; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f7xx_hal_uart.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f7xx_hal_uart.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\..\Library\STM32F7xx_HAL_Driver\Core -I..\..\..\..\Library\STM32F7xx_HAL_Driver\Inc -I..\..\..\..\Library\STM32F7xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\32-Bit_MCU\STM32\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f7xx_hal_uart.crf ..\..\..\..\Library\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_uart.c]
                          THUMB

                          AREA ||i.HAL_HalfDuplex_EnableReceiver||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableReceiver PROC
;;;2083     */
;;;2084   HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2085   {
;;;2086     /* Process Locked */
;;;2087     __HAL_LOCK(huart);
000002  bf00              NOP      
000004  6e88              LDR      r0,[r1,#0x68]
000006  2801              CMP      r0,#1
000008  d101              BNE      |L1.14|
00000a  2002              MOVS     r0,#2
                  |L1.12|
;;;2088     huart->gState = HAL_UART_STATE_BUSY;
;;;2089   
;;;2090     /* Clear TE and RE bits */
;;;2091     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));
;;;2092     /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
;;;2093     SET_BIT(huart->Instance->CR1, USART_CR1_RE);
;;;2094   
;;;2095     huart->gState = HAL_UART_STATE_READY;
;;;2096     /* Process Unlocked */
;;;2097     __HAL_UNLOCK(huart);
;;;2098   
;;;2099     return HAL_OK;
;;;2100   }
00000c  4770              BX       lr
                  |L1.14|
00000e  2001              MOVS     r0,#1                 ;2087
000010  6688              STR      r0,[r1,#0x68]         ;2087
000012  bf00              NOP                            ;2087
000014  2024              MOVS     r0,#0x24              ;2088
000016  66c8              STR      r0,[r1,#0x6c]         ;2088
000018  6808              LDR      r0,[r1,#0]            ;2091
00001a  6800              LDR      r0,[r0,#0]            ;2091
00001c  f020000c          BIC      r0,r0,#0xc            ;2091
000020  680a              LDR      r2,[r1,#0]            ;2091
000022  6010              STR      r0,[r2,#0]            ;2091
000024  6808              LDR      r0,[r1,#0]            ;2093
000026  6800              LDR      r0,[r0,#0]            ;2093
000028  f0400004          ORR      r0,r0,#4              ;2093
00002c  680a              LDR      r2,[r1,#0]            ;2093
00002e  6010              STR      r0,[r2,#0]            ;2093
000030  2020              MOVS     r0,#0x20              ;2095
000032  66c8              STR      r0,[r1,#0x6c]         ;2095
000034  bf00              NOP                            ;2097
000036  2000              MOVS     r0,#0                 ;2097
000038  6688              STR      r0,[r1,#0x68]         ;2097
00003a  bf00              NOP                            ;2097
00003c  bf00              NOP                            ;2099
00003e  e7e5              B        |L1.12|
;;;2101   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_EnableTransmitter||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableTransmitter PROC
;;;2060     */
;;;2061   HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2062   {
;;;2063     /* Process Locked */
;;;2064     __HAL_LOCK(huart);
000002  bf00              NOP      
000004  6e88              LDR      r0,[r1,#0x68]
000006  2801              CMP      r0,#1
000008  d101              BNE      |L2.14|
00000a  2002              MOVS     r0,#2
                  |L2.12|
;;;2065     huart->gState = HAL_UART_STATE_BUSY;
;;;2066   
;;;2067     /* Clear TE and RE bits */
;;;2068     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));
;;;2069     /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
;;;2070     SET_BIT(huart->Instance->CR1, USART_CR1_TE);
;;;2071   
;;;2072     huart->gState= HAL_UART_STATE_READY;
;;;2073     /* Process Unlocked */
;;;2074     __HAL_UNLOCK(huart);
;;;2075   
;;;2076     return HAL_OK;
;;;2077   }
00000c  4770              BX       lr
                  |L2.14|
00000e  2001              MOVS     r0,#1                 ;2064
000010  6688              STR      r0,[r1,#0x68]         ;2064
000012  bf00              NOP                            ;2064
000014  2024              MOVS     r0,#0x24              ;2065
000016  66c8              STR      r0,[r1,#0x6c]         ;2065
000018  6808              LDR      r0,[r1,#0]            ;2068
00001a  6800              LDR      r0,[r0,#0]            ;2068
00001c  f020000c          BIC      r0,r0,#0xc            ;2068
000020  680a              LDR      r2,[r1,#0]            ;2068
000022  6010              STR      r0,[r2,#0]            ;2068
000024  6808              LDR      r0,[r1,#0]            ;2070
000026  6800              LDR      r0,[r0,#0]            ;2070
000028  f0400008          ORR      r0,r0,#8              ;2070
00002c  680a              LDR      r2,[r1,#0]            ;2070
00002e  6010              STR      r0,[r2,#0]            ;2070
000030  2020              MOVS     r0,#0x20              ;2072
000032  66c8              STR      r0,[r1,#0x6c]         ;2072
000034  bf00              NOP                            ;2074
000036  2000              MOVS     r0,#0                 ;2074
000038  6688              STR      r0,[r1,#0x68]         ;2074
00003a  bf00              NOP                            ;2074
00003c  bf00              NOP                            ;2076
00003e  e7e5              B        |L2.12|
;;;2078   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_Init||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_Init PROC
;;;305      */
;;;306    HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;307    {
000002  4604              MOV      r4,r0
;;;308      /* Check the UART handle allocation */
;;;309      if(huart == NULL)
000004  b90c              CBNZ     r4,|L3.10|
;;;310      {
;;;311        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L3.8|
;;;312      }
;;;313    
;;;314      if(huart->gState == HAL_UART_STATE_RESET)
;;;315      {
;;;316        /* Allocate lock resource and initialize it */
;;;317        huart->Lock = HAL_UNLOCKED;
;;;318    
;;;319        /* Init the low level hardware : GPIO, CLOCK */
;;;320        HAL_UART_MspInit(huart);
;;;321      }
;;;322    
;;;323      huart->gState = HAL_UART_STATE_BUSY;
;;;324    
;;;325      /* Disable the Peripheral */
;;;326      __HAL_UART_DISABLE(huart);
;;;327    
;;;328      /* Set the UART Communication parameters */
;;;329      if (UART_SetConfig(huart) == HAL_ERROR)
;;;330      {
;;;331        return HAL_ERROR;
;;;332      }
;;;333    
;;;334      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;335      {
;;;336        UART_AdvFeatureConfig(huart);
;;;337      }
;;;338    
;;;339      /* In half-duplex mode, the following bits must be kept cleared:
;;;340      - LINEN and CLKEN bits in the USART_CR2 register,
;;;341      - SCEN and IREN bits in the USART_CR3 register.*/
;;;342      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;343      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
;;;344    
;;;345      /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;346      SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
;;;347    
;;;348      /* Enable the Peripheral */
;;;349      __HAL_UART_ENABLE(huart);
;;;350    
;;;351      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;352      return (UART_CheckIdleState(huart));
;;;353    }
000008  bd10              POP      {r4,pc}
                  |L3.10|
00000a  6ee0              LDR      r0,[r4,#0x6c]         ;314
00000c  b920              CBNZ     r0,|L3.24|
00000e  2000              MOVS     r0,#0                 ;317
000010  66a0              STR      r0,[r4,#0x68]         ;317
000012  4620              MOV      r0,r4                 ;320
000014  f7fffffe          BL       HAL_UART_MspInit
                  |L3.24|
000018  2024              MOVS     r0,#0x24              ;323
00001a  66e0              STR      r0,[r4,#0x6c]         ;323
00001c  6820              LDR      r0,[r4,#0]            ;326
00001e  6800              LDR      r0,[r0,#0]            ;326
000020  f0200001          BIC      r0,r0,#1              ;326
000024  6821              LDR      r1,[r4,#0]            ;326
000026  6008              STR      r0,[r1,#0]            ;326
000028  4620              MOV      r0,r4                 ;329
00002a  f7fffffe          BL       UART_SetConfig
00002e  2801              CMP      r0,#1                 ;329
000030  d100              BNE      |L3.52|
000032  e7e9              B        |L3.8|
                  |L3.52|
000034  6a60              LDR      r0,[r4,#0x24]         ;334
000036  b110              CBZ      r0,|L3.62|
000038  4620              MOV      r0,r4                 ;336
00003a  f7fffffe          BL       UART_AdvFeatureConfig
                  |L3.62|
00003e  6820              LDR      r0,[r4,#0]            ;342
000040  6840              LDR      r0,[r0,#4]            ;342
000042  f4204090          BIC      r0,r0,#0x4800         ;342
000046  6821              LDR      r1,[r4,#0]            ;342
000048  6048              STR      r0,[r1,#4]            ;342
00004a  6820              LDR      r0,[r4,#0]            ;343
00004c  6880              LDR      r0,[r0,#8]            ;343
00004e  f0200022          BIC      r0,r0,#0x22           ;343
000052  6821              LDR      r1,[r4,#0]            ;343
000054  6088              STR      r0,[r1,#8]            ;343
000056  6820              LDR      r0,[r4,#0]            ;346
000058  6880              LDR      r0,[r0,#8]            ;346
00005a  f0400008          ORR      r0,r0,#8              ;346
00005e  6821              LDR      r1,[r4,#0]            ;346
000060  6088              STR      r0,[r1,#8]            ;346
000062  6820              LDR      r0,[r4,#0]            ;349
000064  6800              LDR      r0,[r0,#0]            ;349
000066  f0400001          ORR      r0,r0,#1              ;349
00006a  6821              LDR      r1,[r4,#0]            ;349
00006c  6008              STR      r0,[r1,#0]            ;349
00006e  4620              MOV      r0,r4                 ;352
000070  f7fffffe          BL       UART_CheckIdleState
000074  e7c8              B        |L3.8|
;;;354    
                          ENDP


                          AREA ||i.HAL_LIN_Init||, CODE, READONLY, ALIGN=1

                  HAL_LIN_Init PROC
;;;365      */
;;;366    HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
000000  b570              PUSH     {r4-r6,lr}
;;;367    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;368      /* Check the UART handle allocation */
;;;369      if(huart == NULL)
000006  b90c              CBNZ     r4,|L4.12|
;;;370      {
;;;371        return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L4.10|
;;;372      }
;;;373    
;;;374      /* Check the parameters */
;;;375      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;376      assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
;;;377      assert_param(IS_LIN_WORD_LENGTH(huart->Init.WordLength));
;;;378    
;;;379      if(huart->gState == HAL_UART_STATE_RESET)
;;;380      {
;;;381        /* Allocate lock resource and initialize it */
;;;382        huart->Lock = HAL_UNLOCKED;
;;;383    
;;;384        /* Init the low level hardware : GPIO, CLOCK */
;;;385        HAL_UART_MspInit(huart);
;;;386      }
;;;387    
;;;388      huart->gState = HAL_UART_STATE_BUSY;
;;;389    
;;;390      /* Disable the Peripheral */
;;;391      __HAL_UART_DISABLE(huart);
;;;392    
;;;393      /* Set the UART Communication parameters */
;;;394      if (UART_SetConfig(huart) == HAL_ERROR)
;;;395      {
;;;396        return HAL_ERROR;
;;;397      }
;;;398    
;;;399      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;400      {
;;;401        UART_AdvFeatureConfig(huart);
;;;402      }
;;;403    
;;;404      /* In LIN mode, the following bits must be kept cleared:
;;;405      - LINEN and CLKEN bits in the USART_CR2 register,
;;;406      - SCEN and IREN bits in the USART_CR3 register.*/
;;;407      CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
;;;408      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
;;;409    
;;;410      /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;411      SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
;;;412    
;;;413      /* Set the USART LIN Break detection length. */
;;;414      MODIFY_REG(huart->Instance->CR2, USART_CR2_LBDL, BreakDetectLength);
;;;415    
;;;416      /* Enable the Peripheral */
;;;417      __HAL_UART_ENABLE(huart);
;;;418    
;;;419      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;420      return (UART_CheckIdleState(huart));
;;;421    }
00000a  bd70              POP      {r4-r6,pc}
                  |L4.12|
00000c  6ee0              LDR      r0,[r4,#0x6c]         ;379
00000e  b920              CBNZ     r0,|L4.26|
000010  2000              MOVS     r0,#0                 ;382
000012  66a0              STR      r0,[r4,#0x68]         ;382
000014  4620              MOV      r0,r4                 ;385
000016  f7fffffe          BL       HAL_UART_MspInit
                  |L4.26|
00001a  2024              MOVS     r0,#0x24              ;388
00001c  66e0              STR      r0,[r4,#0x6c]         ;388
00001e  6820              LDR      r0,[r4,#0]            ;391
000020  6800              LDR      r0,[r0,#0]            ;391
000022  f0200001          BIC      r0,r0,#1              ;391
000026  6821              LDR      r1,[r4,#0]            ;391
000028  6008              STR      r0,[r1,#0]            ;391
00002a  4620              MOV      r0,r4                 ;394
00002c  f7fffffe          BL       UART_SetConfig
000030  2801              CMP      r0,#1                 ;394
000032  d100              BNE      |L4.54|
000034  e7e9              B        |L4.10|
                  |L4.54|
000036  6a60              LDR      r0,[r4,#0x24]         ;399
000038  b110              CBZ      r0,|L4.64|
00003a  4620              MOV      r0,r4                 ;401
00003c  f7fffffe          BL       UART_AdvFeatureConfig
                  |L4.64|
000040  6820              LDR      r0,[r4,#0]            ;407
000042  6840              LDR      r0,[r0,#4]            ;407
000044  f4206000          BIC      r0,r0,#0x800          ;407
000048  6821              LDR      r1,[r4,#0]            ;407
00004a  6048              STR      r0,[r1,#4]            ;407
00004c  6820              LDR      r0,[r4,#0]            ;408
00004e  6880              LDR      r0,[r0,#8]            ;408
000050  f020002a          BIC      r0,r0,#0x2a           ;408
000054  6821              LDR      r1,[r4,#0]            ;408
000056  6088              STR      r0,[r1,#8]            ;408
000058  6820              LDR      r0,[r4,#0]            ;411
00005a  6840              LDR      r0,[r0,#4]            ;411
00005c  f4404080          ORR      r0,r0,#0x4000         ;411
000060  6821              LDR      r1,[r4,#0]            ;411
000062  6048              STR      r0,[r1,#4]            ;411
000064  6820              LDR      r0,[r4,#0]            ;414
000066  6840              LDR      r0,[r0,#4]            ;414
000068  f0200020          BIC      r0,r0,#0x20           ;414
00006c  4328              ORRS     r0,r0,r5              ;414
00006e  6821              LDR      r1,[r4,#0]            ;414
000070  6048              STR      r0,[r1,#4]            ;414
000072  6820              LDR      r0,[r4,#0]            ;417
000074  6800              LDR      r0,[r0,#0]            ;417
000076  f0400001          ORR      r0,r0,#1              ;417
00007a  6821              LDR      r1,[r4,#0]            ;417
00007c  6008              STR      r0,[r1,#0]            ;417
00007e  4620              MOV      r0,r4                 ;420
000080  f7fffffe          BL       UART_CheckIdleState
000084  e7c1              B        |L4.10|
;;;422    
                          ENDP


                          AREA ||i.HAL_LIN_SendBreak||, CODE, READONLY, ALIGN=1

                  HAL_LIN_SendBreak PROC
;;;2107     */
;;;2108   HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2109   {
;;;2110     /* Check the parameters */
;;;2111     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;2112   
;;;2113     /* Process Locked */
;;;2114     __HAL_LOCK(huart);
000002  bf00              NOP      
000004  6e88              LDR      r0,[r1,#0x68]
000006  2801              CMP      r0,#1
000008  d101              BNE      |L5.14|
00000a  2002              MOVS     r0,#2
                  |L5.12|
;;;2115   
;;;2116     huart->gState = HAL_UART_STATE_BUSY;
;;;2117   
;;;2118     /* Send break characters */
;;;2119     SET_BIT(huart->Instance->RQR, UART_SENDBREAK_REQUEST);
;;;2120   
;;;2121     huart->gState = HAL_UART_STATE_READY;
;;;2122   
;;;2123     /* Process Unlocked */
;;;2124     __HAL_UNLOCK(huart);
;;;2125   
;;;2126     return HAL_OK;
;;;2127   }
00000c  4770              BX       lr
                  |L5.14|
00000e  2001              MOVS     r0,#1                 ;2114
000010  6688              STR      r0,[r1,#0x68]         ;2114
000012  bf00              NOP                            ;2114
000014  2024              MOVS     r0,#0x24              ;2116
000016  66c8              STR      r0,[r1,#0x6c]         ;2116
000018  6808              LDR      r0,[r1,#0]            ;2119
00001a  6980              LDR      r0,[r0,#0x18]         ;2119
00001c  f0400002          ORR      r0,r0,#2              ;2119
000020  680a              LDR      r2,[r1,#0]            ;2119
000022  6190              STR      r0,[r2,#0x18]         ;2119
000024  2020              MOVS     r0,#0x20              ;2121
000026  66c8              STR      r0,[r1,#0x6c]         ;2121
000028  bf00              NOP                            ;2124
00002a  2000              MOVS     r0,#0                 ;2124
00002c  6688              STR      r0,[r1,#0x68]         ;2124
00002e  bf00              NOP                            ;2124
000030  bf00              NOP                            ;2126
000032  e7eb              B        |L5.12|
;;;2128   
                          ENDP


                          AREA ||i.HAL_MultiProcessorEx_AddressLength_Set||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessorEx_AddressLength_Set PROC
;;;2141     */
;;;2142   HAL_StatusTypeDef HAL_MultiProcessorEx_AddressLength_Set(UART_HandleTypeDef *huart, uint32_t AddressLength)
000000  b570              PUSH     {r4-r6,lr}
;;;2143   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2144     /* Check the UART handle allocation */
;;;2145     if(huart == NULL)
000006  b90c              CBNZ     r4,|L6.12|
;;;2146     {
;;;2147       return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L6.10|
;;;2148     }
;;;2149   
;;;2150     /* Check the address length parameter */
;;;2151     assert_param(IS_UART_ADDRESSLENGTH_DETECT(AddressLength));
;;;2152   
;;;2153     huart->gState = HAL_UART_STATE_BUSY;
;;;2154   
;;;2155     /* Disable the Peripheral */
;;;2156     __HAL_UART_DISABLE(huart);
;;;2157   
;;;2158     /* Set the address length */
;;;2159     MODIFY_REG(huart->Instance->CR2, USART_CR2_ADDM7, AddressLength);
;;;2160   
;;;2161     /* Enable the Peripheral */
;;;2162     __HAL_UART_ENABLE(huart);
;;;2163   
;;;2164     /* TEACK and/or REACK to check before moving huart->gState to Ready */
;;;2165     return (UART_CheckIdleState(huart));
;;;2166   }
00000a  bd70              POP      {r4-r6,pc}
                  |L6.12|
00000c  2024              MOVS     r0,#0x24              ;2153
00000e  66e0              STR      r0,[r4,#0x6c]         ;2153
000010  6820              LDR      r0,[r4,#0]            ;2156
000012  6800              LDR      r0,[r0,#0]            ;2156
000014  f0200001          BIC      r0,r0,#1              ;2156
000018  6821              LDR      r1,[r4,#0]            ;2156
00001a  6008              STR      r0,[r1,#0]            ;2156
00001c  6820              LDR      r0,[r4,#0]            ;2159
00001e  6840              LDR      r0,[r0,#4]            ;2159
000020  f0200010          BIC      r0,r0,#0x10           ;2159
000024  4328              ORRS     r0,r0,r5              ;2159
000026  6821              LDR      r1,[r4,#0]            ;2159
000028  6048              STR      r0,[r1,#4]            ;2159
00002a  6820              LDR      r0,[r4,#0]            ;2162
00002c  6800              LDR      r0,[r0,#0]            ;2162
00002e  f0400001          ORR      r0,r0,#1              ;2162
000032  6821              LDR      r1,[r4,#0]            ;2162
000034  6008              STR      r0,[r1,#0]            ;2162
000036  4620              MOV      r0,r4                 ;2165
000038  f7fffffe          BL       UART_CheckIdleState
00003c  e7e5              B        |L6.10|
;;;2167   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_DisableMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_DisableMuteMode PROC
;;;1769     */
;;;1770   HAL_StatusTypeDef HAL_MultiProcessor_DisableMuteMode(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1771   {
000002  4604              MOV      r4,r0
;;;1772     /* Process Locked */
;;;1773     __HAL_LOCK(huart);
000004  bf00              NOP      
000006  6ea0              LDR      r0,[r4,#0x68]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L7.16|
00000c  2002              MOVS     r0,#2
                  |L7.14|
;;;1774   
;;;1775     huart->gState = HAL_UART_STATE_BUSY;
;;;1776   
;;;1777      /* Disable USART mute mode by clearing the MME bit in the CR1 register */
;;;1778     CLEAR_BIT(huart->Instance->CR1, USART_CR1_MME);
;;;1779   
;;;1780     huart->gState = HAL_UART_STATE_READY;
;;;1781   
;;;1782     return (UART_CheckIdleState(huart));
;;;1783   }
00000e  bd10              POP      {r4,pc}
                  |L7.16|
000010  2001              MOVS     r0,#1                 ;1773
000012  66a0              STR      r0,[r4,#0x68]         ;1773
000014  bf00              NOP                            ;1773
000016  2024              MOVS     r0,#0x24              ;1775
000018  66e0              STR      r0,[r4,#0x6c]         ;1775
00001a  6820              LDR      r0,[r4,#0]            ;1778
00001c  6800              LDR      r0,[r0,#0]            ;1778
00001e  f4205000          BIC      r0,r0,#0x2000         ;1778
000022  6821              LDR      r1,[r4,#0]            ;1778
000024  6008              STR      r0,[r1,#0]            ;1778
000026  2020              MOVS     r0,#0x20              ;1780
000028  66e0              STR      r0,[r4,#0x6c]         ;1780
00002a  4620              MOV      r0,r4                 ;1782
00002c  f7fffffe          BL       UART_CheckIdleState
000030  e7ed              B        |L7.14|
;;;1784   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnableMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnableMuteMode PROC
;;;1748     */
;;;1749   HAL_StatusTypeDef HAL_MultiProcessor_EnableMuteMode(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1750   {
000002  4604              MOV      r4,r0
;;;1751     /* Process Locked */
;;;1752     __HAL_LOCK(huart);
000004  bf00              NOP      
000006  6ea0              LDR      r0,[r4,#0x68]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L8.16|
00000c  2002              MOVS     r0,#2
                  |L8.14|
;;;1753   
;;;1754     huart->gState = HAL_UART_STATE_BUSY;
;;;1755   
;;;1756     /* Enable USART mute mode by setting the MME bit in the CR1 register */
;;;1757     SET_BIT(huart->Instance->CR1, USART_CR1_MME);
;;;1758   
;;;1759     huart->gState = HAL_UART_STATE_READY;
;;;1760   
;;;1761     return (UART_CheckIdleState(huart));
;;;1762   }
00000e  bd10              POP      {r4,pc}
                  |L8.16|
000010  2001              MOVS     r0,#1                 ;1752
000012  66a0              STR      r0,[r4,#0x68]         ;1752
000014  bf00              NOP                            ;1752
000016  2024              MOVS     r0,#0x24              ;1754
000018  66e0              STR      r0,[r4,#0x6c]         ;1754
00001a  6820              LDR      r0,[r4,#0]            ;1757
00001c  6800              LDR      r0,[r0,#0]            ;1757
00001e  f4405000          ORR      r0,r0,#0x2000         ;1757
000022  6821              LDR      r1,[r4,#0]            ;1757
000024  6008              STR      r0,[r1,#0]            ;1757
000026  2020              MOVS     r0,#0x20              ;1759
000028  66e0              STR      r0,[r4,#0x6c]         ;1759
00002a  4620              MOV      r0,r4                 ;1761
00002c  f7fffffe          BL       UART_CheckIdleState
000030  e7ed              B        |L8.14|
;;;1763   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnterMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnterMuteMode PROC
;;;1790     */
;;;1791   void HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
000000  6801              LDR      r1,[r0,#0]
;;;1792   {
;;;1793     __HAL_UART_SEND_REQ(huart, UART_MUTE_MODE_REQUEST);
000002  6989              LDR      r1,[r1,#0x18]
000004  f0410104          ORR      r1,r1,#4
000008  6802              LDR      r2,[r0,#0]
00000a  6191              STR      r1,[r2,#0x18]
;;;1794   }
00000c  4770              BX       lr
;;;1795   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_Init||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_Init PROC
;;;439      */
;;;440    HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
000000  b570              PUSH     {r4-r6,lr}
;;;441    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;442      /* Check the UART handle allocation */
;;;443      if(huart == NULL)
000008  b90c              CBNZ     r4,|L10.14|
;;;444      {
;;;445        return HAL_ERROR;
00000a  2001              MOVS     r0,#1
                  |L10.12|
;;;446      }
;;;447    
;;;448      /* Check the wake up method parameter */
;;;449      assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
;;;450    
;;;451      if(huart->gState == HAL_UART_STATE_RESET)
;;;452      {
;;;453        /* Allocate lock resource and initialize it */
;;;454        huart->Lock = HAL_UNLOCKED;
;;;455    
;;;456        /* Init the low level hardware : GPIO, CLOCK */
;;;457        HAL_UART_MspInit(huart);
;;;458      }
;;;459    
;;;460      huart->gState = HAL_UART_STATE_BUSY;
;;;461    
;;;462      /* Disable the Peripheral */
;;;463      __HAL_UART_DISABLE(huart);
;;;464    
;;;465      /* Set the UART Communication parameters */
;;;466      if (UART_SetConfig(huart) == HAL_ERROR)
;;;467      {
;;;468        return HAL_ERROR;
;;;469      }
;;;470    
;;;471      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;472      {
;;;473        UART_AdvFeatureConfig(huart);
;;;474      }
;;;475    
;;;476      /* In multiprocessor mode, the following bits must be kept cleared:
;;;477      - LINEN and CLKEN bits in the USART_CR2 register,
;;;478      - SCEN, HDSEL and IREN  bits in the USART_CR3 register. */
;;;479      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;480      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;481    
;;;482      if (WakeUpMethod == UART_WAKEUPMETHOD_ADDRESSMARK)
;;;483      {
;;;484        /* If address mark wake up method is chosen, set the USART address node */
;;;485        MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, ((uint32_t)Address << UART_CR2_ADDRESS_LSB_POS));
;;;486      }
;;;487    
;;;488      /* Set the wake up method by setting the WAKE bit in the CR1 register */
;;;489      MODIFY_REG(huart->Instance->CR1, USART_CR1_WAKE, WakeUpMethod);
;;;490    
;;;491      /* Enable the Peripheral */
;;;492      __HAL_UART_ENABLE(huart);
;;;493    
;;;494      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;495      return (UART_CheckIdleState(huart));
;;;496    }
00000c  bd70              POP      {r4-r6,pc}
                  |L10.14|
00000e  6ee0              LDR      r0,[r4,#0x6c]         ;451
000010  b920              CBNZ     r0,|L10.28|
000012  2000              MOVS     r0,#0                 ;454
000014  66a0              STR      r0,[r4,#0x68]         ;454
000016  4620              MOV      r0,r4                 ;457
000018  f7fffffe          BL       HAL_UART_MspInit
                  |L10.28|
00001c  2024              MOVS     r0,#0x24              ;460
00001e  66e0              STR      r0,[r4,#0x6c]         ;460
000020  6820              LDR      r0,[r4,#0]            ;463
000022  6800              LDR      r0,[r0,#0]            ;463
000024  f0200001          BIC      r0,r0,#1              ;463
000028  6821              LDR      r1,[r4,#0]            ;463
00002a  6008              STR      r0,[r1,#0]            ;463
00002c  4620              MOV      r0,r4                 ;466
00002e  f7fffffe          BL       UART_SetConfig
000032  2801              CMP      r0,#1                 ;466
000034  d100              BNE      |L10.56|
000036  e7e9              B        |L10.12|
                  |L10.56|
000038  6a60              LDR      r0,[r4,#0x24]         ;471
00003a  b110              CBZ      r0,|L10.66|
00003c  4620              MOV      r0,r4                 ;473
00003e  f7fffffe          BL       UART_AdvFeatureConfig
                  |L10.66|
000042  6820              LDR      r0,[r4,#0]            ;479
000044  6840              LDR      r0,[r0,#4]            ;479
000046  f4204090          BIC      r0,r0,#0x4800         ;479
00004a  6821              LDR      r1,[r4,#0]            ;479
00004c  6048              STR      r0,[r1,#4]            ;479
00004e  6820              LDR      r0,[r4,#0]            ;480
000050  6880              LDR      r0,[r0,#8]            ;480
000052  f020002a          BIC      r0,r0,#0x2a           ;480
000056  6821              LDR      r1,[r4,#0]            ;480
000058  6088              STR      r0,[r1,#8]            ;480
00005a  f5b56f00          CMP      r5,#0x800             ;482
00005e  d105              BNE      |L10.108|
000060  6820              LDR      r0,[r4,#0]            ;485
000062  6840              LDR      r0,[r0,#4]            ;485
000064  f366601f          BFI      r0,r6,#24,#8          ;485
000068  6821              LDR      r1,[r4,#0]            ;485
00006a  6048              STR      r0,[r1,#4]            ;485
                  |L10.108|
00006c  6820              LDR      r0,[r4,#0]            ;489
00006e  6800              LDR      r0,[r0,#0]            ;489
000070  f4206000          BIC      r0,r0,#0x800          ;489
000074  4328              ORRS     r0,r0,r5              ;489
000076  6821              LDR      r1,[r4,#0]            ;489
000078  6008              STR      r0,[r1,#0]            ;489
00007a  6820              LDR      r0,[r4,#0]            ;492
00007c  6800              LDR      r0,[r0,#0]            ;492
00007e  f0400001          ORR      r0,r0,#1              ;492
000082  6821              LDR      r1,[r4,#0]            ;492
000084  6008              STR      r0,[r1,#0]            ;492
000086  4620              MOV      r0,r4                 ;495
000088  f7fffffe          BL       UART_CheckIdleState
00008c  e7be              B        |L10.12|
;;;497    
                          ENDP


                          AREA ||i.HAL_RS485Ex_Init||, CODE, READONLY, ALIGN=2

                  HAL_RS485Ex_Init PROC
;;;517      */
;;;518    HAL_StatusTypeDef HAL_RS485Ex_Init(UART_HandleTypeDef *huart, uint32_t Polarity, uint32_t AssertionTime, uint32_t DeassertionTime)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;519    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;520      uint32_t temp = 0x0;
00000c  f04f0800          MOV      r8,#0
;;;521    
;;;522      /* Check the UART handle allocation */
;;;523      if(huart == NULL)
000010  b914              CBNZ     r4,|L11.24|
;;;524      {
;;;525        return HAL_ERROR;
000012  2001              MOVS     r0,#1
                  |L11.20|
;;;526      }
;;;527      /* Check the Driver Enable UART instance */
;;;528      assert_param(IS_UART_DRIVER_ENABLE_INSTANCE(huart->Instance));
;;;529    
;;;530      /* Check the Driver Enable polarity */
;;;531      assert_param(IS_UART_DE_POLARITY(Polarity));
;;;532    
;;;533      /* Check the Driver Enable assertion time */
;;;534      assert_param(IS_UART_ASSERTIONTIME(AssertionTime));
;;;535    
;;;536      /* Check the Driver Enable deassertion time */
;;;537      assert_param(IS_UART_DEASSERTIONTIME(DeassertionTime));
;;;538    
;;;539      if(huart->gState == HAL_UART_STATE_RESET)
;;;540      {
;;;541        /* Allocate lock resource and initialize it */
;;;542        huart->Lock = HAL_UNLOCKED;
;;;543    
;;;544        /* Init the low level hardware : GPIO, CLOCK, CORTEX */
;;;545        HAL_UART_MspInit(huart);
;;;546      }
;;;547    
;;;548      huart->gState = HAL_UART_STATE_BUSY;
;;;549    
;;;550      /* Disable the Peripheral */
;;;551      __HAL_UART_DISABLE(huart);
;;;552    
;;;553      /* Set the UART Communication parameters */
;;;554      if (UART_SetConfig(huart) == HAL_ERROR)
;;;555      {
;;;556        return HAL_ERROR;
;;;557      }
;;;558    
;;;559      if(huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;560      {
;;;561        UART_AdvFeatureConfig(huart);
;;;562      }
;;;563    
;;;564      /* Enable the Driver Enable mode by setting the DEM bit in the CR3 register */
;;;565      SET_BIT(huart->Instance->CR3, USART_CR3_DEM);
;;;566    
;;;567      /* Set the Driver Enable polarity */
;;;568      MODIFY_REG(huart->Instance->CR3, USART_CR3_DEP, Polarity);
;;;569    
;;;570      /* Set the Driver Enable assertion and deassertion times */
;;;571      temp = (AssertionTime << UART_CR1_DEAT_ADDRESS_LSB_POS);
;;;572      temp |= (DeassertionTime << UART_CR1_DEDT_ADDRESS_LSB_POS);
;;;573      MODIFY_REG(huart->Instance->CR1, (USART_CR1_DEDT|USART_CR1_DEAT), temp);
;;;574    
;;;575      /* Enable the Peripheral */
;;;576      __HAL_UART_ENABLE(huart);
;;;577    
;;;578      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;579      return (UART_CheckIdleState(huart));
;;;580    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L11.24|
000018  6ee0              LDR      r0,[r4,#0x6c]         ;539
00001a  b920              CBNZ     r0,|L11.38|
00001c  2000              MOVS     r0,#0                 ;542
00001e  66a0              STR      r0,[r4,#0x68]         ;542
000020  4620              MOV      r0,r4                 ;545
000022  f7fffffe          BL       HAL_UART_MspInit
                  |L11.38|
000026  2024              MOVS     r0,#0x24              ;548
000028  66e0              STR      r0,[r4,#0x6c]         ;548
00002a  6820              LDR      r0,[r4,#0]            ;551
00002c  6800              LDR      r0,[r0,#0]            ;551
00002e  f0200001          BIC      r0,r0,#1              ;551
000032  6821              LDR      r1,[r4,#0]            ;551
000034  6008              STR      r0,[r1,#0]            ;551
000036  4620              MOV      r0,r4                 ;554
000038  f7fffffe          BL       UART_SetConfig
00003c  2801              CMP      r0,#1                 ;554
00003e  d100              BNE      |L11.66|
000040  e7e8              B        |L11.20|
                  |L11.66|
000042  6a60              LDR      r0,[r4,#0x24]         ;559
000044  b110              CBZ      r0,|L11.76|
000046  4620              MOV      r0,r4                 ;561
000048  f7fffffe          BL       UART_AdvFeatureConfig
                  |L11.76|
00004c  6820              LDR      r0,[r4,#0]            ;565
00004e  6880              LDR      r0,[r0,#8]            ;565
000050  f4404080          ORR      r0,r0,#0x4000         ;565
000054  6821              LDR      r1,[r4,#0]            ;565
000056  6088              STR      r0,[r1,#8]            ;565
000058  6820              LDR      r0,[r4,#0]            ;568
00005a  6880              LDR      r0,[r0,#8]            ;568
00005c  f4204000          BIC      r0,r0,#0x8000         ;568
000060  4328              ORRS     r0,r0,r5              ;568
000062  6821              LDR      r1,[r4,#0]            ;568
000064  6088              STR      r0,[r1,#8]            ;568
000066  ea4f5846          LSL      r8,r6,#21             ;571
00006a  ea484807          ORR      r8,r8,r7,LSL #16      ;572
00006e  6820              LDR      r0,[r4,#0]            ;573
000070  6800              LDR      r0,[r0,#0]            ;573
000072  4908              LDR      r1,|L11.148|
000074  4008              ANDS     r0,r0,r1              ;573
000076  ea400008          ORR      r0,r0,r8              ;573
00007a  6821              LDR      r1,[r4,#0]            ;573
00007c  6008              STR      r0,[r1,#0]            ;573
00007e  6820              LDR      r0,[r4,#0]            ;576
000080  6800              LDR      r0,[r0,#0]            ;576
000082  f0400001          ORR      r0,r0,#1              ;576
000086  6821              LDR      r1,[r4,#0]            ;576
000088  6008              STR      r0,[r1,#0]            ;576
00008a  4620              MOV      r0,r4                 ;579
00008c  f7fffffe          BL       UART_CheckIdleState
000090  e7c0              B        |L11.20|
;;;581    
                          ENDP

000092  0000              DCW      0x0000
                  |L11.148|
                          DCD      0xfc00ffff

                          AREA ||i.HAL_UART_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAPause PROC
;;;1076     */
;;;1077   HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;1078   {
;;;1079     /* Process Locked */
;;;1080     __HAL_LOCK(huart);
000002  bf00              NOP      
000004  6e88              LDR      r0,[r1,#0x68]
000006  2801              CMP      r0,#1
000008  d101              BNE      |L12.14|
00000a  2002              MOVS     r0,#2
                  |L12.12|
;;;1081   
;;;1082     if ((huart->gState == HAL_UART_STATE_BUSY_TX) &&
;;;1083         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)))
;;;1084     {
;;;1085       /* Disable the UART DMA Tx request */
;;;1086       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1087     }
;;;1088     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) &&
;;;1089         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
;;;1090     {
;;;1091       /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1092       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1093       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1094   
;;;1095       /* Disable the UART DMA Rx request */
;;;1096       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1097     }
;;;1098   
;;;1099     /* Process Unlocked */
;;;1100     __HAL_UNLOCK(huart);
;;;1101   
;;;1102     return HAL_OK;
;;;1103   }
00000c  4770              BX       lr
                  |L12.14|
00000e  2001              MOVS     r0,#1                 ;1080
000010  6688              STR      r0,[r1,#0x68]         ;1080
000012  bf00              NOP                            ;1080
000014  6ec8              LDR      r0,[r1,#0x6c]         ;1082
000016  2821              CMP      r0,#0x21              ;1082
000018  d10a              BNE      |L12.48|
00001a  6808              LDR      r0,[r1,#0]            ;1083
00001c  6880              LDR      r0,[r0,#8]            ;1083
00001e  f0000080          AND      r0,r0,#0x80           ;1083
000022  b128              CBZ      r0,|L12.48|
000024  6808              LDR      r0,[r1,#0]            ;1086
000026  6880              LDR      r0,[r0,#8]            ;1086
000028  f0200080          BIC      r0,r0,#0x80           ;1086
00002c  680a              LDR      r2,[r1,#0]            ;1086
00002e  6090              STR      r0,[r2,#8]            ;1086
                  |L12.48|
000030  6f08              LDR      r0,[r1,#0x70]         ;1088
000032  2822              CMP      r0,#0x22              ;1088
000034  d116              BNE      |L12.100|
000036  6808              LDR      r0,[r1,#0]            ;1089
000038  6880              LDR      r0,[r0,#8]            ;1089
00003a  f0000040          AND      r0,r0,#0x40           ;1089
00003e  b188              CBZ      r0,|L12.100|
000040  6808              LDR      r0,[r1,#0]            ;1092
000042  6800              LDR      r0,[r0,#0]            ;1092
000044  f4207080          BIC      r0,r0,#0x100          ;1092
000048  680a              LDR      r2,[r1,#0]            ;1092
00004a  6010              STR      r0,[r2,#0]            ;1092
00004c  6808              LDR      r0,[r1,#0]            ;1093
00004e  6880              LDR      r0,[r0,#8]            ;1093
000050  f0200001          BIC      r0,r0,#1              ;1093
000054  680a              LDR      r2,[r1,#0]            ;1093
000056  6090              STR      r0,[r2,#8]            ;1093
000058  6808              LDR      r0,[r1,#0]            ;1096
00005a  6880              LDR      r0,[r0,#8]            ;1096
00005c  f0200040          BIC      r0,r0,#0x40           ;1096
000060  680a              LDR      r2,[r1,#0]            ;1096
000062  6090              STR      r0,[r2,#8]            ;1096
                  |L12.100|
000064  bf00              NOP                            ;1100
000066  2000              MOVS     r0,#0                 ;1100
000068  6688              STR      r0,[r1,#0x68]         ;1100
00006a  bf00              NOP                            ;1100
00006c  bf00              NOP                            ;1102
00006e  e7cd              B        |L12.12|
;;;1104   
                          ENDP


                          AREA ||i.HAL_UART_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAResume PROC
;;;1109     */
;;;1110   HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;1111   {
;;;1112     /* Process Locked */
;;;1113     __HAL_LOCK(huart);
000002  bf00              NOP      
000004  6e88              LDR      r0,[r1,#0x68]
000006  2801              CMP      r0,#1
000008  d101              BNE      |L13.14|
00000a  2002              MOVS     r0,#2
                  |L13.12|
;;;1114   
;;;1115     if(huart->gState == HAL_UART_STATE_BUSY_TX)
;;;1116     {
;;;1117       /* Enable the UART DMA Tx request */
;;;1118       SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1119     }
;;;1120     if(huart->RxState == HAL_UART_STATE_BUSY_RX)
;;;1121     {
;;;1122       /* Clear the Overrun flag before resuming the Rx transfer*/
;;;1123       __HAL_UART_CLEAR_IT(huart, UART_CLEAR_OREF);
;;;1124   
;;;1125       /* Reenable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1126       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1127       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1128   
;;;1129       /* Enable the UART DMA Rx request */
;;;1130       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1131     }
;;;1132   
;;;1133     /* If the UART peripheral is still not enabled, enable it */
;;;1134     if ((huart->Instance->CR1 & USART_CR1_UE) == 0U)
;;;1135     {
;;;1136       /* Enable UART peripheral */
;;;1137       __HAL_UART_ENABLE(huart);
;;;1138     }
;;;1139   
;;;1140     return HAL_OK;
;;;1141   }
00000c  4770              BX       lr
                  |L13.14|
00000e  2001              MOVS     r0,#1                 ;1113
000010  6688              STR      r0,[r1,#0x68]         ;1113
000012  bf00              NOP                            ;1113
000014  6ec8              LDR      r0,[r1,#0x6c]         ;1115
000016  2821              CMP      r0,#0x21              ;1115
000018  d105              BNE      |L13.38|
00001a  6808              LDR      r0,[r1,#0]            ;1118
00001c  6880              LDR      r0,[r0,#8]            ;1118
00001e  f0400080          ORR      r0,r0,#0x80           ;1118
000022  680a              LDR      r2,[r1,#0]            ;1118
000024  6090              STR      r0,[r2,#8]            ;1118
                  |L13.38|
000026  6f08              LDR      r0,[r1,#0x70]         ;1120
000028  2822              CMP      r0,#0x22              ;1120
00002a  d114              BNE      |L13.86|
00002c  2008              MOVS     r0,#8                 ;1123
00002e  680a              LDR      r2,[r1,#0]            ;1123
000030  6210              STR      r0,[r2,#0x20]         ;1123
000032  6808              LDR      r0,[r1,#0]            ;1126
000034  6800              LDR      r0,[r0,#0]            ;1126
000036  f4407080          ORR      r0,r0,#0x100          ;1126
00003a  680a              LDR      r2,[r1,#0]            ;1126
00003c  6010              STR      r0,[r2,#0]            ;1126
00003e  6808              LDR      r0,[r1,#0]            ;1127
000040  6880              LDR      r0,[r0,#8]            ;1127
000042  f0400001          ORR      r0,r0,#1              ;1127
000046  680a              LDR      r2,[r1,#0]            ;1127
000048  6090              STR      r0,[r2,#8]            ;1127
00004a  6808              LDR      r0,[r1,#0]            ;1130
00004c  6880              LDR      r0,[r0,#8]            ;1130
00004e  f0400040          ORR      r0,r0,#0x40           ;1130
000052  680a              LDR      r2,[r1,#0]            ;1130
000054  6090              STR      r0,[r2,#8]            ;1130
                  |L13.86|
000056  6808              LDR      r0,[r1,#0]            ;1134
000058  6800              LDR      r0,[r0,#0]            ;1134
00005a  f0000001          AND      r0,r0,#1              ;1134
00005e  b928              CBNZ     r0,|L13.108|
000060  6808              LDR      r0,[r1,#0]            ;1137
000062  6800              LDR      r0,[r0,#0]            ;1137
000064  f0400001          ORR      r0,r0,#1              ;1137
000068  680a              LDR      r2,[r1,#0]            ;1137
00006a  6010              STR      r0,[r2,#0]            ;1137
                  |L13.108|
00006c  2000              MOVS     r0,#0                 ;1140
00006e  e7cd              B        |L13.12|
;;;1142   
                          ENDP


                          AREA ||i.HAL_UART_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAStop PROC
;;;1147     */
;;;1148   HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1149   {
000002  4604              MOV      r4,r0
;;;1150     /* The Lock is not implemented on this API to allow the user application
;;;1151        to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback() /
;;;1152        HAL_UART_TxHalfCpltCallback / HAL_UART_RxHalfCpltCallback:
;;;1153        indeed, when HAL_DMA_Abort() API is called, the DMA TX/RX Transfer or Half Transfer complete
;;;1154        interrupt is generated if the DMA transfer interruption occurs at the middle or at the end of
;;;1155        the stream and the corresponding call back is executed. */
;;;1156   
;;;1157     /* Stop UART DMA Tx request if ongoing */
;;;1158     if ((huart->gState == HAL_UART_STATE_BUSY_TX) &&
000004  6ee0              LDR      r0,[r4,#0x6c]
000006  2821              CMP      r0,#0x21
000008  d112              BNE      |L14.48|
;;;1159         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)))
00000a  6820              LDR      r0,[r4,#0]
00000c  6880              LDR      r0,[r0,#8]
00000e  f0000080          AND      r0,r0,#0x80
000012  b168              CBZ      r0,|L14.48|
;;;1160     {
;;;1161       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000014  6820              LDR      r0,[r4,#0]
000016  6880              LDR      r0,[r0,#8]
000018  f0200080          BIC      r0,r0,#0x80
00001c  6821              LDR      r1,[r4,#0]
00001e  6088              STR      r0,[r1,#8]
;;;1162   
;;;1163       /* Abort the UART DMA Tx channel */
;;;1164       if(huart->hdmatx != NULL)
000020  6e20              LDR      r0,[r4,#0x60]
000022  b110              CBZ      r0,|L14.42|
;;;1165       {
;;;1166         HAL_DMA_Abort(huart->hdmatx);
000024  6e20              LDR      r0,[r4,#0x60]
000026  f7fffffe          BL       HAL_DMA_Abort
                  |L14.42|
;;;1167       }
;;;1168   
;;;1169       UART_EndTxTransfer(huart);
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       UART_EndTxTransfer
                  |L14.48|
;;;1170     }
;;;1171   
;;;1172     /* Stop UART DMA Rx request if ongoing */
;;;1173     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) &&
000030  6f20              LDR      r0,[r4,#0x70]
000032  2822              CMP      r0,#0x22
000034  d112              BNE      |L14.92|
;;;1174         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
000036  6820              LDR      r0,[r4,#0]
000038  6880              LDR      r0,[r0,#8]
00003a  f0000040          AND      r0,r0,#0x40
00003e  b168              CBZ      r0,|L14.92|
;;;1175     {
;;;1176       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000040  6820              LDR      r0,[r4,#0]
000042  6880              LDR      r0,[r0,#8]
000044  f0200040          BIC      r0,r0,#0x40
000048  6821              LDR      r1,[r4,#0]
00004a  6088              STR      r0,[r1,#8]
;;;1177   
;;;1178       /* Abort the UART DMA Rx channel */
;;;1179       if(huart->hdmarx != NULL)
00004c  6e60              LDR      r0,[r4,#0x64]
00004e  b110              CBZ      r0,|L14.86|
;;;1180       {
;;;1181         HAL_DMA_Abort(huart->hdmarx);
000050  6e60              LDR      r0,[r4,#0x64]
000052  f7fffffe          BL       HAL_DMA_Abort
                  |L14.86|
;;;1182       }
;;;1183   
;;;1184       UART_EndRxTransfer(huart);
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       UART_EndRxTransfer
                  |L14.92|
;;;1185     }
;;;1186   
;;;1187     return HAL_OK;
00005c  2000              MOVS     r0,#0
;;;1188   }
00005e  bd10              POP      {r4,pc}
;;;1189   
                          ENDP


                          AREA ||i.HAL_UART_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_DeInit PROC
;;;586      */
;;;587    HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;588    {
000002  4604              MOV      r4,r0
;;;589      /* Check the UART handle allocation */
;;;590      if(huart == NULL)
000004  b90c              CBNZ     r4,|L15.10|
;;;591      {
;;;592        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L15.8|
;;;593      }
;;;594    
;;;595      /* Check the parameters */
;;;596      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;597    
;;;598      huart->gState = HAL_UART_STATE_BUSY;
;;;599    
;;;600      /* Disable the Peripheral */
;;;601      __HAL_UART_DISABLE(huart);
;;;602    
;;;603      huart->Instance->CR1 = 0x0U;
;;;604      huart->Instance->CR2 = 0x0U;
;;;605      huart->Instance->CR3 = 0x0U;
;;;606    
;;;607      /* DeInit the low level hardware */
;;;608      HAL_UART_MspDeInit(huart);
;;;609    
;;;610      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;611      huart->gState    = HAL_UART_STATE_RESET;
;;;612      huart->RxState   = HAL_UART_STATE_RESET;
;;;613    
;;;614      /* Process Unlock */
;;;615      __HAL_UNLOCK(huart);
;;;616    
;;;617      return HAL_OK;
;;;618    }
000008  bd10              POP      {r4,pc}
                  |L15.10|
00000a  2024              MOVS     r0,#0x24              ;598
00000c  66e0              STR      r0,[r4,#0x6c]         ;598
00000e  6820              LDR      r0,[r4,#0]            ;601
000010  6800              LDR      r0,[r0,#0]            ;601
000012  f0200001          BIC      r0,r0,#1              ;601
000016  6821              LDR      r1,[r4,#0]            ;601
000018  6008              STR      r0,[r1,#0]            ;601
00001a  2000              MOVS     r0,#0                 ;603
00001c  6821              LDR      r1,[r4,#0]            ;603
00001e  6008              STR      r0,[r1,#0]            ;603
000020  6821              LDR      r1,[r4,#0]            ;604
000022  6048              STR      r0,[r1,#4]            ;604
000024  6821              LDR      r1,[r4,#0]            ;605
000026  6088              STR      r0,[r1,#8]            ;605
000028  4620              MOV      r0,r4                 ;608
00002a  f7fffffe          BL       HAL_UART_MspDeInit
00002e  2000              MOVS     r0,#0                 ;610
000030  6760              STR      r0,[r4,#0x74]         ;610
000032  66e0              STR      r0,[r4,#0x6c]         ;611
000034  6720              STR      r0,[r4,#0x70]         ;612
000036  bf00              NOP                            ;615
000038  66a0              STR      r0,[r4,#0x68]         ;615
00003a  bf00              NOP                            ;615
00003c  bf00              NOP                            ;617
00003e  e7e3              B        |L15.8|
;;;619    
                          ENDP


                          AREA ||i.HAL_UART_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_ErrorCallback PROC
;;;1550     */
;;;1551    __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1552   {
;;;1553     /* Prevent unused argument(s) compilation warning */
;;;1554     UNUSED(huart);
;;;1555   
;;;1556     /* NOTE : This function should not be modified, when the callback is needed,
;;;1557               the HAL_UART_ErrorCallback can be implemented in the user file
;;;1558      */
;;;1559   }
;;;1560   
                          ENDP


                          AREA ||i.HAL_UART_GetError||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetError PROC
;;;1817   */
;;;1818   uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;1819   {
;;;1820     return huart->ErrorCode;
000002  6f48              LDR      r0,[r1,#0x74]
;;;1821   }
000004  4770              BX       lr
;;;1822   
                          ENDP


                          AREA ||i.HAL_UART_GetState||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetState PROC
;;;1802     */
;;;1803   HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;1804   {
;;;1805     uint32_t temp1= 0x00U, temp2 = 0x00U;
000002  2300              MOVS     r3,#0
000004  2200              MOVS     r2,#0
;;;1806     temp1 = huart->gState;
000006  6ecb              LDR      r3,[r1,#0x6c]
;;;1807     temp2 = huart->RxState;
000008  6f0a              LDR      r2,[r1,#0x70]
;;;1808   
;;;1809     return (HAL_UART_StateTypeDef)(temp1 | temp2);
00000a  ea430002          ORR      r0,r3,r2
;;;1810   }
00000e  4770              BX       lr
;;;1811   
                          ENDP


                          AREA ||i.HAL_UART_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_UART_IRQHandler PROC
;;;1194     */
;;;1195   void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1196   {
000004  4604              MOV      r4,r0
;;;1197     uint32_t isrflags   = READ_REG(huart->Instance->ISR);
000006  6820              LDR      r0,[r4,#0]
000008  69c5              LDR      r5,[r0,#0x1c]
;;;1198     uint32_t cr1its     = READ_REG(huart->Instance->CR1);
00000a  6820              LDR      r0,[r4,#0]
00000c  6806              LDR      r6,[r0,#0]
;;;1199     uint32_t cr3its     = READ_REG(huart->Instance->CR3);
00000e  6820              LDR      r0,[r4,#0]
000010  6887              LDR      r7,[r0,#8]
;;;1200     uint32_t errorflags;
;;;1201   
;;;1202     /* If no error occurs */
;;;1203     errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE));
000012  f005080f          AND      r8,r5,#0xf
;;;1204     if (errorflags == RESET)
000016  f1b80f00          CMP      r8,#0
00001a  d10a              BNE      |L19.50|
;;;1205     {
;;;1206       /* UART in mode Receiver ---------------------------------------------------*/
;;;1207       if(((isrflags & USART_ISR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
00001c  f0050020          AND      r0,r5,#0x20
000020  b138              CBZ      r0,|L19.50|
000022  f0060020          AND      r0,r6,#0x20
000026  b120              CBZ      r0,|L19.50|
;;;1208       {
;;;1209         UART_Receive_IT(huart);
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       UART_Receive_IT
                  |L19.46|
;;;1210         return;
;;;1211       }
;;;1212     }
;;;1213   
;;;1214     /* If some errors occur */
;;;1215     if((errorflags != RESET) && ((cr3its & (USART_CR3_EIE | USART_CR1_PEIE)) != RESET))
;;;1216     {
;;;1217   
;;;1218       /* UART parity error interrupt occurred -------------------------------------*/
;;;1219       if(((isrflags & USART_ISR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
;;;1220       {
;;;1221         __HAL_UART_CLEAR_IT(huart, UART_CLEAR_PEF);
;;;1222   
;;;1223         huart->ErrorCode |= HAL_UART_ERROR_PE;
;;;1224       }
;;;1225   
;;;1226       /* UART frame error interrupt occurred --------------------------------------*/
;;;1227       if(((isrflags & USART_ISR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
;;;1228       {
;;;1229         __HAL_UART_CLEAR_IT(huart, UART_CLEAR_FEF);
;;;1230   
;;;1231         huart->ErrorCode |= HAL_UART_ERROR_FE;
;;;1232       }
;;;1233   
;;;1234       /* UART noise error interrupt occurred --------------------------------------*/
;;;1235       if(((isrflags & USART_ISR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
;;;1236       {
;;;1237         __HAL_UART_CLEAR_IT(huart, UART_CLEAR_NEF);
;;;1238   
;;;1239         huart->ErrorCode |= HAL_UART_ERROR_NE;
;;;1240       }
;;;1241       
;;;1242       /* UART Over-Run interrupt occurred -----------------------------------------*/
;;;1243       if(((isrflags & USART_ISR_ORE) != RESET) &&
;;;1244          (((cr1its & USART_CR1_RXNEIE) != RESET) || ((cr3its & USART_CR3_EIE) != RESET)))
;;;1245       {
;;;1246         __HAL_UART_CLEAR_IT(huart, UART_CLEAR_OREF);
;;;1247   
;;;1248         huart->ErrorCode |= HAL_UART_ERROR_ORE;
;;;1249       }
;;;1250   
;;;1251       /* Call UART Error Call back function if need be --------------------------*/
;;;1252       if(huart->ErrorCode != HAL_UART_ERROR_NONE)
;;;1253       {
;;;1254         /* UART in mode Receiver ---------------------------------------------------*/
;;;1255         if(((isrflags & USART_ISR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
;;;1256         {
;;;1257           UART_Receive_IT(huart);
;;;1258         }
;;;1259   
;;;1260         /* If Overrun error occurs, or if any error occurs in DMA mode reception,
;;;1261            consider error as blocking */
;;;1262         if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) ||
;;;1263             (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
;;;1264         {
;;;1265           /* Blocking error : transfer is aborted
;;;1266              Set the UART state ready to be able to start again the process,
;;;1267              Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
;;;1268           UART_EndRxTransfer(huart);
;;;1269   
;;;1270           /* Disable the UART DMA Rx request if enabled */
;;;1271           if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
;;;1272           {
;;;1273             CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1274   
;;;1275             /* Abort the UART DMA Rx channel */
;;;1276             if(huart->hdmarx != NULL)
;;;1277             {
;;;1278               /* Set the UART DMA Abort callback :
;;;1279               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
;;;1280               huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
;;;1281   
;;;1282               /* Abort DMA RX */
;;;1283               if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
;;;1284               {
;;;1285                 /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
;;;1286                 huart->hdmarx->XferAbortCallback(huart->hdmarx);
;;;1287               }
;;;1288             }
;;;1289             else
;;;1290             {
;;;1291               /* Call user error callback */
;;;1292               HAL_UART_ErrorCallback(huart);
;;;1293             }
;;;1294           }
;;;1295           else
;;;1296           {
;;;1297             /* Call user error callback */
;;;1298             HAL_UART_ErrorCallback(huart);
;;;1299           }
;;;1300         }
;;;1301         else
;;;1302         {
;;;1303           /* Non Blocking error : transfer could go on.
;;;1304              Error is notified to user through user error callback */
;;;1305           HAL_UART_ErrorCallback(huart);
;;;1306           huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1307         }
;;;1308       }
;;;1309       return;
;;;1310   
;;;1311     } /* End if some error occurs */
;;;1312   
;;;1313     /* UART in mode Transmitter ------------------------------------------------*/
;;;1314     if(((isrflags & USART_ISR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
;;;1315     {
;;;1316       UART_Transmit_IT(huart);
;;;1317       return;
;;;1318     }
;;;1319   
;;;1320     /* UART in mode Transmitter (transmission end) -----------------------------*/
;;;1321     if(((isrflags & USART_ISR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
;;;1322     {
;;;1323       UART_EndTransmit_IT(huart);
;;;1324       return;
;;;1325     }
;;;1326   
;;;1327   }
00002e  e8bd81f0          POP      {r4-r8,pc}
                  |L19.50|
000032  f1b80f00          CMP      r8,#0                 ;1215
000036  d079              BEQ      |L19.300|
000038  f2401001          MOV      r0,#0x101             ;1215
00003c  4038              ANDS     r0,r0,r7              ;1215
00003e  2800              CMP      r0,#0                 ;1215
000040  d074              BEQ      |L19.300|
000042  f0050001          AND      r0,r5,#1              ;1219
000046  b148              CBZ      r0,|L19.92|
000048  f4067080          AND      r0,r6,#0x100          ;1219
00004c  b130              CBZ      r0,|L19.92|
00004e  2001              MOVS     r0,#1                 ;1221
000050  6821              LDR      r1,[r4,#0]            ;1221
000052  6208              STR      r0,[r1,#0x20]         ;1221
000054  6f60              LDR      r0,[r4,#0x74]         ;1223
000056  f0400001          ORR      r0,r0,#1              ;1223
00005a  6760              STR      r0,[r4,#0x74]         ;1223
                  |L19.92|
00005c  f0050002          AND      r0,r5,#2              ;1227
000060  b148              CBZ      r0,|L19.118|
000062  f0070001          AND      r0,r7,#1              ;1227
000066  b130              CBZ      r0,|L19.118|
000068  2002              MOVS     r0,#2                 ;1229
00006a  6821              LDR      r1,[r4,#0]            ;1229
00006c  6208              STR      r0,[r1,#0x20]         ;1229
00006e  6f60              LDR      r0,[r4,#0x74]         ;1231
000070  f0400004          ORR      r0,r0,#4              ;1231
000074  6760              STR      r0,[r4,#0x74]         ;1231
                  |L19.118|
000076  f0050004          AND      r0,r5,#4              ;1235
00007a  b148              CBZ      r0,|L19.144|
00007c  f0070001          AND      r0,r7,#1              ;1235
000080  b130              CBZ      r0,|L19.144|
000082  2004              MOVS     r0,#4                 ;1237
000084  6821              LDR      r1,[r4,#0]            ;1237
000086  6208              STR      r0,[r1,#0x20]         ;1237
000088  6f60              LDR      r0,[r4,#0x74]         ;1239
00008a  f0400002          ORR      r0,r0,#2              ;1239
00008e  6760              STR      r0,[r4,#0x74]         ;1239
                  |L19.144|
000090  f0050008          AND      r0,r5,#8              ;1243
000094  b160              CBZ      r0,|L19.176|
000096  f0060020          AND      r0,r6,#0x20           ;1244
00009a  b910              CBNZ     r0,|L19.162|
00009c  f0070001          AND      r0,r7,#1              ;1244
0000a0  b130              CBZ      r0,|L19.176|
                  |L19.162|
0000a2  2008              MOVS     r0,#8                 ;1246
0000a4  6821              LDR      r1,[r4,#0]            ;1246
0000a6  6208              STR      r0,[r1,#0x20]         ;1246
0000a8  6f60              LDR      r0,[r4,#0x74]         ;1248
0000aa  f0400008          ORR      r0,r0,#8              ;1248
0000ae  6760              STR      r0,[r4,#0x74]         ;1248
                  |L19.176|
0000b0  6f60              LDR      r0,[r4,#0x74]         ;1252
0000b2  b358              CBZ      r0,|L19.268|
0000b4  f0050020          AND      r0,r5,#0x20           ;1255
0000b8  b128              CBZ      r0,|L19.198|
0000ba  f0060020          AND      r0,r6,#0x20           ;1255
0000be  b110              CBZ      r0,|L19.198|
0000c0  4620              MOV      r0,r4                 ;1257
0000c2  f7fffffe          BL       UART_Receive_IT
                  |L19.198|
0000c6  6f60              LDR      r0,[r4,#0x74]         ;1262
0000c8  f0000008          AND      r0,r0,#8              ;1262
0000cc  b920              CBNZ     r0,|L19.216|
0000ce  6820              LDR      r0,[r4,#0]            ;1263
0000d0  6880              LDR      r0,[r0,#8]            ;1263
0000d2  f0000040          AND      r0,r0,#0x40           ;1263
0000d6  b318              CBZ      r0,|L19.288|
                  |L19.216|
0000d8  4620              MOV      r0,r4                 ;1268
0000da  f7fffffe          BL       UART_EndRxTransfer
0000de  6820              LDR      r0,[r4,#0]            ;1271
0000e0  6880              LDR      r0,[r0,#8]            ;1271
0000e2  f0000040          AND      r0,r0,#0x40           ;1271
0000e6  b1b8              CBZ      r0,|L19.280|
0000e8  6820              LDR      r0,[r4,#0]            ;1273
0000ea  6880              LDR      r0,[r0,#8]            ;1273
0000ec  f0200040          BIC      r0,r0,#0x40           ;1273
0000f0  6821              LDR      r1,[r4,#0]            ;1273
0000f2  6088              STR      r0,[r1,#8]            ;1273
0000f4  6e60              LDR      r0,[r4,#0x64]         ;1276
0000f6  b150              CBZ      r0,|L19.270|
0000f8  4817              LDR      r0,|L19.344|
0000fa  6e61              LDR      r1,[r4,#0x64]         ;1280
0000fc  6548              STR      r0,[r1,#0x54]         ;1280
0000fe  6e60              LDR      r0,[r4,#0x64]         ;1283
000100  f7fffffe          BL       HAL_DMA_Abort_IT
000104  b110              CBZ      r0,|L19.268|
000106  6e60              LDR      r0,[r4,#0x64]         ;1286
000108  6d41              LDR      r1,[r0,#0x54]         ;1286
00010a  4788              BLX      r1                    ;1286
                  |L19.268|
00010c  e00d              B        |L19.298|
                  |L19.270|
00010e  4620              MOV      r0,r4                 ;1292
000110  f7fffffe          BL       HAL_UART_ErrorCallback
000114  e009              B        |L19.298|
000116  e009              B        |L19.300|
                  |L19.280|
000118  4620              MOV      r0,r4                 ;1298
00011a  f7fffffe          BL       HAL_UART_ErrorCallback
00011e  e004              B        |L19.298|
                  |L19.288|
000120  4620              MOV      r0,r4                 ;1305
000122  f7fffffe          BL       HAL_UART_ErrorCallback
000126  2000              MOVS     r0,#0                 ;1306
000128  6760              STR      r0,[r4,#0x74]         ;1306
                  |L19.298|
00012a  e780              B        |L19.46|
                  |L19.300|
00012c  f0050080          AND      r0,r5,#0x80           ;1314
000130  b130              CBZ      r0,|L19.320|
000132  f0060080          AND      r0,r6,#0x80           ;1314
000136  b118              CBZ      r0,|L19.320|
000138  4620              MOV      r0,r4                 ;1316
00013a  f7fffffe          BL       UART_Transmit_IT
00013e  e776              B        |L19.46|
                  |L19.320|
000140  f0050040          AND      r0,r5,#0x40           ;1321
000144  b130              CBZ      r0,|L19.340|
000146  f0060040          AND      r0,r6,#0x40           ;1321
00014a  b118              CBZ      r0,|L19.340|
00014c  4620              MOV      r0,r4                 ;1323
00014e  f7fffffe          BL       UART_EndTransmit_IT
000152  e76c              B        |L19.46|
                  |L19.340|
000154  bf00              NOP      
000156  e76a              B        |L19.46|
;;;1328   
                          ENDP

                  |L19.344|
                          DCD      UART_DMAAbortOnError

                          AREA ||i.HAL_UART_Init||, CODE, READONLY, ALIGN=1

                  HAL_UART_Init PROC
;;;242      */
;;;243    HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;244    {
000002  4604              MOV      r4,r0
;;;245      /* Check the UART handle allocation */
;;;246      if(huart == NULL)
000004  b90c              CBNZ     r4,|L20.10|
;;;247      {
;;;248        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L20.8|
;;;249      }
;;;250    
;;;251      if(huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
;;;252      {
;;;253        /* Check the parameters */
;;;254        assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
;;;255      }
;;;256      else
;;;257      {
;;;258        /* Check the parameters */
;;;259        assert_param(IS_UART_INSTANCE(huart->Instance));
;;;260      }
;;;261    
;;;262      if(huart->gState == HAL_UART_STATE_RESET)
;;;263      {
;;;264        /* Allocate lock resource and initialize it */
;;;265        huart->Lock = HAL_UNLOCKED;
;;;266    
;;;267        /* Init the low level hardware : GPIO, CLOCK */
;;;268        HAL_UART_MspInit(huart);
;;;269      }
;;;270    
;;;271      huart->gState = HAL_UART_STATE_BUSY;
;;;272    
;;;273      /* Disable the Peripheral */
;;;274      __HAL_UART_DISABLE(huart);
;;;275    
;;;276      /* Set the UART Communication parameters */
;;;277      if (UART_SetConfig(huart) == HAL_ERROR)
;;;278      {
;;;279        return HAL_ERROR;
;;;280      }
;;;281    
;;;282      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;283      {
;;;284        UART_AdvFeatureConfig(huart);
;;;285      }
;;;286    
;;;287      /* In asynchronous mode, the following bits must be kept cleared:
;;;288      - LINEN and CLKEN bits in the USART_CR2 register,
;;;289      - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
;;;290      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;291      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;292    
;;;293      /* Enable the Peripheral */
;;;294      __HAL_UART_ENABLE(huart);
;;;295    
;;;296      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;297      return (UART_CheckIdleState(huart));
;;;298    }
000008  bd10              POP      {r4,pc}
                  |L20.10|
00000a  69a0              LDR      r0,[r4,#0x18]         ;251
00000c  b100              CBZ      r0,|L20.16|
00000e  e000              B        |L20.18|
                  |L20.16|
000010  bf00              NOP                            ;259
                  |L20.18|
000012  6ee0              LDR      r0,[r4,#0x6c]         ;262
000014  b920              CBNZ     r0,|L20.32|
000016  2000              MOVS     r0,#0                 ;265
000018  66a0              STR      r0,[r4,#0x68]         ;265
00001a  4620              MOV      r0,r4                 ;268
00001c  f7fffffe          BL       HAL_UART_MspInit
                  |L20.32|
000020  2024              MOVS     r0,#0x24              ;271
000022  66e0              STR      r0,[r4,#0x6c]         ;271
000024  6820              LDR      r0,[r4,#0]            ;274
000026  6800              LDR      r0,[r0,#0]            ;274
000028  f0200001          BIC      r0,r0,#1              ;274
00002c  6821              LDR      r1,[r4,#0]            ;274
00002e  6008              STR      r0,[r1,#0]            ;274
000030  4620              MOV      r0,r4                 ;277
000032  f7fffffe          BL       UART_SetConfig
000036  2801              CMP      r0,#1                 ;277
000038  d100              BNE      |L20.60|
00003a  e7e5              B        |L20.8|
                  |L20.60|
00003c  6a60              LDR      r0,[r4,#0x24]         ;282
00003e  b110              CBZ      r0,|L20.70|
000040  4620              MOV      r0,r4                 ;284
000042  f7fffffe          BL       UART_AdvFeatureConfig
                  |L20.70|
000046  6820              LDR      r0,[r4,#0]            ;290
000048  6840              LDR      r0,[r0,#4]            ;290
00004a  f4204090          BIC      r0,r0,#0x4800         ;290
00004e  6821              LDR      r1,[r4,#0]            ;290
000050  6048              STR      r0,[r1,#4]            ;290
000052  6820              LDR      r0,[r4,#0]            ;291
000054  6880              LDR      r0,[r0,#8]            ;291
000056  f020002a          BIC      r0,r0,#0x2a           ;291
00005a  6821              LDR      r1,[r4,#0]            ;291
00005c  6088              STR      r0,[r1,#8]            ;291
00005e  6820              LDR      r0,[r4,#0]            ;294
000060  6800              LDR      r0,[r0,#0]            ;294
000062  f0400001          ORR      r0,r0,#1              ;294
000066  6821              LDR      r1,[r4,#0]            ;294
000068  6008              STR      r0,[r1,#0]            ;294
00006a  4620              MOV      r0,r4                 ;297
00006c  f7fffffe          BL       UART_CheckIdleState
000070  e7ca              B        |L20.8|
;;;299    
                          ENDP


                          AREA ||i.HAL_UART_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspDeInit PROC
;;;639      */
;;;640    __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;641    {
;;;642      /* Prevent unused argument(s) compilation warning */
;;;643      UNUSED(huart);
;;;644    
;;;645      /* NOTE : This function should not be modified, when the callback is needed,
;;;646                the HAL_UART_MspDeInit can be implemented in the user file
;;;647       */
;;;648    }
;;;649    
                          ENDP


                          AREA ||i.HAL_UART_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspInit PROC
;;;624      */
;;;625    __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;626    {
;;;627      /* Prevent unused argument(s) compilation warning */
;;;628      UNUSED(huart);
;;;629    
;;;630      /* NOTE : This function should not be modified, when the callback is needed,
;;;631                the HAL_UART_MspInit can be implemented in the user file
;;;632       */
;;;633    }
;;;634    
                          ENDP


                          AREA ||i.HAL_UART_Receive||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive PROC
;;;786      */
;;;787    HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;788    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  4699              MOV      r9,r3
;;;789      uint16_t* tmp;
;;;790      uint16_t uhMask;
;;;791      uint32_t tickstart = 0U;
00000c  f04f0a00          MOV      r10,#0
;;;792    
;;;793      /* Check that a Rx process is not already ongoing */
;;;794      if(huart->RxState == HAL_UART_STATE_READY)
000010  6f20              LDR      r0,[r4,#0x70]
000012  2820              CMP      r0,#0x20
000014  d176              BNE      |L23.260|
;;;795      {
;;;796        if((pData == NULL ) || (Size == 0U))
000016  b105              CBZ      r5,|L23.26|
000018  b916              CBNZ     r6,|L23.32|
                  |L23.26|
;;;797        {
;;;798          return  HAL_ERROR;
00001a  2001              MOVS     r0,#1
                  |L23.28|
;;;799        }
;;;800    
;;;801        /* Process Locked */
;;;802        __HAL_LOCK(huart);
;;;803    
;;;804        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;805        huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;806    
;;;807        /* Init tickstart for timeout managment*/
;;;808        tickstart = HAL_GetTick();
;;;809    
;;;810        huart->RxXferSize = Size;
;;;811        huart->RxXferCount = Size;
;;;812    
;;;813        /* Computation of UART mask to apply to RDR register */
;;;814        UART_MASK_COMPUTATION(huart);
;;;815        uhMask = huart->Mask;
;;;816    
;;;817        /* as long as data have to be received */
;;;818        while(huart->RxXferCount > 0U)
;;;819        {
;;;820          huart->RxXferCount--;
;;;821          if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;822          {
;;;823            return HAL_TIMEOUT;
;;;824          }
;;;825          if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;826          {
;;;827            tmp = (uint16_t*) pData ;
;;;828            *tmp = (uint16_t)(huart->Instance->RDR & uhMask);
;;;829            pData +=2U;
;;;830          }
;;;831          else
;;;832          {
;;;833            *pData++ = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
;;;834          }
;;;835        }
;;;836    
;;;837        /* At end of Rx process, restore huart->RxState to Ready */
;;;838        huart->RxState = HAL_UART_STATE_READY;
;;;839    
;;;840        /* Process Unlocked */
;;;841        __HAL_UNLOCK(huart);
;;;842    
;;;843        return HAL_OK;
;;;844      }
;;;845      else
;;;846      {
;;;847        return HAL_BUSY;
;;;848      }
;;;849    }
00001c  e8bd8ff8          POP      {r3-r11,pc}
                  |L23.32|
000020  bf00              NOP                            ;802
000022  6ea0              LDR      r0,[r4,#0x68]         ;802
000024  2801              CMP      r0,#1                 ;802
000026  d101              BNE      |L23.44|
000028  2002              MOVS     r0,#2                 ;802
00002a  e7f7              B        |L23.28|
                  |L23.44|
00002c  2001              MOVS     r0,#1                 ;802
00002e  66a0              STR      r0,[r4,#0x68]         ;802
000030  bf00              NOP                            ;802
000032  2000              MOVS     r0,#0                 ;804
000034  6760              STR      r0,[r4,#0x74]         ;804
000036  2022              MOVS     r0,#0x22              ;805
000038  6720              STR      r0,[r4,#0x70]         ;805
00003a  f7fffffe          BL       HAL_GetTick
00003e  4682              MOV      r10,r0                ;808
000040  f8a46058          STRH     r6,[r4,#0x58]         ;810
000044  f8a4605a          STRH     r6,[r4,#0x5a]         ;811
000048  bf00              NOP                            ;814
00004a  68a0              LDR      r0,[r4,#8]            ;814
00004c  f5b05f80          CMP      r0,#0x1000            ;814
000050  d10a              BNE      |L23.104|
000052  6920              LDR      r0,[r4,#0x10]         ;814
000054  b920              CBNZ     r0,|L23.96|
000056  f24010ff          MOV      r0,#0x1ff             ;814
00005a  f8a4005c          STRH     r0,[r4,#0x5c]         ;814
00005e  e01c              B        |L23.154|
                  |L23.96|
000060  20ff              MOVS     r0,#0xff              ;814
000062  f8a4005c          STRH     r0,[r4,#0x5c]         ;814
000066  e018              B        |L23.154|
                  |L23.104|
000068  68a0              LDR      r0,[r4,#8]            ;814
00006a  b948              CBNZ     r0,|L23.128|
00006c  6920              LDR      r0,[r4,#0x10]         ;814
00006e  b918              CBNZ     r0,|L23.120|
000070  20ff              MOVS     r0,#0xff              ;814
000072  f8a4005c          STRH     r0,[r4,#0x5c]         ;814
000076  e010              B        |L23.154|
                  |L23.120|
000078  207f              MOVS     r0,#0x7f              ;814
00007a  f8a4005c          STRH     r0,[r4,#0x5c]         ;814
00007e  e00c              B        |L23.154|
                  |L23.128|
000080  68a0              LDR      r0,[r4,#8]            ;814
000082  f1b05f80          CMP      r0,#0x10000000        ;814
000086  d108              BNE      |L23.154|
000088  6920              LDR      r0,[r4,#0x10]         ;814
00008a  b918              CBNZ     r0,|L23.148|
00008c  207f              MOVS     r0,#0x7f              ;814
00008e  f8a4005c          STRH     r0,[r4,#0x5c]         ;814
000092  e002              B        |L23.154|
                  |L23.148|
000094  203f              MOVS     r0,#0x3f              ;814
000096  f8a4005c          STRH     r0,[r4,#0x5c]         ;814
                  |L23.154|
00009a  bf00              NOP                            ;814
00009c  f8b4805c          LDRH     r8,[r4,#0x5c]         ;815
0000a0  e024              B        |L23.236|
                  |L23.162|
0000a2  f8b4005a          LDRH     r0,[r4,#0x5a]         ;820
0000a6  1e40              SUBS     r0,r0,#1              ;820
0000a8  f8a4005a          STRH     r0,[r4,#0x5a]         ;820
0000ac  4653              MOV      r3,r10                ;821
0000ae  2200              MOVS     r2,#0                 ;821
0000b0  2120              MOVS     r1,#0x20              ;821
0000b2  4620              MOV      r0,r4                 ;821
0000b4  f8cd9000          STR      r9,[sp,#0]            ;821
0000b8  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
0000bc  b108              CBZ      r0,|L23.194|
0000be  2003              MOVS     r0,#3                 ;823
0000c0  e7ac              B        |L23.28|
                  |L23.194|
0000c2  68a0              LDR      r0,[r4,#8]            ;825
0000c4  f5b05f80          CMP      r0,#0x1000            ;825
0000c8  d109              BNE      |L23.222|
0000ca  6920              LDR      r0,[r4,#0x10]         ;825
0000cc  b938              CBNZ     r0,|L23.222|
0000ce  462f              MOV      r7,r5                 ;827
0000d0  6820              LDR      r0,[r4,#0]            ;828
0000d2  6a40              LDR      r0,[r0,#0x24]         ;828
0000d4  ea000008          AND      r0,r0,r8              ;828
0000d8  8038              STRH     r0,[r7,#0]            ;828
0000da  1cad              ADDS     r5,r5,#2              ;829
0000dc  e006              B        |L23.236|
                  |L23.222|
0000de  6820              LDR      r0,[r4,#0]            ;833
0000e0  6a40              LDR      r0,[r0,#0x24]         ;833
0000e2  f00801ff          AND      r1,r8,#0xff           ;833
0000e6  4008              ANDS     r0,r0,r1              ;833
0000e8  f8050b01          STRB     r0,[r5],#1            ;833
                  |L23.236|
0000ec  f8b4005a          LDRH     r0,[r4,#0x5a]         ;818
0000f0  2800              CMP      r0,#0                 ;818
0000f2  d1d6              BNE      |L23.162|
0000f4  2020              MOVS     r0,#0x20              ;838
0000f6  6720              STR      r0,[r4,#0x70]         ;838
0000f8  bf00              NOP                            ;841
0000fa  2000              MOVS     r0,#0                 ;841
0000fc  66a0              STR      r0,[r4,#0x68]         ;841
0000fe  bf00              NOP                            ;841
000100  e78c              B        |L23.28|
000102  e7ff              B        |L23.260|
                  |L23.260|
000104  2002              MOVS     r0,#2                 ;847
000106  e789              B        |L23.28|
;;;850    
                          ENDP


                          AREA ||i.HAL_UART_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive_DMA PROC
;;;1013     */
;;;1014   HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;1015   {
000002  4604              MOV      r4,r0
000004  4615              MOV      r5,r2
;;;1016     uint32_t *tmp;
;;;1017   
;;;1018     /* Check that a Rx process is not already ongoing */
;;;1019     if(huart->RxState == HAL_UART_STATE_READY)
000006  6f20              LDR      r0,[r4,#0x70]
000008  2820              CMP      r0,#0x20
00000a  d142              BNE      |L24.146|
;;;1020     {
;;;1021       if((pData == NULL ) || (Size == 0U))
00000c  9801              LDR      r0,[sp,#4]
00000e  b100              CBZ      r0,|L24.18|
000010  b90d              CBNZ     r5,|L24.22|
                  |L24.18|
;;;1022       {
;;;1023         return HAL_ERROR;
000012  2001              MOVS     r0,#1
                  |L24.20|
;;;1024       }
;;;1025   
;;;1026       /* Process Locked */
;;;1027       __HAL_LOCK(huart);
;;;1028   
;;;1029       huart->pRxBuffPtr = pData;
;;;1030       huart->RxXferSize = Size;
;;;1031   
;;;1032       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1033       huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;1034   
;;;1035       /* Set the UART DMA transfer complete callback */
;;;1036       huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
;;;1037   
;;;1038       /* Set the UART DMA Half transfer complete callback */
;;;1039       huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
;;;1040   
;;;1041       /* Set the DMA error callback */
;;;1042       huart->hdmarx->XferErrorCallback = UART_DMAError;
;;;1043   
;;;1044       /* Set the DMA abort callback */
;;;1045       huart->hdmarx->XferAbortCallback = NULL;
;;;1046   
;;;1047       /* Enable the DMA channel */
;;;1048       tmp = (uint32_t*)&pData;
;;;1049       HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->RDR, *(uint32_t*)tmp, Size);
;;;1050   
;;;1051       /* Process Unlocked */
;;;1052       __HAL_UNLOCK(huart);
;;;1053   
;;;1054       /* Enable the UART Parity Error Interrupt */
;;;1055       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1056   
;;;1057       /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1058       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1059   
;;;1060       /* Enable the DMA transfer for the receiver request by setting the DMAR bit
;;;1061       in the UART CR3 register */
;;;1062       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1063   
;;;1064       return HAL_OK;
;;;1065     }
;;;1066     else
;;;1067     {
;;;1068       return HAL_BUSY;
;;;1069     }
;;;1070   }
000014  bdfe              POP      {r1-r7,pc}
                  |L24.22|
000016  bf00              NOP                            ;1027
000018  6ea0              LDR      r0,[r4,#0x68]         ;1027
00001a  2801              CMP      r0,#1                 ;1027
00001c  d101              BNE      |L24.34|
00001e  2002              MOVS     r0,#2                 ;1027
000020  e7f8              B        |L24.20|
                  |L24.34|
000022  2001              MOVS     r0,#1                 ;1027
000024  66a0              STR      r0,[r4,#0x68]         ;1027
000026  bf00              NOP                            ;1027
000028  9801              LDR      r0,[sp,#4]            ;1029
00002a  6560              STR      r0,[r4,#0x54]         ;1029
00002c  f8a45058          STRH     r5,[r4,#0x58]         ;1030
000030  2000              MOVS     r0,#0                 ;1032
000032  6760              STR      r0,[r4,#0x74]         ;1032
000034  2022              MOVS     r0,#0x22              ;1033
000036  6720              STR      r0,[r4,#0x70]         ;1033
000038  4817              LDR      r0,|L24.152|
00003a  6e61              LDR      r1,[r4,#0x64]         ;1036
00003c  6408              STR      r0,[r1,#0x40]         ;1036
00003e  4817              LDR      r0,|L24.156|
000040  6e61              LDR      r1,[r4,#0x64]         ;1039
000042  6448              STR      r0,[r1,#0x44]         ;1039
000044  4816              LDR      r0,|L24.160|
000046  6e61              LDR      r1,[r4,#0x64]         ;1042
000048  6508              STR      r0,[r1,#0x50]         ;1042
00004a  2000              MOVS     r0,#0                 ;1045
00004c  6e61              LDR      r1,[r4,#0x64]         ;1045
00004e  6548              STR      r0,[r1,#0x54]         ;1045
000050  ae01              ADD      r6,sp,#4              ;1048
000052  6832              LDR      r2,[r6,#0]            ;1049
000054  6823              LDR      r3,[r4,#0]            ;1049
000056  f1030124          ADD      r1,r3,#0x24           ;1049
00005a  462b              MOV      r3,r5                 ;1049
00005c  6e60              LDR      r0,[r4,#0x64]         ;1049
00005e  f7fffffe          BL       HAL_DMA_Start_IT
000062  bf00              NOP                            ;1052
000064  2000              MOVS     r0,#0                 ;1052
000066  66a0              STR      r0,[r4,#0x68]         ;1052
000068  bf00              NOP                            ;1052
00006a  6820              LDR      r0,[r4,#0]            ;1055
00006c  6800              LDR      r0,[r0,#0]            ;1055
00006e  f4407080          ORR      r0,r0,#0x100          ;1055
000072  6821              LDR      r1,[r4,#0]            ;1055
000074  6008              STR      r0,[r1,#0]            ;1055
000076  6820              LDR      r0,[r4,#0]            ;1058
000078  6880              LDR      r0,[r0,#8]            ;1058
00007a  f0400001          ORR      r0,r0,#1              ;1058
00007e  6821              LDR      r1,[r4,#0]            ;1058
000080  6088              STR      r0,[r1,#8]            ;1058
000082  6820              LDR      r0,[r4,#0]            ;1062
000084  6880              LDR      r0,[r0,#8]            ;1062
000086  f0400040          ORR      r0,r0,#0x40           ;1062
00008a  6821              LDR      r1,[r4,#0]            ;1062
00008c  6088              STR      r0,[r1,#8]            ;1062
00008e  2000              MOVS     r0,#0                 ;1064
000090  e7c0              B        |L24.20|
                  |L24.146|
000092  2002              MOVS     r0,#2                 ;1068
000094  e7be              B        |L24.20|
;;;1071   
                          ENDP

000096  0000              DCW      0x0000
                  |L24.152|
                          DCD      UART_DMAReceiveCplt
                  |L24.156|
                          DCD      UART_DMARxHalfCplt
                  |L24.160|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Receive_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive_IT PROC
;;;898      */
;;;899    HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;900    {
000002  4603              MOV      r3,r0
;;;901      /* Check that a Rx process is not already ongoing */
;;;902      if(huart->RxState == HAL_UART_STATE_READY)
000004  6f18              LDR      r0,[r3,#0x70]
000006  2820              CMP      r0,#0x20
000008  d157              BNE      |L25.186|
;;;903      {
;;;904        if((pData == NULL ) || (Size == 0U))
00000a  b101              CBZ      r1,|L25.14|
00000c  b90a              CBNZ     r2,|L25.18|
                  |L25.14|
;;;905        {
;;;906          return HAL_ERROR;
00000e  2001              MOVS     r0,#1
                  |L25.16|
;;;907        }
;;;908    
;;;909        /* Process Locked */
;;;910        __HAL_LOCK(huart);
;;;911    
;;;912        huart->pRxBuffPtr = pData;
;;;913        huart->RxXferSize = Size;
;;;914        huart->RxXferCount = Size;
;;;915    
;;;916        /* Computation of UART mask to apply to RDR register */
;;;917        UART_MASK_COMPUTATION(huart);
;;;918    
;;;919        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;920        huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;921    
;;;922        /* Process Unlocked */
;;;923        __HAL_UNLOCK(huart);
;;;924    
;;;925        /* Enable the UART Parity Error Interrupt */
;;;926        SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;927    
;;;928        /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;929        SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;930    
;;;931        /* Enable the UART Data Register not empty Interrupt */
;;;932        SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE);
;;;933    
;;;934        return HAL_OK;
;;;935      }
;;;936      else
;;;937      {
;;;938        return HAL_BUSY;
;;;939      }
;;;940    }
000010  bd10              POP      {r4,pc}
                  |L25.18|
000012  bf00              NOP                            ;910
000014  6e98              LDR      r0,[r3,#0x68]         ;910
000016  2801              CMP      r0,#1                 ;910
000018  d101              BNE      |L25.30|
00001a  2002              MOVS     r0,#2                 ;910
00001c  e7f8              B        |L25.16|
                  |L25.30|
00001e  2001              MOVS     r0,#1                 ;910
000020  6698              STR      r0,[r3,#0x68]         ;910
000022  bf00              NOP                            ;910
000024  6559              STR      r1,[r3,#0x54]         ;912
000026  f8a32058          STRH     r2,[r3,#0x58]         ;913
00002a  f8a3205a          STRH     r2,[r3,#0x5a]         ;914
00002e  bf00              NOP                            ;917
000030  6898              LDR      r0,[r3,#8]            ;917
000032  f5b05f80          CMP      r0,#0x1000            ;917
000036  d10a              BNE      |L25.78|
000038  6918              LDR      r0,[r3,#0x10]         ;917
00003a  b920              CBNZ     r0,|L25.70|
00003c  f24010ff          MOV      r0,#0x1ff             ;917
000040  f8a3005c          STRH     r0,[r3,#0x5c]         ;917
000044  e01c              B        |L25.128|
                  |L25.70|
000046  20ff              MOVS     r0,#0xff              ;917
000048  f8a3005c          STRH     r0,[r3,#0x5c]         ;917
00004c  e018              B        |L25.128|
                  |L25.78|
00004e  6898              LDR      r0,[r3,#8]            ;917
000050  b948              CBNZ     r0,|L25.102|
000052  6918              LDR      r0,[r3,#0x10]         ;917
000054  b918              CBNZ     r0,|L25.94|
000056  20ff              MOVS     r0,#0xff              ;917
000058  f8a3005c          STRH     r0,[r3,#0x5c]         ;917
00005c  e010              B        |L25.128|
                  |L25.94|
00005e  207f              MOVS     r0,#0x7f              ;917
000060  f8a3005c          STRH     r0,[r3,#0x5c]         ;917
000064  e00c              B        |L25.128|
                  |L25.102|
000066  6898              LDR      r0,[r3,#8]            ;917
000068  f1b05f80          CMP      r0,#0x10000000        ;917
00006c  d108              BNE      |L25.128|
00006e  6918              LDR      r0,[r3,#0x10]         ;917
000070  b918              CBNZ     r0,|L25.122|
000072  207f              MOVS     r0,#0x7f              ;917
000074  f8a3005c          STRH     r0,[r3,#0x5c]         ;917
000078  e002              B        |L25.128|
                  |L25.122|
00007a  203f              MOVS     r0,#0x3f              ;917
00007c  f8a3005c          STRH     r0,[r3,#0x5c]         ;917
                  |L25.128|
000080  bf00              NOP                            ;917
000082  2000              MOVS     r0,#0                 ;919
000084  6758              STR      r0,[r3,#0x74]         ;919
000086  2022              MOVS     r0,#0x22              ;920
000088  6718              STR      r0,[r3,#0x70]         ;920
00008a  bf00              NOP                            ;923
00008c  2000              MOVS     r0,#0                 ;923
00008e  6698              STR      r0,[r3,#0x68]         ;923
000090  bf00              NOP                            ;923
000092  6818              LDR      r0,[r3,#0]            ;926
000094  6800              LDR      r0,[r0,#0]            ;926
000096  f4407080          ORR      r0,r0,#0x100          ;926
00009a  681c              LDR      r4,[r3,#0]            ;926
00009c  6020              STR      r0,[r4,#0]            ;926
00009e  6818              LDR      r0,[r3,#0]            ;929
0000a0  6880              LDR      r0,[r0,#8]            ;929
0000a2  f0400001          ORR      r0,r0,#1              ;929
0000a6  681c              LDR      r4,[r3,#0]            ;929
0000a8  60a0              STR      r0,[r4,#8]            ;929
0000aa  6818              LDR      r0,[r3,#0]            ;932
0000ac  6800              LDR      r0,[r0,#0]            ;932
0000ae  f0400020          ORR      r0,r0,#0x20           ;932
0000b2  681c              LDR      r4,[r3,#0]            ;932
0000b4  6020              STR      r0,[r4,#0]            ;932
0000b6  2000              MOVS     r0,#0                 ;934
0000b8  e7aa              B        |L25.16|
                  |L25.186|
0000ba  2002              MOVS     r0,#2                 ;938
0000bc  e7a8              B        |L25.16|
;;;941    
                          ENDP


                          AREA ||i.HAL_UART_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxCpltCallback PROC
;;;1520     */
;;;1521   __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1522   {
;;;1523     /* Prevent unused argument(s) compilation warning */
;;;1524     UNUSED(huart);
;;;1525   
;;;1526     /* NOTE : This function should not be modified, when the callback is needed,
;;;1527               the HAL_UART_RxCpltCallback can be implemented in the user file
;;;1528      */
;;;1529   }
;;;1530   
                          ENDP


                          AREA ||i.HAL_UART_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxHalfCpltCallback PROC
;;;1535     */
;;;1536   __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1537   {
;;;1538     /* Prevent unused argument(s) compilation warning */
;;;1539     UNUSED(huart);
;;;1540   
;;;1541     /* NOTE: This function should not be modified, when the callback is needed,
;;;1542              the HAL_UART_RxHalfCpltCallback can be implemented in the user file
;;;1543      */
;;;1544   }
;;;1545   
                          ENDP


                          AREA ||i.HAL_UART_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit PROC
;;;717      */
;;;718    HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;719    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;720      uint16_t* tmp;
;;;721      uint32_t tickstart = 0U;
00000c  f04f0900          MOV      r9,#0
;;;722    
;;;723      /* Check that a Tx process is not already ongoing */
;;;724      if(huart->gState == HAL_UART_STATE_READY)
000010  6ee0              LDR      r0,[r4,#0x6c]
000012  2820              CMP      r0,#0x20
000014  d150              BNE      |L28.184|
;;;725      {
;;;726        if((pData == NULL ) || (Size == 0U))
000016  b105              CBZ      r5,|L28.26|
000018  b916              CBNZ     r6,|L28.32|
                  |L28.26|
;;;727        {
;;;728          return  HAL_ERROR;
00001a  2001              MOVS     r0,#1
                  |L28.28|
;;;729        }
;;;730    
;;;731        /* Process Locked */
;;;732        __HAL_LOCK(huart);
;;;733    
;;;734        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;735        huart->gState = HAL_UART_STATE_BUSY_TX;
;;;736    
;;;737        /* Init tickstart for timeout managment*/
;;;738        tickstart = HAL_GetTick();
;;;739    
;;;740        huart->TxXferSize = Size;
;;;741        huart->TxXferCount = Size;
;;;742        while(huart->TxXferCount > 0U)
;;;743        {
;;;744          huart->TxXferCount--;
;;;745          if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;746          {
;;;747            return HAL_TIMEOUT;
;;;748          }
;;;749          if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;750          {
;;;751            tmp = (uint16_t*) pData;
;;;752            huart->Instance->TDR = (*tmp & (uint16_t)0x01FFU);
;;;753            pData += 2;
;;;754          }
;;;755          else
;;;756          {
;;;757            huart->Instance->TDR = (*pData++ & (uint8_t)0xFFU);
;;;758          }
;;;759        }
;;;760        if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;761        {
;;;762          return HAL_TIMEOUT;
;;;763        }
;;;764    
;;;765        /* At end of Tx process, restore huart->gState to Ready */
;;;766        huart->gState = HAL_UART_STATE_READY;
;;;767    
;;;768        /* Process Unlocked */
;;;769        __HAL_UNLOCK(huart);
;;;770    
;;;771        return HAL_OK;
;;;772      }
;;;773      else
;;;774      {
;;;775        return HAL_BUSY;
;;;776      }
;;;777    }
00001c  e8bd83f8          POP      {r3-r9,pc}
                  |L28.32|
000020  bf00              NOP                            ;732
000022  6ea0              LDR      r0,[r4,#0x68]         ;732
000024  2801              CMP      r0,#1                 ;732
000026  d101              BNE      |L28.44|
000028  2002              MOVS     r0,#2                 ;732
00002a  e7f7              B        |L28.28|
                  |L28.44|
00002c  2001              MOVS     r0,#1                 ;732
00002e  66a0              STR      r0,[r4,#0x68]         ;732
000030  bf00              NOP                            ;732
000032  2000              MOVS     r0,#0                 ;734
000034  6760              STR      r0,[r4,#0x74]         ;734
000036  2021              MOVS     r0,#0x21              ;735
000038  66e0              STR      r0,[r4,#0x6c]         ;735
00003a  f7fffffe          BL       HAL_GetTick
00003e  4681              MOV      r9,r0                 ;738
000040  f8a46050          STRH     r6,[r4,#0x50]         ;740
000044  f8a46052          STRH     r6,[r4,#0x52]         ;741
000048  e021              B        |L28.142|
                  |L28.74|
00004a  f8b40052          LDRH     r0,[r4,#0x52]         ;744
00004e  1e40              SUBS     r0,r0,#1              ;744
000050  f8a40052          STRH     r0,[r4,#0x52]         ;744
000054  464b              MOV      r3,r9                 ;745
000056  2200              MOVS     r2,#0                 ;745
000058  2180              MOVS     r1,#0x80              ;745
00005a  4620              MOV      r0,r4                 ;745
00005c  9700              STR      r7,[sp,#0]            ;745
00005e  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000062  b108              CBZ      r0,|L28.104|
000064  2003              MOVS     r0,#3                 ;747
000066  e7d9              B        |L28.28|
                  |L28.104|
000068  68a0              LDR      r0,[r4,#8]            ;749
00006a  f5b05f80          CMP      r0,#0x1000            ;749
00006e  d10a              BNE      |L28.134|
000070  6920              LDR      r0,[r4,#0x10]         ;749
000072  b940              CBNZ     r0,|L28.134|
000074  46a8              MOV      r8,r5                 ;751
000076  f8b80000          LDRH     r0,[r8,#0]            ;752
00007a  f3c00008          UBFX     r0,r0,#0,#9           ;752
00007e  6821              LDR      r1,[r4,#0]            ;752
000080  6288              STR      r0,[r1,#0x28]         ;752
000082  1cad              ADDS     r5,r5,#2              ;753
000084  e003              B        |L28.142|
                  |L28.134|
000086  f8150b01          LDRB     r0,[r5],#1            ;757
00008a  6821              LDR      r1,[r4,#0]            ;757
00008c  6288              STR      r0,[r1,#0x28]         ;757
                  |L28.142|
00008e  f8b40052          LDRH     r0,[r4,#0x52]         ;742
000092  2800              CMP      r0,#0                 ;742
000094  d1d9              BNE      |L28.74|
000096  464b              MOV      r3,r9                 ;760
000098  2200              MOVS     r2,#0                 ;760
00009a  2140              MOVS     r1,#0x40              ;760
00009c  4620              MOV      r0,r4                 ;760
00009e  9700              STR      r7,[sp,#0]            ;760
0000a0  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
0000a4  b108              CBZ      r0,|L28.170|
0000a6  2003              MOVS     r0,#3                 ;762
0000a8  e7b8              B        |L28.28|
                  |L28.170|
0000aa  2020              MOVS     r0,#0x20              ;766
0000ac  66e0              STR      r0,[r4,#0x6c]         ;766
0000ae  bf00              NOP                            ;769
0000b0  2000              MOVS     r0,#0                 ;769
0000b2  66a0              STR      r0,[r4,#0x68]         ;769
0000b4  bf00              NOP                            ;769
0000b6  e7b1              B        |L28.28|
                  |L28.184|
0000b8  2002              MOVS     r0,#2                 ;775
0000ba  e7af              B        |L28.28|
;;;778    
                          ENDP


                          AREA ||i.HAL_UART_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Transmit_DMA PROC
;;;948      */
;;;949    HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;950    {
000002  4604              MOV      r4,r0
000004  4615              MOV      r5,r2
;;;951      uint32_t *tmp;
;;;952    
;;;953      /* Check that a Tx process is not already ongoing */
;;;954      if(huart->gState == HAL_UART_STATE_READY)
000006  6ee0              LDR      r0,[r4,#0x6c]
000008  2820              CMP      r0,#0x20
00000a  d13b              BNE      |L29.132|
;;;955      {
;;;956        if((pData == NULL ) || (Size == 0U))
00000c  9801              LDR      r0,[sp,#4]
00000e  b100              CBZ      r0,|L29.18|
000010  b90d              CBNZ     r5,|L29.22|
                  |L29.18|
;;;957        {
;;;958          return HAL_ERROR;
000012  2001              MOVS     r0,#1
                  |L29.20|
;;;959        }
;;;960    
;;;961        /* Process Locked */
;;;962        __HAL_LOCK(huart);
;;;963    
;;;964        huart->pTxBuffPtr = pData;
;;;965        huart->TxXferSize = Size;
;;;966        huart->TxXferCount = Size;
;;;967    
;;;968        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;969        huart->gState = HAL_UART_STATE_BUSY_TX;
;;;970    
;;;971        /* Set the UART DMA transfer complete callback */
;;;972        huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
;;;973    
;;;974        /* Set the UART DMA Half transfer complete callback */
;;;975        huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
;;;976    
;;;977        /* Set the DMA error callback */
;;;978        huart->hdmatx->XferErrorCallback = UART_DMAError;
;;;979    
;;;980        /* Set the DMA abort callback */
;;;981        huart->hdmatx->XferAbortCallback = NULL;
;;;982    
;;;983        /* Enable the UART transmit DMA channel */
;;;984        tmp = (uint32_t*)&pData;
;;;985        HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t*)tmp, (uint32_t)&huart->Instance->TDR, Size);
;;;986    
;;;987        /* Clear the TC flag in the SR register by writing 0 to it */
;;;988        __HAL_UART_CLEAR_IT(huart, UART_FLAG_TC);
;;;989    
;;;990        /* Process Unlocked */
;;;991        __HAL_UNLOCK(huart);
;;;992    
;;;993        /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;994           in the UART CR3 register */
;;;995        SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;996    
;;;997        return HAL_OK;
;;;998      }
;;;999      else
;;;1000     {
;;;1001       return HAL_BUSY;
;;;1002     }
;;;1003   }
000014  bdfe              POP      {r1-r7,pc}
                  |L29.22|
000016  bf00              NOP                            ;962
000018  6ea0              LDR      r0,[r4,#0x68]         ;962
00001a  2801              CMP      r0,#1                 ;962
00001c  d101              BNE      |L29.34|
00001e  2002              MOVS     r0,#2                 ;962
000020  e7f8              B        |L29.20|
                  |L29.34|
000022  2001              MOVS     r0,#1                 ;962
000024  66a0              STR      r0,[r4,#0x68]         ;962
000026  bf00              NOP                            ;962
000028  9801              LDR      r0,[sp,#4]            ;964
00002a  64e0              STR      r0,[r4,#0x4c]         ;964
00002c  f8a45050          STRH     r5,[r4,#0x50]         ;965
000030  f8a45052          STRH     r5,[r4,#0x52]         ;966
000034  2000              MOVS     r0,#0                 ;968
000036  6760              STR      r0,[r4,#0x74]         ;968
000038  2021              MOVS     r0,#0x21              ;969
00003a  66e0              STR      r0,[r4,#0x6c]         ;969
00003c  4812              LDR      r0,|L29.136|
00003e  6e21              LDR      r1,[r4,#0x60]         ;972
000040  6408              STR      r0,[r1,#0x40]         ;972
000042  4812              LDR      r0,|L29.140|
000044  6e21              LDR      r1,[r4,#0x60]         ;975
000046  6448              STR      r0,[r1,#0x44]         ;975
000048  4811              LDR      r0,|L29.144|
00004a  6e21              LDR      r1,[r4,#0x60]         ;978
00004c  6508              STR      r0,[r1,#0x50]         ;978
00004e  2000              MOVS     r0,#0                 ;981
000050  6e21              LDR      r1,[r4,#0x60]         ;981
000052  6548              STR      r0,[r1,#0x54]         ;981
000054  ae01              ADD      r6,sp,#4              ;984
000056  6823              LDR      r3,[r4,#0]            ;985
000058  f1030228          ADD      r2,r3,#0x28           ;985
00005c  6831              LDR      r1,[r6,#0]            ;985
00005e  462b              MOV      r3,r5                 ;985
000060  6e20              LDR      r0,[r4,#0x60]         ;985
000062  f7fffffe          BL       HAL_DMA_Start_IT
000066  2040              MOVS     r0,#0x40              ;988
000068  6821              LDR      r1,[r4,#0]            ;988
00006a  6208              STR      r0,[r1,#0x20]         ;988
00006c  bf00              NOP                            ;991
00006e  2000              MOVS     r0,#0                 ;991
000070  66a0              STR      r0,[r4,#0x68]         ;991
000072  bf00              NOP                            ;991
000074  6820              LDR      r0,[r4,#0]            ;995
000076  6880              LDR      r0,[r0,#8]            ;995
000078  f0400080          ORR      r0,r0,#0x80           ;995
00007c  6821              LDR      r1,[r4,#0]            ;995
00007e  6088              STR      r0,[r1,#8]            ;995
000080  2000              MOVS     r0,#0                 ;997
000082  e7c7              B        |L29.20|
                  |L29.132|
000084  2002              MOVS     r0,#2                 ;1001
000086  e7c5              B        |L29.20|
;;;1004   
                          ENDP

                  |L29.136|
                          DCD      UART_DMATransmitCplt
                  |L29.140|
                          DCD      UART_DMATxHalfCplt
                  |L29.144|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit_IT PROC
;;;857      */
;;;858    HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;859    {
000002  4603              MOV      r3,r0
;;;860      /* Check that a Tx process is not already ongoing */
;;;861      if(huart->gState == HAL_UART_STATE_READY)
000004  6ed8              LDR      r0,[r3,#0x6c]
000006  2820              CMP      r0,#0x20
000008  d121              BNE      |L30.78|
;;;862      {
;;;863        if((pData == NULL ) || (Size == 0U))
00000a  b101              CBZ      r1,|L30.14|
00000c  b90a              CBNZ     r2,|L30.18|
                  |L30.14|
;;;864        {
;;;865          return HAL_ERROR;
00000e  2001              MOVS     r0,#1
                  |L30.16|
;;;866        }
;;;867    
;;;868        /* Process Locked */
;;;869        __HAL_LOCK(huart);
;;;870    
;;;871        huart->pTxBuffPtr = pData;
;;;872        huart->TxXferSize = Size;
;;;873        huart->TxXferCount = Size;
;;;874    
;;;875        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;876        huart->gState = HAL_UART_STATE_BUSY_TX;
;;;877    
;;;878        /* Process Unlocked */
;;;879        __HAL_UNLOCK(huart);
;;;880    
;;;881        /* Enable the UART Transmit Data Register Empty Interrupt */
;;;882        SET_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
;;;883    
;;;884        return HAL_OK;
;;;885      }
;;;886      else
;;;887      {
;;;888        return HAL_BUSY;
;;;889      }
;;;890    }
000010  bd10              POP      {r4,pc}
                  |L30.18|
000012  bf00              NOP                            ;869
000014  6e98              LDR      r0,[r3,#0x68]         ;869
000016  2801              CMP      r0,#1                 ;869
000018  d101              BNE      |L30.30|
00001a  2002              MOVS     r0,#2                 ;869
00001c  e7f8              B        |L30.16|
                  |L30.30|
00001e  2001              MOVS     r0,#1                 ;869
000020  6698              STR      r0,[r3,#0x68]         ;869
000022  bf00              NOP                            ;869
000024  64d9              STR      r1,[r3,#0x4c]         ;871
000026  f8a32050          STRH     r2,[r3,#0x50]         ;872
00002a  f8a32052          STRH     r2,[r3,#0x52]         ;873
00002e  2000              MOVS     r0,#0                 ;875
000030  6758              STR      r0,[r3,#0x74]         ;875
000032  2021              MOVS     r0,#0x21              ;876
000034  66d8              STR      r0,[r3,#0x6c]         ;876
000036  bf00              NOP                            ;879
000038  2000              MOVS     r0,#0                 ;879
00003a  6698              STR      r0,[r3,#0x68]         ;879
00003c  bf00              NOP                            ;879
00003e  6818              LDR      r0,[r3,#0]            ;882
000040  6800              LDR      r0,[r0,#0]            ;882
000042  f0400080          ORR      r0,r0,#0x80           ;882
000046  681c              LDR      r4,[r3,#0]            ;882
000048  6020              STR      r0,[r4,#0]            ;882
00004a  2000              MOVS     r0,#0                 ;884
00004c  e7e0              B        |L30.16|
                  |L30.78|
00004e  2002              MOVS     r0,#2                 ;888
000050  e7de              B        |L30.16|
;;;891    
                          ENDP


                          AREA ||i.HAL_UART_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxCpltCallback PROC
;;;1490     */
;;;1491    __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1492   {
;;;1493     /* Prevent unused argument(s) compilation warning */
;;;1494     UNUSED(huart);
;;;1495   
;;;1496     /* NOTE : This function should not be modified, when the callback is needed,
;;;1497               the HAL_UART_TxCpltCallback can be implemented in the user file
;;;1498      */
;;;1499   }
;;;1500   
                          ENDP


                          AREA ||i.HAL_UART_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxHalfCpltCallback PROC
;;;1505     */
;;;1506    __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1507   {
;;;1508     /* Prevent unused argument(s) compilation warning */
;;;1509     UNUSED(huart);
;;;1510   
;;;1511     /* NOTE: This function should not be modified, when the callback is needed,
;;;1512              the HAL_UART_TxHalfCpltCallback can be implemented in the user file
;;;1513      */
;;;1514   }
;;;1515   
                          ENDP


                          AREA ||i.UART_AdvFeatureConfig||, CODE, READONLY, ALIGN=1

                  UART_AdvFeatureConfig PROC
;;;1938     */
;;;1939   void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
000000  f8901024          LDRB     r1,[r0,#0x24]
;;;1940   {
;;;1941     /* Check whether the set of advanced features to configure is properly set */
;;;1942     assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
;;;1943   
;;;1944     /* if required, configure TX pin active level inversion */
;;;1945     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
000004  f0010101          AND      r1,r1,#1
000008  b139              CBZ      r1,|L33.26|
;;;1946     {
;;;1947       assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
;;;1948       MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
00000a  6801              LDR      r1,[r0,#0]
00000c  6849              LDR      r1,[r1,#4]
00000e  f4213100          BIC      r1,r1,#0x20000
000012  6a82              LDR      r2,[r0,#0x28]
000014  4311              ORRS     r1,r1,r2
000016  6802              LDR      r2,[r0,#0]
000018  6051              STR      r1,[r2,#4]
                  |L33.26|
;;;1949     }
;;;1950   
;;;1951     /* if required, configure RX pin active level inversion */
;;;1952     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
00001a  f8901024          LDRB     r1,[r0,#0x24]
00001e  f0010102          AND      r1,r1,#2
000022  b139              CBZ      r1,|L33.52|
;;;1953     {
;;;1954       assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
;;;1955       MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
000024  6801              LDR      r1,[r0,#0]
000026  6849              LDR      r1,[r1,#4]
000028  f4213180          BIC      r1,r1,#0x10000
00002c  6ac2              LDR      r2,[r0,#0x2c]
00002e  4311              ORRS     r1,r1,r2
000030  6802              LDR      r2,[r0,#0]
000032  6051              STR      r1,[r2,#4]
                  |L33.52|
;;;1956     }
;;;1957   
;;;1958     /* if required, configure data inversion */
;;;1959     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
000034  f8901024          LDRB     r1,[r0,#0x24]
000038  f0010104          AND      r1,r1,#4
00003c  b139              CBZ      r1,|L33.78|
;;;1960     {
;;;1961       assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
;;;1962       MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
00003e  6801              LDR      r1,[r0,#0]
000040  6849              LDR      r1,[r1,#4]
000042  f4212180          BIC      r1,r1,#0x40000
000046  6b02              LDR      r2,[r0,#0x30]
000048  4311              ORRS     r1,r1,r2
00004a  6802              LDR      r2,[r0,#0]
00004c  6051              STR      r1,[r2,#4]
                  |L33.78|
;;;1963     }
;;;1964   
;;;1965     /* if required, configure RX/TX pins swap */
;;;1966     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
00004e  f8901024          LDRB     r1,[r0,#0x24]
000052  f0010108          AND      r1,r1,#8
000056  b139              CBZ      r1,|L33.104|
;;;1967     {
;;;1968       assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
;;;1969       MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
000058  6801              LDR      r1,[r0,#0]
00005a  6849              LDR      r1,[r1,#4]
00005c  f4214100          BIC      r1,r1,#0x8000
000060  6b42              LDR      r2,[r0,#0x34]
000062  4311              ORRS     r1,r1,r2
000064  6802              LDR      r2,[r0,#0]
000066  6051              STR      r1,[r2,#4]
                  |L33.104|
;;;1970     }
;;;1971   
;;;1972     /* if required, configure RX overrun detection disabling */
;;;1973     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
000068  f8901024          LDRB     r1,[r0,#0x24]
00006c  f0010110          AND      r1,r1,#0x10
000070  b139              CBZ      r1,|L33.130|
;;;1974     {
;;;1975       assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
;;;1976       MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
000072  6801              LDR      r1,[r0,#0]
000074  6889              LDR      r1,[r1,#8]
000076  f4215180          BIC      r1,r1,#0x1000
00007a  6b82              LDR      r2,[r0,#0x38]
00007c  4311              ORRS     r1,r1,r2
00007e  6802              LDR      r2,[r0,#0]
000080  6091              STR      r1,[r2,#8]
                  |L33.130|
;;;1977     }
;;;1978   
;;;1979     /* if required, configure DMA disabling on reception error */
;;;1980     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
000082  f8901024          LDRB     r1,[r0,#0x24]
000086  f0010120          AND      r1,r1,#0x20
00008a  b139              CBZ      r1,|L33.156|
;;;1981     {
;;;1982       assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
;;;1983       MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
00008c  6801              LDR      r1,[r0,#0]
00008e  6889              LDR      r1,[r1,#8]
000090  f4215100          BIC      r1,r1,#0x2000
000094  6bc2              LDR      r2,[r0,#0x3c]
000096  4311              ORRS     r1,r1,r2
000098  6802              LDR      r2,[r0,#0]
00009a  6091              STR      r1,[r2,#8]
                  |L33.156|
;;;1984     }
;;;1985   
;;;1986     /* if required, configure auto Baud rate detection scheme */
;;;1987     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
00009c  f8901024          LDRB     r1,[r0,#0x24]
0000a0  f0010140          AND      r1,r1,#0x40
0000a4  b199              CBZ      r1,|L33.206|
;;;1988     {
;;;1989       assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
;;;1990       MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
0000a6  6801              LDR      r1,[r0,#0]
0000a8  6849              LDR      r1,[r1,#4]
0000aa  f4211180          BIC      r1,r1,#0x100000
0000ae  6c02              LDR      r2,[r0,#0x40]
0000b0  4311              ORRS     r1,r1,r2
0000b2  6802              LDR      r2,[r0,#0]
0000b4  6051              STR      r1,[r2,#4]
;;;1991       /* set auto Baudrate detection parameters if detection is enabled */
;;;1992       if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
0000b6  6c01              LDR      r1,[r0,#0x40]
0000b8  f5b11f80          CMP      r1,#0x100000
0000bc  d107              BNE      |L33.206|
;;;1993       {
;;;1994         assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
;;;1995         MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
0000be  6801              LDR      r1,[r0,#0]
0000c0  6849              LDR      r1,[r1,#4]
0000c2  f42101c0          BIC      r1,r1,#0x600000
0000c6  6c42              LDR      r2,[r0,#0x44]
0000c8  4311              ORRS     r1,r1,r2
0000ca  6802              LDR      r2,[r0,#0]
0000cc  6051              STR      r1,[r2,#4]
                  |L33.206|
;;;1996       }
;;;1997     }
;;;1998   
;;;1999     /* if required, configure MSB first on communication line */
;;;2000     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
0000ce  f8901024          LDRB     r1,[r0,#0x24]
0000d2  f0010180          AND      r1,r1,#0x80
0000d6  b139              CBZ      r1,|L33.232|
;;;2001     {
;;;2002       assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
;;;2003       MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
0000d8  6801              LDR      r1,[r0,#0]
0000da  6849              LDR      r1,[r1,#4]
0000dc  f4212100          BIC      r1,r1,#0x80000
0000e0  6c82              LDR      r2,[r0,#0x48]
0000e2  4311              ORRS     r1,r1,r2
0000e4  6802              LDR      r2,[r0,#0]
0000e6  6051              STR      r1,[r2,#4]
                  |L33.232|
;;;2004     }
;;;2005   }
0000e8  4770              BX       lr
;;;2006   
                          ENDP


                          AREA ||i.UART_CheckIdleState||, CODE, READONLY, ALIGN=1

                  UART_CheckIdleState PROC
;;;2013     */
;;;2014   HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
000000  b538              PUSH     {r3-r5,lr}
;;;2015   {
000002  4604              MOV      r4,r0
;;;2016     uint32_t tickstart = 0U;
000004  2500              MOVS     r5,#0
;;;2017   
;;;2018     /* Initialize the UART ErrorCode */
;;;2019     huart->ErrorCode = HAL_UART_ERROR_NONE;
000006  2000              MOVS     r0,#0
000008  6760              STR      r0,[r4,#0x74]
;;;2020   
;;;2021     /* Init tickstart for timeout managment*/
;;;2022     tickstart = HAL_GetTick();
00000a  f7fffffe          BL       HAL_GetTick
00000e  4605              MOV      r5,r0
;;;2023   
;;;2024     /* Check if the Transmitter is enabled */
;;;2025     if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
000010  6820              LDR      r0,[r4,#0]
000012  6800              LDR      r0,[r0,#0]
000014  f0000008          AND      r0,r0,#8
000018  2808              CMP      r0,#8
00001a  d10c              BNE      |L34.54|
;;;2026     {
;;;2027       /* Wait until TEACK flag is set */
;;;2028       if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
00001c  f06f407e          MVN      r0,#0xfe000000
000020  462b              MOV      r3,r5
000022  2200              MOVS     r2,#0
000024  f44f1100          MOV      r1,#0x200000
000028  9000              STR      r0,[sp,#0]
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000030  b108              CBZ      r0,|L34.54|
;;;2029       {
;;;2030         /* Timeout Occurred */
;;;2031         return HAL_TIMEOUT;
000032  2003              MOVS     r0,#3
                  |L34.52|
;;;2032       }
;;;2033     }
;;;2034     /* Check if the Receiver is enabled */
;;;2035     if((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
;;;2036     {
;;;2037       /* Wait until REACK flag is set */
;;;2038       if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
;;;2039       {
;;;2040         /* Timeout Occurred */
;;;2041         return HAL_TIMEOUT;
;;;2042       }
;;;2043     }
;;;2044   
;;;2045     /* Initialize the UART State */
;;;2046     huart->gState= HAL_UART_STATE_READY;
;;;2047     huart->RxState= HAL_UART_STATE_READY;
;;;2048   
;;;2049     /* Process Unlocked */
;;;2050     __HAL_UNLOCK(huart);
;;;2051   
;;;2052     return HAL_OK;
;;;2053   }
000034  bd38              POP      {r3-r5,pc}
                  |L34.54|
000036  6820              LDR      r0,[r4,#0]            ;2035
000038  6800              LDR      r0,[r0,#0]            ;2035
00003a  f0000004          AND      r0,r0,#4              ;2035
00003e  2804              CMP      r0,#4                 ;2035
000040  d10c              BNE      |L34.92|
000042  f06f407e          MVN      r0,#0xfe000000        ;2038
000046  462b              MOV      r3,r5                 ;2038
000048  2200              MOVS     r2,#0                 ;2038
00004a  f44f0180          MOV      r1,#0x400000          ;2038
00004e  9000              STR      r0,[sp,#0]            ;2038
000050  4620              MOV      r0,r4                 ;2038
000052  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000056  b108              CBZ      r0,|L34.92|
000058  2003              MOVS     r0,#3                 ;2041
00005a  e7eb              B        |L34.52|
                  |L34.92|
00005c  2020              MOVS     r0,#0x20              ;2046
00005e  66e0              STR      r0,[r4,#0x6c]         ;2046
000060  6720              STR      r0,[r4,#0x70]         ;2047
000062  bf00              NOP                            ;2050
000064  2000              MOVS     r0,#0                 ;2050
000066  66a0              STR      r0,[r4,#0x68]         ;2050
000068  bf00              NOP                            ;2050
00006a  bf00              NOP                            ;2052
00006c  e7e2              B        |L34.52|
;;;2054   
                          ENDP


                          AREA ||i.UART_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  UART_DMAAbortOnError PROC
;;;1476     */
;;;1477   static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1478   {
000002  4605              MOV      r5,r0
;;;1479     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)(hdma->Parent);
000004  6bec              LDR      r4,[r5,#0x3c]
;;;1480     huart->RxXferCount = 0U;
000006  2000              MOVS     r0,#0
000008  f8a4005a          STRH     r0,[r4,#0x5a]
;;;1481     huart->TxXferCount = 0U;
00000c  f8a40052          STRH     r0,[r4,#0x52]
;;;1482   
;;;1483     HAL_UART_ErrorCallback(huart);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       HAL_UART_ErrorCallback
;;;1484   }
000016  bd70              POP      {r4-r6,pc}
;;;1485   
                          ENDP


                          AREA ||i.UART_DMAError||, CODE, READONLY, ALIGN=1

                  UART_DMAError PROC
;;;1448     */
;;;1449   static void UART_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1450   {
000002  4605              MOV      r5,r0
;;;1451     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bec              LDR      r4,[r5,#0x3c]
;;;1452     huart->RxXferCount = 0U;
000006  2000              MOVS     r0,#0
000008  f8a4005a          STRH     r0,[r4,#0x5a]
;;;1453     huart->TxXferCount = 0U;
00000c  f8a40052          STRH     r0,[r4,#0x52]
;;;1454     /* Stop UART DMA Tx request if ongoing */
;;;1455     if (  (huart->gState == HAL_UART_STATE_BUSY_TX)
000010  6ee0              LDR      r0,[r4,#0x6c]
000012  2821              CMP      r0,#0x21
000014  d107              BNE      |L36.38|
;;;1456         &&(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) )
000016  6820              LDR      r0,[r4,#0]
000018  6880              LDR      r0,[r0,#8]
00001a  f0000080          AND      r0,r0,#0x80
00001e  b110              CBZ      r0,|L36.38|
;;;1457     {
;;;1458       UART_EndTxTransfer(huart);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       UART_EndTxTransfer
                  |L36.38|
;;;1459     }
;;;1460   
;;;1461     /* Stop UART DMA Rx request if ongoing */
;;;1462     if (  (huart->RxState == HAL_UART_STATE_BUSY_RX)
000026  6f20              LDR      r0,[r4,#0x70]
000028  2822              CMP      r0,#0x22
00002a  d107              BNE      |L36.60|
;;;1463         &&(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) )
00002c  6820              LDR      r0,[r4,#0]
00002e  6880              LDR      r0,[r0,#8]
000030  f0000040          AND      r0,r0,#0x40
000034  b110              CBZ      r0,|L36.60|
;;;1464     {
;;;1465       UART_EndRxTransfer(huart);
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       UART_EndRxTransfer
                  |L36.60|
;;;1466     }
;;;1467     SET_BIT(huart->ErrorCode, HAL_UART_ERROR_DMA);
00003c  6f60              LDR      r0,[r4,#0x74]
00003e  f0400010          ORR      r0,r0,#0x10
000042  6760              STR      r0,[r4,#0x74]
;;;1468     HAL_UART_ErrorCallback(huart);
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       HAL_UART_ErrorCallback
;;;1469   }
00004a  bd70              POP      {r4-r6,pc}
;;;1470   
                          ENDP


                          AREA ||i.UART_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  UART_DMAReceiveCplt PROC
;;;1408     */
;;;1409   static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1410   {
000002  4605              MOV      r5,r0
;;;1411     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bec              LDR      r4,[r5,#0x3c]
;;;1412   
;;;1413     /* DMA Normal mode */
;;;1414     if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
000006  6828              LDR      r0,[r5,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  f4007080          AND      r0,r0,#0x100
00000e  b9b0              CBNZ     r0,|L37.62|
;;;1415     {
;;;1416       huart->RxXferCount = 0U;
000010  2000              MOVS     r0,#0
000012  f8a4005a          STRH     r0,[r4,#0x5a]
;;;1417   
;;;1418       /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1419       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
000016  6820              LDR      r0,[r4,#0]
000018  6800              LDR      r0,[r0,#0]
00001a  f4207080          BIC      r0,r0,#0x100
00001e  6821              LDR      r1,[r4,#0]
000020  6008              STR      r0,[r1,#0]
;;;1420       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000022  6820              LDR      r0,[r4,#0]
000024  6880              LDR      r0,[r0,#8]
000026  f0200001          BIC      r0,r0,#1
00002a  6821              LDR      r1,[r4,#0]
00002c  6088              STR      r0,[r1,#8]
;;;1421   
;;;1422       /* Disable the DMA transfer for the receiver request by setting the DMAR bit
;;;1423       in the UART CR3 register */
;;;1424       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
00002e  6820              LDR      r0,[r4,#0]
000030  6880              LDR      r0,[r0,#8]
000032  f0200040          BIC      r0,r0,#0x40
000036  6821              LDR      r1,[r4,#0]
000038  6088              STR      r0,[r1,#8]
;;;1425   
;;;1426   	/* At end of Rx process, restore huart->RxState to Ready */
;;;1427       huart->RxState = HAL_UART_STATE_READY;
00003a  2020              MOVS     r0,#0x20
00003c  6720              STR      r0,[r4,#0x70]
                  |L37.62|
;;;1428     }
;;;1429     HAL_UART_RxCpltCallback(huart);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       HAL_UART_RxCpltCallback
;;;1430   }
000044  bd70              POP      {r4-r6,pc}
;;;1431   
                          ENDP


                          AREA ||i.UART_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMARxHalfCplt PROC
;;;1436     */
;;;1437   static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1438   {
000002  4604              MOV      r4,r0
;;;1439     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000004  6be5              LDR      r5,[r4,#0x3c]
;;;1440   
;;;1441     HAL_UART_RxHalfCpltCallback(huart);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_UART_RxHalfCpltCallback
;;;1442   }
00000c  bd70              POP      {r4-r6,pc}
;;;1443   
                          ENDP


                          AREA ||i.UART_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATransmitCplt PROC
;;;1368     */
;;;1369   static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1370   {
000002  4605              MOV      r5,r0
;;;1371     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bec              LDR      r4,[r5,#0x3c]
;;;1372   
;;;1373     /* DMA Normal mode*/
;;;1374     if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
000006  6828              LDR      r0,[r5,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  f4007080          AND      r0,r0,#0x100
00000e  b978              CBNZ     r0,|L39.48|
;;;1375     {
;;;1376       huart->TxXferCount = 0U;
000010  2000              MOVS     r0,#0
000012  f8a40052          STRH     r0,[r4,#0x52]
;;;1377   
;;;1378       /* Disable the DMA transfer for transmit request by setting the DMAT bit
;;;1379          in the UART CR3 register */
;;;1380       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000016  6820              LDR      r0,[r4,#0]
000018  6880              LDR      r0,[r0,#8]
00001a  f0200080          BIC      r0,r0,#0x80
00001e  6821              LDR      r1,[r4,#0]
000020  6088              STR      r0,[r1,#8]
;;;1381   
;;;1382       /* Enable the UART Transmit Complete Interrupt */
;;;1383       SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
000022  6820              LDR      r0,[r4,#0]
000024  6800              LDR      r0,[r0,#0]
000026  f0400040          ORR      r0,r0,#0x40
00002a  6821              LDR      r1,[r4,#0]
00002c  6008              STR      r0,[r1,#0]
00002e  e002              B        |L39.54|
                  |L39.48|
;;;1384     }
;;;1385     /* DMA Circular mode */
;;;1386     else
;;;1387     {
;;;1388       HAL_UART_TxCpltCallback(huart);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       HAL_UART_TxCpltCallback
                  |L39.54|
;;;1389     }
;;;1390   }
000036  bd70              POP      {r4-r6,pc}
;;;1391   
                          ENDP


                          AREA ||i.UART_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATxHalfCplt PROC
;;;1396     */
;;;1397   static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1398   {
000002  4604              MOV      r4,r0
;;;1399     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000004  6be5              LDR      r5,[r4,#0x3c]
;;;1400   
;;;1401     HAL_UART_TxHalfCpltCallback(huart);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_UART_TxHalfCpltCallback
;;;1402   }
00000c  bd70              POP      {r4-r6,pc}
;;;1403   
                          ENDP


                          AREA ||i.UART_EndRxTransfer||, CODE, READONLY, ALIGN=1

                  UART_EndRxTransfer PROC
;;;1702     */
;;;1703   static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
000000  6801              LDR      r1,[r0,#0]
;;;1704   {
;;;1705     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1706     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000002  6809              LDR      r1,[r1,#0]
000004  f4217190          BIC      r1,r1,#0x120
000008  6802              LDR      r2,[r0,#0]
00000a  6011              STR      r1,[r2,#0]
;;;1707     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000c  6801              LDR      r1,[r0,#0]
00000e  6889              LDR      r1,[r1,#8]
000010  f0210101          BIC      r1,r1,#1
000014  6802              LDR      r2,[r0,#0]
000016  6091              STR      r1,[r2,#8]
;;;1708   
;;;1709     /* At end of Rx process, restore huart->RxState to Ready */
;;;1710     huart->RxState = HAL_UART_STATE_READY;
000018  2120              MOVS     r1,#0x20
00001a  6701              STR      r1,[r0,#0x70]
;;;1711   }
00001c  4770              BX       lr
;;;1712   
                          ENDP


                          AREA ||i.UART_EndTransmit_IT||, CODE, READONLY, ALIGN=1

                  UART_EndTransmit_IT PROC
;;;1615     */
;;;1616   static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1617   {
000002  4604              MOV      r4,r0
;;;1618     /* Disable the UART Transmit Complete Interrupt */
;;;1619     CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
000004  6820              LDR      r0,[r4,#0]
000006  6800              LDR      r0,[r0,#0]
000008  f0200040          BIC      r0,r0,#0x40
00000c  6821              LDR      r1,[r4,#0]
00000e  6008              STR      r0,[r1,#0]
;;;1620   
;;;1621     /* Tx process is ended, restore huart->gState to Ready */
;;;1622     huart->gState = HAL_UART_STATE_READY;
000010  2020              MOVS     r0,#0x20
000012  66e0              STR      r0,[r4,#0x6c]
;;;1623   
;;;1624     HAL_UART_TxCpltCallback(huart);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       HAL_UART_TxCpltCallback
;;;1625   
;;;1626     return HAL_OK;
00001a  2000              MOVS     r0,#0
;;;1627   }
00001c  bd10              POP      {r4,pc}
;;;1628   
                          ENDP


                          AREA ||i.UART_EndTxTransfer||, CODE, READONLY, ALIGN=1

                  UART_EndTxTransfer PROC
;;;1687     */
;;;1688   static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
000000  6801              LDR      r1,[r0,#0]
;;;1689   {
;;;1690     /* Disable TXEIE and TCIE interrupts */
;;;1691     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000002  6809              LDR      r1,[r1,#0]
000004  f02101c0          BIC      r1,r1,#0xc0
000008  6802              LDR      r2,[r0,#0]
00000a  6011              STR      r1,[r2,#0]
;;;1692   
;;;1693     /* At end of Tx process, restore huart->gState to Ready */
;;;1694     huart->gState = HAL_UART_STATE_READY;
00000c  2120              MOVS     r1,#0x20
00000e  66c1              STR      r1,[r0,#0x6c]
;;;1695   }
000010  4770              BX       lr
;;;1696   
                          ENDP


                          AREA ||i.UART_Receive_IT||, CODE, READONLY, ALIGN=1

                  UART_Receive_IT PROC
;;;1635     */
;;;1636   static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1637   {
000002  4604              MOV      r4,r0
;;;1638     uint16_t* tmp;
;;;1639     uint16_t uhMask = huart->Mask;
000004  f8b4605c          LDRH     r6,[r4,#0x5c]
;;;1640   
;;;1641     /* Check that a Rx process is ongoing */
;;;1642     if(huart->RxState == HAL_UART_STATE_BUSY_RX)
000008  6f20              LDR      r0,[r4,#0x70]
00000a  2822              CMP      r0,#0x22
00000c  d132              BNE      |L44.116|
;;;1643     {
;;;1644   
;;;1645       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
00000e  68a0              LDR      r0,[r4,#8]
000010  f5b05f80          CMP      r0,#0x1000
000014  d10a              BNE      |L44.44|
000016  6920              LDR      r0,[r4,#0x10]
000018  b940              CBNZ     r0,|L44.44|
;;;1646       {
;;;1647         tmp = (uint16_t*) huart->pRxBuffPtr ;
00001a  6d65              LDR      r5,[r4,#0x54]
;;;1648         *tmp = (uint16_t)(huart->Instance->RDR & uhMask);
00001c  6820              LDR      r0,[r4,#0]
00001e  6a40              LDR      r0,[r0,#0x24]
000020  4030              ANDS     r0,r0,r6
000022  8028              STRH     r0,[r5,#0]
;;;1649         huart->pRxBuffPtr +=2;
000024  6d60              LDR      r0,[r4,#0x54]
000026  1c80              ADDS     r0,r0,#2
000028  6560              STR      r0,[r4,#0x54]
00002a  e007              B        |L44.60|
                  |L44.44|
;;;1650       }
;;;1651       else
;;;1652       {
;;;1653         *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
00002c  6820              LDR      r0,[r4,#0]
00002e  6a40              LDR      r0,[r0,#0x24]
000030  b2f1              UXTB     r1,r6
000032  4008              ANDS     r0,r0,r1
000034  6d62              LDR      r2,[r4,#0x54]
000036  1c51              ADDS     r1,r2,#1
000038  6561              STR      r1,[r4,#0x54]
00003a  7010              STRB     r0,[r2,#0]
                  |L44.60|
;;;1654       }
;;;1655   
;;;1656       if(--huart->RxXferCount == 0)
00003c  f8b4005a          LDRH     r0,[r4,#0x5a]
000040  1e40              SUBS     r0,r0,#1
000042  b280              UXTH     r0,r0
000044  f8a4005a          STRH     r0,[r4,#0x5a]
000048  b990              CBNZ     r0,|L44.112|
;;;1657       {
;;;1658         /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
;;;1659         CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
00004a  6820              LDR      r0,[r4,#0]
00004c  6800              LDR      r0,[r0,#0]
00004e  f4207090          BIC      r0,r0,#0x120
000052  6821              LDR      r1,[r4,#0]
000054  6008              STR      r0,[r1,#0]
;;;1660   
;;;1661         /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1662         CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000056  6820              LDR      r0,[r4,#0]
000058  6880              LDR      r0,[r0,#8]
00005a  f0200001          BIC      r0,r0,#1
00005e  6821              LDR      r1,[r4,#0]
000060  6088              STR      r0,[r1,#8]
;;;1663   
;;;1664         /* Rx process is completed, restore huart->RxState to Ready */
;;;1665         huart->RxState = HAL_UART_STATE_READY;
000062  2020              MOVS     r0,#0x20
000064  6720              STR      r0,[r4,#0x70]
;;;1666   
;;;1667         HAL_UART_RxCpltCallback(huart);
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       HAL_UART_RxCpltCallback
;;;1668   
;;;1669         return HAL_OK;
00006c  2000              MOVS     r0,#0
                  |L44.110|
;;;1670       }
;;;1671   
;;;1672       return HAL_OK;
;;;1673     }
;;;1674     else
;;;1675     {
;;;1676       /* Clear RXNE interrupt flag */
;;;1677       __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
;;;1678   
;;;1679       return HAL_BUSY;
;;;1680     }
;;;1681   }
00006e  bd70              POP      {r4-r6,pc}
                  |L44.112|
000070  2000              MOVS     r0,#0                 ;1672
000072  e7fc              B        |L44.110|
                  |L44.116|
000074  6820              LDR      r0,[r4,#0]            ;1677
000076  6980              LDR      r0,[r0,#0x18]         ;1677
000078  f0400008          ORR      r0,r0,#8              ;1677
00007c  6821              LDR      r1,[r4,#0]            ;1677
00007e  6188              STR      r0,[r1,#0x18]         ;1677
000080  2002              MOVS     r0,#2                 ;1679
000082  e7f4              B        |L44.110|
;;;1682   
                          ENDP


                          AREA ||i.UART_SetConfig||, CODE, READONLY, ALIGN=2

                  UART_SetConfig PROC
;;;1827     */
;;;1828   HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1829   {
000004  4604              MOV      r4,r0
;;;1830     uint32_t tmpreg                     = 0x00000000U;
000006  2500              MOVS     r5,#0
;;;1831     UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
000008  2610              MOVS     r6,#0x10
;;;1832     uint16_t brrtemp                    = 0x0000U;
00000a  2700              MOVS     r7,#0
;;;1833     uint16_t usartdiv                   = 0x0000U;
00000c  46a8              MOV      r8,r5
;;;1834     HAL_StatusTypeDef ret               = HAL_OK;
00000e  46a9              MOV      r9,r5
;;;1835   
;;;1836     /* Check the parameters */
;;;1837     assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
;;;1838     assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;1839     assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
;;;1840     assert_param(IS_UART_PARITY(huart->Init.Parity));
;;;1841     assert_param(IS_UART_MODE(huart->Init.Mode));
;;;1842     assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
;;;1843     assert_param(IS_UART_ONE_BIT_SAMPLE(huart->Init.OneBitSampling));
;;;1844   
;;;1845   
;;;1846     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;1847     /* Clear M, PCE, PS, TE, RE and OVER8 bits and configure
;;;1848      *  the UART Word Length, Parity, Mode and oversampling:
;;;1849      *  set the M bits according to huart->Init.WordLength value
;;;1850      *  set PCE and PS bits according to huart->Init.Parity value
;;;1851      *  set TE and RE bits according to huart->Init.Mode value
;;;1852      *  set OVER8 bit according to huart->Init.OverSampling value */
;;;1853     tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
000010  6921              LDR      r1,[r4,#0x10]
000012  68a0              LDR      r0,[r4,#8]
000014  4308              ORRS     r0,r0,r1
000016  6961              LDR      r1,[r4,#0x14]
000018  4308              ORRS     r0,r0,r1
00001a  69e1              LDR      r1,[r4,#0x1c]
00001c  ea400501          ORR      r5,r0,r1
;;;1854     MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
000020  6820              LDR      r0,[r4,#0]
000022  6800              LDR      r0,[r0,#0]
000024  49cd              LDR      r1,|L45.860|
000026  4008              ANDS     r0,r0,r1
000028  4328              ORRS     r0,r0,r5
00002a  6821              LDR      r1,[r4,#0]
00002c  6008              STR      r0,[r1,#0]
;;;1855   
;;;1856     /*-------------------------- USART CR2 Configuration -----------------------*/
;;;1857     /* Configure the UART Stop Bits: Set STOP[13:12] bits according
;;;1858      * to huart->Init.StopBits value */
;;;1859     MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
00002e  6820              LDR      r0,[r4,#0]
000030  6840              LDR      r0,[r0,#4]
000032  f4205040          BIC      r0,r0,#0x3000
000036  68e1              LDR      r1,[r4,#0xc]
000038  4308              ORRS     r0,r0,r1
00003a  6821              LDR      r1,[r4,#0]
00003c  6048              STR      r0,[r1,#4]
;;;1860   
;;;1861     /*-------------------------- USART CR3 Configuration -----------------------*/
;;;1862     /* Configure
;;;1863      * - UART HardWare Flow Control: set CTSE and RTSE bits according
;;;1864      *   to huart->Init.HwFlowCtl value
;;;1865      * - one-bit sampling method versus three samples' majority rule according
;;;1866      *   to huart->Init.OneBitSampling */
;;;1867     tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
00003e  6a21              LDR      r1,[r4,#0x20]
000040  69a0              LDR      r0,[r4,#0x18]
000042  ea400501          ORR      r5,r0,r1
;;;1868     MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
000046  6820              LDR      r0,[r4,#0]
000048  6880              LDR      r0,[r0,#8]
00004a  f4206030          BIC      r0,r0,#0xb00
00004e  4328              ORRS     r0,r0,r5
000050  6821              LDR      r1,[r4,#0]
000052  6088              STR      r0,[r1,#8]
;;;1869   
;;;1870     /*-------------------------- USART BRR Configuration -----------------------*/
;;;1871     UART_GETCLOCKSOURCE(huart, clocksource);
000054  bf00              NOP      
000056  49c2              LDR      r1,|L45.864|
000058  6820              LDR      r0,[r4,#0]
00005a  4288              CMP      r0,r1
00005c  d115              BNE      |L45.138|
00005e  48c1              LDR      r0,|L45.868|
000060  6800              LDR      r0,[r0,#0]
000062  f0000003          AND      r0,r0,#3
000066  b130              CBZ      r0,|L45.118|
000068  2801              CMP      r0,#1
00006a  d008              BEQ      |L45.126|
00006c  2802              CMP      r0,#2
00006e  d004              BEQ      |L45.122|
000070  2803              CMP      r0,#3
000072  d108              BNE      |L45.134|
000074  e005              B        |L45.130|
                  |L45.118|
000076  2601              MOVS     r6,#1
000078  e006              B        |L45.136|
                  |L45.122|
00007a  2602              MOVS     r6,#2
00007c  e004              B        |L45.136|
                  |L45.126|
00007e  2604              MOVS     r6,#4
000080  e002              B        |L45.136|
                  |L45.130|
000082  2608              MOVS     r6,#8
000084  e000              B        |L45.136|
                  |L45.134|
000086  bf00              NOP      
                  |L45.136|
000088  e0c1              B        |L45.526|
                  |L45.138|
00008a  49b7              LDR      r1,|L45.872|
00008c  6820              LDR      r0,[r4,#0]
00008e  4288              CMP      r0,r1
000090  d115              BNE      |L45.190|
000092  48b4              LDR      r0,|L45.868|
000094  6800              LDR      r0,[r0,#0]
000096  f000000c          AND      r0,r0,#0xc
00009a  b130              CBZ      r0,|L45.170|
00009c  2804              CMP      r0,#4
00009e  d008              BEQ      |L45.178|
0000a0  2808              CMP      r0,#8
0000a2  d004              BEQ      |L45.174|
0000a4  280c              CMP      r0,#0xc
0000a6  d108              BNE      |L45.186|
0000a8  e005              B        |L45.182|
                  |L45.170|
0000aa  2600              MOVS     r6,#0
0000ac  e006              B        |L45.188|
                  |L45.174|
0000ae  2602              MOVS     r6,#2
0000b0  e004              B        |L45.188|
                  |L45.178|
0000b2  2604              MOVS     r6,#4
0000b4  e002              B        |L45.188|
                  |L45.182|
0000b6  2608              MOVS     r6,#8
0000b8  e000              B        |L45.188|
                  |L45.186|
0000ba  bf00              NOP      
                  |L45.188|
0000bc  e0a7              B        |L45.526|
                  |L45.190|
0000be  49ab              LDR      r1,|L45.876|
0000c0  6820              LDR      r0,[r4,#0]
0000c2  4288              CMP      r0,r1
0000c4  d115              BNE      |L45.242|
0000c6  48a7              LDR      r0,|L45.868|
0000c8  6800              LDR      r0,[r0,#0]
0000ca  f0000030          AND      r0,r0,#0x30
0000ce  b130              CBZ      r0,|L45.222|
0000d0  2810              CMP      r0,#0x10
0000d2  d008              BEQ      |L45.230|
0000d4  2820              CMP      r0,#0x20
0000d6  d004              BEQ      |L45.226|
0000d8  2830              CMP      r0,#0x30
0000da  d108              BNE      |L45.238|
0000dc  e005              B        |L45.234|
                  |L45.222|
0000de  2600              MOVS     r6,#0
0000e0  e006              B        |L45.240|
                  |L45.226|
0000e2  2602              MOVS     r6,#2
0000e4  e004              B        |L45.240|
                  |L45.230|
0000e6  2604              MOVS     r6,#4
0000e8  e002              B        |L45.240|
                  |L45.234|
0000ea  2608              MOVS     r6,#8
0000ec  e000              B        |L45.240|
                  |L45.238|
0000ee  bf00              NOP      
                  |L45.240|
0000f0  e08d              B        |L45.526|
                  |L45.242|
0000f2  499f              LDR      r1,|L45.880|
0000f4  6820              LDR      r0,[r4,#0]
0000f6  4288              CMP      r0,r1
0000f8  d115              BNE      |L45.294|
0000fa  489a              LDR      r0,|L45.868|
0000fc  6800              LDR      r0,[r0,#0]
0000fe  f00000c0          AND      r0,r0,#0xc0
000102  b130              CBZ      r0,|L45.274|
000104  2840              CMP      r0,#0x40
000106  d008              BEQ      |L45.282|
000108  2880              CMP      r0,#0x80
00010a  d004              BEQ      |L45.278|
00010c  28c0              CMP      r0,#0xc0
00010e  d108              BNE      |L45.290|
000110  e005              B        |L45.286|
                  |L45.274|
000112  2600              MOVS     r6,#0
000114  e006              B        |L45.292|
                  |L45.278|
000116  2602              MOVS     r6,#2
000118  e004              B        |L45.292|
                  |L45.282|
00011a  2604              MOVS     r6,#4
00011c  e002              B        |L45.292|
                  |L45.286|
00011e  2608              MOVS     r6,#8
000120  e000              B        |L45.292|
                  |L45.290|
000122  bf00              NOP      
                  |L45.292|
000124  e073              B        |L45.526|
                  |L45.294|
000126  4993              LDR      r1,|L45.884|
000128  6820              LDR      r0,[r4,#0]
00012a  4288              CMP      r0,r1
00012c  d118              BNE      |L45.352|
00012e  488d              LDR      r0,|L45.868|
000130  6800              LDR      r0,[r0,#0]
000132  f4007040          AND      r0,r0,#0x300
000136  b148              CBZ      r0,|L45.332|
000138  f5b07f80          CMP      r0,#0x100
00013c  d00a              BEQ      |L45.340|
00013e  f5b07f00          CMP      r0,#0x200
000142  d005              BEQ      |L45.336|
000144  f5b07f40          CMP      r0,#0x300
000148  d108              BNE      |L45.348|
00014a  e005              B        |L45.344|
                  |L45.332|
00014c  2600              MOVS     r6,#0
00014e  e006              B        |L45.350|
                  |L45.336|
000150  2602              MOVS     r6,#2
000152  e004              B        |L45.350|
                  |L45.340|
000154  2604              MOVS     r6,#4
000156  e002              B        |L45.350|
                  |L45.344|
000158  2608              MOVS     r6,#8
00015a  e000              B        |L45.350|
                  |L45.348|
00015c  bf00              NOP      
                  |L45.350|
00015e  e056              B        |L45.526|
                  |L45.352|
000160  4985              LDR      r1,|L45.888|
000162  6820              LDR      r0,[r4,#0]
000164  4288              CMP      r0,r1
000166  d118              BNE      |L45.410|
000168  487e              LDR      r0,|L45.868|
00016a  6800              LDR      r0,[r0,#0]
00016c  f4006040          AND      r0,r0,#0xc00
000170  b148              CBZ      r0,|L45.390|
000172  f5b06f80          CMP      r0,#0x400
000176  d00a              BEQ      |L45.398|
000178  f5b06f00          CMP      r0,#0x800
00017c  d005              BEQ      |L45.394|
00017e  f5b06f40          CMP      r0,#0xc00
000182  d108              BNE      |L45.406|
000184  e005              B        |L45.402|
                  |L45.390|
000186  2601              MOVS     r6,#1
000188  e006              B        |L45.408|
                  |L45.394|
00018a  2602              MOVS     r6,#2
00018c  e004              B        |L45.408|
                  |L45.398|
00018e  2604              MOVS     r6,#4
000190  e002              B        |L45.408|
                  |L45.402|
000192  2608              MOVS     r6,#8
000194  e000              B        |L45.408|
                  |L45.406|
000196  bf00              NOP      
                  |L45.408|
000198  e039              B        |L45.526|
                  |L45.410|
00019a  4978              LDR      r1,|L45.892|
00019c  6820              LDR      r0,[r4,#0]
00019e  4288              CMP      r0,r1
0001a0  d118              BNE      |L45.468|
0001a2  4870              LDR      r0,|L45.868|
0001a4  6800              LDR      r0,[r0,#0]
0001a6  f4005040          AND      r0,r0,#0x3000
0001aa  b148              CBZ      r0,|L45.448|
0001ac  f5b05f80          CMP      r0,#0x1000
0001b0  d00a              BEQ      |L45.456|
0001b2  f5b05f00          CMP      r0,#0x2000
0001b6  d005              BEQ      |L45.452|
0001b8  f5b05f40          CMP      r0,#0x3000
0001bc  d108              BNE      |L45.464|
0001be  e005              B        |L45.460|
                  |L45.448|
0001c0  2600              MOVS     r6,#0
0001c2  e006              B        |L45.466|
                  |L45.452|
0001c4  2602              MOVS     r6,#2
0001c6  e004              B        |L45.466|
                  |L45.456|
0001c8  2604              MOVS     r6,#4
0001ca  e002              B        |L45.466|
                  |L45.460|
0001cc  2608              MOVS     r6,#8
0001ce  e000              B        |L45.466|
                  |L45.464|
0001d0  bf00              NOP      
                  |L45.466|
0001d2  e01c              B        |L45.526|
                  |L45.468|
0001d4  496a              LDR      r1,|L45.896|
0001d6  6820              LDR      r0,[r4,#0]
0001d8  4288              CMP      r0,r1
0001da  d118              BNE      |L45.526|
0001dc  4861              LDR      r0,|L45.868|
0001de  6800              LDR      r0,[r0,#0]
0001e0  f4004040          AND      r0,r0,#0xc000
0001e4  b148              CBZ      r0,|L45.506|
0001e6  f5b04f80          CMP      r0,#0x4000
0001ea  d00a              BEQ      |L45.514|
0001ec  f5b04f00          CMP      r0,#0x8000
0001f0  d005              BEQ      |L45.510|
0001f2  f5b04f40          CMP      r0,#0xc000
0001f6  d108              BNE      |L45.522|
0001f8  e005              B        |L45.518|
                  |L45.506|
0001fa  2600              MOVS     r6,#0
0001fc  e006              B        |L45.524|
                  |L45.510|
0001fe  2602              MOVS     r6,#2
000200  e004              B        |L45.524|
                  |L45.514|
000202  2604              MOVS     r6,#4
000204  e002              B        |L45.524|
                  |L45.518|
000206  2608              MOVS     r6,#8
000208  e000              B        |L45.524|
                  |L45.522|
00020a  bf00              NOP      
                  |L45.524|
00020c  bf00              NOP      
                  |L45.526|
00020e  bf00              NOP      
;;;1872   
;;;1873     /* Check UART Over Sampling to set Baud Rate Register */
;;;1874     if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
000210  69e0              LDR      r0,[r4,#0x1c]
000212  f5b04f00          CMP      r0,#0x8000
000216  d152              BNE      |L45.702|
;;;1875     {
;;;1876       switch (clocksource)
000218  2e04              CMP      r6,#4
00021a  d02b              BEQ      |L45.628|
00021c  dc05              BGT      |L45.554|
00021e  b14e              CBZ      r6,|L45.564|
000220  2e01              CMP      r6,#1
000222  d012              BEQ      |L45.586|
000224  2e02              CMP      r6,#2
000226  d13b              BNE      |L45.672|
000228  e01a              B        |L45.608|
                  |L45.554|
00022a  2e08              CMP      r6,#8
00022c  d02d              BEQ      |L45.650|
00022e  2e10              CMP      r6,#0x10
000230  d136              BNE      |L45.672|
000232  e036              B        |L45.674|
                  |L45.564|
;;;1877       {
;;;1878       case UART_CLOCKSOURCE_PCLK1:
;;;1879           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
000234  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000238  0040              LSLS     r0,r0,#1
00023a  6861              LDR      r1,[r4,#4]
00023c  eb000051          ADD      r0,r0,r1,LSR #1
000240  fbb0f0f1          UDIV     r0,r0,r1
000244  fa1ff880          UXTH     r8,r0
;;;1880         break;
000248  e02e              B        |L45.680|
                  |L45.586|
;;;1881       case UART_CLOCKSOURCE_PCLK2:
;;;1882           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
00024a  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00024e  0040              LSLS     r0,r0,#1
000250  6861              LDR      r1,[r4,#4]
000252  eb000051          ADD      r0,r0,r1,LSR #1
000256  fbb0f0f1          UDIV     r0,r0,r1
00025a  fa1ff880          UXTH     r8,r0
;;;1883         break;
00025e  e023              B        |L45.680|
                  |L45.608|
;;;1884       case UART_CLOCKSOURCE_HSI:
;;;1885           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
000260  4948              LDR      r1,|L45.900|
000262  6860              LDR      r0,[r4,#4]
000264  eb010050          ADD      r0,r1,r0,LSR #1
000268  6861              LDR      r1,[r4,#4]
00026a  fbb0f0f1          UDIV     r0,r0,r1
00026e  fa1ff880          UXTH     r8,r0
;;;1886         break;
000272  e019              B        |L45.680|
                  |L45.628|
;;;1887       case UART_CLOCKSOURCE_SYSCLK:
;;;1888           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
000274  f7fffffe          BL       HAL_RCC_GetSysClockFreq
000278  0040              LSLS     r0,r0,#1
00027a  6861              LDR      r1,[r4,#4]
00027c  eb000051          ADD      r0,r0,r1,LSR #1
000280  fbb0f0f1          UDIV     r0,r0,r1
000284  fa1ff880          UXTH     r8,r0
;;;1889         break;
000288  e00e              B        |L45.680|
                  |L45.650|
;;;1890       case UART_CLOCKSOURCE_LSE:
;;;1891           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
00028a  f44f3180          MOV      r1,#0x10000
00028e  6860              LDR      r0,[r4,#4]
000290  eb010050          ADD      r0,r1,r0,LSR #1
000294  6861              LDR      r1,[r4,#4]
000296  fbb0f0f1          UDIV     r0,r0,r1
00029a  fa1ff880          UXTH     r8,r0
;;;1892         break;
00029e  e003              B        |L45.680|
                  |L45.672|
;;;1893         case UART_CLOCKSOURCE_UNDEFINED:
0002a0  bf00              NOP      
                  |L45.674|
;;;1894       default:
;;;1895           ret = HAL_ERROR;
0002a2  f04f0901          MOV      r9,#1
;;;1896         break;
0002a6  bf00              NOP      
                  |L45.680|
0002a8  bf00              NOP                            ;1880
;;;1897       }
;;;1898   
;;;1899       brrtemp = usartdiv & 0xFFF0U;
0002aa  f64f70f0          MOV      r0,#0xfff0
0002ae  ea080700          AND      r7,r8,r0
;;;1900       brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
0002b2  f3c80042          UBFX     r0,r8,#1,#3
0002b6  4307              ORRS     r7,r7,r0
;;;1901       huart->Instance->BRR = brrtemp;
0002b8  6820              LDR      r0,[r4,#0]
0002ba  60c7              STR      r7,[r0,#0xc]
0002bc  e04a              B        |L45.852|
                  |L45.702|
;;;1902     }
;;;1903     else
;;;1904     {
;;;1905       switch (clocksource)
0002be  2e04              CMP      r6,#4
0002c0  d02c              BEQ      |L45.796|
0002c2  dc05              BGT      |L45.720|
0002c4  b14e              CBZ      r6,|L45.730|
0002c6  2e01              CMP      r6,#1
0002c8  d012              BEQ      |L45.752|
0002ca  2e02              CMP      r6,#2
0002cc  d13d              BNE      |L45.842|
0002ce  e01a              B        |L45.774|
                  |L45.720|
0002d0  2e08              CMP      r6,#8
0002d2  d02e              BEQ      |L45.818|
0002d4  2e10              CMP      r6,#0x10
0002d6  d138              BNE      |L45.842|
0002d8  e038              B        |L45.844|
                  |L45.730|
;;;1906       {
;;;1907       case UART_CLOCKSOURCE_PCLK1:
;;;1908           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
0002da  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0002de  6861              LDR      r1,[r4,#4]
0002e0  eb000051          ADD      r0,r0,r1,LSR #1
0002e4  fbb0f0f1          UDIV     r0,r0,r1
0002e8  b280              UXTH     r0,r0
0002ea  6821              LDR      r1,[r4,#0]
0002ec  60c8              STR      r0,[r1,#0xc]
;;;1909         break;
0002ee  e030              B        |L45.850|
                  |L45.752|
;;;1910       case UART_CLOCKSOURCE_PCLK2:
;;;1911           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
0002f0  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
0002f4  6861              LDR      r1,[r4,#4]
0002f6  eb000051          ADD      r0,r0,r1,LSR #1
0002fa  fbb0f0f1          UDIV     r0,r0,r1
0002fe  b280              UXTH     r0,r0
000300  6821              LDR      r1,[r4,#0]
000302  60c8              STR      r0,[r1,#0xc]
;;;1912         break;
000304  e025              B        |L45.850|
                  |L45.774|
;;;1913       case UART_CLOCKSOURCE_HSI:
;;;1914           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
000306  4920              LDR      r1,|L45.904|
000308  6860              LDR      r0,[r4,#4]
00030a  eb010050          ADD      r0,r1,r0,LSR #1
00030e  6861              LDR      r1,[r4,#4]
000310  fbb0f0f1          UDIV     r0,r0,r1
000314  b280              UXTH     r0,r0
000316  6821              LDR      r1,[r4,#0]
000318  60c8              STR      r0,[r1,#0xc]
;;;1915         break;
00031a  e01a              B        |L45.850|
                  |L45.796|
;;;1916       case UART_CLOCKSOURCE_SYSCLK:
;;;1917           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
00031c  f7fffffe          BL       HAL_RCC_GetSysClockFreq
000320  6861              LDR      r1,[r4,#4]
000322  eb000051          ADD      r0,r0,r1,LSR #1
000326  fbb0f0f1          UDIV     r0,r0,r1
00032a  b280              UXTH     r0,r0
00032c  6821              LDR      r1,[r4,#0]
00032e  60c8              STR      r0,[r1,#0xc]
;;;1918         break;
000330  e00f              B        |L45.850|
                  |L45.818|
;;;1919       case UART_CLOCKSOURCE_LSE:
;;;1920           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
000332  f44f4100          MOV      r1,#0x8000
000336  6860              LDR      r0,[r4,#4]
000338  eb010050          ADD      r0,r1,r0,LSR #1
00033c  6861              LDR      r1,[r4,#4]
00033e  fbb0f0f1          UDIV     r0,r0,r1
000342  b280              UXTH     r0,r0
000344  6821              LDR      r1,[r4,#0]
000346  60c8              STR      r0,[r1,#0xc]
;;;1921         break;
000348  e003              B        |L45.850|
                  |L45.842|
;;;1922         case UART_CLOCKSOURCE_UNDEFINED:
00034a  bf00              NOP      
                  |L45.844|
;;;1923       default:
;;;1924           ret = HAL_ERROR;
00034c  f04f0901          MOV      r9,#1
;;;1925         break;
000350  bf00              NOP      
                  |L45.850|
000352  bf00              NOP                            ;1909
                  |L45.852|
;;;1926       }
;;;1927     }
;;;1928   
;;;1929     return ret;
000354  4648              MOV      r0,r9
;;;1930   
;;;1931   }
000356  e8bd87f0          POP      {r4-r10,pc}
;;;1932   
                          ENDP

00035a  0000              DCW      0x0000
                  |L45.860|
                          DCD      0xefff69f3
                  |L45.864|
                          DCD      0x40011000
                  |L45.868|
                          DCD      0x40023890
                  |L45.872|
                          DCD      0x40004400
                  |L45.876|
                          DCD      0x40004800
                  |L45.880|
                          DCD      0x40004c00
                  |L45.884|
                          DCD      0x40005000
                  |L45.888|
                          DCD      0x40011400
                  |L45.892|
                          DCD      0x40007800
                  |L45.896|
                          DCD      0x40007c00
                  |L45.900|
                          DCD      0x01e84800
                  |L45.904|
                          DCD      0x00f42400

                          AREA ||i.UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  UART_Transmit_IT PROC
;;;1567     */
;;;1568   static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;1569   {
;;;1570     uint16_t* tmp;
;;;1571   
;;;1572     /* Check that a Tx process is ongoing */
;;;1573     if (huart->gState == HAL_UART_STATE_BUSY_TX)
000002  6ec8              LDR      r0,[r1,#0x6c]
000004  2821              CMP      r0,#0x21
000006  d12d              BNE      |L46.100|
;;;1574     {
;;;1575   
;;;1576       if(huart->TxXferCount == 0U)
000008  f8b10052          LDRH     r0,[r1,#0x52]
00000c  b968              CBNZ     r0,|L46.42|
;;;1577       {
;;;1578         /* Disable the UART Transmit Data Register Empty Interrupt */
;;;1579         CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
00000e  6808              LDR      r0,[r1,#0]
000010  6800              LDR      r0,[r0,#0]
000012  f0200080          BIC      r0,r0,#0x80
000016  680b              LDR      r3,[r1,#0]
000018  6018              STR      r0,[r3,#0]
;;;1580   
;;;1581         /* Enable the UART Transmit Complete Interrupt */
;;;1582         SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
00001a  6808              LDR      r0,[r1,#0]
00001c  6800              LDR      r0,[r0,#0]
00001e  f0400040          ORR      r0,r0,#0x40
000022  680b              LDR      r3,[r1,#0]
000024  6018              STR      r0,[r3,#0]
;;;1583   
;;;1584         return HAL_OK;
000026  2000              MOVS     r0,#0
                  |L46.40|
;;;1585       }
;;;1586       else
;;;1587       {
;;;1588         if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;1589         {
;;;1590           tmp = (uint16_t*) huart->pTxBuffPtr;
;;;1591           huart->Instance->TDR = (*tmp & (uint16_t)0x01FFU);
;;;1592           huart->pTxBuffPtr += 2U;
;;;1593         }
;;;1594         else
;;;1595         {
;;;1596           huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0xFFU);
;;;1597         }
;;;1598   
;;;1599         huart->TxXferCount--;
;;;1600   
;;;1601         return HAL_OK;
;;;1602       }
;;;1603     }
;;;1604     else
;;;1605     {
;;;1606       return HAL_BUSY;
;;;1607     }
;;;1608   }
000028  4770              BX       lr
                  |L46.42|
00002a  6888              LDR      r0,[r1,#8]            ;1588
00002c  f5b05f80          CMP      r0,#0x1000            ;1588
000030  d10b              BNE      |L46.74|
000032  6908              LDR      r0,[r1,#0x10]         ;1588
000034  b948              CBNZ     r0,|L46.74|
000036  6cca              LDR      r2,[r1,#0x4c]         ;1590
000038  8810              LDRH     r0,[r2,#0]            ;1591
00003a  f3c00008          UBFX     r0,r0,#0,#9           ;1591
00003e  680b              LDR      r3,[r1,#0]            ;1591
000040  6298              STR      r0,[r3,#0x28]         ;1591
000042  6cc8              LDR      r0,[r1,#0x4c]         ;1592
000044  1c80              ADDS     r0,r0,#2              ;1592
000046  64c8              STR      r0,[r1,#0x4c]         ;1592
000048  e005              B        |L46.86|
                  |L46.74|
00004a  6ccb              LDR      r3,[r1,#0x4c]         ;1596
00004c  1c58              ADDS     r0,r3,#1              ;1596
00004e  64c8              STR      r0,[r1,#0x4c]         ;1596
000050  7818              LDRB     r0,[r3,#0]            ;1596
000052  680b              LDR      r3,[r1,#0]            ;1596
000054  6298              STR      r0,[r3,#0x28]         ;1596
                  |L46.86|
000056  f8b10052          LDRH     r0,[r1,#0x52]         ;1599
00005a  1e40              SUBS     r0,r0,#1              ;1599
00005c  f8a10052          STRH     r0,[r1,#0x52]         ;1599
000060  2000              MOVS     r0,#0                 ;1601
000062  e7e1              B        |L46.40|
                  |L46.100|
000064  2002              MOVS     r0,#2                 ;1606
000066  e7df              B        |L46.40|
;;;1609   
                          ENDP


                          AREA ||i.UART_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  UART_WaitOnFlagUntilTimeout PROC
;;;1337     */
;;;1338   HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1339   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  9e06              LDR      r6,[sp,#0x18]
;;;1340     /* Wait until flag is set */
;;;1341     while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
00000e  e01e              B        |L47.78|
                  |L47.16|
;;;1342     {
;;;1343       /* Check for the Timeout */
;;;1344       if(Timeout != HAL_MAX_DELAY)
000010  1c70              ADDS     r0,r6,#1
000012  b1e0              CBZ      r0,|L47.78|
;;;1345       {
;;;1346         if((Timeout == 0U)||((HAL_GetTick()-Tickstart) >=  Timeout))
000014  b12e              CBZ      r6,|L47.34|
000016  f7fffffe          BL       HAL_GetTick
00001a  eba00008          SUB      r0,r0,r8
00001e  42b0              CMP      r0,r6
000020  d315              BCC      |L47.78|
                  |L47.34|
;;;1347         {
;;;1348           /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;1349           CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
000022  6820              LDR      r0,[r4,#0]
000024  6800              LDR      r0,[r0,#0]
000026  f42070d0          BIC      r0,r0,#0x1a0
00002a  6821              LDR      r1,[r4,#0]
00002c  6008              STR      r0,[r1,#0]
;;;1350           CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00002e  6820              LDR      r0,[r4,#0]
000030  6880              LDR      r0,[r0,#8]
000032  f0200001          BIC      r0,r0,#1
000036  6821              LDR      r1,[r4,#0]
000038  6088              STR      r0,[r1,#8]
;;;1351   
;;;1352           huart->gState = HAL_UART_STATE_READY;
00003a  2020              MOVS     r0,#0x20
00003c  66e0              STR      r0,[r4,#0x6c]
;;;1353           huart->RxState = HAL_UART_STATE_READY;
00003e  6720              STR      r0,[r4,#0x70]
;;;1354   
;;;1355           /* Process Unlocked */
;;;1356           __HAL_UNLOCK(huart);
000040  bf00              NOP      
000042  2000              MOVS     r0,#0
000044  66a0              STR      r0,[r4,#0x68]
000046  bf00              NOP      
;;;1357           return HAL_TIMEOUT;
000048  2003              MOVS     r0,#3
                  |L47.74|
;;;1358         }
;;;1359       }
;;;1360     }
;;;1361     return HAL_OK;
;;;1362   }
00004a  e8bd81f0          POP      {r4-r8,pc}
                  |L47.78|
00004e  6820              LDR      r0,[r4,#0]            ;1341
000050  69c0              LDR      r0,[r0,#0x1c]         ;1341
000052  4028              ANDS     r0,r0,r5              ;1341
000054  42a8              CMP      r0,r5                 ;1341
000056  d101              BNE      |L47.92|
000058  2001              MOVS     r0,#1                 ;1341
00005a  e000              B        |L47.94|
                  |L47.92|
00005c  2000              MOVS     r0,#0                 ;1341
                  |L47.94|
00005e  42b8              CMP      r0,r7                 ;1341
000060  d0d6              BEQ      |L47.16|
000062  2000              MOVS     r0,#0                 ;1361
000064  e7f1              B        |L47.74|
;;;1363   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f7xx_hal_uart_c_d497114f____REV16|
#line 388 "..\\..\\..\\..\\Library\\STM32F7xx_HAL_Driver\\Core\\cmsis_armcc.h"
|__asm___20_stm32f7xx_hal_uart_c_d497114f____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f7xx_hal_uart_c_d497114f____REVSH|
#line 402
|__asm___20_stm32f7xx_hal_uart_c_d497114f____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f7xx_hal_uart_c_d497114f____RRX|
#line 587
|__asm___20_stm32f7xx_hal_uart_c_d497114f____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
