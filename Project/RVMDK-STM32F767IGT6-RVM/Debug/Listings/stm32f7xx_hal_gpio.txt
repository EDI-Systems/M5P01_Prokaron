; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f7xx_hal_gpio.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f7xx_hal_gpio.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\..\Library\STM32F7xx_HAL_Driver\Core -I..\..\..\..\Library\STM32F7xx_HAL_Driver\Inc -I..\..\..\..\Library\STM32F7xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\32-Bit_MCU\STM32\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f7xx_hal_gpio.crf ..\..\..\..\Library\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_gpio.c]
                          THUMB

                          AREA ||i.HAL_GPIO_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_DeInit PROC
;;;311      */
;;;312    void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
000000  b5f0              PUSH     {r4-r7,lr}
;;;313    {
000002  460c              MOV      r4,r1
;;;314      uint32_t position;
;;;315      uint32_t ioposition = 0x00;
000004  2500              MOVS     r5,#0
;;;316      uint32_t iocurrent = 0x00;
000006  2200              MOVS     r2,#0
;;;317      uint32_t tmp = 0x00;
000008  2300              MOVS     r3,#0
;;;318    
;;;319      /* Check the parameters */
;;;320      assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
;;;321      
;;;322      /* Configure the port pins */
;;;323      for(position = 0; position < GPIO_NUMBER; position++)
00000a  2100              MOVS     r1,#0
00000c  e09c              B        |L1.328|
                  |L1.14|
;;;324      {
;;;325        /* Get the IO position */
;;;326        ioposition = ((uint32_t)0x01) << position;
00000e  2601              MOVS     r6,#1
000010  fa06f501          LSL      r5,r6,r1
;;;327        /* Get the current IO position */
;;;328        iocurrent = (GPIO_Pin) & ioposition;
000014  ea040205          AND      r2,r4,r5
;;;329    
;;;330        if(iocurrent == ioposition)
000018  42aa              CMP      r2,r5
00001a  d17d              BNE      |L1.280|
;;;331        {
;;;332          /*------------------------- GPIO Mode Configuration --------------------*/
;;;333          /* Configure IO Direction in Input Floating Mode */
;;;334          GPIOx->MODER &= ~(GPIO_MODER_MODER0 << (position * 2));
00001c  6806              LDR      r6,[r0,#0]
00001e  ea4f0c41          LSL      r12,r1,#1
000022  2703              MOVS     r7,#3
000024  fa07f70c          LSL      r7,r7,r12
000028  43be              BICS     r6,r6,r7
00002a  6006              STR      r6,[r0,#0]
;;;335    
;;;336          /* Configure the default Alternate Function in current IO */
;;;337          GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
00002c  08cf              LSRS     r7,r1,#3
00002e  f1000620          ADD      r6,r0,#0x20
000032  f8566027          LDR      r6,[r6,r7,LSL #2]
000036  074f              LSLS     r7,r1,#29
000038  ea4f6cd7          LSR      r12,r7,#27
00003c  270f              MOVS     r7,#0xf
00003e  fa07f70c          LSL      r7,r7,r12
000042  43be              BICS     r6,r6,r7
000044  ea4f0cd1          LSR      r12,r1,#3
000048  f1000720          ADD      r7,r0,#0x20
00004c  f847602c          STR      r6,[r7,r12,LSL #2]
;;;338    
;;;339          /* Configure the default value for IO Speed */
;;;340          GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
000050  6886              LDR      r6,[r0,#8]
000052  ea4f0c41          LSL      r12,r1,#1
000056  2703              MOVS     r7,#3
000058  fa07f70c          LSL      r7,r7,r12
00005c  43be              BICS     r6,r6,r7
00005e  6086              STR      r6,[r0,#8]
;;;341    
;;;342          /* Configure the default value IO Output Type */
;;;343          GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;
000060  6847              LDR      r7,[r0,#4]
000062  2601              MOVS     r6,#1
000064  408e              LSLS     r6,r6,r1
000066  43b7              BICS     r7,r7,r6
000068  6047              STR      r7,[r0,#4]
;;;344    
;;;345          /* Deactivate the Pull-up and Pull-down resistor for the current IO */
;;;346          GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
00006a  68c6              LDR      r6,[r0,#0xc]
00006c  ea4f0c41          LSL      r12,r1,#1
000070  2703              MOVS     r7,#3
000072  fa07f70c          LSL      r7,r7,r12
000076  43be              BICS     r6,r6,r7
000078  60c6              STR      r6,[r0,#0xc]
;;;347    
;;;348          /*------------------------- EXTI Mode Configuration --------------------*/
;;;349          tmp = SYSCFG->EXTICR[position >> 2];
00007a  4e35              LDR      r6,|L1.336|
00007c  088f              LSRS     r7,r1,#2
00007e  f8563027          LDR      r3,[r6,r7,LSL #2]
;;;350          tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
000082  078e              LSLS     r6,r1,#30
000084  0f37              LSRS     r7,r6,#28
000086  260f              MOVS     r6,#0xf
000088  40be              LSLS     r6,r6,r7
00008a  4033              ANDS     r3,r3,r6
;;;351          if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03))))
00008c  4e31              LDR      r6,|L1.340|
00008e  42b0              CMP      r0,r6
000090  d101              BNE      |L1.150|
000092  2600              MOVS     r6,#0
000094  e02d              B        |L1.242|
                  |L1.150|
000096  4e30              LDR      r6,|L1.344|
000098  42b0              CMP      r0,r6
00009a  d101              BNE      |L1.160|
00009c  2601              MOVS     r6,#1
00009e  e028              B        |L1.242|
                  |L1.160|
0000a0  4e2e              LDR      r6,|L1.348|
0000a2  42b0              CMP      r0,r6
0000a4  d101              BNE      |L1.170|
0000a6  2602              MOVS     r6,#2
0000a8  e023              B        |L1.242|
                  |L1.170|
0000aa  4e2d              LDR      r6,|L1.352|
0000ac  42b0              CMP      r0,r6
0000ae  d101              BNE      |L1.180|
0000b0  2603              MOVS     r6,#3
0000b2  e01e              B        |L1.242|
                  |L1.180|
0000b4  4e2b              LDR      r6,|L1.356|
0000b6  42b0              CMP      r0,r6
0000b8  d101              BNE      |L1.190|
0000ba  2604              MOVS     r6,#4
0000bc  e019              B        |L1.242|
                  |L1.190|
0000be  4e2a              LDR      r6,|L1.360|
0000c0  42b0              CMP      r0,r6
0000c2  d101              BNE      |L1.200|
0000c4  2605              MOVS     r6,#5
0000c6  e014              B        |L1.242|
                  |L1.200|
0000c8  4e28              LDR      r6,|L1.364|
0000ca  42b0              CMP      r0,r6
0000cc  d101              BNE      |L1.210|
0000ce  2606              MOVS     r6,#6
0000d0  e00f              B        |L1.242|
                  |L1.210|
0000d2  4e27              LDR      r6,|L1.368|
0000d4  42b0              CMP      r0,r6
0000d6  d101              BNE      |L1.220|
0000d8  2607              MOVS     r6,#7
0000da  e00a              B        |L1.242|
                  |L1.220|
0000dc  4e25              LDR      r6,|L1.372|
0000de  42b0              CMP      r0,r6
0000e0  d101              BNE      |L1.230|
0000e2  2608              MOVS     r6,#8
0000e4  e005              B        |L1.242|
                  |L1.230|
0000e6  4e24              LDR      r6,|L1.376|
0000e8  42b0              CMP      r0,r6
0000ea  d101              BNE      |L1.240|
0000ec  2609              MOVS     r6,#9
0000ee  e000              B        |L1.242|
                  |L1.240|
0000f0  260a              MOVS     r6,#0xa
                  |L1.242|
0000f2  078f              LSLS     r7,r1,#30
0000f4  0f3f              LSRS     r7,r7,#28
0000f6  40be              LSLS     r6,r6,r7
0000f8  429e              CMP      r6,r3
0000fa  d124              BNE      |L1.326|
;;;352          {
;;;353            /* Configure the External Interrupt or event for the current IO */
;;;354            tmp = ((uint32_t)0x0F) << (4 * (position & 0x03));
0000fc  078e              LSLS     r6,r1,#30
0000fe  0f37              LSRS     r7,r6,#28
000100  260f              MOVS     r6,#0xf
000102  fa06f307          LSL      r3,r6,r7
;;;355            SYSCFG->EXTICR[position >> 2] &= ~tmp;
000106  4e12              LDR      r6,|L1.336|
000108  088f              LSRS     r7,r1,#2
00010a  f8566027          LDR      r6,[r6,r7,LSL #2]
00010e  439e              BICS     r6,r6,r3
000110  4f0f              LDR      r7,|L1.336|
000112  ea4f0c91          LSR      r12,r1,#2
000116  e000              B        |L1.282|
                  |L1.280|
000118  e015              B        |L1.326|
                  |L1.282|
00011a  f847602c          STR      r6,[r7,r12,LSL #2]
;;;356    
;;;357            /* Clear EXTI line configuration */
;;;358            EXTI->IMR &= ~((uint32_t)iocurrent);
00011e  4e17              LDR      r6,|L1.380|
000120  6836              LDR      r6,[r6,#0]
000122  4396              BICS     r6,r6,r2
000124  4f15              LDR      r7,|L1.380|
000126  603e              STR      r6,[r7,#0]
;;;359            EXTI->EMR &= ~((uint32_t)iocurrent);
000128  1d3e              ADDS     r6,r7,#4
00012a  6836              LDR      r6,[r6,#0]
00012c  4396              BICS     r6,r6,r2
00012e  1d3f              ADDS     r7,r7,#4
000130  603e              STR      r6,[r7,#0]
;;;360    
;;;361            /* Clear Rising Falling edge configuration */
;;;362            EXTI->RTSR &= ~((uint32_t)iocurrent);
000132  1d3e              ADDS     r6,r7,#4
000134  6836              LDR      r6,[r6,#0]
000136  4396              BICS     r6,r6,r2
000138  1d3f              ADDS     r7,r7,#4
00013a  603e              STR      r6,[r7,#0]
;;;363            EXTI->FTSR &= ~((uint32_t)iocurrent);
00013c  1d3e              ADDS     r6,r7,#4
00013e  6836              LDR      r6,[r6,#0]
000140  4396              BICS     r6,r6,r2
000142  1d3f              ADDS     r7,r7,#4
000144  603e              STR      r6,[r7,#0]
                  |L1.326|
000146  1c49              ADDS     r1,r1,#1              ;323
                  |L1.328|
000148  2910              CMP      r1,#0x10              ;323
00014a  f4ffaf60          BCC      |L1.14|
;;;364    	  }
;;;365        }
;;;366      }
;;;367    }
00014e  bdf0              POP      {r4-r7,pc}
;;;368    
                          ENDP

                  |L1.336|
                          DCD      0x40013808
                  |L1.340|
                          DCD      0x40020000
                  |L1.344|
                          DCD      0x40020400
                  |L1.348|
                          DCD      0x40020800
                  |L1.352|
                          DCD      0x40020c00
                  |L1.356|
                          DCD      0x40021000
                  |L1.360|
                          DCD      0x40021400
                  |L1.364|
                          DCD      0x40021800
                  |L1.368|
                          DCD      0x40021c00
                  |L1.372|
                          DCD      0x40022000
                  |L1.376|
                          DCD      0x40022400
                  |L1.380|
                          DCD      0x40013c00

                          AREA ||i.HAL_GPIO_EXTI_Callback||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_EXTI_Callback PROC
;;;514      */
;;;515    __weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
000000  4770              BX       lr
;;;516    {
;;;517      /* Prevent unused argument(s) compilation warning */
;;;518      UNUSED(GPIO_Pin);
;;;519      
;;;520      /* NOTE: This function Should not be modified, when the callback is needed,
;;;521               the HAL_GPIO_EXTI_Callback could be implemented in the user file
;;;522       */
;;;523    }
;;;524    
                          ENDP


                          AREA ||i.HAL_GPIO_EXTI_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_EXTI_IRQHandler PROC
;;;499      */
;;;500    void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
000000  b510              PUSH     {r4,lr}
;;;501    {
000002  4604              MOV      r4,r0
;;;502      /* EXTI line interrupt detected */
;;;503      if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
000004  4804              LDR      r0,|L3.24|
000006  6800              LDR      r0,[r0,#0]
000008  4020              ANDS     r0,r0,r4
00000a  b120              CBZ      r0,|L3.22|
;;;504      {
;;;505        __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
00000c  4802              LDR      r0,|L3.24|
00000e  6004              STR      r4,[r0,#0]
;;;506        HAL_GPIO_EXTI_Callback(GPIO_Pin);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       HAL_GPIO_EXTI_Callback
                  |L3.22|
;;;507      }
;;;508    }
000016  bd10              POP      {r4,pc}
;;;509    
                          ENDP

                  |L3.24|
                          DCD      0x40013c14

                          AREA ||i.HAL_GPIO_Init||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_Init PROC
;;;186      */
;;;187    void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
000000  b5f8              PUSH     {r3-r7,lr}
;;;188    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;189      uint32_t position = 0x00;
000006  2100              MOVS     r1,#0
;;;190      uint32_t ioposition = 0x00;
000008  2500              MOVS     r5,#0
;;;191      uint32_t iocurrent = 0x00;
00000a  2400              MOVS     r4,#0
;;;192      uint32_t temp = 0x00;
00000c  2000              MOVS     r0,#0
;;;193    
;;;194      /* Check the parameters */
;;;195      assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
;;;196      assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
;;;197      assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
;;;198      assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
;;;199    
;;;200      /* Configure the port pins */
;;;201      for(position = 0; position < GPIO_NUMBER; position++)
00000e  bf00              NOP      
000010  e0e4              B        |L4.476|
                  |L4.18|
;;;202      {
;;;203        /* Get the IO position */
;;;204        ioposition = ((uint32_t)0x01) << position;
000012  2601              MOVS     r6,#1
000014  fa06f501          LSL      r5,r6,r1
;;;205        /* Get the current IO position */
;;;206        iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
000018  681e              LDR      r6,[r3,#0]
00001a  ea060405          AND      r4,r6,r5
;;;207    
;;;208        if(iocurrent == ioposition)
00001e  42ac              CMP      r4,r5
                  |L4.32|
000020  d171              BNE      |L4.262|
;;;209        {
;;;210          /*--------------------- GPIO Mode Configuration ------------------------*/
;;;211          /* In case of Alternate function mode selection */
;;;212          if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
000022  685e              LDR      r6,[r3,#4]
000024  2e02              CMP      r6,#2
000026  d002              BEQ      |L4.46|
000028  685e              LDR      r6,[r3,#4]
00002a  2e12              CMP      r6,#0x12
00002c  d113              BNE      |L4.86|
                  |L4.46|
;;;213          {
;;;214            /* Check the Alternate function parameter */
;;;215            assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
;;;216            
;;;217            /* Configure Alternate function mapped with the current IO */
;;;218            temp = GPIOx->AFR[position >> 3];
00002e  08cf              LSRS     r7,r1,#3
000030  f1020620          ADD      r6,r2,#0x20
000034  f8560027          LDR      r0,[r6,r7,LSL #2]
;;;219            temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
000038  074e              LSLS     r6,r1,#29
00003a  0ef7              LSRS     r7,r6,#27
00003c  260f              MOVS     r6,#0xf
00003e  40be              LSLS     r6,r6,r7
000040  43b0              BICS     r0,r0,r6
;;;220            temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
000042  074f              LSLS     r7,r1,#29
000044  0eff              LSRS     r7,r7,#27
000046  691e              LDR      r6,[r3,#0x10]
000048  40be              LSLS     r6,r6,r7
00004a  4330              ORRS     r0,r0,r6
;;;221            GPIOx->AFR[position >> 3] = temp;
00004c  08cf              LSRS     r7,r1,#3
00004e  f1020620          ADD      r6,r2,#0x20
000052  f8460027          STR      r0,[r6,r7,LSL #2]
                  |L4.86|
;;;222          }
;;;223    
;;;224          /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
;;;225          temp = GPIOx->MODER;
000056  6810              LDR      r0,[r2,#0]
;;;226          temp &= ~(GPIO_MODER_MODER0 << (position * 2));
000058  004f              LSLS     r7,r1,#1
00005a  2603              MOVS     r6,#3
00005c  40be              LSLS     r6,r6,r7
00005e  43b0              BICS     r0,r0,r6
;;;227          temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
000060  791e              LDRB     r6,[r3,#4]
000062  f0060603          AND      r6,r6,#3
000066  004f              LSLS     r7,r1,#1
000068  40be              LSLS     r6,r6,r7
00006a  4330              ORRS     r0,r0,r6
;;;228          GPIOx->MODER = temp;
00006c  6010              STR      r0,[r2,#0]
;;;229    
;;;230          /* In case of Output or Alternate function mode selection */
;;;231          if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
00006e  685e              LDR      r6,[r3,#4]
000070  2e01              CMP      r6,#1
000072  d008              BEQ      |L4.134|
000074  685e              LDR      r6,[r3,#4]
000076  2e02              CMP      r6,#2
000078  d005              BEQ      |L4.134|
;;;232             (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
00007a  685e              LDR      r6,[r3,#4]
00007c  2e11              CMP      r6,#0x11
00007e  d002              BEQ      |L4.134|
000080  685e              LDR      r6,[r3,#4]
000082  2e12              CMP      r6,#0x12
000084  d113              BNE      |L4.174|
                  |L4.134|
;;;233          {
;;;234            /* Check the Speed parameter */
;;;235            assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
;;;236            /* Configure the IO Speed */
;;;237            temp = GPIOx->OSPEEDR; 
000086  6890              LDR      r0,[r2,#8]
;;;238            temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
000088  004f              LSLS     r7,r1,#1
00008a  2603              MOVS     r6,#3
00008c  40be              LSLS     r6,r6,r7
00008e  43b0              BICS     r0,r0,r6
;;;239            temp |= (GPIO_Init->Speed << (position * 2));
000090  004f              LSLS     r7,r1,#1
000092  68de              LDR      r6,[r3,#0xc]
000094  40be              LSLS     r6,r6,r7
000096  4330              ORRS     r0,r0,r6
;;;240            GPIOx->OSPEEDR = temp;
000098  6090              STR      r0,[r2,#8]
;;;241    
;;;242            /* Configure the IO Output Type */
;;;243            temp = GPIOx->OTYPER;
00009a  6850              LDR      r0,[r2,#4]
;;;244            temp &= ~(GPIO_OTYPER_OT_0 << position) ;
00009c  2601              MOVS     r6,#1
00009e  408e              LSLS     r6,r6,r1
0000a0  43b0              BICS     r0,r0,r6
;;;245            temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
0000a2  791e              LDRB     r6,[r3,#4]
0000a4  f3c61600          UBFX     r6,r6,#4,#1
0000a8  408e              LSLS     r6,r6,r1
0000aa  4330              ORRS     r0,r0,r6
;;;246            GPIOx->OTYPER = temp;
0000ac  6050              STR      r0,[r2,#4]
                  |L4.174|
;;;247          }
;;;248    
;;;249          /* Activate the Pull-up or Pull down resistor for the current IO */
;;;250          temp = GPIOx->PUPDR;
0000ae  68d0              LDR      r0,[r2,#0xc]
;;;251          temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
0000b0  004f              LSLS     r7,r1,#1
0000b2  2603              MOVS     r6,#3
0000b4  40be              LSLS     r6,r6,r7
0000b6  43b0              BICS     r0,r0,r6
;;;252          temp |= ((GPIO_Init->Pull) << (position * 2));
0000b8  004f              LSLS     r7,r1,#1
0000ba  689e              LDR      r6,[r3,#8]
0000bc  40be              LSLS     r6,r6,r7
0000be  4330              ORRS     r0,r0,r6
;;;253          GPIOx->PUPDR = temp;
0000c0  60d0              STR      r0,[r2,#0xc]
;;;254    
;;;255          /*--------------------- EXTI Mode Configuration ------------------------*/
;;;256          /* Configure the External Interrupt or event for the current IO */
;;;257          if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
0000c2  685e              LDR      r6,[r3,#4]
0000c4  f0065680          AND      r6,r6,#0x10000000
0000c8  f1b65f80          CMP      r6,#0x10000000
0000cc  d1a8              BNE      |L4.32|
;;;258          {
;;;259            /* Enable SYSCFG Clock */
;;;260            __HAL_RCC_SYSCFG_CLK_ENABLE();
0000ce  bf00              NOP      
0000d0  4e44              LDR      r6,|L4.484|
0000d2  6836              LDR      r6,[r6,#0]
0000d4  f4464680          ORR      r6,r6,#0x4000
0000d8  4f42              LDR      r7,|L4.484|
0000da  603e              STR      r6,[r7,#0]
0000dc  463e              MOV      r6,r7
0000de  6836              LDR      r6,[r6,#0]
0000e0  f4064680          AND      r6,r6,#0x4000
0000e4  9600              STR      r6,[sp,#0]
0000e6  bf00              NOP      
0000e8  bf00              NOP      
;;;261    
;;;262            temp = SYSCFG->EXTICR[position >> 2];
0000ea  4e3f              LDR      r6,|L4.488|
0000ec  088f              LSRS     r7,r1,#2
0000ee  f8560027          LDR      r0,[r6,r7,LSL #2]
;;;263            temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
0000f2  078e              LSLS     r6,r1,#30
0000f4  0f37              LSRS     r7,r6,#28
0000f6  260f              MOVS     r6,#0xf
0000f8  40be              LSLS     r6,r6,r7
0000fa  43b0              BICS     r0,r0,r6
;;;264            temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
0000fc  4e3b              LDR      r6,|L4.492|
0000fe  42b2              CMP      r2,r6
000100  d102              BNE      |L4.264|
000102  2600              MOVS     r6,#0
000104  e02e              B        |L4.356|
                  |L4.262|
000106  e068              B        |L4.474|
                  |L4.264|
000108  4e39              LDR      r6,|L4.496|
00010a  42b2              CMP      r2,r6
00010c  d101              BNE      |L4.274|
00010e  2601              MOVS     r6,#1
000110  e028              B        |L4.356|
                  |L4.274|
000112  4e38              LDR      r6,|L4.500|
000114  42b2              CMP      r2,r6
000116  d101              BNE      |L4.284|
000118  2602              MOVS     r6,#2
00011a  e023              B        |L4.356|
                  |L4.284|
00011c  4e36              LDR      r6,|L4.504|
00011e  42b2              CMP      r2,r6
000120  d101              BNE      |L4.294|
000122  2603              MOVS     r6,#3
000124  e01e              B        |L4.356|
                  |L4.294|
000126  4e35              LDR      r6,|L4.508|
000128  42b2              CMP      r2,r6
00012a  d101              BNE      |L4.304|
00012c  2604              MOVS     r6,#4
00012e  e019              B        |L4.356|
                  |L4.304|
000130  4e33              LDR      r6,|L4.512|
000132  42b2              CMP      r2,r6
000134  d101              BNE      |L4.314|
000136  2605              MOVS     r6,#5
000138  e014              B        |L4.356|
                  |L4.314|
00013a  4e32              LDR      r6,|L4.516|
00013c  42b2              CMP      r2,r6
00013e  d101              BNE      |L4.324|
000140  2606              MOVS     r6,#6
000142  e00f              B        |L4.356|
                  |L4.324|
000144  4e30              LDR      r6,|L4.520|
000146  42b2              CMP      r2,r6
000148  d101              BNE      |L4.334|
00014a  2607              MOVS     r6,#7
00014c  e00a              B        |L4.356|
                  |L4.334|
00014e  4e2f              LDR      r6,|L4.524|
000150  42b2              CMP      r2,r6
000152  d101              BNE      |L4.344|
000154  2608              MOVS     r6,#8
000156  e005              B        |L4.356|
                  |L4.344|
000158  4e2d              LDR      r6,|L4.528|
00015a  42b2              CMP      r2,r6
00015c  d101              BNE      |L4.354|
00015e  2609              MOVS     r6,#9
000160  e000              B        |L4.356|
                  |L4.354|
000162  260a              MOVS     r6,#0xa
                  |L4.356|
000164  078f              LSLS     r7,r1,#30
000166  0f3f              LSRS     r7,r7,#28
000168  40be              LSLS     r6,r6,r7
00016a  4330              ORRS     r0,r0,r6
;;;265            SYSCFG->EXTICR[position >> 2] = temp;
00016c  4e1e              LDR      r6,|L4.488|
00016e  088f              LSRS     r7,r1,#2
000170  f8460027          STR      r0,[r6,r7,LSL #2]
;;;266    
;;;267            /* Clear EXTI line configuration */
;;;268            temp = EXTI->IMR;
000174  4e27              LDR      r6,|L4.532|
000176  6830              LDR      r0,[r6,#0]
;;;269            temp &= ~((uint32_t)iocurrent);
000178  43a0              BICS     r0,r0,r4
;;;270            if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
00017a  685e              LDR      r6,[r3,#4]
00017c  f4063680          AND      r6,r6,#0x10000
000180  f5b63f80          CMP      r6,#0x10000
000184  d100              BNE      |L4.392|
;;;271            {
;;;272              temp |= iocurrent;
000186  4320              ORRS     r0,r0,r4
                  |L4.392|
;;;273            }
;;;274            EXTI->IMR = temp;
000188  4e22              LDR      r6,|L4.532|
00018a  6030              STR      r0,[r6,#0]
;;;275    
;;;276            temp = EXTI->EMR;
00018c  1d36              ADDS     r6,r6,#4
00018e  6830              LDR      r0,[r6,#0]
;;;277            temp &= ~((uint32_t)iocurrent);
000190  43a0              BICS     r0,r0,r4
;;;278            if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
000192  685e              LDR      r6,[r3,#4]
000194  f4063600          AND      r6,r6,#0x20000
000198  f5b63f00          CMP      r6,#0x20000
00019c  d100              BNE      |L4.416|
;;;279            {
;;;280              temp |= iocurrent;
00019e  4320              ORRS     r0,r0,r4
                  |L4.416|
;;;281            }
;;;282            EXTI->EMR = temp;
0001a0  4e1c              LDR      r6,|L4.532|
0001a2  1d36              ADDS     r6,r6,#4
0001a4  6030              STR      r0,[r6,#0]
;;;283    
;;;284            /* Clear Rising Falling edge configuration */
;;;285            temp = EXTI->RTSR;
0001a6  1d36              ADDS     r6,r6,#4
0001a8  6830              LDR      r0,[r6,#0]
;;;286            temp &= ~((uint32_t)iocurrent);
0001aa  43a0              BICS     r0,r0,r4
;;;287            if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
0001ac  685e              LDR      r6,[r3,#4]
0001ae  f4061680          AND      r6,r6,#0x100000
0001b2  f5b61f80          CMP      r6,#0x100000
0001b6  d100              BNE      |L4.442|
;;;288            {
;;;289              temp |= iocurrent;
0001b8  4320              ORRS     r0,r0,r4
                  |L4.442|
;;;290            }
;;;291            EXTI->RTSR = temp;
0001ba  4e16              LDR      r6,|L4.532|
0001bc  3608              ADDS     r6,r6,#8
0001be  6030              STR      r0,[r6,#0]
;;;292    
;;;293            temp = EXTI->FTSR;
0001c0  1d36              ADDS     r6,r6,#4
0001c2  6830              LDR      r0,[r6,#0]
;;;294            temp &= ~((uint32_t)iocurrent);
0001c4  43a0              BICS     r0,r0,r4
;;;295            if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
0001c6  685e              LDR      r6,[r3,#4]
0001c8  f4061600          AND      r6,r6,#0x200000
0001cc  f5b61f00          CMP      r6,#0x200000
0001d0  d100              BNE      |L4.468|
;;;296            {
;;;297              temp |= iocurrent;
0001d2  4320              ORRS     r0,r0,r4
                  |L4.468|
;;;298            }
;;;299            EXTI->FTSR = temp;
0001d4  4e0f              LDR      r6,|L4.532|
0001d6  360c              ADDS     r6,r6,#0xc
0001d8  6030              STR      r0,[r6,#0]
                  |L4.474|
0001da  1c49              ADDS     r1,r1,#1              ;201
                  |L4.476|
0001dc  2910              CMP      r1,#0x10              ;201
0001de  f4ffaf18          BCC      |L4.18|
;;;300          }
;;;301        }
;;;302      }
;;;303    }
0001e2  bdf8              POP      {r3-r7,pc}
;;;304    
                          ENDP

                  |L4.484|
                          DCD      0x40023844
                  |L4.488|
                          DCD      0x40013808
                  |L4.492|
                          DCD      0x40020000
                  |L4.496|
                          DCD      0x40020400
                  |L4.500|
                          DCD      0x40020800
                  |L4.504|
                          DCD      0x40020c00
                  |L4.508|
                          DCD      0x40021000
                  |L4.512|
                          DCD      0x40021400
                  |L4.516|
                          DCD      0x40021800
                  |L4.520|
                          DCD      0x40021c00
                  |L4.524|
                          DCD      0x40022000
                  |L4.528|
                          DCD      0x40022400
                  |L4.532|
                          DCD      0x40013c00

                          AREA ||i.HAL_GPIO_LockPin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_LockPin PROC
;;;466      */
;;;467    HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  b508              PUSH     {r3,lr}
;;;468    {
000002  4602              MOV      r2,r0
;;;469      __IO uint32_t tmp = GPIO_LCKR_LCKK;
000004  f44f3080          MOV      r0,#0x10000
000008  9000              STR      r0,[sp,#0]
;;;470    
;;;471      /* Check the parameters */
;;;472      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;473    
;;;474      /* Apply lock key write sequence */
;;;475      tmp |= GPIO_Pin;
00000a  9800              LDR      r0,[sp,#0]
00000c  4308              ORRS     r0,r0,r1
00000e  9000              STR      r0,[sp,#0]
;;;476      /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
;;;477      GPIOx->LCKR = tmp;
000010  9800              LDR      r0,[sp,#0]
000012  61d0              STR      r0,[r2,#0x1c]
;;;478      /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
;;;479      GPIOx->LCKR = GPIO_Pin;
000014  61d1              STR      r1,[r2,#0x1c]
;;;480      /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
;;;481      GPIOx->LCKR = tmp;
000016  9800              LDR      r0,[sp,#0]
000018  61d0              STR      r0,[r2,#0x1c]
;;;482      /* Read LCKK bit*/
;;;483      tmp = GPIOx->LCKR;
00001a  69d0              LDR      r0,[r2,#0x1c]
00001c  9000              STR      r0,[sp,#0]
;;;484    
;;;485     if((GPIOx->LCKR & GPIO_LCKR_LCKK) != RESET)
00001e  69d0              LDR      r0,[r2,#0x1c]
000020  f4003080          AND      r0,r0,#0x10000
000024  b108              CBZ      r0,|L5.42|
;;;486      {
;;;487        return HAL_OK;
000026  2000              MOVS     r0,#0
                  |L5.40|
;;;488      }
;;;489      else
;;;490      {
;;;491        return HAL_ERROR;
;;;492      }
;;;493    }
000028  bd08              POP      {r3,pc}
                  |L5.42|
00002a  2001              MOVS     r0,#1                 ;491
00002c  e7fc              B        |L5.40|
;;;494    
                          ENDP


                          AREA ||i.HAL_GPIO_ReadPin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_ReadPin PROC
;;;391      */
;;;392    GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  4602              MOV      r2,r0
;;;393    {
;;;394      GPIO_PinState bitstatus;
;;;395    
;;;396      /* Check the parameters */
;;;397      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;398    
;;;399      if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
000002  6913              LDR      r3,[r2,#0x10]
000004  400b              ANDS     r3,r3,r1
000006  b10b              CBZ      r3,|L6.12|
;;;400      {
;;;401        bitstatus = GPIO_PIN_SET;
000008  2001              MOVS     r0,#1
00000a  e000              B        |L6.14|
                  |L6.12|
;;;402      }
;;;403      else
;;;404      {
;;;405        bitstatus = GPIO_PIN_RESET;
00000c  2000              MOVS     r0,#0
                  |L6.14|
;;;406      }
;;;407      return bitstatus;
;;;408    }
00000e  4770              BX       lr
;;;409    
                          ENDP


                          AREA ||i.HAL_GPIO_TogglePin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_TogglePin PROC
;;;447      */
;;;448    void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  6942              LDR      r2,[r0,#0x14]
;;;449    {
;;;450      /* Check the parameters */
;;;451      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;452    
;;;453      GPIOx->ODR ^= GPIO_Pin;
000002  404a              EORS     r2,r2,r1
000004  6142              STR      r2,[r0,#0x14]
;;;454    }
000006  4770              BX       lr
;;;455    
                          ENDP


                          AREA ||i.HAL_GPIO_WritePin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_WritePin PROC
;;;425      */
;;;426    void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
000000  b10a              CBZ      r2,|L8.6|
;;;427    {
;;;428      /* Check the parameters */
;;;429      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;430      assert_param(IS_GPIO_PIN_ACTION(PinState));
;;;431    
;;;432      if(PinState != GPIO_PIN_RESET)
;;;433      {
;;;434        GPIOx->BSRR = GPIO_Pin;
000002  6181              STR      r1,[r0,#0x18]
000004  e001              B        |L8.10|
                  |L8.6|
;;;435      }
;;;436      else
;;;437      {
;;;438        GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
000006  040b              LSLS     r3,r1,#16
000008  6183              STR      r3,[r0,#0x18]
                  |L8.10|
;;;439      }
;;;440    }
00000a  4770              BX       lr
;;;441    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_gpio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f7xx_hal_gpio_c_ea787061____REV16|
#line 388 "..\\..\\..\\..\\Library\\STM32F7xx_HAL_Driver\\Core\\cmsis_armcc.h"
|__asm___20_stm32f7xx_hal_gpio_c_ea787061____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f7xx_hal_gpio_c_ea787061____REVSH|
#line 402
|__asm___20_stm32f7xx_hal_gpio_c_ea787061____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f7xx_hal_gpio_c_ea787061____RRX|
#line 587
|__asm___20_stm32f7xx_hal_gpio_c_ea787061____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
