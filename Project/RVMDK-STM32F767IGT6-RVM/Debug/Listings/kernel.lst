L 1 "..\..\MProkaron\Kernel\kernel.c"
N/******************************************************************************
NFilename    : kernel.c
NAuthor      : pry
NDate        : 04/02/2018
NLicence     : LGPL v3+; see COPYING for details.
NDescription : The RMP RTOS single-file kernel.
N              This is a single-process kernel that does nothing but simple thread
N              context switches. This operating system's kernel object allocation
N              policy is totally exported, so the user assume full control over this.
N******************************************************************************/
N
N/* Includes ******************************************************************/
N#define __HDR_DEFS__
N#include "Platform/RMP_platform.h"
L 1 "..\..\MProkaron\Include\Platform/RMP_platform.h" 1
N/******************************************************************************
NFilename    : RMP_platform.h
NAuthor      : pry 
NDate        : 22/07/2017
NLicence     : LGPL v3+; see COPYING for details.
NDescription : The platform specific types for RMP.
N******************************************************************************/
N
N/* Platform Includes *********************************************************/
N#include "Platform/CortexM_RVM/platform_cmx_RVM.h"
L 1 "..\..\MProkaron\Include\Platform/CortexM_RVM/platform_cmx_RVM.h" 1
N/******************************************************************************
NFilename    : platform_cmx_RVM.h
NAuthor      : pry
NDate        : 01/04/2017
NLicence     : LGPL v3+; see COPYING for details.
NDescription : The header of platform-specific part of RMP for RVM.
N******************************************************************************/
N
N/* Defines *******************************************************************/
N#ifdef __HDR_DEFS__
N#ifndef __PLATFORM_CMX_RVM_H_DEFS__
N#define __PLATFORM_CMX_RVM_H_DEFS__
N/*****************************************************************************/
N/* Basic Types ***************************************************************/
N#if(DEFINE_BASIC_TYPES==TRUE)
N
N#ifndef __S32__
N#define __S32__
Ntypedef signed int  s32;
N#endif
N
N#ifndef __S16__
N#define __S16__
Ntypedef signed short s16;
N#endif
N
N#ifndef __S8__
N#define __S8__
Ntypedef signed char  s8;
N#endif
N
N#ifndef __U32__
N#define __U32__
Ntypedef unsigned int  u32;
N#endif
N
N#ifndef __U16__
N#define __U16__
Ntypedef unsigned short u16;
N#endif
N
N#ifndef __U8__
N#define __U8__
Ntypedef unsigned char  u8;
N#endif
N
N#endif
N/* End Basic Types ***********************************************************/
N
N/* Begin Extended Types ******************************************************/
N#ifndef __TID_T__
N#define __TID_T__
N/* The typedef for the Thread ID */
Ntypedef s32 tid_t;
N#endif
N
N#ifndef __PTR_T__
N#define __PTR_T__
N/* The typedef for the pointers - This is the raw style. Pointers must be unsigned */
Ntypedef u32 ptr_t;
N#endif
N
N#ifndef __CNT_T__
N#define __CNT_T__
N/* The typedef for the count variables */
Ntypedef s32 cnt_t;
N#endif
N
N#ifndef __CID_T__
N#define __CID_T__
N/* The typedef for capability ID */
Ntypedef s32 cid_t;
N#endif
N
N#ifndef __RET_T__
N#define __RET_T__
N/* The type for process return value */
Ntypedef s32 ret_t;
N#endif
N/* End Extended Types ********************************************************/
N
N/* System macros *************************************************************/
N/* Compiler "extern" keyword setting */
N#define EXTERN                   extern
N/* The order of bits in one CPU machine word */
N#define RMP_WORD_ORDER           5
N/* The maximum length of char printing - no need to change this in most cases */
N#define RMP_KERNEL_DEBUG_MAX_STR 128
N/* The offset of the stack when initializing */
N#define RMP_INIT_STACK           RMP_INIT_STACK_TAIL(17)
N
N/* The CPU and application specific macros are here */
N#include "platform_cmx_RVM_conf.h"
L 1 "..\..\MProkaron\Include\Platform/CortexM_RVM/platform_cmx_RVM_conf.h" 1
N/******************************************************************************
NFilename   : platform_cmx_conf.h
NAuthor     : pry
NDate       : 24/06/2017
NLicence    : LGPL v3+; see COPYING for details.
NDescription: The configuration file for Cortex-M HAL.
N******************************************************************************/
N
N/* Config Includes ***********************************************************/
N#include "Platform/CortexM_RVM/Chips/STM32F767IG/platform_STM32F767IG_RVM.h"
L 1 "..\..\MProkaron\Include\Platform/CortexM_RVM/Chips/STM32F767IG/platform_STM32F767IG_RVM.h" 1
N/******************************************************************************
NFilename   : platform_STM32F767IG_RVM.h
NAuthor     : pry
NDate       : 24/06/2017
NLicence    : LGPL v3+; see COPYING for details.
NDescription: The configuration file for STM32F767IG.
N******************************************************************************/
N
N/* Defines *******************************************************************/
N/* The HAL library */
N#include "stm32f7xx.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   CMSIS STM32F7xx Device Peripheral Access Layer Header File.           
N  *            
N  *          The file is the unique include file that the application programmer
N  *          is using in the C source code, usually in main.c. This file contains:
N  *           - Configuration section that allows to select:
N  *              - The STM32F7xx device used in the target application
N  *              - To use or not the peripheral’s drivers in application code(i.e. 
N  *                code will be based on direct access to peripheral’s registers 
N  *                rather than drivers API), this option is controlled by 
N  *                "#define USE_HAL_DRIVER"
N  *  
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/** @addtogroup CMSIS
N  * @{
N  */
N
N/** @addtogroup stm32f7xx
N  * @{
N  */
N    
N#ifndef __STM32F7xx_H
N#define __STM32F7xx_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif /* __cplusplus */
N  
N/** @addtogroup Library_configuration_section
N  * @{
N  */
N
N/**
N  * @brief STM32 Family
N  */
N#if !defined  (STM32F7)
X#if !0L
N#define STM32F7
N#endif /* STM32F7 */
N
N/* Uncomment the line below according to the target STM32 device used in your
N   application 
N  */
N#if !defined (STM32F756xx) && !defined (STM32F746xx) && !defined (STM32F745xx) && !defined (STM32F767xx) && \
N    !defined (STM32F769xx) && !defined (STM32F777xx) && !defined (STM32F779xx)
X#if !0L && !0L && !0L && !1L &&     !0L && !0L && !0L
S  /* #define STM32F756xx */   /*!< STM32F756VG, STM32F756ZG, STM32F756ZG, STM32F756IG, STM32F756BG,
S                                   STM32F756NG Devices */
S  /* #define STM32F746xx */   /*!< STM32F746VE, STM32F746VG, STM32F746ZE, STM32F746ZG, STM32F746IE, STM32F746IG,
S                                   STM32F746BE, STM32F746BG, STM32F746NE, STM32F746NG Devices */
S  /* #define STM32F745xx */   /*!< STM32F745VE, STM32F745VG, STM32F745ZG, STM32F745ZE, STM32F745IE, STM32F745IG Devices */
S  /* #define STM32F765xx */   /*!< STM32F765BI, STM32F765BG, STM32F765NI, STM32F765NG, STM32F765II, STM32F765IG,
S                                   STM32F765ZI, STM32F765ZG, STM32F765VI, STM32F765VG Devices */
S  /* #define STM32F767xx */   /*!< STM32F767BG, STM32F767BI, STM32F767IG, STM32F767II, STM32F767NG, STM32F767NI,
S                                   STM32F767VG, STM32F767VI, STM32F767ZG, STM32F767ZI Devices */
S  /* #define STM32F769xx */   /*!< STM32F769AG, STM32F769AI, STM32F769BG, STM32F769BI, STM32F769IG, STM32F769II,
S                                   STM32F769NG, STM32F769NI, STM32F768AI Devices */
S  /* #define STM32F777xx */   /*!< STM32F777VI, STM32F777ZI, STM32F777II, STM32F777BI, STM32F777NI Devices */
S  /* #define STM32F779xx */   /*!< STM32F779II, STM32F779BI, STM32F779NI, STM32F779AI, STM32F778AI Devices */
N#endif
N
N/*  Tip: To avoid modifying this file each time you need to switch between these
N        devices, you can define the device in your toolchain compiler preprocessor.
N  */
N
N#if !defined  (USE_HAL_DRIVER)
X#if !1L
S/**
S * @brief Comment the line below if you will not use the peripherals drivers.
S   In this case, these drivers will not be included and the application code will 
S   be based on direct access to peripherals registers 
S   */
S  /*#define USE_HAL_DRIVER */
N#endif /* USE_HAL_DRIVER */
N
N/**
N  * @brief CMSIS Device version number V1.1.1
N  */
N#define __STM32F7_CMSIS_VERSION_MAIN   (0x01) /*!< [31:24] main version */
N#define __STM32F7_CMSIS_VERSION_SUB1   (0x01) /*!< [23:16] sub1 version */
N#define __STM32F7_CMSIS_VERSION_SUB2   (0x01) /*!< [15:8]  sub2 version */
N#define __STM32F7_CMSIS_VERSION_RC     (0x00) /*!< [7:0]  release candidate */ 
N#define __STM32F7_CMSIS_VERSION        ((__STM32F7_CMSIS_VERSION_MAIN << 24)\
N                                       |(__STM32F7_CMSIS_VERSION_SUB1 << 16)\
N                                       |(__STM32F7_CMSIS_VERSION_SUB2 << 8 )\
N                                       |(__STM32F7_CMSIS_VERSION))
X#define __STM32F7_CMSIS_VERSION        ((__STM32F7_CMSIS_VERSION_MAIN << 24)                                       |(__STM32F7_CMSIS_VERSION_SUB1 << 16)                                       |(__STM32F7_CMSIS_VERSION_SUB2 << 8 )                                       |(__STM32F7_CMSIS_VERSION))
N/**
N  * @}
N  */
N
N/** @addtogroup Device_Included
N  * @{
N  */
N#if defined(STM32F756xx)
X#if 0L
S  #include "stm32f756xx.h"
S#elif defined(STM32F746xx)
X#elif 0L
S  #include "stm32f746xx.h"
S#elif defined(STM32F745xx)
X#elif 0L
S  #include "stm32f745xx.h"
S#elif defined(STM32F765xx)
X#elif 0L
S  #include "stm32f765xx.h"
N#elif defined(STM32F767xx)
X#elif 1L
N  #include "stm32f767xx.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f767xx.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f767xx.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   CMSIS Cortex-M7 Device Peripheral Access Layer Header File.
N  *
N  *          This file contains:
N  *           - Data structures and the address mapping for all peripherals
N  *           - Peripheral's registers declarations and bits definition
N  *           - Macros to access peripheral’s registers hardware
N  *
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/** @addtogroup CMSIS_Device
N  * @{
N  */
N
N/** @addtogroup stm32f767xx
N  * @{
N  */
N    
N#ifndef __STM32F767xx_H
N#define __STM32F767xx_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif /* __cplusplus */
N  
N/** @addtogroup Configuration_section_for_CMSIS
N  * @{
N  */
N
N/**
N * @brief STM32F7xx Interrupt Number Definition, according to the selected device 
N *        in @ref Library_configuration_section 
N */
Ntypedef enum
N{
N/******  Cortex-M7 Processor Exceptions Numbers ****************************************************************/
N  NonMaskableInt_IRQn         = -14,    /*!< 2 Non Maskable Interrupt                                          */
N  MemoryManagement_IRQn       = -12,    /*!< 4 Cortex-M7 Memory Management Interrupt                           */
N  BusFault_IRQn               = -11,    /*!< 5 Cortex-M7 Bus Fault Interrupt                                   */
N  UsageFault_IRQn             = -10,    /*!< 6 Cortex-M7 Usage Fault Interrupt                                 */
N  SVCall_IRQn                 = -5,     /*!< 11 Cortex-M7 SV Call Interrupt                                    */
N  DebugMonitor_IRQn           = -4,     /*!< 12 Cortex-M7 Debug Monitor Interrupt                              */
N  PendSV_IRQn                 = -2,     /*!< 14 Cortex-M7 Pend SV Interrupt                                    */
N  SysTick_IRQn                = -1,     /*!< 15 Cortex-M7 System Tick Interrupt                                */
N/******  STM32 specific Interrupt Numbers **********************************************************************/
N  WWDG_IRQn                   = 0,      /*!< Window WatchDog Interrupt                                         */
N  PVD_IRQn                    = 1,      /*!< PVD through EXTI Line detection Interrupt                         */
N  TAMP_STAMP_IRQn             = 2,      /*!< Tamper and TimeStamp interrupts through the EXTI line             */
N  RTC_WKUP_IRQn               = 3,      /*!< RTC Wakeup interrupt through the EXTI line                        */
N  FLASH_IRQn                  = 4,      /*!< FLASH global Interrupt                                            */
N  RCC_IRQn                    = 5,      /*!< RCC global Interrupt                                              */
N  EXTI0_IRQn                  = 6,      /*!< EXTI Line0 Interrupt                                              */
N  EXTI1_IRQn                  = 7,      /*!< EXTI Line1 Interrupt                                              */
N  EXTI2_IRQn                  = 8,      /*!< EXTI Line2 Interrupt                                              */
N  EXTI3_IRQn                  = 9,      /*!< EXTI Line3 Interrupt                                              */
N  EXTI4_IRQn                  = 10,     /*!< EXTI Line4 Interrupt                                              */
N  DMA1_Stream0_IRQn           = 11,     /*!< DMA1 Stream 0 global Interrupt                                    */
N  DMA1_Stream1_IRQn           = 12,     /*!< DMA1 Stream 1 global Interrupt                                    */
N  DMA1_Stream2_IRQn           = 13,     /*!< DMA1 Stream 2 global Interrupt                                    */
N  DMA1_Stream3_IRQn           = 14,     /*!< DMA1 Stream 3 global Interrupt                                    */
N  DMA1_Stream4_IRQn           = 15,     /*!< DMA1 Stream 4 global Interrupt                                    */
N  DMA1_Stream5_IRQn           = 16,     /*!< DMA1 Stream 5 global Interrupt                                    */
N  DMA1_Stream6_IRQn           = 17,     /*!< DMA1 Stream 6 global Interrupt                                    */
N  ADC_IRQn                    = 18,     /*!< ADC1, ADC2 and ADC3 global Interrupts                             */
N  CAN1_TX_IRQn                = 19,     /*!< CAN1 TX Interrupt                                                 */
N  CAN1_RX0_IRQn               = 20,     /*!< CAN1 RX0 Interrupt                                                */
N  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                                */
N  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                                */
N  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                                     */
N  TIM1_BRK_TIM9_IRQn          = 24,     /*!< TIM1 Break interrupt and TIM9 global interrupt                    */
N  TIM1_UP_TIM10_IRQn          = 25,     /*!< TIM1 Update Interrupt and TIM10 global interrupt                  */
N  TIM1_TRG_COM_TIM11_IRQn     = 26,     /*!< TIM1 Trigger and Commutation Interrupt and TIM11 global interrupt */
N  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                                    */
N  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                             */
N  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                             */
N  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                             */
N  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                              */
N  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                              */
N  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                              */
N  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                              */  
N  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                             */
N  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                             */
N  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                                           */
N  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                                           */
N  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                                           */
N  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                                   */
N  RTC_Alarm_IRQn              = 41,     /*!< RTC Alarm (A and B) through EXTI Line Interrupt                   */
N  OTG_FS_WKUP_IRQn            = 42,     /*!< USB OTG FS Wakeup through EXTI line interrupt                     */    
N  TIM8_BRK_TIM12_IRQn         = 43,     /*!< TIM8 Break Interrupt and TIM12 global interrupt                   */
N  TIM8_UP_TIM13_IRQn          = 44,     /*!< TIM8 Update Interrupt and TIM13 global interrupt                  */
N  TIM8_TRG_COM_TIM14_IRQn     = 45,     /*!< TIM8 Trigger and Commutation Interrupt and TIM14 global interrupt */
N  TIM8_CC_IRQn                = 46,     /*!< TIM8 Capture Compare Interrupt                                    */
N  DMA1_Stream7_IRQn           = 47,     /*!< DMA1 Stream7 Interrupt                                            */
N  FMC_IRQn                    = 48,     /*!< FMC global Interrupt                                              */
N  SDMMC1_IRQn                 = 49,     /*!< SDMMC1 global Interrupt                                           */
N  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                             */
N  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                             */
N  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                                            */
N  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                                            */
N  TIM6_DAC_IRQn               = 54,     /*!< TIM6 global and DAC1&2 underrun error  interrupts                 */
N  TIM7_IRQn                   = 55,     /*!< TIM7 global interrupt                                             */
N  DMA2_Stream0_IRQn           = 56,     /*!< DMA2 Stream 0 global Interrupt                                    */
N  DMA2_Stream1_IRQn           = 57,     /*!< DMA2 Stream 1 global Interrupt                                    */
N  DMA2_Stream2_IRQn           = 58,     /*!< DMA2 Stream 2 global Interrupt                                    */
N  DMA2_Stream3_IRQn           = 59,     /*!< DMA2 Stream 3 global Interrupt                                    */
N  DMA2_Stream4_IRQn           = 60,     /*!< DMA2 Stream 4 global Interrupt                                    */
N  ETH_IRQn                    = 61,     /*!< Ethernet global Interrupt                                         */
N  ETH_WKUP_IRQn               = 62,     /*!< Ethernet Wakeup through EXTI line Interrupt                       */
N  CAN2_TX_IRQn                = 63,     /*!< CAN2 TX Interrupt                                                 */
N  CAN2_RX0_IRQn               = 64,     /*!< CAN2 RX0 Interrupt                                                */
N  CAN2_RX1_IRQn               = 65,     /*!< CAN2 RX1 Interrupt                                                */
N  CAN2_SCE_IRQn               = 66,     /*!< CAN2 SCE Interrupt                                                */
N  OTG_FS_IRQn                 = 67,     /*!< USB OTG FS global Interrupt                                       */
N  DMA2_Stream5_IRQn           = 68,     /*!< DMA2 Stream 5 global interrupt                                    */
N  DMA2_Stream6_IRQn           = 69,     /*!< DMA2 Stream 6 global interrupt                                    */
N  DMA2_Stream7_IRQn           = 70,     /*!< DMA2 Stream 7 global interrupt                                    */
N  USART6_IRQn                 = 71,     /*!< USART6 global interrupt                                           */
N  I2C3_EV_IRQn                = 72,     /*!< I2C3 event interrupt                                              */
N  I2C3_ER_IRQn                = 73,     /*!< I2C3 error interrupt                                              */
N  OTG_HS_EP1_OUT_IRQn         = 74,     /*!< USB OTG HS End Point 1 Out global interrupt                       */
N  OTG_HS_EP1_IN_IRQn          = 75,     /*!< USB OTG HS End Point 1 In global interrupt                        */
N  OTG_HS_WKUP_IRQn            = 76,     /*!< USB OTG HS Wakeup through EXTI interrupt                          */
N  OTG_HS_IRQn                 = 77,     /*!< USB OTG HS global interrupt                                       */
N  DCMI_IRQn                   = 78,     /*!< DCMI global interrupt                                             */
N  RNG_IRQn                    = 80,     /*!< RNG global interrupt                                              */
N  FPU_IRQn                    = 81,     /*!< FPU global interrupt                                              */
N  UART7_IRQn                  = 82,     /*!< UART7 global interrupt                                            */
N  UART8_IRQn                  = 83,     /*!< UART8 global interrupt                                            */
N  SPI4_IRQn                   = 84,     /*!< SPI4 global Interrupt                                             */
N  SPI5_IRQn                   = 85,     /*!< SPI5 global Interrupt                                             */
N  SPI6_IRQn                   = 86,     /*!< SPI6 global Interrupt                                             */
N  SAI1_IRQn                   = 87,     /*!< SAI1 global Interrupt                                             */
N  LTDC_IRQn                   = 88,     /*!< LTDC global Interrupt                                             */
N  LTDC_ER_IRQn                = 89,     /*!< LTDC Error global Interrupt                                       */
N  DMA2D_IRQn                  = 90,     /*!< DMA2D global Interrupt                                            */
N  SAI2_IRQn                   = 91,     /*!< SAI2 global Interrupt                                             */
N  QUADSPI_IRQn                = 92,     /*!< Quad SPI global interrupt                                         */
N  LPTIM1_IRQn                 = 93,     /*!< LP TIM1 interrupt                                                 */
N  CEC_IRQn                    = 94,     /*!< HDMI-CEC global Interrupt                                         */
N  I2C4_EV_IRQn                = 95,     /*!< I2C4 Event Interrupt                                              */
N  I2C4_ER_IRQn                = 96,     /*!< I2C4 Error Interrupt                                              */
N  SPDIF_RX_IRQn               = 97,     /*!< SPDIF-RX global Interrupt                                         */
N  DFSDM1_FLT0_IRQn	          = 99,     /*!< DFSDM1 Filter 0 global Interrupt                                  */
N  DFSDM1_FLT1_IRQn	          = 100,    /*!< DFSDM1 Filter 1 global Interrupt                                  */
N  DFSDM1_FLT2_IRQn	          = 101,    /*!< DFSDM1 Filter 2 global Interrupt                                  */
N  DFSDM1_FLT3_IRQn	          = 102,    /*!< DFSDM1 Filter 3 global Interrupt                                  */
N  SDMMC2_IRQn                 = 103,    /*!< SDMMC2 global Interrupt                                           */
N  CAN3_TX_IRQn                = 104,    /*!< CAN3 TX Interrupt                                                 */
N  CAN3_RX0_IRQn               = 105,    /*!< CAN3 RX0 Interrupt                                                */
N  CAN3_RX1_IRQn               = 106,    /*!< CAN3 RX1 Interrupt                                                */
N  CAN3_SCE_IRQn               = 107,    /*!< CAN3 SCE Interrupt                                                */
N  JPEG_IRQn                   = 108,    /*!< JPEG global Interrupt                                             */
N  MDIOS_IRQn                  = 109     /*!< MDIO Slave global Interrupt                                       */
N} IRQn_Type;
N
N/**
N  * @}
N  */
N
N/**
N * @brief Configuration of the Cortex-M7 Processor and Core Peripherals 
N */
N#define __CM7_REV                 0x0100U  /*!< Cortex-M7 revision r1p0                       */
N#define __MPU_PRESENT             1       /*!< CM7 provides an MPU                           */
N#define __NVIC_PRIO_BITS          4       /*!< CM7 uses 4 Bits for the Priority Levels       */
N#define __Vendor_SysTickConfig    0       /*!< Set to 1 if different SysTick Config is used  */
N#define __FPU_PRESENT             1       /*!< FPU present                                   */
N#define __ICACHE_PRESENT          1       /*!< CM7 instruction cache present                 */
N#define __DCACHE_PRESENT          1       /*!< CM7 data cache present                        */
N#include "core_cm7.h"                     /*!< Cortex-M7 processor and core peripherals      */
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Core\core_cm7.h" 1
N/**************************************************************************//**
N * @file     core_cm7.h
N * @brief    CMSIS Cortex-M7 Core Peripheral Access Layer Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060183 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM7_H_GENERIC
N#define __CORE_CM7_H_GENERIC
N
N#include <stdint.h>
L 1 "D:\Program_Files_x86\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060009
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 45 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Core\core_cm7.h" 2
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex_M7
N  @{
N */
N
N/*  CMSIS CM7 definitions */
N#define __CM7_CMSIS_VERSION_MAIN  (0x04U)                                      /*!< [31:16] CMSIS HAL main version */
N#define __CM7_CMSIS_VERSION_SUB   (0x1EU)                                      /*!< [15:0]  CMSIS HAL sub version */
N#define __CM7_CMSIS_VERSION       ((__CM7_CMSIS_VERSION_MAIN << 16U) | \
N                                    __CM7_CMSIS_VERSION_SUB           )        /*!< CMSIS HAL version number */
X#define __CM7_CMSIS_VERSION       ((__CM7_CMSIS_VERSION_MAIN << 16U) |                                     __CM7_CMSIS_VERSION_SUB           )         
N
N#define __CORTEX_M                (0x07U)                                      /*!< Cortex-M Core */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
S  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
S  #define __STATIC_INLINE  static __inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TMS470__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __CSMC__ )
S  #define __packed
S  #define __ASM            _asm                                      /*!< asm keyword for COSMIC Compiler */
S  #define __INLINE         inline                                    /*!< inline keyword for COSMIC Compiler. Use -pc99 on compile line */
S  #define __STATIC_INLINE  static inline
S
S#else
S  #error Unknown compiler
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    For this, __FPU_PRESENT has to be checked prior to making use of FPU specific registers and functions.
N*/
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 1L
N    #if (__FPU_PRESENT == 1U)
X    #if (1 == 1U)
N      #define __FPU_USED       1U
N    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
N    #endif
N  #else
S    #define __FPU_USED         0U
N  #endif
N
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_PCS_VFP
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1U
S    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __TMS470__ )
S  #if defined __TI_VFP_SUPPORT__
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
N#endif
N
N#include "core_cmInstr.h"                /* Core Instruction Access */
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Core\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060183 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Core\cmsis_armcc.h" 1
N/**************************************************************************//**
N * @file     cmsis_armcc.h
N * @brief    CMSIS Cortex-M Core Function/Instruction Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5060183 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x07U) >= 0x03U) || (__CORTEX_SC >= 300U)
N
N/**
N  \brief   Enable FIQ
N  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N#define __enable_fault_irq                __enable_fiq
N
N
N/**
N  \brief   Disable FIQ
N  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N#define __disable_fault_irq               __disable_fiq
N
N
N/**
N  \brief   Get Base Priority
N  \details Returns the current value of the Base Priority register.
N  \return               Base Priority register value
N */
N__STATIC_INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N
N/**
N  \brief   Set Base Priority
N  \details Assigns the given value to the Base Priority register.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Set Base Priority with condition
N  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
N           or the new value increases the BASEPRI priority level.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
Xstatic __inline void __set_BASEPRI_MAX(uint32_t basePri)
N{
N  register uint32_t __regBasePriMax      __ASM("basepri_max");
X  register uint32_t __regBasePriMax      __asm("basepri_max");
N  __regBasePriMax = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Get Fault Mask
N  \details Returns the current value of the Fault Mask register.
N  \return               Fault Mask register value
N */
N__STATIC_INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N
N/**
N  \brief   Set Fault Mask
N  \details Assigns the given value to the Fault Mask register.
N  \param [in]    faultMask  Fault Mask value to set
N */
N__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & (uint32_t)1);
N}
N
N#endif /* (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U) */
N
N
N#if       (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U)
X#if       ((0x07U) == 0x04U) || ((0x07U) == 0x07U)
N
N/**
N  \brief   Get FPSCR
N  \details Returns the current value of the Floating Point Status/Control register.
N  \return               Floating Point Status/Control register value
N */
N__STATIC_INLINE uint32_t __get_FPSCR(void)
Xstatic __inline uint32_t __get_FPSCR(void)
N{
N#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
X#if (1 == 1U) && (1U == 1U)
N  register uint32_t __regfpscr         __ASM("fpscr");
X  register uint32_t __regfpscr         __asm("fpscr");
N  return(__regfpscr);
N#else
S   return(0U);
N#endif
N}
N
N
N/**
N  \brief   Set FPSCR
N  \details Assigns the given value to the Floating Point Status/Control register.
N  \param [in]    fpscr  Floating Point Status/Control value to set
N */
N__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
Xstatic __inline void __set_FPSCR(uint32_t fpscr)
N{
N#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
X#if (1 == 1U) && (1U == 1U)
N  register uint32_t __regfpscr         __ASM("fpscr");
X  register uint32_t __regfpscr         __asm("fpscr");
N  __regfpscr = (fpscr);
N#endif
N}
N
N#endif /* (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U) */
N
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB() do {\
N                   __schedule_barrier();\
N                   __isb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __ISB() do {                   __schedule_barrier();                   __isb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB() do {\
N                   __schedule_barrier();\
N                   __dsb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DSB() do {                   __schedule_barrier();                   __dsb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB() do {\
N                   __schedule_barrier();\
N                   __dmb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DMB() do {                   __schedule_barrier();                   __dmb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in integer value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in two unsigned short values.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N/**
N  \brief   Reverse byte order in signed short value
N  \details Reverses the byte order in a signed short value with sign extension to integer.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    value  Value to rotate
N  \param [in]    value  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x07U) >= 0x03U) || (__CORTEX_SC >= 300U)
N  #define __RBIT                          __rbit
N#else
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S  int32_t s = 4 /*sizeof(v)*/ * 8 - 1; /* extra shift needed at end */
S
S  result = value;                      /* r will be reversed bits of v; first get LSB of v */
S  for (value >>= 1U; value; value >>= 1U)
S  {
S    result <<= 1U;
S    result |= value & 1U;
S    s--;
S  }
S  result <<= s;                        /* shift when v's highest bits are zero */
S  return(result);
S}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x07U) >= 0x03U) || (__CORTEX_SC >= 300U)
N
N/**
N  \brief   LDR Exclusive (8 bit)
N  \details Executes a exclusive LDR instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060183 < 5060020)
S  #define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
N#else
N  #define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (16 bit)
N  \details Executes a exclusive LDR instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060183 < 5060020)
S  #define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
N#else
N  #define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (32 bit)
N  \details Executes a exclusive LDR instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060183 < 5060020)
S  #define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
N#else
N  #define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (8 bit)
N  \details Executes a exclusive STR instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060183 < 5060020)
S  #define __STREXB(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (16 bit)
N  \details Executes a exclusive STR instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060183 < 5060020)
S  #define __STREXH(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (32 bit)
N  \details Executes a exclusive STR instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060183 < 5060020)
S  #define __STREXW(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   Remove the exclusive lock
N  \details Removes the exclusive lock which is created by LDREX.
N */
N#define __CLREX                           __clrex
N
N
N/**
N  \brief   Signed Saturate
N  \details Saturates a signed value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (1..32)
N  \return             Saturated value
N */
N#define __SSAT                            __ssat
N
N
N/**
N  \brief   Unsigned Saturate
N  \details Saturates an unsigned value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (0..31)
N  \return             Saturated value
N */
N#define __USAT                            __usat
N
N
N/**
N  \brief   Rotate Right with Extend (32 bit)
N  \details Moves each bit of a bitstring right by one bit.
N           The carry input is shifted in at the left end of the bitstring.
N  \param [in]    value  Value to rotate
N  \return               Rotated value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
X__attribute__((section(".rrx_text"))) static __inline __asm uint32_t __RRX(uint32_t value)
N{
N  rrx r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   LDRT Unprivileged (8 bit)
N  \details Executes a Unprivileged LDRT instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (16 bit)
N  \details Executes a Unprivileged LDRT instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (32 bit)
N  \details Executes a Unprivileged LDRT instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
N
N
N/**
N  \brief   STRT Unprivileged (8 bit)
N  \details Executes a Unprivileged STRT instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRBT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (16 bit)
N  \details Executes a Unprivileged STRT instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRHT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (32 bit)
N  \details Executes a Unprivileged STRT instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRT(value, ptr)                __strt(value, ptr)
N
N#endif /* (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U) */
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if (__CORTEX_M >= 0x04U)  /* only for Cortex-M4 and above */
X#if ((0x07U) >= 0x04U)   
N
N#define __SADD8                           __sadd8
N#define __QADD8                           __qadd8
N#define __SHADD8                          __shadd8
N#define __UADD8                           __uadd8
N#define __UQADD8                          __uqadd8
N#define __UHADD8                          __uhadd8
N#define __SSUB8                           __ssub8
N#define __QSUB8                           __qsub8
N#define __SHSUB8                          __shsub8
N#define __USUB8                           __usub8
N#define __UQSUB8                          __uqsub8
N#define __UHSUB8                          __uhsub8
N#define __SADD16                          __sadd16
N#define __QADD16                          __qadd16
N#define __SHADD16                         __shadd16
N#define __UADD16                          __uadd16
N#define __UQADD16                         __uqadd16
N#define __UHADD16                         __uhadd16
N#define __SSUB16                          __ssub16
N#define __QSUB16                          __qsub16
N#define __SHSUB16                         __shsub16
N#define __USUB16                          __usub16
N#define __UQSUB16                         __uqsub16
N#define __UHSUB16                         __uhsub16
N#define __SASX                            __sasx
N#define __QASX                            __qasx
N#define __SHASX                           __shasx
N#define __UASX                            __uasx
N#define __UQASX                           __uqasx
N#define __UHASX                           __uhasx
N#define __SSAX                            __ssax
N#define __QSAX                            __qsax
N#define __SHSAX                           __shsax
N#define __USAX                            __usax
N#define __UQSAX                           __uqsax
N#define __UHSAX                           __uhsax
N#define __USAD8                           __usad8
N#define __USADA8                          __usada8
N#define __SSAT16                          __ssat16
N#define __USAT16                          __usat16
N#define __UXTB16                          __uxtb16
N#define __UXTAB16                         __uxtab16
N#define __SXTB16                          __sxtb16
N#define __SXTAB16                         __sxtab16
N#define __SMUAD                           __smuad
N#define __SMUADX                          __smuadx
N#define __SMLAD                           __smlad
N#define __SMLADX                          __smladx
N#define __SMLALD                          __smlald
N#define __SMLALDX                         __smlaldx
N#define __SMUSD                           __smusd
N#define __SMUSDX                          __smusdx
N#define __SMLSD                           __smlsd
N#define __SMLSDX                          __smlsdx
N#define __SMLSLD                          __smlsld
N#define __SMLSLDX                         __smlsldx
N#define __SEL                             __sel
N#define __QADD                            __qadd
N#define __QSUB                            __qsub
N
N#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
N                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
N
N#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
N                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
N
N#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
N                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
N
N#endif /* (__CORTEX_M >= 0x04) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 54 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Core\core_cmInstr.h" 2
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S  #include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S  #include <cmsis_csm.h>
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 211 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Core\core_cm7.h" 2
N#include "core_cmFunc.h"                 /* Core Function Access */
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Core\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060183 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S  #include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S  #include <cmsis_csm.h>
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N#endif /* __CORE_CMFUNC_H */
L 212 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Core\core_cm7.h" 2
N#include "core_cmSimd.h"                 /* Compiler specific SIMD Intrinsics */
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Core\core_cmSimd.h" 1
N/**************************************************************************//**
N * @file     core_cmSimd.h
N * @brief    CMSIS Cortex-M SIMD Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060183 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMSIMD_H
N#define __CORE_CMSIMD_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S  #include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S  #include <cmsis_csm.h>
S
N#endif
N
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CMSIMD_H */
L 213 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Core\core_cm7.h" 2
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM7_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM7_H_DEPENDANT
N#define __CORE_CM7_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM7_REV
S    #define __CM7_REV               0x0000U
S    #warning "__CM7_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __FPU_PRESENT
S    #define __FPU_PRESENT             0U
S    #warning "__FPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0U
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __ICACHE_PRESENT
S    #define __ICACHE_PRESENT          0U
S    #warning "__ICACHE_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __DCACHE_PRESENT
S    #define __DCACHE_PRESENT          0U
S    #warning "__DCACHE_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __DTCM_PRESENT
S    #define __DTCM_PRESENT            0U
S    #warning "__DTCM_PRESENT        not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          3U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex_M7 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core Debug Register
N  - Core MPU Register
N  - Core FPU Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved */
N    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
N    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N#define APSR_Q_Pos                         27U                                            /*!< APSR: Q Position */
N#define APSR_Q_Msk                         (1UL << APSR_Q_Pos)                            /*!< APSR: Q Mask */
N
N#define APSR_GE_Pos                        16U                                            /*!< APSR: GE Position */
N#define APSR_GE_Msk                        (0xFUL << APSR_GE_Pos)                         /*!< APSR: GE Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved */
N    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
N    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0) */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_Q_Pos                         27U                                            /*!< xPSR: Q Position */
N#define xPSR_Q_Msk                         (1UL << xPSR_Q_Pos)                            /*!< xPSR: Q Mask */
N
N#define xPSR_IT_Pos                        25U                                            /*!< xPSR: IT Position */
N#define xPSR_IT_Msk                        (3UL << xPSR_IT_Pos)                           /*!< xPSR: IT Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_GE_Pos                        16U                                            /*!< xPSR: GE Position */
N#define xPSR_GE_Msk                        (0xFUL << xPSR_GE_Pos)                         /*!< xPSR: GE Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_FPCA_Pos                    2U                                            /*!< CONTROL: FPCA Position */
N#define CONTROL_FPCA_Msk                   (1UL << CONTROL_FPCA_Pos)                      /*!< CONTROL: FPCA Mask */
N
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N#define CONTROL_nPRIV_Pos                   0U                                            /*!< CONTROL: nPRIV Position */
N#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IOM uint32_t ISER[8U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X  volatile uint32_t ISER[8U];                
N        uint32_t RESERVED0[24U];
N  __IOM uint32_t ICER[8U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X  volatile uint32_t ICER[8U];                
N        uint32_t RSERVED1[24U];
N  __IOM uint32_t ISPR[8U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X  volatile uint32_t ISPR[8U];                
N        uint32_t RESERVED2[24U];
N  __IOM uint32_t ICPR[8U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X  volatile uint32_t ICPR[8U];                
N        uint32_t RESERVED3[24U];
N  __IOM uint32_t IABR[8U];               /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register */
X  volatile uint32_t IABR[8U];                
N        uint32_t RESERVED4[56U];
N  __IOM uint8_t  IP[240U];               /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240U];                
N        uint32_t RESERVED5[644U];
N  __OM  uint32_t STIR;                   /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register */
X  volatile  uint32_t STIR;                    
N}  NVIC_Type;
N
N/* Software Triggered Interrupt Register Definitions */
N#define NVIC_STIR_INTID_Pos                 0U                                         /*!< STIR: INTLINESNUM Position */
N#define NVIC_STIR_INTID_Msk                (0x1FFUL /*<< NVIC_STIR_INTID_Pos*/)        /*!< STIR: INTLINESNUM Mask */
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X  volatile const  uint32_t CPUID;                   
N  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X  volatile uint32_t ICSR;                    
N  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
X  volatile uint32_t VTOR;                    
N  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X  volatile uint32_t AIRCR;                   
N  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X  volatile uint32_t SCR;                     
N  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X  volatile uint32_t CCR;                     
N  __IOM uint8_t  SHPR[12U];              /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHPR[12U];               
N  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X  volatile uint32_t SHCSR;                   
N  __IOM uint32_t CFSR;                   /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register */
X  volatile uint32_t CFSR;                    
N  __IOM uint32_t HFSR;                   /*!< Offset: 0x02C (R/W)  HardFault Status Register */
X  volatile uint32_t HFSR;                    
N  __IOM uint32_t DFSR;                   /*!< Offset: 0x030 (R/W)  Debug Fault Status Register */
X  volatile uint32_t DFSR;                    
N  __IOM uint32_t MMFAR;                  /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register */
X  volatile uint32_t MMFAR;                   
N  __IOM uint32_t BFAR;                   /*!< Offset: 0x038 (R/W)  BusFault Address Register */
X  volatile uint32_t BFAR;                    
N  __IOM uint32_t AFSR;                   /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register */
X  volatile uint32_t AFSR;                    
N  __IM  uint32_t ID_PFR[2U];             /*!< Offset: 0x040 (R/ )  Processor Feature Register */
X  volatile const  uint32_t ID_PFR[2U];              
N  __IM  uint32_t ID_DFR;                 /*!< Offset: 0x048 (R/ )  Debug Feature Register */
X  volatile const  uint32_t ID_DFR;                  
N  __IM  uint32_t ID_AFR;                 /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register */
X  volatile const  uint32_t ID_AFR;                  
N  __IM  uint32_t ID_MFR[4U];             /*!< Offset: 0x050 (R/ )  Memory Model Feature Register */
X  volatile const  uint32_t ID_MFR[4U];              
N  __IM  uint32_t ID_ISAR[5U];            /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register */
X  volatile const  uint32_t ID_ISAR[5U];             
N        uint32_t RESERVED0[1U];
N  __IM  uint32_t CLIDR;                  /*!< Offset: 0x078 (R/ )  Cache Level ID register */
X  volatile const  uint32_t CLIDR;                   
N  __IM  uint32_t CTR;                    /*!< Offset: 0x07C (R/ )  Cache Type register */
X  volatile const  uint32_t CTR;                     
N  __IM  uint32_t CCSIDR;                 /*!< Offset: 0x080 (R/ )  Cache Size ID Register */
X  volatile const  uint32_t CCSIDR;                  
N  __IOM uint32_t CSSELR;                 /*!< Offset: 0x084 (R/W)  Cache Size Selection Register */
X  volatile uint32_t CSSELR;                  
N  __IOM uint32_t CPACR;                  /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register */
X  volatile uint32_t CPACR;                   
N        uint32_t RESERVED3[93U];
N  __OM  uint32_t STIR;                   /*!< Offset: 0x200 ( /W)  Software Triggered Interrupt Register */
X  volatile  uint32_t STIR;                    
N        uint32_t RESERVED4[15U];
N  __IM  uint32_t MVFR0;                  /*!< Offset: 0x240 (R/ )  Media and VFP Feature Register 0 */
X  volatile const  uint32_t MVFR0;                   
N  __IM  uint32_t MVFR1;                  /*!< Offset: 0x244 (R/ )  Media and VFP Feature Register 1 */
X  volatile const  uint32_t MVFR1;                   
N  __IM  uint32_t MVFR2;                  /*!< Offset: 0x248 (R/ )  Media and VFP Feature Register 1 */
X  volatile const  uint32_t MVFR2;                   
N        uint32_t RESERVED5[1U];
N  __OM  uint32_t ICIALLU;                /*!< Offset: 0x250 ( /W)  I-Cache Invalidate All to PoU */
X  volatile  uint32_t ICIALLU;                 
N        uint32_t RESERVED6[1U];
N  __OM  uint32_t ICIMVAU;                /*!< Offset: 0x258 ( /W)  I-Cache Invalidate by MVA to PoU */
X  volatile  uint32_t ICIMVAU;                 
N  __OM  uint32_t DCIMVAC;                /*!< Offset: 0x25C ( /W)  D-Cache Invalidate by MVA to PoC */
X  volatile  uint32_t DCIMVAC;                 
N  __OM  uint32_t DCISW;                  /*!< Offset: 0x260 ( /W)  D-Cache Invalidate by Set-way */
X  volatile  uint32_t DCISW;                   
N  __OM  uint32_t DCCMVAU;                /*!< Offset: 0x264 ( /W)  D-Cache Clean by MVA to PoU */
X  volatile  uint32_t DCCMVAU;                 
N  __OM  uint32_t DCCMVAC;                /*!< Offset: 0x268 ( /W)  D-Cache Clean by MVA to PoC */
X  volatile  uint32_t DCCMVAC;                 
N  __OM  uint32_t DCCSW;                  /*!< Offset: 0x26C ( /W)  D-Cache Clean by Set-way */
X  volatile  uint32_t DCCSW;                   
N  __OM  uint32_t DCCIMVAC;               /*!< Offset: 0x270 ( /W)  D-Cache Clean and Invalidate by MVA to PoC */
X  volatile  uint32_t DCCIMVAC;                
N  __OM  uint32_t DCCISW;                 /*!< Offset: 0x274 ( /W)  D-Cache Clean and Invalidate by Set-way */
X  volatile  uint32_t DCCISW;                  
N        uint32_t RESERVED7[6U];
N  __IOM uint32_t ITCMCR;                 /*!< Offset: 0x290 (R/W)  Instruction Tightly-Coupled Memory Control Register */
X  volatile uint32_t ITCMCR;                  
N  __IOM uint32_t DTCMCR;                 /*!< Offset: 0x294 (R/W)  Data Tightly-Coupled Memory Control Registers */
X  volatile uint32_t DTCMCR;                  
N  __IOM uint32_t AHBPCR;                 /*!< Offset: 0x298 (R/W)  AHBP Control Register */
X  volatile uint32_t AHBPCR;                  
N  __IOM uint32_t CACR;                   /*!< Offset: 0x29C (R/W)  L1 Cache Control Register */
X  volatile uint32_t CACR;                    
N  __IOM uint32_t AHBSCR;                 /*!< Offset: 0x2A0 (R/W)  AHB Slave Control Register */
X  volatile uint32_t AHBSCR;                  
N        uint32_t RESERVED8[1U];
N  __IOM uint32_t ABFSR;                  /*!< Offset: 0x2A8 (R/W)  Auxiliary Bus Fault Status Register */
X  volatile uint32_t ABFSR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11U                                            /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Vector Table Offset Register Definitions */
N#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8U                                            /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0U                                            /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1UL /*<< SCB_AIRCR_VECTRESET_Pos*/)           /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_BP_Pos                      18U                                           /*!< SCB CCR: Branch prediction enable bit Position */
N#define SCB_CCR_BP_Msk                     (1UL << SCB_CCR_BP_Pos)                        /*!< SCB CCR: Branch prediction enable bit Mask */
N
N#define SCB_CCR_IC_Pos                      17U                                           /*!< SCB CCR: Instruction cache enable bit Position */
N#define SCB_CCR_IC_Msk                     (1UL << SCB_CCR_IC_Pos)                        /*!< SCB CCR: Instruction cache enable bit Mask */
N
N#define SCB_CCR_DC_Pos                      16U                                           /*!< SCB CCR: Cache enable bit Position */
N#define SCB_CCR_DC_Msk                     (1UL << SCB_CCR_DC_Pos)                        /*!< SCB CCR: Cache enable bit Mask */
N
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8U                                            /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4U                                            /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1U                                            /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0U                                            /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1UL /*<< SCB_CCR_NONBASETHRDENA_Pos*/)        /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18U                                            /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17U                                            /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16U                                            /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14U                                            /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13U                                            /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12U                                            /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11U                                            /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10U                                            /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8U                                            /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7U                                            /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N
N#define SCB_SHCSR_USGFAULTACT_Pos           3U                                            /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1U                                            /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0U                                            /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL /*<< SCB_SHCSR_MEMFAULTACT_Pos*/)         /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Register Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16U                                            /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8U                                            /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0U                                            /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL /*<< SCB_CFSR_MEMFAULTSR_Pos*/)        /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* SCB Hard Fault Status Register Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31U                                            /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30U                                            /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1U                                            /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4U                                            /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3U                                            /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2U                                            /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1U                                            /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0U                                            /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1UL /*<< SCB_DFSR_HALTED_Pos*/)               /*!< SCB DFSR: HALTED Mask */
N
N/* SCB Cache Level ID Register Definitions */
N#define SCB_CLIDR_LOUU_Pos                 27U                                            /*!< SCB CLIDR: LoUU Position */
N#define SCB_CLIDR_LOUU_Msk                 (7UL << SCB_CLIDR_LOUU_Pos)                    /*!< SCB CLIDR: LoUU Mask */
N
N#define SCB_CLIDR_LOC_Pos                  24U                                            /*!< SCB CLIDR: LoC Position */
N#define SCB_CLIDR_LOC_Msk                  (7UL << SCB_CLIDR_LOC_Pos)                     /*!< SCB CLIDR: LoC Mask */
N
N/* SCB Cache Type Register Definitions */
N#define SCB_CTR_FORMAT_Pos                 29U                                            /*!< SCB CTR: Format Position */
N#define SCB_CTR_FORMAT_Msk                 (7UL << SCB_CTR_FORMAT_Pos)                    /*!< SCB CTR: Format Mask */
N
N#define SCB_CTR_CWG_Pos                    24U                                            /*!< SCB CTR: CWG Position */
N#define SCB_CTR_CWG_Msk                    (0xFUL << SCB_CTR_CWG_Pos)                     /*!< SCB CTR: CWG Mask */
N
N#define SCB_CTR_ERG_Pos                    20U                                            /*!< SCB CTR: ERG Position */
N#define SCB_CTR_ERG_Msk                    (0xFUL << SCB_CTR_ERG_Pos)                     /*!< SCB CTR: ERG Mask */
N
N#define SCB_CTR_DMINLINE_Pos               16U                                            /*!< SCB CTR: DminLine Position */
N#define SCB_CTR_DMINLINE_Msk               (0xFUL << SCB_CTR_DMINLINE_Pos)                /*!< SCB CTR: DminLine Mask */
N
N#define SCB_CTR_IMINLINE_Pos                0U                                            /*!< SCB CTR: ImInLine Position */
N#define SCB_CTR_IMINLINE_Msk               (0xFUL /*<< SCB_CTR_IMINLINE_Pos*/)            /*!< SCB CTR: ImInLine Mask */
N
N/* SCB Cache Size ID Register Definitions */
N#define SCB_CCSIDR_WT_Pos                  31U                                            /*!< SCB CCSIDR: WT Position */
N#define SCB_CCSIDR_WT_Msk                  (1UL << SCB_CCSIDR_WT_Pos)                     /*!< SCB CCSIDR: WT Mask */
N
N#define SCB_CCSIDR_WB_Pos                  30U                                            /*!< SCB CCSIDR: WB Position */
N#define SCB_CCSIDR_WB_Msk                  (1UL << SCB_CCSIDR_WB_Pos)                     /*!< SCB CCSIDR: WB Mask */
N
N#define SCB_CCSIDR_RA_Pos                  29U                                            /*!< SCB CCSIDR: RA Position */
N#define SCB_CCSIDR_RA_Msk                  (1UL << SCB_CCSIDR_RA_Pos)                     /*!< SCB CCSIDR: RA Mask */
N
N#define SCB_CCSIDR_WA_Pos                  28U                                            /*!< SCB CCSIDR: WA Position */
N#define SCB_CCSIDR_WA_Msk                  (1UL << SCB_CCSIDR_WA_Pos)                     /*!< SCB CCSIDR: WA Mask */
N
N#define SCB_CCSIDR_NUMSETS_Pos             13U                                            /*!< SCB CCSIDR: NumSets Position */
N#define SCB_CCSIDR_NUMSETS_Msk             (0x7FFFUL << SCB_CCSIDR_NUMSETS_Pos)           /*!< SCB CCSIDR: NumSets Mask */
N
N#define SCB_CCSIDR_ASSOCIATIVITY_Pos        3U                                            /*!< SCB CCSIDR: Associativity Position */
N#define SCB_CCSIDR_ASSOCIATIVITY_Msk       (0x3FFUL << SCB_CCSIDR_ASSOCIATIVITY_Pos)      /*!< SCB CCSIDR: Associativity Mask */
N
N#define SCB_CCSIDR_LINESIZE_Pos             0U                                            /*!< SCB CCSIDR: LineSize Position */
N#define SCB_CCSIDR_LINESIZE_Msk            (7UL /*<< SCB_CCSIDR_LINESIZE_Pos*/)           /*!< SCB CCSIDR: LineSize Mask */
N
N/* SCB Cache Size Selection Register Definitions */
N#define SCB_CSSELR_LEVEL_Pos                1U                                            /*!< SCB CSSELR: Level Position */
N#define SCB_CSSELR_LEVEL_Msk               (7UL << SCB_CSSELR_LEVEL_Pos)                  /*!< SCB CSSELR: Level Mask */
N
N#define SCB_CSSELR_IND_Pos                  0U                                            /*!< SCB CSSELR: InD Position */
N#define SCB_CSSELR_IND_Msk                 (1UL /*<< SCB_CSSELR_IND_Pos*/)                /*!< SCB CSSELR: InD Mask */
N
N/* SCB Software Triggered Interrupt Register Definitions */
N#define SCB_STIR_INTID_Pos                  0U                                            /*!< SCB STIR: INTID Position */
N#define SCB_STIR_INTID_Msk                 (0x1FFUL /*<< SCB_STIR_INTID_Pos*/)            /*!< SCB STIR: INTID Mask */
N
N/* SCB D-Cache Invalidate by Set-way Register Definitions */
N#define SCB_DCISW_WAY_Pos                  30U                                            /*!< SCB DCISW: Way Position */
N#define SCB_DCISW_WAY_Msk                  (3UL << SCB_DCISW_WAY_Pos)                     /*!< SCB DCISW: Way Mask */
N
N#define SCB_DCISW_SET_Pos                   5U                                            /*!< SCB DCISW: Set Position */
N#define SCB_DCISW_SET_Msk                  (0x1FFUL << SCB_DCISW_SET_Pos)                 /*!< SCB DCISW: Set Mask */
N
N/* SCB D-Cache Clean by Set-way Register Definitions */
N#define SCB_DCCSW_WAY_Pos                  30U                                            /*!< SCB DCCSW: Way Position */
N#define SCB_DCCSW_WAY_Msk                  (3UL << SCB_DCCSW_WAY_Pos)                     /*!< SCB DCCSW: Way Mask */
N
N#define SCB_DCCSW_SET_Pos                   5U                                            /*!< SCB DCCSW: Set Position */
N#define SCB_DCCSW_SET_Msk                  (0x1FFUL << SCB_DCCSW_SET_Pos)                 /*!< SCB DCCSW: Set Mask */
N
N/* SCB D-Cache Clean and Invalidate by Set-way Register Definitions */
N#define SCB_DCCISW_WAY_Pos                 30U                                            /*!< SCB DCCISW: Way Position */
N#define SCB_DCCISW_WAY_Msk                 (3UL << SCB_DCCISW_WAY_Pos)                    /*!< SCB DCCISW: Way Mask */
N
N#define SCB_DCCISW_SET_Pos                  5U                                            /*!< SCB DCCISW: Set Position */
N#define SCB_DCCISW_SET_Msk                 (0x1FFUL << SCB_DCCISW_SET_Pos)                /*!< SCB DCCISW: Set Mask */
N
N/* Instruction Tightly-Coupled Memory Control Register Definitions */
N#define SCB_ITCMCR_SZ_Pos                   3U                                            /*!< SCB ITCMCR: SZ Position */
N#define SCB_ITCMCR_SZ_Msk                  (0xFUL << SCB_ITCMCR_SZ_Pos)                   /*!< SCB ITCMCR: SZ Mask */
N
N#define SCB_ITCMCR_RETEN_Pos                2U                                            /*!< SCB ITCMCR: RETEN Position */
N#define SCB_ITCMCR_RETEN_Msk               (1UL << SCB_ITCMCR_RETEN_Pos)                  /*!< SCB ITCMCR: RETEN Mask */
N
N#define SCB_ITCMCR_RMW_Pos                  1U                                            /*!< SCB ITCMCR: RMW Position */
N#define SCB_ITCMCR_RMW_Msk                 (1UL << SCB_ITCMCR_RMW_Pos)                    /*!< SCB ITCMCR: RMW Mask */
N
N#define SCB_ITCMCR_EN_Pos                   0U                                            /*!< SCB ITCMCR: EN Position */
N#define SCB_ITCMCR_EN_Msk                  (1UL /*<< SCB_ITCMCR_EN_Pos*/)                 /*!< SCB ITCMCR: EN Mask */
N
N/* Data Tightly-Coupled Memory Control Register Definitions */
N#define SCB_DTCMCR_SZ_Pos                   3U                                            /*!< SCB DTCMCR: SZ Position */
N#define SCB_DTCMCR_SZ_Msk                  (0xFUL << SCB_DTCMCR_SZ_Pos)                   /*!< SCB DTCMCR: SZ Mask */
N
N#define SCB_DTCMCR_RETEN_Pos                2U                                            /*!< SCB DTCMCR: RETEN Position */
N#define SCB_DTCMCR_RETEN_Msk               (1UL << SCB_DTCMCR_RETEN_Pos)                   /*!< SCB DTCMCR: RETEN Mask */
N
N#define SCB_DTCMCR_RMW_Pos                  1U                                            /*!< SCB DTCMCR: RMW Position */
N#define SCB_DTCMCR_RMW_Msk                 (1UL << SCB_DTCMCR_RMW_Pos)                    /*!< SCB DTCMCR: RMW Mask */
N
N#define SCB_DTCMCR_EN_Pos                   0U                                            /*!< SCB DTCMCR: EN Position */
N#define SCB_DTCMCR_EN_Msk                  (1UL /*<< SCB_DTCMCR_EN_Pos*/)                 /*!< SCB DTCMCR: EN Mask */
N
N/* AHBP Control Register Definitions */
N#define SCB_AHBPCR_SZ_Pos                   1U                                            /*!< SCB AHBPCR: SZ Position */
N#define SCB_AHBPCR_SZ_Msk                  (7UL << SCB_AHBPCR_SZ_Pos)                     /*!< SCB AHBPCR: SZ Mask */
N
N#define SCB_AHBPCR_EN_Pos                   0U                                            /*!< SCB AHBPCR: EN Position */
N#define SCB_AHBPCR_EN_Msk                  (1UL /*<< SCB_AHBPCR_EN_Pos*/)                 /*!< SCB AHBPCR: EN Mask */
N
N/* L1 Cache Control Register Definitions */
N#define SCB_CACR_FORCEWT_Pos                2U                                            /*!< SCB CACR: FORCEWT Position */
N#define SCB_CACR_FORCEWT_Msk               (1UL << SCB_CACR_FORCEWT_Pos)                  /*!< SCB CACR: FORCEWT Mask */
N
N#define SCB_CACR_ECCEN_Pos                  1U                                            /*!< SCB CACR: ECCEN Position */
N#define SCB_CACR_ECCEN_Msk                 (1UL << SCB_CACR_ECCEN_Pos)                    /*!< SCB CACR: ECCEN Mask */
N
N#define SCB_CACR_SIWT_Pos                   0U                                            /*!< SCB CACR: SIWT Position */
N#define SCB_CACR_SIWT_Msk                  (1UL /*<< SCB_CACR_SIWT_Pos*/)                 /*!< SCB CACR: SIWT Mask */
N
N/* AHBS Control Register Definitions */
N#define SCB_AHBSCR_INITCOUNT_Pos           11U                                            /*!< SCB AHBSCR: INITCOUNT Position */
N#define SCB_AHBSCR_INITCOUNT_Msk           (0x1FUL << SCB_AHBPCR_INITCOUNT_Pos)           /*!< SCB AHBSCR: INITCOUNT Mask */
N
N#define SCB_AHBSCR_TPRI_Pos                 2U                                            /*!< SCB AHBSCR: TPRI Position */
N#define SCB_AHBSCR_TPRI_Msk                (0x1FFUL << SCB_AHBPCR_TPRI_Pos)               /*!< SCB AHBSCR: TPRI Mask */
N
N#define SCB_AHBSCR_CTL_Pos                  0U                                            /*!< SCB AHBSCR: CTL Position*/
N#define SCB_AHBSCR_CTL_Msk                 (3UL /*<< SCB_AHBPCR_CTL_Pos*/)                /*!< SCB AHBSCR: CTL Mask */
N
N/* Auxiliary Bus Fault Status Register Definitions */
N#define SCB_ABFSR_AXIMTYPE_Pos              8U                                            /*!< SCB ABFSR: AXIMTYPE Position*/
N#define SCB_ABFSR_AXIMTYPE_Msk             (3UL << SCB_ABFSR_AXIMTYPE_Pos)                /*!< SCB ABFSR: AXIMTYPE Mask */
N
N#define SCB_ABFSR_EPPB_Pos                  4U                                            /*!< SCB ABFSR: EPPB Position*/
N#define SCB_ABFSR_EPPB_Msk                 (1UL << SCB_ABFSR_EPPB_Pos)                    /*!< SCB ABFSR: EPPB Mask */
N
N#define SCB_ABFSR_AXIM_Pos                  3U                                            /*!< SCB ABFSR: AXIM Position*/
N#define SCB_ABFSR_AXIM_Msk                 (1UL << SCB_ABFSR_AXIM_Pos)                    /*!< SCB ABFSR: AXIM Mask */
N
N#define SCB_ABFSR_AHBP_Pos                  2U                                            /*!< SCB ABFSR: AHBP Position*/
N#define SCB_ABFSR_AHBP_Msk                 (1UL << SCB_ABFSR_AHBP_Pos)                    /*!< SCB ABFSR: AHBP Mask */
N
N#define SCB_ABFSR_DTCM_Pos                  1U                                            /*!< SCB ABFSR: DTCM Position*/
N#define SCB_ABFSR_DTCM_Msk                 (1UL << SCB_ABFSR_DTCM_Pos)                    /*!< SCB ABFSR: DTCM Mask */
N
N#define SCB_ABFSR_ITCM_Pos                  0U                                            /*!< SCB ABFSR: ITCM Position*/
N#define SCB_ABFSR_ITCM_Msk                 (1UL /*<< SCB_ABFSR_ITCM_Pos*/)                /*!< SCB ABFSR: ITCM Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
N  \brief    Type definitions for the System Control and ID Register not in the SCB
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control and ID Register not in the SCB.
N */
Ntypedef struct
N{
N        uint32_t RESERVED0[1U];
N  __IM  uint32_t ICTR;                   /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register */
X  volatile const  uint32_t ICTR;                    
N  __IOM uint32_t ACTLR;                  /*!< Offset: 0x008 (R/W)  Auxiliary Control Register */
X  volatile uint32_t ACTLR;                   
N} SCnSCB_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define SCnSCB_ICTR_INTLINESNUM_Pos         0U                                         /*!< ICTR: INTLINESNUM Position */
N#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N#define SCnSCB_ACTLR_DISITMATBFLUSH_Pos    12U                                         /*!< ACTLR: DISITMATBFLUSH Position */
N#define SCnSCB_ACTLR_DISITMATBFLUSH_Msk    (1UL << SCnSCB_ACTLR_DISITMATBFLUSH_Pos)    /*!< ACTLR: DISITMATBFLUSH Mask */
N
N#define SCnSCB_ACTLR_DISRAMODE_Pos         11U                                         /*!< ACTLR: DISRAMODE Position */
N#define SCnSCB_ACTLR_DISRAMODE_Msk         (1UL << SCnSCB_ACTLR_DISRAMODE_Pos)         /*!< ACTLR: DISRAMODE Mask */
N
N#define SCnSCB_ACTLR_FPEXCODIS_Pos         10U                                         /*!< ACTLR: FPEXCODIS Position */
N#define SCnSCB_ACTLR_FPEXCODIS_Msk         (1UL << SCnSCB_ACTLR_FPEXCODIS_Pos)         /*!< ACTLR: FPEXCODIS Mask */
N
N#define SCnSCB_ACTLR_DISFOLD_Pos            2U                                         /*!< ACTLR: DISFOLD Position */
N#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
N
N#define SCnSCB_ACTLR_DISMCYCINT_Pos         0U                                         /*!< ACTLR: DISMCYCINT Position */
N#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL /*<< SCnSCB_ACTLR_DISMCYCINT_Pos*/)    /*!< ACTLR: DISMCYCINT Mask */
N
N/*@} end of group CMSIS_SCnotSCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X  volatile uint32_t LOAD;                    
N  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X  volatile uint32_t VAL;                     
N  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X  volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
N  \brief    Type definitions for the Instrumentation Trace Macrocell (ITM)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
N */
Ntypedef struct
N{
N  __OM  union
X  volatile  union
N  {
N    __OM  uint8_t    u8;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit */
X    volatile  uint8_t    u8;                  
N    __OM  uint16_t   u16;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit */
X    volatile  uint16_t   u16;                 
N    __OM  uint32_t   u32;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit */
X    volatile  uint32_t   u32;                 
N  }  PORT [32U];                         /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers */
N        uint32_t RESERVED0[864U];
N  __IOM uint32_t TER;                    /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register */
X  volatile uint32_t TER;                     
N        uint32_t RESERVED1[15U];
N  __IOM uint32_t TPR;                    /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register */
X  volatile uint32_t TPR;                     
N        uint32_t RESERVED2[15U];
N  __IOM uint32_t TCR;                    /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register */
X  volatile uint32_t TCR;                     
N        uint32_t RESERVED3[29U];
N  __OM  uint32_t IWR;                    /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register */
X  volatile  uint32_t IWR;                     
N  __IM  uint32_t IRR;                    /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register */
X  volatile const  uint32_t IRR;                     
N  __IOM uint32_t IMCR;                   /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register */
X  volatile uint32_t IMCR;                    
N        uint32_t RESERVED4[43U];
N  __OM  uint32_t LAR;                    /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register */
X  volatile  uint32_t LAR;                     
N  __IM  uint32_t LSR;                    /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register */
X  volatile const  uint32_t LSR;                     
N        uint32_t RESERVED5[6U];
N  __IM  uint32_t PID4;                   /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
X  volatile const  uint32_t PID4;                    
N  __IM  uint32_t PID5;                   /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
X  volatile const  uint32_t PID5;                    
N  __IM  uint32_t PID6;                   /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
X  volatile const  uint32_t PID6;                    
N  __IM  uint32_t PID7;                   /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
X  volatile const  uint32_t PID7;                    
N  __IM  uint32_t PID0;                   /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
X  volatile const  uint32_t PID0;                    
N  __IM  uint32_t PID1;                   /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
X  volatile const  uint32_t PID1;                    
N  __IM  uint32_t PID2;                   /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
X  volatile const  uint32_t PID2;                    
N  __IM  uint32_t PID3;                   /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
X  volatile const  uint32_t PID3;                    
N  __IM  uint32_t CID0;                   /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
X  volatile const  uint32_t CID0;                    
N  __IM  uint32_t CID1;                   /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
X  volatile const  uint32_t CID1;                    
N  __IM  uint32_t CID2;                   /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
X  volatile const  uint32_t CID2;                    
N  __IM  uint32_t CID3;                   /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
X  volatile const  uint32_t CID3;                    
N} ITM_Type;
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0U                                            /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFUL /*<< ITM_TPR_PRIVMASK_Pos*/)            /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23U                                            /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_TraceBusID_Pos             16U                                            /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_GTSFREQ_Pos                10U                                            /*!< ITM TCR: Global timestamp frequency Position */
N#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8U                                            /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4U                                            /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_DWTENA_Pos                  3U                                            /*!< ITM TCR: DWTENA Position */
N#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2U                                            /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1U                                            /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0U                                            /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1UL /*<< ITM_TCR_ITMENA_Pos*/)                /*!< ITM TCR: ITM Enable bit Mask */
N
N/* ITM Integration Write Register Definitions */
N#define ITM_IWR_ATVALIDM_Pos                0U                                            /*!< ITM IWR: ATVALIDM Position */
N#define ITM_IWR_ATVALIDM_Msk               (1UL /*<< ITM_IWR_ATVALIDM_Pos*/)              /*!< ITM IWR: ATVALIDM Mask */
N
N/* ITM Integration Read Register Definitions */
N#define ITM_IRR_ATREADYM_Pos                0U                                            /*!< ITM IRR: ATREADYM Position */
N#define ITM_IRR_ATREADYM_Msk               (1UL /*<< ITM_IRR_ATREADYM_Pos*/)              /*!< ITM IRR: ATREADYM Mask */
N
N/* ITM Integration Mode Control Register Definitions */
N#define ITM_IMCR_INTEGRATION_Pos            0U                                            /*!< ITM IMCR: INTEGRATION Position */
N#define ITM_IMCR_INTEGRATION_Msk           (1UL /*<< ITM_IMCR_INTEGRATION_Pos*/)          /*!< ITM IMCR: INTEGRATION Mask */
N
N/* ITM Lock Status Register Definitions */
N#define ITM_LSR_ByteAcc_Pos                 2U                                            /*!< ITM LSR: ByteAcc Position */
N#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
N
N#define ITM_LSR_Access_Pos                  1U                                            /*!< ITM LSR: Access Position */
N#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
N
N#define ITM_LSR_Present_Pos                 0U                                            /*!< ITM LSR: Present Position */
N#define ITM_LSR_Present_Msk                (1UL /*<< ITM_LSR_Present_Pos*/)               /*!< ITM LSR: Present Mask */
N
N/*@}*/ /* end of group CMSIS_ITM */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
N  \brief    Type definitions for the Data Watchpoint and Trace (DWT)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  Control Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t CYCCNT;                 /*!< Offset: 0x004 (R/W)  Cycle Count Register */
X  volatile uint32_t CYCCNT;                  
N  __IOM uint32_t CPICNT;                 /*!< Offset: 0x008 (R/W)  CPI Count Register */
X  volatile uint32_t CPICNT;                  
N  __IOM uint32_t EXCCNT;                 /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register */
X  volatile uint32_t EXCCNT;                  
N  __IOM uint32_t SLEEPCNT;               /*!< Offset: 0x010 (R/W)  Sleep Count Register */
X  volatile uint32_t SLEEPCNT;                
N  __IOM uint32_t LSUCNT;                 /*!< Offset: 0x014 (R/W)  LSU Count Register */
X  volatile uint32_t LSUCNT;                  
N  __IOM uint32_t FOLDCNT;                /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register */
X  volatile uint32_t FOLDCNT;                 
N  __IM  uint32_t PCSR;                   /*!< Offset: 0x01C (R/ )  Program Counter Sample Register */
X  volatile const  uint32_t PCSR;                    
N  __IOM uint32_t COMP0;                  /*!< Offset: 0x020 (R/W)  Comparator Register 0 */
X  volatile uint32_t COMP0;                   
N  __IOM uint32_t MASK0;                  /*!< Offset: 0x024 (R/W)  Mask Register 0 */
X  volatile uint32_t MASK0;                   
N  __IOM uint32_t FUNCTION0;              /*!< Offset: 0x028 (R/W)  Function Register 0 */
X  volatile uint32_t FUNCTION0;               
N        uint32_t RESERVED0[1U];
N  __IOM uint32_t COMP1;                  /*!< Offset: 0x030 (R/W)  Comparator Register 1 */
X  volatile uint32_t COMP1;                   
N  __IOM uint32_t MASK1;                  /*!< Offset: 0x034 (R/W)  Mask Register 1 */
X  volatile uint32_t MASK1;                   
N  __IOM uint32_t FUNCTION1;              /*!< Offset: 0x038 (R/W)  Function Register 1 */
X  volatile uint32_t FUNCTION1;               
N        uint32_t RESERVED1[1U];
N  __IOM uint32_t COMP2;                  /*!< Offset: 0x040 (R/W)  Comparator Register 2 */
X  volatile uint32_t COMP2;                   
N  __IOM uint32_t MASK2;                  /*!< Offset: 0x044 (R/W)  Mask Register 2 */
X  volatile uint32_t MASK2;                   
N  __IOM uint32_t FUNCTION2;              /*!< Offset: 0x048 (R/W)  Function Register 2 */
X  volatile uint32_t FUNCTION2;               
N        uint32_t RESERVED2[1U];
N  __IOM uint32_t COMP3;                  /*!< Offset: 0x050 (R/W)  Comparator Register 3 */
X  volatile uint32_t COMP3;                   
N  __IOM uint32_t MASK3;                  /*!< Offset: 0x054 (R/W)  Mask Register 3 */
X  volatile uint32_t MASK3;                   
N  __IOM uint32_t FUNCTION3;              /*!< Offset: 0x058 (R/W)  Function Register 3 */
X  volatile uint32_t FUNCTION3;               
N        uint32_t RESERVED3[981U];
N  __OM  uint32_t LAR;                    /*!< Offset: 0xFB0 (  W)  Lock Access Register */
X  volatile  uint32_t LAR;                     
N  __IM  uint32_t LSR;                    /*!< Offset: 0xFB4 (R  )  Lock Status Register */
X  volatile const  uint32_t LSR;                     
N} DWT_Type;
N
N/* DWT Control Register Definitions */
N#define DWT_CTRL_NUMCOMP_Pos               28U                                         /*!< DWT CTRL: NUMCOMP Position */
N#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
N
N#define DWT_CTRL_NOTRCPKT_Pos              27U                                         /*!< DWT CTRL: NOTRCPKT Position */
N#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
N
N#define DWT_CTRL_NOEXTTRIG_Pos             26U                                         /*!< DWT CTRL: NOEXTTRIG Position */
N#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
N
N#define DWT_CTRL_NOCYCCNT_Pos              25U                                         /*!< DWT CTRL: NOCYCCNT Position */
N#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
N
N#define DWT_CTRL_NOPRFCNT_Pos              24U                                         /*!< DWT CTRL: NOPRFCNT Position */
N#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
N
N#define DWT_CTRL_CYCEVTENA_Pos             22U                                         /*!< DWT CTRL: CYCEVTENA Position */
N#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
N
N#define DWT_CTRL_FOLDEVTENA_Pos            21U                                         /*!< DWT CTRL: FOLDEVTENA Position */
N#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
N
N#define DWT_CTRL_LSUEVTENA_Pos             20U                                         /*!< DWT CTRL: LSUEVTENA Position */
N#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
N
N#define DWT_CTRL_SLEEPEVTENA_Pos           19U                                         /*!< DWT CTRL: SLEEPEVTENA Position */
N#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
N
N#define DWT_CTRL_EXCEVTENA_Pos             18U                                         /*!< DWT CTRL: EXCEVTENA Position */
N#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
N
N#define DWT_CTRL_CPIEVTENA_Pos             17U                                         /*!< DWT CTRL: CPIEVTENA Position */
N#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
N
N#define DWT_CTRL_EXCTRCENA_Pos             16U                                         /*!< DWT CTRL: EXCTRCENA Position */
N#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
N
N#define DWT_CTRL_PCSAMPLENA_Pos            12U                                         /*!< DWT CTRL: PCSAMPLENA Position */
N#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
N
N#define DWT_CTRL_SYNCTAP_Pos               10U                                         /*!< DWT CTRL: SYNCTAP Position */
N#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
N
N#define DWT_CTRL_CYCTAP_Pos                 9U                                         /*!< DWT CTRL: CYCTAP Position */
N#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
N
N#define DWT_CTRL_POSTINIT_Pos               5U                                         /*!< DWT CTRL: POSTINIT Position */
N#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
N
N#define DWT_CTRL_POSTPRESET_Pos             1U                                         /*!< DWT CTRL: POSTPRESET Position */
N#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
N
N#define DWT_CTRL_CYCCNTENA_Pos              0U                                         /*!< DWT CTRL: CYCCNTENA Position */
N#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL /*<< DWT_CTRL_CYCCNTENA_Pos*/)       /*!< DWT CTRL: CYCCNTENA Mask */
N
N/* DWT CPI Count Register Definitions */
N#define DWT_CPICNT_CPICNT_Pos               0U                                         /*!< DWT CPICNT: CPICNT Position */
N#define DWT_CPICNT_CPICNT_Msk              (0xFFUL /*<< DWT_CPICNT_CPICNT_Pos*/)       /*!< DWT CPICNT: CPICNT Mask */
N
N/* DWT Exception Overhead Count Register Definitions */
N#define DWT_EXCCNT_EXCCNT_Pos               0U                                         /*!< DWT EXCCNT: EXCCNT Position */
N#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL /*<< DWT_EXCCNT_EXCCNT_Pos*/)       /*!< DWT EXCCNT: EXCCNT Mask */
N
N/* DWT Sleep Count Register Definitions */
N#define DWT_SLEEPCNT_SLEEPCNT_Pos           0U                                         /*!< DWT SLEEPCNT: SLEEPCNT Position */
N#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL /*<< DWT_SLEEPCNT_SLEEPCNT_Pos*/)   /*!< DWT SLEEPCNT: SLEEPCNT Mask */
N
N/* DWT LSU Count Register Definitions */
N#define DWT_LSUCNT_LSUCNT_Pos               0U                                         /*!< DWT LSUCNT: LSUCNT Position */
N#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL /*<< DWT_LSUCNT_LSUCNT_Pos*/)       /*!< DWT LSUCNT: LSUCNT Mask */
N
N/* DWT Folded-instruction Count Register Definitions */
N#define DWT_FOLDCNT_FOLDCNT_Pos             0U                                         /*!< DWT FOLDCNT: FOLDCNT Position */
N#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL /*<< DWT_FOLDCNT_FOLDCNT_Pos*/)     /*!< DWT FOLDCNT: FOLDCNT Mask */
N
N/* DWT Comparator Mask Register Definitions */
N#define DWT_MASK_MASK_Pos                   0U                                         /*!< DWT MASK: MASK Position */
N#define DWT_MASK_MASK_Msk                  (0x1FUL /*<< DWT_MASK_MASK_Pos*/)           /*!< DWT MASK: MASK Mask */
N
N/* DWT Comparator Function Register Definitions */
N#define DWT_FUNCTION_MATCHED_Pos           24U                                         /*!< DWT FUNCTION: MATCHED Position */
N#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
N
N#define DWT_FUNCTION_DATAVADDR1_Pos        16U                                         /*!< DWT FUNCTION: DATAVADDR1 Position */
N#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
N
N#define DWT_FUNCTION_DATAVADDR0_Pos        12U                                         /*!< DWT FUNCTION: DATAVADDR0 Position */
N#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
N
N#define DWT_FUNCTION_DATAVSIZE_Pos         10U                                         /*!< DWT FUNCTION: DATAVSIZE Position */
N#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
N
N#define DWT_FUNCTION_LNK1ENA_Pos            9U                                         /*!< DWT FUNCTION: LNK1ENA Position */
N#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
N
N#define DWT_FUNCTION_DATAVMATCH_Pos         8U                                         /*!< DWT FUNCTION: DATAVMATCH Position */
N#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
N
N#define DWT_FUNCTION_CYCMATCH_Pos           7U                                         /*!< DWT FUNCTION: CYCMATCH Position */
N#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
N
N#define DWT_FUNCTION_EMITRANGE_Pos          5U                                         /*!< DWT FUNCTION: EMITRANGE Position */
N#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
N
N#define DWT_FUNCTION_FUNCTION_Pos           0U                                         /*!< DWT FUNCTION: FUNCTION Position */
N#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL /*<< DWT_FUNCTION_FUNCTION_Pos*/)    /*!< DWT FUNCTION: FUNCTION Mask */
N
N/*@}*/ /* end of group CMSIS_DWT */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_TPI     Trace Port Interface (TPI)
N  \brief    Type definitions for the Trace Port Interface (TPI)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Trace Port Interface Register (TPI).
N */
Ntypedef struct
N{
N  __IOM uint32_t SSPSR;                  /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register */
X  volatile uint32_t SSPSR;                   
N  __IOM uint32_t CSPSR;                  /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
X  volatile uint32_t CSPSR;                   
N        uint32_t RESERVED0[2U];
N  __IOM uint32_t ACPR;                   /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
X  volatile uint32_t ACPR;                    
N        uint32_t RESERVED1[55U];
N  __IOM uint32_t SPPR;                   /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
X  volatile uint32_t SPPR;                    
N        uint32_t RESERVED2[131U];
N  __IM  uint32_t FFSR;                   /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
X  volatile const  uint32_t FFSR;                    
N  __IOM uint32_t FFCR;                   /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
X  volatile uint32_t FFCR;                    
N  __IM  uint32_t FSCR;                   /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
X  volatile const  uint32_t FSCR;                    
N        uint32_t RESERVED3[759U];
N  __IM  uint32_t TRIGGER;                /*!< Offset: 0xEE8 (R/ )  TRIGGER */
X  volatile const  uint32_t TRIGGER;                 
N  __IM  uint32_t FIFO0;                  /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
X  volatile const  uint32_t FIFO0;                   
N  __IM  uint32_t ITATBCTR2;              /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
X  volatile const  uint32_t ITATBCTR2;               
N        uint32_t RESERVED4[1U];
N  __IM  uint32_t ITATBCTR0;              /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
X  volatile const  uint32_t ITATBCTR0;               
N  __IM  uint32_t FIFO1;                  /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
X  volatile const  uint32_t FIFO1;                   
N  __IOM uint32_t ITCTRL;                 /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
X  volatile uint32_t ITCTRL;                  
N        uint32_t RESERVED5[39U];
N  __IOM uint32_t CLAIMSET;               /*!< Offset: 0xFA0 (R/W)  Claim tag set */
X  volatile uint32_t CLAIMSET;                
N  __IOM uint32_t CLAIMCLR;               /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
X  volatile uint32_t CLAIMCLR;                
N        uint32_t RESERVED7[8U];
N  __IM  uint32_t DEVID;                  /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
X  volatile const  uint32_t DEVID;                   
N  __IM  uint32_t DEVTYPE;                /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
X  volatile const  uint32_t DEVTYPE;                 
N} TPI_Type;
N
N/* TPI Asynchronous Clock Prescaler Register Definitions */
N#define TPI_ACPR_PRESCALER_Pos              0U                                         /*!< TPI ACPR: PRESCALER Position */
N#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL /*<< TPI_ACPR_PRESCALER_Pos*/)    /*!< TPI ACPR: PRESCALER Mask */
N
N/* TPI Selected Pin Protocol Register Definitions */
N#define TPI_SPPR_TXMODE_Pos                 0U                                         /*!< TPI SPPR: TXMODE Position */
N#define TPI_SPPR_TXMODE_Msk                (0x3UL /*<< TPI_SPPR_TXMODE_Pos*/)          /*!< TPI SPPR: TXMODE Mask */
N
N/* TPI Formatter and Flush Status Register Definitions */
N#define TPI_FFSR_FtNonStop_Pos              3U                                         /*!< TPI FFSR: FtNonStop Position */
N#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
N
N#define TPI_FFSR_TCPresent_Pos              2U                                         /*!< TPI FFSR: TCPresent Position */
N#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
N
N#define TPI_FFSR_FtStopped_Pos              1U                                         /*!< TPI FFSR: FtStopped Position */
N#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
N
N#define TPI_FFSR_FlInProg_Pos               0U                                         /*!< TPI FFSR: FlInProg Position */
N#define TPI_FFSR_FlInProg_Msk              (0x1UL /*<< TPI_FFSR_FlInProg_Pos*/)        /*!< TPI FFSR: FlInProg Mask */
N
N/* TPI Formatter and Flush Control Register Definitions */
N#define TPI_FFCR_TrigIn_Pos                 8U                                         /*!< TPI FFCR: TrigIn Position */
N#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
N
N#define TPI_FFCR_EnFCont_Pos                1U                                         /*!< TPI FFCR: EnFCont Position */
N#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
N
N/* TPI TRIGGER Register Definitions */
N#define TPI_TRIGGER_TRIGGER_Pos             0U                                         /*!< TPI TRIGGER: TRIGGER Position */
N#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL /*<< TPI_TRIGGER_TRIGGER_Pos*/)      /*!< TPI TRIGGER: TRIGGER Mask */
N
N/* TPI Integration ETM Data Register Definitions (FIFO0) */
N#define TPI_FIFO0_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO0: ITM_ATVALID Position */
N#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
N
N#define TPI_FIFO0_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO0: ITM_bytecount Position */
N#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
N
N#define TPI_FIFO0_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO0: ETM_ATVALID Position */
N#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
N
N#define TPI_FIFO0_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO0: ETM_bytecount Position */
N#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
N
N#define TPI_FIFO0_ETM2_Pos                 16U                                         /*!< TPI FIFO0: ETM2 Position */
N#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
N
N#define TPI_FIFO0_ETM1_Pos                  8U                                         /*!< TPI FIFO0: ETM1 Position */
N#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
N
N#define TPI_FIFO0_ETM0_Pos                  0U                                         /*!< TPI FIFO0: ETM0 Position */
N#define TPI_FIFO0_ETM0_Msk                 (0xFFUL /*<< TPI_FIFO0_ETM0_Pos*/)          /*!< TPI FIFO0: ETM0 Mask */
N
N/* TPI ITATBCTR2 Register Definitions */
N#define TPI_ITATBCTR2_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR2: ATREADY Position */
N#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR2_ATREADY_Pos*/)    /*!< TPI ITATBCTR2: ATREADY Mask */
N
N/* TPI Integration ITM Data Register Definitions (FIFO1) */
N#define TPI_FIFO1_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO1: ITM_ATVALID Position */
N#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
N
N#define TPI_FIFO1_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO1: ITM_bytecount Position */
N#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
N
N#define TPI_FIFO1_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO1: ETM_ATVALID Position */
N#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
N
N#define TPI_FIFO1_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO1: ETM_bytecount Position */
N#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
N
N#define TPI_FIFO1_ITM2_Pos                 16U                                         /*!< TPI FIFO1: ITM2 Position */
N#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
N
N#define TPI_FIFO1_ITM1_Pos                  8U                                         /*!< TPI FIFO1: ITM1 Position */
N#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
N
N#define TPI_FIFO1_ITM0_Pos                  0U                                         /*!< TPI FIFO1: ITM0 Position */
N#define TPI_FIFO1_ITM0_Msk                 (0xFFUL /*<< TPI_FIFO1_ITM0_Pos*/)          /*!< TPI FIFO1: ITM0 Mask */
N
N/* TPI ITATBCTR0 Register Definitions */
N#define TPI_ITATBCTR0_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR0: ATREADY Position */
N#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR0_ATREADY_Pos*/)    /*!< TPI ITATBCTR0: ATREADY Mask */
N
N/* TPI Integration Mode Control Register Definitions */
N#define TPI_ITCTRL_Mode_Pos                 0U                                         /*!< TPI ITCTRL: Mode Position */
N#define TPI_ITCTRL_Mode_Msk                (0x1UL /*<< TPI_ITCTRL_Mode_Pos*/)          /*!< TPI ITCTRL: Mode Mask */
N
N/* TPI DEVID Register Definitions */
N#define TPI_DEVID_NRZVALID_Pos             11U                                         /*!< TPI DEVID: NRZVALID Position */
N#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
N
N#define TPI_DEVID_MANCVALID_Pos            10U                                         /*!< TPI DEVID: MANCVALID Position */
N#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
N
N#define TPI_DEVID_PTINVALID_Pos             9U                                         /*!< TPI DEVID: PTINVALID Position */
N#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
N
N#define TPI_DEVID_MinBufSz_Pos              6U                                         /*!< TPI DEVID: MinBufSz Position */
N#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
N
N#define TPI_DEVID_AsynClkIn_Pos             5U                                         /*!< TPI DEVID: AsynClkIn Position */
N#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
N
N#define TPI_DEVID_NrTraceInput_Pos          0U                                         /*!< TPI DEVID: NrTraceInput Position */
N#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL /*<< TPI_DEVID_NrTraceInput_Pos*/)  /*!< TPI DEVID: NrTraceInput Mask */
N
N/* TPI DEVTYPE Register Definitions */
N#define TPI_DEVTYPE_MajorType_Pos           4U                                         /*!< TPI DEVTYPE: MajorType Position */
N#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
N
N#define TPI_DEVTYPE_SubType_Pos             0U                                         /*!< TPI DEVTYPE: SubType Position */
N#define TPI_DEVTYPE_SubType_Msk            (0xFUL /*<< TPI_DEVTYPE_SubType_Pos*/)      /*!< TPI DEVTYPE: SubType Mask */
N
N/*@}*/ /* end of group CMSIS_TPI */
N
N
N#if (__MPU_PRESENT == 1U)
X#if (1 == 1U)
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
N  \brief    Type definitions for the Memory Protection Unit (MPU)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Memory Protection Unit (MPU).
N */
Ntypedef struct
N{
N  __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
X  volatile const  uint32_t TYPE;                    
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
X  volatile uint32_t RNR;                     
N  __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register */
X  volatile uint32_t RBAR;                    
N  __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register */
X  volatile uint32_t RASR;                    
N  __IOM uint32_t RBAR_A1;                /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register */
X  volatile uint32_t RBAR_A1;                 
N  __IOM uint32_t RASR_A1;                /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
X  volatile uint32_t RASR_A1;                 
N  __IOM uint32_t RBAR_A2;                /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register */
X  volatile uint32_t RBAR_A2;                 
N  __IOM uint32_t RASR_A2;                /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
X  volatile uint32_t RASR_A2;                 
N  __IOM uint32_t RBAR_A3;                /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register */
X  volatile uint32_t RBAR_A3;                 
N  __IOM uint32_t RASR_A3;                /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
X  volatile uint32_t RASR_A3;                 
N} MPU_Type;
N
N/* MPU Type Register Definitions */
N#define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU TYPE: IREGION Position */
N#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
N
N#define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU TYPE: DREGION Position */
N#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
N
N#define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU TYPE: SEPARATE Position */
N#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
N
N/* MPU Control Register Definitions */
N#define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU CTRL: PRIVDEFENA Position */
N#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
N
N#define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU CTRL: HFNMIENA Position */
N#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
N
N#define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU CTRL: ENABLE Position */
N#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
N
N/* MPU Region Number Register Definitions */
N#define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU RNR: REGION Position */
N#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
N
N/* MPU Region Base Address Register Definitions */
N#define MPU_RBAR_ADDR_Pos                   5U                                            /*!< MPU RBAR: ADDR Position */
N#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
N
N#define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU RBAR: VALID Position */
N#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
N
N#define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU RBAR: REGION Position */
N#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
N
N/* MPU Region Attribute and Size Register Definitions */
N#define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU RASR: MPU Region Attribute field Position */
N#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
N
N#define MPU_RASR_XN_Pos                    28U                                            /*!< MPU RASR: ATTRS.XN Position */
N#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
N
N#define MPU_RASR_AP_Pos                    24U                                            /*!< MPU RASR: ATTRS.AP Position */
N#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
N
N#define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU RASR: ATTRS.TEX Position */
N#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
N
N#define MPU_RASR_S_Pos                     18U                                            /*!< MPU RASR: ATTRS.S Position */
N#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
N
N#define MPU_RASR_C_Pos                     17U                                            /*!< MPU RASR: ATTRS.C Position */
N#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
N
N#define MPU_RASR_B_Pos                     16U                                            /*!< MPU RASR: ATTRS.B Position */
N#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
N
N#define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU RASR: Sub-Region Disable Position */
N#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
N
N#define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU RASR: Region Size Field Position */
N#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
N
N#define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU RASR: Region enable bit Position */
N#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
N
N/*@} end of group CMSIS_MPU */
N#endif
N
N
N#if (__FPU_PRESENT == 1U)
X#if (1 == 1U)
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_FPU     Floating Point Unit (FPU)
N  \brief    Type definitions for the Floating Point Unit (FPU)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Floating Point Unit (FPU).
N */
Ntypedef struct
N{
N        uint32_t RESERVED0[1U];
N  __IOM uint32_t FPCCR;                  /*!< Offset: 0x004 (R/W)  Floating-Point Context Control Register */
X  volatile uint32_t FPCCR;                   
N  __IOM uint32_t FPCAR;                  /*!< Offset: 0x008 (R/W)  Floating-Point Context Address Register */
X  volatile uint32_t FPCAR;                   
N  __IOM uint32_t FPDSCR;                 /*!< Offset: 0x00C (R/W)  Floating-Point Default Status Control Register */
X  volatile uint32_t FPDSCR;                  
N  __IM  uint32_t MVFR0;                  /*!< Offset: 0x010 (R/ )  Media and FP Feature Register 0 */
X  volatile const  uint32_t MVFR0;                   
N  __IM  uint32_t MVFR1;                  /*!< Offset: 0x014 (R/ )  Media and FP Feature Register 1 */
X  volatile const  uint32_t MVFR1;                   
N  __IM  uint32_t MVFR2;                  /*!< Offset: 0x018 (R/ )  Media and FP Feature Register 2 */
X  volatile const  uint32_t MVFR2;                   
N} FPU_Type;
N
N/* Floating-Point Context Control Register Definitions */
N#define FPU_FPCCR_ASPEN_Pos                31U                                            /*!< FPCCR: ASPEN bit Position */
N#define FPU_FPCCR_ASPEN_Msk                (1UL << FPU_FPCCR_ASPEN_Pos)                   /*!< FPCCR: ASPEN bit Mask */
N
N#define FPU_FPCCR_LSPEN_Pos                30U                                            /*!< FPCCR: LSPEN Position */
N#define FPU_FPCCR_LSPEN_Msk                (1UL << FPU_FPCCR_LSPEN_Pos)                   /*!< FPCCR: LSPEN bit Mask */
N
N#define FPU_FPCCR_MONRDY_Pos                8U                                            /*!< FPCCR: MONRDY Position */
N#define FPU_FPCCR_MONRDY_Msk               (1UL << FPU_FPCCR_MONRDY_Pos)                  /*!< FPCCR: MONRDY bit Mask */
N
N#define FPU_FPCCR_BFRDY_Pos                 6U                                            /*!< FPCCR: BFRDY Position */
N#define FPU_FPCCR_BFRDY_Msk                (1UL << FPU_FPCCR_BFRDY_Pos)                   /*!< FPCCR: BFRDY bit Mask */
N
N#define FPU_FPCCR_MMRDY_Pos                 5U                                            /*!< FPCCR: MMRDY Position */
N#define FPU_FPCCR_MMRDY_Msk                (1UL << FPU_FPCCR_MMRDY_Pos)                   /*!< FPCCR: MMRDY bit Mask */
N
N#define FPU_FPCCR_HFRDY_Pos                 4U                                            /*!< FPCCR: HFRDY Position */
N#define FPU_FPCCR_HFRDY_Msk                (1UL << FPU_FPCCR_HFRDY_Pos)                   /*!< FPCCR: HFRDY bit Mask */
N
N#define FPU_FPCCR_THREAD_Pos                3U                                            /*!< FPCCR: processor mode bit Position */
N#define FPU_FPCCR_THREAD_Msk               (1UL << FPU_FPCCR_THREAD_Pos)                  /*!< FPCCR: processor mode active bit Mask */
N
N#define FPU_FPCCR_USER_Pos                  1U                                            /*!< FPCCR: privilege level bit Position */
N#define FPU_FPCCR_USER_Msk                 (1UL << FPU_FPCCR_USER_Pos)                    /*!< FPCCR: privilege level bit Mask */
N
N#define FPU_FPCCR_LSPACT_Pos                0U                                            /*!< FPCCR: Lazy state preservation active bit Position */
N#define FPU_FPCCR_LSPACT_Msk               (1UL /*<< FPU_FPCCR_LSPACT_Pos*/)              /*!< FPCCR: Lazy state preservation active bit Mask */
N
N/* Floating-Point Context Address Register Definitions */
N#define FPU_FPCAR_ADDRESS_Pos               3U                                            /*!< FPCAR: ADDRESS bit Position */
N#define FPU_FPCAR_ADDRESS_Msk              (0x1FFFFFFFUL << FPU_FPCAR_ADDRESS_Pos)        /*!< FPCAR: ADDRESS bit Mask */
N
N/* Floating-Point Default Status Control Register Definitions */
N#define FPU_FPDSCR_AHP_Pos                 26U                                            /*!< FPDSCR: AHP bit Position */
N#define FPU_FPDSCR_AHP_Msk                 (1UL << FPU_FPDSCR_AHP_Pos)                    /*!< FPDSCR: AHP bit Mask */
N
N#define FPU_FPDSCR_DN_Pos                  25U                                            /*!< FPDSCR: DN bit Position */
N#define FPU_FPDSCR_DN_Msk                  (1UL << FPU_FPDSCR_DN_Pos)                     /*!< FPDSCR: DN bit Mask */
N
N#define FPU_FPDSCR_FZ_Pos                  24U                                            /*!< FPDSCR: FZ bit Position */
N#define FPU_FPDSCR_FZ_Msk                  (1UL << FPU_FPDSCR_FZ_Pos)                     /*!< FPDSCR: FZ bit Mask */
N
N#define FPU_FPDSCR_RMode_Pos               22U                                            /*!< FPDSCR: RMode bit Position */
N#define FPU_FPDSCR_RMode_Msk               (3UL << FPU_FPDSCR_RMode_Pos)                  /*!< FPDSCR: RMode bit Mask */
N
N/* Media and FP Feature Register 0 Definitions */
N#define FPU_MVFR0_FP_rounding_modes_Pos    28U                                            /*!< MVFR0: FP rounding modes bits Position */
N#define FPU_MVFR0_FP_rounding_modes_Msk    (0xFUL << FPU_MVFR0_FP_rounding_modes_Pos)     /*!< MVFR0: FP rounding modes bits Mask */
N
N#define FPU_MVFR0_Short_vectors_Pos        24U                                            /*!< MVFR0: Short vectors bits Position */
N#define FPU_MVFR0_Short_vectors_Msk        (0xFUL << FPU_MVFR0_Short_vectors_Pos)         /*!< MVFR0: Short vectors bits Mask */
N
N#define FPU_MVFR0_Square_root_Pos          20U                                            /*!< MVFR0: Square root bits Position */
N#define FPU_MVFR0_Square_root_Msk          (0xFUL << FPU_MVFR0_Square_root_Pos)           /*!< MVFR0: Square root bits Mask */
N
N#define FPU_MVFR0_Divide_Pos               16U                                            /*!< MVFR0: Divide bits Position */
N#define FPU_MVFR0_Divide_Msk               (0xFUL << FPU_MVFR0_Divide_Pos)                /*!< MVFR0: Divide bits Mask */
N
N#define FPU_MVFR0_FP_excep_trapping_Pos    12U                                            /*!< MVFR0: FP exception trapping bits Position */
N#define FPU_MVFR0_FP_excep_trapping_Msk    (0xFUL << FPU_MVFR0_FP_excep_trapping_Pos)     /*!< MVFR0: FP exception trapping bits Mask */
N
N#define FPU_MVFR0_Double_precision_Pos      8U                                            /*!< MVFR0: Double-precision bits Position */
N#define FPU_MVFR0_Double_precision_Msk     (0xFUL << FPU_MVFR0_Double_precision_Pos)      /*!< MVFR0: Double-precision bits Mask */
N
N#define FPU_MVFR0_Single_precision_Pos      4U                                            /*!< MVFR0: Single-precision bits Position */
N#define FPU_MVFR0_Single_precision_Msk     (0xFUL << FPU_MVFR0_Single_precision_Pos)      /*!< MVFR0: Single-precision bits Mask */
N
N#define FPU_MVFR0_A_SIMD_registers_Pos      0U                                            /*!< MVFR0: A_SIMD registers bits Position */
N#define FPU_MVFR0_A_SIMD_registers_Msk     (0xFUL /*<< FPU_MVFR0_A_SIMD_registers_Pos*/)  /*!< MVFR0: A_SIMD registers bits Mask */
N
N/* Media and FP Feature Register 1 Definitions */
N#define FPU_MVFR1_FP_fused_MAC_Pos         28U                                            /*!< MVFR1: FP fused MAC bits Position */
N#define FPU_MVFR1_FP_fused_MAC_Msk         (0xFUL << FPU_MVFR1_FP_fused_MAC_Pos)          /*!< MVFR1: FP fused MAC bits Mask */
N
N#define FPU_MVFR1_FP_HPFP_Pos              24U                                            /*!< MVFR1: FP HPFP bits Position */
N#define FPU_MVFR1_FP_HPFP_Msk              (0xFUL << FPU_MVFR1_FP_HPFP_Pos)               /*!< MVFR1: FP HPFP bits Mask */
N
N#define FPU_MVFR1_D_NaN_mode_Pos            4U                                            /*!< MVFR1: D_NaN mode bits Position */
N#define FPU_MVFR1_D_NaN_mode_Msk           (0xFUL << FPU_MVFR1_D_NaN_mode_Pos)            /*!< MVFR1: D_NaN mode bits Mask */
N
N#define FPU_MVFR1_FtZ_mode_Pos              0U                                            /*!< MVFR1: FtZ mode bits Position */
N#define FPU_MVFR1_FtZ_mode_Msk             (0xFUL /*<< FPU_MVFR1_FtZ_mode_Pos*/)          /*!< MVFR1: FtZ mode bits Mask */
N
N/* Media and FP Feature Register 2 Definitions */
N
N/*@} end of group CMSIS_FPU */
N#endif
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Type definitions for the Core Debug Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Core Debug Register (CoreDebug).
N */
Ntypedef struct
N{
N  __IOM uint32_t DHCSR;                  /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register */
X  volatile uint32_t DHCSR;                   
N  __OM  uint32_t DCRSR;                  /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register */
X  volatile  uint32_t DCRSR;                   
N  __IOM uint32_t DCRDR;                  /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register */
X  volatile uint32_t DCRDR;                   
N  __IOM uint32_t DEMCR;                  /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                   
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register Definitions */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16U                                            /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25U                                            /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24U                                            /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19U                                            /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18U                                            /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17U                                            /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16U                                            /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5U                                            /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3U                                            /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2U                                            /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1U                                            /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0U                                            /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL /*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*/)     /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register Definitions */
N#define CoreDebug_DCRSR_REGWnR_Pos         16U                                            /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0U                                            /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL /*<< CoreDebug_DCRSR_REGSEL_Pos*/)     /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register Definitions */
N#define CoreDebug_DEMCR_TRCENA_Pos         24U                                            /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19U                                            /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18U                                            /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17U                                            /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16U                                            /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10U                                            /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9U                                            /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8U                                            /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7U                                            /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6U                                            /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5U                                            /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4U                                            /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0U                                            /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL /*<< CoreDebug_DEMCR_VC_CORERESET_Pos*/)  /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    ((value << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    ((value & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M4 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address */
N#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address */
N#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address */
N#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct */
N#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct */
N#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct */
N
N#if (__MPU_PRESENT == 1U)
X#if (1 == 1U)
N  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit */
N  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit */
N#endif
N
N#if (__FPU_PRESENT == 1U)
X#if (1 == 1U)
N  #define FPU_BASE          (SCS_BASE +  0x0F30UL)                    /*!< Floating Point Unit */
N  #define FPU               ((FPU_Type       *)     FPU_BASE      )   /*!< Floating Point Unit */
N#endif
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Debug Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N/**
N  \brief   Set Priority Grouping
N  \details Sets the priority grouping field using the required unlock sequence.
N           The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
N           Only values from 0..7 are used.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]      PriorityGroup  Priority grouping field.
N */
N__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
N
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR;                                                    
N  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
X  reg_value &= ~((uint32_t)((0xFFFFUL << 16U) | (7UL << 8U)));  
N  reg_value  =  (reg_value                                   |
N                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X                ((uint32_t)0x5FAUL << 16U) |
N                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR =  reg_value;
N}
N
N
N/**
N  \brief   Get Priority Grouping
N  \details Reads the priority grouping field from the NVIC Interrupt Controller.
N  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
N */
N__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t NVIC_GetPriorityGrouping(void)
N{
N  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
X  return ((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) >> 8U));
N}
N
N
N/**
N  \brief   Enable External Interrupt
N  \details Enables a device-specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Disable External Interrupt
N  \details Disables a device-specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the pending register in the NVIC and returns the pending bit for the specified interrupt.
N  \param [in]      IRQn  Interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X  return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of an external interrupt.
N  \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of an external interrupt.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Get Active Interrupt
N  \details Reads the active register in NVIC and returns the active bit.
N  \param [in]      IRQn  Interrupt number.
N  \return             0  Interrupt status is not active.
N  \return             1  Interrupt status is active.
N */
N__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetActive(IRQn_Type IRQn)
N{
N  return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X  return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of an interrupt.
N  \note    The priority cannot be set for every core interrupt.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if ((int32_t)(IRQn) < 0)
N  {
N    SCB->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - 4)) & (uint32_t)0xFFUL);
N  }
N  else
N  {
N    NVIC->IP[((uint32_t)(int32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]                = (uint8_t)((priority << (8U - 4)) & (uint32_t)0xFFUL);
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of an interrupt.
N           The interrupt number can be positive to specify an external (device specific) interrupt,
N           or negative to specify an internal (core) interrupt.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if ((int32_t)(IRQn) < 0)
N  {
N    return(((uint32_t)SCB->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - 4)));
N  }
N  else
N  {
N    return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]                >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]                >> (8U - 4)));
N  }
N}
N
N
N/**
N  \brief   Encode Priority
N  \details Encodes the priority for an interrupt with the given priority group,
N           preemptive priority value, and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]     PriorityGroup  Used priority group.
N  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N  \param [in]       SubPriority  Subpriority value (starting from 0).
N  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(4)) ? (uint32_t)(4) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(4)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(4));
N
N  return (
N           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
N           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
N         );
N}
N
N
N/**
N  \brief   Decode Priority
N  \details Decodes an interrupt priority value with a given priority group to
N           preemptive priority value and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N  \param [in]     PriorityGroup  Used priority group.
N  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N  \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(4)) ? (uint32_t)(4) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(4)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(4));
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
N  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
N}
N
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = (uint32_t)((0x5FAUL << 16U)    |
N                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
X                           (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) |
N                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
X                            (1UL << 2U)    );          
N  __DSB();                                                          /* Ensure completion of memory access */
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                           
N
N  for(;;)                                                           /* wait until reset */
N  {
N    __NOP();
X    __nop();
N  }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N/* ##########################  FPU functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_FpuFunctions FPU Functions
N  \brief    Function that provides FPU type.
N  @{
N */
N
N/**
N  \brief   get FPU type
N  \details returns the FPU type
N  \returns
N   - \b  0: No FPU
N   - \b  1: Single precision FPU
N   - \b  2: Double + Single precision FPU
N */
N__STATIC_INLINE uint32_t SCB_GetFPUType(void)
Xstatic __inline uint32_t SCB_GetFPUType(void)
N{
N  uint32_t mvfr0;
N
N  mvfr0 = SCB->MVFR0;
X  mvfr0 = ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->MVFR0;
N  if        ((mvfr0 & 0x00000FF0UL) == 0x220UL)
N  {
N    return 2UL;           /* Double + Single precision FPU */
N  }
N  else if ((mvfr0 & 0x00000FF0UL) == 0x020UL)
N  {
N    return 1UL;           /* Single precision FPU */
N  }
N  else
N  {
N    return 0UL;           /* No FPU */
N  }
N}
N
N
N/*@} end of CMSIS_Core_FpuFunctions */
N
N
N
N/* ##########################  Cache functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_CacheFunctions Cache Functions
N  \brief    Functions that configure Instruction and Data cache.
N  @{
N */
N
N/* Cache Size ID Register Macros */
N#define CCSIDR_WAYS(x)         (((x) & SCB_CCSIDR_ASSOCIATIVITY_Msk) >> SCB_CCSIDR_ASSOCIATIVITY_Pos)
N#define CCSIDR_SETS(x)         (((x) & SCB_CCSIDR_NUMSETS_Msk      ) >> SCB_CCSIDR_NUMSETS_Pos      )
N
N
N/**
N  \brief   Enable I-Cache
N  \details Turns on I-Cache
N  */
N__STATIC_INLINE void SCB_EnableICache (void)
Xstatic __inline void SCB_EnableICache (void)
N{
N  #if (__ICACHE_PRESENT == 1U)
X  #if (1 == 1U)
N    __DSB();
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N    __ISB();
X    do { __schedule_barrier(); __isb(0xF); __schedule_barrier(); } while (0U);
N    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->ICIALLU = 0UL;                      
N    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->CCR |=  (uint32_t)(1UL << 17U);   
N    __DSB();
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N    __ISB();
X    do { __schedule_barrier(); __isb(0xF); __schedule_barrier(); } while (0U);
N  #endif
N}
N
N
N/**
N  \brief   Disable I-Cache
N  \details Turns off I-Cache
N  */
N__STATIC_INLINE void SCB_DisableICache (void)
Xstatic __inline void SCB_DisableICache (void)
N{
N  #if (__ICACHE_PRESENT == 1U)
X  #if (1 == 1U)
N    __DSB();
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N    __ISB();
X    do { __schedule_barrier(); __isb(0xF); __schedule_barrier(); } while (0U);
N    SCB->CCR &= ~(uint32_t)SCB_CCR_IC_Msk;  /* disable I-Cache */
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->CCR &= ~(uint32_t)(1UL << 17U);   
N    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->ICIALLU = 0UL;                      
N    __DSB();
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N    __ISB();
X    do { __schedule_barrier(); __isb(0xF); __schedule_barrier(); } while (0U);
N  #endif
N}
N
N
N/**
N  \brief   Invalidate I-Cache
N  \details Invalidates I-Cache
N  */
N__STATIC_INLINE void SCB_InvalidateICache (void)
Xstatic __inline void SCB_InvalidateICache (void)
N{
N  #if (__ICACHE_PRESENT == 1U)
X  #if (1 == 1U)
N    __DSB();
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N    __ISB();
X    do { __schedule_barrier(); __isb(0xF); __schedule_barrier(); } while (0U);
N    SCB->ICIALLU = 0UL;
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->ICIALLU = 0UL;
N    __DSB();
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N    __ISB();
X    do { __schedule_barrier(); __isb(0xF); __schedule_barrier(); } while (0U);
N  #endif
N}
N
N
N/**
N  \brief   Enable D-Cache
N  \details Turns on D-Cache
N  */
N__STATIC_INLINE void SCB_EnableDCache (void)
Xstatic __inline void SCB_EnableDCache (void)
N{
N  #if (__DCACHE_PRESENT == 1U)
X  #if (1 == 1U)
N    uint32_t ccsidr;
N    uint32_t sets;
N    uint32_t ways;
N
N    SCB->CSSELR = (0U << 1U) | 0U;          /* Level 1 data cache */
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->CSSELR = (0U << 1U) | 0U;           
N    __DSB();
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N
N    ccsidr = SCB->CCSIDR;
X    ccsidr = ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->CCSIDR;
N
N                                            /* invalidate D-Cache */
N    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
X    sets = (uint32_t)((((ccsidr) & (0x7FFFUL << 13U) ) >> 13U ));
N    do {
N      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
X      ways = (uint32_t)((((ccsidr) & (0x3FFUL << 3U)) >> 3U));
N      do {
N        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
X        ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->DCISW = (((sets << 5U) & (0x1FFUL << 5U)) |
N                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
X                      ((ways << 30U) & (3UL << 30U))  );
N        #if defined ( __CC_ARM )
X        #if 1L
N          __schedule_barrier();
N        #endif
N      } while (ways--);
N    } while(sets--);
N    __DSB();
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N
N    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->CCR |=  (uint32_t)(1UL << 16U);   
N
N    __DSB();
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N    __ISB();
X    do { __schedule_barrier(); __isb(0xF); __schedule_barrier(); } while (0U);
N  #endif
N}
N
N
N/**
N  \brief   Disable D-Cache
N  \details Turns off D-Cache
N  */
N__STATIC_INLINE void SCB_DisableDCache (void)
Xstatic __inline void SCB_DisableDCache (void)
N{
N  #if (__DCACHE_PRESENT == 1U)
X  #if (1 == 1U)
N    uint32_t ccsidr;
N    uint32_t sets;
N    uint32_t ways;
N
N    SCB->CSSELR = (0U << 1U) | 0U;          /* Level 1 data cache */
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->CSSELR = (0U << 1U) | 0U;           
N    __DSB();
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N
N    ccsidr = SCB->CCSIDR;
X    ccsidr = ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->CCSIDR;
N
N    SCB->CCR &= ~(uint32_t)SCB_CCR_DC_Msk;  /* disable D-Cache */
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->CCR &= ~(uint32_t)(1UL << 16U);   
N
N                                            /* clean & invalidate D-Cache */
N    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
X    sets = (uint32_t)((((ccsidr) & (0x7FFFUL << 13U) ) >> 13U ));
N    do {
N      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
X      ways = (uint32_t)((((ccsidr) & (0x3FFUL << 3U)) >> 3U));
N      do {
N        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
X        ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->DCCISW = (((sets << 5U) & (0x1FFUL << 5U)) |
N                       ((ways << SCB_DCCISW_WAY_Pos) & SCB_DCCISW_WAY_Msk)  );
X                       ((ways << 30U) & (3UL << 30U))  );
N        #if defined ( __CC_ARM )
X        #if 1L
N          __schedule_barrier();
N        #endif
N      } while (ways--);
N    } while(sets--);
N
N    __DSB();
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N    __ISB();
X    do { __schedule_barrier(); __isb(0xF); __schedule_barrier(); } while (0U);
N  #endif
N}
N
N
N/**
N  \brief   Invalidate D-Cache
N  \details Invalidates D-Cache
N  */
N__STATIC_INLINE void SCB_InvalidateDCache (void)
Xstatic __inline void SCB_InvalidateDCache (void)
N{
N  #if (__DCACHE_PRESENT == 1U)
X  #if (1 == 1U)
N    uint32_t ccsidr;
N    uint32_t sets;
N    uint32_t ways;
N
N    SCB->CSSELR = (0U << 1U) | 0U;          /* Level 1 data cache */
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->CSSELR = (0U << 1U) | 0U;           
N    __DSB();
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N
N    ccsidr = SCB->CCSIDR;
X    ccsidr = ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->CCSIDR;
N
N                                            /* invalidate D-Cache */
N    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
X    sets = (uint32_t)((((ccsidr) & (0x7FFFUL << 13U) ) >> 13U ));
N    do {
N      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
X      ways = (uint32_t)((((ccsidr) & (0x3FFUL << 3U)) >> 3U));
N      do {
N        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
X        ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->DCISW = (((sets << 5U) & (0x1FFUL << 5U)) |
N                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
X                      ((ways << 30U) & (3UL << 30U))  );
N        #if defined ( __CC_ARM )
X        #if 1L
N          __schedule_barrier();
N        #endif
N      } while (ways--);
N    } while(sets--);
N
N    __DSB();
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N    __ISB();
X    do { __schedule_barrier(); __isb(0xF); __schedule_barrier(); } while (0U);
N  #endif
N}
N
N
N/**
N  \brief   Clean D-Cache
N  \details Cleans D-Cache
N  */
N__STATIC_INLINE void SCB_CleanDCache (void)
Xstatic __inline void SCB_CleanDCache (void)
N{
N  #if (__DCACHE_PRESENT == 1U)
X  #if (1 == 1U)
N    uint32_t ccsidr;
N    uint32_t sets;
N    uint32_t ways;
N
N    SCB->CSSELR = (0U << 1U) | 0U;          /* Level 1 data cache */
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->CSSELR = (0U << 1U) | 0U;           
N    __DSB();
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N
N    ccsidr = SCB->CCSIDR;
X    ccsidr = ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->CCSIDR;
N
N                                            /* clean D-Cache */
N    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
X    sets = (uint32_t)((((ccsidr) & (0x7FFFUL << 13U) ) >> 13U ));
N    do {
N      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
X      ways = (uint32_t)((((ccsidr) & (0x3FFUL << 3U)) >> 3U));
N      do {
N        SCB->DCCSW = (((sets << SCB_DCCSW_SET_Pos) & SCB_DCCSW_SET_Msk) |
X        ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->DCCSW = (((sets << 5U) & (0x1FFUL << 5U)) |
N                      ((ways << SCB_DCCSW_WAY_Pos) & SCB_DCCSW_WAY_Msk)  );
X                      ((ways << 30U) & (3UL << 30U))  );
N        #if defined ( __CC_ARM )
X        #if 1L
N          __schedule_barrier();
N        #endif
N      } while (ways--);
N    } while(sets--);
N
N    __DSB();
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N    __ISB();
X    do { __schedule_barrier(); __isb(0xF); __schedule_barrier(); } while (0U);
N  #endif
N}
N
N
N/**
N  \brief   Clean & Invalidate D-Cache
N  \details Cleans and Invalidates D-Cache
N  */
N__STATIC_INLINE void SCB_CleanInvalidateDCache (void)
Xstatic __inline void SCB_CleanInvalidateDCache (void)
N{
N  #if (__DCACHE_PRESENT == 1U)
X  #if (1 == 1U)
N    uint32_t ccsidr;
N    uint32_t sets;
N    uint32_t ways;
N
N    SCB->CSSELR = (0U << 1U) | 0U;          /* Level 1 data cache */
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->CSSELR = (0U << 1U) | 0U;           
N    __DSB();
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N
N    ccsidr = SCB->CCSIDR;
X    ccsidr = ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->CCSIDR;
N
N                                            /* clean & invalidate D-Cache */
N    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
X    sets = (uint32_t)((((ccsidr) & (0x7FFFUL << 13U) ) >> 13U ));
N    do {
N      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
X      ways = (uint32_t)((((ccsidr) & (0x3FFUL << 3U)) >> 3U));
N      do {
N        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
X        ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->DCCISW = (((sets << 5U) & (0x1FFUL << 5U)) |
N                       ((ways << SCB_DCCISW_WAY_Pos) & SCB_DCCISW_WAY_Msk)  );
X                       ((ways << 30U) & (3UL << 30U))  );
N        #if defined ( __CC_ARM )
X        #if 1L
N          __schedule_barrier();
N        #endif
N      } while (ways--);
N    } while(sets--);
N
N    __DSB();
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N    __ISB();
X    do { __schedule_barrier(); __isb(0xF); __schedule_barrier(); } while (0U);
N  #endif
N}
N
N
N/**
N  \brief   D-Cache Invalidate by address
N  \details Invalidates D-Cache for the given address
N  \param[in]   addr    address (aligned to 32-byte boundary)
N  \param[in]   dsize   size of memory block (in number of bytes)
N*/
N__STATIC_INLINE void SCB_InvalidateDCache_by_Addr (uint32_t *addr, int32_t dsize)
Xstatic __inline void SCB_InvalidateDCache_by_Addr (uint32_t *addr, int32_t dsize)
N{
N  #if (__DCACHE_PRESENT == 1U)
X  #if (1 == 1U)
N     int32_t op_size = dsize;
N    uint32_t op_addr = (uint32_t)addr;
N     int32_t linesize = 32U;                /* in Cortex-M7 size of cache line is fixed to 8 words (32 bytes) */
N
N    __DSB();
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N
N    while (op_size > 0) {
N      SCB->DCIMVAC = op_addr;
X      ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->DCIMVAC = op_addr;
N      op_addr += linesize;
N      op_size -= linesize;
N    }
N
N    __DSB();
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N    __ISB();
X    do { __schedule_barrier(); __isb(0xF); __schedule_barrier(); } while (0U);
N  #endif
N}
N
N
N/**
N  \brief   D-Cache Clean by address
N  \details Cleans D-Cache for the given address
N  \param[in]   addr    address (aligned to 32-byte boundary)
N  \param[in]   dsize   size of memory block (in number of bytes)
N*/
N__STATIC_INLINE void SCB_CleanDCache_by_Addr (uint32_t *addr, int32_t dsize)
Xstatic __inline void SCB_CleanDCache_by_Addr (uint32_t *addr, int32_t dsize)
N{
N  #if (__DCACHE_PRESENT == 1)
X  #if (1 == 1)
N     int32_t op_size = dsize;
N    uint32_t op_addr = (uint32_t) addr;
N     int32_t linesize = 32U;                /* in Cortex-M7 size of cache line is fixed to 8 words (32 bytes) */
N
N    __DSB();
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N
N    while (op_size > 0) {
N      SCB->DCCMVAC = op_addr;
X      ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->DCCMVAC = op_addr;
N      op_addr += linesize;
N      op_size -= linesize;
N    }
N
N    __DSB();
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N    __ISB();
X    do { __schedule_barrier(); __isb(0xF); __schedule_barrier(); } while (0U);
N  #endif
N}
N
N
N/**
N  \brief   D-Cache Clean and Invalidate by address
N  \details Cleans and invalidates D_Cache for the given address
N  \param[in]   addr    address (aligned to 32-byte boundary)
N  \param[in]   dsize   size of memory block (in number of bytes)
N*/
N__STATIC_INLINE void SCB_CleanInvalidateDCache_by_Addr (uint32_t *addr, int32_t dsize)
Xstatic __inline void SCB_CleanInvalidateDCache_by_Addr (uint32_t *addr, int32_t dsize)
N{
N  #if (__DCACHE_PRESENT == 1U)
X  #if (1 == 1U)
N     int32_t op_size = dsize;
N    uint32_t op_addr = (uint32_t) addr;
N     int32_t linesize = 32U;                /* in Cortex-M7 size of cache line is fixed to 8 words (32 bytes) */
N
N    __DSB();
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N
N    while (op_size > 0) {
N      SCB->DCCIMVAC = op_addr;
X      ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->DCCIMVAC = op_addr;
N      op_addr += linesize;
N      op_size -= linesize;
N    }
N
N    __DSB();
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N    __ISB();
X    do { __schedule_barrier(); __isb(0xF); __schedule_barrier(); } while (0U);
N  #endif
N}
N
N
N/*@} end of CMSIS_Core_CacheFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0U)
X#if (0 == 0U)
N
N/**
N  \brief   System Tick Configuration
N  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
N           Counter is in free running mode to generate periodic interrupts.
N  \param [in]  ticks  Number of ticks between two interrupts.
N  \return          0  Function succeeded.
N  \return          1  Function failed.
N  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N           must contain a vendor-specific implementation of this function.
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
X  if ((ticks - 1UL) > (0xFFFFFFUL ))
N  {
N    return (1UL);                                                   /* Reload value impossible */
N  }
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1UL << 4) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1U)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_core_DebugFunctions ITM Functions
N  \brief    Functions that access the ITM debug interface.
N  @{
N */
N
Nextern volatile int32_t ITM_RxBuffer;                    /*!< External variable to receive characters. */
N#define                 ITM_RXBUFFER_EMPTY   0x5AA55AA5U /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
N
N
N/**
N  \brief   ITM Send Character
N  \details Transmits a character via the ITM channel 0, and
N           \li Just returns when no debugger is connected that has booked the output.
N           \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
N  \param [in]     ch  Character to transmit.
N  \returns            Character to transmit.
N */
N__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
X  if (((((ITM_Type *) (0xE0000000UL) )->TCR & (1UL )) != 0UL) &&       
N      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
X      ((((ITM_Type *) (0xE0000000UL) )->TER & 1UL               ) != 0UL)   )      
N  {
N    while (ITM->PORT[0U].u32 == 0UL)
X    while (((ITM_Type *) (0xE0000000UL) )->PORT[0U].u32 == 0UL)
N    {
N      __NOP();
X      __nop();
N    }
N    ITM->PORT[0U].u8 = (uint8_t)ch;
X    ((ITM_Type *) (0xE0000000UL) )->PORT[0U].u8 = (uint8_t)ch;
N  }
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Receive Character
N  \details Inputs a character via the external variable \ref ITM_RxBuffer.
N  \return             Received character.
N  \return         -1  No character pending.
N */
N__STATIC_INLINE int32_t ITM_ReceiveChar (void)
Xstatic __inline int32_t ITM_ReceiveChar (void)
N{
N  int32_t ch = -1;                           /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer != 0x5AA55AA5U)
N  {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = 0x5AA55AA5U;        
N  }
N
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Check Character
N  \details Checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
N  \return          0  No character available.
N  \return          1  Character available.
N */
N__STATIC_INLINE int32_t ITM_CheckChar (void)
Xstatic __inline int32_t ITM_CheckChar (void)
N{
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer == 0x5AA55AA5U)
N  {
N    return (0);                              /* no character available */
N  }
N  else
N  {
N    return (1);                              /*    character available */
N  }
N}
N
N/*@} end of CMSIS_core_DebugFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM7_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 204 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f767xx.h" 2
N  
N  
N#include "system_stm32f7xx.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Core\system_stm32f7xx.h" 1
N/**
N  ******************************************************************************
N  * @file    system_stm32f7xx.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   CMSIS Cortex-M7 Device System Source File for STM32F7xx devices.       
N  ******************************************************************************  
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************  
N  */
N
N/** @addtogroup CMSIS
N  * @{
N  */
N
N/** @addtogroup stm32f7xx_system
N  * @{
N  */  
N  
N/**
N  * @brief Define to prevent recursive inclusion
N  */
N#ifndef __SYSTEM_STM32F7XX_H
N#define __SYSTEM_STM32F7XX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N
N/** @addtogroup STM32F7xx_System_Includes
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N
N/** @addtogroup STM32F7xx_System_Exported_Variables
N  * @{
N  */
N  /* The SystemCoreClock variable is updated in three ways:
N      1) by calling CMSIS function SystemCoreClockUpdate()
N      2) by calling HAL API function HAL_RCC_GetSysClockFreq()
N      3) each time HAL_RCC_ClockConfig() is called to configure the system clock frequency 
N         Note: If you use this function to configure the system clock; then there
N               is no need to call the 2 first functions listed above, since SystemCoreClock
N               variable is updated automatically.
N    */
Nextern uint32_t SystemCoreClock;          /*!< System Clock Frequency (Core Clock) */
N
Nextern const uint8_t  AHBPrescTable[16];    /*!< AHB prescalers table values */
Nextern const uint8_t  APBPrescTable[8];     /*!< APB prescalers table values */
N
N
N/**
N  * @}
N  */
N
N/** @addtogroup STM32F7xx_System_Exported_Constants
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @addtogroup STM32F7xx_System_Exported_Macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @addtogroup STM32F7xx_System_Exported_Functions
N  * @{
N  */
N  
Nextern void SystemInit(void);
Nextern void SystemCoreClockUpdate(void);
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__SYSTEM_STM32F7XX_H */
N
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */  
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 207 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f767xx.h" 2
N#include <stdint.h>
N
N/** @addtogroup Peripheral_registers_structures
N  * @{
N  */   
N
N/** 
N  * @brief Analog to Digital Converter  
N  */
N
Ntypedef struct
N{
N  __IO uint32_t SR;     /*!< ADC status register,                         Address offset: 0x00 */
X  volatile uint32_t SR;      
N  __IO uint32_t CR1;    /*!< ADC control register 1,                      Address offset: 0x04 */      
X  volatile uint32_t CR1;           
N  __IO uint32_t CR2;    /*!< ADC control register 2,                      Address offset: 0x08 */
X  volatile uint32_t CR2;     
N  __IO uint32_t SMPR1;  /*!< ADC sample time register 1,                  Address offset: 0x0C */
X  volatile uint32_t SMPR1;   
N  __IO uint32_t SMPR2;  /*!< ADC sample time register 2,                  Address offset: 0x10 */
X  volatile uint32_t SMPR2;   
N  __IO uint32_t JOFR1;  /*!< ADC injected channel data offset register 1, Address offset: 0x14 */
X  volatile uint32_t JOFR1;   
N  __IO uint32_t JOFR2;  /*!< ADC injected channel data offset register 2, Address offset: 0x18 */
X  volatile uint32_t JOFR2;   
N  __IO uint32_t JOFR3;  /*!< ADC injected channel data offset register 3, Address offset: 0x1C */
X  volatile uint32_t JOFR3;   
N  __IO uint32_t JOFR4;  /*!< ADC injected channel data offset register 4, Address offset: 0x20 */
X  volatile uint32_t JOFR4;   
N  __IO uint32_t HTR;    /*!< ADC watchdog higher threshold register,      Address offset: 0x24 */
X  volatile uint32_t HTR;     
N  __IO uint32_t LTR;    /*!< ADC watchdog lower threshold register,       Address offset: 0x28 */
X  volatile uint32_t LTR;     
N  __IO uint32_t SQR1;   /*!< ADC regular sequence register 1,             Address offset: 0x2C */
X  volatile uint32_t SQR1;    
N  __IO uint32_t SQR2;   /*!< ADC regular sequence register 2,             Address offset: 0x30 */
X  volatile uint32_t SQR2;    
N  __IO uint32_t SQR3;   /*!< ADC regular sequence register 3,             Address offset: 0x34 */
X  volatile uint32_t SQR3;    
N  __IO uint32_t JSQR;   /*!< ADC injected sequence register,              Address offset: 0x38*/
X  volatile uint32_t JSQR;    
N  __IO uint32_t JDR1;   /*!< ADC injected data register 1,                Address offset: 0x3C */
X  volatile uint32_t JDR1;    
N  __IO uint32_t JDR2;   /*!< ADC injected data register 2,                Address offset: 0x40 */
X  volatile uint32_t JDR2;    
N  __IO uint32_t JDR3;   /*!< ADC injected data register 3,                Address offset: 0x44 */
X  volatile uint32_t JDR3;    
N  __IO uint32_t JDR4;   /*!< ADC injected data register 4,                Address offset: 0x48 */
X  volatile uint32_t JDR4;    
N  __IO uint32_t DR;     /*!< ADC regular data register,                   Address offset: 0x4C */
X  volatile uint32_t DR;      
N} ADC_TypeDef;
N
Ntypedef struct
N{
N  __IO uint32_t CSR;    /*!< ADC Common status register,                  Address offset: ADC1 base address + 0x300 */
X  volatile uint32_t CSR;     
N  __IO uint32_t CCR;    /*!< ADC common control register,                 Address offset: ADC1 base address + 0x304 */
X  volatile uint32_t CCR;     
N  __IO uint32_t CDR;    /*!< ADC common regular data register for dual
X  volatile uint32_t CDR;    
N                             AND triple modes,                            Address offset: ADC1 base address + 0x308 */
N} ADC_Common_TypeDef;
N
N
N/** 
N  * @brief Controller Area Network TxMailBox 
N  */
N
Ntypedef struct
N{
N  __IO uint32_t TIR;  /*!< CAN TX mailbox identifier register */
X  volatile uint32_t TIR;   
N  __IO uint32_t TDTR; /*!< CAN mailbox data length control and time stamp register */
X  volatile uint32_t TDTR;  
N  __IO uint32_t TDLR; /*!< CAN mailbox data low register */
X  volatile uint32_t TDLR;  
N  __IO uint32_t TDHR; /*!< CAN mailbox data high register */
X  volatile uint32_t TDHR;  
N} CAN_TxMailBox_TypeDef;
N
N/** 
N  * @brief Controller Area Network FIFOMailBox 
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t RIR;  /*!< CAN receive FIFO mailbox identifier register */
X  volatile uint32_t RIR;   
N  __IO uint32_t RDTR; /*!< CAN receive FIFO mailbox data length control and time stamp register */
X  volatile uint32_t RDTR;  
N  __IO uint32_t RDLR; /*!< CAN receive FIFO mailbox data low register */
X  volatile uint32_t RDLR;  
N  __IO uint32_t RDHR; /*!< CAN receive FIFO mailbox data high register */
X  volatile uint32_t RDHR;  
N} CAN_FIFOMailBox_TypeDef;
N
N/** 
N  * @brief Controller Area Network FilterRegister 
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t FR1; /*!< CAN Filter bank register 1 */
X  volatile uint32_t FR1;  
N  __IO uint32_t FR2; /*!< CAN Filter bank register 1 */
X  volatile uint32_t FR2;  
N} CAN_FilterRegister_TypeDef;
N
N/** 
N  * @brief Controller Area Network 
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t              MCR;                 /*!< CAN master control register,         Address offset: 0x00          */
X  volatile uint32_t              MCR;                  
N  __IO uint32_t              MSR;                 /*!< CAN master status register,          Address offset: 0x04          */
X  volatile uint32_t              MSR;                  
N  __IO uint32_t              TSR;                 /*!< CAN transmit status register,        Address offset: 0x08          */
X  volatile uint32_t              TSR;                  
N  __IO uint32_t              RF0R;                /*!< CAN receive FIFO 0 register,         Address offset: 0x0C          */
X  volatile uint32_t              RF0R;                 
N  __IO uint32_t              RF1R;                /*!< CAN receive FIFO 1 register,         Address offset: 0x10          */
X  volatile uint32_t              RF1R;                 
N  __IO uint32_t              IER;                 /*!< CAN interrupt enable register,       Address offset: 0x14          */
X  volatile uint32_t              IER;                  
N  __IO uint32_t              ESR;                 /*!< CAN error status register,           Address offset: 0x18          */
X  volatile uint32_t              ESR;                  
N  __IO uint32_t              BTR;                 /*!< CAN bit timing register,             Address offset: 0x1C          */
X  volatile uint32_t              BTR;                  
N  uint32_t                   RESERVED0[88];       /*!< Reserved, 0x020 - 0x17F                                            */
N  CAN_TxMailBox_TypeDef      sTxMailBox[3];       /*!< CAN Tx MailBox,                      Address offset: 0x180 - 0x1AC */
N  CAN_FIFOMailBox_TypeDef    sFIFOMailBox[2];     /*!< CAN FIFO MailBox,                    Address offset: 0x1B0 - 0x1CC */
N  uint32_t                   RESERVED1[12];       /*!< Reserved, 0x1D0 - 0x1FF                                            */
N  __IO uint32_t              FMR;                 /*!< CAN filter master register,          Address offset: 0x200         */
X  volatile uint32_t              FMR;                  
N  __IO uint32_t              FM1R;                /*!< CAN filter mode register,            Address offset: 0x204         */
X  volatile uint32_t              FM1R;                 
N  uint32_t                   RESERVED2;           /*!< Reserved, 0x208                                                    */
N  __IO uint32_t              FS1R;                /*!< CAN filter scale register,           Address offset: 0x20C         */
X  volatile uint32_t              FS1R;                 
N  uint32_t                   RESERVED3;           /*!< Reserved, 0x210                                                    */
N  __IO uint32_t              FFA1R;               /*!< CAN filter FIFO assignment register, Address offset: 0x214         */
X  volatile uint32_t              FFA1R;                
N  uint32_t                   RESERVED4;           /*!< Reserved, 0x218                                                    */
N  __IO uint32_t              FA1R;                /*!< CAN filter activation register,      Address offset: 0x21C         */
X  volatile uint32_t              FA1R;                 
N  uint32_t                   RESERVED5[8];        /*!< Reserved, 0x220-0x23F                                              */ 
N  CAN_FilterRegister_TypeDef sFilterRegister[28]; /*!< CAN Filter Register,                 Address offset: 0x240-0x31C   */
N} CAN_TypeDef;
N
N/** 
N  * @brief HDMI-CEC 
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;           /*!< CEC control register,                                       Address offset:0x00 */
X  volatile uint32_t CR;            
N  __IO uint32_t CFGR;         /*!< CEC configuration register,                                 Address offset:0x04 */
X  volatile uint32_t CFGR;          
N  __IO uint32_t TXDR;         /*!< CEC Tx data register ,                                      Address offset:0x08 */
X  volatile uint32_t TXDR;          
N  __IO uint32_t RXDR;         /*!< CEC Rx Data Register,                                       Address offset:0x0C */
X  volatile uint32_t RXDR;          
N  __IO uint32_t ISR;          /*!< CEC Interrupt and Status Register,                          Address offset:0x10 */
X  volatile uint32_t ISR;           
N  __IO uint32_t IER;          /*!< CEC interrupt enable register,                              Address offset:0x14 */
X  volatile uint32_t IER;           
N}CEC_TypeDef;
N
N
N/** 
N  * @brief CRC calculation unit 
N  */
N
Ntypedef struct
N{
N  __IO uint32_t  DR;          /*!< CRC Data register,                           Address offset: 0x00 */
X  volatile uint32_t  DR;           
N  __IO uint8_t   IDR;         /*!< CRC Independent data register,               Address offset: 0x04 */
X  volatile uint8_t   IDR;          
N  uint8_t        RESERVED0;   /*!< Reserved, 0x05                                                    */
N  uint16_t       RESERVED1;   /*!< Reserved, 0x06                                                    */
N  __IO uint32_t  CR;          /*!< CRC Control register,                        Address offset: 0x08 */
X  volatile uint32_t  CR;           
N  uint32_t       RESERVED2;   /*!< Reserved,                                                    0x0C */
N  __IO uint32_t  INIT;        /*!< Initial CRC value register,                  Address offset: 0x10 */
X  volatile uint32_t  INIT;         
N  __IO uint32_t  POL;         /*!< CRC polynomial register,                     Address offset: 0x14 */
X  volatile uint32_t  POL;          
N} CRC_TypeDef;
N
N/** 
N  * @brief Digital to Analog Converter
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;       /*!< DAC control register,                                    Address offset: 0x00 */
X  volatile uint32_t CR;        
N  __IO uint32_t SWTRIGR;  /*!< DAC software trigger register,                           Address offset: 0x04 */
X  volatile uint32_t SWTRIGR;   
N  __IO uint32_t DHR12R1;  /*!< DAC channel1 12-bit right-aligned data holding register, Address offset: 0x08 */
X  volatile uint32_t DHR12R1;   
N  __IO uint32_t DHR12L1;  /*!< DAC channel1 12-bit left aligned data holding register,  Address offset: 0x0C */
X  volatile uint32_t DHR12L1;   
N  __IO uint32_t DHR8R1;   /*!< DAC channel1 8-bit right aligned data holding register,  Address offset: 0x10 */
X  volatile uint32_t DHR8R1;    
N  __IO uint32_t DHR12R2;  /*!< DAC channel2 12-bit right aligned data holding register, Address offset: 0x14 */
X  volatile uint32_t DHR12R2;   
N  __IO uint32_t DHR12L2;  /*!< DAC channel2 12-bit left aligned data holding register,  Address offset: 0x18 */
X  volatile uint32_t DHR12L2;   
N  __IO uint32_t DHR8R2;   /*!< DAC channel2 8-bit right-aligned data holding register,  Address offset: 0x1C */
X  volatile uint32_t DHR8R2;    
N  __IO uint32_t DHR12RD;  /*!< Dual DAC 12-bit right-aligned data holding register,     Address offset: 0x20 */
X  volatile uint32_t DHR12RD;   
N  __IO uint32_t DHR12LD;  /*!< DUAL DAC 12-bit left aligned data holding register,      Address offset: 0x24 */
X  volatile uint32_t DHR12LD;   
N  __IO uint32_t DHR8RD;   /*!< DUAL DAC 8-bit right aligned data holding register,      Address offset: 0x28 */
X  volatile uint32_t DHR8RD;    
N  __IO uint32_t DOR1;     /*!< DAC channel1 data output register,                       Address offset: 0x2C */
X  volatile uint32_t DOR1;      
N  __IO uint32_t DOR2;     /*!< DAC channel2 data output register,                       Address offset: 0x30 */
X  volatile uint32_t DOR2;      
N  __IO uint32_t SR;       /*!< DAC status register,                                     Address offset: 0x34 */
X  volatile uint32_t SR;        
N} DAC_TypeDef;
N
N/**
N  * @brief DFSDM module registers
N  */
Ntypedef struct
N{
N  __IO uint32_t FLTCR1;         /*!< DFSDM control register1,                          Address offset: 0x100 */
X  volatile uint32_t FLTCR1;          
N  __IO uint32_t FLTCR2;         /*!< DFSDM control register2,                          Address offset: 0x104 */
X  volatile uint32_t FLTCR2;          
N  __IO uint32_t FLTISR;         /*!< DFSDM interrupt and status register,              Address offset: 0x108 */
X  volatile uint32_t FLTISR;          
N  __IO uint32_t FLTICR;         /*!< DFSDM interrupt flag clear register,              Address offset: 0x10C */
X  volatile uint32_t FLTICR;          
N  __IO uint32_t FLTJCHGR;       /*!< DFSDM injected channel group selection register,  Address offset: 0x110 */
X  volatile uint32_t FLTJCHGR;        
N  __IO uint32_t FLTFCR;         /*!< DFSDM filter control register,                    Address offset: 0x114 */
X  volatile uint32_t FLTFCR;          
N  __IO uint32_t FLTJDATAR;      /*!< DFSDM data register for injected group,           Address offset: 0x118 */
X  volatile uint32_t FLTJDATAR;       
N  __IO uint32_t FLTRDATAR;      /*!< DFSDM data register for regular group,            Address offset: 0x11C */
X  volatile uint32_t FLTRDATAR;       
N  __IO uint32_t FLTAWHTR;       /*!< DFSDM analog watchdog high threshold register,    Address offset: 0x120 */
X  volatile uint32_t FLTAWHTR;        
N  __IO uint32_t FLTAWLTR;       /*!< DFSDM analog watchdog low threshold register,     Address offset: 0x124 */
X  volatile uint32_t FLTAWLTR;        
N  __IO uint32_t FLTAWSR;        /*!< DFSDM analog watchdog status register             Address offset: 0x128 */
X  volatile uint32_t FLTAWSR;         
N  __IO uint32_t FLTAWCFR;       /*!< DFSDM analog watchdog clear flag register         Address offset: 0x12C */
X  volatile uint32_t FLTAWCFR;        
N  __IO uint32_t FLTEXMAX;       /*!< DFSDM extreme detector maximum register,          Address offset: 0x130 */
X  volatile uint32_t FLTEXMAX;        
N  __IO uint32_t FLTEXMIN;       /*!< DFSDM extreme detector minimum register           Address offset: 0x134 */
X  volatile uint32_t FLTEXMIN;        
N  __IO uint32_t FLTCNVTIMR;     /*!< DFSDM conversion timer,                           Address offset: 0x138 */
X  volatile uint32_t FLTCNVTIMR;      
N} DFSDM_Filter_TypeDef;
N
N/**
N  * @brief DFSDM channel configuration registers
N  */
Ntypedef struct
N{
N  __IO uint32_t CHCFGR1;     /*!< DFSDM channel configuration register1,            Address offset: 0x00 */
X  volatile uint32_t CHCFGR1;      
N  __IO uint32_t CHCFGR2;     /*!< DFSDM channel configuration register2,            Address offset: 0x04 */
X  volatile uint32_t CHCFGR2;      
N  __IO uint32_t CHAWSCDR;    /*!< DFSDM channel analog watchdog and
X  volatile uint32_t CHAWSCDR;    
N                                  short circuit detector register,                  Address offset: 0x08 */
N  __IO uint32_t CHWDATAR;    /*!< DFSDM channel watchdog filter data register,      Address offset: 0x0C */
X  volatile uint32_t CHWDATAR;     
N  __IO uint32_t CHDATINR;    /*!< DFSDM channel data input register,                Address offset: 0x10 */
X  volatile uint32_t CHDATINR;     
N} DFSDM_Channel_TypeDef;
N
N/** 
N  * @brief Debug MCU
N  */
N
Ntypedef struct
N{
N  __IO uint32_t IDCODE;  /*!< MCU device ID code,               Address offset: 0x00 */
X  volatile uint32_t IDCODE;   
N  __IO uint32_t CR;      /*!< Debug MCU configuration register, Address offset: 0x04 */
X  volatile uint32_t CR;       
N  __IO uint32_t APB1FZ;  /*!< Debug MCU APB1 freeze register,   Address offset: 0x08 */
X  volatile uint32_t APB1FZ;   
N  __IO uint32_t APB2FZ;  /*!< Debug MCU APB2 freeze register,   Address offset: 0x0C */
X  volatile uint32_t APB2FZ;   
N}DBGMCU_TypeDef;
N
N/** 
N  * @brief DCMI
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;       /*!< DCMI control register 1,                       Address offset: 0x00 */
X  volatile uint32_t CR;        
N  __IO uint32_t SR;       /*!< DCMI status register,                          Address offset: 0x04 */
X  volatile uint32_t SR;        
N  __IO uint32_t RISR;     /*!< DCMI raw interrupt status register,            Address offset: 0x08 */
X  volatile uint32_t RISR;      
N  __IO uint32_t IER;      /*!< DCMI interrupt enable register,                Address offset: 0x0C */
X  volatile uint32_t IER;       
N  __IO uint32_t MISR;     /*!< DCMI masked interrupt status register,         Address offset: 0x10 */
X  volatile uint32_t MISR;      
N  __IO uint32_t ICR;      /*!< DCMI interrupt clear register,                 Address offset: 0x14 */
X  volatile uint32_t ICR;       
N  __IO uint32_t ESCR;     /*!< DCMI embedded synchronization code register,   Address offset: 0x18 */
X  volatile uint32_t ESCR;      
N  __IO uint32_t ESUR;     /*!< DCMI embedded synchronization unmask register, Address offset: 0x1C */
X  volatile uint32_t ESUR;      
N  __IO uint32_t CWSTRTR;  /*!< DCMI crop window start,                        Address offset: 0x20 */
X  volatile uint32_t CWSTRTR;   
N  __IO uint32_t CWSIZER;  /*!< DCMI crop window size,                         Address offset: 0x24 */
X  volatile uint32_t CWSIZER;   
N  __IO uint32_t DR;       /*!< DCMI data register,                            Address offset: 0x28 */
X  volatile uint32_t DR;        
N} DCMI_TypeDef;
N
N/** 
N  * @brief DMA Controller
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;     /*!< DMA stream x configuration register      */
X  volatile uint32_t CR;      
N  __IO uint32_t NDTR;   /*!< DMA stream x number of data register     */
X  volatile uint32_t NDTR;    
N  __IO uint32_t PAR;    /*!< DMA stream x peripheral address register */
X  volatile uint32_t PAR;     
N  __IO uint32_t M0AR;   /*!< DMA stream x memory 0 address register   */
X  volatile uint32_t M0AR;    
N  __IO uint32_t M1AR;   /*!< DMA stream x memory 1 address register   */
X  volatile uint32_t M1AR;    
N  __IO uint32_t FCR;    /*!< DMA stream x FIFO control register       */
X  volatile uint32_t FCR;     
N} DMA_Stream_TypeDef;
N
Ntypedef struct
N{
N  __IO uint32_t LISR;   /*!< DMA low interrupt status register,      Address offset: 0x00 */
X  volatile uint32_t LISR;    
N  __IO uint32_t HISR;   /*!< DMA high interrupt status register,     Address offset: 0x04 */
X  volatile uint32_t HISR;    
N  __IO uint32_t LIFCR;  /*!< DMA low interrupt flag clear register,  Address offset: 0x08 */
X  volatile uint32_t LIFCR;   
N  __IO uint32_t HIFCR;  /*!< DMA high interrupt flag clear register, Address offset: 0x0C */
X  volatile uint32_t HIFCR;   
N} DMA_TypeDef;
N
N
N/** 
N  * @brief DMA2D Controller
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;            /*!< DMA2D Control Register,                         Address offset: 0x00 */
X  volatile uint32_t CR;             
N  __IO uint32_t ISR;           /*!< DMA2D Interrupt Status Register,                Address offset: 0x04 */
X  volatile uint32_t ISR;            
N  __IO uint32_t IFCR;          /*!< DMA2D Interrupt Flag Clear Register,            Address offset: 0x08 */
X  volatile uint32_t IFCR;           
N  __IO uint32_t FGMAR;         /*!< DMA2D Foreground Memory Address Register,       Address offset: 0x0C */
X  volatile uint32_t FGMAR;          
N  __IO uint32_t FGOR;          /*!< DMA2D Foreground Offset Register,               Address offset: 0x10 */
X  volatile uint32_t FGOR;           
N  __IO uint32_t BGMAR;         /*!< DMA2D Background Memory Address Register,       Address offset: 0x14 */
X  volatile uint32_t BGMAR;          
N  __IO uint32_t BGOR;          /*!< DMA2D Background Offset Register,               Address offset: 0x18 */
X  volatile uint32_t BGOR;           
N  __IO uint32_t FGPFCCR;       /*!< DMA2D Foreground PFC Control Register,          Address offset: 0x1C */
X  volatile uint32_t FGPFCCR;        
N  __IO uint32_t FGCOLR;        /*!< DMA2D Foreground Color Register,                Address offset: 0x20 */
X  volatile uint32_t FGCOLR;         
N  __IO uint32_t BGPFCCR;       /*!< DMA2D Background PFC Control Register,          Address offset: 0x24 */
X  volatile uint32_t BGPFCCR;        
N  __IO uint32_t BGCOLR;        /*!< DMA2D Background Color Register,                Address offset: 0x28 */
X  volatile uint32_t BGCOLR;         
N  __IO uint32_t FGCMAR;        /*!< DMA2D Foreground CLUT Memory Address Register,  Address offset: 0x2C */
X  volatile uint32_t FGCMAR;         
N  __IO uint32_t BGCMAR;        /*!< DMA2D Background CLUT Memory Address Register,  Address offset: 0x30 */
X  volatile uint32_t BGCMAR;         
N  __IO uint32_t OPFCCR;        /*!< DMA2D Output PFC Control Register,              Address offset: 0x34 */
X  volatile uint32_t OPFCCR;         
N  __IO uint32_t OCOLR;         /*!< DMA2D Output Color Register,                    Address offset: 0x38 */
X  volatile uint32_t OCOLR;          
N  __IO uint32_t OMAR;          /*!< DMA2D Output Memory Address Register,           Address offset: 0x3C */
X  volatile uint32_t OMAR;           
N  __IO uint32_t OOR;           /*!< DMA2D Output Offset Register,                   Address offset: 0x40 */
X  volatile uint32_t OOR;            
N  __IO uint32_t NLR;           /*!< DMA2D Number of Line Register,                  Address offset: 0x44 */
X  volatile uint32_t NLR;            
N  __IO uint32_t LWR;           /*!< DMA2D Line Watermark Register,                  Address offset: 0x48 */
X  volatile uint32_t LWR;            
N  __IO uint32_t AMTCR;         /*!< DMA2D AHB Master Timer Configuration Register,  Address offset: 0x4C */
X  volatile uint32_t AMTCR;          
N  uint32_t      RESERVED[236]; /*!< Reserved, 0x50-0x3FF */
N  __IO uint32_t FGCLUT[256];   /*!< DMA2D Foreground CLUT,                          Address offset:400-7FF */
X  volatile uint32_t FGCLUT[256];    
N  __IO uint32_t BGCLUT[256];   /*!< DMA2D Background CLUT,                          Address offset:800-BFF */
X  volatile uint32_t BGCLUT[256];    
N} DMA2D_TypeDef;
N
N
N/** 
N  * @brief Ethernet MAC
N  */
N
Ntypedef struct
N{
N  __IO uint32_t MACCR;
X  volatile uint32_t MACCR;
N  __IO uint32_t MACFFR;
X  volatile uint32_t MACFFR;
N  __IO uint32_t MACHTHR;
X  volatile uint32_t MACHTHR;
N  __IO uint32_t MACHTLR;
X  volatile uint32_t MACHTLR;
N  __IO uint32_t MACMIIAR;
X  volatile uint32_t MACMIIAR;
N  __IO uint32_t MACMIIDR;
X  volatile uint32_t MACMIIDR;
N  __IO uint32_t MACFCR;
X  volatile uint32_t MACFCR;
N  __IO uint32_t MACVLANTR;             /*    8 */
X  volatile uint32_t MACVLANTR;              
N  uint32_t      RESERVED0[2];
N  __IO uint32_t MACRWUFFR;             /*   11 */
X  volatile uint32_t MACRWUFFR;              
N  __IO uint32_t MACPMTCSR;
X  volatile uint32_t MACPMTCSR;
N  uint32_t      RESERVED1[2];
N  __IO uint32_t MACSR;                 /*   15 */
X  volatile uint32_t MACSR;                  
N  __IO uint32_t MACIMR;
X  volatile uint32_t MACIMR;
N  __IO uint32_t MACA0HR;
X  volatile uint32_t MACA0HR;
N  __IO uint32_t MACA0LR;
X  volatile uint32_t MACA0LR;
N  __IO uint32_t MACA1HR;
X  volatile uint32_t MACA1HR;
N  __IO uint32_t MACA1LR;
X  volatile uint32_t MACA1LR;
N  __IO uint32_t MACA2HR;
X  volatile uint32_t MACA2HR;
N  __IO uint32_t MACA2LR;
X  volatile uint32_t MACA2LR;
N  __IO uint32_t MACA3HR;
X  volatile uint32_t MACA3HR;
N  __IO uint32_t MACA3LR;               /*   24 */
X  volatile uint32_t MACA3LR;                
N  uint32_t      RESERVED2[40];
N  __IO uint32_t MMCCR;                 /*   65 */
X  volatile uint32_t MMCCR;                  
N  __IO uint32_t MMCRIR;
X  volatile uint32_t MMCRIR;
N  __IO uint32_t MMCTIR;
X  volatile uint32_t MMCTIR;
N  __IO uint32_t MMCRIMR;
X  volatile uint32_t MMCRIMR;
N  __IO uint32_t MMCTIMR;               /*   69 */
X  volatile uint32_t MMCTIMR;                
N  uint32_t      RESERVED3[14];
N  __IO uint32_t MMCTGFSCCR;            /*   84 */
X  volatile uint32_t MMCTGFSCCR;             
N  __IO uint32_t MMCTGFMSCCR;
X  volatile uint32_t MMCTGFMSCCR;
N  uint32_t      RESERVED4[5];
N  __IO uint32_t MMCTGFCR;
X  volatile uint32_t MMCTGFCR;
N  uint32_t      RESERVED5[10];
N  __IO uint32_t MMCRFCECR;
X  volatile uint32_t MMCRFCECR;
N  __IO uint32_t MMCRFAECR;
X  volatile uint32_t MMCRFAECR;
N  uint32_t      RESERVED6[10];
N  __IO uint32_t MMCRGUFCR;
X  volatile uint32_t MMCRGUFCR;
N  uint32_t      RESERVED7[334];
N  __IO uint32_t PTPTSCR;
X  volatile uint32_t PTPTSCR;
N  __IO uint32_t PTPSSIR;
X  volatile uint32_t PTPSSIR;
N  __IO uint32_t PTPTSHR;
X  volatile uint32_t PTPTSHR;
N  __IO uint32_t PTPTSLR;
X  volatile uint32_t PTPTSLR;
N  __IO uint32_t PTPTSHUR;
X  volatile uint32_t PTPTSHUR;
N  __IO uint32_t PTPTSLUR;
X  volatile uint32_t PTPTSLUR;
N  __IO uint32_t PTPTSAR;
X  volatile uint32_t PTPTSAR;
N  __IO uint32_t PTPTTHR;
X  volatile uint32_t PTPTTHR;
N  __IO uint32_t PTPTTLR;
X  volatile uint32_t PTPTTLR;
N  __IO uint32_t RESERVED8;
X  volatile uint32_t RESERVED8;
N  __IO uint32_t PTPTSSR;
X  volatile uint32_t PTPTSSR;
N  uint32_t      RESERVED9[565];
N  __IO uint32_t DMABMR;
X  volatile uint32_t DMABMR;
N  __IO uint32_t DMATPDR;
X  volatile uint32_t DMATPDR;
N  __IO uint32_t DMARPDR;
X  volatile uint32_t DMARPDR;
N  __IO uint32_t DMARDLAR;
X  volatile uint32_t DMARDLAR;
N  __IO uint32_t DMATDLAR;
X  volatile uint32_t DMATDLAR;
N  __IO uint32_t DMASR;
X  volatile uint32_t DMASR;
N  __IO uint32_t DMAOMR;
X  volatile uint32_t DMAOMR;
N  __IO uint32_t DMAIER;
X  volatile uint32_t DMAIER;
N  __IO uint32_t DMAMFBOCR;
X  volatile uint32_t DMAMFBOCR;
N  __IO uint32_t DMARSWTR;
X  volatile uint32_t DMARSWTR;
N  uint32_t      RESERVED10[8];
N  __IO uint32_t DMACHTDR;
X  volatile uint32_t DMACHTDR;
N  __IO uint32_t DMACHRDR;
X  volatile uint32_t DMACHRDR;
N  __IO uint32_t DMACHTBAR;
X  volatile uint32_t DMACHTBAR;
N  __IO uint32_t DMACHRBAR;
X  volatile uint32_t DMACHRBAR;
N} ETH_TypeDef;
N
N/** 
N  * @brief External Interrupt/Event Controller
N  */
N
Ntypedef struct
N{
N  __IO uint32_t IMR;    /*!< EXTI Interrupt mask register,            Address offset: 0x00 */
X  volatile uint32_t IMR;     
N  __IO uint32_t EMR;    /*!< EXTI Event mask register,                Address offset: 0x04 */
X  volatile uint32_t EMR;     
N  __IO uint32_t RTSR;   /*!< EXTI Rising trigger selection register,  Address offset: 0x08 */
X  volatile uint32_t RTSR;    
N  __IO uint32_t FTSR;   /*!< EXTI Falling trigger selection register, Address offset: 0x0C */
X  volatile uint32_t FTSR;    
N  __IO uint32_t SWIER;  /*!< EXTI Software interrupt event register,  Address offset: 0x10 */
X  volatile uint32_t SWIER;   
N  __IO uint32_t PR;     /*!< EXTI Pending register,                   Address offset: 0x14 */
X  volatile uint32_t PR;      
N} EXTI_TypeDef;
N
N/** 
N  * @brief FLASH Registers
N  */
N
Ntypedef struct
N{
N  __IO uint32_t ACR;      /*!< FLASH access control register,     Address offset: 0x00 */
X  volatile uint32_t ACR;       
N  __IO uint32_t KEYR;     /*!< FLASH key register,                Address offset: 0x04 */
X  volatile uint32_t KEYR;      
N  __IO uint32_t OPTKEYR;  /*!< FLASH option key register,         Address offset: 0x08 */
X  volatile uint32_t OPTKEYR;   
N  __IO uint32_t SR;       /*!< FLASH status register,             Address offset: 0x0C */
X  volatile uint32_t SR;        
N  __IO uint32_t CR;       /*!< FLASH control register,            Address offset: 0x10 */
X  volatile uint32_t CR;        
N  __IO uint32_t OPTCR;    /*!< FLASH option control register ,    Address offset: 0x14 */
X  volatile uint32_t OPTCR;     
N  __IO uint32_t OPTCR1;   /*!< FLASH option control register 1 ,  Address offset: 0x18 */
X  volatile uint32_t OPTCR1;    
N} FLASH_TypeDef;
N
N
N
N/** 
N  * @brief Flexible Memory Controller
N  */
N
Ntypedef struct
N{
N  __IO uint32_t BTCR[8];    /*!< NOR/PSRAM chip-select control register(BCR) and chip-select timing register(BTR), Address offset: 0x00-1C */   
X  volatile uint32_t BTCR[8];        
N} FMC_Bank1_TypeDef; 
N
N/** 
N  * @brief Flexible Memory Controller Bank1E
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t BWTR[7];    /*!< NOR/PSRAM write timing registers, Address offset: 0x104-0x11C */
X  volatile uint32_t BWTR[7];     
N} FMC_Bank1E_TypeDef;
N
N/** 
N  * @brief Flexible Memory Controller Bank3
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t PCR;        /*!< NAND Flash control register,                       Address offset: 0x80 */
X  volatile uint32_t PCR;         
N  __IO uint32_t SR;         /*!< NAND Flash FIFO status and interrupt register,     Address offset: 0x84 */
X  volatile uint32_t SR;          
N  __IO uint32_t PMEM;       /*!< NAND Flash Common memory space timing register,    Address offset: 0x88 */
X  volatile uint32_t PMEM;        
N  __IO uint32_t PATT;       /*!< NAND Flash Attribute memory space timing register, Address offset: 0x8C */
X  volatile uint32_t PATT;        
N  uint32_t      RESERVED0;  /*!< Reserved, 0x90                                                          */
N  __IO uint32_t ECCR;       /*!< NAND Flash ECC result registers,                   Address offset: 0x94 */
X  volatile uint32_t ECCR;        
N} FMC_Bank3_TypeDef;
N 
N/** 
N  * @brief Flexible Memory Controller Bank5_6
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t SDCR[2];        /*!< SDRAM Control registers ,      Address offset: 0x140-0x144  */
X  volatile uint32_t SDCR[2];         
N  __IO uint32_t SDTR[2];        /*!< SDRAM Timing registers ,       Address offset: 0x148-0x14C  */
X  volatile uint32_t SDTR[2];         
N  __IO uint32_t SDCMR;       /*!< SDRAM Command Mode register,    Address offset: 0x150  */
X  volatile uint32_t SDCMR;        
N  __IO uint32_t SDRTR;       /*!< SDRAM Refresh Timer register,   Address offset: 0x154  */
X  volatile uint32_t SDRTR;        
N  __IO uint32_t SDSR;        /*!< SDRAM Status register,          Address offset: 0x158  */
X  volatile uint32_t SDSR;         
N} FMC_Bank5_6_TypeDef; 
N
N
N/** 
N  * @brief General Purpose I/O
N  */
N
Ntypedef struct
N{
N  __IO uint32_t MODER;    /*!< GPIO port mode register,               Address offset: 0x00      */
X  volatile uint32_t MODER;     
N  __IO uint32_t OTYPER;   /*!< GPIO port output type register,        Address offset: 0x04      */
X  volatile uint32_t OTYPER;    
N  __IO uint32_t OSPEEDR;  /*!< GPIO port output speed register,       Address offset: 0x08      */
X  volatile uint32_t OSPEEDR;   
N  __IO uint32_t PUPDR;    /*!< GPIO port pull-up/pull-down register,  Address offset: 0x0C      */
X  volatile uint32_t PUPDR;     
N  __IO uint32_t IDR;      /*!< GPIO port input data register,         Address offset: 0x10      */
X  volatile uint32_t IDR;       
N  __IO uint32_t ODR;      /*!< GPIO port output data register,        Address offset: 0x14      */
X  volatile uint32_t ODR;       
N  __IO uint32_t BSRR;     /*!< GPIO port bit set/reset register,      Address offset: 0x18      */
X  volatile uint32_t BSRR;      
N  __IO uint32_t LCKR;     /*!< GPIO port configuration lock register, Address offset: 0x1C      */
X  volatile uint32_t LCKR;      
N  __IO uint32_t AFR[2];   /*!< GPIO alternate function registers,     Address offset: 0x20-0x24 */
X  volatile uint32_t AFR[2];    
N} GPIO_TypeDef;
N
N/** 
N  * @brief System configuration controller
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t MEMRMP;       /*!< SYSCFG memory remap register,                      Address offset: 0x00      */
X  volatile uint32_t MEMRMP;        
N  __IO uint32_t PMC;          /*!< SYSCFG peripheral mode configuration register,     Address offset: 0x04      */
X  volatile uint32_t PMC;           
N  __IO uint32_t EXTICR[4];    /*!< SYSCFG external interrupt configuration registers, Address offset: 0x08-0x14 */
X  volatile uint32_t EXTICR[4];     
N  uint32_t      RESERVED;     /*!< Reserved, 0x18                                                               */
N  __IO uint32_t CBR;          /*!< SYSCFG Class B register,                           Address offset: 0x1C      */
X  volatile uint32_t CBR;           
N  __IO uint32_t CMPCR;        /*!< SYSCFG Compensation cell control register,         Address offset: 0x20      */
X  volatile uint32_t CMPCR;         
N} SYSCFG_TypeDef;
N
N/** 
N  * @brief Inter-integrated Circuit Interface
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR1;      /*!< I2C Control register 1,            Address offset: 0x00 */
X  volatile uint32_t CR1;       
N  __IO uint32_t CR2;      /*!< I2C Control register 2,            Address offset: 0x04 */  
X  volatile uint32_t CR2;         
N  __IO uint32_t OAR1;     /*!< I2C Own address 1 register,        Address offset: 0x08 */
X  volatile uint32_t OAR1;      
N  __IO uint32_t OAR2;     /*!< I2C Own address 2 register,        Address offset: 0x0C */
X  volatile uint32_t OAR2;      
N  __IO uint32_t TIMINGR;  /*!< I2C Timing register,               Address offset: 0x10 */
X  volatile uint32_t TIMINGR;   
N  __IO uint32_t TIMEOUTR; /*!< I2C Timeout register,              Address offset: 0x14 */
X  volatile uint32_t TIMEOUTR;  
N  __IO uint32_t ISR;      /*!< I2C Interrupt and status register, Address offset: 0x18 */
X  volatile uint32_t ISR;       
N  __IO uint32_t ICR;      /*!< I2C Interrupt clear register,      Address offset: 0x1C */
X  volatile uint32_t ICR;       
N  __IO uint32_t PECR;     /*!< I2C PEC register,                  Address offset: 0x20 */
X  volatile uint32_t PECR;      
N  __IO uint32_t RXDR;     /*!< I2C Receive data register,         Address offset: 0x24 */
X  volatile uint32_t RXDR;      
N  __IO uint32_t TXDR;     /*!< I2C Transmit data register,        Address offset: 0x28 */  
X  volatile uint32_t TXDR;        
N} I2C_TypeDef;
N
N/** 
N  * @brief Independent WATCHDOG
N  */
N
Ntypedef struct
N{
N  __IO uint32_t KR;   /*!< IWDG Key register,       Address offset: 0x00 */
X  volatile uint32_t KR;    
N  __IO uint32_t PR;   /*!< IWDG Prescaler register, Address offset: 0x04 */
X  volatile uint32_t PR;    
N  __IO uint32_t RLR;  /*!< IWDG Reload register,    Address offset: 0x08 */
X  volatile uint32_t RLR;   
N  __IO uint32_t SR;   /*!< IWDG Status register,    Address offset: 0x0C */
X  volatile uint32_t SR;    
N  __IO uint32_t WINR; /*!< IWDG Window register,    Address offset: 0x10 */
X  volatile uint32_t WINR;  
N} IWDG_TypeDef;
N
N
N/** 
N  * @brief LCD-TFT Display Controller
N  */
N  
Ntypedef struct
N{
N  uint32_t      RESERVED0[2];  /*!< Reserved, 0x00-0x04 */
N  __IO uint32_t SSCR;          /*!< LTDC Synchronization Size Configuration Register,    Address offset: 0x08 */
X  volatile uint32_t SSCR;           
N  __IO uint32_t BPCR;          /*!< LTDC Back Porch Configuration Register,              Address offset: 0x0C */
X  volatile uint32_t BPCR;           
N  __IO uint32_t AWCR;          /*!< LTDC Active Width Configuration Register,            Address offset: 0x10 */
X  volatile uint32_t AWCR;           
N  __IO uint32_t TWCR;          /*!< LTDC Total Width Configuration Register,             Address offset: 0x14 */
X  volatile uint32_t TWCR;           
N  __IO uint32_t GCR;           /*!< LTDC Global Control Register,                        Address offset: 0x18 */
X  volatile uint32_t GCR;            
N  uint32_t      RESERVED1[2];  /*!< Reserved, 0x1C-0x20 */
N  __IO uint32_t SRCR;          /*!< LTDC Shadow Reload Configuration Register,           Address offset: 0x24 */
X  volatile uint32_t SRCR;           
N  uint32_t      RESERVED2[1];  /*!< Reserved, 0x28 */
N  __IO uint32_t BCCR;          /*!< LTDC Background Color Configuration Register,        Address offset: 0x2C */
X  volatile uint32_t BCCR;           
N  uint32_t      RESERVED3[1];  /*!< Reserved, 0x30 */
N  __IO uint32_t IER;           /*!< LTDC Interrupt Enable Register,                      Address offset: 0x34 */
X  volatile uint32_t IER;            
N  __IO uint32_t ISR;           /*!< LTDC Interrupt Status Register,                      Address offset: 0x38 */
X  volatile uint32_t ISR;            
N  __IO uint32_t ICR;           /*!< LTDC Interrupt Clear Register,                       Address offset: 0x3C */
X  volatile uint32_t ICR;            
N  __IO uint32_t LIPCR;         /*!< LTDC Line Interrupt Position Configuration Register, Address offset: 0x40 */
X  volatile uint32_t LIPCR;          
N  __IO uint32_t CPSR;          /*!< LTDC Current Position Status Register,               Address offset: 0x44 */
X  volatile uint32_t CPSR;           
N  __IO uint32_t CDSR;         /*!< LTDC Current Display Status Register,                 Address offset: 0x48 */
X  volatile uint32_t CDSR;          
N} LTDC_TypeDef;  
N
N/** 
N  * @brief LCD-TFT Display layer x Controller
N  */
N  
Ntypedef struct
N{  
N  __IO uint32_t CR;            /*!< LTDC Layerx Control Register                                  Address offset: 0x84 */
X  volatile uint32_t CR;             
N  __IO uint32_t WHPCR;         /*!< LTDC Layerx Window Horizontal Position Configuration Register Address offset: 0x88 */
X  volatile uint32_t WHPCR;          
N  __IO uint32_t WVPCR;         /*!< LTDC Layerx Window Vertical Position Configuration Register   Address offset: 0x8C */
X  volatile uint32_t WVPCR;          
N  __IO uint32_t CKCR;          /*!< LTDC Layerx Color Keying Configuration Register               Address offset: 0x90 */
X  volatile uint32_t CKCR;           
N  __IO uint32_t PFCR;          /*!< LTDC Layerx Pixel Format Configuration Register               Address offset: 0x94 */
X  volatile uint32_t PFCR;           
N  __IO uint32_t CACR;          /*!< LTDC Layerx Constant Alpha Configuration Register             Address offset: 0x98 */
X  volatile uint32_t CACR;           
N  __IO uint32_t DCCR;          /*!< LTDC Layerx Default Color Configuration Register              Address offset: 0x9C */
X  volatile uint32_t DCCR;           
N  __IO uint32_t BFCR;          /*!< LTDC Layerx Blending Factors Configuration Register           Address offset: 0xA0 */
X  volatile uint32_t BFCR;           
N  uint32_t      RESERVED0[2];  /*!< Reserved */
N  __IO uint32_t CFBAR;         /*!< LTDC Layerx Color Frame Buffer Address Register               Address offset: 0xAC */
X  volatile uint32_t CFBAR;          
N  __IO uint32_t CFBLR;         /*!< LTDC Layerx Color Frame Buffer Length Register                Address offset: 0xB0 */
X  volatile uint32_t CFBLR;          
N  __IO uint32_t CFBLNR;        /*!< LTDC Layerx ColorFrame Buffer Line Number Register            Address offset: 0xB4 */
X  volatile uint32_t CFBLNR;         
N  uint32_t      RESERVED1[3];  /*!< Reserved */
N  __IO uint32_t CLUTWR;        /*!< LTDC Layerx CLUT Write Register                               Address offset: 0x144 */
X  volatile uint32_t CLUTWR;         
N
N} LTDC_Layer_TypeDef;
N
N/** 
N  * @brief Power Control
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR1;   /*!< PWR power control register 1,        Address offset: 0x00 */
X  volatile uint32_t CR1;    
N  __IO uint32_t CSR1;  /*!< PWR power control/status register 2, Address offset: 0x04 */
X  volatile uint32_t CSR1;   
N  __IO uint32_t CR2;   /*!< PWR power control register 2,        Address offset: 0x08 */
X  volatile uint32_t CR2;    
N  __IO uint32_t CSR2;  /*!< PWR power control/status register 2, Address offset: 0x0C */
X  volatile uint32_t CSR2;   
N} PWR_TypeDef;
N
N
N/** 
N  * @brief Reset and Clock Control
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;            /*!< RCC clock control register,                                  Address offset: 0x00 */
X  volatile uint32_t CR;             
N  __IO uint32_t PLLCFGR;       /*!< RCC PLL configuration register,                              Address offset: 0x04 */
X  volatile uint32_t PLLCFGR;        
N  __IO uint32_t CFGR;          /*!< RCC clock configuration register,                            Address offset: 0x08 */
X  volatile uint32_t CFGR;           
N  __IO uint32_t CIR;           /*!< RCC clock interrupt register,                                Address offset: 0x0C */
X  volatile uint32_t CIR;            
N  __IO uint32_t AHB1RSTR;      /*!< RCC AHB1 peripheral reset register,                          Address offset: 0x10 */
X  volatile uint32_t AHB1RSTR;       
N  __IO uint32_t AHB2RSTR;      /*!< RCC AHB2 peripheral reset register,                          Address offset: 0x14 */
X  volatile uint32_t AHB2RSTR;       
N  __IO uint32_t AHB3RSTR;      /*!< RCC AHB3 peripheral reset register,                          Address offset: 0x18 */
X  volatile uint32_t AHB3RSTR;       
N  uint32_t      RESERVED0;     /*!< Reserved, 0x1C                                                                    */
N  __IO uint32_t APB1RSTR;      /*!< RCC APB1 peripheral reset register,                          Address offset: 0x20 */
X  volatile uint32_t APB1RSTR;       
N  __IO uint32_t APB2RSTR;      /*!< RCC APB2 peripheral reset register,                          Address offset: 0x24 */
X  volatile uint32_t APB2RSTR;       
N  uint32_t      RESERVED1[2];  /*!< Reserved, 0x28-0x2C                                                               */
N  __IO uint32_t AHB1ENR;       /*!< RCC AHB1 peripheral clock register,                          Address offset: 0x30 */
X  volatile uint32_t AHB1ENR;        
N  __IO uint32_t AHB2ENR;       /*!< RCC AHB2 peripheral clock register,                          Address offset: 0x34 */
X  volatile uint32_t AHB2ENR;        
N  __IO uint32_t AHB3ENR;       /*!< RCC AHB3 peripheral clock register,                          Address offset: 0x38 */
X  volatile uint32_t AHB3ENR;        
N  uint32_t      RESERVED2;     /*!< Reserved, 0x3C                                                                    */
N  __IO uint32_t APB1ENR;       /*!< RCC APB1 peripheral clock enable register,                   Address offset: 0x40 */
X  volatile uint32_t APB1ENR;        
N  __IO uint32_t APB2ENR;       /*!< RCC APB2 peripheral clock enable register,                   Address offset: 0x44 */
X  volatile uint32_t APB2ENR;        
N  uint32_t      RESERVED3[2];  /*!< Reserved, 0x48-0x4C                                                               */
N  __IO uint32_t AHB1LPENR;     /*!< RCC AHB1 peripheral clock enable in low power mode register, Address offset: 0x50 */
X  volatile uint32_t AHB1LPENR;      
N  __IO uint32_t AHB2LPENR;     /*!< RCC AHB2 peripheral clock enable in low power mode register, Address offset: 0x54 */
X  volatile uint32_t AHB2LPENR;      
N  __IO uint32_t AHB3LPENR;     /*!< RCC AHB3 peripheral clock enable in low power mode register, Address offset: 0x58 */
X  volatile uint32_t AHB3LPENR;      
N  uint32_t      RESERVED4;     /*!< Reserved, 0x5C                                                                    */
N  __IO uint32_t APB1LPENR;     /*!< RCC APB1 peripheral clock enable in low power mode register, Address offset: 0x60 */
X  volatile uint32_t APB1LPENR;      
N  __IO uint32_t APB2LPENR;     /*!< RCC APB2 peripheral clock enable in low power mode register, Address offset: 0x64 */
X  volatile uint32_t APB2LPENR;      
N  uint32_t      RESERVED5[2];  /*!< Reserved, 0x68-0x6C                                                               */
N  __IO uint32_t BDCR;          /*!< RCC Backup domain control register,                          Address offset: 0x70 */
X  volatile uint32_t BDCR;           
N  __IO uint32_t CSR;           /*!< RCC clock control & status register,                         Address offset: 0x74 */
X  volatile uint32_t CSR;            
N  uint32_t      RESERVED6[2];  /*!< Reserved, 0x78-0x7C                                                               */
N  __IO uint32_t SSCGR;         /*!< RCC spread spectrum clock generation register,               Address offset: 0x80 */
X  volatile uint32_t SSCGR;          
N  __IO uint32_t PLLI2SCFGR;    /*!< RCC PLLI2S configuration register,                           Address offset: 0x84 */
X  volatile uint32_t PLLI2SCFGR;     
N  __IO uint32_t PLLSAICFGR;    /*!< RCC PLLSAI configuration register,                           Address offset: 0x88 */
X  volatile uint32_t PLLSAICFGR;     
N  __IO uint32_t DCKCFGR1;      /*!< RCC Dedicated Clocks configuration register1,                 Address offset: 0x8C */
X  volatile uint32_t DCKCFGR1;       
N  __IO uint32_t DCKCFGR2;      /*!< RCC Dedicated Clocks configuration register 2,               Address offset: 0x90 */
X  volatile uint32_t DCKCFGR2;       
N
N} RCC_TypeDef;
N
N/** 
N  * @brief Real-Time Clock
N  */
N
Ntypedef struct
N{
N  __IO uint32_t TR;         /*!< RTC time register,                                         Address offset: 0x00 */
X  volatile uint32_t TR;          
N  __IO uint32_t DR;         /*!< RTC date register,                                         Address offset: 0x04 */
X  volatile uint32_t DR;          
N  __IO uint32_t CR;         /*!< RTC control register,                                      Address offset: 0x08 */                                                                                            
X  volatile uint32_t CR;                                                                                                      
N  __IO uint32_t ISR;        /*!< RTC initialization and status register,                    Address offset: 0x0C */
X  volatile uint32_t ISR;         
N  __IO uint32_t PRER;       /*!< RTC prescaler register,                                    Address offset: 0x10 */
X  volatile uint32_t PRER;        
N  __IO uint32_t WUTR;       /*!< RTC wakeup timer register,                                 Address offset: 0x14 */
X  volatile uint32_t WUTR;        
N       uint32_t reserved;   /*!< Reserved  */
N  __IO uint32_t ALRMAR;     /*!< RTC alarm A register,                                      Address offset: 0x1C */
X  volatile uint32_t ALRMAR;      
N  __IO uint32_t ALRMBR;     /*!< RTC alarm B register,                                      Address offset: 0x20 */
X  volatile uint32_t ALRMBR;      
N  __IO uint32_t WPR;        /*!< RTC write protection register,                             Address offset: 0x24 */
X  volatile uint32_t WPR;         
N  __IO uint32_t SSR;        /*!< RTC sub second register,                                   Address offset: 0x28 */
X  volatile uint32_t SSR;         
N  __IO uint32_t SHIFTR;     /*!< RTC shift control register,                                Address offset: 0x2C */
X  volatile uint32_t SHIFTR;      
N  __IO uint32_t TSTR;       /*!< RTC time stamp time register,                              Address offset: 0x30 */
X  volatile uint32_t TSTR;        
N  __IO uint32_t TSDR;       /*!< RTC time stamp date register,                              Address offset: 0x34 */
X  volatile uint32_t TSDR;        
N  __IO uint32_t TSSSR;      /*!< RTC time-stamp sub second register,                        Address offset: 0x38 */
X  volatile uint32_t TSSSR;       
N  __IO uint32_t CALR;       /*!< RTC calibration register,                                  Address offset: 0x3C */
X  volatile uint32_t CALR;        
N  __IO uint32_t TAMPCR;     /*!< RTC tamper configuration register,                         Address offset: 0x40 */
X  volatile uint32_t TAMPCR;      
N  __IO uint32_t ALRMASSR;   /*!< RTC alarm A sub second register,                           Address offset: 0x44 */
X  volatile uint32_t ALRMASSR;    
N  __IO uint32_t ALRMBSSR;   /*!< RTC alarm B sub second register,                           Address offset: 0x48 */
X  volatile uint32_t ALRMBSSR;    
N  __IO uint32_t OR;         /*!< RTC option register,                                       Address offset: 0x4C */
X  volatile uint32_t OR;          
N  __IO uint32_t BKP0R;      /*!< RTC backup register 0,                                     Address offset: 0x50 */
X  volatile uint32_t BKP0R;       
N  __IO uint32_t BKP1R;      /*!< RTC backup register 1,                                     Address offset: 0x54 */
X  volatile uint32_t BKP1R;       
N  __IO uint32_t BKP2R;      /*!< RTC backup register 2,                                     Address offset: 0x58 */
X  volatile uint32_t BKP2R;       
N  __IO uint32_t BKP3R;      /*!< RTC backup register 3,                                     Address offset: 0x5C */
X  volatile uint32_t BKP3R;       
N  __IO uint32_t BKP4R;      /*!< RTC backup register 4,                                     Address offset: 0x60 */
X  volatile uint32_t BKP4R;       
N  __IO uint32_t BKP5R;      /*!< RTC backup register 5,                                     Address offset: 0x64 */
X  volatile uint32_t BKP5R;       
N  __IO uint32_t BKP6R;      /*!< RTC backup register 6,                                     Address offset: 0x68 */
X  volatile uint32_t BKP6R;       
N  __IO uint32_t BKP7R;      /*!< RTC backup register 7,                                     Address offset: 0x6C */
X  volatile uint32_t BKP7R;       
N  __IO uint32_t BKP8R;      /*!< RTC backup register 8,                                     Address offset: 0x70 */
X  volatile uint32_t BKP8R;       
N  __IO uint32_t BKP9R;      /*!< RTC backup register 9,                                     Address offset: 0x74 */
X  volatile uint32_t BKP9R;       
N  __IO uint32_t BKP10R;     /*!< RTC backup register 10,                                    Address offset: 0x78 */
X  volatile uint32_t BKP10R;      
N  __IO uint32_t BKP11R;     /*!< RTC backup register 11,                                    Address offset: 0x7C */
X  volatile uint32_t BKP11R;      
N  __IO uint32_t BKP12R;     /*!< RTC backup register 12,                                    Address offset: 0x80 */
X  volatile uint32_t BKP12R;      
N  __IO uint32_t BKP13R;     /*!< RTC backup register 13,                                    Address offset: 0x84 */
X  volatile uint32_t BKP13R;      
N  __IO uint32_t BKP14R;     /*!< RTC backup register 14,                                    Address offset: 0x88 */
X  volatile uint32_t BKP14R;      
N  __IO uint32_t BKP15R;     /*!< RTC backup register 15,                                    Address offset: 0x8C */
X  volatile uint32_t BKP15R;      
N  __IO uint32_t BKP16R;     /*!< RTC backup register 16,                                    Address offset: 0x90 */
X  volatile uint32_t BKP16R;      
N  __IO uint32_t BKP17R;     /*!< RTC backup register 17,                                    Address offset: 0x94 */
X  volatile uint32_t BKP17R;      
N  __IO uint32_t BKP18R;     /*!< RTC backup register 18,                                    Address offset: 0x98 */
X  volatile uint32_t BKP18R;      
N  __IO uint32_t BKP19R;     /*!< RTC backup register 19,                                    Address offset: 0x9C */
X  volatile uint32_t BKP19R;      
N  __IO uint32_t BKP20R;     /*!< RTC backup register 20,                                    Address offset: 0xA0 */
X  volatile uint32_t BKP20R;      
N  __IO uint32_t BKP21R;     /*!< RTC backup register 21,                                    Address offset: 0xA4 */
X  volatile uint32_t BKP21R;      
N  __IO uint32_t BKP22R;     /*!< RTC backup register 22,                                    Address offset: 0xA8 */
X  volatile uint32_t BKP22R;      
N  __IO uint32_t BKP23R;     /*!< RTC backup register 23,                                    Address offset: 0xAC */
X  volatile uint32_t BKP23R;      
N  __IO uint32_t BKP24R;     /*!< RTC backup register 24,                                    Address offset: 0xB0 */
X  volatile uint32_t BKP24R;      
N  __IO uint32_t BKP25R;     /*!< RTC backup register 25,                                    Address offset: 0xB4 */
X  volatile uint32_t BKP25R;      
N  __IO uint32_t BKP26R;     /*!< RTC backup register 26,                                    Address offset: 0xB8 */
X  volatile uint32_t BKP26R;      
N  __IO uint32_t BKP27R;     /*!< RTC backup register 27,                                    Address offset: 0xBC */
X  volatile uint32_t BKP27R;      
N  __IO uint32_t BKP28R;     /*!< RTC backup register 28,                                    Address offset: 0xC0 */
X  volatile uint32_t BKP28R;      
N  __IO uint32_t BKP29R;     /*!< RTC backup register 29,                                    Address offset: 0xC4 */
X  volatile uint32_t BKP29R;      
N  __IO uint32_t BKP30R;     /*!< RTC backup register 30,                                    Address offset: 0xC8 */
X  volatile uint32_t BKP30R;      
N  __IO uint32_t BKP31R;     /*!< RTC backup register 31,                                    Address offset: 0xCC */
X  volatile uint32_t BKP31R;      
N} RTC_TypeDef;
N
N
N/** 
N  * @brief Serial Audio Interface
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t GCR;      /*!< SAI global configuration register,        Address offset: 0x00 */
X  volatile uint32_t GCR;       
N} SAI_TypeDef;
N
Ntypedef struct
N{
N  __IO uint32_t CR1;      /*!< SAI block x configuration register 1,     Address offset: 0x04 */
X  volatile uint32_t CR1;       
N  __IO uint32_t CR2;      /*!< SAI block x configuration register 2,     Address offset: 0x08 */
X  volatile uint32_t CR2;       
N  __IO uint32_t FRCR;     /*!< SAI block x frame configuration register, Address offset: 0x0C */
X  volatile uint32_t FRCR;      
N  __IO uint32_t SLOTR;    /*!< SAI block x slot register,                Address offset: 0x10 */
X  volatile uint32_t SLOTR;     
N  __IO uint32_t IMR;      /*!< SAI block x interrupt mask register,      Address offset: 0x14 */
X  volatile uint32_t IMR;       
N  __IO uint32_t SR;       /*!< SAI block x status register,              Address offset: 0x18 */
X  volatile uint32_t SR;        
N  __IO uint32_t CLRFR;    /*!< SAI block x clear flag register,          Address offset: 0x1C */
X  volatile uint32_t CLRFR;     
N  __IO uint32_t DR;       /*!< SAI block x data register,                Address offset: 0x20 */
X  volatile uint32_t DR;        
N} SAI_Block_TypeDef;
N
N/** 
N  * @brief SPDIF-RX Interface
N  */
N
Ntypedef struct
N{
N  __IO uint32_t   CR;           /*!< Control register,                   Address offset: 0x00 */
X  volatile uint32_t   CR;            
N  __IO uint32_t   IMR;          /*!< Interrupt mask register,            Address offset: 0x04 */  
X  volatile uint32_t   IMR;             
N  __IO uint32_t   SR;           /*!< Status register,                    Address offset: 0x08 */
X  volatile uint32_t   SR;            
N  __IO uint32_t   IFCR;         /*!< Interrupt Flag Clear register,      Address offset: 0x0C */ 
X  volatile uint32_t   IFCR;           
N  __IO uint32_t   DR;           /*!< Data input register,                Address offset: 0x10 */
X  volatile uint32_t   DR;            
N  __IO uint32_t   CSR;          /*!< Channel Status register,            Address offset: 0x14 */
X  volatile uint32_t   CSR;           
N  __IO uint32_t   DIR;          /*!< Debug Information register,         Address offset: 0x18 */
X  volatile uint32_t   DIR;           
N} SPDIFRX_TypeDef;
N
N
N/** 
N  * @brief SD host Interface
N  */
N
Ntypedef struct
N{
N  __IO uint32_t POWER;          /*!< SDMMC power control register,    Address offset: 0x00 */
X  volatile uint32_t POWER;           
N  __IO uint32_t CLKCR;          /*!< SDMMClock control register,     Address offset: 0x04 */
X  volatile uint32_t CLKCR;           
N  __IO uint32_t ARG;            /*!< SDMMC argument register,         Address offset: 0x08 */
X  volatile uint32_t ARG;             
N  __IO uint32_t CMD;            /*!< SDMMC command register,          Address offset: 0x0C */
X  volatile uint32_t CMD;             
N  __I uint32_t  RESPCMD;        /*!< SDMMC command response register, Address offset: 0x10 */
X  volatile const uint32_t  RESPCMD;         
N  __I uint32_t  RESP1;          /*!< SDMMC response 1 register,       Address offset: 0x14 */
X  volatile const uint32_t  RESP1;           
N  __I uint32_t  RESP2;          /*!< SDMMC response 2 register,       Address offset: 0x18 */
X  volatile const uint32_t  RESP2;           
N  __I uint32_t  RESP3;          /*!< SDMMC response 3 register,       Address offset: 0x1C */
X  volatile const uint32_t  RESP3;           
N  __I uint32_t  RESP4;          /*!< SDMMC response 4 register,       Address offset: 0x20 */
X  volatile const uint32_t  RESP4;           
N  __IO uint32_t DTIMER;         /*!< SDMMC data timer register,       Address offset: 0x24 */
X  volatile uint32_t DTIMER;          
N  __IO uint32_t DLEN;           /*!< SDMMC data length register,      Address offset: 0x28 */
X  volatile uint32_t DLEN;            
N  __IO uint32_t DCTRL;          /*!< SDMMC data control register,     Address offset: 0x2C */
X  volatile uint32_t DCTRL;           
N  __I uint32_t  DCOUNT;         /*!< SDMMC data counter register,     Address offset: 0x30 */
X  volatile const uint32_t  DCOUNT;          
N  __I uint32_t  STA;            /*!< SDMMC status register,           Address offset: 0x34 */
X  volatile const uint32_t  STA;             
N  __IO uint32_t ICR;            /*!< SDMMC interrupt clear register,  Address offset: 0x38 */
X  volatile uint32_t ICR;             
N  __IO uint32_t MASK;           /*!< SDMMC mask register,             Address offset: 0x3C */
X  volatile uint32_t MASK;            
N  uint32_t      RESERVED0[2];   /*!< Reserved, 0x40-0x44                                  */
N  __I uint32_t  FIFOCNT;        /*!< SDMMC FIFO counter register,     Address offset: 0x48 */
X  volatile const uint32_t  FIFOCNT;         
N  uint32_t      RESERVED1[13];  /*!< Reserved, 0x4C-0x7C                                  */
N  __IO uint32_t FIFO;           /*!< SDMMC data FIFO register,        Address offset: 0x80 */
X  volatile uint32_t FIFO;            
N} SDMMC_TypeDef;
N
N/** 
N  * @brief Serial Peripheral Interface
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR1;        /*!< SPI control register 1 (not used in I2S mode),      Address offset: 0x00 */
X  volatile uint32_t CR1;         
N  __IO uint32_t CR2;        /*!< SPI control register 2,                             Address offset: 0x04 */
X  volatile uint32_t CR2;         
N  __IO uint32_t SR;         /*!< SPI status register,                                Address offset: 0x08 */
X  volatile uint32_t SR;          
N  __IO uint32_t DR;         /*!< SPI data register,                                  Address offset: 0x0C */
X  volatile uint32_t DR;          
N  __IO uint32_t CRCPR;      /*!< SPI CRC polynomial register (not used in I2S mode), Address offset: 0x10 */
X  volatile uint32_t CRCPR;       
N  __IO uint32_t RXCRCR;     /*!< SPI RX CRC register (not used in I2S mode),         Address offset: 0x14 */
X  volatile uint32_t RXCRCR;      
N  __IO uint32_t TXCRCR;     /*!< SPI TX CRC register (not used in I2S mode),         Address offset: 0x18 */
X  volatile uint32_t TXCRCR;      
N  __IO uint32_t I2SCFGR;    /*!< SPI_I2S configuration register,                     Address offset: 0x1C */
X  volatile uint32_t I2SCFGR;     
N  __IO uint32_t I2SPR;      /*!< SPI_I2S prescaler register,                         Address offset: 0x20 */
X  volatile uint32_t I2SPR;       
N} SPI_TypeDef;
N
N/** 
N  * @brief QUAD Serial Peripheral Interface
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;       /*!< QUADSPI Control register,                           Address offset: 0x00 */
X  volatile uint32_t CR;        
N  __IO uint32_t DCR;      /*!< QUADSPI Device Configuration register,              Address offset: 0x04 */
X  volatile uint32_t DCR;       
N  __IO uint32_t SR;       /*!< QUADSPI Status register,                            Address offset: 0x08 */
X  volatile uint32_t SR;        
N  __IO uint32_t FCR;      /*!< QUADSPI Flag Clear register,                        Address offset: 0x0C */
X  volatile uint32_t FCR;       
N  __IO uint32_t DLR;      /*!< QUADSPI Data Length register,                       Address offset: 0x10 */
X  volatile uint32_t DLR;       
N  __IO uint32_t CCR;      /*!< QUADSPI Communication Configuration register,       Address offset: 0x14 */
X  volatile uint32_t CCR;       
N  __IO uint32_t AR;       /*!< QUADSPI Address register,                           Address offset: 0x18 */
X  volatile uint32_t AR;        
N  __IO uint32_t ABR;      /*!< QUADSPI Alternate Bytes register,                   Address offset: 0x1C */
X  volatile uint32_t ABR;       
N  __IO uint32_t DR;       /*!< QUADSPI Data register,                              Address offset: 0x20 */
X  volatile uint32_t DR;        
N  __IO uint32_t PSMKR;    /*!< QUADSPI Polling Status Mask register,               Address offset: 0x24 */
X  volatile uint32_t PSMKR;     
N  __IO uint32_t PSMAR;    /*!< QUADSPI Polling Status Match register,              Address offset: 0x28 */                  
X  volatile uint32_t PSMAR;                       
N  __IO uint32_t PIR;      /*!< QUADSPI Polling Interval register,                  Address offset: 0x2C */
X  volatile uint32_t PIR;       
N  __IO uint32_t LPTR;     /*!< QUADSPI Low Power Timeout register,                 Address offset: 0x30 */    
X  volatile uint32_t LPTR;          
N} QUADSPI_TypeDef;
N
N/** 
N  * @brief TIM
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR1;         /*!< TIM control register 1,              Address offset: 0x00 */
X  volatile uint32_t CR1;          
N  __IO uint32_t CR2;         /*!< TIM control register 2,              Address offset: 0x04 */
X  volatile uint32_t CR2;          
N  __IO uint32_t SMCR;        /*!< TIM slave mode control register,     Address offset: 0x08 */
X  volatile uint32_t SMCR;         
N  __IO uint32_t DIER;        /*!< TIM DMA/interrupt enable register,   Address offset: 0x0C */
X  volatile uint32_t DIER;         
N  __IO uint32_t SR;          /*!< TIM status register,                 Address offset: 0x10 */
X  volatile uint32_t SR;           
N  __IO uint32_t EGR;         /*!< TIM event generation register,       Address offset: 0x14 */
X  volatile uint32_t EGR;          
N  __IO uint32_t CCMR1;       /*!< TIM capture/compare mode register 1, Address offset: 0x18 */
X  volatile uint32_t CCMR1;        
N  __IO uint32_t CCMR2;       /*!< TIM capture/compare mode register 2, Address offset: 0x1C */
X  volatile uint32_t CCMR2;        
N  __IO uint32_t CCER;        /*!< TIM capture/compare enable register, Address offset: 0x20 */
X  volatile uint32_t CCER;         
N  __IO uint32_t CNT;         /*!< TIM counter register,                Address offset: 0x24 */
X  volatile uint32_t CNT;          
N  __IO uint32_t PSC;         /*!< TIM prescaler,                       Address offset: 0x28 */
X  volatile uint32_t PSC;          
N  __IO uint32_t ARR;         /*!< TIM auto-reload register,            Address offset: 0x2C */
X  volatile uint32_t ARR;          
N  __IO uint32_t RCR;         /*!< TIM repetition counter register,     Address offset: 0x30 */
X  volatile uint32_t RCR;          
N  __IO uint32_t CCR1;        /*!< TIM capture/compare register 1,      Address offset: 0x34 */
X  volatile uint32_t CCR1;         
N  __IO uint32_t CCR2;        /*!< TIM capture/compare register 2,      Address offset: 0x38 */
X  volatile uint32_t CCR2;         
N  __IO uint32_t CCR3;        /*!< TIM capture/compare register 3,      Address offset: 0x3C */
X  volatile uint32_t CCR3;         
N  __IO uint32_t CCR4;        /*!< TIM capture/compare register 4,      Address offset: 0x40 */
X  volatile uint32_t CCR4;         
N  __IO uint32_t BDTR;        /*!< TIM break and dead-time register,    Address offset: 0x44 */
X  volatile uint32_t BDTR;         
N  __IO uint32_t DCR;         /*!< TIM DMA control register,            Address offset: 0x48 */
X  volatile uint32_t DCR;          
N  __IO uint32_t DMAR;        /*!< TIM DMA address for full transfer,   Address offset: 0x4C */
X  volatile uint32_t DMAR;         
N  __IO uint32_t OR;          /*!< TIM option register,                 Address offset: 0x50 */
X  volatile uint32_t OR;           
N  __IO uint32_t CCMR3;       /*!< TIM capture/compare mode register 3,      Address offset: 0x54 */
X  volatile uint32_t CCMR3;        
N  __IO uint32_t CCR5;        /*!< TIM capture/compare mode register5,       Address offset: 0x58 */
X  volatile uint32_t CCR5;         
N  __IO uint32_t CCR6;        /*!< TIM capture/compare mode register6,       Address offset: 0x5C */
X  volatile uint32_t CCR6;         
N  __IO uint32_t AF1;         /*!< TIM Alternate function option register 1, Address offset: 0x60 */
X  volatile uint32_t AF1;          
N  __IO uint32_t AF2;         /*!< TIM Alternate function option register 2, Address offset: 0x64 */
X  volatile uint32_t AF2;          
N
N} TIM_TypeDef;
N
N/** 
N  * @brief LPTIMIMER
N  */
Ntypedef struct
N{
N  __IO uint32_t ISR;      /*!< LPTIM Interrupt and Status register,                Address offset: 0x00 */
X  volatile uint32_t ISR;       
N  __IO uint32_t ICR;      /*!< LPTIM Interrupt Clear register,                     Address offset: 0x04 */
X  volatile uint32_t ICR;       
N  __IO uint32_t IER;      /*!< LPTIM Interrupt Enable register,                    Address offset: 0x08 */
X  volatile uint32_t IER;       
N  __IO uint32_t CFGR;     /*!< LPTIM Configuration register,                       Address offset: 0x0C */
X  volatile uint32_t CFGR;      
N  __IO uint32_t CR;       /*!< LPTIM Control register,                             Address offset: 0x10 */
X  volatile uint32_t CR;        
N  __IO uint32_t CMP;      /*!< LPTIM Compare register,                             Address offset: 0x14 */
X  volatile uint32_t CMP;       
N  __IO uint32_t ARR;      /*!< LPTIM Autoreload register,                          Address offset: 0x18 */
X  volatile uint32_t ARR;       
N  __IO uint32_t CNT;      /*!< LPTIM Counter register,                             Address offset: 0x1C */
X  volatile uint32_t CNT;       
N} LPTIM_TypeDef;
N
N
N/** 
N  * @brief Universal Synchronous Asynchronous Receiver Transmitter
N  */
N 
Ntypedef struct
N{
N  __IO uint32_t CR1;    /*!< USART Control register 1,                 Address offset: 0x00 */ 
X  volatile uint32_t CR1;      
N  __IO uint32_t CR2;    /*!< USART Control register 2,                 Address offset: 0x04 */ 
X  volatile uint32_t CR2;      
N  __IO uint32_t CR3;    /*!< USART Control register 3,                 Address offset: 0x08 */
X  volatile uint32_t CR3;     
N  __IO uint32_t BRR;    /*!< USART Baud rate register,                 Address offset: 0x0C */                                               
X  volatile uint32_t BRR;                                                    
N  __IO uint32_t GTPR;   /*!< USART Guard time and prescaler register,  Address offset: 0x10 */
X  volatile uint32_t GTPR;    
N  __IO uint32_t RTOR;   /*!< USART Receiver Time Out register,         Address offset: 0x14 */  
X  volatile uint32_t RTOR;      
N  __IO uint32_t RQR;    /*!< USART Request register,                   Address offset: 0x18 */
X  volatile uint32_t RQR;     
N  __IO uint32_t ISR;    /*!< USART Interrupt and status register,      Address offset: 0x1C */
X  volatile uint32_t ISR;     
N  __IO uint32_t ICR;    /*!< USART Interrupt flag Clear register,      Address offset: 0x20 */
X  volatile uint32_t ICR;     
N  __IO uint32_t RDR;    /*!< USART Receive Data register,              Address offset: 0x24 */
X  volatile uint32_t RDR;     
N  __IO uint32_t TDR;    /*!< USART Transmit Data register,             Address offset: 0x28 */
X  volatile uint32_t TDR;     
N} USART_TypeDef;
N
N
N/** 
N  * @brief Window WATCHDOG
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;   /*!< WWDG Control register,       Address offset: 0x00 */
X  volatile uint32_t CR;    
N  __IO uint32_t CFR;  /*!< WWDG Configuration register, Address offset: 0x04 */
X  volatile uint32_t CFR;   
N  __IO uint32_t SR;   /*!< WWDG Status register,        Address offset: 0x08 */
X  volatile uint32_t SR;    
N} WWDG_TypeDef;
N
N
N/** 
N  * @brief RNG
N  */
N  
Ntypedef struct 
N{
N  __IO uint32_t CR;  /*!< RNG control register, Address offset: 0x00 */
X  volatile uint32_t CR;   
N  __IO uint32_t SR;  /*!< RNG status register,  Address offset: 0x04 */
X  volatile uint32_t SR;   
N  __IO uint32_t DR;  /*!< RNG data register,    Address offset: 0x08 */
X  volatile uint32_t DR;   
N} RNG_TypeDef;
N
N/**
N  * @}
N  */
N
N/** 
N  * @brief USB_OTG_Core_Registers
N  */
Ntypedef struct
N{
N __IO uint32_t GOTGCTL;               /*!< USB_OTG Control and Status Register          000h */
X volatile uint32_t GOTGCTL;                
N  __IO uint32_t GOTGINT;              /*!< USB_OTG Interrupt Register                   004h */
X  volatile uint32_t GOTGINT;               
N  __IO uint32_t GAHBCFG;              /*!< Core AHB Configuration Register              008h */
X  volatile uint32_t GAHBCFG;               
N  __IO uint32_t GUSBCFG;              /*!< Core USB Configuration Register              00Ch */
X  volatile uint32_t GUSBCFG;               
N  __IO uint32_t GRSTCTL;              /*!< Core Reset Register                          010h */
X  volatile uint32_t GRSTCTL;               
N  __IO uint32_t GINTSTS;              /*!< Core Interrupt Register                      014h */
X  volatile uint32_t GINTSTS;               
N  __IO uint32_t GINTMSK;              /*!< Core Interrupt Mask Register                 018h */
X  volatile uint32_t GINTMSK;               
N  __IO uint32_t GRXSTSR;              /*!< Receive Sts Q Read Register                  01Ch */
X  volatile uint32_t GRXSTSR;               
N  __IO uint32_t GRXSTSP;              /*!< Receive Sts Q Read & POP Register            020h */
X  volatile uint32_t GRXSTSP;               
N  __IO uint32_t GRXFSIZ;              /*!< Receive FIFO Size Register                   024h */
X  volatile uint32_t GRXFSIZ;               
N  __IO uint32_t DIEPTXF0_HNPTXFSIZ;   /*!< EP0 / Non Periodic Tx FIFO Size Register     028h */
X  volatile uint32_t DIEPTXF0_HNPTXFSIZ;    
N  __IO uint32_t HNPTXSTS;             /*!< Non Periodic Tx FIFO/Queue Sts reg           02Ch */
X  volatile uint32_t HNPTXSTS;              
N  uint32_t Reserved30[2];             /*!< Reserved                                     030h */
N  __IO uint32_t GCCFG;                /*!< General Purpose IO Register                  038h */
X  volatile uint32_t GCCFG;                 
N  __IO uint32_t CID;                  /*!< User ID Register                             03Ch */
X  volatile uint32_t CID;                   
N  uint32_t  Reserved5[3];             /*!< Reserved                                040h-048h */
N  __IO uint32_t GHWCFG3;              /*!< User HW config3                              04Ch */
X  volatile uint32_t GHWCFG3;               
N  uint32_t  Reserved6;                /*!< Reserved                                     050h */ 
N  __IO uint32_t GLPMCFG;              /*!< LPM Register                                 054h */
X  volatile uint32_t GLPMCFG;               
N  __IO uint32_t GPWRDN;               /*!< Power Down Register                          058h */
X  volatile uint32_t GPWRDN;                
N  __IO uint32_t GDFIFOCFG;            /*!< DFIFO Software Config Register               05Ch */
X  volatile uint32_t GDFIFOCFG;             
N   __IO uint32_t GADPCTL;             /*!< ADP Timer, Control and Status Register       60Ch */
X   volatile uint32_t GADPCTL;              
N    uint32_t  Reserved43[39];         /*!< Reserved                                058h-0FFh */
N  __IO uint32_t HPTXFSIZ;             /*!< Host Periodic Tx FIFO Size Reg               100h */
X  volatile uint32_t HPTXFSIZ;              
N  __IO uint32_t DIEPTXF[0x0F];        /*!< dev Periodic Transmit FIFO */
X  volatile uint32_t DIEPTXF[0x0F];         
N} USB_OTG_GlobalTypeDef;
N
N
N/** 
N  * @brief USB_OTG_device_Registers
N  */
Ntypedef struct 
N{
N  __IO uint32_t DCFG;            /*!< dev Configuration Register   800h */
X  volatile uint32_t DCFG;             
N  __IO uint32_t DCTL;            /*!< dev Control Register         804h */
X  volatile uint32_t DCTL;             
N  __IO uint32_t DSTS;            /*!< dev Status Register (RO)     808h */
X  volatile uint32_t DSTS;             
N  uint32_t Reserved0C;           /*!< Reserved                     80Ch */
N  __IO uint32_t DIEPMSK;         /*!< dev IN Endpoint Mask         810h */
X  volatile uint32_t DIEPMSK;          
N  __IO uint32_t DOEPMSK;         /*!< dev OUT Endpoint Mask        814h */
X  volatile uint32_t DOEPMSK;          
N  __IO uint32_t DAINT;           /*!< dev All Endpoints Itr Reg    818h */
X  volatile uint32_t DAINT;            
N  __IO uint32_t DAINTMSK;        /*!< dev All Endpoints Itr Mask   81Ch */
X  volatile uint32_t DAINTMSK;         
N  uint32_t  Reserved20;          /*!< Reserved                     820h */
N  uint32_t Reserved9;            /*!< Reserved                     824h */
N  __IO uint32_t DVBUSDIS;        /*!< dev VBUS discharge Register  828h */
X  volatile uint32_t DVBUSDIS;         
N  __IO uint32_t DVBUSPULSE;      /*!< dev VBUS Pulse Register      82Ch */
X  volatile uint32_t DVBUSPULSE;       
N  __IO uint32_t DTHRCTL;         /*!< dev threshold                830h */
X  volatile uint32_t DTHRCTL;          
N  __IO uint32_t DIEPEMPMSK;      /*!< dev empty msk                834h */
X  volatile uint32_t DIEPEMPMSK;       
N  __IO uint32_t DEACHINT;        /*!< dedicated EP interrupt       838h */
X  volatile uint32_t DEACHINT;         
N  __IO uint32_t DEACHMSK;        /*!< dedicated EP msk             83Ch */  
X  volatile uint32_t DEACHMSK;           
N  uint32_t Reserved40;           /*!< dedicated EP mask            840h */
N  __IO uint32_t DINEP1MSK;       /*!< dedicated EP mask            844h */
X  volatile uint32_t DINEP1MSK;        
N  uint32_t  Reserved44[15];      /*!< Reserved                 844-87Ch */
N  __IO uint32_t DOUTEP1MSK;      /*!< dedicated EP msk             884h */   
X  volatile uint32_t DOUTEP1MSK;          
N} USB_OTG_DeviceTypeDef;
N
N
N/** 
N  * @brief USB_OTG_IN_Endpoint-Specific_Register
N  */
Ntypedef struct 
N{
N  __IO uint32_t DIEPCTL;           /*!< dev IN Endpoint Control Reg    900h + (ep_num * 20h) + 00h */
X  volatile uint32_t DIEPCTL;            
N  uint32_t Reserved04;             /*!< Reserved                       900h + (ep_num * 20h) + 04h */
N  __IO uint32_t DIEPINT;           /*!< dev IN Endpoint Itr Reg        900h + (ep_num * 20h) + 08h */
X  volatile uint32_t DIEPINT;            
N  uint32_t Reserved0C;             /*!< Reserved                       900h + (ep_num * 20h) + 0Ch */
N  __IO uint32_t DIEPTSIZ;          /*!< IN Endpoint Txfer Size         900h + (ep_num * 20h) + 10h */
X  volatile uint32_t DIEPTSIZ;           
N  __IO uint32_t DIEPDMA;           /*!< IN Endpoint DMA Address Reg    900h + (ep_num * 20h) + 14h */
X  volatile uint32_t DIEPDMA;            
N  __IO uint32_t DTXFSTS;           /*!< IN Endpoint Tx FIFO Status Reg 900h + (ep_num * 20h) + 18h */
X  volatile uint32_t DTXFSTS;            
N  uint32_t Reserved18;             /*!< Reserved  900h+(ep_num*20h)+1Ch-900h+ (ep_num * 20h) + 1Ch */
N} USB_OTG_INEndpointTypeDef;
N
N
N/** 
N  * @brief USB_OTG_OUT_Endpoint-Specific_Registers
N  */
Ntypedef struct 
N{
N  __IO uint32_t DOEPCTL;       /*!< dev OUT Endpoint Control Reg           B00h + (ep_num * 20h) + 00h */
X  volatile uint32_t DOEPCTL;        
N  uint32_t Reserved04;         /*!< Reserved                               B00h + (ep_num * 20h) + 04h */
N  __IO uint32_t DOEPINT;       /*!< dev OUT Endpoint Itr Reg               B00h + (ep_num * 20h) + 08h */
X  volatile uint32_t DOEPINT;        
N  uint32_t Reserved0C;         /*!< Reserved                               B00h + (ep_num * 20h) + 0Ch */
N  __IO uint32_t DOEPTSIZ;      /*!< dev OUT Endpoint Txfer Size            B00h + (ep_num * 20h) + 10h */
X  volatile uint32_t DOEPTSIZ;       
N  __IO uint32_t DOEPDMA;       /*!< dev OUT Endpoint DMA Address           B00h + (ep_num * 20h) + 14h */
X  volatile uint32_t DOEPDMA;        
N  uint32_t Reserved18[2];      /*!< Reserved B00h + (ep_num * 20h) + 18h - B00h + (ep_num * 20h) + 1Ch */
N} USB_OTG_OUTEndpointTypeDef;
N
N
N/** 
N  * @brief USB_OTG_Host_Mode_Register_Structures
N  */
Ntypedef struct 
N{
N  __IO uint32_t HCFG;             /*!< Host Configuration Register          400h */
X  volatile uint32_t HCFG;              
N  __IO uint32_t HFIR;             /*!< Host Frame Interval Register         404h */
X  volatile uint32_t HFIR;              
N  __IO uint32_t HFNUM;            /*!< Host Frame Nbr/Frame Remaining       408h */
X  volatile uint32_t HFNUM;             
N  uint32_t Reserved40C;           /*!< Reserved                             40Ch */
N  __IO uint32_t HPTXSTS;          /*!< Host Periodic Tx FIFO/ Queue Status  410h */
X  volatile uint32_t HPTXSTS;           
N  __IO uint32_t HAINT;            /*!< Host All Channels Interrupt Register 414h */
X  volatile uint32_t HAINT;             
N  __IO uint32_t HAINTMSK;         /*!< Host All Channels Interrupt Mask     418h */
X  volatile uint32_t HAINTMSK;          
N} USB_OTG_HostTypeDef;
N
N/** 
N  * @brief USB_OTG_Host_Channel_Specific_Registers
N  */
Ntypedef struct
N{
N  __IO uint32_t HCCHAR;           /*!< Host Channel Characteristics Register    500h */
X  volatile uint32_t HCCHAR;            
N  __IO uint32_t HCSPLT;           /*!< Host Channel Split Control Register      504h */
X  volatile uint32_t HCSPLT;            
N  __IO uint32_t HCINT;            /*!< Host Channel Interrupt Register          508h */
X  volatile uint32_t HCINT;             
N  __IO uint32_t HCINTMSK;         /*!< Host Channel Interrupt Mask Register     50Ch */
X  volatile uint32_t HCINTMSK;          
N  __IO uint32_t HCTSIZ;           /*!< Host Channel Transfer Size Register      510h */
X  volatile uint32_t HCTSIZ;            
N  __IO uint32_t HCDMA;            /*!< Host Channel DMA Address Register        514h */
X  volatile uint32_t HCDMA;             
N  uint32_t Reserved[2];           /*!< Reserved                                      */
N} USB_OTG_HostChannelTypeDef;
N/**
N  * @}
N  */
N
N/**
N  * @brief JPEG Codec
N  */
Ntypedef struct
N{
N  __IO uint32_t CONFR0;          /*!< JPEG Codec Control Register (JPEG_CONFR0),        Address offset: 00h       */
X  volatile uint32_t CONFR0;           
N  __IO uint32_t CONFR1;          /*!< JPEG Codec Control Register (JPEG_CONFR1),        Address offset: 04h       */
X  volatile uint32_t CONFR1;           
N  __IO uint32_t CONFR2;          /*!< JPEG Codec Control Register (JPEG_CONFR2),        Address offset: 08h       */
X  volatile uint32_t CONFR2;           
N  __IO uint32_t CONFR3;          /*!< JPEG Codec Control Register (JPEG_CONFR3),        Address offset: 0Ch       */ 
X  volatile uint32_t CONFR3;            
N  __IO uint32_t CONFR4;          /*!< JPEG Codec Control Register (JPEG_CONFR4),        Address offset: 10h       */ 
X  volatile uint32_t CONFR4;            
N  __IO uint32_t CONFR5;          /*!< JPEG Codec Control Register (JPEG_CONFR5),        Address offset: 14h       */ 
X  volatile uint32_t CONFR5;            
N  __IO uint32_t CONFR6;          /*!< JPEG Codec Control Register (JPEG_CONFR6),        Address offset: 18h       */ 
X  volatile uint32_t CONFR6;            
N  __IO uint32_t CONFR7;          /*!< JPEG Codec Control Register (JPEG_CONFR7),        Address offset: 1Ch       */
X  volatile uint32_t CONFR7;           
N  uint32_t  Reserved20[4];       /* Reserved                                            Address offset: 20h-2Ch   */
N  __IO uint32_t CR;              /*!< JPEG Control Register (JPEG_CR),                  Address offset: 30h       */ 
X  volatile uint32_t CR;                
N  __IO uint32_t SR;              /*!< JPEG Status Register (JPEG_SR),                   Address offset: 34h       */ 
X  volatile uint32_t SR;                
N  __IO uint32_t CFR;             /*!< JPEG Clear Flag Register (JPEG_CFR),              Address offset: 38h       */ 
X  volatile uint32_t CFR;               
N  uint32_t  Reserved3c;          /* Reserved                                            Address offset: 3Ch       */
N  __IO uint32_t DIR;             /*!< JPEG Data Input Register (JPEG_DIR),              Address offset: 40h       */
X  volatile uint32_t DIR;              
N  __IO uint32_t DOR;             /*!< JPEG Data Output Register (JPEG_DOR),             Address offset: 44h       */
X  volatile uint32_t DOR;              
N  uint32_t  Reserved48[2];       /* Reserved                                            Address offset: 48h-4Ch   */
N  __IO uint32_t QMEM0[16];       /*!< JPEG quantization tables 0,                       Address offset: 50h-8Ch   */
X  volatile uint32_t QMEM0[16];        
N  __IO uint32_t QMEM1[16];       /*!< JPEG quantization tables 1,                       Address offset: 90h-CCh   */
X  volatile uint32_t QMEM1[16];        
N  __IO uint32_t QMEM2[16];       /*!< JPEG quantization tables 2,                       Address offset: D0h-10Ch  */
X  volatile uint32_t QMEM2[16];        
N  __IO uint32_t QMEM3[16];       /*!< JPEG quantization tables 3,                       Address offset: 110h-14Ch */
X  volatile uint32_t QMEM3[16];        
N  __IO uint32_t HUFFMIN[16];     /*!< JPEG HuffMin tables,                              Address offset: 150h-18Ch */
X  volatile uint32_t HUFFMIN[16];      
N  __IO uint32_t HUFFBASE[32];    /*!< JPEG HuffSymb tables,                             Address offset: 190h-20Ch */
X  volatile uint32_t HUFFBASE[32];     
N  __IO uint32_t HUFFSYMB[84];    /*!< JPEG HUFFSYMB tables,                             Address offset: 210h-35Ch */
X  volatile uint32_t HUFFSYMB[84];     
N  __IO uint32_t DHTMEM[103];     /*!< JPEG DHTMem tables,                               Address offset: 360h-4F8h */
X  volatile uint32_t DHTMEM[103];      
N  uint32_t  Reserved4FC;         /* Reserved                                            Address offset: 4FCh      */
N  __IO uint32_t HUFFENC_AC0[88]; /*!< JPEG encoder, AC Huffman table 0,                 Address offset: 500h-65Ch */
X  volatile uint32_t HUFFENC_AC0[88];  
N  __IO uint32_t HUFFENC_AC1[88]; /*!< JPEG encoder, AC Huffman table 1,                 Address offset: 660h-7BCh */
X  volatile uint32_t HUFFENC_AC1[88];  
N  __IO uint32_t HUFFENC_DC0[8];  /*!< JPEG encoder, DC Huffman table 0,                 Address offset: 7C0h-7DCh */
X  volatile uint32_t HUFFENC_DC0[8];   
N  __IO uint32_t HUFFENC_DC1[8];  /*!< JPEG encoder, DC Huffman table 1,                 Address offset: 7E0h-7FCh */
X  volatile uint32_t HUFFENC_DC1[8];   
N
N} JPEG_TypeDef;
N
N/**
N  * @brief MDIOS
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;               /*!< MDIOS Configuration Register (MDIOS_CR),        Address offset: 00h       */
X  volatile uint32_t CR;                
N  __IO uint32_t WRFR;             /*!< MDIOS Configuration Register (MDIOS_CR),        Address offset: 04h       */
X  volatile uint32_t WRFR;              
N  __IO uint32_t CWRFR;            /*!< MDIOS Configuration Register (MDIOS_CR),        Address offset: 08h       */
X  volatile uint32_t CWRFR;             
N  __IO uint32_t RDFR;             /*!< MDIOS Configuration Register (MDIOS_CR),        Address offset: 0Ch       */ 
X  volatile uint32_t RDFR;               
N  __IO uint32_t CRDFR;            /*!< MDIOS Configuration Register (MDIOS_CR),        Address offset: 10h       */   
X  volatile uint32_t CRDFR;                
N  __IO uint32_t SR;               /*!< MDIOS Configuration Register (MDIOS_CR),        Address offset: 14h       */
X  volatile uint32_t SR;                
N  __IO uint32_t CLRFR;            /*!< MDIOS Configuration Register (MDIOS_CR),        Address offset: 18h       */   	
X  volatile uint32_t CLRFR;                	
N  uint32_t RESERVED0[57];         /* Reserved                                          Address offset: 1Ch       */	
N  __IO uint32_t DINR0;            /*!< MDIOS Input Data Register (MDIOS_DINR0),        Address offset: 100h      */    
X  volatile uint32_t DINR0;                 
N  __IO uint32_t DINR1;            /*!< MDIOS Input Data Register (MDIOS_DINR1),        Address offset: 104h      */     
X  volatile uint32_t DINR1;                  
N  __IO uint32_t DINR2;            /*!< MDIOS Input Data Register (MDIOS_DINR2),        Address offset: 108h      */    
X  volatile uint32_t DINR2;                 
N  __IO uint32_t DINR3;            /*!< MDIOS Input Data Register (MDIOS_DINR3),        Address offset: 10Ch      */     
X  volatile uint32_t DINR3;                  
N  __IO uint32_t DINR4;            /*!< MDIOS Input Data Register (MDIOS_DINR4),        Address offset: 110h      */     
X  volatile uint32_t DINR4;                  
N  __IO uint32_t DINR5;            /*!< MDIOS Input Data Register (MDIOS_DINR5),        Address offset: 114h      */     
X  volatile uint32_t DINR5;                  
N  __IO uint32_t DINR6;            /*!< MDIOS Input Data Register (MDIOS_DINR6),        Address offset: 118h      */  
X  volatile uint32_t DINR6;               
N  __IO uint32_t DINR7;            /*!< MDIOS Input Data Register (MDIOS_DINR7),        Address offset: 11Ch      */ 
X  volatile uint32_t DINR7;              
N  __IO uint32_t DINR8;            /*!< MDIOS Input Data Register (MDIOS_DINR8),        Address offset: 120h      */ 
X  volatile uint32_t DINR8;              
N  __IO uint32_t DINR9;            /*!< MDIOS Input Data Register (MDIOS_DINR9),        Address offset: 124h      */ 
X  volatile uint32_t DINR9;              
N  __IO uint32_t DINR10;           /*!< MDIOS Input Data Register (MDIOS_DINR10),       Address offset: 128h      */ 
X  volatile uint32_t DINR10;             
N  __IO uint32_t DINR11;           /*!< MDIOS Input Data Register (MDIOS_DINR11),       Address offset: 12Ch      */ 
X  volatile uint32_t DINR11;             
N  __IO uint32_t DINR12;           /*!< MDIOS Input Data Register (MDIOS_DINR12),       Address offset: 130h      */ 
X  volatile uint32_t DINR12;             
N  __IO uint32_t DINR13;           /*!< MDIOS Input Data Register (MDIOS_DINR13),       Address offset: 134h      */ 
X  volatile uint32_t DINR13;             
N  __IO uint32_t DINR14;           /*!< MDIOS Input Data Register (MDIOS_DINR14),       Address offset: 138h      */ 
X  volatile uint32_t DINR14;             
N  __IO uint32_t DINR15;           /*!< MDIOS Input Data Register (MDIOS_DINR15),       Address offset: 13Ch      */ 
X  volatile uint32_t DINR15;             
N  __IO uint32_t DINR16;           /*!< MDIOS Input Data Register (MDIOS_DINR16),       Address offset: 140h      */ 
X  volatile uint32_t DINR16;             
N  __IO uint32_t DINR17;           /*!< MDIOS Input Data Register (MDIOS_DINR17),       Address offset: 144h      */ 
X  volatile uint32_t DINR17;             
N  __IO uint32_t DINR18;           /*!< MDIOS Input Data Register (MDIOS_DINR18),       Address offset: 148h      */ 
X  volatile uint32_t DINR18;             
N  __IO uint32_t DINR19;           /*!< MDIOS Input Data Register (MDIOS_DINR19),       Address offset: 14Ch      */ 
X  volatile uint32_t DINR19;             
N  __IO uint32_t DINR20;           /*!< MDIOS Input Data Register (MDIOS_DINR20),       Address offset: 150h      */ 
X  volatile uint32_t DINR20;             
N  __IO uint32_t DINR21;           /*!< MDIOS Input Data Register (MDIOS_DINR21),       Address offset: 154h      */ 
X  volatile uint32_t DINR21;             
N  __IO uint32_t DINR22;           /*!< MDIOS Input Data Register (MDIOS_DINR22),       Address offset: 158h      */ 
X  volatile uint32_t DINR22;             
N  __IO uint32_t DINR23;           /*!< MDIOS Input Data Register (MDIOS_DINR23),       Address offset: 15Ch      */ 
X  volatile uint32_t DINR23;             
N  __IO uint32_t DINR24;           /*!< MDIOS Input Data Register (MDIOS_DINR24),       Address offset: 160h      */ 
X  volatile uint32_t DINR24;             
N  __IO uint32_t DINR25;           /*!< MDIOS Input Data Register (MDIOS_DINR25),       Address offset: 164h      */ 
X  volatile uint32_t DINR25;             
N  __IO uint32_t DINR26;           /*!< MDIOS Input Data Register (MDIOS_DINR26),       Address offset: 168h      */ 
X  volatile uint32_t DINR26;             
N  __IO uint32_t DINR27;           /*!< MDIOS Input Data Register (MDIOS_DINR27),       Address offset: 16Ch      */ 
X  volatile uint32_t DINR27;             
N  __IO uint32_t DINR28;           /*!< MDIOS Input Data Register (MDIOS_DINR28),       Address offset: 170h      */ 
X  volatile uint32_t DINR28;             
N  __IO uint32_t DINR29;           /*!< MDIOS Input Data Register (MDIOS_DINR29),       Address offset: 174h      */ 
X  volatile uint32_t DINR29;             
N  __IO uint32_t DINR30;           /*!< MDIOS Input Data Register (MDIOS_DINR30),       Address offset: 178h      */ 
X  volatile uint32_t DINR30;             
N  __IO uint32_t DINR31;           /*!< MDIOS Input Data Register (MDIOS_DINR31),       Address offset: 17Ch      */ 
X  volatile uint32_t DINR31;             
N  __IO uint32_t DOUTR0;           /*!< MDIOS Output Data Register (MDIOS_DOUTR0),      Address offset: 180h      */   
X  volatile uint32_t DOUTR0;               
N  __IO uint32_t DOUTR1;           /*!< MDIOS Output Data Register (MDIOS_DOUTR1),      Address offset: 184h      */   
X  volatile uint32_t DOUTR1;               
N  __IO uint32_t DOUTR2;           /*!< MDIOS Output Data Register (MDIOS_DOUTR2),      Address offset: 188h      */    
X  volatile uint32_t DOUTR2;                
N  __IO uint32_t DOUTR3;           /*!< MDIOS Output Data Register (MDIOS_DOUTR3),      Address offset: 18Ch      */    
X  volatile uint32_t DOUTR3;                
N  __IO uint32_t DOUTR4;           /*!< MDIOS Output Data Register (MDIOS_DOUTR4),      Address offset: 190h      */   
X  volatile uint32_t DOUTR4;               
N  __IO uint32_t DOUTR5;           /*!< MDIOS Output Data Register (MDIOS_DOUTR5),      Address offset: 194h      */    
X  volatile uint32_t DOUTR5;                
N  __IO uint32_t DOUTR6;           /*!< MDIOS Output Data Register (MDIOS_DOUTR6),      Address offset: 198h      */    
X  volatile uint32_t DOUTR6;                
N  __IO uint32_t DOUTR7;           /*!< MDIOS Output Data Register (MDIOS_DOUTR7),      Address offset: 19Ch      */
X  volatile uint32_t DOUTR7;            
N  __IO uint32_t DOUTR8;           /*!< MDIOS Output Data Register (MDIOS_DOUTR8),      Address offset: 1A0h      */
X  volatile uint32_t DOUTR8;            
N  __IO uint32_t DOUTR9;           /*!< MDIOS Output Data Register (MDIOS_DOUTR9),      Address offset: 1A4h      */
X  volatile uint32_t DOUTR9;            
N  __IO uint32_t DOUTR10;          /*!< MDIOS Output Data Register (MDIOS_DOUTR10),     Address offset: 1A8h      */
X  volatile uint32_t DOUTR10;           
N  __IO uint32_t DOUTR11;          /*!< MDIOS Output Data Register (MDIOS_DOUTR11),     Address offset: 1ACh      */
X  volatile uint32_t DOUTR11;           
N  __IO uint32_t DOUTR12;          /*!< MDIOS Output Data Register (MDIOS_DOUTR12),     Address offset: 1B0h      */
X  volatile uint32_t DOUTR12;           
N  __IO uint32_t DOUTR13;          /*!< MDIOS Output Data Register (MDIOS_DOUTR13),     Address offset: 1B4h      */
X  volatile uint32_t DOUTR13;           
N  __IO uint32_t DOUTR14;          /*!< MDIOS Output Data Register (MDIOS_DOUTR14),     Address offset: 1B8h      */
X  volatile uint32_t DOUTR14;           
N  __IO uint32_t DOUTR15;          /*!< MDIOS Output Data Register (MDIOS_DOUTR15),     Address offset: 1BCh      */
X  volatile uint32_t DOUTR15;           
N  __IO uint32_t DOUTR16;          /*!< MDIOS Output Data Register (MDIOS_DOUTR16),     Address offset: 1C0h      */
X  volatile uint32_t DOUTR16;           
N  __IO uint32_t DOUTR17;          /*!< MDIOS Output Data Register (MDIOS_DOUTR17),     Address offset: 1C4h      */
X  volatile uint32_t DOUTR17;           
N  __IO uint32_t DOUTR18;          /*!< MDIOS Output Data Register (MDIOS_DOUTR18),     Address offset: 1C8h      */
X  volatile uint32_t DOUTR18;           
N  __IO uint32_t DOUTR19;          /*!< MDIOS Output Data Register (MDIOS_DOUTR19),     Address offset: 1CCh      */
X  volatile uint32_t DOUTR19;           
N  __IO uint32_t DOUTR20;          /*!< MDIOS Output Data Register (MDIOS_DOUTR20),     Address offset: 1D0h      */
X  volatile uint32_t DOUTR20;           
N  __IO uint32_t DOUTR21;          /*!< MDIOS Output Data Register (MDIOS_DOUTR21),     Address offset: 1D4h      */
X  volatile uint32_t DOUTR21;           
N  __IO uint32_t DOUTR22;          /*!< MDIOS Output Data Register (MDIOS_DOUTR22),     Address offset: 1D8h      */
X  volatile uint32_t DOUTR22;           
N  __IO uint32_t DOUTR23;          /*!< MDIOS Output Data Register (MDIOS_DOUTR23),     Address offset: 1DCh      */
X  volatile uint32_t DOUTR23;           
N  __IO uint32_t DOUTR24;          /*!< MDIOS Output Data Register (MDIOS_DOUTR24),     Address offset: 1E0h      */
X  volatile uint32_t DOUTR24;           
N  __IO uint32_t DOUTR25;          /*!< MDIOS Output Data Register (MDIOS_DOUTR25),     Address offset: 1E4h      */
X  volatile uint32_t DOUTR25;           
N  __IO uint32_t DOUTR26;          /*!< MDIOS Output Data Register (MDIOS_DOUTR26),     Address offset: 1E8h      */
X  volatile uint32_t DOUTR26;           
N  __IO uint32_t DOUTR27;          /*!< MDIOS Output Data Register (MDIOS_DOUTR27),     Address offset: 1ECh      */
X  volatile uint32_t DOUTR27;           
N  __IO uint32_t DOUTR28;          /*!< MDIOS Output Data Register (MDIOS_DOUTR28),     Address offset: 1F0h      */
X  volatile uint32_t DOUTR28;           
N  __IO uint32_t DOUTR29;          /*!< MDIOS Output Data Register (MDIOS_DOUTR29),     Address offset: 1F4h      */
X  volatile uint32_t DOUTR29;           
N  __IO uint32_t DOUTR30;          /*!< MDIOS Output Data Register (MDIOS_DOUTR30),     Address offset: 1F8h      */
X  volatile uint32_t DOUTR30;           
N  __IO uint32_t DOUTR31;          /*!< MDIOS Output Data Register (MDIOS_DOUTR31),     Address offset: 1FCh      */
X  volatile uint32_t DOUTR31;           
N} MDIOS_TypeDef;
N
N
N/** @addtogroup Peripheral_memory_map
N  * @{
N  */
N#define RAMITCM_BASE           0x00000000U /*!< Base address of : 16KB RAM reserved for CPU execution/instruction accessible over ITCM  */
N#define FLASHITCM_BASE         0x00200000U /*!< Base address of : (up to 2 MB) embedded FLASH memory  accessible over ITCM              */                       
N#define FLASHAXI_BASE          0x08000000U /*!< Base address of : (up to 2 MB) embedded FLASH memory accessible over AXI                */                       
N#define RAMDTCM_BASE           0x20000000U /*!< Base address of : 128KB system data RAM accessible over DTCM                            */
N#define PERIPH_BASE            0x40000000U /*!< Base address of : AHB/ABP Peripherals                                                   */
N#define BKPSRAM_BASE           0x40024000U /*!< Base address of : Backup SRAM(4 KB)                                                     */
N#define QSPI_BASE              0x90000000U /*!< Base address of : QSPI memories  accessible over AXI                                    */
N#define FMC_R_BASE             0xA0000000U /*!< Base address of : FMC Control registers                                                 */
N#define QSPI_R_BASE            0xA0001000U /*!< Base address of : QSPI Control  registers                                               */
N#define SRAM1_BASE             0x20020000U /*!< Base address of : 368KB RAM1 accessible over AXI/AHB                                    */
N#define SRAM2_BASE             0x2007C000U /*!< Base address of : 16KB RAM2 accessible over AXI/AHB                                     */
N#define FLASH_END              0x081FFFFFU /*!< FLASH end address */
N
N/* Legacy define */
N#define FLASH_BASE     FLASHAXI_BASE
N
N/*!< Peripheral memory map */
N#define APB1PERIPH_BASE        PERIPH_BASE
N#define APB2PERIPH_BASE       (PERIPH_BASE + 0x00010000U)
N#define AHB1PERIPH_BASE       (PERIPH_BASE + 0x00020000U)
N#define AHB2PERIPH_BASE       (PERIPH_BASE + 0x10000000U)
N
N/*!< APB1 peripherals */
N#define TIM2_BASE             (APB1PERIPH_BASE + 0x0000U)
N#define TIM3_BASE             (APB1PERIPH_BASE + 0x0400U)
N#define TIM4_BASE             (APB1PERIPH_BASE + 0x0800U)
N#define TIM5_BASE             (APB1PERIPH_BASE + 0x0C00U)
N#define TIM6_BASE             (APB1PERIPH_BASE + 0x1000U)
N#define TIM7_BASE             (APB1PERIPH_BASE + 0x1400U)
N#define TIM12_BASE            (APB1PERIPH_BASE + 0x1800U)
N#define TIM13_BASE            (APB1PERIPH_BASE + 0x1C00U)
N#define TIM14_BASE            (APB1PERIPH_BASE + 0x2000U)
N#define LPTIM1_BASE           (APB1PERIPH_BASE + 0x2400U)
N#define RTC_BASE              (APB1PERIPH_BASE + 0x2800U)
N#define WWDG_BASE             (APB1PERIPH_BASE + 0x2C00U)
N#define IWDG_BASE             (APB1PERIPH_BASE + 0x3000U)
N#define CAN3_BASE             (APB1PERIPH_BASE + 0x3400U)
N#define SPI2_BASE             (APB1PERIPH_BASE + 0x3800U)
N#define SPI3_BASE             (APB1PERIPH_BASE + 0x3C00U)
N#define SPDIFRX_BASE          (APB1PERIPH_BASE + 0x4000U)
N#define USART2_BASE           (APB1PERIPH_BASE + 0x4400U)
N#define USART3_BASE           (APB1PERIPH_BASE + 0x4800U)
N#define UART4_BASE            (APB1PERIPH_BASE + 0x4C00U)
N#define UART5_BASE            (APB1PERIPH_BASE + 0x5000U)
N#define I2C1_BASE             (APB1PERIPH_BASE + 0x5400U)
N#define I2C2_BASE             (APB1PERIPH_BASE + 0x5800U)
N#define I2C3_BASE             (APB1PERIPH_BASE + 0x5C00U)
N#define I2C4_BASE             (APB1PERIPH_BASE + 0x6000U)
N#define CAN1_BASE             (APB1PERIPH_BASE + 0x6400U)
N#define CAN2_BASE             (APB1PERIPH_BASE + 0x6800U)
N#define CEC_BASE              (APB1PERIPH_BASE + 0x6C00U)
N#define PWR_BASE              (APB1PERIPH_BASE + 0x7000U)
N#define DAC_BASE              (APB1PERIPH_BASE + 0x7400U)
N#define UART7_BASE            (APB1PERIPH_BASE + 0x7800U)
N#define UART8_BASE            (APB1PERIPH_BASE + 0x7C00U)
N
N/*!< APB2 peripherals */
N#define TIM1_BASE             (APB2PERIPH_BASE + 0x0000U)
N#define TIM8_BASE             (APB2PERIPH_BASE + 0x0400U)
N#define USART1_BASE           (APB2PERIPH_BASE + 0x1000U)
N#define USART6_BASE           (APB2PERIPH_BASE + 0x1400U)
N#define SDMMC2_BASE           (APB2PERIPH_BASE + 0x1C00U)
N#define ADC1_BASE             (APB2PERIPH_BASE + 0x2000U)
N#define ADC2_BASE             (APB2PERIPH_BASE + 0x2100U)
N#define ADC3_BASE             (APB2PERIPH_BASE + 0x2200U)
N#define ADC_BASE              (APB2PERIPH_BASE + 0x2300U)
N#define SDMMC1_BASE           (APB2PERIPH_BASE + 0x2C00U)
N#define SPI1_BASE             (APB2PERIPH_BASE + 0x3000U)
N#define SPI4_BASE             (APB2PERIPH_BASE + 0x3400U)
N#define SYSCFG_BASE           (APB2PERIPH_BASE + 0x3800U)
N#define EXTI_BASE             (APB2PERIPH_BASE + 0x3C00U)
N#define TIM9_BASE             (APB2PERIPH_BASE + 0x4000U)
N#define TIM10_BASE            (APB2PERIPH_BASE + 0x4400U)
N#define TIM11_BASE            (APB2PERIPH_BASE + 0x4800U)
N#define SPI5_BASE             (APB2PERIPH_BASE + 0x5000U)
N#define SPI6_BASE             (APB2PERIPH_BASE + 0x5400U)
N#define SAI1_BASE             (APB2PERIPH_BASE + 0x5800U)
N#define SAI2_BASE             (APB2PERIPH_BASE + 0x5C00U)
N#define SAI1_Block_A_BASE     (SAI1_BASE + 0x004U)
N#define SAI1_Block_B_BASE     (SAI1_BASE + 0x024U)
N#define SAI2_Block_A_BASE     (SAI2_BASE + 0x004U)
N#define SAI2_Block_B_BASE     (SAI2_BASE + 0x024U)
N#define LTDC_BASE             (APB2PERIPH_BASE + 0x6800U)
N#define LTDC_Layer1_BASE      (LTDC_BASE + 0x84U)
N#define LTDC_Layer2_BASE      (LTDC_BASE + 0x104U)
N#define DFSDM1_BASE           (APB2PERIPH_BASE + 0x7400U)
N#define DFSDM1_Channel0_BASE  (DFSDM1_BASE + 0x00U)
N#define DFSDM1_Channel1_BASE  (DFSDM1_BASE + 0x20U)
N#define DFSDM1_Channel2_BASE  (DFSDM1_BASE + 0x40U)
N#define DFSDM1_Channel3_BASE  (DFSDM1_BASE + 0x60U)
N#define DFSDM1_Channel4_BASE  (DFSDM1_BASE + 0x80U)
N#define DFSDM1_Channel5_BASE  (DFSDM1_BASE + 0xA0U)
N#define DFSDM1_Channel6_BASE  (DFSDM1_BASE + 0xC0U)
N#define DFSDM1_Channel7_BASE  (DFSDM1_BASE + 0xE0U)
N#define DFSDM1_Filter0_BASE   (DFSDM1_BASE + 0x100U)
N#define DFSDM1_Filter1_BASE   (DFSDM1_BASE + 0x180U)
N#define DFSDM1_Filter2_BASE   (DFSDM1_BASE + 0x200U)
N#define DFSDM1_Filter3_BASE   (DFSDM1_BASE + 0x280U)
N#define MDIOS_BASE            (APB2PERIPH_BASE + 0x7800U)
N/*!< AHB1 peripherals */
N#define GPIOA_BASE            (AHB1PERIPH_BASE + 0x0000U)
N#define GPIOB_BASE            (AHB1PERIPH_BASE + 0x0400U)
N#define GPIOC_BASE            (AHB1PERIPH_BASE + 0x0800U)
N#define GPIOD_BASE            (AHB1PERIPH_BASE + 0x0C00U)
N#define GPIOE_BASE            (AHB1PERIPH_BASE + 0x1000U)
N#define GPIOF_BASE            (AHB1PERIPH_BASE + 0x1400U)
N#define GPIOG_BASE            (AHB1PERIPH_BASE + 0x1800U)
N#define GPIOH_BASE            (AHB1PERIPH_BASE + 0x1C00U)
N#define GPIOI_BASE            (AHB1PERIPH_BASE + 0x2000U)
N#define GPIOJ_BASE            (AHB1PERIPH_BASE + 0x2400U)
N#define GPIOK_BASE            (AHB1PERIPH_BASE + 0x2800U)
N#define CRC_BASE              (AHB1PERIPH_BASE + 0x3000U)
N#define RCC_BASE              (AHB1PERIPH_BASE + 0x3800U)
N#define FLASH_R_BASE          (AHB1PERIPH_BASE + 0x3C00U)
N#define UID_BASE              0x1FF0F420U                   /*!< Unique device ID register base address */
N#define FLASHSIZE_BASE        0x1FF0F442U                   /*!< FLASH Size register base address */
N#define PACKAGESIZE_BASE      0x1FFF7BF0U                   /*!< Package size register base address */
N#define DMA1_BASE             (AHB1PERIPH_BASE + 0x6000U)
N#define DMA1_Stream0_BASE     (DMA1_BASE + 0x010U)
N#define DMA1_Stream1_BASE     (DMA1_BASE + 0x028U)
N#define DMA1_Stream2_BASE     (DMA1_BASE + 0x040U)
N#define DMA1_Stream3_BASE     (DMA1_BASE + 0x058U)
N#define DMA1_Stream4_BASE     (DMA1_BASE + 0x070U)
N#define DMA1_Stream5_BASE     (DMA1_BASE + 0x088U)
N#define DMA1_Stream6_BASE     (DMA1_BASE + 0x0A0U)
N#define DMA1_Stream7_BASE     (DMA1_BASE + 0x0B8U)
N#define DMA2_BASE             (AHB1PERIPH_BASE + 0x6400U)
N#define DMA2_Stream0_BASE     (DMA2_BASE + 0x010U)
N#define DMA2_Stream1_BASE     (DMA2_BASE + 0x028U)
N#define DMA2_Stream2_BASE     (DMA2_BASE + 0x040U)
N#define DMA2_Stream3_BASE     (DMA2_BASE + 0x058U)
N#define DMA2_Stream4_BASE     (DMA2_BASE + 0x070U)
N#define DMA2_Stream5_BASE     (DMA2_BASE + 0x088U)
N#define DMA2_Stream6_BASE     (DMA2_BASE + 0x0A0U)
N#define DMA2_Stream7_BASE     (DMA2_BASE + 0x0B8U)
N#define ETH_BASE              (AHB1PERIPH_BASE + 0x8000U)
N#define ETH_MAC_BASE          (ETH_BASE)
N#define ETH_MMC_BASE          (ETH_BASE + 0x0100U)
N#define ETH_PTP_BASE          (ETH_BASE + 0x0700U)
N#define ETH_DMA_BASE          (ETH_BASE + 0x1000U)
N#define DMA2D_BASE            (AHB1PERIPH_BASE + 0xB000U)
N/*!< AHB2 peripherals */
N#define DCMI_BASE             (AHB2PERIPH_BASE + 0x50000U)
N#define JPEG_BASE           (AHB2PERIPH_BASE + 0x51000U)
N#define RNG_BASE              (AHB2PERIPH_BASE + 0x60800U)
N/*!< FMC Bankx registers base address */
N#define FMC_Bank1_R_BASE      (FMC_R_BASE + 0x0000U)
N#define FMC_Bank1E_R_BASE     (FMC_R_BASE + 0x0104U)
N#define FMC_Bank3_R_BASE      (FMC_R_BASE + 0x0080U)
N#define FMC_Bank5_6_R_BASE    (FMC_R_BASE + 0x0140U)
N
N/* Debug MCU registers base address */
N#define DBGMCU_BASE           0xE0042000U
N
N/*!< USB registers base address */
N#define USB_OTG_HS_PERIPH_BASE               0x40040000U
N#define USB_OTG_FS_PERIPH_BASE               0x50000000U
N
N#define USB_OTG_GLOBAL_BASE                  0x000U
N#define USB_OTG_DEVICE_BASE                  0x800U
N#define USB_OTG_IN_ENDPOINT_BASE             0x900U
N#define USB_OTG_OUT_ENDPOINT_BASE            0xB00U
N#define USB_OTG_EP_REG_SIZE                  0x20U
N#define USB_OTG_HOST_BASE                    0x400U
N#define USB_OTG_HOST_PORT_BASE               0x440U
N#define USB_OTG_HOST_CHANNEL_BASE            0x500U
N#define USB_OTG_HOST_CHANNEL_SIZE            0x20U
N#define USB_OTG_PCGCCTL_BASE                 0xE00U
N#define USB_OTG_FIFO_BASE                    0x1000U
N#define USB_OTG_FIFO_SIZE                    0x1000U
N
N/**
N  * @}
N  */
N  
N/** @addtogroup Peripheral_declaration
N  * @{
N  */  
N#define TIM2                ((TIM_TypeDef *) TIM2_BASE)
N#define TIM3                ((TIM_TypeDef *) TIM3_BASE)
N#define TIM4                ((TIM_TypeDef *) TIM4_BASE)
N#define TIM5                ((TIM_TypeDef *) TIM5_BASE)
N#define TIM6                ((TIM_TypeDef *) TIM6_BASE)
N#define TIM7                ((TIM_TypeDef *) TIM7_BASE)
N#define TIM12               ((TIM_TypeDef *) TIM12_BASE)
N#define TIM13               ((TIM_TypeDef *) TIM13_BASE)
N#define TIM14               ((TIM_TypeDef *) TIM14_BASE)
N#define LPTIM1              ((LPTIM_TypeDef *) LPTIM1_BASE)
N#define RTC                 ((RTC_TypeDef *) RTC_BASE)
N#define WWDG                ((WWDG_TypeDef *) WWDG_BASE)
N#define IWDG                ((IWDG_TypeDef *) IWDG_BASE)
N#define SPI2                ((SPI_TypeDef *) SPI2_BASE)
N#define SPI3                ((SPI_TypeDef *) SPI3_BASE)
N#define SPDIFRX             ((SPDIFRX_TypeDef *) SPDIFRX_BASE) 
N#define USART2              ((USART_TypeDef *) USART2_BASE)
N#define USART3              ((USART_TypeDef *) USART3_BASE)
N#define UART4               ((USART_TypeDef *) UART4_BASE)
N#define UART5               ((USART_TypeDef *) UART5_BASE)
N#define I2C1                ((I2C_TypeDef *) I2C1_BASE)
N#define I2C2                ((I2C_TypeDef *) I2C2_BASE)
N#define I2C3                ((I2C_TypeDef *) I2C3_BASE)
N#define I2C4                ((I2C_TypeDef *) I2C4_BASE)
N#define CAN1                ((CAN_TypeDef *) CAN1_BASE)
N#define CAN2                ((CAN_TypeDef *) CAN2_BASE)
N#define CEC                 ((CEC_TypeDef *) CEC_BASE)
N#define PWR                 ((PWR_TypeDef *) PWR_BASE)
N#define DAC                 ((DAC_TypeDef *) DAC_BASE)
N#define UART7               ((USART_TypeDef *) UART7_BASE)
N#define UART8               ((USART_TypeDef *) UART8_BASE)
N#define TIM1                ((TIM_TypeDef *) TIM1_BASE)
N#define TIM8                ((TIM_TypeDef *) TIM8_BASE)
N#define USART1              ((USART_TypeDef *) USART1_BASE)
N#define USART6              ((USART_TypeDef *) USART6_BASE)
N#define ADC                 ((ADC_Common_TypeDef *) ADC_BASE)
N#define ADC1                ((ADC_TypeDef *) ADC1_BASE)
N#define ADC2                ((ADC_TypeDef *) ADC2_BASE)
N#define ADC3                ((ADC_TypeDef *) ADC3_BASE)
N#define SDMMC1              ((SDMMC_TypeDef *) SDMMC1_BASE)
N#define SPI1                ((SPI_TypeDef *) SPI1_BASE) 
N#define SPI4                ((SPI_TypeDef *) SPI4_BASE)
N#define SYSCFG              ((SYSCFG_TypeDef *) SYSCFG_BASE)
N#define EXTI                ((EXTI_TypeDef *) EXTI_BASE)
N#define TIM9                ((TIM_TypeDef *) TIM9_BASE)
N#define TIM10               ((TIM_TypeDef *) TIM10_BASE)
N#define TIM11               ((TIM_TypeDef *) TIM11_BASE)
N#define SPI5                ((SPI_TypeDef *) SPI5_BASE)
N#define SPI6                ((SPI_TypeDef *) SPI6_BASE)
N#define SAI1                ((SAI_TypeDef *) SAI1_BASE)
N#define SAI2                ((SAI_TypeDef *) SAI2_BASE)
N#define SAI1_Block_A        ((SAI_Block_TypeDef *)SAI1_Block_A_BASE)
N#define SAI1_Block_B        ((SAI_Block_TypeDef *)SAI1_Block_B_BASE)
N#define SAI2_Block_A        ((SAI_Block_TypeDef *)SAI2_Block_A_BASE)
N#define SAI2_Block_B        ((SAI_Block_TypeDef *)SAI2_Block_B_BASE)
N#define LTDC                ((LTDC_TypeDef *)LTDC_BASE)
N#define LTDC_Layer1         ((LTDC_Layer_TypeDef *)LTDC_Layer1_BASE)
N#define LTDC_Layer2         ((LTDC_Layer_TypeDef *)LTDC_Layer2_BASE)
N#define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)
N#define GPIOB               ((GPIO_TypeDef *) GPIOB_BASE)
N#define GPIOC               ((GPIO_TypeDef *) GPIOC_BASE)
N#define GPIOD               ((GPIO_TypeDef *) GPIOD_BASE)
N#define GPIOE               ((GPIO_TypeDef *) GPIOE_BASE)
N#define GPIOF               ((GPIO_TypeDef *) GPIOF_BASE)
N#define GPIOG               ((GPIO_TypeDef *) GPIOG_BASE)
N#define GPIOH               ((GPIO_TypeDef *) GPIOH_BASE)
N#define GPIOI               ((GPIO_TypeDef *) GPIOI_BASE)
N#define GPIOJ               ((GPIO_TypeDef *) GPIOJ_BASE)
N#define GPIOK               ((GPIO_TypeDef *) GPIOK_BASE)
N#define CRC                 ((CRC_TypeDef *) CRC_BASE)
N#define RCC                 ((RCC_TypeDef *) RCC_BASE)
N#define FLASH               ((FLASH_TypeDef *) FLASH_R_BASE)
N#define DMA1                ((DMA_TypeDef *) DMA1_BASE)
N#define DMA1_Stream0        ((DMA_Stream_TypeDef *) DMA1_Stream0_BASE)
N#define DMA1_Stream1        ((DMA_Stream_TypeDef *) DMA1_Stream1_BASE)
N#define DMA1_Stream2        ((DMA_Stream_TypeDef *) DMA1_Stream2_BASE)
N#define DMA1_Stream3        ((DMA_Stream_TypeDef *) DMA1_Stream3_BASE)
N#define DMA1_Stream4        ((DMA_Stream_TypeDef *) DMA1_Stream4_BASE)
N#define DMA1_Stream5        ((DMA_Stream_TypeDef *) DMA1_Stream5_BASE)
N#define DMA1_Stream6        ((DMA_Stream_TypeDef *) DMA1_Stream6_BASE)
N#define DMA1_Stream7        ((DMA_Stream_TypeDef *) DMA1_Stream7_BASE)
N#define DMA2                ((DMA_TypeDef *) DMA2_BASE)
N#define DMA2_Stream0        ((DMA_Stream_TypeDef *) DMA2_Stream0_BASE)
N#define DMA2_Stream1        ((DMA_Stream_TypeDef *) DMA2_Stream1_BASE)
N#define DMA2_Stream2        ((DMA_Stream_TypeDef *) DMA2_Stream2_BASE)
N#define DMA2_Stream3        ((DMA_Stream_TypeDef *) DMA2_Stream3_BASE)
N#define DMA2_Stream4        ((DMA_Stream_TypeDef *) DMA2_Stream4_BASE)
N#define DMA2_Stream5        ((DMA_Stream_TypeDef *) DMA2_Stream5_BASE)
N#define DMA2_Stream6        ((DMA_Stream_TypeDef *) DMA2_Stream6_BASE)
N#define DMA2_Stream7        ((DMA_Stream_TypeDef *) DMA2_Stream7_BASE)
N#define ETH                 ((ETH_TypeDef *) ETH_BASE)  
N#define DMA2D               ((DMA2D_TypeDef *)DMA2D_BASE)
N#define DCMI                ((DCMI_TypeDef *) DCMI_BASE)
N#define RNG                 ((RNG_TypeDef *) RNG_BASE)
N#define FMC_Bank1           ((FMC_Bank1_TypeDef *) FMC_Bank1_R_BASE)
N#define FMC_Bank1E          ((FMC_Bank1E_TypeDef *) FMC_Bank1E_R_BASE)
N#define FMC_Bank3           ((FMC_Bank3_TypeDef *) FMC_Bank3_R_BASE)
N#define FMC_Bank5_6         ((FMC_Bank5_6_TypeDef *) FMC_Bank5_6_R_BASE)
N#define QUADSPI             ((QUADSPI_TypeDef *) QSPI_R_BASE)
N#define DBGMCU              ((DBGMCU_TypeDef *) DBGMCU_BASE)
N#define USB_OTG_FS          ((USB_OTG_GlobalTypeDef *) USB_OTG_FS_PERIPH_BASE)
N#define USB_OTG_HS          ((USB_OTG_GlobalTypeDef *) USB_OTG_HS_PERIPH_BASE)
N#define CAN3                ((CAN_TypeDef *) CAN3_BASE)
N#define SDMMC2              ((SDMMC_TypeDef *) SDMMC2_BASE)
N#define MDIOS               ((MDIOS_TypeDef *) MDIOS_BASE)
N#define DFSDM1_Channel0     ((DFSDM_Channel_TypeDef *) DFSDM1_Channel0_BASE)
N#define DFSDM1_Channel1     ((DFSDM_Channel_TypeDef *) DFSDM1_Channel1_BASE)
N#define DFSDM1_Channel2     ((DFSDM_Channel_TypeDef *) DFSDM1_Channel2_BASE)
N#define DFSDM1_Channel3     ((DFSDM_Channel_TypeDef *) DFSDM1_Channel3_BASE)
N#define DFSDM1_Channel4     ((DFSDM_Channel_TypeDef *) DFSDM1_Channel4_BASE)
N#define DFSDM1_Channel5     ((DFSDM_Channel_TypeDef *) DFSDM1_Channel5_BASE)
N#define DFSDM1_Channel6     ((DFSDM_Channel_TypeDef *) DFSDM1_Channel6_BASE)
N#define DFSDM1_Channel7     ((DFSDM_Channel_TypeDef *) DFSDM1_Channel7_BASE)
N#define DFSDM1_Filter0      ((DFSDM_Filter_TypeDef *) DFSDM1_Filter0_BASE)
N#define DFSDM1_Filter1      ((DFSDM_Filter_TypeDef *) DFSDM1_Filter1_BASE)
N#define DFSDM1_Filter2      ((DFSDM_Filter_TypeDef *) DFSDM1_Filter2_BASE)
N#define DFSDM1_Filter3      ((DFSDM_Filter_TypeDef *) DFSDM1_Filter3_BASE)
N#define JPEG                ((JPEG_TypeDef *) JPEG_BASE)
N
N/**
N  * @}
N  */
N
N/** @addtogroup Exported_constants
N  * @{
N  */
N  
N  /** @addtogroup Peripheral_Registers_Bits_Definition
N  * @{
N  */
N    
N/******************************************************************************/
N/*                         Peripheral Registers_Bits_Definition               */
N/******************************************************************************/
N
N/******************************************************************************/
N/*                                                                            */
N/*                        Analog to Digital Converter                         */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for ADC_SR register  ********************/
N#define  ADC_SR_AWD                          0x00000001U        /*!<Analog watchdog flag                                 */
N#define  ADC_SR_EOC                          0x00000002U        /*!<End of conversion                                    */
N#define  ADC_SR_JEOC                         0x00000004U        /*!<Injected channel end of conversion                   */
N#define  ADC_SR_JSTRT                        0x00000008U        /*!<Injected channel Start flag                          */
N#define  ADC_SR_STRT                         0x00000010U        /*!<Regular channel Start flag                           */
N#define  ADC_SR_OVR                          0x00000020U        /*!<Overrun flag                                         */
N
N/*******************  Bit definition for ADC_CR1 register  ********************/
N#define  ADC_CR1_AWDCH                       0x0000001FU        /*!<AWDCH[4:0] bits (Analog watchdog channel select bits) */
N#define  ADC_CR1_AWDCH_0                     0x00000001U        /*!<Bit 0 */
N#define  ADC_CR1_AWDCH_1                     0x00000002U        /*!<Bit 1 */
N#define  ADC_CR1_AWDCH_2                     0x00000004U        /*!<Bit 2 */
N#define  ADC_CR1_AWDCH_3                     0x00000008U        /*!<Bit 3 */
N#define  ADC_CR1_AWDCH_4                     0x00000010U        /*!<Bit 4 */
N#define  ADC_CR1_EOCIE                       0x00000020U        /*!<Interrupt enable for EOC                             */
N#define  ADC_CR1_AWDIE                       0x00000040U        /*!<AAnalog Watchdog interrupt enable                    */
N#define  ADC_CR1_JEOCIE                      0x00000080U        /*!<Interrupt enable for injected channels               */
N#define  ADC_CR1_SCAN                        0x00000100U        /*!<Scan mode */
N#define  ADC_CR1_AWDSGL                      0x00000200U        /*!<Enable the watchdog on a single channel in scan mode */
N#define  ADC_CR1_JAUTO                       0x00000400U        /*!<Automatic injected group conversion                  */
N#define  ADC_CR1_DISCEN                      0x00000800U        /*!<Discontinuous mode on regular channels               */
N#define  ADC_CR1_JDISCEN                     0x00001000U        /*!<Discontinuous mode on injected channels              */
N#define  ADC_CR1_DISCNUM                     0x0000E000U        /*!<DISCNUM[2:0] bits (Discontinuous mode channel count) */
N#define  ADC_CR1_DISCNUM_0                   0x00002000U        /*!<Bit 0 */
N#define  ADC_CR1_DISCNUM_1                   0x00004000U        /*!<Bit 1 */
N#define  ADC_CR1_DISCNUM_2                   0x00008000U        /*!<Bit 2 */
N#define  ADC_CR1_JAWDEN                      0x00400000U        /*!<Analog watchdog enable on injected channels          */
N#define  ADC_CR1_AWDEN                       0x00800000U        /*!<Analog watchdog enable on regular channels           */
N#define  ADC_CR1_RES                         0x03000000U        /*!<RES[2:0] bits (Resolution)                           */
N#define  ADC_CR1_RES_0                       0x01000000U        /*!<Bit 0 */
N#define  ADC_CR1_RES_1                       0x02000000U        /*!<Bit 1 */
N#define  ADC_CR1_OVRIE                       0x04000000U         /*!<overrun interrupt enable */
N  
N/*******************  Bit definition for ADC_CR2 register  ********************/
N#define  ADC_CR2_ADON                        0x00000001U        /*!<A/D Converter ON / OFF                                       */
N#define  ADC_CR2_CONT                        0x00000002U        /*!<Continuous Conversion                                        */
N#define  ADC_CR2_DMA                         0x00000100U        /*!<Direct Memory access mode                                    */
N#define  ADC_CR2_DDS                         0x00000200U        /*!<DMA disable selection (Single ADC)                           */
N#define  ADC_CR2_EOCS                        0x00000400U        /*!<End of conversion selection                                  */
N#define  ADC_CR2_ALIGN                       0x00000800U        /*!<Data Alignment                                               */
N#define  ADC_CR2_JEXTSEL                     0x000F0000U        /*!<JEXTSEL[3:0] bits (External event select for injected group) */
N#define  ADC_CR2_JEXTSEL_0                   0x00010000U        /*!<Bit 0 */
N#define  ADC_CR2_JEXTSEL_1                   0x00020000U        /*!<Bit 1 */
N#define  ADC_CR2_JEXTSEL_2                   0x00040000U        /*!<Bit 2 */
N#define  ADC_CR2_JEXTSEL_3                   0x00080000U        /*!<Bit 3 */
N#define  ADC_CR2_JEXTEN                      0x00300000U        /*!<JEXTEN[1:0] bits (External Trigger Conversion mode for injected channelsp) */
N#define  ADC_CR2_JEXTEN_0                    0x00100000U        /*!<Bit 0 */
N#define  ADC_CR2_JEXTEN_1                    0x00200000U        /*!<Bit 1 */
N#define  ADC_CR2_JSWSTART                    0x00400000U        /*!<Start Conversion of injected channels */
N#define  ADC_CR2_EXTSEL                      0x0F000000U        /*!<EXTSEL[3:0] bits (External Event Select for regular group) */
N#define  ADC_CR2_EXTSEL_0                    0x01000000U        /*!<Bit 0 */
N#define  ADC_CR2_EXTSEL_1                    0x02000000U        /*!<Bit 1 */
N#define  ADC_CR2_EXTSEL_2                    0x04000000U        /*!<Bit 2 */
N#define  ADC_CR2_EXTSEL_3                    0x08000000U        /*!<Bit 3 */
N#define  ADC_CR2_EXTEN                       0x30000000U        /*!<EXTEN[1:0] bits (External Trigger Conversion mode for regular channelsp) */
N#define  ADC_CR2_EXTEN_0                     0x10000000U        /*!<Bit 0 */
N#define  ADC_CR2_EXTEN_1                     0x20000000U        /*!<Bit 1 */
N#define  ADC_CR2_SWSTART                     0x40000000U        /*!<Start Conversion of regular channels */
N
N/******************  Bit definition for ADC_SMPR1 register  *******************/
N#define  ADC_SMPR1_SMP10                     0x00000007U        /*!<SMP10[2:0] bits (Channel 10 Sample time selection) */
N#define  ADC_SMPR1_SMP10_0                   0x00000001U        /*!<Bit 0 */
N#define  ADC_SMPR1_SMP10_1                   0x00000002U        /*!<Bit 1 */
N#define  ADC_SMPR1_SMP10_2                   0x00000004U        /*!<Bit 2 */
N#define  ADC_SMPR1_SMP11                     0x00000038U        /*!<SMP11[2:0] bits (Channel 11 Sample time selection) */
N#define  ADC_SMPR1_SMP11_0                   0x00000008U        /*!<Bit 0 */
N#define  ADC_SMPR1_SMP11_1                   0x00000010U        /*!<Bit 1 */
N#define  ADC_SMPR1_SMP11_2                   0x00000020U        /*!<Bit 2 */
N#define  ADC_SMPR1_SMP12                     0x000001C0U        /*!<SMP12[2:0] bits (Channel 12 Sample time selection) */
N#define  ADC_SMPR1_SMP12_0                   0x00000040U        /*!<Bit 0 */
N#define  ADC_SMPR1_SMP12_1                   0x00000080U        /*!<Bit 1 */
N#define  ADC_SMPR1_SMP12_2                   0x00000100U        /*!<Bit 2 */
N#define  ADC_SMPR1_SMP13                     0x00000E00U        /*!<SMP13[2:0] bits (Channel 13 Sample time selection) */
N#define  ADC_SMPR1_SMP13_0                   0x00000200U        /*!<Bit 0 */
N#define  ADC_SMPR1_SMP13_1                   0x00000400U        /*!<Bit 1 */
N#define  ADC_SMPR1_SMP13_2                   0x00000800U        /*!<Bit 2 */
N#define  ADC_SMPR1_SMP14                     0x00007000U        /*!<SMP14[2:0] bits (Channel 14 Sample time selection) */
N#define  ADC_SMPR1_SMP14_0                   0x00001000U        /*!<Bit 0 */
N#define  ADC_SMPR1_SMP14_1                   0x00002000U        /*!<Bit 1 */
N#define  ADC_SMPR1_SMP14_2                   0x00004000U        /*!<Bit 2 */
N#define  ADC_SMPR1_SMP15                     0x00038000U        /*!<SMP15[2:0] bits (Channel 15 Sample time selection) */
N#define  ADC_SMPR1_SMP15_0                   0x00008000U        /*!<Bit 0 */
N#define  ADC_SMPR1_SMP15_1                   0x00010000U        /*!<Bit 1 */
N#define  ADC_SMPR1_SMP15_2                   0x00020000U        /*!<Bit 2 */
N#define  ADC_SMPR1_SMP16                     0x001C0000U        /*!<SMP16[2:0] bits (Channel 16 Sample time selection) */
N#define  ADC_SMPR1_SMP16_0                   0x00040000U        /*!<Bit 0 */
N#define  ADC_SMPR1_SMP16_1                   0x00080000U        /*!<Bit 1 */
N#define  ADC_SMPR1_SMP16_2                   0x00100000U        /*!<Bit 2 */
N#define  ADC_SMPR1_SMP17                     0x00E00000U        /*!<SMP17[2:0] bits (Channel 17 Sample time selection) */
N#define  ADC_SMPR1_SMP17_0                   0x00200000U        /*!<Bit 0 */
N#define  ADC_SMPR1_SMP17_1                   0x00400000U        /*!<Bit 1 */
N#define  ADC_SMPR1_SMP17_2                   0x00800000U        /*!<Bit 2 */
N#define  ADC_SMPR1_SMP18                     0x07000000U        /*!<SMP18[2:0] bits (Channel 18 Sample time selection) */
N#define  ADC_SMPR1_SMP18_0                   0x01000000U        /*!<Bit 0 */
N#define  ADC_SMPR1_SMP18_1                   0x02000000U        /*!<Bit 1 */
N#define  ADC_SMPR1_SMP18_2                   0x04000000U        /*!<Bit 2 */
N
N/******************  Bit definition for ADC_SMPR2 register  *******************/
N#define  ADC_SMPR2_SMP0                      0x00000007U        /*!<SMP0[2:0] bits (Channel 0 Sample time selection) */
N#define  ADC_SMPR2_SMP0_0                    0x00000001U        /*!<Bit 0 */
N#define  ADC_SMPR2_SMP0_1                    0x00000002U        /*!<Bit 1 */
N#define  ADC_SMPR2_SMP0_2                    0x00000004U        /*!<Bit 2 */
N#define  ADC_SMPR2_SMP1                      0x00000038U        /*!<SMP1[2:0] bits (Channel 1 Sample time selection) */
N#define  ADC_SMPR2_SMP1_0                    0x00000008U        /*!<Bit 0 */
N#define  ADC_SMPR2_SMP1_1                    0x00000010U        /*!<Bit 1 */
N#define  ADC_SMPR2_SMP1_2                    0x00000020U        /*!<Bit 2 */
N#define  ADC_SMPR2_SMP2                      0x000001C0U        /*!<SMP2[2:0] bits (Channel 2 Sample time selection) */
N#define  ADC_SMPR2_SMP2_0                    0x00000040U        /*!<Bit 0 */
N#define  ADC_SMPR2_SMP2_1                    0x00000080U        /*!<Bit 1 */
N#define  ADC_SMPR2_SMP2_2                    0x00000100U        /*!<Bit 2 */
N#define  ADC_SMPR2_SMP3                      0x00000E00U        /*!<SMP3[2:0] bits (Channel 3 Sample time selection) */
N#define  ADC_SMPR2_SMP3_0                    0x00000200U        /*!<Bit 0 */
N#define  ADC_SMPR2_SMP3_1                    0x00000400U        /*!<Bit 1 */
N#define  ADC_SMPR2_SMP3_2                    0x00000800U        /*!<Bit 2 */
N#define  ADC_SMPR2_SMP4                      0x00007000U        /*!<SMP4[2:0] bits (Channel 4 Sample time selection) */
N#define  ADC_SMPR2_SMP4_0                    0x00001000U        /*!<Bit 0 */
N#define  ADC_SMPR2_SMP4_1                    0x00002000U        /*!<Bit 1 */
N#define  ADC_SMPR2_SMP4_2                    0x00004000U        /*!<Bit 2 */
N#define  ADC_SMPR2_SMP5                      0x00038000U        /*!<SMP5[2:0] bits (Channel 5 Sample time selection) */
N#define  ADC_SMPR2_SMP5_0                    0x00008000U        /*!<Bit 0 */
N#define  ADC_SMPR2_SMP5_1                    0x00010000U        /*!<Bit 1 */
N#define  ADC_SMPR2_SMP5_2                    0x00020000U        /*!<Bit 2 */
N#define  ADC_SMPR2_SMP6                      0x001C0000U        /*!<SMP6[2:0] bits (Channel 6 Sample time selection) */
N#define  ADC_SMPR2_SMP6_0                    0x00040000U        /*!<Bit 0 */
N#define  ADC_SMPR2_SMP6_1                    0x00080000U        /*!<Bit 1 */
N#define  ADC_SMPR2_SMP6_2                    0x00100000U        /*!<Bit 2 */
N#define  ADC_SMPR2_SMP7                      0x00E00000U        /*!<SMP7[2:0] bits (Channel 7 Sample time selection) */
N#define  ADC_SMPR2_SMP7_0                    0x00200000U        /*!<Bit 0 */
N#define  ADC_SMPR2_SMP7_1                    0x00400000U        /*!<Bit 1 */
N#define  ADC_SMPR2_SMP7_2                    0x00800000U        /*!<Bit 2 */
N#define  ADC_SMPR2_SMP8                      0x07000000U        /*!<SMP8[2:0] bits (Channel 8 Sample time selection) */
N#define  ADC_SMPR2_SMP8_0                    0x01000000U        /*!<Bit 0 */
N#define  ADC_SMPR2_SMP8_1                    0x02000000U        /*!<Bit 1 */
N#define  ADC_SMPR2_SMP8_2                    0x04000000U        /*!<Bit 2 */
N#define  ADC_SMPR2_SMP9                      0x38000000U        /*!<SMP9[2:0] bits (Channel 9 Sample time selection) */
N#define  ADC_SMPR2_SMP9_0                    0x08000000U        /*!<Bit 0 */
N#define  ADC_SMPR2_SMP9_1                    0x10000000U        /*!<Bit 1 */
N#define  ADC_SMPR2_SMP9_2                    0x20000000U        /*!<Bit 2 */
N
N/******************  Bit definition for ADC_JOFR1 register  *******************/
N#define  ADC_JOFR1_JOFFSET1                  0x0FFFU            /*!<Data offset for injected channel 1 */
N
N/******************  Bit definition for ADC_JOFR2 register  *******************/
N#define  ADC_JOFR2_JOFFSET2                  0x0FFFU            /*!<Data offset for injected channel 2 */
N
N/******************  Bit definition for ADC_JOFR3 register  *******************/
N#define  ADC_JOFR3_JOFFSET3                  0x0FFFU            /*!<Data offset for injected channel 3 */
N
N/******************  Bit definition for ADC_JOFR4 register  *******************/
N#define  ADC_JOFR4_JOFFSET4                  0x0FFFU            /*!<Data offset for injected channel 4 */
N
N/*******************  Bit definition for ADC_HTR register  ********************/
N#define  ADC_HTR_HT                          0x0FFFU            /*!<Analog watchdog high threshold */
N
N/*******************  Bit definition for ADC_LTR register  ********************/
N#define  ADC_LTR_LT                          0x0FFFU            /*!<Analog watchdog low threshold */
N
N/*******************  Bit definition for ADC_SQR1 register  *******************/
N#define  ADC_SQR1_SQ13                       0x0000001FU        /*!<SQ13[4:0] bits (13th conversion in regular sequence) */
N#define  ADC_SQR1_SQ13_0                     0x00000001U        /*!<Bit 0 */
N#define  ADC_SQR1_SQ13_1                     0x00000002U        /*!<Bit 1 */
N#define  ADC_SQR1_SQ13_2                     0x00000004U        /*!<Bit 2 */
N#define  ADC_SQR1_SQ13_3                     0x00000008U        /*!<Bit 3 */
N#define  ADC_SQR1_SQ13_4                     0x00000010U        /*!<Bit 4 */
N#define  ADC_SQR1_SQ14                       0x000003E0U        /*!<SQ14[4:0] bits (14th conversion in regular sequence) */
N#define  ADC_SQR1_SQ14_0                     0x00000020U        /*!<Bit 0 */
N#define  ADC_SQR1_SQ14_1                     0x00000040U        /*!<Bit 1 */
N#define  ADC_SQR1_SQ14_2                     0x00000080U        /*!<Bit 2 */
N#define  ADC_SQR1_SQ14_3                     0x00000100U        /*!<Bit 3 */
N#define  ADC_SQR1_SQ14_4                     0x00000200U        /*!<Bit 4 */
N#define  ADC_SQR1_SQ15                       0x00007C00U        /*!<SQ15[4:0] bits (15th conversion in regular sequence) */
N#define  ADC_SQR1_SQ15_0                     0x00000400U        /*!<Bit 0 */
N#define  ADC_SQR1_SQ15_1                     0x00000800U        /*!<Bit 1 */
N#define  ADC_SQR1_SQ15_2                     0x00001000U        /*!<Bit 2 */
N#define  ADC_SQR1_SQ15_3                     0x00002000U        /*!<Bit 3 */
N#define  ADC_SQR1_SQ15_4                     0x00004000U        /*!<Bit 4 */
N#define  ADC_SQR1_SQ16                       0x000F8000U        /*!<SQ16[4:0] bits (16th conversion in regular sequence) */
N#define  ADC_SQR1_SQ16_0                     0x00008000U        /*!<Bit 0 */
N#define  ADC_SQR1_SQ16_1                     0x00010000U        /*!<Bit 1 */
N#define  ADC_SQR1_SQ16_2                     0x00020000U        /*!<Bit 2 */
N#define  ADC_SQR1_SQ16_3                     0x00040000U        /*!<Bit 3 */
N#define  ADC_SQR1_SQ16_4                     0x00080000U        /*!<Bit 4 */
N#define  ADC_SQR1_L                          0x00F00000U        /*!<L[3:0] bits (Regular channel sequence length) */
N#define  ADC_SQR1_L_0                        0x00100000U        /*!<Bit 0 */
N#define  ADC_SQR1_L_1                        0x00200000U        /*!<Bit 1 */
N#define  ADC_SQR1_L_2                        0x00400000U        /*!<Bit 2 */
N#define  ADC_SQR1_L_3                        0x00800000U        /*!<Bit 3 */
N
N/*******************  Bit definition for ADC_SQR2 register  *******************/
N#define  ADC_SQR2_SQ7                        0x0000001FU        /*!<SQ7[4:0] bits (7th conversion in regular sequence) */
N#define  ADC_SQR2_SQ7_0                      0x00000001U        /*!<Bit 0 */
N#define  ADC_SQR2_SQ7_1                      0x00000002U        /*!<Bit 1 */
N#define  ADC_SQR2_SQ7_2                      0x00000004U        /*!<Bit 2 */
N#define  ADC_SQR2_SQ7_3                      0x00000008U        /*!<Bit 3 */
N#define  ADC_SQR2_SQ7_4                      0x00000010U        /*!<Bit 4 */
N#define  ADC_SQR2_SQ8                        0x000003E0U        /*!<SQ8[4:0] bits (8th conversion in regular sequence) */
N#define  ADC_SQR2_SQ8_0                      0x00000020U        /*!<Bit 0 */
N#define  ADC_SQR2_SQ8_1                      0x00000040U        /*!<Bit 1 */
N#define  ADC_SQR2_SQ8_2                      0x00000080U        /*!<Bit 2 */
N#define  ADC_SQR2_SQ8_3                      0x00000100U        /*!<Bit 3 */
N#define  ADC_SQR2_SQ8_4                      0x00000200U        /*!<Bit 4 */
N#define  ADC_SQR2_SQ9                        0x00007C00U        /*!<SQ9[4:0] bits (9th conversion in regular sequence) */
N#define  ADC_SQR2_SQ9_0                      0x00000400U        /*!<Bit 0 */
N#define  ADC_SQR2_SQ9_1                      0x00000800U        /*!<Bit 1 */
N#define  ADC_SQR2_SQ9_2                      0x00001000U        /*!<Bit 2 */
N#define  ADC_SQR2_SQ9_3                      0x00002000U        /*!<Bit 3 */
N#define  ADC_SQR2_SQ9_4                      0x00004000U        /*!<Bit 4 */
N#define  ADC_SQR2_SQ10                       0x000F8000U        /*!<SQ10[4:0] bits (10th conversion in regular sequence) */
N#define  ADC_SQR2_SQ10_0                     0x00008000U        /*!<Bit 0 */
N#define  ADC_SQR2_SQ10_1                     0x00010000U        /*!<Bit 1 */
N#define  ADC_SQR2_SQ10_2                     0x00020000U        /*!<Bit 2 */
N#define  ADC_SQR2_SQ10_3                     0x00040000U        /*!<Bit 3 */
N#define  ADC_SQR2_SQ10_4                     0x00080000U        /*!<Bit 4 */
N#define  ADC_SQR2_SQ11                       0x01F00000U        /*!<SQ11[4:0] bits (11th conversion in regular sequence) */
N#define  ADC_SQR2_SQ11_0                     0x00100000U        /*!<Bit 0 */
N#define  ADC_SQR2_SQ11_1                     0x00200000U        /*!<Bit 1 */
N#define  ADC_SQR2_SQ11_2                     0x00400000U        /*!<Bit 2 */
N#define  ADC_SQR2_SQ11_3                     0x00800000U        /*!<Bit 3 */
N#define  ADC_SQR2_SQ11_4                     0x01000000U        /*!<Bit 4 */
N#define  ADC_SQR2_SQ12                       0x3E000000U        /*!<SQ12[4:0] bits (12th conversion in regular sequence) */
N#define  ADC_SQR2_SQ12_0                     0x02000000U        /*!<Bit 0 */
N#define  ADC_SQR2_SQ12_1                     0x04000000U        /*!<Bit 1 */
N#define  ADC_SQR2_SQ12_2                     0x08000000U        /*!<Bit 2 */
N#define  ADC_SQR2_SQ12_3                     0x10000000U        /*!<Bit 3 */
N#define  ADC_SQR2_SQ12_4                     0x20000000U        /*!<Bit 4 */
N
N/*******************  Bit definition for ADC_SQR3 register  *******************/
N#define  ADC_SQR3_SQ1                        0x0000001FU        /*!<SQ1[4:0] bits (1st conversion in regular sequence) */
N#define  ADC_SQR3_SQ1_0                      0x00000001U        /*!<Bit 0 */
N#define  ADC_SQR3_SQ1_1                      0x00000002U        /*!<Bit 1 */
N#define  ADC_SQR3_SQ1_2                      0x00000004U        /*!<Bit 2 */
N#define  ADC_SQR3_SQ1_3                      0x00000008U        /*!<Bit 3 */
N#define  ADC_SQR3_SQ1_4                      0x00000010U        /*!<Bit 4 */
N#define  ADC_SQR3_SQ2                        0x000003E0U        /*!<SQ2[4:0] bits (2nd conversion in regular sequence) */
N#define  ADC_SQR3_SQ2_0                      0x00000020U        /*!<Bit 0 */
N#define  ADC_SQR3_SQ2_1                      0x00000040U        /*!<Bit 1 */
N#define  ADC_SQR3_SQ2_2                      0x00000080U        /*!<Bit 2 */
N#define  ADC_SQR3_SQ2_3                      0x00000100U        /*!<Bit 3 */
N#define  ADC_SQR3_SQ2_4                      0x00000200U        /*!<Bit 4 */
N#define  ADC_SQR3_SQ3                        0x00007C00U        /*!<SQ3[4:0] bits (3rd conversion in regular sequence) */
N#define  ADC_SQR3_SQ3_0                      0x00000400U        /*!<Bit 0 */
N#define  ADC_SQR3_SQ3_1                      0x00000800U        /*!<Bit 1 */
N#define  ADC_SQR3_SQ3_2                      0x00001000U        /*!<Bit 2 */
N#define  ADC_SQR3_SQ3_3                      0x00002000U        /*!<Bit 3 */
N#define  ADC_SQR3_SQ3_4                      0x00004000U        /*!<Bit 4 */
N#define  ADC_SQR3_SQ4                        0x000F8000U        /*!<SQ4[4:0] bits (4th conversion in regular sequence) */
N#define  ADC_SQR3_SQ4_0                      0x00008000U        /*!<Bit 0 */
N#define  ADC_SQR3_SQ4_1                      0x00010000U        /*!<Bit 1 */
N#define  ADC_SQR3_SQ4_2                      0x00020000U        /*!<Bit 2 */
N#define  ADC_SQR3_SQ4_3                      0x00040000U        /*!<Bit 3 */
N#define  ADC_SQR3_SQ4_4                      0x00080000U        /*!<Bit 4 */
N#define  ADC_SQR3_SQ5                        0x01F00000U        /*!<SQ5[4:0] bits (5th conversion in regular sequence) */
N#define  ADC_SQR3_SQ5_0                      0x00100000U        /*!<Bit 0 */
N#define  ADC_SQR3_SQ5_1                      0x00200000U        /*!<Bit 1 */
N#define  ADC_SQR3_SQ5_2                      0x00400000U        /*!<Bit 2 */
N#define  ADC_SQR3_SQ5_3                      0x00800000U        /*!<Bit 3 */
N#define  ADC_SQR3_SQ5_4                      0x01000000U        /*!<Bit 4 */
N#define  ADC_SQR3_SQ6                        0x3E000000U        /*!<SQ6[4:0] bits (6th conversion in regular sequence) */
N#define  ADC_SQR3_SQ6_0                      0x02000000U        /*!<Bit 0 */
N#define  ADC_SQR3_SQ6_1                      0x04000000U        /*!<Bit 1 */
N#define  ADC_SQR3_SQ6_2                      0x08000000U        /*!<Bit 2 */
N#define  ADC_SQR3_SQ6_3                      0x10000000U        /*!<Bit 3 */
N#define  ADC_SQR3_SQ6_4                      0x20000000U        /*!<Bit 4 */
N
N/*******************  Bit definition for ADC_JSQR register  *******************/
N#define  ADC_JSQR_JSQ1                       0x0000001FU        /*!<JSQ1[4:0] bits (1st conversion in injected sequence) */  
N#define  ADC_JSQR_JSQ1_0                     0x00000001U        /*!<Bit 0 */
N#define  ADC_JSQR_JSQ1_1                     0x00000002U        /*!<Bit 1 */
N#define  ADC_JSQR_JSQ1_2                     0x00000004U        /*!<Bit 2 */
N#define  ADC_JSQR_JSQ1_3                     0x00000008U        /*!<Bit 3 */
N#define  ADC_JSQR_JSQ1_4                     0x00000010U        /*!<Bit 4 */
N#define  ADC_JSQR_JSQ2                       0x000003E0U        /*!<JSQ2[4:0] bits (2nd conversion in injected sequence) */
N#define  ADC_JSQR_JSQ2_0                     0x00000020U        /*!<Bit 0 */
N#define  ADC_JSQR_JSQ2_1                     0x00000040U        /*!<Bit 1 */
N#define  ADC_JSQR_JSQ2_2                     0x00000080U        /*!<Bit 2 */
N#define  ADC_JSQR_JSQ2_3                     0x00000100U        /*!<Bit 3 */
N#define  ADC_JSQR_JSQ2_4                     0x00000200U        /*!<Bit 4 */
N#define  ADC_JSQR_JSQ3                       0x00007C00U        /*!<JSQ3[4:0] bits (3rd conversion in injected sequence) */
N#define  ADC_JSQR_JSQ3_0                     0x00000400U        /*!<Bit 0 */
N#define  ADC_JSQR_JSQ3_1                     0x00000800U        /*!<Bit 1 */
N#define  ADC_JSQR_JSQ3_2                     0x00001000U        /*!<Bit 2 */
N#define  ADC_JSQR_JSQ3_3                     0x00002000U        /*!<Bit 3 */
N#define  ADC_JSQR_JSQ3_4                     0x00004000U        /*!<Bit 4 */
N#define  ADC_JSQR_JSQ4                       0x000F8000U        /*!<JSQ4[4:0] bits (4th conversion in injected sequence) */
N#define  ADC_JSQR_JSQ4_0                     0x00008000U        /*!<Bit 0 */
N#define  ADC_JSQR_JSQ4_1                     0x00010000U        /*!<Bit 1 */
N#define  ADC_JSQR_JSQ4_2                     0x00020000U        /*!<Bit 2 */
N#define  ADC_JSQR_JSQ4_3                     0x00040000U        /*!<Bit 3 */
N#define  ADC_JSQR_JSQ4_4                     0x00080000U        /*!<Bit 4 */
N#define  ADC_JSQR_JL                         0x00300000U        /*!<JL[1:0] bits (Injected Sequence length) */
N#define  ADC_JSQR_JL_0                       0x00100000U        /*!<Bit 0 */
N#define  ADC_JSQR_JL_1                       0x00200000U        /*!<Bit 1 */
N
N/*******************  Bit definition for ADC_JDR1 register  *******************/
N#define  ADC_JDR1_JDATA                      ((uint16_t)0xFFFFU)            /*!<Injected data */
N
N/*******************  Bit definition for ADC_JDR2 register  *******************/
N#define  ADC_JDR2_JDATA                      ((uint16_t)0xFFFFU)            /*!<Injected data */
N
N/*******************  Bit definition for ADC_JDR3 register  *******************/
N#define  ADC_JDR3_JDATA                      ((uint16_t)0xFFFFU)            /*!<Injected data */
N
N/*******************  Bit definition for ADC_JDR4 register  *******************/
N#define  ADC_JDR4_JDATA                      ((uint16_t)0xFFFFU)            /*!<Injected data */
N
N/********************  Bit definition for ADC_DR register  ********************/
N#define  ADC_DR_DATA                         0x0000FFFFU        /*!<Regular data */
N#define  ADC_DR_ADC2DATA                     0xFFFF0000U        /*!<ADC2 data */
N
N/*******************  Bit definition for ADC_CSR register  ********************/
N#define  ADC_CSR_AWD1                        0x00000001U        /*!<ADC1 Analog watchdog flag               */
N#define  ADC_CSR_EOC1                        0x00000002U        /*!<ADC1 End of conversion                  */
N#define  ADC_CSR_JEOC1                       0x00000004U        /*!<ADC1 Injected channel end of conversion */
N#define  ADC_CSR_JSTRT1                      0x00000008U        /*!<ADC1 Injected channel Start flag        */
N#define  ADC_CSR_STRT1                       0x00000010U        /*!<ADC1 Regular channel Start flag         */
N#define  ADC_CSR_OVR1                        0x00000020U        /*!<ADC1 Overrun flag                       */
N#define  ADC_CSR_AWD2                        0x00000100U        /*!<ADC2 Analog watchdog flag               */
N#define  ADC_CSR_EOC2                        0x00000200U        /*!<ADC2 End of conversion                  */
N#define  ADC_CSR_JEOC2                       0x00000400U        /*!<ADC2 Injected channel end of conversion */
N#define  ADC_CSR_JSTRT2                      0x00000800U        /*!<ADC2 Injected channel Start flag        */
N#define  ADC_CSR_STRT2                       0x00001000U        /*!<ADC2 Regular channel Start flag         */
N#define  ADC_CSR_OVR2                        0x00002000U        /*!<ADC2 Overrun flag                       */
N#define  ADC_CSR_AWD3                        0x00010000U        /*!<ADC3 Analog watchdog flag               */
N#define  ADC_CSR_EOC3                        0x00020000U        /*!<ADC3 End of conversion                  */
N#define  ADC_CSR_JEOC3                       0x00040000U        /*!<ADC3 Injected channel end of conversion */
N#define  ADC_CSR_JSTRT3                      0x00080000U        /*!<ADC3 Injected channel Start flag        */
N#define  ADC_CSR_STRT3                       0x00100000U        /*!<ADC3 Regular channel Start flag         */
N#define  ADC_CSR_OVR3                        0x00200000U        /*!<ADC3 Overrun flag                       */
N
N/* Legacy defines */
N#define  ADC_CSR_DOVR1                       ADC_CSR_OVR1
N#define  ADC_CSR_DOVR2                       ADC_CSR_OVR2
N#define  ADC_CSR_DOVR3                       ADC_CSR_OVR3
N
N
N/*******************  Bit definition for ADC_CCR register  ********************/
N#define  ADC_CCR_MULTI                       0x0000001FU        /*!<MULTI[4:0] bits (Multi-ADC mode selection) */  
N#define  ADC_CCR_MULTI_0                     0x00000001U        /*!<Bit 0 */
N#define  ADC_CCR_MULTI_1                     0x00000002U        /*!<Bit 1 */
N#define  ADC_CCR_MULTI_2                     0x00000004U        /*!<Bit 2 */
N#define  ADC_CCR_MULTI_3                     0x00000008U        /*!<Bit 3 */
N#define  ADC_CCR_MULTI_4                     0x00000010U        /*!<Bit 4 */
N#define  ADC_CCR_DELAY                       0x00000F00U        /*!<DELAY[3:0] bits (Delay between 2 sampling phases) */  
N#define  ADC_CCR_DELAY_0                     0x00000100U        /*!<Bit 0 */
N#define  ADC_CCR_DELAY_1                     0x00000200U        /*!<Bit 1 */
N#define  ADC_CCR_DELAY_2                     0x00000400U        /*!<Bit 2 */
N#define  ADC_CCR_DELAY_3                     0x00000800U        /*!<Bit 3 */
N#define  ADC_CCR_DDS                         0x00002000U        /*!<DMA disable selection (Multi-ADC mode) */
N#define  ADC_CCR_DMA                         0x0000C000U        /*!<DMA[1:0] bits (Direct Memory Access mode for multimode) */  
N#define  ADC_CCR_DMA_0                       0x00004000U        /*!<Bit 0 */
N#define  ADC_CCR_DMA_1                       0x00008000U        /*!<Bit 1 */
N#define  ADC_CCR_ADCPRE                      0x00030000U        /*!<ADCPRE[1:0] bits (ADC prescaler) */  
N#define  ADC_CCR_ADCPRE_0                    0x00010000U        /*!<Bit 0 */
N#define  ADC_CCR_ADCPRE_1                    0x00020000U        /*!<Bit 1 */
N#define  ADC_CCR_VBATE                       0x00400000U        /*!<VBAT Enable */
N#define  ADC_CCR_TSVREFE                     0x00800000U        /*!<Temperature Sensor and VREFINT Enable */
N
N/*******************  Bit definition for ADC_CDR register  ********************/
N#define  ADC_CDR_DATA1                       0x0000FFFFU         /*!<1st data of a pair of regular conversions */
N#define  ADC_CDR_DATA2                       0xFFFF0000U         /*!<2nd data of a pair of regular conversions */
N
N/******************************************************************************/
N/*                                                                            */
N/*                         Controller Area Network                            */
N/*                                                                            */
N/******************************************************************************/
N/*!<CAN control and status registers */
N/*******************  Bit definition for CAN_MCR register  ********************/
N#define  CAN_MCR_INRQ                        0x00000001U        /*!<Initialization Request            */
N#define  CAN_MCR_SLEEP                       0x00000002U        /*!<Sleep Mode Request                */
N#define  CAN_MCR_TXFP                        0x00000004U        /*!<Transmit FIFO Priority            */
N#define  CAN_MCR_RFLM                        0x00000008U        /*!<Receive FIFO Locked Mode          */
N#define  CAN_MCR_NART                        0x00000010U        /*!<No Automatic Retransmission       */
N#define  CAN_MCR_AWUM                        0x00000020U        /*!<Automatic Wakeup Mode             */
N#define  CAN_MCR_ABOM                        0x00000040U        /*!<Automatic Bus-Off Management      */
N#define  CAN_MCR_TTCM                        0x00000080U        /*!<Time Triggered Communication Mode */
N#define  CAN_MCR_RESET                       0x00008000U        /*!<bxCAN software master reset       */
N                                                                           
N/*******************  Bit definition for CAN_MSR register  ********************/
N#define  CAN_MSR_INAK                        0x00000001U        /*!<Initialization Acknowledge  */
N#define  CAN_MSR_SLAK                        0x00000002U        /*!<Sleep Acknowledge           */
N#define  CAN_MSR_ERRI                        0x00000004U        /*!<Error Interrupt             */
N#define  CAN_MSR_WKUI                        0x00000008U        /*!<Wakeup Interrupt            */
N#define  CAN_MSR_SLAKI                       0x00000010U        /*!<Sleep Acknowledge Interrupt */
N#define  CAN_MSR_TXM                         0x00000100U        /*!<Transmit Mode               */
N#define  CAN_MSR_RXM                         0x00000200U        /*!<Receive Mode                */
N#define  CAN_MSR_SAMP                        0x00000400U        /*!<Last Sample Point           */
N#define  CAN_MSR_RX                          0x00000800U        /*!<CAN Rx Signal               */
N
N/*******************  Bit definition for CAN_TSR register  ********************/
N#define  CAN_TSR_RQCP0                       0x00000001U        /*!<Request Completed Mailbox0      */
N#define  CAN_TSR_TXOK0                       0x00000002U        /*!<Transmission OK of Mailbox0     */
N#define  CAN_TSR_ALST0                       0x00000004U        /*!<Arbitration Lost for Mailbox0   */
N#define  CAN_TSR_TERR0                       0x00000008U        /*!<Transmission Error of Mailbox0  */
N#define  CAN_TSR_ABRQ0                       0x00000080U        /*!<Abort Request for Mailbox0      */
N#define  CAN_TSR_RQCP1                       0x00000100U        /*!<Request Completed Mailbox1      */
N#define  CAN_TSR_TXOK1                       0x00000200U        /*!<Transmission OK of Mailbox1     */
N#define  CAN_TSR_ALST1                       0x00000400U        /*!<Arbitration Lost for Mailbox1   */
N#define  CAN_TSR_TERR1                       0x00000800U        /*!<Transmission Error of Mailbox1  */
N#define  CAN_TSR_ABRQ1                       0x00008000U        /*!<Abort Request for Mailbox 1     */
N#define  CAN_TSR_RQCP2                       0x00010000U        /*!<Request Completed Mailbox2      */
N#define  CAN_TSR_TXOK2                       0x00020000U        /*!<Transmission OK of Mailbox 2    */
N#define  CAN_TSR_ALST2                       0x00040000U        /*!<Arbitration Lost for mailbox 2  */
N#define  CAN_TSR_TERR2                       0x00080000U        /*!<Transmission Error of Mailbox 2 */
N#define  CAN_TSR_ABRQ2                       0x00800000U        /*!<Abort Request for Mailbox 2     */
N#define  CAN_TSR_CODE                        0x03000000U        /*!<Mailbox Code                    */
N
N#define  CAN_TSR_TME                         0x1C000000U        /*!<TME[2:0] bits */
N#define  CAN_TSR_TME0                        0x04000000U        /*!<Transmit Mailbox 0 Empty */
N#define  CAN_TSR_TME1                        0x08000000U        /*!<Transmit Mailbox 1 Empty */
N#define  CAN_TSR_TME2                        0x10000000U        /*!<Transmit Mailbox 2 Empty */
N
N#define  CAN_TSR_LOW                         0xE0000000U        /*!<LOW[2:0] bits */
N#define  CAN_TSR_LOW0                        0x20000000U        /*!<Lowest Priority Flag for Mailbox 0 */
N#define  CAN_TSR_LOW1                        0x40000000U        /*!<Lowest Priority Flag for Mailbox 1 */
N#define  CAN_TSR_LOW2                        0x80000000U        /*!<Lowest Priority Flag for Mailbox 2 */
N
N/*******************  Bit definition for CAN_RF0R register  *******************/
N#define  CAN_RF0R_FMP0                       0x00000003U        /*!<FIFO 0 Message Pending        */
N#define  CAN_RF0R_FULL0                      0x00000008U        /*!<FIFO 0 Full                   */
N#define  CAN_RF0R_FOVR0                      0x00000010U        /*!<FIFO 0 Overrun                */
N#define  CAN_RF0R_RFOM0                      0x00000020U        /*!<Release FIFO 0 Output Mailbox */
N
N/*******************  Bit definition for CAN_RF1R register  *******************/
N#define  CAN_RF1R_FMP1                       0x00000003U        /*!<FIFO 1 Message Pending        */
N#define  CAN_RF1R_FULL1                      0x00000008U        /*!<FIFO 1 Full                   */
N#define  CAN_RF1R_FOVR1                      0x00000010U        /*!<FIFO 1 Overrun                */
N#define  CAN_RF1R_RFOM1                      0x00000020U        /*!<Release FIFO 1 Output Mailbox */
N
N/********************  Bit definition for CAN_IER register  *******************/
N#define  CAN_IER_TMEIE                       0x00000001U        /*!<Transmit Mailbox Empty Interrupt Enable */
N#define  CAN_IER_FMPIE0                      0x00000002U        /*!<FIFO Message Pending Interrupt Enable   */
N#define  CAN_IER_FFIE0                       0x00000004U        /*!<FIFO Full Interrupt Enable              */
N#define  CAN_IER_FOVIE0                      0x00000008U        /*!<FIFO Overrun Interrupt Enable           */
N#define  CAN_IER_FMPIE1                      0x00000010U        /*!<FIFO Message Pending Interrupt Enable   */
N#define  CAN_IER_FFIE1                       0x00000020U        /*!<FIFO Full Interrupt Enable              */
N#define  CAN_IER_FOVIE1                      0x00000040U        /*!<FIFO Overrun Interrupt Enable           */
N#define  CAN_IER_EWGIE                       0x00000100U        /*!<Error Warning Interrupt Enable          */
N#define  CAN_IER_EPVIE                       0x00000200U        /*!<Error Passive Interrupt Enable          */
N#define  CAN_IER_BOFIE                       0x00000400U        /*!<Bus-Off Interrupt Enable                */
N#define  CAN_IER_LECIE                       0x00000800U        /*!<Last Error Code Interrupt Enable        */
N#define  CAN_IER_ERRIE                       0x00008000U        /*!<Error Interrupt Enable                  */
N#define  CAN_IER_WKUIE                       0x00010000U        /*!<Wakeup Interrupt Enable                 */
N#define  CAN_IER_SLKIE                       0x00020000U        /*!<Sleep Interrupt Enable                  */
N
N/********************  Bit definition for CAN_ESR register  *******************/
N#define  CAN_ESR_EWGF                        0x00000001U        /*!<Error Warning Flag */
N#define  CAN_ESR_EPVF                        0x00000002U        /*!<Error Passive Flag */
N#define  CAN_ESR_BOFF                        0x00000004U        /*!<Bus-Off Flag */
N
N#define  CAN_ESR_LEC                         0x00000070U        /*!<LEC[2:0] bits (Last Error Code) */
N#define  CAN_ESR_LEC_0                       0x00000010U        /*!<Bit 0 */
N#define  CAN_ESR_LEC_1                       0x00000020U        /*!<Bit 1 */
N#define  CAN_ESR_LEC_2                       0x00000040U        /*!<Bit 2 */
N
N#define  CAN_ESR_TEC                         0x00FF0000U        /*!<Least significant byte of the 9-bit Transmit Error Counter */
N#define  CAN_ESR_REC                         0xFF000000U        /*!<Receive Error Counter */
N
N/*******************  Bit definition for CAN_BTR register  ********************/
N#define  CAN_BTR_BRP                         0x000003FFU        /*!<Baud Rate Prescaler           */
N#define  CAN_BTR_TS1                         0x000F0000U        /*!<Time Segment 1                */
N#define  CAN_BTR_TS1_0                       0x00010000U        /*!<Bit 0 */
N#define  CAN_BTR_TS1_1                       0x00020000U        /*!<Bit 1 */
N#define  CAN_BTR_TS1_2                       0x00040000U        /*!<Bit 2 */
N#define  CAN_BTR_TS1_3                       0x00080000U        /*!<Bit 3 */
N#define  CAN_BTR_TS2                         0x00700000U        /*!<Time Segment 2                */
N#define  CAN_BTR_TS2_0                       0x00100000U        /*!<Bit 0 */
N#define  CAN_BTR_TS2_1                       0x00200000U        /*!<Bit 1 */
N#define  CAN_BTR_TS2_2                       0x00400000U        /*!<Bit 2 */
N#define  CAN_BTR_SJW                         0x03000000U        /*!<Resynchronization Jump Width  */
N#define  CAN_BTR_SJW_0                       0x01000000U        /*!<Bit 0 */
N#define  CAN_BTR_SJW_1                       0x02000000U        /*!<Bit 1 */
N#define  CAN_BTR_LBKM                        0x40000000U        /*!<Loop Back Mode (Debug)        */
N#define  CAN_BTR_SILM                        0x80000000U        /*!<Silent Mode                   */
N
N/*!<Mailbox registers */
N/******************  Bit definition for CAN_TI0R register  ********************/
N#define  CAN_TI0R_TXRQ                       0x00000001U        /*!<Transmit Mailbox Request                   */
N#define  CAN_TI0R_RTR                        0x00000002U        /*!<Remote Transmission Request                */
N#define  CAN_TI0R_IDE                        0x00000004U        /*!<Identifier Extension                       */
N#define  CAN_TI0R_EXID                       0x001FFFF8U        /*!<Extended Identifier                        */
N#define  CAN_TI0R_STID                       0xFFE00000U        /*!<Standard Identifier or Extended Identifier */
N
N/******************  Bit definition for CAN_TDT0R register  *******************/
N#define  CAN_TDT0R_DLC                       0x0000000FU        /*!<Data Length Code     */
N#define  CAN_TDT0R_TGT                       0x00000100U        /*!<Transmit Global Time */
N#define  CAN_TDT0R_TIME                      0xFFFF0000U        /*!<Message Time Stamp   */
N
N/******************  Bit definition for CAN_TDL0R register  *******************/
N#define  CAN_TDL0R_DATA0                     0x000000FFU        /*!<Data byte 0 */
N#define  CAN_TDL0R_DATA1                     0x0000FF00U        /*!<Data byte 1 */
N#define  CAN_TDL0R_DATA2                     0x00FF0000U        /*!<Data byte 2 */
N#define  CAN_TDL0R_DATA3                     0xFF000000U        /*!<Data byte 3 */
N
N/******************  Bit definition for CAN_TDH0R register  *******************/
N#define  CAN_TDH0R_DATA4                     0x000000FFU        /*!<Data byte 4 */
N#define  CAN_TDH0R_DATA5                     0x0000FF00U        /*!<Data byte 5 */
N#define  CAN_TDH0R_DATA6                     0x00FF0000U        /*!<Data byte 6 */
N#define  CAN_TDH0R_DATA7                     0xFF000000U        /*!<Data byte 7 */
N
N/*******************  Bit definition for CAN_TI1R register  *******************/
N#define  CAN_TI1R_TXRQ                       0x00000001U        /*!<Transmit Mailbox Request                   */
N#define  CAN_TI1R_RTR                        0x00000002U        /*!<Remote Transmission Request                */
N#define  CAN_TI1R_IDE                        0x00000004U        /*!<Identifier Extension                       */
N#define  CAN_TI1R_EXID                       0x001FFFF8U        /*!<Extended Identifier                        */
N#define  CAN_TI1R_STID                       0xFFE00000U        /*!<Standard Identifier or Extended Identifier */
N
N/*******************  Bit definition for CAN_TDT1R register  ******************/
N#define  CAN_TDT1R_DLC                       0x0000000FU        /*!<Data Length Code     */
N#define  CAN_TDT1R_TGT                       0x00000100U        /*!<Transmit Global Time */
N#define  CAN_TDT1R_TIME                      0xFFFF0000U        /*!<Message Time Stamp   */
N
N/*******************  Bit definition for CAN_TDL1R register  ******************/
N#define  CAN_TDL1R_DATA0                     0x000000FFU        /*!<Data byte 0 */
N#define  CAN_TDL1R_DATA1                     0x0000FF00U        /*!<Data byte 1 */
N#define  CAN_TDL1R_DATA2                     0x00FF0000U        /*!<Data byte 2 */
N#define  CAN_TDL1R_DATA3                     0xFF000000U        /*!<Data byte 3 */
N
N/*******************  Bit definition for CAN_TDH1R register  ******************/
N#define  CAN_TDH1R_DATA4                     0x000000FFU        /*!<Data byte 4 */
N#define  CAN_TDH1R_DATA5                     0x0000FF00U        /*!<Data byte 5 */
N#define  CAN_TDH1R_DATA6                     0x00FF0000U        /*!<Data byte 6 */
N#define  CAN_TDH1R_DATA7                     0xFF000000U        /*!<Data byte 7 */
N
N/*******************  Bit definition for CAN_TI2R register  *******************/
N#define  CAN_TI2R_TXRQ                       0x00000001U        /*!<Transmit Mailbox Request                   */
N#define  CAN_TI2R_RTR                        0x00000002U        /*!<Remote Transmission Request                */
N#define  CAN_TI2R_IDE                        0x00000004U        /*!<Identifier Extension                       */
N#define  CAN_TI2R_EXID                       0x001FFFF8U        /*!<Extended identifier                        */
N#define  CAN_TI2R_STID                       0xFFE00000U        /*!<Standard Identifier or Extended Identifier */
N
N/*******************  Bit definition for CAN_TDT2R register  ******************/  
N#define  CAN_TDT2R_DLC                       0x0000000FU        /*!<Data Length Code      */
N#define  CAN_TDT2R_TGT                       0x00000100U        /*!<Transmit Global Time  */
N#define  CAN_TDT2R_TIME                      0xFFFF0000U        /*!<Message Time Stamp    */
N
N/*******************  Bit definition for CAN_TDL2R register  ******************/
N#define  CAN_TDL2R_DATA0                     0x000000FFU        /*!<Data byte 0 */
N#define  CAN_TDL2R_DATA1                     0x0000FF00U        /*!<Data byte 1 */
N#define  CAN_TDL2R_DATA2                     0x00FF0000U        /*!<Data byte 2 */
N#define  CAN_TDL2R_DATA3                     0xFF000000U        /*!<Data byte 3 */
N
N/*******************  Bit definition for CAN_TDH2R register  ******************/
N#define  CAN_TDH2R_DATA4                     0x000000FFU        /*!<Data byte 4 */
N#define  CAN_TDH2R_DATA5                     0x0000FF00U        /*!<Data byte 5 */
N#define  CAN_TDH2R_DATA6                     0x00FF0000U        /*!<Data byte 6 */
N#define  CAN_TDH2R_DATA7                     0xFF000000U        /*!<Data byte 7 */
N
N/*******************  Bit definition for CAN_RI0R register  *******************/
N#define  CAN_RI0R_RTR                        0x00000002U        /*!<Remote Transmission Request                */
N#define  CAN_RI0R_IDE                        0x00000004U        /*!<Identifier Extension                       */
N#define  CAN_RI0R_EXID                       0x001FFFF8U        /*!<Extended Identifier                        */
N#define  CAN_RI0R_STID                       0xFFE00000U        /*!<Standard Identifier or Extended Identifier */
N
N/*******************  Bit definition for CAN_RDT0R register  ******************/
N#define  CAN_RDT0R_DLC                       0x0000000FU        /*!<Data Length Code */
N#define  CAN_RDT0R_FMI                       0x0000FF00U        /*!<Filter Match Index */
N#define  CAN_RDT0R_TIME                      0xFFFF0000U        /*!<Message Time Stamp */
N
N/*******************  Bit definition for CAN_RDL0R register  ******************/
N#define  CAN_RDL0R_DATA0                     0x000000FFU        /*!<Data byte 0 */
N#define  CAN_RDL0R_DATA1                     0x0000FF00U        /*!<Data byte 1 */
N#define  CAN_RDL0R_DATA2                     0x00FF0000U        /*!<Data byte 2 */
N#define  CAN_RDL0R_DATA3                     0xFF000000U        /*!<Data byte 3 */
N
N/*******************  Bit definition for CAN_RDH0R register  ******************/
N#define  CAN_RDH0R_DATA4                     0x000000FFU        /*!<Data byte 4 */
N#define  CAN_RDH0R_DATA5                     0x0000FF00U        /*!<Data byte 5 */
N#define  CAN_RDH0R_DATA6                     0x00FF0000U        /*!<Data byte 6 */
N#define  CAN_RDH0R_DATA7                     0xFF000000U        /*!<Data byte 7 */
N
N/*******************  Bit definition for CAN_RI1R register  *******************/
N#define  CAN_RI1R_RTR                        0x00000002U        /*!<Remote Transmission Request                */
N#define  CAN_RI1R_IDE                        0x00000004U        /*!<Identifier Extension                       */
N#define  CAN_RI1R_EXID                       0x001FFFF8U        /*!<Extended identifier                        */
N#define  CAN_RI1R_STID                       0xFFE00000U        /*!<Standard Identifier or Extended Identifier */
N
N/*******************  Bit definition for CAN_RDT1R register  ******************/
N#define  CAN_RDT1R_DLC                       0x0000000FU        /*!<Data Length Code   */
N#define  CAN_RDT1R_FMI                       0x0000FF00U        /*!<Filter Match Index */
N#define  CAN_RDT1R_TIME                      0xFFFF0000U        /*!<Message Time Stamp */
N
N/*******************  Bit definition for CAN_RDL1R register  ******************/
N#define  CAN_RDL1R_DATA0                     0x000000FFU        /*!<Data byte 0 */
N#define  CAN_RDL1R_DATA1                     0x0000FF00U        /*!<Data byte 1 */
N#define  CAN_RDL1R_DATA2                     0x00FF0000U        /*!<Data byte 2 */
N#define  CAN_RDL1R_DATA3                     0xFF000000U        /*!<Data byte 3 */
N
N/*******************  Bit definition for CAN_RDH1R register  ******************/
N#define  CAN_RDH1R_DATA4                     0x000000FFU        /*!<Data byte 4 */
N#define  CAN_RDH1R_DATA5                     0x0000FF00U        /*!<Data byte 5 */
N#define  CAN_RDH1R_DATA6                     0x00FF0000U        /*!<Data byte 6 */
N#define  CAN_RDH1R_DATA7                     0xFF000000U        /*!<Data byte 7 */
N
N/*!<CAN filter registers */
N/*******************  Bit definition for CAN_FMR register  ********************/
N#define  CAN_FMR_FINIT                       ((uint8_t)0x01U)               /*!<Filter Init Mode */
N#define  CAN_FMR_CAN2SB                      0x00003F00U        /*!<CAN2 start bank */
N
N/*******************  Bit definition for CAN_FM1R register  *******************/
N#define  CAN_FM1R_FBM                        0x3FFFU            /*!<Filter Mode */
N#define  CAN_FM1R_FBM0                       0x0001U            /*!<Filter Init Mode bit 0  */
N#define  CAN_FM1R_FBM1                       0x0002U            /*!<Filter Init Mode bit 1  */
N#define  CAN_FM1R_FBM2                       0x0004U            /*!<Filter Init Mode bit 2  */
N#define  CAN_FM1R_FBM3                       0x0008U            /*!<Filter Init Mode bit 3  */
N#define  CAN_FM1R_FBM4                       0x0010U            /*!<Filter Init Mode bit 4  */
N#define  CAN_FM1R_FBM5                       0x0020U            /*!<Filter Init Mode bit 5  */
N#define  CAN_FM1R_FBM6                       0x0040U            /*!<Filter Init Mode bit 6  */
N#define  CAN_FM1R_FBM7                       0x0080U            /*!<Filter Init Mode bit 7  */
N#define  CAN_FM1R_FBM8                       0x0100U            /*!<Filter Init Mode bit 8  */
N#define  CAN_FM1R_FBM9                       0x0200U            /*!<Filter Init Mode bit 9  */
N#define  CAN_FM1R_FBM10                      0x0400U            /*!<Filter Init Mode bit 10 */
N#define  CAN_FM1R_FBM11                      0x0800U            /*!<Filter Init Mode bit 11 */
N#define  CAN_FM1R_FBM12                      0x1000U            /*!<Filter Init Mode bit 12 */
N#define  CAN_FM1R_FBM13                      0x2000U            /*!<Filter Init Mode bit 13 */
N
N/*******************  Bit definition for CAN_FS1R register  *******************/
N#define  CAN_FS1R_FSC                        0x00003FFFU        /*!<Filter Scale Configuration        */
N#define  CAN_FS1R_FSC0                       0x00000001U        /*!<Filter Scale Configuration bit 0  */
N#define  CAN_FS1R_FSC1                       0x00000002U        /*!<Filter Scale Configuration bit 1  */
N#define  CAN_FS1R_FSC2                       0x00000004U        /*!<Filter Scale Configuration bit 2  */
N#define  CAN_FS1R_FSC3                       0x00000008U        /*!<Filter Scale Configuration bit 3  */
N#define  CAN_FS1R_FSC4                       0x00000010U        /*!<Filter Scale Configuration bit 4  */
N#define  CAN_FS1R_FSC5                       0x00000020U        /*!<Filter Scale Configuration bit 5  */
N#define  CAN_FS1R_FSC6                       0x00000040U        /*!<Filter Scale Configuration bit 6  */
N#define  CAN_FS1R_FSC7                       0x00000080U        /*!<Filter Scale Configuration bit 7  */
N#define  CAN_FS1R_FSC8                       0x00000100U        /*!<Filter Scale Configuration bit 8  */
N#define  CAN_FS1R_FSC9                       0x00000200U        /*!<Filter Scale Configuration bit 9  */
N#define  CAN_FS1R_FSC10                      0x00000400U        /*!<Filter Scale Configuration bit 10 */
N#define  CAN_FS1R_FSC11                      0x00000800U        /*!<Filter Scale Configuration bit 11 */
N#define  CAN_FS1R_FSC12                      0x00001000U        /*!<Filter Scale Configuration bit 12 */
N#define  CAN_FS1R_FSC13                      0x00002000U        /*!<Filter Scale Configuration bit 13 */
N
N/******************  Bit definition for CAN_FFA1R register  *******************/
N#define  CAN_FFA1R_FFA                       0x00003FFFU        /*!<Filter FIFO Assignment */
N#define  CAN_FFA1R_FFA0                      0x00000001U        /*!<Filter FIFO Assignment for Filter 0 */
N#define  CAN_FFA1R_FFA1                      0x00000002U        /*!<Filter FIFO Assignment for Filter 1 */
N#define  CAN_FFA1R_FFA2                      0x00000004U        /*!<Filter FIFO Assignment for Filter 2 */
N#define  CAN_FFA1R_FFA3                      0x00000008U        /*!<Filter FIFO Assignment for Filter 3 */
N#define  CAN_FFA1R_FFA4                      0x00000010U        /*!<Filter FIFO Assignment for Filter 4 */
N#define  CAN_FFA1R_FFA5                      0x00000020U        /*!<Filter FIFO Assignment for Filter 5 */
N#define  CAN_FFA1R_FFA6                      0x00000040U        /*!<Filter FIFO Assignment for Filter 6 */
N#define  CAN_FFA1R_FFA7                      0x00000080U        /*!<Filter FIFO Assignment for Filter 7 */
N#define  CAN_FFA1R_FFA8                      0x00000100U        /*!<Filter FIFO Assignment for Filter 8 */
N#define  CAN_FFA1R_FFA9                      0x00000200U        /*!<Filter FIFO Assignment for Filter 9 */
N#define  CAN_FFA1R_FFA10                     0x00000400U        /*!<Filter FIFO Assignment for Filter 10 */
N#define  CAN_FFA1R_FFA11                     0x00000800U        /*!<Filter FIFO Assignment for Filter 11 */
N#define  CAN_FFA1R_FFA12                     0x00001000U        /*!<Filter FIFO Assignment for Filter 12 */
N#define  CAN_FFA1R_FFA13                     0x00002000U        /*!<Filter FIFO Assignment for Filter 13 */
N
N/*******************  Bit definition for CAN_FA1R register  *******************/
N#define  CAN_FA1R_FACT                       0x00003FFFU        /*!<Filter Active    */
N#define  CAN_FA1R_FACT0                      0x00000001U        /*!<Filter 0 Active  */
N#define  CAN_FA1R_FACT1                      0x00000002U        /*!<Filter 1 Active  */
N#define  CAN_FA1R_FACT2                      0x00000004U        /*!<Filter 2 Active  */
N#define  CAN_FA1R_FACT3                      0x00000008U        /*!<Filter 3 Active  */
N#define  CAN_FA1R_FACT4                      0x00000010U        /*!<Filter 4 Active  */
N#define  CAN_FA1R_FACT5                      0x00000020U        /*!<Filter 5 Active  */
N#define  CAN_FA1R_FACT6                      0x00000040U        /*!<Filter 6 Active  */
N#define  CAN_FA1R_FACT7                      0x00000080U        /*!<Filter 7 Active  */
N#define  CAN_FA1R_FACT8                      0x00000100U        /*!<Filter 8 Active  */
N#define  CAN_FA1R_FACT9                      0x00000200U        /*!<Filter 9 Active  */
N#define  CAN_FA1R_FACT10                     0x00000400U        /*!<Filter 10 Active */
N#define  CAN_FA1R_FACT11                     0x00000800U        /*!<Filter 11 Active */
N#define  CAN_FA1R_FACT12                     0x00001000U        /*!<Filter 12 Active */
N#define  CAN_FA1R_FACT13                     0x00002000U        /*!<Filter 13 Active */
N
N/*******************  Bit definition for CAN_F0R1 register  *******************/
N#define  CAN_F0R1_FB0                        0x00000001U        /*!<Filter bit 0 */
N#define  CAN_F0R1_FB1                        0x00000002U        /*!<Filter bit 1 */
N#define  CAN_F0R1_FB2                        0x00000004U        /*!<Filter bit 2 */
N#define  CAN_F0R1_FB3                        0x00000008U        /*!<Filter bit 3 */
N#define  CAN_F0R1_FB4                        0x00000010U        /*!<Filter bit 4 */
N#define  CAN_F0R1_FB5                        0x00000020U        /*!<Filter bit 5 */
N#define  CAN_F0R1_FB6                        0x00000040U        /*!<Filter bit 6 */
N#define  CAN_F0R1_FB7                        0x00000080U        /*!<Filter bit 7 */
N#define  CAN_F0R1_FB8                        0x00000100U        /*!<Filter bit 8 */
N#define  CAN_F0R1_FB9                        0x00000200U        /*!<Filter bit 9 */
N#define  CAN_F0R1_FB10                       0x00000400U        /*!<Filter bit 10 */
N#define  CAN_F0R1_FB11                       0x00000800U        /*!<Filter bit 11 */
N#define  CAN_F0R1_FB12                       0x00001000U        /*!<Filter bit 12 */
N#define  CAN_F0R1_FB13                       0x00002000U        /*!<Filter bit 13 */
N#define  CAN_F0R1_FB14                       0x00004000U        /*!<Filter bit 14 */
N#define  CAN_F0R1_FB15                       0x00008000U        /*!<Filter bit 15 */
N#define  CAN_F0R1_FB16                       0x00010000U        /*!<Filter bit 16 */
N#define  CAN_F0R1_FB17                       0x00020000U        /*!<Filter bit 17 */
N#define  CAN_F0R1_FB18                       0x00040000U        /*!<Filter bit 18 */
N#define  CAN_F0R1_FB19                       0x00080000U        /*!<Filter bit 19 */
N#define  CAN_F0R1_FB20                       0x00100000U        /*!<Filter bit 20 */
N#define  CAN_F0R1_FB21                       0x00200000U        /*!<Filter bit 21 */
N#define  CAN_F0R1_FB22                       0x00400000U        /*!<Filter bit 22 */
N#define  CAN_F0R1_FB23                       0x00800000U        /*!<Filter bit 23 */
N#define  CAN_F0R1_FB24                       0x01000000U        /*!<Filter bit 24 */
N#define  CAN_F0R1_FB25                       0x02000000U        /*!<Filter bit 25 */
N#define  CAN_F0R1_FB26                       0x04000000U        /*!<Filter bit 26 */
N#define  CAN_F0R1_FB27                       0x08000000U        /*!<Filter bit 27 */
N#define  CAN_F0R1_FB28                       0x10000000U        /*!<Filter bit 28 */
N#define  CAN_F0R1_FB29                       0x20000000U        /*!<Filter bit 29 */
N#define  CAN_F0R1_FB30                       0x40000000U        /*!<Filter bit 30 */
N#define  CAN_F0R1_FB31                       0x80000000U        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F1R1 register  *******************/
N#define  CAN_F1R1_FB0                        0x00000001U        /*!<Filter bit 0 */
N#define  CAN_F1R1_FB1                        0x00000002U        /*!<Filter bit 1 */
N#define  CAN_F1R1_FB2                        0x00000004U        /*!<Filter bit 2 */
N#define  CAN_F1R1_FB3                        0x00000008U        /*!<Filter bit 3 */
N#define  CAN_F1R1_FB4                        0x00000010U        /*!<Filter bit 4 */
N#define  CAN_F1R1_FB5                        0x00000020U        /*!<Filter bit 5 */
N#define  CAN_F1R1_FB6                        0x00000040U        /*!<Filter bit 6 */
N#define  CAN_F1R1_FB7                        0x00000080U        /*!<Filter bit 7 */
N#define  CAN_F1R1_FB8                        0x00000100U        /*!<Filter bit 8 */
N#define  CAN_F1R1_FB9                        0x00000200U        /*!<Filter bit 9 */
N#define  CAN_F1R1_FB10                       0x00000400U        /*!<Filter bit 10 */
N#define  CAN_F1R1_FB11                       0x00000800U        /*!<Filter bit 11 */
N#define  CAN_F1R1_FB12                       0x00001000U        /*!<Filter bit 12 */
N#define  CAN_F1R1_FB13                       0x00002000U        /*!<Filter bit 13 */
N#define  CAN_F1R1_FB14                       0x00004000U        /*!<Filter bit 14 */
N#define  CAN_F1R1_FB15                       0x00008000U        /*!<Filter bit 15 */
N#define  CAN_F1R1_FB16                       0x00010000U        /*!<Filter bit 16 */
N#define  CAN_F1R1_FB17                       0x00020000U        /*!<Filter bit 17 */
N#define  CAN_F1R1_FB18                       0x00040000U        /*!<Filter bit 18 */
N#define  CAN_F1R1_FB19                       0x00080000U        /*!<Filter bit 19 */
N#define  CAN_F1R1_FB20                       0x00100000U        /*!<Filter bit 20 */
N#define  CAN_F1R1_FB21                       0x00200000U        /*!<Filter bit 21 */
N#define  CAN_F1R1_FB22                       0x00400000U        /*!<Filter bit 22 */
N#define  CAN_F1R1_FB23                       0x00800000U        /*!<Filter bit 23 */
N#define  CAN_F1R1_FB24                       0x01000000U        /*!<Filter bit 24 */
N#define  CAN_F1R1_FB25                       0x02000000U        /*!<Filter bit 25 */
N#define  CAN_F1R1_FB26                       0x04000000U        /*!<Filter bit 26 */
N#define  CAN_F1R1_FB27                       0x08000000U        /*!<Filter bit 27 */
N#define  CAN_F1R1_FB28                       0x10000000U        /*!<Filter bit 28 */
N#define  CAN_F1R1_FB29                       0x20000000U        /*!<Filter bit 29 */
N#define  CAN_F1R1_FB30                       0x40000000U        /*!<Filter bit 30 */
N#define  CAN_F1R1_FB31                       0x80000000U        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F2R1 register  *******************/
N#define  CAN_F2R1_FB0                        0x00000001U        /*!<Filter bit 0 */
N#define  CAN_F2R1_FB1                        0x00000002U        /*!<Filter bit 1 */
N#define  CAN_F2R1_FB2                        0x00000004U        /*!<Filter bit 2 */
N#define  CAN_F2R1_FB3                        0x00000008U        /*!<Filter bit 3 */
N#define  CAN_F2R1_FB4                        0x00000010U        /*!<Filter bit 4 */
N#define  CAN_F2R1_FB5                        0x00000020U        /*!<Filter bit 5 */
N#define  CAN_F2R1_FB6                        0x00000040U        /*!<Filter bit 6 */
N#define  CAN_F2R1_FB7                        0x00000080U        /*!<Filter bit 7 */
N#define  CAN_F2R1_FB8                        0x00000100U        /*!<Filter bit 8 */
N#define  CAN_F2R1_FB9                        0x00000200U        /*!<Filter bit 9 */
N#define  CAN_F2R1_FB10                       0x00000400U        /*!<Filter bit 10 */
N#define  CAN_F2R1_FB11                       0x00000800U        /*!<Filter bit 11 */
N#define  CAN_F2R1_FB12                       0x00001000U        /*!<Filter bit 12 */
N#define  CAN_F2R1_FB13                       0x00002000U        /*!<Filter bit 13 */
N#define  CAN_F2R1_FB14                       0x00004000U        /*!<Filter bit 14 */
N#define  CAN_F2R1_FB15                       0x00008000U        /*!<Filter bit 15 */
N#define  CAN_F2R1_FB16                       0x00010000U        /*!<Filter bit 16 */
N#define  CAN_F2R1_FB17                       0x00020000U        /*!<Filter bit 17 */
N#define  CAN_F2R1_FB18                       0x00040000U        /*!<Filter bit 18 */
N#define  CAN_F2R1_FB19                       0x00080000U        /*!<Filter bit 19 */
N#define  CAN_F2R1_FB20                       0x00100000U        /*!<Filter bit 20 */
N#define  CAN_F2R1_FB21                       0x00200000U        /*!<Filter bit 21 */
N#define  CAN_F2R1_FB22                       0x00400000U        /*!<Filter bit 22 */
N#define  CAN_F2R1_FB23                       0x00800000U        /*!<Filter bit 23 */
N#define  CAN_F2R1_FB24                       0x01000000U        /*!<Filter bit 24 */
N#define  CAN_F2R1_FB25                       0x02000000U        /*!<Filter bit 25 */
N#define  CAN_F2R1_FB26                       0x04000000U        /*!<Filter bit 26 */
N#define  CAN_F2R1_FB27                       0x08000000U        /*!<Filter bit 27 */
N#define  CAN_F2R1_FB28                       0x10000000U        /*!<Filter bit 28 */
N#define  CAN_F2R1_FB29                       0x20000000U        /*!<Filter bit 29 */
N#define  CAN_F2R1_FB30                       0x40000000U        /*!<Filter bit 30 */
N#define  CAN_F2R1_FB31                       0x80000000U        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F3R1 register  *******************/
N#define  CAN_F3R1_FB0                        0x00000001U        /*!<Filter bit 0 */
N#define  CAN_F3R1_FB1                        0x00000002U        /*!<Filter bit 1 */
N#define  CAN_F3R1_FB2                        0x00000004U        /*!<Filter bit 2 */
N#define  CAN_F3R1_FB3                        0x00000008U        /*!<Filter bit 3 */
N#define  CAN_F3R1_FB4                        0x00000010U        /*!<Filter bit 4 */
N#define  CAN_F3R1_FB5                        0x00000020U        /*!<Filter bit 5 */
N#define  CAN_F3R1_FB6                        0x00000040U        /*!<Filter bit 6 */
N#define  CAN_F3R1_FB7                        0x00000080U        /*!<Filter bit 7 */
N#define  CAN_F3R1_FB8                        0x00000100U        /*!<Filter bit 8 */
N#define  CAN_F3R1_FB9                        0x00000200U        /*!<Filter bit 9 */
N#define  CAN_F3R1_FB10                       0x00000400U        /*!<Filter bit 10 */
N#define  CAN_F3R1_FB11                       0x00000800U        /*!<Filter bit 11 */
N#define  CAN_F3R1_FB12                       0x00001000U        /*!<Filter bit 12 */
N#define  CAN_F3R1_FB13                       0x00002000U        /*!<Filter bit 13 */
N#define  CAN_F3R1_FB14                       0x00004000U        /*!<Filter bit 14 */
N#define  CAN_F3R1_FB15                       0x00008000U        /*!<Filter bit 15 */
N#define  CAN_F3R1_FB16                       0x00010000U        /*!<Filter bit 16 */
N#define  CAN_F3R1_FB17                       0x00020000U        /*!<Filter bit 17 */
N#define  CAN_F3R1_FB18                       0x00040000U        /*!<Filter bit 18 */
N#define  CAN_F3R1_FB19                       0x00080000U        /*!<Filter bit 19 */
N#define  CAN_F3R1_FB20                       0x00100000U        /*!<Filter bit 20 */
N#define  CAN_F3R1_FB21                       0x00200000U        /*!<Filter bit 21 */
N#define  CAN_F3R1_FB22                       0x00400000U        /*!<Filter bit 22 */
N#define  CAN_F3R1_FB23                       0x00800000U        /*!<Filter bit 23 */
N#define  CAN_F3R1_FB24                       0x01000000U        /*!<Filter bit 24 */
N#define  CAN_F3R1_FB25                       0x02000000U        /*!<Filter bit 25 */
N#define  CAN_F3R1_FB26                       0x04000000U        /*!<Filter bit 26 */
N#define  CAN_F3R1_FB27                       0x08000000U        /*!<Filter bit 27 */
N#define  CAN_F3R1_FB28                       0x10000000U        /*!<Filter bit 28 */
N#define  CAN_F3R1_FB29                       0x20000000U        /*!<Filter bit 29 */
N#define  CAN_F3R1_FB30                       0x40000000U        /*!<Filter bit 30 */
N#define  CAN_F3R1_FB31                       0x80000000U        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F4R1 register  *******************/
N#define  CAN_F4R1_FB0                        0x00000001U        /*!<Filter bit 0 */
N#define  CAN_F4R1_FB1                        0x00000002U        /*!<Filter bit 1 */
N#define  CAN_F4R1_FB2                        0x00000004U        /*!<Filter bit 2 */
N#define  CAN_F4R1_FB3                        0x00000008U        /*!<Filter bit 3 */
N#define  CAN_F4R1_FB4                        0x00000010U        /*!<Filter bit 4 */
N#define  CAN_F4R1_FB5                        0x00000020U        /*!<Filter bit 5 */
N#define  CAN_F4R1_FB6                        0x00000040U        /*!<Filter bit 6 */
N#define  CAN_F4R1_FB7                        0x00000080U        /*!<Filter bit 7 */
N#define  CAN_F4R1_FB8                        0x00000100U        /*!<Filter bit 8 */
N#define  CAN_F4R1_FB9                        0x00000200U        /*!<Filter bit 9 */
N#define  CAN_F4R1_FB10                       0x00000400U        /*!<Filter bit 10 */
N#define  CAN_F4R1_FB11                       0x00000800U        /*!<Filter bit 11 */
N#define  CAN_F4R1_FB12                       0x00001000U        /*!<Filter bit 12 */
N#define  CAN_F4R1_FB13                       0x00002000U        /*!<Filter bit 13 */
N#define  CAN_F4R1_FB14                       0x00004000U        /*!<Filter bit 14 */
N#define  CAN_F4R1_FB15                       0x00008000U        /*!<Filter bit 15 */
N#define  CAN_F4R1_FB16                       0x00010000U        /*!<Filter bit 16 */
N#define  CAN_F4R1_FB17                       0x00020000U        /*!<Filter bit 17 */
N#define  CAN_F4R1_FB18                       0x00040000U        /*!<Filter bit 18 */
N#define  CAN_F4R1_FB19                       0x00080000U        /*!<Filter bit 19 */
N#define  CAN_F4R1_FB20                       0x00100000U        /*!<Filter bit 20 */
N#define  CAN_F4R1_FB21                       0x00200000U        /*!<Filter bit 21 */
N#define  CAN_F4R1_FB22                       0x00400000U        /*!<Filter bit 22 */
N#define  CAN_F4R1_FB23                       0x00800000U        /*!<Filter bit 23 */
N#define  CAN_F4R1_FB24                       0x01000000U        /*!<Filter bit 24 */
N#define  CAN_F4R1_FB25                       0x02000000U        /*!<Filter bit 25 */
N#define  CAN_F4R1_FB26                       0x04000000U        /*!<Filter bit 26 */
N#define  CAN_F4R1_FB27                       0x08000000U        /*!<Filter bit 27 */
N#define  CAN_F4R1_FB28                       0x10000000U        /*!<Filter bit 28 */
N#define  CAN_F4R1_FB29                       0x20000000U        /*!<Filter bit 29 */
N#define  CAN_F4R1_FB30                       0x40000000U        /*!<Filter bit 30 */
N#define  CAN_F4R1_FB31                       0x80000000U        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F5R1 register  *******************/
N#define  CAN_F5R1_FB0                        0x00000001U        /*!<Filter bit 0 */
N#define  CAN_F5R1_FB1                        0x00000002U        /*!<Filter bit 1 */
N#define  CAN_F5R1_FB2                        0x00000004U        /*!<Filter bit 2 */
N#define  CAN_F5R1_FB3                        0x00000008U        /*!<Filter bit 3 */
N#define  CAN_F5R1_FB4                        0x00000010U        /*!<Filter bit 4 */
N#define  CAN_F5R1_FB5                        0x00000020U        /*!<Filter bit 5 */
N#define  CAN_F5R1_FB6                        0x00000040U        /*!<Filter bit 6 */
N#define  CAN_F5R1_FB7                        0x00000080U        /*!<Filter bit 7 */
N#define  CAN_F5R1_FB8                        0x00000100U        /*!<Filter bit 8 */
N#define  CAN_F5R1_FB9                        0x00000200U        /*!<Filter bit 9 */
N#define  CAN_F5R1_FB10                       0x00000400U        /*!<Filter bit 10 */
N#define  CAN_F5R1_FB11                       0x00000800U        /*!<Filter bit 11 */
N#define  CAN_F5R1_FB12                       0x00001000U        /*!<Filter bit 12 */
N#define  CAN_F5R1_FB13                       0x00002000U        /*!<Filter bit 13 */
N#define  CAN_F5R1_FB14                       0x00004000U        /*!<Filter bit 14 */
N#define  CAN_F5R1_FB15                       0x00008000U        /*!<Filter bit 15 */
N#define  CAN_F5R1_FB16                       0x00010000U        /*!<Filter bit 16 */
N#define  CAN_F5R1_FB17                       0x00020000U        /*!<Filter bit 17 */
N#define  CAN_F5R1_FB18                       0x00040000U        /*!<Filter bit 18 */
N#define  CAN_F5R1_FB19                       0x00080000U        /*!<Filter bit 19 */
N#define  CAN_F5R1_FB20                       0x00100000U        /*!<Filter bit 20 */
N#define  CAN_F5R1_FB21                       0x00200000U        /*!<Filter bit 21 */
N#define  CAN_F5R1_FB22                       0x00400000U        /*!<Filter bit 22 */
N#define  CAN_F5R1_FB23                       0x00800000U        /*!<Filter bit 23 */
N#define  CAN_F5R1_FB24                       0x01000000U        /*!<Filter bit 24 */
N#define  CAN_F5R1_FB25                       0x02000000U        /*!<Filter bit 25 */
N#define  CAN_F5R1_FB26                       0x04000000U        /*!<Filter bit 26 */
N#define  CAN_F5R1_FB27                       0x08000000U        /*!<Filter bit 27 */
N#define  CAN_F5R1_FB28                       0x10000000U        /*!<Filter bit 28 */
N#define  CAN_F5R1_FB29                       0x20000000U        /*!<Filter bit 29 */
N#define  CAN_F5R1_FB30                       0x40000000U        /*!<Filter bit 30 */
N#define  CAN_F5R1_FB31                       0x80000000U        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F6R1 register  *******************/
N#define  CAN_F6R1_FB0                        0x00000001U        /*!<Filter bit 0 */
N#define  CAN_F6R1_FB1                        0x00000002U        /*!<Filter bit 1 */
N#define  CAN_F6R1_FB2                        0x00000004U        /*!<Filter bit 2 */
N#define  CAN_F6R1_FB3                        0x00000008U        /*!<Filter bit 3 */
N#define  CAN_F6R1_FB4                        0x00000010U        /*!<Filter bit 4 */
N#define  CAN_F6R1_FB5                        0x00000020U        /*!<Filter bit 5 */
N#define  CAN_F6R1_FB6                        0x00000040U        /*!<Filter bit 6 */
N#define  CAN_F6R1_FB7                        0x00000080U        /*!<Filter bit 7 */
N#define  CAN_F6R1_FB8                        0x00000100U        /*!<Filter bit 8 */
N#define  CAN_F6R1_FB9                        0x00000200U        /*!<Filter bit 9 */
N#define  CAN_F6R1_FB10                       0x00000400U        /*!<Filter bit 10 */
N#define  CAN_F6R1_FB11                       0x00000800U        /*!<Filter bit 11 */
N#define  CAN_F6R1_FB12                       0x00001000U        /*!<Filter bit 12 */
N#define  CAN_F6R1_FB13                       0x00002000U        /*!<Filter bit 13 */
N#define  CAN_F6R1_FB14                       0x00004000U        /*!<Filter bit 14 */
N#define  CAN_F6R1_FB15                       0x00008000U        /*!<Filter bit 15 */
N#define  CAN_F6R1_FB16                       0x00010000U        /*!<Filter bit 16 */
N#define  CAN_F6R1_FB17                       0x00020000U        /*!<Filter bit 17 */
N#define  CAN_F6R1_FB18                       0x00040000U        /*!<Filter bit 18 */
N#define  CAN_F6R1_FB19                       0x00080000U        /*!<Filter bit 19 */
N#define  CAN_F6R1_FB20                       0x00100000U        /*!<Filter bit 20 */
N#define  CAN_F6R1_FB21                       0x00200000U        /*!<Filter bit 21 */
N#define  CAN_F6R1_FB22                       0x00400000U        /*!<Filter bit 22 */
N#define  CAN_F6R1_FB23                       0x00800000U        /*!<Filter bit 23 */
N#define  CAN_F6R1_FB24                       0x01000000U        /*!<Filter bit 24 */
N#define  CAN_F6R1_FB25                       0x02000000U        /*!<Filter bit 25 */
N#define  CAN_F6R1_FB26                       0x04000000U        /*!<Filter bit 26 */
N#define  CAN_F6R1_FB27                       0x08000000U        /*!<Filter bit 27 */
N#define  CAN_F6R1_FB28                       0x10000000U        /*!<Filter bit 28 */
N#define  CAN_F6R1_FB29                       0x20000000U        /*!<Filter bit 29 */
N#define  CAN_F6R1_FB30                       0x40000000U        /*!<Filter bit 30 */
N#define  CAN_F6R1_FB31                       0x80000000U        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F7R1 register  *******************/
N#define  CAN_F7R1_FB0                        0x00000001U        /*!<Filter bit 0 */
N#define  CAN_F7R1_FB1                        0x00000002U        /*!<Filter bit 1 */
N#define  CAN_F7R1_FB2                        0x00000004U        /*!<Filter bit 2 */
N#define  CAN_F7R1_FB3                        0x00000008U        /*!<Filter bit 3 */
N#define  CAN_F7R1_FB4                        0x00000010U        /*!<Filter bit 4 */
N#define  CAN_F7R1_FB5                        0x00000020U        /*!<Filter bit 5 */
N#define  CAN_F7R1_FB6                        0x00000040U        /*!<Filter bit 6 */
N#define  CAN_F7R1_FB7                        0x00000080U        /*!<Filter bit 7 */
N#define  CAN_F7R1_FB8                        0x00000100U        /*!<Filter bit 8 */
N#define  CAN_F7R1_FB9                        0x00000200U        /*!<Filter bit 9 */
N#define  CAN_F7R1_FB10                       0x00000400U        /*!<Filter bit 10 */
N#define  CAN_F7R1_FB11                       0x00000800U        /*!<Filter bit 11 */
N#define  CAN_F7R1_FB12                       0x00001000U        /*!<Filter bit 12 */
N#define  CAN_F7R1_FB13                       0x00002000U        /*!<Filter bit 13 */
N#define  CAN_F7R1_FB14                       0x00004000U        /*!<Filter bit 14 */
N#define  CAN_F7R1_FB15                       0x00008000U        /*!<Filter bit 15 */
N#define  CAN_F7R1_FB16                       0x00010000U        /*!<Filter bit 16 */
N#define  CAN_F7R1_FB17                       0x00020000U        /*!<Filter bit 17 */
N#define  CAN_F7R1_FB18                       0x00040000U        /*!<Filter bit 18 */
N#define  CAN_F7R1_FB19                       0x00080000U        /*!<Filter bit 19 */
N#define  CAN_F7R1_FB20                       0x00100000U        /*!<Filter bit 20 */
N#define  CAN_F7R1_FB21                       0x00200000U        /*!<Filter bit 21 */
N#define  CAN_F7R1_FB22                       0x00400000U        /*!<Filter bit 22 */
N#define  CAN_F7R1_FB23                       0x00800000U        /*!<Filter bit 23 */
N#define  CAN_F7R1_FB24                       0x01000000U        /*!<Filter bit 24 */
N#define  CAN_F7R1_FB25                       0x02000000U        /*!<Filter bit 25 */
N#define  CAN_F7R1_FB26                       0x04000000U        /*!<Filter bit 26 */
N#define  CAN_F7R1_FB27                       0x08000000U        /*!<Filter bit 27 */
N#define  CAN_F7R1_FB28                       0x10000000U        /*!<Filter bit 28 */
N#define  CAN_F7R1_FB29                       0x20000000U        /*!<Filter bit 29 */
N#define  CAN_F7R1_FB30                       0x40000000U        /*!<Filter bit 30 */
N#define  CAN_F7R1_FB31                       0x80000000U        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F8R1 register  *******************/
N#define  CAN_F8R1_FB0                        0x00000001U        /*!<Filter bit 0 */
N#define  CAN_F8R1_FB1                        0x00000002U        /*!<Filter bit 1 */
N#define  CAN_F8R1_FB2                        0x00000004U        /*!<Filter bit 2 */
N#define  CAN_F8R1_FB3                        0x00000008U        /*!<Filter bit 3 */
N#define  CAN_F8R1_FB4                        0x00000010U        /*!<Filter bit 4 */
N#define  CAN_F8R1_FB5                        0x00000020U        /*!<Filter bit 5 */
N#define  CAN_F8R1_FB6                        0x00000040U        /*!<Filter bit 6 */
N#define  CAN_F8R1_FB7                        0x00000080U        /*!<Filter bit 7 */
N#define  CAN_F8R1_FB8                        0x00000100U        /*!<Filter bit 8 */
N#define  CAN_F8R1_FB9                        0x00000200U        /*!<Filter bit 9 */
N#define  CAN_F8R1_FB10                       0x00000400U        /*!<Filter bit 10 */
N#define  CAN_F8R1_FB11                       0x00000800U        /*!<Filter bit 11 */
N#define  CAN_F8R1_FB12                       0x00001000U        /*!<Filter bit 12 */
N#define  CAN_F8R1_FB13                       0x00002000U        /*!<Filter bit 13 */
N#define  CAN_F8R1_FB14                       0x00004000U        /*!<Filter bit 14 */
N#define  CAN_F8R1_FB15                       0x00008000U        /*!<Filter bit 15 */
N#define  CAN_F8R1_FB16                       0x00010000U        /*!<Filter bit 16 */
N#define  CAN_F8R1_FB17                       0x00020000U        /*!<Filter bit 17 */
N#define  CAN_F8R1_FB18                       0x00040000U        /*!<Filter bit 18 */
N#define  CAN_F8R1_FB19                       0x00080000U        /*!<Filter bit 19 */
N#define  CAN_F8R1_FB20                       0x00100000U        /*!<Filter bit 20 */
N#define  CAN_F8R1_FB21                       0x00200000U        /*!<Filter bit 21 */
N#define  CAN_F8R1_FB22                       0x00400000U        /*!<Filter bit 22 */
N#define  CAN_F8R1_FB23                       0x00800000U        /*!<Filter bit 23 */
N#define  CAN_F8R1_FB24                       0x01000000U        /*!<Filter bit 24 */
N#define  CAN_F8R1_FB25                       0x02000000U        /*!<Filter bit 25 */
N#define  CAN_F8R1_FB26                       0x04000000U        /*!<Filter bit 26 */
N#define  CAN_F8R1_FB27                       0x08000000U        /*!<Filter bit 27 */
N#define  CAN_F8R1_FB28                       0x10000000U        /*!<Filter bit 28 */
N#define  CAN_F8R1_FB29                       0x20000000U        /*!<Filter bit 29 */
N#define  CAN_F8R1_FB30                       0x40000000U        /*!<Filter bit 30 */
N#define  CAN_F8R1_FB31                       0x80000000U        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F9R1 register  *******************/
N#define  CAN_F9R1_FB0                        0x00000001U        /*!<Filter bit 0 */
N#define  CAN_F9R1_FB1                        0x00000002U        /*!<Filter bit 1 */
N#define  CAN_F9R1_FB2                        0x00000004U        /*!<Filter bit 2 */
N#define  CAN_F9R1_FB3                        0x00000008U        /*!<Filter bit 3 */
N#define  CAN_F9R1_FB4                        0x00000010U        /*!<Filter bit 4 */
N#define  CAN_F9R1_FB5                        0x00000020U        /*!<Filter bit 5 */
N#define  CAN_F9R1_FB6                        0x00000040U        /*!<Filter bit 6 */
N#define  CAN_F9R1_FB7                        0x00000080U        /*!<Filter bit 7 */
N#define  CAN_F9R1_FB8                        0x00000100U        /*!<Filter bit 8 */
N#define  CAN_F9R1_FB9                        0x00000200U        /*!<Filter bit 9 */
N#define  CAN_F9R1_FB10                       0x00000400U        /*!<Filter bit 10 */
N#define  CAN_F9R1_FB11                       0x00000800U        /*!<Filter bit 11 */
N#define  CAN_F9R1_FB12                       0x00001000U        /*!<Filter bit 12 */
N#define  CAN_F9R1_FB13                       0x00002000U        /*!<Filter bit 13 */
N#define  CAN_F9R1_FB14                       0x00004000U        /*!<Filter bit 14 */
N#define  CAN_F9R1_FB15                       0x00008000U        /*!<Filter bit 15 */
N#define  CAN_F9R1_FB16                       0x00010000U        /*!<Filter bit 16 */
N#define  CAN_F9R1_FB17                       0x00020000U        /*!<Filter bit 17 */
N#define  CAN_F9R1_FB18                       0x00040000U        /*!<Filter bit 18 */
N#define  CAN_F9R1_FB19                       0x00080000U        /*!<Filter bit 19 */
N#define  CAN_F9R1_FB20                       0x00100000U        /*!<Filter bit 20 */
N#define  CAN_F9R1_FB21                       0x00200000U        /*!<Filter bit 21 */
N#define  CAN_F9R1_FB22                       0x00400000U        /*!<Filter bit 22 */
N#define  CAN_F9R1_FB23                       0x00800000U        /*!<Filter bit 23 */
N#define  CAN_F9R1_FB24                       0x01000000U        /*!<Filter bit 24 */
N#define  CAN_F9R1_FB25                       0x02000000U        /*!<Filter bit 25 */
N#define  CAN_F9R1_FB26                       0x04000000U        /*!<Filter bit 26 */
N#define  CAN_F9R1_FB27                       0x08000000U        /*!<Filter bit 27 */
N#define  CAN_F9R1_FB28                       0x10000000U        /*!<Filter bit 28 */
N#define  CAN_F9R1_FB29                       0x20000000U        /*!<Filter bit 29 */
N#define  CAN_F9R1_FB30                       0x40000000U        /*!<Filter bit 30 */
N#define  CAN_F9R1_FB31                       0x80000000U        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F10R1 register  ******************/
N#define  CAN_F10R1_FB0                       0x00000001U        /*!<Filter bit 0 */
N#define  CAN_F10R1_FB1                       0x00000002U        /*!<Filter bit 1 */
N#define  CAN_F10R1_FB2                       0x00000004U        /*!<Filter bit 2 */
N#define  CAN_F10R1_FB3                       0x00000008U        /*!<Filter bit 3 */
N#define  CAN_F10R1_FB4                       0x00000010U        /*!<Filter bit 4 */
N#define  CAN_F10R1_FB5                       0x00000020U        /*!<Filter bit 5 */
N#define  CAN_F10R1_FB6                       0x00000040U        /*!<Filter bit 6 */
N#define  CAN_F10R1_FB7                       0x00000080U        /*!<Filter bit 7 */
N#define  CAN_F10R1_FB8                       0x00000100U        /*!<Filter bit 8 */
N#define  CAN_F10R1_FB9                       0x00000200U        /*!<Filter bit 9 */
N#define  CAN_F10R1_FB10                      0x00000400U        /*!<Filter bit 10 */
N#define  CAN_F10R1_FB11                      0x00000800U        /*!<Filter bit 11 */
N#define  CAN_F10R1_FB12                      0x00001000U        /*!<Filter bit 12 */
N#define  CAN_F10R1_FB13                      0x00002000U        /*!<Filter bit 13 */
N#define  CAN_F10R1_FB14                      0x00004000U        /*!<Filter bit 14 */
N#define  CAN_F10R1_FB15                      0x00008000U        /*!<Filter bit 15 */
N#define  CAN_F10R1_FB16                      0x00010000U        /*!<Filter bit 16 */
N#define  CAN_F10R1_FB17                      0x00020000U        /*!<Filter bit 17 */
N#define  CAN_F10R1_FB18                      0x00040000U        /*!<Filter bit 18 */
N#define  CAN_F10R1_FB19                      0x00080000U        /*!<Filter bit 19 */
N#define  CAN_F10R1_FB20                      0x00100000U        /*!<Filter bit 20 */
N#define  CAN_F10R1_FB21                      0x00200000U        /*!<Filter bit 21 */
N#define  CAN_F10R1_FB22                      0x00400000U        /*!<Filter bit 22 */
N#define  CAN_F10R1_FB23                      0x00800000U        /*!<Filter bit 23 */
N#define  CAN_F10R1_FB24                      0x01000000U        /*!<Filter bit 24 */
N#define  CAN_F10R1_FB25                      0x02000000U        /*!<Filter bit 25 */
N#define  CAN_F10R1_FB26                      0x04000000U        /*!<Filter bit 26 */
N#define  CAN_F10R1_FB27                      0x08000000U        /*!<Filter bit 27 */
N#define  CAN_F10R1_FB28                      0x10000000U        /*!<Filter bit 28 */
N#define  CAN_F10R1_FB29                      0x20000000U        /*!<Filter bit 29 */
N#define  CAN_F10R1_FB30                      0x40000000U        /*!<Filter bit 30 */
N#define  CAN_F10R1_FB31                      0x80000000U        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F11R1 register  ******************/
N#define  CAN_F11R1_FB0                       0x00000001U        /*!<Filter bit 0 */
N#define  CAN_F11R1_FB1                       0x00000002U        /*!<Filter bit 1 */
N#define  CAN_F11R1_FB2                       0x00000004U        /*!<Filter bit 2 */
N#define  CAN_F11R1_FB3                       0x00000008U        /*!<Filter bit 3 */
N#define  CAN_F11R1_FB4                       0x00000010U        /*!<Filter bit 4 */
N#define  CAN_F11R1_FB5                       0x00000020U        /*!<Filter bit 5 */
N#define  CAN_F11R1_FB6                       0x00000040U        /*!<Filter bit 6 */
N#define  CAN_F11R1_FB7                       0x00000080U        /*!<Filter bit 7 */
N#define  CAN_F11R1_FB8                       0x00000100U        /*!<Filter bit 8 */
N#define  CAN_F11R1_FB9                       0x00000200U        /*!<Filter bit 9 */
N#define  CAN_F11R1_FB10                      0x00000400U        /*!<Filter bit 10 */
N#define  CAN_F11R1_FB11                      0x00000800U        /*!<Filter bit 11 */
N#define  CAN_F11R1_FB12                      0x00001000U        /*!<Filter bit 12 */
N#define  CAN_F11R1_FB13                      0x00002000U        /*!<Filter bit 13 */
N#define  CAN_F11R1_FB14                      0x00004000U        /*!<Filter bit 14 */
N#define  CAN_F11R1_FB15                      0x00008000U        /*!<Filter bit 15 */
N#define  CAN_F11R1_FB16                      0x00010000U        /*!<Filter bit 16 */
N#define  CAN_F11R1_FB17                      0x00020000U        /*!<Filter bit 17 */
N#define  CAN_F11R1_FB18                      0x00040000U        /*!<Filter bit 18 */
N#define  CAN_F11R1_FB19                      0x00080000U        /*!<Filter bit 19 */
N#define  CAN_F11R1_FB20                      0x00100000U        /*!<Filter bit 20 */
N#define  CAN_F11R1_FB21                      0x00200000U        /*!<Filter bit 21 */
N#define  CAN_F11R1_FB22                      0x00400000U        /*!<Filter bit 22 */
N#define  CAN_F11R1_FB23                      0x00800000U        /*!<Filter bit 23 */
N#define  CAN_F11R1_FB24                      0x01000000U        /*!<Filter bit 24 */
N#define  CAN_F11R1_FB25                      0x02000000U        /*!<Filter bit 25 */
N#define  CAN_F11R1_FB26                      0x04000000U        /*!<Filter bit 26 */
N#define  CAN_F11R1_FB27                      0x08000000U        /*!<Filter bit 27 */
N#define  CAN_F11R1_FB28                      0x10000000U        /*!<Filter bit 28 */
N#define  CAN_F11R1_FB29                      0x20000000U        /*!<Filter bit 29 */
N#define  CAN_F11R1_FB30                      0x40000000U        /*!<Filter bit 30 */
N#define  CAN_F11R1_FB31                      0x80000000U        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F12R1 register  ******************/
N#define  CAN_F12R1_FB0                       0x00000001U        /*!<Filter bit 0 */
N#define  CAN_F12R1_FB1                       0x00000002U        /*!<Filter bit 1 */
N#define  CAN_F12R1_FB2                       0x00000004U        /*!<Filter bit 2 */
N#define  CAN_F12R1_FB3                       0x00000008U        /*!<Filter bit 3 */
N#define  CAN_F12R1_FB4                       0x00000010U        /*!<Filter bit 4 */
N#define  CAN_F12R1_FB5                       0x00000020U        /*!<Filter bit 5 */
N#define  CAN_F12R1_FB6                       0x00000040U        /*!<Filter bit 6 */
N#define  CAN_F12R1_FB7                       0x00000080U        /*!<Filter bit 7 */
N#define  CAN_F12R1_FB8                       0x00000100U        /*!<Filter bit 8 */
N#define  CAN_F12R1_FB9                       0x00000200U        /*!<Filter bit 9 */
N#define  CAN_F12R1_FB10                      0x00000400U        /*!<Filter bit 10 */
N#define  CAN_F12R1_FB11                      0x00000800U        /*!<Filter bit 11 */
N#define  CAN_F12R1_FB12                      0x00001000U        /*!<Filter bit 12 */
N#define  CAN_F12R1_FB13                      0x00002000U        /*!<Filter bit 13 */
N#define  CAN_F12R1_FB14                      0x00004000U        /*!<Filter bit 14 */
N#define  CAN_F12R1_FB15                      0x00008000U        /*!<Filter bit 15 */
N#define  CAN_F12R1_FB16                      0x00010000U        /*!<Filter bit 16 */
N#define  CAN_F12R1_FB17                      0x00020000U        /*!<Filter bit 17 */
N#define  CAN_F12R1_FB18                      0x00040000U        /*!<Filter bit 18 */
N#define  CAN_F12R1_FB19                      0x00080000U        /*!<Filter bit 19 */
N#define  CAN_F12R1_FB20                      0x00100000U        /*!<Filter bit 20 */
N#define  CAN_F12R1_FB21                      0x00200000U        /*!<Filter bit 21 */
N#define  CAN_F12R1_FB22                      0x00400000U        /*!<Filter bit 22 */
N#define  CAN_F12R1_FB23                      0x00800000U        /*!<Filter bit 23 */
N#define  CAN_F12R1_FB24                      0x01000000U        /*!<Filter bit 24 */
N#define  CAN_F12R1_FB25                      0x02000000U        /*!<Filter bit 25 */
N#define  CAN_F12R1_FB26                      0x04000000U        /*!<Filter bit 26 */
N#define  CAN_F12R1_FB27                      0x08000000U        /*!<Filter bit 27 */
N#define  CAN_F12R1_FB28                      0x10000000U        /*!<Filter bit 28 */
N#define  CAN_F12R1_FB29                      0x20000000U        /*!<Filter bit 29 */
N#define  CAN_F12R1_FB30                      0x40000000U        /*!<Filter bit 30 */
N#define  CAN_F12R1_FB31                      0x80000000U        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F13R1 register  ******************/
N#define  CAN_F13R1_FB0                       0x00000001U        /*!<Filter bit 0 */
N#define  CAN_F13R1_FB1                       0x00000002U        /*!<Filter bit 1 */
N#define  CAN_F13R1_FB2                       0x00000004U        /*!<Filter bit 2 */
N#define  CAN_F13R1_FB3                       0x00000008U        /*!<Filter bit 3 */
N#define  CAN_F13R1_FB4                       0x00000010U        /*!<Filter bit 4 */
N#define  CAN_F13R1_FB5                       0x00000020U        /*!<Filter bit 5 */
N#define  CAN_F13R1_FB6                       0x00000040U        /*!<Filter bit 6 */
N#define  CAN_F13R1_FB7                       0x00000080U        /*!<Filter bit 7 */
N#define  CAN_F13R1_FB8                       0x00000100U        /*!<Filter bit 8 */
N#define  CAN_F13R1_FB9                       0x00000200U        /*!<Filter bit 9 */
N#define  CAN_F13R1_FB10                      0x00000400U        /*!<Filter bit 10 */
N#define  CAN_F13R1_FB11                      0x00000800U        /*!<Filter bit 11 */
N#define  CAN_F13R1_FB12                      0x00001000U        /*!<Filter bit 12 */
N#define  CAN_F13R1_FB13                      0x00002000U        /*!<Filter bit 13 */
N#define  CAN_F13R1_FB14                      0x00004000U        /*!<Filter bit 14 */
N#define  CAN_F13R1_FB15                      0x00008000U        /*!<Filter bit 15 */
N#define  CAN_F13R1_FB16                      0x00010000U        /*!<Filter bit 16 */
N#define  CAN_F13R1_FB17                      0x00020000U        /*!<Filter bit 17 */
N#define  CAN_F13R1_FB18                      0x00040000U        /*!<Filter bit 18 */
N#define  CAN_F13R1_FB19                      0x00080000U        /*!<Filter bit 19 */
N#define  CAN_F13R1_FB20                      0x00100000U        /*!<Filter bit 20 */
N#define  CAN_F13R1_FB21                      0x00200000U        /*!<Filter bit 21 */
N#define  CAN_F13R1_FB22                      0x00400000U        /*!<Filter bit 22 */
N#define  CAN_F13R1_FB23                      0x00800000U        /*!<Filter bit 23 */
N#define  CAN_F13R1_FB24                      0x01000000U        /*!<Filter bit 24 */
N#define  CAN_F13R1_FB25                      0x02000000U        /*!<Filter bit 25 */
N#define  CAN_F13R1_FB26                      0x04000000U        /*!<Filter bit 26 */
N#define  CAN_F13R1_FB27                      0x08000000U        /*!<Filter bit 27 */
N#define  CAN_F13R1_FB28                      0x10000000U        /*!<Filter bit 28 */
N#define  CAN_F13R1_FB29                      0x20000000U        /*!<Filter bit 29 */
N#define  CAN_F13R1_FB30                      0x40000000U        /*!<Filter bit 30 */
N#define  CAN_F13R1_FB31                      0x80000000U        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F0R2 register  *******************/
N#define  CAN_F0R2_FB0                        0x00000001U        /*!<Filter bit 0 */
N#define  CAN_F0R2_FB1                        0x00000002U        /*!<Filter bit 1 */
N#define  CAN_F0R2_FB2                        0x00000004U        /*!<Filter bit 2 */
N#define  CAN_F0R2_FB3                        0x00000008U        /*!<Filter bit 3 */
N#define  CAN_F0R2_FB4                        0x00000010U        /*!<Filter bit 4 */
N#define  CAN_F0R2_FB5                        0x00000020U        /*!<Filter bit 5 */
N#define  CAN_F0R2_FB6                        0x00000040U        /*!<Filter bit 6 */
N#define  CAN_F0R2_FB7                        0x00000080U        /*!<Filter bit 7 */
N#define  CAN_F0R2_FB8                        0x00000100U        /*!<Filter bit 8 */
N#define  CAN_F0R2_FB9                        0x00000200U        /*!<Filter bit 9 */
N#define  CAN_F0R2_FB10                       0x00000400U        /*!<Filter bit 10 */
N#define  CAN_F0R2_FB11                       0x00000800U        /*!<Filter bit 11 */
N#define  CAN_F0R2_FB12                       0x00001000U        /*!<Filter bit 12 */
N#define  CAN_F0R2_FB13                       0x00002000U        /*!<Filter bit 13 */
N#define  CAN_F0R2_FB14                       0x00004000U        /*!<Filter bit 14 */
N#define  CAN_F0R2_FB15                       0x00008000U        /*!<Filter bit 15 */
N#define  CAN_F0R2_FB16                       0x00010000U        /*!<Filter bit 16 */
N#define  CAN_F0R2_FB17                       0x00020000U        /*!<Filter bit 17 */
N#define  CAN_F0R2_FB18                       0x00040000U        /*!<Filter bit 18 */
N#define  CAN_F0R2_FB19                       0x00080000U        /*!<Filter bit 19 */
N#define  CAN_F0R2_FB20                       0x00100000U        /*!<Filter bit 20 */
N#define  CAN_F0R2_FB21                       0x00200000U        /*!<Filter bit 21 */
N#define  CAN_F0R2_FB22                       0x00400000U        /*!<Filter bit 22 */
N#define  CAN_F0R2_FB23                       0x00800000U        /*!<Filter bit 23 */
N#define  CAN_F0R2_FB24                       0x01000000U        /*!<Filter bit 24 */
N#define  CAN_F0R2_FB25                       0x02000000U        /*!<Filter bit 25 */
N#define  CAN_F0R2_FB26                       0x04000000U        /*!<Filter bit 26 */
N#define  CAN_F0R2_FB27                       0x08000000U        /*!<Filter bit 27 */
N#define  CAN_F0R2_FB28                       0x10000000U        /*!<Filter bit 28 */
N#define  CAN_F0R2_FB29                       0x20000000U        /*!<Filter bit 29 */
N#define  CAN_F0R2_FB30                       0x40000000U        /*!<Filter bit 30 */
N#define  CAN_F0R2_FB31                       0x80000000U        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F1R2 register  *******************/
N#define  CAN_F1R2_FB0                        0x00000001U        /*!<Filter bit 0 */
N#define  CAN_F1R2_FB1                        0x00000002U        /*!<Filter bit 1 */
N#define  CAN_F1R2_FB2                        0x00000004U        /*!<Filter bit 2 */
N#define  CAN_F1R2_FB3                        0x00000008U        /*!<Filter bit 3 */
N#define  CAN_F1R2_FB4                        0x00000010U        /*!<Filter bit 4 */
N#define  CAN_F1R2_FB5                        0x00000020U        /*!<Filter bit 5 */
N#define  CAN_F1R2_FB6                        0x00000040U        /*!<Filter bit 6 */
N#define  CAN_F1R2_FB7                        0x00000080U        /*!<Filter bit 7 */
N#define  CAN_F1R2_FB8                        0x00000100U        /*!<Filter bit 8 */
N#define  CAN_F1R2_FB9                        0x00000200U        /*!<Filter bit 9 */
N#define  CAN_F1R2_FB10                       0x00000400U        /*!<Filter bit 10 */
N#define  CAN_F1R2_FB11                       0x00000800U        /*!<Filter bit 11 */
N#define  CAN_F1R2_FB12                       0x00001000U        /*!<Filter bit 12 */
N#define  CAN_F1R2_FB13                       0x00002000U        /*!<Filter bit 13 */
N#define  CAN_F1R2_FB14                       0x00004000U        /*!<Filter bit 14 */
N#define  CAN_F1R2_FB15                       0x00008000U        /*!<Filter bit 15 */
N#define  CAN_F1R2_FB16                       0x00010000U        /*!<Filter bit 16 */
N#define  CAN_F1R2_FB17                       0x00020000U        /*!<Filter bit 17 */
N#define  CAN_F1R2_FB18                       0x00040000U        /*!<Filter bit 18 */
N#define  CAN_F1R2_FB19                       0x00080000U        /*!<Filter bit 19 */
N#define  CAN_F1R2_FB20                       0x00100000U        /*!<Filter bit 20 */
N#define  CAN_F1R2_FB21                       0x00200000U        /*!<Filter bit 21 */
N#define  CAN_F1R2_FB22                       0x00400000U        /*!<Filter bit 22 */
N#define  CAN_F1R2_FB23                       0x00800000U        /*!<Filter bit 23 */
N#define  CAN_F1R2_FB24                       0x01000000U        /*!<Filter bit 24 */
N#define  CAN_F1R2_FB25                       0x02000000U        /*!<Filter bit 25 */
N#define  CAN_F1R2_FB26                       0x04000000U        /*!<Filter bit 26 */
N#define  CAN_F1R2_FB27                       0x08000000U        /*!<Filter bit 27 */
N#define  CAN_F1R2_FB28                       0x10000000U        /*!<Filter bit 28 */
N#define  CAN_F1R2_FB29                       0x20000000U        /*!<Filter bit 29 */
N#define  CAN_F1R2_FB30                       0x40000000U        /*!<Filter bit 30 */
N#define  CAN_F1R2_FB31                       0x80000000U        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F2R2 register  *******************/
N#define  CAN_F2R2_FB0                        0x00000001U        /*!<Filter bit 0 */
N#define  CAN_F2R2_FB1                        0x00000002U        /*!<Filter bit 1 */
N#define  CAN_F2R2_FB2                        0x00000004U        /*!<Filter bit 2 */
N#define  CAN_F2R2_FB3                        0x00000008U        /*!<Filter bit 3 */
N#define  CAN_F2R2_FB4                        0x00000010U        /*!<Filter bit 4 */
N#define  CAN_F2R2_FB5                        0x00000020U        /*!<Filter bit 5 */
N#define  CAN_F2R2_FB6                        0x00000040U        /*!<Filter bit 6 */
N#define  CAN_F2R2_FB7                        0x00000080U        /*!<Filter bit 7 */
N#define  CAN_F2R2_FB8                        0x00000100U        /*!<Filter bit 8 */
N#define  CAN_F2R2_FB9                        0x00000200U        /*!<Filter bit 9 */
N#define  CAN_F2R2_FB10                       0x00000400U        /*!<Filter bit 10 */
N#define  CAN_F2R2_FB11                       0x00000800U        /*!<Filter bit 11 */
N#define  CAN_F2R2_FB12                       0x00001000U        /*!<Filter bit 12 */
N#define  CAN_F2R2_FB13                       0x00002000U        /*!<Filter bit 13 */
N#define  CAN_F2R2_FB14                       0x00004000U        /*!<Filter bit 14 */
N#define  CAN_F2R2_FB15                       0x00008000U        /*!<Filter bit 15 */
N#define  CAN_F2R2_FB16                       0x00010000U        /*!<Filter bit 16 */
N#define  CAN_F2R2_FB17                       0x00020000U        /*!<Filter bit 17 */
N#define  CAN_F2R2_FB18                       0x00040000U        /*!<Filter bit 18 */
N#define  CAN_F2R2_FB19                       0x00080000U        /*!<Filter bit 19 */
N#define  CAN_F2R2_FB20                       0x00100000U        /*!<Filter bit 20 */
N#define  CAN_F2R2_FB21                       0x00200000U        /*!<Filter bit 21 */
N#define  CAN_F2R2_FB22                       0x00400000U        /*!<Filter bit 22 */
N#define  CAN_F2R2_FB23                       0x00800000U        /*!<Filter bit 23 */
N#define  CAN_F2R2_FB24                       0x01000000U        /*!<Filter bit 24 */
N#define  CAN_F2R2_FB25                       0x02000000U        /*!<Filter bit 25 */
N#define  CAN_F2R2_FB26                       0x04000000U        /*!<Filter bit 26 */
N#define  CAN_F2R2_FB27                       0x08000000U        /*!<Filter bit 27 */
N#define  CAN_F2R2_FB28                       0x10000000U        /*!<Filter bit 28 */
N#define  CAN_F2R2_FB29                       0x20000000U        /*!<Filter bit 29 */
N#define  CAN_F2R2_FB30                       0x40000000U        /*!<Filter bit 30 */
N#define  CAN_F2R2_FB31                       0x80000000U        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F3R2 register  *******************/
N#define  CAN_F3R2_FB0                        0x00000001U        /*!<Filter bit 0 */
N#define  CAN_F3R2_FB1                        0x00000002U        /*!<Filter bit 1 */
N#define  CAN_F3R2_FB2                        0x00000004U        /*!<Filter bit 2 */
N#define  CAN_F3R2_FB3                        0x00000008U        /*!<Filter bit 3 */
N#define  CAN_F3R2_FB4                        0x00000010U        /*!<Filter bit 4 */
N#define  CAN_F3R2_FB5                        0x00000020U        /*!<Filter bit 5 */
N#define  CAN_F3R2_FB6                        0x00000040U        /*!<Filter bit 6 */
N#define  CAN_F3R2_FB7                        0x00000080U        /*!<Filter bit 7 */
N#define  CAN_F3R2_FB8                        0x00000100U        /*!<Filter bit 8 */
N#define  CAN_F3R2_FB9                        0x00000200U        /*!<Filter bit 9 */
N#define  CAN_F3R2_FB10                       0x00000400U        /*!<Filter bit 10 */
N#define  CAN_F3R2_FB11                       0x00000800U        /*!<Filter bit 11 */
N#define  CAN_F3R2_FB12                       0x00001000U        /*!<Filter bit 12 */
N#define  CAN_F3R2_FB13                       0x00002000U        /*!<Filter bit 13 */
N#define  CAN_F3R2_FB14                       0x00004000U        /*!<Filter bit 14 */
N#define  CAN_F3R2_FB15                       0x00008000U        /*!<Filter bit 15 */
N#define  CAN_F3R2_FB16                       0x00010000U        /*!<Filter bit 16 */
N#define  CAN_F3R2_FB17                       0x00020000U        /*!<Filter bit 17 */
N#define  CAN_F3R2_FB18                       0x00040000U        /*!<Filter bit 18 */
N#define  CAN_F3R2_FB19                       0x00080000U        /*!<Filter bit 19 */
N#define  CAN_F3R2_FB20                       0x00100000U        /*!<Filter bit 20 */
N#define  CAN_F3R2_FB21                       0x00200000U        /*!<Filter bit 21 */
N#define  CAN_F3R2_FB22                       0x00400000U        /*!<Filter bit 22 */
N#define  CAN_F3R2_FB23                       0x00800000U        /*!<Filter bit 23 */
N#define  CAN_F3R2_FB24                       0x01000000U        /*!<Filter bit 24 */
N#define  CAN_F3R2_FB25                       0x02000000U        /*!<Filter bit 25 */
N#define  CAN_F3R2_FB26                       0x04000000U        /*!<Filter bit 26 */
N#define  CAN_F3R2_FB27                       0x08000000U        /*!<Filter bit 27 */
N#define  CAN_F3R2_FB28                       0x10000000U        /*!<Filter bit 28 */
N#define  CAN_F3R2_FB29                       0x20000000U        /*!<Filter bit 29 */
N#define  CAN_F3R2_FB30                       0x40000000U        /*!<Filter bit 30 */
N#define  CAN_F3R2_FB31                       0x80000000U        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F4R2 register  *******************/
N#define  CAN_F4R2_FB0                        0x00000001U        /*!<Filter bit 0 */
N#define  CAN_F4R2_FB1                        0x00000002U        /*!<Filter bit 1 */
N#define  CAN_F4R2_FB2                        0x00000004U        /*!<Filter bit 2 */
N#define  CAN_F4R2_FB3                        0x00000008U        /*!<Filter bit 3 */
N#define  CAN_F4R2_FB4                        0x00000010U        /*!<Filter bit 4 */
N#define  CAN_F4R2_FB5                        0x00000020U        /*!<Filter bit 5 */
N#define  CAN_F4R2_FB6                        0x00000040U        /*!<Filter bit 6 */
N#define  CAN_F4R2_FB7                        0x00000080U        /*!<Filter bit 7 */
N#define  CAN_F4R2_FB8                        0x00000100U        /*!<Filter bit 8 */
N#define  CAN_F4R2_FB9                        0x00000200U        /*!<Filter bit 9 */
N#define  CAN_F4R2_FB10                       0x00000400U        /*!<Filter bit 10 */
N#define  CAN_F4R2_FB11                       0x00000800U        /*!<Filter bit 11 */
N#define  CAN_F4R2_FB12                       0x00001000U        /*!<Filter bit 12 */
N#define  CAN_F4R2_FB13                       0x00002000U        /*!<Filter bit 13 */
N#define  CAN_F4R2_FB14                       0x00004000U        /*!<Filter bit 14 */
N#define  CAN_F4R2_FB15                       0x00008000U        /*!<Filter bit 15 */
N#define  CAN_F4R2_FB16                       0x00010000U        /*!<Filter bit 16 */
N#define  CAN_F4R2_FB17                       0x00020000U        /*!<Filter bit 17 */
N#define  CAN_F4R2_FB18                       0x00040000U        /*!<Filter bit 18 */
N#define  CAN_F4R2_FB19                       0x00080000U        /*!<Filter bit 19 */
N#define  CAN_F4R2_FB20                       0x00100000U        /*!<Filter bit 20 */
N#define  CAN_F4R2_FB21                       0x00200000U        /*!<Filter bit 21 */
N#define  CAN_F4R2_FB22                       0x00400000U        /*!<Filter bit 22 */
N#define  CAN_F4R2_FB23                       0x00800000U        /*!<Filter bit 23 */
N#define  CAN_F4R2_FB24                       0x01000000U        /*!<Filter bit 24 */
N#define  CAN_F4R2_FB25                       0x02000000U        /*!<Filter bit 25 */
N#define  CAN_F4R2_FB26                       0x04000000U        /*!<Filter bit 26 */
N#define  CAN_F4R2_FB27                       0x08000000U        /*!<Filter bit 27 */
N#define  CAN_F4R2_FB28                       0x10000000U        /*!<Filter bit 28 */
N#define  CAN_F4R2_FB29                       0x20000000U        /*!<Filter bit 29 */
N#define  CAN_F4R2_FB30                       0x40000000U        /*!<Filter bit 30 */
N#define  CAN_F4R2_FB31                       0x80000000U        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F5R2 register  *******************/
N#define  CAN_F5R2_FB0                        0x00000001U        /*!<Filter bit 0 */
N#define  CAN_F5R2_FB1                        0x00000002U        /*!<Filter bit 1 */
N#define  CAN_F5R2_FB2                        0x00000004U        /*!<Filter bit 2 */
N#define  CAN_F5R2_FB3                        0x00000008U        /*!<Filter bit 3 */
N#define  CAN_F5R2_FB4                        0x00000010U        /*!<Filter bit 4 */
N#define  CAN_F5R2_FB5                        0x00000020U        /*!<Filter bit 5 */
N#define  CAN_F5R2_FB6                        0x00000040U        /*!<Filter bit 6 */
N#define  CAN_F5R2_FB7                        0x00000080U        /*!<Filter bit 7 */
N#define  CAN_F5R2_FB8                        0x00000100U        /*!<Filter bit 8 */
N#define  CAN_F5R2_FB9                        0x00000200U        /*!<Filter bit 9 */
N#define  CAN_F5R2_FB10                       0x00000400U        /*!<Filter bit 10 */
N#define  CAN_F5R2_FB11                       0x00000800U        /*!<Filter bit 11 */
N#define  CAN_F5R2_FB12                       0x00001000U        /*!<Filter bit 12 */
N#define  CAN_F5R2_FB13                       0x00002000U        /*!<Filter bit 13 */
N#define  CAN_F5R2_FB14                       0x00004000U        /*!<Filter bit 14 */
N#define  CAN_F5R2_FB15                       0x00008000U        /*!<Filter bit 15 */
N#define  CAN_F5R2_FB16                       0x00010000U        /*!<Filter bit 16 */
N#define  CAN_F5R2_FB17                       0x00020000U        /*!<Filter bit 17 */
N#define  CAN_F5R2_FB18                       0x00040000U        /*!<Filter bit 18 */
N#define  CAN_F5R2_FB19                       0x00080000U        /*!<Filter bit 19 */
N#define  CAN_F5R2_FB20                       0x00100000U        /*!<Filter bit 20 */
N#define  CAN_F5R2_FB21                       0x00200000U        /*!<Filter bit 21 */
N#define  CAN_F5R2_FB22                       0x00400000U        /*!<Filter bit 22 */
N#define  CAN_F5R2_FB23                       0x00800000U        /*!<Filter bit 23 */
N#define  CAN_F5R2_FB24                       0x01000000U        /*!<Filter bit 24 */
N#define  CAN_F5R2_FB25                       0x02000000U        /*!<Filter bit 25 */
N#define  CAN_F5R2_FB26                       0x04000000U        /*!<Filter bit 26 */
N#define  CAN_F5R2_FB27                       0x08000000U        /*!<Filter bit 27 */
N#define  CAN_F5R2_FB28                       0x10000000U        /*!<Filter bit 28 */
N#define  CAN_F5R2_FB29                       0x20000000U        /*!<Filter bit 29 */
N#define  CAN_F5R2_FB30                       0x40000000U        /*!<Filter bit 30 */
N#define  CAN_F5R2_FB31                       0x80000000U        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F6R2 register  *******************/
N#define  CAN_F6R2_FB0                        0x00000001U        /*!<Filter bit 0 */
N#define  CAN_F6R2_FB1                        0x00000002U        /*!<Filter bit 1 */
N#define  CAN_F6R2_FB2                        0x00000004U        /*!<Filter bit 2 */
N#define  CAN_F6R2_FB3                        0x00000008U        /*!<Filter bit 3 */
N#define  CAN_F6R2_FB4                        0x00000010U        /*!<Filter bit 4 */
N#define  CAN_F6R2_FB5                        0x00000020U        /*!<Filter bit 5 */
N#define  CAN_F6R2_FB6                        0x00000040U        /*!<Filter bit 6 */
N#define  CAN_F6R2_FB7                        0x00000080U        /*!<Filter bit 7 */
N#define  CAN_F6R2_FB8                        0x00000100U        /*!<Filter bit 8 */
N#define  CAN_F6R2_FB9                        0x00000200U        /*!<Filter bit 9 */
N#define  CAN_F6R2_FB10                       0x00000400U        /*!<Filter bit 10 */
N#define  CAN_F6R2_FB11                       0x00000800U        /*!<Filter bit 11 */
N#define  CAN_F6R2_FB12                       0x00001000U        /*!<Filter bit 12 */
N#define  CAN_F6R2_FB13                       0x00002000U        /*!<Filter bit 13 */
N#define  CAN_F6R2_FB14                       0x00004000U        /*!<Filter bit 14 */
N#define  CAN_F6R2_FB15                       0x00008000U        /*!<Filter bit 15 */
N#define  CAN_F6R2_FB16                       0x00010000U        /*!<Filter bit 16 */
N#define  CAN_F6R2_FB17                       0x00020000U        /*!<Filter bit 17 */
N#define  CAN_F6R2_FB18                       0x00040000U        /*!<Filter bit 18 */
N#define  CAN_F6R2_FB19                       0x00080000U        /*!<Filter bit 19 */
N#define  CAN_F6R2_FB20                       0x00100000U        /*!<Filter bit 20 */
N#define  CAN_F6R2_FB21                       0x00200000U        /*!<Filter bit 21 */
N#define  CAN_F6R2_FB22                       0x00400000U        /*!<Filter bit 22 */
N#define  CAN_F6R2_FB23                       0x00800000U        /*!<Filter bit 23 */
N#define  CAN_F6R2_FB24                       0x01000000U        /*!<Filter bit 24 */
N#define  CAN_F6R2_FB25                       0x02000000U        /*!<Filter bit 25 */
N#define  CAN_F6R2_FB26                       0x04000000U        /*!<Filter bit 26 */
N#define  CAN_F6R2_FB27                       0x08000000U        /*!<Filter bit 27 */
N#define  CAN_F6R2_FB28                       0x10000000U        /*!<Filter bit 28 */
N#define  CAN_F6R2_FB29                       0x20000000U        /*!<Filter bit 29 */
N#define  CAN_F6R2_FB30                       0x40000000U        /*!<Filter bit 30 */
N#define  CAN_F6R2_FB31                       0x80000000U        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F7R2 register  *******************/
N#define  CAN_F7R2_FB0                        0x00000001U        /*!<Filter bit 0 */
N#define  CAN_F7R2_FB1                        0x00000002U        /*!<Filter bit 1 */
N#define  CAN_F7R2_FB2                        0x00000004U        /*!<Filter bit 2 */
N#define  CAN_F7R2_FB3                        0x00000008U        /*!<Filter bit 3 */
N#define  CAN_F7R2_FB4                        0x00000010U        /*!<Filter bit 4 */
N#define  CAN_F7R2_FB5                        0x00000020U        /*!<Filter bit 5 */
N#define  CAN_F7R2_FB6                        0x00000040U        /*!<Filter bit 6 */
N#define  CAN_F7R2_FB7                        0x00000080U        /*!<Filter bit 7 */
N#define  CAN_F7R2_FB8                        0x00000100U        /*!<Filter bit 8 */
N#define  CAN_F7R2_FB9                        0x00000200U        /*!<Filter bit 9 */
N#define  CAN_F7R2_FB10                       0x00000400U        /*!<Filter bit 10 */
N#define  CAN_F7R2_FB11                       0x00000800U        /*!<Filter bit 11 */
N#define  CAN_F7R2_FB12                       0x00001000U        /*!<Filter bit 12 */
N#define  CAN_F7R2_FB13                       0x00002000U        /*!<Filter bit 13 */
N#define  CAN_F7R2_FB14                       0x00004000U        /*!<Filter bit 14 */
N#define  CAN_F7R2_FB15                       0x00008000U        /*!<Filter bit 15 */
N#define  CAN_F7R2_FB16                       0x00010000U        /*!<Filter bit 16 */
N#define  CAN_F7R2_FB17                       0x00020000U        /*!<Filter bit 17 */
N#define  CAN_F7R2_FB18                       0x00040000U        /*!<Filter bit 18 */
N#define  CAN_F7R2_FB19                       0x00080000U        /*!<Filter bit 19 */
N#define  CAN_F7R2_FB20                       0x00100000U        /*!<Filter bit 20 */
N#define  CAN_F7R2_FB21                       0x00200000U        /*!<Filter bit 21 */
N#define  CAN_F7R2_FB22                       0x00400000U        /*!<Filter bit 22 */
N#define  CAN_F7R2_FB23                       0x00800000U        /*!<Filter bit 23 */
N#define  CAN_F7R2_FB24                       0x01000000U        /*!<Filter bit 24 */
N#define  CAN_F7R2_FB25                       0x02000000U        /*!<Filter bit 25 */
N#define  CAN_F7R2_FB26                       0x04000000U        /*!<Filter bit 26 */
N#define  CAN_F7R2_FB27                       0x08000000U        /*!<Filter bit 27 */
N#define  CAN_F7R2_FB28                       0x10000000U        /*!<Filter bit 28 */
N#define  CAN_F7R2_FB29                       0x20000000U        /*!<Filter bit 29 */
N#define  CAN_F7R2_FB30                       0x40000000U        /*!<Filter bit 30 */
N#define  CAN_F7R2_FB31                       0x80000000U        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F8R2 register  *******************/
N#define  CAN_F8R2_FB0                        0x00000001U        /*!<Filter bit 0 */
N#define  CAN_F8R2_FB1                        0x00000002U        /*!<Filter bit 1 */
N#define  CAN_F8R2_FB2                        0x00000004U        /*!<Filter bit 2 */
N#define  CAN_F8R2_FB3                        0x00000008U        /*!<Filter bit 3 */
N#define  CAN_F8R2_FB4                        0x00000010U        /*!<Filter bit 4 */
N#define  CAN_F8R2_FB5                        0x00000020U        /*!<Filter bit 5 */
N#define  CAN_F8R2_FB6                        0x00000040U        /*!<Filter bit 6 */
N#define  CAN_F8R2_FB7                        0x00000080U        /*!<Filter bit 7 */
N#define  CAN_F8R2_FB8                        0x00000100U        /*!<Filter bit 8 */
N#define  CAN_F8R2_FB9                        0x00000200U        /*!<Filter bit 9 */
N#define  CAN_F8R2_FB10                       0x00000400U        /*!<Filter bit 10 */
N#define  CAN_F8R2_FB11                       0x00000800U        /*!<Filter bit 11 */
N#define  CAN_F8R2_FB12                       0x00001000U        /*!<Filter bit 12 */
N#define  CAN_F8R2_FB13                       0x00002000U        /*!<Filter bit 13 */
N#define  CAN_F8R2_FB14                       0x00004000U        /*!<Filter bit 14 */
N#define  CAN_F8R2_FB15                       0x00008000U        /*!<Filter bit 15 */
N#define  CAN_F8R2_FB16                       0x00010000U        /*!<Filter bit 16 */
N#define  CAN_F8R2_FB17                       0x00020000U        /*!<Filter bit 17 */
N#define  CAN_F8R2_FB18                       0x00040000U        /*!<Filter bit 18 */
N#define  CAN_F8R2_FB19                       0x00080000U        /*!<Filter bit 19 */
N#define  CAN_F8R2_FB20                       0x00100000U        /*!<Filter bit 20 */
N#define  CAN_F8R2_FB21                       0x00200000U        /*!<Filter bit 21 */
N#define  CAN_F8R2_FB22                       0x00400000U        /*!<Filter bit 22 */
N#define  CAN_F8R2_FB23                       0x00800000U        /*!<Filter bit 23 */
N#define  CAN_F8R2_FB24                       0x01000000U        /*!<Filter bit 24 */
N#define  CAN_F8R2_FB25                       0x02000000U        /*!<Filter bit 25 */
N#define  CAN_F8R2_FB26                       0x04000000U        /*!<Filter bit 26 */
N#define  CAN_F8R2_FB27                       0x08000000U        /*!<Filter bit 27 */
N#define  CAN_F8R2_FB28                       0x10000000U        /*!<Filter bit 28 */
N#define  CAN_F8R2_FB29                       0x20000000U        /*!<Filter bit 29 */
N#define  CAN_F8R2_FB30                       0x40000000U        /*!<Filter bit 30 */
N#define  CAN_F8R2_FB31                       0x80000000U        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F9R2 register  *******************/
N#define  CAN_F9R2_FB0                        0x00000001U        /*!<Filter bit 0 */
N#define  CAN_F9R2_FB1                        0x00000002U        /*!<Filter bit 1 */
N#define  CAN_F9R2_FB2                        0x00000004U        /*!<Filter bit 2 */
N#define  CAN_F9R2_FB3                        0x00000008U        /*!<Filter bit 3 */
N#define  CAN_F9R2_FB4                        0x00000010U        /*!<Filter bit 4 */
N#define  CAN_F9R2_FB5                        0x00000020U        /*!<Filter bit 5 */
N#define  CAN_F9R2_FB6                        0x00000040U        /*!<Filter bit 6 */
N#define  CAN_F9R2_FB7                        0x00000080U        /*!<Filter bit 7 */
N#define  CAN_F9R2_FB8                        0x00000100U        /*!<Filter bit 8 */
N#define  CAN_F9R2_FB9                        0x00000200U        /*!<Filter bit 9 */
N#define  CAN_F9R2_FB10                       0x00000400U        /*!<Filter bit 10 */
N#define  CAN_F9R2_FB11                       0x00000800U        /*!<Filter bit 11 */
N#define  CAN_F9R2_FB12                       0x00001000U        /*!<Filter bit 12 */
N#define  CAN_F9R2_FB13                       0x00002000U        /*!<Filter bit 13 */
N#define  CAN_F9R2_FB14                       0x00004000U        /*!<Filter bit 14 */
N#define  CAN_F9R2_FB15                       0x00008000U        /*!<Filter bit 15 */
N#define  CAN_F9R2_FB16                       0x00010000U        /*!<Filter bit 16 */
N#define  CAN_F9R2_FB17                       0x00020000U        /*!<Filter bit 17 */
N#define  CAN_F9R2_FB18                       0x00040000U        /*!<Filter bit 18 */
N#define  CAN_F9R2_FB19                       0x00080000U        /*!<Filter bit 19 */
N#define  CAN_F9R2_FB20                       0x00100000U        /*!<Filter bit 20 */
N#define  CAN_F9R2_FB21                       0x00200000U        /*!<Filter bit 21 */
N#define  CAN_F9R2_FB22                       0x00400000U        /*!<Filter bit 22 */
N#define  CAN_F9R2_FB23                       0x00800000U        /*!<Filter bit 23 */
N#define  CAN_F9R2_FB24                       0x01000000U        /*!<Filter bit 24 */
N#define  CAN_F9R2_FB25                       0x02000000U        /*!<Filter bit 25 */
N#define  CAN_F9R2_FB26                       0x04000000U        /*!<Filter bit 26 */
N#define  CAN_F9R2_FB27                       0x08000000U        /*!<Filter bit 27 */
N#define  CAN_F9R2_FB28                       0x10000000U        /*!<Filter bit 28 */
N#define  CAN_F9R2_FB29                       0x20000000U        /*!<Filter bit 29 */
N#define  CAN_F9R2_FB30                       0x40000000U        /*!<Filter bit 30 */
N#define  CAN_F9R2_FB31                       0x80000000U        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F10R2 register  ******************/
N#define  CAN_F10R2_FB0                       0x00000001U        /*!<Filter bit 0 */
N#define  CAN_F10R2_FB1                       0x00000002U        /*!<Filter bit 1 */
N#define  CAN_F10R2_FB2                       0x00000004U        /*!<Filter bit 2 */
N#define  CAN_F10R2_FB3                       0x00000008U        /*!<Filter bit 3 */
N#define  CAN_F10R2_FB4                       0x00000010U        /*!<Filter bit 4 */
N#define  CAN_F10R2_FB5                       0x00000020U        /*!<Filter bit 5 */
N#define  CAN_F10R2_FB6                       0x00000040U        /*!<Filter bit 6 */
N#define  CAN_F10R2_FB7                       0x00000080U        /*!<Filter bit 7 */
N#define  CAN_F10R2_FB8                       0x00000100U        /*!<Filter bit 8 */
N#define  CAN_F10R2_FB9                       0x00000200U        /*!<Filter bit 9 */
N#define  CAN_F10R2_FB10                      0x00000400U        /*!<Filter bit 10 */
N#define  CAN_F10R2_FB11                      0x00000800U        /*!<Filter bit 11 */
N#define  CAN_F10R2_FB12                      0x00001000U        /*!<Filter bit 12 */
N#define  CAN_F10R2_FB13                      0x00002000U        /*!<Filter bit 13 */
N#define  CAN_F10R2_FB14                      0x00004000U        /*!<Filter bit 14 */
N#define  CAN_F10R2_FB15                      0x00008000U        /*!<Filter bit 15 */
N#define  CAN_F10R2_FB16                      0x00010000U        /*!<Filter bit 16 */
N#define  CAN_F10R2_FB17                      0x00020000U        /*!<Filter bit 17 */
N#define  CAN_F10R2_FB18                      0x00040000U        /*!<Filter bit 18 */
N#define  CAN_F10R2_FB19                      0x00080000U        /*!<Filter bit 19 */
N#define  CAN_F10R2_FB20                      0x00100000U        /*!<Filter bit 20 */
N#define  CAN_F10R2_FB21                      0x00200000U        /*!<Filter bit 21 */
N#define  CAN_F10R2_FB22                      0x00400000U        /*!<Filter bit 22 */
N#define  CAN_F10R2_FB23                      0x00800000U        /*!<Filter bit 23 */
N#define  CAN_F10R2_FB24                      0x01000000U        /*!<Filter bit 24 */
N#define  CAN_F10R2_FB25                      0x02000000U        /*!<Filter bit 25 */
N#define  CAN_F10R2_FB26                      0x04000000U        /*!<Filter bit 26 */
N#define  CAN_F10R2_FB27                      0x08000000U        /*!<Filter bit 27 */
N#define  CAN_F10R2_FB28                      0x10000000U        /*!<Filter bit 28 */
N#define  CAN_F10R2_FB29                      0x20000000U        /*!<Filter bit 29 */
N#define  CAN_F10R2_FB30                      0x40000000U        /*!<Filter bit 30 */
N#define  CAN_F10R2_FB31                      0x80000000U        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F11R2 register  ******************/
N#define  CAN_F11R2_FB0                       0x00000001U        /*!<Filter bit 0 */
N#define  CAN_F11R2_FB1                       0x00000002U        /*!<Filter bit 1 */
N#define  CAN_F11R2_FB2                       0x00000004U        /*!<Filter bit 2 */
N#define  CAN_F11R2_FB3                       0x00000008U        /*!<Filter bit 3 */
N#define  CAN_F11R2_FB4                       0x00000010U        /*!<Filter bit 4 */
N#define  CAN_F11R2_FB5                       0x00000020U        /*!<Filter bit 5 */
N#define  CAN_F11R2_FB6                       0x00000040U        /*!<Filter bit 6 */
N#define  CAN_F11R2_FB7                       0x00000080U        /*!<Filter bit 7 */
N#define  CAN_F11R2_FB8                       0x00000100U        /*!<Filter bit 8 */
N#define  CAN_F11R2_FB9                       0x00000200U        /*!<Filter bit 9 */
N#define  CAN_F11R2_FB10                      0x00000400U        /*!<Filter bit 10 */
N#define  CAN_F11R2_FB11                      0x00000800U        /*!<Filter bit 11 */
N#define  CAN_F11R2_FB12                      0x00001000U        /*!<Filter bit 12 */
N#define  CAN_F11R2_FB13                      0x00002000U        /*!<Filter bit 13 */
N#define  CAN_F11R2_FB14                      0x00004000U        /*!<Filter bit 14 */
N#define  CAN_F11R2_FB15                      0x00008000U        /*!<Filter bit 15 */
N#define  CAN_F11R2_FB16                      0x00010000U        /*!<Filter bit 16 */
N#define  CAN_F11R2_FB17                      0x00020000U        /*!<Filter bit 17 */
N#define  CAN_F11R2_FB18                      0x00040000U        /*!<Filter bit 18 */
N#define  CAN_F11R2_FB19                      0x00080000U        /*!<Filter bit 19 */
N#define  CAN_F11R2_FB20                      0x00100000U        /*!<Filter bit 20 */
N#define  CAN_F11R2_FB21                      0x00200000U        /*!<Filter bit 21 */
N#define  CAN_F11R2_FB22                      0x00400000U        /*!<Filter bit 22 */
N#define  CAN_F11R2_FB23                      0x00800000U        /*!<Filter bit 23 */
N#define  CAN_F11R2_FB24                      0x01000000U        /*!<Filter bit 24 */
N#define  CAN_F11R2_FB25                      0x02000000U        /*!<Filter bit 25 */
N#define  CAN_F11R2_FB26                      0x04000000U        /*!<Filter bit 26 */
N#define  CAN_F11R2_FB27                      0x08000000U        /*!<Filter bit 27 */
N#define  CAN_F11R2_FB28                      0x10000000U        /*!<Filter bit 28 */
N#define  CAN_F11R2_FB29                      0x20000000U        /*!<Filter bit 29 */
N#define  CAN_F11R2_FB30                      0x40000000U        /*!<Filter bit 30 */
N#define  CAN_F11R2_FB31                      0x80000000U        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F12R2 register  ******************/
N#define  CAN_F12R2_FB0                       0x00000001U        /*!<Filter bit 0 */
N#define  CAN_F12R2_FB1                       0x00000002U        /*!<Filter bit 1 */
N#define  CAN_F12R2_FB2                       0x00000004U        /*!<Filter bit 2 */
N#define  CAN_F12R2_FB3                       0x00000008U        /*!<Filter bit 3 */
N#define  CAN_F12R2_FB4                       0x00000010U        /*!<Filter bit 4 */
N#define  CAN_F12R2_FB5                       0x00000020U        /*!<Filter bit 5 */
N#define  CAN_F12R2_FB6                       0x00000040U        /*!<Filter bit 6 */
N#define  CAN_F12R2_FB7                       0x00000080U        /*!<Filter bit 7 */
N#define  CAN_F12R2_FB8                       0x00000100U        /*!<Filter bit 8 */
N#define  CAN_F12R2_FB9                       0x00000200U        /*!<Filter bit 9 */
N#define  CAN_F12R2_FB10                      0x00000400U        /*!<Filter bit 10 */
N#define  CAN_F12R2_FB11                      0x00000800U        /*!<Filter bit 11 */
N#define  CAN_F12R2_FB12                      0x00001000U        /*!<Filter bit 12 */
N#define  CAN_F12R2_FB13                      0x00002000U        /*!<Filter bit 13 */
N#define  CAN_F12R2_FB14                      0x00004000U        /*!<Filter bit 14 */
N#define  CAN_F12R2_FB15                      0x00008000U        /*!<Filter bit 15 */
N#define  CAN_F12R2_FB16                      0x00010000U        /*!<Filter bit 16 */
N#define  CAN_F12R2_FB17                      0x00020000U        /*!<Filter bit 17 */
N#define  CAN_F12R2_FB18                      0x00040000U        /*!<Filter bit 18 */
N#define  CAN_F12R2_FB19                      0x00080000U        /*!<Filter bit 19 */
N#define  CAN_F12R2_FB20                      0x00100000U        /*!<Filter bit 20 */
N#define  CAN_F12R2_FB21                      0x00200000U        /*!<Filter bit 21 */
N#define  CAN_F12R2_FB22                      0x00400000U        /*!<Filter bit 22 */
N#define  CAN_F12R2_FB23                      0x00800000U        /*!<Filter bit 23 */
N#define  CAN_F12R2_FB24                      0x01000000U        /*!<Filter bit 24 */
N#define  CAN_F12R2_FB25                      0x02000000U        /*!<Filter bit 25 */
N#define  CAN_F12R2_FB26                      0x04000000U        /*!<Filter bit 26 */
N#define  CAN_F12R2_FB27                      0x08000000U        /*!<Filter bit 27 */
N#define  CAN_F12R2_FB28                      0x10000000U        /*!<Filter bit 28 */
N#define  CAN_F12R2_FB29                      0x20000000U        /*!<Filter bit 29 */
N#define  CAN_F12R2_FB30                      0x40000000U        /*!<Filter bit 30 */
N#define  CAN_F12R2_FB31                      0x80000000U        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F13R2 register  ******************/
N#define  CAN_F13R2_FB0                       0x00000001U        /*!<Filter bit 0 */
N#define  CAN_F13R2_FB1                       0x00000002U        /*!<Filter bit 1 */
N#define  CAN_F13R2_FB2                       0x00000004U        /*!<Filter bit 2 */
N#define  CAN_F13R2_FB3                       0x00000008U        /*!<Filter bit 3 */
N#define  CAN_F13R2_FB4                       0x00000010U        /*!<Filter bit 4 */
N#define  CAN_F13R2_FB5                       0x00000020U        /*!<Filter bit 5 */
N#define  CAN_F13R2_FB6                       0x00000040U        /*!<Filter bit 6 */
N#define  CAN_F13R2_FB7                       0x00000080U        /*!<Filter bit 7 */
N#define  CAN_F13R2_FB8                       0x00000100U        /*!<Filter bit 8 */
N#define  CAN_F13R2_FB9                       0x00000200U        /*!<Filter bit 9 */
N#define  CAN_F13R2_FB10                      0x00000400U        /*!<Filter bit 10 */
N#define  CAN_F13R2_FB11                      0x00000800U        /*!<Filter bit 11 */
N#define  CAN_F13R2_FB12                      0x00001000U        /*!<Filter bit 12 */
N#define  CAN_F13R2_FB13                      0x00002000U        /*!<Filter bit 13 */
N#define  CAN_F13R2_FB14                      0x00004000U        /*!<Filter bit 14 */
N#define  CAN_F13R2_FB15                      0x00008000U        /*!<Filter bit 15 */
N#define  CAN_F13R2_FB16                      0x00010000U        /*!<Filter bit 16 */
N#define  CAN_F13R2_FB17                      0x00020000U        /*!<Filter bit 17 */
N#define  CAN_F13R2_FB18                      0x00040000U        /*!<Filter bit 18 */
N#define  CAN_F13R2_FB19                      0x00080000U        /*!<Filter bit 19 */
N#define  CAN_F13R2_FB20                      0x00100000U        /*!<Filter bit 20 */
N#define  CAN_F13R2_FB21                      0x00200000U        /*!<Filter bit 21 */
N#define  CAN_F13R2_FB22                      0x00400000U        /*!<Filter bit 22 */
N#define  CAN_F13R2_FB23                      0x00800000U        /*!<Filter bit 23 */
N#define  CAN_F13R2_FB24                      0x01000000U        /*!<Filter bit 24 */
N#define  CAN_F13R2_FB25                      0x02000000U        /*!<Filter bit 25 */
N#define  CAN_F13R2_FB26                      0x04000000U        /*!<Filter bit 26 */
N#define  CAN_F13R2_FB27                      0x08000000U        /*!<Filter bit 27 */
N#define  CAN_F13R2_FB28                      0x10000000U        /*!<Filter bit 28 */
N#define  CAN_F13R2_FB29                      0x20000000U        /*!<Filter bit 29 */
N#define  CAN_F13R2_FB30                      0x40000000U        /*!<Filter bit 30 */
N#define  CAN_F13R2_FB31                      0x80000000U        /*!<Filter bit 31 */
N
N/******************************************************************************/
N/*                                                                            */
N/*                                 HDMI-CEC (CEC)                             */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for CEC_CR register  *********************/
N#define  CEC_CR_CECEN                        0x00000001U       /*!< CEC Enable                         */
N#define  CEC_CR_TXSOM                        0x00000002U       /*!< CEC Tx Start Of Message            */
N#define  CEC_CR_TXEOM                        0x00000004U       /*!< CEC Tx End Of Message              */
N
N/*******************  Bit definition for CEC_CFGR register  *******************/
N#define  CEC_CFGR_SFT                        0x00000007U       /*!< CEC Signal Free Time               */
N#define  CEC_CFGR_RXTOL                      0x00000008U       /*!< CEC Tolerance                      */
N#define  CEC_CFGR_BRESTP                     0x00000010U       /*!< CEC Rx Stop                        */
N#define  CEC_CFGR_BREGEN                     0x00000020U       /*!< CEC Bit Rising Error generation    */
N#define  CEC_CFGR_LBPEGEN                    0x00000040U       /*!< CEC Long Period Error generation   */
N#define  CEC_CFGR_BRDNOGEN                   0x00000080U       /*!< CEC Broadcast no Error generation  */
N#define  CEC_CFGR_SFTOPT                     0x00000100U       /*!< CEC Signal Free Time optional      */
N#define  CEC_CFGR_OAR                        0x7FFF0000U       /*!< CEC Own Address                    */
N#define  CEC_CFGR_LSTN                       0x80000000U       /*!< CEC Listen mode                    */
N
N/*******************  Bit definition for CEC_TXDR register  *******************/
N#define  CEC_TXDR_TXD                        0x000000FFU       /*!< CEC Tx Data                        */
N
N/*******************  Bit definition for CEC_RXDR register  *******************/
N#define  CEC_TXDR_RXD                        0x000000FFU       /*!< CEC Rx Data                        */
N
N/*******************  Bit definition for CEC_ISR register  ********************/
N#define  CEC_ISR_RXBR                        0x00000001U       /*!< CEC Rx-Byte Received                   */
N#define  CEC_ISR_RXEND                       0x00000002U       /*!< CEC End Of Reception                   */
N#define  CEC_ISR_RXOVR                       0x00000004U       /*!< CEC Rx-Overrun                         */
N#define  CEC_ISR_BRE                         0x00000008U       /*!< CEC Rx Bit Rising Error                */
N#define  CEC_ISR_SBPE                        0x00000010U       /*!< CEC Rx Short Bit period Error          */
N#define  CEC_ISR_LBPE                        0x00000020U       /*!< CEC Rx Long Bit period Error           */
N#define  CEC_ISR_RXACKE                      0x00000040U       /*!< CEC Rx Missing Acknowledge             */
N#define  CEC_ISR_ARBLST                      0x00000080U       /*!< CEC Arbitration Lost                   */
N#define  CEC_ISR_TXBR                        0x00000100U       /*!< CEC Tx Byte Request                    */
N#define  CEC_ISR_TXEND                       0x00000200U       /*!< CEC End of Transmission                */
N#define  CEC_ISR_TXUDR                       0x00000400U       /*!< CEC Tx-Buffer Underrun                 */
N#define  CEC_ISR_TXERR                       0x00000800U       /*!< CEC Tx-Error                           */
N#define  CEC_ISR_TXACKE                      0x00001000U       /*!< CEC Tx Missing Acknowledge             */
N
N/*******************  Bit definition for CEC_IER register  ********************/
N#define  CEC_IER_RXBRIE                      0x00000001U       /*!< CEC Rx-Byte Received IT Enable         */
N#define  CEC_IER_RXENDIE                     0x00000002U       /*!< CEC End Of Reception IT Enable         */
N#define  CEC_IER_RXOVRIE                     0x00000004U       /*!< CEC Rx-Overrun IT Enable               */
N#define  CEC_IER_BREIE                       0x00000008U       /*!< CEC Rx Bit Rising Error IT Enable      */
N#define  CEC_IER_SBPEIE                      0x00000010U       /*!< CEC Rx Short Bit period Error IT Enable*/
N#define  CEC_IER_LBPEIE                      0x00000020U       /*!< CEC Rx Long Bit period Error IT Enable */
N#define  CEC_IER_RXACKEIE                    0x00000040U       /*!< CEC Rx Missing Acknowledge IT Enable   */
N#define  CEC_IER_ARBLSTIE                    0x00000080U       /*!< CEC Arbitration Lost IT Enable         */
N#define  CEC_IER_TXBRIE                      0x00000100U       /*!< CEC Tx Byte Request  IT Enable         */
N#define  CEC_IER_TXENDIE                     0x00000200U       /*!< CEC End of Transmission IT Enable      */
N#define  CEC_IER_TXUDRIE                     0x00000400U       /*!< CEC Tx-Buffer Underrun IT Enable       */
N#define  CEC_IER_TXERRIE                     0x00000800U       /*!< CEC Tx-Error IT Enable                 */
N#define  CEC_IER_TXACKEIE                    0x00001000U       /*!< CEC Tx Missing Acknowledge IT Enable   */
N
N/******************************************************************************/
N/*                                                                            */
N/*                          CRC calculation unit                              */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for CRC_DR register  *********************/
N#define  CRC_DR_DR                           0xFFFFFFFFU     /*!< Data register bits */
N
N/*******************  Bit definition for CRC_IDR register  ********************/
N#define  CRC_IDR_IDR                         0x000000FFU     /*!< General-purpose 8-bit data register bits */
N
N/********************  Bit definition for CRC_CR register  ********************/
N#define  CRC_CR_RESET                        0x00000001U     /*!< RESET the CRC computation unit bit */
N#define  CRC_CR_POLYSIZE                     0x00000018U     /*!< Polynomial size bits               */
N#define  CRC_CR_POLYSIZE_0                   0x00000008U     /*!< Polynomial size bit 0              */
N#define  CRC_CR_POLYSIZE_1                   0x00000010U     /*!< Polynomial size bit 1              */
N#define  CRC_CR_REV_IN                       0x00000060U     /*!< REV_IN Reverse Input Data bits     */
N#define  CRC_CR_REV_IN_0                     0x00000020U     /*!< Bit 0 */
N#define  CRC_CR_REV_IN_1                     0x00000040U     /*!< Bit 1 */
N#define  CRC_CR_REV_OUT                      0x00000080U     /*!< REV_OUT Reverse Output Data bits   */
N
N/*******************  Bit definition for CRC_INIT register  *******************/
N#define  CRC_INIT_INIT                       0xFFFFFFFFU     /*!< Initial CRC value bits         */
N
N/*******************  Bit definition for CRC_POL register  ********************/
N#define  CRC_POL_POL                         0xFFFFFFFFU     /*!< Coefficients of the polynomial */
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                      Digital to Analog Converter                           */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for DAC_CR register  ********************/
N#define  DAC_CR_EN1                          0x00000001U        /*!<DAC channel1 enable                         */
N#define  DAC_CR_BOFF1                        0x00000002U        /*!<DAC channel1 output buffer disable          */
N#define  DAC_CR_TEN1                         0x00000004U        /*!<DAC channel1 Trigger enable                 */
N#define  DAC_CR_TSEL1                        0x00000038U        /*!<TSEL1[2:0] (DAC channel1 Trigger selection) */
N#define  DAC_CR_TSEL1_0                      0x00000008U        /*!<Bit 0 */
N#define  DAC_CR_TSEL1_1                      0x00000010U        /*!<Bit 1 */
N#define  DAC_CR_TSEL1_2                      0x00000020U        /*!<Bit 2 */
N#define  DAC_CR_WAVE1                        0x000000C0U        /*!<WAVE1[1:0] (DAC channel1 noise/triangle wave generation enablEU) */
N#define  DAC_CR_WAVE1_0                      0x00000040U        /*!<Bit 0 */
N#define  DAC_CR_WAVE1_1                      0x00000080U        /*!<Bit 1 */
N#define  DAC_CR_MAMP1                        0x00000F00U        /*!<MAMP1[3:0] (DAC channel1 Mask/Amplitude selector) */
N#define  DAC_CR_MAMP1_0                      0x00000100U        /*!<Bit 0 */
N#define  DAC_CR_MAMP1_1                      0x00000200U        /*!<Bit 1 */
N#define  DAC_CR_MAMP1_2                      0x00000400U        /*!<Bit 2 */
N#define  DAC_CR_MAMP1_3                      0x00000800U        /*!<Bit 3 */
N#define  DAC_CR_DMAEN1                       0x00001000U        /*!<DAC channel1 DMA enable                     */
N#define  DAC_CR_DMAUDRIE1                    0x00002000U        /*!<DAC channel1 DMA underrun interrupt enable  */
N#define  DAC_CR_EN2                          0x00010000U        /*!<DAC channel2 enable                         */
N#define  DAC_CR_BOFF2                        0x00020000U        /*!<DAC channel2 output buffer disable          */
N#define  DAC_CR_TEN2                         0x00040000U        /*!<DAC channel2 Trigger enable                 */
N#define  DAC_CR_TSEL2                        0x00380000U        /*!<TSEL2[2:0] (DAC channel2 Trigger selection) */
N#define  DAC_CR_TSEL2_0                      0x00080000U        /*!<Bit 0 */
N#define  DAC_CR_TSEL2_1                      0x00100000U        /*!<Bit 1 */
N#define  DAC_CR_TSEL2_2                      0x00200000U        /*!<Bit 2 */
N#define  DAC_CR_WAVE2                        0x00C00000U        /*!<WAVE2[1:0] (DAC channel2 noise/triangle wave generation enable) */
N#define  DAC_CR_WAVE2_0                      0x00400000U        /*!<Bit 0 */
N#define  DAC_CR_WAVE2_1                      0x00800000U        /*!<Bit 1 */
N#define  DAC_CR_MAMP2                        0x0F000000U        /*!<MAMP2[3:0] (DAC channel2 Mask/Amplitude selector) */
N#define  DAC_CR_MAMP2_0                      0x01000000U        /*!<Bit 0 */
N#define  DAC_CR_MAMP2_1                      0x02000000U        /*!<Bit 1 */
N#define  DAC_CR_MAMP2_2                      0x04000000U        /*!<Bit 2 */
N#define  DAC_CR_MAMP2_3                      0x08000000U        /*!<Bit 3 */
N#define  DAC_CR_DMAEN2                       0x10000000U        /*!<DAC channel2 DMA enable                    */
N#define  DAC_CR_DMAUDRIE2                    0x20000000U        /*!<DAC channel2 DMA underrun interrupt enable */
N
N/*****************  Bit definition for DAC_SWTRIGR register  ******************/
N#define  DAC_SWTRIGR_SWTRIG1                 0x01U               /*!<DAC channel1 software trigger */
N#define  DAC_SWTRIGR_SWTRIG2                 0x02U               /*!<DAC channel2 software trigger */
N
N/*****************  Bit definition for DAC_DHR12R1 register  ******************/
N#define  DAC_DHR12R1_DACC1DHR                0x0FFFU            /*!<DAC channel1 12-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12L1 register  ******************/
N#define  DAC_DHR12L1_DACC1DHR                0xFFF0U            /*!<DAC channel1 12-bit Left aligned data */
N
N/******************  Bit definition for DAC_DHR8R1 register  ******************/
N#define  DAC_DHR8R1_DACC1DHR                 0xFFU               /*!<DAC channel1 8-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12R2 register  ******************/
N#define  DAC_DHR12R2_DACC2DHR                0x0FFFU            /*!<DAC channel2 12-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12L2 register  ******************/
N#define  DAC_DHR12L2_DACC2DHR                0xFFF0U            /*!<DAC channel2 12-bit Left aligned data */
N
N/******************  Bit definition for DAC_DHR8R2 register  ******************/
N#define  DAC_DHR8R2_DACC2DHR                 0xFFU               /*!<DAC channel2 8-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12RD register  ******************/
N#define  DAC_DHR12RD_DACC1DHR                0x00000FFFU        /*!<DAC channel1 12-bit Right aligned data */
N#define  DAC_DHR12RD_DACC2DHR                0x0FFF0000U        /*!<DAC channel2 12-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12LD register  ******************/
N#define  DAC_DHR12LD_DACC1DHR                0x0000FFF0U        /*!<DAC channel1 12-bit Left aligned data */
N#define  DAC_DHR12LD_DACC2DHR                0xFFF00000U        /*!<DAC channel2 12-bit Left aligned data */
N
N/******************  Bit definition for DAC_DHR8RD register  ******************/
N#define  DAC_DHR8RD_DACC1DHR                 0x00FFU            /*!<DAC channel1 8-bit Right aligned data */
N#define  DAC_DHR8RD_DACC2DHR                 0xFF00U            /*!<DAC channel2 8-bit Right aligned data */
N
N/*******************  Bit definition for DAC_DOR1 register  *******************/
N#define  DAC_DOR1_DACC1DOR                   0x0FFFU            /*!<DAC channel1 data output */
N
N/*******************  Bit definition for DAC_DOR2 register  *******************/
N#define  DAC_DOR2_DACC2DOR                   0x0FFFU            /*!<DAC channel2 data output */
N
N/********************  Bit definition for DAC_SR register  ********************/
N#define  DAC_SR_DMAUDR1                      0x00002000U        /*!<DAC channel1 DMA underrun flag */
N#define  DAC_SR_DMAUDR2                      0x20000000U        /*!<DAC channel2 DMA underrun flag */
N
N/******************************************************************************/
N/*                                                                            */
N/*                 Digital Filter for Sigma Delta Modulators                  */
N/*                                                                            */
N/******************************************************************************/
N
N/****************   DFSDM channel configuration registers  ********************/
N
N/***************  Bit definition for DFSDM_CHCFGR1 register  ******************/
N#define  DFSDM_CHCFGR1_DFSDMEN                0x80000000U            /*!< Global enable for DFSDM interface */
N#define  DFSDM_CHCFGR1_CKOUTSRC               0x40000000U            /*!< Output serial clock source selection */
N#define  DFSDM_CHCFGR1_CKOUTDIV               0x00FF0000U            /*!< CKOUTDIV[7:0] output serial clock divider */
N#define  DFSDM_CHCFGR1_DATPACK                0x0000C000U            /*!< DATPACK[1:0] Data packing mode */
N#define  DFSDM_CHCFGR1_DATPACK_1              0x00008000U            /*!< Data packing mode, Bit 1 */
N#define  DFSDM_CHCFGR1_DATPACK_0              0x00004000U            /*!< Data packing mode, Bit 0 */
N#define  DFSDM_CHCFGR1_DATMPX                 0x00003000U            /*!< DATMPX[1:0] Input data multiplexer for channel y */
N#define  DFSDM_CHCFGR1_DATMPX_1               0x00002000U            /*!< Input data multiplexer for channel y, Bit 1 */
N#define  DFSDM_CHCFGR1_DATMPX_0               0x00001000U            /*!< Input data multiplexer for channel y, Bit 0 */
N#define  DFSDM_CHCFGR1_CHINSEL                0x00000100U            /*!< Serial inputs selection for channel y */
N#define  DFSDM_CHCFGR1_CHEN                   0x00000080U            /*!< Channel y enable */
N#define  DFSDM_CHCFGR1_CKABEN                 0x00000040U            /*!< Clock absence detector enable on channel y */
N#define  DFSDM_CHCFGR1_SCDEN                  0x00000020U            /*!< Short circuit detector enable on channel y */
N#define  DFSDM_CHCFGR1_SPICKSEL               0x0000000CU            /*!< SPICKSEL[1:0] SPI clock select for channel y */
N#define  DFSDM_CHCFGR1_SPICKSEL_1             0x00000008U            /*!< SPI clock select for channel y, Bit 1 */
N#define  DFSDM_CHCFGR1_SPICKSEL_0             0x00000004U            /*!< SPI clock select for channel y, Bit 0 */
N#define  DFSDM_CHCFGR1_SITP                   0x00000003U            /*!< SITP[1:0] Serial interface type for channel y */
N#define  DFSDM_CHCFGR1_SITP_1                 0x00000002U            /*!< Serial interface type for channel y, Bit 1 */
N#define  DFSDM_CHCFGR1_SITP_0                 0x00000001U            /*!< Serial interface type for channel y, Bit 0 */
N
N/***************  Bit definition for DFSDM_CHCFGR2 register  ******************/
N#define  DFSDM_CHCFGR2_OFFSET                 0xFFFFFF00U            /*!< OFFSET[23:0] 24-bit calibration offset for channel y */
N#define  DFSDM_CHCFGR2_DTRBS                  0x000000F8U            /*!< DTRBS[4:0] Data right bit-shift for channel y */
N
N/******************  Bit definition for DFSDM_CHAWSCDR register *****************/
N#define  DFSDM_CHAWSCDR_AWFORD                0x00C00000U            /*!< AWFORD[1:0] Analog watchdog Sinc filter order on channel y */
N#define  DFSDM_CHAWSCDR_AWFORD_1              0x00800000U            /*!< Analog watchdog Sinc filter order on channel y, Bit 1 */
N#define  DFSDM_CHAWSCDR_AWFORD_0              0x00400000U            /*!< Analog watchdog Sinc filter order on channel y, Bit 0 */
N#define  DFSDM_CHAWSCDR_AWFOSR                0x001F0000U            /*!< AWFOSR[4:0] Analog watchdog filter oversampling ratio on channel y */
N#define  DFSDM_CHAWSCDR_BKSCD                 0x0000F000U            /*!< BKSCD[3:0] Break signal assignment for short circuit detector on channel y */
N#define  DFSDM_CHAWSCDR_SCDT                  0x000000FFU            /*!< SCDT[7:0] Short circuit detector threshold for channel y */
N
N/****************  Bit definition for DFSDM_CHWDATR register *******************/
N#define  DFSDM_CHWDATR_WDATA                  0x0000FFFFU            /*!< WDATA[15:0] Input channel y watchdog data */
N
N/****************  Bit definition for DFSDM_CHDATINR register *****************/
N#define  DFSDM_CHDATINR_INDAT0                0x0000FFFFU            /*!< INDAT0[31:16] Input data for channel y or channel (y+1) */
N#define  DFSDM_CHDATINR_INDAT1                0xFFFF0000U            /*!< INDAT0[15:0] Input data for channel y */
N
N/************************   DFSDM module registers  ****************************/
N
N/********************  Bit definition for DFSDM_FLTCR1 register *******************/
N#define  DFSDM_FLTCR1_AWFSEL                  0x40000000U            /*!< Analog watchdog fast mode select */
N#define  DFSDM_FLTCR1_FAST                    0x20000000U            /*!< Fast conversion mode selection */
N#define  DFSDM_FLTCR1_RCH                     0x07000000U            /*!< RCH[2:0] Regular channel selection */
N#define  DFSDM_FLTCR1_RDMAEN                  0x00200000U            /*!< DMA channel enabled to read data for the regular conversion */
N#define  DFSDM_FLTCR1_RSYNC                   0x00080000U            /*!< Launch regular conversion synchronously with DFSDMx */
N#define  DFSDM_FLTCR1_RCONT                   0x00040000U            /*!< Continuous mode selection for regular conversions */
N#define  DFSDM_FLTCR1_RSWSTART                0x00020000U            /*!< Software start of a conversion on the regular channel */
N#define  DFSDM_FLTCR1_JEXTEN                  0x00006000U            /*!< JEXTEN[1:0] Trigger enable and trigger edge selection for injected conversions */
N#define  DFSDM_FLTCR1_JEXTEN_1                0x00004000U            /*!< Trigger enable and trigger edge selection for injected conversions, Bit 1 */
N#define  DFSDM_FLTCR1_JEXTEN_0                0x00002000U            /*!< Trigger enable and trigger edge selection for injected conversions, Bit 0 */
N#define  DFSDM_FLTCR1_JEXTSEL                 0x00001F00U            /*!< JEXTSEL[4:0]Trigger signal selection for launching injected conversions */
N#define  DFSDM_FLTCR1_JEXTSEL_0               0x00000100U            /*!< Trigger signal selection for launching injected conversions, Bit 0 */
N#define  DFSDM_FLTCR1_JEXTSEL_1               0x00000200U            /*!< Trigger signal selection for launching injected conversions, Bit 1 */
N#define  DFSDM_FLTCR1_JEXTSEL_2               0x00000400U            /*!< Trigger signal selection for launching injected conversions, Bit 2 */
N#define  DFSDM_FLTCR1_JEXTSEL_3               0x00000800U            /*!< Trigger signal selection for launching injected conversions, Bit 3 */
N#define  DFSDM_FLTCR1_JEXTSEL_4               0x00001000U            /*!< Trigger signal selection for launching injected conversions, Bit 4 */
N#define  DFSDM_FLTCR1_JDMAEN                  0x00000020U            /*!< DMA channel enabled to read data for the injected channel group */
N#define  DFSDM_FLTCR1_JSCAN                   0x00000010U            /*!< Scanning conversion in continuous mode selection for injected conversions */
N#define  DFSDM_FLTCR1_JSYNC                   0x00000008U            /*!< Launch an injected conversion synchronously with DFSDMx JSWSTART trigger  */
N#define  DFSDM_FLTCR1_JSWSTART                0x00000002U            /*!< Start the conversion of the injected group of channels */
N#define  DFSDM_FLTCR1_DFEN                    0x00000001U            /*!< DFSDM enable */
N
N/********************  Bit definition for DFSDM_FLTCR2 register *******************/
N#define  DFSDM_FLTCR2_AWDCH                   0x00FF0000U            /*!< AWDCH[7:0] Analog watchdog channel selection */
N#define  DFSDM_FLTCR2_EXCH                    0x0000FF00U            /*!< EXCH[7:0] Extreme detector channel selection */
N#define  DFSDM_FLTCR2_CKABIE                  0x00000040U            /*!< Clock absence interrupt enable */
N#define  DFSDM_FLTCR2_SCDIE                   0x00000020U            /*!< Short circuit detector interrupt enable */
N#define  DFSDM_FLTCR2_AWDIE                   0x00000010U            /*!< Analog watchdog interrupt enable */
N#define  DFSDM_FLTCR2_ROVRIE                  0x00000008U            /*!< Regular data overrun interrupt enable */
N#define  DFSDM_FLTCR2_JOVRIE                  0x00000004U            /*!< Injected data overrun interrupt enable */
N#define  DFSDM_FLTCR2_REOCIE                  0x00000002U            /*!< Regular end of conversion interrupt enable */
N#define  DFSDM_FLTCR2_JEOCIE                  0x00000001U            /*!< Injected end of conversion interrupt enable */
N
N/********************  Bit definition for DFSDM_FLTISR register *******************/
N#define  DFSDM_FLTISR_SCDF                    0xFF000000U            /*!< SCDF[7:0] Short circuit detector flag */
N#define  DFSDM_FLTISR_CKABF                   0x00FF0000U            /*!< CKABF[7:0] Clock absence flag */
N#define  DFSDM_FLTISR_RCIP                    0x00004000U            /*!< Regular conversion in progress status */
N#define  DFSDM_FLTISR_JCIP                    0x00002000U            /*!< Injected conversion in progress status */
N#define  DFSDM_FLTISR_AWDF                    0x00000010U            /*!< Analog watchdog */
N#define  DFSDM_FLTISR_ROVRF                   0x00000008U            /*!< Regular conversion overrun flag */
N#define  DFSDM_FLTISR_JOVRF                   0x00000004U            /*!< Injected conversion overrun flag */
N#define  DFSDM_FLTISR_REOCF                   0x00000002U            /*!< End of regular conversion flag */
N#define  DFSDM_FLTISR_JEOCF                   0x00000001U            /*!< End of injected conversion flag */
N
N/********************  Bit definition for DFSDM_FLTICR register *******************/
N#define  DFSDM_FLTICR_CLRSCSDF                0xFF000000U            /*!< CLRSCSDF[7:0] Clear the short circuit detector flag */
N#define  DFSDM_FLTICR_CLRCKABF                0x00FF0000U            /*!< CLRCKABF[7:0] Clear the clock absence flag */
N#define  DFSDM_FLTICR_CLRROVRF                0x00000008U            /*!< Clear the regular conversion overrun flag */
N#define  DFSDM_FLTICR_CLRJOVRF                0x00000004U            /*!< Clear the injected conversion overrun flag */
N
N/*******************  Bit definition for DFSDM_FLTJCHGR register ******************/
N#define  DFSDM_FLTJCHGR_JCHG                  0x000000FFU            /*!< JCHG[7:0] Injected channel group selection */
N
N/********************  Bit definition for DFSDM_FLTFCR register *******************/
N#define  DFSDM_FLTFCR_FORD                    0xE0000000U            /*!< FORD[2:0] Sinc filter order */
N#define  DFSDM_FLTFCR_FORD_2                  0x80000000U            /*!< Sinc filter order, Bit 2 */
N#define  DFSDM_FLTFCR_FORD_1                  0x40000000U            /*!< Sinc filter order, Bit 1 */
N#define  DFSDM_FLTFCR_FORD_0                  0x20000000U            /*!< Sinc filter order, Bit 0 */
N#define  DFSDM_FLTFCR_FOSR                    0x03FF0000U            /*!< FOSR[9:0] Sinc filter oversampling ratio (decimation rate) */
N#define  DFSDM_FLTFCR_IOSR                    0x000000FFU            /*!< IOSR[7:0] Integrator oversampling ratio (averaging length) */
N
N/******************  Bit definition for DFSDM_FLTJDATAR register *****************/
N#define  DFSDM_FLTJDATAR_JDATA                0xFFFFFF00U            /*!< JDATA[23:0] Injected group conversion data */
N#define  DFSDM_FLTJDATAR_JDATACH              0x00000007U            /*!< JDATACH[2:0] Injected channel most recently converted */
N
N/******************  Bit definition for DFSDM_FLTRDATAR register *****************/
N#define  DFSDM_FLTRDATAR_RDATA                0xFFFFFF00U            /*!< RDATA[23:0] Regular channel conversion data */
N#define  DFSDM_FLTRDATAR_RPEND                0x00000010U            /*!< RPEND Regular channel pending data */
N#define  DFSDM_FLTRDATAR_RDATACH              0x00000007U            /*!< RDATACH[2:0] Regular channel most recently converted */
N
N/******************  Bit definition for DFSDM_FLTAWHTR register ******************/
N#define  DFSDM_FLTAWHTR_AWHT                  0xFFFFFF00U             /*!< AWHT[23:0] Analog watchdog high threshold */
N#define  DFSDM_FLTAWHTR_BKAWH                 0x0000000FU             /*!< BKAWH[3:0] Break signal assignment to analog watchdog high threshold event */
N
N/******************  Bit definition for DFSDM_FLTAWLTR register ******************/
N#define  DFSDM_FLTAWLTR_AWLT                  0xFFFFFF00U             /*!< AWLT[23:0] Analog watchdog low threshold */
N#define  DFSDM_FLTAWLTR_BKAWL                 0x0000000FU             /*!< BKAWL[3:0] Break signal assignment to analog watchdog low threshold event */
N
N/******************  Bit definition for DFSDM_FLTAWSR register ******************/
N#define  DFSDM_FLTAWSR_AWHTF                  0x0000FF00U             /*!< AWHTF[15:8] Analog watchdog high threshold error on given channels */
N#define  DFSDM_FLTAWSR_AWLTF                  0x000000FFU             /*!< AWLTF[7:0] Analog watchdog low threshold error on given channels */
N
N/******************  Bit definition for DFSDM_FLTAWCFR register *****************/
N#define  DFSDM_FLTAWCFR_CLRAWHTF              0x0000FF00U             /*!< CLRAWHTF[15:8] Clear the Analog watchdog high threshold flag */
N#define  DFSDM_FLTAWCFR_CLRAWLTF              0x000000FFU             /*!< CLRAWLTF[7:0] Clear the Analog watchdog low threshold flag */
N
N/******************  Bit definition for DFSDM_FLTEXMAX register ******************/
N#define  DFSDM_FLTEXMAX_EXMAX                 0xFFFFFF00U             /*!< EXMAX[23:0] Extreme detector maximum value */
N#define  DFSDM_FLTEXMAX_EXMAXCH               0x00000007U             /*!< EXMAXCH[2:0] Extreme detector maximum data channel */
N
N/******************  Bit definition for DFSDM_FLTEXMIN register ******************/
N#define  DFSDM_FLTEXMIN_EXMIN                 0xFFFFFF00U             /*!< EXMIN[23:0] Extreme detector minimum value */
N#define  DFSDM_FLTEXMIN_EXMINCH               0x00000007U             /*!< EXMINCH[2:0] Extreme detector minimum data channel */
N
N/******************  Bit definition for DFSDM_FLTCNVTIMR register ******************/
N#define  DFSDM_FLTCNVTIMR_CNVCNT              0xFFFFFFF0U             /*!< CNVCNT[27:0]: 28-bit timer counting conversion time */
N
N/******************************************************************************/
N/*                                                                            */
N/*                                 Debug MCU                                  */
N/*                                                                            */
N/******************************************************************************/
N
N/******************************************************************************/
N/*                                                                            */
N/*                                    DCMI                                    */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bits definition for DCMI_CR register  ******************/
N#define DCMI_CR_CAPTURE                      0x00000001U
N#define DCMI_CR_CM                           0x00000002U
N#define DCMI_CR_CROP                         0x00000004U
N#define DCMI_CR_JPEG                         0x00000008U
N#define DCMI_CR_ESS                          0x00000010U
N#define DCMI_CR_PCKPOL                       0x00000020U
N#define DCMI_CR_HSPOL                        0x00000040U
N#define DCMI_CR_VSPOL                        0x00000080U
N#define DCMI_CR_FCRC_0                       0x00000100U
N#define DCMI_CR_FCRC_1                       0x00000200U
N#define DCMI_CR_EDM_0                        0x00000400U
N#define DCMI_CR_EDM_1                        0x00000800U
N#define DCMI_CR_CRE                          0x00001000U
N#define DCMI_CR_ENABLE                       0x00004000U
N#define DCMI_CR_BSM                          0x00030000U
N#define DCMI_CR_BSM_0                        0x00010000U
N#define DCMI_CR_BSM_1                        0x00020000U
N#define DCMI_CR_OEBS                         0x00040000U
N#define DCMI_CR_LSM                          0x00080000U
N#define DCMI_CR_OELS                         0x00100000U
N
N/********************  Bits definition for DCMI_SR register  ******************/
N#define DCMI_SR_HSYNC                        0x00000001U
N#define DCMI_SR_VSYNC                        0x00000002U
N#define DCMI_SR_FNE                          0x00000004U
N
N/********************  Bits definition for DCMI_RIS register   ****************/
N#define DCMI_RIS_FRAME_RIS                   0x00000001U
N#define DCMI_RIS_OVR_RIS                     0x00000002U
N#define DCMI_RIS_ERR_RIS                     0x00000004U
N#define DCMI_RIS_VSYNC_RIS                   0x00000008U
N#define DCMI_RIS_LINE_RIS                    0x00000010U
N
N/* Legacy defines */
N#define DCMI_RISR_FRAME_RIS                  DCMI_RIS_FRAME_RIS
N#define DCMI_RISR_OVF_RIS                    DCMI_RIS_OVR_RIS
N#define DCMI_RISR_ERR_RIS                    DCMI_RIS_ERR_RIS
N#define DCMI_RISR_VSYNC_RIS                  DCMI_RIS_VSYNC_RIS
N#define DCMI_RISR_LINE_RIS                   DCMI_RIS_LINE_RIS
N
N/********************  Bits definition for DCMI_IER register  *****************/
N#define DCMI_IER_FRAME_IE                    0x00000001U
N#define DCMI_IER_OVR_IE                      0x00000002U
N#define DCMI_IER_ERR_IE                      0x00000004U
N#define DCMI_IER_VSYNC_IE                    0x00000008U
N#define DCMI_IER_LINE_IE                     0x00000010U
N
N
N/********************  Bits definition for DCMI_MIS register  *****************/
N#define DCMI_MIS_FRAME_MIS                   0x00000001U
N#define DCMI_MIS_OVR_MIS                     0x00000002U
N#define DCMI_MIS_ERR_MIS                     0x00000004U
N#define DCMI_MIS_VSYNC_MIS                   0x00000008U
N#define DCMI_MIS_LINE_MIS                    0x00000010U
N
N
N/********************  Bits definition for DCMI_ICR register  *****************/
N#define DCMI_ICR_FRAME_ISC                   0x00000001U
N#define DCMI_ICR_OVR_ISC                     0x00000002U
N#define DCMI_ICR_ERR_ISC                     0x00000004U
N#define DCMI_ICR_VSYNC_ISC                   0x00000008U
N#define DCMI_ICR_LINE_ISC                    0x00000010U
N
N
N/********************  Bits definition for DCMI_ESCR register  ******************/
N#define DCMI_ESCR_FSC                        0x000000FFU
N#define DCMI_ESCR_LSC                        0x0000FF00U
N#define DCMI_ESCR_LEC                        0x00FF0000U
N#define DCMI_ESCR_FEC                        0xFF000000U
N
N/********************  Bits definition for DCMI_ESUR register  ******************/
N#define DCMI_ESUR_FSU                        0x000000FFU
N#define DCMI_ESUR_LSU                        0x0000FF00U
N#define DCMI_ESUR_LEU                        0x00FF0000U
N#define DCMI_ESUR_FEU                        0xFF000000U
N
N/********************  Bits definition for DCMI_CWSTRT register  ******************/
N#define DCMI_CWSTRT_HOFFCNT                  0x00003FFFU
N#define DCMI_CWSTRT_VST                      0x1FFF0000U
N
N/********************  Bits definition for DCMI_CWSIZE register  ******************/
N#define DCMI_CWSIZE_CAPCNT                   0x00003FFFU
N#define DCMI_CWSIZE_VLINE                    0x3FFF0000U
N
N/********************  Bits definition for DCMI_DR register  ******************/
N#define DCMI_DR_BYTE0                        0x000000FFU
N#define DCMI_DR_BYTE1                        0x0000FF00U
N#define DCMI_DR_BYTE2                        0x00FF0000U
N#define DCMI_DR_BYTE3                        0xFF000000U
N
N/******************************************************************************/
N/*                                                                            */
N/*                             DMA Controller                                 */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bits definition for DMA_SxCR register  *****************/ 
N#define DMA_SxCR_CHSEL                       0x1E000000U
N#define DMA_SxCR_CHSEL_0                     0x02000000U
N#define DMA_SxCR_CHSEL_1                     0x04000000U
N#define DMA_SxCR_CHSEL_2                     0x08000000U 
N#define DMA_SxCR_CHSEL_3                     0x10000000U
N#define DMA_SxCR_MBURST                      0x01800000U
N#define DMA_SxCR_MBURST_0                    0x00800000U
N#define DMA_SxCR_MBURST_1                    0x01000000U
N#define DMA_SxCR_PBURST                      0x00600000U
N#define DMA_SxCR_PBURST_0                    0x00200000U
N#define DMA_SxCR_PBURST_1                    0x00400000U
N#define DMA_SxCR_CT                          0x00080000U  
N#define DMA_SxCR_DBM                         0x00040000U
N#define DMA_SxCR_PL                          0x00030000U
N#define DMA_SxCR_PL_0                        0x00010000U
N#define DMA_SxCR_PL_1                        0x00020000U
N#define DMA_SxCR_PINCOS                      0x00008000U
N#define DMA_SxCR_MSIZE                       0x00006000U
N#define DMA_SxCR_MSIZE_0                     0x00002000U
N#define DMA_SxCR_MSIZE_1                     0x00004000U
N#define DMA_SxCR_PSIZE                       0x00001800U
N#define DMA_SxCR_PSIZE_0                     0x00000800U
N#define DMA_SxCR_PSIZE_1                     0x00001000U
N#define DMA_SxCR_MINC                        0x00000400U
N#define DMA_SxCR_PINC                        0x00000200U
N#define DMA_SxCR_CIRC                        0x00000100U
N#define DMA_SxCR_DIR                         0x000000C0U
N#define DMA_SxCR_DIR_0                       0x00000040U
N#define DMA_SxCR_DIR_1                       0x00000080U
N#define DMA_SxCR_PFCTRL                      0x00000020U
N#define DMA_SxCR_TCIE                        0x00000010U
N#define DMA_SxCR_HTIE                        0x00000008U
N#define DMA_SxCR_TEIE                        0x00000004U
N#define DMA_SxCR_DMEIE                       0x00000002U
N#define DMA_SxCR_EN                          0x00000001U
N
N/********************  Bits definition for DMA_SxCNDTR register  **************/
N#define DMA_SxNDT                            0x0000FFFFU
N#define DMA_SxNDT_0                          0x00000001U
N#define DMA_SxNDT_1                          0x00000002U
N#define DMA_SxNDT_2                          0x00000004U
N#define DMA_SxNDT_3                          0x00000008U
N#define DMA_SxNDT_4                          0x00000010U
N#define DMA_SxNDT_5                          0x00000020U
N#define DMA_SxNDT_6                          0x00000040U
N#define DMA_SxNDT_7                          0x00000080U
N#define DMA_SxNDT_8                          0x00000100U
N#define DMA_SxNDT_9                          0x00000200U
N#define DMA_SxNDT_10                         0x00000400U
N#define DMA_SxNDT_11                         0x00000800U
N#define DMA_SxNDT_12                         0x00001000U
N#define DMA_SxNDT_13                         0x00002000U
N#define DMA_SxNDT_14                         0x00004000U
N#define DMA_SxNDT_15                         0x00008000U
N
N/********************  Bits definition for DMA_SxFCR register  ****************/ 
N#define DMA_SxFCR_FEIE                       0x00000080U
N#define DMA_SxFCR_FS                         0x00000038U
N#define DMA_SxFCR_FS_0                       0x00000008U
N#define DMA_SxFCR_FS_1                       0x00000010U
N#define DMA_SxFCR_FS_2                       0x00000020U
N#define DMA_SxFCR_DMDIS                      0x00000004U
N#define DMA_SxFCR_FTH                        0x00000003U
N#define DMA_SxFCR_FTH_0                      0x00000001U
N#define DMA_SxFCR_FTH_1                      0x00000002U
N
N/********************  Bits definition for DMA_LISR register  *****************/ 
N#define DMA_LISR_TCIF3                       0x08000000U
N#define DMA_LISR_HTIF3                       0x04000000U
N#define DMA_LISR_TEIF3                       0x02000000U
N#define DMA_LISR_DMEIF3                      0x01000000U
N#define DMA_LISR_FEIF3                       0x00400000U
N#define DMA_LISR_TCIF2                       0x00200000U
N#define DMA_LISR_HTIF2                       0x00100000U
N#define DMA_LISR_TEIF2                       0x00080000U
N#define DMA_LISR_DMEIF2                      0x00040000U
N#define DMA_LISR_FEIF2                       0x00010000U
N#define DMA_LISR_TCIF1                       0x00000800U
N#define DMA_LISR_HTIF1                       0x00000400U
N#define DMA_LISR_TEIF1                       0x00000200U
N#define DMA_LISR_DMEIF1                      0x00000100U
N#define DMA_LISR_FEIF1                       0x00000040U
N#define DMA_LISR_TCIF0                       0x00000020U
N#define DMA_LISR_HTIF0                       0x00000010U
N#define DMA_LISR_TEIF0                       0x00000008U
N#define DMA_LISR_DMEIF0                      0x00000004U
N#define DMA_LISR_FEIF0                       0x00000001U
N
N/********************  Bits definition for DMA_HISR register  *****************/ 
N#define DMA_HISR_TCIF7                       0x08000000U
N#define DMA_HISR_HTIF7                       0x04000000U
N#define DMA_HISR_TEIF7                       0x02000000U
N#define DMA_HISR_DMEIF7                      0x01000000U
N#define DMA_HISR_FEIF7                       0x00400000U
N#define DMA_HISR_TCIF6                       0x00200000U
N#define DMA_HISR_HTIF6                       0x00100000U
N#define DMA_HISR_TEIF6                       0x00080000U
N#define DMA_HISR_DMEIF6                      0x00040000U
N#define DMA_HISR_FEIF6                       0x00010000U
N#define DMA_HISR_TCIF5                       0x00000800U
N#define DMA_HISR_HTIF5                       0x00000400U
N#define DMA_HISR_TEIF5                       0x00000200U
N#define DMA_HISR_DMEIF5                      0x00000100U
N#define DMA_HISR_FEIF5                       0x00000040U
N#define DMA_HISR_TCIF4                       0x00000020U
N#define DMA_HISR_HTIF4                       0x00000010U
N#define DMA_HISR_TEIF4                       0x00000008U
N#define DMA_HISR_DMEIF4                      0x00000004U
N#define DMA_HISR_FEIF4                       0x00000001U
N
N/********************  Bits definition for DMA_LIFCR register  ****************/ 
N#define DMA_LIFCR_CTCIF3                     0x08000000U
N#define DMA_LIFCR_CHTIF3                     0x04000000U
N#define DMA_LIFCR_CTEIF3                     0x02000000U
N#define DMA_LIFCR_CDMEIF3                    0x01000000U
N#define DMA_LIFCR_CFEIF3                     0x00400000U
N#define DMA_LIFCR_CTCIF2                     0x00200000U
N#define DMA_LIFCR_CHTIF2                     0x00100000U
N#define DMA_LIFCR_CTEIF2                     0x00080000U
N#define DMA_LIFCR_CDMEIF2                    0x00040000U
N#define DMA_LIFCR_CFEIF2                     0x00010000U
N#define DMA_LIFCR_CTCIF1                     0x00000800U
N#define DMA_LIFCR_CHTIF1                     0x00000400U
N#define DMA_LIFCR_CTEIF1                     0x00000200U
N#define DMA_LIFCR_CDMEIF1                    0x00000100U
N#define DMA_LIFCR_CFEIF1                     0x00000040U
N#define DMA_LIFCR_CTCIF0                     0x00000020U
N#define DMA_LIFCR_CHTIF0                     0x00000010U
N#define DMA_LIFCR_CTEIF0                     0x00000008U
N#define DMA_LIFCR_CDMEIF0                    0x00000004U
N#define DMA_LIFCR_CFEIF0                     0x00000001U
N
N/********************  Bits definition for DMA_HIFCR  register  ****************/ 
N#define DMA_HIFCR_CTCIF7                     0x08000000U
N#define DMA_HIFCR_CHTIF7                     0x04000000U
N#define DMA_HIFCR_CTEIF7                     0x02000000U
N#define DMA_HIFCR_CDMEIF7                    0x01000000U
N#define DMA_HIFCR_CFEIF7                     0x00400000U
N#define DMA_HIFCR_CTCIF6                     0x00200000U
N#define DMA_HIFCR_CHTIF6                     0x00100000U
N#define DMA_HIFCR_CTEIF6                     0x00080000U
N#define DMA_HIFCR_CDMEIF6                    0x00040000U
N#define DMA_HIFCR_CFEIF6                     0x00010000U
N#define DMA_HIFCR_CTCIF5                     0x00000800U
N#define DMA_HIFCR_CHTIF5                     0x00000400U
N#define DMA_HIFCR_CTEIF5                     0x00000200U
N#define DMA_HIFCR_CDMEIF5                    0x00000100U
N#define DMA_HIFCR_CFEIF5                     0x00000040U
N#define DMA_HIFCR_CTCIF4                     0x00000020U
N#define DMA_HIFCR_CHTIF4                     0x00000010U
N#define DMA_HIFCR_CTEIF4                     0x00000008U
N#define DMA_HIFCR_CDMEIF4                    0x00000004U
N#define DMA_HIFCR_CFEIF4                     0x00000001U
N
N/******************************************************************************/
N/*                                                                            */
N/*                         AHB Master DMA2D Controller (DMA2D)                */
N/*                                                                            */
N/******************************************************************************/
N
N/********************  Bit definition for DMA2D_CR register  ******************/
N
N#define DMA2D_CR_START                     0x00000001U               /*!< Start transfer                          */
N#define DMA2D_CR_SUSP                      0x00000002U               /*!< Suspend transfer                        */
N#define DMA2D_CR_ABORT                     0x00000004U               /*!< Abort transfer                          */
N#define DMA2D_CR_TEIE                      0x00000100U               /*!< Transfer Error Interrupt Enable         */
N#define DMA2D_CR_TCIE                      0x00000200U               /*!< Transfer Complete Interrupt Enable      */
N#define DMA2D_CR_TWIE                      0x00000400U               /*!< Transfer Watermark Interrupt Enable     */
N#define DMA2D_CR_CAEIE                     0x00000800U               /*!< CLUT Access Error Interrupt Enable      */
N#define DMA2D_CR_CTCIE                     0x00001000U               /*!< CLUT Transfer Complete Interrupt Enable */
N#define DMA2D_CR_CEIE                      0x00002000U               /*!< Configuration Error Interrupt Enable    */
N#define DMA2D_CR_MODE                      0x00030000U               /*!< DMA2D Mode[1:0]                         */
N#define DMA2D_CR_MODE_0                    0x00010000U               /*!< DMA2D Mode bit 0                        */
N#define DMA2D_CR_MODE_1                    0x00020000U               /*!< DMA2D Mode bit 1                        */
N
N/********************  Bit definition for DMA2D_ISR register  *****************/
N
N#define DMA2D_ISR_TEIF                     0x00000001U               /*!< Transfer Error Interrupt Flag         */
N#define DMA2D_ISR_TCIF                     0x00000002U               /*!< Transfer Complete Interrupt Flag      */
N#define DMA2D_ISR_TWIF                     0x00000004U               /*!< Transfer Watermark Interrupt Flag     */
N#define DMA2D_ISR_CAEIF                    0x00000008U               /*!< CLUT Access Error Interrupt Flag      */
N#define DMA2D_ISR_CTCIF                    0x00000010U               /*!< CLUT Transfer Complete Interrupt Flag */
N#define DMA2D_ISR_CEIF                     0x00000020U               /*!< Configuration Error Interrupt Flag    */
N
N/********************  Bit definition for DMA2D_IFCR register  ****************/
N
N#define DMA2D_IFCR_CTEIF                   0x00000001U               /*!< Clears Transfer Error Interrupt Flag         */
N#define DMA2D_IFCR_CTCIF                   0x00000002U               /*!< Clears Transfer Complete Interrupt Flag      */
N#define DMA2D_IFCR_CTWIF                   0x00000004U               /*!< Clears Transfer Watermark Interrupt Flag     */
N#define DMA2D_IFCR_CAECIF                  0x00000008U               /*!< Clears CLUT Access Error Interrupt Flag      */
N#define DMA2D_IFCR_CCTCIF                  0x00000010U               /*!< Clears CLUT Transfer Complete Interrupt Flag */
N#define DMA2D_IFCR_CCEIF                   0x00000020U               /*!< Clears Configuration Error Interrupt Flag    */
N
N/* Legacy defines */
N#define DMA2D_IFSR_CTEIF                   DMA2D_IFCR_CTEIF                     /*!< Clears Transfer Error Interrupt Flag         */
N#define DMA2D_IFSR_CTCIF                   DMA2D_IFCR_CTCIF                     /*!< Clears Transfer Complete Interrupt Flag      */
N#define DMA2D_IFSR_CTWIF                   DMA2D_IFCR_CTWIF                     /*!< Clears Transfer Watermark Interrupt Flag     */
N#define DMA2D_IFSR_CCAEIF                  DMA2D_IFCR_CAECIF                    /*!< Clears CLUT Access Error Interrupt Flag      */
N#define DMA2D_IFSR_CCTCIF                  DMA2D_IFCR_CCTCIF                    /*!< Clears CLUT Transfer Complete Interrupt Flag */
N#define DMA2D_IFSR_CCEIF                   DMA2D_IFCR_CCEIF                     /*!< Clears Configuration Error Interrupt Flag    */
N
N/********************  Bit definition for DMA2D_FGMAR register  ***************/
N
N#define DMA2D_FGMAR_MA                     0xFFFFFFFFU               /*!< Memory Address */
N
N/********************  Bit definition for DMA2D_FGOR register  ****************/
N
N#define DMA2D_FGOR_LO                      0x00003FFFU               /*!< Line Offset */
N
N/********************  Bit definition for DMA2D_BGMAR register  ***************/
N
N#define DMA2D_BGMAR_MA                     0xFFFFFFFFU               /*!< Memory Address */
N
N/********************  Bit definition for DMA2D_BGOR register  ****************/
N
N#define DMA2D_BGOR_LO                      0x00003FFFU               /*!< Line Offset */
N
N/********************  Bit definition for DMA2D_FGPFCCR register  *************/
N
N#define DMA2D_FGPFCCR_CM                   0x0000000FU               /*!< Input color mode CM[3:0] */
N#define DMA2D_FGPFCCR_CM_0                 0x00000001U               /*!< Input color mode CM bit 0 */
N#define DMA2D_FGPFCCR_CM_1                 0x00000002U               /*!< Input color mode CM bit 1 */
N#define DMA2D_FGPFCCR_CM_2                 0x00000004U               /*!< Input color mode CM bit 2 */
N#define DMA2D_FGPFCCR_CM_3                 0x00000008U               /*!< Input color mode CM bit 3 */
N#define DMA2D_FGPFCCR_CCM                  0x00000010U               /*!< CLUT Color mode */
N#define DMA2D_FGPFCCR_START                0x00000020U               /*!< Start */
N#define DMA2D_FGPFCCR_CS                   0x0000FF00U               /*!< CLUT size */
N#define DMA2D_FGPFCCR_AM                   0x00030000U               /*!< Alpha mode AM[1:0] */
N#define DMA2D_FGPFCCR_AM_0                 0x00010000U               /*!< Alpha mode AM bit 0 */
N#define DMA2D_FGPFCCR_AM_1                 0x00020000U               /*!< Alpha mode AM bit 1 */
N#define DMA2D_FGPFCCR_AI                   0x00100000U               /*!< Foreground Input Alpha Inverted */
N#define DMA2D_FGPFCCR_RBS                  0x00200000U               /*!< Foreground Input Red Blue Swap */
N#define DMA2D_FGPFCCR_ALPHA                0xFF000000U               /*!< Alpha value */
N
N/********************  Bit definition for DMA2D_FGCOLR register  **************/
N
N#define DMA2D_FGCOLR_BLUE                  0x000000FFU               /*!< Blue Value */
N#define DMA2D_FGCOLR_GREEN                 0x0000FF00U               /*!< Green Value */
N#define DMA2D_FGCOLR_RED                   0x00FF0000U               /*!< Red Value */   
N
N/********************  Bit definition for DMA2D_BGPFCCR register  *************/
N
N#define DMA2D_BGPFCCR_CM                   0x0000000FU               /*!< Input color mode CM[3:0] */
N#define DMA2D_BGPFCCR_CM_0                 0x00000001U               /*!< Input color mode CM bit 0 */
N#define DMA2D_BGPFCCR_CM_1                 0x00000002U               /*!< Input color mode CM bit 1 */
N#define DMA2D_BGPFCCR_CM_2                 0x00000004U               /*!< Input color mode CM bit 2 */
N#define DMA2D_FGPFCCR_CM_3                 0x00000008U               /*!< Input color mode CM bit 3 */
N#define DMA2D_BGPFCCR_CCM                  0x00000010U               /*!< CLUT Color mode */
N#define DMA2D_BGPFCCR_START                0x00000020U               /*!< Start */
N#define DMA2D_BGPFCCR_CS                   0x0000FF00U               /*!< CLUT size */
N#define DMA2D_BGPFCCR_AM                   0x00030000U               /*!< Alpha mode AM[1:0] */
N#define DMA2D_BGPFCCR_AM_0                 0x00010000U               /*!< Alpha mode AM bit 0 */
N#define DMA2D_BGPFCCR_AM_1                 0x00020000U               /*!< Alpha mode AM bit 1 */
N#define DMA2D_BGPFCCR_AI                   0x00100000U               /*!< background Input Alpha Inverted */
N#define DMA2D_BGPFCCR_RBS                  0x00200000U               /*!< Background Input Red Blue Swap */
N#define DMA2D_BGPFCCR_ALPHA                0xFF000000U               /*!< background Input Alpha value */
N
N/********************  Bit definition for DMA2D_BGCOLR register  **************/
N
N#define DMA2D_BGCOLR_BLUE                  0x000000FFU               /*!< Blue Value */
N#define DMA2D_BGCOLR_GREEN                 0x0000FF00U               /*!< Green Value */
N#define DMA2D_BGCOLR_RED                   0x00FF0000U               /*!< Red Value */
N
N/********************  Bit definition for DMA2D_FGCMAR register  **************/
N
N#define DMA2D_FGCMAR_MA                    0xFFFFFFFFU               /*!< Memory Address */
N
N/********************  Bit definition for DMA2D_BGCMAR register  **************/
N
N#define DMA2D_BGCMAR_MA                    0xFFFFFFFFU               /*!< Memory Address */
N
N/********************  Bit definition for DMA2D_OPFCCR register  **************/
N
N#define DMA2D_OPFCCR_CM                    0x00000007U               /*!< Color mode CM[2:0] */
N#define DMA2D_OPFCCR_CM_0                  0x00000001U               /*!< Color mode CM bit 0 */
N#define DMA2D_OPFCCR_CM_1                  0x00000002U               /*!< Color mode CM bit 1 */
N#define DMA2D_OPFCCR_CM_2                  0x00000004U               /*!< Color mode CM bit 2 */
N#define DMA2D_OPFCCR_AI                    0x00100000U               /*!< Output Alpha Inverted */
N#define DMA2D_OPFCCR_RBS                   0x00200000U               /*!< Output Red Blue Swap */
N
N/********************  Bit definition for DMA2D_OCOLR register  ***************/
N
N/*!<Mode_ARGB8888/RGB888 */
N
N#define DMA2D_OCOLR_BLUE_1                 0x000000FFU               /*!< BLUE Value */
N#define DMA2D_OCOLR_GREEN_1                0x0000FF00U               /*!< GREEN Value  */
N#define DMA2D_OCOLR_RED_1                  0x00FF0000U               /*!< Red Value */
N#define DMA2D_OCOLR_ALPHA_1                0xFF000000U               /*!< Alpha Channel Value */
N
N/*!<Mode_RGB565 */
N#define DMA2D_OCOLR_BLUE_2                 0x0000001FU               /*!< BLUE Value */
N#define DMA2D_OCOLR_GREEN_2                0x000007E0U               /*!< GREEN Value  */
N#define DMA2D_OCOLR_RED_2                  0x0000F800U               /*!< Red Value */
N
N/*!<Mode_ARGB1555 */
N#define DMA2D_OCOLR_BLUE_3                 0x0000001FU               /*!< BLUE Value */
N#define DMA2D_OCOLR_GREEN_3                0x000003E0U               /*!< GREEN Value  */
N#define DMA2D_OCOLR_RED_3                  0x00007C00U               /*!< Red Value */
N#define DMA2D_OCOLR_ALPHA_3                0x00008000U               /*!< Alpha Channel Value */
N
N/*!<Mode_ARGB4444 */
N#define DMA2D_OCOLR_BLUE_4                 0x0000000FU               /*!< BLUE Value */
N#define DMA2D_OCOLR_GREEN_4                0x000000F0U               /*!< GREEN Value  */
N#define DMA2D_OCOLR_RED_4                  0x00000F00U               /*!< Red Value */
N#define DMA2D_OCOLR_ALPHA_4                0x0000F000U               /*!< Alpha Channel Value */
N
N/********************  Bit definition for DMA2D_OMAR register  ****************/
N
N#define DMA2D_OMAR_MA                      0xFFFFFFFFU               /*!< Memory Address */
N
N/********************  Bit definition for DMA2D_OOR register  *****************/
N
N#define DMA2D_OOR_LO                       0x00003FFFU               /*!< Line Offset */
N
N/********************  Bit definition for DMA2D_NLR register  *****************/
N
N#define DMA2D_NLR_NL                       0x0000FFFFU               /*!< Number of Lines */
N#define DMA2D_NLR_PL                       0x3FFF0000U               /*!< Pixel per Lines */
N
N/********************  Bit definition for DMA2D_LWR register  *****************/
N
N#define DMA2D_LWR_LW                       0x0000FFFFU               /*!< Line Watermark */
N
N/********************  Bit definition for DMA2D_AMTCR register  ***************/
N
N#define DMA2D_AMTCR_EN                     0x00000001U               /*!< Enable */
N#define DMA2D_AMTCR_DT                     0x0000FF00U               /*!< Dead Time */
N
N
N/********************  Bit definition for DMA2D_FGCLUT register  **************/
N                                                                     
N/********************  Bit definition for DMA2D_BGCLUT register  **************/
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                    External Interrupt/Event Controller                     */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for EXTI_IMR register  *******************/
N#define  EXTI_IMR_MR0                        0x00000001U        /*!< Interrupt Mask on line 0 */
N#define  EXTI_IMR_MR1                        0x00000002U        /*!< Interrupt Mask on line 1 */
N#define  EXTI_IMR_MR2                        0x00000004U        /*!< Interrupt Mask on line 2 */
N#define  EXTI_IMR_MR3                        0x00000008U        /*!< Interrupt Mask on line 3 */
N#define  EXTI_IMR_MR4                        0x00000010U        /*!< Interrupt Mask on line 4 */
N#define  EXTI_IMR_MR5                        0x00000020U        /*!< Interrupt Mask on line 5 */
N#define  EXTI_IMR_MR6                        0x00000040U        /*!< Interrupt Mask on line 6 */
N#define  EXTI_IMR_MR7                        0x00000080U        /*!< Interrupt Mask on line 7 */
N#define  EXTI_IMR_MR8                        0x00000100U        /*!< Interrupt Mask on line 8 */
N#define  EXTI_IMR_MR9                        0x00000200U        /*!< Interrupt Mask on line 9 */
N#define  EXTI_IMR_MR10                       0x00000400U        /*!< Interrupt Mask on line 10 */
N#define  EXTI_IMR_MR11                       0x00000800U        /*!< Interrupt Mask on line 11 */
N#define  EXTI_IMR_MR12                       0x00001000U        /*!< Interrupt Mask on line 12 */
N#define  EXTI_IMR_MR13                       0x00002000U        /*!< Interrupt Mask on line 13 */
N#define  EXTI_IMR_MR14                       0x00004000U        /*!< Interrupt Mask on line 14 */
N#define  EXTI_IMR_MR15                       0x00008000U        /*!< Interrupt Mask on line 15 */
N#define  EXTI_IMR_MR16                       0x00010000U        /*!< Interrupt Mask on line 16 */
N#define  EXTI_IMR_MR17                       0x00020000U        /*!< Interrupt Mask on line 17 */
N#define  EXTI_IMR_MR18                       0x00040000U        /*!< Interrupt Mask on line 18 */
N#define  EXTI_IMR_MR19                       0x00080000U        /*!< Interrupt Mask on line 19 */
N#define  EXTI_IMR_MR20                       0x00100000U        /*!< Interrupt Mask on line 20 */
N#define  EXTI_IMR_MR21                       0x00200000U        /*!< Interrupt Mask on line 21 */
N#define  EXTI_IMR_MR22                       0x00400000U        /*!< Interrupt Mask on line 22 */
N#define  EXTI_IMR_MR23                       0x00800000U        /*!< Interrupt Mask on line 23 */
N#define  EXTI_IMR_MR24                       0x01000000U        /*!< Interrupt Mask on line 24 */
N
N/* Reference Defines */
N#define  EXTI_IMR_IM0                        EXTI_IMR_MR0                     
N#define  EXTI_IMR_IM1                        EXTI_IMR_MR1 
N#define  EXTI_IMR_IM2                        EXTI_IMR_MR2 
N#define  EXTI_IMR_IM3                        EXTI_IMR_MR3 
N#define  EXTI_IMR_IM4                        EXTI_IMR_MR4 
N#define  EXTI_IMR_IM5                        EXTI_IMR_MR5 
N#define  EXTI_IMR_IM6                        EXTI_IMR_MR6 
N#define  EXTI_IMR_IM7                        EXTI_IMR_MR7 
N#define  EXTI_IMR_IM8                        EXTI_IMR_MR8 
N#define  EXTI_IMR_IM9                        EXTI_IMR_MR9 
N#define  EXTI_IMR_IM10                       EXTI_IMR_MR10
N#define  EXTI_IMR_IM11                       EXTI_IMR_MR11
N#define  EXTI_IMR_IM12                       EXTI_IMR_MR12
N#define  EXTI_IMR_IM13                       EXTI_IMR_MR13
N#define  EXTI_IMR_IM14                       EXTI_IMR_MR14
N#define  EXTI_IMR_IM15                       EXTI_IMR_MR15
N#define  EXTI_IMR_IM16                       EXTI_IMR_MR16
N#define  EXTI_IMR_IM17                       EXTI_IMR_MR17
N#define  EXTI_IMR_IM18                       EXTI_IMR_MR18
N#define  EXTI_IMR_IM19                       EXTI_IMR_MR19
N#define  EXTI_IMR_IM20                       EXTI_IMR_MR20
N#define  EXTI_IMR_IM21                       EXTI_IMR_MR21
N#define  EXTI_IMR_IM22                       EXTI_IMR_MR22
N#define  EXTI_IMR_IM23                       EXTI_IMR_MR23
N#define  EXTI_IMR_IM24                       EXTI_IMR_MR24
N
N#define  EXTI_IMR_IM                         0x01FFFFFFU        /*!< Interrupt Mask All */
N
N/*******************  Bit definition for EXTI_EMR register  *******************/
N#define  EXTI_EMR_MR0                        0x00000001U        /*!< Event Mask on line 0 */
N#define  EXTI_EMR_MR1                        0x00000002U        /*!< Event Mask on line 1 */
N#define  EXTI_EMR_MR2                        0x00000004U        /*!< Event Mask on line 2 */
N#define  EXTI_EMR_MR3                        0x00000008U        /*!< Event Mask on line 3 */
N#define  EXTI_EMR_MR4                        0x00000010U        /*!< Event Mask on line 4 */
N#define  EXTI_EMR_MR5                        0x00000020U        /*!< Event Mask on line 5 */
N#define  EXTI_EMR_MR6                        0x00000040U        /*!< Event Mask on line 6 */
N#define  EXTI_EMR_MR7                        0x00000080U        /*!< Event Mask on line 7 */
N#define  EXTI_EMR_MR8                        0x00000100U        /*!< Event Mask on line 8 */
N#define  EXTI_EMR_MR9                        0x00000200U        /*!< Event Mask on line 9 */
N#define  EXTI_EMR_MR10                       0x00000400U        /*!< Event Mask on line 10 */
N#define  EXTI_EMR_MR11                       0x00000800U        /*!< Event Mask on line 11 */
N#define  EXTI_EMR_MR12                       0x00001000U        /*!< Event Mask on line 12 */
N#define  EXTI_EMR_MR13                       0x00002000U        /*!< Event Mask on line 13 */
N#define  EXTI_EMR_MR14                       0x00004000U        /*!< Event Mask on line 14 */
N#define  EXTI_EMR_MR15                       0x00008000U        /*!< Event Mask on line 15 */
N#define  EXTI_EMR_MR16                       0x00010000U        /*!< Event Mask on line 16 */
N#define  EXTI_EMR_MR17                       0x00020000U        /*!< Event Mask on line 17 */
N#define  EXTI_EMR_MR18                       0x00040000U        /*!< Event Mask on line 18 */
N#define  EXTI_EMR_MR19                       0x00080000U        /*!< Event Mask on line 19 */
N#define  EXTI_EMR_MR20                       0x00100000U        /*!< Event Mask on line 20 */
N#define  EXTI_EMR_MR21                       0x00200000U        /*!< Event Mask on line 21 */
N#define  EXTI_EMR_MR22                       0x00400000U        /*!< Event Mask on line 22 */
N#define  EXTI_EMR_MR23                       0x00800000U        /*!< Event Mask on line 23 */
N#define  EXTI_EMR_MR24                       0x01000000U        /*!< Event Mask on line 24 */
N
N/* Reference Defines */
N#define  EXTI_EMR_EM0                        EXTI_EMR_MR0                         
N#define  EXTI_EMR_EM1                        EXTI_EMR_MR1 
N#define  EXTI_EMR_EM2                        EXTI_EMR_MR2 
N#define  EXTI_EMR_EM3                        EXTI_EMR_MR3 
N#define  EXTI_EMR_EM4                        EXTI_EMR_MR4 
N#define  EXTI_EMR_EM5                        EXTI_EMR_MR5 
N#define  EXTI_EMR_EM6                        EXTI_EMR_MR6 
N#define  EXTI_EMR_EM7                        EXTI_EMR_MR7 
N#define  EXTI_EMR_EM8                        EXTI_EMR_MR8 
N#define  EXTI_EMR_EM9                        EXTI_EMR_MR9 
N#define  EXTI_EMR_EM10                       EXTI_EMR_MR10
N#define  EXTI_EMR_EM11                       EXTI_EMR_MR11
N#define  EXTI_EMR_EM12                       EXTI_EMR_MR12
N#define  EXTI_EMR_EM13                       EXTI_EMR_MR13
N#define  EXTI_EMR_EM14                       EXTI_EMR_MR14
N#define  EXTI_EMR_EM15                       EXTI_EMR_MR15
N#define  EXTI_EMR_EM16                       EXTI_EMR_MR16
N#define  EXTI_EMR_EM17                       EXTI_EMR_MR17
N#define  EXTI_EMR_EM18                       EXTI_EMR_MR18
N#define  EXTI_EMR_EM19                       EXTI_EMR_MR19
N#define  EXTI_EMR_EM20                       EXTI_EMR_MR20
N#define  EXTI_EMR_EM21                       EXTI_EMR_MR21
N#define  EXTI_EMR_EM22                       EXTI_EMR_MR22
N#define  EXTI_EMR_EM23                       EXTI_EMR_MR23
N#define  EXTI_EMR_EM24                       EXTI_EMR_MR24
N
N
N/******************  Bit definition for EXTI_RTSR register  *******************/
N#define  EXTI_RTSR_TR0                       0x00000001U        /*!< Rising trigger event configuration bit of line 0 */
N#define  EXTI_RTSR_TR1                       0x00000002U        /*!< Rising trigger event configuration bit of line 1 */
N#define  EXTI_RTSR_TR2                       0x00000004U        /*!< Rising trigger event configuration bit of line 2 */
N#define  EXTI_RTSR_TR3                       0x00000008U        /*!< Rising trigger event configuration bit of line 3 */
N#define  EXTI_RTSR_TR4                       0x00000010U        /*!< Rising trigger event configuration bit of line 4 */
N#define  EXTI_RTSR_TR5                       0x00000020U        /*!< Rising trigger event configuration bit of line 5 */
N#define  EXTI_RTSR_TR6                       0x00000040U        /*!< Rising trigger event configuration bit of line 6 */
N#define  EXTI_RTSR_TR7                       0x00000080U        /*!< Rising trigger event configuration bit of line 7 */
N#define  EXTI_RTSR_TR8                       0x00000100U        /*!< Rising trigger event configuration bit of line 8 */
N#define  EXTI_RTSR_TR9                       0x00000200U        /*!< Rising trigger event configuration bit of line 9 */
N#define  EXTI_RTSR_TR10                      0x00000400U        /*!< Rising trigger event configuration bit of line 10 */
N#define  EXTI_RTSR_TR11                      0x00000800U        /*!< Rising trigger event configuration bit of line 11 */
N#define  EXTI_RTSR_TR12                      0x00001000U        /*!< Rising trigger event configuration bit of line 12 */
N#define  EXTI_RTSR_TR13                      0x00002000U        /*!< Rising trigger event configuration bit of line 13 */
N#define  EXTI_RTSR_TR14                      0x00004000U        /*!< Rising trigger event configuration bit of line 14 */
N#define  EXTI_RTSR_TR15                      0x00008000U        /*!< Rising trigger event configuration bit of line 15 */
N#define  EXTI_RTSR_TR16                      0x00010000U        /*!< Rising trigger event configuration bit of line 16 */
N#define  EXTI_RTSR_TR17                      0x00020000U        /*!< Rising trigger event configuration bit of line 17 */
N#define  EXTI_RTSR_TR18                      0x00040000U        /*!< Rising trigger event configuration bit of line 18 */
N#define  EXTI_RTSR_TR19                      0x00080000U        /*!< Rising trigger event configuration bit of line 19 */
N#define  EXTI_RTSR_TR20                      0x00100000U        /*!< Rising trigger event configuration bit of line 20 */
N#define  EXTI_RTSR_TR21                      0x00200000U        /*!< Rising trigger event configuration bit of line 21 */
N#define  EXTI_RTSR_TR22                      0x00400000U        /*!< Rising trigger event configuration bit of line 22 */
N#define  EXTI_RTSR_TR23                      0x00800000U        /*!< Rising trigger event configuration bit of line 23 */
N#define  EXTI_RTSR_TR24                      0x01000000U        /*!< Rising trigger event configuration bit of line 24 */
N
N/******************  Bit definition for EXTI_FTSR register  *******************/
N#define  EXTI_FTSR_TR0                       0x00000001U        /*!< Falling trigger event configuration bit of line 0 */
N#define  EXTI_FTSR_TR1                       0x00000002U        /*!< Falling trigger event configuration bit of line 1 */
N#define  EXTI_FTSR_TR2                       0x00000004U        /*!< Falling trigger event configuration bit of line 2 */
N#define  EXTI_FTSR_TR3                       0x00000008U        /*!< Falling trigger event configuration bit of line 3 */
N#define  EXTI_FTSR_TR4                       0x00000010U        /*!< Falling trigger event configuration bit of line 4 */
N#define  EXTI_FTSR_TR5                       0x00000020U        /*!< Falling trigger event configuration bit of line 5 */
N#define  EXTI_FTSR_TR6                       0x00000040U        /*!< Falling trigger event configuration bit of line 6 */
N#define  EXTI_FTSR_TR7                       0x00000080U        /*!< Falling trigger event configuration bit of line 7 */
N#define  EXTI_FTSR_TR8                       0x00000100U        /*!< Falling trigger event configuration bit of line 8 */
N#define  EXTI_FTSR_TR9                       0x00000200U        /*!< Falling trigger event configuration bit of line 9 */
N#define  EXTI_FTSR_TR10                      0x00000400U        /*!< Falling trigger event configuration bit of line 10 */
N#define  EXTI_FTSR_TR11                      0x00000800U        /*!< Falling trigger event configuration bit of line 11 */
N#define  EXTI_FTSR_TR12                      0x00001000U        /*!< Falling trigger event configuration bit of line 12 */
N#define  EXTI_FTSR_TR13                      0x00002000U        /*!< Falling trigger event configuration bit of line 13 */
N#define  EXTI_FTSR_TR14                      0x00004000U        /*!< Falling trigger event configuration bit of line 14 */
N#define  EXTI_FTSR_TR15                      0x00008000U        /*!< Falling trigger event configuration bit of line 15 */
N#define  EXTI_FTSR_TR16                      0x00010000U        /*!< Falling trigger event configuration bit of line 16 */
N#define  EXTI_FTSR_TR17                      0x00020000U        /*!< Falling trigger event configuration bit of line 17 */
N#define  EXTI_FTSR_TR18                      0x00040000U        /*!< Falling trigger event configuration bit of line 18 */
N#define  EXTI_FTSR_TR19                      0x00080000U        /*!< Falling trigger event configuration bit of line 19 */
N#define  EXTI_FTSR_TR20                      0x00100000U        /*!< Falling trigger event configuration bit of line 20 */
N#define  EXTI_FTSR_TR21                      0x00200000U        /*!< Falling trigger event configuration bit of line 21 */
N#define  EXTI_FTSR_TR22                      0x00400000U        /*!< Falling trigger event configuration bit of line 22 */
N#define  EXTI_FTSR_TR23                      0x00800000U        /*!< Falling trigger event configuration bit of line 23 */
N#define  EXTI_FTSR_TR24                      0x01000000U        /*!< Falling trigger event configuration bit of line 24 */
N
N/******************  Bit definition for EXTI_SWIER register  ******************/
N#define  EXTI_SWIER_SWIER0                   0x00000001U        /*!< Software Interrupt on line 0 */
N#define  EXTI_SWIER_SWIER1                   0x00000002U        /*!< Software Interrupt on line 1 */
N#define  EXTI_SWIER_SWIER2                   0x00000004U        /*!< Software Interrupt on line 2 */
N#define  EXTI_SWIER_SWIER3                   0x00000008U        /*!< Software Interrupt on line 3 */
N#define  EXTI_SWIER_SWIER4                   0x00000010U        /*!< Software Interrupt on line 4 */
N#define  EXTI_SWIER_SWIER5                   0x00000020U        /*!< Software Interrupt on line 5 */
N#define  EXTI_SWIER_SWIER6                   0x00000040U        /*!< Software Interrupt on line 6 */
N#define  EXTI_SWIER_SWIER7                   0x00000080U        /*!< Software Interrupt on line 7 */
N#define  EXTI_SWIER_SWIER8                   0x00000100U        /*!< Software Interrupt on line 8 */
N#define  EXTI_SWIER_SWIER9                   0x00000200U        /*!< Software Interrupt on line 9 */
N#define  EXTI_SWIER_SWIER10                  0x00000400U        /*!< Software Interrupt on line 10 */
N#define  EXTI_SWIER_SWIER11                  0x00000800U        /*!< Software Interrupt on line 11 */
N#define  EXTI_SWIER_SWIER12                  0x00001000U        /*!< Software Interrupt on line 12 */
N#define  EXTI_SWIER_SWIER13                  0x00002000U        /*!< Software Interrupt on line 13 */
N#define  EXTI_SWIER_SWIER14                  0x00004000U        /*!< Software Interrupt on line 14 */
N#define  EXTI_SWIER_SWIER15                  0x00008000U        /*!< Software Interrupt on line 15 */
N#define  EXTI_SWIER_SWIER16                  0x00010000U        /*!< Software Interrupt on line 16 */
N#define  EXTI_SWIER_SWIER17                  0x00020000U        /*!< Software Interrupt on line 17 */
N#define  EXTI_SWIER_SWIER18                  0x00040000U        /*!< Software Interrupt on line 18 */
N#define  EXTI_SWIER_SWIER19                  0x00080000U        /*!< Software Interrupt on line 19 */
N#define  EXTI_SWIER_SWIER20                  0x00100000U        /*!< Software Interrupt on line 20 */
N#define  EXTI_SWIER_SWIER21                  0x00200000U        /*!< Software Interrupt on line 21 */
N#define  EXTI_SWIER_SWIER22                  0x00400000U        /*!< Software Interrupt on line 22 */
N#define  EXTI_SWIER_SWIER23                  0x00800000U        /*!< Software Interrupt on line 23 */
N#define  EXTI_SWIER_SWIER24                  0x01000000U        /*!< Software Interrupt on line 24 */
N
N/*******************  Bit definition for EXTI_PR register  ********************/
N#define  EXTI_PR_PR0                         0x00000001U        /*!< Pending bit for line 0 */
N#define  EXTI_PR_PR1                         0x00000002U        /*!< Pending bit for line 1 */
N#define  EXTI_PR_PR2                         0x00000004U        /*!< Pending bit for line 2 */
N#define  EXTI_PR_PR3                         0x00000008U        /*!< Pending bit for line 3 */
N#define  EXTI_PR_PR4                         0x00000010U        /*!< Pending bit for line 4 */
N#define  EXTI_PR_PR5                         0x00000020U        /*!< Pending bit for line 5 */
N#define  EXTI_PR_PR6                         0x00000040U        /*!< Pending bit for line 6 */
N#define  EXTI_PR_PR7                         0x00000080U        /*!< Pending bit for line 7 */
N#define  EXTI_PR_PR8                         0x00000100U        /*!< Pending bit for line 8 */
N#define  EXTI_PR_PR9                         0x00000200U        /*!< Pending bit for line 9 */
N#define  EXTI_PR_PR10                        0x00000400U        /*!< Pending bit for line 10 */
N#define  EXTI_PR_PR11                        0x00000800U        /*!< Pending bit for line 11 */
N#define  EXTI_PR_PR12                        0x00001000U        /*!< Pending bit for line 12 */
N#define  EXTI_PR_PR13                        0x00002000U        /*!< Pending bit for line 13 */
N#define  EXTI_PR_PR14                        0x00004000U        /*!< Pending bit for line 14 */
N#define  EXTI_PR_PR15                        0x00008000U        /*!< Pending bit for line 15 */
N#define  EXTI_PR_PR16                        0x00010000U        /*!< Pending bit for line 16 */
N#define  EXTI_PR_PR17                        0x00020000U        /*!< Pending bit for line 17 */
N#define  EXTI_PR_PR18                        0x00040000U        /*!< Pending bit for line 18 */
N#define  EXTI_PR_PR19                        0x00080000U        /*!< Pending bit for line 19 */
N#define  EXTI_PR_PR20                        0x00100000U        /*!< Pending bit for line 20 */
N#define  EXTI_PR_PR21                        0x00200000U        /*!< Pending bit for line 21 */
N#define  EXTI_PR_PR22                        0x00400000U        /*!< Pending bit for line 22 */
N#define  EXTI_PR_PR23                        0x00800000U        /*!< Pending bit for line 23 */
N#define  EXTI_PR_PR24                        0x01000000U        /*!< Pending bit for line 24 */
N
N/******************************************************************************/
N/*                                                                            */
N/*                                    FLASH                                   */
N/*                                                                            */
N/******************************************************************************/
N/*
N* @brief FLASH Total Sectors Number
N*/
N#define FLASH_SECTOR_TOTAL  24
N
N/*******************  Bits definition for FLASH_ACR register  *****************/
N#define FLASH_ACR_LATENCY                    0x0000000FU
N#define FLASH_ACR_LATENCY_0WS                0x00000000U
N#define FLASH_ACR_LATENCY_1WS                0x00000001U
N#define FLASH_ACR_LATENCY_2WS                0x00000002U
N#define FLASH_ACR_LATENCY_3WS                0x00000003U
N#define FLASH_ACR_LATENCY_4WS                0x00000004U
N#define FLASH_ACR_LATENCY_5WS                0x00000005U
N#define FLASH_ACR_LATENCY_6WS                0x00000006U
N#define FLASH_ACR_LATENCY_7WS                0x00000007U
N#define FLASH_ACR_LATENCY_8WS                0x00000008U
N#define FLASH_ACR_LATENCY_9WS                0x00000009U
N#define FLASH_ACR_LATENCY_10WS               0x0000000AU
N#define FLASH_ACR_LATENCY_11WS               0x0000000BU
N#define FLASH_ACR_LATENCY_12WS               0x0000000CU
N#define FLASH_ACR_LATENCY_13WS               0x0000000DU
N#define FLASH_ACR_LATENCY_14WS               0x0000000EU
N#define FLASH_ACR_LATENCY_15WS               0x0000000FU
N#define FLASH_ACR_PRFTEN                     0x00000100U
N#define FLASH_ACR_ARTEN                      0x00000200U
N#define FLASH_ACR_ARTRST                     0x00000800U
N
N/*******************  Bits definition for FLASH_SR register  ******************/
N#define FLASH_SR_EOP                         0x00000001U
N#define FLASH_SR_OPERR                       0x00000002U
N#define FLASH_SR_WRPERR                      0x00000010U
N#define FLASH_SR_PGAERR                      0x00000020U
N#define FLASH_SR_PGPERR                      0x00000040U
N#define FLASH_SR_ERSERR                      0x00000080U
N#define FLASH_SR_BSY                         0x00010000U
N
N/*******************  Bits definition for FLASH_CR register  ******************/
N#define FLASH_CR_PG                          0x00000001U
N#define FLASH_CR_SER                         0x00000002U
N#define FLASH_CR_MER                         0x00000004U
N#define FLASH_CR_MER1                        FLASH_CR_MER
N#define FLASH_CR_SNB                         0x000000F8U
N#define FLASH_CR_SNB_0                       0x00000008U
N#define FLASH_CR_SNB_1                       0x00000010U
N#define FLASH_CR_SNB_2                       0x00000020U
N#define FLASH_CR_SNB_3                       0x00000040U
N#define FLASH_CR_SNB_4                       0x00000080U
N#define FLASH_CR_PSIZE                       0x00000300U
N#define FLASH_CR_PSIZE_0                     0x00000100U
N#define FLASH_CR_PSIZE_1                     0x00000200U
N#define FLASH_CR_MER2                        0x00008000U
N#define FLASH_CR_STRT                        0x00010000U
N#define FLASH_CR_EOPIE                       0x01000000U
N#define FLASH_CR_ERRIE                       0x02000000U
N#define FLASH_CR_LOCK                        0x80000000U
N
N/*******************  Bits definition for FLASH_OPTCR register  ***************/
N#define FLASH_OPTCR_OPTLOCK                 0x00000001U
N#define FLASH_OPTCR_OPTSTRT                 0x00000002U
N#define FLASH_OPTCR_BOR_LEV                 0x0000000CU
N#define FLASH_OPTCR_BOR_LEV_0               0x00000004U
N#define FLASH_OPTCR_BOR_LEV_1               0x00000008U
N#define FLASH_OPTCR_WWDG_SW                 0x00000010U
N#define FLASH_OPTCR_IWDG_SW                 0x00000020U
N#define FLASH_OPTCR_nRST_STOP               0x00000040U
N#define FLASH_OPTCR_nRST_STDBY              0x00000080U
N#define FLASH_OPTCR_RDP                     0x0000FF00U
N#define FLASH_OPTCR_RDP_0                   0x00000100U
N#define FLASH_OPTCR_RDP_1                   0x00000200U
N#define FLASH_OPTCR_RDP_2                   0x00000400U
N#define FLASH_OPTCR_RDP_3                   0x00000800U
N#define FLASH_OPTCR_RDP_4                   0x00001000U
N#define FLASH_OPTCR_RDP_5                   0x00002000U
N#define FLASH_OPTCR_RDP_6                   0x00004000U
N#define FLASH_OPTCR_RDP_7                   0x00008000U
N#define FLASH_OPTCR_nWRP                    0x0FFF0000U
N#define FLASH_OPTCR_nWRP_0                  0x00010000U
N#define FLASH_OPTCR_nWRP_1                  0x00020000U
N#define FLASH_OPTCR_nWRP_2                  0x00040000U
N#define FLASH_OPTCR_nWRP_3                  0x00080000U
N#define FLASH_OPTCR_nWRP_4                  0x00100000U
N#define FLASH_OPTCR_nWRP_5                  0x00200000U
N#define FLASH_OPTCR_nWRP_6                  0x00400000U
N#define FLASH_OPTCR_nWRP_7                  0x00800000U
N#define FLASH_OPTCR_nWRP_8                  0x01000000U
N#define FLASH_OPTCR_nWRP_9                  0x02000000U
N#define FLASH_OPTCR_nWRP_10                 0x04000000U
N#define FLASH_OPTCR_nWRP_11                 0x08000000U
N#define FLASH_OPTCR_nDBOOT                  0x10000000U
N#define FLASH_OPTCR_nDBANK                  0x20000000U
N#define FLASH_OPTCR_IWDG_STDBY              0x40000000U
N#define FLASH_OPTCR_IWDG_STOP               0x80000000U
N
N/*******************  Bits definition for FLASH_OPTCR1 register  ***************/
N#define FLASH_OPTCR1_BOOT_ADD0              0x0000FFFFU
N#define FLASH_OPTCR1_BOOT_ADD1              0xFFFF0000U
N
N/******************************************************************************/
N/*                                                                            */
N/*                          Flexible Memory Controller                        */
N/*                                                                            */
N/******************************************************************************/
N/******************  Bit definition for FMC_BCR1 register  *******************/
N#define  FMC_BCR1_MBKEN                     0x00000001U        /*!<Memory bank enable bit                 */
N#define  FMC_BCR1_MUXEN                     0x00000002U        /*!<Address/data multiplexing enable bit   */
N#define  FMC_BCR1_MTYP                      0x0000000CU        /*!<MTYP[1:0] bits (Memory type)           */
N#define  FMC_BCR1_MTYP_0                    0x00000004U        /*!<Bit 0 */
N#define  FMC_BCR1_MTYP_1                    0x00000008U        /*!<Bit 1 */
N#define  FMC_BCR1_MWID                      0x00000030U        /*!<MWID[1:0] bits (Memory data bus width) */
N#define  FMC_BCR1_MWID_0                    0x00000010U        /*!<Bit 0 */
N#define  FMC_BCR1_MWID_1                    0x00000020U        /*!<Bit 1 */
N#define  FMC_BCR1_FACCEN                    0x00000040U        /*!<Flash access enable        */
N#define  FMC_BCR1_BURSTEN                   0x00000100U        /*!<Burst enable bit           */
N#define  FMC_BCR1_WAITPOL                   0x00000200U        /*!<Wait signal polarity bit   */
N#define  FMC_BCR1_WRAPMOD                   0x00000400U        /*!<Wrapped burst mode support */
N#define  FMC_BCR1_WAITCFG                   0x00000800U        /*!<Wait timing configuration  */
N#define  FMC_BCR1_WREN                      0x00001000U        /*!<Write enable bit           */
N#define  FMC_BCR1_WAITEN                    0x00002000U        /*!<Wait enable bit            */
N#define  FMC_BCR1_EXTMOD                    0x00004000U        /*!<Extended mode enable       */
N#define  FMC_BCR1_ASYNCWAIT                 0x00008000U        /*!<Asynchronous wait          */
N#define  FMC_BCR1_CPSIZE                    0x00070000U        /*!<CRAM page size             */
N#define  FMC_BCR1_CPSIZE_0                  0x00010000U        /*!<Bit 0 */
N#define  FMC_BCR1_CPSIZE_1                  0x00020000U        /*!<Bit 1 */
N#define  FMC_BCR1_CPSIZE_2                  0x00040000U        /*!<Bit 2 */
N#define  FMC_BCR1_CBURSTRW                  0x00080000U        /*!<Write burst enable         */
N#define  FMC_BCR1_CCLKEN                    0x00100000U        /*!<Continous clock enable     */
N#define  FMC_BCR1_WFDIS                     0x00200000U        /*!<Write FIFO Disable         */
N
N/******************  Bit definition for FMC_BCR2 register  *******************/
N#define  FMC_BCR2_MBKEN                     0x00000001U        /*!<Memory bank enable bit                 */
N#define  FMC_BCR2_MUXEN                     0x00000002U        /*!<Address/data multiplexing enable bit   */
N#define  FMC_BCR2_MTYP                      0x0000000CU        /*!<MTYP[1:0] bits (Memory type)           */
N#define  FMC_BCR2_MTYP_0                    0x00000004U        /*!<Bit 0 */
N#define  FMC_BCR2_MTYP_1                    0x00000008U        /*!<Bit 1 */
N#define  FMC_BCR2_MWID                      0x00000030U        /*!<MWID[1:0] bits (Memory data bus width) */
N#define  FMC_BCR2_MWID_0                    0x00000010U        /*!<Bit 0 */
N#define  FMC_BCR2_MWID_1                    0x00000020U        /*!<Bit 1 */
N#define  FMC_BCR2_FACCEN                    0x00000040U        /*!<Flash access enable        */
N#define  FMC_BCR2_BURSTEN                   0x00000100U        /*!<Burst enable bit           */
N#define  FMC_BCR2_WAITPOL                   0x00000200U        /*!<Wait signal polarity bit   */
N#define  FMC_BCR2_WRAPMOD                   0x00000400U        /*!<Wrapped burst mode support */
N#define  FMC_BCR2_WAITCFG                   0x00000800U        /*!<Wait timing configuration  */
N#define  FMC_BCR2_WREN                      0x00001000U        /*!<Write enable bit           */
N#define  FMC_BCR2_WAITEN                    0x00002000U        /*!<Wait enable bit            */
N#define  FMC_BCR2_EXTMOD                    0x00004000U        /*!<Extended mode enable       */
N#define  FMC_BCR2_ASYNCWAIT                 0x00008000U        /*!<Asynchronous wait          */
N#define  FMC_BCR2_CPSIZE                    0x00070000U        /*!<CRAM page size             */
N#define  FMC_BCR2_CPSIZE_0                  0x00010000U        /*!<Bit 0 */
N#define  FMC_BCR2_CPSIZE_1                  0x00020000U        /*!<Bit 1 */
N#define  FMC_BCR2_CPSIZE_2                  0x00040000U        /*!<Bit 2 */
N#define  FMC_BCR2_CBURSTRW                  0x00080000U        /*!<Write burst enable         */
N
N/******************  Bit definition for FMC_BCR3 register  *******************/
N#define  FMC_BCR3_MBKEN                     0x00000001U        /*!<Memory bank enable bit                 */
N#define  FMC_BCR3_MUXEN                     0x00000002U        /*!<Address/data multiplexing enable bit   */
N#define  FMC_BCR3_MTYP                      0x0000000CU        /*!<MTYP[1:0] bits (Memory type)           */
N#define  FMC_BCR3_MTYP_0                    0x00000004U        /*!<Bit 0 */
N#define  FMC_BCR3_MTYP_1                    0x00000008U        /*!<Bit 1 */
N#define  FMC_BCR3_MWID                      0x00000030U        /*!<MWID[1:0] bits (Memory data bus width) */
N#define  FMC_BCR3_MWID_0                    0x00000010U        /*!<Bit 0 */
N#define  FMC_BCR3_MWID_1                    0x00000020U        /*!<Bit 1 */
N#define  FMC_BCR3_FACCEN                    0x00000040U        /*!<Flash access enable        */
N#define  FMC_BCR3_BURSTEN                   0x00000100U        /*!<Burst enable bit           */
N#define  FMC_BCR3_WAITPOL                   0x00000200U        /*!<Wait signal polarity bit   */
N#define  FMC_BCR3_WRAPMOD                   0x00000400U        /*!<Wrapped burst mode support */
N#define  FMC_BCR3_WAITCFG                   0x00000800U        /*!<Wait timing configuration  */
N#define  FMC_BCR3_WREN                      0x00001000U        /*!<Write enable bit           */
N#define  FMC_BCR3_WAITEN                    0x00002000U        /*!<Wait enable bit            */
N#define  FMC_BCR3_EXTMOD                    0x00004000U        /*!<Extended mode enable       */
N#define  FMC_BCR3_ASYNCWAIT                 0x00008000U        /*!<Asynchronous wait          */
N#define  FMC_BCR3_CPSIZE                    0x00070000U        /*!<CRAM page size             */
N#define  FMC_BCR3_CPSIZE_0                  0x00010000U        /*!<Bit 0 */
N#define  FMC_BCR3_CPSIZE_1                  0x00020000U        /*!<Bit 1 */
N#define  FMC_BCR3_CPSIZE_2                  0x00040000U        /*!<Bit 2 */
N#define  FMC_BCR3_CBURSTRW                  0x00080000U        /*!<Write burst enable         */
N
N/******************  Bit definition for FMC_BCR4 register  *******************/
N#define  FMC_BCR4_MBKEN                     0x00000001U        /*!<Memory bank enable bit                 */
N#define  FMC_BCR4_MUXEN                     0x00000002U        /*!<Address/data multiplexing enable bit   */
N#define  FMC_BCR4_MTYP                      0x0000000CU        /*!<MTYP[1:0] bits (Memory type)           */
N#define  FMC_BCR4_MTYP_0                    0x00000004U        /*!<Bit 0 */
N#define  FMC_BCR4_MTYP_1                    0x00000008U        /*!<Bit 1 */
N#define  FMC_BCR4_MWID                      0x00000030U        /*!<MWID[1:0] bits (Memory data bus width) */
N#define  FMC_BCR4_MWID_0                    0x00000010U        /*!<Bit 0 */
N#define  FMC_BCR4_MWID_1                    0x00000020U        /*!<Bit 1 */
N#define  FMC_BCR4_FACCEN                    0x00000040U        /*!<Flash access enable        */
N#define  FMC_BCR4_BURSTEN                   0x00000100U        /*!<Burst enable bit           */
N#define  FMC_BCR4_WAITPOL                   0x00000200U        /*!<Wait signal polarity bit   */
N#define  FMC_BCR4_WRAPMOD                   0x00000400U        /*!<Wrapped burst mode support */
N#define  FMC_BCR4_WAITCFG                   0x00000800U        /*!<Wait timing configuration  */
N#define  FMC_BCR4_WREN                      0x00001000U        /*!<Write enable bit           */
N#define  FMC_BCR4_WAITEN                    0x00002000U        /*!<Wait enable bit            */
N#define  FMC_BCR4_EXTMOD                    0x00004000U        /*!<Extended mode enable       */
N#define  FMC_BCR4_ASYNCWAIT                 0x00008000U        /*!<Asynchronous wait          */
N#define  FMC_BCR4_CPSIZE                    0x00070000U        /*!<CRAM page size             */
N#define  FMC_BCR4_CPSIZE_0                  0x00010000U        /*!<Bit 0 */
N#define  FMC_BCR4_CPSIZE_1                  0x00020000U        /*!<Bit 1 */
N#define  FMC_BCR4_CPSIZE_2                  0x00040000U        /*!<Bit 2 */
N#define  FMC_BCR4_CBURSTRW                  0x00080000U        /*!<Write burst enable         */
N
N/******************  Bit definition for FMC_BTR1 register  ******************/
N#define  FMC_BTR1_ADDSET                    0x0000000FU        /*!<ADDSET[3:0] bits (Address setup phase duration) */
N#define  FMC_BTR1_ADDSET_0                  0x00000001U        /*!<Bit 0 */
N#define  FMC_BTR1_ADDSET_1                  0x00000002U        /*!<Bit 1 */
N#define  FMC_BTR1_ADDSET_2                  0x00000004U        /*!<Bit 2 */
N#define  FMC_BTR1_ADDSET_3                  0x00000008U        /*!<Bit 3 */
N#define  FMC_BTR1_ADDHLD                    0x000000F0U        /*!<ADDHLD[3:0] bits (Address-hold phase duration)  */
N#define  FMC_BTR1_ADDHLD_0                  0x00000010U        /*!<Bit 0 */
N#define  FMC_BTR1_ADDHLD_1                  0x00000020U        /*!<Bit 1 */
N#define  FMC_BTR1_ADDHLD_2                  0x00000040U        /*!<Bit 2 */
N#define  FMC_BTR1_ADDHLD_3                  0x00000080U        /*!<Bit 3 */
N#define  FMC_BTR1_DATAST                    0x0000FF00U        /*!<DATAST [3:0] bits (Data-phase duration) */
N#define  FMC_BTR1_DATAST_0                  0x00000100U        /*!<Bit 0 */
N#define  FMC_BTR1_DATAST_1                  0x00000200U        /*!<Bit 1 */
N#define  FMC_BTR1_DATAST_2                  0x00000400U        /*!<Bit 2 */
N#define  FMC_BTR1_DATAST_3                  0x00000800U        /*!<Bit 3 */
N#define  FMC_BTR1_DATAST_4                  0x00001000U        /*!<Bit 4 */
N#define  FMC_BTR1_DATAST_5                  0x00002000U        /*!<Bit 5 */
N#define  FMC_BTR1_DATAST_6                  0x00004000U        /*!<Bit 6 */
N#define  FMC_BTR1_DATAST_7                  0x00008000U        /*!<Bit 7 */
N#define  FMC_BTR1_BUSTURN                   0x000F0000U        /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
N#define  FMC_BTR1_BUSTURN_0                 0x00010000U        /*!<Bit 0 */
N#define  FMC_BTR1_BUSTURN_1                 0x00020000U        /*!<Bit 1 */
N#define  FMC_BTR1_BUSTURN_2                 0x00040000U        /*!<Bit 2 */
N#define  FMC_BTR1_BUSTURN_3                 0x00080000U        /*!<Bit 3 */
N#define  FMC_BTR1_CLKDIV                    0x00F00000U        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
N#define  FMC_BTR1_CLKDIV_0                  0x00100000U        /*!<Bit 0 */
N#define  FMC_BTR1_CLKDIV_1                  0x00200000U        /*!<Bit 1 */
N#define  FMC_BTR1_CLKDIV_2                  0x00400000U        /*!<Bit 2 */
N#define  FMC_BTR1_CLKDIV_3                  0x00800000U        /*!<Bit 3 */
N#define  FMC_BTR1_DATLAT                    0x0F000000U        /*!<DATLA[3:0] bits (Data latency) */
N#define  FMC_BTR1_DATLAT_0                  0x01000000U        /*!<Bit 0 */
N#define  FMC_BTR1_DATLAT_1                  0x02000000U        /*!<Bit 1 */
N#define  FMC_BTR1_DATLAT_2                  0x04000000U        /*!<Bit 2 */
N#define  FMC_BTR1_DATLAT_3                  0x08000000U        /*!<Bit 3 */
N#define  FMC_BTR1_ACCMOD                    0x30000000U        /*!<ACCMOD[1:0] bits (Access mode) */
N#define  FMC_BTR1_ACCMOD_0                  0x10000000U        /*!<Bit 0 */
N#define  FMC_BTR1_ACCMOD_1                  0x20000000U        /*!<Bit 1 */
N
N/******************  Bit definition for FMC_BTR2 register  *******************/
N#define  FMC_BTR2_ADDSET                    0x0000000FU        /*!<ADDSET[3:0] bits (Address setup phase duration) */
N#define  FMC_BTR2_ADDSET_0                  0x00000001U        /*!<Bit 0 */
N#define  FMC_BTR2_ADDSET_1                  0x00000002U        /*!<Bit 1 */
N#define  FMC_BTR2_ADDSET_2                  0x00000004U        /*!<Bit 2 */
N#define  FMC_BTR2_ADDSET_3                  0x00000008U        /*!<Bit 3 */
N#define  FMC_BTR2_ADDHLD                    0x000000F0U        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
N#define  FMC_BTR2_ADDHLD_0                  0x00000010U        /*!<Bit 0 */
N#define  FMC_BTR2_ADDHLD_1                  0x00000020U        /*!<Bit 1 */
N#define  FMC_BTR2_ADDHLD_2                  0x00000040U        /*!<Bit 2 */
N#define  FMC_BTR2_ADDHLD_3                  0x00000080U        /*!<Bit 3 */
N#define  FMC_BTR2_DATAST                    0x0000FF00U        /*!<DATAST [3:0] bits (Data-phase duration) */
N#define  FMC_BTR2_DATAST_0                  0x00000100U        /*!<Bit 0 */
N#define  FMC_BTR2_DATAST_1                  0x00000200U        /*!<Bit 1 */
N#define  FMC_BTR2_DATAST_2                  0x00000400U        /*!<Bit 2 */
N#define  FMC_BTR2_DATAST_3                  0x00000800U        /*!<Bit 3 */
N#define  FMC_BTR2_DATAST_4                  0x00001000U        /*!<Bit 4 */
N#define  FMC_BTR2_DATAST_5                  0x00002000U        /*!<Bit 5 */
N#define  FMC_BTR2_DATAST_6                  0x00004000U        /*!<Bit 6 */
N#define  FMC_BTR2_DATAST_7                  0x00008000U        /*!<Bit 7 */
N#define  FMC_BTR2_BUSTURN                   0x000F0000U        /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
N#define  FMC_BTR2_BUSTURN_0                 0x00010000U        /*!<Bit 0 */
N#define  FMC_BTR2_BUSTURN_1                 0x00020000U        /*!<Bit 1 */
N#define  FMC_BTR2_BUSTURN_2                 0x00040000U        /*!<Bit 2 */
N#define  FMC_BTR2_BUSTURN_3                 0x00080000U        /*!<Bit 3 */
N#define  FMC_BTR2_CLKDIV                    0x00F00000U        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
N#define  FMC_BTR2_CLKDIV_0                  0x00100000U        /*!<Bit 0 */
N#define  FMC_BTR2_CLKDIV_1                  0x00200000U        /*!<Bit 1 */
N#define  FMC_BTR2_CLKDIV_2                  0x00400000U        /*!<Bit 2 */
N#define  FMC_BTR2_CLKDIV_3                  0x00800000U        /*!<Bit 3 */
N#define  FMC_BTR2_DATLAT                    0x0F000000U        /*!<DATLA[3:0] bits (Data latency) */
N#define  FMC_BTR2_DATLAT_0                  0x01000000U        /*!<Bit 0 */
N#define  FMC_BTR2_DATLAT_1                  0x02000000U        /*!<Bit 1 */
N#define  FMC_BTR2_DATLAT_2                  0x04000000U        /*!<Bit 2 */
N#define  FMC_BTR2_DATLAT_3                  0x08000000U        /*!<Bit 3 */
N#define  FMC_BTR2_ACCMOD                    0x30000000U        /*!<ACCMOD[1:0] bits (Access mode) */
N#define  FMC_BTR2_ACCMOD_0                  0x10000000U        /*!<Bit 0 */
N#define  FMC_BTR2_ACCMOD_1                  0x20000000U        /*!<Bit 1 */
N
N/*******************  Bit definition for FMC_BTR3 register  *******************/
N#define  FMC_BTR3_ADDSET                    0x0000000FU        /*!<ADDSET[3:0] bits (Address setup phase duration) */
N#define  FMC_BTR3_ADDSET_0                  0x00000001U        /*!<Bit 0 */
N#define  FMC_BTR3_ADDSET_1                  0x00000002U        /*!<Bit 1 */
N#define  FMC_BTR3_ADDSET_2                  0x00000004U        /*!<Bit 2 */
N#define  FMC_BTR3_ADDSET_3                  0x00000008U        /*!<Bit 3 */
N#define  FMC_BTR3_ADDHLD                    0x000000F0U        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
N#define  FMC_BTR3_ADDHLD_0                  0x00000010U        /*!<Bit 0 */
N#define  FMC_BTR3_ADDHLD_1                  0x00000020U        /*!<Bit 1 */
N#define  FMC_BTR3_ADDHLD_2                  0x00000040U        /*!<Bit 2 */
N#define  FMC_BTR3_ADDHLD_3                  0x00000080U        /*!<Bit 3 */
N#define  FMC_BTR3_DATAST                    0x0000FF00U        /*!<DATAST [3:0] bits (Data-phase duration) */
N#define  FMC_BTR3_DATAST_0                  0x00000100U        /*!<Bit 0 */
N#define  FMC_BTR3_DATAST_1                  0x00000200U        /*!<Bit 1 */
N#define  FMC_BTR3_DATAST_2                  0x00000400U        /*!<Bit 2 */
N#define  FMC_BTR3_DATAST_3                  0x00000800U        /*!<Bit 3 */
N#define  FMC_BTR3_DATAST_4                  0x00001000U        /*!<Bit 4 */
N#define  FMC_BTR3_DATAST_5                  0x00002000U        /*!<Bit 5 */
N#define  FMC_BTR3_DATAST_6                  0x00004000U        /*!<Bit 6 */
N#define  FMC_BTR3_DATAST_7                  0x00008000U        /*!<Bit 7 */
N#define  FMC_BTR3_BUSTURN                   0x000F0000U        /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
N#define  FMC_BTR3_BUSTURN_0                 0x00010000U        /*!<Bit 0 */
N#define  FMC_BTR3_BUSTURN_1                 0x00020000U        /*!<Bit 1 */
N#define  FMC_BTR3_BUSTURN_2                 0x00040000U        /*!<Bit 2 */
N#define  FMC_BTR3_BUSTURN_3                 0x00080000U        /*!<Bit 3 */
N#define  FMC_BTR3_CLKDIV                    0x00F00000U        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
N#define  FMC_BTR3_CLKDIV_0                  0x00100000U        /*!<Bit 0 */
N#define  FMC_BTR3_CLKDIV_1                  0x00200000U        /*!<Bit 1 */
N#define  FMC_BTR3_CLKDIV_2                  0x00400000U        /*!<Bit 2 */
N#define  FMC_BTR3_CLKDIV_3                  0x00800000U        /*!<Bit 3 */
N#define  FMC_BTR3_DATLAT                    0x0F000000U        /*!<DATLA[3:0] bits (Data latency) */
N#define  FMC_BTR3_DATLAT_0                  0x01000000U        /*!<Bit 0 */
N#define  FMC_BTR3_DATLAT_1                  0x02000000U        /*!<Bit 1 */
N#define  FMC_BTR3_DATLAT_2                  0x04000000U        /*!<Bit 2 */
N#define  FMC_BTR3_DATLAT_3                  0x08000000U        /*!<Bit 3 */
N#define  FMC_BTR3_ACCMOD                    0x30000000U        /*!<ACCMOD[1:0] bits (Access mode) */
N#define  FMC_BTR3_ACCMOD_0                  0x10000000U        /*!<Bit 0 */
N#define  FMC_BTR3_ACCMOD_1                  0x20000000U        /*!<Bit 1 */
N
N/******************  Bit definition for FMC_BTR4 register  *******************/
N#define  FMC_BTR4_ADDSET                    0x0000000FU        /*!<ADDSET[3:0] bits (Address setup phase duration) */
N#define  FMC_BTR4_ADDSET_0                  0x00000001U        /*!<Bit 0 */
N#define  FMC_BTR4_ADDSET_1                  0x00000002U        /*!<Bit 1 */
N#define  FMC_BTR4_ADDSET_2                  0x00000004U        /*!<Bit 2 */
N#define  FMC_BTR4_ADDSET_3                  0x00000008U        /*!<Bit 3 */
N#define  FMC_BTR4_ADDHLD                    0x000000F0U        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
N#define  FMC_BTR4_ADDHLD_0                  0x00000010U        /*!<Bit 0 */
N#define  FMC_BTR4_ADDHLD_1                  0x00000020U        /*!<Bit 1 */
N#define  FMC_BTR4_ADDHLD_2                  0x00000040U        /*!<Bit 2 */
N#define  FMC_BTR4_ADDHLD_3                  0x00000080U        /*!<Bit 3 */
N#define  FMC_BTR4_DATAST                    0x0000FF00U        /*!<DATAST [3:0] bits (Data-phase duration) */
N#define  FMC_BTR4_DATAST_0                  0x00000100U        /*!<Bit 0 */
N#define  FMC_BTR4_DATAST_1                  0x00000200U        /*!<Bit 1 */
N#define  FMC_BTR4_DATAST_2                  0x00000400U        /*!<Bit 2 */
N#define  FMC_BTR4_DATAST_3                  0x00000800U        /*!<Bit 3 */
N#define  FMC_BTR4_DATAST_4                  0x00001000U        /*!<Bit 4 */
N#define  FMC_BTR4_DATAST_5                  0x00002000U        /*!<Bit 5 */
N#define  FMC_BTR4_DATAST_6                  0x00004000U        /*!<Bit 6 */
N#define  FMC_BTR4_DATAST_7                  0x00008000U        /*!<Bit 7 */
N#define  FMC_BTR4_BUSTURN                   0x000F0000U        /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
N#define  FMC_BTR4_BUSTURN_0                 0x00010000U        /*!<Bit 0 */
N#define  FMC_BTR4_BUSTURN_1                 0x00020000U        /*!<Bit 1 */
N#define  FMC_BTR4_BUSTURN_2                 0x00040000U        /*!<Bit 2 */
N#define  FMC_BTR4_BUSTURN_3                 0x00080000U        /*!<Bit 3 */
N#define  FMC_BTR4_CLKDIV                    0x00F00000U        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
N#define  FMC_BTR4_CLKDIV_0                  0x00100000U        /*!<Bit 0 */
N#define  FMC_BTR4_CLKDIV_1                  0x00200000U        /*!<Bit 1 */
N#define  FMC_BTR4_CLKDIV_2                  0x00400000U        /*!<Bit 2 */
N#define  FMC_BTR4_CLKDIV_3                  0x00800000U        /*!<Bit 3 */
N#define  FMC_BTR4_DATLAT                    0x0F000000U        /*!<DATLA[3:0] bits (Data latency) */
N#define  FMC_BTR4_DATLAT_0                  0x01000000U        /*!<Bit 0 */
N#define  FMC_BTR4_DATLAT_1                  0x02000000U        /*!<Bit 1 */
N#define  FMC_BTR4_DATLAT_2                  0x04000000U        /*!<Bit 2 */
N#define  FMC_BTR4_DATLAT_3                  0x08000000U        /*!<Bit 3 */
N#define  FMC_BTR4_ACCMOD                    0x30000000U        /*!<ACCMOD[1:0] bits (Access mode) */
N#define  FMC_BTR4_ACCMOD_0                  0x10000000U        /*!<Bit 0 */
N#define  FMC_BTR4_ACCMOD_1                  0x20000000U        /*!<Bit 1 */
N
N/******************  Bit definition for FMC_BWTR1 register  ******************/
N#define  FMC_BWTR1_ADDSET                   0x0000000FU        /*!<ADDSET[3:0] bits (Address setup phase duration) */
N#define  FMC_BWTR1_ADDSET_0                 0x00000001U        /*!<Bit 0 */
N#define  FMC_BWTR1_ADDSET_1                 0x00000002U        /*!<Bit 1 */
N#define  FMC_BWTR1_ADDSET_2                 0x00000004U        /*!<Bit 2 */
N#define  FMC_BWTR1_ADDSET_3                 0x00000008U        /*!<Bit 3 */
N#define  FMC_BWTR1_ADDHLD                   0x000000F0U        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
N#define  FMC_BWTR1_ADDHLD_0                 0x00000010U        /*!<Bit 0 */
N#define  FMC_BWTR1_ADDHLD_1                 0x00000020U        /*!<Bit 1 */
N#define  FMC_BWTR1_ADDHLD_2                 0x00000040U        /*!<Bit 2 */
N#define  FMC_BWTR1_ADDHLD_3                 0x00000080U        /*!<Bit 3 */
N#define  FMC_BWTR1_DATAST                   0x0000FF00U        /*!<DATAST [3:0] bits (Data-phase duration) */
N#define  FMC_BWTR1_DATAST_0                 0x00000100U        /*!<Bit 0 */
N#define  FMC_BWTR1_DATAST_1                 0x00000200U        /*!<Bit 1 */
N#define  FMC_BWTR1_DATAST_2                 0x00000400U        /*!<Bit 2 */
N#define  FMC_BWTR1_DATAST_3                 0x00000800U        /*!<Bit 3 */
N#define  FMC_BWTR1_DATAST_4                 0x00001000U        /*!<Bit 4 */
N#define  FMC_BWTR1_DATAST_5                 0x00002000U        /*!<Bit 5 */
N#define  FMC_BWTR1_DATAST_6                 0x00004000U        /*!<Bit 6 */
N#define  FMC_BWTR1_DATAST_7                 0x00008000U        /*!<Bit 7 */
N#define  FMC_BWTR1_BUSTURN                  0x000F0000U        /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
N#define  FMC_BWTR1_BUSTURN_0                0x00010000U        /*!<Bit 0 */
N#define  FMC_BWTR1_BUSTURN_1                0x00020000U        /*!<Bit 1 */
N#define  FMC_BWTR1_BUSTURN_2                0x00040000U        /*!<Bit 2 */
N#define  FMC_BWTR1_BUSTURN_3                0x00080000U        /*!<Bit 3 */
N#define  FMC_BWTR1_ACCMOD                   0x30000000U        /*!<ACCMOD[1:0] bits (Access mode) */
N#define  FMC_BWTR1_ACCMOD_0                 0x10000000U        /*!<Bit 0 */
N#define  FMC_BWTR1_ACCMOD_1                 0x20000000U        /*!<Bit 1 */
N
N/******************  Bit definition for FMC_BWTR2 register  ******************/
N#define  FMC_BWTR2_ADDSET                   0x0000000FU        /*!<ADDSET[3:0] bits (Address setup phase duration) */
N#define  FMC_BWTR2_ADDSET_0                 0x00000001U        /*!<Bit 0 */
N#define  FMC_BWTR2_ADDSET_1                 0x00000002U        /*!<Bit 1 */
N#define  FMC_BWTR2_ADDSET_2                 0x00000004U        /*!<Bit 2 */
N#define  FMC_BWTR2_ADDSET_3                 0x00000008U        /*!<Bit 3 */
N#define  FMC_BWTR2_ADDHLD                   0x000000F0U        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
N#define  FMC_BWTR2_ADDHLD_0                 0x00000010U        /*!<Bit 0 */
N#define  FMC_BWTR2_ADDHLD_1                 0x00000020U        /*!<Bit 1 */
N#define  FMC_BWTR2_ADDHLD_2                 0x00000040U        /*!<Bit 2 */
N#define  FMC_BWTR2_ADDHLD_3                 0x00000080U        /*!<Bit 3 */
N#define  FMC_BWTR2_DATAST                   0x0000FF00U        /*!<DATAST [3:0] bits (Data-phase duration) */
N#define  FMC_BWTR2_DATAST_0                 0x00000100U        /*!<Bit 0 */
N#define  FMC_BWTR2_DATAST_1                 0x00000200U        /*!<Bit 1 */
N#define  FMC_BWTR2_DATAST_2                 0x00000400U        /*!<Bit 2 */
N#define  FMC_BWTR2_DATAST_3                 0x00000800U        /*!<Bit 3 */
N#define  FMC_BWTR2_DATAST_4                 0x00001000U        /*!<Bit 4 */
N#define  FMC_BWTR2_DATAST_5                 0x00002000U        /*!<Bit 5 */
N#define  FMC_BWTR2_DATAST_6                 0x00004000U        /*!<Bit 6 */
N#define  FMC_BWTR2_DATAST_7                 0x00008000U        /*!<Bit 7 */
N#define  FMC_BWTR2_BUSTURN                  0x000F0000U        /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
N#define  FMC_BWTR2_BUSTURN_0                0x00010000U        /*!<Bit 0 */
N#define  FMC_BWTR2_BUSTURN_1                0x00020000U        /*!<Bit 1 */
N#define  FMC_BWTR2_BUSTURN_2                0x00040000U        /*!<Bit 2 */
N#define  FMC_BWTR2_BUSTURN_3                0x00080000U        /*!<Bit 3 */
N#define  FMC_BWTR2_ACCMOD                   0x30000000U        /*!<ACCMOD[1:0] bits (Access mode) */
N#define  FMC_BWTR2_ACCMOD_0                 0x10000000U        /*!<Bit 0 */
N#define  FMC_BWTR2_ACCMOD_1                 0x20000000U        /*!<Bit 1 */
N
N/******************  Bit definition for FMC_BWTR3 register  ******************/
N#define  FMC_BWTR3_ADDSET                   0x0000000FU        /*!<ADDSET[3:0] bits (Address setup phase duration) */
N#define  FMC_BWTR3_ADDSET_0                 0x00000001U        /*!<Bit 0 */
N#define  FMC_BWTR3_ADDSET_1                 0x00000002U        /*!<Bit 1 */
N#define  FMC_BWTR3_ADDSET_2                 0x00000004U        /*!<Bit 2 */
N#define  FMC_BWTR3_ADDSET_3                 0x00000008U        /*!<Bit 3 */
N#define  FMC_BWTR3_ADDHLD                   0x000000F0U        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
N#define  FMC_BWTR3_ADDHLD_0                 0x00000010U        /*!<Bit 0 */
N#define  FMC_BWTR3_ADDHLD_1                 0x00000020U        /*!<Bit 1 */
N#define  FMC_BWTR3_ADDHLD_2                 0x00000040U        /*!<Bit 2 */
N#define  FMC_BWTR3_ADDHLD_3                 0x00000080U        /*!<Bit 3 */
N#define  FMC_BWTR3_DATAST                   0x0000FF00U        /*!<DATAST [3:0] bits (Data-phase duration) */
N#define  FMC_BWTR3_DATAST_0                 0x00000100U        /*!<Bit 0 */
N#define  FMC_BWTR3_DATAST_1                 0x00000200U        /*!<Bit 1 */
N#define  FMC_BWTR3_DATAST_2                 0x00000400U        /*!<Bit 2 */
N#define  FMC_BWTR3_DATAST_3                 0x00000800U        /*!<Bit 3 */
N#define  FMC_BWTR3_DATAST_4                 0x00001000U        /*!<Bit 4 */
N#define  FMC_BWTR3_DATAST_5                 0x00002000U        /*!<Bit 5 */
N#define  FMC_BWTR3_DATAST_6                 0x00004000U        /*!<Bit 6 */
N#define  FMC_BWTR3_DATAST_7                 0x00008000U        /*!<Bit 7 */
N#define  FMC_BWTR3_BUSTURN                  0x000F0000U        /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
N#define  FMC_BWTR3_BUSTURN_0                0x00010000U        /*!<Bit 0 */
N#define  FMC_BWTR3_BUSTURN_1                0x00020000U        /*!<Bit 1 */
N#define  FMC_BWTR3_BUSTURN_2                0x00040000U        /*!<Bit 2 */
N#define  FMC_BWTR3_BUSTURN_3                0x00080000U        /*!<Bit 3 */
N#define  FMC_BWTR3_ACCMOD                   0x30000000U        /*!<ACCMOD[1:0] bits (Access mode) */
N#define  FMC_BWTR3_ACCMOD_0                 0x10000000U        /*!<Bit 0 */
N#define  FMC_BWTR3_ACCMOD_1                 0x20000000U        /*!<Bit 1 */
N
N/******************  Bit definition for FMC_BWTR4 register  ******************/
N#define  FMC_BWTR4_ADDSET                   0x0000000FU        /*!<ADDSET[3:0] bits (Address setup phase duration) */
N#define  FMC_BWTR4_ADDSET_0                 0x00000001U        /*!<Bit 0 */
N#define  FMC_BWTR4_ADDSET_1                 0x00000002U        /*!<Bit 1 */
N#define  FMC_BWTR4_ADDSET_2                 0x00000004U        /*!<Bit 2 */
N#define  FMC_BWTR4_ADDSET_3                 0x00000008U        /*!<Bit 3 */
N#define  FMC_BWTR4_ADDHLD                   0x000000F0U        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
N#define  FMC_BWTR4_ADDHLD_0                 0x00000010U        /*!<Bit 0 */
N#define  FMC_BWTR4_ADDHLD_1                 0x00000020U        /*!<Bit 1 */
N#define  FMC_BWTR4_ADDHLD_2                 0x00000040U        /*!<Bit 2 */
N#define  FMC_BWTR4_ADDHLD_3                 0x00000080U        /*!<Bit 3 */
N#define  FMC_BWTR4_DATAST                   0x0000FF00U        /*!<DATAST [3:0] bits (Data-phase duration) */
N#define  FMC_BWTR4_DATAST_0                 0x00000100U        /*!<Bit 0 */
N#define  FMC_BWTR4_DATAST_1                 0x00000200U        /*!<Bit 1 */
N#define  FMC_BWTR4_DATAST_2                 0x00000400U        /*!<Bit 2 */
N#define  FMC_BWTR4_DATAST_3                 0x00000800U        /*!<Bit 3 */
N#define  FMC_BWTR4_DATAST_4                 0x00001000U        /*!<Bit 4 */
N#define  FMC_BWTR4_DATAST_5                 0x00002000U        /*!<Bit 5 */
N#define  FMC_BWTR4_DATAST_6                 0x00004000U        /*!<Bit 6 */
N#define  FMC_BWTR4_DATAST_7                 0x00008000U        /*!<Bit 7 */
N#define  FMC_BWTR4_BUSTURN                  0x000F0000U        /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
N#define  FMC_BWTR4_BUSTURN_0                0x00010000U        /*!<Bit 0 */
N#define  FMC_BWTR4_BUSTURN_1                0x00020000U        /*!<Bit 1 */
N#define  FMC_BWTR4_BUSTURN_2                0x00040000U        /*!<Bit 2 */
N#define  FMC_BWTR4_BUSTURN_3                0x00080000U        /*!<Bit 3 */
N#define  FMC_BWTR4_ACCMOD                   0x30000000U        /*!<ACCMOD[1:0] bits (Access mode) */
N#define  FMC_BWTR4_ACCMOD_0                 0x10000000U        /*!<Bit 0 */
N#define  FMC_BWTR4_ACCMOD_1                 0x20000000U        /*!<Bit 1 */
N
N/******************  Bit definition for FMC_PCR register  *******************/
N#define  FMC_PCR_PWAITEN                   0x00000002U        /*!<Wait feature enable bit                   */
N#define  FMC_PCR_PBKEN                     0x00000004U        /*!<PC Card/NAND Flash memory bank enable bit */
N#define  FMC_PCR_PTYP                      0x00000008U        /*!<Memory type                               */
N#define  FMC_PCR_PWID                      0x00000030U        /*!<PWID[1:0] bits (NAND Flash databus width) */
N#define  FMC_PCR_PWID_0                    0x00000010U        /*!<Bit 0 */
N#define  FMC_PCR_PWID_1                    0x00000020U        /*!<Bit 1 */
N#define  FMC_PCR_ECCEN                     0x00000040U        /*!<ECC computation logic enable bit          */
N#define  FMC_PCR_TCLR                      0x00001E00U        /*!<TCLR[3:0] bits (CLE to RE delay)          */
N#define  FMC_PCR_TCLR_0                    0x00000200U        /*!<Bit 0 */
N#define  FMC_PCR_TCLR_1                    0x00000400U        /*!<Bit 1 */
N#define  FMC_PCR_TCLR_2                    0x00000800U        /*!<Bit 2 */
N#define  FMC_PCR_TCLR_3                    0x00001000U        /*!<Bit 3 */
N#define  FMC_PCR_TAR                       0x0001E000U        /*!<TAR[3:0] bits (ALE to RE delay)           */
N#define  FMC_PCR_TAR_0                     0x00002000U        /*!<Bit 0 */
N#define  FMC_PCR_TAR_1                     0x00004000U        /*!<Bit 1 */
N#define  FMC_PCR_TAR_2                     0x00008000U        /*!<Bit 2 */
N#define  FMC_PCR_TAR_3                     0x00010000U        /*!<Bit 3 */
N#define  FMC_PCR_ECCPS                     0x000E0000U        /*!<ECCPS[2:0] bits (ECC page size)           */
N#define  FMC_PCR_ECCPS_0                   0x00020000U        /*!<Bit 0 */
N#define  FMC_PCR_ECCPS_1                   0x00040000U        /*!<Bit 1 */
N#define  FMC_PCR_ECCPS_2                   0x00080000U        /*!<Bit 2 */
N
N/*******************  Bit definition for FMC_SR register  *******************/
N#define  FMC_SR_IRS                        0x01U              /*!<Interrupt Rising Edge status                */
N#define  FMC_SR_ILS                        0x02U              /*!<Interrupt Level status                      */
N#define  FMC_SR_IFS                        0x04U              /*!<Interrupt Falling Edge status               */
N#define  FMC_SR_IREN                       0x08U              /*!<Interrupt Rising Edge detection Enable bit  */
N#define  FMC_SR_ILEN                       0x10U              /*!<Interrupt Level detection Enable bit        */
N#define  FMC_SR_IFEN                       0x20U              /*!<Interrupt Falling Edge detection Enable bit */
N#define  FMC_SR_FEMPT                      0x40U              /*!<FIFO empty                                  */
N
N/******************  Bit definition for FMC_PMEM register  ******************/
N#define  FMC_PMEM_MEMSET3                  0x000000FFU        /*!<MEMSET3[7:0] bits (Common memory 3 setup time) */
N#define  FMC_PMEM_MEMSET3_0                0x00000001U        /*!<Bit 0 */
N#define  FMC_PMEM_MEMSET3_1                0x00000002U        /*!<Bit 1 */
N#define  FMC_PMEM_MEMSET3_2                0x00000004U        /*!<Bit 2 */
N#define  FMC_PMEM_MEMSET3_3                0x00000008U        /*!<Bit 3 */
N#define  FMC_PMEM_MEMSET3_4                0x00000010U        /*!<Bit 4 */
N#define  FMC_PMEM_MEMSET3_5                0x00000020U        /*!<Bit 5 */
N#define  FMC_PMEM_MEMSET3_6                0x00000040U        /*!<Bit 6 */
N#define  FMC_PMEM_MEMSET3_7                0x00000080U        /*!<Bit 7 */
N#define  FMC_PMEM_MEMWAIT3                 0x0000FF00U        /*!<MEMWAIT3[7:0] bits (Common memory 3 wait time) */
N#define  FMC_PMEM_MEMWAIT3_0               0x00000100U        /*!<Bit 0 */
N#define  FMC_PMEM_MEMWAIT3_1               0x00000200U        /*!<Bit 1 */
N#define  FMC_PMEM_MEMWAIT3_2               0x00000400U        /*!<Bit 2 */
N#define  FMC_PMEM_MEMWAIT3_3               0x00000800U        /*!<Bit 3 */
N#define  FMC_PMEM_MEMWAIT3_4               0x00001000U        /*!<Bit 4 */
N#define  FMC_PMEM_MEMWAIT3_5               0x00002000U        /*!<Bit 5 */
N#define  FMC_PMEM_MEMWAIT3_6               0x00004000U        /*!<Bit 6 */
N#define  FMC_PMEM_MEMWAIT3_7               0x00008000U        /*!<Bit 7 */
N#define  FMC_PMEM_MEMHOLD3                 0x00FF0000U        /*!<MEMHOLD3[7:0] bits (Common memory 3 hold time) */
N#define  FMC_PMEM_MEMHOLD3_0               0x00010000U        /*!<Bit 0 */
N#define  FMC_PMEM_MEMHOLD3_1               0x00020000U        /*!<Bit 1 */
N#define  FMC_PMEM_MEMHOLD3_2               0x00040000U        /*!<Bit 2 */
N#define  FMC_PMEM_MEMHOLD3_3               0x00080000U        /*!<Bit 3 */
N#define  FMC_PMEM_MEMHOLD3_4               0x00100000U        /*!<Bit 4 */
N#define  FMC_PMEM_MEMHOLD3_5               0x00200000U        /*!<Bit 5 */
N#define  FMC_PMEM_MEMHOLD3_6               0x00400000U        /*!<Bit 6 */
N#define  FMC_PMEM_MEMHOLD3_7               0x00800000U        /*!<Bit 7 */
N#define  FMC_PMEM_MEMHIZ3                  0xFF000000U        /*!<MEMHIZ3[7:0] bits (Common memory 3 databus HiZ time) */
N#define  FMC_PMEM_MEMHIZ3_0                0x01000000U        /*!<Bit 0 */
N#define  FMC_PMEM_MEMHIZ3_1                0x02000000U        /*!<Bit 1 */
N#define  FMC_PMEM_MEMHIZ3_2                0x04000000U        /*!<Bit 2 */
N#define  FMC_PMEM_MEMHIZ3_3                0x08000000U        /*!<Bit 3 */
N#define  FMC_PMEM_MEMHIZ3_4                0x10000000U        /*!<Bit 4 */
N#define  FMC_PMEM_MEMHIZ3_5                0x20000000U        /*!<Bit 5 */
N#define  FMC_PMEM_MEMHIZ3_6                0x40000000U        /*!<Bit 6 */
N#define  FMC_PMEM_MEMHIZ3_7                0x80000000U        /*!<Bit 7 */
N
N/******************  Bit definition for FMC_PATT register  ******************/
N#define  FMC_PATT_ATTSET3                  0x000000FFU        /*!<ATTSET3[7:0] bits (Attribute memory 3 setup time) */
N#define  FMC_PATT_ATTSET3_0                0x00000001U        /*!<Bit 0 */
N#define  FMC_PATT_ATTSET3_1                0x00000002U        /*!<Bit 1 */
N#define  FMC_PATT_ATTSET3_2                0x00000004U        /*!<Bit 2 */
N#define  FMC_PATT_ATTSET3_3                0x00000008U        /*!<Bit 3 */
N#define  FMC_PATT_ATTSET3_4                0x00000010U        /*!<Bit 4 */
N#define  FMC_PATT_ATTSET3_5                0x00000020U        /*!<Bit 5 */
N#define  FMC_PATT_ATTSET3_6                0x00000040U        /*!<Bit 6 */
N#define  FMC_PATT_ATTSET3_7                0x00000080U        /*!<Bit 7 */
N#define  FMC_PATT_ATTWAIT3                 0x0000FF00U        /*!<ATTWAIT3[7:0] bits (Attribute memory 3 wait time) */
N#define  FMC_PATT_ATTWAIT3_0               0x00000100U        /*!<Bit 0 */
N#define  FMC_PATT_ATTWAIT3_1               0x00000200U        /*!<Bit 1 */
N#define  FMC_PATT_ATTWAIT3_2               0x00000400U        /*!<Bit 2 */
N#define  FMC_PATT_ATTWAIT3_3               0x00000800U        /*!<Bit 3 */
N#define  FMC_PATT_ATTWAIT3_4               0x00001000U        /*!<Bit 4 */
N#define  FMC_PATT_ATTWAIT3_5               0x00002000U        /*!<Bit 5 */
N#define  FMC_PATT_ATTWAIT3_6               0x00004000U        /*!<Bit 6 */
N#define  FMC_PATT_ATTWAIT3_7               0x00008000U        /*!<Bit 7 */
N#define  FMC_PATT_ATTHOLD3                 0x00FF0000U        /*!<ATTHOLD3[7:0] bits (Attribute memory 3 hold time) */
N#define  FMC_PATT_ATTHOLD3_0               0x00010000U        /*!<Bit 0 */
N#define  FMC_PATT_ATTHOLD3_1               0x00020000U        /*!<Bit 1 */
N#define  FMC_PATT_ATTHOLD3_2               0x00040000U        /*!<Bit 2 */
N#define  FMC_PATT_ATTHOLD3_3               0x00080000U        /*!<Bit 3 */
N#define  FMC_PATT_ATTHOLD3_4               0x00100000U        /*!<Bit 4 */
N#define  FMC_PATT_ATTHOLD3_5               0x00200000U        /*!<Bit 5 */
N#define  FMC_PATT_ATTHOLD3_6               0x00400000U        /*!<Bit 6 */
N#define  FMC_PATT_ATTHOLD3_7               0x00800000U        /*!<Bit 7 */
N#define  FMC_PATT_ATTHIZ3                  0xFF000000U        /*!<ATTHIZ3[7:0] bits (Attribute memory 3 databus HiZ time) */
N#define  FMC_PATT_ATTHIZ3_0                0x01000000U        /*!<Bit 0 */
N#define  FMC_PATT_ATTHIZ3_1                0x02000000U        /*!<Bit 1 */
N#define  FMC_PATT_ATTHIZ3_2                0x04000000U        /*!<Bit 2 */
N#define  FMC_PATT_ATTHIZ3_3                0x08000000U        /*!<Bit 3 */
N#define  FMC_PATT_ATTHIZ3_4                0x10000000U        /*!<Bit 4 */
N#define  FMC_PATT_ATTHIZ3_5                0x20000000U        /*!<Bit 5 */
N#define  FMC_PATT_ATTHIZ3_6                0x40000000U        /*!<Bit 6 */
N#define  FMC_PATT_ATTHIZ3_7                0x80000000U        /*!<Bit 7 */
N
N/******************  Bit definition for FMC_ECCR register  ******************/
N#define  FMC_ECCR_ECC3                     0xFFFFFFFFU        /*!<ECC result */
N
N/******************  Bit definition for FMC_SDCR1 register  ******************/
N#define  FMC_SDCR1_NC                       0x00000003U        /*!<NC[1:0] bits (Number of column bits) */
N#define  FMC_SDCR1_NC_0                     0x00000001U        /*!<Bit 0 */
N#define  FMC_SDCR1_NC_1                     0x00000002U        /*!<Bit 1 */
N#define  FMC_SDCR1_NR                       0x0000000CU        /*!<NR[1:0] bits (Number of row bits) */
N#define  FMC_SDCR1_NR_0                     0x00000004U        /*!<Bit 0 */
N#define  FMC_SDCR1_NR_1                     0x00000008U        /*!<Bit 1 */
N#define  FMC_SDCR1_MWID                     0x00000030U        /*!<NR[1:0] bits (Number of row bits) */
N#define  FMC_SDCR1_MWID_0                   0x00000010U        /*!<Bit 0 */
N#define  FMC_SDCR1_MWID_1                   0x00000020U        /*!<Bit 1 */
N#define  FMC_SDCR1_NB                       0x00000040U        /*!<Number of internal bank */
N#define  FMC_SDCR1_CAS                      0x00000180U        /*!<CAS[1:0] bits (CAS latency) */
N#define  FMC_SDCR1_CAS_0                    0x00000080U        /*!<Bit 0 */
N#define  FMC_SDCR1_CAS_1                    0x00000100U        /*!<Bit 1 */
N#define  FMC_SDCR1_WP                       0x00000200U        /*!<Write protection */
N#define  FMC_SDCR1_SDCLK                    0x00000C00U        /*!<SDRAM clock configuration */
N#define  FMC_SDCR1_SDCLK_0                  0x00000400U        /*!<Bit 0 */
N#define  FMC_SDCR1_SDCLK_1                  0x00000800U        /*!<Bit 1 */
N#define  FMC_SDCR1_RBURST                   0x00001000U        /*!<Read burst */
N#define  FMC_SDCR1_RPIPE                    0x00006000U        /*!<Write protection */
N#define  FMC_SDCR1_RPIPE_0                  0x00002000U        /*!<Bit 0 */
N#define  FMC_SDCR1_RPIPE_1                  0x00004000U        /*!<Bit 1 */
N
N/******************  Bit definition for FMC_SDCR2 register  ******************/
N#define  FMC_SDCR2_NC                       0x00000003U        /*!<NC[1:0] bits (Number of column bits) */
N#define  FMC_SDCR2_NC_0                     0x00000001U        /*!<Bit 0 */
N#define  FMC_SDCR2_NC_1                     0x00000002U        /*!<Bit 1 */
N#define  FMC_SDCR2_NR                       0x0000000CU        /*!<NR[1:0] bits (Number of row bits) */
N#define  FMC_SDCR2_NR_0                     0x00000004U        /*!<Bit 0 */
N#define  FMC_SDCR2_NR_1                     0x00000008U        /*!<Bit 1 */
N#define  FMC_SDCR2_MWID                     0x00000030U        /*!<NR[1:0] bits (Number of row bits) */
N#define  FMC_SDCR2_MWID_0                   0x00000010U        /*!<Bit 0 */
N#define  FMC_SDCR2_MWID_1                   0x00000020U        /*!<Bit 1 */
N#define  FMC_SDCR2_NB                       0x00000040U        /*!<Number of internal bank */
N#define  FMC_SDCR2_CAS                      0x00000180U        /*!<CAS[1:0] bits (CAS latency) */
N#define  FMC_SDCR2_CAS_0                    0x00000080U        /*!<Bit 0 */
N#define  FMC_SDCR2_CAS_1                    0x00000100U        /*!<Bit 1 */
N#define  FMC_SDCR2_WP                       0x00000200U        /*!<Write protection */
N#define  FMC_SDCR2_SDCLK                    0x00000C00U        /*!<SDCLK[1:0] (SDRAM clock configuration) */
N#define  FMC_SDCR2_SDCLK_0                  0x00000400U        /*!<Bit 0 */
N#define  FMC_SDCR2_SDCLK_1                  0x00000800U        /*!<Bit 1 */
N#define  FMC_SDCR2_RBURST                   0x00001000U        /*!<Read burst */
N#define  FMC_SDCR2_RPIPE                    0x00006000U        /*!<RPIPE[1:0](Read pipe) */
N#define  FMC_SDCR2_RPIPE_0                  0x00002000U        /*!<Bit 0 */
N#define  FMC_SDCR2_RPIPE_1                  0x00004000U        /*!<Bit 1 */
N
N/******************  Bit definition for FMC_SDTR1 register  ******************/
N#define  FMC_SDTR1_TMRD                     0x0000000FU        /*!<TMRD[3:0] bits (Load mode register to active) */
N#define  FMC_SDTR1_TMRD_0                   0x00000001U        /*!<Bit 0 */
N#define  FMC_SDTR1_TMRD_1                   0x00000002U        /*!<Bit 1 */
N#define  FMC_SDTR1_TMRD_2                   0x00000004U        /*!<Bit 2 */
N#define  FMC_SDTR1_TMRD_3                   0x00000008U        /*!<Bit 3 */
N#define  FMC_SDTR1_TXSR                     0x000000F0U        /*!<TXSR[3:0] bits (Exit self refresh) */
N#define  FMC_SDTR1_TXSR_0                   0x00000010U        /*!<Bit 0 */
N#define  FMC_SDTR1_TXSR_1                   0x00000020U        /*!<Bit 1 */
N#define  FMC_SDTR1_TXSR_2                   0x00000040U        /*!<Bit 2 */
N#define  FMC_SDTR1_TXSR_3                   0x00000080U        /*!<Bit 3 */
N#define  FMC_SDTR1_TRAS                     0x00000F00U        /*!<TRAS[3:0] bits (Self refresh time) */
N#define  FMC_SDTR1_TRAS_0                   0x00000100U        /*!<Bit 0 */
N#define  FMC_SDTR1_TRAS_1                   0x00000200U        /*!<Bit 1 */
N#define  FMC_SDTR1_TRAS_2                   0x00000400U        /*!<Bit 2 */
N#define  FMC_SDTR1_TRAS_3                   0x00000800U        /*!<Bit 3 */
N#define  FMC_SDTR1_TRC                      0x0000F000U        /*!<TRC[2:0] bits (Row cycle delay) */
N#define  FMC_SDTR1_TRC_0                    0x00001000U        /*!<Bit 0 */
N#define  FMC_SDTR1_TRC_1                    0x00002000U        /*!<Bit 1 */
N#define  FMC_SDTR1_TRC_2                    0x00004000U        /*!<Bit 2 */
N#define  FMC_SDTR1_TWR                      0x000F0000U        /*!<TRC[2:0] bits (Write recovery delay) */
N#define  FMC_SDTR1_TWR_0                    0x00010000U        /*!<Bit 0 */
N#define  FMC_SDTR1_TWR_1                    0x00020000U        /*!<Bit 1 */
N#define  FMC_SDTR1_TWR_2                    0x00040000U        /*!<Bit 2 */
N#define  FMC_SDTR1_TRP                      0x00F00000U        /*!<TRP[2:0] bits (Row precharge delay) */
N#define  FMC_SDTR1_TRP_0                    0x00100000U        /*!<Bit 0 */
N#define  FMC_SDTR1_TRP_1                    0x00200000U        /*!<Bit 1 */
N#define  FMC_SDTR1_TRP_2                    0x00400000U        /*!<Bit 2 */
N#define  FMC_SDTR1_TRCD                     0x0F000000U        /*!<TRP[2:0] bits (Row to column delay) */
N#define  FMC_SDTR1_TRCD_0                   0x01000000U        /*!<Bit 0 */
N#define  FMC_SDTR1_TRCD_1                   0x02000000U        /*!<Bit 1 */
N#define  FMC_SDTR1_TRCD_2                   0x04000000U        /*!<Bit 2 */
N
N/******************  Bit definition for FMC_SDTR2 register  ******************/
N#define  FMC_SDTR2_TMRD                     0x0000000FU        /*!<TMRD[3:0] bits (Load mode register to active) */
N#define  FMC_SDTR2_TMRD_0                   0x00000001U        /*!<Bit 0 */
N#define  FMC_SDTR2_TMRD_1                   0x00000002U        /*!<Bit 1 */
N#define  FMC_SDTR2_TMRD_2                   0x00000004U        /*!<Bit 2 */
N#define  FMC_SDTR2_TMRD_3                   0x00000008U        /*!<Bit 3 */
N#define  FMC_SDTR2_TXSR                     0x000000F0U        /*!<TXSR[3:0] bits (Exit self refresh) */
N#define  FMC_SDTR2_TXSR_0                   0x00000010U        /*!<Bit 0 */
N#define  FMC_SDTR2_TXSR_1                   0x00000020U        /*!<Bit 1 */
N#define  FMC_SDTR2_TXSR_2                   0x00000040U        /*!<Bit 2 */
N#define  FMC_SDTR2_TXSR_3                   0x00000080U        /*!<Bit 3 */
N#define  FMC_SDTR2_TRAS                     0x00000F00U        /*!<TRAS[3:0] bits (Self refresh time) */
N#define  FMC_SDTR2_TRAS_0                   0x00000100U        /*!<Bit 0 */
N#define  FMC_SDTR2_TRAS_1                   0x00000200U        /*!<Bit 1 */
N#define  FMC_SDTR2_TRAS_2                   0x00000400U        /*!<Bit 2 */
N#define  FMC_SDTR2_TRAS_3                   0x00000800U        /*!<Bit 3 */
N#define  FMC_SDTR2_TRC                      0x0000F000U        /*!<TRC[2:0] bits (Row cycle delay) */
N#define  FMC_SDTR2_TRC_0                    0x00001000U        /*!<Bit 0 */
N#define  FMC_SDTR2_TRC_1                    0x00002000U        /*!<Bit 1 */
N#define  FMC_SDTR2_TRC_2                    0x00004000U        /*!<Bit 2 */
N#define  FMC_SDTR2_TWR                      0x000F0000U        /*!<TRC[2:0] bits (Write recovery delay) */
N#define  FMC_SDTR2_TWR_0                    0x00010000U        /*!<Bit 0 */
N#define  FMC_SDTR2_TWR_1                    0x00020000U        /*!<Bit 1 */
N#define  FMC_SDTR2_TWR_2                    0x00040000U        /*!<Bit 2 */
N#define  FMC_SDTR2_TRP                      0x00F00000U        /*!<TRP[2:0] bits (Row precharge delay) */
N#define  FMC_SDTR2_TRP_0                    0x00100000U        /*!<Bit 0 */
N#define  FMC_SDTR2_TRP_1                    0x00200000U        /*!<Bit 1 */
N#define  FMC_SDTR2_TRP_2                    0x00400000U        /*!<Bit 2 */
N#define  FMC_SDTR2_TRCD                     0x0F000000U        /*!<TRP[2:0] bits (Row to column delay) */
N#define  FMC_SDTR2_TRCD_0                   0x01000000U        /*!<Bit 0 */
N#define  FMC_SDTR2_TRCD_1                   0x02000000U        /*!<Bit 1 */
N#define  FMC_SDTR2_TRCD_2                   0x04000000U        /*!<Bit 2 */
N
N/******************  Bit definition for FMC_SDCMR register  ******************/
N#define  FMC_SDCMR_MODE                     0x00000007U        /*!<MODE[2:0] bits (Command mode) */
N#define  FMC_SDCMR_MODE_0                   0x00000001U        /*!<Bit 0 */
N#define  FMC_SDCMR_MODE_1                   0x00000002U        /*!<Bit 1 */
N#define  FMC_SDCMR_MODE_2                   0x00000003U        /*!<Bit 2 */
N#define  FMC_SDCMR_CTB2                     0x00000008U        /*!<Command target 2 */
N#define  FMC_SDCMR_CTB1                     0x00000010U        /*!<Command target 1 */
N#define  FMC_SDCMR_NRFS                     0x000001E0U        /*!<NRFS[3:0] bits (Number of auto-refresh) */
N#define  FMC_SDCMR_NRFS_0                   0x00000020U        /*!<Bit 0 */
N#define  FMC_SDCMR_NRFS_1                   0x00000040U        /*!<Bit 1 */
N#define  FMC_SDCMR_NRFS_2                   0x00000080U        /*!<Bit 2 */
N#define  FMC_SDCMR_NRFS_3                   0x00000100U        /*!<Bit 3 */
N#define  FMC_SDCMR_MRD                      0x003FFE00U        /*!<MRD[12:0] bits (Mode register definition) */
N
N/******************  Bit definition for FMC_SDRTR register  ******************/
N#define  FMC_SDRTR_CRE                      0x00000001U        /*!<Clear refresh error flag */
N#define  FMC_SDRTR_COUNT                    0x00003FFEU        /*!<COUNT[12:0] bits (Refresh timer count) */
N#define  FMC_SDRTR_REIE                     0x00004000U        /*!<RES interupt enable */
N
N/******************  Bit definition for FMC_SDSR register  ******************/
N#define  FMC_SDSR_RE                        0x00000001U        /*!<Refresh error flag */
N#define  FMC_SDSR_MODES1                    0x00000006U        /*!<MODES1[1:0]bits (Status mode for bank 1) */
N#define  FMC_SDSR_MODES1_0                  0x00000002U        /*!<Bit 0 */
N#define  FMC_SDSR_MODES1_1                  0x00000004U        /*!<Bit 1 */
N#define  FMC_SDSR_MODES2                    0x00000018U        /*!<MODES2[1:0]bits (Status mode for bank 2) */
N#define  FMC_SDSR_MODES2_0                  0x00000008U        /*!<Bit 0 */
N#define  FMC_SDSR_MODES2_1                  0x00000010U        /*!<Bit 1 */
N#define  FMC_SDSR_BUSY                      0x00000020U        /*!<Busy status */
N
N/******************************************************************************/
N/*                                                                            */
N/*                            General Purpose I/O                             */
N/*                                                                            */
N/******************************************************************************/
N/******************  Bits definition for GPIO_MODER register  *****************/
N#define GPIO_MODER_MODER0                    0x00000003U
N#define GPIO_MODER_MODER0_0                  0x00000001U
N#define GPIO_MODER_MODER0_1                  0x00000002U
N#define GPIO_MODER_MODER1                    0x0000000CU
N#define GPIO_MODER_MODER1_0                  0x00000004U
N#define GPIO_MODER_MODER1_1                  0x00000008U
N#define GPIO_MODER_MODER2                    0x00000030U
N#define GPIO_MODER_MODER2_0                  0x00000010U
N#define GPIO_MODER_MODER2_1                  0x00000020U
N#define GPIO_MODER_MODER3                    0x000000C0U
N#define GPIO_MODER_MODER3_0                  0x00000040U
N#define GPIO_MODER_MODER3_1                  0x00000080U
N#define GPIO_MODER_MODER4                    0x00000300U
N#define GPIO_MODER_MODER4_0                  0x00000100U
N#define GPIO_MODER_MODER4_1                  0x00000200U
N#define GPIO_MODER_MODER5                    0x00000C00U
N#define GPIO_MODER_MODER5_0                  0x00000400U
N#define GPIO_MODER_MODER5_1                  0x00000800U
N#define GPIO_MODER_MODER6                    0x00003000U
N#define GPIO_MODER_MODER6_0                  0x00001000U
N#define GPIO_MODER_MODER6_1                  0x00002000U
N#define GPIO_MODER_MODER7                    0x0000C000U
N#define GPIO_MODER_MODER7_0                  0x00004000U
N#define GPIO_MODER_MODER7_1                  0x00008000U
N#define GPIO_MODER_MODER8                    0x00030000U
N#define GPIO_MODER_MODER8_0                  0x00010000U
N#define GPIO_MODER_MODER8_1                  0x00020000U
N#define GPIO_MODER_MODER9                    0x000C0000U
N#define GPIO_MODER_MODER9_0                  0x00040000U
N#define GPIO_MODER_MODER9_1                  0x00080000U
N#define GPIO_MODER_MODER10                   0x00300000U
N#define GPIO_MODER_MODER10_0                 0x00100000U
N#define GPIO_MODER_MODER10_1                 0x00200000U
N#define GPIO_MODER_MODER11                   0x00C00000U
N#define GPIO_MODER_MODER11_0                 0x00400000U
N#define GPIO_MODER_MODER11_1                 0x00800000U
N#define GPIO_MODER_MODER12                   0x03000000U
N#define GPIO_MODER_MODER12_0                 0x01000000U
N#define GPIO_MODER_MODER12_1                 0x02000000U
N#define GPIO_MODER_MODER13                   0x0C000000U
N#define GPIO_MODER_MODER13_0                 0x04000000U
N#define GPIO_MODER_MODER13_1                 0x08000000U
N#define GPIO_MODER_MODER14                   0x30000000U
N#define GPIO_MODER_MODER14_0                 0x10000000U
N#define GPIO_MODER_MODER14_1                 0x20000000U
N#define GPIO_MODER_MODER15                   0xC0000000U
N#define GPIO_MODER_MODER15_0                 0x40000000U
N#define GPIO_MODER_MODER15_1                 0x80000000U
N
N/******************  Bits definition for GPIO_OTYPER register  ****************/
N#define GPIO_OTYPER_OT_0                     0x00000001U
N#define GPIO_OTYPER_OT_1                     0x00000002U
N#define GPIO_OTYPER_OT_2                     0x00000004U
N#define GPIO_OTYPER_OT_3                     0x00000008U
N#define GPIO_OTYPER_OT_4                     0x00000010U
N#define GPIO_OTYPER_OT_5                     0x00000020U
N#define GPIO_OTYPER_OT_6                     0x00000040U
N#define GPIO_OTYPER_OT_7                     0x00000080U
N#define GPIO_OTYPER_OT_8                     0x00000100U
N#define GPIO_OTYPER_OT_9                     0x00000200U
N#define GPIO_OTYPER_OT_10                    0x00000400U
N#define GPIO_OTYPER_OT_11                    0x00000800U
N#define GPIO_OTYPER_OT_12                    0x00001000U
N#define GPIO_OTYPER_OT_13                    0x00002000U
N#define GPIO_OTYPER_OT_14                    0x00004000U
N#define GPIO_OTYPER_OT_15                    0x00008000U
N
N/******************  Bits definition for GPIO_OSPEEDR register  ***************/
N#define GPIO_OSPEEDER_OSPEEDR0               0x00000003U
N#define GPIO_OSPEEDER_OSPEEDR0_0             0x00000001U
N#define GPIO_OSPEEDER_OSPEEDR0_1             0x00000002U
N#define GPIO_OSPEEDER_OSPEEDR1               0x0000000CU
N#define GPIO_OSPEEDER_OSPEEDR1_0             0x00000004U
N#define GPIO_OSPEEDER_OSPEEDR1_1             0x00000008U
N#define GPIO_OSPEEDER_OSPEEDR2               0x00000030U
N#define GPIO_OSPEEDER_OSPEEDR2_0             0x00000010U
N#define GPIO_OSPEEDER_OSPEEDR2_1             0x00000020U
N#define GPIO_OSPEEDER_OSPEEDR3               0x000000C0U
N#define GPIO_OSPEEDER_OSPEEDR3_0             0x00000040U
N#define GPIO_OSPEEDER_OSPEEDR3_1             0x00000080U
N#define GPIO_OSPEEDER_OSPEEDR4               0x00000300U
N#define GPIO_OSPEEDER_OSPEEDR4_0             0x00000100U
N#define GPIO_OSPEEDER_OSPEEDR4_1             0x00000200U
N#define GPIO_OSPEEDER_OSPEEDR5               0x00000C00U
N#define GPIO_OSPEEDER_OSPEEDR5_0             0x00000400U
N#define GPIO_OSPEEDER_OSPEEDR5_1             0x00000800U
N#define GPIO_OSPEEDER_OSPEEDR6               0x00003000U
N#define GPIO_OSPEEDER_OSPEEDR6_0             0x00001000U
N#define GPIO_OSPEEDER_OSPEEDR6_1             0x00002000U
N#define GPIO_OSPEEDER_OSPEEDR7               0x0000C000U
N#define GPIO_OSPEEDER_OSPEEDR7_0             0x00004000U
N#define GPIO_OSPEEDER_OSPEEDR7_1             0x00008000U
N#define GPIO_OSPEEDER_OSPEEDR8               0x00030000U
N#define GPIO_OSPEEDER_OSPEEDR8_0             0x00010000U
N#define GPIO_OSPEEDER_OSPEEDR8_1             0x00020000U
N#define GPIO_OSPEEDER_OSPEEDR9               0x000C0000U
N#define GPIO_OSPEEDER_OSPEEDR9_0             0x00040000U
N#define GPIO_OSPEEDER_OSPEEDR9_1             0x00080000U
N#define GPIO_OSPEEDER_OSPEEDR10              0x00300000U
N#define GPIO_OSPEEDER_OSPEEDR10_0            0x00100000U
N#define GPIO_OSPEEDER_OSPEEDR10_1            0x00200000U
N#define GPIO_OSPEEDER_OSPEEDR11              0x00C00000U
N#define GPIO_OSPEEDER_OSPEEDR11_0            0x00400000U
N#define GPIO_OSPEEDER_OSPEEDR11_1            0x00800000U
N#define GPIO_OSPEEDER_OSPEEDR12              0x03000000U
N#define GPIO_OSPEEDER_OSPEEDR12_0            0x01000000U
N#define GPIO_OSPEEDER_OSPEEDR12_1            0x02000000U
N#define GPIO_OSPEEDER_OSPEEDR13              0x0C000000U
N#define GPIO_OSPEEDER_OSPEEDR13_0            0x04000000U
N#define GPIO_OSPEEDER_OSPEEDR13_1            0x08000000U
N#define GPIO_OSPEEDER_OSPEEDR14              0x30000000U
N#define GPIO_OSPEEDER_OSPEEDR14_0            0x10000000U
N#define GPIO_OSPEEDER_OSPEEDR14_1            0x20000000U
N#define GPIO_OSPEEDER_OSPEEDR15              0xC0000000U
N#define GPIO_OSPEEDER_OSPEEDR15_0            0x40000000U
N#define GPIO_OSPEEDER_OSPEEDR15_1            0x80000000U
N
N/******************  Bits definition for GPIO_PUPDR register  *****************/
N#define GPIO_PUPDR_PUPDR0                    0x00000003U
N#define GPIO_PUPDR_PUPDR0_0                  0x00000001U
N#define GPIO_PUPDR_PUPDR0_1                  0x00000002U
N#define GPIO_PUPDR_PUPDR1                    0x0000000CU
N#define GPIO_PUPDR_PUPDR1_0                  0x00000004U
N#define GPIO_PUPDR_PUPDR1_1                  0x00000008U
N#define GPIO_PUPDR_PUPDR2                    0x00000030U
N#define GPIO_PUPDR_PUPDR2_0                  0x00000010U
N#define GPIO_PUPDR_PUPDR2_1                  0x00000020U
N#define GPIO_PUPDR_PUPDR3                    0x000000C0U
N#define GPIO_PUPDR_PUPDR3_0                  0x00000040U
N#define GPIO_PUPDR_PUPDR3_1                  0x00000080U
N#define GPIO_PUPDR_PUPDR4                    0x00000300U
N#define GPIO_PUPDR_PUPDR4_0                  0x00000100U
N#define GPIO_PUPDR_PUPDR4_1                  0x00000200U
N#define GPIO_PUPDR_PUPDR5                    0x00000C00U
N#define GPIO_PUPDR_PUPDR5_0                  0x00000400U
N#define GPIO_PUPDR_PUPDR5_1                  0x00000800U
N#define GPIO_PUPDR_PUPDR6                    0x00003000U
N#define GPIO_PUPDR_PUPDR6_0                  0x00001000U
N#define GPIO_PUPDR_PUPDR6_1                  0x00002000U
N#define GPIO_PUPDR_PUPDR7                    0x0000C000U
N#define GPIO_PUPDR_PUPDR7_0                  0x00004000U
N#define GPIO_PUPDR_PUPDR7_1                  0x00008000U
N#define GPIO_PUPDR_PUPDR8                    0x00030000U
N#define GPIO_PUPDR_PUPDR8_0                  0x00010000U
N#define GPIO_PUPDR_PUPDR8_1                  0x00020000U
N#define GPIO_PUPDR_PUPDR9                    0x000C0000U
N#define GPIO_PUPDR_PUPDR9_0                  0x00040000U
N#define GPIO_PUPDR_PUPDR9_1                  0x00080000U
N#define GPIO_PUPDR_PUPDR10                   0x00300000U
N#define GPIO_PUPDR_PUPDR10_0                 0x00100000U
N#define GPIO_PUPDR_PUPDR10_1                 0x00200000U
N#define GPIO_PUPDR_PUPDR11                   0x00C00000U
N#define GPIO_PUPDR_PUPDR11_0                 0x00400000U
N#define GPIO_PUPDR_PUPDR11_1                 0x00800000U
N#define GPIO_PUPDR_PUPDR12                   0x03000000U
N#define GPIO_PUPDR_PUPDR12_0                 0x01000000U
N#define GPIO_PUPDR_PUPDR12_1                 0x02000000U
N#define GPIO_PUPDR_PUPDR13                   0x0C000000U
N#define GPIO_PUPDR_PUPDR13_0                 0x04000000U
N#define GPIO_PUPDR_PUPDR13_1                 0x08000000U
N#define GPIO_PUPDR_PUPDR14                   0x30000000U
N#define GPIO_PUPDR_PUPDR14_0                 0x10000000U
N#define GPIO_PUPDR_PUPDR14_1                 0x20000000U
N#define GPIO_PUPDR_PUPDR15                   0xC0000000U
N#define GPIO_PUPDR_PUPDR15_0                 0x40000000U
N#define GPIO_PUPDR_PUPDR15_1                 0x80000000U
N
N/******************  Bits definition for GPIO_IDR register  *******************/
N#define GPIO_IDR_IDR_0                       0x00000001U
N#define GPIO_IDR_IDR_1                       0x00000002U
N#define GPIO_IDR_IDR_2                       0x00000004U
N#define GPIO_IDR_IDR_3                       0x00000008U
N#define GPIO_IDR_IDR_4                       0x00000010U
N#define GPIO_IDR_IDR_5                       0x00000020U
N#define GPIO_IDR_IDR_6                       0x00000040U
N#define GPIO_IDR_IDR_7                       0x00000080U
N#define GPIO_IDR_IDR_8                       0x00000100U
N#define GPIO_IDR_IDR_9                       0x00000200U
N#define GPIO_IDR_IDR_10                      0x00000400U
N#define GPIO_IDR_IDR_11                      0x00000800U
N#define GPIO_IDR_IDR_12                      0x00001000U
N#define GPIO_IDR_IDR_13                      0x00002000U
N#define GPIO_IDR_IDR_14                      0x00004000U
N#define GPIO_IDR_IDR_15                      0x00008000U
N
N/******************  Bits definition for GPIO_ODR register  *******************/
N#define GPIO_ODR_ODR_0                       0x00000001U
N#define GPIO_ODR_ODR_1                       0x00000002U
N#define GPIO_ODR_ODR_2                       0x00000004U
N#define GPIO_ODR_ODR_3                       0x00000008U
N#define GPIO_ODR_ODR_4                       0x00000010U
N#define GPIO_ODR_ODR_5                       0x00000020U
N#define GPIO_ODR_ODR_6                       0x00000040U
N#define GPIO_ODR_ODR_7                       0x00000080U
N#define GPIO_ODR_ODR_8                       0x00000100U
N#define GPIO_ODR_ODR_9                       0x00000200U
N#define GPIO_ODR_ODR_10                      0x00000400U
N#define GPIO_ODR_ODR_11                      0x00000800U
N#define GPIO_ODR_ODR_12                      0x00001000U
N#define GPIO_ODR_ODR_13                      0x00002000U
N#define GPIO_ODR_ODR_14                      0x00004000U
N#define GPIO_ODR_ODR_15                      0x00008000U
N
N/******************  Bits definition for GPIO_BSRR register  ******************/
N#define GPIO_BSRR_BS_0                       0x00000001U
N#define GPIO_BSRR_BS_1                       0x00000002U
N#define GPIO_BSRR_BS_2                       0x00000004U
N#define GPIO_BSRR_BS_3                       0x00000008U
N#define GPIO_BSRR_BS_4                       0x00000010U
N#define GPIO_BSRR_BS_5                       0x00000020U
N#define GPIO_BSRR_BS_6                       0x00000040U
N#define GPIO_BSRR_BS_7                       0x00000080U
N#define GPIO_BSRR_BS_8                       0x00000100U
N#define GPIO_BSRR_BS_9                       0x00000200U
N#define GPIO_BSRR_BS_10                      0x00000400U
N#define GPIO_BSRR_BS_11                      0x00000800U
N#define GPIO_BSRR_BS_12                      0x00001000U
N#define GPIO_BSRR_BS_13                      0x00002000U
N#define GPIO_BSRR_BS_14                      0x00004000U
N#define GPIO_BSRR_BS_15                      0x00008000U
N#define GPIO_BSRR_BR_0                       0x00010000U
N#define GPIO_BSRR_BR_1                       0x00020000U
N#define GPIO_BSRR_BR_2                       0x00040000U
N#define GPIO_BSRR_BR_3                       0x00080000U
N#define GPIO_BSRR_BR_4                       0x00100000U
N#define GPIO_BSRR_BR_5                       0x00200000U
N#define GPIO_BSRR_BR_6                       0x00400000U
N#define GPIO_BSRR_BR_7                       0x00800000U
N#define GPIO_BSRR_BR_8                       0x01000000U
N#define GPIO_BSRR_BR_9                       0x02000000U
N#define GPIO_BSRR_BR_10                      0x04000000U
N#define GPIO_BSRR_BR_11                      0x08000000U
N#define GPIO_BSRR_BR_12                      0x10000000U
N#define GPIO_BSRR_BR_13                      0x20000000U
N#define GPIO_BSRR_BR_14                      0x40000000U
N#define GPIO_BSRR_BR_15                      0x80000000U
N
N/****************** Bit definition for GPIO_LCKR register *********************/
N#define GPIO_LCKR_LCK0                       0x00000001U
N#define GPIO_LCKR_LCK1                       0x00000002U
N#define GPIO_LCKR_LCK2                       0x00000004U
N#define GPIO_LCKR_LCK3                       0x00000008U
N#define GPIO_LCKR_LCK4                       0x00000010U
N#define GPIO_LCKR_LCK5                       0x00000020U
N#define GPIO_LCKR_LCK6                       0x00000040U
N#define GPIO_LCKR_LCK7                       0x00000080U
N#define GPIO_LCKR_LCK8                       0x00000100U
N#define GPIO_LCKR_LCK9                       0x00000200U
N#define GPIO_LCKR_LCK10                      0x00000400U
N#define GPIO_LCKR_LCK11                      0x00000800U
N#define GPIO_LCKR_LCK12                      0x00001000U
N#define GPIO_LCKR_LCK13                      0x00002000U
N#define GPIO_LCKR_LCK14                      0x00004000U
N#define GPIO_LCKR_LCK15                      0x00008000U
N#define GPIO_LCKR_LCKK                       0x00010000U
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                      Inter-integrated Circuit Interface (I2C)              */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for I2C_CR1 register  *******************/
N#define  I2C_CR1_PE                          0x00000001U        /*!< Peripheral enable                   */
N#define  I2C_CR1_TXIE                        0x00000002U        /*!< TX interrupt enable                 */
N#define  I2C_CR1_RXIE                        0x00000004U        /*!< RX interrupt enable                 */
N#define  I2C_CR1_ADDRIE                      0x00000008U        /*!< Address match interrupt enable      */
N#define  I2C_CR1_NACKIE                      0x00000010U        /*!< NACK received interrupt enable      */
N#define  I2C_CR1_STOPIE                      0x00000020U        /*!< STOP detection interrupt enable     */
N#define  I2C_CR1_TCIE                        0x00000040U        /*!< Transfer complete interrupt enable  */
N#define  I2C_CR1_ERRIE                       0x00000080U        /*!< Errors interrupt enable             */
N#define  I2C_CR1_DNF                         0x00000F00U        /*!< Digital noise filter                */
N#define  I2C_CR1_ANFOFF                      0x00001000U        /*!< Analog noise filter OFF             */
N#define  I2C_CR1_TXDMAEN                     0x00004000U        /*!< DMA transmission requests enable    */
N#define  I2C_CR1_RXDMAEN                     0x00008000U        /*!< DMA reception requests enable       */
N#define  I2C_CR1_SBC                         0x00010000U        /*!< Slave byte control                  */
N#define  I2C_CR1_NOSTRETCH                   0x00020000U        /*!< Clock stretching disable            */
N#define  I2C_CR1_GCEN                        0x00080000U        /*!< General call enable                 */
N#define  I2C_CR1_SMBHEN                      0x00100000U        /*!< SMBus host address enable           */
N#define  I2C_CR1_SMBDEN                      0x00200000U        /*!< SMBus device default address enable */
N#define  I2C_CR1_ALERTEN                     0x00400000U        /*!< SMBus alert enable                  */
N#define  I2C_CR1_PECEN                       0x00800000U        /*!< PEC enable                          */
N
N
N/******************  Bit definition for I2C_CR2 register  ********************/
N#define  I2C_CR2_SADD                        0x000003FFU        /*!< Slave address (master mode)                             */
N#define  I2C_CR2_RD_WRN                      0x00000400U        /*!< Transfer direction (master mode)                        */
N#define  I2C_CR2_ADD10                       0x00000800U        /*!< 10-bit addressing mode (master mode)                    */
N#define  I2C_CR2_HEAD10R                     0x00001000U        /*!< 10-bit address header only read direction (master mode) */
N#define  I2C_CR2_START                       0x00002000U        /*!< START generation                                        */
N#define  I2C_CR2_STOP                        0x00004000U        /*!< STOP generation (master mode)                           */
N#define  I2C_CR2_NACK                        0x00008000U        /*!< NACK generation (slave mode)                            */
N#define  I2C_CR2_NBYTES                      0x00FF0000U        /*!< Number of bytes                                         */
N#define  I2C_CR2_RELOAD                      0x01000000U        /*!< NBYTES reload mode                                      */
N#define  I2C_CR2_AUTOEND                     0x02000000U        /*!< Automatic end mode (master mode)                        */
N#define  I2C_CR2_PECBYTE                     0x04000000U        /*!< Packet error checking byte                              */
N
N/*******************  Bit definition for I2C_OAR1 register  ******************/
N#define  I2C_OAR1_OA1                        0x000003FFU        /*!< Interface own address 1   */
N#define  I2C_OAR1_OA1MODE                    0x00000400U        /*!< Own address 1 10-bit mode */
N#define  I2C_OAR1_OA1EN                      0x00008000U        /*!< Own address 1 enable      */
N
N/*******************  Bit definition for I2C_OAR2 register  ******************/
N#define  I2C_OAR2_OA2                        0x000000FEU        /*!< Interface own address 2 */
N#define  I2C_OAR2_OA2MSK                     0x00000700U        /*!< Own address 2 masks     */
N#define  I2C_OAR2_OA2NOMASK                  0x00000000U        /*!< No mask */
N#define  I2C_OAR2_OA2MASK01                  0x00000100U        /*!< OA2[1] is masked, Only OA2[7:2] are compared */
N#define  I2C_OAR2_OA2MASK02                  0x00000200U        /*!< OA2[2:1] is masked, Only OA2[7:3] are compared */
N#define  I2C_OAR2_OA2MASK03                  0x00000300U        /*!< OA2[3:1] is masked, Only OA2[7:4] are compared */
N#define  I2C_OAR2_OA2MASK04                  0x00000400U        /*!< OA2[4:1] is masked, Only OA2[7:5] are compared */
N#define  I2C_OAR2_OA2MASK05                  0x00000500U        /*!< OA2[5:1] is masked, Only OA2[7:6] are compared */
N#define  I2C_OAR2_OA2MASK06                  0x00000600U        /*!< OA2[6:1] is masked, Only OA2[7] are compared */
N#define  I2C_OAR2_OA2MASK07                  0x00000700U        /*!< OA2[7:1] is masked, No comparison is done */
N#define  I2C_OAR2_OA2EN                      0x00008000U        /*!< Own address 2 enable    */
N
N/*******************  Bit definition for I2C_TIMINGR register *******************/
N#define  I2C_TIMINGR_SCLL                    0x000000FFU        /*!< SCL low period (master mode)  */
N#define  I2C_TIMINGR_SCLH                    0x0000FF00U        /*!< SCL high period (master mode) */
N#define  I2C_TIMINGR_SDADEL                  0x000F0000U        /*!< Data hold time                */
N#define  I2C_TIMINGR_SCLDEL                  0x00F00000U        /*!< Data setup time               */
N#define  I2C_TIMINGR_PRESC                   0xF0000000U        /*!< Timings prescaler             */
N
N/******************* Bit definition for I2C_TIMEOUTR register *******************/
N#define  I2C_TIMEOUTR_TIMEOUTA               0x00000FFFU        /*!< Bus timeout A                 */
N#define  I2C_TIMEOUTR_TIDLE                  0x00001000U        /*!< Idle clock timeout detection  */
N#define  I2C_TIMEOUTR_TIMOUTEN               0x00008000U        /*!< Clock timeout enable          */
N#define  I2C_TIMEOUTR_TIMEOUTB               0x0FFF0000U        /*!< Bus timeout B                 */
N#define  I2C_TIMEOUTR_TEXTEN                 0x80000000U        /*!< Extended clock timeout enable */
N
N/******************  Bit definition for I2C_ISR register  *********************/
N#define  I2C_ISR_TXE                         0x00000001U        /*!< Transmit data register empty    */
N#define  I2C_ISR_TXIS                        0x00000002U        /*!< Transmit interrupt status       */
N#define  I2C_ISR_RXNE                        0x00000004U        /*!< Receive data register not empty */
N#define  I2C_ISR_ADDR                        0x00000008U        /*!< Address matched (slave mode)    */
N#define  I2C_ISR_NACKF                       0x00000010U        /*!< NACK received flag              */
N#define  I2C_ISR_STOPF                       0x00000020U        /*!< STOP detection flag             */
N#define  I2C_ISR_TC                          0x00000040U        /*!< Transfer complete (master mode) */
N#define  I2C_ISR_TCR                         0x00000080U        /*!< Transfer complete reload        */
N#define  I2C_ISR_BERR                        0x00000100U        /*!< Bus error                       */
N#define  I2C_ISR_ARLO                        0x00000200U        /*!< Arbitration lost                */
N#define  I2C_ISR_OVR                         0x00000400U        /*!< Overrun/Underrun                */
N#define  I2C_ISR_PECERR                      0x00000800U        /*!< PEC error in reception          */
N#define  I2C_ISR_TIMEOUT                     0x00001000U        /*!< Timeout or Tlow detection flag  */
N#define  I2C_ISR_ALERT                       0x00002000U        /*!< SMBus alert                     */
N#define  I2C_ISR_BUSY                        0x00008000U        /*!< Bus busy                        */
N#define  I2C_ISR_DIR                         0x00010000U        /*!< Transfer direction (slave mode) */
N#define  I2C_ISR_ADDCODE                     0x00FE0000U        /*!< Address match code (slave mode) */
N
N/******************  Bit definition for I2C_ICR register  *********************/
N#define  I2C_ICR_ADDRCF                      0x00000008U        /*!< Address matched clear flag      */
N#define  I2C_ICR_NACKCF                      0x00000010U        /*!< NACK clear flag                 */
N#define  I2C_ICR_STOPCF                      0x00000020U        /*!< STOP detection clear flag       */
N#define  I2C_ICR_BERRCF                      0x00000100U        /*!< Bus error clear flag            */
N#define  I2C_ICR_ARLOCF                      0x00000200U        /*!< Arbitration lost clear flag     */
N#define  I2C_ICR_OVRCF                       0x00000400U        /*!< Overrun/Underrun clear flag     */
N#define  I2C_ICR_PECCF                       0x00000800U        /*!< PAC error clear flag            */
N#define  I2C_ICR_TIMOUTCF                    0x00001000U        /*!< Timeout clear flag              */
N#define  I2C_ICR_ALERTCF                     0x00002000U        /*!< Alert clear flag                */
N
N/******************  Bit definition for I2C_PECR register  *********************/
N#define  I2C_PECR_PEC                        0x000000FFU        /*!< PEC register        */
N
N/******************  Bit definition for I2C_RXDR register  *********************/
N#define  I2C_RXDR_RXDATA                     0x000000FFU        /*!< 8-bit receive data  */
N
N/******************  Bit definition for I2C_TXDR register  *********************/
N#define  I2C_TXDR_TXDATA                     0x000000FFU        /*!< 8-bit transmit data */
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                           Independent WATCHDOG                             */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for IWDG_KR register  ********************/
N#define  IWDG_KR_KEY                         0xFFFFU            /*!<Key value (write only, read 0000h)  */
N
N/*******************  Bit definition for IWDG_PR register  ********************/
N#define  IWDG_PR_PR                          0x07U               /*!<PR[2:0] (Prescaler divider)         */
N#define  IWDG_PR_PR_0                        0x01U               /*!<Bit 0 */
N#define  IWDG_PR_PR_1                        0x02U               /*!<Bit 1 */
N#define  IWDG_PR_PR_2                        0x04U               /*!<Bit 2 */
N
N/*******************  Bit definition for IWDG_RLR register  *******************/
N#define  IWDG_RLR_RL                         0x0FFFU            /*!<Watchdog counter reload value        */
N
N/*******************  Bit definition for IWDG_SR register  ********************/
N#define  IWDG_SR_PVU                         0x01U               /*!< Watchdog prescaler value update */
N#define  IWDG_SR_RVU                         0x02U               /*!< Watchdog counter reload value update */
N#define  IWDG_SR_WVU                         0x04U               /*!< Watchdog counter window value update */
N
N/*******************  Bit definition for IWDG_KR register  ********************/
N#define  IWDG_WINR_WIN                       0x0FFFU             /*!< Watchdog counter window value */
N
N/******************************************************************************/
N/*                                                                            */
N/*                      LCD-TFT Display Controller (LTDC)                     */
N/*                                                                            */
N/******************************************************************************/
N
N/********************  Bit definition for LTDC_SSCR register  *****************/
N
N#define LTDC_SSCR_VSH                       0x000007FFU              /*!< Vertical Synchronization Height  */
N#define LTDC_SSCR_HSW                       0x0FFF0000U              /*!< Horizontal Synchronization Width */
N
N/********************  Bit definition for LTDC_BPCR register  *****************/
N
N#define LTDC_BPCR_AVBP                      0x000007FFU              /*!< Accumulated Vertical Back Porch   */
N#define LTDC_BPCR_AHBP                      0x0FFF0000U              /*!< Accumulated Horizontal Back Porch */
N
N/********************  Bit definition for LTDC_AWCR register  *****************/
N
N#define LTDC_AWCR_AAH                       0x000007FFU              /*!< Accumulated Active heigh */
N#define LTDC_AWCR_AAW                       0x0FFF0000U              /*!< Accumulated Active Width */
N
N/********************  Bit definition for LTDC_TWCR register  *****************/
N
N#define LTDC_TWCR_TOTALH                    0x000007FFU              /*!< Total Heigh */
N#define LTDC_TWCR_TOTALW                    0x0FFF0000U              /*!< Total Width */
N
N/********************  Bit definition for LTDC_GCR register  ******************/
N
N#define LTDC_GCR_LTDCEN                     0x00000001U              /*!< LCD-TFT controller enable bit       */
N#define LTDC_GCR_DBW                        0x00000070U              /*!< Dither Blue Width                   */
N#define LTDC_GCR_DGW                        0x00000700U              /*!< Dither Green Width                  */
N#define LTDC_GCR_DRW                        0x00007000U              /*!< Dither Red Width                    */
N#define LTDC_GCR_DEN                        0x00010000U              /*!< Dither Enable                       */
N#define LTDC_GCR_PCPOL                      0x10000000U              /*!< Pixel Clock Polarity                */
N#define LTDC_GCR_DEPOL                      0x20000000U              /*!< Data Enable Polarity                */
N#define LTDC_GCR_VSPOL                      0x40000000U              /*!< Vertical Synchronization Polarity   */
N#define LTDC_GCR_HSPOL                      0x80000000U              /*!< Horizontal Synchronization Polarity */
N
N
N/********************  Bit definition for LTDC_SRCR register  *****************/
N
N#define LTDC_SRCR_IMR                      0x00000001U               /*!< Immediate Reload         */
N#define LTDC_SRCR_VBR                      0x00000002U               /*!< Vertical Blanking Reload */
N
N/********************  Bit definition for LTDC_BCCR register  *****************/
N
N#define LTDC_BCCR_BCBLUE                    0x000000FFU              /*!< Background Blue value  */
N#define LTDC_BCCR_BCGREEN                   0x0000FF00U              /*!< Background Green value */
N#define LTDC_BCCR_BCRED                     0x00FF0000U              /*!< Background Red value   */
N
N/********************  Bit definition for LTDC_IER register  ******************/
N
N#define LTDC_IER_LIE                        0x00000001U              /*!< Line Interrupt Enable            */
N#define LTDC_IER_FUIE                       0x00000002U              /*!< FIFO Underrun Interrupt Enable   */
N#define LTDC_IER_TERRIE                     0x00000004U              /*!< Transfer Error Interrupt Enable  */
N#define LTDC_IER_RRIE                       0x00000008U              /*!< Register Reload interrupt enable */
N
N/********************  Bit definition for LTDC_ISR register  ******************/
N
N#define LTDC_ISR_LIF                        0x00000001U              /*!< Line Interrupt Flag */
N#define LTDC_ISR_FUIF                       0x00000002U              /*!< FIFO Underrun Interrupt Flag */
N#define LTDC_ISR_TERRIF                     0x00000004U              /*!< Transfer Error Interrupt Flag */
N#define LTDC_ISR_RRIF                       0x00000008U              /*!< Register Reload interrupt Flag */
N
N/********************  Bit definition for LTDC_ICR register  ******************/
N
N#define LTDC_ICR_CLIF                       0x00000001U              /*!< Clears the Line Interrupt Flag */
N#define LTDC_ICR_CFUIF                      0x00000002U              /*!< Clears the FIFO Underrun Interrupt Flag */
N#define LTDC_ICR_CTERRIF                    0x00000004U              /*!< Clears the Transfer Error Interrupt Flag */
N#define LTDC_ICR_CRRIF                      0x00000008U              /*!< Clears Register Reload interrupt Flag */
N
N/********************  Bit definition for LTDC_LIPCR register  ****************/
N
N#define LTDC_LIPCR_LIPOS                    0x000007FFU              /*!< Line Interrupt Position */
N
N/********************  Bit definition for LTDC_CPSR register  *****************/
N
N#define LTDC_CPSR_CYPOS                     0x0000FFFFU              /*!< Current Y Position */
N#define LTDC_CPSR_CXPOS                     0xFFFF0000U              /*!< Current X Position */
N
N/********************  Bit definition for LTDC_CDSR register  *****************/
N
N#define LTDC_CDSR_VDES                      0x00000001U              /*!< Vertical Data Enable Status       */
N#define LTDC_CDSR_HDES                      0x00000002U              /*!< Horizontal Data Enable Status     */
N#define LTDC_CDSR_VSYNCS                    0x00000004U              /*!< Vertical Synchronization Status   */
N#define LTDC_CDSR_HSYNCS                    0x00000008U              /*!< Horizontal Synchronization Status */
N
N/********************  Bit definition for LTDC_LxCR register  *****************/
N
N#define LTDC_LxCR_LEN                       0x00000001U              /*!< Layer Enable              */
N#define LTDC_LxCR_COLKEN                    0x00000002U              /*!< Color Keying Enable       */
N#define LTDC_LxCR_CLUTEN                    0x00000010U              /*!< Color Lockup Table Enable */
N
N/********************  Bit definition for LTDC_LxWHPCR register  **************/
N
N#define LTDC_LxWHPCR_WHSTPOS                0x00000FFFU              /*!< Window Horizontal Start Position */
N#define LTDC_LxWHPCR_WHSPPOS                0xFFFF0000U              /*!< Window Horizontal Stop Position  */
N
N/********************  Bit definition for LTDC_LxWVPCR register  **************/
N
N#define LTDC_LxWVPCR_WVSTPOS                0x00000FFFU              /*!< Window Vertical Start Position */
N#define LTDC_LxWVPCR_WVSPPOS                0xFFFF0000U              /*!< Window Vertical Stop Position  */
N
N/********************  Bit definition for LTDC_LxCKCR register  ***************/
N
N#define LTDC_LxCKCR_CKBLUE                  0x000000FFU              /*!< Color Key Blue value  */
N#define LTDC_LxCKCR_CKGREEN                 0x0000FF00U              /*!< Color Key Green value */
N#define LTDC_LxCKCR_CKRED                   0x00FF0000U              /*!< Color Key Red value   */
N
N/********************  Bit definition for LTDC_LxPFCR register  ***************/
N
N#define LTDC_LxPFCR_PF                      0x00000007U              /*!< Pixel Format */
N
N/********************  Bit definition for LTDC_LxCACR register  ***************/
N
N#define LTDC_LxCACR_CONSTA                  0x000000FFU              /*!< Constant Alpha */
N
N/********************  Bit definition for LTDC_LxDCCR register  ***************/
N
N#define LTDC_LxDCCR_DCBLUE                  0x000000FFU              /*!< Default Color Blue  */
N#define LTDC_LxDCCR_DCGREEN                 0x0000FF00U              /*!< Default Color Green */
N#define LTDC_LxDCCR_DCRED                   0x00FF0000U              /*!< Default Color Red   */
N#define LTDC_LxDCCR_DCALPHA                 0xFF000000U              /*!< Default Color Alpha */
N                                
N/********************  Bit definition for LTDC_LxBFCR register  ***************/
N
N#define LTDC_LxBFCR_BF2                     0x00000007U              /*!< Blending Factor 2 */
N#define LTDC_LxBFCR_BF1                     0x00000700U              /*!< Blending Factor 1 */
N
N/********************  Bit definition for LTDC_LxCFBAR register  **************/
N
N#define LTDC_LxCFBAR_CFBADD                 0xFFFFFFFFU              /*!< Color Frame Buffer Start Address */
N
N/********************  Bit definition for LTDC_LxCFBLR register  **************/
N
N#define LTDC_LxCFBLR_CFBLL                  0x00001FFFU              /*!< Color Frame Buffer Line Length    */
N#define LTDC_LxCFBLR_CFBP                   0x1FFF0000U              /*!< Color Frame Buffer Pitch in bytes */
N
N/********************  Bit definition for LTDC_LxCFBLNR register  *************/
N
N#define LTDC_LxCFBLNR_CFBLNBR               0x000007FFU              /*!< Frame Buffer Line Number */
N
N/********************  Bit definition for LTDC_LxCLUTWR register  *************/
N
N#define LTDC_LxCLUTWR_BLUE                  0x000000FFU              /*!< Blue value   */
N#define LTDC_LxCLUTWR_GREEN                 0x0000FF00U              /*!< Green value  */
N#define LTDC_LxCLUTWR_RED                   0x00FF0000U              /*!< Red value    */
N#define LTDC_LxCLUTWR_CLUTADD               0xFF000000U              /*!< CLUT address */
N
N/******************************************************************************/
N/*                                                                            */
N/*                             Power Control                                  */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for PWR_CR1 register  ********************/
N#define  PWR_CR1_LPDS                         0x00000001U     /*!< Low-Power Deepsleep                 */
N#define  PWR_CR1_PDDS                         0x00000002U     /*!< Power Down Deepsleep                */
N#define  PWR_CR1_CSBF                         0x00000008U     /*!< Clear Standby Flag                  */
N#define  PWR_CR1_PVDE                         0x00000010U     /*!< Power Voltage Detector Enable       */
N#define  PWR_CR1_PLS                          0x000000E0U     /*!< PLS[2:0] bits (PVD Level Selection) */
N#define  PWR_CR1_PLS_0                        0x00000020U     /*!< Bit 0 */
N#define  PWR_CR1_PLS_1                        0x00000040U     /*!< Bit 1 */
N#define  PWR_CR1_PLS_2                        0x00000080U     /*!< Bit 2 */
N
N/*!< PVD level configuration */
N#define  PWR_CR1_PLS_LEV0                     0x00000000U     /*!< PVD level 0 */
N#define  PWR_CR1_PLS_LEV1                     0x00000020U     /*!< PVD level 1 */
N#define  PWR_CR1_PLS_LEV2                     0x00000040U     /*!< PVD level 2 */
N#define  PWR_CR1_PLS_LEV3                     0x00000060U     /*!< PVD level 3 */
N#define  PWR_CR1_PLS_LEV4                     0x00000080U     /*!< PVD level 4 */
N#define  PWR_CR1_PLS_LEV5                     0x000000A0U     /*!< PVD level 5 */
N#define  PWR_CR1_PLS_LEV6                     0x000000C0U     /*!< PVD level 6 */
N#define  PWR_CR1_PLS_LEV7                     0x000000E0U     /*!< PVD level 7 */
N#define  PWR_CR1_DBP                          0x00000100U     /*!< Disable Backup Domain write protection                     */
N#define  PWR_CR1_FPDS                         0x00000200U     /*!< Flash power down in Stop mode                              */
N#define  PWR_CR1_LPUDS                        0x00000400U     /*!< Low-power regulator in deepsleep under-drive mode          */
N#define  PWR_CR1_MRUDS                        0x00000800U     /*!< Main regulator in deepsleep under-drive mode               */
N#define  PWR_CR1_ADCDC1                       0x00002000U     /*!< Refer to AN4073 on how to use this bit */ 
N#define  PWR_CR1_VOS                          0x0000C000U     /*!< VOS[1:0] bits (Regulator voltage scaling output selection) */
N#define  PWR_CR1_VOS_0                        0x00004000U     /*!< Bit 0 */
N#define  PWR_CR1_VOS_1                        0x00008000U     /*!< Bit 1 */
N#define  PWR_CR1_ODEN                         0x00010000U     /*!< Over Drive enable                   */
N#define  PWR_CR1_ODSWEN                       0x00020000U     /*!< Over Drive switch enabled           */
N#define  PWR_CR1_UDEN                         0x000C0000U     /*!< Under Drive enable in stop mode     */
N#define  PWR_CR1_UDEN_0                       0x00040000U     /*!< Bit 0                               */
N#define  PWR_CR1_UDEN_1                       0x00080000U     /*!< Bit 1                               */
N
N/*******************  Bit definition for PWR_CSR1 register  ********************/
N#define  PWR_CSR1_WUIF                        0x00000001U     /*!< Wake up internal Flag                            */
N#define  PWR_CSR1_SBF                         0x00000002U     /*!< Standby Flag                                     */
N#define  PWR_CSR1_PVDO                        0x00000004U     /*!< PVD Output                                       */
N#define  PWR_CSR1_BRR                         0x00000008U     /*!< Backup regulator ready                           */
N#define  PWR_CSR1_EIWUP                       0x00000100U     /*!< Enable internal wakeup                           */
N#define  PWR_CSR1_BRE                         0x00000200U     /*!< Backup regulator enable                          */
N#define  PWR_CSR1_VOSRDY                      0x00004000U     /*!< Regulator voltage scaling output selection ready */
N#define  PWR_CSR1_ODRDY                       0x00010000U     /*!< Over Drive generator ready                       */
N#define  PWR_CSR1_ODSWRDY                     0x00020000U     /*!< Over Drive Switch ready                          */
N#define  PWR_CSR1_UDRDY                       0x000C0000U     /*!< Under Drive ready                                */
N
N
N/********************  Bit definition for PWR_CR2 register  ********************/
N#define  PWR_CR2_CWUPF1                         0x00000001U     /*!< Clear Wakeup Pin Flag for PA0      */
N#define  PWR_CR2_CWUPF2                         0x00000002U     /*!< Clear Wakeup Pin Flag for PA2      */
N#define  PWR_CR2_CWUPF3                         0x00000004U     /*!< Clear Wakeup Pin Flag for PC1      */
N#define  PWR_CR2_CWUPF4                         0x00000008U     /*!< Clear Wakeup Pin Flag for PC13     */
N#define  PWR_CR2_CWUPF5                         0x00000010U     /*!< Clear Wakeup Pin Flag for PI8      */
N#define  PWR_CR2_CWUPF6                         0x00000020U     /*!< Clear Wakeup Pin Flag for PI11     */
N#define  PWR_CR2_WUPP1                          0x00000100U     /*!< Wakeup Pin Polarity bit for PA0    */
N#define  PWR_CR2_WUPP2                          0x00000200U     /*!< Wakeup Pin Polarity bit for PA2    */
N#define  PWR_CR2_WUPP3                          0x00000400U     /*!< Wakeup Pin Polarity bit for PC1    */
N#define  PWR_CR2_WUPP4                          0x00000800U     /*!< Wakeup Pin Polarity bit for PC13   */
N#define  PWR_CR2_WUPP5                          0x00001000U     /*!< Wakeup Pin Polarity bit for PI8    */
N#define  PWR_CR2_WUPP6                          0x00002000U     /*!< Wakeup Pin Polarity bit for PI11   */
N
N/*******************  Bit definition for PWR_CSR2 register  ********************/
N#define  PWR_CSR2_WUPF1                         0x00000001U     /*!< Wakeup Pin Flag for PA0            */
N#define  PWR_CSR2_WUPF2                         0x00000002U     /*!< Wakeup Pin Flag for PA2            */
N#define  PWR_CSR2_WUPF3                         0x00000004U     /*!< Wakeup Pin Flag for PC1            */
N#define  PWR_CSR2_WUPF4                         0x00000008U     /*!< Wakeup Pin Flag for PC13           */
N#define  PWR_CSR2_WUPF5                         0x00000010U     /*!< Wakeup Pin Flag for PI8            */
N#define  PWR_CSR2_WUPF6                         0x00000020U     /*!< Wakeup Pin Flag for PI11           */
N#define  PWR_CSR2_EWUP1                         0x00000100U     /*!< Enable Wakeup Pin PA0              */
N#define  PWR_CSR2_EWUP2                         0x00000200U     /*!< Enable Wakeup Pin PA2              */
N#define  PWR_CSR2_EWUP3                         0x00000400U     /*!< Enable Wakeup Pin PC1              */
N#define  PWR_CSR2_EWUP4                         0x00000800U     /*!< Enable Wakeup Pin PC13             */
N#define  PWR_CSR2_EWUP5                         0x00001000U     /*!< Enable Wakeup Pin PI8              */
N#define  PWR_CSR2_EWUP6                         0x00002000U     /*!< Enable Wakeup Pin PI11             */
N
N/******************************************************************************/
N/*                                                                            */
N/*                                    QUADSPI                                 */
N/*                                                                            */
N/******************************************************************************/
N/*****************  Bit definition for QUADSPI_CR register  *******************/
N#define  QUADSPI_CR_EN                           0x00000001U            /*!< Enable                            */
N#define  QUADSPI_CR_ABORT                        0x00000002U            /*!< Abort request                     */
N#define  QUADSPI_CR_DMAEN                        0x00000004U            /*!< DMA Enable                        */
N#define  QUADSPI_CR_TCEN                         0x00000008U            /*!< Timeout Counter Enable            */
N#define  QUADSPI_CR_SSHIFT                       0x00000010U            /*!< Sample Shift                      */
N#define  QUADSPI_CR_DFM                          0x00000040U            /*!< Dual Flash Mode                   */
N#define  QUADSPI_CR_FSEL                         0x00000080U            /*!< Flash Select                      */
N#define  QUADSPI_CR_FTHRES                       0x00001F00U            /*!< FTHRES[4:0] FIFO Level            */
N#define  QUADSPI_CR_FTHRES_0                     0x00000100U            /*!< Bit 0 */
N#define  QUADSPI_CR_FTHRES_1                     0x00000200U            /*!< Bit 1 */
N#define  QUADSPI_CR_FTHRES_2                     0x00000400U            /*!< Bit 2 */
N#define  QUADSPI_CR_FTHRES_3                     0x00000800U            /*!< Bit 3 */
N#define  QUADSPI_CR_FTHRES_4                     0x00001000U            /*!< Bit 4 */
N#define  QUADSPI_CR_TEIE                         0x00010000U            /*!< Transfer Error Interrupt Enable    */
N#define  QUADSPI_CR_TCIE                         0x00020000U            /*!< Transfer Complete Interrupt Enable */
N#define  QUADSPI_CR_FTIE                         0x00040000U            /*!< FIFO Threshold Interrupt Enable    */
N#define  QUADSPI_CR_SMIE                         0x00080000U            /*!< Status Match Interrupt Enable      */
N#define  QUADSPI_CR_TOIE                         0x00100000U            /*!< TimeOut Interrupt Enable           */
N#define  QUADSPI_CR_APMS                         0x00400000U            /*!< Bit 1                              */
N#define  QUADSPI_CR_PMM                          0x00800000U            /*!< Polling Match Mode                 */
N#define  QUADSPI_CR_PRESCALER                    0xFF000000U            /*!< PRESCALER[7:0] Clock prescaler     */
N#define  QUADSPI_CR_PRESCALER_0                  0x01000000U            /*!< Bit 0 */
N#define  QUADSPI_CR_PRESCALER_1                  0x02000000U            /*!< Bit 1 */
N#define  QUADSPI_CR_PRESCALER_2                  0x04000000U            /*!< Bit 2 */
N#define  QUADSPI_CR_PRESCALER_3                  0x08000000U            /*!< Bit 3 */
N#define  QUADSPI_CR_PRESCALER_4                  0x10000000U            /*!< Bit 4 */
N#define  QUADSPI_CR_PRESCALER_5                  0x20000000U            /*!< Bit 5 */
N#define  QUADSPI_CR_PRESCALER_6                  0x40000000U            /*!< Bit 6 */
N#define  QUADSPI_CR_PRESCALER_7                  0x80000000U            /*!< Bit 7 */
N
N/*****************  Bit definition for QUADSPI_DCR register  ******************/
N#define  QUADSPI_DCR_CKMODE                      0x00000001U            /*!< Mode 0 / Mode 3                 */
N#define  QUADSPI_DCR_CSHT                        0x00000700U            /*!< CSHT[2:0]: ChipSelect High Time */
N#define  QUADSPI_DCR_CSHT_0                      0x00000100U            /*!< Bit 0 */
N#define  QUADSPI_DCR_CSHT_1                      0x00000200U            /*!< Bit 1 */
N#define  QUADSPI_DCR_CSHT_2                      0x00000400U            /*!< Bit 2 */
N#define  QUADSPI_DCR_FSIZE                       0x001F0000U            /*!< FSIZE[4:0]: Flash Size          */
N#define  QUADSPI_DCR_FSIZE_0                     0x00010000U            /*!< Bit 0 */
N#define  QUADSPI_DCR_FSIZE_1                     0x00020000U            /*!< Bit 1 */
N#define  QUADSPI_DCR_FSIZE_2                     0x00040000U            /*!< Bit 2 */
N#define  QUADSPI_DCR_FSIZE_3                     0x00080000U            /*!< Bit 3 */
N#define  QUADSPI_DCR_FSIZE_4                     0x00100000U            /*!< Bit 4 */
N
N/******************  Bit definition for QUADSPI_SR register  *******************/
N#define  QUADSPI_SR_TEF                          0x00000001U             /*!< Transfer Error Flag    */
N#define  QUADSPI_SR_TCF                          0x00000002U             /*!< Transfer Complete Flag */
N#define  QUADSPI_SR_FTF                          0x00000004U             /*!< FIFO Threshlod Flag    */
N#define  QUADSPI_SR_SMF                          0x00000008U             /*!< Status Match Flag      */
N#define  QUADSPI_SR_TOF                          0x00000010U             /*!< Timeout Flag           */
N#define  QUADSPI_SR_BUSY                         0x00000020U             /*!< Busy                   */
N#define  QUADSPI_SR_FLEVEL                       0x00001F00U             /*!< FIFO Threshlod Flag    */
N#define  QUADSPI_SR_FLEVEL_0                     0x00000100U             /*!< Bit 0 */
N#define  QUADSPI_SR_FLEVEL_1                     0x00000200U             /*!< Bit 1 */
N#define  QUADSPI_SR_FLEVEL_2                     0x00000400U             /*!< Bit 2 */
N#define  QUADSPI_SR_FLEVEL_3                     0x00000800U             /*!< Bit 3 */
N#define  QUADSPI_SR_FLEVEL_4                     0x00001000U             /*!< Bit 4 */
N
N/******************  Bit definition for QUADSPI_FCR register  ******************/
N#define  QUADSPI_FCR_CTEF                        0x00000001U             /*!< Clear Transfer Error Flag    */
N#define  QUADSPI_FCR_CTCF                        0x00000002U             /*!< Clear Transfer Complete Flag */
N#define  QUADSPI_FCR_CSMF                        0x00000008U             /*!< Clear Status Match Flag      */
N#define  QUADSPI_FCR_CTOF                        0x00000010U             /*!< Clear Timeout Flag           */
N
N/******************  Bit definition for QUADSPI_DLR register  ******************/
N#define  QUADSPI_DLR_DL                          0xFFFFFFFFU             /*!< DL[31:0]: Data Length */
N
N/******************  Bit definition for QUADSPI_CCR register  ******************/
N#define  QUADSPI_CCR_INSTRUCTION                  0x000000FFU            /*!< INSTRUCTION[7:0]: Instruction    */
N#define  QUADSPI_CCR_INSTRUCTION_0                0x00000001U            /*!< Bit 0 */
N#define  QUADSPI_CCR_INSTRUCTION_1                0x00000002U            /*!< Bit 1 */
N#define  QUADSPI_CCR_INSTRUCTION_2                0x00000004U            /*!< Bit 2 */
N#define  QUADSPI_CCR_INSTRUCTION_3                0x00000008U            /*!< Bit 3 */
N#define  QUADSPI_CCR_INSTRUCTION_4                0x00000010U            /*!< Bit 4 */
N#define  QUADSPI_CCR_INSTRUCTION_5                0x00000020U            /*!< Bit 5 */
N#define  QUADSPI_CCR_INSTRUCTION_6                0x00000040U            /*!< Bit 6 */
N#define  QUADSPI_CCR_INSTRUCTION_7                0x00000080U            /*!< Bit 7 */
N#define  QUADSPI_CCR_IMODE                        0x00000300U            /*!< IMODE[1:0]: Instruction Mode      */
N#define  QUADSPI_CCR_IMODE_0                      0x00000100U            /*!< Bit 0 */
N#define  QUADSPI_CCR_IMODE_1                      0x00000200U            /*!< Bit 1 */
N#define  QUADSPI_CCR_ADMODE                       0x00000C00U            /*!< ADMODE[1:0]: Address Mode         */
N#define  QUADSPI_CCR_ADMODE_0                     0x00000400U            /*!< Bit 0 */
N#define  QUADSPI_CCR_ADMODE_1                     0x00000800U            /*!< Bit 1 */
N#define  QUADSPI_CCR_ADSIZE                       0x00003000U            /*!< ADSIZE[1:0]: Address Size         */
N#define  QUADSPI_CCR_ADSIZE_0                     0x00001000U            /*!< Bit 0 */
N#define  QUADSPI_CCR_ADSIZE_1                     0x00002000U            /*!< Bit 1 */
N#define  QUADSPI_CCR_ABMODE                       0x0000C000U            /*!< ABMODE[1:0]: Alternate Bytes Mode */
N#define  QUADSPI_CCR_ABMODE_0                     0x00004000U            /*!< Bit 0 */
N#define  QUADSPI_CCR_ABMODE_1                     0x00008000U            /*!< Bit 1 */
N#define  QUADSPI_CCR_ABSIZE                       0x00030000U            /*!< ABSIZE[1:0]: Instruction Mode     */
N#define  QUADSPI_CCR_ABSIZE_0                     0x00010000U            /*!< Bit 0 */
N#define  QUADSPI_CCR_ABSIZE_1                     0x00020000U            /*!< Bit 1 */
N#define  QUADSPI_CCR_DCYC                         0x007C0000U            /*!< DCYC[4:0]: Dummy Cycles           */
N#define  QUADSPI_CCR_DCYC_0                       0x00040000U            /*!< Bit 0 */
N#define  QUADSPI_CCR_DCYC_1                       0x00080000U            /*!< Bit 1 */
N#define  QUADSPI_CCR_DCYC_2                       0x00100000U            /*!< Bit 2 */
N#define  QUADSPI_CCR_DCYC_3                       0x00200000U            /*!< Bit 3 */
N#define  QUADSPI_CCR_DCYC_4                       0x00400000U            /*!< Bit 4 */
N#define  QUADSPI_CCR_DMODE                        0x03000000U            /*!< DMODE[1:0]: Data Mode              */
N#define  QUADSPI_CCR_DMODE_0                      0x01000000U            /*!< Bit 0 */
N#define  QUADSPI_CCR_DMODE_1                      0x02000000U            /*!< Bit 1 */
N#define  QUADSPI_CCR_FMODE                        0x0C000000U            /*!< FMODE[1:0]: Functional Mode        */
N#define  QUADSPI_CCR_FMODE_0                      0x04000000U            /*!< Bit 0 */
N#define  QUADSPI_CCR_FMODE_1                      0x08000000U            /*!< Bit 1 */
N#define  QUADSPI_CCR_SIOO                         0x10000000U            /*!< SIOO: Send Instruction Only Once Mode */
N#define  QUADSPI_CCR_DHHC                         0x40000000U            /*!< DHHC: Delay Half Hclk Cycle           */
N#define  QUADSPI_CCR_DDRM                         0x80000000U            /*!< DDRM: Double Data Rate Mode           */ 
N/******************  Bit definition for QUADSPI_AR register  *******************/
N#define  QUADSPI_AR_ADDRESS                       0xFFFFFFFFU            /*!< ADDRESS[31:0]: Address */
N
N/******************  Bit definition for QUADSPI_ABR register  ******************/
N#define  QUADSPI_ABR_ALTERNATE                    0xFFFFFFFFU            /*!< ALTERNATE[31:0]: Alternate Bytes */
N
N/******************  Bit definition for QUADSPI_DR register  *******************/
N#define  QUADSPI_DR_DATA                          0xFFFFFFFFU            /*!< DATA[31:0]: Data */
N
N/******************  Bit definition for QUADSPI_PSMKR register  ****************/
N#define  QUADSPI_PSMKR_MASK                       0xFFFFFFFFU            /*!< MASK[31:0]: Status Mask */
N
N/******************  Bit definition for QUADSPI_PSMAR register  ****************/
N#define  QUADSPI_PSMAR_MATCH                      0xFFFFFFFFU            /*!< MATCH[31:0]: Status Match */
N
N/******************  Bit definition for QUADSPI_PIR register  *****************/
N#define  QUADSPI_PIR_INTERVAL                     0x0000FFFFU            /*!< INTERVAL[15:0]: Polling Interval */
N
N/******************  Bit definition for QUADSPI_LPTR register  *****************/
N#define  QUADSPI_LPTR_TIMEOUT                     0x0000FFFFU            /*!< TIMEOUT[15:0]: Timeout period */
N
N/******************************************************************************/
N/*                                                                            */
N/*                         Reset and Clock Control            */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for RCC_CR register  ********************/
N#define  RCC_CR_HSION                        0x00000001U
N#define  RCC_CR_HSIRDY                       0x00000002U
N#define  RCC_CR_HSITRIM                      0x000000F8U
N#define  RCC_CR_HSITRIM_0                    0x00000008U /*!<Bit 0 */
N#define  RCC_CR_HSITRIM_1                    0x00000010U /*!<Bit 1 */
N#define  RCC_CR_HSITRIM_2                    0x00000020U /*!<Bit 2 */
N#define  RCC_CR_HSITRIM_3                    0x00000040U /*!<Bit 3 */
N#define  RCC_CR_HSITRIM_4                    0x00000080U /*!<Bit 4 */
N#define  RCC_CR_HSICAL                       0x0000FF00U
N#define  RCC_CR_HSICAL_0                     0x00000100U /*!<Bit 0 */
N#define  RCC_CR_HSICAL_1                     0x00000200U /*!<Bit 1 */
N#define  RCC_CR_HSICAL_2                     0x00000400U /*!<Bit 2 */
N#define  RCC_CR_HSICAL_3                     0x00000800U /*!<Bit 3 */
N#define  RCC_CR_HSICAL_4                     0x00001000U /*!<Bit 4 */
N#define  RCC_CR_HSICAL_5                     0x00002000U /*!<Bit 5 */
N#define  RCC_CR_HSICAL_6                     0x00004000U /*!<Bit 6 */
N#define  RCC_CR_HSICAL_7                     0x00008000U /*!<Bit 7 */
N#define  RCC_CR_HSEON                        0x00010000U
N#define  RCC_CR_HSERDY                       0x00020000U
N#define  RCC_CR_HSEBYP                       0x00040000U
N#define  RCC_CR_CSSON                        0x00080000U
N#define  RCC_CR_PLLON                        0x01000000U
N#define  RCC_CR_PLLRDY                       0x02000000U
N#define  RCC_CR_PLLI2SON                     0x04000000U
N#define  RCC_CR_PLLI2SRDY                    0x08000000U
N#define  RCC_CR_PLLSAION                     0x10000000U
N#define  RCC_CR_PLLSAIRDY                    0x20000000U
N
N/********************  Bit definition for RCC_PLLCFGR register  ***************/
N#define  RCC_PLLCFGR_PLLM                    0x0000003FU
N#define  RCC_PLLCFGR_PLLM_0                  0x00000001U
N#define  RCC_PLLCFGR_PLLM_1                  0x00000002U
N#define  RCC_PLLCFGR_PLLM_2                  0x00000004U
N#define  RCC_PLLCFGR_PLLM_3                  0x00000008U
N#define  RCC_PLLCFGR_PLLM_4                  0x00000010U
N#define  RCC_PLLCFGR_PLLM_5                  0x00000020U
N#define  RCC_PLLCFGR_PLLN                    0x00007FC0U
N#define  RCC_PLLCFGR_PLLN_0                  0x00000040U
N#define  RCC_PLLCFGR_PLLN_1                  0x00000080U
N#define  RCC_PLLCFGR_PLLN_2                  0x00000100U
N#define  RCC_PLLCFGR_PLLN_3                  0x00000200U
N#define  RCC_PLLCFGR_PLLN_4                  0x00000400U
N#define  RCC_PLLCFGR_PLLN_5                  0x00000800U
N#define  RCC_PLLCFGR_PLLN_6                  0x00001000U
N#define  RCC_PLLCFGR_PLLN_7                  0x00002000U
N#define  RCC_PLLCFGR_PLLN_8                  0x00004000U
N#define  RCC_PLLCFGR_PLLP                    0x00030000U
N#define  RCC_PLLCFGR_PLLP_0                  0x00010000U
N#define  RCC_PLLCFGR_PLLP_1                  0x00020000U
N#define  RCC_PLLCFGR_PLLSRC                  0x00400000U
N#define  RCC_PLLCFGR_PLLSRC_HSE              0x00400000U
N#define  RCC_PLLCFGR_PLLSRC_HSI              0x00000000U
N#define  RCC_PLLCFGR_PLLQ                    0x0F000000U
N#define  RCC_PLLCFGR_PLLQ_0                  0x01000000U
N#define  RCC_PLLCFGR_PLLQ_1                  0x02000000U
N#define  RCC_PLLCFGR_PLLQ_2                  0x04000000U
N#define  RCC_PLLCFGR_PLLQ_3                  0x08000000U
N
N#define  RCC_PLLCFGR_PLLR                    0x70000000U
N#define  RCC_PLLCFGR_PLLR_0                  0x10000000U
N#define  RCC_PLLCFGR_PLLR_1                  0x20000000U
N#define  RCC_PLLCFGR_PLLR_2                  0x40000000U
N
N/********************  Bit definition for RCC_CFGR register  ******************/
N/*!< SW configuration */
N#define  RCC_CFGR_SW                         0x00000003U        /*!< SW[1:0] bits (System clock Switch) */
N#define  RCC_CFGR_SW_0                       0x00000001U        /*!< Bit 0 */
N#define  RCC_CFGR_SW_1                       0x00000002U        /*!< Bit 1 */
N#define  RCC_CFGR_SW_HSI                     0x00000000U        /*!< HSI selected as system clock */
N#define  RCC_CFGR_SW_HSE                     0x00000001U        /*!< HSE selected as system clock */
N#define  RCC_CFGR_SW_PLL                     0x00000002U        /*!< PLL selected as system clock */
N
N/*!< SWS configuration */
N#define  RCC_CFGR_SWS                        0x0000000CU        /*!< SWS[1:0] bits (System Clock Switch Status) */
N#define  RCC_CFGR_SWS_0                      0x00000004U        /*!< Bit 0 */
N#define  RCC_CFGR_SWS_1                      0x00000008U        /*!< Bit 1 */
N#define  RCC_CFGR_SWS_HSI                    0x00000000U        /*!< HSI oscillator used as system clock */
N#define  RCC_CFGR_SWS_HSE                    0x00000004U        /*!< HSE oscillator used as system clock */
N#define  RCC_CFGR_SWS_PLL                    0x00000008U        /*!< PLL used as system clock */
N
N/*!< HPRE configuration */
N#define  RCC_CFGR_HPRE                       0x000000F0U        /*!< HPRE[3:0] bits (AHB prescaler) */
N#define  RCC_CFGR_HPRE_0                     0x00000010U        /*!< Bit 0 */
N#define  RCC_CFGR_HPRE_1                     0x00000020U        /*!< Bit 1 */
N#define  RCC_CFGR_HPRE_2                     0x00000040U        /*!< Bit 2 */
N#define  RCC_CFGR_HPRE_3                     0x00000080U        /*!< Bit 3 */
N
N#define  RCC_CFGR_HPRE_DIV1                  0x00000000U        /*!< SYSCLK not divided */
N#define  RCC_CFGR_HPRE_DIV2                  0x00000080U        /*!< SYSCLK divided by 2 */
N#define  RCC_CFGR_HPRE_DIV4                  0x00000090U        /*!< SYSCLK divided by 4 */
N#define  RCC_CFGR_HPRE_DIV8                  0x000000A0U        /*!< SYSCLK divided by 8 */
N#define  RCC_CFGR_HPRE_DIV16                 0x000000B0U        /*!< SYSCLK divided by 16 */
N#define  RCC_CFGR_HPRE_DIV64                 0x000000C0U        /*!< SYSCLK divided by 64 */
N#define  RCC_CFGR_HPRE_DIV128                0x000000D0U        /*!< SYSCLK divided by 128 */
N#define  RCC_CFGR_HPRE_DIV256                0x000000E0U        /*!< SYSCLK divided by 256 */
N#define  RCC_CFGR_HPRE_DIV512                0x000000F0U        /*!< SYSCLK divided by 512 */
N
N/*!< PPRE1 configuration */
N#define  RCC_CFGR_PPRE1                      0x00001C00U        /*!< PRE1[2:0] bits (APB1 prescaler) */
N#define  RCC_CFGR_PPRE1_0                    0x00000400U        /*!< Bit 0 */
N#define  RCC_CFGR_PPRE1_1                    0x00000800U        /*!< Bit 1 */
N#define  RCC_CFGR_PPRE1_2                    0x00001000U        /*!< Bit 2 */
N
N#define  RCC_CFGR_PPRE1_DIV1                 0x00000000U        /*!< HCLK not divided */
N#define  RCC_CFGR_PPRE1_DIV2                 0x00001000U        /*!< HCLK divided by 2 */
N#define  RCC_CFGR_PPRE1_DIV4                 0x00001400U        /*!< HCLK divided by 4 */
N#define  RCC_CFGR_PPRE1_DIV8                 0x00001800U        /*!< HCLK divided by 8 */
N#define  RCC_CFGR_PPRE1_DIV16                0x00001C00U        /*!< HCLK divided by 16 */
N
N/*!< PPRE2 configuration */
N#define  RCC_CFGR_PPRE2                      0x0000E000U        /*!< PRE2[2:0] bits (APB2 prescaler) */
N#define  RCC_CFGR_PPRE2_0                    0x00002000U        /*!< Bit 0 */
N#define  RCC_CFGR_PPRE2_1                    0x00004000U        /*!< Bit 1 */
N#define  RCC_CFGR_PPRE2_2                    0x00008000U        /*!< Bit 2 */
N
N#define  RCC_CFGR_PPRE2_DIV1                 0x00000000U        /*!< HCLK not divided */
N#define  RCC_CFGR_PPRE2_DIV2                 0x00008000U        /*!< HCLK divided by 2 */
N#define  RCC_CFGR_PPRE2_DIV4                 0x0000A000U        /*!< HCLK divided by 4 */
N#define  RCC_CFGR_PPRE2_DIV8                 0x0000C000U        /*!< HCLK divided by 8 */
N#define  RCC_CFGR_PPRE2_DIV16                0x0000E000U        /*!< HCLK divided by 16 */
N
N/*!< RTCPRE configuration */
N#define  RCC_CFGR_RTCPRE                     0x001F0000U
N#define  RCC_CFGR_RTCPRE_0                   0x00010000U
N#define  RCC_CFGR_RTCPRE_1                   0x00020000U
N#define  RCC_CFGR_RTCPRE_2                   0x00040000U
N#define  RCC_CFGR_RTCPRE_3                   0x00080000U
N#define  RCC_CFGR_RTCPRE_4                   0x00100000U
N
N/*!< MCO1 configuration */
N#define  RCC_CFGR_MCO1                       0x00600000U
N#define  RCC_CFGR_MCO1_0                     0x00200000U
N#define  RCC_CFGR_MCO1_1                     0x00400000U
N
N#define  RCC_CFGR_I2SSRC                     0x00800000U
N
N#define  RCC_CFGR_MCO1PRE                    0x07000000U
N#define  RCC_CFGR_MCO1PRE_0                  0x01000000U
N#define  RCC_CFGR_MCO1PRE_1                  0x02000000U
N#define  RCC_CFGR_MCO1PRE_2                  0x04000000U
N
N#define  RCC_CFGR_MCO2PRE                    0x38000000U
N#define  RCC_CFGR_MCO2PRE_0                  0x08000000U
N#define  RCC_CFGR_MCO2PRE_1                  0x10000000U
N#define  RCC_CFGR_MCO2PRE_2                  0x20000000U
N
N#define  RCC_CFGR_MCO2                       0xC0000000U
N#define  RCC_CFGR_MCO2_0                     0x40000000U
N#define  RCC_CFGR_MCO2_1                     0x80000000U
N
N/********************  Bit definition for RCC_CIR register  *******************/
N#define  RCC_CIR_LSIRDYF                     0x00000001U
N#define  RCC_CIR_LSERDYF                     0x00000002U
N#define  RCC_CIR_HSIRDYF                     0x00000004U
N#define  RCC_CIR_HSERDYF                     0x00000008U
N#define  RCC_CIR_PLLRDYF                     0x00000010U
N#define  RCC_CIR_PLLI2SRDYF                  0x00000020U
N#define  RCC_CIR_PLLSAIRDYF                  0x00000040U
N#define  RCC_CIR_CSSF                        0x00000080U
N#define  RCC_CIR_LSIRDYIE                    0x00000100U
N#define  RCC_CIR_LSERDYIE                    0x00000200U
N#define  RCC_CIR_HSIRDYIE                    0x00000400U
N#define  RCC_CIR_HSERDYIE                    0x00000800U
N#define  RCC_CIR_PLLRDYIE                    0x00001000U
N#define  RCC_CIR_PLLI2SRDYIE                 0x00002000U
N#define  RCC_CIR_PLLSAIRDYIE                 0x00004000U
N#define  RCC_CIR_LSIRDYC                     0x00010000U
N#define  RCC_CIR_LSERDYC                     0x00020000U
N#define  RCC_CIR_HSIRDYC                     0x00040000U
N#define  RCC_CIR_HSERDYC                     0x00080000U
N#define  RCC_CIR_PLLRDYC                     0x00100000U
N#define  RCC_CIR_PLLI2SRDYC                  0x00200000U
N#define  RCC_CIR_PLLSAIRDYC                  0x00400000U
N#define  RCC_CIR_CSSC                        0x00800000U
N
N/********************  Bit definition for RCC_AHB1RSTR register  **************/
N#define  RCC_AHB1RSTR_GPIOARST               0x00000001U
N#define  RCC_AHB1RSTR_GPIOBRST               0x00000002U
N#define  RCC_AHB1RSTR_GPIOCRST               0x00000004U
N#define  RCC_AHB1RSTR_GPIODRST               0x00000008U
N#define  RCC_AHB1RSTR_GPIOERST               0x00000010U
N#define  RCC_AHB1RSTR_GPIOFRST               0x00000020U
N#define  RCC_AHB1RSTR_GPIOGRST               0x00000040U
N#define  RCC_AHB1RSTR_GPIOHRST               0x00000080U
N#define  RCC_AHB1RSTR_GPIOIRST               0x00000100U
N#define  RCC_AHB1RSTR_GPIOJRST               0x00000200U
N#define  RCC_AHB1RSTR_GPIOKRST               0x00000400U
N#define  RCC_AHB1RSTR_CRCRST                 0x00001000U
N#define  RCC_AHB1RSTR_DMA1RST                0x00200000U
N#define  RCC_AHB1RSTR_DMA2RST                0x00400000U
N#define  RCC_AHB1RSTR_DMA2DRST               0x00800000U
N#define  RCC_AHB1RSTR_ETHMACRST              0x02000000U
N#define  RCC_AHB1RSTR_OTGHRST                0x20000000U
N
N/********************  Bit definition for RCC_AHB2RSTR register  **************/
N#define  RCC_AHB2RSTR_DCMIRST                0x00000001U
N#define  RCC_AHB2RSTR_JPEGRST                0x00000002U
N#define  RCC_AHB2RSTR_RNGRST                 0x00000040U
N#define  RCC_AHB2RSTR_OTGFSRST               0x00000080U
N
N/********************  Bit definition for RCC_AHB3RSTR register  **************/
N
N#define  RCC_AHB3RSTR_FMCRST                 0x00000001U
N#define  RCC_AHB3RSTR_QSPIRST                0x00000002U
N
N/********************  Bit definition for RCC_APB1RSTR register  **************/
N#define  RCC_APB1RSTR_TIM2RST                0x00000001U
N#define  RCC_APB1RSTR_TIM3RST                0x00000002U
N#define  RCC_APB1RSTR_TIM4RST                0x00000004U
N#define  RCC_APB1RSTR_TIM5RST                0x00000008U
N#define  RCC_APB1RSTR_TIM6RST                0x00000010U
N#define  RCC_APB1RSTR_TIM7RST                0x00000020U
N#define  RCC_APB1RSTR_TIM12RST               0x00000040U
N#define  RCC_APB1RSTR_TIM13RST               0x00000080U
N#define  RCC_APB1RSTR_TIM14RST               0x00000100U
N#define  RCC_APB1RSTR_LPTIM1RST              0x00000200U
N#define  RCC_APB1RSTR_WWDGRST                0x00000800U
N#define  RCC_APB1RSTR_CAN3RST                0x00002000U
N#define  RCC_APB1RSTR_SPI2RST                0x00004000U
N#define  RCC_APB1RSTR_SPI3RST                0x00008000U
N#define  RCC_APB1RSTR_SPDIFRXRST             0x00010000U
N#define  RCC_APB1RSTR_USART2RST              0x00020000U
N#define  RCC_APB1RSTR_USART3RST              0x00040000U
N#define  RCC_APB1RSTR_UART4RST               0x00080000U
N#define  RCC_APB1RSTR_UART5RST               0x00100000U
N#define  RCC_APB1RSTR_I2C1RST                0x00200000U
N#define  RCC_APB1RSTR_I2C2RST                0x00400000U
N#define  RCC_APB1RSTR_I2C3RST                0x00800000U
N#define  RCC_APB1RSTR_I2C4RST                0x01000000U
N#define  RCC_APB1RSTR_CAN1RST                0x02000000U
N#define  RCC_APB1RSTR_CAN2RST                0x04000000U
N#define  RCC_APB1RSTR_CECRST                 0x08000000U
N#define  RCC_APB1RSTR_PWRRST                 0x10000000U
N#define  RCC_APB1RSTR_DACRST                 0x20000000U
N#define  RCC_APB1RSTR_UART7RST               0x40000000U
N#define  RCC_APB1RSTR_UART8RST               0x80000000U
N
N/********************  Bit definition for RCC_APB2RSTR register  **************/
N#define  RCC_APB2RSTR_TIM1RST                0x00000001U
N#define  RCC_APB2RSTR_TIM8RST                0x00000002U
N#define  RCC_APB2RSTR_USART1RST              0x00000010U
N#define  RCC_APB2RSTR_USART6RST              0x00000020U
N#define  RCC_APB2RSTR_SDMMC2RST              0x00000080U
N#define  RCC_APB2RSTR_ADCRST                 0x00000100U
N#define  RCC_APB2RSTR_SDMMC1RST              0x00000800U
N#define  RCC_APB2RSTR_SPI1RST                0x00001000U
N#define  RCC_APB2RSTR_SPI4RST                0x00002000U
N#define  RCC_APB2RSTR_SYSCFGRST              0x00004000U
N#define  RCC_APB2RSTR_TIM9RST                0x00010000U
N#define  RCC_APB2RSTR_TIM10RST               0x00020000U
N#define  RCC_APB2RSTR_TIM11RST               0x00040000U
N#define  RCC_APB2RSTR_SPI5RST                0x00100000U
N#define  RCC_APB2RSTR_SPI6RST                0x00200000U
N#define  RCC_APB2RSTR_SAI1RST                0x00400000U
N#define  RCC_APB2RSTR_SAI2RST                0x00800000U
N#define  RCC_APB2RSTR_LTDCRST                0x04000000U
N#define  RCC_APB2RSTR_DFSDM1RST              0x20000000U
N#define  RCC_APB2RSTR_MDIORST                0x40000000U
N
N/********************  Bit definition for RCC_AHB1ENR register  ***************/
N#define  RCC_AHB1ENR_GPIOAEN                 0x00000001U
N#define  RCC_AHB1ENR_GPIOBEN                 0x00000002U
N#define  RCC_AHB1ENR_GPIOCEN                 0x00000004U
N#define  RCC_AHB1ENR_GPIODEN                 0x00000008U
N#define  RCC_AHB1ENR_GPIOEEN                 0x00000010U
N#define  RCC_AHB1ENR_GPIOFEN                 0x00000020U
N#define  RCC_AHB1ENR_GPIOGEN                 0x00000040U
N#define  RCC_AHB1ENR_GPIOHEN                 0x00000080U
N#define  RCC_AHB1ENR_GPIOIEN                 0x00000100U
N#define  RCC_AHB1ENR_GPIOJEN                 0x00000200U
N#define  RCC_AHB1ENR_GPIOKEN                 0x00000400U
N#define  RCC_AHB1ENR_CRCEN                   0x00001000U
N#define  RCC_AHB1ENR_BKPSRAMEN               0x00040000U
N#define  RCC_AHB1ENR_DTCMRAMEN               0x00100000U
N#define  RCC_AHB1ENR_DMA1EN                  0x00200000U
N#define  RCC_AHB1ENR_DMA2EN                  0x00400000U
N#define  RCC_AHB1ENR_DMA2DEN                 0x00800000U
N#define  RCC_AHB1ENR_ETHMACEN                0x02000000U
N#define  RCC_AHB1ENR_ETHMACTXEN              0x04000000U
N#define  RCC_AHB1ENR_ETHMACRXEN              0x08000000U
N#define  RCC_AHB1ENR_ETHMACPTPEN             0x10000000U
N#define  RCC_AHB1ENR_OTGHSEN                 0x20000000U
N#define  RCC_AHB1ENR_OTGHSULPIEN             0x40000000U
N
N/********************  Bit definition for RCC_AHB2ENR register  ***************/
N#define  RCC_AHB2ENR_DCMIEN                  0x00000001U
N#define  RCC_AHB2ENR_JPEGEN                  0x00000002U
N#define  RCC_AHB2ENR_RNGEN                   0x00000040U
N#define  RCC_AHB2ENR_OTGFSEN                 0x00000080U
N
N/********************  Bit definition for RCC_AHB3ENR register  ***************/
N#define  RCC_AHB3ENR_FMCEN                  0x00000001U
N#define  RCC_AHB3ENR_QSPIEN                 0x00000002U
N
N/********************  Bit definition for RCC_APB1ENR register  ***************/
N#define  RCC_APB1ENR_TIM2EN                  0x00000001U
N#define  RCC_APB1ENR_TIM3EN                  0x00000002U
N#define  RCC_APB1ENR_TIM4EN                  0x00000004U
N#define  RCC_APB1ENR_TIM5EN                  0x00000008U
N#define  RCC_APB1ENR_TIM6EN                  0x00000010U
N#define  RCC_APB1ENR_TIM7EN                  0x00000020U
N#define  RCC_APB1ENR_TIM12EN                 0x00000040U
N#define  RCC_APB1ENR_TIM13EN                 0x00000080U
N#define  RCC_APB1ENR_TIM14EN                 0x00000100U
N#define  RCC_APB1ENR_LPTIM1EN                0x00000200U
N#define  RCC_APB1ENR_RTCEN                   0x00000400U
N#define  RCC_APB1ENR_WWDGEN                  0x00000800U
N#define  RCC_APB1ENR_CAN3EN                  0x00002000U
N#define  RCC_APB1ENR_SPI2EN                  0x00004000U
N#define  RCC_APB1ENR_SPI3EN                  0x00008000U
N#define  RCC_APB1ENR_SPDIFRXEN               0x00010000U
N#define  RCC_APB1ENR_USART2EN                0x00020000U
N#define  RCC_APB1ENR_USART3EN                0x00040000U
N#define  RCC_APB1ENR_UART4EN                 0x00080000U
N#define  RCC_APB1ENR_UART5EN                 0x00100000U
N#define  RCC_APB1ENR_I2C1EN                  0x00200000U
N#define  RCC_APB1ENR_I2C2EN                  0x00400000U
N#define  RCC_APB1ENR_I2C3EN                  0x00800000U
N#define  RCC_APB1ENR_I2C4EN                  0x01000000U
N#define  RCC_APB1ENR_CAN1EN                  0x02000000U
N#define  RCC_APB1ENR_CAN2EN                  0x04000000U
N#define  RCC_APB1ENR_CECEN                   0x08000000U
N#define  RCC_APB1ENR_PWREN                   0x10000000U
N#define  RCC_APB1ENR_DACEN                   0x20000000U
N#define  RCC_APB1ENR_UART7EN                 0x40000000U
N#define  RCC_APB1ENR_UART8EN                 0x80000000U
N
N/********************  Bit definition for RCC_APB2ENR register  ***************/
N#define  RCC_APB2ENR_TIM1EN                  0x00000001U
N#define  RCC_APB2ENR_TIM8EN                  0x00000002U
N#define  RCC_APB2ENR_USART1EN                0x00000010U
N#define  RCC_APB2ENR_USART6EN                0x00000020U
N#define  RCC_APB2ENR_SDMMC2EN                0x00000080U
N#define  RCC_APB2ENR_ADC1EN                  0x00000100U
N#define  RCC_APB2ENR_ADC2EN                  0x00000200U
N#define  RCC_APB2ENR_ADC3EN                  0x00000400U
N#define  RCC_APB2ENR_SDMMC1EN                0x00000800U
N#define  RCC_APB2ENR_SPI1EN                  0x00001000U
N#define  RCC_APB2ENR_SPI4EN                  0x00002000U
N#define  RCC_APB2ENR_SYSCFGEN                0x00004000U
N#define  RCC_APB2ENR_TIM9EN                  0x00010000U
N#define  RCC_APB2ENR_TIM10EN                 0x00020000U
N#define  RCC_APB2ENR_TIM11EN                 0x00040000U
N#define  RCC_APB2ENR_SPI5EN                  0x00100000U
N#define  RCC_APB2ENR_SPI6EN                  0x00200000U
N#define  RCC_APB2ENR_SAI1EN                  0x00400000U
N#define  RCC_APB2ENR_SAI2EN                  0x00800000U
N#define  RCC_APB2ENR_LTDCEN                  0x04000000U
N#define  RCC_APB2ENR_DFSDM1EN                0x20000000U
N#define  RCC_APB2ENR_MDIOEN                  0x40000000U
N
N/********************  Bit definition for RCC_AHB1LPENR register  *************/
N#define  RCC_AHB1LPENR_GPIOALPEN             0x00000001U
N#define  RCC_AHB1LPENR_GPIOBLPEN             0x00000002U
N#define  RCC_AHB1LPENR_GPIOCLPEN             0x00000004U
N#define  RCC_AHB1LPENR_GPIODLPEN             0x00000008U
N#define  RCC_AHB1LPENR_GPIOELPEN             0x00000010U
N#define  RCC_AHB1LPENR_GPIOFLPEN             0x00000020U
N#define  RCC_AHB1LPENR_GPIOGLPEN             0x00000040U
N#define  RCC_AHB1LPENR_GPIOHLPEN             0x00000080U
N#define  RCC_AHB1LPENR_GPIOILPEN             0x00000100U
N#define  RCC_AHB1LPENR_GPIOJLPEN             0x00000200U
N#define  RCC_AHB1LPENR_GPIOKLPEN             0x00000400U
N#define  RCC_AHB1LPENR_CRCLPEN               0x00001000U
N#define  RCC_AHB1LPENR_AXILPEN               0x00002000U
N#define  RCC_AHB1LPENR_FLITFLPEN             0x00008000U
N#define  RCC_AHB1LPENR_SRAM1LPEN             0x00010000U
N#define  RCC_AHB1LPENR_SRAM2LPEN             0x00020000U
N#define  RCC_AHB1LPENR_BKPSRAMLPEN           0x00040000U
N#define  RCC_AHB1LPENR_DTCMLPEN              0x00100000U
N#define  RCC_AHB1LPENR_DMA1LPEN              0x00200000U
N#define  RCC_AHB1LPENR_DMA2LPEN              0x00400000U
N#define  RCC_AHB1LPENR_DMA2DLPEN             0x00800000U
N#define  RCC_AHB1LPENR_ETHMACLPEN            0x02000000U
N#define  RCC_AHB1LPENR_ETHMACTXLPEN          0x04000000U
N#define  RCC_AHB1LPENR_ETHMACRXLPEN          0x08000000U
N#define  RCC_AHB1LPENR_ETHMACPTPLPEN         0x10000000U
N#define  RCC_AHB1LPENR_OTGHSLPEN             0x20000000U
N#define  RCC_AHB1LPENR_OTGHSULPILPEN         0x40000000U
N
N/********************  Bit definition for RCC_AHB2LPENR register  *************/
N#define  RCC_AHB2LPENR_DCMILPEN              0x00000001U
N#define  RCC_AHB2LPENR_JPEGLPEN              0x00000002U
N#define  RCC_AHB2LPENR_RNGLPEN               0x00000040U
N#define  RCC_AHB2LPENR_OTGFSLPEN             0x00000080U
N
N/********************  Bit definition for RCC_AHB3LPENR register  *************/
N#define  RCC_AHB3LPENR_FMCLPEN               0x00000001U
N#define  RCC_AHB3LPENR_QSPILPEN              0x00000002U
N/********************  Bit definition for RCC_APB1LPENR register  *************/
N#define  RCC_APB1LPENR_TIM2LPEN              0x00000001U
N#define  RCC_APB1LPENR_TIM3LPEN              0x00000002U
N#define  RCC_APB1LPENR_TIM4LPEN              0x00000004U
N#define  RCC_APB1LPENR_TIM5LPEN              0x00000008U
N#define  RCC_APB1LPENR_TIM6LPEN              0x00000010U
N#define  RCC_APB1LPENR_TIM7LPEN              0x00000020U
N#define  RCC_APB1LPENR_TIM12LPEN             0x00000040U
N#define  RCC_APB1LPENR_TIM13LPEN             0x00000080U
N#define  RCC_APB1LPENR_TIM14LPEN             0x00000100U
N#define  RCC_APB1LPENR_LPTIM1LPEN            0x00000200U
N#define  RCC_APB1LPENR_RTCLPEN               0x00000400U
N#define  RCC_APB1LPENR_WWDGLPEN              0x00000800U
N#define  RCC_APB1LPENR_CAN3LPEN              0x00002000U
N#define  RCC_APB1LPENR_SPI2LPEN              0x00004000U
N#define  RCC_APB1LPENR_SPI3LPEN              0x00008000U
N#define  RCC_APB1LPENR_SPDIFRXLPEN           0x00010000U
N#define  RCC_APB1LPENR_USART2LPEN            0x00020000U
N#define  RCC_APB1LPENR_USART3LPEN            0x00040000U
N#define  RCC_APB1LPENR_UART4LPEN             0x00080000U
N#define  RCC_APB1LPENR_UART5LPEN             0x00100000U
N#define  RCC_APB1LPENR_I2C1LPEN              0x00200000U
N#define  RCC_APB1LPENR_I2C2LPEN              0x00400000U
N#define  RCC_APB1LPENR_I2C3LPEN              0x00800000U
N#define  RCC_APB1LPENR_I2C4LPEN              0x01000000U
N#define  RCC_APB1LPENR_CAN1LPEN              0x02000000U
N#define  RCC_APB1LPENR_CAN2LPEN              0x04000000U
N#define  RCC_APB1LPENR_CECLPEN               0x08000000U
N#define  RCC_APB1LPENR_PWRLPEN               0x10000000U
N#define  RCC_APB1LPENR_DACLPEN               0x20000000U
N#define  RCC_APB1LPENR_UART7LPEN             0x40000000U
N#define  RCC_APB1LPENR_UART8LPEN             0x80000000U
N
N/********************  Bit definition for RCC_APB2LPENR register  *************/
N#define  RCC_APB2LPENR_TIM1LPEN              0x00000001U
N#define  RCC_APB2LPENR_TIM8LPEN              0x00000002U
N#define  RCC_APB2LPENR_USART1LPEN            0x00000010U
N#define  RCC_APB2LPENR_USART6LPEN            0x00000020U
N#define  RCC_APB2LPENR_SDMMC2LPEN            0x00000080U
N#define  RCC_APB2LPENR_ADC1LPEN              0x00000100U
N#define  RCC_APB2LPENR_ADC2LPEN              0x00000200U
N#define  RCC_APB2LPENR_ADC3LPEN              0x00000400U
N#define  RCC_APB2LPENR_SDMMC1LPEN            0x00000800U
N#define  RCC_APB2LPENR_SPI1LPEN              0x00001000U
N#define  RCC_APB2LPENR_SPI4LPEN              0x00002000U
N#define  RCC_APB2LPENR_SYSCFGLPEN            0x00004000U
N#define  RCC_APB2LPENR_TIM9LPEN              0x00010000U
N#define  RCC_APB2LPENR_TIM10LPEN             0x00020000U
N#define  RCC_APB2LPENR_TIM11LPEN             0x00040000U
N#define  RCC_APB2LPENR_SPI5LPEN              0x00100000U
N#define  RCC_APB2LPENR_SPI6LPEN              0x00200000U
N#define  RCC_APB2LPENR_SAI1LPEN              0x00400000U
N#define  RCC_APB2LPENR_SAI2LPEN              0x00800000U
N#define  RCC_APB2LPENR_LTDCLPEN              0x04000000U
N#define  RCC_APB2LPENR_DFSDM1LPEN            0x20000000U
N#define  RCC_APB2LPENR_MDIOLPEN              0x40000000U
N
N/********************  Bit definition for RCC_BDCR register  ******************/
N#define  RCC_BDCR_LSEON                      0x00000001U
N#define  RCC_BDCR_LSERDY                     0x00000002U
N#define  RCC_BDCR_LSEBYP                     0x00000004U
N#define  RCC_BDCR_LSEDRV                     0x00000018U
N#define  RCC_BDCR_LSEDRV_0                   0x00000008U
N#define  RCC_BDCR_LSEDRV_1                   0x00000010U
N#define  RCC_BDCR_RTCSEL                     0x00000300U
N#define  RCC_BDCR_RTCSEL_0                   0x00000100U
N#define  RCC_BDCR_RTCSEL_1                   0x00000200U
N#define  RCC_BDCR_RTCEN                      0x00008000U
N#define  RCC_BDCR_BDRST                      0x00010000U
N
N/********************  Bit definition for RCC_CSR register  *******************/
N#define  RCC_CSR_LSION                       0x00000001U
N#define  RCC_CSR_LSIRDY                      0x00000002U
N#define  RCC_CSR_RMVF                        0x01000000U
N#define  RCC_CSR_BORRSTF                     0x02000000U
N#define  RCC_CSR_PINRSTF                     0x04000000U
N#define  RCC_CSR_PORRSTF                     0x08000000U
N#define  RCC_CSR_SFTRSTF                     0x10000000U
N#define  RCC_CSR_IWDGRSTF                    0x20000000U
N#define  RCC_CSR_WWDGRSTF                    0x40000000U
N#define  RCC_CSR_LPWRRSTF                    0x80000000U
N
N/********************  Bit definition for RCC_SSCGR register  *****************/
N#define  RCC_SSCGR_MODPER                    0x00001FFFU
N#define  RCC_SSCGR_INCSTEP                   0x0FFFE000U
N#define  RCC_SSCGR_SPREADSEL                 0x40000000U
N#define  RCC_SSCGR_SSCGEN                    0x80000000U
N
N/********************  Bit definition for RCC_PLLI2SCFGR register  ************/
N#define  RCC_PLLI2SCFGR_PLLI2SN              0x00007FC0U
N#define  RCC_PLLI2SCFGR_PLLI2SN_0            0x00000040U
N#define  RCC_PLLI2SCFGR_PLLI2SN_1            0x00000080U
N#define  RCC_PLLI2SCFGR_PLLI2SN_2            0x00000100U
N#define  RCC_PLLI2SCFGR_PLLI2SN_3            0x00000200U
N#define  RCC_PLLI2SCFGR_PLLI2SN_4            0x00000400U
N#define  RCC_PLLI2SCFGR_PLLI2SN_5            0x00000800U
N#define  RCC_PLLI2SCFGR_PLLI2SN_6            0x00001000U
N#define  RCC_PLLI2SCFGR_PLLI2SN_7            0x00002000U
N#define  RCC_PLLI2SCFGR_PLLI2SN_8            0x00004000U
N#define  RCC_PLLI2SCFGR_PLLI2SP              0x00030000U
N#define  RCC_PLLI2SCFGR_PLLI2SP_0            0x00010000U
N#define  RCC_PLLI2SCFGR_PLLI2SP_1            0x00020000U
N#define  RCC_PLLI2SCFGR_PLLI2SQ              0x0F000000U
N#define  RCC_PLLI2SCFGR_PLLI2SQ_0            0x01000000U
N#define  RCC_PLLI2SCFGR_PLLI2SQ_1            0x02000000U
N#define  RCC_PLLI2SCFGR_PLLI2SQ_2            0x04000000U
N#define  RCC_PLLI2SCFGR_PLLI2SQ_3            0x08000000U
N#define  RCC_PLLI2SCFGR_PLLI2SR              0x70000000U
N#define  RCC_PLLI2SCFGR_PLLI2SR_0            0x10000000U
N#define  RCC_PLLI2SCFGR_PLLI2SR_1            0x20000000U
N#define  RCC_PLLI2SCFGR_PLLI2SR_2            0x40000000U
N
N/********************  Bit definition for RCC_PLLSAICFGR register  ************/
N#define  RCC_PLLSAICFGR_PLLSAIN              0x00007FC0U
N#define  RCC_PLLSAICFGR_PLLSAIN_0            0x00000040U
N#define  RCC_PLLSAICFGR_PLLSAIN_1            0x00000080U
N#define  RCC_PLLSAICFGR_PLLSAIN_2            0x00000100U
N#define  RCC_PLLSAICFGR_PLLSAIN_3            0x00000200U
N#define  RCC_PLLSAICFGR_PLLSAIN_4            0x00000400U
N#define  RCC_PLLSAICFGR_PLLSAIN_5            0x00000800U
N#define  RCC_PLLSAICFGR_PLLSAIN_6            0x00001000U
N#define  RCC_PLLSAICFGR_PLLSAIN_7            0x00002000U
N#define  RCC_PLLSAICFGR_PLLSAIN_8            0x00004000U
N#define  RCC_PLLSAICFGR_PLLSAIP              0x00030000U
N#define  RCC_PLLSAICFGR_PLLSAIP_0            0x00010000U
N#define  RCC_PLLSAICFGR_PLLSAIP_1            0x00020000U
N#define  RCC_PLLSAICFGR_PLLSAIQ              0x0F000000U
N#define  RCC_PLLSAICFGR_PLLSAIQ_0            0x01000000U
N#define  RCC_PLLSAICFGR_PLLSAIQ_1            0x02000000U
N#define  RCC_PLLSAICFGR_PLLSAIQ_2            0x04000000U
N#define  RCC_PLLSAICFGR_PLLSAIQ_3            0x08000000U
N#define  RCC_PLLSAICFGR_PLLSAIR              0x70000000U
N#define  RCC_PLLSAICFGR_PLLSAIR_0            0x10000000U
N#define  RCC_PLLSAICFGR_PLLSAIR_1            0x20000000U
N#define  RCC_PLLSAICFGR_PLLSAIR_2            0x40000000U
N
N/********************  Bit definition for RCC_DCKCFGR1 register  ***************/
N#define  RCC_DCKCFGR1_PLLI2SDIVQ             0x0000001FU
N#define  RCC_DCKCFGR1_PLLI2SDIVQ_0           0x00000001U
N#define  RCC_DCKCFGR1_PLLI2SDIVQ_1           0x00000002U
N#define  RCC_DCKCFGR1_PLLI2SDIVQ_2           0x00000004U
N#define  RCC_DCKCFGR1_PLLI2SDIVQ_3           0x00000008U
N#define  RCC_DCKCFGR1_PLLI2SDIVQ_4           0x00000010U
N
N#define  RCC_DCKCFGR1_PLLSAIDIVQ             0x00001F00U
N#define  RCC_DCKCFGR1_PLLSAIDIVQ_0           0x00000100U
N#define  RCC_DCKCFGR1_PLLSAIDIVQ_1           0x00000200U
N#define  RCC_DCKCFGR1_PLLSAIDIVQ_2           0x00000400U
N#define  RCC_DCKCFGR1_PLLSAIDIVQ_3           0x00000800U
N#define  RCC_DCKCFGR1_PLLSAIDIVQ_4           0x00001000U
N
N#define  RCC_DCKCFGR1_PLLSAIDIVR             0x00030000U
N#define  RCC_DCKCFGR1_PLLSAIDIVR_0           0x00010000U
N#define  RCC_DCKCFGR1_PLLSAIDIVR_1           0x00020000U
N
N#define  RCC_DCKCFGR1_SAI1SEL                0x00300000U
N#define  RCC_DCKCFGR1_SAI1SEL_0              0x00100000U
N#define  RCC_DCKCFGR1_SAI1SEL_1              0x00200000U
N
N#define  RCC_DCKCFGR1_SAI2SEL                0x00C00000U
N#define  RCC_DCKCFGR1_SAI2SEL_0              0x00400000U
N#define  RCC_DCKCFGR1_SAI2SEL_1              0x00800000U
N
N#define  RCC_DCKCFGR1_TIMPRE                 0x01000000U
N#define  RCC_DCKCFGR1_DFSDM1SEL              0x02000000U
N#define  RCC_DCKCFGR1_ADFSDM1SEL             0x04000000U
N
N/********************  Bit definition for RCC_DCKCFGR2 register  ***************/
N#define  RCC_DCKCFGR2_USART1SEL              0x00000003U
N#define  RCC_DCKCFGR2_USART1SEL_0            0x00000001U
N#define  RCC_DCKCFGR2_USART1SEL_1            0x00000002U
N#define  RCC_DCKCFGR2_USART2SEL              0x0000000CU
N#define  RCC_DCKCFGR2_USART2SEL_0            0x00000004U
N#define  RCC_DCKCFGR2_USART2SEL_1            0x00000008U
N#define  RCC_DCKCFGR2_USART3SEL              0x00000030U
N#define  RCC_DCKCFGR2_USART3SEL_0            0x00000010U
N#define  RCC_DCKCFGR2_USART3SEL_1            0x00000020U
N#define  RCC_DCKCFGR2_UART4SEL               0x000000C0U
N#define  RCC_DCKCFGR2_UART4SEL_0             0x00000040U
N#define  RCC_DCKCFGR2_UART4SEL_1             0x00000080U
N#define  RCC_DCKCFGR2_UART5SEL               0x00000300U
N#define  RCC_DCKCFGR2_UART5SEL_0             0x00000100U
N#define  RCC_DCKCFGR2_UART5SEL_1             0x00000200U
N#define  RCC_DCKCFGR2_USART6SEL              0x00000C00U
N#define  RCC_DCKCFGR2_USART6SEL_0            0x00000400U
N#define  RCC_DCKCFGR2_USART6SEL_1            0x00000800U
N#define  RCC_DCKCFGR2_UART7SEL               0x00003000U
N#define  RCC_DCKCFGR2_UART7SEL_0             0x00001000U
N#define  RCC_DCKCFGR2_UART7SEL_1             0x00002000U
N#define  RCC_DCKCFGR2_UART8SEL               0x0000C000U
N#define  RCC_DCKCFGR2_UART8SEL_0             0x00004000U
N#define  RCC_DCKCFGR2_UART8SEL_1             0x00008000U
N#define  RCC_DCKCFGR2_I2C1SEL                0x00030000U
N#define  RCC_DCKCFGR2_I2C1SEL_0              0x00010000U
N#define  RCC_DCKCFGR2_I2C1SEL_1              0x00020000U
N#define  RCC_DCKCFGR2_I2C2SEL                0x000C0000U
N#define  RCC_DCKCFGR2_I2C2SEL_0              0x00040000U
N#define  RCC_DCKCFGR2_I2C2SEL_1              0x00080000U
N#define  RCC_DCKCFGR2_I2C3SEL                0x00300000U
N#define  RCC_DCKCFGR2_I2C3SEL_0              0x00100000U
N#define  RCC_DCKCFGR2_I2C3SEL_1              0x00200000U
N#define  RCC_DCKCFGR2_I2C4SEL                0x00C00000U
N#define  RCC_DCKCFGR2_I2C4SEL_0              0x00400000U
N#define  RCC_DCKCFGR2_I2C4SEL_1              0x00800000U
N#define  RCC_DCKCFGR2_LPTIM1SEL              0x03000000U
N#define  RCC_DCKCFGR2_LPTIM1SEL_0            0x01000000U
N#define  RCC_DCKCFGR2_LPTIM1SEL_1            0x02000000U
N#define  RCC_DCKCFGR2_CECSEL                 0x04000000U
N#define  RCC_DCKCFGR2_CK48MSEL               0x08000000U
N#define  RCC_DCKCFGR2_SDMMC1SEL              0x10000000U
N#define  RCC_DCKCFGR2_SDMMC2SEL              0x20000000U
N
N/******************************************************************************/
N/*                                                                            */
N/*                                    RNG                                     */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bits definition for RNG_CR register  *******************/
N#define RNG_CR_RNGEN                         0x00000004U
N#define RNG_CR_IE                            0x00000008U
N
N/********************  Bits definition for RNG_SR register  *******************/
N#define RNG_SR_DRDY                          0x00000001U
N#define RNG_SR_CECS                          0x00000002U
N#define RNG_SR_SECS                          0x00000004U
N#define RNG_SR_CEIS                          0x00000020U
N#define RNG_SR_SEIS                          0x00000040U
N
N/******************************************************************************/
N/*                                                                            */
N/*                           Real-Time Clock (RTC)                            */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bits definition for RTC_TR register  *******************/
N#define RTC_TR_PM                            0x00400000U
N#define RTC_TR_HT                            0x00300000U
N#define RTC_TR_HT_0                          0x00100000U
N#define RTC_TR_HT_1                          0x00200000U
N#define RTC_TR_HU                            0x000F0000U
N#define RTC_TR_HU_0                          0x00010000U
N#define RTC_TR_HU_1                          0x00020000U
N#define RTC_TR_HU_2                          0x00040000U
N#define RTC_TR_HU_3                          0x00080000U
N#define RTC_TR_MNT                           0x00007000U
N#define RTC_TR_MNT_0                         0x00001000U
N#define RTC_TR_MNT_1                         0x00002000U
N#define RTC_TR_MNT_2                         0x00004000U
N#define RTC_TR_MNU                           0x00000F00U
N#define RTC_TR_MNU_0                         0x00000100U
N#define RTC_TR_MNU_1                         0x00000200U
N#define RTC_TR_MNU_2                         0x00000400U
N#define RTC_TR_MNU_3                         0x00000800U
N#define RTC_TR_ST                            0x00000070U
N#define RTC_TR_ST_0                          0x00000010U
N#define RTC_TR_ST_1                          0x00000020U
N#define RTC_TR_ST_2                          0x00000040U
N#define RTC_TR_SU                            0x0000000FU
N#define RTC_TR_SU_0                          0x00000001U
N#define RTC_TR_SU_1                          0x00000002U
N#define RTC_TR_SU_2                          0x00000004U
N#define RTC_TR_SU_3                          0x00000008U
N
N/********************  Bits definition for RTC_DR register  *******************/
N#define RTC_DR_YT                            0x00F00000U
N#define RTC_DR_YT_0                          0x00100000U
N#define RTC_DR_YT_1                          0x00200000U
N#define RTC_DR_YT_2                          0x00400000U
N#define RTC_DR_YT_3                          0x00800000U
N#define RTC_DR_YU                            0x000F0000U
N#define RTC_DR_YU_0                          0x00010000U
N#define RTC_DR_YU_1                          0x00020000U
N#define RTC_DR_YU_2                          0x00040000U
N#define RTC_DR_YU_3                          0x00080000U
N#define RTC_DR_WDU                           0x0000E000U
N#define RTC_DR_WDU_0                         0x00002000U
N#define RTC_DR_WDU_1                         0x00004000U
N#define RTC_DR_WDU_2                         0x00008000U
N#define RTC_DR_MT                            0x00001000U
N#define RTC_DR_MU                            0x00000F00U
N#define RTC_DR_MU_0                          0x00000100U
N#define RTC_DR_MU_1                          0x00000200U
N#define RTC_DR_MU_2                          0x00000400U
N#define RTC_DR_MU_3                          0x00000800U
N#define RTC_DR_DT                            0x00000030U
N#define RTC_DR_DT_0                          0x00000010U
N#define RTC_DR_DT_1                          0x00000020U
N#define RTC_DR_DU                            0x0000000FU
N#define RTC_DR_DU_0                          0x00000001U
N#define RTC_DR_DU_1                          0x00000002U
N#define RTC_DR_DU_2                          0x00000004U
N#define RTC_DR_DU_3                          0x00000008U
N
N/********************  Bits definition for RTC_CR register  *******************/
N#define RTC_CR_ITSE                          0x01000000U 
N#define RTC_CR_COE                           0x00800000U
N#define RTC_CR_OSEL                          0x00600000U
N#define RTC_CR_OSEL_0                        0x00200000U
N#define RTC_CR_OSEL_1                        0x00400000U
N#define RTC_CR_POL                           0x00100000U
N#define RTC_CR_COSEL                         0x00080000U
N#define RTC_CR_BCK                           0x00040000U
N#define RTC_CR_SUB1H                         0x00020000U
N#define RTC_CR_ADD1H                         0x00010000U
N#define RTC_CR_TSIE                          0x00008000U
N#define RTC_CR_WUTIE                         0x00004000U
N#define RTC_CR_ALRBIE                        0x00002000U
N#define RTC_CR_ALRAIE                        0x00001000U
N#define RTC_CR_TSE                           0x00000800U
N#define RTC_CR_WUTE                          0x00000400U
N#define RTC_CR_ALRBE                         0x00000200U
N#define RTC_CR_ALRAE                         0x00000100U
N#define RTC_CR_FMT                           0x00000040U
N#define RTC_CR_BYPSHAD                       0x00000020U
N#define RTC_CR_REFCKON                       0x00000010U
N#define RTC_CR_TSEDGE                        0x00000008U
N#define RTC_CR_WUCKSEL                       0x00000007U
N#define RTC_CR_WUCKSEL_0                     0x00000001U
N#define RTC_CR_WUCKSEL_1                     0x00000002U
N#define RTC_CR_WUCKSEL_2                     0x00000004U
N
N/********************  Bits definition for RTC_ISR register  ******************/
N#define RTC_ISR_ITSF                         0x00020000U
N#define RTC_ISR_RECALPF                      0x00010000U
N#define RTC_ISR_TAMP3F                       0x00008000U
N#define RTC_ISR_TAMP2F                       0x00004000U
N#define RTC_ISR_TAMP1F                       0x00002000U
N#define RTC_ISR_TSOVF                        0x00001000U
N#define RTC_ISR_TSF                          0x00000800U
N#define RTC_ISR_WUTF                         0x00000400U
N#define RTC_ISR_ALRBF                        0x00000200U
N#define RTC_ISR_ALRAF                        0x00000100U
N#define RTC_ISR_INIT                         0x00000080U
N#define RTC_ISR_INITF                        0x00000040U
N#define RTC_ISR_RSF                          0x00000020U
N#define RTC_ISR_INITS                        0x00000010U
N#define RTC_ISR_SHPF                         0x00000008U
N#define RTC_ISR_WUTWF                        0x00000004U
N#define RTC_ISR_ALRBWF                       0x00000002U
N#define RTC_ISR_ALRAWF                       0x00000001U
N
N/********************  Bits definition for RTC_PRER register  *****************/
N#define RTC_PRER_PREDIV_A                    0x007F0000U
N#define RTC_PRER_PREDIV_S                    0x00007FFFU
N
N/********************  Bits definition for RTC_WUTR register  *****************/
N#define RTC_WUTR_WUT                         0x0000FFFFU
N
N/********************  Bits definition for RTC_ALRMAR register  ***************/
N#define RTC_ALRMAR_MSK4                      0x80000000U
N#define RTC_ALRMAR_WDSEL                     0x40000000U
N#define RTC_ALRMAR_DT                        0x30000000U
N#define RTC_ALRMAR_DT_0                      0x10000000U
N#define RTC_ALRMAR_DT_1                      0x20000000U
N#define RTC_ALRMAR_DU                        0x0F000000U
N#define RTC_ALRMAR_DU_0                      0x01000000U
N#define RTC_ALRMAR_DU_1                      0x02000000U
N#define RTC_ALRMAR_DU_2                      0x04000000U
N#define RTC_ALRMAR_DU_3                      0x08000000U
N#define RTC_ALRMAR_MSK3                      0x00800000U
N#define RTC_ALRMAR_PM                        0x00400000U
N#define RTC_ALRMAR_HT                        0x00300000U
N#define RTC_ALRMAR_HT_0                      0x00100000U
N#define RTC_ALRMAR_HT_1                      0x00200000U
N#define RTC_ALRMAR_HU                        0x000F0000U
N#define RTC_ALRMAR_HU_0                      0x00010000U
N#define RTC_ALRMAR_HU_1                      0x00020000U
N#define RTC_ALRMAR_HU_2                      0x00040000U
N#define RTC_ALRMAR_HU_3                      0x00080000U
N#define RTC_ALRMAR_MSK2                      0x00008000U
N#define RTC_ALRMAR_MNT                       0x00007000U
N#define RTC_ALRMAR_MNT_0                     0x00001000U
N#define RTC_ALRMAR_MNT_1                     0x00002000U
N#define RTC_ALRMAR_MNT_2                     0x00004000U
N#define RTC_ALRMAR_MNU                       0x00000F00U
N#define RTC_ALRMAR_MNU_0                     0x00000100U
N#define RTC_ALRMAR_MNU_1                     0x00000200U
N#define RTC_ALRMAR_MNU_2                     0x00000400U
N#define RTC_ALRMAR_MNU_3                     0x00000800U
N#define RTC_ALRMAR_MSK1                      0x00000080U
N#define RTC_ALRMAR_ST                        0x00000070U
N#define RTC_ALRMAR_ST_0                      0x00000010U
N#define RTC_ALRMAR_ST_1                      0x00000020U
N#define RTC_ALRMAR_ST_2                      0x00000040U
N#define RTC_ALRMAR_SU                        0x0000000FU
N#define RTC_ALRMAR_SU_0                      0x00000001U
N#define RTC_ALRMAR_SU_1                      0x00000002U
N#define RTC_ALRMAR_SU_2                      0x00000004U
N#define RTC_ALRMAR_SU_3                      0x00000008U
N
N/********************  Bits definition for RTC_ALRMBR register  ***************/
N#define RTC_ALRMBR_MSK4                      0x80000000U
N#define RTC_ALRMBR_WDSEL                     0x40000000U
N#define RTC_ALRMBR_DT                        0x30000000U
N#define RTC_ALRMBR_DT_0                      0x10000000U
N#define RTC_ALRMBR_DT_1                      0x20000000U
N#define RTC_ALRMBR_DU                        0x0F000000U
N#define RTC_ALRMBR_DU_0                      0x01000000U
N#define RTC_ALRMBR_DU_1                      0x02000000U
N#define RTC_ALRMBR_DU_2                      0x04000000U
N#define RTC_ALRMBR_DU_3                      0x08000000U
N#define RTC_ALRMBR_MSK3                      0x00800000U
N#define RTC_ALRMBR_PM                        0x00400000U
N#define RTC_ALRMBR_HT                        0x00300000U
N#define RTC_ALRMBR_HT_0                      0x00100000U
N#define RTC_ALRMBR_HT_1                      0x00200000U
N#define RTC_ALRMBR_HU                        0x000F0000U
N#define RTC_ALRMBR_HU_0                      0x00010000U
N#define RTC_ALRMBR_HU_1                      0x00020000U
N#define RTC_ALRMBR_HU_2                      0x00040000U
N#define RTC_ALRMBR_HU_3                      0x00080000U
N#define RTC_ALRMBR_MSK2                      0x00008000U
N#define RTC_ALRMBR_MNT                       0x00007000U
N#define RTC_ALRMBR_MNT_0                     0x00001000U
N#define RTC_ALRMBR_MNT_1                     0x00002000U
N#define RTC_ALRMBR_MNT_2                     0x00004000U
N#define RTC_ALRMBR_MNU                       0x00000F00U
N#define RTC_ALRMBR_MNU_0                     0x00000100U
N#define RTC_ALRMBR_MNU_1                     0x00000200U
N#define RTC_ALRMBR_MNU_2                     0x00000400U
N#define RTC_ALRMBR_MNU_3                     0x00000800U
N#define RTC_ALRMBR_MSK1                      0x00000080U
N#define RTC_ALRMBR_ST                        0x00000070U
N#define RTC_ALRMBR_ST_0                      0x00000010U
N#define RTC_ALRMBR_ST_1                      0x00000020U
N#define RTC_ALRMBR_ST_2                      0x00000040U
N#define RTC_ALRMBR_SU                        0x0000000FU
N#define RTC_ALRMBR_SU_0                      0x00000001U
N#define RTC_ALRMBR_SU_1                      0x00000002U
N#define RTC_ALRMBR_SU_2                      0x00000004U
N#define RTC_ALRMBR_SU_3                      0x00000008U
N
N/********************  Bits definition for RTC_WPR register  ******************/
N#define RTC_WPR_KEY                          0x000000FFU
N
N/********************  Bits definition for RTC_SSR register  ******************/
N#define RTC_SSR_SS                           0x0000FFFFU
N
N/********************  Bits definition for RTC_SHIFTR register  ***************/
N#define RTC_SHIFTR_SUBFS                     0x00007FFFU
N#define RTC_SHIFTR_ADD1S                     0x80000000U
N
N/********************  Bits definition for RTC_TSTR register  *****************/
N#define RTC_TSTR_PM                          0x00400000U
N#define RTC_TSTR_HT                          0x00300000U
N#define RTC_TSTR_HT_0                        0x00100000U
N#define RTC_TSTR_HT_1                        0x00200000U
N#define RTC_TSTR_HU                          0x000F0000U
N#define RTC_TSTR_HU_0                        0x00010000U
N#define RTC_TSTR_HU_1                        0x00020000U
N#define RTC_TSTR_HU_2                        0x00040000U
N#define RTC_TSTR_HU_3                        0x00080000U
N#define RTC_TSTR_MNT                         0x00007000U
N#define RTC_TSTR_MNT_0                       0x00001000U
N#define RTC_TSTR_MNT_1                       0x00002000U
N#define RTC_TSTR_MNT_2                       0x00004000U
N#define RTC_TSTR_MNU                         0x00000F00U
N#define RTC_TSTR_MNU_0                       0x00000100U
N#define RTC_TSTR_MNU_1                       0x00000200U
N#define RTC_TSTR_MNU_2                       0x00000400U
N#define RTC_TSTR_MNU_3                       0x00000800U
N#define RTC_TSTR_ST                          0x00000070U
N#define RTC_TSTR_ST_0                        0x00000010U
N#define RTC_TSTR_ST_1                        0x00000020U
N#define RTC_TSTR_ST_2                        0x00000040U
N#define RTC_TSTR_SU                          0x0000000FU
N#define RTC_TSTR_SU_0                        0x00000001U
N#define RTC_TSTR_SU_1                        0x00000002U
N#define RTC_TSTR_SU_2                        0x00000004U
N#define RTC_TSTR_SU_3                        0x00000008U
N
N/********************  Bits definition for RTC_TSDR register  *****************/
N#define RTC_TSDR_WDU                         0x0000E000U
N#define RTC_TSDR_WDU_0                       0x00002000U
N#define RTC_TSDR_WDU_1                       0x00004000U
N#define RTC_TSDR_WDU_2                       0x00008000U
N#define RTC_TSDR_MT                          0x00001000U
N#define RTC_TSDR_MU                          0x00000F00U
N#define RTC_TSDR_MU_0                        0x00000100U
N#define RTC_TSDR_MU_1                        0x00000200U
N#define RTC_TSDR_MU_2                        0x00000400U
N#define RTC_TSDR_MU_3                        0x00000800U
N#define RTC_TSDR_DT                          0x00000030U
N#define RTC_TSDR_DT_0                        0x00000010U
N#define RTC_TSDR_DT_1                        0x00000020U
N#define RTC_TSDR_DU                          0x0000000FU
N#define RTC_TSDR_DU_0                        0x00000001U
N#define RTC_TSDR_DU_1                        0x00000002U
N#define RTC_TSDR_DU_2                        0x00000004U
N#define RTC_TSDR_DU_3                        0x00000008U
N
N/********************  Bits definition for RTC_TSSSR register  ****************/
N#define RTC_TSSSR_SS                         0x0000FFFFU
N
N/********************  Bits definition for RTC_CAL register  *****************/
N#define RTC_CALR_CALP                        0x00008000U
N#define RTC_CALR_CALW8                       0x00004000U
N#define RTC_CALR_CALW16                      0x00002000U
N#define RTC_CALR_CALM                        0x000001FFU
N#define RTC_CALR_CALM_0                      0x00000001U
N#define RTC_CALR_CALM_1                      0x00000002U
N#define RTC_CALR_CALM_2                      0x00000004U
N#define RTC_CALR_CALM_3                      0x00000008U
N#define RTC_CALR_CALM_4                      0x00000010U
N#define RTC_CALR_CALM_5                      0x00000020U
N#define RTC_CALR_CALM_6                      0x00000040U
N#define RTC_CALR_CALM_7                      0x00000080U
N#define RTC_CALR_CALM_8                      0x00000100U
N
N/********************  Bits definition for RTC_TAMPCR register  ****************/
N#define RTC_TAMPCR_TAMP3MF                   0x01000000U
N#define RTC_TAMPCR_TAMP3NOERASE              0x00800000U
N#define RTC_TAMPCR_TAMP3IE                   0x00400000U
N#define RTC_TAMPCR_TAMP2MF                   0x00200000U
N#define RTC_TAMPCR_TAMP2NOERASE              0x00100000U
N#define RTC_TAMPCR_TAMP2IE                   0x00080000U
N#define RTC_TAMPCR_TAMP1MF                   0x00040000U
N#define RTC_TAMPCR_TAMP1NOERASE              0x00020000U
N#define RTC_TAMPCR_TAMP1IE                   0x00010000U
N#define RTC_TAMPCR_TAMPPUDIS                 0x00008000U
N#define RTC_TAMPCR_TAMPPRCH                  0x00006000U
N#define RTC_TAMPCR_TAMPPRCH_0                0x00002000U
N#define RTC_TAMPCR_TAMPPRCH_1                0x00004000U
N#define RTC_TAMPCR_TAMPFLT                   0x00001800U
N#define RTC_TAMPCR_TAMPFLT_0                 0x00000800U
N#define RTC_TAMPCR_TAMPFLT_1                 0x00001000U
N#define RTC_TAMPCR_TAMPFREQ                  0x00000700U
N#define RTC_TAMPCR_TAMPFREQ_0                0x00000100U
N#define RTC_TAMPCR_TAMPFREQ_1                0x00000200U
N#define RTC_TAMPCR_TAMPFREQ_2                0x00000400U
N#define RTC_TAMPCR_TAMPTS                    0x00000080U
N#define RTC_TAMPCR_TAMP3TRG                  0x00000040U
N#define RTC_TAMPCR_TAMP3E                    0x00000020U
N#define RTC_TAMPCR_TAMP2TRG                  0x00000010U
N#define RTC_TAMPCR_TAMP2E                    0x00000008U
N#define RTC_TAMPCR_TAMPIE                    0x00000004U
N#define RTC_TAMPCR_TAMP1TRG                  0x00000002U
N#define RTC_TAMPCR_TAMP1E                    0x00000001U
N
N
N/********************  Bits definition for RTC_ALRMASSR register  *************/
N#define RTC_ALRMASSR_MASKSS                  0x0F000000U
N#define RTC_ALRMASSR_MASKSS_0                0x01000000U
N#define RTC_ALRMASSR_MASKSS_1                0x02000000U
N#define RTC_ALRMASSR_MASKSS_2                0x04000000U
N#define RTC_ALRMASSR_MASKSS_3                0x08000000U
N#define RTC_ALRMASSR_SS                      0x00007FFFU
N
N/********************  Bits definition for RTC_ALRMBSSR register  *************/
N#define RTC_ALRMBSSR_MASKSS                  0x0F000000U
N#define RTC_ALRMBSSR_MASKSS_0                0x01000000U
N#define RTC_ALRMBSSR_MASKSS_1                0x02000000U
N#define RTC_ALRMBSSR_MASKSS_2                0x04000000U
N#define RTC_ALRMBSSR_MASKSS_3                0x08000000U
N#define RTC_ALRMBSSR_SS                      0x00007FFFU
N
N/********************  Bits definition for RTC_OR register  ****************/
N#define RTC_OR_TSINSEL                       0x00000006U
N#define RTC_OR_TSINSEL_0                     0x00000002U
N#define RTC_OR_TSINSEL_1                     0x00000004U
N#define RTC_OR_ALARMTYPE                     0x00000008U
N
N/********************  Bits definition for RTC_BKP0R register  ****************/
N#define RTC_BKP0R                            0xFFFFFFFFU
N
N/********************  Bits definition for RTC_BKP1R register  ****************/
N#define RTC_BKP1R                            0xFFFFFFFFU
N
N/********************  Bits definition for RTC_BKP2R register  ****************/
N#define RTC_BKP2R                            0xFFFFFFFFU
N
N/********************  Bits definition for RTC_BKP3R register  ****************/
N#define RTC_BKP3R                            0xFFFFFFFFU
N
N/********************  Bits definition for RTC_BKP4R register  ****************/
N#define RTC_BKP4R                            0xFFFFFFFFU
N
N/********************  Bits definition for RTC_BKP5R register  ****************/
N#define RTC_BKP5R                            0xFFFFFFFFU
N
N/********************  Bits definition for RTC_BKP6R register  ****************/
N#define RTC_BKP6R                            0xFFFFFFFFU
N
N/********************  Bits definition for RTC_BKP7R register  ****************/
N#define RTC_BKP7R                            0xFFFFFFFFU
N
N/********************  Bits definition for RTC_BKP8R register  ****************/
N#define RTC_BKP8R                            0xFFFFFFFFU
N
N/********************  Bits definition for RTC_BKP9R register  ****************/
N#define RTC_BKP9R                            0xFFFFFFFFU
N
N/********************  Bits definition for RTC_BKP10R register  ***************/
N#define RTC_BKP10R                           0xFFFFFFFFU
N
N/********************  Bits definition for RTC_BKP11R register  ***************/
N#define RTC_BKP11R                           0xFFFFFFFFU
N
N/********************  Bits definition for RTC_BKP12R register  ***************/
N#define RTC_BKP12R                           0xFFFFFFFFU
N
N/********************  Bits definition for RTC_BKP13R register  ***************/
N#define RTC_BKP13R                           0xFFFFFFFFU
N
N/********************  Bits definition for RTC_BKP14R register  ***************/
N#define RTC_BKP14R                           0xFFFFFFFFU
N
N/********************  Bits definition for RTC_BKP15R register  ***************/
N#define RTC_BKP15R                           0xFFFFFFFFU
N
N/********************  Bits definition for RTC_BKP16R register  ***************/
N#define RTC_BKP16R                           0xFFFFFFFFU
N
N/********************  Bits definition for RTC_BKP17R register  ***************/
N#define RTC_BKP17R                           0xFFFFFFFFU
N
N/********************  Bits definition for RTC_BKP18R register  ***************/
N#define RTC_BKP18R                           0xFFFFFFFFU
N
N/********************  Bits definition for RTC_BKP19R register  ***************/
N#define RTC_BKP19R                           0xFFFFFFFFU
N
N/********************  Bits definition for RTC_BKP20R register  ***************/
N#define RTC_BKP20R                           0xFFFFFFFFU
N
N/********************  Bits definition for RTC_BKP21R register  ***************/
N#define RTC_BKP21R                           0xFFFFFFFFU
N
N/********************  Bits definition for RTC_BKP22R register  ***************/
N#define RTC_BKP22R                           0xFFFFFFFFU
N
N/********************  Bits definition for RTC_BKP23R register  ***************/
N#define RTC_BKP23R                           0xFFFFFFFFU
N
N/********************  Bits definition for RTC_BKP24R register  ***************/
N#define RTC_BKP24R                           0xFFFFFFFFU
N
N/********************  Bits definition for RTC_BKP25R register  ***************/
N#define RTC_BKP25R                           0xFFFFFFFFU
N
N/********************  Bits definition for RTC_BKP26R register  ***************/
N#define RTC_BKP26R                           0xFFFFFFFFU
N
N/********************  Bits definition for RTC_BKP27R register  ***************/
N#define RTC_BKP27R                           0xFFFFFFFFU
N
N/********************  Bits definition for RTC_BKP28R register  ***************/
N#define RTC_BKP28R                           0xFFFFFFFFU
N
N/********************  Bits definition for RTC_BKP29R register  ***************/
N#define RTC_BKP29R                           0xFFFFFFFFU
N
N/********************  Bits definition for RTC_BKP30R register  ***************/
N#define RTC_BKP30R                           0xFFFFFFFFU
N
N/********************  Bits definition for RTC_BKP31R register  ***************/
N#define RTC_BKP31R                           0xFFFFFFFFU
N
N/******************** Number of backup registers ******************************/
N#define RTC_BKP_NUMBER                       0x00000020U
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                          Serial Audio Interface                            */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for SAI_GCR register  *******************/
N#define  SAI_GCR_SYNCIN                      0x00000003U        /*!<SYNCIN[1:0] bits (Synchronization Inputs)   */
N#define  SAI_GCR_SYNCIN_0                    0x00000001U        /*!<Bit 0 */
N#define  SAI_GCR_SYNCIN_1                    0x00000002U        /*!<Bit 1 */
N                                             
N#define  SAI_GCR_SYNCOUT                     0x00000030U        /*!<SYNCOUT[1:0] bits (Synchronization Outputs) */
N#define  SAI_GCR_SYNCOUT_0                   0x00000010U        /*!<Bit 0 */
N#define  SAI_GCR_SYNCOUT_1                   0x00000020U        /*!<Bit 1 */
N
N/*******************  Bit definition for SAI_xCR1 register  *******************/
N#define  SAI_xCR1_MODE                       0x00000003U        /*!<MODE[1:0] bits (Audio Block Mode)           */
N#define  SAI_xCR1_MODE_0                     0x00000001U        /*!<Bit 0 */
N#define  SAI_xCR1_MODE_1                     0x00000002U        /*!<Bit 1 */
N                                             
N#define  SAI_xCR1_PRTCFG                     0x0000000CU        /*!<PRTCFG[1:0] bits (Protocol Configuration)   */
N#define  SAI_xCR1_PRTCFG_0                   0x00000004U        /*!<Bit 0 */
N#define  SAI_xCR1_PRTCFG_1                   0x00000008U        /*!<Bit 1 */
N                                             
N#define  SAI_xCR1_DS                         0x000000E0U        /*!<DS[1:0] bits (Data Size) */
N#define  SAI_xCR1_DS_0                       0x00000020U        /*!<Bit 0 */
N#define  SAI_xCR1_DS_1                       0x00000040U        /*!<Bit 1 */
N#define  SAI_xCR1_DS_2                       0x00000080U        /*!<Bit 2 */
N                                             
N#define  SAI_xCR1_LSBFIRST                   0x00000100U        /*!<LSB First Configuration  */
N#define  SAI_xCR1_CKSTR                      0x00000200U        /*!<ClocK STRobing edge      */
N                                             
N#define  SAI_xCR1_SYNCEN                     0x00000C00U        /*!<SYNCEN[1:0](SYNChronization ENable) */
N#define  SAI_xCR1_SYNCEN_0                   0x00000400U        /*!<Bit 0 */
N#define  SAI_xCR1_SYNCEN_1                   0x00000800U        /*!<Bit 1 */
N                                             
N#define  SAI_xCR1_MONO                       0x00001000U        /*!<Mono mode                  */
N#define  SAI_xCR1_OUTDRIV                    0x00002000U        /*!<Output Drive               */
N#define  SAI_xCR1_SAIEN                      0x00010000U        /*!<Audio Block enable         */
N#define  SAI_xCR1_DMAEN                      0x00020000U        /*!<DMA enable                 */
N#define  SAI_xCR1_NODIV                      0x00080000U        /*!<No Divider Configuration   */
N                                             
N#define  SAI_xCR1_MCKDIV                     0x00F00000U        /*!<MCKDIV[3:0] (Master ClocK Divider)  */
N#define  SAI_xCR1_MCKDIV_0                   0x00100000U        /*!<Bit 0  */
N#define  SAI_xCR1_MCKDIV_1                   0x00200000U        /*!<Bit 1  */
N#define  SAI_xCR1_MCKDIV_2                   0x00400000U        /*!<Bit 2  */
N#define  SAI_xCR1_MCKDIV_3                   0x00800000U        /*!<Bit 3  */
N
N/*******************  Bit definition for SAI_xCR2 register  *******************/
N#define  SAI_xCR2_FTH                        0x00000007U        /*!<FTH[2:0](Fifo THreshold)  */
N#define  SAI_xCR2_FTH_0                      0x00000001U        /*!<Bit 0 */
N#define  SAI_xCR2_FTH_1                      0x00000002U        /*!<Bit 1 */
N#define  SAI_xCR2_FTH_2                      0x00000004U        /*!<Bit 2 */
N                                             
N#define  SAI_xCR2_FFLUSH                     0x00000008U        /*!<Fifo FLUSH                       */
N#define  SAI_xCR2_TRIS                       0x00000010U        /*!<TRIState Management on data line */
N#define  SAI_xCR2_MUTE                       0x00000020U        /*!<Mute mode                        */
N#define  SAI_xCR2_MUTEVAL                    0x00000040U        /*!<Muate value                      */
N                                             
N#define  SAI_xCR2_MUTECNT                    0x00001F80U       /*!<MUTECNT[5:0] (MUTE counter) */
N#define  SAI_xCR2_MUTECNT_0                  0x00000080U        /*!<Bit 0 */
N#define  SAI_xCR2_MUTECNT_1                  0x00000100U        /*!<Bit 1 */
N#define  SAI_xCR2_MUTECNT_2                  0x00000200U        /*!<Bit 2 */
N#define  SAI_xCR2_MUTECNT_3                  0x00000400U        /*!<Bit 3 */
N#define  SAI_xCR2_MUTECNT_4                  0x00000800U        /*!<Bit 4 */
N#define  SAI_xCR2_MUTECNT_5                  0x00001000U        /*!<Bit 5 */
N                                             
N#define  SAI_xCR2_CPL                        0x00002000U        /*!< Complement Bit             */
N                                             
N#define  SAI_xCR2_COMP                       0x0000C000U        /*!<COMP[1:0] (Companding mode) */
N#define  SAI_xCR2_COMP_0                     0x00004000U        /*!<Bit 0 */
N#define  SAI_xCR2_COMP_1                     0x00008000U        /*!<Bit 1 */
N
N/******************  Bit definition for SAI_xFRCR register  *******************/
N#define  SAI_xFRCR_FRL                       0x000000FFU        /*!<FRL[1:0](Frame length)  */
N#define  SAI_xFRCR_FRL_0                     0x00000001U        /*!<Bit 0 */
N#define  SAI_xFRCR_FRL_1                     0x00000002U        /*!<Bit 1 */
N#define  SAI_xFRCR_FRL_2                     0x00000004U        /*!<Bit 2 */
N#define  SAI_xFRCR_FRL_3                     0x00000008U        /*!<Bit 3 */
N#define  SAI_xFRCR_FRL_4                     0x00000010U        /*!<Bit 4 */
N#define  SAI_xFRCR_FRL_5                     0x00000020U        /*!<Bit 5 */
N#define  SAI_xFRCR_FRL_6                     0x00000040U        /*!<Bit 6 */
N#define  SAI_xFRCR_FRL_7                     0x00000080U        /*!<Bit 7 */
N                                                        
N#define  SAI_xFRCR_FSALL                     0x00007F00U        /*!<FRL[1:0] (Frame synchronization active level length)  */
N#define  SAI_xFRCR_FSALL_0                   0x00000100U        /*!<Bit 0 */
N#define  SAI_xFRCR_FSALL_1                   0x00000200U        /*!<Bit 1 */
N#define  SAI_xFRCR_FSALL_2                   0x00000400U        /*!<Bit 2 */
N#define  SAI_xFRCR_FSALL_3                   0x00000800U        /*!<Bit 3 */
N#define  SAI_xFRCR_FSALL_4                   0x00001000U        /*!<Bit 4 */
N#define  SAI_xFRCR_FSALL_5                   0x00002000U        /*!<Bit 5 */
N#define  SAI_xFRCR_FSALL_6                   0x00004000U        /*!<Bit 6 */
N                                                        
N#define  SAI_xFRCR_FSDEF                     0x00010000U        /*!<Frame Synchronization Definition  */
N#define  SAI_xFRCR_FSPOL                     0x00020000U        /*!<Frame Synchronization POLarity    */
N#define  SAI_xFRCR_FSOFF                     0x00040000U        /*!<Frame Synchronization OFFset      */
N                                             
N/* Legacy define */                          
N#define  SAI_xFRCR_FSPO                      SAI_xFRCR_FSPOL
N
N/******************  Bit definition for SAI_xSLOTR register  *******************/
N#define  SAI_xSLOTR_FBOFF                    0x0000001FU        /*!<FRL[4:0](First Bit Offset)  */
N#define  SAI_xSLOTR_FBOFF_0                  0x00000001U        /*!<Bit 0 */
N#define  SAI_xSLOTR_FBOFF_1                  0x00000002U        /*!<Bit 1 */
N#define  SAI_xSLOTR_FBOFF_2                  0x00000004U        /*!<Bit 2 */
N#define  SAI_xSLOTR_FBOFF_3                  0x00000008U        /*!<Bit 3 */
N#define  SAI_xSLOTR_FBOFF_4                  0x00000010U        /*!<Bit 4 */
N                                            
N#define  SAI_xSLOTR_SLOTSZ                   0x000000C0U        /*!<SLOTSZ[1:0] (Slot size)  */
N#define  SAI_xSLOTR_SLOTSZ_0                 0x00000040U        /*!<Bit 0 */
N#define  SAI_xSLOTR_SLOTSZ_1                 0x00000080U        /*!<Bit 1 */
N                                            
N#define  SAI_xSLOTR_NBSLOT                   0x00000F00U        /*!<NBSLOT[3:0] (Number of Slot in audio Frame)  */
N#define  SAI_xSLOTR_NBSLOT_0                 0x00000100U        /*!<Bit 0 */
N#define  SAI_xSLOTR_NBSLOT_1                 0x00000200U        /*!<Bit 1 */
N#define  SAI_xSLOTR_NBSLOT_2                 0x00000400U        /*!<Bit 2 */
N#define  SAI_xSLOTR_NBSLOT_3                 0x00000800U        /*!<Bit 3 */
N                                            
N#define  SAI_xSLOTR_SLOTEN                   0xFFFF0000U        /*!<SLOTEN[15:0] (Slot Enable)  */
N
N/*******************  Bit definition for SAI_xIMR register  *******************/
N#define  SAI_xIMR_OVRUDRIE                   0x00000001U        /*!<Overrun underrun interrupt enable                              */
N#define  SAI_xIMR_MUTEDETIE                  0x00000002U        /*!<Mute detection interrupt enable                                */
N#define  SAI_xIMR_WCKCFGIE                   0x00000004U        /*!<Wrong Clock Configuration interrupt enable                     */
N#define  SAI_xIMR_FREQIE                     0x00000008U        /*!<FIFO request interrupt enable                                  */
N#define  SAI_xIMR_CNRDYIE                    0x00000010U        /*!<Codec not ready interrupt enable                               */
N#define  SAI_xIMR_AFSDETIE                   0x00000020U        /*!<Anticipated frame synchronization detection interrupt enable   */
N#define  SAI_xIMR_LFSDETIE                   0x00000040U        /*!<Late frame synchronization detection interrupt enable          */
N
N/********************  Bit definition for SAI_xSR register  *******************/
N#define  SAI_xSR_OVRUDR                      0x00000001U         /*!<Overrun underrun                               */
N#define  SAI_xSR_MUTEDET                     0x00000002U         /*!<Mute detection                                 */
N#define  SAI_xSR_WCKCFG                      0x00000004U         /*!<Wrong Clock Configuration                      */
N#define  SAI_xSR_FREQ                        0x00000008U         /*!<FIFO request                                   */
N#define  SAI_xSR_CNRDY                       0x00000010U         /*!<Codec not ready                                */
N#define  SAI_xSR_AFSDET                      0x00000020U         /*!<Anticipated frame synchronization detection    */
N#define  SAI_xSR_LFSDET                      0x00000040U         /*!<Late frame synchronization detection           */
N                                             
N#define  SAI_xSR_FLVL                        0x00070000U         /*!<FLVL[2:0] (FIFO Level Threshold)               */
N#define  SAI_xSR_FLVL_0                      0x00010000U         /*!<Bit 0 */
N#define  SAI_xSR_FLVL_1                      0x00020000U         /*!<Bit 1 */
N#define  SAI_xSR_FLVL_2                      0x00040000U         /*!<Bit 2 */
N
N/******************  Bit definition for SAI_xCLRFR register  ******************/
N#define  SAI_xCLRFR_COVRUDR                  0x00000001U        /*!<Clear Overrun underrun                               */
N#define  SAI_xCLRFR_CMUTEDET                 0x00000002U        /*!<Clear Mute detection                                 */
N#define  SAI_xCLRFR_CWCKCFG                  0x00000004U        /*!<Clear Wrong Clock Configuration                      */
N#define  SAI_xCLRFR_CFREQ                    0x00000008U        /*!<Clear FIFO request                                   */
N#define  SAI_xCLRFR_CCNRDY                   0x00000010U        /*!<Clear Codec not ready                                */
N#define  SAI_xCLRFR_CAFSDET                  0x00000020U        /*!<Clear Anticipated frame synchronization detection    */
N#define  SAI_xCLRFR_CLFSDET                  0x00000040U        /*!<Clear Late frame synchronization detection           */
N
N/******************  Bit definition for SAI_xDR register  *********************/
N#define  SAI_xDR_DATA                        0xFFFFFFFFU        
N
N/******************************************************************************/
N/*                                                                            */
N/*                              SPDIF-RX Interface                            */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for SPDIF_CR register  *******************/
N#define  SPDIFRX_CR_SPDIFEN                0x00000003U        /*!<Peripheral Block Enable                      */
N#define  SPDIFRX_CR_RXDMAEN                0x00000004U        /*!<Receiver DMA Enable for data flow            */
N#define  SPDIFRX_CR_RXSTEO                 0x00000008U        /*!<Stereo Mode                                  */
N#define  SPDIFRX_CR_DRFMT                  0x00000030U        /*!<RX Data format                               */
N#define  SPDIFRX_CR_PMSK                   0x00000040U        /*!<Mask Parity error bit                        */
N#define  SPDIFRX_CR_VMSK                   0x00000080U        /*!<Mask of Validity bit                         */
N#define  SPDIFRX_CR_CUMSK                  0x00000100U        /*!<Mask of channel status and user bits         */
N#define  SPDIFRX_CR_PTMSK                  0x00000200U        /*!<Mask of Preamble Type bits                   */
N#define  SPDIFRX_CR_CBDMAEN                0x00000400U        /*!<Control Buffer DMA ENable for control flow   */
N#define  SPDIFRX_CR_CHSEL                  0x00000800U        /*!<Channel Selection                            */
N#define  SPDIFRX_CR_NBTR                   0x00003000U        /*!<Maximum allowed re-tries during synchronization phase */
N#define  SPDIFRX_CR_WFA                    0x00004000U        /*!<Wait For Activity     */
N#define  SPDIFRX_CR_INSEL                  0x00070000U        /*!<SPDIF input selection */
N
N/*******************  Bit definition for SPDIFRX_IMR register  *******************/
N#define  SPDIFRX_IMR_RXNEIE                0x00000001U        /*!<RXNE interrupt enable                              */
N#define  SPDIFRX_IMR_CSRNEIE               0x00000002U        /*!<Control Buffer Ready Interrupt Enable              */
N#define  SPDIFRX_IMR_PERRIE                0x00000004U        /*!<Parity error interrupt enable                      */
N#define  SPDIFRX_IMR_OVRIE                 0x00000008U        /*!<Overrun error Interrupt Enable                     */
N#define  SPDIFRX_IMR_SBLKIE                0x00000010U        /*!<Synchronization Block Detected Interrupt Enable    */
N#define  SPDIFRX_IMR_SYNCDIE               0x00000020U        /*!<Synchronization Done                               */
N#define  SPDIFRX_IMR_IFEIE                 0x00000040U        /*!<Serial Interface Error Interrupt Enable            */
N
N/*******************  Bit definition for SPDIFRX_SR register  *******************/
N#define  SPDIFRX_SR_RXNE                   0x00000001U       /*!<Read data register not empty                          */
N#define  SPDIFRX_SR_CSRNE                  0x00000002U       /*!<The Control Buffer register is not empty              */
N#define  SPDIFRX_SR_PERR                   0x00000004U       /*!<Parity error                                          */
N#define  SPDIFRX_SR_OVR                    0x00000008U       /*!<Overrun error                                         */
N#define  SPDIFRX_SR_SBD                    0x00000010U       /*!<Synchronization Block Detected                        */
N#define  SPDIFRX_SR_SYNCD                  0x00000020U       /*!<Synchronization Done                                  */
N#define  SPDIFRX_SR_FERR                   0x00000040U       /*!<Framing error                                         */
N#define  SPDIFRX_SR_SERR                   0x00000080U       /*!<Synchronization error                                 */
N#define  SPDIFRX_SR_TERR                   0x00000100U       /*!<Time-out error                                        */
N#define  SPDIFRX_SR_WIDTH5                 0x7FFF0000U       /*!<Duration of 5 symbols counted with spdif_clk          */
N
N/*******************  Bit definition for SPDIFRX_IFCR register  *******************/
N#define  SPDIFRX_IFCR_PERRCF               0x00000004U       /*!<Clears the Parity error flag                         */
N#define  SPDIFRX_IFCR_OVRCF                0x00000008U       /*!<Clears the Overrun error flag                        */
N#define  SPDIFRX_IFCR_SBDCF                0x00000010U       /*!<Clears the Synchronization Block Detected flag       */
N#define  SPDIFRX_IFCR_SYNCDCF              0x00000020U       /*!<Clears the Synchronization Done flag                 */
N
N/*******************  Bit definition for SPDIFRX_DR register  (DRFMT = 0b00 case) *******************/
N#define  SPDIFRX_DR0_DR                    0x00FFFFFFU        /*!<Data value            */
N#define  SPDIFRX_DR0_PE                    0x01000000U        /*!<Parity Error bit      */
N#define  SPDIFRX_DR0_V                     0x02000000U        /*!<Validity bit          */
N#define  SPDIFRX_DR0_U                     0x04000000U        /*!<User bit              */
N#define  SPDIFRX_DR0_C                     0x08000000U        /*!<Channel Status bit    */
N#define  SPDIFRX_DR0_PT                    0x30000000U        /*!<Preamble Type         */
N
N/*******************  Bit definition for SPDIFRX_DR register  (DRFMT = 0b01 case) *******************/
N#define  SPDIFRX_DR1_DR                    0xFFFFFF00U        /*!<Data value            */
N#define  SPDIFRX_DR1_PT                    0x00000030U        /*!<Preamble Type         */
N#define  SPDIFRX_DR1_C                     0x00000008U        /*!<Channel Status bit    */
N#define  SPDIFRX_DR1_U                     0x00000004U        /*!<User bit              */
N#define  SPDIFRX_DR1_V                     0x00000002U        /*!<Validity bit          */
N#define  SPDIFRX_DR1_PE                    0x00000001U        /*!<Parity Error bit      */
N
N/*******************  Bit definition for SPDIFRX_DR register  (DRFMT = 0b10 case) *******************/
N#define  SPDIFRX_DR1_DRNL1                 0xFFFF0000U        /*!<Data value Channel B      */
N#define  SPDIFRX_DR1_DRNL2                 0x0000FFFFU        /*!<Data value Channel A      */
N
N/*******************  Bit definition for SPDIFRX_CSR register   *******************/
N#define  SPDIFRX_CSR_USR                   0x0000FFFFU        /*!<User data information           */
N#define  SPDIFRX_CSR_CS                    0x00FF0000U        /*!<Channel A status information    */
N#define  SPDIFRX_CSR_SOB                   0x01000000U        /*!<Start Of Block                  */
N
N/*******************  Bit definition for SPDIFRX_DIR register    *******************/
N#define  SPDIFRX_DIR_THI                   0x000013FFU        /*!<Threshold LOW      */
N#define  SPDIFRX_DIR_TLO                   0x1FFF0000U        /*!<Threshold HIGH     */
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                          SD host Interface                                 */
N/*                                                                            */
N/******************************************************************************/
N/******************  Bit definition for SDMMC_POWER register  ******************/
N#define  SDMMC_POWER_PWRCTRL                  0x03U               /*!<PWRCTRL[1:0] bits (Power supply control bits) */
N#define  SDMMC_POWER_PWRCTRL_0                0x01U               /*!<Bit 0 */
N#define  SDMMC_POWER_PWRCTRL_1                0x02U               /*!<Bit 1 */
N
N/******************  Bit definition for SDMMC_CLKCR register  ******************/
N#define  SDMMC_CLKCR_CLKDIV                   0x00FFU            /*!<Clock divide factor             */
N#define  SDMMC_CLKCR_CLKEN                    0x0100U            /*!<Clock enable bit                */
N#define  SDMMC_CLKCR_PWRSAV                   0x0200U            /*!<Power saving configuration bit  */
N#define  SDMMC_CLKCR_BYPASS                   0x0400U            /*!<Clock divider bypass enable bit */
N         
N#define  SDMMC_CLKCR_WIDBUS                   0x1800U            /*!<WIDBUS[1:0] bits (Wide bus mode enable bit) */
N#define  SDMMC_CLKCR_WIDBUS_0                 0x0800U            /*!<Bit 0 */
N#define  SDMMC_CLKCR_WIDBUS_1                 0x1000U            /*!<Bit 1 */
N         
N#define  SDMMC_CLKCR_NEGEDGE                  0x2000U            /*!<SDMMC_CK dephasing selection bit */
N#define  SDMMC_CLKCR_HWFC_EN                  0x4000U            /*!<HW Flow Control enable          */
N
N/*******************  Bit definition for SDMMC_ARG register  *******************/
N#define  SDMMC_ARG_CMDARG                     0xFFFFFFFFU            /*!<Command argument */
N
N/*******************  Bit definition for SDMMC_CMD register  *******************/
N#define  SDMMC_CMD_CMDINDEX                   0x003FU            /*!<Command Index                               */
N         
N#define  SDMMC_CMD_WAITRESP                   0x00C0U            /*!<WAITRESP[1:0] bits (Wait for response bits) */
N#define  SDMMC_CMD_WAITRESP_0                 0x0040U            /*!< Bit 0 */
N#define  SDMMC_CMD_WAITRESP_1                 0x0080U            /*!< Bit 1 */
N         
N#define  SDMMC_CMD_WAITINT                    0x0100U            /*!<CPSM Waits for Interrupt Request                               */
N#define  SDMMC_CMD_WAITPEND                   0x0200U            /*!<CPSM Waits for ends of data transfer (CmdPend internal signal) */
N#define  SDMMC_CMD_CPSMEN                     0x0400U            /*!<Command path state machine (CPSM) Enable bit                   */
N#define  SDMMC_CMD_SDIOSUSPEND                0x0800U            /*!<SD I/O suspend command                                         */
N
N/*****************  Bit definition for SDMMC_RESPCMD register  *****************/
N#define  SDMMC_RESPCMD_RESPCMD                0x3FU               /*!<Response command index */
N
N/******************  Bit definition for SDMMC_RESP0 register  ******************/
N#define  SDMMC_RESP0_CARDSTATUS0              0xFFFFFFFFU        /*!<Card Status */
N
N/******************  Bit definition for SDMMC_RESP1 register  ******************/
N#define  SDMMC_RESP1_CARDSTATUS1              0xFFFFFFFFU        /*!<Card Status */
N
N/******************  Bit definition for SDMMC_RESP2 register  ******************/
N#define  SDMMC_RESP2_CARDSTATUS2              0xFFFFFFFFU        /*!<Card Status */
N
N/******************  Bit definition for SDMMC_RESP3 register  ******************/
N#define  SDMMC_RESP3_CARDSTATUS3              0xFFFFFFFFU        /*!<Card Status */
N
N/******************  Bit definition for SDMMC_RESP4 register  ******************/
N#define  SDMMC_RESP4_CARDSTATUS4              0xFFFFFFFFU        /*!<Card Status */
N
N/******************  Bit definition for SDMMC_DTIMER register  *****************/
N#define  SDMMC_DTIMER_DATATIME                0xFFFFFFFFU        /*!<Data timeout period. */
N
N/******************  Bit definition for SDMMC_DLEN register  *******************/
N#define  SDMMC_DLEN_DATALENGTH                0x01FFFFFFU        /*!<Data length value    */
N
N/******************  Bit definition for SDMMC_DCTRL register  ******************/
N#define  SDMMC_DCTRL_DTEN                     0x0001U            /*!<Data transfer enabled bit         */
N#define  SDMMC_DCTRL_DTDIR                    0x0002U            /*!<Data transfer direction selection */
N#define  SDMMC_DCTRL_DTMODE                   0x0004U            /*!<Data transfer mode selection      */
N#define  SDMMC_DCTRL_DMAEN                    0x0008U            /*!<DMA enabled bit                   */
N
N#define  SDMMC_DCTRL_DBLOCKSIZE               0x00F0U            /*!<DBLOCKSIZE[3:0] bits (Data block size) */
N#define  SDMMC_DCTRL_DBLOCKSIZE_0             0x0010U            /*!<Bit 0 */
N#define  SDMMC_DCTRL_DBLOCKSIZE_1             0x0020U            /*!<Bit 1 */
N#define  SDMMC_DCTRL_DBLOCKSIZE_2             0x0040U            /*!<Bit 2 */
N#define  SDMMC_DCTRL_DBLOCKSIZE_3             0x0080U            /*!<Bit 3 */
N
N#define  SDMMC_DCTRL_RWSTART                  0x0100U            /*!<Read wait start         */
N#define  SDMMC_DCTRL_RWSTOP                   0x0200U            /*!<Read wait stop          */
N#define  SDMMC_DCTRL_RWMOD                    0x0400U            /*!<Read wait mode          */
N#define  SDMMC_DCTRL_SDIOEN                   0x0800U            /*!<SD I/O enable functions */
N
N/******************  Bit definition for SDMMC_DCOUNT register  *****************/
N#define  SDMMC_DCOUNT_DATACOUNT               0x01FFFFFFU        /*!<Data count value */
N
N/******************  Bit definition for SDMMC_STA registe  ********************/
N#define  SDMMC_STA_CCRCFAIL                   0x00000001U        /*!<Command response received (CRC check failed)  */
N#define  SDMMC_STA_DCRCFAIL                   0x00000002U        /*!<Data block sent/received (CRC check failed)   */
N#define  SDMMC_STA_CTIMEOUT                   0x00000004U        /*!<Command response timeout                      */
N#define  SDMMC_STA_DTIMEOUT                   0x00000008U        /*!<Data timeout                                  */
N#define  SDMMC_STA_TXUNDERR                   0x00000010U        /*!<Transmit FIFO underrun error                  */
N#define  SDMMC_STA_RXOVERR                    0x00000020U        /*!<Received FIFO overrun error                   */
N#define  SDMMC_STA_CMDREND                    0x00000040U        /*!<Command response received (CRC check passed)  */
N#define  SDMMC_STA_CMDSENT                    0x00000080U        /*!<Command sent (no response required)           */
N#define  SDMMC_STA_DATAEND                    0x00000100U        /*!<Data end (data counter, SDIDCOUNT, is zero)   */
N#define  SDMMC_STA_DBCKEND                    0x00000400U        /*!<Data block sent/received (CRC check passed)   */
N#define  SDMMC_STA_CMDACT                     0x00000800U        /*!<Command transfer in progress                  */
N#define  SDMMC_STA_TXACT                      0x00001000U        /*!<Data transmit in progress                     */
N#define  SDMMC_STA_RXACT                      0x00002000U        /*!<Data receive in progress                      */
N#define  SDMMC_STA_TXFIFOHE                   0x00004000U        /*!<Transmit FIFO Half Empty: at least 8 words can be written into the FIFO */
N#define  SDMMC_STA_RXFIFOHF                   0x00008000U        /*!<Receive FIFO Half Full: there are at least 8 words in the FIFO */
N#define  SDMMC_STA_TXFIFOF                    0x00010000U        /*!<Transmit FIFO full                            */
N#define  SDMMC_STA_RXFIFOF                    0x00020000U        /*!<Receive FIFO full                             */
N#define  SDMMC_STA_TXFIFOE                    0x00040000U        /*!<Transmit FIFO empty                           */
N#define  SDMMC_STA_RXFIFOE                    0x00080000U        /*!<Receive FIFO empty                            */
N#define  SDMMC_STA_TXDAVL                     0x00100000U        /*!<Data available in transmit FIFO               */
N#define  SDMMC_STA_RXDAVL                     0x00200000U        /*!<Data available in receive FIFO                */
N#define  SDMMC_STA_SDIOIT                     0x00400000U        /*!<SDMMC interrupt received                       */
N
N/*******************  Bit definition for SDMMC_ICR register  *******************/
N#define  SDMMC_ICR_CCRCFAILC                  0x00000001U        /*!<CCRCFAIL flag clear bit */
N#define  SDMMC_ICR_DCRCFAILC                  0x00000002U        /*!<DCRCFAIL flag clear bit */
N#define  SDMMC_ICR_CTIMEOUTC                  0x00000004U        /*!<CTIMEOUT flag clear bit */
N#define  SDMMC_ICR_DTIMEOUTC                  0x00000008U        /*!<DTIMEOUT flag clear bit */
N#define  SDMMC_ICR_TXUNDERRC                  0x00000010U        /*!<TXUNDERR flag clear bit */
N#define  SDMMC_ICR_RXOVERRC                   0x00000020U        /*!<RXOVERR flag clear bit  */
N#define  SDMMC_ICR_CMDRENDC                   0x00000040U        /*!<CMDREND flag clear bit  */
N#define  SDMMC_ICR_CMDSENTC                   0x00000080U        /*!<CMDSENT flag clear bit  */
N#define  SDMMC_ICR_DATAENDC                   0x00000100U        /*!<DATAEND flag clear bit  */
N#define  SDMMC_ICR_DBCKENDC                   0x00000400U        /*!<DBCKEND flag clear bit  */
N#define  SDMMC_ICR_SDIOITC                    0x00400000U        /*!<SDMMCIT flag clear bit   */
N
N/******************  Bit definition for SDMMC_MASK register  *******************/
N#define  SDMMC_MASK_CCRCFAILIE                0x00000001U        /*!<Command CRC Fail Interrupt Enable          */
N#define  SDMMC_MASK_DCRCFAILIE                0x00000002U        /*!<Data CRC Fail Interrupt Enable             */
N#define  SDMMC_MASK_CTIMEOUTIE                0x00000004U        /*!<Command TimeOut Interrupt Enable           */
N#define  SDMMC_MASK_DTIMEOUTIE                0x00000008U        /*!<Data TimeOut Interrupt Enable              */
N#define  SDMMC_MASK_TXUNDERRIE                0x00000010U        /*!<Tx FIFO UnderRun Error Interrupt Enable    */
N#define  SDMMC_MASK_RXOVERRIE                 0x00000020U        /*!<Rx FIFO OverRun Error Interrupt Enable     */
N#define  SDMMC_MASK_CMDRENDIE                 0x00000040U        /*!<Command Response Received Interrupt Enable */
N#define  SDMMC_MASK_CMDSENTIE                 0x00000080U        /*!<Command Sent Interrupt Enable              */
N#define  SDMMC_MASK_DATAENDIE                 0x00000100U        /*!<Data End Interrupt Enable                  */
N#define  SDMMC_MASK_DBCKENDIE                 0x00000400U        /*!<Data Block End Interrupt Enable            */
N#define  SDMMC_MASK_CMDACTIE                  0x00000800U        /*!<CCommand Acting Interrupt Enable           */
N#define  SDMMC_MASK_TXACTIE                   0x00001000U        /*!<Data Transmit Acting Interrupt Enable      */
N#define  SDMMC_MASK_RXACTIE                   0x00002000U        /*!<Data receive acting interrupt enabled      */
N#define  SDMMC_MASK_TXFIFOHEIE                0x00004000U        /*!<Tx FIFO Half Empty interrupt Enable        */
N#define  SDMMC_MASK_RXFIFOHFIE                0x00008000U        /*!<Rx FIFO Half Full interrupt Enable         */
N#define  SDMMC_MASK_TXFIFOFIE                 0x00010000U        /*!<Tx FIFO Full interrupt Enable              */
N#define  SDMMC_MASK_RXFIFOFIE                 0x00020000U        /*!<Rx FIFO Full interrupt Enable              */
N#define  SDMMC_MASK_TXFIFOEIE                 0x00040000U        /*!<Tx FIFO Empty interrupt Enable             */
N#define  SDMMC_MASK_RXFIFOEIE                 0x00080000U        /*!<Rx FIFO Empty interrupt Enable             */
N#define  SDMMC_MASK_TXDAVLIE                  0x00100000U        /*!<Data available in Tx FIFO interrupt Enable */
N#define  SDMMC_MASK_RXDAVLIE                  0x00200000U        /*!<Data available in Rx FIFO interrupt Enable */
N#define  SDMMC_MASK_SDIOITIE                  0x00400000U        /*!<SDMMC Mode Interrupt Received interrupt Enable */
N
N/*****************  Bit definition for SDMMC_FIFOCNT register  *****************/
N#define  SDMMC_FIFOCNT_FIFOCOUNT              0x00FFFFFFU        /*!<Remaining number of words to be written to or read from the FIFO */
N
N/******************  Bit definition for SDMMC_FIFO register  *******************/
N#define  SDMMC_FIFO_FIFODATA                  0xFFFFFFFFU        /*!<Receive and transmit FIFO data */
N
N/******************************************************************************/
N/*                                                                            */
N/*                        Serial Peripheral Interface (SPI)                   */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for SPI_CR1 register  ********************/
N#define  SPI_CR1_CPHA                        0x00000001U        /*!< Clock Phase                        */
N#define  SPI_CR1_CPOL                        0x00000002U        /*!< Clock Polarity                     */
N#define  SPI_CR1_MSTR                        0x00000004U        /*!< Master Selection                   */
N#define  SPI_CR1_BR                          0x00000038U        /*!< BR[2:0] bits (Baud Rate Control)   */
N#define  SPI_CR1_BR_0                        0x00000008U        /*!< Bit 0 */
N#define  SPI_CR1_BR_1                        0x00000010U        /*!< Bit 1 */
N#define  SPI_CR1_BR_2                        0x00000020U        /*!< Bit 2 */
N#define  SPI_CR1_SPE                         0x00000040U        /*!< SPI Enable                          */
N#define  SPI_CR1_LSBFIRST                    0x00000080U        /*!< Frame Format                        */
N#define  SPI_CR1_SSI                         0x00000100U        /*!< Internal slave select               */
N#define  SPI_CR1_SSM                         0x00000200U        /*!< Software slave management           */
N#define  SPI_CR1_RXONLY                      0x00000400U        /*!< Receive only                        */
N#define  SPI_CR1_CRCL                        0x00000800U        /*!< CRC Length                          */
N#define  SPI_CR1_CRCNEXT                     0x00001000U        /*!< Transmit CRC next                   */
N#define  SPI_CR1_CRCEN                       0x00002000U        /*!< Hardware CRC calculation enable     */
N#define  SPI_CR1_BIDIOE                      0x00004000U        /*!< Output enable in bidirectional mode */
N#define  SPI_CR1_BIDIMODE                    0x00008000U        /*!< Bidirectional data mode enable      */
N
N/*******************  Bit definition for SPI_CR2 register  ********************/
N#define  SPI_CR2_RXDMAEN                     0x00000001U        /*!< Rx Buffer DMA Enable                 */
N#define  SPI_CR2_TXDMAEN                     0x00000002U        /*!< Tx Buffer DMA Enable                 */
N#define  SPI_CR2_SSOE                        0x00000004U        /*!< SS Output Enable                     */
N#define  SPI_CR2_NSSP                        0x00000008U        /*!< NSS pulse management Enable          */
N#define  SPI_CR2_FRF                         0x00000010U        /*!< Frame Format Enable                  */
N#define  SPI_CR2_ERRIE                       0x00000020U        /*!< Error Interrupt Enable               */
N#define  SPI_CR2_RXNEIE                      0x00000040U        /*!< RX buffer Not Empty Interrupt Enable */
N#define  SPI_CR2_TXEIE                       0x00000080U        /*!< Tx buffer Empty Interrupt Enable     */
N#define  SPI_CR2_DS                          0x00000F00U        /*!< DS[3:0] Data Size                    */
N#define  SPI_CR2_DS_0                        0x00000100U        /*!< Bit 0 */
N#define  SPI_CR2_DS_1                        0x00000200U        /*!< Bit 1 */
N#define  SPI_CR2_DS_2                        0x00000400U        /*!< Bit 2 */
N#define  SPI_CR2_DS_3                        0x00000800U        /*!< Bit 3 */
N#define  SPI_CR2_FRXTH                       0x00001000U        /*!< FIFO reception Threshold           */
N#define  SPI_CR2_LDMARX                      0x00002000U        /*!< Last DMA transfer for reception    */
N#define  SPI_CR2_LDMATX                      0x00004000U        /*!< Last DMA transfer for transmission */
N
N/********************  Bit definition for SPI_SR register  ********************/
N#define  SPI_SR_RXNE                         0x00000001U        /*!< Receive buffer Not Empty  */
N#define  SPI_SR_TXE                          0x00000002U        /*!< Transmit buffer Empty     */
N#define  SPI_SR_CHSIDE                       0x00000004U        /*!< Channel side              */
N#define  SPI_SR_UDR                          0x00000008U        /*!< Underrun flag             */
N#define  SPI_SR_CRCERR                       0x00000010U        /*!< CRC Error flag            */
N#define  SPI_SR_MODF                         0x00000020U        /*!< Mode fault                */
N#define  SPI_SR_OVR                          0x00000040U        /*!< Overrun flag              */
N#define  SPI_SR_BSY                          0x00000080U        /*!< Busy flag                 */
N#define  SPI_SR_FRE                          0x00000100U        /*!< TI frame format error     */
N#define  SPI_SR_FRLVL                        0x00000600U        /*!< FIFO Reception Level      */
N#define  SPI_SR_FRLVL_0                      0x00000200U        /*!< Bit 0 */
N#define  SPI_SR_FRLVL_1                      0x00000400U        /*!< Bit 1 */
N#define  SPI_SR_FTLVL                        0x00001800U        /*!< FIFO Transmission Level   */
N#define  SPI_SR_FTLVL_0                      0x00000800U        /*!< Bit 0 */
N#define  SPI_SR_FTLVL_1                      0x00001000U        /*!< Bit 1 */  
N
N/********************  Bit definition for SPI_DR register  ********************/
N#define  SPI_DR_DR                           0xFFFFU            /*!< Data Register */
N
N/*******************  Bit definition for SPI_CRCPR register  ******************/
N#define  SPI_CRCPR_CRCPOLY                   0xFFFFU            /*!< CRC polynomial register */
N
N/******************  Bit definition for SPI_RXCRCR register  ******************/
N#define  SPI_RXCRCR_RXCRC                    0xFFFFU            /*!< Rx CRC Register */
N
N/******************  Bit definition for SPI_TXCRCR register  ******************/
N#define  SPI_TXCRCR_TXCRC                    0xFFFFU            /*!< Tx CRC Register */
N
N/******************  Bit definition for SPI_I2SCFGR register  *****************/
N#define  SPI_I2SCFGR_CHLEN                   0x00000001U        /*!<Channel length (number of bits per audio channel) */
N#define  SPI_I2SCFGR_DATLEN                  0x00000006U        /*!<DATLEN[1:0] bits (Data length to be transferred)  */
N#define  SPI_I2SCFGR_DATLEN_0                0x00000002U        /*!<Bit 0 */
N#define  SPI_I2SCFGR_DATLEN_1                0x00000004U        /*!<Bit 1 */
N#define  SPI_I2SCFGR_CKPOL                   0x00000008U        /*!<steady state clock polarity                       */
N#define  SPI_I2SCFGR_I2SSTD                  0x00000030U        /*!<I2SSTD[1:0] bits (I2S standard selection)         */
N#define  SPI_I2SCFGR_I2SSTD_0                0x00000010U        /*!<Bit 0 */
N#define  SPI_I2SCFGR_I2SSTD_1                0x00000020U        /*!<Bit 1 */
N#define  SPI_I2SCFGR_PCMSYNC                 0x00000080U        /*!<PCM frame synchronization                         */
N#define  SPI_I2SCFGR_I2SCFG                  0x00000300U        /*!<I2SCFG[1:0] bits (I2S configuration mode)         */
N#define  SPI_I2SCFGR_I2SCFG_0                0x00000100U        /*!<Bit 0 */
N#define  SPI_I2SCFGR_I2SCFG_1                0x00000200U        /*!<Bit 1 */
N#define  SPI_I2SCFGR_I2SE                    0x00000400U        /*!<I2S Enable                                        */
N#define  SPI_I2SCFGR_I2SMOD                  0x00000800U        /*!<I2S mode selection                                */
N#define  SPI_I2SCFGR_ASTRTEN                 0x00001000U        /*!<Asynchronous start enable                        */
N
N/******************  Bit definition for SPI_I2SPR register  *******************/
N#define  SPI_I2SPR_I2SDIV                    0x00FFU            /*!<I2S Linear prescaler         */
N#define  SPI_I2SPR_ODD                       0x0100U            /*!<Odd factor for the prescaler */
N#define  SPI_I2SPR_MCKOE                     0x0200U            /*!<Master Clock Output Enable   */
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                                 SYSCFG                                     */
N/*                                                                            */
N/******************************************************************************/
N/******************  Bit definition for SYSCFG_MEMRMP register  ***************/  
N#define SYSCFG_MEMRMP_MEM_BOOT         0x00000001U /*!< Boot information after Reset */
N
N#define SYSCFG_MEMRMP_SWP_FB           0x00000100U /*!< User Flash Bank swap    */
N
N#define SYSCFG_MEMRMP_SWP_FMC          0x00000C00U /*!< FMC Memory Mapping swapping */
N#define SYSCFG_MEMRMP_SWP_FMC_0        0x00000400U 
N#define SYSCFG_MEMRMP_SWP_FMC_1        0x00000800U 
N
N/******************  Bit definition for SYSCFG_PMC register  ******************/
N#define SYSCFG_PMC_I2C1_FMP             0x00000001U /*!< I2C1_FMP I2C1 Fast Mode + Enable */
N#define SYSCFG_PMC_I2C2_FMP             0x00000002U /*!< I2C2_FMP I2C2 Fast Mode + Enable */
N#define SYSCFG_PMC_I2C3_FMP             0x00000004U /*!< I2C3_FMP I2C3 Fast Mode + Enable */
N#define SYSCFG_PMC_I2C4_FMP             0x00000008U /*!< I2C4_FMP I2C4 Fast Mode + Enable */
N#define SYSCFG_PMC_I2C_PB6_FMP          0x00000010U /*!< PB6_FMP Fast Mode + Enable */
N#define SYSCFG_PMC_I2C_PB7_FMP          0x00000020U /*!< PB7_FMP Fast Mode + Enable */
N#define SYSCFG_PMC_I2C_PB8_FMP          0x00000040U /*!< PB8_FMP Fast Mode + Enable */
N#define SYSCFG_PMC_I2C_PB9_FMP          0x00000080U /*!< PB9_FMP Fast Mode + Enable */
N
N#define SYSCFG_PMC_ADCxDC2              0x00070000U /*!< Refer to AN4073 on how to use this bit  */
N#define SYSCFG_PMC_ADC1DC2              0x00010000U /*!< Refer to AN4073 on how to use this bit  */
N#define SYSCFG_PMC_ADC2DC2              0x00020000U /*!< Refer to AN4073 on how to use this bit  */
N#define SYSCFG_PMC_ADC3DC2              0x00040000U /*!< Refer to AN4073 on how to use this bit  */
N
N#define SYSCFG_PMC_MII_RMII_SEL         0x00800000U /*!<Ethernet PHY interface selection */
N
N/*****************  Bit definition for SYSCFG_EXTICR1 register  ***************/
N#define SYSCFG_EXTICR1_EXTI0            0x000FU /*!<EXTI 0 configuration */
N#define SYSCFG_EXTICR1_EXTI1            0x00F0U /*!<EXTI 1 configuration */
N#define SYSCFG_EXTICR1_EXTI2            0x0F00U /*!<EXTI 2 configuration */
N#define SYSCFG_EXTICR1_EXTI3            0xF000U /*!<EXTI 3 configuration */
N/** 
N  * @brief   EXTI0 configuration  
N  */ 
N#define SYSCFG_EXTICR1_EXTI0_PA         0x0000U /*!<PA[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PB         0x0001U /*!<PB[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PC         0x0002U /*!<PC[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PD         0x0003U /*!<PD[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PE         0x0004U /*!<PE[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PF         0x0005U /*!<PF[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PG         0x0006U /*!<PG[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PH         0x0007U /*!<PH[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PI         0x0008U /*!<PI[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PJ         0x0009U /*!<PJ[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PK         0x000AU /*!<PK[0] pin */
N
N/** 
N  * @brief   EXTI1 configuration  
N  */ 
N#define SYSCFG_EXTICR1_EXTI1_PA         0x0000U /*!<PA[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PB         0x0010U /*!<PB[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PC         0x0020U /*!<PC[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PD         0x0030U /*!<PD[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PE         0x0040U /*!<PE[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PF         0x0050U /*!<PF[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PG         0x0060U /*!<PG[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PH         0x0070U /*!<PH[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PI         0x0080U /*!<PI[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PJ         0x0090U /*!<PJ[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PK         0x00A0U /*!<PK[1] pin */
N
N/** 
N  * @brief   EXTI2 configuration  
N  */ 
N#define SYSCFG_EXTICR1_EXTI2_PA         0x0000U /*!<PA[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PB         0x0100U /*!<PB[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PC         0x0200U /*!<PC[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PD         0x0300U /*!<PD[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PE         0x0400U /*!<PE[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PF         0x0500U /*!<PF[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PG         0x0600U /*!<PG[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PH         0x0700U /*!<PH[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PI         0x0800U /*!<PI[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PJ         0x0900U /*!<PJ[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PK         0x0A00U /*!<PK[2] pin */
N
N/** 
N  * @brief   EXTI3 configuration  
N  */ 
N#define SYSCFG_EXTICR1_EXTI3_PA         0x0000U /*!<PA[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PB         0x1000U /*!<PB[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PC         0x2000U /*!<PC[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PD         0x3000U /*!<PD[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PE         0x4000U /*!<PE[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PF         0x5000U /*!<PF[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PG         0x6000U /*!<PG[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PH         0x7000U /*!<PH[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PI         0x8000U /*!<PI[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PJ         0x9000U /*!<PJ[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PK         0xA000U /*!<PK[3] pin */
N
N/*****************  Bit definition for SYSCFG_EXTICR2 register  ***************/
N#define SYSCFG_EXTICR2_EXTI4            0x000FU /*!<EXTI 4 configuration */
N#define SYSCFG_EXTICR2_EXTI5            0x00F0U /*!<EXTI 5 configuration */
N#define SYSCFG_EXTICR2_EXTI6            0x0F00U /*!<EXTI 6 configuration */
N#define SYSCFG_EXTICR2_EXTI7            0xF000U /*!<EXTI 7 configuration */
N/** 
N  * @brief   EXTI4 configuration  
N  */ 
N#define SYSCFG_EXTICR2_EXTI4_PA         0x0000U /*!<PA[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PB         0x0001U /*!<PB[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PC         0x0002U /*!<PC[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PD         0x0003U /*!<PD[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PE         0x0004U /*!<PE[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PF         0x0005U /*!<PF[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PG         0x0006U /*!<PG[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PH         0x0007U /*!<PH[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PI         0x0008U /*!<PI[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PJ         0x0009U /*!<PJ[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PK         0x000AU /*!<PK[4] pin */
N
N/** 
N  * @brief   EXTI5 configuration  
N  */ 
N#define SYSCFG_EXTICR2_EXTI5_PA         0x0000U /*!<PA[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PB         0x0010U /*!<PB[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PC         0x0020U /*!<PC[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PD         0x0030U /*!<PD[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PE         0x0040U /*!<PE[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PF         0x0050U /*!<PF[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PG         0x0060U /*!<PG[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PH         0x0070U /*!<PH[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PI         0x0080U /*!<PI[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PJ         0x0090U /*!<PJ[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PK         0x00A0U /*!<PK[5] pin */
N
N/** 
N  * @brief   EXTI6 configuration  
N  */ 
N#define SYSCFG_EXTICR2_EXTI6_PA         0x0000U /*!<PA[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PB         0x0100U /*!<PB[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PC         0x0200U /*!<PC[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PD         0x0300U /*!<PD[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PE         0x0400U /*!<PE[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PF         0x0500U /*!<PF[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PG         0x0600U /*!<PG[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PH         0x0700U /*!<PH[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PI         0x0800U /*!<PI[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PJ         0x0900U /*!<PJ[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PK         0x0A00U /*!<PK[6] pin */
N
N/** 
N  * @brief   EXTI7 configuration  
N  */ 
N#define SYSCFG_EXTICR2_EXTI7_PA         0x0000U /*!<PA[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PB         0x1000U /*!<PB[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PC         0x2000U /*!<PC[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PD         0x3000U /*!<PD[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PE         0x4000U /*!<PE[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PF         0x5000U /*!<PF[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PG         0x6000U /*!<PG[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PH         0x7000U /*!<PH[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PI         0x8000U /*!<PI[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PJ         0x9000U /*!<PJ[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PK         0xA000U /*!<PK[7] pin */
N
N/*****************  Bit definition for SYSCFG_EXTICR3 register  ***************/
N#define SYSCFG_EXTICR3_EXTI8            0x000FU /*!<EXTI 8 configuration */
N#define SYSCFG_EXTICR3_EXTI9            0x00F0U /*!<EXTI 9 configuration */
N#define SYSCFG_EXTICR3_EXTI10           0x0F00U /*!<EXTI 10 configuration */
N#define SYSCFG_EXTICR3_EXTI11           0xF000U /*!<EXTI 11 configuration */
N           
N/** 
N  * @brief   EXTI8 configuration  
N  */ 
N#define SYSCFG_EXTICR3_EXTI8_PA         0x0000U /*!<PA[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PB         0x0001U /*!<PB[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PC         0x0002U /*!<PC[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PD         0x0003U /*!<PD[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PE         0x0004U /*!<PE[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PF         0x0005U /*!<PF[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PG         0x0006U /*!<PG[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PH         0x0007U /*!<PH[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PI         0x0008U /*!<PI[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PJ         0x0009U /*!<PJ[8] pin */
N
N/** 
N  * @brief   EXTI9 configuration  
N  */ 
N#define SYSCFG_EXTICR3_EXTI9_PA         0x0000U /*!<PA[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PB         0x0010U /*!<PB[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PC         0x0020U /*!<PC[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PD         0x0030U /*!<PD[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PE         0x0040U /*!<PE[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PF         0x0050U /*!<PF[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PG         0x0060U /*!<PG[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PH         0x0070U /*!<PH[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PI         0x0080U /*!<PI[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PJ         0x0090U /*!<PJ[9] pin */
N
N/** 
N  * @brief   EXTI10 configuration  
N  */ 
N#define SYSCFG_EXTICR3_EXTI10_PA        0x0000U /*!<PA[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PB        0x0100U /*!<PB[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PC        0x0200U /*!<PC[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PD        0x0300U /*!<PD[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PE        0x0400U /*!<PE[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PF        0x0500U /*!<PF[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PG        0x0600U /*!<PG[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PH        0x0700U /*!<PH[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PI        0x0800U /*!<PI[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PJ        0x0900U /*!<PJ[10] pin */
N
N/** 
N  * @brief   EXTI11 configuration  
N  */ 
N#define SYSCFG_EXTICR3_EXTI11_PA        0x0000U /*!<PA[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PB        0x1000U /*!<PB[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PC        0x2000U /*!<PC[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PD        0x3000U /*!<PD[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PE        0x4000U /*!<PE[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PF        0x5000U /*!<PF[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PG        0x6000U /*!<PG[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PH        0x7000U /*!<PH[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PI        0x8000U /*!<PI[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PJ        0x9000U /*!<PJ[11] pin */
N
N
N/*****************  Bit definition for SYSCFG_EXTICR4 register  ***************/
N#define SYSCFG_EXTICR4_EXTI12           0x000FU /*!<EXTI 12 configuration */
N#define SYSCFG_EXTICR4_EXTI13           0x00F0U /*!<EXTI 13 configuration */
N#define SYSCFG_EXTICR4_EXTI14           0x0F00U /*!<EXTI 14 configuration */
N#define SYSCFG_EXTICR4_EXTI15           0xF000U /*!<EXTI 15 configuration */
N/** 
N  * @brief   EXTI12 configuration  
N  */ 
N#define SYSCFG_EXTICR4_EXTI12_PA        0x0000U /*!<PA[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PB        0x0001U /*!<PB[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PC        0x0002U /*!<PC[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PD        0x0003U /*!<PD[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PE        0x0004U /*!<PE[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PF        0x0005U /*!<PF[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PG        0x0006U /*!<PG[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PH        0x0007U /*!<PH[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PI        0x0008U /*!<PI[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PJ        0x0009U /*!<PJ[12] pin */
N
N/** 
N  * @brief   EXTI13 configuration  
N  */ 
N#define SYSCFG_EXTICR4_EXTI13_PA        0x0000U /*!<PA[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PB        0x0010U /*!<PB[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PC        0x0020U /*!<PC[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PD        0x0030U /*!<PD[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PE        0x0040U /*!<PE[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PF        0x0050U /*!<PF[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PG        0x0060U /*!<PG[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PH        0x0070U /*!<PH[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PI        0x0080U /*!<PI[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PJ        0x0090U /*!<PJ[13] pin */
N
N/** 
N  * @brief   EXTI14 configuration  
N  */ 
N#define SYSCFG_EXTICR4_EXTI14_PA        0x0000U /*!<PA[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PB        0x0100U /*!<PB[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PC        0x0200U /*!<PC[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PD        0x0300U /*!<PD[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PE        0x0400U /*!<PE[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PF        0x0500U /*!<PF[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PG        0x0600U /*!<PG[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PH        0x0700U /*!<PH[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PI        0x0800U /*!<PI[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PJ        0x0900U /*!<PJ[14] pin */
N
N/** 
N  * @brief   EXTI15 configuration  
N  */ 
N#define SYSCFG_EXTICR4_EXTI15_PA        0x0000U /*!<PA[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PB        0x1000U /*!<PB[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PC        0x2000U /*!<PC[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PD        0x3000U /*!<PD[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PE        0x4000U /*!<PE[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PF        0x5000U /*!<PF[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PG        0x6000U /*!<PG[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PH        0x7000U /*!<PH[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PI        0x8000U /*!<PI[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PJ        0x9000U /*!<PJ[15] pin */
N
N/******************  Bit definition for SYSCFG_CBR register  ******************/  
N#define SYSCFG_CBR_CLL                  0x00000001U /*!<Core Lockup Lock */
N#define SYSCFG_CBR_PVDL                 0x00000004U /*!<PVD Lock         */
N
N/******************  Bit definition for SYSCFG_CMPCR register  ****************/  
N#define SYSCFG_CMPCR_CMP_PD             0x00000001U /*!<Compensation cell power-down */
N#define SYSCFG_CMPCR_READY              0x00000100U /*!<Compensation cell ready flag */
N
N/******************************************************************************/
N/*                                                                            */
N/*                                    TIM                                     */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for TIM_CR1 register  ********************/
N#define  TIM_CR1_CEN                         0x0001U            /*!<Counter enable        */
N#define  TIM_CR1_UDIS                        0x0002U            /*!<Update disable        */
N#define  TIM_CR1_URS                         0x0004U            /*!<Update request source */
N#define  TIM_CR1_OPM                         0x0008U            /*!<One pulse mode        */
N#define  TIM_CR1_DIR                         0x0010U            /*!<Direction             */
N
N#define  TIM_CR1_CMS                         0x0060U            /*!<CMS[1:0] bits (Center-aligned mode selection) */
N#define  TIM_CR1_CMS_0                       0x0020U            /*!<Bit 0 */
N#define  TIM_CR1_CMS_1                       0x0040U            /*!<Bit 1 */
N
N#define  TIM_CR1_ARPE                        0x0080U            /*!<Auto-reload preload enable     */
N
N#define  TIM_CR1_CKD                         0x0300U            /*!<CKD[1:0] bits (clock division) */
N#define  TIM_CR1_CKD_0                       0x0100U            /*!<Bit 0 */
N#define  TIM_CR1_CKD_1                       0x0200U            /*!<Bit 1 */
N#define  TIM_CR1_UIFREMAP                    0x0800U            /*!<UIF status bit */
N
N/*******************  Bit definition for TIM_CR2 register  ********************/
N#define  TIM_CR2_CCPC                        0x00000001U            /*!<Capture/Compare Preloaded Control        */
N#define  TIM_CR2_CCUS                        0x00000004U            /*!<Capture/Compare Control Update Selection */
N#define  TIM_CR2_CCDS                        0x00000008U            /*!<Capture/Compare DMA Selection            */
N
N#define  TIM_CR2_OIS5                        0x00010000U            /*!<Output Idle state 4 (OC4 output) */
N#define  TIM_CR2_OIS6                        0x00040000U            /*!<Output Idle state 4 (OC4 output) */
N
N#define  TIM_CR2_MMS                         0x0070U           /*!<MMS[2:0] bits (Master Mode Selection) */
N#define  TIM_CR2_MMS_0                       0x0010U           /*!<Bit 0 */
N#define  TIM_CR2_MMS_1                       0x0020U           /*!<Bit 1 */
N#define  TIM_CR2_MMS_2                       0x0040U           /*!<Bit 2 */
N
N#define  TIM_CR2_MMS2                        0x00F00000U            /*!<MMS[2:0] bits (Master Mode Selection) */
N#define  TIM_CR2_MMS2_0                      0x00100000U            /*!<Bit 0 */
N#define  TIM_CR2_MMS2_1                      0x00200000U            /*!<Bit 1 */
N#define  TIM_CR2_MMS2_2                      0x00400000U            /*!<Bit 2 */
N#define  TIM_CR2_MMS2_3                      0x00800000U            /*!<Bit 2 */
N
N#define  TIM_CR2_TI1S                        0x0080U            /*!<TI1 Selection */
N#define  TIM_CR2_OIS1                        0x0100U            /*!<Output Idle state 1 (OC1 output)  */
N#define  TIM_CR2_OIS1N                       0x0200U            /*!<Output Idle state 1 (OC1N output) */
N#define  TIM_CR2_OIS2                        0x0400U            /*!<Output Idle state 2 (OC2 output)  */
N#define  TIM_CR2_OIS2N                       0x0800U            /*!<Output Idle state 2 (OC2N output) */
N#define  TIM_CR2_OIS3                        0x1000U            /*!<Output Idle state 3 (OC3 output)  */
N#define  TIM_CR2_OIS3N                       0x2000U            /*!<Output Idle state 3 (OC3N output) */
N#define  TIM_CR2_OIS4                        0x4000U            /*!<Output Idle state 4 (OC4 output)  */
N
N/*******************  Bit definition for TIM_SMCR register  *******************/
N#define  TIM_SMCR_SMS                        0x00010007U            /*!<SMS[2:0] bits (Slave mode selection)    */
N#define  TIM_SMCR_SMS_0                      0x00000001U            /*!<Bit 0 */
N#define  TIM_SMCR_SMS_1                      0x00000002U            /*!<Bit 1 */
N#define  TIM_SMCR_SMS_2                      0x00000004U            /*!<Bit 2 */
N#define  TIM_SMCR_SMS_3                      0x00010000U            /*!<Bit 3 */
N#define  TIM_SMCR_OCCS                       0x00000008U            /*!< OCREF clear selection */
N
N#define  TIM_SMCR_TS                         0x0070U            /*!<TS[2:0] bits (Trigger selection)        */
N#define  TIM_SMCR_TS_0                       0x0010U            /*!<Bit 0 */
N#define  TIM_SMCR_TS_1                       0x0020U            /*!<Bit 1 */
N#define  TIM_SMCR_TS_2                       0x0040U            /*!<Bit 2 */
N
N#define  TIM_SMCR_MSM                        0x0080U            /*!<Master/slave mode                       */
N
N#define  TIM_SMCR_ETF                        0x0F00U            /*!<ETF[3:0] bits (External trigger filter) */
N#define  TIM_SMCR_ETF_0                      0x0100U            /*!<Bit 0 */
N#define  TIM_SMCR_ETF_1                      0x0200U            /*!<Bit 1 */
N#define  TIM_SMCR_ETF_2                      0x0400U            /*!<Bit 2 */
N#define  TIM_SMCR_ETF_3                      0x0800U            /*!<Bit 3 */
N
N#define  TIM_SMCR_ETPS                       0x3000U            /*!<ETPS[1:0] bits (External trigger prescaler) */
N#define  TIM_SMCR_ETPS_0                     0x1000U            /*!<Bit 0 */
N#define  TIM_SMCR_ETPS_1                     0x2000U            /*!<Bit 1 */
N
N#define  TIM_SMCR_ECE                        0x4000U            /*!<External clock enable     */
N#define  TIM_SMCR_ETP                        0x8000U            /*!<External trigger polarity */
N
N/*******************  Bit definition for TIM_DIER register  *******************/
N#define  TIM_DIER_UIE                        0x0001U            /*!<Update interrupt enable */
N#define  TIM_DIER_CC1IE                      0x0002U            /*!<Capture/Compare 1 interrupt enable   */
N#define  TIM_DIER_CC2IE                      0x0004U            /*!<Capture/Compare 2 interrupt enable   */
N#define  TIM_DIER_CC3IE                      0x0008U            /*!<Capture/Compare 3 interrupt enable   */
N#define  TIM_DIER_CC4IE                      0x0010U            /*!<Capture/Compare 4 interrupt enable   */
N#define  TIM_DIER_COMIE                      0x0020U            /*!<COM interrupt enable                 */
N#define  TIM_DIER_TIE                        0x0040U            /*!<Trigger interrupt enable             */
N#define  TIM_DIER_BIE                        0x0080U            /*!<Break interrupt enable               */
N#define  TIM_DIER_UDE                        0x0100U            /*!<Update DMA request enable            */
N#define  TIM_DIER_CC1DE                      0x0200U            /*!<Capture/Compare 1 DMA request enable */
N#define  TIM_DIER_CC2DE                      0x0400U            /*!<Capture/Compare 2 DMA request enable */
N#define  TIM_DIER_CC3DE                      0x0800U            /*!<Capture/Compare 3 DMA request enable */
N#define  TIM_DIER_CC4DE                      0x1000U            /*!<Capture/Compare 4 DMA request enable */
N#define  TIM_DIER_COMDE                      0x2000U            /*!<COM DMA request enable               */
N#define  TIM_DIER_TDE                        0x4000U            /*!<Trigger DMA request enable           */
N
N/********************  Bit definition for TIM_SR register  ********************/
N#define  TIM_SR_UIF                          0x0001U            /*!<Update interrupt Flag              */
N#define  TIM_SR_CC1IF                        0x0002U            /*!<Capture/Compare 1 interrupt Flag   */
N#define  TIM_SR_CC2IF                        0x0004U            /*!<Capture/Compare 2 interrupt Flag   */
N#define  TIM_SR_CC3IF                        0x0008U            /*!<Capture/Compare 3 interrupt Flag   */
N#define  TIM_SR_CC4IF                        0x0010U            /*!<Capture/Compare 4 interrupt Flag   */
N#define  TIM_SR_COMIF                        0x0020U            /*!<COM interrupt Flag                 */
N#define  TIM_SR_TIF                          0x0040U            /*!<Trigger interrupt Flag             */
N#define  TIM_SR_BIF                          0x0080U            /*!<Break interrupt Flag               */
N#define  TIM_SR_B2IF                         0x0100U            /*!<Break2 interrupt Flag               */
N#define  TIM_SR_CC1OF                        0x0200U            /*!<Capture/Compare 1 Overcapture Flag */
N#define  TIM_SR_CC2OF                        0x0400U            /*!<Capture/Compare 2 Overcapture Flag */
N#define  TIM_SR_CC3OF                        0x0800U            /*!<Capture/Compare 3 Overcapture Flag */
N#define  TIM_SR_CC4OF                        0x1000U            /*!<Capture/Compare 4 Overcapture Flag */
N
N/*******************  Bit definition for TIM_EGR register  ********************/
N#define  TIM_EGR_UG                          0x00000001U               /*!<Update Generation                         */
N#define  TIM_EGR_CC1G                        0x00000002U               /*!<Capture/Compare 1 Generation              */
N#define  TIM_EGR_CC2G                        0x00000004U               /*!<Capture/Compare 2 Generation              */
N#define  TIM_EGR_CC3G                        0x00000008U               /*!<Capture/Compare 3 Generation              */
N#define  TIM_EGR_CC4G                        0x00000010U               /*!<Capture/Compare 4 Generation              */
N#define  TIM_EGR_COMG                        0x00000020U               /*!<Capture/Compare Control Update Generation */
N#define  TIM_EGR_TG                          0x00000040U               /*!<Trigger Generation                        */
N#define  TIM_EGR_BG                          0x00000080U               /*!<Break Generation                          */
N#define  TIM_EGR_B2G                         0x00000100U              /*!<Break2 Generation                          */
N
N/******************  Bit definition for TIM_CCMR1 register  *******************/
N#define  TIM_CCMR1_CC1S                      0x00000003U            /*!<CC1S[1:0] bits (Capture/Compare 1 Selection) */
N#define  TIM_CCMR1_CC1S_0                    0x00000001U            /*!<Bit 0 */
N#define  TIM_CCMR1_CC1S_1                    0x00000002U            /*!<Bit 1 */
N
N#define  TIM_CCMR1_OC1FE                     0x00000004U            /*!<Output Compare 1 Fast enable                 */
N#define  TIM_CCMR1_OC1PE                     0x00000008U            /*!<Output Compare 1 Preload enable              */
N
N#define  TIM_CCMR1_OC1M                      0x00010070U            /*!<OC1M[2:0] bits (Output Compare 1 Mode)       */
N#define  TIM_CCMR1_OC1M_0                    0x00000010U            /*!<Bit 0 */
N#define  TIM_CCMR1_OC1M_1                    0x00000020U            /*!<Bit 1 */
N#define  TIM_CCMR1_OC1M_2                    0x00000040U            /*!<Bit 2 */
N#define  TIM_CCMR1_OC1M_3                    0x00010000U            /*!<Bit 3 */
N
N#define  TIM_CCMR1_OC1CE                     0x00000080U            /*!<Output Compare 1Clear Enable                 */
N
N#define  TIM_CCMR1_CC2S                      0x00000300U            /*!<CC2S[1:0] bits (Capture/Compare 2 Selection) */
N#define  TIM_CCMR1_CC2S_0                    0x00000100U            /*!<Bit 0 */
N#define  TIM_CCMR1_CC2S_1                    0x00000200U            /*!<Bit 1 */
N
N#define  TIM_CCMR1_OC2FE                     0x00000400U            /*!<Output Compare 2 Fast enable                 */
N#define  TIM_CCMR1_OC2PE                     0x00000800U            /*!<Output Compare 2 Preload enable              */
N
N#define  TIM_CCMR1_OC2M                      0x01007000U            /*!<OC2M[2:0] bits (Output Compare 2 Mode)       */
N#define  TIM_CCMR1_OC2M_0                    0x00001000U            /*!<Bit 0 */
N#define  TIM_CCMR1_OC2M_1                    0x00002000U            /*!<Bit 1 */
N#define  TIM_CCMR1_OC2M_2                    0x00004000U            /*!<Bit 2 */
N#define  TIM_CCMR1_OC2M_3                    0x01000000U            /*!<Bit 3 */
N
N#define  TIM_CCMR1_OC2CE                     0x00008000U            /*!<Output Compare 2 Clear Enable */
N
N/*----------------------------------------------------------------------------*/
N
N#define  TIM_CCMR1_IC1PSC                    0x000CU            /*!<IC1PSC[1:0] bits (Input Capture 1 Prescaler) */
N#define  TIM_CCMR1_IC1PSC_0                  0x0004U            /*!<Bit 0 */
N#define  TIM_CCMR1_IC1PSC_1                  0x0008U            /*!<Bit 1 */
N
N#define  TIM_CCMR1_IC1F                      0x00F0U            /*!<IC1F[3:0] bits (Input Capture 1 Filter)      */
N#define  TIM_CCMR1_IC1F_0                    0x0010U            /*!<Bit 0 */
N#define  TIM_CCMR1_IC1F_1                    0x0020U            /*!<Bit 1 */
N#define  TIM_CCMR1_IC1F_2                    0x0040U            /*!<Bit 2 */
N#define  TIM_CCMR1_IC1F_3                    0x0080U            /*!<Bit 3 */
N
N#define  TIM_CCMR1_IC2PSC                    0x0C00U            /*!<IC2PSC[1:0] bits (Input Capture 2 Prescaler)  */
N#define  TIM_CCMR1_IC2PSC_0                  0x0400U            /*!<Bit 0 */
N#define  TIM_CCMR1_IC2PSC_1                  0x0800U            /*!<Bit 1 */
N
N#define  TIM_CCMR1_IC2F                      0xF000U            /*!<IC2F[3:0] bits (Input Capture 2 Filter)       */
N#define  TIM_CCMR1_IC2F_0                    0x1000U            /*!<Bit 0 */
N#define  TIM_CCMR1_IC2F_1                    0x2000U            /*!<Bit 1 */
N#define  TIM_CCMR1_IC2F_2                    0x4000U            /*!<Bit 2 */
N#define  TIM_CCMR1_IC2F_3                    0x8000U            /*!<Bit 3 */
N
N/******************  Bit definition for TIM_CCMR2 register  *******************/
N#define  TIM_CCMR2_CC3S                      0x00000003U        /*!<CC3S[1:0] bits (Capture/Compare 3 Selection)  */
N#define  TIM_CCMR2_CC3S_0                    0x00000001U        /*!<Bit 0 */
N#define  TIM_CCMR2_CC3S_1                    0x00000002U        /*!<Bit 1 */
N
N#define  TIM_CCMR2_OC3FE                     0x00000004U        /*!<Output Compare 3 Fast enable           */
N#define  TIM_CCMR2_OC3PE                     0x00000008U        /*!<Output Compare 3 Preload enable        */
N
N#define  TIM_CCMR2_OC3M                      0x00010070U        /*!<OC3M[2:0] bits (Output Compare 3 Mode) */
N#define  TIM_CCMR2_OC3M_0                    0x00000010U        /*!<Bit 0 */
N#define  TIM_CCMR2_OC3M_1                    0x00000020U        /*!<Bit 1 */
N#define  TIM_CCMR2_OC3M_2                    0x00000040U        /*!<Bit 2 */
N#define  TIM_CCMR2_OC3M_3                    0x00010000U        /*!<Bit 3 */
N
N
N
N#define  TIM_CCMR2_OC3CE                     0x00000080U        /*!<Output Compare 3 Clear Enable */
N
N#define  TIM_CCMR2_CC4S                      0x00000300U        /*!<CC4S[1:0] bits (Capture/Compare 4 Selection) */
N#define  TIM_CCMR2_CC4S_0                    0x00000100U        /*!<Bit 0 */
N#define  TIM_CCMR2_CC4S_1                    0x00000200U        /*!<Bit 1 */
N
N#define  TIM_CCMR2_OC4FE                     0x00000400U        /*!<Output Compare 4 Fast enable    */
N#define  TIM_CCMR2_OC4PE                     0x00000800U        /*!<Output Compare 4 Preload enable */
N
N#define  TIM_CCMR2_OC4M                      0x01007000U        /*!<OC4M[2:0] bits (Output Compare 4 Mode) */
N#define  TIM_CCMR2_OC4M_0                    0x00001000U        /*!<Bit 0 */
N#define  TIM_CCMR2_OC4M_1                    0x00002000U        /*!<Bit 1 */
N#define  TIM_CCMR2_OC4M_2                    0x00004000U        /*!<Bit 2 */
N#define  TIM_CCMR2_OC4M_3                    0x01000000U        /*!<Bit 3 */
N
N#define  TIM_CCMR2_OC4CE                     0x8000U            /*!<Output Compare 4 Clear Enable */
N
N/*----------------------------------------------------------------------------*/
N
N#define  TIM_CCMR2_IC3PSC                    0x000CU            /*!<IC3PSC[1:0] bits (Input Capture 3 Prescaler) */
N#define  TIM_CCMR2_IC3PSC_0                  0x0004U            /*!<Bit 0 */
N#define  TIM_CCMR2_IC3PSC_1                  0x0008U            /*!<Bit 1 */
N
N#define  TIM_CCMR2_IC3F                      0x00F0U            /*!<IC3F[3:0] bits (Input Capture 3 Filter) */
N#define  TIM_CCMR2_IC3F_0                    0x0010U            /*!<Bit 0 */
N#define  TIM_CCMR2_IC3F_1                    0x0020U            /*!<Bit 1 */
N#define  TIM_CCMR2_IC3F_2                    0x0040U            /*!<Bit 2 */
N#define  TIM_CCMR2_IC3F_3                    0x0080U            /*!<Bit 3 */
N
N#define  TIM_CCMR2_IC4PSC                    0x0C00U            /*!<IC4PSC[1:0] bits (Input Capture 4 Prescaler) */
N#define  TIM_CCMR2_IC4PSC_0                  0x0400U            /*!<Bit 0 */
N#define  TIM_CCMR2_IC4PSC_1                  0x0800U            /*!<Bit 1 */
N
N#define  TIM_CCMR2_IC4F                      0xF000U            /*!<IC4F[3:0] bits (Input Capture 4 Filter) */
N#define  TIM_CCMR2_IC4F_0                    0x1000U            /*!<Bit 0 */
N#define  TIM_CCMR2_IC4F_1                    0x2000U            /*!<Bit 1 */
N#define  TIM_CCMR2_IC4F_2                    0x4000U            /*!<Bit 2 */
N#define  TIM_CCMR2_IC4F_3                    0x8000U            /*!<Bit 3 */
N
N/*******************  Bit definition for TIM_CCER register  *******************/
N#define  TIM_CCER_CC1E                       0x00000001U            /*!<Capture/Compare 1 output enable */
N#define  TIM_CCER_CC1P                       0x00000002U            /*!<Capture/Compare 1 output Polarity */
N#define  TIM_CCER_CC1NE                      0x00000004U            /*!<Capture/Compare 1 Complementary output enable */
N#define  TIM_CCER_CC1NP                      0x00000008U            /*!<Capture/Compare 1 Complementary output Polarity */
N#define  TIM_CCER_CC2E                       0x00000010U            /*!<Capture/Compare 2 output enable */
N#define  TIM_CCER_CC2P                       0x00000020U            /*!<Capture/Compare 2 output Polarity */
N#define  TIM_CCER_CC2NE                      0x00000040U            /*!<Capture/Compare 2 Complementary output enable */
N#define  TIM_CCER_CC2NP                      0x00000080U            /*!<Capture/Compare 2 Complementary output Polarity */
N#define  TIM_CCER_CC3E                       0x00000100U            /*!<Capture/Compare 3 output enable */
N#define  TIM_CCER_CC3P                       0x00000200U            /*!<Capture/Compare 3 output Polarity */
N#define  TIM_CCER_CC3NE                      0x00000400U            /*!<Capture/Compare 3 Complementary output enable */
N#define  TIM_CCER_CC3NP                      0x00000800U            /*!<Capture/Compare 3 Complementary output Polarity */
N#define  TIM_CCER_CC4E                       0x00001000U            /*!<Capture/Compare 4 output enable */
N#define  TIM_CCER_CC4P                       0x00002000U            /*!<Capture/Compare 4 output Polarity */
N#define  TIM_CCER_CC4NP                      0x00008000U            /*!<Capture/Compare 4 Complementary output Polarity */
N#define  TIM_CCER_CC5E                       0x00010000U            /*!<Capture/Compare 5 output enable */
N#define  TIM_CCER_CC5P                       0x00020000U            /*!<Capture/Compare 5 output Polarity */
N#define  TIM_CCER_CC6E                       0x00100000U            /*!<Capture/Compare 6 output enable */
N#define  TIM_CCER_CC6P                       0x00200000U            /*!<Capture/Compare 6 output Polarity */
N
N
N/*******************  Bit definition for TIM_CNT register  ********************/
N#define  TIM_CNT_CNT                         0xFFFFU            /*!<Counter Value            */
N
N/*******************  Bit definition for TIM_PSC register  ********************/
N#define  TIM_PSC_PSC                         0xFFFFU            /*!<Prescaler Value          */
N
N/*******************  Bit definition for TIM_ARR register  ********************/
N#define  TIM_ARR_ARR                         0xFFFFU            /*!<actual auto-reload Value */
N
N/*******************  Bit definition for TIM_RCR register  ********************/
N#define  TIM_RCR_REP                         ((uint8_t)0xFFU)               /*!<Repetition Counter Value */
N
N/*******************  Bit definition for TIM_CCR1 register  *******************/
N#define  TIM_CCR1_CCR1                       0xFFFFU            /*!<Capture/Compare 1 Value  */
N
N/*******************  Bit definition for TIM_CCR2 register  *******************/
N#define  TIM_CCR2_CCR2                       0xFFFFU            /*!<Capture/Compare 2 Value  */
N
N/*******************  Bit definition for TIM_CCR3 register  *******************/
N#define  TIM_CCR3_CCR3                       0xFFFFU            /*!<Capture/Compare 3 Value  */
N
N/*******************  Bit definition for TIM_CCR4 register  *******************/
N#define  TIM_CCR4_CCR4                       0xFFFFU            /*!<Capture/Compare 4 Value  */
N
N/*******************  Bit definition for TIM_BDTR register  *******************/
N#define  TIM_BDTR_DTG                        0x000000FFU            /*!<DTG[0:7] bits (Dead-Time Generator set-up) */
N#define  TIM_BDTR_DTG_0                      0x00000001U            /*!<Bit 0 */
N#define  TIM_BDTR_DTG_1                      0x00000002U            /*!<Bit 1 */
N#define  TIM_BDTR_DTG_2                      0x00000004U            /*!<Bit 2 */
N#define  TIM_BDTR_DTG_3                      0x00000008U            /*!<Bit 3 */
N#define  TIM_BDTR_DTG_4                      0x00000010U            /*!<Bit 4 */
N#define  TIM_BDTR_DTG_5                      0x00000020U            /*!<Bit 5 */
N#define  TIM_BDTR_DTG_6                      0x00000040U            /*!<Bit 6 */
N#define  TIM_BDTR_DTG_7                      0x00000080U            /*!<Bit 7 */
N
N#define  TIM_BDTR_LOCK                       0x00000300U            /*!<LOCK[1:0] bits (Lock Configuration) */
N#define  TIM_BDTR_LOCK_0                     0x00000100U            /*!<Bit 0 */
N#define  TIM_BDTR_LOCK_1                     0x00000200U            /*!<Bit 1 */
N
N#define  TIM_BDTR_OSSI                       0x00000400U            /*!<Off-State Selection for Idle mode */
N#define  TIM_BDTR_OSSR                       0x00000800U            /*!<Off-State Selection for Run mode  */
N#define  TIM_BDTR_BKE                        0x00001000U            /*!<Break enable                      */
N#define  TIM_BDTR_BKP                        0x00002000U            /*!<Break Polarity                    */
N#define  TIM_BDTR_AOE                        0x00004000U            /*!<Automatic Output enable           */
N#define  TIM_BDTR_MOE                        0x00008000U            /*!<Main Output enable                */
N#define  TIM_BDTR_BKF                        0x000F0000U            /*!<Break Filter for Break1 */
N#define  TIM_BDTR_BK2F                       0x00F00000U            /*!<Break Filter for Break2 */
N#define  TIM_BDTR_BK2E                       0x01000000U            /*!<Break enable for Break2 */
N#define  TIM_BDTR_BK2P                       0x02000000U            /*!<Break Polarity for Break2 */
N
N/*******************  Bit definition for TIM_DCR register  ********************/
N#define  TIM_DCR_DBA                         0x001FU            /*!<DBA[4:0] bits (DMA Base Address) */
N#define  TIM_DCR_DBA_0                       0x0001U            /*!<Bit 0 */
N#define  TIM_DCR_DBA_1                       0x0002U            /*!<Bit 1 */
N#define  TIM_DCR_DBA_2                       0x0004U            /*!<Bit 2 */
N#define  TIM_DCR_DBA_3                       0x0008U            /*!<Bit 3 */
N#define  TIM_DCR_DBA_4                       0x0010U            /*!<Bit 4 */
N
N#define  TIM_DCR_DBL                         0x1F00U            /*!<DBL[4:0] bits (DMA Burst Length) */
N#define  TIM_DCR_DBL_0                       0x0100U            /*!<Bit 0 */
N#define  TIM_DCR_DBL_1                       0x0200U            /*!<Bit 1 */
N#define  TIM_DCR_DBL_2                       0x0400U            /*!<Bit 2 */
N#define  TIM_DCR_DBL_3                       0x0800U            /*!<Bit 3 */
N#define  TIM_DCR_DBL_4                       0x1000U            /*!<Bit 4 */
N
N/*******************  Bit definition for TIM_DMAR register  *******************/
N#define  TIM_DMAR_DMAB                       0xFFFFU            /*!<DMA register for burst accesses                    */
N
N/*******************  Bit definition for TIM_OR regiter  *********************/
N#define TIM_OR_TI4_RMP                       0x00C0U            /*!<TI4_RMP[1:0] bits (TIM5 Input 4 remap)             */
N#define TIM_OR_TI4_RMP_0                     0x0040U            /*!<Bit 0 */
N#define TIM_OR_TI4_RMP_1                     0x0080U            /*!<Bit 1 */
N#define TIM_OR_ITR1_RMP                      0x0C00U            /*!<ITR1_RMP[1:0] bits (TIM2 Internal trigger 1 remap) */
N#define TIM_OR_ITR1_RMP_0                    0x0400U            /*!<Bit 0 */
N#define TIM_OR_ITR1_RMP_1                    0x0800U            /*!<Bit 1 */
N
N/******************  Bit definition for TIM_CCMR3 register  *******************/
N#define  TIM_CCMR3_OC5FE                     0x00000004U            /*!<Output Compare 5 Fast enable */
N#define  TIM_CCMR3_OC5PE                     0x00000008U            /*!<Output Compare 5 Preload enable */
N
N#define  TIM_CCMR3_OC5M                      0x00010070U            /*!<OC5M[2:0] bits (Output Compare 5 Mode) */
N#define  TIM_CCMR3_OC5M_0                    0x00000010U            /*!<Bit 0 */
N#define  TIM_CCMR3_OC5M_1                    0x00000020U            /*!<Bit 1 */
N#define  TIM_CCMR3_OC5M_2                    0x00000040U            /*!<Bit 2 */
N#define  TIM_CCMR3_OC5M_3                    0x00010000U            /*!<Bit 3 */
N
N#define  TIM_CCMR3_OC5CE                     0x00000080U            /*!<Output Compare 5 Clear Enable */
N
N#define  TIM_CCMR3_OC6FE                     0x00000400U            /*!<Output Compare 4 Fast enable */
N#define  TIM_CCMR3_OC6PE                     0x00000800U            /*!<Output Compare 4 Preload enable */
N
N#define  TIM_CCMR3_OC6M                      0x01007000U            /*!<OC4M[2:0] bits (Output Compare 4 Mode) */
N#define  TIM_CCMR3_OC6M_0                    0x00001000U            /*!<Bit 0 */
N#define  TIM_CCMR3_OC6M_1                    0x00002000U            /*!<Bit 1 */
N#define  TIM_CCMR3_OC6M_2                    0x00004000U            /*!<Bit 2 */
N#define  TIM_CCMR3_OC6M_3                    0x01000000U            /*!<Bit 3 */
N
N#define  TIM_CCMR3_OC6CE                     0x00008000U            /*!<Output Compare 4 Clear Enable */
N
N/*******************  Bit definition for TIM_CCR5 register  *******************/
N#define  TIM_CCR5_CCR5                       0xFFFFFFFFU        /*!<Capture/Compare 5 Value */
N#define  TIM_CCR5_GC5C1                      0x20000000U        /*!<Group Channel 5 and Channel 1 */
N#define  TIM_CCR5_GC5C2                      0x40000000U        /*!<Group Channel 5 and Channel 2 */
N#define  TIM_CCR5_GC5C3                      0x80000000U        /*!<Group Channel 5 and Channel 3 */
N
N/*******************  Bit definition for TIM_CCR6 register  *******************/
N#define  TIM_CCR6_CCR6                       ((uint16_t)0xFFFFU)            /*!<Capture/Compare 6 Value */
N
N/*******************  Bit definition for TIM1_AF1 register  *******************/
N#define TIM1_AF1_BKINE                       0x00000001U        /*!<BRK BKIN input enable */
N#define TIM1_AF1_BKDF1BKE                    0x00000100U        /*!<BRK DFSDM1_BREAK enable */
N
N/*******************  Bit definition for TIM1_AF2 register  *******************/
N#define TIM1_AF2_BK2INE                      0x00000001U        /*!<BRK2 BKIN input enable */
N#define TIM1_AF2_BK2DF1BKE                   0x00000100U        /*!<BRK2 DFSDM1_BREAK enable */
N
N/*******************  Bit definition for TIM8_AF1 register  *******************/
N#define TIM8_AF1_BKINE                       0x00000001U        /*!<BRK BKIN input enable */
N#define TIM8_AF1_BKDF1BKE                    0x00000100U        /*!<BRK DFSDM1_BREAK enable */
N
N/*******************  Bit definition for TIM8_AF2 register  *******************/
N#define TIM8_AF2_BK2INE                      0x00000001U        /*!<BRK2 BKIN2 input enable */
N#define TIM8_AF2_BK2DF1BKE                   0x00000100U        /*!<BRK2 DFSDM1_BREAK enable */
N
N/******************************************************************************/
N/*                                                                            */
N/*                         Low Power Timer (LPTIM)                            */
N/*                                                                            */
N/******************************************************************************/
N/******************  Bit definition for LPTIM_ISR register  *******************/
N#define  LPTIM_ISR_CMPM                         0x00000001U            /*!< Compare match                       */
N#define  LPTIM_ISR_ARRM                         0x00000002U            /*!< Autoreload match                    */
N#define  LPTIM_ISR_EXTTRIG                      0x00000004U            /*!< External trigger edge event         */
N#define  LPTIM_ISR_CMPOK                        0x00000008U            /*!< Compare register update OK          */
N#define  LPTIM_ISR_ARROK                        0x00000010U            /*!< Autoreload register update OK       */
N#define  LPTIM_ISR_UP                           0x00000020U            /*!< Counter direction change down to up */
N#define  LPTIM_ISR_DOWN                         0x00000040U            /*!< Counter direction change up to down */
N
N/******************  Bit definition for LPTIM_ICR register  *******************/
N#define  LPTIM_ICR_CMPMCF                       0x00000001U            /*!< Compare match Clear Flag                       */
N#define  LPTIM_ICR_ARRMCF                       0x00000002U            /*!< Autoreload match Clear Flag                    */
N#define  LPTIM_ICR_EXTTRIGCF                    0x00000004U            /*!< External trigger edge event Clear Flag         */
N#define  LPTIM_ICR_CMPOKCF                      0x00000008U            /*!< Compare register update OK Clear Flag          */
N#define  LPTIM_ICR_ARROKCF                      0x00000010U            /*!< Autoreload register update OK Clear Flag       */
N#define  LPTIM_ICR_UPCF                         0x00000020U            /*!< Counter direction change down to up Clear Flag */
N#define  LPTIM_ICR_DOWNCF                       0x00000040U            /*!< Counter direction change up to down Clear Flag */
N
N/******************  Bit definition for LPTIM_IER register *******************/
N#define  LPTIM_IER_CMPMIE                       0x00000001U            /*!< Compare match Interrupt Enable                       */
N#define  LPTIM_IER_ARRMIE                       0x00000002U            /*!< Autoreload match Interrupt Enable                    */
N#define  LPTIM_IER_EXTTRIGIE                    0x00000004U            /*!< External trigger edge event Interrupt Enable         */
N#define  LPTIM_IER_CMPOKIE                      0x00000008U            /*!< Compare register update OK Interrupt Enable          */
N#define  LPTIM_IER_ARROKIE                      0x00000010U            /*!< Autoreload register update OK Interrupt Enable       */
N#define  LPTIM_IER_UPIE                         0x00000020U            /*!< Counter direction change down to up Interrupt Enable */
N#define  LPTIM_IER_DOWNIE                       0x00000040U            /*!< Counter direction change up to down Interrupt Enable */
N
N/******************  Bit definition for LPTIM_CFGR register*******************/
N#define  LPTIM_CFGR_CKSEL                       0x00000001U             /*!< Clock selector */
N
N#define  LPTIM_CFGR_CKPOL                       0x00000006U             /*!< CKPOL[1:0] bits (Clock polarity) */
N#define  LPTIM_CFGR_CKPOL_0                     0x00000002U             /*!< Bit 0 */
N#define  LPTIM_CFGR_CKPOL_1                     0x00000004U             /*!< Bit 1 */
N
N#define  LPTIM_CFGR_CKFLT                       0x00000018U             /*!< CKFLT[1:0] bits (Configurable digital filter for external clock) */
N#define  LPTIM_CFGR_CKFLT_0                     0x00000008U             /*!< Bit 0 */
N#define  LPTIM_CFGR_CKFLT_1                     0x00000010U             /*!< Bit 1 */
N
N#define  LPTIM_CFGR_TRGFLT                      0x000000C0U             /*!< TRGFLT[1:0] bits (Configurable digital filter for trigger) */
N#define  LPTIM_CFGR_TRGFLT_0                    0x00000040U             /*!< Bit 0 */
N#define  LPTIM_CFGR_TRGFLT_1                    0x00000080U             /*!< Bit 1 */
N
N#define  LPTIM_CFGR_PRESC                       0x00000E00U             /*!< PRESC[2:0] bits (Clock prescaler) */
N#define  LPTIM_CFGR_PRESC_0                     0x00000200U             /*!< Bit 0 */
N#define  LPTIM_CFGR_PRESC_1                     0x00000400U             /*!< Bit 1 */
N#define  LPTIM_CFGR_PRESC_2                     0x00000800U             /*!< Bit 2 */
N
N#define  LPTIM_CFGR_TRIGSEL                     0x0000E000U             /*!< TRIGSEL[2:0]] bits (Trigger selector) */
N#define  LPTIM_CFGR_TRIGSEL_0                   0x00002000U             /*!< Bit 0 */
N#define  LPTIM_CFGR_TRIGSEL_1                   0x00004000U             /*!< Bit 1 */
N#define  LPTIM_CFGR_TRIGSEL_2                   0x00008000U             /*!< Bit 2 */
N
N#define  LPTIM_CFGR_TRIGEN                      0x00060000U             /*!< TRIGEN[1:0] bits (Trigger enable and polarity) */
N#define  LPTIM_CFGR_TRIGEN_0                    0x00020000U             /*!< Bit 0 */
N#define  LPTIM_CFGR_TRIGEN_1                    0x00040000U             /*!< Bit 1 */
N
N#define  LPTIM_CFGR_TIMOUT                      0x00080000U             /*!< Timout enable           */
N#define  LPTIM_CFGR_WAVE                        0x00100000U             /*!< Waveform shape          */
N#define  LPTIM_CFGR_WAVPOL                      0x00200000U             /*!< Waveform shape polarity */
N#define  LPTIM_CFGR_PRELOAD                     0x00400000U             /*!< Reg update mode         */
N#define  LPTIM_CFGR_COUNTMODE                   0x00800000U             /*!< Counter mode enable     */     
N#define  LPTIM_CFGR_ENC                         0x01000000U             /*!< Encoder mode enable     */          
N
N/******************  Bit definition for LPTIM_CR register  ********************/
N#define  LPTIM_CR_ENABLE                        0x00000001U             /*!< LPTIMer enable                 */
N#define  LPTIM_CR_SNGSTRT                       0x00000002U             /*!< Timer start in single mode     */
N#define  LPTIM_CR_CNTSTRT                       0x00000004U             /*!< Timer start in continuous mode */
N
N/******************  Bit definition for LPTIM_CMP register *******************/
N#define  LPTIM_CMP_CMP                          0x0000FFFFU             /*!< Compare register     */
N
N/******************  Bit definition for LPTIM_ARR register *******************/
N#define  LPTIM_ARR_ARR                          0x0000FFFFU             /*!< Auto reload register */
N
N/******************  Bit definition for LPTIM_CNT register *******************/
N#define  LPTIM_CNT_CNT                          0x0000FFFFU             /*!< Counter register     */
N/******************************************************************************/
N/*                                                                            */
N/*      Universal Synchronous Asynchronous Receiver Transmitter (USART)       */
N/*                                                                            */
N/******************************************************************************/
N/******************  Bit definition for USART_CR1 register  *******************/
N#define  USART_CR1_UE                        0x00000001U            /*!< USART Enable                                    */
N#define  USART_CR1_RE                        0x00000004U            /*!< Receiver Enable                                 */
N#define  USART_CR1_TE                        0x00000008U            /*!< Transmitter Enable                              */
N#define  USART_CR1_IDLEIE                    0x00000010U            /*!< IDLE Interrupt Enable                           */
N#define  USART_CR1_RXNEIE                    0x00000020U            /*!< RXNE Interrupt Enable                           */
N#define  USART_CR1_TCIE                      0x00000040U            /*!< Transmission Complete Interrupt Enable          */
N#define  USART_CR1_TXEIE                     0x00000080U            /*!< TXE Interrupt Enable                            */
N#define  USART_CR1_PEIE                      0x00000100U            /*!< PE Interrupt Enable                             */
N#define  USART_CR1_PS                        0x00000200U            /*!< Parity Selection                                */
N#define  USART_CR1_PCE                       0x00000400U            /*!< Parity Control Enable                           */
N#define  USART_CR1_WAKE                      0x00000800U            /*!< Receiver Wakeup method                          */
N#define  USART_CR1_M                         0x10001000U            /*!< Word length                                     */
N#define  USART_CR1_M_0                       0x00001000U            /*!< Word length - Bit 0                             */
N#define  USART_CR1_MME                       0x00002000U            /*!< Mute Mode Enable                                */
N#define  USART_CR1_CMIE                      0x00004000U            /*!< Character match interrupt enable                */
N#define  USART_CR1_OVER8                     0x00008000U            /*!< Oversampling by 8-bit or 16-bit mode            */
N#define  USART_CR1_DEDT                      0x001F0000U            /*!< DEDT[4:0] bits (Driver Enable Deassertion Time) */
N#define  USART_CR1_DEDT_0                    0x00010000U            /*!< Bit 0 */
N#define  USART_CR1_DEDT_1                    0x00020000U            /*!< Bit 1 */
N#define  USART_CR1_DEDT_2                    0x00040000U            /*!< Bit 2 */
N#define  USART_CR1_DEDT_3                    0x00080000U            /*!< Bit 3 */
N#define  USART_CR1_DEDT_4                    0x00100000U            /*!< Bit 4 */
N#define  USART_CR1_DEAT                      0x03E00000U            /*!< DEAT[4:0] bits (Driver Enable Assertion Time)   */
N#define  USART_CR1_DEAT_0                    0x00200000U            /*!< Bit 0 */
N#define  USART_CR1_DEAT_1                    0x00400000U            /*!< Bit 1 */
N#define  USART_CR1_DEAT_2                    0x00800000U            /*!< Bit 2 */
N#define  USART_CR1_DEAT_3                    0x01000000U            /*!< Bit 3 */
N#define  USART_CR1_DEAT_4                    0x02000000U            /*!< Bit 4 */
N#define  USART_CR1_RTOIE                     0x04000000U            /*!< Receive Time Out interrupt enable */
N#define  USART_CR1_EOBIE                     0x08000000U            /*!< End of Block interrupt enable     */
N#define  USART_CR1_M_1                       0x10000000U            /*!< Word length - Bit 1               */
N
N/******************  Bit definition for USART_CR2 register  *******************/
N#define  USART_CR2_ADDM7                     0x00000010U            /*!< 7-bit or 4-bit Address Detection       */
N#define  USART_CR2_LBDL                      0x00000020U            /*!< LIN Break Detection Length             */
N#define  USART_CR2_LBDIE                     0x00000040U            /*!< LIN Break Detection Interrupt Enable   */
N#define  USART_CR2_LBCL                      0x00000100U            /*!< Last Bit Clock pulse                   */
N#define  USART_CR2_CPHA                      0x00000200U            /*!< Clock Phase                            */
N#define  USART_CR2_CPOL                      0x00000400U            /*!< Clock Polarity                         */
N#define  USART_CR2_CLKEN                     0x00000800U            /*!< Clock Enable                           */
N#define  USART_CR2_STOP                      0x00003000U            /*!< STOP[1:0] bits (STOP bits)             */
N#define  USART_CR2_STOP_0                    0x00001000U            /*!< Bit 0 */
N#define  USART_CR2_STOP_1                    0x00002000U            /*!< Bit 1 */
N#define  USART_CR2_LINEN                     0x00004000U            /*!< LIN mode enable                        */
N#define  USART_CR2_SWAP                      0x00008000U            /*!< SWAP TX/RX pins                        */
N#define  USART_CR2_RXINV                     0x00010000U            /*!< RX pin active level inversion          */
N#define  USART_CR2_TXINV                     0x00020000U            /*!< TX pin active level inversion          */
N#define  USART_CR2_DATAINV                   0x00040000U            /*!< Binary data inversion                  */
N#define  USART_CR2_MSBFIRST                  0x00080000U            /*!< Most Significant Bit First             */
N#define  USART_CR2_ABREN                     0x00100000U            /*!< Auto Baud-Rate Enable                  */
N#define  USART_CR2_ABRMODE                   0x00600000U            /*!< ABRMOD[1:0] bits (Auto Baud-Rate Mode) */
N#define  USART_CR2_ABRMODE_0                 0x00200000U            /*!< Bit 0 */
N#define  USART_CR2_ABRMODE_1                 0x00400000U            /*!< Bit 1 */
N#define  USART_CR2_RTOEN                     0x00800000U            /*!< Receiver Time-Out enable  */
N#define  USART_CR2_ADD                       0xFF000000U            /*!< Address of the USART node */
N
N/******************  Bit definition for USART_CR3 register  *******************/
N#define  USART_CR3_EIE                       0x00000001U            /*!< Error Interrupt Enable                         */
N#define  USART_CR3_IREN                      0x00000002U            /*!< IrDA mode Enable                               */
N#define  USART_CR3_IRLP                      0x00000004U            /*!< IrDA Low-Power                                 */
N#define  USART_CR3_HDSEL                     0x00000008U            /*!< Half-Duplex Selection                          */
N#define  USART_CR3_NACK                      0x00000010U            /*!< SmartCard NACK enable                          */
N#define  USART_CR3_SCEN                      0x00000020U            /*!< SmartCard mode enable                          */
N#define  USART_CR3_DMAR                      0x00000040U            /*!< DMA Enable Receiver                            */
N#define  USART_CR3_DMAT                      0x00000080U            /*!< DMA Enable Transmitter                         */
N#define  USART_CR3_RTSE                      0x00000100U            /*!< RTS Enable                                     */
N#define  USART_CR3_CTSE                      0x00000200U            /*!< CTS Enable                                     */
N#define  USART_CR3_CTSIE                     0x00000400U            /*!< CTS Interrupt Enable                           */
N#define  USART_CR3_ONEBIT                    0x00000800U            /*!< One sample bit method enable                   */
N#define  USART_CR3_OVRDIS                    0x00001000U            /*!< Overrun Disable                                */
N#define  USART_CR3_DDRE                      0x00002000U            /*!< DMA Disable on Reception Error                 */
N#define  USART_CR3_DEM                       0x00004000U            /*!< Driver Enable Mode                             */
N#define  USART_CR3_DEP                       0x00008000U            /*!< Driver Enable Polarity Selection               */
N#define  USART_CR3_SCARCNT                   0x000E0000U            /*!< SCARCNT[2:0] bits (SmartCard Auto-Retry Count) */
N#define  USART_CR3_SCARCNT_0                 0x00020000U            /*!< Bit 0 */
N#define  USART_CR3_SCARCNT_1                 0x00040000U            /*!< Bit 1 */
N#define  USART_CR3_SCARCNT_2                 0x00080000U            /*!< Bit 2 */
N
N
N/******************  Bit definition for USART_BRR register  *******************/
N#define  USART_BRR_DIV_FRACTION              0x000FU                /*!< Fraction of USARTDIV */
N#define  USART_BRR_DIV_MANTISSA              0xFFF0U                /*!< Mantissa of USARTDIV */
N
N/******************  Bit definition for USART_GTPR register  ******************/
N#define  USART_GTPR_PSC                      0x00FFU                /*!< PSC[7:0] bits (Prescaler value) */
N#define  USART_GTPR_GT                       0xFF00U                /*!< GT[7:0] bits (Guard time value) */
N
N
N/*******************  Bit definition for USART_RTOR register  *****************/
N#define  USART_RTOR_RTO                      0x00FFFFFFU            /*!< Receiver Time Out Value */
N#define  USART_RTOR_BLEN                     0xFF000000U            /*!< Block Length */
N
N/*******************  Bit definition for USART_RQR register  ******************/
N#define  USART_RQR_ABRRQ                     0x0001U                /*!< Auto-Baud Rate Request      */
N#define  USART_RQR_SBKRQ                     0x0002U                /*!< Send Break Request          */
N#define  USART_RQR_MMRQ                      0x0004U                /*!< Mute Mode Request           */
N#define  USART_RQR_RXFRQ                     0x0008U                /*!< Receive Data flush Request  */
N#define  USART_RQR_TXFRQ                     0x0010U                /*!< Transmit data flush Request */
N
N/*******************  Bit definition for USART_ISR register  ******************/
N#define  USART_ISR_PE                        0x00000001U            /*!< Parity Error                        */
N#define  USART_ISR_FE                        0x00000002U            /*!< Framing Error                       */
N#define  USART_ISR_NE                        0x00000004U            /*!< Noise detected Flag                 */
N#define  USART_ISR_ORE                       0x00000008U            /*!< OverRun Error                       */
N#define  USART_ISR_IDLE                      0x00000010U            /*!< IDLE line detected                  */
N#define  USART_ISR_RXNE                      0x00000020U            /*!< Read Data Register Not Empty        */
N#define  USART_ISR_TC                        0x00000040U            /*!< Transmission Complete               */
N#define  USART_ISR_TXE                       0x00000080U            /*!< Transmit Data Register Empty        */
N#define  USART_ISR_LBDF                      0x00000100U            /*!< LIN Break Detection Flag            */
N#define  USART_ISR_CTSIF                     0x00000200U            /*!< CTS interrupt flag                  */
N#define  USART_ISR_CTS                       0x00000400U            /*!< CTS flag                            */
N#define  USART_ISR_RTOF                      0x00000800U            /*!< Receiver Time Out                   */
N#define  USART_ISR_EOBF                      0x00001000U            /*!< End Of Block Flag                   */
N#define  USART_ISR_ABRE                      0x00004000U            /*!< Auto-Baud Rate Error                */
N#define  USART_ISR_ABRF                      0x00008000U            /*!< Auto-Baud Rate Flag                 */
N#define  USART_ISR_BUSY                      0x00010000U            /*!< Busy Flag                           */
N#define  USART_ISR_CMF                       0x00020000U            /*!< Character Match Flag                */
N#define  USART_ISR_SBKF                      0x00040000U            /*!< Send Break Flag                     */
N#define  USART_ISR_RWU                       0x00080000U            /*!< Receive Wake Up from mute mode Flag */
N#define  USART_ISR_WUF                       0x00100000U            /*!< Wake Up from stop mode Flag         */
N#define  USART_ISR_TEACK                     0x00200000U            /*!< Transmit Enable Acknowledge Flag    */
N#define  USART_ISR_REACK                     0x00400000U            /*!< Receive Enable Acknowledge Flag     */
N
N
N/*******************  Bit definition for USART_ICR register  ******************/
N#define  USART_ICR_PECF                      0x00000001U            /*!< Parity Error Clear Flag             */
N#define  USART_ICR_FECF                      0x00000002U            /*!< Framing Error Clear Flag            */
N#define  USART_ICR_NCF                       0x00000004U            /*!< Noise detected Clear Flag           */
N#define  USART_ICR_ORECF                     0x00000008U            /*!< OverRun Error Clear Flag            */
N#define  USART_ICR_IDLECF                    0x00000010U            /*!< IDLE line detected Clear Flag       */
N#define  USART_ICR_TCCF                      0x00000040U            /*!< Transmission Complete Clear Flag    */
N#define  USART_ICR_LBDCF                     0x00000100U            /*!< LIN Break Detection Clear Flag      */
N#define  USART_ICR_CTSCF                     0x00000200U            /*!< CTS Interrupt Clear Flag            */
N#define  USART_ICR_RTOCF                     0x00000800U            /*!< Receiver Time Out Clear Flag        */
N#define  USART_ICR_EOBCF                     0x00001000U            /*!< End Of Block Clear Flag             */
N#define  USART_ICR_CMCF                      0x00020000U            /*!< Character Match Clear Flag          */
N#define  USART_ICR_WUCF                      0x00100000U            /*!< Wake Up from stop mode Clear Flag   */
N
N/*******************  Bit definition for USART_RDR register  ******************/
N#define  USART_RDR_RDR                       0x01FFU                /*!< RDR[8:0] bits (Receive Data value) */
N
N/*******************  Bit definition for USART_TDR register  ******************/
N#define  USART_TDR_TDR                       0x01FFU                /*!< TDR[8:0] bits (Transmit Data value) */
N
N/******************************************************************************/
N/*                                                                            */
N/*                            Window WATCHDOG                                 */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for WWDG_CR register  ********************/
N#define  WWDG_CR_T                            0x7FU                 /*!<T[6:0] bits (7-Bit counter (MSB to LSB)) */
N#define  WWDG_CR_T_0                          0x01U                 /*!<Bit 0 */
N#define  WWDG_CR_T_1                          0x02U                 /*!<Bit 1 */
N#define  WWDG_CR_T_2                          0x04U                 /*!<Bit 2 */
N#define  WWDG_CR_T_3                          0x08U                 /*!<Bit 3 */
N#define  WWDG_CR_T_4                          0x10U                 /*!<Bit 4 */
N#define  WWDG_CR_T_5                          0x20U                 /*!<Bit 5 */
N#define  WWDG_CR_T_6                          0x40U                 /*!<Bit 6 */
N
N
N#define  WWDG_CR_WDGA                        0x80U                  /*!<Activation bit */
N
N/*******************  Bit definition for WWDG_CFR register  *******************/
N#define  WWDG_CFR_W                          0x007FU                /*!<W[6:0] bits (7-bit window value) */
N#define  WWDG_CFR_W_0                        0x0001U                /*!<Bit 0 */
N#define  WWDG_CFR_W_1                        0x0002U                /*!<Bit 1 */
N#define  WWDG_CFR_W_2                        0x0004U                /*!<Bit 2 */
N#define  WWDG_CFR_W_3                        0x0008U                /*!<Bit 3 */
N#define  WWDG_CFR_W_4                        0x0010U                /*!<Bit 4 */
N#define  WWDG_CFR_W_5                        0x0020U                /*!<Bit 5 */
N#define  WWDG_CFR_W_6                        0x0040U                /*!<Bit 6 */
N
N
N#define  WWDG_CFR_WDGTB                      0x0180U                /*!<WDGTB[1:0] bits (Timer Base) */
N#define  WWDG_CFR_WDGTB_0                    0x0080U                /*!<Bit 0 */
N#define  WWDG_CFR_WDGTB_1                    0x0100U                /*!<Bit 1 */
N
N
N#define  WWDG_CFR_EWI                        0x0200U               /*!<Early Wakeup Interrupt */
N
N/*******************  Bit definition for WWDG_SR register  ********************/
N#define  WWDG_SR_EWIF                        0x01U                  /*!<Early Wakeup Interrupt Flag */
N
N/******************************************************************************/
N/*                                                                            */
N/*                                DBG                                         */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for DBGMCU_IDCODE register  *************/
N#define  DBGMCU_IDCODE_DEV_ID                0x00000FFFU
N#define  DBGMCU_IDCODE_REV_ID                0xFFFF0000U
N
N/********************  Bit definition for DBGMCU_CR register  *****************/
N#define  DBGMCU_CR_DBG_SLEEP                 0x00000001U
N#define  DBGMCU_CR_DBG_STOP                  0x00000002U
N#define  DBGMCU_CR_DBG_STANDBY               0x00000004U
N#define  DBGMCU_CR_TRACE_IOEN                0x00000020U
N
N#define  DBGMCU_CR_TRACE_MODE                0x000000C0U
N#define  DBGMCU_CR_TRACE_MODE_0              0x00000040U /*!<Bit 0 */
N#define  DBGMCU_CR_TRACE_MODE_1              0x00000080U /*!<Bit 1 */
N
N/********************  Bit definition for DBGMCU_APB1_FZ register  ************/
N#define  DBGMCU_APB1_FZ_DBG_TIM2_STOP            0x00000001U
N#define  DBGMCU_APB1_FZ_DBG_TIM3_STOP            0x00000002U
N#define  DBGMCU_APB1_FZ_DBG_TIM4_STOP            0x00000004U
N#define  DBGMCU_APB1_FZ_DBG_TIM5_STOP            0x00000008U
N#define  DBGMCU_APB1_FZ_DBG_TIM6_STOP            0x00000010U
N#define  DBGMCU_APB1_FZ_DBG_TIM7_STOP            0x00000020U
N#define  DBGMCU_APB1_FZ_DBG_TIM12_STOP           0x00000040U
N#define  DBGMCU_APB1_FZ_DBG_TIM13_STOP           0x00000080U
N#define  DBGMCU_APB1_FZ_DBG_TIM14_STOP           0x00000100U
N#define  DBGMCU_APB1_FZ_DBG_RTC_STOP             0x00000400U
N#define  DBGMCU_APB1_FZ_DBG_WWDG_STOP            0x00000800U
N#define  DBGMCU_APB1_FZ_DBG_IWDG_STOP            0x00001000U
N#define  DBGMCU_APB1_FZ_DBG_CAN3_STOP            0x00002000U
N#define  DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT   0x00200000U
N#define  DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT   0x00400000U
N#define  DBGMCU_APB1_FZ_DBG_I2C3_SMBUS_TIMEOUT   0x00800000U
N#define  DBGMCU_APB1_FZ_DBG_CAN1_STOP            0x02000000U
N#define  DBGMCU_APB1_FZ_DBG_CAN2_STOP            0x04000000U
N
N/********************  Bit definition for DBGMCU_APB2_FZ register  ************/
N#define  DBGMCU_APB2_FZ_DBG_TIM1_STOP            0x00000001U
N#define  DBGMCU_APB2_FZ_DBG_TIM8_STOP            0x00000002U
N#define  DBGMCU_APB2_FZ_DBG_TIM9_STOP            0x00010000U
N#define  DBGMCU_APB2_FZ_DBG_TIM10_STOP           0x00020000U
N#define  DBGMCU_APB2_FZ_DBG_TIM11_STOP           0x00040000U
N
N/******************************************************************************/
N/*                                                                            */
N/*                Ethernet MAC Registers bits definitions                     */
N/*                                                                            */
N/******************************************************************************/
N/* Bit definition for Ethernet MAC Control Register register */
N#define ETH_MACCR_WD              0x00800000U  /* Watchdog disable */
N#define ETH_MACCR_JD              0x00400000U  /* Jabber disable */
N#define ETH_MACCR_IFG             0x000E0000U  /* Inter-frame gap */
N#define ETH_MACCR_IFG_96Bit       0x00000000U  /* Minimum IFG between frames during transmission is 96Bit */
N#define ETH_MACCR_IFG_88Bit       0x00020000U  /* Minimum IFG between frames during transmission is 88Bit */
N#define ETH_MACCR_IFG_80Bit       0x00040000U  /* Minimum IFG between frames during transmission is 80Bit */
N#define ETH_MACCR_IFG_72Bit       0x00060000U  /* Minimum IFG between frames during transmission is 72Bit */
N#define ETH_MACCR_IFG_64Bit       0x00080000U  /* Minimum IFG between frames during transmission is 64Bit */        
N#define ETH_MACCR_IFG_56Bit       0x000A0000U  /* Minimum IFG between frames during transmission is 56Bit */
N#define ETH_MACCR_IFG_48Bit       0x000C0000U  /* Minimum IFG between frames during transmission is 48Bit */
N#define ETH_MACCR_IFG_40Bit       0x000E0000U  /* Minimum IFG between frames during transmission is 40Bit */              
N#define ETH_MACCR_CSD             0x00010000U  /* Carrier sense disable (during transmission) */
N#define ETH_MACCR_FES             0x00004000U  /* Fast ethernet speed */
N#define ETH_MACCR_ROD             0x00002000U  /* Receive own disable */
N#define ETH_MACCR_LM              0x00001000U  /* loopback mode */
N#define ETH_MACCR_DM              0x00000800U  /* Duplex mode */
N#define ETH_MACCR_IPCO            0x00000400U  /* IP Checksum offload */
N#define ETH_MACCR_RD              0x00000200U  /* Retry disable */
N#define ETH_MACCR_APCS            0x00000080U  /* Automatic Pad/CRC stripping */
N#define ETH_MACCR_BL              0x00000060U  /* Back-off limit: random integer number (r) of slot time delays before rescheduling
N                                                       a transmission attempt during retries after a collision: 0 =< r <2^k */
N#define ETH_MACCR_BL_10           0x00000000U  /* k = min (n, 10) */
N#define ETH_MACCR_BL_8            0x00000020U  /* k = min (n, 8) */
N#define ETH_MACCR_BL_4            0x00000040U  /* k = min (n, 4) */
N#define ETH_MACCR_BL_1            0x00000060U  /* k = min (n, 1) */ 
N#define ETH_MACCR_DC              0x00000010U  /* Defferal check */
N#define ETH_MACCR_TE              0x00000008U  /* Transmitter enable */
N#define ETH_MACCR_RE              0x00000004U  /* Receiver enable */
N
N/* Bit definition for Ethernet MAC Frame Filter Register */
N#define ETH_MACFFR_RA             0x80000000U  /* Receive all */ 
N#define ETH_MACFFR_HPF            0x00000400U  /* Hash or perfect filter */ 
N#define ETH_MACFFR_SAF            0x00000200U  /* Source address filter enable */ 
N#define ETH_MACFFR_SAIF           0x00000100U  /* SA inverse filtering */ 
N#define ETH_MACFFR_PCF            0x000000C0U  /* Pass control frames: 3 cases */
N#define ETH_MACFFR_PCF_BlockAll                0x00000040U  /* MAC filters all control frames from reaching the application */
N#define ETH_MACFFR_PCF_ForwardAll              0x00000080U  /* MAC forwards all control frames to application even if they fail the Address Filter */
N#define ETH_MACFFR_PCF_ForwardPassedAddrFilter 0x000000C0U  /* MAC forwards control frames that pass the Address Filter. */ 
N#define ETH_MACFFR_BFD             0x00000020U  /* Broadcast frame disable */ 
N#define ETH_MACFFR_PAM             0x00000010U  /* Pass all mutlicast */ 
N#define ETH_MACFFR_DAIF            0x00000008U  /* DA Inverse filtering */ 
N#define ETH_MACFFR_HM              0x00000004U  /* Hash multicast */ 
N#define ETH_MACFFR_HU              0x00000002U  /* Hash unicast */
N#define ETH_MACFFR_PM              0x00000001U  /* Promiscuous mode */
N
N/* Bit definition for Ethernet MAC Hash Table High Register */
N#define ETH_MACHTHR_HTH            0xFFFFFFFFU  /* Hash table high */
N
N/* Bit definition for Ethernet MAC Hash Table Low Register */
N#define ETH_MACHTLR_HTL            0xFFFFFFFFU  /* Hash table low */
N
N/* Bit definition for Ethernet MAC MII Address Register */
N#define ETH_MACMIIAR_PA            0x0000F800U  /* Physical layer address */ 
N#define ETH_MACMIIAR_MR            0x000007C0U  /* MII register in the selected PHY */ 
N#define ETH_MACMIIAR_CR            0x0000001CU  /* CR clock range: 6 cases */ 
N#define ETH_MACMIIAR_CR_Div42      0x00000000U  /* HCLK:60-100 MHz; MDC clock= HCLK/42 */
N#define ETH_MACMIIAR_CR_Div62      0x00000004U  /* HCLK:100-150 MHz; MDC clock= HCLK/62 */
N#define ETH_MACMIIAR_CR_Div16      0x00000008U  /* HCLK:20-35 MHz; MDC clock= HCLK/16 */
N#define ETH_MACMIIAR_CR_Div26      0x0000000CU  /* HCLK:35-60 MHz; MDC clock= HCLK/26 */
N#define ETH_MACMIIAR_CR_Div102     0x00000010U  /* HCLK:150-168 MHz; MDC clock= HCLK/102 */  
N#define ETH_MACMIIAR_MW            0x00000002U  /* MII write */ 
N#define ETH_MACMIIAR_MB            0x00000001U  /* MII busy */ 
N  
N/* Bit definition for Ethernet MAC MII Data Register */
N#define ETH_MACMIIDR_MD            0x0000FFFFU  /* MII data: read/write data from/to PHY */
N
N/* Bit definition for Ethernet MAC Flow Control Register */
N#define ETH_MACFCR_PT              0xFFFF0000U  /* Pause time */
N#define ETH_MACFCR_ZQPD            0x00000080U  /* Zero-quanta pause disable */
N#define ETH_MACFCR_PLT             0x00000030U  /* Pause low threshold: 4 cases */
N#define ETH_MACFCR_PLT_Minus4      0x00000000U  /* Pause time minus 4 slot times */
N#define ETH_MACFCR_PLT_Minus28     0x00000010U  /* Pause time minus 28 slot times */
N#define ETH_MACFCR_PLT_Minus144    0x00000020U  /* Pause time minus 144 slot times */
N#define ETH_MACFCR_PLT_Minus256    0x00000030U  /* Pause time minus 256 slot times */      
N#define ETH_MACFCR_UPFD            0x00000008U  /* Unicast pause frame detect */
N#define ETH_MACFCR_RFCE            0x00000004U  /* Receive flow control enable */
N#define ETH_MACFCR_TFCE            0x00000002U  /* Transmit flow control enable */
N#define ETH_MACFCR_FCBBPA          0x00000001U  /* Flow control busy/backpressure activate */
N
N/* Bit definition for Ethernet MAC VLAN Tag Register */
N#define ETH_MACVLANTR_VLANTC       0x00010000U  /* 12-bit VLAN tag comparison */
N#define ETH_MACVLANTR_VLANTI       0x0000FFFFU  /* VLAN tag identifier (for receive frames) */
N
N/* Bit definition for Ethernet MAC Remote Wake-UpFrame Filter Register */ 
N#define ETH_MACRWUFFR_D            0xFFFFFFFFU  /* Wake-up frame filter register data */
N/* Eight sequential Writes to this address (offset 0x28) will write all Wake-UpFrame Filter Registers.
N   Eight sequential Reads from this address (offset 0x28) will read all Wake-UpFrame Filter Registers. */
N/* Wake-UpFrame Filter Reg0 : Filter 0 Byte Mask
N   Wake-UpFrame Filter Reg1 : Filter 1 Byte Mask
N   Wake-UpFrame Filter Reg2 : Filter 2 Byte Mask
N   Wake-UpFrame Filter Reg3 : Filter 3 Byte Mask
N   Wake-UpFrame Filter Reg4 : RSVD - Filter3 Command - RSVD - Filter2 Command - 
N                              RSVD - Filter1 Command - RSVD - Filter0 Command
N   Wake-UpFrame Filter Re5 : Filter3 Offset - Filter2 Offset - Filter1 Offset - Filter0 Offset
N   Wake-UpFrame Filter Re6 : Filter1 CRC16 - Filter0 CRC16
N   Wake-UpFrame Filter Re7 : Filter3 CRC16 - Filter2 CRC16 */
N
N/* Bit definition for Ethernet MAC PMT Control and Status Register */ 
N#define ETH_MACPMTCSR_WFFRPR       0x80000000U  /* Wake-Up Frame Filter Register Pointer Reset */
N#define ETH_MACPMTCSR_GU           0x00000200U  /* Global Unicast */
N#define ETH_MACPMTCSR_WFR          0x00000040U  /* Wake-Up Frame Received */
N#define ETH_MACPMTCSR_MPR          0x00000020U  /* Magic Packet Received */
N#define ETH_MACPMTCSR_WFE          0x00000004U  /* Wake-Up Frame Enable */
N#define ETH_MACPMTCSR_MPE          0x00000002U  /* Magic Packet Enable */
N#define ETH_MACPMTCSR_PD           0x00000001U  /* Power Down */
N
N/* Bit definition for Ethernet MAC Status Register */
N#define ETH_MACSR_TSTS      0x00000200U  /* Time stamp trigger status */
N#define ETH_MACSR_MMCTS     0x00000040U  /* MMC transmit status */
N#define ETH_MACSR_MMMCRS    0x00000020U  /* MMC receive status */
N#define ETH_MACSR_MMCS      0x00000010U  /* MMC status */
N#define ETH_MACSR_PMTS      0x00000008U  /* PMT status */
N
N/* Bit definition for Ethernet MAC Interrupt Mask Register */
N#define ETH_MACIMR_TSTIM     0x00000200U  /* Time stamp trigger interrupt mask */
N#define ETH_MACIMR_PMTIM     0x00000008U  /* PMT interrupt mask */
N
N/* Bit definition for Ethernet MAC Address0 High Register */
N#define ETH_MACA0HR_MACA0H   0x0000FFFFU  /* MAC address0 high */
N
N/* Bit definition for Ethernet MAC Address0 Low Register */
N#define ETH_MACA0LR_MACA0L   0xFFFFFFFFU  /* MAC address0 low */
N
N/* Bit definition for Ethernet MAC Address1 High Register */
N#define ETH_MACA1HR_AE       0x80000000U  /* Address enable */
N#define ETH_MACA1HR_SA       0x40000000U  /* Source address */
N#define ETH_MACA1HR_MBC      0x3F000000U  /* Mask byte control: bits to mask for comparison of the MAC Address bytes */
N  #define ETH_MACA1HR_MBC_HBits15_8    0x20000000U  /* Mask MAC Address high reg bits [15:8] */
N  #define ETH_MACA1HR_MBC_HBits7_0     0x10000000U  /* Mask MAC Address high reg bits [7:0] */
N  #define ETH_MACA1HR_MBC_LBits31_24   0x08000000U  /* Mask MAC Address low reg bits [31:24] */
N  #define ETH_MACA1HR_MBC_LBits23_16   0x04000000U  /* Mask MAC Address low reg bits [23:16] */
N  #define ETH_MACA1HR_MBC_LBits15_8    0x02000000U  /* Mask MAC Address low reg bits [15:8] */
N  #define ETH_MACA1HR_MBC_LBits7_0     0x01000000U  /* Mask MAC Address low reg bits [7:0] */ 
N#define ETH_MACA1HR_MACA1H            0x0000FFFFU  /* MAC address1 high */
N
N/* Bit definition for Ethernet MAC Address1 Low Register */
N#define ETH_MACA1LR_MACA1L   0xFFFFFFFFU  /* MAC address1 low */
N
N/* Bit definition for Ethernet MAC Address2 High Register */
N#define ETH_MACA2HR_AE       0x80000000U  /* Address enable */
N#define ETH_MACA2HR_SA       0x40000000U  /* Source address */
N#define ETH_MACA2HR_MBC      0x3F000000U  /* Mask byte control */
N  #define ETH_MACA2HR_MBC_HBits15_8    0x20000000U  /* Mask MAC Address high reg bits [15:8] */
N  #define ETH_MACA2HR_MBC_HBits7_0     0x10000000U  /* Mask MAC Address high reg bits [7:0] */
N  #define ETH_MACA2HR_MBC_LBits31_24   0x08000000U  /* Mask MAC Address low reg bits [31:24] */
N  #define ETH_MACA2HR_MBC_LBits23_16   0x04000000U  /* Mask MAC Address low reg bits [23:16] */
N  #define ETH_MACA2HR_MBC_LBits15_8    0x02000000U  /* Mask MAC Address low reg bits [15:8] */
N  #define ETH_MACA2HR_MBC_LBits7_0     0x01000000U  /* Mask MAC Address low reg bits [70] */
N#define ETH_MACA2HR_MACA2H   0x0000FFFFU  /* MAC address1 high */
N
N/* Bit definition for Ethernet MAC Address2 Low Register */
N#define ETH_MACA2LR_MACA2L   0xFFFFFFFFU  /* MAC address2 low */
N
N/* Bit definition for Ethernet MAC Address3 High Register */
N#define ETH_MACA3HR_AE       0x80000000U  /* Address enable */
N#define ETH_MACA3HR_SA       0x40000000U  /* Source address */
N#define ETH_MACA3HR_MBC      0x3F000000U  /* Mask byte control */
N  #define ETH_MACA3HR_MBC_HBits15_8    0x20000000U  /* Mask MAC Address high reg bits [15:8] */
N  #define ETH_MACA3HR_MBC_HBits7_0     0x10000000U  /* Mask MAC Address high reg bits [7:0] */
N  #define ETH_MACA3HR_MBC_LBits31_24   0x08000000U  /* Mask MAC Address low reg bits [31:24] */
N  #define ETH_MACA3HR_MBC_LBits23_16   0x04000000U  /* Mask MAC Address low reg bits [23:16] */
N  #define ETH_MACA3HR_MBC_LBits15_8    0x02000000U  /* Mask MAC Address low reg bits [15:8] */
N  #define ETH_MACA3HR_MBC_LBits7_0     0x01000000U  /* Mask MAC Address low reg bits [70] */
N#define ETH_MACA3HR_MACA3H   0x0000FFFFU  /* MAC address3 high */
N
N/* Bit definition for Ethernet MAC Address3 Low Register */
N#define ETH_MACA3LR_MACA3L   0xFFFFFFFFU  /* MAC address3 low */
N
N/******************************************************************************/
N/*                Ethernet MMC Registers bits definition                      */
N/******************************************************************************/
N
N/* Bit definition for Ethernet MMC Contol Register */
N#define ETH_MMCCR_MCFHP      0x00000020U  /* MMC counter Full-Half preset */
N#define ETH_MMCCR_MCP        0x00000010U  /* MMC counter preset */
N#define ETH_MMCCR_MCF        0x00000008U  /* MMC Counter Freeze */
N#define ETH_MMCCR_ROR        0x00000004U  /* Reset on Read */
N#define ETH_MMCCR_CSR        0x00000002U  /* Counter Stop Rollover */
N#define ETH_MMCCR_CR         0x00000001U  /* Counters Reset */
N
N/* Bit definition for Ethernet MMC Receive Interrupt Register */
N#define ETH_MMCRIR_RGUFS     0x00020000U  /* Set when Rx good unicast frames counter reaches half the maximum value */
N#define ETH_MMCRIR_RFAES     0x00000040U  /* Set when Rx alignment error counter reaches half the maximum value */
N#define ETH_MMCRIR_RFCES     0x00000020U  /* Set when Rx crc error counter reaches half the maximum value */
N
N/* Bit definition for Ethernet MMC Transmit Interrupt Register */
N#define ETH_MMCTIR_TGFS      0x00200000U  /* Set when Tx good frame count counter reaches half the maximum value */
N#define ETH_MMCTIR_TGFMSCS   0x00008000U  /* Set when Tx good multi col counter reaches half the maximum value */
N#define ETH_MMCTIR_TGFSCS    0x00004000U  /* Set when Tx good single col counter reaches half the maximum value */
N
N/* Bit definition for Ethernet MMC Receive Interrupt Mask Register */
N#define ETH_MMCRIMR_RGUFM    0x00020000U  /* Mask the interrupt when Rx good unicast frames counter reaches half the maximum value */
N#define ETH_MMCRIMR_RFAEM    0x00000040U  /* Mask the interrupt when when Rx alignment error counter reaches half the maximum value */
N#define ETH_MMCRIMR_RFCEM    0x00000020U  /* Mask the interrupt when Rx crc error counter reaches half the maximum value */
N
N/* Bit definition for Ethernet MMC Transmit Interrupt Mask Register */
N#define ETH_MMCTIMR_TGFM     0x00200000U  /* Mask the interrupt when Tx good frame count counter reaches half the maximum value */
N#define ETH_MMCTIMR_TGFMSCM  0x00008000U  /* Mask the interrupt when Tx good multi col counter reaches half the maximum value */
N#define ETH_MMCTIMR_TGFSCM   0x00004000U  /* Mask the interrupt when Tx good single col counter reaches half the maximum value */
N
N/* Bit definition for Ethernet MMC Transmitted Good Frames after Single Collision Counter Register */
N#define ETH_MMCTGFSCCR_TGFSCC     0xFFFFFFFFU  /* Number of successfully transmitted frames after a single collision in Half-duplex mode. */
N
N/* Bit definition for Ethernet MMC Transmitted Good Frames after More than a Single Collision Counter Register */
N#define ETH_MMCTGFMSCCR_TGFMSCC   0xFFFFFFFFU  /* Number of successfully transmitted frames after more than a single collision in Half-duplex mode. */
N
N/* Bit definition for Ethernet MMC Transmitted Good Frames Counter Register */
N#define ETH_MMCTGFCR_TGFC    0xFFFFFFFFU  /* Number of good frames transmitted. */
N
N/* Bit definition for Ethernet MMC Received Frames with CRC Error Counter Register */
N#define ETH_MMCRFCECR_RFCEC  0xFFFFFFFFU  /* Number of frames received with CRC error. */
N
N/* Bit definition for Ethernet MMC Received Frames with Alignement Error Counter Register */
N#define ETH_MMCRFAECR_RFAEC  0xFFFFFFFFU  /* Number of frames received with alignment (dribble) error */
N
N/* Bit definition for Ethernet MMC Received Good Unicast Frames Counter Register */
N#define ETH_MMCRGUFCR_RGUFC  0xFFFFFFFFU  /* Number of good unicast frames received. */
N
N/******************************************************************************/
N/*               Ethernet PTP Registers bits definition                       */
N/******************************************************************************/
N
N/* Bit definition for Ethernet PTP Time Stamp Contol Register */
N#define ETH_PTPTSCR_TSCNT       0x00030000U  /* Time stamp clock node type */
N#define ETH_PTPTSSR_TSSMRME     0x00008000U  /* Time stamp snapshot for message relevant to master enable */
N#define ETH_PTPTSSR_TSSEME      0x00004000U  /* Time stamp snapshot for event message enable */
N#define ETH_PTPTSSR_TSSIPV4FE   0x00002000U  /* Time stamp snapshot for IPv4 frames enable */
N#define ETH_PTPTSSR_TSSIPV6FE   0x00001000U  /* Time stamp snapshot for IPv6 frames enable */
N#define ETH_PTPTSSR_TSSPTPOEFE  0x00000800U  /* Time stamp snapshot for PTP over ethernet frames enable */
N#define ETH_PTPTSSR_TSPTPPSV2E  0x00000400U  /* Time stamp PTP packet snooping for version2 format enable */
N#define ETH_PTPTSSR_TSSSR       0x00000200U  /* Time stamp Sub-seconds rollover */
N#define ETH_PTPTSSR_TSSARFE     0x00000100U  /* Time stamp snapshot for all received frames enable */
N
N#define ETH_PTPTSCR_TSARU       0x00000020U  /* Addend register update */
N#define ETH_PTPTSCR_TSITE       0x00000010U  /* Time stamp interrupt trigger enable */
N#define ETH_PTPTSCR_TSSTU       0x00000008U  /* Time stamp update */
N#define ETH_PTPTSCR_TSSTI       0x00000004U  /* Time stamp initialize */
N#define ETH_PTPTSCR_TSFCU       0x00000002U  /* Time stamp fine or coarse update */
N#define ETH_PTPTSCR_TSE         0x00000001U  /* Time stamp enable */
N
N/* Bit definition for Ethernet PTP Sub-Second Increment Register */
N#define ETH_PTPSSIR_STSSI      0x000000FFU   /* System time Sub-second increment value */
N
N/* Bit definition for Ethernet PTP Time Stamp High Register */
N#define ETH_PTPTSHR_STS        0xFFFFFFFFU   /* System Time second */
N
N/* Bit definition for Ethernet PTP Time Stamp Low Register */
N#define ETH_PTPTSLR_STPNS      0x80000000U  /* System Time Positive or negative time */
N#define ETH_PTPTSLR_STSS       0x7FFFFFFFU  /* System Time sub-seconds */
N
N/* Bit definition for Ethernet PTP Time Stamp High Update Register */
N#define ETH_PTPTSHUR_TSUS      0xFFFFFFFFU  /* Time stamp update seconds */
N
N/* Bit definition for Ethernet PTP Time Stamp Low Update Register */
N#define ETH_PTPTSLUR_TSUPNS    0x80000000U  /* Time stamp update Positive or negative time */
N#define ETH_PTPTSLUR_TSUSS     0x7FFFFFFFU  /* Time stamp update sub-seconds */
N
N/* Bit definition for Ethernet PTP Time Stamp Addend Register */
N#define ETH_PTPTSAR_TSA        0xFFFFFFFFU  /* Time stamp addend */
N
N/* Bit definition for Ethernet PTP Target Time High Register */
N#define ETH_PTPTTHR_TTSH       0xFFFFFFFFU  /* Target time stamp high */
N
N/* Bit definition for Ethernet PTP Target Time Low Register */
N#define ETH_PTPTTLR_TTSL       0xFFFFFFFFU  /* Target time stamp low */
N
N/* Bit definition for Ethernet PTP Time Stamp Status Register */
N#define ETH_PTPTSSR_TSTTR      0x00000020U  /* Time stamp target time reached */
N#define ETH_PTPTSSR_TSSO       0x00000010U  /* Time stamp seconds overflow */
N
N/******************************************************************************/
N/*                 Ethernet DMA Registers bits definition                     */
N/******************************************************************************/
N
N/* Bit definition for Ethernet DMA Bus Mode Register */
N#define ETH_DMABMR_AAB        0x02000000U  /* Address-Aligned beats */
N#define ETH_DMABMR_FPM        0x01000000U  /* 4xPBL mode */
N#define ETH_DMABMR_USP        0x00800000U  /* Use separate PBL */
N#define ETH_DMABMR_RDP        0x007E0000U  /* RxDMA PBL */
N  #define ETH_DMABMR_RDP_1Beat    0x00020000U  /* maximum number of beats to be transferred in one RxDMA transaction is 1 */
N  #define ETH_DMABMR_RDP_2Beat    0x00040000U  /* maximum number of beats to be transferred in one RxDMA transaction is 2 */
N  #define ETH_DMABMR_RDP_4Beat    0x00080000U  /* maximum number of beats to be transferred in one RxDMA transaction is 4 */
N  #define ETH_DMABMR_RDP_8Beat    0x00100000U  /* maximum number of beats to be transferred in one RxDMA transaction is 8 */
N  #define ETH_DMABMR_RDP_16Beat   0x00200000U  /* maximum number of beats to be transferred in one RxDMA transaction is 16 */
N  #define ETH_DMABMR_RDP_32Beat   0x00400000U  /* maximum number of beats to be transferred in one RxDMA transaction is 32 */                
N  #define ETH_DMABMR_RDP_4xPBL_4Beat   0x01020000U  /* maximum number of beats to be transferred in one RxDMA transaction is 4 */
N  #define ETH_DMABMR_RDP_4xPBL_8Beat   0x01040000U  /* maximum number of beats to be transferred in one RxDMA transaction is 8 */
N  #define ETH_DMABMR_RDP_4xPBL_16Beat  0x01080000U  /* maximum number of beats to be transferred in one RxDMA transaction is 16 */
N  #define ETH_DMABMR_RDP_4xPBL_32Beat  0x01100000U  /* maximum number of beats to be transferred in one RxDMA transaction is 32 */
N  #define ETH_DMABMR_RDP_4xPBL_64Beat  0x01200000U  /* maximum number of beats to be transferred in one RxDMA transaction is 64 */
N  #define ETH_DMABMR_RDP_4xPBL_128Beat 0x01400000U  /* maximum number of beats to be transferred in one RxDMA transaction is 128 */  
N#define ETH_DMABMR_FB        0x00010000U  /* Fixed Burst */
N#define ETH_DMABMR_RTPR      0x0000C000U  /* Rx Tx priority ratio */
N  #define ETH_DMABMR_RTPR_1_1     0x00000000U  /* Rx Tx priority ratio */
N  #define ETH_DMABMR_RTPR_2_1     0x00004000U  /* Rx Tx priority ratio */
N  #define ETH_DMABMR_RTPR_3_1     0x00008000U  /* Rx Tx priority ratio */
N  #define ETH_DMABMR_RTPR_4_1     0x0000C000U  /* Rx Tx priority ratio */  
N#define ETH_DMABMR_PBL    0x00003F00U  /* Programmable burst length */
N  #define ETH_DMABMR_PBL_1Beat    0x00000100U  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 1 */
N  #define ETH_DMABMR_PBL_2Beat    0x00000200U  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 2 */
N  #define ETH_DMABMR_PBL_4Beat    0x00000400U  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */
N  #define ETH_DMABMR_PBL_8Beat    0x00000800U  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */
N  #define ETH_DMABMR_PBL_16Beat   0x00001000U  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */
N  #define ETH_DMABMR_PBL_32Beat   0x00002000U  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */                
N  #define ETH_DMABMR_PBL_4xPBL_4Beat   0x01000100U  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */
N  #define ETH_DMABMR_PBL_4xPBL_8Beat   0x01000200U  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */
N  #define ETH_DMABMR_PBL_4xPBL_16Beat  0x01000400U  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */
N  #define ETH_DMABMR_PBL_4xPBL_32Beat  0x01000800U  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */
N  #define ETH_DMABMR_PBL_4xPBL_64Beat  0x01001000U  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 64 */
N  #define ETH_DMABMR_PBL_4xPBL_128Beat 0x01002000U  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 128 */
N#define ETH_DMABMR_EDE       0x00000080U  /* Enhanced Descriptor Enable */
N#define ETH_DMABMR_DSL       0x0000007CU  /* Descriptor Skip Length */
N#define ETH_DMABMR_DA        0x00000002U  /* DMA arbitration scheme */
N#define ETH_DMABMR_SR        0x00000001U  /* Software reset */
N
N/* Bit definition for Ethernet DMA Transmit Poll Demand Register */
N#define ETH_DMATPDR_TPD      0xFFFFFFFFU  /* Transmit poll demand */
N
N/* Bit definition for Ethernet DMA Receive Poll Demand Register */
N#define ETH_DMARPDR_RPD      0xFFFFFFFFU  /* Receive poll demand  */
N
N/* Bit definition for Ethernet DMA Receive Descriptor List Address Register */
N#define ETH_DMARDLAR_SRL     0xFFFFFFFFU  /* Start of receive list */
N
N/* Bit definition for Ethernet DMA Transmit Descriptor List Address Register */
N#define ETH_DMATDLAR_STL     0xFFFFFFFFU  /* Start of transmit list */
N
N/* Bit definition for Ethernet DMA Status Register */
N#define ETH_DMASR_TSTS       0x20000000U  /* Time-stamp trigger status */
N#define ETH_DMASR_PMTS       0x10000000U  /* PMT status */
N#define ETH_DMASR_MMCS       0x08000000U  /* MMC status */
N#define ETH_DMASR_EBS        0x03800000U  /* Error bits status */
N  /* combination with EBS[2:0] for GetFlagStatus function */
N  #define ETH_DMASR_EBS_DescAccess      0x02000000U  /* Error bits 0-data buffer, 1-desc. access */
N  #define ETH_DMASR_EBS_ReadTransf      0x01000000U  /* Error bits 0-write trnsf, 1-read transfr */
N  #define ETH_DMASR_EBS_DataTransfTx    0x00800000U  /* Error bits 0-Rx DMA, 1-Tx DMA */
N#define ETH_DMASR_TPS         0x00700000U  /* Transmit process state */
N  #define ETH_DMASR_TPS_Stopped         0x00000000U  /* Stopped - Reset or Stop Tx Command issued  */
N  #define ETH_DMASR_TPS_Fetching        0x00100000U  /* Running - fetching the Tx descriptor */
N  #define ETH_DMASR_TPS_Waiting         0x00200000U  /* Running - waiting for status */
N  #define ETH_DMASR_TPS_Reading         0x00300000U  /* Running - reading the data from host memory */
N  #define ETH_DMASR_TPS_Suspended       0x00600000U  /* Suspended - Tx Descriptor unavailabe */
N  #define ETH_DMASR_TPS_Closing         0x00700000U  /* Running - closing Rx descriptor */
N#define ETH_DMASR_RPS         0x000E0000U  /* Receive process state */
N  #define ETH_DMASR_RPS_Stopped         0x00000000U  /* Stopped - Reset or Stop Rx Command issued */
N  #define ETH_DMASR_RPS_Fetching        0x00020000U  /* Running - fetching the Rx descriptor */
N  #define ETH_DMASR_RPS_Waiting         0x00060000U  /* Running - waiting for packet */
N  #define ETH_DMASR_RPS_Suspended       0x00080000U  /* Suspended - Rx Descriptor unavailable */
N  #define ETH_DMASR_RPS_Closing         0x000A0000U  /* Running - closing descriptor */
N  #define ETH_DMASR_RPS_Queuing         0x000E0000U  /* Running - queuing the recieve frame into host memory */
N#define ETH_DMASR_NIS        0x00010000U  /* Normal interrupt summary */
N#define ETH_DMASR_AIS        0x00008000U  /* Abnormal interrupt summary */
N#define ETH_DMASR_ERS        0x00004000U  /* Early receive status */
N#define ETH_DMASR_FBES       0x00002000U  /* Fatal bus error status */
N#define ETH_DMASR_ETS        0x00000400U  /* Early transmit status */
N#define ETH_DMASR_RWTS       0x00000200U  /* Receive watchdog timeout status */
N#define ETH_DMASR_RPSS       0x00000100U  /* Receive process stopped status */
N#define ETH_DMASR_RBUS       0x00000080U  /* Receive buffer unavailable status */
N#define ETH_DMASR_RS         0x00000040U  /* Receive status */
N#define ETH_DMASR_TUS        0x00000020U  /* Transmit underflow status */
N#define ETH_DMASR_ROS        0x00000010U  /* Receive overflow status */
N#define ETH_DMASR_TJTS       0x00000008U  /* Transmit jabber timeout status */
N#define ETH_DMASR_TBUS       0x00000004U  /* Transmit buffer unavailable status */
N#define ETH_DMASR_TPSS       0x00000002U  /* Transmit process stopped status */
N#define ETH_DMASR_TS         0x00000001U  /* Transmit status */
N
N/* Bit definition for Ethernet DMA Operation Mode Register */
N#define ETH_DMAOMR_DTCEFD    0x04000000U  /* Disable Dropping of TCP/IP checksum error frames */
N#define ETH_DMAOMR_RSF       0x02000000U  /* Receive store and forward */
N#define ETH_DMAOMR_DFRF      0x01000000U  /* Disable flushing of received frames */
N#define ETH_DMAOMR_TSF       0x00200000U  /* Transmit store and forward */
N#define ETH_DMAOMR_FTF       0x00100000U  /* Flush transmit FIFO */
N#define ETH_DMAOMR_TTC       0x0001C000U  /* Transmit threshold control */
N  #define ETH_DMAOMR_TTC_64Bytes       0x00000000U  /* threshold level of the MTL Transmit FIFO is 64 Bytes */
N  #define ETH_DMAOMR_TTC_128Bytes      0x00004000U  /* threshold level of the MTL Transmit FIFO is 128 Bytes */
N  #define ETH_DMAOMR_TTC_192Bytes      0x00008000U  /* threshold level of the MTL Transmit FIFO is 192 Bytes */
N  #define ETH_DMAOMR_TTC_256Bytes      0x0000C000U  /* threshold level of the MTL Transmit FIFO is 256 Bytes */
N  #define ETH_DMAOMR_TTC_40Bytes       0x00010000U  /* threshold level of the MTL Transmit FIFO is 40 Bytes */
N  #define ETH_DMAOMR_TTC_32Bytes       0x00014000U  /* threshold level of the MTL Transmit FIFO is 32 Bytes */
N  #define ETH_DMAOMR_TTC_24Bytes       0x00018000U  /* threshold level of the MTL Transmit FIFO is 24 Bytes */
N  #define ETH_DMAOMR_TTC_16Bytes       0x0001C000U  /* threshold level of the MTL Transmit FIFO is 16 Bytes */
N#define ETH_DMAOMR_ST        0x00002000U  /* Start/stop transmission command */
N#define ETH_DMAOMR_FEF       0x00000080U  /* Forward error frames */
N#define ETH_DMAOMR_FUGF      0x00000040U  /* Forward undersized good frames */
N#define ETH_DMAOMR_RTC       0x00000018U  /* receive threshold control */
N  #define ETH_DMAOMR_RTC_64Bytes       0x00000000U  /* threshold level of the MTL Receive FIFO is 64 Bytes */
N  #define ETH_DMAOMR_RTC_32Bytes       0x00000008U  /* threshold level of the MTL Receive FIFO is 32 Bytes */
N  #define ETH_DMAOMR_RTC_96Bytes       0x00000010U  /* threshold level of the MTL Receive FIFO is 96 Bytes */
N  #define ETH_DMAOMR_RTC_128Bytes      0x00000018U  /* threshold level of the MTL Receive FIFO is 128 Bytes */
N#define ETH_DMAOMR_OSF       0x00000004U  /* operate on second frame */
N#define ETH_DMAOMR_SR        0x00000002U  /* Start/stop receive */
N
N/* Bit definition for Ethernet DMA Interrupt Enable Register */
N#define ETH_DMAIER_NISE      0x00010000U  /* Normal interrupt summary enable */
N#define ETH_DMAIER_AISE      0x00008000U  /* Abnormal interrupt summary enable */
N#define ETH_DMAIER_ERIE      0x00004000U  /* Early receive interrupt enable */
N#define ETH_DMAIER_FBEIE     0x00002000U  /* Fatal bus error interrupt enable */
N#define ETH_DMAIER_ETIE      0x00000400U  /* Early transmit interrupt enable */
N#define ETH_DMAIER_RWTIE     0x00000200U  /* Receive watchdog timeout interrupt enable */
N#define ETH_DMAIER_RPSIE     0x00000100U  /* Receive process stopped interrupt enable */
N#define ETH_DMAIER_RBUIE     0x00000080U  /* Receive buffer unavailable interrupt enable */
N#define ETH_DMAIER_RIE       0x00000040U  /* Receive interrupt enable */
N#define ETH_DMAIER_TUIE      0x00000020U  /* Transmit Underflow interrupt enable */
N#define ETH_DMAIER_ROIE      0x00000010U  /* Receive Overflow interrupt enable */
N#define ETH_DMAIER_TJTIE     0x00000008U  /* Transmit jabber timeout interrupt enable */
N#define ETH_DMAIER_TBUIE     0x00000004U  /* Transmit buffer unavailable interrupt enable */
N#define ETH_DMAIER_TPSIE     0x00000002U  /* Transmit process stopped interrupt enable */
N#define ETH_DMAIER_TIE       0x00000001U  /* Transmit interrupt enable */
N
N/* Bit definition for Ethernet DMA Missed Frame and Buffer Overflow Counter Register */
N#define ETH_DMAMFBOCR_OFOC   0x10000000U  /* Overflow bit for FIFO overflow counter */
N#define ETH_DMAMFBOCR_MFA    0x0FFE0000U  /* Number of frames missed by the application */
N#define ETH_DMAMFBOCR_OMFC   0x00010000U  /* Overflow bit for missed frame counter */
N#define ETH_DMAMFBOCR_MFC    0x0000FFFFU  /* Number of frames missed by the controller */
N
N/* Bit definition for Ethernet DMA Current Host Transmit Descriptor Register */
N#define ETH_DMACHTDR_HTDAP   0xFFFFFFFFU  /* Host transmit descriptor address pointer */
N
N/* Bit definition for Ethernet DMA Current Host Receive Descriptor Register */
N#define ETH_DMACHRDR_HRDAP   0xFFFFFFFFU  /* Host receive descriptor address pointer */
N
N/* Bit definition for Ethernet DMA Current Host Transmit Buffer Address Register */
N#define ETH_DMACHTBAR_HTBAP  0xFFFFFFFFU  /* Host transmit buffer address pointer */
N
N/* Bit definition for Ethernet DMA Current Host Receive Buffer Address Register */
N#define ETH_DMACHRBAR_HRBAP  0xFFFFFFFFU  /* Host receive buffer address pointer */
N
N/******************************************************************************/
N/*                                                                            */
N/*                                       USB_OTG                              */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for USB_OTG_GOTGCTL register  ********************/
N#define USB_OTG_GOTGCTL_SRQSCS                  0x00000001U         /*!< Session request success */
N#define USB_OTG_GOTGCTL_SRQ                     0x00000002U         /*!< Session request */
N#define USB_OTG_GOTGCTL_VBVALOEN                0x00000004U         /*!< VBUS valid override enable */
N#define USB_OTG_GOTGCTL_VBVALOVAL               0x00000008U         /*!< VBUS valid override value */
N#define USB_OTG_GOTGCTL_AVALOEN                 0x00000010U         /*!< A-peripheral session valid override enable */
N#define USB_OTG_GOTGCTL_AVALOVAL                0x00000020U         /*!< A-peripheral session valid override value */
N#define USB_OTG_GOTGCTL_BVALOEN                 0x00000040U         /*!< B-peripheral session valid override enable */
N#define USB_OTG_GOTGCTL_BVALOVAL                0x00000080U         /*!< B-peripheral session valid override value  */
N#define USB_OTG_GOTGCTL_HNGSCS                  0x00000100U         /*!< Host set HNP enable */
N#define USB_OTG_GOTGCTL_HNPRQ                   0x00000200U         /*!< HNP request */
N#define USB_OTG_GOTGCTL_HSHNPEN                 0x00000400U         /*!< Host set HNP enable */
N#define USB_OTG_GOTGCTL_DHNPEN                  0x00000800U         /*!< Device HNP enabled */
N#define USB_OTG_GOTGCTL_EHEN                    0x00001000U         /*!< Embedded host enable */
N#define USB_OTG_GOTGCTL_CIDSTS                  0x00010000U         /*!< Connector ID status */
N#define USB_OTG_GOTGCTL_DBCT                    0x00020000U         /*!< Long/short debounce time */
N#define USB_OTG_GOTGCTL_ASVLD                   0x00040000U         /*!< A-session valid  */
N#define USB_OTG_GOTGCTL_BSESVLD                 0x00080000U         /*!< B-session valid */
N#define USB_OTG_GOTGCTL_OTGVER                  0x00100000U         /*!< OTG version  */
N
N/********************  Bit definition for USB_OTG_HCFG register  ********************/
N#define USB_OTG_HCFG_FSLSPCS                 0x00000003U            /*!< FS/LS PHY clock select  */
N#define USB_OTG_HCFG_FSLSPCS_0               0x00000001U            /*!<Bit 0 */
N#define USB_OTG_HCFG_FSLSPCS_1               0x00000002U            /*!<Bit 1 */
N#define USB_OTG_HCFG_FSLSS                   0x00000004U            /*!< FS- and LS-only support */
N
N/********************  Bit definition for USB_OTG_DCFG register  ********************/
N#define USB_OTG_DCFG_DSPD                    0x00000003U            /*!< Device speed */
N#define USB_OTG_DCFG_DSPD_0                  0x00000001U            /*!<Bit 0 */
N#define USB_OTG_DCFG_DSPD_1                  0x00000002U            /*!<Bit 1 */
N#define USB_OTG_DCFG_NZLSOHSK                0x00000004U            /*!< Nonzero-length status OUT handshake */
N
N#define USB_OTG_DCFG_DAD                     0x000007F0U            /*!< Device address */
N#define USB_OTG_DCFG_DAD_0                   0x00000010U            /*!<Bit 0 */
N#define USB_OTG_DCFG_DAD_1                   0x00000020U            /*!<Bit 1 */
N#define USB_OTG_DCFG_DAD_2                   0x00000040U            /*!<Bit 2 */
N#define USB_OTG_DCFG_DAD_3                   0x00000080U            /*!<Bit 3 */
N#define USB_OTG_DCFG_DAD_4                   0x00000100U            /*!<Bit 4 */
N#define USB_OTG_DCFG_DAD_5                   0x00000200U            /*!<Bit 5 */
N#define USB_OTG_DCFG_DAD_6                   0x00000400U            /*!<Bit 6 */
N
N#define USB_OTG_DCFG_PFIVL                   0x00001800U            /*!< Periodic (micro)frame interval */
N#define USB_OTG_DCFG_PFIVL_0                 0x00000800U            /*!<Bit 0 */
N#define USB_OTG_DCFG_PFIVL_1                 0x00001000U            /*!<Bit 1 */
N
N#define USB_OTG_DCFG_PERSCHIVL               0x03000000U            /*!< Periodic scheduling interval */
N#define USB_OTG_DCFG_PERSCHIVL_0             0x01000000U            /*!<Bit 0 */
N#define USB_OTG_DCFG_PERSCHIVL_1             0x02000000U            /*!<Bit 1 */
N
N/********************  Bit definition for USB_OTG_PCGCR register  ********************/
N#define USB_OTG_PCGCR_STPPCLK                 0x00000001U            /*!< Stop PHY clock */
N#define USB_OTG_PCGCR_GATEHCLK                0x00000002U            /*!< Gate HCLK */
N#define USB_OTG_PCGCR_PHYSUSP                 0x00000010U            /*!< PHY suspended */
N
N/********************  Bit definition for USB_OTG_GOTGINT register  ********************/
N#define USB_OTG_GOTGINT_SEDET                   0x00000004U            /*!< Session end detected                   */
N#define USB_OTG_GOTGINT_SRSSCHG                 0x00000100U            /*!< Session request success status change  */
N#define USB_OTG_GOTGINT_HNSSCHG                 0x00000200U            /*!< Host negotiation success status change */
N#define USB_OTG_GOTGINT_HNGDET                  0x00020000U            /*!< Host negotiation detected              */
N#define USB_OTG_GOTGINT_ADTOCHG                 0x00040000U            /*!< A-device timeout change                */
N#define USB_OTG_GOTGINT_DBCDNE                  0x00080000U            /*!< Debounce done                          */
N#define USB_OTG_GOTGINT_IDCHNG                  0x00100000U            /*!< Change in ID pin input value           */
N
N/********************  Bit definition for USB_OTG_DCTL register  ********************/
N#define USB_OTG_DCTL_RWUSIG                  0x00000001U            /*!< Remote wakeup signaling */
N#define USB_OTG_DCTL_SDIS                    0x00000002U            /*!< Soft disconnect         */
N#define USB_OTG_DCTL_GINSTS                  0x00000004U            /*!< Global IN NAK status    */
N#define USB_OTG_DCTL_GONSTS                  0x00000008U            /*!< Global OUT NAK status   */
N
N#define USB_OTG_DCTL_TCTL                    0x00000070U            /*!< Test control */
N#define USB_OTG_DCTL_TCTL_0                  0x00000010U            /*!<Bit 0 */
N#define USB_OTG_DCTL_TCTL_1                  0x00000020U            /*!<Bit 1 */
N#define USB_OTG_DCTL_TCTL_2                  0x00000040U            /*!<Bit 2 */
N#define USB_OTG_DCTL_SGINAK                  0x00000080U            /*!< Set global IN NAK         */
N#define USB_OTG_DCTL_CGINAK                  0x00000100U            /*!< Clear global IN NAK       */
N#define USB_OTG_DCTL_SGONAK                  0x00000200U            /*!< Set global OUT NAK        */
N#define USB_OTG_DCTL_CGONAK                  0x00000400U            /*!< Clear global OUT NAK      */
N#define USB_OTG_DCTL_POPRGDNE                0x00000800U            /*!< Power-on programming done */
N
N/********************  Bit definition for USB_OTG_HFIR register  ********************/
N#define USB_OTG_HFIR_FRIVL                   0x0000FFFFU            /*!< Frame interval */
N
N/********************  Bit definition for USB_OTG_HFNUM register  ********************/
N#define USB_OTG_HFNUM_FRNUM                   0x0000FFFFU            /*!< Frame number         */
N#define USB_OTG_HFNUM_FTREM                   0xFFFF0000U            /*!< Frame time remaining */
N
N/********************  Bit definition for USB_OTG_DSTS register  ********************/
N#define USB_OTG_DSTS_SUSPSTS                 0x00000001U            /*!< Suspend status   */
N
N#define USB_OTG_DSTS_ENUMSPD                 0x00000006U            /*!< Enumerated speed */
N#define USB_OTG_DSTS_ENUMSPD_0               0x00000002U            /*!<Bit 0 */
N#define USB_OTG_DSTS_ENUMSPD_1               0x00000004U            /*!<Bit 1 */
N#define USB_OTG_DSTS_EERR                    0x00000008U            /*!< Erratic error     */
N#define USB_OTG_DSTS_FNSOF                   0x003FFF00U            /*!< Frame number of the received SOF */
N
N/********************  Bit definition for USB_OTG_GAHBCFG register  ********************/
N#define USB_OTG_GAHBCFG_GINT                    0x00000001U            /*!< Global interrupt mask */
N#define USB_OTG_GAHBCFG_HBSTLEN                 0x0000001EU            /*!< Burst length/type */
N#define USB_OTG_GAHBCFG_HBSTLEN_0               0x00000002U            /*!<Bit 0 */
N#define USB_OTG_GAHBCFG_HBSTLEN_1               0x00000004U            /*!<Bit 1 */
N#define USB_OTG_GAHBCFG_HBSTLEN_2               0x00000008U            /*!<Bit 2 */
N#define USB_OTG_GAHBCFG_HBSTLEN_3               0x00000010U            /*!<Bit 3 */
N#define USB_OTG_GAHBCFG_DMAEN                   0x00000020U            /*!< DMA enable */
N#define USB_OTG_GAHBCFG_TXFELVL                 0x00000080U            /*!< TxFIFO empty level */
N#define USB_OTG_GAHBCFG_PTXFELVL                0x00000100U            /*!< Periodic TxFIFO empty level */
N
N/********************  Bit definition for USB_OTG_GUSBCFG register  ********************/
N#define USB_OTG_GUSBCFG_TOCAL                   0x00000007U            /*!< FS timeout calibration */
N#define USB_OTG_GUSBCFG_TOCAL_0                 0x00000001U            /*!<Bit 0 */
N#define USB_OTG_GUSBCFG_TOCAL_1                 0x00000002U            /*!<Bit 1 */
N#define USB_OTG_GUSBCFG_TOCAL_2                 0x00000004U            /*!<Bit 2 */
N#define USB_OTG_GUSBCFG_PHYSEL                  0x00000040U            /*!< USB 2.0 high-speed ULPI PHY or USB 1.1 full-speed serial transceiver select */
N#define USB_OTG_GUSBCFG_SRPCAP                  0x00000100U            /*!< SRP-capable */
N#define USB_OTG_GUSBCFG_HNPCAP                  0x00000200U            /*!< HNP-capable */
N#define USB_OTG_GUSBCFG_TRDT                    0x00003C00U            /*!< USB turnaround time */
N#define USB_OTG_GUSBCFG_TRDT_0                  0x00000400U            /*!<Bit 0 */
N#define USB_OTG_GUSBCFG_TRDT_1                  0x00000800U            /*!<Bit 1 */
N#define USB_OTG_GUSBCFG_TRDT_2                  0x00001000U            /*!<Bit 2 */
N#define USB_OTG_GUSBCFG_TRDT_3                  0x00002000U            /*!<Bit 3 */
N#define USB_OTG_GUSBCFG_PHYLPCS                 0x00008000U            /*!< PHY Low-power clock select */
N#define USB_OTG_GUSBCFG_ULPIFSLS                0x00020000U            /*!< ULPI FS/LS select               */
N#define USB_OTG_GUSBCFG_ULPIAR                  0x00040000U            /*!< ULPI Auto-resume                */
N#define USB_OTG_GUSBCFG_ULPICSM                 0x00080000U            /*!< ULPI Clock SuspendM             */
N#define USB_OTG_GUSBCFG_ULPIEVBUSD              0x00100000U            /*!< ULPI External VBUS Drive        */
N#define USB_OTG_GUSBCFG_ULPIEVBUSI              0x00200000U            /*!< ULPI external VBUS indicator    */
N#define USB_OTG_GUSBCFG_TSDPS                   0x00400000U            /*!< TermSel DLine pulsing selection */
N#define USB_OTG_GUSBCFG_PCCI                    0x00800000U            /*!< Indicator complement            */
N#define USB_OTG_GUSBCFG_PTCI                    0x01000000U            /*!< Indicator pass through          */
N#define USB_OTG_GUSBCFG_ULPIIPD                 0x02000000U            /*!< ULPI interface protect disable  */
N#define USB_OTG_GUSBCFG_FHMOD                   0x20000000U            /*!< Forced host mode                */
N#define USB_OTG_GUSBCFG_FDMOD                   0x40000000U            /*!< Forced peripheral mode          */
N#define USB_OTG_GUSBCFG_CTXPKT                  0x80000000U            /*!< Corrupt Tx packet               */
N
N/********************  Bit definition for USB_OTG_GRSTCTL register  ********************/
N#define USB_OTG_GRSTCTL_CSRST                   0x00000001U            /*!< Core soft reset          */
N#define USB_OTG_GRSTCTL_HSRST                   0x00000002U            /*!< HCLK soft reset          */
N#define USB_OTG_GRSTCTL_FCRST                   0x00000004U            /*!< Host frame counter reset */
N#define USB_OTG_GRSTCTL_RXFFLSH                 0x00000010U            /*!< RxFIFO flush             */
N#define USB_OTG_GRSTCTL_TXFFLSH                 0x00000020U            /*!< TxFIFO flush             */
N#define USB_OTG_GRSTCTL_TXFNUM                  0x000007C0U            /*!< TxFIFO number */
N#define USB_OTG_GRSTCTL_TXFNUM_0                0x00000040U            /*!<Bit 0 */
N#define USB_OTG_GRSTCTL_TXFNUM_1                0x00000080U            /*!<Bit 1 */
N#define USB_OTG_GRSTCTL_TXFNUM_2                0x00000100U            /*!<Bit 2 */
N#define USB_OTG_GRSTCTL_TXFNUM_3                0x00000200U            /*!<Bit 3 */
N#define USB_OTG_GRSTCTL_TXFNUM_4                0x00000400U            /*!<Bit 4 */
N#define USB_OTG_GRSTCTL_DMAREQ                  0x40000000U            /*!< DMA request signal */
N#define USB_OTG_GRSTCTL_AHBIDL                  0x80000000U            /*!< AHB master idle */
N
N/********************  Bit definition for USB_OTG_DIEPMSK register  ********************/
N#define USB_OTG_DIEPMSK_XFRCM                   0x00000001U            /*!< Transfer completed interrupt mask                 */
N#define USB_OTG_DIEPMSK_EPDM                    0x00000002U            /*!< Endpoint disabled interrupt mask                  */
N#define USB_OTG_DIEPMSK_TOM                     0x00000008U            /*!< Timeout condition mask (nonisochronous endpoints) */
N#define USB_OTG_DIEPMSK_ITTXFEMSK               0x00000010U            /*!< IN token received when TxFIFO empty mask          */
N#define USB_OTG_DIEPMSK_INEPNMM                 0x00000020U            /*!< IN token received with EP mismatch mask           */
N#define USB_OTG_DIEPMSK_INEPNEM                 0x00000040U            /*!< IN endpoint NAK effective mask                    */
N#define USB_OTG_DIEPMSK_TXFURM                  0x00000100U            /*!< FIFO underrun mask                                */
N#define USB_OTG_DIEPMSK_BIM                     0x00000200U            /*!< BNA interrupt mask                                */
N
N/********************  Bit definition for USB_OTG_HPTXSTS register  ********************/
N#define USB_OTG_HPTXSTS_PTXFSAVL                0x0000FFFFU            /*!< Periodic transmit data FIFO space available     */
N#define USB_OTG_HPTXSTS_PTXQSAV                 0x00FF0000U            /*!< Periodic transmit request queue space available */
N#define USB_OTG_HPTXSTS_PTXQSAV_0               0x00010000U            /*!<Bit 0 */
N#define USB_OTG_HPTXSTS_PTXQSAV_1               0x00020000U            /*!<Bit 1 */
N#define USB_OTG_HPTXSTS_PTXQSAV_2               0x00040000U            /*!<Bit 2 */
N#define USB_OTG_HPTXSTS_PTXQSAV_3               0x00080000U            /*!<Bit 3 */
N#define USB_OTG_HPTXSTS_PTXQSAV_4               0x00100000U            /*!<Bit 4 */
N#define USB_OTG_HPTXSTS_PTXQSAV_5               0x00200000U            /*!<Bit 5 */
N#define USB_OTG_HPTXSTS_PTXQSAV_6               0x00400000U            /*!<Bit 6 */
N#define USB_OTG_HPTXSTS_PTXQSAV_7               0x00800000U            /*!<Bit 7 */
N
N#define USB_OTG_HPTXSTS_PTXQTOP                 0xFF000000U            /*!< Top of the periodic transmit request queue */
N#define USB_OTG_HPTXSTS_PTXQTOP_0               0x01000000U            /*!<Bit 0 */
N#define USB_OTG_HPTXSTS_PTXQTOP_1               0x02000000U            /*!<Bit 1 */
N#define USB_OTG_HPTXSTS_PTXQTOP_2               0x04000000U            /*!<Bit 2 */
N#define USB_OTG_HPTXSTS_PTXQTOP_3               0x08000000U            /*!<Bit 3 */
N#define USB_OTG_HPTXSTS_PTXQTOP_4               0x10000000U            /*!<Bit 4 */
N#define USB_OTG_HPTXSTS_PTXQTOP_5               0x20000000U            /*!<Bit 5 */
N#define USB_OTG_HPTXSTS_PTXQTOP_6               0x40000000U            /*!<Bit 6 */
N#define USB_OTG_HPTXSTS_PTXQTOP_7               0x80000000U            /*!<Bit 7 */
N
N/********************  Bit definition for USB_OTG_HAINT register  ********************/
N#define USB_OTG_HAINT_HAINT                     0x0000FFFFU            /*!< Channel interrupts */
N
N/********************  Bit definition for USB_OTG_DOEPMSK register  ********************/
N#define USB_OTG_DOEPMSK_XFRCM                   0x00000001U            /*!< Transfer completed interrupt mask */
N#define USB_OTG_DOEPMSK_EPDM                    0x00000002U            /*!< Endpoint disabled interrupt mask               */
N#define USB_OTG_DOEPMSK_STUPM                   0x00000008U            /*!< SETUP phase done mask                          */
N#define USB_OTG_DOEPMSK_OTEPDM                  0x00000010U            /*!< OUT token received when endpoint disabled mask */
N#define USB_OTG_DOEPMSK_OTEPSPRM                0x00000020U            /*!< Status Phase Received mask                     */
N#define USB_OTG_DOEPMSK_B2BSTUP                 0x00000040U            /*!< Back-to-back SETUP packets received mask       */
N#define USB_OTG_DOEPMSK_OPEM                    0x00000100U            /*!< OUT packet error mask                          */
N#define USB_OTG_DOEPMSK_BOIM                    0x00000200U            /*!< BNA interrupt mask                             */
N
N/********************  Bit definition for USB_OTG_GINTSTS register  ********************/
N#define USB_OTG_GINTSTS_CMOD                    0x00000001U            /*!< Current mode of operation                      */
N#define USB_OTG_GINTSTS_MMIS                    0x00000002U            /*!< Mode mismatch interrupt                        */
N#define USB_OTG_GINTSTS_OTGINT                  0x00000004U            /*!< OTG interrupt                                  */
N#define USB_OTG_GINTSTS_SOF                     0x00000008U            /*!< Start of frame                                 */
N#define USB_OTG_GINTSTS_RXFLVL                  0x00000010U            /*!< RxFIFO nonempty                                */
N#define USB_OTG_GINTSTS_NPTXFE                  0x00000020U            /*!< Nonperiodic TxFIFO empty                       */
N#define USB_OTG_GINTSTS_GINAKEFF                0x00000040U            /*!< Global IN nonperiodic NAK effective            */
N#define USB_OTG_GINTSTS_BOUTNAKEFF              0x00000080U            /*!< Global OUT NAK effective                       */
N#define USB_OTG_GINTSTS_ESUSP                   0x00000400U            /*!< Early suspend                                  */
N#define USB_OTG_GINTSTS_USBSUSP                 0x00000800U            /*!< USB suspend                                    */
N#define USB_OTG_GINTSTS_USBRST                  0x00001000U            /*!< USB reset                                      */
N#define USB_OTG_GINTSTS_ENUMDNE                 0x00002000U            /*!< Enumeration done                               */
N#define USB_OTG_GINTSTS_ISOODRP                 0x00004000U            /*!< Isochronous OUT packet dropped interrupt       */
N#define USB_OTG_GINTSTS_EOPF                    0x00008000U            /*!< End of periodic frame interrupt                */
N#define USB_OTG_GINTSTS_IEPINT                  0x00040000U            /*!< IN endpoint interrupt                          */
N#define USB_OTG_GINTSTS_OEPINT                  0x00080000U            /*!< OUT endpoint interrupt                         */
N#define USB_OTG_GINTSTS_IISOIXFR                0x00100000U            /*!< Incomplete isochronous IN transfer             */
N#define USB_OTG_GINTSTS_PXFR_INCOMPISOOUT       0x00200000U            /*!< Incomplete periodic transfer                   */
N#define USB_OTG_GINTSTS_DATAFSUSP               0x00400000U            /*!< Data fetch suspended                           */
N#define USB_OTG_GINTSTS_RSTDET                  0x00800000U            /*!< Reset detected interrupt                       */
N#define USB_OTG_GINTSTS_HPRTINT                 0x01000000U            /*!< Host port interrupt                            */
N#define USB_OTG_GINTSTS_HCINT                   0x02000000U            /*!< Host channels interrupt                        */
N#define USB_OTG_GINTSTS_PTXFE                   0x04000000U            /*!< Periodic TxFIFO empty                          */
N#define USB_OTG_GINTSTS_LPMINT                  0x08000000U            /*!< LPM interrupt                                  */
N#define USB_OTG_GINTSTS_CIDSCHG                 0x10000000U            /*!< Connector ID status change                     */
N#define USB_OTG_GINTSTS_DISCINT                 0x20000000U            /*!< Disconnect detected interrupt                  */
N#define USB_OTG_GINTSTS_SRQINT                  0x40000000U            /*!< Session request/new session detected interrupt */
N#define USB_OTG_GINTSTS_WKUINT                  0x80000000U            /*!< Resume/remote wakeup detected interrupt        */
N
N/********************  Bit definition for USB_OTG_GINTMSK register  ********************/
N#define USB_OTG_GINTMSK_MMISM                   0x00000002U            /*!< Mode mismatch interrupt mask                        */
N#define USB_OTG_GINTMSK_OTGINT                  0x00000004U            /*!< OTG interrupt mask                                  */
N#define USB_OTG_GINTMSK_SOFM                    0x00000008U            /*!< Start of frame mask                                 */
N#define USB_OTG_GINTMSK_RXFLVLM                 0x00000010U            /*!< Receive FIFO nonempty mask                          */
N#define USB_OTG_GINTMSK_NPTXFEM                 0x00000020U            /*!< Nonperiodic TxFIFO empty mask                       */
N#define USB_OTG_GINTMSK_GINAKEFFM               0x00000040U            /*!< Global nonperiodic IN NAK effective mask            */
N#define USB_OTG_GINTMSK_GONAKEFFM               0x00000080U            /*!< Global OUT NAK effective mask                       */
N#define USB_OTG_GINTMSK_ESUSPM                  0x00000400U            /*!< Early suspend mask                                  */
N#define USB_OTG_GINTMSK_USBSUSPM                0x00000800U            /*!< USB suspend mask                                    */
N#define USB_OTG_GINTMSK_USBRST                  0x00001000U            /*!< USB reset mask                                      */
N#define USB_OTG_GINTMSK_ENUMDNEM                0x00002000U            /*!< Enumeration done mask                               */
N#define USB_OTG_GINTMSK_ISOODRPM                0x00004000U            /*!< Isochronous OUT packet dropped interrupt mask       */
N#define USB_OTG_GINTMSK_EOPFM                   0x00008000U            /*!< End of periodic frame interrupt mask                */
N#define USB_OTG_GINTMSK_EPMISM                  0x00020000U            /*!< Endpoint mismatch interrupt mask                    */
N#define USB_OTG_GINTMSK_IEPINT                  0x00040000U            /*!< IN endpoints interrupt mask                         */
N#define USB_OTG_GINTMSK_OEPINT                  0x00080000U            /*!< OUT endpoints interrupt mask                        */
N#define USB_OTG_GINTMSK_IISOIXFRM               0x00100000U            /*!< Incomplete isochronous IN transfer mask             */
N#define USB_OTG_GINTMSK_PXFRM_IISOOXFRM         0x00200000U            /*!< Incomplete periodic transfer mask                   */
N#define USB_OTG_GINTMSK_FSUSPM                  0x00400000U            /*!< Data fetch suspended mask                           */
N#define USB_OTG_GINTMSK_RSTDEM                  0x00800000U            /*!< Reset detected interrupt mask                       */
N#define USB_OTG_GINTMSK_PRTIM                   0x01000000U            /*!< Host port interrupt mask                            */
N#define USB_OTG_GINTMSK_HCIM                    0x02000000U            /*!< Host channels interrupt mask                        */
N#define USB_OTG_GINTMSK_PTXFEM                  0x04000000U            /*!< Periodic TxFIFO empty mask                          */
N#define USB_OTG_GINTMSK_LPMINTM                 0x08000000U            /*!< LPM interrupt Mask                                  */
N#define USB_OTG_GINTMSK_CIDSCHGM                0x10000000U            /*!< Connector ID status change mask                     */
N#define USB_OTG_GINTMSK_DISCINT                 0x20000000U            /*!< Disconnect detected interrupt mask                  */
N#define USB_OTG_GINTMSK_SRQIM                   0x40000000U            /*!< Session request/new session detected interrupt mask */
N#define USB_OTG_GINTMSK_WUIM                    0x80000000U            /*!< Resume/remote wakeup detected interrupt mask        */
N
N/********************  Bit definition for USB_OTG_DAINT register  ********************/
N#define USB_OTG_DAINT_IEPINT                  0x0000FFFFU            /*!< IN endpoint interrupt bits  */
N#define USB_OTG_DAINT_OEPINT                  0xFFFF0000U            /*!< OUT endpoint interrupt bits */
N
N/********************  Bit definition for USB_OTG_HAINTMSK register  ********************/
N#define USB_OTG_HAINTMSK_HAINTM                  0x0000FFFFU            /*!< Channel interrupt mask */
N
N/********************  Bit definition for USB_OTG_GRXSTSP register  ********************/
N#define USB_OTG_GRXSTSP_EPNUM                    0x0000000FU            /*!< IN EP interrupt mask bits  */
N#define USB_OTG_GRXSTSP_BCNT                     0x00007FF0U            /*!< OUT EP interrupt mask bits */
N#define USB_OTG_GRXSTSP_DPID                     0x00018000U            /*!< OUT EP interrupt mask bits */
N#define USB_OTG_GRXSTSP_PKTSTS                   0x001E0000U            /*!< OUT EP interrupt mask bits */
N
N/********************  Bit definition for USB_OTG_DAINTMSK register  ********************/
N#define USB_OTG_DAINTMSK_IEPM                    0x0000FFFFU            /*!< IN EP interrupt mask bits */
N#define USB_OTG_DAINTMSK_OEPM                    0xFFFF0000U            /*!< OUT EP interrupt mask bits */
N
N/********************  Bit definition for OTG register  ********************/
N
N#define USB_OTG_CHNUM                   0x0000000FU            /*!< Channel number */
N#define USB_OTG_CHNUM_0                 0x00000001U            /*!<Bit 0 */
N#define USB_OTG_CHNUM_1                 0x00000002U            /*!<Bit 1 */
N#define USB_OTG_CHNUM_2                 0x00000004U            /*!<Bit 2 */
N#define USB_OTG_CHNUM_3                 0x00000008U            /*!<Bit 3 */
N#define USB_OTG_BCNT                    0x00007FF0U            /*!< Byte count */
N
N#define USB_OTG_DPID                    0x00018000U            /*!< Data PID */
N#define USB_OTG_DPID_0                  0x00008000U            /*!<Bit 0 */
N#define USB_OTG_DPID_1                  0x00010000U            /*!<Bit 1 */
N
N#define USB_OTG_PKTSTS                  0x001E0000U            /*!< Packet status */
N#define USB_OTG_PKTSTS_0                0x00020000U            /*!<Bit 0 */
N#define USB_OTG_PKTSTS_1                0x00040000U            /*!<Bit 1 */
N#define USB_OTG_PKTSTS_2                0x00080000U            /*!<Bit 2 */
N#define USB_OTG_PKTSTS_3                0x00100000U            /*!<Bit 3 */
N
N#define USB_OTG_EPNUM                   0x0000000FU            /*!< Endpoint number */
N#define USB_OTG_EPNUM_0                 0x00000001U            /*!<Bit 0 */
N#define USB_OTG_EPNUM_1                 0x00000002U            /*!<Bit 1 */
N#define USB_OTG_EPNUM_2                 0x00000004U            /*!<Bit 2 */
N#define USB_OTG_EPNUM_3                 0x00000008U            /*!<Bit 3 */
N
N#define USB_OTG_FRMNUM                  0x01E00000U            /*!< Frame number */
N#define USB_OTG_FRMNUM_0                0x00200000U            /*!<Bit 0 */
N#define USB_OTG_FRMNUM_1                0x00400000U            /*!<Bit 1 */
N#define USB_OTG_FRMNUM_2                0x00800000U            /*!<Bit 2 */
N#define USB_OTG_FRMNUM_3                0x01000000U            /*!<Bit 3 */
N
N/********************  Bit definition for OTG register  ********************/
N
N#define USB_OTG_CHNUM                   0x0000000FU            /*!< Channel number */
N#define USB_OTG_CHNUM_0                 0x00000001U            /*!<Bit 0 */
N#define USB_OTG_CHNUM_1                 0x00000002U            /*!<Bit 1 */
N#define USB_OTG_CHNUM_2                 0x00000004U            /*!<Bit 2 */
N#define USB_OTG_CHNUM_3                 0x00000008U            /*!<Bit 3 */
N#define USB_OTG_BCNT                    0x00007FF0U            /*!< Byte count */
N
N#define USB_OTG_DPID                    0x00018000U            /*!< Data PID */
N#define USB_OTG_DPID_0                  0x00008000U            /*!<Bit 0 */
N#define USB_OTG_DPID_1                  0x00010000U            /*!<Bit 1 */
N
N#define USB_OTG_PKTSTS                  0x001E0000U            /*!< Packet status */
N#define USB_OTG_PKTSTS_0                0x00020000U            /*!<Bit 0 */
N#define USB_OTG_PKTSTS_1                0x00040000U            /*!<Bit 1 */
N#define USB_OTG_PKTSTS_2                0x00080000U            /*!<Bit 2 */
N#define USB_OTG_PKTSTS_3                0x00100000U            /*!<Bit 3 */
N
N#define USB_OTG_EPNUM                   0x0000000FU            /*!< Endpoint number */
N#define USB_OTG_EPNUM_0                 0x00000001U            /*!<Bit 0 */
N#define USB_OTG_EPNUM_1                 0x00000002U            /*!<Bit 1 */
N#define USB_OTG_EPNUM_2                 0x00000004U            /*!<Bit 2 */
N#define USB_OTG_EPNUM_3                 0x00000008U            /*!<Bit 3 */
N
N#define USB_OTG_FRMNUM                  0x01E00000U            /*!< Frame number */
N#define USB_OTG_FRMNUM_0                0x00200000U            /*!<Bit 0 */
N#define USB_OTG_FRMNUM_1                0x00400000U            /*!<Bit 1 */
N#define USB_OTG_FRMNUM_2                0x00800000U            /*!<Bit 2 */
N#define USB_OTG_FRMNUM_3                0x01000000U            /*!<Bit 3 */
N
N/********************  Bit definition for USB_OTG_GRXFSIZ register  ********************/
N#define USB_OTG_GRXFSIZ_RXFD            0x0000FFFFU            /*!< RxFIFO depth */
N
N/********************  Bit definition for USB_OTG_DVBUSDIS register  ********************/
N#define USB_OTG_DVBUSDIS_VBUSDT         0x0000FFFFU            /*!< Device VBUS discharge time */
N
N/********************  Bit definition for OTG register  ********************/
N#define USB_OTG_NPTXFSA                 0x0000FFFFU            /*!< Nonperiodic transmit RAM start address */
N#define USB_OTG_NPTXFD                  0xFFFF0000U            /*!< Nonperiodic TxFIFO depth               */
N#define USB_OTG_TX0FSA                  0x0000FFFFU            /*!< Endpoint 0 transmit RAM start address  */
N#define USB_OTG_TX0FD                   0xFFFF0000U            /*!< Endpoint 0 TxFIFO depth                */
N
N/********************  Bit definition for USB_OTG_DVBUSPULSE register  ********************/
N#define USB_OTG_DVBUSPULSE_DVBUSP                0x00000FFFU            /*!< Device VBUS pulsing time */
N
N/********************  Bit definition for USB_OTG_GNPTXSTS register  ********************/
N#define USB_OTG_GNPTXSTS_NPTXFSAV                0x0000FFFFU            /*!< Nonperiodic TxFIFO space available */
N
N#define USB_OTG_GNPTXSTS_NPTQXSAV                0x00FF0000U            /*!< Nonperiodic transmit request queue space available */
N#define USB_OTG_GNPTXSTS_NPTQXSAV_0              0x00010000U            /*!<Bit 0 */
N#define USB_OTG_GNPTXSTS_NPTQXSAV_1              0x00020000U            /*!<Bit 1 */
N#define USB_OTG_GNPTXSTS_NPTQXSAV_2              0x00040000U            /*!<Bit 2 */
N#define USB_OTG_GNPTXSTS_NPTQXSAV_3              0x00080000U            /*!<Bit 3 */
N#define USB_OTG_GNPTXSTS_NPTQXSAV_4              0x00100000U            /*!<Bit 4 */
N#define USB_OTG_GNPTXSTS_NPTQXSAV_5              0x00200000U            /*!<Bit 5 */
N#define USB_OTG_GNPTXSTS_NPTQXSAV_6              0x00400000U            /*!<Bit 6 */
N#define USB_OTG_GNPTXSTS_NPTQXSAV_7              0x00800000U            /*!<Bit 7 */
N
N#define USB_OTG_GNPTXSTS_NPTXQTOP                0x7F000000U            /*!< Top of the nonperiodic transmit request queue */
N#define USB_OTG_GNPTXSTS_NPTXQTOP_0              0x01000000U            /*!<Bit 0 */
N#define USB_OTG_GNPTXSTS_NPTXQTOP_1              0x02000000U            /*!<Bit 1 */
N#define USB_OTG_GNPTXSTS_NPTXQTOP_2              0x04000000U            /*!<Bit 2 */
N#define USB_OTG_GNPTXSTS_NPTXQTOP_3              0x08000000U            /*!<Bit 3 */
N#define USB_OTG_GNPTXSTS_NPTXQTOP_4              0x10000000U            /*!<Bit 4 */
N#define USB_OTG_GNPTXSTS_NPTXQTOP_5              0x20000000U            /*!<Bit 5 */
N#define USB_OTG_GNPTXSTS_NPTXQTOP_6              0x40000000U            /*!<Bit 6 */
N
N/********************  Bit definition for USB_OTG_DTHRCTL register  ********************/
N#define USB_OTG_DTHRCTL_NONISOTHREN             0x00000001U            /*!< Nonisochronous IN endpoints threshold enable */
N#define USB_OTG_DTHRCTL_ISOTHREN                0x00000002U            /*!< ISO IN endpoint threshold enable */
N
N#define USB_OTG_DTHRCTL_TXTHRLEN                0x000007FCU            /*!< Transmit threshold length */
N#define USB_OTG_DTHRCTL_TXTHRLEN_0              0x00000004U            /*!<Bit 0 */
N#define USB_OTG_DTHRCTL_TXTHRLEN_1              0x00000008U            /*!<Bit 1 */
N#define USB_OTG_DTHRCTL_TXTHRLEN_2              0x00000010U            /*!<Bit 2 */
N#define USB_OTG_DTHRCTL_TXTHRLEN_3              0x00000020U            /*!<Bit 3 */
N#define USB_OTG_DTHRCTL_TXTHRLEN_4              0x00000040U            /*!<Bit 4 */
N#define USB_OTG_DTHRCTL_TXTHRLEN_5              0x00000080U            /*!<Bit 5 */
N#define USB_OTG_DTHRCTL_TXTHRLEN_6              0x00000100U            /*!<Bit 6 */
N#define USB_OTG_DTHRCTL_TXTHRLEN_7              0x00000200U            /*!<Bit 7 */
N#define USB_OTG_DTHRCTL_TXTHRLEN_8              0x00000400U            /*!<Bit 8 */
N#define USB_OTG_DTHRCTL_RXTHREN                 0x00010000U            /*!< Receive threshold enable */
N
N#define USB_OTG_DTHRCTL_RXTHRLEN                0x03FE0000U            /*!< Receive threshold length */
N#define USB_OTG_DTHRCTL_RXTHRLEN_0              0x00020000U            /*!<Bit 0 */
N#define USB_OTG_DTHRCTL_RXTHRLEN_1              0x00040000U            /*!<Bit 1 */
N#define USB_OTG_DTHRCTL_RXTHRLEN_2              0x00080000U            /*!<Bit 2 */
N#define USB_OTG_DTHRCTL_RXTHRLEN_3              0x00100000U            /*!<Bit 3 */
N#define USB_OTG_DTHRCTL_RXTHRLEN_4              0x00200000U            /*!<Bit 4 */
N#define USB_OTG_DTHRCTL_RXTHRLEN_5              0x00400000U            /*!<Bit 5 */
N#define USB_OTG_DTHRCTL_RXTHRLEN_6              0x00800000U            /*!<Bit 6 */
N#define USB_OTG_DTHRCTL_RXTHRLEN_7              0x01000000U            /*!<Bit 7 */
N#define USB_OTG_DTHRCTL_RXTHRLEN_8              0x02000000U            /*!<Bit 8 */
N#define USB_OTG_DTHRCTL_ARPEN                   0x08000000U            /*!< Arbiter parking enable */
N
N/********************  Bit definition for USB_OTG_DIEPEMPMSK register  ********************/
N#define USB_OTG_DIEPEMPMSK_INEPTXFEM            0x0000FFFFU         /*!< IN EP Tx FIFO empty interrupt mask bits */
N
N/********************  Bit definition for USB_OTG_DEACHINT register  ********************/
N#define USB_OTG_DEACHINT_IEP1INT                0x00000002U           /*!< IN endpoint 1interrupt bit   */
N#define USB_OTG_DEACHINT_OEP1INT                0x00020000U           /*!< OUT endpoint 1 interrupt bit */
N
N/********************  Bit definition for USB_OTG_GCCFG register  ********************/
N#define USB_OTG_GCCFG_PWRDWN                 0x00010000U              /*!< Power down */
N#define USB_OTG_GCCFG_VBDEN                  0x00200000U              /*!< USB VBUS Detection Enable */
N
N/********************  Bit definition for USB_OTG_GPWRDN) register  ********************/
N#define USB_OTG_GPWRDN_ADPMEN                 0x00000001U             /*!< ADP module enable */
N#define USB_OTG_GPWRDN_ADPIF                  0x00800000U             /*!< ADP Interrupt flag */
N
N/********************  Bit definition for USB_OTG_DEACHINTMSK register  ********************/
N#define USB_OTG_DEACHINTMSK_IEP1INTM          0x00000002U            /*!< IN Endpoint 1 interrupt mask bit  */
N#define USB_OTG_DEACHINTMSK_OEP1INTM          0x00020000U            /*!< OUT Endpoint 1 interrupt mask bit */
N 
N/********************  Bit definition for USB_OTG_CID register  ********************/
N#define USB_OTG_CID_PRODUCT_ID               0xFFFFFFFFU            /*!< Product ID field */
N
N/********************  Bit definition for USB_OTG_GLPMCFG register  ********************/
N#define  USB_OTG_GLPMCFG_LPMEN               0x00000001U            /*!< LPM support enable                                     */
N#define  USB_OTG_GLPMCFG_LPMACK              0x00000002U            /*!< LPM Token acknowledge enable                           */
N#define  USB_OTG_GLPMCFG_BESL                0x0000003CU            /*!< BESL value received with last ACKed LPM Token          */
N#define  USB_OTG_GLPMCFG_REMWAKE             0x00000040U            /*!< bRemoteWake value received with last ACKed LPM Token   */
N#define  USB_OTG_GLPMCFG_L1SSEN              0x00000080U            /*!< L1 shallow sleep enable                                */
N#define  USB_OTG_GLPMCFG_BESLTHRS            0x00000F00U            /*!< BESL threshold                                         */
N#define  USB_OTG_GLPMCFG_L1DSEN              0x00001000U            /*!< L1 deep sleep enable                                   */
N#define  USB_OTG_GLPMCFG_LPMRSP              0x00006000U            /*!< LPM response                                           */
N#define  USB_OTG_GLPMCFG_SLPSTS              0x00008000U            /*!< Port sleep status                                      */
N#define  USB_OTG_GLPMCFG_L1RSMOK             0x00010000U            /*!< Sleep State Resume OK                                  */
N#define  USB_OTG_GLPMCFG_LPMCHIDX            0x001E0000U            /*!< LPM Channel Index                                      */
N#define  USB_OTG_GLPMCFG_LPMRCNT             0x00E00000U            /*!< LPM retry count                                        */
N#define  USB_OTG_GLPMCFG_SNDLPM              0x01000000U            /*!< Send LPM transaction                                   */
N#define  USB_OTG_GLPMCFG_LPMRCNTSTS          0x0E000000U            /*!< LPM retry count status                                 */
N#define  USB_OTG_GLPMCFG_ENBESL              0x10000000U            /*!< Enable best effort service latency                     */
N
N/********************  Bit definition for USB_OTG_DIEPEACHMSK1 register  ********************/
N#define USB_OTG_DIEPEACHMSK1_XFRCM           0x00000001U            /*!< Transfer completed interrupt mask                 */
N#define USB_OTG_DIEPEACHMSK1_EPDM            0x00000002U            /*!< Endpoint disabled interrupt mask                  */
N#define USB_OTG_DIEPEACHMSK1_TOM             0x00000008U            /*!< Timeout condition mask (nonisochronous endpoints) */
N#define USB_OTG_DIEPEACHMSK1_ITTXFEMSK       0x00000010U            /*!< IN token received when TxFIFO empty mask          */
N#define USB_OTG_DIEPEACHMSK1_INEPNMM         0x00000020U            /*!< IN token received with EP mismatch mask           */
N#define USB_OTG_DIEPEACHMSK1_INEPNEM         0x00000040U            /*!< IN endpoint NAK effective mask                    */
N#define USB_OTG_DIEPEACHMSK1_TXFURM          0x00000100U            /*!< FIFO underrun mask                                */
N#define USB_OTG_DIEPEACHMSK1_BIM             0x00000200U            /*!< BNA interrupt mask                                */
N#define USB_OTG_DIEPEACHMSK1_NAKM            0x00002000U            /*!< NAK interrupt mask                                */
N
N/********************  Bit definition for USB_OTG_HPRT register  ********************/
N#define USB_OTG_HPRT_PCSTS                   0x00000001U            /*!< Port connect status        */
N#define USB_OTG_HPRT_PCDET                   0x00000002U            /*!< Port connect detected      */
N#define USB_OTG_HPRT_PENA                    0x00000004U            /*!< Port enable                */
N#define USB_OTG_HPRT_PENCHNG                 0x00000008U            /*!< Port enable/disable change */
N#define USB_OTG_HPRT_POCA                    0x00000010U            /*!< Port overcurrent active    */
N#define USB_OTG_HPRT_POCCHNG                 0x00000020U            /*!< Port overcurrent change    */
N#define USB_OTG_HPRT_PRES                    0x00000040U            /*!< Port resume                */
N#define USB_OTG_HPRT_PSUSP                   0x00000080U            /*!< Port suspend               */
N#define USB_OTG_HPRT_PRST                    0x00000100U            /*!< Port reset                 */
N
N#define USB_OTG_HPRT_PLSTS                   0x00000C00U            /*!< Port line status           */
N#define USB_OTG_HPRT_PLSTS_0                 0x00000400U            /*!<Bit 0 */
N#define USB_OTG_HPRT_PLSTS_1                 0x00000800U            /*!<Bit 1 */
N#define USB_OTG_HPRT_PPWR                    0x00001000U            /*!< Port power                 */
N
N#define USB_OTG_HPRT_PTCTL                   0x0001E000U            /*!< Port test control          */
N#define USB_OTG_HPRT_PTCTL_0                 0x00002000U            /*!<Bit 0 */
N#define USB_OTG_HPRT_PTCTL_1                 0x00004000U            /*!<Bit 1 */
N#define USB_OTG_HPRT_PTCTL_2                 0x00008000U            /*!<Bit 2 */
N#define USB_OTG_HPRT_PTCTL_3                 0x00010000U            /*!<Bit 3 */
N
N#define USB_OTG_HPRT_PSPD                    0x00060000U            /*!< Port speed                 */
N#define USB_OTG_HPRT_PSPD_0                  0x00020000U            /*!<Bit 0 */
N#define USB_OTG_HPRT_PSPD_1                  0x00040000U            /*!<Bit 1 */
N
N/********************  Bit definition for USB_OTG_DOEPEACHMSK1 register  ********************/
N#define USB_OTG_DOEPEACHMSK1_XFRCM               0x00000001U            /*!< Transfer completed interrupt mask         */
N#define USB_OTG_DOEPEACHMSK1_EPDM                0x00000002U            /*!< Endpoint disabled interrupt mask          */
N#define USB_OTG_DOEPEACHMSK1_TOM                 0x00000008U            /*!< Timeout condition mask                    */
N#define USB_OTG_DOEPEACHMSK1_ITTXFEMSK           0x00000010U            /*!< IN token received when TxFIFO empty mask  */
N#define USB_OTG_DOEPEACHMSK1_INEPNMM             0x00000020U            /*!< IN token received with EP mismatch mask   */
N#define USB_OTG_DOEPEACHMSK1_INEPNEM             0x00000040U            /*!< IN endpoint NAK effective mask            */
N#define USB_OTG_DOEPEACHMSK1_TXFURM              0x00000100U            /*!< OUT packet error mask                     */
N#define USB_OTG_DOEPEACHMSK1_BIM                 0x00000200U            /*!< BNA interrupt mask                        */
N#define USB_OTG_DOEPEACHMSK1_BERRM               0x00001000U            /*!< Bubble error interrupt mask               */
N#define USB_OTG_DOEPEACHMSK1_NAKM                0x00002000U            /*!< NAK interrupt mask                        */
N#define USB_OTG_DOEPEACHMSK1_NYETM               0x00004000U            /*!< NYET interrupt mask                       */
N
N/********************  Bit definition for USB_OTG_HPTXFSIZ register  ********************/
N#define USB_OTG_HPTXFSIZ_PTXSA                   0x0000FFFFU            /*!< Host periodic TxFIFO start address            */
N#define USB_OTG_HPTXFSIZ_PTXFD                   0xFFFF0000U            /*!< Host periodic TxFIFO depth                    */
N
N/********************  Bit definition for USB_OTG_DIEPCTL register  ********************/
N#define USB_OTG_DIEPCTL_MPSIZ                   0x000007FFU            /*!< Maximum packet size              */
N#define USB_OTG_DIEPCTL_USBAEP                  0x00008000U            /*!< USB active endpoint              */
N#define USB_OTG_DIEPCTL_EONUM_DPID              0x00010000U            /*!< Even/odd frame                   */
N#define USB_OTG_DIEPCTL_NAKSTS                  0x00020000U            /*!< NAK status                       */
N
N#define USB_OTG_DIEPCTL_EPTYP                   0x000C0000U            /*!< Endpoint type                    */
N#define USB_OTG_DIEPCTL_EPTYP_0                 0x00040000U            /*!<Bit 0 */
N#define USB_OTG_DIEPCTL_EPTYP_1                 0x00080000U            /*!<Bit 1 */
N#define USB_OTG_DIEPCTL_STALL                   0x00200000U            /*!< STALL handshake                  */
N
N#define USB_OTG_DIEPCTL_TXFNUM                  0x03C00000U            /*!< TxFIFO number                    */
N#define USB_OTG_DIEPCTL_TXFNUM_0                0x00400000U            /*!<Bit 0 */
N#define USB_OTG_DIEPCTL_TXFNUM_1                0x00800000U            /*!<Bit 1 */
N#define USB_OTG_DIEPCTL_TXFNUM_2                0x01000000U            /*!<Bit 2 */
N#define USB_OTG_DIEPCTL_TXFNUM_3                0x02000000U            /*!<Bit 3 */
N#define USB_OTG_DIEPCTL_CNAK                    0x04000000U            /*!< Clear NAK                        */
N#define USB_OTG_DIEPCTL_SNAK                    0x08000000U            /*!< Set NAK */
N#define USB_OTG_DIEPCTL_SD0PID_SEVNFRM          0x10000000U            /*!< Set DATA0 PID                    */
N#define USB_OTG_DIEPCTL_SODDFRM                 0x20000000U            /*!< Set odd frame                    */
N#define USB_OTG_DIEPCTL_EPDIS                   0x40000000U            /*!< Endpoint disable                 */
N#define USB_OTG_DIEPCTL_EPENA                   0x80000000U            /*!< Endpoint enable                  */
N
N/********************  Bit definition for USB_OTG_HCCHAR register  ********************/
N#define USB_OTG_HCCHAR_MPSIZ                   0x000007FFU            /*!< Maximum packet size */
N
N#define USB_OTG_HCCHAR_EPNUM                   0x00007800U            /*!< Endpoint number */
N#define USB_OTG_HCCHAR_EPNUM_0                 0x00000800U            /*!<Bit 0 */
N#define USB_OTG_HCCHAR_EPNUM_1                 0x00001000U            /*!<Bit 1 */
N#define USB_OTG_HCCHAR_EPNUM_2                 0x00002000U            /*!<Bit 2 */
N#define USB_OTG_HCCHAR_EPNUM_3                 0x00004000U            /*!<Bit 3 */
N#define USB_OTG_HCCHAR_EPDIR                   0x00008000U            /*!< Endpoint direction */
N#define USB_OTG_HCCHAR_LSDEV                   0x00020000U            /*!< Low-speed device */
N
N#define USB_OTG_HCCHAR_EPTYP                   0x000C0000U            /*!< Endpoint type */
N#define USB_OTG_HCCHAR_EPTYP_0                 0x00040000U            /*!<Bit 0 */
N#define USB_OTG_HCCHAR_EPTYP_1                 0x00080000U            /*!<Bit 1 */
N
N#define USB_OTG_HCCHAR_MC                      0x00300000U            /*!< Multi Count (MC) / Error Count (EC) */
N#define USB_OTG_HCCHAR_MC_0                    0x00100000U            /*!<Bit 0 */
N#define USB_OTG_HCCHAR_MC_1                    0x00200000U            /*!<Bit 1 */
N
N#define USB_OTG_HCCHAR_DAD                     0x1FC00000U            /*!< Device address */
N#define USB_OTG_HCCHAR_DAD_0                   0x00400000U            /*!<Bit 0 */
N#define USB_OTG_HCCHAR_DAD_1                   0x00800000U            /*!<Bit 1 */
N#define USB_OTG_HCCHAR_DAD_2                   0x01000000U            /*!<Bit 2 */
N#define USB_OTG_HCCHAR_DAD_3                   0x02000000U            /*!<Bit 3 */
N#define USB_OTG_HCCHAR_DAD_4                   0x04000000U            /*!<Bit 4 */
N#define USB_OTG_HCCHAR_DAD_5                   0x08000000U            /*!<Bit 5 */
N#define USB_OTG_HCCHAR_DAD_6                   0x10000000U            /*!<Bit 6 */
N#define USB_OTG_HCCHAR_ODDFRM                  0x20000000U            /*!< Odd frame */
N#define USB_OTG_HCCHAR_CHDIS                   0x40000000U            /*!< Channel disable */
N#define USB_OTG_HCCHAR_CHENA                   0x80000000U            /*!< Channel enable */
N
N/********************  Bit definition for USB_OTG_HCSPLT register  ********************/
N
N#define USB_OTG_HCSPLT_PRTADDR                 0x0000007FU            /*!< Port address */
N#define USB_OTG_HCSPLT_PRTADDR_0               0x00000001U            /*!<Bit 0 */
N#define USB_OTG_HCSPLT_PRTADDR_1               0x00000002U            /*!<Bit 1 */
N#define USB_OTG_HCSPLT_PRTADDR_2               0x00000004U            /*!<Bit 2 */
N#define USB_OTG_HCSPLT_PRTADDR_3               0x00000008U            /*!<Bit 3 */
N#define USB_OTG_HCSPLT_PRTADDR_4               0x00000010U            /*!<Bit 4 */
N#define USB_OTG_HCSPLT_PRTADDR_5               0x00000020U            /*!<Bit 5 */
N#define USB_OTG_HCSPLT_PRTADDR_6               0x00000040U            /*!<Bit 6 */
N
N#define USB_OTG_HCSPLT_HUBADDR                 0x00003F80U            /*!< Hub address */
N#define USB_OTG_HCSPLT_HUBADDR_0               0x00000080U            /*!<Bit 0 */
N#define USB_OTG_HCSPLT_HUBADDR_1               0x00000100U            /*!<Bit 1 */
N#define USB_OTG_HCSPLT_HUBADDR_2               0x00000200U            /*!<Bit 2 */
N#define USB_OTG_HCSPLT_HUBADDR_3               0x00000400U            /*!<Bit 3 */
N#define USB_OTG_HCSPLT_HUBADDR_4               0x00000800U            /*!<Bit 4 */
N#define USB_OTG_HCSPLT_HUBADDR_5               0x00001000U            /*!<Bit 5 */
N#define USB_OTG_HCSPLT_HUBADDR_6               0x00002000U            /*!<Bit 6 */
N
N#define USB_OTG_HCSPLT_XACTPOS                 0x0000C000U            /*!< XACTPOS */
N#define USB_OTG_HCSPLT_XACTPOS_0               0x00004000U            /*!<Bit 0 */
N#define USB_OTG_HCSPLT_XACTPOS_1               0x00008000U            /*!<Bit 1 */
N#define USB_OTG_HCSPLT_COMPLSPLT               0x00010000U            /*!< Do complete split */
N#define USB_OTG_HCSPLT_SPLITEN                 0x80000000U            /*!< Split enable */
N
N/********************  Bit definition for USB_OTG_HCINT register  ********************/
N#define USB_OTG_HCINT_XFRC                    0x00000001U            /*!< Transfer completed */
N#define USB_OTG_HCINT_CHH                     0x00000002U            /*!< Channel halted */
N#define USB_OTG_HCINT_AHBERR                  0x00000004U            /*!< AHB error */
N#define USB_OTG_HCINT_STALL                   0x00000008U            /*!< STALL response received interrupt */
N#define USB_OTG_HCINT_NAK                     0x00000010U            /*!< NAK response received interrupt */
N#define USB_OTG_HCINT_ACK                     0x00000020U            /*!< ACK response received/transmitted interrupt */
N#define USB_OTG_HCINT_NYET                    0x00000040U            /*!< Response received interrupt */
N#define USB_OTG_HCINT_TXERR                   0x00000080U            /*!< Transaction error */
N#define USB_OTG_HCINT_BBERR                   0x00000100U            /*!< Babble error */
N#define USB_OTG_HCINT_FRMOR                   0x00000200U            /*!< Frame overrun */
N#define USB_OTG_HCINT_DTERR                   0x00000400U            /*!< Data toggle error */
N
N/********************  Bit definition for USB_OTG_DIEPINT register  ********************/
N#define USB_OTG_DIEPINT_XFRC                    0x00000001U            /*!< Transfer completed interrupt */
N#define USB_OTG_DIEPINT_EPDISD                  0x00000002U            /*!< Endpoint disabled interrupt */
N#define USB_OTG_DIEPINT_TOC                     0x00000008U            /*!< Timeout condition */
N#define USB_OTG_DIEPINT_ITTXFE                  0x00000010U            /*!< IN token received when TxFIFO is empty */
N#define USB_OTG_DIEPINT_INEPNE                  0x00000040U            /*!< IN endpoint NAK effective */
N#define USB_OTG_DIEPINT_TXFE                    0x00000080U            /*!< Transmit FIFO empty */
N#define USB_OTG_DIEPINT_TXFIFOUDRN              0x00000100U            /*!< Transmit Fifo Underrun */
N#define USB_OTG_DIEPINT_BNA                     0x00000200U            /*!< Buffer not available interrupt */
N#define USB_OTG_DIEPINT_PKTDRPSTS               0x00000800U            /*!< Packet dropped status */
N#define USB_OTG_DIEPINT_BERR                    0x00001000U            /*!< Babble error interrupt */
N#define USB_OTG_DIEPINT_NAK                     0x00002000U            /*!< NAK interrupt */
N
N/********************  Bit definition for USB_OTG_HCINTMSK register  ********************/
N#define USB_OTG_HCINTMSK_XFRCM                   0x00000001U            /*!< Transfer completed mask */
N#define USB_OTG_HCINTMSK_CHHM                    0x00000002U            /*!< Channel halted mask */
N#define USB_OTG_HCINTMSK_AHBERR                  0x00000004U            /*!< AHB error */
N#define USB_OTG_HCINTMSK_STALLM                  0x00000008U            /*!< STALL response received interrupt mask */
N#define USB_OTG_HCINTMSK_NAKM                    0x00000010U            /*!< NAK response received interrupt mask */
N#define USB_OTG_HCINTMSK_ACKM                    0x00000020U            /*!< ACK response received/transmitted interrupt mask */
N#define USB_OTG_HCINTMSK_NYET                    0x00000040U            /*!< response received interrupt mask */
N#define USB_OTG_HCINTMSK_TXERRM                  0x00000080U            /*!< Transaction error mask */
N#define USB_OTG_HCINTMSK_BBERRM                  0x00000100U            /*!< Babble error mask */
N#define USB_OTG_HCINTMSK_FRMORM                  0x00000200U            /*!< Frame overrun mask */
N#define USB_OTG_HCINTMSK_DTERRM                  0x00000400U            /*!< Data toggle error mask */
N
N/********************  Bit definition for USB_OTG_DIEPTSIZ register  ********************/
N
N#define USB_OTG_DIEPTSIZ_XFRSIZ                  0x0007FFFFU            /*!< Transfer size */
N#define USB_OTG_DIEPTSIZ_PKTCNT                  0x1FF80000U            /*!< Packet count */
N#define USB_OTG_DIEPTSIZ_MULCNT                  0x60000000U            /*!< Packet count */
N/********************  Bit definition for USB_OTG_HCTSIZ register  ********************/
N#define USB_OTG_HCTSIZ_XFRSIZ                    0x0007FFFFU            /*!< Transfer size */
N#define USB_OTG_HCTSIZ_PKTCNT                    0x1FF80000U            /*!< Packet count */
N#define USB_OTG_HCTSIZ_DOPING                    0x80000000U            /*!< Do PING */
N#define USB_OTG_HCTSIZ_DPID                      0x60000000U            /*!< Data PID */
N#define USB_OTG_HCTSIZ_DPID_0                    0x20000000U            /*!<Bit 0 */
N#define USB_OTG_HCTSIZ_DPID_1                    0x40000000U            /*!<Bit 1 */
N
N/********************  Bit definition for USB_OTG_DIEPDMA register  ********************/
N#define USB_OTG_DIEPDMA_DMAADDR                  0xFFFFFFFFU            /*!< DMA address */
N
N/********************  Bit definition for USB_OTG_HCDMA register  ********************/
N#define USB_OTG_HCDMA_DMAADDR                    0xFFFFFFFFU            /*!< DMA address */
N
N/********************  Bit definition for USB_OTG_DTXFSTS register  ********************/
N#define USB_OTG_DTXFSTS_INEPTFSAV                0x0000FFFFU            /*!< IN endpoint TxFIFO space available */
N
N/********************  Bit definition for USB_OTG_DIEPTXF register  ********************/
N#define USB_OTG_DIEPTXF_INEPTXSA                 0x0000FFFFU            /*!< IN endpoint FIFOx transmit RAM start address */
N#define USB_OTG_DIEPTXF_INEPTXFD                 0xFFFF0000U            /*!< IN endpoint TxFIFO depth */
N
N/********************  Bit definition for USB_OTG_DOEPCTL register  ********************/
N#define USB_OTG_DOEPCTL_MPSIZ                     0x000007FFU            /*!< Maximum packet size */          /*!<Bit 1 */
N#define USB_OTG_DOEPCTL_USBAEP                    0x00008000U            /*!< USB active endpoint */
N#define USB_OTG_DOEPCTL_NAKSTS                    0x00020000U            /*!< NAK status */
N#define USB_OTG_DOEPCTL_SD0PID_SEVNFRM            0x10000000U            /*!< Set DATA0 PID */
N#define USB_OTG_DOEPCTL_SODDFRM                   0x20000000U            /*!< Set odd frame */
N#define USB_OTG_DOEPCTL_EPTYP                     0x000C0000U            /*!< Endpoint type */
N#define USB_OTG_DOEPCTL_EPTYP_0                   0x00040000U            /*!<Bit 0 */
N#define USB_OTG_DOEPCTL_EPTYP_1                   0x00080000U            /*!<Bit 1 */
N#define USB_OTG_DOEPCTL_SNPM                      0x00100000U            /*!< Snoop mode */
N#define USB_OTG_DOEPCTL_STALL                     0x00200000U            /*!< STALL handshake */
N#define USB_OTG_DOEPCTL_CNAK                      0x04000000U            /*!< Clear NAK */
N#define USB_OTG_DOEPCTL_SNAK                      0x08000000U            /*!< Set NAK */
N#define USB_OTG_DOEPCTL_EPDIS                     0x40000000U            /*!< Endpoint disable */
N#define USB_OTG_DOEPCTL_EPENA                     0x80000000U            /*!< Endpoint enable */
N
N/********************  Bit definition for USB_OTG_DOEPINT register  ********************/
N#define USB_OTG_DOEPINT_XFRC                    0x00000001U            /*!< Transfer completed interrupt */
N#define USB_OTG_DOEPINT_EPDISD                  0x00000002U            /*!< Endpoint disabled interrupt */
N#define USB_OTG_DOEPINT_STUP                    0x00000008U            /*!< SETUP phase done */
N#define USB_OTG_DOEPINT_OTEPDIS                 0x00000010U            /*!< OUT token received when endpoint disabled */
N#define USB_OTG_DOEPINT_OTEPSPR                 0x00000020U            /*!< Status Phase Received For Control Write */
N#define USB_OTG_DOEPINT_B2BSTUP                 0x00000040U            /*!< Back-to-back SETUP packets received */
N#define USB_OTG_DOEPINT_NYET                    0x00004000U            /*!< NYET interrupt */
N
N/********************  Bit definition for USB_OTG_DOEPTSIZ register  ********************/
N#define USB_OTG_DOEPTSIZ_XFRSIZ                  0x0007FFFFU            /*!< Transfer size */
N#define USB_OTG_DOEPTSIZ_PKTCNT                  0x1FF80000U            /*!< Packet count */
N
N#define USB_OTG_DOEPTSIZ_STUPCNT                 0x60000000U            /*!< SETUP packet count */
N#define USB_OTG_DOEPTSIZ_STUPCNT_0               0x20000000U            /*!<Bit 0 */
N#define USB_OTG_DOEPTSIZ_STUPCNT_1               0x40000000U            /*!<Bit 1 */
N
N/********************  Bit definition for PCGCCTL register  ********************/
N#define USB_OTG_PCGCCTL_STOPCLK                 0x00000001U            /*!< SETUP packet count */
N#define USB_OTG_PCGCCTL_GATECLK                 0x00000002U            /*!<Bit 0 */
N#define USB_OTG_PCGCCTL_PHYSUSP                 0x00000010U            /*!<Bit 1 */
N
N/******************************************************************************/
N/*                                                                            */
N/*                        JPEG Encoder/Decoder                                */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for CONFR0 register  ********************/
N#define  JPEG_CONFR0_START                       0x00000001U        /*!<Start/Stop bit */  
N
N/********************  Bit definition for CONFR1 register  *******************/
N#define  JPEG_CONFR1_NF                          0x00000003U        /*!<Number of color components */  
N#define  JPEG_CONFR1_NF_0                        0x00000001U        /*!<Bit 0 */   
N#define  JPEG_CONFR1_NF_1                        0x00000002U        /*!<Bit 1 */
N#define  JPEG_CONFR1_RE                          0x00000004U        /*!<Restart maker Enable */  
N#define  JPEG_CONFR1_DE                          0x00000008U        /*!<Decoding Enable */  
N#define  JPEG_CONFR1_COLORSPACE                  0x00000030U        /*!<Color Space */  
N#define  JPEG_CONFR1_COLORSPACE_0                0x00000010U        /*!<Bit 0 */  
N#define  JPEG_CONFR1_COLORSPACE_1                0x00000020U        /*!<Bit 1 */  
N#define  JPEG_CONFR1_NS                          0x000000C0U        /*!<Number of components for Scan */  
N#define  JPEG_CONFR1_NS_0                        0x00000040U        /*!<Bit 0 */  
N#define  JPEG_CONFR1_NS_1                        0x00000080U        /*!<Bit 1 */
N#define  JPEG_CONFR1_HDR                         0x00000100U        /*!<Header Processing On/Off */
N#define  JPEG_CONFR1_YSIZE                       0xFFFF0000U        /*!<Number of lines in source image */
N
N/********************  Bit definition for CONFR2 register  *******************/
N#define  JPEG_CONFR2_NMCU                        0x03FFFFFFU        /*!<Number of MCU units minus 1 to encode */
N
N/********************  Bit definition for CONFR3 register  *******************/
N#define  JPEG_CONFR3_NRST                        0x0000FFFFU        /*!<Number of MCU between two restart makers minus 1 */
N#define  JPEG_CONFR3_XSIZE                       0xFFFF0000U        /*!<Number of pixels per line */
N
N/********************  Bit definition for CONFR4 register  *******************/
N#define  JPEG_CONFR4_HD                          0x00000001U        /*!<Selects the Huffman table for encoding the DC coefficients */  
N#define  JPEG_CONFR4_HA                          0x00000002U        /*!<Selects the Huffman table for encoding the AC coefficients */ 
N#define  JPEG_CONFR4_QT                          0x0000000CU        /*!<Selects quantization table associated with a color component */
N#define  JPEG_CONFR4_QT_0                        0x00000004U        /*!<Bit 0 */
N#define  JPEG_CONFR4_QT_1                        0x00000008U        /*!<Bit 1 */
N#define  JPEG_CONFR4_NB                          0x000000F0U        /*!<Number of data units minus 1 that belong to a particular color in the MCU */
N#define  JPEG_CONFR4_NB_0                        0x00000010U        /*!<Bit 0 */
N#define  JPEG_CONFR4_NB_1                        0x00000020U        /*!<Bit 1 */
N#define  JPEG_CONFR4_NB_2                        0x00000040U        /*!<Bit 2 */
N#define  JPEG_CONFR4_NB_3                        0x00000080U        /*!<Bit 3 */
N#define  JPEG_CONFR4_VSF                         0x00000F00U        /*!<Vertical sampling factor for component 1 */
N#define  JPEG_CONFR4_VSF_0                       0x00000100U        /*!<Bit 0 */
N#define  JPEG_CONFR4_VSF_1                       0x00000200U        /*!<Bit 1 */
N#define  JPEG_CONFR4_VSF_2                       0x00000400U        /*!<Bit 2 */
N#define  JPEG_CONFR4_VSF_3                       0x00000800U        /*!<Bit 3 */
N#define  JPEG_CONFR4_HSF                         0x0000F000U        /*!<Horizontal sampling factor for component 1 */
N#define  JPEG_CONFR4_HSF_0                       0x00001000U        /*!<Bit 0 */
N#define  JPEG_CONFR4_HSF_1                       0x00002000U        /*!<Bit 1 */
N#define  JPEG_CONFR4_HSF_2                       0x00004000U        /*!<Bit 2 */
N#define  JPEG_CONFR4_HSF_3                       0x00008000U        /*!<Bit 3 */
N
N/********************  Bit definition for CONFR5 register  *******************/
N#define  JPEG_CONFR5_HD                          0x00000001U        /*!<Selects the Huffman table for encoding the DC coefficients */  
N#define  JPEG_CONFR5_HA                          0x00000002U        /*!<Selects the Huffman table for encoding the AC coefficients */ 
N#define  JPEG_CONFR5_QT                          0x0000000CU        /*!<Selects quantization table associated with a color component */
N#define  JPEG_CONFR5_QT_0                        0x00000004U        /*!<Bit 0 */
N#define  JPEG_CONFR5_QT_1                        0x00000008U        /*!<Bit 1 */
N#define  JPEG_CONFR5_NB                          0x000000F0U        /*!<Number of data units minus 1 that belong to a particular color in the MCU */
N#define  JPEG_CONFR5_NB_0                        0x00000010U        /*!<Bit 0 */
N#define  JPEG_CONFR5_NB_1                        0x00000020U        /*!<Bit 1 */
N#define  JPEG_CONFR5_NB_2                        0x00000040U        /*!<Bit 2 */
N#define  JPEG_CONFR5_NB_3                        0x00000080U        /*!<Bit 3 */
N#define  JPEG_CONFR5_VSF                         0x00000F00U        /*!<Vertical sampling factor for component 2 */
N#define  JPEG_CONFR5_VSF_0                       0x00000100U        /*!<Bit 0 */
N#define  JPEG_CONFR5_VSF_1                       0x00000200U        /*!<Bit 1 */
N#define  JPEG_CONFR5_VSF_2                       0x00000400U        /*!<Bit 2 */
N#define  JPEG_CONFR5_VSF_3                       0x00000800U        /*!<Bit 3 */
N#define  JPEG_CONFR5_HSF                         0x0000F000U        /*!<Horizontal sampling factor for component 2 */
N#define  JPEG_CONFR5_HSF_0                       0x00001000U        /*!<Bit 0 */
N#define  JPEG_CONFR5_HSF_1                       0x00002000U        /*!<Bit 1 */
N#define  JPEG_CONFR5_HSF_2                       0x00004000U        /*!<Bit 2 */
N#define  JPEG_CONFR5_HSF_3                       0x00008000U        /*!<Bit 3 */
N
N/********************  Bit definition for CONFR6 register  *******************/
N#define  JPEG_CONFR6_HD                          0x00000001U        /*!<Selects the Huffman table for encoding the DC coefficients */  
N#define  JPEG_CONFR6_HA                          0x00000002U        /*!<Selects the Huffman table for encoding the AC coefficients */ 
N#define  JPEG_CONFR6_QT                          0x0000000CU        /*!<Selects quantization table associated with a color component */
N#define  JPEG_CONFR6_QT_0                        0x00000004U        /*!<Bit 0 */
N#define  JPEG_CONFR6_QT_1                        0x00000008U        /*!<Bit 1 */
N#define  JPEG_CONFR6_NB                          0x000000F0U        /*!<Number of data units minus 1 that belong to a particular color in the MCU */
N#define  JPEG_CONFR6_NB_0                        0x00000010U        /*!<Bit 0 */
N#define  JPEG_CONFR6_NB_1                        0x00000020U        /*!<Bit 1 */
N#define  JPEG_CONFR6_NB_2                        0x00000040U        /*!<Bit 2 */
N#define  JPEG_CONFR6_NB_3                        0x00000080U        /*!<Bit 3 */
N#define  JPEG_CONFR6_VSF                         0x00000F00U        /*!<Vertical sampling factor for component 2 */
N#define  JPEG_CONFR6_VSF_0                       0x00000100U        /*!<Bit 0 */
N#define  JPEG_CONFR6_VSF_1                       0x00000200U        /*!<Bit 1 */
N#define  JPEG_CONFR6_VSF_2                       0x00000400U        /*!<Bit 2 */
N#define  JPEG_CONFR6_VSF_3                       0x00000800U        /*!<Bit 3 */
N#define  JPEG_CONFR6_HSF                         0x0000F000U        /*!<Horizontal sampling factor for component 2 */
N#define  JPEG_CONFR6_HSF_0                       0x00001000U        /*!<Bit 0 */
N#define  JPEG_CONFR6_HSF_1                       0x00002000U        /*!<Bit 1 */
N#define  JPEG_CONFR6_HSF_2                       0x00004000U        /*!<Bit 2 */
N#define  JPEG_CONFR6_HSF_3                       0x00008000U        /*!<Bit 3 */
N
N/********************  Bit definition for CONFR7 register  *******************/
N#define  JPEG_CONFR7_HD                          0x00000001U        /*!<Selects the Huffman table for encoding the DC coefficients */  
N#define  JPEG_CONFR7_HA                          0x00000002U        /*!<Selects the Huffman table for encoding the AC coefficients */ 
N#define  JPEG_CONFR7_QT                          0x0000000CU        /*!<Selects quantization table associated with a color component */
N#define  JPEG_CONFR7_QT_0                        0x00000004U        /*!<Bit 0 */
N#define  JPEG_CONFR7_QT_1                        0x00000008U        /*!<Bit 1 */
N#define  JPEG_CONFR7_NB                          0x000000F0U        /*!<Number of data units minus 1 that belong to a particular color in the MCU */
N#define  JPEG_CONFR7_NB_0                        0x00000010U        /*!<Bit 0 */
N#define  JPEG_CONFR7_NB_1                        0x00000020U        /*!<Bit 1 */
N#define  JPEG_CONFR7_NB_2                        0x00000040U        /*!<Bit 2 */
N#define  JPEG_CONFR7_NB_3                        0x00000080U        /*!<Bit 3 */
N#define  JPEG_CONFR7_VSF                         0x00000F00U        /*!<Vertical sampling factor for component 2 */
N#define  JPEG_CONFR7_VSF_0                       0x00000100U        /*!<Bit 0 */
N#define  JPEG_CONFR7_VSF_1                       0x00000200U        /*!<Bit 1 */
N#define  JPEG_CONFR7_VSF_2                       0x00000400U        /*!<Bit 2 */
N#define  JPEG_CONFR7_VSF_3                       0x00000800U        /*!<Bit 3 */
N#define  JPEG_CONFR7_HSF                         0x0000F000U        /*!<Horizontal sampling factor for component 2 */
N#define  JPEG_CONFR7_HSF_0                       0x00001000U        /*!<Bit 0 */
N#define  JPEG_CONFR7_HSF_1                       0x00002000U        /*!<Bit 1 */
N#define  JPEG_CONFR7_HSF_2                       0x00004000U        /*!<Bit 2 */
N#define  JPEG_CONFR7_HSF_3                       0x00008000U        /*!<Bit 3 */
N
N/********************  Bit definition for CR register  *******************/
N#define  JPEG_CR_JCEN                            0x00000001U        /*!<Enable the JPEG Codec Core */
N#define  JPEG_CR_IFTIE                           0x00000002U        /*!<Input FIFO Threshold Interrupt Enable */
N#define  JPEG_CR_IFNFIE                          0x00000004U        /*!<Input FIFO Not Full Interrupt Enable */
N#define  JPEG_CR_OFTIE                           0x00000008U        /*!<Output FIFO Threshold Interrupt Enable */
N#define  JPEG_CR_OFNEIE                          0x00000010U        /*!<Output FIFO Not Empty Interrupt Enable */
N#define  JPEG_CR_EOCIE                           0x00000020U        /*!<End of Conversion Interrupt Enable */
N#define  JPEG_CR_HPDIE                           0x00000040U        /*!<Header Parsing Done Interrupt Enable */
N#define  JPEG_CR_IDMAEN                          0x00000800U        /*!<Enable the DMA request generation for the input FIFO */
N#define  JPEG_CR_ODMAEN                          0x00001000U        /*!<Enable the DMA request generation for the output FIFO */
N#define  JPEG_CR_IFF                             0x00002000U        /*!<Flush the input FIFO */
N#define  JPEG_CR_OFF                             0x00004000U        /*!<Flush the output FIFO */
N
N/********************  Bit definition for SR register  *******************/
N#define  JPEG_SR_IFTF                            0x00000002U        /*!<Input FIFO is not full and is bellow its threshold flag */
N#define  JPEG_SR_IFNFF                           0x00000004U        /*!<Input FIFO Not Full Flag, a data can be written */
N#define  JPEG_SR_OFTF                            0x00000008U        /*!<Output FIFO is not empty and has reach its threshold */
N#define  JPEG_SR_OFNEF                           0x000000010U       /*!<Output FIFO is not empty, a data is available */
N#define  JPEG_SR_EOCF                            0x000000020U       /*!<JPEG Codec core has finished the encoding or the decoding process and than last data has been sent to the output FIFO */
N#define  JPEG_SR_HPDF                            0x000000040U       /*!<JPEG Codec has finished the parsing of the headers and the internal registers have been updated */
N#define  JPEG_SR_COF                             0x000000080U       /*!<JPEG Codec operation on going  flag */
N
N/********************  Bit definition for CFR register  *******************/
N#define  JPEG_CFR_CEOCF                          0x00000020U       /*!<Clear End of Conversion Flag */
N#define  JPEG_CFR_CHPDF                          0x00000040U       /*!<Clear Header Parsing Done Flag */
N
N/********************  Bit definition for DIR register  ********************/
N#define  JPEG_DIR_DATAIN                         0xFFFFFFFFU        /*!<Data Input FIFO */
N
N/********************  Bit definition for DOR register  ********************/
N#define  JPEG_DOR_DATAOUT                        0xFFFFFFFFU        /*!<Data Output FIFO */
N
N/******************************************************************************/
N/*                                                                            */
N/*                                MDIOS                                        */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for MDIOS_CR register  *******************/
N#define MDIOS_CR_EN               0x00000001U    /*!<Peripheral enable */
N#define MDIOS_CR_WRIE             0x00000002U    /*!<Register write interrupt enable */ 
N#define MDIOS_CR_RDIE             0x00000004U    /*!<Register Read Interrupt Enable */
N#define MDIOS_CR_EIE              0x00000008U    /*!<Error interrupt enable */
N#define MDIOS_CR_DPC              0x00000080U    /*!<Disable Preamble Check */
N#define MDIOS_CR_PORT_ADDRESS     0x00001F00U    /*!<PORT_ADDRESS[4:0] bits */
N#define MDIOS_CR_PORT_ADDRESS_0   0x00000100U    /*!<Bit 0 */
N#define MDIOS_CR_PORT_ADDRESS_1   0x00000200U    /*!<Bit 1 */
N#define MDIOS_CR_PORT_ADDRESS_2   0x00000400U    /*!<Bit 2 */
N#define MDIOS_CR_PORT_ADDRESS_3   0x00000800U    /*!<Bit 3 */
N#define MDIOS_CR_PORT_ADDRESS_4   0x00001000U    /*!<Bit 4 */
N
N/********************  Bit definition for MDIOS_WRFR register  *******************/
N#define MDIOS_WRFR_WRF            0xFFFFFFFFU    /*!<WRF[31:0] bits (Write flags for MDIO register 0 to 31) */
N
N/********************  Bit definition for MDIOS_CWRFR register  *******************/
N#define MDIOS_CWRFR_CWRF           0xFFFFFFFFU    /*!<CWRF[31:0] bits (Clear the write flag for MDIO register 0 to 31) */
N
N/********************  Bit definition for MDIOS_RDFR register  *******************/
N#define MDIOS_RDFR_RDF           0xFFFFFFFFU      /*!<RDF[31:0] bits (Read flags for MDIO registers 0 to 31) */
N
N/********************  Bit definition for MDIOS_CRDFR register  *******************/
N#define MDIOS_CRDFR_CRDF          0xFFFFFFFFU      /*!<CRDF[31:0] bits (Clear the read flag for MDIO registers 0 to 31) */
N
N/********************  Bit definition for MDIOS_SR register  *******************/
N#define MDIOS_SR_PERF             0x00000001U    /*!< Preamble error flag */
N#define MDIOS_SR_SERF             0x00000002U    /*!< Start error flag */
N#define MDIOS_SR_TERF             0x00000004U    /*!< Turnaround error flag */
N
N/********************  Bit definition for MDIOS_CLRFR register  *******************/
N#define MDIOS_CLRFR_CPERF             0x00000001U    /*!< Clear the preamble error flag */
N#define MDIOS_CLRFR_CSERF             0x00000002U    /*!< Clear the start error flag */
N#define MDIOS_CLRFR_CTERF             0x00000004U    /*!< Clear the turnaround error flag */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/** @addtogroup Exported_macros
N  * @{
N  */
N
N/******************************* ADC Instances ********************************/
N#define IS_ADC_ALL_INSTANCE(__INSTANCE__) (((__INSTANCE__) == ADC1) || \
N                                       ((__INSTANCE__) == ADC2) || \
N                                       ((__INSTANCE__) == ADC3))
X#define IS_ADC_ALL_INSTANCE(__INSTANCE__) (((__INSTANCE__) == ADC1) ||                                        ((__INSTANCE__) == ADC2) ||                                        ((__INSTANCE__) == ADC3))
N
N/******************************* CAN Instances ********************************/
N#define IS_CAN_ALL_INSTANCE(__INSTANCE__) (((__INSTANCE__) == CAN1) || \
N                                           ((__INSTANCE__) == CAN2) || \
N									       ((__INSTANCE__) == CAN3))
X#define IS_CAN_ALL_INSTANCE(__INSTANCE__) (((__INSTANCE__) == CAN1) ||                                            ((__INSTANCE__) == CAN2) || 									       ((__INSTANCE__) == CAN3))
N/******************************* CRC Instances ********************************/
N#define IS_CRC_ALL_INSTANCE(__INSTANCE__) ((__INSTANCE__) == CRC)
N
N/******************************* DAC Instances ********************************/
N#define IS_DAC_ALL_INSTANCE(__INSTANCE__) ((__INSTANCE__) == DAC)
N
N/******************************* DCMI Instances *******************************/
N#define IS_DCMI_ALL_INSTANCE(__INSTANCE__) ((__INSTANCE__) == DCMI)
N
N/****************************** DFSDM Instances *******************************/
N#define IS_DFSDM_FILTER_ALL_INSTANCE(INSTANCE) (((INSTANCE) == DFSDM1_Filter0) || \
N                                                ((INSTANCE) == DFSDM1_Filter1) || \
N                                                ((INSTANCE) == DFSDM1_Filter2) || \
N                                                ((INSTANCE) == DFSDM1_Filter3))
X#define IS_DFSDM_FILTER_ALL_INSTANCE(INSTANCE) (((INSTANCE) == DFSDM1_Filter0) ||                                                 ((INSTANCE) == DFSDM1_Filter1) ||                                                 ((INSTANCE) == DFSDM1_Filter2) ||                                                 ((INSTANCE) == DFSDM1_Filter3))
N
N#define IS_DFSDM_CHANNEL_ALL_INSTANCE(INSTANCE) (((INSTANCE) == DFSDM1_Channel0) || \
N                                                 ((INSTANCE) == DFSDM1_Channel1) || \
N                                                 ((INSTANCE) == DFSDM1_Channel2) || \
N                                                 ((INSTANCE) == DFSDM1_Channel3) || \
N                                                 ((INSTANCE) == DFSDM1_Channel4) || \
N                                                 ((INSTANCE) == DFSDM1_Channel5) || \
N                                                 ((INSTANCE) == DFSDM1_Channel6) || \
N                                                 ((INSTANCE) == DFSDM1_Channel7))
X#define IS_DFSDM_CHANNEL_ALL_INSTANCE(INSTANCE) (((INSTANCE) == DFSDM1_Channel0) ||                                                  ((INSTANCE) == DFSDM1_Channel1) ||                                                  ((INSTANCE) == DFSDM1_Channel2) ||                                                  ((INSTANCE) == DFSDM1_Channel3) ||                                                  ((INSTANCE) == DFSDM1_Channel4) ||                                                  ((INSTANCE) == DFSDM1_Channel5) ||                                                  ((INSTANCE) == DFSDM1_Channel6) ||                                                  ((INSTANCE) == DFSDM1_Channel7))
N
N/******************************* DMA2D Instances *******************************/
N#define IS_DMA2D_ALL_INSTANCE(__INSTANCE__) ((__INSTANCE__) == DMA2D)
N
N/******************************** DMA Instances *******************************/
N#define IS_DMA_STREAM_ALL_INSTANCE(__INSTANCE__) (((__INSTANCE__) == DMA1_Stream0) || \
N                                              ((__INSTANCE__) == DMA1_Stream1) || \
N                                              ((__INSTANCE__) == DMA1_Stream2) || \
N                                              ((__INSTANCE__) == DMA1_Stream3) || \
N                                              ((__INSTANCE__) == DMA1_Stream4) || \
N                                              ((__INSTANCE__) == DMA1_Stream5) || \
N                                              ((__INSTANCE__) == DMA1_Stream6) || \
N                                              ((__INSTANCE__) == DMA1_Stream7) || \
N                                              ((__INSTANCE__) == DMA2_Stream0) || \
N                                              ((__INSTANCE__) == DMA2_Stream1) || \
N                                              ((__INSTANCE__) == DMA2_Stream2) || \
N                                              ((__INSTANCE__) == DMA2_Stream3) || \
N                                              ((__INSTANCE__) == DMA2_Stream4) || \
N                                              ((__INSTANCE__) == DMA2_Stream5) || \
N                                              ((__INSTANCE__) == DMA2_Stream6) || \
N                                              ((__INSTANCE__) == DMA2_Stream7))
X#define IS_DMA_STREAM_ALL_INSTANCE(__INSTANCE__) (((__INSTANCE__) == DMA1_Stream0) ||                                               ((__INSTANCE__) == DMA1_Stream1) ||                                               ((__INSTANCE__) == DMA1_Stream2) ||                                               ((__INSTANCE__) == DMA1_Stream3) ||                                               ((__INSTANCE__) == DMA1_Stream4) ||                                               ((__INSTANCE__) == DMA1_Stream5) ||                                               ((__INSTANCE__) == DMA1_Stream6) ||                                               ((__INSTANCE__) == DMA1_Stream7) ||                                               ((__INSTANCE__) == DMA2_Stream0) ||                                               ((__INSTANCE__) == DMA2_Stream1) ||                                               ((__INSTANCE__) == DMA2_Stream2) ||                                               ((__INSTANCE__) == DMA2_Stream3) ||                                               ((__INSTANCE__) == DMA2_Stream4) ||                                               ((__INSTANCE__) == DMA2_Stream5) ||                                               ((__INSTANCE__) == DMA2_Stream6) ||                                               ((__INSTANCE__) == DMA2_Stream7))
N
N/******************************* GPIO Instances *******************************/
N#define IS_GPIO_ALL_INSTANCE(__INSTANCE__) (((__INSTANCE__) == GPIOA) || \
N                                        ((__INSTANCE__) == GPIOB) || \
N                                        ((__INSTANCE__) == GPIOC) || \
N                                        ((__INSTANCE__) == GPIOD) || \
N                                        ((__INSTANCE__) == GPIOE) || \
N                                        ((__INSTANCE__) == GPIOF) || \
N                                        ((__INSTANCE__) == GPIOG) || \
N                                        ((__INSTANCE__) == GPIOH) || \
N                                        ((__INSTANCE__) == GPIOI) || \
N                                        ((__INSTANCE__) == GPIOJ) || \
N                                        ((__INSTANCE__) == GPIOK))
X#define IS_GPIO_ALL_INSTANCE(__INSTANCE__) (((__INSTANCE__) == GPIOA) ||                                         ((__INSTANCE__) == GPIOB) ||                                         ((__INSTANCE__) == GPIOC) ||                                         ((__INSTANCE__) == GPIOD) ||                                         ((__INSTANCE__) == GPIOE) ||                                         ((__INSTANCE__) == GPIOF) ||                                         ((__INSTANCE__) == GPIOG) ||                                         ((__INSTANCE__) == GPIOH) ||                                         ((__INSTANCE__) == GPIOI) ||                                         ((__INSTANCE__) == GPIOJ) ||                                         ((__INSTANCE__) == GPIOK))
N										
N#define IS_GPIO_AF_INSTANCE(__INSTANCE__)   (((__INSTANCE__) == GPIOA) || \
N                                        ((__INSTANCE__) == GPIOB) || \
N                                        ((__INSTANCE__) == GPIOC) || \
N                                        ((__INSTANCE__) == GPIOD) || \
N                                        ((__INSTANCE__) == GPIOE) || \
N                                        ((__INSTANCE__) == GPIOF) || \
N                                        ((__INSTANCE__) == GPIOG) || \
N                                        ((__INSTANCE__) == GPIOH) || \
N                                        ((__INSTANCE__) == GPIOI) || \
N                                        ((__INSTANCE__) == GPIOJ) || \
N                                        ((__INSTANCE__) == GPIOK))
X#define IS_GPIO_AF_INSTANCE(__INSTANCE__)   (((__INSTANCE__) == GPIOA) ||                                         ((__INSTANCE__) == GPIOB) ||                                         ((__INSTANCE__) == GPIOC) ||                                         ((__INSTANCE__) == GPIOD) ||                                         ((__INSTANCE__) == GPIOE) ||                                         ((__INSTANCE__) == GPIOF) ||                                         ((__INSTANCE__) == GPIOG) ||                                         ((__INSTANCE__) == GPIOH) ||                                         ((__INSTANCE__) == GPIOI) ||                                         ((__INSTANCE__) == GPIOJ) ||                                         ((__INSTANCE__) == GPIOK))
N
N/****************************** CEC Instances *********************************/
N#define IS_CEC_ALL_INSTANCE(__INSTANCE__) ((__INSTANCE__) == CEC)
N
N/****************************** QSPI Instances *********************************/
N#define IS_QSPI_ALL_INSTANCE(__INSTANCE__) ((__INSTANCE__) == QUADSPI)
N
N                                        
N/******************************** I2C Instances *******************************/
N#define IS_I2C_ALL_INSTANCE(__INSTANCE__) (((__INSTANCE__) == I2C1) || \
N                                       ((__INSTANCE__) == I2C2) || \
N                                       ((__INSTANCE__) == I2C3) || \
N                                       ((__INSTANCE__) == I2C4))
X#define IS_I2C_ALL_INSTANCE(__INSTANCE__) (((__INSTANCE__) == I2C1) ||                                        ((__INSTANCE__) == I2C2) ||                                        ((__INSTANCE__) == I2C3) ||                                        ((__INSTANCE__) == I2C4))
N
N/******************************** I2S Instances *******************************/
N#define IS_I2S_ALL_INSTANCE(__INSTANCE__)  (((__INSTANCE__) == SPI1) || \
N                                    ((__INSTANCE__) == SPI2) || \
N                                    ((__INSTANCE__) == SPI3))
X#define IS_I2S_ALL_INSTANCE(__INSTANCE__)  (((__INSTANCE__) == SPI1) ||                                     ((__INSTANCE__) == SPI2) ||                                     ((__INSTANCE__) == SPI3))
N
N/******************************* LPTIM Instances ********************************/
N#define IS_LPTIM_INSTANCE(__INSTANCE__) ((__INSTANCE__) == LPTIM1)
N
N/****************************** LTDC Instances ********************************/
N#define IS_LTDC_ALL_INSTANCE(__INSTANCE__)  ((__INSTANCE__) == LTDC)
N
N/****************************** MDIOS Instances ********************************/
N#define IS_MDIOS_ALL_INSTANCE(__INSTANCE__)  ((__INSTANCE__) == MDIOS)
N
N/****************************** MDIOS Instances ********************************/
N#define IS_JPEG_ALL_INSTANCE(__INSTANCE__)  ((__INSTANCE__) == JPEG)
N
N/******************************* RNG Instances ********************************/
N#define IS_RNG_ALL_INSTANCE(__INSTANCE__)  ((__INSTANCE__) == RNG)
N
N/****************************** RTC Instances *********************************/
N#define IS_RTC_ALL_INSTANCE(__INSTANCE__)  ((__INSTANCE__) == RTC)
N
N/******************************* SAI Instances ********************************/
N#define IS_SAI_ALL_INSTANCE(__PERIPH__) (((__PERIPH__) == SAI1_Block_A) || \
N                                         ((__PERIPH__) == SAI1_Block_B) || \
N                                         ((__PERIPH__) == SAI2_Block_A) || \
N                                         ((__PERIPH__) == SAI2_Block_B))
X#define IS_SAI_ALL_INSTANCE(__PERIPH__) (((__PERIPH__) == SAI1_Block_A) ||                                          ((__PERIPH__) == SAI1_Block_B) ||                                          ((__PERIPH__) == SAI2_Block_A) ||                                          ((__PERIPH__) == SAI2_Block_B))
N/* Legacy define */
N#define IS_SAI_BLOCK_PERIPH IS_SAI_ALL_INSTANCE
N
N/******************************** SDMMC Instances *******************************/
N#define IS_SDMMC_ALL_INSTANCE(__INSTANCE__) (((__INSTANCE__) == SDMMC1) || \
N                                             ((__INSTANCE__) == SDMMC2))
X#define IS_SDMMC_ALL_INSTANCE(__INSTANCE__) (((__INSTANCE__) == SDMMC1) ||                                              ((__INSTANCE__) == SDMMC2))
N
N/****************************** SPDIFRX Instances *********************************/
N#define IS_SPDIFRX_ALL_INSTANCE(__INSTANCE__) ((__INSTANCE__) == SPDIFRX)
N                                     
N/******************************** SPI Instances *******************************/
N#define IS_SPI_ALL_INSTANCE(__INSTANCE__) (((__INSTANCE__) == SPI1) || \
N                                       ((__INSTANCE__) == SPI2) || \
N                                       ((__INSTANCE__) == SPI3) || \
N                                       ((__INSTANCE__) == SPI4) || \
N                                       ((__INSTANCE__) == SPI5) || \
N                                       ((__INSTANCE__) == SPI6))
X#define IS_SPI_ALL_INSTANCE(__INSTANCE__) (((__INSTANCE__) == SPI1) ||                                        ((__INSTANCE__) == SPI2) ||                                        ((__INSTANCE__) == SPI3) ||                                        ((__INSTANCE__) == SPI4) ||                                        ((__INSTANCE__) == SPI5) ||                                        ((__INSTANCE__) == SPI6))
N
N/****************** TIM Instances : All supported instances *******************/
N#define IS_TIM_INSTANCE(__INSTANCE__) (((__INSTANCE__) == TIM1)   || \
N                                   ((__INSTANCE__) == TIM2)   || \
N                                   ((__INSTANCE__) == TIM3)   || \
N                                   ((__INSTANCE__) == TIM4)   || \
N                                   ((__INSTANCE__) == TIM5)   || \
N                                   ((__INSTANCE__) == TIM6)   || \
N                                   ((__INSTANCE__) == TIM7)   || \
N                                   ((__INSTANCE__) == TIM8)   || \
N                                   ((__INSTANCE__) == TIM9)   || \
N                                   ((__INSTANCE__) == TIM10)  || \
N                                   ((__INSTANCE__) == TIM11)  || \
N                                   ((__INSTANCE__) == TIM12)  || \
N                                   ((__INSTANCE__) == TIM13)  || \
N                                   ((__INSTANCE__) == TIM14))
X#define IS_TIM_INSTANCE(__INSTANCE__) (((__INSTANCE__) == TIM1)   ||                                    ((__INSTANCE__) == TIM2)   ||                                    ((__INSTANCE__) == TIM3)   ||                                    ((__INSTANCE__) == TIM4)   ||                                    ((__INSTANCE__) == TIM5)   ||                                    ((__INSTANCE__) == TIM6)   ||                                    ((__INSTANCE__) == TIM7)   ||                                    ((__INSTANCE__) == TIM8)   ||                                    ((__INSTANCE__) == TIM9)   ||                                    ((__INSTANCE__) == TIM10)  ||                                    ((__INSTANCE__) == TIM11)  ||                                    ((__INSTANCE__) == TIM12)  ||                                    ((__INSTANCE__) == TIM13)  ||                                    ((__INSTANCE__) == TIM14))
N
N/************* TIM Instances : at least 1 capture/compare channel *************/
N#define IS_TIM_CC1_INSTANCE(__INSTANCE__)   (((__INSTANCE__) == TIM1)  || \
N                                         ((__INSTANCE__) == TIM2)  || \
N                                         ((__INSTANCE__) == TIM3)  || \
N                                         ((__INSTANCE__) == TIM4)  || \
N                                         ((__INSTANCE__) == TIM5)  || \
N                                         ((__INSTANCE__) == TIM8)  || \
N                                         ((__INSTANCE__) == TIM9)  || \
N                                         ((__INSTANCE__) == TIM10) || \
N                                         ((__INSTANCE__) == TIM11) || \
N                                         ((__INSTANCE__) == TIM12) || \
N                                         ((__INSTANCE__) == TIM13) || \
N                                         ((__INSTANCE__) == TIM14))
X#define IS_TIM_CC1_INSTANCE(__INSTANCE__)   (((__INSTANCE__) == TIM1)  ||                                          ((__INSTANCE__) == TIM2)  ||                                          ((__INSTANCE__) == TIM3)  ||                                          ((__INSTANCE__) == TIM4)  ||                                          ((__INSTANCE__) == TIM5)  ||                                          ((__INSTANCE__) == TIM8)  ||                                          ((__INSTANCE__) == TIM9)  ||                                          ((__INSTANCE__) == TIM10) ||                                          ((__INSTANCE__) == TIM11) ||                                          ((__INSTANCE__) == TIM12) ||                                          ((__INSTANCE__) == TIM13) ||                                          ((__INSTANCE__) == TIM14))
N
N/************ TIM Instances : at least 2 capture/compare channels *************/
N#define IS_TIM_CC2_INSTANCE(__INSTANCE__)   (((__INSTANCE__) == TIM1)  || \
N                                         ((__INSTANCE__) == TIM2)  || \
N                                         ((__INSTANCE__) == TIM3)  || \
N                                         ((__INSTANCE__) == TIM4)  || \
N                                         ((__INSTANCE__) == TIM5)  || \
N                                         ((__INSTANCE__) == TIM8)  || \
N                                         ((__INSTANCE__) == TIM9)  || \
N                                         ((__INSTANCE__) == TIM12))
X#define IS_TIM_CC2_INSTANCE(__INSTANCE__)   (((__INSTANCE__) == TIM1)  ||                                          ((__INSTANCE__) == TIM2)  ||                                          ((__INSTANCE__) == TIM3)  ||                                          ((__INSTANCE__) == TIM4)  ||                                          ((__INSTANCE__) == TIM5)  ||                                          ((__INSTANCE__) == TIM8)  ||                                          ((__INSTANCE__) == TIM9)  ||                                          ((__INSTANCE__) == TIM12))
N
N/************ TIM Instances : at least 3 capture/compare channels *************/
N#define IS_TIM_CC3_INSTANCE(__INSTANCE__)   (((__INSTANCE__) == TIM1) || \
N                                         ((__INSTANCE__) == TIM2) || \
N                                         ((__INSTANCE__) == TIM3) || \
N                                         ((__INSTANCE__) == TIM4) || \
N                                         ((__INSTANCE__) == TIM5) || \
N                                         ((__INSTANCE__) == TIM8))
X#define IS_TIM_CC3_INSTANCE(__INSTANCE__)   (((__INSTANCE__) == TIM1) ||                                          ((__INSTANCE__) == TIM2) ||                                          ((__INSTANCE__) == TIM3) ||                                          ((__INSTANCE__) == TIM4) ||                                          ((__INSTANCE__) == TIM5) ||                                          ((__INSTANCE__) == TIM8))
N
N/************ TIM Instances : at least 4 capture/compare channels *************/
N#define IS_TIM_CC4_INSTANCE(__INSTANCE__) (((__INSTANCE__) == TIM1) || \
N                                       ((__INSTANCE__) == TIM2) || \
N                                       ((__INSTANCE__) == TIM3) || \
N                                       ((__INSTANCE__) == TIM4) || \
N                                       ((__INSTANCE__) == TIM5) || \
N                                       ((__INSTANCE__) == TIM8))
X#define IS_TIM_CC4_INSTANCE(__INSTANCE__) (((__INSTANCE__) == TIM1) ||                                        ((__INSTANCE__) == TIM2) ||                                        ((__INSTANCE__) == TIM3) ||                                        ((__INSTANCE__) == TIM4) ||                                        ((__INSTANCE__) == TIM5) ||                                        ((__INSTANCE__) == TIM8))
N                                       
N/****************** TIM Instances : supporting combined 3-phase PWM mode ******/
N#define IS_TIM_COMBINED3PHASEPWM_INSTANCE(__INSTANCE__) \
N                                       (((__INSTANCE__) == TIM1)    || \
N                                        ((__INSTANCE__) == TIM8))
X#define IS_TIM_COMBINED3PHASEPWM_INSTANCE(__INSTANCE__)                                        (((__INSTANCE__) == TIM1)    ||                                         ((__INSTANCE__) == TIM8))
N
N/****************** TIM Instances : supporting OCxREF clear *******************/
N#define IS_TIM_OCXREF_CLEAR_INSTANCE(__INSTANCE__)\
N                                  (((__INSTANCE__) == TIM1)    || \
N                                   ((__INSTANCE__) == TIM2)    || \
N                                   ((__INSTANCE__) == TIM3)    || \
N                                   ((__INSTANCE__) == TIM4)    || \
N                                   ((__INSTANCE__) == TIM8))
X#define IS_TIM_OCXREF_CLEAR_INSTANCE(__INSTANCE__)                                  (((__INSTANCE__) == TIM1)    ||                                    ((__INSTANCE__) == TIM2)    ||                                    ((__INSTANCE__) == TIM3)    ||                                    ((__INSTANCE__) == TIM4)    ||                                    ((__INSTANCE__) == TIM8))
N
N/****************** TIM Instances : supporting external clock mode 1 for TIX inputs*/
N#define IS_TIM_CLOCKSOURCE_TIX_INSTANCE(__INSTANCE__)\
N                                                 (((__INSTANCE__) == TIM1)    || \
N                                                  ((__INSTANCE__) == TIM2)    || \
N                                                  ((__INSTANCE__) == TIM3)    || \
N                                                  ((__INSTANCE__) == TIM4)    || \
N                                                  ((__INSTANCE__) == TIM5)    || \
N                                                  ((__INSTANCE__) == TIM8))
X#define IS_TIM_CLOCKSOURCE_TIX_INSTANCE(__INSTANCE__)                                                 (((__INSTANCE__) == TIM1)    ||                                                   ((__INSTANCE__) == TIM2)    ||                                                   ((__INSTANCE__) == TIM3)    ||                                                   ((__INSTANCE__) == TIM4)    ||                                                   ((__INSTANCE__) == TIM5)    ||                                                   ((__INSTANCE__) == TIM8))
N 
N/****************** TIM Instances : supporting internal trigger inputs(ITRX) *******/
N#define IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(__INSTANCE__)\
N                                                   (((__INSTANCE__) == TIM1)    || \
N                                                    ((__INSTANCE__) == TIM2)    || \
N                                                    ((__INSTANCE__) == TIM3)    || \
N                                                    ((__INSTANCE__) == TIM4)    || \
N                                                    ((__INSTANCE__) == TIM5)    || \
N                                                    ((__INSTANCE__) == TIM8))
X#define IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(__INSTANCE__)                                                   (((__INSTANCE__) == TIM1)    ||                                                     ((__INSTANCE__) == TIM2)    ||                                                     ((__INSTANCE__) == TIM3)    ||                                                     ((__INSTANCE__) == TIM4)    ||                                                     ((__INSTANCE__) == TIM5)    ||                                                     ((__INSTANCE__) == TIM8))
N/****************** TIM Instances : at least 5 capture/compare channels *******/
N#define IS_TIM_CC5_INSTANCE(__INSTANCE__)\
N  (((__INSTANCE__) == TIM1)    || \
N   ((__INSTANCE__) == TIM8) )
X#define IS_TIM_CC5_INSTANCE(__INSTANCE__)  (((__INSTANCE__) == TIM1)    ||    ((__INSTANCE__) == TIM8) )
N
N/****************** TIM Instances : at least 6 capture/compare channels *******/
N#define IS_TIM_CC6_INSTANCE(__INSTANCE__)\
N  (((__INSTANCE__) == TIM1)    || \
N   ((__INSTANCE__) == TIM8))
X#define IS_TIM_CC6_INSTANCE(__INSTANCE__)  (((__INSTANCE__) == TIM1)    ||    ((__INSTANCE__) == TIM8))
N
N                                       
N/******************** TIM Instances : Advanced-control timers *****************/
N#define IS_TIM_ADVANCED_INSTANCE(__INSTANCE__) (((__INSTANCE__) == TIM1) || \
N                                            ((__INSTANCE__) == TIM8))
X#define IS_TIM_ADVANCED_INSTANCE(__INSTANCE__) (((__INSTANCE__) == TIM1) ||                                             ((__INSTANCE__) == TIM8))
N
N/****************** TIM Instances : supporting 2 break inputs *****************/
N#define IS_TIM_BREAK_INSTANCE(__INSTANCE__)\
N  (((__INSTANCE__) == TIM1)    || \
N   ((__INSTANCE__) == TIM8))
X#define IS_TIM_BREAK_INSTANCE(__INSTANCE__)  (((__INSTANCE__) == TIM1)    ||    ((__INSTANCE__) == TIM8))
N   
N/******************* TIM Instances : Timer input XOR function *****************/
N#define IS_TIM_XOR_INSTANCE(__INSTANCE__)   (((__INSTANCE__) == TIM1) || \
N                                         ((__INSTANCE__) == TIM2) || \
N                                         ((__INSTANCE__) == TIM3) || \
N                                         ((__INSTANCE__) == TIM4) || \
N                                         ((__INSTANCE__) == TIM5) || \
N                                         ((__INSTANCE__) == TIM8))
X#define IS_TIM_XOR_INSTANCE(__INSTANCE__)   (((__INSTANCE__) == TIM1) ||                                          ((__INSTANCE__) == TIM2) ||                                          ((__INSTANCE__) == TIM3) ||                                          ((__INSTANCE__) == TIM4) ||                                          ((__INSTANCE__) == TIM5) ||                                          ((__INSTANCE__) == TIM8))
N
N/****************** TIM Instances : DMA requests generation (UDE) *************/
N#define IS_TIM_DMA_INSTANCE(__INSTANCE__) (((__INSTANCE__) == TIM1) || \
N                                       ((__INSTANCE__) == TIM2) || \
N                                       ((__INSTANCE__) == TIM3) || \
N                                       ((__INSTANCE__) == TIM4) || \
N                                       ((__INSTANCE__) == TIM5) || \
N                                       ((__INSTANCE__) == TIM6) || \
N                                       ((__INSTANCE__) == TIM7) || \
N                                       ((__INSTANCE__) == TIM8))
X#define IS_TIM_DMA_INSTANCE(__INSTANCE__) (((__INSTANCE__) == TIM1) ||                                        ((__INSTANCE__) == TIM2) ||                                        ((__INSTANCE__) == TIM3) ||                                        ((__INSTANCE__) == TIM4) ||                                        ((__INSTANCE__) == TIM5) ||                                        ((__INSTANCE__) == TIM6) ||                                        ((__INSTANCE__) == TIM7) ||                                        ((__INSTANCE__) == TIM8))
N
N/************ TIM Instances : DMA requests generation (CCxDE) *****************/
N#define IS_TIM_DMA_CC_INSTANCE(__INSTANCE__) (((__INSTANCE__) == TIM1) || \
N                                          ((__INSTANCE__) == TIM2) || \
N                                          ((__INSTANCE__) == TIM3) || \
N                                          ((__INSTANCE__) == TIM4) || \
N                                          ((__INSTANCE__) == TIM5) || \
N                                          ((__INSTANCE__) == TIM8))
X#define IS_TIM_DMA_CC_INSTANCE(__INSTANCE__) (((__INSTANCE__) == TIM1) ||                                           ((__INSTANCE__) == TIM2) ||                                           ((__INSTANCE__) == TIM3) ||                                           ((__INSTANCE__) == TIM4) ||                                           ((__INSTANCE__) == TIM5) ||                                           ((__INSTANCE__) == TIM8))
N
N/************ TIM Instances : DMA requests generation (COMDE) *****************/
N#define IS_TIM_CCDMA_INSTANCE(__INSTANCE__)  (((__INSTANCE__) == TIM1) || \
N                                          ((__INSTANCE__) == TIM2) || \
N                                          ((__INSTANCE__) == TIM3) || \
N                                          ((__INSTANCE__) == TIM4) || \
N                                          ((__INSTANCE__) == TIM5) || \
N                                          ((__INSTANCE__) == TIM8)) 
X#define IS_TIM_CCDMA_INSTANCE(__INSTANCE__)  (((__INSTANCE__) == TIM1) ||                                           ((__INSTANCE__) == TIM2) ||                                           ((__INSTANCE__) == TIM3) ||                                           ((__INSTANCE__) == TIM4) ||                                           ((__INSTANCE__) == TIM5) ||                                           ((__INSTANCE__) == TIM8)) 
N
N/******************** TIM Instances : DMA burst feature ***********************/
N#define IS_TIM_DMABURST_INSTANCE(__INSTANCE__)  (((__INSTANCE__) == TIM1) || \
N                                             ((__INSTANCE__) == TIM2) || \
N                                             ((__INSTANCE__) == TIM3) || \
N                                             ((__INSTANCE__) == TIM4) || \
N                                             ((__INSTANCE__) == TIM5) || \
N                                             ((__INSTANCE__) == TIM8))
X#define IS_TIM_DMABURST_INSTANCE(__INSTANCE__)  (((__INSTANCE__) == TIM1) ||                                              ((__INSTANCE__) == TIM2) ||                                              ((__INSTANCE__) == TIM3) ||                                              ((__INSTANCE__) == TIM4) ||                                              ((__INSTANCE__) == TIM5) ||                                              ((__INSTANCE__) == TIM8))
N
N/****** TIM Instances : master mode available (TIMx_CR2.MMS available )********/
N#define IS_TIM_MASTER_INSTANCE(__INSTANCE__) (((__INSTANCE__) == TIM1) || \
N                                          ((__INSTANCE__) == TIM2) || \
N                                          ((__INSTANCE__) == TIM3) || \
N                                          ((__INSTANCE__) == TIM4) || \
N                                          ((__INSTANCE__) == TIM5) || \
N                                          ((__INSTANCE__) == TIM6) || \
N                                          ((__INSTANCE__) == TIM7) || \
N                                          ((__INSTANCE__) == TIM8) || \
N                                          ((__INSTANCE__) == TIM13) || \
N                                          ((__INSTANCE__) == TIM14))
X#define IS_TIM_MASTER_INSTANCE(__INSTANCE__) (((__INSTANCE__) == TIM1) ||                                           ((__INSTANCE__) == TIM2) ||                                           ((__INSTANCE__) == TIM3) ||                                           ((__INSTANCE__) == TIM4) ||                                           ((__INSTANCE__) == TIM5) ||                                           ((__INSTANCE__) == TIM6) ||                                           ((__INSTANCE__) == TIM7) ||                                           ((__INSTANCE__) == TIM8) ||                                           ((__INSTANCE__) == TIM13) ||                                           ((__INSTANCE__) == TIM14))
N
N/*********** TIM Instances : Slave mode available (TIMx_SMCR available )*******/
N#define IS_TIM_SLAVE_INSTANCE(__INSTANCE__) (((__INSTANCE__) == TIM1) || \
N                                         ((__INSTANCE__) == TIM2) || \
N                                         ((__INSTANCE__) == TIM3) || \
N                                         ((__INSTANCE__) == TIM4) || \
N                                         ((__INSTANCE__) == TIM5) || \
N                                         ((__INSTANCE__) == TIM8) || \
N                                         ((__INSTANCE__) == TIM9) || \
N                                         ((__INSTANCE__) == TIM12))
X#define IS_TIM_SLAVE_INSTANCE(__INSTANCE__) (((__INSTANCE__) == TIM1) ||                                          ((__INSTANCE__) == TIM2) ||                                          ((__INSTANCE__) == TIM3) ||                                          ((__INSTANCE__) == TIM4) ||                                          ((__INSTANCE__) == TIM5) ||                                          ((__INSTANCE__) == TIM8) ||                                          ((__INSTANCE__) == TIM9) ||                                          ((__INSTANCE__) == TIM12))
N
N/********************** TIM Instances : 32 bit Counter ************************/
N#define IS_TIM_32B_COUNTER_INSTANCE(__INSTANCE__)(((__INSTANCE__) == TIM2) || \
N                                              ((__INSTANCE__) == TIM5))
X#define IS_TIM_32B_COUNTER_INSTANCE(__INSTANCE__)(((__INSTANCE__) == TIM2) ||                                               ((__INSTANCE__) == TIM5))
N
N/***************** TIM Instances : external trigger input available ************/
N#define IS_TIM_ETR_INSTANCE(__INSTANCE__)  (((__INSTANCE__) == TIM1) || \
N                                        ((__INSTANCE__) == TIM2) || \
N                                        ((__INSTANCE__) == TIM3) || \
N                                        ((__INSTANCE__) == TIM4) || \
N                                        ((__INSTANCE__) == TIM5) || \
N                                        ((__INSTANCE__) == TIM8))
X#define IS_TIM_ETR_INSTANCE(__INSTANCE__)  (((__INSTANCE__) == TIM1) ||                                         ((__INSTANCE__) == TIM2) ||                                         ((__INSTANCE__) == TIM3) ||                                         ((__INSTANCE__) == TIM4) ||                                         ((__INSTANCE__) == TIM5) ||                                         ((__INSTANCE__) == TIM8))
N
N/****************** TIM Instances : remapping capability **********************/
N#define IS_TIM_REMAP_INSTANCE(__INSTANCE__) (((__INSTANCE__) == TIM2)  || \
N                                         ((__INSTANCE__) == TIM5)  || \
N                                         ((__INSTANCE__) == TIM11))
X#define IS_TIM_REMAP_INSTANCE(__INSTANCE__) (((__INSTANCE__) == TIM2)  ||                                          ((__INSTANCE__) == TIM5)  ||                                          ((__INSTANCE__) == TIM11))
N
N/******************* TIM Instances : output(s) available **********************/
N#define IS_TIM_CCX_INSTANCE(__INSTANCE__, __CHANNEL__) \
N    ((((__INSTANCE__) == TIM1) &&                  \
N     (((__CHANNEL__) == TIM_CHANNEL_1) ||          \
N      ((__CHANNEL__) == TIM_CHANNEL_2) ||          \
N      ((__CHANNEL__) == TIM_CHANNEL_3) ||          \
N      ((__CHANNEL__) == TIM_CHANNEL_4)))           \
N    ||                                         \
N    (((__INSTANCE__) == TIM2) &&                   \
N     (((__CHANNEL__) == TIM_CHANNEL_1) ||          \
N      ((__CHANNEL__) == TIM_CHANNEL_2) ||          \
N      ((__CHANNEL__) == TIM_CHANNEL_3) ||          \
N      ((__CHANNEL__) == TIM_CHANNEL_4)))           \
N    ||                                         \
N    (((__INSTANCE__) == TIM3) &&                   \
N     (((__CHANNEL__) == TIM_CHANNEL_1) ||          \
N      ((__CHANNEL__) == TIM_CHANNEL_2) ||          \
N      ((__CHANNEL__) == TIM_CHANNEL_3) ||          \
N      ((__CHANNEL__) == TIM_CHANNEL_4)))           \
N    ||                                         \
N    (((__INSTANCE__) == TIM4) &&                   \
N     (((__CHANNEL__) == TIM_CHANNEL_1) ||          \
N      ((__CHANNEL__) == TIM_CHANNEL_2) ||          \
N      ((__CHANNEL__) == TIM_CHANNEL_3) ||          \
N      ((__CHANNEL__) == TIM_CHANNEL_4)))           \
N    ||                                         \
N    (((__INSTANCE__) == TIM5) &&                   \
N     (((__CHANNEL__) == TIM_CHANNEL_1) ||          \
N      ((__CHANNEL__) == TIM_CHANNEL_2) ||          \
N      ((__CHANNEL__) == TIM_CHANNEL_3) ||          \
N      ((__CHANNEL__) == TIM_CHANNEL_4)))           \
N    ||                                         \
N    (((__INSTANCE__) == TIM8) &&                   \
N     (((__CHANNEL__) == TIM_CHANNEL_1) ||          \
N      ((__CHANNEL__) == TIM_CHANNEL_2) ||          \
N      ((__CHANNEL__) == TIM_CHANNEL_3) ||          \
N      ((__CHANNEL__) == TIM_CHANNEL_4)))           \
N    ||                                         \
N    (((__INSTANCE__) == TIM9) &&                   \
N     (((__CHANNEL__) == TIM_CHANNEL_1) ||          \
N      ((__CHANNEL__) == TIM_CHANNEL_2)))           \
N    ||                                         \
N    (((__INSTANCE__) == TIM10) &&                  \
N     (((__CHANNEL__) == TIM_CHANNEL_1)))           \
N    ||                                         \
N    (((__INSTANCE__) == TIM11) &&                  \
N     (((__CHANNEL__) == TIM_CHANNEL_1)))           \
N    ||                                         \
N    (((__INSTANCE__) == TIM12) &&                  \
N     (((__CHANNEL__) == TIM_CHANNEL_1) ||          \
N      ((__CHANNEL__) == TIM_CHANNEL_2)))           \
N    ||                                         \
N    (((__INSTANCE__) == TIM13) &&                  \
N     (((__CHANNEL__) == TIM_CHANNEL_1)))           \
N    ||                                         \
N    (((__INSTANCE__) == TIM14) &&                  \
N     (((__CHANNEL__) == TIM_CHANNEL_1))))
X#define IS_TIM_CCX_INSTANCE(__INSTANCE__, __CHANNEL__)     ((((__INSTANCE__) == TIM1) &&                       (((__CHANNEL__) == TIM_CHANNEL_1) ||                ((__CHANNEL__) == TIM_CHANNEL_2) ||                ((__CHANNEL__) == TIM_CHANNEL_3) ||                ((__CHANNEL__) == TIM_CHANNEL_4)))               ||                                             (((__INSTANCE__) == TIM2) &&                        (((__CHANNEL__) == TIM_CHANNEL_1) ||                ((__CHANNEL__) == TIM_CHANNEL_2) ||                ((__CHANNEL__) == TIM_CHANNEL_3) ||                ((__CHANNEL__) == TIM_CHANNEL_4)))               ||                                             (((__INSTANCE__) == TIM3) &&                        (((__CHANNEL__) == TIM_CHANNEL_1) ||                ((__CHANNEL__) == TIM_CHANNEL_2) ||                ((__CHANNEL__) == TIM_CHANNEL_3) ||                ((__CHANNEL__) == TIM_CHANNEL_4)))               ||                                             (((__INSTANCE__) == TIM4) &&                        (((__CHANNEL__) == TIM_CHANNEL_1) ||                ((__CHANNEL__) == TIM_CHANNEL_2) ||                ((__CHANNEL__) == TIM_CHANNEL_3) ||                ((__CHANNEL__) == TIM_CHANNEL_4)))               ||                                             (((__INSTANCE__) == TIM5) &&                        (((__CHANNEL__) == TIM_CHANNEL_1) ||                ((__CHANNEL__) == TIM_CHANNEL_2) ||                ((__CHANNEL__) == TIM_CHANNEL_3) ||                ((__CHANNEL__) == TIM_CHANNEL_4)))               ||                                             (((__INSTANCE__) == TIM8) &&                        (((__CHANNEL__) == TIM_CHANNEL_1) ||                ((__CHANNEL__) == TIM_CHANNEL_2) ||                ((__CHANNEL__) == TIM_CHANNEL_3) ||                ((__CHANNEL__) == TIM_CHANNEL_4)))               ||                                             (((__INSTANCE__) == TIM9) &&                        (((__CHANNEL__) == TIM_CHANNEL_1) ||                ((__CHANNEL__) == TIM_CHANNEL_2)))               ||                                             (((__INSTANCE__) == TIM10) &&                       (((__CHANNEL__) == TIM_CHANNEL_1)))               ||                                             (((__INSTANCE__) == TIM11) &&                       (((__CHANNEL__) == TIM_CHANNEL_1)))               ||                                             (((__INSTANCE__) == TIM12) &&                       (((__CHANNEL__) == TIM_CHANNEL_1) ||                ((__CHANNEL__) == TIM_CHANNEL_2)))               ||                                             (((__INSTANCE__) == TIM13) &&                       (((__CHANNEL__) == TIM_CHANNEL_1)))               ||                                             (((__INSTANCE__) == TIM14) &&                       (((__CHANNEL__) == TIM_CHANNEL_1))))
N
N/************ TIM Instances : complementary output(s) available ***************/
N#define IS_TIM_CCXN_INSTANCE(__INSTANCE__, __CHANNEL__) \
N   ((((__INSTANCE__) == TIM1) &&                    \
N     (((__CHANNEL__) == TIM_CHANNEL_1) ||           \
N      ((__CHANNEL__) == TIM_CHANNEL_2) ||           \
N      ((__CHANNEL__) == TIM_CHANNEL_3)))            \
N    ||                                          \
N    (((__INSTANCE__) == TIM8) &&                    \
N     (((__CHANNEL__) == TIM_CHANNEL_1) ||           \
N      ((__CHANNEL__) == TIM_CHANNEL_2) ||           \
N      ((__CHANNEL__) == TIM_CHANNEL_3))))
X#define IS_TIM_CCXN_INSTANCE(__INSTANCE__, __CHANNEL__)    ((((__INSTANCE__) == TIM1) &&                         (((__CHANNEL__) == TIM_CHANNEL_1) ||                 ((__CHANNEL__) == TIM_CHANNEL_2) ||                 ((__CHANNEL__) == TIM_CHANNEL_3)))                ||                                              (((__INSTANCE__) == TIM8) &&                         (((__CHANNEL__) == TIM_CHANNEL_1) ||                 ((__CHANNEL__) == TIM_CHANNEL_2) ||                 ((__CHANNEL__) == TIM_CHANNEL_3))))
N
N/****************** TIM Instances : supporting ADC triggering through TRGO2 ***/
N#define IS_TIM_TRGO2_INSTANCE(__INSTANCE__)\
N  (((__INSTANCE__) == TIM1)    || \
N   ((__INSTANCE__) == TIM8) )
X#define IS_TIM_TRGO2_INSTANCE(__INSTANCE__)  (((__INSTANCE__) == TIM1)    ||    ((__INSTANCE__) == TIM8) )
N
N/****************** TIM Instances : supporting synchronization ****************/
N#define IS_TIM_SYNCHRO_INSTANCE(__INSTANCE__)\
N    (((__INSTANCE__) == TIM1)    || \
N     ((__INSTANCE__) == TIM2)    || \
N     ((__INSTANCE__) == TIM3)    || \
N     ((__INSTANCE__) == TIM4)    || \
N     ((__INSTANCE__) == TIM5)    || \
N     ((__INSTANCE__) == TIM6)    || \
N     ((__INSTANCE__) == TIM7)    || \
N     ((__INSTANCE__) == TIM8))  
X#define IS_TIM_SYNCHRO_INSTANCE(__INSTANCE__)    (((__INSTANCE__) == TIM1)    ||      ((__INSTANCE__) == TIM2)    ||      ((__INSTANCE__) == TIM3)    ||      ((__INSTANCE__) == TIM4)    ||      ((__INSTANCE__) == TIM5)    ||      ((__INSTANCE__) == TIM6)    ||      ((__INSTANCE__) == TIM7)    ||      ((__INSTANCE__) == TIM8))  
N      
N/******************** USART Instances : Synchronous mode **********************/
N#define IS_USART_INSTANCE(__INSTANCE__) (((__INSTANCE__) == USART1) || \
N                                     ((__INSTANCE__) == USART2) || \
N                                     ((__INSTANCE__) == USART3) || \
N                                     ((__INSTANCE__) == USART6))
X#define IS_USART_INSTANCE(__INSTANCE__) (((__INSTANCE__) == USART1) ||                                      ((__INSTANCE__) == USART2) ||                                      ((__INSTANCE__) == USART3) ||                                      ((__INSTANCE__) == USART6))
N
N/******************** UART Instances : Asynchronous mode **********************/
N#define IS_UART_INSTANCE(__INSTANCE__) (((__INSTANCE__) == USART1) || \
N                                    ((__INSTANCE__) == USART2) || \
N                                    ((__INSTANCE__) == USART3) || \
N                                    ((__INSTANCE__) == UART4)  || \
N                                    ((__INSTANCE__) == UART5)  || \
N                                    ((__INSTANCE__) == USART6) || \
N                                    ((__INSTANCE__) == UART7)  || \
N                                    ((__INSTANCE__) == UART8))
X#define IS_UART_INSTANCE(__INSTANCE__) (((__INSTANCE__) == USART1) ||                                     ((__INSTANCE__) == USART2) ||                                     ((__INSTANCE__) == USART3) ||                                     ((__INSTANCE__) == UART4)  ||                                     ((__INSTANCE__) == UART5)  ||                                     ((__INSTANCE__) == USART6) ||                                     ((__INSTANCE__) == UART7)  ||                                     ((__INSTANCE__) == UART8))
N
N/****************** UART Instances : Driver Enable *****************/
N#define IS_UART_DRIVER_ENABLE_INSTANCE(__INSTANCE__) (((__INSTANCE__) == USART1) || \
N                                    ((__INSTANCE__) == USART2) || \
N                                    ((__INSTANCE__) == USART3) || \
N                                    ((__INSTANCE__) == UART4)  || \
N                                    ((__INSTANCE__) == UART5)  || \
N                                    ((__INSTANCE__) == USART6) || \
N                                    ((__INSTANCE__) == UART7)  || \
N                                    ((__INSTANCE__) == UART8))
X#define IS_UART_DRIVER_ENABLE_INSTANCE(__INSTANCE__) (((__INSTANCE__) == USART1) ||                                     ((__INSTANCE__) == USART2) ||                                     ((__INSTANCE__) == USART3) ||                                     ((__INSTANCE__) == UART4)  ||                                     ((__INSTANCE__) == UART5)  ||                                     ((__INSTANCE__) == USART6) ||                                     ((__INSTANCE__) == UART7)  ||                                     ((__INSTANCE__) == UART8))
N
N/****************** UART Instances : Hardware Flow control ********************/
N#define IS_UART_HWFLOW_INSTANCE(__INSTANCE__) (((__INSTANCE__) == USART1) || \
N                                    ((__INSTANCE__) == USART2) || \
N                                    ((__INSTANCE__) == USART3) || \
N                                    ((__INSTANCE__) == UART4)  || \
N                                    ((__INSTANCE__) == UART5)  || \
N                                    ((__INSTANCE__) == USART6) || \
N                                    ((__INSTANCE__) == UART7)  || \
N                                    ((__INSTANCE__) == UART8))
X#define IS_UART_HWFLOW_INSTANCE(__INSTANCE__) (((__INSTANCE__) == USART1) ||                                     ((__INSTANCE__) == USART2) ||                                     ((__INSTANCE__) == USART3) ||                                     ((__INSTANCE__) == UART4)  ||                                     ((__INSTANCE__) == UART5)  ||                                     ((__INSTANCE__) == USART6) ||                                     ((__INSTANCE__) == UART7)  ||                                     ((__INSTANCE__) == UART8))
N
N/********************* UART Instances : Smart card mode ***********************/
N#define IS_SMARTCARD_INSTANCE(__INSTANCE__) (((__INSTANCE__) == USART1) || \
N                                         ((__INSTANCE__) == USART2) || \
N                                         ((__INSTANCE__) == USART3) || \
N                                         ((__INSTANCE__) == USART6))
X#define IS_SMARTCARD_INSTANCE(__INSTANCE__) (((__INSTANCE__) == USART1) ||                                          ((__INSTANCE__) == USART2) ||                                          ((__INSTANCE__) == USART3) ||                                          ((__INSTANCE__) == USART6))
N
N/*********************** UART Instances : IRDA mode ***************************/
N#define IS_IRDA_INSTANCE(__INSTANCE__) (((__INSTANCE__) == USART1) || \
N                                    ((__INSTANCE__) == USART2) || \
N                                    ((__INSTANCE__) == USART3) || \
N                                    ((__INSTANCE__) == UART4)  || \
N                                    ((__INSTANCE__) == UART5)  || \
N                                    ((__INSTANCE__) == USART6) || \
N                                    ((__INSTANCE__) == UART7)  || \
N                                    ((__INSTANCE__) == UART8))     
X#define IS_IRDA_INSTANCE(__INSTANCE__) (((__INSTANCE__) == USART1) ||                                     ((__INSTANCE__) == USART2) ||                                     ((__INSTANCE__) == USART3) ||                                     ((__INSTANCE__) == UART4)  ||                                     ((__INSTANCE__) == UART5)  ||                                     ((__INSTANCE__) == USART6) ||                                     ((__INSTANCE__) == UART7)  ||                                     ((__INSTANCE__) == UART8))     
N
N/****************************** IWDG Instances ********************************/
N#define IS_IWDG_ALL_INSTANCE(__INSTANCE__)  ((__INSTANCE__) == IWDG)
N
N/****************************** WWDG Instances ********************************/
N#define IS_WWDG_ALL_INSTANCE(__INSTANCE__)  ((__INSTANCE__) == WWDG)
N
N
N/******************************************************************************/
N/*  For a painless codes migration between the STM32F7xx device product       */
N/*  lines, the aliases defined below are put in place to overcome the         */
N/*  differences in the interrupt handlers and IRQn definitions.               */
N/*  No need to update developed interrupt code when moving across             */
N/*  product lines within the same STM32F7 Family                              */
N/******************************************************************************/
N
N/* Aliases for __IRQn */
N#define HASH_RNG_IRQn              RNG_IRQn
N
N/* Aliases for __IRQHandler */
N#define HASH_RNG_IRQHandler        RNG_IRQHandler
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N  
N#ifdef __cplusplus
S}
N#endif /* __cplusplus */
N
N#endif /* __STM32F767xx_H */
N
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 135 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx.h" 2
N#elif defined(STM32F769xx)
S  #include "stm32f769xx.h"
S#elif defined(STM32F777xx)
S  #include "stm32f777xx.h"
S#elif defined(STM32F779xx)
S  #include "stm32f779xx.h"  
S#else
S #error "Please select first the target STM32F7xx device used in your application (in stm32f7xx.h file)"
N#endif
N
N/**
N  * @}
N  */
N
N/** @addtogroup Exported_types
N  * @{
N  */ 
Ntypedef enum 
N{
N  RESET = 0, 
N  SET = !RESET
N} FlagStatus, ITStatus;
N
Ntypedef enum 
N{
N  DISABLE = 0, 
N  ENABLE = !DISABLE
N} FunctionalState;
N#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
N
Ntypedef enum 
N{
N  ERROR = 0, 
N  SUCCESS = !ERROR
N} ErrorStatus;
N
N/**
N  * @}
N  */
N  
N/** @addtogroup Exported_macro
N  * @{
N  */
N#define SET_BIT(REG, BIT)     ((REG) |= (BIT))
N
N#define CLEAR_BIT(REG, BIT)   ((REG) &= ~(BIT))
N
N#define READ_BIT(REG, BIT)    ((REG) & (BIT))
N
N#define CLEAR_REG(REG)        ((REG) = (0x0))
N
N#define WRITE_REG(REG, VAL)   ((REG) = (VAL))
N
N#define READ_REG(REG)         ((REG))
N
N#define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))
N
N#define POSITION_VAL(VAL)     (__CLZ(__RBIT(VAL))) 
N
N/**
N  * @}
N  */
N
N#ifdef USE_HAL_DRIVER
N  #include "stm32f7xx_hal_conf.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_conf.h
N  * @author  MCD Application Team
N  * @version V1.0.0
N  * @date    22-April-2016
N  * @brief   HAL configuration file. 
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_CONF_H
N#define __STM32F7xx_HAL_CONF_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/* ########################## Module Selection ############################## */
N/**
N  * @brief This is the list of modules to be used in the HAL driver 
N  */
N#define HAL_MODULE_ENABLED  
N#define HAL_ADC_MODULE_ENABLED  
N#define HAL_CAN_MODULE_ENABLED
N#define HAL_CEC_MODULE_ENABLED  
N#define HAL_CRC_MODULE_ENABLED  
N/*#define HAL_CRYP_MODULE_ENABLED*/  
N#define HAL_DAC_MODULE_ENABLED  
N#define HAL_DCMI_MODULE_ENABLED 
N#define HAL_DMA_MODULE_ENABLED
N#define HAL_DMA2D_MODULE_ENABLED 
N#define HAL_ETH_MODULE_ENABLED 
N#define HAL_FLASH_MODULE_ENABLED 
N#define HAL_NAND_MODULE_ENABLED
N#define HAL_NOR_MODULE_ENABLED
N#define HAL_SRAM_MODULE_ENABLED
N#define HAL_SDRAM_MODULE_ENABLED
N/*#define HAL_HASH_MODULE_ENABLED*/
N#define HAL_GPIO_MODULE_ENABLED
N#define HAL_I2C_MODULE_ENABLED
N#define HAL_I2S_MODULE_ENABLED   
N#define HAL_IWDG_MODULE_ENABLED 
N#define HAL_LPTIM_MODULE_ENABLED
N#define HAL_LTDC_MODULE_ENABLED 
N#define HAL_PWR_MODULE_ENABLED
N#define HAL_QSPI_MODULE_ENABLED   
N#define HAL_RCC_MODULE_ENABLED 
N#define HAL_RNG_MODULE_ENABLED   
N#define HAL_RTC_MODULE_ENABLED
N#define HAL_SAI_MODULE_ENABLED   
N#define HAL_SD_MODULE_ENABLED  
N#define HAL_SPDIFRX_MODULE_ENABLED
N#define HAL_SPI_MODULE_ENABLED   
N#define HAL_TIM_MODULE_ENABLED   
N#define HAL_UART_MODULE_ENABLED 
N#define HAL_USART_MODULE_ENABLED 
N#define HAL_IRDA_MODULE_ENABLED 
N#define HAL_SMARTCARD_MODULE_ENABLED 
N#define HAL_WWDG_MODULE_ENABLED  
N#define HAL_CORTEX_MODULE_ENABLED
N#define HAL_PCD_MODULE_ENABLED
N#define HAL_HCD_MODULE_ENABLED
N#define HAL_DFSDM_MODULE_ENABLED
N/* #define HAL_DSI_MODULE_ENABLED */
N#define HAL_JPEG_MODULE_ENABLED
N#define HAL_MDIOS_MODULE_ENABLED
N
N
N/* ########################## HSE/HSI Values adaptation ##################### */
N/**
N  * @brief Adjust the value of External High Speed oscillator (HSE) used in your application.
N  *        This value is used by the RCC HAL module to compute the system frequency
N  *        (when HSE is used as system clock source, directly or through the PLL).  
N  */
N#if !defined  (HSE_VALUE) 
X#if !0L 
N  #define HSE_VALUE    ((uint32_t)25000000U) /*!< Value of the External oscillator in Hz */
N#endif /* HSE_VALUE */
N
N#if !defined  (HSE_STARTUP_TIMEOUT)
X#if !0L
N  #define HSE_STARTUP_TIMEOUT    ((uint32_t)100U)   /*!< Time out for HSE start up, in ms */
N#endif /* HSE_STARTUP_TIMEOUT */
N
N/**
N  * @brief Internal High Speed oscillator (HSI) value.
N  *        This value is used by the RCC HAL module to compute the system frequency
N  *        (when HSI is used as system clock source, directly or through the PLL). 
N  */
N#if !defined  (HSI_VALUE)
X#if !0L
N  #define HSI_VALUE    ((uint32_t)16000000U) /*!< Value of the Internal oscillator in Hz*/
N#endif /* HSI_VALUE */
N
N/**
N  * @brief Internal Low Speed oscillator (LSI) value.
N  */
N#if !defined  (LSI_VALUE) 
X#if !0L 
N #define LSI_VALUE  ((uint32_t)32000U)       /*!< LSI Typical Value in Hz*/
N#endif /* LSI_VALUE */                      /*!< Value of the Internal Low Speed oscillator in Hz
N                                             The real value may vary depending on the variations
N                                             in voltage and temperature.  */
N/**
N  * @brief External Low Speed oscillator (LSE) value.
N  */
N#if !defined  (LSE_VALUE)
X#if !0L
N #define LSE_VALUE  ((uint32_t)32768U)    /*!< Value of the External Low Speed oscillator in Hz */
N#endif /* LSE_VALUE */
N
N#if !defined  (LSE_STARTUP_TIMEOUT)
X#if !0L
N  #define LSE_STARTUP_TIMEOUT    ((uint32_t)5000U)   /*!< Time out for LSE start up, in ms */
N#endif /* LSE_STARTUP_TIMEOUT */
N
N/**
N  * @brief External clock source for I2S peripheral
N  *        This value is used by the I2S HAL module to compute the I2S clock source 
N  *        frequency, this source is inserted directly through I2S_CKIN pad. 
N  */
N#if !defined  (EXTERNAL_CLOCK_VALUE)
X#if !0L
N  #define EXTERNAL_CLOCK_VALUE    ((uint32_t)12288000U) /*!< Value of the Internal oscillator in Hz*/
N#endif /* EXTERNAL_CLOCK_VALUE */
N
N/* Tip: To avoid modifying this file each time you need to use different HSE,
N   ===  you can define the HSE value in your toolchain compiler preprocessor. */
N
N/* ########################### System Configuration ######################### */
N/**
N  * @brief This is the HAL system configuration section
N  */     
N#define  VDD_VALUE                    ((uint32_t)3300U) /*!< Value of VDD in mv */
N#define  TICK_INT_PRIORITY            ((uint32_t)0x0FU) /*!< tick interrupt priority */
N#define  USE_RTOS                     0U
N#define  PREFETCH_ENABLE              1U
N#define  ART_ACCLERATOR_ENABLE        1U /* To enable instruction cache and prefetch */
N
N/* ########################## Assert Selection ############################## */
N/**
N  * @brief Uncomment the line below to expanse the "assert_param" macro in the 
N  *        HAL drivers code
N  */
N/* #define USE_FULL_ASSERT    1 */
N
N/* ################## Ethernet peripheral configuration for NUCLEO 144 board ##################### */
N
N/* Section 1 : Ethernet peripheral configuration */
N
N/* MAC ADDRESS: MAC_ADDR0:MAC_ADDR1:MAC_ADDR2:MAC_ADDR3:MAC_ADDR4:MAC_ADDR5 */
N#define MAC_ADDR0   2U
N#define MAC_ADDR1   0U
N#define MAC_ADDR2   0U
N#define MAC_ADDR3   0U
N#define MAC_ADDR4   0U
N#define MAC_ADDR5   0U
N
N/* Definition of the Ethernet driver buffers size and count */   
N#define ETH_RX_BUF_SIZE                ETH_MAX_PACKET_SIZE /* buffer size for receive               */
N#define ETH_TX_BUF_SIZE                ETH_MAX_PACKET_SIZE /* buffer size for transmit              */
N#define ETH_RXBUFNB                    ((uint32_t)5)       /* 5 Rx buffers of size ETH_RX_BUF_SIZE  */
N#define ETH_TXBUFNB                    ((uint32_t)5)       /* 5 Tx buffers of size ETH_TX_BUF_SIZE  */
N
N/* Section 2: PHY configuration section */
N/* LAN8742A PHY Address*/
N#define LAN8742A_PHY_ADDRESS            0x00
N/* PHY Reset delay these values are based on a 1 ms Systick interrupt*/ 
N#define PHY_RESET_DELAY                 ((uint32_t)0x00000FFF)
N/* PHY Configuration delay */
N#define PHY_CONFIG_DELAY                ((uint32_t)0x00000FFF)
N
N#define PHY_READ_TO                     ((uint32_t)0x0000FFFF)
N#define PHY_WRITE_TO                    ((uint32_t)0x0000FFFF)
N
N/* Section 3: Common PHY Registers */
N
N#define PHY_BCR                         ((uint16_t)0x00)    /*!< Transceiver Basic Control Register   */
N#define PHY_BSR                         ((uint16_t)0x01)    /*!< Transceiver Basic Status Register    */
N 
N#define PHY_RESET                       ((uint16_t)0x8000)  /*!< PHY Reset */
N#define PHY_LOOPBACK                    ((uint16_t)0x4000)  /*!< Select loop-back mode */
N#define PHY_FULLDUPLEX_100M             ((uint16_t)0x2100)  /*!< Set the full-duplex mode at 100 Mb/s */
N#define PHY_HALFDUPLEX_100M             ((uint16_t)0x2000)  /*!< Set the half-duplex mode at 100 Mb/s */
N#define PHY_FULLDUPLEX_10M              ((uint16_t)0x0100)  /*!< Set the full-duplex mode at 10 Mb/s  */
N#define PHY_HALFDUPLEX_10M              ((uint16_t)0x0000)  /*!< Set the half-duplex mode at 10 Mb/s  */
N#define PHY_AUTONEGOTIATION             ((uint16_t)0x1000)  /*!< Enable auto-negotiation function     */
N#define PHY_RESTART_AUTONEGOTIATION     ((uint16_t)0x0200)  /*!< Restart auto-negotiation function    */
N#define PHY_POWERDOWN                   ((uint16_t)0x0800)  /*!< Select the power down mode           */
N#define PHY_ISOLATE                     ((uint16_t)0x0400)  /*!< Isolate PHY from MII                 */
N
N#define PHY_AUTONEGO_COMPLETE           ((uint16_t)0x0020)  /*!< Auto-Negotiation process completed   */
N#define PHY_LINKED_STATUS               ((uint16_t)0x0004)  /*!< Valid link established               */
N#define PHY_JABBER_DETECTION            ((uint16_t)0x0002)  /*!< Jabber condition detected            */
N  
N/* Section 4: Extended PHY Registers */
N
N#define PHY_SR                          ((uint16_t)0x1F)    /*!< PHY special control/ status register Offset     */
N
N#define PHY_SPEED_STATUS                ((uint16_t)0x0004)  /*!< PHY Speed mask                                  */
N#define PHY_DUPLEX_STATUS               ((uint16_t)0x0010)  /*!< PHY Duplex mask                                 */
N
N
N#define PHY_ISFR                        ((uint16_t)0x1D)    /*!< PHY Interrupt Source Flag register Offset       */
N#define PHY_ISFR_INT4                   ((uint16_t)0x0010)  /*!< PHY Link down inturrupt                         */
N
N/* ################## SPI peripheral configuration ########################## */
N
N/* CRC FEATURE: Use to activate CRC feature inside HAL SPI Driver
N* Activated: CRC code is present inside driver
N* Deactivated: CRC code cleaned from driver
N*/
N
N#define USE_SPI_CRC                     1U
N
N/* Includes ------------------------------------------------------------------*/
N/**
N  * @brief Include module's header file 
N  */
N
N#ifdef HAL_RCC_MODULE_ENABLED
N  #include "stm32f7xx_hal_rcc.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_rcc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_rcc.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of RCC HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_RCC_H
N#define __STM32F7xx_HAL_RCC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_def.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_def.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   This file contains HAL common defines, enumeration, macros and 
N  *          structures definitions. 
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_DEF
N#define __STM32F7xx_HAL_DEF
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   CMSIS STM32F7xx Device Peripheral Access Layer Header File.           
N  *            
N  *          The file is the unique include file that the application programmer
N  *          is using in the C source code, usually in main.c. This file contains:
N  *           - Configuration section that allows to select:
N  *              - The STM32F7xx device used in the target application
N  *              - To use or not the peripheral’s drivers in application code(i.e. 
N  *                code will be based on direct access to peripheral’s registers 
N  *                rather than drivers API), this option is controlled by 
N  *                "#define USE_HAL_DRIVER"
N  *  
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/** @addtogroup CMSIS
N  * @{
N  */
N
N/** @addtogroup stm32f7xx
N  * @{
N  */
N    
N#ifndef __STM32F7xx_H
S#define __STM32F7xx_H
S
S#ifdef __cplusplus
S extern "C" {
S#endif /* __cplusplus */
S  
S/** @addtogroup Library_configuration_section
S  * @{
S  */
S
S/**
S  * @brief STM32 Family
S  */
S#if !defined  (STM32F7)
S#define STM32F7
S#endif /* STM32F7 */
S
S/* Uncomment the line below according to the target STM32 device used in your
S   application 
S  */
S#if !defined (STM32F756xx) && !defined (STM32F746xx) && !defined (STM32F745xx) && !defined (STM32F767xx) && \
S    !defined (STM32F769xx) && !defined (STM32F777xx) && !defined (STM32F779xx)
X#if !defined (STM32F756xx) && !defined (STM32F746xx) && !defined (STM32F745xx) && !defined (STM32F767xx) &&     !defined (STM32F769xx) && !defined (STM32F777xx) && !defined (STM32F779xx)
S  /* #define STM32F756xx */   /*!< STM32F756VG, STM32F756ZG, STM32F756ZG, STM32F756IG, STM32F756BG,
S                                   STM32F756NG Devices */
S  /* #define STM32F746xx */   /*!< STM32F746VE, STM32F746VG, STM32F746ZE, STM32F746ZG, STM32F746IE, STM32F746IG,
S                                   STM32F746BE, STM32F746BG, STM32F746NE, STM32F746NG Devices */
S  /* #define STM32F745xx */   /*!< STM32F745VE, STM32F745VG, STM32F745ZG, STM32F745ZE, STM32F745IE, STM32F745IG Devices */
S  /* #define STM32F765xx */   /*!< STM32F765BI, STM32F765BG, STM32F765NI, STM32F765NG, STM32F765II, STM32F765IG,
S                                   STM32F765ZI, STM32F765ZG, STM32F765VI, STM32F765VG Devices */
S  /* #define STM32F767xx */   /*!< STM32F767BG, STM32F767BI, STM32F767IG, STM32F767II, STM32F767NG, STM32F767NI,
S                                   STM32F767VG, STM32F767VI, STM32F767ZG, STM32F767ZI Devices */
S  /* #define STM32F769xx */   /*!< STM32F769AG, STM32F769AI, STM32F769BG, STM32F769BI, STM32F769IG, STM32F769II,
S                                   STM32F769NG, STM32F769NI, STM32F768AI Devices */
S  /* #define STM32F777xx */   /*!< STM32F777VI, STM32F777ZI, STM32F777II, STM32F777BI, STM32F777NI Devices */
S  /* #define STM32F779xx */   /*!< STM32F779II, STM32F779BI, STM32F779NI, STM32F779AI, STM32F778AI Devices */
S#endif
S
S/*  Tip: To avoid modifying this file each time you need to switch between these
S        devices, you can define the device in your toolchain compiler preprocessor.
S  */
S
S#if !defined  (USE_HAL_DRIVER)
S/**
S * @brief Comment the line below if you will not use the peripherals drivers.
S   In this case, these drivers will not be included and the application code will 
S   be based on direct access to peripherals registers 
S   */
S  /*#define USE_HAL_DRIVER */
S#endif /* USE_HAL_DRIVER */
S
S/**
S  * @brief CMSIS Device version number V1.1.1
S  */
S#define __STM32F7_CMSIS_VERSION_MAIN   (0x01) /*!< [31:24] main version */
S#define __STM32F7_CMSIS_VERSION_SUB1   (0x01) /*!< [23:16] sub1 version */
S#define __STM32F7_CMSIS_VERSION_SUB2   (0x01) /*!< [15:8]  sub2 version */
S#define __STM32F7_CMSIS_VERSION_RC     (0x00) /*!< [7:0]  release candidate */ 
S#define __STM32F7_CMSIS_VERSION        ((__STM32F7_CMSIS_VERSION_MAIN << 24)\
S                                       |(__STM32F7_CMSIS_VERSION_SUB1 << 16)\
S                                       |(__STM32F7_CMSIS_VERSION_SUB2 << 8 )\
S                                       |(__STM32F7_CMSIS_VERSION))
X#define __STM32F7_CMSIS_VERSION        ((__STM32F7_CMSIS_VERSION_MAIN << 24)                                       |(__STM32F7_CMSIS_VERSION_SUB1 << 16)                                       |(__STM32F7_CMSIS_VERSION_SUB2 << 8 )                                       |(__STM32F7_CMSIS_VERSION))
S/**
S  * @}
S  */
S
S/** @addtogroup Device_Included
S  * @{
S  */
S#if defined(STM32F756xx)
S  #include "stm32f756xx.h"
S#elif defined(STM32F746xx)
S  #include "stm32f746xx.h"
S#elif defined(STM32F745xx)
S  #include "stm32f745xx.h"
S#elif defined(STM32F765xx)
S  #include "stm32f765xx.h"
S#elif defined(STM32F767xx)
S  #include "stm32f767xx.h"
S#elif defined(STM32F769xx)
S  #include "stm32f769xx.h"
S#elif defined(STM32F777xx)
S  #include "stm32f777xx.h"
S#elif defined(STM32F779xx)
S  #include "stm32f779xx.h"  
S#else
S #error "Please select first the target STM32F7xx device used in your application (in stm32f7xx.h file)"
S#endif
S
S/**
S  * @}
S  */
S
S/** @addtogroup Exported_types
S  * @{
S  */ 
Stypedef enum 
S{
S  RESET = 0, 
S  SET = !RESET
S} FlagStatus, ITStatus;
S
Stypedef enum 
S{
S  DISABLE = 0, 
S  ENABLE = !DISABLE
S} FunctionalState;
S#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
S
Stypedef enum 
S{
S  ERROR = 0, 
S  SUCCESS = !ERROR
S} ErrorStatus;
S
S/**
S  * @}
S  */
S  
S/** @addtogroup Exported_macro
S  * @{
S  */
S#define SET_BIT(REG, BIT)     ((REG) |= (BIT))
S
S#define CLEAR_BIT(REG, BIT)   ((REG) &= ~(BIT))
S
S#define READ_BIT(REG, BIT)    ((REG) & (BIT))
S
S#define CLEAR_REG(REG)        ((REG) = (0x0))
S
S#define WRITE_REG(REG, VAL)   ((REG) = (VAL))
S
S#define READ_REG(REG)         ((REG))
S
S#define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))
S
S#define POSITION_VAL(VAL)     (__CLZ(__RBIT(VAL))) 
S
S/**
S  * @}
S  */
S
S#ifdef USE_HAL_DRIVER
S  #include "stm32f7xx_hal_conf.h"
S#endif /* USE_HAL_DRIVER */
S
S#ifdef __cplusplus
S}
S#endif /* __cplusplus */
S
N#endif /* __STM32F7xx_H */
N
N/**
N  * @}
N  */
N
N  /**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 49 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_def.h" 2
N#include "Legacy/stm32_hal_legacy.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Legacy/stm32_hal_legacy.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32_hal_legacy.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   This file contains aliases definition for the STM32Cube HAL constants 
N  *          macros and functions maintained for legacy purpose.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32_HAL_LEGACY
N#define __STM32_HAL_LEGACY
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup HAL_AES_Aliased_Defines HAL CRYP Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define AES_FLAG_RDERR                  CRYP_FLAG_RDERR
N#define AES_FLAG_WRERR                  CRYP_FLAG_WRERR
N#define AES_CLEARFLAG_CCF               CRYP_CLEARFLAG_CCF
N#define AES_CLEARFLAG_RDERR             CRYP_CLEARFLAG_RDERR
N#define AES_CLEARFLAG_WRERR             CRYP_CLEARFLAG_WRERR
N
N/**
N  * @}
N  */
N  
N/** @defgroup HAL_ADC_Aliased_Defines HAL ADC Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define ADC_RESOLUTION12b               ADC_RESOLUTION_12B
N#define ADC_RESOLUTION10b               ADC_RESOLUTION_10B
N#define ADC_RESOLUTION8b                ADC_RESOLUTION_8B
N#define ADC_RESOLUTION6b                ADC_RESOLUTION_6B
N#define OVR_DATA_OVERWRITTEN            ADC_OVR_DATA_OVERWRITTEN
N#define OVR_DATA_PRESERVED              ADC_OVR_DATA_PRESERVED
N#define EOC_SINGLE_CONV                 ADC_EOC_SINGLE_CONV
N#define EOC_SEQ_CONV                    ADC_EOC_SEQ_CONV
N#define EOC_SINGLE_SEQ_CONV             ADC_EOC_SINGLE_SEQ_CONV
N#define REGULAR_GROUP                   ADC_REGULAR_GROUP
N#define INJECTED_GROUP                  ADC_INJECTED_GROUP
N#define REGULAR_INJECTED_GROUP          ADC_REGULAR_INJECTED_GROUP
N#define AWD_EVENT                       ADC_AWD_EVENT
N#define AWD1_EVENT                      ADC_AWD1_EVENT
N#define AWD2_EVENT                      ADC_AWD2_EVENT
N#define AWD3_EVENT                      ADC_AWD3_EVENT
N#define OVR_EVENT                       ADC_OVR_EVENT
N#define JQOVF_EVENT                     ADC_JQOVF_EVENT
N#define ALL_CHANNELS                    ADC_ALL_CHANNELS
N#define REGULAR_CHANNELS                ADC_REGULAR_CHANNELS
N#define INJECTED_CHANNELS               ADC_INJECTED_CHANNELS
N#define SYSCFG_FLAG_SENSOR_ADC          ADC_FLAG_SENSOR
N#define SYSCFG_FLAG_VREF_ADC            ADC_FLAG_VREFINT
N#define ADC_CLOCKPRESCALER_PCLK_DIV1    ADC_CLOCK_SYNC_PCLK_DIV1
N#define ADC_CLOCKPRESCALER_PCLK_DIV2    ADC_CLOCK_SYNC_PCLK_DIV2
N#define ADC_CLOCKPRESCALER_PCLK_DIV4    ADC_CLOCK_SYNC_PCLK_DIV4
N#define ADC_CLOCKPRESCALER_PCLK_DIV6    ADC_CLOCK_SYNC_PCLK_DIV6
N#define ADC_CLOCKPRESCALER_PCLK_DIV8    ADC_CLOCK_SYNC_PCLK_DIV8
N#define ADC_EXTERNALTRIG0_T6_TRGO       ADC_EXTERNALTRIGCONV_T6_TRGO 
N#define ADC_EXTERNALTRIG1_T21_CC2       ADC_EXTERNALTRIGCONV_T21_CC2 
N#define ADC_EXTERNALTRIG2_T2_TRGO       ADC_EXTERNALTRIGCONV_T2_TRGO 
N#define ADC_EXTERNALTRIG3_T2_CC4        ADC_EXTERNALTRIGCONV_T2_CC4  
N#define ADC_EXTERNALTRIG4_T22_TRGO      ADC_EXTERNALTRIGCONV_T22_TRGO
N#define ADC_EXTERNALTRIG7_EXT_IT11      ADC_EXTERNALTRIGCONV_EXT_IT11
N#define ADC_CLOCK_ASYNC                 ADC_CLOCK_ASYNC_DIV1
N#define ADC_EXTERNALTRIG_EDGE_NONE      ADC_EXTERNALTRIGCONVEDGE_NONE
N#define ADC_EXTERNALTRIG_EDGE_RISING    ADC_EXTERNALTRIGCONVEDGE_RISING
N#define ADC_EXTERNALTRIG_EDGE_FALLING   ADC_EXTERNALTRIGCONVEDGE_FALLING
N#define ADC_EXTERNALTRIG_EDGE_RISINGFALLING ADC_EXTERNALTRIGCONVEDGE_RISINGFALLING
N#define ADC_SAMPLETIME_2CYCLE_5         ADC_SAMPLETIME_2CYCLES_5
N
N#define HAL_ADC_STATE_BUSY_REG          HAL_ADC_STATE_REG_BUSY
N#define HAL_ADC_STATE_BUSY_INJ          HAL_ADC_STATE_INJ_BUSY
N#define HAL_ADC_STATE_EOC_REG           HAL_ADC_STATE_REG_EOC
N#define HAL_ADC_STATE_EOC_INJ           HAL_ADC_STATE_INJ_EOC
N#define HAL_ADC_STATE_ERROR             HAL_ADC_STATE_ERROR_INTERNAL
N#define HAL_ADC_STATE_BUSY              HAL_ADC_STATE_BUSY_INTERNAL
N#define HAL_ADC_STATE_AWD               HAL_ADC_STATE_AWD1 
N/**
N  * @}
N  */
N  
N/** @defgroup HAL_CEC_Aliased_Defines HAL CEC Aliased Defines maintained for legacy purpose
N  * @{
N  */ 
N  
N#define __HAL_CEC_GET_IT __HAL_CEC_GET_FLAG 
N
N/**
N  * @}
N  */   
N   
N/** @defgroup HAL_COMP_Aliased_Defines HAL COMP Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define COMP_WINDOWMODE_DISABLED       COMP_WINDOWMODE_DISABLE
N#define COMP_WINDOWMODE_ENABLED        COMP_WINDOWMODE_ENABLE
N#define COMP_EXTI_LINE_COMP1_EVENT     COMP_EXTI_LINE_COMP1
N#define COMP_EXTI_LINE_COMP2_EVENT     COMP_EXTI_LINE_COMP2
N#define COMP_EXTI_LINE_COMP3_EVENT     COMP_EXTI_LINE_COMP3
N#define COMP_EXTI_LINE_COMP4_EVENT     COMP_EXTI_LINE_COMP4
N#define COMP_EXTI_LINE_COMP5_EVENT     COMP_EXTI_LINE_COMP5
N#define COMP_EXTI_LINE_COMP6_EVENT     COMP_EXTI_LINE_COMP6
N#define COMP_EXTI_LINE_COMP7_EVENT     COMP_EXTI_LINE_COMP7
N#define COMP_OUTPUT_COMP6TIM2OCREFCLR  COMP_OUTPUT_COMP6_TIM2OCREFCLR
N#if defined(STM32F373xC) || defined(STM32F378xx)
X#if 0L || 0L
S#define COMP_OUTPUT_TIM3IC1            COMP_OUTPUT_COMP1_TIM3IC1
S#define COMP_OUTPUT_TIM3OCREFCLR       COMP_OUTPUT_COMP1_TIM3OCREFCLR
N#endif /* STM32F373xC || STM32F378xx */
N
N#if defined(STM32L0) || defined(STM32L4)
X#if 0L || 0L
S#define COMP_WINDOWMODE_ENABLE         COMP_WINDOWMODE_COMP1_INPUT_PLUS_COMMON
S
S#define COMP_NONINVERTINGINPUT_IO1      COMP_INPUT_PLUS_IO1
S#define COMP_NONINVERTINGINPUT_IO2      COMP_INPUT_PLUS_IO2
S#define COMP_NONINVERTINGINPUT_IO3      COMP_INPUT_PLUS_IO3
S 
S#define COMP_INVERTINGINPUT_1_4VREFINT  COMP_INPUT_MINUS_1_4VREFINT
S#define COMP_INVERTINGINPUT_1_2VREFINT  COMP_INPUT_MINUS_1_2VREFINT
S#define COMP_INVERTINGINPUT_3_4VREFINT  COMP_INPUT_MINUS_3_4VREFINT
S#define COMP_INVERTINGINPUT_VREFINT     COMP_INPUT_MINUS_VREFINT
S#define COMP_INVERTINGINPUT_DAC1_CH1    COMP_INPUT_MINUS_DAC1_CH1
S#define COMP_INVERTINGINPUT_DAC1_CH2    COMP_INPUT_MINUS_DAC1_CH2
S#define COMP_INVERTINGINPUT_DAC1        COMP_INPUT_MINUS_DAC1_CH1
S#define COMP_INVERTINGINPUT_DAC2        COMP_INPUT_MINUS_DAC1_CH2
S#define COMP_INVERTINGINPUT_IO1         COMP_INPUT_MINUS_IO1
S#define COMP_INVERTINGINPUT_IO2         COMP_INPUT_MINUS_IO2
S#define COMP_INVERTINGINPUT_IO3         COMP_INPUT_MINUS_IO3
S#define COMP_INVERTINGINPUT_IO4         COMP_INPUT_MINUS_IO4
S#define COMP_INVERTINGINPUT_IO5         COMP_INPUT_MINUS_IO5
S
S#define COMP_OUTPUTLEVEL_LOW            COMP_OUTPUT_LEVEL_LOW
S#define COMP_OUTPUTLEVEL_HIGH           COMP_OUTPUT_LEVEL_HIGH
S
S/* Note: Literal "COMP_FLAG_LOCK" kept for legacy purpose.                    */
S/*       To check COMP lock state, use macro "__HAL_COMP_IS_LOCKED()".        */
S#if defined(COMP_CSR_LOCK)
S#define COMP_FLAG_LOCK                 COMP_CSR_LOCK
S#elif defined(COMP_CSR_COMP1LOCK)
S#define COMP_FLAG_LOCK                 COMP_CSR_COMP1LOCK
S#elif defined(COMP_CSR_COMPxLOCK)
S#define COMP_FLAG_LOCK                 COMP_CSR_COMPxLOCK
S#endif
S
S#if defined(STM32L4)
S#define COMP_BLANKINGSRCE_TIM1OC5        COMP_BLANKINGSRC_TIM1_OC5_COMP1
S#define COMP_BLANKINGSRCE_TIM2OC3        COMP_BLANKINGSRC_TIM2_OC3_COMP1
S#define COMP_BLANKINGSRCE_TIM3OC3        COMP_BLANKINGSRC_TIM3_OC3_COMP1
S#define COMP_BLANKINGSRCE_TIM3OC4        COMP_BLANKINGSRC_TIM3_OC4_COMP2
S#define COMP_BLANKINGSRCE_TIM8OC5        COMP_BLANKINGSRC_TIM8_OC5_COMP2
S#define COMP_BLANKINGSRCE_TIM15OC1       COMP_BLANKINGSRC_TIM15_OC1_COMP2
S#define COMP_BLANKINGSRCE_NONE           COMP_BLANKINGSRC_NONE
S#endif
S
S#if defined(STM32L0)
S#define COMP_MODE_HIGHSPEED              COMP_POWERMODE_MEDIUMSPEED
S#define COMP_MODE_LOWSPEED               COMP_POWERMODE_ULTRALOWPOWER
S#else
S#define COMP_MODE_HIGHSPEED              COMP_POWERMODE_HIGHSPEED
S#define COMP_MODE_MEDIUMSPEED            COMP_POWERMODE_MEDIUMSPEED
S#define COMP_MODE_LOWPOWER               COMP_POWERMODE_LOWPOWER
S#define COMP_MODE_ULTRALOWPOWER          COMP_POWERMODE_ULTRALOWPOWER
S#endif
S
N#endif
N/**
N  * @}
N  */
N
N/** @defgroup HAL_CORTEX_Aliased_Defines HAL CORTEX Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define __HAL_CORTEX_SYSTICKCLK_CONFIG HAL_SYSTICK_CLKSourceConfig
N/**
N  * @}
N  */
N
N/** @defgroup HAL_CRC_Aliased_Defines HAL CRC Aliased Defines maintained for legacy purpose
N  * @{
N  */
N  
N#define CRC_OUTPUTDATA_INVERSION_DISABLED    CRC_OUTPUTDATA_INVERSION_DISABLE
N#define CRC_OUTPUTDATA_INVERSION_ENABLED     CRC_OUTPUTDATA_INVERSION_ENABLE
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_DAC_Aliased_Defines HAL DAC Aliased Defines maintained for legacy purpose
N  * @{
N  */
N
N#define DAC1_CHANNEL_1                                  DAC_CHANNEL_1
N#define DAC1_CHANNEL_2                                  DAC_CHANNEL_2
N#define DAC2_CHANNEL_1                                  DAC_CHANNEL_1
N#define DAC_WAVE_NONE                                   ((uint32_t)0x00000000U)
N#define DAC_WAVE_NOISE                                  ((uint32_t)DAC_CR_WAVE1_0)
N#define DAC_WAVE_TRIANGLE                               ((uint32_t)DAC_CR_WAVE1_1)                           
N#define DAC_WAVEGENERATION_NONE                         DAC_WAVE_NONE
N#define DAC_WAVEGENERATION_NOISE                        DAC_WAVE_NOISE
N#define DAC_WAVEGENERATION_TRIANGLE                     DAC_WAVE_TRIANGLE
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_DMA_Aliased_Defines HAL DMA Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define HAL_REMAPDMA_ADC_DMA_CH2                DMA_REMAP_ADC_DMA_CH2       
N#define HAL_REMAPDMA_USART1_TX_DMA_CH4          DMA_REMAP_USART1_TX_DMA_CH4 
N#define HAL_REMAPDMA_USART1_RX_DMA_CH5          DMA_REMAP_USART1_RX_DMA_CH5   
N#define HAL_REMAPDMA_TIM16_DMA_CH4              DMA_REMAP_TIM16_DMA_CH4       
N#define HAL_REMAPDMA_TIM17_DMA_CH2              DMA_REMAP_TIM17_DMA_CH2       
N#define HAL_REMAPDMA_USART3_DMA_CH32            DMA_REMAP_USART3_DMA_CH32
N#define HAL_REMAPDMA_TIM16_DMA_CH6              DMA_REMAP_TIM16_DMA_CH6
N#define HAL_REMAPDMA_TIM17_DMA_CH7              DMA_REMAP_TIM17_DMA_CH7      
N#define HAL_REMAPDMA_SPI2_DMA_CH67              DMA_REMAP_SPI2_DMA_CH67  
N#define HAL_REMAPDMA_USART2_DMA_CH67            DMA_REMAP_USART2_DMA_CH67 
N#define HAL_REMAPDMA_USART3_DMA_CH32            DMA_REMAP_USART3_DMA_CH32  
N#define HAL_REMAPDMA_I2C1_DMA_CH76              DMA_REMAP_I2C1_DMA_CH76   
N#define HAL_REMAPDMA_TIM1_DMA_CH6               DMA_REMAP_TIM1_DMA_CH6     
N#define HAL_REMAPDMA_TIM2_DMA_CH7               DMA_REMAP_TIM2_DMA_CH7      
N#define HAL_REMAPDMA_TIM3_DMA_CH6               DMA_REMAP_TIM3_DMA_CH6    
N  
N#define IS_HAL_REMAPDMA                          IS_DMA_REMAP  
N#define __HAL_REMAPDMA_CHANNEL_ENABLE            __HAL_DMA_REMAP_CHANNEL_ENABLE
N#define __HAL_REMAPDMA_CHANNEL_DISABLE           __HAL_DMA_REMAP_CHANNEL_DISABLE
N  
N  
N  
N/**
N  * @}
N  */
N
N/** @defgroup HAL_FLASH_Aliased_Defines HAL FLASH Aliased Defines maintained for legacy purpose
N  * @{
N  */
N  
N#define TYPEPROGRAM_BYTE              FLASH_TYPEPROGRAM_BYTE
N#define TYPEPROGRAM_HALFWORD          FLASH_TYPEPROGRAM_HALFWORD
N#define TYPEPROGRAM_WORD              FLASH_TYPEPROGRAM_WORD
N#define TYPEPROGRAM_DOUBLEWORD        FLASH_TYPEPROGRAM_DOUBLEWORD
N#define TYPEERASE_SECTORS             FLASH_TYPEERASE_SECTORS
N#define TYPEERASE_PAGES               FLASH_TYPEERASE_PAGES
N#define TYPEERASE_PAGEERASE           FLASH_TYPEERASE_PAGES
N#define TYPEERASE_MASSERASE           FLASH_TYPEERASE_MASSERASE
N#define WRPSTATE_DISABLE              OB_WRPSTATE_DISABLE
N#define WRPSTATE_ENABLE               OB_WRPSTATE_ENABLE
N#define HAL_FLASH_TIMEOUT_VALUE       FLASH_TIMEOUT_VALUE
N#define OBEX_PCROP                    OPTIONBYTE_PCROP
N#define OBEX_BOOTCONFIG               OPTIONBYTE_BOOTCONFIG
N#define PCROPSTATE_DISABLE            OB_PCROP_STATE_DISABLE
N#define PCROPSTATE_ENABLE             OB_PCROP_STATE_ENABLE
N#define TYPEERASEDATA_BYTE            FLASH_TYPEERASEDATA_BYTE
N#define TYPEERASEDATA_HALFWORD        FLASH_TYPEERASEDATA_HALFWORD
N#define TYPEERASEDATA_WORD            FLASH_TYPEERASEDATA_WORD
N#define TYPEPROGRAMDATA_BYTE          FLASH_TYPEPROGRAMDATA_BYTE
N#define TYPEPROGRAMDATA_HALFWORD      FLASH_TYPEPROGRAMDATA_HALFWORD
N#define TYPEPROGRAMDATA_WORD          FLASH_TYPEPROGRAMDATA_WORD
N#define TYPEPROGRAMDATA_FASTBYTE      FLASH_TYPEPROGRAMDATA_FASTBYTE
N#define TYPEPROGRAMDATA_FASTHALFWORD  FLASH_TYPEPROGRAMDATA_FASTHALFWORD
N#define TYPEPROGRAMDATA_FASTWORD      FLASH_TYPEPROGRAMDATA_FASTWORD
N#define PAGESIZE                      FLASH_PAGE_SIZE
N#define TYPEPROGRAM_FASTBYTE          FLASH_TYPEPROGRAM_BYTE
N#define TYPEPROGRAM_FASTHALFWORD      FLASH_TYPEPROGRAM_HALFWORD
N#define TYPEPROGRAM_FASTWORD          FLASH_TYPEPROGRAM_WORD
N#define VOLTAGE_RANGE_1               FLASH_VOLTAGE_RANGE_1
N#define VOLTAGE_RANGE_2               FLASH_VOLTAGE_RANGE_2
N#define VOLTAGE_RANGE_3               FLASH_VOLTAGE_RANGE_3
N#define VOLTAGE_RANGE_4               FLASH_VOLTAGE_RANGE_4
N#define TYPEPROGRAM_FAST              FLASH_TYPEPROGRAM_FAST
N#define TYPEPROGRAM_FAST_AND_LAST     FLASH_TYPEPROGRAM_FAST_AND_LAST
N#define WRPAREA_BANK1_AREAA           OB_WRPAREA_BANK1_AREAA
N#define WRPAREA_BANK1_AREAB           OB_WRPAREA_BANK1_AREAB
N#define WRPAREA_BANK2_AREAA           OB_WRPAREA_BANK2_AREAA
N#define WRPAREA_BANK2_AREAB           OB_WRPAREA_BANK2_AREAB
N#define IWDG_STDBY_FREEZE             OB_IWDG_STDBY_FREEZE
N#define IWDG_STDBY_ACTIVE             OB_IWDG_STDBY_RUN
N#define IWDG_STOP_FREEZE              OB_IWDG_STOP_FREEZE
N#define IWDG_STOP_ACTIVE              OB_IWDG_STOP_RUN
N#define FLASH_ERROR_NONE              HAL_FLASH_ERROR_NONE
N#define FLASH_ERROR_RD                HAL_FLASH_ERROR_RD
N#define FLASH_ERROR_PG                HAL_FLASH_ERROR_PROG
N#define FLASH_ERROR_PGP               HAL_FLASH_ERROR_PGS
N#define FLASH_ERROR_WRP               HAL_FLASH_ERROR_WRP
N#define FLASH_ERROR_OPTV              HAL_FLASH_ERROR_OPTV
N#define FLASH_ERROR_OPTVUSR           HAL_FLASH_ERROR_OPTVUSR
N#define FLASH_ERROR_PROG              HAL_FLASH_ERROR_PROG
N#define FLASH_ERROR_OP                HAL_FLASH_ERROR_OPERATION
N#define FLASH_ERROR_PGA               HAL_FLASH_ERROR_PGA
N#define FLASH_ERROR_SIZE              HAL_FLASH_ERROR_SIZE
N#define FLASH_ERROR_SIZ               HAL_FLASH_ERROR_SIZE
N#define FLASH_ERROR_PGS               HAL_FLASH_ERROR_PGS
N#define FLASH_ERROR_MIS               HAL_FLASH_ERROR_MIS
N#define FLASH_ERROR_FAST              HAL_FLASH_ERROR_FAST
N#define FLASH_ERROR_FWWERR            HAL_FLASH_ERROR_FWWERR
N#define FLASH_ERROR_NOTZERO           HAL_FLASH_ERROR_NOTZERO
N#define FLASH_ERROR_OPERATION         HAL_FLASH_ERROR_OPERATION
N#define FLASH_ERROR_ERS               HAL_FLASH_ERROR_ERS
N#define OB_WDG_SW                     OB_IWDG_SW
N#define OB_WDG_HW                     OB_IWDG_HW
N#define OB_SDADC12_VDD_MONITOR_SET    OB_SDACD_VDD_MONITOR_SET
N#define OB_SDADC12_VDD_MONITOR_RESET  OB_SDACD_VDD_MONITOR_RESET
N#define OB_RAM_PARITY_CHECK_SET       OB_SRAM_PARITY_SET
N#define OB_RAM_PARITY_CHECK_RESET     OB_SRAM_PARITY_RESET
N#define IS_OB_SDADC12_VDD_MONITOR     IS_OB_SDACD_VDD_MONITOR
N#define OB_RDP_LEVEL0                 OB_RDP_LEVEL_0
N#define OB_RDP_LEVEL1                 OB_RDP_LEVEL_1
N#define OB_RDP_LEVEL2                 OB_RDP_LEVEL_2
N/**
N  * @}
N  */
N  
N/** @defgroup HAL_SYSCFG_Aliased_Defines HAL SYSCFG Aliased Defines maintained for legacy purpose
N  * @{
N  */
N  
N#define HAL_SYSCFG_FASTMODEPLUS_I2C_PA9    I2C_FASTMODEPLUS_PA9
N#define HAL_SYSCFG_FASTMODEPLUS_I2C_PA10   I2C_FASTMODEPLUS_PA10
N#define HAL_SYSCFG_FASTMODEPLUS_I2C_PB6    I2C_FASTMODEPLUS_PB6
N#define HAL_SYSCFG_FASTMODEPLUS_I2C_PB7    I2C_FASTMODEPLUS_PB7
N#define HAL_SYSCFG_FASTMODEPLUS_I2C_PB8    I2C_FASTMODEPLUS_PB8
N#define HAL_SYSCFG_FASTMODEPLUS_I2C_PB9    I2C_FASTMODEPLUS_PB9
N#define HAL_SYSCFG_FASTMODEPLUS_I2C1       I2C_FASTMODEPLUS_I2C1
N#define HAL_SYSCFG_FASTMODEPLUS_I2C2       I2C_FASTMODEPLUS_I2C2
N#define HAL_SYSCFG_FASTMODEPLUS_I2C3       I2C_FASTMODEPLUS_I2C3
N/**
N  * @}
N  */
N  
N
N/** @defgroup LL_FMC_Aliased_Defines LL FMC Aliased Defines maintained for compatibility purpose
N  * @{
N  */
N#if defined(STM32L4) || defined(STM32F7)
X#if 0L || 1L
N#define FMC_NAND_PCC_WAIT_FEATURE_DISABLE       FMC_NAND_WAIT_FEATURE_DISABLE
N#define FMC_NAND_PCC_WAIT_FEATURE_ENABLE        FMC_NAND_WAIT_FEATURE_ENABLE
N#define FMC_NAND_PCC_MEM_BUS_WIDTH_8            FMC_NAND_MEM_BUS_WIDTH_8
N#define FMC_NAND_PCC_MEM_BUS_WIDTH_16           FMC_NAND_MEM_BUS_WIDTH_16
N#else
S#define FMC_NAND_WAIT_FEATURE_DISABLE           FMC_NAND_PCC_WAIT_FEATURE_DISABLE
S#define FMC_NAND_WAIT_FEATURE_ENABLE            FMC_NAND_PCC_WAIT_FEATURE_ENABLE
S#define FMC_NAND_MEM_BUS_WIDTH_8                FMC_NAND_PCC_MEM_BUS_WIDTH_8
S#define FMC_NAND_MEM_BUS_WIDTH_16               FMC_NAND_PCC_MEM_BUS_WIDTH_16
N#endif
N/**
N  * @}
N  */
N
N/** @defgroup LL_FSMC_Aliased_Defines LL FSMC Aliased Defines maintained for legacy purpose
N  * @{
N  */
N  
N#define FSMC_NORSRAM_TYPEDEF                      FSMC_NORSRAM_TypeDef
N#define FSMC_NORSRAM_EXTENDED_TYPEDEF             FSMC_NORSRAM_EXTENDED_TypeDef
N/**
N  * @}
N  */
N
N/** @defgroup HAL_GPIO_Aliased_Macros HAL GPIO Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define GET_GPIO_SOURCE                           GPIO_GET_INDEX
N#define GET_GPIO_INDEX                            GPIO_GET_INDEX
N
N#if defined(STM32F4)
X#if 0L
S#define GPIO_AF12_SDMMC                           GPIO_AF12_SDIO
S#define GPIO_AF12_SDMMC1                          GPIO_AF12_SDIO
N#endif
N
N#if defined(STM32F7)
X#if 1L
N#define GPIO_AF12_SDIO                            GPIO_AF12_SDMMC1
N#define GPIO_AF12_SDMMC                           GPIO_AF12_SDMMC1
N#endif
N
N#if defined(STM32L4)
X#if 0L
S#define GPIO_AF12_SDIO                            GPIO_AF12_SDMMC1
S#define GPIO_AF12_SDMMC                           GPIO_AF12_SDMMC1
N#endif
N
N#define GPIO_AF0_LPTIM                            GPIO_AF0_LPTIM1
N#define GPIO_AF1_LPTIM                            GPIO_AF1_LPTIM1
N#define GPIO_AF2_LPTIM                            GPIO_AF2_LPTIM1
N
N#if defined(STM32L0) || defined(STM32L4) || defined(STM32F4) || defined(STM32F2) || defined(STM32F7)
X#if 0L || 0L || 0L || 0L || 1L
N#define  GPIO_SPEED_LOW                           GPIO_SPEED_FREQ_LOW     
N#define  GPIO_SPEED_MEDIUM                        GPIO_SPEED_FREQ_MEDIUM     
N#define  GPIO_SPEED_FAST                          GPIO_SPEED_FREQ_HIGH     
N#define  GPIO_SPEED_HIGH                          GPIO_SPEED_FREQ_VERY_HIGH       
N#endif /* STM32L0 || STM32L4 || STM32F4 || STM32F2 || STM32F7 */
N
N#if defined(STM32L1) 
X#if 0L 
S #define  GPIO_SPEED_VERY_LOW    GPIO_SPEED_FREQ_LOW     
S #define  GPIO_SPEED_LOW         GPIO_SPEED_FREQ_MEDIUM     
S #define  GPIO_SPEED_MEDIUM      GPIO_SPEED_FREQ_HIGH     
S #define  GPIO_SPEED_HIGH        GPIO_SPEED_FREQ_VERY_HIGH     
N#endif /* STM32L1 */
N
N#if defined(STM32F0) || defined(STM32F3) || defined(STM32F1)
X#if 0L || 0L || 0L
S #define  GPIO_SPEED_LOW    GPIO_SPEED_FREQ_LOW
S #define  GPIO_SPEED_MEDIUM GPIO_SPEED_FREQ_MEDIUM
S #define  GPIO_SPEED_HIGH   GPIO_SPEED_FREQ_HIGH
N#endif /* STM32F0 || STM32F3 || STM32F1 */
N
N#define GPIO_AF6_DFSDM                            GPIO_AF6_DFSDM1
N/**
N  * @}
N  */
N
N/** @defgroup HAL_HRTIM_Aliased_Macros HAL HRTIM Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define HRTIM_TIMDELAYEDPROTECTION_DISABLED           HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DISABLED
N#define HRTIM_TIMDELAYEDPROTECTION_DELAYEDOUT1_EEV68  HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DELAYEDOUT1_EEV6
N#define HRTIM_TIMDELAYEDPROTECTION_DELAYEDOUT2_EEV68  HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DELAYEDOUT2_EEV6
N#define HRTIM_TIMDELAYEDPROTECTION_DELAYEDBOTH_EEV68  HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DELAYEDBOTH_EEV6
N#define HRTIM_TIMDELAYEDPROTECTION_BALANCED_EEV68     HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_BALANCED_EEV6
N#define HRTIM_TIMDELAYEDPROTECTION_DELAYEDOUT1_DEEV79 HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DELAYEDOUT1_DEEV7
N#define HRTIM_TIMDELAYEDPROTECTION_DELAYEDOUT2_DEEV79 HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DELAYEDOUT2_DEEV7
N#define HRTIM_TIMDELAYEDPROTECTION_DELAYEDBOTH_EEV79  HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DELAYEDBOTH_EEV7
N#define HRTIM_TIMDELAYEDPROTECTION_BALANCED_EEV79     HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_BALANCED_EEV7
N   
N#define __HAL_HRTIM_SetCounter        __HAL_HRTIM_SETCOUNTER
N#define __HAL_HRTIM_GetCounter        __HAL_HRTIM_GETCOUNTER
N#define __HAL_HRTIM_SetPeriod         __HAL_HRTIM_SETPERIOD
N#define __HAL_HRTIM_GetPeriod         __HAL_HRTIM_GETPERIOD
N#define __HAL_HRTIM_SetClockPrescaler __HAL_HRTIM_SETCLOCKPRESCALER
N#define __HAL_HRTIM_GetClockPrescaler __HAL_HRTIM_GETCLOCKPRESCALER
N#define __HAL_HRTIM_SetCompare        __HAL_HRTIM_SETCOMPARE
N#define __HAL_HRTIM_GetCompare        __HAL_HRTIM_GETCOMPARE
N/**
N  * @}
N  */
N
N/** @defgroup HAL_I2C_Aliased_Defines HAL I2C Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define I2C_DUALADDRESS_DISABLED                I2C_DUALADDRESS_DISABLE
N#define I2C_DUALADDRESS_ENABLED                 I2C_DUALADDRESS_ENABLE
N#define I2C_GENERALCALL_DISABLED                I2C_GENERALCALL_DISABLE
N#define I2C_GENERALCALL_ENABLED                 I2C_GENERALCALL_ENABLE
N#define I2C_NOSTRETCH_DISABLED                  I2C_NOSTRETCH_DISABLE
N#define I2C_NOSTRETCH_ENABLED                   I2C_NOSTRETCH_ENABLE
N#define I2C_ANALOGFILTER_ENABLED                I2C_ANALOGFILTER_ENABLE
N#define I2C_ANALOGFILTER_DISABLED               I2C_ANALOGFILTER_DISABLE
N#if defined(STM32F0) || defined(STM32F1) || defined(STM32F3) || defined(STM32G0) || defined(STM32L4) || defined(STM32L1) || defined(STM32F7)
X#if 0L || 0L || 0L || 0L || 0L || 0L || 1L
N#define HAL_I2C_STATE_MEM_BUSY_TX               HAL_I2C_STATE_BUSY_TX
N#define HAL_I2C_STATE_MEM_BUSY_RX               HAL_I2C_STATE_BUSY_RX
N#define HAL_I2C_STATE_MASTER_BUSY_TX            HAL_I2C_STATE_BUSY_TX
N#define HAL_I2C_STATE_MASTER_BUSY_RX            HAL_I2C_STATE_BUSY_RX
N#define HAL_I2C_STATE_SLAVE_BUSY_TX             HAL_I2C_STATE_BUSY_TX
N#define HAL_I2C_STATE_SLAVE_BUSY_RX             HAL_I2C_STATE_BUSY_RX
N#endif
N/**
N  * @}
N  */
N
N/** @defgroup HAL_IRDA_Aliased_Defines HAL IRDA Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define IRDA_ONE_BIT_SAMPLE_DISABLED            IRDA_ONE_BIT_SAMPLE_DISABLE
N#define IRDA_ONE_BIT_SAMPLE_ENABLED             IRDA_ONE_BIT_SAMPLE_ENABLE
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_IWDG_Aliased_Defines HAL IWDG Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define KR_KEY_RELOAD                   IWDG_KEY_RELOAD
N#define KR_KEY_ENABLE                   IWDG_KEY_ENABLE
N#define KR_KEY_EWA                      IWDG_KEY_WRITE_ACCESS_ENABLE
N#define KR_KEY_DWA                      IWDG_KEY_WRITE_ACCESS_DISABLE
N/**
N  * @}
N  */
N
N/** @defgroup HAL_LPTIM_Aliased_Defines HAL LPTIM Aliased Defines maintained for legacy purpose
N  * @{
N  */
N
N#define LPTIM_CLOCKSAMPLETIME_DIRECTTRANSISTION LPTIM_CLOCKSAMPLETIME_DIRECTTRANSITION
N#define LPTIM_CLOCKSAMPLETIME_2TRANSISTIONS     LPTIM_CLOCKSAMPLETIME_2TRANSITIONS
N#define LPTIM_CLOCKSAMPLETIME_4TRANSISTIONS     LPTIM_CLOCKSAMPLETIME_4TRANSITIONS
N#define LPTIM_CLOCKSAMPLETIME_8TRANSISTIONS     LPTIM_CLOCKSAMPLETIME_8TRANSITIONS
N
N#define LPTIM_CLOCKPOLARITY_RISINGEDGE          LPTIM_CLOCKPOLARITY_RISING
N#define LPTIM_CLOCKPOLARITY_FALLINGEDGE         LPTIM_CLOCKPOLARITY_FALLING
N#define LPTIM_CLOCKPOLARITY_BOTHEDGES           LPTIM_CLOCKPOLARITY_RISING_FALLING
N
N#define LPTIM_TRIGSAMPLETIME_DIRECTTRANSISTION  LPTIM_TRIGSAMPLETIME_DIRECTTRANSITION
N#define LPTIM_TRIGSAMPLETIME_2TRANSISTIONS      LPTIM_TRIGSAMPLETIME_2TRANSITIONS
N#define LPTIM_TRIGSAMPLETIME_4TRANSISTIONS      LPTIM_TRIGSAMPLETIME_4TRANSITIONS
N#define LPTIM_TRIGSAMPLETIME_8TRANSISTIONS      LPTIM_TRIGSAMPLETIME_8TRANSITIONS        
N
N/* The following 3 definition have also been present in a temporary version of lptim.h */
N/* They need to be renamed also to the right name, just in case */
N#define LPTIM_TRIGSAMPLETIME_2TRANSITION        LPTIM_TRIGSAMPLETIME_2TRANSITIONS
N#define LPTIM_TRIGSAMPLETIME_4TRANSITION        LPTIM_TRIGSAMPLETIME_4TRANSITIONS
N#define LPTIM_TRIGSAMPLETIME_8TRANSITION        LPTIM_TRIGSAMPLETIME_8TRANSITIONS
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_NAND_Aliased_Defines HAL NAND Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define HAL_NAND_Read_Page              HAL_NAND_Read_Page_8b
N#define HAL_NAND_Write_Page             HAL_NAND_Write_Page_8b
N#define HAL_NAND_Read_SpareArea         HAL_NAND_Read_SpareArea_8b
N#define HAL_NAND_Write_SpareArea        HAL_NAND_Write_SpareArea_8b
N
N#define NAND_AddressTypedef             NAND_AddressTypeDef
N
N#define __ARRAY_ADDRESS                 ARRAY_ADDRESS
N#define __ADDR_1st_CYCLE                ADDR_1ST_CYCLE
N#define __ADDR_2nd_CYCLE                ADDR_2ND_CYCLE
N#define __ADDR_3rd_CYCLE                ADDR_3RD_CYCLE
N#define __ADDR_4th_CYCLE                ADDR_4TH_CYCLE
N/**
N  * @}
N  */
N   
N/** @defgroup HAL_NOR_Aliased_Defines HAL NOR Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define NOR_StatusTypedef              HAL_NOR_StatusTypeDef
N#define NOR_SUCCESS                    HAL_NOR_STATUS_SUCCESS
N#define NOR_ONGOING                    HAL_NOR_STATUS_ONGOING
N#define NOR_ERROR                      HAL_NOR_STATUS_ERROR
N#define NOR_TIMEOUT                    HAL_NOR_STATUS_TIMEOUT
N
N#define __NOR_WRITE                    NOR_WRITE
N#define __NOR_ADDR_SHIFT               NOR_ADDR_SHIFT
N/**
N  * @}
N  */
N
N/** @defgroup HAL_OPAMP_Aliased_Defines HAL OPAMP Aliased Defines maintained for legacy purpose
N  * @{
N  */
N
N#define OPAMP_NONINVERTINGINPUT_VP0           OPAMP_NONINVERTINGINPUT_IO0
N#define OPAMP_NONINVERTINGINPUT_VP1           OPAMP_NONINVERTINGINPUT_IO1
N#define OPAMP_NONINVERTINGINPUT_VP2           OPAMP_NONINVERTINGINPUT_IO2
N#define OPAMP_NONINVERTINGINPUT_VP3           OPAMP_NONINVERTINGINPUT_IO3
N                                              
N#define OPAMP_SEC_NONINVERTINGINPUT_VP0       OPAMP_SEC_NONINVERTINGINPUT_IO0
N#define OPAMP_SEC_NONINVERTINGINPUT_VP1       OPAMP_SEC_NONINVERTINGINPUT_IO1
N#define OPAMP_SEC_NONINVERTINGINPUT_VP2       OPAMP_SEC_NONINVERTINGINPUT_IO2
N#define OPAMP_SEC_NONINVERTINGINPUT_VP3       OPAMP_SEC_NONINVERTINGINPUT_IO3   
N
N#define OPAMP_INVERTINGINPUT_VM0              OPAMP_INVERTINGINPUT_IO0
N#define OPAMP_INVERTINGINPUT_VM1              OPAMP_INVERTINGINPUT_IO1
N
N#define IOPAMP_INVERTINGINPUT_VM0             OPAMP_INVERTINGINPUT_IO0
N#define IOPAMP_INVERTINGINPUT_VM1             OPAMP_INVERTINGINPUT_IO1
N
N#define OPAMP_SEC_INVERTINGINPUT_VM0          OPAMP_SEC_INVERTINGINPUT_IO0
N#define OPAMP_SEC_INVERTINGINPUT_VM1          OPAMP_SEC_INVERTINGINPUT_IO1    
N
N#define OPAMP_INVERTINGINPUT_VINM             OPAMP_SEC_INVERTINGINPUT_IO1
N                                                                      
N#define OPAMP_PGACONNECT_NO                   OPAMP_PGA_CONNECT_INVERTINGINPUT_NO             
N#define OPAMP_PGACONNECT_VM0                  OPAMP_PGA_CONNECT_INVERTINGINPUT_IO0            
N#define OPAMP_PGACONNECT_VM1                  OPAMP_PGA_CONNECT_INVERTINGINPUT_IO1          
N                                                        
N/**
N  * @}
N  */
N
N/** @defgroup HAL_I2S_Aliased_Defines HAL I2S Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define I2S_STANDARD_PHILLIPS      I2S_STANDARD_PHILIPS
N#if defined(STM32F7) 
X#if 1L 
N  #define I2S_CLOCK_SYSCLK           I2S_CLOCK_PLL
N#endif
N/**
N  * @}
N  */
N
N/** @defgroup HAL_PCCARD_Aliased_Defines HAL PCCARD Aliased Defines maintained for legacy purpose
N  * @{
N  */
N
N/* Compact Flash-ATA registers description */
N#define CF_DATA                       ATA_DATA                
N#define CF_SECTOR_COUNT               ATA_SECTOR_COUNT        
N#define CF_SECTOR_NUMBER              ATA_SECTOR_NUMBER       
N#define CF_CYLINDER_LOW               ATA_CYLINDER_LOW        
N#define CF_CYLINDER_HIGH              ATA_CYLINDER_HIGH       
N#define CF_CARD_HEAD                  ATA_CARD_HEAD           
N#define CF_STATUS_CMD                 ATA_STATUS_CMD          
N#define CF_STATUS_CMD_ALTERNATE       ATA_STATUS_CMD_ALTERNATE
N#define CF_COMMON_DATA_AREA           ATA_COMMON_DATA_AREA    
N
N/* Compact Flash-ATA commands */
N#define CF_READ_SECTOR_CMD            ATA_READ_SECTOR_CMD 
N#define CF_WRITE_SECTOR_CMD           ATA_WRITE_SECTOR_CMD
N#define CF_ERASE_SECTOR_CMD           ATA_ERASE_SECTOR_CMD
N#define CF_IDENTIFY_CMD               ATA_IDENTIFY_CMD
N
N#define PCCARD_StatusTypedef          HAL_PCCARD_StatusTypeDef
N#define PCCARD_SUCCESS                HAL_PCCARD_STATUS_SUCCESS
N#define PCCARD_ONGOING                HAL_PCCARD_STATUS_ONGOING
N#define PCCARD_ERROR                  HAL_PCCARD_STATUS_ERROR
N#define PCCARD_TIMEOUT                HAL_PCCARD_STATUS_TIMEOUT
N/**
N  * @}
N  */
N  
N/** @defgroup HAL_RTC_Aliased_Defines HAL RTC Aliased Defines maintained for legacy purpose
N  * @{
N  */
N  
N#define FORMAT_BIN                  RTC_FORMAT_BIN
N#define FORMAT_BCD                  RTC_FORMAT_BCD
N
N#define RTC_ALARMSUBSECONDMASK_None     RTC_ALARMSUBSECONDMASK_NONE
N#define RTC_TAMPERERASEBACKUP_ENABLED   RTC_TAMPER_ERASE_BACKUP_ENABLE
N#define RTC_TAMPERERASEBACKUP_DISABLED  RTC_TAMPER_ERASE_BACKUP_DISABLE
N#define RTC_TAMPERMASK_FLAG_DISABLED    RTC_TAMPERMASK_FLAG_DISABLE
N#define RTC_TAMPERMASK_FLAG_ENABLED     RTC_TAMPERMASK_FLAG_ENABLE
N
N#define RTC_MASKTAMPERFLAG_DISABLED     RTC_TAMPERMASK_FLAG_DISABLE 
N#define RTC_MASKTAMPERFLAG_ENABLED      RTC_TAMPERMASK_FLAG_ENABLE 
N#define RTC_TAMPERERASEBACKUP_ENABLED   RTC_TAMPER_ERASE_BACKUP_ENABLE
N#define RTC_TAMPERERASEBACKUP_DISABLED  RTC_TAMPER_ERASE_BACKUP_DISABLE 
N#define RTC_MASKTAMPERFLAG_DISABLED     RTC_TAMPERMASK_FLAG_DISABLE 
N#define RTC_MASKTAMPERFLAG_ENABLED      RTC_TAMPERMASK_FLAG_ENABLE
N#define RTC_TAMPER1_2_INTERRUPT         RTC_ALL_TAMPER_INTERRUPT 
N#define RTC_TAMPER1_2_3_INTERRUPT       RTC_ALL_TAMPER_INTERRUPT 
N
N#define RTC_TIMESTAMPPIN_PC13  RTC_TIMESTAMPPIN_DEFAULT
N#define RTC_TIMESTAMPPIN_PA0 RTC_TIMESTAMPPIN_POS1 
N#define RTC_TIMESTAMPPIN_PI8 RTC_TIMESTAMPPIN_POS1
N#define RTC_TIMESTAMPPIN_PC1   RTC_TIMESTAMPPIN_POS2
N
N#define RTC_OUTPUT_REMAP_PC13  RTC_OUTPUT_REMAP_NONE
N#define RTC_OUTPUT_REMAP_PB14  RTC_OUTPUT_REMAP_POS1
N#define RTC_OUTPUT_REMAP_PB2   RTC_OUTPUT_REMAP_POS1
N
N#define RTC_TAMPERPIN_PC13 RTC_TAMPERPIN_DEFAULT 
N#define RTC_TAMPERPIN_PA0  RTC_TAMPERPIN_POS1 
N#define RTC_TAMPERPIN_PI8  RTC_TAMPERPIN_POS1
N
N/**
N  * @}
N  */
N
N  
N/** @defgroup HAL_SMARTCARD_Aliased_Defines HAL SMARTCARD Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define SMARTCARD_NACK_ENABLED                  SMARTCARD_NACK_ENABLE
N#define SMARTCARD_NACK_DISABLED                 SMARTCARD_NACK_DISABLE
N
N#define SMARTCARD_ONEBIT_SAMPLING_DISABLED      SMARTCARD_ONE_BIT_SAMPLE_DISABLE
N#define SMARTCARD_ONEBIT_SAMPLING_ENABLED       SMARTCARD_ONE_BIT_SAMPLE_ENABLE
N#define SMARTCARD_ONEBIT_SAMPLING_DISABLE       SMARTCARD_ONE_BIT_SAMPLE_DISABLE
N#define SMARTCARD_ONEBIT_SAMPLING_ENABLE        SMARTCARD_ONE_BIT_SAMPLE_ENABLE
N
N#define SMARTCARD_TIMEOUT_DISABLED              SMARTCARD_TIMEOUT_DISABLE
N#define SMARTCARD_TIMEOUT_ENABLED               SMARTCARD_TIMEOUT_ENABLE
N
N#define SMARTCARD_LASTBIT_DISABLED              SMARTCARD_LASTBIT_DISABLE
N#define SMARTCARD_LASTBIT_ENABLED               SMARTCARD_LASTBIT_ENABLE
N/**
N  * @}
N  */
N
N  
N/** @defgroup HAL_SMBUS_Aliased_Defines HAL SMBUS Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define SMBUS_DUALADDRESS_DISABLED      SMBUS_DUALADDRESS_DISABLE
N#define SMBUS_DUALADDRESS_ENABLED       SMBUS_DUALADDRESS_ENABLE
N#define SMBUS_GENERALCALL_DISABLED      SMBUS_GENERALCALL_DISABLE
N#define SMBUS_GENERALCALL_ENABLED       SMBUS_GENERALCALL_ENABLE
N#define SMBUS_NOSTRETCH_DISABLED        SMBUS_NOSTRETCH_DISABLE
N#define SMBUS_NOSTRETCH_ENABLED         SMBUS_NOSTRETCH_ENABLE
N#define SMBUS_ANALOGFILTER_ENABLED      SMBUS_ANALOGFILTER_ENABLE
N#define SMBUS_ANALOGFILTER_DISABLED     SMBUS_ANALOGFILTER_DISABLE
N#define SMBUS_PEC_DISABLED              SMBUS_PEC_DISABLE
N#define SMBUS_PEC_ENABLED               SMBUS_PEC_ENABLE
N#define HAL_SMBUS_STATE_SLAVE_LISTEN    HAL_SMBUS_STATE_LISTEN
N/**
N  * @}
N  */
N  
N/** @defgroup HAL_SPI_Aliased_Defines HAL SPI Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define SPI_TIMODE_DISABLED             SPI_TIMODE_DISABLE
N#define SPI_TIMODE_ENABLED              SPI_TIMODE_ENABLE
N
N#define SPI_CRCCALCULATION_DISABLED     SPI_CRCCALCULATION_DISABLE
N#define SPI_CRCCALCULATION_ENABLED      SPI_CRCCALCULATION_ENABLE
N
N#define SPI_NSS_PULSE_DISABLED          SPI_NSS_PULSE_DISABLE
N#define SPI_NSS_PULSE_ENABLED           SPI_NSS_PULSE_ENABLE
N
N/**
N  * @}
N  */
N  
N/** @defgroup HAL_TIM_Aliased_Defines HAL TIM Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define CCER_CCxE_MASK                   TIM_CCER_CCxE_MASK
N#define CCER_CCxNE_MASK                  TIM_CCER_CCxNE_MASK
N  
N#define TIM_DMABase_CR1                  TIM_DMABASE_CR1
N#define TIM_DMABase_CR2                  TIM_DMABASE_CR2
N#define TIM_DMABase_SMCR                 TIM_DMABASE_SMCR
N#define TIM_DMABase_DIER                 TIM_DMABASE_DIER
N#define TIM_DMABase_SR                   TIM_DMABASE_SR
N#define TIM_DMABase_EGR                  TIM_DMABASE_EGR
N#define TIM_DMABase_CCMR1                TIM_DMABASE_CCMR1
N#define TIM_DMABase_CCMR2                TIM_DMABASE_CCMR2
N#define TIM_DMABase_CCER                 TIM_DMABASE_CCER
N#define TIM_DMABase_CNT                  TIM_DMABASE_CNT
N#define TIM_DMABase_PSC                  TIM_DMABASE_PSC
N#define TIM_DMABase_ARR                  TIM_DMABASE_ARR
N#define TIM_DMABase_RCR                  TIM_DMABASE_RCR
N#define TIM_DMABase_CCR1                 TIM_DMABASE_CCR1
N#define TIM_DMABase_CCR2                 TIM_DMABASE_CCR2
N#define TIM_DMABase_CCR3                 TIM_DMABASE_CCR3
N#define TIM_DMABase_CCR4                 TIM_DMABASE_CCR4
N#define TIM_DMABase_BDTR                 TIM_DMABASE_BDTR
N#define TIM_DMABase_DCR                  TIM_DMABASE_DCR
N#define TIM_DMABase_DMAR                 TIM_DMABASE_DMAR
N#define TIM_DMABase_OR1                  TIM_DMABASE_OR1
N#define TIM_DMABase_CCMR3                TIM_DMABASE_CCMR3
N#define TIM_DMABase_CCR5                 TIM_DMABASE_CCR5
N#define TIM_DMABase_CCR6                 TIM_DMABASE_CCR6
N#define TIM_DMABase_OR2                  TIM_DMABASE_OR2
N#define TIM_DMABase_OR3                  TIM_DMABASE_OR3
N#define TIM_DMABase_OR                   TIM_DMABASE_OR
N
N#define TIM_EventSource_Update           TIM_EVENTSOURCE_UPDATE
N#define TIM_EventSource_CC1              TIM_EVENTSOURCE_CC1
N#define TIM_EventSource_CC2              TIM_EVENTSOURCE_CC2
N#define TIM_EventSource_CC3              TIM_EVENTSOURCE_CC3
N#define TIM_EventSource_CC4              TIM_EVENTSOURCE_CC4
N#define TIM_EventSource_COM              TIM_EVENTSOURCE_COM
N#define TIM_EventSource_Trigger          TIM_EVENTSOURCE_TRIGGER
N#define TIM_EventSource_Break            TIM_EVENTSOURCE_BREAK
N#define TIM_EventSource_Break2           TIM_EVENTSOURCE_BREAK2
N
N#define TIM_DMABurstLength_1Transfer     TIM_DMABURSTLENGTH_1TRANSFER
N#define TIM_DMABurstLength_2Transfers    TIM_DMABURSTLENGTH_2TRANSFERS
N#define TIM_DMABurstLength_3Transfers    TIM_DMABURSTLENGTH_3TRANSFERS
N#define TIM_DMABurstLength_4Transfers    TIM_DMABURSTLENGTH_4TRANSFERS
N#define TIM_DMABurstLength_5Transfers    TIM_DMABURSTLENGTH_5TRANSFERS
N#define TIM_DMABurstLength_6Transfers    TIM_DMABURSTLENGTH_6TRANSFERS
N#define TIM_DMABurstLength_7Transfers    TIM_DMABURSTLENGTH_7TRANSFERS
N#define TIM_DMABurstLength_8Transfers    TIM_DMABURSTLENGTH_8TRANSFERS
N#define TIM_DMABurstLength_9Transfers    TIM_DMABURSTLENGTH_9TRANSFERS
N#define TIM_DMABurstLength_10Transfers   TIM_DMABURSTLENGTH_10TRANSFERS
N#define TIM_DMABurstLength_11Transfers   TIM_DMABURSTLENGTH_11TRANSFERS
N#define TIM_DMABurstLength_12Transfers   TIM_DMABURSTLENGTH_12TRANSFERS
N#define TIM_DMABurstLength_13Transfers   TIM_DMABURSTLENGTH_13TRANSFERS
N#define TIM_DMABurstLength_14Transfers   TIM_DMABURSTLENGTH_14TRANSFERS
N#define TIM_DMABurstLength_15Transfers   TIM_DMABURSTLENGTH_15TRANSFERS
N#define TIM_DMABurstLength_16Transfers   TIM_DMABURSTLENGTH_16TRANSFERS
N#define TIM_DMABurstLength_17Transfers   TIM_DMABURSTLENGTH_17TRANSFERS
N#define TIM_DMABurstLength_18Transfers   TIM_DMABURSTLENGTH_18TRANSFERS
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_TSC_Aliased_Defines HAL TSC Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define TSC_SYNC_POL_FALL        TSC_SYNC_POLARITY_FALLING
N#define TSC_SYNC_POL_RISE_HIGH   TSC_SYNC_POLARITY_RISING
N/**
N  * @}
N  */
N
N/** @defgroup HAL_UART_Aliased_Defines HAL UART Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define UART_ONEBIT_SAMPLING_DISABLED   UART_ONE_BIT_SAMPLE_DISABLE
N#define UART_ONEBIT_SAMPLING_ENABLED    UART_ONE_BIT_SAMPLE_ENABLE
N#define UART_ONE_BIT_SAMPLE_DISABLED    UART_ONE_BIT_SAMPLE_DISABLE
N#define UART_ONE_BIT_SAMPLE_ENABLED     UART_ONE_BIT_SAMPLE_ENABLE
N
N#define __HAL_UART_ONEBIT_ENABLE        __HAL_UART_ONE_BIT_SAMPLE_ENABLE
N#define __HAL_UART_ONEBIT_DISABLE       __HAL_UART_ONE_BIT_SAMPLE_DISABLE
N
N#define __DIV_SAMPLING16                UART_DIV_SAMPLING16
N#define __DIVMANT_SAMPLING16            UART_DIVMANT_SAMPLING16
N#define __DIVFRAQ_SAMPLING16            UART_DIVFRAQ_SAMPLING16
N#define __UART_BRR_SAMPLING16           UART_BRR_SAMPLING16
N
N#define __DIV_SAMPLING8                 UART_DIV_SAMPLING8
N#define __DIVMANT_SAMPLING8             UART_DIVMANT_SAMPLING8
N#define __DIVFRAQ_SAMPLING8             UART_DIVFRAQ_SAMPLING8
N#define __UART_BRR_SAMPLING8            UART_BRR_SAMPLING8
N
N#define UART_WAKEUPMETHODE_IDLELINE     UART_WAKEUPMETHOD_IDLELINE
N#define UART_WAKEUPMETHODE_ADDRESSMARK  UART_WAKEUPMETHOD_ADDRESSMARK
N
N/**
N  * @}
N  */
N
N  
N/** @defgroup HAL_USART_Aliased_Defines HAL USART Aliased Defines maintained for legacy purpose
N  * @{
N  */
N
N#define USART_CLOCK_DISABLED            USART_CLOCK_DISABLE
N#define USART_CLOCK_ENABLED             USART_CLOCK_ENABLE
N
N#define USARTNACK_ENABLED               USART_NACK_ENABLE
N#define USARTNACK_DISABLED              USART_NACK_DISABLE
N/**
N  * @}
N  */
N
N/** @defgroup HAL_WWDG_Aliased_Defines HAL WWDG Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define CFR_BASE                    WWDG_CFR_BASE
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_CAN_Aliased_Defines HAL CAN Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define CAN_FilterFIFO0             CAN_FILTER_FIFO0
N#define CAN_FilterFIFO1             CAN_FILTER_FIFO1
N#define CAN_IT_RQCP0                CAN_IT_TME
N#define CAN_IT_RQCP1                CAN_IT_TME
N#define CAN_IT_RQCP2                CAN_IT_TME
N#define INAK_TIMEOUT                CAN_TIMEOUT_VALUE
N#define SLAK_TIMEOUT                CAN_TIMEOUT_VALUE
N#define CAN_TXSTATUS_FAILED         ((uint8_t)0x00U)
N#define CAN_TXSTATUS_OK             ((uint8_t)0x01U)
N#define CAN_TXSTATUS_PENDING        ((uint8_t)0x02U)
N
N/**
N  * @}
N  */
N  
N/** @defgroup HAL_ETH_Aliased_Defines HAL ETH Aliased Defines maintained for legacy purpose
N  * @{
N  */
N
N#define VLAN_TAG                ETH_VLAN_TAG
N#define MIN_ETH_PAYLOAD         ETH_MIN_ETH_PAYLOAD
N#define MAX_ETH_PAYLOAD         ETH_MAX_ETH_PAYLOAD
N#define JUMBO_FRAME_PAYLOAD     ETH_JUMBO_FRAME_PAYLOAD
N#define MACMIIAR_CR_MASK        ETH_MACMIIAR_CR_MASK
N#define MACCR_CLEAR_MASK        ETH_MACCR_CLEAR_MASK
N#define MACFCR_CLEAR_MASK       ETH_MACFCR_CLEAR_MASK
N#define DMAOMR_CLEAR_MASK       ETH_DMAOMR_CLEAR_MASK
N
N#define ETH_MMCCR              ((uint32_t)0x00000100U)  
N#define ETH_MMCRIR             ((uint32_t)0x00000104U)  
N#define ETH_MMCTIR             ((uint32_t)0x00000108U)  
N#define ETH_MMCRIMR            ((uint32_t)0x0000010CU)  
N#define ETH_MMCTIMR            ((uint32_t)0x00000110U)  
N#define ETH_MMCTGFSCCR         ((uint32_t)0x0000014CU)  
N#define ETH_MMCTGFMSCCR        ((uint32_t)0x00000150U)  
N#define ETH_MMCTGFCR           ((uint32_t)0x00000168U)  
N#define ETH_MMCRFCECR          ((uint32_t)0x00000194U)  
N#define ETH_MMCRFAECR          ((uint32_t)0x00000198U)  
N#define ETH_MMCRGUFCR          ((uint32_t)0x000001C4U)
N 
N#define ETH_MAC_TXFIFO_FULL          ((uint32_t)0x02000000)  /* Tx FIFO full */
N#define ETH_MAC_TXFIFONOT_EMPTY      ((uint32_t)0x01000000)  /* Tx FIFO not empty */
N#define ETH_MAC_TXFIFO_WRITE_ACTIVE  ((uint32_t)0x00400000)  /* Tx FIFO write active */
N#define ETH_MAC_TXFIFO_IDLE     ((uint32_t)0x00000000)  /* Tx FIFO read status: Idle */
N#define ETH_MAC_TXFIFO_READ     ((uint32_t)0x00100000)  /* Tx FIFO read status: Read (transferring data to the MAC transmitter) */
N#define ETH_MAC_TXFIFO_WAITING  ((uint32_t)0x00200000)  /* Tx FIFO read status: Waiting for TxStatus from MAC transmitter */
N#define ETH_MAC_TXFIFO_WRITING  ((uint32_t)0x00300000)  /* Tx FIFO read status: Writing the received TxStatus or flushing the TxFIFO */
N#define ETH_MAC_TRANSMISSION_PAUSE     ((uint32_t)0x00080000)  /* MAC transmitter in pause */
N#define ETH_MAC_TRANSMITFRAMECONTROLLER_IDLE            ((uint32_t)0x00000000)  /* MAC transmit frame controller: Idle */
N#define ETH_MAC_TRANSMITFRAMECONTROLLER_WAITING         ((uint32_t)0x00020000)  /* MAC transmit frame controller: Waiting for Status of previous frame or IFG/backoff period to be over */
N#define ETH_MAC_TRANSMITFRAMECONTROLLER_GENRATING_PCF   ((uint32_t)0x00040000)  /* MAC transmit frame controller: Generating and transmitting a Pause control frame (in full duplex mode) */
N#define ETH_MAC_TRANSMITFRAMECONTROLLER_TRANSFERRING    ((uint32_t)0x00060000)  /* MAC transmit frame controller: Transferring input frame for transmission */
N#define ETH_MAC_MII_TRANSMIT_ACTIVE      ((uint32_t)0x00010000)  /* MAC MII transmit engine active */
N#define ETH_MAC_RXFIFO_EMPTY             ((uint32_t)0x00000000)  /* Rx FIFO fill level: empty */
N#define ETH_MAC_RXFIFO_BELOW_THRESHOLD   ((uint32_t)0x00000100)  /* Rx FIFO fill level: fill-level below flow-control de-activate threshold */
N#define ETH_MAC_RXFIFO_ABOVE_THRESHOLD   ((uint32_t)0x00000200)  /* Rx FIFO fill level: fill-level above flow-control activate threshold */
N#define ETH_MAC_RXFIFO_FULL              ((uint32_t)0x00000300)  /* Rx FIFO fill level: full */
N#if defined(STM32F1)
X#if 0L
N#else
N#define ETH_MAC_READCONTROLLER_IDLE               ((uint32_t)0x00000000)  /* Rx FIFO read controller IDLE state */
N#define ETH_MAC_READCONTROLLER_READING_DATA       ((uint32_t)0x00000020)  /* Rx FIFO read controller Reading frame data */
N#define ETH_MAC_READCONTROLLER_READING_STATUS     ((uint32_t)0x00000040)  /* Rx FIFO read controller Reading frame status (or time-stamp) */
N#endif
N#define ETH_MAC_READCONTROLLER_FLUSHING           ((uint32_t)0x00000060)  /* Rx FIFO read controller Flushing the frame data and status */
N#define ETH_MAC_RXFIFO_WRITE_ACTIVE     ((uint32_t)0x00000010)  /* Rx FIFO write controller active */
N#define ETH_MAC_SMALL_FIFO_NOTACTIVE    ((uint32_t)0x00000000)  /* MAC small FIFO read / write controllers not active */
N#define ETH_MAC_SMALL_FIFO_READ_ACTIVE  ((uint32_t)0x00000002)  /* MAC small FIFO read controller active */
N#define ETH_MAC_SMALL_FIFO_WRITE_ACTIVE ((uint32_t)0x00000004)  /* MAC small FIFO write controller active */
N#define ETH_MAC_SMALL_FIFO_RW_ACTIVE    ((uint32_t)0x00000006)  /* MAC small FIFO read / write controllers active */
N#define ETH_MAC_MII_RECEIVE_PROTOCOL_ACTIVE   ((uint32_t)0x00000001)  /* MAC MII receive protocol engine active */
N
N/**
N  * @}
N  */
N  
N/** @defgroup HAL_DCMI_Aliased_Defines HAL DCMI Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define HAL_DCMI_ERROR_OVF      HAL_DCMI_ERROR_OVR
N#define DCMI_IT_OVF             DCMI_IT_OVR
N#define DCMI_FLAG_OVFRI         DCMI_FLAG_OVRRI
N#define DCMI_FLAG_OVFMI         DCMI_FLAG_OVRMI
N
N#define HAL_DCMI_ConfigCROP     HAL_DCMI_ConfigCrop
N#define HAL_DCMI_EnableCROP     HAL_DCMI_EnableCrop
N#define HAL_DCMI_DisableCROP    HAL_DCMI_DisableCrop
N
N/**
N  * @}
N  */  
N  
N#if defined(STM32L4xx) || defined(STM32F7) || defined(STM32F427xx) || defined(STM32F437xx) ||\
N    defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 1L || 0L || 0L ||    0L || 0L || 0L || 0L
N/** @defgroup HAL_DMA2D_Aliased_Defines HAL DMA2D Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define DMA2D_ARGB8888          DMA2D_OUTPUT_ARGB8888
N#define DMA2D_RGB888            DMA2D_OUTPUT_RGB888  
N#define DMA2D_RGB565            DMA2D_OUTPUT_RGB565  
N#define DMA2D_ARGB1555          DMA2D_OUTPUT_ARGB1555
N#define DMA2D_ARGB4444          DMA2D_OUTPUT_ARGB4444
N
N#define CM_ARGB8888             DMA2D_INPUT_ARGB8888
N#define CM_RGB888               DMA2D_INPUT_RGB888  
N#define CM_RGB565               DMA2D_INPUT_RGB565  
N#define CM_ARGB1555             DMA2D_INPUT_ARGB1555
N#define CM_ARGB4444             DMA2D_INPUT_ARGB4444
N#define CM_L8                   DMA2D_INPUT_L8      
N#define CM_AL44                 DMA2D_INPUT_AL44    
N#define CM_AL88                 DMA2D_INPUT_AL88    
N#define CM_L4                   DMA2D_INPUT_L4      
N#define CM_A8                   DMA2D_INPUT_A8      
N#define CM_A4                   DMA2D_INPUT_A4      
N/**
N  * @}
N  */    
N#endif  /* STM32L4xx ||  STM32F7*/
N
N/** @defgroup HAL_PPP_Aliased_Defines HAL PPP Aliased Defines maintained for legacy purpose
N  * @{
N  */
N  
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N
N/** @defgroup HAL_CRYP_Aliased_Functions HAL CRYP Aliased Functions maintained for legacy purpose
N  * @{
N  */
N#define HAL_CRYP_ComputationCpltCallback     HAL_CRYPEx_ComputationCpltCallback
N/**
N  * @}
N  */  
N
N/** @defgroup HAL_HASH_Aliased_Functions HAL HASH Aliased Functions maintained for legacy purpose
N  * @{
N  */ 
N#define HAL_HASH_STATETypeDef        HAL_HASH_StateTypeDef
N#define HAL_HASHPhaseTypeDef         HAL_HASH_PhaseTypeDef
N#define HAL_HMAC_MD5_Finish          HAL_HASH_MD5_Finish
N#define HAL_HMAC_SHA1_Finish         HAL_HASH_SHA1_Finish
N#define HAL_HMAC_SHA224_Finish       HAL_HASH_SHA224_Finish
N#define HAL_HMAC_SHA256_Finish       HAL_HASH_SHA256_Finish
N
N/*HASH Algorithm Selection*/
N
N#define HASH_AlgoSelection_SHA1      HASH_ALGOSELECTION_SHA1 
N#define HASH_AlgoSelection_SHA224    HASH_ALGOSELECTION_SHA224
N#define HASH_AlgoSelection_SHA256    HASH_ALGOSELECTION_SHA256
N#define HASH_AlgoSelection_MD5       HASH_ALGOSELECTION_MD5
N
N#define HASH_AlgoMode_HASH         HASH_ALGOMODE_HASH 
N#define HASH_AlgoMode_HMAC         HASH_ALGOMODE_HMAC
N
N#define HASH_HMACKeyType_ShortKey  HASH_HMAC_KEYTYPE_SHORTKEY
N#define HASH_HMACKeyType_LongKey   HASH_HMAC_KEYTYPE_LONGKEY
N/**
N  * @}
N  */
N  
N/** @defgroup HAL_Aliased_Functions HAL Generic Aliased Functions maintained for legacy purpose
N  * @{
N  */
N#define HAL_EnableDBGSleepMode HAL_DBGMCU_EnableDBGSleepMode
N#define HAL_DisableDBGSleepMode HAL_DBGMCU_DisableDBGSleepMode
N#define HAL_EnableDBGStopMode HAL_DBGMCU_EnableDBGStopMode
N#define HAL_DisableDBGStopMode HAL_DBGMCU_DisableDBGStopMode
N#define HAL_EnableDBGStandbyMode HAL_DBGMCU_EnableDBGStandbyMode
N#define HAL_DisableDBGStandbyMode HAL_DBGMCU_DisableDBGStandbyMode
N#define HAL_DBG_LowPowerConfig(Periph, cmd) (((cmd)==ENABLE)? HAL_DBGMCU_DBG_EnableLowPowerConfig(Periph) : HAL_DBGMCU_DBG_DisableLowPowerConfig(Periph))
N#define HAL_VREFINT_OutputSelect  HAL_SYSCFG_VREFINT_OutputSelect
N#define HAL_Lock_Cmd(cmd) (((cmd)==ENABLE) ? HAL_SYSCFG_Enable_Lock_VREFINT() : HAL_SYSCFG_Disable_Lock_VREFINT())
N#if defined(STM32L0)
X#if 0L
N#else
N#define HAL_VREFINT_Cmd(cmd) (((cmd)==ENABLE)? HAL_SYSCFG_EnableVREFINT() : HAL_SYSCFG_DisableVREFINT())
N#endif
N#define HAL_ADC_EnableBuffer_Cmd(cmd)  (((cmd)==ENABLE) ? HAL_ADCEx_EnableVREFINT() : HAL_ADCEx_DisableVREFINT())
N#define HAL_ADC_EnableBufferSensor_Cmd(cmd) (((cmd)==ENABLE) ?  HAL_ADCEx_EnableVREFINTTempSensor() : HAL_ADCEx_DisableVREFINTTempSensor())
N/**
N  * @}
N  */
N
N/** @defgroup HAL_FLASH_Aliased_Functions HAL FLASH Aliased Functions maintained for legacy purpose
N  * @{
N  */
N#define FLASH_HalfPageProgram      HAL_FLASHEx_HalfPageProgram
N#define FLASH_EnableRunPowerDown   HAL_FLASHEx_EnableRunPowerDown
N#define FLASH_DisableRunPowerDown  HAL_FLASHEx_DisableRunPowerDown
N#define HAL_DATA_EEPROMEx_Unlock   HAL_FLASHEx_DATAEEPROM_Unlock
N#define HAL_DATA_EEPROMEx_Lock     HAL_FLASHEx_DATAEEPROM_Lock
N#define HAL_DATA_EEPROMEx_Erase    HAL_FLASHEx_DATAEEPROM_Erase
N#define HAL_DATA_EEPROMEx_Program  HAL_FLASHEx_DATAEEPROM_Program
N
N /**
N  * @}
N  */
N
N/** @defgroup HAL_I2C_Aliased_Functions HAL I2C Aliased Functions maintained for legacy purpose
N  * @{
N  */
N#define HAL_I2CEx_AnalogFilter_Config         HAL_I2CEx_ConfigAnalogFilter
N#define HAL_I2CEx_DigitalFilter_Config        HAL_I2CEx_ConfigDigitalFilter
N#define HAL_FMPI2CEx_AnalogFilter_Config      HAL_FMPI2CEx_ConfigAnalogFilter
N#define HAL_FMPI2CEx_DigitalFilter_Config     HAL_FMPI2CEx_ConfigDigitalFilter
N
N#define HAL_I2CFastModePlusConfig(SYSCFG_I2CFastModePlus, cmd) (((cmd)==ENABLE)? HAL_I2CEx_EnableFastModePlus(SYSCFG_I2CFastModePlus): HAL_I2CEx_DisableFastModePlus(SYSCFG_I2CFastModePlus))
N /**
N  * @}
N  */
N
N/** @defgroup HAL_PWR_Aliased HAL PWR Aliased maintained for legacy purpose
N  * @{
N  */
N#define HAL_PWR_PVDConfig                             HAL_PWR_ConfigPVD
N#define HAL_PWR_DisableBkUpReg                        HAL_PWREx_DisableBkUpReg
N#define HAL_PWR_DisableFlashPowerDown                 HAL_PWREx_DisableFlashPowerDown
N#define HAL_PWR_DisableVddio2Monitor                  HAL_PWREx_DisableVddio2Monitor
N#define HAL_PWR_EnableBkUpReg                         HAL_PWREx_EnableBkUpReg
N#define HAL_PWR_EnableFlashPowerDown                  HAL_PWREx_EnableFlashPowerDown
N#define HAL_PWR_EnableVddio2Monitor                   HAL_PWREx_EnableVddio2Monitor
N#define HAL_PWR_PVD_PVM_IRQHandler                    HAL_PWREx_PVD_PVM_IRQHandler
N#define HAL_PWR_PVDLevelConfig                        HAL_PWR_ConfigPVD
N#define HAL_PWR_Vddio2Monitor_IRQHandler              HAL_PWREx_Vddio2Monitor_IRQHandler
N#define HAL_PWR_Vddio2MonitorCallback                 HAL_PWREx_Vddio2MonitorCallback
N#define HAL_PWREx_ActivateOverDrive                   HAL_PWREx_EnableOverDrive
N#define HAL_PWREx_DeactivateOverDrive                 HAL_PWREx_DisableOverDrive
N#define HAL_PWREx_DisableSDADCAnalog                  HAL_PWREx_DisableSDADC
N#define HAL_PWREx_EnableSDADCAnalog                   HAL_PWREx_EnableSDADC
N#define HAL_PWREx_PVMConfig                           HAL_PWREx_ConfigPVM
N
N#define PWR_MODE_NORMAL                               PWR_PVD_MODE_NORMAL
N#define PWR_MODE_IT_RISING                            PWR_PVD_MODE_IT_RISING
N#define PWR_MODE_IT_FALLING                           PWR_PVD_MODE_IT_FALLING
N#define PWR_MODE_IT_RISING_FALLING                    PWR_PVD_MODE_IT_RISING_FALLING
N#define PWR_MODE_EVENT_RISING                         PWR_PVD_MODE_EVENT_RISING
N#define PWR_MODE_EVENT_FALLING                        PWR_PVD_MODE_EVENT_FALLING
N#define PWR_MODE_EVENT_RISING_FALLING                 PWR_PVD_MODE_EVENT_RISING_FALLING
N
N#define CR_OFFSET_BB                                  PWR_CR_OFFSET_BB
N#define CSR_OFFSET_BB                                 PWR_CSR_OFFSET_BB
N
N#define DBP_BitNumber                                 DBP_BIT_NUMBER
N#define PVDE_BitNumber                                PVDE_BIT_NUMBER
N#define PMODE_BitNumber                               PMODE_BIT_NUMBER
N#define EWUP_BitNumber                                EWUP_BIT_NUMBER
N#define FPDS_BitNumber                                FPDS_BIT_NUMBER
N#define ODEN_BitNumber                                ODEN_BIT_NUMBER
N#define ODSWEN_BitNumber                              ODSWEN_BIT_NUMBER
N#define MRLVDS_BitNumber                              MRLVDS_BIT_NUMBER
N#define LPLVDS_BitNumber                              LPLVDS_BIT_NUMBER
N#define BRE_BitNumber                                 BRE_BIT_NUMBER
N
N#define PWR_MODE_EVT                                  PWR_PVD_MODE_NORMAL
N 
N /**
N  * @}
N  */  
N  
N/** @defgroup HAL_SMBUS_Aliased_Functions HAL SMBUS Aliased Functions maintained for legacy purpose
N  * @{
N  */
N#define HAL_SMBUS_Slave_Listen_IT          HAL_SMBUS_EnableListen_IT
N#define HAL_SMBUS_SlaveAddrCallback        HAL_SMBUS_AddrCallback         
N#define HAL_SMBUS_SlaveListenCpltCallback  HAL_SMBUS_ListenCpltCallback   
N/**
N  * @}
N  */
N
N/** @defgroup HAL_SPI_Aliased_Functions HAL SPI Aliased Functions maintained for legacy purpose
N  * @{
N  */
N#define HAL_SPI_FlushRxFifo                HAL_SPIEx_FlushRxFifo
N/**
N  * @}
N  */  
N
N/** @defgroup HAL_TIM_Aliased_Functions HAL TIM Aliased Functions maintained for legacy purpose
N  * @{
N  */
N#define HAL_TIM_DMADelayPulseCplt                       TIM_DMADelayPulseCplt
N#define HAL_TIM_DMAError                                TIM_DMAError
N#define HAL_TIM_DMACaptureCplt                          TIM_DMACaptureCplt
N#define HAL_TIMEx_DMACommutationCplt                    TIMEx_DMACommutationCplt
N/**
N  * @}
N  */
N   
N/** @defgroup HAL_UART_Aliased_Functions HAL UART Aliased Functions maintained for legacy purpose
N  * @{
N  */ 
N#define HAL_UART_WakeupCallback HAL_UARTEx_WakeupCallback
N/**
N  * @}
N  */
N  
N/** @defgroup HAL_LTDC_Aliased_Functions HAL LTDC Aliased Functions maintained for legacy purpose
N  * @{
N  */ 
N#define HAL_LTDC_LineEvenCallback HAL_LTDC_LineEventCallback
N/**
N  * @}
N  */  
N   
N  
N/** @defgroup HAL_PPP_Aliased_Functions HAL PPP Aliased Functions maintained for legacy purpose
N  * @{
N  */
N  
N/**
N  * @}
N  */
N
N/* Exported macros ------------------------------------------------------------*/
N
N/** @defgroup HAL_AES_Aliased_Macros HAL CRYP Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define AES_IT_CC                      CRYP_IT_CC
N#define AES_IT_ERR                     CRYP_IT_ERR
N#define AES_FLAG_CCF                   CRYP_FLAG_CCF
N/**
N  * @}
N  */  
N  
N/** @defgroup HAL_Aliased_Macros HAL Generic Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define __HAL_GET_BOOT_MODE                   __HAL_SYSCFG_GET_BOOT_MODE
N#define __HAL_REMAPMEMORY_FLASH               __HAL_SYSCFG_REMAPMEMORY_FLASH
N#define __HAL_REMAPMEMORY_SYSTEMFLASH         __HAL_SYSCFG_REMAPMEMORY_SYSTEMFLASH
N#define __HAL_REMAPMEMORY_SRAM                __HAL_SYSCFG_REMAPMEMORY_SRAM
N#define __HAL_REMAPMEMORY_FMC                 __HAL_SYSCFG_REMAPMEMORY_FMC
N#define __HAL_REMAPMEMORY_FMC_SDRAM           __HAL_SYSCFG_REMAPMEMORY_FMC_SDRAM 
N#define __HAL_REMAPMEMORY_FSMC                __HAL_SYSCFG_REMAPMEMORY_FSMC
N#define __HAL_REMAPMEMORY_QUADSPI             __HAL_SYSCFG_REMAPMEMORY_QUADSPI
N#define __HAL_FMC_BANK                        __HAL_SYSCFG_FMC_BANK
N#define __HAL_GET_FLAG                        __HAL_SYSCFG_GET_FLAG
N#define __HAL_CLEAR_FLAG                      __HAL_SYSCFG_CLEAR_FLAG
N#define __HAL_VREFINT_OUT_ENABLE              __HAL_SYSCFG_VREFINT_OUT_ENABLE
N#define __HAL_VREFINT_OUT_DISABLE             __HAL_SYSCFG_VREFINT_OUT_DISABLE
N
N#define SYSCFG_FLAG_VREF_READY                SYSCFG_FLAG_VREFINT_READY
N#define SYSCFG_FLAG_RC48                      RCC_FLAG_HSI48
N#define IS_SYSCFG_FASTMODEPLUS_CONFIG         IS_I2C_FASTMODEPLUS
N#define UFB_MODE_BitNumber                    UFB_MODE_BIT_NUMBER
N#define CMP_PD_BitNumber                      CMP_PD_BIT_NUMBER
N
N/**
N  * @}
N  */
N
N   
N/** @defgroup HAL_ADC_Aliased_Macros HAL ADC Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define __ADC_ENABLE                                     __HAL_ADC_ENABLE
N#define __ADC_DISABLE                                    __HAL_ADC_DISABLE
N#define __HAL_ADC_ENABLING_CONDITIONS                    ADC_ENABLING_CONDITIONS
N#define __HAL_ADC_DISABLING_CONDITIONS                   ADC_DISABLING_CONDITIONS
N#define __HAL_ADC_IS_ENABLED                             ADC_IS_ENABLE
N#define __ADC_IS_ENABLED                                 ADC_IS_ENABLE
N#define __HAL_ADC_IS_SOFTWARE_START_REGULAR              ADC_IS_SOFTWARE_START_REGULAR
N#define __HAL_ADC_IS_SOFTWARE_START_INJECTED             ADC_IS_SOFTWARE_START_INJECTED
N#define __HAL_ADC_IS_CONVERSION_ONGOING_REGULAR_INJECTED ADC_IS_CONVERSION_ONGOING_REGULAR_INJECTED
N#define __HAL_ADC_IS_CONVERSION_ONGOING_REGULAR          ADC_IS_CONVERSION_ONGOING_REGULAR
N#define __HAL_ADC_IS_CONVERSION_ONGOING_INJECTED         ADC_IS_CONVERSION_ONGOING_INJECTED
N#define __HAL_ADC_IS_CONVERSION_ONGOING                  ADC_IS_CONVERSION_ONGOING
N#define __HAL_ADC_CLEAR_ERRORCODE                        ADC_CLEAR_ERRORCODE
N
N#define __HAL_ADC_GET_RESOLUTION                         ADC_GET_RESOLUTION
N#define __HAL_ADC_JSQR_RK                                ADC_JSQR_RK
N#define __HAL_ADC_CFGR_AWD1CH                            ADC_CFGR_AWD1CH_SHIFT
N#define __HAL_ADC_CFGR_AWD23CR                           ADC_CFGR_AWD23CR
N#define __HAL_ADC_CFGR_INJECT_AUTO_CONVERSION            ADC_CFGR_INJECT_AUTO_CONVERSION
N#define __HAL_ADC_CFGR_INJECT_CONTEXT_QUEUE              ADC_CFGR_INJECT_CONTEXT_QUEUE
N#define __HAL_ADC_CFGR_INJECT_DISCCONTINUOUS             ADC_CFGR_INJECT_DISCCONTINUOUS
N#define __HAL_ADC_CFGR_REG_DISCCONTINUOUS                ADC_CFGR_REG_DISCCONTINUOUS
N#define __HAL_ADC_CFGR_DISCONTINUOUS_NUM                 ADC_CFGR_DISCONTINUOUS_NUM
N#define __HAL_ADC_CFGR_AUTOWAIT                          ADC_CFGR_AUTOWAIT
N#define __HAL_ADC_CFGR_CONTINUOUS                        ADC_CFGR_CONTINUOUS
N#define __HAL_ADC_CFGR_OVERRUN                           ADC_CFGR_OVERRUN
N#define __HAL_ADC_CFGR_DMACONTREQ                        ADC_CFGR_DMACONTREQ
N#define __HAL_ADC_CFGR_EXTSEL                            ADC_CFGR_EXTSEL_SET
N#define __HAL_ADC_JSQR_JEXTSEL                           ADC_JSQR_JEXTSEL_SET
N#define __HAL_ADC_OFR_CHANNEL                            ADC_OFR_CHANNEL
N#define __HAL_ADC_DIFSEL_CHANNEL                         ADC_DIFSEL_CHANNEL
N#define __HAL_ADC_CALFACT_DIFF_SET                       ADC_CALFACT_DIFF_SET
N#define __HAL_ADC_CALFACT_DIFF_GET                       ADC_CALFACT_DIFF_GET
N#define __HAL_ADC_TRX_HIGHTHRESHOLD                      ADC_TRX_HIGHTHRESHOLD
N
N#define __HAL_ADC_OFFSET_SHIFT_RESOLUTION                ADC_OFFSET_SHIFT_RESOLUTION
N#define __HAL_ADC_AWD1THRESHOLD_SHIFT_RESOLUTION         ADC_AWD1THRESHOLD_SHIFT_RESOLUTION
N#define __HAL_ADC_AWD23THRESHOLD_SHIFT_RESOLUTION        ADC_AWD23THRESHOLD_SHIFT_RESOLUTION
N#define __HAL_ADC_COMMON_REGISTER                        ADC_COMMON_REGISTER
N#define __HAL_ADC_COMMON_CCR_MULTI                       ADC_COMMON_CCR_MULTI
N#define __HAL_ADC_MULTIMODE_IS_ENABLED                   ADC_MULTIMODE_IS_ENABLE
N#define __ADC_MULTIMODE_IS_ENABLED                       ADC_MULTIMODE_IS_ENABLE
N#define __HAL_ADC_NONMULTIMODE_OR_MULTIMODEMASTER        ADC_NONMULTIMODE_OR_MULTIMODEMASTER
N#define __HAL_ADC_COMMON_ADC_OTHER                       ADC_COMMON_ADC_OTHER
N#define __HAL_ADC_MULTI_SLAVE                            ADC_MULTI_SLAVE
N
N#define __HAL_ADC_SQR1_L                                 ADC_SQR1_L_SHIFT
N#define __HAL_ADC_JSQR_JL                                ADC_JSQR_JL_SHIFT
N#define __HAL_ADC_JSQR_RK_JL                             ADC_JSQR_RK_JL
N#define __HAL_ADC_CR1_DISCONTINUOUS_NUM                  ADC_CR1_DISCONTINUOUS_NUM
N#define __HAL_ADC_CR1_SCAN                               ADC_CR1_SCAN_SET
N#define __HAL_ADC_CONVCYCLES_MAX_RANGE                   ADC_CONVCYCLES_MAX_RANGE
N#define __HAL_ADC_CLOCK_PRESCALER_RANGE                  ADC_CLOCK_PRESCALER_RANGE
N#define __HAL_ADC_GET_CLOCK_PRESCALER                    ADC_GET_CLOCK_PRESCALER
N
N#define __HAL_ADC_SQR1                                   ADC_SQR1
N#define __HAL_ADC_SMPR1                                  ADC_SMPR1
N#define __HAL_ADC_SMPR2                                  ADC_SMPR2
N#define __HAL_ADC_SQR3_RK                                ADC_SQR3_RK
N#define __HAL_ADC_SQR2_RK                                ADC_SQR2_RK
N#define __HAL_ADC_SQR1_RK                                ADC_SQR1_RK
N#define __HAL_ADC_CR2_CONTINUOUS                         ADC_CR2_CONTINUOUS
N#define __HAL_ADC_CR1_DISCONTINUOUS                      ADC_CR1_DISCONTINUOUS
N#define __HAL_ADC_CR1_SCANCONV                           ADC_CR1_SCANCONV
N#define __HAL_ADC_CR2_EOCSelection                       ADC_CR2_EOCSelection
N#define __HAL_ADC_CR2_DMAContReq                         ADC_CR2_DMAContReq
N#define __HAL_ADC_GET_RESOLUTION                         ADC_GET_RESOLUTION
N#define __HAL_ADC_JSQR                                   ADC_JSQR
N
N#define __HAL_ADC_CHSELR_CHANNEL                         ADC_CHSELR_CHANNEL
N#define __HAL_ADC_CFGR1_REG_DISCCONTINUOUS               ADC_CFGR1_REG_DISCCONTINUOUS
N#define __HAL_ADC_CFGR1_AUTOOFF                          ADC_CFGR1_AUTOOFF
N#define __HAL_ADC_CFGR1_AUTOWAIT                         ADC_CFGR1_AUTOWAIT
N#define __HAL_ADC_CFGR1_CONTINUOUS                       ADC_CFGR1_CONTINUOUS
N#define __HAL_ADC_CFGR1_OVERRUN                          ADC_CFGR1_OVERRUN
N#define __HAL_ADC_CFGR1_SCANDIR                          ADC_CFGR1_SCANDIR
N#define __HAL_ADC_CFGR1_DMACONTREQ                       ADC_CFGR1_DMACONTREQ
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_DAC_Aliased_Macros HAL DAC Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define __HAL_DHR12R1_ALIGNEMENT                        DAC_DHR12R1_ALIGNMENT
N#define __HAL_DHR12R2_ALIGNEMENT                        DAC_DHR12R2_ALIGNMENT
N#define __HAL_DHR12RD_ALIGNEMENT                        DAC_DHR12RD_ALIGNMENT
N#define IS_DAC_GENERATE_WAVE                            IS_DAC_WAVE
N
N/**
N  * @}
N  */
N   
N/** @defgroup HAL_DBGMCU_Aliased_Macros HAL DBGMCU Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define __HAL_FREEZE_TIM1_DBGMCU __HAL_DBGMCU_FREEZE_TIM1
N#define __HAL_UNFREEZE_TIM1_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM1
N#define __HAL_FREEZE_TIM2_DBGMCU __HAL_DBGMCU_FREEZE_TIM2
N#define __HAL_UNFREEZE_TIM2_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM2
N#define __HAL_FREEZE_TIM3_DBGMCU __HAL_DBGMCU_FREEZE_TIM3
N#define __HAL_UNFREEZE_TIM3_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM3
N#define __HAL_FREEZE_TIM4_DBGMCU __HAL_DBGMCU_FREEZE_TIM4
N#define __HAL_UNFREEZE_TIM4_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM4
N#define __HAL_FREEZE_TIM5_DBGMCU __HAL_DBGMCU_FREEZE_TIM5
N#define __HAL_UNFREEZE_TIM5_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM5
N#define __HAL_FREEZE_TIM6_DBGMCU __HAL_DBGMCU_FREEZE_TIM6
N#define __HAL_UNFREEZE_TIM6_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM6
N#define __HAL_FREEZE_TIM7_DBGMCU __HAL_DBGMCU_FREEZE_TIM7
N#define __HAL_UNFREEZE_TIM7_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM7
N#define __HAL_FREEZE_TIM8_DBGMCU __HAL_DBGMCU_FREEZE_TIM8
N#define __HAL_UNFREEZE_TIM8_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM8
N
N#define __HAL_FREEZE_TIM9_DBGMCU __HAL_DBGMCU_FREEZE_TIM9
N#define __HAL_UNFREEZE_TIM9_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM9
N#define __HAL_FREEZE_TIM10_DBGMCU __HAL_DBGMCU_FREEZE_TIM10
N#define __HAL_UNFREEZE_TIM10_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM10
N#define __HAL_FREEZE_TIM11_DBGMCU __HAL_DBGMCU_FREEZE_TIM11
N#define __HAL_UNFREEZE_TIM11_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM11
N#define __HAL_FREEZE_TIM12_DBGMCU __HAL_DBGMCU_FREEZE_TIM12
N#define __HAL_UNFREEZE_TIM12_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM12
N#define __HAL_FREEZE_TIM13_DBGMCU __HAL_DBGMCU_FREEZE_TIM13
N#define __HAL_UNFREEZE_TIM13_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM13
N#define __HAL_FREEZE_TIM14_DBGMCU __HAL_DBGMCU_FREEZE_TIM14
N#define __HAL_UNFREEZE_TIM14_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM14
N#define __HAL_FREEZE_CAN2_DBGMCU __HAL_DBGMCU_FREEZE_CAN2
N#define __HAL_UNFREEZE_CAN2_DBGMCU __HAL_DBGMCU_UNFREEZE_CAN2
N
N
N#define __HAL_FREEZE_TIM15_DBGMCU __HAL_DBGMCU_FREEZE_TIM15
N#define __HAL_UNFREEZE_TIM15_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM15
N#define __HAL_FREEZE_TIM16_DBGMCU __HAL_DBGMCU_FREEZE_TIM16
N#define __HAL_UNFREEZE_TIM16_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM16
N#define __HAL_FREEZE_TIM17_DBGMCU __HAL_DBGMCU_FREEZE_TIM17
N#define __HAL_UNFREEZE_TIM17_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM17
N#define __HAL_FREEZE_RTC_DBGMCU __HAL_DBGMCU_FREEZE_RTC
N#define __HAL_UNFREEZE_RTC_DBGMCU __HAL_DBGMCU_UNFREEZE_RTC
N#define __HAL_FREEZE_WWDG_DBGMCU __HAL_DBGMCU_FREEZE_WWDG
N#define __HAL_UNFREEZE_WWDG_DBGMCU __HAL_DBGMCU_UNFREEZE_WWDG
N#define __HAL_FREEZE_IWDG_DBGMCU __HAL_DBGMCU_FREEZE_IWDG
N#define __HAL_UNFREEZE_IWDG_DBGMCU __HAL_DBGMCU_UNFREEZE_IWDG
N#define __HAL_FREEZE_I2C1_TIMEOUT_DBGMCU __HAL_DBGMCU_FREEZE_I2C1_TIMEOUT
N#define __HAL_UNFREEZE_I2C1_TIMEOUT_DBGMCU __HAL_DBGMCU_UNFREEZE_I2C1_TIMEOUT
N#define __HAL_FREEZE_I2C2_TIMEOUT_DBGMCU __HAL_DBGMCU_FREEZE_I2C2_TIMEOUT
N#define __HAL_UNFREEZE_I2C2_TIMEOUT_DBGMCU __HAL_DBGMCU_UNFREEZE_I2C2_TIMEOUT
N#define __HAL_FREEZE_I2C3_TIMEOUT_DBGMCU __HAL_DBGMCU_FREEZE_I2C3_TIMEOUT
N#define __HAL_UNFREEZE_I2C3_TIMEOUT_DBGMCU __HAL_DBGMCU_UNFREEZE_I2C3_TIMEOUT
N#define __HAL_FREEZE_CAN1_DBGMCU __HAL_DBGMCU_FREEZE_CAN1
N#define __HAL_UNFREEZE_CAN1_DBGMCU __HAL_DBGMCU_UNFREEZE_CAN1
N#define __HAL_FREEZE_LPTIM1_DBGMCU __HAL_DBGMCU_FREEZE_LPTIM1
N#define __HAL_UNFREEZE_LPTIM1_DBGMCU __HAL_DBGMCU_UNFREEZE_LPTIM1
N#define __HAL_FREEZE_LPTIM2_DBGMCU __HAL_DBGMCU_FREEZE_LPTIM2
N#define __HAL_UNFREEZE_LPTIM2_DBGMCU __HAL_DBGMCU_UNFREEZE_LPTIM2
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_COMP_Aliased_Macros HAL COMP Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#if defined(STM32F3)
X#if 0L
S#define COMP_START                                       __HAL_COMP_ENABLE
S#define COMP_STOP                                        __HAL_COMP_DISABLE
S#define COMP_LOCK                                        __HAL_COMP_LOCK
S   
S#if defined(STM32F301x8) || defined(STM32F302x8) || defined(STM32F318xx) || defined(STM32F303x8) || defined(STM32F334x8) || defined(STM32F328xx)
S#define __HAL_COMP_EXTI_RISING_IT_ENABLE(__EXTILINE__)   (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_RISING_EDGE() : \
S                                                          __HAL_COMP_COMP6_EXTI_ENABLE_RISING_EDGE())
X#define __HAL_COMP_EXTI_RISING_IT_ENABLE(__EXTILINE__)   (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_RISING_EDGE() :                                                           __HAL_COMP_COMP6_EXTI_ENABLE_RISING_EDGE())
S#define __HAL_COMP_EXTI_RISING_IT_DISABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_RISING_EDGE() : \
S                                                          __HAL_COMP_COMP6_EXTI_DISABLE_RISING_EDGE())
X#define __HAL_COMP_EXTI_RISING_IT_DISABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_RISING_EDGE() :                                                           __HAL_COMP_COMP6_EXTI_DISABLE_RISING_EDGE())
S#define __HAL_COMP_EXTI_FALLING_IT_ENABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          __HAL_COMP_COMP6_EXTI_ENABLE_FALLING_EDGE())
X#define __HAL_COMP_EXTI_FALLING_IT_ENABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_FALLING_EDGE() :                                                           __HAL_COMP_COMP6_EXTI_ENABLE_FALLING_EDGE())
S#define __HAL_COMP_EXTI_FALLING_IT_DISABLE(__EXTILINE__) (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          __HAL_COMP_COMP6_EXTI_DISABLE_FALLING_EDGE())
X#define __HAL_COMP_EXTI_FALLING_IT_DISABLE(__EXTILINE__) (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_FALLING_EDGE() :                                                           __HAL_COMP_COMP6_EXTI_DISABLE_FALLING_EDGE())
S#define __HAL_COMP_EXTI_ENABLE_IT(__EXTILINE__)          (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_IT() : \
S                                                          __HAL_COMP_COMP6_EXTI_ENABLE_IT())
X#define __HAL_COMP_EXTI_ENABLE_IT(__EXTILINE__)          (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_IT() :                                                           __HAL_COMP_COMP6_EXTI_ENABLE_IT())
S#define __HAL_COMP_EXTI_DISABLE_IT(__EXTILINE__)         (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_IT() : \
S                                                          __HAL_COMP_COMP6_EXTI_DISABLE_IT())
X#define __HAL_COMP_EXTI_DISABLE_IT(__EXTILINE__)         (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_IT() :                                                           __HAL_COMP_COMP6_EXTI_DISABLE_IT())
S#define __HAL_COMP_EXTI_GET_FLAG(__FLAG__)               (((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_GET_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_GET_FLAG() : \
S                                                          __HAL_COMP_COMP6_EXTI_GET_FLAG())
X#define __HAL_COMP_EXTI_GET_FLAG(__FLAG__)               (((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_GET_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_GET_FLAG() :                                                           __HAL_COMP_COMP6_EXTI_GET_FLAG())
S#define __HAL_COMP_EXTI_CLEAR_FLAG(__FLAG__)             (((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_CLEAR_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_CLEAR_FLAG() : \
S                                                          __HAL_COMP_COMP6_EXTI_CLEAR_FLAG())
X#define __HAL_COMP_EXTI_CLEAR_FLAG(__FLAG__)             (((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_CLEAR_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_CLEAR_FLAG() :                                                           __HAL_COMP_COMP6_EXTI_CLEAR_FLAG())
S# endif
S# if defined(STM32F302xE) || defined(STM32F302xC)
S#define __HAL_COMP_EXTI_RISING_IT_ENABLE(__EXTILINE__)   (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_RISING_EDGE() : \
S                                                          __HAL_COMP_COMP6_EXTI_ENABLE_RISING_EDGE())
X#define __HAL_COMP_EXTI_RISING_IT_ENABLE(__EXTILINE__)   (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_RISING_EDGE() :                                                           __HAL_COMP_COMP6_EXTI_ENABLE_RISING_EDGE())
S#define __HAL_COMP_EXTI_RISING_IT_DISABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_RISING_EDGE() : \
S                                                          __HAL_COMP_COMP6_EXTI_DISABLE_RISING_EDGE())
X#define __HAL_COMP_EXTI_RISING_IT_DISABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_RISING_EDGE() :                                                           __HAL_COMP_COMP6_EXTI_DISABLE_RISING_EDGE())
S#define __HAL_COMP_EXTI_FALLING_IT_ENABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          __HAL_COMP_COMP6_EXTI_ENABLE_FALLING_EDGE())
X#define __HAL_COMP_EXTI_FALLING_IT_ENABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_FALLING_EDGE() :                                                           __HAL_COMP_COMP6_EXTI_ENABLE_FALLING_EDGE())
S#define __HAL_COMP_EXTI_FALLING_IT_DISABLE(__EXTILINE__) (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          __HAL_COMP_COMP6_EXTI_DISABLE_FALLING_EDGE())
X#define __HAL_COMP_EXTI_FALLING_IT_DISABLE(__EXTILINE__) (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_FALLING_EDGE() :                                                           __HAL_COMP_COMP6_EXTI_DISABLE_FALLING_EDGE())
S#define __HAL_COMP_EXTI_ENABLE_IT(__EXTILINE__)          (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_IT() : \
S                                                          __HAL_COMP_COMP6_EXTI_ENABLE_IT())
X#define __HAL_COMP_EXTI_ENABLE_IT(__EXTILINE__)          (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_IT() :                                                           __HAL_COMP_COMP6_EXTI_ENABLE_IT())
S#define __HAL_COMP_EXTI_DISABLE_IT(__EXTILINE__)         (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_IT() : \
S                                                          __HAL_COMP_COMP6_EXTI_DISABLE_IT())
X#define __HAL_COMP_EXTI_DISABLE_IT(__EXTILINE__)         (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_IT() :                                                           __HAL_COMP_COMP6_EXTI_DISABLE_IT())
S#define __HAL_COMP_EXTI_GET_FLAG(__FLAG__)               (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_GET_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_GET_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_GET_FLAG() : \
S                                                          __HAL_COMP_COMP6_EXTI_GET_FLAG())
X#define __HAL_COMP_EXTI_GET_FLAG(__FLAG__)               (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_GET_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_GET_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_GET_FLAG() :                                                           __HAL_COMP_COMP6_EXTI_GET_FLAG())
S#define __HAL_COMP_EXTI_CLEAR_FLAG(__FLAG__)             (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_CLEAR_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_CLEAR_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_CLEAR_FLAG() : \
S                                                          __HAL_COMP_COMP6_EXTI_CLEAR_FLAG())
X#define __HAL_COMP_EXTI_CLEAR_FLAG(__FLAG__)             (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_CLEAR_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_CLEAR_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_CLEAR_FLAG() :                                                           __HAL_COMP_COMP6_EXTI_CLEAR_FLAG())
S# endif
S# if defined(STM32F303xE) || defined(STM32F398xx) || defined(STM32F303xC) || defined(STM32F358xx)
S#define __HAL_COMP_EXTI_RISING_IT_ENABLE(__EXTILINE__)   (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_ENABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_ENABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_ENABLE_RISING_EDGE() : \
S                                                          __HAL_COMP_COMP7_EXTI_ENABLE_RISING_EDGE())
X#define __HAL_COMP_EXTI_RISING_IT_ENABLE(__EXTILINE__)   (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_ENABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_ENABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_ENABLE_RISING_EDGE() :                                                           __HAL_COMP_COMP7_EXTI_ENABLE_RISING_EDGE())
S#define __HAL_COMP_EXTI_RISING_IT_DISABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_DISABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_DISABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_DISABLE_RISING_EDGE() : \
S                                                          __HAL_COMP_COMP7_EXTI_DISABLE_RISING_EDGE())
X#define __HAL_COMP_EXTI_RISING_IT_DISABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_DISABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_DISABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_DISABLE_RISING_EDGE() :                                                           __HAL_COMP_COMP7_EXTI_DISABLE_RISING_EDGE())
S#define __HAL_COMP_EXTI_FALLING_IT_ENABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          __HAL_COMP_COMP7_EXTI_ENABLE_FALLING_EDGE())
X#define __HAL_COMP_EXTI_FALLING_IT_ENABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_ENABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_ENABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_ENABLE_FALLING_EDGE() :                                                           __HAL_COMP_COMP7_EXTI_ENABLE_FALLING_EDGE())
S#define __HAL_COMP_EXTI_FALLING_IT_DISABLE(__EXTILINE__) (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          __HAL_COMP_COMP7_EXTI_DISABLE_FALLING_EDGE())
X#define __HAL_COMP_EXTI_FALLING_IT_DISABLE(__EXTILINE__) (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_DISABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_DISABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_DISABLE_FALLING_EDGE() :                                                           __HAL_COMP_COMP7_EXTI_DISABLE_FALLING_EDGE())
S#define __HAL_COMP_EXTI_ENABLE_IT(__EXTILINE__)          (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_ENABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_ENABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_ENABLE_IT() : \
S                                                          __HAL_COMP_COMP7_EXTI_ENABLE_IT())
X#define __HAL_COMP_EXTI_ENABLE_IT(__EXTILINE__)          (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_ENABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_ENABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_ENABLE_IT() :                                                           __HAL_COMP_COMP7_EXTI_ENABLE_IT())
S#define __HAL_COMP_EXTI_DISABLE_IT(__EXTILINE__)         (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_DISABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_DISABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_DISABLE_IT() : \
S                                                          __HAL_COMP_COMP7_EXTI_DISABLE_IT())
X#define __HAL_COMP_EXTI_DISABLE_IT(__EXTILINE__)         (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_DISABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_DISABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_DISABLE_IT() :                                                           __HAL_COMP_COMP7_EXTI_DISABLE_IT())
S#define __HAL_COMP_EXTI_GET_FLAG(__FLAG__)               (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_GET_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_GET_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_GET_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_GET_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_GET_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_GET_FLAG() : \
S                                                          __HAL_COMP_COMP7_EXTI_GET_FLAG())
X#define __HAL_COMP_EXTI_GET_FLAG(__FLAG__)               (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_GET_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_GET_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_GET_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_GET_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_GET_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_GET_FLAG() :                                                           __HAL_COMP_COMP7_EXTI_GET_FLAG())
S#define __HAL_COMP_EXTI_CLEAR_FLAG(__FLAG__)             (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_CLEAR_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_CLEAR_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_CLEAR_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_CLEAR_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_CLEAR_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_CLEAR_FLAG() : \
S                                                          __HAL_COMP_COMP7_EXTI_CLEAR_FLAG())
X#define __HAL_COMP_EXTI_CLEAR_FLAG(__FLAG__)             (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_CLEAR_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_CLEAR_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_CLEAR_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_CLEAR_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_CLEAR_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_CLEAR_FLAG() :                                                           __HAL_COMP_COMP7_EXTI_CLEAR_FLAG())
S# endif
S# if defined(STM32F373xC) ||defined(STM32F378xx)
S#define __HAL_COMP_EXTI_RISING_IT_ENABLE(__EXTILINE__)   (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_RISING_EDGE() : \
S                                                          __HAL_COMP_COMP2_EXTI_ENABLE_RISING_EDGE())
X#define __HAL_COMP_EXTI_RISING_IT_ENABLE(__EXTILINE__)   (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_RISING_EDGE() :                                                           __HAL_COMP_COMP2_EXTI_ENABLE_RISING_EDGE())
S#define __HAL_COMP_EXTI_RISING_IT_DISABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_RISING_EDGE() : \
S                                                          __HAL_COMP_COMP2_EXTI_DISABLE_RISING_EDGE())
X#define __HAL_COMP_EXTI_RISING_IT_DISABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_RISING_EDGE() :                                                           __HAL_COMP_COMP2_EXTI_DISABLE_RISING_EDGE())
S#define __HAL_COMP_EXTI_FALLING_IT_ENABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          __HAL_COMP_COMP2_EXTI_ENABLE_FALLING_EDGE())
X#define __HAL_COMP_EXTI_FALLING_IT_ENABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_FALLING_EDGE() :                                                           __HAL_COMP_COMP2_EXTI_ENABLE_FALLING_EDGE())
S#define __HAL_COMP_EXTI_FALLING_IT_DISABLE(__EXTILINE__) (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          __HAL_COMP_COMP2_EXTI_DISABLE_FALLING_EDGE())
X#define __HAL_COMP_EXTI_FALLING_IT_DISABLE(__EXTILINE__) (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_FALLING_EDGE() :                                                           __HAL_COMP_COMP2_EXTI_DISABLE_FALLING_EDGE())
S#define __HAL_COMP_EXTI_ENABLE_IT(__EXTILINE__)          (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_IT() : \
S                                                          __HAL_COMP_COMP2_EXTI_ENABLE_IT())
X#define __HAL_COMP_EXTI_ENABLE_IT(__EXTILINE__)          (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_IT() :                                                           __HAL_COMP_COMP2_EXTI_ENABLE_IT())
S#define __HAL_COMP_EXTI_DISABLE_IT(__EXTILINE__)         (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_IT() : \
S                                                          __HAL_COMP_COMP2_EXTI_DISABLE_IT())
X#define __HAL_COMP_EXTI_DISABLE_IT(__EXTILINE__)         (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_IT() :                                                           __HAL_COMP_COMP2_EXTI_DISABLE_IT())
S#define __HAL_COMP_EXTI_GET_FLAG(__FLAG__)               (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_GET_FLAG() : \
S                                                          __HAL_COMP_COMP2_EXTI_GET_FLAG())
X#define __HAL_COMP_EXTI_GET_FLAG(__FLAG__)               (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_GET_FLAG() :                                                           __HAL_COMP_COMP2_EXTI_GET_FLAG())
S#define __HAL_COMP_EXTI_CLEAR_FLAG(__FLAG__)             (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_CLEAR_FLAG() : \
S                                                          __HAL_COMP_COMP2_EXTI_CLEAR_FLAG())
X#define __HAL_COMP_EXTI_CLEAR_FLAG(__FLAG__)             (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_CLEAR_FLAG() :                                                           __HAL_COMP_COMP2_EXTI_CLEAR_FLAG())
S# endif
N#else
N#define __HAL_COMP_EXTI_RISING_IT_ENABLE(__EXTILINE__)   (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_RISING_EDGE() : \
N                                                          __HAL_COMP_COMP2_EXTI_ENABLE_RISING_EDGE())
X#define __HAL_COMP_EXTI_RISING_IT_ENABLE(__EXTILINE__)   (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_RISING_EDGE() :                                                           __HAL_COMP_COMP2_EXTI_ENABLE_RISING_EDGE())
N#define __HAL_COMP_EXTI_RISING_IT_DISABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_RISING_EDGE() : \
N                                                          __HAL_COMP_COMP2_EXTI_DISABLE_RISING_EDGE())
X#define __HAL_COMP_EXTI_RISING_IT_DISABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_RISING_EDGE() :                                                           __HAL_COMP_COMP2_EXTI_DISABLE_RISING_EDGE())
N#define __HAL_COMP_EXTI_FALLING_IT_ENABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_FALLING_EDGE() : \
N                                                          __HAL_COMP_COMP2_EXTI_ENABLE_FALLING_EDGE())
X#define __HAL_COMP_EXTI_FALLING_IT_ENABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_FALLING_EDGE() :                                                           __HAL_COMP_COMP2_EXTI_ENABLE_FALLING_EDGE())
N#define __HAL_COMP_EXTI_FALLING_IT_DISABLE(__EXTILINE__) (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_FALLING_EDGE() : \
N                                                          __HAL_COMP_COMP2_EXTI_DISABLE_FALLING_EDGE())
X#define __HAL_COMP_EXTI_FALLING_IT_DISABLE(__EXTILINE__) (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_FALLING_EDGE() :                                                           __HAL_COMP_COMP2_EXTI_DISABLE_FALLING_EDGE())
N#define __HAL_COMP_EXTI_ENABLE_IT(__EXTILINE__)          (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_IT() : \
N                                                          __HAL_COMP_COMP2_EXTI_ENABLE_IT())
X#define __HAL_COMP_EXTI_ENABLE_IT(__EXTILINE__)          (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_IT() :                                                           __HAL_COMP_COMP2_EXTI_ENABLE_IT())
N#define __HAL_COMP_EXTI_DISABLE_IT(__EXTILINE__)         (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_IT() : \
N                                                          __HAL_COMP_COMP2_EXTI_DISABLE_IT())
X#define __HAL_COMP_EXTI_DISABLE_IT(__EXTILINE__)         (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_IT() :                                                           __HAL_COMP_COMP2_EXTI_DISABLE_IT())
N#define __HAL_COMP_EXTI_GET_FLAG(__FLAG__)               (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_GET_FLAG() : \
N                                                          __HAL_COMP_COMP2_EXTI_GET_FLAG())
X#define __HAL_COMP_EXTI_GET_FLAG(__FLAG__)               (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_GET_FLAG() :                                                           __HAL_COMP_COMP2_EXTI_GET_FLAG())
N#define __HAL_COMP_EXTI_CLEAR_FLAG(__FLAG__)             (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_CLEAR_FLAG() : \
N                                                          __HAL_COMP_COMP2_EXTI_CLEAR_FLAG())
X#define __HAL_COMP_EXTI_CLEAR_FLAG(__FLAG__)             (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_CLEAR_FLAG() :                                                           __HAL_COMP_COMP2_EXTI_CLEAR_FLAG())
N#endif
N
N#define __HAL_COMP_GET_EXTI_LINE  COMP_GET_EXTI_LINE
N
N#if defined(STM32L0) || defined(STM32L4)
X#if 0L || 0L
S/* Note: On these STM32 families, the only argument of this macro             */
S/*       is COMP_FLAG_LOCK.                                                   */
S/*       This macro is replaced by __HAL_COMP_IS_LOCKED with only HAL handle  */
S/*       argument.                                                            */
S#define __HAL_COMP_GET_FLAG(__HANDLE__, __FLAG__)  (__HAL_COMP_IS_LOCKED(__HANDLE__))
N#endif
N/**
N  * @}
N  */
N
N#if defined(STM32L0) || defined(STM32L4)
X#if 0L || 0L
S/** @defgroup HAL_COMP_Aliased_Functions HAL COMP Aliased Functions maintained for legacy purpose
S  * @{
S  */
S#define HAL_COMP_Start_IT       HAL_COMP_Start /* Function considered as legacy as EXTI event or IT configuration is done into HAL_COMP_Init() */
S#define HAL_COMP_Stop_IT        HAL_COMP_Stop  /* Function considered as legacy as EXTI event or IT configuration is done into HAL_COMP_Init() */
S/**
S  * @}
S  */
N#endif
N
N/** @defgroup HAL_DAC_Aliased_Macros HAL DAC Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#define IS_DAC_WAVE(WAVE) (((WAVE) == DAC_WAVE_NONE) || \
N                          ((WAVE) == DAC_WAVE_NOISE)|| \
N                          ((WAVE) == DAC_WAVE_TRIANGLE))
X#define IS_DAC_WAVE(WAVE) (((WAVE) == DAC_WAVE_NONE) ||                           ((WAVE) == DAC_WAVE_NOISE)||                           ((WAVE) == DAC_WAVE_TRIANGLE))
N  
N/**
N  * @}
N  */
N
N/** @defgroup HAL_FLASH_Aliased_Macros HAL FLASH Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#define IS_WRPAREA          IS_OB_WRPAREA
N#define IS_TYPEPROGRAM      IS_FLASH_TYPEPROGRAM
N#define IS_TYPEPROGRAMFLASH IS_FLASH_TYPEPROGRAM
N#define IS_TYPEERASE        IS_FLASH_TYPEERASE
N#define IS_NBSECTORS        IS_FLASH_NBSECTORS
N#define IS_OB_WDG_SOURCE    IS_OB_IWDG_SOURCE
N
N/**
N  * @}
N  */
N  
N/** @defgroup HAL_I2C_Aliased_Macros HAL I2C Aliased Macros maintained for legacy purpose
N  * @{
N  */
N  
N#define __HAL_I2C_RESET_CR2             I2C_RESET_CR2
N#define __HAL_I2C_GENERATE_START        I2C_GENERATE_START
N#define __HAL_I2C_FREQ_RANGE            I2C_FREQ_RANGE
N#define __HAL_I2C_RISE_TIME             I2C_RISE_TIME
N#define __HAL_I2C_SPEED_STANDARD        I2C_SPEED_STANDARD
N#define __HAL_I2C_SPEED_FAST            I2C_SPEED_FAST
N#define __HAL_I2C_SPEED                 I2C_SPEED
N#define __HAL_I2C_7BIT_ADD_WRITE        I2C_7BIT_ADD_WRITE
N#define __HAL_I2C_7BIT_ADD_READ         I2C_7BIT_ADD_READ
N#define __HAL_I2C_10BIT_ADDRESS         I2C_10BIT_ADDRESS
N#define __HAL_I2C_10BIT_HEADER_WRITE    I2C_10BIT_HEADER_WRITE
N#define __HAL_I2C_10BIT_HEADER_READ     I2C_10BIT_HEADER_READ
N#define __HAL_I2C_MEM_ADD_MSB           I2C_MEM_ADD_MSB
N#define __HAL_I2C_MEM_ADD_LSB           I2C_MEM_ADD_LSB
N#define __HAL_I2C_FREQRANGE             I2C_FREQRANGE
N/**
N  * @}
N  */
N  
N/** @defgroup HAL_I2S_Aliased_Macros HAL I2S Aliased Macros maintained for legacy purpose
N  * @{
N  */
N  
N#define IS_I2S_INSTANCE                 IS_I2S_ALL_INSTANCE
N#define IS_I2S_INSTANCE_EXT             IS_I2S_ALL_INSTANCE_EXT
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_IRDA_Aliased_Macros HAL IRDA Aliased Macros maintained for legacy purpose
N  * @{
N  */
N  
N#define __IRDA_DISABLE                  __HAL_IRDA_DISABLE
N#define __IRDA_ENABLE                   __HAL_IRDA_ENABLE
N
N#define __HAL_IRDA_GETCLOCKSOURCE       IRDA_GETCLOCKSOURCE
N#define __HAL_IRDA_MASK_COMPUTATION     IRDA_MASK_COMPUTATION
N#define __IRDA_GETCLOCKSOURCE           IRDA_GETCLOCKSOURCE
N#define __IRDA_MASK_COMPUTATION         IRDA_MASK_COMPUTATION
N
N#define IS_IRDA_ONEBIT_SAMPLE           IS_IRDA_ONE_BIT_SAMPLE                  
N
N
N/**
N  * @}
N  */
N
N
N/** @defgroup HAL_IWDG_Aliased_Macros HAL IWDG Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define __HAL_IWDG_ENABLE_WRITE_ACCESS  IWDG_ENABLE_WRITE_ACCESS
N#define __HAL_IWDG_DISABLE_WRITE_ACCESS IWDG_DISABLE_WRITE_ACCESS
N/**
N  * @}
N  */
N
N
N/** @defgroup HAL_LPTIM_Aliased_Macros HAL LPTIM Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#define __HAL_LPTIM_ENABLE_INTERRUPT    __HAL_LPTIM_ENABLE_IT
N#define __HAL_LPTIM_DISABLE_INTERRUPT   __HAL_LPTIM_DISABLE_IT
N#define __HAL_LPTIM_GET_ITSTATUS        __HAL_LPTIM_GET_IT_SOURCE
N
N/**
N  * @}
N  */
N  
N  
N/** @defgroup HAL_OPAMP_Aliased_Macros HAL OPAMP Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define __OPAMP_CSR_OPAXPD                OPAMP_CSR_OPAXPD
N#define __OPAMP_CSR_S3SELX                OPAMP_CSR_S3SELX
N#define __OPAMP_CSR_S4SELX                OPAMP_CSR_S4SELX
N#define __OPAMP_CSR_S5SELX                OPAMP_CSR_S5SELX
N#define __OPAMP_CSR_S6SELX                OPAMP_CSR_S6SELX
N#define __OPAMP_CSR_OPAXCAL_L             OPAMP_CSR_OPAXCAL_L
N#define __OPAMP_CSR_OPAXCAL_H             OPAMP_CSR_OPAXCAL_H
N#define __OPAMP_CSR_OPAXLPM               OPAMP_CSR_OPAXLPM
N#define __OPAMP_CSR_ALL_SWITCHES          OPAMP_CSR_ALL_SWITCHES
N#define __OPAMP_CSR_ANAWSELX              OPAMP_CSR_ANAWSELX
N#define __OPAMP_CSR_OPAXCALOUT            OPAMP_CSR_OPAXCALOUT
N#define __OPAMP_OFFSET_TRIM_BITSPOSITION  OPAMP_OFFSET_TRIM_BITSPOSITION
N#define __OPAMP_OFFSET_TRIM_SET           OPAMP_OFFSET_TRIM_SET
N
N/**
N  * @}
N  */
N
N
N/** @defgroup HAL_PWR_Aliased_Macros HAL PWR Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define __HAL_PVD_EVENT_DISABLE                                  __HAL_PWR_PVD_EXTI_DISABLE_EVENT
N#define __HAL_PVD_EVENT_ENABLE                                   __HAL_PWR_PVD_EXTI_ENABLE_EVENT
N#define __HAL_PVD_EXTI_FALLINGTRIGGER_DISABLE                    __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE
N#define __HAL_PVD_EXTI_FALLINGTRIGGER_ENABLE                     __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE
N#define __HAL_PVD_EXTI_RISINGTRIGGER_DISABLE                     __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE
N#define __HAL_PVD_EXTI_RISINGTRIGGER_ENABLE                      __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE
N#define __HAL_PVM_EVENT_DISABLE                                  __HAL_PWR_PVM_EVENT_DISABLE
N#define __HAL_PVM_EVENT_ENABLE                                   __HAL_PWR_PVM_EVENT_ENABLE
N#define __HAL_PVM_EXTI_FALLINGTRIGGER_DISABLE                    __HAL_PWR_PVM_EXTI_FALLINGTRIGGER_DISABLE
N#define __HAL_PVM_EXTI_FALLINGTRIGGER_ENABLE                     __HAL_PWR_PVM_EXTI_FALLINGTRIGGER_ENABLE
N#define __HAL_PVM_EXTI_RISINGTRIGGER_DISABLE                     __HAL_PWR_PVM_EXTI_RISINGTRIGGER_DISABLE
N#define __HAL_PVM_EXTI_RISINGTRIGGER_ENABLE                      __HAL_PWR_PVM_EXTI_RISINGTRIGGER_ENABLE
N#define __HAL_PWR_INTERNALWAKEUP_DISABLE                         HAL_PWREx_DisableInternalWakeUpLine
N#define __HAL_PWR_INTERNALWAKEUP_ENABLE                          HAL_PWREx_EnableInternalWakeUpLine
N#define __HAL_PWR_PULL_UP_DOWN_CONFIG_DISABLE                    HAL_PWREx_DisablePullUpPullDownConfig
N#define __HAL_PWR_PULL_UP_DOWN_CONFIG_ENABLE                     HAL_PWREx_EnablePullUpPullDownConfig
N#define __HAL_PWR_PVD_EXTI_CLEAR_EGDE_TRIGGER()                  do { __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();__HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE(); } while(0)
N#define __HAL_PWR_PVD_EXTI_EVENT_DISABLE                         __HAL_PWR_PVD_EXTI_DISABLE_EVENT
N#define __HAL_PWR_PVD_EXTI_EVENT_ENABLE                          __HAL_PWR_PVD_EXTI_ENABLE_EVENT
N#define __HAL_PWR_PVD_EXTI_FALLINGTRIGGER_DISABLE                __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE
N#define __HAL_PWR_PVD_EXTI_FALLINGTRIGGER_ENABLE                 __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE
N#define __HAL_PWR_PVD_EXTI_RISINGTRIGGER_DISABLE                 __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE
N#define __HAL_PWR_PVD_EXTI_RISINGTRIGGER_ENABLE                  __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE
N#define __HAL_PWR_PVD_EXTI_SET_FALLING_EGDE_TRIGGER              __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE
N#define __HAL_PWR_PVD_EXTI_SET_RISING_EDGE_TRIGGER               __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE
N#define __HAL_PWR_PVM_DISABLE()                                  do { HAL_PWREx_DisablePVM1();HAL_PWREx_DisablePVM2();HAL_PWREx_DisablePVM3();HAL_PWREx_DisablePVM4(); } while(0)
N#define __HAL_PWR_PVM_ENABLE()                                   do { HAL_PWREx_EnablePVM1();HAL_PWREx_EnablePVM2();HAL_PWREx_EnablePVM3();HAL_PWREx_EnablePVM4(); } while(0)
N#define __HAL_PWR_SRAM2CONTENT_PRESERVE_DISABLE                  HAL_PWREx_DisableSRAM2ContentRetention
N#define __HAL_PWR_SRAM2CONTENT_PRESERVE_ENABLE                   HAL_PWREx_EnableSRAM2ContentRetention
N#define __HAL_PWR_VDDIO2_DISABLE                                 HAL_PWREx_DisableVddIO2
N#define __HAL_PWR_VDDIO2_ENABLE                                  HAL_PWREx_EnableVddIO2
N#define __HAL_PWR_VDDIO2_EXTI_CLEAR_EGDE_TRIGGER                 __HAL_PWR_VDDIO2_EXTI_DISABLE_FALLING_EDGE
N#define __HAL_PWR_VDDIO2_EXTI_SET_FALLING_EGDE_TRIGGER           __HAL_PWR_VDDIO2_EXTI_ENABLE_FALLING_EDGE
N#define __HAL_PWR_VDDUSB_DISABLE                                 HAL_PWREx_DisableVddUSB
N#define __HAL_PWR_VDDUSB_ENABLE                                  HAL_PWREx_EnableVddUSB
N
N#if defined (STM32F4)
X#if 0L
S#define __HAL_PVD_EXTI_ENABLE_IT(PWR_EXTI_LINE_PVD)         __HAL_PWR_PVD_EXTI_ENABLE_IT()
S#define __HAL_PVD_EXTI_DISABLE_IT(PWR_EXTI_LINE_PVD)        __HAL_PWR_PVD_EXTI_DISABLE_IT()
S#define __HAL_PVD_EXTI_GET_FLAG(PWR_EXTI_LINE_PVD)          __HAL_PWR_PVD_EXTI_GET_FLAG()   
S#define __HAL_PVD_EXTI_CLEAR_FLAG(PWR_EXTI_LINE_PVD)        __HAL_PWR_PVD_EXTI_CLEAR_FLAG()
S#define __HAL_PVD_EXTI_GENERATE_SWIT(PWR_EXTI_LINE_PVD)     __HAL_PWR_PVD_EXTI_GENERATE_SWIT()
N#else
N#define __HAL_PVD_EXTI_CLEAR_FLAG                                __HAL_PWR_PVD_EXTI_CLEAR_FLAG
N#define __HAL_PVD_EXTI_DISABLE_IT                                __HAL_PWR_PVD_EXTI_DISABLE_IT
N#define __HAL_PVD_EXTI_ENABLE_IT                                 __HAL_PWR_PVD_EXTI_ENABLE_IT
N#define __HAL_PVD_EXTI_GENERATE_SWIT                             __HAL_PWR_PVD_EXTI_GENERATE_SWIT
N#define __HAL_PVD_EXTI_GET_FLAG                                  __HAL_PWR_PVD_EXTI_GET_FLAG 
N#endif /* STM32F4 */
N/**   
N  * @}
N  */  
N  
N  
N/** @defgroup HAL_RCC_Aliased HAL RCC Aliased maintained for legacy purpose
N  * @{
N  */
N  
N#define RCC_StopWakeUpClock_MSI     RCC_STOP_WAKEUPCLOCK_MSI
N#define RCC_StopWakeUpClock_HSI     RCC_STOP_WAKEUPCLOCK_HSI
N
N#define HAL_RCC_CCSCallback HAL_RCC_CSSCallback
N#define HAL_RC48_EnableBuffer_Cmd(cmd) (((cmd)==ENABLE) ? HAL_RCCEx_EnableHSI48_VREFINT() : HAL_RCCEx_DisableHSI48_VREFINT())
N
N#define __ADC_CLK_DISABLE __HAL_RCC_ADC_CLK_DISABLE
N#define __ADC_CLK_ENABLE __HAL_RCC_ADC_CLK_ENABLE
N#define __ADC_CLK_SLEEP_DISABLE __HAL_RCC_ADC_CLK_SLEEP_DISABLE
N#define __ADC_CLK_SLEEP_ENABLE __HAL_RCC_ADC_CLK_SLEEP_ENABLE
N#define __ADC_FORCE_RESET __HAL_RCC_ADC_FORCE_RESET
N#define __ADC_RELEASE_RESET __HAL_RCC_ADC_RELEASE_RESET
N#define __ADC1_CLK_DISABLE        __HAL_RCC_ADC1_CLK_DISABLE
N#define __ADC1_CLK_ENABLE         __HAL_RCC_ADC1_CLK_ENABLE
N#define __ADC1_FORCE_RESET        __HAL_RCC_ADC1_FORCE_RESET
N#define __ADC1_RELEASE_RESET      __HAL_RCC_ADC1_RELEASE_RESET
N#define __ADC1_CLK_SLEEP_ENABLE   __HAL_RCC_ADC1_CLK_SLEEP_ENABLE  
N#define __ADC1_CLK_SLEEP_DISABLE  __HAL_RCC_ADC1_CLK_SLEEP_DISABLE  
N#define __ADC2_CLK_DISABLE __HAL_RCC_ADC2_CLK_DISABLE
N#define __ADC2_CLK_ENABLE __HAL_RCC_ADC2_CLK_ENABLE
N#define __ADC2_FORCE_RESET __HAL_RCC_ADC2_FORCE_RESET
N#define __ADC2_RELEASE_RESET __HAL_RCC_ADC2_RELEASE_RESET
N#define __ADC3_CLK_DISABLE __HAL_RCC_ADC3_CLK_DISABLE
N#define __ADC3_CLK_ENABLE __HAL_RCC_ADC3_CLK_ENABLE
N#define __ADC3_FORCE_RESET __HAL_RCC_ADC3_FORCE_RESET
N#define __ADC3_RELEASE_RESET __HAL_RCC_ADC3_RELEASE_RESET
N#define __AES_CLK_DISABLE __HAL_RCC_AES_CLK_DISABLE
N#define __AES_CLK_ENABLE __HAL_RCC_AES_CLK_ENABLE
N#define __AES_CLK_SLEEP_DISABLE __HAL_RCC_AES_CLK_SLEEP_DISABLE
N#define __AES_CLK_SLEEP_ENABLE __HAL_RCC_AES_CLK_SLEEP_ENABLE
N#define __AES_FORCE_RESET __HAL_RCC_AES_FORCE_RESET
N#define __AES_RELEASE_RESET __HAL_RCC_AES_RELEASE_RESET
N#define __CRYP_CLK_SLEEP_ENABLE      __HAL_RCC_CRYP_CLK_SLEEP_ENABLE
N#define __CRYP_CLK_SLEEP_DISABLE  __HAL_RCC_CRYP_CLK_SLEEP_DISABLE
N#define __CRYP_CLK_ENABLE  __HAL_RCC_CRYP_CLK_ENABLE
N#define __CRYP_CLK_DISABLE  __HAL_RCC_CRYP_CLK_DISABLE
N#define __CRYP_FORCE_RESET  __HAL_RCC_CRYP_FORCE_RESET
N#define __CRYP_RELEASE_RESET  __HAL_RCC_CRYP_RELEASE_RESET
N#define __AFIO_CLK_DISABLE __HAL_RCC_AFIO_CLK_DISABLE
N#define __AFIO_CLK_ENABLE __HAL_RCC_AFIO_CLK_ENABLE
N#define __AFIO_FORCE_RESET __HAL_RCC_AFIO_FORCE_RESET
N#define __AFIO_RELEASE_RESET __HAL_RCC_AFIO_RELEASE_RESET
N#define __AHB_FORCE_RESET __HAL_RCC_AHB_FORCE_RESET
N#define __AHB_RELEASE_RESET __HAL_RCC_AHB_RELEASE_RESET
N#define __AHB1_FORCE_RESET __HAL_RCC_AHB1_FORCE_RESET
N#define __AHB1_RELEASE_RESET __HAL_RCC_AHB1_RELEASE_RESET
N#define __AHB2_FORCE_RESET __HAL_RCC_AHB2_FORCE_RESET
N#define __AHB2_RELEASE_RESET __HAL_RCC_AHB2_RELEASE_RESET
N#define __AHB3_FORCE_RESET __HAL_RCC_AHB3_FORCE_RESET
N#define __AHB3_RELEASE_RESET __HAL_RCC_AHB3_RELEASE_RESET
N#define __APB1_FORCE_RESET __HAL_RCC_APB1_FORCE_RESET
N#define __APB1_RELEASE_RESET __HAL_RCC_APB1_RELEASE_RESET
N#define __APB2_FORCE_RESET __HAL_RCC_APB2_FORCE_RESET
N#define __APB2_RELEASE_RESET __HAL_RCC_APB2_RELEASE_RESET
N#define __BKP_CLK_DISABLE __HAL_RCC_BKP_CLK_DISABLE
N#define __BKP_CLK_ENABLE __HAL_RCC_BKP_CLK_ENABLE
N#define __BKP_FORCE_RESET __HAL_RCC_BKP_FORCE_RESET
N#define __BKP_RELEASE_RESET __HAL_RCC_BKP_RELEASE_RESET
N#define __CAN1_CLK_DISABLE __HAL_RCC_CAN1_CLK_DISABLE
N#define __CAN1_CLK_ENABLE __HAL_RCC_CAN1_CLK_ENABLE
N#define __CAN1_CLK_SLEEP_DISABLE __HAL_RCC_CAN1_CLK_SLEEP_DISABLE
N#define __CAN1_CLK_SLEEP_ENABLE __HAL_RCC_CAN1_CLK_SLEEP_ENABLE
N#define __CAN1_FORCE_RESET __HAL_RCC_CAN1_FORCE_RESET
N#define __CAN1_RELEASE_RESET __HAL_RCC_CAN1_RELEASE_RESET
N#define __CAN_CLK_DISABLE         __HAL_RCC_CAN1_CLK_DISABLE
N#define __CAN_CLK_ENABLE          __HAL_RCC_CAN1_CLK_ENABLE
N#define __CAN_FORCE_RESET         __HAL_RCC_CAN1_FORCE_RESET
N#define __CAN_RELEASE_RESET       __HAL_RCC_CAN1_RELEASE_RESET
N#define __CAN2_CLK_DISABLE __HAL_RCC_CAN2_CLK_DISABLE
N#define __CAN2_CLK_ENABLE __HAL_RCC_CAN2_CLK_ENABLE
N#define __CAN2_FORCE_RESET __HAL_RCC_CAN2_FORCE_RESET
N#define __CAN2_RELEASE_RESET __HAL_RCC_CAN2_RELEASE_RESET
N#define __CEC_CLK_DISABLE __HAL_RCC_CEC_CLK_DISABLE
N#define __CEC_CLK_ENABLE __HAL_RCC_CEC_CLK_ENABLE
N#define __COMP_CLK_DISABLE        __HAL_RCC_COMP_CLK_DISABLE
N#define __COMP_CLK_ENABLE         __HAL_RCC_COMP_CLK_ENABLE
N#define __COMP_FORCE_RESET        __HAL_RCC_COMP_FORCE_RESET
N#define __COMP_RELEASE_RESET      __HAL_RCC_COMP_RELEASE_RESET
N#define __COMP_CLK_SLEEP_ENABLE   __HAL_RCC_COMP_CLK_SLEEP_ENABLE
N#define __COMP_CLK_SLEEP_DISABLE  __HAL_RCC_COMP_CLK_SLEEP_DISABLE
N#define __CEC_FORCE_RESET __HAL_RCC_CEC_FORCE_RESET
N#define __CEC_RELEASE_RESET __HAL_RCC_CEC_RELEASE_RESET
N#define __CRC_CLK_DISABLE __HAL_RCC_CRC_CLK_DISABLE
N#define __CRC_CLK_ENABLE __HAL_RCC_CRC_CLK_ENABLE
N#define __CRC_CLK_SLEEP_DISABLE __HAL_RCC_CRC_CLK_SLEEP_DISABLE
N#define __CRC_CLK_SLEEP_ENABLE __HAL_RCC_CRC_CLK_SLEEP_ENABLE
N#define __CRC_FORCE_RESET __HAL_RCC_CRC_FORCE_RESET
N#define __CRC_RELEASE_RESET __HAL_RCC_CRC_RELEASE_RESET
N#define __DAC_CLK_DISABLE __HAL_RCC_DAC_CLK_DISABLE
N#define __DAC_CLK_ENABLE __HAL_RCC_DAC_CLK_ENABLE
N#define __DAC_FORCE_RESET __HAL_RCC_DAC_FORCE_RESET
N#define __DAC_RELEASE_RESET __HAL_RCC_DAC_RELEASE_RESET
N#define __DAC1_CLK_DISABLE __HAL_RCC_DAC1_CLK_DISABLE
N#define __DAC1_CLK_ENABLE __HAL_RCC_DAC1_CLK_ENABLE
N#define __DAC1_CLK_SLEEP_DISABLE __HAL_RCC_DAC1_CLK_SLEEP_DISABLE
N#define __DAC1_CLK_SLEEP_ENABLE __HAL_RCC_DAC1_CLK_SLEEP_ENABLE
N#define __DAC1_FORCE_RESET __HAL_RCC_DAC1_FORCE_RESET
N#define __DAC1_RELEASE_RESET __HAL_RCC_DAC1_RELEASE_RESET
N#define __DBGMCU_CLK_ENABLE     __HAL_RCC_DBGMCU_CLK_ENABLE
N#define __DBGMCU_CLK_DISABLE     __HAL_RCC_DBGMCU_CLK_DISABLE
N#define __DBGMCU_FORCE_RESET    __HAL_RCC_DBGMCU_FORCE_RESET
N#define __DBGMCU_RELEASE_RESET  __HAL_RCC_DBGMCU_RELEASE_RESET
N#define __DFSDM_CLK_DISABLE __HAL_RCC_DFSDM_CLK_DISABLE
N#define __DFSDM_CLK_ENABLE __HAL_RCC_DFSDM_CLK_ENABLE
N#define __DFSDM_CLK_SLEEP_DISABLE __HAL_RCC_DFSDM_CLK_SLEEP_DISABLE
N#define __DFSDM_CLK_SLEEP_ENABLE __HAL_RCC_DFSDM_CLK_SLEEP_ENABLE
N#define __DFSDM_FORCE_RESET __HAL_RCC_DFSDM_FORCE_RESET
N#define __DFSDM_RELEASE_RESET __HAL_RCC_DFSDM_RELEASE_RESET
N#define __DMA1_CLK_DISABLE __HAL_RCC_DMA1_CLK_DISABLE
N#define __DMA1_CLK_ENABLE __HAL_RCC_DMA1_CLK_ENABLE
N#define __DMA1_CLK_SLEEP_DISABLE __HAL_RCC_DMA1_CLK_SLEEP_DISABLE
N#define __DMA1_CLK_SLEEP_ENABLE __HAL_RCC_DMA1_CLK_SLEEP_ENABLE
N#define __DMA1_FORCE_RESET __HAL_RCC_DMA1_FORCE_RESET
N#define __DMA1_RELEASE_RESET __HAL_RCC_DMA1_RELEASE_RESET
N#define __DMA2_CLK_DISABLE __HAL_RCC_DMA2_CLK_DISABLE
N#define __DMA2_CLK_ENABLE __HAL_RCC_DMA2_CLK_ENABLE
N#define __DMA2_CLK_SLEEP_DISABLE __HAL_RCC_DMA2_CLK_SLEEP_DISABLE
N#define __DMA2_CLK_SLEEP_ENABLE __HAL_RCC_DMA2_CLK_SLEEP_ENABLE
N#define __DMA2_FORCE_RESET __HAL_RCC_DMA2_FORCE_RESET
N#define __DMA2_RELEASE_RESET __HAL_RCC_DMA2_RELEASE_RESET
N#define __ETHMAC_CLK_DISABLE __HAL_RCC_ETHMAC_CLK_DISABLE
N#define __ETHMAC_CLK_ENABLE __HAL_RCC_ETHMAC_CLK_ENABLE
N#define __ETHMAC_FORCE_RESET __HAL_RCC_ETHMAC_FORCE_RESET
N#define __ETHMAC_RELEASE_RESET __HAL_RCC_ETHMAC_RELEASE_RESET
N#define __ETHMACRX_CLK_DISABLE __HAL_RCC_ETHMACRX_CLK_DISABLE
N#define __ETHMACRX_CLK_ENABLE __HAL_RCC_ETHMACRX_CLK_ENABLE
N#define __ETHMACTX_CLK_DISABLE __HAL_RCC_ETHMACTX_CLK_DISABLE
N#define __ETHMACTX_CLK_ENABLE __HAL_RCC_ETHMACTX_CLK_ENABLE
N#define __FIREWALL_CLK_DISABLE __HAL_RCC_FIREWALL_CLK_DISABLE
N#define __FIREWALL_CLK_ENABLE __HAL_RCC_FIREWALL_CLK_ENABLE
N#define __FLASH_CLK_DISABLE __HAL_RCC_FLASH_CLK_DISABLE
N#define __FLASH_CLK_ENABLE __HAL_RCC_FLASH_CLK_ENABLE
N#define __FLASH_CLK_SLEEP_DISABLE __HAL_RCC_FLASH_CLK_SLEEP_DISABLE
N#define __FLASH_CLK_SLEEP_ENABLE __HAL_RCC_FLASH_CLK_SLEEP_ENABLE
N#define __FLASH_FORCE_RESET __HAL_RCC_FLASH_FORCE_RESET
N#define __FLASH_RELEASE_RESET __HAL_RCC_FLASH_RELEASE_RESET
N#define __FLITF_CLK_DISABLE       __HAL_RCC_FLITF_CLK_DISABLE
N#define __FLITF_CLK_ENABLE        __HAL_RCC_FLITF_CLK_ENABLE
N#define __FLITF_FORCE_RESET       __HAL_RCC_FLITF_FORCE_RESET
N#define __FLITF_RELEASE_RESET     __HAL_RCC_FLITF_RELEASE_RESET
N#define __FLITF_CLK_SLEEP_ENABLE  __HAL_RCC_FLITF_CLK_SLEEP_ENABLE
N#define __FLITF_CLK_SLEEP_DISABLE __HAL_RCC_FLITF_CLK_SLEEP_DISABLE
N#define __FMC_CLK_DISABLE __HAL_RCC_FMC_CLK_DISABLE
N#define __FMC_CLK_ENABLE __HAL_RCC_FMC_CLK_ENABLE
N#define __FMC_CLK_SLEEP_DISABLE __HAL_RCC_FMC_CLK_SLEEP_DISABLE
N#define __FMC_CLK_SLEEP_ENABLE __HAL_RCC_FMC_CLK_SLEEP_ENABLE
N#define __FMC_FORCE_RESET __HAL_RCC_FMC_FORCE_RESET
N#define __FMC_RELEASE_RESET __HAL_RCC_FMC_RELEASE_RESET
N#define __FSMC_CLK_DISABLE __HAL_RCC_FSMC_CLK_DISABLE
N#define __FSMC_CLK_ENABLE __HAL_RCC_FSMC_CLK_ENABLE
N#define __GPIOA_CLK_DISABLE __HAL_RCC_GPIOA_CLK_DISABLE
N#define __GPIOA_CLK_ENABLE __HAL_RCC_GPIOA_CLK_ENABLE
N#define __GPIOA_CLK_SLEEP_DISABLE __HAL_RCC_GPIOA_CLK_SLEEP_DISABLE
N#define __GPIOA_CLK_SLEEP_ENABLE __HAL_RCC_GPIOA_CLK_SLEEP_ENABLE
N#define __GPIOA_FORCE_RESET __HAL_RCC_GPIOA_FORCE_RESET
N#define __GPIOA_RELEASE_RESET __HAL_RCC_GPIOA_RELEASE_RESET
N#define __GPIOB_CLK_DISABLE __HAL_RCC_GPIOB_CLK_DISABLE
N#define __GPIOB_CLK_ENABLE __HAL_RCC_GPIOB_CLK_ENABLE
N#define __GPIOB_CLK_SLEEP_DISABLE __HAL_RCC_GPIOB_CLK_SLEEP_DISABLE
N#define __GPIOB_CLK_SLEEP_ENABLE __HAL_RCC_GPIOB_CLK_SLEEP_ENABLE
N#define __GPIOB_FORCE_RESET __HAL_RCC_GPIOB_FORCE_RESET
N#define __GPIOB_RELEASE_RESET __HAL_RCC_GPIOB_RELEASE_RESET
N#define __GPIOC_CLK_DISABLE __HAL_RCC_GPIOC_CLK_DISABLE
N#define __GPIOC_CLK_ENABLE __HAL_RCC_GPIOC_CLK_ENABLE
N#define __GPIOC_CLK_SLEEP_DISABLE __HAL_RCC_GPIOC_CLK_SLEEP_DISABLE
N#define __GPIOC_CLK_SLEEP_ENABLE __HAL_RCC_GPIOC_CLK_SLEEP_ENABLE
N#define __GPIOC_FORCE_RESET __HAL_RCC_GPIOC_FORCE_RESET
N#define __GPIOC_RELEASE_RESET __HAL_RCC_GPIOC_RELEASE_RESET
N#define __GPIOD_CLK_DISABLE __HAL_RCC_GPIOD_CLK_DISABLE
N#define __GPIOD_CLK_ENABLE __HAL_RCC_GPIOD_CLK_ENABLE
N#define __GPIOD_CLK_SLEEP_DISABLE __HAL_RCC_GPIOD_CLK_SLEEP_DISABLE
N#define __GPIOD_CLK_SLEEP_ENABLE __HAL_RCC_GPIOD_CLK_SLEEP_ENABLE
N#define __GPIOD_FORCE_RESET __HAL_RCC_GPIOD_FORCE_RESET
N#define __GPIOD_RELEASE_RESET __HAL_RCC_GPIOD_RELEASE_RESET
N#define __GPIOE_CLK_DISABLE __HAL_RCC_GPIOE_CLK_DISABLE
N#define __GPIOE_CLK_ENABLE __HAL_RCC_GPIOE_CLK_ENABLE
N#define __GPIOE_CLK_SLEEP_DISABLE __HAL_RCC_GPIOE_CLK_SLEEP_DISABLE
N#define __GPIOE_CLK_SLEEP_ENABLE __HAL_RCC_GPIOE_CLK_SLEEP_ENABLE
N#define __GPIOE_FORCE_RESET __HAL_RCC_GPIOE_FORCE_RESET
N#define __GPIOE_RELEASE_RESET __HAL_RCC_GPIOE_RELEASE_RESET
N#define __GPIOF_CLK_DISABLE __HAL_RCC_GPIOF_CLK_DISABLE
N#define __GPIOF_CLK_ENABLE __HAL_RCC_GPIOF_CLK_ENABLE
N#define __GPIOF_CLK_SLEEP_DISABLE __HAL_RCC_GPIOF_CLK_SLEEP_DISABLE
N#define __GPIOF_CLK_SLEEP_ENABLE __HAL_RCC_GPIOF_CLK_SLEEP_ENABLE
N#define __GPIOF_FORCE_RESET __HAL_RCC_GPIOF_FORCE_RESET
N#define __GPIOF_RELEASE_RESET __HAL_RCC_GPIOF_RELEASE_RESET
N#define __GPIOG_CLK_DISABLE __HAL_RCC_GPIOG_CLK_DISABLE
N#define __GPIOG_CLK_ENABLE __HAL_RCC_GPIOG_CLK_ENABLE
N#define __GPIOG_CLK_SLEEP_DISABLE __HAL_RCC_GPIOG_CLK_SLEEP_DISABLE
N#define __GPIOG_CLK_SLEEP_ENABLE __HAL_RCC_GPIOG_CLK_SLEEP_ENABLE
N#define __GPIOG_FORCE_RESET __HAL_RCC_GPIOG_FORCE_RESET
N#define __GPIOG_RELEASE_RESET __HAL_RCC_GPIOG_RELEASE_RESET
N#define __GPIOH_CLK_DISABLE __HAL_RCC_GPIOH_CLK_DISABLE
N#define __GPIOH_CLK_ENABLE __HAL_RCC_GPIOH_CLK_ENABLE
N#define __GPIOH_CLK_SLEEP_DISABLE __HAL_RCC_GPIOH_CLK_SLEEP_DISABLE
N#define __GPIOH_CLK_SLEEP_ENABLE __HAL_RCC_GPIOH_CLK_SLEEP_ENABLE
N#define __GPIOH_FORCE_RESET __HAL_RCC_GPIOH_FORCE_RESET
N#define __GPIOH_RELEASE_RESET __HAL_RCC_GPIOH_RELEASE_RESET
N#define __I2C1_CLK_DISABLE __HAL_RCC_I2C1_CLK_DISABLE
N#define __I2C1_CLK_ENABLE __HAL_RCC_I2C1_CLK_ENABLE
N#define __I2C1_CLK_SLEEP_DISABLE __HAL_RCC_I2C1_CLK_SLEEP_DISABLE
N#define __I2C1_CLK_SLEEP_ENABLE __HAL_RCC_I2C1_CLK_SLEEP_ENABLE
N#define __I2C1_FORCE_RESET __HAL_RCC_I2C1_FORCE_RESET
N#define __I2C1_RELEASE_RESET __HAL_RCC_I2C1_RELEASE_RESET
N#define __I2C2_CLK_DISABLE __HAL_RCC_I2C2_CLK_DISABLE
N#define __I2C2_CLK_ENABLE __HAL_RCC_I2C2_CLK_ENABLE
N#define __I2C2_CLK_SLEEP_DISABLE __HAL_RCC_I2C2_CLK_SLEEP_DISABLE
N#define __I2C2_CLK_SLEEP_ENABLE __HAL_RCC_I2C2_CLK_SLEEP_ENABLE
N#define __I2C2_FORCE_RESET __HAL_RCC_I2C2_FORCE_RESET
N#define __I2C2_RELEASE_RESET __HAL_RCC_I2C2_RELEASE_RESET
N#define __I2C3_CLK_DISABLE __HAL_RCC_I2C3_CLK_DISABLE
N#define __I2C3_CLK_ENABLE __HAL_RCC_I2C3_CLK_ENABLE
N#define __I2C3_CLK_SLEEP_DISABLE __HAL_RCC_I2C3_CLK_SLEEP_DISABLE
N#define __I2C3_CLK_SLEEP_ENABLE __HAL_RCC_I2C3_CLK_SLEEP_ENABLE
N#define __I2C3_FORCE_RESET __HAL_RCC_I2C3_FORCE_RESET
N#define __I2C3_RELEASE_RESET __HAL_RCC_I2C3_RELEASE_RESET
N#define __LCD_CLK_DISABLE __HAL_RCC_LCD_CLK_DISABLE
N#define __LCD_CLK_ENABLE __HAL_RCC_LCD_CLK_ENABLE
N#define __LCD_CLK_SLEEP_DISABLE __HAL_RCC_LCD_CLK_SLEEP_DISABLE
N#define __LCD_CLK_SLEEP_ENABLE __HAL_RCC_LCD_CLK_SLEEP_ENABLE
N#define __LCD_FORCE_RESET __HAL_RCC_LCD_FORCE_RESET
N#define __LCD_RELEASE_RESET __HAL_RCC_LCD_RELEASE_RESET
N#define __LPTIM1_CLK_DISABLE __HAL_RCC_LPTIM1_CLK_DISABLE
N#define __LPTIM1_CLK_ENABLE __HAL_RCC_LPTIM1_CLK_ENABLE
N#define __LPTIM1_CLK_SLEEP_DISABLE __HAL_RCC_LPTIM1_CLK_SLEEP_DISABLE
N#define __LPTIM1_CLK_SLEEP_ENABLE __HAL_RCC_LPTIM1_CLK_SLEEP_ENABLE
N#define __LPTIM1_FORCE_RESET __HAL_RCC_LPTIM1_FORCE_RESET
N#define __LPTIM1_RELEASE_RESET __HAL_RCC_LPTIM1_RELEASE_RESET
N#define __LPTIM2_CLK_DISABLE __HAL_RCC_LPTIM2_CLK_DISABLE
N#define __LPTIM2_CLK_ENABLE __HAL_RCC_LPTIM2_CLK_ENABLE
N#define __LPTIM2_CLK_SLEEP_DISABLE __HAL_RCC_LPTIM2_CLK_SLEEP_DISABLE
N#define __LPTIM2_CLK_SLEEP_ENABLE __HAL_RCC_LPTIM2_CLK_SLEEP_ENABLE
N#define __LPTIM2_FORCE_RESET __HAL_RCC_LPTIM2_FORCE_RESET
N#define __LPTIM2_RELEASE_RESET __HAL_RCC_LPTIM2_RELEASE_RESET
N#define __LPUART1_CLK_DISABLE __HAL_RCC_LPUART1_CLK_DISABLE
N#define __LPUART1_CLK_ENABLE __HAL_RCC_LPUART1_CLK_ENABLE
N#define __LPUART1_CLK_SLEEP_DISABLE __HAL_RCC_LPUART1_CLK_SLEEP_DISABLE
N#define __LPUART1_CLK_SLEEP_ENABLE __HAL_RCC_LPUART1_CLK_SLEEP_ENABLE
N#define __LPUART1_FORCE_RESET __HAL_RCC_LPUART1_FORCE_RESET
N#define __LPUART1_RELEASE_RESET __HAL_RCC_LPUART1_RELEASE_RESET
N#define __OPAMP_CLK_DISABLE __HAL_RCC_OPAMP_CLK_DISABLE
N#define __OPAMP_CLK_ENABLE __HAL_RCC_OPAMP_CLK_ENABLE
N#define __OPAMP_CLK_SLEEP_DISABLE __HAL_RCC_OPAMP_CLK_SLEEP_DISABLE
N#define __OPAMP_CLK_SLEEP_ENABLE __HAL_RCC_OPAMP_CLK_SLEEP_ENABLE
N#define __OPAMP_FORCE_RESET __HAL_RCC_OPAMP_FORCE_RESET
N#define __OPAMP_RELEASE_RESET __HAL_RCC_OPAMP_RELEASE_RESET
N#define __OTGFS_CLK_DISABLE __HAL_RCC_OTGFS_CLK_DISABLE
N#define __OTGFS_CLK_ENABLE __HAL_RCC_OTGFS_CLK_ENABLE
N#define __OTGFS_CLK_SLEEP_DISABLE __HAL_RCC_OTGFS_CLK_SLEEP_DISABLE
N#define __OTGFS_CLK_SLEEP_ENABLE __HAL_RCC_OTGFS_CLK_SLEEP_ENABLE
N#define __OTGFS_FORCE_RESET __HAL_RCC_OTGFS_FORCE_RESET
N#define __OTGFS_RELEASE_RESET __HAL_RCC_OTGFS_RELEASE_RESET
N#define __PWR_CLK_DISABLE __HAL_RCC_PWR_CLK_DISABLE
N#define __PWR_CLK_ENABLE __HAL_RCC_PWR_CLK_ENABLE
N#define __PWR_CLK_SLEEP_DISABLE __HAL_RCC_PWR_CLK_SLEEP_DISABLE
N#define __PWR_CLK_SLEEP_ENABLE __HAL_RCC_PWR_CLK_SLEEP_ENABLE
N#define __PWR_FORCE_RESET __HAL_RCC_PWR_FORCE_RESET
N#define __PWR_RELEASE_RESET __HAL_RCC_PWR_RELEASE_RESET
N#define __QSPI_CLK_DISABLE __HAL_RCC_QSPI_CLK_DISABLE
N#define __QSPI_CLK_ENABLE __HAL_RCC_QSPI_CLK_ENABLE
N#define __QSPI_CLK_SLEEP_DISABLE __HAL_RCC_QSPI_CLK_SLEEP_DISABLE
N#define __QSPI_CLK_SLEEP_ENABLE __HAL_RCC_QSPI_CLK_SLEEP_ENABLE
N#define __QSPI_FORCE_RESET __HAL_RCC_QSPI_FORCE_RESET
N#define __QSPI_RELEASE_RESET __HAL_RCC_QSPI_RELEASE_RESET
N#define __RNG_CLK_DISABLE __HAL_RCC_RNG_CLK_DISABLE
N#define __RNG_CLK_ENABLE __HAL_RCC_RNG_CLK_ENABLE
N#define __RNG_CLK_SLEEP_DISABLE __HAL_RCC_RNG_CLK_SLEEP_DISABLE
N#define __RNG_CLK_SLEEP_ENABLE __HAL_RCC_RNG_CLK_SLEEP_ENABLE
N#define __RNG_FORCE_RESET __HAL_RCC_RNG_FORCE_RESET
N#define __RNG_RELEASE_RESET __HAL_RCC_RNG_RELEASE_RESET
N#define __SAI1_CLK_DISABLE __HAL_RCC_SAI1_CLK_DISABLE
N#define __SAI1_CLK_ENABLE __HAL_RCC_SAI1_CLK_ENABLE
N#define __SAI1_CLK_SLEEP_DISABLE __HAL_RCC_SAI1_CLK_SLEEP_DISABLE
N#define __SAI1_CLK_SLEEP_ENABLE __HAL_RCC_SAI1_CLK_SLEEP_ENABLE
N#define __SAI1_FORCE_RESET __HAL_RCC_SAI1_FORCE_RESET
N#define __SAI1_RELEASE_RESET __HAL_RCC_SAI1_RELEASE_RESET
N#define __SAI2_CLK_DISABLE __HAL_RCC_SAI2_CLK_DISABLE
N#define __SAI2_CLK_ENABLE __HAL_RCC_SAI2_CLK_ENABLE
N#define __SAI2_CLK_SLEEP_DISABLE __HAL_RCC_SAI2_CLK_SLEEP_DISABLE
N#define __SAI2_CLK_SLEEP_ENABLE __HAL_RCC_SAI2_CLK_SLEEP_ENABLE
N#define __SAI2_FORCE_RESET __HAL_RCC_SAI2_FORCE_RESET
N#define __SAI2_RELEASE_RESET __HAL_RCC_SAI2_RELEASE_RESET
N#define __SDIO_CLK_DISABLE __HAL_RCC_SDIO_CLK_DISABLE
N#define __SDIO_CLK_ENABLE __HAL_RCC_SDIO_CLK_ENABLE
N#define __SDMMC_CLK_DISABLE __HAL_RCC_SDMMC_CLK_DISABLE
N#define __SDMMC_CLK_ENABLE __HAL_RCC_SDMMC_CLK_ENABLE
N#define __SDMMC_CLK_SLEEP_DISABLE __HAL_RCC_SDMMC_CLK_SLEEP_DISABLE
N#define __SDMMC_CLK_SLEEP_ENABLE __HAL_RCC_SDMMC_CLK_SLEEP_ENABLE
N#define __SDMMC_FORCE_RESET __HAL_RCC_SDMMC_FORCE_RESET
N#define __SDMMC_RELEASE_RESET __HAL_RCC_SDMMC_RELEASE_RESET
N#define __SPI1_CLK_DISABLE __HAL_RCC_SPI1_CLK_DISABLE
N#define __SPI1_CLK_ENABLE __HAL_RCC_SPI1_CLK_ENABLE
N#define __SPI1_CLK_SLEEP_DISABLE __HAL_RCC_SPI1_CLK_SLEEP_DISABLE
N#define __SPI1_CLK_SLEEP_ENABLE __HAL_RCC_SPI1_CLK_SLEEP_ENABLE
N#define __SPI1_FORCE_RESET __HAL_RCC_SPI1_FORCE_RESET
N#define __SPI1_RELEASE_RESET __HAL_RCC_SPI1_RELEASE_RESET
N#define __SPI2_CLK_DISABLE __HAL_RCC_SPI2_CLK_DISABLE
N#define __SPI2_CLK_ENABLE __HAL_RCC_SPI2_CLK_ENABLE
N#define __SPI2_CLK_SLEEP_DISABLE __HAL_RCC_SPI2_CLK_SLEEP_DISABLE
N#define __SPI2_CLK_SLEEP_ENABLE __HAL_RCC_SPI2_CLK_SLEEP_ENABLE
N#define __SPI2_FORCE_RESET __HAL_RCC_SPI2_FORCE_RESET
N#define __SPI2_RELEASE_RESET __HAL_RCC_SPI2_RELEASE_RESET
N#define __SPI3_CLK_DISABLE __HAL_RCC_SPI3_CLK_DISABLE
N#define __SPI3_CLK_ENABLE __HAL_RCC_SPI3_CLK_ENABLE
N#define __SPI3_CLK_SLEEP_DISABLE __HAL_RCC_SPI3_CLK_SLEEP_DISABLE
N#define __SPI3_CLK_SLEEP_ENABLE __HAL_RCC_SPI3_CLK_SLEEP_ENABLE
N#define __SPI3_FORCE_RESET __HAL_RCC_SPI3_FORCE_RESET
N#define __SPI3_RELEASE_RESET __HAL_RCC_SPI3_RELEASE_RESET
N#define __SRAM_CLK_DISABLE __HAL_RCC_SRAM_CLK_DISABLE
N#define __SRAM_CLK_ENABLE __HAL_RCC_SRAM_CLK_ENABLE
N#define __SRAM1_CLK_SLEEP_DISABLE __HAL_RCC_SRAM1_CLK_SLEEP_DISABLE
N#define __SRAM1_CLK_SLEEP_ENABLE __HAL_RCC_SRAM1_CLK_SLEEP_ENABLE
N#define __SRAM2_CLK_SLEEP_DISABLE __HAL_RCC_SRAM2_CLK_SLEEP_DISABLE
N#define __SRAM2_CLK_SLEEP_ENABLE __HAL_RCC_SRAM2_CLK_SLEEP_ENABLE
N#define __SWPMI1_CLK_DISABLE __HAL_RCC_SWPMI1_CLK_DISABLE
N#define __SWPMI1_CLK_ENABLE __HAL_RCC_SWPMI1_CLK_ENABLE
N#define __SWPMI1_CLK_SLEEP_DISABLE __HAL_RCC_SWPMI1_CLK_SLEEP_DISABLE
N#define __SWPMI1_CLK_SLEEP_ENABLE __HAL_RCC_SWPMI1_CLK_SLEEP_ENABLE
N#define __SWPMI1_FORCE_RESET __HAL_RCC_SWPMI1_FORCE_RESET
N#define __SWPMI1_RELEASE_RESET __HAL_RCC_SWPMI1_RELEASE_RESET
N#define __SYSCFG_CLK_DISABLE __HAL_RCC_SYSCFG_CLK_DISABLE
N#define __SYSCFG_CLK_ENABLE __HAL_RCC_SYSCFG_CLK_ENABLE
N#define __SYSCFG_CLK_SLEEP_DISABLE __HAL_RCC_SYSCFG_CLK_SLEEP_DISABLE
N#define __SYSCFG_CLK_SLEEP_ENABLE __HAL_RCC_SYSCFG_CLK_SLEEP_ENABLE
N#define __SYSCFG_FORCE_RESET __HAL_RCC_SYSCFG_FORCE_RESET
N#define __SYSCFG_RELEASE_RESET __HAL_RCC_SYSCFG_RELEASE_RESET
N#define __TIM1_CLK_DISABLE __HAL_RCC_TIM1_CLK_DISABLE
N#define __TIM1_CLK_ENABLE __HAL_RCC_TIM1_CLK_ENABLE
N#define __TIM1_CLK_SLEEP_DISABLE __HAL_RCC_TIM1_CLK_SLEEP_DISABLE
N#define __TIM1_CLK_SLEEP_ENABLE __HAL_RCC_TIM1_CLK_SLEEP_ENABLE
N#define __TIM1_FORCE_RESET __HAL_RCC_TIM1_FORCE_RESET
N#define __TIM1_RELEASE_RESET __HAL_RCC_TIM1_RELEASE_RESET
N#define __TIM10_CLK_DISABLE __HAL_RCC_TIM10_CLK_DISABLE
N#define __TIM10_CLK_ENABLE __HAL_RCC_TIM10_CLK_ENABLE
N#define __TIM10_FORCE_RESET __HAL_RCC_TIM10_FORCE_RESET
N#define __TIM10_RELEASE_RESET __HAL_RCC_TIM10_RELEASE_RESET
N#define __TIM11_CLK_DISABLE __HAL_RCC_TIM11_CLK_DISABLE
N#define __TIM11_CLK_ENABLE __HAL_RCC_TIM11_CLK_ENABLE
N#define __TIM11_FORCE_RESET __HAL_RCC_TIM11_FORCE_RESET
N#define __TIM11_RELEASE_RESET __HAL_RCC_TIM11_RELEASE_RESET
N#define __TIM12_CLK_DISABLE __HAL_RCC_TIM12_CLK_DISABLE
N#define __TIM12_CLK_ENABLE __HAL_RCC_TIM12_CLK_ENABLE
N#define __TIM12_FORCE_RESET __HAL_RCC_TIM12_FORCE_RESET
N#define __TIM12_RELEASE_RESET __HAL_RCC_TIM12_RELEASE_RESET
N#define __TIM13_CLK_DISABLE __HAL_RCC_TIM13_CLK_DISABLE
N#define __TIM13_CLK_ENABLE __HAL_RCC_TIM13_CLK_ENABLE
N#define __TIM13_FORCE_RESET __HAL_RCC_TIM13_FORCE_RESET
N#define __TIM13_RELEASE_RESET __HAL_RCC_TIM13_RELEASE_RESET
N#define __TIM14_CLK_DISABLE __HAL_RCC_TIM14_CLK_DISABLE
N#define __TIM14_CLK_ENABLE __HAL_RCC_TIM14_CLK_ENABLE
N#define __TIM14_FORCE_RESET __HAL_RCC_TIM14_FORCE_RESET
N#define __TIM14_RELEASE_RESET __HAL_RCC_TIM14_RELEASE_RESET
N#define __TIM15_CLK_DISABLE __HAL_RCC_TIM15_CLK_DISABLE
N#define __TIM15_CLK_ENABLE __HAL_RCC_TIM15_CLK_ENABLE
N#define __TIM15_CLK_SLEEP_DISABLE __HAL_RCC_TIM15_CLK_SLEEP_DISABLE
N#define __TIM15_CLK_SLEEP_ENABLE __HAL_RCC_TIM15_CLK_SLEEP_ENABLE
N#define __TIM15_FORCE_RESET __HAL_RCC_TIM15_FORCE_RESET
N#define __TIM15_RELEASE_RESET __HAL_RCC_TIM15_RELEASE_RESET
N#define __TIM16_CLK_DISABLE __HAL_RCC_TIM16_CLK_DISABLE
N#define __TIM16_CLK_ENABLE __HAL_RCC_TIM16_CLK_ENABLE
N#define __TIM16_CLK_SLEEP_DISABLE __HAL_RCC_TIM16_CLK_SLEEP_DISABLE
N#define __TIM16_CLK_SLEEP_ENABLE __HAL_RCC_TIM16_CLK_SLEEP_ENABLE
N#define __TIM16_FORCE_RESET __HAL_RCC_TIM16_FORCE_RESET
N#define __TIM16_RELEASE_RESET __HAL_RCC_TIM16_RELEASE_RESET
N#define __TIM17_CLK_DISABLE __HAL_RCC_TIM17_CLK_DISABLE
N#define __TIM17_CLK_ENABLE __HAL_RCC_TIM17_CLK_ENABLE
N#define __TIM17_CLK_SLEEP_DISABLE __HAL_RCC_TIM17_CLK_SLEEP_DISABLE
N#define __TIM17_CLK_SLEEP_ENABLE __HAL_RCC_TIM17_CLK_SLEEP_ENABLE
N#define __TIM17_FORCE_RESET __HAL_RCC_TIM17_FORCE_RESET
N#define __TIM17_RELEASE_RESET __HAL_RCC_TIM17_RELEASE_RESET
N#define __TIM2_CLK_DISABLE __HAL_RCC_TIM2_CLK_DISABLE
N#define __TIM2_CLK_ENABLE __HAL_RCC_TIM2_CLK_ENABLE
N#define __TIM2_CLK_SLEEP_DISABLE __HAL_RCC_TIM2_CLK_SLEEP_DISABLE
N#define __TIM2_CLK_SLEEP_ENABLE __HAL_RCC_TIM2_CLK_SLEEP_ENABLE
N#define __TIM2_FORCE_RESET __HAL_RCC_TIM2_FORCE_RESET
N#define __TIM2_RELEASE_RESET __HAL_RCC_TIM2_RELEASE_RESET
N#define __TIM3_CLK_DISABLE __HAL_RCC_TIM3_CLK_DISABLE
N#define __TIM3_CLK_ENABLE __HAL_RCC_TIM3_CLK_ENABLE
N#define __TIM3_CLK_SLEEP_DISABLE __HAL_RCC_TIM3_CLK_SLEEP_DISABLE
N#define __TIM3_CLK_SLEEP_ENABLE __HAL_RCC_TIM3_CLK_SLEEP_ENABLE
N#define __TIM3_FORCE_RESET __HAL_RCC_TIM3_FORCE_RESET
N#define __TIM3_RELEASE_RESET __HAL_RCC_TIM3_RELEASE_RESET
N#define __TIM4_CLK_DISABLE __HAL_RCC_TIM4_CLK_DISABLE
N#define __TIM4_CLK_ENABLE __HAL_RCC_TIM4_CLK_ENABLE
N#define __TIM4_CLK_SLEEP_DISABLE __HAL_RCC_TIM4_CLK_SLEEP_DISABLE
N#define __TIM4_CLK_SLEEP_ENABLE __HAL_RCC_TIM4_CLK_SLEEP_ENABLE
N#define __TIM4_FORCE_RESET __HAL_RCC_TIM4_FORCE_RESET
N#define __TIM4_RELEASE_RESET __HAL_RCC_TIM4_RELEASE_RESET
N#define __TIM5_CLK_DISABLE __HAL_RCC_TIM5_CLK_DISABLE
N#define __TIM5_CLK_ENABLE __HAL_RCC_TIM5_CLK_ENABLE
N#define __TIM5_CLK_SLEEP_DISABLE __HAL_RCC_TIM5_CLK_SLEEP_DISABLE
N#define __TIM5_CLK_SLEEP_ENABLE __HAL_RCC_TIM5_CLK_SLEEP_ENABLE
N#define __TIM5_FORCE_RESET __HAL_RCC_TIM5_FORCE_RESET
N#define __TIM5_RELEASE_RESET __HAL_RCC_TIM5_RELEASE_RESET
N#define __TIM6_CLK_DISABLE __HAL_RCC_TIM6_CLK_DISABLE
N#define __TIM6_CLK_ENABLE __HAL_RCC_TIM6_CLK_ENABLE
N#define __TIM6_CLK_SLEEP_DISABLE __HAL_RCC_TIM6_CLK_SLEEP_DISABLE
N#define __TIM6_CLK_SLEEP_ENABLE __HAL_RCC_TIM6_CLK_SLEEP_ENABLE
N#define __TIM6_FORCE_RESET __HAL_RCC_TIM6_FORCE_RESET
N#define __TIM6_RELEASE_RESET __HAL_RCC_TIM6_RELEASE_RESET
N#define __TIM7_CLK_DISABLE __HAL_RCC_TIM7_CLK_DISABLE
N#define __TIM7_CLK_ENABLE __HAL_RCC_TIM7_CLK_ENABLE
N#define __TIM7_CLK_SLEEP_DISABLE __HAL_RCC_TIM7_CLK_SLEEP_DISABLE
N#define __TIM7_CLK_SLEEP_ENABLE __HAL_RCC_TIM7_CLK_SLEEP_ENABLE
N#define __TIM7_FORCE_RESET __HAL_RCC_TIM7_FORCE_RESET
N#define __TIM7_RELEASE_RESET __HAL_RCC_TIM7_RELEASE_RESET
N#define __TIM8_CLK_DISABLE __HAL_RCC_TIM8_CLK_DISABLE
N#define __TIM8_CLK_ENABLE __HAL_RCC_TIM8_CLK_ENABLE
N#define __TIM8_CLK_SLEEP_DISABLE __HAL_RCC_TIM8_CLK_SLEEP_DISABLE
N#define __TIM8_CLK_SLEEP_ENABLE __HAL_RCC_TIM8_CLK_SLEEP_ENABLE
N#define __TIM8_FORCE_RESET __HAL_RCC_TIM8_FORCE_RESET
N#define __TIM8_RELEASE_RESET __HAL_RCC_TIM8_RELEASE_RESET
N#define __TIM9_CLK_DISABLE __HAL_RCC_TIM9_CLK_DISABLE
N#define __TIM9_CLK_ENABLE __HAL_RCC_TIM9_CLK_ENABLE
N#define __TIM9_FORCE_RESET __HAL_RCC_TIM9_FORCE_RESET
N#define __TIM9_RELEASE_RESET __HAL_RCC_TIM9_RELEASE_RESET
N#define __TSC_CLK_DISABLE __HAL_RCC_TSC_CLK_DISABLE
N#define __TSC_CLK_ENABLE __HAL_RCC_TSC_CLK_ENABLE
N#define __TSC_CLK_SLEEP_DISABLE __HAL_RCC_TSC_CLK_SLEEP_DISABLE
N#define __TSC_CLK_SLEEP_ENABLE __HAL_RCC_TSC_CLK_SLEEP_ENABLE
N#define __TSC_FORCE_RESET __HAL_RCC_TSC_FORCE_RESET
N#define __TSC_RELEASE_RESET __HAL_RCC_TSC_RELEASE_RESET
N#define __UART4_CLK_DISABLE __HAL_RCC_UART4_CLK_DISABLE
N#define __UART4_CLK_ENABLE __HAL_RCC_UART4_CLK_ENABLE
N#define __UART4_CLK_SLEEP_DISABLE __HAL_RCC_UART4_CLK_SLEEP_DISABLE
N#define __UART4_CLK_SLEEP_ENABLE __HAL_RCC_UART4_CLK_SLEEP_ENABLE
N#define __UART4_FORCE_RESET __HAL_RCC_UART4_FORCE_RESET
N#define __UART4_RELEASE_RESET __HAL_RCC_UART4_RELEASE_RESET
N#define __UART5_CLK_DISABLE __HAL_RCC_UART5_CLK_DISABLE
N#define __UART5_CLK_ENABLE __HAL_RCC_UART5_CLK_ENABLE
N#define __UART5_CLK_SLEEP_DISABLE __HAL_RCC_UART5_CLK_SLEEP_DISABLE
N#define __UART5_CLK_SLEEP_ENABLE __HAL_RCC_UART5_CLK_SLEEP_ENABLE
N#define __UART5_FORCE_RESET __HAL_RCC_UART5_FORCE_RESET
N#define __UART5_RELEASE_RESET __HAL_RCC_UART5_RELEASE_RESET
N#define __USART1_CLK_DISABLE __HAL_RCC_USART1_CLK_DISABLE
N#define __USART1_CLK_ENABLE __HAL_RCC_USART1_CLK_ENABLE
N#define __USART1_CLK_SLEEP_DISABLE __HAL_RCC_USART1_CLK_SLEEP_DISABLE
N#define __USART1_CLK_SLEEP_ENABLE __HAL_RCC_USART1_CLK_SLEEP_ENABLE
N#define __USART1_FORCE_RESET __HAL_RCC_USART1_FORCE_RESET
N#define __USART1_RELEASE_RESET __HAL_RCC_USART1_RELEASE_RESET
N#define __USART2_CLK_DISABLE __HAL_RCC_USART2_CLK_DISABLE
N#define __USART2_CLK_ENABLE __HAL_RCC_USART2_CLK_ENABLE
N#define __USART2_CLK_SLEEP_DISABLE __HAL_RCC_USART2_CLK_SLEEP_DISABLE
N#define __USART2_CLK_SLEEP_ENABLE __HAL_RCC_USART2_CLK_SLEEP_ENABLE
N#define __USART2_FORCE_RESET __HAL_RCC_USART2_FORCE_RESET
N#define __USART2_RELEASE_RESET __HAL_RCC_USART2_RELEASE_RESET
N#define __USART3_CLK_DISABLE __HAL_RCC_USART3_CLK_DISABLE
N#define __USART3_CLK_ENABLE __HAL_RCC_USART3_CLK_ENABLE
N#define __USART3_CLK_SLEEP_DISABLE __HAL_RCC_USART3_CLK_SLEEP_DISABLE
N#define __USART3_CLK_SLEEP_ENABLE __HAL_RCC_USART3_CLK_SLEEP_ENABLE
N#define __USART3_FORCE_RESET __HAL_RCC_USART3_FORCE_RESET
N#define __USART3_RELEASE_RESET __HAL_RCC_USART3_RELEASE_RESET
N#define __USART4_CLK_DISABLE        __HAL_RCC_USART4_CLK_DISABLE
N#define __USART4_CLK_ENABLE         __HAL_RCC_USART4_CLK_ENABLE
N#define __USART4_CLK_SLEEP_ENABLE   __HAL_RCC_USART4_CLK_SLEEP_ENABLE
N#define __USART4_CLK_SLEEP_DISABLE  __HAL_RCC_USART4_CLK_SLEEP_DISABLE 
N#define __USART4_FORCE_RESET        __HAL_RCC_USART4_FORCE_RESET
N#define __USART4_RELEASE_RESET      __HAL_RCC_USART4_RELEASE_RESET
N#define __USART5_CLK_DISABLE        __HAL_RCC_USART5_CLK_DISABLE
N#define __USART5_CLK_ENABLE         __HAL_RCC_USART5_CLK_ENABLE
N#define __USART5_CLK_SLEEP_ENABLE   __HAL_RCC_USART5_CLK_SLEEP_ENABLE
N#define __USART5_CLK_SLEEP_DISABLE  __HAL_RCC_USART5_CLK_SLEEP_DISABLE 
N#define __USART5_FORCE_RESET        __HAL_RCC_USART5_FORCE_RESET
N#define __USART5_RELEASE_RESET      __HAL_RCC_USART5_RELEASE_RESET
N#define __USART7_CLK_DISABLE        __HAL_RCC_USART7_CLK_DISABLE
N#define __USART7_CLK_ENABLE         __HAL_RCC_USART7_CLK_ENABLE
N#define __USART7_FORCE_RESET        __HAL_RCC_USART7_FORCE_RESET
N#define __USART7_RELEASE_RESET      __HAL_RCC_USART7_RELEASE_RESET
N#define __USART8_CLK_DISABLE        __HAL_RCC_USART8_CLK_DISABLE
N#define __USART8_CLK_ENABLE         __HAL_RCC_USART8_CLK_ENABLE
N#define __USART8_FORCE_RESET        __HAL_RCC_USART8_FORCE_RESET
N#define __USART8_RELEASE_RESET      __HAL_RCC_USART8_RELEASE_RESET
N#define __USB_CLK_DISABLE         __HAL_RCC_USB_CLK_DISABLE
N#define __USB_CLK_ENABLE          __HAL_RCC_USB_CLK_ENABLE
N#define __USB_FORCE_RESET         __HAL_RCC_USB_FORCE_RESET
N#define __USB_CLK_SLEEP_ENABLE    __HAL_RCC_USB_CLK_SLEEP_ENABLE
N#define __USB_CLK_SLEEP_DISABLE   __HAL_RCC_USB_CLK_SLEEP_DISABLE
N#define __USB_OTG_FS_CLK_DISABLE __HAL_RCC_USB_OTG_FS_CLK_DISABLE
N#define __USB_OTG_FS_CLK_ENABLE __HAL_RCC_USB_OTG_FS_CLK_ENABLE
N#define __USB_RELEASE_RESET __HAL_RCC_USB_RELEASE_RESET
N#define __WWDG_CLK_DISABLE __HAL_RCC_WWDG_CLK_DISABLE
N#define __WWDG_CLK_ENABLE __HAL_RCC_WWDG_CLK_ENABLE
N#define __WWDG_CLK_SLEEP_DISABLE __HAL_RCC_WWDG_CLK_SLEEP_DISABLE
N#define __WWDG_CLK_SLEEP_ENABLE __HAL_RCC_WWDG_CLK_SLEEP_ENABLE
N#define __WWDG_FORCE_RESET __HAL_RCC_WWDG_FORCE_RESET
N#define __WWDG_RELEASE_RESET __HAL_RCC_WWDG_RELEASE_RESET
N#define __TIM21_CLK_ENABLE   __HAL_RCC_TIM21_CLK_ENABLE
N#define __TIM21_CLK_DISABLE   __HAL_RCC_TIM21_CLK_DISABLE
N#define __TIM21_FORCE_RESET   __HAL_RCC_TIM21_FORCE_RESET
N#define __TIM21_RELEASE_RESET  __HAL_RCC_TIM21_RELEASE_RESET
N#define __TIM21_CLK_SLEEP_ENABLE   __HAL_RCC_TIM21_CLK_SLEEP_ENABLE
N#define __TIM21_CLK_SLEEP_DISABLE   __HAL_RCC_TIM21_CLK_SLEEP_DISABLE
N#define __TIM22_CLK_ENABLE   __HAL_RCC_TIM22_CLK_ENABLE
N#define __TIM22_CLK_DISABLE   __HAL_RCC_TIM22_CLK_DISABLE
N#define __TIM22_FORCE_RESET   __HAL_RCC_TIM22_FORCE_RESET
N#define __TIM22_RELEASE_RESET  __HAL_RCC_TIM22_RELEASE_RESET
N#define __TIM22_CLK_SLEEP_ENABLE   __HAL_RCC_TIM22_CLK_SLEEP_ENABLE
N#define __TIM22_CLK_SLEEP_DISABLE   __HAL_RCC_TIM22_CLK_SLEEP_DISABLE
N#define __CRS_CLK_DISABLE __HAL_RCC_CRS_CLK_DISABLE
N#define __CRS_CLK_ENABLE __HAL_RCC_CRS_CLK_ENABLE
N#define __CRS_CLK_SLEEP_DISABLE __HAL_RCC_CRS_CLK_SLEEP_DISABLE
N#define __CRS_CLK_SLEEP_ENABLE __HAL_RCC_CRS_CLK_SLEEP_ENABLE
N#define __CRS_FORCE_RESET __HAL_RCC_CRS_FORCE_RESET
N#define __CRS_RELEASE_RESET __HAL_RCC_CRS_RELEASE_RESET
N#define __RCC_BACKUPRESET_FORCE __HAL_RCC_BACKUPRESET_FORCE
N#define __RCC_BACKUPRESET_RELEASE __HAL_RCC_BACKUPRESET_RELEASE
N
N#define __USB_OTG_FS_FORCE_RESET  __HAL_RCC_USB_OTG_FS_FORCE_RESET
N#define __USB_OTG_FS_RELEASE_RESET  __HAL_RCC_USB_OTG_FS_RELEASE_RESET
N#define __USB_OTG_FS_CLK_SLEEP_ENABLE  __HAL_RCC_USB_OTG_FS_CLK_SLEEP_ENABLE
N#define __USB_OTG_FS_CLK_SLEEP_DISABLE  __HAL_RCC_USB_OTG_FS_CLK_SLEEP_DISABLE
N#define __USB_OTG_HS_CLK_DISABLE  __HAL_RCC_USB_OTG_HS_CLK_DISABLE
N#define __USB_OTG_HS_CLK_ENABLE          __HAL_RCC_USB_OTG_HS_CLK_ENABLE
N#define __USB_OTG_HS_ULPI_CLK_ENABLE  __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE
N#define __USB_OTG_HS_ULPI_CLK_DISABLE  __HAL_RCC_USB_OTG_HS_ULPI_CLK_DISABLE  
N#define __TIM9_CLK_SLEEP_ENABLE          __HAL_RCC_TIM9_CLK_SLEEP_ENABLE
N#define __TIM9_CLK_SLEEP_DISABLE  __HAL_RCC_TIM9_CLK_SLEEP_DISABLE  
N#define __TIM10_CLK_SLEEP_ENABLE  __HAL_RCC_TIM10_CLK_SLEEP_ENABLE
N#define __TIM10_CLK_SLEEP_DISABLE  __HAL_RCC_TIM10_CLK_SLEEP_DISABLE  
N#define __TIM11_CLK_SLEEP_ENABLE  __HAL_RCC_TIM11_CLK_SLEEP_ENABLE
N#define __TIM11_CLK_SLEEP_DISABLE  __HAL_RCC_TIM11_CLK_SLEEP_DISABLE  
N#define __ETHMACPTP_CLK_SLEEP_ENABLE  __HAL_RCC_ETHMACPTP_CLK_SLEEP_ENABLE
N#define __ETHMACPTP_CLK_SLEEP_DISABLE  __HAL_RCC_ETHMACPTP_CLK_SLEEP_DISABLE
N#define __ETHMACPTP_CLK_ENABLE          __HAL_RCC_ETHMACPTP_CLK_ENABLE
N#define __ETHMACPTP_CLK_DISABLE          __HAL_RCC_ETHMACPTP_CLK_DISABLE  
N#define __HASH_CLK_ENABLE          __HAL_RCC_HASH_CLK_ENABLE
N#define __HASH_FORCE_RESET          __HAL_RCC_HASH_FORCE_RESET
N#define __HASH_RELEASE_RESET          __HAL_RCC_HASH_RELEASE_RESET
N#define __HASH_CLK_SLEEP_ENABLE          __HAL_RCC_HASH_CLK_SLEEP_ENABLE
N#define __HASH_CLK_SLEEP_DISABLE  __HAL_RCC_HASH_CLK_SLEEP_DISABLE
N#define __HASH_CLK_DISABLE            __HAL_RCC_HASH_CLK_DISABLE  
N#define __SPI5_CLK_ENABLE          __HAL_RCC_SPI5_CLK_ENABLE
N#define __SPI5_CLK_DISABLE              __HAL_RCC_SPI5_CLK_DISABLE
N#define __SPI5_FORCE_RESET          __HAL_RCC_SPI5_FORCE_RESET
N#define __SPI5_RELEASE_RESET          __HAL_RCC_SPI5_RELEASE_RESET
N#define __SPI5_CLK_SLEEP_ENABLE          __HAL_RCC_SPI5_CLK_SLEEP_ENABLE
N#define __SPI5_CLK_SLEEP_DISABLE  __HAL_RCC_SPI5_CLK_SLEEP_DISABLE  
N#define __SPI6_CLK_ENABLE          __HAL_RCC_SPI6_CLK_ENABLE
N#define __SPI6_CLK_DISABLE          __HAL_RCC_SPI6_CLK_DISABLE
N#define __SPI6_FORCE_RESET          __HAL_RCC_SPI6_FORCE_RESET
N#define __SPI6_RELEASE_RESET         __HAL_RCC_SPI6_RELEASE_RESET
N#define __SPI6_CLK_SLEEP_ENABLE          __HAL_RCC_SPI6_CLK_SLEEP_ENABLE
N#define __SPI6_CLK_SLEEP_DISABLE  __HAL_RCC_SPI6_CLK_SLEEP_DISABLE  
N#define __LTDC_CLK_ENABLE          __HAL_RCC_LTDC_CLK_ENABLE
N#define __LTDC_CLK_DISABLE          __HAL_RCC_LTDC_CLK_DISABLE
N#define __LTDC_FORCE_RESET          __HAL_RCC_LTDC_FORCE_RESET
N#define __LTDC_RELEASE_RESET          __HAL_RCC_LTDC_RELEASE_RESET
N#define __LTDC_CLK_SLEEP_ENABLE          __HAL_RCC_LTDC_CLK_SLEEP_ENABLE  
N#define __ETHMAC_CLK_SLEEP_ENABLE  __HAL_RCC_ETHMAC_CLK_SLEEP_ENABLE
N#define __ETHMAC_CLK_SLEEP_DISABLE  __HAL_RCC_ETHMAC_CLK_SLEEP_DISABLE  
N#define __ETHMACTX_CLK_SLEEP_ENABLE  __HAL_RCC_ETHMACTX_CLK_SLEEP_ENABLE
N#define __ETHMACTX_CLK_SLEEP_DISABLE  __HAL_RCC_ETHMACTX_CLK_SLEEP_DISABLE  
N#define __ETHMACRX_CLK_SLEEP_ENABLE  __HAL_RCC_ETHMACRX_CLK_SLEEP_ENABLE
N#define __ETHMACRX_CLK_SLEEP_DISABLE  __HAL_RCC_ETHMACRX_CLK_SLEEP_DISABLE  
N#define __TIM12_CLK_SLEEP_ENABLE  __HAL_RCC_TIM12_CLK_SLEEP_ENABLE
N#define __TIM12_CLK_SLEEP_DISABLE  __HAL_RCC_TIM12_CLK_SLEEP_DISABLE  
N#define __TIM13_CLK_SLEEP_ENABLE  __HAL_RCC_TIM13_CLK_SLEEP_ENABLE
N#define __TIM13_CLK_SLEEP_DISABLE  __HAL_RCC_TIM13_CLK_SLEEP_DISABLE  
N#define __TIM14_CLK_SLEEP_ENABLE  __HAL_RCC_TIM14_CLK_SLEEP_ENABLE
N#define __TIM14_CLK_SLEEP_DISABLE  __HAL_RCC_TIM14_CLK_SLEEP_DISABLE  
N#define __BKPSRAM_CLK_ENABLE          __HAL_RCC_BKPSRAM_CLK_ENABLE
N#define __BKPSRAM_CLK_DISABLE          __HAL_RCC_BKPSRAM_CLK_DISABLE
N#define __BKPSRAM_CLK_SLEEP_ENABLE  __HAL_RCC_BKPSRAM_CLK_SLEEP_ENABLE
N#define __BKPSRAM_CLK_SLEEP_DISABLE  __HAL_RCC_BKPSRAM_CLK_SLEEP_DISABLE  
N#define __CCMDATARAMEN_CLK_ENABLE  __HAL_RCC_CCMDATARAMEN_CLK_ENABLE
N#define __CCMDATARAMEN_CLK_DISABLE  __HAL_RCC_CCMDATARAMEN_CLK_DISABLE  
N#define __USART6_CLK_ENABLE          __HAL_RCC_USART6_CLK_ENABLE
N#define __USART6_CLK_DISABLE          __HAL_RCC_USART6_CLK_DISABLE
N#define __USART6_FORCE_RESET        __HAL_RCC_USART6_FORCE_RESET
N#define __USART6_RELEASE_RESET        __HAL_RCC_USART6_RELEASE_RESET
N#define __USART6_CLK_SLEEP_ENABLE  __HAL_RCC_USART6_CLK_SLEEP_ENABLE
N#define __USART6_CLK_SLEEP_DISABLE  __HAL_RCC_USART6_CLK_SLEEP_DISABLE  
N#define __SPI4_CLK_ENABLE          __HAL_RCC_SPI4_CLK_ENABLE
N#define __SPI4_CLK_DISABLE          __HAL_RCC_SPI4_CLK_DISABLE
N#define __SPI4_FORCE_RESET          __HAL_RCC_SPI4_FORCE_RESET
N#define __SPI4_RELEASE_RESET        __HAL_RCC_SPI4_RELEASE_RESET
N#define __SPI4_CLK_SLEEP_ENABLE   __HAL_RCC_SPI4_CLK_SLEEP_ENABLE
N#define __SPI4_CLK_SLEEP_DISABLE  __HAL_RCC_SPI4_CLK_SLEEP_DISABLE  
N#define __GPIOI_CLK_ENABLE          __HAL_RCC_GPIOI_CLK_ENABLE
N#define __GPIOI_CLK_DISABLE          __HAL_RCC_GPIOI_CLK_DISABLE
N#define __GPIOI_FORCE_RESET          __HAL_RCC_GPIOI_FORCE_RESET
N#define __GPIOI_RELEASE_RESET          __HAL_RCC_GPIOI_RELEASE_RESET
N#define __GPIOI_CLK_SLEEP_ENABLE  __HAL_RCC_GPIOI_CLK_SLEEP_ENABLE
N#define __GPIOI_CLK_SLEEP_DISABLE  __HAL_RCC_GPIOI_CLK_SLEEP_DISABLE  
N#define __GPIOJ_CLK_ENABLE          __HAL_RCC_GPIOJ_CLK_ENABLE
N#define __GPIOJ_CLK_DISABLE          __HAL_RCC_GPIOJ_CLK_DISABLE
N#define __GPIOJ_FORCE_RESET         __HAL_RCC_GPIOJ_FORCE_RESET
N#define __GPIOJ_RELEASE_RESET          __HAL_RCC_GPIOJ_RELEASE_RESET
N#define __GPIOJ_CLK_SLEEP_ENABLE  __HAL_RCC_GPIOJ_CLK_SLEEP_ENABLE
N#define __GPIOJ_CLK_SLEEP_DISABLE  __HAL_RCC_GPIOJ_CLK_SLEEP_DISABLE  
N#define __GPIOK_CLK_ENABLE          __HAL_RCC_GPIOK_CLK_ENABLE
N#define __GPIOK_CLK_DISABLE          __HAL_RCC_GPIOK_CLK_DISABLE
N#define __GPIOK_RELEASE_RESET          __HAL_RCC_GPIOK_RELEASE_RESET
N#define __GPIOK_CLK_SLEEP_ENABLE  __HAL_RCC_GPIOK_CLK_SLEEP_ENABLE
N#define __GPIOK_CLK_SLEEP_DISABLE  __HAL_RCC_GPIOK_CLK_SLEEP_DISABLE  
N#define __ETH_CLK_ENABLE          __HAL_RCC_ETH_CLK_ENABLE
N#define __ETH_CLK_DISABLE          __HAL_RCC_ETH_CLK_DISABLE  
N#define __DCMI_CLK_ENABLE          __HAL_RCC_DCMI_CLK_ENABLE
N#define __DCMI_CLK_DISABLE          __HAL_RCC_DCMI_CLK_DISABLE
N#define __DCMI_FORCE_RESET          __HAL_RCC_DCMI_FORCE_RESET
N#define __DCMI_RELEASE_RESET          __HAL_RCC_DCMI_RELEASE_RESET
N#define __DCMI_CLK_SLEEP_ENABLE   __HAL_RCC_DCMI_CLK_SLEEP_ENABLE
N#define __DCMI_CLK_SLEEP_DISABLE  __HAL_RCC_DCMI_CLK_SLEEP_DISABLE  
N#define __UART7_CLK_ENABLE          __HAL_RCC_UART7_CLK_ENABLE
N#define __UART7_CLK_DISABLE          __HAL_RCC_UART7_CLK_DISABLE
N#define __UART7_RELEASE_RESET       __HAL_RCC_UART7_RELEASE_RESET
N#define __UART7_FORCE_RESET       __HAL_RCC_UART7_FORCE_RESET
N#define __UART7_CLK_SLEEP_ENABLE  __HAL_RCC_UART7_CLK_SLEEP_ENABLE
N#define __UART7_CLK_SLEEP_DISABLE  __HAL_RCC_UART7_CLK_SLEEP_DISABLE  
N#define __UART8_CLK_ENABLE          __HAL_RCC_UART8_CLK_ENABLE
N#define __UART8_CLK_DISABLE          __HAL_RCC_UART8_CLK_DISABLE
N#define __UART8_FORCE_RESET          __HAL_RCC_UART8_FORCE_RESET
N#define __UART8_RELEASE_RESET          __HAL_RCC_UART8_RELEASE_RESET
N#define __UART8_CLK_SLEEP_ENABLE  __HAL_RCC_UART8_CLK_SLEEP_ENABLE
N#define __UART8_CLK_SLEEP_DISABLE  __HAL_RCC_UART8_CLK_SLEEP_DISABLE  
N#define __OTGHS_CLK_SLEEP_ENABLE  __HAL_RCC_USB_OTG_HS_CLK_SLEEP_ENABLE
N#define __OTGHS_CLK_SLEEP_DISABLE  __HAL_RCC_USB_OTG_HS_CLK_SLEEP_DISABLE
N#define __OTGHS_FORCE_RESET          __HAL_RCC_USB_OTG_HS_FORCE_RESET
N#define __OTGHS_RELEASE_RESET          __HAL_RCC_USB_OTG_HS_RELEASE_RESET  
N#define __OTGHSULPI_CLK_SLEEP_ENABLE  __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_ENABLE
N#define __OTGHSULPI_CLK_SLEEP_DISABLE  __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_DISABLE
N#define __HAL_RCC_OTGHS_CLK_SLEEP_ENABLE  __HAL_RCC_USB_OTG_HS_CLK_SLEEP_ENABLE
N#define __HAL_RCC_OTGHS_CLK_SLEEP_DISABLE  __HAL_RCC_USB_OTG_HS_CLK_SLEEP_DISABLE
N#define __HAL_RCC_OTGHS_IS_CLK_SLEEP_ENABLED __HAL_RCC_USB_OTG_HS_IS_CLK_SLEEP_ENABLED
N#define __HAL_RCC_OTGHS_IS_CLK_SLEEP_DISABLED __HAL_RCC_USB_OTG_HS_IS_CLK_SLEEP_DISABLED
N#define __HAL_RCC_OTGHS_FORCE_RESET          __HAL_RCC_USB_OTG_HS_FORCE_RESET
N#define __HAL_RCC_OTGHS_RELEASE_RESET          __HAL_RCC_USB_OTG_HS_RELEASE_RESET  
N#define __HAL_RCC_OTGHSULPI_CLK_SLEEP_ENABLE      __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_ENABLE
N#define __HAL_RCC_OTGHSULPI_CLK_SLEEP_DISABLE     __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_DISABLE 
N#define __HAL_RCC_OTGHSULPI_IS_CLK_SLEEP_ENABLED  __HAL_RCC_USB_OTG_HS_ULPI_IS_CLK_SLEEP_ENABLED
N#define __HAL_RCC_OTGHSULPI_IS_CLK_SLEEP_DISABLED __HAL_RCC_USB_OTG_HS_ULPI_IS_CLK_SLEEP_DISABLED   
N#define __CRYP_FORCE_RESET             __HAL_RCC_CRYP_FORCE_RESET  
N#define __SRAM3_CLK_SLEEP_ENABLE       __HAL_RCC_SRAM3_CLK_SLEEP_ENABLE  
N#define __CAN2_CLK_SLEEP_ENABLE        __HAL_RCC_CAN2_CLK_SLEEP_ENABLE
N#define __CAN2_CLK_SLEEP_DISABLE       __HAL_RCC_CAN2_CLK_SLEEP_DISABLE  
N#define __DAC_CLK_SLEEP_ENABLE         __HAL_RCC_DAC_CLK_SLEEP_ENABLE
N#define __DAC_CLK_SLEEP_DISABLE        __HAL_RCC_DAC_CLK_SLEEP_DISABLE  
N#define __ADC2_CLK_SLEEP_ENABLE        __HAL_RCC_ADC2_CLK_SLEEP_ENABLE
N#define __ADC2_CLK_SLEEP_DISABLE       __HAL_RCC_ADC2_CLK_SLEEP_DISABLE  
N#define __ADC3_CLK_SLEEP_ENABLE        __HAL_RCC_ADC3_CLK_SLEEP_ENABLE
N#define __ADC3_CLK_SLEEP_DISABLE       __HAL_RCC_ADC3_CLK_SLEEP_DISABLE  
N#define __FSMC_FORCE_RESET             __HAL_RCC_FSMC_FORCE_RESET
N#define __FSMC_RELEASE_RESET           __HAL_RCC_FSMC_RELEASE_RESET
N#define __FSMC_CLK_SLEEP_ENABLE        __HAL_RCC_FSMC_CLK_SLEEP_ENABLE
N#define __FSMC_CLK_SLEEP_DISABLE       __HAL_RCC_FSMC_CLK_SLEEP_DISABLE  
N#define __SDIO_FORCE_RESET             __HAL_RCC_SDIO_FORCE_RESET
N#define __SDIO_RELEASE_RESET           __HAL_RCC_SDIO_RELEASE_RESET
N#define __SDIO_CLK_SLEEP_DISABLE       __HAL_RCC_SDIO_CLK_SLEEP_DISABLE
N#define __SDIO_CLK_SLEEP_ENABLE        __HAL_RCC_SDIO_CLK_SLEEP_ENABLE  
N#define __DMA2D_CLK_ENABLE             __HAL_RCC_DMA2D_CLK_ENABLE
N#define __DMA2D_CLK_DISABLE            __HAL_RCC_DMA2D_CLK_DISABLE
N#define __DMA2D_FORCE_RESET            __HAL_RCC_DMA2D_FORCE_RESET
N#define __DMA2D_RELEASE_RESET          __HAL_RCC_DMA2D_RELEASE_RESET
N#define __DMA2D_CLK_SLEEP_ENABLE       __HAL_RCC_DMA2D_CLK_SLEEP_ENABLE
N#define __DMA2D_CLK_SLEEP_DISABLE      __HAL_RCC_DMA2D_CLK_SLEEP_DISABLE
N
N/* alias define maintained for legacy */
N#define __HAL_RCC_OTGFS_FORCE_RESET    __HAL_RCC_USB_OTG_FS_FORCE_RESET
N#define __HAL_RCC_OTGFS_RELEASE_RESET  __HAL_RCC_USB_OTG_FS_RELEASE_RESET
N
N#define __ADC12_CLK_ENABLE          __HAL_RCC_ADC12_CLK_ENABLE
N#define __ADC12_CLK_DISABLE         __HAL_RCC_ADC12_CLK_DISABLE
N#define __ADC34_CLK_ENABLE          __HAL_RCC_ADC34_CLK_ENABLE
N#define __ADC34_CLK_DISABLE         __HAL_RCC_ADC34_CLK_DISABLE
N#define __ADC12_CLK_ENABLE          __HAL_RCC_ADC12_CLK_ENABLE
N#define __ADC12_CLK_DISABLE         __HAL_RCC_ADC12_CLK_DISABLE
N#define __DAC2_CLK_ENABLE           __HAL_RCC_DAC2_CLK_ENABLE
N#define __DAC2_CLK_DISABLE          __HAL_RCC_DAC2_CLK_DISABLE
N#define __TIM18_CLK_ENABLE          __HAL_RCC_TIM18_CLK_ENABLE
N#define __TIM18_CLK_DISABLE         __HAL_RCC_TIM18_CLK_DISABLE
N#define __TIM19_CLK_ENABLE          __HAL_RCC_TIM19_CLK_ENABLE
N#define __TIM19_CLK_DISABLE         __HAL_RCC_TIM19_CLK_DISABLE
N#define __TIM20_CLK_ENABLE          __HAL_RCC_TIM20_CLK_ENABLE
N#define __TIM20_CLK_DISABLE         __HAL_RCC_TIM20_CLK_DISABLE
N#define __HRTIM1_CLK_ENABLE         __HAL_RCC_HRTIM1_CLK_ENABLE
N#define __HRTIM1_CLK_DISABLE        __HAL_RCC_HRTIM1_CLK_DISABLE
N#define __SDADC1_CLK_ENABLE         __HAL_RCC_SDADC1_CLK_ENABLE
N#define __SDADC2_CLK_ENABLE         __HAL_RCC_SDADC2_CLK_ENABLE
N#define __SDADC3_CLK_ENABLE         __HAL_RCC_SDADC3_CLK_ENABLE
N#define __SDADC1_CLK_DISABLE        __HAL_RCC_SDADC1_CLK_DISABLE
N#define __SDADC2_CLK_DISABLE        __HAL_RCC_SDADC2_CLK_DISABLE
N#define __SDADC3_CLK_DISABLE        __HAL_RCC_SDADC3_CLK_DISABLE
N
N#define __ADC12_FORCE_RESET         __HAL_RCC_ADC12_FORCE_RESET
N#define __ADC12_RELEASE_RESET       __HAL_RCC_ADC12_RELEASE_RESET
N#define __ADC34_FORCE_RESET         __HAL_RCC_ADC34_FORCE_RESET
N#define __ADC34_RELEASE_RESET       __HAL_RCC_ADC34_RELEASE_RESET
N#define __ADC12_FORCE_RESET         __HAL_RCC_ADC12_FORCE_RESET
N#define __ADC12_RELEASE_RESET       __HAL_RCC_ADC12_RELEASE_RESET
N#define __DAC2_FORCE_RESET          __HAL_RCC_DAC2_FORCE_RESET
N#define __DAC2_RELEASE_RESET        __HAL_RCC_DAC2_RELEASE_RESET
N#define __TIM18_FORCE_RESET         __HAL_RCC_TIM18_FORCE_RESET
N#define __TIM18_RELEASE_RESET       __HAL_RCC_TIM18_RELEASE_RESET
N#define __TIM19_FORCE_RESET         __HAL_RCC_TIM19_FORCE_RESET
N#define __TIM19_RELEASE_RESET       __HAL_RCC_TIM19_RELEASE_RESET
N#define __TIM20_FORCE_RESET         __HAL_RCC_TIM20_FORCE_RESET
N#define __TIM20_RELEASE_RESET       __HAL_RCC_TIM20_RELEASE_RESET
N#define __HRTIM1_FORCE_RESET        __HAL_RCC_HRTIM1_FORCE_RESET
N#define __HRTIM1_RELEASE_RESET      __HAL_RCC_HRTIM1_RELEASE_RESET
N#define __SDADC1_FORCE_RESET        __HAL_RCC_SDADC1_FORCE_RESET
N#define __SDADC2_FORCE_RESET        __HAL_RCC_SDADC2_FORCE_RESET
N#define __SDADC3_FORCE_RESET        __HAL_RCC_SDADC3_FORCE_RESET
N#define __SDADC1_RELEASE_RESET      __HAL_RCC_SDADC1_RELEASE_RESET
N#define __SDADC2_RELEASE_RESET      __HAL_RCC_SDADC2_RELEASE_RESET
N#define __SDADC3_RELEASE_RESET      __HAL_RCC_SDADC3_RELEASE_RESET
N
N#define __ADC1_IS_CLK_ENABLED       __HAL_RCC_ADC1_IS_CLK_ENABLED
N#define __ADC1_IS_CLK_DISABLED      __HAL_RCC_ADC1_IS_CLK_DISABLED
N#define __ADC12_IS_CLK_ENABLED      __HAL_RCC_ADC12_IS_CLK_ENABLED
N#define __ADC12_IS_CLK_DISABLED     __HAL_RCC_ADC12_IS_CLK_DISABLED
N#define __ADC34_IS_CLK_ENABLED      __HAL_RCC_ADC34_IS_CLK_ENABLED
N#define __ADC34_IS_CLK_DISABLED     __HAL_RCC_ADC34_IS_CLK_DISABLED
N#define __CEC_IS_CLK_ENABLED        __HAL_RCC_CEC_IS_CLK_ENABLED
N#define __CEC_IS_CLK_DISABLED       __HAL_RCC_CEC_IS_CLK_DISABLED
N#define __CRC_IS_CLK_ENABLED        __HAL_RCC_CRC_IS_CLK_ENABLED
N#define __CRC_IS_CLK_DISABLED       __HAL_RCC_CRC_IS_CLK_DISABLED
N#define __DAC1_IS_CLK_ENABLED       __HAL_RCC_DAC1_IS_CLK_ENABLED
N#define __DAC1_IS_CLK_DISABLED      __HAL_RCC_DAC1_IS_CLK_DISABLED
N#define __DAC2_IS_CLK_ENABLED       __HAL_RCC_DAC2_IS_CLK_ENABLED
N#define __DAC2_IS_CLK_DISABLED      __HAL_RCC_DAC2_IS_CLK_DISABLED
N#define __DMA1_IS_CLK_ENABLED       __HAL_RCC_DMA1_IS_CLK_ENABLED
N#define __DMA1_IS_CLK_DISABLED      __HAL_RCC_DMA1_IS_CLK_DISABLED
N#define __DMA2_IS_CLK_ENABLED       __HAL_RCC_DMA2_IS_CLK_ENABLED
N#define __DMA2_IS_CLK_DISABLED      __HAL_RCC_DMA2_IS_CLK_DISABLED
N#define __FLITF_IS_CLK_ENABLED      __HAL_RCC_FLITF_IS_CLK_ENABLED
N#define __FLITF_IS_CLK_DISABLED     __HAL_RCC_FLITF_IS_CLK_DISABLED
N#define __FMC_IS_CLK_ENABLED        __HAL_RCC_FMC_IS_CLK_ENABLED
N#define __FMC_IS_CLK_DISABLED       __HAL_RCC_FMC_IS_CLK_DISABLED
N#define __GPIOA_IS_CLK_ENABLED      __HAL_RCC_GPIOA_IS_CLK_ENABLED
N#define __GPIOA_IS_CLK_DISABLED     __HAL_RCC_GPIOA_IS_CLK_DISABLED
N#define __GPIOB_IS_CLK_ENABLED      __HAL_RCC_GPIOB_IS_CLK_ENABLED
N#define __GPIOB_IS_CLK_DISABLED     __HAL_RCC_GPIOB_IS_CLK_DISABLED
N#define __GPIOC_IS_CLK_ENABLED      __HAL_RCC_GPIOC_IS_CLK_ENABLED
N#define __GPIOC_IS_CLK_DISABLED     __HAL_RCC_GPIOC_IS_CLK_DISABLED
N#define __GPIOD_IS_CLK_ENABLED      __HAL_RCC_GPIOD_IS_CLK_ENABLED
N#define __GPIOD_IS_CLK_DISABLED     __HAL_RCC_GPIOD_IS_CLK_DISABLED
N#define __GPIOE_IS_CLK_ENABLED      __HAL_RCC_GPIOE_IS_CLK_ENABLED
N#define __GPIOE_IS_CLK_DISABLED     __HAL_RCC_GPIOE_IS_CLK_DISABLED
N#define __GPIOF_IS_CLK_ENABLED      __HAL_RCC_GPIOF_IS_CLK_ENABLED
N#define __GPIOF_IS_CLK_DISABLED     __HAL_RCC_GPIOF_IS_CLK_DISABLED
N#define __GPIOG_IS_CLK_ENABLED      __HAL_RCC_GPIOG_IS_CLK_ENABLED
N#define __GPIOG_IS_CLK_DISABLED     __HAL_RCC_GPIOG_IS_CLK_DISABLED
N#define __GPIOH_IS_CLK_ENABLED      __HAL_RCC_GPIOH_IS_CLK_ENABLED
N#define __GPIOH_IS_CLK_DISABLED     __HAL_RCC_GPIOH_IS_CLK_DISABLED
N#define __HRTIM1_IS_CLK_ENABLED     __HAL_RCC_HRTIM1_IS_CLK_ENABLED
N#define __HRTIM1_IS_CLK_DISABLED    __HAL_RCC_HRTIM1_IS_CLK_DISABLED
N#define __I2C1_IS_CLK_ENABLED       __HAL_RCC_I2C1_IS_CLK_ENABLED
N#define __I2C1_IS_CLK_DISABLED      __HAL_RCC_I2C1_IS_CLK_DISABLED
N#define __I2C2_IS_CLK_ENABLED       __HAL_RCC_I2C2_IS_CLK_ENABLED
N#define __I2C2_IS_CLK_DISABLED      __HAL_RCC_I2C2_IS_CLK_DISABLED
N#define __I2C3_IS_CLK_ENABLED       __HAL_RCC_I2C3_IS_CLK_ENABLED
N#define __I2C3_IS_CLK_DISABLED      __HAL_RCC_I2C3_IS_CLK_DISABLED
N#define __PWR_IS_CLK_ENABLED        __HAL_RCC_PWR_IS_CLK_ENABLED
N#define __PWR_IS_CLK_DISABLED       __HAL_RCC_PWR_IS_CLK_DISABLED
N#define __SYSCFG_IS_CLK_ENABLED     __HAL_RCC_SYSCFG_IS_CLK_ENABLED
N#define __SYSCFG_IS_CLK_DISABLED    __HAL_RCC_SYSCFG_IS_CLK_DISABLED
N#define __SPI1_IS_CLK_ENABLED       __HAL_RCC_SPI1_IS_CLK_ENABLED
N#define __SPI1_IS_CLK_DISABLED      __HAL_RCC_SPI1_IS_CLK_DISABLED
N#define __SPI2_IS_CLK_ENABLED       __HAL_RCC_SPI2_IS_CLK_ENABLED
N#define __SPI2_IS_CLK_DISABLED      __HAL_RCC_SPI2_IS_CLK_DISABLED
N#define __SPI3_IS_CLK_ENABLED       __HAL_RCC_SPI3_IS_CLK_ENABLED
N#define __SPI3_IS_CLK_DISABLED      __HAL_RCC_SPI3_IS_CLK_DISABLED
N#define __SPI4_IS_CLK_ENABLED       __HAL_RCC_SPI4_IS_CLK_ENABLED
N#define __SPI4_IS_CLK_DISABLED      __HAL_RCC_SPI4_IS_CLK_DISABLED
N#define __SDADC1_IS_CLK_ENABLED     __HAL_RCC_SDADC1_IS_CLK_ENABLED
N#define __SDADC1_IS_CLK_DISABLED    __HAL_RCC_SDADC1_IS_CLK_DISABLED
N#define __SDADC2_IS_CLK_ENABLED     __HAL_RCC_SDADC2_IS_CLK_ENABLED
N#define __SDADC2_IS_CLK_DISABLED    __HAL_RCC_SDADC2_IS_CLK_DISABLED
N#define __SDADC3_IS_CLK_ENABLED     __HAL_RCC_SDADC3_IS_CLK_ENABLED
N#define __SDADC3_IS_CLK_DISABLED    __HAL_RCC_SDADC3_IS_CLK_DISABLED
N#define __SRAM_IS_CLK_ENABLED       __HAL_RCC_SRAM_IS_CLK_ENABLED
N#define __SRAM_IS_CLK_DISABLED      __HAL_RCC_SRAM_IS_CLK_DISABLED
N#define __TIM1_IS_CLK_ENABLED       __HAL_RCC_TIM1_IS_CLK_ENABLED
N#define __TIM1_IS_CLK_DISABLED      __HAL_RCC_TIM1_IS_CLK_DISABLED
N#define __TIM2_IS_CLK_ENABLED       __HAL_RCC_TIM2_IS_CLK_ENABLED
N#define __TIM2_IS_CLK_DISABLED      __HAL_RCC_TIM2_IS_CLK_DISABLED
N#define __TIM3_IS_CLK_ENABLED       __HAL_RCC_TIM3_IS_CLK_ENABLED
N#define __TIM3_IS_CLK_DISABLED      __HAL_RCC_TIM3_IS_CLK_DISABLED
N#define __TIM4_IS_CLK_ENABLED       __HAL_RCC_TIM4_IS_CLK_ENABLED
N#define __TIM4_IS_CLK_DISABLED      __HAL_RCC_TIM4_IS_CLK_DISABLED
N#define __TIM5_IS_CLK_ENABLED       __HAL_RCC_TIM5_IS_CLK_ENABLED
N#define __TIM5_IS_CLK_DISABLED      __HAL_RCC_TIM5_IS_CLK_DISABLED
N#define __TIM6_IS_CLK_ENABLED       __HAL_RCC_TIM6_IS_CLK_ENABLED
N#define __TIM6_IS_CLK_DISABLED      __HAL_RCC_TIM6_IS_CLK_DISABLED
N#define __TIM7_IS_CLK_ENABLED       __HAL_RCC_TIM7_IS_CLK_ENABLED
N#define __TIM7_IS_CLK_DISABLED      __HAL_RCC_TIM7_IS_CLK_DISABLED
N#define __TIM8_IS_CLK_ENABLED       __HAL_RCC_TIM8_IS_CLK_ENABLED
N#define __TIM8_IS_CLK_DISABLED      __HAL_RCC_TIM8_IS_CLK_DISABLED
N#define __TIM12_IS_CLK_ENABLED      __HAL_RCC_TIM12_IS_CLK_ENABLED
N#define __TIM12_IS_CLK_DISABLED     __HAL_RCC_TIM12_IS_CLK_DISABLED
N#define __TIM13_IS_CLK_ENABLED      __HAL_RCC_TIM13_IS_CLK_ENABLED
N#define __TIM13_IS_CLK_DISABLED     __HAL_RCC_TIM13_IS_CLK_DISABLED
N#define __TIM14_IS_CLK_ENABLED      __HAL_RCC_TIM14_IS_CLK_ENABLED
N#define __TIM14_IS_CLK_DISABLED     __HAL_RCC_TIM14_IS_CLK_DISABLED
N#define __TIM15_IS_CLK_ENABLED      __HAL_RCC_TIM15_IS_CLK_ENABLED
N#define __TIM15_IS_CLK_DISABLED     __HAL_RCC_TIM15_IS_CLK_DISABLED
N#define __TIM16_IS_CLK_ENABLED      __HAL_RCC_TIM16_IS_CLK_ENABLED
N#define __TIM16_IS_CLK_DISABLED     __HAL_RCC_TIM16_IS_CLK_DISABLED
N#define __TIM17_IS_CLK_ENABLED      __HAL_RCC_TIM17_IS_CLK_ENABLED
N#define __TIM17_IS_CLK_DISABLED     __HAL_RCC_TIM17_IS_CLK_DISABLED
N#define __TIM18_IS_CLK_ENABLED      __HAL_RCC_TIM18_IS_CLK_ENABLED
N#define __TIM18_IS_CLK_DISABLED     __HAL_RCC_TIM18_IS_CLK_DISABLED
N#define __TIM19_IS_CLK_ENABLED      __HAL_RCC_TIM19_IS_CLK_ENABLED
N#define __TIM19_IS_CLK_DISABLED     __HAL_RCC_TIM19_IS_CLK_DISABLED
N#define __TIM20_IS_CLK_ENABLED      __HAL_RCC_TIM20_IS_CLK_ENABLED
N#define __TIM20_IS_CLK_DISABLED     __HAL_RCC_TIM20_IS_CLK_DISABLED
N#define __TSC_IS_CLK_ENABLED        __HAL_RCC_TSC_IS_CLK_ENABLED
N#define __TSC_IS_CLK_DISABLED       __HAL_RCC_TSC_IS_CLK_DISABLED
N#define __UART4_IS_CLK_ENABLED      __HAL_RCC_UART4_IS_CLK_ENABLED
N#define __UART4_IS_CLK_DISABLED     __HAL_RCC_UART4_IS_CLK_DISABLED
N#define __UART5_IS_CLK_ENABLED      __HAL_RCC_UART5_IS_CLK_ENABLED
N#define __UART5_IS_CLK_DISABLED     __HAL_RCC_UART5_IS_CLK_DISABLED
N#define __USART1_IS_CLK_ENABLED     __HAL_RCC_USART1_IS_CLK_ENABLED
N#define __USART1_IS_CLK_DISABLED    __HAL_RCC_USART1_IS_CLK_DISABLED
N#define __USART2_IS_CLK_ENABLED     __HAL_RCC_USART2_IS_CLK_ENABLED
N#define __USART2_IS_CLK_DISABLED    __HAL_RCC_USART2_IS_CLK_DISABLED
N#define __USART3_IS_CLK_ENABLED     __HAL_RCC_USART3_IS_CLK_ENABLED
N#define __USART3_IS_CLK_DISABLED    __HAL_RCC_USART3_IS_CLK_DISABLED
N#define __USB_IS_CLK_ENABLED        __HAL_RCC_USB_IS_CLK_ENABLED
N#define __USB_IS_CLK_DISABLED       __HAL_RCC_USB_IS_CLK_DISABLED
N#define __WWDG_IS_CLK_ENABLED       __HAL_RCC_WWDG_IS_CLK_ENABLED
N#define __WWDG_IS_CLK_DISABLED      __HAL_RCC_WWDG_IS_CLK_DISABLED
N
N#if defined(STM32F4)
X#if 0L
S#define __HAL_RCC_SDMMC1_FORCE_RESET       __HAL_RCC_SDIO_FORCE_RESET
S#define __HAL_RCC_SDMMC1_RELEASE_RESET     __HAL_RCC_SDIO_RELEASE_RESET
S#define __HAL_RCC_SDMMC1_CLK_SLEEP_ENABLE  __HAL_RCC_SDIO_CLK_SLEEP_ENABLE
S#define __HAL_RCC_SDMMC1_CLK_SLEEP_DISABLE __HAL_RCC_SDIO_CLK_SLEEP_DISABLE
S#define __HAL_RCC_SDMMC1_CLK_ENABLE        __HAL_RCC_SDIO_CLK_ENABLE
S#define __HAL_RCC_SDMMC1_CLK_DISABLE       __HAL_RCC_SDIO_CLK_DISABLE
S#define __HAL_RCC_SDMMC1_IS_CLK_ENABLED    __HAL_RCC_SDIO_IS_CLK_ENABLED
S#define __HAL_RCC_SDMMC1_IS_CLK_DISABLED   __HAL_RCC_SDIO_IS_CLK_DISABLED
S#define Sdmmc1ClockSelection               SdioClockSelection
S#define RCC_PERIPHCLK_SDMMC1               RCC_PERIPHCLK_SDIO
S#define RCC_SDMMC1CLKSOURCE_CLK48          RCC_SDIOCLKSOURCE_CK48
S#define RCC_SDMMC1CLKSOURCE_SYSCLK         RCC_SDIOCLKSOURCE_SYSCLK
S#define __HAL_RCC_SDMMC1_CONFIG            __HAL_RCC_SDIO_CONFIG
S#define __HAL_RCC_GET_SDMMC1_SOURCE        __HAL_RCC_GET_SDIO_SOURCE
N#endif
N
N#if defined(STM32F7) || defined(STM32L4)
X#if 1L || 0L
N#define __HAL_RCC_SDIO_FORCE_RESET         __HAL_RCC_SDMMC1_FORCE_RESET
N#define __HAL_RCC_SDIO_RELEASE_RESET       __HAL_RCC_SDMMC1_RELEASE_RESET
N#define __HAL_RCC_SDIO_CLK_SLEEP_ENABLE    __HAL_RCC_SDMMC1_CLK_SLEEP_ENABLE
N#define __HAL_RCC_SDIO_CLK_SLEEP_DISABLE   __HAL_RCC_SDMMC1_CLK_SLEEP_DISABLE
N#define __HAL_RCC_SDIO_CLK_ENABLE          __HAL_RCC_SDMMC1_CLK_ENABLE
N#define __HAL_RCC_SDIO_CLK_DISABLE         __HAL_RCC_SDMMC1_CLK_DISABLE
N#define __HAL_RCC_SDIO_IS_CLK_ENABLED      __HAL_RCC_SDMMC1_IS_CLK_ENABLED
N#define __HAL_RCC_SDIO_IS_CLK_DISABLED     __HAL_RCC_SDMMC1_IS_CLK_DISABLED
N#define SdioClockSelection                 Sdmmc1ClockSelection
N#define RCC_PERIPHCLK_SDIO                 RCC_PERIPHCLK_SDMMC1
N#define __HAL_RCC_SDIO_CONFIG              __HAL_RCC_SDMMC1_CONFIG
N#define __HAL_RCC_GET_SDIO_SOURCE          __HAL_RCC_GET_SDMMC1_SOURCE	
N#endif
N
N#if defined(STM32F7)
X#if 1L
N#define RCC_SDIOCLKSOURCE_CLK48             RCC_SDMMC1CLKSOURCE_CLK48
N#define RCC_SDIOCLKSOURCE_SYSCLK           RCC_SDMMC1CLKSOURCE_SYSCLK
N#endif
N
N#define __HAL_RCC_I2SCLK            __HAL_RCC_I2S_CONFIG
N#define __HAL_RCC_I2SCLK_CONFIG     __HAL_RCC_I2S_CONFIG
N
N#define __RCC_PLLSRC                RCC_GET_PLL_OSCSOURCE
N
N#define IS_RCC_MSIRANGE             IS_RCC_MSI_CLOCK_RANGE
N#define IS_RCC_RTCCLK_SOURCE        IS_RCC_RTCCLKSOURCE
N#define IS_RCC_SYSCLK_DIV           IS_RCC_HCLK
N#define IS_RCC_HCLK_DIV             IS_RCC_PCLK
N#define IS_RCC_PERIPHCLK            IS_RCC_PERIPHCLOCK
N
N#define RCC_IT_HSI14                RCC_IT_HSI14RDY
N
N#if defined(STM32L0)
X#if 0L
S#define RCC_IT_LSECSS              RCC_IT_CSSLSE 
S#define RCC_IT_CSS                 RCC_IT_CSSHSE
N#endif
N
N#define IS_RCC_MCOSOURCE            IS_RCC_MCO1SOURCE
N#define __HAL_RCC_MCO_CONFIG        __HAL_RCC_MCO1_CONFIG
N#define RCC_MCO_NODIV               RCC_MCODIV_1
N#define RCC_MCO_DIV1                RCC_MCODIV_1
N#define RCC_MCO_DIV2                RCC_MCODIV_2
N#define RCC_MCO_DIV4                RCC_MCODIV_4
N#define RCC_MCO_DIV8                RCC_MCODIV_8
N#define RCC_MCO_DIV16               RCC_MCODIV_16
N#define RCC_MCO_DIV32               RCC_MCODIV_32
N#define RCC_MCO_DIV64               RCC_MCODIV_64
N#define RCC_MCO_DIV128              RCC_MCODIV_128
N#define RCC_MCOSOURCE_NONE          RCC_MCO1SOURCE_NOCLOCK
N#define RCC_MCOSOURCE_LSI           RCC_MCO1SOURCE_LSI
N#define RCC_MCOSOURCE_LSE           RCC_MCO1SOURCE_LSE
N#define RCC_MCOSOURCE_SYSCLK        RCC_MCO1SOURCE_SYSCLK
N#define RCC_MCOSOURCE_HSI           RCC_MCO1SOURCE_HSI
N#define RCC_MCOSOURCE_HSI14         RCC_MCO1SOURCE_HSI14
N#define RCC_MCOSOURCE_HSI48         RCC_MCO1SOURCE_HSI48
N#define RCC_MCOSOURCE_HSE           RCC_MCO1SOURCE_HSE
N#define RCC_MCOSOURCE_PLLCLK_DIV1   RCC_MCO1SOURCE_PLLCLK
N#define RCC_MCOSOURCE_PLLCLK_NODIV  RCC_MCO1SOURCE_PLLCLK
N#define RCC_MCOSOURCE_PLLCLK_DIV2   RCC_MCO1SOURCE_PLLCLK_DIV2
N
N#define RCC_RTCCLKSOURCE_NONE       RCC_RTCCLKSOURCE_NO_CLK
N
N#define RCC_USBCLK_PLLSAI1          RCC_USBCLKSOURCE_PLLSAI1
N#define RCC_USBCLK_PLL              RCC_USBCLKSOURCE_PLL
N#define RCC_USBCLK_MSI              RCC_USBCLKSOURCE_MSI
N#define RCC_USBCLKSOURCE_PLLCLK     RCC_USBCLKSOURCE_PLL
N#define RCC_USBPLLCLK_DIV1          RCC_USBCLKSOURCE_PLL
N#define RCC_USBPLLCLK_DIV1_5        RCC_USBCLKSOURCE_PLL_DIV1_5
N#define RCC_USBPLLCLK_DIV2          RCC_USBCLKSOURCE_PLL_DIV2
N#define RCC_USBPLLCLK_DIV3          RCC_USBCLKSOURCE_PLL_DIV3
N
N#define HSION_BitNumber        RCC_HSION_BIT_NUMBER
N#define HSION_BITNUMBER        RCC_HSION_BIT_NUMBER
N#define HSEON_BitNumber        RCC_HSEON_BIT_NUMBER
N#define HSEON_BITNUMBER        RCC_HSEON_BIT_NUMBER
N#define MSION_BITNUMBER        RCC_MSION_BIT_NUMBER
N#define CSSON_BitNumber        RCC_CSSON_BIT_NUMBER
N#define CSSON_BITNUMBER        RCC_CSSON_BIT_NUMBER
N#define PLLON_BitNumber        RCC_PLLON_BIT_NUMBER
N#define PLLON_BITNUMBER        RCC_PLLON_BIT_NUMBER
N#define PLLI2SON_BitNumber     RCC_PLLI2SON_BIT_NUMBER
N#define I2SSRC_BitNumber       RCC_I2SSRC_BIT_NUMBER
N#define RTCEN_BitNumber        RCC_RTCEN_BIT_NUMBER
N#define RTCEN_BITNUMBER        RCC_RTCEN_BIT_NUMBER
N#define BDRST_BitNumber        RCC_BDRST_BIT_NUMBER
N#define BDRST_BITNUMBER        RCC_BDRST_BIT_NUMBER
N#define RTCRST_BITNUMBER       RCC_RTCRST_BIT_NUMBER
N#define LSION_BitNumber        RCC_LSION_BIT_NUMBER
N#define LSION_BITNUMBER        RCC_LSION_BIT_NUMBER
N#define LSEON_BitNumber        RCC_LSEON_BIT_NUMBER
N#define LSEON_BITNUMBER        RCC_LSEON_BIT_NUMBER
N#define LSEBYP_BITNUMBER       RCC_LSEBYP_BIT_NUMBER
N#define PLLSAION_BitNumber     RCC_PLLSAION_BIT_NUMBER
N#define TIMPRE_BitNumber       RCC_TIMPRE_BIT_NUMBER
N#define RMVF_BitNumber         RCC_RMVF_BIT_NUMBER
N#define RMVF_BITNUMBER         RCC_RMVF_BIT_NUMBER
N#define RCC_CR2_HSI14TRIM_BitNumber RCC_HSI14TRIM_BIT_NUMBER
N#define CR_BYTE2_ADDRESS       RCC_CR_BYTE2_ADDRESS
N#define CIR_BYTE1_ADDRESS      RCC_CIR_BYTE1_ADDRESS
N#define CIR_BYTE2_ADDRESS      RCC_CIR_BYTE2_ADDRESS
N#define BDCR_BYTE0_ADDRESS     RCC_BDCR_BYTE0_ADDRESS
N#define DBP_TIMEOUT_VALUE      RCC_DBP_TIMEOUT_VALUE
N#define LSE_TIMEOUT_VALUE      RCC_LSE_TIMEOUT_VALUE
N
N#define CR_HSION_BB            RCC_CR_HSION_BB
N#define CR_CSSON_BB            RCC_CR_CSSON_BB
N#define CR_PLLON_BB            RCC_CR_PLLON_BB
N#define CR_PLLI2SON_BB         RCC_CR_PLLI2SON_BB
N#define CR_MSION_BB            RCC_CR_MSION_BB
N#define CSR_LSION_BB           RCC_CSR_LSION_BB
N#define CSR_LSEON_BB           RCC_CSR_LSEON_BB
N#define CSR_LSEBYP_BB          RCC_CSR_LSEBYP_BB
N#define CSR_RTCEN_BB           RCC_CSR_RTCEN_BB
N#define CSR_RTCRST_BB          RCC_CSR_RTCRST_BB
N#define CFGR_I2SSRC_BB         RCC_CFGR_I2SSRC_BB
N#define BDCR_RTCEN_BB          RCC_BDCR_RTCEN_BB
N#define BDCR_BDRST_BB          RCC_BDCR_BDRST_BB
N#define CR_HSEON_BB            RCC_CR_HSEON_BB
N#define CSR_RMVF_BB            RCC_CSR_RMVF_BB
N#define CR_PLLSAION_BB         RCC_CR_PLLSAION_BB
N#define DCKCFGR_TIMPRE_BB      RCC_DCKCFGR_TIMPRE_BB
N
N#define __HAL_RCC_CRS_ENABLE_FREQ_ERROR_COUNTER     __HAL_RCC_CRS_FREQ_ERROR_COUNTER_ENABLE
N#define __HAL_RCC_CRS_DISABLE_FREQ_ERROR_COUNTER    __HAL_RCC_CRS_FREQ_ERROR_COUNTER_DISABLE
N#define __HAL_RCC_CRS_ENABLE_AUTOMATIC_CALIB        __HAL_RCC_CRS_AUTOMATIC_CALIB_ENABLE
N#define __HAL_RCC_CRS_DISABLE_AUTOMATIC_CALIB       __HAL_RCC_CRS_AUTOMATIC_CALIB_DISABLE
N#define __HAL_RCC_CRS_CALCULATE_RELOADVALUE         __HAL_RCC_CRS_RELOADVALUE_CALCULATE
N
N#define __HAL_RCC_GET_IT_SOURCE                     __HAL_RCC_GET_IT
N
N#define RCC_CRS_SYNCWARM       RCC_CRS_SYNCWARN
N#define RCC_CRS_TRIMOV         RCC_CRS_TRIMOVF
N
N#define RCC_PERIPHCLK_CK48               RCC_PERIPHCLK_CLK48
N#define RCC_CK48CLKSOURCE_PLLQ           RCC_CLK48CLKSOURCE_PLLQ
N#define RCC_CK48CLKSOURCE_PLLSAIP        RCC_CLK48CLKSOURCE_PLLSAIP
N#define RCC_CK48CLKSOURCE_PLLI2SQ        RCC_CLK48CLKSOURCE_PLLI2SQ
N#define IS_RCC_CK48CLKSOURCE             IS_RCC_CLK48CLKSOURCE
N#define RCC_SDIOCLKSOURCE_CK48           RCC_SDIOCLKSOURCE_CLK48
N
N#define __HAL_RCC_DFSDM_CLK_ENABLE             __HAL_RCC_DFSDM1_CLK_ENABLE
N#define __HAL_RCC_DFSDM_CLK_DISABLE            __HAL_RCC_DFSDM1_CLK_DISABLE
N#define __HAL_RCC_DFSDM_IS_CLK_ENABLED         __HAL_RCC_DFSDM1_IS_CLK_ENABLED
N#define __HAL_RCC_DFSDM_IS_CLK_DISABLED        __HAL_RCC_DFSDM1_IS_CLK_DISABLED
N#define __HAL_RCC_DFSDM_FORCE_RESET            __HAL_RCC_DFSDM1_FORCE_RESET
N#define __HAL_RCC_DFSDM_RELEASE_RESET          __HAL_RCC_DFSDM1_RELEASE_RESET
N#define __HAL_RCC_DFSDM_CLK_SLEEP_ENABLE       __HAL_RCC_DFSDM1_CLK_SLEEP_ENABLE
N#define __HAL_RCC_DFSDM_CLK_SLEEP_DISABLE      __HAL_RCC_DFSDM1_CLK_SLEEP_DISABLE
N#define __HAL_RCC_DFSDM_IS_CLK_SLEEP_ENABLED   __HAL_RCC_DFSDM1_IS_CLK_SLEEP_ENABLED
N#define __HAL_RCC_DFSDM_IS_CLK_SLEEP_DISABLED  __HAL_RCC_DFSDM1_IS_CLK_SLEEP_DISABLED
N#define DfsdmClockSelection         Dfsdm1ClockSelection
N#define RCC_PERIPHCLK_DFSDM         RCC_PERIPHCLK_DFSDM1
N#define RCC_DFSDMCLKSOURCE_PCLK     RCC_DFSDM1CLKSOURCE_PCLK
N#define RCC_DFSDMCLKSOURCE_SYSCLK   RCC_DFSDM1CLKSOURCE_SYSCLK
N#define __HAL_RCC_DFSDM_CONFIG      __HAL_RCC_DFSDM1_CONFIG
N#define __HAL_RCC_GET_DFSDM_SOURCE  __HAL_RCC_GET_DFSDM1_SOURCE
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_RNG_Aliased_Macros HAL RNG Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define  HAL_RNG_ReadyCallback(__HANDLE__)  HAL_RNG_ReadyDataCallback((__HANDLE__), uint32_t random32bit)                                       
N
N/**
N  * @}
N  */
N  
N/** @defgroup HAL_RTC_Aliased_Macros HAL RTC Aliased Macros maintained for legacy purpose
N  * @{
N  */
N  
N#define __HAL_RTC_CLEAR_FLAG                      __HAL_RTC_EXTI_CLEAR_FLAG
N#define __HAL_RTC_DISABLE_IT                      __HAL_RTC_EXTI_DISABLE_IT
N#define __HAL_RTC_ENABLE_IT                       __HAL_RTC_EXTI_ENABLE_IT
N
N#if defined (STM32F1)
X#if 0L
S#define __HAL_RTC_EXTI_CLEAR_FLAG(RTC_EXTI_LINE_ALARM_EVENT)  __HAL_RTC_ALARM_EXTI_CLEAR_FLAG()
S
S#define __HAL_RTC_EXTI_ENABLE_IT(RTC_EXTI_LINE_ALARM_EVENT)   __HAL_RTC_ALARM_EXTI_ENABLE_IT()
S
S#define __HAL_RTC_EXTI_DISABLE_IT(RTC_EXTI_LINE_ALARM_EVENT)  __HAL_RTC_ALARM_EXTI_DISABLE_IT()
S
S#define __HAL_RTC_EXTI_GET_FLAG(RTC_EXTI_LINE_ALARM_EVENT)    __HAL_RTC_ALARM_EXTI_GET_FLAG()
S
S#define __HAL_RTC_EXTI_GENERATE_SWIT(RTC_EXTI_LINE_ALARM_EVENT)   __HAL_RTC_ALARM_EXTI_GENERATE_SWIT()
N#else
N#define __HAL_RTC_EXTI_CLEAR_FLAG(__EXTI_LINE__)  (((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_CLEAR_FLAG() : \
N                                                   (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG() : \
N                                                      __HAL_RTC_TAMPER_TIMESTAMP_EXTI_CLEAR_FLAG()))
X#define __HAL_RTC_EXTI_CLEAR_FLAG(__EXTI_LINE__)  (((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_CLEAR_FLAG() :                                                    (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG() :                                                       __HAL_RTC_TAMPER_TIMESTAMP_EXTI_CLEAR_FLAG()))
N#define __HAL_RTC_EXTI_ENABLE_IT(__EXTI_LINE__)   (((__EXTI_LINE__)  == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_ENABLE_IT() : \
N                                                  (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_IT() : \
N                                                      __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT()))
X#define __HAL_RTC_EXTI_ENABLE_IT(__EXTI_LINE__)   (((__EXTI_LINE__)  == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_ENABLE_IT() :                                                   (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_IT() :                                                       __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT()))
N#define __HAL_RTC_EXTI_DISABLE_IT(__EXTI_LINE__)  (((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_DISABLE_IT() : \
N                                                  (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_DISABLE_IT() : \
N                                                      __HAL_RTC_TAMPER_TIMESTAMP_EXTI_DISABLE_IT()))
X#define __HAL_RTC_EXTI_DISABLE_IT(__EXTI_LINE__)  (((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_DISABLE_IT() :                                                   (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_DISABLE_IT() :                                                       __HAL_RTC_TAMPER_TIMESTAMP_EXTI_DISABLE_IT()))
N#define __HAL_RTC_EXTI_GET_FLAG(__EXTI_LINE__)    (((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_GET_FLAG() : \
N                                                  (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_GET_FLAG() : \
N                                                      __HAL_RTC_TAMPER_TIMESTAMP_EXTI_GET_FLAG()))
X#define __HAL_RTC_EXTI_GET_FLAG(__EXTI_LINE__)    (((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_GET_FLAG() :                                                   (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_GET_FLAG() :                                                       __HAL_RTC_TAMPER_TIMESTAMP_EXTI_GET_FLAG()))
N#define __HAL_RTC_EXTI_GENERATE_SWIT(__EXTI_LINE__)   (((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_GENERATE_SWIT() : \
N                                                      (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_GENERATE_SWIT() :  \
N                                                          __HAL_RTC_TAMPER_TIMESTAMP_EXTI_GENERATE_SWIT()))
X#define __HAL_RTC_EXTI_GENERATE_SWIT(__EXTI_LINE__)   (((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_GENERATE_SWIT() :                                                       (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_GENERATE_SWIT() :                                                            __HAL_RTC_TAMPER_TIMESTAMP_EXTI_GENERATE_SWIT()))
N#endif   /* STM32F1 */
N
N#define IS_ALARM                                  IS_RTC_ALARM
N#define IS_ALARM_MASK                             IS_RTC_ALARM_MASK
N#define IS_TAMPER                                 IS_RTC_TAMPER
N#define IS_TAMPER_ERASE_MODE                      IS_RTC_TAMPER_ERASE_MODE
N#define IS_TAMPER_FILTER                          IS_RTC_TAMPER_FILTER 
N#define IS_TAMPER_INTERRUPT                       IS_RTC_TAMPER_INTERRUPT
N#define IS_TAMPER_MASKFLAG_STATE                  IS_RTC_TAMPER_MASKFLAG_STATE
N#define IS_TAMPER_PRECHARGE_DURATION              IS_RTC_TAMPER_PRECHARGE_DURATION
N#define IS_TAMPER_PULLUP_STATE                    IS_RTC_TAMPER_PULLUP_STATE
N#define IS_TAMPER_SAMPLING_FREQ                   IS_RTC_TAMPER_SAMPLING_FREQ
N#define IS_TAMPER_TIMESTAMPONTAMPER_DETECTION     IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION
N#define IS_TAMPER_TRIGGER                         IS_RTC_TAMPER_TRIGGER
N#define IS_WAKEUP_CLOCK                           IS_RTC_WAKEUP_CLOCK
N#define IS_WAKEUP_COUNTER                         IS_RTC_WAKEUP_COUNTER
N
N#define __RTC_WRITEPROTECTION_ENABLE  __HAL_RTC_WRITEPROTECTION_ENABLE
N#define __RTC_WRITEPROTECTION_DISABLE  __HAL_RTC_WRITEPROTECTION_DISABLE
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_SD_Aliased_Macros HAL SD Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#define SD_OCR_CID_CSD_OVERWRIETE   SD_OCR_CID_CSD_OVERWRITE
N#define SD_CMD_SD_APP_STAUS         SD_CMD_SD_APP_STATUS
N
N#if defined(STM32F4)
X#if 0L
S#define  SD_SDMMC_DISABLED          SD_SDIO_DISABLED
S#define  SD_SDMMC_FUNCTION_BUSY     SD_SDIO_FUNCTION_BUSY     
S#define  SD_SDMMC_FUNCTION_FAILED   SD_SDIO_FUNCTION_FAILED   
S#define  SD_SDMMC_UNKNOWN_FUNCTION  SD_SDIO_UNKNOWN_FUNCTION  
S#define  SD_CMD_SDMMC_SEN_OP_COND   SD_CMD_SDIO_SEN_OP_COND   
S#define  SD_CMD_SDMMC_RW_DIRECT     SD_CMD_SDIO_RW_DIRECT     
S#define  SD_CMD_SDMMC_RW_EXTENDED   SD_CMD_SDIO_RW_EXTENDED   
S#define  __HAL_SD_SDMMC_ENABLE      __HAL_SD_SDIO_ENABLE      
S#define  __HAL_SD_SDMMC_DISABLE     __HAL_SD_SDIO_DISABLE     
S#define  __HAL_SD_SDMMC_DMA_ENABLE  __HAL_SD_SDIO_DMA_ENABLE  
S#define  __HAL_SD_SDMMC_DMA_DISABLE __HAL_SD_SDIO_DMA_DISABL  
S#define  __HAL_SD_SDMMC_ENABLE_IT   __HAL_SD_SDIO_ENABLE_IT   
S#define  __HAL_SD_SDMMC_DISABLE_IT  __HAL_SD_SDIO_DISABLE_IT  
S#define  __HAL_SD_SDMMC_GET_FLAG    __HAL_SD_SDIO_GET_FLAG    
S#define  __HAL_SD_SDMMC_CLEAR_FLAG  __HAL_SD_SDIO_CLEAR_FLAG  
S#define  __HAL_SD_SDMMC_GET_IT      __HAL_SD_SDIO_GET_IT      
S#define  __HAL_SD_SDMMC_CLEAR_IT    __HAL_SD_SDIO_CLEAR_IT    
S#define  SDMMC_STATIC_FLAGS         SDIO_STATIC_FLAGS	       
S#define  SDMMC_CMD0TIMEOUT          SDIO_CMD0TIMEOUT	       
S#define  SD_SDMMC_SEND_IF_COND      SD_SDIO_SEND_IF_COND
S/* alias CMSIS */
S#define  SDMMC1_IRQn                SDIO_IRQn
S#define  SDMMC1_IRQHandler          SDIO_IRQHandler
N#endif
N
N#if defined(STM32F7) || defined(STM32L4)
X#if 1L || 0L
N#define  SD_SDIO_DISABLED           SD_SDMMC_DISABLED
N#define  SD_SDIO_FUNCTION_BUSY      SD_SDMMC_FUNCTION_BUSY    
N#define  SD_SDIO_FUNCTION_FAILED    SD_SDMMC_FUNCTION_FAILED  
N#define  SD_SDIO_UNKNOWN_FUNCTION   SD_SDMMC_UNKNOWN_FUNCTION
N#define  SD_CMD_SDIO_SEN_OP_COND    SD_CMD_SDMMC_SEN_OP_COND
N#define  SD_CMD_SDIO_RW_DIRECT      SD_CMD_SDMMC_RW_DIRECT
N#define  SD_CMD_SDIO_RW_EXTENDED    SD_CMD_SDMMC_RW_EXTENDED
N#define  __HAL_SD_SDIO_ENABLE       __HAL_SD_SDMMC_ENABLE
N#define  __HAL_SD_SDIO_DISABLE      __HAL_SD_SDMMC_DISABLE
N#define  __HAL_SD_SDIO_DMA_ENABLE   __HAL_SD_SDMMC_DMA_ENABLE
N#define  __HAL_SD_SDIO_DMA_DISABL   __HAL_SD_SDMMC_DMA_DISABLE
N#define  __HAL_SD_SDIO_ENABLE_IT    __HAL_SD_SDMMC_ENABLE_IT
N#define  __HAL_SD_SDIO_DISABLE_IT   __HAL_SD_SDMMC_DISABLE_IT
N#define  __HAL_SD_SDIO_GET_FLAG     __HAL_SD_SDMMC_GET_FLAG
N#define  __HAL_SD_SDIO_CLEAR_FLAG   __HAL_SD_SDMMC_CLEAR_FLAG
N#define  __HAL_SD_SDIO_GET_IT       __HAL_SD_SDMMC_GET_IT
N#define  __HAL_SD_SDIO_CLEAR_IT     __HAL_SD_SDMMC_CLEAR_IT
N#define  SDIO_STATIC_FLAGS	        SDMMC_STATIC_FLAGS
N#define  SDIO_CMD0TIMEOUT	          SDMMC_CMD0TIMEOUT
N#define  SD_SDIO_SEND_IF_COND	      SD_SDMMC_SEND_IF_COND
N/* alias CMSIS for compatibilities */
N#define  SDIO_IRQn                  SDMMC1_IRQn
N#define  SDIO_IRQHandler            SDMMC1_IRQHandler
N#endif
N/**
N  * @}
N  */
N
N/** @defgroup HAL_SMARTCARD_Aliased_Macros HAL SMARTCARD Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#define __SMARTCARD_ENABLE_IT           __HAL_SMARTCARD_ENABLE_IT
N#define __SMARTCARD_DISABLE_IT          __HAL_SMARTCARD_DISABLE_IT
N#define __SMARTCARD_ENABLE              __HAL_SMARTCARD_ENABLE
N#define __SMARTCARD_DISABLE             __HAL_SMARTCARD_DISABLE
N#define __SMARTCARD_DMA_REQUEST_ENABLE  __HAL_SMARTCARD_DMA_REQUEST_ENABLE
N#define __SMARTCARD_DMA_REQUEST_DISABLE __HAL_SMARTCARD_DMA_REQUEST_DISABLE
N
N#define __HAL_SMARTCARD_GETCLOCKSOURCE  SMARTCARD_GETCLOCKSOURCE
N#define __SMARTCARD_GETCLOCKSOURCE      SMARTCARD_GETCLOCKSOURCE
N
N#define IS_SMARTCARD_ONEBIT_SAMPLING    IS_SMARTCARD_ONE_BIT_SAMPLE                  
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_SMBUS_Aliased_Macros HAL SMBUS Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define __HAL_SMBUS_RESET_CR1           SMBUS_RESET_CR1
N#define __HAL_SMBUS_RESET_CR2           SMBUS_RESET_CR2
N#define __HAL_SMBUS_GENERATE_START      SMBUS_GENERATE_START
N#define __HAL_SMBUS_GET_ADDR_MATCH      SMBUS_GET_ADDR_MATCH
N#define __HAL_SMBUS_GET_DIR             SMBUS_GET_DIR
N#define __HAL_SMBUS_GET_STOP_MODE       SMBUS_GET_STOP_MODE
N#define __HAL_SMBUS_GET_PEC_MODE        SMBUS_GET_PEC_MODE
N#define __HAL_SMBUS_GET_ALERT_ENABLED   SMBUS_GET_ALERT_ENABLED
N/**
N  * @}
N  */
N
N/** @defgroup HAL_SPI_Aliased_Macros HAL SPI Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#define __HAL_SPI_1LINE_TX              SPI_1LINE_TX
N#define __HAL_SPI_1LINE_RX              SPI_1LINE_RX
N#define __HAL_SPI_RESET_CRC             SPI_RESET_CRC
N
N/**
N  * @}
N  */
N  
N/** @defgroup HAL_UART_Aliased_Macros HAL UART Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#define __HAL_UART_GETCLOCKSOURCE       UART_GETCLOCKSOURCE
N#define __HAL_UART_MASK_COMPUTATION     UART_MASK_COMPUTATION
N#define __UART_GETCLOCKSOURCE           UART_GETCLOCKSOURCE
N#define __UART_MASK_COMPUTATION         UART_MASK_COMPUTATION
N
N#define IS_UART_WAKEUPMETHODE           IS_UART_WAKEUPMETHOD
N
N#define IS_UART_ONEBIT_SAMPLE           IS_UART_ONE_BIT_SAMPLE                  
N#define IS_UART_ONEBIT_SAMPLING         IS_UART_ONE_BIT_SAMPLE                  
N
N/**
N  * @}
N  */
N
N
N/** @defgroup HAL_USART_Aliased_Macros HAL USART Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#define __USART_ENABLE_IT               __HAL_USART_ENABLE_IT
N#define __USART_DISABLE_IT              __HAL_USART_DISABLE_IT
N#define __USART_ENABLE                  __HAL_USART_ENABLE
N#define __USART_DISABLE                 __HAL_USART_DISABLE
N
N#define __HAL_USART_GETCLOCKSOURCE      USART_GETCLOCKSOURCE
N#define __USART_GETCLOCKSOURCE          USART_GETCLOCKSOURCE
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_USB_Aliased_Macros HAL USB Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define USB_EXTI_LINE_WAKEUP                               USB_WAKEUP_EXTI_LINE
N
N#define USB_FS_EXTI_TRIGGER_RISING_EDGE                    USB_OTG_FS_WAKEUP_EXTI_RISING_EDGE
N#define USB_FS_EXTI_TRIGGER_FALLING_EDGE                   USB_OTG_FS_WAKEUP_EXTI_FALLING_EDGE
N#define USB_FS_EXTI_TRIGGER_BOTH_EDGE                      USB_OTG_FS_WAKEUP_EXTI_RISING_FALLING_EDGE
N#define USB_FS_EXTI_LINE_WAKEUP                            USB_OTG_FS_WAKEUP_EXTI_LINE
N
N#define USB_HS_EXTI_TRIGGER_RISING_EDGE                    USB_OTG_HS_WAKEUP_EXTI_RISING_EDGE
N#define USB_HS_EXTI_TRIGGER_FALLING_EDGE                   USB_OTG_HS_WAKEUP_EXTI_FALLING_EDGE
N#define USB_HS_EXTI_TRIGGER_BOTH_EDGE                      USB_OTG_HS_WAKEUP_EXTI_RISING_FALLING_EDGE
N#define USB_HS_EXTI_LINE_WAKEUP                            USB_OTG_HS_WAKEUP_EXTI_LINE
N
N#define __HAL_USB_EXTI_ENABLE_IT                           __HAL_USB_WAKEUP_EXTI_ENABLE_IT
N#define __HAL_USB_EXTI_DISABLE_IT                          __HAL_USB_WAKEUP_EXTI_DISABLE_IT
N#define __HAL_USB_EXTI_GET_FLAG                            __HAL_USB_WAKEUP_EXTI_GET_FLAG
N#define __HAL_USB_EXTI_CLEAR_FLAG                          __HAL_USB_WAKEUP_EXTI_CLEAR_FLAG
N#define __HAL_USB_EXTI_SET_RISING_EDGE_TRIGGER             __HAL_USB_WAKEUP_EXTI_ENABLE_RISING_EDGE
N#define __HAL_USB_EXTI_SET_FALLING_EDGE_TRIGGER            __HAL_USB_WAKEUP_EXTI_ENABLE_FALLING_EDGE
N#define __HAL_USB_EXTI_SET_FALLINGRISING_TRIGGER           __HAL_USB_WAKEUP_EXTI_ENABLE_RISING_FALLING_EDGE
N
N#define __HAL_USB_FS_EXTI_ENABLE_IT                        __HAL_USB_OTG_FS_WAKEUP_EXTI_ENABLE_IT
N#define __HAL_USB_FS_EXTI_DISABLE_IT                       __HAL_USB_OTG_FS_WAKEUP_EXTI_DISABLE_IT
N#define __HAL_USB_FS_EXTI_GET_FLAG                         __HAL_USB_OTG_FS_WAKEUP_EXTI_GET_FLAG
N#define __HAL_USB_FS_EXTI_CLEAR_FLAG                       __HAL_USB_OTG_FS_WAKEUP_EXTI_CLEAR_FLAG
N#define __HAL_USB_FS_EXTI_SET_RISING_EGDE_TRIGGER          __HAL_USB_OTG_FS_WAKEUP_EXTI_ENABLE_RISING_EDGE
N#define __HAL_USB_FS_EXTI_SET_FALLING_EGDE_TRIGGER         __HAL_USB_OTG_FS_WAKEUP_EXTI_ENABLE_FALLING_EDGE
N#define __HAL_USB_FS_EXTI_SET_FALLINGRISING_TRIGGER        __HAL_USB_OTG_FS_WAKEUP_EXTI_ENABLE_RISING_FALLING_EDGE
N#define __HAL_USB_FS_EXTI_GENERATE_SWIT                    __HAL_USB_OTG_FS_WAKEUP_EXTI_GENERATE_SWIT
N
N#define __HAL_USB_HS_EXTI_ENABLE_IT                        __HAL_USB_OTG_HS_WAKEUP_EXTI_ENABLE_IT
N#define __HAL_USB_HS_EXTI_DISABLE_IT                       __HAL_USB_OTG_HS_WAKEUP_EXTI_DISABLE_IT
N#define __HAL_USB_HS_EXTI_GET_FLAG                         __HAL_USB_OTG_HS_WAKEUP_EXTI_GET_FLAG
N#define __HAL_USB_HS_EXTI_CLEAR_FLAG                       __HAL_USB_OTG_HS_WAKEUP_EXTI_CLEAR_FLAG
N#define __HAL_USB_HS_EXTI_SET_RISING_EGDE_TRIGGER          __HAL_USB_OTG_HS_WAKEUP_EXTI_ENABLE_RISING_EDGE
N#define __HAL_USB_HS_EXTI_SET_FALLING_EGDE_TRIGGER         __HAL_USB_OTG_HS_WAKEUP_EXTI_ENABLE_FALLING_EDGE
N#define __HAL_USB_HS_EXTI_SET_FALLINGRISING_TRIGGER        __HAL_USB_OTG_HS_WAKEUP_EXTI_ENABLE_RISING_FALLING_EDGE
N#define __HAL_USB_HS_EXTI_GENERATE_SWIT                    __HAL_USB_OTG_HS_WAKEUP_EXTI_GENERATE_SWIT
N
N#define HAL_PCD_ActiveRemoteWakeup                         HAL_PCD_ActivateRemoteWakeup
N#define HAL_PCD_DeActiveRemoteWakeup                       HAL_PCD_DeActivateRemoteWakeup
N
N#define HAL_PCD_SetTxFiFo                                  HAL_PCDEx_SetTxFiFo
N#define HAL_PCD_SetRxFiFo                                  HAL_PCDEx_SetRxFiFo
N/**
N  * @}
N  */
N
N/** @defgroup HAL_TIM_Aliased_Macros HAL TIM Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define __HAL_TIM_SetICPrescalerValue   TIM_SET_ICPRESCALERVALUE
N#define __HAL_TIM_ResetICPrescalerValue TIM_RESET_ICPRESCALERVALUE
N
N#define TIM_GET_ITSTATUS                __HAL_TIM_GET_IT_SOURCE
N#define TIM_GET_CLEAR_IT                __HAL_TIM_CLEAR_IT
N
N#define __HAL_TIM_GET_ITSTATUS          __HAL_TIM_GET_IT_SOURCE
N
N#define __HAL_TIM_DIRECTION_STATUS      __HAL_TIM_IS_TIM_COUNTING_DOWN
N#define __HAL_TIM_PRESCALER             __HAL_TIM_SET_PRESCALER
N#define __HAL_TIM_SetCounter            __HAL_TIM_SET_COUNTER
N#define __HAL_TIM_GetCounter            __HAL_TIM_GET_COUNTER
N#define __HAL_TIM_SetAutoreload         __HAL_TIM_SET_AUTORELOAD
N#define __HAL_TIM_GetAutoreload         __HAL_TIM_GET_AUTORELOAD
N#define __HAL_TIM_SetClockDivision      __HAL_TIM_SET_CLOCKDIVISION
N#define __HAL_TIM_GetClockDivision      __HAL_TIM_GET_CLOCKDIVISION
N#define __HAL_TIM_SetICPrescaler        __HAL_TIM_SET_ICPRESCALER
N#define __HAL_TIM_GetICPrescaler        __HAL_TIM_GET_ICPRESCALER
N#define __HAL_TIM_SetCompare            __HAL_TIM_SET_COMPARE
N#define __HAL_TIM_GetCompare            __HAL_TIM_GET_COMPARE
N
N#define TIM_BREAKINPUTSOURCE_DFSDM  TIM_BREAKINPUTSOURCE_DFSDM1
N/**
N  * @}
N  */
N
N/** @defgroup HAL_ETH_Aliased_Macros HAL ETH Aliased Macros maintained for legacy purpose
N  * @{
N  */
N  
N#define __HAL_ETH_EXTI_ENABLE_IT                   __HAL_ETH_WAKEUP_EXTI_ENABLE_IT
N#define __HAL_ETH_EXTI_DISABLE_IT                  __HAL_ETH_WAKEUP_EXTI_DISABLE_IT
N#define __HAL_ETH_EXTI_GET_FLAG                    __HAL_ETH_WAKEUP_EXTI_GET_FLAG
N#define __HAL_ETH_EXTI_CLEAR_FLAG                  __HAL_ETH_WAKEUP_EXTI_CLEAR_FLAG
N#define __HAL_ETH_EXTI_SET_RISING_EGDE_TRIGGER     __HAL_ETH_WAKEUP_EXTI_ENABLE_RISING_EDGE_TRIGGER
N#define __HAL_ETH_EXTI_SET_FALLING_EGDE_TRIGGER    __HAL_ETH_WAKEUP_EXTI_ENABLE_FALLING_EDGE_TRIGGER
N#define __HAL_ETH_EXTI_SET_FALLINGRISING_TRIGGER   __HAL_ETH_WAKEUP_EXTI_ENABLE_FALLINGRISING_TRIGGER
N
N#define ETH_PROMISCIOUSMODE_ENABLE   ETH_PROMISCUOUS_MODE_ENABLE 
N#define ETH_PROMISCIOUSMODE_DISABLE  ETH_PROMISCUOUS_MODE_DISABLE
N#define IS_ETH_PROMISCIOUS_MODE      IS_ETH_PROMISCUOUS_MODE
N/**
N  * @}
N  */
N
N/** @defgroup HAL_LTDC_Aliased_Macros HAL LTDC Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define __HAL_LTDC_LAYER LTDC_LAYER
N/**
N  * @}
N  */
N
N/** @defgroup HAL_SAI_Aliased_Macros HAL SAI Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define SAI_OUTPUTDRIVE_DISABLED          SAI_OUTPUTDRIVE_DISABLE
N#define SAI_OUTPUTDRIVE_ENABLED           SAI_OUTPUTDRIVE_ENABLE
N#define SAI_MASTERDIVIDER_ENABLED         SAI_MASTERDIVIDER_ENABLE
N#define SAI_MASTERDIVIDER_DISABLED        SAI_MASTERDIVIDER_DISABLE
N#define SAI_STREOMODE                     SAI_STEREOMODE
N#define SAI_FIFOStatus_Empty              SAI_FIFOSTATUS_EMPTY
N#define SAI_FIFOStatus_Less1QuarterFull   SAI_FIFOSTATUS_LESS1QUARTERFULL
N#define SAI_FIFOStatus_1QuarterFull       SAI_FIFOSTATUS_1QUARTERFULL
N#define SAI_FIFOStatus_HalfFull           SAI_FIFOSTATUS_HALFFULL
N#define SAI_FIFOStatus_3QuartersFull      SAI_FIFOSTATUS_3QUARTERFULL
N#define SAI_FIFOStatus_Full               SAI_FIFOSTATUS_FULL
N#define IS_SAI_BLOCK_MONO_STREO_MODE      IS_SAI_BLOCK_MONO_STEREO_MODE
N#define SAI_SYNCHRONOUS_EXT               SAI_SYNCHRONOUS_EXT_SAI1
N#define SAI_SYNCEXT_IN_ENABLE             SAI_SYNCEXT_OUTBLOCKA_ENABLE
N/**
N  * @}
N  */
N
N
N/** @defgroup HAL_PPP_Aliased_Macros HAL PPP Aliased Macros maintained for legacy purpose
N  * @{
N  */
N  
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* ___STM32_HAL_LEGACY */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
N
L 50 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_def.h" 2
N#include <stdio.h>
L 1 "D:\Program_Files_x86\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060009
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 51 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_def.h" 2
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  HAL Status structures definition  
N  */  
Ntypedef enum 
N{
N  HAL_OK       = 0x00U,
N  HAL_ERROR    = 0x01U,
N  HAL_BUSY     = 0x02U,
N  HAL_TIMEOUT  = 0x03U
N} HAL_StatusTypeDef;
N
N/** 
N  * @brief  HAL Lock structures definition  
N  */
Ntypedef enum 
N{
N  HAL_UNLOCKED = 0x00,
N  HAL_LOCKED   = 0x01  
N} HAL_LockTypeDef;
N
N/* Exported macro ------------------------------------------------------------*/
N#define HAL_MAX_DELAY      0xFFFFFFFFU
N
N#define HAL_IS_BIT_SET(REG, BIT)         (((REG) & (BIT)) != RESET)
N#define HAL_IS_BIT_CLR(REG, BIT)         (((REG) & (BIT)) == RESET)
N
N#define __HAL_LINKDMA(__HANDLE__, __PPP_DMA_FIELD__, __DMA_HANDLE__)               \
N                        do{                                                      \
N                              (__HANDLE__)->__PPP_DMA_FIELD__ = &(__DMA_HANDLE__); \
N                              (__DMA_HANDLE__).Parent = (__HANDLE__);             \
N                          } while(0)
X#define __HAL_LINKDMA(__HANDLE__, __PPP_DMA_FIELD__, __DMA_HANDLE__)                                       do{                                                                                    (__HANDLE__)->__PPP_DMA_FIELD__ = &(__DMA_HANDLE__);                               (__DMA_HANDLE__).Parent = (__HANDLE__);                                       } while(0)
N
N#define UNUSED(x) ((void)(x))
N
N/** @brief Reset the Handle's State field.
N  * @param __HANDLE__: specifies the Peripheral Handle.
N  * @note  This macro can be used for the following purpose: 
N  *          - When the Handle is declared as local variable; before passing it as parameter
N  *            to HAL_PPP_Init() for the first time, it is mandatory to use this macro 
N  *            to set to 0 the Handle's "State" field.
N  *            Otherwise, "State" field may have any random value and the first time the function 
N  *            HAL_PPP_Init() is called, the low level hardware initialization will be missed
N  *            (i.e. HAL_PPP_MspInit() will not be executed).
N  *          - When there is a need to reconfigure the low level hardware: instead of calling
N  *            HAL_PPP_DeInit() then HAL_PPP_Init(), user can make a call to this macro then HAL_PPP_Init().
N  *            In this later function, when the Handle's "State" field is set to 0, it will execute the function
N  *            HAL_PPP_MspInit() which will reconfigure the low level hardware.
N  * @retval None
N  */
N#define __HAL_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = 0U)
N
N#if (USE_RTOS == 1)
X#if (0U == 1)
S  /* Reserved for future use */
S  #error "USE_RTOS should be 0 in the current HAL release"
N#else
N  #define __HAL_LOCK(__HANDLE__)                                           \
N                                do{                                        \
N                                    if((__HANDLE__)->Lock == HAL_LOCKED)   \
N                                    {                                      \
N                                       return HAL_BUSY;                    \
N                                    }                                      \
N                                    else                                   \
N                                    {                                      \
N                                       (__HANDLE__)->Lock = HAL_LOCKED;    \
N                                    }                                      \
N                                  }while (0)
X  #define __HAL_LOCK(__HANDLE__)                                                                           do{                                                                            if((__HANDLE__)->Lock == HAL_LOCKED)                                       {                                                                             return HAL_BUSY;                                                        }                                                                          else                                                                       {                                                                             (__HANDLE__)->Lock = HAL_LOCKED;                                        }                                                                        }while (0)
N
N  #define __HAL_UNLOCK(__HANDLE__)                                          \
N                                  do{                                       \
N                                      (__HANDLE__)->Lock = HAL_UNLOCKED;    \
N                                    }while (0)
X  #define __HAL_UNLOCK(__HANDLE__)                                                                            do{                                                                             (__HANDLE__)->Lock = HAL_UNLOCKED;                                        }while (0)
N#endif /* USE_RTOS */
N
N#if  defined ( __GNUC__ )
X#if  0L
S  #ifndef __weak
S    #define __weak   __attribute__((weak))
S  #endif /* __weak */
S  #ifndef __packed
S    #define __packed __attribute__((__packed__))
S  #endif /* __packed */
N#endif /* __GNUC__ */
N
N
N/* Macro to get variable aligned on 4-bytes, for __ICCARM__ the directive "#pragma data_alignment=4" must be used instead */
N#if defined   (__GNUC__)        /* GNU Compiler */
X#if 0L         
S  #ifndef __ALIGN_END
S    #define __ALIGN_END    __attribute__ ((aligned (4)))
S  #endif /* __ALIGN_END */
S  #ifndef __ALIGN_BEGIN  
S    #define __ALIGN_BEGIN
S  #endif /* __ALIGN_BEGIN */
N#else
N  #ifndef __ALIGN_END
N    #define __ALIGN_END
N  #endif /* __ALIGN_END */
N  #ifndef __ALIGN_BEGIN      
N    #if defined   (__CC_ARM)      /* ARM Compiler */
X    #if 1L       
N      #define __ALIGN_BEGIN    __align(4)  
N    #elif defined (__ICCARM__)    /* IAR Compiler */
S      #define __ALIGN_BEGIN 
N    #endif /* __CC_ARM */
N  #endif /* __ALIGN_BEGIN */
N#endif /* __GNUC__ */
N
N
N/** 
N  * @brief  __RAM_FUNC definition
N  */ 
N#if defined ( __CC_ARM   )
X#if 1L
N/* ARM Compiler
N   ------------
N   RAM functions are defined using the toolchain options. 
N   Functions that are executed in RAM should reside in a separate source module.
N   Using the 'Options for File' dialog you can simply change the 'Code / Const' 
N   area of a module to a memory space in physical RAM.
N   Available memory areas are declared in the 'Target' tab of the 'Options for Target'
N   dialog. 
N*/
N#define __RAM_FUNC HAL_StatusTypeDef 
N
N#elif defined ( __ICCARM__ )
S/* ICCARM Compiler
S   ---------------
S   RAM functions are defined using a specific toolchain keyword "__ramfunc". 
S*/
S#define __RAM_FUNC __ramfunc HAL_StatusTypeDef
S
S#elif defined   (  __GNUC__  )
S/* GNU Compiler
S   ------------
S  RAM functions are defined using a specific toolchain attribute 
S   "__attribute__((section(".RamFunc")))".
S*/
S#define __RAM_FUNC HAL_StatusTypeDef  __attribute__((section(".RamFunc")))
S
N#endif
N
N/** 
N  * @brief  __NOINLINE definition
N  */ 
N#if defined ( __CC_ARM   ) || defined   (  __GNUC__  )
X#if 1L || 0L
N/* ARM & GNUCompiler 
N   ---------------- 
N*/
N#define __NOINLINE __attribute__ ( (noinline) )
N
N#elif defined ( __ICCARM__ )
S/* ICCARM Compiler
S   ---------------
S*/
S#define __NOINLINE _Pragma("optimize = no_inline")
S
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* ___STM32F7xx_HAL_DEF */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 48 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_rcc.h" 2
N   
N/* Include RCC HAL Extended module */
N/* (include on top of file since RCC structures are defined in extended file) */
N#include "stm32f7xx_hal_rcc_ex.h"   
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_rcc_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_rcc_ex.h
N  * @author  MCD Application Team                                                                                                     
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of RCC HAL Extension module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_RCC_EX_H
N#define __STM32F7xx_HAL_RCC_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup RCCEx
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup RCCEx_Exported_Types RCCEx Exported Types
N  * @{
N  */
N   
N/** 
N  * @brief  RCC PLL configuration structure definition  
N  */
Ntypedef struct
N{
N  uint32_t PLLState;   /*!< The new state of the PLL.
N                            This parameter can be a value of @ref RCC_PLL_Config                      */
N
N  uint32_t PLLSource;  /*!< RCC_PLLSource: PLL entry clock source.
N                            This parameter must be a value of @ref RCC_PLL_Clock_Source               */           
N
N  uint32_t PLLM;       /*!< PLLM: Division factor for PLL VCO input clock.
N                            This parameter must be a number between Min_Data = 2 and Max_Data = 63    */        
N
N  uint32_t PLLN;       /*!< PLLN: Multiplication factor for PLL VCO output clock.
N                            This parameter must be a number between Min_Data = 50 and Max_Data = 432  */
N
N  uint32_t PLLP;       /*!< PLLP: Division factor for main system clock (SYSCLK).
N                            This parameter must be a value of @ref RCC_PLLP_Clock_Divider             */
N
N  uint32_t PLLQ;       /*!< PLLQ: Division factor for OTG FS, SDMMC and RNG clocks.
N                            This parameter must be a number between Min_Data = 2 and Max_Data = 15    */
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N  uint32_t PLLR;       /*!< PLLR: Division factor for DSI clock.
N                            This parameter must be a number between Min_Data = 2 and Max_Data = 7    */
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */  
N
N}RCC_PLLInitTypeDef;   
N
N/** 
N  * @brief  PLLI2S Clock structure definition  
N  */
Ntypedef struct
N{
N  uint32_t PLLI2SN;    /*!< Specifies the multiplication factor for PLLI2S VCO output clock.
N                            This parameter must be a number between Min_Data = 50 and Max_Data = 432.
N                            This parameter will be used only when PLLI2S is selected as Clock Source I2S or SAI */
N
N  uint32_t PLLI2SR;    /*!< Specifies the division factor for I2S clock.
N                            This parameter must be a number between Min_Data = 2 and Max_Data = 7. 
N                            This parameter will be used only when PLLI2S is selected as Clock Source I2S or SAI */
N
N  uint32_t PLLI2SQ;    /*!< Specifies the division factor for SAI1 clock.
N                            This parameter must be a number between Min_Data = 2 and Max_Data = 15. 
N                            This parameter will be used only when PLLI2S is selected as Clock Source SAI */
N
N  uint32_t PLLI2SP;    /*!< Specifies the division factor for SPDIF-RX clock.
N                            This parameter must be a value of @ref RCCEx_PLLI2SP_Clock_Divider. 
N                            This parameter will be used only when PLLI2S is selected as Clock Source SPDIF-RX */
N}RCC_PLLI2SInitTypeDef;
N
N/** 
N  * @brief  PLLSAI Clock structure definition  
N  */
Ntypedef struct
N{
N  uint32_t PLLSAIN;    /*!< Specifies the multiplication factor for PLLI2S VCO output clock.
N                            This parameter must be a number between Min_Data = 50 and Max_Data = 432.
N                            This parameter will be used only when PLLSAI is selected as Clock Source SAI or LTDC */ 
N                                 
N  uint32_t PLLSAIQ;    /*!< Specifies the division factor for SAI1 clock.
N                            This parameter must be a number between Min_Data = 2 and Max_Data = 15.
N                            This parameter will be used only when PLLSAI is selected as Clock Source SAI or LTDC */
N                              
N  uint32_t PLLSAIR;    /*!< specifies the division factor for LTDC clock
N                            This parameter must be a number between Min_Data = 2 and Max_Data = 7.
N                            This parameter will be used only when PLLSAI is selected as Clock Source LTDC */
N
N  uint32_t PLLSAIP;    /*!< Specifies the division factor for 48MHz clock.
N                            This parameter must be a value of @ref RCCEx_PLLSAIP_Clock_Divider
N                            This parameter will be used only when PLLSAI is disabled */
N}RCC_PLLSAIInitTypeDef;
N
N/** 
N  * @brief  RCC extended clocks structure definition  
N  */
Ntypedef struct
N{
N  uint32_t PeriphClockSelection; /*!< The Extended Clock to be configured.
N                                      This parameter can be a value of @ref RCCEx_Periph_Clock_Selection */
N
N  RCC_PLLI2SInitTypeDef PLLI2S;  /*!< PLL I2S structure parameters. 
N                                      This parameter will be used only when PLLI2S is selected as Clock Source I2S or SAI */
N
N  RCC_PLLSAIInitTypeDef PLLSAI;  /*!< PLL SAI structure parameters. 
N                                      This parameter will be used only when PLLI2S is selected as Clock Source SAI or LTDC */
N
N  uint32_t PLLI2SDivQ;           /*!< Specifies the PLLI2S division factor for SAI1 clock.
N                                      This parameter must be a number between Min_Data = 1 and Max_Data = 32
N                                      This parameter will be used only when PLLI2S is selected as Clock Source SAI */
N
N  uint32_t PLLSAIDivQ;           /*!< Specifies the PLLI2S division factor for SAI1 clock.
N                                      This parameter must be a number between Min_Data = 1 and Max_Data = 32
N                                      This parameter will be used only when PLLSAI is selected as Clock Source SAI */
N
N  uint32_t PLLSAIDivR;           /*!< Specifies the PLLSAI division factor for LTDC clock.
N                                      This parameter must be one value of @ref RCCEx_PLLSAI_DIVR */
N
N  uint32_t RTCClockSelection;      /*!< Specifies RTC Clock source Selection. 
N                                        This parameter can be a value of @ref RCC_RTC_Clock_Source */
N                                        
N  uint32_t I2sClockSelection;      /*!< Specifies I2S Clock source Selection. 
N                                        This parameter can be a value of @ref RCCEx_I2S_Clock_Source */
N
N  uint32_t TIMPresSelection;      /*!< Specifies TIM Clock Prescalers Selection. 
N                                       This parameter can be a value of @ref RCCEx_TIM_Prescaler_Selection */
N  
N  uint32_t Sai1ClockSelection;     /*!< Specifies SAI1 Clock Prescalers Selection
N                                        This parameter can be a value of @ref RCCEx_SAI1_Clock_Source */
N
N  uint32_t Sai2ClockSelection;     /*!< Specifies SAI2 Clock Prescalers Selection
N                                        This parameter can be a value of @ref RCCEx_SAI2_Clock_Source */
N  
N  uint32_t Usart1ClockSelection; /*!< USART1 clock source      
N                                      This parameter can be a value of @ref RCCEx_USART1_Clock_Source */
N  
N  uint32_t Usart2ClockSelection; /*!< USART2 clock source      
N                                      This parameter can be a value of @ref RCCEx_USART2_Clock_Source */
N
N  uint32_t Usart3ClockSelection; /*!< USART3 clock source      
N                                      This parameter can be a value of @ref RCCEx_USART3_Clock_Source */                                
N  
N  uint32_t Uart4ClockSelection;  /*!< UART4 clock source      
N                                      This parameter can be a value of @ref RCCEx_UART4_Clock_Source */
N  
N  uint32_t Uart5ClockSelection;  /*!< UART5 clock source      
N                                      This parameter can be a value of @ref RCCEx_UART5_Clock_Source */
N  
N  uint32_t Usart6ClockSelection;  /*!< USART6 clock source      
N                                      This parameter can be a value of @ref RCCEx_USART6_Clock_Source */
N  
N  uint32_t Uart7ClockSelection;  /*!< UART7 clock source      
N                                      This parameter can be a value of @ref RCCEx_UART7_Clock_Source */
N  
N  uint32_t Uart8ClockSelection;  /*!< UART8 clock source      
N                                      This parameter can be a value of @ref RCCEx_UART8_Clock_Source */
N  
N  uint32_t I2c1ClockSelection;   /*!< I2C1 clock source      
N                                      This parameter can be a value of @ref RCCEx_I2C1_Clock_Source */
N
N  uint32_t I2c2ClockSelection;   /*!< I2C2 clock source      
N                                      This parameter can be a value of @ref RCCEx_I2C2_Clock_Source */
N
N  uint32_t I2c3ClockSelection;   /*!< I2C3 clock source      
N                                      This parameter can be a value of @ref RCCEx_I2C3_Clock_Source */
N  
N  uint32_t I2c4ClockSelection;   /*!< I2C4 clock source      
N                                      This parameter can be a value of @ref RCCEx_I2C4_Clock_Source */
N  
N  uint32_t Lptim1ClockSelection;   /*!< Specifies LPTIM1 clock source
N                                        This parameter can be a value of @ref RCCEx_LPTIM1_Clock_Source */
N  
N  uint32_t CecClockSelection;      /*!< CEC clock source      
N                                        This parameter can be a value of @ref RCCEx_CEC_Clock_Source */
N  
N  uint32_t Clk48ClockSelection;    /*!< Specifies 48Mhz clock source used by USB OTG FS, RNG and SDMMC
N                                        This parameter can be a value of @ref RCCEx_CLK48_Clock_Source */
N  
N  uint32_t Sdmmc1ClockSelection;     /*!< SDMMC1 clock source      
N                                        This parameter can be a value of @ref RCCEx_SDMMC1_Clock_Source */
N                                          
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)  
X#if 0L || 1L || 0L || 0L || 0L  
N  uint32_t Sdmmc2ClockSelection;     /*!< SDMMC2 clock source      
N                                        This parameter can be a value of @ref RCCEx_SDMMC2_Clock_Source */
N  
N  uint32_t Dfsdm1ClockSelection;     /*!< DFSDM1 clock source      
N                                        This parameter can be a value of @ref RCCEx_DFSDM1_Kernel_Clock_Source */
N                                          
N  uint32_t Dfsdm1AudioClockSelection; /*!< DFSDM1 clock source      
N                                        This parameter can be a value of @ref RCCEx_DFSDM1_AUDIO_Clock_Source */
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */  
N}RCC_PeriphCLKInitTypeDef;
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup RCCEx_Exported_Constants RCCEx Exported Constants
N  * @{
N  */
N
N/** @defgroup RCCEx_Periph_Clock_Selection RCC Periph Clock Selection
N  * @{
N  */
N#define RCC_PERIPHCLK_I2S             ((uint32_t)0x00000001U)
N#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 0L || 1L || 0L || 0L || 0L
N#define RCC_PERIPHCLK_LTDC            ((uint32_t)0x00000008U)
N#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N#define RCC_PERIPHCLK_TIM             ((uint32_t)0x00000010U)
N#define RCC_PERIPHCLK_RTC             ((uint32_t)0x00000020U)
N#define RCC_PERIPHCLK_USART1          ((uint32_t)0x00000040U)
N#define RCC_PERIPHCLK_USART2          ((uint32_t)0x00000080U)
N#define RCC_PERIPHCLK_USART3          ((uint32_t)0x00000100U)
N#define RCC_PERIPHCLK_UART4           ((uint32_t)0x00000200U)
N#define RCC_PERIPHCLK_UART5           ((uint32_t)0x00000400U)
N#define RCC_PERIPHCLK_USART6          ((uint32_t)0x00000800U)
N#define RCC_PERIPHCLK_UART7           ((uint32_t)0x00001000U)
N#define RCC_PERIPHCLK_UART8           ((uint32_t)0x00002000U)
N#define RCC_PERIPHCLK_I2C1            ((uint32_t)0x00004000U)
N#define RCC_PERIPHCLK_I2C2            ((uint32_t)0x00008000U)
N#define RCC_PERIPHCLK_I2C3            ((uint32_t)0x00010000U)
N#define RCC_PERIPHCLK_I2C4            ((uint32_t)0x00020000U)
N#define RCC_PERIPHCLK_LPTIM1          ((uint32_t)0x00040000U)
N#define RCC_PERIPHCLK_SAI1            ((uint32_t)0x00080000U)
N#define RCC_PERIPHCLK_SAI2            ((uint32_t)0x00100000U)
N#define RCC_PERIPHCLK_CLK48           ((uint32_t)0x00200000U)
N#define RCC_PERIPHCLK_CEC             ((uint32_t)0x00400000U)
N#define RCC_PERIPHCLK_SDMMC1          ((uint32_t)0x00800000U)
N#define RCC_PERIPHCLK_SPDIFRX         ((uint32_t)0x01000000U)
N#define RCC_PERIPHCLK_PLLI2S          ((uint32_t)0x02000000U)
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)    
X#if 0L || 1L || 0L || 0L || 0L    
N#define RCC_PERIPHCLK_SDMMC2          ((uint32_t)0x04000000U)
N#define RCC_PERIPHCLK_DFSDM1           ((uint32_t)0x08000000U)
N#define RCC_PERIPHCLK_DFSDM1_AUDIO      ((uint32_t)0x10000000U)    
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N    
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_PLLI2SP_Clock_Divider RCCEx PLLI2SP Clock Divider
N  * @{
N  */
N#define RCC_PLLI2SP_DIV2                  ((uint32_t)0x00000000U)
N#define RCC_PLLI2SP_DIV4                  ((uint32_t)0x00000001U)
N#define RCC_PLLI2SP_DIV6                  ((uint32_t)0x00000002U)
N#define RCC_PLLI2SP_DIV8                  ((uint32_t)0x00000003U)
N/**
N  * @}
N  */
N  
N/** @defgroup RCCEx_PLLSAIP_Clock_Divider RCCEx PLLSAIP Clock Divider
N  * @{
N  */
N#define RCC_PLLSAIP_DIV2                  ((uint32_t)0x00000000U)
N#define RCC_PLLSAIP_DIV4                  ((uint32_t)0x00000001U)
N#define RCC_PLLSAIP_DIV6                  ((uint32_t)0x00000002U)
N#define RCC_PLLSAIP_DIV8                  ((uint32_t)0x00000003U)
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_PLLSAI_DIVR RCCEx PLLSAI DIVR
N  * @{
N  */
N#define RCC_PLLSAIDIVR_2                ((uint32_t)0x00000000U)
N#define RCC_PLLSAIDIVR_4                RCC_DCKCFGR1_PLLSAIDIVR_0
N#define RCC_PLLSAIDIVR_8                RCC_DCKCFGR1_PLLSAIDIVR_1
N#define RCC_PLLSAIDIVR_16               RCC_DCKCFGR1_PLLSAIDIVR
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_I2S_Clock_Source RCCEx I2S Clock Source
N  * @{
N  */
N#define RCC_I2SCLKSOURCE_PLLI2S             ((uint32_t)0x00000000U)
N#define RCC_I2SCLKSOURCE_EXT                RCC_CFGR_I2SSRC
N
N/**
N  * @}
N  */ 
N  
N  
N/** @defgroup RCCEx_SAI1_Clock_Source RCCEx SAI1 Clock Source
N  * @{
N  */
N#define RCC_SAI1CLKSOURCE_PLLSAI             ((uint32_t)0x00000000U)
N#define RCC_SAI1CLKSOURCE_PLLI2S             RCC_DCKCFGR1_SAI1SEL_0
N#define RCC_SAI1CLKSOURCE_PIN                RCC_DCKCFGR1_SAI1SEL_1
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N#define RCC_SAI1CLKSOURCE_PLLSRC             RCC_DCKCFGR1_SAI1SEL
N#endif /* STM32F765xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N/**
N  * @}
N  */ 
N
N/** @defgroup RCCEx_SAI2_Clock_Source RCCEx SAI2 Clock Source
N  * @{
N  */
N#define RCC_SAI2CLKSOURCE_PLLSAI             ((uint32_t)0x00000000U)
N#define RCC_SAI2CLKSOURCE_PLLI2S             RCC_DCKCFGR1_SAI2SEL_0
N#define RCC_SAI2CLKSOURCE_PIN                RCC_DCKCFGR1_SAI2SEL_1
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N#define RCC_SAI2CLKSOURCE_PLLSRC             RCC_DCKCFGR1_SAI2SEL
N#endif /* STM32F765xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N/**
N  * @}
N  */ 
N
N/** @defgroup RCCEx_CEC_Clock_Source RCCEx CEC Clock Source
N  * @{
N  */
N#define RCC_CECCLKSOURCE_LSE             ((uint32_t)0x00000000U)
N#define RCC_CECCLKSOURCE_HSI             RCC_DCKCFGR2_CECSEL /* CEC clock is HSI/488*/
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_USART1_Clock_Source RCCEx USART1 Clock Source
N  * @{
N  */
N#define RCC_USART1CLKSOURCE_PCLK2      ((uint32_t)0x00000000U)
N#define RCC_USART1CLKSOURCE_SYSCLK     RCC_DCKCFGR2_USART1SEL_0
N#define RCC_USART1CLKSOURCE_HSI        RCC_DCKCFGR2_USART1SEL_1
N#define RCC_USART1CLKSOURCE_LSE        RCC_DCKCFGR2_USART1SEL
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_USART2_Clock_Source RCCEx USART2 Clock Source
N  * @{
N  */
N#define RCC_USART2CLKSOURCE_PCLK1       ((uint32_t)0x00000000U)
N#define RCC_USART2CLKSOURCE_SYSCLK     RCC_DCKCFGR2_USART2SEL_0
N#define RCC_USART2CLKSOURCE_HSI        RCC_DCKCFGR2_USART2SEL_1
N#define RCC_USART2CLKSOURCE_LSE        RCC_DCKCFGR2_USART2SEL
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_USART3_Clock_Source RCCEx USART3 Clock Source
N  * @{
N  */
N#define RCC_USART3CLKSOURCE_PCLK1       ((uint32_t)0x00000000U)
N#define RCC_USART3CLKSOURCE_SYSCLK     RCC_DCKCFGR2_USART3SEL_0
N#define RCC_USART3CLKSOURCE_HSI        RCC_DCKCFGR2_USART3SEL_1
N#define RCC_USART3CLKSOURCE_LSE        RCC_DCKCFGR2_USART3SEL
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_UART4_Clock_Source RCCEx UART4 Clock Source
N  * @{
N  */
N#define RCC_UART4CLKSOURCE_PCLK1        ((uint32_t)0x00000000U)
N#define RCC_UART4CLKSOURCE_SYSCLK       RCC_DCKCFGR2_UART4SEL_0
N#define RCC_UART4CLKSOURCE_HSI          RCC_DCKCFGR2_UART4SEL_1
N#define RCC_UART4CLKSOURCE_LSE          RCC_DCKCFGR2_UART4SEL
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_UART5_Clock_Source RCCEx UART5 Clock Source
N  * @{
N  */
N#define RCC_UART5CLKSOURCE_PCLK1        ((uint32_t)0x00000000U)
N#define RCC_UART5CLKSOURCE_SYSCLK       RCC_DCKCFGR2_UART5SEL_0
N#define RCC_UART5CLKSOURCE_HSI          RCC_DCKCFGR2_UART5SEL_1
N#define RCC_UART5CLKSOURCE_LSE          RCC_DCKCFGR2_UART5SEL
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_USART6_Clock_Source RCCEx USART6 Clock Source
N  * @{
N  */
N#define RCC_USART6CLKSOURCE_PCLK2       ((uint32_t)0x00000000U)
N#define RCC_USART6CLKSOURCE_SYSCLK      RCC_DCKCFGR2_USART6SEL_0
N#define RCC_USART6CLKSOURCE_HSI         RCC_DCKCFGR2_USART6SEL_1
N#define RCC_USART6CLKSOURCE_LSE         RCC_DCKCFGR2_USART6SEL
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_UART7_Clock_Source RCCEx UART7 Clock Source
N  * @{
N  */
N#define RCC_UART7CLKSOURCE_PCLK1       ((uint32_t)0x00000000U)
N#define RCC_UART7CLKSOURCE_SYSCLK      RCC_DCKCFGR2_UART7SEL_0
N#define RCC_UART7CLKSOURCE_HSI         RCC_DCKCFGR2_UART7SEL_1
N#define RCC_UART7CLKSOURCE_LSE         RCC_DCKCFGR2_UART7SEL
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_UART8_Clock_Source RCCEx UART8 Clock Source
N  * @{
N  */
N#define RCC_UART8CLKSOURCE_PCLK1        ((uint32_t)0x00000000U)
N#define RCC_UART8CLKSOURCE_SYSCLK      RCC_DCKCFGR2_UART8SEL_0
N#define RCC_UART8CLKSOURCE_HSI         RCC_DCKCFGR2_UART8SEL_1
N#define RCC_UART8CLKSOURCE_LSE         RCC_DCKCFGR2_UART8SEL
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_I2C1_Clock_Source RCCEx I2C1 Clock Source
N  * @{
N  */
N#define RCC_I2C1CLKSOURCE_PCLK1        ((uint32_t)0x00000000U)
N#define RCC_I2C1CLKSOURCE_SYSCLK       RCC_DCKCFGR2_I2C1SEL_0
N#define RCC_I2C1CLKSOURCE_HSI          RCC_DCKCFGR2_I2C1SEL_1
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_I2C2_Clock_Source RCCEx I2C2 Clock Source
N  * @{
N  */
N#define RCC_I2C2CLKSOURCE_PCLK1        ((uint32_t)0x00000000U)
N#define RCC_I2C2CLKSOURCE_SYSCLK       RCC_DCKCFGR2_I2C2SEL_0
N#define RCC_I2C2CLKSOURCE_HSI          RCC_DCKCFGR2_I2C2SEL_1
N
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_I2C3_Clock_Source RCCEx I2C3 Clock Source
N  * @{
N  */
N#define RCC_I2C3CLKSOURCE_PCLK1        ((uint32_t)0x00000000U)
N#define RCC_I2C3CLKSOURCE_SYSCLK       RCC_DCKCFGR2_I2C3SEL_0
N#define RCC_I2C3CLKSOURCE_HSI          RCC_DCKCFGR2_I2C3SEL_1
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_I2C4_Clock_Source RCCEx I2C4 Clock Source
N  * @{
N  */
N#define RCC_I2C4CLKSOURCE_PCLK1        ((uint32_t)0x00000000U)
N#define RCC_I2C4CLKSOURCE_SYSCLK       RCC_DCKCFGR2_I2C4SEL_0
N#define RCC_I2C4CLKSOURCE_HSI          RCC_DCKCFGR2_I2C4SEL_1
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_LPTIM1_Clock_Source RCCEx LPTIM1 Clock Source
N  * @{
N  */
N#define RCC_LPTIM1CLKSOURCE_PCLK       ((uint32_t)0x00000000U)
N#define RCC_LPTIM1CLKSOURCE_LSI        RCC_DCKCFGR2_LPTIM1SEL_0
N#define RCC_LPTIM1CLKSOURCE_HSI        RCC_DCKCFGR2_LPTIM1SEL_1
N#define RCC_LPTIM1CLKSOURCE_LSE        RCC_DCKCFGR2_LPTIM1SEL
N
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_CLK48_Clock_Source RCCEx CLK48 Clock Source
N  * @{
N  */
N#define RCC_CLK48SOURCE_PLL         ((uint32_t)0x00000000U)
N#define RCC_CLK48SOURCE_PLLSAIP     RCC_DCKCFGR2_CK48MSEL
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_TIM_Prescaler_Selection RCCEx TIM Prescaler Selection
N  * @{
N  */
N#define RCC_TIMPRES_DESACTIVATED        ((uint32_t)0x00000000U)
N#define RCC_TIMPRES_ACTIVATED           RCC_DCKCFGR1_TIMPRE
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_SDMMC1_Clock_Source RCCEx SDMMC1 Clock Source
N  * @{
N  */
N#define RCC_SDMMC1CLKSOURCE_CLK48              ((uint32_t)0x00000000U)
N#define RCC_SDMMC1CLKSOURCE_SYSCLK             RCC_DCKCFGR2_SDMMC1SEL
N/**
N  * @}
N  */
N
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N/** @defgroup RCCEx_SDMMC2_Clock_Source RCCEx SDMMC2 Clock Source
N  * @{
N  */
N#define RCC_SDMMC2CLKSOURCE_CLK48              ((uint32_t)0x00000000U)
N#define RCC_SDMMC2CLKSOURCE_SYSCLK             RCC_DCKCFGR2_SDMMC2SEL
N/**
N  * @}
N  */ 
N
N/** @defgroup RCCEx_DFSDM1_Kernel_Clock_Source  RCCEx DFSDM1 Kernel Clock Source
N  * @{
N  */
N#define RCC_DFSDM1CLKSOURCE_PCLK             ((uint32_t)0x00000000U)
N#define RCC_DFSDM1CLKSOURCE_SYSCLK           RCC_DCKCFGR1_DFSDM1SEL
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_DFSDM1_AUDIO_Clock_Source RCCEx DFSDM1 AUDIO Clock Source
N  * @{
N  */
N#define RCC_DFSDM1AUDIOCLKSOURCE_SAI1        ((uint32_t)0x00000000U)
N#define RCC_DFSDM1AUDIOCLKSOURCE_SAI2        RCC_DCKCFGR1_ADFSDM1SEL
N/**
N  * @}
N  */
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N
N#if defined (STM32F769xx) || defined (STM32F779xx)
X#if 0L || 0L
S/** @defgroup RCCEx_DSI_Clock_Source  RCC DSI Clock Source
S  * @{
S  */
S#define RCC_DSICLKSOURCE_DSIPHY             ((uint32_t)0x00000000U)
S#define RCC_DSICLKSOURCE_PLLR               ((uint32_t)RCC_DCKCFGR2_DSISEL)      
S/**
S  * @}
S  */ 
N#endif /* STM32F769xx || STM32F779xx */
N
N/**
N  * @}
N  */
N     
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup RCCEx_Exported_Macros RCCEx Exported Macros
N  * @{
N  */
N/** @defgroup RCCEx_Peripheral_Clock_Enable_Disable RCCEx_Peripheral_Clock_Enable_Disable
N  * @brief  Enables or disables the AHB/APB peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before 
N  *         using it.   
N  * @{
N  */
N 
N/** @brief  Enables or disables the AHB1 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before 
N  *         using it.
N  */
N#define __HAL_RCC_BKPSRAM_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_BKPSRAMEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_BKPSRAMEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_BKPSRAM_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_BKPSRAMEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_BKPSRAMEN);                                        UNUSED(tmpreg);                                       } while(0)
N                                      
N#define __HAL_RCC_DTCMRAMEN_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DTCMRAMEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DTCMRAMEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_DTCMRAMEN_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DTCMRAMEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DTCMRAMEN);                                        UNUSED(tmpreg);                                       } while(0)
N                                      
N#define __HAL_RCC_DMA2_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA2EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA2EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)  
X#define __HAL_RCC_DMA2_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA2EN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA2EN);                                        UNUSED(tmpreg);                                       } while(0)  
N
N#define __HAL_RCC_DMA2D_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA2DEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA2DEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0) 
X#define __HAL_RCC_DMA2D_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA2DEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA2DEN);                                        UNUSED(tmpreg);                                       } while(0) 
N
N#define __HAL_RCC_USB_OTG_HS_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_USB_OTG_HS_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSEN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSULPIEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSULPIEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSULPIEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSULPIEN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_GPIOA_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOAEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOAEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_GPIOA_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOAEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOAEN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_GPIOB_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOBEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOBEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_GPIOB_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOBEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOBEN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_GPIOC_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOCEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOCEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_GPIOC_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOCEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOCEN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_GPIOD_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_GPIOD_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_GPIOE_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_GPIOE_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_GPIOF_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_GPIOF_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_GPIOG_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_GPIOG_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_GPIOH_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOHEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOHEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_GPIOH_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOHEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOHEN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_GPIOI_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOIEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOIEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_GPIOI_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOIEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOIEN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_GPIOJ_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOJEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOJEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_GPIOJ_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOJEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOJEN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_GPIOK_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOKEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOKEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_GPIOK_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOKEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOKEN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_BKPSRAM_CLK_DISABLE()         (RCC->AHB1ENR &= ~(RCC_AHB1ENR_BKPSRAMEN))
N#define __HAL_RCC_DTCMRAMEN_CLK_DISABLE()       (RCC->AHB1ENR &= ~(RCC_AHB1ENR_DTCMRAMEN))
N#define __HAL_RCC_DMA2_CLK_DISABLE()            (RCC->AHB1ENR &= ~(RCC_AHB1ENR_DMA2EN))
N#define __HAL_RCC_DMA2D_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_DMA2DEN))
N#define __HAL_RCC_USB_OTG_HS_CLK_DISABLE()      (RCC->AHB1ENR &= ~(RCC_AHB1ENR_OTGHSEN))
N#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_DISABLE() (RCC->AHB1ENR &= ~(RCC_AHB1ENR_OTGHSULPIEN))
N#define __HAL_RCC_GPIOA_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOAEN))
N#define __HAL_RCC_GPIOB_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOBEN))
N#define __HAL_RCC_GPIOC_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOCEN))
N#define __HAL_RCC_GPIOD_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIODEN))
N#define __HAL_RCC_GPIOE_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOEEN))
N#define __HAL_RCC_GPIOF_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOFEN))
N#define __HAL_RCC_GPIOG_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOGEN))
N#define __HAL_RCC_GPIOH_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOHEN))
N#define __HAL_RCC_GPIOI_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOIEN))
N#define __HAL_RCC_GPIOJ_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOJEN))
N#define __HAL_RCC_GPIOK_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOKEN))
N/**
N  * @brief  Enable ETHERNET clock.
N  */
N#define __HAL_RCC_ETHMAC_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_ETHMAC_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACEN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_ETHMACTX_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACTXEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACTXEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_ETHMACTX_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACTXEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACTXEN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_ETHMACRX_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACRXEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACRXEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_ETHMACRX_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACRXEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACRXEN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_ETHMACPTP_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACPTPEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACPTPEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_ETHMACPTP_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACPTPEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACPTPEN);                                        UNUSED(tmpreg);                                       } while(0)
N                                      
N#define __HAL_RCC_ETH_CLK_ENABLE()       do {                            \
N                                     __HAL_RCC_ETHMAC_CLK_ENABLE();      \
N                                     __HAL_RCC_ETHMACTX_CLK_ENABLE();    \
N                                     __HAL_RCC_ETHMACRX_CLK_ENABLE();    \
N                                    } while(0)
X#define __HAL_RCC_ETH_CLK_ENABLE()       do {                                                                 __HAL_RCC_ETHMAC_CLK_ENABLE();                                           __HAL_RCC_ETHMACTX_CLK_ENABLE();                                         __HAL_RCC_ETHMACRX_CLK_ENABLE();                                        } while(0)
N/**
N  * @brief  Disable ETHERNET clock.
N  */
N#define __HAL_RCC_ETHMAC_CLK_DISABLE()    (RCC->AHB1ENR &= ~(RCC_AHB1ENR_ETHMACEN))
N#define __HAL_RCC_ETHMACTX_CLK_DISABLE()  (RCC->AHB1ENR &= ~(RCC_AHB1ENR_ETHMACTXEN))
N#define __HAL_RCC_ETHMACRX_CLK_DISABLE()  (RCC->AHB1ENR &= ~(RCC_AHB1ENR_ETHMACRXEN))
N#define __HAL_RCC_ETHMACPTP_CLK_DISABLE() (RCC->AHB1ENR &= ~(RCC_AHB1ENR_ETHMACPTPEN))
N#define __HAL_RCC_ETH_CLK_DISABLE()       do {                             \
N                                      __HAL_RCC_ETHMACTX_CLK_DISABLE();    \
N                                      __HAL_RCC_ETHMACRX_CLK_DISABLE();    \
N                                      __HAL_RCC_ETHMAC_CLK_DISABLE();      \
N                                     } while(0)
X#define __HAL_RCC_ETH_CLK_DISABLE()       do {                                                                   __HAL_RCC_ETHMACTX_CLK_DISABLE();                                          __HAL_RCC_ETHMACRX_CLK_DISABLE();                                          __HAL_RCC_ETHMAC_CLK_DISABLE();                                           } while(0)
N                                     
N/** @brief  Enable or disable the AHB2 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before 
N  *         using it.
N  */
N#define __HAL_RCC_DCMI_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DCMIEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DCMIEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_DCMI_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DCMIEN);                                                                                  tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DCMIEN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#if defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)                                        
X#if 1L || 0L || 0L || 0L                                        
N#define __HAL_RCC_JPEG_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_JPEGEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_JPEGEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_JPEG_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_JPEGEN);                                                                                  tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_JPEGEN);                                        UNUSED(tmpreg);                                       } while(0)
N#define __HAL_RCC_JPEG_CLK_DISABLE()  (RCC->AHB2ENR &= ~(RCC_AHB2ENR_JPEGEN))                                        
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */                                       
N
N#define __HAL_RCC_RNG_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_RNG_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);                                                                                  tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_USB_OTG_FS_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_OTGFSEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_OTGFSEN);\
N                                        UNUSED(tmpreg); \
N                                        __HAL_RCC_SYSCFG_CLK_ENABLE();\
N                                      } while(0) 
X#define __HAL_RCC_USB_OTG_FS_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_OTGFSEN);                                                                                  tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_OTGFSEN);                                        UNUSED(tmpreg);                                         __HAL_RCC_SYSCFG_CLK_ENABLE();                                      } while(0) 
N                                      
N#define __HAL_RCC_DCMI_CLK_DISABLE()  (RCC->AHB2ENR &= ~(RCC_AHB2ENR_DCMIEN))                                        
N#define __HAL_RCC_RNG_CLK_DISABLE()   (RCC->AHB2ENR &= ~(RCC_AHB2ENR_RNGEN))                                        
N
N#define __HAL_RCC_USB_OTG_FS_CLK_DISABLE() (RCC->AHB2ENR &= ~(RCC_AHB2ENR_OTGFSEN))
N#if defined(STM32F756xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 0L || 0L
S#define __HAL_RCC_CRYP_CLK_ENABLE()   do { \
S                                        __IO uint32_t tmpreg; \
S                                        SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_CRYPEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_CRYPEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0)
X#define __HAL_RCC_CRYP_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_CRYPEN);                                                                                  tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_CRYPEN);                                        UNUSED(tmpreg);                                       } while(0)
S
S#define __HAL_RCC_HASH_CLK_ENABLE()   do { \
S                                        __IO uint32_t tmpreg; \
S                                        SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_HASHEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_HASHEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0)
X#define __HAL_RCC_HASH_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_HASHEN);                                                                                  tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_HASHEN);                                        UNUSED(tmpreg);                                       } while(0)
S                                      
S#define __HAL_RCC_CRYP_CLK_DISABLE()  (RCC->AHB2ENR &= ~(RCC_AHB2ENR_CRYPEN))
S#define __HAL_RCC_HASH_CLK_DISABLE()  (RCC->AHB2ENR &= ~(RCC_AHB2ENR_HASHEN)) 
N#endif /* STM32F756x || STM32F777xx || STM32F779xx */
N                                        
N/** @brief  Enables or disables the AHB3 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before 
N  *         using it. 
N  */
N#define __HAL_RCC_FMC_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_FMC_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);                                                                                  tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_QSPI_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_QSPI_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN);                                                                                  tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_FMC_CLK_DISABLE()   (RCC->AHB3ENR &= ~(RCC_AHB3ENR_FMCEN))
N#define __HAL_RCC_QSPI_CLK_DISABLE()  (RCC->AHB3ENR &= ~(RCC_AHB3ENR_QSPIEN))
N
N/** @brief  Enable or disable the Low Speed APB (APB1) peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before 
N  *         using it. 
N  */
N#define __HAL_RCC_TIM2_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_TIM2_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_TIM3_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_TIM3_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_TIM4_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_TIM4_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_TIM5_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM5EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM5EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_TIM5_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM5EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM5EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_TIM6_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_TIM6_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_TIM7_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_TIM7_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_TIM12_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_TIM12_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_TIM13_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_TIM13_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_TIM14_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_TIM14_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_LPTIM1_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_LPTIM1EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_LPTIM1EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_LPTIM1_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_LPTIM1EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_LPTIM1EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N#define __HAL_RCC_RTC_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_RTCEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_RTCEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_RTC_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_RTCEN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_RTCEN);                                        UNUSED(tmpreg);                                       } while(0)
N                                        
N#define __HAL_RCC_CAN3_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN3EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN3EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_CAN3_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN3EN);                                        UNUSED(tmpreg);                                       } while(0)
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N                                        
N#define __HAL_RCC_SPI2_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI2EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI2EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_SPI2_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI2EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI2EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_SPI3_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_SPI3_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_SPDIFRX_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPDIFRXEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPDIFRXEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_SPDIFRX_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPDIFRXEN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPDIFRXEN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_USART2_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART2EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART2EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_USART2_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART2EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART2EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_USART3_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_USART3_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_UART4_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_UART4_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_UART5_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_UART5_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_I2C1_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C1EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C1EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_I2C1_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C1EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C1EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_I2C2_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C2EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C2EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_I2C2_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C2EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C2EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_I2C3_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_I2C3_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_I2C4_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C4EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C4EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_I2C4_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C4EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C4EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_CAN1_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_CAN1_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_CAN2_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_CAN2_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_CEC_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CECEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CECEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_CEC_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CECEN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CECEN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_DAC_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_DAC_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_UART7_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART7EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART7EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_UART7_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART7EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART7EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_UART8_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART8EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART8EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_UART8_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART8EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART8EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_TIM2_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM2EN))
N#define __HAL_RCC_TIM3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM3EN))
N#define __HAL_RCC_TIM4_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM4EN))
N#define __HAL_RCC_TIM5_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM5EN))
N#define __HAL_RCC_TIM6_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM6EN))
N#define __HAL_RCC_TIM7_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM7EN))
N#define __HAL_RCC_TIM12_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM12EN))
N#define __HAL_RCC_TIM13_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM13EN))
N#define __HAL_RCC_TIM14_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM14EN))
N#define __HAL_RCC_LPTIM1_CLK_DISABLE() (RCC->APB1ENR &= ~(RCC_APB1ENR_LPTIM1EN))
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N#define __HAL_RCC_RTC_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_RTCEN))                                        
N#define __HAL_RCC_CAN3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_CAN3EN))
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */                                        
N#define __HAL_RCC_SPI2_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_SPI2EN))
N#define __HAL_RCC_SPI3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_SPI3EN))
N#define __HAL_RCC_SPDIFRX_CLK_DISABLE()(RCC->APB1ENR &= ~(RCC_APB1ENR_SPDIFRXEN))
N#define __HAL_RCC_USART2_CLK_DISABLE() (RCC->APB1ENR &= ~(RCC_APB1ENR_USART2EN))
N#define __HAL_RCC_USART3_CLK_DISABLE() (RCC->APB1ENR &= ~(RCC_APB1ENR_USART3EN))
N#define __HAL_RCC_UART4_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_UART4EN))
N#define __HAL_RCC_UART5_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_UART5EN))
N#define __HAL_RCC_I2C1_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_I2C1EN))
N#define __HAL_RCC_I2C2_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_I2C2EN))
N#define __HAL_RCC_I2C3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_I2C3EN))
N#define __HAL_RCC_I2C4_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_I2C4EN))
N#define __HAL_RCC_CAN1_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_CAN1EN))
N#define __HAL_RCC_CAN2_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_CAN2EN))
N#define __HAL_RCC_CEC_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_CECEN))
N#define __HAL_RCC_DAC_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_DACEN))
N#define __HAL_RCC_UART7_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_UART7EN))
N#define __HAL_RCC_UART8_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_UART8EN))
N
N/** @brief  Enable or disable the High Speed APB (APB2) peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before 
N  *         using it.
N  */
N#define __HAL_RCC_TIM1_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM1EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM1EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_TIM1_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM1EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM1EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_TIM8_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_TIM8_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_USART1_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_USART1EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_USART1EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_USART1_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_USART1EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_USART1EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_USART6_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_USART6EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_USART6EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_USART6_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_USART6EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_USART6EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)                                        
X#if 0L || 1L || 0L || 0L || 0L                                        
N#define __HAL_RCC_SDMMC2_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SDMMC2EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SDMMC2EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_SDMMC2_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SDMMC2EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SDMMC2EN);                                        UNUSED(tmpreg);                                       } while(0)
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N
N#define __HAL_RCC_ADC1_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC1EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC1EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_ADC1_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC1EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC1EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_ADC2_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC2EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC2EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_ADC2_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC2EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC2EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_ADC3_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC3EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC3EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_ADC3_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC3EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC3EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_SDMMC1_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SDMMC1EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SDMMC1EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_SDMMC1_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SDMMC1EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SDMMC1EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_SPI1_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI1EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI1EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_SPI1_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI1EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI1EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_SPI4_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_SPI4_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_TIM9_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM9EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM9EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_TIM9_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM9EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM9EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_TIM10_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_TIM10_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_TIM11_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM11EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM11EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_TIM11_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM11EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM11EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_SPI5_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_SPI5_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_SPI6_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI6EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI6EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_SPI6_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI6EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI6EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_SAI1_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_SAI1_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_SAI2_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI2EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI2EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_SAI2_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI2EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI2EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#if defined (STM32F746xx) || defined (STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 0L || 1L || 0L || 0L || 0L
N#define __HAL_RCC_LTDC_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_LTDCEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_LTDCEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_LTDC_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_LTDCEN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_LTDCEN);                                        UNUSED(tmpreg);                                       } while(0)
N#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N                                        
N#if defined (STM32F769xx) || defined (STM32F779xx)                                        
X#if 0L || 0L                                        
S#define __HAL_RCC_DSI_CLK_ENABLE()   do { \
S                                        __IO uint32_t tmpreg; \
S                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_DSIEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_DSIEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0)                                                                            
X#define __HAL_RCC_DSI_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_DSIEN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_DSIEN);                                        UNUSED(tmpreg);                                       } while(0)                                                                            
N#endif /* STM32F769xx || STM32F779xx */
N                                        
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)                                        
X#if 0L || 1L || 0L || 0L || 0L                                        
N#define __HAL_RCC_DFSDM1_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_DFSDM1EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_DFSDM1EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)    
X#define __HAL_RCC_DFSDM1_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_DFSDM1EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_DFSDM1EN);                                        UNUSED(tmpreg);                                       } while(0)    
N
N#define __HAL_RCC_MDIO_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_MDIOEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_MDIOEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_MDIO_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_MDIOEN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_MDIOEN);                                        UNUSED(tmpreg);                                       } while(0)
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N                                        
N#define __HAL_RCC_TIM1_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM1EN))
N#define __HAL_RCC_TIM8_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM8EN))
N#define __HAL_RCC_USART1_CLK_DISABLE() (RCC->APB2ENR &= ~(RCC_APB2ENR_USART1EN))
N#define __HAL_RCC_USART6_CLK_DISABLE() (RCC->APB2ENR &= ~(RCC_APB2ENR_USART6EN))
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)                                        
X#if 0L || 1L || 0L || 0L || 0L                                        
N#define __HAL_RCC_SDMMC2_CLK_DISABLE() (RCC->APB2ENR &= ~(RCC_APB2ENR_SDMMC2EN))
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */                                        
N#define __HAL_RCC_ADC1_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_ADC1EN))
N#define __HAL_RCC_ADC2_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_ADC2EN))
N#define __HAL_RCC_ADC3_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_ADC3EN))
N#define __HAL_RCC_SDMMC1_CLK_DISABLE() (RCC->APB2ENR &= ~(RCC_APB2ENR_SDMMC1EN))
N#define __HAL_RCC_SPI1_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SPI1EN))
N#define __HAL_RCC_SPI4_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SPI4EN))
N#define __HAL_RCC_TIM9_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM9EN))
N#define __HAL_RCC_TIM10_CLK_DISABLE()  (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM10EN))
N#define __HAL_RCC_TIM11_CLK_DISABLE()  (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM11EN))
N#define __HAL_RCC_SPI5_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SPI5EN))
N#define __HAL_RCC_SPI6_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SPI6EN))
N#define __HAL_RCC_SAI1_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SAI1EN))
N#define __HAL_RCC_SAI2_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SAI2EN))
N#if defined (STM32F746xx) || defined (STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 0L || 1L || 0L || 0L || 0L
N#define __HAL_RCC_LTDC_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_LTDCEN))
N#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N#if defined (STM32F769xx) || defined (STM32F779xx)                                        
X#if 0L || 0L                                        
S#define __HAL_RCC_DSI_CLK_DISABLE()    (RCC->APB2ENR &= ~(RCC_APB2ENR_DSIEN))
N#endif /* STM32F769xx || STM32F779xx */                                        
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)                                        
X#if 0L || 1L || 0L || 0L || 0L                                        
N#define __HAL_RCC_DFSDM1_CLK_DISABLE()  (RCC->APB2ENR &= ~(RCC_APB2ENR_DFSDM1EN))
N#define __HAL_RCC_MDIO_CLK_DISABLE()  (RCC->APB2ENR &= ~(RCC_APB2ENR_MDIOEN))
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N                                        
N/**
N  * @}
N  */
N
N
N/** @defgroup RCCEx_Peripheral_Clock_Enable_Disable_Status Peripheral Clock Enable Disable Status
N  * @brief  Get the enable or disable status of the AHB/APB peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{
N  */
N 
N/** @brief  Get the enable or disable status of the AHB1 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it. 
N  */
N#define __HAL_RCC_BKPSRAM_IS_CLK_ENABLED()          ((RCC->AHB1ENR & (RCC_AHB1ENR_BKPSRAMEN)) != RESET)
N#define __HAL_RCC_DTCMRAMEN_IS_CLK_ENABLED()        ((RCC->AHB1ENR & (RCC_AHB1ENR_DTCMRAMEN)) != RESET)
N#define __HAL_RCC_DMA2_IS_CLK_ENABLED()             ((RCC->AHB1ENR & (RCC_AHB1ENR_DMA2EN)) != RESET)  
N#define __HAL_RCC_DMA2D_IS_CLK_ENABLED()            ((RCC->AHB1ENR & (RCC_AHB1ENR_DMA2DEN)) != RESET)
N#define __HAL_RCC_USB_OTG_HS_IS_CLK_ENABLED()       ((RCC->AHB1ENR & (RCC_AHB1ENR_OTGHSEN)) != RESET)
N#define __HAL_RCC_USB_OTG_HS_ULPI_IS_CLK_ENABLED()  ((RCC->AHB1ENR & (RCC_AHB1ENR_OTGHSULPIEN)) != RESET)
N#define __HAL_RCC_GPIOA_IS_CLK_ENABLED()            ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOAEN)) != RESET)
N#define __HAL_RCC_GPIOB_IS_CLK_ENABLED()            ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOBEN)) != RESET)
N#define __HAL_RCC_GPIOC_IS_CLK_ENABLED()            ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOCEN)) != RESET)
N#define __HAL_RCC_GPIOD_IS_CLK_ENABLED()            ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIODEN)) != RESET)
N#define __HAL_RCC_GPIOE_IS_CLK_ENABLED()            ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOEEN)) != RESET)
N#define __HAL_RCC_GPIOF_IS_CLK_ENABLED()            ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOFEN)) != RESET)
N#define __HAL_RCC_GPIOG_IS_CLK_ENABLED()            ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOGEN)) != RESET)
N#define __HAL_RCC_GPIOH_IS_CLK_ENABLED()            ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOHEN)) != RESET)
N#define __HAL_RCC_GPIOI_IS_CLK_ENABLED()            ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOIEN)) != RESET)
N#define __HAL_RCC_GPIOJ_IS_CLK_ENABLED()            ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOJEN)) != RESET)
N#define __HAL_RCC_GPIOK_IS_CLK_ENABLED()            ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOKEN)) != RESET)
N
N#define __HAL_RCC_BKPSRAM_IS_CLK_DISABLED()         ((RCC->AHB1ENR & (RCC_AHB1ENR_BKPSRAMEN)) == RESET)
N#define __HAL_RCC_DTCMRAMEN_IS_CLK_DISABLED()       ((RCC->AHB1ENR & (RCC_AHB1ENR_DTCMRAMEN)) == RESET)
N#define __HAL_RCC_DMA2_IS_CLK_DISABLED()            ((RCC->AHB1ENR & (RCC_AHB1ENR_DMA2EN)) == RESET)
N#define __HAL_RCC_DMA2D_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_DMA2DEN)) == RESET)
N#define __HAL_RCC_USB_OTG_HS_IS_CLK_DISABLED()      ((RCC->AHB1ENR & (RCC_AHB1ENR_OTGHSEN)) == RESET)
N#define __HAL_RCC_USB_OTG_HS_ULPI_IS_CLK_DISABLED() ((RCC->AHB1ENR & (RCC_AHB1ENR_OTGHSULPIEN)) == RESET)
N#define __HAL_RCC_GPIOA_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOAEN)) == RESET)
N#define __HAL_RCC_GPIOB_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOBEN)) == RESET)
N#define __HAL_RCC_GPIOC_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOCEN)) == RESET)
N#define __HAL_RCC_GPIOD_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIODEN)) == RESET)
N#define __HAL_RCC_GPIOE_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOEEN)) == RESET)
N#define __HAL_RCC_GPIOF_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOFEN)) == RESET)
N#define __HAL_RCC_GPIOG_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOGEN)) == RESET)
N#define __HAL_RCC_GPIOH_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOHEN)) == RESET)
N#define __HAL_RCC_GPIOI_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOIEN)) == RESET)
N#define __HAL_RCC_GPIOJ_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOJEN)) == RESET)
N#define __HAL_RCC_GPIOK_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOKEN)) == RESET)
N/**
N  * @brief  Enable ETHERNET clock.
N  */
N#define __HAL_RCC_ETHMAC_IS_CLK_ENABLED()     ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACEN)) != RESET)
N#define __HAL_RCC_ETHMACTX_IS_CLK_ENABLED()   ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACTXEN)) != RESET)
N#define __HAL_RCC_ETHMACRX_IS_CLK_ENABLED()   ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACRXEN)) != RESET)
N#define __HAL_RCC_ETHMACPTP_IS_CLK_ENABLED()  ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACPTPEN)) != RESET)
N#define __HAL_RCC_ETH_IS_CLK_ENABLED()        (__HAL_RCC_ETHMAC_IS_CLK_ENABLED()   && \
N                                               __HAL_RCC_ETHMACTX_IS_CLK_ENABLED() && \
N                                               __HAL_RCC_ETHMACRX_IS_CLK_ENABLED())
X#define __HAL_RCC_ETH_IS_CLK_ENABLED()        (__HAL_RCC_ETHMAC_IS_CLK_ENABLED()   &&                                                __HAL_RCC_ETHMACTX_IS_CLK_ENABLED() &&                                                __HAL_RCC_ETHMACRX_IS_CLK_ENABLED())
N
N/**
N  * @brief  Disable ETHERNET clock.
N  */
N#define __HAL_RCC_ETHMAC_IS_CLK_DISABLED()    ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACEN)) == RESET)
N#define __HAL_RCC_ETHMACTX_IS_CLK_DISABLED()  ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACTXEN)) == RESET)
N#define __HAL_RCC_ETHMACRX_IS_CLK_DISABLED()  ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACRXEN)) == RESET)
N#define __HAL_RCC_ETHMACPTP_IS_CLK_DISABLED() ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACPTPEN)) == RESET)
N#define __HAL_RCC_ETH_IS_CLK_DISABLED()        (__HAL_RCC_ETHMAC_IS_CLK_DISABLED()   && \
N                                                __HAL_RCC_ETHMACTX_IS_CLK_DISABLED() && \
N                                                __HAL_RCC_ETHMACRX_IS_CLK_DISABLED())
X#define __HAL_RCC_ETH_IS_CLK_DISABLED()        (__HAL_RCC_ETHMAC_IS_CLK_DISABLED()   &&                                                 __HAL_RCC_ETHMACTX_IS_CLK_DISABLED() &&                                                 __HAL_RCC_ETHMACRX_IS_CLK_DISABLED())
N
N/** @brief  Get the enable or disable status of the AHB2 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it. 
N  */
N#define __HAL_RCC_DCMI_IS_CLK_ENABLED()        ((RCC->AHB2ENR & (RCC_AHB2ENR_DCMIEN)) != RESET)
N#define __HAL_RCC_RNG_IS_CLK_ENABLED()         ((RCC->AHB2ENR & (RCC_AHB2ENR_RNGEN)) != RESET)
N#define __HAL_RCC_USB_OTG_FS_IS_CLK_ENABLED()  ((RCC->AHB2ENR & (RCC_AHB2ENR_OTGFSEN)) != RESET)
N                                   
N#define __HAL_RCC_DCMI_IS_CLK_DISABLED()       ((RCC->AHB2ENR & (RCC_AHB2ENR_DCMIEN)) == RESET)
N#define __HAL_RCC_RNG_IS_CLK_DISABLED()        ((RCC->AHB2ENR & (RCC_AHB2ENR_RNGEN)) == RESET)                                        
N#define __HAL_RCC_USB_IS_OTG_FS_CLK_DISABLED() ((RCC->AHB2ENR & (RCC_AHB2ENR_OTGFSEN)) == RESET)
N
N#if defined(STM32F756xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 0L || 0L
S#define __HAL_RCC_CRYP_IS_CLK_ENABLED()   ((RCC->AHB2ENR & (RCC_AHB2ENR_CRYPEN)) != RESET)
S#define __HAL_RCC_HASH_IS_CLK_ENABLED()   ((RCC->AHB2ENR & (RCC_AHB2ENR_HASHEN)) != RESET)
S#define __HAL_RCC_CRYP_IS_CLK_DISABLED()  ((RCC->AHB2ENR & (RCC_AHB2ENR_CRYPEN)) == RESET)
S#define __HAL_RCC_HASH_IS_CLK_DISABLED()  ((RCC->AHB2ENR & (RCC_AHB2ENR_HASHEN)) == RESET) 
N#endif /* STM32F756xx || STM32F777xx || STM32F779xx */
N
N#if defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 1L || 0L || 0L || 0L
N#define __HAL_RCC_JPEG_IS_CLK_ENABLED()        ((RCC->AHB2ENR & (RCC_AHB2ENR_JPEGEN)) != RESET)
N#define __HAL_RCC_JPEG_IS_CLK_DISABLED()       ((RCC->AHB2ENR & (RCC_AHB2ENR_JPEGEN)) == RESET)
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N
N/** @brief  Get the enable or disable status of the AHB3 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  */  
N#define __HAL_RCC_FMC_IS_CLK_ENABLED()   ((RCC->AHB3ENR & (RCC_AHB3ENR_FMCEN)) != RESET)
N#define __HAL_RCC_QSPI_IS_CLK_ENABLED()  ((RCC->AHB3ENR & (RCC_AHB3ENR_QSPIEN)) != RESET)
N
N#define __HAL_RCC_FMC_IS_CLK_DISABLED()   ((RCC->AHB3ENR & (RCC_AHB3ENR_FMCEN)) == RESET)
N#define __HAL_RCC_QSPI_IS_CLK_DISABLED()  ((RCC->AHB3ENR & (RCC_AHB3ENR_QSPIEN)) == RESET)
N
N/** @brief  Get the enable or disable status of the APB1 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  */
N#define __HAL_RCC_TIM2_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM2EN)) != RESET)
N#define __HAL_RCC_TIM3_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM3EN)) != RESET)
N#define __HAL_RCC_TIM4_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM4EN)) != RESET)
N#define __HAL_RCC_TIM5_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM5EN)) != RESET)
N#define __HAL_RCC_TIM6_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM6EN)) != RESET)
N#define __HAL_RCC_TIM7_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM7EN)) != RESET)
N#define __HAL_RCC_TIM12_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM12EN)) != RESET)
N#define __HAL_RCC_TIM13_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM13EN)) != RESET)
N#define __HAL_RCC_TIM14_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM14EN)) != RESET)
N#define __HAL_RCC_LPTIM1_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_LPTIM1EN)) != RESET)
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N#define __HAL_RCC_RTC_IS_CLK_ENABLED()     ((RCC->APB1ENR & (RCC_APB1ENR_RTCEN)) != RESET)
N#define __HAL_RCC_CAN3_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_CAN3EN)) != RESET)
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N#define __HAL_RCC_SPI2_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_SPI2EN)) != RESET)
N#define __HAL_RCC_SPI3_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_SPI3EN)) != RESET)
N#define __HAL_RCC_SPDIFRX_IS_CLK_ENABLED() ((RCC->APB1ENR & (RCC_APB1ENR_SPDIFRXEN)) != RESET)
N#define __HAL_RCC_USART2_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_USART2EN)) != RESET)
N#define __HAL_RCC_USART3_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_USART3EN)) != RESET)
N#define __HAL_RCC_UART4_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_UART4EN)) != RESET)
N#define __HAL_RCC_UART5_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_UART5EN)) != RESET)
N#define __HAL_RCC_I2C1_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_I2C1EN)) != RESET)
N#define __HAL_RCC_I2C2_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_I2C2EN)) != RESET)
N#define __HAL_RCC_I2C3_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_I2C3EN)) != RESET)
N#define __HAL_RCC_I2C4_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_I2C4EN)) != RESET)
N#define __HAL_RCC_CAN1_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_CAN1EN)) != RESET)
N#define __HAL_RCC_CAN2_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_CAN2EN)) != RESET)
N#define __HAL_RCC_CEC_IS_CLK_ENABLED()     ((RCC->APB1ENR & (RCC_APB1ENR_CECEN)) != RESET)
N#define __HAL_RCC_DAC_IS_CLK_ENABLED()     ((RCC->APB1ENR & (RCC_APB1ENR_DACEN)) != RESET)
N#define __HAL_RCC_UART7_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_UART7EN)) != RESET)
N#define __HAL_RCC_UART8_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_UART8EN)) != RESET)
N
N#define __HAL_RCC_TIM2_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM2EN)) == RESET)
N#define __HAL_RCC_TIM3_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM3EN)) == RESET)
N#define __HAL_RCC_TIM4_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM4EN)) == RESET)
N#define __HAL_RCC_TIM5_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM5EN)) == RESET)
N#define __HAL_RCC_TIM6_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM6EN)) == RESET)
N#define __HAL_RCC_TIM7_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM7EN)) == RESET)
N#define __HAL_RCC_TIM12_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_TIM12EN)) == RESET)
N#define __HAL_RCC_TIM13_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_TIM13EN)) == RESET)
N#define __HAL_RCC_TIM14_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_TIM14EN)) == RESET)
N#define __HAL_RCC_LPTIM1_IS_CLK_DISABLED() ((RCC->APB1ENR & (RCC_APB1ENR_LPTIM1EN)) == RESET)
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N#define __HAL_RCC_RTC_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_RTCEN)) == RESET)
N#define __HAL_RCC_CAN3_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_CAN3EN)) == RESET)
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N#define __HAL_RCC_SPI2_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_SPI2EN)) == RESET)
N#define __HAL_RCC_SPI3_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_SPI3EN)) == RESET)
N#define __HAL_RCC_SPDIFRX_IS_CLK_DISABLED()((RCC->APB1ENR & (RCC_APB1ENR_SPDIFRXEN)) == RESET)
N#define __HAL_RCC_USART2_IS_CLK_DISABLED() ((RCC->APB1ENR & (RCC_APB1ENR_USART2EN)) == RESET)
N#define __HAL_RCC_USART3_IS_CLK_DISABLED() ((RCC->APB1ENR & (RCC_APB1ENR_USART3EN)) == RESET)
N#define __HAL_RCC_UART4_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART4EN)) == RESET)
N#define __HAL_RCC_UART5_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART5EN)) == RESET)
N#define __HAL_RCC_I2C1_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_I2C1EN)) == RESET)
N#define __HAL_RCC_I2C2_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_I2C2EN)) == RESET)
N#define __HAL_RCC_I2C3_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_I2C3EN)) == RESET)
N#define __HAL_RCC_I2C4_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_I2C4EN)) == RESET)
N#define __HAL_RCC_CAN1_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_CAN1EN)) == RESET)
N#define __HAL_RCC_CAN2_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_CAN2EN)) == RESET)
N#define __HAL_RCC_CEC_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_CECEN)) == RESET)
N#define __HAL_RCC_DAC_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_DACEN)) == RESET)
N#define __HAL_RCC_UART7_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART7EN)) == RESET)
N#define __HAL_RCC_UART8_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART8EN)) == RESET)
N
N/** @brief  Get the enable or disable status of the APB2 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  */
N#define __HAL_RCC_TIM1_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_TIM1EN)) != RESET)
N#define __HAL_RCC_TIM8_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_TIM8EN)) != RESET)
N#define __HAL_RCC_USART1_IS_CLK_ENABLED()  ((RCC->APB2ENR & (RCC_APB2ENR_USART1EN)) != RESET)
N#define __HAL_RCC_USART6_IS_CLK_ENABLED()  ((RCC->APB2ENR & (RCC_APB2ENR_USART6EN)) != RESET)
N#define __HAL_RCC_ADC1_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_ADC1EN)) != RESET)
N#define __HAL_RCC_ADC2_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_ADC2EN)) != RESET)
N#define __HAL_RCC_ADC3_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_ADC3EN)) != RESET)
N#define __HAL_RCC_SDMMC1_IS_CLK_ENABLED()  ((RCC->APB2ENR & (RCC_APB2ENR_SDMMC1EN)) != RESET)
N#define __HAL_RCC_SPI1_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_SPI1EN)) != RESET)
N#define __HAL_RCC_SPI4_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_SPI4EN)) != RESET)
N#define __HAL_RCC_TIM9_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_TIM9EN)) != RESET)
N#define __HAL_RCC_TIM10_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_TIM10EN)) != RESET)
N#define __HAL_RCC_TIM11_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_TIM11EN)) != RESET)
N#define __HAL_RCC_SPI5_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_SPI5EN)) != RESET)
N#define __HAL_RCC_SPI6_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_SPI6EN)) != RESET)
N#define __HAL_RCC_SAI1_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_SAI1EN)) != RESET)
N#define __HAL_RCC_SAI2_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_SAI2EN)) != RESET)
N#if defined (STM32F746xx) || defined (STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 0L || 1L || 0L || 0L || 0L
N#define __HAL_RCC_LTDC_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_LTDCEN)) != RESET)
N#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N#if defined (STM32F769xx) || defined (STM32F779xx)
X#if 0L || 0L
S#define __HAL_RCC_DSI_IS_CLK_ENABLED()     ((RCC->APB2ENR & (RCC_APB2ENR_DSIEN)) != RESET)
N#endif /* STM32F769xx || STM32F779xx */
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N#define __HAL_RCC_SDMMC2_IS_CLK_ENABLED()  ((RCC->APB2ENR & (RCC_APB2ENR_SDMMC2EN)) != RESET)
N#define __HAL_RCC_DFSDM1_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_DFSDM1EN)) != RESET)
N#define __HAL_RCC_MDIO_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_MDIOEN)) != RESET)
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N#define __HAL_RCC_TIM1_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_TIM1EN)) == RESET)
N#define __HAL_RCC_TIM8_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_TIM8EN)) == RESET)
N#define __HAL_RCC_USART1_IS_CLK_DISABLED() ((RCC->APB2ENR & (RCC_APB2ENR_USART1EN)) == RESET)
N#define __HAL_RCC_USART6_IS_CLK_DISABLED() ((RCC->APB2ENR & (RCC_APB2ENR_USART6EN)) == RESET)
N#define __HAL_RCC_ADC1_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_ADC1EN)) == RESET)
N#define __HAL_RCC_ADC2_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_ADC2EN)) == RESET)
N#define __HAL_RCC_ADC3_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_ADC3EN)) == RESET)
N#define __HAL_RCC_SDMMC1_IS_CLK_DISABLED() ((RCC->APB2ENR & (RCC_APB2ENR_SDMMC1EN)) == RESET)
N#define __HAL_RCC_SPI1_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SPI1EN)) == RESET)
N#define __HAL_RCC_SPI4_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SPI4EN)) == RESET)
N#define __HAL_RCC_TIM9_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_TIM9EN)) == RESET)
N#define __HAL_RCC_TIM10_IS_CLK_DISABLED()  ((RCC->APB2ENR & (RCC_APB2ENR_TIM10EN)) == RESET)
N#define __HAL_RCC_TIM11_IS_CLK_DISABLED()  ((RCC->APB2ENR & (RCC_APB2ENR_TIM11EN)) == RESET)
N#define __HAL_RCC_SPI5_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SPI5EN)) == RESET)
N#define __HAL_RCC_SPI6_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SPI6EN)) == RESET)
N#define __HAL_RCC_SAI1_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SAI1EN)) == RESET)
N#define __HAL_RCC_SAI2_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SAI2EN)) == RESET)
N#if defined (STM32F746xx) || defined (STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 0L || 1L || 0L || 0L || 0L
N#define __HAL_RCC_LTDC_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_LTDCEN)) == RESET)  
N#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N#if defined (STM32F769xx) || defined (STM32F779xx)
X#if 0L || 0L
S#define __HAL_RCC_DSI_IS_CLK_DISABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_DSIEN)) == RESET)
N#endif /* STM32F769xx || STM32F779xx */
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N#define __HAL_RCC_SDMMC2_IS_CLK_DISABLED() ((RCC->APB2ENR & (RCC_APB2ENR_SDMMC2EN)) == RESET)
N#define __HAL_RCC_DFSDM1_IS_CLK_DISABLED()  ((RCC->APB2ENR & (RCC_APB2ENR_DFSDM1EN)) == RESET)
N#define __HAL_RCC_MDIO_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_MDIOEN)) == RESET)
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N/**
N  * @}
N  */  
N
N/** @defgroup RCCEx_Force_Release_Peripheral_Reset RCCEx Force Release Peripheral Reset
N  * @brief  Forces or releases AHB/APB peripheral reset.
N  * @{
N  */
N  
N/** @brief  Force or release AHB1 peripheral reset.
N  */  
N#define __HAL_RCC_DMA2_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_DMA2RST))
N#define __HAL_RCC_DMA2D_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_DMA2DRST))
N#define __HAL_RCC_ETHMAC_FORCE_RESET()   (RCC->AHB1RSTR |= (RCC_AHB1RSTR_ETHMACRST))
N#define __HAL_RCC_USB_OTG_HS_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_OTGHRST))
N#define __HAL_RCC_GPIOA_FORCE_RESET()   (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOARST))
N#define __HAL_RCC_GPIOB_FORCE_RESET()   (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOBRST))
N#define __HAL_RCC_GPIOC_FORCE_RESET()   (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOCRST))
N#define __HAL_RCC_GPIOD_FORCE_RESET()   (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIODRST))
N#define __HAL_RCC_GPIOE_FORCE_RESET()   (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOERST))
N#define __HAL_RCC_GPIOF_FORCE_RESET()   (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOFRST))
N#define __HAL_RCC_GPIOG_FORCE_RESET()   (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOGRST))
N#define __HAL_RCC_GPIOH_FORCE_RESET()   (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOHRST))
N#define __HAL_RCC_GPIOI_FORCE_RESET()   (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOIRST))
N#define __HAL_RCC_GPIOJ_FORCE_RESET()   (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOJRST))
N#define __HAL_RCC_GPIOK_FORCE_RESET()   (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOKRST))
N
N#define __HAL_RCC_DMA2_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_DMA2RST))
N#define __HAL_RCC_DMA2D_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_DMA2DRST))
N#define __HAL_RCC_ETHMAC_RELEASE_RESET() (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_ETHMACRST))
N#define __HAL_RCC_USB_OTG_HS_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_OTGHRST))
N#define __HAL_RCC_GPIOA_RELEASE_RESET() (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOARST))
N#define __HAL_RCC_GPIOB_RELEASE_RESET() (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOBRST))
N#define __HAL_RCC_GPIOC_RELEASE_RESET() (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOCRST))
N#define __HAL_RCC_GPIOD_RELEASE_RESET() (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIODRST))
N#define __HAL_RCC_GPIOE_RELEASE_RESET() (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOERST))
N#define __HAL_RCC_GPIOF_RELEASE_RESET() (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOFRST))
N#define __HAL_RCC_GPIOG_RELEASE_RESET() (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOGRST))
N#define __HAL_RCC_GPIOH_RELEASE_RESET() (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOHRST))
N#define __HAL_RCC_GPIOI_RELEASE_RESET() (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOIRST))
N#define __HAL_RCC_GPIOJ_RELEASE_RESET() (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOJRST))
N#define __HAL_RCC_GPIOK_RELEASE_RESET() (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOKRST))
N 
N/** @brief  Force or release AHB2 peripheral reset.
N  */
N#define __HAL_RCC_AHB2_FORCE_RESET()    (RCC->AHB2RSTR = 0xFFFFFFFFU) 
N#define __HAL_RCC_DCMI_FORCE_RESET()   (RCC->AHB2RSTR |= (RCC_AHB2RSTR_DCMIRST))
N#define __HAL_RCC_RNG_FORCE_RESET()    (RCC->AHB2RSTR |= (RCC_AHB2RSTR_RNGRST))
N#define __HAL_RCC_USB_OTG_FS_FORCE_RESET()   (RCC->AHB2RSTR |= (RCC_AHB2RSTR_OTGFSRST))
N
N#define __HAL_RCC_AHB2_RELEASE_RESET()  (RCC->AHB2RSTR = 0x00U)
N#define __HAL_RCC_DCMI_RELEASE_RESET() (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_DCMIRST))
N#define __HAL_RCC_RNG_RELEASE_RESET()  (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_RNGRST))
N#define __HAL_RCC_USB_OTG_FS_RELEASE_RESET() (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_OTGFSRST))
N
N#if defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 1L || 0L || 0L || 0L
N#define __HAL_RCC_JPEG_FORCE_RESET()   (RCC->AHB2RSTR |= (RCC_AHB2RSTR_JPEGRST))
N#define __HAL_RCC_JPEG_RELEASE_RESET() (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_JPEGRST))
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N
N#if defined(STM32F756xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 0L || 0L
S#define __HAL_RCC_CRYP_FORCE_RESET()   (RCC->AHB2RSTR |= (RCC_AHB2RSTR_CRYPRST))
S#define __HAL_RCC_HASH_FORCE_RESET()   (RCC->AHB2RSTR |= (RCC_AHB2RSTR_HASHRST))
S#define __HAL_RCC_CRYP_RELEASE_RESET() (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_CRYPRST))
S#define __HAL_RCC_HASH_RELEASE_RESET() (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_HASHRST))
N#endif /* STM32F756xx || STM32F777xx || STM32F779xx */
N
N/** @brief  Force or release AHB3 peripheral reset
N  */ 
N#define __HAL_RCC_AHB3_FORCE_RESET()   (RCC->AHB3RSTR = 0xFFFFFFFFU) 
N#define __HAL_RCC_FMC_FORCE_RESET()    (RCC->AHB3RSTR |= (RCC_AHB3RSTR_FMCRST))
N#define __HAL_RCC_QSPI_FORCE_RESET()   (RCC->AHB3RSTR |= (RCC_AHB3RSTR_QSPIRST))
N
N#define __HAL_RCC_AHB3_RELEASE_RESET() (RCC->AHB3RSTR = 0x00U)
N#define __HAL_RCC_FMC_RELEASE_RESET()  (RCC->AHB3RSTR &= ~(RCC_AHB3RSTR_FMCRST))
N#define __HAL_RCC_QSPI_RELEASE_RESET() (RCC->AHB3RSTR &= ~(RCC_AHB3RSTR_QSPIRST))
N 
N/** @brief  Force or release APB1 peripheral reset.
N  */ 
N#define __HAL_RCC_TIM2_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM2RST))
N#define __HAL_RCC_TIM3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM3RST))
N#define __HAL_RCC_TIM4_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM4RST))
N#define __HAL_RCC_TIM5_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM5RST))
N#define __HAL_RCC_TIM6_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM6RST))
N#define __HAL_RCC_TIM7_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM7RST))
N#define __HAL_RCC_TIM12_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM12RST))
N#define __HAL_RCC_TIM13_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM13RST))
N#define __HAL_RCC_TIM14_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM14RST))
N#define __HAL_RCC_LPTIM1_FORCE_RESET()   (RCC->APB1RSTR |= (RCC_APB1RSTR_LPTIM1RST))
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N#define __HAL_RCC_CAN3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_CAN3RST))
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N#define __HAL_RCC_SPI2_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_SPI2RST))
N#define __HAL_RCC_SPI3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_SPI3RST))
N#define __HAL_RCC_SPDIFRX_FORCE_RESET()  (RCC->APB1RSTR |= (RCC_APB1RSTR_SPDIFRXRST))
N#define __HAL_RCC_USART2_FORCE_RESET()   (RCC->APB1RSTR |= (RCC_APB1RSTR_USART2RST))
N#define __HAL_RCC_USART3_FORCE_RESET()   (RCC->APB1RSTR |= (RCC_APB1RSTR_USART3RST))
N#define __HAL_RCC_UART4_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_UART4RST))
N#define __HAL_RCC_UART5_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_UART5RST))
N#define __HAL_RCC_I2C1_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_I2C1RST))
N#define __HAL_RCC_I2C2_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_I2C2RST))
N#define __HAL_RCC_I2C3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_I2C3RST))
N#define __HAL_RCC_I2C4_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_I2C4RST))
N#define __HAL_RCC_CAN1_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_CAN1RST))
N#define __HAL_RCC_CAN2_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_CAN2RST))
N#define __HAL_RCC_CEC_FORCE_RESET()      (RCC->APB1RSTR |= (RCC_APB1RSTR_CECRST))
N#define __HAL_RCC_DAC_FORCE_RESET()      (RCC->APB1RSTR |= (RCC_APB1RSTR_DACRST))
N#define __HAL_RCC_UART7_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_UART7RST))
N#define __HAL_RCC_UART8_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_UART8RST))
N
N#define __HAL_RCC_TIM2_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM2RST))
N#define __HAL_RCC_TIM3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM3RST))
N#define __HAL_RCC_TIM4_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM4RST))
N#define __HAL_RCC_TIM5_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM5RST))
N#define __HAL_RCC_TIM6_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM6RST))
N#define __HAL_RCC_TIM7_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM7RST))
N#define __HAL_RCC_TIM12_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM12RST))
N#define __HAL_RCC_TIM13_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM13RST))
N#define __HAL_RCC_TIM14_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM14RST))
N#define __HAL_RCC_LPTIM1_RELEASE_RESET() (RCC->APB1RSTR &= ~(RCC_APB1RSTR_LPTIM1RST))
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N#define __HAL_RCC_CAN3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_CAN3RST))
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N#define __HAL_RCC_SPI2_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_SPI2RST))
N#define __HAL_RCC_SPI3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_SPI3RST))
N#define __HAL_RCC_SPDIFRX_RELEASE_RESET()(RCC->APB1RSTR &= ~(RCC_APB1RSTR_SPDIFRXRST))
N#define __HAL_RCC_USART2_RELEASE_RESET() (RCC->APB1RSTR &= ~(RCC_APB1RSTR_USART2RST))
N#define __HAL_RCC_USART3_RELEASE_RESET() (RCC->APB1RSTR &= ~(RCC_APB1RSTR_USART3RST))
N#define __HAL_RCC_UART4_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_UART4RST))
N#define __HAL_RCC_UART5_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_UART5RST))
N#define __HAL_RCC_I2C1_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_I2C1RST))
N#define __HAL_RCC_I2C2_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_I2C2RST))
N#define __HAL_RCC_I2C3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_I2C3RST))
N#define __HAL_RCC_I2C4_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_I2C4RST))
N#define __HAL_RCC_CAN1_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_CAN1RST))
N#define __HAL_RCC_CAN2_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_CAN2RST))
N#define __HAL_RCC_CEC_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_CECRST))
N#define __HAL_RCC_DAC_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_DACRST))
N#define __HAL_RCC_UART7_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_UART7RST))
N#define __HAL_RCC_UART8_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_UART8RST))
N
N/** @brief  Force or release APB2 peripheral reset.
N  */
N#define __HAL_RCC_TIM1_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM1RST))
N#define __HAL_RCC_TIM8_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM8RST))
N#define __HAL_RCC_USART1_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_USART1RST))
N#define __HAL_RCC_USART6_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_USART6RST))
N#define __HAL_RCC_ADC_FORCE_RESET()      (RCC->APB2RSTR |= (RCC_APB2RSTR_ADCRST))
N#define __HAL_RCC_SDMMC1_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_SDMMC1RST))
N#define __HAL_RCC_SPI1_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SPI1RST))
N#define __HAL_RCC_SPI4_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SPI4RST))
N#define __HAL_RCC_TIM9_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM9RST))
N#define __HAL_RCC_TIM10_FORCE_RESET()    (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM10RST))
N#define __HAL_RCC_TIM11_FORCE_RESET()    (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM11RST))
N#define __HAL_RCC_SPI5_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SPI5RST))
N#define __HAL_RCC_SPI6_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SPI6RST))
N#define __HAL_RCC_SAI1_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SAI1RST))
N#define __HAL_RCC_SAI2_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SAI2RST))
N#if defined (STM32F746xx) || defined (STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 0L || 1L || 0L || 0L || 0L
N#define __HAL_RCC_LTDC_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_LTDCRST))
N#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N
N#define __HAL_RCC_TIM1_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM1RST))
N#define __HAL_RCC_TIM8_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM8RST))
N#define __HAL_RCC_USART1_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_USART1RST))
N#define __HAL_RCC_USART6_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_USART6RST))
N#define __HAL_RCC_ADC_RELEASE_RESET()    (RCC->APB2RSTR &= ~(RCC_APB2RSTR_ADCRST))
N#define __HAL_RCC_SDMMC1_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SDMMC1RST))
N#define __HAL_RCC_SPI1_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SPI1RST))
N#define __HAL_RCC_SPI4_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SPI4RST))
N#define __HAL_RCC_TIM9_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM9RST))
N#define __HAL_RCC_TIM10_RELEASE_RESET()  (RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM10RST))
N#define __HAL_RCC_TIM11_RELEASE_RESET()  (RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM11RST))
N#define __HAL_RCC_SPI5_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SPI5RST))
N#define __HAL_RCC_SPI6_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SPI6RST))
N#define __HAL_RCC_SAI1_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SAI1RST))
N#define __HAL_RCC_SAI2_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SAI2RST))
N#if defined (STM32F746xx) || defined (STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 0L || 1L || 0L || 0L || 0L
N#define __HAL_RCC_LTDC_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_LTDCRST))
N#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N
N#if defined (STM32F769xx) || defined (STM32F779xx)
X#if 0L || 0L
S#define __HAL_RCC_DSI_FORCE_RESET()      (RCC->APB2RSTR |= (RCC_APB2RSTR_DSIRST))
S#define __HAL_RCC_DSI_RELEASE_RESET()    (RCC->APB2RSTR &= ~(RCC_APB2RSTR_DSIRST))
N#endif /* STM32F769xx || STM32F779xx */
N
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N#define __HAL_RCC_SDMMC2_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_SDMMC2RST))
N#define __HAL_RCC_DFSDM1_FORCE_RESET()    (RCC->APB2RSTR |= (RCC_APB2RSTR_DFSDM1RST))
N#define __HAL_RCC_MDIO_FORCE_RESET()    (RCC->APB2RSTR |= (RCC_APB2RSTR_MDIORST))
N
N#define __HAL_RCC_SDMMC2_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SDMMC2RST))
N#define __HAL_RCC_DFSDM1_RELEASE_RESET()  (RCC->APB2RSTR &= ~(RCC_APB2RSTR_DFSDM1RST))
N#define __HAL_RCC_MDIO_RELEASE_RESET()  (RCC->APB2RSTR &= ~(RCC_APB2RSTR_MDIORST))
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N/**
N  * @}
N  */ 
N
N/** @defgroup RCCEx_Peripheral_Clock_Sleep_Enable_Disable RCCEx Peripheral Clock Sleep Enable Disable
N  * @brief  Enables or disables the AHB/APB peripheral clock during Low Power (Sleep) mode.
N  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
N  *         power consumption.
N  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
N  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
N  * @{
N  */ 
N  
N/** @brief  Enable or disable the AHB1 peripheral clock during Low Power (Sleep) mode.
N  */ 
N#define __HAL_RCC_FLITF_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_FLITFLPEN))
N#define __HAL_RCC_AXI_CLK_SLEEP_ENABLE()        (RCC->AHB1LPENR |= (RCC_AHB1LPENR_AXILPEN))
N#define __HAL_RCC_SRAM1_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_SRAM1LPEN))
N#define __HAL_RCC_SRAM2_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_SRAM2LPEN))
N#define __HAL_RCC_BKPSRAM_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_BKPSRAMLPEN))
N#define __HAL_RCC_DTCM_CLK_SLEEP_ENABLE()       (RCC->AHB1LPENR |= (RCC_AHB1LPENR_DTCMLPEN))
N#define __HAL_RCC_DMA2_CLK_SLEEP_ENABLE()       (RCC->AHB1LPENR |= (RCC_AHB1LPENR_DMA2LPEN))
N#define __HAL_RCC_DMA2D_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_DMA2DLPEN))
N#define __HAL_RCC_ETHMAC_CLK_SLEEP_ENABLE()     (RCC->AHB1LPENR |= (RCC_AHB1LPENR_ETHMACLPEN))
N#define __HAL_RCC_ETHMACTX_CLK_SLEEP_ENABLE()   (RCC->AHB1LPENR |= (RCC_AHB1LPENR_ETHMACTXLPEN))
N#define __HAL_RCC_ETHMACRX_CLK_SLEEP_ENABLE()   (RCC->AHB1LPENR |= (RCC_AHB1LPENR_ETHMACRXLPEN))
N#define __HAL_RCC_ETHMACPTP_CLK_SLEEP_ENABLE()  (RCC->AHB1LPENR |= (RCC_AHB1LPENR_ETHMACPTPLPEN))
N#define __HAL_RCC_USB_OTG_HS_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_OTGHSLPEN))
N#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_ENABLE() (RCC->AHB1LPENR |= (RCC_AHB1LPENR_OTGHSULPILPEN))
N#define __HAL_RCC_GPIOA_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOALPEN))
N#define __HAL_RCC_GPIOB_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOBLPEN))
N#define __HAL_RCC_GPIOC_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOCLPEN))
N#define __HAL_RCC_GPIOD_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIODLPEN))
N#define __HAL_RCC_GPIOE_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOELPEN))
N#define __HAL_RCC_GPIOF_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOFLPEN))
N#define __HAL_RCC_GPIOG_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOGLPEN))
N#define __HAL_RCC_GPIOH_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOHLPEN))
N#define __HAL_RCC_GPIOI_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOILPEN))
N#define __HAL_RCC_GPIOJ_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOJLPEN))
N#define __HAL_RCC_GPIOK_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOKLPEN))
N
N#define __HAL_RCC_FLITF_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_FLITFLPEN))
N#define __HAL_RCC_AXI_CLK_SLEEP_DISABLE()       (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_AXILPEN))
N#define __HAL_RCC_SRAM1_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_SRAM1LPEN))
N#define __HAL_RCC_SRAM2_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_SRAM2LPEN))
N#define __HAL_RCC_BKPSRAM_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_BKPSRAMLPEN))
N#define __HAL_RCC_DTCM_CLK_SLEEP_DISABLE()      (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_DTCMLPEN))
N#define __HAL_RCC_DMA2_CLK_SLEEP_DISABLE()      (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_DMA2LPEN))
N#define __HAL_RCC_DMA2D_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_DMA2DLPEN))
N#define __HAL_RCC_ETHMAC_CLK_SLEEP_DISABLE()    (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_ETHMACLPEN))
N#define __HAL_RCC_ETHMACTX_CLK_SLEEP_DISABLE()  (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_ETHMACTXLPEN))
N#define __HAL_RCC_ETHMACRX_CLK_SLEEP_DISABLE()  (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_ETHMACRXLPEN))
N#define __HAL_RCC_ETHMACPTP_CLK_SLEEP_DISABLE() (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_ETHMACPTPLPEN))
N#define __HAL_RCC_USB_OTG_HS_CLK_SLEEP_DISABLE()      (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_OTGHSLPEN))
N#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_DISABLE() (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_OTGHSULPILPEN))
N#define __HAL_RCC_GPIOA_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOALPEN))
N#define __HAL_RCC_GPIOB_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOBLPEN))
N#define __HAL_RCC_GPIOC_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOCLPEN))
N#define __HAL_RCC_GPIOD_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIODLPEN))
N#define __HAL_RCC_GPIOE_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOELPEN))
N#define __HAL_RCC_GPIOF_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOFLPEN))
N#define __HAL_RCC_GPIOG_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOGLPEN))
N#define __HAL_RCC_GPIOH_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOHLPEN))
N#define __HAL_RCC_GPIOI_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOILPEN))
N#define __HAL_RCC_GPIOJ_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOJLPEN))
N#define __HAL_RCC_GPIOK_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOKLPEN))
N
N/** @brief  Enable or disable the AHB2 peripheral clock during Low Power (Sleep) mode.
N  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
N  *         power consumption.
N  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
N  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
N  */
N#define __HAL_RCC_DCMI_CLK_SLEEP_ENABLE()        (RCC->AHB2LPENR |= (RCC_AHB2LPENR_DCMILPEN))
N#define __HAL_RCC_DCMI_CLK_SLEEP_DISABLE()       (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_DCMILPEN))
N
N#if defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 1L || 0L || 0L || 0L
N#define __HAL_RCC_JPEG_CLK_SLEEP_ENABLE()        (RCC->AHB2LPENR |= (RCC_AHB2LPENR_JPEGLPEN))
N#define __HAL_RCC_JPEG_CLK_SLEEP_DISABLE()       (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_JPEGLPEN))
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N
N#define __HAL_RCC_RNG_CLK_SLEEP_ENABLE()         (RCC->AHB2LPENR |= (RCC_AHB2LPENR_RNGLPEN))
N#define __HAL_RCC_RNG_CLK_SLEEP_DISABLE()        (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_RNGLPEN))
N
N#define __HAL_RCC_USB_OTG_FS_CLK_SLEEP_ENABLE()  (RCC->AHB2LPENR |= (RCC_AHB2LPENR_OTGFSLPEN))
N#define __HAL_RCC_USB_OTG_FS_CLK_SLEEP_DISABLE() (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_OTGFSLPEN))
N
N#if defined(STM32F756xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 0L || 0L
S#define __HAL_RCC_CRYP_CLK_SLEEP_ENABLE()        (RCC->AHB2LPENR |= (RCC_AHB2LPENR_CRYPLPEN))
S#define __HAL_RCC_HASH_CLK_SLEEP_ENABLE()        (RCC->AHB2LPENR |= (RCC_AHB2LPENR_HASHLPEN))
S                                         
S#define __HAL_RCC_CRYP_CLK_SLEEP_DISABLE()       (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_CRYPLPEN))
S#define __HAL_RCC_HASH_CLK_SLEEP_DISABLE()       (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_HASHLPEN))
N#endif /* STM32F756xx || STM32F777xx || STM32F779xx */
N
N/** @brief  Enable or disable the AHB3 peripheral clock during Low Power (Sleep) mode.
N  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
N  *         power consumption.
N  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
N  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
N  */
N#define __HAL_RCC_FMC_CLK_SLEEP_ENABLE()  (RCC->AHB3LPENR |= (RCC_AHB3LPENR_FMCLPEN))
N#define __HAL_RCC_FMC_CLK_SLEEP_DISABLE() (RCC->AHB3LPENR &= ~(RCC_AHB3LPENR_FMCLPEN))
N
N#define __HAL_RCC_QSPI_CLK_SLEEP_ENABLE()  (RCC->AHB3LPENR |= (RCC_AHB3LPENR_QSPILPEN))
N#define __HAL_RCC_QSPI_CLK_SLEEP_DISABLE() (RCC->AHB3LPENR &= ~(RCC_AHB3LPENR_QSPILPEN))
N
N/** @brief  Enable or disable the APB1 peripheral clock during Low Power (Sleep) mode.
N  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
N  *         power consumption.
N  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
N  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
N  */  
N#define __HAL_RCC_TIM2_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM2LPEN))
N#define __HAL_RCC_TIM3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM3LPEN))
N#define __HAL_RCC_TIM4_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM4LPEN))
N#define __HAL_RCC_TIM5_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM5LPEN))
N#define __HAL_RCC_TIM6_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM6LPEN))
N#define __HAL_RCC_TIM7_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM7LPEN))
N#define __HAL_RCC_TIM12_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM12LPEN))
N#define __HAL_RCC_TIM13_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM13LPEN))
N#define __HAL_RCC_TIM14_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM14LPEN))
N#define __HAL_RCC_LPTIM1_CLK_SLEEP_ENABLE()  (RCC->APB1LPENR |= (RCC_APB1LPENR_LPTIM1LPEN))
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N#define __HAL_RCC_RTC_CLK_SLEEP_ENABLE()     (RCC->APB1LPENR |= (RCC_APB1LPENR_RTCLPEN))
N#define __HAL_RCC_CAN3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_CAN3LPEN))
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N#define __HAL_RCC_SPI2_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_SPI2LPEN))
N#define __HAL_RCC_SPI3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_SPI3LPEN))
N#define __HAL_RCC_SPDIFRX_CLK_SLEEP_ENABLE() (RCC->APB1LPENR |= (RCC_APB1LPENR_SPDIFRXLPEN))
N#define __HAL_RCC_USART2_CLK_SLEEP_ENABLE()  (RCC->APB1LPENR |= (RCC_APB1LPENR_USART2LPEN))
N#define __HAL_RCC_USART3_CLK_SLEEP_ENABLE()  (RCC->APB1LPENR |= (RCC_APB1LPENR_USART3LPEN))
N#define __HAL_RCC_UART4_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_UART4LPEN))
N#define __HAL_RCC_UART5_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_UART5LPEN))
N#define __HAL_RCC_I2C1_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_I2C1LPEN))
N#define __HAL_RCC_I2C2_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_I2C2LPEN))
N#define __HAL_RCC_I2C3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_I2C3LPEN))
N#define __HAL_RCC_I2C4_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_I2C4LPEN))
N#define __HAL_RCC_CAN1_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_CAN1LPEN))
N#define __HAL_RCC_CAN2_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_CAN2LPEN))
N#define __HAL_RCC_CEC_CLK_SLEEP_ENABLE()     (RCC->APB1LPENR |= (RCC_APB1LPENR_CECLPEN))
N#define __HAL_RCC_DAC_CLK_SLEEP_ENABLE()     (RCC->APB1LPENR |= (RCC_APB1LPENR_DACLPEN))
N#define __HAL_RCC_UART7_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_UART7LPEN))
N#define __HAL_RCC_UART8_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_UART8LPEN))
N
N#define __HAL_RCC_TIM2_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM2LPEN))
N#define __HAL_RCC_TIM3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM3LPEN))
N#define __HAL_RCC_TIM4_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM4LPEN))
N#define __HAL_RCC_TIM5_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM5LPEN))
N#define __HAL_RCC_TIM6_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM6LPEN))
N#define __HAL_RCC_TIM7_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM7LPEN))
N#define __HAL_RCC_TIM12_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM12LPEN))
N#define __HAL_RCC_TIM13_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM13LPEN))
N#define __HAL_RCC_TIM14_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM14LPEN))
N#define __HAL_RCC_LPTIM1_CLK_SLEEP_DISABLE() (RCC->APB1LPENR &= ~(RCC_APB1LPENR_LPTIM1LPEN))
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N#define __HAL_RCC_RTC_CLK_SLEEP_DISABLE()    (RCC->APB1LPENR &= ~(RCC_APB1LPENR_RTCLPEN))
N#define __HAL_RCC_CAN3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_CAN3LPEN))
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N#define __HAL_RCC_SPI2_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_SPI2LPEN))
N#define __HAL_RCC_SPI3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_SPI3LPEN))
N#define __HAL_RCC_SPDIFRX_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_SPDIFRXLPEN))
N#define __HAL_RCC_USART2_CLK_SLEEP_DISABLE() (RCC->APB1LPENR &= ~(RCC_APB1LPENR_USART2LPEN))
N#define __HAL_RCC_USART3_CLK_SLEEP_DISABLE() (RCC->APB1LPENR &= ~(RCC_APB1LPENR_USART3LPEN))
N#define __HAL_RCC_UART4_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_UART4LPEN))
N#define __HAL_RCC_UART5_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_UART5LPEN))
N#define __HAL_RCC_I2C1_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_I2C1LPEN))
N#define __HAL_RCC_I2C2_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_I2C2LPEN))
N#define __HAL_RCC_I2C3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_I2C3LPEN))
N#define __HAL_RCC_I2C4_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_I2C4LPEN))
N#define __HAL_RCC_CAN1_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_CAN1LPEN))
N#define __HAL_RCC_CAN2_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_CAN2LPEN))
N#define __HAL_RCC_CEC_CLK_SLEEP_DISABLE()    (RCC->APB1LPENR &= ~(RCC_APB1LPENR_CECLPEN))
N#define __HAL_RCC_DAC_CLK_SLEEP_DISABLE()    (RCC->APB1LPENR &= ~(RCC_APB1LPENR_DACLPEN))
N#define __HAL_RCC_UART7_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_UART7LPEN))
N#define __HAL_RCC_UART8_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_UART8LPEN))
N
N/** @brief  Enable or disable the APB2 peripheral clock during Low Power (Sleep) mode.
N  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
N  *         power consumption.
N  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
N  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
N  */ 
N#define __HAL_RCC_TIM1_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_TIM1LPEN))
N#define __HAL_RCC_TIM8_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_TIM8LPEN))
N#define __HAL_RCC_USART1_CLK_SLEEP_ENABLE()  (RCC->APB2LPENR |= (RCC_APB2LPENR_USART1LPEN))
N#define __HAL_RCC_USART6_CLK_SLEEP_ENABLE()  (RCC->APB2LPENR |= (RCC_APB2LPENR_USART6LPEN))
N#define __HAL_RCC_ADC1_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_ADC1LPEN))
N#define __HAL_RCC_ADC2_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_ADC2LPEN))
N#define __HAL_RCC_ADC3_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_ADC3LPEN))
N#define __HAL_RCC_SDMMC1_CLK_SLEEP_ENABLE()  (RCC->APB2LPENR |= (RCC_APB2LPENR_SDMMC1LPEN))
N#define __HAL_RCC_SPI1_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_SPI1LPEN))
N#define __HAL_RCC_SPI4_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_SPI4LPEN))
N#define __HAL_RCC_TIM9_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_TIM9LPEN))
N#define __HAL_RCC_TIM10_CLK_SLEEP_ENABLE()   (RCC->APB2LPENR |= (RCC_APB2LPENR_TIM10LPEN))
N#define __HAL_RCC_TIM11_CLK_SLEEP_ENABLE()   (RCC->APB2LPENR |= (RCC_APB2LPENR_TIM11LPEN))
N#define __HAL_RCC_SPI5_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_SPI5LPEN))
N#define __HAL_RCC_SPI6_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_SPI6LPEN))
N#define __HAL_RCC_SAI1_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_SAI1LPEN))
N#define __HAL_RCC_SAI2_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_SAI2LPEN))
N#if defined (STM32F746xx) || defined (STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 0L || 1L || 0L || 0L || 0L
N#define __HAL_RCC_LTDC_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_LTDCLPEN))
N#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N
N#define __HAL_RCC_TIM1_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM1LPEN))
N#define __HAL_RCC_TIM8_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM8LPEN))
N#define __HAL_RCC_USART1_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_USART1LPEN))
N#define __HAL_RCC_USART6_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_USART6LPEN))
N#define __HAL_RCC_ADC1_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_ADC1LPEN))
N#define __HAL_RCC_ADC2_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_ADC2LPEN))
N#define __HAL_RCC_ADC3_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_ADC3LPEN))
N#define __HAL_RCC_SDMMC1_CLK_SLEEP_DISABLE()  (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SDMMC1LPEN))
N#define __HAL_RCC_SPI1_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SPI1LPEN))
N#define __HAL_RCC_SPI4_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SPI4LPEN))
N#define __HAL_RCC_TIM9_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM9LPEN))
N#define __HAL_RCC_TIM10_CLK_SLEEP_DISABLE()  (RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM10LPEN))
N#define __HAL_RCC_TIM11_CLK_SLEEP_DISABLE()  (RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM11LPEN))
N#define __HAL_RCC_SPI5_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SPI5LPEN))
N#define __HAL_RCC_SPI6_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SPI6LPEN))
N#define __HAL_RCC_SAI1_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SAI1LPEN))
N#define __HAL_RCC_SAI2_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SAI2LPEN))
N#if defined (STM32F746xx) || defined (STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 0L || 1L || 0L || 0L || 0L
N#define __HAL_RCC_LTDC_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_LTDCLPEN))
N#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N#if defined (STM32F769xx) || defined (STM32F779xx)
X#if 0L || 0L
S#define __HAL_RCC_DSI_CLK_SLEEP_ENABLE()     (RCC->APB2LPENR |= (RCC_APB2LPENR_DSILPEN))
S#define __HAL_RCC_DSI_CLK_SLEEP_DISABLE()    (RCC->APB2LPENR &= ~(RCC_APB2LPENR_DSILPEN))
N#endif /* STM32F769xx || STM32F779xx */
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N#define __HAL_RCC_SDMMC2_CLK_SLEEP_ENABLE()  (RCC->APB2LPENR |= (RCC_APB2LPENR_SDMMC2LPEN))
N#define __HAL_RCC_DFSDM1_CLK_SLEEP_ENABLE()   (RCC->APB2LPENR |= (RCC_APB2LPENR_DFSDM1LPEN))
N#define __HAL_RCC_MDIO_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_MDIOLPEN))
N
N#define __HAL_RCC_SDMMC2_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SDMMC2LPEN))
N#define __HAL_RCC_DFSDM1_CLK_SLEEP_DISABLE()  (RCC->APB2LPENR &= ~(RCC_APB2LPENR_DFSDM1LPEN))
N#define __HAL_RCC_MDIO_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_MDIOLPEN))
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_Clock_Sleep_Enable_Disable_Status AHB/APB Peripheral Clock Sleep Enable Disable Status
N  * @brief  Get the enable or disable status of the AHB/APB peripheral clock during Low Power (Sleep) mode.
N  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
N  *         power consumption.
N  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
N  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
N  * @{
N  */
N  
N/** @brief  Get the enable or disable status of the AHB1 peripheral clock during Low Power (Sleep) mode.
N  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
N  *         power consumption.
N  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
N  * @note   By default, all peripheral clocks are enabled during SLEEP mode.  
N  */
N#define __HAL_RCC_FLITF_IS_CLK_SLEEP_ENABLED()      ((RCC->AHB1LPENR & (RCC_AHB1LPENR_FLITFLPEN)) != RESET)
N#define __HAL_RCC_AXI_IS_CLK_SLEEP_ENABLED()        ((RCC->AHB1LPENR & (RCC_AHB1LPENR_AXILPEN)) != RESET)
N#define __HAL_RCC_SRAM1_IS_CLK_SLEEP_ENABLED()      ((RCC->AHB1LPENR & (RCC_AHB1LPENR_SRAM1LPEN)) != RESET)
N#define __HAL_RCC_SRAM2_IS_CLK_SLEEP_ENABLED()      ((RCC->AHB1LPENR & (RCC_AHB1LPENR_SRAM2LPEN)) != RESET)
N#define __HAL_RCC_BKPSRAM_IS_CLK_SLEEP_ENABLED()    ((RCC->AHB1LPENR & (RCC_AHB1LPENR_BKPSRAMLPEN)) != RESET)
N#define __HAL_RCC_DTCM_IS_CLK_SLEEP_ENABLED()       ((RCC->AHB1LPENR & (RCC_AHB1LPENR_DTCMLPEN)) != RESET)
N#define __HAL_RCC_DMA2_IS_CLK_SLEEP_ENABLED()       ((RCC->AHB1LPENR & (RCC_AHB1LPENR_DMA2LPEN)) != RESET)
N#define __HAL_RCC_DMA2D_IS_CLK_SLEEP_ENABLED()      ((RCC->AHB1LPENR & (RCC_AHB1LPENR_DMA2DLPEN)) != RESET)
N#define __HAL_RCC_ETHMAC_IS_CLK_SLEEP_ENABLED()     ((RCC->AHB1LPENR & (RCC_AHB1LPENR_ETHMACLPEN)) != RESET)
N#define __HAL_RCC_ETHMACTX_IS_CLK_SLEEP_ENABLED()   ((RCC->AHB1LPENR & (RCC_AHB1LPENR_ETHMACTXLPEN)) != RESET)
N#define __HAL_RCC_ETHMACRX_IS_CLK_SLEEP_ENABLED()   ((RCC->AHB1LPENR & (RCC_AHB1LPENR_ETHMACRXLPEN)) != RESET)
N#define __HAL_RCC_ETHMACPTP_IS_CLK_SLEEP_ENABLED()  ((RCC->AHB1LPENR & (RCC_AHB1LPENR_ETHMACPTPLPEN)) != RESET)
N#define __HAL_RCC_USB_OTG_HS_IS_CLK_SLEEP_ENABLED() ((RCC->AHB1LPENR & (RCC_AHB1LPENR_OTGHSLPEN)) != RESET)
N#define __HAL_RCC_USB_OTG_HS_ULPI_IS_CLK_SLEEP_ENABLED() ((RCC->AHB1LPENR & (RCC_AHB1LPENR_OTGHSULPILPEN)) != RESET)
N#define __HAL_RCC_GPIOA_IS_CLK_SLEEP_ENABLED()      ((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOALPEN)) != RESET)
N#define __HAL_RCC_GPIOB_IS_CLK_SLEEP_ENABLED()      ((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOBLPEN)) != RESET)
N#define __HAL_RCC_GPIOC_IS_CLK_SLEEP_ENABLED()      ((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOCLPEN)) != RESET)
N#define __HAL_RCC_GPIOD_IS_CLK_SLEEP_ENABLED()      ((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIODLPEN)) != RESET)
N#define __HAL_RCC_GPIOE_IS_CLK_SLEEP_ENABLED()      ((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOELPEN)) != RESET)
N#define __HAL_RCC_GPIOF_IS_CLK_SLEEP_ENABLED()      ((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOFLPEN)) != RESET)
N#define __HAL_RCC_GPIOG_IS_CLK_SLEEP_ENABLED()      ((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOGLPEN)) != RESET)
N#define __HAL_RCC_GPIOH_IS_CLK_SLEEP_ENABLED()      ((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOHLPEN)) != RESET)
N#define __HAL_RCC_GPIOI_IS_CLK_SLEEP_ENABLED()      ((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOILPEN)) != RESET)
N#define __HAL_RCC_GPIOJ_IS_CLK_SLEEP_ENABLED()      ((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOJLPEN)) != RESET)
N#define __HAL_RCC_GPIOK_IS_CLK_SLEEP_ENABLED()      ((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOKLPEN)) != RESET)
N
N#define __HAL_RCC_FLITF_IS_CLK_SLEEP_DISABLED()     ((RCC->AHB1LPENR & (RCC_AHB1LPENR_FLITFLPEN)) == RESET)
N#define __HAL_RCC_AXI_IS_CLK_SLEEP_DISABLED()       ((RCC->AHB1LPENR & (RCC_AHB1LPENR_AXILPEN)) == RESET)
N#define __HAL_RCC_SRAM1_IS_CLK_SLEEP_DISABLED()     ((RCC->AHB1LPENR & (RCC_AHB1LPENR_SRAM1LPEN)) == RESET)
N#define __HAL_RCC_SRAM2_IS_CLK_SLEEP_DISABLED()     ((RCC->AHB1LPENR & (RCC_AHB1LPENR_SRAM2LPEN)) == RESET)
N#define __HAL_RCC_BKPSRAM_IS_CLK_SLEEP_DISABLED()   ((RCC->AHB1LPENR & (RCC_AHB1LPENR_BKPSRAMLPEN)) == RESET)
N#define __HAL_RCC_DTCM_IS_CLK_SLEEP_DISABLED()      ((RCC->AHB1LPENR & (RCC_AHB1LPENR_DTCMLPEN)) == RESET)
N#define __HAL_RCC_DMA2_IS_CLK_SLEEP_DISABLED()      ((RCC->AHB1LPENR & (RCC_AHB1LPENR_DMA2LPEN)) == RESET)
N#define __HAL_RCC_DMA2D_IS_CLK_SLEEP_DISABLED()     ((RCC->AHB1LPENR & (RCC_AHB1LPENR_DMA2DLPEN)) == RESET)
N#define __HAL_RCC_ETHMAC_IS_CLK_SLEEP_DISABLED()    ((RCC->AHB1LPENR & (RCC_AHB1LPENR_ETHMACLPEN)) == RESET)
N#define __HAL_RCC_ETHMACTX_IS_CLK_SLEEP_DISABLED()  ((RCC->AHB1LPENR & (RCC_AHB1LPENR_ETHMACTXLPEN)) == RESET)
N#define __HAL_RCC_ETHMACRX_IS_CLK_SLEEP_DISABLED()  ((RCC->AHB1LPENR & (RCC_AHB1LPENR_ETHMACRXLPEN)) == RESET)
N#define __HAL_RCC_ETHMACPTP_IS_CLK_SLEEP_DISABLED() ((RCC->AHB1LPENR & (RCC_AHB1LPENR_ETHMACPTPLPEN)) == RESET)
N#define __HAL_RCC_USB_OTG_HS_IS_CLK_SLEEP_DISABLED() ((RCC->AHB1LPENR & (RCC_AHB1LPENR_OTGHSLPEN)) == RESET)
N#define __HAL_RCC_USB_OTG_HS_ULPI_IS_CLK_SLEEP_DISABLED() ((RCC->AHB1LPENR & (RCC_AHB1LPENR_OTGHSULPILPEN)) == RESET)
N#define __HAL_RCC_GPIOA_IS_CLK_SLEEP_DISABLED()     ((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOALPEN)) == RESET)
N#define __HAL_RCC_GPIOB_IS_CLK_SLEEP_DISABLED()     ((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOBLPEN)) == RESET)
N#define __HAL_RCC_GPIOC_IS_CLK_SLEEP_DISABLED()     ((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOCLPEN)) == RESET)
N#define __HAL_RCC_GPIOD_IS_CLK_SLEEP_DISABLED()     ((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIODLPEN)) == RESET)
N#define __HAL_RCC_GPIOE_IS_CLK_SLEEP_DISABLED()     ((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOELPEN)) == RESET)
N#define __HAL_RCC_GPIOF_IS_CLK_SLEEP_DISABLED()     ((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOFLPEN)) == RESET)
N#define __HAL_RCC_GPIOG_IS_CLK_SLEEP_DISABLED()     ((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOGLPEN)) == RESET)
N#define __HAL_RCC_GPIOH_IS_CLK_SLEEP_DISABLED()     ((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOHLPEN)) == RESET)
N#define __HAL_RCC_GPIOI_IS_CLK_SLEEP_DISABLED()     ((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOILPEN)) == RESET)
N#define __HAL_RCC_GPIOJ_IS_CLK_SLEEP_DISABLED()     ((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOJLPEN)) == RESET)
N#define __HAL_RCC_GPIOK_IS_CLK_SLEEP_DISABLED()     ((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOKLPEN)) == RESET)
N
N/** @brief  Get the enable or disable status of the AHB2 peripheral clock during Low Power (Sleep) mode.
N  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
N  *         power consumption.
N  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
N  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
N  */
N#define __HAL_RCC_DCMI_IS_CLK_SLEEP_ENABLED()        ((RCC->AHB2LPENR & (RCC_AHB2LPENR_DCMILPEN)) != RESET)
N#define __HAL_RCC_DCMI_IS_CLK_SLEEP_DISABLED()       ((RCC->AHB2LPENR & (RCC_AHB2LPENR_DCMILPEN)) == RESET)
N
N#if defined(STM32F767xx) || defined(STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) 
X#if 1L || 0L || 0L || 0L 
N#define __HAL_RCC_JPEG_IS_CLK_SLEEP_ENABLED()        ((RCC->AHB2LPENR & (RCC_AHB2LPENR_JPEGLPEN)) != RESET)
N#define __HAL_RCC_JPEG_IS_CLK_SLEEP_DISABLED()       ((RCC->AHB2LPENR & (RCC_AHB2LPENR_JPEGLPEN)) == RESET)
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N                                         
N#define __HAL_RCC_RNG_IS_CLK_SLEEP_ENABLED()         ((RCC->AHB2LPENR & (RCC_AHB2LPENR_RNGLPEN)) != RESET)
N#define __HAL_RCC_RNG_IS_CLK_SLEEP_DISABLED()        ((RCC->AHB2LPENR & (RCC_AHB2LPENR_RNGLPEN)) == RESET)
N
N#define __HAL_RCC_USB_OTG_FS_IS_CLK_SLEEP_ENABLED()  ((RCC->AHB2LPENR & (RCC_AHB2LPENR_OTGFSLPEN)) != RESET)
N#define __HAL_RCC_USB_OTG_FS_IS_CLK_SLEEP_DISABLED() ((RCC->AHB2LPENR & (RCC_AHB2LPENR_OTGFSLPEN)) == RESET)
N
N#if defined(STM32F756xx) || defined (STM32F777xx) || defined (STM32F779xx) 
X#if 0L || 0L || 0L 
S#define __HAL_RCC_CRYP_IS_CLK_SLEEP_ENABLED()        ((RCC->AHB2LPENR & (RCC_AHB2LPENR_CRYPLPEN)) != RESET)
S#define __HAL_RCC_HASH_IS_CLK_SLEEP_ENABLED()        ((RCC->AHB2LPENR & (RCC_AHB2LPENR_HASHLPEN)) != RESET)
S                                         
S#define __HAL_RCC_CRYP_IS_CLK_SLEEP_DISABLED()       ((RCC->AHB2LPENR & (RCC_AHB2LPENR_CRYPLPEN)) == RESET)
S#define __HAL_RCC_HASH_IS_CLK_SLEEP_DISABLED()       ((RCC->AHB2LPENR & (RCC_AHB2LPENR_HASHLPEN)) == RESET)
N#endif /* STM32F756xx || STM32F777xx || STM32F779xx */
N
N/** @brief  Get the enable or disable status of the AHB3 peripheral clock during Low Power (Sleep) mode.
N  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
N  *         power consumption.
N  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
N  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
N  */
N#define __HAL_RCC_FMC_IS_CLK_SLEEP_ENABLED()  ((RCC->AHB3LPENR & (RCC_AHB3LPENR_FMCLPEN)) != RESET)
N#define __HAL_RCC_FMC_IS_CLK_SLEEP_DISABLED() ((RCC->AHB3LPENR & (RCC_AHB3LPENR_FMCLPEN)) == RESET)
N
N#define __HAL_RCC_QSPI_IS_CLK_SLEEP_ENABLED()  ((RCC->AHB3LPENR & (RCC_AHB3LPENR_QSPILPEN)) != RESET)
N#define __HAL_RCC_QSPI_IS_CLK_SLEEP_DISABLED() ((RCC->AHB3LPENR & (RCC_AHB3LPENR_QSPILPEN)) == RESET)
N
N/** @brief  Get the enable or disable status of the APB1 peripheral clock during Low Power (Sleep) mode.
N  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
N  *         power consumption.
N  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
N  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
N  */  
N#define __HAL_RCC_TIM2_IS_CLK_SLEEP_ENABLED()    ((RCC->APB1LPENR & (RCC_APB1LPENR_TIM2LPEN)) != RESET)
N#define __HAL_RCC_TIM3_IS_CLK_SLEEP_ENABLED()    ((RCC->APB1LPENR & (RCC_APB1LPENR_TIM3LPEN)) != RESET)
N#define __HAL_RCC_TIM4_IS_CLK_SLEEP_ENABLED()    ((RCC->APB1LPENR & (RCC_APB1LPENR_TIM4LPEN)) != RESET)
N#define __HAL_RCC_TIM5_IS_CLK_SLEEP_ENABLED()    ((RCC->APB1LPENR & (RCC_APB1LPENR_TIM5LPEN)) != RESET)
N#define __HAL_RCC_TIM6_IS_CLK_SLEEP_ENABLED()    ((RCC->APB1LPENR & (RCC_APB1LPENR_TIM6LPEN)) != RESET)
N#define __HAL_RCC_TIM7_IS_CLK_SLEEP_ENABLED()    ((RCC->APB1LPENR & (RCC_APB1LPENR_TIM7LPEN)) != RESET)
N#define __HAL_RCC_TIM12_IS_CLK_SLEEP_ENABLED()   ((RCC->APB1LPENR & (RCC_APB1LPENR_TIM12LPEN)) != RESET)
N#define __HAL_RCC_TIM13_IS_CLK_SLEEP_ENABLED()   ((RCC->APB1LPENR & (RCC_APB1LPENR_TIM13LPEN)) != RESET)
N#define __HAL_RCC_TIM14_IS_CLK_SLEEP_ENABLED()   ((RCC->APB1LPENR & (RCC_APB1LPENR_TIM14LPEN)) != RESET)
N#define __HAL_RCC_LPTIM1_IS_CLK_SLEEP_ENABLED()  ((RCC->APB1LPENR & (RCC_APB1LPENR_LPTIM1LPEN)) != RESET)
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N#define __HAL_RCC_RTC_IS_CLK_SLEEP_ENABLED()     ((RCC->APB1LPENR & (RCC_APB1LPENR_RTCLPEN)) != RESET)
N#define __HAL_RCC_CAN3_IS_CLK_SLEEP_ENABLED()    ((RCC->APB1LPENR & (RCC_APB1LPENR_CAN3LPEN)) != RESET)
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N#define __HAL_RCC_SPI2_IS_CLK_SLEEP_ENABLED()    ((RCC->APB1LPENR & (RCC_APB1LPENR_SPI2LPEN)) != RESET)
N#define __HAL_RCC_SPI3_IS_CLK_SLEEP_ENABLED()    ((RCC->APB1LPENR & (RCC_APB1LPENR_SPI3LPEN)) != RESET)
N#define __HAL_RCC_SPDIFRX_IS_CLK_SLEEP_ENABLED() ((RCC->APB1LPENR & (RCC_APB1LPENR_SPDIFRXLPEN)) != RESET)
N#define __HAL_RCC_USART2_IS_CLK_SLEEP_ENABLED()  ((RCC->APB1LPENR & (RCC_APB1LPENR_USART2LPEN)) != RESET)
N#define __HAL_RCC_USART3_IS_CLK_SLEEP_ENABLED()  ((RCC->APB1LPENR & (RCC_APB1LPENR_USART3LPEN)) != RESET)
N#define __HAL_RCC_UART4_IS_CLK_SLEEP_ENABLED()   ((RCC->APB1LPENR & (RCC_APB1LPENR_UART4LPEN)) != RESET)
N#define __HAL_RCC_UART5_IS_CLK_SLEEP_ENABLED()   ((RCC->APB1LPENR & (RCC_APB1LPENR_UART5LPEN)) != RESET)
N#define __HAL_RCC_I2C1_IS_CLK_SLEEP_ENABLED()    ((RCC->APB1LPENR & (RCC_APB1LPENR_I2C1LPEN)) != RESET)
N#define __HAL_RCC_I2C2_IS_CLK_SLEEP_ENABLED()    ((RCC->APB1LPENR & (RCC_APB1LPENR_I2C2LPEN)) != RESET)
N#define __HAL_RCC_I2C3_IS_CLK_SLEEP_ENABLED()    ((RCC->APB1LPENR & (RCC_APB1LPENR_I2C3LPEN)) != RESET)
N#define __HAL_RCC_I2C4_IS_CLK_SLEEP_ENABLED()    ((RCC->APB1LPENR & (RCC_APB1LPENR_I2C4LPEN)) != RESET)
N#define __HAL_RCC_CAN1_IS_CLK_SLEEP_ENABLED()    ((RCC->APB1LPENR & (RCC_APB1LPENR_CAN1LPEN)) != RESET)
N#define __HAL_RCC_CAN2_IS_CLK_SLEEP_ENABLED()    ((RCC->APB1LPENR & (RCC_APB1LPENR_CAN2LPEN)) != RESET)
N#define __HAL_RCC_CEC_IS_CLK_SLEEP_ENABLED()     ((RCC->APB1LPENR & (RCC_APB1LPENR_CECLPEN)) != RESET)
N#define __HAL_RCC_DAC_IS_CLK_SLEEP_ENABLED()     ((RCC->APB1LPENR & (RCC_APB1LPENR_DACLPEN)) != RESET)
N#define __HAL_RCC_UART7_IS_CLK_SLEEP_ENABLED()   ((RCC->APB1LPENR & (RCC_APB1LPENR_UART7LPEN)) != RESET)
N#define __HAL_RCC_UART8_IS_CLK_SLEEP_ENABLED()   ((RCC->APB1LPENR & (RCC_APB1LPENR_UART8LPEN)) != RESET)
N
N#define __HAL_RCC_TIM2_IS_CLK_SLEEP_DISABLED()   ((RCC->APB1LPENR & (RCC_APB1LPENR_TIM2LPEN)) == RESET)
N#define __HAL_RCC_TIM3_IS_CLK_SLEEP_DISABLED()   ((RCC->APB1LPENR & (RCC_APB1LPENR_TIM3LPEN)) == RESET)
N#define __HAL_RCC_TIM4_IS_CLK_SLEEP_DISABLED()   ((RCC->APB1LPENR & (RCC_APB1LPENR_TIM4LPEN)) == RESET)
N#define __HAL_RCC_TIM5_IS_CLK_SLEEP_DISABLED()   ((RCC->APB1LPENR & (RCC_APB1LPENR_TIM5LPEN)) == RESET)
N#define __HAL_RCC_TIM6_IS_CLK_SLEEP_DISABLED()   ((RCC->APB1LPENR & (RCC_APB1LPENR_TIM6LPEN)) == RESET)
N#define __HAL_RCC_TIM7_IS_CLK_SLEEP_DISABLED()   ((RCC->APB1LPENR & (RCC_APB1LPENR_TIM7LPEN)) == RESET)
N#define __HAL_RCC_TIM12_IS_CLK_SLEEP_DISABLED()  ((RCC->APB1LPENR & (RCC_APB1LPENR_TIM12LPEN)) == RESET)
N#define __HAL_RCC_TIM13_IS_CLK_SLEEP_DISABLED()  ((RCC->APB1LPENR & (RCC_APB1LPENR_TIM13LPEN)) == RESET)
N#define __HAL_RCC_TIM14_IS_CLK_SLEEP_DISABLED()  ((RCC->APB1LPENR & (RCC_APB1LPENR_TIM14LPEN)) == RESET)
N#define __HAL_RCC_LPTIM1_IS_CLK_SLEEP_DISABLED() ((RCC->APB1LPENR & (RCC_APB1LPENR_LPTIM1LPEN)) == RESET)
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N#define __HAL_RCC_RTC_IS_CLK_SLEEP_DISABLED()    ((RCC->APB1LPENR & (RCC_APB1LPENR_RTCLPEN)) == RESET)
N#define __HAL_RCC_CAN3_IS_CLK_SLEEP_DISABLED()   ((RCC->APB1LPENR & (RCC_APB1LPENR_CAN3LPEN)) == RESET)
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N#define __HAL_RCC_SPI2_IS_CLK_SLEEP_DISABLED()   ((RCC->APB1LPENR & (RCC_APB1LPENR_SPI2LPEN)) == RESET)
N#define __HAL_RCC_SPI3_IS_CLK_SLEEP_DISABLED()   ((RCC->APB1LPENR & (RCC_APB1LPENR_SPI3LPEN)) == RESET)
N#define __HAL_RCC_SPDIFRX_IS_CLK_SLEEP_DISABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_SPDIFRXLPEN)) == RESET)
N#define __HAL_RCC_USART2_IS_CLK_SLEEP_DISABLED() ((RCC->APB1LPENR & (RCC_APB1LPENR_USART2LPEN)) == RESET)
N#define __HAL_RCC_USART3_IS_CLK_SLEEP_DISABLED() ((RCC->APB1LPENR & (RCC_APB1LPENR_USART3LPEN)) == RESET)
N#define __HAL_RCC_UART4_IS_CLK_SLEEP_DISABLED()  ((RCC->APB1LPENR & (RCC_APB1LPENR_UART4LPEN)) == RESET)
N#define __HAL_RCC_UART5_IS_CLK_SLEEP_DISABLED()  ((RCC->APB1LPENR & (RCC_APB1LPENR_UART5LPEN)) == RESET)
N#define __HAL_RCC_I2C1_IS_CLK_SLEEP_DISABLED()   ((RCC->APB1LPENR & (RCC_APB1LPENR_I2C1LPEN)) == RESET)
N#define __HAL_RCC_I2C2_IS_CLK_SLEEP_DISABLED()   ((RCC->APB1LPENR & (RCC_APB1LPENR_I2C2LPEN)) == RESET)
N#define __HAL_RCC_I2C3_IS_CLK_SLEEP_DISABLED()   ((RCC->APB1LPENR & (RCC_APB1LPENR_I2C3LPEN)) == RESET)
N#define __HAL_RCC_I2C4_IS_CLK_SLEEP_DISABLED()   ((RCC->APB1LPENR & (RCC_APB1LPENR_I2C4LPEN)) == RESET)
N#define __HAL_RCC_CAN1_IS_CLK_SLEEP_DISABLED()   ((RCC->APB1LPENR & (RCC_APB1LPENR_CAN1LPEN)) == RESET)
N#define __HAL_RCC_CAN2_IS_CLK_SLEEP_DISABLED()   ((RCC->APB1LPENR & (RCC_APB1LPENR_CAN2LPEN)) == RESET)
N#define __HAL_RCC_CEC_IS_CLK_SLEEP_DISABLED()    ((RCC->APB1LPENR & (RCC_APB1LPENR_CECLPEN)) == RESET)
N#define __HAL_RCC_DAC_IS_CLK_SLEEP_DISABLED()    ((RCC->APB1LPENR & (RCC_APB1LPENR_DACLPEN)) == RESET)
N#define __HAL_RCC_UART7_IS_CLK_SLEEP_DISABLED()  ((RCC->APB1LPENR & (RCC_APB1LPENR_UART7LPEN)) == RESET)
N#define __HAL_RCC_UART8_IS_CLK_SLEEP_DISABLED()  ((RCC->APB1LPENR & (RCC_APB1LPENR_UART8LPEN)) == RESET)
N
N/** @brief  Get the enable or disable status of the APB2 peripheral clock during Low Power (Sleep) mode.
N  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
N  *         power consumption.
N  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
N  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
N  */ 
N#define __HAL_RCC_TIM1_IS_CLK_SLEEP_ENABLED()    ((RCC->APB2LPENR & (RCC_APB2LPENR_TIM1LPEN)) != RESET)
N#define __HAL_RCC_TIM8_IS_CLK_SLEEP_ENABLED()    ((RCC->APB2LPENR & (RCC_APB2LPENR_TIM8LPEN)) != RESET)
N#define __HAL_RCC_USART1_IS_CLK_SLEEP_ENABLED()  ((RCC->APB2LPENR & (RCC_APB2LPENR_USART1LPEN)) != RESET)
N#define __HAL_RCC_USART6_IS_CLK_SLEEP_ENABLED()  ((RCC->APB2LPENR & (RCC_APB2LPENR_USART6LPEN)) != RESET)
N#define __HAL_RCC_ADC1_IS_CLK_SLEEP_ENABLED()    ((RCC->APB2LPENR & (RCC_APB2LPENR_ADC1LPEN)) != RESET)
N#define __HAL_RCC_ADC2_IS_CLK_SLEEP_ENABLED()    ((RCC->APB2LPENR & (RCC_APB2LPENR_ADC2LPEN)) != RESET)
N#define __HAL_RCC_ADC3_IS_CLK_SLEEP_ENABLED()    ((RCC->APB2LPENR & (RCC_APB2LPENR_ADC3LPEN)) != RESET)
N#define __HAL_RCC_SDMMC1_IS_CLK_SLEEP_ENABLED()  ((RCC->APB2LPENR & (RCC_APB2LPENR_SDMMC1LPEN)) != RESET)
N#define __HAL_RCC_SPI1_IS_CLK_SLEEP_ENABLED()    ((RCC->APB2LPENR & (RCC_APB2LPENR_SPI1LPEN)) != RESET)
N#define __HAL_RCC_SPI4_IS_CLK_SLEEP_ENABLED()    ((RCC->APB2LPENR & (RCC_APB2LPENR_SPI4LPEN)) != RESET)
N#define __HAL_RCC_TIM9_IS_CLK_SLEEP_ENABLED()    ((RCC->APB2LPENR & (RCC_APB2LPENR_TIM9LPEN)) != RESET)
N#define __HAL_RCC_TIM10_IS_CLK_SLEEP_ENABLED()   ((RCC->APB2LPENR & (RCC_APB2LPENR_TIM10LPEN)) != RESET)
N#define __HAL_RCC_TIM11_IS_CLK_SLEEP_ENABLED()   ((RCC->APB2LPENR & (RCC_APB2LPENR_TIM11LPEN)) != RESET)
N#define __HAL_RCC_SPI5_IS_CLK_SLEEP_ENABLED()    ((RCC->APB2LPENR & (RCC_APB2LPENR_SPI5LPEN)) != RESET)
N#define __HAL_RCC_SPI6_IS_CLK_SLEEP_ENABLED()    ((RCC->APB2LPENR & (RCC_APB2LPENR_SPI6LPEN)) != RESET)
N#define __HAL_RCC_SAI1_IS_CLK_SLEEP_ENABLED()    ((RCC->APB2LPENR & (RCC_APB2LPENR_SAI1LPEN)) != RESET)
N#define __HAL_RCC_SAI2_IS_CLK_SLEEP_ENABLED()    ((RCC->APB2LPENR & (RCC_APB2LPENR_SAI2LPEN)) != RESET)
N#if defined (STM32F746xx) || defined (STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 0L || 1L || 0L || 0L || 0L
N#define __HAL_RCC_LTDC_IS_CLK_SLEEP_ENABLED()    ((RCC->APB2LPENR & (RCC_APB2LPENR_LTDCLPEN)) != RESET)
N#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N#if defined (STM32F769xx) || defined (STM32F779xx)
X#if 0L || 0L
S#define __HAL_RCC_DSI_IS_CLK_SLEEP_ENABLED()     ((RCC->APB2LPENR & (RCC_APB2LPENR_DSILPEN)) != RESET)
N#endif /* STM32F769xx || STM32F779xx */
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N#define __HAL_RCC_SDMMC2_IS_CLK_SLEEP_ENABLED()  ((RCC->APB2LPENR & (RCC_APB2LPENR_SDMMC2LPEN)) != RESET)
N#define __HAL_RCC_DFSDM1_IS_CLK_SLEEP_ENABLED()   ((RCC->APB2LPENR & (RCC_APB2LPENR_DFSDM1LPEN)) != RESET)
N#define __HAL_RCC_MDIO_IS_CLK_SLEEP_ENABLED()    ((RCC->APB2LPENR & (RCC_APB2LPENR_MDIOLPEN)) != RESET)
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N
N#define __HAL_RCC_TIM1_IS_CLK_SLEEP_DISABLED()   ((RCC->APB2LPENR & (RCC_APB2LPENR_TIM1LPEN)) == RESET)
N#define __HAL_RCC_TIM8_IS_CLK_SLEEP_DISABLED()   ((RCC->APB2LPENR & (RCC_APB2LPENR_TIM8LPEN)) == RESET)
N#define __HAL_RCC_USART1_IS_CLK_SLEEP_DISABLED() ((RCC->APB2LPENR & (RCC_APB2LPENR_USART1LPEN)) == RESET)
N#define __HAL_RCC_USART6_IS_CLK_SLEEP_DISABLED() ((RCC->APB2LPENR & (RCC_APB2LPENR_USART6LPEN)) == RESET)
N#define __HAL_RCC_ADC1_IS_CLK_SLEEP_DISABLED()   ((RCC->APB2LPENR & (RCC_APB2LPENR_ADC1LPEN)) == RESET)
N#define __HAL_RCC_ADC2_IS_CLK_SLEEP_DISABLED()   ((RCC->APB2LPENR & (RCC_APB2LPENR_ADC2LPEN)) == RESET)
N#define __HAL_RCC_ADC3_IS_CLK_SLEEP_DISABLED()   ((RCC->APB2LPENR & (RCC_APB2LPENR_ADC3LPEN)) == RESET)
N#define __HAL_RCC_SDMMC1_IS_CLK_SLEEP_DISABLED() ((RCC->APB2LPENR & (RCC_APB2LPENR_SDMMC1LPEN)) == RESET)
N#define __HAL_RCC_SPI1_IS_CLK_SLEEP_DISABLED()   ((RCC->APB2LPENR & (RCC_APB2LPENR_SPI1LPEN)) == RESET)
N#define __HAL_RCC_SPI4_IS_CLK_SLEEP_DISABLED()   ((RCC->APB2LPENR & (RCC_APB2LPENR_SPI4LPEN)) == RESET)
N#define __HAL_RCC_TIM9_IS_CLK_SLEEP_DISABLED()   ((RCC->APB2LPENR & (RCC_APB2LPENR_TIM9LPEN)) == RESET)
N#define __HAL_RCC_TIM10_IS_CLK_SLEEP_DISABLED()  ((RCC->APB2LPENR & (RCC_APB2LPENR_TIM10LPEN)) == RESET)
N#define __HAL_RCC_TIM11_IS_CLK_SLEEP_DISABLED()  ((RCC->APB2LPENR & (RCC_APB2LPENR_TIM11LPEN)) == RESET)
N#define __HAL_RCC_SPI5_IS_CLK_SLEEP_DISABLED()   ((RCC->APB2LPENR & (RCC_APB2LPENR_SPI5LPEN)) == RESET)
N#define __HAL_RCC_SPI6_IS_CLK_SLEEP_DISABLED()   ((RCC->APB2LPENR & (RCC_APB2LPENR_SPI6LPEN)) == RESET)
N#define __HAL_RCC_SAI1_IS_CLK_SLEEP_DISABLED()   ((RCC->APB2LPENR & (RCC_APB2LPENR_SAI1LPEN)) == RESET)
N#define __HAL_RCC_SAI2_IS_CLK_SLEEP_DISABLED()   ((RCC->APB2LPENR & (RCC_APB2LPENR_SAI2LPEN)) == RESET)
N#if defined (STM32F746xx) || defined (STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 0L || 1L || 0L || 0L || 0L
N#define __HAL_RCC_LTDC_IS_CLK_SLEEP_DISABLED()   ((RCC->APB2LPENR & (RCC_APB2LPENR_LTDCLPEN)) == RESET)
N#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N#if defined (STM32F769xx) || defined (STM32F779xx)
X#if 0L || 0L
S#define __HAL_RCC_DSI_IS_CLK_SLEEP_DISABLED()     ((RCC->APB2LPENR & (RCC_APB2LPENR_DSILPEN)) == RESET)
N#endif /* STM32F769xx || STM32F779xx */
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N#define __HAL_RCC_SDMMC2_IS_CLK_SLEEP_DISABLED()  ((RCC->APB2LPENR & (RCC_APB2LPENR_SDMMC2LPEN)) == RESET)
N#define __HAL_RCC_DFSDM1_IS_CLK_SLEEP_DISABLED()   ((RCC->APB2LPENR & (RCC_APB2LPENR_DFSDM1LPEN)) == RESET)
N#define __HAL_RCC_MDIO_IS_CLK_SLEEP_DISABLED()    ((RCC->APB2LPENR & (RCC_APB2LPENR_MDIOLPEN)) == RESET)
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N/**
N  * @}
N  */
N
N/*------------------------------- PLL Configuration --------------------------*/
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N/** @brief  Macro to configure the main PLL clock source, multiplication and division factors.
N  * @note   This function must be used only when the main PLL is disabled.
N  * @param  __RCC_PLLSource__: specifies the PLL entry clock source.
N  *         This parameter can be one of the following values:
N  *            @arg RCC_PLLSOURCE_HSI: HSI oscillator clock selected as PLL clock entry
N  *            @arg RCC_PLLSOURCE_HSE: HSE oscillator clock selected as PLL clock entry
N  * @note   This clock source (RCC_PLLSource) is common for the main PLL and PLLI2S.  
N  * @param  __PLLM__: specifies the division factor for PLL VCO input clock
N  *         This parameter must be a number between Min_Data = 2 and Max_Data = 63.
N  * @note   You have to set the PLLM parameter correctly to ensure that the VCO input
N  *         frequency ranges from 1 to 2 MHz. It is recommended to select a frequency
N  *         of 2 MHz to limit PLL jitter.
N  * @param  __PLLN__: specifies the multiplication factor for PLL VCO output clock
N  *         This parameter must be a number between Min_Data = 50 and Max_Data = 432.
N  * @note   You have to set the PLLN parameter correctly to ensure that the VCO
N  *         output frequency is between 100 and 432 MHz.
N  * @param  __PLLP__: specifies the division factor for main system clock (SYSCLK)
N  *         This parameter must be a number in the range {2, 4, 6, or 8}.
N  * @note   You have to set the PLLP parameter correctly to not exceed 216 MHz on
N  *         the System clock frequency.
N  * @param  __PLLQ__: specifies the division factor for OTG FS, SDMMC and RNG clocks
N  *         This parameter must be a number between Min_Data = 2 and Max_Data = 15.
N  * @note   If the USB OTG FS is used in your application, you have to set the
N  *         PLLQ parameter correctly to have 48 MHz clock for the USB. However,
N  *         the SDMMC and RNG need a frequency lower than or equal to 48 MHz to work
N  *         correctly.
N  * @param  __PLLR__: specifies the division factor for DSI clock
N  *         This parameter must be a number between Min_Data = 2 and Max_Data = 7.
N  */
N#define __HAL_RCC_PLL_CONFIG(__RCC_PLLSource__, __PLLM__, __PLLN__, __PLLP__, __PLLQ__,__PLLR__)  \
N                            (RCC->PLLCFGR = ((__RCC_PLLSource__) | (__PLLM__)                   | \
N                            ((__PLLN__) << POSITION_VAL(RCC_PLLCFGR_PLLN))                      | \
N                            ((((__PLLP__) >> 1) -1) << POSITION_VAL(RCC_PLLCFGR_PLLP))          | \
N                            ((__PLLQ__) << POSITION_VAL(RCC_PLLCFGR_PLLQ))                      | \
N                            ((__PLLR__) << POSITION_VAL(RCC_PLLCFGR_PLLR))))
X#define __HAL_RCC_PLL_CONFIG(__RCC_PLLSource__, __PLLM__, __PLLN__, __PLLP__, __PLLQ__,__PLLR__)                              (RCC->PLLCFGR = ((__RCC_PLLSource__) | (__PLLM__)                   |                             ((__PLLN__) << POSITION_VAL(RCC_PLLCFGR_PLLN))                      |                             ((((__PLLP__) >> 1) -1) << POSITION_VAL(RCC_PLLCFGR_PLLP))          |                             ((__PLLQ__) << POSITION_VAL(RCC_PLLCFGR_PLLQ))                      |                             ((__PLLR__) << POSITION_VAL(RCC_PLLCFGR_PLLR))))
N#else
S/** @brief  Macro to configure the main PLL clock source, multiplication and division factors.
S  * @note   This function must be used only when the main PLL is disabled.
S  * @param  __RCC_PLLSource__: specifies the PLL entry clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_PLLSOURCE_HSI: HSI oscillator clock selected as PLL clock entry
S  *            @arg RCC_PLLSOURCE_HSE: HSE oscillator clock selected as PLL clock entry
S  * @note   This clock source (RCC_PLLSource) is common for the main PLL and PLLI2S.  
S  * @param  __PLLM__: specifies the division factor for PLL VCO input clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 63.
S  * @note   You have to set the PLLM parameter correctly to ensure that the VCO input
S  *         frequency ranges from 1 to 2 MHz. It is recommended to select a frequency
S  *         of 2 MHz to limit PLL jitter.
S  * @param  __PLLN__: specifies the multiplication factor for PLL VCO output clock
S  *         This parameter must be a number between Min_Data = 50 and Max_Data = 432.
S  * @note   You have to set the PLLN parameter correctly to ensure that the VCO
S  *         output frequency is between 100 and 432 MHz.
S  * @param  __PLLP__: specifies the division factor for main system clock (SYSCLK)
S  *         This parameter must be a number in the range {2, 4, 6, or 8}.
S  * @note   You have to set the PLLP parameter correctly to not exceed 216 MHz on
S  *         the System clock frequency.
S  * @param  __PLLQ__: specifies the division factor for OTG FS, SDMMC and RNG clocks
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 15.
S  * @note   If the USB OTG FS is used in your application, you have to set the
S  *         PLLQ parameter correctly to have 48 MHz clock for the USB. However,
S  *         the SDMMC and RNG need a frequency lower than or equal to 48 MHz to work
S  *         correctly.
S  */
S#define __HAL_RCC_PLL_CONFIG(__RCC_PLLSource__, __PLLM__, __PLLN__, __PLLP__, __PLLQ__)     \
S                            (RCC->PLLCFGR = (0x20000000 | (__RCC_PLLSource__) | (__PLLM__)| \
S                            ((__PLLN__) << POSITION_VAL(RCC_PLLCFGR_PLLN))                | \
S                            ((((__PLLP__) >> 1) -1) << POSITION_VAL(RCC_PLLCFGR_PLLP))    | \
S                            ((__PLLQ__) << POSITION_VAL(RCC_PLLCFGR_PLLQ))))
X#define __HAL_RCC_PLL_CONFIG(__RCC_PLLSource__, __PLLM__, __PLLN__, __PLLP__, __PLLQ__)                                 (RCC->PLLCFGR = (0x20000000 | (__RCC_PLLSource__) | (__PLLM__)|                             ((__PLLN__) << POSITION_VAL(RCC_PLLCFGR_PLLN))                |                             ((((__PLLP__) >> 1) -1) << POSITION_VAL(RCC_PLLCFGR_PLLP))    |                             ((__PLLQ__) << POSITION_VAL(RCC_PLLCFGR_PLLQ))))
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */ 
N/*---------------------------------------------------------------------------------------------*/
N
N/** @brief  Macro to configure the Timers clocks prescalers 
N  * @param  __PRESC__ : specifies the Timers clocks prescalers selection
N  *         This parameter can be one of the following values:
N  *            @arg RCC_TIMPRES_DESACTIVATED: The Timers kernels clocks prescaler is 
N  *                 equal to HPRE if PPREx is corresponding to division by 1 or 2, 
N  *                 else it is equal to [(HPRE * PPREx) / 2] if PPREx is corresponding to 
N  *                 division by 4 or more.       
N  *            @arg RCC_TIMPRES_ACTIVATED: The Timers kernels clocks prescaler is 
N  *                 equal to HPRE if PPREx is corresponding to division by 1, 2 or 4, 
N  *                 else it is equal to [(HPRE * PPREx) / 4] if PPREx is corresponding 
N  *                 to division by 8 or more.
N  */     
N#define __HAL_RCC_TIMCLKPRESCALER(__PRESC__) do {RCC->DCKCFGR1 &= ~(RCC_DCKCFGR1_TIMPRE);\
N                                                 RCC->DCKCFGR1 |= (__PRESC__);           \
N                                                }while(0)
X#define __HAL_RCC_TIMCLKPRESCALER(__PRESC__) do {RCC->DCKCFGR1 &= ~(RCC_DCKCFGR1_TIMPRE);                                                 RCC->DCKCFGR1 |= (__PRESC__);                                                           }while(0)
N
N/** @brief Macros to Enable or Disable the PLLISAI. 
N  * @note  The PLLSAI is disabled by hardware when entering STOP and STANDBY modes. 
N  */
N#define __HAL_RCC_PLLSAI_ENABLE() (RCC->CR |= (RCC_CR_PLLSAION))
N#define __HAL_RCC_PLLSAI_DISABLE() (RCC->CR &= ~(RCC_CR_PLLSAION))
N
N/** @brief  Macro to configure the PLLSAI clock multiplication and division factors.
N  * @note   This function must be used only when the PLLSAI is disabled.
N  * @note   PLLSAI clock source is common with the main PLL (configured in 
N  *         RCC_PLLConfig function )
N  * @param  __PLLSAIN__: specifies the multiplication factor for PLLSAI VCO output clock.
N  *         This parameter must be a number between Min_Data = 50 and Max_Data = 432.
N  * @note   You have to set the PLLSAIN parameter correctly to ensure that the VCO 
N  *         output frequency is between Min_Data = 100 and Max_Data = 432 MHz.
N  * @param  __PLLSAIP__: specifies the division factor for USB, RNG, SDMMC clocks
N  *         This parameter can be a value of @ref RCCEx_PLLSAIP_Clock_Divider.                                                  
N  * @param  __PLLSAIQ__: specifies the division factor for SAI clock
N  *         This parameter must be a number between Min_Data = 2 and Max_Data = 15.
N  * @param  __PLLSAIR__: specifies the division factor for LTDC clock
N  *         This parameter must be a number between Min_Data = 2 and Max_Data = 7.
N  */   
N#define __HAL_RCC_PLLSAI_CONFIG(__PLLSAIN__, __PLLSAIP__, __PLLSAIQ__, __PLLSAIR__)                        \
N                               (RCC->PLLSAICFGR = ((__PLLSAIN__) << POSITION_VAL(RCC_PLLSAICFGR_PLLSAIN)) |\
N                               ((__PLLSAIP__) << POSITION_VAL(RCC_PLLSAICFGR_PLLSAIP))                    |\
N                               ((__PLLSAIQ__) << POSITION_VAL(RCC_PLLSAICFGR_PLLSAIQ))                    |\
N                               ((__PLLSAIR__) << POSITION_VAL(RCC_PLLSAICFGR_PLLSAIR)))
X#define __HAL_RCC_PLLSAI_CONFIG(__PLLSAIN__, __PLLSAIP__, __PLLSAIQ__, __PLLSAIR__)                                                       (RCC->PLLSAICFGR = ((__PLLSAIN__) << POSITION_VAL(RCC_PLLSAICFGR_PLLSAIN)) |                               ((__PLLSAIP__) << POSITION_VAL(RCC_PLLSAICFGR_PLLSAIP))                    |                               ((__PLLSAIQ__) << POSITION_VAL(RCC_PLLSAICFGR_PLLSAIQ))                    |                               ((__PLLSAIR__) << POSITION_VAL(RCC_PLLSAICFGR_PLLSAIR)))
N
N/** @brief  Macro to configure the PLLI2S clock multiplication and division factors.
N  * @note   This macro must be used only when the PLLI2S is disabled.
N  * @note   PLLI2S clock source is common with the main PLL (configured in 
N  *         HAL_RCC_ClockConfig() API)             
N  * @param  __PLLI2SN__: specifies the multiplication factor for PLLI2S VCO output clock.
N  *         This parameter must be a number between Min_Data = 50 and Max_Data = 432.
N  * @note   You have to set the PLLI2SN parameter correctly to ensure that the VCO 
N  *         output frequency is between Min_Data = 100 and Max_Data = 432 MHz.
N  * @param  __PLLI2SP__: specifies the division factor for SPDDIF-RX clock.
N  *         This parameter can be a value of @ref RCCEx_PLLI2SP_Clock_Divider.                                 
N  * @param  __PLLI2SQ__: specifies the division factor for SAI clock.
N  *         This parameter must be a number between Min_Data = 2 and Max_Data = 15. 
N  * @param  __PLLI2SR__: specifies the division factor for I2S clock
N  *         This parameter must be a number between Min_Data = 2 and Max_Data = 7.
N  * @note   You have to set the PLLI2SR parameter correctly to not exceed 192 MHz
N  *         on the I2S clock frequency. 
N  */
N#define __HAL_RCC_PLLI2S_CONFIG(__PLLI2SN__, __PLLI2SP__, __PLLI2SQ__, __PLLI2SR__)                        \
N                               (RCC->PLLI2SCFGR = ((__PLLI2SN__) << POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SN)) |\
N                               ((__PLLI2SP__) << POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SP))                    |\
N                               ((__PLLI2SQ__) << POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SQ))                    |\
N                               ((__PLLI2SR__) << POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SR)))
X#define __HAL_RCC_PLLI2S_CONFIG(__PLLI2SN__, __PLLI2SP__, __PLLI2SQ__, __PLLI2SR__)                                                       (RCC->PLLI2SCFGR = ((__PLLI2SN__) << POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SN)) |                               ((__PLLI2SP__) << POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SP))                    |                               ((__PLLI2SQ__) << POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SQ))                    |                               ((__PLLI2SR__) << POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SR)))
N    
N/** @brief  Macro to configure the SAI clock Divider coming from PLLI2S.
N  * @note   This function must be called before enabling the PLLI2S.          
N  * @param  __PLLI2SDivQ__: specifies the PLLI2S division factor for SAI1 clock .
N  *          This parameter must be a number between 1 and 32.
N  *          SAI1 clock frequency = f(PLLI2SQ) / __PLLI2SDivQ__ 
N  */
N#define __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(__PLLI2SDivQ__) (MODIFY_REG(RCC->DCKCFGR1, RCC_DCKCFGR1_PLLI2SDIVQ, (__PLLI2SDivQ__)-1))
N
N/** @brief  Macro to configure the SAI clock Divider coming from PLLSAI.
N  * @note   This function must be called before enabling the PLLSAI.
N  * @param  __PLLSAIDivQ__: specifies the PLLSAI division factor for SAI1 clock .
N  *         This parameter must be a number between Min_Data = 1 and Max_Data = 32.
N  *         SAI1 clock frequency = f(PLLSAIQ) / __PLLSAIDivQ__  
N  */
N#define __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(__PLLSAIDivQ__) (MODIFY_REG(RCC->DCKCFGR1, RCC_DCKCFGR1_PLLSAIDIVQ, ((__PLLSAIDivQ__)-1)<<8))
N
N/** @brief  Macro to configure the LTDC clock Divider coming from PLLSAI.
N  * 
N  * @note   This function must be called before enabling the PLLSAI. 
N  * @param  __PLLSAIDivR__: specifies the PLLSAI division factor for LTDC clock .
N  *          This parameter can be a value of @ref RCCEx_PLLSAI_DIVR.
N  *          LTDC clock frequency = f(PLLSAIR) / __PLLSAIDivR__ 
N  */   
N#define __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(__PLLSAIDivR__)\
N                            MODIFY_REG(RCC->DCKCFGR1, RCC_DCKCFGR1_PLLSAIDIVR, (uint32_t)(__PLLSAIDivR__))
X#define __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(__PLLSAIDivR__)                            MODIFY_REG(RCC->DCKCFGR1, RCC_DCKCFGR1_PLLSAIDIVR, (uint32_t)(__PLLSAIDivR__))
N
N/** @brief  Macro to configure SAI1 clock source selection.
N  * @note   This function must be called before enabling PLLSAI, PLLI2S and  
N  *         the SAI clock.
N  * @param  __SOURCE__: specifies the SAI1 clock source.
N  *         This parameter can be one of the following values:
N  *            @arg RCC_SAI1CLKSOURCE_PLLI2S: PLLI2S_Q clock divided by PLLI2SDIVQ used 
N  *                                           as SAI1 clock. 
N  *            @arg RCC_SAI1CLKSOURCE_PLLSAI: PLLISAI_Q clock divided by PLLSAIDIVQ used 
N  *                                           as SAI1 clock.
N  *            @arg RCC_SAI1CLKSOURCE_PIN: External clock mapped on the I2S_CKIN pin
N  *                                        used as SAI1 clock.
N  *            @arg RCC_SAI1CLKSOURCE_PLLSRC: HSI or HSE depending from PLL Source clock 
N  *                                           used as SAI1 clock.
N  * @note      The RCC_SAI1CLKSOURCE_PLLSRC value is only available with STM32F767/769/777/779xx Devices                               
N  */
N#define __HAL_RCC_SAI1_CONFIG(__SOURCE__)\
N                             MODIFY_REG(RCC->DCKCFGR1, RCC_DCKCFGR1_SAI1SEL, (uint32_t)(__SOURCE__))
X#define __HAL_RCC_SAI1_CONFIG(__SOURCE__)                             MODIFY_REG(RCC->DCKCFGR1, RCC_DCKCFGR1_SAI1SEL, (uint32_t)(__SOURCE__))
N
N/** @brief  Macro to get the SAI1 clock source.
N  * @retval The clock source can be one of the following values:
N  *            @arg RCC_SAI1CLKSOURCE_PLLI2S: PLLI2S_Q clock divided by PLLI2SDIVQ used 
N  *                                           as SAI1 clock. 
N  *            @arg RCC_SAI1CLKSOURCE_PLLSAI: PLLISAI_Q clock divided by PLLSAIDIVQ used 
N  *                                           as SAI1 clock.
N  *            @arg RCC_SAI1CLKSOURCE_PIN: External clock mapped on the I2S_CKIN pin
N  *                                        used as SAI1 clock.
N  *            @arg RCC_SAI1CLKSOURCE_PLLSRC: HSI or HSE depending from PLL Source clock 
N  *                                           used as SAI1 clock.
N  * @note      The RCC_SAI1CLKSOURCE_PLLSRC value is only available with STM32F767/769/777/779xx Devices                               
N  */
N#define __HAL_RCC_GET_SAI1_SOURCE() ((uint32_t)(READ_BIT(RCC->DCKCFGR1, RCC_DCKCFGR1_SAI1SEL)))
N
N
N/** @brief  Macro to configure SAI2 clock source selection.
N  * @note   This function must be called before enabling PLLSAI, PLLI2S and  
N  *         the SAI clock.
N  * @param  __SOURCE__: specifies the SAI2 clock source.
N  *         This parameter can be one of the following values:
N  *            @arg RCC_SAI2CLKSOURCE_PLLI2S: PLLI2S_Q clock divided by PLLI2SDIVQ used 
N  *                                           as SAI2 clock. 
N  *            @arg RCC_SAI2CLKSOURCE_PLLSAI: PLLISAI_Q clock divided by PLLSAIDIVQ used 
N  *                                           as SAI2 clock. 
N  *            @arg RCC_SAI2CLKSOURCE_PIN: External clock mapped on the I2S_CKIN pin
N  *                                        used as SAI2 clock.
N  *            @arg RCC_SAI2CLKSOURCE_PLLSRC: HSI or HSE depending from PLL Source clock 
N  *                                           used as SAI2 clock.
N  * @note      The RCC_SAI2CLKSOURCE_PLLSRC value is only available with STM32F767/769/777/779xx Devices                                
N  */
N#define __HAL_RCC_SAI2_CONFIG(__SOURCE__)\
N                            MODIFY_REG(RCC->DCKCFGR1, RCC_DCKCFGR1_SAI2SEL, (uint32_t)(__SOURCE__))
X#define __HAL_RCC_SAI2_CONFIG(__SOURCE__)                            MODIFY_REG(RCC->DCKCFGR1, RCC_DCKCFGR1_SAI2SEL, (uint32_t)(__SOURCE__))
N
N
N/** @brief  Macro to get the SAI2 clock source.
N  * @retval The clock source can be one of the following values:
N  *            @arg RCC_SAI2CLKSOURCE_PLLI2S: PLLI2S_Q clock divided by PLLI2SDIVQ used 
N  *                                           as SAI2 clock. 
N  *            @arg RCC_SAI2CLKSOURCE_PLLSAI: PLLISAI_Q clock divided by PLLSAIDIVQ used 
N  *                                           as SAI2 clock.
N  *            @arg RCC_SAI2CLKSOURCE_PIN: External clock mapped on the I2S_CKIN pin
N  *                                        used as SAI2 clock.
N  *            @arg RCC_SAI2CLKSOURCE_PLLSRC: HSI or HSE depending from PLL Source clock 
N  *                                           used as SAI2 clock.
N  * @note      The RCC_SAI2CLKSOURCE_PLLSRC value is only available with STM32F767/769/777/779xx Devices                              
N  */
N#define __HAL_RCC_GET_SAI2_SOURCE() ((uint32_t)(READ_BIT(RCC->DCKCFGR1, RCC_DCKCFGR1_SAI2SEL)))
N
N
N/** @brief Enable PLLSAI_RDY interrupt.
N  */
N#define __HAL_RCC_PLLSAI_ENABLE_IT() (RCC->CIR |= (RCC_CIR_PLLSAIRDYIE))
N
N/** @brief Disable PLLSAI_RDY interrupt.
N  */
N#define __HAL_RCC_PLLSAI_DISABLE_IT() (RCC->CIR &= ~(RCC_CIR_PLLSAIRDYIE))
N
N/** @brief Clear the PLLSAI RDY interrupt pending bits.
N  */
N#define __HAL_RCC_PLLSAI_CLEAR_IT() (RCC->CIR |= (RCC_CIR_PLLSAIRDYF))
N
N/** @brief Check the PLLSAI RDY interrupt has occurred or not.
N  * @retval The new state (TRUE or FALSE).
N  */
N#define __HAL_RCC_PLLSAI_GET_IT() ((RCC->CIR & (RCC_CIR_PLLSAIRDYIE)) == (RCC_CIR_PLLSAIRDYIE))
N
N/** @brief  Check PLLSAI RDY flag is set or not.
N  * @retval The new state (TRUE or FALSE).
N  */
N#define __HAL_RCC_PLLSAI_GET_FLAG() ((RCC->CR & (RCC_CR_PLLSAIRDY)) == (RCC_CR_PLLSAIRDY))
N
N/** @brief  Macro to Get I2S clock source selection.
N  * @retval The clock source can be one of the following values:
N  *            @arg RCC_I2SCLKSOURCE_PLLI2S: PLLI2S VCO output clock divided by PLLI2SR used as I2S clock. 
N  *            @arg RCC_I2SCLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin used as I2S clock source
N  */
N#define __HAL_RCC_GET_I2SCLKSOURCE() (READ_BIT(RCC->CFGR, RCC_CFGR_I2SSRC))
N
N/** @brief  Macro to configure the I2C1 clock (I2C1CLK).
N  *
N  * @param  __I2C1_CLKSOURCE__: specifies the I2C1 clock source.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_I2C1CLKSOURCE_PCLK1: PCLK1 selected as I2C1 clock
N  *            @arg RCC_I2C1CLKSOURCE_HSI: HSI selected as I2C1 clock
N  *            @arg RCC_I2C1CLKSOURCE_SYSCLK: System Clock selected as I2C1 clock
N  */
N#define __HAL_RCC_I2C1_CONFIG(__I2C1_CLKSOURCE__) \
N                  MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_I2C1SEL, (uint32_t)(__I2C1_CLKSOURCE__))
X#define __HAL_RCC_I2C1_CONFIG(__I2C1_CLKSOURCE__)                   MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_I2C1SEL, (uint32_t)(__I2C1_CLKSOURCE__))
N
N/** @brief  Macro to get the I2C1 clock source.
N  * @retval The clock source can be one of the following values:
N  *            @arg RCC_I2C1CLKSOURCE_PCLK1: PCLK1 selected as I2C1 clock
N  *            @arg RCC_I2C1CLKSOURCE_HSI: HSI selected as I2C1 clock
N  *            @arg RCC_I2C1CLKSOURCE_SYSCLK: System Clock selected as I2C1 clock
N  */
N#define __HAL_RCC_GET_I2C1_SOURCE() ((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_I2C1SEL)))
N
N/** @brief  Macro to configure the I2C2 clock (I2C2CLK).
N  *
N  * @param  __I2C2_CLKSOURCE__: specifies the I2C2 clock source.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_I2C2CLKSOURCE_PCLK1: PCLK1 selected as I2C2 clock
N  *            @arg RCC_I2C2CLKSOURCE_HSI: HSI selected as I2C2 clock
N  *            @arg RCC_I2C2CLKSOURCE_SYSCLK: System Clock selected as I2C2 clock
N  */
N#define __HAL_RCC_I2C2_CONFIG(__I2C2_CLKSOURCE__) \
N                  MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_I2C2SEL, (uint32_t)(__I2C2_CLKSOURCE__))
X#define __HAL_RCC_I2C2_CONFIG(__I2C2_CLKSOURCE__)                   MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_I2C2SEL, (uint32_t)(__I2C2_CLKSOURCE__))
N
N/** @brief  Macro to get the I2C2 clock source.
N  * @retval The clock source can be one of the following values:
N  *            @arg RCC_I2C2CLKSOURCE_PCLK1: PCLK1 selected as I2C2 clock
N  *            @arg RCC_I2C2CLKSOURCE_HSI: HSI selected as I2C2 clock
N  *            @arg RCC_I2C2CLKSOURCE_SYSCLK: System Clock selected as I2C2 clock
N  */
N#define __HAL_RCC_GET_I2C2_SOURCE() ((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_I2C2SEL)))
N
N/** @brief  Macro to configure the I2C3 clock (I2C3CLK).
N  *
N  * @param  __I2C3_CLKSOURCE__: specifies the I2C3 clock source.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_I2C3CLKSOURCE_PCLK1: PCLK1 selected as I2C3 clock
N  *            @arg RCC_I2C3CLKSOURCE_HSI: HSI selected as I2C3 clock
N  *            @arg RCC_I2C3CLKSOURCE_SYSCLK: System Clock selected as I2C3 clock
N  */
N#define __HAL_RCC_I2C3_CONFIG(__I2C3_CLKSOURCE__) \
N                  MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_I2C3SEL, (uint32_t)(__I2C3_CLKSOURCE__))
X#define __HAL_RCC_I2C3_CONFIG(__I2C3_CLKSOURCE__)                   MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_I2C3SEL, (uint32_t)(__I2C3_CLKSOURCE__))
N
N/** @brief  macro to get the I2C3 clock source.
N  * @retval The clock source can be one of the following values:
N  *            @arg RCC_I2C3CLKSOURCE_PCLK1: PCLK1 selected as I2C3 clock
N  *            @arg RCC_I2C3CLKSOURCE_HSI: HSI selected as I2C3 clock
N  *            @arg RCC_I2C3CLKSOURCE_SYSCLK: System Clock selected as I2C3 clock
N  */
N#define __HAL_RCC_GET_I2C3_SOURCE() ((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_I2C3SEL)))
N
N/** @brief  Macro to configure the I2C4 clock (I2C4CLK).
N  *
N  * @param  __I2C4_CLKSOURCE__: specifies the I2C4 clock source.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_I2C4CLKSOURCE_PCLK1: PCLK1 selected as I2C4 clock
N  *            @arg RCC_I2C4CLKSOURCE_HSI: HSI selected as I2C4 clock
N  *            @arg RCC_I2C4CLKSOURCE_SYSCLK: System Clock selected as I2C4 clock
N  */
N#define __HAL_RCC_I2C4_CONFIG(__I2C4_CLKSOURCE__) \
N                  MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_I2C4SEL, (uint32_t)(__I2C4_CLKSOURCE__))
X#define __HAL_RCC_I2C4_CONFIG(__I2C4_CLKSOURCE__)                   MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_I2C4SEL, (uint32_t)(__I2C4_CLKSOURCE__))
N
N/** @brief  macro to get the I2C4 clock source.
N  * @retval The clock source can be one of the following values:
N  *            @arg RCC_I2C4CLKSOURCE_PCLK1: PCLK1 selected as I2C4 clock
N  *            @arg RCC_I2C4CLKSOURCE_HSI: HSI selected as I2C4 clock
N  *            @arg RCC_I2C4CLKSOURCE_SYSCLK: System Clock selected as I2C4 clock
N  */
N#define __HAL_RCC_GET_I2C4_SOURCE() ((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_I2C4SEL)))
N
N/** @brief  Macro to configure the USART1 clock (USART1CLK).
N  *
N  * @param  __USART1_CLKSOURCE__: specifies the USART1 clock source.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_USART1CLKSOURCE_PCLK2: PCLK2 selected as USART1 clock
N  *            @arg RCC_USART1CLKSOURCE_HSI: HSI selected as USART1 clock
N  *            @arg RCC_USART1CLKSOURCE_SYSCLK: System Clock selected as USART1 clock
N  *            @arg RCC_USART1CLKSOURCE_LSE: LSE selected as USART1 clock
N  */
N#define __HAL_RCC_USART1_CONFIG(__USART1_CLKSOURCE__) \
N                  MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_USART1SEL, (uint32_t)(__USART1_CLKSOURCE__))
X#define __HAL_RCC_USART1_CONFIG(__USART1_CLKSOURCE__)                   MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_USART1SEL, (uint32_t)(__USART1_CLKSOURCE__))
N
N/** @brief  macro to get the USART1 clock source.
N  * @retval The clock source can be one of the following values:
N  *            @arg RCC_USART1CLKSOURCE_PCLK2: PCLK2 selected as USART1 clock
N  *            @arg RCC_USART1CLKSOURCE_HSI: HSI selected as USART1 clock
N  *            @arg RCC_USART1CLKSOURCE_SYSCLK: System Clock selected as USART1 clock
N  *            @arg RCC_USART1CLKSOURCE_LSE: LSE selected as USART1 clock
N  */
N#define __HAL_RCC_GET_USART1_SOURCE() ((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_USART1SEL)))
N
N/** @brief  Macro to configure the USART2 clock (USART2CLK).
N  *
N  * @param  __USART2_CLKSOURCE__: specifies the USART2 clock source.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_USART2CLKSOURCE_PCLK1: PCLK1 selected as USART2 clock
N  *            @arg RCC_USART2CLKSOURCE_HSI: HSI selected as USART2 clock
N  *            @arg RCC_USART2CLKSOURCE_SYSCLK: System Clock selected as USART2 clock
N  *            @arg RCC_USART2CLKSOURCE_LSE: LSE selected as USART2 clock
N  */
N#define __HAL_RCC_USART2_CONFIG(__USART2_CLKSOURCE__) \
N                  MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_USART2SEL, (uint32_t)(__USART2_CLKSOURCE__))
X#define __HAL_RCC_USART2_CONFIG(__USART2_CLKSOURCE__)                   MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_USART2SEL, (uint32_t)(__USART2_CLKSOURCE__))
N
N/** @brief  macro to get the USART2 clock source.
N  * @retval The clock source can be one of the following values:
N  *            @arg RCC_USART2CLKSOURCE_PCLK1: PCLK1 selected as USART2 clock
N  *            @arg RCC_USART2CLKSOURCE_HSI: HSI selected as USART2 clock
N  *            @arg RCC_USART2CLKSOURCE_SYSCLK: System Clock selected as USART2 clock
N  *            @arg RCC_USART2CLKSOURCE_LSE: LSE selected as USART2 clock
N  */
N#define __HAL_RCC_GET_USART2_SOURCE() ((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_USART2SEL)))
N
N/** @brief  Macro to configure the USART3 clock (USART3CLK).
N  *
N  * @param  __USART3_CLKSOURCE__: specifies the USART3 clock source.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_USART3CLKSOURCE_PCLK1: PCLK1 selected as USART3 clock
N  *            @arg RCC_USART3CLKSOURCE_HSI: HSI selected as USART3 clock
N  *            @arg RCC_USART3CLKSOURCE_SYSCLK: System Clock selected as USART3 clock
N  *            @arg RCC_USART3CLKSOURCE_LSE: LSE selected as USART3 clock
N  */
N#define __HAL_RCC_USART3_CONFIG(__USART3_CLKSOURCE__) \
N                  MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_USART3SEL, (uint32_t)(__USART3_CLKSOURCE__))
X#define __HAL_RCC_USART3_CONFIG(__USART3_CLKSOURCE__)                   MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_USART3SEL, (uint32_t)(__USART3_CLKSOURCE__))
N
N/** @brief  macro to get the USART3 clock source.
N  * @retval The clock source can be one of the following values:
N  *            @arg RCC_USART3CLKSOURCE_PCLK1: PCLK1 selected as USART3 clock
N  *            @arg RCC_USART3CLKSOURCE_HSI: HSI selected as USART3 clock
N  *            @arg RCC_USART3CLKSOURCE_SYSCLK: System Clock selected as USART3 clock
N  *            @arg RCC_USART3CLKSOURCE_LSE: LSE selected as USART3 clock
N  */
N#define __HAL_RCC_GET_USART3_SOURCE() ((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_USART3SEL)))
N
N /** @brief  Macro to configure the UART4 clock (UART4CLK).
N  *
N  * @param  __UART4_CLKSOURCE__: specifies the UART4 clock source.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_UART4CLKSOURCE_PCLK1: PCLK1 selected as UART4 clock
N  *            @arg RCC_UART4CLKSOURCE_HSI: HSI selected as UART4 clock
N  *            @arg RCC_UART4CLKSOURCE_SYSCLK: System Clock selected as UART4 clock
N  *            @arg RCC_UART4CLKSOURCE_LSE: LSE selected as UART4 clock
N  */
N#define __HAL_RCC_UART4_CONFIG(__UART4_CLKSOURCE__) \
N                  MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_UART4SEL, (uint32_t)(__UART4_CLKSOURCE__))
X#define __HAL_RCC_UART4_CONFIG(__UART4_CLKSOURCE__)                   MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_UART4SEL, (uint32_t)(__UART4_CLKSOURCE__))
N
N/** @brief  macro to get the UART4 clock source.
N  * @retval The clock source can be one of the following values:
N  *            @arg RCC_UART4CLKSOURCE_PCLK1: PCLK1 selected as UART4 clock
N  *            @arg RCC_UART4CLKSOURCE_HSI: HSI selected as UART4 clock
N  *            @arg RCC_UART4CLKSOURCE_SYSCLK: System Clock selected as UART4 clock
N  *            @arg RCC_UART4CLKSOURCE_LSE: LSE selected as UART4 clock
N  */
N#define __HAL_RCC_GET_UART4_SOURCE() ((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_UART4SEL)))
N
N /** @brief  Macro to configure the UART5 clock (UART5CLK).
N  *
N  * @param  __UART5_CLKSOURCE__: specifies the UART5 clock source.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_UART5CLKSOURCE_PCLK1: PCLK1 selected as UART5 clock
N  *            @arg RCC_UART5CLKSOURCE_HSI: HSI selected as UART5 clock
N  *            @arg RCC_UART5CLKSOURCE_SYSCLK: System Clock selected as UART5 clock
N  *            @arg RCC_UART5CLKSOURCE_LSE: LSE selected as UART5 clock
N  */
N#define __HAL_RCC_UART5_CONFIG(__UART5_CLKSOURCE__) \
N                  MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_UART5SEL, (uint32_t)(__UART5_CLKSOURCE__))
X#define __HAL_RCC_UART5_CONFIG(__UART5_CLKSOURCE__)                   MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_UART5SEL, (uint32_t)(__UART5_CLKSOURCE__))
N
N/** @brief  macro to get the UART5 clock source.
N  * @retval The clock source can be one of the following values:
N  *            @arg RCC_UART5CLKSOURCE_PCLK1: PCLK1 selected as UART5 clock
N  *            @arg RCC_UART5CLKSOURCE_HSI: HSI selected as UART5 clock
N  *            @arg RCC_UART5CLKSOURCE_SYSCLK: System Clock selected as UART5 clock
N  *            @arg RCC_UART5CLKSOURCE_LSE: LSE selected as UART5 clock
N  */
N#define __HAL_RCC_GET_UART5_SOURCE() ((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_UART5SEL)))
N
N /** @brief  Macro to configure the USART6 clock (USART6CLK).
N  *
N  * @param  __USART6_CLKSOURCE__: specifies the USART6 clock source.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_USART6CLKSOURCE_PCLK1: PCLK1 selected as USART6 clock
N  *            @arg RCC_USART6CLKSOURCE_HSI: HSI selected as USART6 clock
N  *            @arg RCC_USART6CLKSOURCE_SYSCLK: System Clock selected as USART6 clock
N  *            @arg RCC_USART6CLKSOURCE_LSE: LSE selected as USART6 clock
N  */
N#define __HAL_RCC_USART6_CONFIG(__USART6_CLKSOURCE__) \
N                  MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_USART6SEL, (uint32_t)(__USART6_CLKSOURCE__))
X#define __HAL_RCC_USART6_CONFIG(__USART6_CLKSOURCE__)                   MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_USART6SEL, (uint32_t)(__USART6_CLKSOURCE__))
N
N/** @brief  macro to get the USART6 clock source.
N  * @retval The clock source can be one of the following values:
N  *            @arg RCC_USART6CLKSOURCE_PCLK1: PCLK1 selected as USART6 clock
N  *            @arg RCC_USART6CLKSOURCE_HSI: HSI selected as USART6 clock
N  *            @arg RCC_USART6CLKSOURCE_SYSCLK: System Clock selected as USART6 clock
N  *            @arg RCC_USART6CLKSOURCE_LSE: LSE selected as USART6 clock
N  */
N#define __HAL_RCC_GET_USART6_SOURCE() ((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_USART6SEL)))
N
N /** @brief  Macro to configure the UART7 clock (UART7CLK).
N  *
N  * @param  __UART7_CLKSOURCE__: specifies the UART7 clock source.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_UART7CLKSOURCE_PCLK1: PCLK1 selected as UART7 clock
N  *            @arg RCC_UART7CLKSOURCE_HSI: HSI selected as UART7 clock
N  *            @arg RCC_UART7CLKSOURCE_SYSCLK: System Clock selected as UART7 clock
N  *            @arg RCC_UART7CLKSOURCE_LSE: LSE selected as UART7 clock
N  */
N#define __HAL_RCC_UART7_CONFIG(__UART7_CLKSOURCE__) \
N                  MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_UART7SEL, (uint32_t)(__UART7_CLKSOURCE__))
X#define __HAL_RCC_UART7_CONFIG(__UART7_CLKSOURCE__)                   MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_UART7SEL, (uint32_t)(__UART7_CLKSOURCE__))
N
N/** @brief  macro to get the UART7 clock source.
N  * @retval The clock source can be one of the following values:
N  *            @arg RCC_UART7CLKSOURCE_PCLK1: PCLK1 selected as UART7 clock
N  *            @arg RCC_UART7CLKSOURCE_HSI: HSI selected as UART7 clock
N  *            @arg RCC_UART7CLKSOURCE_SYSCLK: System Clock selected as UART7 clock
N  *            @arg RCC_UART7CLKSOURCE_LSE: LSE selected as UART7 clock
N  */
N#define __HAL_RCC_GET_UART7_SOURCE() ((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_UART7SEL)))
N
N/** @brief  Macro to configure the UART8 clock (UART8CLK).
N  *
N  * @param  __UART8_CLKSOURCE__: specifies the UART8 clock source.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_UART8CLKSOURCE_PCLK1: PCLK1 selected as UART8 clock
N  *            @arg RCC_UART8CLKSOURCE_HSI: HSI selected as UART8 clock
N  *            @arg RCC_UART8CLKSOURCE_SYSCLK: System Clock selected as UART8 clock
N  *            @arg RCC_UART8CLKSOURCE_LSE: LSE selected as UART8 clock
N  */
N#define __HAL_RCC_UART8_CONFIG(__UART8_CLKSOURCE__) \
N                  MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_UART8SEL, (uint32_t)(__UART8_CLKSOURCE__))
X#define __HAL_RCC_UART8_CONFIG(__UART8_CLKSOURCE__)                   MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_UART8SEL, (uint32_t)(__UART8_CLKSOURCE__))
N
N/** @brief  macro to get the UART8 clock source.
N  * @retval The clock source can be one of the following values:
N  *            @arg RCC_UART8CLKSOURCE_PCLK1: PCLK1 selected as UART8 clock
N  *            @arg RCC_UART8CLKSOURCE_HSI: HSI selected as UART8 clock
N  *            @arg RCC_UART8CLKSOURCE_SYSCLK: System Clock selected as UART8 clock
N  *            @arg RCC_UART8CLKSOURCE_LSE: LSE selected as UART8 clock
N  */
N#define __HAL_RCC_GET_UART8_SOURCE() ((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_UART8SEL)))
N
N/** @brief  Macro to configure the LPTIM1 clock (LPTIM1CLK).
N  *
N  * @param  __LPTIM1_CLKSOURCE__: specifies the LPTIM1 clock source.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_LPTIM1CLKSOURCE_PCLK: PCLK selected as LPTIM1 clock
N  *            @arg RCC_LPTIM1CLKSOURCE_HSI: HSI selected as LPTIM1 clock
N  *            @arg RCC_LPTIM1CLKSOURCE_LSI: LSI selected as LPTIM1 clock
N  *            @arg RCC_LPTIM1CLKSOURCE_LSE: LSE selected as LPTIM1 clock
N  */
N#define __HAL_RCC_LPTIM1_CONFIG(__LPTIM1_CLKSOURCE__) \
N                  MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_LPTIM1SEL, (uint32_t)(__LPTIM1_CLKSOURCE__))
X#define __HAL_RCC_LPTIM1_CONFIG(__LPTIM1_CLKSOURCE__)                   MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_LPTIM1SEL, (uint32_t)(__LPTIM1_CLKSOURCE__))
N
N/** @brief  macro to get the LPTIM1 clock source.
N  * @retval The clock source can be one of the following values:
N  *            @arg RCC_LPTIM1CLKSOURCE_PCLK: PCLK selected as LPTIM1 clock
N  *            @arg RCC_LPTIM1CLKSOURCE_HSI: HSI selected as LPTIM1 clock
N  *            @arg RCC_LPTIM1CLKSOURCE_LSI: LSI selected as LPTIM1 clock
N  *            @arg RCC_LPTIM1CLKSOURCE_LSE: LSE selected as LPTIM1 clock
N  */
N#define __HAL_RCC_GET_LPTIM1_SOURCE() ((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_LPTIM1SEL)))
N
N/** @brief  Macro to configure the CEC clock (CECCLK).
N  *
N  * @param  __CEC_CLKSOURCE__: specifies the CEC clock source.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_CECCLKSOURCE_LSE: LSE selected as CEC clock
N  *            @arg RCC_CECCLKSOURCE_HSI: HSI divided by 488 selected as CEC clock
N  */
N#define __HAL_RCC_CEC_CONFIG(__CEC_CLKSOURCE__) \
N                  MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_CECSEL, (uint32_t)(__CEC_CLKSOURCE__))
X#define __HAL_RCC_CEC_CONFIG(__CEC_CLKSOURCE__)                   MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_CECSEL, (uint32_t)(__CEC_CLKSOURCE__))
N
N/** @brief  macro to get the CEC clock source.
N  * @retval The clock source can be one of the following values:
N  *            @arg RCC_CECCLKSOURCE_LSE: LSE selected as CEC clock
N  *            @arg RCC_CECCLKSOURCE_HSI: HSI selected as CEC clock
N  */
N#define __HAL_RCC_GET_CEC_SOURCE() ((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_CECSEL)))
N
N/** @brief  Macro to configure the CLK48 source (CLK48CLK).
N  *
N  * @param  __CLK48_SOURCE__: specifies the CLK48 clock source.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_CLK48SOURCE_PLL: PLL selected as CLK48 source
N  *            @arg RCC_CLK48SOURCE_PLLSAIP: PLLSAIP selected as CLK48 source
N  */
N#define __HAL_RCC_CLK48_CONFIG(__CLK48_SOURCE__) \
N                  MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_CK48MSEL, (uint32_t)(__CLK48_SOURCE__))
X#define __HAL_RCC_CLK48_CONFIG(__CLK48_SOURCE__)                   MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_CK48MSEL, (uint32_t)(__CLK48_SOURCE__))
N
N/** @brief  macro to get the CLK48 source.
N  * @retval The clock source can be one of the following values:
N  *            @arg RCC_CLK48SOURCE_PLL: PLL used as CLK48 source
N  *            @arg RCC_CLK48SOURCE_PLLSAIP: PLLSAIP used as CLK48 source
N  */
N#define __HAL_RCC_GET_CLK48_SOURCE() ((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_CK48MSEL)))
N
N/** @brief  Macro to configure the SDMMC1 clock (SDMMC1CLK).
N  *
N  * @param  __SDMMC1_CLKSOURCE__: specifies the SDMMC1 clock source.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_SDMMC1CLKSOURCE_CLK48: CLK48 selected as SDMMC clock
N  *            @arg RCC_SDMMC1CLKSOURCE_SYSCLK: SYSCLK selected as SDMMC clock
N  */
N#define __HAL_RCC_SDMMC1_CONFIG(__SDMMC1_CLKSOURCE__) \
N                  MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_SDMMC1SEL, (uint32_t)(__SDMMC1_CLKSOURCE__))
X#define __HAL_RCC_SDMMC1_CONFIG(__SDMMC1_CLKSOURCE__)                   MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_SDMMC1SEL, (uint32_t)(__SDMMC1_CLKSOURCE__))
N
N/** @brief  macro to get the SDMMC1 clock source.
N  * @retval The clock source can be one of the following values:
N  *            @arg RCC_SDMMC1CLKSOURCE_CLK48: CLK48 selected as SDMMC1 clock
N  *            @arg RCC_SDMMC1CLKSOURCE_SYSCLK: SYSCLK selected as SDMMC1 clock
N  */
N#define __HAL_RCC_GET_SDMMC1_SOURCE() ((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_SDMMC1SEL)))
N
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)                    
X#if 0L || 1L || 0L || 0L || 0L                    
N/** @brief  Macro to configure the SDMMC2 clock (SDMMC2CLK).
N  * @param  __SDMMC2_CLKSOURCE__: specifies the SDMMC2 clock source.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_SDMMC2CLKSOURCE_CLK48: CLK48 selected as SDMMC2 clock
N  *            @arg RCC_SDMMC2CLKSOURCE_SYSCLK: SYSCLK selected as SDMMC2 clock
N  */
N#define __HAL_RCC_SDMMC2_CONFIG(__SDMMC2_CLKSOURCE__) \
N                  MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_SDMMC2SEL, (uint32_t)(__SDMMC2_CLKSOURCE__))
X#define __HAL_RCC_SDMMC2_CONFIG(__SDMMC2_CLKSOURCE__)                   MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_SDMMC2SEL, (uint32_t)(__SDMMC2_CLKSOURCE__))
N
N/** @brief  macro to get the SDMMC2 clock source.
N  * @retval The clock source can be one of the following values:
N  *            @arg RCC_SDMMC2CLKSOURCE_CLK48: CLK48 selected as SDMMC2 clock
N  *            @arg RCC_SDMMC2CLKSOURCE_SYSCLK: SYSCLK selected as SDMMC2 clock
N  */
N#define __HAL_RCC_GET_SDMMC2_SOURCE() ((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_SDMMC2SEL)))
N                    
N/** @brief  Macro to configure the DFSDM1 clock
N  * @param  __DFSDM1_CLKSOURCE__: specifies the DFSDM1  clock source.
N  *         This parameter can be one of the following values:
N  *            @arg RCC_DFSDM1CLKSOURCE_PCLK: PCLK2 Clock selected as DFSDM clock
N  *            @arg RCC_DFSDMCLKSOURCE_SYSCLK: System Clock selected as DFSDM clock
N  */
N#define __HAL_RCC_DFSDM1_CONFIG(__DFSDM1_CLKSOURCE__) \
N                  MODIFY_REG(RCC->DCKCFGR1, RCC_DCKCFGR1_DFSDM1SEL, (uint32_t)(__DFSDM1_CLKSOURCE__))
X#define __HAL_RCC_DFSDM1_CONFIG(__DFSDM1_CLKSOURCE__)                   MODIFY_REG(RCC->DCKCFGR1, RCC_DCKCFGR1_DFSDM1SEL, (uint32_t)(__DFSDM1_CLKSOURCE__))
N
N/** @brief  Macro to get the DFSDM1 clock source.
N  * @retval The clock source can be one of the following values:
N  *            @arg RCC_DFSDM1CLKSOURCE_PCLK:  PCLK2 Clock selected as DFSDM1 clock
N  *            @arg RCC_DFSDM1CLKSOURCE_SYSCLK:   System Clock selected as DFSDM1 clock
N  */
N#define __HAL_RCC_GET_DFSDM1_SOURCE() ((uint32_t)(READ_BIT(RCC->DCKCFGR1, RCC_DCKCFGR1_DFSDM1SEL)))
N
N/** @brief  Macro to configure the DFSDM1 Audio clock
N  * @param  __DFSDM1AUDIO_CLKSOURCE__: specifies the DFSDM1 Audio clock source.
N  *         This parameter can be one of the following values:
N  *            @arg RCC_DFSDM1AUDIOCLKSOURCE_SAI1:  SAI1 Clock selected as DFSDM1 Audio clock
N  *            @arg RCC_DFSDM1AUDIOCLKSOURCE_SAI2:  SAI2 Clock selected as DFSDM1 Audio clock
N  */
N#define __HAL_RCC_DFSDM1AUDIO_CONFIG(__DFSDM1AUDIO_CLKSOURCE__) \
N                  MODIFY_REG(RCC->DCKCFGR1, RCC_DCKCFGR1_ADFSDM1SEL, (uint32_t)(__DFSDM1AUDIO_CLKSOURCE__))
X#define __HAL_RCC_DFSDM1AUDIO_CONFIG(__DFSDM1AUDIO_CLKSOURCE__)                   MODIFY_REG(RCC->DCKCFGR1, RCC_DCKCFGR1_ADFSDM1SEL, (uint32_t)(__DFSDM1AUDIO_CLKSOURCE__))
N
N/** @brief  Macro to get the DFSDM1 Audio clock source.
N  * @retval The clock source can be one of the following values:
N  *            @arg RCC_DFSDM1AUDIOCLKSOURCE_SAI1:  SAI1 Clock selected as DFSDM1 Audio clock
N  *            @arg RCC_DFSDM1AUDIOCLKSOURCE_SAI2:  SAI2 Clock selected as DFSDM1 Audio clock
N  */
N#define __HAL_RCC_GET_DFSDM1AUDIO_SOURCE() ((uint32_t)(READ_BIT(RCC->DCKCFGR1, RCC_DCKCFGR1_ADFSDM1SEL)))                   
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N
N#if defined (STM32F769xx) || defined (STM32F779xx)
X#if 0L || 0L
S/** @brief  Macro to configure the DSI clock.
S  * @param  __DSI_CLKSOURCE__: specifies the DSI clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_DSICLKSOURCE_PLLR: PLLR output used as DSI clock. 
S  *            @arg RCC_DSICLKSOURCE_DSIPHY: DSI-PHY output used as DSI clock. 
S  */
S#define __HAL_RCC_DSI_CONFIG(__DSI_CLKSOURCE__) (MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_DSISEL, (uint32_t)(__DSI_CLKSOURCE__)))
S
S/** @brief  Macro to Get the DSI clock.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_DSICLKSOURCE_PLLR: PLLR output used as DSI clock. 
S  *            @arg RCC_DSICLKSOURCE_DSIPHY: DSI-PHY output used as DSI clock. 
S  */
S#define __HAL_RCC_GET_DSI_SOURCE() (READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_DSISEL))                    
N#endif /* STM32F769xx || STM32F779xx */                    
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup RCCEx_Exported_Functions_Group1
N  * @{
N  */
NHAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit);
Nvoid HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit);
Nuint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk);
N
N/**
N  * @}
N  */ 
N/* Private macros ------------------------------------------------------------*/
N/** @addtogroup RCCEx_Private_Macros RCCEx Private Macros
N  * @{
N  */
N/** @defgroup RCCEx_IS_RCC_Definitions RCC Private macros to check input parameters
N  * @{
N  */
N#if defined(STM32F756xx) || defined(STM32F746xx)
X#if 0L || 0L
S#define IS_RCC_PERIPHCLOCK(SELECTION)  \
S               ((((SELECTION) & RCC_PERIPHCLK_I2S)         == RCC_PERIPHCLK_I2S)     || \
S                (((SELECTION) & RCC_PERIPHCLK_LTDC)        == RCC_PERIPHCLK_LTDC)    || \
S                (((SELECTION) & RCC_PERIPHCLK_TIM)         == RCC_PERIPHCLK_TIM)     || \
S                (((SELECTION) & RCC_PERIPHCLK_USART1)      == RCC_PERIPHCLK_USART1)  || \
S                (((SELECTION) & RCC_PERIPHCLK_USART2)      == RCC_PERIPHCLK_USART2)  || \
S                (((SELECTION) & RCC_PERIPHCLK_USART3)      == RCC_PERIPHCLK_USART3)  || \
S                (((SELECTION) & RCC_PERIPHCLK_UART4)       == RCC_PERIPHCLK_UART4)   || \
S                (((SELECTION) & RCC_PERIPHCLK_UART5)       == RCC_PERIPHCLK_UART5)   || \
S                (((SELECTION) & RCC_PERIPHCLK_USART6)      == RCC_PERIPHCLK_USART6)  || \
S                (((SELECTION) & RCC_PERIPHCLK_UART7)       == RCC_PERIPHCLK_UART7)   || \
S                (((SELECTION) & RCC_PERIPHCLK_UART8)       == RCC_PERIPHCLK_UART8)   || \
S                (((SELECTION) & RCC_PERIPHCLK_I2C1)        == RCC_PERIPHCLK_I2C1)    || \
S                (((SELECTION) & RCC_PERIPHCLK_I2C2)        == RCC_PERIPHCLK_I2C2)    || \
S                (((SELECTION) & RCC_PERIPHCLK_I2C3)        == RCC_PERIPHCLK_I2C3)    || \
S                (((SELECTION) & RCC_PERIPHCLK_I2C4)        == RCC_PERIPHCLK_I2C4)    || \
S                (((SELECTION) & RCC_PERIPHCLK_LPTIM1)      == RCC_PERIPHCLK_LPTIM1)  || \
S                (((SELECTION) & RCC_PERIPHCLK_SAI1)        == RCC_PERIPHCLK_SAI1)    || \
S                (((SELECTION) & RCC_PERIPHCLK_SAI2)        == RCC_PERIPHCLK_SAI2)    || \
S                (((SELECTION) & RCC_PERIPHCLK_CLK48)       == RCC_PERIPHCLK_CLK48)   || \
S                (((SELECTION) & RCC_PERIPHCLK_CEC)         == RCC_PERIPHCLK_CEC)     || \
S                (((SELECTION) & RCC_PERIPHCLK_SDMMC1)      == RCC_PERIPHCLK_SDMMC1)  || \
S                (((SELECTION) & RCC_PERIPHCLK_SPDIFRX)     == RCC_PERIPHCLK_SPDIFRX) || \
S                (((SELECTION) & RCC_PERIPHCLK_RTC)         == RCC_PERIPHCLK_RTC))
X#define IS_RCC_PERIPHCLOCK(SELECTION)                 ((((SELECTION) & RCC_PERIPHCLK_I2S)         == RCC_PERIPHCLK_I2S)     ||                 (((SELECTION) & RCC_PERIPHCLK_LTDC)        == RCC_PERIPHCLK_LTDC)    ||                 (((SELECTION) & RCC_PERIPHCLK_TIM)         == RCC_PERIPHCLK_TIM)     ||                 (((SELECTION) & RCC_PERIPHCLK_USART1)      == RCC_PERIPHCLK_USART1)  ||                 (((SELECTION) & RCC_PERIPHCLK_USART2)      == RCC_PERIPHCLK_USART2)  ||                 (((SELECTION) & RCC_PERIPHCLK_USART3)      == RCC_PERIPHCLK_USART3)  ||                 (((SELECTION) & RCC_PERIPHCLK_UART4)       == RCC_PERIPHCLK_UART4)   ||                 (((SELECTION) & RCC_PERIPHCLK_UART5)       == RCC_PERIPHCLK_UART5)   ||                 (((SELECTION) & RCC_PERIPHCLK_USART6)      == RCC_PERIPHCLK_USART6)  ||                 (((SELECTION) & RCC_PERIPHCLK_UART7)       == RCC_PERIPHCLK_UART7)   ||                 (((SELECTION) & RCC_PERIPHCLK_UART8)       == RCC_PERIPHCLK_UART8)   ||                 (((SELECTION) & RCC_PERIPHCLK_I2C1)        == RCC_PERIPHCLK_I2C1)    ||                 (((SELECTION) & RCC_PERIPHCLK_I2C2)        == RCC_PERIPHCLK_I2C2)    ||                 (((SELECTION) & RCC_PERIPHCLK_I2C3)        == RCC_PERIPHCLK_I2C3)    ||                 (((SELECTION) & RCC_PERIPHCLK_I2C4)        == RCC_PERIPHCLK_I2C4)    ||                 (((SELECTION) & RCC_PERIPHCLK_LPTIM1)      == RCC_PERIPHCLK_LPTIM1)  ||                 (((SELECTION) & RCC_PERIPHCLK_SAI1)        == RCC_PERIPHCLK_SAI1)    ||                 (((SELECTION) & RCC_PERIPHCLK_SAI2)        == RCC_PERIPHCLK_SAI2)    ||                 (((SELECTION) & RCC_PERIPHCLK_CLK48)       == RCC_PERIPHCLK_CLK48)   ||                 (((SELECTION) & RCC_PERIPHCLK_CEC)         == RCC_PERIPHCLK_CEC)     ||                 (((SELECTION) & RCC_PERIPHCLK_SDMMC1)      == RCC_PERIPHCLK_SDMMC1)  ||                 (((SELECTION) & RCC_PERIPHCLK_SPDIFRX)     == RCC_PERIPHCLK_SPDIFRX) ||                 (((SELECTION) & RCC_PERIPHCLK_RTC)         == RCC_PERIPHCLK_RTC))
S#elif defined(STM32F745xx)
X#elif 0L
S#define IS_RCC_PERIPHCLOCK(SELECTION)  \
S               ((((SELECTION) & RCC_PERIPHCLK_I2S)         == RCC_PERIPHCLK_I2S)     || \
S                (((SELECTION) & RCC_PERIPHCLK_TIM)         == RCC_PERIPHCLK_TIM)     || \
S                (((SELECTION) & RCC_PERIPHCLK_USART1)      == RCC_PERIPHCLK_USART1)  || \
S                (((SELECTION) & RCC_PERIPHCLK_USART2)      == RCC_PERIPHCLK_USART2)  || \
S                (((SELECTION) & RCC_PERIPHCLK_USART3)      == RCC_PERIPHCLK_USART3)  || \
S                (((SELECTION) & RCC_PERIPHCLK_UART4)       == RCC_PERIPHCLK_UART4)   || \
S                (((SELECTION) & RCC_PERIPHCLK_UART5)       == RCC_PERIPHCLK_UART5)   || \
S                (((SELECTION) & RCC_PERIPHCLK_USART6)      == RCC_PERIPHCLK_USART6)  || \
S                (((SELECTION) & RCC_PERIPHCLK_UART7)       == RCC_PERIPHCLK_UART7)   || \
S                (((SELECTION) & RCC_PERIPHCLK_UART8)       == RCC_PERIPHCLK_UART8)   || \
S                (((SELECTION) & RCC_PERIPHCLK_I2C1)        == RCC_PERIPHCLK_I2C1)    || \
S                (((SELECTION) & RCC_PERIPHCLK_I2C2)        == RCC_PERIPHCLK_I2C2)    || \
S                (((SELECTION) & RCC_PERIPHCLK_I2C3)        == RCC_PERIPHCLK_I2C3)    || \
S                (((SELECTION) & RCC_PERIPHCLK_I2C4)        == RCC_PERIPHCLK_I2C4)    || \
S                (((SELECTION) & RCC_PERIPHCLK_LPTIM1)      == RCC_PERIPHCLK_LPTIM1)  || \
S                (((SELECTION) & RCC_PERIPHCLK_SAI1)        == RCC_PERIPHCLK_SAI1)    || \
S                (((SELECTION) & RCC_PERIPHCLK_SAI2)        == RCC_PERIPHCLK_SAI2)    || \
S                (((SELECTION) & RCC_PERIPHCLK_CLK48)       == RCC_PERIPHCLK_CLK48)   || \
S                (((SELECTION) & RCC_PERIPHCLK_CEC)         == RCC_PERIPHCLK_CEC)     || \
S                (((SELECTION) & RCC_PERIPHCLK_SDMMC1)      == RCC_PERIPHCLK_SDMMC1)  || \
S                (((SELECTION) & RCC_PERIPHCLK_SPDIFRX)     == RCC_PERIPHCLK_SPDIFRX) || \
S                (((SELECTION) & RCC_PERIPHCLK_RTC)         == RCC_PERIPHCLK_RTC))
X#define IS_RCC_PERIPHCLOCK(SELECTION)                 ((((SELECTION) & RCC_PERIPHCLK_I2S)         == RCC_PERIPHCLK_I2S)     ||                 (((SELECTION) & RCC_PERIPHCLK_TIM)         == RCC_PERIPHCLK_TIM)     ||                 (((SELECTION) & RCC_PERIPHCLK_USART1)      == RCC_PERIPHCLK_USART1)  ||                 (((SELECTION) & RCC_PERIPHCLK_USART2)      == RCC_PERIPHCLK_USART2)  ||                 (((SELECTION) & RCC_PERIPHCLK_USART3)      == RCC_PERIPHCLK_USART3)  ||                 (((SELECTION) & RCC_PERIPHCLK_UART4)       == RCC_PERIPHCLK_UART4)   ||                 (((SELECTION) & RCC_PERIPHCLK_UART5)       == RCC_PERIPHCLK_UART5)   ||                 (((SELECTION) & RCC_PERIPHCLK_USART6)      == RCC_PERIPHCLK_USART6)  ||                 (((SELECTION) & RCC_PERIPHCLK_UART7)       == RCC_PERIPHCLK_UART7)   ||                 (((SELECTION) & RCC_PERIPHCLK_UART8)       == RCC_PERIPHCLK_UART8)   ||                 (((SELECTION) & RCC_PERIPHCLK_I2C1)        == RCC_PERIPHCLK_I2C1)    ||                 (((SELECTION) & RCC_PERIPHCLK_I2C2)        == RCC_PERIPHCLK_I2C2)    ||                 (((SELECTION) & RCC_PERIPHCLK_I2C3)        == RCC_PERIPHCLK_I2C3)    ||                 (((SELECTION) & RCC_PERIPHCLK_I2C4)        == RCC_PERIPHCLK_I2C4)    ||                 (((SELECTION) & RCC_PERIPHCLK_LPTIM1)      == RCC_PERIPHCLK_LPTIM1)  ||                 (((SELECTION) & RCC_PERIPHCLK_SAI1)        == RCC_PERIPHCLK_SAI1)    ||                 (((SELECTION) & RCC_PERIPHCLK_SAI2)        == RCC_PERIPHCLK_SAI2)    ||                 (((SELECTION) & RCC_PERIPHCLK_CLK48)       == RCC_PERIPHCLK_CLK48)   ||                 (((SELECTION) & RCC_PERIPHCLK_CEC)         == RCC_PERIPHCLK_CEC)     ||                 (((SELECTION) & RCC_PERIPHCLK_SDMMC1)      == RCC_PERIPHCLK_SDMMC1)  ||                 (((SELECTION) & RCC_PERIPHCLK_SPDIFRX)     == RCC_PERIPHCLK_SPDIFRX) ||                 (((SELECTION) & RCC_PERIPHCLK_RTC)         == RCC_PERIPHCLK_RTC))
N#elif defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#elif 1L || 0L || 0L || 0L
N#define IS_RCC_PERIPHCLOCK(SELECTION)  \
N               ((((SELECTION) & RCC_PERIPHCLK_I2S)         == RCC_PERIPHCLK_I2S)     || \
N                (((SELECTION) & RCC_PERIPHCLK_LTDC)        == RCC_PERIPHCLK_LTDC)    || \
N                (((SELECTION) & RCC_PERIPHCLK_TIM)         == RCC_PERIPHCLK_TIM)     || \
N                (((SELECTION) & RCC_PERIPHCLK_USART1)      == RCC_PERIPHCLK_USART1)  || \
N                (((SELECTION) & RCC_PERIPHCLK_USART2)      == RCC_PERIPHCLK_USART2)  || \
N                (((SELECTION) & RCC_PERIPHCLK_USART3)      == RCC_PERIPHCLK_USART3)  || \
N                (((SELECTION) & RCC_PERIPHCLK_UART4)       == RCC_PERIPHCLK_UART4)   || \
N                (((SELECTION) & RCC_PERIPHCLK_UART5)       == RCC_PERIPHCLK_UART5)   || \
N                (((SELECTION) & RCC_PERIPHCLK_USART6)      == RCC_PERIPHCLK_USART6)  || \
N                (((SELECTION) & RCC_PERIPHCLK_UART7)       == RCC_PERIPHCLK_UART7)   || \
N                (((SELECTION) & RCC_PERIPHCLK_UART8)       == RCC_PERIPHCLK_UART8)   || \
N                (((SELECTION) & RCC_PERIPHCLK_I2C1)        == RCC_PERIPHCLK_I2C1)    || \
N                (((SELECTION) & RCC_PERIPHCLK_I2C2)        == RCC_PERIPHCLK_I2C2)    || \
N                (((SELECTION) & RCC_PERIPHCLK_I2C3)        == RCC_PERIPHCLK_I2C3)    || \
N                (((SELECTION) & RCC_PERIPHCLK_I2C4)        == RCC_PERIPHCLK_I2C4)    || \
N                (((SELECTION) & RCC_PERIPHCLK_LPTIM1)      == RCC_PERIPHCLK_LPTIM1)  || \
N                (((SELECTION) & RCC_PERIPHCLK_SAI1)        == RCC_PERIPHCLK_SAI1)    || \
N                (((SELECTION) & RCC_PERIPHCLK_SAI2)        == RCC_PERIPHCLK_SAI2)    || \
N                (((SELECTION) & RCC_PERIPHCLK_CLK48)       == RCC_PERIPHCLK_CLK48)   || \
N                (((SELECTION) & RCC_PERIPHCLK_CEC)         == RCC_PERIPHCLK_CEC)     || \
N                (((SELECTION) & RCC_PERIPHCLK_SDMMC1)      == RCC_PERIPHCLK_SDMMC1)  || \
N                (((SELECTION) & RCC_PERIPHCLK_SDMMC2)      == RCC_PERIPHCLK_SDMMC2)  || \
N                (((SELECTION) & RCC_PERIPHCLK_DFSDM1)       == RCC_PERIPHCLK_DFSDM1)   || \
N                (((SELECTION) & RCC_PERIPHCLK_DFSDM1_AUDIO) == RCC_PERIPHCLK_DFSDM1_AUDIO) || \
N                (((SELECTION) & RCC_PERIPHCLK_SPDIFRX)     == RCC_PERIPHCLK_SPDIFRX) || \
N                (((SELECTION) & RCC_PERIPHCLK_RTC)         == RCC_PERIPHCLK_RTC))                
X#define IS_RCC_PERIPHCLOCK(SELECTION)                 ((((SELECTION) & RCC_PERIPHCLK_I2S)         == RCC_PERIPHCLK_I2S)     ||                 (((SELECTION) & RCC_PERIPHCLK_LTDC)        == RCC_PERIPHCLK_LTDC)    ||                 (((SELECTION) & RCC_PERIPHCLK_TIM)         == RCC_PERIPHCLK_TIM)     ||                 (((SELECTION) & RCC_PERIPHCLK_USART1)      == RCC_PERIPHCLK_USART1)  ||                 (((SELECTION) & RCC_PERIPHCLK_USART2)      == RCC_PERIPHCLK_USART2)  ||                 (((SELECTION) & RCC_PERIPHCLK_USART3)      == RCC_PERIPHCLK_USART3)  ||                 (((SELECTION) & RCC_PERIPHCLK_UART4)       == RCC_PERIPHCLK_UART4)   ||                 (((SELECTION) & RCC_PERIPHCLK_UART5)       == RCC_PERIPHCLK_UART5)   ||                 (((SELECTION) & RCC_PERIPHCLK_USART6)      == RCC_PERIPHCLK_USART6)  ||                 (((SELECTION) & RCC_PERIPHCLK_UART7)       == RCC_PERIPHCLK_UART7)   ||                 (((SELECTION) & RCC_PERIPHCLK_UART8)       == RCC_PERIPHCLK_UART8)   ||                 (((SELECTION) & RCC_PERIPHCLK_I2C1)        == RCC_PERIPHCLK_I2C1)    ||                 (((SELECTION) & RCC_PERIPHCLK_I2C2)        == RCC_PERIPHCLK_I2C2)    ||                 (((SELECTION) & RCC_PERIPHCLK_I2C3)        == RCC_PERIPHCLK_I2C3)    ||                 (((SELECTION) & RCC_PERIPHCLK_I2C4)        == RCC_PERIPHCLK_I2C4)    ||                 (((SELECTION) & RCC_PERIPHCLK_LPTIM1)      == RCC_PERIPHCLK_LPTIM1)  ||                 (((SELECTION) & RCC_PERIPHCLK_SAI1)        == RCC_PERIPHCLK_SAI1)    ||                 (((SELECTION) & RCC_PERIPHCLK_SAI2)        == RCC_PERIPHCLK_SAI2)    ||                 (((SELECTION) & RCC_PERIPHCLK_CLK48)       == RCC_PERIPHCLK_CLK48)   ||                 (((SELECTION) & RCC_PERIPHCLK_CEC)         == RCC_PERIPHCLK_CEC)     ||                 (((SELECTION) & RCC_PERIPHCLK_SDMMC1)      == RCC_PERIPHCLK_SDMMC1)  ||                 (((SELECTION) & RCC_PERIPHCLK_SDMMC2)      == RCC_PERIPHCLK_SDMMC2)  ||                 (((SELECTION) & RCC_PERIPHCLK_DFSDM1)       == RCC_PERIPHCLK_DFSDM1)   ||                 (((SELECTION) & RCC_PERIPHCLK_DFSDM1_AUDIO) == RCC_PERIPHCLK_DFSDM1_AUDIO) ||                 (((SELECTION) & RCC_PERIPHCLK_SPDIFRX)     == RCC_PERIPHCLK_SPDIFRX) ||                 (((SELECTION) & RCC_PERIPHCLK_RTC)         == RCC_PERIPHCLK_RTC))                
N#elif defined (STM32F765xx)
S#define IS_RCC_PERIPHCLOCK(SELECTION)  \
S               ((((SELECTION) & RCC_PERIPHCLK_I2S)         == RCC_PERIPHCLK_I2S)     || \
S                (((SELECTION) & RCC_PERIPHCLK_TIM)         == RCC_PERIPHCLK_TIM)     || \
S                (((SELECTION) & RCC_PERIPHCLK_USART1)      == RCC_PERIPHCLK_USART1)  || \
S                (((SELECTION) & RCC_PERIPHCLK_USART2)      == RCC_PERIPHCLK_USART2)  || \
S                (((SELECTION) & RCC_PERIPHCLK_USART3)      == RCC_PERIPHCLK_USART3)  || \
S                (((SELECTION) & RCC_PERIPHCLK_UART4)       == RCC_PERIPHCLK_UART4)   || \
S                (((SELECTION) & RCC_PERIPHCLK_UART5)       == RCC_PERIPHCLK_UART5)   || \
S                (((SELECTION) & RCC_PERIPHCLK_USART6)      == RCC_PERIPHCLK_USART6)  || \
S                (((SELECTION) & RCC_PERIPHCLK_UART7)       == RCC_PERIPHCLK_UART7)   || \
S                (((SELECTION) & RCC_PERIPHCLK_UART8)       == RCC_PERIPHCLK_UART8)   || \
S                (((SELECTION) & RCC_PERIPHCLK_I2C1)        == RCC_PERIPHCLK_I2C1)    || \
S                (((SELECTION) & RCC_PERIPHCLK_I2C2)        == RCC_PERIPHCLK_I2C2)    || \
S                (((SELECTION) & RCC_PERIPHCLK_I2C3)        == RCC_PERIPHCLK_I2C3)    || \
S                (((SELECTION) & RCC_PERIPHCLK_I2C4)        == RCC_PERIPHCLK_I2C4)    || \
S                (((SELECTION) & RCC_PERIPHCLK_LPTIM1)      == RCC_PERIPHCLK_LPTIM1)  || \
S                (((SELECTION) & RCC_PERIPHCLK_SAI1)        == RCC_PERIPHCLK_SAI1)    || \
S                (((SELECTION) & RCC_PERIPHCLK_SAI2)        == RCC_PERIPHCLK_SAI2)    || \
S                (((SELECTION) & RCC_PERIPHCLK_CLK48)       == RCC_PERIPHCLK_CLK48)   || \
S                (((SELECTION) & RCC_PERIPHCLK_CEC)         == RCC_PERIPHCLK_CEC)     || \
S                (((SELECTION) & RCC_PERIPHCLK_SDMMC1)      == RCC_PERIPHCLK_SDMMC1)  || \
S                (((SELECTION) & RCC_PERIPHCLK_SDMMC2)      == RCC_PERIPHCLK_SDMMC2)  || \
S                (((SELECTION) & RCC_PERIPHCLK_DFSDM1)       == RCC_PERIPHCLK_DFSDM1)   || \
S                (((SELECTION) & RCC_PERIPHCLK_DFSDM1_AUDIO) == RCC_PERIPHCLK_DFSDM1_AUDIO) || \
S                (((SELECTION) & RCC_PERIPHCLK_SPDIFRX)     == RCC_PERIPHCLK_SPDIFRX) || \
S                (((SELECTION) & RCC_PERIPHCLK_RTC)         == RCC_PERIPHCLK_RTC)) 
X#define IS_RCC_PERIPHCLOCK(SELECTION)                 ((((SELECTION) & RCC_PERIPHCLK_I2S)         == RCC_PERIPHCLK_I2S)     ||                 (((SELECTION) & RCC_PERIPHCLK_TIM)         == RCC_PERIPHCLK_TIM)     ||                 (((SELECTION) & RCC_PERIPHCLK_USART1)      == RCC_PERIPHCLK_USART1)  ||                 (((SELECTION) & RCC_PERIPHCLK_USART2)      == RCC_PERIPHCLK_USART2)  ||                 (((SELECTION) & RCC_PERIPHCLK_USART3)      == RCC_PERIPHCLK_USART3)  ||                 (((SELECTION) & RCC_PERIPHCLK_UART4)       == RCC_PERIPHCLK_UART4)   ||                 (((SELECTION) & RCC_PERIPHCLK_UART5)       == RCC_PERIPHCLK_UART5)   ||                 (((SELECTION) & RCC_PERIPHCLK_USART6)      == RCC_PERIPHCLK_USART6)  ||                 (((SELECTION) & RCC_PERIPHCLK_UART7)       == RCC_PERIPHCLK_UART7)   ||                 (((SELECTION) & RCC_PERIPHCLK_UART8)       == RCC_PERIPHCLK_UART8)   ||                 (((SELECTION) & RCC_PERIPHCLK_I2C1)        == RCC_PERIPHCLK_I2C1)    ||                 (((SELECTION) & RCC_PERIPHCLK_I2C2)        == RCC_PERIPHCLK_I2C2)    ||                 (((SELECTION) & RCC_PERIPHCLK_I2C3)        == RCC_PERIPHCLK_I2C3)    ||                 (((SELECTION) & RCC_PERIPHCLK_I2C4)        == RCC_PERIPHCLK_I2C4)    ||                 (((SELECTION) & RCC_PERIPHCLK_LPTIM1)      == RCC_PERIPHCLK_LPTIM1)  ||                 (((SELECTION) & RCC_PERIPHCLK_SAI1)        == RCC_PERIPHCLK_SAI1)    ||                 (((SELECTION) & RCC_PERIPHCLK_SAI2)        == RCC_PERIPHCLK_SAI2)    ||                 (((SELECTION) & RCC_PERIPHCLK_CLK48)       == RCC_PERIPHCLK_CLK48)   ||                 (((SELECTION) & RCC_PERIPHCLK_CEC)         == RCC_PERIPHCLK_CEC)     ||                 (((SELECTION) & RCC_PERIPHCLK_SDMMC1)      == RCC_PERIPHCLK_SDMMC1)  ||                 (((SELECTION) & RCC_PERIPHCLK_SDMMC2)      == RCC_PERIPHCLK_SDMMC2)  ||                 (((SELECTION) & RCC_PERIPHCLK_DFSDM1)       == RCC_PERIPHCLK_DFSDM1)   ||                 (((SELECTION) & RCC_PERIPHCLK_DFSDM1_AUDIO) == RCC_PERIPHCLK_DFSDM1_AUDIO) ||                 (((SELECTION) & RCC_PERIPHCLK_SPDIFRX)     == RCC_PERIPHCLK_SPDIFRX) ||                 (((SELECTION) & RCC_PERIPHCLK_RTC)         == RCC_PERIPHCLK_RTC)) 
N#endif /* STM32F746xx || STM32F756xx */
N#define IS_RCC_PLLI2SN_VALUE(VALUE) ((50 <= (VALUE)) && ((VALUE) <= 432))
N#define IS_RCC_PLLI2SP_VALUE(VALUE) (((VALUE) == RCC_PLLI2SP_DIV2) ||\
N                                     ((VALUE) == RCC_PLLI2SP_DIV4) ||\
N                                     ((VALUE) == RCC_PLLI2SP_DIV6) ||\
N                                     ((VALUE) == RCC_PLLI2SP_DIV8))                 
X#define IS_RCC_PLLI2SP_VALUE(VALUE) (((VALUE) == RCC_PLLI2SP_DIV2) ||                                     ((VALUE) == RCC_PLLI2SP_DIV4) ||                                     ((VALUE) == RCC_PLLI2SP_DIV6) ||                                     ((VALUE) == RCC_PLLI2SP_DIV8))                 
N#define IS_RCC_PLLI2SQ_VALUE(VALUE) ((2 <= (VALUE)) && ((VALUE) <= 15))
N#define IS_RCC_PLLI2SR_VALUE(VALUE) ((2 <= (VALUE)) && ((VALUE) <= 7))
N
N#define IS_RCC_PLLSAIN_VALUE(VALUE) ((50 <= (VALUE)) && ((VALUE) <= 432))
N#define IS_RCC_PLLSAIP_VALUE(VALUE) (((VALUE) == RCC_PLLSAIP_DIV2) ||\
N                                     ((VALUE) == RCC_PLLSAIP_DIV4) ||\
N                                     ((VALUE) == RCC_PLLSAIP_DIV6) ||\
N                                     ((VALUE) == RCC_PLLSAIP_DIV8))
X#define IS_RCC_PLLSAIP_VALUE(VALUE) (((VALUE) == RCC_PLLSAIP_DIV2) ||                                     ((VALUE) == RCC_PLLSAIP_DIV4) ||                                     ((VALUE) == RCC_PLLSAIP_DIV6) ||                                     ((VALUE) == RCC_PLLSAIP_DIV8))
N#define IS_RCC_PLLSAIQ_VALUE(VALUE) ((2 <= (VALUE)) && ((VALUE) <= 15))
N#define IS_RCC_PLLSAIR_VALUE(VALUE) ((2 <= (VALUE)) && ((VALUE) <= 7))  
N
N#define IS_RCC_PLLSAI_DIVQ_VALUE(VALUE) ((1 <= (VALUE)) && ((VALUE) <= 32))
N
N#define IS_RCC_PLLI2S_DIVQ_VALUE(VALUE) ((1 <= (VALUE)) && ((VALUE) <= 32))
N
N#define IS_RCC_PLLSAI_DIVR_VALUE(VALUE) (((VALUE) == RCC_PLLSAIDIVR_2) ||\
N                                         ((VALUE) == RCC_PLLSAIDIVR_4) ||\
N                                         ((VALUE) == RCC_PLLSAIDIVR_8) ||\
N                                         ((VALUE) == RCC_PLLSAIDIVR_16))
X#define IS_RCC_PLLSAI_DIVR_VALUE(VALUE) (((VALUE) == RCC_PLLSAIDIVR_2) ||                                         ((VALUE) == RCC_PLLSAIDIVR_4) ||                                         ((VALUE) == RCC_PLLSAIDIVR_8) ||                                         ((VALUE) == RCC_PLLSAIDIVR_16))
N#define IS_RCC_I2SCLKSOURCE(SOURCE)  (((SOURCE) == RCC_I2SCLKSOURCE_PLLI2S) || \
N                                      ((SOURCE) == RCC_I2SCLKSOURCE_EXT))
X#define IS_RCC_I2SCLKSOURCE(SOURCE)  (((SOURCE) == RCC_I2SCLKSOURCE_PLLI2S) ||                                       ((SOURCE) == RCC_I2SCLKSOURCE_EXT))
N
N#define IS_RCC_SDMMC1CLKSOURCE(SOURCE) (((SOURCE) == RCC_SDMMC1CLKSOURCE_SYSCLK) || \
N                                        ((SOURCE) == RCC_SDMMC1CLKSOURCE_CLK48))
X#define IS_RCC_SDMMC1CLKSOURCE(SOURCE) (((SOURCE) == RCC_SDMMC1CLKSOURCE_SYSCLK) ||                                         ((SOURCE) == RCC_SDMMC1CLKSOURCE_CLK48))
N
N#define IS_RCC_CECCLKSOURCE(SOURCE)  (((SOURCE) == RCC_CECCLKSOURCE_HSI) || \
N                                      ((SOURCE) == RCC_CECCLKSOURCE_LSE))
X#define IS_RCC_CECCLKSOURCE(SOURCE)  (((SOURCE) == RCC_CECCLKSOURCE_HSI) ||                                       ((SOURCE) == RCC_CECCLKSOURCE_LSE))
N#define IS_RCC_USART1CLKSOURCE(SOURCE)  \
N               (((SOURCE) == RCC_USART1CLKSOURCE_PCLK2)  || \
N                ((SOURCE) == RCC_USART1CLKSOURCE_SYSCLK) || \
N                ((SOURCE) == RCC_USART1CLKSOURCE_LSE)    || \
N                ((SOURCE) == RCC_USART1CLKSOURCE_HSI))
X#define IS_RCC_USART1CLKSOURCE(SOURCE)                 (((SOURCE) == RCC_USART1CLKSOURCE_PCLK2)  ||                 ((SOURCE) == RCC_USART1CLKSOURCE_SYSCLK) ||                 ((SOURCE) == RCC_USART1CLKSOURCE_LSE)    ||                 ((SOURCE) == RCC_USART1CLKSOURCE_HSI))
N
N#define IS_RCC_USART2CLKSOURCE(SOURCE)  \
N               (((SOURCE) == RCC_USART2CLKSOURCE_PCLK1)  || \
N                ((SOURCE) == RCC_USART2CLKSOURCE_SYSCLK) || \
N                ((SOURCE) == RCC_USART2CLKSOURCE_LSE)    || \
N                ((SOURCE) == RCC_USART2CLKSOURCE_HSI))
X#define IS_RCC_USART2CLKSOURCE(SOURCE)                 (((SOURCE) == RCC_USART2CLKSOURCE_PCLK1)  ||                 ((SOURCE) == RCC_USART2CLKSOURCE_SYSCLK) ||                 ((SOURCE) == RCC_USART2CLKSOURCE_LSE)    ||                 ((SOURCE) == RCC_USART2CLKSOURCE_HSI))
N#define IS_RCC_USART3CLKSOURCE(SOURCE)  \
N               (((SOURCE) == RCC_USART3CLKSOURCE_PCLK1)  || \
N                ((SOURCE) == RCC_USART3CLKSOURCE_SYSCLK) || \
N                ((SOURCE) == RCC_USART3CLKSOURCE_LSE)    || \
N                ((SOURCE) == RCC_USART3CLKSOURCE_HSI))
X#define IS_RCC_USART3CLKSOURCE(SOURCE)                 (((SOURCE) == RCC_USART3CLKSOURCE_PCLK1)  ||                 ((SOURCE) == RCC_USART3CLKSOURCE_SYSCLK) ||                 ((SOURCE) == RCC_USART3CLKSOURCE_LSE)    ||                 ((SOURCE) == RCC_USART3CLKSOURCE_HSI))
N
N#define IS_RCC_UART4CLKSOURCE(SOURCE)  \
N               (((SOURCE) == RCC_UART4CLKSOURCE_PCLK1)  || \
N                ((SOURCE) == RCC_UART4CLKSOURCE_SYSCLK) || \
N                ((SOURCE) == RCC_UART4CLKSOURCE_LSE)    || \
N                ((SOURCE) == RCC_UART4CLKSOURCE_HSI))
X#define IS_RCC_UART4CLKSOURCE(SOURCE)                 (((SOURCE) == RCC_UART4CLKSOURCE_PCLK1)  ||                 ((SOURCE) == RCC_UART4CLKSOURCE_SYSCLK) ||                 ((SOURCE) == RCC_UART4CLKSOURCE_LSE)    ||                 ((SOURCE) == RCC_UART4CLKSOURCE_HSI))
N
N#define IS_RCC_UART5CLKSOURCE(SOURCE)  \
N               (((SOURCE) == RCC_UART5CLKSOURCE_PCLK1)  || \
N                ((SOURCE) == RCC_UART5CLKSOURCE_SYSCLK) || \
N                ((SOURCE) == RCC_UART5CLKSOURCE_LSE)    || \
N                ((SOURCE) == RCC_UART5CLKSOURCE_HSI))
X#define IS_RCC_UART5CLKSOURCE(SOURCE)                 (((SOURCE) == RCC_UART5CLKSOURCE_PCLK1)  ||                 ((SOURCE) == RCC_UART5CLKSOURCE_SYSCLK) ||                 ((SOURCE) == RCC_UART5CLKSOURCE_LSE)    ||                 ((SOURCE) == RCC_UART5CLKSOURCE_HSI))
N
N#define IS_RCC_USART6CLKSOURCE(SOURCE)  \
N               (((SOURCE) == RCC_USART6CLKSOURCE_PCLK2)  || \
N                ((SOURCE) == RCC_USART6CLKSOURCE_SYSCLK) || \
N                ((SOURCE) == RCC_USART6CLKSOURCE_LSE)    || \
N                ((SOURCE) == RCC_USART6CLKSOURCE_HSI))
X#define IS_RCC_USART6CLKSOURCE(SOURCE)                 (((SOURCE) == RCC_USART6CLKSOURCE_PCLK2)  ||                 ((SOURCE) == RCC_USART6CLKSOURCE_SYSCLK) ||                 ((SOURCE) == RCC_USART6CLKSOURCE_LSE)    ||                 ((SOURCE) == RCC_USART6CLKSOURCE_HSI))
N
N#define IS_RCC_UART7CLKSOURCE(SOURCE)  \
N               (((SOURCE) == RCC_UART7CLKSOURCE_PCLK1)  || \
N                ((SOURCE) == RCC_UART7CLKSOURCE_SYSCLK) || \
N                ((SOURCE) == RCC_UART7CLKSOURCE_LSE)    || \
N                ((SOURCE) == RCC_UART7CLKSOURCE_HSI))
X#define IS_RCC_UART7CLKSOURCE(SOURCE)                 (((SOURCE) == RCC_UART7CLKSOURCE_PCLK1)  ||                 ((SOURCE) == RCC_UART7CLKSOURCE_SYSCLK) ||                 ((SOURCE) == RCC_UART7CLKSOURCE_LSE)    ||                 ((SOURCE) == RCC_UART7CLKSOURCE_HSI))
N
N#define IS_RCC_UART8CLKSOURCE(SOURCE)  \
N               (((SOURCE) == RCC_UART8CLKSOURCE_PCLK1)  || \
N                ((SOURCE) == RCC_UART8CLKSOURCE_SYSCLK) || \
N                ((SOURCE) == RCC_UART8CLKSOURCE_LSE)    || \
N                ((SOURCE) == RCC_UART8CLKSOURCE_HSI))
X#define IS_RCC_UART8CLKSOURCE(SOURCE)                 (((SOURCE) == RCC_UART8CLKSOURCE_PCLK1)  ||                 ((SOURCE) == RCC_UART8CLKSOURCE_SYSCLK) ||                 ((SOURCE) == RCC_UART8CLKSOURCE_LSE)    ||                 ((SOURCE) == RCC_UART8CLKSOURCE_HSI))
N#define IS_RCC_I2C1CLKSOURCE(SOURCE)   \
N               (((SOURCE) == RCC_I2C1CLKSOURCE_PCLK1) || \
N                ((SOURCE) == RCC_I2C1CLKSOURCE_SYSCLK)|| \
N                ((SOURCE) == RCC_I2C1CLKSOURCE_HSI))
X#define IS_RCC_I2C1CLKSOURCE(SOURCE)                  (((SOURCE) == RCC_I2C1CLKSOURCE_PCLK1) ||                 ((SOURCE) == RCC_I2C1CLKSOURCE_SYSCLK)||                 ((SOURCE) == RCC_I2C1CLKSOURCE_HSI))
N#define IS_RCC_I2C2CLKSOURCE(SOURCE)   \
N               (((SOURCE) == RCC_I2C2CLKSOURCE_PCLK1) || \
N                ((SOURCE) == RCC_I2C2CLKSOURCE_SYSCLK)|| \
N                ((SOURCE) == RCC_I2C2CLKSOURCE_HSI))
X#define IS_RCC_I2C2CLKSOURCE(SOURCE)                  (((SOURCE) == RCC_I2C2CLKSOURCE_PCLK1) ||                 ((SOURCE) == RCC_I2C2CLKSOURCE_SYSCLK)||                 ((SOURCE) == RCC_I2C2CLKSOURCE_HSI))
N
N#define IS_RCC_I2C3CLKSOURCE(SOURCE)   \
N               (((SOURCE) == RCC_I2C3CLKSOURCE_PCLK1) || \
N                ((SOURCE) == RCC_I2C3CLKSOURCE_SYSCLK)|| \
N                ((SOURCE) == RCC_I2C3CLKSOURCE_HSI))
X#define IS_RCC_I2C3CLKSOURCE(SOURCE)                  (((SOURCE) == RCC_I2C3CLKSOURCE_PCLK1) ||                 ((SOURCE) == RCC_I2C3CLKSOURCE_SYSCLK)||                 ((SOURCE) == RCC_I2C3CLKSOURCE_HSI))
N#define IS_RCC_I2C4CLKSOURCE(SOURCE)   \
N               (((SOURCE) == RCC_I2C4CLKSOURCE_PCLK1) || \
N                ((SOURCE) == RCC_I2C4CLKSOURCE_SYSCLK)|| \
N                ((SOURCE) == RCC_I2C4CLKSOURCE_HSI))
X#define IS_RCC_I2C4CLKSOURCE(SOURCE)                  (((SOURCE) == RCC_I2C4CLKSOURCE_PCLK1) ||                 ((SOURCE) == RCC_I2C4CLKSOURCE_SYSCLK)||                 ((SOURCE) == RCC_I2C4CLKSOURCE_HSI))
N#define IS_RCC_LPTIM1CLK(SOURCE)  \
N               (((SOURCE) == RCC_LPTIM1CLKSOURCE_PCLK) || \
N                ((SOURCE) == RCC_LPTIM1CLKSOURCE_LSI)  || \
N                ((SOURCE) == RCC_LPTIM1CLKSOURCE_HSI)  || \
N                ((SOURCE) == RCC_LPTIM1CLKSOURCE_LSE))
X#define IS_RCC_LPTIM1CLK(SOURCE)                 (((SOURCE) == RCC_LPTIM1CLKSOURCE_PCLK) ||                 ((SOURCE) == RCC_LPTIM1CLKSOURCE_LSI)  ||                 ((SOURCE) == RCC_LPTIM1CLKSOURCE_HSI)  ||                 ((SOURCE) == RCC_LPTIM1CLKSOURCE_LSE))
N#define IS_RCC_CLK48SOURCE(SOURCE)  \
N               (((SOURCE) == RCC_CLK48SOURCE_PLLSAIP) || \
N                ((SOURCE) == RCC_CLK48SOURCE_PLL))
X#define IS_RCC_CLK48SOURCE(SOURCE)                 (((SOURCE) == RCC_CLK48SOURCE_PLLSAIP) ||                 ((SOURCE) == RCC_CLK48SOURCE_PLL))
N#define IS_RCC_TIMPRES(VALUE)  \
N               (((VALUE) == RCC_TIMPRES_DESACTIVATED) || \
N                ((VALUE) == RCC_TIMPRES_ACTIVATED))
X#define IS_RCC_TIMPRES(VALUE)                 (((VALUE) == RCC_TIMPRES_DESACTIVATED) ||                 ((VALUE) == RCC_TIMPRES_ACTIVATED))
N
N#if defined (STM32F745xx) || defined (STM32F746xx) || defined (STM32F756xx)
X#if 0L || 0L || 0L
S#define IS_RCC_SAI1CLKSOURCE(SOURCE)  (((SOURCE) == RCC_SAI1CLKSOURCE_PLLSAI) || \
S                                       ((SOURCE) == RCC_SAI1CLKSOURCE_PLLI2S) || \
S                                       ((SOURCE) == RCC_SAI1CLKSOURCE_PIN))
X#define IS_RCC_SAI1CLKSOURCE(SOURCE)  (((SOURCE) == RCC_SAI1CLKSOURCE_PLLSAI) ||                                        ((SOURCE) == RCC_SAI1CLKSOURCE_PLLI2S) ||                                        ((SOURCE) == RCC_SAI1CLKSOURCE_PIN))
S#define IS_RCC_SAI2CLKSOURCE(SOURCE)  (((SOURCE) == RCC_SAI2CLKSOURCE_PLLSAI) || \
S                                       ((SOURCE) == RCC_SAI2CLKSOURCE_PLLI2S) || \
S                                       ((SOURCE) == RCC_SAI2CLKSOURCE_PIN))
X#define IS_RCC_SAI2CLKSOURCE(SOURCE)  (((SOURCE) == RCC_SAI2CLKSOURCE_PLLSAI) ||                                        ((SOURCE) == RCC_SAI2CLKSOURCE_PLLI2S) ||                                        ((SOURCE) == RCC_SAI2CLKSOURCE_PIN))
N#endif /* STM32F745xx || STM32F746xx || STM32F756xx */
N                 
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N#define IS_RCC_PLLR_VALUE(VALUE)            ((2 <= (VALUE)) && ((VALUE) <= 7))
N                 
N#define IS_RCC_SAI1CLKSOURCE(SOURCE)  (((SOURCE) == RCC_SAI1CLKSOURCE_PLLSAI) || \
N                                       ((SOURCE) == RCC_SAI1CLKSOURCE_PLLI2S) || \
N                                       ((SOURCE) == RCC_SAI1CLKSOURCE_PIN)    || \
N                                       ((SOURCE) == RCC_SAI1CLKSOURCE_PLLSRC))
X#define IS_RCC_SAI1CLKSOURCE(SOURCE)  (((SOURCE) == RCC_SAI1CLKSOURCE_PLLSAI) ||                                        ((SOURCE) == RCC_SAI1CLKSOURCE_PLLI2S) ||                                        ((SOURCE) == RCC_SAI1CLKSOURCE_PIN)    ||                                        ((SOURCE) == RCC_SAI1CLKSOURCE_PLLSRC))
N
N#define IS_RCC_SAI2CLKSOURCE(SOURCE)  (((SOURCE) == RCC_SAI2CLKSOURCE_PLLSAI) || \
N                                       ((SOURCE) == RCC_SAI2CLKSOURCE_PLLI2S) || \
N                                       ((SOURCE) == RCC_SAI2CLKSOURCE_PIN)    || \
N                                       ((SOURCE) == RCC_SAI2CLKSOURCE_PLLSRC))
X#define IS_RCC_SAI2CLKSOURCE(SOURCE)  (((SOURCE) == RCC_SAI2CLKSOURCE_PLLSAI) ||                                        ((SOURCE) == RCC_SAI2CLKSOURCE_PLLI2S) ||                                        ((SOURCE) == RCC_SAI2CLKSOURCE_PIN)    ||                                        ((SOURCE) == RCC_SAI2CLKSOURCE_PLLSRC))
N
N#define IS_RCC_SDMMC2CLKSOURCE(SOURCE)  (((SOURCE) == RCC_SDMMC2CLKSOURCE_SYSCLK) || \
N                                         ((SOURCE) == RCC_SDMMC2CLKSOURCE_CLK48))
X#define IS_RCC_SDMMC2CLKSOURCE(SOURCE)  (((SOURCE) == RCC_SDMMC2CLKSOURCE_SYSCLK) ||                                          ((SOURCE) == RCC_SDMMC2CLKSOURCE_CLK48))
N
N#define IS_RCC_DFSDM1CLKSOURCE(SOURCE)  (((SOURCE) == RCC_DFSDM1CLKSOURCE_PCLK) || \
N                                        ((SOURCE) == RCC_DFSDM1CLKSOURCE_SYSCLK))
X#define IS_RCC_DFSDM1CLKSOURCE(SOURCE)  (((SOURCE) == RCC_DFSDM1CLKSOURCE_PCLK) ||                                         ((SOURCE) == RCC_DFSDM1CLKSOURCE_SYSCLK))
N
N#define IS_RCC_DFSDM1AUDIOCLKSOURCE(SOURCE)  (((SOURCE) == RCC_DFSDM1AUDIOCLKSOURCE_SAI1) || \
N                                             ((SOURCE) == RCC_DFSDM1AUDIOCLKSOURCE_SAI2))
X#define IS_RCC_DFSDM1AUDIOCLKSOURCE(SOURCE)  (((SOURCE) == RCC_DFSDM1AUDIOCLKSOURCE_SAI1) ||                                              ((SOURCE) == RCC_DFSDM1AUDIOCLKSOURCE_SAI2))
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N
N#if defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 1L || 0L || 0L || 0L
N#define IS_RCC_DSIBYTELANECLKSOURCE(SOURCE) (((SOURCE) == RCC_DSICLKSOURCE_PLLR)  ||\
N                                             ((SOURCE) == RCC_DSICLKSOURCE_DSIPHY))
X#define IS_RCC_DSIBYTELANECLKSOURCE(SOURCE) (((SOURCE) == RCC_DSICLKSOURCE_PLLR)  ||                                             ((SOURCE) == RCC_DSICLKSOURCE_DSIPHY))
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N                 
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_RCC_EX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 52 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_rcc.h" 2
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup RCC
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/ 
N
N/** @defgroup RCC_Exported_Types RCC Exported Types
N  * @{
N  */
N
N/**
N  * @brief  RCC Internal/External Oscillator (HSE, HSI, LSE and LSI) configuration structure definition  
N  */
Ntypedef struct
N{
N  uint32_t OscillatorType;       /*!< The oscillators to be configured.
N                                      This parameter can be a value of @ref RCC_Oscillator_Type                   */
N
N  uint32_t HSEState;             /*!< The new state of the HSE.
N                                      This parameter can be a value of @ref RCC_HSE_Config                        */
N
N  uint32_t LSEState;             /*!< The new state of the LSE.
N                                      This parameter can be a value of @ref RCC_LSE_Config                        */
N                                          
N  uint32_t HSIState;             /*!< The new state of the HSI.
N                                      This parameter can be a value of @ref RCC_HSI_Config                        */
N
N  uint32_t HSICalibrationValue;   /*!< The HSI calibration trimming value (default is RCC_HSICALIBRATION_DEFAULT).
N                                       This parameter must be a number between Min_Data = 0x00 and Max_Data = 0x1F */
N                               
N  uint32_t LSIState;             /*!< The new state of the LSI.
N                                      This parameter can be a value of @ref RCC_LSI_Config                        */
N
N  RCC_PLLInitTypeDef PLL;        /*!< PLL structure parameters                                                    */      
N
N}RCC_OscInitTypeDef;
N
N/**
N  * @brief  RCC System, AHB and APB busses clock configuration structure definition  
N  */
Ntypedef struct
N{
N  uint32_t ClockType;             /*!< The clock to be configured.
N                                       This parameter can be a value of @ref RCC_System_Clock_Type */
N  
N  uint32_t SYSCLKSource;          /*!< The clock source (SYSCLKS) used as system clock.
N                                       This parameter can be a value of @ref RCC_System_Clock_Source    */
N
N  uint32_t AHBCLKDivider;         /*!< The AHB clock (HCLK) divider. This clock is derived from the system clock (SYSCLK).
N                                       This parameter can be a value of @ref RCC_AHB_Clock_Source       */
N
N  uint32_t APB1CLKDivider;        /*!< The APB1 clock (PCLK1) divider. This clock is derived from the AHB clock (HCLK).
N                                       This parameter can be a value of @ref RCC_APB1_APB2_Clock_Source */
N
N  uint32_t APB2CLKDivider;        /*!< The APB2 clock (PCLK2) divider. This clock is derived from the AHB clock (HCLK).
N                                       This parameter can be a value of @ref RCC_APB1_APB2_Clock_Source */
N
N}RCC_ClkInitTypeDef;
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup RCC_Exported_Constants RCC Exported Constants
N  * @{
N  */
N
N/** @defgroup RCC_Oscillator_Type Oscillator Type
N  * @{
N  */
N#define RCC_OSCILLATORTYPE_NONE            ((uint32_t)0x00000000U)
N#define RCC_OSCILLATORTYPE_HSE             ((uint32_t)0x00000001U)
N#define RCC_OSCILLATORTYPE_HSI             ((uint32_t)0x00000002U)
N#define RCC_OSCILLATORTYPE_LSE             ((uint32_t)0x00000004U)
N#define RCC_OSCILLATORTYPE_LSI             ((uint32_t)0x00000008U)
N/**
N  * @}
N  */
N
N/** @defgroup RCC_HSE_Config RCC HSE Config
N  * @{
N  */
N#define RCC_HSE_OFF                      ((uint32_t)0x00000000U)
N#define RCC_HSE_ON                       RCC_CR_HSEON
N#define RCC_HSE_BYPASS                   ((uint32_t)(RCC_CR_HSEBYP | RCC_CR_HSEON))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LSE_Config RCC LSE Config
N  * @{
N  */
N#define RCC_LSE_OFF                    ((uint32_t)0x00000000U)
N#define RCC_LSE_ON                     RCC_BDCR_LSEON
N#define RCC_LSE_BYPASS                 ((uint32_t)(RCC_BDCR_LSEBYP | RCC_BDCR_LSEON))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_HSI_Config RCC HSI Config
N  * @{
N  */
N#define RCC_HSI_OFF                    ((uint32_t)0x00000000U)
N#define RCC_HSI_ON                     RCC_CR_HSION
N
N#define RCC_HSICALIBRATION_DEFAULT     ((uint32_t)0x10U)         /* Default HSI calibration trimming value */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LSI_Config RCC LSI Config
N  * @{
N  */
N#define RCC_LSI_OFF                    ((uint32_t)0x00000000U)
N#define RCC_LSI_ON                     RCC_CSR_LSION
N/**
N  * @}
N  */
N
N/** @defgroup RCC_PLL_Config RCC PLL Config
N  * @{
N  */
N#define RCC_PLL_NONE                   ((uint32_t)0x00000000U)
N#define RCC_PLL_OFF                    ((uint32_t)0x00000001U)
N#define RCC_PLL_ON                     ((uint32_t)0x00000002U)
N/**
N  * @}
N  */
N
N/** @defgroup RCC_PLLP_Clock_Divider PLLP Clock Divider
N  * @{
N  */
N#define RCC_PLLP_DIV2                  ((uint32_t)0x00000002U)
N#define RCC_PLLP_DIV4                  ((uint32_t)0x00000004U)
N#define RCC_PLLP_DIV6                  ((uint32_t)0x00000006U)
N#define RCC_PLLP_DIV8                  ((uint32_t)0x00000008U)
N/**
N  * @}
N  */
N
N/** @defgroup RCC_PLL_Clock_Source PLL Clock Source
N  * @{
N  */
N#define RCC_PLLSOURCE_HSI                RCC_PLLCFGR_PLLSRC_HSI
N#define RCC_PLLSOURCE_HSE                RCC_PLLCFGR_PLLSRC_HSE
N/**
N  * @}
N  */
N
N/** @defgroup RCC_System_Clock_Type RCC System Clock Type
N  * @{
N  */
N#define RCC_CLOCKTYPE_SYSCLK             ((uint32_t)0x00000001U)
N#define RCC_CLOCKTYPE_HCLK               ((uint32_t)0x00000002U)
N#define RCC_CLOCKTYPE_PCLK1              ((uint32_t)0x00000004U)
N#define RCC_CLOCKTYPE_PCLK2              ((uint32_t)0x00000008U)
N/**
N  * @}
N  */
N  
N/** @defgroup RCC_System_Clock_Source RCC System Clock Source
N  * @{
N  */
N#define RCC_SYSCLKSOURCE_HSI             RCC_CFGR_SW_HSI
N#define RCC_SYSCLKSOURCE_HSE             RCC_CFGR_SW_HSE
N#define RCC_SYSCLKSOURCE_PLLCLK          RCC_CFGR_SW_PLL
N/**
N  * @}
N  */
N
N
N/** @defgroup RCC_System_Clock_Source_Status System Clock Source Status
N  * @{
N  */
N#define RCC_SYSCLKSOURCE_STATUS_HSI      RCC_CFGR_SWS_HSI   /*!< HSI used as system clock */
N#define RCC_SYSCLKSOURCE_STATUS_HSE      RCC_CFGR_SWS_HSE   /*!< HSE used as system clock */
N#define RCC_SYSCLKSOURCE_STATUS_PLLCLK   RCC_CFGR_SWS_PLL   /*!< PLL used as system clock */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_AHB_Clock_Source RCC AHB Clock Source
N  * @{
N  */
N#define RCC_SYSCLK_DIV1                  RCC_CFGR_HPRE_DIV1
N#define RCC_SYSCLK_DIV2                  RCC_CFGR_HPRE_DIV2
N#define RCC_SYSCLK_DIV4                  RCC_CFGR_HPRE_DIV4
N#define RCC_SYSCLK_DIV8                  RCC_CFGR_HPRE_DIV8
N#define RCC_SYSCLK_DIV16                 RCC_CFGR_HPRE_DIV16
N#define RCC_SYSCLK_DIV64                 RCC_CFGR_HPRE_DIV64
N#define RCC_SYSCLK_DIV128                RCC_CFGR_HPRE_DIV128
N#define RCC_SYSCLK_DIV256                RCC_CFGR_HPRE_DIV256
N#define RCC_SYSCLK_DIV512                RCC_CFGR_HPRE_DIV512
N/**
N  * @}
N  */ 
N  
N/** @defgroup RCC_APB1_APB2_Clock_Source RCC APB1/APB2 Clock Source
N  * @{
N  */
N#define RCC_HCLK_DIV1                    RCC_CFGR_PPRE1_DIV1
N#define RCC_HCLK_DIV2                    RCC_CFGR_PPRE1_DIV2
N#define RCC_HCLK_DIV4                    RCC_CFGR_PPRE1_DIV4
N#define RCC_HCLK_DIV8                    RCC_CFGR_PPRE1_DIV8
N#define RCC_HCLK_DIV16                   RCC_CFGR_PPRE1_DIV16
N/**
N  * @}
N  */ 
N
N/** @defgroup RCC_RTC_Clock_Source RCC RTC Clock Source
N  * @{
N  */
N#define RCC_RTCCLKSOURCE_LSE             ((uint32_t)0x00000100U)
N#define RCC_RTCCLKSOURCE_LSI             ((uint32_t)0x00000200U)
N#define RCC_RTCCLKSOURCE_HSE_DIV2        ((uint32_t)0x00020300U)
N#define RCC_RTCCLKSOURCE_HSE_DIV3        ((uint32_t)0x00030300U)
N#define RCC_RTCCLKSOURCE_HSE_DIV4        ((uint32_t)0x00040300U)
N#define RCC_RTCCLKSOURCE_HSE_DIV5        ((uint32_t)0x00050300U)
N#define RCC_RTCCLKSOURCE_HSE_DIV6        ((uint32_t)0x00060300U)
N#define RCC_RTCCLKSOURCE_HSE_DIV7        ((uint32_t)0x00070300U)
N#define RCC_RTCCLKSOURCE_HSE_DIV8        ((uint32_t)0x00080300U)
N#define RCC_RTCCLKSOURCE_HSE_DIV9        ((uint32_t)0x00090300U)
N#define RCC_RTCCLKSOURCE_HSE_DIV10       ((uint32_t)0x000A0300U)
N#define RCC_RTCCLKSOURCE_HSE_DIV11       ((uint32_t)0x000B0300U)
N#define RCC_RTCCLKSOURCE_HSE_DIV12       ((uint32_t)0x000C0300U)
N#define RCC_RTCCLKSOURCE_HSE_DIV13       ((uint32_t)0x000D0300U)
N#define RCC_RTCCLKSOURCE_HSE_DIV14       ((uint32_t)0x000E0300U)
N#define RCC_RTCCLKSOURCE_HSE_DIV15       ((uint32_t)0x000F0300U)
N#define RCC_RTCCLKSOURCE_HSE_DIV16       ((uint32_t)0x00100300U)
N#define RCC_RTCCLKSOURCE_HSE_DIV17       ((uint32_t)0x00110300U)
N#define RCC_RTCCLKSOURCE_HSE_DIV18       ((uint32_t)0x00120300U)
N#define RCC_RTCCLKSOURCE_HSE_DIV19       ((uint32_t)0x00130300U)
N#define RCC_RTCCLKSOURCE_HSE_DIV20       ((uint32_t)0x00140300U)
N#define RCC_RTCCLKSOURCE_HSE_DIV21       ((uint32_t)0x00150300U)
N#define RCC_RTCCLKSOURCE_HSE_DIV22       ((uint32_t)0x00160300U)
N#define RCC_RTCCLKSOURCE_HSE_DIV23       ((uint32_t)0x00170300U)
N#define RCC_RTCCLKSOURCE_HSE_DIV24       ((uint32_t)0x00180300U)
N#define RCC_RTCCLKSOURCE_HSE_DIV25       ((uint32_t)0x00190300U)
N#define RCC_RTCCLKSOURCE_HSE_DIV26       ((uint32_t)0x001A0300U)
N#define RCC_RTCCLKSOURCE_HSE_DIV27       ((uint32_t)0x001B0300U)
N#define RCC_RTCCLKSOURCE_HSE_DIV28       ((uint32_t)0x001C0300U)
N#define RCC_RTCCLKSOURCE_HSE_DIV29       ((uint32_t)0x001D0300U)
N#define RCC_RTCCLKSOURCE_HSE_DIV30       ((uint32_t)0x001E0300U)
N#define RCC_RTCCLKSOURCE_HSE_DIV31       ((uint32_t)0x001F0300U)
N/**
N  * @}
N  */
N
N
N
N/** @defgroup RCC_MCO_Index RCC MCO Index
N  * @{
N  */
N#define RCC_MCO1                         ((uint32_t)0x00000000U)
N#define RCC_MCO2                         ((uint32_t)0x00000001U)
N/**
N  * @}
N  */
N
N/** @defgroup RCC_MCO1_Clock_Source RCC MCO1 Clock Source
N  * @{
N  */
N#define RCC_MCO1SOURCE_HSI               ((uint32_t)0x00000000U)
N#define RCC_MCO1SOURCE_LSE               RCC_CFGR_MCO1_0
N#define RCC_MCO1SOURCE_HSE               RCC_CFGR_MCO1_1
N#define RCC_MCO1SOURCE_PLLCLK            RCC_CFGR_MCO1
N/**
N  * @}
N  */
N
N/** @defgroup RCC_MCO2_Clock_Source RCC MCO2 Clock Source
N  * @{
N  */
N#define RCC_MCO2SOURCE_SYSCLK            ((uint32_t)0x00000000U)
N#define RCC_MCO2SOURCE_PLLI2SCLK         RCC_CFGR_MCO2_0
N#define RCC_MCO2SOURCE_HSE               RCC_CFGR_MCO2_1
N#define RCC_MCO2SOURCE_PLLCLK            RCC_CFGR_MCO2
N/**
N  * @}
N  */
N
N/** @defgroup RCC_MCOx_Clock_Prescaler RCC MCO1 Clock Prescaler
N  * @{
N  */
N#define RCC_MCODIV_1                    ((uint32_t)0x00000000U)
N#define RCC_MCODIV_2                    RCC_CFGR_MCO1PRE_2
N#define RCC_MCODIV_3                    ((uint32_t)RCC_CFGR_MCO1PRE_0 | RCC_CFGR_MCO1PRE_2)
N#define RCC_MCODIV_4                    ((uint32_t)RCC_CFGR_MCO1PRE_1 | RCC_CFGR_MCO1PRE_2)
N#define RCC_MCODIV_5                    RCC_CFGR_MCO1PRE
N/**
N  * @}
N  */
N
N/** @defgroup RCC_Interrupt RCC Interrupt 
N  * @{
N  */
N#define RCC_IT_LSIRDY                    ((uint8_t)0x01U)
N#define RCC_IT_LSERDY                    ((uint8_t)0x02U)
N#define RCC_IT_HSIRDY                    ((uint8_t)0x04U)
N#define RCC_IT_HSERDY                    ((uint8_t)0x08U)
N#define RCC_IT_PLLRDY                    ((uint8_t)0x10U)
N#define RCC_IT_PLLI2SRDY                 ((uint8_t)0x20U)
N#define RCC_IT_PLLSAIRDY                 ((uint8_t)0x40U)
N#define RCC_IT_CSS                       ((uint8_t)0x80U)
N/**
N  * @}
N  */
N  
N/** @defgroup RCC_Flag RCC Flags
N  *        Elements values convention: 0XXYYYYYb
N  *           - YYYYY  : Flag position in the register
N  *           - 0XX  : Register index
N  *                 - 01: CR register
N  *                 - 10: BDCR register
N  *                 - 11: CSR register
N  * @{
N  */
N/* Flags in the CR register */
N#define RCC_FLAG_HSIRDY                  ((uint8_t)0x21U)
N#define RCC_FLAG_HSERDY                  ((uint8_t)0x31U)
N#define RCC_FLAG_PLLRDY                  ((uint8_t)0x39U)
N#define RCC_FLAG_PLLI2SRDY               ((uint8_t)0x3BU)
N#define RCC_FLAG_PLLSAIRDY               ((uint8_t)0x3CU)
N
N/* Flags in the BDCR register */
N#define RCC_FLAG_LSERDY                  ((uint8_t)0x41U)
N
N/* Flags in the CSR register */
N#define RCC_FLAG_LSIRDY                  ((uint8_t)0x61U)
N#define RCC_FLAG_BORRST                  ((uint8_t)0x79U)
N#define RCC_FLAG_PINRST                  ((uint8_t)0x7AU)
N#define RCC_FLAG_PORRST                  ((uint8_t)0x7BU)
N#define RCC_FLAG_SFTRST                  ((uint8_t)0x7CU)
N#define RCC_FLAG_IWDGRST                 ((uint8_t)0x7DU)
N#define RCC_FLAG_WWDGRST                 ((uint8_t)0x7EU)
N#define RCC_FLAG_LPWRRST                 ((uint8_t)0x7FU)
N/**
N  * @}
N  */ 
N
N/** @defgroup RCC_LSEDrive_Configuration RCC LSE Drive configurations
N  * @{
N  */
N#define RCC_LSEDRIVE_LOW                 ((uint32_t)0x00000000U)
N#define RCC_LSEDRIVE_MEDIUMLOW           RCC_BDCR_LSEDRV_1
N#define RCC_LSEDRIVE_MEDIUMHIGH          RCC_BDCR_LSEDRV_0
N#define RCC_LSEDRIVE_HIGH                RCC_BDCR_LSEDRV
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */
N   
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup RCC_Exported_Macros RCC Exported Macros
N  * @{
N  */
N
N/** @defgroup RCC_AHB1_Clock_Enable_Disable AHB1 Peripheral Clock Enable Disable
N  * @brief  Enable or disable the AHB1 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before 
N  *         using it.   
N  * @{
N  */
N#define __HAL_RCC_CRC_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_CRC_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);                                        UNUSED(tmpreg);                                       } while(0)
N									  
N#define __HAL_RCC_DMA1_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA1EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA1EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_DMA1_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA1EN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA1EN);                                        UNUSED(tmpreg);                                       } while(0)
N
N#define __HAL_RCC_CRC_CLK_DISABLE()          (RCC->AHB1ENR &= ~(RCC_AHB1ENR_CRCEN))
N#define __HAL_RCC_DMA1_CLK_DISABLE()         (RCC->AHB1ENR &= ~(RCC_AHB1ENR_DMA1EN))
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_APB1_Clock_Enable_Disable APB1 Peripheral Clock Enable Disable
N  * @brief  Enable or disable the Low Speed APB (APB1) peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{
N  */
N#define __HAL_RCC_WWDG_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_WWDGEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_WWDGEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_WWDG_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_WWDGEN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_WWDGEN);                                        UNUSED(tmpreg);                                       } while(0)
N									  
N#define __HAL_RCC_PWR_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)									  
X#define __HAL_RCC_PWR_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN);                                        UNUSED(tmpreg);                                       } while(0)									  
N
N#define __HAL_RCC_WWDG_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_WWDGEN))
N#define __HAL_RCC_PWR_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_PWREN)) 
N/**
N  * @}
N  */
N
N/** @defgroup RCC_APB2_Clock_Enable_Disable APB2 Peripheral Clock Enable Disable                                      
N  * @brief  Enable or disable the High Speed APB (APB2) peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before 
N  *         using it.
N  * @{
N  */
N#define __HAL_RCC_SYSCFG_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SYSCFGEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SYSCFGEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0)
X#define __HAL_RCC_SYSCFG_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SYSCFGEN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SYSCFGEN);                                        UNUSED(tmpreg);                                       } while(0)
N									  
N#define __HAL_RCC_SYSCFG_CLK_DISABLE() (RCC->APB2ENR &= ~(RCC_APB2ENR_SYSCFGEN))
N
N/**
N  * @}
N  */
N  
N/** @defgroup RCC_AHB1_Peripheral_Clock_Enable_Disable_Status AHB1 Peripheral Clock Enable Disable Status
N  * @brief  Get the enable or disable status of the AHB1 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{
N  */
N#define __HAL_RCC_CRC_IS_CLK_ENABLED()         ((RCC->AHB1ENR & (RCC_AHB1ENR_CRCEN)) != RESET)  
N#define __HAL_RCC_DMA1_IS_CLK_ENABLED()        ((RCC->AHB1ENR & (RCC_AHB1ENR_DMA1EN)) != RESET)
N
N#define __HAL_RCC_CRC_IS_CLK_DISABLED()        ((RCC->AHB1ENR & (RCC_AHB1ENR_CRCEN)) == RESET)
N#define __HAL_RCC_DMA1_IS_CLK_DISABLED()       ((RCC->AHB1ENR & (RCC_AHB1ENR_DMA1EN)) == RESET)
N/**
N  * @}
N  */
N  
N/** @defgroup RCC_APB1_Clock_Enable_Disable_Status APB1 Peripheral Clock Enable Disable  Status
N  * @brief  Get the enable or disable status of the APB1 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{
N  */
N#define __HAL_RCC_WWDG_IS_CLK_ENABLED()        ((RCC->APB1ENR & (RCC_APB1ENR_WWDGEN)) != RESET)
N#define __HAL_RCC_PWR_IS_CLK_ENABLED()         ((RCC->APB1ENR & (RCC_APB1ENR_PWREN)) != RESET)
N
N#define __HAL_RCC_WWDG_IS_CLK_DISABLED()       ((RCC->APB1ENR & (RCC_APB1ENR_WWDGEN)) == RESET)
N#define __HAL_RCC_PWR_IS_CLK_DISABLED()        ((RCC->APB1ENR & (RCC_APB1ENR_PWREN)) == RESET)
N/**
N  * @}
N  */  
N
N/** @defgroup RCC_APB2_Clock_Enable_Disable_Status APB2 Peripheral Clock Enable Disable Status
N  * @brief  EGet the enable or disable status of the APB2 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{
N  */
N#define __HAL_RCC_SYSCFG_IS_CLK_ENABLED()      ((RCC->APB2ENR & (RCC_APB2ENR_SYSCFGEN)) != RESET)
N#define __HAL_RCC_SYSCFG_IS_CLK_DISABLED()     ((RCC->APB2ENR & (RCC_APB2ENR_SYSCFGEN)) == RESET)
N/**
N  * @}
N  */  
N  
N/** @defgroup RCC_Peripheral_Clock_Force_Release RCC Peripheral Clock Force Release
N  * @brief  Force or release AHB peripheral reset.
N  * @{
N  */  
N#define __HAL_RCC_AHB1_FORCE_RESET()    (RCC->AHB1RSTR = 0xFFFFFFFFU)
N#define __HAL_RCC_CRC_FORCE_RESET()     (RCC->AHB1RSTR |= (RCC_AHB1RSTR_CRCRST))
N#define __HAL_RCC_DMA1_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_DMA1RST))
N
N#define __HAL_RCC_AHB1_RELEASE_RESET()  (RCC->AHB1RSTR = 0x00U)
N#define __HAL_RCC_CRC_RELEASE_RESET()   (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_CRCRST))
N#define __HAL_RCC_DMA1_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_DMA1RST))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_APB1_Force_Release_Reset APB1 Force Release Reset 
N  * @brief  Force or release APB1 peripheral reset.
N  * @{
N  */
N#define __HAL_RCC_APB1_FORCE_RESET()     (RCC->APB1RSTR = 0xFFFFFFFFU)  
N#define __HAL_RCC_WWDG_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_WWDGRST))
N#define __HAL_RCC_PWR_FORCE_RESET()      (RCC->APB1RSTR |= (RCC_APB1RSTR_PWRRST))
N
N#define __HAL_RCC_APB1_RELEASE_RESET()   (RCC->APB1RSTR = 0x00U) 
N#define __HAL_RCC_WWDG_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_WWDGRST))
N#define __HAL_RCC_PWR_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_PWRRST))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_APB2_Force_Release_Reset APB2 Force Release Reset 
N  * @brief  Force or release APB2 peripheral reset.
N  * @{
N  */
N#define __HAL_RCC_APB2_FORCE_RESET()     (RCC->APB2RSTR = 0xFFFFFFFFU)  
N#define __HAL_RCC_SYSCFG_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_SYSCFGRST))
N
N#define __HAL_RCC_APB2_RELEASE_RESET()   (RCC->APB2RSTR = 0x00U)
N#define __HAL_RCC_SYSCFG_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SYSCFGRST))
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_Peripheral_Clock_Sleep_Enable_Disable RCC Peripheral Clock Sleep Enable Disable
N  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
N  *         power consumption.
N  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
N  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
N  * @{
N  */
N#define __HAL_RCC_CRC_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_CRCLPEN))
N#define __HAL_RCC_DMA1_CLK_SLEEP_ENABLE()     (RCC->AHB1LPENR |= (RCC_AHB1LPENR_DMA1LPEN))
N
N#define __HAL_RCC_CRC_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_CRCLPEN))
N#define __HAL_RCC_DMA1_CLK_SLEEP_DISABLE()    (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_DMA1LPEN))
N
N/** @brief  Enable or disable the APB1 peripheral clock during Low Power (Sleep) mode.
N  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
N  *         power consumption.
N  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
N  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
N  */
N#define __HAL_RCC_WWDG_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_WWDGLPEN))
N#define __HAL_RCC_PWR_CLK_SLEEP_ENABLE()     (RCC->APB1LPENR |= (RCC_APB1LPENR_PWRLPEN))
N
N#define __HAL_RCC_WWDG_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_WWDGLPEN))
N#define __HAL_RCC_PWR_CLK_SLEEP_DISABLE()    (RCC->APB1LPENR &= ~(RCC_APB1LPENR_PWRLPEN))
N
N/** @brief  Enable or disable the APB2 peripheral clock during Low Power (Sleep) mode.
N  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
N  *         power consumption.
N  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
N  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
N  */
N#define __HAL_RCC_SYSCFG_CLK_SLEEP_ENABLE()  (RCC->APB2LPENR |= (RCC_APB2LPENR_SYSCFGLPEN))
N#define __HAL_RCC_SYSCFG_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SYSCFGLPEN))
N
N/**
N  * @}
N  */
N  
N/** @defgroup RCC_AHB1_Clock_Sleep_Enable_Disable_Status AHB1 Peripheral Clock Sleep Enable Disable Status
N  * @brief  Get the enable or disable status of the AHB1 peripheral clock during Low Power (Sleep) mode.
N  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
N  *         power consumption.
N  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
N  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
N  * @{
N  */
N#define __HAL_RCC_CRC_IS_CLK_SLEEP_ENABLED()     ((RCC->AHB1LPENR & (RCC_AHB1LPENR_CRCLPEN)) != RESET)
N#define __HAL_RCC_DMA1_IS_CLK_SLEEP_ENABLED()    ((RCC->AHB1LPENR & (RCC_AHB1LPENR_DMA1LPEN)) != RESET)
N
N#define __HAL_RCC_CRC_IS_CLK_SLEEP_DISABLED()    ((RCC->AHB1LPENR & (RCC_AHB1LPENR_CRCLPEN)) == RESET)
N#define __HAL_RCC_DMA1_IS_CLK_SLEEP_DISABLED()   ((RCC->AHB1LPENR & (RCC_AHB1LPENR_DMA1LPEN)) == RESET)
N/**
N  * @}
N  */
N
N/** @defgroup RCC_APB1_Clock_Sleep_Enable_Disable_Status APB1 Peripheral Clock Sleep Enable Disable Status
N  * @brief  Get the enable or disable status of the APB1 peripheral clock during Low Power (Sleep) mode.
N  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
N  *         power consumption.
N  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
N  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
N  * @{
N  */
N#define __HAL_RCC_WWDG_IS_CLK_SLEEP_ENABLED()      ((RCC->APB1LPENR & (RCC_APB1LPENR_WWDGLPEN)) != RESET)
N#define __HAL_RCC_PWR_IS_CLK_SLEEP_ENABLED()       ((RCC->APB1LPENR & (RCC_APB1LPENR_PWRLPEN)) != RESET)
N
N#define __HAL_RCC_WWDG_IS_CLK_SLEEP_DISABLED()     ((RCC->APB1LPENR & (RCC_APB1LPENR_WWDGLPEN)) == RESET)
N#define __HAL_RCC_PWR_IS_CLK_SLEEP_DISABLED()      ((RCC->APB1LPENR & (RCC_APB1LPENR_PWRLPEN)) == RESET)
N/**
N  * @}
N  */
N
N/** @defgroup RCC_APB2_Clock_Sleep_Enable_Disable_Status APB2 Peripheral Clock Sleep Enable Disable Status
N  * @brief  Get the enable or disable status of the APB2 peripheral clock during Low Power (Sleep) mode.
N  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
N  *         power consumption.
N  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
N  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
N  * @{
N  */
N#define __HAL_RCC_SYSCFG_IS_CLK_SLEEP_ENABLED()    ((RCC->APB2LPENR & (RCC_APB2LPENR_SYSCFGLPEN)) != RESET)
N#define __HAL_RCC_SYSCFG_IS_CLK_SLEEP_DISABLED()   ((RCC->APB2LPENR & (RCC_APB2LPENR_SYSCFGLPEN)) == RESET)
N/**
N  * @}
N  */  
N
N/** @defgroup RCC_HSI_Configuration HSI Configuration
N  * @{   
N  */ 
N                                      
N/** @brief  Macros to enable or disable the Internal High Speed oscillator (HSI).
N  * @note   The HSI is stopped by hardware when entering STOP and STANDBY modes.
N  *         It is used (enabled by hardware) as system clock source after startup
N  *         from Reset, wakeup from STOP and STANDBY mode, or in case of failure
N  *         of the HSE used directly or indirectly as system clock (if the Clock
N  *         Security System CSS is enabled).             
N  * @note   HSI can not be stopped if it is used as system clock source. In this case,
N  *         you have to select another source of the system clock then stop the HSI.  
N  * @note   After enabling the HSI, the application software should wait on HSIRDY
N  *         flag to be set indicating that HSI clock is stable and can be used as
N  *         system clock source.  
N  * @note   When the HSI is stopped, HSIRDY flag goes low after 6 HSI oscillator
N  *         clock cycles.  
N  */
N#define __HAL_RCC_HSI_ENABLE() (RCC->CR |= (RCC_CR_HSION))
N#define __HAL_RCC_HSI_DISABLE() (RCC->CR &= ~(RCC_CR_HSION))
N
N/** @brief  Macro to adjust the Internal High Speed oscillator (HSI) calibration value.
N  * @note   The calibration is used to compensate for the variations in voltage
N  *         and temperature that influence the frequency of the internal HSI RC.
N  * @param  __HSICALIBRATIONVALUE__: specifies the calibration trimming value.
N  *         (default is RCC_HSICALIBRATION_DEFAULT).
N  */
N#define __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(__HSICALIBRATIONVALUE__) (MODIFY_REG(RCC->CR,\
N        RCC_CR_HSITRIM, (uint32_t)(__HSICALIBRATIONVALUE__) << POSITION_VAL(RCC_CR_HSITRIM)))
X#define __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(__HSICALIBRATIONVALUE__) (MODIFY_REG(RCC->CR,        RCC_CR_HSITRIM, (uint32_t)(__HSICALIBRATIONVALUE__) << POSITION_VAL(RCC_CR_HSITRIM)))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LSI_Configuration LSI Configuration
N  * @{   
N  */ 
N
N/** @brief  Macros to enable or disable the Internal Low Speed oscillator (LSI).
N  * @note   After enabling the LSI, the application software should wait on 
N  *         LSIRDY flag to be set indicating that LSI clock is stable and can
N  *         be used to clock the IWDG and/or the RTC.
N  * @note   LSI can not be disabled if the IWDG is running.
N  * @note   When the LSI is stopped, LSIRDY flag goes low after 6 LSI oscillator
N  *         clock cycles. 
N  */
N#define __HAL_RCC_LSI_ENABLE()  (RCC->CSR |= (RCC_CSR_LSION))
N#define __HAL_RCC_LSI_DISABLE() (RCC->CSR &= ~(RCC_CSR_LSION))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_HSE_Configuration HSE Configuration
N  * @{   
N  */ 
N/**
N  * @brief  Macro to configure the External High Speed oscillator (HSE).
N  * @note   Transitions HSE Bypass to HSE On and HSE On to HSE Bypass are not
N  *         supported by this macro. User should request a transition to HSE Off
N  *         first and then HSE On or HSE Bypass.
N  * @note   After enabling the HSE (RCC_HSE_ON or RCC_HSE_Bypass), the application
N  *         software should wait on HSERDY flag to be set indicating that HSE clock
N  *         is stable and can be used to clock the PLL and/or system clock.
N  * @note   HSE state can not be changed if it is used directly or through the
N  *         PLL as system clock. In this case, you have to select another source
N  *         of the system clock then change the HSE state (ex. disable it).
N  * @note   The HSE is stopped by hardware when entering STOP and STANDBY modes.
N  * @note   This function reset the CSSON bit, so if the clock security system(CSS)
N  *         was previously enabled you have to enable it again after calling this
N  *         function.
N  * @param  __STATE__: specifies the new state of the HSE.
N  *         This parameter can be one of the following values:
N  *            @arg RCC_HSE_OFF: turn OFF the HSE oscillator, HSERDY flag goes low after
N  *                              6 HSE oscillator clock cycles.
N  *            @arg RCC_HSE_ON: turn ON the HSE oscillator.
N  *            @arg RCC_HSE_BYPASS: HSE oscillator bypassed with external clock.
N  */
N#define __HAL_RCC_HSE_CONFIG(__STATE__)                         \
N                    do {                                        \
N                      if ((__STATE__) == RCC_HSE_ON)            \
N                      {                                         \
N                        SET_BIT(RCC->CR, RCC_CR_HSEON);         \
N                      }                                         \
N                      else if ((__STATE__) == RCC_HSE_OFF)      \
N                      {                                         \
N                        CLEAR_BIT(RCC->CR, RCC_CR_HSEON);       \
N                        CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);      \
N                      }                                         \
N                      else if ((__STATE__) == RCC_HSE_BYPASS)   \
N                      {                                         \
N                        SET_BIT(RCC->CR, RCC_CR_HSEBYP);        \
N                        SET_BIT(RCC->CR, RCC_CR_HSEON);         \
N                      }                                         \
N                      else                                      \
N                      {                                         \
N                        CLEAR_BIT(RCC->CR, RCC_CR_HSEON);       \
N                        CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);      \
N                      }                                         \
N                    } while(0)
X#define __HAL_RCC_HSE_CONFIG(__STATE__)                                             do {                                                              if ((__STATE__) == RCC_HSE_ON)                                  {                                                                 SET_BIT(RCC->CR, RCC_CR_HSEON);                               }                                                               else if ((__STATE__) == RCC_HSE_OFF)                            {                                                                 CLEAR_BIT(RCC->CR, RCC_CR_HSEON);                               CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);                            }                                                               else if ((__STATE__) == RCC_HSE_BYPASS)                         {                                                                 SET_BIT(RCC->CR, RCC_CR_HSEBYP);                                SET_BIT(RCC->CR, RCC_CR_HSEON);                               }                                                               else                                                            {                                                                 CLEAR_BIT(RCC->CR, RCC_CR_HSEON);                               CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);                            }                                                             } while(0)
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LSE_Configuration LSE Configuration
N  * @{   
N  */
N
N/**
N  * @brief  Macro to configure the External Low Speed oscillator (LSE).
N  * @note   Transitions LSE Bypass to LSE On and LSE On to LSE Bypass are not supported by this macro. 
N  *         User should request a transition to LSE Off first and then LSE On or LSE Bypass.  
N  * @note   As the LSE is in the Backup domain and write access is denied to
N  *         this domain after reset, you have to enable write access using 
N  *         HAL_PWR_EnableBkUpAccess() function before to configure the LSE
N  *         (to be done once after reset).  
N  * @note   After enabling the LSE (RCC_LSE_ON or RCC_LSE_BYPASS), the application
N  *         software should wait on LSERDY flag to be set indicating that LSE clock
N  *         is stable and can be used to clock the RTC.
N  * @param  __STATE__: specifies the new state of the LSE.
N  *         This parameter can be one of the following values:
N  *            @arg RCC_LSE_OFF: turn OFF the LSE oscillator, LSERDY flag goes low after
N  *                              6 LSE oscillator clock cycles.
N  *            @arg RCC_LSE_ON: turn ON the LSE oscillator.
N  *            @arg RCC_LSE_BYPASS: LSE oscillator bypassed with external clock.
N  */
N#define __HAL_RCC_LSE_CONFIG(__STATE__) \
N                    do {                                       \
N                      if((__STATE__) == RCC_LSE_ON)            \
N                      {                                        \
N                        SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);    \
N                      }                                        \
N                      else if((__STATE__) == RCC_LSE_OFF)      \
N                      {                                        \
N                        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);  \
N                        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP); \
N                      }                                        \
N                      else if((__STATE__) == RCC_LSE_BYPASS)   \
N                      {                                        \
N                        SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);   \
N                        SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);    \
N                      }                                        \
N                      else                                     \
N                      {                                        \
N                        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);  \
N                        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP); \
N                      }                                        \
N                    } while(0)
X#define __HAL_RCC_LSE_CONFIG(__STATE__)                     do {                                                             if((__STATE__) == RCC_LSE_ON)                                  {                                                                SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);                          }                                                              else if((__STATE__) == RCC_LSE_OFF)                            {                                                                CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);                          CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);                       }                                                              else if((__STATE__) == RCC_LSE_BYPASS)                         {                                                                SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);                           SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);                          }                                                              else                                                           {                                                                CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);                          CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);                       }                                                            } while(0)
N/**
N  * @}
N  */
N
N/** @defgroup RCC_Internal_RTC_Clock_Configuration RTC Clock Configuration
N  * @{   
N  */
N
N/** @brief  Macros to enable or disable the RTC clock.
N  * @note   These macros must be used only after the RTC clock source was selected.
N  */
N#define __HAL_RCC_RTC_ENABLE()  (RCC->BDCR |= (RCC_BDCR_RTCEN))
N#define __HAL_RCC_RTC_DISABLE() (RCC->BDCR &= ~(RCC_BDCR_RTCEN))
N
N/** @brief  Macros to configure the RTC clock (RTCCLK).
N  * @note   As the RTC clock configuration bits are in the Backup domain and write
N  *         access is denied to this domain after reset, you have to enable write
N  *         access using the Power Backup Access macro before to configure
N  *         the RTC clock source (to be done once after reset).    
N  * @note   Once the RTC clock is configured it can't be changed unless the  
N  *         Backup domain is reset using __HAL_RCC_BackupReset_RELEASE() macro, or by
N  *         a Power On Reset (POR).
N  * @param  __RTCCLKSource__: specifies the RTC clock source.
N  *         This parameter can be one of the following values:
N  *            @arg RCC_RTCCLKSOURCE_LSE: LSE selected as RTC clock.
N  *            @arg RCC_RTCCLKSOURCE_LSI: LSI selected as RTC clock.
N  *            @arg RCC_RTCCLKSOURCE_HSE_DIVx: HSE clock divided by x selected
N  *                                            as RTC clock, where x:[2,31]
N  * @note   If the LSE or LSI is used as RTC clock source, the RTC continues to
N  *         work in STOP and STANDBY modes, and can be used as wakeup source.
N  *         However, when the HSE clock is used as RTC clock source, the RTC
N  *         cannot be used in STOP and STANDBY modes.    
N  * @note   The maximum input clock frequency for RTC is 1MHz (when using HSE as
N  *         RTC clock source).
N  */
N#define __HAL_RCC_RTC_CLKPRESCALER(__RTCCLKSource__) (((__RTCCLKSource__) & RCC_BDCR_RTCSEL) == RCC_BDCR_RTCSEL) ?    \
N                                                 MODIFY_REG(RCC->CFGR, RCC_CFGR_RTCPRE, ((__RTCCLKSource__) & 0xFFFFCFF)) : CLEAR_BIT(RCC->CFGR, RCC_CFGR_RTCPRE)
X#define __HAL_RCC_RTC_CLKPRESCALER(__RTCCLKSource__) (((__RTCCLKSource__) & RCC_BDCR_RTCSEL) == RCC_BDCR_RTCSEL) ?                                                     MODIFY_REG(RCC->CFGR, RCC_CFGR_RTCPRE, ((__RTCCLKSource__) & 0xFFFFCFF)) : CLEAR_BIT(RCC->CFGR, RCC_CFGR_RTCPRE)
N                                                   
N#define __HAL_RCC_RTC_CONFIG(__RTCCLKSource__) do { __HAL_RCC_RTC_CLKPRESCALER(__RTCCLKSource__);    \
N                                                    RCC->BDCR |= ((__RTCCLKSource__) & 0x00000FFF);  \
N                                                   } while (0)
X#define __HAL_RCC_RTC_CONFIG(__RTCCLKSource__) do { __HAL_RCC_RTC_CLKPRESCALER(__RTCCLKSource__);                                                        RCC->BDCR |= ((__RTCCLKSource__) & 0x00000FFF);                                                     } while (0)
N
N/** @brief  Macros to force or release the Backup domain reset.
N  * @note   This function resets the RTC peripheral (including the backup registers)
N  *         and the RTC clock source selection in RCC_CSR register.
N  * @note   The BKPSRAM is not affected by this reset.   
N  */
N#define __HAL_RCC_BACKUPRESET_FORCE()   (RCC->BDCR |= (RCC_BDCR_BDRST))
N#define __HAL_RCC_BACKUPRESET_RELEASE() (RCC->BDCR &= ~(RCC_BDCR_BDRST))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_PLL_Configuration PLL Configuration
N  * @{   
N  */
N
N/** @brief  Macros to enable or disable the main PLL.
N  * @note   After enabling the main PLL, the application software should wait on 
N  *         PLLRDY flag to be set indicating that PLL clock is stable and can
N  *         be used as system clock source.
N  * @note   The main PLL can not be disabled if it is used as system clock source
N  * @note   The main PLL is disabled by hardware when entering STOP and STANDBY modes.
N  */
N#define __HAL_RCC_PLL_ENABLE() SET_BIT(RCC->CR, RCC_CR_PLLON)
N#define __HAL_RCC_PLL_DISABLE() CLEAR_BIT(RCC->CR, RCC_CR_PLLON)
N                            
N/** @brief  Macro to configure the PLL clock source.
N  * @note   This function must be used only when the main PLL is disabled.
N  * @param  __PLLSOURCE__: specifies the PLL entry clock source.
N  *         This parameter can be one of the following values:
N  *            @arg RCC_PLLSOURCE_HSI: HSI oscillator clock selected as PLL clock entry
N  *            @arg RCC_PLLSOURCE_HSE: HSE oscillator clock selected as PLL clock entry
N  *      
N  */
N#define __HAL_RCC_PLL_PLLSOURCE_CONFIG(__PLLSOURCE__) MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, (__PLLSOURCE__))
N
N/** @brief  Macro to configure the PLL multiplication factor.
N  * @note   This function must be used only when the main PLL is disabled.
N  * @param  __PLLM__: specifies the division factor for PLL VCO input clock
N  *         This parameter must be a number between Min_Data = 2 and Max_Data = 63.
N  * @note   You have to set the PLLM parameter correctly to ensure that the VCO input
N  *         frequency ranges from 1 to 2 MHz. It is recommended to select a frequency
N  *         of 2 MHz to limit PLL jitter.
N  *      
N  */
N#define __HAL_RCC_PLL_PLLM_CONFIG(__PLLM__) MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLM, (__PLLM__))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_PLL_I2S_Configuration PLL I2S Configuration
N  * @{   
N  */
N
N/** @brief  Macro to configure the I2S clock source (I2SCLK).
N  * @note   This function must be called before enabling the I2S APB clock.
N  * @param  __SOURCE__: specifies the I2S clock source.
N  *         This parameter can be one of the following values:
N  *            @arg RCC_I2SCLKSOURCE_PLLI2S: PLLI2S clock used as I2S clock source.
N  *            @arg RCC_I2SCLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin
N  *                                       used as I2S clock source.
N  */
N#define __HAL_RCC_I2S_CONFIG(__SOURCE__) do {RCC->CFGR &= ~(RCC_CFGR_I2SSRC); \
N                                             RCC->CFGR |= (__SOURCE__);       \
N                                            }while(0)
X#define __HAL_RCC_I2S_CONFIG(__SOURCE__) do {RCC->CFGR &= ~(RCC_CFGR_I2SSRC);                                              RCC->CFGR |= (__SOURCE__);                                                   }while(0)
N
N/** @brief Macros to enable or disable the PLLI2S. 
N  * @note  The PLLI2S is disabled by hardware when entering STOP and STANDBY modes.
N  */
N#define __HAL_RCC_PLLI2S_ENABLE() (RCC->CR |= (RCC_CR_PLLI2SON))
N#define __HAL_RCC_PLLI2S_DISABLE() (RCC->CR &= ~(RCC_CR_PLLI2SON))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_Get_Clock_source Get Clock source
N  * @{   
N  */
N/**
N  * @brief Macro to configure the system clock source.
N  * @param __RCC_SYSCLKSOURCE__: specifies the system clock source.
N  * This parameter can be one of the following values:
N  *              - RCC_SYSCLKSOURCE_HSI: HSI oscillator is used as system clock source.
N  *              - RCC_SYSCLKSOURCE_HSE: HSE oscillator is used as system clock source.
N  *              - RCC_SYSCLKSOURCE_PLLCLK: PLL output is used as system clock source.
N  */
N#define __HAL_RCC_SYSCLK_CONFIG(__RCC_SYSCLKSOURCE__) MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, (__RCC_SYSCLKSOURCE__))
N
N/** @brief  Macro to get the clock source used as system clock.
N  * @retval The clock source used as system clock. The returned value can be one
N  *         of the following:
N  *              - RCC_SYSCLKSOURCE_STATUS_HSI: HSI used as system clock.
N  *              - RCC_SYSCLKSOURCE_STATUS_HSE: HSE used as system clock.
N  *              - RCC_SYSCLKSOURCE_STATUS_PLLCLK: PLL used as system clock.
N  */     
N#define __HAL_RCC_GET_SYSCLK_SOURCE() ((uint32_t)(RCC->CFGR & RCC_CFGR_SWS))
N
N/**
N  * @brief  Macro to configures the External Low Speed oscillator (LSE) drive capability.
N  * @note   As the LSE is in the Backup domain and write access is denied to
N  *         this domain after reset, you have to enable write access using
N  *         HAL_PWR_EnableBkUpAccess() function before to configure the LSE
N  *         (to be done once after reset).
N  * @param  __RCC_LSEDRIVE__: specifies the new state of the LSE drive capability.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_LSEDRIVE_LOW: LSE oscillator low drive capability.
N  *            @arg RCC_LSEDRIVE_MEDIUMLOW: LSE oscillator medium low drive capability.
N  *            @arg RCC_LSEDRIVE_MEDIUMHIGH: LSE oscillator medium high drive capability.
N  *            @arg RCC_LSEDRIVE_HIGH: LSE oscillator high drive capability.
N  * @retval None
N  */
N#define __HAL_RCC_LSEDRIVE_CONFIG(__RCC_LSEDRIVE__) \
N                  (MODIFY_REG(RCC->BDCR, RCC_BDCR_LSEDRV, (uint32_t)(__RCC_LSEDRIVE__) ))
X#define __HAL_RCC_LSEDRIVE_CONFIG(__RCC_LSEDRIVE__)                   (MODIFY_REG(RCC->BDCR, RCC_BDCR_LSEDRV, (uint32_t)(__RCC_LSEDRIVE__) ))
N
N/** @brief  Macro to get the oscillator used as PLL clock source.
N  * @retval The oscillator used as PLL clock source. The returned value can be one
N  *         of the following:
N  *              - RCC_PLLSOURCE_HSI: HSI oscillator is used as PLL clock source.
N  *              - RCC_PLLSOURCE_HSE: HSE oscillator is used as PLL clock source.
N  */
N#define __HAL_RCC_GET_PLL_OSCSOURCE() ((uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC))
N/**
N  * @}
N  */
N  
N/** @defgroup RCCEx_MCOx_Clock_Config RCC Extended MCOx Clock Config
N  * @{   
N  */ 
N  
N/** @brief  Macro to configure the MCO1 clock.
N  * @param  __MCOCLKSOURCE__ specifies the MCO clock source.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_MCO1SOURCE_HSI: HSI clock selected as MCO1 source
N  *            @arg RCC_MCO1SOURCE_LSE: LSE clock selected as MCO1 source
N  *            @arg RCC_MCO1SOURCE_HSE: HSE clock selected as MCO1 source
N  *            @arg RCC_MCO1SOURCE_PLLCLK: main PLL clock selected as MCO1 source
N  * @param  __MCODIV__ specifies the MCO clock prescaler.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_MCODIV_1: no division applied to MCOx clock
N  *            @arg RCC_MCODIV_2: division by 2 applied to MCOx clock
N  *            @arg RCC_MCODIV_3: division by 3 applied to MCOx clock
N  *            @arg RCC_MCODIV_4: division by 4 applied to MCOx clock
N  *            @arg RCC_MCODIV_5: division by 5 applied to MCOx clock
N  */
N
N#define __HAL_RCC_MCO1_CONFIG(__MCOCLKSOURCE__, __MCODIV__) \
N        MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), ((__MCOCLKSOURCE__) | (__MCODIV__)))
X#define __HAL_RCC_MCO1_CONFIG(__MCOCLKSOURCE__, __MCODIV__)         MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), ((__MCOCLKSOURCE__) | (__MCODIV__)))
N                
N/** @brief  Macro to configure the MCO2 clock.
N  * @param  __MCOCLKSOURCE__ specifies the MCO clock source.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_MCO2SOURCE_SYSCLK: System clock (SYSCLK) selected as MCO2 source
N  *            @arg RCC_MCO2SOURCE_PLLI2SCLK: PLLI2S clock selected as MCO2 source 
N  *            @arg RCC_MCO2SOURCE_HSE: HSE clock selected as MCO2 source
N  *            @arg RCC_MCO2SOURCE_PLLCLK: main PLL clock selected as MCO2 source
N  * @param  __MCODIV__ specifies the MCO clock prescaler.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_MCODIV_1: no division applied to MCOx clock
N  *            @arg RCC_MCODIV_2: division by 2 applied to MCOx clock
N  *            @arg RCC_MCODIV_3: division by 3 applied to MCOx clock
N  *            @arg RCC_MCODIV_4: division by 4 applied to MCOx clock
N  *            @arg RCC_MCODIV_5: division by 5 applied to MCOx clock
N  */
N
N#define __HAL_RCC_MCO2_CONFIG(__MCOCLKSOURCE__, __MCODIV__) \
N        MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), ((__MCOCLKSOURCE__) | ((__MCODIV__) << 3)));
X#define __HAL_RCC_MCO2_CONFIG(__MCOCLKSOURCE__, __MCODIV__)         MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), ((__MCOCLKSOURCE__) | ((__MCODIV__) << 3)));
N/**
N  * @}
N  */
N  
N/** @defgroup RCC_Flags_Interrupts_Management Flags Interrupts Management
N  * @brief macros to manage the specified RCC Flags and interrupts.
N  * @{
N  */
N
N/** @brief  Enable RCC interrupt (Perform Byte access to RCC_CIR[14:8] bits to enable
N  *         the selected interrupts).
N  * @param  __INTERRUPT__: specifies the RCC interrupt sources to be enabled.
N  *         This parameter can be any combination of the following values:
N  *            @arg RCC_IT_LSIRDY: LSI ready interrupt.
N  *            @arg RCC_IT_LSERDY: LSE ready interrupt.
N  *            @arg RCC_IT_HSIRDY: HSI ready interrupt.
N  *            @arg RCC_IT_HSERDY: HSE ready interrupt.
N  *            @arg RCC_IT_PLLRDY: Main PLL ready interrupt.
N  *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt.
N  */
N#define __HAL_RCC_ENABLE_IT(__INTERRUPT__) (*(__IO uint8_t *) RCC_CIR_BYTE1_ADDRESS |= (__INTERRUPT__))
N
N/** @brief Disable RCC interrupt (Perform Byte access to RCC_CIR[14:8] bits to disable 
N  *        the selected interrupts).
N  * @param  __INTERRUPT__: specifies the RCC interrupt sources to be disabled.
N  *         This parameter can be any combination of the following values:
N  *            @arg RCC_IT_LSIRDY: LSI ready interrupt.
N  *            @arg RCC_IT_LSERDY: LSE ready interrupt.
N  *            @arg RCC_IT_HSIRDY: HSI ready interrupt.
N  *            @arg RCC_IT_HSERDY: HSE ready interrupt.
N  *            @arg RCC_IT_PLLRDY: Main PLL ready interrupt.
N  *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt.
N  */
N#define __HAL_RCC_DISABLE_IT(__INTERRUPT__) (*(__IO uint8_t *) RCC_CIR_BYTE1_ADDRESS &= (uint8_t)(~(__INTERRUPT__)))
N
N/** @brief  Clear the RCC's interrupt pending bits (Perform Byte access to RCC_CIR[23:16]
N  *         bits to clear the selected interrupt pending bits.
N  * @param  __INTERRUPT__: specifies the interrupt pending bit to clear.
N  *         This parameter can be any combination of the following values:
N  *            @arg RCC_IT_LSIRDY: LSI ready interrupt.
N  *            @arg RCC_IT_LSERDY: LSE ready interrupt.
N  *            @arg RCC_IT_HSIRDY: HSI ready interrupt.
N  *            @arg RCC_IT_HSERDY: HSE ready interrupt.
N  *            @arg RCC_IT_PLLRDY: Main PLL ready interrupt.
N  *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt.  
N  *            @arg RCC_IT_CSS: Clock Security System interrupt
N  */
N#define __HAL_RCC_CLEAR_IT(__INTERRUPT__) (*(__IO uint8_t *) RCC_CIR_BYTE2_ADDRESS = (__INTERRUPT__))
N
N/** @brief  Check the RCC's interrupt has occurred or not.
N  * @param  __INTERRUPT__: specifies the RCC interrupt source to check.
N  *         This parameter can be one of the following values:
N  *            @arg RCC_IT_LSIRDY: LSI ready interrupt.
N  *            @arg RCC_IT_LSERDY: LSE ready interrupt.
N  *            @arg RCC_IT_HSIRDY: HSI ready interrupt.
N  *            @arg RCC_IT_HSERDY: HSE ready interrupt.
N  *            @arg RCC_IT_PLLRDY: Main PLL ready interrupt.
N  *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt.
N  *            @arg RCC_IT_CSS: Clock Security System interrupt
N  * @retval The new state of __INTERRUPT__ (TRUE or FALSE).
N  */
N#define __HAL_RCC_GET_IT(__INTERRUPT__) ((RCC->CIR & (__INTERRUPT__)) == (__INTERRUPT__))
N
N/** @brief Set RMVF bit to clear the reset flags: RCC_FLAG_PINRST, RCC_FLAG_PORRST, 
N  *        RCC_FLAG_SFTRST, RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST and RCC_FLAG_LPWRRST.
N  */
N#define __HAL_RCC_CLEAR_RESET_FLAGS() (RCC->CSR |= RCC_CSR_RMVF)
N
N/** @brief  Check RCC flag is set or not.
N  * @param  __FLAG__: specifies the flag to check.
N  *         This parameter can be one of the following values:
N  *            @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready.
N  *            @arg RCC_FLAG_HSERDY: HSE oscillator clock ready.
N  *            @arg RCC_FLAG_PLLRDY: Main PLL clock ready.
N  *            @arg RCC_FLAG_PLLI2SRDY: PLLI2S clock ready.
N  *            @arg RCC_FLAG_LSERDY: LSE oscillator clock ready.
N  *            @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready.
N  *            @arg RCC_FLAG_BORRST: POR/PDR or BOR reset.
N  *            @arg RCC_FLAG_PINRST: Pin reset.
N  *            @arg RCC_FLAG_PORRST: POR/PDR reset.
N  *            @arg RCC_FLAG_SFTRST: Software reset.
N  *            @arg RCC_FLAG_IWDGRST: Independent Watchdog reset.
N  *            @arg RCC_FLAG_WWDGRST: Window Watchdog reset.
N  *            @arg RCC_FLAG_LPWRRST: Low Power reset.
N  * @retval The new state of __FLAG__ (TRUE or FALSE).
N  */
N#define RCC_FLAG_MASK  ((uint8_t)0x1F)
N#define __HAL_RCC_GET_FLAG(__FLAG__) (((((((__FLAG__) >> 5) == 1)? RCC->CR :((((__FLAG__) >> 5) == 2) ? RCC->BDCR :((((__FLAG__) >> 5) == 3)? RCC->CSR :RCC->CIR))) & ((uint32_t)1 << ((__FLAG__) & RCC_FLAG_MASK)))!= 0)? 1 : 0)
N
N/**
N  * @}
N  */
N     
N/**
N  * @}
N  */
N
N/* Include RCC HAL Extension module */
N#include "stm32f7xx_hal_rcc_ex.h"
N
N/* Exported functions --------------------------------------------------------*/
N /** @addtogroup RCC_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup RCC_Exported_Functions_Group1
N  * @{
N  */                             
N/* Initialization and de-initialization functions  ******************************/
Nvoid HAL_RCC_DeInit(void);
NHAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef *RCC_OscInitStruct);
NHAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef *RCC_ClkInitStruct, uint32_t FLatency);
N/**
N  * @}
N  */
N
N/** @addtogroup RCC_Exported_Functions_Group2
N  * @{
N  */
N/* Peripheral Control functions  ************************************************/
Nvoid     HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv);
Nvoid     HAL_RCC_EnableCSS(void);
Nvoid     HAL_RCC_DisableCSS(void);
Nuint32_t HAL_RCC_GetSysClockFreq(void);
Nuint32_t HAL_RCC_GetHCLKFreq(void);
Nuint32_t HAL_RCC_GetPCLK1Freq(void);
Nuint32_t HAL_RCC_GetPCLK2Freq(void);
Nvoid     HAL_RCC_GetOscConfig(RCC_OscInitTypeDef *RCC_OscInitStruct);
Nvoid     HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef *RCC_ClkInitStruct, uint32_t *pFLatency);
N
N/* CSS NMI IRQ handler */
Nvoid HAL_RCC_NMI_IRQHandler(void);
N
N/* User Callbacks in non blocking mode (IT mode) */ 
Nvoid HAL_RCC_CSSCallback(void);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup RCC_Private_Constants RCC Private Constants
N  * @{
N  */
N#define HSE_TIMEOUT_VALUE          HSE_STARTUP_TIMEOUT
N#define HSI_TIMEOUT_VALUE          ((uint32_t)2)  /* 2 ms */
N#define LSI_TIMEOUT_VALUE          ((uint32_t)2)  /* 2 ms */
N#define PLL_TIMEOUT_VALUE          ((uint32_t)2)  /* 2 ms */
N#define CLOCKSWITCH_TIMEOUT_VALUE  ((uint32_t)5000) /* 5 s    */ 
N
N/** @defgroup RCC_BitAddress_Alias RCC BitAddress Alias
N  * @brief RCC registers bit address alias
N  * @{
N  */
N/* CIR register byte 2 (Bits[15:8]) base address */
N#define RCC_CIR_BYTE1_ADDRESS         ((uint32_t)(RCC_BASE + 0x0C + 0x01))
N
N/* CIR register byte 3 (Bits[23:16]) base address */
N#define RCC_CIR_BYTE2_ADDRESS         ((uint32_t)(RCC_BASE + 0x0C + 0x02))
N
N#define RCC_DBP_TIMEOUT_VALUE      ((uint32_t)100)
N#define RCC_LSE_TIMEOUT_VALUE      LSE_STARTUP_TIMEOUT
N/**
N  * @}
N  */
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @addtogroup RCC_Private_Macros RCC Private Macros
N  * @{
N  */
N    
N/** @defgroup RCC_IS_RCC_Definitions RCC Private macros to check input parameters
N  * @{
N  */  
N#define IS_RCC_OSCILLATORTYPE(OSCILLATOR) ((OSCILLATOR) <= 15)
N
N#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) || \
N                         ((HSE) == RCC_HSE_BYPASS))
X#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) ||                          ((HSE) == RCC_HSE_BYPASS))
N
N#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) || \
N                         ((LSE) == RCC_LSE_BYPASS))
X#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) ||                          ((LSE) == RCC_LSE_BYPASS))
N
N#define IS_RCC_HSI(HSI) (((HSI) == RCC_HSI_OFF) || ((HSI) == RCC_HSI_ON))
N
N#define IS_RCC_LSI(LSI) (((LSI) == RCC_LSI_OFF) || ((LSI) == RCC_LSI_ON))
N
N#define IS_RCC_PLL(PLL) (((PLL) == RCC_PLL_NONE) ||((PLL) == RCC_PLL_OFF) || ((PLL) == RCC_PLL_ON))
N
N#define IS_RCC_PLLSOURCE(SOURCE) (((SOURCE) == RCC_PLLSOURCE_HSI) || \
N                                  ((SOURCE) == RCC_PLLSOURCE_HSE))
X#define IS_RCC_PLLSOURCE(SOURCE) (((SOURCE) == RCC_PLLSOURCE_HSI) ||                                   ((SOURCE) == RCC_PLLSOURCE_HSE))
N
N#define IS_RCC_SYSCLKSOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSOURCE_HSI) || \
N                                     ((SOURCE) == RCC_SYSCLKSOURCE_HSE) || \
N                                     ((SOURCE) == RCC_SYSCLKSOURCE_PLLCLK))
X#define IS_RCC_SYSCLKSOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSOURCE_HSI) ||                                      ((SOURCE) == RCC_SYSCLKSOURCE_HSE) ||                                      ((SOURCE) == RCC_SYSCLKSOURCE_PLLCLK))
N#define IS_RCC_PLLM_VALUE(VALUE) ((2 <= (VALUE)) && ((VALUE) <= 63))
N
N#define IS_RCC_PLLN_VALUE(VALUE) ((50 <= (VALUE)) && ((VALUE) <= 432))
N
N#define IS_RCC_PLLP_VALUE(VALUE) (((VALUE) == RCC_PLLP_DIV2) || ((VALUE) == RCC_PLLP_DIV4) || \
N                                  ((VALUE) == RCC_PLLP_DIV6) || ((VALUE) == RCC_PLLP_DIV8))
X#define IS_RCC_PLLP_VALUE(VALUE) (((VALUE) == RCC_PLLP_DIV2) || ((VALUE) == RCC_PLLP_DIV4) ||                                   ((VALUE) == RCC_PLLP_DIV6) || ((VALUE) == RCC_PLLP_DIV8))
N#define IS_RCC_PLLQ_VALUE(VALUE) ((2 <= (VALUE)) && ((VALUE) <= 15))
N
N#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_DIV1)   || ((HCLK) == RCC_SYSCLK_DIV2)   || \
N                           ((HCLK) == RCC_SYSCLK_DIV4)   || ((HCLK) == RCC_SYSCLK_DIV8)   || \
N                           ((HCLK) == RCC_SYSCLK_DIV16)  || ((HCLK) == RCC_SYSCLK_DIV64)  || \
N                           ((HCLK) == RCC_SYSCLK_DIV128) || ((HCLK) == RCC_SYSCLK_DIV256) || \
N                           ((HCLK) == RCC_SYSCLK_DIV512))
X#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_DIV1)   || ((HCLK) == RCC_SYSCLK_DIV2)   ||                            ((HCLK) == RCC_SYSCLK_DIV4)   || ((HCLK) == RCC_SYSCLK_DIV8)   ||                            ((HCLK) == RCC_SYSCLK_DIV16)  || ((HCLK) == RCC_SYSCLK_DIV64)  ||                            ((HCLK) == RCC_SYSCLK_DIV128) || ((HCLK) == RCC_SYSCLK_DIV256) ||                            ((HCLK) == RCC_SYSCLK_DIV512))
N
N#define IS_RCC_CLOCKTYPE(CLK) ((1 <= (CLK)) && ((CLK) <= 15))
N
N#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_DIV1) || ((PCLK) == RCC_HCLK_DIV2) || \
N                           ((PCLK) == RCC_HCLK_DIV4) || ((PCLK) == RCC_HCLK_DIV8) || \
N                           ((PCLK) == RCC_HCLK_DIV16))
X#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_DIV1) || ((PCLK) == RCC_HCLK_DIV2) ||                            ((PCLK) == RCC_HCLK_DIV4) || ((PCLK) == RCC_HCLK_DIV8) ||                            ((PCLK) == RCC_HCLK_DIV16))
N
N#define IS_RCC_MCO(MCOX) (((MCOX) == RCC_MCO1) || ((MCOX) == RCC_MCO2))
N
N
N#define IS_RCC_MCO1SOURCE(SOURCE) (((SOURCE) == RCC_MCO1SOURCE_HSI) || ((SOURCE) == RCC_MCO1SOURCE_LSE) || \
N                                   ((SOURCE) == RCC_MCO1SOURCE_HSE) || ((SOURCE) == RCC_MCO1SOURCE_PLLCLK))
X#define IS_RCC_MCO1SOURCE(SOURCE) (((SOURCE) == RCC_MCO1SOURCE_HSI) || ((SOURCE) == RCC_MCO1SOURCE_LSE) ||                                    ((SOURCE) == RCC_MCO1SOURCE_HSE) || ((SOURCE) == RCC_MCO1SOURCE_PLLCLK))
N
N#define IS_RCC_MCO2SOURCE(SOURCE) (((SOURCE) == RCC_MCO2SOURCE_SYSCLK) || ((SOURCE) == RCC_MCO2SOURCE_PLLI2SCLK)|| \
N                                   ((SOURCE) == RCC_MCO2SOURCE_HSE)    || ((SOURCE) == RCC_MCO2SOURCE_PLLCLK))
X#define IS_RCC_MCO2SOURCE(SOURCE) (((SOURCE) == RCC_MCO2SOURCE_SYSCLK) || ((SOURCE) == RCC_MCO2SOURCE_PLLI2SCLK)||                                    ((SOURCE) == RCC_MCO2SOURCE_HSE)    || ((SOURCE) == RCC_MCO2SOURCE_PLLCLK))
N
N#define IS_RCC_MCODIV(DIV) (((DIV) == RCC_MCODIV_1)  || ((DIV) == RCC_MCODIV_2) || \
N                             ((DIV) == RCC_MCODIV_3) || ((DIV) == RCC_MCODIV_4) || \
N                             ((DIV) == RCC_MCODIV_5)) 
X#define IS_RCC_MCODIV(DIV) (((DIV) == RCC_MCODIV_1)  || ((DIV) == RCC_MCODIV_2) ||                              ((DIV) == RCC_MCODIV_3) || ((DIV) == RCC_MCODIV_4) ||                              ((DIV) == RCC_MCODIV_5)) 
N#define IS_RCC_CALIBRATION_VALUE(VALUE) ((VALUE) <= 0x1F)
N
N#define IS_RCC_RTCCLKSOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSOURCE_LSE) || ((SOURCE) == RCC_RTCCLKSOURCE_LSI) || \
N                                     ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV2) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV3) || \
N                                     ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV4) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV5) || \
N                                     ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV6) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV7) || \
N                                     ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV8) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV9) || \
N                                     ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV10) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV11) || \
N                                     ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV12) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV13) || \
N                                     ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV14) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV15) || \
N                                     ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV16) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV17) || \
N                                     ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV18) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV19) || \
N                                     ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV20) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV21) || \
N                                     ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV22) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV23) || \
N                                     ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV24) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV25) || \
N                                     ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV26) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV27) || \
N                                     ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV28) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV29) || \
N                                     ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV30) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV31))
X#define IS_RCC_RTCCLKSOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSOURCE_LSE) || ((SOURCE) == RCC_RTCCLKSOURCE_LSI) ||                                      ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV2) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV3) ||                                      ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV4) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV5) ||                                      ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV6) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV7) ||                                      ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV8) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV9) ||                                      ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV10) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV11) ||                                      ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV12) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV13) ||                                      ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV14) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV15) ||                                      ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV16) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV17) ||                                      ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV18) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV19) ||                                      ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV20) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV21) ||                                      ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV22) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV23) ||                                      ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV24) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV25) ||                                      ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV26) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV27) ||                                      ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV28) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV29) ||                                      ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV30) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV31))
N
N
N#define IS_RCC_LSE_DRIVE(DRIVE) (((DRIVE) == RCC_LSEDRIVE_LOW)        || \
N                                 ((DRIVE) == RCC_LSEDRIVE_MEDIUMLOW)  || \
N                                 ((DRIVE) == RCC_LSEDRIVE_MEDIUMHIGH) || \
N                                 ((DRIVE) == RCC_LSEDRIVE_HIGH))
X#define IS_RCC_LSE_DRIVE(DRIVE) (((DRIVE) == RCC_LSEDRIVE_LOW)        ||                                  ((DRIVE) == RCC_LSEDRIVE_MEDIUMLOW)  ||                                  ((DRIVE) == RCC_LSEDRIVE_MEDIUMHIGH) ||                                  ((DRIVE) == RCC_LSEDRIVE_HIGH))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_RCC_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 247 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_RCC_MODULE_ENABLED */
N
N#ifdef HAL_GPIO_MODULE_ENABLED
N  #include "stm32f7xx_hal_gpio.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_gpio.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_gpio.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of GPIO HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_GPIO_H
N#define __STM32F7xx_HAL_GPIO_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup GPIO
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup GPIO_Exported_Types GPIO Exported Types
N  * @{
N  */
N
N/** 
N  * @brief GPIO Init structure definition  
N  */ 
Ntypedef struct
N{
N  uint32_t Pin;       /*!< Specifies the GPIO pins to be configured.
N                           This parameter can be any value of @ref GPIO_pins_define */
N
N  uint32_t Mode;      /*!< Specifies the operating mode for the selected pins.
N                           This parameter can be a value of @ref GPIO_mode_define */
N
N  uint32_t Pull;      /*!< Specifies the Pull-up or Pull-Down activation for the selected pins.
N                           This parameter can be a value of @ref GPIO_pull_define */
N
N  uint32_t Speed;     /*!< Specifies the speed for the selected pins.
N                           This parameter can be a value of @ref GPIO_speed_define */
N
N  uint32_t Alternate;  /*!< Peripheral to be connected to the selected pins. 
N                            This parameter can be a value of @ref GPIO_Alternate_function_selection */
N}GPIO_InitTypeDef;
N
N/** 
N  * @brief  GPIO Bit SET and Bit RESET enumeration 
N  */
Ntypedef enum
N{
N  GPIO_PIN_RESET = 0,
N  GPIO_PIN_SET
N}GPIO_PinState;
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup GPIO_Exported_Constants GPIO Exported Constants
N  * @{
N  */ 
N
N/** @defgroup GPIO_pins_define GPIO pins define
N  * @{
N  */
N#define GPIO_PIN_0                 ((uint16_t)0x0001U)  /* Pin 0 selected    */
N#define GPIO_PIN_1                 ((uint16_t)0x0002U)  /* Pin 1 selected    */
N#define GPIO_PIN_2                 ((uint16_t)0x0004U)  /* Pin 2 selected    */
N#define GPIO_PIN_3                 ((uint16_t)0x0008U)  /* Pin 3 selected    */
N#define GPIO_PIN_4                 ((uint16_t)0x0010U)  /* Pin 4 selected    */
N#define GPIO_PIN_5                 ((uint16_t)0x0020U)  /* Pin 5 selected    */
N#define GPIO_PIN_6                 ((uint16_t)0x0040U)  /* Pin 6 selected    */
N#define GPIO_PIN_7                 ((uint16_t)0x0080U)  /* Pin 7 selected    */
N#define GPIO_PIN_8                 ((uint16_t)0x0100U)  /* Pin 8 selected    */
N#define GPIO_PIN_9                 ((uint16_t)0x0200U)  /* Pin 9 selected    */
N#define GPIO_PIN_10                ((uint16_t)0x0400U)  /* Pin 10 selected   */
N#define GPIO_PIN_11                ((uint16_t)0x0800U)  /* Pin 11 selected   */
N#define GPIO_PIN_12                ((uint16_t)0x1000U)  /* Pin 12 selected   */
N#define GPIO_PIN_13                ((uint16_t)0x2000U)  /* Pin 13 selected   */
N#define GPIO_PIN_14                ((uint16_t)0x4000U)  /* Pin 14 selected   */
N#define GPIO_PIN_15                ((uint16_t)0x8000U)  /* Pin 15 selected   */
N#define GPIO_PIN_All               ((uint16_t)0xFFFFU)  /* All pins selected */
N
N#define GPIO_PIN_MASK              ((uint32_t)0x0000FFFFU) /* PIN mask for assert test */
N/**
N  * @}
N  */
N
N/** @defgroup GPIO_mode_define GPIO mode define
N  * @brief GPIO Configuration Mode 
N  *        Elements values convention: 0xX0yz00YZ
N  *           - X  : GPIO mode or EXTI Mode
N  *           - y  : External IT or Event trigger detection 
N  *           - z  : IO configuration on External IT or Event
N  *           - Y  : Output type (Push Pull or Open Drain)
N  *           - Z  : IO Direction mode (Input, Output, Alternate or Analog)
N  * @{
N  */ 
N#define  GPIO_MODE_INPUT                        ((uint32_t)0x00000000U)   /*!< Input Floating Mode                   */
N#define  GPIO_MODE_OUTPUT_PP                    ((uint32_t)0x00000001U)   /*!< Output Push Pull Mode                 */
N#define  GPIO_MODE_OUTPUT_OD                    ((uint32_t)0x00000011U)   /*!< Output Open Drain Mode                */
N#define  GPIO_MODE_AF_PP                        ((uint32_t)0x00000002U)   /*!< Alternate Function Push Pull Mode     */
N#define  GPIO_MODE_AF_OD                        ((uint32_t)0x00000012U)   /*!< Alternate Function Open Drain Mode    */
N
N#define  GPIO_MODE_ANALOG                       ((uint32_t)0x00000003U)   /*!< Analog Mode  */
N    
N#define  GPIO_MODE_IT_RISING                    ((uint32_t)0x10110000U)   /*!< External Interrupt Mode with Rising edge trigger detection          */
N#define  GPIO_MODE_IT_FALLING                   ((uint32_t)0x10210000U)   /*!< External Interrupt Mode with Falling edge trigger detection         */
N#define  GPIO_MODE_IT_RISING_FALLING            ((uint32_t)0x10310000U)   /*!< External Interrupt Mode with Rising/Falling edge trigger detection  */
N 
N#define  GPIO_MODE_EVT_RISING                   ((uint32_t)0x10120000U)   /*!< External Event Mode with Rising edge trigger detection               */
N#define  GPIO_MODE_EVT_FALLING                  ((uint32_t)0x10220000U)   /*!< External Event Mode with Falling edge trigger detection              */
N#define  GPIO_MODE_EVT_RISING_FALLING           ((uint32_t)0x10320000U)   /*!< External Event Mode with Rising/Falling edge trigger detection       */
N/**
N  * @}
N  */
N
N/** @defgroup GPIO_speed_define  GPIO speed define
N  * @brief GPIO Output Maximum frequency
N  * @{
N  */  
N#define  GPIO_SPEED_FREQ_LOW         ((uint32_t)0x00000000U)  /*!< Low speed     */
N#define  GPIO_SPEED_FREQ_MEDIUM      ((uint32_t)0x00000001U)  /*!< Medium speed  */
N#define  GPIO_SPEED_FREQ_HIGH        ((uint32_t)0x00000002U)  /*!< Fast speed    */
N#define  GPIO_SPEED_FREQ_VERY_HIGH   ((uint32_t)0x00000003U)  /*!< High speed    */
N/**
N  * @}
N  */
N
N /** @defgroup GPIO_pull_define GPIO pull define
N   * @brief GPIO Pull-Up or Pull-Down Activation
N   * @{
N   */  
N#define  GPIO_NOPULL        ((uint32_t)0x00000000U)   /*!< No Pull-up or Pull-down activation  */
N#define  GPIO_PULLUP        ((uint32_t)0x00000001U)   /*!< Pull-up activation                  */
N#define  GPIO_PULLDOWN      ((uint32_t)0x00000002U)   /*!< Pull-down activation                */
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup GPIO_Exported_Macros GPIO Exported Macros
N  * @{
N  */
N
N/**
N  * @brief  Checks whether the specified EXTI line flag is set or not.
N  * @param  __EXTI_LINE__: specifies the EXTI line flag to check.
N  *         This parameter can be GPIO_PIN_x where x can be(0..15)
N  * @retval The new state of __EXTI_LINE__ (SET or RESET).
N  */
N#define __HAL_GPIO_EXTI_GET_FLAG(__EXTI_LINE__) (EXTI->PR & (__EXTI_LINE__))
N
N/**
N  * @brief  Clears the EXTI's line pending flags.
N  * @param  __EXTI_LINE__: specifies the EXTI lines flags to clear.
N  *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15)
N  * @retval None
N  */
N#define __HAL_GPIO_EXTI_CLEAR_FLAG(__EXTI_LINE__) (EXTI->PR = (__EXTI_LINE__))
N
N/**
N  * @brief  Checks whether the specified EXTI line is asserted or not.
N  * @param  __EXTI_LINE__: specifies the EXTI line to check.
N  *          This parameter can be GPIO_PIN_x where x can be(0..15)
N  * @retval The new state of __EXTI_LINE__ (SET or RESET).
N  */
N#define __HAL_GPIO_EXTI_GET_IT(__EXTI_LINE__) (EXTI->PR & (__EXTI_LINE__))
N
N/**
N  * @brief  Clears the EXTI's line pending bits.
N  * @param  __EXTI_LINE__: specifies the EXTI lines to clear.
N  *          This parameter can be any combination of GPIO_PIN_x where x can be (0..15)
N  * @retval None
N  */
N#define __HAL_GPIO_EXTI_CLEAR_IT(__EXTI_LINE__) (EXTI->PR = (__EXTI_LINE__))
N
N/**
N  * @brief  Generates a Software interrupt on selected EXTI line.
N  * @param  __EXTI_LINE__: specifies the EXTI line to check.
N  *          This parameter can be GPIO_PIN_x where x can be(0..15)
N  * @retval None
N  */
N#define __HAL_GPIO_EXTI_GENERATE_SWIT(__EXTI_LINE__) (EXTI->SWIER |= (__EXTI_LINE__))
N/**
N  * @}
N  */
N
N/* Include GPIO HAL Extension module */
N#include "stm32f7xx_hal_gpio_ex.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_gpio_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_gpio_ex.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of GPIO HAL Extension module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_GPIO_EX_H
N#define __STM32F7xx_HAL_GPIO_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @defgroup GPIOEx GPIOEx
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup GPIOEx_Exported_Constants GPIO Exported Constants
N  * @{
N  */
N  
N/** @defgroup GPIO_Alternate_function_selection GPIO Alternate Function Selection
N  * @{
N  */  
N
N/** 
N  * @brief   AF 0 selection  
N  */ 
N#define GPIO_AF0_RTC_50Hz      ((uint8_t)0x00U)  /* RTC_50Hz Alternate Function mapping                       */
N#define GPIO_AF0_MCO           ((uint8_t)0x00U)  /* MCO (MCO1 and MCO2) Alternate Function mapping            */
N#define GPIO_AF0_SWJ           ((uint8_t)0x00U)  /* SWJ (SWD and JTAG) Alternate Function mapping             */
N#define GPIO_AF0_TRACE         ((uint8_t)0x00U)  /* TRACE Alternate Function mapping                          */
N
N/** 
N  * @brief   AF 1 selection  
N  */ 
N#define GPIO_AF1_TIM1          ((uint8_t)0x01U)  /* TIM1 Alternate Function mapping */
N#define GPIO_AF1_TIM2          ((uint8_t)0x01U)  /* TIM2 Alternate Function mapping */
N#if defined (STM32F765xx) || defined(STM32F767xx) || defined(STM32F769xx) || defined(STM32F777xx) || defined(STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N#define GPIO_AF1_UART5         ((uint8_t)0x01U)  /* UART5 Alternate Function mapping */
N#define GPIO_AF1_I2C4          ((uint8_t)0x01U)  /* I2C4 Alternate Function mapping  */   
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N
N/** 
N  * @brief   AF 2 selection  
N  */ 
N#define GPIO_AF2_TIM3          ((uint8_t)0x02U)  /* TIM3 Alternate Function mapping */
N#define GPIO_AF2_TIM4          ((uint8_t)0x02U)  /* TIM4 Alternate Function mapping */
N#define GPIO_AF2_TIM5          ((uint8_t)0x02U)  /* TIM5 Alternate Function mapping */
N
N/** 
N  * @brief   AF 3 selection  
N  */ 
N#define GPIO_AF3_TIM8          ((uint8_t)0x03U)  /* TIM8 Alternate Function mapping  */
N#define GPIO_AF3_TIM9          ((uint8_t)0x03U)  /* TIM9 Alternate Function mapping  */
N#define GPIO_AF3_TIM10         ((uint8_t)0x03U)  /* TIM10 Alternate Function mapping */
N#define GPIO_AF3_TIM11         ((uint8_t)0x03U)  /* TIM11 Alternate Function mapping */
N#define GPIO_AF3_LPTIM1        ((uint8_t)0x03U)  /* LPTIM1 Alternate Function mapping */
N#define GPIO_AF3_CEC           ((uint8_t)0x03U)  /* CEC Alternate Function mapping */
N#if defined (STM32F765xx) || defined(STM32F767xx) || defined(STM32F769xx) || defined(STM32F777xx) || defined(STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N#define GPIO_AF3_DFSDM1         ((uint8_t)0x03U)  /* DFSDM1 Alternate Function mapping */
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N/** 
N  * @brief   AF 4 selection  
N  */ 
N#define GPIO_AF4_I2C1          ((uint8_t)0x04U)  /* I2C1 Alternate Function mapping */
N#define GPIO_AF4_I2C2          ((uint8_t)0x04U)  /* I2C2 Alternate Function mapping */
N#define GPIO_AF4_I2C3          ((uint8_t)0x04U)  /* I2C3 Alternate Function mapping */
N#define GPIO_AF4_I2C4          ((uint8_t)0x04U)  /* I2C4 Alternate Function mapping */
N#define GPIO_AF4_CEC           ((uint8_t)0x04U)  /* CEC Alternate Function mapping */
N#if defined (STM32F765xx) || defined(STM32F767xx) || defined(STM32F769xx) || defined(STM32F777xx) || defined(STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N#define GPIO_AF4_USART1        ((uint8_t)0x04)  /* USART1 Alternate Function mapping */
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */   
N
N/** 
N  * @brief   AF 5 selection  
N  */ 
N#define GPIO_AF5_SPI1          ((uint8_t)0x05U)  /* SPI1 Alternate Function mapping        */
N#define GPIO_AF5_SPI2          ((uint8_t)0x05U)  /* SPI2/I2S2 Alternate Function mapping   */
N#define GPIO_AF5_SPI3          ((uint8_t)0x05U)  /* SPI3/I2S3 Alternate Function mapping   */
N#define GPIO_AF5_SPI4          ((uint8_t)0x05U)  /* SPI4 Alternate Function mapping        */
N#define GPIO_AF5_SPI5          ((uint8_t)0x05U)  /* SPI5 Alternate Function mapping        */
N#define GPIO_AF5_SPI6          ((uint8_t)0x05U)  /* SPI6 Alternate Function mapping        */
N
N/** 
N  * @brief   AF 6 selection  
N  */ 
N#define GPIO_AF6_SPI3          ((uint8_t)0x06U)  /* SPI3/I2S3 Alternate Function mapping  */
N#define GPIO_AF6_SAI1          ((uint8_t)0x06U)  /* SAI1 Alternate Function mapping       */
N#if defined (STM32F765xx) || defined(STM32F767xx) || defined(STM32F769xx) || defined(STM32F777xx) || defined(STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N#define GPIO_AF6_UART4         ((uint8_t)0x06U)   /* UART4 Alternate Function mapping     */   
N#define GPIO_AF6_DFSDM1        ((uint8_t)0x06U)  /* DFSDM1 Alternate Function mapping     */
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */   
N
N/** 
N  * @brief   AF 7 selection  
N  */ 
N#define GPIO_AF7_USART1        ((uint8_t)0x07U)  /* USART1 Alternate Function mapping     */
N#define GPIO_AF7_USART2        ((uint8_t)0x07U)  /* USART2 Alternate Function mapping     */
N#define GPIO_AF7_USART3        ((uint8_t)0x07U)  /* USART3 Alternate Function mapping     */
N#define GPIO_AF7_UART5         ((uint8_t)0x07U)  /* UART5 Alternate Function mapping      */
N#define GPIO_AF7_SPDIFRX       ((uint8_t)0x07U)  /* SPDIF-RX Alternate Function mapping   */
N#define GPIO_AF7_SPI2          ((uint8_t)0x07U)  /* SPI2 Alternate Function mapping       */
N#define GPIO_AF7_SPI3          ((uint8_t)0x07U)  /* SPI3 Alternate Function mapping       */
N#if defined (STM32F765xx) || defined(STM32F767xx) || defined(STM32F769xx) || defined(STM32F777xx) || defined(STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N#define GPIO_AF7_SPI6          ((uint8_t)0x07U)  /* SPI6 Alternate Function mapping       */
N#define GPIO_AF7_DFSDM1         ((uint8_t)0x07U) /* DFSDM1 Alternate Function mapping      */
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */  
N
N/** 
N  * @brief   AF 8 selection  
N  */ 
N#define GPIO_AF8_UART4         ((uint8_t)0x08U)  /* UART4 Alternate Function mapping  */
N#define GPIO_AF8_UART5         ((uint8_t)0x08U)  /* UART5 Alternate Function mapping  */
N#define GPIO_AF8_USART6        ((uint8_t)0x08U)  /* USART6 Alternate Function mapping */
N#define GPIO_AF8_UART7         ((uint8_t)0x08U)  /* UART7 Alternate Function mapping  */
N#define GPIO_AF8_UART8         ((uint8_t)0x08U)  /* UART8 Alternate Function mapping  */
N#define GPIO_AF8_SPDIFRX       ((uint8_t)0x08U)  /* SPIDIF-RX Alternate Function mapping */
N#define GPIO_AF8_SAI2          ((uint8_t)0x08U)  /* SAI2 Alternate Function mapping   */
N#if defined (STM32F765xx) || defined(STM32F767xx) || defined(STM32F769xx) || defined(STM32F777xx) || defined(STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N#define GPIO_AF8_SPI6          ((uint8_t)0x08U)  /* SPI6 Alternate Function mapping   */  
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */    
N
N
N/** 
N  * @brief   AF 9 selection 
N  */ 
N#define GPIO_AF9_CAN1          ((uint8_t)0x09U)  /* CAN1 Alternate Function mapping    */
N#define GPIO_AF9_CAN2          ((uint8_t)0x09U)  /* CAN2 Alternate Function mapping    */
N#define GPIO_AF9_TIM12         ((uint8_t)0x09U)  /* TIM12 Alternate Function mapping   */
N#define GPIO_AF9_TIM13         ((uint8_t)0x09U)  /* TIM13 Alternate Function mapping   */
N#define GPIO_AF9_TIM14         ((uint8_t)0x09U)  /* TIM14 Alternate Function mapping   */
N#define GPIO_AF9_QUADSPI       ((uint8_t)0x09U)  /* QUADSPI Alternate Function mapping */
N#if defined(STM32F746xx) || defined(STM32F756xx) || defined(STM32F767xx) || defined(STM32F769xx) || defined(STM32F777xx) || defined(STM32F779xx)
X#if 0L || 0L || 1L || 0L || 0L || 0L
N#define GPIO_AF9_LTDC          ((uint8_t)0x09U)  /* LCD-TFT Alternate Function mapping */
N#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N#if defined(STM32F746xx) || defined(STM32F756xx) || defined(STM32F765xx) || defined(STM32F765xx) || defined(STM32F767xx) || defined(STM32F769xx) || defined(STM32F777xx) || defined(STM32F779xx)
X#if 0L || 0L || 0L || 0L || 1L || 0L || 0L || 0L
N#define GPIO_AF9_FMC           ((uint8_t)0x09U)   /* FMC Alternate Function mapping     */
N#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N/** 
N  * @brief   AF 10 selection  
N  */ 
N#define GPIO_AF10_OTG_FS        ((uint8_t)0xAU)  /* OTG_FS Alternate Function mapping */
N#define GPIO_AF10_OTG_HS        ((uint8_t)0xAU)  /* OTG_HS Alternate Function mapping */
N#define GPIO_AF10_QUADSPI       ((uint8_t)0xAU)  /* QUADSPI Alternate Function mapping */
N#define GPIO_AF10_SAI2          ((uint8_t)0xAU)  /* SAI2 Alternate Function mapping */
N#if defined (STM32F765xx) || defined(STM32F767xx) || defined(STM32F769xx) || defined(STM32F777xx) || defined(STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N#define GPIO_AF10_DFSDM1         ((uint8_t)0x0AU)  /* DFSDM1 Alternate Function mapping  */
N#define GPIO_AF10_SDMMC2        ((uint8_t)0x0AU)  /* SDMMC2 Alternate Function mapping */   
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */   
N
N/** 
N  * @brief   AF 11 selection  
N  */ 
N#define GPIO_AF11_ETH           ((uint8_t)0x0BU)  /* ETHERNET Alternate Function mapping */
N#if defined(STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N#define GPIO_AF11_CAN3          ((uint8_t)0x0BU)  /* CAN3 Alternate Function mapping     */
N#define GPIO_AF11_SDMMC2        ((uint8_t)0x0BU)  /* SDMMC2 Alternate Function mapping   */
N#define GPIO_AF11_I2C4          ((uint8_t)0x0BU)  /* I2C4 Alternate Function mapping     */   
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N   
N/** 
N  * @brief   AF 12 selection  
N  */ 
N#define GPIO_AF12_FMC           ((uint8_t)0xCU)  /* FMC Alternate Function mapping                      */
N#define GPIO_AF12_OTG_HS_FS     ((uint8_t)0xCU)  /* OTG HS configured in FS, Alternate Function mapping */
N#define GPIO_AF12_SDMMC1        ((uint8_t)0xCU)  /* SDMMC1 Alternate Function mapping                   */
N#if defined(STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)   
X#if 0L || 1L || 0L || 0L || 0L   
N#define GPIO_AF12_MDIOS        ((uint8_t)0xCU)  /* SDMMC1 Alternate Function mapping                    */
N#define GPIO_AF12_UART7        ((uint8_t)0xCU)  /* UART7 Alternate Function mapping                     */   
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N   
N/** 
N  * @brief   AF 13 selection  
N  */ 
N#define GPIO_AF13_DCMI          ((uint8_t)0x0DU)  /* DCMI Alternate Function mapping */
N#if defined (STM32F769xx) || defined (STM32F779xx)   
X#if 0L || 0L   
S#define GPIO_AF13_DSI           ((uint8_t)0x0DU)  /* DSI Alternate Function mapping  */
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */   
N#if defined(STM32F746xx) || defined(STM32F756xx) || defined(STM32F767xx) || defined(STM32F769xx) || defined(STM32F777xx) || defined(STM32F779xx)
X#if 0L || 0L || 1L || 0L || 0L || 0L
N#define GPIO_AF13_LTDC          ((uint8_t)0x0DU)  /* LTDC Alternate Function mapping */   
N   
N/** 
N  * @brief   AF 14 selection  
N  */
N#define GPIO_AF14_LTDC          ((uint8_t)0x0EU)  /* LCD-TFT Alternate Function mapping */
N#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N/** 
N  * @brief   AF 15 selection  
N  */ 
N#define GPIO_AF15_EVENTOUT      ((uint8_t)0x0FU)  /* EVENTOUT Alternate Function mapping */
N
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup GPIOEx_Exported_Macros GPIO Exported Macros
N  * @{
N  */
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/ 
N/** @defgroup GPIOEx_Exported_Functions GPIO Exported Functions
N  * @{
N  */
N/**
N  * @}
N  */
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup GPIOEx_Private_Constants GPIO Private Constants
N  * @{
N  */
N
N/**
N  * @brief   GPIO pin available on the platform
N  */
N/* Defines the available pins per GPIOs */
N#define GPIOA_PIN_AVAILABLE  GPIO_PIN_All
N#define GPIOB_PIN_AVAILABLE  GPIO_PIN_All
N#define GPIOC_PIN_AVAILABLE  GPIO_PIN_All
N#define GPIOD_PIN_AVAILABLE  GPIO_PIN_All
N#define GPIOE_PIN_AVAILABLE  GPIO_PIN_All
N#define GPIOF_PIN_AVAILABLE  GPIO_PIN_All
N#define GPIOG_PIN_AVAILABLE  GPIO_PIN_All
N#define GPIOI_PIN_AVAILABLE  GPIO_PIN_All
N#define GPIOJ_PIN_AVAILABLE  GPIO_PIN_All
N#define GPIOH_PIN_AVAILABLE  GPIO_PIN_All
N#define GPIOK_PIN_AVAILABLE  (GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_3 | GPIO_PIN_4 | \
N                              GPIO_PIN_5 | GPIO_PIN_6 | GPIO_PIN_7)
X#define GPIOK_PIN_AVAILABLE  (GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_3 | GPIO_PIN_4 |                               GPIO_PIN_5 | GPIO_PIN_6 | GPIO_PIN_7)
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup GPIOEx_Private_Macros GPIO Private Macros
N  * @{
N  */
N/** @defgroup GPIOEx_Get_Port_Index GPIO Get Port Index
N  * @{
N  */
N#define GPIO_GET_INDEX(__GPIOx__)   (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :\
N                                              ((__GPIOx__) == (GPIOB))? 1U :\
N                                              ((__GPIOx__) == (GPIOC))? 2U :\
N                                              ((__GPIOx__) == (GPIOD))? 3U :\
N                                              ((__GPIOx__) == (GPIOE))? 4U :\
N                                              ((__GPIOx__) == (GPIOF))? 5U :\
N                                              ((__GPIOx__) == (GPIOG))? 6U :\
N                                              ((__GPIOx__) == (GPIOH))? 7U :\
N                                              ((__GPIOx__) == (GPIOI))? 8U :\
N                                              ((__GPIOx__) == (GPIOJ))? 9U : 10U)			
X#define GPIO_GET_INDEX(__GPIOx__)   (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :                                              ((__GPIOx__) == (GPIOB))? 1U :                                              ((__GPIOx__) == (GPIOC))? 2U :                                              ((__GPIOx__) == (GPIOD))? 3U :                                              ((__GPIOx__) == (GPIOE))? 4U :                                              ((__GPIOx__) == (GPIOF))? 5U :                                              ((__GPIOx__) == (GPIOG))? 6U :                                              ((__GPIOx__) == (GPIOH))? 7U :                                              ((__GPIOx__) == (GPIOI))? 8U :                                              ((__GPIOx__) == (GPIOJ))? 9U : 10U)			
N/**
N  * @}
N  */
N
N#define IS_GPIO_PIN_AVAILABLE(__INSTANCE__,__PIN__)  \
N           ((((__INSTANCE__) == GPIOA) && (((__PIN__) & (GPIOA_PIN_AVAILABLE)) != 0) && (((__PIN__) | (GPIOA_PIN_AVAILABLE)) == (GPIOA_PIN_AVAILABLE))) || \
N            (((__INSTANCE__) == GPIOB) && (((__PIN__) & (GPIOB_PIN_AVAILABLE)) != 0) && (((__PIN__) | (GPIOB_PIN_AVAILABLE)) == (GPIOB_PIN_AVAILABLE))) || \
N            (((__INSTANCE__) == GPIOC) && (((__PIN__) & (GPIOC_PIN_AVAILABLE)) != 0) && (((__PIN__) | (GPIOC_PIN_AVAILABLE)) == (GPIOC_PIN_AVAILABLE))) || \
N            (((__INSTANCE__) == GPIOD) && (((__PIN__) & (GPIOD_PIN_AVAILABLE)) != 0) && (((__PIN__) | (GPIOD_PIN_AVAILABLE)) == (GPIOD_PIN_AVAILABLE))) || \
N            (((__INSTANCE__) == GPIOE) && (((__PIN__) & (GPIOE_PIN_AVAILABLE)) != 0) && (((__PIN__) | (GPIOE_PIN_AVAILABLE)) == (GPIOE_PIN_AVAILABLE))) || \
N            (((__INSTANCE__) == GPIOF) && (((__PIN__) & (GPIOF_PIN_AVAILABLE)) != 0) && (((__PIN__) | (GPIOF_PIN_AVAILABLE)) == (GPIOF_PIN_AVAILABLE))) || \
N			(((__INSTANCE__) == GPIOG) && (((__PIN__) & (GPIOG_PIN_AVAILABLE)) != 0) && (((__PIN__) | (GPIOG_PIN_AVAILABLE)) == (GPIOG_PIN_AVAILABLE))) || \
N			(((__INSTANCE__) == GPIOI) && (((__PIN__) & (GPIOI_PIN_AVAILABLE)) != 0) && (((__PIN__) | (GPIOI_PIN_AVAILABLE)) == (GPIOI_PIN_AVAILABLE))) || \
N			(((__INSTANCE__) == GPIOJ) && (((__PIN__) & (GPIOJ_PIN_AVAILABLE)) != 0) && (((__PIN__) | (GPIOJ_PIN_AVAILABLE)) == (GPIOJ_PIN_AVAILABLE))) || \
N			(((__INSTANCE__) == GPIOK) && (((__PIN__) & (GPIOK_PIN_AVAILABLE)) != 0) && (((__PIN__) | (GPIOK_PIN_AVAILABLE)) == (GPIOK_PIN_AVAILABLE))) || \
N			(((__INSTANCE__) == GPIOH) && (((__PIN__) & (GPIOH_PIN_AVAILABLE)) != 0) && (((__PIN__) | (GPIOH_PIN_AVAILABLE)) == (GPIOH_PIN_AVAILABLE))))
X#define IS_GPIO_PIN_AVAILABLE(__INSTANCE__,__PIN__)             ((((__INSTANCE__) == GPIOA) && (((__PIN__) & (GPIOA_PIN_AVAILABLE)) != 0) && (((__PIN__) | (GPIOA_PIN_AVAILABLE)) == (GPIOA_PIN_AVAILABLE))) ||             (((__INSTANCE__) == GPIOB) && (((__PIN__) & (GPIOB_PIN_AVAILABLE)) != 0) && (((__PIN__) | (GPIOB_PIN_AVAILABLE)) == (GPIOB_PIN_AVAILABLE))) ||             (((__INSTANCE__) == GPIOC) && (((__PIN__) & (GPIOC_PIN_AVAILABLE)) != 0) && (((__PIN__) | (GPIOC_PIN_AVAILABLE)) == (GPIOC_PIN_AVAILABLE))) ||             (((__INSTANCE__) == GPIOD) && (((__PIN__) & (GPIOD_PIN_AVAILABLE)) != 0) && (((__PIN__) | (GPIOD_PIN_AVAILABLE)) == (GPIOD_PIN_AVAILABLE))) ||             (((__INSTANCE__) == GPIOE) && (((__PIN__) & (GPIOE_PIN_AVAILABLE)) != 0) && (((__PIN__) | (GPIOE_PIN_AVAILABLE)) == (GPIOE_PIN_AVAILABLE))) ||             (((__INSTANCE__) == GPIOF) && (((__PIN__) & (GPIOF_PIN_AVAILABLE)) != 0) && (((__PIN__) | (GPIOF_PIN_AVAILABLE)) == (GPIOF_PIN_AVAILABLE))) || 			(((__INSTANCE__) == GPIOG) && (((__PIN__) & (GPIOG_PIN_AVAILABLE)) != 0) && (((__PIN__) | (GPIOG_PIN_AVAILABLE)) == (GPIOG_PIN_AVAILABLE))) || 			(((__INSTANCE__) == GPIOI) && (((__PIN__) & (GPIOI_PIN_AVAILABLE)) != 0) && (((__PIN__) | (GPIOI_PIN_AVAILABLE)) == (GPIOI_PIN_AVAILABLE))) || 			(((__INSTANCE__) == GPIOJ) && (((__PIN__) & (GPIOJ_PIN_AVAILABLE)) != 0) && (((__PIN__) | (GPIOJ_PIN_AVAILABLE)) == (GPIOJ_PIN_AVAILABLE))) || 			(((__INSTANCE__) == GPIOK) && (((__PIN__) & (GPIOK_PIN_AVAILABLE)) != 0) && (((__PIN__) | (GPIOK_PIN_AVAILABLE)) == (GPIOK_PIN_AVAILABLE))) || 			(((__INSTANCE__) == GPIOH) && (((__PIN__) & (GPIOH_PIN_AVAILABLE)) != 0) && (((__PIN__) | (GPIOH_PIN_AVAILABLE)) == (GPIOH_PIN_AVAILABLE))))
N/** @defgroup GPIOEx_IS_Alternat_function_selection GPIO Check Alternate Function
N  * @{
N  */
N#if defined(STM32F756xx) || defined(STM32F746xx)
X#if 0L || 0L
S#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF1_TIM1)        || \
S                          ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      || \
S                          ((AF) == GPIO_AF0_MCO)       || ((AF) == GPIO_AF1_TIM2)       || \
S                          ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       || \
S                          ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       || \
S                          ((AF) == GPIO_AF3_TIM9)       || ((AF) == GPIO_AF3_TIM10)      || \
S                          ((AF) == GPIO_AF3_TIM11)      || ((AF) == GPIO_AF3_LPTIM1)     || \
S                          ((AF) == GPIO_AF3_CEC)        || ((AF) == GPIO_AF4_CEC)        || \
S                          ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       || \
S                          ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF4_I2C4)       || \
S                          ((AF) == GPIO_AF5_SPI1)       || ((AF) == GPIO_AF5_SPI2)       || \
S                          ((AF) == GPIO_AF5_SPI3)       || ((AF) == GPIO_AF5_SPI4)       || \
S                          ((AF) == GPIO_AF5_SPI5)       || ((AF) == GPIO_AF5_SPI6)       || \
S                          ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF6_SAI1)       || \
S                          ((AF) == GPIO_AF7_SPI3)       || ((AF) == GPIO_AF7_SPI2)        || \
S                          ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)      || \
S                          ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF7_UART5)       || \
S                          ((AF) == GPIO_AF7_SPDIFRX)    || ((AF) == GPIO_AF8_SPDIFRX)     || \
S                          ((AF) == GPIO_AF8_SAI2)       || ((AF) == GPIO_AF8_USART6)      || \
S                          ((AF) == GPIO_AF8_UART4)      || ((AF) == GPIO_AF8_UART5)       || \
S                          ((AF) == GPIO_AF8_UART7)      || ((AF) == GPIO_AF8_UART8)       || \
S                          ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)        || \
S                          ((AF) == GPIO_AF9_TIM12)      || ((AF) == GPIO_AF9_TIM12)      || \
S                          ((AF) == GPIO_AF9_TIM14)      || ((AF) == GPIO_AF9_QUADSPI)    || \
S                          ((AF) == GPIO_AF9_LTDC)       || ((AF) == GPIO_AF10_OTG_FS)    || \
S                          ((AF) == GPIO_AF10_OTG_HS)    || ((AF) == GPIO_AF10_SAI2)      || \
S                          ((AF) == GPIO_AF10_QUADSPI)   || ((AF) == GPIO_AF11_ETH)       || \
S                          ((AF) == GPIO_AF12_OTG_HS_FS) || ((AF) == GPIO_AF12_SDMMC1)     || \
S                          ((AF) == GPIO_AF12_FMC)       || ((AF) == GPIO_AF15_EVENTOUT)  || \
S                          ((AF) == GPIO_AF13_DCMI)      || ((AF) == GPIO_AF14_LTDC))
X#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF1_TIM1)        ||                           ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      ||                           ((AF) == GPIO_AF0_MCO)       || ((AF) == GPIO_AF1_TIM2)       ||                           ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       ||                           ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       ||                           ((AF) == GPIO_AF3_TIM9)       || ((AF) == GPIO_AF3_TIM10)      ||                           ((AF) == GPIO_AF3_TIM11)      || ((AF) == GPIO_AF3_LPTIM1)     ||                           ((AF) == GPIO_AF3_CEC)        || ((AF) == GPIO_AF4_CEC)        ||                           ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       ||                           ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF4_I2C4)       ||                           ((AF) == GPIO_AF5_SPI1)       || ((AF) == GPIO_AF5_SPI2)       ||                           ((AF) == GPIO_AF5_SPI3)       || ((AF) == GPIO_AF5_SPI4)       ||                           ((AF) == GPIO_AF5_SPI5)       || ((AF) == GPIO_AF5_SPI6)       ||                           ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF6_SAI1)       ||                           ((AF) == GPIO_AF7_SPI3)       || ((AF) == GPIO_AF7_SPI2)        ||                           ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)      ||                           ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF7_UART5)       ||                           ((AF) == GPIO_AF7_SPDIFRX)    || ((AF) == GPIO_AF8_SPDIFRX)     ||                           ((AF) == GPIO_AF8_SAI2)       || ((AF) == GPIO_AF8_USART6)      ||                           ((AF) == GPIO_AF8_UART4)      || ((AF) == GPIO_AF8_UART5)       ||                           ((AF) == GPIO_AF8_UART7)      || ((AF) == GPIO_AF8_UART8)       ||                           ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)        ||                           ((AF) == GPIO_AF9_TIM12)      || ((AF) == GPIO_AF9_TIM12)      ||                           ((AF) == GPIO_AF9_TIM14)      || ((AF) == GPIO_AF9_QUADSPI)    ||                           ((AF) == GPIO_AF9_LTDC)       || ((AF) == GPIO_AF10_OTG_FS)    ||                           ((AF) == GPIO_AF10_OTG_HS)    || ((AF) == GPIO_AF10_SAI2)      ||                           ((AF) == GPIO_AF10_QUADSPI)   || ((AF) == GPIO_AF11_ETH)       ||                           ((AF) == GPIO_AF12_OTG_HS_FS) || ((AF) == GPIO_AF12_SDMMC1)     ||                           ((AF) == GPIO_AF12_FMC)       || ((AF) == GPIO_AF15_EVENTOUT)  ||                           ((AF) == GPIO_AF13_DCMI)      || ((AF) == GPIO_AF14_LTDC))
S#elif defined(STM32F745xx)
X#elif 0L
S#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF1_TIM1)        || \
S                          ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      || \
S                          ((AF) == GPIO_AF0_MCO)       || ((AF) == GPIO_AF1_TIM2)       || \
S                          ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       || \
S                          ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       || \
S                          ((AF) == GPIO_AF3_TIM9)       || ((AF) == GPIO_AF3_TIM10)      || \
S                          ((AF) == GPIO_AF3_TIM11)      || ((AF) == GPIO_AF3_LPTIM1)     || \
S                          ((AF) == GPIO_AF3_CEC)        || ((AF) == GPIO_AF4_CEC)        || \
S                          ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       || \
S                          ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF4_I2C4)       || \
S                          ((AF) == GPIO_AF5_SPI1)       || ((AF) == GPIO_AF5_SPI2)       || \
S                          ((AF) == GPIO_AF5_SPI3)       || ((AF) == GPIO_AF5_SPI4)       || \
S                          ((AF) == GPIO_AF5_SPI5)       || ((AF) == GPIO_AF5_SPI6)       || \
S                          ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF6_SAI1)       || \
S                          ((AF) == GPIO_AF7_SPI3)       || ((AF) == GPIO_AF7_SPI2)        || \
S                          ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)      || \
S                          ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF7_UART5)       || \
S                          ((AF) == GPIO_AF7_SPDIFRX)    || ((AF) == GPIO_AF8_SPDIFRX)     || \
S                          ((AF) == GPIO_AF8_SAI2)       || ((AF) == GPIO_AF8_USART6)      || \
S                          ((AF) == GPIO_AF8_UART4)      || ((AF) == GPIO_AF8_UART5)       || \
S                          ((AF) == GPIO_AF8_UART7)      || ((AF) == GPIO_AF8_UART8)       || \
S                          ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)        || \
S                          ((AF) == GPIO_AF9_TIM12)      || ((AF) == GPIO_AF9_TIM12)      || \
S                          ((AF) == GPIO_AF9_TIM14)      || ((AF) == GPIO_AF9_QUADSPI)    || \
S                          ((AF) == GPIO_AF13_DCMI)      || ((AF) == GPIO_AF10_OTG_FS)    || \
S                          ((AF) == GPIO_AF10_OTG_HS)    || ((AF) == GPIO_AF10_SAI2)      || \
S                          ((AF) == GPIO_AF10_QUADSPI)   || ((AF) == GPIO_AF11_ETH)       || \
S                          ((AF) == GPIO_AF12_OTG_HS_FS) || ((AF) == GPIO_AF12_SDMMC1)     || \
S                          ((AF) == GPIO_AF12_FMC)       || ((AF) == GPIO_AF15_EVENTOUT))
X#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF1_TIM1)        ||                           ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      ||                           ((AF) == GPIO_AF0_MCO)       || ((AF) == GPIO_AF1_TIM2)       ||                           ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       ||                           ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       ||                           ((AF) == GPIO_AF3_TIM9)       || ((AF) == GPIO_AF3_TIM10)      ||                           ((AF) == GPIO_AF3_TIM11)      || ((AF) == GPIO_AF3_LPTIM1)     ||                           ((AF) == GPIO_AF3_CEC)        || ((AF) == GPIO_AF4_CEC)        ||                           ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       ||                           ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF4_I2C4)       ||                           ((AF) == GPIO_AF5_SPI1)       || ((AF) == GPIO_AF5_SPI2)       ||                           ((AF) == GPIO_AF5_SPI3)       || ((AF) == GPIO_AF5_SPI4)       ||                           ((AF) == GPIO_AF5_SPI5)       || ((AF) == GPIO_AF5_SPI6)       ||                           ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF6_SAI1)       ||                           ((AF) == GPIO_AF7_SPI3)       || ((AF) == GPIO_AF7_SPI2)        ||                           ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)      ||                           ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF7_UART5)       ||                           ((AF) == GPIO_AF7_SPDIFRX)    || ((AF) == GPIO_AF8_SPDIFRX)     ||                           ((AF) == GPIO_AF8_SAI2)       || ((AF) == GPIO_AF8_USART6)      ||                           ((AF) == GPIO_AF8_UART4)      || ((AF) == GPIO_AF8_UART5)       ||                           ((AF) == GPIO_AF8_UART7)      || ((AF) == GPIO_AF8_UART8)       ||                           ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)        ||                           ((AF) == GPIO_AF9_TIM12)      || ((AF) == GPIO_AF9_TIM12)      ||                           ((AF) == GPIO_AF9_TIM14)      || ((AF) == GPIO_AF9_QUADSPI)    ||                           ((AF) == GPIO_AF13_DCMI)      || ((AF) == GPIO_AF10_OTG_FS)    ||                           ((AF) == GPIO_AF10_OTG_HS)    || ((AF) == GPIO_AF10_SAI2)      ||                           ((AF) == GPIO_AF10_QUADSPI)   || ((AF) == GPIO_AF11_ETH)       ||                           ((AF) == GPIO_AF12_OTG_HS_FS) || ((AF) == GPIO_AF12_SDMMC1)     ||                           ((AF) == GPIO_AF12_FMC)       || ((AF) == GPIO_AF15_EVENTOUT))
N#elif defined(STM32F767xx) || defined(STM32F777xx)
X#elif 1L || 0L
N#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF1_TIM1)        || \
N                          ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      || \
N                          ((AF) == GPIO_AF0_MCO)       || ((AF) == GPIO_AF1_TIM2)       || \
N                          ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       || \
N                          ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       || \
N                          ((AF) == GPIO_AF3_TIM9)       || ((AF) == GPIO_AF3_TIM10)      || \
N                          ((AF) == GPIO_AF3_TIM11)      || ((AF) == GPIO_AF3_LPTIM1)     || \
N                          ((AF) == GPIO_AF3_CEC)        || ((AF) == GPIO_AF4_CEC)        || \
N                          ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       || \
N                          ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF4_I2C4)       || \
N                          ((AF) == GPIO_AF5_SPI1)       || ((AF) == GPIO_AF5_SPI2)       || \
N                          ((AF) == GPIO_AF5_SPI3)       || ((AF) == GPIO_AF5_SPI4)       || \
N                          ((AF) == GPIO_AF5_SPI5)       || ((AF) == GPIO_AF5_SPI6)       || \
N                          ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF6_SAI1)       || \
N                          ((AF) == GPIO_AF7_SPI3)       || ((AF) == GPIO_AF7_SPI2)       || \
N                          ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     || \
N                          ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF7_UART5)      || \
N                          ((AF) == GPIO_AF7_SPDIFRX)    || ((AF) == GPIO_AF8_SPDIFRX)    || \
N                          ((AF) == GPIO_AF8_SAI2)       || ((AF) == GPIO_AF8_USART6)     || \
N                          ((AF) == GPIO_AF8_UART4)      || ((AF) == GPIO_AF8_UART5)      || \
N                          ((AF) == GPIO_AF8_UART7)      || ((AF) == GPIO_AF8_UART8)      || \
N                          ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)       || \
N                          ((AF) == GPIO_AF9_TIM12)      || ((AF) == GPIO_AF9_TIM12)      || \
N                          ((AF) == GPIO_AF9_TIM14)      || ((AF) == GPIO_AF9_QUADSPI)    || \
N                          ((AF) == GPIO_AF10_OTG_FS)    || ((AF) == GPIO_AF9_LTDC)       || \
N                          ((AF) == GPIO_AF10_OTG_HS)    || ((AF) == GPIO_AF10_SAI2)      || \
N                          ((AF) == GPIO_AF10_QUADSPI)   || ((AF) == GPIO_AF11_ETH)       || \
N                          ((AF) == GPIO_AF11_CAN3)      || ((AF) == GPIO_AF12_OTG_HS_FS) || \
N                          ((AF) == GPIO_AF12_SDMMC1)    || ((AF) == GPIO_AF12_FMC)       || \
N                          ((AF) == GPIO_AF15_EVENTOUT)  || ((AF) == GPIO_AF13_DCMI)      || \
N						  ((AF) == GPIO_AF14_LTDC))
X#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF1_TIM1)        ||                           ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      ||                           ((AF) == GPIO_AF0_MCO)       || ((AF) == GPIO_AF1_TIM2)       ||                           ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       ||                           ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       ||                           ((AF) == GPIO_AF3_TIM9)       || ((AF) == GPIO_AF3_TIM10)      ||                           ((AF) == GPIO_AF3_TIM11)      || ((AF) == GPIO_AF3_LPTIM1)     ||                           ((AF) == GPIO_AF3_CEC)        || ((AF) == GPIO_AF4_CEC)        ||                           ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       ||                           ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF4_I2C4)       ||                           ((AF) == GPIO_AF5_SPI1)       || ((AF) == GPIO_AF5_SPI2)       ||                           ((AF) == GPIO_AF5_SPI3)       || ((AF) == GPIO_AF5_SPI4)       ||                           ((AF) == GPIO_AF5_SPI5)       || ((AF) == GPIO_AF5_SPI6)       ||                           ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF6_SAI1)       ||                           ((AF) == GPIO_AF7_SPI3)       || ((AF) == GPIO_AF7_SPI2)       ||                           ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     ||                           ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF7_UART5)      ||                           ((AF) == GPIO_AF7_SPDIFRX)    || ((AF) == GPIO_AF8_SPDIFRX)    ||                           ((AF) == GPIO_AF8_SAI2)       || ((AF) == GPIO_AF8_USART6)     ||                           ((AF) == GPIO_AF8_UART4)      || ((AF) == GPIO_AF8_UART5)      ||                           ((AF) == GPIO_AF8_UART7)      || ((AF) == GPIO_AF8_UART8)      ||                           ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)       ||                           ((AF) == GPIO_AF9_TIM12)      || ((AF) == GPIO_AF9_TIM12)      ||                           ((AF) == GPIO_AF9_TIM14)      || ((AF) == GPIO_AF9_QUADSPI)    ||                           ((AF) == GPIO_AF10_OTG_FS)    || ((AF) == GPIO_AF9_LTDC)       ||                           ((AF) == GPIO_AF10_OTG_HS)    || ((AF) == GPIO_AF10_SAI2)      ||                           ((AF) == GPIO_AF10_QUADSPI)   || ((AF) == GPIO_AF11_ETH)       ||                           ((AF) == GPIO_AF11_CAN3)      || ((AF) == GPIO_AF12_OTG_HS_FS) ||                           ((AF) == GPIO_AF12_SDMMC1)    || ((AF) == GPIO_AF12_FMC)       ||                           ((AF) == GPIO_AF15_EVENTOUT)  || ((AF) == GPIO_AF13_DCMI)      || 						  ((AF) == GPIO_AF14_LTDC))
N#elif defined(STM32F769xx) || defined(STM32F779xx)
S#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF1_TIM1)        || \
S                          ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      || \
S                          ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF1_TIM2)       || \
S                          ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       || \
S                          ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       || \
S                          ((AF) == GPIO_AF3_TIM9)       || ((AF) == GPIO_AF3_TIM10)      || \
S                          ((AF) == GPIO_AF3_TIM11)      || ((AF) == GPIO_AF3_LPTIM1)     || \
S                          ((AF) == GPIO_AF3_CEC)        || ((AF) == GPIO_AF4_CEC)        || \
S                          ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       || \
S                          ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF4_I2C4)       || \
S                          ((AF) == GPIO_AF5_SPI1)       || ((AF) == GPIO_AF5_SPI2)       || \
S                          ((AF) == GPIO_AF5_SPI3)       || ((AF) == GPIO_AF5_SPI4)       || \
S                          ((AF) == GPIO_AF5_SPI5)       || ((AF) == GPIO_AF5_SPI6)       || \
S                          ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF6_SAI1)       || \
S                          ((AF) == GPIO_AF7_SPI3)       || ((AF) == GPIO_AF7_SPI2)       || \
S                          ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     || \
S                          ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF7_UART5)      || \
S                          ((AF) == GPIO_AF7_SPDIFRX)    || ((AF) == GPIO_AF8_SPDIFRX)    || \
S                          ((AF) == GPIO_AF8_SAI2)       || ((AF) == GPIO_AF8_USART6)     || \
S                          ((AF) == GPIO_AF8_UART4)      || ((AF) == GPIO_AF8_UART5)      || \
S                          ((AF) == GPIO_AF8_UART7)      || ((AF) == GPIO_AF8_UART8)      || \
S                          ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)       || \
S                          ((AF) == GPIO_AF9_TIM12)      || ((AF) == GPIO_AF9_TIM12)      || \
S                          ((AF) == GPIO_AF9_TIM14)      || ((AF) == GPIO_AF9_QUADSPI)    || \
S                          ((AF) == GPIO_AF9_LTDC)       || ((AF) == GPIO_AF10_OTG_FS)    || \
S                          ((AF) == GPIO_AF10_OTG_HS)    || ((AF) == GPIO_AF10_SAI2)      || \
S                          ((AF) == GPIO_AF10_QUADSPI)   || ((AF) == GPIO_AF11_ETH)       || \
S                          ((AF) == GPIO_AF11_CAN3)      || ((AF) == GPIO_AF12_OTG_HS_FS) || \
S                          ((AF) == GPIO_AF12_SDMMC1)    || ((AF) == GPIO_AF12_FMC)       || \
S                          ((AF) == GPIO_AF15_EVENTOUT)  || ((AF) == GPIO_AF13_DCMI)      || \
S                          ((AF) == GPIO_AF14_LTDC)      || ((AF) == GPIO_AF13_DSI))
X#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF1_TIM1)        ||                           ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      ||                           ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF1_TIM2)       ||                           ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       ||                           ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       ||                           ((AF) == GPIO_AF3_TIM9)       || ((AF) == GPIO_AF3_TIM10)      ||                           ((AF) == GPIO_AF3_TIM11)      || ((AF) == GPIO_AF3_LPTIM1)     ||                           ((AF) == GPIO_AF3_CEC)        || ((AF) == GPIO_AF4_CEC)        ||                           ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       ||                           ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF4_I2C4)       ||                           ((AF) == GPIO_AF5_SPI1)       || ((AF) == GPIO_AF5_SPI2)       ||                           ((AF) == GPIO_AF5_SPI3)       || ((AF) == GPIO_AF5_SPI4)       ||                           ((AF) == GPIO_AF5_SPI5)       || ((AF) == GPIO_AF5_SPI6)       ||                           ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF6_SAI1)       ||                           ((AF) == GPIO_AF7_SPI3)       || ((AF) == GPIO_AF7_SPI2)       ||                           ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     ||                           ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF7_UART5)      ||                           ((AF) == GPIO_AF7_SPDIFRX)    || ((AF) == GPIO_AF8_SPDIFRX)    ||                           ((AF) == GPIO_AF8_SAI2)       || ((AF) == GPIO_AF8_USART6)     ||                           ((AF) == GPIO_AF8_UART4)      || ((AF) == GPIO_AF8_UART5)      ||                           ((AF) == GPIO_AF8_UART7)      || ((AF) == GPIO_AF8_UART8)      ||                           ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)       ||                           ((AF) == GPIO_AF9_TIM12)      || ((AF) == GPIO_AF9_TIM12)      ||                           ((AF) == GPIO_AF9_TIM14)      || ((AF) == GPIO_AF9_QUADSPI)    ||                           ((AF) == GPIO_AF9_LTDC)       || ((AF) == GPIO_AF10_OTG_FS)    ||                           ((AF) == GPIO_AF10_OTG_HS)    || ((AF) == GPIO_AF10_SAI2)      ||                           ((AF) == GPIO_AF10_QUADSPI)   || ((AF) == GPIO_AF11_ETH)       ||                           ((AF) == GPIO_AF11_CAN3)      || ((AF) == GPIO_AF12_OTG_HS_FS) ||                           ((AF) == GPIO_AF12_SDMMC1)    || ((AF) == GPIO_AF12_FMC)       ||                           ((AF) == GPIO_AF15_EVENTOUT)  || ((AF) == GPIO_AF13_DCMI)      ||                           ((AF) == GPIO_AF14_LTDC)      || ((AF) == GPIO_AF13_DSI))
S#elif defined(STM32F765xx)
S#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF1_TIM1)        || \
S                          ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      || \
S                          ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF1_TIM2)       || \
S                          ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       || \
S                          ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       || \
S                          ((AF) == GPIO_AF3_TIM9)       || ((AF) == GPIO_AF3_TIM10)      || \
S                          ((AF) == GPIO_AF3_TIM11)      || ((AF) == GPIO_AF3_LPTIM1)     || \
S                          ((AF) == GPIO_AF3_CEC)        || ((AF) == GPIO_AF4_CEC)        || \
S                          ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       || \
S                          ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF4_I2C4)       || \
S                          ((AF) == GPIO_AF5_SPI1)       || ((AF) == GPIO_AF5_SPI2)       || \
S                          ((AF) == GPIO_AF5_SPI3)       || ((AF) == GPIO_AF5_SPI4)       || \
S                          ((AF) == GPIO_AF5_SPI5)       || ((AF) == GPIO_AF5_SPI6)       || \
S                          ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF6_SAI1)       || \
S                          ((AF) == GPIO_AF7_SPI3)       || ((AF) == GPIO_AF7_SPI2)       || \
S                          ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     || \
S                          ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF7_UART5)      || \
S                          ((AF) == GPIO_AF7_SPDIFRX)    || ((AF) == GPIO_AF8_SPDIFRX)    || \
S                          ((AF) == GPIO_AF8_SAI2)       || ((AF) == GPIO_AF8_USART6)     || \
S                          ((AF) == GPIO_AF8_UART4)      || ((AF) == GPIO_AF8_UART5)      || \
S                          ((AF) == GPIO_AF8_UART7)      || ((AF) == GPIO_AF8_UART8)      || \
S                          ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)       || \
S                          ((AF) == GPIO_AF9_TIM12)      || ((AF) == GPIO_AF9_TIM12)      || \
S                          ((AF) == GPIO_AF9_TIM14)      || ((AF) == GPIO_AF9_QUADSPI)    || \
S                          ((AF) == GPIO_AF10_OTG_HS)    || ((AF) == GPIO_AF10_SAI2)      || \
S                          ((AF) == GPIO_AF10_QUADSPI)   || ((AF) == GPIO_AF11_ETH)       || \
S                          ((AF) == GPIO_AF11_CAN3)      || ((AF) == GPIO_AF12_OTG_HS_FS) || \
S                          ((AF) == GPIO_AF12_SDMMC1)    || ((AF) == GPIO_AF12_FMC)       || \
S                          ((AF) == GPIO_AF15_EVENTOUT)  || ((AF) == GPIO_AF13_DCMI)      || \
S                          ((AF) == GPIO_AF10_OTG_FS))
X#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF1_TIM1)        ||                           ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      ||                           ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF1_TIM2)       ||                           ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       ||                           ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       ||                           ((AF) == GPIO_AF3_TIM9)       || ((AF) == GPIO_AF3_TIM10)      ||                           ((AF) == GPIO_AF3_TIM11)      || ((AF) == GPIO_AF3_LPTIM1)     ||                           ((AF) == GPIO_AF3_CEC)        || ((AF) == GPIO_AF4_CEC)        ||                           ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       ||                           ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF4_I2C4)       ||                           ((AF) == GPIO_AF5_SPI1)       || ((AF) == GPIO_AF5_SPI2)       ||                           ((AF) == GPIO_AF5_SPI3)       || ((AF) == GPIO_AF5_SPI4)       ||                           ((AF) == GPIO_AF5_SPI5)       || ((AF) == GPIO_AF5_SPI6)       ||                           ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF6_SAI1)       ||                           ((AF) == GPIO_AF7_SPI3)       || ((AF) == GPIO_AF7_SPI2)       ||                           ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     ||                           ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF7_UART5)      ||                           ((AF) == GPIO_AF7_SPDIFRX)    || ((AF) == GPIO_AF8_SPDIFRX)    ||                           ((AF) == GPIO_AF8_SAI2)       || ((AF) == GPIO_AF8_USART6)     ||                           ((AF) == GPIO_AF8_UART4)      || ((AF) == GPIO_AF8_UART5)      ||                           ((AF) == GPIO_AF8_UART7)      || ((AF) == GPIO_AF8_UART8)      ||                           ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)       ||                           ((AF) == GPIO_AF9_TIM12)      || ((AF) == GPIO_AF9_TIM12)      ||                           ((AF) == GPIO_AF9_TIM14)      || ((AF) == GPIO_AF9_QUADSPI)    ||                           ((AF) == GPIO_AF10_OTG_HS)    || ((AF) == GPIO_AF10_SAI2)      ||                           ((AF) == GPIO_AF10_QUADSPI)   || ((AF) == GPIO_AF11_ETH)       ||                           ((AF) == GPIO_AF11_CAN3)      || ((AF) == GPIO_AF12_OTG_HS_FS) ||                           ((AF) == GPIO_AF12_SDMMC1)    || ((AF) == GPIO_AF12_FMC)       ||                           ((AF) == GPIO_AF15_EVENTOUT)  || ((AF) == GPIO_AF13_DCMI)      ||                           ((AF) == GPIO_AF10_OTG_FS))
N#endif /* STM32F756xx || STM32F746xx */
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup GPIOEx_Private_Functions GPIO Private Functions
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_GPIO_EX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 233 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_gpio.h" 2
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup GPIO_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup GPIO_Exported_Functions_Group1
N  * @{
N  */
N/* Initialization and de-initialization functions *****************************/
Nvoid  HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init);
Nvoid  HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin);
N/**
N  * @}
N  */
N
N/** @addtogroup GPIO_Exported_Functions_Group2
N  * @{
N  */
N/* IO operation functions *****************************************************/
NGPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
Nvoid HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState);
Nvoid HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
NHAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
Nvoid HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin);
Nvoid HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin);
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup GPIO_Private_Constants GPIO Private Constants
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup GPIO_Private_Macros GPIO Private Macros
N  * @{
N  */
N#define IS_GPIO_PIN_ACTION(ACTION) (((ACTION) == GPIO_PIN_RESET) || ((ACTION) == GPIO_PIN_SET))
N#define IS_GPIO_PIN(PIN)           (((PIN) & GPIO_PIN_MASK ) != (uint32_t)0x00)
N#define IS_GPIO_MODE(MODE) (((MODE) == GPIO_MODE_INPUT)              ||\
N                            ((MODE) == GPIO_MODE_OUTPUT_PP)          ||\
N                            ((MODE) == GPIO_MODE_OUTPUT_OD)          ||\
N                            ((MODE) == GPIO_MODE_AF_PP)              ||\
N                            ((MODE) == GPIO_MODE_AF_OD)              ||\
N                            ((MODE) == GPIO_MODE_IT_RISING)          ||\
N                            ((MODE) == GPIO_MODE_IT_FALLING)         ||\
N                            ((MODE) == GPIO_MODE_IT_RISING_FALLING)  ||\
N                            ((MODE) == GPIO_MODE_EVT_RISING)         ||\
N                            ((MODE) == GPIO_MODE_EVT_FALLING)        ||\
N                            ((MODE) == GPIO_MODE_EVT_RISING_FALLING) ||\
N                            ((MODE) == GPIO_MODE_ANALOG))
X#define IS_GPIO_MODE(MODE) (((MODE) == GPIO_MODE_INPUT)              ||                            ((MODE) == GPIO_MODE_OUTPUT_PP)          ||                            ((MODE) == GPIO_MODE_OUTPUT_OD)          ||                            ((MODE) == GPIO_MODE_AF_PP)              ||                            ((MODE) == GPIO_MODE_AF_OD)              ||                            ((MODE) == GPIO_MODE_IT_RISING)          ||                            ((MODE) == GPIO_MODE_IT_FALLING)         ||                            ((MODE) == GPIO_MODE_IT_RISING_FALLING)  ||                            ((MODE) == GPIO_MODE_EVT_RISING)         ||                            ((MODE) == GPIO_MODE_EVT_FALLING)        ||                            ((MODE) == GPIO_MODE_EVT_RISING_FALLING) ||                            ((MODE) == GPIO_MODE_ANALOG))
N#define IS_GPIO_SPEED(SPEED) (((SPEED) == GPIO_SPEED_LOW)  || ((SPEED) == GPIO_SPEED_MEDIUM) || \
N                              ((SPEED) == GPIO_SPEED_FAST) || ((SPEED) == GPIO_SPEED_HIGH))
X#define IS_GPIO_SPEED(SPEED) (((SPEED) == GPIO_SPEED_LOW)  || ((SPEED) == GPIO_SPEED_MEDIUM) ||                               ((SPEED) == GPIO_SPEED_FAST) || ((SPEED) == GPIO_SPEED_HIGH))
N#define IS_GPIO_PULL(PULL) (((PULL) == GPIO_NOPULL) || ((PULL) == GPIO_PULLUP) || \
N                            ((PULL) == GPIO_PULLDOWN))
X#define IS_GPIO_PULL(PULL) (((PULL) == GPIO_NOPULL) || ((PULL) == GPIO_PULLUP) ||                             ((PULL) == GPIO_PULLDOWN))
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup GPIO_Private_Functions GPIO Private Functions
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_GPIO_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 251 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_GPIO_MODULE_ENABLED */
N
N#ifdef HAL_DMA_MODULE_ENABLED
N  #include "stm32f7xx_hal_dma.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_dma.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_dma.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of DMA HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_DMA_H
N#define __STM32F7xx_HAL_DMA_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup DMA
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N
N/** @defgroup DMA_Exported_Types DMA Exported Types
N  * @brief    DMA Exported Types 
N  * @{
N  */
N   
N/** 
N  * @brief  DMA Configuration Structure definition
N  */
Ntypedef struct
N{
N  uint32_t Channel;              /*!< Specifies the channel used for the specified stream. 
N                                      This parameter can be a value of @ref DMAEx_Channel_selection                  */
N
N  uint32_t Direction;            /*!< Specifies if the data will be transferred from memory to peripheral, 
N                                      from memory to memory or from peripheral to memory.
N                                      This parameter can be a value of @ref DMA_Data_transfer_direction              */
N
N  uint32_t PeriphInc;            /*!< Specifies whether the Peripheral address register should be incremented or not.
N                                      This parameter can be a value of @ref DMA_Peripheral_incremented_mode          */
N
N  uint32_t MemInc;               /*!< Specifies whether the memory address register should be incremented or not.
N                                      This parameter can be a value of @ref DMA_Memory_incremented_mode              */
N
N  uint32_t PeriphDataAlignment;  /*!< Specifies the Peripheral data width.
N                                      This parameter can be a value of @ref DMA_Peripheral_data_size                 */
N
N  uint32_t MemDataAlignment;     /*!< Specifies the Memory data width.
N                                      This parameter can be a value of @ref DMA_Memory_data_size                     */
N
N  uint32_t Mode;                 /*!< Specifies the operation mode of the DMAy Streamx.
N                                      This parameter can be a value of @ref DMA_mode
N                                      @note The circular buffer mode cannot be used if the memory-to-memory
N                                            data transfer is configured on the selected Stream                        */
N
N  uint32_t Priority;             /*!< Specifies the software priority for the DMAy Streamx.
N                                      This parameter can be a value of @ref DMA_Priority_level                       */
N
N  uint32_t FIFOMode;             /*!< Specifies if the FIFO mode or Direct mode will be used for the specified stream.
N                                      This parameter can be a value of @ref DMA_FIFO_direct_mode
N                                      @note The Direct mode (FIFO mode disabled) cannot be used if the 
N                                            memory-to-memory data transfer is configured on the selected stream       */
N
N  uint32_t FIFOThreshold;        /*!< Specifies the FIFO threshold level.
N                                      This parameter can be a value of @ref DMA_FIFO_threshold_level                  */
N
N  uint32_t MemBurst;             /*!< Specifies the Burst transfer configuration for the memory transfers. 
N                                      It specifies the amount of data to be transferred in a single non interruptible 
N                                      transaction.
N                                      This parameter can be a value of @ref DMA_Memory_burst 
N                                      @note The burst mode is possible only if the address Increment mode is enabled. */
N
N  uint32_t PeriphBurst;          /*!< Specifies the Burst transfer configuration for the peripheral transfers. 
N                                      It specifies the amount of data to be transferred in a single non interruptible 
N                                      transaction. 
N                                      This parameter can be a value of @ref DMA_Peripheral_burst
N                                      @note The burst mode is possible only if the address Increment mode is enabled. */
N}DMA_InitTypeDef;
N
N/** 
N  * @brief  HAL DMA State structures definition
N  */
Ntypedef enum
N{
N  HAL_DMA_STATE_RESET             = 0x00U,  /*!< DMA not yet initialized or disabled */
N  HAL_DMA_STATE_READY             = 0x01U,  /*!< DMA initialized and ready for use   */
N  HAL_DMA_STATE_BUSY              = 0x02U,  /*!< DMA process is ongoing              */
N  HAL_DMA_STATE_TIMEOUT           = 0x03U,  /*!< DMA timeout state                   */
N  HAL_DMA_STATE_ERROR             = 0x04U,  /*!< DMA error state                     */
N  HAL_DMA_STATE_ABORT             = 0x05U,  /*!< DMA Abort state                     */
N}HAL_DMA_StateTypeDef;
N
N/** 
N  * @brief  HAL DMA Error Code structure definition
N  */
Ntypedef enum
N{
N  HAL_DMA_FULL_TRANSFER      = 0x00U,    /*!< Full transfer     */
N  HAL_DMA_HALF_TRANSFER      = 0x01U,    /*!< Half Transfer     */
N}HAL_DMA_LevelCompleteTypeDef;
N
N/** 
N  * @brief  HAL DMA Error Code structure definition
N  */
Ntypedef enum
N{
N  HAL_DMA_XFER_CPLT_CB_ID          = 0x00U,    /*!< Full transfer     */
N  HAL_DMA_XFER_HALFCPLT_CB_ID      = 0x01U,    /*!< Half Transfer     */
N  HAL_DMA_XFER_M1CPLT_CB_ID        = 0x02U,    /*!< M1 Full Transfer  */
N  HAL_DMA_XFER_M1HALFCPLT_CB_ID    = 0x03U,    /*!< M1 Half Transfer  */
N  HAL_DMA_XFER_ERROR_CB_ID         = 0x04U,    /*!< Error             */
N  HAL_DMA_XFER_ABORT_CB_ID         = 0x05U,    /*!< Abort             */
N  HAL_DMA_XFER_ALL_CB_ID           = 0x06U     /*!< All               */
N}HAL_DMA_CallbackIDTypeDef;
N
N/** 
N  * @brief  DMA handle Structure definition
N  */
Ntypedef struct __DMA_HandleTypeDef
N{
N  DMA_Stream_TypeDef         *Instance;                                                    /*!< Register base address                  */
N
N  DMA_InitTypeDef            Init;                                                         /*!< DMA communication parameters           */ 
N
N  HAL_LockTypeDef            Lock;                                                         /*!< DMA locking object                     */  
N
N  __IO HAL_DMA_StateTypeDef  State;                                                        /*!< DMA transfer state                     */
X  volatile HAL_DMA_StateTypeDef  State;                                                         
N
N  void                       *Parent;                                                      /*!< Parent object state                    */ 
N
N  void                       (* XferCpltCallback)( struct __DMA_HandleTypeDef * hdma);     /*!< DMA transfer complete callback         */
N
N  void                       (* XferHalfCpltCallback)( struct __DMA_HandleTypeDef * hdma); /*!< DMA Half transfer complete callback    */
N
N  void                       (* XferM1CpltCallback)( struct __DMA_HandleTypeDef * hdma);   /*!< DMA transfer complete Memory1 callback */
N  
N  void                       (* XferM1HalfCpltCallback)( struct __DMA_HandleTypeDef * hdma);   /*!< DMA transfer Half complete Memory1 callback */
N  
N  void                       (* XferErrorCallback)( struct __DMA_HandleTypeDef * hdma);    /*!< DMA transfer error callback            */
N  
N  void                       (* XferAbortCallback)( struct __DMA_HandleTypeDef * hdma);    /*!< DMA transfer Abort callback            */  
N
N __IO uint32_t               ErrorCode;                                                    /*!< DMA Error code                          */
X volatile uint32_t               ErrorCode;                                                     
N  
N uint32_t                    StreamBaseAddress;                                            /*!< DMA Stream Base Address                */
N
N uint32_t                    StreamIndex;                                                  /*!< DMA Stream Index                       */
N 
N}DMA_HandleTypeDef;
N
N/**
N  * @}
N  */
N
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup DMA_Exported_Constants DMA Exported Constants
N  * @brief    DMA Exported constants 
N  * @{
N  */
N
N/** @defgroup DMA_Error_Code DMA Error Code
N  * @brief    DMA Error Code 
N  * @{
N  */ 
N#define HAL_DMA_ERROR_NONE            ((uint32_t)0x00000000U)    /*!< No error                               */
N#define HAL_DMA_ERROR_TE              ((uint32_t)0x00000001U)    /*!< Transfer error                         */
N#define HAL_DMA_ERROR_FE              ((uint32_t)0x00000002U)    /*!< FIFO error                             */
N#define HAL_DMA_ERROR_DME             ((uint32_t)0x00000004U)    /*!< Direct Mode error                      */
N#define HAL_DMA_ERROR_TIMEOUT         ((uint32_t)0x00000020U)    /*!< Timeout error                          */
N#define HAL_DMA_ERROR_PARAM           ((uint32_t)0x00000040U)    /*!< Parameter error                        */
N#define HAL_DMA_ERROR_NO_XFER         ((uint32_t)0x00000080U)    /*!< Abort requested with no Xfer ongoing   */ 
N#define HAL_DMA_ERROR_NOT_SUPPORTED   ((uint32_t)0x00000100U)    /*!< Not supported mode                     */     
N/**
N  * @}
N  */
N
N/** @defgroup DMA_Data_transfer_direction DMA Data transfer direction
N  * @brief    DMA data transfer direction 
N  * @{
N  */ 
N#define DMA_PERIPH_TO_MEMORY         ((uint32_t)0x00000000U)      /*!< Peripheral to memory direction */
N#define DMA_MEMORY_TO_PERIPH         ((uint32_t)DMA_SxCR_DIR_0)  /*!< Memory to peripheral direction */
N#define DMA_MEMORY_TO_MEMORY         ((uint32_t)DMA_SxCR_DIR_1)  /*!< Memory to memory direction     */
N/**
N  * @}
N  */
N        
N/** @defgroup DMA_Peripheral_incremented_mode DMA Peripheral incremented mode
N  * @brief    DMA peripheral incremented mode 
N  * @{
N  */ 
N#define DMA_PINC_ENABLE        ((uint32_t)DMA_SxCR_PINC)  /*!< Peripheral increment mode enable  */
N#define DMA_PINC_DISABLE       ((uint32_t)0x00000000U)     /*!< Peripheral increment mode disable */
N/**
N  * @}
N  */ 
N
N/** @defgroup DMA_Memory_incremented_mode DMA Memory incremented mode
N  * @brief    DMA memory incremented mode 
N  * @{
N  */ 
N#define DMA_MINC_ENABLE         ((uint32_t)DMA_SxCR_MINC)  /*!< Memory increment mode enable  */
N#define DMA_MINC_DISABLE        ((uint32_t)0x00000000U)     /*!< Memory increment mode disable */
N/**
N  * @}
N  */
N
N/** @defgroup DMA_Peripheral_data_size DMA Peripheral data size
N  * @brief    DMA peripheral data size 
N  * @{
N  */ 
N#define DMA_PDATAALIGN_BYTE          ((uint32_t)0x00000000U)        /*!< Peripheral data alignment: Byte     */
N#define DMA_PDATAALIGN_HALFWORD      ((uint32_t)DMA_SxCR_PSIZE_0)  /*!< Peripheral data alignment: HalfWord */
N#define DMA_PDATAALIGN_WORD          ((uint32_t)DMA_SxCR_PSIZE_1)  /*!< Peripheral data alignment: Word     */
N/**
N  * @}
N  */ 
N
N/** @defgroup DMA_Memory_data_size DMA Memory data size
N  * @brief    DMA memory data size 
N  * @{ 
N  */
N#define DMA_MDATAALIGN_BYTE          ((uint32_t)0x00000000U)        /*!< Memory data alignment: Byte     */
N#define DMA_MDATAALIGN_HALFWORD      ((uint32_t)DMA_SxCR_MSIZE_0)  /*!< Memory data alignment: HalfWord */
N#define DMA_MDATAALIGN_WORD          ((uint32_t)DMA_SxCR_MSIZE_1)  /*!< Memory data alignment: Word     */
N/**
N  * @}
N  */
N
N/** @defgroup DMA_mode DMA mode
N  * @brief    DMA mode 
N  * @{
N  */ 
N#define DMA_NORMAL         ((uint32_t)0x00000000U)       /*!< Normal mode                  */
N#define DMA_CIRCULAR       ((uint32_t)DMA_SxCR_CIRC)    /*!< Circular mode                */
N#define DMA_PFCTRL         ((uint32_t)DMA_SxCR_PFCTRL)  /*!< Peripheral flow control mode */
N/**
N  * @}
N  */
N
N/** @defgroup DMA_Priority_level DMA Priority level
N  * @brief    DMA priority levels 
N  * @{
N  */
N#define DMA_PRIORITY_LOW             ((uint32_t)0x00000000U)     /*!< Priority level: Low       */
N#define DMA_PRIORITY_MEDIUM          ((uint32_t)DMA_SxCR_PL_0)  /*!< Priority level: Medium    */
N#define DMA_PRIORITY_HIGH            ((uint32_t)DMA_SxCR_PL_1)  /*!< Priority level: High      */
N#define DMA_PRIORITY_VERY_HIGH       ((uint32_t)DMA_SxCR_PL)    /*!< Priority level: Very High */
N/**
N  * @}
N  */ 
N
N/** @defgroup DMA_FIFO_direct_mode DMA FIFO direct mode
N  * @brief    DMA FIFO direct mode
N  * @{
N  */
N#define DMA_FIFOMODE_DISABLE        ((uint32_t)0x00000000U)       /*!< FIFO mode disable */
N#define DMA_FIFOMODE_ENABLE         ((uint32_t)DMA_SxFCR_DMDIS)  /*!< FIFO mode enable  */
N/**
N  * @}
N  */ 
N
N/** @defgroup DMA_FIFO_threshold_level DMA FIFO threshold level
N  * @brief    DMA FIFO level 
N  * @{
N  */
N#define DMA_FIFO_THRESHOLD_1QUARTERFULL       ((uint32_t)0x00000000U)       /*!< FIFO threshold 1 quart full configuration  */
N#define DMA_FIFO_THRESHOLD_HALFFULL           ((uint32_t)DMA_SxFCR_FTH_0)  /*!< FIFO threshold half full configuration     */
N#define DMA_FIFO_THRESHOLD_3QUARTERSFULL      ((uint32_t)DMA_SxFCR_FTH_1)  /*!< FIFO threshold 3 quarts full configuration */
N#define DMA_FIFO_THRESHOLD_FULL               ((uint32_t)DMA_SxFCR_FTH)    /*!< FIFO threshold full configuration          */
N/**
N  * @}
N  */ 
N
N/** @defgroup DMA_Memory_burst DMA Memory burst
N  * @brief    DMA memory burst 
N  * @{
N  */ 
N#define DMA_MBURST_SINGLE       ((uint32_t)0x00000000U)  
N#define DMA_MBURST_INC4         ((uint32_t)DMA_SxCR_MBURST_0)  
N#define DMA_MBURST_INC8         ((uint32_t)DMA_SxCR_MBURST_1)  
N#define DMA_MBURST_INC16        ((uint32_t)DMA_SxCR_MBURST)  
N/**
N  * @}
N  */ 
N
N/** @defgroup DMA_Peripheral_burst DMA Peripheral burst
N  * @brief    DMA peripheral burst 
N  * @{
N  */ 
N#define DMA_PBURST_SINGLE       ((uint32_t)0x00000000U)
N#define DMA_PBURST_INC4         ((uint32_t)DMA_SxCR_PBURST_0)
N#define DMA_PBURST_INC8         ((uint32_t)DMA_SxCR_PBURST_1)
N#define DMA_PBURST_INC16        ((uint32_t)DMA_SxCR_PBURST)
N/**
N  * @}
N  */
N
N/** @defgroup DMA_interrupt_enable_definitions DMA interrupt enable definitions
N  * @brief    DMA interrupts definition 
N  * @{
N  */
N#define DMA_IT_TC                         ((uint32_t)DMA_SxCR_TCIE)
N#define DMA_IT_HT                         ((uint32_t)DMA_SxCR_HTIE)
N#define DMA_IT_TE                         ((uint32_t)DMA_SxCR_TEIE)
N#define DMA_IT_DME                        ((uint32_t)DMA_SxCR_DMEIE)
N#define DMA_IT_FE                         ((uint32_t)0x00000080U)
N/**
N  * @}
N  */
N
N/** @defgroup DMA_flag_definitions DMA flag definitions
N  * @brief    DMA flag definitions 
N  * @{
N  */ 
N#define DMA_FLAG_FEIF0_4                    ((uint32_t)0x00800001U)
N#define DMA_FLAG_DMEIF0_4                   ((uint32_t)0x00800004U)
N#define DMA_FLAG_TEIF0_4                    ((uint32_t)0x00000008U)
N#define DMA_FLAG_HTIF0_4                    ((uint32_t)0x00000010U)
N#define DMA_FLAG_TCIF0_4                    ((uint32_t)0x00000020U)
N#define DMA_FLAG_FEIF1_5                    ((uint32_t)0x00000040U)
N#define DMA_FLAG_DMEIF1_5                   ((uint32_t)0x00000100U)
N#define DMA_FLAG_TEIF1_5                    ((uint32_t)0x00000200U)
N#define DMA_FLAG_HTIF1_5                    ((uint32_t)0x00000400U)
N#define DMA_FLAG_TCIF1_5                    ((uint32_t)0x00000800U)
N#define DMA_FLAG_FEIF2_6                    ((uint32_t)0x00010000U)
N#define DMA_FLAG_DMEIF2_6                   ((uint32_t)0x00040000U)
N#define DMA_FLAG_TEIF2_6                    ((uint32_t)0x00080000U)
N#define DMA_FLAG_HTIF2_6                    ((uint32_t)0x00100000U)
N#define DMA_FLAG_TCIF2_6                    ((uint32_t)0x00200000U)
N#define DMA_FLAG_FEIF3_7                    ((uint32_t)0x00400000U)
N#define DMA_FLAG_DMEIF3_7                   ((uint32_t)0x01000000U)
N#define DMA_FLAG_TEIF3_7                    ((uint32_t)0x02000000U)
N#define DMA_FLAG_HTIF3_7                    ((uint32_t)0x04000000U)
N#define DMA_FLAG_TCIF3_7                    ((uint32_t)0x08000000U)
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N 
N/* Exported macro ------------------------------------------------------------*/
N
N/** @brief Reset DMA handle state
N  * @param  __HANDLE__: specifies the DMA handle.
N  * @retval None
N  */
N#define __HAL_DMA_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_DMA_STATE_RESET)
N
N/**
N  * @brief  Return the current DMA Stream FIFO filled level.
N  * @param  __HANDLE__: DMA handle
N  * @retval The FIFO filling state.
N  *           - DMA_FIFOStatus_Less1QuarterFull: when FIFO is less than 1 quarter-full 
N  *                                              and not empty.
N  *           - DMA_FIFOStatus_1QuarterFull: if more than 1 quarter-full.
N  *           - DMA_FIFOStatus_HalfFull: if more than 1 half-full.
N  *           - DMA_FIFOStatus_3QuartersFull: if more than 3 quarters-full.
N  *           - DMA_FIFOStatus_Empty: when FIFO is empty
N  *           - DMA_FIFOStatus_Full: when FIFO is full
N  */
N#define __HAL_DMA_GET_FS(__HANDLE__)      (((__HANDLE__)->Instance->FCR & (DMA_SxFCR_FS)))
N
N/**
N  * @brief  Enable the specified DMA Stream.
N  * @param  __HANDLE__: DMA handle
N  * @retval None
N  */
N#define __HAL_DMA_ENABLE(__HANDLE__)      ((__HANDLE__)->Instance->CR |=  DMA_SxCR_EN)
N
N/**
N  * @brief  Disable the specified DMA Stream.
N  * @param  __HANDLE__: DMA handle
N  * @retval None
N  */
N#define __HAL_DMA_DISABLE(__HANDLE__)     ((__HANDLE__)->Instance->CR &=  ~DMA_SxCR_EN)
N
N/* Interrupt & Flag management */
N
N/**
N  * @brief  Return the current DMA Stream transfer complete flag.
N  * @param  __HANDLE__: DMA handle
N  * @retval The specified transfer complete flag index.
N  */
N#define __HAL_DMA_GET_TC_FLAG_INDEX(__HANDLE__) \
N(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_TCIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_TCIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_TCIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_TCIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_TCIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_TCIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_TCIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_TCIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_TCIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_TCIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_TCIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_TCIF2_6 :\
N   DMA_FLAG_TCIF3_7)
X#define __HAL_DMA_GET_TC_FLAG_INDEX(__HANDLE__) (((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_TCIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_TCIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_TCIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_TCIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_TCIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_TCIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_TCIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_TCIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_TCIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_TCIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_TCIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_TCIF2_6 :   DMA_FLAG_TCIF3_7)
N
N/**
N  * @brief  Return the current DMA Stream half transfer complete flag.
N  * @param  __HANDLE__: DMA handle
N  * @retval The specified half transfer complete flag index.
N  */      
N#define __HAL_DMA_GET_HT_FLAG_INDEX(__HANDLE__)\
N(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_HTIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_HTIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_HTIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_HTIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_HTIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_HTIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_HTIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_HTIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_HTIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_HTIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_HTIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_HTIF2_6 :\
N   DMA_FLAG_HTIF3_7)
X#define __HAL_DMA_GET_HT_FLAG_INDEX(__HANDLE__)(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_HTIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_HTIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_HTIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_HTIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_HTIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_HTIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_HTIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_HTIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_HTIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_HTIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_HTIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_HTIF2_6 :   DMA_FLAG_HTIF3_7)
N
N/**
N  * @brief  Return the current DMA Stream transfer error flag.
N  * @param  __HANDLE__: DMA handle
N  * @retval The specified transfer error flag index.
N  */
N#define __HAL_DMA_GET_TE_FLAG_INDEX(__HANDLE__)\
N(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_TEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_TEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_TEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_TEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_TEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_TEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_TEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_TEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_TEIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_TEIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_TEIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_TEIF2_6 :\
N   DMA_FLAG_TEIF3_7)
X#define __HAL_DMA_GET_TE_FLAG_INDEX(__HANDLE__)(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_TEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_TEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_TEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_TEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_TEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_TEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_TEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_TEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_TEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_TEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_TEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_TEIF2_6 :   DMA_FLAG_TEIF3_7)
N
N/**
N  * @brief  Return the current DMA Stream FIFO error flag.
N  * @param  __HANDLE__: DMA handle
N  * @retval The specified FIFO error flag index.
N  */
N#define __HAL_DMA_GET_FE_FLAG_INDEX(__HANDLE__)\
N(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_FEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_FEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_FEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_FEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_FEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_FEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_FEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_FEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_FEIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_FEIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_FEIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_FEIF2_6 :\
N   DMA_FLAG_FEIF3_7)
X#define __HAL_DMA_GET_FE_FLAG_INDEX(__HANDLE__)(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_FEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_FEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_FEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_FEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_FEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_FEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_FEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_FEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_FEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_FEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_FEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_FEIF2_6 :   DMA_FLAG_FEIF3_7)
N
N/**
N  * @brief  Return the current DMA Stream direct mode error flag.
N  * @param  __HANDLE__: DMA handle
N  * @retval The specified direct mode error flag index.
N  */
N#define __HAL_DMA_GET_DME_FLAG_INDEX(__HANDLE__)\
N(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_DMEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_DMEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_DMEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_DMEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_DMEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_DMEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_DMEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_DMEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_DMEIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_DMEIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_DMEIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_DMEIF2_6 :\
N   DMA_FLAG_DMEIF3_7)
X#define __HAL_DMA_GET_DME_FLAG_INDEX(__HANDLE__)(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_DMEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_DMEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_DMEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_DMEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_DMEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_DMEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_DMEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_DMEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_DMEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_DMEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_DMEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_DMEIF2_6 :   DMA_FLAG_DMEIF3_7)
N
N/**
N  * @brief  Get the DMA Stream pending flags.
N  * @param  __HANDLE__: DMA handle
N  * @param  __FLAG__: Get the specified flag.
N  *          This parameter can be any combination of the following values:
N  *            @arg DMA_FLAG_TCIFx: Transfer complete flag.
N  *            @arg DMA_FLAG_HTIFx: Half transfer complete flag.
N  *            @arg DMA_FLAG_TEIFx: Transfer error flag.
N  *            @arg DMA_FLAG_DMEIFx: Direct mode error flag.
N  *            @arg DMA_FLAG_FEIFx: FIFO error flag.
N  *         Where x can be 0_4, 1_5, 2_6 or 3_7 to select the DMA Stream flag.   
N  * @retval The state of FLAG (SET or RESET).
N  */
N#define __HAL_DMA_GET_FLAG(__HANDLE__, __FLAG__)\
N(((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA2_Stream3)? (DMA2->HISR & (__FLAG__)) :\
N ((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA1_Stream7)? (DMA2->LISR & (__FLAG__)) :\
N ((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA1_Stream3)? (DMA1->HISR & (__FLAG__)) : (DMA1->LISR & (__FLAG__)))
X#define __HAL_DMA_GET_FLAG(__HANDLE__, __FLAG__)(((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA2_Stream3)? (DMA2->HISR & (__FLAG__)) : ((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA1_Stream7)? (DMA2->LISR & (__FLAG__)) : ((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA1_Stream3)? (DMA1->HISR & (__FLAG__)) : (DMA1->LISR & (__FLAG__)))
N
N/**
N  * @brief  Clear the DMA Stream pending flags.
N  * @param  __HANDLE__: DMA handle
N  * @param  __FLAG__: specifies the flag to clear.
N  *          This parameter can be any combination of the following values:
N  *            @arg DMA_FLAG_TCIFx: Transfer complete flag.
N  *            @arg DMA_FLAG_HTIFx: Half transfer complete flag.
N  *            @arg DMA_FLAG_TEIFx: Transfer error flag.
N  *            @arg DMA_FLAG_DMEIFx: Direct mode error flag.
N  *            @arg DMA_FLAG_FEIFx: FIFO error flag.
N  *         Where x can be 0_4, 1_5, 2_6 or 3_7 to select the DMA Stream flag.   
N  * @retval None
N  */
N#define __HAL_DMA_CLEAR_FLAG(__HANDLE__, __FLAG__) \
N(((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA2_Stream3)? (DMA2->HIFCR = (__FLAG__)) :\
N ((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA1_Stream7)? (DMA2->LIFCR = (__FLAG__)) :\
N ((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA1_Stream3)? (DMA1->HIFCR = (__FLAG__)) : (DMA1->LIFCR = (__FLAG__)))
X#define __HAL_DMA_CLEAR_FLAG(__HANDLE__, __FLAG__) (((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA2_Stream3)? (DMA2->HIFCR = (__FLAG__)) : ((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA1_Stream7)? (DMA2->LIFCR = (__FLAG__)) : ((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA1_Stream3)? (DMA1->HIFCR = (__FLAG__)) : (DMA1->LIFCR = (__FLAG__)))
N
N/**
N  * @brief  Enable the specified DMA Stream interrupts.
N  * @param  __HANDLE__: DMA handle
N  * @param  __INTERRUPT__: specifies the DMA interrupt sources to be enabled or disabled. 
N  *        This parameter can be one of the following values:
N  *           @arg DMA_IT_TC: Transfer complete interrupt mask.
N  *           @arg DMA_IT_HT: Half transfer complete interrupt mask.
N  *           @arg DMA_IT_TE: Transfer error interrupt mask.
N  *           @arg DMA_IT_FE: FIFO error interrupt mask.
N  *           @arg DMA_IT_DME: Direct mode error interrupt.
N  * @retval None
N  */
N#define __HAL_DMA_ENABLE_IT(__HANDLE__, __INTERRUPT__)   (((__INTERRUPT__) != DMA_IT_FE)? \
N((__HANDLE__)->Instance->CR |= (__INTERRUPT__)) : ((__HANDLE__)->Instance->FCR |= (__INTERRUPT__)))
X#define __HAL_DMA_ENABLE_IT(__HANDLE__, __INTERRUPT__)   (((__INTERRUPT__) != DMA_IT_FE)? ((__HANDLE__)->Instance->CR |= (__INTERRUPT__)) : ((__HANDLE__)->Instance->FCR |= (__INTERRUPT__)))
N
N/**
N  * @brief  Disable the specified DMA Stream interrupts.
N  * @param  __HANDLE__: DMA handle
N  * @param  __INTERRUPT__: specifies the DMA interrupt sources to be enabled or disabled. 
N  *         This parameter can be one of the following values:
N  *            @arg DMA_IT_TC: Transfer complete interrupt mask.
N  *            @arg DMA_IT_HT: Half transfer complete interrupt mask.
N  *            @arg DMA_IT_TE: Transfer error interrupt mask.
N  *            @arg DMA_IT_FE: FIFO error interrupt mask.
N  *            @arg DMA_IT_DME: Direct mode error interrupt.
N  * @retval None
N  */
N#define __HAL_DMA_DISABLE_IT(__HANDLE__, __INTERRUPT__)  (((__INTERRUPT__) != DMA_IT_FE)? \
N((__HANDLE__)->Instance->CR &= ~(__INTERRUPT__)) : ((__HANDLE__)->Instance->FCR &= ~(__INTERRUPT__)))
X#define __HAL_DMA_DISABLE_IT(__HANDLE__, __INTERRUPT__)  (((__INTERRUPT__) != DMA_IT_FE)? ((__HANDLE__)->Instance->CR &= ~(__INTERRUPT__)) : ((__HANDLE__)->Instance->FCR &= ~(__INTERRUPT__)))
N
N/**
N  * @brief  Check whether the specified DMA Stream interrupt is enabled or not.
N  * @param  __HANDLE__: DMA handle
N  * @param  __INTERRUPT__: specifies the DMA interrupt source to check.
N  *         This parameter can be one of the following values:
N  *            @arg DMA_IT_TC: Transfer complete interrupt mask.
N  *            @arg DMA_IT_HT: Half transfer complete interrupt mask.
N  *            @arg DMA_IT_TE: Transfer error interrupt mask.
N  *            @arg DMA_IT_FE: FIFO error interrupt mask.
N  *            @arg DMA_IT_DME: Direct mode error interrupt.
N  * @retval The state of DMA_IT.
N  */
N#define __HAL_DMA_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)  (((__INTERRUPT__) != DMA_IT_FE)? \
N                                                        ((__HANDLE__)->Instance->CR & (__INTERRUPT__)) : \
N                                                        ((__HANDLE__)->Instance->FCR & (__INTERRUPT__)))
X#define __HAL_DMA_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)  (((__INTERRUPT__) != DMA_IT_FE)?                                                         ((__HANDLE__)->Instance->CR & (__INTERRUPT__)) :                                                         ((__HANDLE__)->Instance->FCR & (__INTERRUPT__)))
N
N/**
N  * @brief  Writes the number of data units to be transferred on the DMA Stream.
N  * @param  __HANDLE__: DMA handle
N  * @param  __COUNTER__: Number of data units to be transferred (from 0 to 65535) 
N  *          Number of data items depends only on the Peripheral data format.
N  *            
N  * @note   If Peripheral data format is Bytes: number of data units is equal 
N  *         to total number of bytes to be transferred.
N  *           
N  * @note   If Peripheral data format is Half-Word: number of data units is  
N  *         equal to total number of bytes to be transferred / 2.
N  *           
N  * @note   If Peripheral data format is Word: number of data units is equal 
N  *         to total  number of bytes to be transferred / 4.
N  *      
N  * @retval The number of remaining data units in the current DMAy Streamx transfer.
N  */
N#define __HAL_DMA_SET_COUNTER(__HANDLE__, __COUNTER__) ((__HANDLE__)->Instance->NDTR = (uint16_t)(__COUNTER__))
N
N/**
N  * @brief  Returns the number of remaining data units in the current DMAy Streamx transfer.
N  * @param  __HANDLE__: DMA handle
N  *   
N  * @retval The number of remaining data units in the current DMA Stream transfer.
N  */
N#define __HAL_DMA_GET_COUNTER(__HANDLE__) ((__HANDLE__)->Instance->NDTR)
N
N
N/* Include DMA HAL Extension module */
N#include "stm32f7xx_hal_dma_ex.h"   
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_dma_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_dma_ex.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of DMA HAL extension module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_DMA_EX_H
N#define __STM32F7xx_HAL_DMA_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup DMAEx
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup DMAEx_Exported_Types DMAEx Exported Types
N  * @brief DMAEx Exported types
N  * @{
N  */
N   
N/** 
N  * @brief  HAL DMA Memory definition  
N  */ 
Ntypedef enum
N{
N  MEMORY0      = 0x00U,    /*!< Memory 0     */
N  MEMORY1      = 0x01U,    /*!< Memory 1     */
N
N}HAL_DMA_MemoryTypeDef;
N
N/**
N  * @}
N  */
N  
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup DMA_Exported_Constants DMA Exported Constants
N  * @brief    DMA Exported constants 
N  * @{
N  */
N
N/** @defgroup DMAEx_Channel_selection DMA Channel selection
N  * @brief    DMAEx channel selection 
N  * @{
N  */ 
N#define DMA_CHANNEL_0        ((uint32_t)0x00000000U)  /*!< DMA Channel 0 */
N#define DMA_CHANNEL_1        ((uint32_t)0x02000000U)  /*!< DMA Channel 1 */
N#define DMA_CHANNEL_2        ((uint32_t)0x04000000U)  /*!< DMA Channel 2 */
N#define DMA_CHANNEL_3        ((uint32_t)0x06000000U)  /*!< DMA Channel 3 */
N#define DMA_CHANNEL_4        ((uint32_t)0x08000000U)  /*!< DMA Channel 4 */
N#define DMA_CHANNEL_5        ((uint32_t)0x0A000000U)  /*!< DMA Channel 5 */
N#define DMA_CHANNEL_6        ((uint32_t)0x0C000000U)  /*!< DMA Channel 6 */
N#define DMA_CHANNEL_7        ((uint32_t)0x0E000000U)  /*!< DMA Channel 7 */
N#if defined (STM32F765xx) || defined(STM32F767xx) || defined(STM32F769xx) || defined(STM32F777xx) || defined(STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N#define DMA_CHANNEL_8        ((uint32_t)0x10000000U)  /*!< DMA Channel 8 */
N#define DMA_CHANNEL_9        ((uint32_t)0x12000000U)  /*!< DMA Channel 9 */
N#define DMA_CHANNEL_10       ((uint32_t)0x14000000U)  /*!< DMA Channel 10*/
N#define DMA_CHANNEL_11       ((uint32_t)0x16000000U)  /*!< DMA Channel 11*/
N#define DMA_CHANNEL_12       ((uint32_t)0x18000000U)  /*!< DMA Channel 12*/
N#define DMA_CHANNEL_13       ((uint32_t)0x1A000000U)  /*!< DMA Channel 13*/
N#define DMA_CHANNEL_14       ((uint32_t)0x1C000000U)  /*!< DMA Channel 14*/
N#define DMA_CHANNEL_15       ((uint32_t)0x1E000000U)  /*!< DMA Channel 15*/
N#endif /* STM32F765xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */  
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup DMAEx_Exported_Functions DMAEx Exported Functions
N  * @brief   DMAEx Exported functions
N  * @{
N  */
N
N/** @defgroup DMAEx_Exported_Functions_Group1 Extended features functions
N  * @brief   Extended features functions
N  * @{
N  */
N
N/* IO operation functions *******************************************************/
NHAL_StatusTypeDef HAL_DMAEx_MultiBufferStart(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength);
NHAL_StatusTypeDef HAL_DMAEx_MultiBufferStart_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength);
NHAL_StatusTypeDef HAL_DMAEx_ChangeMemory(DMA_HandleTypeDef *hdma, uint32_t Address, HAL_DMA_MemoryTypeDef memory);
N
N/**
N  * @}
N  */
N/**
N  * @}
N  */
N  
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup DMAEx_Private_Macros DMA Private Macros
N  * @brief    DMAEx private macros 
N  * @{
N  */
N#if defined (STM32F765xx) || defined(STM32F767xx) || defined(STM32F769xx) || defined(STM32F777xx) || defined(STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N#define IS_DMA_CHANNEL(CHANNEL) (((CHANNEL) == DMA_CHANNEL_0)  || \
N                                 ((CHANNEL) == DMA_CHANNEL_1)  || \
N                                 ((CHANNEL) == DMA_CHANNEL_2)  || \
N                                 ((CHANNEL) == DMA_CHANNEL_3)  || \
N                                 ((CHANNEL) == DMA_CHANNEL_4)  || \
N                                 ((CHANNEL) == DMA_CHANNEL_5)  || \
N                                 ((CHANNEL) == DMA_CHANNEL_6)  || \
N                                 ((CHANNEL) == DMA_CHANNEL_7)  || \
N                                 ((CHANNEL) == DMA_CHANNEL_8)  || \
N                                 ((CHANNEL) == DMA_CHANNEL_9)  || \
N                                 ((CHANNEL) == DMA_CHANNEL_10) || \
N                                 ((CHANNEL) == DMA_CHANNEL_11) || \
N                                 ((CHANNEL) == DMA_CHANNEL_12) || \
N                                 ((CHANNEL) == DMA_CHANNEL_13) || \
N                                 ((CHANNEL) == DMA_CHANNEL_14) || \
N                                 ((CHANNEL) == DMA_CHANNEL_15)) 
X#define IS_DMA_CHANNEL(CHANNEL) (((CHANNEL) == DMA_CHANNEL_0)  ||                                  ((CHANNEL) == DMA_CHANNEL_1)  ||                                  ((CHANNEL) == DMA_CHANNEL_2)  ||                                  ((CHANNEL) == DMA_CHANNEL_3)  ||                                  ((CHANNEL) == DMA_CHANNEL_4)  ||                                  ((CHANNEL) == DMA_CHANNEL_5)  ||                                  ((CHANNEL) == DMA_CHANNEL_6)  ||                                  ((CHANNEL) == DMA_CHANNEL_7)  ||                                  ((CHANNEL) == DMA_CHANNEL_8)  ||                                  ((CHANNEL) == DMA_CHANNEL_9)  ||                                  ((CHANNEL) == DMA_CHANNEL_10) ||                                  ((CHANNEL) == DMA_CHANNEL_11) ||                                  ((CHANNEL) == DMA_CHANNEL_12) ||                                  ((CHANNEL) == DMA_CHANNEL_13) ||                                  ((CHANNEL) == DMA_CHANNEL_14) ||                                  ((CHANNEL) == DMA_CHANNEL_15)) 
N#else
S#define IS_DMA_CHANNEL(CHANNEL) (((CHANNEL) == DMA_CHANNEL_0) || \
S                                 ((CHANNEL) == DMA_CHANNEL_1) || \
S                                 ((CHANNEL) == DMA_CHANNEL_2) || \
S                                 ((CHANNEL) == DMA_CHANNEL_3) || \
S                                 ((CHANNEL) == DMA_CHANNEL_4) || \
S                                 ((CHANNEL) == DMA_CHANNEL_5) || \
S                                 ((CHANNEL) == DMA_CHANNEL_6) || \
S                                 ((CHANNEL) == DMA_CHANNEL_7))
X#define IS_DMA_CHANNEL(CHANNEL) (((CHANNEL) == DMA_CHANNEL_0) ||                                  ((CHANNEL) == DMA_CHANNEL_1) ||                                  ((CHANNEL) == DMA_CHANNEL_2) ||                                  ((CHANNEL) == DMA_CHANNEL_3) ||                                  ((CHANNEL) == DMA_CHANNEL_4) ||                                  ((CHANNEL) == DMA_CHANNEL_5) ||                                  ((CHANNEL) == DMA_CHANNEL_6) ||                                  ((CHANNEL) == DMA_CHANNEL_7))
N#endif /* STM32F765xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N/**
N  * @}
N  */  
N         
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup DMAEx_Private_Functions DMAEx Private Functions
N  * @brief DMAEx Private functions
N  * @{
N  */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_DMA_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 633 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_dma.h" 2
N
N/* Exported functions --------------------------------------------------------*/
N
N/** @defgroup DMA_Exported_Functions DMA Exported Functions
N  * @brief    DMA Exported functions 
N  * @{
N  */
N
N/** @defgroup DMA_Exported_Functions_Group1 Initialization and de-initialization functions
N  * @brief   Initialization and de-initialization functions 
N  * @{
N  */
NHAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma); 
NHAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma);
N/**
N  * @}
N  */
N
N/** @defgroup DMA_Exported_Functions_Group2 I/O operation functions
N  * @brief   I/O operation functions  
N  * @{
N  */
NHAL_StatusTypeDef HAL_DMA_Start (DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength);
NHAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength);
NHAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma);
NHAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma);
NHAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, HAL_DMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout);
Nvoid              HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma);
NHAL_StatusTypeDef HAL_DMA_CleanCallbacks(DMA_HandleTypeDef *hdma);
NHAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)(DMA_HandleTypeDef *_hdma));
NHAL_StatusTypeDef HAL_DMA_UnRegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID);
N
N/**
N  * @}
N  */ 
N
N/** @defgroup DMA_Exported_Functions_Group3 Peripheral State functions
N  * @brief    Peripheral State functions 
N  * @{
N  */
NHAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma);
Nuint32_t             HAL_DMA_GetError(DMA_HandleTypeDef *hdma);
N/**
N  * @}
N  */ 
N/**
N  * @}
N  */ 
N/* Private Constants -------------------------------------------------------------*/
N/** @defgroup DMA_Private_Constants DMA Private Constants
N  * @brief    DMA private defines and constants 
N  * @{
N  */
N/**
N  * @}
N  */ 
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup DMA_Private_Macros DMA Private Macros
N  * @brief    DMA private macros 
N  * @{
N  */
N#define IS_DMA_DIRECTION(DIRECTION) (((DIRECTION) == DMA_PERIPH_TO_MEMORY ) || \
N                                     ((DIRECTION) == DMA_MEMORY_TO_PERIPH)  || \
N                                     ((DIRECTION) == DMA_MEMORY_TO_MEMORY)) 
X#define IS_DMA_DIRECTION(DIRECTION) (((DIRECTION) == DMA_PERIPH_TO_MEMORY ) ||                                      ((DIRECTION) == DMA_MEMORY_TO_PERIPH)  ||                                      ((DIRECTION) == DMA_MEMORY_TO_MEMORY)) 
N
N#define IS_DMA_BUFFER_SIZE(SIZE) (((SIZE) >= 0x01U) && ((SIZE) < 0x10000U))
N
N#define IS_DMA_PERIPHERAL_INC_STATE(STATE) (((STATE) == DMA_PINC_ENABLE) || \
N                                            ((STATE) == DMA_PINC_DISABLE))
X#define IS_DMA_PERIPHERAL_INC_STATE(STATE) (((STATE) == DMA_PINC_ENABLE) ||                                             ((STATE) == DMA_PINC_DISABLE))
N
N#define IS_DMA_MEMORY_INC_STATE(STATE) (((STATE) == DMA_MINC_ENABLE)  || \
N                                        ((STATE) == DMA_MINC_DISABLE))
X#define IS_DMA_MEMORY_INC_STATE(STATE) (((STATE) == DMA_MINC_ENABLE)  ||                                         ((STATE) == DMA_MINC_DISABLE))
N
N#define IS_DMA_PERIPHERAL_DATA_SIZE(SIZE) (((SIZE) == DMA_PDATAALIGN_BYTE)     || \
N                                           ((SIZE) == DMA_PDATAALIGN_HALFWORD) || \
N                                           ((SIZE) == DMA_PDATAALIGN_WORD))
X#define IS_DMA_PERIPHERAL_DATA_SIZE(SIZE) (((SIZE) == DMA_PDATAALIGN_BYTE)     ||                                            ((SIZE) == DMA_PDATAALIGN_HALFWORD) ||                                            ((SIZE) == DMA_PDATAALIGN_WORD))
N
N#define IS_DMA_MEMORY_DATA_SIZE(SIZE) (((SIZE) == DMA_MDATAALIGN_BYTE)     || \
N                                       ((SIZE) == DMA_MDATAALIGN_HALFWORD) || \
N                                       ((SIZE) == DMA_MDATAALIGN_WORD ))
X#define IS_DMA_MEMORY_DATA_SIZE(SIZE) (((SIZE) == DMA_MDATAALIGN_BYTE)     ||                                        ((SIZE) == DMA_MDATAALIGN_HALFWORD) ||                                        ((SIZE) == DMA_MDATAALIGN_WORD ))
N
N#define IS_DMA_MODE(MODE) (((MODE) == DMA_NORMAL )  || \
N                           ((MODE) == DMA_CIRCULAR) || \
N                           ((MODE) == DMA_PFCTRL)) 
X#define IS_DMA_MODE(MODE) (((MODE) == DMA_NORMAL )  ||                            ((MODE) == DMA_CIRCULAR) ||                            ((MODE) == DMA_PFCTRL)) 
N
N#define IS_DMA_PRIORITY(PRIORITY) (((PRIORITY) == DMA_PRIORITY_LOW )   || \
N                                   ((PRIORITY) == DMA_PRIORITY_MEDIUM) || \
N                                   ((PRIORITY) == DMA_PRIORITY_HIGH)   || \
N                                   ((PRIORITY) == DMA_PRIORITY_VERY_HIGH)) 
X#define IS_DMA_PRIORITY(PRIORITY) (((PRIORITY) == DMA_PRIORITY_LOW )   ||                                    ((PRIORITY) == DMA_PRIORITY_MEDIUM) ||                                    ((PRIORITY) == DMA_PRIORITY_HIGH)   ||                                    ((PRIORITY) == DMA_PRIORITY_VERY_HIGH)) 
N
N#define IS_DMA_FIFO_MODE_STATE(STATE) (((STATE) == DMA_FIFOMODE_DISABLE ) || \
N                                       ((STATE) == DMA_FIFOMODE_ENABLE))
X#define IS_DMA_FIFO_MODE_STATE(STATE) (((STATE) == DMA_FIFOMODE_DISABLE ) ||                                        ((STATE) == DMA_FIFOMODE_ENABLE))
N
N#define IS_DMA_FIFO_THRESHOLD(THRESHOLD) (((THRESHOLD) == DMA_FIFO_THRESHOLD_1QUARTERFULL ) || \
N                                          ((THRESHOLD) == DMA_FIFO_THRESHOLD_HALFFULL)      || \
N                                          ((THRESHOLD) == DMA_FIFO_THRESHOLD_3QUARTERSFULL) || \
N                                          ((THRESHOLD) == DMA_FIFO_THRESHOLD_FULL))
X#define IS_DMA_FIFO_THRESHOLD(THRESHOLD) (((THRESHOLD) == DMA_FIFO_THRESHOLD_1QUARTERFULL ) ||                                           ((THRESHOLD) == DMA_FIFO_THRESHOLD_HALFFULL)      ||                                           ((THRESHOLD) == DMA_FIFO_THRESHOLD_3QUARTERSFULL) ||                                           ((THRESHOLD) == DMA_FIFO_THRESHOLD_FULL))
N
N#define IS_DMA_MEMORY_BURST(BURST) (((BURST) == DMA_MBURST_SINGLE) || \
N                                    ((BURST) == DMA_MBURST_INC4)   || \
N                                    ((BURST) == DMA_MBURST_INC8)   || \
N                                    ((BURST) == DMA_MBURST_INC16))
X#define IS_DMA_MEMORY_BURST(BURST) (((BURST) == DMA_MBURST_SINGLE) ||                                     ((BURST) == DMA_MBURST_INC4)   ||                                     ((BURST) == DMA_MBURST_INC8)   ||                                     ((BURST) == DMA_MBURST_INC16))
N
N#define IS_DMA_PERIPHERAL_BURST(BURST) (((BURST) == DMA_PBURST_SINGLE) || \
N                                        ((BURST) == DMA_PBURST_INC4)   || \
N                                        ((BURST) == DMA_PBURST_INC8)   || \
N                                        ((BURST) == DMA_PBURST_INC16))
X#define IS_DMA_PERIPHERAL_BURST(BURST) (((BURST) == DMA_PBURST_SINGLE) ||                                         ((BURST) == DMA_PBURST_INC4)   ||                                         ((BURST) == DMA_PBURST_INC8)   ||                                         ((BURST) == DMA_PBURST_INC16))
N/**
N  * @}
N  */ 
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup DMA_Private_Functions DMA Private Functions
N  * @brief    DMA private  functions 
N  * @{
N  */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_DMA_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 255 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_DMA_MODULE_ENABLED */
N   
N#ifdef HAL_CORTEX_MODULE_ENABLED
N  #include "stm32f7xx_hal_cortex.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_cortex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_cortex.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of CORTEX HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_CORTEX_H
N#define __STM32F7xx_HAL_CORTEX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup CORTEX
N  * @{
N  */ 
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup CORTEX_Exported_Types Cortex Exported Types
N  * @{
N  */
N
N#if (__MPU_PRESENT == 1)
X#if (1 == 1)
N/** @defgroup CORTEX_MPU_Region_Initialization_Structure_definition MPU Region Initialization Structure Definition
N  * @brief  MPU Region initialization structure 
N  * @{
N  */
Ntypedef struct
N{
N  uint8_t                Enable;                /*!< Specifies the status of the region. 
N                                                     This parameter can be a value of @ref CORTEX_MPU_Region_Enable                 */
N  uint8_t                Number;                /*!< Specifies the number of the region to protect. 
N                                                     This parameter can be a value of @ref CORTEX_MPU_Region_Number                 */
N  uint32_t               BaseAddress;           /*!< Specifies the base address of the region to protect.                           */
N  uint8_t                Size;                  /*!< Specifies the size of the region to protect. 
N                                                     This parameter can be a value of @ref CORTEX_MPU_Region_Size                   */
N  uint8_t                SubRegionDisable;      /*!< Specifies the number of the subregion protection to disable. 
N                                                     This parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFF    */         
N  uint8_t                TypeExtField;          /*!< Specifies the TEX field level.
N                                                     This parameter can be a value of @ref CORTEX_MPU_TEX_Levels                    */                 
N  uint8_t                AccessPermission;      /*!< Specifies the region access permission type. 
N                                                     This parameter can be a value of @ref CORTEX_MPU_Region_Permission_Attributes  */
N  uint8_t                DisableExec;           /*!< Specifies the instruction access status. 
N                                                     This parameter can be a value of @ref CORTEX_MPU_Instruction_Access            */
N  uint8_t                IsShareable;           /*!< Specifies the shareability status of the protected region. 
N                                                     This parameter can be a value of @ref CORTEX_MPU_Access_Shareable              */
N  uint8_t                IsCacheable;           /*!< Specifies the cacheable status of the region protected. 
N                                                     This parameter can be a value of @ref CORTEX_MPU_Access_Cacheable              */
N  uint8_t                IsBufferable;          /*!< Specifies the bufferable status of the protected region. 
N                                                     This parameter can be a value of @ref CORTEX_MPU_Access_Bufferable             */
N}MPU_Region_InitTypeDef;
N/**
N  * @}
N  */
N#endif /* __MPU_PRESENT */
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup CORTEX_Exported_Constants CORTEX Exported Constants
N  * @{
N  */
N
N/** @defgroup CORTEX_Preemption_Priority_Group CORTEX Preemption Priority Group
N  * @{
N  */
N#define NVIC_PRIORITYGROUP_0         ((uint32_t)0x00000007U) /*!< 0 bits for pre-emption priority
N                                                                 4 bits for subpriority */
N#define NVIC_PRIORITYGROUP_1         ((uint32_t)0x00000006U) /*!< 1 bits for pre-emption priority
N                                                                 3 bits for subpriority */
N#define NVIC_PRIORITYGROUP_2         ((uint32_t)0x00000005U) /*!< 2 bits for pre-emption priority
N                                                                 2 bits for subpriority */
N#define NVIC_PRIORITYGROUP_3         ((uint32_t)0x00000004U) /*!< 3 bits for pre-emption priority
N                                                                 1 bits for subpriority */
N#define NVIC_PRIORITYGROUP_4         ((uint32_t)0x00000003U) /*!< 4 bits for pre-emption priority
N                                                                 0 bits for subpriority */
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_SysTick_clock_source CORTEX _SysTick clock source 
N  * @{
N  */
N#define SYSTICK_CLKSOURCE_HCLK_DIV8    ((uint32_t)0x00000000U)
N#define SYSTICK_CLKSOURCE_HCLK         ((uint32_t)0x00000004U)
N
N/**
N  * @}
N  */
N
N#if (__MPU_PRESENT == 1)
X#if (1 == 1)
N/** @defgroup CORTEX_MPU_HFNMI_PRIVDEF_Control MPU HFNMI and PRIVILEGED Access control
N  * @{
N  */
N#define  MPU_HFNMI_PRIVDEF_NONE      ((uint32_t)0x00000000U)  
N#define  MPU_HARDFAULT_NMI           ((uint32_t)0x00000002U)
N#define  MPU_PRIVILEGED_DEFAULT      ((uint32_t)0x00000004U)
N#define  MPU_HFNMI_PRIVDEF           ((uint32_t)0x00000006U)
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_MPU_Region_Enable CORTEX MPU Region Enable
N  * @{
N  */
N#define  MPU_REGION_ENABLE     ((uint8_t)0x01U)
N#define  MPU_REGION_DISABLE    ((uint8_t)0x00U)
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_MPU_Instruction_Access CORTEX MPU Instruction Access
N  * @{
N  */
N#define  MPU_INSTRUCTION_ACCESS_ENABLE      ((uint8_t)0x00U)
N#define  MPU_INSTRUCTION_ACCESS_DISABLE     ((uint8_t)0x01U)
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_MPU_Access_Shareable CORTEX MPU Instruction Access Shareable
N  * @{
N  */
N#define  MPU_ACCESS_SHAREABLE        ((uint8_t)0x01U)
N#define  MPU_ACCESS_NOT_SHAREABLE    ((uint8_t)0x00U)
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_MPU_Access_Cacheable CORTEX MPU Instruction Access Cacheable
N  * @{
N  */
N#define  MPU_ACCESS_CACHEABLE         ((uint8_t)0x01U)
N#define  MPU_ACCESS_NOT_CACHEABLE     ((uint8_t)0x00U)
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_MPU_Access_Bufferable CORTEX MPU Instruction Access Bufferable
N  * @{
N  */
N#define  MPU_ACCESS_BUFFERABLE         ((uint8_t)0x01U)
N#define  MPU_ACCESS_NOT_BUFFERABLE     ((uint8_t)0x00U)
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_MPU_TEX_Levels MPU TEX Levels
N  * @{
N  */
N#define  MPU_TEX_LEVEL0    ((uint8_t)0x00U)
N#define  MPU_TEX_LEVEL1    ((uint8_t)0x01U)
N#define  MPU_TEX_LEVEL2    ((uint8_t)0x02U)
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_MPU_Region_Size CORTEX MPU Region Size
N  * @{
N  */
N#define   MPU_REGION_SIZE_32B      ((uint8_t)0x04U)
N#define   MPU_REGION_SIZE_64B      ((uint8_t)0x05U)
N#define   MPU_REGION_SIZE_128B     ((uint8_t)0x06U) 
N#define   MPU_REGION_SIZE_256B     ((uint8_t)0x07U) 
N#define   MPU_REGION_SIZE_512B     ((uint8_t)0x08U) 
N#define   MPU_REGION_SIZE_1KB      ((uint8_t)0x09U)  
N#define   MPU_REGION_SIZE_2KB      ((uint8_t)0x0AU)
N#define   MPU_REGION_SIZE_4KB      ((uint8_t)0x0BU) 
N#define   MPU_REGION_SIZE_8KB      ((uint8_t)0x0CU) 
N#define   MPU_REGION_SIZE_16KB     ((uint8_t)0x0DU) 
N#define   MPU_REGION_SIZE_32KB     ((uint8_t)0x0EU) 
N#define   MPU_REGION_SIZE_64KB     ((uint8_t)0x0FU) 
N#define   MPU_REGION_SIZE_128KB    ((uint8_t)0x10U)
N#define   MPU_REGION_SIZE_256KB    ((uint8_t)0x11U)
N#define   MPU_REGION_SIZE_512KB    ((uint8_t)0x12U)
N#define   MPU_REGION_SIZE_1MB      ((uint8_t)0x13U) 
N#define   MPU_REGION_SIZE_2MB      ((uint8_t)0x14U) 
N#define   MPU_REGION_SIZE_4MB      ((uint8_t)0x15U) 
N#define   MPU_REGION_SIZE_8MB      ((uint8_t)0x16U) 
N#define   MPU_REGION_SIZE_16MB     ((uint8_t)0x17U)
N#define   MPU_REGION_SIZE_32MB     ((uint8_t)0x18U)
N#define   MPU_REGION_SIZE_64MB     ((uint8_t)0x19U)
N#define   MPU_REGION_SIZE_128MB    ((uint8_t)0x1AU)
N#define   MPU_REGION_SIZE_256MB    ((uint8_t)0x1BU)
N#define   MPU_REGION_SIZE_512MB    ((uint8_t)0x1CU)
N#define   MPU_REGION_SIZE_1GB      ((uint8_t)0x1DU) 
N#define   MPU_REGION_SIZE_2GB      ((uint8_t)0x1EU) 
N#define   MPU_REGION_SIZE_4GB      ((uint8_t)0x1FU)
N/**                                
N  * @}
N  */
N   
N/** @defgroup CORTEX_MPU_Region_Permission_Attributes CORTEX MPU Region Permission Attributes 
N  * @{
N  */
N#define  MPU_REGION_NO_ACCESS      ((uint8_t)0x00U)  
N#define  MPU_REGION_PRIV_RW        ((uint8_t)0x01U) 
N#define  MPU_REGION_PRIV_RW_URO    ((uint8_t)0x02U)  
N#define  MPU_REGION_FULL_ACCESS    ((uint8_t)0x03U)  
N#define  MPU_REGION_PRIV_RO        ((uint8_t)0x05U) 
N#define  MPU_REGION_PRIV_RO_URO    ((uint8_t)0x06U)
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_MPU_Region_Number CORTEX MPU Region Number
N  * @{
N  */
N#define  MPU_REGION_NUMBER0    ((uint8_t)0x00U)  
N#define  MPU_REGION_NUMBER1    ((uint8_t)0x01U) 
N#define  MPU_REGION_NUMBER2    ((uint8_t)0x02U)  
N#define  MPU_REGION_NUMBER3    ((uint8_t)0x03U)  
N#define  MPU_REGION_NUMBER4    ((uint8_t)0x04U) 
N#define  MPU_REGION_NUMBER5    ((uint8_t)0x05U)
N#define  MPU_REGION_NUMBER6    ((uint8_t)0x06U)
N#define  MPU_REGION_NUMBER7    ((uint8_t)0x07U)
N/**
N  * @}
N  */
N#endif /* __MPU_PRESENT */
N
N/**
N  * @}
N  */
N
N
N/* Exported Macros -----------------------------------------------------------*/
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup CORTEX_Exported_Functions
N  * @{
N  */
N  
N/** @addtogroup CORTEX_Exported_Functions_Group1
N * @{
N */
N/* Initialization and de-initialization functions *****************************/
Nvoid HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup);
Nvoid HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority);
Nvoid HAL_NVIC_EnableIRQ(IRQn_Type IRQn);
Nvoid HAL_NVIC_DisableIRQ(IRQn_Type IRQn);
Nvoid HAL_NVIC_SystemReset(void);
Nuint32_t HAL_SYSTICK_Config(uint32_t TicksNumb);
N/**
N  * @}
N  */
N
N/** @addtogroup CORTEX_Exported_Functions_Group2
N * @{
N */
N/* Peripheral Control functions ***********************************************/
N#if (__MPU_PRESENT == 1)
X#if (1 == 1)
Nvoid HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init);
N#endif /* __MPU_PRESENT */
Nuint32_t HAL_NVIC_GetPriorityGrouping(void);
Nvoid HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority);
Nuint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn);
Nvoid HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn);
Nvoid HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn);
Nuint32_t HAL_NVIC_GetActive(IRQn_Type IRQn);
Nvoid HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource);
Nvoid HAL_SYSTICK_IRQHandler(void);
Nvoid HAL_SYSTICK_Callback(void);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private types -------------------------------------------------------------*/ 
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup CORTEX_Private_Macros CORTEX Private Macros
N  * @{
N  */
N#define IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PRIORITYGROUP_0) || \
N                                       ((GROUP) == NVIC_PRIORITYGROUP_1) || \
N                                       ((GROUP) == NVIC_PRIORITYGROUP_2) || \
N                                       ((GROUP) == NVIC_PRIORITYGROUP_3) || \
N                                       ((GROUP) == NVIC_PRIORITYGROUP_4))
X#define IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PRIORITYGROUP_0) ||                                        ((GROUP) == NVIC_PRIORITYGROUP_1) ||                                        ((GROUP) == NVIC_PRIORITYGROUP_2) ||                                        ((GROUP) == NVIC_PRIORITYGROUP_3) ||                                        ((GROUP) == NVIC_PRIORITYGROUP_4))
N
N#define IS_NVIC_PREEMPTION_PRIORITY(PRIORITY)  ((PRIORITY) < 0x10U)
N
N#define IS_NVIC_SUB_PRIORITY(PRIORITY)         ((PRIORITY) < 0x10U)
N
N#define IS_NVIC_DEVICE_IRQ(IRQ)                ((IRQ) >= 0x00)
N
N#define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SYSTICK_CLKSOURCE_HCLK) || \
N                                       ((SOURCE) == SYSTICK_CLKSOURCE_HCLK_DIV8))
X#define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SYSTICK_CLKSOURCE_HCLK) ||                                        ((SOURCE) == SYSTICK_CLKSOURCE_HCLK_DIV8))
N
N#if (__MPU_PRESENT == 1)
X#if (1 == 1)
N#define IS_MPU_REGION_ENABLE(STATE) (((STATE) == MPU_REGION_ENABLE) || \
N                                     ((STATE) == MPU_REGION_DISABLE))
X#define IS_MPU_REGION_ENABLE(STATE) (((STATE) == MPU_REGION_ENABLE) ||                                      ((STATE) == MPU_REGION_DISABLE))
N
N#define IS_MPU_INSTRUCTION_ACCESS(STATE) (((STATE) == MPU_INSTRUCTION_ACCESS_ENABLE) || \
N                                          ((STATE) == MPU_INSTRUCTION_ACCESS_DISABLE))
X#define IS_MPU_INSTRUCTION_ACCESS(STATE) (((STATE) == MPU_INSTRUCTION_ACCESS_ENABLE) ||                                           ((STATE) == MPU_INSTRUCTION_ACCESS_DISABLE))
N
N#define IS_MPU_ACCESS_SHAREABLE(STATE)   (((STATE) == MPU_ACCESS_SHAREABLE) || \
N                                          ((STATE) == MPU_ACCESS_NOT_SHAREABLE))
X#define IS_MPU_ACCESS_SHAREABLE(STATE)   (((STATE) == MPU_ACCESS_SHAREABLE) ||                                           ((STATE) == MPU_ACCESS_NOT_SHAREABLE))
N
N#define IS_MPU_ACCESS_CACHEABLE(STATE)   (((STATE) == MPU_ACCESS_CACHEABLE) || \
N                                          ((STATE) == MPU_ACCESS_NOT_CACHEABLE))
X#define IS_MPU_ACCESS_CACHEABLE(STATE)   (((STATE) == MPU_ACCESS_CACHEABLE) ||                                           ((STATE) == MPU_ACCESS_NOT_CACHEABLE))
N
N#define IS_MPU_ACCESS_BUFFERABLE(STATE)   (((STATE) == MPU_ACCESS_BUFFERABLE) || \
N                                          ((STATE) == MPU_ACCESS_NOT_BUFFERABLE))
X#define IS_MPU_ACCESS_BUFFERABLE(STATE)   (((STATE) == MPU_ACCESS_BUFFERABLE) ||                                           ((STATE) == MPU_ACCESS_NOT_BUFFERABLE))
N
N#define IS_MPU_TEX_LEVEL(TYPE) (((TYPE) == MPU_TEX_LEVEL0)  || \
N                                ((TYPE) == MPU_TEX_LEVEL1)  || \
N                                ((TYPE) == MPU_TEX_LEVEL2))
X#define IS_MPU_TEX_LEVEL(TYPE) (((TYPE) == MPU_TEX_LEVEL0)  ||                                 ((TYPE) == MPU_TEX_LEVEL1)  ||                                 ((TYPE) == MPU_TEX_LEVEL2))
N
N#define IS_MPU_REGION_PERMISSION_ATTRIBUTE(TYPE) (((TYPE) == MPU_REGION_NO_ACCESS)   || \
N                                                  ((TYPE) == MPU_REGION_PRIV_RW)     || \
N                                                  ((TYPE) == MPU_REGION_PRIV_RW_URO) || \
N                                                  ((TYPE) == MPU_REGION_FULL_ACCESS) || \
N                                                  ((TYPE) == MPU_REGION_PRIV_RO)     || \
N                                                  ((TYPE) == MPU_REGION_PRIV_RO_URO))
X#define IS_MPU_REGION_PERMISSION_ATTRIBUTE(TYPE) (((TYPE) == MPU_REGION_NO_ACCESS)   ||                                                   ((TYPE) == MPU_REGION_PRIV_RW)     ||                                                   ((TYPE) == MPU_REGION_PRIV_RW_URO) ||                                                   ((TYPE) == MPU_REGION_FULL_ACCESS) ||                                                   ((TYPE) == MPU_REGION_PRIV_RO)     ||                                                   ((TYPE) == MPU_REGION_PRIV_RO_URO))
N
N#define IS_MPU_REGION_NUMBER(NUMBER)    (((NUMBER) == MPU_REGION_NUMBER0) || \
N                                         ((NUMBER) == MPU_REGION_NUMBER1) || \
N                                         ((NUMBER) == MPU_REGION_NUMBER2) || \
N                                         ((NUMBER) == MPU_REGION_NUMBER3) || \
N                                         ((NUMBER) == MPU_REGION_NUMBER4) || \
N                                         ((NUMBER) == MPU_REGION_NUMBER5) || \
N                                         ((NUMBER) == MPU_REGION_NUMBER6) || \
N                                         ((NUMBER) == MPU_REGION_NUMBER7))
X#define IS_MPU_REGION_NUMBER(NUMBER)    (((NUMBER) == MPU_REGION_NUMBER0) ||                                          ((NUMBER) == MPU_REGION_NUMBER1) ||                                          ((NUMBER) == MPU_REGION_NUMBER2) ||                                          ((NUMBER) == MPU_REGION_NUMBER3) ||                                          ((NUMBER) == MPU_REGION_NUMBER4) ||                                          ((NUMBER) == MPU_REGION_NUMBER5) ||                                          ((NUMBER) == MPU_REGION_NUMBER6) ||                                          ((NUMBER) == MPU_REGION_NUMBER7))
N
N#define IS_MPU_REGION_SIZE(SIZE)    (((SIZE) == MPU_REGION_SIZE_32B)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_64B)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_128B)  || \
N                                     ((SIZE) == MPU_REGION_SIZE_256B)  || \
N                                     ((SIZE) == MPU_REGION_SIZE_512B)  || \
N                                     ((SIZE) == MPU_REGION_SIZE_1KB)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_2KB)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_4KB)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_8KB)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_16KB)  || \
N                                     ((SIZE) == MPU_REGION_SIZE_32KB)  || \
N                                     ((SIZE) == MPU_REGION_SIZE_64KB)  || \
N                                     ((SIZE) == MPU_REGION_SIZE_128KB) || \
N                                     ((SIZE) == MPU_REGION_SIZE_256KB) || \
N                                     ((SIZE) == MPU_REGION_SIZE_512KB) || \
N                                     ((SIZE) == MPU_REGION_SIZE_1MB)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_2MB)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_4MB)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_8MB)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_16MB)  || \
N                                     ((SIZE) == MPU_REGION_SIZE_32MB)  || \
N                                     ((SIZE) == MPU_REGION_SIZE_64MB)  || \
N                                     ((SIZE) == MPU_REGION_SIZE_128MB) || \
N                                     ((SIZE) == MPU_REGION_SIZE_256MB) || \
N                                     ((SIZE) == MPU_REGION_SIZE_512MB) || \
N                                     ((SIZE) == MPU_REGION_SIZE_1GB)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_2GB)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_4GB))
X#define IS_MPU_REGION_SIZE(SIZE)    (((SIZE) == MPU_REGION_SIZE_32B)   ||                                      ((SIZE) == MPU_REGION_SIZE_64B)   ||                                      ((SIZE) == MPU_REGION_SIZE_128B)  ||                                      ((SIZE) == MPU_REGION_SIZE_256B)  ||                                      ((SIZE) == MPU_REGION_SIZE_512B)  ||                                      ((SIZE) == MPU_REGION_SIZE_1KB)   ||                                      ((SIZE) == MPU_REGION_SIZE_2KB)   ||                                      ((SIZE) == MPU_REGION_SIZE_4KB)   ||                                      ((SIZE) == MPU_REGION_SIZE_8KB)   ||                                      ((SIZE) == MPU_REGION_SIZE_16KB)  ||                                      ((SIZE) == MPU_REGION_SIZE_32KB)  ||                                      ((SIZE) == MPU_REGION_SIZE_64KB)  ||                                      ((SIZE) == MPU_REGION_SIZE_128KB) ||                                      ((SIZE) == MPU_REGION_SIZE_256KB) ||                                      ((SIZE) == MPU_REGION_SIZE_512KB) ||                                      ((SIZE) == MPU_REGION_SIZE_1MB)   ||                                      ((SIZE) == MPU_REGION_SIZE_2MB)   ||                                      ((SIZE) == MPU_REGION_SIZE_4MB)   ||                                      ((SIZE) == MPU_REGION_SIZE_8MB)   ||                                      ((SIZE) == MPU_REGION_SIZE_16MB)  ||                                      ((SIZE) == MPU_REGION_SIZE_32MB)  ||                                      ((SIZE) == MPU_REGION_SIZE_64MB)  ||                                      ((SIZE) == MPU_REGION_SIZE_128MB) ||                                      ((SIZE) == MPU_REGION_SIZE_256MB) ||                                      ((SIZE) == MPU_REGION_SIZE_512MB) ||                                      ((SIZE) == MPU_REGION_SIZE_1GB)   ||                                      ((SIZE) == MPU_REGION_SIZE_2GB)   ||                                      ((SIZE) == MPU_REGION_SIZE_4GB))
N
N#define IS_MPU_SUB_REGION_DISABLE(SUBREGION)  ((SUBREGION) < (uint16_t)0x00FFU)
N#endif /* __MPU_PRESENT */
N
N/**                                                                          
N  * @}                                                                  
N  */                                                                            
N                                                                                   
N/* Private functions ---------------------------------------------------------*/   
N/** @defgroup CORTEX_Private_Functions CORTEX Private Functions
N  * @brief    CORTEX private  functions 
N  * @{
N  */
N
N#if (__MPU_PRESENT == 1)
X#if (1 == 1)
N/**
N  * @brief  Disables the MPU
N  * @retval None
N  */
N__STATIC_INLINE void HAL_MPU_Disable(void)
Xstatic __inline void HAL_MPU_Disable(void)
N{
N  /* Disable fault exceptions */
N  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHCSR &= ~(1UL << 16U);
N  
N  /* Disable the MPU */
N  MPU->CTRL  &= ~MPU_CTRL_ENABLE_Msk;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->CTRL  &= ~(1UL );
N}
N
N/**
N  * @brief  Enables the MPU
N  * @param  MPU_Control: Specifies the control mode of the MPU during hard fault, 
N  *          NMI, FAULTMASK and privileged access to the default memory 
N  *          This parameter can be one of the following values:
N  *            @arg MPU_HFNMI_PRIVDEF_NONE
N  *            @arg MPU_HARDFAULT_NMI
N  *            @arg MPU_PRIVILEGED_DEFAULT
N  *            @arg MPU_HFNMI_PRIVDEF
N  * @retval None
N  */
N__STATIC_INLINE void HAL_MPU_Enable(uint32_t MPU_Control)
Xstatic __inline void HAL_MPU_Enable(uint32_t MPU_Control)
N{
N  /* Enable the MPU */
N  MPU->CTRL   = MPU_Control | MPU_CTRL_ENABLE_Msk;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->CTRL   = MPU_Control | (1UL );
N  
N  /* Enable fault exceptions */
N  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHCSR |= (1UL << 16U);
N}
N#endif /* __MPU_PRESENT */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_CORTEX_H */
N 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 259 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_CORTEX_MODULE_ENABLED */
N
N#ifdef HAL_ADC_MODULE_ENABLED
N  #include "stm32f7xx_hal_adc.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_adc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_adc.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of ADC HAL extension module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_ADC_H
N#define __STM32F7xx_ADC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup ADC
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup ADC_Exported_Types ADC Exported Types
N  * @{
N  */
N
N/** 
N  * @brief  Structure definition of ADC and regular group initialization 
N  * @note   Parameters of this structure are shared within 2 scopes:
N  *          - Scope entire ADC (affects regular and injected groups): ClockPrescaler, Resolution, ScanConvMode, DataAlign, ScanConvMode, EOCSelection, LowPowerAutoWait, LowPowerAutoPowerOff, ChannelsBank.
N  *          - Scope regular group: ContinuousConvMode, NbrOfConversion, DiscontinuousConvMode, NbrOfDiscConversion, ExternalTrigConvEdge, ExternalTrigConv.
N  * @note   The setting of these parameters with function HAL_ADC_Init() is conditioned to ADC state.
N  *         ADC state can be either:
N  *          - For all parameters: ADC disabled
N  *          - For all parameters except 'Resolution', 'ScanConvMode', 'DiscontinuousConvMode', 'NbrOfDiscConversion' : ADC enabled without conversion on going on regular group.
N  *          - For parameters 'ExternalTrigConv' and 'ExternalTrigConvEdge': ADC enabled, even with conversion on going.
N  *         If ADC is not in the appropriate state to modify some parameters, these parameters setting is bypassed
N  *         without error reporting (as it can be the expected behaviour in case of intended action to update another parameter (which fullfills the ADC state condition) on the fly).
N  */
Ntypedef struct
N{
N  uint32_t ClockPrescaler;        /*!< Select ADC clock prescaler. The clock is common for 
N                                       all the ADCs.
N                                       This parameter can be a value of @ref ADC_ClockPrescaler */
N  uint32_t Resolution;            /*!< Configures the ADC resolution.
N                                       This parameter can be a value of @ref ADC_Resolution */
N  uint32_t DataAlign;             /*!< Specifies ADC data alignment to right (MSB on register bit 11 and LSB on register bit 0) (default setting)
N                                       or to left (if regular group: MSB on register bit 15 and LSB on register bit 4, if injected group (MSB kept as signed value due to potential negative value after offset application): MSB on register bit 14 and LSB on register bit 3).
N                                       This parameter can be a value of @ref ADC_Data_Align */
N  uint32_t ScanConvMode;          /*!< Configures the sequencer of regular and injected groups.
N                                       This parameter can be associated to parameter 'DiscontinuousConvMode' to have main sequence subdivided in successive parts.
N                                       If disabled: Conversion is performed in single mode (one channel converted, the one defined in rank 1).
N                                                    Parameters 'NbrOfConversion' and 'InjectedNbrOfConversion' are discarded (equivalent to set to 1).
N                                       If enabled:  Conversions are performed in sequence mode (multiple ranks defined by 'NbrOfConversion'/'InjectedNbrOfConversion' and each channel rank).
N                                                    Scan direction is upward: from rank1 to rank 'n'.
N                                       This parameter can be set to ENABLE or DISABLE */
N  uint32_t EOCSelection;          /*!< Specifies what EOC (End Of Conversion) flag is used for conversion by polling and interruption: end of conversion of each rank or complete sequence.
N                                       This parameter can be a value of @ref ADC_EOCSelection.
N                                       Note: For injected group, end of conversion (flag&IT) is raised only at the end of the sequence.
N                                             Therefore, if end of conversion is set to end of each conversion, injected group should not be used with interruption (HAL_ADCEx_InjectedStart_IT)
N                                             or polling (HAL_ADCEx_InjectedStart and HAL_ADCEx_InjectedPollForConversion). By the way, polling is still possible since driver will use an estimated timing for end of injected conversion.
N                                       Note: If overrun feature is intended to be used, use ADC in mode 'interruption' (function HAL_ADC_Start_IT() ) with parameter EOCSelection set to end of each conversion or in mode 'transfer by DMA' (function HAL_ADC_Start_DMA()).
N                                             If overrun feature is intended to be bypassed, use ADC in mode 'polling' or 'interruption' with parameter EOCSelection must be set to end of sequence */
N  uint32_t ContinuousConvMode;    /*!< Specifies whether the conversion is performed in single mode (one conversion) or continuous mode for regular group,
N                                       after the selected trigger occurred (software start or external trigger).
N                                       This parameter can be set to ENABLE or DISABLE. */
N  uint32_t NbrOfConversion;       /*!< Specifies the number of ranks that will be converted within the regular group sequencer.
N                                       To use regular group sequencer and convert several ranks, parameter 'ScanConvMode' must be enabled.
N                                       This parameter must be a number between Min_Data = 1 and Max_Data = 16. */
N  uint32_t DiscontinuousConvMode; /*!< Specifies whether the conversions sequence of regular group is performed in Complete-sequence/Discontinuous-sequence (main sequence subdivided in successive parts).
N                                       Discontinuous mode is used only if sequencer is enabled (parameter 'ScanConvMode'). If sequencer is disabled, this parameter is discarded.
N                                       Discontinuous mode can be enabled only if continuous mode is disabled. If continuous mode is enabled, this parameter setting is discarded.
N                                       This parameter can be set to ENABLE or DISABLE. */
N  uint32_t NbrOfDiscConversion;   /*!< Specifies the number of discontinuous conversions in which the  main sequence of regular group (parameter NbrOfConversion) will be subdivided.
N                                       If parameter 'DiscontinuousConvMode' is disabled, this parameter is discarded.
N                                       This parameter must be a number between Min_Data = 1 and Max_Data = 8. */
N  uint32_t ExternalTrigConv;      /*!< Selects the external event used to trigger the conversion start of regular group.
N                                       If set to ADC_SOFTWARE_START, external triggers are disabled.
N                                       If set to external trigger source, triggering is on event rising edge by default.
N                                       This parameter can be a value of @ref ADC_External_trigger_Source_Regular */
N  uint32_t ExternalTrigConvEdge;  /*!< Selects the external trigger edge of regular group.
N                                       If trigger is set to ADC_SOFTWARE_START, this parameter is discarded.
N                                       This parameter can be a value of @ref ADC_External_trigger_edge_Regular */
N  uint32_t DMAContinuousRequests; /*!< Specifies whether the DMA requests are performed in one shot mode (DMA transfer stop when number of conversions is reached)
N                                       or in Continuous mode (DMA transfer unlimited, whatever number of conversions).
N                                       Note: In continuous mode, DMA must be configured in circular mode. Otherwise an overrun will be triggered when DMA buffer maximum pointer is reached.
N                                       Note: This parameter must be modified when no conversion is on going on both regular and injected groups (ADC disabled, or ADC enabled without continuous mode or external trigger that could launch a conversion).
N                                       This parameter can be set to ENABLE or DISABLE. */
N}ADC_InitTypeDef;
N
N
N
N/** 
N  * @brief  Structure definition of ADC channel for regular group   
N  * @note   The setting of these parameters with function HAL_ADC_ConfigChannel() is conditioned to ADC state.
N  *         ADC can be either disabled or enabled without conversion on going on regular group.
N  */ 
Ntypedef struct 
N{
N  uint32_t Channel;                /*!< Specifies the channel to configure into ADC regular group.
N                                        This parameter can be a value of @ref ADC_channels */
N  uint32_t Rank;                   /*!< Specifies the rank in the regular group sequencer.
N                                        This parameter must be a number between Min_Data = 1 and Max_Data = 16 */
N  uint32_t SamplingTime;           /*!< Sampling time value to be set for the selected channel.
N                                        Unit: ADC clock cycles
N                                        Conversion time is the addition of sampling time and processing time (12 ADC clock cycles at ADC resolution 12 bits, 11 cycles at 10 bits, 9 cycles at 8 bits, 7 cycles at 6 bits).
N                                        This parameter can be a value of @ref ADC_sampling_times
N                                        Caution: This parameter updates the parameter property of the channel, that can be used into regular and/or injected groups.
N                                                 If this same channel has been previously configured in the other group (regular/injected), it will be updated to last setting.
N                                        Note: In case of usage of internal measurement channels (VrefInt/Vbat/TempSensor),
N                                              sampling time constraints must be respected (sampling time can be adjusted in function of ADC clock frequency and sampling time setting)
N                                              Refer to device datasheet for timings values, parameters TS_vrefint, TS_temp (values rough order: 4us min). */
N  uint32_t Offset;                 /*!< Reserved for future use, can be set to 0 */
N}ADC_ChannelConfTypeDef;
N
N/** 
N  * @brief ADC Configuration multi-mode structure definition  
N  */ 
Ntypedef struct
N{
N  uint32_t WatchdogMode;      /*!< Configures the ADC analog watchdog mode.
N                                   This parameter can be a value of @ref ADC_analog_watchdog_selection */
N  uint32_t HighThreshold;     /*!< Configures the ADC analog watchdog High threshold value.
N                                   This parameter must be a 12-bit value. */     
N  uint32_t LowThreshold;      /*!< Configures the ADC analog watchdog High threshold value.
N                                   This parameter must be a 12-bit value. */
N  uint32_t Channel;           /*!< Configures ADC channel for the analog watchdog. 
N                                   This parameter has an effect only if watchdog mode is configured on single channel 
N                                   This parameter can be a value of @ref ADC_channels */      
N  uint32_t ITMode;            /*!< Specifies whether the analog watchdog is configured
N                                   is interrupt mode or in polling mode.
N                                   This parameter can be set to ENABLE or DISABLE */
N  uint32_t WatchdogNumber;    /*!< Reserved for future use, can be set to 0 */
N}ADC_AnalogWDGConfTypeDef;
N
N/** 
N  * @brief  HAL ADC state machine: ADC states definition (bitfields)
N  */ 
N/* States of ADC global scope */
N#define HAL_ADC_STATE_RESET             ((uint32_t)0x00000000U)    /*!< ADC not yet initialized or disabled */
N#define HAL_ADC_STATE_READY             ((uint32_t)0x00000001U)    /*!< ADC peripheral ready for use */
N#define HAL_ADC_STATE_BUSY_INTERNAL     ((uint32_t)0x00000002U)    /*!< ADC is busy to internal process (initialization, calibration) */
N#define HAL_ADC_STATE_TIMEOUT           ((uint32_t)0x00000004U)    /*!< TimeOut occurrence */
N
N/* States of ADC errors */
N#define HAL_ADC_STATE_ERROR_INTERNAL    ((uint32_t)0x00000010U)    /*!< Internal error occurrence */
N#define HAL_ADC_STATE_ERROR_CONFIG      ((uint32_t)0x00000020U)    /*!< Configuration error occurrence */
N#define HAL_ADC_STATE_ERROR_DMA         ((uint32_t)0x00000040U)    /*!< DMA error occurrence */
N
N/* States of ADC group regular */
N#define HAL_ADC_STATE_REG_BUSY          ((uint32_t)0x00000100U)    /*!< A conversion on group regular is ongoing or can occur (either by continuous mode,
N                                                                       external trigger, low power auto power-on (if feature available), multimode ADC master control (if feature available)) */
N#define HAL_ADC_STATE_REG_EOC           ((uint32_t)0x00000200U)    /*!< Conversion data available on group regular */
N#define HAL_ADC_STATE_REG_OVR           ((uint32_t)0x00000400U)    /*!< Overrun occurrence */
N
N/* States of ADC group injected */
N#define HAL_ADC_STATE_INJ_BUSY          ((uint32_t)0x00001000U)    /*!< A conversion on group injected is ongoing or can occur (either by auto-injection mode,
N                                                                       external trigger, low power auto power-on (if feature available), multimode ADC master control (if feature available)) */
N#define HAL_ADC_STATE_INJ_EOC           ((uint32_t)0x00002000U)    /*!< Conversion data available on group injected */
N
N/* States of ADC analog watchdogs */
N#define HAL_ADC_STATE_AWD1              ((uint32_t)0x00010000U)    /*!< Out-of-window occurrence of analog watchdog 1 */
N#define HAL_ADC_STATE_AWD2              ((uint32_t)0x00020000U)    /*!< Not available on STM32F7 device: Out-of-window occurrence of analog watchdog 2 */
N#define HAL_ADC_STATE_AWD3              ((uint32_t)0x00040000U)    /*!< Not available on STM32F7 device: Out-of-window occurrence of analog watchdog 3 */
N
N/* States of ADC multi-mode */
N#define HAL_ADC_STATE_MULTIMODE_SLAVE   ((uint32_t)0x00100000U)    /*!< Not available on STM32F7 device: ADC in multimode slave state, controlled by another ADC master ( */
N
N
N/** 
N  * @brief  ADC handle Structure definition
N  */ 
Ntypedef struct
N{
N  ADC_TypeDef                   *Instance;                   /*!< Register base address */
N
N  ADC_InitTypeDef               Init;                        /*!< ADC required parameters */
N
N  __IO uint32_t                 NbrOfCurrentConversionRank;  /*!< ADC number of current conversion rank */
X  volatile uint32_t                 NbrOfCurrentConversionRank;   
N
N  DMA_HandleTypeDef             *DMA_Handle;                 /*!< Pointer DMA Handler */
N
N  HAL_LockTypeDef               Lock;                        /*!< ADC locking object */
N
N  __IO uint32_t                 State;                       /*!< ADC communication state */
X  volatile uint32_t                 State;                        
N
N  __IO uint32_t                 ErrorCode;                   /*!< ADC Error code */
X  volatile uint32_t                 ErrorCode;                    
N}ADC_HandleTypeDef;
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup ADC_Exported_Constants ADC Exported Constants
N  * @{
N  */
N
N/** @defgroup ADC_Error_Code ADC Error Code
N  * @{
N  */
N#define HAL_ADC_ERROR_NONE        ((uint32_t)0x00U)   /*!< No error                                              */
N#define HAL_ADC_ERROR_INTERNAL    ((uint32_t)0x01U)   /*!< ADC IP internal error: if problem of clocking, 
N                                                          enable/disable, erroneous state                       */
N#define HAL_ADC_ERROR_OVR         ((uint32_t)0x02U)   /*!< Overrun error                                         */
N#define HAL_ADC_ERROR_DMA         ((uint32_t)0x04U)   /*!< DMA transfer error                                    */
N/**
N  * @}
N  */
N
N
N/** @defgroup ADC_ClockPrescaler  ADC Clock Prescaler
N  * @{
N  */ 
N#define ADC_CLOCK_SYNC_PCLK_DIV2    ((uint32_t)0x00000000U)
N#define ADC_CLOCK_SYNC_PCLK_DIV4    ((uint32_t)ADC_CCR_ADCPRE_0)
N#define ADC_CLOCK_SYNC_PCLK_DIV6    ((uint32_t)ADC_CCR_ADCPRE_1)
N#define ADC_CLOCK_SYNC_PCLK_DIV8    ((uint32_t)ADC_CCR_ADCPRE)
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_delay_between_2_sampling_phases ADC Delay Between 2 Sampling Phases
N  * @{
N  */ 
N#define ADC_TWOSAMPLINGDELAY_5CYCLES    ((uint32_t)0x00000000U)
N#define ADC_TWOSAMPLINGDELAY_6CYCLES    ((uint32_t)ADC_CCR_DELAY_0)
N#define ADC_TWOSAMPLINGDELAY_7CYCLES    ((uint32_t)ADC_CCR_DELAY_1)
N#define ADC_TWOSAMPLINGDELAY_8CYCLES    ((uint32_t)(ADC_CCR_DELAY_1 | ADC_CCR_DELAY_0))
N#define ADC_TWOSAMPLINGDELAY_9CYCLES    ((uint32_t)ADC_CCR_DELAY_2)
N#define ADC_TWOSAMPLINGDELAY_10CYCLES   ((uint32_t)(ADC_CCR_DELAY_2 | ADC_CCR_DELAY_0))
N#define ADC_TWOSAMPLINGDELAY_11CYCLES   ((uint32_t)(ADC_CCR_DELAY_2 | ADC_CCR_DELAY_1))
N#define ADC_TWOSAMPLINGDELAY_12CYCLES   ((uint32_t)(ADC_CCR_DELAY_2 | ADC_CCR_DELAY_1 | ADC_CCR_DELAY_0))
N#define ADC_TWOSAMPLINGDELAY_13CYCLES   ((uint32_t)ADC_CCR_DELAY_3)
N#define ADC_TWOSAMPLINGDELAY_14CYCLES   ((uint32_t)(ADC_CCR_DELAY_3 | ADC_CCR_DELAY_0))
N#define ADC_TWOSAMPLINGDELAY_15CYCLES   ((uint32_t)(ADC_CCR_DELAY_3 | ADC_CCR_DELAY_1))
N#define ADC_TWOSAMPLINGDELAY_16CYCLES   ((uint32_t)(ADC_CCR_DELAY_3 | ADC_CCR_DELAY_1 | ADC_CCR_DELAY_0))
N#define ADC_TWOSAMPLINGDELAY_17CYCLES   ((uint32_t)(ADC_CCR_DELAY_3 | ADC_CCR_DELAY_2))
N#define ADC_TWOSAMPLINGDELAY_18CYCLES   ((uint32_t)(ADC_CCR_DELAY_3 | ADC_CCR_DELAY_2 | ADC_CCR_DELAY_0))
N#define ADC_TWOSAMPLINGDELAY_19CYCLES   ((uint32_t)(ADC_CCR_DELAY_3 | ADC_CCR_DELAY_2 | ADC_CCR_DELAY_1))
N#define ADC_TWOSAMPLINGDELAY_20CYCLES   ((uint32_t)ADC_CCR_DELAY)
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_Resolution ADC Resolution
N  * @{
N  */ 
N#define ADC_RESOLUTION_12B  ((uint32_t)0x00000000U)
N#define ADC_RESOLUTION_10B  ((uint32_t)ADC_CR1_RES_0)
N#define ADC_RESOLUTION_8B   ((uint32_t)ADC_CR1_RES_1)
N#define ADC_RESOLUTION_6B   ((uint32_t)ADC_CR1_RES)
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_External_trigger_edge_Regular ADC External Trigger Edge Regular
N  * @{
N  */ 
N#define ADC_EXTERNALTRIGCONVEDGE_NONE           ((uint32_t)0x00000000U)
N#define ADC_EXTERNALTRIGCONVEDGE_RISING         ((uint32_t)ADC_CR2_EXTEN_0)
N#define ADC_EXTERNALTRIGCONVEDGE_FALLING        ((uint32_t)ADC_CR2_EXTEN_1)
N#define ADC_EXTERNALTRIGCONVEDGE_RISINGFALLING  ((uint32_t)ADC_CR2_EXTEN)
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_External_trigger_Source_Regular ADC External Trigger Source Regular
N  * @{
N  */
N/* Note: Parameter ADC_SOFTWARE_START is a software parameter used for        */
N/*       compatibility with other STM32 devices.                              */
N
N
N#define ADC_EXTERNALTRIGCONV_T1_CC1    ((uint32_t)0x00000000U)
N#define ADC_EXTERNALTRIGCONV_T1_CC2    ((uint32_t)ADC_CR2_EXTSEL_0)
N#define ADC_EXTERNALTRIGCONV_T1_CC3    ((uint32_t)ADC_CR2_EXTSEL_1)
N#define ADC_EXTERNALTRIGCONV_T2_CC2    ((uint32_t)(ADC_CR2_EXTSEL_1 | ADC_CR2_EXTSEL_0))
N#define ADC_EXTERNALTRIGCONV_T5_TRGO   ((uint32_t)ADC_CR2_EXTSEL_2)
N#define ADC_EXTERNALTRIGCONV_T4_CC4    ((uint32_t)(ADC_CR2_EXTSEL_2 | ADC_CR2_EXTSEL_0))
N#define ADC_EXTERNALTRIGCONV_T3_CC4    ((uint32_t)(ADC_CR2_EXTSEL_2 | ADC_CR2_EXTSEL_1))
N#define ADC_EXTERNALTRIGCONV_T8_TRGO   ((uint32_t)(ADC_CR2_EXTSEL_2 | ADC_CR2_EXTSEL_1 | ADC_CR2_EXTSEL_0))
N#define ADC_EXTERNALTRIGCONV_T8_TRGO2  ((uint32_t)ADC_CR2_EXTSEL_3)
N#define ADC_EXTERNALTRIGCONV_T1_TRGO   ((uint32_t)(ADC_CR2_EXTSEL_3 | ADC_CR2_EXTSEL_0))
N#define ADC_EXTERNALTRIGCONV_T1_TRGO2  ((uint32_t)(ADC_CR2_EXTSEL_3 | ADC_CR2_EXTSEL_1))
N#define ADC_EXTERNALTRIGCONV_T2_TRGO   ((uint32_t)(ADC_CR2_EXTSEL_3 | ADC_CR2_EXTSEL_1 | ADC_CR2_EXTSEL_0))
N#define ADC_EXTERNALTRIGCONV_T4_TRGO   ((uint32_t)(ADC_CR2_EXTSEL_3 | ADC_CR2_EXTSEL_2))
N#define ADC_EXTERNALTRIGCONV_T6_TRGO   ((uint32_t)(ADC_CR2_EXTSEL_3 | ADC_CR2_EXTSEL_2 | ADC_CR2_EXTSEL_0))
N
N#define ADC_EXTERNALTRIGCONV_EXT_IT11  ((uint32_t)ADC_CR2_EXTSEL)
N#define ADC_SOFTWARE_START             ((uint32_t)ADC_CR2_EXTSEL + 1)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_Data_Align ADC Data Align
N  * @{
N  */ 
N#define ADC_DATAALIGN_RIGHT      ((uint32_t)0x00000000U)
N#define ADC_DATAALIGN_LEFT       ((uint32_t)ADC_CR2_ALIGN)
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_channels ADC Common Channels
N  * @{
N  */ 
N#define ADC_CHANNEL_0           ((uint32_t)0x00000000U)
N#define ADC_CHANNEL_1           ((uint32_t)ADC_CR1_AWDCH_0)
N#define ADC_CHANNEL_2           ((uint32_t)ADC_CR1_AWDCH_1)
N#define ADC_CHANNEL_3           ((uint32_t)(ADC_CR1_AWDCH_1 | ADC_CR1_AWDCH_0))
N#define ADC_CHANNEL_4           ((uint32_t)ADC_CR1_AWDCH_2)
N#define ADC_CHANNEL_5           ((uint32_t)(ADC_CR1_AWDCH_2 | ADC_CR1_AWDCH_0))
N#define ADC_CHANNEL_6           ((uint32_t)(ADC_CR1_AWDCH_2 | ADC_CR1_AWDCH_1))
N#define ADC_CHANNEL_7           ((uint32_t)(ADC_CR1_AWDCH_2 | ADC_CR1_AWDCH_1 | ADC_CR1_AWDCH_0))
N#define ADC_CHANNEL_8           ((uint32_t)ADC_CR1_AWDCH_3)
N#define ADC_CHANNEL_9           ((uint32_t)(ADC_CR1_AWDCH_3 | ADC_CR1_AWDCH_0))
N#define ADC_CHANNEL_10          ((uint32_t)(ADC_CR1_AWDCH_3 | ADC_CR1_AWDCH_1))
N#define ADC_CHANNEL_11          ((uint32_t)(ADC_CR1_AWDCH_3 | ADC_CR1_AWDCH_1 | ADC_CR1_AWDCH_0))
N#define ADC_CHANNEL_12          ((uint32_t)(ADC_CR1_AWDCH_3 | ADC_CR1_AWDCH_2))
N#define ADC_CHANNEL_13          ((uint32_t)(ADC_CR1_AWDCH_3 | ADC_CR1_AWDCH_2 | ADC_CR1_AWDCH_0))
N#define ADC_CHANNEL_14          ((uint32_t)(ADC_CR1_AWDCH_3 | ADC_CR1_AWDCH_2 | ADC_CR1_AWDCH_1))
N#define ADC_CHANNEL_15          ((uint32_t)(ADC_CR1_AWDCH_3 | ADC_CR1_AWDCH_2 | ADC_CR1_AWDCH_1 | ADC_CR1_AWDCH_0))
N#define ADC_CHANNEL_16          ((uint32_t)ADC_CR1_AWDCH_4)
N#define ADC_CHANNEL_17          ((uint32_t)(ADC_CR1_AWDCH_4 | ADC_CR1_AWDCH_0))
N#define ADC_CHANNEL_18          ((uint32_t)(ADC_CR1_AWDCH_4 | ADC_CR1_AWDCH_1))
N
N#define ADC_CHANNEL_VREFINT     ((uint32_t)ADC_CHANNEL_17)
N#define ADC_CHANNEL_VBAT        ((uint32_t)ADC_CHANNEL_18)
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_sampling_times ADC Sampling Times
N  * @{
N  */ 
N#define ADC_SAMPLETIME_3CYCLES    ((uint32_t)0x00000000U)
N#define ADC_SAMPLETIME_15CYCLES   ((uint32_t)ADC_SMPR1_SMP10_0)
N#define ADC_SAMPLETIME_28CYCLES   ((uint32_t)ADC_SMPR1_SMP10_1)
N#define ADC_SAMPLETIME_56CYCLES   ((uint32_t)(ADC_SMPR1_SMP10_1 | ADC_SMPR1_SMP10_0))
N#define ADC_SAMPLETIME_84CYCLES   ((uint32_t)ADC_SMPR1_SMP10_2)
N#define ADC_SAMPLETIME_112CYCLES  ((uint32_t)(ADC_SMPR1_SMP10_2 | ADC_SMPR1_SMP10_0))
N#define ADC_SAMPLETIME_144CYCLES  ((uint32_t)(ADC_SMPR1_SMP10_2 | ADC_SMPR1_SMP10_1))
N#define ADC_SAMPLETIME_480CYCLES  ((uint32_t)ADC_SMPR1_SMP10)
N/**
N  * @}
N  */ 
N
N  /** @defgroup ADC_EOCSelection ADC EOC Selection
N  * @{
N  */ 
N#define ADC_EOC_SEQ_CONV              ((uint32_t)0x00000000U)
N#define ADC_EOC_SINGLE_CONV           ((uint32_t)0x00000001U)
N#define ADC_EOC_SINGLE_SEQ_CONV       ((uint32_t)0x00000002U)  /*!< reserved for future use */
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_Event_type ADC Event Type
N  * @{
N  */ 
N#define ADC_AWD_EVENT             ((uint32_t)ADC_FLAG_AWD)
N#define ADC_OVR_EVENT             ((uint32_t)ADC_FLAG_OVR)
N/**
N  * @}
N  */
N
N/** @defgroup ADC_analog_watchdog_selection ADC Analog Watchdog Selection
N  * @{
N  */ 
N#define ADC_ANALOGWATCHDOG_SINGLE_REG         ((uint32_t)(ADC_CR1_AWDSGL | ADC_CR1_AWDEN))
N#define ADC_ANALOGWATCHDOG_SINGLE_INJEC       ((uint32_t)(ADC_CR1_AWDSGL | ADC_CR1_JAWDEN))
N#define ADC_ANALOGWATCHDOG_SINGLE_REGINJEC    ((uint32_t)(ADC_CR1_AWDSGL | ADC_CR1_AWDEN | ADC_CR1_JAWDEN))
N#define ADC_ANALOGWATCHDOG_ALL_REG            ((uint32_t)ADC_CR1_AWDEN)
N#define ADC_ANALOGWATCHDOG_ALL_INJEC          ((uint32_t)ADC_CR1_JAWDEN)
N#define ADC_ANALOGWATCHDOG_ALL_REGINJEC       ((uint32_t)(ADC_CR1_AWDEN | ADC_CR1_JAWDEN))
N#define ADC_ANALOGWATCHDOG_NONE               ((uint32_t)0x00000000U)
N/**
N  * @}
N  */ 
N    
N/** @defgroup ADC_interrupts_definition ADC Interrupts Definition
N  * @{
N  */ 
N#define ADC_IT_EOC      ((uint32_t)ADC_CR1_EOCIE)  
N#define ADC_IT_AWD      ((uint32_t)ADC_CR1_AWDIE) 
N#define ADC_IT_JEOC     ((uint32_t)ADC_CR1_JEOCIE)
N#define ADC_IT_OVR      ((uint32_t)ADC_CR1_OVRIE) 
N/**
N  * @}
N  */ 
N    
N/** @defgroup ADC_flags_definition ADC Flags Definition
N  * @{
N  */ 
N#define ADC_FLAG_AWD    ((uint32_t)ADC_SR_AWD)
N#define ADC_FLAG_EOC    ((uint32_t)ADC_SR_EOC)
N#define ADC_FLAG_JEOC   ((uint32_t)ADC_SR_JEOC)
N#define ADC_FLAG_JSTRT  ((uint32_t)ADC_SR_JSTRT)
N#define ADC_FLAG_STRT   ((uint32_t)ADC_SR_STRT)
N#define ADC_FLAG_OVR    ((uint32_t)ADC_SR_OVR)
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_channels_type ADC Channels Type
N  * @{
N  */ 
N#define ADC_ALL_CHANNELS      ((uint32_t)0x00000001U)
N#define ADC_REGULAR_CHANNELS  ((uint32_t)0x00000002U) /*!< reserved for future use */
N#define ADC_INJECTED_CHANNELS ((uint32_t)0x00000003U) /*!< reserved for future use */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup ADC_Exported_Macros ADC Exported Macros
N  * @{
N  */
N	
N/** @brief Reset ADC handle state
N  * @param  __HANDLE__: ADC handle
N  * @retval None
N  */
N#define __HAL_ADC_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_ADC_STATE_RESET)
N
N/**
N  * @brief  Enable the ADC peripheral.
N  * @param  __HANDLE__: ADC handle
N  * @retval None
N  */
N#define __HAL_ADC_ENABLE(__HANDLE__) ((__HANDLE__)->Instance->CR2 |=  ADC_CR2_ADON)
N
N/**
N  * @brief  Disable the ADC peripheral.
N  * @param  __HANDLE__: ADC handle
N  * @retval None
N  */
N#define __HAL_ADC_DISABLE(__HANDLE__) ((__HANDLE__)->Instance->CR2 &=  ~ADC_CR2_ADON)
N
N/**
N  * @brief  Enable the ADC end of conversion interrupt.
N  * @param  __HANDLE__: specifies the ADC Handle.
N  * @param  __INTERRUPT__: ADC Interrupt.
N  * @retval None
N  */
N#define __HAL_ADC_ENABLE_IT(__HANDLE__, __INTERRUPT__) (((__HANDLE__)->Instance->CR1) |= (__INTERRUPT__))
N
N/**
N  * @brief  Disable the ADC end of conversion interrupt.
N  * @param  __HANDLE__: specifies the ADC Handle.
N  * @param  __INTERRUPT__: ADC interrupt.
N  * @retval None
N  */
N#define __HAL_ADC_DISABLE_IT(__HANDLE__, __INTERRUPT__) (((__HANDLE__)->Instance->CR1) &= ~(__INTERRUPT__))
N
N/** @brief  Check if the specified ADC interrupt source is enabled or disabled.
N  * @param  __HANDLE__: specifies the ADC Handle.
N  * @param  __INTERRUPT__: specifies the ADC interrupt source to check.
N  * @retval The new state of __IT__ (TRUE or FALSE).
N  */
N#define __HAL_ADC_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)  (((__HANDLE__)->Instance->CR1 & (__INTERRUPT__)) == (__INTERRUPT__))
N
N/**
N  * @brief  Clear the ADC's pending flags.
N  * @param  __HANDLE__: specifies the ADC Handle.
N  * @param  __FLAG__: ADC flag.
N  * @retval None
N  */
N#define __HAL_ADC_CLEAR_FLAG(__HANDLE__, __FLAG__) (((__HANDLE__)->Instance->SR) = ~(__FLAG__))
N
N/**
N  * @brief  Get the selected ADC's flag status.
N  * @param  __HANDLE__: specifies the ADC Handle.
N  * @param  __FLAG__: ADC flag.
N  * @retval None
N  */
N#define __HAL_ADC_GET_FLAG(__HANDLE__, __FLAG__) ((((__HANDLE__)->Instance->SR) & (__FLAG__)) == (__FLAG__))
N
N/**
N  * @}
N  */
N
N/* Include ADC HAL Extension module */
N#include "stm32f7xx_hal_adc_ex.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_adc_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_adc.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of ADC HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_ADC_EX_H
N#define __STM32F7xx_ADC_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup ADCEx
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup ADCEx_Exported_Types ADC Exported Types
N  * @{
N  */
N   
N/** 
N  * @brief  ADC Configuration injected Channel structure definition
N  * @note   Parameters of this structure are shared within 2 scopes:
N  *          - Scope channel: InjectedChannel, InjectedRank, InjectedSamplingTime, InjectedOffset
N  *          - Scope injected group (affects all channels of injected group): InjectedNbrOfConversion, InjectedDiscontinuousConvMode,
N  *            AutoInjectedConv, ExternalTrigInjecConvEdge, ExternalTrigInjecConv.
N  * @note   The setting of these parameters with function HAL_ADCEx_InjectedConfigChannel() is conditioned to ADC state.
N  *         ADC state can be either:
N  *          - For all parameters: ADC disabled
N  *          - For all except parameters 'InjectedDiscontinuousConvMode' and 'AutoInjectedConv': ADC enabled without conversion on going on injected group.
N  *          - For parameters 'ExternalTrigInjecConv' and 'ExternalTrigInjecConvEdge': ADC enabled, even with conversion on going on injected group.
N  */
Ntypedef struct 
N{
N  uint32_t InjectedChannel;               /*!< Selection of ADC channel to configure
N                                               This parameter can be a value of @ref ADC_channels
N                                               Note: Depending on devices, some channels may not be available on package pins. Refer to device datasheet for channels availability. */
N  uint32_t InjectedRank;                  /*!< Rank in the injected group sequencer
N                                               This parameter must be a value of @ref ADCEx_injected_rank
N                                               Note: In case of need to disable a channel or change order of conversion sequencer, rank containing a previous channel setting can be overwritten by the new channel setting (or parameter number of conversions can be adjusted) */
N  uint32_t InjectedSamplingTime;          /*!< Sampling time value to be set for the selected channel.
N                                               Unit: ADC clock cycles
N                                               Conversion time is the addition of sampling time and processing time (12 ADC clock cycles at ADC resolution 12 bits, 11 cycles at 10 bits, 9 cycles at 8 bits, 7 cycles at 6 bits).
N                                               This parameter can be a value of @ref ADC_sampling_times
N                                               Caution: This parameter updates the parameter property of the channel, that can be used into regular and/or injected groups.
N                                                        If this same channel has been previously configured in the other group (regular/injected), it will be updated to last setting.
N                                               Note: In case of usage of internal measurement channels (VrefInt/Vbat/TempSensor),
N                                                     sampling time constraints must be respected (sampling time can be adjusted in function of ADC clock frequency and sampling time setting)
N                                                     Refer to device datasheet for timings values, parameters TS_vrefint, TS_temp (values rough order: 4us min). */
N  uint32_t InjectedOffset;                /*!< Defines the offset to be subtracted from the raw converted data (for channels set on injected group only).
N                                               Offset value must be a positive number.
N                                               Depending of ADC resolution selected (12, 10, 8 or 6 bits),
N                                               this parameter must be a number between Min_Data = 0x000 and Max_Data = 0xFFF, 0x3FF, 0xFF or 0x3F respectively. */
N  uint32_t InjectedNbrOfConversion;       /*!< Specifies the number of ranks that will be converted within the injected group sequencer.
N                                               To use the injected group sequencer and convert several ranks, parameter 'ScanConvMode' must be enabled.
N                                               This parameter must be a number between Min_Data = 1 and Max_Data = 4.
N                                               Caution: this setting impacts the entire injected group. Therefore, call of HAL_ADCEx_InjectedConfigChannel() to 
N                                                        configure a channel on injected group can impact the configuration of other channels previously set. */
N  uint32_t InjectedDiscontinuousConvMode; /*!< Specifies whether the conversions sequence of injected group is performed in Complete-sequence/Discontinuous-sequence (main sequence subdivided in successive parts).
N                                               Discontinuous mode is used only if sequencer is enabled (parameter 'ScanConvMode'). If sequencer is disabled, this parameter is discarded.
N                                               Discontinuous mode can be enabled only if continuous mode is disabled. If continuous mode is enabled, this parameter setting is discarded.
N                                               This parameter can be set to ENABLE or DISABLE.
N                                               Note: For injected group, number of discontinuous ranks increment is fixed to one-by-one.
N                                               Caution: this setting impacts the entire injected group. Therefore, call of HAL_ADCEx_InjectedConfigChannel() to 
N                                                        configure a channel on injected group can impact the configuration of other channels previously set. */
N  uint32_t AutoInjectedConv;              /*!< Enables or disables the selected ADC automatic injected group conversion after regular one
N                                               This parameter can be set to ENABLE or DISABLE.      
N                                               Note: To use Automatic injected conversion, discontinuous mode must be disabled ('DiscontinuousConvMode' and 'InjectedDiscontinuousConvMode' set to DISABLE)
N                                               Note: To use Automatic injected conversion, injected group external triggers must be disabled ('ExternalTrigInjecConv' set to ADC_SOFTWARE_START)
N                                               Note: In case of DMA used with regular group: if DMA configured in normal mode (single shot) JAUTO will be stopped upon DMA transfer complete.
N                                                     To maintain JAUTO always enabled, DMA must be configured in circular mode.
N                                               Caution: this setting impacts the entire injected group. Therefore, call of HAL_ADCEx_InjectedConfigChannel() to
N                                                        configure a channel on injected group can impact the configuration of other channels previously set. */
N  uint32_t ExternalTrigInjecConv;         /*!< Selects the external event used to trigger the conversion start of injected group.
N                                               If set to ADC_INJECTED_SOFTWARE_START, external triggers are disabled.
N                                               If set to external trigger source, triggering is on event rising edge.
N                                               This parameter can be a value of @ref ADCEx_External_trigger_Source_Injected
N                                               Note: This parameter must be modified when ADC is disabled (before ADC start conversion or after ADC stop conversion).
N                                                     If ADC is enabled, this parameter setting is bypassed without error reporting (as it can be the expected behaviour in case of another parameter update on the fly)
N                                               Caution: this setting impacts the entire injected group. Therefore, call of HAL_ADCEx_InjectedConfigChannel() to
N                                                        configure a channel on injected group can impact the configuration of other channels previously set. */
N  uint32_t ExternalTrigInjecConvEdge;     /*!< Selects the external trigger edge of injected group.
N                                               This parameter can be a value of @ref ADCEx_External_trigger_edge_Injected.
N                                               If trigger is set to ADC_INJECTED_SOFTWARE_START, this parameter is discarded.
N                                               Caution: this setting impacts the entire injected group. Therefore, call of HAL_ADCEx_InjectedConfigChannel() to 
N                                                        configure a channel on injected group can impact the configuration of other channels previously set. */
N}ADC_InjectionConfTypeDef; 
N/**
N  * @}
N  */
N
N/** 
N  * @brief ADC Configuration multi-mode structure definition  
N  */ 
Ntypedef struct
N{
N  uint32_t Mode;              /*!< Configures the ADC to operate in independent or multi mode. 
N                                   This parameter can be a value of @ref ADCEx_Common_mode */
N  uint32_t DMAAccessMode;     /*!< Configures the Direct memory access mode for multi ADC mode.
N                                   This parameter can be a value of @ref ADCEx_Direct_memory_access_mode_for_multi_mode */
N  uint32_t TwoSamplingDelay;  /*!< Configures the Delay between 2 sampling phases.
N                                   This parameter can be a value of @ref ADC_delay_between_2_sampling_phases */
N}ADC_MultiModeTypeDef;
N
N/**
N  * @}
N  */ 
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup ADCEx_Exported_Constants ADC Exported Constants
N  * @{
N  */
N
N/** @defgroup ADCEx_Common_mode ADC Common Mode
N  * @{
N  */
N#define ADC_MODE_INDEPENDENT                  ((uint32_t)0x00000000U)      
N#define ADC_DUALMODE_REGSIMULT_INJECSIMULT    ((uint32_t)ADC_CCR_MULTI_0)
N#define ADC_DUALMODE_REGSIMULT_ALTERTRIG      ((uint32_t)ADC_CCR_MULTI_1)
N#define ADC_DUALMODE_INJECSIMULT              ((uint32_t)(ADC_CCR_MULTI_2 | ADC_CCR_MULTI_0))
N#define ADC_DUALMODE_REGSIMULT                ((uint32_t)(ADC_CCR_MULTI_2 | ADC_CCR_MULTI_1))
N#define ADC_DUALMODE_INTERL                   ((uint32_t)(ADC_CCR_MULTI_2 | ADC_CCR_MULTI_1 | ADC_CCR_MULTI_0))
N#define ADC_DUALMODE_ALTERTRIG                ((uint32_t)(ADC_CCR_MULTI_3 | ADC_CCR_MULTI_0))
N#define ADC_TRIPLEMODE_REGSIMULT_INJECSIMULT  ((uint32_t)(ADC_CCR_MULTI_4 | ADC_CCR_MULTI_0))
N#define ADC_TRIPLEMODE_REGSIMULT_AlterTrig    ((uint32_t)(ADC_CCR_MULTI_4 | ADC_CCR_MULTI_1))
N#define ADC_TRIPLEMODE_INJECSIMULT            ((uint32_t)(ADC_CCR_MULTI_4 | ADC_CCR_MULTI_2 | ADC_CCR_MULTI_0))
N#define ADC_TRIPLEMODE_REGSIMULT              ((uint32_t)(ADC_CCR_MULTI_4 | ADC_CCR_MULTI_2 | ADC_CCR_MULTI_1))
N#define ADC_TRIPLEMODE_INTERL                 ((uint32_t)(ADC_CCR_MULTI_4 | ADC_CCR_MULTI_2 | ADC_CCR_MULTI_1 | ADC_CCR_MULTI_0))
N#define ADC_TRIPLEMODE_ALTERTRIG              ((uint32_t)(ADC_CCR_MULTI_4 | ADC_CCR_MULTI_3 | ADC_CCR_MULTI_0))
N/**
N  * @}
N  */ 
N
N/** @defgroup ADCEx_Direct_memory_access_mode_for_multi_mode ADC Direct Memory Access Mode For Multi Mode
N  * @{
N  */ 
N#define ADC_DMAACCESSMODE_DISABLED  ((uint32_t)0x00000000U)     /*!< DMA mode disabled */
N#define ADC_DMAACCESSMODE_1         ((uint32_t)ADC_CCR_DMA_0)  /*!< DMA mode 1 enabled (2 / 3 half-words one by one - 1 then 2 then 3)*/
N#define ADC_DMAACCESSMODE_2         ((uint32_t)ADC_CCR_DMA_1)  /*!< DMA mode 2 enabled (2 / 3 half-words by pairs - 2&1 then 1&3 then 3&2)*/
N#define ADC_DMAACCESSMODE_3         ((uint32_t)ADC_CCR_DMA)    /*!< DMA mode 3 enabled (2 / 3 bytes by pairs - 2&1 then 1&3 then 3&2) */
N/**
N  * @}
N  */ 
N
N/** @defgroup ADCEx_External_trigger_edge_Injected ADC External Trigger Edge Injected
N  * @{
N  */
N#define ADC_EXTERNALTRIGINJECCONVEDGE_NONE           ((uint32_t)0x00000000U)
N#define ADC_EXTERNALTRIGINJECCONVEDGE_RISING         ((uint32_t)ADC_CR2_JEXTEN_0)
N#define ADC_EXTERNALTRIGINJECCONVEDGE_FALLING        ((uint32_t)ADC_CR2_JEXTEN_1)
N#define ADC_EXTERNALTRIGINJECCONVEDGE_RISINGFALLING  ((uint32_t)ADC_CR2_JEXTEN)
N/**
N  * @}
N  */ 
N
N/** @defgroup ADCEx_External_trigger_Source_Injected ADC External Trigger Source Injected
N  * @{
N  */
N#define ADC_EXTERNALTRIGINJECCONV_T1_TRGO         ((uint32_t)0x00000000U)
N#define ADC_EXTERNALTRIGINJECCONV_T1_CC4          ((uint32_t)ADC_CR2_JEXTSEL_0)
N#define ADC_EXTERNALTRIGINJECCONV_T2_TRGO         ((uint32_t)ADC_CR2_JEXTSEL_1)
N#define ADC_EXTERNALTRIGINJECCONV_T2_CC1          ((uint32_t)(ADC_CR2_JEXTSEL_1 | ADC_CR2_JEXTSEL_0))
N#define ADC_EXTERNALTRIGINJECCONV_T3_CC4          ((uint32_t)ADC_CR2_JEXTSEL_2)
N#define ADC_EXTERNALTRIGINJECCONV_T4_TRGO         ((uint32_t)(ADC_CR2_JEXTSEL_2 | ADC_CR2_JEXTSEL_0))
N
N#define ADC_EXTERNALTRIGINJECCONV_T8_CC4          ((uint32_t)(ADC_CR2_JEXTSEL_2 | ADC_CR2_JEXTSEL_1 | ADC_CR2_JEXTSEL_0))
N#define ADC_EXTERNALTRIGINJECCONV_T1_TRGO2        ((uint32_t)ADC_CR2_JEXTSEL_3)
N#define ADC_EXTERNALTRIGINJECCONV_T8_TRGO         ((uint32_t)(ADC_CR2_JEXTSEL_3 | ADC_CR2_JEXTSEL_0))
N#define ADC_EXTERNALTRIGINJECCONV_T8_TRGO2        ((uint32_t)(ADC_CR2_JEXTSEL_3 | ADC_CR2_JEXTSEL_1))
N#define ADC_EXTERNALTRIGINJECCONV_T3_CC3          ((uint32_t)(ADC_CR2_JEXTSEL_3 | ADC_CR2_JEXTSEL_1 | ADC_CR2_JEXTSEL_0))
N#define ADC_EXTERNALTRIGINJECCONV_T5_TRGO         ((uint32_t)(ADC_CR2_JEXTSEL_3 | ADC_CR2_JEXTSEL_2))
N#define ADC_EXTERNALTRIGINJECCONV_T3_CC1          ((uint32_t)(ADC_CR2_JEXTSEL_3 | ADC_CR2_JEXTSEL_2 | ADC_CR2_JEXTSEL_0))
N#define ADC_EXTERNALTRIGINJECCONV_T6_TRGO         ((uint32_t)(ADC_CR2_JEXTSEL_3 | ADC_CR2_JEXTSEL_2 | ADC_CR2_JEXTSEL_1))
N#define ADC_INJECTED_SOFTWARE_START                ((uint32_t)ADC_CR2_JEXTSEL + 1)
N/**
N  * @}
N  */ 
N
N/** @defgroup ADCEx_injected_rank ADC Injected Rank
N  * @{
N  */ 
N#define ADC_INJECTED_RANK_1    ((uint32_t)0x00000001U)
N#define ADC_INJECTED_RANK_2    ((uint32_t)0x00000002U)
N#define ADC_INJECTED_RANK_3    ((uint32_t)0x00000003U)
N#define ADC_INJECTED_RANK_4    ((uint32_t)0x00000004U)
N/**
N  * @}
N  */ 
N
N/** @defgroup ADCEx_channels  ADC Specific Channels
N  * @{
N  */
N#define ADC_CHANNEL_TEMPSENSOR  ((uint32_t)ADC_CHANNEL_18 | 0x10000000U)    
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup ADC_Exported_Macros ADC Exported Macros
N  * @{
N  */
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup ADCEx_Exported_Functions
N  * @{
N  */
N	
N/** @addtogroup ADCEx_Exported_Functions_Group1
N  * @{
N  */
N
N/* I/O operation functions ******************************************************/
NHAL_StatusTypeDef HAL_ADCEx_InjectedStart(ADC_HandleTypeDef* hadc);
NHAL_StatusTypeDef HAL_ADCEx_InjectedStop(ADC_HandleTypeDef* hadc);
NHAL_StatusTypeDef HAL_ADCEx_InjectedPollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout);
NHAL_StatusTypeDef HAL_ADCEx_InjectedStart_IT(ADC_HandleTypeDef* hadc);
NHAL_StatusTypeDef HAL_ADCEx_InjectedStop_IT(ADC_HandleTypeDef* hadc);
Nuint32_t HAL_ADCEx_InjectedGetValue(ADC_HandleTypeDef* hadc, uint32_t InjectedRank);
NHAL_StatusTypeDef HAL_ADCEx_MultiModeStart_DMA(ADC_HandleTypeDef* hadc, uint32_t* pData, uint32_t Length);
NHAL_StatusTypeDef HAL_ADCEx_MultiModeStop_DMA(ADC_HandleTypeDef* hadc);
Nuint32_t HAL_ADCEx_MultiModeGetValue(ADC_HandleTypeDef* hadc);
Nvoid HAL_ADCEx_InjectedConvCpltCallback(ADC_HandleTypeDef* hadc);
N
N/* Peripheral Control functions *************************************************/
NHAL_StatusTypeDef HAL_ADCEx_InjectedConfigChannel(ADC_HandleTypeDef* hadc,ADC_InjectionConfTypeDef* sConfigInjected);
NHAL_StatusTypeDef HAL_ADCEx_MultiModeConfigChannel(ADC_HandleTypeDef* hadc, ADC_MultiModeTypeDef* multimode);
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup ADCEx_Private_Constants ADC Private Constants
N  * @{
N  */
N
N/**
N  * @}
N  */
N	
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup ADCEx_Private_Macros ADC Private Macros
N  * @{
N  */
N#define IS_ADC_CHANNEL(CHANNEL) (((CHANNEL) <= ADC_CHANNEL_18)  || \
N                                 ((CHANNEL) == ADC_CHANNEL_TEMPSENSOR))
X#define IS_ADC_CHANNEL(CHANNEL) (((CHANNEL) <= ADC_CHANNEL_18)  ||                                  ((CHANNEL) == ADC_CHANNEL_TEMPSENSOR))
N                                     
N#define IS_ADC_MODE(__MODE__) (((__MODE__) == ADC_MODE_INDEPENDENT)                 || \
N                               ((__MODE__) == ADC_DUALMODE_REGSIMULT_INJECSIMULT)   || \
N                               ((__MODE__) == ADC_DUALMODE_REGSIMULT_ALTERTRIG)     || \
N                               ((__MODE__) == ADC_DUALMODE_INJECSIMULT)             || \
N                               ((__MODE__) == ADC_DUALMODE_REGSIMULT)               || \
N                               ((__MODE__) == ADC_DUALMODE_INTERL)                  || \
N                               ((__MODE__) == ADC_DUALMODE_ALTERTRIG)               || \
N                               ((__MODE__) == ADC_TRIPLEMODE_REGSIMULT_INJECSIMULT) || \
N                               ((__MODE__) == ADC_TRIPLEMODE_REGSIMULT_AlterTrig)   || \
N                               ((__MODE__) == ADC_TRIPLEMODE_INJECSIMULT)           || \
N                               ((__MODE__) == ADC_TRIPLEMODE_REGSIMULT)             || \
N                               ((__MODE__) == ADC_TRIPLEMODE_INTERL)                || \
N                               ((__MODE__) == ADC_TRIPLEMODE_ALTERTRIG))
X#define IS_ADC_MODE(__MODE__) (((__MODE__) == ADC_MODE_INDEPENDENT)                 ||                                ((__MODE__) == ADC_DUALMODE_REGSIMULT_INJECSIMULT)   ||                                ((__MODE__) == ADC_DUALMODE_REGSIMULT_ALTERTRIG)     ||                                ((__MODE__) == ADC_DUALMODE_INJECSIMULT)             ||                                ((__MODE__) == ADC_DUALMODE_REGSIMULT)               ||                                ((__MODE__) == ADC_DUALMODE_INTERL)                  ||                                ((__MODE__) == ADC_DUALMODE_ALTERTRIG)               ||                                ((__MODE__) == ADC_TRIPLEMODE_REGSIMULT_INJECSIMULT) ||                                ((__MODE__) == ADC_TRIPLEMODE_REGSIMULT_AlterTrig)   ||                                ((__MODE__) == ADC_TRIPLEMODE_INJECSIMULT)           ||                                ((__MODE__) == ADC_TRIPLEMODE_REGSIMULT)             ||                                ((__MODE__) == ADC_TRIPLEMODE_INTERL)                ||                                ((__MODE__) == ADC_TRIPLEMODE_ALTERTRIG))
N#define IS_ADC_DMA_ACCESS_MODE(__MODE__) (((__MODE__) == ADC_DMAACCESSMODE_DISABLED) || \
N                                          ((__MODE__) == ADC_DMAACCESSMODE_1)        || \
N                                          ((__MODE__) == ADC_DMAACCESSMODE_2)        || \
N                                          ((__MODE__) == ADC_DMAACCESSMODE_3))
X#define IS_ADC_DMA_ACCESS_MODE(__MODE__) (((__MODE__) == ADC_DMAACCESSMODE_DISABLED) ||                                           ((__MODE__) == ADC_DMAACCESSMODE_1)        ||                                           ((__MODE__) == ADC_DMAACCESSMODE_2)        ||                                           ((__MODE__) == ADC_DMAACCESSMODE_3))
N#define IS_ADC_EXT_INJEC_TRIG_EDGE(__EDGE__) (((__EDGE__) == ADC_EXTERNALTRIGINJECCONVEDGE_NONE)    || \
N                                              ((__EDGE__) == ADC_EXTERNALTRIGINJECCONVEDGE_RISING)  || \
N                                              ((__EDGE__) == ADC_EXTERNALTRIGINJECCONVEDGE_FALLING) || \
N                                              ((__EDGE__) == ADC_EXTERNALTRIGINJECCONVEDGE_RISINGFALLING))
X#define IS_ADC_EXT_INJEC_TRIG_EDGE(__EDGE__) (((__EDGE__) == ADC_EXTERNALTRIGINJECCONVEDGE_NONE)    ||                                               ((__EDGE__) == ADC_EXTERNALTRIGINJECCONVEDGE_RISING)  ||                                               ((__EDGE__) == ADC_EXTERNALTRIGINJECCONVEDGE_FALLING) ||                                               ((__EDGE__) == ADC_EXTERNALTRIGINJECCONVEDGE_RISINGFALLING))
N#define IS_ADC_EXT_INJEC_TRIG(__INJTRIG__) (((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T1_TRGO)  || \
N                                            ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T1_CC4)   || \
N                                            ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T2_TRGO)  || \
N                                            ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T2_CC1)   || \
N                                            ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T3_CC4)   || \
N                                            ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T4_TRGO)  || \
N                                            ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T8_CC4)   || \
N                                            ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T1_TRGO2) || \
N                                            ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T8_TRGO)  || \
N                                            ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T8_TRGO2) || \
N                                            ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T3_CC3)   || \
N                                            ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T5_TRGO)  || \
N                                            ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T3_CC1)   || \
N                                            ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T6_TRGO)  || \
N											((__INJTRIG__) == ADC_INJECTED_SOFTWARE_START))
X#define IS_ADC_EXT_INJEC_TRIG(__INJTRIG__) (((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T1_TRGO)  ||                                             ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T1_CC4)   ||                                             ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T2_TRGO)  ||                                             ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T2_CC1)   ||                                             ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T3_CC4)   ||                                             ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T4_TRGO)  ||                                             ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T8_CC4)   ||                                             ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T1_TRGO2) ||                                             ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T8_TRGO)  ||                                             ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T8_TRGO2) ||                                             ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T3_CC3)   ||                                             ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T5_TRGO)  ||                                             ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T3_CC1)   ||                                             ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T6_TRGO)  || 											((__INJTRIG__) == ADC_INJECTED_SOFTWARE_START))
N#define IS_ADC_INJECTED_LENGTH(__LENGTH__) (((__LENGTH__) >= ((uint32_t)1)) && ((__LENGTH__) <= ((uint32_t)4)))
N#define IS_ADC_INJECTED_RANK(__RANK__) (((__RANK__) >= ((uint32_t)1)) && ((__RANK__) <= ((uint32_t)4)))
N
N/**
N  * @brief  Set the selected injected Channel rank.
N  * @param  _CHANNELNB_: Channel number.
N  * @param  _RANKNB_: Rank number. 
N  * @param  _JSQR_JL_: Sequence length.     
N  * @retval None
N  */
N#define   ADC_JSQR(_CHANNELNB_, _RANKNB_,_JSQR_JL_) (((uint32_t)((uint16_t)(_CHANNELNB_))) << (5 * (uint8_t)(((_RANKNB_) + 3) - (_JSQR_JL_))))
N/**
N  * @}
N  */
N	
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup ADCEx_Private_Functions ADC Private Functions
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N	
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F7xx_ADC_EX_H */
N
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 525 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_adc.h" 2
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup ADC_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup ADC_Exported_Functions_Group1
N  * @{
N  */
N/* Initialization/de-initialization functions ***********************************/
NHAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc);
NHAL_StatusTypeDef HAL_ADC_DeInit(ADC_HandleTypeDef *hadc);
Nvoid       HAL_ADC_MspInit(ADC_HandleTypeDef* hadc);
Nvoid       HAL_ADC_MspDeInit(ADC_HandleTypeDef* hadc);
N/**
N  * @}
N  */
N
N/** @addtogroup ADC_Exported_Functions_Group2
N  * @{
N  */
N/* I/O operation functions ******************************************************/
NHAL_StatusTypeDef HAL_ADC_Start(ADC_HandleTypeDef* hadc);
NHAL_StatusTypeDef HAL_ADC_Stop(ADC_HandleTypeDef* hadc);
NHAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout);
N
NHAL_StatusTypeDef HAL_ADC_PollForEvent(ADC_HandleTypeDef* hadc, uint32_t EventType, uint32_t Timeout);
N
NHAL_StatusTypeDef HAL_ADC_Start_IT(ADC_HandleTypeDef* hadc);
NHAL_StatusTypeDef HAL_ADC_Stop_IT(ADC_HandleTypeDef* hadc);
N
Nvoid              HAL_ADC_IRQHandler(ADC_HandleTypeDef* hadc);
N
NHAL_StatusTypeDef HAL_ADC_Start_DMA(ADC_HandleTypeDef* hadc, uint32_t* pData, uint32_t Length);
NHAL_StatusTypeDef HAL_ADC_Stop_DMA(ADC_HandleTypeDef* hadc);
N
Nuint32_t          HAL_ADC_GetValue(ADC_HandleTypeDef* hadc);
N
Nvoid       HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc);
Nvoid       HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef* hadc);
Nvoid       HAL_ADC_LevelOutOfWindowCallback(ADC_HandleTypeDef* hadc);
Nvoid       HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc);
N/**
N  * @}
N  */
N
N/** @addtogroup ADC_Exported_Functions_Group3
N  * @{
N  */
N/* Peripheral Control functions *************************************************/
NHAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig);
NHAL_StatusTypeDef HAL_ADC_AnalogWDGConfig(ADC_HandleTypeDef* hadc, ADC_AnalogWDGConfTypeDef* AnalogWDGConfig);
N/**
N  * @}
N  */
N
N/** @addtogroup ADC_Exported_Functions_Group4
N  * @{
N  */
N/* Peripheral State functions ***************************************************/
Nuint32_t HAL_ADC_GetState(ADC_HandleTypeDef* hadc);
Nuint32_t HAL_ADC_GetError(ADC_HandleTypeDef *hadc);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup ADC_Private_Constants ADC Private Constants
N  * @{
N  */
N/* Delay for ADC stabilization time.                                        */
N/* Maximum delay is 1us (refer to device datasheet, parameter tSTAB).       */
N/* Unit: us                                                                 */
N#define ADC_STAB_DELAY_US               ((uint32_t) 3U)
N/* Delay for temperature sensor stabilization time.                         */
N/* Maximum delay is 10us (refer to device datasheet, parameter tSTART).     */
N/* Unit: us                                                                 */
N#define ADC_TEMPSENSOR_DELAY_US         ((uint32_t) 10U)
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup ADC_Private_Macros ADC Private Macros
N  * @{
N  */
N/* Macro reserved for internal HAL driver usage, not intended to be used in
N   code of final user */
N
N/**
N  * @brief Verification of ADC state: enabled or disabled
N  * @param __HANDLE__: ADC handle
N  * @retval SET (ADC enabled) or RESET (ADC disabled)
N  */
N#define ADC_IS_ENABLE(__HANDLE__)                                              \
N  ((( ((__HANDLE__)->Instance->SR & ADC_SR_ADONS) == ADC_SR_ADONS )            \
N  ) ? SET : RESET)
X#define ADC_IS_ENABLE(__HANDLE__)                                                ((( ((__HANDLE__)->Instance->SR & ADC_SR_ADONS) == ADC_SR_ADONS )              ) ? SET : RESET)
N
N/**
N  * @brief Test if conversion trigger of regular group is software start
N  *        or external trigger.
N  * @param __HANDLE__: ADC handle
N  * @retval SET (software start) or RESET (external trigger)
N  */
N#define ADC_IS_SOFTWARE_START_REGULAR(__HANDLE__)                              \
N  (((__HANDLE__)->Instance->CR2 & ADC_CR2_EXTEN) == RESET)
X#define ADC_IS_SOFTWARE_START_REGULAR(__HANDLE__)                                (((__HANDLE__)->Instance->CR2 & ADC_CR2_EXTEN) == RESET)
N
N/**
N  * @brief Test if conversion trigger of injected group is software start
N  *        or external trigger.
N  * @param __HANDLE__: ADC handle
N  * @retval SET (software start) or RESET (external trigger)
N  */
N#define ADC_IS_SOFTWARE_START_INJECTED(__HANDLE__)                             \
N  (((__HANDLE__)->Instance->CR2 & ADC_CR2_JEXTEN) == RESET)
X#define ADC_IS_SOFTWARE_START_INJECTED(__HANDLE__)                               (((__HANDLE__)->Instance->CR2 & ADC_CR2_JEXTEN) == RESET)
N
N/**
N  * @brief Simultaneously clears and sets specific bits of the handle State
N  * @note: ADC_STATE_CLR_SET() macro is merely aliased to generic macro MODIFY_REG(),
N  *        the first parameter is the ADC handle State, the second parameter is the
N  *        bit field to clear, the third and last parameter is the bit field to set.
N  * @retval None
N  */
N#define ADC_STATE_CLR_SET MODIFY_REG
N
N/**
N  * @brief Clear ADC error code (set it to error code: "no error")
N  * @param __HANDLE__: ADC handle
N  * @retval None
N  */
N#define ADC_CLEAR_ERRORCODE(__HANDLE__)                                        \
N  ((__HANDLE__)->ErrorCode = HAL_ADC_ERROR_NONE)
X#define ADC_CLEAR_ERRORCODE(__HANDLE__)                                          ((__HANDLE__)->ErrorCode = HAL_ADC_ERROR_NONE)
N#define IS_ADC_CLOCKPRESCALER(__ADC_CLOCK__)     (((__ADC_CLOCK__) == ADC_CLOCK_SYNC_PCLK_DIV2) || \
N                                                  ((__ADC_CLOCK__) == ADC_CLOCK_SYNC_PCLK_DIV4) || \
N                                                  ((__ADC_CLOCK__) == ADC_CLOCK_SYNC_PCLK_DIV6) || \
N                                                  ((__ADC_CLOCK__) == ADC_CLOCK_SYNC_PCLK_DIV8))
X#define IS_ADC_CLOCKPRESCALER(__ADC_CLOCK__)     (((__ADC_CLOCK__) == ADC_CLOCK_SYNC_PCLK_DIV2) ||                                                   ((__ADC_CLOCK__) == ADC_CLOCK_SYNC_PCLK_DIV4) ||                                                   ((__ADC_CLOCK__) == ADC_CLOCK_SYNC_PCLK_DIV6) ||                                                   ((__ADC_CLOCK__) == ADC_CLOCK_SYNC_PCLK_DIV8))
N#define IS_ADC_SAMPLING_DELAY(__DELAY__) (((__DELAY__) == ADC_TWOSAMPLINGDELAY_5CYCLES)  || \
N                                          ((__DELAY__) == ADC_TWOSAMPLINGDELAY_6CYCLES)  || \
N                                          ((__DELAY__) == ADC_TWOSAMPLINGDELAY_7CYCLES)  || \
N                                          ((__DELAY__) == ADC_TWOSAMPLINGDELAY_8CYCLES)  || \
N                                          ((__DELAY__) == ADC_TWOSAMPLINGDELAY_9CYCLES)  || \
N                                          ((__DELAY__) == ADC_TWOSAMPLINGDELAY_10CYCLES) || \
N                                          ((__DELAY__) == ADC_TWOSAMPLINGDELAY_11CYCLES) || \
N                                          ((__DELAY__) == ADC_TWOSAMPLINGDELAY_12CYCLES) || \
N                                          ((__DELAY__) == ADC_TWOSAMPLINGDELAY_13CYCLES) || \
N                                          ((__DELAY__) == ADC_TWOSAMPLINGDELAY_14CYCLES) || \
N                                          ((__DELAY__) == ADC_TWOSAMPLINGDELAY_15CYCLES) || \
N                                          ((__DELAY__) == ADC_TWOSAMPLINGDELAY_16CYCLES) || \
N                                          ((__DELAY__) == ADC_TWOSAMPLINGDELAY_17CYCLES) || \
N                                          ((__DELAY__) == ADC_TWOSAMPLINGDELAY_18CYCLES) || \
N                                          ((__DELAY__) == ADC_TWOSAMPLINGDELAY_19CYCLES) || \
N                                          ((__DELAY__) == ADC_TWOSAMPLINGDELAY_20CYCLES))
X#define IS_ADC_SAMPLING_DELAY(__DELAY__) (((__DELAY__) == ADC_TWOSAMPLINGDELAY_5CYCLES)  ||                                           ((__DELAY__) == ADC_TWOSAMPLINGDELAY_6CYCLES)  ||                                           ((__DELAY__) == ADC_TWOSAMPLINGDELAY_7CYCLES)  ||                                           ((__DELAY__) == ADC_TWOSAMPLINGDELAY_8CYCLES)  ||                                           ((__DELAY__) == ADC_TWOSAMPLINGDELAY_9CYCLES)  ||                                           ((__DELAY__) == ADC_TWOSAMPLINGDELAY_10CYCLES) ||                                           ((__DELAY__) == ADC_TWOSAMPLINGDELAY_11CYCLES) ||                                           ((__DELAY__) == ADC_TWOSAMPLINGDELAY_12CYCLES) ||                                           ((__DELAY__) == ADC_TWOSAMPLINGDELAY_13CYCLES) ||                                           ((__DELAY__) == ADC_TWOSAMPLINGDELAY_14CYCLES) ||                                           ((__DELAY__) == ADC_TWOSAMPLINGDELAY_15CYCLES) ||                                           ((__DELAY__) == ADC_TWOSAMPLINGDELAY_16CYCLES) ||                                           ((__DELAY__) == ADC_TWOSAMPLINGDELAY_17CYCLES) ||                                           ((__DELAY__) == ADC_TWOSAMPLINGDELAY_18CYCLES) ||                                           ((__DELAY__) == ADC_TWOSAMPLINGDELAY_19CYCLES) ||                                           ((__DELAY__) == ADC_TWOSAMPLINGDELAY_20CYCLES))
N#define IS_ADC_RESOLUTION(__RESOLUTION__) (((__RESOLUTION__) == ADC_RESOLUTION_12B) || \
N                                           ((__RESOLUTION__) == ADC_RESOLUTION_10B) || \
N                                           ((__RESOLUTION__) == ADC_RESOLUTION_8B)  || \
N                                           ((__RESOLUTION__) == ADC_RESOLUTION_6B))			
X#define IS_ADC_RESOLUTION(__RESOLUTION__) (((__RESOLUTION__) == ADC_RESOLUTION_12B) ||                                            ((__RESOLUTION__) == ADC_RESOLUTION_10B) ||                                            ((__RESOLUTION__) == ADC_RESOLUTION_8B)  ||                                            ((__RESOLUTION__) == ADC_RESOLUTION_6B))			
N#define IS_ADC_EXT_TRIG_EDGE(__EDGE__) (((__EDGE__) == ADC_EXTERNALTRIGCONVEDGE_NONE)    || \
N                                        ((__EDGE__) == ADC_EXTERNALTRIGCONVEDGE_RISING)  || \
N                                        ((__EDGE__) == ADC_EXTERNALTRIGCONVEDGE_FALLING) || \
N                                        ((__EDGE__) == ADC_EXTERNALTRIGCONVEDGE_RISINGFALLING))
X#define IS_ADC_EXT_TRIG_EDGE(__EDGE__) (((__EDGE__) == ADC_EXTERNALTRIGCONVEDGE_NONE)    ||                                         ((__EDGE__) == ADC_EXTERNALTRIGCONVEDGE_RISING)  ||                                         ((__EDGE__) == ADC_EXTERNALTRIGCONVEDGE_FALLING) ||                                         ((__EDGE__) == ADC_EXTERNALTRIGCONVEDGE_RISINGFALLING))
N#define IS_ADC_EXT_TRIG(__REGTRIG__) (((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T1_CC1)   || \
N                                      ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T1_CC2)   || \
N                                      ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T1_CC3)   || \
N                                      ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T2_CC2)   || \
N                                      ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T5_TRGO)  || \
N                                      ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T4_CC4)   || \
N                                      ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T3_CC4) || \
N                                      ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T8_TRGO)  || \
N                                      ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T8_TRGO2) || \
N                                      ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T1_TRGO)  || \
N                                      ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T1_TRGO2) || \
N                                      ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T2_TRGO)  || \
N                                      ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T4_TRGO)  || \
N                                      ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T6_TRGO)  || \
N                                      ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_EXT_IT11) || \
N																			((__REGTRIG__) == ADC_SOFTWARE_START))
X#define IS_ADC_EXT_TRIG(__REGTRIG__) (((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T1_CC1)   ||                                       ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T1_CC2)   ||                                       ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T1_CC3)   ||                                       ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T2_CC2)   ||                                       ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T5_TRGO)  ||                                       ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T4_CC4)   ||                                       ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T3_CC4) ||                                       ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T8_TRGO)  ||                                       ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T8_TRGO2) ||                                       ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T1_TRGO)  ||                                       ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T1_TRGO2) ||                                       ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T2_TRGO)  ||                                       ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T4_TRGO)  ||                                       ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T6_TRGO)  ||                                       ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_EXT_IT11) || 																			((__REGTRIG__) == ADC_SOFTWARE_START))
N#define IS_ADC_DATA_ALIGN(__ALIGN__) (((__ALIGN__) == ADC_DATAALIGN_RIGHT) || \
N                                      ((__ALIGN__) == ADC_DATAALIGN_LEFT))		
X#define IS_ADC_DATA_ALIGN(__ALIGN__) (((__ALIGN__) == ADC_DATAALIGN_RIGHT) ||                                       ((__ALIGN__) == ADC_DATAALIGN_LEFT))		
N                                      									
N#define IS_ADC_SAMPLE_TIME(__TIME__) (((__TIME__) == ADC_SAMPLETIME_3CYCLES)   || \
N                                      ((__TIME__) == ADC_SAMPLETIME_15CYCLES)  || \
N                                      ((__TIME__) == ADC_SAMPLETIME_28CYCLES)  || \
N                                      ((__TIME__) == ADC_SAMPLETIME_56CYCLES)  || \
N                                      ((__TIME__) == ADC_SAMPLETIME_84CYCLES)  || \
N                                      ((__TIME__) == ADC_SAMPLETIME_112CYCLES) || \
N                                      ((__TIME__) == ADC_SAMPLETIME_144CYCLES) || \
N                                      ((__TIME__) == ADC_SAMPLETIME_480CYCLES))	
X#define IS_ADC_SAMPLE_TIME(__TIME__) (((__TIME__) == ADC_SAMPLETIME_3CYCLES)   ||                                       ((__TIME__) == ADC_SAMPLETIME_15CYCLES)  ||                                       ((__TIME__) == ADC_SAMPLETIME_28CYCLES)  ||                                       ((__TIME__) == ADC_SAMPLETIME_56CYCLES)  ||                                       ((__TIME__) == ADC_SAMPLETIME_84CYCLES)  ||                                       ((__TIME__) == ADC_SAMPLETIME_112CYCLES) ||                                       ((__TIME__) == ADC_SAMPLETIME_144CYCLES) ||                                       ((__TIME__) == ADC_SAMPLETIME_480CYCLES))	
N#define IS_ADC_EOCSelection(__EOCSelection__) (((__EOCSelection__) == ADC_EOC_SINGLE_CONV)   || \
N                                               ((__EOCSelection__) == ADC_EOC_SEQ_CONV)  || \
N                                               ((__EOCSelection__) == ADC_EOC_SINGLE_SEQ_CONV))	
X#define IS_ADC_EOCSelection(__EOCSelection__) (((__EOCSelection__) == ADC_EOC_SINGLE_CONV)   ||                                                ((__EOCSelection__) == ADC_EOC_SEQ_CONV)  ||                                                ((__EOCSelection__) == ADC_EOC_SINGLE_SEQ_CONV))	
N#define IS_ADC_EVENT_TYPE(__EVENT__) (((__EVENT__) == ADC_AWD_EVENT) || \
N                                      ((__EVENT__) == ADC_OVR_EVENT))		
X#define IS_ADC_EVENT_TYPE(__EVENT__) (((__EVENT__) == ADC_AWD_EVENT) ||                                       ((__EVENT__) == ADC_OVR_EVENT))		
N#define IS_ADC_ANALOG_WATCHDOG(__WATCHDOG__) (((__WATCHDOG__) == ADC_ANALOGWATCHDOG_SINGLE_REG)        || \
N                                              ((__WATCHDOG__) == ADC_ANALOGWATCHDOG_SINGLE_INJEC)      || \
N                                              ((__WATCHDOG__) == ADC_ANALOGWATCHDOG_SINGLE_REGINJEC)   || \
N                                              ((__WATCHDOG__) == ADC_ANALOGWATCHDOG_ALL_REG)           || \
N                                              ((__WATCHDOG__) == ADC_ANALOGWATCHDOG_ALL_INJEC)         || \
N                                              ((__WATCHDOG__) == ADC_ANALOGWATCHDOG_ALL_REGINJEC)      || \
N                                              ((__WATCHDOG__) == ADC_ANALOGWATCHDOG_NONE))
X#define IS_ADC_ANALOG_WATCHDOG(__WATCHDOG__) (((__WATCHDOG__) == ADC_ANALOGWATCHDOG_SINGLE_REG)        ||                                               ((__WATCHDOG__) == ADC_ANALOGWATCHDOG_SINGLE_INJEC)      ||                                               ((__WATCHDOG__) == ADC_ANALOGWATCHDOG_SINGLE_REGINJEC)   ||                                               ((__WATCHDOG__) == ADC_ANALOGWATCHDOG_ALL_REG)           ||                                               ((__WATCHDOG__) == ADC_ANALOGWATCHDOG_ALL_INJEC)         ||                                               ((__WATCHDOG__) == ADC_ANALOGWATCHDOG_ALL_REGINJEC)      ||                                               ((__WATCHDOG__) == ADC_ANALOGWATCHDOG_NONE))
N#define IS_ADC_CHANNELS_TYPE(CHANNEL_TYPE) (((CHANNEL_TYPE) == ADC_ALL_CHANNELS) || \
N                                            ((CHANNEL_TYPE) == ADC_REGULAR_CHANNELS) || \
N                                            ((CHANNEL_TYPE) == ADC_INJECTED_CHANNELS))
X#define IS_ADC_CHANNELS_TYPE(CHANNEL_TYPE) (((CHANNEL_TYPE) == ADC_ALL_CHANNELS) ||                                             ((CHANNEL_TYPE) == ADC_REGULAR_CHANNELS) ||                                             ((CHANNEL_TYPE) == ADC_INJECTED_CHANNELS))
N#define IS_ADC_THRESHOLD(__THRESHOLD__) ((__THRESHOLD__) <= ((uint32_t)0xFFF))
N#define IS_ADC_REGULAR_LENGTH(__LENGTH__) (((__LENGTH__) >= ((uint32_t)1)) && ((__LENGTH__) <= ((uint32_t)16)))
N#define IS_ADC_REGULAR_RANK(__RANK__) (((__RANK__) >= ((uint32_t)1)) && ((__RANK__) <= ((uint32_t)16)))
N#define IS_ADC_REGULAR_DISC_NUMBER(__NUMBER__) (((__NUMBER__) >= ((uint32_t)1)) && ((__NUMBER__) <= ((uint32_t)8)))
N#define IS_ADC_RANGE(__RESOLUTION__, __ADC_VALUE__)                                     \
N   ((((__RESOLUTION__) == ADC_RESOLUTION_12B) && ((__ADC_VALUE__) <= ((uint32_t)0x0FFF))) || \
N    (((__RESOLUTION__) == ADC_RESOLUTION_10B) && ((__ADC_VALUE__) <= ((uint32_t)0x03FF))) || \
N    (((__RESOLUTION__) == ADC_RESOLUTION_8B)  && ((__ADC_VALUE__) <= ((uint32_t)0x00FF))) || \
N    (((__RESOLUTION__) == ADC_RESOLUTION_6B)  && ((__ADC_VALUE__) <= ((uint32_t)0x003F))))
X#define IS_ADC_RANGE(__RESOLUTION__, __ADC_VALUE__)                                        ((((__RESOLUTION__) == ADC_RESOLUTION_12B) && ((__ADC_VALUE__) <= ((uint32_t)0x0FFF))) ||     (((__RESOLUTION__) == ADC_RESOLUTION_10B) && ((__ADC_VALUE__) <= ((uint32_t)0x03FF))) ||     (((__RESOLUTION__) == ADC_RESOLUTION_8B)  && ((__ADC_VALUE__) <= ((uint32_t)0x00FF))) ||     (((__RESOLUTION__) == ADC_RESOLUTION_6B)  && ((__ADC_VALUE__) <= ((uint32_t)0x003F))))
N
N/**
N  * @brief  Set ADC Regular channel sequence length.
N  * @param  _NbrOfConversion_: Regular channel sequence length. 
N  * @retval None
N  */
N#define ADC_SQR1(_NbrOfConversion_) (((_NbrOfConversion_) - (uint8_t)1) << 20)
N
N/**
N  * @brief  Set the ADC's sample time for channel numbers between 10 and 18.
N  * @param  _SAMPLETIME_: Sample time parameter.
N  * @param  _CHANNELNB_: Channel number.  
N  * @retval None
N  */
N#define ADC_SMPR1(_SAMPLETIME_, _CHANNELNB_) ((_SAMPLETIME_) << (3 * (((uint32_t)((uint16_t)(_CHANNELNB_))) - 10)))
N
N/**
N  * @brief  Set the ADC's sample time for channel numbers between 0 and 9.
N  * @param  _SAMPLETIME_: Sample time parameter.
N  * @param  _CHANNELNB_: Channel number.  
N  * @retval None
N  */
N#define ADC_SMPR2(_SAMPLETIME_, _CHANNELNB_) ((_SAMPLETIME_) << (3 * ((uint32_t)((uint16_t)(_CHANNELNB_)))))
N
N/**
N  * @brief  Set the selected regular channel rank for rank between 1 and 6.
N  * @param  _CHANNELNB_: Channel number.
N  * @param  _RANKNB_: Rank number.    
N  * @retval None
N  */
N#define ADC_SQR3_RK(_CHANNELNB_, _RANKNB_) (((uint32_t)((uint16_t)(_CHANNELNB_))) << (5 * ((_RANKNB_) - 1)))
N
N/**
N  * @brief  Set the selected regular channel rank for rank between 7 and 12.
N  * @param  _CHANNELNB_: Channel number.
N  * @param  _RANKNB_: Rank number.    
N  * @retval None
N  */
N#define ADC_SQR2_RK(_CHANNELNB_, _RANKNB_) (((uint32_t)((uint16_t)(_CHANNELNB_))) << (5 * ((_RANKNB_) - 7)))
N
N/**
N  * @brief  Set the selected regular channel rank for rank between 13 and 16.
N  * @param  _CHANNELNB_: Channel number.
N  * @param  _RANKNB_: Rank number.    
N  * @retval None
N  */
N#define ADC_SQR1_RK(_CHANNELNB_, _RANKNB_) (((uint32_t)((uint16_t)(_CHANNELNB_))) << (5 * ((_RANKNB_) - 13)))
N
N/**
N  * @brief  Enable ADC continuous conversion mode.
N  * @param  _CONTINUOUS_MODE_: Continuous mode.
N  * @retval None
N  */
N#define ADC_CR2_CONTINUOUS(_CONTINUOUS_MODE_) ((_CONTINUOUS_MODE_) << 1)
N
N/**
N  * @brief  Configures the number of discontinuous conversions for the regular group channels.
N  * @param  _NBR_DISCONTINUOUSCONV_: Number of discontinuous conversions.
N  * @retval None
N  */
N#define ADC_CR1_DISCONTINUOUS(_NBR_DISCONTINUOUSCONV_) (((_NBR_DISCONTINUOUSCONV_) - 1) << POSITION_VAL(ADC_CR1_DISCNUM))
N
N/**
N  * @brief  Enable ADC scan mode.
N  * @param  _SCANCONV_MODE_: Scan conversion mode.
N  * @retval None
N  */
N#define ADC_CR1_SCANCONV(_SCANCONV_MODE_) ((_SCANCONV_MODE_) << 8)
N
N/**
N  * @brief  Enable the ADC end of conversion selection.
N  * @param  _EOCSelection_MODE_: End of conversion selection mode.
N  * @retval None
N  */
N#define ADC_CR2_EOCSelection(_EOCSelection_MODE_) ((_EOCSelection_MODE_) << 10)
N
N/**
N  * @brief  Enable the ADC DMA continuous request.
N  * @param  _DMAContReq_MODE_: DMA continuous request mode.
N  * @retval None
N  */
N#define ADC_CR2_DMAContReq(_DMAContReq_MODE_) ((_DMAContReq_MODE_) << 9)
N
N/**
N  * @brief Return resolution bits in CR1 register.
N  * @param __HANDLE__: ADC handle
N  * @retval None
N  */
N#define ADC_GET_RESOLUTION(__HANDLE__) (((__HANDLE__)->Instance->CR1) & ADC_CR1_RES)
N																
N/**
N  * @}
N  */
N	
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup ADC_Private_Functions ADC Private Functions
N  * @{
N  */
N
N/**
N  * @}
N  */
N	
N/**
N  * @}
N  */
N	
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F7xx_ADC_H */
N
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 263 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_ADC_MODULE_ENABLED */
N
N#ifdef HAL_CAN_MODULE_ENABLED
N  #include "stm32f7xx_hal_can.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_can.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_can.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of CAN HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_CAN_H
N#define __STM32F7xx_HAL_CAN_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup CAN
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup CAN_Exported_Types CAN Exported Types
N  * @{
N  */
N
N/**
N  * @brief  HAL State structures definition
N  */
Ntypedef enum
N{
N  HAL_CAN_STATE_RESET             = 0x00U,  /*!< CAN not yet initialized or disabled */
N  HAL_CAN_STATE_READY             = 0x01U,  /*!< CAN initialized and ready for use   */
N  HAL_CAN_STATE_BUSY              = 0x02U,  /*!< CAN process is ongoing              */
N  HAL_CAN_STATE_BUSY_TX           = 0x12U,  /*!< CAN process is ongoing              */
N  HAL_CAN_STATE_BUSY_RX           = 0x22U,  /*!< CAN process is ongoing              */
N  HAL_CAN_STATE_BUSY_TX_RX        = 0x32U,  /*!< CAN process is ongoing              */
N  HAL_CAN_STATE_TIMEOUT           = 0x03U,  /*!< Timeout state                       */
N  HAL_CAN_STATE_ERROR             = 0x04U   /*!< CAN error state                     */
N
N}HAL_CAN_StateTypeDef;
N
N/**
N  * @brief  CAN init structure definition
N  */
Ntypedef struct
N{
N  uint32_t Prescaler;  /*!< Specifies the length of a time quantum.
N                            This parameter must be a number between Min_Data = 1 and Max_Data = 1024 */
N
N  uint32_t Mode;       /*!< Specifies the CAN operating mode.
N                            This parameter can be a value of @ref CAN_operating_mode */
N
N  uint32_t SJW;        /*!< Specifies the maximum number of time quanta
N                            the CAN hardware is allowed to lengthen or
N                            shorten a bit to perform resynchronization.
N                            This parameter can be a value of @ref CAN_synchronisation_jump_width */
N
N  uint32_t BS1;        /*!< Specifies the number of time quanta in Bit Segment 1.
N                            This parameter can be a value of @ref CAN_time_quantum_in_bit_segment_1 */
N
N  uint32_t BS2;        /*!< Specifies the number of time quanta in Bit Segment 2.
N                            This parameter can be a value of @ref CAN_time_quantum_in_bit_segment_2 */
N
N  uint32_t TTCM;       /*!< Enable or disable the time triggered communication mode.
N                            This parameter can be set to ENABLE or DISABLE. */
N
N  uint32_t ABOM;       /*!< Enable or disable the automatic bus-off management.
N                            This parameter can be set to ENABLE or DISABLE */
N
N  uint32_t AWUM;       /*!< Enable or disable the automatic wake-up mode.
N                            This parameter can be set to ENABLE or DISABLE */
N
N  uint32_t NART;       /*!< Enable or disable the non-automatic retransmission mode.
N                            This parameter can be set to ENABLE or DISABLE */
N
N  uint32_t RFLM;       /*!< Enable or disable the receive FIFO Locked mode.
N                            This parameter can be set to ENABLE or DISABLE */
N
N  uint32_t TXFP;       /*!< Enable or disable the transmit FIFO priority.
N                            This parameter can be set to ENABLE or DISABLE */
N}CAN_InitTypeDef;
N
N/**
N  * @brief  CAN filter configuration structure definition
N  */
Ntypedef struct
N{
N  uint32_t FilterIdHigh;          /*!< Specifies the filter identification number (MSBs for a 32-bit
N                                       configuration, first one for a 16-bit configuration).
N                                       This parameter must be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF */
N
N  uint32_t FilterIdLow;           /*!< Specifies the filter identification number (LSBs for a 32-bit
N                                       configuration, second one for a 16-bit configuration).
N                                       This parameter must be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF */
N
N  uint32_t FilterMaskIdHigh;      /*!< Specifies the filter mask number or identification number,
N                                       according to the mode (MSBs for a 32-bit configuration,
N                                       first one for a 16-bit configuration).
N                                       This parameter must be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF */
N
N  uint32_t FilterMaskIdLow;       /*!< Specifies the filter mask number or identification number,
N                                       according to the mode (LSBs for a 32-bit configuration,
N                                       second one for a 16-bit configuration).
N                                       This parameter must be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF */
N
N  uint32_t FilterFIFOAssignment;  /*!< Specifies the FIFO (0 or 1) which will be assigned to the filter.
N                                       This parameter can be a value of @ref CAN_filter_FIFO */
N
N  uint32_t FilterNumber;          /*!< Specifies the filter which will be initialized.
N                                       This parameter must be a number between Min_Data = 0 and Max_Data = 27 */
N
N  uint32_t FilterMode;            /*!< Specifies the filter mode to be initialized.
N                                       This parameter can be a value of @ref CAN_filter_mode */
N
N  uint32_t FilterScale;           /*!< Specifies the filter scale.
N                                       This parameter can be a value of @ref CAN_filter_scale */
N
N  uint32_t FilterActivation;      /*!< Enable or disable the filter.
N                                       This parameter can be set to ENABLE or DISABLE. */
N
N  uint32_t BankNumber;            /*!< Select the start slave bank filter.
N                                       This parameter must be a number between Min_Data = 0 and Max_Data = 28 */
N
N}CAN_FilterConfTypeDef;
N
N/**
N  * @brief  CAN Tx message structure definition
N  */
Ntypedef struct
N{
N  uint32_t StdId;    /*!< Specifies the standard identifier.
N                          This parameter must be a number between Min_Data = 0 and Max_Data = 0x7FF */
N
N  uint32_t ExtId;    /*!< Specifies the extended identifier.
N                          This parameter must be a number between Min_Data = 0 and Max_Data = 0x1FFFFFFF */
N
N  uint32_t IDE;      /*!< Specifies the type of identifier for the message that will be transmitted.
N                          This parameter can be a value of @ref CAN_Identifier_Type */
N
N  uint32_t RTR;      /*!< Specifies the type of frame for the message that will be transmitted.
N                          This parameter can be a value of @ref CAN_remote_transmission_request */
N
N  uint32_t DLC;      /*!< Specifies the length of the frame that will be transmitted.
N                          This parameter must be a number between Min_Data = 0 and Max_Data = 8 */
N
N  uint8_t Data[8];  /*!< Contains the data to be transmitted.
N                          This parameter must be a number between Min_Data = 0 and Max_Data = 0xFF */
N
N}CanTxMsgTypeDef;
N
N/**
N  * @brief  CAN Rx message structure definition
N  */
Ntypedef struct
N{
N  uint32_t StdId;       /*!< Specifies the standard identifier.
N                             This parameter must be a number between Min_Data = 0 and Max_Data = 0x7FF */
N
N  uint32_t ExtId;       /*!< Specifies the extended identifier.
N                             This parameter must be a number between Min_Data = 0 and Max_Data = 0x1FFFFFFF */
N
N  uint32_t IDE;         /*!< Specifies the type of identifier for the message that will be received.
N                             This parameter can be a value of @ref CAN_Identifier_Type */
N
N  uint32_t RTR;         /*!< Specifies the type of frame for the received message.
N                             This parameter can be a value of @ref CAN_remote_transmission_request */
N
N  uint32_t DLC;         /*!< Specifies the length of the frame that will be received.
N                             This parameter must be a number between Min_Data = 0 and Max_Data = 8 */
N
N  uint8_t Data[8];      /*!< Contains the data to be received.
N                             This parameter must be a number between Min_Data = 0 and Max_Data = 0xFF */
N
N  uint32_t FMI;         /*!< Specifies the index of the filter the message stored in the mailbox passes through.
N                             This parameter must be a number between Min_Data = 0 and Max_Data = 0xFF */
N
N  uint32_t FIFONumber;  /*!< Specifies the receive FIFO number.
N                             This parameter can be CAN_FIFO0 or CAN_FIFO1 */
N
N}CanRxMsgTypeDef;
N
N/**
N  * @brief  CAN handle Structure definition
N  */
Ntypedef struct
N{
N  CAN_TypeDef                 *Instance;  /*!< Register base address          */
N
N  CAN_InitTypeDef             Init;       /*!< CAN required parameters        */
N
N  CanTxMsgTypeDef*            pTxMsg;     /*!< Pointer to transmit structure  */
N
N  CanRxMsgTypeDef*            pRxMsg;     /*!< Pointer to reception structure */
N
N  __IO HAL_CAN_StateTypeDef   State;      /*!< CAN communication state        */
X  volatile HAL_CAN_StateTypeDef   State;       
N
N  HAL_LockTypeDef             Lock;       /*!< CAN locking object             */
N
N  __IO uint32_t               ErrorCode;  /*!< CAN Error code                 */
X  volatile uint32_t               ErrorCode;   
N
N}CAN_HandleTypeDef;
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup CAN_Exported_Constants CAN Exported Constants
N  * @{
N  */
N
N/** @defgroup HAL_CAN_Error_Code HAL CAN Error Code
N  * @{
N  */
N#define   HAL_CAN_ERROR_NONE      0x00U    /*!< No error             */
N#define   HAL_CAN_ERROR_EWG       0x01U    /*!< EWG error            */
N#define   HAL_CAN_ERROR_EPV       0x02U    /*!< EPV error            */
N#define   HAL_CAN_ERROR_BOF       0x04U    /*!< BOF error            */
N#define   HAL_CAN_ERROR_STF       0x08U    /*!< Stuff error          */
N#define   HAL_CAN_ERROR_FOR       0x10U    /*!< Form error           */
N#define   HAL_CAN_ERROR_ACK       0x20U    /*!< Acknowledgment error */
N#define   HAL_CAN_ERROR_BR        0x40U    /*!< Bit recessive        */
N#define   HAL_CAN_ERROR_BD        0x80U    /*!< LEC dominant         */
N#define   HAL_CAN_ERROR_CRC       0x100U   /*!< LEC transfer error   */
N/**
N  * @}
N  */
N
N/** @defgroup CAN_InitStatus CAN InitStatus
N  * @{
N  */
N#define CAN_INITSTATUS_FAILED       ((uint8_t)0x00U)  /*!< CAN initialization failed */
N#define CAN_INITSTATUS_SUCCESS      ((uint8_t)0x01U)  /*!< CAN initialization OK */
N/**
N  * @}
N  */
N
N/** @defgroup CAN_operating_mode CAN Operating Mode
N  * @{
N  */
N#define CAN_MODE_NORMAL             ((uint32_t)0x00000000U)                     /*!< Normal mode   */
N#define CAN_MODE_LOOPBACK           ((uint32_t)CAN_BTR_LBKM)                   /*!< Loopback mode */
N#define CAN_MODE_SILENT             ((uint32_t)CAN_BTR_SILM)                   /*!< Silent mode   */
N#define CAN_MODE_SILENT_LOOPBACK    ((uint32_t)(CAN_BTR_LBKM | CAN_BTR_SILM))  /*!< Loopback combined with silent mode */
N/**
N  * @}
N  */
N
N/** @defgroup CAN_synchronisation_jump_width CAN Synchronisation Jump Width
N  * @{
N  */
N#define CAN_SJW_1TQ                 ((uint32_t)0x00000000U)     /*!< 1 time quantum */
N#define CAN_SJW_2TQ                 ((uint32_t)CAN_BTR_SJW_0)  /*!< 2 time quantum */
N#define CAN_SJW_3TQ                 ((uint32_t)CAN_BTR_SJW_1)  /*!< 3 time quantum */
N#define CAN_SJW_4TQ                 ((uint32_t)CAN_BTR_SJW)    /*!< 4 time quantum */
N/**
N  * @}
N  */
N
N/** @defgroup CAN_time_quantum_in_bit_segment_1 CAN Time Quantum in bit segment 1
N  * @{
N  */
N#define CAN_BS1_1TQ                 ((uint32_t)0x00000000U)                                       /*!< 1 time quantum  */
N#define CAN_BS1_2TQ                 ((uint32_t)CAN_BTR_TS1_0)                                    /*!< 2 time quantum  */
N#define CAN_BS1_3TQ                 ((uint32_t)CAN_BTR_TS1_1)                                    /*!< 3 time quantum  */
N#define CAN_BS1_4TQ                 ((uint32_t)(CAN_BTR_TS1_1 | CAN_BTR_TS1_0))                  /*!< 4 time quantum  */
N#define CAN_BS1_5TQ                 ((uint32_t)CAN_BTR_TS1_2)                                    /*!< 5 time quantum  */
N#define CAN_BS1_6TQ                 ((uint32_t)(CAN_BTR_TS1_2 | CAN_BTR_TS1_0))                  /*!< 6 time quantum  */
N#define CAN_BS1_7TQ                 ((uint32_t)(CAN_BTR_TS1_2 | CAN_BTR_TS1_1))                  /*!< 7 time quantum  */
N#define CAN_BS1_8TQ                 ((uint32_t)(CAN_BTR_TS1_2 | CAN_BTR_TS1_1 | CAN_BTR_TS1_0))  /*!< 8 time quantum  */
N#define CAN_BS1_9TQ                 ((uint32_t)CAN_BTR_TS1_3)                                    /*!< 9 time quantum  */
N#define CAN_BS1_10TQ                ((uint32_t)(CAN_BTR_TS1_3 | CAN_BTR_TS1_0))                  /*!< 10 time quantum */
N#define CAN_BS1_11TQ                ((uint32_t)(CAN_BTR_TS1_3 | CAN_BTR_TS1_1))                  /*!< 11 time quantum */
N#define CAN_BS1_12TQ                ((uint32_t)(CAN_BTR_TS1_3 | CAN_BTR_TS1_1 | CAN_BTR_TS1_0))  /*!< 12 time quantum */
N#define CAN_BS1_13TQ                ((uint32_t)(CAN_BTR_TS1_3 | CAN_BTR_TS1_2))                  /*!< 13 time quantum */
N#define CAN_BS1_14TQ                ((uint32_t)(CAN_BTR_TS1_3 | CAN_BTR_TS1_2 | CAN_BTR_TS1_0))  /*!< 14 time quantum */
N#define CAN_BS1_15TQ                ((uint32_t)(CAN_BTR_TS1_3 | CAN_BTR_TS1_2 | CAN_BTR_TS1_1))  /*!< 15 time quantum */
N#define CAN_BS1_16TQ                ((uint32_t)CAN_BTR_TS1) /*!< 16 time quantum */
N/**
N  * @}
N  */
N
N/** @defgroup CAN_time_quantum_in_bit_segment_2 CAN Time Quantum in bit segment 2
N  * @{
N  */
N#define CAN_BS2_1TQ                 ((uint32_t)0x00000000U)                       /*!< 1 time quantum */
N#define CAN_BS2_2TQ                 ((uint32_t)CAN_BTR_TS2_0)                    /*!< 2 time quantum */
N#define CAN_BS2_3TQ                 ((uint32_t)CAN_BTR_TS2_1)                    /*!< 3 time quantum */
N#define CAN_BS2_4TQ                 ((uint32_t)(CAN_BTR_TS2_1 | CAN_BTR_TS2_0))  /*!< 4 time quantum */
N#define CAN_BS2_5TQ                 ((uint32_t)CAN_BTR_TS2_2)                    /*!< 5 time quantum */
N#define CAN_BS2_6TQ                 ((uint32_t)(CAN_BTR_TS2_2 | CAN_BTR_TS2_0))  /*!< 6 time quantum */
N#define CAN_BS2_7TQ                 ((uint32_t)(CAN_BTR_TS2_2 | CAN_BTR_TS2_1))  /*!< 7 time quantum */
N#define CAN_BS2_8TQ                 ((uint32_t)CAN_BTR_TS2)                      /*!< 8 time quantum */
N/**
N  * @}
N  */
N
N/** @defgroup CAN_filter_mode  CAN Filter Mode
N  * @{
N  */
N#define CAN_FILTERMODE_IDMASK       ((uint8_t)0x00U)  /*!< Identifier mask mode */
N#define CAN_FILTERMODE_IDLIST       ((uint8_t)0x01U)  /*!< Identifier list mode */
N/**
N  * @}
N  */
N
N/** @defgroup CAN_filter_scale CAN Filter Scale
N  * @{
N  */
N#define CAN_FILTERSCALE_16BIT       ((uint8_t)0x00U)  /*!< Two 16-bit filters */
N#define CAN_FILTERSCALE_32BIT       ((uint8_t)0x01U)  /*!< One 32-bit filter  */
N/**
N  * @}
N  */
N
N/** @defgroup CAN_filter_FIFO CAN Filter FIFO
N  * @{
N  */
N#define CAN_FILTER_FIFO0             ((uint8_t)0x00U)  /*!< Filter FIFO 0 assignment for filter x */
N#define CAN_FILTER_FIFO1             ((uint8_t)0x01U)  /*!< Filter FIFO 1 assignment for filter x */
N/**
N  * @}
N  */
N
N/** @defgroup CAN_Identifier_Type CAN Identifier Type
N  * @{
N  */
N#define CAN_ID_STD             ((uint32_t)0x00000000U)  /*!< Standard Id */
N#define CAN_ID_EXT             ((uint32_t)0x00000004U)  /*!< Extended Id */
N/**
N  * @}
N  */
N
N/** @defgroup CAN_remote_transmission_request CAN Remote Transmission Request
N  * @{
N  */
N#define CAN_RTR_DATA                ((uint32_t)0x00000000U)  /*!< Data frame */
N#define CAN_RTR_REMOTE              ((uint32_t)0x00000002U)  /*!< Remote frame */
N/**
N  * @}
N  */
N
N/** @defgroup CAN_receive_FIFO_number_constants CAN Receive FIFO Number Constants
N  * @{
N  */
N#define CAN_FIFO0                   ((uint8_t)0x00U)  /*!< CAN FIFO 0 used to receive */
N#define CAN_FIFO1                   ((uint8_t)0x01U)  /*!< CAN FIFO 1 used to receive */
N/**
N  * @}
N  */
N
N/** @defgroup CAN_flags CAN Flags
N  * @{
N  */
N/* If the flag is 0x3XXXXXXX, it means that it can be used with CAN_GetFlagStatus()
N   and CAN_ClearFlag() functions. */
N/* If the flag is 0x1XXXXXXX, it means that it can only be used with
N   CAN_GetFlagStatus() function.  */
N
N/* Transmit Flags */
N#define CAN_FLAG_RQCP0             ((uint32_t)0x00000500U)  /*!< Request MailBox0 flag         */
N#define CAN_FLAG_RQCP1             ((uint32_t)0x00000508U)  /*!< Request MailBox1 flag         */
N#define CAN_FLAG_RQCP2             ((uint32_t)0x00000510U)  /*!< Request MailBox2 flag         */
N#define CAN_FLAG_TXOK0             ((uint32_t)0x00000501U)  /*!< Transmission OK MailBox0 flag */
N#define CAN_FLAG_TXOK1             ((uint32_t)0x00000509U)  /*!< Transmission OK MailBox1 flag */
N#define CAN_FLAG_TXOK2             ((uint32_t)0x00000511U)  /*!< Transmission OK MailBox2 flag */
N#define CAN_FLAG_TME0              ((uint32_t)0x0000051AU)  /*!< Transmit mailbox 0 empty flag */
N#define CAN_FLAG_TME1              ((uint32_t)0x0000051BU)  /*!< Transmit mailbox 0 empty flag */
N#define CAN_FLAG_TME2              ((uint32_t)0x0000051CU)  /*!< Transmit mailbox 0 empty flag */
N
N/* Receive Flags */
N#define CAN_FLAG_FF0               ((uint32_t)0x00000203U)  /*!< FIFO 0 Full flag    */
N#define CAN_FLAG_FOV0              ((uint32_t)0x00000204U)  /*!< FIFO 0 Overrun flag */
N
N#define CAN_FLAG_FF1               ((uint32_t)0x00000403U)  /*!< FIFO 1 Full flag    */
N#define CAN_FLAG_FOV1              ((uint32_t)0x00000404U)  /*!< FIFO 1 Overrun flag */
N
N/* Operating Mode Flags */
N#define CAN_FLAG_INAK              ((uint32_t)0x00000100U)  /*!<  Initialization acknowledge flag */
N#define CAN_FLAG_SLAK              ((uint32_t)0x00000101U)  /*!< Sleep acknowledge flag */
N#define CAN_FLAG_ERRI              ((uint32_t)0x00000102U)  /*!<  Error flag */
N#define CAN_FLAG_WKU               ((uint32_t)0x00000103U)  /*!< Wake up flag           */
N#define CAN_FLAG_SLAKI             ((uint32_t)0x00000104U)  /*!< Sleep acknowledge flag */
N
N/* @note When SLAK interrupt is disabled (SLKIE=0), no polling on SLAKI is possible.
N         In this case the SLAK bit can be polled.*/
N
N/* Error Flags */
N#define CAN_FLAG_EWG               ((uint32_t)0x00000300U)  /*!< Error warning flag   */
N#define CAN_FLAG_EPV               ((uint32_t)0x00000301U)  /*!< Error passive flag   */
N#define CAN_FLAG_BOF               ((uint32_t)0x00000302U)  /*!< Bus-Off flag         */
N/**
N  * @}
N  */
N
N/** @defgroup CAN_Interrupts CAN Interrupts
N  * @{
N  */
N#define CAN_IT_TME                  ((uint32_t)CAN_IER_TMEIE)   /*!< Transmit mailbox empty interrupt */
N
N/* Receive Interrupts */
N#define CAN_IT_FMP0                 ((uint32_t)CAN_IER_FMPIE0)  /*!< FIFO 0 message pending interrupt */
N#define CAN_IT_FF0                  ((uint32_t)CAN_IER_FFIE0)   /*!< FIFO 0 full interrupt            */
N#define CAN_IT_FOV0                 ((uint32_t)CAN_IER_FOVIE0)  /*!< FIFO 0 overrun interrupt         */
N#define CAN_IT_FMP1                 ((uint32_t)CAN_IER_FMPIE1)  /*!< FIFO 1 message pending interrupt */
N#define CAN_IT_FF1                  ((uint32_t)CAN_IER_FFIE1)   /*!< FIFO 1 full interrupt            */
N#define CAN_IT_FOV1                 ((uint32_t)CAN_IER_FOVIE1)  /*!< FIFO 1 overrun interrupt         */
N
N/* Operating Mode Interrupts */
N#define CAN_IT_WKU                  ((uint32_t)CAN_IER_WKUIE)  /*!< Wake-up interrupt           */
N#define CAN_IT_SLK                  ((uint32_t)CAN_IER_SLKIE)  /*!< Sleep acknowledge interrupt */
N
N/* Error Interrupts */
N#define CAN_IT_EWG                  ((uint32_t)CAN_IER_EWGIE) /*!< Error warning interrupt   */
N#define CAN_IT_EPV                  ((uint32_t)CAN_IER_EPVIE) /*!< Error passive interrupt   */
N#define CAN_IT_BOF                  ((uint32_t)CAN_IER_BOFIE) /*!< Bus-off interrupt         */
N#define CAN_IT_LEC                  ((uint32_t)CAN_IER_LECIE) /*!< Last error code interrupt */
N#define CAN_IT_ERR                  ((uint32_t)CAN_IER_ERRIE) /*!< Error Interrupt           */
N/**
N  * @}
N  */
N
N/** @defgroup CAN_Mailboxes_Definition CAN Mailboxes Definition
N  * @{
N  */
N#define CAN_TXMAILBOX_0   ((uint8_t)0x00U)
N#define CAN_TXMAILBOX_1   ((uint8_t)0x01U)
N#define CAN_TXMAILBOX_2   ((uint8_t)0x02U)
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup CAN_Exported_Macros CAN Exported Macros
N  * @{
N  */
N
N/** @brief Reset CAN handle state
N  * @param  __HANDLE__: specifies the CAN Handle.
N  * @retval None
N  */
N#define __HAL_CAN_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_CAN_STATE_RESET)
N
N/**
N  * @brief  Enable the specified CAN interrupts.
N  * @param  __HANDLE__: CAN handle
N  * @param  __INTERRUPT__: CAN Interrupt
N  * @retval None
N  */
N#define __HAL_CAN_ENABLE_IT(__HANDLE__, __INTERRUPT__) (((__HANDLE__)->Instance->IER) |= (__INTERRUPT__))
N
N/**
N  * @brief  Disable the specified CAN interrupts.
N  * @param  __HANDLE__: CAN handle
N  * @param  __INTERRUPT__: CAN Interrupt
N  * @retval None
N  */
N#define __HAL_CAN_DISABLE_IT(__HANDLE__, __INTERRUPT__) (((__HANDLE__)->Instance->IER) &= ~(__INTERRUPT__))
N
N/**
N  * @brief  Return the number of pending received messages.
N  * @param  __HANDLE__: CAN handle
N  * @param  __FIFONUMBER__: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
N  * @retval The number of pending message.
N  */
N#define __HAL_CAN_MSG_PENDING(__HANDLE__, __FIFONUMBER__) (((__FIFONUMBER__) == CAN_FIFO0)? \
N((uint8_t)((__HANDLE__)->Instance->RF0R&(uint32_t)0x03)) : ((uint8_t)((__HANDLE__)->Instance->RF1R&(uint32_t)0x03)))
X#define __HAL_CAN_MSG_PENDING(__HANDLE__, __FIFONUMBER__) (((__FIFONUMBER__) == CAN_FIFO0)? ((uint8_t)((__HANDLE__)->Instance->RF0R&(uint32_t)0x03)) : ((uint8_t)((__HANDLE__)->Instance->RF1R&(uint32_t)0x03)))
N
N/** @brief  Check whether the specified CAN flag is set or not.
N  * @param  __HANDLE__: CAN Handle
N  * @param  __FLAG__: specifies the flag to check.
N  *         This parameter can be one of the following values:
N  *            @arg CAN_TSR_RQCP0: Request MailBox0 Flag
N  *            @arg CAN_TSR_RQCP1: Request MailBox1 Flag
N  *            @arg CAN_TSR_RQCP2: Request MailBox2 Flag
N  *            @arg CAN_FLAG_TXOK0: Transmission OK MailBox0 Flag
N  *            @arg CAN_FLAG_TXOK1: Transmission OK MailBox1 Flag
N  *            @arg CAN_FLAG_TXOK2: Transmission OK MailBox2 Flag
N  *            @arg CAN_FLAG_TME0: Transmit mailbox 0 empty Flag
N  *            @arg CAN_FLAG_TME1: Transmit mailbox 1 empty Flag
N  *            @arg CAN_FLAG_TME2: Transmit mailbox 2 empty Flag
N  *            @arg CAN_FLAG_FMP0: FIFO 0 Message Pending Flag
N  *            @arg CAN_FLAG_FF0: FIFO 0 Full Flag
N  *            @arg CAN_FLAG_FOV0: FIFO 0 Overrun Flag
N  *            @arg CAN_FLAG_FMP1: FIFO 1 Message Pending Flag
N  *            @arg CAN_FLAG_FF1: FIFO 1 Full Flag
N  *            @arg CAN_FLAG_FOV1: FIFO 1 Overrun Flag
N  *            @arg CAN_FLAG_WKU: Wake up Flag
N  *            @arg CAN_FLAG_SLAK: Sleep acknowledge Flag
N  *            @arg CAN_FLAG_SLAKI: Sleep acknowledge Flag
N  *            @arg CAN_FLAG_EWG: Error Warning Flag
N  *            @arg CAN_FLAG_EPV: Error Passive Flag
N  *            @arg CAN_FLAG_BOF: Bus-Off Flag
N  * @retval The new state of __FLAG__ (TRUE or FALSE).
N  */
N#define __HAL_CAN_GET_FLAG(__HANDLE__, __FLAG__) \
N((((__FLAG__) >> 8) == 5)? ((((__HANDLE__)->Instance->TSR) & (1 << ((__FLAG__) & CAN_FLAG_MASK))) == (1 << ((__FLAG__) & CAN_FLAG_MASK))): \
N (((__FLAG__) >> 8) == 2)? ((((__HANDLE__)->Instance->RF0R) & (1 << ((__FLAG__) & CAN_FLAG_MASK))) == (1 << ((__FLAG__) & CAN_FLAG_MASK))): \
N (((__FLAG__) >> 8) == 4)? ((((__HANDLE__)->Instance->RF1R) & (1 << ((__FLAG__) & CAN_FLAG_MASK))) == (1 << ((__FLAG__) & CAN_FLAG_MASK))): \
N (((__FLAG__) >> 8) == 1)? ((((__HANDLE__)->Instance->MSR) & (1 << ((__FLAG__) & CAN_FLAG_MASK))) == (1 << ((__FLAG__) & CAN_FLAG_MASK))): \
N ((((__HANDLE__)->Instance->ESR) & (1 << ((__FLAG__) & CAN_FLAG_MASK))) == (1 << ((__FLAG__) & CAN_FLAG_MASK))))
X#define __HAL_CAN_GET_FLAG(__HANDLE__, __FLAG__) ((((__FLAG__) >> 8) == 5)? ((((__HANDLE__)->Instance->TSR) & (1 << ((__FLAG__) & CAN_FLAG_MASK))) == (1 << ((__FLAG__) & CAN_FLAG_MASK))):  (((__FLAG__) >> 8) == 2)? ((((__HANDLE__)->Instance->RF0R) & (1 << ((__FLAG__) & CAN_FLAG_MASK))) == (1 << ((__FLAG__) & CAN_FLAG_MASK))):  (((__FLAG__) >> 8) == 4)? ((((__HANDLE__)->Instance->RF1R) & (1 << ((__FLAG__) & CAN_FLAG_MASK))) == (1 << ((__FLAG__) & CAN_FLAG_MASK))):  (((__FLAG__) >> 8) == 1)? ((((__HANDLE__)->Instance->MSR) & (1 << ((__FLAG__) & CAN_FLAG_MASK))) == (1 << ((__FLAG__) & CAN_FLAG_MASK))):  ((((__HANDLE__)->Instance->ESR) & (1 << ((__FLAG__) & CAN_FLAG_MASK))) == (1 << ((__FLAG__) & CAN_FLAG_MASK))))
N
N/** @brief  Clear the specified CAN pending flag.
N  * @param  __HANDLE__: CAN Handle.
N  * @param  __FLAG__: specifies the flag to check.
N  *         This parameter can be one of the following values:
N  *            @arg CAN_TSR_RQCP0: Request MailBox0 Flag
N  *            @arg CAN_TSR_RQCP1: Request MailBox1 Flag
N  *            @arg CAN_TSR_RQCP2: Request MailBox2 Flag
N  *            @arg CAN_FLAG_TXOK0: Transmission OK MailBox0 Flag
N  *            @arg CAN_FLAG_TXOK1: Transmission OK MailBox1 Flag
N  *            @arg CAN_FLAG_TXOK2: Transmission OK MailBox2 Flag
N  *            @arg CAN_FLAG_TME0: Transmit mailbox 0 empty Flag
N  *            @arg CAN_FLAG_TME1: Transmit mailbox 1 empty Flag
N  *            @arg CAN_FLAG_TME2: Transmit mailbox 2 empty Flag
N  *            @arg CAN_FLAG_FMP0: FIFO 0 Message Pending Flag
N  *            @arg CAN_FLAG_FF0: FIFO 0 Full Flag
N  *            @arg CAN_FLAG_FOV0: FIFO 0 Overrun Flag
N  *            @arg CAN_FLAG_FMP1: FIFO 1 Message Pending Flag
N  *            @arg CAN_FLAG_FF1: FIFO 1 Full Flag
N  *            @arg CAN_FLAG_FOV1: FIFO 1 Overrun Flag
N  *            @arg CAN_FLAG_WKU: Wake up Flag
N  *            @arg CAN_FLAG_SLAK: Sleep acknowledge Flag
N  *            @arg CAN_FLAG_SLAKI: Sleep acknowledge Flag
N  * @retval The new state of __FLAG__ (TRUE or FALSE).
N  */
N#define __HAL_CAN_CLEAR_FLAG(__HANDLE__, __FLAG__) \
N((((__FLAG__) >> 8) == 5)? (((__HANDLE__)->Instance->TSR) = ((uint32_t)1 << ((__FLAG__) & CAN_FLAG_MASK))): \
N (((__FLAG__) >> 8) == 2)? (((__HANDLE__)->Instance->RF0R) = ((uint32_t)1 << ((__FLAG__) & CAN_FLAG_MASK))): \
N (((__FLAG__) >> 8) == 4)? (((__HANDLE__)->Instance->RF1R) = ((uint32_t)1 << ((__FLAG__) & CAN_FLAG_MASK))): \
N (((__HANDLE__)->Instance->MSR) = ((uint32_t)1 << ((__FLAG__) & CAN_FLAG_MASK))))
X#define __HAL_CAN_CLEAR_FLAG(__HANDLE__, __FLAG__) ((((__FLAG__) >> 8) == 5)? (((__HANDLE__)->Instance->TSR) = ((uint32_t)1 << ((__FLAG__) & CAN_FLAG_MASK))):  (((__FLAG__) >> 8) == 2)? (((__HANDLE__)->Instance->RF0R) = ((uint32_t)1 << ((__FLAG__) & CAN_FLAG_MASK))):  (((__FLAG__) >> 8) == 4)? (((__HANDLE__)->Instance->RF1R) = ((uint32_t)1 << ((__FLAG__) & CAN_FLAG_MASK))):  (((__HANDLE__)->Instance->MSR) = ((uint32_t)1 << ((__FLAG__) & CAN_FLAG_MASK))))
N
N/** @brief  Check if the specified CAN interrupt source is enabled or disabled.
N  * @param  __HANDLE__: CAN Handle
N  * @param  __INTERRUPT__: specifies the CAN interrupt source to check.
N  *          This parameter can be one of the following values:
N  *             @arg CAN_IT_TME: Transmit mailbox empty interrupt enable
N  *             @arg CAN_IT_FMP0: FIFO0 message pending interrupt enable
N  *             @arg CAN_IT_FMP1: FIFO1 message pending interrupt enable
N  * @retval The new state of __IT__ (TRUE or FALSE).
N  */
N#define __HAL_CAN_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) ((((__HANDLE__)->Instance->IER & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)
N
N/**
N  * @brief  Check the transmission status of a CAN Frame.
N  * @param  __HANDLE__: CAN Handle
N  * @param  __TRANSMITMAILBOX__: the number of the mailbox that is used for transmission.
N  * @retval The new status of transmission  (TRUE or FALSE).
N  */
N#define __HAL_CAN_TRANSMIT_STATUS(__HANDLE__, __TRANSMITMAILBOX__)\
N(((__TRANSMITMAILBOX__) == CAN_TXMAILBOX_0)? ((((__HANDLE__)->Instance->TSR) & (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0)) == (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0)) :\
N ((__TRANSMITMAILBOX__) == CAN_TXMAILBOX_1)? ((((__HANDLE__)->Instance->TSR) & (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1)) == (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1)) :\
N ((((__HANDLE__)->Instance->TSR) & (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2)) == (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2)))
X#define __HAL_CAN_TRANSMIT_STATUS(__HANDLE__, __TRANSMITMAILBOX__)(((__TRANSMITMAILBOX__) == CAN_TXMAILBOX_0)? ((((__HANDLE__)->Instance->TSR) & (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0)) == (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0)) : ((__TRANSMITMAILBOX__) == CAN_TXMAILBOX_1)? ((((__HANDLE__)->Instance->TSR) & (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1)) == (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1)) : ((((__HANDLE__)->Instance->TSR) & (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2)) == (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2)))
N
N/**
N  * @brief  Release the specified receive FIFO.
N  * @param  __HANDLE__: CAN handle
N  * @param  __FIFONUMBER__: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
N  * @retval None
N  */
N#define __HAL_CAN_FIFO_RELEASE(__HANDLE__, __FIFONUMBER__) (((__FIFONUMBER__) == CAN_FIFO0)? \
N((__HANDLE__)->Instance->RF0R = CAN_RF0R_RFOM0) : ((__HANDLE__)->Instance->RF1R = CAN_RF1R_RFOM1))
X#define __HAL_CAN_FIFO_RELEASE(__HANDLE__, __FIFONUMBER__) (((__FIFONUMBER__) == CAN_FIFO0)? ((__HANDLE__)->Instance->RF0R = CAN_RF0R_RFOM0) : ((__HANDLE__)->Instance->RF1R = CAN_RF1R_RFOM1))
N
N/**
N  * @brief  Cancel a transmit request.
N  * @param  __HANDLE__: CAN Handle
N  * @param  __TRANSMITMAILBOX__: the number of the mailbox that is used for transmission.
N  * @retval None
N  */
N#define __HAL_CAN_CANCEL_TRANSMIT(__HANDLE__, __TRANSMITMAILBOX__)\
N(((__TRANSMITMAILBOX__) == CAN_TXMAILBOX_0)? ((__HANDLE__)->Instance->TSR = CAN_TSR_ABRQ0) :\
N ((__TRANSMITMAILBOX__) == CAN_TXMAILBOX_1)? ((__HANDLE__)->Instance->TSR = CAN_TSR_ABRQ1) :\
N ((__HANDLE__)->Instance->TSR = CAN_TSR_ABRQ2))
X#define __HAL_CAN_CANCEL_TRANSMIT(__HANDLE__, __TRANSMITMAILBOX__)(((__TRANSMITMAILBOX__) == CAN_TXMAILBOX_0)? ((__HANDLE__)->Instance->TSR = CAN_TSR_ABRQ0) : ((__TRANSMITMAILBOX__) == CAN_TXMAILBOX_1)? ((__HANDLE__)->Instance->TSR = CAN_TSR_ABRQ1) : ((__HANDLE__)->Instance->TSR = CAN_TSR_ABRQ2))
N
N/**
N  * @brief  Enable or disable the DBG Freeze for CAN.
N  * @param  __HANDLE__: CAN Handle
N  * @param  __NEWSTATE__: new state of the CAN peripheral.
N  *          This parameter can be: ENABLE (CAN reception/transmission is frozen
N  *          during debug. Reception FIFOs can still be accessed/controlled normally)
N  *          or DISABLE (CAN is working during debug).
N  * @retval None
N  */
N#define __HAL_CAN_DBG_FREEZE(__HANDLE__, __NEWSTATE__) (((__NEWSTATE__) == ENABLE)? \
N((__HANDLE__)->Instance->MCR |= CAN_MCR_DBF) : ((__HANDLE__)->Instance->MCR &= ~CAN_MCR_DBF))
X#define __HAL_CAN_DBG_FREEZE(__HANDLE__, __NEWSTATE__) (((__NEWSTATE__) == ENABLE)? ((__HANDLE__)->Instance->MCR |= CAN_MCR_DBF) : ((__HANDLE__)->Instance->MCR &= ~CAN_MCR_DBF))
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup CAN_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup CAN_Exported_Functions_Group1
N  * @{
N  */
N/* Initialization/de-initialization functions ***********************************/
NHAL_StatusTypeDef HAL_CAN_Init(CAN_HandleTypeDef* hcan);
NHAL_StatusTypeDef HAL_CAN_ConfigFilter(CAN_HandleTypeDef* hcan, CAN_FilterConfTypeDef* sFilterConfig);
NHAL_StatusTypeDef HAL_CAN_DeInit(CAN_HandleTypeDef* hcan);
Nvoid HAL_CAN_MspInit(CAN_HandleTypeDef* hcan);
Nvoid HAL_CAN_MspDeInit(CAN_HandleTypeDef* hcan);
N/**
N  * @}
N  */
N
N/** @addtogroup CAN_Exported_Functions_Group2
N  * @{
N  */
N/* I/O operation functions ******************************************************/
NHAL_StatusTypeDef HAL_CAN_Transmit(CAN_HandleTypeDef *hcan, uint32_t Timeout);
NHAL_StatusTypeDef HAL_CAN_Transmit_IT(CAN_HandleTypeDef *hcan);
NHAL_StatusTypeDef HAL_CAN_Receive(CAN_HandleTypeDef *hcan, uint8_t FIFONumber, uint32_t Timeout);
NHAL_StatusTypeDef HAL_CAN_Receive_IT(CAN_HandleTypeDef *hcan, uint8_t FIFONumber);
NHAL_StatusTypeDef HAL_CAN_Sleep(CAN_HandleTypeDef *hcan);
NHAL_StatusTypeDef HAL_CAN_WakeUp(CAN_HandleTypeDef *hcan);
Nvoid HAL_CAN_IRQHandler(CAN_HandleTypeDef* hcan);
Nvoid HAL_CAN_TxCpltCallback(CAN_HandleTypeDef* hcan);
Nvoid HAL_CAN_RxCpltCallback(CAN_HandleTypeDef* hcan);
Nvoid HAL_CAN_ErrorCallback(CAN_HandleTypeDef *hcan);
N/**
N  * @}
N  */
N
N/** @addtogroup CAN_Exported_Functions_Group3
N  * @{
N  */
N/* Peripheral State functions ***************************************************/
Nuint32_t HAL_CAN_GetError(CAN_HandleTypeDef *hcan);
NHAL_CAN_StateTypeDef HAL_CAN_GetState(CAN_HandleTypeDef* hcan);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private types -------------------------------------------------------------*/
N/** @defgroup CAN_Private_Types CAN Private Types
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/* Private variables ---------------------------------------------------------*/
N/** @defgroup CAN_Private_Variables CAN Private Variables
N  * @{
N  */
N
N/**
N  * @}
N  */ 
N
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup CAN_Private_Constants CAN Private Constants
N  * @{
N  */
N#define CAN_TXSTATUS_NOMAILBOX      ((uint8_t)0x04U)  /*!< CAN cell did not provide CAN_TxStatus_NoMailBox */
N#define CAN_FLAG_MASK  ((uint32_t)0x000000FFU)
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup CAN_Private_Macros CAN Private Macros
N  * @{
N  */
N#define IS_CAN_MODE(MODE) (((MODE) == CAN_MODE_NORMAL) || \
N                           ((MODE) == CAN_MODE_LOOPBACK)|| \
N                           ((MODE) == CAN_MODE_SILENT) || \
N                           ((MODE) == CAN_MODE_SILENT_LOOPBACK))
X#define IS_CAN_MODE(MODE) (((MODE) == CAN_MODE_NORMAL) ||                            ((MODE) == CAN_MODE_LOOPBACK)||                            ((MODE) == CAN_MODE_SILENT) ||                            ((MODE) == CAN_MODE_SILENT_LOOPBACK))
N#define IS_CAN_SJW(SJW) (((SJW) == CAN_SJW_1TQ) || ((SJW) == CAN_SJW_2TQ)|| \
N                         ((SJW) == CAN_SJW_3TQ) || ((SJW) == CAN_SJW_4TQ))
X#define IS_CAN_SJW(SJW) (((SJW) == CAN_SJW_1TQ) || ((SJW) == CAN_SJW_2TQ)||                          ((SJW) == CAN_SJW_3TQ) || ((SJW) == CAN_SJW_4TQ))
N#define IS_CAN_BS1(BS1) ((BS1) <= CAN_BS1_16TQ)
N#define IS_CAN_BS2(BS2) ((BS2) <= CAN_BS2_8TQ)
N#define IS_CAN_PRESCALER(PRESCALER) (((PRESCALER) >= 1) && ((PRESCALER) <= 1024))
N#define IS_CAN_FILTER_NUMBER(NUMBER) ((NUMBER) <= 27)
N#define IS_CAN_FILTER_MODE(MODE) (((MODE) == CAN_FILTERMODE_IDMASK) || \
N                                  ((MODE) == CAN_FILTERMODE_IDLIST))
X#define IS_CAN_FILTER_MODE(MODE) (((MODE) == CAN_FILTERMODE_IDMASK) ||                                   ((MODE) == CAN_FILTERMODE_IDLIST))
N#define IS_CAN_FILTER_SCALE(SCALE) (((SCALE) == CAN_FILTERSCALE_16BIT) || \
N                                    ((SCALE) == CAN_FILTERSCALE_32BIT))
X#define IS_CAN_FILTER_SCALE(SCALE) (((SCALE) == CAN_FILTERSCALE_16BIT) ||                                     ((SCALE) == CAN_FILTERSCALE_32BIT))
N#define IS_CAN_FILTER_FIFO(FIFO) (((FIFO) == CAN_FILTER_FIFO0) || \
N                                  ((FIFO) == CAN_FILTER_FIFO1))
X#define IS_CAN_FILTER_FIFO(FIFO) (((FIFO) == CAN_FILTER_FIFO0) ||                                   ((FIFO) == CAN_FILTER_FIFO1))
N#define IS_CAN_BANKNUMBER(BANKNUMBER) ((BANKNUMBER) <= 28)
N
N#define IS_CAN_TRANSMITMAILBOX(TRANSMITMAILBOX) ((TRANSMITMAILBOX) <= ((uint8_t)0x02))
N#define IS_CAN_STDID(STDID)   ((STDID) <= ((uint32_t)0x7FF))
N#define IS_CAN_EXTID(EXTID)   ((EXTID) <= ((uint32_t)0x1FFFFFFF))
N#define IS_CAN_DLC(DLC)       ((DLC) <= ((uint8_t)0x08))
N
N#define IS_CAN_IDTYPE(IDTYPE)  (((IDTYPE) == CAN_ID_STD) || \
N                                ((IDTYPE) == CAN_ID_EXT))
X#define IS_CAN_IDTYPE(IDTYPE)  (((IDTYPE) == CAN_ID_STD) ||                                 ((IDTYPE) == CAN_ID_EXT))
N#define IS_CAN_RTR(RTR) (((RTR) == CAN_RTR_DATA) || ((RTR) == CAN_RTR_REMOTE))
N#define IS_CAN_FIFO(FIFO) (((FIFO) == CAN_FIFO0) || ((FIFO) == CAN_FIFO1))
N
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup CAN_Private_Functions CAN Private Functions
N  * @{
N  */
N
N/**
N  * @}
N  */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_CAN_H */
N
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 267 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_CAN_MODULE_ENABLED */
N
N#ifdef HAL_CEC_MODULE_ENABLED
N  #include "stm32f7xx_hal_cec.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_cec.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_cec.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of CEC HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************  
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_CEC_H
N#define __STM32F7xx_HAL_CEC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup CEC
N  * @{
N  */
N  
N/* Exported types ------------------------------------------------------------*/ 
N/** @defgroup CEC_Exported_Types CEC Exported Types
N  * @{
N  */
N  
N/** 
N  * @brief CEC Init Structure definition  
N  */ 
Ntypedef struct
N{
N  uint32_t SignalFreeTime;               /*!< Set SFT field, specifies the Signal Free Time.
N                                              It can be one of @ref CEC_Signal_Free_Time 
N                                              and belongs to the set {0,...,7} where  
N                                              0x0 is the default configuration 
N                                              else means 0.5 + (SignalFreeTime - 1) nominal data bit periods */
N
N  uint32_t Tolerance;                    /*!< Set RXTOL bit, specifies the tolerance accepted on the received waveforms,
N                                              it can be a value of @ref CEC_Tolerance : it is either CEC_STANDARD_TOLERANCE 
N                                              or CEC_EXTENDED_TOLERANCE */
N
N  uint32_t BRERxStop;                    /*!< Set BRESTP bit @ref CEC_BRERxStop : specifies whether or not a Bit Rising Error stops the reception. 
N                                              CEC_NO_RX_STOP_ON_BRE: reception is not stopped. 
N                                              CEC_RX_STOP_ON_BRE:    reception is stopped. */
N
N  uint32_t BREErrorBitGen;               /*!< Set BREGEN bit @ref CEC_BREErrorBitGen : specifies whether or not an Error-Bit is generated on the
N                                              CEC line upon Bit Rising Error detection.
N                                              CEC_BRE_ERRORBIT_NO_GENERATION: no error-bit generation.
N                                              CEC_BRE_ERRORBIT_GENERATION:    error-bit generation if BRESTP is set. */
N                                              
N  uint32_t LBPEErrorBitGen;              /*!< Set LBPEGEN bit @ref CEC_LBPEErrorBitGen : specifies whether or not an Error-Bit is generated on the
N                                              CEC line upon Long Bit Period Error detection.
N                                              CEC_LBPE_ERRORBIT_NO_GENERATION:  no error-bit generation. 
N                                              CEC_LBPE_ERRORBIT_GENERATION:     error-bit generation. */  
N                                              
N  uint32_t BroadcastMsgNoErrorBitGen;    /*!< Set BRDNOGEN bit @ref CEC_BroadCastMsgErrorBitGen : allows to avoid an Error-Bit generation on the CEC line
N                                              upon an error detected on a broadcast message. 
N                                              
N                                              It supersedes BREGEN and LBPEGEN bits for a broadcast message error handling. It can take two values:
N                                              
N                                              1) CEC_BROADCASTERROR_ERRORBIT_GENERATION.
N                                                 a) BRE detection: error-bit generation on the CEC line if BRESTP=CEC_RX_STOP_ON_BRE 
N                                                    and BREGEN=CEC_BRE_ERRORBIT_NO_GENERATION.
N                                                 b) LBPE detection: error-bit generation on the CEC line 
N                                                    if LBPGEN=CEC_LBPE_ERRORBIT_NO_GENERATION.
N                                                    
N                                              2) CEC_BROADCASTERROR_NO_ERRORBIT_GENERATION.
N                                                 no error-bit generation in case neither a) nor b) are satisfied. Additionally,
N                                                 there is no error-bit generation in case of Short Bit Period Error detection in 
N                                                 a broadcast message while LSTN bit is set. */
N 
N  uint32_t SignalFreeTimeOption;         /*!< Set SFTOP bit @ref CEC_SFT_Option : specifies when SFT timer starts.
N                                              CEC_SFT_START_ON_TXSOM SFT:    timer starts when TXSOM is set by software.
N                                              CEC_SFT_START_ON_TX_RX_END:  SFT timer starts automatically at the end of message transmission/reception. */
N  
N  uint32_t ListenMode;                   /*!< Set LSTN bit @ref CEC_Listening_Mode : specifies device listening mode. It can take two values:
N  
N                                              CEC_REDUCED_LISTENING_MODE: CEC peripheral receives only message addressed to its 
N                                                own address (OAR). Messages addressed to different destination are ignored. 
N                                                Broadcast messages are always received.
N                                                
N                                              CEC_FULL_LISTENING_MODE: CEC peripheral receives messages addressed to its own 
N                                                address (OAR) with positive acknowledge. Messages addressed to different destination 
N                                                are received, but without interfering with the CEC bus: no acknowledge sent.  */
N
N  uint16_t  OwnAddress;                 /*!< Own addresses configuration
N                                             This parameter can be a value of @ref CEC_OWN_ADDRESS */
N  
N  uint8_t  *RxBuffer;                    /*!< CEC Rx buffer pointeur */
N  
N
N}CEC_InitTypeDef;
N
N/** 
N  * @brief HAL CEC State structures definition 
N  * @note  HAL CEC State value is a combination of 2 different substates: gState and RxState.
N  *        - gState contains CEC state information related to global Handle management 
N  *          and also information related to Tx operations.
N  *          gState value coding follow below described bitmap :
N  *          b7 (not used)
N  *             x  : Should be set to 0
N  *          b6  Error information 
N  *             0  : No Error
N  *             1  : Error
N  *          b5     IP initilisation status
N  *             0  : Reset (IP not initialized)
N  *             1  : Init done (IP initialized. HAL CEC Init function already called)
N  *          b4-b3  (not used)
N  *             xx : Should be set to 00
N  *          b2     Intrinsic process state
N  *             0  : Ready
N  *             1  : Busy (IP busy with some configuration or internal operations)
N  *          b1     (not used)
N  *             x  : Should be set to 0
N  *          b0     Tx state
N  *             0  : Ready (no Tx operation ongoing)
N  *             1  : Busy (Tx operation ongoing)
N  *        - RxState contains information related to Rx operations.
N  *          RxState value coding follow below described bitmap :
N  *          b7-b6  (not used)
N  *             xx : Should be set to 00
N  *          b5     IP initilisation status
N  *             0  : Reset (IP not initialized)
N  *             1  : Init done (IP initialized)
N  *          b4-b2  (not used)
N  *            xxx : Should be set to 000
N  *          b1     Rx state
N  *             0  : Ready (no Rx operation ongoing)
N  *             1  : Busy (Rx operation ongoing)
N  *          b0     (not used)
N  *             x  : Should be set to 0.  
N  */ 
Ntypedef enum
N{
N  HAL_CEC_STATE_RESET             = 0x00U,    /*!< Peripheral is not yet Initialized 
N                                                   Value is allowed for gState and RxState             */
N  HAL_CEC_STATE_READY             = 0x20U,    /*!< Peripheral Initialized and ready for use
N                                                   Value is allowed for gState and RxState             */
N  HAL_CEC_STATE_BUSY              = 0x24U,    /*!< an internal process is ongoing
N                                                   Value is allowed for gState only                    */
N  HAL_CEC_STATE_BUSY_RX           = 0x22U,    /*!< Data Reception process is ongoing
N                                                   Value is allowed for RxState only                   */
N  HAL_CEC_STATE_BUSY_TX           = 0x21U,    /*!< Data Transmission process is ongoing 
N                                                   Value is allowed for gState only                    */                                                  
N  HAL_CEC_STATE_BUSY_RX_TX        = 0x23U,    /*!< an internal process is ongoing
N                                                   Value is allowed for gState only                    */
N  HAL_CEC_STATE_ERROR             = 0x60U     /*!< Error Value is allowed for gState only              */
N}HAL_CEC_StateTypeDef;
N
N/** 
N  * @brief  CEC handle Structure definition  
N  */  
Ntypedef struct
N{
N  CEC_TypeDef             *Instance;      /*!< CEC registers base address */
N  
N  CEC_InitTypeDef         Init;           /*!< CEC communication parameters */
N  
N  uint8_t                 *pTxBuffPtr;    /*!< Pointer to CEC Tx transfer Buffer */
N  
N  uint16_t                TxXferCount;    /*!< CEC Tx Transfer Counter */
N  
N  uint16_t                RxXferSize;     /*!< CEC Rx Transfer size, 0: header received only */
N  
N  HAL_LockTypeDef         Lock;           /*!< Locking object */
N
N  HAL_CEC_StateTypeDef    gState;         /*!< CEC state information related to global Handle management 
N                                               and also related to Tx operations.
N                                               This parameter can be a value of @ref HAL_CEC_StateTypeDef */
N  
N  HAL_CEC_StateTypeDef    RxState;        /*!< CEC state information related to Rx operations.
N                                               This parameter can be a value of @ref HAL_CEC_StateTypeDef */
N  
N  uint32_t                ErrorCode;      /*!< For errors handling purposes, copy of ISR register 
N                                               in case error is reported */    
N}CEC_HandleTypeDef;
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup CEC_Exported_Constants CEC Exported Constants
N  * @{
N  */
N
N/** @defgroup CEC_Error_Code CEC Error Code
N  * @{
N  */ 
N#define HAL_CEC_ERROR_NONE    (uint32_t) 0x0000U     /*!< no error                      */
N#define HAL_CEC_ERROR_RXOVR   CEC_ISR_RXOVR          /*!< CEC Rx-Overrun                */
N#define HAL_CEC_ERROR_BRE     CEC_ISR_BRE            /*!< CEC Rx Bit Rising Error       */
N#define HAL_CEC_ERROR_SBPE    CEC_ISR_SBPE           /*!< CEC Rx Short Bit period Error */
N#define HAL_CEC_ERROR_LBPE    CEC_ISR_LBPE           /*!< CEC Rx Long Bit period Error  */
N#define HAL_CEC_ERROR_RXACKE  CEC_ISR_RXACKE         /*!< CEC Rx Missing Acknowledge    */
N#define HAL_CEC_ERROR_ARBLST  CEC_ISR_ARBLST         /*!< CEC Arbitration Lost          */
N#define HAL_CEC_ERROR_TXUDR   CEC_ISR_TXUDR          /*!< CEC Tx-Buffer Underrun        */
N#define HAL_CEC_ERROR_TXERR   CEC_ISR_TXERR          /*!< CEC Tx-Error                  */
N#define HAL_CEC_ERROR_TXACKE  CEC_ISR_TXACKE         /*!< CEC Tx Missing Acknowledge    */
N/**
N  * @}
N  */
N       
N/** @defgroup CEC_Signal_Free_Time  CEC Signal Free Time setting parameter
N  * @{
N  */
N#define CEC_DEFAULT_SFT                    ((uint32_t)0x00000000U)
N#define CEC_0_5_BITPERIOD_SFT              ((uint32_t)0x00000001U)
N#define CEC_1_5_BITPERIOD_SFT              ((uint32_t)0x00000002U)
N#define CEC_2_5_BITPERIOD_SFT              ((uint32_t)0x00000003U)
N#define CEC_3_5_BITPERIOD_SFT              ((uint32_t)0x00000004U)
N#define CEC_4_5_BITPERIOD_SFT              ((uint32_t)0x00000005U)
N#define CEC_5_5_BITPERIOD_SFT              ((uint32_t)0x00000006U)
N#define CEC_6_5_BITPERIOD_SFT              ((uint32_t)0x00000007U)
N/**
N  * @}
N  */
N
N/** @defgroup CEC_Tolerance CEC Receiver Tolerance
N  * @{
N  */
N#define CEC_STANDARD_TOLERANCE             ((uint32_t)0x00000000U)
N#define CEC_EXTENDED_TOLERANCE             ((uint32_t)CEC_CFGR_RXTOL)
N/**
N  * @}
N  */ 
N
N/** @defgroup CEC_BRERxStop CEC Reception Stop on Error
N  * @{
N  */
N#define CEC_NO_RX_STOP_ON_BRE             ((uint32_t)0x00000000U)
N#define CEC_RX_STOP_ON_BRE                ((uint32_t)CEC_CFGR_BRESTP)
N/**
N  * @}
N  */            
N             
N/** @defgroup CEC_BREErrorBitGen  CEC Error Bit Generation if Bit Rise Error reported
N  * @{
N  */ 
N#define CEC_BRE_ERRORBIT_NO_GENERATION     ((uint32_t)0x00000000U)
N#define CEC_BRE_ERRORBIT_GENERATION        ((uint32_t)CEC_CFGR_BREGEN)
N/**
N  * @}
N  */ 
N                        
N/** @defgroup CEC_LBPEErrorBitGen  CEC Error Bit Generation if Long Bit Period Error reported
N  * @{
N  */ 
N#define CEC_LBPE_ERRORBIT_NO_GENERATION     ((uint32_t)0x00000000U)
N#define CEC_LBPE_ERRORBIT_GENERATION        ((uint32_t)CEC_CFGR_LBPEGEN)
N/**
N  * @}
N  */    
N
N/** @defgroup CEC_BroadCastMsgErrorBitGen  CEC Error Bit Generation on Broadcast message
N  * @{
N  */ 
N#define CEC_BROADCASTERROR_ERRORBIT_GENERATION     ((uint32_t)0x00000000U)
N#define CEC_BROADCASTERROR_NO_ERRORBIT_GENERATION  ((uint32_t)CEC_CFGR_BRDNOGEN)
N/**
N  * @}
N  */
N  
N/** @defgroup CEC_SFT_Option     CEC Signal Free Time start option
N  * @{
N  */ 
N#define CEC_SFT_START_ON_TXSOM           ((uint32_t)0x00000000U)
N#define CEC_SFT_START_ON_TX_RX_END       ((uint32_t)CEC_CFGR_SFTOPT)
N/**
N  * @}
N  */
N  
N/** @defgroup CEC_Listening_Mode    CEC Listening mode option
N  * @{
N  */ 
N#define CEC_REDUCED_LISTENING_MODE          ((uint32_t)0x00000000U)
N#define CEC_FULL_LISTENING_MODE             ((uint32_t)CEC_CFGR_LSTN)
N/**
N  * @}
N  */
N  
N/** @defgroup CEC_OAR_Position   CEC Device Own Address position in CEC CFGR register     
N  * @{
N  */
N#define CEC_CFGR_OAR_LSB_POS            ((uint32_t) 16U)
N/**
N  * @}
N  */
N  
N/** @defgroup CEC_Initiator_Position   CEC Initiator logical address position in message header     
N  * @{
N  */
N#define CEC_INITIATOR_LSB_POS           ((uint32_t) 4U)
N/**
N  * @}
N  */
N
N/** @defgroup CEC_OWN_ADDRESS   CEC Own Address    
N  * @{
N  */
N#define CEC_OWN_ADDRESS_NONE           ((uint16_t) 0x0000U)   /* Reset value */
N#define CEC_OWN_ADDRESS_0              ((uint16_t) 0x0001U)   /* Logical Address 0 */
N#define CEC_OWN_ADDRESS_1              ((uint16_t) 0x0002U)   /* Logical Address 1 */
N#define CEC_OWN_ADDRESS_2              ((uint16_t) 0x0004U)   /* Logical Address 2 */
N#define CEC_OWN_ADDRESS_3              ((uint16_t) 0x0008U)   /* Logical Address 3 */
N#define CEC_OWN_ADDRESS_4              ((uint16_t) 0x0010U)   /* Logical Address 4 */
N#define CEC_OWN_ADDRESS_5              ((uint16_t) 0x0020U)   /* Logical Address 5 */
N#define CEC_OWN_ADDRESS_6              ((uint16_t) 0x0040U)   /* Logical Address 6 */
N#define CEC_OWN_ADDRESS_7              ((uint16_t) 0x0080U)   /* Logical Address 7 */
N#define CEC_OWN_ADDRESS_8              ((uint16_t) 0x0100U)   /* Logical Address 9 */
N#define CEC_OWN_ADDRESS_9              ((uint16_t) 0x0200U)   /* Logical Address 10 */
N#define CEC_OWN_ADDRESS_10             ((uint16_t) 0x0400U)   /* Logical Address 11 */
N#define CEC_OWN_ADDRESS_11             ((uint16_t) 0x0800U)   /* Logical Address 12 */
N#define CEC_OWN_ADDRESS_12             ((uint16_t) 0x1000U)   /* Logical Address 13 */
N#define CEC_OWN_ADDRESS_13             ((uint16_t) 0x2000U)   /* Logical Address 14 */
N#define CEC_OWN_ADDRESS_14             ((uint16_t) 0x4000U)   /* Logical Address 15 */
N/**
N  * @}
N  */
N    
N/** @defgroup CEC_Interrupts_Definitions  CEC Interrupts definition
N  * @{
N  */
N#define CEC_IT_TXACKE                   CEC_IER_TXACKEIE
N#define CEC_IT_TXERR                    CEC_IER_TXERRIE
N#define CEC_IT_TXUDR                    CEC_IER_TXUDRIE
N#define CEC_IT_TXEND                    CEC_IER_TXENDIE
N#define CEC_IT_TXBR                     CEC_IER_TXBRIE
N#define CEC_IT_ARBLST                   CEC_IER_ARBLSTIE
N#define CEC_IT_RXACKE                   CEC_IER_RXACKEIE
N#define CEC_IT_LBPE                     CEC_IER_LBPEIE
N#define CEC_IT_SBPE                     CEC_IER_SBPEIE
N#define CEC_IT_BRE                      CEC_IER_BREIE
N#define CEC_IT_RXOVR                    CEC_IER_RXOVRIE
N#define CEC_IT_RXEND                    CEC_IER_RXENDIE
N#define CEC_IT_RXBR                     CEC_IER_RXBRIE
N/**
N  * @}
N  */
N
N/** @defgroup CEC_Flags_Definitions  CEC Flags definition
N  * @{
N  */
N#define CEC_FLAG_TXACKE                 CEC_ISR_TXACKE
N#define CEC_FLAG_TXERR                  CEC_ISR_TXERR
N#define CEC_FLAG_TXUDR                  CEC_ISR_TXUDR
N#define CEC_FLAG_TXEND                  CEC_ISR_TXEND
N#define CEC_FLAG_TXBR                   CEC_ISR_TXBR
N#define CEC_FLAG_ARBLST                 CEC_ISR_ARBLST
N#define CEC_FLAG_RXACKE                 CEC_ISR_RXACKE
N#define CEC_FLAG_LBPE                   CEC_ISR_LBPE
N#define CEC_FLAG_SBPE                   CEC_ISR_SBPE
N#define CEC_FLAG_BRE                    CEC_ISR_BRE
N#define CEC_FLAG_RXOVR                  CEC_ISR_RXOVR
N#define CEC_FLAG_RXEND                  CEC_ISR_RXEND
N#define CEC_FLAG_RXBR                   CEC_ISR_RXBR
N/**
N  * @}
N  */
N  
N/** @defgroup CEC_ALL_ERROR CEC all RX or TX errors flags 
N  * @{
N  */
N#define CEC_ISR_ALL_ERROR              ((uint32_t)CEC_ISR_RXOVR|CEC_ISR_BRE|CEC_ISR_SBPE|CEC_ISR_LBPE|CEC_ISR_RXACKE|\
N                                                  CEC_ISR_ARBLST|CEC_ISR_TXUDR|CEC_ISR_TXERR|CEC_ISR_TXACKE)
X#define CEC_ISR_ALL_ERROR              ((uint32_t)CEC_ISR_RXOVR|CEC_ISR_BRE|CEC_ISR_SBPE|CEC_ISR_LBPE|CEC_ISR_RXACKE|                                                  CEC_ISR_ARBLST|CEC_ISR_TXUDR|CEC_ISR_TXERR|CEC_ISR_TXACKE)
N/**
N  * @}
N  */
N
N/** @defgroup CEC_IER_ALL_RX CEC all RX errors interrupts enabling flag 
N  * @{
N  */
N#define CEC_IER_RX_ALL_ERR              ((uint32_t)CEC_IER_RXACKEIE|CEC_IER_LBPEIE|CEC_IER_SBPEIE|CEC_IER_BREIE|CEC_IER_RXOVRIE)
N/**
N  * @}
N  */
N  
N/** @defgroup CEC_IER_ALL_TX CEC all TX errors interrupts enabling flag 
N  * @{
N  */
N#define CEC_IER_TX_ALL_ERR              ((uint32_t)CEC_IER_TXACKEIE|CEC_IER_TXERRIE|CEC_IER_TXUDRIE|CEC_IER_ARBLSTIE)
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */  
N  
N/* Exported macros -----------------------------------------------------------*/
N/** @defgroup CEC_Exported_Macros CEC Exported Macros
N  * @{
N  */
N
N/** @brief  Reset CEC handle gstate & RxState
N  * @param  __HANDLE__: CEC handle.
N  * @retval None
N  */
N#define __HAL_CEC_RESET_HANDLE_STATE(__HANDLE__) do{                                                   \
N                                                       (__HANDLE__)->gState = HAL_CEC_STATE_RESET;     \
N                                                       (__HANDLE__)->RxState = HAL_CEC_STATE_RESET;    \
N                                                     } while(0)
X#define __HAL_CEC_RESET_HANDLE_STATE(__HANDLE__) do{                                                                                                          (__HANDLE__)->gState = HAL_CEC_STATE_RESET;                                                            (__HANDLE__)->RxState = HAL_CEC_STATE_RESET;                                                         } while(0)
N
N/** @brief  Checks whether or not the specified CEC interrupt flag is set.
N  * @param  __HANDLE__: specifies the CEC Handle.
N  * @param  __FLAG__: specifies the flag to check.
N  *            @arg CEC_FLAG_TXACKE: Tx Missing acknowledge Error
N  *            @arg CEC_FLAG_TXERR: Tx Error.
N  *            @arg CEC_FLAG_TXUDR: Tx-Buffer Underrun.
N  *            @arg CEC_FLAG_TXEND: End of transmission (successful transmission of the last byte).
N  *            @arg CEC_FLAG_TXBR: Tx-Byte Request.
N  *            @arg CEC_FLAG_ARBLST: Arbitration Lost
N  *            @arg CEC_FLAG_RXACKE: Rx-Missing Acknowledge 
N  *            @arg CEC_FLAG_LBPE: Rx Long period Error
N  *            @arg CEC_FLAG_SBPE: Rx Short period Error
N  *            @arg CEC_FLAG_BRE: Rx Bit Rising Error
N  *            @arg CEC_FLAG_RXOVR: Rx Overrun.
N  *            @arg CEC_FLAG_RXEND: End Of Reception.
N  *            @arg CEC_FLAG_RXBR: Rx-Byte Received.      
N  * @retval ITStatus
N  */
N#define __HAL_CEC_GET_FLAG(__HANDLE__, __FLAG__)        ((__HANDLE__)->Instance->ISR & (__FLAG__)) 
N
N/** @brief  Clears the interrupt or status flag when raised (write at 1)
N  * @param  __HANDLE__: specifies the CEC Handle.
N  * @param  __FLAG__: specifies the interrupt/status flag to clear.
N  *        This parameter can be one of the following values:
N  *            @arg CEC_FLAG_TXACKE: Tx Missing acknowledge Error
N  *            @arg CEC_FLAG_TXERR: Tx Error.
N  *            @arg CEC_FLAG_TXUDR: Tx-Buffer Underrun.
N  *            @arg CEC_FLAG_TXEND: End of transmission (successful transmission of the last byte).
N  *            @arg CEC_FLAG_TXBR: Tx-Byte Request.
N  *            @arg CEC_FLAG_ARBLST: Arbitration Lost
N  *            @arg CEC_FLAG_RXACKE: Rx-Missing Acknowledge 
N  *            @arg CEC_FLAG_LBPE: Rx Long period Error
N  *            @arg CEC_FLAG_SBPE: Rx Short period Error
N  *            @arg CEC_FLAG_BRE: Rx Bit Rising Error
N  *            @arg CEC_FLAG_RXOVR: Rx Overrun.
N  *            @arg CEC_FLAG_RXEND: End Of Reception.
N  *            @arg CEC_FLAG_RXBR: Rx-Byte Received. 
N  * @retval none  
N  */
N#define __HAL_CEC_CLEAR_FLAG(__HANDLE__, __FLAG__)         ((__HANDLE__)->Instance->ISR |= (__FLAG__)) 
N
N/** @brief  Enables the specified CEC interrupt.
N  * @param  __HANDLE__: specifies the CEC Handle.
N  * @param  __INTERRUPT__: specifies the CEC interrupt to enable.
N  *          This parameter can be one of the following values:
N  *            @arg CEC_IT_TXACKE: Tx Missing acknowledge Error IT Enable 
N  *            @arg CEC_IT_TXERR: Tx Error IT Enable 
N  *            @arg CEC_IT_TXUDR: Tx-Buffer Underrun IT Enable 
N  *            @arg CEC_IT_TXEND: End of transmission IT Enable 
N  *            @arg CEC_IT_TXBR: Tx-Byte Request IT Enable 
N  *            @arg CEC_IT_ARBLST: Arbitration Lost IT Enable 
N  *            @arg CEC_IT_RXACKE: Rx-Missing Acknowledge IT Enable 
N  *            @arg CEC_IT_LBPE: Rx Long period Error IT Enable 
N  *            @arg CEC_IT_SBPE: Rx Short period Error IT Enable 
N  *            @arg CEC_IT_BRE: Rx Bit Rising Error IT Enable 
N  *            @arg CEC_IT_RXOVR: Rx Overrun IT Enable 
N  *            @arg CEC_IT_RXEND: End Of Reception IT Enable 
N  *            @arg CEC_IT_RXBR: Rx-Byte Received IT Enable                          
N  * @retval none
N  */
N#define __HAL_CEC_ENABLE_IT(__HANDLE__, __INTERRUPT__)     ((__HANDLE__)->Instance->IER |= (__INTERRUPT__))  
N
N/** @brief  Disables the specified CEC interrupt.
N  * @param  __HANDLE__: specifies the CEC Handle.
N  * @param  __INTERRUPT__: specifies the CEC interrupt to disable.
N  *          This parameter can be one of the following values:
N  *            @arg CEC_IT_TXACKE: Tx Missing acknowledge Error IT Enable 
N  *            @arg CEC_IT_TXERR: Tx Error IT Enable 
N  *            @arg CEC_IT_TXUDR: Tx-Buffer Underrun IT Enable 
N  *            @arg CEC_IT_TXEND: End of transmission IT Enable 
N  *            @arg CEC_IT_TXBR: Tx-Byte Request IT Enable 
N  *            @arg CEC_IT_ARBLST: Arbitration Lost IT Enable 
N  *            @arg CEC_IT_RXACKE: Rx-Missing Acknowledge IT Enable 
N  *            @arg CEC_IT_LBPE: Rx Long period Error IT Enable 
N  *            @arg CEC_IT_SBPE: Rx Short period Error IT Enable 
N  *            @arg CEC_IT_BRE: Rx Bit Rising Error IT Enable 
N  *            @arg CEC_IT_RXOVR: Rx Overrun IT Enable 
N  *            @arg CEC_IT_RXEND: End Of Reception IT Enable 
N  *            @arg CEC_IT_RXBR: Rx-Byte Received IT Enable                   
N  * @retval none
N  */   
N#define __HAL_CEC_DISABLE_IT(__HANDLE__, __INTERRUPT__)    ((__HANDLE__)->Instance->IER &= (~(__INTERRUPT__)))  
N
N/** @brief  Checks whether or not the specified CEC interrupt is enabled.
N  * @param  __HANDLE__: specifies the CEC Handle.
N  * @param  __INTERRUPT__: specifies the CEC interrupt to check.
N  *          This parameter can be one of the following values:
N  *            @arg CEC_IT_TXACKE: Tx Missing acknowledge Error IT Enable 
N  *            @arg CEC_IT_TXERR: Tx Error IT Enable 
N  *            @arg CEC_IT_TXUDR: Tx-Buffer Underrun IT Enable 
N  *            @arg CEC_IT_TXEND: End of transmission IT Enable 
N  *            @arg CEC_IT_TXBR: Tx-Byte Request IT Enable 
N  *            @arg CEC_IT_ARBLST: Arbitration Lost IT Enable 
N  *            @arg CEC_IT_RXACKE: Rx-Missing Acknowledge IT Enable 
N  *            @arg CEC_IT_LBPE: Rx Long period Error IT Enable 
N  *            @arg CEC_IT_SBPE: Rx Short period Error IT Enable 
N  *            @arg CEC_IT_BRE: Rx Bit Rising Error IT Enable 
N  *            @arg CEC_IT_RXOVR: Rx Overrun IT Enable 
N  *            @arg CEC_IT_RXEND: End Of Reception IT Enable 
N  *            @arg CEC_IT_RXBR: Rx-Byte Received IT Enable                  
N  * @retval FlagStatus  
N  */
N#define __HAL_CEC_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) ((__HANDLE__)->Instance->IER & (__INTERRUPT__))
N
N/** @brief  Enables the CEC device
N  * @param  __HANDLE__: specifies the CEC Handle.               
N  * @retval none 
N  */
N#define __HAL_CEC_ENABLE(__HANDLE__)                   ((__HANDLE__)->Instance->CR |=  CEC_CR_CECEN)
N
N/** @brief  Disables the CEC device
N  * @param  __HANDLE__: specifies the CEC Handle.               
N  * @retval none 
N  */
N#define __HAL_CEC_DISABLE(__HANDLE__)                  ((__HANDLE__)->Instance->CR &=  ~CEC_CR_CECEN)
N
N/** @brief  Set Transmission Start flag
N  * @param  __HANDLE__: specifies the CEC Handle.               
N  * @retval none 
N  */
N#define __HAL_CEC_FIRST_BYTE_TX_SET(__HANDLE__)        ((__HANDLE__)->Instance->CR |=  CEC_CR_TXSOM)
N
N/** @brief  Set Transmission End flag
N  * @param  __HANDLE__: specifies the CEC Handle.               
N  * @retval none 
N  * If the CEC message consists of only one byte, TXEOM must be set before of TXSOM.  
N  */
N#define __HAL_CEC_LAST_BYTE_TX_SET(__HANDLE__)         ((__HANDLE__)->Instance->CR |=  CEC_CR_TXEOM)
N
N/** @brief  Get Transmission Start flag
N  * @param  __HANDLE__: specifies the CEC Handle.               
N  * @retval FlagStatus 
N  */
N#define __HAL_CEC_GET_TRANSMISSION_START_FLAG(__HANDLE__) ((__HANDLE__)->Instance->CR & CEC_CR_TXSOM)
N
N/** @brief  Get Transmission End flag
N  * @param  __HANDLE__: specifies the CEC Handle.               
N  * @retval FlagStatus 
N  */
N#define __HAL_CEC_GET_TRANSMISSION_END_FLAG(__HANDLE__)   ((__HANDLE__)->Instance->CR & CEC_CR_TXEOM)   
N
N/** @brief  Clear OAR register
N  * @param  __HANDLE__: specifies the CEC Handle.               
N  * @retval none 
N  */
N#define __HAL_CEC_CLEAR_OAR(__HANDLE__)   CLEAR_BIT((__HANDLE__)->Instance->CFGR, CEC_CFGR_OAR)
N
N/** @brief  Set OAR register (without resetting previously set address in case of multi-address mode)
N  *          To reset OAR, __HAL_CEC_CLEAR_OAR() needs to be called beforehand
N  * @param  __HANDLE__: specifies the CEC Handle. 
N  * @param  __ADDRESS__: Own Address value (CEC logical address is identified by bit position)                   
N  * @retval none 
N  */
N#define __HAL_CEC_SET_OAR(__HANDLE__,__ADDRESS__)   SET_BIT((__HANDLE__)->Instance->CFGR, (__ADDRESS__)<< CEC_CFGR_OAR_LSB_POS)
N
N/**
N  * @}
N  */                       
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup CEC_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup CEC_Exported_Functions_Group1
N  * @{
N  */
N/* Initialization and de-initialization functions  ****************************/
NHAL_StatusTypeDef HAL_CEC_Init(CEC_HandleTypeDef *hcec);
NHAL_StatusTypeDef HAL_CEC_DeInit(CEC_HandleTypeDef *hcec);
NHAL_StatusTypeDef HAL_CEC_SetDeviceAddress(CEC_HandleTypeDef *hcec, uint16_t CEC_OwnAddress);
Nvoid HAL_CEC_MspInit(CEC_HandleTypeDef *hcec);
Nvoid HAL_CEC_MspDeInit(CEC_HandleTypeDef *hcec);
N/**
N  * @}
N  */
N
N/** @addtogroup CEC_Exported_Functions_Group2
N  * @{
N  */
N/* I/O operation functions  ***************************************************/
NHAL_StatusTypeDef HAL_CEC_Transmit_IT(CEC_HandleTypeDef *hcec, uint8_t InitiatorAddress,uint8_t DestinationAddress, uint8_t *pData, uint32_t Size);
Nuint32_t HAL_CEC_GetLastReceivedFrameSize(CEC_HandleTypeDef *hcec);
Nvoid HAL_CEC_ChangeRxBuffer(CEC_HandleTypeDef *hcec, uint8_t* Rxbuffer);
Nvoid HAL_CEC_IRQHandler(CEC_HandleTypeDef *hcec);
Nvoid HAL_CEC_TxCpltCallback(CEC_HandleTypeDef *hcec);
Nvoid HAL_CEC_RxCpltCallback(CEC_HandleTypeDef *hcec, uint32_t RxFrameSize);
Nvoid HAL_CEC_ErrorCallback(CEC_HandleTypeDef *hcec);
N/**
N  * @}
N  */
N
N/** @addtogroup CEC_Exported_Functions_Group3
N  * @{
N  */
N/* Peripheral State functions  ************************************************/
NHAL_CEC_StateTypeDef HAL_CEC_GetState(CEC_HandleTypeDef *hcec);
Nuint32_t HAL_CEC_GetError(CEC_HandleTypeDef *hcec);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N  
N/* Private types -------------------------------------------------------------*/
N/** @defgroup CEC_Private_Types CEC Private Types
N  * @{
N  */
N
N/**
N  * @}
N  */ 
N
N/* Private variables ---------------------------------------------------------*/
N/** @defgroup CEC_Private_Variables CEC Private Variables
N  * @{
N  */
N  
N/**
N  * @}
N  */ 
N
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup CEC_Private_Constants CEC Private Constants
N  * @{
N  */
N
N/**
N  * @}
N  */ 
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup CEC_Private_Macros CEC Private Macros
N  * @{
N  */
N  
N#define IS_CEC_SIGNALFREETIME(__SFT__)     ((__SFT__) <= CEC_CFGR_SFT)  
N
N#define IS_CEC_TOLERANCE(__RXTOL__)        (((__RXTOL__) == CEC_STANDARD_TOLERANCE) || \
N                                            ((__RXTOL__) == CEC_EXTENDED_TOLERANCE))
X#define IS_CEC_TOLERANCE(__RXTOL__)        (((__RXTOL__) == CEC_STANDARD_TOLERANCE) ||                                             ((__RXTOL__) == CEC_EXTENDED_TOLERANCE))
N                                            
N#define IS_CEC_BRERXSTOP(__BRERXSTOP__)   (((__BRERXSTOP__) == CEC_NO_RX_STOP_ON_BRE) || \
N                                           ((__BRERXSTOP__) == CEC_RX_STOP_ON_BRE))
X#define IS_CEC_BRERXSTOP(__BRERXSTOP__)   (((__BRERXSTOP__) == CEC_NO_RX_STOP_ON_BRE) ||                                            ((__BRERXSTOP__) == CEC_RX_STOP_ON_BRE))
N                                           
N#define IS_CEC_BREERRORBITGEN(__ERRORBITGEN__) (((__ERRORBITGEN__) == CEC_BRE_ERRORBIT_NO_GENERATION) || \
N                                                ((__ERRORBITGEN__) == CEC_BRE_ERRORBIT_GENERATION))
X#define IS_CEC_BREERRORBITGEN(__ERRORBITGEN__) (((__ERRORBITGEN__) == CEC_BRE_ERRORBIT_NO_GENERATION) ||                                                 ((__ERRORBITGEN__) == CEC_BRE_ERRORBIT_GENERATION))
N
N#define IS_CEC_LBPEERRORBITGEN(__ERRORBITGEN__) (((__ERRORBITGEN__) == CEC_LBPE_ERRORBIT_NO_GENERATION) || \
N                                                 ((__ERRORBITGEN__) == CEC_LBPE_ERRORBIT_GENERATION))
X#define IS_CEC_LBPEERRORBITGEN(__ERRORBITGEN__) (((__ERRORBITGEN__) == CEC_LBPE_ERRORBIT_NO_GENERATION) ||                                                  ((__ERRORBITGEN__) == CEC_LBPE_ERRORBIT_GENERATION))
N                                                 
N#define IS_CEC_BROADCASTERROR_NO_ERRORBIT_GENERATION(__ERRORBITGEN__) (((__ERRORBITGEN__) == CEC_BROADCASTERROR_ERRORBIT_GENERATION) || \
N                                                                       ((__ERRORBITGEN__) == CEC_BROADCASTERROR_NO_ERRORBIT_GENERATION))
X#define IS_CEC_BROADCASTERROR_NO_ERRORBIT_GENERATION(__ERRORBITGEN__) (((__ERRORBITGEN__) == CEC_BROADCASTERROR_ERRORBIT_GENERATION) ||                                                                        ((__ERRORBITGEN__) == CEC_BROADCASTERROR_NO_ERRORBIT_GENERATION))
N                                                                       
N#define IS_CEC_SFTOP(__SFTOP__)          (((__SFTOP__) == CEC_SFT_START_ON_TXSOM) || \
N                                          ((__SFTOP__) == CEC_SFT_START_ON_TX_RX_END))
X#define IS_CEC_SFTOP(__SFTOP__)          (((__SFTOP__) == CEC_SFT_START_ON_TXSOM) ||                                           ((__SFTOP__) == CEC_SFT_START_ON_TX_RX_END))
N                                          
N#define IS_CEC_LISTENING_MODE(__MODE__)     (((__MODE__) == CEC_REDUCED_LISTENING_MODE) || \
N                                             ((__MODE__) == CEC_FULL_LISTENING_MODE))
X#define IS_CEC_LISTENING_MODE(__MODE__)     (((__MODE__) == CEC_REDUCED_LISTENING_MODE) ||                                              ((__MODE__) == CEC_FULL_LISTENING_MODE))
N
N/** @brief Check CEC message size.
N  *       The message size is the payload size: without counting the header, 
N  *       it varies from 0 byte (ping operation, one header only, no payload) to 
N  *       15 bytes (1 opcode and up to 14 operands following the header). 
N  * @param  __SIZE__: CEC message size.               
N  * @retval Test result (TRUE or FALSE).
N  */
N#define IS_CEC_MSGSIZE(__SIZE__) ((__SIZE__) <= 0x10)  
N                                                 
N/** @brief Check CEC device Own Address Register (OAR) setting.
N  *        OAR address is written in a 15-bit field within CEC_CFGR register. 
N  * @param  __ADDRESS__: CEC own address.               
N  * @retval Test result (TRUE or FALSE).
N  */
N#define IS_CEC_OWN_ADDRESS(__ADDRESS__) ((__ADDRESS__) <= 0x7FFF)
N
N/** @brief Check CEC initiator or destination logical address setting.
N  *        Initiator and destination addresses are coded over 4 bits. 
N  * @param  __ADDRESS__: CEC initiator or logical address.               
N  * @retval Test result (TRUE or FALSE).
N  */
N#define IS_CEC_ADDRESS(__ADDRESS__) ((__ADDRESS__) <= 0xF) 
N/**
N  * @}
N  */
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup CEC_Private_Functions CEC Private Functions
N  * @{
N  */
N  
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_CEC_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 271 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_CEC_MODULE_ENABLED */
N
N#ifdef HAL_CRC_MODULE_ENABLED
N  #include "stm32f7xx_hal_crc.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_crc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_crc.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of CRC HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_CRC_H
N#define __STM32F7xx_HAL_CRC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @defgroup CRC CRC
N  * @brief CRC HAL module driver
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup CRC_Exported_Types CRC Exported Types
N  * @{
N  */
N
N/** @defgroup CRC_Exported_Types_Group1 CRC State Structure definition 
N  * @{
N  */
Ntypedef enum
N{
N  HAL_CRC_STATE_RESET     = 0x00U,  /*!< CRC not yet initialized or disabled */
N  HAL_CRC_STATE_READY     = 0x01U,  /*!< CRC initialized and ready for use   */
N  HAL_CRC_STATE_BUSY      = 0x02U,  /*!< CRC internal process is ongoing     */
N  HAL_CRC_STATE_TIMEOUT   = 0x03U,  /*!< CRC timeout state                   */
N  HAL_CRC_STATE_ERROR     = 0x04U   /*!< CRC error state                     */
N}HAL_CRC_StateTypeDef;
N/** 
N  * @}
N  */
N
N/** @defgroup CRC_Exported_Types_Group2 CRC Init Structure definition  
N  * @{
N  */
Ntypedef struct
N{
N  uint8_t DefaultPolynomialUse;       /*!< This parameter is a value of @ref CRC_Default_Polynomial and indicates if default polynomial is used.  
N                                            If set to DEFAULT_POLYNOMIAL_ENABLE, resort to default 
N                                            X^32 + X^26 + X^23 + X^22 + X^16 + X^12 + X^11 + X^10 +X^8 + X^7 + X^5 + X^4 + X^2+ X +1. 
N                                            In that case, there is no need to set GeneratingPolynomial field.
N                                            If otherwise set to DEFAULT_POLYNOMIAL_DISABLE, GeneratingPolynomial and CRCLength fields must be set */
N
N  uint8_t DefaultInitValueUse;        /*!< This parameter is a value of @ref CRC_Default_InitValue_Use and indicates if default init value is used. 
N                                           If set to DEFAULT_INIT_VALUE_ENABLE, resort to default
N                                           0xFFFFFFFF value. In that case, there is no need to set InitValue field.   
N                                           If otherwise set to DEFAULT_INIT_VALUE_DISABLE,  InitValue field must be set */
N
N  uint32_t GeneratingPolynomial;      /*!< Set CRC generating polynomial. 7, 8, 16 or 32-bit long value for a polynomial degree
N                                           respectively equal to 7, 8, 16 or 32. This field is written in normal representation, 
N                                           e.g., for a polynomial of degree 7, X^7 + X^6 + X^5 + X^2 + 1 is written 0x65.
N                                           No need to specify it if DefaultPolynomialUse is set to DEFAULT_POLYNOMIAL_ENABLE   */                                                
N
N  uint32_t CRCLength;                 /*!< This parameter is a value of @ref CRC_Polynomial_Sizes and indicates CRC length.
N                                           Value can be either one of
N                                           CRC_POLYLENGTH_32B                  (32-bit CRC)
N                                           CRC_POLYLENGTH_16B                  (16-bit CRC)
N                                           CRC_POLYLENGTH_8B                   (8-bit CRC)
N                                           CRC_POLYLENGTH_7B                   (7-bit CRC) */
N                                              
N  uint32_t InitValue;                 /*!< Init value to initiate CRC computation. No need to specify it if DefaultInitValueUse 
N                                           is set to DEFAULT_INIT_VALUE_ENABLE   */                                                
N  
N  uint32_t InputDataInversionMode;    /*!< This parameter is a value of @ref CRCEx_Input_Data_Inversion and specifies input data inversion mode. 
N                                           Can be either one of the following values 
N                                           CRC_INPUTDATA_INVERSION_NONE      no input data inversion
N                                           CRC_INPUTDATA_INVERSION_BYTE      byte-wise inversion, 0x1A2B3C4D becomes 0x58D43CB2
N                                           CRC_INPUTDATA_INVERSION_HALFWORD  halfword-wise inversion, 0x1A2B3C4D becomes 0xD458B23C
N                                           CRC_INPUTDATA_INVERSION_WORD      word-wise inversion, 0x1A2B3C4D becomes 0xB23CD458 */  
N                                              
N  uint32_t OutputDataInversionMode;   /*!< This parameter is a value of @ref CRCEx_Output_Data_Inversion and specifies output data (i.e. CRC) inversion mode.
N                                            Can be either 
N                                            CRC_OUTPUTDATA_INVERSION_DISABLE   no CRC inversion, or
N                                            CRC_OUTPUTDATA_INVERSION_ENABLE    CRC 0x11223344 is converted into 0x22CC4488 */
N}CRC_InitTypeDef;
N/** 
N  * @}
N  */
N  
N/** @defgroup CRC_Exported_Types_Group3 CRC Handle Structure definition   
N  * @{
N  */
Ntypedef struct
N{
N  CRC_TypeDef                 *Instance;   /*!< Register base address        */ 
N  
N  CRC_InitTypeDef             Init;        /*!< CRC configuration parameters */
N  
N  HAL_LockTypeDef             Lock;        /*!< CRC Locking object           */
N    
N  __IO HAL_CRC_StateTypeDef   State;       /*!< CRC communication state      */
X  volatile HAL_CRC_StateTypeDef   State;        
N  
N  uint32_t InputDataFormat;                /*!< This parameter is a value of @ref CRC_Input_Buffer_Format and specifies input data format. 
N                                            Can be either 
N                                            CRC_INPUTDATA_FORMAT_BYTES       input data is a stream of bytes (8-bit data)
N                                            CRC_INPUTDATA_FORMAT_HALFWORDS   input data is a stream of half-words (16-bit data)
N                                            CRC_INPUTDATA_FORMAT_WORDS       input data is a stream of words (32-bits data)                                                                                        
N                                           Note that constant CRC_INPUT_FORMAT_UNDEFINED is defined but an initialization error
N                                           must occur if InputBufferFormat is not one of the three values listed above  */ 
N}CRC_HandleTypeDef;
N/** 
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N  
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup CRC_Exported_Constants   CRC exported constants
N  * @{
N  */
N  
N/** @defgroup CRC_Default_Polynomial_Value    Default CRC generating polynomial
N  * @{
N  */
N#define DEFAULT_CRC32_POLY      0x04C11DB7U
N
N/**
N  * @}
N  */
N
N/** @defgroup CRC_Default_InitValue    Default CRC computation initialization value
N  * @{
N  */
N#define DEFAULT_CRC_INITVALUE   0xFFFFFFFFU
N
N/**
N  * @}
N  */
N
N/** @defgroup CRC_Default_Polynomial    Indicates whether or not default polynomial is used
N  * @{
N  */
N#define DEFAULT_POLYNOMIAL_ENABLE       ((uint8_t)0x00U)
N#define DEFAULT_POLYNOMIAL_DISABLE      ((uint8_t)0x01U)
N
N
N/**
N  * @}
N  */
N 
N/** @defgroup CRC_Default_InitValue_Use    Indicates whether or not default init value is used
N  * @{
N  */                                      
N#define DEFAULT_INIT_VALUE_ENABLE      ((uint8_t)0x00U)
N#define DEFAULT_INIT_VALUE_DISABLE     ((uint8_t)0x01U)
N
N/**
N  * @}
N  */
N
N/** @defgroup CRC_Polynomial_Sizes Polynomial sizes to configure the IP
N  * @{
N  */
N#define CRC_POLYLENGTH_32B                  ((uint32_t)0x00000000U)
N#define CRC_POLYLENGTH_16B                  ((uint32_t)CRC_CR_POLYSIZE_0)
N#define CRC_POLYLENGTH_8B                   ((uint32_t)CRC_CR_POLYSIZE_1)
N#define CRC_POLYLENGTH_7B                   ((uint32_t)CRC_CR_POLYSIZE)
N/**
N  * @}
N  */
N
N/** @defgroup CRC_Polynomial_Size_Definitions CRC polynomial possible sizes actual definitions
N  * @{
N  */
N#define HAL_CRC_LENGTH_32B     32U
N#define HAL_CRC_LENGTH_16B     16U
N#define HAL_CRC_LENGTH_8B       8U
N#define HAL_CRC_LENGTH_7B       7U
N
N/**
N  * @}
N  */  
N
N/** @defgroup CRC_Input_Buffer_Format CRC input buffer format
N  * @{
N  */
N/* WARNING: CRC_INPUT_FORMAT_UNDEFINED is created for reference purposes but
N * an error is triggered in HAL_CRC_Init() if InputDataFormat field is set 
N * to CRC_INPUT_FORMAT_UNDEFINED: the format MUST be defined by the user for 
N * the CRC APIs to provide a correct result */   
N#define CRC_INPUTDATA_FORMAT_UNDEFINED             ((uint32_t)0x00000000U)
N#define CRC_INPUTDATA_FORMAT_BYTES                 ((uint32_t)0x00000001U)
N#define CRC_INPUTDATA_FORMAT_HALFWORDS             ((uint32_t)0x00000002U)
N#define CRC_INPUTDATA_FORMAT_WORDS                 ((uint32_t)0x00000003U)
N/** 
N  * @}
N  */   
N
N/** 
N  * @}
N  */ 
N/* Exported macros -----------------------------------------------------------*/
N
N/** @defgroup CRC_Exported_Macros CRC exported macros
N  * @{
N  */
N
N/** @brief Reset CRC handle state
N  * @param  __HANDLE__: CRC handle.
N  * @retval None
N  */
N#define __HAL_CRC_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_CRC_STATE_RESET)
N
N/**
N  * @brief  Reset CRC Data Register.
N  * @param  __HANDLE__: CRC handle
N  * @retval None.
N  */
N#define __HAL_CRC_DR_RESET(__HANDLE__) ((__HANDLE__)->Instance->CR |= CRC_CR_RESET)
N
N/**
N  * @brief  Set CRC INIT non-default value
N  * @param  __HANDLE__    : CRC handle
N  * @param  __INIT__      : 32-bit initial value  
N  * @retval None.
N  */
N#define __HAL_CRC_INITIALCRCVALUE_CONFIG(__HANDLE__, __INIT__) ((__HANDLE__)->Instance->INIT = (__INIT__))    
N
N/**
N  * @brief Stores a 8-bit data in the Independent Data(ID) register.
N  * @param __HANDLE__: CRC handle
N  * @param __VALUE__: 8-bit value to be stored in the ID register
N  * @retval None
N  */
N#define __HAL_CRC_SET_IDR(__HANDLE__, __VALUE__) (WRITE_REG((__HANDLE__)->Instance->IDR, CRC_IDR_IDR, (__VALUE__)))
N
N/**
N  * @brief Returns the 8-bit data stored in the Independent Data(ID) register.
N  * @param __HANDLE__: CRC handle
N  * @retval 8-bit value of the ID register 
N  */
N#define __HAL_CRC_GET_IDR(__HANDLE__) (((__HANDLE__)->Instance->IDR) & CRC_IDR_IDR)
N/**
N  * @}
N  */
N
N
N/* Include CRC HAL Extension module */
N#include "stm32f7xx_hal_crc_ex.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_crc_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_crc_ex.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of CRC HAL extension module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_CRC_EX_H
N#define __STM32F7xx_HAL_CRC_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @defgroup CRCEx CRCEx
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/ 
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup CRCEx_Exported_Constants CRC Extended exported constants
N * @{
N */
N
N/** @defgroup CRCEx_Input_Data_Inversion CRC Extended input data inversion modes
N  * @{
N  */
N#define CRC_INPUTDATA_INVERSION_NONE              ((uint32_t)0x00000000U)
N#define CRC_INPUTDATA_INVERSION_BYTE              ((uint32_t)CRC_CR_REV_IN_0)
N#define CRC_INPUTDATA_INVERSION_HALFWORD          ((uint32_t)CRC_CR_REV_IN_1)
N#define CRC_INPUTDATA_INVERSION_WORD              ((uint32_t)CRC_CR_REV_IN)
N
N#define IS_CRC_INPUTDATA_INVERSION_MODE(__MODE__)     (((__MODE__) == CRC_INPUTDATA_INVERSION_NONE) || \
N                                                       ((__MODE__) == CRC_INPUTDATA_INVERSION_BYTE) || \
N                                                       ((__MODE__) == CRC_INPUTDATA_INVERSION_HALFWORD) || \
N                                                       ((__MODE__) == CRC_INPUTDATA_INVERSION_WORD))
X#define IS_CRC_INPUTDATA_INVERSION_MODE(__MODE__)     (((__MODE__) == CRC_INPUTDATA_INVERSION_NONE) ||                                                        ((__MODE__) == CRC_INPUTDATA_INVERSION_BYTE) ||                                                        ((__MODE__) == CRC_INPUTDATA_INVERSION_HALFWORD) ||                                                        ((__MODE__) == CRC_INPUTDATA_INVERSION_WORD))
N/**
N  * @}
N  */
N
N/** @defgroup CRCEx_Output_Data_Inversion CRC Extended output data inversion modes
N  * @{
N  */
N#define CRC_OUTPUTDATA_INVERSION_DISABLE         ((uint32_t)0x00000000U)
N#define CRC_OUTPUTDATA_INVERSION_ENABLE          ((uint32_t)CRC_CR_REV_OUT)
N
N#define IS_CRC_OUTPUTDATA_INVERSION_MODE(__MODE__)    (((__MODE__) == CRC_OUTPUTDATA_INVERSION_DISABLE) || \
N                                                       ((__MODE__) == CRC_OUTPUTDATA_INVERSION_ENABLE))
X#define IS_CRC_OUTPUTDATA_INVERSION_MODE(__MODE__)    (((__MODE__) == CRC_OUTPUTDATA_INVERSION_DISABLE) ||                                                        ((__MODE__) == CRC_OUTPUTDATA_INVERSION_ENABLE))
N/**                                               
N  * @}
N  */
N
N
N/**
N * @}
N */
N/* Exported macro ------------------------------------------------------------*/
N
N/** @defgroup CRCEx_Exported_Macros CRC Extended exported macros
N  * @{
N  */
N    
N/**
N  * @brief  Set CRC output reversal
N  * @param  __HANDLE__    : CRC handle
N  * @retval None.
N  */
N#define  __HAL_CRC_OUTPUTREVERSAL_ENABLE(__HANDLE__) ((__HANDLE__)->Instance->CR |= CRC_CR_REV_OUT)   
N
N/**
N  * @brief  Unset CRC output reversal
N  * @param  __HANDLE__    : CRC handle
N  * @retval None.
N  */
N#define __HAL_CRC_OUTPUTREVERSAL_DISABLE(__HANDLE__) ((__HANDLE__)->Instance->CR &= ~(CRC_CR_REV_OUT))   
N
N/**
N  * @brief  Set CRC non-default polynomial
N  * @param  __HANDLE__    : CRC handle
N  * @param  __POLYNOMIAL__: 7, 8, 16 or 32-bit polynomial  
N  * @retval None.
N  */
N#define __HAL_CRC_POLYNOMIAL_CONFIG(__HANDLE__, __POLYNOMIAL__) ((__HANDLE__)->Instance->POL = (__POLYNOMIAL__))
N
N/**
N  * @}
N  */
N
N
N/** @defgroup CRCEx_Exported_Functions CRC Extended Exported Functions
N  * @{
N  */
N
N/** @defgroup CRCEx_Exported_Functions_Group1 Extended CRC features functions
N  * @{
N  */
N/* Exported functions --------------------------------------------------------*/
N/* Initialization and de-initialization functions  ****************************/
NHAL_StatusTypeDef HAL_CRCEx_Polynomial_Set(CRC_HandleTypeDef *hcrc, uint32_t Pol, uint32_t PolyLength);
NHAL_StatusTypeDef HAL_CRCEx_Input_Data_Reverse(CRC_HandleTypeDef *hcrc, uint32_t InputReverseMode);
NHAL_StatusTypeDef HAL_CRCEx_Output_Data_Reverse(CRC_HandleTypeDef *hcrc, uint32_t OutputReverseMode);
N
N/* Peripheral Control functions ***********************************************/
N/* Peripheral State and Error functions ***************************************/
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_CRC_EX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 287 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_crc.h" 2
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup CRC_Exported_Functions CRC Exported Functions
N  * @{
N  */
N
N/** @defgroup CRC_Exported_Functions_Group1 Initialization/de-initialization functions
N  * @{
N  */
N/* Initialization and de-initialization functions  ****************************/
NHAL_StatusTypeDef HAL_CRC_Init(CRC_HandleTypeDef *hcrc);
NHAL_StatusTypeDef HAL_CRC_DeInit (CRC_HandleTypeDef *hcrc);
Nvoid HAL_CRC_MspInit(CRC_HandleTypeDef *hcrc);
Nvoid HAL_CRC_MspDeInit(CRC_HandleTypeDef *hcrc);
N/**
N  * @}
N  */
N
N/* Aliases for inter STM32 series compatibility */
N#define HAL_CRC_Input_Data_Reverse   HAL_CRCEx_Input_Data_Reverse
N#define HAL_CRC_Output_Data_Reverse  HAL_CRCEx_Output_Data_Reverse
N
N/** @defgroup CRC_Exported_Functions_Group2 Peripheral Control functions
N  * @{
N  */
N/* Peripheral Control functions ***********************************************/
Nuint32_t HAL_CRC_Accumulate(CRC_HandleTypeDef *hcrc, uint32_t pBuffer[], uint32_t BufferLength);
Nuint32_t HAL_CRC_Calculate(CRC_HandleTypeDef *hcrc, uint32_t pBuffer[], uint32_t BufferLength);
N/**
N  * @}
N  */
N
N/** @defgroup CRC_Exported_Functions_Group3 Peripheral State functions
N  * @{
N  */
N/* Peripheral State and Error functions ***************************************/
NHAL_CRC_StateTypeDef HAL_CRC_GetState(CRC_HandleTypeDef *hcrc);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N
N/* Private types -------------------------------------------------------------*/
N/** @defgroup CRC_Private_Types CRC Private Types
N  * @{
N  */
N
N/**
N  * @}
N  */ 
N
N/* Private defines -----------------------------------------------------------*/
N/** @defgroup CRC_Private_Defines CRC Private Defines
N  * @{
N  */
N
N/**
N  * @}
N  */ 
N
N/* Private variables ---------------------------------------------------------*/
N/** @defgroup CRC_Private_Variables CRC Private Variables
N  * @{
N  */
N
N/**
N  * @}
N  */ 
N
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup CRC_Private_Constants CRC Private Constants
N  * @{
N  */
N
N/**
N  * @}
N  */ 
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup CRC_Private_Macros CRC Private Macros
N  * @{
N  */
N#define IS_DEFAULT_POLYNOMIAL(__DEFAULT__) (((__DEFAULT__) == DEFAULT_POLYNOMIAL_ENABLE) || \
N                                            ((__DEFAULT__) == DEFAULT_POLYNOMIAL_DISABLE))
X#define IS_DEFAULT_POLYNOMIAL(__DEFAULT__) (((__DEFAULT__) == DEFAULT_POLYNOMIAL_ENABLE) ||                                             ((__DEFAULT__) == DEFAULT_POLYNOMIAL_DISABLE))
N#define IS_DEFAULT_INIT_VALUE(__VALUE__)  (((__VALUE__) == DEFAULT_INIT_VALUE_ENABLE) || \
N                                           ((__VALUE__) == DEFAULT_INIT_VALUE_DISABLE))
X#define IS_DEFAULT_INIT_VALUE(__VALUE__)  (((__VALUE__) == DEFAULT_INIT_VALUE_ENABLE) ||                                            ((__VALUE__) == DEFAULT_INIT_VALUE_DISABLE))
N#define IS_CRC_POL_LENGTH(__LENGTH__)     (((__LENGTH__) == CRC_POLYLENGTH_32B) || \
N                                           ((__LENGTH__) == CRC_POLYLENGTH_16B) || \
N                                           ((__LENGTH__) == CRC_POLYLENGTH_8B)  || \
N                                           ((__LENGTH__) == CRC_POLYLENGTH_7B))
X#define IS_CRC_POL_LENGTH(__LENGTH__)     (((__LENGTH__) == CRC_POLYLENGTH_32B) ||                                            ((__LENGTH__) == CRC_POLYLENGTH_16B) ||                                            ((__LENGTH__) == CRC_POLYLENGTH_8B)  ||                                            ((__LENGTH__) == CRC_POLYLENGTH_7B))
N#define IS_CRC_INPUTDATA_FORMAT(__FORMAT__)       (((__FORMAT__) == CRC_INPUTDATA_FORMAT_BYTES) || \
N                                                   ((__FORMAT__) == CRC_INPUTDATA_FORMAT_HALFWORDS) || \
N                                                   ((__FORMAT__) == CRC_INPUTDATA_FORMAT_WORDS))
X#define IS_CRC_INPUTDATA_FORMAT(__FORMAT__)       (((__FORMAT__) == CRC_INPUTDATA_FORMAT_BYTES) ||                                                    ((__FORMAT__) == CRC_INPUTDATA_FORMAT_HALFWORDS) ||                                                    ((__FORMAT__) == CRC_INPUTDATA_FORMAT_WORDS))
N
N
N/**
N  * @}
N  */
N
N/* Private functions prototypes ----------------------------------------------*/
N/** @defgroup CRC_Private_Functions_Prototypes CRC Private Functions Prototypes
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup CRC_Private_Functions CRC Private Functions
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_CRC_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
N
L 275 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_CRC_MODULE_ENABLED */
N
N#ifdef HAL_CRYP_MODULE_ENABLED
S  #include "stm32f7xx_hal_cryp.h" 
N#endif /* HAL_CRYP_MODULE_ENABLED */
N
N#ifdef HAL_DMA2D_MODULE_ENABLED
N  #include "stm32f7xx_hal_dma2d.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_dma2d.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_dma2d.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of DMA2D HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_DMA2D_H
N#define __STM32F7xx_HAL_DMA2D_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup DMA2D DMA2D
N  * @brief DMA2D HAL module driver
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup DMA2D_Exported_Types DMA2D Exported Types
N  * @{
N  */
N#define MAX_DMA2D_LAYER  2
N
N/** 
N  * @brief DMA2D color Structure definition
N  */
Ntypedef struct
N{
N  uint32_t Blue;               /*!< Configures the blue value.
N                                    This parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFF. */
N
N  uint32_t Green;              /*!< Configures the green value.
N                                    This parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFF. */
N
N  uint32_t Red;                /*!< Configures the red value.
N                                    This parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFF. */
N} DMA2D_ColorTypeDef;
N
N/** 
N  * @brief DMA2D CLUT Structure definition
N  */
Ntypedef struct
N{
N  uint32_t *pCLUT;                  /*!< Configures the DMA2D CLUT memory address.*/
N
N  uint32_t CLUTColorMode;           /*!< Configures the DMA2D CLUT color mode.
N                                         This parameter can be one value of @ref DMA2D_CLUT_CM. */
N
N  uint32_t Size;                    /*!< Configures the DMA2D CLUT size. 
N                                         This parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFF.*/
N} DMA2D_CLUTCfgTypeDef;
N
N/** 
N  * @brief DMA2D Init structure definition
N  */
Ntypedef struct
N{
N  uint32_t             Mode;               /*!< Configures the DMA2D transfer mode.
N                                                This parameter can be one value of @ref DMA2D_Mode. */
N
N  uint32_t             ColorMode;          /*!< Configures the color format of the output image.
N                                                This parameter can be one value of @ref DMA2D_Output_Color_Mode. */
N
N  uint32_t             OutputOffset;       /*!< Specifies the Offset value. 
N                                                This parameter must be a number between Min_Data = 0x0000 and Max_Data = 0x3FFF. */
N#if defined (DMA2D_OPFCCR_AI)
X#if 1L
N  uint32_t             AlphaInverted;     /*!< Select regular or inverted alpha value for the output pixel format converter.
N                                               This parameter can be one value of @ref DMA2D_Alpha_Inverted. */
N#endif /* DMA2D_OPFCCR_AI */  
N
N#if defined (DMA2D_OPFCCR_RBS) 
X#if 1L 
N  uint32_t             RedBlueSwap;       /*!< Select regular mode (RGB or ARGB) or swap mode (BGR or ABGR)
N                                               for the output pixel format converter.
N                                               This parameter can be one value of @ref DMA2D_RB_Swap. */ 
N#endif /* DMA2D_OPFCCR_RBS */
N  
N} DMA2D_InitTypeDef;
N
N
N/** 
N  * @brief DMA2D Layer structure definition
N  */
Ntypedef struct
N{
N  uint32_t             InputOffset;       /*!< Configures the DMA2D foreground or background offset.
N                                               This parameter must be a number between Min_Data = 0x0000 and Max_Data = 0x3FFF. */
N
N  uint32_t             InputColorMode;    /*!< Configures the DMA2D foreground or background color mode. 
N                                               This parameter can be one value of @ref DMA2D_Input_Color_Mode. */
N
N  uint32_t             AlphaMode;         /*!< Configures the DMA2D foreground or background alpha mode. 
N                                               This parameter can be one value of @ref DMA2D_Alpha_Mode. */
N
N  uint32_t             InputAlpha;        /*!< Specifies the DMA2D foreground or background alpha value and color value in case of A8 or A4 color mode. 
N                                               This parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFF except for the color modes detailed below.
N                                               @note In case of A8 or A4 color mode (ARGB), this parameter must be a number between 
N                                               Min_Data = 0x00000000 and Max_Data = 0xFFFFFFFF where 
N                                               - InputAlpha[24:31] is the alpha value ALPHA[0:7]
N                                               - InputAlpha[16:23] is the red value RED[0:7]
N                                               - InputAlpha[8:15] is the green value GREEN[0:7]
N                                               - InputAlpha[0:7] is the blue value BLUE[0:7]. */
N
N#if defined (DMA2D_FGPFCCR_AI) && defined (DMA2D_BGPFCCR_AI) 
X#if 1L && 1L 
N  uint32_t             AlphaInverted;     /*!< Select regular or inverted alpha value.
N                                               This parameter can be one value of @ref DMA2D_Alpha_Inverted. 
N                                               This feature is only available on devices :
N                                               STM32F756xx, STM32F767xx, STM32F769xx, STM32F777xx and STM32F779xx.*/
N  
N#endif /* (DMA2D_FGPFCCR_AI) && (DMA2D_BGPFCCR_AI)  */   
N
N#if defined (DMA2D_FGPFCCR_RBS) && defined (DMA2D_BGPFCCR_RBS)   
X#if 1L && 1L   
N  uint32_t             RedBlueSwap;       /*!< Select regular mode (RGB or ARGB) or swap mode (BGR or ABGR).
N                                               This parameter can be one value of @ref DMA2D_RB_Swap
N                                               This feature is only available on devices :
N                                               STM32F756xx, STM32F767xx, STM32F769xx, STM32F777xx and STM32F779xx.*/  
N
N#endif /* (DMA2D_FGPFCCR_RBS) && (DMA2D_BGPFCCR_RBS)  */
N  
N} DMA2D_LayerCfgTypeDef;
N
N/** 
N  * @brief  HAL DMA2D State structures definition
N  */
Ntypedef enum
N{
N  HAL_DMA2D_STATE_RESET             = 0x00U,    /*!< DMA2D not yet initialized or disabled       */
N  HAL_DMA2D_STATE_READY             = 0x01U,    /*!< Peripheral Initialized and ready for use    */
N  HAL_DMA2D_STATE_BUSY              = 0x02U,    /*!< An internal process is ongoing              */
N  HAL_DMA2D_STATE_TIMEOUT           = 0x03U,    /*!< Timeout state                               */
N  HAL_DMA2D_STATE_ERROR             = 0x04U,    /*!< DMA2D state error                           */
N  HAL_DMA2D_STATE_SUSPEND           = 0x05U     /*!< DMA2D process is suspended                  */
N}HAL_DMA2D_StateTypeDef;
N
N/** 
N  * @brief  DMA2D handle Structure definition
N  */
Ntypedef struct __DMA2D_HandleTypeDef
N{
N  DMA2D_TypeDef               *Instance;                                                    /*!< DMA2D register base address.               */
N                                                                                                                                          
N  DMA2D_InitTypeDef           Init;                                                         /*!< DMA2D communication parameters.            */
N
N  void                        (* XferCpltCallback)(struct __DMA2D_HandleTypeDef * hdma2d);  /*!< DMA2D transfer complete callback.          */
N                                                                                                                                           
N  void                        (* XferErrorCallback)(struct __DMA2D_HandleTypeDef * hdma2d); /*!< DMA2D transfer error callback.             */                                                                                                                                             
N
N  DMA2D_LayerCfgTypeDef       LayerCfg[MAX_DMA2D_LAYER];                                    /*!< DMA2D Layers parameters           */  
X  DMA2D_LayerCfgTypeDef       LayerCfg[2];                                       
N
N  HAL_LockTypeDef             Lock;                                                         /*!< DMA2D lock.                                */  
N                                                                                                                                           
N  __IO HAL_DMA2D_StateTypeDef State;                                                        /*!< DMA2D transfer state.                      */
X  volatile HAL_DMA2D_StateTypeDef State;                                                         
N                                                                                                                                           
N  __IO uint32_t               ErrorCode;                                                    /*!< DMA2D error code.                          */  
X  volatile uint32_t               ErrorCode;                                                       
N} DMA2D_HandleTypeDef;
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup DMA2D_Exported_Constants DMA2D Exported Constants
N  * @{
N  */
N
N/** @defgroup DMA2D_Error_Code DMA2D Error Code
N  * @{
N  */
N#define HAL_DMA2D_ERROR_NONE        ((uint32_t)0x00000000U)  /*!< No error             */
N#define HAL_DMA2D_ERROR_TE          ((uint32_t)0x00000001U)  /*!< Transfer error       */
N#define HAL_DMA2D_ERROR_CE          ((uint32_t)0x00000002U)  /*!< Configuration error  */
N#define HAL_DMA2D_ERROR_CAE         ((uint32_t)0x00000004U)  /*!< CLUT access error    */
N#define HAL_DMA2D_ERROR_TIMEOUT     ((uint32_t)0x00000020U)  /*!< Timeout error        */
N/**
N  * @}
N  */
N
N/** @defgroup DMA2D_Mode DMA2D Mode 
N  * @{
N  */
N#define DMA2D_M2M                   ((uint32_t)0x00000000U)  /*!< DMA2D memory to memory transfer mode */
N#define DMA2D_M2M_PFC               DMA2D_CR_MODE_0          /*!< DMA2D memory to memory with pixel format conversion transfer mode */
N#define DMA2D_M2M_BLEND             DMA2D_CR_MODE_1          /*!< DMA2D memory to memory with blending transfer mode */
N#define DMA2D_R2M                   DMA2D_CR_MODE            /*!< DMA2D register to memory transfer mode */
N/**
N  * @}
N  */
N
N/** @defgroup DMA2D_Output_Color_Mode DMA2D Output Color Mode 
N  * @{
N  */
N#define DMA2D_OUTPUT_ARGB8888       ((uint32_t)0x00000000U)               /*!< ARGB8888 DMA2D color mode */
N#define DMA2D_OUTPUT_RGB888         DMA2D_OPFCCR_CM_0                     /*!< RGB888 DMA2D color mode   */
N#define DMA2D_OUTPUT_RGB565         DMA2D_OPFCCR_CM_1                     /*!< RGB565 DMA2D color mode   */
N#define DMA2D_OUTPUT_ARGB1555       (DMA2D_OPFCCR_CM_0|DMA2D_OPFCCR_CM_1) /*!< ARGB1555 DMA2D color mode */
N#define DMA2D_OUTPUT_ARGB4444       DMA2D_OPFCCR_CM_2                     /*!< ARGB4444 DMA2D color mode */
N/**
N  * @}
N  */
N
N/** @defgroup DMA2D_Input_Color_Mode DMA2D Input Color Mode
N  * @{
N  */
N#define DMA2D_INPUT_ARGB8888        ((uint32_t)0x00000000U)  /*!< ARGB8888 color mode */
N#define DMA2D_INPUT_RGB888          ((uint32_t)0x00000001U)  /*!< RGB888 color mode   */
N#define DMA2D_INPUT_RGB565          ((uint32_t)0x00000002U)  /*!< RGB565 color mode   */
N#define DMA2D_INPUT_ARGB1555        ((uint32_t)0x00000003U)  /*!< ARGB1555 color mode */
N#define DMA2D_INPUT_ARGB4444        ((uint32_t)0x00000004U)  /*!< ARGB4444 color mode */
N#define DMA2D_INPUT_L8              ((uint32_t)0x00000005U)  /*!< L8 color mode       */
N#define DMA2D_INPUT_AL44            ((uint32_t)0x00000006U)  /*!< AL44 color mode     */
N#define DMA2D_INPUT_AL88            ((uint32_t)0x00000007U)  /*!< AL88 color mode     */
N#define DMA2D_INPUT_L4              ((uint32_t)0x00000008U)  /*!< L4 color mode       */
N#define DMA2D_INPUT_A8              ((uint32_t)0x00000009U)  /*!< A8 color mode       */
N#define DMA2D_INPUT_A4              ((uint32_t)0x0000000AU)  /*!< A4 color mode       */
N/**
N  * @}
N  */
N
N/** @defgroup DMA2D_Alpha_Mode DMA2D Alpha Mode
N  * @{
N  */
N#define DMA2D_NO_MODIF_ALPHA        ((uint32_t)0x00000000U)  /*!< No modification of the alpha channel value */
N#define DMA2D_REPLACE_ALPHA         ((uint32_t)0x00000001U)  /*!< Replace original alpha channel value by programmed alpha value */
N#define DMA2D_COMBINE_ALPHA         ((uint32_t)0x00000002U)  /*!< Replace original alpha channel value by programmed alpha value
N                                                                with original alpha channel value                              */
N/**
N  * @}
N  */    
N
N#if defined (DMA2D_FGPFCCR_AI) && defined (DMA2D_BGPFCCR_AI)    
X#if 1L && 1L    
N/** @defgroup DMA2D_Alpha_Inverted DMA2D ALPHA Inversion
N  * @{
N  */
N#define DMA2D_REGULAR_ALPHA         ((uint32_t)0x00000000U)  /*!< No modification of the alpha channel value */
N#define DMA2D_INVERTED_ALPHA        ((uint32_t)0x00000001U)  /*!< Invert the alpha channel value */                                  
N/**
N  * @}
N  */
N#endif /* (DMA2D_FGPFCCR_AI) && (DMA2D_BGPFCCR_AI)  */
N
N#if defined (DMA2D_FGPFCCR_RBS) && defined (DMA2D_BGPFCCR_RBS)  
X#if 1L && 1L  
N/** @defgroup DMA2D_RB_Swap DMA2D Red and Blue Swap
N  * @{
N  */
N#define DMA2D_RB_REGULAR            ((uint32_t)0x00000000U)  /*!< Select regular mode (RGB or ARGB) */
N#define DMA2D_RB_SWAP               ((uint32_t)0x00000001U)  /*!< Select swap mode (BGR or ABGR) */
N/**
N  * @}
N  */ 
N#endif /* (DMA2D_FGPFCCR_RBS) && (DMA2D_BGPFCCR_RBS)  */     
N
N/** @defgroup DMA2D_CLUT_CM DMA2D CLUT Color Mode
N  * @{
N  */
N#define DMA2D_CCM_ARGB8888          ((uint32_t)0x00000000U)  /*!< ARGB8888 DMA2D CLUT color mode */
N#define DMA2D_CCM_RGB888            ((uint32_t)0x00000001U)  /*!< RGB888 DMA2D CLUT color mode   */
N/**
N  * @}
N  */
N
N
N/** @defgroup DMA2D_Interrupts DMA2D Interrupts 
N  * @{
N  */
N#define DMA2D_IT_CE                 DMA2D_CR_CEIE            /*!< Configuration Error Interrupt */
N#define DMA2D_IT_CTC                DMA2D_CR_CTCIE           /*!< CLUT Transfer Complete Interrupt */
N#define DMA2D_IT_CAE                DMA2D_CR_CAEIE           /*!< CLUT Access Error Interrupt */
N#define DMA2D_IT_TW                 DMA2D_CR_TWIE            /*!< Transfer Watermark Interrupt */
N#define DMA2D_IT_TC                 DMA2D_CR_TCIE            /*!< Transfer Complete Interrupt */
N#define DMA2D_IT_TE                 DMA2D_CR_TEIE            /*!< Transfer Error Interrupt */
N/**                                                         
N  * @}                                                      
N  */                                                        
N                                                            
N/** @defgroup DMA2D_Flags DMA2D Flags                       
N  * @{                                                      
N  */                                                        
N#define DMA2D_FLAG_CE               DMA2D_ISR_CEIF           /*!< Configuration Error Interrupt Flag */
N#define DMA2D_FLAG_CTC              DMA2D_ISR_CTCIF          /*!< CLUT Transfer Complete Interrupt Flag */
N#define DMA2D_FLAG_CAE              DMA2D_ISR_CAEIF          /*!< CLUT Access Error Interrupt Flag */
N#define DMA2D_FLAG_TW               DMA2D_ISR_TWIF           /*!< Transfer Watermark Interrupt Flag */
N#define DMA2D_FLAG_TC               DMA2D_ISR_TCIF           /*!< Transfer Complete Interrupt Flag */
N#define DMA2D_FLAG_TE               DMA2D_ISR_TEIF           /*!< Transfer Error Interrupt Flag */
N/**
N  * @}
N  */
N  
N/** @defgroup DMA2D_Aliases DMA2D API Aliases
N  * @{
N  */
N#define HAL_DMA2D_DisableCLUT       HAL_DMA2D_CLUTLoading_Abort    /*!< Aliased to HAL_DMA2D_CLUTLoading_Abort for compatibility with legacy code */
N/**
N  * @}
N  */
N  
N  
N/**
N  * @}
N  */
N/* Exported macros ------------------------------------------------------------*/
N/** @defgroup DMA2D_Exported_Macros DMA2D Exported Macros
N  * @{
N  */
N
N/** @brief Reset DMA2D handle state
N  * @param  __HANDLE__: specifies the DMA2D handle.
N  * @retval None
N  */
N#define __HAL_DMA2D_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_DMA2D_STATE_RESET)
N
N/**
N  * @brief  Enable the DMA2D.
N  * @param  __HANDLE__: DMA2D handle
N  * @retval None.
N  */
N#define __HAL_DMA2D_ENABLE(__HANDLE__)        ((__HANDLE__)->Instance->CR |= DMA2D_CR_START)
N
N
N/* Interrupt & Flag management */
N/**
N  * @brief  Get the DMA2D pending flags.
N  * @param  __HANDLE__: DMA2D handle
N  * @param  __FLAG__: flag to check.
N  *          This parameter can be any combination of the following values:
N  *            @arg DMA2D_FLAG_CE:  Configuration error flag
N  *            @arg DMA2D_FLAG_CTC: CLUT transfer complete flag
N  *            @arg DMA2D_FLAG_CAE: CLUT access error flag
N  *            @arg DMA2D_FLAG_TW:  Transfer Watermark flag
N  *            @arg DMA2D_FLAG_TC:  Transfer complete flag
N  *            @arg DMA2D_FLAG_TE:  Transfer error flag   
N  * @retval The state of FLAG.
N  */
N#define __HAL_DMA2D_GET_FLAG(__HANDLE__, __FLAG__) ((__HANDLE__)->Instance->ISR & (__FLAG__))
N
N/**
N  * @brief  Clear the DMA2D pending flags.
N  * @param  __HANDLE__: DMA2D handle
N  * @param  __FLAG__: specifies the flag to clear.
N  *          This parameter can be any combination of the following values:
N  *            @arg DMA2D_FLAG_CE:  Configuration error flag
N  *            @arg DMA2D_FLAG_CTC: CLUT transfer complete flag
N  *            @arg DMA2D_FLAG_CAE: CLUT access error flag
N  *            @arg DMA2D_FLAG_TW:  Transfer Watermark flag
N  *            @arg DMA2D_FLAG_TC:  Transfer complete flag
N  *            @arg DMA2D_FLAG_TE:  Transfer error flag    
N  * @retval None
N  */
N#define __HAL_DMA2D_CLEAR_FLAG(__HANDLE__, __FLAG__) ((__HANDLE__)->Instance->IFCR = (__FLAG__))
N
N/**
N  * @brief  Enable the specified DMA2D interrupts.
N  * @param  __HANDLE__: DMA2D handle
N  * @param __INTERRUPT__: specifies the DMA2D interrupt sources to be enabled. 
N  *          This parameter can be any combination of the following values:
N  *            @arg DMA2D_IT_CE:  Configuration error interrupt mask
N  *            @arg DMA2D_IT_CTC: CLUT transfer complete interrupt mask
N  *            @arg DMA2D_IT_CAE: CLUT access error interrupt mask
N  *            @arg DMA2D_IT_TW:  Transfer Watermark interrupt mask
N  *            @arg DMA2D_IT_TC:  Transfer complete interrupt mask
N  *            @arg DMA2D_IT_TE:  Transfer error interrupt mask
N  * @retval None
N  */
N#define __HAL_DMA2D_ENABLE_IT(__HANDLE__, __INTERRUPT__) ((__HANDLE__)->Instance->CR |= (__INTERRUPT__))
N
N/**
N  * @brief  Disable the specified DMA2D interrupts.
N  * @param  __HANDLE__: DMA2D handle
N  * @param __INTERRUPT__: specifies the DMA2D interrupt sources to be disabled. 
N  *          This parameter can be any combination of the following values:
N  *            @arg DMA2D_IT_CE:  Configuration error interrupt mask
N  *            @arg DMA2D_IT_CTC: CLUT transfer complete interrupt mask
N  *            @arg DMA2D_IT_CAE: CLUT access error interrupt mask
N  *            @arg DMA2D_IT_TW:  Transfer Watermark interrupt mask
N  *            @arg DMA2D_IT_TC:  Transfer complete interrupt mask
N  *            @arg DMA2D_IT_TE:  Transfer error interrupt mask
N  * @retval None
N  */
N#define __HAL_DMA2D_DISABLE_IT(__HANDLE__, __INTERRUPT__) ((__HANDLE__)->Instance->CR &= ~(__INTERRUPT__))
N
N/**
N  * @brief  Check whether the specified DMA2D interrupt source is enabled or not.
N  * @param  __HANDLE__: DMA2D handle
N  * @param  __INTERRUPT__: specifies the DMA2D interrupt source to check.
N  *          This parameter can be one of the following values:
N  *            @arg DMA2D_IT_CE:  Configuration error interrupt mask
N  *            @arg DMA2D_IT_CTC: CLUT transfer complete interrupt mask
N  *            @arg DMA2D_IT_CAE: CLUT access error interrupt mask
N  *            @arg DMA2D_IT_TW:  Transfer Watermark interrupt mask
N  *            @arg DMA2D_IT_TC:  Transfer complete interrupt mask
N  *            @arg DMA2D_IT_TE:  Transfer error interrupt mask
N  * @retval The state of INTERRUPT source.
N  */
N#define __HAL_DMA2D_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) ((__HANDLE__)->Instance->CR & (__INTERRUPT__))
N     
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/  
N/** @addtogroup DMA2D_Exported_Functions DMA2D Exported Functions
N  * @{
N  */
N
N/** @addtogroup DMA2D_Exported_Functions_Group1 Initialization and de-initialization functions
N  * @{
N  */  
N  
N/* Initialization and de-initialization functions *******************************/
NHAL_StatusTypeDef HAL_DMA2D_Init(DMA2D_HandleTypeDef *hdma2d); 
NHAL_StatusTypeDef HAL_DMA2D_DeInit (DMA2D_HandleTypeDef *hdma2d);
Nvoid              HAL_DMA2D_MspInit(DMA2D_HandleTypeDef* hdma2d);
Nvoid              HAL_DMA2D_MspDeInit(DMA2D_HandleTypeDef* hdma2d);
N
N/**
N  * @}
N  */
N
N
N/** @addtogroup DMA2D_Exported_Functions_Group2 IO operation functions
N  * @{
N  */
N  
N/* IO operation functions *******************************************************/
NHAL_StatusTypeDef HAL_DMA2D_Start(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width, uint32_t Height);
NHAL_StatusTypeDef HAL_DMA2D_BlendingStart(DMA2D_HandleTypeDef *hdma2d, uint32_t SrcAddress1, uint32_t SrcAddress2, uint32_t DstAddress, uint32_t Width,  uint32_t Height);
NHAL_StatusTypeDef HAL_DMA2D_Start_IT(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width, uint32_t Height);
NHAL_StatusTypeDef HAL_DMA2D_BlendingStart_IT(DMA2D_HandleTypeDef *hdma2d, uint32_t SrcAddress1, uint32_t SrcAddress2, uint32_t DstAddress, uint32_t Width, uint32_t Height);
NHAL_StatusTypeDef HAL_DMA2D_Suspend(DMA2D_HandleTypeDef *hdma2d);
NHAL_StatusTypeDef HAL_DMA2D_Resume(DMA2D_HandleTypeDef *hdma2d);
NHAL_StatusTypeDef HAL_DMA2D_Abort(DMA2D_HandleTypeDef *hdma2d);
NHAL_StatusTypeDef HAL_DMA2D_EnableCLUT(DMA2D_HandleTypeDef *hdma2d, uint32_t LayerIdx);
NHAL_StatusTypeDef HAL_DMA2D_CLUTLoad(DMA2D_HandleTypeDef *hdma2d, DMA2D_CLUTCfgTypeDef CLUTCfg, uint32_t LayerIdx);
NHAL_StatusTypeDef HAL_DMA2D_CLUTLoad_IT(DMA2D_HandleTypeDef *hdma2d, DMA2D_CLUTCfgTypeDef CLUTCfg, uint32_t LayerIdx);
NHAL_StatusTypeDef HAL_DMA2D_CLUTLoading_Abort(DMA2D_HandleTypeDef *hdma2d, uint32_t LayerIdx);
NHAL_StatusTypeDef HAL_DMA2D_CLUTLoading_Suspend(DMA2D_HandleTypeDef *hdma2d, uint32_t LayerIdx);
NHAL_StatusTypeDef HAL_DMA2D_CLUTLoading_Resume(DMA2D_HandleTypeDef *hdma2d, uint32_t LayerIdx);
NHAL_StatusTypeDef HAL_DMA2D_PollForTransfer(DMA2D_HandleTypeDef *hdma2d, uint32_t Timeout);
Nvoid              HAL_DMA2D_IRQHandler(DMA2D_HandleTypeDef *hdma2d);
Nvoid              HAL_DMA2D_LineEventCallback(DMA2D_HandleTypeDef *hdma2d);
Nvoid              HAL_DMA2D_CLUTLoadingCpltCallback(DMA2D_HandleTypeDef *hdma2d);
N
N/**
N  * @}
N  */
N
N/** @addtogroup DMA2D_Exported_Functions_Group3 Peripheral Control functions
N  * @{
N  */
N
N/* Peripheral Control functions *************************************************/
NHAL_StatusTypeDef HAL_DMA2D_ConfigLayer(DMA2D_HandleTypeDef *hdma2d, uint32_t LayerIdx);
NHAL_StatusTypeDef HAL_DMA2D_ConfigCLUT(DMA2D_HandleTypeDef *hdma2d, DMA2D_CLUTCfgTypeDef CLUTCfg, uint32_t LayerIdx);
NHAL_StatusTypeDef HAL_DMA2D_ProgramLineEvent(DMA2D_HandleTypeDef *hdma2d, uint32_t Line);
NHAL_StatusTypeDef HAL_DMA2D_EnableDeadTime(DMA2D_HandleTypeDef *hdma2d);
NHAL_StatusTypeDef HAL_DMA2D_DisableDeadTime(DMA2D_HandleTypeDef *hdma2d);
NHAL_StatusTypeDef HAL_DMA2D_ConfigDeadTime(DMA2D_HandleTypeDef *hdma2d, uint8_t DeadTime);
N
N/**
N  * @}
N  */
N
N/** @addtogroup DMA2D_Exported_Functions_Group4 Peripheral State and Error functions
N  * @{
N  */
N
N/* Peripheral State functions ***************************************************/
NHAL_DMA2D_StateTypeDef HAL_DMA2D_GetState(DMA2D_HandleTypeDef *hdma2d);
Nuint32_t               HAL_DMA2D_GetError(DMA2D_HandleTypeDef *hdma2d);
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private constants ---------------------------------------------------------*/  
N  
N/** @addtogroup DMA2D_Private_Constants DMA2D Private Constants
N  * @{
N  */                         
N
N/** @defgroup DMA2D_Maximum_Line_WaterMark DMA2D Maximum Line Watermark 
N  * @{
N  */
N#define DMA2D_LINE_WATERMARK_MAX            DMA2D_LWR_LW       /*!< DMA2D maximum line watermark */
N/**
N  * @}
N  */
N  
N/** @defgroup DMA2D_Color_Value DMA2D Color Value
N  * @{
N  */
N#define DMA2D_COLOR_VALUE                 ((uint32_t)0x000000FFU)  /*!< Color value mask */
N/**
N  * @}
N  */      
N
N/** @defgroup DMA2D_Max_Layer DMA2D Maximum Number of Layers
N  * @{
N  */  
N#define DMA2D_MAX_LAYER         2         /*!< DMA2D maximum number of layers */  
N/**
N  * @}
N  */ 
N  
N/** @defgroup DMA2D_Offset DMA2D Offset 
N  * @{
N  */
N#define DMA2D_OFFSET                DMA2D_FGOR_LO            /*!< Line Offset */
N/**
N  * @}
N  */ 
N  
N/** @defgroup DMA2D_Size DMA2D Size 
N  * @{
N  */
N#define DMA2D_PIXEL                 (DMA2D_NLR_PL >> 16U)    /*!< DMA2D number of pixels per line */
N#define DMA2D_LINE                  DMA2D_NLR_NL             /*!< DMA2D number of lines           */
N/**
N  * @}
N  */    
N  
N/** @defgroup DMA2D_CLUT_Size DMA2D CLUT Size
N  * @{
N  */
N#define DMA2D_CLUT_SIZE             (DMA2D_FGPFCCR_CS >> 8)  /*!< DMA2D CLUT size */
N/**
N  * @}
N  */   
N    
N/**
N  * @}
N  */ 
N
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup DMA2D_Private_Macros DMA2D Private Macros
N  * @{
N  */
N#define IS_DMA2D_LAYER(LAYER)                 ((LAYER) <= DMA2D_MAX_LAYER)
N#define IS_DMA2D_MODE(MODE)                   (((MODE) == DMA2D_M2M)       || ((MODE) == DMA2D_M2M_PFC) || \
N                                               ((MODE) == DMA2D_M2M_BLEND) || ((MODE) == DMA2D_R2M))
X#define IS_DMA2D_MODE(MODE)                   (((MODE) == DMA2D_M2M)       || ((MODE) == DMA2D_M2M_PFC) ||                                                ((MODE) == DMA2D_M2M_BLEND) || ((MODE) == DMA2D_R2M))
N#define IS_DMA2D_CMODE(MODE_ARGB)             (((MODE_ARGB) == DMA2D_OUTPUT_ARGB8888) || ((MODE_ARGB) == DMA2D_OUTPUT_RGB888)   || \
N                                               ((MODE_ARGB) == DMA2D_OUTPUT_RGB565)   || ((MODE_ARGB) == DMA2D_OUTPUT_ARGB1555) || \
N                                               ((MODE_ARGB) == DMA2D_OUTPUT_ARGB4444))
X#define IS_DMA2D_CMODE(MODE_ARGB)             (((MODE_ARGB) == DMA2D_OUTPUT_ARGB8888) || ((MODE_ARGB) == DMA2D_OUTPUT_RGB888)   ||                                                ((MODE_ARGB) == DMA2D_OUTPUT_RGB565)   || ((MODE_ARGB) == DMA2D_OUTPUT_ARGB1555) ||                                                ((MODE_ARGB) == DMA2D_OUTPUT_ARGB4444))
N#define IS_DMA2D_COLOR(COLOR)                 ((COLOR) <= DMA2D_COLOR_VALUE)
N#define IS_DMA2D_LINE(LINE)                   ((LINE) <= DMA2D_LINE)
N#define IS_DMA2D_PIXEL(PIXEL)                 ((PIXEL) <= DMA2D_PIXEL)
N#define IS_DMA2D_OFFSET(OOFFSET)              ((OOFFSET) <= DMA2D_OFFSET)
N#define IS_DMA2D_INPUT_COLOR_MODE(INPUT_CM)   (((INPUT_CM) == DMA2D_INPUT_ARGB8888) || ((INPUT_CM) == DMA2D_INPUT_RGB888)   || \
N                                               ((INPUT_CM) == DMA2D_INPUT_RGB565)   || ((INPUT_CM) == DMA2D_INPUT_ARGB1555) || \
N                                               ((INPUT_CM) == DMA2D_INPUT_ARGB4444) || ((INPUT_CM) == DMA2D_INPUT_L8)       || \
N                                               ((INPUT_CM) == DMA2D_INPUT_AL44)     || ((INPUT_CM) == DMA2D_INPUT_AL88)     || \
N                                               ((INPUT_CM) == DMA2D_INPUT_L4)       || ((INPUT_CM) == DMA2D_INPUT_A8)       || \
N                                               ((INPUT_CM) == DMA2D_INPUT_A4))
X#define IS_DMA2D_INPUT_COLOR_MODE(INPUT_CM)   (((INPUT_CM) == DMA2D_INPUT_ARGB8888) || ((INPUT_CM) == DMA2D_INPUT_RGB888)   ||                                                ((INPUT_CM) == DMA2D_INPUT_RGB565)   || ((INPUT_CM) == DMA2D_INPUT_ARGB1555) ||                                                ((INPUT_CM) == DMA2D_INPUT_ARGB4444) || ((INPUT_CM) == DMA2D_INPUT_L8)       ||                                                ((INPUT_CM) == DMA2D_INPUT_AL44)     || ((INPUT_CM) == DMA2D_INPUT_AL88)     ||                                                ((INPUT_CM) == DMA2D_INPUT_L4)       || ((INPUT_CM) == DMA2D_INPUT_A8)       ||                                                ((INPUT_CM) == DMA2D_INPUT_A4))
N#define IS_DMA2D_ALPHA_MODE(AlphaMode)        (((AlphaMode) == DMA2D_NO_MODIF_ALPHA) || \
N                                               ((AlphaMode) == DMA2D_REPLACE_ALPHA)  || \
N                                               ((AlphaMode) == DMA2D_COMBINE_ALPHA))
X#define IS_DMA2D_ALPHA_MODE(AlphaMode)        (((AlphaMode) == DMA2D_NO_MODIF_ALPHA) ||                                                ((AlphaMode) == DMA2D_REPLACE_ALPHA)  ||                                                ((AlphaMode) == DMA2D_COMBINE_ALPHA))
N
N#define IS_DMA2D_ALPHA_INVERTED(Alpha_Inverted) (((Alpha_Inverted) == DMA2D_REGULAR_ALPHA) || \
N                                                 ((Alpha_Inverted) == DMA2D_INVERTED_ALPHA))
X#define IS_DMA2D_ALPHA_INVERTED(Alpha_Inverted) (((Alpha_Inverted) == DMA2D_REGULAR_ALPHA) ||                                                  ((Alpha_Inverted) == DMA2D_INVERTED_ALPHA))
N
N#define IS_DMA2D_RB_SWAP(RB_Swap) (((RB_Swap) == DMA2D_RB_REGULAR) || \
N                                   ((RB_Swap) == DMA2D_RB_SWAP))
X#define IS_DMA2D_RB_SWAP(RB_Swap) (((RB_Swap) == DMA2D_RB_REGULAR) ||                                    ((RB_Swap) == DMA2D_RB_SWAP))
N
N#define IS_DMA2D_CLUT_CM(CLUT_CM)             (((CLUT_CM) == DMA2D_CCM_ARGB8888) || ((CLUT_CM) == DMA2D_CCM_RGB888))
N#define IS_DMA2D_CLUT_SIZE(CLUT_SIZE)         ((CLUT_SIZE) <= DMA2D_CLUT_SIZE)
N#define IS_DMA2D_LINEWATERMARK(LineWatermark) ((LineWatermark) <= DMA2D_LINE_WATERMARK_MAX)
N#define IS_DMA2D_IT(IT)                       (((IT) == DMA2D_IT_CTC) || ((IT) == DMA2D_IT_CAE) || \
N                                               ((IT) == DMA2D_IT_TW) || ((IT) == DMA2D_IT_TC) || \
N                                               ((IT) == DMA2D_IT_TE) || ((IT) == DMA2D_IT_CE))
X#define IS_DMA2D_IT(IT)                       (((IT) == DMA2D_IT_CTC) || ((IT) == DMA2D_IT_CAE) ||                                                ((IT) == DMA2D_IT_TW) || ((IT) == DMA2D_IT_TC) ||                                                ((IT) == DMA2D_IT_TE) || ((IT) == DMA2D_IT_CE))
N#define IS_DMA2D_GET_FLAG(FLAG)               (((FLAG) == DMA2D_FLAG_CTC) || ((FLAG) == DMA2D_FLAG_CAE) || \
N                                               ((FLAG) == DMA2D_FLAG_TW)   || ((FLAG) == DMA2D_FLAG_TC)  || \
N                                               ((FLAG) == DMA2D_FLAG_TE)   || ((FLAG) == DMA2D_FLAG_CE))
X#define IS_DMA2D_GET_FLAG(FLAG)               (((FLAG) == DMA2D_FLAG_CTC) || ((FLAG) == DMA2D_FLAG_CAE) ||                                                ((FLAG) == DMA2D_FLAG_TW)   || ((FLAG) == DMA2D_FLAG_TC)  ||                                                ((FLAG) == DMA2D_FLAG_TE)   || ((FLAG) == DMA2D_FLAG_CE))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_DMA2D_H */
N 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 283 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_DMA2D_MODULE_ENABLED */
N
N#ifdef HAL_DAC_MODULE_ENABLED
N  #include "stm32f7xx_hal_dac.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_dac.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_dac.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of DAC HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_DAC_H
N#define __STM32F7xx_HAL_DAC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup DAC
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup DAC_Exported_Types DAC Exported Types
N  * @{
N  */
N
N/** 
N  * @brief HAL State structures definition
N  */
Ntypedef enum
N{
N  HAL_DAC_STATE_RESET             = 0x00U,  /*!< DAC not yet initialized or disabled  */
N  HAL_DAC_STATE_READY             = 0x01U,  /*!< DAC initialized and ready for use    */
N  HAL_DAC_STATE_BUSY              = 0x02U,  /*!< DAC internal processing is ongoing   */
N  HAL_DAC_STATE_TIMEOUT           = 0x03U,  /*!< DAC timeout state                    */
N  HAL_DAC_STATE_ERROR             = 0x04U   /*!< DAC error state                      */
N}HAL_DAC_StateTypeDef;
N 
N/** 
N  * @brief DAC handle Structure definition
N  */
Ntypedef struct
N{
N  DAC_TypeDef                 *Instance;     /*!< Register base address             */
N
N  __IO HAL_DAC_StateTypeDef   State;         /*!< DAC communication state           */
X  volatile HAL_DAC_StateTypeDef   State;          
N
N  HAL_LockTypeDef             Lock;          /*!< DAC locking object                */
N
N  DMA_HandleTypeDef           *DMA_Handle1;  /*!< Pointer DMA handler for channel 1 */
N
N  DMA_HandleTypeDef           *DMA_Handle2;  /*!< Pointer DMA handler for channel 2 */
N
N  __IO uint32_t               ErrorCode;     /*!< DAC Error code                    */
X  volatile uint32_t               ErrorCode;      
N
N}DAC_HandleTypeDef;
N
N/** 
N  * @brief DAC Configuration regular Channel structure definition
N  */
Ntypedef struct
N{
N  uint32_t DAC_Trigger;       /*!< Specifies the external trigger for the selected DAC channel.
N                                   This parameter can be a value of @ref DAC_trigger_selection */
N
N  uint32_t DAC_OutputBuffer;  /*!< Specifies whether the DAC channel output buffer is enabled or disabled.
N                                   This parameter can be a value of @ref DAC_output_buffer */
N}DAC_ChannelConfTypeDef;
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup DAC_Exported_Constants DAC Exported Constants
N  * @{
N  */
N
N/** @defgroup DAC_Error_Code DAC Error Code
N  * @{
N  */
N#define  HAL_DAC_ERROR_NONE              0x00U    /*!< No error                          */
N#define  HAL_DAC_ERROR_DMAUNDERRUNCH1    0x01U    /*!< DAC channel1 DAM underrun error   */
N#define  HAL_DAC_ERROR_DMAUNDERRUNCH2    0x02U    /*!< DAC channel2 DAM underrun error   */
N#define  HAL_DAC_ERROR_DMA               0x04U    /*!< DMA error                         */
N/**
N  * @}
N  */
N
N/** @defgroup DAC_trigger_selection DAC Trigger Selection
N  * @{
N  */
N
N#define DAC_TRIGGER_NONE                   ((uint32_t)0x00000000U) /*!< Conversion is automatic once the DAC1_DHRxxxx register 
N                                                                       has been loaded, and not by external trigger */
N#define DAC_TRIGGER_T2_TRGO                ((uint32_t)(DAC_CR_TSEL1_2 | DAC_CR_TEN1)) /*!< TIM2 TRGO selected as external conversion trigger for DAC channel */
N#define DAC_TRIGGER_T4_TRGO                ((uint32_t)(DAC_CR_TSEL1_2 | DAC_CR_TSEL1_0 | DAC_CR_TEN1)) /*!< TIM4 TRGO selected as external conversion trigger for DAC channel */
N#define DAC_TRIGGER_T5_TRGO                ((uint32_t)(DAC_CR_TSEL1_1 | DAC_CR_TSEL1_0 | DAC_CR_TEN1)) /*!< TIM5 TRGO selected as external conversion trigger for DAC channel */
N#define DAC_TRIGGER_T6_TRGO                ((uint32_t)DAC_CR_TEN1) /*!< TIM6 TRGO selected as external conversion trigger for DAC channel */
N#define DAC_TRIGGER_T7_TRGO                ((uint32_t)(DAC_CR_TSEL1_1 | DAC_CR_TEN1)) /*!< TIM7 TRGO selected as external conversion trigger for DAC channel */
N#define DAC_TRIGGER_T8_TRGO                ((uint32_t)(DAC_CR_TSEL1_0 | DAC_CR_TEN1)) /*!< TIM8 TRGO selected as external conversion trigger for DAC channel */                                                                       
N
N#define DAC_TRIGGER_EXT_IT9                ((uint32_t)(DAC_CR_TSEL1_2 | DAC_CR_TSEL1_1 | DAC_CR_TEN1)) /*!< EXTI Line9 event selected as external conversion trigger for DAC channel */
N#define DAC_TRIGGER_SOFTWARE               ((uint32_t)(DAC_CR_TSEL1 | DAC_CR_TEN1)) /*!< Conversion started by software trigger for DAC channel */
N/**
N  * @}
N  */
N
N/** @defgroup DAC_output_buffer  DAC Output Buffer
N  * @{
N  */
N#define DAC_OUTPUTBUFFER_ENABLE            ((uint32_t)0x00000000U)
N#define DAC_OUTPUTBUFFER_DISABLE           ((uint32_t)DAC_CR_BOFF1)
N/**
N  * @}
N  */
N
N/** @defgroup DAC_Channel_selection DAC Channel Selection
N  * @{
N  */
N#define DAC_CHANNEL_1                      ((uint32_t)0x00000000U)
N#define DAC_CHANNEL_2                      ((uint32_t)0x00000010U)
N/**
N  * @}
N  */
N
N/** @defgroup DAC_data_alignment DAC Data Alignment
N  * @{
N  */
N#define DAC_ALIGN_12B_R                    ((uint32_t)0x00000000U)
N#define DAC_ALIGN_12B_L                    ((uint32_t)0x00000004U)
N#define DAC_ALIGN_8B_R                     ((uint32_t)0x00000008U)
N/**
N  * @}
N  */
N
N/** @defgroup DAC_flags_definition DAC Flags Definition
N  * @{
N  */ 
N#define DAC_FLAG_DMAUDR1                   ((uint32_t)DAC_SR_DMAUDR1)
N#define DAC_FLAG_DMAUDR2                   ((uint32_t)DAC_SR_DMAUDR2)
N/**
N  * @}
N  */
N
N/** @defgroup DAC_IT_definition DAC IT Definition
N  * @{
N  */ 
N#define DAC_IT_DMAUDR1                   ((uint32_t)DAC_SR_DMAUDR1)
N#define DAC_IT_DMAUDR2                   ((uint32_t)DAC_SR_DMAUDR2)
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup DAC_Exported_Macros DAC Exported Macros
N  * @{
N  */
N
N/** @brief Reset DAC handle state
N  * @param  __HANDLE__: specifies the DAC handle.
N  * @retval None
N  */
N#define __HAL_DAC_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_DAC_STATE_RESET)
N
N/** @brief Enable the DAC channel
N  * @param  __HANDLE__: specifies the DAC handle.
N  * @param  __DAC_CHANNEL__: specifies the DAC channel
N  * @retval None
N  */
N#define __HAL_DAC_ENABLE(__HANDLE__, __DAC_CHANNEL__) \
N((__HANDLE__)->Instance->CR |=  (DAC_CR_EN1 << (__DAC_CHANNEL__)))
X#define __HAL_DAC_ENABLE(__HANDLE__, __DAC_CHANNEL__) ((__HANDLE__)->Instance->CR |=  (DAC_CR_EN1 << (__DAC_CHANNEL__)))
N
N/** @brief Disable the DAC channel
N  * @param  __HANDLE__: specifies the DAC handle
N  * @param  __DAC_CHANNEL__: specifies the DAC channel.
N  * @retval None
N  */
N#define __HAL_DAC_DISABLE(__HANDLE__, __DAC_CHANNEL__) \
N((__HANDLE__)->Instance->CR &=  ~(DAC_CR_EN1 << (__DAC_CHANNEL__)))
X#define __HAL_DAC_DISABLE(__HANDLE__, __DAC_CHANNEL__) ((__HANDLE__)->Instance->CR &=  ~(DAC_CR_EN1 << (__DAC_CHANNEL__)))
N
N
N/** @brief Enable the DAC interrupt
N  * @param  __HANDLE__: specifies the DAC handle
N  * @param  __INTERRUPT__: specifies the DAC interrupt.
N  * @retval None
N  */
N#define __HAL_DAC_ENABLE_IT(__HANDLE__, __INTERRUPT__) (((__HANDLE__)->Instance->CR) |= (__INTERRUPT__))
N
N/** @brief Disable the DAC interrupt
N  * @param  __HANDLE__: specifies the DAC handle
N  * @param  __INTERRUPT__: specifies the DAC interrupt.
N  * @retval None
N  */
N#define __HAL_DAC_DISABLE_IT(__HANDLE__, __INTERRUPT__) (((__HANDLE__)->Instance->CR) &= ~(__INTERRUPT__))
N
N/** @brief  Checks if the specified DAC interrupt source is enabled or disabled.
N  * @param __HANDLE__: DAC handle
N  * @param __INTERRUPT__: DAC interrupt source to check
N  *          This parameter can be any combination of the following values:
N  *            @arg DAC_IT_DMAUDR1: DAC channel 1 DMA underrun interrupt
N  *            @arg DAC_IT_DMAUDR2: DAC channel 2 DMA underrun interrupt
N  * @retval State of interruption (SET or RESET)
N  */
N#define __HAL_DAC_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) (((__HANDLE__)->Instance->CR & (__INTERRUPT__)) == (__INTERRUPT__))
N
N/** @brief  Get the selected DAC's flag status.
N  * @param  __HANDLE__: specifies the DAC handle.
N  * @param  __FLAG__: specifies the flag to clear.
N  *         This parameter can be any combination of the following values:
N  *            @arg DAC_FLAG_DMAUDR1: DMA underrun 1 flag
N  *            @arg DAC_FLAG_DMAUDR2: DMA underrun 2 flag
N  * @retval None
N  */
N#define __HAL_DAC_GET_FLAG(__HANDLE__, __FLAG__) ((((__HANDLE__)->Instance->SR) & (__FLAG__)) == (__FLAG__))
N
N/** @brief  Clear the DAC's flag.
N  * @param  __HANDLE__: specifies the DAC handle.
N  * @param  __FLAG__: specifies the flag to clear.
N  *         This parameter can be any combination of the following values:
N  *            @arg DAC_FLAG_DMAUDR1: DMA underrun 1 flag
N  *            @arg DAC_FLAG_DMAUDR2: DMA underrun 2 flag
N  * @retval None
N  */
N#define __HAL_DAC_CLEAR_FLAG(__HANDLE__, __FLAG__) (((__HANDLE__)->Instance->SR) = (__FLAG__))
N/**
N  * @}
N  */
N
N/* Include DAC HAL Extension module */
N#include "stm32f7xx_hal_dac_ex.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_dac_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_dac.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of DAC HAL Extension module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_DAC_EX_H
N#define __STM32F7xx_HAL_DAC_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup DACEx
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup DACEx_Exported_Constants DAC Exported Constants
N  * @{
N  */
N   
N/** @defgroup DACEx_lfsrunmask_triangleamplitude DAC LFS Run Mask Triangle Amplitude
N  * @{
N  */
N#define DAC_LFSRUNMASK_BIT0                ((uint32_t)0x00000000U) /*!< Unmask DAC channel LFSR bit0 for noise wave generation */
N#define DAC_LFSRUNMASK_BITS1_0             ((uint32_t)DAC_CR_MAMP1_0) /*!< Unmask DAC channel LFSR bit[1:0] for noise wave generation */
N#define DAC_LFSRUNMASK_BITS2_0             ((uint32_t)DAC_CR_MAMP1_1) /*!< Unmask DAC channel LFSR bit[2:0] for noise wave generation */
N#define DAC_LFSRUNMASK_BITS3_0             ((uint32_t)DAC_CR_MAMP1_1 | DAC_CR_MAMP1_0)/*!< Unmask DAC channel LFSR bit[3:0] for noise wave generation */
N#define DAC_LFSRUNMASK_BITS4_0             ((uint32_t)DAC_CR_MAMP1_2) /*!< Unmask DAC channel LFSR bit[4:0] for noise wave generation */
N#define DAC_LFSRUNMASK_BITS5_0             ((uint32_t)DAC_CR_MAMP1_2 | DAC_CR_MAMP1_0) /*!< Unmask DAC channel LFSR bit[5:0] for noise wave generation */
N#define DAC_LFSRUNMASK_BITS6_0             ((uint32_t)DAC_CR_MAMP1_2 | DAC_CR_MAMP1_1) /*!< Unmask DAC channel LFSR bit[6:0] for noise wave generation */
N#define DAC_LFSRUNMASK_BITS7_0             ((uint32_t)DAC_CR_MAMP1_2 | DAC_CR_MAMP1_1 | DAC_CR_MAMP1_0) /*!< Unmask DAC channel LFSR bit[7:0] for noise wave generation */
N#define DAC_LFSRUNMASK_BITS8_0             ((uint32_t)DAC_CR_MAMP1_3) /*!< Unmask DAC channel LFSR bit[8:0] for noise wave generation */
N#define DAC_LFSRUNMASK_BITS9_0             ((uint32_t)DAC_CR_MAMP1_3 | DAC_CR_MAMP1_0) /*!< Unmask DAC channel LFSR bit[9:0] for noise wave generation */
N#define DAC_LFSRUNMASK_BITS10_0            ((uint32_t)DAC_CR_MAMP1_3 | DAC_CR_MAMP1_1) /*!< Unmask DAC channel LFSR bit[10:0] for noise wave generation */
N#define DAC_LFSRUNMASK_BITS11_0            ((uint32_t)DAC_CR_MAMP1_3 | DAC_CR_MAMP1_1 | DAC_CR_MAMP1_0) /*!< Unmask DAC channel LFSR bit[11:0] for noise wave generation */
N#define DAC_TRIANGLEAMPLITUDE_1            ((uint32_t)0x00000000U) /*!< Select max triangle amplitude of 1 */
N#define DAC_TRIANGLEAMPLITUDE_3            ((uint32_t)DAC_CR_MAMP1_0) /*!< Select max triangle amplitude of 3 */
N#define DAC_TRIANGLEAMPLITUDE_7            ((uint32_t)DAC_CR_MAMP1_1) /*!< Select max triangle amplitude of 7 */
N#define DAC_TRIANGLEAMPLITUDE_15           ((uint32_t)DAC_CR_MAMP1_1 | DAC_CR_MAMP1_0) /*!< Select max triangle amplitude of 15 */
N#define DAC_TRIANGLEAMPLITUDE_31           ((uint32_t)DAC_CR_MAMP1_2) /*!< Select max triangle amplitude of 31 */
N#define DAC_TRIANGLEAMPLITUDE_63           ((uint32_t)DAC_CR_MAMP1_2 | DAC_CR_MAMP1_0) /*!< Select max triangle amplitude of 63 */
N#define DAC_TRIANGLEAMPLITUDE_127          ((uint32_t)DAC_CR_MAMP1_2 | DAC_CR_MAMP1_1) /*!< Select max triangle amplitude of 127 */
N#define DAC_TRIANGLEAMPLITUDE_255          ((uint32_t)DAC_CR_MAMP1_2 | DAC_CR_MAMP1_1 | DAC_CR_MAMP1_0) /*!< Select max triangle amplitude of 255 */
N#define DAC_TRIANGLEAMPLITUDE_511          ((uint32_t)DAC_CR_MAMP1_3) /*!< Select max triangle amplitude of 511 */
N#define DAC_TRIANGLEAMPLITUDE_1023         ((uint32_t)DAC_CR_MAMP1_3 | DAC_CR_MAMP1_0) /*!< Select max triangle amplitude of 1023 */
N#define DAC_TRIANGLEAMPLITUDE_2047         ((uint32_t)DAC_CR_MAMP1_3 | DAC_CR_MAMP1_1) /*!< Select max triangle amplitude of 2047 */
N#define DAC_TRIANGLEAMPLITUDE_4095         ((uint32_t)DAC_CR_MAMP1_3 | DAC_CR_MAMP1_1 | DAC_CR_MAMP1_0) /*!< Select max triangle amplitude of 4095 */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup DACEx_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup DACEx_Exported_Functions_Group1
N  * @{
N  */
N/* Extension features functions ***********************************************/
Nuint32_t HAL_DACEx_DualGetValue(DAC_HandleTypeDef* hdac);
NHAL_StatusTypeDef HAL_DACEx_TriangleWaveGenerate(DAC_HandleTypeDef* hdac, uint32_t Channel, uint32_t Amplitude);
NHAL_StatusTypeDef HAL_DACEx_NoiseWaveGenerate(DAC_HandleTypeDef* hdac, uint32_t Channel, uint32_t Amplitude);
NHAL_StatusTypeDef HAL_DACEx_DualSetValue(DAC_HandleTypeDef* hdac, uint32_t Alignment, uint32_t Data1, uint32_t Data2);
N
Nvoid HAL_DACEx_ConvCpltCallbackCh2(DAC_HandleTypeDef* hdac);
Nvoid HAL_DACEx_ConvHalfCpltCallbackCh2(DAC_HandleTypeDef* hdac);
Nvoid HAL_DACEx_ErrorCallbackCh2(DAC_HandleTypeDef* hdac);
Nvoid HAL_DACEx_DMAUnderrunCallbackCh2(DAC_HandleTypeDef* hdac);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup DACEx_Private_Constants DAC Private Constants
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup DACEx_Private_Macros DAC Private Macros
N  * @{
N  */
N#define IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(VALUE) (((VALUE) == DAC_LFSRUNMASK_BIT0) || \
N                                                      ((VALUE) == DAC_LFSRUNMASK_BITS1_0) || \
N                                                      ((VALUE) == DAC_LFSRUNMASK_BITS2_0) || \
N                                                      ((VALUE) == DAC_LFSRUNMASK_BITS3_0) || \
N                                                      ((VALUE) == DAC_LFSRUNMASK_BITS4_0) || \
N                                                      ((VALUE) == DAC_LFSRUNMASK_BITS5_0) || \
N                                                      ((VALUE) == DAC_LFSRUNMASK_BITS6_0) || \
N                                                      ((VALUE) == DAC_LFSRUNMASK_BITS7_0) || \
N                                                      ((VALUE) == DAC_LFSRUNMASK_BITS8_0) || \
N                                                      ((VALUE) == DAC_LFSRUNMASK_BITS9_0) || \
N                                                      ((VALUE) == DAC_LFSRUNMASK_BITS10_0) || \
N                                                      ((VALUE) == DAC_LFSRUNMASK_BITS11_0) || \
N                                                      ((VALUE) == DAC_TRIANGLEAMPLITUDE_1) || \
N                                                      ((VALUE) == DAC_TRIANGLEAMPLITUDE_3) || \
N                                                      ((VALUE) == DAC_TRIANGLEAMPLITUDE_7) || \
N                                                      ((VALUE) == DAC_TRIANGLEAMPLITUDE_15) || \
N                                                      ((VALUE) == DAC_TRIANGLEAMPLITUDE_31) || \
N                                                      ((VALUE) == DAC_TRIANGLEAMPLITUDE_63) || \
N                                                      ((VALUE) == DAC_TRIANGLEAMPLITUDE_127) || \
N                                                      ((VALUE) == DAC_TRIANGLEAMPLITUDE_255) || \
N                                                      ((VALUE) == DAC_TRIANGLEAMPLITUDE_511) || \
N                                                      ((VALUE) == DAC_TRIANGLEAMPLITUDE_1023) || \
N                                                      ((VALUE) == DAC_TRIANGLEAMPLITUDE_2047) || \
N                                                      ((VALUE) == DAC_TRIANGLEAMPLITUDE_4095))
X#define IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(VALUE) (((VALUE) == DAC_LFSRUNMASK_BIT0) ||                                                       ((VALUE) == DAC_LFSRUNMASK_BITS1_0) ||                                                       ((VALUE) == DAC_LFSRUNMASK_BITS2_0) ||                                                       ((VALUE) == DAC_LFSRUNMASK_BITS3_0) ||                                                       ((VALUE) == DAC_LFSRUNMASK_BITS4_0) ||                                                       ((VALUE) == DAC_LFSRUNMASK_BITS5_0) ||                                                       ((VALUE) == DAC_LFSRUNMASK_BITS6_0) ||                                                       ((VALUE) == DAC_LFSRUNMASK_BITS7_0) ||                                                       ((VALUE) == DAC_LFSRUNMASK_BITS8_0) ||                                                       ((VALUE) == DAC_LFSRUNMASK_BITS9_0) ||                                                       ((VALUE) == DAC_LFSRUNMASK_BITS10_0) ||                                                       ((VALUE) == DAC_LFSRUNMASK_BITS11_0) ||                                                       ((VALUE) == DAC_TRIANGLEAMPLITUDE_1) ||                                                       ((VALUE) == DAC_TRIANGLEAMPLITUDE_3) ||                                                       ((VALUE) == DAC_TRIANGLEAMPLITUDE_7) ||                                                       ((VALUE) == DAC_TRIANGLEAMPLITUDE_15) ||                                                       ((VALUE) == DAC_TRIANGLEAMPLITUDE_31) ||                                                       ((VALUE) == DAC_TRIANGLEAMPLITUDE_63) ||                                                       ((VALUE) == DAC_TRIANGLEAMPLITUDE_127) ||                                                       ((VALUE) == DAC_TRIANGLEAMPLITUDE_255) ||                                                       ((VALUE) == DAC_TRIANGLEAMPLITUDE_511) ||                                                       ((VALUE) == DAC_TRIANGLEAMPLITUDE_1023) ||                                                       ((VALUE) == DAC_TRIANGLEAMPLITUDE_2047) ||                                                       ((VALUE) == DAC_TRIANGLEAMPLITUDE_4095))
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup DACEx_Private_Functions DAC Private Functions
N  * @{
N  */
Nvoid DAC_DMAConvCpltCh2(DMA_HandleTypeDef *hdma);
Nvoid DAC_DMAErrorCh2(DMA_HandleTypeDef *hdma);
Nvoid DAC_DMAHalfConvCpltCh2(DMA_HandleTypeDef *hdma); 
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F7xx_HAL_DAC_EX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 270 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_dac.h" 2
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup DAC_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup DAC_Exported_Functions_Group1
N  * @{
N  */
N/* Initialization/de-initialization functions *********************************/
NHAL_StatusTypeDef HAL_DAC_Init(DAC_HandleTypeDef* hdac);
NHAL_StatusTypeDef HAL_DAC_DeInit(DAC_HandleTypeDef* hdac);
Nvoid HAL_DAC_MspInit(DAC_HandleTypeDef* hdac);
Nvoid HAL_DAC_MspDeInit(DAC_HandleTypeDef* hdac);
N/**
N  * @}
N  */
N
N/** @addtogroup DAC_Exported_Functions_Group2
N  * @{
N  */
N/* I/O operation functions ****************************************************/
NHAL_StatusTypeDef HAL_DAC_Start(DAC_HandleTypeDef* hdac, uint32_t Channel);
NHAL_StatusTypeDef HAL_DAC_Stop(DAC_HandleTypeDef* hdac, uint32_t Channel);
NHAL_StatusTypeDef HAL_DAC_Start_DMA(DAC_HandleTypeDef* hdac, uint32_t Channel, uint32_t* pData, uint32_t Length, uint32_t Alignment);
NHAL_StatusTypeDef HAL_DAC_Stop_DMA(DAC_HandleTypeDef* hdac, uint32_t Channel);
Nuint32_t HAL_DAC_GetValue(DAC_HandleTypeDef* hdac, uint32_t Channel);
N/**
N  * @}
N  */
N
N/** @addtogroup DAC_Exported_Functions_Group3
N  * @{
N  */
N/* Peripheral Control functions ***********************************************/
NHAL_StatusTypeDef HAL_DAC_ConfigChannel(DAC_HandleTypeDef* hdac, DAC_ChannelConfTypeDef* sConfig, uint32_t Channel);
NHAL_StatusTypeDef HAL_DAC_SetValue(DAC_HandleTypeDef* hdac, uint32_t Channel, uint32_t Alignment, uint32_t Data);
N/**
N  * @}
N  */
N
N/** @addtogroup DAC_Exported_Functions_Group4
N  * @{
N  */
N/* Peripheral State functions *************************************************/
NHAL_DAC_StateTypeDef HAL_DAC_GetState(DAC_HandleTypeDef* hdac);
Nvoid HAL_DAC_IRQHandler(DAC_HandleTypeDef* hdac);
Nuint32_t HAL_DAC_GetError(DAC_HandleTypeDef *hdac);
N
Nvoid HAL_DAC_ConvCpltCallbackCh1(DAC_HandleTypeDef* hdac);
Nvoid HAL_DAC_ConvHalfCpltCallbackCh1(DAC_HandleTypeDef* hdac);
Nvoid HAL_DAC_ErrorCallbackCh1(DAC_HandleTypeDef *hdac);
Nvoid HAL_DAC_DMAUnderrunCallbackCh1(DAC_HandleTypeDef *hdac);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup DAC_Private_Constants DAC Private Constants
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup DAC_Private_Macros DAC Private Macros
N  * @{
N  */
N#define IS_DAC_DATA(DATA) ((DATA) <= 0xFFF0U)
N#define IS_DAC_ALIGN(ALIGN) (((ALIGN) == DAC_ALIGN_12B_R) || \
N                             ((ALIGN) == DAC_ALIGN_12B_L) || \
N                             ((ALIGN) == DAC_ALIGN_8B_R))
X#define IS_DAC_ALIGN(ALIGN) (((ALIGN) == DAC_ALIGN_12B_R) ||                              ((ALIGN) == DAC_ALIGN_12B_L) ||                              ((ALIGN) == DAC_ALIGN_8B_R))
N#define IS_DAC_CHANNEL(CHANNEL) (((CHANNEL) == DAC_CHANNEL_1) || \
N                                 ((CHANNEL) == DAC_CHANNEL_2))
X#define IS_DAC_CHANNEL(CHANNEL) (((CHANNEL) == DAC_CHANNEL_1) ||                                  ((CHANNEL) == DAC_CHANNEL_2))
N#define IS_DAC_OUTPUT_BUFFER_STATE(STATE) (((STATE) == DAC_OUTPUTBUFFER_ENABLE) || \
N                                           ((STATE) == DAC_OUTPUTBUFFER_DISABLE))
X#define IS_DAC_OUTPUT_BUFFER_STATE(STATE) (((STATE) == DAC_OUTPUTBUFFER_ENABLE) ||                                            ((STATE) == DAC_OUTPUTBUFFER_DISABLE))
N
N#define IS_DAC_TRIGGER(TRIGGER) (((TRIGGER) == DAC_TRIGGER_NONE) || \
N                                 ((TRIGGER) == DAC_TRIGGER_T2_TRGO) || \
N                                 ((TRIGGER) == DAC_TRIGGER_T8_TRGO) || \
N                                 ((TRIGGER) == DAC_TRIGGER_T7_TRGO) || \
N                                 ((TRIGGER) == DAC_TRIGGER_T5_TRGO) || \
N                                 ((TRIGGER) == DAC_TRIGGER_T6_TRGO) || \
N                                 ((TRIGGER) == DAC_TRIGGER_T4_TRGO) || \
N                                 ((TRIGGER) == DAC_TRIGGER_EXT_IT9) || \
N                                 ((TRIGGER) == DAC_TRIGGER_SOFTWARE))
X#define IS_DAC_TRIGGER(TRIGGER) (((TRIGGER) == DAC_TRIGGER_NONE) ||                                  ((TRIGGER) == DAC_TRIGGER_T2_TRGO) ||                                  ((TRIGGER) == DAC_TRIGGER_T8_TRGO) ||                                  ((TRIGGER) == DAC_TRIGGER_T7_TRGO) ||                                  ((TRIGGER) == DAC_TRIGGER_T5_TRGO) ||                                  ((TRIGGER) == DAC_TRIGGER_T6_TRGO) ||                                  ((TRIGGER) == DAC_TRIGGER_T4_TRGO) ||                                  ((TRIGGER) == DAC_TRIGGER_EXT_IT9) ||                                  ((TRIGGER) == DAC_TRIGGER_SOFTWARE))
N
N/** @brief Set DHR12R1 alignment
N  * @param  __ALIGNMENT__: specifies the DAC alignment
N  * @retval None
N  */
N#define DAC_DHR12R1_ALIGNMENT(__ALIGNMENT__) (((uint32_t)0x00000008U) + (__ALIGNMENT__))
N
N/** @brief  Set DHR12R2 alignment
N  * @param  __ALIGNMENT__: specifies the DAC alignment
N  * @retval None
N  */
N#define DAC_DHR12R2_ALIGNMENT(__ALIGNMENT__) (((uint32_t)0x00000014U) + (__ALIGNMENT__))
N
N/** @brief  Set DHR12RD alignment
N  * @param  __ALIGNMENT__: specifies the DAC alignment
N  * @retval None
N  */
N#define DAC_DHR12RD_ALIGNMENT(__ALIGNMENT__) (((uint32_t)0x00000020U) + (__ALIGNMENT__))
N
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup DAC_Private_Functions DAC Private Functions
N  * @{
N  */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F7xx_HAL_DAC_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 287 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_DAC_MODULE_ENABLED */
N
N#ifdef HAL_DCMI_MODULE_ENABLED
N  #include "stm32f7xx_hal_dcmi.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_dcmi.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_dcmi.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of DCMI HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_DCMI_H
N#define __STM32F7xx_HAL_DCMI_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N 
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup DCMI DCMI
N  * @brief DCMI HAL module driver
N  * @{
N  */  
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup DCMI_Exported_Types DCMI Exported Types
N  * @{
N  */
N/** 
N  * @brief  HAL DCMI State structures definition
N  */ 
Ntypedef enum
N{
N  HAL_DCMI_STATE_RESET             = 0x00U,  /*!< DCMI not yet initialized or disabled  */
N  HAL_DCMI_STATE_READY             = 0x01U,  /*!< DCMI initialized and ready for use    */
N  HAL_DCMI_STATE_BUSY              = 0x02U,  /*!< DCMI internal processing is ongoing   */
N  HAL_DCMI_STATE_TIMEOUT           = 0x03U,  /*!< DCMI timeout state                    */
N  HAL_DCMI_STATE_ERROR             = 0x04U,  /*!< DCMI error state                      */
N  HAL_DCMI_STATE_SUSPENDED         = 0x05U   /*!< DCMI suspend state                    */    
N}HAL_DCMI_StateTypeDef;
N
N/** 
N  * @brief   DCMIEx Embedded Synchronisation CODE Init structure definition
N  */ 
Ntypedef struct
N{
N  uint8_t FrameStartCode; /*!< Specifies the code of the frame start delimiter. */
N  uint8_t LineStartCode;  /*!< Specifies the code of the line start delimiter.  */
N  uint8_t LineEndCode;    /*!< Specifies the code of the line end delimiter.    */
N  uint8_t FrameEndCode;   /*!< Specifies the code of the frame end delimiter.   */
N}DCMI_CodesInitTypeDef;
N
N/** 
N  * @brief   DCMI Init structure definition
N  */  
Ntypedef struct
N{
N  uint32_t  SynchroMode;                /*!< Specifies the Synchronization Mode: Hardware or Embedded.
N                                             This parameter can be a value of @ref DCMI_Synchronization_Mode */
N
N  uint32_t  PCKPolarity;                /*!< Specifies the Pixel clock polarity: Falling or Rising.
N                                             This parameter can be a value of @ref DCMI_PIXCK_Polarity       */
N
N  uint32_t  VSPolarity;                 /*!< Specifies the Vertical synchronization polarity: High or Low.
N                                             This parameter can be a value of @ref DCMI_VSYNC_Polarity       */
N
N  uint32_t  HSPolarity;                 /*!< Specifies the Horizontal synchronization polarity: High or Low.
N                                             This parameter can be a value of @ref DCMI_HSYNC_Polarity       */
N
N  uint32_t  CaptureRate;                /*!< Specifies the frequency of frame capture: All, 1/2 or 1/4.
N                                             This parameter can be a value of @ref DCMI_Capture_Rate         */
N
N  uint32_t  ExtendedDataMode;           /*!< Specifies the data width: 8-bit, 10-bit, 12-bit or 14-bit.
N                                             This parameter can be a value of @ref DCMI_Extended_Data_Mode   */
N
N  DCMI_CodesInitTypeDef SyncroCode;     /*!< Specifies the code of the line/frame start delimiter and the
N                                             line/frame end delimiter */
N
N  uint32_t JPEGMode;                    /*!< Enable or Disable the JPEG mode.                                
N                                             This parameter can be a value of @ref DCMI_MODE_JPEG            */
N
N  uint32_t ByteSelectMode;              /*!< Specifies the data to be captured by the interface 
N                                            This parameter can be a value of @ref DCMI_Byte_Select_Mode      */
N                                            
N  uint32_t ByteSelectStart;             /*!< Specifies if the data to be captured by the interface is even or odd
N                                            This parameter can be a value of @ref DCMI_Byte_Select_Start     */
N
N  uint32_t LineSelectMode;              /*!< Specifies the line of data to be captured by the interface 
N                                            This parameter can be a value of @ref DCMI_Line_Select_Mode      */
N                                            
N  uint32_t LineSelectStart;             /*!< Specifies if the line of data to be captured by the interface is even or odd
N                                            This parameter can be a value of @ref DCMI_Line_Select_Start     */
N}DCMI_InitTypeDef;
N
N/** 
N  * @brief  DCMI handle Structure definition
N  */
Ntypedef struct
N{
N  DCMI_TypeDef                  *Instance;           /*!< DCMI Register base address   */
N
N  DCMI_InitTypeDef              Init;                /*!< DCMI parameters              */
N
N  HAL_LockTypeDef               Lock;                /*!< DCMI locking object          */
N
N  __IO HAL_DCMI_StateTypeDef    State;               /*!< DCMI state                   */
X  volatile HAL_DCMI_StateTypeDef    State;                
N
N  __IO uint32_t                 XferCount;           /*!< DMA transfer counter         */
X  volatile uint32_t                 XferCount;            
N
N  __IO uint32_t                 XferSize;            /*!< DMA transfer size            */
X  volatile uint32_t                 XferSize;             
N
N  uint32_t                      XferTransferNumber;  /*!< DMA transfer number          */
N
N  uint32_t                      pBuffPtr;            /*!< Pointer to DMA output buffer */
N
N  DMA_HandleTypeDef             *DMA_Handle;         /*!< Pointer to the DMA handler   */
N
N  __IO uint32_t                 ErrorCode;           /*!< DCMI Error code              */
X  volatile uint32_t                 ErrorCode;            
N
N}DCMI_HandleTypeDef;
N/**
N  * @}
N  */
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup DCMI_Exported_Constants DCMI Exported Constants
N  * @{
N  */
N
N/** @defgroup DCMI_Error_Code DCMI Error Code
N  * @{
N  */
N#define HAL_DCMI_ERROR_NONE      ((uint32_t)0x00000000U)    /*!< No error              */
N#define HAL_DCMI_ERROR_OVR       ((uint32_t)0x00000001U)    /*!< Overrun error         */
N#define HAL_DCMI_ERROR_SYNC      ((uint32_t)0x00000002U)    /*!< Synchronization error */
N#define HAL_DCMI_ERROR_TIMEOUT   ((uint32_t)0x00000020U)    /*!< Timeout error         */
N#define HAL_DCMI_ERROR_DMA       ((uint32_t)0x00000040U)    /*!< DMA error             */
N/**
N  * @}
N  */
N
N/** @defgroup DCMI_Capture_Mode DCMI Capture Mode
N  * @{
N  */ 
N#define DCMI_MODE_CONTINUOUS           ((uint32_t)0x00000000U)  /*!< The received data are transferred continuously 
N                                                                    into the destination memory through the DMA             */
N#define DCMI_MODE_SNAPSHOT             ((uint32_t)DCMI_CR_CM)  /*!< Once activated, the interface waits for the start of 
N                                                                    frame and then transfers a single frame through the DMA */
N/**
N  * @}
N  */
N
N/** @defgroup DCMI_Synchronization_Mode DCMI Synchronization Mode
N  * @{
N  */ 
N#define DCMI_SYNCHRO_HARDWARE        ((uint32_t)0x00000000U)   /*!< Hardware synchronization data capture (frame/line start/stop)
N                                                                   is synchronized with the HSYNC/VSYNC signals                  */
N#define DCMI_SYNCHRO_EMBEDDED        ((uint32_t)DCMI_CR_ESS)  /*!< Embedded synchronization data capture is synchronized with 
N                                                                   synchronization codes embedded in the data flow               */
N
N/**
N  * @}
N  */
N
N/** @defgroup DCMI_PIXCK_Polarity DCMI PIXCK Polarity
N  * @{
N  */
N#define DCMI_PCKPOLARITY_FALLING    ((uint32_t)0x00000000U)      /*!< Pixel clock active on Falling edge */
N#define DCMI_PCKPOLARITY_RISING     ((uint32_t)DCMI_CR_PCKPOL)  /*!< Pixel clock active on Rising edge  */
N
N/**
N  * @}
N  */
N
N/** @defgroup DCMI_VSYNC_Polarity DCMI VSYNC Polarity
N  * @{
N  */
N#define DCMI_VSPOLARITY_LOW     ((uint32_t)0x00000000U)     /*!< Vertical synchronization active Low  */
N#define DCMI_VSPOLARITY_HIGH    ((uint32_t)DCMI_CR_VSPOL)  /*!< Vertical synchronization active High */
N
N/**
N  * @}
N  */
N
N/** @defgroup DCMI_HSYNC_Polarity DCMI HSYNC Polarity
N  * @{
N  */ 
N#define DCMI_HSPOLARITY_LOW     ((uint32_t)0x00000000U)     /*!< Horizontal synchronization active Low  */
N#define DCMI_HSPOLARITY_HIGH    ((uint32_t)DCMI_CR_HSPOL)  /*!< Horizontal synchronization active High */
N
N/**
N  * @}
N  */
N
N/** @defgroup DCMI_MODE_JPEG DCMI MODE JPEG
N  * @{
N  */
N#define DCMI_JPEG_DISABLE   ((uint32_t)0x00000000U)    /*!< Mode JPEG Disabled  */
N#define DCMI_JPEG_ENABLE    ((uint32_t)DCMI_CR_JPEG)  /*!< Mode JPEG Enabled   */
N
N/**
N  * @}
N  */
N
N/** @defgroup DCMI_Capture_Rate DCMI Capture Rate
N  * @{
N  */
N#define DCMI_CR_ALL_FRAME            ((uint32_t)0x00000000U)      /*!< All frames are captured        */
N#define DCMI_CR_ALTERNATE_2_FRAME    ((uint32_t)DCMI_CR_FCRC_0)  /*!< Every alternate frame captured */
N#define DCMI_CR_ALTERNATE_4_FRAME    ((uint32_t)DCMI_CR_FCRC_1)  /*!< One frame in 4 frames captured */
N
N/**
N  * @}
N  */
N
N/** @defgroup DCMI_Extended_Data_Mode DCMI Extended Data Mode
N  * @{
N  */
N#define DCMI_EXTEND_DATA_8B     ((uint32_t)0x00000000U)                       /*!< Interface captures 8-bit data on every pixel clock  */
N#define DCMI_EXTEND_DATA_10B    ((uint32_t)DCMI_CR_EDM_0)                    /*!< Interface captures 10-bit data on every pixel clock */
N#define DCMI_EXTEND_DATA_12B    ((uint32_t)DCMI_CR_EDM_1)                    /*!< Interface captures 12-bit data on every pixel clock */
N#define DCMI_EXTEND_DATA_14B    ((uint32_t)(DCMI_CR_EDM_0 | DCMI_CR_EDM_1))  /*!< Interface captures 14-bit data on every pixel clock */
N
N/**
N  * @}
N  */
N
N/** @defgroup DCMI_Window_Coordinate DCMI Window Coordinate 
N  * @{
N  */
N#define DCMI_WINDOW_COORDINATE    ((uint32_t)0x3FFFU)  /*!< Window coordinate */
N
N/**
N  * @}
N  */
N
N/** @defgroup DCMI_Window_Height DCMI Window Height
N  * @{
N  */ 
N#define DCMI_WINDOW_HEIGHT    ((uint32_t)0x1FFFU)  /*!< Window Height */
N
N/**
N  * @}
N  */
N
N/** @defgroup DCMI_interrupt_sources  DCMI interrupt sources
N  * @{
N  */
N#define DCMI_IT_FRAME    ((uint32_t)DCMI_IER_FRAME_IE)    /*!< Capture complete interrupt      */
N#define DCMI_IT_OVR      ((uint32_t)DCMI_IER_OVR_IE)      /*!< Overrun interrupt               */
N#define DCMI_IT_ERR      ((uint32_t)DCMI_IER_ERR_IE)      /*!< Synchronization error interrupt */
N#define DCMI_IT_VSYNC    ((uint32_t)DCMI_IER_VSYNC_IE)    /*!< VSYNC interrupt                 */
N#define DCMI_IT_LINE     ((uint32_t)DCMI_IER_LINE_IE)     /*!< Line interrupt                  */
N/**
N  * @}
N  */
N
N/** @defgroup DCMI_Flags DCMI Flags
N  * @{
N  */
N
N/** 
N  * @brief   DCMI SR register
N  */ 
N#define DCMI_FLAG_HSYNC     ((uint32_t)DCMI_SR_INDEX|DCMI_SR_HSYNC) /*!< HSYNC pin state (active line / synchronization between lines)   */
N#define DCMI_FLAG_VSYNC     ((uint32_t)DCMI_SR_INDEX|DCMI_SR_VSYNC) /*!< VSYNC pin state (active frame / synchronization between frames) */
N#define DCMI_FLAG_FNE       ((uint32_t)DCMI_SR_INDEX|DCMI_SR_FNE)   /*!< FIFO not empty flag                                                 */
N/** 
N  * @brief   DCMI RIS register  
N  */ 
N#define DCMI_FLAG_FRAMERI    ((uint32_t)DCMI_RIS_FRAME_RIS)  /*!< Frame capture complete interrupt flag */ 
N#define DCMI_FLAG_OVRRI      ((uint32_t)DCMI_RIS_OVR_RIS)    /*!< Overrun interrupt flag                */ 
N#define DCMI_FLAG_ERRRI      ((uint32_t)DCMI_RIS_ERR_RIS)    /*!< Synchronization error interrupt flag  */ 
N#define DCMI_FLAG_VSYNCRI    ((uint32_t)DCMI_RIS_VSYNC_RIS)  /*!< VSYNC interrupt flag                  */ 
N#define DCMI_FLAG_LINERI     ((uint32_t)DCMI_RIS_LINE_RIS)   /*!< Line interrupt flag                   */ 
N/** 
N  * @brief   DCMI MIS register  
N  */ 
N#define DCMI_FLAG_FRAMEMI    ((uint32_t)DCMI_MIS_INDEX|DCMI_MIS_FRAME_MIS)  /*!< DCMI Frame capture complete masked interrupt status */      
N#define DCMI_FLAG_OVRMI      ((uint32_t)DCMI_MIS_INDEX|DCMI_MIS_OVR_MIS  )  /*!< DCMI Overrun masked interrupt status                */               
N#define DCMI_FLAG_ERRMI      ((uint32_t)DCMI_MIS_INDEX|DCMI_MIS_ERR_MIS  )  /*!< DCMI Synchronization error masked interrupt status  */ 
N#define DCMI_FLAG_VSYNCMI    ((uint32_t)DCMI_MIS_INDEX|DCMI_MIS_VSYNC_MIS)  /*!< DCMI VSYNC masked interrupt status                  */                 
N#define DCMI_FLAG_LINEMI     ((uint32_t)DCMI_MIS_INDEX|DCMI_MIS_LINE_MIS )  /*!< DCMI Line masked interrupt status                   */                  
N/**
N  * @}
N  */ 
N
N/** @defgroup DCMI_Byte_Select_Mode DCMI Byte Select Mode
N  * @{
N  */
N#define DCMI_BSM_ALL                 ((uint32_t)0x00000000U) /*!< Interface captures all received data */
N#define DCMI_BSM_OTHER               ((uint32_t)DCMI_CR_BSM_0) /*!< Interface captures every other byte from the received data */
N#define DCMI_BSM_ALTERNATE_4         ((uint32_t)DCMI_CR_BSM_1) /*!< Interface captures one byte out of four */
N#define DCMI_BSM_ALTERNATE_2         ((uint32_t)(DCMI_CR_BSM_0 | DCMI_CR_BSM_1)) /*!< Interface captures two bytes out of four */
N
N/**
N  * @}
N  */
N
N/** @defgroup DCMI_Byte_Select_Start DCMI Byte Select Start
N  * @{
N  */ 
N#define DCMI_OEBS_ODD               ((uint32_t)0x00000000U) /*!< Interface captures first data from the frame/line start, second one being dropped */
N#define DCMI_OEBS_EVEN              ((uint32_t)DCMI_CR_OEBS) /*!< Interface captures second data from the frame/line start, first one being dropped */
N
N/**
N  * @}
N  */
N
N/** @defgroup DCMI_Line_Select_Mode DCMI Line Select Mode
N  * @{
N  */
N#define DCMI_LSM_ALL                 ((uint32_t)0x00000000U) /*!< Interface captures all received lines */
N#define DCMI_LSM_ALTERNATE_2         ((uint32_t)DCMI_CR_LSM) /*!< Interface captures one line out of two */
N
N/**
N  * @}
N  */
N
N/** @defgroup DCMI_Line_Select_Start DCMI Line Select Start
N  * @{
N  */ 
N#define DCMI_OELS_ODD               ((uint32_t)0x00000000U) /*!< Interface captures first line from the frame start, second one being dropped */
N#define DCMI_OELS_EVEN              ((uint32_t)DCMI_CR_OELS) /*!< Interface captures second line from the frame start, first one being dropped */
N
N/**
N  * @}
N  */
N    
N/**
N  * @}
N  */
N 
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup DCMI_Exported_Macros DCMI Exported Macros
N  * @{
N  */
N  
N/** @brief Reset DCMI handle state
N  * @param  __HANDLE__: specifies the DCMI handle.
N  * @retval None
N  */
N#define __HAL_DCMI_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_DCMI_STATE_RESET)
N
N/**
N  * @brief  Enable the DCMI.
N  * @param  __HANDLE__: DCMI handle
N  * @retval None
N  */
N#define __HAL_DCMI_ENABLE(__HANDLE__)    ((__HANDLE__)->Instance->CR |= DCMI_CR_ENABLE)
N
N/**
N  * @brief  Disable the DCMI.
N  * @param  __HANDLE__: DCMI handle
N  * @retval None
N  */
N#define __HAL_DCMI_DISABLE(__HANDLE__)   ((__HANDLE__)->Instance->CR &= ~(DCMI_CR_ENABLE))
N
N/* Interrupt & Flag management */
N/**
N  * @brief  Get the DCMI pending flag.
N  * @param  __HANDLE__: DCMI handle
N  * @param  __FLAG__: Get the specified flag.
N  *         This parameter can be one of the following values (no combination allowed)
N  *            @arg DCMI_FLAG_HSYNC: HSYNC pin state (active line / synchronization between lines)   
N  *            @arg DCMI_FLAG_VSYNC: VSYNC pin state (active frame / synchronization between frames) 
N  *            @arg DCMI_FLAG_FNE: FIFO empty flag                                                  
N  *            @arg DCMI_FLAG_FRAMERI: Frame capture complete flag mask
N  *            @arg DCMI_FLAG_OVRRI: Overrun flag mask
N  *            @arg DCMI_FLAG_ERRRI: Synchronization error flag mask
N  *            @arg DCMI_FLAG_VSYNCRI: VSYNC flag mask
N  *            @arg DCMI_FLAG_LINERI: Line flag mask
N  *            @arg DCMI_FLAG_FRAMEMI: DCMI Capture complete masked interrupt status      
N  *            @arg DCMI_FLAG_OVRMI: DCMI Overrun masked interrupt status               
N  *            @arg DCMI_FLAG_ERRMI: DCMI Synchronization error masked interrupt status 
N  *            @arg DCMI_FLAG_VSYNCMI: DCMI VSYNC masked interrupt status                 
N  *            @arg DCMI_FLAG_LINEMI: DCMI Line masked interrupt status                  
N  * @retval The state of FLAG.
N  */
N#define __HAL_DCMI_GET_FLAG(__HANDLE__, __FLAG__)\
N((((__FLAG__) & (DCMI_SR_INDEX|DCMI_MIS_INDEX)) == 0x0)? ((__HANDLE__)->Instance->RIS & (__FLAG__)) :\
N (((__FLAG__) & DCMI_SR_INDEX) == 0x0)? ((__HANDLE__)->Instance->MIS & (__FLAG__)) : ((__HANDLE__)->Instance->SR & (__FLAG__)))
X#define __HAL_DCMI_GET_FLAG(__HANDLE__, __FLAG__)((((__FLAG__) & (DCMI_SR_INDEX|DCMI_MIS_INDEX)) == 0x0)? ((__HANDLE__)->Instance->RIS & (__FLAG__)) : (((__FLAG__) & DCMI_SR_INDEX) == 0x0)? ((__HANDLE__)->Instance->MIS & (__FLAG__)) : ((__HANDLE__)->Instance->SR & (__FLAG__)))
N
N/**
N  * @brief  Clear the DCMI pending flags.
N  * @param  __HANDLE__: DCMI handle
N  * @param  __FLAG__: specifies the flag to clear.
N  *         This parameter can be any combination of the following values:
N  *            @arg DCMI_FLAG_FRAMERI: Frame capture complete flag mask
N  *            @arg DCMI_FLAG_OVFRI: Overflow flag mask
N  *            @arg DCMI_FLAG_ERRRI: Synchronization error flag mask
N  *            @arg DCMI_FLAG_VSYNCRI: VSYNC flag mask
N  *            @arg DCMI_FLAG_LINERI: Line flag mask
N  * @retval None
N  */
N#define __HAL_DCMI_CLEAR_FLAG(__HANDLE__, __FLAG__) ((__HANDLE__)->Instance->ICR = (__FLAG__))
N
N/**
N  * @brief  Enable the specified DCMI interrupts.
N  * @param  __HANDLE__:    DCMI handle
N  * @param  __INTERRUPT__: specifies the DCMI interrupt sources to be enabled. 
N  *         This parameter can be any combination of the following values:
N  *            @arg DCMI_IT_FRAME: Frame capture complete interrupt mask
N  *            @arg DCMI_IT_OVF: Overflow interrupt mask
N  *            @arg DCMI_IT_ERR: Synchronization error interrupt mask
N  *            @arg DCMI_IT_VSYNC: VSYNC interrupt mask
N  *            @arg DCMI_IT_LINE: Line interrupt mask
N  * @retval None
N  */
N#define __HAL_DCMI_ENABLE_IT(__HANDLE__, __INTERRUPT__) ((__HANDLE__)->Instance->IER |= (__INTERRUPT__))
N
N/**
N  * @brief  Disable the specified DCMI interrupts.
N  * @param  __HANDLE__: DCMI handle
N  * @param  __INTERRUPT__: specifies the DCMI interrupt sources to be enabled. 
N  *         This parameter can be any combination of the following values:
N  *            @arg DCMI_IT_FRAME: Frame capture complete interrupt mask
N  *            @arg DCMI_IT_OVF: Overflow interrupt mask
N  *            @arg DCMI_IT_ERR: Synchronization error interrupt mask
N  *            @arg DCMI_IT_VSYNC: VSYNC interrupt mask
N  *            @arg DCMI_IT_LINE: Line interrupt mask
N  * @retval None
N  */
N#define __HAL_DCMI_DISABLE_IT(__HANDLE__, __INTERRUPT__) ((__HANDLE__)->Instance->IER &= ~(__INTERRUPT__))
N
N/**
N  * @brief  Check whether the specified DCMI interrupt has occurred or not.
N  * @param  __HANDLE__: DCMI handle
N  * @param  __INTERRUPT__: specifies the DCMI interrupt source to check.
N  *         This parameter can be one of the following values:
N  *            @arg DCMI_IT_FRAME: Frame capture complete interrupt mask
N  *            @arg DCMI_IT_OVF: Overflow interrupt mask
N  *            @arg DCMI_IT_ERR: Synchronization error interrupt mask
N  *            @arg DCMI_IT_VSYNC: VSYNC interrupt mask
N  *            @arg DCMI_IT_LINE: Line interrupt mask
N  * @retval The state of INTERRUPT.
N  */
N#define __HAL_DCMI_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) ((__HANDLE__)->Instance->MISR & (__INTERRUPT__))
N
N/**
N  * @}
N  */
N  
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup DCMI_Exported_Functions DCMI Exported Functions
N  * @{
N  */
N
N/** @addtogroup DCMI_Exported_Functions_Group1 Initialization and Configuration functions
N * @{
N */
N/* Initialization and de-initialization functions *****************************/
NHAL_StatusTypeDef HAL_DCMI_Init(DCMI_HandleTypeDef *hdcmi);
NHAL_StatusTypeDef HAL_DCMI_DeInit(DCMI_HandleTypeDef *hdcmi);
Nvoid       HAL_DCMI_MspInit(DCMI_HandleTypeDef* hdcmi);
Nvoid       HAL_DCMI_MspDeInit(DCMI_HandleTypeDef* hdcmi);
N/**
N  * @}
N  */
N  
N/** @addtogroup DCMI_Exported_Functions_Group2 IO operation functions
N * @{
N */
N/* IO operation functions *****************************************************/
NHAL_StatusTypeDef HAL_DCMI_Start_DMA(DCMI_HandleTypeDef* hdcmi, uint32_t DCMI_Mode, uint32_t pData, uint32_t Length);
NHAL_StatusTypeDef HAL_DCMI_Stop(DCMI_HandleTypeDef* hdcmi);
NHAL_StatusTypeDef HAL_DCMI_Suspend(DCMI_HandleTypeDef* hdcmi);
NHAL_StatusTypeDef HAL_DCMI_Resume(DCMI_HandleTypeDef* hdcmi);
Nvoid       HAL_DCMI_ErrorCallback(DCMI_HandleTypeDef *hdcmi);
Nvoid       HAL_DCMI_LineEventCallback(DCMI_HandleTypeDef *hdcmi);
Nvoid       HAL_DCMI_FrameEventCallback(DCMI_HandleTypeDef *hdcmi);
Nvoid       HAL_DCMI_VsyncEventCallback(DCMI_HandleTypeDef *hdcmi);
Nvoid       HAL_DCMI_VsyncCallback(DCMI_HandleTypeDef *hdcmi);
Nvoid       HAL_DCMI_HsyncCallback(DCMI_HandleTypeDef *hdcmi);
Nvoid       HAL_DCMI_IRQHandler(DCMI_HandleTypeDef *hdcmi);
N/**
N  * @}
N  */
N  
N/** @addtogroup DCMI_Exported_Functions_Group3 Peripheral Control functions
N * @{
N */
N/* Peripheral Control functions ***********************************************/
NHAL_StatusTypeDef     HAL_DCMI_ConfigCrop(DCMI_HandleTypeDef *hdcmi, uint32_t X0, uint32_t Y0, uint32_t XSize, uint32_t YSize);
NHAL_StatusTypeDef     HAL_DCMI_EnableCrop(DCMI_HandleTypeDef *hdcmi);
NHAL_StatusTypeDef     HAL_DCMI_DisableCrop(DCMI_HandleTypeDef *hdcmi);
N
N/**
N  * @}
N  */
N  
N/** @addtogroup DCMI_Exported_Functions_Group4 Peripheral State functions
N * @{
N */
N/* Peripheral State functions *************************************************/
NHAL_DCMI_StateTypeDef HAL_DCMI_GetState(DCMI_HandleTypeDef *hdcmi);
Nuint32_t              HAL_DCMI_GetError(DCMI_HandleTypeDef *hdcmi);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup DCMI_Private_Constants DCMI Private Constants
N  * @{
N  */
N#define DCMI_MIS_INDEX        ((uint32_t)0x1000) /*!< DCMI MIS register index */
N#define DCMI_SR_INDEX         ((uint32_t)0x2000) /*!< DCMI SR register index  */   
N/**
N  * @}
N  */   
N/* Private macro -------------------------------------------------------------*/
N/** @defgroup DCMI_Private_Macros DCMI Private Macros
N  * @{
N  */
N#define IS_DCMI_CAPTURE_MODE(MODE)(((MODE) == DCMI_MODE_CONTINUOUS) || \
N                                   ((MODE) == DCMI_MODE_SNAPSHOT))
X#define IS_DCMI_CAPTURE_MODE(MODE)(((MODE) == DCMI_MODE_CONTINUOUS) ||                                    ((MODE) == DCMI_MODE_SNAPSHOT))
N																			 
N#define IS_DCMI_SYNCHRO(MODE)(((MODE) == DCMI_SYNCHRO_HARDWARE) || \
N                              ((MODE) == DCMI_SYNCHRO_EMBEDDED))
X#define IS_DCMI_SYNCHRO(MODE)(((MODE) == DCMI_SYNCHRO_HARDWARE) ||                               ((MODE) == DCMI_SYNCHRO_EMBEDDED))
N																	
N#define IS_DCMI_PCKPOLARITY(POLARITY)(((POLARITY) == DCMI_PCKPOLARITY_FALLING) || \
N                                      ((POLARITY) == DCMI_PCKPOLARITY_RISING))
X#define IS_DCMI_PCKPOLARITY(POLARITY)(((POLARITY) == DCMI_PCKPOLARITY_FALLING) ||                                       ((POLARITY) == DCMI_PCKPOLARITY_RISING))
N																					
N#define IS_DCMI_VSPOLARITY(POLARITY)(((POLARITY) == DCMI_VSPOLARITY_LOW) || \
N                                     ((POLARITY) == DCMI_VSPOLARITY_HIGH))
X#define IS_DCMI_VSPOLARITY(POLARITY)(((POLARITY) == DCMI_VSPOLARITY_LOW) ||                                      ((POLARITY) == DCMI_VSPOLARITY_HIGH))
N																				 
N#define IS_DCMI_HSPOLARITY(POLARITY)(((POLARITY) == DCMI_HSPOLARITY_LOW) || \
N                                     ((POLARITY) == DCMI_HSPOLARITY_HIGH))
X#define IS_DCMI_HSPOLARITY(POLARITY)(((POLARITY) == DCMI_HSPOLARITY_LOW) ||                                      ((POLARITY) == DCMI_HSPOLARITY_HIGH))
N																				 
N#define IS_DCMI_MODE_JPEG(JPEG_MODE)(((JPEG_MODE) == DCMI_JPEG_DISABLE) || \
N                                     ((JPEG_MODE) == DCMI_JPEG_ENABLE))
X#define IS_DCMI_MODE_JPEG(JPEG_MODE)(((JPEG_MODE) == DCMI_JPEG_DISABLE) ||                                      ((JPEG_MODE) == DCMI_JPEG_ENABLE))
N																				 
N#define IS_DCMI_CAPTURE_RATE(RATE) (((RATE) == DCMI_CR_ALL_FRAME)         || \
N                                    ((RATE) == DCMI_CR_ALTERNATE_2_FRAME) || \
N                                    ((RATE) == DCMI_CR_ALTERNATE_4_FRAME))
X#define IS_DCMI_CAPTURE_RATE(RATE) (((RATE) == DCMI_CR_ALL_FRAME)         ||                                     ((RATE) == DCMI_CR_ALTERNATE_2_FRAME) ||                                     ((RATE) == DCMI_CR_ALTERNATE_4_FRAME))
N																				
N#define IS_DCMI_EXTENDED_DATA(DATA)(((DATA) == DCMI_EXTEND_DATA_8B)  || \
N                                    ((DATA) == DCMI_EXTEND_DATA_10B) || \
N                                    ((DATA) == DCMI_EXTEND_DATA_12B) || \
N                                    ((DATA) == DCMI_EXTEND_DATA_14B))
X#define IS_DCMI_EXTENDED_DATA(DATA)(((DATA) == DCMI_EXTEND_DATA_8B)  ||                                     ((DATA) == DCMI_EXTEND_DATA_10B) ||                                     ((DATA) == DCMI_EXTEND_DATA_12B) ||                                     ((DATA) == DCMI_EXTEND_DATA_14B))
N																				
N#define IS_DCMI_WINDOW_COORDINATE(COORDINATE) ((COORDINATE) <= DCMI_WINDOW_COORDINATE)
N
N#define IS_DCMI_WINDOW_HEIGHT(HEIGHT) ((HEIGHT) <= DCMI_WINDOW_HEIGHT)
N
N#define IS_DCMI_BYTE_SELECT_MODE(MODE)(((MODE) == DCMI_BSM_ALL) || \
N                                       ((MODE) == DCMI_BSM_OTHER) || \
N                                       ((MODE) == DCMI_BSM_ALTERNATE_4) || \
N                                       ((MODE) == DCMI_BSM_ALTERNATE_2))
X#define IS_DCMI_BYTE_SELECT_MODE(MODE)(((MODE) == DCMI_BSM_ALL) ||                                        ((MODE) == DCMI_BSM_OTHER) ||                                        ((MODE) == DCMI_BSM_ALTERNATE_4) ||                                        ((MODE) == DCMI_BSM_ALTERNATE_2))
N                                                                                                
N#define IS_DCMI_BYTE_SELECT_START(POLARITY)(((POLARITY) == DCMI_OEBS_ODD) || \
N                                            ((POLARITY) == DCMI_OEBS_EVEN))
X#define IS_DCMI_BYTE_SELECT_START(POLARITY)(((POLARITY) == DCMI_OEBS_ODD) ||                                             ((POLARITY) == DCMI_OEBS_EVEN))
N                              
N#define IS_DCMI_LINE_SELECT_MODE(MODE)(((MODE) == DCMI_LSM_ALL) || \
N                                       ((MODE) == DCMI_LSM_ALTERNATE_2))
X#define IS_DCMI_LINE_SELECT_MODE(MODE)(((MODE) == DCMI_LSM_ALL) ||                                        ((MODE) == DCMI_LSM_ALTERNATE_2))
N                                      
N#define IS_DCMI_LINE_SELECT_START(POLARITY)(((POLARITY) == DCMI_OELS_ODD) || \
N                                            ((POLARITY) == DCMI_OELS_EVEN))
X#define IS_DCMI_LINE_SELECT_START(POLARITY)(((POLARITY) == DCMI_OELS_ODD) ||                                             ((POLARITY) == DCMI_OELS_EVEN))
N
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @addtogroup DCMI_Private_Functions DCMI Private Functions
N  * @{
N  */
N  
N/**
N  * @}
N  */
N      
N/**
N  * @}
N  */
N/**
N  * @}
N  */ 
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_DCMI_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 291 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_DCMI_MODULE_ENABLED */
N
N#ifdef HAL_ETH_MODULE_ENABLED
N  #include "stm32f7xx_hal_eth.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_eth.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_eth.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of ETH HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_ETH_H
N#define __STM32F7xx_HAL_ETH_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup ETH
N  * @{
N  */ 
N  
N/** @addtogroup ETH_Private_Macros
N  * @{
N  */
N#define IS_ETH_PHY_ADDRESS(ADDRESS) ((ADDRESS) <= 0x20)
N#define IS_ETH_AUTONEGOTIATION(CMD) (((CMD) == ETH_AUTONEGOTIATION_ENABLE) || \
N                                     ((CMD) == ETH_AUTONEGOTIATION_DISABLE))
X#define IS_ETH_AUTONEGOTIATION(CMD) (((CMD) == ETH_AUTONEGOTIATION_ENABLE) ||                                      ((CMD) == ETH_AUTONEGOTIATION_DISABLE))
N#define IS_ETH_SPEED(SPEED) (((SPEED) == ETH_SPEED_10M) || \
N                             ((SPEED) == ETH_SPEED_100M))
X#define IS_ETH_SPEED(SPEED) (((SPEED) == ETH_SPEED_10M) ||                              ((SPEED) == ETH_SPEED_100M))
N#define IS_ETH_DUPLEX_MODE(MODE)  (((MODE) == ETH_MODE_FULLDUPLEX) || \
N                                  ((MODE) == ETH_MODE_HALFDUPLEX))
X#define IS_ETH_DUPLEX_MODE(MODE)  (((MODE) == ETH_MODE_FULLDUPLEX) ||                                   ((MODE) == ETH_MODE_HALFDUPLEX))
N#define IS_ETH_RX_MODE(MODE)    (((MODE) == ETH_RXPOLLING_MODE) || \
N                                 ((MODE) == ETH_RXINTERRUPT_MODE)) 
X#define IS_ETH_RX_MODE(MODE)    (((MODE) == ETH_RXPOLLING_MODE) ||                                  ((MODE) == ETH_RXINTERRUPT_MODE)) 
N#define IS_ETH_CHECKSUM_MODE(MODE)    (((MODE) == ETH_CHECKSUM_BY_HARDWARE) || \
N                                      ((MODE) == ETH_CHECKSUM_BY_SOFTWARE))
X#define IS_ETH_CHECKSUM_MODE(MODE)    (((MODE) == ETH_CHECKSUM_BY_HARDWARE) ||                                       ((MODE) == ETH_CHECKSUM_BY_SOFTWARE))
N#define IS_ETH_MEDIA_INTERFACE(MODE)         (((MODE) == ETH_MEDIA_INTERFACE_MII) || \
N                                              ((MODE) == ETH_MEDIA_INTERFACE_RMII))
X#define IS_ETH_MEDIA_INTERFACE(MODE)         (((MODE) == ETH_MEDIA_INTERFACE_MII) ||                                               ((MODE) == ETH_MEDIA_INTERFACE_RMII))
N#define IS_ETH_WATCHDOG(CMD) (((CMD) == ETH_WATCHDOG_ENABLE) || \
N                              ((CMD) == ETH_WATCHDOG_DISABLE))
X#define IS_ETH_WATCHDOG(CMD) (((CMD) == ETH_WATCHDOG_ENABLE) ||                               ((CMD) == ETH_WATCHDOG_DISABLE))
N#define IS_ETH_JABBER(CMD) (((CMD) == ETH_JABBER_ENABLE) || \
N                            ((CMD) == ETH_JABBER_DISABLE))
X#define IS_ETH_JABBER(CMD) (((CMD) == ETH_JABBER_ENABLE) ||                             ((CMD) == ETH_JABBER_DISABLE))
N#define IS_ETH_INTER_FRAME_GAP(GAP) (((GAP) == ETH_INTERFRAMEGAP_96BIT) || \
N                                     ((GAP) == ETH_INTERFRAMEGAP_88BIT) || \
N                                     ((GAP) == ETH_INTERFRAMEGAP_80BIT) || \
N                                     ((GAP) == ETH_INTERFRAMEGAP_72BIT) || \
N                                     ((GAP) == ETH_INTERFRAMEGAP_64BIT) || \
N                                     ((GAP) == ETH_INTERFRAMEGAP_56BIT) || \
N                                     ((GAP) == ETH_INTERFRAMEGAP_48BIT) || \
N                                     ((GAP) == ETH_INTERFRAMEGAP_40BIT))
X#define IS_ETH_INTER_FRAME_GAP(GAP) (((GAP) == ETH_INTERFRAMEGAP_96BIT) ||                                      ((GAP) == ETH_INTERFRAMEGAP_88BIT) ||                                      ((GAP) == ETH_INTERFRAMEGAP_80BIT) ||                                      ((GAP) == ETH_INTERFRAMEGAP_72BIT) ||                                      ((GAP) == ETH_INTERFRAMEGAP_64BIT) ||                                      ((GAP) == ETH_INTERFRAMEGAP_56BIT) ||                                      ((GAP) == ETH_INTERFRAMEGAP_48BIT) ||                                      ((GAP) == ETH_INTERFRAMEGAP_40BIT))
N#define IS_ETH_CARRIER_SENSE(CMD) (((CMD) == ETH_CARRIERSENCE_ENABLE) || \
N                                   ((CMD) == ETH_CARRIERSENCE_DISABLE))
X#define IS_ETH_CARRIER_SENSE(CMD) (((CMD) == ETH_CARRIERSENCE_ENABLE) ||                                    ((CMD) == ETH_CARRIERSENCE_DISABLE))
N#define IS_ETH_RECEIVE_OWN(CMD) (((CMD) == ETH_RECEIVEOWN_ENABLE) || \
N                                 ((CMD) == ETH_RECEIVEOWN_DISABLE))
X#define IS_ETH_RECEIVE_OWN(CMD) (((CMD) == ETH_RECEIVEOWN_ENABLE) ||                                  ((CMD) == ETH_RECEIVEOWN_DISABLE))
N#define IS_ETH_LOOPBACK_MODE(CMD) (((CMD) == ETH_LOOPBACKMODE_ENABLE) || \
N                                   ((CMD) == ETH_LOOPBACKMODE_DISABLE))
X#define IS_ETH_LOOPBACK_MODE(CMD) (((CMD) == ETH_LOOPBACKMODE_ENABLE) ||                                    ((CMD) == ETH_LOOPBACKMODE_DISABLE))
N#define IS_ETH_CHECKSUM_OFFLOAD(CMD) (((CMD) == ETH_CHECKSUMOFFLAOD_ENABLE) || \
N                                      ((CMD) == ETH_CHECKSUMOFFLAOD_DISABLE))
X#define IS_ETH_CHECKSUM_OFFLOAD(CMD) (((CMD) == ETH_CHECKSUMOFFLAOD_ENABLE) ||                                       ((CMD) == ETH_CHECKSUMOFFLAOD_DISABLE))
N#define IS_ETH_RETRY_TRANSMISSION(CMD) (((CMD) == ETH_RETRYTRANSMISSION_ENABLE) || \
N                                        ((CMD) == ETH_RETRYTRANSMISSION_DISABLE))
X#define IS_ETH_RETRY_TRANSMISSION(CMD) (((CMD) == ETH_RETRYTRANSMISSION_ENABLE) ||                                         ((CMD) == ETH_RETRYTRANSMISSION_DISABLE))
N#define IS_ETH_AUTOMATIC_PADCRC_STRIP(CMD) (((CMD) == ETH_AUTOMATICPADCRCSTRIP_ENABLE) || \
N                                            ((CMD) == ETH_AUTOMATICPADCRCSTRIP_DISABLE))
X#define IS_ETH_AUTOMATIC_PADCRC_STRIP(CMD) (((CMD) == ETH_AUTOMATICPADCRCSTRIP_ENABLE) ||                                             ((CMD) == ETH_AUTOMATICPADCRCSTRIP_DISABLE))
N#define IS_ETH_BACKOFF_LIMIT(LIMIT) (((LIMIT) == ETH_BACKOFFLIMIT_10) || \
N                                     ((LIMIT) == ETH_BACKOFFLIMIT_8) || \
N                                     ((LIMIT) == ETH_BACKOFFLIMIT_4) || \
N                                     ((LIMIT) == ETH_BACKOFFLIMIT_1))
X#define IS_ETH_BACKOFF_LIMIT(LIMIT) (((LIMIT) == ETH_BACKOFFLIMIT_10) ||                                      ((LIMIT) == ETH_BACKOFFLIMIT_8) ||                                      ((LIMIT) == ETH_BACKOFFLIMIT_4) ||                                      ((LIMIT) == ETH_BACKOFFLIMIT_1))
N#define IS_ETH_DEFERRAL_CHECK(CMD) (((CMD) == ETH_DEFFERRALCHECK_ENABLE) || \
N                                    ((CMD) == ETH_DEFFERRALCHECK_DISABLE))
X#define IS_ETH_DEFERRAL_CHECK(CMD) (((CMD) == ETH_DEFFERRALCHECK_ENABLE) ||                                     ((CMD) == ETH_DEFFERRALCHECK_DISABLE))
N#define IS_ETH_RECEIVE_ALL(CMD) (((CMD) == ETH_RECEIVEALL_ENABLE) || \
N                                 ((CMD) == ETH_RECEIVEAll_DISABLE))
X#define IS_ETH_RECEIVE_ALL(CMD) (((CMD) == ETH_RECEIVEALL_ENABLE) ||                                  ((CMD) == ETH_RECEIVEAll_DISABLE))
N#define IS_ETH_SOURCE_ADDR_FILTER(CMD) (((CMD) == ETH_SOURCEADDRFILTER_NORMAL_ENABLE) || \
N                                        ((CMD) == ETH_SOURCEADDRFILTER_INVERSE_ENABLE) || \
N                                        ((CMD) == ETH_SOURCEADDRFILTER_DISABLE))
X#define IS_ETH_SOURCE_ADDR_FILTER(CMD) (((CMD) == ETH_SOURCEADDRFILTER_NORMAL_ENABLE) ||                                         ((CMD) == ETH_SOURCEADDRFILTER_INVERSE_ENABLE) ||                                         ((CMD) == ETH_SOURCEADDRFILTER_DISABLE))
N#define IS_ETH_CONTROL_FRAMES(PASS) (((PASS) == ETH_PASSCONTROLFRAMES_BLOCKALL) || \
N                                     ((PASS) == ETH_PASSCONTROLFRAMES_FORWARDALL) || \
N                                     ((PASS) == ETH_PASSCONTROLFRAMES_FORWARDPASSEDADDRFILTER))
X#define IS_ETH_CONTROL_FRAMES(PASS) (((PASS) == ETH_PASSCONTROLFRAMES_BLOCKALL) ||                                      ((PASS) == ETH_PASSCONTROLFRAMES_FORWARDALL) ||                                      ((PASS) == ETH_PASSCONTROLFRAMES_FORWARDPASSEDADDRFILTER))
N#define IS_ETH_BROADCAST_FRAMES_RECEPTION(CMD) (((CMD) == ETH_BROADCASTFRAMESRECEPTION_ENABLE) || \
N                                                ((CMD) == ETH_BROADCASTFRAMESRECEPTION_DISABLE))
X#define IS_ETH_BROADCAST_FRAMES_RECEPTION(CMD) (((CMD) == ETH_BROADCASTFRAMESRECEPTION_ENABLE) ||                                                 ((CMD) == ETH_BROADCASTFRAMESRECEPTION_DISABLE))
N#define IS_ETH_DESTINATION_ADDR_FILTER(FILTER) (((FILTER) == ETH_DESTINATIONADDRFILTER_NORMAL) || \
N                                                ((FILTER) == ETH_DESTINATIONADDRFILTER_INVERSE))
X#define IS_ETH_DESTINATION_ADDR_FILTER(FILTER) (((FILTER) == ETH_DESTINATIONADDRFILTER_NORMAL) ||                                                 ((FILTER) == ETH_DESTINATIONADDRFILTER_INVERSE))
N#define IS_ETH_PROMISCUOUS_MODE(CMD) (((CMD) == ETH_PROMISCUOUS_MODE_ENABLE) || \
N                                      ((CMD) == ETH_PROMISCUOUS_MODE_DISABLE))
X#define IS_ETH_PROMISCUOUS_MODE(CMD) (((CMD) == ETH_PROMISCUOUS_MODE_ENABLE) ||                                       ((CMD) == ETH_PROMISCUOUS_MODE_DISABLE))
N#define IS_ETH_MULTICAST_FRAMES_FILTER(FILTER) (((FILTER) == ETH_MULTICASTFRAMESFILTER_PERFECTHASHTABLE) || \
N                                                ((FILTER) == ETH_MULTICASTFRAMESFILTER_HASHTABLE) || \
N                                                ((FILTER) == ETH_MULTICASTFRAMESFILTER_PERFECT) || \
N                                                ((FILTER) == ETH_MULTICASTFRAMESFILTER_NONE))
X#define IS_ETH_MULTICAST_FRAMES_FILTER(FILTER) (((FILTER) == ETH_MULTICASTFRAMESFILTER_PERFECTHASHTABLE) ||                                                 ((FILTER) == ETH_MULTICASTFRAMESFILTER_HASHTABLE) ||                                                 ((FILTER) == ETH_MULTICASTFRAMESFILTER_PERFECT) ||                                                 ((FILTER) == ETH_MULTICASTFRAMESFILTER_NONE))
N#define IS_ETH_UNICAST_FRAMES_FILTER(FILTER) (((FILTER) == ETH_UNICASTFRAMESFILTER_PERFECTHASHTABLE) || \
N                                              ((FILTER) == ETH_UNICASTFRAMESFILTER_HASHTABLE) || \
N                                              ((FILTER) == ETH_UNICASTFRAMESFILTER_PERFECT))
X#define IS_ETH_UNICAST_FRAMES_FILTER(FILTER) (((FILTER) == ETH_UNICASTFRAMESFILTER_PERFECTHASHTABLE) ||                                               ((FILTER) == ETH_UNICASTFRAMESFILTER_HASHTABLE) ||                                               ((FILTER) == ETH_UNICASTFRAMESFILTER_PERFECT))
N#define IS_ETH_PAUSE_TIME(TIME) ((TIME) <= 0xFFFF)
N#define IS_ETH_ZEROQUANTA_PAUSE(CMD)   (((CMD) == ETH_ZEROQUANTAPAUSE_ENABLE) || \
N                                        ((CMD) == ETH_ZEROQUANTAPAUSE_DISABLE))
X#define IS_ETH_ZEROQUANTA_PAUSE(CMD)   (((CMD) == ETH_ZEROQUANTAPAUSE_ENABLE) ||                                         ((CMD) == ETH_ZEROQUANTAPAUSE_DISABLE))
N#define IS_ETH_PAUSE_LOW_THRESHOLD(THRESHOLD) (((THRESHOLD) == ETH_PAUSELOWTHRESHOLD_MINUS4) || \
N                                               ((THRESHOLD) == ETH_PAUSELOWTHRESHOLD_MINUS28) || \
N                                               ((THRESHOLD) == ETH_PAUSELOWTHRESHOLD_MINUS144) || \
N                                               ((THRESHOLD) == ETH_PAUSELOWTHRESHOLD_MINUS256))
X#define IS_ETH_PAUSE_LOW_THRESHOLD(THRESHOLD) (((THRESHOLD) == ETH_PAUSELOWTHRESHOLD_MINUS4) ||                                                ((THRESHOLD) == ETH_PAUSELOWTHRESHOLD_MINUS28) ||                                                ((THRESHOLD) == ETH_PAUSELOWTHRESHOLD_MINUS144) ||                                                ((THRESHOLD) == ETH_PAUSELOWTHRESHOLD_MINUS256))
N#define IS_ETH_UNICAST_PAUSE_FRAME_DETECT(CMD) (((CMD) == ETH_UNICASTPAUSEFRAMEDETECT_ENABLE) || \
N                                                ((CMD) == ETH_UNICASTPAUSEFRAMEDETECT_DISABLE))
X#define IS_ETH_UNICAST_PAUSE_FRAME_DETECT(CMD) (((CMD) == ETH_UNICASTPAUSEFRAMEDETECT_ENABLE) ||                                                 ((CMD) == ETH_UNICASTPAUSEFRAMEDETECT_DISABLE))
N#define IS_ETH_RECEIVE_FLOWCONTROL(CMD) (((CMD) == ETH_RECEIVEFLOWCONTROL_ENABLE) || \
N                                         ((CMD) == ETH_RECEIVEFLOWCONTROL_DISABLE))
X#define IS_ETH_RECEIVE_FLOWCONTROL(CMD) (((CMD) == ETH_RECEIVEFLOWCONTROL_ENABLE) ||                                          ((CMD) == ETH_RECEIVEFLOWCONTROL_DISABLE))
N#define IS_ETH_TRANSMIT_FLOWCONTROL(CMD) (((CMD) == ETH_TRANSMITFLOWCONTROL_ENABLE) || \
N                                          ((CMD) == ETH_TRANSMITFLOWCONTROL_DISABLE))
X#define IS_ETH_TRANSMIT_FLOWCONTROL(CMD) (((CMD) == ETH_TRANSMITFLOWCONTROL_ENABLE) ||                                           ((CMD) == ETH_TRANSMITFLOWCONTROL_DISABLE))
N#define IS_ETH_VLAN_TAG_COMPARISON(COMPARISON) (((COMPARISON) == ETH_VLANTAGCOMPARISON_12BIT) || \
N                                                ((COMPARISON) == ETH_VLANTAGCOMPARISON_16BIT))
X#define IS_ETH_VLAN_TAG_COMPARISON(COMPARISON) (((COMPARISON) == ETH_VLANTAGCOMPARISON_12BIT) ||                                                 ((COMPARISON) == ETH_VLANTAGCOMPARISON_16BIT))
N#define IS_ETH_VLAN_TAG_IDENTIFIER(IDENTIFIER) ((IDENTIFIER) <= 0xFFFF)
N#define IS_ETH_MAC_ADDRESS0123(ADDRESS) (((ADDRESS) == ETH_MAC_ADDRESS0) || \
N                                         ((ADDRESS) == ETH_MAC_ADDRESS1) || \
N                                         ((ADDRESS) == ETH_MAC_ADDRESS2) || \
N                                         ((ADDRESS) == ETH_MAC_ADDRESS3))
X#define IS_ETH_MAC_ADDRESS0123(ADDRESS) (((ADDRESS) == ETH_MAC_ADDRESS0) ||                                          ((ADDRESS) == ETH_MAC_ADDRESS1) ||                                          ((ADDRESS) == ETH_MAC_ADDRESS2) ||                                          ((ADDRESS) == ETH_MAC_ADDRESS3))
N#define IS_ETH_MAC_ADDRESS123(ADDRESS) (((ADDRESS) == ETH_MAC_ADDRESS1) || \
N                                        ((ADDRESS) == ETH_MAC_ADDRESS2) || \
N                                        ((ADDRESS) == ETH_MAC_ADDRESS3))
X#define IS_ETH_MAC_ADDRESS123(ADDRESS) (((ADDRESS) == ETH_MAC_ADDRESS1) ||                                         ((ADDRESS) == ETH_MAC_ADDRESS2) ||                                         ((ADDRESS) == ETH_MAC_ADDRESS3))
N#define IS_ETH_MAC_ADDRESS_FILTER(FILTER) (((FILTER) == ETH_MAC_ADDRESSFILTER_SA) || \
N                                           ((FILTER) == ETH_MAC_ADDRESSFILTER_DA))
X#define IS_ETH_MAC_ADDRESS_FILTER(FILTER) (((FILTER) == ETH_MAC_ADDRESSFILTER_SA) ||                                            ((FILTER) == ETH_MAC_ADDRESSFILTER_DA))
N#define IS_ETH_MAC_ADDRESS_MASK(MASK) (((MASK) == ETH_MAC_ADDRESSMASK_BYTE6) || \
N                                       ((MASK) == ETH_MAC_ADDRESSMASK_BYTE5) || \
N                                       ((MASK) == ETH_MAC_ADDRESSMASK_BYTE4) || \
N                                       ((MASK) == ETH_MAC_ADDRESSMASK_BYTE3) || \
N                                       ((MASK) == ETH_MAC_ADDRESSMASK_BYTE2) || \
N                                       ((MASK) == ETH_MAC_ADDRESSMASK_BYTE1))
X#define IS_ETH_MAC_ADDRESS_MASK(MASK) (((MASK) == ETH_MAC_ADDRESSMASK_BYTE6) ||                                        ((MASK) == ETH_MAC_ADDRESSMASK_BYTE5) ||                                        ((MASK) == ETH_MAC_ADDRESSMASK_BYTE4) ||                                        ((MASK) == ETH_MAC_ADDRESSMASK_BYTE3) ||                                        ((MASK) == ETH_MAC_ADDRESSMASK_BYTE2) ||                                        ((MASK) == ETH_MAC_ADDRESSMASK_BYTE1))
N#define IS_ETH_DROP_TCPIP_CHECKSUM_FRAME(CMD) (((CMD) == ETH_DROPTCPIPCHECKSUMERRORFRAME_ENABLE) || \
N                                               ((CMD) == ETH_DROPTCPIPCHECKSUMERRORFRAME_DISABLE))
X#define IS_ETH_DROP_TCPIP_CHECKSUM_FRAME(CMD) (((CMD) == ETH_DROPTCPIPCHECKSUMERRORFRAME_ENABLE) ||                                                ((CMD) == ETH_DROPTCPIPCHECKSUMERRORFRAME_DISABLE))
N#define IS_ETH_RECEIVE_STORE_FORWARD(CMD) (((CMD) == ETH_RECEIVESTOREFORWARD_ENABLE) || \
N                                           ((CMD) == ETH_RECEIVESTOREFORWARD_DISABLE))
X#define IS_ETH_RECEIVE_STORE_FORWARD(CMD) (((CMD) == ETH_RECEIVESTOREFORWARD_ENABLE) ||                                            ((CMD) == ETH_RECEIVESTOREFORWARD_DISABLE))
N#define IS_ETH_FLUSH_RECEIVE_FRAME(CMD) (((CMD) == ETH_FLUSHRECEIVEDFRAME_ENABLE) || \
N                                         ((CMD) == ETH_FLUSHRECEIVEDFRAME_DISABLE))
X#define IS_ETH_FLUSH_RECEIVE_FRAME(CMD) (((CMD) == ETH_FLUSHRECEIVEDFRAME_ENABLE) ||                                          ((CMD) == ETH_FLUSHRECEIVEDFRAME_DISABLE))
N#define IS_ETH_TRANSMIT_STORE_FORWARD(CMD) (((CMD) == ETH_TRANSMITSTOREFORWARD_ENABLE) || \
N                                            ((CMD) == ETH_TRANSMITSTOREFORWARD_DISABLE))
X#define IS_ETH_TRANSMIT_STORE_FORWARD(CMD) (((CMD) == ETH_TRANSMITSTOREFORWARD_ENABLE) ||                                             ((CMD) == ETH_TRANSMITSTOREFORWARD_DISABLE))
N#define IS_ETH_TRANSMIT_THRESHOLD_CONTROL(THRESHOLD) (((THRESHOLD) == ETH_TRANSMITTHRESHOLDCONTROL_64BYTES) || \
N                                                      ((THRESHOLD) == ETH_TRANSMITTHRESHOLDCONTROL_128BYTES) || \
N                                                      ((THRESHOLD) == ETH_TRANSMITTHRESHOLDCONTROL_192BYTES) || \
N                                                      ((THRESHOLD) == ETH_TRANSMITTHRESHOLDCONTROL_256BYTES) || \
N                                                      ((THRESHOLD) == ETH_TRANSMITTHRESHOLDCONTROL_40BYTES) || \
N                                                      ((THRESHOLD) == ETH_TRANSMITTHRESHOLDCONTROL_32BYTES) || \
N                                                      ((THRESHOLD) == ETH_TRANSMITTHRESHOLDCONTROL_24BYTES) || \
N                                                      ((THRESHOLD) == ETH_TRANSMITTHRESHOLDCONTROL_16BYTES))
X#define IS_ETH_TRANSMIT_THRESHOLD_CONTROL(THRESHOLD) (((THRESHOLD) == ETH_TRANSMITTHRESHOLDCONTROL_64BYTES) ||                                                       ((THRESHOLD) == ETH_TRANSMITTHRESHOLDCONTROL_128BYTES) ||                                                       ((THRESHOLD) == ETH_TRANSMITTHRESHOLDCONTROL_192BYTES) ||                                                       ((THRESHOLD) == ETH_TRANSMITTHRESHOLDCONTROL_256BYTES) ||                                                       ((THRESHOLD) == ETH_TRANSMITTHRESHOLDCONTROL_40BYTES) ||                                                       ((THRESHOLD) == ETH_TRANSMITTHRESHOLDCONTROL_32BYTES) ||                                                       ((THRESHOLD) == ETH_TRANSMITTHRESHOLDCONTROL_24BYTES) ||                                                       ((THRESHOLD) == ETH_TRANSMITTHRESHOLDCONTROL_16BYTES))
N#define IS_ETH_FORWARD_ERROR_FRAMES(CMD) (((CMD) == ETH_FORWARDERRORFRAMES_ENABLE) || \
N                                          ((CMD) == ETH_FORWARDERRORFRAMES_DISABLE))
X#define IS_ETH_FORWARD_ERROR_FRAMES(CMD) (((CMD) == ETH_FORWARDERRORFRAMES_ENABLE) ||                                           ((CMD) == ETH_FORWARDERRORFRAMES_DISABLE))
N#define IS_ETH_FORWARD_UNDERSIZED_GOOD_FRAMES(CMD) (((CMD) == ETH_FORWARDUNDERSIZEDGOODFRAMES_ENABLE) || \
N                                                    ((CMD) == ETH_FORWARDUNDERSIZEDGOODFRAMES_DISABLE))
X#define IS_ETH_FORWARD_UNDERSIZED_GOOD_FRAMES(CMD) (((CMD) == ETH_FORWARDUNDERSIZEDGOODFRAMES_ENABLE) ||                                                     ((CMD) == ETH_FORWARDUNDERSIZEDGOODFRAMES_DISABLE))
N#define IS_ETH_RECEIVE_THRESHOLD_CONTROL(THRESHOLD) (((THRESHOLD) == ETH_RECEIVEDTHRESHOLDCONTROL_64BYTES) || \
N                                                     ((THRESHOLD) == ETH_RECEIVEDTHRESHOLDCONTROL_32BYTES) || \
N                                                     ((THRESHOLD) == ETH_RECEIVEDTHRESHOLDCONTROL_96BYTES) || \
N                                                     ((THRESHOLD) == ETH_RECEIVEDTHRESHOLDCONTROL_128BYTES))
X#define IS_ETH_RECEIVE_THRESHOLD_CONTROL(THRESHOLD) (((THRESHOLD) == ETH_RECEIVEDTHRESHOLDCONTROL_64BYTES) ||                                                      ((THRESHOLD) == ETH_RECEIVEDTHRESHOLDCONTROL_32BYTES) ||                                                      ((THRESHOLD) == ETH_RECEIVEDTHRESHOLDCONTROL_96BYTES) ||                                                      ((THRESHOLD) == ETH_RECEIVEDTHRESHOLDCONTROL_128BYTES))
N#define IS_ETH_SECOND_FRAME_OPERATE(CMD) (((CMD) == ETH_SECONDFRAMEOPERARTE_ENABLE) || \
N                                          ((CMD) == ETH_SECONDFRAMEOPERARTE_DISABLE))
X#define IS_ETH_SECOND_FRAME_OPERATE(CMD) (((CMD) == ETH_SECONDFRAMEOPERARTE_ENABLE) ||                                           ((CMD) == ETH_SECONDFRAMEOPERARTE_DISABLE))
N#define IS_ETH_ADDRESS_ALIGNED_BEATS(CMD) (((CMD) == ETH_ADDRESSALIGNEDBEATS_ENABLE) || \
N                                           ((CMD) == ETH_ADDRESSALIGNEDBEATS_DISABLE))
X#define IS_ETH_ADDRESS_ALIGNED_BEATS(CMD) (((CMD) == ETH_ADDRESSALIGNEDBEATS_ENABLE) ||                                            ((CMD) == ETH_ADDRESSALIGNEDBEATS_DISABLE))
N#define IS_ETH_FIXED_BURST(CMD) (((CMD) == ETH_FIXEDBURST_ENABLE) || \
N                                 ((CMD) == ETH_FIXEDBURST_DISABLE))
X#define IS_ETH_FIXED_BURST(CMD) (((CMD) == ETH_FIXEDBURST_ENABLE) ||                                  ((CMD) == ETH_FIXEDBURST_DISABLE))
N#define IS_ETH_RXDMA_BURST_LENGTH(LENGTH) (((LENGTH) == ETH_RXDMABURSTLENGTH_1BEAT) || \
N                                           ((LENGTH) == ETH_RXDMABURSTLENGTH_2BEAT) || \
N                                           ((LENGTH) == ETH_RXDMABURSTLENGTH_4BEAT) || \
N                                           ((LENGTH) == ETH_RXDMABURSTLENGTH_8BEAT) || \
N                                           ((LENGTH) == ETH_RXDMABURSTLENGTH_16BEAT) || \
N                                           ((LENGTH) == ETH_RXDMABURSTLENGTH_32BEAT) || \
N                                           ((LENGTH) == ETH_RXDMABURSTLENGTH_4XPBL_4BEAT) || \
N                                           ((LENGTH) == ETH_RXDMABURSTLENGTH_4XPBL_8BEAT) || \
N                                           ((LENGTH) == ETH_RXDMABURSTLENGTH_4XPBL_16BEAT) || \
N                                           ((LENGTH) == ETH_RXDMABURSTLENGTH_4XPBL_32BEAT) || \
N                                           ((LENGTH) == ETH_RXDMABURSTLENGTH_4XPBL_64BEAT) || \
N                                           ((LENGTH) == ETH_RXDMABURSTLENGTH_4XPBL_128BEAT))
X#define IS_ETH_RXDMA_BURST_LENGTH(LENGTH) (((LENGTH) == ETH_RXDMABURSTLENGTH_1BEAT) ||                                            ((LENGTH) == ETH_RXDMABURSTLENGTH_2BEAT) ||                                            ((LENGTH) == ETH_RXDMABURSTLENGTH_4BEAT) ||                                            ((LENGTH) == ETH_RXDMABURSTLENGTH_8BEAT) ||                                            ((LENGTH) == ETH_RXDMABURSTLENGTH_16BEAT) ||                                            ((LENGTH) == ETH_RXDMABURSTLENGTH_32BEAT) ||                                            ((LENGTH) == ETH_RXDMABURSTLENGTH_4XPBL_4BEAT) ||                                            ((LENGTH) == ETH_RXDMABURSTLENGTH_4XPBL_8BEAT) ||                                            ((LENGTH) == ETH_RXDMABURSTLENGTH_4XPBL_16BEAT) ||                                            ((LENGTH) == ETH_RXDMABURSTLENGTH_4XPBL_32BEAT) ||                                            ((LENGTH) == ETH_RXDMABURSTLENGTH_4XPBL_64BEAT) ||                                            ((LENGTH) == ETH_RXDMABURSTLENGTH_4XPBL_128BEAT))
N#define IS_ETH_TXDMA_BURST_LENGTH(LENGTH) (((LENGTH) == ETH_TXDMABURSTLENGTH_1BEAT) || \
N                                           ((LENGTH) == ETH_TXDMABURSTLENGTH_2BEAT) || \
N                                           ((LENGTH) == ETH_TXDMABURSTLENGTH_4BEAT) || \
N                                           ((LENGTH) == ETH_TXDMABURSTLENGTH_8BEAT) || \
N                                           ((LENGTH) == ETH_TXDMABURSTLENGTH_16BEAT) || \
N                                           ((LENGTH) == ETH_TXDMABURSTLENGTH_32BEAT) || \
N                                           ((LENGTH) == ETH_TXDMABURSTLENGTH_4XPBL_4BEAT) || \
N                                           ((LENGTH) == ETH_TXDMABURSTLENGTH_4XPBL_8BEAT) || \
N                                           ((LENGTH) == ETH_TXDMABURSTLENGTH_4XPBL_16BEAT) || \
N                                           ((LENGTH) == ETH_TXDMABURSTLENGTH_4XPBL_32BEAT) || \
N                                           ((LENGTH) == ETH_TXDMABURSTLENGTH_4XPBL_64BEAT) || \
N                                           ((LENGTH) == ETH_TXDMABURSTLENGTH_4XPBL_128BEAT))
X#define IS_ETH_TXDMA_BURST_LENGTH(LENGTH) (((LENGTH) == ETH_TXDMABURSTLENGTH_1BEAT) ||                                            ((LENGTH) == ETH_TXDMABURSTLENGTH_2BEAT) ||                                            ((LENGTH) == ETH_TXDMABURSTLENGTH_4BEAT) ||                                            ((LENGTH) == ETH_TXDMABURSTLENGTH_8BEAT) ||                                            ((LENGTH) == ETH_TXDMABURSTLENGTH_16BEAT) ||                                            ((LENGTH) == ETH_TXDMABURSTLENGTH_32BEAT) ||                                            ((LENGTH) == ETH_TXDMABURSTLENGTH_4XPBL_4BEAT) ||                                            ((LENGTH) == ETH_TXDMABURSTLENGTH_4XPBL_8BEAT) ||                                            ((LENGTH) == ETH_TXDMABURSTLENGTH_4XPBL_16BEAT) ||                                            ((LENGTH) == ETH_TXDMABURSTLENGTH_4XPBL_32BEAT) ||                                            ((LENGTH) == ETH_TXDMABURSTLENGTH_4XPBL_64BEAT) ||                                            ((LENGTH) == ETH_TXDMABURSTLENGTH_4XPBL_128BEAT))
N#define IS_ETH_DMA_DESC_SKIP_LENGTH(LENGTH) ((LENGTH) <= 0x1F)
N#define IS_ETH_DMA_ARBITRATION_ROUNDROBIN_RXTX(RATIO) (((RATIO) == ETH_DMAARBITRATION_ROUNDROBIN_RXTX_1_1) || \
N                                                       ((RATIO) == ETH_DMAARBITRATION_ROUNDROBIN_RXTX_2_1) || \
N                                                       ((RATIO) == ETH_DMAARBITRATION_ROUNDROBIN_RXTX_3_1) || \
N                                                       ((RATIO) == ETH_DMAARBITRATION_ROUNDROBIN_RXTX_4_1) || \
N                                                       ((RATIO) == ETH_DMAARBITRATION_RXPRIORTX))
X#define IS_ETH_DMA_ARBITRATION_ROUNDROBIN_RXTX(RATIO) (((RATIO) == ETH_DMAARBITRATION_ROUNDROBIN_RXTX_1_1) ||                                                        ((RATIO) == ETH_DMAARBITRATION_ROUNDROBIN_RXTX_2_1) ||                                                        ((RATIO) == ETH_DMAARBITRATION_ROUNDROBIN_RXTX_3_1) ||                                                        ((RATIO) == ETH_DMAARBITRATION_ROUNDROBIN_RXTX_4_1) ||                                                        ((RATIO) == ETH_DMAARBITRATION_RXPRIORTX))
N#define IS_ETH_DMATXDESC_GET_FLAG(FLAG) (((FLAG) == ETH_DMATXDESC_OWN) || \
N                                         ((FLAG) == ETH_DMATXDESC_IC) || \
N                                         ((FLAG) == ETH_DMATXDESC_LS) || \
N                                         ((FLAG) == ETH_DMATXDESC_FS) || \
N                                         ((FLAG) == ETH_DMATXDESC_DC) || \
N                                         ((FLAG) == ETH_DMATXDESC_DP) || \
N                                         ((FLAG) == ETH_DMATXDESC_TTSE) || \
N                                         ((FLAG) == ETH_DMATXDESC_TER) || \
N                                         ((FLAG) == ETH_DMATXDESC_TCH) || \
N                                         ((FLAG) == ETH_DMATXDESC_TTSS) || \
N                                         ((FLAG) == ETH_DMATXDESC_IHE) || \
N                                         ((FLAG) == ETH_DMATXDESC_ES) || \
N                                         ((FLAG) == ETH_DMATXDESC_JT) || \
N                                         ((FLAG) == ETH_DMATXDESC_FF) || \
N                                         ((FLAG) == ETH_DMATXDESC_PCE) || \
N                                         ((FLAG) == ETH_DMATXDESC_LCA) || \
N                                         ((FLAG) == ETH_DMATXDESC_NC) || \
N                                         ((FLAG) == ETH_DMATXDESC_LCO) || \
N                                         ((FLAG) == ETH_DMATXDESC_EC) || \
N                                         ((FLAG) == ETH_DMATXDESC_VF) || \
N                                         ((FLAG) == ETH_DMATXDESC_CC) || \
N                                         ((FLAG) == ETH_DMATXDESC_ED) || \
N                                         ((FLAG) == ETH_DMATXDESC_UF) || \
N                                         ((FLAG) == ETH_DMATXDESC_DB))
X#define IS_ETH_DMATXDESC_GET_FLAG(FLAG) (((FLAG) == ETH_DMATXDESC_OWN) ||                                          ((FLAG) == ETH_DMATXDESC_IC) ||                                          ((FLAG) == ETH_DMATXDESC_LS) ||                                          ((FLAG) == ETH_DMATXDESC_FS) ||                                          ((FLAG) == ETH_DMATXDESC_DC) ||                                          ((FLAG) == ETH_DMATXDESC_DP) ||                                          ((FLAG) == ETH_DMATXDESC_TTSE) ||                                          ((FLAG) == ETH_DMATXDESC_TER) ||                                          ((FLAG) == ETH_DMATXDESC_TCH) ||                                          ((FLAG) == ETH_DMATXDESC_TTSS) ||                                          ((FLAG) == ETH_DMATXDESC_IHE) ||                                          ((FLAG) == ETH_DMATXDESC_ES) ||                                          ((FLAG) == ETH_DMATXDESC_JT) ||                                          ((FLAG) == ETH_DMATXDESC_FF) ||                                          ((FLAG) == ETH_DMATXDESC_PCE) ||                                          ((FLAG) == ETH_DMATXDESC_LCA) ||                                          ((FLAG) == ETH_DMATXDESC_NC) ||                                          ((FLAG) == ETH_DMATXDESC_LCO) ||                                          ((FLAG) == ETH_DMATXDESC_EC) ||                                          ((FLAG) == ETH_DMATXDESC_VF) ||                                          ((FLAG) == ETH_DMATXDESC_CC) ||                                          ((FLAG) == ETH_DMATXDESC_ED) ||                                          ((FLAG) == ETH_DMATXDESC_UF) ||                                          ((FLAG) == ETH_DMATXDESC_DB))
N#define IS_ETH_DMA_TXDESC_SEGMENT(SEGMENT) (((SEGMENT) == ETH_DMATXDESC_LASTSEGMENTS) || \
N                                            ((SEGMENT) == ETH_DMATXDESC_FIRSTSEGMENT))
X#define IS_ETH_DMA_TXDESC_SEGMENT(SEGMENT) (((SEGMENT) == ETH_DMATXDESC_LASTSEGMENTS) ||                                             ((SEGMENT) == ETH_DMATXDESC_FIRSTSEGMENT))
N#define IS_ETH_DMA_TXDESC_CHECKSUM(CHECKSUM) (((CHECKSUM) == ETH_DMATXDESC_CHECKSUMBYPASS) || \
N                                              ((CHECKSUM) == ETH_DMATXDESC_CHECKSUMIPV4HEADER) || \
N                                              ((CHECKSUM) == ETH_DMATXDESC_CHECKSUMTCPUDPICMPSEGMENT) || \
N                                              ((CHECKSUM) == ETH_DMATXDESC_CHECKSUMTCPUDPICMPFULL))
X#define IS_ETH_DMA_TXDESC_CHECKSUM(CHECKSUM) (((CHECKSUM) == ETH_DMATXDESC_CHECKSUMBYPASS) ||                                               ((CHECKSUM) == ETH_DMATXDESC_CHECKSUMIPV4HEADER) ||                                               ((CHECKSUM) == ETH_DMATXDESC_CHECKSUMTCPUDPICMPSEGMENT) ||                                               ((CHECKSUM) == ETH_DMATXDESC_CHECKSUMTCPUDPICMPFULL))
N#define IS_ETH_DMATXDESC_BUFFER_SIZE(SIZE) ((SIZE) <= 0x1FFF)
N#define IS_ETH_DMARXDESC_GET_FLAG(FLAG) (((FLAG) == ETH_DMARXDESC_OWN) || \
N                                         ((FLAG) == ETH_DMARXDESC_AFM) || \
N                                         ((FLAG) == ETH_DMARXDESC_ES) || \
N                                         ((FLAG) == ETH_DMARXDESC_DE) || \
N                                         ((FLAG) == ETH_DMARXDESC_SAF) || \
N                                         ((FLAG) == ETH_DMARXDESC_LE) || \
N                                         ((FLAG) == ETH_DMARXDESC_OE) || \
N                                         ((FLAG) == ETH_DMARXDESC_VLAN) || \
N                                         ((FLAG) == ETH_DMARXDESC_FS) || \
N                                         ((FLAG) == ETH_DMARXDESC_LS) || \
N                                         ((FLAG) == ETH_DMARXDESC_IPV4HCE) || \
N                                         ((FLAG) == ETH_DMARXDESC_LC) || \
N                                         ((FLAG) == ETH_DMARXDESC_FT) || \
N                                         ((FLAG) == ETH_DMARXDESC_RWT) || \
N                                         ((FLAG) == ETH_DMARXDESC_RE) || \
N                                         ((FLAG) == ETH_DMARXDESC_DBE) || \
N                                         ((FLAG) == ETH_DMARXDESC_CE) || \
N                                         ((FLAG) == ETH_DMARXDESC_MAMPCE))
X#define IS_ETH_DMARXDESC_GET_FLAG(FLAG) (((FLAG) == ETH_DMARXDESC_OWN) ||                                          ((FLAG) == ETH_DMARXDESC_AFM) ||                                          ((FLAG) == ETH_DMARXDESC_ES) ||                                          ((FLAG) == ETH_DMARXDESC_DE) ||                                          ((FLAG) == ETH_DMARXDESC_SAF) ||                                          ((FLAG) == ETH_DMARXDESC_LE) ||                                          ((FLAG) == ETH_DMARXDESC_OE) ||                                          ((FLAG) == ETH_DMARXDESC_VLAN) ||                                          ((FLAG) == ETH_DMARXDESC_FS) ||                                          ((FLAG) == ETH_DMARXDESC_LS) ||                                          ((FLAG) == ETH_DMARXDESC_IPV4HCE) ||                                          ((FLAG) == ETH_DMARXDESC_LC) ||                                          ((FLAG) == ETH_DMARXDESC_FT) ||                                          ((FLAG) == ETH_DMARXDESC_RWT) ||                                          ((FLAG) == ETH_DMARXDESC_RE) ||                                          ((FLAG) == ETH_DMARXDESC_DBE) ||                                          ((FLAG) == ETH_DMARXDESC_CE) ||                                          ((FLAG) == ETH_DMARXDESC_MAMPCE))
N#define IS_ETH_DMA_RXDESC_BUFFER(BUFFER) (((BUFFER) == ETH_DMARXDESC_BUFFER1) || \
N                                          ((BUFFER) == ETH_DMARXDESC_BUFFER2))
X#define IS_ETH_DMA_RXDESC_BUFFER(BUFFER) (((BUFFER) == ETH_DMARXDESC_BUFFER1) ||                                           ((BUFFER) == ETH_DMARXDESC_BUFFER2))
N#define IS_ETH_PMT_GET_FLAG(FLAG) (((FLAG) == ETH_PMT_FLAG_WUFR) || \
N                                   ((FLAG) == ETH_PMT_FLAG_MPR))
X#define IS_ETH_PMT_GET_FLAG(FLAG) (((FLAG) == ETH_PMT_FLAG_WUFR) ||                                    ((FLAG) == ETH_PMT_FLAG_MPR))
N#define IS_ETH_DMA_FLAG(FLAG) ((((FLAG) & (uint32_t)0xC7FE1800) == 0x00) && ((FLAG) != 0x00)) 
N#define IS_ETH_DMA_GET_FLAG(FLAG) (((FLAG) == ETH_DMA_FLAG_TST) || ((FLAG) == ETH_DMA_FLAG_PMT) || \
N                                   ((FLAG) == ETH_DMA_FLAG_MMC) || ((FLAG) == ETH_DMA_FLAG_DATATRANSFERERROR) || \
N                                   ((FLAG) == ETH_DMA_FLAG_READWRITEERROR) || ((FLAG) == ETH_DMA_FLAG_ACCESSERROR) || \
N                                   ((FLAG) == ETH_DMA_FLAG_NIS) || ((FLAG) == ETH_DMA_FLAG_AIS) || \
N                                   ((FLAG) == ETH_DMA_FLAG_ER) || ((FLAG) == ETH_DMA_FLAG_FBE) || \
N                                   ((FLAG) == ETH_DMA_FLAG_ET) || ((FLAG) == ETH_DMA_FLAG_RWT) || \
N                                   ((FLAG) == ETH_DMA_FLAG_RPS) || ((FLAG) == ETH_DMA_FLAG_RBU) || \
N                                   ((FLAG) == ETH_DMA_FLAG_R) || ((FLAG) == ETH_DMA_FLAG_TU) || \
N                                   ((FLAG) == ETH_DMA_FLAG_RO) || ((FLAG) == ETH_DMA_FLAG_TJT) || \
N                                   ((FLAG) == ETH_DMA_FLAG_TBU) || ((FLAG) == ETH_DMA_FLAG_TPS) || \
N                                   ((FLAG) == ETH_DMA_FLAG_T))
X#define IS_ETH_DMA_GET_FLAG(FLAG) (((FLAG) == ETH_DMA_FLAG_TST) || ((FLAG) == ETH_DMA_FLAG_PMT) ||                                    ((FLAG) == ETH_DMA_FLAG_MMC) || ((FLAG) == ETH_DMA_FLAG_DATATRANSFERERROR) ||                                    ((FLAG) == ETH_DMA_FLAG_READWRITEERROR) || ((FLAG) == ETH_DMA_FLAG_ACCESSERROR) ||                                    ((FLAG) == ETH_DMA_FLAG_NIS) || ((FLAG) == ETH_DMA_FLAG_AIS) ||                                    ((FLAG) == ETH_DMA_FLAG_ER) || ((FLAG) == ETH_DMA_FLAG_FBE) ||                                    ((FLAG) == ETH_DMA_FLAG_ET) || ((FLAG) == ETH_DMA_FLAG_RWT) ||                                    ((FLAG) == ETH_DMA_FLAG_RPS) || ((FLAG) == ETH_DMA_FLAG_RBU) ||                                    ((FLAG) == ETH_DMA_FLAG_R) || ((FLAG) == ETH_DMA_FLAG_TU) ||                                    ((FLAG) == ETH_DMA_FLAG_RO) || ((FLAG) == ETH_DMA_FLAG_TJT) ||                                    ((FLAG) == ETH_DMA_FLAG_TBU) || ((FLAG) == ETH_DMA_FLAG_TPS) ||                                    ((FLAG) == ETH_DMA_FLAG_T))
N#define IS_ETH_MAC_IT(IT) ((((IT) & (uint32_t)0xFFFFFDF1) == 0x00) && ((IT) != 0x00))
N#define IS_ETH_MAC_GET_IT(IT) (((IT) == ETH_MAC_IT_TST) || ((IT) == ETH_MAC_IT_MMCT) || \
N                               ((IT) == ETH_MAC_IT_MMCR) || ((IT) == ETH_MAC_IT_MMC) || \
N                               ((IT) == ETH_MAC_IT_PMT))
X#define IS_ETH_MAC_GET_IT(IT) (((IT) == ETH_MAC_IT_TST) || ((IT) == ETH_MAC_IT_MMCT) ||                                ((IT) == ETH_MAC_IT_MMCR) || ((IT) == ETH_MAC_IT_MMC) ||                                ((IT) == ETH_MAC_IT_PMT))
N#define IS_ETH_MAC_GET_FLAG(FLAG) (((FLAG) == ETH_MAC_FLAG_TST) || ((FLAG) == ETH_MAC_FLAG_MMCT) || \
N                                   ((FLAG) == ETH_MAC_FLAG_MMCR) || ((FLAG) == ETH_MAC_FLAG_MMC) || \
N                                   ((FLAG) == ETH_MAC_FLAG_PMT))
X#define IS_ETH_MAC_GET_FLAG(FLAG) (((FLAG) == ETH_MAC_FLAG_TST) || ((FLAG) == ETH_MAC_FLAG_MMCT) ||                                    ((FLAG) == ETH_MAC_FLAG_MMCR) || ((FLAG) == ETH_MAC_FLAG_MMC) ||                                    ((FLAG) == ETH_MAC_FLAG_PMT))
N#define IS_ETH_DMA_IT(IT) ((((IT) & (uint32_t)0xC7FE1800) == 0x00) && ((IT) != 0x00))
N#define IS_ETH_DMA_GET_IT(IT) (((IT) == ETH_DMA_IT_TST) || ((IT) == ETH_DMA_IT_PMT) || \
N                               ((IT) == ETH_DMA_IT_MMC) || ((IT) == ETH_DMA_IT_NIS) || \
N                               ((IT) == ETH_DMA_IT_AIS) || ((IT) == ETH_DMA_IT_ER) || \
N                               ((IT) == ETH_DMA_IT_FBE) || ((IT) == ETH_DMA_IT_ET) || \
N                               ((IT) == ETH_DMA_IT_RWT) || ((IT) == ETH_DMA_IT_RPS) || \
N                               ((IT) == ETH_DMA_IT_RBU) || ((IT) == ETH_DMA_IT_R) || \
N                               ((IT) == ETH_DMA_IT_TU) || ((IT) == ETH_DMA_IT_RO) || \
N                               ((IT) == ETH_DMA_IT_TJT) || ((IT) == ETH_DMA_IT_TBU) || \
N                               ((IT) == ETH_DMA_IT_TPS) || ((IT) == ETH_DMA_IT_T))
X#define IS_ETH_DMA_GET_IT(IT) (((IT) == ETH_DMA_IT_TST) || ((IT) == ETH_DMA_IT_PMT) ||                                ((IT) == ETH_DMA_IT_MMC) || ((IT) == ETH_DMA_IT_NIS) ||                                ((IT) == ETH_DMA_IT_AIS) || ((IT) == ETH_DMA_IT_ER) ||                                ((IT) == ETH_DMA_IT_FBE) || ((IT) == ETH_DMA_IT_ET) ||                                ((IT) == ETH_DMA_IT_RWT) || ((IT) == ETH_DMA_IT_RPS) ||                                ((IT) == ETH_DMA_IT_RBU) || ((IT) == ETH_DMA_IT_R) ||                                ((IT) == ETH_DMA_IT_TU) || ((IT) == ETH_DMA_IT_RO) ||                                ((IT) == ETH_DMA_IT_TJT) || ((IT) == ETH_DMA_IT_TBU) ||                                ((IT) == ETH_DMA_IT_TPS) || ((IT) == ETH_DMA_IT_T))
N#define IS_ETH_DMA_GET_OVERFLOW(OVERFLOW) (((OVERFLOW) == ETH_DMA_OVERFLOW_RXFIFOCOUNTER) || \
N                                           ((OVERFLOW) == ETH_DMA_OVERFLOW_MISSEDFRAMECOUNTER))
X#define IS_ETH_DMA_GET_OVERFLOW(OVERFLOW) (((OVERFLOW) == ETH_DMA_OVERFLOW_RXFIFOCOUNTER) ||                                            ((OVERFLOW) == ETH_DMA_OVERFLOW_MISSEDFRAMECOUNTER))
N#define IS_ETH_MMC_IT(IT) (((((IT) & (uint32_t)0xFFDF3FFF) == 0x00) || (((IT) & (uint32_t)0xEFFDFF9F) == 0x00)) && \
N                           ((IT) != 0x00))
X#define IS_ETH_MMC_IT(IT) (((((IT) & (uint32_t)0xFFDF3FFF) == 0x00) || (((IT) & (uint32_t)0xEFFDFF9F) == 0x00)) &&                            ((IT) != 0x00))
N#define IS_ETH_MMC_GET_IT(IT) (((IT) == ETH_MMC_IT_TGF) || ((IT) == ETH_MMC_IT_TGFMSC) || \
N                               ((IT) == ETH_MMC_IT_TGFSC) || ((IT) == ETH_MMC_IT_RGUF) || \
N                               ((IT) == ETH_MMC_IT_RFAE) || ((IT) == ETH_MMC_IT_RFCE))
X#define IS_ETH_MMC_GET_IT(IT) (((IT) == ETH_MMC_IT_TGF) || ((IT) == ETH_MMC_IT_TGFMSC) ||                                ((IT) == ETH_MMC_IT_TGFSC) || ((IT) == ETH_MMC_IT_RGUF) ||                                ((IT) == ETH_MMC_IT_RFAE) || ((IT) == ETH_MMC_IT_RFCE))
N#define IS_ETH_ENHANCED_DESCRIPTOR_FORMAT(CMD) (((CMD) == ETH_DMAENHANCEDDESCRIPTOR_ENABLE) || \
N                                                ((CMD) == ETH_DMAENHANCEDDESCRIPTOR_DISABLE))
X#define IS_ETH_ENHANCED_DESCRIPTOR_FORMAT(CMD) (((CMD) == ETH_DMAENHANCEDDESCRIPTOR_ENABLE) ||                                                 ((CMD) == ETH_DMAENHANCEDDESCRIPTOR_DISABLE))
N
N
N/**
N  * @}
N  */
N
N/** @addtogroup ETH_Private_Defines
N  * @{
N  */
N/* Delay to wait when writing to some Ethernet registers */
N#define ETH_REG_WRITE_DELAY ((uint32_t)0x00000001U)
N
N/* Ethernet Errors */
N#define  ETH_SUCCESS            ((uint32_t)0U)
N#define  ETH_ERROR              ((uint32_t)1U)
N
N/* Ethernet DMA Tx descriptors Collision Count Shift */
N#define  ETH_DMATXDESC_COLLISION_COUNTSHIFT         ((uint32_t)3U)
N
N/* Ethernet DMA Tx descriptors Buffer2 Size Shift */
N#define  ETH_DMATXDESC_BUFFER2_SIZESHIFT           ((uint32_t)16U)
N
N/* Ethernet DMA Rx descriptors Frame Length Shift */
N#define  ETH_DMARXDESC_FRAME_LENGTHSHIFT           ((uint32_t)16U)
N
N/* Ethernet DMA Rx descriptors Buffer2 Size Shift */
N#define  ETH_DMARXDESC_BUFFER2_SIZESHIFT           ((uint32_t)16U)
N
N/* Ethernet DMA Rx descriptors Frame length Shift */
N#define  ETH_DMARXDESC_FRAMELENGTHSHIFT            ((uint32_t)16)
N
N/* Ethernet MAC address offsets */
N#define ETH_MAC_ADDR_HBASE    (uint32_t)(ETH_MAC_BASE + (uint32_t)0x40U)  /* Ethernet MAC address high offset */
N#define ETH_MAC_ADDR_LBASE    (uint32_t)(ETH_MAC_BASE + (uint32_t)0x44U)  /* Ethernet MAC address low offset */
N
N/* Ethernet MACMIIAR register Mask */
N#define ETH_MACMIIAR_CR_MASK    ((uint32_t)0xFFFFFFE3U)
N
N/* Ethernet MACCR register Mask */
N#define ETH_MACCR_CLEAR_MASK    ((uint32_t)0xFF20810FU)  
N
N/* Ethernet MACFCR register Mask */
N#define ETH_MACFCR_CLEAR_MASK   ((uint32_t)0x0000FF41U)
N
N/* Ethernet DMAOMR register Mask */
N#define ETH_DMAOMR_CLEAR_MASK   ((uint32_t)0xF8DE3F23U)
N
N/* Ethernet Remote Wake-up frame register length */
N#define ETH_WAKEUP_REGISTER_LENGTH      8U
N
N/* Ethernet Missed frames counter Shift */
N#define  ETH_DMA_RX_OVERFLOW_MISSEDFRAMES_COUNTERSHIFT     17U
N /**
N  * @}
N  */
N
N/* Exported types ------------------------------------------------------------*/ 
N/** @defgroup ETH_Exported_Types ETH Exported Types
N  * @{
N  */
N
N/** 
N  * @brief  HAL State structures definition  
N  */ 
Ntypedef enum
N{
N  HAL_ETH_STATE_RESET             = 0x00U,    /*!< Peripheral not yet Initialized or disabled         */
N  HAL_ETH_STATE_READY             = 0x01U,    /*!< Peripheral Initialized and ready for use           */
N  HAL_ETH_STATE_BUSY              = 0x02U,    /*!< an internal process is ongoing                     */
N  HAL_ETH_STATE_BUSY_TX           = 0x12U,    /*!< Data Transmission process is ongoing               */
N  HAL_ETH_STATE_BUSY_RX           = 0x22U,    /*!< Data Reception process is ongoing                  */
N  HAL_ETH_STATE_BUSY_TX_RX        = 0x32U,    /*!< Data Transmission and Reception process is ongoing */
N  HAL_ETH_STATE_BUSY_WR           = 0x42U,    /*!< Write process is ongoing                           */
N  HAL_ETH_STATE_BUSY_RD           = 0x82U,    /*!< Read process is ongoing                            */
N  HAL_ETH_STATE_TIMEOUT           = 0x03U,    /*!< Timeout state                                      */
N  HAL_ETH_STATE_ERROR             = 0x04U     /*!< Reception process is ongoing                       */
N}HAL_ETH_StateTypeDef;
N
N/** 
N  * @brief  ETH Init Structure definition  
N  */
N
Ntypedef struct
N{
N  uint32_t             AutoNegotiation;           /*!< Selects or not the AutoNegotiation mode for the external PHY
N                                                           The AutoNegotiation allows an automatic setting of the Speed (10/100Mbps)
N                                                           and the mode (half/full-duplex).
N                                                           This parameter can be a value of @ref ETH_AutoNegotiation */
N
N  uint32_t             Speed;                     /*!< Sets the Ethernet speed: 10/100 Mbps.
N                                                           This parameter can be a value of @ref ETH_Speed */
N
N  uint32_t             DuplexMode;                /*!< Selects the MAC duplex mode: Half-Duplex or Full-Duplex mode
N                                                           This parameter can be a value of @ref ETH_Duplex_Mode */
N  
N  uint16_t             PhyAddress;                /*!< Ethernet PHY address.
N                                                           This parameter must be a number between Min_Data = 0 and Max_Data = 32 */
N  
N  uint8_t             *MACAddr;                   /*!< MAC Address of used Hardware: must be pointer on an array of 6 bytes */
N  
N  uint32_t             RxMode;                    /*!< Selects the Ethernet Rx mode: Polling mode, Interrupt mode.
N                                                           This parameter can be a value of @ref ETH_Rx_Mode */
N  
N  uint32_t             ChecksumMode;              /*!< Selects if the checksum is check by hardware or by software. 
N                                                         This parameter can be a value of @ref ETH_Checksum_Mode */
N  
N  uint32_t             MediaInterface    ;               /*!< Selects the media-independent interface or the reduced media-independent interface. 
N                                                         This parameter can be a value of @ref ETH_Media_Interface */
N
N} ETH_InitTypeDef;
N
N
N /** 
N  * @brief  ETH MAC Configuration Structure definition  
N  */
N
Ntypedef struct
N{
N  uint32_t             Watchdog;                  /*!< Selects or not the Watchdog timer
N                                                           When enabled, the MAC allows no more then 2048 bytes to be received.
N                                                           When disabled, the MAC can receive up to 16384 bytes.
N                                                           This parameter can be a value of @ref ETH_Watchdog */  
N
N  uint32_t             Jabber;                    /*!< Selects or not Jabber timer
N                                                           When enabled, the MAC allows no more then 2048 bytes to be sent.
N                                                           When disabled, the MAC can send up to 16384 bytes.
N                                                           This parameter can be a value of @ref ETH_Jabber */
N
N  uint32_t             InterFrameGap;             /*!< Selects the minimum IFG between frames during transmission.
N                                                           This parameter can be a value of @ref ETH_Inter_Frame_Gap */   
N
N  uint32_t             CarrierSense;              /*!< Selects or not the Carrier Sense.
N                                                           This parameter can be a value of @ref ETH_Carrier_Sense */
N
N  uint32_t             ReceiveOwn;                /*!< Selects or not the ReceiveOwn,
N                                                           ReceiveOwn allows the reception of frames when the TX_EN signal is asserted
N                                                           in Half-Duplex mode.
N                                                           This parameter can be a value of @ref ETH_Receive_Own */  
N
N  uint32_t             LoopbackMode;              /*!< Selects or not the internal MAC MII Loopback mode.
N                                                           This parameter can be a value of @ref ETH_Loop_Back_Mode */  
N
N  uint32_t             ChecksumOffload;           /*!< Selects or not the IPv4 checksum checking for received frame payloads' TCP/UDP/ICMP headers.
N                                                           This parameter can be a value of @ref ETH_Checksum_Offload */    
N
N  uint32_t             RetryTransmission;         /*!< Selects or not the MAC attempt retries transmission, based on the settings of BL,
N                                                           when a collision occurs (Half-Duplex mode).
N                                                           This parameter can be a value of @ref ETH_Retry_Transmission */
N
N  uint32_t             AutomaticPadCRCStrip;      /*!< Selects or not the Automatic MAC Pad/CRC Stripping.
N                                                           This parameter can be a value of @ref ETH_Automatic_Pad_CRC_Strip */ 
N
N  uint32_t             BackOffLimit;              /*!< Selects the BackOff limit value.
N                                                           This parameter can be a value of @ref ETH_Back_Off_Limit */
N
N  uint32_t             DeferralCheck;             /*!< Selects or not the deferral check function (Half-Duplex mode).
N                                                           This parameter can be a value of @ref ETH_Deferral_Check */                                                                                                        
N
N  uint32_t             ReceiveAll;                /*!< Selects or not all frames reception by the MAC (No filtering).
N                                                           This parameter can be a value of @ref ETH_Receive_All */   
N
N  uint32_t             SourceAddrFilter;          /*!< Selects the Source Address Filter mode.                                                           
N                                                           This parameter can be a value of @ref ETH_Source_Addr_Filter */                  
N
N  uint32_t             PassControlFrames;         /*!< Sets the forwarding mode of the control frames (including unicast and multicast PAUSE frames)                                                          
N                                                           This parameter can be a value of @ref ETH_Pass_Control_Frames */ 
N
N  uint32_t             BroadcastFramesReception;  /*!< Selects or not the reception of Broadcast Frames.
N                                                           This parameter can be a value of @ref ETH_Broadcast_Frames_Reception */
N
N  uint32_t             DestinationAddrFilter;     /*!< Sets the destination filter mode for both unicast and multicast frames.
N                                                           This parameter can be a value of @ref ETH_Destination_Addr_Filter */ 
N
N  uint32_t             PromiscuousMode;           /*!< Selects or not the Promiscuous Mode
N                                                           This parameter can be a value of @ref ETH_Promiscuous_Mode */
N
N  uint32_t             MulticastFramesFilter;     /*!< Selects the Multicast Frames filter mode: None/HashTableFilter/PerfectFilter/PerfectHashTableFilter.
N                                                           This parameter can be a value of @ref ETH_Multicast_Frames_Filter */ 
N
N  uint32_t             UnicastFramesFilter;       /*!< Selects the Unicast Frames filter mode: HashTableFilter/PerfectFilter/PerfectHashTableFilter.
N                                                           This parameter can be a value of @ref ETH_Unicast_Frames_Filter */ 
N
N  uint32_t             HashTableHigh;             /*!< This field holds the higher 32 bits of Hash table.
N                                                           This parameter must be a number between Min_Data = 0x0 and Max_Data = 0xFFFFFFFF */
N
N  uint32_t             HashTableLow;              /*!< This field holds the lower 32 bits of Hash table.
N                                                           This parameter must be a number between Min_Data = 0x0 and Max_Data = 0xFFFFFFFF  */    
N
N  uint32_t             PauseTime;                 /*!< This field holds the value to be used in the Pause Time field in the transmit control frame. 
N                                                           This parameter must be a number between Min_Data = 0x0 and Max_Data = 0xFFFF */
N
N  uint32_t             ZeroQuantaPause;           /*!< Selects or not the automatic generation of Zero-Quanta Pause Control frames.
N                                                           This parameter can be a value of @ref ETH_Zero_Quanta_Pause */  
N
N  uint32_t             PauseLowThreshold;         /*!< This field configures the threshold of the PAUSE to be checked for
N                                                           automatic retransmission of PAUSE Frame.
N                                                           This parameter can be a value of @ref ETH_Pause_Low_Threshold */
N                                                           
N  uint32_t             UnicastPauseFrameDetect;   /*!< Selects or not the MAC detection of the Pause frames (with MAC Address0
N                                                           unicast address and unique multicast address).
N                                                           This parameter can be a value of @ref ETH_Unicast_Pause_Frame_Detect */  
N
N  uint32_t             ReceiveFlowControl;        /*!< Enables or disables the MAC to decode the received Pause frame and
N                                                           disable its transmitter for a specified time (Pause Time)
N                                                           This parameter can be a value of @ref ETH_Receive_Flow_Control */
N
N  uint32_t             TransmitFlowControl;       /*!< Enables or disables the MAC to transmit Pause frames (Full-Duplex mode)
N                                                           or the MAC back-pressure operation (Half-Duplex mode)
N                                                           This parameter can be a value of @ref ETH_Transmit_Flow_Control */     
N
N  uint32_t             VLANTagComparison;         /*!< Selects the 12-bit VLAN identifier or the complete 16-bit VLAN tag for
N                                                           comparison and filtering.
N                                                           This parameter can be a value of @ref ETH_VLAN_Tag_Comparison */ 
N
N  uint32_t             VLANTagIdentifier;         /*!< Holds the VLAN tag identifier for receive frames */
N
N} ETH_MACInitTypeDef;
N
N
N/** 
N  * @brief  ETH DMA Configuration Structure definition  
N  */
N
Ntypedef struct
N{
N uint32_t              DropTCPIPChecksumErrorFrame; /*!< Selects or not the Dropping of TCP/IP Checksum Error Frames.
N                                                             This parameter can be a value of @ref ETH_Drop_TCP_IP_Checksum_Error_Frame */ 
N
N  uint32_t             ReceiveStoreForward;         /*!< Enables or disables the Receive store and forward mode.
N                                                             This parameter can be a value of @ref ETH_Receive_Store_Forward */ 
N
N  uint32_t             FlushReceivedFrame;          /*!< Enables or disables the flushing of received frames.
N                                                             This parameter can be a value of @ref ETH_Flush_Received_Frame */ 
N
N  uint32_t             TransmitStoreForward;        /*!< Enables or disables Transmit store and forward mode.
N                                                             This parameter can be a value of @ref ETH_Transmit_Store_Forward */ 
N
N  uint32_t             TransmitThresholdControl;    /*!< Selects or not the Transmit Threshold Control.
N                                                             This parameter can be a value of @ref ETH_Transmit_Threshold_Control */
N
N  uint32_t             ForwardErrorFrames;          /*!< Selects or not the forward to the DMA of erroneous frames.
N                                                             This parameter can be a value of @ref ETH_Forward_Error_Frames */
N
N  uint32_t             ForwardUndersizedGoodFrames; /*!< Enables or disables the Rx FIFO to forward Undersized frames (frames with no Error
N                                                             and length less than 64 bytes) including pad-bytes and CRC)
N                                                             This parameter can be a value of @ref ETH_Forward_Undersized_Good_Frames */
N
N  uint32_t             ReceiveThresholdControl;     /*!< Selects the threshold level of the Receive FIFO.
N                                                             This parameter can be a value of @ref ETH_Receive_Threshold_Control */
N
N  uint32_t             SecondFrameOperate;          /*!< Selects or not the Operate on second frame mode, which allows the DMA to process a second
N                                                             frame of Transmit data even before obtaining the status for the first frame.
N                                                             This parameter can be a value of @ref ETH_Second_Frame_Operate */
N
N  uint32_t             AddressAlignedBeats;         /*!< Enables or disables the Address Aligned Beats.
N                                                             This parameter can be a value of @ref ETH_Address_Aligned_Beats */
N
N  uint32_t             FixedBurst;                  /*!< Enables or disables the AHB Master interface fixed burst transfers.
N                                                             This parameter can be a value of @ref ETH_Fixed_Burst */
N                       
N  uint32_t             RxDMABurstLength;            /*!< Indicates the maximum number of beats to be transferred in one Rx DMA transaction.
N                                                             This parameter can be a value of @ref ETH_Rx_DMA_Burst_Length */ 
N
N  uint32_t             TxDMABurstLength;            /*!< Indicates the maximum number of beats to be transferred in one Tx DMA transaction.
N                                                             This parameter can be a value of @ref ETH_Tx_DMA_Burst_Length */
N  
N  uint32_t             EnhancedDescriptorFormat;    /*!< Enables the enhanced descriptor format.
N                                                             This parameter can be a value of @ref ETH_DMA_Enhanced_descriptor_format */
N
N  uint32_t             DescriptorSkipLength;        /*!< Specifies the number of word to skip between two unchained descriptors (Ring mode)
N                                                             This parameter must be a number between Min_Data = 0 and Max_Data = 32 */                                                             
N
N  uint32_t             DMAArbitration;              /*!< Selects the DMA Tx/Rx arbitration.
N                                                             This parameter can be a value of @ref ETH_DMA_Arbitration */  
N} ETH_DMAInitTypeDef;
N
N
N/** 
N  * @brief  ETH DMA Descriptors data structure definition
N  */ 
N
Ntypedef struct  
N{
N  __IO uint32_t   Status;           /*!< Status */
X  volatile uint32_t   Status;            
N  
N  uint32_t   ControlBufferSize;     /*!< Control and Buffer1, Buffer2 lengths */
N  
N  uint32_t   Buffer1Addr;           /*!< Buffer1 address pointer */
N  
N  uint32_t   Buffer2NextDescAddr;   /*!< Buffer2 or next descriptor address pointer */
N  
N  /*!< Enhanced Ethernet DMA PTP Descriptors */
N  uint32_t   ExtendedStatus;        /*!< Extended status for PTP receive descriptor */
N  
N  uint32_t   Reserved1;             /*!< Reserved */
N  
N  uint32_t   TimeStampLow;          /*!< Time Stamp Low value for transmit and receive */
N  
N  uint32_t   TimeStampHigh;         /*!< Time Stamp High value for transmit and receive */
N
N} ETH_DMADescTypeDef;
N
N
N/** 
N  * @brief  Received Frame Informations structure definition
N  */ 
Ntypedef struct  
N{
N  ETH_DMADescTypeDef *FSRxDesc;          /*!< First Segment Rx Desc */
N  
N  ETH_DMADescTypeDef *LSRxDesc;          /*!< Last Segment Rx Desc */
N  
N  uint32_t  SegCount;                    /*!< Segment count */
N  
N  uint32_t length;                       /*!< Frame length */
N  
N  uint32_t buffer;                       /*!< Frame buffer */
N
N} ETH_DMARxFrameInfos;
N
N
N/** 
N  * @brief  ETH Handle Structure definition  
N  */
N  
Ntypedef struct
N{
N  ETH_TypeDef                *Instance;     /*!< Register base address       */
N  
N  ETH_InitTypeDef            Init;          /*!< Ethernet Init Configuration */
N  
N  uint32_t                   LinkStatus;    /*!< Ethernet link status        */
N  
N  ETH_DMADescTypeDef         *RxDesc;       /*!< Rx descriptor to Get        */
N  
N  ETH_DMADescTypeDef         *TxDesc;       /*!< Tx descriptor to Set        */
N  
N  ETH_DMARxFrameInfos        RxFrameInfos;  /*!< last Rx frame infos         */
N  
N  __IO HAL_ETH_StateTypeDef  State;         /*!< ETH communication state     */
X  volatile HAL_ETH_StateTypeDef  State;          
N  
N  HAL_LockTypeDef            Lock;          /*!< ETH Lock                    */
N
N} ETH_HandleTypeDef;
N
N /**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup ETH_Exported_Constants ETH Exported Constants
N  * @{
N  */
N
N/** @defgroup ETH_Buffers_setting ETH Buffers setting
N  * @{
N  */ 
N#define ETH_MAX_PACKET_SIZE    ((uint32_t)1524U)    /*!< ETH_HEADER + ETH_EXTRA + ETH_VLAN_TAG + ETH_MAX_ETH_PAYLOAD + ETH_CRC */
N#define ETH_HEADER               ((uint32_t)14U)    /*!< 6 byte Dest addr, 6 byte Src addr, 2 byte length/type */
N#define ETH_CRC                   ((uint32_t)4U)    /*!< Ethernet CRC */
N#define ETH_EXTRA                 ((uint32_t)2U)    /*!< Extra bytes in some cases */   
N#define ETH_VLAN_TAG              ((uint32_t)4U)    /*!< optional 802.1q VLAN Tag */
N#define ETH_MIN_ETH_PAYLOAD       ((uint32_t)46U)    /*!< Minimum Ethernet payload size */
N#define ETH_MAX_ETH_PAYLOAD       ((uint32_t)1500U)    /*!< Maximum Ethernet payload size */
N#define ETH_JUMBO_FRAME_PAYLOAD   ((uint32_t)9000U)    /*!< Jumbo frame payload size */      
N
N /* Ethernet driver receive buffers are organized in a chained linked-list, when
N    an Ethernet packet is received, the Rx-DMA will transfer the packet from RxFIFO
N    to the driver receive buffers memory.
N
N    Depending on the size of the received Ethernet packet and the size of 
N    each Ethernet driver receive buffer, the received packet can take one or more
N    Ethernet driver receive buffer. 
N
N    In below are defined the size of one Ethernet driver receive buffer ETH_RX_BUF_SIZE 
N    and the total count of the driver receive buffers ETH_RXBUFNB.
N
N    The configured value for ETH_RX_BUF_SIZE and ETH_RXBUFNB are only provided as 
N    example, they can be reconfigured in the application layer to fit the application 
N    needs */ 
N
N/* Here we configure each Ethernet driver receive buffer to fit the Max size Ethernet
N   packet */
N#ifndef ETH_RX_BUF_SIZE
S #define ETH_RX_BUF_SIZE         ETH_MAX_PACKET_SIZE 
N#endif
N
N/* 5 Ethernet driver receive buffers are used (in a chained linked list)*/ 
N#ifndef ETH_RXBUFNB
S #define ETH_RXBUFNB             ((uint32_t)5U     /*  5 Rx buffers of size ETH_RX_BUF_SIZE */
N#endif
N
N
N /* Ethernet driver transmit buffers are organized in a chained linked-list, when
N    an Ethernet packet is transmitted, Tx-DMA will transfer the packet from the 
N    driver transmit buffers memory to the TxFIFO.
N
N    Depending on the size of the Ethernet packet to be transmitted and the size of 
N    each Ethernet driver transmit buffer, the packet to be transmitted can take 
N    one or more Ethernet driver transmit buffer. 
N
N    In below are defined the size of one Ethernet driver transmit buffer ETH_TX_BUF_SIZE 
N    and the total count of the driver transmit buffers ETH_TXBUFNB.
N
N    The configured value for ETH_TX_BUF_SIZE and ETH_TXBUFNB are only provided as 
N    example, they can be reconfigured in the application layer to fit the application 
N    needs */ 
N
N/* Here we configure each Ethernet driver transmit buffer to fit the Max size Ethernet
N   packet */
N#ifndef ETH_TX_BUF_SIZE 
S #define ETH_TX_BUF_SIZE         ETH_MAX_PACKET_SIZE
N#endif
N
N/* 5 Ethernet driver transmit buffers are used (in a chained linked list)*/ 
N#ifndef ETH_TXBUFNB
S #define ETH_TXBUFNB             ((uint32_t)5U      /* 5  Tx buffers of size ETH_TX_BUF_SIZE */
N#endif
N
N /**
N  * @}
N  */
N
N/** @defgroup ETH_DMA_TX_Descriptor ETH DMA TX Descriptor
N  * @{
N  */
N
N/*
N   DMA Tx Descriptor
N  -----------------------------------------------------------------------------------------------
N  TDES0 | OWN(31) | CTRL[30:26] | Reserved[25:24] | CTRL[23:20] | Reserved[19:17] | Status[16:0] |
N  -----------------------------------------------------------------------------------------------
N  TDES1 | Reserved[31:29] | Buffer2 ByteCount[28:16] | Reserved[15:13] | Buffer1 ByteCount[12:0] |
N  -----------------------------------------------------------------------------------------------
N  TDES2 |                         Buffer1 Address [31:0]                                         |
N  -----------------------------------------------------------------------------------------------
N  TDES3 |                   Buffer2 Address [31:0] / Next Descriptor Address [31:0]              |
N  -----------------------------------------------------------------------------------------------
N*/
N
N/** 
N  * @brief  Bit definition of TDES0 register: DMA Tx descriptor status register
N  */ 
N#define ETH_DMATXDESC_OWN                     ((uint32_t)0x80000000U)  /*!< OWN bit: descriptor is owned by DMA engine */
N#define ETH_DMATXDESC_IC                      ((uint32_t)0x40000000U)  /*!< Interrupt on Completion */
N#define ETH_DMATXDESC_LS                      ((uint32_t)0x20000000U)  /*!< Last Segment */
N#define ETH_DMATXDESC_FS                      ((uint32_t)0x10000000U)  /*!< First Segment */
N#define ETH_DMATXDESC_DC                      ((uint32_t)0x08000000U)  /*!< Disable CRC */
N#define ETH_DMATXDESC_DP                      ((uint32_t)0x04000000U)  /*!< Disable Padding */
N#define ETH_DMATXDESC_TTSE                    ((uint32_t)0x02000000U)  /*!< Transmit Time Stamp Enable */
N#define ETH_DMATXDESC_CIC                     ((uint32_t)0x00C00000U)  /*!< Checksum Insertion Control: 4 cases */
N#define ETH_DMATXDESC_CIC_BYPASS              ((uint32_t)0x00000000U)  /*!< Do Nothing: Checksum Engine is bypassed */ 
N#define ETH_DMATXDESC_CIC_IPV4HEADER          ((uint32_t)0x00400000U)  /*!< IPV4 header Checksum Insertion */ 
N#define ETH_DMATXDESC_CIC_TCPUDPICMP_SEGMENT  ((uint32_t)0x00800000U)  /*!< TCP/UDP/ICMP Checksum Insertion calculated over segment only */ 
N#define ETH_DMATXDESC_CIC_TCPUDPICMP_FULL     ((uint32_t)0x00C00000U)  /*!< TCP/UDP/ICMP Checksum Insertion fully calculated */ 
N#define ETH_DMATXDESC_TER                     ((uint32_t)0x00200000U)  /*!< Transmit End of Ring */
N#define ETH_DMATXDESC_TCH                     ((uint32_t)0x00100000U)  /*!< Second Address Chained */
N#define ETH_DMATXDESC_TTSS                    ((uint32_t)0x00020000U)  /*!< Tx Time Stamp Status */
N#define ETH_DMATXDESC_IHE                     ((uint32_t)0x00010000U)  /*!< IP Header Error */
N#define ETH_DMATXDESC_ES                      ((uint32_t)0x00008000U)  /*!< Error summary: OR of the following bits: UE || ED || EC || LCO || NC || LCA || FF || JT */
N#define ETH_DMATXDESC_JT                      ((uint32_t)0x00004000U)  /*!< Jabber Timeout */
N#define ETH_DMATXDESC_FF                      ((uint32_t)0x00002000U)  /*!< Frame Flushed: DMA/MTL flushed the frame due to SW flush */
N#define ETH_DMATXDESC_PCE                     ((uint32_t)0x00001000U)  /*!< Payload Checksum Error */
N#define ETH_DMATXDESC_LCA                     ((uint32_t)0x00000800U)  /*!< Loss of Carrier: carrier lost during transmission */
N#define ETH_DMATXDESC_NC                      ((uint32_t)0x00000400U)  /*!< No Carrier: no carrier signal from the transceiver */
N#define ETH_DMATXDESC_LCO                     ((uint32_t)0x00000200U)  /*!< Late Collision: transmission aborted due to collision */
N#define ETH_DMATXDESC_EC                      ((uint32_t)0x00000100U)  /*!< Excessive Collision: transmission aborted after 16 collisions */
N#define ETH_DMATXDESC_VF                      ((uint32_t)0x00000080U)  /*!< VLAN Frame */
N#define ETH_DMATXDESC_CC                      ((uint32_t)0x00000078U)  /*!< Collision Count */
N#define ETH_DMATXDESC_ED                      ((uint32_t)0x00000004U)  /*!< Excessive Deferral */
N#define ETH_DMATXDESC_UF                      ((uint32_t)0x00000002U)  /*!< Underflow Error: late data arrival from the memory */
N#define ETH_DMATXDESC_DB                      ((uint32_t)0x00000001U)  /*!< Deferred Bit */
N
N/** 
N  * @brief  Bit definition of TDES1 register
N  */ 
N#define ETH_DMATXDESC_TBS2  ((uint32_t)0x1FFF0000U)  /*!< Transmit Buffer2 Size */
N#define ETH_DMATXDESC_TBS1  ((uint32_t)0x00001FFFU)  /*!< Transmit Buffer1 Size */
N
N/** 
N  * @brief  Bit definition of TDES2 register
N  */ 
N#define ETH_DMATXDESC_B1AP  ((uint32_t)0xFFFFFFFFU)  /*!< Buffer1 Address Pointer */
N
N/** 
N  * @brief  Bit definition of TDES3 register
N  */ 
N#define ETH_DMATXDESC_B2AP  ((uint32_t)0xFFFFFFFFU)  /*!< Buffer2 Address Pointer */
N
N  /*---------------------------------------------------------------------------------------------
N  TDES6 |                         Transmit Time Stamp Low [31:0]                                 |
N  -----------------------------------------------------------------------------------------------
N  TDES7 |                         Transmit Time Stamp High [31:0]                                |
N  ----------------------------------------------------------------------------------------------*/
N
N/* Bit definition of TDES6 register */
N #define ETH_DMAPTPTXDESC_TTSL  ((uint32_t)0xFFFFFFFFU)  /* Transmit Time Stamp Low */
N
N/* Bit definition of TDES7 register */
N #define ETH_DMAPTPTXDESC_TTSH  ((uint32_t)0xFFFFFFFFU)  /* Transmit Time Stamp High */
N
N/**
N  * @}
N  */ 
N/** @defgroup ETH_DMA_RX_Descriptor ETH DMA RX Descriptor
N  * @{
N  */
N
N/*
N  DMA Rx Descriptor
N  --------------------------------------------------------------------------------------------------------------------
N  RDES0 | OWN(31) |                                             Status [30:0]                                          |
N  ---------------------------------------------------------------------------------------------------------------------
N  RDES1 | CTRL(31) | Reserved[30:29] | Buffer2 ByteCount[28:16] | CTRL[15:14] | Reserved(13) | Buffer1 ByteCount[12:0] |
N  ---------------------------------------------------------------------------------------------------------------------
N  RDES2 |                                       Buffer1 Address [31:0]                                                 |
N  ---------------------------------------------------------------------------------------------------------------------
N  RDES3 |                          Buffer2 Address [31:0] / Next Descriptor Address [31:0]                             |
N  ---------------------------------------------------------------------------------------------------------------------
N*/
N
N/** 
N  * @brief  Bit definition of RDES0 register: DMA Rx descriptor status register
N  */ 
N#define ETH_DMARXDESC_OWN         ((uint32_t)0x80000000U)  /*!< OWN bit: descriptor is owned by DMA engine  */
N#define ETH_DMARXDESC_AFM         ((uint32_t)0x40000000U)  /*!< DA Filter Fail for the rx frame  */
N#define ETH_DMARXDESC_FL          ((uint32_t)0x3FFF0000U)  /*!< Receive descriptor frame length  */
N#define ETH_DMARXDESC_ES          ((uint32_t)0x00008000U)  /*!< Error summary: OR of the following bits: DE || OE || IPC || LC || RWT || RE || CE */
N#define ETH_DMARXDESC_DE          ((uint32_t)0x00004000U)  /*!< Descriptor error: no more descriptors for receive frame  */
N#define ETH_DMARXDESC_SAF         ((uint32_t)0x00002000U)  /*!< SA Filter Fail for the received frame */
N#define ETH_DMARXDESC_LE          ((uint32_t)0x00001000U)  /*!< Frame size not matching with length field */
N#define ETH_DMARXDESC_OE          ((uint32_t)0x00000800U)  /*!< Overflow Error: Frame was damaged due to buffer overflow */
N#define ETH_DMARXDESC_VLAN        ((uint32_t)0x00000400U)  /*!< VLAN Tag: received frame is a VLAN frame */
N#define ETH_DMARXDESC_FS          ((uint32_t)0x00000200U)  /*!< First descriptor of the frame  */
N#define ETH_DMARXDESC_LS          ((uint32_t)0x00000100U)  /*!< Last descriptor of the frame  */ 
N#define ETH_DMARXDESC_IPV4HCE     ((uint32_t)0x00000080U)  /*!< IPC Checksum Error: Rx Ipv4 header checksum error   */    
N#define ETH_DMARXDESC_LC          ((uint32_t)0x00000040U)  /*!< Late collision occurred during reception   */
N#define ETH_DMARXDESC_FT          ((uint32_t)0x00000020U)  /*!< Frame type - Ethernet, otherwise 802.3    */
N#define ETH_DMARXDESC_RWT         ((uint32_t)0x00000010U)  /*!< Receive Watchdog Timeout: watchdog timer expired during reception    */
N#define ETH_DMARXDESC_RE          ((uint32_t)0x00000008U)  /*!< Receive error: error reported by MII interface  */
N#define ETH_DMARXDESC_DBE         ((uint32_t)0x00000004U)  /*!< Dribble bit error: frame contains non int multiple of 8 bits  */
N#define ETH_DMARXDESC_CE          ((uint32_t)0x00000002U)  /*!< CRC error */
N#define ETH_DMARXDESC_MAMPCE      ((uint32_t)0x00000001U)  /*!< Rx MAC Address/Payload Checksum Error: Rx MAC address matched/ Rx Payload Checksum Error */
N
N/** 
N  * @brief  Bit definition of RDES1 register
N  */ 
N#define ETH_DMARXDESC_DIC   ((uint32_t)0x80000000U)  /*!< Disable Interrupt on Completion */
N#define ETH_DMARXDESC_RBS2  ((uint32_t)0x1FFF0000U)  /*!< Receive Buffer2 Size */
N#define ETH_DMARXDESC_RER   ((uint32_t)0x00008000U)  /*!< Receive End of Ring */
N#define ETH_DMARXDESC_RCH   ((uint32_t)0x00004000U)  /*!< Second Address Chained */
N#define ETH_DMARXDESC_RBS1  ((uint32_t)0x00001FFFU)  /*!< Receive Buffer1 Size */
N
N/** 
N  * @brief  Bit definition of RDES2 register  
N  */ 
N#define ETH_DMARXDESC_B1AP  ((uint32_t)0xFFFFFFFFU)  /*!< Buffer1 Address Pointer */
N
N/** 
N  * @brief  Bit definition of RDES3 register  
N  */ 
N#define ETH_DMARXDESC_B2AP  ((uint32_t)0xFFFFFFFFU)  /*!< Buffer2 Address Pointer */
N
N/*---------------------------------------------------------------------------------------------------------------------
N  RDES4 |                   Reserved[31:15]              |             Extended Status [14:0]                          |
N  ---------------------------------------------------------------------------------------------------------------------
N  RDES5 |                                            Reserved[31:0]                                                    |
N  ---------------------------------------------------------------------------------------------------------------------
N  RDES6 |                                       Receive Time Stamp Low [31:0]                                          |
N  ---------------------------------------------------------------------------------------------------------------------
N  RDES7 |                                       Receive Time Stamp High [31:0]                                         |
N  --------------------------------------------------------------------------------------------------------------------*/
N
N/* Bit definition of RDES4 register */
N#define ETH_DMAPTPRXDESC_PTPV                            ((uint32_t)0x00002000U)  /* PTP Version */
N#define ETH_DMAPTPRXDESC_PTPFT                           ((uint32_t)0x00001000U)  /* PTP Frame Type */
N#define ETH_DMAPTPRXDESC_PTPMT                           ((uint32_t)0x00000F00U)  /* PTP Message Type */
N#define ETH_DMAPTPRXDESC_PTPMT_SYNC                      ((uint32_t)0x00000100U)  /* SYNC message (all clock types) */
N#define ETH_DMAPTPRXDESC_PTPMT_FOLLOWUP                  ((uint32_t)0x00000200U)  /* FollowUp message (all clock types) */ 
N#define ETH_DMAPTPRXDESC_PTPMT_DELAYREQ                  ((uint32_t)0x00000300U)  /* DelayReq message (all clock types) */ 
N#define ETH_DMAPTPRXDESC_PTPMT_DELAYRESP                 ((uint32_t)0x00000400U)  /* DelayResp message (all clock types) */ 
N#define ETH_DMAPTPRXDESC_PTPMT_PDELAYREQ_ANNOUNCE        ((uint32_t)0x00000500U)  /* PdelayReq message (peer-to-peer transparent clock) or Announce message (Ordinary or Boundary clock) */ 
N#define ETH_DMAPTPRXDESC_PTPMT_PDELAYRESP_MANAG          ((uint32_t)0x00000600U)  /* PdelayResp message (peer-to-peer transparent clock) or Management message (Ordinary or Boundary clock)  */ 
N#define ETH_DMAPTPRXDESC_PTPMT_PDELAYRESPFOLLOWUP_SIGNAL ((uint32_t)0x00000700U)  /* PdelayRespFollowUp message (peer-to-peer transparent clock) or Signaling message (Ordinary or Boundary clock) */           
N#define ETH_DMAPTPRXDESC_IPV6PR                          ((uint32_t)0x00000080U)  /* IPv6 Packet Received */
N#define ETH_DMAPTPRXDESC_IPV4PR                          ((uint32_t)0x00000040U)  /* IPv4 Packet Received */
N#define ETH_DMAPTPRXDESC_IPCB                            ((uint32_t)0x00000020U)  /* IP Checksum Bypassed */
N#define ETH_DMAPTPRXDESC_IPPE                            ((uint32_t)0x00000010U)  /* IP Payload Error */
N#define ETH_DMAPTPRXDESC_IPHE                            ((uint32_t)0x00000008U)  /* IP Header Error */
N#define ETH_DMAPTPRXDESC_IPPT                            ((uint32_t)0x00000007U)  /* IP Payload Type */
N#define ETH_DMAPTPRXDESC_IPPT_UDP                        ((uint32_t)0x00000001U)  /* UDP payload encapsulated in the IP datagram */
N#define ETH_DMAPTPRXDESC_IPPT_TCP                        ((uint32_t)0x00000002U)  /* TCP payload encapsulated in the IP datagram */ 
N#define ETH_DMAPTPRXDESC_IPPT_ICMP                       ((uint32_t)0x00000003U)  /* ICMP payload encapsulated in the IP datagram */
N
N/* Bit definition of RDES6 register */
N#define ETH_DMAPTPRXDESC_RTSL  ((uint32_t)0xFFFFFFFFU)  /* Receive Time Stamp Low */
N
N/* Bit definition of RDES7 register */
N#define ETH_DMAPTPRXDESC_RTSH  ((uint32_t)0xFFFFFFFFU)  /* Receive Time Stamp High */
N/**
N  * @}
N  */
N /** @defgroup ETH_AutoNegotiation ETH AutoNegotiation 
N  * @{
N  */ 
N#define ETH_AUTONEGOTIATION_ENABLE     ((uint32_t)0x00000001U)
N#define ETH_AUTONEGOTIATION_DISABLE    ((uint32_t)0x00000000U)
N
N/**
N  * @}
N  */
N/** @defgroup ETH_Speed ETH Speed 
N  * @{
N  */ 
N#define ETH_SPEED_10M        ((uint32_t)0x00000000U)
N#define ETH_SPEED_100M       ((uint32_t)0x00004000U)
N
N/**
N  * @}
N  */
N/** @defgroup ETH_Duplex_Mode ETH Duplex Mode
N  * @{
N  */ 
N#define ETH_MODE_FULLDUPLEX       ((uint32_t)0x00000800U)
N#define ETH_MODE_HALFDUPLEX       ((uint32_t)0x00000000U)
N/**
N  * @}
N  */
N/** @defgroup ETH_Rx_Mode ETH Rx Mode
N  * @{
N  */ 
N#define ETH_RXPOLLING_MODE      ((uint32_t)0x00000000U)
N#define ETH_RXINTERRUPT_MODE    ((uint32_t)0x00000001U)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Checksum_Mode ETH Checksum Mode
N  * @{
N  */ 
N#define ETH_CHECKSUM_BY_HARDWARE      ((uint32_t)0x00000000U)
N#define ETH_CHECKSUM_BY_SOFTWARE      ((uint32_t)0x00000001U)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Media_Interface ETH Media Interface
N  * @{
N  */ 
N#define ETH_MEDIA_INTERFACE_MII       ((uint32_t)0x00000000U)
N#define ETH_MEDIA_INTERFACE_RMII      ((uint32_t)SYSCFG_PMC_MII_RMII_SEL)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Watchdog ETH Watchdog 
N  * @{
N  */ 
N#define ETH_WATCHDOG_ENABLE       ((uint32_t)0x00000000U)
N#define ETH_WATCHDOG_DISABLE      ((uint32_t)0x00800000U)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Jabber ETH Jabber
N  * @{
N  */ 
N#define ETH_JABBER_ENABLE    ((uint32_t)0x00000000U)
N#define ETH_JABBER_DISABLE   ((uint32_t)0x00400000U)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Inter_Frame_Gap ETH Inter Frame Gap 
N  * @{
N  */ 
N#define ETH_INTERFRAMEGAP_96BIT   ((uint32_t)0x00000000U)  /*!< minimum IFG between frames during transmission is 96Bit */
N#define ETH_INTERFRAMEGAP_88BIT   ((uint32_t)0x00020000U)  /*!< minimum IFG between frames during transmission is 88Bit */
N#define ETH_INTERFRAMEGAP_80BIT   ((uint32_t)0x00040000U)  /*!< minimum IFG between frames during transmission is 80Bit */
N#define ETH_INTERFRAMEGAP_72BIT   ((uint32_t)0x00060000U)  /*!< minimum IFG between frames during transmission is 72Bit */
N#define ETH_INTERFRAMEGAP_64BIT   ((uint32_t)0x00080000U)  /*!< minimum IFG between frames during transmission is 64Bit */
N#define ETH_INTERFRAMEGAP_56BIT   ((uint32_t)0x000A0000U)  /*!< minimum IFG between frames during transmission is 56Bit */
N#define ETH_INTERFRAMEGAP_48BIT   ((uint32_t)0x000C0000U)  /*!< minimum IFG between frames during transmission is 48Bit */
N#define ETH_INTERFRAMEGAP_40BIT   ((uint32_t)0x000E0000U)  /*!< minimum IFG between frames during transmission is 40Bit */
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Carrier_Sense ETH Carrier Sense
N  * @{
N  */ 
N#define ETH_CARRIERSENCE_ENABLE   ((uint32_t)0x00000000U)
N#define ETH_CARRIERSENCE_DISABLE  ((uint32_t)0x00010000U)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Receive_Own ETH Receive Own 
N  * @{
N  */ 
N#define ETH_RECEIVEOWN_ENABLE     ((uint32_t)0x00000000U)
N#define ETH_RECEIVEOWN_DISABLE    ((uint32_t)0x00002000U)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Loop_Back_Mode ETH Loop Back Mode 
N  * @{
N  */ 
N#define ETH_LOOPBACKMODE_ENABLE        ((uint32_t)0x00001000U)
N#define ETH_LOOPBACKMODE_DISABLE       ((uint32_t)0x00000000U)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Checksum_Offload ETH Checksum Offload
N  * @{
N  */ 
N#define ETH_CHECKSUMOFFLAOD_ENABLE     ((uint32_t)0x00000400U)
N#define ETH_CHECKSUMOFFLAOD_DISABLE    ((uint32_t)0x00000000U)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Retry_Transmission ETH Retry Transmission
N  * @{
N  */ 
N#define ETH_RETRYTRANSMISSION_ENABLE   ((uint32_t)0x00000000U)
N#define ETH_RETRYTRANSMISSION_DISABLE  ((uint32_t)0x00000200U)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Automatic_Pad_CRC_Strip ETH Automatic Pad CRC Strip
N  * @{
N  */ 
N#define ETH_AUTOMATICPADCRCSTRIP_ENABLE     ((uint32_t)0x00000080U)
N#define ETH_AUTOMATICPADCRCSTRIP_DISABLE    ((uint32_t)0x00000000U)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Back_Off_Limit ETH Back Off Limit
N  * @{
N  */ 
N#define ETH_BACKOFFLIMIT_10  ((uint32_t)0x00000000U)
N#define ETH_BACKOFFLIMIT_8   ((uint32_t)0x00000020U)
N#define ETH_BACKOFFLIMIT_4   ((uint32_t)0x00000040U)
N#define ETH_BACKOFFLIMIT_1   ((uint32_t)0x00000060U)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Deferral_Check ETH Deferral Check
N  * @{
N  */
N#define ETH_DEFFERRALCHECK_ENABLE       ((uint32_t)0x00000010U)
N#define ETH_DEFFERRALCHECK_DISABLE      ((uint32_t)0x00000000U)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Receive_All ETH Receive All
N  * @{
N  */ 
N#define ETH_RECEIVEALL_ENABLE     ((uint32_t)0x80000000U)
N#define ETH_RECEIVEAll_DISABLE    ((uint32_t)0x00000000U)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Source_Addr_Filter ETH Source Addr Filter
N  * @{
N  */ 
N#define ETH_SOURCEADDRFILTER_NORMAL_ENABLE       ((uint32_t)0x00000200U)
N#define ETH_SOURCEADDRFILTER_INVERSE_ENABLE      ((uint32_t)0x00000300U)
N#define ETH_SOURCEADDRFILTER_DISABLE             ((uint32_t)0x00000000U)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Pass_Control_Frames ETH Pass Control Frames
N  * @{
N  */ 
N#define ETH_PASSCONTROLFRAMES_BLOCKALL                ((uint32_t)0x00000040U)  /*!< MAC filters all control frames from reaching the application */
N#define ETH_PASSCONTROLFRAMES_FORWARDALL              ((uint32_t)0x00000080U)  /*!< MAC forwards all control frames to application even if they fail the Address Filter */
N#define ETH_PASSCONTROLFRAMES_FORWARDPASSEDADDRFILTER ((uint32_t)0x000000C0U)  /*!< MAC forwards control frames that pass the Address Filter. */ 
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Broadcast_Frames_Reception ETH Broadcast Frames Reception
N  * @{
N  */ 
N#define ETH_BROADCASTFRAMESRECEPTION_ENABLE     ((uint32_t)0x00000000U)
N#define ETH_BROADCASTFRAMESRECEPTION_DISABLE    ((uint32_t)0x00000020U)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Destination_Addr_Filter ETH Destination Addr Filter
N  * @{
N  */ 
N#define ETH_DESTINATIONADDRFILTER_NORMAL    ((uint32_t)0x00000000U)
N#define ETH_DESTINATIONADDRFILTER_INVERSE   ((uint32_t)0x00000008U)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Promiscuous_Mode ETH Promiscuous Mode
N  * @{
N  */ 
N#define ETH_PROMISCUOUS_MODE_ENABLE     ((uint32_t)0x00000001U)
N#define ETH_PROMISCUOUS_MODE_DISABLE    ((uint32_t)0x00000000U)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Multicast_Frames_Filter ETH Multicast Frames Filter
N  * @{
N  */ 
N#define ETH_MULTICASTFRAMESFILTER_PERFECTHASHTABLE    ((uint32_t)0x00000404U)
N#define ETH_MULTICASTFRAMESFILTER_HASHTABLE           ((uint32_t)0x00000004U)
N#define ETH_MULTICASTFRAMESFILTER_PERFECT             ((uint32_t)0x00000000U)
N#define ETH_MULTICASTFRAMESFILTER_NONE                ((uint32_t)0x00000010U)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Unicast_Frames_Filter ETH Unicast Frames Filter
N  * @{
N  */ 
N#define ETH_UNICASTFRAMESFILTER_PERFECTHASHTABLE ((uint32_t)0x00000402U)
N#define ETH_UNICASTFRAMESFILTER_HASHTABLE        ((uint32_t)0x00000002U)
N#define ETH_UNICASTFRAMESFILTER_PERFECT          ((uint32_t)0x00000000U)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Zero_Quanta_Pause ETH Zero Quanta Pause 
N  * @{
N  */ 
N#define ETH_ZEROQUANTAPAUSE_ENABLE     ((uint32_t)0x00000000U)
N#define ETH_ZEROQUANTAPAUSE_DISABLE    ((uint32_t)0x00000080U)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Pause_Low_Threshold ETH Pause Low Threshold
N  * @{
N  */ 
N#define ETH_PAUSELOWTHRESHOLD_MINUS4        ((uint32_t)0x00000000U)  /*!< Pause time minus 4 slot times */
N#define ETH_PAUSELOWTHRESHOLD_MINUS28       ((uint32_t)0x00000010U)  /*!< Pause time minus 28 slot times */
N#define ETH_PAUSELOWTHRESHOLD_MINUS144      ((uint32_t)0x00000020U)  /*!< Pause time minus 144 slot times */
N#define ETH_PAUSELOWTHRESHOLD_MINUS256      ((uint32_t)0x00000030U)  /*!< Pause time minus 256 slot times */
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Unicast_Pause_Frame_Detect ETH Unicast Pause Frame Detect
N  * @{
N  */ 
N#define ETH_UNICASTPAUSEFRAMEDETECT_ENABLE  ((uint32_t)0x00000008U)
N#define ETH_UNICASTPAUSEFRAMEDETECT_DISABLE ((uint32_t)0x00000000U)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Receive_Flow_Control ETH Receive Flow Control
N  * @{
N  */ 
N#define ETH_RECEIVEFLOWCONTROL_ENABLE       ((uint32_t)0x00000004U)
N#define ETH_RECEIVEFLOWCONTROL_DISABLE      ((uint32_t)0x00000000U)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Transmit_Flow_Control ETH Transmit Flow Control
N  * @{
N  */ 
N#define ETH_TRANSMITFLOWCONTROL_ENABLE      ((uint32_t)0x00000002U)
N#define ETH_TRANSMITFLOWCONTROL_DISABLE     ((uint32_t)0x00000000U)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_VLAN_Tag_Comparison ETH VLAN Tag Comparison
N  * @{
N  */ 
N#define ETH_VLANTAGCOMPARISON_12BIT    ((uint32_t)0x00010000U)
N#define ETH_VLANTAGCOMPARISON_16BIT    ((uint32_t)0x00000000U)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_MAC_addresses ETH MAC addresses
N  * @{
N  */ 
N#define ETH_MAC_ADDRESS0     ((uint32_t)0x00000000U)
N#define ETH_MAC_ADDRESS1     ((uint32_t)0x00000008U)
N#define ETH_MAC_ADDRESS2     ((uint32_t)0x00000010U)
N#define ETH_MAC_ADDRESS3     ((uint32_t)0x00000018U)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_MAC_addresses_filter_SA_DA ETH MAC addresses filter SA DA 
N  * @{
N  */ 
N#define ETH_MAC_ADDRESSFILTER_SA       ((uint32_t)0x00000000U)
N#define ETH_MAC_ADDRESSFILTER_DA       ((uint32_t)0x00000008U)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_MAC_addresses_filter_Mask_bytes ETH MAC addresses filter Mask bytes
N  * @{
N  */ 
N#define ETH_MAC_ADDRESSMASK_BYTE6      ((uint32_t)0x20000000U)  /*!< Mask MAC Address high reg bits [15:8] */
N#define ETH_MAC_ADDRESSMASK_BYTE5      ((uint32_t)0x10000000U)  /*!< Mask MAC Address high reg bits [7:0] */
N#define ETH_MAC_ADDRESSMASK_BYTE4      ((uint32_t)0x08000000U)  /*!< Mask MAC Address low reg bits [31:24] */
N#define ETH_MAC_ADDRESSMASK_BYTE3      ((uint32_t)0x04000000U)  /*!< Mask MAC Address low reg bits [23:16] */
N#define ETH_MAC_ADDRESSMASK_BYTE2      ((uint32_t)0x02000000U)  /*!< Mask MAC Address low reg bits [15:8] */
N#define ETH_MAC_ADDRESSMASK_BYTE1      ((uint32_t)0x01000000U)  /*!< Mask MAC Address low reg bits [70] */
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Drop_TCP_IP_Checksum_Error_Frame ETH Drop TCP IP Checksum Error Frame
N  * @{
N  */ 
N#define ETH_DROPTCPIPCHECKSUMERRORFRAME_ENABLE   ((uint32_t)0x00000000U)
N#define ETH_DROPTCPIPCHECKSUMERRORFRAME_DISABLE  ((uint32_t)0x04000000U)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Receive_Store_Forward ETH Receive Store Forward
N  * @{
N  */ 
N#define ETH_RECEIVESTOREFORWARD_ENABLE      ((uint32_t)0x02000000U)
N#define ETH_RECEIVESTOREFORWARD_DISABLE     ((uint32_t)0x00000000U)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Flush_Received_Frame ETH Flush Received Frame
N  * @{
N  */ 
N#define ETH_FLUSHRECEIVEDFRAME_ENABLE       ((uint32_t)0x00000000U)
N#define ETH_FLUSHRECEIVEDFRAME_DISABLE      ((uint32_t)0x01000000U)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Transmit_Store_Forward ETH Transmit Store Forward
N  * @{
N  */ 
N#define ETH_TRANSMITSTOREFORWARD_ENABLE     ((uint32_t)0x00200000U)
N#define ETH_TRANSMITSTOREFORWARD_DISABLE    ((uint32_t)0x00000000U)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Transmit_Threshold_Control ETH Transmit Threshold Control
N  * @{
N  */ 
N#define ETH_TRANSMITTHRESHOLDCONTROL_64BYTES     ((uint32_t)0x00000000U)  /*!< threshold level of the MTL Transmit FIFO is 64 Bytes */
N#define ETH_TRANSMITTHRESHOLDCONTROL_128BYTES    ((uint32_t)0x00004000U)  /*!< threshold level of the MTL Transmit FIFO is 128 Bytes */
N#define ETH_TRANSMITTHRESHOLDCONTROL_192BYTES    ((uint32_t)0x00008000U)  /*!< threshold level of the MTL Transmit FIFO is 192 Bytes */
N#define ETH_TRANSMITTHRESHOLDCONTROL_256BYTES    ((uint32_t)0x0000C000U)  /*!< threshold level of the MTL Transmit FIFO is 256 Bytes */
N#define ETH_TRANSMITTHRESHOLDCONTROL_40BYTES     ((uint32_t)0x00010000U)  /*!< threshold level of the MTL Transmit FIFO is 40 Bytes */
N#define ETH_TRANSMITTHRESHOLDCONTROL_32BYTES     ((uint32_t)0x00014000U)  /*!< threshold level of the MTL Transmit FIFO is 32 Bytes */
N#define ETH_TRANSMITTHRESHOLDCONTROL_24BYTES     ((uint32_t)0x00018000U)  /*!< threshold level of the MTL Transmit FIFO is 24 Bytes */
N#define ETH_TRANSMITTHRESHOLDCONTROL_16BYTES     ((uint32_t)0x0001C000U)  /*!< threshold level of the MTL Transmit FIFO is 16 Bytes */
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Forward_Error_Frames ETH Forward Error Frames
N  * @{
N  */ 
N#define ETH_FORWARDERRORFRAMES_ENABLE       ((uint32_t)0x00000080U)
N#define ETH_FORWARDERRORFRAMES_DISABLE      ((uint32_t)0x00000000U)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Forward_Undersized_Good_Frames ETH Forward Undersized Good Frames
N  * @{
N  */ 
N#define ETH_FORWARDUNDERSIZEDGOODFRAMES_ENABLE   ((uint32_t)0x00000040U)
N#define ETH_FORWARDUNDERSIZEDGOODFRAMES_DISABLE  ((uint32_t)0x00000000U)     
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Receive_Threshold_Control ETH Receive Threshold Control
N  * @{
N  */ 
N#define ETH_RECEIVEDTHRESHOLDCONTROL_64BYTES      ((uint32_t)0x00000000U)  /*!< threshold level of the MTL Receive FIFO is 64 Bytes */
N#define ETH_RECEIVEDTHRESHOLDCONTROL_32BYTES      ((uint32_t)0x00000008U)  /*!< threshold level of the MTL Receive FIFO is 32 Bytes */
N#define ETH_RECEIVEDTHRESHOLDCONTROL_96BYTES      ((uint32_t)0x00000010U)  /*!< threshold level of the MTL Receive FIFO is 96 Bytes */
N#define ETH_RECEIVEDTHRESHOLDCONTROL_128BYTES     ((uint32_t)0x00000018U)  /*!< threshold level of the MTL Receive FIFO is 128 Bytes */
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Second_Frame_Operate ETH Second Frame Operate
N  * @{
N  */ 
N#define ETH_SECONDFRAMEOPERARTE_ENABLE       ((uint32_t)0x00000004U)
N#define ETH_SECONDFRAMEOPERARTE_DISABLE      ((uint32_t)0x00000000U)  
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Address_Aligned_Beats ETH Address Aligned Beats 
N  * @{
N  */ 
N#define ETH_ADDRESSALIGNEDBEATS_ENABLE      ((uint32_t)0x02000000U)
N#define ETH_ADDRESSALIGNEDBEATS_DISABLE     ((uint32_t)0x00000000U) 
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Fixed_Burst ETH Fixed Burst
N  * @{
N  */ 
N#define ETH_FIXEDBURST_ENABLE     ((uint32_t)0x00010000U)
N#define ETH_FIXEDBURST_DISABLE    ((uint32_t)0x00000000U) 
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Rx_DMA_Burst_Length ETH Rx DMA Burst Length
N  * @{
N  */ 
N#define ETH_RXDMABURSTLENGTH_1BEAT          ((uint32_t)0x00020000U)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 1 */
N#define ETH_RXDMABURSTLENGTH_2BEAT          ((uint32_t)0x00040000U)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 2 */
N#define ETH_RXDMABURSTLENGTH_4BEAT          ((uint32_t)0x00080000U)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 4 */
N#define ETH_RXDMABURSTLENGTH_8BEAT          ((uint32_t)0x00100000U)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 8 */
N#define ETH_RXDMABURSTLENGTH_16BEAT         ((uint32_t)0x00200000U)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 16 */
N#define ETH_RXDMABURSTLENGTH_32BEAT         ((uint32_t)0x00400000U)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 32 */                
N#define ETH_RXDMABURSTLENGTH_4XPBL_4BEAT    ((uint32_t)0x01020000U)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 4 */
N#define ETH_RXDMABURSTLENGTH_4XPBL_8BEAT    ((uint32_t)0x01040000U)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 8 */
N#define ETH_RXDMABURSTLENGTH_4XPBL_16BEAT   ((uint32_t)0x01080000U)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 16 */
N#define ETH_RXDMABURSTLENGTH_4XPBL_32BEAT   ((uint32_t)0x01100000U)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 32 */
N#define ETH_RXDMABURSTLENGTH_4XPBL_64BEAT   ((uint32_t)0x01200000U)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 64 */
N#define ETH_RXDMABURSTLENGTH_4XPBL_128BEAT  ((uint32_t)0x01400000U)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 128 */
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Tx_DMA_Burst_Length ETH Tx DMA Burst Length
N  * @{
N  */ 
N#define ETH_TXDMABURSTLENGTH_1BEAT          ((uint32_t)0x00000100U)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 1 */
N#define ETH_TXDMABURSTLENGTH_2BEAT          ((uint32_t)0x00000200U)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 2 */
N#define ETH_TXDMABURSTLENGTH_4BEAT          ((uint32_t)0x00000400U)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */
N#define ETH_TXDMABURSTLENGTH_8BEAT          ((uint32_t)0x00000800U)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */
N#define ETH_TXDMABURSTLENGTH_16BEAT         ((uint32_t)0x00001000U)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */
N#define ETH_TXDMABURSTLENGTH_32BEAT         ((uint32_t)0x00002000U)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */                
N#define ETH_TXDMABURSTLENGTH_4XPBL_4BEAT    ((uint32_t)0x01000100U)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */
N#define ETH_TXDMABURSTLENGTH_4XPBL_8BEAT    ((uint32_t)0x01000200U)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */
N#define ETH_TXDMABURSTLENGTH_4XPBL_16BEAT   ((uint32_t)0x01000400U)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */
N#define ETH_TXDMABURSTLENGTH_4XPBL_32BEAT   ((uint32_t)0x01000800U)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */
N#define ETH_TXDMABURSTLENGTH_4XPBL_64BEAT   ((uint32_t)0x01001000U)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 64 */
N#define ETH_TXDMABURSTLENGTH_4XPBL_128BEAT  ((uint32_t)0x01002000U)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 128 */
N/**
N  * @}
N  */
N
N/** @defgroup ETH_DMA_Enhanced_descriptor_format ETH DMA Enhanced descriptor format
N  * @{
N  */  
N#define ETH_DMAENHANCEDDESCRIPTOR_ENABLE              ((uint32_t)0x00000080U)
N#define ETH_DMAENHANCEDDESCRIPTOR_DISABLE             ((uint32_t)0x00000000U)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_DMA_Arbitration ETH DMA Arbitration
N  * @{
N  */ 
N#define ETH_DMAARBITRATION_ROUNDROBIN_RXTX_1_1   ((uint32_t)0x00000000U)
N#define ETH_DMAARBITRATION_ROUNDROBIN_RXTX_2_1   ((uint32_t)0x00004000U)
N#define ETH_DMAARBITRATION_ROUNDROBIN_RXTX_3_1   ((uint32_t)0x00008000U)
N#define ETH_DMAARBITRATION_ROUNDROBIN_RXTX_4_1   ((uint32_t)0x0000C000U)
N#define ETH_DMAARBITRATION_RXPRIORTX             ((uint32_t)0x00000002U)
N/**
N  * @}
N  */
N
N/** @defgroup ETH_DMA_Tx_descriptor_segment ETH DMA Tx descriptor segment
N  * @{
N  */ 
N#define ETH_DMATXDESC_LASTSEGMENTS      ((uint32_t)0x40000000U)  /*!< Last Segment */
N#define ETH_DMATXDESC_FIRSTSEGMENT      ((uint32_t)0x20000000U)  /*!< First Segment */
N/**
N  * @}
N  */
N
N/** @defgroup ETH_DMA_Tx_descriptor_Checksum_Insertion_Control ETH DMA Tx descriptor Checksum Insertion Control
N  * @{
N  */ 
N#define ETH_DMATXDESC_CHECKSUMBYPASS             ((uint32_t)0x00000000U)   /*!< Checksum engine bypass */
N#define ETH_DMATXDESC_CHECKSUMIPV4HEADER         ((uint32_t)0x00400000U)   /*!< IPv4 header checksum insertion  */
N#define ETH_DMATXDESC_CHECKSUMTCPUDPICMPSEGMENT  ((uint32_t)0x00800000U)   /*!< TCP/UDP/ICMP checksum insertion. Pseudo header checksum is assumed to be present */
N#define ETH_DMATXDESC_CHECKSUMTCPUDPICMPFULL     ((uint32_t)0x00C00000U)   /*!< TCP/UDP/ICMP checksum fully in hardware including pseudo header */
N/**
N  * @}
N  */
N
N/** @defgroup ETH_DMA_Rx_descriptor_buffers ETH DMA Rx descriptor buffers 
N  * @{
N  */ 
N#define ETH_DMARXDESC_BUFFER1     ((uint32_t)0x00000000U)  /*!< DMA Rx Desc Buffer1 */
N#define ETH_DMARXDESC_BUFFER2     ((uint32_t)0x00000001U)  /*!< DMA Rx Desc Buffer2 */
N/**
N  * @}
N  */
N
N/** @defgroup ETH_PMT_Flags ETH PMT Flags
N  * @{
N  */ 
N#define ETH_PMT_FLAG_WUFFRPR      ((uint32_t)0x80000000U)  /*!< Wake-Up Frame Filter Register Pointer Reset */
N#define ETH_PMT_FLAG_WUFR         ((uint32_t)0x00000040U)  /*!< Wake-Up Frame Received */
N#define ETH_PMT_FLAG_MPR          ((uint32_t)0x00000020U)  /*!< Magic Packet Received */
N/**
N  * @}
N  */
N
N/** @defgroup ETH_MMC_Tx_Interrupts ETH MMC Tx Interrupts
N  * @{
N  */ 
N#define ETH_MMC_IT_TGF       ((uint32_t)0x00200000U)  /*!< When Tx good frame counter reaches half the maximum value */
N#define ETH_MMC_IT_TGFMSC    ((uint32_t)0x00008000U)  /*!< When Tx good multi col counter reaches half the maximum value */
N#define ETH_MMC_IT_TGFSC     ((uint32_t)0x00004000U)  /*!< When Tx good single col counter reaches half the maximum value */
N/**
N  * @}
N  */
N
N/** @defgroup ETH_MMC_Rx_Interrupts ETH MMC Rx Interrupts
N  * @{
N  */
N#define ETH_MMC_IT_RGUF      ((uint32_t)0x10020000U)  /*!< When Rx good unicast frames counter reaches half the maximum value */
N#define ETH_MMC_IT_RFAE      ((uint32_t)0x10000040U)  /*!< When Rx alignment error counter reaches half the maximum value */
N#define ETH_MMC_IT_RFCE      ((uint32_t)0x10000020U)  /*!< When Rx crc error counter reaches half the maximum value */
N/**
N  * @}
N  */
N
N/** @defgroup ETH_MAC_Flags ETH MAC Flags
N  * @{
N  */ 
N#define ETH_MAC_FLAG_TST     ((uint32_t)0x00000200U)  /*!< Time stamp trigger flag (on MAC) */
N#define ETH_MAC_FLAG_MMCT    ((uint32_t)0x00000040U)  /*!< MMC transmit flag  */
N#define ETH_MAC_FLAG_MMCR    ((uint32_t)0x00000020U)  /*!< MMC receive flag */
N#define ETH_MAC_FLAG_MMC     ((uint32_t)0x00000010U)  /*!< MMC flag (on MAC) */
N#define ETH_MAC_FLAG_PMT     ((uint32_t)0x00000008U)  /*!< PMT flag (on MAC) */
N/**
N  * @}
N  */
N
N/** @defgroup ETH_DMA_Flags ETH DMA Flags
N  * @{
N  */ 
N#define ETH_DMA_FLAG_TST               ((uint32_t)0x20000000U)  /*!< Time-stamp trigger interrupt (on DMA) */
N#define ETH_DMA_FLAG_PMT               ((uint32_t)0x10000000U)  /*!< PMT interrupt (on DMA) */
N#define ETH_DMA_FLAG_MMC               ((uint32_t)0x08000000U)  /*!< MMC interrupt (on DMA) */
N#define ETH_DMA_FLAG_DATATRANSFERERROR ((uint32_t)0x00800000U)  /*!< Error bits 0-Rx DMA, 1-Tx DMA */
N#define ETH_DMA_FLAG_READWRITEERROR    ((uint32_t)0x01000000U)  /*!< Error bits 0-write transfer, 1-read transfer */
N#define ETH_DMA_FLAG_ACCESSERROR       ((uint32_t)0x02000000U)  /*!< Error bits 0-data buffer, 1-desc. access */
N#define ETH_DMA_FLAG_NIS               ((uint32_t)0x00010000U)  /*!< Normal interrupt summary flag */
N#define ETH_DMA_FLAG_AIS               ((uint32_t)0x00008000U)  /*!< Abnormal interrupt summary flag */
N#define ETH_DMA_FLAG_ER                ((uint32_t)0x00004000U)  /*!< Early receive flag */
N#define ETH_DMA_FLAG_FBE               ((uint32_t)0x00002000U)  /*!< Fatal bus error flag */
N#define ETH_DMA_FLAG_ET                ((uint32_t)0x00000400U)  /*!< Early transmit flag */
N#define ETH_DMA_FLAG_RWT               ((uint32_t)0x00000200U)  /*!< Receive watchdog timeout flag */
N#define ETH_DMA_FLAG_RPS               ((uint32_t)0x00000100U)  /*!< Receive process stopped flag */
N#define ETH_DMA_FLAG_RBU               ((uint32_t)0x00000080U)  /*!< Receive buffer unavailable flag */
N#define ETH_DMA_FLAG_R                 ((uint32_t)0x00000040U)  /*!< Receive flag */
N#define ETH_DMA_FLAG_TU                ((uint32_t)0x00000020U)  /*!< Underflow flag */
N#define ETH_DMA_FLAG_RO                ((uint32_t)0x00000010U)  /*!< Overflow flag */
N#define ETH_DMA_FLAG_TJT               ((uint32_t)0x00000008U)  /*!< Transmit jabber timeout flag */
N#define ETH_DMA_FLAG_TBU               ((uint32_t)0x00000004U)  /*!< Transmit buffer unavailable flag */
N#define ETH_DMA_FLAG_TPS               ((uint32_t)0x00000002U)  /*!< Transmit process stopped flag */
N#define ETH_DMA_FLAG_T                 ((uint32_t)0x00000001U)  /*!< Transmit flag */
N/**
N  * @}
N  */
N
N/** @defgroup ETH_MAC_Interrupts ETH MAC Interrupts 
N  * @{
N  */ 
N#define ETH_MAC_IT_TST       ((uint32_t)0x00000200U)  /*!< Time stamp trigger interrupt (on MAC) */
N#define ETH_MAC_IT_MMCT      ((uint32_t)0x00000040U)  /*!< MMC transmit interrupt */
N#define ETH_MAC_IT_MMCR      ((uint32_t)0x00000020U)  /*!< MMC receive interrupt */
N#define ETH_MAC_IT_MMC       ((uint32_t)0x00000010U)  /*!< MMC interrupt (on MAC) */
N#define ETH_MAC_IT_PMT       ((uint32_t)0x00000008U)  /*!< PMT interrupt (on MAC) */
N/**
N  * @}
N  */
N
N/** @defgroup ETH_DMA_Interrupts ETH DMA Interrupts 
N  * @{
N  */ 
N#define ETH_DMA_IT_TST       ((uint32_t)0x20000000U)  /*!< Time-stamp trigger interrupt (on DMA) */
N#define ETH_DMA_IT_PMT       ((uint32_t)0x10000000U)  /*!< PMT interrupt (on DMA) */
N#define ETH_DMA_IT_MMC       ((uint32_t)0x08000000U)  /*!< MMC interrupt (on DMA) */
N#define ETH_DMA_IT_NIS       ((uint32_t)0x00010000U)  /*!< Normal interrupt summary */
N#define ETH_DMA_IT_AIS       ((uint32_t)0x00008000U)  /*!< Abnormal interrupt summary */
N#define ETH_DMA_IT_ER        ((uint32_t)0x00004000U)  /*!< Early receive interrupt */
N#define ETH_DMA_IT_FBE       ((uint32_t)0x00002000U)  /*!< Fatal bus error interrupt */
N#define ETH_DMA_IT_ET        ((uint32_t)0x00000400U)  /*!< Early transmit interrupt */
N#define ETH_DMA_IT_RWT       ((uint32_t)0x00000200U)  /*!< Receive watchdog timeout interrupt */
N#define ETH_DMA_IT_RPS       ((uint32_t)0x00000100U)  /*!< Receive process stopped interrupt */
N#define ETH_DMA_IT_RBU       ((uint32_t)0x00000080U)  /*!< Receive buffer unavailable interrupt */
N#define ETH_DMA_IT_R         ((uint32_t)0x00000040U)  /*!< Receive interrupt */
N#define ETH_DMA_IT_TU        ((uint32_t)0x00000020U)  /*!< Underflow interrupt */
N#define ETH_DMA_IT_RO        ((uint32_t)0x00000010U)  /*!< Overflow interrupt */
N#define ETH_DMA_IT_TJT       ((uint32_t)0x00000008U)  /*!< Transmit jabber timeout interrupt */
N#define ETH_DMA_IT_TBU       ((uint32_t)0x00000004U)  /*!< Transmit buffer unavailable interrupt */
N#define ETH_DMA_IT_TPS       ((uint32_t)0x00000002U)  /*!< Transmit process stopped interrupt */
N#define ETH_DMA_IT_T         ((uint32_t)0x00000001U)  /*!< Transmit interrupt */
N/**
N  * @}
N  */
N
N/** @defgroup ETH_DMA_transmit_process_state ETH DMA transmit process state 
N  * @{
N  */ 
N#define ETH_DMA_TRANSMITPROCESS_STOPPED     ((uint32_t)0x00000000U)  /*!< Stopped - Reset or Stop Tx Command issued */
N#define ETH_DMA_TRANSMITPROCESS_FETCHING    ((uint32_t)0x00100000U)  /*!< Running - fetching the Tx descriptor */
N#define ETH_DMA_TRANSMITPROCESS_WAITING     ((uint32_t)0x00200000U)  /*!< Running - waiting for status */
N#define ETH_DMA_TRANSMITPROCESS_READING     ((uint32_t)0x00300000U)  /*!< Running - reading the data from host memory */
N#define ETH_DMA_TRANSMITPROCESS_SUSPENDED   ((uint32_t)0x00600000U)  /*!< Suspended - Tx Descriptor unavailable */
N#define ETH_DMA_TRANSMITPROCESS_CLOSING     ((uint32_t)0x00700000U)  /*!< Running - closing Rx descriptor */
N
N/**
N  * @}
N  */ 
N
N
N/** @defgroup ETH_DMA_receive_process_state ETH DMA receive process state 
N  * @{
N  */ 
N#define ETH_DMA_RECEIVEPROCESS_STOPPED      ((uint32_t)0x00000000U)  /*!< Stopped - Reset or Stop Rx Command issued */
N#define ETH_DMA_RECEIVEPROCESS_FETCHING     ((uint32_t)0x00020000U)  /*!< Running - fetching the Rx descriptor */
N#define ETH_DMA_RECEIVEPROCESS_WAITING      ((uint32_t)0x00060000U)  /*!< Running - waiting for packet */
N#define ETH_DMA_RECEIVEPROCESS_SUSPENDED    ((uint32_t)0x00080000U)  /*!< Suspended - Rx Descriptor unavailable */
N#define ETH_DMA_RECEIVEPROCESS_CLOSING      ((uint32_t)0x000A0000U)  /*!< Running - closing descriptor */
N#define ETH_DMA_RECEIVEPROCESS_QUEUING      ((uint32_t)0x000E0000U)  /*!< Running - queuing the receive frame into host memory */
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_DMA_overflow ETH DMA overflow
N  * @{
N  */ 
N#define ETH_DMA_OVERFLOW_RXFIFOCOUNTER      ((uint32_t)0x10000000U)  /*!< Overflow bit for FIFO overflow counter */
N#define ETH_DMA_OVERFLOW_MISSEDFRAMECOUNTER ((uint32_t)0x00010000U)  /*!< Overflow bit for missed frame counter */
N/**
N  * @}
N  */ 
N
N/** @defgroup ETH_EXTI_LINE_WAKEUP ETH EXTI LINE WAKEUP
N  * @{
N  */ 
N#define ETH_EXTI_LINE_WAKEUP              ((uint32_t)0x00080000U)  /*!< External interrupt line 19 Connected to the ETH EXTI Line */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup ETH_Exported_Macros ETH Exported Macros
N *  @brief macros to handle interrupts and specific clock configurations
N * @{
N */
N 
N/** @brief Reset ETH handle state
N  * @param  __HANDLE__: specifies the ETH handle.
N  * @retval None
N  */
N#define __HAL_ETH_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_ETH_STATE_RESET)
N
N/** 
N  * @brief  Checks whether the specified Ethernet DMA Tx Desc flag is set or not.
N  * @param  __HANDLE__: ETH Handle
N  * @param  __FLAG__: specifies the flag of TDES0 to check.
N  * @retval the ETH_DMATxDescFlag (SET or RESET).
N  */
N#define __HAL_ETH_DMATXDESC_GET_FLAG(__HANDLE__, __FLAG__)             ((__HANDLE__)->TxDesc->Status & (__FLAG__) == (__FLAG__))
N
N/**
N  * @brief  Checks whether the specified Ethernet DMA Rx Desc flag is set or not.
N  * @param  __HANDLE__: ETH Handle
N  * @param  __FLAG__: specifies the flag of RDES0 to check.
N  * @retval the ETH_DMATxDescFlag (SET or RESET).
N  */
N#define __HAL_ETH_DMARXDESC_GET_FLAG(__HANDLE__, __FLAG__)             ((__HANDLE__)->RxDesc->Status & (__FLAG__) == (__FLAG__))
N
N/**
N  * @brief  Enables the specified DMA Rx Desc receive interrupt.
N  * @param  __HANDLE__: ETH Handle
N  * @retval None
N  */
N#define __HAL_ETH_DMARXDESC_ENABLE_IT(__HANDLE__)                          ((__HANDLE__)->RxDesc->ControlBufferSize &=(~(uint32_t)ETH_DMARXDESC_DIC))
N
N/**
N  * @brief  Disables the specified DMA Rx Desc receive interrupt.
N  * @param  __HANDLE__: ETH Handle
N  * @retval None
N  */
N#define __HAL_ETH_DMARXDESC_DISABLE_IT(__HANDLE__)                         ((__HANDLE__)->RxDesc->ControlBufferSize |= ETH_DMARXDESC_DIC)
N
N/**
N  * @brief  Set the specified DMA Rx Desc Own bit.
N  * @param  __HANDLE__: ETH Handle
N  * @retval None
N  */
N#define __HAL_ETH_DMARXDESC_SET_OWN_BIT(__HANDLE__)                           ((__HANDLE__)->RxDesc->Status |= ETH_DMARXDESC_OWN)
N
N/**
N  * @brief  Returns the specified Ethernet DMA Tx Desc collision count.
N  * @param  __HANDLE__: ETH Handle                     
N  * @retval The Transmit descriptor collision counter value.
N  */
N#define __HAL_ETH_DMATXDESC_GET_COLLISION_COUNT(__HANDLE__)                   (((__HANDLE__)->TxDesc->Status & ETH_DMATXDESC_CC) >> ETH_DMATXDESC_COLLISION_COUNTSHIFT)
N
N/**
N  * @brief  Set the specified DMA Tx Desc Own bit.
N  * @param  __HANDLE__: ETH Handle
N  * @retval None
N  */
N#define __HAL_ETH_DMATXDESC_SET_OWN_BIT(__HANDLE__)                       ((__HANDLE__)->TxDesc->Status |= ETH_DMATXDESC_OWN)
N
N/**
N  * @brief  Enables the specified DMA Tx Desc Transmit interrupt.
N  * @param  __HANDLE__: ETH Handle                   
N  * @retval None
N  */
N#define __HAL_ETH_DMATXDESC_ENABLE_IT(__HANDLE__)                          ((__HANDLE__)->TxDesc->Status |= ETH_DMATXDESC_IC)
N
N/**
N  * @brief  Disables the specified DMA Tx Desc Transmit interrupt.
N  * @param  __HANDLE__: ETH Handle             
N  * @retval None
N  */
N#define __HAL_ETH_DMATXDESC_DISABLE_IT(__HANDLE__)                          ((__HANDLE__)->TxDesc->Status &= ~ETH_DMATXDESC_IC)
N
N/**
N  * @brief  Selects the specified Ethernet DMA Tx Desc Checksum Insertion.
N  * @param  __HANDLE__: ETH Handle  
N  * @param  __CHECKSUM__: specifies is the DMA Tx desc checksum insertion.
N  *   This parameter can be one of the following values:
N  *     @arg ETH_DMATXDESC_CHECKSUMBYPASS : Checksum bypass
N  *     @arg ETH_DMATXDESC_CHECKSUMIPV4HEADER : IPv4 header checksum
N  *     @arg ETH_DMATXDESC_CHECKSUMTCPUDPICMPSEGMENT : TCP/UDP/ICMP checksum. Pseudo header checksum is assumed to be present
N  *     @arg ETH_DMATXDESC_CHECKSUMTCPUDPICMPFULL : TCP/UDP/ICMP checksum fully in hardware including pseudo header                                                                
N  * @retval None
N  */
N#define __HAL_ETH_DMATXDESC_CHECKSUM_INSERTION(__HANDLE__, __CHECKSUM__)     ((__HANDLE__)->TxDesc->Status |= (__CHECKSUM__))
N
N/**
N  * @brief  Enables the DMA Tx Desc CRC.
N  * @param  __HANDLE__: ETH Handle 
N  * @retval None
N  */
N#define __HAL_ETH_DMATXDESC_CRC_ENABLE(__HANDLE__)                          ((__HANDLE__)->TxDesc->Status &= ~ETH_DMATXDESC_DC)
N
N/**
N  * @brief  Disables the DMA Tx Desc CRC.
N  * @param  __HANDLE__: ETH Handle 
N  * @retval None
N  */
N#define __HAL_ETH_DMATXDESC_CRC_DISABLE(__HANDLE__)                         ((__HANDLE__)->TxDesc->Status |= ETH_DMATXDESC_DC)
N
N/**
N  * @brief  Enables the DMA Tx Desc padding for frame shorter than 64 bytes.
N  * @param  __HANDLE__: ETH Handle 
N  * @retval None
N  */
N#define __HAL_ETH_DMATXDESC_SHORT_FRAME_PADDING_ENABLE(__HANDLE__)            ((__HANDLE__)->TxDesc->Status &= ~ETH_DMATXDESC_DP)
N
N/**
N  * @brief  Disables the DMA Tx Desc padding for frame shorter than 64 bytes.
N  * @param  __HANDLE__: ETH Handle 
N  * @retval None
N  */
N#define __HAL_ETH_DMATXDESC_SHORT_FRAME_PADDING_DISABLE(__HANDLE__)           ((__HANDLE__)->TxDesc->Status |= ETH_DMATXDESC_DP)
N
N/** 
N * @brief  Enables the specified Ethernet MAC interrupts.
N  * @param  __HANDLE__   : ETH Handle
N  * @param  __INTERRUPT__: specifies the Ethernet MAC interrupt sources to be
N  *   enabled or disabled.
N  *   This parameter can be any combination of the following values:
N  *     @arg ETH_MAC_IT_TST : Time stamp trigger interrupt 
N  *     @arg ETH_MAC_IT_PMT : PMT interrupt 
N  * @retval None
N  */
N#define __HAL_ETH_MAC_ENABLE_IT(__HANDLE__, __INTERRUPT__)                 ((__HANDLE__)->Instance->MACIMR |= (__INTERRUPT__))
N
N/**
N  * @brief  Disables the specified Ethernet MAC interrupts.
N  * @param  __HANDLE__   : ETH Handle
N  * @param  __INTERRUPT__: specifies the Ethernet MAC interrupt sources to be
N  *   enabled or disabled.
N  *   This parameter can be any combination of the following values:
N  *     @arg ETH_MAC_IT_TST : Time stamp trigger interrupt 
N  *     @arg ETH_MAC_IT_PMT : PMT interrupt
N  * @retval None
N  */
N#define __HAL_ETH_MAC_DISABLE_IT(__HANDLE__, __INTERRUPT__)                ((__HANDLE__)->Instance->MACIMR &= ~(__INTERRUPT__))
N
N/**
N  * @brief  Initiate a Pause Control Frame (Full-duplex only).
N  * @param  __HANDLE__: ETH Handle
N  * @retval None
N  */
N#define __HAL_ETH_INITIATE_PAUSE_CONTROL_FRAME(__HANDLE__)              ((__HANDLE__)->Instance->MACFCR |= ETH_MACFCR_FCBBPA)
N
N/**
N  * @brief  Checks whether the Ethernet flow control busy bit is set or not.
N  * @param  __HANDLE__: ETH Handle
N  * @retval The new state of flow control busy status bit (SET or RESET).
N  */
N#define __HAL_ETH_GET_FLOW_CONTROL_BUSY_STATUS(__HANDLE__)               (((__HANDLE__)->Instance->MACFCR & ETH_MACFCR_FCBBPA) == ETH_MACFCR_FCBBPA)
N
N/**
N  * @brief  Enables the MAC Back Pressure operation activation (Half-duplex only).
N  * @param  __HANDLE__: ETH Handle
N  * @retval None
N  */
N#define __HAL_ETH_BACK_PRESSURE_ACTIVATION_ENABLE(__HANDLE__)          ((__HANDLE__)->Instance->MACFCR |= ETH_MACFCR_FCBBPA)
N
N/**
N  * @brief  Disables the MAC BackPressure operation activation (Half-duplex only).
N  * @param  __HANDLE__: ETH Handle
N  * @retval None
N  */
N#define __HAL_ETH_BACK_PRESSURE_ACTIVATION_DISABLE(__HANDLE__)         ((__HANDLE__)->Instance->MACFCR &= ~ETH_MACFCR_FCBBPA)
N
N/**
N  * @brief  Checks whether the specified Ethernet MAC flag is set or not.
N  * @param  __HANDLE__: ETH Handle
N  * @param  __FLAG__: specifies the flag to check.
N  *   This parameter can be one of the following values:
N  *     @arg ETH_MAC_FLAG_TST  : Time stamp trigger flag   
N  *     @arg ETH_MAC_FLAG_MMCT : MMC transmit flag  
N  *     @arg ETH_MAC_FLAG_MMCR : MMC receive flag   
N  *     @arg ETH_MAC_FLAG_MMC  : MMC flag  
N  *     @arg ETH_MAC_FLAG_PMT  : PMT flag  
N  * @retval The state of Ethernet MAC flag.
N  */
N#define __HAL_ETH_MAC_GET_FLAG(__HANDLE__, __FLAG__)                   (((__HANDLE__)->Instance->MACSR &( __FLAG__)) == ( __FLAG__))
N
N/** 
N  * @brief  Enables the specified Ethernet DMA interrupts.
N  * @param  __HANDLE__   : ETH Handle
N  * @param  __INTERRUPT__: specifies the Ethernet DMA interrupt sources to be
N  *   enabled @ref ETH_DMA_Interrupts
N  * @retval None
N  */
N#define __HAL_ETH_DMA_ENABLE_IT(__HANDLE__, __INTERRUPT__)                 ((__HANDLE__)->Instance->DMAIER |= (__INTERRUPT__))
N
N/**
N  * @brief  Disables the specified Ethernet DMA interrupts.
N  * @param  __HANDLE__   : ETH Handle
N  * @param  __INTERRUPT__: specifies the Ethernet DMA interrupt sources to be
N  *   disabled. @ref ETH_DMA_Interrupts
N  * @retval None
N  */
N#define __HAL_ETH_DMA_DISABLE_IT(__HANDLE__, __INTERRUPT__)                ((__HANDLE__)->Instance->DMAIER &= ~(__INTERRUPT__))
N
N/**
N  * @brief  Clears the Ethernet DMA IT pending bit.
N  * @param  __HANDLE__   : ETH Handle
N  * @param  __INTERRUPT__: specifies the interrupt pending bit to clear. @ref ETH_DMA_Interrupts
N  * @retval None
N  */
N#define __HAL_ETH_DMA_CLEAR_IT(__HANDLE__, __INTERRUPT__)      ((__HANDLE__)->Instance->DMASR =(__INTERRUPT__))
N
N/**
N  * @brief  Checks whether the specified Ethernet DMA flag is set or not.
N* @param  __HANDLE__: ETH Handle
N  * @param  __FLAG__: specifies the flag to check. @ref ETH_DMA_Flags
N  * @retval The new state of ETH_DMA_FLAG (SET or RESET).
N  */
N#define __HAL_ETH_DMA_GET_FLAG(__HANDLE__, __FLAG__)                   (((__HANDLE__)->Instance->DMASR &( __FLAG__)) == ( __FLAG__))
N
N/**
N  * @brief  Checks whether the specified Ethernet DMA flag is set or not.
N  * @param  __HANDLE__: ETH Handle
N  * @param  __FLAG__: specifies the flag to clear. @ref ETH_DMA_Flags
N  * @retval The new state of ETH_DMA_FLAG (SET or RESET).
N  */
N#define __HAL_ETH_DMA_CLEAR_FLAG(__HANDLE__, __FLAG__)                 ((__HANDLE__)->Instance->DMASR = (__FLAG__))
N
N/**
N  * @brief  Checks whether the specified Ethernet DMA overflow flag is set or not.
N  * @param  __HANDLE__: ETH Handle
N  * @param  __OVERFLOW__: specifies the DMA overflow flag to check.
N  *   This parameter can be one of the following values:
N  *     @arg ETH_DMA_OVERFLOW_RXFIFOCOUNTER : Overflow for FIFO Overflows Counter
N  *     @arg ETH_DMA_OVERFLOW_MISSEDFRAMECOUNTER : Overflow for Buffer Unavailable Missed Frame Counter
N  * @retval The state of Ethernet DMA overflow Flag (SET or RESET).
N  */
N#define __HAL_ETH_GET_DMA_OVERFLOW_STATUS(__HANDLE__, __OVERFLOW__)       (((__HANDLE__)->Instance->DMAMFBOCR & (__OVERFLOW__)) == (__OVERFLOW__))
N
N/**
N  * @brief  Set the DMA Receive status watchdog timer register value
N  * @param  __HANDLE__: ETH Handle
N  * @param  __VALUE__: DMA Receive status watchdog timer register value   
N  * @retval None
N  */
N#define __HAL_ETH_SET_RECEIVE_WATCHDOG_TIMER(__HANDLE__, __VALUE__)       ((__HANDLE__)->Instance->DMARSWTR = (__VALUE__))
N
N/** 
N  * @brief  Enables any unicast packet filtered by the MAC address
N  *   recognition to be a wake-up frame.
N  * @param  __HANDLE__: ETH Handle.
N  * @retval None
N  */
N#define __HAL_ETH_GLOBAL_UNICAST_WAKEUP_ENABLE(__HANDLE__)               ((__HANDLE__)->Instance->MACPMTCSR |= ETH_MACPMTCSR_GU)
N
N/**
N  * @brief  Disables any unicast packet filtered by the MAC address
N  *   recognition to be a wake-up frame.
N  * @param  __HANDLE__: ETH Handle.
N  * @retval None
N  */
N#define __HAL_ETH_GLOBAL_UNICAST_WAKEUP_DISABLE(__HANDLE__)              ((__HANDLE__)->Instance->MACPMTCSR &= ~ETH_MACPMTCSR_GU)
N
N/**
N  * @brief  Enables the MAC Wake-Up Frame Detection.
N  * @param  __HANDLE__: ETH Handle.
N  * @retval None
N  */
N#define __HAL_ETH_WAKEUP_FRAME_DETECTION_ENABLE(__HANDLE__)              ((__HANDLE__)->Instance->MACPMTCSR |= ETH_MACPMTCSR_WFE)
N
N/**
N  * @brief  Disables the MAC Wake-Up Frame Detection.
N  * @param  __HANDLE__: ETH Handle.
N  * @retval None
N  */
N#define __HAL_ETH_WAKEUP_FRAME_DETECTION_DISABLE(__HANDLE__)             ((__HANDLE__)->Instance->MACPMTCSR &= ~ETH_MACPMTCSR_WFE)
N
N/**
N  * @brief  Enables the MAC Magic Packet Detection.
N  * @param  __HANDLE__: ETH Handle.
N  * @retval None
N  */
N#define __HAL_ETH_MAGIC_PACKET_DETECTION_ENABLE(__HANDLE__)              ((__HANDLE__)->Instance->MACPMTCSR |= ETH_MACPMTCSR_MPE)
N
N/**
N  * @brief  Disables the MAC Magic Packet Detection.
N  * @param  __HANDLE__: ETH Handle.
N  * @retval None
N  */
N#define __HAL_ETH_MAGIC_PACKET_DETECTION_DISABLE(__HANDLE__)             ((__HANDLE__)->Instance->MACPMTCSR &= ~ETH_MACPMTCSR_WFE)
N
N/**
N  * @brief  Enables the MAC Power Down.
N  * @param  __HANDLE__: ETH Handle
N  * @retval None
N  */
N#define __HAL_ETH_POWER_DOWN_ENABLE(__HANDLE__)                         ((__HANDLE__)->Instance->MACPMTCSR |= ETH_MACPMTCSR_PD)
N
N/**
N  * @brief  Disables the MAC Power Down.
N  * @param  __HANDLE__: ETH Handle
N  * @retval None
N  */
N#define __HAL_ETH_POWER_DOWN_DISABLE(__HANDLE__)                        ((__HANDLE__)->Instance->MACPMTCSR &= ~ETH_MACPMTCSR_PD)
N
N/**
N  * @brief  Checks whether the specified Ethernet PMT flag is set or not.
N  * @param  __HANDLE__: ETH Handle.
N  * @param  __FLAG__: specifies the flag to check.
N  *   This parameter can be one of the following values:
N  *     @arg ETH_PMT_FLAG_WUFFRPR : Wake-Up Frame Filter Register Pointer Reset 
N  *     @arg ETH_PMT_FLAG_WUFR    : Wake-Up Frame Received 
N  *     @arg ETH_PMT_FLAG_MPR     : Magic Packet Received
N  * @retval The new state of Ethernet PMT Flag (SET or RESET).
N  */
N#define __HAL_ETH_GET_PMT_FLAG_STATUS(__HANDLE__, __FLAG__)               (((__HANDLE__)->Instance->MACPMTCSR &( __FLAG__)) == ( __FLAG__))
N
N/** 
N  * @brief  Preset and Initialize the MMC counters to almost-full value: 0xFFFF_FFF0 (full - 16)
N  * @param   __HANDLE__: ETH Handle.
N  * @retval None
N  */
N#define __HAL_ETH_MMC_COUNTER_FULL_PRESET(__HANDLE__)                     ((__HANDLE__)->Instance->MMCCR |= (ETH_MMCCR_MCFHP | ETH_MMCCR_MCP))
N
N/**
N  * @brief  Preset and Initialize the MMC counters to almost-half value: 0x7FFF_FFF0 (half - 16)
N  * @param  __HANDLE__: ETH Handle.
N  * @retval None
N  */
N#define __HAL_ETH_MMC_COUNTER_HALF_PRESET(__HANDLE__)                     do{(__HANDLE__)->Instance->MMCCR &= ~ETH_MMCCR_MCFHP;\
N                                                                          (__HANDLE__)->Instance->MMCCR |= ETH_MMCCR_MCP;} while (0)
X#define __HAL_ETH_MMC_COUNTER_HALF_PRESET(__HANDLE__)                     do{(__HANDLE__)->Instance->MMCCR &= ~ETH_MMCCR_MCFHP;                                                                          (__HANDLE__)->Instance->MMCCR |= ETH_MMCCR_MCP;} while (0)
N
N/**
N  * @brief  Enables the MMC Counter Freeze.
N  * @param  __HANDLE__: ETH Handle.
N  * @retval None
N  */
N#define __HAL_ETH_MMC_COUNTER_FREEZE_ENABLE(__HANDLE__)                  ((__HANDLE__)->Instance->MMCCR |= ETH_MMCCR_MCF)
N
N/**
N  * @brief  Disables the MMC Counter Freeze.
N  * @param  __HANDLE__: ETH Handle.
N  * @retval None
N  */
N#define __HAL_ETH_MMC_COUNTER_FREEZE_DISABLE(__HANDLE__)                 ((__HANDLE__)->Instance->MMCCR &= ~ETH_MMCCR_MCF)
N
N/**
N  * @brief  Enables the MMC Reset On Read.
N  * @param  __HANDLE__: ETH Handle.
N  * @retval None
N  */
N#define __HAL_ETH_ETH_MMC_RESET_ONREAD_ENABLE(__HANDLE__)                ((__HANDLE__)->Instance->MMCCR |= ETH_MMCCR_ROR)
N
N/**
N  * @brief  Disables the MMC Reset On Read.
N  * @param  __HANDLE__: ETH Handle.
N  * @retval None
N  */
N#define __HAL_ETH_ETH_MMC_RESET_ONREAD_DISABLE(__HANDLE__)               ((__HANDLE__)->Instance->MMCCR &= ~ETH_MMCCR_ROR)
N
N/**
N  * @brief  Enables the MMC Counter Stop Rollover.
N  * @param  __HANDLE__: ETH Handle.
N  * @retval None
N  */
N#define __HAL_ETH_ETH_MMC_COUNTER_ROLLOVER_ENABLE(__HANDLE__)            ((__HANDLE__)->Instance->MMCCR &= ~ETH_MMCCR_CSR)
N
N/**
N  * @brief  Disables the MMC Counter Stop Rollover.
N  * @param  __HANDLE__: ETH Handle.
N  * @retval None
N  */
N#define __HAL_ETH_ETH_MMC_COUNTER_ROLLOVER_DISABLE(__HANDLE__)           ((__HANDLE__)->Instance->MMCCR |= ETH_MMCCR_CSR)
N
N/**
N  * @brief  Resets the MMC Counters.
N  * @param   __HANDLE__: ETH Handle.
N  * @retval None
N  */
N#define __HAL_ETH_MMC_COUNTERS_RESET(__HANDLE__)                         ((__HANDLE__)->Instance->MMCCR |= ETH_MMCCR_CR)
N
N/**
N  * @brief  Enables the specified Ethernet MMC Rx interrupts.
N  * @param   __HANDLE__: ETH Handle.
N  * @param  __INTERRUPT__: specifies the Ethernet MMC interrupt sources to be enabled or disabled.
N  *   This parameter can be one of the following values:  
N  *     @arg ETH_MMC_IT_RGUF  : When Rx good unicast frames counter reaches half the maximum value 
N  *     @arg ETH_MMC_IT_RFAE  : When Rx alignment error counter reaches half the maximum value 
N  *     @arg ETH_MMC_IT_RFCE  : When Rx crc error counter reaches half the maximum value
N  * @retval None
N  */
N#define __HAL_ETH_MMC_RX_IT_ENABLE(__HANDLE__, __INTERRUPT__)               (__HANDLE__)->Instance->MMCRIMR &= ~((__INTERRUPT__) & 0xEFFFFFFF)
N/**
N  * @brief  Disables the specified Ethernet MMC Rx interrupts.
N  * @param   __HANDLE__: ETH Handle.
N  * @param  __INTERRUPT__: specifies the Ethernet MMC interrupt sources to be enabled or disabled.
N  *   This parameter can be one of the following values: 
N  *     @arg ETH_MMC_IT_RGUF  : When Rx good unicast frames counter reaches half the maximum value 
N  *     @arg ETH_MMC_IT_RFAE  : When Rx alignment error counter reaches half the maximum value 
N  *     @arg ETH_MMC_IT_RFCE  : When Rx crc error counter reaches half the maximum value
N  * @retval None
N  */
N#define __HAL_ETH_MMC_RX_IT_DISABLE(__HANDLE__, __INTERRUPT__)              (__HANDLE__)->Instance->MMCRIMR |= ((__INTERRUPT__) & 0xEFFFFFFF)
N/**
N  * @brief  Enables the specified Ethernet MMC Tx interrupts.
N  * @param   __HANDLE__: ETH Handle.
N  * @param  __INTERRUPT__: specifies the Ethernet MMC interrupt sources to be enabled or disabled.
N  *   This parameter can be one of the following values:  
N  *     @arg ETH_MMC_IT_TGF   : When Tx good frame counter reaches half the maximum value 
N  *     @arg ETH_MMC_IT_TGFMSC: When Tx good multi col counter reaches half the maximum value 
N  *     @arg ETH_MMC_IT_TGFSC : When Tx good single col counter reaches half the maximum value 
N  * @retval None
N  */
N#define __HAL_ETH_MMC_TX_IT_ENABLE(__HANDLE__, __INTERRUPT__)            ((__HANDLE__)->Instance->MMCRIMR &= ~ (__INTERRUPT__))
N
N/**
N  * @brief  Disables the specified Ethernet MMC Tx interrupts.
N  * @param   __HANDLE__: ETH Handle.
N  * @param  __INTERRUPT__: specifies the Ethernet MMC interrupt sources to be enabled or disabled.
N  *   This parameter can be one of the following values:  
N  *     @arg ETH_MMC_IT_TGF   : When Tx good frame counter reaches half the maximum value 
N  *     @arg ETH_MMC_IT_TGFMSC: When Tx good multi col counter reaches half the maximum value 
N  *     @arg ETH_MMC_IT_TGFSC : When Tx good single col counter reaches half the maximum value 
N  * @retval None
N  */
N#define __HAL_ETH_MMC_TX_IT_DISABLE(__HANDLE__, __INTERRUPT__)           ((__HANDLE__)->Instance->MMCRIMR |= (__INTERRUPT__))
N
N/**
N  * @brief  Enables the ETH External interrupt line.
N  * @retval None
N  */
N#define __HAL_ETH_WAKEUP_EXTI_ENABLE_IT()    EXTI->IMR |= (ETH_EXTI_LINE_WAKEUP)
N
N/**
N  * @brief  Disables the ETH External interrupt line.
N  * @retval None
N  */
N#define __HAL_ETH_WAKEUP_EXTI_DISABLE_IT()   EXTI->IMR &= ~(ETH_EXTI_LINE_WAKEUP)
N
N/**
N  * @brief Enable event on ETH External event line.
N  * @retval None.
N  */
N#define __HAL_ETH_WAKEUP_EXTI_ENABLE_EVENT()  EXTI->EMR |= (ETH_EXTI_LINE_WAKEUP)
N
N/**
N  * @brief Disable event on ETH External event line
N  * @retval None.
N  */
N#define __HAL_ETH_WAKEUP_EXTI_DISABLE_EVENT() EXTI->EMR &= ~(ETH_EXTI_LINE_WAKEUP)
N
N/**
N  * @brief  Get flag of the ETH External interrupt line.
N  * @retval None
N  */
N#define __HAL_ETH_WAKEUP_EXTI_GET_FLAG()     EXTI->PR & (ETH_EXTI_LINE_WAKEUP)
N
N/**
N  * @brief  Clear flag of the ETH External interrupt line.
N  * @retval None
N  */
N#define __HAL_ETH_WAKEUP_EXTI_CLEAR_FLAG()   EXTI->PR = (ETH_EXTI_LINE_WAKEUP)
N
N/**
N  * @brief  Enables rising edge trigger to the ETH External interrupt line.
N  * @retval None
N  */
N#define __HAL_ETH_WAKEUP_EXTI_ENABLE_RISING_EDGE_TRIGGER()  EXTI->RTSR |= ETH_EXTI_LINE_WAKEUP
N                                                            
N/**
N  * @brief  Disables the rising edge trigger to the ETH External interrupt line.
N  * @retval None
N  */
N#define __HAL_ETH_WAKEUP_EXTI_DISABLE_RISING_EDGE_TRIGGER()  EXTI->RTSR &= ~(ETH_EXTI_LINE_WAKEUP)                                                          
N
N/**
N  * @brief  Enables falling edge trigger to the ETH External interrupt line.
N  * @retval None
N  */                                                      
N#define __HAL_ETH_WAKEUP_EXTI_ENABLE_FALLING_EDGE_TRIGGER()  EXTI->FTSR |= (ETH_EXTI_LINE_WAKEUP)
N
N/**
N  * @brief  Disables falling edge trigger to the ETH External interrupt line.
N  * @retval None
N  */
N#define __HAL_ETH_WAKEUP_EXTI_DISABLE_FALLING_EDGE_TRIGGER()  EXTI->FTSR &= ~(ETH_EXTI_LINE_WAKEUP)
N
N/**
N  * @brief  Enables rising/falling edge trigger to the ETH External interrupt line.
N  * @retval None
N  */
N#define __HAL_ETH_WAKEUP_EXTI_ENABLE_FALLINGRISING_TRIGGER()  EXTI->RTSR |= ETH_EXTI_LINE_WAKEUP;\
N                                                              EXTI->FTSR |= ETH_EXTI_LINE_WAKEUP
X#define __HAL_ETH_WAKEUP_EXTI_ENABLE_FALLINGRISING_TRIGGER()  EXTI->RTSR |= ETH_EXTI_LINE_WAKEUP;                                                              EXTI->FTSR |= ETH_EXTI_LINE_WAKEUP
N
N/**
N  * @brief  Disables rising/falling edge trigger to the ETH External interrupt line.
N  * @retval None
N  */
N#define __HAL_ETH_WAKEUP_EXTI_DISABLE_FALLINGRISING_TRIGGER()  EXTI->RTSR &= ~(ETH_EXTI_LINE_WAKEUP);\
N                                                               EXTI->FTSR &= ~(ETH_EXTI_LINE_WAKEUP)
X#define __HAL_ETH_WAKEUP_EXTI_DISABLE_FALLINGRISING_TRIGGER()  EXTI->RTSR &= ~(ETH_EXTI_LINE_WAKEUP);                                                               EXTI->FTSR &= ~(ETH_EXTI_LINE_WAKEUP)
N
N/**
N  * @brief Generate a Software interrupt on selected EXTI line.
N  * @retval None.
N  */
N#define __HAL_ETH_WAKEUP_EXTI_GENERATE_SWIT()                  EXTI->SWIER|= ETH_EXTI_LINE_WAKEUP
N
N/**
N  * @}
N  */
N/* Exported functions --------------------------------------------------------*/
N
N/** @addtogroup ETH_Exported_Functions
N  * @{
N  */
N
N/* Initialization and de-initialization functions  ****************************/
N
N/** @addtogroup ETH_Exported_Functions_Group1
N  * @{
N  */
NHAL_StatusTypeDef HAL_ETH_Init(ETH_HandleTypeDef *heth);
NHAL_StatusTypeDef HAL_ETH_DeInit(ETH_HandleTypeDef *heth);
Nvoid HAL_ETH_MspInit(ETH_HandleTypeDef *heth);
Nvoid HAL_ETH_MspDeInit(ETH_HandleTypeDef *heth);
NHAL_StatusTypeDef HAL_ETH_DMATxDescListInit(ETH_HandleTypeDef *heth, ETH_DMADescTypeDef *DMATxDescTab, uint8_t* TxBuff, uint32_t TxBuffCount);
NHAL_StatusTypeDef HAL_ETH_DMARxDescListInit(ETH_HandleTypeDef *heth, ETH_DMADescTypeDef *DMARxDescTab, uint8_t *RxBuff, uint32_t RxBuffCount);
N
N/**
N  * @}
N  */
N/* IO operation functions  ****************************************************/
N
N/** @addtogroup ETH_Exported_Functions_Group2
N  * @{
N  */
NHAL_StatusTypeDef HAL_ETH_TransmitFrame(ETH_HandleTypeDef *heth, uint32_t FrameLength);
NHAL_StatusTypeDef HAL_ETH_GetReceivedFrame(ETH_HandleTypeDef *heth);
N/* Communication with PHY functions*/
NHAL_StatusTypeDef HAL_ETH_ReadPHYRegister(ETH_HandleTypeDef *heth, uint16_t PHYReg, uint32_t *RegValue);
NHAL_StatusTypeDef HAL_ETH_WritePHYRegister(ETH_HandleTypeDef *heth, uint16_t PHYReg, uint32_t RegValue);
N/* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_ETH_GetReceivedFrame_IT(ETH_HandleTypeDef *heth);
Nvoid HAL_ETH_IRQHandler(ETH_HandleTypeDef *heth);
N/* Callback in non blocking modes (Interrupt) */
Nvoid HAL_ETH_TxCpltCallback(ETH_HandleTypeDef *heth);
Nvoid HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth);
Nvoid HAL_ETH_ErrorCallback(ETH_HandleTypeDef *heth);
N/**
N  * @}
N  */
N
N/* Peripheral Control functions  **********************************************/
N
N/** @addtogroup ETH_Exported_Functions_Group3
N  * @{
N  */
N
NHAL_StatusTypeDef HAL_ETH_Start(ETH_HandleTypeDef *heth);
NHAL_StatusTypeDef HAL_ETH_Stop(ETH_HandleTypeDef *heth);
NHAL_StatusTypeDef HAL_ETH_ConfigMAC(ETH_HandleTypeDef *heth, ETH_MACInitTypeDef *macconf);
NHAL_StatusTypeDef HAL_ETH_ConfigDMA(ETH_HandleTypeDef *heth, ETH_DMAInitTypeDef *dmaconf);
N/**
N  * @}
N  */ 
N
N/* Peripheral State functions  ************************************************/
N
N/** @addtogroup ETH_Exported_Functions_Group4
N  * @{
N  */
NHAL_ETH_StateTypeDef HAL_ETH_GetState(ETH_HandleTypeDef *heth);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_ETH_H */
N
N
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 295 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_ETH_MODULE_ENABLED */
N
N#ifdef HAL_FLASH_MODULE_ENABLED
N  #include "stm32f7xx_hal_flash.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_flash.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_flash.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of FLASH HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_FLASH_H
N#define __STM32F7xx_HAL_FLASH_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup FLASH
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/ 
N/** @defgroup FLASH_Exported_Types FLASH Exported Types
N  * @{
N  */
N 
N/**
N  * @brief  FLASH Procedure structure definition
N  */
Ntypedef enum 
N{
N  FLASH_PROC_NONE = 0U, 
N  FLASH_PROC_SECTERASE,
N  FLASH_PROC_MASSERASE,
N  FLASH_PROC_PROGRAM
N} FLASH_ProcedureTypeDef;
N
N
N/** 
N  * @brief  FLASH handle Structure definition  
N  */
Ntypedef struct
N{
N  __IO FLASH_ProcedureTypeDef ProcedureOnGoing;   /* Internal variable to indicate which procedure is ongoing or not in IT context */
X  volatile FLASH_ProcedureTypeDef ProcedureOnGoing;    
N  
N  __IO uint32_t               NbSectorsToErase;   /* Internal variable to save the remaining sectors to erase in IT context        */
X  volatile uint32_t               NbSectorsToErase;    
N  
N  __IO uint8_t                VoltageForErase;    /* Internal variable to provide voltage range selected by user in IT context     */
X  volatile uint8_t                VoltageForErase;     
N  
N  __IO uint32_t               Sector;             /* Internal variable to define the current sector which is erasing               */
X  volatile uint32_t               Sector;              
N
N  __IO uint32_t               Address;            /* Internal variable to save address selected for program                        */
X  volatile uint32_t               Address;             
N  
N  HAL_LockTypeDef             Lock;               /* FLASH locking object                                                          */
N
N  __IO uint32_t               ErrorCode;          /* FLASH error code                                                              */
X  volatile uint32_t               ErrorCode;           
N
N}FLASH_ProcessTypeDef;
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup FLASH_Exported_Constants FLASH Exported Constants
N  * @{
N  */  
N
N/** @defgroup FLASH_Error_Code FLASH Error Code
N  * @brief    FLASH Error Code 
N  * @{
N  */ 
N#define HAL_FLASH_ERROR_NONE         ((uint32_t)0x00000000U)    /*!< No error                      */
N#define HAL_FLASH_ERROR_ERS          ((uint32_t)0x00000002U)    /*!< Programming Sequence error    */
N#define HAL_FLASH_ERROR_PGP          ((uint32_t)0x00000004U)    /*!< Programming Parallelism error */
N#define HAL_FLASH_ERROR_PGA          ((uint32_t)0x00000008U)    /*!< Programming Alignment error   */
N#define HAL_FLASH_ERROR_WRP          ((uint32_t)0x00000010U)    /*!< Write protection error        */
N#define HAL_FLASH_ERROR_OPERATION    ((uint32_t)0x00000020U)    /*!< Operation Error               */
N/**
N  * @}
N  */
N  
N/** @defgroup FLASH_Type_Program FLASH Type Program
N  * @{
N  */ 
N#define FLASH_TYPEPROGRAM_BYTE        ((uint32_t)0x00U)  /*!< Program byte (8-bit) at a specified address           */
N#define FLASH_TYPEPROGRAM_HALFWORD    ((uint32_t)0x01U)  /*!< Program a half-word (16-bit) at a specified address   */
N#define FLASH_TYPEPROGRAM_WORD        ((uint32_t)0x02U)  /*!< Program a word (32-bit) at a specified address        */
N#define FLASH_TYPEPROGRAM_DOUBLEWORD  ((uint32_t)0x03U)  /*!< Program a double word (64-bit) at a specified address */
N/**
N  * @}
N  */
N
N/** @defgroup FLASH_Flag_definition FLASH Flag definition
N  * @brief Flag definition
N  * @{
N  */ 
N#define FLASH_FLAG_EOP                 FLASH_SR_EOP            /*!< FLASH End of Operation flag               */
N#define FLASH_FLAG_OPERR               FLASH_SR_OPERR          /*!< FLASH operation Error flag                */
N#define FLASH_FLAG_WRPERR              FLASH_SR_WRPERR         /*!< FLASH Write protected error flag          */
N#define FLASH_FLAG_PGAERR              FLASH_SR_PGAERR         /*!< FLASH Programming Alignment error flag    */
N#define FLASH_FLAG_PGPERR              FLASH_SR_PGPERR         /*!< FLASH Programming Parallelism error flag  */
N#define FLASH_FLAG_ERSERR              FLASH_SR_ERSERR         /*!< FLASH Erasing Sequence error flag         */
N#define FLASH_FLAG_BSY                 FLASH_SR_BSY            /*!< FLASH Busy flag                           */ 
N/**
N  * @}
N  */
N
N/** @defgroup FLASH_Interrupt_definition FLASH Interrupt definition
N  * @brief FLASH Interrupt definition
N  * @{
N  */
N#define FLASH_IT_EOP                   FLASH_CR_EOPIE          /*!< End of FLASH Operation Interrupt source */
N#define FLASH_IT_ERR                   ((uint32_t)0x02000000U)  /*!< Error Interrupt source                  */
N/**
N  * @}
N  */
N
N/** @defgroup FLASH_Program_Parallelism FLASH Program Parallelism
N  * @{
N  */
N#define FLASH_PSIZE_BYTE           ((uint32_t)0x00000000U)
N#define FLASH_PSIZE_HALF_WORD      ((uint32_t)FLASH_CR_PSIZE_0)
N#define FLASH_PSIZE_WORD           ((uint32_t)FLASH_CR_PSIZE_1)
N#define FLASH_PSIZE_DOUBLE_WORD    ((uint32_t)FLASH_CR_PSIZE)
N#define CR_PSIZE_MASK              ((uint32_t)0xFFFFFCFFU)
N/**
N  * @}
N  */ 
N
N/** @defgroup FLASH_Keys FLASH Keys
N  * @{
N  */ 
N#define FLASH_KEY1               ((uint32_t)0x45670123U)
N#define FLASH_KEY2               ((uint32_t)0xCDEF89ABU)
N#define FLASH_OPT_KEY1           ((uint32_t)0x08192A3BU)
N#define FLASH_OPT_KEY2           ((uint32_t)0x4C5D6E7FU)
N/**
N  * @}
N  */
N
N/** @defgroup FLASH_Sectors FLASH Sectors
N  * @{
N  */
N#define FLASH_SECTOR_0           ((uint32_t)0U) /*!< Sector Number 0   */
N#define FLASH_SECTOR_1           ((uint32_t)1U) /*!< Sector Number 1   */
N#define FLASH_SECTOR_2           ((uint32_t)2U) /*!< Sector Number 2   */
N#define FLASH_SECTOR_3           ((uint32_t)3U) /*!< Sector Number 3   */
N#define FLASH_SECTOR_4           ((uint32_t)4U) /*!< Sector Number 4   */
N#define FLASH_SECTOR_5           ((uint32_t)5U) /*!< Sector Number 5   */
N#define FLASH_SECTOR_6           ((uint32_t)6U) /*!< Sector Number 6   */
N#define FLASH_SECTOR_7           ((uint32_t)7U) /*!< Sector Number 7   */
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N  
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup FLASH_Exported_Macros FLASH Exported Macros
N  * @{
N  */
N/**
N  * @brief  Set the FLASH Latency.
N  * @param  __LATENCY__: FLASH Latency                   
N  *         The value of this parameter depend on device used within the same series
N  * @retval none
N  */
N#define __HAL_FLASH_SET_LATENCY(__LATENCY__) \
N                  MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(__LATENCY__))
X#define __HAL_FLASH_SET_LATENCY(__LATENCY__)                   MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(__LATENCY__))
N
N/**
N  * @brief  Get the FLASH Latency.
N  * @retval FLASH Latency                   
N  *          The value of this parameter depend on device used within the same series
N  */ 
N#define __HAL_FLASH_GET_LATENCY()     (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY))
N
N/**
N  * @brief  Enable the FLASH prefetch buffer.
N  * @retval none
N  */ 
N#define __HAL_FLASH_PREFETCH_BUFFER_ENABLE()  (FLASH->ACR |= FLASH_ACR_PRFTEN)
N
N/**
N  * @brief  Disable the FLASH prefetch buffer.
N  * @retval none
N  */ 
N#define __HAL_FLASH_PREFETCH_BUFFER_DISABLE()   (FLASH->ACR &= (~FLASH_ACR_PRFTEN))
N
N/**
N  * @brief  Enable the FLASH Adaptive Real-Time memory accelerator.
N  * @note   The ART accelerator is available only for flash access on ITCM interface.
N  * @retval none
N  */ 
N#define __HAL_FLASH_ART_ENABLE()  SET_BIT(FLASH->ACR, FLASH_ACR_ARTEN)
N
N/**
N  * @brief  Disable the FLASH Adaptive Real-Time memory accelerator.
N  * @retval none
N  */ 
N#define __HAL_FLASH_ART_DISABLE()   CLEAR_BIT(FLASH->ACR, FLASH_ACR_ARTEN)
N
N/**
N  * @brief  Resets the FLASH Adaptive Real-Time memory accelerator.
N  * @note   This function must be used only when the Adaptive Real-Time memory accelerator
N  *         is disabled.  
N  * @retval None
N  */
N#define __HAL_FLASH_ART_RESET()  (FLASH->ACR |= FLASH_ACR_ARTRST)
N
N/**
N  * @brief  Enable the specified FLASH interrupt.
N  * @param  __INTERRUPT__ : FLASH interrupt 
N  *         This parameter can be any combination of the following values:
N  *     @arg FLASH_IT_EOP: End of FLASH Operation Interrupt
N  *     @arg FLASH_IT_ERR: Error Interrupt    
N  * @retval none
N  */  
N#define __HAL_FLASH_ENABLE_IT(__INTERRUPT__)  (FLASH->CR |= (__INTERRUPT__))
N
N/**
N  * @brief  Disable the specified FLASH interrupt.
N  * @param  __INTERRUPT__ : FLASH interrupt 
N  *         This parameter can be any combination of the following values:
N  *     @arg FLASH_IT_EOP: End of FLASH Operation Interrupt
N  *     @arg FLASH_IT_ERR: Error Interrupt    
N  * @retval none
N  */  
N#define __HAL_FLASH_DISABLE_IT(__INTERRUPT__)  (FLASH->CR &= ~(uint32_t)(__INTERRUPT__))
N
N/**
N  * @brief  Get the specified FLASH flag status. 
N  * @param  __FLAG__: specifies the FLASH flag to check.
N  *          This parameter can be one of the following values:
N  *            @arg FLASH_FLAG_EOP   : FLASH End of Operation flag 
N  *            @arg FLASH_FLAG_OPERR : FLASH operation Error flag 
N  *            @arg FLASH_FLAG_WRPERR: FLASH Write protected error flag 
N  *            @arg FLASH_FLAG_PGAERR: FLASH Programming Alignment error flag
N  *            @arg FLASH_FLAG_PGPERR: FLASH Programming Parallelism error flag
N  *            @arg FLASH_FLAG_ERSERR : FLASH Erasing Sequence error flag 
N  *            @arg FLASH_FLAG_BSY   : FLASH Busy flag
N  * @retval The new state of __FLAG__ (SET or RESET).
N  */
N#define __HAL_FLASH_GET_FLAG(__FLAG__)   ((FLASH->SR & (__FLAG__)))
N
N/**
N  * @brief  Clear the specified FLASH flag.
N  * @param  __FLAG__: specifies the FLASH flags to clear.
N  *          This parameter can be any combination of the following values:
N  *            @arg FLASH_FLAG_EOP   : FLASH End of Operation flag 
N  *            @arg FLASH_FLAG_OPERR : FLASH operation Error flag 
N  *            @arg FLASH_FLAG_WRPERR: FLASH Write protected error flag 
N  *            @arg FLASH_FLAG_PGAERR: FLASH Programming Alignment error flag 
N  *            @arg FLASH_FLAG_PGPERR: FLASH Programming Parallelism error flag
N  *            @arg FLASH_FLAG_ERSERR : FLASH Erasing Sequence error flag    
N  * @retval none
N  */
N#define __HAL_FLASH_CLEAR_FLAG(__FLAG__)   (FLASH->SR = (__FLAG__))
N/**
N  * @}
N  */
N
N/* Include FLASH HAL Extension module */
N#include "stm32f7xx_hal_flash_ex.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_flash_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_flash_ex.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of FLASH HAL Extension module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_FLASH_EX_H
N#define __STM32F7xx_HAL_FLASH_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup FLASHEx
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/ 
N/** @defgroup FLASHEx_Exported_Types FLASH Exported Types
N  * @{
N  */
N
N/**
N  * @brief  FLASH Erase structure definition
N  */
Ntypedef struct
N{
N  uint32_t TypeErase;   /*!< Mass erase or sector Erase.
N                             This parameter can be a value of @ref FLASHEx_Type_Erase */
N
N#if defined (FLASH_OPTCR_nDBANK)  
X#if 1L  
N  uint32_t Banks;       /*!< Select banks to erase when Mass erase is enabled.
N                             This parameter must be a value of @ref FLASHEx_Banks */
N#endif /* FLASH_OPTCR_nDBANK */  
N  
N  uint32_t Sector;      /*!< Initial FLASH sector to erase when Mass erase is disabled
N                             This parameter must be a value of @ref FLASHEx_Sectors */
N
N  uint32_t NbSectors;   /*!< Number of sectors to be erased.
N                             This parameter must be a value between 1 and (max number of sectors - value of Initial sector)*/
N
N  uint32_t VoltageRange;/*!< The device voltage range which defines the erase parallelism
N                             This parameter must be a value of @ref FLASHEx_Voltage_Range */
N
N} FLASH_EraseInitTypeDef;
N
N/**
N  * @brief  FLASH Option Bytes Program structure definition
N  */
Ntypedef struct
N{
N  uint32_t OptionType;   /*!< Option byte to be configured.
N                              This parameter can be a value of @ref FLASHEx_Option_Type */
N
N  uint32_t WRPState;     /*!< Write protection activation or deactivation.
N                              This parameter can be a value of @ref FLASHEx_WRP_State */
N
N  uint32_t WRPSector;    /*!< Specifies the sector(s) to be write protected.
N                              The value of this parameter depend on device used within the same series */
N
N  uint32_t RDPLevel;     /*!< Set the read protection level.
N                              This parameter can be a value of @ref FLASHEx_Option_Bytes_Read_Protection */
N
N  uint32_t BORLevel;     /*!< Set the BOR Level.
N                              This parameter can be a value of @ref FLASHEx_BOR_Reset_Level */
N
N  uint32_t USERConfig;   /*!< Program the FLASH User Option Byte: WWDG_SW / IWDG_SW / RST_STOP / RST_STDBY / 
N                              IWDG_FREEZE_STOP / IWDG_FREEZE_SANDBY / nDBANK / nDBOOT.
N                              nDBANK / nDBOOT are only available for STM32F76xxx/STM32F77xxx devices */
N 
N  uint32_t BootAddr0;    /*!< Boot base address when Boot pin = 0.
N                              This parameter can be a value of @ref FLASHEx_Boot_Address */
N
N  uint32_t BootAddr1;    /*!< Boot base address when Boot pin = 1.
N                              This parameter can be a value of @ref FLASHEx_Boot_Address */
N
N} FLASH_OBProgramInitTypeDef;
N
N/**
N  * @}
N  */
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup FLASHEx_Exported_Constants FLASH Exported Constants
N  * @{
N  */
N
N/** @defgroup FLASHEx_Type_Erase FLASH Type Erase
N  * @{
N  */ 
N#define FLASH_TYPEERASE_SECTORS         ((uint32_t)0x00U)  /*!< Sectors erase only          */
N#define FLASH_TYPEERASE_MASSERASE       ((uint32_t)0x01U)  /*!< Flash Mass erase activation */
N/**
N  * @}
N  */
N  
N/** @defgroup FLASHEx_Voltage_Range FLASH Voltage Range
N  * @{
N  */ 
N#define FLASH_VOLTAGE_RANGE_1        ((uint32_t)0x00U)  /*!< Device operating range: 1.8V to 2.1V                */
N#define FLASH_VOLTAGE_RANGE_2        ((uint32_t)0x01U)  /*!< Device operating range: 2.1V to 2.7V                */
N#define FLASH_VOLTAGE_RANGE_3        ((uint32_t)0x02U)  /*!< Device operating range: 2.7V to 3.6V                */
N#define FLASH_VOLTAGE_RANGE_4        ((uint32_t)0x03U)  /*!< Device operating range: 2.7V to 3.6V + External Vpp */
N/**
N  * @}
N  */
N  
N/** @defgroup FLASHEx_WRP_State FLASH WRP State
N  * @{
N  */ 
N#define OB_WRPSTATE_DISABLE       ((uint32_t)0x00U)  /*!< Disable the write protection of the desired bank 1 sectors */
N#define OB_WRPSTATE_ENABLE        ((uint32_t)0x01U)  /*!< Enable the write protection of the desired bank 1 sectors  */
N/**
N  * @}
N  */
N  
N/** @defgroup FLASHEx_Option_Type FLASH Option Type
N  * @{
N  */ 
N#define OPTIONBYTE_WRP         ((uint32_t)0x01U)  /*!< WRP option byte configuration  */
N#define OPTIONBYTE_RDP         ((uint32_t)0x02U)  /*!< RDP option byte configuration  */
N#define OPTIONBYTE_USER        ((uint32_t)0x04U)  /*!< USER option byte configuration */
N#define OPTIONBYTE_BOR         ((uint32_t)0x08U)  /*!< BOR option byte configuration  */
N#define OPTIONBYTE_BOOTADDR_0  ((uint32_t)0x10U)  /*!< Boot 0 Address configuration   */
N#define OPTIONBYTE_BOOTADDR_1  ((uint32_t)0x20U)  /*!< Boot 1 Address configuration   */
N/**
N  * @}
N  */
N  
N/** @defgroup FLASHEx_Option_Bytes_Read_Protection FLASH Option Bytes Read Protection
N  * @{
N  */
N#define OB_RDP_LEVEL_0       ((uint8_t)0xAAU)
N#define OB_RDP_LEVEL_1       ((uint8_t)0x55U)
N#define OB_RDP_LEVEL_2       ((uint8_t)0xCCU)   /*!< Warning: When enabling read protection level 2 
N                                                  it s no more possible to go back to level 1 or 0 */
N/**
N  * @}
N  */ 
N  
N/** @defgroup FLASHEx_Option_Bytes_WWatchdog FLASH Option Bytes WWatchdog
N  * @{
N  */ 
N#define OB_WWDG_SW           ((uint32_t)0x10U)  /*!< Software WWDG selected */
N#define OB_WWDG_HW           ((uint32_t)0x00U)  /*!< Hardware WWDG selected */
N/**
N  * @}
N  */ 
N  
N
N/** @defgroup FLASHEx_Option_Bytes_IWatchdog FLASH Option Bytes IWatchdog
N  * @{
N  */ 
N#define OB_IWDG_SW           ((uint32_t)0x20U)  /*!< Software IWDG selected */
N#define OB_IWDG_HW           ((uint32_t)0x00U)  /*!< Hardware IWDG selected */
N/**
N  * @}
N  */ 
N
N/** @defgroup FLASHEx_Option_Bytes_nRST_STOP FLASH Option Bytes nRST_STOP
N  * @{
N  */ 
N#define OB_STOP_NO_RST       ((uint32_t)0x40U) /*!< No reset generated when entering in STOP */
N#define OB_STOP_RST          ((uint32_t)0x00U) /*!< Reset generated when entering in STOP    */
N/**
N  * @}
N  */ 
N
N/** @defgroup FLASHEx_Option_Bytes_nRST_STDBY FLASH Option Bytes nRST_STDBY
N  * @{
N  */                               
N#define OB_STDBY_NO_RST      ((uint32_t)0x80U) /*!< No reset generated when entering in STANDBY */
N#define OB_STDBY_RST         ((uint32_t)0x00U) /*!< Reset generated when entering in STANDBY    */
N/**
N  * @}
N  */
N
N/** @defgroup FLASHEx_Option_Bytes_IWDG_FREEZE_STOP FLASH IWDG Counter Freeze in STOP
N  * @{
N  */
N#define OB_IWDG_STOP_FREEZE      ((uint32_t)0x00000000U) /*!< Freeze IWDG counter in STOP mode */
N#define OB_IWDG_STOP_ACTIVE      ((uint32_t)0x80000000U) /*!< IWDG counter active in STOP mode */
N/**
N  * @}
N  */
N
N/** @defgroup FLASHEx_Option_Bytes_IWDG_FREEZE_SANDBY FLASH IWDG Counter Freeze in STANDBY
N  * @{
N  */
N#define OB_IWDG_STDBY_FREEZE      ((uint32_t)0x00000000U) /*!< Freeze IWDG counter in STANDBY mode */
N#define OB_IWDG_STDBY_ACTIVE      ((uint32_t)0x40000000U) /*!< IWDG counter active in STANDBY mode */
N/**
N  * @}
N  */
N
N/** @defgroup FLASHEx_BOR_Reset_Level FLASH BOR Reset Level
N  * @{
N  */
N#define OB_BOR_LEVEL3          ((uint32_t)0x00U)  /*!< Supply voltage ranges from 2.70 to 3.60 V */
N#define OB_BOR_LEVEL2          ((uint32_t)0x04U)  /*!< Supply voltage ranges from 2.40 to 2.70 V */
N#define OB_BOR_LEVEL1          ((uint32_t)0x08U)  /*!< Supply voltage ranges from 2.10 to 2.40 V */
N#define OB_BOR_OFF             ((uint32_t)0x0CU)  /*!< Supply voltage ranges from 1.62 to 2.10 V */
N/**
N  * @}
N  */
N
N#if defined (FLASH_OPTCR_nDBOOT)
X#if 1L
N/** @defgroup FLASHEx_Option_Bytes_nDBOOT FLASH Option Bytes nDBOOT
N  * @{
N  */                               
N#define OB_DUAL_BOOT_DISABLE      ((uint32_t)0x10000000U) /* !< Dual Boot disable. Boot according to boot address option */
N#define OB_DUAL_BOOT_ENABLE       ((uint32_t)0x00000000U) /* !< Dual Boot enable. Boot always from system memory if boot address in flash 
N                                                              (Dual bank Boot mode), or RAM if Boot address option in RAM    */
N/**
N  * @}
N  */  
N#endif /* FLASH_OPTCR_nDBOOT */
N
N#if defined (FLASH_OPTCR_nDBANK)
X#if 1L
N/** @defgroup FLASHEx_Option_Bytes_nDBank FLASH Single Bank or Dual Bank
N  * @{
N  */
N#define OB_NDBANK_SINGLE_BANK      ((uint32_t)0x20000000U) /*!< NDBANK bit is set : Single Bank mode */
N#define OB_NDBANK_DUAL_BANK        ((uint32_t)0x00000000U) /*!< NDBANK bit is reset : Dual Bank mode */
N/**
N  * @}
N  */
N#endif /* FLASH_OPTCR_nDBANK */
N
N/** @defgroup FLASHEx_Boot_Address FLASH Boot Address
N  * @{
N  */
N#define OB_BOOTADDR_ITCM_RAM         ((uint32_t)0x0000U)  /*!< Boot from ITCM RAM (0x00000000)                 */
N#define OB_BOOTADDR_SYSTEM           ((uint32_t)0x0040U)  /*!< Boot from System memory bootloader (0x00100000) */
N#define OB_BOOTADDR_ITCM_FLASH       ((uint32_t)0x0080U)  /*!< Boot from Flash on ITCM interface (0x00200000)  */
N#define OB_BOOTADDR_AXIM_FLASH       ((uint32_t)0x2000U)  /*!< Boot from Flash on AXIM interface (0x08000000)  */
N#define OB_BOOTADDR_DTCM_RAM         ((uint32_t)0x8000U)  /*!< Boot from DTCM RAM (0x20000000)                 */
N#define OB_BOOTADDR_SRAM1            ((uint32_t)0x8004U)  /*!< Boot from SRAM1 (0x20010000)                    */
N#define OB_BOOTADDR_SRAM2            ((uint32_t)0x8013U)  /*!< Boot from SRAM2 (0x2004C000)                    */
N/**
N  * @}
N  */
N  
N/** @defgroup FLASH_Latency FLASH Latency
N  * @{
N  */
N#define FLASH_LATENCY_0                FLASH_ACR_LATENCY_0WS   /*!< FLASH Zero Latency cycle      */
N#define FLASH_LATENCY_1                FLASH_ACR_LATENCY_1WS   /*!< FLASH One Latency cycle       */
N#define FLASH_LATENCY_2                FLASH_ACR_LATENCY_2WS   /*!< FLASH Two Latency cycles      */
N#define FLASH_LATENCY_3                FLASH_ACR_LATENCY_3WS   /*!< FLASH Three Latency cycles    */
N#define FLASH_LATENCY_4                FLASH_ACR_LATENCY_4WS   /*!< FLASH Four Latency cycles     */
N#define FLASH_LATENCY_5                FLASH_ACR_LATENCY_5WS   /*!< FLASH Five Latency cycles     */
N#define FLASH_LATENCY_6                FLASH_ACR_LATENCY_6WS   /*!< FLASH Six Latency cycles      */
N#define FLASH_LATENCY_7                FLASH_ACR_LATENCY_7WS   /*!< FLASH Seven Latency cycles    */
N#define FLASH_LATENCY_8                FLASH_ACR_LATENCY_8WS   /*!< FLASH Eight Latency cycles    */
N#define FLASH_LATENCY_9                FLASH_ACR_LATENCY_9WS   /*!< FLASH Nine Latency cycles     */
N#define FLASH_LATENCY_10               FLASH_ACR_LATENCY_10WS  /*!< FLASH Ten Latency cycles      */
N#define FLASH_LATENCY_11               FLASH_ACR_LATENCY_11WS  /*!< FLASH Eleven Latency cycles   */
N#define FLASH_LATENCY_12               FLASH_ACR_LATENCY_12WS  /*!< FLASH Twelve Latency cycles   */
N#define FLASH_LATENCY_13               FLASH_ACR_LATENCY_13WS  /*!< FLASH Thirteen Latency cycles */
N#define FLASH_LATENCY_14               FLASH_ACR_LATENCY_14WS  /*!< FLASH Fourteen Latency cycles */
N#define FLASH_LATENCY_15               FLASH_ACR_LATENCY_15WS  /*!< FLASH Fifteen Latency cycles  */
N/**
N  * @}
N  */
N
N#if defined (FLASH_OPTCR_nDBANK)
X#if 1L
N/** @defgroup FLASHEx_Banks FLASH Banks
N  * @{
N  */
N#define FLASH_BANK_1                       ((uint32_t)0x01U)                          /*!< Bank 1   */
N#define FLASH_BANK_2                       ((uint32_t)0x02U)                          /*!< Bank 2   */
N#define FLASH_BANK_BOTH                    ((uint32_t)(FLASH_BANK_1 | FLASH_BANK_2)) /*!< Bank1 and Bank2  */
N/**
N  * @}
N  */
N#endif /* FLASH_OPTCR_nDBANK */
N
N/** @defgroup FLASHEx_MassErase_bit FLASH Mass Erase bit
N  * @{
N  */
N#if defined (FLASH_OPTCR_nDBANK)
X#if 1L
N#define FLASH_MER_BIT     (FLASH_CR_MER1 | FLASH_CR_MER2) /*!< 2 MER bits */
N#else
S#define FLASH_MER_BIT     (FLASH_CR_MER) /*!< only 1 MER bit */
N#endif /* FLASH_OPTCR_nDBANK */
N/**
N  * @}
N  */
N
N/** @defgroup FLASHEx_Sectors FLASH Sectors
N  * @{
N  */
N#if (FLASH_SECTOR_TOTAL == 24)
X#if (24 == 24)
N#define FLASH_SECTOR_8     ((uint32_t)8U)  /*!< Sector Number 8   */
N#define FLASH_SECTOR_9     ((uint32_t)9U)  /*!< Sector Number 9   */
N#define FLASH_SECTOR_10    ((uint32_t)10U) /*!< Sector Number 10  */
N#define FLASH_SECTOR_11    ((uint32_t)11U) /*!< Sector Number 11  */
N#define FLASH_SECTOR_12    ((uint32_t)12U) /*!< Sector Number 12  */
N#define FLASH_SECTOR_13    ((uint32_t)13U) /*!< Sector Number 13  */
N#define FLASH_SECTOR_14    ((uint32_t)14U) /*!< Sector Number 14  */
N#define FLASH_SECTOR_15    ((uint32_t)15U) /*!< Sector Number 15  */
N#define FLASH_SECTOR_16    ((uint32_t)16U) /*!< Sector Number 16  */
N#define FLASH_SECTOR_17    ((uint32_t)17U) /*!< Sector Number 17  */
N#define FLASH_SECTOR_18    ((uint32_t)18U) /*!< Sector Number 18  */
N#define FLASH_SECTOR_19    ((uint32_t)19U) /*!< Sector Number 19  */
N#define FLASH_SECTOR_20    ((uint32_t)20U) /*!< Sector Number 20  */
N#define FLASH_SECTOR_21    ((uint32_t)21U) /*!< Sector Number 21  */
N#define FLASH_SECTOR_22    ((uint32_t)22U) /*!< Sector Number 22  */
N#define FLASH_SECTOR_23    ((uint32_t)23U) /*!< Sector Number 23  */
N#endif /* FLASH_SECTOR_TOTAL == 24 */
N/**
N  * @}
N  */ 
N
N#if (FLASH_SECTOR_TOTAL == 24)
X#if (24 == 24)
N/** @defgroup FLASHEx_Option_Bytes_Write_Protection FLASH Option Bytes Write Protection
N  * @note For Single Bank mode, use OB_WRP_SECTOR_x defines: In fact, in FLASH_OPTCR register,
N  *       nWRP[11:0] bits contain the value of the write-protection option bytes for sectors 0 to 11.
N  *       For Dual Bank mode, use OB_WRP_DB_SECTOR_x defines: In fact, in FLASH_OPTCR register,
N  *       nWRP[11:0] bits are divided on two groups, one group dedicated for bank 1 and 
N  *       a second one dedicated for bank 2 (nWRP[i] activates Write protection on sector 2*i and 2*i+1).
N  *       This behavior is applicable only for STM32F76xxx / STM32F77xxx devices.
N  * @{
N  */
N/* Single Bank Sectors */
N#define OB_WRP_SECTOR_0       ((uint32_t)0x00010000U) /*!< Write protection of Single Bank Sector0   */
N#define OB_WRP_SECTOR_1       ((uint32_t)0x00020000U) /*!< Write protection of Single Bank Sector1   */
N#define OB_WRP_SECTOR_2       ((uint32_t)0x00040000U) /*!< Write protection of Single Bank Sector2   */
N#define OB_WRP_SECTOR_3       ((uint32_t)0x00080000U) /*!< Write protection of Single Bank Sector3   */
N#define OB_WRP_SECTOR_4       ((uint32_t)0x00100000U) /*!< Write protection of Single Bank Sector4   */
N#define OB_WRP_SECTOR_5       ((uint32_t)0x00200000U) /*!< Write protection of Single Bank Sector5   */
N#define OB_WRP_SECTOR_6       ((uint32_t)0x00400000U) /*!< Write protection of Single Bank Sector6   */
N#define OB_WRP_SECTOR_7       ((uint32_t)0x00800000U) /*!< Write protection of Single Bank Sector7   */
N#define OB_WRP_SECTOR_8       ((uint32_t)0x01000000U) /*!< Write protection of Single Bank Sector8   */
N#define OB_WRP_SECTOR_9       ((uint32_t)0x02000000U) /*!< Write protection of Single Bank Sector9   */
N#define OB_WRP_SECTOR_10      ((uint32_t)0x04000000U) /*!< Write protection of Single Bank Sector10  */
N#define OB_WRP_SECTOR_11      ((uint32_t)0x08000000U) /*!< Write protection of Single Bank Sector11  */   
N#define OB_WRP_SECTOR_All     ((uint32_t)0x0FFF0000U) /*!< Write protection of all Sectors for Single Bank Flash */
N
N/* Dual Bank Sectors */
N#define OB_WRP_DB_SECTOR_0    ((uint32_t)0x00010000U) /*!< Write protection of Dual Bank Sector0     */
N#define OB_WRP_DB_SECTOR_1    ((uint32_t)0x00010000U) /*!< Write protection of Dual Bank Sector1     */
N#define OB_WRP_DB_SECTOR_2    ((uint32_t)0x00020000U) /*!< Write protection of Dual Bank Sector2     */
N#define OB_WRP_DB_SECTOR_3    ((uint32_t)0x00020000U) /*!< Write protection of Dual Bank Sector3     */
N#define OB_WRP_DB_SECTOR_4    ((uint32_t)0x00040000U) /*!< Write protection of Dual Bank Sector4     */
N#define OB_WRP_DB_SECTOR_5    ((uint32_t)0x00040000U) /*!< Write protection of Dual Bank Sector5     */
N#define OB_WRP_DB_SECTOR_6    ((uint32_t)0x00080000U) /*!< Write protection of Dual Bank Sector6     */
N#define OB_WRP_DB_SECTOR_7    ((uint32_t)0x00080000U) /*!< Write protection of Dual Bank Sector7     */
N#define OB_WRP_DB_SECTOR_8    ((uint32_t)0x00100000U) /*!< Write protection of Dual Bank Sector8     */
N#define OB_WRP_DB_SECTOR_9    ((uint32_t)0x00100000U) /*!< Write protection of Dual Bank Sector9     */
N#define OB_WRP_DB_SECTOR_10   ((uint32_t)0x00200000U) /*!< Write protection of Dual Bank Sector10    */
N#define OB_WRP_DB_SECTOR_11   ((uint32_t)0x00200000U) /*!< Write protection of Dual Bank Sector11    */    
N#define OB_WRP_DB_SECTOR_12   ((uint32_t)0x00400000U) /*!< Write protection of Dual Bank Sector12    */
N#define OB_WRP_DB_SECTOR_13   ((uint32_t)0x00400000U) /*!< Write protection of Dual Bank Sector13    */
N#define OB_WRP_DB_SECTOR_14   ((uint32_t)0x00800000U) /*!< Write protection of Dual Bank Sector14    */
N#define OB_WRP_DB_SECTOR_15   ((uint32_t)0x00800000U) /*!< Write protection of Dual Bank Sector15    */
N#define OB_WRP_DB_SECTOR_16   ((uint32_t)0x01000000U) /*!< Write protection of Dual Bank Sector16    */
N#define OB_WRP_DB_SECTOR_17   ((uint32_t)0x01000000U) /*!< Write protection of Dual Bank Sector17    */
N#define OB_WRP_DB_SECTOR_18   ((uint32_t)0x02000000U) /*!< Write protection of Dual Bank Sector18    */
N#define OB_WRP_DB_SECTOR_19   ((uint32_t)0x02000000U) /*!< Write protection of Dual Bank Sector19    */
N#define OB_WRP_DB_SECTOR_20   ((uint32_t)0x04000000U) /*!< Write protection of Dual Bank Sector20    */
N#define OB_WRP_DB_SECTOR_21   ((uint32_t)0x04000000U) /*!< Write protection of Dual Bank Sector21    */
N#define OB_WRP_DB_SECTOR_22   ((uint32_t)0x08000000U) /*!< Write protection of Dual Bank Sector22    */
N#define OB_WRP_DB_SECTOR_23   ((uint32_t)0x08000000U) /*!< Write protection of Dual Bank Sector23    */
N#define OB_WRP_DB_SECTOR_All  ((uint32_t)0x0FFF0000U) /*!< Write protection of all Sectors for Dual Bank Flash */
N/**
N  * @}
N  */
N#endif /* FLASH_SECTOR_TOTAL == 24 */
N    
N#if (FLASH_SECTOR_TOTAL == 8)
X#if (24 == 8)
S/** @defgroup FLASHEx_Option_Bytes_Write_Protection FLASH Option Bytes Write Protection
S  * @{
S  */
S#define OB_WRP_SECTOR_0       ((uint32_t)0x00010000U) /*!< Write protection of Sector0     */
S#define OB_WRP_SECTOR_1       ((uint32_t)0x00020000U) /*!< Write protection of Sector1     */
S#define OB_WRP_SECTOR_2       ((uint32_t)0x00040000U) /*!< Write protection of Sector2     */
S#define OB_WRP_SECTOR_3       ((uint32_t)0x00080000U) /*!< Write protection of Sector3     */
S#define OB_WRP_SECTOR_4       ((uint32_t)0x00100000U) /*!< Write protection of Sector4     */
S#define OB_WRP_SECTOR_5       ((uint32_t)0x00200000U) /*!< Write protection of Sector5     */
S#define OB_WRP_SECTOR_6       ((uint32_t)0x00400000U) /*!< Write protection of Sector6     */
S#define OB_WRP_SECTOR_7       ((uint32_t)0x00800000U) /*!< Write protection of Sector7     */
S#define OB_WRP_SECTOR_All     ((uint32_t)0x00FF0000U) /*!< Write protection of all Sectors */
S/**
S  * @}
S  */
N#endif /* FLASH_SECTOR_TOTAL == 8 */
N
N/**
N  * @}
N  */ 
N  
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup FLASH_Exported_Macros FLASH Exported Macros
N  * @{
N  */
N/**
N  * @brief  Calculate the FLASH Boot Base Adress (BOOT_ADD0 or BOOT_ADD1)
N  * @note   Returned value BOOT_ADDx[15:0] corresponds to boot address [29:14].
N  * @param  __ADDRESS__: FLASH Boot Address (in the range 0x0000 0000 to 0x2004 FFFF with a granularity of 16KB)
N  * @retval The FLASH Boot Base Adress
N  */
N#define __HAL_FLASH_CALC_BOOT_BASE_ADR(__ADDRESS__) ((__ADDRESS__) >> 14)
N /**
N  * @}
N  */
N                    
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup FLASHEx_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup FLASHEx_Exported_Functions_Group1
N  * @{
N  */
N/* Extension Program operation functions  *************************************/
NHAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *SectorError);
NHAL_StatusTypeDef HAL_FLASHEx_Erase_IT(FLASH_EraseInitTypeDef *pEraseInit);
NHAL_StatusTypeDef HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit);
Nvoid              HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit);
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup FLASHEx_Private_Macros FLASH Private Macros
N  * @{
N  */
N
N/** @defgroup FLASHEx_IS_FLASH_Definitions FLASH Private macros to check input parameters
N  * @{
N  */
N
N#define IS_FLASH_TYPEERASE(VALUE)(((VALUE) == FLASH_TYPEERASE_SECTORS) || \
N                                  ((VALUE) == FLASH_TYPEERASE_MASSERASE))  
X#define IS_FLASH_TYPEERASE(VALUE)(((VALUE) == FLASH_TYPEERASE_SECTORS) ||                                   ((VALUE) == FLASH_TYPEERASE_MASSERASE))  
N
N#define IS_VOLTAGERANGE(RANGE)(((RANGE) == FLASH_VOLTAGE_RANGE_1) || \
N                               ((RANGE) == FLASH_VOLTAGE_RANGE_2) || \
N                               ((RANGE) == FLASH_VOLTAGE_RANGE_3) || \
N                               ((RANGE) == FLASH_VOLTAGE_RANGE_4))  
X#define IS_VOLTAGERANGE(RANGE)(((RANGE) == FLASH_VOLTAGE_RANGE_1) ||                                ((RANGE) == FLASH_VOLTAGE_RANGE_2) ||                                ((RANGE) == FLASH_VOLTAGE_RANGE_3) ||                                ((RANGE) == FLASH_VOLTAGE_RANGE_4))  
N
N#define IS_WRPSTATE(VALUE)(((VALUE) == OB_WRPSTATE_DISABLE) || \
N                           ((VALUE) == OB_WRPSTATE_ENABLE))  
X#define IS_WRPSTATE(VALUE)(((VALUE) == OB_WRPSTATE_DISABLE) ||                            ((VALUE) == OB_WRPSTATE_ENABLE))  
N
N#define IS_OPTIONBYTE(VALUE)(((VALUE) <= (OPTIONBYTE_WRP | OPTIONBYTE_RDP        | OPTIONBYTE_USER |\
N                                          OPTIONBYTE_BOR | OPTIONBYTE_BOOTADDR_0 | OPTIONBYTE_BOOTADDR_1)))
X#define IS_OPTIONBYTE(VALUE)(((VALUE) <= (OPTIONBYTE_WRP | OPTIONBYTE_RDP        | OPTIONBYTE_USER |                                          OPTIONBYTE_BOR | OPTIONBYTE_BOOTADDR_0 | OPTIONBYTE_BOOTADDR_1)))
N
N#define IS_OB_BOOT_ADDRESS(ADDRESS) ((ADDRESS) <= 0x8013)
N
N#define IS_OB_RDP_LEVEL(LEVEL) (((LEVEL) == OB_RDP_LEVEL_0)   ||\
N                                ((LEVEL) == OB_RDP_LEVEL_1)   ||\
N                                ((LEVEL) == OB_RDP_LEVEL_2))
X#define IS_OB_RDP_LEVEL(LEVEL) (((LEVEL) == OB_RDP_LEVEL_0)   ||                                ((LEVEL) == OB_RDP_LEVEL_1)   ||                                ((LEVEL) == OB_RDP_LEVEL_2))
N
N#define IS_OB_WWDG_SOURCE(SOURCE) (((SOURCE) == OB_WWDG_SW) || ((SOURCE) == OB_WWDG_HW))
N
N#define IS_OB_IWDG_SOURCE(SOURCE) (((SOURCE) == OB_IWDG_SW) || ((SOURCE) == OB_IWDG_HW))
N
N#define IS_OB_STOP_SOURCE(SOURCE) (((SOURCE) == OB_STOP_NO_RST) || ((SOURCE) == OB_STOP_RST))
N
N#define IS_OB_STDBY_SOURCE(SOURCE) (((SOURCE) == OB_STDBY_NO_RST) || ((SOURCE) == OB_STDBY_RST))
N
N#define IS_OB_IWDG_STOP_FREEZE(FREEZE) (((FREEZE) == OB_IWDG_STOP_FREEZE) || ((FREEZE) == OB_IWDG_STOP_ACTIVE))
N
N#define IS_OB_IWDG_STDBY_FREEZE(FREEZE) (((FREEZE) == OB_IWDG_STDBY_FREEZE) || ((FREEZE) == OB_IWDG_STDBY_ACTIVE))
N
N#define IS_OB_BOR_LEVEL(LEVEL) (((LEVEL) == OB_BOR_LEVEL1) || ((LEVEL) == OB_BOR_LEVEL2) ||\
N                                ((LEVEL) == OB_BOR_LEVEL3) || ((LEVEL) == OB_BOR_OFF))
X#define IS_OB_BOR_LEVEL(LEVEL) (((LEVEL) == OB_BOR_LEVEL1) || ((LEVEL) == OB_BOR_LEVEL2) ||                                ((LEVEL) == OB_BOR_LEVEL3) || ((LEVEL) == OB_BOR_OFF))
N
N#define IS_FLASH_LATENCY(LATENCY) (((LATENCY) == FLASH_LATENCY_0)  || \
N                                   ((LATENCY) == FLASH_LATENCY_1)  || \
N                                   ((LATENCY) == FLASH_LATENCY_2)  || \
N                                   ((LATENCY) == FLASH_LATENCY_3)  || \
N                                   ((LATENCY) == FLASH_LATENCY_4)  || \
N                                   ((LATENCY) == FLASH_LATENCY_5)  || \
N                                   ((LATENCY) == FLASH_LATENCY_6)  || \
N                                   ((LATENCY) == FLASH_LATENCY_7)  || \
N                                   ((LATENCY) == FLASH_LATENCY_8)  || \
N                                   ((LATENCY) == FLASH_LATENCY_9)  || \
N                                   ((LATENCY) == FLASH_LATENCY_10) || \
N                                   ((LATENCY) == FLASH_LATENCY_11) || \
N                                   ((LATENCY) == FLASH_LATENCY_12) || \
N                                   ((LATENCY) == FLASH_LATENCY_13) || \
N                                   ((LATENCY) == FLASH_LATENCY_14) || \
N                                   ((LATENCY) == FLASH_LATENCY_15))
X#define IS_FLASH_LATENCY(LATENCY) (((LATENCY) == FLASH_LATENCY_0)  ||                                    ((LATENCY) == FLASH_LATENCY_1)  ||                                    ((LATENCY) == FLASH_LATENCY_2)  ||                                    ((LATENCY) == FLASH_LATENCY_3)  ||                                    ((LATENCY) == FLASH_LATENCY_4)  ||                                    ((LATENCY) == FLASH_LATENCY_5)  ||                                    ((LATENCY) == FLASH_LATENCY_6)  ||                                    ((LATENCY) == FLASH_LATENCY_7)  ||                                    ((LATENCY) == FLASH_LATENCY_8)  ||                                    ((LATENCY) == FLASH_LATENCY_9)  ||                                    ((LATENCY) == FLASH_LATENCY_10) ||                                    ((LATENCY) == FLASH_LATENCY_11) ||                                    ((LATENCY) == FLASH_LATENCY_12) ||                                    ((LATENCY) == FLASH_LATENCY_13) ||                                    ((LATENCY) == FLASH_LATENCY_14) ||                                    ((LATENCY) == FLASH_LATENCY_15))
N
N#define IS_FLASH_ADDRESS(ADDRESS) (((ADDRESS) >= FLASH_BASE) && ((ADDRESS) <= FLASH_END))
N
N#define IS_FLASH_NBSECTORS(NBSECTORS) (((NBSECTORS) != 0U) && ((NBSECTORS) <= FLASH_SECTOR_TOTAL))
N
N#if (FLASH_SECTOR_TOTAL == 8)
X#if (24 == 8)
S#define IS_FLASH_SECTOR(SECTOR) (((SECTOR) == FLASH_SECTOR_0)   || ((SECTOR) == FLASH_SECTOR_1)   ||\
S                                 ((SECTOR) == FLASH_SECTOR_2)   || ((SECTOR) == FLASH_SECTOR_3)   ||\
S                                 ((SECTOR) == FLASH_SECTOR_4)   || ((SECTOR) == FLASH_SECTOR_5)   ||\
S                                 ((SECTOR) == FLASH_SECTOR_6)   || ((SECTOR) == FLASH_SECTOR_7))
X#define IS_FLASH_SECTOR(SECTOR) (((SECTOR) == FLASH_SECTOR_0)   || ((SECTOR) == FLASH_SECTOR_1)   ||                                 ((SECTOR) == FLASH_SECTOR_2)   || ((SECTOR) == FLASH_SECTOR_3)   ||                                 ((SECTOR) == FLASH_SECTOR_4)   || ((SECTOR) == FLASH_SECTOR_5)   ||                                 ((SECTOR) == FLASH_SECTOR_6)   || ((SECTOR) == FLASH_SECTOR_7))
S
S#define IS_OB_WRP_SECTOR(SECTOR)  ((((SECTOR) & (uint32_t)0xFF00FFFF) == 0x00000000U) && ((SECTOR) != 0x00000000U))
N#endif /* FLASH_SECTOR_TOTAL == 8 */
N
N#if (FLASH_SECTOR_TOTAL == 24)
X#if (24 == 24)
N#define IS_FLASH_SECTOR(SECTOR) (((SECTOR) == FLASH_SECTOR_0)   || ((SECTOR) == FLASH_SECTOR_1)   ||\
N                                 ((SECTOR) == FLASH_SECTOR_2)   || ((SECTOR) == FLASH_SECTOR_3)   ||\
N                                 ((SECTOR) == FLASH_SECTOR_4)   || ((SECTOR) == FLASH_SECTOR_5)   ||\
N                                 ((SECTOR) == FLASH_SECTOR_6)   || ((SECTOR) == FLASH_SECTOR_7)   ||\
N                                 ((SECTOR) == FLASH_SECTOR_8)   || ((SECTOR) == FLASH_SECTOR_9)   ||\
N                                 ((SECTOR) == FLASH_SECTOR_10)  || ((SECTOR) == FLASH_SECTOR_11)  ||\
N                                 ((SECTOR) == FLASH_SECTOR_12)  || ((SECTOR) == FLASH_SECTOR_13)  ||\
N                                 ((SECTOR) == FLASH_SECTOR_14)  || ((SECTOR) == FLASH_SECTOR_15)  ||\
N                                 ((SECTOR) == FLASH_SECTOR_16)  || ((SECTOR) == FLASH_SECTOR_17)  ||\
N                                 ((SECTOR) == FLASH_SECTOR_18)  || ((SECTOR) == FLASH_SECTOR_19)  ||\
N                                 ((SECTOR) == FLASH_SECTOR_20)  || ((SECTOR) == FLASH_SECTOR_21)  ||\
N                                 ((SECTOR) == FLASH_SECTOR_22)  || ((SECTOR) == FLASH_SECTOR_23))
X#define IS_FLASH_SECTOR(SECTOR) (((SECTOR) == FLASH_SECTOR_0)   || ((SECTOR) == FLASH_SECTOR_1)   ||                                 ((SECTOR) == FLASH_SECTOR_2)   || ((SECTOR) == FLASH_SECTOR_3)   ||                                 ((SECTOR) == FLASH_SECTOR_4)   || ((SECTOR) == FLASH_SECTOR_5)   ||                                 ((SECTOR) == FLASH_SECTOR_6)   || ((SECTOR) == FLASH_SECTOR_7)   ||                                 ((SECTOR) == FLASH_SECTOR_8)   || ((SECTOR) == FLASH_SECTOR_9)   ||                                 ((SECTOR) == FLASH_SECTOR_10)  || ((SECTOR) == FLASH_SECTOR_11)  ||                                 ((SECTOR) == FLASH_SECTOR_12)  || ((SECTOR) == FLASH_SECTOR_13)  ||                                 ((SECTOR) == FLASH_SECTOR_14)  || ((SECTOR) == FLASH_SECTOR_15)  ||                                 ((SECTOR) == FLASH_SECTOR_16)  || ((SECTOR) == FLASH_SECTOR_17)  ||                                 ((SECTOR) == FLASH_SECTOR_18)  || ((SECTOR) == FLASH_SECTOR_19)  ||                                 ((SECTOR) == FLASH_SECTOR_20)  || ((SECTOR) == FLASH_SECTOR_21)  ||                                 ((SECTOR) == FLASH_SECTOR_22)  || ((SECTOR) == FLASH_SECTOR_23))
N
N#define IS_OB_WRP_SECTOR(SECTOR)  ((((SECTOR) & (uint32_t)0xF000FFFFU) == 0x00000000U) && ((SECTOR) != 0x00000000U))
N#endif /* FLASH_SECTOR_TOTAL == 24 */
N
N#if defined (FLASH_OPTCR_nDBANK)
X#if 1L
N#define IS_OB_NDBANK(VALUE)        (((VALUE) == OB_NDBANK_SINGLE_BANK) || \
N                                    ((VALUE) == OB_NDBANK_DUAL_BANK))
X#define IS_OB_NDBANK(VALUE)        (((VALUE) == OB_NDBANK_SINGLE_BANK) ||                                     ((VALUE) == OB_NDBANK_DUAL_BANK))
N
N#define IS_FLASH_BANK(BANK)        (((BANK) == FLASH_BANK_1)  || \
N                                    ((BANK) == FLASH_BANK_2)  || \
N                                    ((BANK) == FLASH_BANK_BOTH))
X#define IS_FLASH_BANK(BANK)        (((BANK) == FLASH_BANK_1)  ||                                     ((BANK) == FLASH_BANK_2)  ||                                     ((BANK) == FLASH_BANK_BOTH))
N#endif /* FLASH_OPTCR_nDBANK */
N
N#if defined (FLASH_OPTCR_nDBOOT)
X#if 1L
N#define IS_OB_NDBOOT(VALUE)        (((VALUE) == OB_DUAL_BOOT_DISABLE) || \
N                                    ((VALUE) == OB_DUAL_BOOT_ENABLE))
X#define IS_OB_NDBOOT(VALUE)        (((VALUE) == OB_DUAL_BOOT_DISABLE) ||                                     ((VALUE) == OB_DUAL_BOOT_ENABLE))
N#endif /* FLASH_OPTCR_nDBOOT */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup FLASHEx_Private_Functions FLASH Private Functions
N  * @{
N  */
Nvoid FLASH_Erase_Sector(uint32_t Sector, uint8_t VoltageRange);
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_FLASH_EX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 303 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_flash.h" 2
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup FLASH_Exported_Functions
N  * @{
N  */
N/** @addtogroup FLASH_Exported_Functions_Group1
N  * @{
N  */
N/* Program operation functions  ***********************************************/
NHAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data);
NHAL_StatusTypeDef HAL_FLASH_Program_IT(uint32_t TypeProgram, uint32_t Address, uint64_t Data);
N/* FLASH IRQ handler method */
Nvoid HAL_FLASH_IRQHandler(void);
N/* Callbacks in non blocking modes */ 
Nvoid HAL_FLASH_EndOfOperationCallback(uint32_t ReturnValue);
Nvoid HAL_FLASH_OperationErrorCallback(uint32_t ReturnValue);
N/**
N  * @}
N  */
N
N/** @addtogroup FLASH_Exported_Functions_Group2
N  * @{
N  */
N/* Peripheral Control functions  **********************************************/
NHAL_StatusTypeDef HAL_FLASH_Unlock(void);
NHAL_StatusTypeDef HAL_FLASH_Lock(void);
NHAL_StatusTypeDef HAL_FLASH_OB_Unlock(void);
NHAL_StatusTypeDef HAL_FLASH_OB_Lock(void);
N/* Option bytes control */
NHAL_StatusTypeDef HAL_FLASH_OB_Launch(void);
N/**
N  * @}
N  */
N
N/** @addtogroup FLASH_Exported_Functions_Group3
N  * @{
N  */
N/* Peripheral State functions  ************************************************/
Nuint32_t HAL_FLASH_GetError(void);
NHAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/** @defgroup FLASH_Private_Variables FLASH Private Variables
N  * @{
N  */
N
N/**
N  * @}
N  */
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup FLASH_Private_Constants FLASH Private Constants
N  * @{
N  */
N
N/** 
N  * @brief   OPTCR register byte 1 (Bits[15:8]) base address  
N  */ 
N#define OPTCR_BYTE1_ADDRESS         ((uint32_t)0x40023C15)
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup FLASH_Private_Macros FLASH Private Macros
N  * @{
N  */
N
N/** @defgroup FLASH_IS_FLASH_Definitions FLASH Private macros to check input parameters
N  * @{
N  */
N#define IS_FLASH_TYPEPROGRAM(VALUE)(((VALUE) == FLASH_TYPEPROGRAM_BYTE) || \
N                                    ((VALUE) == FLASH_TYPEPROGRAM_HALFWORD) || \
N                                    ((VALUE) == FLASH_TYPEPROGRAM_WORD) || \
N                                    ((VALUE) == FLASH_TYPEPROGRAM_DOUBLEWORD))  
X#define IS_FLASH_TYPEPROGRAM(VALUE)(((VALUE) == FLASH_TYPEPROGRAM_BYTE) ||                                     ((VALUE) == FLASH_TYPEPROGRAM_HALFWORD) ||                                     ((VALUE) == FLASH_TYPEPROGRAM_WORD) ||                                     ((VALUE) == FLASH_TYPEPROGRAM_DOUBLEWORD))  
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup FLASH_Private_Functions FLASH Private Functions
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_FLASH_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 299 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_FLASH_MODULE_ENABLED */
N 
N#ifdef HAL_SRAM_MODULE_ENABLED
N  #include "stm32f7xx_hal_sram.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_sram.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_sram.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of SRAM HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_SRAM_H
N#define __STM32F7xx_HAL_SRAM_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_ll_fmc.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_ll_fmc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_ll_fmc.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of FMC HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_LL_FMC_H
N#define __STM32F7xx_LL_FMC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup FMC_LL
N  * @{
N  */
N
N/** @addtogroup FMC_LL_Private_Macros
N  * @{
N  */
N#define IS_FMC_NORSRAM_BANK(BANK) (((BANK) == FMC_NORSRAM_BANK1) || \
N                                   ((BANK) == FMC_NORSRAM_BANK2) || \
N                                   ((BANK) == FMC_NORSRAM_BANK3) || \
N                                   ((BANK) == FMC_NORSRAM_BANK4))
X#define IS_FMC_NORSRAM_BANK(BANK) (((BANK) == FMC_NORSRAM_BANK1) ||                                    ((BANK) == FMC_NORSRAM_BANK2) ||                                    ((BANK) == FMC_NORSRAM_BANK3) ||                                    ((BANK) == FMC_NORSRAM_BANK4))
N
N#define IS_FMC_MUX(__MUX__) (((__MUX__) == FMC_DATA_ADDRESS_MUX_DISABLE) || \
N                              ((__MUX__) == FMC_DATA_ADDRESS_MUX_ENABLE))
X#define IS_FMC_MUX(__MUX__) (((__MUX__) == FMC_DATA_ADDRESS_MUX_DISABLE) ||                               ((__MUX__) == FMC_DATA_ADDRESS_MUX_ENABLE))
N
N#define IS_FMC_MEMORY(__MEMORY__) (((__MEMORY__) == FMC_MEMORY_TYPE_SRAM) || \
N                                    ((__MEMORY__) == FMC_MEMORY_TYPE_PSRAM)|| \
N                                    ((__MEMORY__) == FMC_MEMORY_TYPE_NOR))
X#define IS_FMC_MEMORY(__MEMORY__) (((__MEMORY__) == FMC_MEMORY_TYPE_SRAM) ||                                     ((__MEMORY__) == FMC_MEMORY_TYPE_PSRAM)||                                     ((__MEMORY__) == FMC_MEMORY_TYPE_NOR))
N
N#define IS_FMC_NORSRAM_MEMORY_WIDTH(__WIDTH__) (((__WIDTH__) == FMC_NORSRAM_MEM_BUS_WIDTH_8)  || \
N                                                 ((__WIDTH__) == FMC_NORSRAM_MEM_BUS_WIDTH_16) || \
N                                                 ((__WIDTH__) == FMC_NORSRAM_MEM_BUS_WIDTH_32))
X#define IS_FMC_NORSRAM_MEMORY_WIDTH(__WIDTH__) (((__WIDTH__) == FMC_NORSRAM_MEM_BUS_WIDTH_8)  ||                                                  ((__WIDTH__) == FMC_NORSRAM_MEM_BUS_WIDTH_16) ||                                                  ((__WIDTH__) == FMC_NORSRAM_MEM_BUS_WIDTH_32))
N
N#define IS_FMC_ACCESS_MODE(__MODE__) (((__MODE__) == FMC_ACCESS_MODE_A) || \
N                                       ((__MODE__) == FMC_ACCESS_MODE_B) || \
N                                       ((__MODE__) == FMC_ACCESS_MODE_C) || \
N                                       ((__MODE__) == FMC_ACCESS_MODE_D))
X#define IS_FMC_ACCESS_MODE(__MODE__) (((__MODE__) == FMC_ACCESS_MODE_A) ||                                        ((__MODE__) == FMC_ACCESS_MODE_B) ||                                        ((__MODE__) == FMC_ACCESS_MODE_C) ||                                        ((__MODE__) == FMC_ACCESS_MODE_D))
N
N#define IS_FMC_NAND_BANK(BANK) ((BANK) == FMC_NAND_BANK3)
N
N#define IS_FMC_WAIT_FEATURE(FEATURE) (((FEATURE) == FMC_NAND_WAIT_FEATURE_DISABLE) || \
N                                      ((FEATURE) == FMC_NAND_WAIT_FEATURE_ENABLE))
X#define IS_FMC_WAIT_FEATURE(FEATURE) (((FEATURE) == FMC_NAND_WAIT_FEATURE_DISABLE) ||                                       ((FEATURE) == FMC_NAND_WAIT_FEATURE_ENABLE))
N
N#define IS_FMC_NAND_MEMORY_WIDTH(WIDTH) (((WIDTH) == FMC_NAND_MEM_BUS_WIDTH_8) || \
N                                         ((WIDTH) == FMC_NAND_MEM_BUS_WIDTH_16))
X#define IS_FMC_NAND_MEMORY_WIDTH(WIDTH) (((WIDTH) == FMC_NAND_MEM_BUS_WIDTH_8) ||                                          ((WIDTH) == FMC_NAND_MEM_BUS_WIDTH_16))
N
N#define IS_FMC_ECC_STATE(STATE) (((STATE) == FMC_NAND_ECC_DISABLE) || \
N                                 ((STATE) == FMC_NAND_ECC_ENABLE))
X#define IS_FMC_ECC_STATE(STATE) (((STATE) == FMC_NAND_ECC_DISABLE) ||                                  ((STATE) == FMC_NAND_ECC_ENABLE))
N
N#define IS_FMC_ECCPAGE_SIZE(SIZE) (((SIZE) == FMC_NAND_ECC_PAGE_SIZE_256BYTE)  || \
N                                   ((SIZE) == FMC_NAND_ECC_PAGE_SIZE_512BYTE)  || \
N                                   ((SIZE) == FMC_NAND_ECC_PAGE_SIZE_1024BYTE) || \
N                                   ((SIZE) == FMC_NAND_ECC_PAGE_SIZE_2048BYTE) || \
N                                   ((SIZE) == FMC_NAND_ECC_PAGE_SIZE_4096BYTE) || \
N                                   ((SIZE) == FMC_NAND_ECC_PAGE_SIZE_8192BYTE))
X#define IS_FMC_ECCPAGE_SIZE(SIZE) (((SIZE) == FMC_NAND_ECC_PAGE_SIZE_256BYTE)  ||                                    ((SIZE) == FMC_NAND_ECC_PAGE_SIZE_512BYTE)  ||                                    ((SIZE) == FMC_NAND_ECC_PAGE_SIZE_1024BYTE) ||                                    ((SIZE) == FMC_NAND_ECC_PAGE_SIZE_2048BYTE) ||                                    ((SIZE) == FMC_NAND_ECC_PAGE_SIZE_4096BYTE) ||                                    ((SIZE) == FMC_NAND_ECC_PAGE_SIZE_8192BYTE))
N								   
N#define IS_FMC_SDMEMORY_WIDTH(WIDTH) (((WIDTH) == FMC_SDRAM_MEM_BUS_WIDTH_8)  || \
N                                      ((WIDTH) == FMC_SDRAM_MEM_BUS_WIDTH_16) || \
N                                      ((WIDTH) == FMC_SDRAM_MEM_BUS_WIDTH_32))
X#define IS_FMC_SDMEMORY_WIDTH(WIDTH) (((WIDTH) == FMC_SDRAM_MEM_BUS_WIDTH_8)  ||                                       ((WIDTH) == FMC_SDRAM_MEM_BUS_WIDTH_16) ||                                       ((WIDTH) == FMC_SDRAM_MEM_BUS_WIDTH_32))
N
N#define IS_FMC_WRITE_PROTECTION(__WRITE__) (((__WRITE__) == FMC_SDRAM_WRITE_PROTECTION_DISABLE) || \
N                                            ((__WRITE__) == FMC_SDRAM_WRITE_PROTECTION_ENABLE))									  
X#define IS_FMC_WRITE_PROTECTION(__WRITE__) (((__WRITE__) == FMC_SDRAM_WRITE_PROTECTION_DISABLE) ||                                             ((__WRITE__) == FMC_SDRAM_WRITE_PROTECTION_ENABLE))									  
N
N#define IS_FMC_SDCLOCK_PERIOD(__PERIOD__) (((__PERIOD__) == FMC_SDRAM_CLOCK_DISABLE)  || \
N                                           ((__PERIOD__) == FMC_SDRAM_CLOCK_PERIOD_2) || \
N                                           ((__PERIOD__) == FMC_SDRAM_CLOCK_PERIOD_3))
X#define IS_FMC_SDCLOCK_PERIOD(__PERIOD__) (((__PERIOD__) == FMC_SDRAM_CLOCK_DISABLE)  ||                                            ((__PERIOD__) == FMC_SDRAM_CLOCK_PERIOD_2) ||                                            ((__PERIOD__) == FMC_SDRAM_CLOCK_PERIOD_3))
N										   
N#define IS_FMC_READ_BURST(__RBURST__) (((__RBURST__) == FMC_SDRAM_RBURST_DISABLE) || \
N                                       ((__RBURST__) == FMC_SDRAM_RBURST_ENABLE))
X#define IS_FMC_READ_BURST(__RBURST__) (((__RBURST__) == FMC_SDRAM_RBURST_DISABLE) ||                                        ((__RBURST__) == FMC_SDRAM_RBURST_ENABLE))
N									   
N#define IS_FMC_READPIPE_DELAY(__DELAY__) (((__DELAY__) == FMC_SDRAM_RPIPE_DELAY_0) || \
N                                          ((__DELAY__) == FMC_SDRAM_RPIPE_DELAY_1) || \
N                                          ((__DELAY__) == FMC_SDRAM_RPIPE_DELAY_2))
X#define IS_FMC_READPIPE_DELAY(__DELAY__) (((__DELAY__) == FMC_SDRAM_RPIPE_DELAY_0) ||                                           ((__DELAY__) == FMC_SDRAM_RPIPE_DELAY_1) ||                                           ((__DELAY__) == FMC_SDRAM_RPIPE_DELAY_2))
N
N#define IS_FMC_COMMAND_MODE(__COMMAND__) (((__COMMAND__) == FMC_SDRAM_CMD_NORMAL_MODE)      || \
N                                          ((__COMMAND__) == FMC_SDRAM_CMD_CLK_ENABLE)       || \
N                                          ((__COMMAND__) == FMC_SDRAM_CMD_PALL)             || \
N                                          ((__COMMAND__) == FMC_SDRAM_CMD_AUTOREFRESH_MODE) || \
N                                          ((__COMMAND__) == FMC_SDRAM_CMD_LOAD_MODE)        || \
N                                          ((__COMMAND__) == FMC_SDRAM_CMD_SELFREFRESH_MODE) || \
N                                          ((__COMMAND__) == FMC_SDRAM_CMD_POWERDOWN_MODE))
X#define IS_FMC_COMMAND_MODE(__COMMAND__) (((__COMMAND__) == FMC_SDRAM_CMD_NORMAL_MODE)      ||                                           ((__COMMAND__) == FMC_SDRAM_CMD_CLK_ENABLE)       ||                                           ((__COMMAND__) == FMC_SDRAM_CMD_PALL)             ||                                           ((__COMMAND__) == FMC_SDRAM_CMD_AUTOREFRESH_MODE) ||                                           ((__COMMAND__) == FMC_SDRAM_CMD_LOAD_MODE)        ||                                           ((__COMMAND__) == FMC_SDRAM_CMD_SELFREFRESH_MODE) ||                                           ((__COMMAND__) == FMC_SDRAM_CMD_POWERDOWN_MODE))
N
N#define IS_FMC_COMMAND_TARGET(__TARGET__) (((__TARGET__) == FMC_SDRAM_CMD_TARGET_BANK1) || \
N                                           ((__TARGET__) == FMC_SDRAM_CMD_TARGET_BANK2) || \
N                                           ((__TARGET__) == FMC_SDRAM_CMD_TARGET_BANK1_2)) 										  
X#define IS_FMC_COMMAND_TARGET(__TARGET__) (((__TARGET__) == FMC_SDRAM_CMD_TARGET_BANK1) ||                                            ((__TARGET__) == FMC_SDRAM_CMD_TARGET_BANK2) ||                                            ((__TARGET__) == FMC_SDRAM_CMD_TARGET_BANK1_2)) 										  
N						   
N/** @defgroup FMC_TCLR_Setup_Time FMC TCLR Setup Time
N  * @{
N  */
N#define IS_FMC_TCLR_TIME(__TIME__) ((__TIME__) <= 255)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_TAR_Setup_Time FMC TAR Setup Time 
N  * @{
N  */
N#define IS_FMC_TAR_TIME(TIME) ((TIME) <= 255)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_Setup_Time FMC Setup Time 
N  * @{
N  */
N#define IS_FMC_SETUP_TIME(TIME) ((TIME) <= 254)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_Wait_Setup_Time FMC Wait Setup Time 
N  * @{
N  */
N#define IS_FMC_WAIT_TIME(TIME) ((TIME) <= 254)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_Hold_Setup_Time FMC Hold Setup Time 
N  * @{
N  */
N#define IS_FMC_HOLD_TIME(TIME) ((TIME) <= 254)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_HiZ_Setup_Time FMC HiZ Setup Time 
N  * @{
N  */
N#define IS_FMC_HIZ_TIME(TIME) ((TIME) <= 254)
N/**
N  * @}
N  */
N
N#define IS_FMC_BURSTMODE(__STATE__) (((__STATE__) == FMC_BURST_ACCESS_MODE_DISABLE) || \
N                                      ((__STATE__) == FMC_BURST_ACCESS_MODE_ENABLE))
X#define IS_FMC_BURSTMODE(__STATE__) (((__STATE__) == FMC_BURST_ACCESS_MODE_DISABLE) ||                                       ((__STATE__) == FMC_BURST_ACCESS_MODE_ENABLE))
N
N#define IS_FMC_WAIT_POLARITY(__POLARITY__) (((__POLARITY__) == FMC_WAIT_SIGNAL_POLARITY_LOW) || \
N                                             ((__POLARITY__) == FMC_WAIT_SIGNAL_POLARITY_HIGH))
X#define IS_FMC_WAIT_POLARITY(__POLARITY__) (((__POLARITY__) == FMC_WAIT_SIGNAL_POLARITY_LOW) ||                                              ((__POLARITY__) == FMC_WAIT_SIGNAL_POLARITY_HIGH))
N
N#define IS_FMC_WAIT_SIGNAL_ACTIVE(__ACTIVE__) (((__ACTIVE__) == FMC_WAIT_TIMING_BEFORE_WS) || \
N                                                ((__ACTIVE__) == FMC_WAIT_TIMING_DURING_WS)) 
X#define IS_FMC_WAIT_SIGNAL_ACTIVE(__ACTIVE__) (((__ACTIVE__) == FMC_WAIT_TIMING_BEFORE_WS) ||                                                 ((__ACTIVE__) == FMC_WAIT_TIMING_DURING_WS)) 
N
N#define IS_FMC_WRITE_OPERATION(__OPERATION__) (((__OPERATION__) == FMC_WRITE_OPERATION_DISABLE) || \
N                                                ((__OPERATION__) == FMC_WRITE_OPERATION_ENABLE))
X#define IS_FMC_WRITE_OPERATION(__OPERATION__) (((__OPERATION__) == FMC_WRITE_OPERATION_DISABLE) ||                                                 ((__OPERATION__) == FMC_WRITE_OPERATION_ENABLE))
N
N#define IS_FMC_WAITE_SIGNAL(__SIGNAL__) (((__SIGNAL__) == FMC_WAIT_SIGNAL_DISABLE) || \
N                                          ((__SIGNAL__) == FMC_WAIT_SIGNAL_ENABLE))
X#define IS_FMC_WAITE_SIGNAL(__SIGNAL__) (((__SIGNAL__) == FMC_WAIT_SIGNAL_DISABLE) ||                                           ((__SIGNAL__) == FMC_WAIT_SIGNAL_ENABLE))
N
N#define IS_FMC_EXTENDED_MODE(__MODE__) (((__MODE__) == FMC_EXTENDED_MODE_DISABLE) || \
N                                         ((__MODE__) == FMC_EXTENDED_MODE_ENABLE))
X#define IS_FMC_EXTENDED_MODE(__MODE__) (((__MODE__) == FMC_EXTENDED_MODE_DISABLE) ||                                          ((__MODE__) == FMC_EXTENDED_MODE_ENABLE))
N
N#define IS_FMC_ASYNWAIT(__STATE__) (((__STATE__) == FMC_ASYNCHRONOUS_WAIT_DISABLE) || \
N                                     ((__STATE__) == FMC_ASYNCHRONOUS_WAIT_ENABLE))
X#define IS_FMC_ASYNWAIT(__STATE__) (((__STATE__) == FMC_ASYNCHRONOUS_WAIT_DISABLE) ||                                      ((__STATE__) == FMC_ASYNCHRONOUS_WAIT_ENABLE))
N
N/** @defgroup FMC_Data_Latency FMC Data Latency 
N  * @{
N  */
N#define IS_FMC_DATA_LATENCY(__LATENCY__) (((__LATENCY__) > 1) && ((__LATENCY__) <= 17))
N/**
N  * @}
N  */
N
N#define IS_FMC_WRITE_BURST(__BURST__) (((__BURST__) == FMC_WRITE_BURST_DISABLE) || \
N                                        ((__BURST__) == FMC_WRITE_BURST_ENABLE))
X#define IS_FMC_WRITE_BURST(__BURST__) (((__BURST__) == FMC_WRITE_BURST_DISABLE) ||                                         ((__BURST__) == FMC_WRITE_BURST_ENABLE))
N
N#define IS_FMC_CONTINOUS_CLOCK(CCLOCK) (((CCLOCK) == FMC_CONTINUOUS_CLOCK_SYNC_ONLY) || \
N                                        ((CCLOCK) == FMC_CONTINUOUS_CLOCK_SYNC_ASYNC))
X#define IS_FMC_CONTINOUS_CLOCK(CCLOCK) (((CCLOCK) == FMC_CONTINUOUS_CLOCK_SYNC_ONLY) ||                                         ((CCLOCK) == FMC_CONTINUOUS_CLOCK_SYNC_ASYNC))
N
N
N/** @defgroup FMC_Address_Setup_Time FMC Address Setup Time
N  * @{
N  */
N#define IS_FMC_ADDRESS_SETUP_TIME(__TIME__) ((__TIME__) <= 15)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_Address_Hold_Time FMC Address Hold Time
N  * @{
N  */
N#define IS_FMC_ADDRESS_HOLD_TIME(__TIME__) (((__TIME__) > 0) && ((__TIME__) <= 15))
N/**
N  * @}
N  */
N
N/** @defgroup FMC_Data_Setup_Time FMC Data Setup Time
N  * @{
N  */
N#define IS_FMC_DATASETUP_TIME(__TIME__) (((__TIME__) > 0) && ((__TIME__) <= 255))
N/**
N  * @}
N  */
N
N/** @defgroup FMC_Bus_Turn_around_Duration FMC Bus Turn around Duration
N  * @{
N  */
N#define IS_FMC_TURNAROUND_TIME(__TIME__) ((__TIME__) <= 15)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_CLK_Division FMC CLK Division 
N  * @{
N  */
N#define IS_FMC_CLK_DIV(DIV) (((DIV) > 1) && ((DIV) <= 16))
N/**
N  * @}
N  */
N
N/** @defgroup FMC_SDRAM_LoadToActive_Delay FMC SDRAM LoadToActive Delay
N  * @{
N  */
N#define IS_FMC_LOADTOACTIVE_DELAY(__DELAY__) (((__DELAY__) > 0) && ((__DELAY__) <= 16))
N/**
N  * @}
N  */
N  
N/** @defgroup FMC_SDRAM_ExitSelfRefresh_Delay FMC SDRAM ExitSelfRefresh Delay
N  * @{
N  */
N#define IS_FMC_EXITSELFREFRESH_DELAY(__DELAY__) (((__DELAY__) > 0) && ((__DELAY__) <= 16))
N/**
N  * @}
N  */ 
N     
N/** @defgroup FMC_SDRAM_SelfRefresh_Time FMC SDRAM SelfRefresh Time
N  * @{
N  */  
N#define IS_FMC_SELFREFRESH_TIME(__TIME__) (((__TIME__) > 0) && ((__TIME__) <= 16))
N/**
N  * @}
N  */
N  
N/** @defgroup FMC_SDRAM_RowCycle_Delay FMC SDRAM RowCycle Delay
N  * @{
N  */  
N#define IS_FMC_ROWCYCLE_DELAY(__DELAY__) (((__DELAY__) > 0) && ((__DELAY__) <= 16))
N/**
N  * @}
N  */  
N  
N/** @defgroup FMC_SDRAM_Write_Recovery_Time FMC SDRAM Write Recovery Time
N  * @{
N  */  
N#define IS_FMC_WRITE_RECOVERY_TIME(__TIME__) (((__TIME__) > 0) && ((__TIME__) <= 16))
N/**
N  * @}
N  */         
N  
N/** @defgroup FMC_SDRAM_RP_Delay FMC SDRAM RP Delay
N  * @{
N  */  
N#define IS_FMC_RP_DELAY(__DELAY__) (((__DELAY__) > 0) && ((__DELAY__) <= 16))
N/**
N  * @}
N  */ 
N  
N/** @defgroup FMC_SDRAM_RCD_Delay FMC SDRAM RCD Delay
N  * @{
N  */  
N#define IS_FMC_RCD_DELAY(__DELAY__) (((__DELAY__) > 0) && ((__DELAY__) <= 16))
N/**
N  * @}
N  */
N  
N/** @defgroup FMC_SDRAM_AutoRefresh_Number FMC SDRAM AutoRefresh Number
N  * @{
N  */  
N#define IS_FMC_AUTOREFRESH_NUMBER(__NUMBER__) (((__NUMBER__) > 0) && ((__NUMBER__) <= 16))
N/**
N  * @}
N  */
N
N/** @defgroup FMC_SDRAM_ModeRegister_Definition FMC SDRAM ModeRegister Definition
N  * @{
N  */
N#define IS_FMC_MODE_REGISTER(__CONTENT__) ((__CONTENT__) <= 8191)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_SDRAM_Refresh_rate FMC SDRAM Refresh rate
N  * @{
N  */
N#define IS_FMC_REFRESH_RATE(__RATE__) ((__RATE__) <= 8191)
N/**
N  * @}
N  */
N  
N/** @defgroup FMC_NORSRAM_Device_Instance FMC NORSRAM Device Instance
N  * @{
N  */
N#define IS_FMC_NORSRAM_DEVICE(__INSTANCE__) ((__INSTANCE__) == FMC_NORSRAM_DEVICE)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_NORSRAM_EXTENDED_Device_Instance FMC NORSRAM EXTENDED Device Instance
N  * @{
N  */
N#define IS_FMC_NORSRAM_EXTENDED_DEVICE(__INSTANCE__) ((__INSTANCE__) == FMC_NORSRAM_EXTENDED_DEVICE)
N/**
N  * @}
N  */
N  
N/** @defgroup FMC_NAND_Device_Instance FMC NAND Device Instance
N  * @{
N  */
N#define IS_FMC_NAND_DEVICE(__INSTANCE__) ((__INSTANCE__) == FMC_NAND_DEVICE)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_SDRAM_Device_Instance FMC SDRAM Device Instance
N  * @{
N  */
N#define IS_FMC_SDRAM_DEVICE(__INSTANCE__) ((__INSTANCE__) == FMC_SDRAM_DEVICE)
N/**
N  * @}
N  */
N
N#define IS_FMC_SDRAM_BANK(BANK) (((BANK) == FMC_SDRAM_BANK1) || \
N                                 ((BANK) == FMC_SDRAM_BANK2))
X#define IS_FMC_SDRAM_BANK(BANK) (((BANK) == FMC_SDRAM_BANK1) ||                                  ((BANK) == FMC_SDRAM_BANK2))
N
N#define IS_FMC_COLUMNBITS_NUMBER(COLUMN) (((COLUMN) == FMC_SDRAM_COLUMN_BITS_NUM_8)  || \
N                                          ((COLUMN) == FMC_SDRAM_COLUMN_BITS_NUM_9)  || \
N                                          ((COLUMN) == FMC_SDRAM_COLUMN_BITS_NUM_10) || \
N                                          ((COLUMN) == FMC_SDRAM_COLUMN_BITS_NUM_11))
X#define IS_FMC_COLUMNBITS_NUMBER(COLUMN) (((COLUMN) == FMC_SDRAM_COLUMN_BITS_NUM_8)  ||                                           ((COLUMN) == FMC_SDRAM_COLUMN_BITS_NUM_9)  ||                                           ((COLUMN) == FMC_SDRAM_COLUMN_BITS_NUM_10) ||                                           ((COLUMN) == FMC_SDRAM_COLUMN_BITS_NUM_11))
N
N#define IS_FMC_ROWBITS_NUMBER(ROW) (((ROW) == FMC_SDRAM_ROW_BITS_NUM_11) || \
N                                    ((ROW) == FMC_SDRAM_ROW_BITS_NUM_12) || \
N                                    ((ROW) == FMC_SDRAM_ROW_BITS_NUM_13))
X#define IS_FMC_ROWBITS_NUMBER(ROW) (((ROW) == FMC_SDRAM_ROW_BITS_NUM_11) ||                                     ((ROW) == FMC_SDRAM_ROW_BITS_NUM_12) ||                                     ((ROW) == FMC_SDRAM_ROW_BITS_NUM_13))
N
N#define IS_FMC_INTERNALBANK_NUMBER(NUMBER) (((NUMBER) == FMC_SDRAM_INTERN_BANKS_NUM_2) || \
N                                            ((NUMBER) == FMC_SDRAM_INTERN_BANKS_NUM_4))
X#define IS_FMC_INTERNALBANK_NUMBER(NUMBER) (((NUMBER) == FMC_SDRAM_INTERN_BANKS_NUM_2) ||                                             ((NUMBER) == FMC_SDRAM_INTERN_BANKS_NUM_4))
N
N
N#define IS_FMC_CAS_LATENCY(LATENCY) (((LATENCY) == FMC_SDRAM_CAS_LATENCY_1) || \
N                                     ((LATENCY) == FMC_SDRAM_CAS_LATENCY_2) || \
N                                     ((LATENCY) == FMC_SDRAM_CAS_LATENCY_3))
X#define IS_FMC_CAS_LATENCY(LATENCY) (((LATENCY) == FMC_SDRAM_CAS_LATENCY_1) ||                                      ((LATENCY) == FMC_SDRAM_CAS_LATENCY_2) ||                                      ((LATENCY) == FMC_SDRAM_CAS_LATENCY_3))
N
N#define IS_FMC_PAGESIZE(__SIZE__) (((__SIZE__) == FMC_PAGE_SIZE_NONE) || \
N                                   ((__SIZE__) == FMC_PAGE_SIZE_128) || \
N                                   ((__SIZE__) == FMC_PAGE_SIZE_256) || \
N                                   ((__SIZE__) == FMC_PAGE_SIZE_512) || \
N                                   ((__SIZE__) == FMC_PAGE_SIZE_1024))
X#define IS_FMC_PAGESIZE(__SIZE__) (((__SIZE__) == FMC_PAGE_SIZE_NONE) ||                                    ((__SIZE__) == FMC_PAGE_SIZE_128) ||                                    ((__SIZE__) == FMC_PAGE_SIZE_256) ||                                    ((__SIZE__) == FMC_PAGE_SIZE_512) ||                                    ((__SIZE__) == FMC_PAGE_SIZE_1024))
N
N#define IS_FMC_WRITE_FIFO(__FIFO__) (((__FIFO__) == FMC_WRITE_FIFO_DISABLE) || \
N                                     ((__FIFO__) == FMC_WRITE_FIFO_ENABLE))
X#define IS_FMC_WRITE_FIFO(__FIFO__) (((__FIFO__) == FMC_WRITE_FIFO_DISABLE) ||                                      ((__FIFO__) == FMC_WRITE_FIFO_ENABLE))
N/**
N  * @}
N  */
N
N/* Exported typedef ----------------------------------------------------------*/
N/** @defgroup FMC_Exported_typedef FMC Low Layer Exported Types
N  * @{
N  */
N#define FMC_NORSRAM_TypeDef            FMC_Bank1_TypeDef
N#define FMC_NORSRAM_EXTENDED_TypeDef   FMC_Bank1E_TypeDef
N#define FMC_NAND_TypeDef               FMC_Bank3_TypeDef
N#define FMC_SDRAM_TypeDef              FMC_Bank5_6_TypeDef
N
N#define FMC_NORSRAM_DEVICE             FMC_Bank1
N#define FMC_NORSRAM_EXTENDED_DEVICE    FMC_Bank1E
N#define FMC_NAND_DEVICE                FMC_Bank3
N#define FMC_SDRAM_DEVICE               FMC_Bank5_6
N
N/** 
N  * @brief  FMC NORSRAM Configuration Structure definition
N  */ 
Ntypedef struct
N{
N  uint32_t NSBank;                       /*!< Specifies the NORSRAM memory device that will be used.
N                                              This parameter can be a value of @ref FMC_NORSRAM_Bank                     */
N
N  uint32_t DataAddressMux;               /*!< Specifies whether the address and data values are
N                                              multiplexed on the data bus or not. 
N                                              This parameter can be a value of @ref FMC_Data_Address_Bus_Multiplexing    */
N
N  uint32_t MemoryType;                   /*!< Specifies the type of external memory attached to
N                                              the corresponding memory device.
N                                              This parameter can be a value of @ref FMC_Memory_Type                      */
N
N  uint32_t MemoryDataWidth;              /*!< Specifies the external memory device width.
N                                              This parameter can be a value of @ref FMC_NORSRAM_Data_Width               */
N
N  uint32_t BurstAccessMode;              /*!< Enables or disables the burst access mode for Flash memory,
N                                              valid only with synchronous burst Flash memories.
N                                              This parameter can be a value of @ref FMC_Burst_Access_Mode                */
N
N  uint32_t WaitSignalPolarity;           /*!< Specifies the wait signal polarity, valid only when accessing
N                                              the Flash memory in burst mode.
N                                              This parameter can be a value of @ref FMC_Wait_Signal_Polarity             */
N
N  uint32_t WaitSignalActive;             /*!< Specifies if the wait signal is asserted by the memory one
N                                              clock cycle before the wait state or during the wait state,
N                                              valid only when accessing memories in burst mode. 
N                                              This parameter can be a value of @ref FMC_Wait_Timing                      */
N
N  uint32_t WriteOperation;               /*!< Enables or disables the write operation in the selected device by the FMC. 
N                                              This parameter can be a value of @ref FMC_Write_Operation                  */
N
N  uint32_t WaitSignal;                   /*!< Enables or disables the wait state insertion via wait
N                                              signal, valid for Flash memory access in burst mode. 
N                                              This parameter can be a value of @ref FMC_Wait_Signal                      */
N
N  uint32_t ExtendedMode;                 /*!< Enables or disables the extended mode.
N                                              This parameter can be a value of @ref FMC_Extended_Mode                    */
N
N  uint32_t AsynchronousWait;             /*!< Enables or disables wait signal during asynchronous transfers,
N                                              valid only with asynchronous Flash memories.
N                                              This parameter can be a value of @ref FMC_AsynchronousWait                 */
N
N  uint32_t WriteBurst;                   /*!< Enables or disables the write burst operation.
N                                              This parameter can be a value of @ref FMC_Write_Burst                      */
N
N  uint32_t ContinuousClock;              /*!< Enables or disables the FMC clock output to external memory devices.
N                                              This parameter is only enabled through the FMC_BCR1 register, and don't care 
N                                              through FMC_BCR2..4 registers.
N                                              This parameter can be a value of @ref FMC_Continous_Clock                  */
N
N  uint32_t WriteFifo;                    /*!< Enables or disables the write FIFO used by the FMC controller.
N                                              This parameter is only enabled through the FMC_BCR1 register, and don't care 
N                                              through FMC_BCR2..4 registers.
N                                              This parameter can be a value of @ref FMC_Write_FIFO                      */
N
N  uint32_t PageSize;                     /*!< Specifies the memory page size.
N                                              This parameter can be a value of @ref FMC_Page_Size                        */
N
N}FMC_NORSRAM_InitTypeDef;
N
N/** 
N  * @brief  FMC NORSRAM Timing parameters structure definition  
N  */
Ntypedef struct
N{
N  uint32_t AddressSetupTime;             /*!< Defines the number of HCLK cycles to configure
N                                              the duration of the address setup time. 
N                                              This parameter can be a value between Min_Data = 0 and Max_Data = 15.
N                                              @note This parameter is not used with synchronous NOR Flash memories.      */
N
N  uint32_t AddressHoldTime;              /*!< Defines the number of HCLK cycles to configure
N                                              the duration of the address hold time.
N                                              This parameter can be a value between Min_Data = 1 and Max_Data = 15. 
N                                              @note This parameter is not used with synchronous NOR Flash memories.      */
N
N  uint32_t DataSetupTime;                /*!< Defines the number of HCLK cycles to configure
N                                              the duration of the data setup time.
N                                              This parameter can be a value between Min_Data = 1 and Max_Data = 255.
N                                              @note This parameter is used for SRAMs, ROMs and asynchronous multiplexed 
N                                              NOR Flash memories.                                                        */
N
N  uint32_t BusTurnAroundDuration;        /*!< Defines the number of HCLK cycles to configure
N                                              the duration of the bus turnaround.
N                                              This parameter can be a value between Min_Data = 0 and Max_Data = 15.
N                                              @note This parameter is only used for multiplexed NOR Flash memories.      */
N
N  uint32_t CLKDivision;                  /*!< Defines the period of CLK clock output signal, expressed in number of 
N                                              HCLK cycles. This parameter can be a value between Min_Data = 2 and Max_Data = 16.
N                                              @note This parameter is not used for asynchronous NOR Flash, SRAM or ROM 
N                                              accesses.                                                                  */
N
N  uint32_t DataLatency;                  /*!< Defines the number of memory clock cycles to issue
N                                              to the memory before getting the first data.
N                                              The parameter value depends on the memory type as shown below:
N                                              - It must be set to 0 in case of a CRAM
N                                              - It is don't care in asynchronous NOR, SRAM or ROM accesses
N                                              - It may assume a value between Min_Data = 2 and Max_Data = 17 in NOR Flash memories
N                                                with synchronous burst mode enable                                       */
N
N  uint32_t AccessMode;                   /*!< Specifies the asynchronous access mode. 
N                                              This parameter can be a value of @ref FMC_Access_Mode                      */
N}FMC_NORSRAM_TimingTypeDef;
N
N/** 
N  * @brief  FMC NAND Configuration Structure definition  
N  */ 
Ntypedef struct
N{
N  uint32_t NandBank;               /*!< Specifies the NAND memory device that will be used.
N                                        This parameter can be a value of @ref FMC_NAND_Bank                    */
N
N  uint32_t Waitfeature;            /*!< Enables or disables the Wait feature for the NAND Memory device.
N                                        This parameter can be any value of @ref FMC_Wait_feature               */
N
N  uint32_t MemoryDataWidth;        /*!< Specifies the external memory device width.
N                                        This parameter can be any value of @ref FMC_NAND_Data_Width            */
N
N  uint32_t EccComputation;         /*!< Enables or disables the ECC computation.
N                                        This parameter can be any value of @ref FMC_ECC                        */
N
N  uint32_t ECCPageSize;            /*!< Defines the page size for the extended ECC.
N                                        This parameter can be any value of @ref FMC_ECC_Page_Size              */
N
N  uint32_t TCLRSetupTime;          /*!< Defines the number of HCLK cycles to configure the
N                                        delay between CLE low and RE low.
N                                        This parameter can be a value between Min_Data = 0 and Max_Data = 255  */
N
N  uint32_t TARSetupTime;           /*!< Defines the number of HCLK cycles to configure the
N                                        delay between ALE low and RE low.
N                                        This parameter can be a number between Min_Data = 0 and Max_Data = 255 */
N}FMC_NAND_InitTypeDef;
N
N/** 
N  * @brief  FMC NAND Timing parameters structure definition
N  */
Ntypedef struct
N{
N  uint32_t SetupTime;            /*!< Defines the number of HCLK cycles to setup address before
N                                      the command assertion for NAND-Flash read or write access
N                                      to common/Attribute or I/O memory space (depending on
N                                      the memory space timing to be configured).
N                                      This parameter can be a value between Min_Data = 0 and Max_Data = 254    */
N
N  uint32_t WaitSetupTime;        /*!< Defines the minimum number of HCLK cycles to assert the
N                                      command for NAND-Flash read or write access to
N                                      common/Attribute or I/O memory space (depending on the
N                                      memory space timing to be configured). 
N                                      This parameter can be a number between Min_Data = 0 and Max_Data = 254   */
N
N  uint32_t HoldSetupTime;        /*!< Defines the number of HCLK clock cycles to hold address
N                                      (and data for write access) after the command de-assertion
N                                      for NAND-Flash read or write access to common/Attribute
N                                      or I/O memory space (depending on the memory space timing
N                                      to be configured).
N                                      This parameter can be a number between Min_Data = 0 and Max_Data = 254   */
N
N  uint32_t HiZSetupTime;         /*!< Defines the number of HCLK clock cycles during which the
N                                      data bus is kept in HiZ after the start of a NAND-Flash
N                                      write access to common/Attribute or I/O memory space (depending
N                                      on the memory space timing to be configured).
N                                      This parameter can be a number between Min_Data = 0 and Max_Data = 254   */
N}FMC_NAND_PCC_TimingTypeDef;
N
N/** 
N  * @brief  FMC SDRAM Configuration Structure definition  
N  */  
Ntypedef struct
N{
N  uint32_t SDBank;                      /*!< Specifies the SDRAM memory device that will be used.
N                                             This parameter can be a value of @ref FMC_SDRAM_Bank                */
N
N  uint32_t ColumnBitsNumber;            /*!< Defines the number of bits of column address.
N                                             This parameter can be a value of @ref FMC_SDRAM_Column_Bits_number. */
N
N  uint32_t RowBitsNumber;               /*!< Defines the number of bits of column address.
N                                             This parameter can be a value of @ref FMC_SDRAM_Row_Bits_number.    */
N
N  uint32_t MemoryDataWidth;             /*!< Defines the memory device width.
N                                             This parameter can be a value of @ref FMC_SDRAM_Memory_Bus_Width.   */
N
N  uint32_t InternalBankNumber;          /*!< Defines the number of the device's internal banks.
N                                             This parameter can be of @ref FMC_SDRAM_Internal_Banks_Number.      */
N
N  uint32_t CASLatency;                  /*!< Defines the SDRAM CAS latency in number of memory clock cycles.
N                                             This parameter can be a value of @ref FMC_SDRAM_CAS_Latency.        */
N
N  uint32_t WriteProtection;             /*!< Enables the SDRAM device to be accessed in write mode.
N                                             This parameter can be a value of @ref FMC_SDRAM_Write_Protection.   */
N
N  uint32_t SDClockPeriod;               /*!< Define the SDRAM Clock Period for both SDRAM devices and they allow 
N                                             to disable the clock before changing frequency.
N                                             This parameter can be a value of @ref FMC_SDRAM_Clock_Period.       */
N
N  uint32_t ReadBurst;                   /*!< This bit enable the SDRAM controller to anticipate the next read 
N                                             commands during the CAS latency and stores data in the Read FIFO.
N                                             This parameter can be a value of @ref FMC_SDRAM_Read_Burst.         */
N
N  uint32_t ReadPipeDelay;               /*!< Define the delay in system clock cycles on read data path.
N                                             This parameter can be a value of @ref FMC_SDRAM_Read_Pipe_Delay.    */
N}FMC_SDRAM_InitTypeDef;
N
N/** 
N  * @brief FMC SDRAM Timing parameters structure definition
N  */
Ntypedef struct
N{
N  uint32_t LoadToActiveDelay;            /*!< Defines the delay between a Load Mode Register command and 
N                                              an active or Refresh command in number of memory clock cycles.
N                                              This parameter can be a value between Min_Data = 1 and Max_Data = 16  */
N
N  uint32_t ExitSelfRefreshDelay;         /*!< Defines the delay from releasing the self refresh command to 
N                                              issuing the Activate command in number of memory clock cycles.
N                                              This parameter can be a value between Min_Data = 1 and Max_Data = 16  */
N
N  uint32_t SelfRefreshTime;              /*!< Defines the minimum Self Refresh period in number of memory clock 
N                                              cycles.
N                                              This parameter can be a value between Min_Data = 1 and Max_Data = 16  */
N
N  uint32_t RowCycleDelay;                /*!< Defines the delay between the Refresh command and the Activate command
N                                              and the delay between two consecutive Refresh commands in number of 
N                                              memory clock cycles.
N                                              This parameter can be a value between Min_Data = 1 and Max_Data = 16  */
N
N  uint32_t WriteRecoveryTime;            /*!< Defines the Write recovery Time in number of memory clock cycles.
N                                              This parameter can be a value between Min_Data = 1 and Max_Data = 16  */
N
N  uint32_t RPDelay;                      /*!< Defines the delay between a Precharge Command and an other command 
N                                              in number of memory clock cycles.
N                                              This parameter can be a value between Min_Data = 1 and Max_Data = 16  */
N
N  uint32_t RCDDelay;                     /*!< Defines the delay between the Activate Command and a Read/Write 
N                                              command in number of memory clock cycles.
N                                              This parameter can be a value between Min_Data = 1 and Max_Data = 16  */ 
N}FMC_SDRAM_TimingTypeDef;
N
N/** 
N  * @brief SDRAM command parameters structure definition
N  */
Ntypedef struct
N{
N  uint32_t CommandMode;                  /*!< Defines the command issued to the SDRAM device.
N                                              This parameter can be a value of @ref FMC_SDRAM_Command_Mode.          */
N
N  uint32_t CommandTarget;                /*!< Defines which device (1 or 2) the command will be issued to.
N                                              This parameter can be a value of @ref FMC_SDRAM_Command_Target.        */
N
N  uint32_t AutoRefreshNumber;            /*!< Defines the number of consecutive auto refresh command issued
N                                              in auto refresh mode.
N                                              This parameter can be a value between Min_Data = 1 and Max_Data = 16   */
N  uint32_t ModeRegisterDefinition;       /*!< Defines the SDRAM Mode register content                                */
N}FMC_SDRAM_CommandTypeDef;
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @addtogroup FMC_LL_Exported_Constants FMC Low Layer Exported Constants
N  * @{
N  */
N
N/** @defgroup FMC_LL_NOR_SRAM_Controller FMC NOR/SRAM Controller 
N  * @{
N  */
N
N/** @defgroup FMC_NORSRAM_Bank FMC NOR/SRAM Bank
N  * @{
N  */
N#define FMC_NORSRAM_BANK1                       ((uint32_t)0x00000000U)
N#define FMC_NORSRAM_BANK2                       ((uint32_t)0x00000002U)
N#define FMC_NORSRAM_BANK3                       ((uint32_t)0x00000004U)
N#define FMC_NORSRAM_BANK4                       ((uint32_t)0x00000006U)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_Data_Address_Bus_Multiplexing FMC Data Address Bus Multiplexing
N  * @{
N  */
N#define FMC_DATA_ADDRESS_MUX_DISABLE            ((uint32_t)0x00000000U)
N#define FMC_DATA_ADDRESS_MUX_ENABLE             ((uint32_t)0x00000002U)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_Memory_Type FMC Memory Type
N  * @{
N  */
N#define FMC_MEMORY_TYPE_SRAM                    ((uint32_t)0x00000000U)
N#define FMC_MEMORY_TYPE_PSRAM                   ((uint32_t)0x00000004U)
N#define FMC_MEMORY_TYPE_NOR                     ((uint32_t)0x00000008U)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_NORSRAM_Data_Width FMC NORSRAM Data Width
N  * @{
N  */
N#define FMC_NORSRAM_MEM_BUS_WIDTH_8             ((uint32_t)0x00000000U)
N#define FMC_NORSRAM_MEM_BUS_WIDTH_16            ((uint32_t)0x00000010U)
N#define FMC_NORSRAM_MEM_BUS_WIDTH_32            ((uint32_t)0x00000020U)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_NORSRAM_Flash_Access FMC NOR/SRAM Flash Access
N  * @{
N  */
N#define FMC_NORSRAM_FLASH_ACCESS_ENABLE         ((uint32_t)0x00000040U)
N#define FMC_NORSRAM_FLASH_ACCESS_DISABLE        ((uint32_t)0x00000000U)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_Burst_Access_Mode FMC Burst Access Mode
N  * @{
N  */
N#define FMC_BURST_ACCESS_MODE_DISABLE           ((uint32_t)0x00000000U) 
N#define FMC_BURST_ACCESS_MODE_ENABLE            ((uint32_t)0x00000100U)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_Wait_Signal_Polarity FMC Wait Signal Polarity
N  * @{
N  */
N#define FMC_WAIT_SIGNAL_POLARITY_LOW            ((uint32_t)0x00000000U)
N#define FMC_WAIT_SIGNAL_POLARITY_HIGH           ((uint32_t)0x00000200U)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_Wait_Timing FMC Wait Timing
N  * @{
N  */
N#define FMC_WAIT_TIMING_BEFORE_WS               ((uint32_t)0x00000000U)
N#define FMC_WAIT_TIMING_DURING_WS               ((uint32_t)0x00000800U) 
N/**
N  * @}
N  */
N
N/** @defgroup FMC_Write_Operation FMC Write Operation
N  * @{
N  */
N#define FMC_WRITE_OPERATION_DISABLE             ((uint32_t)0x00000000U)
N#define FMC_WRITE_OPERATION_ENABLE              ((uint32_t)0x00001000U)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_Wait_Signal FMC Wait Signal
N  * @{
N  */
N#define FMC_WAIT_SIGNAL_DISABLE                 ((uint32_t)0x00000000U)
N#define FMC_WAIT_SIGNAL_ENABLE                  ((uint32_t)0x00002000U)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_Extended_Mode FMC Extended Mode
N  * @{
N  */
N#define FMC_EXTENDED_MODE_DISABLE               ((uint32_t)0x00000000U)
N#define FMC_EXTENDED_MODE_ENABLE                ((uint32_t)0x00004000U)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_AsynchronousWait FMC Asynchronous Wait
N  * @{
N  */
N#define FMC_ASYNCHRONOUS_WAIT_DISABLE           ((uint32_t)0x00000000U)
N#define FMC_ASYNCHRONOUS_WAIT_ENABLE            ((uint32_t)0x00008000U)
N/**
N  * @}
N  */  
N
N/** @defgroup FMC_Page_Size FMC Page Size
N  * @{
N  */
N#define FMC_PAGE_SIZE_NONE           ((uint32_t)0x00000000U)
N#define FMC_PAGE_SIZE_128            ((uint32_t)FMC_BCR1_CPSIZE_0)
N#define FMC_PAGE_SIZE_256            ((uint32_t)FMC_BCR1_CPSIZE_1)
N#define FMC_PAGE_SIZE_512            ((uint32_t)(FMC_BCR1_CPSIZE_0 | FMC_BCR1_CPSIZE_1))
N#define FMC_PAGE_SIZE_1024           ((uint32_t)FMC_BCR1_CPSIZE_2)
N/**
N  * @}
N  */  
N
N/** @defgroup FMC_Write_Burst FMC Write Burst
N  * @{
N  */
N#define FMC_WRITE_BURST_DISABLE                 ((uint32_t)0x00000000U)
N#define FMC_WRITE_BURST_ENABLE                  ((uint32_t)0x00080000U) 
N/**
N  * @}
N  */
N  
N/** @defgroup FMC_Continous_Clock FMC Continuous Clock
N  * @{
N  */
N#define FMC_CONTINUOUS_CLOCK_SYNC_ONLY          ((uint32_t)0x00000000U)
N#define FMC_CONTINUOUS_CLOCK_SYNC_ASYNC         ((uint32_t)0x00100000U)
N/**
N  * @}
N  */ 
N
N/** @defgroup FMC_Write_FIFO FMC Write FIFO 
N  * @{
N  */
N#define FMC_WRITE_FIFO_DISABLE           ((uint32_t)FMC_BCR1_WFDIS)
N#define FMC_WRITE_FIFO_ENABLE            ((uint32_t)0x00000000U)
N/**
N  * @}
N  */
N	
N/** @defgroup FMC_Access_Mode FMC Access Mode 
N  * @{
N  */
N#define FMC_ACCESS_MODE_A                        ((uint32_t)0x00000000U)
N#define FMC_ACCESS_MODE_B                        ((uint32_t)0x10000000U) 
N#define FMC_ACCESS_MODE_C                        ((uint32_t)0x20000000U)
N#define FMC_ACCESS_MODE_D                        ((uint32_t)0x30000000)
N/**
N  * @}
N  */
N    
N/**
N  * @}
N  */ 
N
N/** @defgroup FMC_LL_NAND_Controller FMC NAND Controller 
N  * @{
N  */
N/** @defgroup FMC_NAND_Bank FMC NAND Bank 
N  * @{
N  */
N#define FMC_NAND_BANK3                          ((uint32_t)0x00000100U) 
N/**
N  * @}
N  */
N
N/** @defgroup FMC_Wait_feature FMC Wait feature
N  * @{
N  */
N#define FMC_NAND_WAIT_FEATURE_DISABLE           ((uint32_t)0x00000000U)
N#define FMC_NAND_WAIT_FEATURE_ENABLE            ((uint32_t)0x00000002U)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_PCR_Memory_Type FMC PCR Memory Type 
N  * @{
N  */
N#define FMC_PCR_MEMORY_TYPE_NAND          ((uint32_t)0x00000008U)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_NAND_Data_Width FMC NAND Data Width 
N  * @{
N  */
N#define FMC_NAND_MEM_BUS_WIDTH_8                ((uint32_t)0x00000000U)
N#define FMC_NAND_MEM_BUS_WIDTH_16               ((uint32_t)0x00000010U)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_ECC FMC ECC 
N  * @{
N  */
N#define FMC_NAND_ECC_DISABLE                    ((uint32_t)0x00000000U)
N#define FMC_NAND_ECC_ENABLE                     ((uint32_t)0x00000040U)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_ECC_Page_Size FMC ECC Page Size 
N  * @{
N  */
N#define FMC_NAND_ECC_PAGE_SIZE_256BYTE          ((uint32_t)0x00000000U)
N#define FMC_NAND_ECC_PAGE_SIZE_512BYTE          ((uint32_t)0x00020000U)
N#define FMC_NAND_ECC_PAGE_SIZE_1024BYTE         ((uint32_t)0x00040000U)
N#define FMC_NAND_ECC_PAGE_SIZE_2048BYTE         ((uint32_t)0x00060000U)
N#define FMC_NAND_ECC_PAGE_SIZE_4096BYTE         ((uint32_t)0x00080000U)
N#define FMC_NAND_ECC_PAGE_SIZE_8192BYTE         ((uint32_t)0x000A0000U)
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */ 
N
N/** @defgroup FMC_LL_SDRAM_Controller FMC SDRAM Controller 
N  * @{
N  */
N/** @defgroup FMC_SDRAM_Bank FMC SDRAM Bank
N  * @{
N  */
N#define FMC_SDRAM_BANK1                       ((uint32_t)0x00000000U)
N#define FMC_SDRAM_BANK2                       ((uint32_t)0x00000001U)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_SDRAM_Column_Bits_number FMC SDRAM Column Bits number 
N  * @{
N  */
N#define FMC_SDRAM_COLUMN_BITS_NUM_8           ((uint32_t)0x00000000U)
N#define FMC_SDRAM_COLUMN_BITS_NUM_9           ((uint32_t)0x00000001U)
N#define FMC_SDRAM_COLUMN_BITS_NUM_10          ((uint32_t)0x00000002U)
N#define FMC_SDRAM_COLUMN_BITS_NUM_11          ((uint32_t)0x00000003U)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_SDRAM_Row_Bits_number FMC SDRAM Row Bits number
N  * @{
N  */
N#define FMC_SDRAM_ROW_BITS_NUM_11             ((uint32_t)0x00000000U)
N#define FMC_SDRAM_ROW_BITS_NUM_12             ((uint32_t)0x00000004U)
N#define FMC_SDRAM_ROW_BITS_NUM_13             ((uint32_t)0x00000008U)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_SDRAM_Memory_Bus_Width FMC SDRAM Memory Bus Width
N  * @{
N  */
N#define FMC_SDRAM_MEM_BUS_WIDTH_8             ((uint32_t)0x00000000U)
N#define FMC_SDRAM_MEM_BUS_WIDTH_16            ((uint32_t)0x00000010U)
N#define FMC_SDRAM_MEM_BUS_WIDTH_32            ((uint32_t)0x00000020U)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_SDRAM_Internal_Banks_Number FMC SDRAM Internal Banks Number
N  * @{
N  */
N#define FMC_SDRAM_INTERN_BANKS_NUM_2          ((uint32_t)0x00000000U)
N#define FMC_SDRAM_INTERN_BANKS_NUM_4          ((uint32_t)0x00000040U)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_SDRAM_CAS_Latency FMC SDRAM CAS Latency
N  * @{
N  */
N#define FMC_SDRAM_CAS_LATENCY_1               ((uint32_t)0x00000080U)
N#define FMC_SDRAM_CAS_LATENCY_2               ((uint32_t)0x00000100U)
N#define FMC_SDRAM_CAS_LATENCY_3               ((uint32_t)0x00000180)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_SDRAM_Write_Protection FMC SDRAM Write Protection
N  * @{
N  */
N#define FMC_SDRAM_WRITE_PROTECTION_DISABLE    ((uint32_t)0x00000000U)
N#define FMC_SDRAM_WRITE_PROTECTION_ENABLE     ((uint32_t)0x00000200U)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_SDRAM_Clock_Period FMC SDRAM Clock Period
N  * @{
N  */
N#define FMC_SDRAM_CLOCK_DISABLE               ((uint32_t)0x00000000U)
N#define FMC_SDRAM_CLOCK_PERIOD_2              ((uint32_t)0x00000800U)
N#define FMC_SDRAM_CLOCK_PERIOD_3              ((uint32_t)0x00000C00)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_SDRAM_Read_Burst FMC SDRAM Read Burst
N  * @{
N  */
N#define FMC_SDRAM_RBURST_DISABLE              ((uint32_t)0x00000000U)
N#define FMC_SDRAM_RBURST_ENABLE               ((uint32_t)0x00001000U)
N/**
N  * @}
N  */
N  
N/** @defgroup FMC_SDRAM_Read_Pipe_Delay FMC SDRAM Read Pipe Delay
N  * @{
N  */
N#define FMC_SDRAM_RPIPE_DELAY_0               ((uint32_t)0x00000000U)
N#define FMC_SDRAM_RPIPE_DELAY_1               ((uint32_t)0x00002000U)
N#define FMC_SDRAM_RPIPE_DELAY_2               ((uint32_t)0x00004000U)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_SDRAM_Command_Mode FMC SDRAM Command Mode
N  * @{
N  */
N#define FMC_SDRAM_CMD_NORMAL_MODE             ((uint32_t)0x00000000U)
N#define FMC_SDRAM_CMD_CLK_ENABLE              ((uint32_t)0x00000001U)
N#define FMC_SDRAM_CMD_PALL                    ((uint32_t)0x00000002U)
N#define FMC_SDRAM_CMD_AUTOREFRESH_MODE        ((uint32_t)0x00000003U)
N#define FMC_SDRAM_CMD_LOAD_MODE               ((uint32_t)0x00000004U)
N#define FMC_SDRAM_CMD_SELFREFRESH_MODE        ((uint32_t)0x00000005U)
N#define FMC_SDRAM_CMD_POWERDOWN_MODE          ((uint32_t)0x00000006U)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_SDRAM_Command_Target FMC SDRAM Command Target
N  * @{
N  */
N#define FMC_SDRAM_CMD_TARGET_BANK2            FMC_SDCMR_CTB2
N#define FMC_SDRAM_CMD_TARGET_BANK1            FMC_SDCMR_CTB1
N#define FMC_SDRAM_CMD_TARGET_BANK1_2          ((uint32_t)0x00000018U)
N/**
N  * @}
N  */
N
N/** @defgroup FMC_SDRAM_Mode_Status FMC SDRAM Mode Status 
N  * @{
N  */
N#define FMC_SDRAM_NORMAL_MODE                     ((uint32_t)0x00000000U)
N#define FMC_SDRAM_SELF_REFRESH_MODE               FMC_SDSR_MODES1_0
N#define FMC_SDRAM_POWER_DOWN_MODE                 FMC_SDSR_MODES1_1
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/** @defgroup FMC_LL_Interrupt_definition FMC Low Layer Interrupt definition  
N  * @{
N  */  
N#define FMC_IT_RISING_EDGE                ((uint32_t)0x00000008U)
N#define FMC_IT_LEVEL                      ((uint32_t)0x00000010U)
N#define FMC_IT_FALLING_EDGE               ((uint32_t)0x00000020U)
N#define FMC_IT_REFRESH_ERROR              ((uint32_t)0x00004000U)
N/**
N  * @}
N  */
N    
N/** @defgroup FMC_LL_Flag_definition FMC Low Layer Flag definition 
N  * @{
N  */ 
N#define FMC_FLAG_RISING_EDGE                    ((uint32_t)0x00000001U)
N#define FMC_FLAG_LEVEL                          ((uint32_t)0x00000002U)
N#define FMC_FLAG_FALLING_EDGE                   ((uint32_t)0x00000004U)
N#define FMC_FLAG_FEMPT                          ((uint32_t)0x00000040U)
N#define FMC_SDRAM_FLAG_REFRESH_IT               FMC_SDSR_RE
N#define FMC_SDRAM_FLAG_BUSY                     FMC_SDSR_BUSY
N#define FMC_SDRAM_FLAG_REFRESH_ERROR            FMC_SDRTR_CRE
N/**
N  * @}
N  */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private macro -------------------------------------------------------------*/
N/** @defgroup FMC_LL_Private_Macros FMC_LL  Private Macros
N  * @{
N  */
N
N/** @defgroup FMC_LL_NOR_Macros FMC NOR/SRAM Macros
N *  @brief macros to handle NOR device enable/disable and read/write operations
N *  @{
N */
N 
N/**
N  * @brief  Enable the NORSRAM device access.
N  * @param  __INSTANCE__: FMC_NORSRAM Instance
N  * @param  __BANK__: FMC_NORSRAM Bank     
N  * @retval None
N  */ 
N#define __FMC_NORSRAM_ENABLE(__INSTANCE__, __BANK__)  ((__INSTANCE__)->BTCR[(__BANK__)] |= FMC_BCR1_MBKEN)
N
N/**
N  * @brief  Disable the NORSRAM device access.
N  * @param  __INSTANCE__: FMC_NORSRAM Instance
N  * @param  __BANK__: FMC_NORSRAM Bank   
N  * @retval None
N  */ 
N#define __FMC_NORSRAM_DISABLE(__INSTANCE__, __BANK__) ((__INSTANCE__)->BTCR[(__BANK__)] &= ~FMC_BCR1_MBKEN)  
N
N/**
N  * @}
N  */ 
N
N/** @defgroup FMC_LL_NAND_Macros FMC NAND Macros
N *  @brief macros to handle NAND device enable/disable
N *  @{
N */
N 
N/**
N  * @brief  Enable the NAND device access.
N  * @param  __INSTANCE__: FMC_NAND Instance    
N  * @retval None
N  */  
N#define __FMC_NAND_ENABLE(__INSTANCE__)  ((__INSTANCE__)->PCR |= FMC_PCR_PBKEN)
N
N/**
N  * @brief  Disable the NAND device access.
N  * @param  __INSTANCE__: FMC_NAND Instance  
N  * @retval None
N  */
N#define __FMC_NAND_DISABLE(__INSTANCE__) ((__INSTANCE__)->PCR &= ~FMC_PCR_PBKEN)
N
N/**
N  * @}
N  */ 
N    
N/** @defgroup FMC_Interrupt FMC Interrupt
N *  @brief macros to handle FMC interrupts
N * @{
N */ 
N
N/**
N  * @brief  Enable the NAND device interrupt.
N  * @param  __INSTANCE__:  FMC_NAND instance     
N  * @param  __INTERRUPT__: FMC_NAND interrupt 
N  *         This parameter can be any combination of the following values:
N  *            @arg FMC_IT_RISING_EDGE: Interrupt rising edge.
N  *            @arg FMC_IT_LEVEL: Interrupt level.
N  *            @arg FMC_IT_FALLING_EDGE: Interrupt falling edge.       
N  * @retval None
N  */  
N#define __FMC_NAND_ENABLE_IT(__INSTANCE__, __INTERRUPT__)  ((__INSTANCE__)->SR |= (__INTERRUPT__))
N
N/**
N  * @brief  Disable the NAND device interrupt.
N  * @param  __INSTANCE__:  FMC_NAND Instance
N  * @param  __INTERRUPT__: FMC_NAND interrupt
N  *         This parameter can be any combination of the following values:
N  *            @arg FMC_IT_RISING_EDGE: Interrupt rising edge.
N  *            @arg FMC_IT_LEVEL: Interrupt level.
N  *            @arg FMC_IT_FALLING_EDGE: Interrupt falling edge.   
N  * @retval None
N  */
N#define __FMC_NAND_DISABLE_IT(__INSTANCE__, __INTERRUPT__)  ((__INSTANCE__)->SR &= ~(__INTERRUPT__))
N                                                                                                                           
N/**
N  * @brief  Get flag status of the NAND device.
N  * @param  __INSTANCE__: FMC_NAND Instance
N  * @param  __BANK__:     FMC_NAND Bank     
N  * @param  __FLAG__: FMC_NAND flag
N  *         This parameter can be any combination of the following values:
N  *            @arg FMC_FLAG_RISING_EDGE: Interrupt rising edge flag.
N  *            @arg FMC_FLAG_LEVEL: Interrupt level edge flag.
N  *            @arg FMC_FLAG_FALLING_EDGE: Interrupt falling edge flag.
N  *            @arg FMC_FLAG_FEMPT: FIFO empty flag.   
N  * @retval The state of FLAG (SET or RESET).
N  */
N#define __FMC_NAND_GET_FLAG(__INSTANCE__, __BANK__, __FLAG__)  (((__INSTANCE__)->SR &(__FLAG__)) == (__FLAG__))
N
N/**
N  * @brief  Clear flag status of the NAND device.
N  * @param  __INSTANCE__: FMC_NAND Instance   
N  * @param  __FLAG__: FMC_NAND flag
N  *         This parameter can be any combination of the following values:
N  *            @arg FMC_FLAG_RISING_EDGE: Interrupt rising edge flag.
N  *            @arg FMC_FLAG_LEVEL: Interrupt level edge flag.
N  *            @arg FMC_FLAG_FALLING_EDGE: Interrupt falling edge flag.
N  *            @arg FMC_FLAG_FEMPT: FIFO empty flag.   
N  * @retval None
N  */
N#define __FMC_NAND_CLEAR_FLAG(__INSTANCE__, __FLAG__)  ((__INSTANCE__)->SR &= ~(__FLAG__))  
N
N/**
N  * @brief  Enable the SDRAM device interrupt.
N  * @param  __INSTANCE__: FMC_SDRAM instance  
N  * @param  __INTERRUPT__: FMC_SDRAM interrupt 
N  *         This parameter can be any combination of the following values:
N  *            @arg FMC_IT_REFRESH_ERROR: Interrupt refresh error      
N  * @retval None
N  */
N#define __FMC_SDRAM_ENABLE_IT(__INSTANCE__, __INTERRUPT__)  ((__INSTANCE__)->SDRTR |= (__INTERRUPT__))
N
N/**
N  * @brief  Disable the SDRAM device interrupt.
N  * @param  __INSTANCE__: FMC_SDRAM instance  
N  * @param  __INTERRUPT__: FMC_SDRAM interrupt 
N  *         This parameter can be any combination of the following values:
N  *            @arg FMC_IT_REFRESH_ERROR: Interrupt refresh error      
N  * @retval None
N  */
N#define __FMC_SDRAM_DISABLE_IT(__INSTANCE__, __INTERRUPT__)  ((__INSTANCE__)->SDRTR &= ~(__INTERRUPT__))
N
N/**
N  * @brief  Get flag status of the SDRAM device.
N  * @param  __INSTANCE__: FMC_SDRAM instance  
N  * @param  __FLAG__: FMC_SDRAM flag
N  *         This parameter can be any combination of the following values:
N  *            @arg FMC_SDRAM_FLAG_REFRESH_IT: Interrupt refresh error.
N  *            @arg FMC_SDRAM_FLAG_BUSY: SDRAM busy flag.
N  *            @arg FMC_SDRAM_FLAG_REFRESH_ERROR: Refresh error flag.
N  * @retval The state of FLAG (SET or RESET).
N  */
N#define __FMC_SDRAM_GET_FLAG(__INSTANCE__, __FLAG__)  (((__INSTANCE__)->SDSR &(__FLAG__)) == (__FLAG__))
N
N/**
N  * @brief  Clear flag status of the SDRAM device.
N  * @param  __INSTANCE__: FMC_SDRAM instance  
N  * @param  __FLAG__: FMC_SDRAM flag
N  *         This parameter can be any combination of the following values:
N  *           @arg FMC_SDRAM_FLAG_REFRESH_ERROR
N  * @retval None
N  */
N#define __FMC_SDRAM_CLEAR_FLAG(__INSTANCE__, __FLAG__)  ((__INSTANCE__)->SDRTR |= (__FLAG__))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup FMC_LL_Private_Functions FMC LL Private Functions
N  *  @{
N  */
N
N/** @defgroup FMC_LL_NORSRAM  NOR SRAM
N  *  @{
N  */
N/** @defgroup FMC_LL_NORSRAM_Private_Functions_Group1 NOR SRAM Initialization/de-initialization functions 
N  *  @{
N  */
NHAL_StatusTypeDef  FMC_NORSRAM_Init(FMC_NORSRAM_TypeDef *Device, FMC_NORSRAM_InitTypeDef *Init);
XHAL_StatusTypeDef  FMC_NORSRAM_Init(FMC_Bank1_TypeDef *Device, FMC_NORSRAM_InitTypeDef *Init);
NHAL_StatusTypeDef  FMC_NORSRAM_Timing_Init(FMC_NORSRAM_TypeDef *Device, FMC_NORSRAM_TimingTypeDef *Timing, uint32_t Bank);
XHAL_StatusTypeDef  FMC_NORSRAM_Timing_Init(FMC_Bank1_TypeDef *Device, FMC_NORSRAM_TimingTypeDef *Timing, uint32_t Bank);
NHAL_StatusTypeDef  FMC_NORSRAM_Extended_Timing_Init(FMC_NORSRAM_EXTENDED_TypeDef *Device, FMC_NORSRAM_TimingTypeDef *Timing, uint32_t Bank, uint32_t ExtendedMode);
XHAL_StatusTypeDef  FMC_NORSRAM_Extended_Timing_Init(FMC_Bank1E_TypeDef *Device, FMC_NORSRAM_TimingTypeDef *Timing, uint32_t Bank, uint32_t ExtendedMode);
NHAL_StatusTypeDef  FMC_NORSRAM_DeInit(FMC_NORSRAM_TypeDef *Device, FMC_NORSRAM_EXTENDED_TypeDef *ExDevice, uint32_t Bank);
XHAL_StatusTypeDef  FMC_NORSRAM_DeInit(FMC_Bank1_TypeDef *Device, FMC_Bank1E_TypeDef *ExDevice, uint32_t Bank);
N/**
N  * @}
N  */ 
N
N/** @defgroup FMC_LL_NORSRAM_Private_Functions_Group2 NOR SRAM Control functions 
N  *  @{
N  */
NHAL_StatusTypeDef  FMC_NORSRAM_WriteOperation_Enable(FMC_NORSRAM_TypeDef *Device, uint32_t Bank);
XHAL_StatusTypeDef  FMC_NORSRAM_WriteOperation_Enable(FMC_Bank1_TypeDef *Device, uint32_t Bank);
NHAL_StatusTypeDef  FMC_NORSRAM_WriteOperation_Disable(FMC_NORSRAM_TypeDef *Device, uint32_t Bank);
XHAL_StatusTypeDef  FMC_NORSRAM_WriteOperation_Disable(FMC_Bank1_TypeDef *Device, uint32_t Bank);
N/**
N  * @}
N  */
N/**
N  * @}
N  */
N
N/** @defgroup FMC_LL_NAND NAND
N  *  @{
N  */
N/** @defgroup FMC_LL_NAND_Private_Functions_Group1 NAND Initialization/de-initialization functions 
N  *  @{
N  */
NHAL_StatusTypeDef  FMC_NAND_Init(FMC_NAND_TypeDef *Device, FMC_NAND_InitTypeDef *Init);
XHAL_StatusTypeDef  FMC_NAND_Init(FMC_Bank3_TypeDef *Device, FMC_NAND_InitTypeDef *Init);
NHAL_StatusTypeDef  FMC_NAND_CommonSpace_Timing_Init(FMC_NAND_TypeDef *Device, FMC_NAND_PCC_TimingTypeDef *Timing, uint32_t Bank);
XHAL_StatusTypeDef  FMC_NAND_CommonSpace_Timing_Init(FMC_Bank3_TypeDef *Device, FMC_NAND_PCC_TimingTypeDef *Timing, uint32_t Bank);
NHAL_StatusTypeDef  FMC_NAND_AttributeSpace_Timing_Init(FMC_NAND_TypeDef *Device, FMC_NAND_PCC_TimingTypeDef *Timing, uint32_t Bank);
XHAL_StatusTypeDef  FMC_NAND_AttributeSpace_Timing_Init(FMC_Bank3_TypeDef *Device, FMC_NAND_PCC_TimingTypeDef *Timing, uint32_t Bank);
NHAL_StatusTypeDef  FMC_NAND_DeInit(FMC_NAND_TypeDef *Device, uint32_t Bank);
XHAL_StatusTypeDef  FMC_NAND_DeInit(FMC_Bank3_TypeDef *Device, uint32_t Bank);
N/**
N  * @}
N  */
N
N/** @defgroup FMC_LL_NAND_Private_Functions_Group2 NAND Control functions 
N  *  @{
N  */
NHAL_StatusTypeDef  FMC_NAND_ECC_Enable(FMC_NAND_TypeDef *Device, uint32_t Bank);
XHAL_StatusTypeDef  FMC_NAND_ECC_Enable(FMC_Bank3_TypeDef *Device, uint32_t Bank);
NHAL_StatusTypeDef  FMC_NAND_ECC_Disable(FMC_NAND_TypeDef *Device, uint32_t Bank);
XHAL_StatusTypeDef  FMC_NAND_ECC_Disable(FMC_Bank3_TypeDef *Device, uint32_t Bank);
NHAL_StatusTypeDef  FMC_NAND_GetECC(FMC_NAND_TypeDef *Device, uint32_t *ECCval, uint32_t Bank, uint32_t Timeout);
XHAL_StatusTypeDef  FMC_NAND_GetECC(FMC_Bank3_TypeDef *Device, uint32_t *ECCval, uint32_t Bank, uint32_t Timeout);
N/**
N  * @}
N  */
N
N/** @defgroup FMC_LL_SDRAM SDRAM
N  *  @{
N  */
N/** @defgroup FMC_LL_SDRAM_Private_Functions_Group1 SDRAM Initialization/de-initialization functions 
N  *  @{
N  */
NHAL_StatusTypeDef  FMC_SDRAM_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_InitTypeDef *Init);
XHAL_StatusTypeDef  FMC_SDRAM_Init(FMC_Bank5_6_TypeDef *Device, FMC_SDRAM_InitTypeDef *Init);
NHAL_StatusTypeDef  FMC_SDRAM_Timing_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_TimingTypeDef *Timing, uint32_t Bank);
XHAL_StatusTypeDef  FMC_SDRAM_Timing_Init(FMC_Bank5_6_TypeDef *Device, FMC_SDRAM_TimingTypeDef *Timing, uint32_t Bank);
NHAL_StatusTypeDef  FMC_SDRAM_DeInit(FMC_SDRAM_TypeDef *Device, uint32_t Bank);
XHAL_StatusTypeDef  FMC_SDRAM_DeInit(FMC_Bank5_6_TypeDef *Device, uint32_t Bank);
N
N/**
N  * @}
N  */
N
N/** @defgroup FMC_LL_SDRAM_Private_Functions_Group2 SDRAM Control functions 
N  *  @{
N  */
NHAL_StatusTypeDef  FMC_SDRAM_WriteProtection_Enable(FMC_SDRAM_TypeDef *Device, uint32_t Bank);
XHAL_StatusTypeDef  FMC_SDRAM_WriteProtection_Enable(FMC_Bank5_6_TypeDef *Device, uint32_t Bank);
NHAL_StatusTypeDef  FMC_SDRAM_WriteProtection_Disable(FMC_SDRAM_TypeDef *Device, uint32_t Bank);
XHAL_StatusTypeDef  FMC_SDRAM_WriteProtection_Disable(FMC_Bank5_6_TypeDef *Device, uint32_t Bank);
NHAL_StatusTypeDef  FMC_SDRAM_SendCommand(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout);
XHAL_StatusTypeDef  FMC_SDRAM_SendCommand(FMC_Bank5_6_TypeDef *Device, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout);
NHAL_StatusTypeDef  FMC_SDRAM_ProgramRefreshRate(FMC_SDRAM_TypeDef *Device, uint32_t RefreshRate);
XHAL_StatusTypeDef  FMC_SDRAM_ProgramRefreshRate(FMC_Bank5_6_TypeDef *Device, uint32_t RefreshRate);
NHAL_StatusTypeDef  FMC_SDRAM_SetAutoRefreshNumber(FMC_SDRAM_TypeDef *Device, uint32_t AutoRefreshNumber);
XHAL_StatusTypeDef  FMC_SDRAM_SetAutoRefreshNumber(FMC_Bank5_6_TypeDef *Device, uint32_t AutoRefreshNumber);
Nuint32_t           FMC_SDRAM_GetModeStatus(FMC_SDRAM_TypeDef *Device, uint32_t Bank);
Xuint32_t           FMC_SDRAM_GetModeStatus(FMC_Bank5_6_TypeDef *Device, uint32_t Bank);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_LL_FMC_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 48 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_sram.h" 2
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N/** @addtogroup SRAM
N  * @{
N  */ 
N
N/* Exported typedef ----------------------------------------------------------*/
N
N/** @defgroup SRAM_Exported_Types SRAM Exported Types
N  * @{
N  */
N/** 
N  * @brief  HAL SRAM State structures definition  
N  */ 
Ntypedef enum
N{
N  HAL_SRAM_STATE_RESET     = 0x00U,  /*!< SRAM not yet initialized or disabled           */
N  HAL_SRAM_STATE_READY     = 0x01U,  /*!< SRAM initialized and ready for use             */
N  HAL_SRAM_STATE_BUSY      = 0x02U,  /*!< SRAM internal process is ongoing               */
N  HAL_SRAM_STATE_ERROR     = 0x03U,  /*!< SRAM error state                               */
N  HAL_SRAM_STATE_PROTECTED = 0x04U   /*!< SRAM peripheral NORSRAM device write protected */
N  
N}HAL_SRAM_StateTypeDef;
N
N/** 
N  * @brief  SRAM handle Structure definition  
N  */ 
Ntypedef struct
N{
N  FMC_NORSRAM_TypeDef           *Instance;  /*!< Register base address                        */ 
X  FMC_Bank1_TypeDef           *Instance;    
N  
N  FMC_NORSRAM_EXTENDED_TypeDef  *Extended;  /*!< Extended mode register base address          */
X  FMC_Bank1E_TypeDef  *Extended;   
N  
N  FMC_NORSRAM_InitTypeDef       Init;       /*!< SRAM device control configuration parameters */
N
N  HAL_LockTypeDef               Lock;       /*!< SRAM locking object                          */ 
N  
N  __IO HAL_SRAM_StateTypeDef    State;      /*!< SRAM device access state                     */
X  volatile HAL_SRAM_StateTypeDef    State;       
N  
N  DMA_HandleTypeDef             *hdma;      /*!< Pointer DMA handler                          */
N  
N}SRAM_HandleTypeDef; 
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N
N/** @defgroup SRAM_Exported_Macros SRAM Exported Macros
N * @{
N */
N
N/** @brief Reset SRAM handle state
N  * @param  __HANDLE__: SRAM handle
N  * @retval None
N  */
N#define __HAL_SRAM_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_SRAM_STATE_RESET)
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup SRAM_Exported_Functions SRAM Exported Functions
N  * @{
N  */
N
N/** @addtogroup SRAM_Exported_Functions_Group1 Initialization and de-initialization functions
N * @{
N */
N
N/* Initialization/de-initialization functions  ********************************/
NHAL_StatusTypeDef HAL_SRAM_Init(SRAM_HandleTypeDef *hsram, FMC_NORSRAM_TimingTypeDef *Timing, FMC_NORSRAM_TimingTypeDef *ExtTiming);
NHAL_StatusTypeDef HAL_SRAM_DeInit(SRAM_HandleTypeDef *hsram);
Nvoid HAL_SRAM_MspInit(SRAM_HandleTypeDef *hsram);
Nvoid HAL_SRAM_MspDeInit(SRAM_HandleTypeDef *hsram);
N
N/**
N  * @}
N  */
N
N/** @addtogroup SRAM_Exported_Functions_Group2 Input Output and memory control functions
N * @{
N */
N
N/* I/O operation functions  ***************************************************/
NHAL_StatusTypeDef HAL_SRAM_Read_8b(SRAM_HandleTypeDef *hsram, uint32_t *pAddress, uint8_t *pDstBuffer, uint32_t BufferSize);
NHAL_StatusTypeDef HAL_SRAM_Write_8b(SRAM_HandleTypeDef *hsram, uint32_t *pAddress, uint8_t *pSrcBuffer, uint32_t BufferSize);
NHAL_StatusTypeDef HAL_SRAM_Read_16b(SRAM_HandleTypeDef *hsram, uint32_t *pAddress, uint16_t *pDstBuffer, uint32_t BufferSize);
NHAL_StatusTypeDef HAL_SRAM_Write_16b(SRAM_HandleTypeDef *hsram, uint32_t *pAddress, uint16_t *pSrcBuffer, uint32_t BufferSize);
NHAL_StatusTypeDef HAL_SRAM_Read_32b(SRAM_HandleTypeDef *hsram, uint32_t *pAddress, uint32_t *pDstBuffer, uint32_t BufferSize);
NHAL_StatusTypeDef HAL_SRAM_Write_32b(SRAM_HandleTypeDef *hsram, uint32_t *pAddress, uint32_t *pSrcBuffer, uint32_t BufferSize);
NHAL_StatusTypeDef HAL_SRAM_Read_DMA(SRAM_HandleTypeDef *hsram, uint32_t *pAddress, uint32_t *pDstBuffer, uint32_t BufferSize);
NHAL_StatusTypeDef HAL_SRAM_Write_DMA(SRAM_HandleTypeDef *hsram, uint32_t *pAddress, uint32_t *pSrcBuffer, uint32_t BufferSize);
N
Nvoid HAL_SRAM_DMA_XferCpltCallback(DMA_HandleTypeDef *hdma);
Nvoid HAL_SRAM_DMA_XferErrorCallback(DMA_HandleTypeDef *hdma);
N
N/**
N  * @}
N  */
N  
N/** @addtogroup SRAM_Exported_Functions_Group3 Control functions
N * @{
N */
N
N/* SRAM Control functions  ****************************************************/
NHAL_StatusTypeDef HAL_SRAM_WriteOperation_Enable(SRAM_HandleTypeDef *hsram);
NHAL_StatusTypeDef HAL_SRAM_WriteOperation_Disable(SRAM_HandleTypeDef *hsram);
N
N/**
N  * @}
N  */
N
N/** @addtogroup SRAM_Exported_Functions_Group4 Peripheral State functions
N * @{
N */
N
N/* SRAM  State functions ******************************************************/
NHAL_SRAM_StateTypeDef HAL_SRAM_GetState(SRAM_HandleTypeDef *hsram);
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_SRAM_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 303 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_SRAM_MODULE_ENABLED */
N
N#ifdef HAL_NOR_MODULE_ENABLED
N  #include "stm32f7xx_hal_nor.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_nor.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_nor.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of NOR HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_NOR_H
N#define __STM32F7xx_HAL_NOR_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_ll_fmc.h"
N
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup NOR
N  * @{
N  */ 
N
N/* Exported typedef ----------------------------------------------------------*/
N/** @defgroup NOR_Exported_Types NOR Exported Types
N  * @{
N  */
N
N/** 
N  * @brief  HAL SRAM State structures definition  
N  */ 
Ntypedef enum
N{  
N  HAL_NOR_STATE_RESET             = 0x00U,  /*!< NOR not yet initialized or disabled  */
N  HAL_NOR_STATE_READY             = 0x01U,  /*!< NOR initialized and ready for use    */
N  HAL_NOR_STATE_BUSY              = 0x02U,  /*!< NOR internal processing is ongoing   */
N  HAL_NOR_STATE_ERROR             = 0x03U,  /*!< NOR error state                      */
N  HAL_NOR_STATE_PROTECTED         = 0x04U   /*!< NOR NORSRAM device write protected   */
N}HAL_NOR_StateTypeDef;
N
N/**
N  * @brief  FMC NOR Status typedef
N  */
Ntypedef enum
N{
N  HAL_NOR_STATUS_SUCCESS  = 0U,
N  HAL_NOR_STATUS_ONGOING,
N  HAL_NOR_STATUS_ERROR,
N  HAL_NOR_STATUS_TIMEOUT
N}HAL_NOR_StatusTypeDef;
N
N/**
N  * @brief  FMC NOR ID typedef
N  */
Ntypedef struct
N{
N  uint16_t Manufacturer_Code;  /*!< Defines the device's manufacturer code used to identify the memory       */
N
N  uint16_t Device_Code1;
N
N  uint16_t Device_Code2;
N
N  uint16_t Device_Code3;       /*!< Defines the device's codes used to identify the memory. 
N                                    These codes can be accessed by performing read operations with specific 
N                                    control signals and addresses set.They can also be accessed by issuing 
N                                    an Auto Select command                                                   */
N}NOR_IDTypeDef;
N
N/**
N  * @brief  FMC NOR CFI typedef
N  */
Ntypedef struct
N{
N  /*!< Defines the information stored in the memory's Common flash interface
N       which contains a description of various electrical and timing parameters, 
N       density information and functions supported by the memory                   */
N
N  uint16_t CFI_1;
N
N  uint16_t CFI_2;
N
N  uint16_t CFI_3;
N
N  uint16_t CFI_4;
N}NOR_CFITypeDef;
N
N/** 
N  * @brief  NOR handle Structure definition
N  */ 
Ntypedef struct
N{
N  FMC_NORSRAM_TypeDef           *Instance;    /*!< Register base address                        */
X  FMC_Bank1_TypeDef           *Instance;     
N
N  FMC_NORSRAM_EXTENDED_TypeDef  *Extended;    /*!< Extended mode register base address          */
X  FMC_Bank1E_TypeDef  *Extended;     
N
N  FMC_NORSRAM_InitTypeDef       Init;         /*!< NOR device control configuration parameters  */
N
N  HAL_LockTypeDef               Lock;         /*!< NOR locking object                           */
N
N  __IO HAL_NOR_StateTypeDef     State;        /*!< NOR device access state                      */
X  volatile HAL_NOR_StateTypeDef     State;         
N
N}NOR_HandleTypeDef;
N/**
N  * @}
N  */
N  
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup NOR_Exported_Macros NOR Exported Macros
N  * @{
N  */
N/** @brief Reset NOR handle state
N  * @param  __HANDLE__: specifies the NOR handle.
N  * @retval None
N  */
N#define __HAL_NOR_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_NOR_STATE_RESET)
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup NOR_Exported_Functions NOR Exported Functions
N  * @{
N  */
N
N/** @addtogroup NOR_Exported_Functions_Group1 Initialization and de-initialization functions 
N  * @{
N  */
N
N/* Initialization/de-initialization functions  ********************************/
NHAL_StatusTypeDef HAL_NOR_Init(NOR_HandleTypeDef *hnor, FMC_NORSRAM_TimingTypeDef *Timing, FMC_NORSRAM_TimingTypeDef *ExtTiming);
NHAL_StatusTypeDef HAL_NOR_DeInit(NOR_HandleTypeDef *hnor);
Nvoid HAL_NOR_MspInit(NOR_HandleTypeDef *hnor);
Nvoid HAL_NOR_MspDeInit(NOR_HandleTypeDef *hnor);
Nvoid HAL_NOR_MspWait(NOR_HandleTypeDef *hnor, uint32_t Timeout);
N/**
N  * @}
N  */
N
N/** @addtogroup NOR_Exported_Functions_Group2 Input and Output functions 
N  * @{
N  */
N
N/* I/O operation functions  ***************************************************/
NHAL_StatusTypeDef HAL_NOR_Read_ID(NOR_HandleTypeDef *hnor, NOR_IDTypeDef *pNOR_ID);
NHAL_StatusTypeDef HAL_NOR_ReturnToReadMode(NOR_HandleTypeDef *hnor);
NHAL_StatusTypeDef HAL_NOR_Read(NOR_HandleTypeDef *hnor, uint32_t *pAddress, uint16_t *pData);
NHAL_StatusTypeDef HAL_NOR_Program(NOR_HandleTypeDef *hnor, uint32_t *pAddress, uint16_t *pData);
N
NHAL_StatusTypeDef HAL_NOR_ReadBuffer(NOR_HandleTypeDef *hnor, uint32_t uwAddress, uint16_t *pData, uint32_t uwBufferSize);
NHAL_StatusTypeDef HAL_NOR_ProgramBuffer(NOR_HandleTypeDef *hnor, uint32_t uwAddress, uint16_t *pData, uint32_t uwBufferSize);
N
NHAL_StatusTypeDef HAL_NOR_Erase_Block(NOR_HandleTypeDef *hnor, uint32_t BlockAddress, uint32_t Address);
NHAL_StatusTypeDef HAL_NOR_Erase_Chip(NOR_HandleTypeDef *hnor, uint32_t Address);
NHAL_StatusTypeDef HAL_NOR_Read_CFI(NOR_HandleTypeDef *hnor, NOR_CFITypeDef *pNOR_CFI);
N/**
N  * @}
N  */
N  
N/** @addtogroup NOR_Exported_Functions_Group3 NOR Control functions 
N  * @{
N  */
N
N/* NOR Control functions  *****************************************************/
NHAL_StatusTypeDef HAL_NOR_WriteOperation_Enable(NOR_HandleTypeDef *hnor);
NHAL_StatusTypeDef HAL_NOR_WriteOperation_Disable(NOR_HandleTypeDef *hnor);
N/**
N  * @}
N  */
N  
N/** @addtogroup NOR_Exported_Functions_Group4 NOR State functions 
N  * @{
N  */
N
N/* NOR State functions ********************************************************/
NHAL_NOR_StateTypeDef  HAL_NOR_GetState(NOR_HandleTypeDef *hnor);
NHAL_NOR_StatusTypeDef HAL_NOR_GetStatus(NOR_HandleTypeDef *hnor, uint32_t Address, uint32_t Timeout);
N/**
N  * @}
N  */
N    
N/**
N  * @}
N  */
N  
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup NOR_Private_Constants NOR Private Constants
N  * @{
N  */
N/* NOR device IDs addresses */
N#define MC_ADDRESS               ((uint16_t)0x0000U)
N#define DEVICE_CODE1_ADDR        ((uint16_t)0x0001U)
N#define DEVICE_CODE2_ADDR        ((uint16_t)0x000EU)
N#define DEVICE_CODE3_ADDR        ((uint16_t)0x000FU)
N
N/* NOR CFI IDs addresses */
N#define CFI1_ADDRESS             ((uint16_t)0x61U)
N#define CFI2_ADDRESS             ((uint16_t)0x62U)
N#define CFI3_ADDRESS             ((uint16_t)0x63U)
N#define CFI4_ADDRESS             ((uint16_t)0x64U)
N
N/* NOR operation wait timeout */
N#define NOR_TMEOUT               ((uint16_t)0xFFFFU)
N   
N/* NOR memory data width */
N#define NOR_MEMORY_8B            ((uint8_t)0x0U)
N#define NOR_MEMORY_16B           ((uint8_t)0x1U)
N
N/* NOR memory device read/write start address */
N#define NOR_MEMORY_ADRESS1       ((uint32_t)0x60000000U)
N#define NOR_MEMORY_ADRESS2       ((uint32_t)0x64000000U)
N#define NOR_MEMORY_ADRESS3       ((uint32_t)0x68000000U)
N#define NOR_MEMORY_ADRESS4       ((uint32_t)0x6C000000U)
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup NOR_Private_Macros NOR Private Macros
N  * @{
N  */
N/**
N  * @brief  NOR memory address shifting.
N  * @param  __NOR_ADDRESS: NOR base address 
N  * @param  __NOR_MEMORY_WIDTH_: NOR memory width
N  * @param  __ADDRESS__: NOR memory address 
N  * @retval NOR shifted address value
N  */
N#define NOR_ADDR_SHIFT(__NOR_ADDRESS, __NOR_MEMORY_WIDTH_, __ADDRESS__)       \
N            ((uint32_t)(((__NOR_MEMORY_WIDTH_) == NOR_MEMORY_16B)?              \
N              ((uint32_t)((__NOR_ADDRESS) + (2 * (__ADDRESS__)))):              \
N              ((uint32_t)((__NOR_ADDRESS) + (__ADDRESS__)))))
X#define NOR_ADDR_SHIFT(__NOR_ADDRESS, __NOR_MEMORY_WIDTH_, __ADDRESS__)                   ((uint32_t)(((__NOR_MEMORY_WIDTH_) == NOR_MEMORY_16B)?                            ((uint32_t)((__NOR_ADDRESS) + (2 * (__ADDRESS__)))):                            ((uint32_t)((__NOR_ADDRESS) + (__ADDRESS__)))))
N 
N/**
N  * @brief  NOR memory write data to specified address.
N  * @param  __ADDRESS__: NOR memory address 
N  * @param  __DATA__: Data to write
N  * @retval None
N  */
N#define NOR_WRITE(__ADDRESS__, __DATA__)   do{                                                             \
N                                                 (*(__IO uint16_t *)((uint32_t)(__ADDRESS__)) = (__DATA__)); \
N                                                 __DSB();                                                    \
N                                               } while(0)
X#define NOR_WRITE(__ADDRESS__, __DATA__)   do{                                                                                                              (*(__IO uint16_t *)((uint32_t)(__ADDRESS__)) = (__DATA__));                                                  __DSB();                                                                                                   } while(0)
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_NOR_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 307 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_NOR_MODULE_ENABLED */
N
N#ifdef HAL_NAND_MODULE_ENABLED
N  #include "stm32f7xx_hal_nand.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_nand.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_nand.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of NAND HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_NAND_H
N#define __STM32F7xx_HAL_NAND_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_ll_fmc.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup NAND
N  * @{
N  */ 
N
N/* Exported typedef ----------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup NAND_Exported_Types NAND Exported Types
N  * @{
N  */
N
N/** 
N  * @brief  HAL NAND State structures definition
N  */
Ntypedef enum
N{
N  HAL_NAND_STATE_RESET     = 0x00U,  /*!< NAND not yet initialized or disabled */
N  HAL_NAND_STATE_READY     = 0x01U,  /*!< NAND initialized and ready for use   */
N  HAL_NAND_STATE_BUSY      = 0x02U,  /*!< NAND internal process is ongoing     */
N  HAL_NAND_STATE_ERROR     = 0x03U   /*!< NAND error state                     */
N}HAL_NAND_StateTypeDef;
N   
N/** 
N  * @brief  NAND Memory electronic signature Structure definition
N  */
Ntypedef struct
N{
N  /*<! NAND memory electronic signature maker and device IDs */
N
N  uint8_t Maker_Id; 
N
N  uint8_t Device_Id;
N
N  uint8_t Third_Id;
N
N  uint8_t Fourth_Id;
N}NAND_IDTypeDef;
N
N/** 
N  * @brief  NAND Memory address Structure definition
N  */
Ntypedef struct 
N{
N  uint16_t Page;   /*!< NAND memory Page address  */
N
N  uint16_t Zone;   /*!< NAND memory Zone address  */
N
N  uint16_t Block;  /*!< NAND memory Block address */
N
N}NAND_AddressTypeDef;
N
N/** 
N  * @brief  NAND Memory info Structure definition
N  */ 
Ntypedef struct
N{
N  uint32_t PageSize;       /*!< NAND memory page (without spare area) size measured in K. bytes */
N
N  uint32_t SpareAreaSize;  /*!< NAND memory spare area size measured in K. bytes                */
N
N  uint32_t BlockSize;      /*!< NAND memory block size number of pages                          */
N
N  uint32_t BlockNbr;       /*!< NAND memory number of blocks                                    */
N
N  uint32_t ZoneSize;       /*!< NAND memory zone size measured in number of blocks              */
N}NAND_InfoTypeDef;
N
N/** 
N  * @brief  NAND handle Structure definition
N  */   
Ntypedef struct
N{
N  FMC_NAND_TypeDef             *Instance;  /*!< Register base address                        */
X  FMC_Bank3_TypeDef             *Instance;   
N  
N  FMC_NAND_InitTypeDef         Init;       /*!< NAND device control configuration parameters */
N
N  HAL_LockTypeDef              Lock;       /*!< NAND locking object                          */
N
N  __IO HAL_NAND_StateTypeDef   State;      /*!< NAND device access state                     */
X  volatile HAL_NAND_StateTypeDef   State;       
N
N  NAND_InfoTypeDef             Info;       /*!< NAND characteristic information structure    */
N}NAND_HandleTypeDef;
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup NAND_Exported_Macros NAND Exported Macros
N * @{
N */ 
N
N/** @brief Reset NAND handle state
N  * @param  __HANDLE__: specifies the NAND handle.
N  * @retval None
N  */
N#define __HAL_NAND_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_NAND_STATE_RESET)
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup NAND_Exported_Functions NAND Exported Functions
N  * @{
N  */
N    
N/** @addtogroup NAND_Exported_Functions_Group1 Initialization and de-initialization functions 
N  * @{
N  */
N
N/* Initialization/de-initialization functions  ********************************/
NHAL_StatusTypeDef  HAL_NAND_Init(NAND_HandleTypeDef *hnand, FMC_NAND_PCC_TimingTypeDef *ComSpace_Timing, FMC_NAND_PCC_TimingTypeDef *AttSpace_Timing);
NHAL_StatusTypeDef  HAL_NAND_DeInit(NAND_HandleTypeDef *hnand);
Nvoid               HAL_NAND_MspInit(NAND_HandleTypeDef *hnand);
Nvoid               HAL_NAND_MspDeInit(NAND_HandleTypeDef *hnand);
Nvoid               HAL_NAND_IRQHandler(NAND_HandleTypeDef *hnand);
Nvoid               HAL_NAND_ITCallback(NAND_HandleTypeDef *hnand);
N
N/**
N  * @}
N  */
N  
N/** @addtogroup NAND_Exported_Functions_Group2 Input and Output functions 
N  * @{
N  */
N
N/* IO operation functions  ****************************************************/
NHAL_StatusTypeDef  HAL_NAND_Read_ID(NAND_HandleTypeDef *hnand, NAND_IDTypeDef *pNAND_ID);
NHAL_StatusTypeDef  HAL_NAND_Reset(NAND_HandleTypeDef *hnand);
N
NHAL_StatusTypeDef  HAL_NAND_Read_Page_8b(NAND_HandleTypeDef *hnand, NAND_AddressTypeDef *pAddress, uint8_t *pBuffer, uint32_t NumPageToRead);
NHAL_StatusTypeDef  HAL_NAND_Read_Page_16b(NAND_HandleTypeDef *hnand, NAND_AddressTypeDef *pAddress, uint16_t *pBuffer, uint32_t NumPageToRead);
NHAL_StatusTypeDef  HAL_NAND_Write_Page_8b(NAND_HandleTypeDef *hnand, NAND_AddressTypeDef *pAddress, uint8_t *pBuffer, uint32_t NumPageToWrite);
NHAL_StatusTypeDef  HAL_NAND_Write_Page_16b(NAND_HandleTypeDef *hnand, NAND_AddressTypeDef *pAddress, uint16_t *pBuffer, uint32_t NumPageToWrite);
NHAL_StatusTypeDef  HAL_NAND_Read_SpareArea_8b(NAND_HandleTypeDef *hnand, NAND_AddressTypeDef *pAddress, uint8_t *pBuffer, uint32_t NumSpareAreaToRead);
NHAL_StatusTypeDef  HAL_NAND_Read_SpareArea_16b(NAND_HandleTypeDef *hnand, NAND_AddressTypeDef *pAddress, uint16_t *pBuffer, uint32_t NumSpareAreaToRead);
NHAL_StatusTypeDef  HAL_NAND_Write_SpareArea_8b(NAND_HandleTypeDef *hnand, NAND_AddressTypeDef *pAddress, uint8_t *pBuffer, uint32_t NumSpareAreaTowrite);
NHAL_StatusTypeDef  HAL_NAND_Write_SpareArea_16b(NAND_HandleTypeDef *hnand, NAND_AddressTypeDef *pAddress, uint16_t *pBuffer, uint32_t NumSpareAreaTowrite);
NHAL_StatusTypeDef  HAL_NAND_Erase_Block(NAND_HandleTypeDef *hnand, NAND_AddressTypeDef *pAddress);
Nuint32_t           HAL_NAND_Read_Status(NAND_HandleTypeDef *hnand);
Nuint32_t           HAL_NAND_Address_Inc(NAND_HandleTypeDef *hnand, NAND_AddressTypeDef *pAddress);
N
N/**
N  * @}
N  */
N
N/** @addtogroup NAND_Exported_Functions_Group3 Peripheral Control functions 
N  * @{
N  */
N
N/* NAND Control functions  ****************************************************/
NHAL_StatusTypeDef  HAL_NAND_ECC_Enable(NAND_HandleTypeDef *hnand);
NHAL_StatusTypeDef  HAL_NAND_ECC_Disable(NAND_HandleTypeDef *hnand);
NHAL_StatusTypeDef  HAL_NAND_GetECC(NAND_HandleTypeDef *hnand, uint32_t *ECCval, uint32_t Timeout);
N
N/**
N  * @}
N  */
N    
N/** @addtogroup NAND_Exported_Functions_Group4 Peripheral State functions 
N  * @{
N  */
N/* NAND State functions *******************************************************/
NHAL_NAND_StateTypeDef HAL_NAND_GetState(NAND_HandleTypeDef *hnand);
Nuint32_t              HAL_NAND_Read_Status(NAND_HandleTypeDef *hnand);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup NAND_Private_Constants NAND Private Constants
N  * @{
N  */
N#define NAND_DEVICE                ((uint32_t)0x80000000U) 
N#define NAND_WRITE_TIMEOUT         ((uint32_t)0x01000000U)
N
N#define CMD_AREA                   ((uint32_t)(1<<16))  /* A16 = CLE high */
N#define ADDR_AREA                  ((uint32_t)(1<<17))  /* A17 = ALE high */
N
N#define NAND_CMD_AREA_A            ((uint8_t)0x00U)
N#define NAND_CMD_AREA_B            ((uint8_t)0x01U)
N#define NAND_CMD_AREA_C            ((uint8_t)0x50U)
N#define NAND_CMD_AREA_TRUE1        ((uint8_t)0x30U)
N
N#define NAND_CMD_WRITE0            ((uint8_t)0x80U)
N#define NAND_CMD_WRITE_TRUE1       ((uint8_t)0x10U)
N#define NAND_CMD_ERASE0            ((uint8_t)0x60U)
N#define NAND_CMD_ERASE1            ((uint8_t)0xD0U)
N#define NAND_CMD_READID            ((uint8_t)0x90U)
N#define NAND_CMD_STATUS            ((uint8_t)0x70U)
N#define NAND_CMD_LOCK_STATUS       ((uint8_t)0x7AU)
N#define NAND_CMD_RESET             ((uint8_t)0xFFU)
N
N/* NAND memory status */
N#define NAND_VALID_ADDRESS         ((uint32_t)0x00000100U)
N#define NAND_INVALID_ADDRESS       ((uint32_t)0x00000200U)
N#define NAND_TIMEOUT_ERROR         ((uint32_t)0x00000400U)
N#define NAND_BUSY                  ((uint32_t)0x00000000U)
N#define NAND_ERROR                 ((uint32_t)0x00000001U)
N#define NAND_READY                 ((uint32_t)0x00000040U)
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup NAND_Private_Macros NAND Private Macros
N  * @{
N  */
N
N/**
N  * @brief  NAND memory address computation.
N  * @param  __ADDRESS__: NAND memory address.
N  * @param  __HANDLE__ : NAND handle.
N  * @retval NAND Raw address value
N  */
N#define ARRAY_ADDRESS(__ADDRESS__ , __HANDLE__) ((__ADDRESS__)->Page + \
N                         (((__ADDRESS__)->Block + (((__ADDRESS__)->Zone) * ((__HANDLE__)->Info.ZoneSize)))* ((__HANDLE__)->Info.BlockSize)))
X#define ARRAY_ADDRESS(__ADDRESS__ , __HANDLE__) ((__ADDRESS__)->Page +                          (((__ADDRESS__)->Block + (((__ADDRESS__)->Zone) * ((__HANDLE__)->Info.ZoneSize)))* ((__HANDLE__)->Info.BlockSize)))
N
N/**
N  * @brief  NAND memory address cycling.
N  * @param  __ADDRESS__: NAND memory address.
N  * @retval NAND address cycling value.
N  */
N#define ADDR_1ST_CYCLE(__ADDRESS__)       (uint8_t)(__ADDRESS__)              /* 1st addressing cycle */
N#define ADDR_2ND_CYCLE(__ADDRESS__)       (uint8_t)((__ADDRESS__) >> 8)       /* 2nd addressing cycle */
N#define ADDR_3RD_CYCLE(__ADDRESS__)       (uint8_t)((__ADDRESS__) >> 16)      /* 3rd addressing cycle */
N#define ADDR_4TH_CYCLE(__ADDRESS__)       (uint8_t)((__ADDRESS__) >> 24)      /* 4th addressing cycle */
N/**
N  * @}
N  */
N    
N/**
N  * @}
N  */
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_NAND_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 311 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_NAND_MODULE_ENABLED */
N
N#ifdef HAL_SDRAM_MODULE_ENABLED
N  #include "stm32f7xx_hal_sdram.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_sdram.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_sdram.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of SDRAM HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_SDRAM_H
N#define __STM32F7xx_HAL_SDRAM_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_ll_fmc.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup SDRAM
N  * @{
N  */ 
N
N/* Exported typedef ----------------------------------------------------------*/   
N
N/** @defgroup SDRAM_Exported_Types SDRAM Exported Types
N  * @{
N  */
N	 
N/** 
N  * @brief  HAL SDRAM State structure definition  
N  */ 
Ntypedef enum
N{
N  HAL_SDRAM_STATE_RESET             = 0x00U,  /*!< SDRAM not yet initialized or disabled */
N  HAL_SDRAM_STATE_READY             = 0x01U,  /*!< SDRAM initialized and ready for use   */
N  HAL_SDRAM_STATE_BUSY              = 0x02U,  /*!< SDRAM internal process is ongoing     */
N  HAL_SDRAM_STATE_ERROR             = 0x03U,  /*!< SDRAM error state                     */
N  HAL_SDRAM_STATE_WRITE_PROTECTED   = 0x04U,  /*!< SDRAM device write protected          */
N  HAL_SDRAM_STATE_PRECHARGED        = 0x05U   /*!< SDRAM device precharged               */
N  
N}HAL_SDRAM_StateTypeDef;
N
N/** 
N  * @brief  SDRAM handle Structure definition  
N  */ 
Ntypedef struct
N{
N  FMC_SDRAM_TypeDef             *Instance;  /*!< Register base address                 */
X  FMC_Bank5_6_TypeDef             *Instance;   
N  
N  FMC_SDRAM_InitTypeDef         Init;       /*!< SDRAM device configuration parameters */
N  
N  __IO HAL_SDRAM_StateTypeDef   State;      /*!< SDRAM access state                    */
X  volatile HAL_SDRAM_StateTypeDef   State;       
N  
N  HAL_LockTypeDef               Lock;       /*!< SDRAM locking object                  */ 
N
N  DMA_HandleTypeDef             *hdma;      /*!< Pointer DMA handler                   */
N  
N}SDRAM_HandleTypeDef;
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N
N/** @defgroup SDRAM_Exported_Macros SDRAM Exported Macros
N  * @{
N  */
N
N/** @brief Reset SDRAM handle state
N  * @param  __HANDLE__: specifies the SDRAM handle.
N  * @retval None
N  */
N#define __HAL_SDRAM_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_SDRAM_STATE_RESET)
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N
N/** @addtogroup SDRAM_Exported_Functions SDRAM Exported Functions
N  * @{
N  */
N
N/** @addtogroup SDRAM_Exported_Functions_Group1 
N  * @{
N  */
N
N/* Initialization/de-initialization functions *********************************/
NHAL_StatusTypeDef HAL_SDRAM_Init(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_TimingTypeDef *Timing);
NHAL_StatusTypeDef HAL_SDRAM_DeInit(SDRAM_HandleTypeDef *hsdram);
Nvoid HAL_SDRAM_MspInit(SDRAM_HandleTypeDef *hsdram);
Nvoid HAL_SDRAM_MspDeInit(SDRAM_HandleTypeDef *hsdram);
N
Nvoid HAL_SDRAM_IRQHandler(SDRAM_HandleTypeDef *hsdram);
Nvoid HAL_SDRAM_RefreshErrorCallback(SDRAM_HandleTypeDef *hsdram);
Nvoid HAL_SDRAM_DMA_XferCpltCallback(DMA_HandleTypeDef *hdma);
Nvoid HAL_SDRAM_DMA_XferErrorCallback(DMA_HandleTypeDef *hdma);
N
N/**
N  * @}
N  */
N
N/** @addtogroup SDRAM_Exported_Functions_Group2 
N  * @{
N  */
N/* I/O operation functions ****************************************************/
NHAL_StatusTypeDef HAL_SDRAM_Read_8b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint8_t *pDstBuffer, uint32_t BufferSize);
NHAL_StatusTypeDef HAL_SDRAM_Write_8b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint8_t *pSrcBuffer, uint32_t BufferSize);
NHAL_StatusTypeDef HAL_SDRAM_Read_16b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint16_t *pDstBuffer, uint32_t BufferSize);
NHAL_StatusTypeDef HAL_SDRAM_Write_16b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint16_t *pSrcBuffer, uint32_t BufferSize);
NHAL_StatusTypeDef HAL_SDRAM_Read_32b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pDstBuffer, uint32_t BufferSize);
NHAL_StatusTypeDef HAL_SDRAM_Write_32b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pSrcBuffer, uint32_t BufferSize);
N
NHAL_StatusTypeDef HAL_SDRAM_Read_DMA(SDRAM_HandleTypeDef *hsdram, uint32_t * pAddress, uint32_t *pDstBuffer, uint32_t BufferSize);
NHAL_StatusTypeDef HAL_SDRAM_Write_DMA(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pSrcBuffer, uint32_t BufferSize);
N
N/**
N  * @}
N  */
N  
N/** @addtogroup SDRAM_Exported_Functions_Group3 
N  * @{
N  */
N/* SDRAM Control functions  *****************************************************/
NHAL_StatusTypeDef HAL_SDRAM_WriteProtection_Enable(SDRAM_HandleTypeDef *hsdram);
NHAL_StatusTypeDef HAL_SDRAM_WriteProtection_Disable(SDRAM_HandleTypeDef *hsdram);
NHAL_StatusTypeDef HAL_SDRAM_SendCommand(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout);
NHAL_StatusTypeDef HAL_SDRAM_ProgramRefreshRate(SDRAM_HandleTypeDef *hsdram, uint32_t RefreshRate);
NHAL_StatusTypeDef HAL_SDRAM_SetAutoRefreshNumber(SDRAM_HandleTypeDef *hsdram, uint32_t AutoRefreshNumber);
Nuint32_t          HAL_SDRAM_GetModeStatus(SDRAM_HandleTypeDef *hsdram);
N
N/**
N  * @}
N  */
N
N/** @addtogroup SDRAM_Exported_Functions_Group4 
N  * @{
N  */
N/* SDRAM State functions ********************************************************/
NHAL_SDRAM_StateTypeDef  HAL_SDRAM_GetState(SDRAM_HandleTypeDef *hsdram);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_SDRAM_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 315 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_SDRAM_MODULE_ENABLED */      
N
N#ifdef HAL_HASH_MODULE_ENABLED
S #include "stm32f7xx_hal_hash.h"
N#endif /* HAL_HASH_MODULE_ENABLED */
N
N#ifdef HAL_I2C_MODULE_ENABLED
N #include "stm32f7xx_hal_i2c.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_i2c.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_i2c.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of I2C HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_I2C_H
N#define __STM32F7xx_HAL_I2C_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"  
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup I2C
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup I2C_Exported_Types I2C Exported Types
N  * @{
N  */
N
N/** @defgroup I2C_Configuration_Structure_definition I2C Configuration Structure definition
N  * @brief  I2C Configuration Structure definition  
N  * @{
N  */
Ntypedef struct
N{
N  uint32_t Timing;              /*!< Specifies the I2C_TIMINGR_register value.
N                                  This parameter calculated by referring to I2C initialization 
N                                         section in Reference manual */
N
N  uint32_t OwnAddress1;         /*!< Specifies the first device own address.
N                                  This parameter can be a 7-bit or 10-bit address. */
N
N  uint32_t AddressingMode;      /*!< Specifies if 7-bit or 10-bit addressing mode is selected.
N                                  This parameter can be a value of @ref I2C_ADDRESSING_MODE */
N
N  uint32_t DualAddressMode;     /*!< Specifies if dual addressing mode is selected.
N                                  This parameter can be a value of @ref I2C_DUAL_ADDRESSING_MODE */
N
N  uint32_t OwnAddress2;         /*!< Specifies the second device own address if dual addressing mode is selected
N                                  This parameter can be a 7-bit address. */
N
N  uint32_t OwnAddress2Masks;    /*!< Specifies the acknowledge mask address second device own address if dual addressing mode is selected
N                                  This parameter can be a value of @ref I2C_OWN_ADDRESS2_MASKS */
N
N  uint32_t GeneralCallMode;     /*!< Specifies if general call mode is selected.
N                                  This parameter can be a value of @ref I2C_GENERAL_CALL_ADDRESSING_MODE */
N
N  uint32_t NoStretchMode;       /*!< Specifies if nostretch mode is selected.
N                                  This parameter can be a value of @ref I2C_NOSTRETCH_MODE */
N
N}I2C_InitTypeDef;
N
N/** 
N  * @}
N  */
N
N/** @defgroup HAL_state_structure_definition HAL state structure definition
N  * @brief  HAL State structure definition
N  * @note  HAL I2C State value coding follow below described bitmap :
N  *          b7-b6  Error information 
N  *             00 : No Error
N  *             01 : Abort (Abort user request on going)
N  *             10 : Timeout
N  *             11 : Error
N  *          b5     IP initilisation status
N  *             0  : Reset (IP not initialized)
N  *             1  : Init done (IP initialized and ready to use. HAL I2C Init function called)
N  *          b4     (not used)
N  *             x  : Should be set to 0
N  *          b3
N  *             0  : Ready or Busy (No Listen mode ongoing)
N  *             1  : Listen (IP in Address Listen Mode)
N  *          b2     Intrinsic process state
N  *             0  : Ready
N  *             1  : Busy (IP busy with some configuration or internal operations)
N  *          b1     Rx state
N  *             0  : Ready (no Rx operation ongoing)
N  *             1  : Busy (Rx operation ongoing)
N  *          b0     Tx state
N  *             0  : Ready (no Tx operation ongoing)
N  *             1  : Busy (Tx operation ongoing)
N  * @{
N  */ 
N
Ntypedef enum
N{
N  HAL_I2C_STATE_RESET             = 0x00U,   /*!< Peripheral is not yet Initialized         */
N  HAL_I2C_STATE_READY             = 0x20U,   /*!< Peripheral Initialized and ready for use  */
N  HAL_I2C_STATE_BUSY              = 0x24U,   /*!< An internal process is ongoing            */
N  HAL_I2C_STATE_BUSY_TX           = 0x21U,   /*!< Data Transmission process is ongoing      */ 
N  HAL_I2C_STATE_BUSY_RX           = 0x22U,   /*!< Data Reception process is ongoing         */
N  HAL_I2C_STATE_LISTEN            = 0x28U,   /*!< Address Listen Mode is ongoing            */
N  HAL_I2C_STATE_BUSY_TX_LISTEN    = 0x29U,   /*!< Address Listen Mode and Data Transmission
N                                                 process is ongoing                        */
N  HAL_I2C_STATE_BUSY_RX_LISTEN    = 0x2AU,   /*!< Address Listen Mode and Data Reception
N                                                 process is ongoing                        */
N  HAL_I2C_STATE_ABORT             = 0x60,    /*!< Abort user request ongoing                */
N  HAL_I2C_STATE_TIMEOUT           = 0xA0U,   /*!< Timeout state                             */
N  HAL_I2C_STATE_ERROR             = 0xE0U    /*!< Error                                     */ 
N
N}HAL_I2C_StateTypeDef;
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_mode_structure_definition HAL mode structure definition
N  * @brief  HAL Mode structure definition
N  * @note  HAL I2C Mode value coding follow below described bitmap :
N  *          b7     (not used)
N  *             x  : Should be set to 0
N  *          b6
N  *             0  : None
N  *             1  : Memory (HAL I2C communication is in Memory Mode)
N  *          b5
N  *             0  : None
N  *             1  : Slave (HAL I2C communication is in Slave Mode)
N  *          b4
N  *             0  : None
N  *             1  : Master (HAL I2C communication is in Master Mode)
N  *          b3-b2-b1-b0  (not used)
N  *             xxxx : Should be set to 0000
N  * @{
N  */
Ntypedef enum
N{
N  HAL_I2C_MODE_NONE               = 0x00U,   /*!< No I2C communication on going             */
N  HAL_I2C_MODE_MASTER             = 0x10U,   /*!< I2C communication is in Master Mode       */
N  HAL_I2C_MODE_SLAVE              = 0x20U,   /*!< I2C communication is in Slave Mode        */
N  HAL_I2C_MODE_MEM                = 0x40U    /*!< I2C communication is in Memory Mode       */
N
N}HAL_I2C_ModeTypeDef;
N
N/** 
N  * @}
N  */
N
N/** @defgroup I2C_Error_Code_definition I2C Error Code definition
N  * @brief  I2C Error Code definition  
N  * @{
N  */
N#define HAL_I2C_ERROR_NONE      ((uint32_t)0x00000000U)    /*!< No error              */
N#define HAL_I2C_ERROR_BERR      ((uint32_t)0x00000001U)    /*!< BERR error            */
N#define HAL_I2C_ERROR_ARLO      ((uint32_t)0x00000002U)    /*!< ARLO error            */
N#define HAL_I2C_ERROR_AF        ((uint32_t)0x00000004U)    /*!< ACKF error            */
N#define HAL_I2C_ERROR_OVR       ((uint32_t)0x00000008U)    /*!< OVR error             */
N#define HAL_I2C_ERROR_DMA       ((uint32_t)0x00000010U)    /*!< DMA transfer error    */
N#define HAL_I2C_ERROR_TIMEOUT   ((uint32_t)0x00000020U)    /*!< Timeout error         */
N#define HAL_I2C_ERROR_SIZE      ((uint32_t)0x00000040U)    /*!< Size Management error */
N#define HAL_I2C_ERROR_ABORT     ((uint32_t)0x00000080U)    /*!< Abort user request    */
N/**
N  * @}
N  */
N
N/** @defgroup I2C_handle_Structure_definition I2C handle Structure definition
N  * @brief  I2C handle Structure definition  
N  * @{
N  */
Ntypedef struct __I2C_HandleTypeDef
N{
N  I2C_TypeDef                *Instance;      /*!< I2C registers base address                */
N
N  I2C_InitTypeDef            Init;           /*!< I2C communication parameters              */
N
N  uint8_t                    *pBuffPtr;      /*!< Pointer to I2C transfer buffer            */
N
N  uint16_t                   XferSize;       /*!< I2C transfer size                         */
N
N  __IO uint16_t              XferCount;      /*!< I2C transfer counter                      */
X  volatile uint16_t              XferCount;       
N
N  __IO uint32_t              XferOptions;    /*!< I2C sequantial transfer options, this parameter can
X  volatile uint32_t              XferOptions;    
N                                                  be a value of @ref I2C_XFEROPTIONS */
N
N  __IO uint32_t              PreviousState;  /*!< I2C communication Previous state          */
X  volatile uint32_t              PreviousState;   
N
N  HAL_StatusTypeDef (*XferISR)(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources); /*!< I2C transfer IRQ handler function pointer */
N
N  DMA_HandleTypeDef          *hdmatx;        /*!< I2C Tx DMA handle parameters              */
N
N  DMA_HandleTypeDef          *hdmarx;        /*!< I2C Rx DMA handle parameters              */
N
N  HAL_LockTypeDef            Lock;           /*!< I2C locking object                        */
N
N  __IO HAL_I2C_StateTypeDef  State;          /*!< I2C communication state                   */
X  volatile HAL_I2C_StateTypeDef  State;           
N
N  __IO HAL_I2C_ModeTypeDef   Mode;           /*!< I2C communication mode                    */
X  volatile HAL_I2C_ModeTypeDef   Mode;            
N
N  __IO uint32_t              ErrorCode;      /*!< I2C Error code                            */
X  volatile uint32_t              ErrorCode;       
N
N  __IO uint32_t              AddrEventCount; /*!< I2C Address Event counter                 */
X  volatile uint32_t              AddrEventCount;  
N}I2C_HandleTypeDef;
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */  
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup I2C_Exported_Constants I2C Exported Constants
N  * @{
N  */
N
N/** @defgroup I2C_XFEROPTIONS  I2C Sequential Transfer Options
N  * @{
N  */
N#define I2C_NO_OPTION_FRAME             ((uint32_t)0xFFFF0000U)
N#define I2C_FIRST_FRAME                 ((uint32_t)I2C_SOFTEND_MODE)
N#define I2C_NEXT_FRAME                  ((uint32_t)(I2C_RELOAD_MODE | I2C_SOFTEND_MODE))
N#define I2C_FIRST_AND_LAST_FRAME        ((uint32_t)I2C_AUTOEND_MODE)
N#define I2C_LAST_FRAME                  ((uint32_t)I2C_AUTOEND_MODE)
N/**
N  * @}
N  */
N
N/** @defgroup I2C_ADDRESSING_MODE I2C Addressing Mode
N  * @{
N  */
N#define I2C_ADDRESSINGMODE_7BIT         ((uint32_t)0x00000001U)
N#define I2C_ADDRESSINGMODE_10BIT        ((uint32_t)0x00000002U)
N/**
N  * @}
N  */
N
N/** @defgroup I2C_DUAL_ADDRESSING_MODE I2C Dual Addressing Mode
N  * @{
N  */
N#define I2C_DUALADDRESS_DISABLE         ((uint32_t)0x00000000U)
N#define I2C_DUALADDRESS_ENABLE          I2C_OAR2_OA2EN
N/**
N  * @}
N  */
N
N/** @defgroup I2C_OWN_ADDRESS2_MASKS I2C Own Address2 Masks
N  * @{
N  */
N#define I2C_OA2_NOMASK                  ((uint8_t)0x00U)
N#define I2C_OA2_MASK01                  ((uint8_t)0x01U)
N#define I2C_OA2_MASK02                  ((uint8_t)0x02U)
N#define I2C_OA2_MASK03                  ((uint8_t)0x03U)
N#define I2C_OA2_MASK04                  ((uint8_t)0x04U)
N#define I2C_OA2_MASK05                  ((uint8_t)0x05U)
N#define I2C_OA2_MASK06                  ((uint8_t)0x06U)
N#define I2C_OA2_MASK07                  ((uint8_t)0x07U)
N/**
N  * @}
N  */
N
N/** @defgroup I2C_GENERAL_CALL_ADDRESSING_MODE I2C General Call Addressing Mode
N  * @{
N  */
N#define I2C_GENERALCALL_DISABLE         ((uint32_t)0x00000000U)
N#define I2C_GENERALCALL_ENABLE          I2C_CR1_GCEN
N/**
N  * @}
N  */
N
N/** @defgroup I2C_NOSTRETCH_MODE I2C No-Stretch Mode
N  * @{
N  */
N#define I2C_NOSTRETCH_DISABLE           ((uint32_t)0x00000000U)
N#define I2C_NOSTRETCH_ENABLE            I2C_CR1_NOSTRETCH
N/**
N  * @}
N  */
N
N/** @defgroup I2C_MEMORY_ADDRESS_SIZE I2C Memory Address Size
N  * @{
N  */
N#define I2C_MEMADD_SIZE_8BIT            ((uint32_t)0x00000001U)
N#define I2C_MEMADD_SIZE_16BIT           ((uint32_t)0x00000002U)
N/**
N  * @}
N  */
N  
N/** @defgroup I2C_XferDirection I2C Transfer Direction
N  * @{
N  */
N#define I2C_DIRECTION_TRANSMIT          ((uint32_t)0x00000000U)
N#define I2C_DIRECTION_RECEIVE           ((uint32_t)0x00000001U)
N/**
N  * @}
N  */
N
N/** @defgroup I2C_RELOAD_END_MODE I2C Reload End Mode
N  * @{
N  */
N#define  I2C_RELOAD_MODE                I2C_CR2_RELOAD
N#define  I2C_AUTOEND_MODE               I2C_CR2_AUTOEND
N#define  I2C_SOFTEND_MODE               ((uint32_t)0x00000000U)
N/**
N  * @}
N  */
N
N/** @defgroup I2C_START_STOP_MODE I2C Start or Stop Mode
N  * @{
N  */
N#define  I2C_NO_STARTSTOP               ((uint32_t)0x00000000U)
N#define  I2C_GENERATE_STOP              I2C_CR2_STOP
N#define  I2C_GENERATE_START_READ        (uint32_t)(I2C_CR2_START | I2C_CR2_RD_WRN)
N#define  I2C_GENERATE_START_WRITE       I2C_CR2_START
N/**
N  * @}
N  */
N
N/** @defgroup I2C_Interrupt_configuration_definition I2C Interrupt configuration definition
N  * @brief I2C Interrupt definition
N  *        Elements values convention: 0xXXXXXXXX
N  *           - XXXXXXXX  : Interrupt control mask
N  * @{
N  */
N#define I2C_IT_ERRI                     I2C_CR1_ERRIE
N#define I2C_IT_TCI                      I2C_CR1_TCIE
N#define I2C_IT_STOPI                    I2C_CR1_STOPIE
N#define I2C_IT_NACKI                    I2C_CR1_NACKIE
N#define I2C_IT_ADDRI                    I2C_CR1_ADDRIE
N#define I2C_IT_RXI                      I2C_CR1_RXIE
N#define I2C_IT_TXI                      I2C_CR1_TXIE
N/**
N  * @}
N  */
N
N/** @defgroup I2C_Flag_definition I2C Flag definition
N  * @{
N  */ 
N#define I2C_FLAG_TXE                    I2C_ISR_TXE
N#define I2C_FLAG_TXIS                   I2C_ISR_TXIS
N#define I2C_FLAG_RXNE                   I2C_ISR_RXNE
N#define I2C_FLAG_ADDR                   I2C_ISR_ADDR
N#define I2C_FLAG_AF                     I2C_ISR_NACKF
N#define I2C_FLAG_STOPF                  I2C_ISR_STOPF
N#define I2C_FLAG_TC                     I2C_ISR_TC
N#define I2C_FLAG_TCR                    I2C_ISR_TCR
N#define I2C_FLAG_BERR                   I2C_ISR_BERR
N#define I2C_FLAG_ARLO                   I2C_ISR_ARLO
N#define I2C_FLAG_OVR                    I2C_ISR_OVR
N#define I2C_FLAG_PECERR                 I2C_ISR_PECERR
N#define I2C_FLAG_TIMEOUT                I2C_ISR_TIMEOUT
N#define I2C_FLAG_ALERT                  I2C_ISR_ALERT
N#define I2C_FLAG_BUSY                   I2C_ISR_BUSY
N#define I2C_FLAG_DIR                    I2C_ISR_DIR
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macros -----------------------------------------------------------*/
N  
N/** @defgroup I2C_Exported_Macros I2C Exported Macros
N  * @{
N  */
N
N/** @brief Reset I2C handle state.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  * @retval None
N  */
N#define __HAL_I2C_RESET_HANDLE_STATE(__HANDLE__)                ((__HANDLE__)->State = HAL_I2C_STATE_RESET)
N
N/** @brief  Enable the specified I2C interrupt.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  * @param  __INTERRUPT__ specifies the interrupt source to enable.
N  *        This parameter can be one of the following values:
N  *            @arg @ref I2C_IT_ERRI  Errors interrupt enable
N  *            @arg @ref I2C_IT_TCI   Transfer complete interrupt enable
N  *            @arg @ref I2C_IT_STOPI STOP detection interrupt enable
N  *            @arg @ref I2C_IT_NACKI NACK received interrupt enable
N  *            @arg @ref I2C_IT_ADDRI Address match interrupt enable
N  *            @arg @ref I2C_IT_RXI   RX interrupt enable
N  *            @arg @ref I2C_IT_TXI   TX interrupt enable
N  *
N  * @retval None
N  */
N#define __HAL_I2C_ENABLE_IT(__HANDLE__, __INTERRUPT__)          ((__HANDLE__)->Instance->CR1 |= (__INTERRUPT__))
N
N/** @brief  Disable the specified I2C interrupt.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  * @param  __INTERRUPT__ specifies the interrupt source to disable.
N  *        This parameter can be one of the following values:
N  *            @arg @ref I2C_IT_ERRI  Errors interrupt enable
N  *            @arg @ref I2C_IT_TCI   Transfer complete interrupt enable
N  *            @arg @ref I2C_IT_STOPI STOP detection interrupt enable
N  *            @arg @ref I2C_IT_NACKI NACK received interrupt enable
N  *            @arg @ref I2C_IT_ADDRI Address match interrupt enable
N  *            @arg @ref I2C_IT_RXI   RX interrupt enable
N  *            @arg @ref I2C_IT_TXI   TX interrupt enable
N  *   
N  * @retval None
N  */
N#define __HAL_I2C_DISABLE_IT(__HANDLE__, __INTERRUPT__)         ((__HANDLE__)->Instance->CR1 &= (~(__INTERRUPT__)))
N 
N/** @brief  Check whether the specified I2C interrupt source is enabled or not.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  * @param  __INTERRUPT__ specifies the I2C interrupt source to check.
N  *          This parameter can be one of the following values:
N  *            @arg @ref I2C_IT_ERRI  Errors interrupt enable
N  *            @arg @ref I2C_IT_TCI   Transfer complete interrupt enable
N  *            @arg @ref I2C_IT_STOPI STOP detection interrupt enable
N  *            @arg @ref I2C_IT_NACKI NACK received interrupt enable
N  *            @arg @ref I2C_IT_ADDRI Address match interrupt enable
N  *            @arg @ref I2C_IT_RXI   RX interrupt enable
N  *            @arg @ref I2C_IT_TXI   TX interrupt enable
N  *
N  * @retval The new state of __INTERRUPT__ (SET or RESET).
N  */
N#define __HAL_I2C_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)      ((((__HANDLE__)->Instance->CR1 & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)
N
N/** @brief  Check whether the specified I2C flag is set or not.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  * @param  __FLAG__ specifies the flag to check.
N  *        This parameter can be one of the following values:
N  *            @arg @ref I2C_FLAG_TXE     Transmit data register empty
N  *            @arg @ref I2C_FLAG_TXIS    Transmit interrupt status
N  *            @arg @ref I2C_FLAG_RXNE    Receive data register not empty
N  *            @arg @ref I2C_FLAG_ADDR    Address matched (slave mode)
N  *            @arg @ref I2C_FLAG_AF      Acknowledge failure received flag
N  *            @arg @ref I2C_FLAG_STOPF   STOP detection flag
N  *            @arg @ref I2C_FLAG_TC      Transfer complete (master mode)
N  *            @arg @ref I2C_FLAG_TCR     Transfer complete reload
N  *            @arg @ref I2C_FLAG_BERR    Bus error
N  *            @arg @ref I2C_FLAG_ARLO    Arbitration lost
N  *            @arg @ref I2C_FLAG_OVR     Overrun/Underrun
N  *            @arg @ref I2C_FLAG_PECERR  PEC error in reception
N  *            @arg @ref I2C_FLAG_TIMEOUT Timeout or Tlow detection flag
N  *            @arg @ref I2C_FLAG_ALERT   SMBus alert
N  *            @arg @ref I2C_FLAG_BUSY    Bus busy
N  *            @arg @ref I2C_FLAG_DIR     Transfer direction (slave mode)
N  *
N  * @retval The new state of __FLAG__ (SET or RESET).
N  */
N#define __HAL_I2C_GET_FLAG(__HANDLE__, __FLAG__) (((((__HANDLE__)->Instance->ISR) & (__FLAG__)) == (__FLAG__)) ? SET : RESET)
N
N/** @brief  Clear the I2C pending flags which are cleared by writing 1 in a specific bit.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  * @param  __FLAG__ specifies the flag to clear.
N  *          This parameter can be any combination of the following values:
N  *            @arg @ref I2C_FLAG_TXE     Transmit data register empty
N  *            @arg @ref I2C_FLAG_ADDR    Address matched (slave mode)
N  *            @arg @ref I2C_FLAG_AF      Acknowledge failure received flag
N  *            @arg @ref I2C_FLAG_STOPF   STOP detection flag
N  *            @arg @ref I2C_FLAG_BERR    Bus error
N  *            @arg @ref I2C_FLAG_ARLO    Arbitration lost
N  *            @arg @ref I2C_FLAG_OVR     Overrun/Underrun            
N  *            @arg @ref I2C_FLAG_PECERR  PEC error in reception
N  *            @arg @ref I2C_FLAG_TIMEOUT Timeout or Tlow detection flag 
N  *            @arg @ref I2C_FLAG_ALERT   SMBus alert
N  *
N  * @retval None
N  */
N#define __HAL_I2C_CLEAR_FLAG(__HANDLE__, __FLAG__) (((__FLAG__) == I2C_FLAG_TXE) ? ((__HANDLE__)->Instance->ISR |= (__FLAG__)) \
N                                                                                 : ((__HANDLE__)->Instance->ICR = (__FLAG__)))
X#define __HAL_I2C_CLEAR_FLAG(__HANDLE__, __FLAG__) (((__FLAG__) == I2C_FLAG_TXE) ? ((__HANDLE__)->Instance->ISR |= (__FLAG__))                                                                                  : ((__HANDLE__)->Instance->ICR = (__FLAG__)))
N 
N/** @brief  Enable the specified I2C peripheral.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  * @retval None
N  */
N#define __HAL_I2C_ENABLE(__HANDLE__)                            (SET_BIT((__HANDLE__)->Instance->CR1,  I2C_CR1_PE))
N
N/** @brief  Disable the specified I2C peripheral.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  * @retval None
N  */
N#define __HAL_I2C_DISABLE(__HANDLE__)                           (CLEAR_BIT((__HANDLE__)->Instance->CR1, I2C_CR1_PE))
N
N/** @brief  Generate a Non-Acknowledge I2C peripheral in Slave mode.
N  * @param  __HANDLE__: specifies the I2C Handle. 
N  * @retval None
N  */
N#define __HAL_I2C_GENERATE_NACK(__HANDLE__)                     (SET_BIT((__HANDLE__)->Instance->CR2, I2C_CR2_NACK))
N/**
N  * @}
N  */
N
N/* Include I2C HAL Extended module */
N#include "stm32f7xx_hal_i2c_ex.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_i2c_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_i2c_ex.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of I2C HAL Extension module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_I2C_EX_H
N#define __STM32F7xx_HAL_I2C_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup I2CEx
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup I2CEx_Exported_Constants I2CEx Exported Constants
N  * @{
N  */
N
N/** @defgroup I2CEx_Analog_Filter I2CEx Analog Filter
N  * @{
N  */
N#define I2C_ANALOGFILTER_ENABLE        ((uint32_t)0x00000000U)
N#define I2C_ANALOGFILTER_DISABLE       I2C_CR1_ANFOFF
N/**
N  * @}
N  */
N
N/** @defgroup I2CEx_FastModePlus I2C Extended Fast Mode Plus
N  * @{
N  */
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N
N#define I2C_FASTMODEPLUS_PB6          SYSCFG_PMC_I2C_PB6_FMP
N#define I2C_FASTMODEPLUS_PB7          SYSCFG_PMC_I2C_PB7_FMP
N#define I2C_FASTMODEPLUS_PB8          SYSCFG_PMC_I2C_PB8_FMP
N#define I2C_FASTMODEPLUS_PB9          SYSCFG_PMC_I2C_PB9_FMP
N
N#define I2C_FASTMODEPLUS_I2C1         SYSCFG_PMC_I2C1_FMP
N#define I2C_FASTMODEPLUS_I2C2         SYSCFG_PMC_I2C2_FMP
N#define I2C_FASTMODEPLUS_I2C3         SYSCFG_PMC_I2C3_FMP
N#define I2C_FASTMODEPLUS_I2C4         SYSCFG_PMC_I2C4_FMP
N
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx  */
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */ 
N  
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/
N
N/* Peripheral Control methods  ************************************************/
NHAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter);
NHAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter);
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
Nvoid HAL_I2CEx_EnableFastModePlus(uint32_t ConfigFastModePlus);
Nvoid HAL_I2CEx_DisableFastModePlus(uint32_t ConfigFastModePlus);
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup I2C_Private_Constants I2C Private Constants
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup I2C_Private_Macro I2C Private Macros
N  * @{
N  */
N#define IS_I2C_ANALOG_FILTER(FILTER)    (((FILTER) == I2C_ANALOGFILTER_ENABLE) || \
N                                          ((FILTER) == I2C_ANALOGFILTER_DISABLE))
X#define IS_I2C_ANALOG_FILTER(FILTER)    (((FILTER) == I2C_ANALOGFILTER_ENABLE) ||                                           ((FILTER) == I2C_ANALOGFILTER_DISABLE))
N
N#define IS_I2C_DIGITAL_FILTER(FILTER)   ((FILTER) <= 0x0000000FU)
N
N#if defined(SYSCFG_PMC_I2C1_FMP) && defined(SYSCFG_PMC_I2C2_FMP) && defined(SYSCFG_PMC_I2C3_FMP) && defined(SYSCFG_PMC_I2C4_FMP) 
X#if 1L && 1L && 1L && 1L 
N#define IS_I2C_FASTMODEPLUS(__CONFIG__) ((((__CONFIG__) & I2C_FASTMODEPLUS_PB6)  == I2C_FASTMODEPLUS_PB6)  || \
N                                         (((__CONFIG__) & I2C_FASTMODEPLUS_PB7)  == I2C_FASTMODEPLUS_PB7)  || \
N                                         (((__CONFIG__) & I2C_FASTMODEPLUS_PB8)  == I2C_FASTMODEPLUS_PB8)  || \
N                                         (((__CONFIG__) & I2C_FASTMODEPLUS_PB9)  == I2C_FASTMODEPLUS_PB9)  || \
N                                         (((__CONFIG__) & I2C_FASTMODEPLUS_I2C1) == I2C_FASTMODEPLUS_I2C1) || \
N                                         (((__CONFIG__) & I2C_FASTMODEPLUS_I2C2) == I2C_FASTMODEPLUS_I2C2) || \
N										 (((__CONFIG__) & I2C_FASTMODEPLUS_I2C3) == I2C_FASTMODEPLUS_I2C3) || \
N                                         (((__CONFIG__) & I2C_FASTMODEPLUS_I2C4) == I2C_FASTMODEPLUS_I2C4))
X#define IS_I2C_FASTMODEPLUS(__CONFIG__) ((((__CONFIG__) & I2C_FASTMODEPLUS_PB6)  == I2C_FASTMODEPLUS_PB6)  ||                                          (((__CONFIG__) & I2C_FASTMODEPLUS_PB7)  == I2C_FASTMODEPLUS_PB7)  ||                                          (((__CONFIG__) & I2C_FASTMODEPLUS_PB8)  == I2C_FASTMODEPLUS_PB8)  ||                                          (((__CONFIG__) & I2C_FASTMODEPLUS_PB9)  == I2C_FASTMODEPLUS_PB9)  ||                                          (((__CONFIG__) & I2C_FASTMODEPLUS_I2C1) == I2C_FASTMODEPLUS_I2C1) ||                                          (((__CONFIG__) & I2C_FASTMODEPLUS_I2C2) == I2C_FASTMODEPLUS_I2C2) || 										 (((__CONFIG__) & I2C_FASTMODEPLUS_I2C3) == I2C_FASTMODEPLUS_I2C3) ||                                          (((__CONFIG__) & I2C_FASTMODEPLUS_I2C4) == I2C_FASTMODEPLUS_I2C4))
N#elif defined(SYSCFG_PMC_I2C1_FMP) && defined(SYSCFG_PMC_I2C2_FMP) && defined(SYSCFG_PMC_I2C3_FMP)
S#define IS_I2C_FASTMODEPLUS(__CONFIG__) ((((__CONFIG__) & I2C_FASTMODEPLUS_PB6)  == I2C_FASTMODEPLUS_PB6)  || \
S                                         (((__CONFIG__) & I2C_FASTMODEPLUS_PB7)  == I2C_FASTMODEPLUS_PB7)  || \
S                                         (((__CONFIG__) & I2C_FASTMODEPLUS_PB8)  == I2C_FASTMODEPLUS_PB8)  || \
S                                         (((__CONFIG__) & I2C_FASTMODEPLUS_PB9)  == I2C_FASTMODEPLUS_PB9)  || \
S                                         (((__CONFIG__) & I2C_FASTMODEPLUS_I2C1) == I2C_FASTMODEPLUS_I2C1) || \
S										 (((__CONFIG__) & I2C_FASTMODEPLUS_I2C2) == I2C_FASTMODEPLUS_I2C2) || \
S                                         (((__CONFIG__) & I2C_FASTMODEPLUS_I2C3) == I2C_FASTMODEPLUS_I2C3))
X#define IS_I2C_FASTMODEPLUS(__CONFIG__) ((((__CONFIG__) & I2C_FASTMODEPLUS_PB6)  == I2C_FASTMODEPLUS_PB6)  ||                                          (((__CONFIG__) & I2C_FASTMODEPLUS_PB7)  == I2C_FASTMODEPLUS_PB7)  ||                                          (((__CONFIG__) & I2C_FASTMODEPLUS_PB8)  == I2C_FASTMODEPLUS_PB8)  ||                                          (((__CONFIG__) & I2C_FASTMODEPLUS_PB9)  == I2C_FASTMODEPLUS_PB9)  ||                                          (((__CONFIG__) & I2C_FASTMODEPLUS_I2C1) == I2C_FASTMODEPLUS_I2C1) || 										 (((__CONFIG__) & I2C_FASTMODEPLUS_I2C2) == I2C_FASTMODEPLUS_I2C2) ||                                          (((__CONFIG__) & I2C_FASTMODEPLUS_I2C3) == I2C_FASTMODEPLUS_I2C3))
S#elif defined(SYSCFG_PMC_I2C1_FMP) && defined(SYSCFG_PMC_I2C2_FMP)
S#define IS_I2C_FASTMODEPLUS(__CONFIG__) ((((__CONFIG__) & I2C_FASTMODEPLUS_PB6)  == I2C_FASTMODEPLUS_PB6)  || \
S                                         (((__CONFIG__) & I2C_FASTMODEPLUS_PB7)  == I2C_FASTMODEPLUS_PB7)  || \
S                                         (((__CONFIG__) & I2C_FASTMODEPLUS_PB8)  == I2C_FASTMODEPLUS_PB8)  || \
S                                         (((__CONFIG__) & I2C_FASTMODEPLUS_PB9)  == I2C_FASTMODEPLUS_PB9)  || \
S                                         (((__CONFIG__) & I2C_FASTMODEPLUS_I2C1) == I2C_FASTMODEPLUS_I2C1) || \
S                                         (((__CONFIG__) & I2C_FASTMODEPLUS_I2C2) == I2C_FASTMODEPLUS_I2C2))
X#define IS_I2C_FASTMODEPLUS(__CONFIG__) ((((__CONFIG__) & I2C_FASTMODEPLUS_PB6)  == I2C_FASTMODEPLUS_PB6)  ||                                          (((__CONFIG__) & I2C_FASTMODEPLUS_PB7)  == I2C_FASTMODEPLUS_PB7)  ||                                          (((__CONFIG__) & I2C_FASTMODEPLUS_PB8)  == I2C_FASTMODEPLUS_PB8)  ||                                          (((__CONFIG__) & I2C_FASTMODEPLUS_PB9)  == I2C_FASTMODEPLUS_PB9)  ||                                          (((__CONFIG__) & I2C_FASTMODEPLUS_I2C1) == I2C_FASTMODEPLUS_I2C1) ||                                          (((__CONFIG__) & I2C_FASTMODEPLUS_I2C2) == I2C_FASTMODEPLUS_I2C2))
S#elif defined(SYSCFG_PMC_I2C1_FMP)
S#define IS_I2C_FASTMODEPLUS(__CONFIG__) ((((__CONFIG__) & I2C_FASTMODEPLUS_PB6)  == I2C_FASTMODEPLUS_PB6)  || \
S                                         (((__CONFIG__) & I2C_FASTMODEPLUS_PB7)  == I2C_FASTMODEPLUS_PB7)  || \
S                                         (((__CONFIG__) & I2C_FASTMODEPLUS_PB8)  == I2C_FASTMODEPLUS_PB8)  || \
S                                         (((__CONFIG__) & I2C_FASTMODEPLUS_PB9)  == I2C_FASTMODEPLUS_PB9)  || \
S                                         (((__CONFIG__) & I2C_FASTMODEPLUS_I2C1) == I2C_FASTMODEPLUS_I2C1))
X#define IS_I2C_FASTMODEPLUS(__CONFIG__) ((((__CONFIG__) & I2C_FASTMODEPLUS_PB6)  == I2C_FASTMODEPLUS_PB6)  ||                                          (((__CONFIG__) & I2C_FASTMODEPLUS_PB7)  == I2C_FASTMODEPLUS_PB7)  ||                                          (((__CONFIG__) & I2C_FASTMODEPLUS_PB8)  == I2C_FASTMODEPLUS_PB8)  ||                                          (((__CONFIG__) & I2C_FASTMODEPLUS_PB9)  == I2C_FASTMODEPLUS_PB9)  ||                                          (((__CONFIG__) & I2C_FASTMODEPLUS_I2C1) == I2C_FASTMODEPLUS_I2C1))
N#endif /* SYSCFG_PMC_I2C1_FMP && SYSCFG_PMC_I2C2_FMP && SYSCFG_PMC_I2C3_FMP && SYSCFG_PMC_I2C4_FMP */
N/**
N  * @}
N  */
N/**
N  * @}
N  */
N
N/* Private Functions ---------------------------------------------------------*/
N/** @defgroup I2C_Private_Functions I2C Private Functions
N  * @{
N  */
N/* Private functions are defined in stm32f7xx_hal_i2c_ex.c file */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_I2C_EX_H */
N
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 521 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_i2c.h" 2
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup I2C_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup I2C_Exported_Functions_Group1 Initialization and de-initialization functions
N  * @{
N  */
N/* Initialization and de-initialization functions******************************/
NHAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c);
NHAL_StatusTypeDef HAL_I2C_DeInit (I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c);
N/**
N  * @}
N  */
N
N/** @addtogroup I2C_Exported_Functions_Group2 Input and Output operation functions
N  * @{
N  */
N/* IO operation functions  ****************************************************/
N /******* Blocking mode: Polling */
NHAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_I2C_Slave_Transmit(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_I2C_Slave_Receive(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_I2C_IsDeviceReady(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Trials, uint32_t Timeout);
N
N /******* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Mem_Write_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Mem_Read_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size);
N
NHAL_StatusTypeDef HAL_I2C_Master_Sequential_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions);
NHAL_StatusTypeDef HAL_I2C_Master_Sequential_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions);
NHAL_StatusTypeDef HAL_I2C_Slave_Sequential_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions);
NHAL_StatusTypeDef HAL_I2C_Slave_Sequential_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions);
NHAL_StatusTypeDef HAL_I2C_EnableListen_IT(I2C_HandleTypeDef *hi2c);
NHAL_StatusTypeDef HAL_I2C_DisableListen_IT(I2C_HandleTypeDef *hi2c);
NHAL_StatusTypeDef HAL_I2C_Master_Abort_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress);
N
N /******* Non-Blocking mode: DMA */
NHAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Master_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Slave_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Slave_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Mem_Read_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size);
N/**
N  * @}
N  */
N
N/** @addtogroup I2C_IRQ_Handler_and_Callbacks IRQ Handler and Callbacks
N * @{
N */
N/******* I2C IRQHandler and Callbacks used in non blocking modes (Interrupt and DMA) */
Nvoid HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode);
Nvoid HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c);
N/**
N  * @}
N  */ 
N
N/** @addtogroup I2C_Exported_Functions_Group3 Peripheral State, Mode and Error functions
N  * @{
N  */
N/* Peripheral State, Mode and Error functions  *********************************/
NHAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c);
NHAL_I2C_ModeTypeDef  HAL_I2C_GetMode(I2C_HandleTypeDef *hi2c);
Nuint32_t             HAL_I2C_GetError(I2C_HandleTypeDef *hi2c);
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup I2C_Private_Constants I2C Private Constants
N  * @{
N  */
N
N/**
N  * @}
N  */ 
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup I2C_Private_Macro I2C Private Macros
N  * @{
N  */
N
N#define IS_I2C_ADDRESSING_MODE(MODE)    (((MODE) == I2C_ADDRESSINGMODE_7BIT) || \
N                                         ((MODE) == I2C_ADDRESSINGMODE_10BIT))
X#define IS_I2C_ADDRESSING_MODE(MODE)    (((MODE) == I2C_ADDRESSINGMODE_7BIT) ||                                          ((MODE) == I2C_ADDRESSINGMODE_10BIT))
N
N#define IS_I2C_DUAL_ADDRESS(ADDRESS)    (((ADDRESS) == I2C_DUALADDRESS_DISABLE) || \
N                                         ((ADDRESS) == I2C_DUALADDRESS_ENABLE))
X#define IS_I2C_DUAL_ADDRESS(ADDRESS)    (((ADDRESS) == I2C_DUALADDRESS_DISABLE) ||                                          ((ADDRESS) == I2C_DUALADDRESS_ENABLE))
N
N#define IS_I2C_OWN_ADDRESS2_MASK(MASK)  (((MASK) == I2C_OA2_NOMASK)  || \
N                                         ((MASK) == I2C_OA2_MASK01) || \
N                                         ((MASK) == I2C_OA2_MASK02) || \
N                                         ((MASK) == I2C_OA2_MASK03) || \
N                                         ((MASK) == I2C_OA2_MASK04) || \
N                                         ((MASK) == I2C_OA2_MASK05) || \
N                                         ((MASK) == I2C_OA2_MASK06) || \
N                                         ((MASK) == I2C_OA2_MASK07))
X#define IS_I2C_OWN_ADDRESS2_MASK(MASK)  (((MASK) == I2C_OA2_NOMASK)  ||                                          ((MASK) == I2C_OA2_MASK01) ||                                          ((MASK) == I2C_OA2_MASK02) ||                                          ((MASK) == I2C_OA2_MASK03) ||                                          ((MASK) == I2C_OA2_MASK04) ||                                          ((MASK) == I2C_OA2_MASK05) ||                                          ((MASK) == I2C_OA2_MASK06) ||                                          ((MASK) == I2C_OA2_MASK07))
N
N#define IS_I2C_GENERAL_CALL(CALL)       (((CALL) == I2C_GENERALCALL_DISABLE) || \
N                                         ((CALL) == I2C_GENERALCALL_ENABLE))
X#define IS_I2C_GENERAL_CALL(CALL)       (((CALL) == I2C_GENERALCALL_DISABLE) ||                                          ((CALL) == I2C_GENERALCALL_ENABLE))
N
N#define IS_I2C_NO_STRETCH(STRETCH)      (((STRETCH) == I2C_NOSTRETCH_DISABLE) || \
N                                         ((STRETCH) == I2C_NOSTRETCH_ENABLE))
X#define IS_I2C_NO_STRETCH(STRETCH)      (((STRETCH) == I2C_NOSTRETCH_DISABLE) ||                                          ((STRETCH) == I2C_NOSTRETCH_ENABLE))
N
N#define IS_I2C_MEMADD_SIZE(SIZE)        (((SIZE) == I2C_MEMADD_SIZE_8BIT) || \
N                                         ((SIZE) == I2C_MEMADD_SIZE_16BIT))
X#define IS_I2C_MEMADD_SIZE(SIZE)        (((SIZE) == I2C_MEMADD_SIZE_8BIT) ||                                          ((SIZE) == I2C_MEMADD_SIZE_16BIT))
N
N#define IS_TRANSFER_MODE(MODE)          (((MODE) == I2C_RELOAD_MODE)   || \
N                                         ((MODE) == I2C_AUTOEND_MODE) || \
N                                         ((MODE) == I2C_SOFTEND_MODE))
X#define IS_TRANSFER_MODE(MODE)          (((MODE) == I2C_RELOAD_MODE)   ||                                          ((MODE) == I2C_AUTOEND_MODE) ||                                          ((MODE) == I2C_SOFTEND_MODE))
N
N#define IS_TRANSFER_REQUEST(REQUEST)    (((REQUEST) == I2C_GENERATE_STOP)        || \
N                                         ((REQUEST) == I2C_GENERATE_START_READ)  || \
N                                         ((REQUEST) == I2C_GENERATE_START_WRITE) || \
N                                         ((REQUEST) == I2C_NO_STARTSTOP))
X#define IS_TRANSFER_REQUEST(REQUEST)    (((REQUEST) == I2C_GENERATE_STOP)        ||                                          ((REQUEST) == I2C_GENERATE_START_READ)  ||                                          ((REQUEST) == I2C_GENERATE_START_WRITE) ||                                          ((REQUEST) == I2C_NO_STARTSTOP))
N
N#define IS_I2C_TRANSFER_OPTIONS_REQUEST(REQUEST)  (((REQUEST) == I2C_FIRST_FRAME)          || \
N                                                   ((REQUEST) == I2C_NEXT_FRAME)           || \
N                                                   ((REQUEST) == I2C_FIRST_AND_LAST_FRAME) || \
N                                                   ((REQUEST) == I2C_LAST_FRAME))
X#define IS_I2C_TRANSFER_OPTIONS_REQUEST(REQUEST)  (((REQUEST) == I2C_FIRST_FRAME)          ||                                                    ((REQUEST) == I2C_NEXT_FRAME)           ||                                                    ((REQUEST) == I2C_FIRST_AND_LAST_FRAME) ||                                                    ((REQUEST) == I2C_LAST_FRAME))
N
N#define I2C_RESET_CR2(__HANDLE__)                 ((__HANDLE__)->Instance->CR2 &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_HEAD10R | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_RD_WRN)))
N
N#define I2C_GET_ADDR_MATCH(__HANDLE__)            (((__HANDLE__)->Instance->ISR & I2C_ISR_ADDCODE) >> 16)
N#define I2C_GET_DIR(__HANDLE__)                   (((__HANDLE__)->Instance->ISR & I2C_ISR_DIR) >> 16)
N#define I2C_GET_STOP_MODE(__HANDLE__)             ((__HANDLE__)->Instance->CR2 & I2C_CR2_AUTOEND)
N#define I2C_GET_OWN_ADDRESS1(__HANDLE__)          ((__HANDLE__)->Instance->OAR1 & I2C_OAR1_OA1)
N#define I2C_GET_OWN_ADDRESS2(__HANDLE__)          ((__HANDLE__)->Instance->OAR2 & I2C_OAR2_OA2)
N
N#define IS_I2C_OWN_ADDRESS1(ADDRESS1)             ((ADDRESS1) <= (uint32_t)0x000003FF)
N#define IS_I2C_OWN_ADDRESS2(ADDRESS2)             ((ADDRESS2) <= (uint16_t)0x00FF)
N
N#define I2C_MEM_ADD_MSB(__ADDRESS__)              ((uint8_t)((uint16_t)(((uint16_t)((__ADDRESS__) & (uint16_t)(0xFF00))) >> 8)))
N#define I2C_MEM_ADD_LSB(__ADDRESS__)              ((uint8_t)((uint16_t)((__ADDRESS__) & (uint16_t)(0x00FF))))
N
N#define I2C_GENERATE_START(__ADDMODE__,__ADDRESS__) (((__ADDMODE__) == I2C_ADDRESSINGMODE_7BIT) ? (uint32_t)((((uint32_t)(__ADDRESS__) & (I2C_CR2_SADD)) | (I2C_CR2_START) | (I2C_CR2_AUTOEND)) & (~I2C_CR2_RD_WRN)) : \
N                                                          (uint32_t)((((uint32_t)(__ADDRESS__) & (I2C_CR2_SADD)) | (I2C_CR2_ADD10) | (I2C_CR2_START)) & (~I2C_CR2_RD_WRN)))
X#define I2C_GENERATE_START(__ADDMODE__,__ADDRESS__) (((__ADDMODE__) == I2C_ADDRESSINGMODE_7BIT) ? (uint32_t)((((uint32_t)(__ADDRESS__) & (I2C_CR2_SADD)) | (I2C_CR2_START) | (I2C_CR2_AUTOEND)) & (~I2C_CR2_RD_WRN)) :                                                           (uint32_t)((((uint32_t)(__ADDRESS__) & (I2C_CR2_SADD)) | (I2C_CR2_ADD10) | (I2C_CR2_START)) & (~I2C_CR2_RD_WRN)))
N/**
N  * @}
N  */ 
N
N/* Private Functions ---------------------------------------------------------*/
N/** @defgroup I2C_Private_Functions I2C Private Functions
N  * @{
N  */
N/* Private functions are defined in stm32f7xx_hal_i2c.c file */
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif /* __STM32F7xx_HAL_I2C_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 323 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_I2C_MODULE_ENABLED */
N
N#ifdef HAL_I2S_MODULE_ENABLED
N #include "stm32f7xx_hal_i2s.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_i2s.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_i2s.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of I2S HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_I2S_H
N#define __STM32F7xx_HAL_I2S_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"  
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup I2S
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/ 
N/** @defgroup I2S_Exported_Types I2S Exported Types
N  * @{
N  */
N
N/** 
N  * @brief I2S Init structure definition  
N  */
Ntypedef struct
N{
N  uint32_t Mode;                /*!< Specifies the I2S operating mode.
N                                     This parameter can be a value of @ref I2S_Mode */
N
N  uint32_t Standard;            /*!< Specifies the standard used for the I2S communication.
N                                     This parameter can be a value of @ref I2S_Standard */
N
N  uint32_t DataFormat;          /*!< Specifies the data format for the I2S communication.
N                                     This parameter can be a value of @ref I2S_Data_Format */
N
N  uint32_t MCLKOutput;          /*!< Specifies whether the I2S MCLK output is enabled or not.
N                                     This parameter can be a value of @ref I2S_MCLK_Output */
N
N  uint32_t AudioFreq;           /*!< Specifies the frequency selected for the I2S communication.
N                                     This parameter can be a value of @ref I2S_Audio_Frequency */
N
N  uint32_t CPOL;                /*!< Specifies the idle state of the I2S clock.
N                                     This parameter can be a value of @ref I2S_Clock_Polarity */
N   
N  uint32_t ClockSource;         /*!< Specifies the I2S Clock Source.
N                                     This parameter can be a value of @ref I2S_Clock_Source */
N}I2S_InitTypeDef;
N
N/** 
N  * @brief  HAL State structures definition  
N  */ 
Ntypedef enum
N{
N  HAL_I2S_STATE_RESET      = 0x00U,  /*!< I2S not yet initialized or disabled                */
N  HAL_I2S_STATE_READY      = 0x01U,  /*!< I2S initialized and ready for use                  */
N  HAL_I2S_STATE_BUSY       = 0x02U,  /*!< I2S internal process is ongoing                    */   
N  HAL_I2S_STATE_BUSY_TX    = 0x03U,  /*!< Data Transmission process is ongoing               */ 
N  HAL_I2S_STATE_BUSY_RX    = 0x04U,  /*!< Data Reception process is ongoing                  */
N  HAL_I2S_STATE_BUSY_TX_RX = 0x05U,  /*!< Data Transmission and Reception process is ongoing */
N  HAL_I2S_STATE_TIMEOUT    = 0x06U,  /*!< I2S timeout state                                  */  
N  HAL_I2S_STATE_ERROR      = 0x07U   /*!< I2S error state                                    */      
N                                                                        
N}HAL_I2S_StateTypeDef;
N
N/** 
N  * @brief I2S handle Structure definition  
N  */
Ntypedef struct
N{
N  SPI_TypeDef                *Instance;    /* I2S registers base address */
N
N  I2S_InitTypeDef            Init;         /* I2S communication parameters */
N  
N  uint16_t                   *pTxBuffPtr;  /* Pointer to I2S Tx transfer buffer */
N  
N  __IO uint16_t              TxXferSize;   /* I2S Tx transfer size */
X  volatile uint16_t              TxXferSize;    
N  
N  __IO uint16_t              TxXferCount;  /* I2S Tx transfer Counter */
X  volatile uint16_t              TxXferCount;   
N  
N  uint16_t                   *pRxBuffPtr;  /* Pointer to I2S Rx transfer buffer */
N  
N  __IO uint16_t              RxXferSize;   /* I2S Rx transfer size */
X  volatile uint16_t              RxXferSize;    
N  
N  __IO uint16_t              RxXferCount;  /* I2S Rx transfer counter 
X  volatile uint16_t              RxXferCount;  
N                                              (This field is initialized at the 
N                                               same value as transfer size at the 
N                                               beginning of the transfer and 
N                                               decremented when a sample is received. 
N                                               NbSamplesReceived = RxBufferSize-RxBufferCount) */
N
N  DMA_HandleTypeDef          *hdmatx;      /* I2S Tx DMA handle parameters */
N
N  DMA_HandleTypeDef          *hdmarx;      /* I2S Rx DMA handle parameters */
N  
N  __IO HAL_LockTypeDef       Lock;         /* I2S locking object */
X  volatile HAL_LockTypeDef       Lock;          
N  
N  __IO HAL_I2S_StateTypeDef  State;        /* I2S communication state */
X  volatile HAL_I2S_StateTypeDef  State;         
N
N  __IO uint32_t  ErrorCode;                /* I2S Error code                 */
X  volatile uint32_t  ErrorCode;                 
N
N}I2S_HandleTypeDef;
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup I2S_Exported_Constants I2S Exported Constants
N  * @{
N  */
N
N/** @defgroup I2S_Error_Defintion I2S_Error_Defintion
N  *@brief     I2S Error Code
N  * @{
N  */
N#define HAL_I2S_ERROR_NONE      ((uint32_t)0x00000000U)  /*!< No error           */
N#define HAL_I2S_ERROR_TIMEOUT   ((uint32_t)0x00000001U)  /*!< Timeout error      */
N#define HAL_I2S_ERROR_OVR       ((uint32_t)0x00000002U)  /*!< OVR error          */
N#define HAL_I2S_ERROR_UDR       ((uint32_t)0x00000004U)  /*!< UDR error          */
N#define HAL_I2S_ERROR_DMA       ((uint32_t)0x00000008U)  /*!< DMA transfer error */
N#define HAL_I2S_ERROR_UNKNOW    ((uint32_t)0x00000010U)  /*!< Unknow Error error */
N
N/**
N  * @}
N  */
N/** @defgroup I2S_Clock_Source I2S Clock Source
N  * @{
N  */
N#define I2S_CLOCK_EXTERNAL                ((uint32_t)0x00000001U)
N#define I2S_CLOCK_PLL                     ((uint32_t)0x00000002U)
N/**
N  * @}
N  */
N
N/** @defgroup I2S_Mode I2S Mode
N  * @{
N  */
N#define I2S_MODE_SLAVE_TX                ((uint32_t)0x00000000U)
N#define I2S_MODE_SLAVE_RX                ((uint32_t)0x00000100U)
N#define I2S_MODE_MASTER_TX               ((uint32_t)0x00000200U)
N#define I2S_MODE_MASTER_RX               ((uint32_t)0x00000300U)
N/**
N  * @}
N  */
N  
N/** @defgroup I2S_Standard I2S Standard
N  * @{
N  */
N#define I2S_STANDARD_PHILIPS             ((uint32_t)0x00000000U)
N#define I2S_STANDARD_MSB                 ((uint32_t)0x00000010U)
N#define I2S_STANDARD_LSB                 ((uint32_t)0x00000020U)
N#define I2S_STANDARD_PCM_SHORT           ((uint32_t)0x00000030U)
N#define I2S_STANDARD_PCM_LONG            ((uint32_t)0x000000B0U)
N/**
N  * @}
N  */
N  
N/** @defgroup I2S_Data_Format I2S Data Format
N  * @{
N  */
N#define I2S_DATAFORMAT_16B               ((uint32_t)0x00000000U)
N#define I2S_DATAFORMAT_16B_EXTENDED      ((uint32_t)0x00000001U)
N#define I2S_DATAFORMAT_24B               ((uint32_t)0x00000003U)
N#define I2S_DATAFORMAT_32B               ((uint32_t)0x00000005U)
N/**
N  * @}
N  */
N
N/** @defgroup I2S_MCLK_Output I2S Mclk Output
N  * @{
N  */
N#define I2S_MCLKOUTPUT_ENABLE           ((uint32_t)SPI_I2SPR_MCKOE)
N#define I2S_MCLKOUTPUT_DISABLE          ((uint32_t)0x00000000U)
N/**
N  * @}
N  */
N
N/** @defgroup I2S_Audio_Frequency I2S Audio Frequency
N  * @{
N  */
N#define I2S_AUDIOFREQ_192K               ((uint32_t)192000U)
N#define I2S_AUDIOFREQ_96K                ((uint32_t)96000U)
N#define I2S_AUDIOFREQ_48K                ((uint32_t)48000U)
N#define I2S_AUDIOFREQ_44K                ((uint32_t)44100U)
N#define I2S_AUDIOFREQ_32K                ((uint32_t)32000U)
N#define I2S_AUDIOFREQ_22K                ((uint32_t)22050U)
N#define I2S_AUDIOFREQ_16K                ((uint32_t)16000U)
N#define I2S_AUDIOFREQ_11K                ((uint32_t)11025U)
N#define I2S_AUDIOFREQ_8K                 ((uint32_t)8000U)
N#define I2S_AUDIOFREQ_DEFAULT            ((uint32_t)2U)
N/**
N  * @}
N  */
N            
N
N/** @defgroup I2S_Clock_Polarity I2S Clock Polarity
N  * @{
N  */
N#define I2S_CPOL_LOW                    ((uint32_t)0x00000000U)
N#define I2S_CPOL_HIGH                   ((uint32_t)SPI_I2SCFGR_CKPOL)
N/**
N  * @}
N  */
N
N/** @defgroup I2S_Interrupts_Definition I2S Interrupts Definition
N  * @{
N  */
N#define I2S_IT_TXE                      SPI_CR2_TXEIE
N#define I2S_IT_RXNE                     SPI_CR2_RXNEIE
N#define I2S_IT_ERR                      SPI_CR2_ERRIE
N/**
N  * @}
N  */
N
N/** @defgroup I2S_Flags_Definition I2S Flags Definition
N  * @{
N  */ 
N#define I2S_FLAG_TXE                    SPI_SR_TXE
N#define I2S_FLAG_RXNE                   SPI_SR_RXNE
N
N#define I2S_FLAG_UDR                    SPI_SR_UDR
N#define I2S_FLAG_OVR                    SPI_SR_OVR
N#define I2S_FLAG_FRE                    SPI_SR_FRE
N
N#define I2S_FLAG_CHSIDE                 SPI_SR_CHSIDE
N#define I2S_FLAG_BSY                    SPI_SR_BSY
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N  
N/* Exported macros -----------------------------------------------------------*/
N/** @defgroup I2S_Exported_Macros I2S Exported Macros
N  * @{
N  */
N
N/** @brief  Reset I2S handle state
N  * @param  __HANDLE__: specifies the I2S handle.
N  * @retval None
N  */
N#define __HAL_I2S_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_I2S_STATE_RESET)
N
N/** @brief  Enable or disable the specified SPI peripheral (in I2S mode).
N  * @param  __HANDLE__: specifies the I2S Handle. 
N  * @retval None
N  */
N#define __HAL_I2S_ENABLE(__HANDLE__) ((__HANDLE__)->Instance->I2SCFGR |= SPI_I2SCFGR_I2SE)
N#define __HAL_I2S_DISABLE(__HANDLE__) ((__HANDLE__)->Instance->I2SCFGR &= ~SPI_I2SCFGR_I2SE)
N
N/** @brief  Enable or disable the specified I2S interrupts.
N  * @param  __HANDLE__: specifies the I2S Handle.
N  * @param  __INTERRUPT__: specifies the interrupt source to enable or disable.
N  *        This parameter can be one of the following values:
N  *            @arg I2S_IT_TXE: Tx buffer empty interrupt enable
N  *            @arg I2S_IT_RXNE: RX buffer not empty interrupt enable
N  *            @arg I2S_IT_ERR: Error interrupt enable
N  * @retval None
N  */  
N#define __HAL_I2S_ENABLE_IT(__HANDLE__, __INTERRUPT__) ((__HANDLE__)->Instance->CR2 |= (__INTERRUPT__))
N#define __HAL_I2S_DISABLE_IT(__HANDLE__, __INTERRUPT__) ((__HANDLE__)->Instance->CR2 &= ~(__INTERRUPT__))
N 
N/** @brief  Checks if the specified I2S interrupt source is enabled or disabled.
N  * @param  __HANDLE__: specifies the I2S Handle.
N  *         This parameter can be I2S where x: 1, 2, or 3 to select the I2S peripheral.
N  * @param  __INTERRUPT__: specifies the I2S interrupt source to check.
N  *          This parameter can be one of the following values:
N  *            @arg I2S_IT_TXE: Tx buffer empty interrupt enable
N  *            @arg I2S_IT_RXNE: RX buffer not empty interrupt enable
N  *            @arg I2S_IT_ERR: Error interrupt enable
N  * @retval The new state of __IT__ (TRUE or FALSE).
N  */
N#define __HAL_I2S_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) ((((__HANDLE__)->Instance->CR2 & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)
N
N/** @brief  Checks whether the specified I2S flag is set or not.
N  * @param  __HANDLE__: specifies the I2S Handle.
N  * @param  __FLAG__: specifies the flag to check.
N  *        This parameter can be one of the following values:
N  *            @arg I2S_FLAG_RXNE: Receive buffer not empty flag
N  *            @arg I2S_FLAG_TXE: Transmit buffer empty flag
N  *            @arg I2S_FLAG_UDR: Underrun flag
N  *            @arg I2S_FLAG_OVR: Overrun flag
N  *            @arg I2S_FLAG_FRE: Frame error flag
N  *            @arg I2S_FLAG_CHSIDE: Channel Side flag
N  *            @arg I2S_FLAG_BSY: Busy flag
N  * @retval The new state of __FLAG__ (TRUE or FALSE).
N  */
N#define __HAL_I2S_GET_FLAG(__HANDLE__, __FLAG__) ((((__HANDLE__)->Instance->SR) & (__FLAG__)) == (__FLAG__))
N
N/** @brief Clears the I2S OVR pending flag.
N  * @param  __HANDLE__: specifies the I2S Handle.
N  * @retval None
N  */
N#define __HAL_I2S_CLEAR_OVRFLAG(__HANDLE__)     \
N  do{                                           \
N    __IO uint32_t tmpreg;                       \
N    tmpreg = (__HANDLE__)->Instance->DR;        \
N    tmpreg = (__HANDLE__)->Instance->SR;        \
N    UNUSED(tmpreg);                             \
N  } while(0)
X#define __HAL_I2S_CLEAR_OVRFLAG(__HANDLE__)       do{                                               __IO uint32_t tmpreg;                           tmpreg = (__HANDLE__)->Instance->DR;            tmpreg = (__HANDLE__)->Instance->SR;            UNUSED(tmpreg);                               } while(0)
N    
N/** @brief Clears the I2S UDR pending flag.
N  * @param  __HANDLE__: specifies the I2S Handle.
N  * @retval None
N  */
N#define __HAL_I2S_CLEAR_UDRFLAG(__HANDLE__)     \
N  do{                                             \
N  __IO uint32_t tmpreg;                         \
N  tmpreg = (__HANDLE__)->Instance->SR;          \
N  UNUSED(tmpreg);                               \
N  } while(0)
X#define __HAL_I2S_CLEAR_UDRFLAG(__HANDLE__)       do{                                               __IO uint32_t tmpreg;                           tmpreg = (__HANDLE__)->Instance->SR;            UNUSED(tmpreg);                                 } while(0)
N/**
N  * @}
N  */ 
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup I2S_Exported_Functions  I2S Exported Functions
N  * @{
N  */
N                                                
N/** @addtogroup I2S_Exported_Functions_Group1 Initialization and de-initialization functions 
N  * @{
N  */
N
N/* Initialization and de-initialization functions *****************************/
NHAL_StatusTypeDef HAL_I2S_Init(I2S_HandleTypeDef *hi2s);
NHAL_StatusTypeDef HAL_I2S_DeInit (I2S_HandleTypeDef *hi2s);
Nvoid HAL_I2S_MspInit(I2S_HandleTypeDef *hi2s);
Nvoid HAL_I2S_MspDeInit(I2S_HandleTypeDef *hi2s);
N/**
N  * @}
N  */
N
N/** @addtogroup I2S_Exported_Functions_Group2 Input and Output operation functions 
N  * @{
N  */
N/* I/O operation functions  ***************************************************/
N /* Blocking mode: Polling */
NHAL_StatusTypeDef HAL_I2S_Transmit(I2S_HandleTypeDef *hi2s, uint16_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_I2S_Receive(I2S_HandleTypeDef *hi2s, uint16_t *pData, uint16_t Size, uint32_t Timeout);
N
N /* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_I2S_Transmit_IT(I2S_HandleTypeDef *hi2s, uint16_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2S_Receive_IT(I2S_HandleTypeDef *hi2s, uint16_t *pData, uint16_t Size);
Nvoid HAL_I2S_IRQHandler(I2S_HandleTypeDef *hi2s);
N
N/* Non-Blocking mode: DMA */
NHAL_StatusTypeDef HAL_I2S_Transmit_DMA(I2S_HandleTypeDef *hi2s, uint16_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2S_Receive_DMA(I2S_HandleTypeDef *hi2s, uint16_t *pData, uint16_t Size);
N
NHAL_StatusTypeDef HAL_I2S_DMAPause(I2S_HandleTypeDef *hi2s);
NHAL_StatusTypeDef HAL_I2S_DMAResume(I2S_HandleTypeDef *hi2s);
NHAL_StatusTypeDef HAL_I2S_DMAStop(I2S_HandleTypeDef *hi2s);
N
N/* Callbacks used in non blocking modes (Interrupt and DMA) *******************/
Nvoid HAL_I2S_TxHalfCpltCallback(I2S_HandleTypeDef *hi2s);
Nvoid HAL_I2S_TxCpltCallback(I2S_HandleTypeDef *hi2s);
Nvoid HAL_I2S_RxHalfCpltCallback(I2S_HandleTypeDef *hi2s);
Nvoid HAL_I2S_RxCpltCallback(I2S_HandleTypeDef *hi2s);
Nvoid HAL_I2S_ErrorCallback(I2S_HandleTypeDef *hi2s);
N/**
N  * @}
N  */
N
N/** @addtogroup I2S_Exported_Functions_Group3 Peripheral State and Errors functions
N  * @{
N  */
N/* Peripheral Control and State functions  ************************************/
NHAL_I2S_StateTypeDef HAL_I2S_GetState(I2S_HandleTypeDef *hi2s);
Nuint32_t HAL_I2S_GetError(I2S_HandleTypeDef *hi2s);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup I2S_Private_Constants I2S Private Constants
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup I2S_Private_Macros I2S Private Macros
N  * @{
N  */
N#define IS_I2S_CLOCKSOURCE(CLOCK) (((CLOCK) == I2S_CLOCK_EXTERNAL) || \
N                                   ((CLOCK) == I2S_CLOCK_PLL))
X#define IS_I2S_CLOCKSOURCE(CLOCK) (((CLOCK) == I2S_CLOCK_EXTERNAL) ||                                    ((CLOCK) == I2S_CLOCK_PLL))
N								   
N#define IS_I2S_MODE(MODE) (((MODE) == I2S_MODE_SLAVE_TX) || \
N                           ((MODE) == I2S_MODE_SLAVE_RX) || \
N                           ((MODE) == I2S_MODE_MASTER_TX)|| \
N                           ((MODE) == I2S_MODE_MASTER_RX))
X#define IS_I2S_MODE(MODE) (((MODE) == I2S_MODE_SLAVE_TX) ||                            ((MODE) == I2S_MODE_SLAVE_RX) ||                            ((MODE) == I2S_MODE_MASTER_TX)||                            ((MODE) == I2S_MODE_MASTER_RX))
N                           
N#define IS_I2S_STANDARD(STANDARD) (((STANDARD) == I2S_STANDARD_PHILIPS)   || \
N                                   ((STANDARD) == I2S_STANDARD_MSB)       || \
N                                   ((STANDARD) == I2S_STANDARD_LSB)       || \
N                                   ((STANDARD) == I2S_STANDARD_PCM_SHORT) || \
N                                   ((STANDARD) == I2S_STANDARD_PCM_LONG))
X#define IS_I2S_STANDARD(STANDARD) (((STANDARD) == I2S_STANDARD_PHILIPS)   ||                                    ((STANDARD) == I2S_STANDARD_MSB)       ||                                    ((STANDARD) == I2S_STANDARD_LSB)       ||                                    ((STANDARD) == I2S_STANDARD_PCM_SHORT) ||                                    ((STANDARD) == I2S_STANDARD_PCM_LONG))
N
N#define IS_I2S_DATA_FORMAT(FORMAT) (((FORMAT) == I2S_DATAFORMAT_16B)          || \
N                                    ((FORMAT) == I2S_DATAFORMAT_16B_EXTENDED) || \
N                                    ((FORMAT) == I2S_DATAFORMAT_24B)          || \
N                                    ((FORMAT) == I2S_DATAFORMAT_32B))
X#define IS_I2S_DATA_FORMAT(FORMAT) (((FORMAT) == I2S_DATAFORMAT_16B)          ||                                     ((FORMAT) == I2S_DATAFORMAT_16B_EXTENDED) ||                                     ((FORMAT) == I2S_DATAFORMAT_24B)          ||                                     ((FORMAT) == I2S_DATAFORMAT_32B))
N
N#define IS_I2S_MCLK_OUTPUT(OUTPUT) (((OUTPUT) == I2S_MCLKOUTPUT_ENABLE) || \
N                                    ((OUTPUT) == I2S_MCLKOUTPUT_DISABLE))
X#define IS_I2S_MCLK_OUTPUT(OUTPUT) (((OUTPUT) == I2S_MCLKOUTPUT_ENABLE) ||                                     ((OUTPUT) == I2S_MCLKOUTPUT_DISABLE))
N                                    
N#define IS_I2S_AUDIO_FREQ(FREQ) ((((FREQ) >= I2S_AUDIOFREQ_8K) && \
N                                 ((FREQ) <= I2S_AUDIOFREQ_192K)) || \
N                                 ((FREQ) == I2S_AUDIOFREQ_DEFAULT))
X#define IS_I2S_AUDIO_FREQ(FREQ) ((((FREQ) >= I2S_AUDIOFREQ_8K) &&                                  ((FREQ) <= I2S_AUDIOFREQ_192K)) ||                                  ((FREQ) == I2S_AUDIOFREQ_DEFAULT))
N								 
N#define IS_I2S_CPOL(CPOL) (((CPOL) == I2S_CPOL_LOW) || \
N                           ((CPOL) == I2S_CPOL_HIGH))
X#define IS_I2S_CPOL(CPOL) (((CPOL) == I2S_CPOL_LOW) ||                            ((CPOL) == I2S_CPOL_HIGH))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */  
N	
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif /* __STM32F7xx_HAL_I2S_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 327 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_I2S_MODULE_ENABLED */
N
N#ifdef HAL_IWDG_MODULE_ENABLED
N #include "stm32f7xx_hal_iwdg.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_iwdg.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_iwdg.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of IWDG HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_IWDG_H
N#define __STM32F7xx_HAL_IWDG_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @defgroup IWDG IWDG
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup IWDG_Exported_Types IWDG Exported Types
N  * @{
N  */
N
N/** 
N  * @brief  IWDG Init structure definition
N  */
Ntypedef struct
N{
N  uint32_t Prescaler;  /*!< Select the prescaler of the IWDG.
N                            This parameter can be a value of @ref IWDG_Prescaler */
N
N  uint32_t Reload;     /*!< Specifies the IWDG down-counter reload value.
N                            This parameter must be a number between Min_Data = 0 and Max_Data = 0x0FFF */
N
N  uint32_t Window;     /*!< Specifies the window value to be compared to the down-counter.
N                            This parameter must be a number between Min_Data = 0 and Max_Data = 0x0FFF */
N
N} IWDG_InitTypeDef;
N
N/** 
N  * @brief  IWDG Handle Structure definition  
N  */
Ntypedef struct
N{
N  IWDG_TypeDef                 *Instance;  /*!< Register base address    */
N
N  IWDG_InitTypeDef             Init;       /*!< IWDG required parameters */
N
N}IWDG_HandleTypeDef;
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup IWDG_Exported_Constants IWDG Exported Constants
N  * @{
N  */
N
N/** @defgroup IWDG_Prescaler IWDG Prescaler
N  * @{
N  */
N#define IWDG_PRESCALER_4                0x00000000u                   /*!< IWDG prescaler set to 4   */
N#define IWDG_PRESCALER_8                IWDG_PR_PR_0                  /*!< IWDG prescaler set to 8   */
N#define IWDG_PRESCALER_16               IWDG_PR_PR_1                  /*!< IWDG prescaler set to 16  */
N#define IWDG_PRESCALER_32               (IWDG_PR_PR_1 | IWDG_PR_PR_0) /*!< IWDG prescaler set to 32  */
N#define IWDG_PRESCALER_64               IWDG_PR_PR_2                  /*!< IWDG prescaler set to 64  */
N#define IWDG_PRESCALER_128              (IWDG_PR_PR_2 | IWDG_PR_PR_0) /*!< IWDG prescaler set to 128 */
N#define IWDG_PRESCALER_256              (IWDG_PR_PR_2 | IWDG_PR_PR_1) /*!< IWDG prescaler set to 256 */
N/**
N  * @}
N  */
N
N/** @defgroup IWDG_Window_option IWDG Window option
N  * @{
N  */
N#define IWDG_WINDOW_DISABLE             IWDG_WINR_WIN
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macros -----------------------------------------------------------*/
N/** @defgroup IWDG_Exported_Macros IWDG Exported Macros
N  * @{
N  */
N
N/**
N  * @brief  Enable the IWDG peripheral.
N  * @param  __HANDLE__: IWDG handle
N  * @retval None
N  */
N#define __HAL_IWDG_START(__HANDLE__)                WRITE_REG((__HANDLE__)->Instance->KR, IWDG_KEY_ENABLE)
N
N/**
N  * @brief  Reload IWDG counter with value defined in the reload register
N  *         (write access to IWDG_PR, IWDG_RLR & IWDG_WINR registers disabled).
N  * @param  __HANDLE__:  IWDG handle
N  * @retval None
N  */
N#define __HAL_IWDG_RELOAD_COUNTER(__HANDLE__)       WRITE_REG((__HANDLE__)->Instance->KR, IWDG_KEY_RELOAD)
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup IWDG_Exported_Functions  IWDG Exported Functions
N  * @{
N  */
N
N/** @defgroup IWDG_Exported_Functions_Group1 Initialization and Start functions
N  * @{
N  */
N/* Initialization/Start functions  ********************************************/
NHAL_StatusTypeDef HAL_IWDG_Init(IWDG_HandleTypeDef *hiwdg);
N/**
N  * @}
N  */
N
N/** @defgroup IWDG_Exported_Functions_Group2 IO operation functions
N  * @{
N  */
N/* I/O operation functions ****************************************************/
NHAL_StatusTypeDef HAL_IWDG_Refresh(IWDG_HandleTypeDef *hiwdg);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup IWDG_Private_Constants IWDG Private Constants
N  * @{
N  */
N
N/**
N  * @brief  IWDG Key Register BitMask
N  */
N#define IWDG_KEY_RELOAD                 0x0000AAAAu  /*!< IWDG Reload Counter Enable   */
N#define IWDG_KEY_ENABLE                 0x0000CCCCu  /*!< IWDG Peripheral Enable       */
N#define IWDG_KEY_WRITE_ACCESS_ENABLE    0x00005555u  /*!< IWDG KR Write Access Enable  */
N#define IWDG_KEY_WRITE_ACCESS_DISABLE   0x00000000u  /*!< IWDG KR Write Access Disable */
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup IWDG_Private_Macros IWDG Private Macros
N  * @{
N  */
N
N/**
N  * @brief  Enable write access to IWDG_PR, IWDG_RLR and IWDG_WINR registers.
N  * @param  __HANDLE__: IWDG handle
N  * @retval None
N  */
N#define IWDG_ENABLE_WRITE_ACCESS(__HANDLE__)  WRITE_REG((__HANDLE__)->Instance->KR, IWDG_KEY_WRITE_ACCESS_ENABLE)
N
N/**
N  * @brief  Disable write access to IWDG_PR, IWDG_RLR and IWDG_WINR registers.
N  * @param  __HANDLE__: IWDG handle
N  * @retval None
N  */
N#define IWDG_DISABLE_WRITE_ACCESS(__HANDLE__) WRITE_REG((__HANDLE__)->Instance->KR, IWDG_KEY_WRITE_ACCESS_DISABLE)
N
N/**
N  * @brief  Check IWDG prescaler value.
N  * @param  __PRESCALER__: IWDG prescaler value
N  * @retval None
N  */
N#define IS_IWDG_PRESCALER(__PRESCALER__)      (((__PRESCALER__) == IWDG_PRESCALER_4)  || \
N                                               ((__PRESCALER__) == IWDG_PRESCALER_8)  || \
N                                               ((__PRESCALER__) == IWDG_PRESCALER_16) || \
N                                               ((__PRESCALER__) == IWDG_PRESCALER_32) || \
N                                               ((__PRESCALER__) == IWDG_PRESCALER_64) || \
N                                               ((__PRESCALER__) == IWDG_PRESCALER_128)|| \
N                                               ((__PRESCALER__) == IWDG_PRESCALER_256))
X#define IS_IWDG_PRESCALER(__PRESCALER__)      (((__PRESCALER__) == IWDG_PRESCALER_4)  ||                                                ((__PRESCALER__) == IWDG_PRESCALER_8)  ||                                                ((__PRESCALER__) == IWDG_PRESCALER_16) ||                                                ((__PRESCALER__) == IWDG_PRESCALER_32) ||                                                ((__PRESCALER__) == IWDG_PRESCALER_64) ||                                                ((__PRESCALER__) == IWDG_PRESCALER_128)||                                                ((__PRESCALER__) == IWDG_PRESCALER_256))
N
N/**
N  * @brief  Check IWDG reload value.
N  * @param  __RELOAD__: IWDG reload value
N  * @retval None
N  */
N#define IS_IWDG_RELOAD(__RELOAD__)            ((__RELOAD__) <= IWDG_RLR_RL)
N
N/**
N  * @brief  Check IWDG window value.
N  * @param  __WINDOW__: IWDG window value
N  * @retval None
N  */
N#define IS_IWDG_WINDOW(__WINDOW__)            ((__WINDOW__) <= IWDG_WINR_WIN)
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_IWDG_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 331 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_IWDG_MODULE_ENABLED */
N
N#ifdef HAL_LPTIM_MODULE_ENABLED
N #include "stm32f7xx_hal_lptim.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_lptim.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_lptim.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of LPTIM HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_LPTIM_H
N#define __STM32F7xx_HAL_LPTIM_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @defgroup LPTIM LPTIM
N  * @brief LPTIM HAL module driver
N  * @{
N  */
N  
N/* Exported types ------------------------------------------------------------*/ 
N/** @defgroup LPTIM_Exported_Types LPTIM Exported Types
N  * @{
N  */
N
N/** @defgroup LPTIM_WAKEUPTIMER_EXTILINE LPTIM WAKEUP Timer EXTI Line
N  * @{
N  */
N#define LPTIM_EXTI_LINE_WAKEUPTIMER_EVENT  ((uint32_t)EXTI_IMR_MR23)  /*!< External interrupt line 23 Connected to the LPTIM EXTI Line */
N/**
N  * @}
N  */
N
N/** 
N  * @brief  LPTIM Clock configuration definition  
N  */
Ntypedef struct
N{
N  uint32_t Source;         /*!< Selects the clock source.
N                           This parameter can be a value of @ref LPTIM_Clock_Source   */
N
N  uint32_t Prescaler;      /*!< Specifies the counter clock Prescaler.
N                           This parameter can be a value of @ref LPTIM_Clock_Prescaler */
N  
N}LPTIM_ClockConfigTypeDef;
N
N/** 
N  * @brief  LPTIM Clock configuration definition  
N  */
Ntypedef struct
N{
N  uint32_t Polarity;      /*!< Selects the polarity of the active edge for the counter unit
N                           if the ULPTIM input is selected.
N                           Note: This parameter is used only when Ultra low power clock source is used.
N                           Note: If the polarity is configured on 'both edges', an auxiliary clock
N                           (one of the Low power oscillator) must be active.
N                           This parameter can be a value of @ref LPTIM_Clock_Polarity */ 
N  
N  uint32_t SampleTime;     /*!< Selects the clock sampling time to configure the clock glitch filter.
N                           Note: This parameter is used only when Ultra low power clock source is used.
N                           This parameter can be a value of @ref LPTIM_Clock_Sample_Time */  
N  
N}LPTIM_ULPClockConfigTypeDef;
N
N/** 
N  * @brief  LPTIM Trigger configuration definition  
N  */
Ntypedef struct
N{
N  uint32_t Source;        /*!< Selects the Trigger source.
N                          This parameter can be a value of @ref LPTIM_Trigger_Source */
N  
N  uint32_t ActiveEdge;    /*!< Selects the Trigger active edge.
N                          Note: This parameter is used only when an external trigger is used.
N                          This parameter can be a value of @ref LPTIM_External_Trigger_Polarity */
N  
N  uint32_t SampleTime;    /*!< Selects the trigger sampling time to configure the clock glitch filter.
N                          Note: This parameter is used only when an external trigger is used.
N                          This parameter can be a value of @ref LPTIM_Trigger_Sample_Time  */  
N}LPTIM_TriggerConfigTypeDef;
N
N/** 
N  * @brief  LPTIM Initialization Structure definition  
N  */
Ntypedef struct
N{                                                    
N  LPTIM_ClockConfigTypeDef     Clock;               /*!< Specifies the clock parameters */
N                                                    
N  LPTIM_ULPClockConfigTypeDef  UltraLowPowerClock;  /*!< Specifies the Ultra Low Power clock parameters */
N                                                    
N  LPTIM_TriggerConfigTypeDef   Trigger;             /*!< Specifies the Trigger parameters */
N                                                    
N  uint32_t                     OutputPolarity;      /*!< Specifies the Output polarity.
N                                                    This parameter can be a value of @ref LPTIM_Output_Polarity */
N                                                    
N  uint32_t                     UpdateMode;          /*!< Specifies whether the update of the autorelaod and the compare
N                                                    values is done immediately or after the end of current period.
N                                                    This parameter can be a value of @ref LPTIM_Updating_Mode */
N
N  uint32_t                     CounterSource;       /*!< Specifies whether the counter is incremented each internal event
N                                                    or each external event.
N                                                    This parameter can be a value of @ref LPTIM_Counter_Source */  
N  
N}LPTIM_InitTypeDef;
N
N/** 
N  * @brief  HAL LPTIM State structure definition  
N  */ 
Ntypedef enum __HAL_LPTIM_StateTypeDef
N{
N  HAL_LPTIM_STATE_RESET            = 0x00U,    /*!< Peripheral not yet initialized or disabled  */
N  HAL_LPTIM_STATE_READY            = 0x01U,    /*!< Peripheral Initialized and ready for use    */
N  HAL_LPTIM_STATE_BUSY             = 0x02U,    /*!< An internal process is ongoing              */    
N  HAL_LPTIM_STATE_TIMEOUT          = 0x03U,    /*!< Timeout state                               */  
N  HAL_LPTIM_STATE_ERROR            = 0x04U     /*!< Internal Process is ongoing                */                                                                             
N}HAL_LPTIM_StateTypeDef;
N
N/** 
N  * @brief  LPTIM handle Structure definition  
N  */ 
Ntypedef struct
N{
N      LPTIM_TypeDef              *Instance;         /*!< Register base address     */
N      
N      LPTIM_InitTypeDef           Init;             /*!< LPTIM required parameters */
N  
N      HAL_StatusTypeDef           Status;           /*!< LPTIM peripheral status   */  
N  
N      HAL_LockTypeDef             Lock;             /*!< LPTIM locking object      */
N  
N   __IO  HAL_LPTIM_StateTypeDef   State;            /*!< LPTIM peripheral state    */
X   volatile  HAL_LPTIM_StateTypeDef   State;             
N  
N}LPTIM_HandleTypeDef;
N
N/**
N  * @}
N  */ 
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup LPTIM_Exported_Constants LPTIM Exported Constants
N  * @{
N  */
N
N/** @defgroup LPTIM_Clock_Source LPTIM Clock Source
N  * @{
N  */
N#define LPTIM_CLOCKSOURCE_APBCLOCK_LPOSC        ((uint32_t)0x00U)
N#define LPTIM_CLOCKSOURCE_ULPTIM                LPTIM_CFGR_CKSEL                                           
N/**                                             
N  * @}
N  */
N
N/** @defgroup LPTIM_Clock_Prescaler LPTIM Clock Prescaler
N  * @{
N  */
N#define LPTIM_PRESCALER_DIV1                    ((uint32_t)0x000000U)
N#define LPTIM_PRESCALER_DIV2                    LPTIM_CFGR_PRESC_0
N#define LPTIM_PRESCALER_DIV4                    LPTIM_CFGR_PRESC_1
N#define LPTIM_PRESCALER_DIV8                    ((uint32_t)(LPTIM_CFGR_PRESC_0 | LPTIM_CFGR_PRESC_1))
N#define LPTIM_PRESCALER_DIV16                   LPTIM_CFGR_PRESC_2
N#define LPTIM_PRESCALER_DIV32                   ((uint32_t)(LPTIM_CFGR_PRESC_0 | LPTIM_CFGR_PRESC_2))
N#define LPTIM_PRESCALER_DIV64                   ((uint32_t)(LPTIM_CFGR_PRESC_1 | LPTIM_CFGR_PRESC_2))
N#define LPTIM_PRESCALER_DIV128                  ((uint32_t)LPTIM_CFGR_PRESC)                                             
N/**
N  * @}
N  */ 
N
N/** @defgroup LPTIM_Output_Polarity LPTIM Output Polarity
N  * @{
N  */
N
N#define LPTIM_OUTPUTPOLARITY_HIGH               ((uint32_t)0x00000000U)
N#define LPTIM_OUTPUTPOLARITY_LOW                (LPTIM_CFGR_WAVPOL)
N/**
N  * @}
N  */
N
N/** @defgroup LPTIM_Clock_Sample_Time LPTIM Clock Sample Time
N  * @{
N  */
N#define LPTIM_CLOCKSAMPLETIME_DIRECTTRANSITION ((uint32_t)0x00000000U)
N#define LPTIM_CLOCKSAMPLETIME_2TRANSITIONS     LPTIM_CFGR_CKFLT_0
N#define LPTIM_CLOCKSAMPLETIME_4TRANSITIONS     LPTIM_CFGR_CKFLT_1
N#define LPTIM_CLOCKSAMPLETIME_8TRANSITIONS     LPTIM_CFGR_CKFLT
N/**
N  * @}
N  */
N
N/** @defgroup LPTIM_Clock_Polarity LPTIM Clock Polarity
N  * @{
N  */
N
N#define LPTIM_CLOCKPOLARITY_RISING                ((uint32_t)0x00000000U)
N#define LPTIM_CLOCKPOLARITY_FALLING               LPTIM_CFGR_CKPOL_0
N#define LPTIM_CLOCKPOLARITY_RISING_FALLING        LPTIM_CFGR_CKPOL_1
N/**
N  * @}
N  */
N
N/** @defgroup LPTIM_Trigger_Source LPTIM Trigger Source
N  * @{
N  */
N#define LPTIM_TRIGSOURCE_SOFTWARE               ((uint32_t)0x0000FFFFU)
N#define LPTIM_TRIGSOURCE_0                      ((uint32_t)0x00000000U)
N#define LPTIM_TRIGSOURCE_1                      ((uint32_t)LPTIM_CFGR_TRIGSEL_0)
N#define LPTIM_TRIGSOURCE_2                      LPTIM_CFGR_TRIGSEL_1
N#define LPTIM_TRIGSOURCE_3                      ((uint32_t)LPTIM_CFGR_TRIGSEL_0 | LPTIM_CFGR_TRIGSEL_1)
N#define LPTIM_TRIGSOURCE_4                      LPTIM_CFGR_TRIGSEL_2
N#define LPTIM_TRIGSOURCE_5                      ((uint32_t)LPTIM_CFGR_TRIGSEL_0 | LPTIM_CFGR_TRIGSEL_2)
N/**
N  * @}
N  */
N
N/** @defgroup LPTIM_External_Trigger_Polarity LPTIM External Trigger Polarity
N  * @{
N  */
N#define LPTIM_ACTIVEEDGE_RISING                LPTIM_CFGR_TRIGEN_0
N#define LPTIM_ACTIVEEDGE_FALLING               LPTIM_CFGR_TRIGEN_1
N#define LPTIM_ACTIVEEDGE_RISING_FALLING        LPTIM_CFGR_TRIGEN
N/**
N  * @}
N  */
N
N/** @defgroup LPTIM_Trigger_Sample_Time LPTIM Trigger Sample Time
N  * @{
N  */
N#define LPTIM_TRIGSAMPLETIME_DIRECTTRANSITION  ((uint32_t)0x00000000U)
N#define LPTIM_TRIGSAMPLETIME_2TRANSITIONS      LPTIM_CFGR_TRGFLT_0
N#define LPTIM_TRIGSAMPLETIME_4TRANSITIONS      LPTIM_CFGR_TRGFLT_1
N#define LPTIM_TRIGSAMPLETIME_8TRANSITIONS      LPTIM_CFGR_TRGFLT
N/**
N  * @}
N  */
N
N/** @defgroup LPTIM_Updating_Mode LPTIM Updating Mode
N  * @{
N  */
N
N#define LPTIM_UPDATE_IMMEDIATE                  ((uint32_t)0x00000000U)
N#define LPTIM_UPDATE_ENDOFPERIOD                LPTIM_CFGR_PRELOAD
N/**
N  * @}
N  */
N
N/** @defgroup LPTIM_Counter_Source LPTIM Counter Source
N  * @{
N  */
N
N#define LPTIM_COUNTERSOURCE_INTERNAL            ((uint32_t)0x00000000U)
N#define LPTIM_COUNTERSOURCE_EXTERNAL            LPTIM_CFGR_COUNTMODE
N/**
N  * @}
N  */
N 
N/** @defgroup LPTIM_Flag_Definition LPTIM Flag Definition
N  * @{
N  */
N
N#define LPTIM_FLAG_DOWN                          LPTIM_ISR_DOWN
N#define LPTIM_FLAG_UP                            LPTIM_ISR_UP
N#define LPTIM_FLAG_ARROK                         LPTIM_ISR_ARROK
N#define LPTIM_FLAG_CMPOK                         LPTIM_ISR_CMPOK
N#define LPTIM_FLAG_EXTTRIG                       LPTIM_ISR_EXTTRIG
N#define LPTIM_FLAG_ARRM                          LPTIM_ISR_ARRM
N#define LPTIM_FLAG_CMPM                          LPTIM_ISR_CMPM
N/**
N  * @}
N  */
N
N/** @defgroup LPTIM_Interrupts_Definition LPTIM Interrupts Definition
N  * @{
N  */
N
N#define LPTIM_IT_DOWN                            LPTIM_IER_DOWNIE
N#define LPTIM_IT_UP                              LPTIM_IER_UPIE
N#define LPTIM_IT_ARROK                           LPTIM_IER_ARROKIE
N#define LPTIM_IT_CMPOK                           LPTIM_IER_CMPOKIE
N#define LPTIM_IT_EXTTRIG                         LPTIM_IER_EXTTRIGIE
N#define LPTIM_IT_ARRM                            LPTIM_IER_ARRMIE
N#define LPTIM_IT_CMPM                            LPTIM_IER_CMPMIE
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup LPTIM_Exported_Macros LPTIM Exported Macros
N  * @{
N  */
N
N/** @brief Reset LPTIM handle state
N  * @param  __HANDLE__: LPTIM handle
N  * @retval None
N  */
N#define __HAL_LPTIM_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_LPTIM_STATE_RESET)
N
N/**
N  * @brief  Enable/Disable the LPTIM peripheral.
N  * @param  __HANDLE__: LPTIM handle
N  * @retval None
N  */
N#define __HAL_LPTIM_ENABLE(__HANDLE__)   ((__HANDLE__)->Instance->CR |=  (LPTIM_CR_ENABLE))
N#define __HAL_LPTIM_DISABLE(__HANDLE__)  ((__HANDLE__)->Instance->CR &=  ~(LPTIM_CR_ENABLE))
N
N/**
N  * @brief  Starts the LPTIM peripheral in Continuous or in single mode.
N  * @param  __HANDLE__: DMA handle
N  * @retval None
N  */
N#define __HAL_LPTIM_START_CONTINUOUS(__HANDLE__)  ((__HANDLE__)->Instance->CR |=  LPTIM_CR_CNTSTRT)
N#define __HAL_LPTIM_START_SINGLE(__HANDLE__)      ((__HANDLE__)->Instance->CR |=  LPTIM_CR_SNGSTRT)
N 
N    
N/**
N  * @brief  Writes the passed parameter in the Autoreload register.
N  * @param  __HANDLE__: LPTIM handle
N  * @param  __VALUE__ : Autoreload value
N  * @retval None
N  */
N#define __HAL_LPTIM_AUTORELOAD_SET(__HANDLE__ , __VALUE__)  ((__HANDLE__)->Instance->ARR =  (__VALUE__))
N
N/**
N  * @brief  Writes the passed parameter in the Compare register.
N  * @param  __HANDLE__: LPTIM handle
N  * @param  __VALUE__ : Compare value
N  * @retval None
N  */
N#define __HAL_LPTIM_COMPARE_SET(__HANDLE__ , __VALUE__)     ((__HANDLE__)->Instance->CMP =  (__VALUE__))
N
N/**
N  * @brief  Checks whether the specified LPTIM flag is set or not.
N  * @param  __HANDLE__: LPTIM handle
N  * @param  __FLAG__  : LPTIM flag to check
N  *            This parameter can be a value of:
N  *            @arg LPTIM_FLAG_DOWN    : Counter direction change up Flag.
N  *            @arg LPTIM_FLAG_UP      : Counter direction change down to up Flag.
N  *            @arg LPTIM_FLAG_ARROK   : Autoreload register update OK Flag.
N  *            @arg LPTIM_FLAG_CMPOK   : Compare register update OK Flag.
N  *            @arg LPTIM_FLAG_EXTTRIG : External trigger edge event Flag.
N  *            @arg LPTIM_FLAG_ARRM    : Autoreload match Flag.
N  *            @arg LPTIM_FLAG_CMPM    : Compare match Flag.
N  * @retval The state of the specified flag (SET or RESET).
N  */
N#define __HAL_LPTIM_GET_FLAG(__HANDLE__, __FLAG__)          (((__HANDLE__)->Instance->ISR &(__FLAG__)) == (__FLAG__))
N
N/**
N  * @brief  Clears the specified LPTIM flag.
N  * @param  __HANDLE__: LPTIM handle.
N  * @param  __FLAG__  : LPTIM flag to clear.
N  *            This parameter can be a value of:
N  *            @arg LPTIM_FLAG_DOWN    : Counter direction change up Flag.
N  *            @arg LPTIM_FLAG_UP      : Counter direction change down to up Flag.
N  *            @arg LPTIM_FLAG_ARROK   : Autoreload register update OK Flag.
N  *            @arg LPTIM_FLAG_CMPOK   : Compare register update OK Flag.
N  *            @arg LPTIM_FLAG_EXTTRIG : External trigger edge event Flag.
N  *            @arg LPTIM_FLAG_ARRM    : Autoreload match Flag.
N  *            @arg LPTIM_FLAG_CMPM    : Compare match Flag.
N  * @retval None.
N  */
N#define __HAL_LPTIM_CLEAR_FLAG(__HANDLE__, __FLAG__)         ((__HANDLE__)->Instance->ICR  = (__FLAG__))
N
N/**
N  * @brief  Enable the specified LPTIM interrupt.
N  * @param  __HANDLE__    : LPTIM handle.
N  * @param  __INTERRUPT__ : LPTIM interrupt to set.
N  *            This parameter can be a value of:
N  *            @arg LPTIM_IT_DOWN    : Counter direction change up Interrupt.
N  *            @arg LPTIM_IT_UP      : Counter direction change down to up Interrupt.
N  *            @arg LPTIM_IT_ARROK   : Autoreload register update OK Interrupt.
N  *            @arg LPTIM_IT_CMPOK   : Compare register update OK Interrupt.
N  *            @arg LPTIM_IT_EXTTRIG : External trigger edge event Interrupt.
N  *            @arg LPTIM_IT_ARRM    : Autoreload match Interrupt.
N  *            @arg LPTIM_IT_CMPM    : Compare match Interrupt.
N  * @retval None.
N  */
N#define __HAL_LPTIM_ENABLE_IT(__HANDLE__, __INTERRUPT__)         ((__HANDLE__)->Instance->IER  |= (__INTERRUPT__))
N
N /**
N  * @brief  Disable the specified LPTIM interrupt.
N  * @param  __HANDLE__    : LPTIM handle.
N  * @param  __INTERRUPT__ : LPTIM interrupt to set.
N  *            This parameter can be a value of:
N  *            @arg LPTIM_IT_DOWN    : Counter direction change up Interrupt.
N  *            @arg LPTIM_IT_UP      : Counter direction change down to up Interrupt.
N  *            @arg LPTIM_IT_ARROK   : Autoreload register update OK Interrupt.
N  *            @arg LPTIM_IT_CMPOK   : Compare register update OK Interrupt.
N  *            @arg LPTIM_IT_EXTTRIG : External trigger edge event Interrupt.
N  *            @arg LPTIM_IT_ARRM    : Autoreload match Interrupt.
N  *            @arg LPTIM_IT_CMPM    : Compare match Interrupt.
N  * @retval None.
N  */
N#define __HAL_LPTIM_DISABLE_IT(__HANDLE__, __INTERRUPT__)         ((__HANDLE__)->Instance->IER  &= (~(__INTERRUPT__)))
N
N    /**
N  * @brief  Checks whether the specified LPTIM interrupt is set or not.
N  * @param  __HANDLE__    : LPTIM handle.
N  * @param  __INTERRUPT__ : LPTIM interrupt to check.
N  *            This parameter can be a value of:
N  *            @arg LPTIM_IT_DOWN    : Counter direction change up Interrupt.
N  *            @arg LPTIM_IT_UP      : Counter direction change down to up Interrupt.
N  *            @arg LPTIM_IT_ARROK   : Autoreload register update OK Interrupt.
N  *            @arg LPTIM_IT_CMPOK   : Compare register update OK Interrupt.
N  *            @arg LPTIM_IT_EXTTRIG : External trigger edge event Interrupt.
N  *            @arg LPTIM_IT_ARRM    : Autoreload match Interrupt.
N  *            @arg LPTIM_IT_CMPM    : Compare match Interrupt.
N  * @retval Interrupt status.
N  */
N    
N#define __HAL_LPTIM_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) ((((__HANDLE__)->Instance->IER & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)
N
N/**
N  * @brief  Enable interrupt on the LPTIM Wake-up Timer associated Exti line.
N  * @retval None
N  */
N#define __HAL_LPTIM_WAKEUPTIMER_EXTI_ENABLE_IT()       (EXTI->IMR |= LPTIM_EXTI_LINE_WAKEUPTIMER_EVENT)
N
N/**
N  * @brief  Disable interrupt on the LPTIM Wake-up Timer associated Exti line.
N  * @retval None
N  */
N#define __HAL_LPTIM_WAKEUPTIMER_EXTI_DISABLE_IT()      (EXTI->IMR &= ~(LPTIM_EXTI_LINE_WAKEUPTIMER_EVENT))
N
N/**
N  * @brief  Enable event on the LPTIM Wake-up Timer associated Exti line.
N  * @retval None.
N  */
N#define __HAL_LPTIM_WAKEUPTIMER_EXTI_ENABLE_EVENT()    (EXTI->EMR |= LPTIM_EXTI_LINE_WAKEUPTIMER_EVENT)
N
N/**
N  * @brief  Disable event on the LPTIM Wake-up Timer associated Exti line.
N  * @retval None.
N  */
N#define __HAL_LPTIM_WAKEUPTIMER_EXTI_DISABLE_EVENT()   (EXTI->EMR &= ~(LPTIM_EXTI_LINE_WAKEUPTIMER_EVENT))
N
N/**
N  * @brief  Enable falling edge trigger on the LPTIM Wake-up Timer associated Exti line. 
N  * @retval None.
N  */
N#define __HAL_LPTIM_WAKEUPTIMER_EXTI_ENABLE_FALLING_EDGE()   (EXTI->FTSR |= LPTIM_EXTI_LINE_WAKEUPTIMER_EVENT)
N
N/**
N  * @brief  Disable falling edge trigger on the LPTIM Wake-up Timer associated Exti line.
N  * @retval None.
N  */
N#define __HAL_LPTIM_WAKEUPTIMER_EXTI_DISABLE_FALLING_EDGE()  (EXTI->FTSR &= ~(LPTIM_EXTI_LINE_WAKEUPTIMER_EVENT))
N
N/**
N  * @brief  Enable rising edge trigger on the LPTIM Wake-up Timer associated Exti line.
N  * @retval None.
N  */
N#define __HAL_LPTIM_WAKEUPTIMER_EXTI_ENABLE_RISING_EDGE()    (EXTI->RTSR |= LPTIM_EXTI_LINE_WAKEUPTIMER_EVENT)
N
N/**
N  * @brief  Disable rising edge trigger on the LPTIM Wake-up Timer associated Exti line.
N  * @retval None.
N  */
N#define __HAL_LPTIM_WAKEUPTIMER_EXTI_DISABLE_RISING_EDGE()   (EXTI->RTSR &= ~(LPTIM_EXTI_LINE_WAKEUPTIMER_EVENT))
N
N/**
N  * @brief  Enable rising & falling edge trigger on the LPTIM Wake-up Timer associated Exti line.
N  * @retval None.
N  */
N#define __HAL_LPTIM_WAKEUPTIMER_EXTI_ENABLE_RISING_FALLING_EDGE() do{__HAL_LPTIM_WAKEUPTIMER_EXTI_ENABLE_RISING_EDGE();\
N                                                                     __HAL_LPTIM_WAKEUPTIMER_EXTI_ENABLE_FALLING_EDGE();\
N                                                                    }while(0)
X#define __HAL_LPTIM_WAKEUPTIMER_EXTI_ENABLE_RISING_FALLING_EDGE() do{__HAL_LPTIM_WAKEUPTIMER_EXTI_ENABLE_RISING_EDGE();                                                                     __HAL_LPTIM_WAKEUPTIMER_EXTI_ENABLE_FALLING_EDGE();                                                                    }while(0)
N
N/**
N  * @brief  Disable rising & falling edge trigger on the LPTIM Wake-up Timer associated Exti line.
N  * This parameter can be:
N  * @retval None.
N  */
N#define __HAL_LPTIM_WAKEUPTIMER_EXTI_DISABLE_RISING_FALLING_EDGE() do{__HAL_LPTIM_WAKEUPTIMER_EXTI_DISABLE_RISING_EDGE();\
N                                                                      __HAL_LPTIM_WAKEUPTIMER_EXTI_DISABLE_FALLING_EDGE();\
N                                                                     }while(0)
X#define __HAL_LPTIM_WAKEUPTIMER_EXTI_DISABLE_RISING_FALLING_EDGE() do{__HAL_LPTIM_WAKEUPTIMER_EXTI_DISABLE_RISING_EDGE();                                                                      __HAL_LPTIM_WAKEUPTIMER_EXTI_DISABLE_FALLING_EDGE();                                                                     }while(0)
N
N/**
N  * @brief Check whether the LPTIM Wake-up Timer associated Exti line interrupt flag is set or not.
N  * @retval Line Status.
N  */
N#define __HAL_LPTIM_WAKEUPTIMER_EXTI_GET_FLAG()              (EXTI->PR & LPTIM_EXTI_LINE_WAKEUPTIMER_EVENT)
N
N/**
N  * @brief Clear the LPTIM Wake-up Timer associated Exti line flag.
N  * @retval None.
N  */
N#define __HAL_LPTIM_WAKEUPTIMER_EXTI_CLEAR_FLAG()            (EXTI->PR = LPTIM_EXTI_LINE_WAKEUPTIMER_EVENT)
N
N/**
N  * @brief Generate a Software interrupt on the LPTIM Wake-up Timer associated Exti line.
N  * @retval None.
N  */
N#define __HAL_LPTIM_WAKEUPTIMER_EXTI_GENERATE_SWIT()         (EXTI->SWIER |= LPTIM_EXTI_LINE_WAKEUPTIMER_EVENT)
N
N/**
N  * @}
N  */
N   
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup LPTIM_Exported_Functions LPTIM Exported Functions
N  * @{
N  */
N
N/* Initialization/de-initialization functions  ********************************/
NHAL_StatusTypeDef HAL_LPTIM_Init(LPTIM_HandleTypeDef *hlptim);
NHAL_StatusTypeDef HAL_LPTIM_DeInit(LPTIM_HandleTypeDef *hlptim);
N
N/* MSP functions  *************************************************************/
Nvoid HAL_LPTIM_MspInit(LPTIM_HandleTypeDef *hlptim);
Nvoid HAL_LPTIM_MspDeInit(LPTIM_HandleTypeDef *hlptim);
N
N/* Start/Stop operation functions  *********************************************/
N/* ################################# PWM Mode ################################*/
N/* Blocking mode: Polling */
NHAL_StatusTypeDef HAL_LPTIM_PWM_Start(LPTIM_HandleTypeDef *hlptim, uint32_t Period, uint32_t Pulse);
NHAL_StatusTypeDef HAL_LPTIM_PWM_Stop(LPTIM_HandleTypeDef *hlptim);
N/* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_LPTIM_PWM_Start_IT(LPTIM_HandleTypeDef *hlptim, uint32_t Period, uint32_t Pulse);
NHAL_StatusTypeDef HAL_LPTIM_PWM_Stop_IT(LPTIM_HandleTypeDef *hlptim);
N
N/* ############################# One Pulse Mode ##############################*/
N/* Blocking mode: Polling */
NHAL_StatusTypeDef HAL_LPTIM_OnePulse_Start(LPTIM_HandleTypeDef *hlptim, uint32_t Period, uint32_t Pulse);
NHAL_StatusTypeDef HAL_LPTIM_OnePulse_Stop(LPTIM_HandleTypeDef *hlptim);
N/* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_LPTIM_OnePulse_Start_IT(LPTIM_HandleTypeDef *hlptim, uint32_t Period, uint32_t Pulse);
NHAL_StatusTypeDef HAL_LPTIM_OnePulse_Stop_IT(LPTIM_HandleTypeDef *hlptim);
N
N/* ############################## Set once Mode ##############################*/
N/* Blocking mode: Polling */
NHAL_StatusTypeDef HAL_LPTIM_SetOnce_Start(LPTIM_HandleTypeDef *hlptim, uint32_t Period, uint32_t Pulse);
NHAL_StatusTypeDef HAL_LPTIM_SetOnce_Stop(LPTIM_HandleTypeDef *hlptim);
N/* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_LPTIM_SetOnce_Start_IT(LPTIM_HandleTypeDef *hlptim, uint32_t Period, uint32_t Pulse);
NHAL_StatusTypeDef HAL_LPTIM_SetOnce_Stop_IT(LPTIM_HandleTypeDef *hlptim);
N
N/* ############################### Encoder Mode ##############################*/
N/* Blocking mode: Polling */
NHAL_StatusTypeDef HAL_LPTIM_Encoder_Start(LPTIM_HandleTypeDef *hlptim, uint32_t Period);
NHAL_StatusTypeDef HAL_LPTIM_Encoder_Stop(LPTIM_HandleTypeDef *hlptim);
N/* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_LPTIM_Encoder_Start_IT(LPTIM_HandleTypeDef *hlptim, uint32_t Period);
NHAL_StatusTypeDef HAL_LPTIM_Encoder_Stop_IT(LPTIM_HandleTypeDef *hlptim);
N
N/* ############################# Time out  Mode ##############################*/
N/* Blocking mode: Polling */
NHAL_StatusTypeDef HAL_LPTIM_TimeOut_Start(LPTIM_HandleTypeDef *hlptim, uint32_t Period, uint32_t Timeout);
NHAL_StatusTypeDef HAL_LPTIM_TimeOut_Stop(LPTIM_HandleTypeDef *hlptim);
N/* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_LPTIM_TimeOut_Start_IT(LPTIM_HandleTypeDef *hlptim, uint32_t Period, uint32_t Timeout);
NHAL_StatusTypeDef HAL_LPTIM_TimeOut_Stop_IT(LPTIM_HandleTypeDef *hlptim);
N
N/* ############################## Counter Mode ###############################*/
N/* Blocking mode: Polling */
NHAL_StatusTypeDef HAL_LPTIM_Counter_Start(LPTIM_HandleTypeDef *hlptim, uint32_t Period);
NHAL_StatusTypeDef HAL_LPTIM_Counter_Stop(LPTIM_HandleTypeDef *hlptim);
N/* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_LPTIM_Counter_Start_IT(LPTIM_HandleTypeDef *hlptim, uint32_t Period);
NHAL_StatusTypeDef HAL_LPTIM_Counter_Stop_IT(LPTIM_HandleTypeDef *hlptim);
N
N/* Reading operation functions ************************************************/
Nuint32_t HAL_LPTIM_ReadCounter(LPTIM_HandleTypeDef *hlptim);
Nuint32_t HAL_LPTIM_ReadAutoReload(LPTIM_HandleTypeDef *hlptim);
Nuint32_t HAL_LPTIM_ReadCompare(LPTIM_HandleTypeDef *hlptim);
N
N/* LPTIM IRQ functions  *******************************************************/
Nvoid HAL_LPTIM_IRQHandler(LPTIM_HandleTypeDef *hlptim);
N
N/* CallBack functions  ********************************************************/
Nvoid HAL_LPTIM_CompareMatchCallback(LPTIM_HandleTypeDef *hlptim);
Nvoid HAL_LPTIM_AutoReloadMatchCallback(LPTIM_HandleTypeDef *hlptim);
Nvoid HAL_LPTIM_TriggerCallback(LPTIM_HandleTypeDef *hlptim);
Nvoid HAL_LPTIM_CompareWriteCallback(LPTIM_HandleTypeDef *hlptim);
Nvoid HAL_LPTIM_AutoReloadWriteCallback(LPTIM_HandleTypeDef *hlptim);
Nvoid HAL_LPTIM_DirectionUpCallback(LPTIM_HandleTypeDef *hlptim);
Nvoid HAL_LPTIM_DirectionDownCallback(LPTIM_HandleTypeDef *hlptim);
N
N/* Peripheral State functions  ************************************************/
NHAL_LPTIM_StateTypeDef HAL_LPTIM_GetState(LPTIM_HandleTypeDef *hlptim);
N
N/**
N  * @}
N  */
N  
N/* Private types -------------------------------------------------------------*/
N/** @defgroup LPTIM_Private_Types LPTIM Private Types
N  * @{
N  */
N
N/**
N  * @}
N  */ 
N
N/* Private variables ---------------------------------------------------------*/
N/** @defgroup LPTIM_Private_Variables LPTIM Private Variables
N  * @{
N  */
N  
N/**
N  * @}
N  */ 
N
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup LPTIM_Private_Constants LPTIM Private Constants
N  * @{
N  */
N
N/**
N  * @}
N  */ 
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup LPTIM_Private_Macros LPTIM Private Macros
N  * @{
N  */
N  
N#define IS_LPTIM_CLOCK_SOURCE(__SOURCE__)           (((__SOURCE__) == LPTIM_CLOCKSOURCE_ULPTIM) || \
N                                                     ((__SOURCE__) == LPTIM_CLOCKSOURCE_APBCLOCK_LPOSC))
X#define IS_LPTIM_CLOCK_SOURCE(__SOURCE__)           (((__SOURCE__) == LPTIM_CLOCKSOURCE_ULPTIM) ||                                                      ((__SOURCE__) == LPTIM_CLOCKSOURCE_APBCLOCK_LPOSC))
N													 
N#define IS_LPTIM_CLOCK_PRESCALER(__PRESCALER__)     (((__PRESCALER__) ==  LPTIM_PRESCALER_DIV1  ) || \
N                                                     ((__PRESCALER__) ==  LPTIM_PRESCALER_DIV2  ) || \
N                                                     ((__PRESCALER__) ==  LPTIM_PRESCALER_DIV4  ) || \
N                                                     ((__PRESCALER__) ==  LPTIM_PRESCALER_DIV8  ) || \
N                                                     ((__PRESCALER__) ==  LPTIM_PRESCALER_DIV16 ) || \
N                                                     ((__PRESCALER__) ==  LPTIM_PRESCALER_DIV32 ) || \
N                                                     ((__PRESCALER__) ==  LPTIM_PRESCALER_DIV64 ) || \
N                                                     ((__PRESCALER__) ==  LPTIM_PRESCALER_DIV128))
X#define IS_LPTIM_CLOCK_PRESCALER(__PRESCALER__)     (((__PRESCALER__) ==  LPTIM_PRESCALER_DIV1  ) ||                                                      ((__PRESCALER__) ==  LPTIM_PRESCALER_DIV2  ) ||                                                      ((__PRESCALER__) ==  LPTIM_PRESCALER_DIV4  ) ||                                                      ((__PRESCALER__) ==  LPTIM_PRESCALER_DIV8  ) ||                                                      ((__PRESCALER__) ==  LPTIM_PRESCALER_DIV16 ) ||                                                      ((__PRESCALER__) ==  LPTIM_PRESCALER_DIV32 ) ||                                                      ((__PRESCALER__) ==  LPTIM_PRESCALER_DIV64 ) ||                                                      ((__PRESCALER__) ==  LPTIM_PRESCALER_DIV128))
N#define IS_LPTIM_CLOCK_PRESCALERDIV1(__PRESCALER__) ((__PRESCALER__) ==  LPTIM_PRESCALER_DIV1)													 
N
N#define IS_LPTIM_OUTPUT_POLARITY(__POLARITY__)      (((__POLARITY__) == LPTIM_OUTPUTPOLARITY_LOW ) || \
N                                                     ((__POLARITY__) == LPTIM_OUTPUTPOLARITY_HIGH))
X#define IS_LPTIM_OUTPUT_POLARITY(__POLARITY__)      (((__POLARITY__) == LPTIM_OUTPUTPOLARITY_LOW ) ||                                                      ((__POLARITY__) == LPTIM_OUTPUTPOLARITY_HIGH))
N													 
N#define IS_LPTIM_CLOCK_SAMPLE_TIME(__SAMPLETIME__)  (((__SAMPLETIME__) == LPTIM_CLOCKSAMPLETIME_DIRECTTRANSITION) || \
N                                                     ((__SAMPLETIME__) == LPTIM_CLOCKSAMPLETIME_2TRANSITIONS)     || \
N                                                     ((__SAMPLETIME__) == LPTIM_CLOCKSAMPLETIME_4TRANSITIONS)     || \
N                                                     ((__SAMPLETIME__) == LPTIM_CLOCKSAMPLETIME_8TRANSITIONS))
X#define IS_LPTIM_CLOCK_SAMPLE_TIME(__SAMPLETIME__)  (((__SAMPLETIME__) == LPTIM_CLOCKSAMPLETIME_DIRECTTRANSITION) ||                                                      ((__SAMPLETIME__) == LPTIM_CLOCKSAMPLETIME_2TRANSITIONS)     ||                                                      ((__SAMPLETIME__) == LPTIM_CLOCKSAMPLETIME_4TRANSITIONS)     ||                                                      ((__SAMPLETIME__) == LPTIM_CLOCKSAMPLETIME_8TRANSITIONS))
N
N#define IS_LPTIM_CLOCK_POLARITY(__POLARITY__)       (((__POLARITY__) == LPTIM_CLOCKPOLARITY_RISING)  || \
N                                                     ((__POLARITY__) == LPTIM_CLOCKPOLARITY_FALLING) || \
N                                                     ((__POLARITY__) == LPTIM_CLOCKPOLARITY_RISING_FALLING))
X#define IS_LPTIM_CLOCK_POLARITY(__POLARITY__)       (((__POLARITY__) == LPTIM_CLOCKPOLARITY_RISING)  ||                                                      ((__POLARITY__) == LPTIM_CLOCKPOLARITY_FALLING) ||                                                      ((__POLARITY__) == LPTIM_CLOCKPOLARITY_RISING_FALLING))
N
N#define IS_LPTIM_TRG_SOURCE(__TRIG__)               (((__TRIG__) == LPTIM_TRIGSOURCE_SOFTWARE) || \
N													 ((__TRIG__) == LPTIM_TRIGSOURCE_0) || \
N													 ((__TRIG__) == LPTIM_TRIGSOURCE_1) || \
N													 ((__TRIG__) == LPTIM_TRIGSOURCE_2) || \
N													 ((__TRIG__) == LPTIM_TRIGSOURCE_3) || \
N													 ((__TRIG__) == LPTIM_TRIGSOURCE_4) || \
N													 ((__TRIG__) == LPTIM_TRIGSOURCE_5))
X#define IS_LPTIM_TRG_SOURCE(__TRIG__)               (((__TRIG__) == LPTIM_TRIGSOURCE_SOFTWARE) || 													 ((__TRIG__) == LPTIM_TRIGSOURCE_0) || 													 ((__TRIG__) == LPTIM_TRIGSOURCE_1) || 													 ((__TRIG__) == LPTIM_TRIGSOURCE_2) || 													 ((__TRIG__) == LPTIM_TRIGSOURCE_3) || 													 ((__TRIG__) == LPTIM_TRIGSOURCE_4) || 													 ((__TRIG__) == LPTIM_TRIGSOURCE_5))
N
N#define IS_LPTIM_EXT_TRG_POLARITY(__POLAR__)        (((__POLAR__) == LPTIM_ACTIVEEDGE_RISING         ) || \
N                                                     ((__POLAR__) == LPTIM_ACTIVEEDGE_FALLING        ) || \
N                                                     ((__POLAR__) == LPTIM_ACTIVEEDGE_RISING_FALLING ))
X#define IS_LPTIM_EXT_TRG_POLARITY(__POLAR__)        (((__POLAR__) == LPTIM_ACTIVEEDGE_RISING         ) ||                                                      ((__POLAR__) == LPTIM_ACTIVEEDGE_FALLING        ) ||                                                      ((__POLAR__) == LPTIM_ACTIVEEDGE_RISING_FALLING ))
N
N#define IS_LPTIM_TRIG_SAMPLE_TIME(__SAMPLETIME__)   (((__SAMPLETIME__) == LPTIM_TRIGSAMPLETIME_DIRECTTRANSITION) || \
N                                                     ((__SAMPLETIME__) == LPTIM_TRIGSAMPLETIME_2TRANSITIONS    ) || \
N                                                     ((__SAMPLETIME__) == LPTIM_TRIGSAMPLETIME_4TRANSITIONS    ) || \
N                                                     ((__SAMPLETIME__) == LPTIM_TRIGSAMPLETIME_8TRANSITIONS    ))		
X#define IS_LPTIM_TRIG_SAMPLE_TIME(__SAMPLETIME__)   (((__SAMPLETIME__) == LPTIM_TRIGSAMPLETIME_DIRECTTRANSITION) ||                                                      ((__SAMPLETIME__) == LPTIM_TRIGSAMPLETIME_2TRANSITIONS    ) ||                                                      ((__SAMPLETIME__) == LPTIM_TRIGSAMPLETIME_4TRANSITIONS    ) ||                                                      ((__SAMPLETIME__) == LPTIM_TRIGSAMPLETIME_8TRANSITIONS    ))		
N
N#define IS_LPTIM_UPDATE_MODE(__MODE__)              (((__MODE__) == LPTIM_UPDATE_IMMEDIATE) || \
N                                                     ((__MODE__) == LPTIM_UPDATE_ENDOFPERIOD))
X#define IS_LPTIM_UPDATE_MODE(__MODE__)              (((__MODE__) == LPTIM_UPDATE_IMMEDIATE) ||                                                      ((__MODE__) == LPTIM_UPDATE_ENDOFPERIOD))
N
N#define IS_LPTIM_COUNTER_SOURCE(__SOURCE__)         (((__SOURCE__) == LPTIM_COUNTERSOURCE_INTERNAL) || \
N                                                     ((__SOURCE__) == LPTIM_COUNTERSOURCE_EXTERNAL))
X#define IS_LPTIM_COUNTER_SOURCE(__SOURCE__)         (((__SOURCE__) == LPTIM_COUNTERSOURCE_INTERNAL) ||                                                      ((__SOURCE__) == LPTIM_COUNTERSOURCE_EXTERNAL))
N
N#define IS_LPTIM_AUTORELOAD(__AUTORELOAD__)         ((__AUTORELOAD__) <= 0x0000FFFFU)
N
N#define IS_LPTIM_COMPARE(__COMPARE__)               ((__COMPARE__) <= 0x0000FFFFU)
N  
N#define IS_LPTIM_PERIOD(PERIOD)               ((PERIOD) <= 0x0000FFFFU)
N
N#define IS_LPTIM_PULSE(PULSE)                 ((PULSE) <= 0x0000FFFFU)
N
N/**
N  * @}
N  */ 
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup LPTIM_Private_Functions LPTIM Private Functions
N  * @{
N  */
N  
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_LPTIM_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 335 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_LPTIM_MODULE_ENABLED */
N
N#ifdef HAL_LTDC_MODULE_ENABLED
N #include "stm32f7xx_hal_ltdc.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_ltdc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_ltdc.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of LTDC HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_LTDC_H
N#define __STM32F7xx_HAL_LTDC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#if defined (STM32F746xx) || defined (STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 0L || 1L || 0L || 0L || 0L
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @defgroup LTDC LTDC
N  * @brief LTDC HAL module driver
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup LTDC_Exported_Types LTDC Exported Types
N  * @{
N  */
N#define MAX_LAYER  2
N
N/** 
N  * @brief  LTDC color structure definition
N  */
Ntypedef struct
N{
N  uint8_t Blue;                    /*!< Configures the blue value.
N                                        This parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFF. */
N
N  uint8_t Green;                   /*!< Configures the green value.
N                                        This parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFF. */
N
N  uint8_t Red;                     /*!< Configures the red value. 
N                                        This parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFF. */
N
N  uint8_t Reserved;                /*!< Reserved 0xFF */
N} LTDC_ColorTypeDef;
N
N/** 
N  * @brief  LTDC Init structure definition
N  */
Ntypedef struct
N{
N  uint32_t            HSPolarity;                /*!< configures the horizontal synchronization polarity.
N                                                      This parameter can be one value of @ref LTDC_HS_POLARITY */
N
N  uint32_t            VSPolarity;                /*!< configures the vertical synchronization polarity.
N                                                      This parameter can be one value of @ref LTDC_VS_POLARITY */
N
N  uint32_t            DEPolarity;                /*!< configures the data enable polarity. 
N                                                      This parameter can be one of value of @ref LTDC_DE_POLARITY */
N
N  uint32_t            PCPolarity;                /*!< configures the pixel clock polarity. 
N                                                      This parameter can be one of value of @ref LTDC_PC_POLARITY */
N
N  uint32_t            HorizontalSync;            /*!< configures the number of Horizontal synchronization width.
N                                                      This parameter must be a number between Min_Data = 0x000 and Max_Data = 0xFFF. */
N
N  uint32_t            VerticalSync;              /*!< configures the number of Vertical synchronization height. 
N                                                      This parameter must be a number between Min_Data = 0x000 and Max_Data = 0x7FF. */
N
N  uint32_t            AccumulatedHBP;            /*!< configures the accumulated horizontal back porch width.
N                                                      This parameter must be a number between Min_Data = LTDC_HorizontalSync and Max_Data = 0xFFF. */
N
N  uint32_t            AccumulatedVBP;            /*!< configures the accumulated vertical back porch height.
N                                                      This parameter must be a number between Min_Data = LTDC_VerticalSync and Max_Data = 0x7FF. */
N
N  uint32_t            AccumulatedActiveW;        /*!< configures the accumulated active width. 
N                                                      This parameter must be a number between Min_Data = LTDC_AccumulatedHBP and Max_Data = 0xFFF. */
N
N  uint32_t            AccumulatedActiveH;        /*!< configures the accumulated active height.
N                                                      This parameter must be a number between Min_Data = LTDC_AccumulatedVBP and Max_Data = 0x7FF. */
N
N  uint32_t            TotalWidth;                /*!< configures the total width.
N                                                      This parameter must be a number between Min_Data = LTDC_AccumulatedActiveW and Max_Data = 0xFFF. */
N
N  uint32_t            TotalHeigh;                /*!< configures the total height.
N                                                      This parameter must be a number between Min_Data = LTDC_AccumulatedActiveH and Max_Data = 0x7FF. */
N
N  LTDC_ColorTypeDef   Backcolor;                 /*!< Configures the background color. */
N} LTDC_InitTypeDef;
N
N/** 
N  * @brief  LTDC Layer structure definition
N  */
Ntypedef struct
N{
N  uint32_t WindowX0;                   /*!< Configures the Window Horizontal Start Position.
N                                            This parameter must be a number between Min_Data = 0x000 and Max_Data = 0xFFF. */
N
N  uint32_t WindowX1;                   /*!< Configures the Window Horizontal Stop Position.
N                                            This parameter must be a number between Min_Data = 0x000 and Max_Data = 0xFFF. */
N
N  uint32_t WindowY0;                   /*!< Configures the Window vertical Start Position.
N                                            This parameter must be a number between Min_Data = 0x000 and Max_Data = 0x7FF. */
N
N  uint32_t WindowY1;                   /*!< Configures the Window vertical Stop Position.
N                                            This parameter must be a number between Min_Data = 0x0000 and Max_Data = 0x7FF. */
N
N  uint32_t PixelFormat;                /*!< Specifies the pixel format. 
N                                            This parameter can be one of value of @ref LTDC_Pixelformat */
N
N  uint32_t Alpha;                      /*!< Specifies the constant alpha used for blending.
N                                            This parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFF. */
N
N  uint32_t Alpha0;                     /*!< Configures the default alpha value.
N                                            This parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFF. */
N
N  uint32_t BlendingFactor1;            /*!< Select the blending factor 1. 
N                                            This parameter can be one of value of @ref LTDC_BlendingFactor1 */
N
N  uint32_t BlendingFactor2;            /*!< Select the blending factor 2. 
N                                            This parameter can be one of value of @ref LTDC_BlendingFactor2 */
N
N  uint32_t FBStartAdress;              /*!< Configures the color frame buffer address */
N
N  uint32_t ImageWidth;                 /*!< Configures the color frame buffer line length. 
N                                            This parameter must be a number between Min_Data = 0x0000 and Max_Data = 0x1FFF. */
N
N  uint32_t ImageHeight;                /*!< Specifies the number of line in frame buffer. 
N                                            This parameter must be a number between Min_Data = 0x000 and Max_Data = 0x7FF. */
N
N  LTDC_ColorTypeDef   Backcolor;       /*!< Configures the layer background color. */
N} LTDC_LayerCfgTypeDef;
N
N/** 
N  * @brief  HAL LTDC State structures definition
N  */
Ntypedef enum
N{
N  HAL_LTDC_STATE_RESET             = 0x00U,    /*!< LTDC not yet initialized or disabled */
N  HAL_LTDC_STATE_READY             = 0x01U,    /*!< LTDC initialized and ready for use   */
N  HAL_LTDC_STATE_BUSY              = 0x02U,    /*!< LTDC internal process is ongoing     */
N  HAL_LTDC_STATE_TIMEOUT           = 0x03U,    /*!< LTDC Timeout state                   */
N  HAL_LTDC_STATE_ERROR             = 0x04U     /*!< LTDC state error                     */
N}HAL_LTDC_StateTypeDef;
N
N/** 
N  * @brief  LTDC handle Structure definition
N  */
Ntypedef struct
N{
N  LTDC_TypeDef                *Instance;                /*!< LTDC Register base address                */
N
N  LTDC_InitTypeDef            Init;                     /*!< LTDC parameters                           */
N
N  LTDC_LayerCfgTypeDef        LayerCfg[MAX_LAYER];      /*!< LTDC Layers parameters                    */
X  LTDC_LayerCfgTypeDef        LayerCfg[2];       
N
N  HAL_LockTypeDef             Lock;                     /*!< LTDC Lock                                 */
N
N  __IO HAL_LTDC_StateTypeDef  State;                    /*!< LTDC state                                */
X  volatile HAL_LTDC_StateTypeDef  State;                     
N
N  __IO uint32_t               ErrorCode;                /*!< LTDC Error code                           */
X  volatile uint32_t               ErrorCode;                 
N
N} LTDC_HandleTypeDef;
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup LTDC_Exported_Constants LTDC Exported Constants
N  * @{
N  */
N
N/** @defgroup LTDC_Error_Code LTDC Error Code
N  * @{
N  */
N#define HAL_LTDC_ERROR_NONE      ((uint32_t)0x00000000U)    /*!< LTDC No error             */
N#define HAL_LTDC_ERROR_TE        ((uint32_t)0x00000001U)    /*!< LTDC Transfer error       */
N#define HAL_LTDC_ERROR_FU        ((uint32_t)0x00000002U)    /*!< LTDC FIFO Underrun        */
N#define HAL_LTDC_ERROR_TIMEOUT   ((uint32_t)0x00000020U)    /*!< LTDC Timeout error        */
N/**
N  * @}
N  */
N
N/** @defgroup LTDC_HS_POLARITY LTDC HS POLARITY
N  * @{
N  */
N#define LTDC_HSPOLARITY_AL                ((uint32_t)0x00000000U)                /*!< Horizontal Synchronization is active low. */
N#define LTDC_HSPOLARITY_AH                LTDC_GCR_HSPOL                        /*!< Horizontal Synchronization is active high. */
N/**
N  * @}
N  */
N
N/** @defgroup LTDC_VS_POLARITY LTDC VS POLARITY
N  * @{
N  */
N#define LTDC_VSPOLARITY_AL                ((uint32_t)0x00000000U)                /*!< Vertical Synchronization is active low. */
N#define LTDC_VSPOLARITY_AH                LTDC_GCR_VSPOL                        /*!< Vertical Synchronization is active high. */
N/**
N  * @}
N  */
N  
N/** @defgroup LTDC_DE_POLARITY LTDC DE POLARITY
N  * @{
N  */
N#define LTDC_DEPOLARITY_AL                ((uint32_t)0x00000000U)                /*!< Data Enable, is active low. */
N#define LTDC_DEPOLARITY_AH                LTDC_GCR_DEPOL                        /*!< Data Enable, is active high. */
N/**
N  * @}
N  */
N
N/** @defgroup LTDC_PC_POLARITY LTDC PC POLARITY
N  * @{
N  */
N#define LTDC_PCPOLARITY_IPC               ((uint32_t)0x00000000U)                /*!< input pixel clock. */
N#define LTDC_PCPOLARITY_IIPC              LTDC_GCR_PCPOL                        /*!< inverted input pixel clock. */
N/**
N  * @}
N  */
N
N/** @defgroup LTDC_SYNC LTDC SYNC
N  * @{
N  */
N#define LTDC_HORIZONTALSYNC               (LTDC_SSCR_HSW >> 16)                 /*!< Horizontal synchronization width. */ 
N#define LTDC_VERTICALSYNC                 LTDC_SSCR_VSH                         /*!< Vertical synchronization height. */
N/**
N  * @}
N  */
N
N/** @defgroup LTDC_BACK_COLOR LTDC BACK COLOR
N  * @{
N  */
N#define LTDC_COLOR                   ((uint32_t)0x000000FFU)                     /*!< Color mask */ 
N/**
N  * @}
N  */
N      
N/** @defgroup LTDC_BlendingFactor1 LTDC Blending Factor1
N  * @{
N  */
N#define LTDC_BLENDING_FACTOR1_CA                       ((uint32_t)0x00000400U)   /*!< Blending factor : Cte Alpha */
N#define LTDC_BLENDING_FACTOR1_PAxCA                    ((uint32_t)0x00000600U)   /*!< Blending factor : Cte Alpha x Pixel Alpha*/
N/**
N  * @}
N  */
N
N/** @defgroup LTDC_BlendingFactor2 LTDC Blending Factor2
N  * @{
N  */
N#define LTDC_BLENDING_FACTOR2_CA                       ((uint32_t)0x00000005U)   /*!< Blending factor : Cte Alpha */
N#define LTDC_BLENDING_FACTOR2_PAxCA                    ((uint32_t)0x00000007U)   /*!< Blending factor : Cte Alpha x Pixel Alpha*/
N/**
N  * @}
N  */
N      
N/** @defgroup LTDC_Pixelformat LTDC Pixel format
N  * @{
N  */
N#define LTDC_PIXEL_FORMAT_ARGB8888                  ((uint32_t)0x00000000U)      /*!< ARGB8888 LTDC pixel format */
N#define LTDC_PIXEL_FORMAT_RGB888                    ((uint32_t)0x00000001U)      /*!< RGB888 LTDC pixel format   */
N#define LTDC_PIXEL_FORMAT_RGB565                    ((uint32_t)0x00000002U)      /*!< RGB565 LTDC pixel format   */
N#define LTDC_PIXEL_FORMAT_ARGB1555                  ((uint32_t)0x00000003U)      /*!< ARGB1555 LTDC pixel format */
N#define LTDC_PIXEL_FORMAT_ARGB4444                  ((uint32_t)0x00000004U)      /*!< ARGB4444 LTDC pixel format */
N#define LTDC_PIXEL_FORMAT_L8                        ((uint32_t)0x00000005U)      /*!< L8 LTDC pixel format       */
N#define LTDC_PIXEL_FORMAT_AL44                      ((uint32_t)0x00000006U)      /*!< AL44 LTDC pixel format     */
N#define LTDC_PIXEL_FORMAT_AL88                      ((uint32_t)0x00000007U)      /*!< AL88 LTDC pixel format     */
N/**
N  * @}
N  */
N
N/** @defgroup LTDC_Alpha LTDC Alpha
N  * @{
N  */
N#define LTDC_ALPHA               LTDC_LxCACR_CONSTA                             /*!< LTDC Cte Alpha mask */
N/**
N  * @}
N  */
N
N/** @defgroup LTDC_LAYER_Config LTDC LAYER Config
N  * @{
N  */
N#define LTDC_STOPPOSITION                 (LTDC_LxWHPCR_WHSPPOS >> 16)          /*!< LTDC Layer stop position  */
N#define LTDC_STARTPOSITION                LTDC_LxWHPCR_WHSTPOS                  /*!< LTDC Layer start position */
N
N#define LTDC_COLOR_FRAME_BUFFER           LTDC_LxCFBLR_CFBLL                    /*!< LTDC Layer Line length    */ 
N#define LTDC_LINE_NUMBER                  LTDC_LxCFBLNR_CFBLNBR                 /*!< LTDC Layer Line number    */
N/**
N  * @}
N  */
N
N/** @defgroup LTDC_Interrupts LTDC Interrupts
N  * @{
N  */
N#define LTDC_IT_LI                      LTDC_IER_LIE
N#define LTDC_IT_FU                      LTDC_IER_FUIE
N#define LTDC_IT_TE                      LTDC_IER_TERRIE
N#define LTDC_IT_RR                      LTDC_IER_RRIE
N/**
N  * @}
N  */
N      
N/** @defgroup LTDC_Flag LTDC Flag
N  * @{
N  */
N#define LTDC_FLAG_LI                     LTDC_ISR_LIF
N#define LTDC_FLAG_FU                     LTDC_ISR_FUIF
N#define LTDC_FLAG_TE                     LTDC_ISR_TERRIF
N#define LTDC_FLAG_RR                     LTDC_ISR_RRIF
N/**
N  * @}
N  */
N
N/** @defgroup LTDC_Reload_Type LTDC Reload Type
N  * @{
N  */
N#define LTDC_RELOAD_IMMEDIATE            LTDC_SRCR_IMR       /*!< Immediate Reload */
N#define LTDC_RELOAD_VERTICAL_BLANKING    LTDC_SRCR_VBR       /*!< Vertical Blanking Reload */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */  
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup LTDC_Exported_Macros LTDC Exported Macros
N  * @{
N  */
N
N/** @brief Reset LTDC handle state
N  * @param  __HANDLE__: specifies the LTDC handle.
N  * @retval None
N  */
N#define __HAL_LTDC_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_LTDC_STATE_RESET)
N
N/**
N  * @brief  Enable the LTDC.
N  * @param  __HANDLE__: LTDC handle
N  * @retval None.
N  */
N#define __HAL_LTDC_ENABLE(__HANDLE__)    ((__HANDLE__)->Instance->GCR |= LTDC_GCR_LTDCEN)
N
N/**
N  * @brief  Disable the LTDC.
N  * @param  __HANDLE__: LTDC handle
N  * @retval None.
N  */
N#define __HAL_LTDC_DISABLE(__HANDLE__)   ((__HANDLE__)->Instance->GCR &= ~(LTDC_GCR_LTDCEN))
N
N/**
N  * @brief  Enable the LTDC Layer.
N  * @param  __HANDLE__: LTDC handle
N  * @param  __LAYER__: Specify the layer to be enabled
N  *                     This parameter can be 0 or 1
N  * @retval None.
N  */
N#define __HAL_LTDC_LAYER_ENABLE(__HANDLE__, __LAYER__)  ((LTDC_LAYER((__HANDLE__), (__LAYER__)))->CR |= (uint32_t)LTDC_LxCR_LEN)
N
N/**
N  * @brief  Disable the LTDC Layer.
N  * @param  __HANDLE__: LTDC handle
N  * @param  __LAYER__: Specify the layer to be disabled
N  *                     This parameter can be 0 or 1
N  * @retval None.
N  */
N#define __HAL_LTDC_LAYER_DISABLE(__HANDLE__, __LAYER__) ((LTDC_LAYER((__HANDLE__), (__LAYER__)))->CR &= ~(uint32_t)LTDC_LxCR_LEN)
N
N/**
N  * @brief  Reload  Layer Configuration.
N  * @param  __HANDLE__: LTDC handle
N  * @retval None.
N  */
N#define __HAL_LTDC_RELOAD_CONFIG(__HANDLE__)   ((__HANDLE__)->Instance->SRCR |= LTDC_SRCR_IMR)
N
N/* Interrupt & Flag management */
N/**
N  * @brief  Get the LTDC pending flags.
N  * @param  __HANDLE__: LTDC handle
N  * @param  __FLAG__: Get the specified flag.
N  *          This parameter can be any combination of the following values:
N  *            @arg LTDC_FLAG_LI: Line Interrupt flag 
N  *            @arg LTDC_FLAG_FU: FIFO Underrun Interrupt flag
N  *            @arg LTDC_FLAG_TE: Transfer Error interrupt flag
N  *            @arg LTDC_FLAG_RR: Register Reload Interrupt Flag 
N  * @retval The state of FLAG (SET or RESET).
N  */
N#define __HAL_LTDC_GET_FLAG(__HANDLE__, __FLAG__) ((__HANDLE__)->Instance->ISR & (__FLAG__))
N
N/**
N  * @brief  Clears the LTDC pending flags.
N  * @param  __HANDLE__: LTDC handle
N  * @param  __FLAG__: specifies the flag to clear.
N  *          This parameter can be any combination of the following values:
N  *            @arg LTDC_FLAG_LI: Line Interrupt flag 
N  *            @arg LTDC_FLAG_FU: FIFO Underrun Interrupt flag
N  *            @arg LTDC_FLAG_TE: Transfer Error interrupt flag
N  *            @arg LTDC_FLAG_RR: Register Reload Interrupt Flag 
N  * @retval None
N  */
N#define __HAL_LTDC_CLEAR_FLAG(__HANDLE__, __FLAG__) ((__HANDLE__)->Instance->ICR = (__FLAG__))
N
N/**
N  * @brief  Enables the specified LTDC interrupts.
N  * @param  __HANDLE__: LTDC handle
N  * @param __INTERRUPT__: specifies the LTDC interrupt sources to be enabled. 
N  *          This parameter can be any combination of the following values:
N  *            @arg LTDC_IT_LI: Line Interrupt flag 
N  *            @arg LTDC_IT_FU: FIFO Underrun Interrupt flag
N  *            @arg LTDC_IT_TE: Transfer Error interrupt flag
N  *            @arg LTDC_IT_RR: Register Reload Interrupt Flag
N  * @retval None
N  */
N#define __HAL_LTDC_ENABLE_IT(__HANDLE__, __INTERRUPT__) ((__HANDLE__)->Instance->IER |= (__INTERRUPT__))
N
N/**
N  * @brief  Disables the specified LTDC interrupts.
N  * @param  __HANDLE__: LTDC handle
N  * @param __INTERRUPT__: specifies the LTDC interrupt sources to be disabled. 
N  *          This parameter can be any combination of the following values:
N  *            @arg LTDC_IT_LI: Line Interrupt flag 
N  *            @arg LTDC_IT_FU: FIFO Underrun Interrupt flag
N  *            @arg LTDC_IT_TE: Transfer Error interrupt flag
N  *            @arg LTDC_IT_RR: Register Reload Interrupt Flag
N  * @retval None
N  */
N#define __HAL_LTDC_DISABLE_IT(__HANDLE__, __INTERRUPT__) ((__HANDLE__)->Instance->IER &= ~(__INTERRUPT__))
N
N/**
N  * @brief  Checks whether the specified LTDC interrupt has occurred or not.
N  * @param  __HANDLE__: LTDC handle
N  * @param  __INTERRUPT__: specifies the LTDC interrupt source to check.
N  *          This parameter can be one of the following values:
N  *            @arg LTDC_IT_LI: Line Interrupt flag 
N  *            @arg LTDC_IT_FU: FIFO Underrun Interrupt flag
N  *            @arg LTDC_IT_TE: Transfer Error interrupt flag
N  *            @arg LTDC_IT_RR: Register Reload Interrupt Flag
N  * @retval The state of INTERRUPT (SET or RESET).
N  */
N#define __HAL_LTDC_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) ((__HANDLE__)->Instance->ISR & (__INTERRUPT__))
N/**
N  * @}
N  */
N
N#if defined (STM32F769xx) || defined (STM32F779xx)  
X#if 0L || 0L  
S/* Include LTDC HAL Extension module */
S#include "stm32f7xx_hal_ltdc_ex.h"
N#endif /* STM32F769xx) | STM32F779xx */
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup LTDC_Exported_Functions
N  * @{
N  */
N/** @addtogroup LTDC_Exported_Functions_Group1
N  * @{
N  */
N/* Initialization and de-initialization functions *****************************/
NHAL_StatusTypeDef HAL_LTDC_Init(LTDC_HandleTypeDef *hltdc);
NHAL_StatusTypeDef HAL_LTDC_DeInit(LTDC_HandleTypeDef *hltdc);
Nvoid HAL_LTDC_MspInit(LTDC_HandleTypeDef* hltdc);
Nvoid HAL_LTDC_MspDeInit(LTDC_HandleTypeDef* hltdc);
Nvoid HAL_LTDC_ErrorCallback(LTDC_HandleTypeDef *hltdc);
Nvoid HAL_LTDC_LineEvenCallback(LTDC_HandleTypeDef *hltdc);
Xvoid HAL_LTDC_LineEventCallback(LTDC_HandleTypeDef *hltdc);
Nvoid HAL_LTDC_ReloadEventCallback(LTDC_HandleTypeDef *hltdc);
N/**
N  * @}
N  */
N
N/** @addtogroup LTDC_Exported_Functions_Group2
N  * @{
N  */
N/* IO operation functions *****************************************************/
Nvoid  HAL_LTDC_IRQHandler(LTDC_HandleTypeDef *hltdc);
N/**
N  * @}
N  */
N
N/** @addtogroup LTDC_Exported_Functions_Group3
N  * @{
N  */
N/* Peripheral Control functions ***********************************************/
NHAL_StatusTypeDef HAL_LTDC_ConfigLayer(LTDC_HandleTypeDef *hltdc, LTDC_LayerCfgTypeDef *pLayerCfg, uint32_t LayerIdx);
NHAL_StatusTypeDef HAL_LTDC_SetWindowSize(LTDC_HandleTypeDef *hltdc, uint32_t XSize, uint32_t YSize, uint32_t LayerIdx);
NHAL_StatusTypeDef HAL_LTDC_SetWindowPosition(LTDC_HandleTypeDef *hltdc, uint32_t X0, uint32_t Y0, uint32_t LayerIdx);
NHAL_StatusTypeDef HAL_LTDC_SetPixelFormat(LTDC_HandleTypeDef *hltdc, uint32_t Pixelformat, uint32_t LayerIdx);
NHAL_StatusTypeDef HAL_LTDC_SetAlpha(LTDC_HandleTypeDef *hltdc, uint32_t Alpha, uint32_t LayerIdx);
NHAL_StatusTypeDef HAL_LTDC_SetAddress(LTDC_HandleTypeDef *hltdc, uint32_t Address, uint32_t LayerIdx);
NHAL_StatusTypeDef HAL_LTDC_SetPitch(LTDC_HandleTypeDef *hltdc, uint32_t LinePitchInPixels, uint32_t LayerIdx);
NHAL_StatusTypeDef HAL_LTDC_ConfigColorKeying(LTDC_HandleTypeDef *hltdc, uint32_t RGBValue, uint32_t LayerIdx);
NHAL_StatusTypeDef HAL_LTDC_ConfigCLUT(LTDC_HandleTypeDef *hltdc, uint32_t *pCLUT, uint32_t CLUTSize, uint32_t LayerIdx);
NHAL_StatusTypeDef HAL_LTDC_EnableColorKeying(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx);
NHAL_StatusTypeDef HAL_LTDC_DisableColorKeying(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx);
NHAL_StatusTypeDef HAL_LTDC_EnableCLUT(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx);
NHAL_StatusTypeDef HAL_LTDC_DisableCLUT(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx);
NHAL_StatusTypeDef HAL_LTDC_ProgramLineEvent(LTDC_HandleTypeDef *hltdc, uint32_t Line);
NHAL_StatusTypeDef HAL_LTDC_EnableDither(LTDC_HandleTypeDef *hltdc);
NHAL_StatusTypeDef HAL_LTDC_DisableDither(LTDC_HandleTypeDef *hltdc);
NHAL_StatusTypeDef HAL_LTDC_Reload(LTDC_HandleTypeDef *hltdc, uint32_t ReloadType);
NHAL_StatusTypeDef HAL_LTDC_ConfigLayer_NoReload(LTDC_HandleTypeDef *hltdc, LTDC_LayerCfgTypeDef *pLayerCfg, uint32_t LayerIdx);
NHAL_StatusTypeDef HAL_LTDC_SetWindowSize_NoReload(LTDC_HandleTypeDef *hltdc, uint32_t XSize, uint32_t YSize, uint32_t LayerIdx);
NHAL_StatusTypeDef HAL_LTDC_SetWindowPosition_NoReload(LTDC_HandleTypeDef *hltdc, uint32_t X0, uint32_t Y0, uint32_t LayerIdx);
NHAL_StatusTypeDef HAL_LTDC_SetPixelFormat_NoReload(LTDC_HandleTypeDef *hltdc, uint32_t Pixelformat, uint32_t LayerIdx);
NHAL_StatusTypeDef HAL_LTDC_SetAlpha_NoReload(LTDC_HandleTypeDef *hltdc, uint32_t Alpha, uint32_t LayerIdx);
NHAL_StatusTypeDef HAL_LTDC_SetAddress_NoReload(LTDC_HandleTypeDef *hltdc, uint32_t Address, uint32_t LayerIdx);
NHAL_StatusTypeDef HAL_LTDC_SetPitch_NoReload(LTDC_HandleTypeDef *hltdc, uint32_t LinePitchInPixels, uint32_t LayerIdx);
NHAL_StatusTypeDef HAL_LTDC_ConfigColorKeying_NoReload(LTDC_HandleTypeDef *hltdc, uint32_t RGBValue, uint32_t LayerIdx);
NHAL_StatusTypeDef HAL_LTDC_EnableColorKeying_NoReload(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx);
NHAL_StatusTypeDef HAL_LTDC_DisableColorKeying_NoReload(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx);
NHAL_StatusTypeDef HAL_LTDC_EnableCLUT_NoReload(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx);
NHAL_StatusTypeDef HAL_LTDC_DisableCLUT_NoReload(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx);
N
N/**
N  * @}
N  */
N
N/** @addtogroup LTDC_Exported_Functions_Group4
N  * @{
N  */
N/* Peripheral State functions *************************************************/
NHAL_LTDC_StateTypeDef HAL_LTDC_GetState(LTDC_HandleTypeDef *hltdc);
Nuint32_t              HAL_LTDC_GetError(LTDC_HandleTypeDef *hltdc);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/* Private types -------------------------------------------------------------*/
N/** @defgroup LTDC_Private_Types LTDC Private Types
N  * @{
N  */
N
N/**
N  * @}
N  */ 
N
N/* Private variables ---------------------------------------------------------*/
N/** @defgroup LTDC_Private_Variables LTDC Private Variables
N  * @{
N  */
N
N/**
N  * @}
N  */ 
N
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup LTDC_Private_Constants LTDC Private Constants
N  * @{
N  */
N
N/**
N  * @}
N  */ 
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup LTDC_Private_Macros LTDC Private Macros
N  * @{
N  */
N#define LTDC_LAYER(__HANDLE__, __LAYER__)         ((LTDC_Layer_TypeDef *)((uint32_t)(((uint32_t)((__HANDLE__)->Instance)) + 0x84 + (0x80*(__LAYER__)))))
N#define IS_LTDC_LAYER(LAYER)                      ((LAYER) <= MAX_LAYER)
N#define IS_LTDC_HSPOL(HSPOL)                      (((HSPOL) == LTDC_HSPOLARITY_AL) || \
N                                                   ((HSPOL) == LTDC_HSPOLARITY_AH))
X#define IS_LTDC_HSPOL(HSPOL)                      (((HSPOL) == LTDC_HSPOLARITY_AL) ||                                                    ((HSPOL) == LTDC_HSPOLARITY_AH))
N#define IS_LTDC_VSPOL(VSPOL)                      (((VSPOL) == LTDC_VSPOLARITY_AL) || \
N                                                   ((VSPOL) == LTDC_VSPOLARITY_AH))
X#define IS_LTDC_VSPOL(VSPOL)                      (((VSPOL) == LTDC_VSPOLARITY_AL) ||                                                    ((VSPOL) == LTDC_VSPOLARITY_AH))
N#define IS_LTDC_DEPOL(DEPOL)                      (((DEPOL) ==  LTDC_DEPOLARITY_AL) || \
N                                                   ((DEPOL) ==  LTDC_DEPOLARITY_AH))
X#define IS_LTDC_DEPOL(DEPOL)                      (((DEPOL) ==  LTDC_DEPOLARITY_AL) ||                                                    ((DEPOL) ==  LTDC_DEPOLARITY_AH))
N#define IS_LTDC_PCPOL(PCPOL)                      (((PCPOL) ==  LTDC_PCPOLARITY_IPC) || \
N                                                   ((PCPOL) ==  LTDC_PCPOLARITY_IIPC))
X#define IS_LTDC_PCPOL(PCPOL)                      (((PCPOL) ==  LTDC_PCPOLARITY_IPC) ||                                                    ((PCPOL) ==  LTDC_PCPOLARITY_IIPC))
N#define IS_LTDC_HSYNC(HSYNC)                      ((HSYNC)  <= LTDC_HORIZONTALSYNC)
N#define IS_LTDC_VSYNC(VSYNC)                      ((VSYNC)  <= LTDC_VERTICALSYNC)
N#define IS_LTDC_AHBP(AHBP)                        ((AHBP)   <= LTDC_HORIZONTALSYNC)
N#define IS_LTDC_AVBP(AVBP)                        ((AVBP)   <= LTDC_VERTICALSYNC)
N#define IS_LTDC_AAW(AAW)                          ((AAW)    <= LTDC_HORIZONTALSYNC)
N#define IS_LTDC_AAH(AAH)                          ((AAH)    <= LTDC_VERTICALSYNC)
N#define IS_LTDC_TOTALW(TOTALW)                    ((TOTALW) <= LTDC_HORIZONTALSYNC)
N#define IS_LTDC_TOTALH(TOTALH)                    ((TOTALH) <= LTDC_VERTICALSYNC)
N#define IS_LTDC_BLUEVALUE(BBLUE)                  ((BBLUE)  <= LTDC_COLOR)
N#define IS_LTDC_GREENVALUE(BGREEN)                ((BGREEN) <= LTDC_COLOR)
N#define IS_LTDC_REDVALUE(BRED)                    ((BRED)   <= LTDC_COLOR)
N#define IS_LTDC_BLENDING_FACTOR1(BlendingFactor1) (((BlendingFactor1) == LTDC_BLENDING_FACTOR1_CA) || \
N                                                   ((BlendingFactor1) == LTDC_BLENDING_FACTOR1_PAxCA))
X#define IS_LTDC_BLENDING_FACTOR1(BlendingFactor1) (((BlendingFactor1) == LTDC_BLENDING_FACTOR1_CA) ||                                                    ((BlendingFactor1) == LTDC_BLENDING_FACTOR1_PAxCA))
N#define IS_LTDC_BLENDING_FACTOR2(BlendingFactor2) (((BlendingFactor2) == LTDC_BLENDING_FACTOR2_CA) || \
N                                                   ((BlendingFactor2) == LTDC_BLENDING_FACTOR2_PAxCA))
X#define IS_LTDC_BLENDING_FACTOR2(BlendingFactor2) (((BlendingFactor2) == LTDC_BLENDING_FACTOR2_CA) ||                                                    ((BlendingFactor2) == LTDC_BLENDING_FACTOR2_PAxCA))
N#define IS_LTDC_PIXEL_FORMAT(Pixelformat)         (((Pixelformat) == LTDC_PIXEL_FORMAT_ARGB8888) || ((Pixelformat) == LTDC_PIXEL_FORMAT_RGB888)   || \
N                                                   ((Pixelformat) == LTDC_PIXEL_FORMAT_RGB565)   || ((Pixelformat) == LTDC_PIXEL_FORMAT_ARGB1555) || \
N                                                   ((Pixelformat) == LTDC_PIXEL_FORMAT_ARGB4444) || ((Pixelformat) == LTDC_PIXEL_FORMAT_L8)       || \
N                                                   ((Pixelformat) == LTDC_PIXEL_FORMAT_AL44)     || ((Pixelformat) == LTDC_PIXEL_FORMAT_AL88))
X#define IS_LTDC_PIXEL_FORMAT(Pixelformat)         (((Pixelformat) == LTDC_PIXEL_FORMAT_ARGB8888) || ((Pixelformat) == LTDC_PIXEL_FORMAT_RGB888)   ||                                                    ((Pixelformat) == LTDC_PIXEL_FORMAT_RGB565)   || ((Pixelformat) == LTDC_PIXEL_FORMAT_ARGB1555) ||                                                    ((Pixelformat) == LTDC_PIXEL_FORMAT_ARGB4444) || ((Pixelformat) == LTDC_PIXEL_FORMAT_L8)       ||                                                    ((Pixelformat) == LTDC_PIXEL_FORMAT_AL44)     || ((Pixelformat) == LTDC_PIXEL_FORMAT_AL88))
N#define IS_LTDC_ALPHA(ALPHA)                      ((ALPHA) <= LTDC_ALPHA)
N#define IS_LTDC_HCONFIGST(HCONFIGST)              ((HCONFIGST) <= LTDC_STARTPOSITION)
N#define IS_LTDC_HCONFIGSP(HCONFIGSP)              ((HCONFIGSP) <= LTDC_STOPPOSITION)
N#define IS_LTDC_VCONFIGST(VCONFIGST)              ((VCONFIGST) <= LTDC_STARTPOSITION)
N#define IS_LTDC_VCONFIGSP(VCONFIGSP)              ((VCONFIGSP) <= LTDC_STOPPOSITION)
N#define IS_LTDC_CFBP(CFBP)                        ((CFBP) <= LTDC_COLOR_FRAME_BUFFER)
N#define IS_LTDC_CFBLL(CFBLL)                      ((CFBLL) <= LTDC_COLOR_FRAME_BUFFER)
N#define IS_LTDC_CFBLNBR(CFBLNBR)                  ((CFBLNBR) <= LTDC_LINE_NUMBER)
N#define IS_LTDC_LIPOS(LIPOS)                      ((LIPOS) <= 0x7FF)
N#define IS_LTDC_RELAOD(RELOADTYPE)                (((RELOADTYPE) == LTDC_RELOAD_IMMEDIATE) || ((RELOADTYPE) == LTDC_SRCR_VBR))
N/**
N  * @}
N  */ 
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup LTDC_Private_Functions LTDC Private Functions
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_LTDC_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 339 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_LTDC_MODULE_ENABLED */
N
N#ifdef HAL_PWR_MODULE_ENABLED
N #include "stm32f7xx_hal_pwr.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_pwr.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_pwr.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of PWR HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_PWR_H
N#define __STM32F7xx_HAL_PWR_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup PWR
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N
N/** @defgroup PWR_Exported_Types PWR Exported Types
N  * @{
N  */
N   
N/**
N  * @brief  PWR PVD configuration structure definition
N  */
Ntypedef struct
N{
N  uint32_t PVDLevel;   /*!< PVDLevel: Specifies the PVD detection level.
N                            This parameter can be a value of @ref PWR_PVD_detection_level */
N
N  uint32_t Mode;      /*!< Mode: Specifies the operating mode for the selected pins.
N                           This parameter can be a value of @ref PWR_PVD_Mode */
N}PWR_PVDTypeDef;
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup PWR_Exported_Constants PWR Exported Constants
N  * @{
N  */
N
N/** @defgroup PWR_PVD_detection_level PWR PVD detection level
N  * @{
N  */ 
N#define PWR_PVDLEVEL_0                  PWR_CR1_PLS_LEV0
N#define PWR_PVDLEVEL_1                  PWR_CR1_PLS_LEV1
N#define PWR_PVDLEVEL_2                  PWR_CR1_PLS_LEV2
N#define PWR_PVDLEVEL_3                  PWR_CR1_PLS_LEV3
N#define PWR_PVDLEVEL_4                  PWR_CR1_PLS_LEV4
N#define PWR_PVDLEVEL_5                  PWR_CR1_PLS_LEV5
N#define PWR_PVDLEVEL_6                  PWR_CR1_PLS_LEV6
N#define PWR_PVDLEVEL_7                  PWR_CR1_PLS_LEV7/* External input analog voltage 
N                                                          (Compare internally to VREFINT) */
N
N/**
N  * @}
N  */   
N 
N/** @defgroup PWR_PVD_Mode PWR PVD Mode
N  * @{
N  */
N#define PWR_PVD_MODE_NORMAL                 ((uint32_t)0x00000000U)   /*!< basic mode is used */
N#define PWR_PVD_MODE_IT_RISING              ((uint32_t)0x00010001U)   /*!< External Interrupt Mode with Rising edge trigger detection */
N#define PWR_PVD_MODE_IT_FALLING             ((uint32_t)0x00010002U)   /*!< External Interrupt Mode with Falling edge trigger detection */
N#define PWR_PVD_MODE_IT_RISING_FALLING      ((uint32_t)0x00010003U)   /*!< External Interrupt Mode with Rising/Falling edge trigger detection */
N#define PWR_PVD_MODE_EVENT_RISING           ((uint32_t)0x00020001U)   /*!< Event Mode with Rising edge trigger detection */
N#define PWR_PVD_MODE_EVENT_FALLING          ((uint32_t)0x00020002U)   /*!< Event Mode with Falling edge trigger detection */
N#define PWR_PVD_MODE_EVENT_RISING_FALLING   ((uint32_t)0x00020003U)   /*!< Event Mode with Rising/Falling edge trigger detection */
N/**
N  * @}
N  */
N
N/** @defgroup PWR_Regulator_state_in_STOP_mode PWR Regulator state in SLEEP/STOP mode
N  * @{
N  */
N#define PWR_MAINREGULATOR_ON                        ((uint32_t)0x00000000U)
N#define PWR_LOWPOWERREGULATOR_ON                    PWR_CR1_LPDS
N/**
N  * @}
N  */
N    
N/** @defgroup PWR_SLEEP_mode_entry PWR SLEEP mode entry
N  * @{
N  */
N#define PWR_SLEEPENTRY_WFI              ((uint8_t)0x01U)
N#define PWR_SLEEPENTRY_WFE              ((uint8_t)0x02U)
N/**
N  * @}
N  */
N
N/** @defgroup PWR_STOP_mode_entry PWR STOP mode entry
N  * @{
N  */
N#define PWR_STOPENTRY_WFI               ((uint8_t)0x01U)
N#define PWR_STOPENTRY_WFE               ((uint8_t)0x02U)
N/**
N  * @}
N  */
N
N/** @defgroup PWR_Regulator_Voltage_Scale PWR Regulator Voltage Scale
N  * @{
N  */
N#define PWR_REGULATOR_VOLTAGE_SCALE1         PWR_CR1_VOS
N#define PWR_REGULATOR_VOLTAGE_SCALE2         PWR_CR1_VOS_1
N#define PWR_REGULATOR_VOLTAGE_SCALE3         PWR_CR1_VOS_0
N/**
N  * @}
N  */
N
N/** @defgroup PWR_Flag PWR Flag
N  * @{
N  */
N#define PWR_FLAG_WU                     PWR_CSR1_WUIF
N#define PWR_FLAG_SB                     PWR_CSR1_SBF
N#define PWR_FLAG_PVDO                   PWR_CSR1_PVDO
N#define PWR_FLAG_BRR                    PWR_CSR1_BRR
N#define PWR_FLAG_VOSRDY                 PWR_CSR1_VOSRDY
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N  
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup PWR_Exported_Macro PWR Exported Macro
N  * @{
N  */
N
N/** @brief  macros configure the main internal regulator output voltage.
N  * @param  __REGULATOR__: specifies the regulator output voltage to achieve
N  *         a tradeoff between performance and power consumption when the device does
N  *         not operate at the maximum frequency (refer to the datasheets for more details).
N  *          This parameter can be one of the following values:
N  *            @arg PWR_REGULATOR_VOLTAGE_SCALE1: Regulator voltage output Scale 1 mode
N  *            @arg PWR_REGULATOR_VOLTAGE_SCALE2: Regulator voltage output Scale 2 mode
N  *            @arg PWR_REGULATOR_VOLTAGE_SCALE3: Regulator voltage output Scale 3 mode
N  * @retval None
N  */
N#define __HAL_PWR_VOLTAGESCALING_CONFIG(__REGULATOR__) do {                                                     \
N                                                            __IO uint32_t tmpreg;                               \
N                                                            MODIFY_REG(PWR->CR1, PWR_CR1_VOS, (__REGULATOR__)); \
N                                                            /* Delay after an RCC peripheral clock enabling */  \
N                                                            tmpreg = READ_BIT(PWR->CR1, PWR_CR1_VOS);           \
N                                                            UNUSED(tmpreg);                                     \
N				                                                	} while(0)
X#define __HAL_PWR_VOLTAGESCALING_CONFIG(__REGULATOR__) do {                                                                                                                 __IO uint32_t tmpreg;                                                                                           MODIFY_REG(PWR->CR1, PWR_CR1_VOS, (__REGULATOR__));                                                                                                                            tmpreg = READ_BIT(PWR->CR1, PWR_CR1_VOS);                                                                       UNUSED(tmpreg);                                     				                                                	} while(0)
N
N/** @brief  Check PWR flag is set or not.
N  * @param  __FLAG__: specifies the flag to check.
N  *           This parameter can be one of the following values:
N  *            @arg PWR_FLAG_WU: Wake Up flag. This flag indicates that a wakeup event 
N  *                  was received on the internal wakeup line in standby mode (RTC alarm (Alarm A or Alarm B),
N  *                  RTC Tamper event, RTC TimeStamp event or RTC Wakeup)).
N  *            @arg PWR_FLAG_SB: StandBy flag. This flag indicates that the system was
N  *                  resumed from StandBy mode.    
N  *            @arg PWR_FLAG_PVDO: PVD Output. This flag is valid only if PVD is enabled 
N  *                  by the HAL_PWR_EnablePVD() function. The PVD is stopped by Standby mode 
N  *                  For this reason, this bit is equal to 0 after Standby or reset
N  *                  until the PVDE bit is set.
N  *            @arg PWR_FLAG_BRR: Backup regulator ready flag. This bit is not reset 
N  *                  when the device wakes up from Standby mode or by a system reset 
N  *                  or power reset.  
N  *            @arg PWR_FLAG_VOSRDY: This flag indicates that the Regulator voltage 
N  *                 scaling output selection is ready.
N  * @retval The new state of __FLAG__ (TRUE or FALSE).
N  */
N#define __HAL_PWR_GET_FLAG(__FLAG__) ((PWR->CSR1 & (__FLAG__)) == (__FLAG__))
N
N/** @brief  Clear the PWR's pending flags.
N  * @param  __FLAG__: specifies the flag to clear.
N  *          This parameter can be one of the following values:
N  *            @arg PWR_FLAG_SB: StandBy flag
N  */
N#define __HAL_PWR_CLEAR_FLAG(__FLAG__) (PWR->CR1 |=  (__FLAG__) << 2)
N
N/**
N  * @brief Enable the PVD Exti Line 16.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_ENABLE_IT()   (EXTI->IMR |= (PWR_EXTI_LINE_PVD))
N
N/**
N  * @brief Disable the PVD EXTI Line 16.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_DISABLE_IT()  (EXTI->IMR &= ~(PWR_EXTI_LINE_PVD))
N
N/**
N  * @brief Enable event on PVD Exti Line 16.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_ENABLE_EVENT()   (EXTI->EMR |= (PWR_EXTI_LINE_PVD))
N
N/**
N  * @brief Disable event on PVD Exti Line 16.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_DISABLE_EVENT()  (EXTI->EMR &= ~(PWR_EXTI_LINE_PVD))
N
N/**
N  * @brief Enable the PVD Extended Interrupt Rising Trigger.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE()   SET_BIT(EXTI->RTSR, PWR_EXTI_LINE_PVD)
N
N/**
N  * @brief Disable the PVD Extended Interrupt Rising Trigger.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE()  CLEAR_BIT(EXTI->RTSR, PWR_EXTI_LINE_PVD)
N
N/**
N  * @brief Enable the PVD Extended Interrupt Falling Trigger.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE()   SET_BIT(EXTI->FTSR, PWR_EXTI_LINE_PVD)
N
N
N/**
N  * @brief Disable the PVD Extended Interrupt Falling Trigger.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE()  CLEAR_BIT(EXTI->FTSR, PWR_EXTI_LINE_PVD)
N
N
N/**
N  * @brief  PVD EXTI line configuration: set rising & falling edge trigger.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_ENABLE_RISING_FALLING_EDGE()   __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();__HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();
N
N/**
N  * @brief Disable the PVD Extended Interrupt Rising & Falling Trigger.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_DISABLE_RISING_FALLING_EDGE()  __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();__HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE();
N
N/**
N  * @brief checks whether the specified PVD Exti interrupt flag is set or not.
N  * @retval EXTI PVD Line Status.
N  */
N#define __HAL_PWR_PVD_EXTI_GET_FLAG()  (EXTI->PR & (PWR_EXTI_LINE_PVD))
N
N/**
N  * @brief Clear the PVD Exti flag.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_CLEAR_FLAG()  (EXTI->PR = (PWR_EXTI_LINE_PVD))
N
N/**
N  * @brief  Generates a Software interrupt on PVD EXTI line.
N  * @retval None
N  */
N#define __HAL_PWR_PVD_EXTI_GENERATE_SWIT() (EXTI->SWIER |= (PWR_EXTI_LINE_PVD))
N
N/**
N  * @}
N  */
N
N/* Include PWR HAL Extension module */
N#include "stm32f7xx_hal_pwr_ex.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_pwr_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_pwr_ex.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of PWR HAL Extension module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_PWR_EX_H
N#define __STM32F7xx_HAL_PWR_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup PWREx
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/ 
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup PWREx_Exported_Constants PWREx Exported Constants
N  * @{
N  */
N/** @defgroup PWREx_WakeUp_Pins PWREx Wake Up Pins
N  * @{
N  */
N#define PWR_WAKEUP_PIN1                PWR_CSR2_EWUP1
N#define PWR_WAKEUP_PIN2                PWR_CSR2_EWUP2
N#define PWR_WAKEUP_PIN3                PWR_CSR2_EWUP3
N#define PWR_WAKEUP_PIN4                PWR_CSR2_EWUP4
N#define PWR_WAKEUP_PIN5                PWR_CSR2_EWUP5
N#define PWR_WAKEUP_PIN6                PWR_CSR2_EWUP6
N#define PWR_WAKEUP_PIN1_HIGH           PWR_CSR2_EWUP1
N#define PWR_WAKEUP_PIN2_HIGH           PWR_CSR2_EWUP2
N#define PWR_WAKEUP_PIN3_HIGH           PWR_CSR2_EWUP3
N#define PWR_WAKEUP_PIN4_HIGH           PWR_CSR2_EWUP4
N#define PWR_WAKEUP_PIN5_HIGH           PWR_CSR2_EWUP5
N#define PWR_WAKEUP_PIN6_HIGH           PWR_CSR2_EWUP6
N#define PWR_WAKEUP_PIN1_LOW            (uint32_t)((PWR_CR2_WUPP1<<6) | PWR_CSR2_EWUP1)
N#define PWR_WAKEUP_PIN2_LOW            (uint32_t)((PWR_CR2_WUPP2<<6) | PWR_CSR2_EWUP2)
N#define PWR_WAKEUP_PIN3_LOW            (uint32_t)((PWR_CR2_WUPP3<<6) | PWR_CSR2_EWUP3)
N#define PWR_WAKEUP_PIN4_LOW            (uint32_t)((PWR_CR2_WUPP4<<6) | PWR_CSR2_EWUP4)
N#define PWR_WAKEUP_PIN5_LOW            (uint32_t)((PWR_CR2_WUPP5<<6) | PWR_CSR2_EWUP5)
N#define PWR_WAKEUP_PIN6_LOW            (uint32_t)((PWR_CR2_WUPP6<<6) | PWR_CSR2_EWUP6)
N
N/**
N  * @}
N  */
N	
N/** @defgroup PWREx_Regulator_state_in_UnderDrive_mode PWREx Regulator state in UnderDrive mode
N  * @{
N  */
N#define PWR_MAINREGULATOR_UNDERDRIVE_ON                       PWR_CR1_MRUDS
N#define PWR_LOWPOWERREGULATOR_UNDERDRIVE_ON                   ((uint32_t)(PWR_CR1_LPDS | PWR_CR1_LPUDS))
N/**
N  * @}
N  */ 
N  
N/** @defgroup PWREx_Over_Under_Drive_Flag PWREx Over Under Drive Flag
N  * @{
N  */
N#define PWR_FLAG_ODRDY                  PWR_CSR1_ODRDY
N#define PWR_FLAG_ODSWRDY                PWR_CSR1_ODSWRDY
N#define PWR_FLAG_UDRDY                  PWR_CSR1_UDRDY
N/**
N  * @}
N  */
N	
N/** @defgroup PWREx_Wakeup_Pins_Flag PWREx Wake Up Pin Flags
N  * @{
N  */
N#define PWR_WAKEUP_PIN_FLAG1            PWR_CSR2_WUPF1
N#define PWR_WAKEUP_PIN_FLAG2            PWR_CSR2_WUPF2
N#define PWR_WAKEUP_PIN_FLAG3            PWR_CSR2_WUPF3
N#define PWR_WAKEUP_PIN_FLAG4            PWR_CSR2_WUPF4
N#define PWR_WAKEUP_PIN_FLAG5            PWR_CSR2_WUPF5
N#define PWR_WAKEUP_PIN_FLAG6            PWR_CSR2_WUPF6
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N  
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup PWREx_Exported_Macro PWREx Exported Macro
N  *  @{
N  */
N/** @brief Macros to enable or disable the Over drive mode.
N  */
N#define __HAL_PWR_OVERDRIVE_ENABLE() (PWR->CR1 |= (uint32_t)PWR_CR1_ODEN)
N#define __HAL_PWR_OVERDRIVE_DISABLE() (PWR->CR1 &= (uint32_t)(~PWR_CR1_ODEN))
N
N/** @brief Macros to enable or disable the Over drive switching.
N  */
N#define __HAL_PWR_OVERDRIVESWITCHING_ENABLE() (PWR->CR1 |= (uint32_t)PWR_CR1_ODSWEN)
N#define __HAL_PWR_OVERDRIVESWITCHING_DISABLE() (PWR->CR1 &= (uint32_t)(~PWR_CR1_ODSWEN))
N
N/** @brief Macros to enable or disable the Under drive mode.
N  * @note  This mode is enabled only with STOP low power mode.
N  *        In this mode, the 1.2V domain is preserved in reduced leakage mode. This 
N  *        mode is only available when the main regulator or the low power regulator 
N  *        is in low voltage mode.      
N  * @note  If the Under-drive mode was enabled, it is automatically disabled after 
N  *        exiting Stop mode. 
N  *        When the voltage regulator operates in Under-drive mode, an additional  
N  *        startup delay is induced when waking up from Stop mode.
N  */
N#define __HAL_PWR_UNDERDRIVE_ENABLE() (PWR->CR1 |= (uint32_t)PWR_CR1_UDEN)
N#define __HAL_PWR_UNDERDRIVE_DISABLE() (PWR->CR1 &= (uint32_t)(~PWR_CR1_UDEN))
N
N/** @brief  Check PWR flag is set or not.
N  * @param  __FLAG__: specifies the flag to check.
N  *         This parameter can be one of the following values:
N  *            @arg PWR_FLAG_ODRDY: This flag indicates that the Over-drive mode
N  *                                 is ready 
N  *            @arg PWR_FLAG_ODSWRDY: This flag indicates that the Over-drive mode
N  *                                   switching is ready  
N  *            @arg PWR_FLAG_UDRDY: This flag indicates that the Under-drive mode
N  *                                 is enabled in Stop mode
N  * @retval The new state of __FLAG__ (TRUE or FALSE).
N  */
N#define __HAL_PWR_GET_ODRUDR_FLAG(__FLAG__) ((PWR->CSR1 & (__FLAG__)) == (__FLAG__))
N
N/** @brief Clear the Under-Drive Ready flag.
N  */
N#define __HAL_PWR_CLEAR_ODRUDR_FLAG() (PWR->CSR1 |= PWR_FLAG_UDRDY)
N
N/** @brief  Check Wake Up flag is set or not.
N  * @param  __WUFLAG__: specifies the Wake Up flag to check.
N  *          This parameter can be one of the following values:
N  *            @arg PWR_WAKEUP_PIN_FLAG1: Wakeup Pin Flag for PA0
N  *            @arg PWR_WAKEUP_PIN_FLAG2: Wakeup Pin Flag for PA2
N  *            @arg PWR_WAKEUP_PIN_FLAG3: Wakeup Pin Flag for PC1
N  *            @arg PWR_WAKEUP_PIN_FLAG4: Wakeup Pin Flag for PC13
N  *            @arg PWR_WAKEUP_PIN_FLAG5: Wakeup Pin Flag for PI8
N  *            @arg PWR_WAKEUP_PIN_FLAG6: Wakeup Pin Flag for PI11          
N  */
N#define __HAL_PWR_GET_WAKEUP_FLAG(__WUFLAG__) (PWR->CSR2 & (__WUFLAG__))
N
N/** @brief  Clear the WakeUp pins flags.
N  * @param  __WUFLAG__: specifies the Wake Up pin flag to clear.
N  *          This parameter can be one of the following values:
N  *            @arg PWR_WAKEUP_PIN_FLAG1: Wakeup Pin Flag for PA0
N  *            @arg PWR_WAKEUP_PIN_FLAG2: Wakeup Pin Flag for PA2
N  *            @arg PWR_WAKEUP_PIN_FLAG3: Wakeup Pin Flag for PC1
N  *            @arg PWR_WAKEUP_PIN_FLAG4: Wakeup Pin Flag for PC13
N  *            @arg PWR_WAKEUP_PIN_FLAG5: Wakeup Pin Flag for PI8
N  *            @arg PWR_WAKEUP_PIN_FLAG6: Wakeup Pin Flag for PI11          
N  */
N#define __HAL_PWR_CLEAR_WAKEUP_FLAG(__WUFLAG__) (PWR->CR2 |=  (__WUFLAG__))
N/**
N  * @}
N  */
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup PWREx_Exported_Functions PWREx Exported Functions
N  *  @{
N  */
N 
N/** @addtogroup PWREx_Exported_Functions_Group1
N  * @{
N  */
Nuint32_t HAL_PWREx_GetVoltageRange(void);
NHAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling);
N
Nvoid HAL_PWREx_EnableFlashPowerDown(void);
Nvoid HAL_PWREx_DisableFlashPowerDown(void); 
NHAL_StatusTypeDef HAL_PWREx_EnableBkUpReg(void);
NHAL_StatusTypeDef HAL_PWREx_DisableBkUpReg(void); 
N
Nvoid HAL_PWREx_EnableMainRegulatorLowVoltage(void);
Nvoid HAL_PWREx_DisableMainRegulatorLowVoltage(void);
Nvoid HAL_PWREx_EnableLowRegulatorLowVoltage(void);
Nvoid HAL_PWREx_DisableLowRegulatorLowVoltage(void);
N
NHAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void);
NHAL_StatusTypeDef HAL_PWREx_DisableOverDrive(void);
NHAL_StatusTypeDef HAL_PWREx_EnterUnderDriveSTOPMode(uint32_t Regulator, uint8_t STOPEntry);
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup PWREx_Private_Macros PWREx Private Macros
N  * @{
N  */
N
N/** @defgroup PWREx_IS_PWR_Definitions PWREx Private macros to check input parameters
N  * @{
N  */
N#define IS_PWR_REGULATOR_UNDERDRIVE(REGULATOR) (((REGULATOR) == PWR_MAINREGULATOR_UNDERDRIVE_ON) || \
N                                                ((REGULATOR) == PWR_LOWPOWERREGULATOR_UNDERDRIVE_ON))
X#define IS_PWR_REGULATOR_UNDERDRIVE(REGULATOR) (((REGULATOR) == PWR_MAINREGULATOR_UNDERDRIVE_ON) ||                                                 ((REGULATOR) == PWR_LOWPOWERREGULATOR_UNDERDRIVE_ON))
N#define IS_PWR_WAKEUP_PIN(__PIN__)         (((__PIN__) == PWR_WAKEUP_PIN1)       || \
N                                            ((__PIN__) == PWR_WAKEUP_PIN2)       || \
N                                            ((__PIN__) == PWR_WAKEUP_PIN3)       || \
N                                            ((__PIN__) == PWR_WAKEUP_PIN4)       || \
N                                            ((__PIN__) == PWR_WAKEUP_PIN5)       || \
N                                            ((__PIN__) == PWR_WAKEUP_PIN6)  		 || \
N                                            ((__PIN__) == PWR_WAKEUP_PIN1_HIGH)  || \
N                                            ((__PIN__) == PWR_WAKEUP_PIN2_HIGH)  || \
N                                            ((__PIN__) == PWR_WAKEUP_PIN3_HIGH)  || \
N                                            ((__PIN__) == PWR_WAKEUP_PIN4_HIGH)  || \
N                                            ((__PIN__) == PWR_WAKEUP_PIN5_HIGH)  || \
N                                            ((__PIN__) == PWR_WAKEUP_PIN6_HIGH)  || \
N                                            ((__PIN__) == PWR_WAKEUP_PIN1_LOW)   || \
N                                            ((__PIN__) == PWR_WAKEUP_PIN2_LOW)   || \
N                                            ((__PIN__) == PWR_WAKEUP_PIN3_LOW)   || \
N                                            ((__PIN__) == PWR_WAKEUP_PIN4_LOW)   || \
N                                            ((__PIN__) == PWR_WAKEUP_PIN5_LOW)	 || \
N                                            ((__PIN__) == PWR_WAKEUP_PIN6_LOW))
X#define IS_PWR_WAKEUP_PIN(__PIN__)         (((__PIN__) == PWR_WAKEUP_PIN1)       ||                                             ((__PIN__) == PWR_WAKEUP_PIN2)       ||                                             ((__PIN__) == PWR_WAKEUP_PIN3)       ||                                             ((__PIN__) == PWR_WAKEUP_PIN4)       ||                                             ((__PIN__) == PWR_WAKEUP_PIN5)       ||                                             ((__PIN__) == PWR_WAKEUP_PIN6)  		 ||                                             ((__PIN__) == PWR_WAKEUP_PIN1_HIGH)  ||                                             ((__PIN__) == PWR_WAKEUP_PIN2_HIGH)  ||                                             ((__PIN__) == PWR_WAKEUP_PIN3_HIGH)  ||                                             ((__PIN__) == PWR_WAKEUP_PIN4_HIGH)  ||                                             ((__PIN__) == PWR_WAKEUP_PIN5_HIGH)  ||                                             ((__PIN__) == PWR_WAKEUP_PIN6_HIGH)  ||                                             ((__PIN__) == PWR_WAKEUP_PIN1_LOW)   ||                                             ((__PIN__) == PWR_WAKEUP_PIN2_LOW)   ||                                             ((__PIN__) == PWR_WAKEUP_PIN3_LOW)   ||                                             ((__PIN__) == PWR_WAKEUP_PIN4_LOW)   ||                                             ((__PIN__) == PWR_WAKEUP_PIN5_LOW)	 ||                                             ((__PIN__) == PWR_WAKEUP_PIN6_LOW))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N  
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif /* __STM32F7xx_HAL_PWR_EX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 305 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_pwr.h" 2
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup PWR_Exported_Functions PWR Exported Functions
N  * @{
N  */
N  
N/** @addtogroup PWR_Exported_Functions_Group1 Initialization and de-initialization functions 
N  * @{
N  */
N/* Initialization and de-initialization functions *****************************/
Nvoid HAL_PWR_DeInit(void);
Nvoid HAL_PWR_EnableBkUpAccess(void);
Nvoid HAL_PWR_DisableBkUpAccess(void);
N/**
N  * @}
N  */
N
N/** @addtogroup PWR_Exported_Functions_Group2 Peripheral Control functions 
N  * @{
N  */
N/* Peripheral Control functions  **********************************************/
N/* PVD configuration */
Nvoid HAL_PWR_ConfigPVD(PWR_PVDTypeDef *sConfigPVD);
Nvoid HAL_PWR_EnablePVD(void);
Nvoid HAL_PWR_DisablePVD(void);
N
N/* WakeUp pins configuration */
Nvoid HAL_PWR_EnableWakeUpPin(uint32_t WakeUpPinPolarity);
Nvoid HAL_PWR_DisableWakeUpPin(uint32_t WakeUpPinx);
N
N/* Low Power modes entry */
Nvoid HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry);
Nvoid HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry);
Nvoid HAL_PWR_EnterSTANDBYMode(void);
N
N/* Power PVD IRQ Handler */
Nvoid HAL_PWR_PVD_IRQHandler(void);
Nvoid HAL_PWR_PVDCallback(void);
N
N/* Cortex System Control functions  *******************************************/
Nvoid HAL_PWR_EnableSleepOnExit(void);
Nvoid HAL_PWR_DisableSleepOnExit(void);
Nvoid HAL_PWR_EnableSEVOnPend(void);
Nvoid HAL_PWR_DisableSEVOnPend(void);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup PWR_Private_Constants PWR Private Constants
N  * @{
N  */
N
N/** @defgroup PWR_PVD_EXTI_Line PWR PVD EXTI Line
N  * @{
N  */
N#define PWR_EXTI_LINE_PVD  ((uint32_t)EXTI_IMR_IM16)  /*!< External interrupt line 16 Connected to the PVD EXTI Line */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup PWR_Private_Macros PWR Private Macros
N  * @{
N  */
N
N/** @defgroup PWR_IS_PWR_Definitions PWR Private macros to check input parameters
N  * @{
N  */
N#define IS_PWR_PVD_LEVEL(LEVEL) (((LEVEL) == PWR_PVDLEVEL_0) || ((LEVEL) == PWR_PVDLEVEL_1)|| \
N                                 ((LEVEL) == PWR_PVDLEVEL_2) || ((LEVEL) == PWR_PVDLEVEL_3)|| \
N                                 ((LEVEL) == PWR_PVDLEVEL_4) || ((LEVEL) == PWR_PVDLEVEL_5)|| \
N                                 ((LEVEL) == PWR_PVDLEVEL_6) || ((LEVEL) == PWR_PVDLEVEL_7))
X#define IS_PWR_PVD_LEVEL(LEVEL) (((LEVEL) == PWR_PVDLEVEL_0) || ((LEVEL) == PWR_PVDLEVEL_1)||                                  ((LEVEL) == PWR_PVDLEVEL_2) || ((LEVEL) == PWR_PVDLEVEL_3)||                                  ((LEVEL) == PWR_PVDLEVEL_4) || ((LEVEL) == PWR_PVDLEVEL_5)||                                  ((LEVEL) == PWR_PVDLEVEL_6) || ((LEVEL) == PWR_PVDLEVEL_7))
N#define IS_PWR_PVD_MODE(MODE) (((MODE) == PWR_PVD_MODE_IT_RISING)|| ((MODE) == PWR_PVD_MODE_IT_FALLING) || \
N                              ((MODE) == PWR_PVD_MODE_IT_RISING_FALLING) || ((MODE) == PWR_PVD_MODE_EVENT_RISING) || \
N                              ((MODE) == PWR_PVD_MODE_EVENT_FALLING) || ((MODE) == PWR_PVD_MODE_EVENT_RISING_FALLING) || \
N                              ((MODE) == PWR_PVD_MODE_NORMAL))
X#define IS_PWR_PVD_MODE(MODE) (((MODE) == PWR_PVD_MODE_IT_RISING)|| ((MODE) == PWR_PVD_MODE_IT_FALLING) ||                               ((MODE) == PWR_PVD_MODE_IT_RISING_FALLING) || ((MODE) == PWR_PVD_MODE_EVENT_RISING) ||                               ((MODE) == PWR_PVD_MODE_EVENT_FALLING) || ((MODE) == PWR_PVD_MODE_EVENT_RISING_FALLING) ||                               ((MODE) == PWR_PVD_MODE_NORMAL))
N#define IS_PWR_REGULATOR(REGULATOR) (((REGULATOR) == PWR_MAINREGULATOR_ON) || \
N                                     ((REGULATOR) == PWR_LOWPOWERREGULATOR_ON))
X#define IS_PWR_REGULATOR(REGULATOR) (((REGULATOR) == PWR_MAINREGULATOR_ON) ||                                      ((REGULATOR) == PWR_LOWPOWERREGULATOR_ON))
N#define IS_PWR_SLEEP_ENTRY(ENTRY) (((ENTRY) == PWR_SLEEPENTRY_WFI) || ((ENTRY) == PWR_SLEEPENTRY_WFE))
N#define IS_PWR_STOP_ENTRY(ENTRY) (((ENTRY) == PWR_STOPENTRY_WFI) || ((ENTRY) == PWR_STOPENTRY_WFE))
N#define IS_PWR_REGULATOR_VOLTAGE(VOLTAGE) (((VOLTAGE) == PWR_REGULATOR_VOLTAGE_SCALE1) || \
N                                           ((VOLTAGE) == PWR_REGULATOR_VOLTAGE_SCALE2) || \
N                                           ((VOLTAGE) == PWR_REGULATOR_VOLTAGE_SCALE3))
X#define IS_PWR_REGULATOR_VOLTAGE(VOLTAGE) (((VOLTAGE) == PWR_REGULATOR_VOLTAGE_SCALE1) ||                                            ((VOLTAGE) == PWR_REGULATOR_VOLTAGE_SCALE2) ||                                            ((VOLTAGE) == PWR_REGULATOR_VOLTAGE_SCALE3))
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N  
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif /* __STM32F7xx_HAL_PWR_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 343 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_PWR_MODULE_ENABLED */
N
N#ifdef HAL_QSPI_MODULE_ENABLED
N #include "stm32f7xx_hal_qspi.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_qspi.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_qspi.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of QSPI HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************  
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_QSPI_H
N#define __STM32F7xx_HAL_QSPI_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup QSPI
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/ 
N/** @defgroup QSPI_Exported_Types QSPI Exported Types
N  * @{
N  */
N  
N/** 
N  * @brief  QSPI Init structure definition  
N  */
N
Ntypedef struct
N{
N  uint32_t ClockPrescaler;     /* Specifies the prescaler factor for generating clock based on the AHB clock.
N                                  This parameter can be a number between 0 and 255 */ 
N                                  
N  uint32_t FifoThreshold;      /* Specifies the threshold number of bytes in the FIFO (used only in indirect mode)
N                                  This parameter can be a value between 1 and 32 */
N                                  
N  uint32_t SampleShifting;     /* Specifies the Sample Shift. The data is sampled 1/2 clock cycle delay later to 
N                                  take in account external signal delays. (It should be QSPI_SAMPLE_SHIFTING_NONE in DDR mode)
N                                  This parameter can be a value of @ref QSPI_SampleShifting */
N                                  
N  uint32_t FlashSize;          /* Specifies the Flash Size. FlashSize+1 is effectively the number of address bits 
N                                  required to address the flash memory. The flash capacity can be up to 4GB 
N                                  (addressed using 32 bits) in indirect mode, but the addressable space in 
N                                  memory-mapped mode is limited to 256MB
N                                  This parameter can be a number between 0 and 31 */
N                                  
N  uint32_t ChipSelectHighTime; /* Specifies the Chip Select High Time. ChipSelectHighTime+1 defines the minimum number 
N                                  of clock cycles which the chip select must remain high between commands.
N                                  This parameter can be a value of @ref QSPI_ChipSelectHighTime */ 
N                                    
N  uint32_t ClockMode;          /* Specifies the Clock Mode. It indicates the level that clock takes between commands.
N                                  This parameter can be a value of @ref QSPI_ClockMode */
N                                 
N  uint32_t FlashID;            /* Specifies the Flash which will be used,
N                                  This parameter can be a value of @ref QSPI_Flash_Select */
N                                 
N  uint32_t DualFlash;          /* Specifies the Dual Flash Mode State
N                                  This parameter can be a value of @ref QSPI_DualFlash_Mode */                                               
N}QSPI_InitTypeDef;
N
N/** 
N  * @brief HAL QSPI State structures definition  
N  */ 
Ntypedef enum
N{
N  HAL_QSPI_STATE_RESET             = 0x00U,    /*!< Peripheral not initialized                            */
N  HAL_QSPI_STATE_READY             = 0x01U,    /*!< Peripheral initialized and ready for use              */
N  HAL_QSPI_STATE_BUSY              = 0x02U,    /*!< Peripheral in indirect mode and busy                  */ 
N  HAL_QSPI_STATE_BUSY_INDIRECT_TX  = 0x12U,    /*!< Peripheral in indirect mode with transmission ongoing */ 
N  HAL_QSPI_STATE_BUSY_INDIRECT_RX  = 0x22U,    /*!< Peripheral in indirect mode with reception ongoing    */
N  HAL_QSPI_STATE_BUSY_AUTO_POLLING = 0x42U,    /*!< Peripheral in auto polling mode ongoing               */
N  HAL_QSPI_STATE_BUSY_MEM_MAPPED   = 0x82U,    /*!< Peripheral in memory mapped mode ongoing              */
N  HAL_QSPI_STATE_ABORT             = 0x08U,    /*!< Peripheral with abort request ongoing                 */
N  HAL_QSPI_STATE_ERROR             = 0x04U     /*!< Peripheral in error                                   */
N}HAL_QSPI_StateTypeDef;
N
N/** 
N  * @brief  QSPI Handle Structure definition  
N  */  
Ntypedef struct
N{
N  QUADSPI_TypeDef            *Instance;        /* QSPI registers base address        */
N  QSPI_InitTypeDef           Init;             /* QSPI communication parameters      */
N  uint8_t                    *pTxBuffPtr;      /* Pointer to QSPI Tx transfer Buffer */
N  __IO uint16_t              TxXferSize;       /* QSPI Tx Transfer size              */
X  volatile uint16_t              TxXferSize;        
N  __IO uint16_t              TxXferCount;      /* QSPI Tx Transfer Counter           */
X  volatile uint16_t              TxXferCount;       
N  uint8_t                    *pRxBuffPtr;      /* Pointer to QSPI Rx transfer Buffer */
N  __IO uint16_t              RxXferSize;       /* QSPI Rx Transfer size              */
X  volatile uint16_t              RxXferSize;        
N  __IO uint16_t              RxXferCount;      /* QSPI Rx Transfer Counter           */
X  volatile uint16_t              RxXferCount;       
N  DMA_HandleTypeDef          *hdma;            /* QSPI Rx/Tx DMA Handle parameters   */
N  __IO HAL_LockTypeDef       Lock;             /* Locking object                     */
X  volatile HAL_LockTypeDef       Lock;              
N  __IO HAL_QSPI_StateTypeDef State;            /* QSPI communication state           */
X  volatile HAL_QSPI_StateTypeDef State;             
N  __IO uint32_t              ErrorCode;        /* QSPI Error code                    */
X  volatile uint32_t              ErrorCode;         
N  uint32_t                   Timeout;          /* Timeout for the QSPI memory access */ 
N}QSPI_HandleTypeDef;
N
N/** 
N  * @brief  QSPI Command structure definition  
N  */
Ntypedef struct
N{
N  uint32_t Instruction;        /* Specifies the Instruction to be sent
N                                  This parameter can be a value (8-bit) between 0x00 and 0xFF */
N  uint32_t Address;            /* Specifies the Address to be sent (Size from 1 to 4 bytes according AddressSize)
N                                  This parameter can be a value (32-bits) between 0x0 and 0xFFFFFFFF */
N  uint32_t AlternateBytes;     /* Specifies the Alternate Bytes to be sent (Size from 1 to 4 bytes according AlternateBytesSize)
N                                  This parameter can be a value (32-bits) between 0x0 and 0xFFFFFFFF */
N  uint32_t AddressSize;        /* Specifies the Address Size
N                                  This parameter can be a value of @ref QSPI_AddressSize */
N  uint32_t AlternateBytesSize; /* Specifies the Alternate Bytes Size
N                                  This parameter can be a value of @ref QSPI_AlternateBytesSize */
N  uint32_t DummyCycles;        /* Specifies the Number of Dummy Cycles.
N                                  This parameter can be a number between 0 and 31 */
N  uint32_t InstructionMode;    /* Specifies the Instruction Mode
N                                  This parameter can be a value of @ref QSPI_InstructionMode */
N  uint32_t AddressMode;        /* Specifies the Address Mode
N                                  This parameter can be a value of @ref QSPI_AddressMode */
N  uint32_t AlternateByteMode;  /* Specifies the Alternate Bytes Mode
N                                  This parameter can be a value of @ref QSPI_AlternateBytesMode */
N  uint32_t DataMode;           /* Specifies the Data Mode (used for dummy cycles and data phases)
N                                  This parameter can be a value of @ref QSPI_DataMode */
N  uint32_t NbData;             /* Specifies the number of data to transfer. 
N                                  This parameter can be any value between 0 and 0xFFFFFFFF (0 means undefined length 
N                                  until end of memory)*/
N  uint32_t DdrMode;            /* Specifies the double data rate mode for address, alternate byte and data phase
N                                  This parameter can be a value of @ref QSPI_DdrMode */
N  uint32_t DdrHoldHalfCycle;   /* Specifies the DDR hold half cycle. It delays the data output by one half of 
N                                  system clock in DDR mode.
N                                  This parameter can be a value of @ref QSPI_DdrHoldHalfCycle */
N  uint32_t SIOOMode;          /* Specifies the send instruction only once mode
N                                  This parameter can be a value of @ref QSPI_SIOOMode */
N}QSPI_CommandTypeDef;
N
N/** 
N  * @brief  QSPI Auto Polling mode configuration structure definition  
N  */
Ntypedef struct
N{
N  uint32_t Match;              /* Specifies the value to be compared with the masked status register to get a match.
N                                  This parameter can be any value between 0 and 0xFFFFFFFF */
N  uint32_t Mask;               /* Specifies the mask to be applied to the status bytes received. 
N                                  This parameter can be any value between 0 and 0xFFFFFFFF */
N  uint32_t Interval;           /* Specifies the number of clock cycles between two read during automatic polling phases.
N                                  This parameter can be any value between 0 and 0xFFFF */
N  uint32_t StatusBytesSize;    /* Specifies the size of the status bytes received.
N                                  This parameter can be any value between 1 and 4 */
N  uint32_t MatchMode;          /* Specifies the method used for determining a match.
N                                  This parameter can be a value of @ref QSPI_MatchMode */
N  uint32_t AutomaticStop;      /* Specifies if automatic polling is stopped after a match.
N                                  This parameter can be a value of @ref QSPI_AutomaticStop */
N}QSPI_AutoPollingTypeDef;
N                           
N/** 
N  * @brief  QSPI Memory Mapped mode configuration structure definition  
N  */
Ntypedef struct
N{
N  uint32_t TimeOutPeriod;      /* Specifies the number of clock to wait when the FIFO is full before to release the chip select.
N                                  This parameter can be any value between 0 and 0xFFFF */
N  uint32_t TimeOutActivation;  /* Specifies if the time out counter is enabled to release the chip select. 
N                                  This parameter can be a value of @ref QSPI_TimeOutActivation */
N}QSPI_MemoryMappedTypeDef;                                     
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup QSPI_Exported_Constants QSPI Exported Constants
N  * @{
N  */
N/** @defgroup QSPI_ErrorCode QSPI Error Code
N  * @{
N  */ 
N#define HAL_QSPI_ERROR_NONE            ((uint32_t)0x00000000U) /*!< No error           */
N#define HAL_QSPI_ERROR_TIMEOUT         ((uint32_t)0x00000001U) /*!< Timeout error      */
N#define HAL_QSPI_ERROR_TRANSFER        ((uint32_t)0x00000002U) /*!< Transfer error     */
N#define HAL_QSPI_ERROR_DMA             ((uint32_t)0x00000004U) /*!< DMA transfer error */
N#define HAL_QSPI_ERROR_INVALID_PARAM   ((uint32_t)0x00000008U) /*!< Invalid parameters error */
N/**
N  * @}
N  */ 
N  
N/** @defgroup QSPI_SampleShifting QSPI Sample Shifting
N  * @{
N  */
N#define QSPI_SAMPLE_SHIFTING_NONE           ((uint32_t)0x00000000U)        /*!<No clock cycle shift to sample data*/
N#define QSPI_SAMPLE_SHIFTING_HALFCYCLE      ((uint32_t)QUADSPI_CR_SSHIFT) /*!<1/2 clock cycle shift to sample data*/
N/**
N  * @}
N  */ 
N
N/** @defgroup QSPI_ChipSelectHighTime QSPI Chip Select High Time
N  * @{
N  */
N#define QSPI_CS_HIGH_TIME_1_CYCLE           ((uint32_t)0x00000000U)                              /*!<nCS stay high for at least 1 clock cycle between commands*/
N#define QSPI_CS_HIGH_TIME_2_CYCLE           ((uint32_t)QUADSPI_DCR_CSHT_0)                      /*!<nCS stay high for at least 2 clock cycles between commands*/
N#define QSPI_CS_HIGH_TIME_3_CYCLE           ((uint32_t)QUADSPI_DCR_CSHT_1)                      /*!<nCS stay high for at least 3 clock cycles between commands*/
N#define QSPI_CS_HIGH_TIME_4_CYCLE           ((uint32_t)QUADSPI_DCR_CSHT_0 | QUADSPI_DCR_CSHT_1) /*!<nCS stay high for at least 4 clock cycles between commands*/
N#define QSPI_CS_HIGH_TIME_5_CYCLE           ((uint32_t)QUADSPI_DCR_CSHT_2)                      /*!<nCS stay high for at least 5 clock cycles between commands*/
N#define QSPI_CS_HIGH_TIME_6_CYCLE           ((uint32_t)QUADSPI_DCR_CSHT_2 | QUADSPI_DCR_CSHT_0) /*!<nCS stay high for at least 6 clock cycles between commands*/
N#define QSPI_CS_HIGH_TIME_7_CYCLE           ((uint32_t)QUADSPI_DCR_CSHT_2 | QUADSPI_DCR_CSHT_1) /*!<nCS stay high for at least 7 clock cycles between commands*/
N#define QSPI_CS_HIGH_TIME_8_CYCLE           ((uint32_t)QUADSPI_DCR_CSHT)                        /*!<nCS stay high for at least 8 clock cycles between commands*/
N/**
N  * @}
N  */
N
N/** @defgroup QSPI_ClockMode QSPI Clock Mode
N  * @{
N  */
N#define QSPI_CLOCK_MODE_0                   ((uint32_t)0x00000000U)         /*!<Clk stays low while nCS is released*/
N#define QSPI_CLOCK_MODE_3                   ((uint32_t)QUADSPI_DCR_CKMODE) /*!<Clk goes high while nCS is released*/
N/**
N  * @}
N  */
N  
N/** @defgroup QSPI_Flash_Select QSPI Flash Select
N  * @{
N  */
N#define QSPI_FLASH_ID_1           ((uint32_t)0x00000000U)
N#define QSPI_FLASH_ID_2           ((uint32_t)QUADSPI_CR_FSEL)
N/**
N  * @}
N  */  
N
N  /** @defgroup QSPI_DualFlash_Mode  QSPI Dual Flash Mode
N  * @{
N  */
N#define QSPI_DUALFLASH_ENABLE            ((uint32_t)QUADSPI_CR_DFM)
N#define QSPI_DUALFLASH_DISABLE           ((uint32_t)0x00000000U) 
N/**
N  * @}
N  */ 
N
N/** @defgroup QSPI_AddressSize QSPI Address Size 
N  * @{
N  */
N#define QSPI_ADDRESS_8_BITS            ((uint32_t)0x00000000U)           /*!<8-bit address*/
N#define QSPI_ADDRESS_16_BITS           ((uint32_t)QUADSPI_CCR_ADSIZE_0) /*!<16-bit address*/
N#define QSPI_ADDRESS_24_BITS           ((uint32_t)QUADSPI_CCR_ADSIZE_1) /*!<24-bit address*/
N#define QSPI_ADDRESS_32_BITS           ((uint32_t)QUADSPI_CCR_ADSIZE)   /*!<32-bit address*/
N/**
N  * @}
N  */  
N
N/** @defgroup QSPI_AlternateBytesSize QSPI Alternate Bytes Size
N  * @{
N  */
N#define QSPI_ALTERNATE_BYTES_8_BITS    ((uint32_t)0x00000000U)           /*!<8-bit alternate bytes*/
N#define QSPI_ALTERNATE_BYTES_16_BITS   ((uint32_t)QUADSPI_CCR_ABSIZE_0) /*!<16-bit alternate bytes*/
N#define QSPI_ALTERNATE_BYTES_24_BITS   ((uint32_t)QUADSPI_CCR_ABSIZE_1) /*!<24-bit alternate bytes*/
N#define QSPI_ALTERNATE_BYTES_32_BITS   ((uint32_t)QUADSPI_CCR_ABSIZE)   /*!<32-bit alternate bytes*/
N/**
N  * @}
N  */
N
N/** @defgroup QSPI_InstructionMode QSPI Instruction Mode
N* @{
N*/
N#define QSPI_INSTRUCTION_NONE          ((uint32_t)0x00000000U)          /*!<No instruction*/
N#define QSPI_INSTRUCTION_1_LINE        ((uint32_t)QUADSPI_CCR_IMODE_0) /*!<Instruction on a single line*/
N#define QSPI_INSTRUCTION_2_LINES       ((uint32_t)QUADSPI_CCR_IMODE_1) /*!<Instruction on two lines*/
N#define QSPI_INSTRUCTION_4_LINES       ((uint32_t)QUADSPI_CCR_IMODE)   /*!<Instruction on four lines*/
N/**
N  * @}
N  */
N
N/** @defgroup QSPI_AddressMode QSPI Address Mode
N* @{
N*/
N#define QSPI_ADDRESS_NONE              ((uint32_t)0x00000000U)           /*!<No address*/
N#define QSPI_ADDRESS_1_LINE            ((uint32_t)QUADSPI_CCR_ADMODE_0) /*!<Address on a single line*/
N#define QSPI_ADDRESS_2_LINES           ((uint32_t)QUADSPI_CCR_ADMODE_1) /*!<Address on two lines*/
N#define QSPI_ADDRESS_4_LINES           ((uint32_t)QUADSPI_CCR_ADMODE)   /*!<Address on four lines*/
N/**
N  * @}
N  */  
N
N/** @defgroup QSPI_AlternateBytesMode  QSPI Alternate Bytes Mode
N* @{                                  
N*/
N#define QSPI_ALTERNATE_BYTES_NONE      ((uint32_t)0x00000000U)           /*!<No alternate bytes*/
N#define QSPI_ALTERNATE_BYTES_1_LINE    ((uint32_t)QUADSPI_CCR_ABMODE_0) /*!<Alternate bytes on a single line*/
N#define QSPI_ALTERNATE_BYTES_2_LINES   ((uint32_t)QUADSPI_CCR_ABMODE_1) /*!<Alternate bytes on two lines*/
N#define QSPI_ALTERNATE_BYTES_4_LINES   ((uint32_t)QUADSPI_CCR_ABMODE)   /*!<Alternate bytes on four lines*/
N/**
N  * @}
N  */  
N
N/** @defgroup QSPI_DataMode QSPI Data Mode
N  * @{
N  */
N#define QSPI_DATA_NONE                 ((uint32_t)0X00000000)           /*!<No data*/
N#define QSPI_DATA_1_LINE               ((uint32_t)QUADSPI_CCR_DMODE_0) /*!<Data on a single line*/
N#define QSPI_DATA_2_LINES              ((uint32_t)QUADSPI_CCR_DMODE_1) /*!<Data on two lines*/
N#define QSPI_DATA_4_LINES              ((uint32_t)QUADSPI_CCR_DMODE)   /*!<Data on four lines*/
N/**
N  * @}
N  */  
N
N/** @defgroup QSPI_DdrMode QSPI Ddr Mode
N  * @{
N  */
N#define QSPI_DDR_MODE_DISABLE              ((uint32_t)0x00000000U)       /*!<Double data rate mode disabled*/
N#define QSPI_DDR_MODE_ENABLE               ((uint32_t)QUADSPI_CCR_DDRM) /*!<Double data rate mode enabled*/
N/**
N  * @}
N  */
N
N/** @defgroup QSPI_DdrHoldHalfCycle QSPI Ddr HoldHalfCycle
N  * @{
N  */
N#define QSPI_DDR_HHC_ANALOG_DELAY           ((uint32_t)0x00000000U)       /*!<Delay the data output using analog delay in DDR mode*/
N#define QSPI_DDR_HHC_HALF_CLK_DELAY         ((uint32_t)QUADSPI_CCR_DHHC) /*!<Delay the data output by 1/2 clock cycle in DDR mode*/
N/**
N  * @}
N  */
N
N/** @defgroup QSPI_SIOOMode QSPI SIOO Mode
N  * @{
N  */
N#define QSPI_SIOO_INST_EVERY_CMD       ((uint32_t)0x00000000U)       /*!<Send instruction on every transaction*/
N#define QSPI_SIOO_INST_ONLY_FIRST_CMD  ((uint32_t)QUADSPI_CCR_SIOO) /*!<Send instruction only for the first command*/
N/**
N  * @}
N  */
N
N/** @defgroup QSPI_MatchMode QSPI Match Mode
N  * @{
N  */
N#define QSPI_MATCH_MODE_AND                 ((uint32_t)0x00000000U)     /*!<AND match mode between unmasked bits*/
N#define QSPI_MATCH_MODE_OR                  ((uint32_t)QUADSPI_CR_PMM) /*!<OR match mode between unmasked bits*/
N/**
N  * @}
N  */  
N
N/** @defgroup QSPI_AutomaticStop QSPI Automatic Stop
N  * @{
N  */
N#define QSPI_AUTOMATIC_STOP_DISABLE        ((uint32_t)0x00000000U)      /*!<AutoPolling stops only with abort or QSPI disabling*/
N#define QSPI_AUTOMATIC_STOP_ENABLE         ((uint32_t)QUADSPI_CR_APMS) /*!<AutoPolling stops as soon as there is a match*/
N/**
N  * @}
N  */  
N
N/** @defgroup QSPI_TimeOutActivation QSPI TimeOut Activation
N  * @{
N  */
N#define QSPI_TIMEOUT_COUNTER_DISABLE       ((uint32_t)0x00000000U)      /*!<Timeout counter disabled, nCS remains active*/
N#define QSPI_TIMEOUT_COUNTER_ENABLE        ((uint32_t)QUADSPI_CR_TCEN) /*!<Timeout counter enabled, nCS released when timeout expires*/
N/**
N  * @}
N  */  
N
N/** @defgroup QSPI_Flags  QSPI Flags
N  * @{
N  */
N#define QSPI_FLAG_BUSY                 QUADSPI_SR_BUSY /*!<Busy flag: operation is ongoing*/
N#define QSPI_FLAG_TO                   QUADSPI_SR_TOF  /*!<Timeout flag: timeout occurs in memory-mapped mode*/
N#define QSPI_FLAG_SM                   QUADSPI_SR_SMF  /*!<Status match flag: received data matches in autopolling mode*/
N#define QSPI_FLAG_FT                   QUADSPI_SR_FTF  /*!<Fifo threshold flag: Fifo threshold reached or data left after read from memory is complete*/
N#define QSPI_FLAG_TC                   QUADSPI_SR_TCF  /*!<Transfer complete flag: programmed number of data have been transferred or the transfer has been aborted*/
N#define QSPI_FLAG_TE                   QUADSPI_SR_TEF  /*!<Transfer error flag: invalid address is being accessed*/
N/**
N  * @}
N  */
N
N/** @defgroup QSPI_Interrupts  QSPI Interrupts
N  * @{
N  */  
N#define QSPI_IT_TO                          QUADSPI_CR_TOIE /*!<Interrupt on the timeout flag*/
N#define QSPI_IT_SM                          QUADSPI_CR_SMIE /*!<Interrupt on the status match flag*/
N#define QSPI_IT_FT                          QUADSPI_CR_FTIE /*!<Interrupt on the fifo threshold flag*/
N#define QSPI_IT_TC                          QUADSPI_CR_TCIE /*!<Interrupt on the transfer complete flag*/
N#define QSPI_IT_TE                          QUADSPI_CR_TEIE /*!<Interrupt on the transfer error flag*/
N/**
N  * @}
N  */
N
N/** @defgroup QSPI_Timeout_definition QSPI Timeout definition
N  * @{
N  */ 
N#define HAL_QPSI_TIMEOUT_DEFAULT_VALUE ((uint32_t)5000)/* 5 s */
N/**
N  * @}
N  */  
N    
N/**
N  * @}
N  */
N
N/* Exported macros -----------------------------------------------------------*/
N/** @defgroup QSPI_Exported_Macros QSPI Exported Macros
N  * @{
N  */
N
N/** @brief Reset QSPI handle state
N  * @param  __HANDLE__: QSPI handle.
N  * @retval None
N  */
N#define __HAL_QSPI_RESET_HANDLE_STATE(__HANDLE__)           ((__HANDLE__)->State = HAL_QSPI_STATE_RESET)
N
N/** @brief  Enable QSPI
N  * @param  __HANDLE__: specifies the QSPI Handle.
N  * @retval None
N  */ 
N#define __HAL_QSPI_ENABLE(__HANDLE__)                       SET_BIT((__HANDLE__)->Instance->CR, QUADSPI_CR_EN)
N
N/** @brief  Disable QSPI
N  * @param  __HANDLE__: specifies the QSPI Handle.
N  * @retval None
N  */
N#define __HAL_QSPI_DISABLE(__HANDLE__)                      CLEAR_BIT((__HANDLE__)->Instance->CR, QUADSPI_CR_EN)
N
N/** @brief  Enables the specified QSPI interrupt.
N  * @param  __HANDLE__: specifies the QSPI Handle.
N  * @param  __INTERRUPT__: specifies the QSPI interrupt source to enable.
N  *          This parameter can be one of the following values:
N  *            @arg QSPI_IT_TO: QSPI Time out interrupt
N  *            @arg QSPI_IT_SM: QSPI Status match interrupt
N  *            @arg QSPI_IT_FT: QSPI FIFO threshold interrupt
N  *            @arg QSPI_IT_TC: QSPI Transfer complete interrupt
N  *            @arg QSPI_IT_TE: QSPI Transfer error interrupt
N  * @retval None
N  */
N#define __HAL_QSPI_ENABLE_IT(__HANDLE__, __INTERRUPT__)     SET_BIT((__HANDLE__)->Instance->CR, (__INTERRUPT__))
N
N
N/** @brief  Disables the specified QSPI interrupt.
N  * @param  __HANDLE__: specifies the QSPI Handle.
N  * @param  __INTERRUPT__: specifies the QSPI interrupt source to disable.
N  *          This parameter can be one of the following values:
N  *            @arg QSPI_IT_TO: QSPI Timeout interrupt
N  *            @arg QSPI_IT_SM: QSPI Status match interrupt
N  *            @arg QSPI_IT_FT: QSPI FIFO threshold interrupt
N  *            @arg QSPI_IT_TC: QSPI Transfer complete interrupt
N  *            @arg QSPI_IT_TE: QSPI Transfer error interrupt
N  * @retval None
N  */
N#define __HAL_QSPI_DISABLE_IT(__HANDLE__, __INTERRUPT__)    CLEAR_BIT((__HANDLE__)->Instance->CR, (__INTERRUPT__))
N
N/** @brief  Checks whether the specified QSPI interrupt source is enabled.
N  * @param  __HANDLE__: specifies the QSPI Handle.
N  * @param  __INTERRUPT__: specifies the QSPI interrupt source to check.
N  *          This parameter can be one of the following values:
N  *            @arg QSPI_IT_TO: QSPI Time out interrupt
N  *            @arg QSPI_IT_SM: QSPI Status match interrupt
N  *            @arg QSPI_IT_FT: QSPI FIFO threshold interrupt
N  *            @arg QSPI_IT_TC: QSPI Transfer complete interrupt
N  *            @arg QSPI_IT_TE: QSPI Transfer error interrupt
N  * @retval The new state of __INTERRUPT__ (TRUE or FALSE).
N  */
N#define __HAL_QSPI_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) (READ_BIT((__HANDLE__)->Instance->CR, (__INTERRUPT__)) == (__INTERRUPT__)) 
N
N/**
N  * @brief  Get the selected QSPI's flag status.
N  * @param  __HANDLE__: specifies the QSPI Handle.
N  * @param  __FLAG__: specifies the QSPI flag to check.
N  *          This parameter can be one of the following values:
N  *            @arg QSPI_FLAG_BUSY: QSPI Busy flag
N  *            @arg QSPI_FLAG_TO:   QSPI Time out flag
N  *            @arg QSPI_FLAG_SM:   QSPI Status match flag
N  *            @arg QSPI_FLAG_FT:   QSPI FIFO threshold flag
N  *            @arg QSPI_FLAG_TC:   QSPI Transfer complete flag
N  *            @arg QSPI_FLAG_TE:   QSPI Transfer error flag
N  * @retval None
N  */
N#define __HAL_QSPI_GET_FLAG(__HANDLE__, __FLAG__)           (READ_BIT((__HANDLE__)->Instance->SR, (__FLAG__)) != 0)
N
N/** @brief  Clears the specified QSPI's flag status.
N  * @param  __HANDLE__: specifies the QSPI Handle.
N  * @param  __FLAG__: specifies the QSPI clear register flag that needs to be set
N  *          This parameter can be one of the following values:
N  *            @arg QSPI_FLAG_TO: QSPI Time out flag
N  *            @arg QSPI_FLAG_SM: QSPI Status match flag
N  *            @arg QSPI_FLAG_TC: QSPI Transfer complete flag
N  *            @arg QSPI_FLAG_TE: QSPI Transfer error flag
N  * @retval None
N  */
N#define __HAL_QSPI_CLEAR_FLAG(__HANDLE__, __FLAG__)         WRITE_REG((__HANDLE__)->Instance->FCR, (__FLAG__))
N/**
N  * @}
N  */
N  
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup QSPI_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup QSPI_Exported_Functions_Group1
N  * @{
N  */
N/* Initialization/de-initialization functions  ********************************/
NHAL_StatusTypeDef     HAL_QSPI_Init     (QSPI_HandleTypeDef *hqspi);
NHAL_StatusTypeDef     HAL_QSPI_DeInit   (QSPI_HandleTypeDef *hqspi);
Nvoid                  HAL_QSPI_MspInit  (QSPI_HandleTypeDef *hqspi);
Nvoid                  HAL_QSPI_MspDeInit(QSPI_HandleTypeDef *hqspi);
N/**
N  * @}
N  */
N
N/** @addtogroup QSPI_Exported_Functions_Group2
N  * @{
N  */  
N/* IO operation functions *****************************************************/
N/* QSPI IRQ handler method */
Nvoid                  HAL_QSPI_IRQHandler(QSPI_HandleTypeDef *hqspi);
N
N/* QSPI indirect mode */
NHAL_StatusTypeDef     HAL_QSPI_Command      (QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, uint32_t Timeout);
NHAL_StatusTypeDef     HAL_QSPI_Transmit     (QSPI_HandleTypeDef *hqspi, uint8_t *pData, uint32_t Timeout);
NHAL_StatusTypeDef     HAL_QSPI_Receive      (QSPI_HandleTypeDef *hqspi, uint8_t *pData, uint32_t Timeout);
NHAL_StatusTypeDef     HAL_QSPI_Command_IT   (QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd);
NHAL_StatusTypeDef     HAL_QSPI_Transmit_IT  (QSPI_HandleTypeDef *hqspi, uint8_t *pData);
NHAL_StatusTypeDef     HAL_QSPI_Receive_IT   (QSPI_HandleTypeDef *hqspi, uint8_t *pData);
NHAL_StatusTypeDef     HAL_QSPI_Transmit_DMA (QSPI_HandleTypeDef *hqspi, uint8_t *pData);
NHAL_StatusTypeDef     HAL_QSPI_Receive_DMA  (QSPI_HandleTypeDef *hqspi, uint8_t *pData);
N
N/* QSPI status flag polling mode */
NHAL_StatusTypeDef     HAL_QSPI_AutoPolling   (QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, QSPI_AutoPollingTypeDef *cfg, uint32_t Timeout);
NHAL_StatusTypeDef     HAL_QSPI_AutoPolling_IT(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, QSPI_AutoPollingTypeDef *cfg);
N
N/* QSPI memory-mapped mode */
NHAL_StatusTypeDef     HAL_QSPI_MemoryMapped(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, QSPI_MemoryMappedTypeDef *cfg);
N/**
N  * @}
N  */
N
N/** @addtogroup QSPI_Exported_Functions_Group3
N  * @{
N  */  
N/* Callback functions in non-blocking modes ***********************************/
Nvoid                  HAL_QSPI_ErrorCallback        (QSPI_HandleTypeDef *hqspi);
Nvoid                  HAL_QSPI_AbortCpltCallback    (QSPI_HandleTypeDef *hqspi);
Nvoid                  HAL_QSPI_FifoThresholdCallback(QSPI_HandleTypeDef *hqspi);
N
N/* QSPI indirect mode */
Nvoid                  HAL_QSPI_CmdCpltCallback      (QSPI_HandleTypeDef *hqspi);
Nvoid                  HAL_QSPI_RxCpltCallback       (QSPI_HandleTypeDef *hqspi);
Nvoid                  HAL_QSPI_TxCpltCallback       (QSPI_HandleTypeDef *hqspi);
Nvoid                  HAL_QSPI_RxHalfCpltCallback   (QSPI_HandleTypeDef *hqspi);
Nvoid                  HAL_QSPI_TxHalfCpltCallback   (QSPI_HandleTypeDef *hqspi);
N
N/* QSPI status flag polling mode */
Nvoid                  HAL_QSPI_StatusMatchCallback  (QSPI_HandleTypeDef *hqspi);
N
N/* QSPI memory-mapped mode */
Nvoid                  HAL_QSPI_TimeOutCallback      (QSPI_HandleTypeDef *hqspi);
N/**
N  * @}
N  */
N
N/** @addtogroup QSPI_Exported_Functions_Group4
N  * @{
N  */  
N/* Peripheral Control and State functions  ************************************/
NHAL_QSPI_StateTypeDef HAL_QSPI_GetState        (QSPI_HandleTypeDef *hqspi);
Nuint32_t              HAL_QSPI_GetError        (QSPI_HandleTypeDef *hqspi);
NHAL_StatusTypeDef     HAL_QSPI_Abort           (QSPI_HandleTypeDef *hqspi);
NHAL_StatusTypeDef     HAL_QSPI_Abort_IT        (QSPI_HandleTypeDef *hqspi);
Nvoid                  HAL_QSPI_SetTimeout      (QSPI_HandleTypeDef *hqspi, uint32_t Timeout);
NHAL_StatusTypeDef     HAL_QSPI_SetFifoThreshold(QSPI_HandleTypeDef *hqspi, uint32_t Threshold);
Nuint32_t              HAL_QSPI_GetFifoThreshold(QSPI_HandleTypeDef *hqspi);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup QSPI_Private_Macros QSPI Private Macros
N  * @{
N  */
N/** @defgroup QSPI_ClockPrescaler QSPI Clock Prescaler
N  * @{
N  */ 
N#define IS_QSPI_CLOCK_PRESCALER(PRESCALER)  ((PRESCALER) <= 0xFF)
N/**
N  * @}
N  */
N
N/** @defgroup QSPI_FifoThreshold  QSPI Fifo Threshold 
N  * @{
N  */
N#define IS_QSPI_FIFO_THRESHOLD(THR)         (((THR) > 0) && ((THR) <= 32))
N/**
N  * @}
N  */
N  
N#define IS_QSPI_SSHIFT(SSHIFT)              (((SSHIFT) == QSPI_SAMPLE_SHIFTING_NONE) || \
N                                             ((SSHIFT) == QSPI_SAMPLE_SHIFTING_HALFCYCLE)) 
X#define IS_QSPI_SSHIFT(SSHIFT)              (((SSHIFT) == QSPI_SAMPLE_SHIFTING_NONE) ||                                              ((SSHIFT) == QSPI_SAMPLE_SHIFTING_HALFCYCLE)) 
N
N/** @defgroup QSPI_FlashSize QSPI Flash Size
N  * @{
N  */
N#define IS_QSPI_FLASH_SIZE(FSIZE)           (((FSIZE) <= 31))
N/**
N  * @}
N  */
N  
N#define IS_QSPI_CS_HIGH_TIME(CSHTIME)       (((CSHTIME) == QSPI_CS_HIGH_TIME_1_CYCLE) || \
N                                             ((CSHTIME) == QSPI_CS_HIGH_TIME_2_CYCLE) || \
N                                             ((CSHTIME) == QSPI_CS_HIGH_TIME_3_CYCLE) || \
N                                             ((CSHTIME) == QSPI_CS_HIGH_TIME_4_CYCLE) || \
N                                             ((CSHTIME) == QSPI_CS_HIGH_TIME_5_CYCLE) || \
N                                             ((CSHTIME) == QSPI_CS_HIGH_TIME_6_CYCLE) || \
N                                             ((CSHTIME) == QSPI_CS_HIGH_TIME_7_CYCLE) || \
N                                             ((CSHTIME) == QSPI_CS_HIGH_TIME_8_CYCLE))   
X#define IS_QSPI_CS_HIGH_TIME(CSHTIME)       (((CSHTIME) == QSPI_CS_HIGH_TIME_1_CYCLE) ||                                              ((CSHTIME) == QSPI_CS_HIGH_TIME_2_CYCLE) ||                                              ((CSHTIME) == QSPI_CS_HIGH_TIME_3_CYCLE) ||                                              ((CSHTIME) == QSPI_CS_HIGH_TIME_4_CYCLE) ||                                              ((CSHTIME) == QSPI_CS_HIGH_TIME_5_CYCLE) ||                                              ((CSHTIME) == QSPI_CS_HIGH_TIME_6_CYCLE) ||                                              ((CSHTIME) == QSPI_CS_HIGH_TIME_7_CYCLE) ||                                              ((CSHTIME) == QSPI_CS_HIGH_TIME_8_CYCLE))   
N
N#define IS_QSPI_CLOCK_MODE(CLKMODE)         (((CLKMODE) == QSPI_CLOCK_MODE_0) || \
N                                             ((CLKMODE) == QSPI_CLOCK_MODE_3))
X#define IS_QSPI_CLOCK_MODE(CLKMODE)         (((CLKMODE) == QSPI_CLOCK_MODE_0) ||                                              ((CLKMODE) == QSPI_CLOCK_MODE_3))
N
N#define IS_QSPI_FLASH_ID(FLA)    (((FLA) == QSPI_FLASH_ID_1) || \
N                                  ((FLA) == QSPI_FLASH_ID_2)) 
X#define IS_QSPI_FLASH_ID(FLA)    (((FLA) == QSPI_FLASH_ID_1) ||                                   ((FLA) == QSPI_FLASH_ID_2)) 
N                                  
N#define IS_QSPI_DUAL_FLASH_MODE(MODE)    (((MODE) == QSPI_DUALFLASH_ENABLE) || \
N                                          ((MODE) == QSPI_DUALFLASH_DISABLE))
X#define IS_QSPI_DUAL_FLASH_MODE(MODE)    (((MODE) == QSPI_DUALFLASH_ENABLE) ||                                           ((MODE) == QSPI_DUALFLASH_DISABLE))
N                                          
N  
N/** @defgroup QSPI_Instruction QSPI Instruction
N  * @{
N  */
N#define IS_QSPI_INSTRUCTION(INSTRUCTION)    ((INSTRUCTION) <= 0xFF) 
N/**
N  * @}
N  */ 
N
N#define IS_QSPI_ADDRESS_SIZE(ADDR_SIZE)     (((ADDR_SIZE) == QSPI_ADDRESS_8_BITS)  || \
N                                             ((ADDR_SIZE) == QSPI_ADDRESS_16_BITS) || \
N                                             ((ADDR_SIZE) == QSPI_ADDRESS_24_BITS) || \
N                                             ((ADDR_SIZE) == QSPI_ADDRESS_32_BITS))
X#define IS_QSPI_ADDRESS_SIZE(ADDR_SIZE)     (((ADDR_SIZE) == QSPI_ADDRESS_8_BITS)  ||                                              ((ADDR_SIZE) == QSPI_ADDRESS_16_BITS) ||                                              ((ADDR_SIZE) == QSPI_ADDRESS_24_BITS) ||                                              ((ADDR_SIZE) == QSPI_ADDRESS_32_BITS))
N
N#define IS_QSPI_ALTERNATE_BYTES_SIZE(SIZE)  (((SIZE) == QSPI_ALTERNATE_BYTES_8_BITS)  || \
N                                             ((SIZE) == QSPI_ALTERNATE_BYTES_16_BITS) || \
N                                             ((SIZE) == QSPI_ALTERNATE_BYTES_24_BITS) || \
N                                             ((SIZE) == QSPI_ALTERNATE_BYTES_32_BITS))                                               
X#define IS_QSPI_ALTERNATE_BYTES_SIZE(SIZE)  (((SIZE) == QSPI_ALTERNATE_BYTES_8_BITS)  ||                                              ((SIZE) == QSPI_ALTERNATE_BYTES_16_BITS) ||                                              ((SIZE) == QSPI_ALTERNATE_BYTES_24_BITS) ||                                              ((SIZE) == QSPI_ALTERNATE_BYTES_32_BITS))                                               
N
N
N/** @defgroup QSPI_DummyCycles QSPI Dummy Cycles
N  * @{
N  */
N#define IS_QSPI_DUMMY_CYCLES(DCY)           ((DCY) <= 31) 
N/**
N  * @}
N  */
N
N#define IS_QSPI_INSTRUCTION_MODE(MODE)      (((MODE) == QSPI_INSTRUCTION_NONE)    || \
N                                             ((MODE) == QSPI_INSTRUCTION_1_LINE)  || \
N                                             ((MODE) == QSPI_INSTRUCTION_2_LINES) || \
N                                             ((MODE) == QSPI_INSTRUCTION_4_LINES))  
X#define IS_QSPI_INSTRUCTION_MODE(MODE)      (((MODE) == QSPI_INSTRUCTION_NONE)    ||                                              ((MODE) == QSPI_INSTRUCTION_1_LINE)  ||                                              ((MODE) == QSPI_INSTRUCTION_2_LINES) ||                                              ((MODE) == QSPI_INSTRUCTION_4_LINES))  
N
N#define IS_QSPI_ADDRESS_MODE(MODE)          (((MODE) == QSPI_ADDRESS_NONE)    || \
N                                             ((MODE) == QSPI_ADDRESS_1_LINE)  || \
N                                             ((MODE) == QSPI_ADDRESS_2_LINES) || \
N                                             ((MODE) == QSPI_ADDRESS_4_LINES))
X#define IS_QSPI_ADDRESS_MODE(MODE)          (((MODE) == QSPI_ADDRESS_NONE)    ||                                              ((MODE) == QSPI_ADDRESS_1_LINE)  ||                                              ((MODE) == QSPI_ADDRESS_2_LINES) ||                                              ((MODE) == QSPI_ADDRESS_4_LINES))
N
N#define IS_QSPI_ALTERNATE_BYTES_MODE(MODE)  (((MODE) == QSPI_ALTERNATE_BYTES_NONE)    || \
N                                             ((MODE) == QSPI_ALTERNATE_BYTES_1_LINE)  || \
N                                             ((MODE) == QSPI_ALTERNATE_BYTES_2_LINES) || \
N                                             ((MODE) == QSPI_ALTERNATE_BYTES_4_LINES))
X#define IS_QSPI_ALTERNATE_BYTES_MODE(MODE)  (((MODE) == QSPI_ALTERNATE_BYTES_NONE)    ||                                              ((MODE) == QSPI_ALTERNATE_BYTES_1_LINE)  ||                                              ((MODE) == QSPI_ALTERNATE_BYTES_2_LINES) ||                                              ((MODE) == QSPI_ALTERNATE_BYTES_4_LINES))
N
N#define IS_QSPI_DATA_MODE(MODE)             (((MODE) == QSPI_DATA_NONE)    || \
N                                             ((MODE) == QSPI_DATA_1_LINE)  || \
N                                             ((MODE) == QSPI_DATA_2_LINES) || \
N                                             ((MODE) == QSPI_DATA_4_LINES))
X#define IS_QSPI_DATA_MODE(MODE)             (((MODE) == QSPI_DATA_NONE)    ||                                              ((MODE) == QSPI_DATA_1_LINE)  ||                                              ((MODE) == QSPI_DATA_2_LINES) ||                                              ((MODE) == QSPI_DATA_4_LINES))
N
N#define IS_QSPI_DDR_MODE(DDR_MODE)          (((DDR_MODE) == QSPI_DDR_MODE_DISABLE) || \
N                                             ((DDR_MODE) == QSPI_DDR_MODE_ENABLE))
X#define IS_QSPI_DDR_MODE(DDR_MODE)          (((DDR_MODE) == QSPI_DDR_MODE_DISABLE) ||                                              ((DDR_MODE) == QSPI_DDR_MODE_ENABLE))
N
N#define IS_QSPI_DDR_HHC(DDR_HHC)            (((DDR_HHC) == QSPI_DDR_HHC_ANALOG_DELAY) || \
N                                             ((DDR_HHC) == QSPI_DDR_HHC_HALF_CLK_DELAY))
X#define IS_QSPI_DDR_HHC(DDR_HHC)            (((DDR_HHC) == QSPI_DDR_HHC_ANALOG_DELAY) ||                                              ((DDR_HHC) == QSPI_DDR_HHC_HALF_CLK_DELAY))
N
N#define IS_QSPI_SIOO_MODE(SIOO_MODE)      (((SIOO_MODE) == QSPI_SIOO_INST_EVERY_CMD) || \
N                                             ((SIOO_MODE) == QSPI_SIOO_INST_ONLY_FIRST_CMD))
X#define IS_QSPI_SIOO_MODE(SIOO_MODE)      (((SIOO_MODE) == QSPI_SIOO_INST_EVERY_CMD) ||                                              ((SIOO_MODE) == QSPI_SIOO_INST_ONLY_FIRST_CMD))
N
N/** @defgroup QSPI_Interval QSPI Interval 
N  * @{
N  */
N#define IS_QSPI_INTERVAL(INTERVAL)        ((INTERVAL) <= QUADSPI_PIR_INTERVAL) 
N/**
N  * @}
N  */
N
N/** @defgroup QSPI_StatusBytesSize QSPI Status Bytes Size
N  * @{
N  */
N#define IS_QSPI_STATUS_BYTES_SIZE(SIZE)   (((SIZE) >= 1) && ((SIZE) <= 4)) 
N/**
N  * @}
N  */
N#define IS_QSPI_MATCH_MODE(MODE)            (((MODE) == QSPI_MATCH_MODE_AND) || \
N                                             ((MODE) == QSPI_MATCH_MODE_OR)) 
X#define IS_QSPI_MATCH_MODE(MODE)            (((MODE) == QSPI_MATCH_MODE_AND) ||                                              ((MODE) == QSPI_MATCH_MODE_OR)) 
N                                             
N#define IS_QSPI_AUTOMATIC_STOP(APMS)        (((APMS) == QSPI_AUTOMATIC_STOP_DISABLE) || \
N                                             ((APMS) == QSPI_AUTOMATIC_STOP_ENABLE))                                                                                                                                                                                                                                    
X#define IS_QSPI_AUTOMATIC_STOP(APMS)        (((APMS) == QSPI_AUTOMATIC_STOP_DISABLE) ||                                              ((APMS) == QSPI_AUTOMATIC_STOP_ENABLE))                                                                                                                                                                                                                                    
N
N#define IS_QSPI_TIMEOUT_ACTIVATION(TCEN)    (((TCEN) == QSPI_TIMEOUT_COUNTER_DISABLE) || \
N                                             ((TCEN) == QSPI_TIMEOUT_COUNTER_ENABLE)) 
X#define IS_QSPI_TIMEOUT_ACTIVATION(TCEN)    (((TCEN) == QSPI_TIMEOUT_COUNTER_DISABLE) ||                                              ((TCEN) == QSPI_TIMEOUT_COUNTER_ENABLE)) 
N
N/** @defgroup QSPI_TimeOutPeriod  QSPI TimeOut Period
N  * @{
N  */
N#define IS_QSPI_TIMEOUT_PERIOD(PERIOD)      ((PERIOD) <= 0xFFFF) 
N/**
N  * @}
N  */
N
N#define IS_QSPI_GET_FLAG(FLAG)              (((FLAG) == QSPI_FLAG_BUSY) || \
N                                             ((FLAG) == QSPI_FLAG_TO)   || \
N                                             ((FLAG) == QSPI_FLAG_SM)   || \
N                                             ((FLAG) == QSPI_FLAG_FT)   || \
N                                             ((FLAG) == QSPI_FLAG_TC)   || \
N                                             ((FLAG) == QSPI_FLAG_TE))    
X#define IS_QSPI_GET_FLAG(FLAG)              (((FLAG) == QSPI_FLAG_BUSY) ||                                              ((FLAG) == QSPI_FLAG_TO)   ||                                              ((FLAG) == QSPI_FLAG_SM)   ||                                              ((FLAG) == QSPI_FLAG_FT)   ||                                              ((FLAG) == QSPI_FLAG_TC)   ||                                              ((FLAG) == QSPI_FLAG_TE))    
N
N#define IS_QSPI_IT(IT)                      ((((IT) & (uint32_t)0xFFE0FFFFU) == 0x00000000U) && ((IT) != 0x00000000U))
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup QSPI_Private_Functions QSPI Private Functions
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_QSPI_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 347 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_QSPI_MODULE_ENABLED */
N
N#ifdef HAL_RNG_MODULE_ENABLED
N #include "stm32f7xx_hal_rng.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_rng.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_rng.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of RNG HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_RNG_H
N#define __STM32F7xx_HAL_RNG_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @defgroup RNG RNG
N  * @brief RNG HAL module driver
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/ 
N
N/** @defgroup RNG_Exported_Types RNG Exported Types
N  * @{
N  */
N
N/** @defgroup RNG_Exported_Types_Group1 RNG State Structure definition 
N  * @{
N  */
Ntypedef enum
N{
N  HAL_RNG_STATE_RESET     = 0x00U,  /*!< RNG not yet initialized or disabled */
N  HAL_RNG_STATE_READY     = 0x01U,  /*!< RNG initialized and ready for use   */
N  HAL_RNG_STATE_BUSY      = 0x02U,  /*!< RNG internal process is ongoing     */ 
N  HAL_RNG_STATE_TIMEOUT   = 0x03U,  /*!< RNG timeout state                   */
N  HAL_RNG_STATE_ERROR     = 0x04U   /*!< RNG error state                     */
N    
N}HAL_RNG_StateTypeDef;
N
N/** 
N  * @}
N  */
N
N/** @defgroup RNG_Exported_Types_Group2 RNG Handle Structure definition   
N  * @{
N  */ 
Ntypedef struct
N{
N  RNG_TypeDef                 *Instance;    /*!< Register base address   */
N
N  uint32_t                    RandomNumber; /*!< Last Generated random number */	
N  
N  HAL_LockTypeDef             Lock;         /*!< RNG locking object      */
N  
N  __IO HAL_RNG_StateTypeDef   State;        /*!< RNG communication state */
X  volatile HAL_RNG_StateTypeDef   State;         
N  
N}RNG_HandleTypeDef;
N
N/** 
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N   
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup RNG_Exported_Constants RNG Exported Constants
N  * @{
N  */
N
N/** @defgroup RNG_Exported_Constants_Group1 RNG Interrupt definition
N  * @{
N  */
N#define RNG_IT_DRDY  RNG_SR_DRDY  /*!< Data Ready interrupt  */
N#define RNG_IT_CEI   RNG_SR_CEIS  /*!< Clock error interrupt */
N#define RNG_IT_SEI   RNG_SR_SEIS  /*!< Seed error interrupt  */
N/**
N  * @}
N  */
N
N/** @defgroup RNG_Exported_Constants_Group2 RNG Flag definition
N  * @{
N  */
N#define RNG_FLAG_DRDY   RNG_SR_DRDY  /*!< Data ready                 */
N#define RNG_FLAG_CECS   RNG_SR_CECS  /*!< Clock error current status */
N#define RNG_FLAG_SECS   RNG_SR_SECS  /*!< Seed error current status  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N  
N/* Exported macros -----------------------------------------------------------*/
N
N/** @defgroup RNG_Exported_Macros RNG Exported Macros
N  * @{
N  */
N
N/** @brief Reset RNG handle state
N  * @param  __HANDLE__: RNG Handle
N  * @retval None
N  */
N#define __HAL_RNG_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_RNG_STATE_RESET)
N
N/**
N  * @brief  Enables the RNG peripheral.
N  * @param  __HANDLE__: RNG Handle
N  * @retval None
N  */
N#define __HAL_RNG_ENABLE(__HANDLE__) ((__HANDLE__)->Instance->CR |=  RNG_CR_RNGEN)
N
N/**
N  * @brief  Disables the RNG peripheral.
N  * @param  __HANDLE__: RNG Handle
N  * @retval None
N  */
N#define __HAL_RNG_DISABLE(__HANDLE__) ((__HANDLE__)->Instance->CR &= ~RNG_CR_RNGEN)
N
N/**
N  * @brief  Check the selected RNG flag status.
N  * @param  __HANDLE__: RNG Handle
N  * @param  __FLAG__: RNG flag
N  *          This parameter can be one of the following values:
N  *            @arg RNG_FLAG_DRDY: Data ready                
N  *            @arg RNG_FLAG_CECS: Clock error current status
N  *            @arg RNG_FLAG_SECS: Seed error current status 
N  * @retval The new state of __FLAG__ (SET or RESET).
N  */
N#define __HAL_RNG_GET_FLAG(__HANDLE__, __FLAG__) (((__HANDLE__)->Instance->SR & (__FLAG__)) == (__FLAG__))
N
N/**
N  * @brief  Clears the selected RNG flag status.
N  * @param  __HANDLE__: RNG handle
N  * @param  __FLAG__: RNG flag to clear  
N  * @note   WARNING: This is a dummy macro for HAL code alignment,
N  *         flags RNG_FLAG_DRDY, RNG_FLAG_CECS and RNG_FLAG_SECS are read-only.
N  * @retval None
N  */
N#define __HAL_RNG_CLEAR_FLAG(__HANDLE__, __FLAG__)                      /* dummy  macro */
N
N
N
N/**
N  * @brief  Enables the RNG interrupts.
N  * @param  __HANDLE__: RNG Handle
N  * @retval None
N  */
N#define __HAL_RNG_ENABLE_IT(__HANDLE__) ((__HANDLE__)->Instance->CR |=  RNG_CR_IE)
N    
N/**
N  * @brief  Disables the RNG interrupts.
N  * @param  __HANDLE__: RNG Handle
N  * @retval None
N  */
N#define __HAL_RNG_DISABLE_IT(__HANDLE__) ((__HANDLE__)->Instance->CR &= ~RNG_CR_IE)
N
N/**
N  * @brief  Checks whether the specified RNG interrupt has occurred or not.
N  * @param  __HANDLE__: RNG Handle
N  * @param  __INTERRUPT__: specifies the RNG interrupt status flag to check.
N  *         This parameter can be one of the following values:
N  *            @arg RNG_IT_DRDY: Data ready interrupt              
N  *            @arg RNG_IT_CEI: Clock error interrupt
N  *            @arg RNG_IT_SEI: Seed error interrupt
N  * @retval The new state of __INTERRUPT__ (SET or RESET).
N  */
N#define __HAL_RNG_GET_IT(__HANDLE__, __INTERRUPT__) (((__HANDLE__)->Instance->SR & (__INTERRUPT__)) == (__INTERRUPT__))   
N
N/**
N  * @brief  Clear the RNG interrupt status flags.
N  * @param  __HANDLE__: RNG Handle
N  * @param  __INTERRUPT__: specifies the RNG interrupt status flag to clear.
N  *          This parameter can be one of the following values:            
N  *            @arg RNG_IT_CEI: Clock error interrupt
N  *            @arg RNG_IT_SEI: Seed error interrupt
N  * @note   RNG_IT_DRDY flag is read-only, reading RNG_DR register automatically clears RNG_IT_DRDY.          
N  * @retval None
N  */
N#define __HAL_RNG_CLEAR_IT(__HANDLE__, __INTERRUPT__) (((__HANDLE__)->Instance->SR) = ~(__INTERRUPT__))
N
N/**
N  * @}
N  */ 
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup RNG_Exported_Functions RNG Exported Functions
N  * @{
N  */
N
N/** @defgroup RNG_Exported_Functions_Group1 Initialization and de-initialization functions
N  * @{
N  */  
NHAL_StatusTypeDef HAL_RNG_Init(RNG_HandleTypeDef *hrng);
NHAL_StatusTypeDef HAL_RNG_DeInit (RNG_HandleTypeDef *hrng);
Nvoid HAL_RNG_MspInit(RNG_HandleTypeDef *hrng);
Nvoid HAL_RNG_MspDeInit(RNG_HandleTypeDef *hrng);
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RNG_Exported_Functions_Group2 Peripheral Control functions
N  * @{
N  */
Nuint32_t HAL_RNG_GetRandomNumber(RNG_HandleTypeDef *hrng);    /* Obsolete, use HAL_RNG_GenerateRandomNumber() instead    */
Nuint32_t HAL_RNG_GetRandomNumber_IT(RNG_HandleTypeDef *hrng); /* Obsolete, use HAL_RNG_GenerateRandomNumber_IT() instead */
N
NHAL_StatusTypeDef HAL_RNG_GenerateRandomNumber(RNG_HandleTypeDef *hrng, uint32_t *random32bit);
NHAL_StatusTypeDef HAL_RNG_GenerateRandomNumber_IT(RNG_HandleTypeDef *hrng);
Nuint32_t HAL_RNG_ReadLastRandomNumber(RNG_HandleTypeDef *hrng);
N
Nvoid HAL_RNG_IRQHandler(RNG_HandleTypeDef *hrng);
Nvoid HAL_RNG_ErrorCallback(RNG_HandleTypeDef *hrng);
Nvoid HAL_RNG_ReadyDataCallback(RNG_HandleTypeDef* hrng, uint32_t random32bit);
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RNG_Exported_Functions_Group3 Peripheral State functions
N  * @{
N  */
NHAL_RNG_StateTypeDef HAL_RNG_GetState(RNG_HandleTypeDef *hrng);
N
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */ 
N
N/* Private types -------------------------------------------------------------*/
N/** @defgroup RNG_Private_Types RNG Private Types
N  * @{
N  */
N
N/**
N  * @}
N  */ 
N
N/* Private defines -----------------------------------------------------------*/
N/** @defgroup RNG_Private_Defines RNG Private Defines
N  * @{
N  */
N
N/**
N  * @}
N  */ 
N          
N/* Private variables ---------------------------------------------------------*/
N/** @defgroup RNG_Private_Variables RNG Private Variables
N  * @{
N  */
N
N/**
N  * @}
N  */ 
N
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup RNG_Private_Constants RNG Private Constants
N  * @{
N  */
N
N/**
N  * @}
N  */ 
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup RNG_Private_Macros RNG Private Macros
N  * @{
N  */
N#define IS_RNG_IT(IT) (((IT) == RNG_IT_CEI) || \
N                       ((IT) == RNG_IT_SEI))
X#define IS_RNG_IT(IT) (((IT) == RNG_IT_CEI) ||                        ((IT) == RNG_IT_SEI))
N
N#define IS_RNG_FLAG(FLAG) (((FLAG) == RNG_FLAG_DRDY) || \
N                           ((FLAG) == RNG_FLAG_CECS) || \
N                           ((FLAG) == RNG_FLAG_SECS))
X#define IS_RNG_FLAG(FLAG) (((FLAG) == RNG_FLAG_DRDY) ||                            ((FLAG) == RNG_FLAG_CECS) ||                            ((FLAG) == RNG_FLAG_SECS))
N
N/**
N  * @}
N  */ 
N
N/* Private functions prototypes ----------------------------------------------*/
N/** @defgroup RNG_Private_Functions_Prototypes RNG Private Functions Prototypes
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup RNG_Private_Functions RNG Private Functions
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_RNG_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 351 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_RNG_MODULE_ENABLED */
N
N#ifdef HAL_RTC_MODULE_ENABLED
N #include "stm32f7xx_hal_rtc.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_rtc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_rtc.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of RTC HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_RTC_H
N#define __STM32F7xx_HAL_RTC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup RTC
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup RTC_Exported_Types RTC Exported Types
N  * @{
N  */
N
N/** 
N  * @brief  HAL State structures definition  
N  */ 
Ntypedef enum
N{
N  HAL_RTC_STATE_RESET             = 0x00U,  /*!< RTC not yet initialized or disabled */
N  HAL_RTC_STATE_READY             = 0x01U,  /*!< RTC initialized and ready for use   */
N  HAL_RTC_STATE_BUSY              = 0x02U,  /*!< RTC process is ongoing              */     
N  HAL_RTC_STATE_TIMEOUT           = 0x03U,  /*!< RTC timeout state                   */  
N  HAL_RTC_STATE_ERROR             = 0x04U   /*!< RTC error state                     */      
N                                                                        
N}HAL_RTCStateTypeDef;
N
N/** 
N  * @brief  RTC Configuration Structure definition  
N  */
Ntypedef struct
N{
N  uint32_t HourFormat;      /*!< Specifies the RTC Hour Format.
N                                 This parameter can be a value of @ref RTC_Hour_Formats */         
N
N  uint32_t AsynchPrediv;    /*!< Specifies the RTC Asynchronous Predivider value.
N                                 This parameter must be a number between Min_Data = 0x00 and Max_Data = 0x7F */        
N                               
N  uint32_t SynchPrediv;     /*!< Specifies the RTC Synchronous Predivider value.
N                                 This parameter must be a number between Min_Data = 0x00 and Max_Data = 0x7FFF */   
N  
N  uint32_t OutPut;          /*!< Specifies which signal will be routed to the RTC output.   
N                                 This parameter can be a value of @ref RTCEx_Output_selection_Definitions */      
N  
N  uint32_t OutPutPolarity;  /*!< Specifies the polarity of the output signal.  
N                                 This parameter can be a value of @ref RTC_Output_Polarity_Definitions */ 
N  
N  uint32_t OutPutType;      /*!< Specifies the RTC Output Pin mode.   
N                                 This parameter can be a value of @ref RTC_Output_Type_ALARM_OUT */             
N}RTC_InitTypeDef;
N
N/** 
N  * @brief  RTC Time structure definition  
N  */
Ntypedef struct
N{
N  uint8_t Hours;            /*!< Specifies the RTC Time Hour.
N                                 This parameter must be a number between Min_Data = 0 and Max_Data = 12 if the RTC_HourFormat_12 is selected.
N                                 This parameter must be a number between Min_Data = 0 and Max_Data = 23 if the RTC_HourFormat_24 is selected  */
N
N  uint8_t Minutes;          /*!< Specifies the RTC Time Minutes.
N                                 This parameter must be a number between Min_Data = 0 and Max_Data = 59 */
N  
N  uint8_t Seconds;          /*!< Specifies the RTC Time Seconds.
N                                 This parameter must be a number between Min_Data = 0 and Max_Data = 59 */
N  
N  uint32_t SubSeconds;      /*!< Specifies the RTC_SSR RTC Sub Second register content.
N                                 This parameter corresponds to a time unit range between [0-1] Second
N                                 with [1 Sec / SecondFraction +1] granularity */
N  
N  uint32_t SecondFraction;  /*!< Specifies the range or granularity of Sub Second register content
N                                 corresponding to Synchronous pre-scaler factor value (PREDIV_S)
N                                 This parameter corresponds to a time unit range between [0-1] Second
N                                 with [1 Sec / SecondFraction +1] granularity.
N                                 This field will be used only by HAL_RTC_GetTime function */
N
N  uint8_t TimeFormat;       /*!< Specifies the RTC AM/PM Time.
N                                 This parameter can be a value of @ref RTC_AM_PM_Definitions */ 
N  
N  uint32_t DayLightSaving;  /*!< Specifies RTC_DayLightSaveOperation: the value of hour adjustment.
N                                 This parameter can be a value of @ref RTC_DayLightSaving_Definitions */
N  
N  uint32_t StoreOperation;  /*!< Specifies RTC_StoreOperation value to be written in the BCK bit 
N                                 in CR register to store the operation.
N                                 This parameter can be a value of @ref RTC_StoreOperation_Definitions */
N}RTC_TimeTypeDef; 
N  
N/** 
N  * @brief  RTC Date structure definition  
N  */
Ntypedef struct
N{
N  uint8_t WeekDay;  /*!< Specifies the RTC Date WeekDay.
N                         This parameter can be a value of @ref RTC_WeekDay_Definitions */
N  
N  uint8_t Month;    /*!< Specifies the RTC Date Month (in BCD format).
N                         This parameter can be a value of @ref RTC_Month_Date_Definitions */
N
N  uint8_t Date;     /*!< Specifies the RTC Date.
N                         This parameter must be a number between Min_Data = 1 and Max_Data = 31 */
N  
N  uint8_t Year;     /*!< Specifies the RTC Date Year.
N                         This parameter must be a number between Min_Data = 0 and Max_Data = 99 */
N                        
N}RTC_DateTypeDef;
N
N/** 
N  * @brief  RTC Alarm structure definition  
N  */
Ntypedef struct
N{
N  RTC_TimeTypeDef AlarmTime;     /*!< Specifies the RTC Alarm Time members */
N    
N  uint32_t AlarmMask;            /*!< Specifies the RTC Alarm Masks.
N                                      This parameter can be a value of @ref RTC_AlarmMask_Definitions */
N  
N  uint32_t AlarmSubSecondMask;   /*!< Specifies the RTC Alarm SubSeconds Masks.
N                                      This parameter can be a value of @ref RTC_Alarm_Sub_Seconds_Masks_Definitions */                                   
N
N  uint32_t AlarmDateWeekDaySel;  /*!< Specifies the RTC Alarm is on Date or WeekDay.
N                                     This parameter can be a value of @ref RTC_AlarmDateWeekDay_Definitions */
N  
N  uint8_t AlarmDateWeekDay;      /*!< Specifies the RTC Alarm Date/WeekDay.
N                                      If the Alarm Date is selected, this parameter must be set to a value in the 1-31 range.
N                                      If the Alarm WeekDay is selected, this parameter can be a value of @ref RTC_WeekDay_Definitions */
N                                                                     
N  uint32_t Alarm;                /*!< Specifies the alarm .
N                                      This parameter can be a value of @ref RTC_Alarms_Definitions */                            
N}RTC_AlarmTypeDef;
N
N/** 
N  * @brief  RTC Handle Structure definition  
N  */ 
Ntypedef struct
N{
N  RTC_TypeDef                 *Instance;  /*!< Register base address    */
N   
N  RTC_InitTypeDef             Init;       /*!< RTC required parameters  */ 
N  
N  HAL_LockTypeDef             Lock;       /*!< RTC locking object       */
N  
N  __IO HAL_RTCStateTypeDef    State;      /*!< Time communication state */
X  volatile HAL_RTCStateTypeDef    State;       
N    
N}RTC_HandleTypeDef;
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup RTC_Exported_Constants RTC Exported Constants
N  * @{
N  */
N 
N/** @defgroup RTC_Hour_Formats RTC Hour Formats
N  * @{
N  */ 
N#define RTC_HOURFORMAT_24              ((uint32_t)0x00000000U)
N#define RTC_HOURFORMAT_12              ((uint32_t)0x00000040U)
N/**
N  * @}
N  */ 
N
N
N/** @defgroup RTC_Output_Polarity_Definitions RTC Output Polarity Definitions 
N  * @{
N  */ 
N#define RTC_OUTPUT_POLARITY_HIGH       ((uint32_t)0x00000000U)
N#define RTC_OUTPUT_POLARITY_LOW        ((uint32_t)0x00100000U)
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Output_Type_ALARM_OUT RTC Output Type ALARM OUT
N  * @{
N  */ 
N#define RTC_OUTPUT_TYPE_OPENDRAIN      ((uint32_t)0x00000000U)
N#define RTC_OUTPUT_TYPE_PUSHPULL       ((uint32_t)RTC_OR_ALARMTYPE)  /* 0x00000008 */
N/**
N  * @}
N  */
N
N/** @defgroup RTC_AM_PM_Definitions RTC AM PM Definitions
N  * @{
N  */ 
N#define RTC_HOURFORMAT12_AM            ((uint8_t)0x00U)
N#define RTC_HOURFORMAT12_PM            ((uint8_t)0x40U)
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_DayLightSaving_Definitions RTC DayLight Saving Definitions
N  * @{
N  */ 
N#define RTC_DAYLIGHTSAVING_SUB1H       ((uint32_t)0x00020000U)
N#define RTC_DAYLIGHTSAVING_ADD1H       ((uint32_t)0x00010000U)
N#define RTC_DAYLIGHTSAVING_NONE        ((uint32_t)0x00000000U)
N/**
N  * @}
N  */
N
N/** @defgroup RTC_StoreOperation_Definitions RTC Store Operation Definitions
N  * @{
N  */ 
N#define RTC_STOREOPERATION_RESET        ((uint32_t)0x00000000U)
N#define RTC_STOREOPERATION_SET          ((uint32_t)0x00040000U)
N/**
N  * @}
N  */
N
N/** @defgroup RTC_Input_parameter_format_definitions RTC Input Parameter Format Definitions
N  * @{
N  */ 
N#define RTC_FORMAT_BIN                      ((uint32_t)0x00000000U)
N#define RTC_FORMAT_BCD                      ((uint32_t)0x00000001U)
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Month_Date_Definitions RTC Month Date Definitions
N  * @{
N  */
N/* Coded in BCD format */
N#define RTC_MONTH_JANUARY              ((uint8_t)0x01U)
N#define RTC_MONTH_FEBRUARY             ((uint8_t)0x02U)
N#define RTC_MONTH_MARCH                ((uint8_t)0x03U)
N#define RTC_MONTH_APRIL                ((uint8_t)0x04U)
N#define RTC_MONTH_MAY                  ((uint8_t)0x05U)
N#define RTC_MONTH_JUNE                 ((uint8_t)0x06U)
N#define RTC_MONTH_JULY                 ((uint8_t)0x07U)
N#define RTC_MONTH_AUGUST               ((uint8_t)0x08U)
N#define RTC_MONTH_SEPTEMBER            ((uint8_t)0x09U)
N#define RTC_MONTH_OCTOBER              ((uint8_t)0x10U)
N#define RTC_MONTH_NOVEMBER             ((uint8_t)0x11U)
N#define RTC_MONTH_DECEMBER             ((uint8_t)0x12U)
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_WeekDay_Definitions RTC WeekDay Definitions
N  * @{
N  */   
N#define RTC_WEEKDAY_MONDAY             ((uint8_t)0x01U)
N#define RTC_WEEKDAY_TUESDAY            ((uint8_t)0x02U)
N#define RTC_WEEKDAY_WEDNESDAY          ((uint8_t)0x03U)
N#define RTC_WEEKDAY_THURSDAY           ((uint8_t)0x04U)
N#define RTC_WEEKDAY_FRIDAY             ((uint8_t)0x05U)
N#define RTC_WEEKDAY_SATURDAY           ((uint8_t)0x06U)
N#define RTC_WEEKDAY_SUNDAY             ((uint8_t)0x07U)
N/**
N  * @}
N  */                                 
N
N/** @defgroup RTC_AlarmDateWeekDay_Definitions RTC Alarm Date WeekDay Definitions
N  * @{
N  */ 
N#define RTC_ALARMDATEWEEKDAYSEL_DATE      ((uint32_t)0x00000000U)
N#define RTC_ALARMDATEWEEKDAYSEL_WEEKDAY   ((uint32_t)0x40000000U)
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_AlarmMask_Definitions RTC Alarm Mask Definitions 
N  * @{
N  */ 
N#define RTC_ALARMMASK_NONE                ((uint32_t)0x00000000U)
N#define RTC_ALARMMASK_DATEWEEKDAY         RTC_ALRMAR_MSK4
N#define RTC_ALARMMASK_HOURS               RTC_ALRMAR_MSK3
N#define RTC_ALARMMASK_MINUTES             RTC_ALRMAR_MSK2
N#define RTC_ALARMMASK_SECONDS             RTC_ALRMAR_MSK1
N#define RTC_ALARMMASK_ALL                 ((uint32_t)0x80808080U)
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Alarms_Definitions RTC Alarms Definitions 
N  * @{
N  */ 
N#define RTC_ALARM_A                       RTC_CR_ALRAE
N#define RTC_ALARM_B                       RTC_CR_ALRBE
N/**
N  * @}
N  */
N
N/** @defgroup RTC_Alarm_Sub_Seconds_Masks_Definitions RTC Alarm Sub Seconds Masks Definitions
N  * @{
N  */
N#define RTC_ALARMSUBSECONDMASK_ALL         ((uint32_t)0x00000000U)  /*!< All Alarm SS fields are masked. 
N                                                                        There is no comparison on sub seconds 
N                                                                        for Alarm */
N#define RTC_ALARMSUBSECONDMASK_SS14_1      ((uint32_t)0x01000000U)  /*!< SS[14:1] are don't care in Alarm 
N                                                                        comparison. Only SS[0] is compared.    */
N#define RTC_ALARMSUBSECONDMASK_SS14_2      ((uint32_t)0x02000000U)  /*!< SS[14:2] are don't care in Alarm 
N                                                                        comparison. Only SS[1:0] are compared  */
N#define RTC_ALARMSUBSECONDMASK_SS14_3      ((uint32_t)0x03000000U)  /*!< SS[14:3] are don't care in Alarm 
N                                                                        comparison. Only SS[2:0] are compared  */
N#define RTC_ALARMSUBSECONDMASK_SS14_4      ((uint32_t)0x04000000U)  /*!< SS[14:4] are don't care in Alarm 
N                                                                        comparison. Only SS[3:0] are compared  */
N#define RTC_ALARMSUBSECONDMASK_SS14_5      ((uint32_t)0x05000000U)  /*!< SS[14:5] are don't care in Alarm 
N                                                                        comparison. Only SS[4:0] are compared  */
N#define RTC_ALARMSUBSECONDMASK_SS14_6      ((uint32_t)0x06000000U)  /*!< SS[14:6] are don't care in Alarm 
N                                                                        comparison. Only SS[5:0] are compared  */
N#define RTC_ALARMSUBSECONDMASK_SS14_7      ((uint32_t)0x07000000U)  /*!< SS[14:7] are don't care in Alarm 
N                                                                        comparison. Only SS[6:0] are compared  */
N#define RTC_ALARMSUBSECONDMASK_SS14_8      ((uint32_t)0x08000000U)  /*!< SS[14:8] are don't care in Alarm 
N                                                                        comparison. Only SS[7:0] are compared  */
N#define RTC_ALARMSUBSECONDMASK_SS14_9      ((uint32_t)0x09000000U)  /*!< SS[14:9] are don't care in Alarm 
N                                                                        comparison. Only SS[8:0] are compared  */
N#define RTC_ALARMSUBSECONDMASK_SS14_10     ((uint32_t)0x0A000000U)  /*!< SS[14:10] are don't care in Alarm 
N                                                                        comparison. Only SS[9:0] are compared  */
N#define RTC_ALARMSUBSECONDMASK_SS14_11     ((uint32_t)0x0B000000U)  /*!< SS[14:11] are don't care in Alarm 
N                                                                        comparison. Only SS[10:0] are compared */
N#define RTC_ALARMSUBSECONDMASK_SS14_12     ((uint32_t)0x0C000000U)  /*!< SS[14:12] are don't care in Alarm 
N                                                                        comparison.Only SS[11:0] are compared  */
N#define RTC_ALARMSUBSECONDMASK_SS14_13     ((uint32_t)0x0D000000U)  /*!< SS[14:13] are don't care in Alarm 
N                                                                        comparison. Only SS[12:0] are compared */
N#define RTC_ALARMSUBSECONDMASK_SS14        ((uint32_t)0x0E000000U)  /*!< SS[14] is don't care in Alarm 
N                                                                        comparison.Only SS[13:0] are compared  */
N#define RTC_ALARMSUBSECONDMASK_NONE        ((uint32_t)0x0F000000U)  /*!< SS[14:0] are compared and must match 
N                                                                        to activate alarm. */
N/**
N  * @}
N  */   
N
N/** @defgroup RTC_Interrupts_Definitions RTC Interrupts Definitions 
N  * @{
N  */ 
N#define RTC_IT_TS                         ((uint32_t)RTC_CR_TSIE)
N#define RTC_IT_WUT                        ((uint32_t)RTC_CR_WUTIE)
N#define RTC_IT_ALRA                       ((uint32_t)RTC_CR_ALRAIE)
N#define RTC_IT_ALRB                       ((uint32_t)RTC_CR_ALRBIE)
N#define RTC_IT_TAMP                       ((uint32_t)RTC_TAMPCR_TAMPIE) /* Used only to Enable the Tamper Interrupt */
N#define RTC_IT_TAMP1                      ((uint32_t)RTC_TAMPCR_TAMP1IE)
N#define RTC_IT_TAMP2                      ((uint32_t)RTC_TAMPCR_TAMP2IE)
N#define RTC_IT_TAMP3                      ((uint32_t)RTC_TAMPCR_TAMP3IE)
N/**
N  * @}
N  */
N
N/** @defgroup RTC_Flags_Definitions RTC Flags Definitions 
N  * @{
N  */ 
N#define RTC_FLAG_RECALPF                  ((uint32_t)RTC_ISR_RECALPF)
N#define RTC_FLAG_TAMP3F                   ((uint32_t)RTC_ISR_TAMP3F)
N#define RTC_FLAG_TAMP2F                   ((uint32_t)RTC_ISR_TAMP2F)
N#define RTC_FLAG_TAMP1F                   ((uint32_t)RTC_ISR_TAMP1F)
N#define RTC_FLAG_TSOVF                    ((uint32_t)RTC_ISR_TSOVF)
N#define RTC_FLAG_TSF                      ((uint32_t)RTC_ISR_TSF)
N#define RTC_FLAG_ITSF                     ((uint32_t)RTC_ISR_ITSF)
N#define RTC_FLAG_WUTF                     ((uint32_t)RTC_ISR_WUTF)
N#define RTC_FLAG_ALRBF                    ((uint32_t)RTC_ISR_ALRBF)
N#define RTC_FLAG_ALRAF                    ((uint32_t)RTC_ISR_ALRAF)
N#define RTC_FLAG_INITF                    ((uint32_t)RTC_ISR_INITF)
N#define RTC_FLAG_RSF                      ((uint32_t)RTC_ISR_RSF)
N#define RTC_FLAG_INITS                    ((uint32_t)RTC_ISR_INITS)
N#define RTC_FLAG_SHPF                     ((uint32_t)RTC_ISR_SHPF)
N#define RTC_FLAG_WUTWF                    ((uint32_t)RTC_ISR_WUTWF)
N#define RTC_FLAG_ALRBWF                   ((uint32_t)RTC_ISR_ALRBWF)
N#define RTC_FLAG_ALRAWF                   ((uint32_t)RTC_ISR_ALRAWF)
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N  
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup RTC_Exported_Macros RTC Exported Macros
N  * @{
N  */
N
N/** @brief Reset RTC handle state
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_RTC_STATE_RESET)
N
N/**
N  * @brief  Disable the write protection for RTC registers.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_WRITEPROTECTION_DISABLE(__HANDLE__)             \
N                        do{                                       \
N                            (__HANDLE__)->Instance->WPR = 0xCA;   \
N                            (__HANDLE__)->Instance->WPR = 0x53;   \
N                          } while(0)
X#define __HAL_RTC_WRITEPROTECTION_DISABLE(__HANDLE__)                                     do{                                                                   (__HANDLE__)->Instance->WPR = 0xCA;                               (__HANDLE__)->Instance->WPR = 0x53;                             } while(0)
N
N/**
N  * @brief  Enable the write protection for RTC registers.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_WRITEPROTECTION_ENABLE(__HANDLE__)              \
N                        do{                                       \
N                            (__HANDLE__)->Instance->WPR = 0xFF;   \
N                          } while(0)                            
X#define __HAL_RTC_WRITEPROTECTION_ENABLE(__HANDLE__)                                      do{                                                                   (__HANDLE__)->Instance->WPR = 0xFF;                             } while(0)                            
N 
N/**
N  * @brief  Enable the RTC ALARMA peripheral.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_ALARMA_ENABLE(__HANDLE__)                           ((__HANDLE__)->Instance->CR |= (RTC_CR_ALRAE))
N
N/**
N  * @brief  Disable the RTC ALARMA peripheral.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_ALARMA_DISABLE(__HANDLE__)                          ((__HANDLE__)->Instance->CR &= ~(RTC_CR_ALRAE))
N
N/**
N  * @brief  Enable the RTC ALARMB peripheral.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_ALARMB_ENABLE(__HANDLE__)                           ((__HANDLE__)->Instance->CR |= (RTC_CR_ALRBE))
N
N/**
N  * @brief  Disable the RTC ALARMB peripheral.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_ALARMB_DISABLE(__HANDLE__)                          ((__HANDLE__)->Instance->CR &= ~(RTC_CR_ALRBE))
N
N/**
N  * @brief  Enable the RTC Alarm interrupt.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @param  __INTERRUPT__: specifies the RTC Alarm interrupt sources to be enabled or disabled. 
N  *          This parameter can be any combination of the following values:
N  *             @arg RTC_IT_ALRA: Alarm A interrupt
N  *             @arg RTC_IT_ALRB: Alarm B interrupt  
N  * @retval None
N  */   
N#define __HAL_RTC_ALARM_ENABLE_IT(__HANDLE__, __INTERRUPT__)          ((__HANDLE__)->Instance->CR |= (__INTERRUPT__))
N
N/**
N  * @brief  Disable the RTC Alarm interrupt.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @param  __INTERRUPT__: specifies the RTC Alarm interrupt sources to be enabled or disabled. 
N  *         This parameter can be any combination of the following values:
N  *            @arg RTC_IT_ALRA: Alarm A interrupt
N  *            @arg RTC_IT_ALRB: Alarm B interrupt  
N  * @retval None
N  */
N#define __HAL_RTC_ALARM_DISABLE_IT(__HANDLE__, __INTERRUPT__)         ((__HANDLE__)->Instance->CR &= ~(__INTERRUPT__))
N
N/**
N  * @brief  Check whether the specified RTC Alarm interrupt has occurred or not.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @param  __INTERRUPT__: specifies the RTC Alarm interrupt to check.
N  *         This parameter can be:
N  *            @arg RTC_IT_ALRA: Alarm A interrupt
N  *            @arg RTC_IT_ALRB: Alarm B interrupt  
N  * @retval None
N  */
N#define __HAL_RTC_ALARM_GET_IT(__HANDLE__, __INTERRUPT__)                  ((((((__HANDLE__)->Instance->ISR)& ((__INTERRUPT__)>> 4)) & 0x0000FFFF) != RESET)? SET : RESET)
N
N/**
N  * @brief  Get the selected RTC Alarm's flag status.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @param  __FLAG__: specifies the RTC Alarm Flag to check.
N  *         This parameter can be:
N  *            @arg RTC_FLAG_ALRAF
N  *            @arg RTC_FLAG_ALRBF
N  *            @arg RTC_FLAG_ALRAWF     
N  *            @arg RTC_FLAG_ALRBWF    
N  * @retval None
N  */
N#define __HAL_RTC_ALARM_GET_FLAG(__HANDLE__, __FLAG__)                (((((__HANDLE__)->Instance->ISR) & (__FLAG__)) != RESET)? SET : RESET)
N
N/**
N  * @brief  Clear the RTC Alarm's pending flags.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @param  __FLAG__: specifies the RTC Alarm Flag sources to be enabled or disabled.
N  *          This parameter can be:
N  *             @arg RTC_FLAG_ALRAF
N  *             @arg RTC_FLAG_ALRBF 
N  * @retval None
N  */
N#define __HAL_RTC_ALARM_CLEAR_FLAG(__HANDLE__, __FLAG__)                  ((__HANDLE__)->Instance->ISR) = (~(((__FLAG__) | RTC_ISR_INIT)& 0x0000FFFF)|((__HANDLE__)->Instance->ISR & RTC_ISR_INIT))
N                                       
N/**
N  * @brief  Check whether the specified RTC Alarm interrupt has been enabled or not.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @param  __INTERRUPT__: specifies the RTC Alarm interrupt sources to check.
N  *         This parameter can be:
N  *            @arg RTC_IT_ALRA: Alarm A interrupt
N  *            @arg RTC_IT_ALRB: Alarm B interrupt
N  * @retval None
N  */
N#define __HAL_RTC_ALARM_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)     (((((__HANDLE__)->Instance->CR) & (__INTERRUPT__)) != RESET) ? SET : RESET)
N
N/**
N  * @brief  Enable interrupt on the RTC Alarm associated Exti line.
N  * @retval None
N  */
N#define __HAL_RTC_ALARM_EXTI_ENABLE_IT()            (EXTI->IMR |= RTC_EXTI_LINE_ALARM_EVENT)
N
N/**
N  * @brief  Disable interrupt on the RTC Alarm associated Exti line.
N  * @retval None
N  */
N#define __HAL_RTC_ALARM_EXTI_DISABLE_IT()           (EXTI->IMR &= ~(RTC_EXTI_LINE_ALARM_EVENT))
N
N/**
N  * @brief  Enable event on the RTC Alarm associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_ALARM_EXTI_ENABLE_EVENT()         (EXTI->EMR |= RTC_EXTI_LINE_ALARM_EVENT)
N
N/**
N  * @brief  Disable event on the RTC Alarm associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_ALARM_EXTI_DISABLE_EVENT()         (EXTI->EMR &= ~(RTC_EXTI_LINE_ALARM_EVENT))
N
N/**
N  * @brief  Enable falling edge trigger on the RTC Alarm associated Exti line.  
N  * @retval None.
N  */
N#define __HAL_RTC_ALARM_EXTI_ENABLE_FALLING_EDGE()   (EXTI->FTSR |= RTC_EXTI_LINE_ALARM_EVENT)
N
N/**
N  * @brief  Disable falling edge trigger on the RTC Alarm associated Exti line.  
N  * @retval None.
N  */
N#define __HAL_RTC_ALARM_EXTI_DISABLE_FALLING_EDGE()  (EXTI->FTSR &= ~(RTC_EXTI_LINE_ALARM_EVENT))
N
N/**
N  * @brief  Enable rising edge trigger on the RTC Alarm associated Exti line.  
N  * @retval None.
N  */
N#define __HAL_RTC_ALARM_EXTI_ENABLE_RISING_EDGE()    (EXTI->RTSR |= RTC_EXTI_LINE_ALARM_EVENT)
N
N/**
N  * @brief  Disable rising edge trigger on the RTC Alarm associated Exti line.  
N  * @retval None.
N  */
N#define __HAL_RTC_ALARM_EXTI_DISABLE_RISING_EDGE()   (EXTI->RTSR &= ~(RTC_EXTI_LINE_ALARM_EVENT))
N
N/**
N  * @brief  Enable rising & falling edge trigger on the RTC Alarm associated Exti line.  
N  * @retval None.
N  */
N#define __HAL_RTC_ALARM_EXTI_ENABLE_RISING_FALLING_EDGE() __HAL_RTC_ALARM_EXTI_ENABLE_RISING_EDGE();__HAL_RTC_ALARM_EXTI_ENABLE_FALLING_EDGE();
N
N/**
N  * @brief  Disable rising & falling edge trigger on the RTC Alarm associated Exti line.  
N  * @retval None.
N  */
N#define __HAL_RTC_ALARM_EXTI_DISABLE_RISING_FALLING_EDGE() __HAL_RTC_ALARM_EXTI_DISABLE_RISING_EDGE();__HAL_RTC_ALARM_EXTI_DISABLE_FALLING_EDGE();
N
N/**
N  * @brief Check whether the RTC Alarm associated Exti line interrupt flag is set or not.
N  * @retval Line Status.
N  */
N#define __HAL_RTC_ALARM_EXTI_GET_FLAG()              (EXTI->PR & RTC_EXTI_LINE_ALARM_EVENT)
N
N/**
N  * @brief Clear the RTC Alarm associated Exti line flag.
N  * @retval None.
N  */
N#define __HAL_RTC_ALARM_EXTI_CLEAR_FLAG()            (EXTI->PR = RTC_EXTI_LINE_ALARM_EVENT)
N
N/**
N  * @brief Generate a Software interrupt on RTC Alarm associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_ALARM_EXTI_GENERATE_SWIT()         (EXTI->SWIER |= RTC_EXTI_LINE_ALARM_EVENT)
N/**
N  * @}
N  */
N
N/* Include RTC HAL Extension module */
N#include "stm32f7xx_hal_rtc_ex.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_rtc_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_rtc_ex.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of RTC HAL Extension module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_RTC_EX_H
N#define __STM32F7xx_HAL_RTC_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup RTCEx
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/ 
N/** @defgroup RTCEx_Exported_Types RTCEx Exported Types
N  * @{
N  */
N
N/** 
N  * @brief  RTC Tamper structure definition  
N  */
Ntypedef struct 
N{
N  uint32_t Tamper;                      /*!< Specifies the Tamper Pin.
N                                             This parameter can be a value of @ref  RTCEx_Tamper_Pins_Definitions */
N  
N  uint32_t Interrupt;                   /*!< Specifies the Tamper Interrupt.
N                                             This parameter can be a value of @ref  RTCEx_Tamper_Interrupt_Definitions */                                  
N                                             
N  uint32_t Trigger;                     /*!< Specifies the Tamper Trigger.
N                                             This parameter can be a value of @ref  RTCEx_Tamper_Trigger_Definitions */
N                                             
N  uint32_t NoErase;                     /*!< Specifies the Tamper no erase mode.
N                                             This parameter can be a value of @ref  RTCEx_Tamper_EraseBackUp_Definitions */
N
N  uint32_t MaskFlag;                     /*!< Specifies the Tamper Flag masking.
N                                             This parameter can be a value of @ref RTCEx_Tamper_MaskFlag_Definitions   */
N
N  uint32_t Filter;                      /*!< Specifies the RTC Filter Tamper.
N                                             This parameter can be a value of @ref RTCEx_Tamper_Filter_Definitions */
N  
N  uint32_t SamplingFrequency;           /*!< Specifies the sampling frequency.
N                                             This parameter can be a value of @ref RTCEx_Tamper_Sampling_Frequencies_Definitions */
N                                      
N  uint32_t PrechargeDuration;           /*!< Specifies the Precharge Duration .
N                                             This parameter can be a value of @ref RTCEx_Tamper_Pin_Precharge_Duration_Definitions */ 
N 
N  uint32_t TamperPullUp;                /*!< Specifies the Tamper PullUp .
N                                             This parameter can be a value of @ref RTCEx_Tamper_Pull_UP_Definitions */           
N 
N  uint32_t TimeStampOnTamperDetection;  /*!< Specifies the TimeStampOnTamperDetection.
N                                             This parameter can be a value of @ref RTCEx_Tamper_TimeStampOnTamperDetection_Definitions */                      
N}RTC_TamperTypeDef;
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup RTCEx_Exported_Constants RTCEx Exported Constants
N  * @{
N  */
N
N/** @defgroup RTCEx_Output_selection_Definitions RTCEx Output selection Definitions 
N  * @{
N  */ 
N#define RTC_OUTPUT_DISABLE             ((uint32_t)0x00000000U)
N#define RTC_OUTPUT_ALARMA              ((uint32_t)0x00200000U)
N#define RTC_OUTPUT_ALARMB              ((uint32_t)0x00400000U)
N#define RTC_OUTPUT_WAKEUP              ((uint32_t)0x00600000U)
N/**
N  * @}
N  */ 
N  
N/** @defgroup RTCEx_Backup_Registers_Definitions RTC Backup Registers Definitions
N  * @{
N  */
N#define RTC_BKP_DR0                       ((uint32_t)0x00000000U)
N#define RTC_BKP_DR1                       ((uint32_t)0x00000001U)
N#define RTC_BKP_DR2                       ((uint32_t)0x00000002U)
N#define RTC_BKP_DR3                       ((uint32_t)0x00000003U)
N#define RTC_BKP_DR4                       ((uint32_t)0x00000004U)
N#define RTC_BKP_DR5                       ((uint32_t)0x00000005U)
N#define RTC_BKP_DR6                       ((uint32_t)0x00000006U)
N#define RTC_BKP_DR7                       ((uint32_t)0x00000007U)
N#define RTC_BKP_DR8                       ((uint32_t)0x00000008U)
N#define RTC_BKP_DR9                       ((uint32_t)0x00000009U)
N#define RTC_BKP_DR10                      ((uint32_t)0x0000000AU)
N#define RTC_BKP_DR11                      ((uint32_t)0x0000000BU)
N#define RTC_BKP_DR12                      ((uint32_t)0x0000000CU)
N#define RTC_BKP_DR13                      ((uint32_t)0x0000000DU)
N#define RTC_BKP_DR14                      ((uint32_t)0x0000000EU)
N#define RTC_BKP_DR15                      ((uint32_t)0x0000000FU)
N#define RTC_BKP_DR16                      ((uint32_t)0x00000010U)
N#define RTC_BKP_DR17                      ((uint32_t)0x00000011U)
N#define RTC_BKP_DR18                      ((uint32_t)0x00000012U)
N#define RTC_BKP_DR19                      ((uint32_t)0x00000013U)
N#define RTC_BKP_DR20                      ((uint32_t)0x00000014U)
N#define RTC_BKP_DR21                      ((uint32_t)0x00000015U)
N#define RTC_BKP_DR22                      ((uint32_t)0x00000016U)
N#define RTC_BKP_DR23                      ((uint32_t)0x00000017U)
N#define RTC_BKP_DR24                      ((uint32_t)0x00000018U)
N#define RTC_BKP_DR25                      ((uint32_t)0x00000019U)
N#define RTC_BKP_DR26                      ((uint32_t)0x0000001AU)
N#define RTC_BKP_DR27                      ((uint32_t)0x0000001BU)
N#define RTC_BKP_DR28                      ((uint32_t)0x0000001CU)
N#define RTC_BKP_DR29                      ((uint32_t)0x0000001DU)
N#define RTC_BKP_DR30                      ((uint32_t)0x0000001EU)
N#define RTC_BKP_DR31                      ((uint32_t)0x0000001FU)
N/**
N  * @}
N  */ 
N
N/** @defgroup RTCEx_Time_Stamp_Edges_definitions RTCEx Time Stamp Edges definitions 
N  * @{
N  */ 
N#define RTC_TIMESTAMPEDGE_RISING          ((uint32_t)0x00000000U)
N#define RTC_TIMESTAMPEDGE_FALLING         ((uint32_t)0x00000008U)
N/**
N  * @}
N  */
N  
N/** @defgroup RTCEx_Tamper_Pins_Definitions RTCEx Tamper Pins Definitions 
N  * @{
N  */ 
N#define RTC_TAMPER_1                    RTC_TAMPCR_TAMP1E
N#define RTC_TAMPER_2                    RTC_TAMPCR_TAMP2E
N#define RTC_TAMPER_3                    RTC_TAMPCR_TAMP3E
N/**
N  * @}
N  */
N
N/** @defgroup RTCEx_Tamper_Interrupt_Definitions RTCEx Tamper Interrupt Definitions
N  * @{
N  */
N#define RTC_TAMPER1_INTERRUPT                RTC_TAMPCR_TAMP1IE
N#define RTC_TAMPER2_INTERRUPT                RTC_TAMPCR_TAMP2IE
N#define RTC_TAMPER3_INTERRUPT                RTC_TAMPCR_TAMP3IE
N#define RTC_ALL_TAMPER_INTERRUPT             RTC_TAMPCR_TAMPIE
N/**
N  * @}
N  */
N
N/** @defgroup RTCEx_TimeStamp_Pin_Selection RTCEx TimeStamp Pin Selection
N  * @{
N  */ 
N#define RTC_TIMESTAMPPIN_DEFAULT            ((uint32_t)0x00000000U)
N#define RTC_TIMESTAMPPIN_POS1               ((uint32_t)0x00000002U)
N#define RTC_TIMESTAMPPIN_POS2               ((uint32_t)0x00000004U)
N/**
N  * @}
N  */ 
N
N/** @defgroup RTCEx_Tamper_Trigger_Definitions RTCEx Tamper Trigger Definitions 
N  * @{
N  */ 
N#define RTC_TAMPERTRIGGER_RISINGEDGE       ((uint32_t)0x00000000U)
N#define RTC_TAMPERTRIGGER_FALLINGEDGE      ((uint32_t)0x00000002U)
N#define RTC_TAMPERTRIGGER_LOWLEVEL         RTC_TAMPERTRIGGER_RISINGEDGE
N#define RTC_TAMPERTRIGGER_HIGHLEVEL        RTC_TAMPERTRIGGER_FALLINGEDGE 
N/**
N  * @}
N  */  
N
N  /** @defgroup RTCEx_Tamper_EraseBackUp_Definitions RTCEx Tamper EraseBackUp Definitions
N* @{
N*/
N#define RTC_TAMPER_ERASE_BACKUP_ENABLE               ((uint32_t)0x00000000U)
N#define RTC_TAMPER_ERASE_BACKUP_DISABLE              ((uint32_t)0x00020000U)
N/**
N  * @}
N  */
N
N/** @defgroup RTCEx_Tamper_MaskFlag_Definitions RTCEx Tamper MaskFlag Definitions
N  * @{
N  */
N#define RTC_TAMPERMASK_FLAG_DISABLE                ((uint32_t)0x00000000U)
N#define RTC_TAMPERMASK_FLAG_ENABLE                 ((uint32_t)0x00040000U)
N/**
N  * @}
N  */
N  
N/** @defgroup RTCEx_Tamper_Filter_Definitions RTCEx Tamper Filter Definitions 
N  * @{
N  */ 
N#define RTC_TAMPERFILTER_DISABLE   ((uint32_t)0x00000000U)  /*!< Tamper filter is disabled */
N
N#define RTC_TAMPERFILTER_2SAMPLE   ((uint32_t)0x00000800U)  /*!< Tamper is activated after 2 
N                                                                consecutive samples at the active level */
N#define RTC_TAMPERFILTER_4SAMPLE   ((uint32_t)0x00001000U)  /*!< Tamper is activated after 4 
N                                                                consecutive samples at the active level */
N#define RTC_TAMPERFILTER_8SAMPLE   ((uint32_t)0x00001800U)  /*!< Tamper is activated after 8 
N                                                                consecutive samples at the active leve. */
N/**
N  * @}
N  */
N
N/** @defgroup RTCEx_Tamper_Sampling_Frequencies_Definitions RTCEx Tamper Sampling Frequencies Definitions 
N  * @{
N  */
N#define RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV32768  ((uint32_t)0x00000000U)  /*!< Each of the tamper inputs are sampled
N                                                                             with a frequency =  RTCCLK / 32768 */
N#define RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV16384  ((uint32_t)0x00000100U)  /*!< Each of the tamper inputs are sampled
N                                                                             with a frequency =  RTCCLK / 16384 */
N#define RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV8192   ((uint32_t)0x00000200U)  /*!< Each of the tamper inputs are sampled
N                                                                             with a frequency =  RTCCLK / 8192  */
N#define RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV4096   ((uint32_t)0x00000300U)  /*!< Each of the tamper inputs are sampled
N                                                                             with a frequency =  RTCCLK / 4096  */
N#define RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV2048   ((uint32_t)0x00000400U)  /*!< Each of the tamper inputs are sampled
N                                                                             with a frequency =  RTCCLK / 2048  */
N#define RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV1024   ((uint32_t)0x00000500U)  /*!< Each of the tamper inputs are sampled
N                                                                             with a frequency =  RTCCLK / 1024  */
N#define RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV512    ((uint32_t)0x00000600U)  /*!< Each of the tamper inputs are sampled
N                                                                             with a frequency =  RTCCLK / 512   */
N#define RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV256    ((uint32_t)0x00000700U)  /*!< Each of the tamper inputs are sampled
N                                                                             with a frequency =  RTCCLK / 256   */
N/**
N  * @}
N  */
N
N/** @defgroup RTCEx_Tamper_Pin_Precharge_Duration_Definitions RTCEx Tamper Pin Precharge Duration Definitions 
N  * @{
N  */ 
N#define RTC_TAMPERPRECHARGEDURATION_1RTCCLK ((uint32_t)0x00000000U)  /*!< Tamper pins are pre-charged before 
N                                                                         sampling during 1 RTCCLK cycle */
N#define RTC_TAMPERPRECHARGEDURATION_2RTCCLK ((uint32_t)0x00002000U)  /*!< Tamper pins are pre-charged before 
N                                                                         sampling during 2 RTCCLK cycles */
N#define RTC_TAMPERPRECHARGEDURATION_4RTCCLK ((uint32_t)0x00004000U)  /*!< Tamper pins are pre-charged before 
N                                                                         sampling during 4 RTCCLK cycles */
N#define RTC_TAMPERPRECHARGEDURATION_8RTCCLK ((uint32_t)0x00006000U)  /*!< Tamper pins are pre-charged before 
N                                                                         sampling during 8 RTCCLK cycles */
N/**
N  * @}
N  */
N  
N/** @defgroup RTCEx_Tamper_TimeStampOnTamperDetection_Definitions RTCEx Tamper TimeStampOnTamperDetection Definitions
N  * @{
N  */ 
N#define RTC_TIMESTAMPONTAMPERDETECTION_ENABLE  ((uint32_t)RTC_TAMPCR_TAMPTS)  /*!< TimeStamp on Tamper Detection event saved        */
N#define RTC_TIMESTAMPONTAMPERDETECTION_DISABLE ((uint32_t)0x00000000U)        /*!< TimeStamp on Tamper Detection event is not saved */                                                                      
N/**
N  * @}
N  */
N  
N/** @defgroup  RTCEx_Tamper_Pull_UP_Definitions RTCEx Tamper Pull UP Definitions
N  * @{
N  */ 
N#define RTC_TAMPER_PULLUP_ENABLE  ((uint32_t)0x00000000U)            /*!< TimeStamp on Tamper Detection event saved        */
N#define RTC_TAMPER_PULLUP_DISABLE ((uint32_t)RTC_TAMPCR_TAMPPUDIS)   /*!< TimeStamp on Tamper Detection event is not saved */                                                                  
N/**
N  * @}
N  */
N
N/** @defgroup RTCEx_Wakeup_Timer_Definitions RTCEx Wakeup Timer Definitions 
N  * @{
N  */ 
N#define RTC_WAKEUPCLOCK_RTCCLK_DIV16        ((uint32_t)0x00000000U)
N#define RTC_WAKEUPCLOCK_RTCCLK_DIV8         ((uint32_t)0x00000001U)
N#define RTC_WAKEUPCLOCK_RTCCLK_DIV4         ((uint32_t)0x00000002U)
N#define RTC_WAKEUPCLOCK_RTCCLK_DIV2         ((uint32_t)0x00000003U)
N#define RTC_WAKEUPCLOCK_CK_SPRE_16BITS      ((uint32_t)0x00000004U)
N#define RTC_WAKEUPCLOCK_CK_SPRE_17BITS      ((uint32_t)0x00000006U)
N/**
N  * @}
N  */ 
N
N/** @defgroup RTCEx_Smooth_calib_period_Definitions RTCEx Smooth calib period Definitions 
N  * @{
N  */ 
N#define RTC_SMOOTHCALIB_PERIOD_32SEC   ((uint32_t)0x00000000U)  /*!< If RTCCLK = 32768 Hz, Smooth calibration
N                                                                    period is 32s,  else 2exp20 RTCCLK seconds */
N#define RTC_SMOOTHCALIB_PERIOD_16SEC   ((uint32_t)0x00002000U)  /*!< If RTCCLK = 32768 Hz, Smooth calibration 
N                                                                    period is 16s, else 2exp19 RTCCLK seconds */
N#define RTC_SMOOTHCALIB_PERIOD_8SEC    ((uint32_t)0x00004000U)  /*!< If RTCCLK = 32768 Hz, Smooth calibration 
N                                                                    period is 8s, else 2exp18 RTCCLK seconds */                                        
N/**
N  * @}
N  */ 
N
N/** @defgroup RTCEx_Smooth_calib_Plus_pulses_Definitions RTCEx Smooth calib Plus pulses Definitions 
N  * @{
N  */ 
N#define RTC_SMOOTHCALIB_PLUSPULSES_SET    ((uint32_t)0x00008000U)  /*!< The number of RTCCLK pulses added  
N                                                                       during a X -second window = Y - CALM[8:0] 
N                                                                       with Y = 512, 256, 128 when X = 32, 16, 8 */
N#define RTC_SMOOTHCALIB_PLUSPULSES_RESET  ((uint32_t)0x00000000U)  /*!< The number of RTCCLK pulses subbstited
N                                                                       during a 32-second window = CALM[8:0] */
N/**
N  * @}
N  */
N
N/** @defgroup RTCEx_Add_1_Second_Parameter_Definitions RTCEx Add 1 Second Parameter Definitions
N  * @{
N  */ 
N#define RTC_SHIFTADD1S_RESET      ((uint32_t)0x00000000U)
N#define RTC_SHIFTADD1S_SET        ((uint32_t)0x80000000U)
N/**
N  * @}
N  */
N
N /** @defgroup RTCEx_Calib_Output_selection_Definitions RTCEx Calib Output selection Definitions
N  * @{
N  */ 
N#define RTC_CALIBOUTPUT_512HZ            ((uint32_t)0x00000000U) 
N#define RTC_CALIBOUTPUT_1HZ              ((uint32_t)0x00080000U)
N/**
N  * @}
N  */ 
N  
N/**
N  * @}
N  */ 
N  
N/* Exported macros -----------------------------------------------------------*/
N/** @defgroup RTCEx_Exported_Macros RTCEx Exported Macros
N  * @{
N  */
N
N/**
N  * @brief  Enable the RTC WakeUp Timer peripheral.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_WAKEUPTIMER_ENABLE(__HANDLE__)                     ((__HANDLE__)->Instance->CR |= (RTC_CR_WUTE))
N
N/**
N  * @brief  Disable the RTC WakeUp Timer peripheral.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_WAKEUPTIMER_DISABLE(__HANDLE__)                    ((__HANDLE__)->Instance->CR &= ~(RTC_CR_WUTE))
N
N/**
N  * @brief  Enable the RTC WakeUpTimer interrupt.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @param  __INTERRUPT__: specifies the RTC WakeUpTimer interrupt sources to be enabled or disabled.
N  *         This parameter can be:
N  *            @arg RTC_IT_WUT: WakeUpTimer interrupt
N  * @retval None
N  */
N#define __HAL_RTC_WAKEUPTIMER_ENABLE_IT(__HANDLE__, __INTERRUPT__)    ((__HANDLE__)->Instance->CR |= (__INTERRUPT__))
N
N/**
N  * @brief  Disable the RTC WakeUpTimer interrupt.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @param  __INTERRUPT__: specifies the RTC WakeUpTimer interrupt sources to be enabled or disabled.
N  *         This parameter can be:
N  *            @arg RTC_IT_WUT: WakeUpTimer interrupt
N  * @retval None
N  */
N#define __HAL_RTC_WAKEUPTIMER_DISABLE_IT(__HANDLE__, __INTERRUPT__)   ((__HANDLE__)->Instance->CR &= ~(__INTERRUPT__))
N
N/**
N  * @brief  Check whether the specified RTC WakeUpTimer interrupt has occurred or not.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @param  __INTERRUPT__: specifies the RTC WakeUpTimer interrupt sources to check.
N  *         This parameter can be:
N  *            @arg RTC_IT_WUT:  WakeUpTimer interrupt
N  * @retval None
N  */
N#define __HAL_RTC_WAKEUPTIMER_GET_IT(__HANDLE__, __INTERRUPT__)       (((((__HANDLE__)->Instance->ISR) & ((__INTERRUPT__)>> 4)) != RESET) ? SET : RESET)
N
N/**
N  * @brief  Check whether the specified RTC Wake Up timer interrupt has been enabled or not.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @param  __INTERRUPT__: specifies the RTC Wake Up timer interrupt sources to check.
N  *         This parameter can be:
N  *            @arg RTC_IT_WUT:  WakeUpTimer interrupt
N  * @retval None
N  */
N#define __HAL_RTC_WAKEUPTIMER_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)   (((((__HANDLE__)->Instance->CR) & (__INTERRUPT__)) != RESET) ? SET : RESET)
N
N/**
N  * @brief  Get the selected RTC WakeUpTimer's flag status.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @param  __FLAG__: specifies the RTC WakeUpTimer Flag is pending or not.
N  *          This parameter can be:
N  *             @arg RTC_FLAG_WUTF
N  *             @arg RTC_FLAG_WUTWF
N  * @retval None
N  */
N#define __HAL_RTC_WAKEUPTIMER_GET_FLAG(__HANDLE__, __FLAG__)   (((((__HANDLE__)->Instance->ISR) & (__FLAG__)) != RESET) ? SET : RESET)
N
N/**
N  * @brief  Clear the RTC Wake Up timer's pending flags.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @param  __FLAG__: specifies the RTC WakeUpTimer Flag to clear.
N  *         This parameter can be:
N  *            @arg RTC_FLAG_WUTF
N  * @retval None
N  */
N#define __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(__HANDLE__, __FLAG__) ((__HANDLE__)->Instance->ISR) = (~((__FLAG__) | RTC_ISR_INIT)|((__HANDLE__)->Instance->ISR & RTC_ISR_INIT))    
N
N/**
N  * @brief  Enable the RTC Tamper1 input detection.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER1_ENABLE(__HANDLE__)                         ((__HANDLE__)->Instance->TAMPCR |= (RTC_TAMPCR_TAMP1E))
N
N/**
N  * @brief  Disable the RTC Tamper1 input detection.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER1_DISABLE(__HANDLE__)                        ((__HANDLE__)->Instance->TAMPCR &= ~(RTC_TAMPCR_TAMP1E))
N
N/**
N  * @brief  Enable the RTC Tamper2 input detection.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER2_ENABLE(__HANDLE__)                         ((__HANDLE__)->Instance->TAMPCR |= (RTC_TAMPCR_TAMP2E))
N
N/**
N  * @brief  Disable the RTC Tamper2 input detection.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER2_DISABLE(__HANDLE__)                        ((__HANDLE__)->Instance->TAMPCR &= ~(RTC_TAMPCR_TAMP2E))
N
N/**
N  * @brief  Enable the RTC Tamper3 input detection.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER3_ENABLE(__HANDLE__)                         ((__HANDLE__)->Instance->TAMPCR |= (RTC_TAMPCR_TAMP3E))
N
N/**
N  * @brief  Disable the RTC Tamper3 input detection.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER3_DISABLE(__HANDLE__)                        ((__HANDLE__)->Instance->TAMPCR &= ~(RTC_TAMPCR_TAMP3E))
N
N/**
N  * @brief  Check whether the specified RTC Tamper interrupt has occurred or not.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @param  __INTERRUPT__: specifies the RTC Tamper interrupt to check.
N  *         This parameter can be:
N  *            @arg  RTC_IT_TAMP: All tampers interrupts
N  *            @arg  RTC_IT_TAMP1: Tamper1 interrupt
N  *            @arg  RTC_IT_TAMP2: Tamper2 interrupt
N  *            @arg  RTC_IT_TAMP3: Tamper3 interrupt
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER_GET_IT(__HANDLE__, __INTERRUPT__)           (((__INTERRUPT__) == RTC_IT_TAMP1) ? (((((__HANDLE__)->Instance->ISR) & ((__INTERRUPT__)>> 3)) != RESET) ? SET : RESET) : \
N                                                                      ((__INTERRUPT__) == RTC_IT_TAMP2) ? (((((__HANDLE__)->Instance->ISR) & ((__INTERRUPT__)>> 5)) != RESET) ? SET : RESET) : \
N                                                                                                          (((((__HANDLE__)->Instance->ISR) & ((__INTERRUPT__)>> 7)) != RESET) ? SET : RESET))
X#define __HAL_RTC_TAMPER_GET_IT(__HANDLE__, __INTERRUPT__)           (((__INTERRUPT__) == RTC_IT_TAMP1) ? (((((__HANDLE__)->Instance->ISR) & ((__INTERRUPT__)>> 3)) != RESET) ? SET : RESET) :                                                                       ((__INTERRUPT__) == RTC_IT_TAMP2) ? (((((__HANDLE__)->Instance->ISR) & ((__INTERRUPT__)>> 5)) != RESET) ? SET : RESET) :                                                                                                           (((((__HANDLE__)->Instance->ISR) & ((__INTERRUPT__)>> 7)) != RESET) ? SET : RESET))
N
N/**
N  * @brief  Check whether the specified RTC Tamper interrupt has been enabled or not.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @param  __INTERRUPT__: specifies the RTC Tamper interrupt source to check.
N  *         This parameter can be:
N  *            @arg  RTC_IT_TAMP: All tampers interrupts
N  *            @arg  RTC_IT_TAMP1: Tamper1 interrupt
N  *            @arg  RTC_IT_TAMP2: Tamper2 interrupt
N  *            @arg  RTC_IT_TAMP3: Tamper3 interrupt
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)    (((((__HANDLE__)->Instance->TAMPCR) & (__INTERRUPT__)) != RESET) ? SET : RESET)
N
N/**
N  * @brief  Get the selected RTC Tamper's flag status.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @param  __FLAG__: specifies the RTC Tamper Flag is pending or not.
N  *          This parameter can be:
N  *             @arg RTC_FLAG_TAMP1F: Tamper1 flag
N  *             @arg RTC_FLAG_TAMP2F: Tamper2 flag
N  *             @arg RTC_FLAG_TAMP3F: Tamper3 flag
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER_GET_FLAG(__HANDLE__, __FLAG__)        (((((__HANDLE__)->Instance->ISR) & (__FLAG__)) != RESET) ? SET : RESET)
N
N/**
N  * @brief  Clear the RTC Tamper's pending flags.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @param  __FLAG__: specifies the RTC Tamper Flag sources to clear.
N  *          This parameter can be:
N  *             @arg RTC_FLAG_TAMP1F: Tamper1 flag
N  *             @arg RTC_FLAG_TAMP2F: Tamper2 flag
N  *             @arg RTC_FLAG_TAMP3F: Tamper3 flag
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER_CLEAR_FLAG(__HANDLE__, __FLAG__)      ((__HANDLE__)->Instance->ISR) = (~((__FLAG__) | RTC_ISR_INIT)|((__HANDLE__)->Instance->ISR & RTC_ISR_INIT))
N
N/**
N  * @brief  Enable the RTC TimeStamp peripheral.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_TIMESTAMP_ENABLE(__HANDLE__)                       ((__HANDLE__)->Instance->CR |= (RTC_CR_TSE))
N
N/**
N  * @brief  Disable the RTC TimeStamp peripheral.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_TIMESTAMP_DISABLE(__HANDLE__)                      ((__HANDLE__)->Instance->CR &= ~(RTC_CR_TSE))
N
N/**
N  * @brief  Enable the RTC TimeStamp interrupt.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @param  __INTERRUPT__: specifies the RTC TimeStamp interrupt sources to be enabled or disabled.
N  *         This parameter can be:
N  *            @arg RTC_IT_TS: TimeStamp interrupt
N  * @retval None
N  */
N#define __HAL_RTC_TIMESTAMP_ENABLE_IT(__HANDLE__, __INTERRUPT__)     ((__HANDLE__)->Instance->CR |= (__INTERRUPT__))
N
N/**
N  * @brief  Disable the RTC TimeStamp interrupt.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @param  __INTERRUPT__: specifies the RTC TimeStamp interrupt sources to be enabled or disabled. 
N  *         This parameter can be:
N  *            @arg RTC_IT_TS: TimeStamp interrupt
N  * @retval None
N  */
N#define __HAL_RTC_TIMESTAMP_DISABLE_IT(__HANDLE__, __INTERRUPT__)    ((__HANDLE__)->Instance->CR &= ~(__INTERRUPT__))
N
N/**
N  * @brief  Check whether the specified RTC TimeStamp interrupt has occurred or not.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @param  __INTERRUPT__: specifies the RTC TimeStamp interrupt sources to check.
N  *         This parameter can be:
N  *            @arg RTC_IT_TS: TimeStamp interrupt
N  * @retval None
N  */
N#define __HAL_RTC_TIMESTAMP_GET_IT(__HANDLE__, __INTERRUPT__)        (((((__HANDLE__)->Instance->ISR) & ((__INTERRUPT__)>> 4)) != RESET) ? SET : RESET)
N
N/**
N  * @brief  Check whether the specified RTC Time Stamp interrupt has been enabled or not.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @param  __INTERRUPT__: specifies the RTC Time Stamp interrupt source to check.
N  *         This parameter can be:
N  *            @arg RTC_IT_TS: TimeStamp interrupt
N  * @retval None
N  */
N#define __HAL_RTC_TIMESTAMP_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)     (((((__HANDLE__)->Instance->CR) & (__INTERRUPT__)) != RESET) ? SET : RESET)
N
N/**
N  * @brief  Get the selected RTC TimeStamp's flag status.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @param  __FLAG__: specifies the RTC TimeStamp Flag is pending or not.
N  *         This parameter can be:
N  *            @arg RTC_FLAG_TSF
N  *            @arg RTC_FLAG_TSOVF
N  * @retval None
N  */
N#define __HAL_RTC_TIMESTAMP_GET_FLAG(__HANDLE__, __FLAG__)     (((((__HANDLE__)->Instance->ISR) & (__FLAG__)) != RESET) ? SET : RESET)
N
N/**
N  * @brief  Clear the RTC Time Stamp's pending flags.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @param  __FLAG__: specifies the RTC Alarm Flag sources to clear.
N  *          This parameter can be:
N  *             @arg RTC_FLAG_TSF
N  *             @arg RTC_FLAG_TSOVF
N  * @retval None
N  */
N#define __HAL_RTC_TIMESTAMP_CLEAR_FLAG(__HANDLE__, __FLAG__)   ((__HANDLE__)->Instance->ISR) = (~((__FLAG__) | RTC_ISR_INIT)|((__HANDLE__)->Instance->ISR & RTC_ISR_INIT))
N
N/**
N  * @brief  Enable the RTC internal TimeStamp peripheral.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_INTERNAL_TIMESTAMP_ENABLE(__HANDLE__)                ((__HANDLE__)->Instance->CR |= (RTC_CR_ITSE))
N
N/**
N  * @brief  Disable the RTC internal TimeStamp peripheral.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_INTERNAL_TIMESTAMP_DISABLE(__HANDLE__)               ((__HANDLE__)->Instance->CR &= ~(RTC_CR_ITSE))
N
N/**
N  * @brief  Get the selected RTC Internal Time Stamp's flag status.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @param  __FLAG__: specifies the RTC Internal Time Stamp Flag is pending or not.
N  *         This parameter can be:
N  *            @arg RTC_FLAG_ITSF
N  * @retval None
N  */
N#define __HAL_RTC_INTERNAL_TIMESTAMP_GET_FLAG(__HANDLE__, __FLAG__)    (((((__HANDLE__)->Instance->ISR) & (__FLAG__)) != RESET) ? SET : RESET)
N
N/**
N  * @brief  Clear the RTC Internal Time Stamp's pending flags.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @param  __FLAG__: specifies the RTC Internal Time Stamp Flag source to clear.
N  *          This parameter can be:
N  *             @arg RTC_FLAG_ITSF
N  * @retval None
N  */
N#define __HAL_RTC_INTERNAL_TIMESTAMP_CLEAR_FLAG(__HANDLE__, __FLAG__)  ((__HANDLE__)->Instance->ISR) = (~(((__FLAG__) | RTC_ISR_INIT)& 0x0003FFFF)|((__HANDLE__)->Instance->ISR & RTC_ISR_INIT))
N
N/**
N  * @brief  Enable the RTC calibration output.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_CALIBRATION_OUTPUT_ENABLE(__HANDLE__)                ((__HANDLE__)->Instance->CR |= (RTC_CR_COE))
N
N/**
N  * @brief  Disable the calibration output.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_CALIBRATION_OUTPUT_DISABLE(__HANDLE__)               ((__HANDLE__)->Instance->CR &= ~(RTC_CR_COE))
N
N/**
N  * @brief  Enable the clock reference detection.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_CLOCKREF_DETECTION_ENABLE(__HANDLE__)                ((__HANDLE__)->Instance->CR |= (RTC_CR_REFCKON))
N
N/**
N  * @brief  Disable the clock reference detection.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_CLOCKREF_DETECTION_DISABLE(__HANDLE__)               ((__HANDLE__)->Instance->CR &= ~(RTC_CR_REFCKON))
N
N/**
N  * @brief  Get the selected RTC shift operation's flag status.
N  * @param  __HANDLE__: specifies the RTC handle.
N  * @param  __FLAG__: specifies the RTC shift operation Flag is pending or not.
N  *          This parameter can be:
N  *             @arg RTC_FLAG_SHPF
N  * @retval None
N  */
N#define __HAL_RTC_SHIFT_GET_FLAG(__HANDLE__, __FLAG__)         (((((__HANDLE__)->Instance->ISR) & (__FLAG__)) != RESET) ? SET : RESET)
N
N/**
N  * @brief  Enable interrupt on the RTC WakeUp Timer associated Exti line.
N  * @retval None
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_IT()       (EXTI->IMR |= RTC_EXTI_LINE_WAKEUPTIMER_EVENT)
N
N/**
N  * @brief  Disable interrupt on the RTC WakeUp Timer associated Exti line.
N  * @retval None
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_DISABLE_IT()      (EXTI->IMR &= ~(RTC_EXTI_LINE_WAKEUPTIMER_EVENT))
N
N/**
N  * @brief  Enable event on the RTC WakeUp Timer associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_EVENT()    (EXTI->EMR |= RTC_EXTI_LINE_WAKEUPTIMER_EVENT)
N
N/**
N  * @brief  Disable event on the RTC WakeUp Timer associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_DISABLE_EVENT()   (EXTI->EMR &= ~(RTC_EXTI_LINE_WAKEUPTIMER_EVENT))
N
N/**
N  * @brief  Enable falling edge trigger on the RTC WakeUp Timer associated Exti line. 
N  * @retval None.
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_FALLING_EDGE()   (EXTI->FTSR |= RTC_EXTI_LINE_WAKEUPTIMER_EVENT)
N
N/**
N  * @brief  Disable falling edge trigger on the RTC WakeUp Timer associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_DISABLE_FALLING_EDGE()  (EXTI->FTSR &= ~(RTC_EXTI_LINE_WAKEUPTIMER_EVENT))
N
N/**
N  * @brief  Enable rising edge trigger on the RTC WakeUp Timer associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_RISING_EDGE()    (EXTI->RTSR |= RTC_EXTI_LINE_WAKEUPTIMER_EVENT)
N
N/**
N  * @brief  Disable rising edge trigger on the RTC WakeUp Timer associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_DISABLE_RISING_EDGE()   (EXTI->RTSR &= ~(RTC_EXTI_LINE_WAKEUPTIMER_EVENT))
N
N/**
N  * @brief  Enable rising & falling edge trigger on the RTC WakeUp Timer associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_RISING_FALLING_EDGE() __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_RISING_EDGE();__HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_FALLING_EDGE();
N
N/**
N  * @brief  Disable rising & falling edge trigger on the RTC WakeUp Timer associated Exti line.
N  * This parameter can be:
N  * @retval None.
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_DISABLE_RISING_FALLING_EDGE() __HAL_RTC_WAKEUPTIMER_EXTI_DISABLE_RISING_EDGE();__HAL_RTC_WAKEUPTIMER_EXTI_DISABLE_FALLING_EDGE();
N
N/**
N  * @brief Check whether the RTC WakeUp Timer associated Exti line interrupt flag is set or not.
N  * @retval Line Status.
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_GET_FLAG()              (EXTI->PR & RTC_EXTI_LINE_WAKEUPTIMER_EVENT)
N
N/**
N  * @brief Clear the RTC WakeUp Timer associated Exti line flag.
N  * @retval None.
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG()            (EXTI->PR = RTC_EXTI_LINE_WAKEUPTIMER_EVENT)
N
N/**
N  * @brief Generate a Software interrupt on the RTC WakeUp Timer associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_GENERATE_SWIT()         (EXTI->SWIER |= RTC_EXTI_LINE_WAKEUPTIMER_EVENT)
N
N/**
N  * @brief  Enable interrupt on the RTC Tamper and Timestamp associated Exti line.
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT()        (EXTI->IMR |= RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT)
N
N/**
N  * @brief  Disable interrupt on the RTC Tamper and Timestamp associated Exti line.
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_DISABLE_IT()       (EXTI->IMR &= ~(RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT))
N
N/**
N  * @brief  Enable event on the RTC Tamper and Timestamp associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_EVENT()    (EXTI->EMR |= RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT)
N
N/**
N  * @brief  Disable event on the RTC Tamper and Timestamp associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_DISABLE_EVENT()   (EXTI->EMR &= ~(RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT))
N
N/**
N  * @brief  Enable falling edge trigger on the RTC Tamper and Timestamp associated Exti line. 
N  * @retval None.
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_FALLING_EDGE()   (EXTI->FTSR |= RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT)
N
N/**
N  * @brief  Disable falling edge trigger on the RTC Tamper and Timestamp associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_DISABLE_FALLING_EDGE()  (EXTI->FTSR &= ~(RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT))
N
N/**
N  * @brief  Enable rising edge trigger on the RTC Tamper and Timestamp associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_RISING_EDGE()    (EXTI->RTSR |= RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT)
N
N/**
N  * @brief  Disable rising edge trigger on the RTC Tamper and Timestamp associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_DISABLE_RISING_EDGE()   (EXTI->RTSR &= ~(RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT))
N
N/**
N  * @brief  Enable rising & falling edge trigger on the RTC Tamper and Timestamp associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_RISING_FALLING_EDGE() __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_RISING_EDGE();__HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_FALLING_EDGE();
N
N/**
N  * @brief  Disable rising & falling edge trigger on the RTC Tamper and Timestamp associated Exti line.
N  * This parameter can be:
N  * @retval None.
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_DISABLE_RISING_FALLING_EDGE() __HAL_RTC_TAMPER_TIMESTAMP_EXTI_DISABLE_RISING_EDGE();__HAL_RTC_TAMPER_TIMESTAMP_EXTI_DISABLE_FALLING_EDGE();
N
N/**
N  * @brief Check whether the RTC Tamper and Timestamp associated Exti line interrupt flag is set or not.
N  * @retval Line Status.
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_GET_FLAG()         (EXTI->PR & RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT)
N
N/**
N  * @brief Clear the RTC Tamper and Timestamp associated Exti line flag.
N  * @retval None.
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_CLEAR_FLAG()       (EXTI->PR = RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT)
N
N/**
N  * @brief Generate a Software interrupt on the RTC Tamper and Timestamp associated Exti line
N  * @retval None.
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_GENERATE_SWIT()    (EXTI->SWIER |= RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT)
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup RTCEx_Exported_Functions RTCEx Exported Functions
N  * @{
N  */
N
N/** @addtogroup RTCEx_Exported_Functions_Group1
N  * @{
N  */
N
N/* RTC TimeStamp and Tamper functions *****************************************/
NHAL_StatusTypeDef HAL_RTCEx_SetTimeStamp(RTC_HandleTypeDef *hrtc, uint32_t TimeStampEdge, uint32_t RTC_TimeStampPin);
NHAL_StatusTypeDef HAL_RTCEx_SetTimeStamp_IT(RTC_HandleTypeDef *hrtc, uint32_t TimeStampEdge, uint32_t RTC_TimeStampPin);
NHAL_StatusTypeDef HAL_RTCEx_DeactivateTimeStamp(RTC_HandleTypeDef *hrtc);
NHAL_StatusTypeDef HAL_RTCEx_SetInternalTimeStamp(RTC_HandleTypeDef *hrtc);
NHAL_StatusTypeDef HAL_RTCEx_DeactivateInternalTimeStamp(RTC_HandleTypeDef *hrtc);
NHAL_StatusTypeDef HAL_RTCEx_GetTimeStamp(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTimeStamp, RTC_DateTypeDef *sTimeStampDate, uint32_t Format);
N
NHAL_StatusTypeDef HAL_RTCEx_SetTamper(RTC_HandleTypeDef *hrtc, RTC_TamperTypeDef* sTamper);
NHAL_StatusTypeDef HAL_RTCEx_SetTamper_IT(RTC_HandleTypeDef *hrtc, RTC_TamperTypeDef* sTamper);
NHAL_StatusTypeDef HAL_RTCEx_DeactivateTamper(RTC_HandleTypeDef *hrtc, uint32_t Tamper);
Nvoid              HAL_RTCEx_TamperTimeStampIRQHandler(RTC_HandleTypeDef *hrtc);
N
Nvoid              HAL_RTCEx_Tamper1EventCallback(RTC_HandleTypeDef *hrtc);
Nvoid              HAL_RTCEx_Tamper2EventCallback(RTC_HandleTypeDef *hrtc);
Nvoid              HAL_RTCEx_Tamper3EventCallback(RTC_HandleTypeDef *hrtc);
Nvoid              HAL_RTCEx_TimeStampEventCallback(RTC_HandleTypeDef *hrtc);
NHAL_StatusTypeDef HAL_RTCEx_PollForTimeStampEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout);
NHAL_StatusTypeDef HAL_RTCEx_PollForTamper1Event(RTC_HandleTypeDef *hrtc, uint32_t Timeout);
NHAL_StatusTypeDef HAL_RTCEx_PollForTamper2Event(RTC_HandleTypeDef *hrtc, uint32_t Timeout);
NHAL_StatusTypeDef HAL_RTCEx_PollForTamper3Event(RTC_HandleTypeDef *hrtc, uint32_t Timeout);
N/**
N  * @}
N  */
N
N/** @addtogroup RTCEx_Exported_Functions_Group2
N  * @{
N  */
N/* RTC Wake-up functions ******************************************************/
NHAL_StatusTypeDef HAL_RTCEx_SetWakeUpTimer(RTC_HandleTypeDef *hrtc, uint32_t WakeUpCounter, uint32_t WakeUpClock);
NHAL_StatusTypeDef HAL_RTCEx_SetWakeUpTimer_IT(RTC_HandleTypeDef *hrtc, uint32_t WakeUpCounter, uint32_t WakeUpClock);
Nuint32_t          HAL_RTCEx_DeactivateWakeUpTimer(RTC_HandleTypeDef *hrtc);
Nuint32_t          HAL_RTCEx_GetWakeUpTimer(RTC_HandleTypeDef *hrtc);
Nvoid              HAL_RTCEx_WakeUpTimerIRQHandler(RTC_HandleTypeDef *hrtc);
Nvoid              HAL_RTCEx_WakeUpTimerEventCallback(RTC_HandleTypeDef *hrtc);
NHAL_StatusTypeDef HAL_RTCEx_PollForWakeUpTimerEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout);
N/**
N  * @}
N  */
N
N/** @addtogroup RTCEx_Exported_Functions_Group3
N  * @{
N  */
N/* Extension Control functions ************************************************/
Nvoid              HAL_RTCEx_BKUPWrite(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister, uint32_t Data);
Nuint32_t          HAL_RTCEx_BKUPRead(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister);
N
NHAL_StatusTypeDef HAL_RTCEx_SetSmoothCalib(RTC_HandleTypeDef *hrtc, uint32_t SmoothCalibPeriod, uint32_t SmoothCalibPlusPulses, uint32_t SmouthCalibMinusPulsesValue);
NHAL_StatusTypeDef HAL_RTCEx_SetSynchroShift(RTC_HandleTypeDef *hrtc, uint32_t ShiftAdd1S, uint32_t ShiftSubFS);
NHAL_StatusTypeDef HAL_RTCEx_SetCalibrationOutPut(RTC_HandleTypeDef *hrtc, uint32_t CalibOutput);
NHAL_StatusTypeDef HAL_RTCEx_DeactivateCalibrationOutPut(RTC_HandleTypeDef *hrtc);
NHAL_StatusTypeDef HAL_RTCEx_SetRefClock(RTC_HandleTypeDef *hrtc);
NHAL_StatusTypeDef HAL_RTCEx_DeactivateRefClock(RTC_HandleTypeDef *hrtc);
NHAL_StatusTypeDef HAL_RTCEx_EnableBypassShadow(RTC_HandleTypeDef *hrtc);
NHAL_StatusTypeDef HAL_RTCEx_DisableBypassShadow(RTC_HandleTypeDef *hrtc);
N/**
N  * @}
N  */
N
N/** @addtogroup RTCEx_Exported_Functions_Group4
N  * @{
N  */
N/* Extension RTC features functions *******************************************/
Nvoid              HAL_RTCEx_AlarmBEventCallback(RTC_HandleTypeDef *hrtc); 
NHAL_StatusTypeDef HAL_RTCEx_PollForAlarmBEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout);
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N/* Private types -------------------------------------------------------------*/ 
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup RTCEx_Private_Constants RTCEx Private Constants
N  * @{
N  */
N#define RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT  ((uint32_t)EXTI_IMR_IM21)  /*!< External interrupt line 21 Connected to the RTC Tamper and Time Stamp events */                                               
N#define RTC_EXTI_LINE_WAKEUPTIMER_EVENT       ((uint32_t)EXTI_IMR_IM22)  /*!< External interrupt line 22 Connected to the RTC Wake-up event */  
N/**
N  * @}
N  */
N
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup RTCEx_Private_Constants RTCEx Private Constants
N  * @{
N  */
N/* Masks Definition */
N#define RTC_TAMPCR_TAMPXE     ((uint32_t) (RTC_TAMPCR_TAMP3E | RTC_TAMPCR_TAMP2E | RTC_TAMPCR_TAMP1E))
N#define RTC_TAMPCR_TAMPXIE    ((uint32_t) (RTC_TAMPER1_INTERRUPT | RTC_TAMPER2_INTERRUPT | RTC_TAMPER3_INTERRUPT | RTC_ALL_TAMPER_INTERRUPT))
N/**
N  * @}
N  */
N  
N/* Private macros ------------------------------------------------------------*/   
N/** @defgroup RTCEx_Private_Macros RTCEx Private Macros
N  * @{
N  */
N
N/** @defgroup RTCEx_IS_RTC_Definitions Private macros to check input parameters
N  * @{
N  */
N#define IS_RTC_OUTPUT(__OUTPUT__)      (((__OUTPUT__) == RTC_OUTPUT_DISABLE) || \
N                                        ((__OUTPUT__) == RTC_OUTPUT_ALARMA)  || \
N                                        ((__OUTPUT__) == RTC_OUTPUT_ALARMB)  || \
N                                        ((__OUTPUT__) == RTC_OUTPUT_WAKEUP))
X#define IS_RTC_OUTPUT(__OUTPUT__)      (((__OUTPUT__) == RTC_OUTPUT_DISABLE) ||                                         ((__OUTPUT__) == RTC_OUTPUT_ALARMA)  ||                                         ((__OUTPUT__) == RTC_OUTPUT_ALARMB)  ||                                         ((__OUTPUT__) == RTC_OUTPUT_WAKEUP))
N#define IS_RTC_BKP(__BKP__)               ((__BKP__) < (uint32_t) RTC_BKP_NUMBER)
N#define IS_TIMESTAMP_EDGE(__EDGE__) (((__EDGE__) == RTC_TIMESTAMPEDGE_RISING) || \
N                                     ((__EDGE__) == RTC_TIMESTAMPEDGE_FALLING))
X#define IS_TIMESTAMP_EDGE(__EDGE__) (((__EDGE__) == RTC_TIMESTAMPEDGE_RISING) ||                                      ((__EDGE__) == RTC_TIMESTAMPEDGE_FALLING))
N#define IS_RTC_TAMPER(__TAMPER__)   ((((__TAMPER__) & ((uint32_t)(0xFFFFFFFFU ^ RTC_TAMPCR_TAMPXE))) == 0x00U) && ((__TAMPER__) != (uint32_t)RESET))
N
N#define IS_RTC_TAMPER_INTERRUPT(__INTERRUPT__)  ((((__INTERRUPT__) & (uint32_t)(0xFFFFFFFFU ^ RTC_TAMPCR_TAMPXIE)) == 0x00U) && ((__INTERRUPT__) != (uint32_t)RESET))
N
N#define IS_RTC_TIMESTAMP_PIN(__PIN__) (((__PIN__) == RTC_TIMESTAMPPIN_DEFAULT) || \
N                                       ((__PIN__) == RTC_TIMESTAMPPIN_POS1)  || \
N                                       ((__PIN__) == RTC_TIMESTAMPPIN_POS2))
X#define IS_RTC_TIMESTAMP_PIN(__PIN__) (((__PIN__) == RTC_TIMESTAMPPIN_DEFAULT) ||                                        ((__PIN__) == RTC_TIMESTAMPPIN_POS1)  ||                                        ((__PIN__) == RTC_TIMESTAMPPIN_POS2))
N#define IS_RTC_TAMPER_TRIGGER(__TRIGGER__) (((__TRIGGER__) == RTC_TAMPERTRIGGER_RISINGEDGE) || \
N                                        ((__TRIGGER__) == RTC_TAMPERTRIGGER_FALLINGEDGE) || \
N                                        ((__TRIGGER__) == RTC_TAMPERTRIGGER_LOWLEVEL) || \
N                                        ((__TRIGGER__) == RTC_TAMPERTRIGGER_HIGHLEVEL))
X#define IS_RTC_TAMPER_TRIGGER(__TRIGGER__) (((__TRIGGER__) == RTC_TAMPERTRIGGER_RISINGEDGE) ||                                         ((__TRIGGER__) == RTC_TAMPERTRIGGER_FALLINGEDGE) ||                                         ((__TRIGGER__) == RTC_TAMPERTRIGGER_LOWLEVEL) ||                                         ((__TRIGGER__) == RTC_TAMPERTRIGGER_HIGHLEVEL))
N#define IS_RTC_TAMPER_ERASE_MODE(__MODE__)             (((__MODE__) == RTC_TAMPER_ERASE_BACKUP_ENABLE) || \
N                                                        ((__MODE__) == RTC_TAMPER_ERASE_BACKUP_DISABLE))
X#define IS_RTC_TAMPER_ERASE_MODE(__MODE__)             (((__MODE__) == RTC_TAMPER_ERASE_BACKUP_ENABLE) ||                                                         ((__MODE__) == RTC_TAMPER_ERASE_BACKUP_DISABLE))
N#define IS_RTC_TAMPER_MASKFLAG_STATE(__STATE__)     (((__STATE__) == RTC_TAMPERMASK_FLAG_ENABLE) || \
N                                                     ((__STATE__) == RTC_TAMPERMASK_FLAG_DISABLE))
X#define IS_RTC_TAMPER_MASKFLAG_STATE(__STATE__)     (((__STATE__) == RTC_TAMPERMASK_FLAG_ENABLE) ||                                                      ((__STATE__) == RTC_TAMPERMASK_FLAG_DISABLE))
N#define IS_RTC_TAMPER_FILTER(__FILTER__)  (((__FILTER__) == RTC_TAMPERFILTER_DISABLE) || \
N                                       ((__FILTER__) == RTC_TAMPERFILTER_2SAMPLE) || \
N                                       ((__FILTER__) == RTC_TAMPERFILTER_4SAMPLE) || \
N                                       ((__FILTER__) == RTC_TAMPERFILTER_8SAMPLE))
X#define IS_RTC_TAMPER_FILTER(__FILTER__)  (((__FILTER__) == RTC_TAMPERFILTER_DISABLE) ||                                        ((__FILTER__) == RTC_TAMPERFILTER_2SAMPLE) ||                                        ((__FILTER__) == RTC_TAMPERFILTER_4SAMPLE) ||                                        ((__FILTER__) == RTC_TAMPERFILTER_8SAMPLE))
N#define IS_RTC_TAMPER_SAMPLING_FREQ(__FREQ__) (((__FREQ__) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV32768)|| \
N                                           ((__FREQ__) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV16384)|| \
N                                           ((__FREQ__) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV8192) || \
N                                           ((__FREQ__) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV4096) || \
N                                           ((__FREQ__) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV2048) || \
N                                           ((__FREQ__) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV1024) || \
N                                           ((__FREQ__) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV512)  || \
N                                           ((__FREQ__) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV256))
X#define IS_RTC_TAMPER_SAMPLING_FREQ(__FREQ__) (((__FREQ__) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV32768)||                                            ((__FREQ__) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV16384)||                                            ((__FREQ__) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV8192) ||                                            ((__FREQ__) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV4096) ||                                            ((__FREQ__) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV2048) ||                                            ((__FREQ__) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV1024) ||                                            ((__FREQ__) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV512)  ||                                            ((__FREQ__) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV256))
N#define IS_RTC_TAMPER_PRECHARGE_DURATION(__DURATION__) (((__DURATION__) == RTC_TAMPERPRECHARGEDURATION_1RTCCLK) || \
N                                                    ((__DURATION__) == RTC_TAMPERPRECHARGEDURATION_2RTCCLK) || \
N                                                    ((__DURATION__) == RTC_TAMPERPRECHARGEDURATION_4RTCCLK) || \
N                                                    ((__DURATION__) == RTC_TAMPERPRECHARGEDURATION_8RTCCLK))
X#define IS_RTC_TAMPER_PRECHARGE_DURATION(__DURATION__) (((__DURATION__) == RTC_TAMPERPRECHARGEDURATION_1RTCCLK) ||                                                     ((__DURATION__) == RTC_TAMPERPRECHARGEDURATION_2RTCCLK) ||                                                     ((__DURATION__) == RTC_TAMPERPRECHARGEDURATION_4RTCCLK) ||                                                     ((__DURATION__) == RTC_TAMPERPRECHARGEDURATION_8RTCCLK))
N#define IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION(__DETECTION__) (((__DETECTION__) == RTC_TIMESTAMPONTAMPERDETECTION_ENABLE) || \
N                                                              ((__DETECTION__) == RTC_TIMESTAMPONTAMPERDETECTION_DISABLE))
X#define IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION(__DETECTION__) (((__DETECTION__) == RTC_TIMESTAMPONTAMPERDETECTION_ENABLE) ||                                                               ((__DETECTION__) == RTC_TIMESTAMPONTAMPERDETECTION_DISABLE))
N#define IS_RTC_TAMPER_PULLUP_STATE(__STATE__) (((__STATE__) == RTC_TAMPER_PULLUP_ENABLE) || \
N                                       ((__STATE__) == RTC_TAMPER_PULLUP_DISABLE))
X#define IS_RTC_TAMPER_PULLUP_STATE(__STATE__) (((__STATE__) == RTC_TAMPER_PULLUP_ENABLE) ||                                        ((__STATE__) == RTC_TAMPER_PULLUP_DISABLE))
N#define IS_RTC_WAKEUP_CLOCK(__CLOCK__) (((__CLOCK__) == RTC_WAKEUPCLOCK_RTCCLK_DIV16)       || \
N                                    ((__CLOCK__) == RTC_WAKEUPCLOCK_RTCCLK_DIV8)    || \
N                                    ((__CLOCK__) == RTC_WAKEUPCLOCK_RTCCLK_DIV4)    || \
N                                    ((__CLOCK__) == RTC_WAKEUPCLOCK_RTCCLK_DIV2)    || \
N                                    ((__CLOCK__) == RTC_WAKEUPCLOCK_CK_SPRE_16BITS) || \
N                                    ((__CLOCK__) == RTC_WAKEUPCLOCK_CK_SPRE_17BITS))
X#define IS_RTC_WAKEUP_CLOCK(__CLOCK__) (((__CLOCK__) == RTC_WAKEUPCLOCK_RTCCLK_DIV16)       ||                                     ((__CLOCK__) == RTC_WAKEUPCLOCK_RTCCLK_DIV8)    ||                                     ((__CLOCK__) == RTC_WAKEUPCLOCK_RTCCLK_DIV4)    ||                                     ((__CLOCK__) == RTC_WAKEUPCLOCK_RTCCLK_DIV2)    ||                                     ((__CLOCK__) == RTC_WAKEUPCLOCK_CK_SPRE_16BITS) ||                                     ((__CLOCK__) == RTC_WAKEUPCLOCK_CK_SPRE_17BITS))
N
N#define IS_RTC_WAKEUP_COUNTER(__COUNTER__)  ((__COUNTER__) <= 0xFFFF)
N#define IS_RTC_SMOOTH_CALIB_PERIOD(__PERIOD__) (((__PERIOD__) == RTC_SMOOTHCALIB_PERIOD_32SEC) || \
N                                                ((__PERIOD__) == RTC_SMOOTHCALIB_PERIOD_16SEC) || \
N                                                ((__PERIOD__) == RTC_SMOOTHCALIB_PERIOD_8SEC))
X#define IS_RTC_SMOOTH_CALIB_PERIOD(__PERIOD__) (((__PERIOD__) == RTC_SMOOTHCALIB_PERIOD_32SEC) ||                                                 ((__PERIOD__) == RTC_SMOOTHCALIB_PERIOD_16SEC) ||                                                 ((__PERIOD__) == RTC_SMOOTHCALIB_PERIOD_8SEC))
N#define IS_RTC_SMOOTH_CALIB_PLUS(__PLUS__) (((__PLUS__) == RTC_SMOOTHCALIB_PLUSPULSES_SET) || \
N                                            ((__PLUS__) == RTC_SMOOTHCALIB_PLUSPULSES_RESET))
X#define IS_RTC_SMOOTH_CALIB_PLUS(__PLUS__) (((__PLUS__) == RTC_SMOOTHCALIB_PLUSPULSES_SET) ||                                             ((__PLUS__) == RTC_SMOOTHCALIB_PLUSPULSES_RESET))
N#define  IS_RTC_SMOOTH_CALIB_MINUS(__VALUE__) ((__VALUE__) <= 0x000001FF)
N#define IS_RTC_SHIFT_ADD1S(__SEL__) (((__SEL__) == RTC_SHIFTADD1S_RESET) || \
N                                     ((__SEL__) == RTC_SHIFTADD1S_SET))
X#define IS_RTC_SHIFT_ADD1S(__SEL__) (((__SEL__) == RTC_SHIFTADD1S_RESET) ||                                      ((__SEL__) == RTC_SHIFTADD1S_SET))
N#define IS_RTC_SHIFT_SUBFS(__FS__) ((__FS__) <= 0x00007FFF)
N#define IS_RTC_CALIB_OUTPUT(__OUTPUT__)  (((__OUTPUT__) == RTC_CALIBOUTPUT_512HZ) || \
N                                          ((__OUTPUT__) == RTC_CALIBOUTPUT_1HZ))
X#define IS_RTC_CALIB_OUTPUT(__OUTPUT__)  (((__OUTPUT__) == RTC_CALIBOUTPUT_512HZ) ||                                           ((__OUTPUT__) == RTC_CALIBOUTPUT_1HZ))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_RTC_EX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 626 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_rtc.h" 2
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup RTC_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup RTC_Exported_Functions_Group1
N  * @{
N  */
N/* Initialization and de-initialization functions  ****************************/
NHAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc);
NHAL_StatusTypeDef HAL_RTC_DeInit(RTC_HandleTypeDef *hrtc);
Nvoid       HAL_RTC_MspInit(RTC_HandleTypeDef *hrtc);
Nvoid       HAL_RTC_MspDeInit(RTC_HandleTypeDef *hrtc);
N/**
N  * @}
N  */
N
N/** @addtogroup RTC_Exported_Functions_Group2
N  * @{
N  */
N/* RTC Time and Date functions ************************************************/
NHAL_StatusTypeDef HAL_RTC_SetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format);
NHAL_StatusTypeDef HAL_RTC_GetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format);
NHAL_StatusTypeDef HAL_RTC_SetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format);
NHAL_StatusTypeDef HAL_RTC_GetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format);
N/**
N  * @}
N  */
N
N/** @addtogroup RTC_Exported_Functions_Group3
N  * @{
N  */
N/* RTC Alarm functions ********************************************************/
NHAL_StatusTypeDef HAL_RTC_SetAlarm(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format);
NHAL_StatusTypeDef HAL_RTC_SetAlarm_IT(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format);
NHAL_StatusTypeDef HAL_RTC_DeactivateAlarm(RTC_HandleTypeDef *hrtc, uint32_t Alarm);
NHAL_StatusTypeDef HAL_RTC_GetAlarm(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Alarm, uint32_t Format);
Nvoid                HAL_RTC_AlarmIRQHandler(RTC_HandleTypeDef *hrtc);
NHAL_StatusTypeDef   HAL_RTC_PollForAlarmAEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout);
Nvoid         HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc);
N/**
N  * @}
N  */
N
N/** @addtogroup RTC_Exported_Functions_Group4
N  * @{
N  */
N/* Peripheral Control functions ***********************************************/
NHAL_StatusTypeDef   HAL_RTC_WaitForSynchro(RTC_HandleTypeDef* hrtc);
N/**
N  * @}
N  */
N
N/** @addtogroup RTC_Exported_Functions_Group5
N  * @{
N  */
N/* Peripheral State functions *************************************************/
NHAL_RTCStateTypeDef HAL_RTC_GetState(RTC_HandleTypeDef *hrtc);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup RTC_Private_Constants RTC Private Constants
N  * @{
N  */
N/* Masks Definition */
N#define RTC_TR_RESERVED_MASK    ((uint32_t)0x007F7F7FU)
N#define RTC_DR_RESERVED_MASK    ((uint32_t)0x00FFFF3FU) 
N#define RTC_INIT_MASK           ((uint32_t)0xFFFFFFFFU)  
N#define RTC_RSF_MASK            ((uint32_t)0xFFFFFF5FU)
N
N#define RTC_TIMEOUT_VALUE       1000
N
N#define RTC_EXTI_LINE_ALARM_EVENT             ((uint32_t)EXTI_IMR_IM17)  /*!< External interrupt line 17 Connected to the RTC Alarm event */
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup RTC_Private_Macros RTC Private Macros
N  * @{
N  */
N
N/** @defgroup RTC_IS_RTC_Definitions RTC Private macros to check input parameters
N  * @{
N  */
N#define IS_RTC_HOUR_FORMAT(__FORMAT__) (((__FORMAT__) == RTC_HOURFORMAT_12) || \
N                                        ((__FORMAT__) == RTC_HOURFORMAT_24))
X#define IS_RTC_HOUR_FORMAT(__FORMAT__) (((__FORMAT__) == RTC_HOURFORMAT_12) ||                                         ((__FORMAT__) == RTC_HOURFORMAT_24))
N#define IS_RTC_OUTPUT_POL(__POL__)     (((__POL__) == RTC_OUTPUT_POLARITY_HIGH) || \
N                                        ((__POL__) == RTC_OUTPUT_POLARITY_LOW))
X#define IS_RTC_OUTPUT_POL(__POL__)     (((__POL__) == RTC_OUTPUT_POLARITY_HIGH) ||                                         ((__POL__) == RTC_OUTPUT_POLARITY_LOW))
N#define IS_RTC_OUTPUT_TYPE(__TYPE__)   (((__TYPE__) == RTC_OUTPUT_TYPE_OPENDRAIN) || \
N                                        ((__TYPE__) == RTC_OUTPUT_TYPE_PUSHPULL))
X#define IS_RTC_OUTPUT_TYPE(__TYPE__)   (((__TYPE__) == RTC_OUTPUT_TYPE_OPENDRAIN) ||                                         ((__TYPE__) == RTC_OUTPUT_TYPE_PUSHPULL))
N#define IS_RTC_ASYNCH_PREDIV(__PREDIV__)   ((__PREDIV__) <= (uint32_t)0x7F) 
N#define IS_RTC_SYNCH_PREDIV(__PREDIV__)    ((__PREDIV__) <= (uint32_t)0x7FFF)
N#define IS_RTC_HOUR12(__HOUR__)            (((__HOUR__) > (uint32_t)0) && ((__HOUR__) <= (uint32_t)12))
N#define IS_RTC_HOUR24(__HOUR__)            ((__HOUR__) <= (uint32_t)23)
N#define IS_RTC_MINUTES(__MINUTES__)        ((__MINUTES__) <= (uint32_t)59)
N#define IS_RTC_SECONDS(__SECONDS__)        ((__SECONDS__) <= (uint32_t)59)
N#define IS_RTC_HOURFORMAT12(__PM__)  (((__PM__) == RTC_HOURFORMAT12_AM) || ((__PM__) == RTC_HOURFORMAT12_PM))
N#define IS_RTC_DAYLIGHT_SAVING(__SAVE__) (((__SAVE__) == RTC_DAYLIGHTSAVING_SUB1H) || \
N                                          ((__SAVE__) == RTC_DAYLIGHTSAVING_ADD1H) || \
N                                          ((__SAVE__) == RTC_DAYLIGHTSAVING_NONE))
X#define IS_RTC_DAYLIGHT_SAVING(__SAVE__) (((__SAVE__) == RTC_DAYLIGHTSAVING_SUB1H) ||                                           ((__SAVE__) == RTC_DAYLIGHTSAVING_ADD1H) ||                                           ((__SAVE__) == RTC_DAYLIGHTSAVING_NONE))
N#define IS_RTC_STORE_OPERATION(__OPERATION__) (((__OPERATION__) == RTC_STOREOPERATION_RESET) || \
N                                               ((__OPERATION__) == RTC_STOREOPERATION_SET))
X#define IS_RTC_STORE_OPERATION(__OPERATION__) (((__OPERATION__) == RTC_STOREOPERATION_RESET) ||                                                ((__OPERATION__) == RTC_STOREOPERATION_SET))
N#define IS_RTC_FORMAT(__FORMAT__) (((__FORMAT__) == RTC_FORMAT_BIN) || ((__FORMAT__) == RTC_FORMAT_BCD))
N#define IS_RTC_YEAR(__YEAR__)              ((__YEAR__) <= (uint32_t)99)
N#define IS_RTC_MONTH(__MONTH__)            (((__MONTH__) >= (uint32_t)1) && ((__MONTH__) <= (uint32_t)12))
N#define IS_RTC_DATE(__DATE__)              (((__DATE__) >= (uint32_t)1) && ((__DATE__) <= (uint32_t)31))
N#define IS_RTC_WEEKDAY(__WEEKDAY__) (((__WEEKDAY__) == RTC_WEEKDAY_MONDAY)    || \
N                                     ((__WEEKDAY__) == RTC_WEEKDAY_TUESDAY)   || \
N                                     ((__WEEKDAY__) == RTC_WEEKDAY_WEDNESDAY) || \
N                                     ((__WEEKDAY__) == RTC_WEEKDAY_THURSDAY)  || \
N                                     ((__WEEKDAY__) == RTC_WEEKDAY_FRIDAY)    || \
N                                     ((__WEEKDAY__) == RTC_WEEKDAY_SATURDAY)  || \
N                                     ((__WEEKDAY__) == RTC_WEEKDAY_SUNDAY))
X#define IS_RTC_WEEKDAY(__WEEKDAY__) (((__WEEKDAY__) == RTC_WEEKDAY_MONDAY)    ||                                      ((__WEEKDAY__) == RTC_WEEKDAY_TUESDAY)   ||                                      ((__WEEKDAY__) == RTC_WEEKDAY_WEDNESDAY) ||                                      ((__WEEKDAY__) == RTC_WEEKDAY_THURSDAY)  ||                                      ((__WEEKDAY__) == RTC_WEEKDAY_FRIDAY)    ||                                      ((__WEEKDAY__) == RTC_WEEKDAY_SATURDAY)  ||                                      ((__WEEKDAY__) == RTC_WEEKDAY_SUNDAY))
N
N#define IS_RTC_ALARM_DATE_WEEKDAY_DATE(__DATE__) (((__DATE__) >(uint32_t) 0) && ((__DATE__) <= (uint32_t)31))
N#define IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(__WEEKDAY__) (((__WEEKDAY__) == RTC_WEEKDAY_MONDAY)    || \
N                                                        ((__WEEKDAY__) == RTC_WEEKDAY_TUESDAY)   || \
N                                                        ((__WEEKDAY__) == RTC_WEEKDAY_WEDNESDAY) || \
N                                                        ((__WEEKDAY__) == RTC_WEEKDAY_THURSDAY)  || \
N                                                        ((__WEEKDAY__) == RTC_WEEKDAY_FRIDAY)    || \
N                                                        ((__WEEKDAY__) == RTC_WEEKDAY_SATURDAY)  || \
N                                                        ((__WEEKDAY__) == RTC_WEEKDAY_SUNDAY))
X#define IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(__WEEKDAY__) (((__WEEKDAY__) == RTC_WEEKDAY_MONDAY)    ||                                                         ((__WEEKDAY__) == RTC_WEEKDAY_TUESDAY)   ||                                                         ((__WEEKDAY__) == RTC_WEEKDAY_WEDNESDAY) ||                                                         ((__WEEKDAY__) == RTC_WEEKDAY_THURSDAY)  ||                                                         ((__WEEKDAY__) == RTC_WEEKDAY_FRIDAY)    ||                                                         ((__WEEKDAY__) == RTC_WEEKDAY_SATURDAY)  ||                                                         ((__WEEKDAY__) == RTC_WEEKDAY_SUNDAY))
N#define IS_RTC_ALARM_DATE_WEEKDAY_SEL(__SEL__) (((__SEL__) == RTC_ALARMDATEWEEKDAYSEL_DATE) || \
N                                                ((__SEL__) == RTC_ALARMDATEWEEKDAYSEL_WEEKDAY))
X#define IS_RTC_ALARM_DATE_WEEKDAY_SEL(__SEL__) (((__SEL__) == RTC_ALARMDATEWEEKDAYSEL_DATE) ||                                                 ((__SEL__) == RTC_ALARMDATEWEEKDAYSEL_WEEKDAY))
N#define IS_RTC_ALARM_MASK(__MASK__)  (((__MASK__) & 0x7F7F7F7F) == (uint32_t)RESET)
N#define IS_RTC_ALARM(__ALARM__)      (((__ALARM__) == RTC_ALARM_A) || ((__ALARM__) == RTC_ALARM_B))
N#define IS_RTC_ALARM_SUB_SECOND_VALUE(__VALUE__) ((__VALUE__) <= (uint32_t)0x00007FFF)
N#define IS_RTC_ALARM_SUB_SECOND_MASK(__MASK__)   (((__MASK__) == RTC_ALARMSUBSECONDMASK_ALL) || \
N                                                  ((__MASK__) == RTC_ALARMSUBSECONDMASK_SS14_1) || \
N                                                  ((__MASK__) == RTC_ALARMSUBSECONDMASK_SS14_2) || \
N                                                  ((__MASK__) == RTC_ALARMSUBSECONDMASK_SS14_3) || \
N                                                  ((__MASK__) == RTC_ALARMSUBSECONDMASK_SS14_4) || \
N                                                  ((__MASK__) == RTC_ALARMSUBSECONDMASK_SS14_5) || \
N                                                  ((__MASK__) == RTC_ALARMSUBSECONDMASK_SS14_6) || \
N                                                  ((__MASK__) == RTC_ALARMSUBSECONDMASK_SS14_7) || \
N                                                  ((__MASK__) == RTC_ALARMSUBSECONDMASK_SS14_8) || \
N                                                  ((__MASK__) == RTC_ALARMSUBSECONDMASK_SS14_9) || \
N                                                  ((__MASK__) == RTC_ALARMSUBSECONDMASK_SS14_10) || \
N                                                  ((__MASK__) == RTC_ALARMSUBSECONDMASK_SS14_11) || \
N                                                  ((__MASK__) == RTC_ALARMSUBSECONDMASK_SS14_12) || \
N                                                  ((__MASK__) == RTC_ALARMSUBSECONDMASK_SS14_13) || \
N                                                  ((__MASK__) == RTC_ALARMSUBSECONDMASK_SS14) || \
N                                                  ((__MASK__) == RTC_ALARMSUBSECONDMASK_NONE))
X#define IS_RTC_ALARM_SUB_SECOND_MASK(__MASK__)   (((__MASK__) == RTC_ALARMSUBSECONDMASK_ALL) ||                                                   ((__MASK__) == RTC_ALARMSUBSECONDMASK_SS14_1) ||                                                   ((__MASK__) == RTC_ALARMSUBSECONDMASK_SS14_2) ||                                                   ((__MASK__) == RTC_ALARMSUBSECONDMASK_SS14_3) ||                                                   ((__MASK__) == RTC_ALARMSUBSECONDMASK_SS14_4) ||                                                   ((__MASK__) == RTC_ALARMSUBSECONDMASK_SS14_5) ||                                                   ((__MASK__) == RTC_ALARMSUBSECONDMASK_SS14_6) ||                                                   ((__MASK__) == RTC_ALARMSUBSECONDMASK_SS14_7) ||                                                   ((__MASK__) == RTC_ALARMSUBSECONDMASK_SS14_8) ||                                                   ((__MASK__) == RTC_ALARMSUBSECONDMASK_SS14_9) ||                                                   ((__MASK__) == RTC_ALARMSUBSECONDMASK_SS14_10) ||                                                   ((__MASK__) == RTC_ALARMSUBSECONDMASK_SS14_11) ||                                                   ((__MASK__) == RTC_ALARMSUBSECONDMASK_SS14_12) ||                                                   ((__MASK__) == RTC_ALARMSUBSECONDMASK_SS14_13) ||                                                   ((__MASK__) == RTC_ALARMSUBSECONDMASK_SS14) ||                                                   ((__MASK__) == RTC_ALARMSUBSECONDMASK_NONE))
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup RTC_Private_Functions RTC Private Functions
N  * @{
N  */
NHAL_StatusTypeDef  RTC_EnterInitMode(RTC_HandleTypeDef* hrtc);
Nuint8_t            RTC_ByteToBcd2(uint8_t Value);
Nuint8_t            RTC_Bcd2ToByte(uint8_t Value);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_RTC_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 355 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_RTC_MODULE_ENABLED */
N
N#ifdef HAL_SAI_MODULE_ENABLED
N #include "stm32f7xx_hal_sai.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_sai.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_sai.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of SAI HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_SAI_H
N#define __STM32F7xx_HAL_SAI_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup SAI
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup SAI_Exported_Types SAI Exported Types
N  * @{
N  */
N
N/**
N  * @brief  HAL State structures definition
N  */
Ntypedef enum
N{
N  HAL_SAI_STATE_RESET    = 0x00U,  /*!< SAI not yet initialized or disabled                */
N  HAL_SAI_STATE_READY    = 0x01U,  /*!< SAI initialized and ready for use                  */
N  HAL_SAI_STATE_BUSY     = 0x02U,  /*!< SAI internal process is ongoing                    */
N  HAL_SAI_STATE_BUSY_TX  = 0x12U,  /*!< Data transmission process is ongoing               */
N  HAL_SAI_STATE_BUSY_RX  = 0x22U,  /*!< Data reception process is ongoing                  */
N}HAL_SAI_StateTypeDef;
N
N/**
N  * @brief  SAI Callback prototype
N  */
Ntypedef void (*SAIcallback)(void);
N
N/** @defgroup SAI_Init_Structure_definition SAI Init Structure definition
N  * @brief  SAI Init Structure definition
N  * @{
N  */
Ntypedef struct
N{
N  uint32_t AudioMode;           /*!< Specifies the SAI Block audio Mode.
N                                     This parameter can be a value of @ref SAI_Block_Mode */
N
N  uint32_t Synchro;             /*!< Specifies SAI Block synchronization
N                                     This parameter can be a value of @ref SAI_Block_Synchronization */
N
N  uint32_t SynchroExt;          /*!< Specifies SAI external output synchronization, this setup is common
N                                     for BlockA and BlockB
N                                     This parameter can be a value of @ref SAI_Block_SyncExt
N                                     @note: If both audio blocks of same SAI are used, this parameter has
N                                            to be set to the same value for each audio block */
N
N  uint32_t OutputDrive;         /*!< Specifies when SAI Block outputs are driven.
N                                     This parameter can be a value of @ref SAI_Block_Output_Drive
N                                     @note this value has to be set before enabling the audio block
N                                     but after the audio block configuration. */
N
N  uint32_t NoDivider;           /*!< Specifies whether master clock will be divided or not.
N                                     This parameter can be a value of @ref SAI_Block_NoDivider
N                                     @note: If bit NODIV in the SAI_xCR1 register is cleared, the frame length
N                                            should be aligned to a number equal to a power of 2, from 8 to 256.
N                                            If bit NODIV in the SAI_xCR1 register is set, the frame length can
N                                            take any of the values without constraint since the input clock of
N                                            the audio block should be equal to the bit clock.
N                                            There is no MCLK_x clock which can be output. */
N
N  uint32_t FIFOThreshold;       /*!< Specifies SAI Block FIFO threshold.
N                                     This parameter can be a value of @ref SAI_Block_Fifo_Threshold */
N
N  uint32_t AudioFrequency;      /*!< Specifies the audio frequency sampling.
N                                     This parameter can be a value of @ref SAI_Audio_Frequency */
N
N  uint32_t Mckdiv;              /*!< Specifies the master clock divider, the parameter will be used if for
N                                     AudioFrequency the user choice
N                                     This parameter must be a number between Min_Data = 0 and Max_Data = 15 */
N
N  uint32_t MonoStereoMode;      /*!< Specifies if the mono or stereo mode is selected.
N                                     This parameter can be a value of @ref SAI_Mono_Stereo_Mode */
N
N  uint32_t CompandingMode;      /*!< Specifies the companding mode type.
N                                     This parameter can be a value of @ref SAI_Block_Companding_Mode */
N
N  uint32_t TriState;            /*!< Specifies the companding mode type.
N                                     This parameter can be a value of @ref SAI_TRIState_Management */
N
N  /* This part of the structure is automatically filled if your are using the high level initialisation
N     function HAL_SAI_InitProtocol */
N
N  uint32_t Protocol;        /*!< Specifies the SAI Block protocol.
N                                 This parameter can be a value of @ref SAI_Block_Protocol */
N
N  uint32_t DataSize;        /*!< Specifies the SAI Block data size.
N                                 This parameter can be a value of @ref SAI_Block_Data_Size */
N
N  uint32_t FirstBit;        /*!< Specifies whether data transfers start from MSB or LSB bit.
N                                 This parameter can be a value of @ref SAI_Block_MSB_LSB_transmission */
N
N  uint32_t ClockStrobing;   /*!< Specifies the SAI Block clock strobing edge sensitivity.
N                                 This parameter can be a value of @ref SAI_Block_Clock_Strobing */
N}SAI_InitTypeDef;
N/**
N  * @}
N  */
N
N/** @defgroup SAI_Frame_Structure_definition SAI Frame Structure definition
N  * @brief  SAI Frame Init structure definition
N  * @{
N  */
Ntypedef struct
N{
N
N  uint32_t FrameLength;        /*!< Specifies the Frame length, the number of SCK clocks for each audio frame.
N                                    This parameter must be a number between Min_Data = 8 and Max_Data = 256.
N                                    @note: If master clock MCLK_x pin is declared as an output, the frame length
N                                           should be aligned to a number equal to power of 2 in order to keep
N                                           in an audio frame, an integer number of MCLK pulses by bit Clock. */
N
N  uint32_t ActiveFrameLength;  /*!< Specifies the Frame synchronization active level length.
N                                    This Parameter specifies the length in number of bit clock (SCK + 1)
N                                    of the active level of FS signal in audio frame.
N                                    This parameter must be a number between Min_Data = 1 and Max_Data = 128 */
N
N  uint32_t FSDefinition;       /*!< Specifies the Frame synchronization definition.
N                                    This parameter can be a value of @ref SAI_Block_FS_Definition */
N
N  uint32_t FSPolarity;         /*!< Specifies the Frame synchronization Polarity.
N                                    This parameter can be a value of @ref SAI_Block_FS_Polarity */
N
N  uint32_t FSOffset;           /*!< Specifies the Frame synchronization Offset.
N                                    This parameter can be a value of @ref SAI_Block_FS_Offset */
N
N}SAI_FrameInitTypeDef;
N/**
N  * @}
N  */
N
N/** @defgroup SAI_Slot_Structure_definition SAI Slot Structure definition
N  * @brief   SAI Block Slot Init Structure definition
N  * @{
N  */
Ntypedef struct
N{
N  uint32_t FirstBitOffset;  /*!< Specifies the position of first data transfer bit in the slot.
N                                 This parameter must be a number between Min_Data = 0 and Max_Data = 24 */
N
N  uint32_t SlotSize;        /*!< Specifies the Slot Size.
N                                 This parameter can be a value of @ref SAI_Block_Slot_Size */
N
N  uint32_t SlotNumber;      /*!< Specifies the number of slot in the audio frame.
N                                 This parameter must be a number between Min_Data = 1 and Max_Data = 16 */
N
N  uint32_t SlotActive;      /*!< Specifies the slots in audio frame that will be activated.
N                                 This parameter can be a value of @ref SAI_Block_Slot_Active */
N}SAI_SlotInitTypeDef;
N/**
N  * @}
N  */
N
N/** @defgroup SAI_Handle_Structure_definition SAI Handle Structure definition
N  * @brief  SAI handle Structure definition
N  * @{
N  */
Ntypedef struct __SAI_HandleTypeDef
N{
N  SAI_Block_TypeDef         *Instance;    /*!< SAI Blockx registers base address */
N
N  SAI_InitTypeDef           Init;         /*!< SAI communication parameters */
N
N  SAI_FrameInitTypeDef      FrameInit;    /*!< SAI Frame configuration parameters */
N
N  SAI_SlotInitTypeDef       SlotInit;     /*!< SAI Slot configuration parameters */
N
N  uint8_t                  *pBuffPtr;     /*!< Pointer to SAI transfer Buffer */
N
N  uint16_t                  XferSize;     /*!< SAI transfer size */
N
N  uint16_t                  XferCount;    /*!< SAI transfer counter */
N
N  DMA_HandleTypeDef         *hdmatx;      /*!< SAI Tx DMA handle parameters */
N
N  DMA_HandleTypeDef         *hdmarx;      /*!< SAI Rx DMA handle parameters */
N
N  SAIcallback               mutecallback; /*!< SAI mute callback */
N
N  void (*InterruptServiceRoutine)(struct __SAI_HandleTypeDef *hsai); /* function pointer for IRQ handler */
N
N  HAL_LockTypeDef           Lock;         /*!< SAI locking object */
N
N  __IO HAL_SAI_StateTypeDef State;        /*!< SAI communication state */
X  volatile HAL_SAI_StateTypeDef State;         
N
N  __IO uint32_t             ErrorCode;    /*!< SAI Error code */
X  volatile uint32_t             ErrorCode;     
N}SAI_HandleTypeDef;
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup SAI_Exported_Constants SAI Exported Constants
N  * @{
N  */
N
N/** @defgroup SAI_Error_Code SAI Error Code
N  * @{
N  */
N#define HAL_SAI_ERROR_NONE    ((uint32_t)0x00000000U)  /*!< No error                                    */
N#define HAL_SAI_ERROR_OVR     ((uint32_t)0x00000001U)  /*!< Overrun Error                               */
N#define HAL_SAI_ERROR_UDR     ((uint32_t)0x00000002U)  /*!< Underrun error                              */
N#define HAL_SAI_ERROR_AFSDET  ((uint32_t)0x00000004U)  /*!< Anticipated Frame synchronisation detection */
N#define HAL_SAI_ERROR_LFSDET  ((uint32_t)0x00000008U)  /*!< Late Frame synchronisation detection        */
N#define HAL_SAI_ERROR_CNREADY ((uint32_t)0x00000010U)  /*!< codec not ready                             */
N#define HAL_SAI_ERROR_WCKCFG  ((uint32_t)0x00000020U)  /*!< Wrong clock configuration                   */
N#define HAL_SAI_ERROR_TIMEOUT ((uint32_t)0x00000040U)  /*!< Timeout error                               */
N#define HAL_SAI_ERROR_DMA     ((uint32_t)0x00000080U)  /*!< DMA error                                   */
N/**
N  * @}
N  */
N
N/** @defgroup SAI_Block_SyncExt SAI External synchronisation
N  * @{
N  */
N#define SAI_SYNCEXT_DISABLE          0
N#define SAI_SYNCEXT_OUTBLOCKA_ENABLE 1
N#define SAI_SYNCEXT_OUTBLOCKB_ENABLE 2
N/**
N  * @}
N  */
N
N/** @defgroup SAI_Protocol SAI Supported protocol
N  * @{
N  */
N#define SAI_I2S_STANDARD      0
N#define SAI_I2S_MSBJUSTIFIED  1
N#define SAI_I2S_LSBJUSTIFIED  2
N#define SAI_PCM_LONG          3
N#define SAI_PCM_SHORT         4
N/**
N  * @}
N  */
N
N/** @defgroup SAI_Protocol_DataSize SAI protocol data size
N  * @{
N  */
N#define SAI_PROTOCOL_DATASIZE_16BIT         0
N#define SAI_PROTOCOL_DATASIZE_16BITEXTENDED 1
N#define SAI_PROTOCOL_DATASIZE_24BIT         2
N#define SAI_PROTOCOL_DATASIZE_32BIT         3
N/**
N  * @}
N  */
N
N/** @defgroup SAI_Audio_Frequency SAI Audio Frequency
N  * @{
N  */
N#define SAI_AUDIO_FREQUENCY_192K          ((uint32_t)192000U)
N#define SAI_AUDIO_FREQUENCY_96K           ((uint32_t)96000U)
N#define SAI_AUDIO_FREQUENCY_48K           ((uint32_t)48000U)
N#define SAI_AUDIO_FREQUENCY_44K           ((uint32_t)44100U)
N#define SAI_AUDIO_FREQUENCY_32K           ((uint32_t)32000U)
N#define SAI_AUDIO_FREQUENCY_22K           ((uint32_t)22050U)
N#define SAI_AUDIO_FREQUENCY_16K           ((uint32_t)16000U)
N#define SAI_AUDIO_FREQUENCY_11K           ((uint32_t)11025U)
N#define SAI_AUDIO_FREQUENCY_8K            ((uint32_t)8000U)
N#define SAI_AUDIO_FREQUENCY_MCKDIV        ((uint32_t)0U)
N/**
N  * @}
N  */
N
N/** @defgroup SAI_Block_Mode SAI Block Mode
N  * @{
N  */
N#define SAI_MODEMASTER_TX         ((uint32_t)0x00000000U)
N#define SAI_MODEMASTER_RX         ((uint32_t)SAI_xCR1_MODE_0)
N#define SAI_MODESLAVE_TX          ((uint32_t)SAI_xCR1_MODE_1)
N#define SAI_MODESLAVE_RX          ((uint32_t)(SAI_xCR1_MODE_1 | SAI_xCR1_MODE_0))
N
N/**
N  * @}
N  */
N
N/** @defgroup SAI_Block_Protocol SAI Block Protocol
N  * @{
N  */
N#define SAI_FREE_PROTOCOL                 ((uint32_t)0x00000000U)
N#define SAI_SPDIF_PROTOCOL                ((uint32_t)SAI_xCR1_PRTCFG_0)
N#define SAI_AC97_PROTOCOL                 ((uint32_t)SAI_xCR1_PRTCFG_1)
N/**
N  * @}
N  */
N
N/** @defgroup SAI_Block_Data_Size SAI Block Data Size
N  * @{
N  */
N#define SAI_DATASIZE_8     ((uint32_t)SAI_xCR1_DS_1)
N#define SAI_DATASIZE_10    ((uint32_t)(SAI_xCR1_DS_1 | SAI_xCR1_DS_0))
N#define SAI_DATASIZE_16    ((uint32_t)SAI_xCR1_DS_2)
N#define SAI_DATASIZE_20    ((uint32_t)(SAI_xCR1_DS_2 | SAI_xCR1_DS_0))
N#define SAI_DATASIZE_24    ((uint32_t)(SAI_xCR1_DS_2 | SAI_xCR1_DS_1))
N#define SAI_DATASIZE_32    ((uint32_t)(SAI_xCR1_DS_2 | SAI_xCR1_DS_1 | SAI_xCR1_DS_0))
N/**
N  * @}
N  */
N
N/** @defgroup SAI_Block_MSB_LSB_transmission SAI Block MSB LSB transmission
N  * @{
N  */
N#define SAI_FIRSTBIT_MSB                  ((uint32_t)0x00000000U)
N#define SAI_FIRSTBIT_LSB                  ((uint32_t)SAI_xCR1_LSBFIRST)
N/**
N  * @}
N  */
N
N/** @defgroup SAI_Block_Clock_Strobing SAI Block Clock Strobing
N  * @{
N  */
N#define SAI_CLOCKSTROBING_FALLINGEDGE     0
N#define SAI_CLOCKSTROBING_RISINGEDGE      1
N/**
N  * @}
N  */
N
N/** @defgroup SAI_Block_Synchronization SAI Block Synchronization
N  * @{
N  */
N#define SAI_ASYNCHRONOUS                  0 /*!< Asynchronous */
N#define SAI_SYNCHRONOUS                   1 /*!< Synchronous with other block of same SAI */
N#define SAI_SYNCHRONOUS_EXT_SAI1          2 /*!< Synchronous with other SAI, SAI1 */
N#define SAI_SYNCHRONOUS_EXT_SAI2          3 /*!< Synchronous with other SAI, SAI2 */
N/**
N  * @}
N  */
N
N/** @defgroup SAI_Block_Output_Drive SAI Block Output Drive
N  * @{
N  */
N#define SAI_OUTPUTDRIVE_DISABLE          ((uint32_t)0x00000000U)
N#define SAI_OUTPUTDRIVE_ENABLE           ((uint32_t)SAI_xCR1_OUTDRIV)
N/**
N  * @}
N  */
N
N/** @defgroup SAI_Block_NoDivider SAI Block NoDivider
N  * @{
N  */
N#define SAI_MASTERDIVIDER_ENABLE         ((uint32_t)0x00000000U)
N#define SAI_MASTERDIVIDER_DISABLE        ((uint32_t)SAI_xCR1_NODIV)
N/**
N  * @}
N  */
N  
N
N/** @defgroup SAI_Block_FS_Definition SAI Block FS Definition
N  * @{
N  */
N#define SAI_FS_STARTFRAME                 ((uint32_t)0x00000000U)
N#define SAI_FS_CHANNEL_IDENTIFICATION     ((uint32_t)SAI_xFRCR_FSDEF)
N/**
N  * @}
N  */
N
N/** @defgroup SAI_Block_FS_Polarity SAI Block FS Polarity
N  * @{
N  */
N#define SAI_FS_ACTIVE_LOW                  ((uint32_t)0x00000000U)
N#define SAI_FS_ACTIVE_HIGH                 ((uint32_t)SAI_xFRCR_FSPOL)
N/**
N  * @}
N  */
N
N/** @defgroup SAI_Block_FS_Offset SAI Block FS Offset
N  * @{
N  */
N#define SAI_FS_FIRSTBIT                   ((uint32_t)0x00000000U)
N#define SAI_FS_BEFOREFIRSTBIT             ((uint32_t)SAI_xFRCR_FSOFF)
N/**
N  * @}
N  */
N  
N
N  /** @defgroup SAI_Block_Slot_Size SAI Block Slot Size
N  * @{
N  */
N#define SAI_SLOTSIZE_DATASIZE             ((uint32_t)0x00000000U)
N#define SAI_SLOTSIZE_16B                  ((uint32_t)SAI_xSLOTR_SLOTSZ_0)
N#define SAI_SLOTSIZE_32B                  ((uint32_t)SAI_xSLOTR_SLOTSZ_1)
N/**
N  * @}
N  */
N
N/** @defgroup SAI_Block_Slot_Active SAI Block Slot Active
N  * @{
N  */
N#define SAI_SLOT_NOTACTIVE           ((uint32_t)0x00000000U)
N#define SAI_SLOTACTIVE_0             ((uint32_t)0x00000001U)
N#define SAI_SLOTACTIVE_1             ((uint32_t)0x00000002U)
N#define SAI_SLOTACTIVE_2             ((uint32_t)0x00000004U)
N#define SAI_SLOTACTIVE_3             ((uint32_t)0x00000008U)
N#define SAI_SLOTACTIVE_4             ((uint32_t)0x00000010U)
N#define SAI_SLOTACTIVE_5             ((uint32_t)0x00000020U)
N#define SAI_SLOTACTIVE_6             ((uint32_t)0x00000040U)
N#define SAI_SLOTACTIVE_7             ((uint32_t)0x00000080U)
N#define SAI_SLOTACTIVE_8             ((uint32_t)0x00000100U)
N#define SAI_SLOTACTIVE_9             ((uint32_t)0x00000200U)
N#define SAI_SLOTACTIVE_10            ((uint32_t)0x00000400U)
N#define SAI_SLOTACTIVE_11            ((uint32_t)0x00000800U)
N#define SAI_SLOTACTIVE_12            ((uint32_t)0x00001000U)
N#define SAI_SLOTACTIVE_13            ((uint32_t)0x00002000U)
N#define SAI_SLOTACTIVE_14            ((uint32_t)0x00004000U)
N#define SAI_SLOTACTIVE_15            ((uint32_t)0x00008000U)
N#define SAI_SLOTACTIVE_ALL           ((uint32_t)0x0000FFFFU)
N/**
N  * @}
N  */
N
N/** @defgroup SAI_Mono_Stereo_Mode SAI Mono Stereo Mode
N  * @{
N  */
N#define SAI_STEREOMODE               ((uint32_t)0x00000000U)
N#define SAI_MONOMODE                 ((uint32_t)SAI_xCR1_MONO)
N/**
N  * @}
N  */
N
N/** @defgroup SAI_TRIState_Management SAI TRIState Management
N  * @{
N  */
N#define SAI_OUTPUT_NOTRELEASED        ((uint32_t)0x00000000U)
N#define SAI_OUTPUT_RELEASED           ((uint32_t)SAI_xCR2_TRIS)
N/**
N  * @}
N  */
N
N/** @defgroup SAI_Block_Fifo_Threshold SAI Block Fifo Threshold
N  * @{
N  */
N#define SAI_FIFOTHRESHOLD_EMPTY  ((uint32_t)0x00000000U)
N#define SAI_FIFOTHRESHOLD_1QF    ((uint32_t)(SAI_xCR2_FTH_0))
N#define SAI_FIFOTHRESHOLD_HF     ((uint32_t)(SAI_xCR2_FTH_1))
N#define SAI_FIFOTHRESHOLD_3QF    ((uint32_t)(SAI_xCR2_FTH_1 | SAI_xCR2_FTH_0))
N#define SAI_FIFOTHRESHOLD_FULL   ((uint32_t)(SAI_xCR2_FTH_2))
N/**
N  * @}
N  */
N
N/** @defgroup SAI_Block_Companding_Mode SAI Block Companding Mode
N  * @{
N  */
N#define SAI_NOCOMPANDING                 ((uint32_t)0x00000000U)
N#define SAI_ULAW_1CPL_COMPANDING         ((uint32_t)(SAI_xCR2_COMP_1))
N#define SAI_ALAW_1CPL_COMPANDING         ((uint32_t)(SAI_xCR2_COMP_1 | SAI_xCR2_COMP_0))
N#define SAI_ULAW_2CPL_COMPANDING         ((uint32_t)(SAI_xCR2_COMP_1 | SAI_xCR2_CPL))
N#define SAI_ALAW_2CPL_COMPANDING         ((uint32_t)(SAI_xCR2_COMP_1 | SAI_xCR2_COMP_0 | SAI_xCR2_CPL))
N/**
N  * @}
N  */
N
N/** @defgroup SAI_Block_Mute_Value SAI Block Mute Value
N  * @{
N  */
N#define SAI_ZERO_VALUE                   ((uint32_t)0x00000000U)
N#define SAI_LAST_SENT_VALUE              ((uint32_t)SAI_xCR2_MUTEVAL)
N/**
N  * @}
N  */
N
N/** @defgroup SAI_Block_Interrupts_Definition SAI Block Interrupts Definition
N  * @{
N  */
N#define SAI_IT_OVRUDR                     ((uint32_t)SAI_xIMR_OVRUDRIE)
N#define SAI_IT_MUTEDET                    ((uint32_t)SAI_xIMR_MUTEDETIE)
N#define SAI_IT_WCKCFG                     ((uint32_t)SAI_xIMR_WCKCFGIE)
N#define SAI_IT_FREQ                       ((uint32_t)SAI_xIMR_FREQIE)
N#define SAI_IT_CNRDY                      ((uint32_t)SAI_xIMR_CNRDYIE)
N#define SAI_IT_AFSDET                     ((uint32_t)SAI_xIMR_AFSDETIE)
N#define SAI_IT_LFSDET                     ((uint32_t)SAI_xIMR_LFSDETIE)
N/**
N  * @}
N  */
N
N/** @defgroup SAI_Block_Flags_Definition  SAI Block Flags Definition
N  * @{
N  */
N#define SAI_FLAG_OVRUDR                   ((uint32_t)SAI_xSR_OVRUDR)
N#define SAI_FLAG_MUTEDET                  ((uint32_t)SAI_xSR_MUTEDET)
N#define SAI_FLAG_WCKCFG                   ((uint32_t)SAI_xSR_WCKCFG)
N#define SAI_FLAG_FREQ                     ((uint32_t)SAI_xSR_FREQ)
N#define SAI_FLAG_CNRDY                    ((uint32_t)SAI_xSR_CNRDY)
N#define SAI_FLAG_AFSDET                   ((uint32_t)SAI_xSR_AFSDET)
N#define SAI_FLAG_LFSDET                   ((uint32_t)SAI_xSR_LFSDET)
N/**
N  * @}
N  */
N
N/** @defgroup SAI_Block_Fifo_Status_Level   SAI Block Fifo Status Level
N  * @{
N  */
N#define SAI_FIFOSTATUS_EMPTY              ((uint32_t)0x00000000U)
N#define SAI_FIFOSTATUS_LESS1QUARTERFULL   ((uint32_t)0x00010000U)
N#define SAI_FIFOSTATUS_1QUARTERFULL       ((uint32_t)0x00020000U)
N#define SAI_FIFOSTATUS_HALFFULL           ((uint32_t)0x00030000U)
N#define SAI_FIFOSTATUS_3QUARTERFULL       ((uint32_t)0x00040000U)
N#define SAI_FIFOSTATUS_FULL               ((uint32_t)0x00050000U)
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N
N/** @defgroup SAI_Exported_Macros SAI Exported Macros
N *  @brief macros to handle interrupts and specific configurations
N * @{
N */
N
N/** @brief Reset SAI handle state.
N  * @param  __HANDLE__: specifies the SAI Handle.
N  * @retval None
N  */
N#define __HAL_SAI_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_SAI_STATE_RESET)
N
N/** @brief  Enable or disable the specified SAI interrupts.
N  * @param  __HANDLE__: specifies the SAI Handle.
N  * @param  __INTERRUPT__: specifies the interrupt source to enable or disable.
N  *         This parameter can be one of the following values:
N  *            @arg SAI_IT_OVRUDR: Overrun underrun interrupt enable
N  *            @arg SAI_IT_MUTEDET: Mute detection interrupt enable
N  *            @arg SAI_IT_WCKCFG: Wrong Clock Configuration interrupt enable
N  *            @arg SAI_IT_FREQ: FIFO request interrupt enable
N  *            @arg SAI_IT_CNRDY: Codec not ready interrupt enable
N  *            @arg SAI_IT_AFSDET: Anticipated frame synchronization detection interrupt enable
N  *            @arg SAI_IT_LFSDET: Late frame synchronization detection interrupt enable
N  * @retval None
N  */
N#define __HAL_SAI_ENABLE_IT(__HANDLE__, __INTERRUPT__)   ((__HANDLE__)->Instance->IMR |= (__INTERRUPT__))
N#define __HAL_SAI_DISABLE_IT(__HANDLE__, __INTERRUPT__)  ((__HANDLE__)->Instance->IMR &= (~(__INTERRUPT__)))
N
N/** @brief  Check whether the specified SAI interrupt source is enabled or not.
N  * @param  __HANDLE__: specifies the SAI Handle.
N  * @param  __INTERRUPT__: specifies the SAI interrupt source to check.
N  *         This parameter can be one of the following values:
N  *            @arg SAI_IT_OVRUDR: Overrun underrun interrupt enable
N  *            @arg SAI_IT_MUTEDET: Mute detection interrupt enable
N  *            @arg SAI_IT_WCKCFG: Wrong Clock Configuration interrupt enable
N  *            @arg SAI_IT_FREQ: FIFO request interrupt enable
N  *            @arg SAI_IT_CNRDY: Codec not ready interrupt enable
N  *            @arg SAI_IT_AFSDET: Anticipated frame synchronization detection interrupt enable
N  *            @arg SAI_IT_LFSDET: Late frame synchronization detection interrupt enable
N  * @retval The new state of __INTERRUPT__ (TRUE or FALSE).
N  */
N#define __HAL_SAI_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) ((((__HANDLE__)->Instance->IMR & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)
N
N/** @brief  Check whether the specified SAI flag is set or not.
N  * @param  __HANDLE__: specifies the SAI Handle.
N  * @param  __FLAG__: specifies the flag to check.
N  *         This parameter can be one of the following values:
N  *            @arg SAI_FLAG_OVRUDR: Overrun underrun flag.
N  *            @arg SAI_FLAG_MUTEDET: Mute detection flag.
N  *            @arg SAI_FLAG_WCKCFG: Wrong Clock Configuration flag.
N  *            @arg SAI_FLAG_FREQ: FIFO request flag.
N  *            @arg SAI_FLAG_CNRDY: Codec not ready flag.
N  *            @arg SAI_FLAG_AFSDET: Anticipated frame synchronization detection flag.
N  *            @arg SAI_FLAG_LFSDET: Late frame synchronization detection flag.
N  * @retval The new state of __FLAG__ (TRUE or FALSE).
N  */
N#define __HAL_SAI_GET_FLAG(__HANDLE__, __FLAG__) ((((__HANDLE__)->Instance->SR) & (__FLAG__)) == (__FLAG__))
N
N/** @brief  Clear the specified SAI pending flag.
N  * @param  __HANDLE__: specifies the SAI Handle.
N  * @param  __FLAG__: specifies the flag to check.
N  *          This parameter can be any combination of the following values:
N  *            @arg SAI_FLAG_OVRUDR: Clear Overrun underrun
N  *            @arg SAI_FLAG_MUTEDET: Clear Mute detection
N  *            @arg SAI_FLAG_WCKCFG: Clear Wrong Clock Configuration
N  *            @arg SAI_FLAG_FREQ: Clear FIFO request
N  *            @arg SAI_FLAG_CNRDY: Clear Codec not ready
N  *            @arg SAI_FLAG_AFSDET: Clear Anticipated frame synchronization detection
N  *            @arg SAI_FLAG_LFSDET: Clear Late frame synchronization detection
N  *
N  * @retval None
N  */
N#define __HAL_SAI_CLEAR_FLAG(__HANDLE__, __FLAG__) ((__HANDLE__)->Instance->CLRFR = (__FLAG__))
N
N#define __HAL_SAI_ENABLE(__HANDLE__) ((__HANDLE__)->Instance->CR1 |=  SAI_xCR1_SAIEN)
N#define __HAL_SAI_DISABLE(__HANDLE__) ((__HANDLE__)->Instance->CR1 &=  ~SAI_xCR1_SAIEN)
N
N /**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N
N/** @addtogroup SAI_Exported_Functions
N  * @{
N  */
N
N/* Initialization/de-initialization functions  ********************************/
N
N/** @addtogroup SAI_Exported_Functions_Group1
N  * @{
N  */
NHAL_StatusTypeDef HAL_SAI_InitProtocol(SAI_HandleTypeDef *hsai, uint32_t protocol, uint32_t datasize, uint32_t nbslot);
NHAL_StatusTypeDef HAL_SAI_Init(SAI_HandleTypeDef *hsai);
NHAL_StatusTypeDef HAL_SAI_DeInit (SAI_HandleTypeDef *hsai);
Nvoid HAL_SAI_MspInit(SAI_HandleTypeDef *hsai);
Nvoid HAL_SAI_MspDeInit(SAI_HandleTypeDef *hsai);
N
N/**
N  * @}
N  */
N
N/* I/O operation functions  ***************************************************/
N
N/** @addtogroup SAI_Exported_Functions_Group2
N  * @{
N  */
N/* Blocking mode: Polling */
NHAL_StatusTypeDef HAL_SAI_Transmit(SAI_HandleTypeDef *hsai, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_SAI_Receive(SAI_HandleTypeDef *hsai, uint8_t *pData, uint16_t Size, uint32_t Timeout);
N
N/* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_SAI_Transmit_IT(SAI_HandleTypeDef *hsai, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_SAI_Receive_IT(SAI_HandleTypeDef *hsai, uint8_t *pData, uint16_t Size);
N
N/* Non-Blocking mode: DMA */
NHAL_StatusTypeDef HAL_SAI_Transmit_DMA(SAI_HandleTypeDef *hsai, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_SAI_Receive_DMA(SAI_HandleTypeDef *hsai, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_SAI_DMAPause(SAI_HandleTypeDef *hsai);
NHAL_StatusTypeDef HAL_SAI_DMAResume(SAI_HandleTypeDef *hsai);
NHAL_StatusTypeDef HAL_SAI_DMAStop(SAI_HandleTypeDef *hsai);
N
N/* Abort function */
NHAL_StatusTypeDef HAL_SAI_Abort(SAI_HandleTypeDef *hsai);
N
N/* Mute management */
NHAL_StatusTypeDef HAL_SAI_EnableTxMuteMode(SAI_HandleTypeDef *hsai, uint16_t val);
NHAL_StatusTypeDef HAL_SAI_DisableTxMuteMode(SAI_HandleTypeDef *hsai);
NHAL_StatusTypeDef HAL_SAI_EnableRxMuteMode(SAI_HandleTypeDef *hsai, SAIcallback callback, uint16_t counter);
NHAL_StatusTypeDef HAL_SAI_DisableRxMuteMode(SAI_HandleTypeDef *hsai);
N
N/* SAI IRQHandler and Callbacks used in non blocking modes (Interrupt and DMA) */
Nvoid HAL_SAI_IRQHandler(SAI_HandleTypeDef *hsai);
Nvoid HAL_SAI_TxHalfCpltCallback(SAI_HandleTypeDef *hsai);
Nvoid HAL_SAI_TxCpltCallback(SAI_HandleTypeDef *hsai);
Nvoid HAL_SAI_RxHalfCpltCallback(SAI_HandleTypeDef *hsai);
Nvoid HAL_SAI_RxCpltCallback(SAI_HandleTypeDef *hsai);
Nvoid HAL_SAI_ErrorCallback(SAI_HandleTypeDef *hsai);
N/**
N  * @}
N  */
N
N/** @addtogroup SAI_Exported_Functions_Group3
N  * @{
N  */
N/* Peripheral State functions  ************************************************/
NHAL_SAI_StateTypeDef HAL_SAI_GetState(SAI_HandleTypeDef *hsai);
Nuint32_t HAL_SAI_GetError(SAI_HandleTypeDef *hsai);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @addtogroup SAI_Private_Macros
N  * @{
N  */
N#define IS_SAI_BLOCK_SYNCEXT(STATE) (((STATE) == SAI_SYNCEXT_DISABLE)          ||\
N                                     ((STATE) == SAI_SYNCEXT_OUTBLOCKA_ENABLE) ||\
N                                     ((STATE) == SAI_SYNCEXT_OUTBLOCKB_ENABLE))
X#define IS_SAI_BLOCK_SYNCEXT(STATE) (((STATE) == SAI_SYNCEXT_DISABLE)          ||                                     ((STATE) == SAI_SYNCEXT_OUTBLOCKA_ENABLE) ||                                     ((STATE) == SAI_SYNCEXT_OUTBLOCKB_ENABLE))
N
N#define IS_SAI_SUPPORTED_PROTOCOL(PROTOCOL)   (((PROTOCOL) == SAI_I2S_STANDARD)     ||\
N                                               ((PROTOCOL) == SAI_I2S_MSBJUSTIFIED) ||\
N                                               ((PROTOCOL) == SAI_I2S_LSBJUSTIFIED) ||\
N                                               ((PROTOCOL) == SAI_PCM_LONG)         ||\
N                                               ((PROTOCOL) == SAI_PCM_SHORT))
X#define IS_SAI_SUPPORTED_PROTOCOL(PROTOCOL)   (((PROTOCOL) == SAI_I2S_STANDARD)     ||                                               ((PROTOCOL) == SAI_I2S_MSBJUSTIFIED) ||                                               ((PROTOCOL) == SAI_I2S_LSBJUSTIFIED) ||                                               ((PROTOCOL) == SAI_PCM_LONG)         ||                                               ((PROTOCOL) == SAI_PCM_SHORT))
N
N#define IS_SAI_PROTOCOL_DATASIZE(DATASIZE)   (((DATASIZE) == SAI_PROTOCOL_DATASIZE_16BIT)         ||\
N                                              ((DATASIZE) == SAI_PROTOCOL_DATASIZE_16BITEXTENDED) ||\
N                                              ((DATASIZE) == SAI_PROTOCOL_DATASIZE_24BIT)         ||\
N                                              ((DATASIZE) == SAI_PROTOCOL_DATASIZE_32BIT))
X#define IS_SAI_PROTOCOL_DATASIZE(DATASIZE)   (((DATASIZE) == SAI_PROTOCOL_DATASIZE_16BIT)         ||                                              ((DATASIZE) == SAI_PROTOCOL_DATASIZE_16BITEXTENDED) ||                                              ((DATASIZE) == SAI_PROTOCOL_DATASIZE_24BIT)         ||                                              ((DATASIZE) == SAI_PROTOCOL_DATASIZE_32BIT))
N
N#define IS_SAI_AUDIO_FREQUENCY(AUDIO) (((AUDIO) == SAI_AUDIO_FREQUENCY_192K) || ((AUDIO) == SAI_AUDIO_FREQUENCY_96K) || \
N                                       ((AUDIO) == SAI_AUDIO_FREQUENCY_48K)  || ((AUDIO) == SAI_AUDIO_FREQUENCY_44K) || \
N                                       ((AUDIO) == SAI_AUDIO_FREQUENCY_32K)  || ((AUDIO) == SAI_AUDIO_FREQUENCY_22K) || \
N                                       ((AUDIO) == SAI_AUDIO_FREQUENCY_16K)  || ((AUDIO) == SAI_AUDIO_FREQUENCY_11K) || \
N                                       ((AUDIO) == SAI_AUDIO_FREQUENCY_8K)   || ((AUDIO) == SAI_AUDIO_FREQUENCY_MCKDIV))
X#define IS_SAI_AUDIO_FREQUENCY(AUDIO) (((AUDIO) == SAI_AUDIO_FREQUENCY_192K) || ((AUDIO) == SAI_AUDIO_FREQUENCY_96K) ||                                        ((AUDIO) == SAI_AUDIO_FREQUENCY_48K)  || ((AUDIO) == SAI_AUDIO_FREQUENCY_44K) ||                                        ((AUDIO) == SAI_AUDIO_FREQUENCY_32K)  || ((AUDIO) == SAI_AUDIO_FREQUENCY_22K) ||                                        ((AUDIO) == SAI_AUDIO_FREQUENCY_16K)  || ((AUDIO) == SAI_AUDIO_FREQUENCY_11K) ||                                        ((AUDIO) == SAI_AUDIO_FREQUENCY_8K)   || ((AUDIO) == SAI_AUDIO_FREQUENCY_MCKDIV))
N
N#define IS_SAI_BLOCK_MODE(MODE)  (((MODE) == SAI_MODEMASTER_TX) || \
N                                  ((MODE) == SAI_MODEMASTER_RX) || \
N                                  ((MODE) == SAI_MODESLAVE_TX)  || \
N                                  ((MODE) == SAI_MODESLAVE_RX))
X#define IS_SAI_BLOCK_MODE(MODE)  (((MODE) == SAI_MODEMASTER_TX) ||                                   ((MODE) == SAI_MODEMASTER_RX) ||                                   ((MODE) == SAI_MODESLAVE_TX)  ||                                   ((MODE) == SAI_MODESLAVE_RX))
N
N#define IS_SAI_BLOCK_PROTOCOL(PROTOCOL) (((PROTOCOL) == SAI_FREE_PROTOCOL)  || \
N                                         ((PROTOCOL) == SAI_AC97_PROTOCOL)  || \
N                                         ((PROTOCOL) == SAI_SPDIF_PROTOCOL))
X#define IS_SAI_BLOCK_PROTOCOL(PROTOCOL) (((PROTOCOL) == SAI_FREE_PROTOCOL)  ||                                          ((PROTOCOL) == SAI_AC97_PROTOCOL)  ||                                          ((PROTOCOL) == SAI_SPDIF_PROTOCOL))
N
N#define IS_SAI_BLOCK_DATASIZE(DATASIZE) (((DATASIZE) == SAI_DATASIZE_8)  || \
N                                         ((DATASIZE) == SAI_DATASIZE_10) || \
N                                         ((DATASIZE) == SAI_DATASIZE_16) || \
N                                         ((DATASIZE) == SAI_DATASIZE_20) || \
N                                         ((DATASIZE) == SAI_DATASIZE_24) || \
N                                         ((DATASIZE) == SAI_DATASIZE_32))
X#define IS_SAI_BLOCK_DATASIZE(DATASIZE) (((DATASIZE) == SAI_DATASIZE_8)  ||                                          ((DATASIZE) == SAI_DATASIZE_10) ||                                          ((DATASIZE) == SAI_DATASIZE_16) ||                                          ((DATASIZE) == SAI_DATASIZE_20) ||                                          ((DATASIZE) == SAI_DATASIZE_24) ||                                          ((DATASIZE) == SAI_DATASIZE_32))
N
N#define IS_SAI_BLOCK_FIRST_BIT(BIT) (((BIT) == SAI_FIRSTBIT_MSB) || \
N                                     ((BIT) == SAI_FIRSTBIT_LSB))
X#define IS_SAI_BLOCK_FIRST_BIT(BIT) (((BIT) == SAI_FIRSTBIT_MSB) ||                                      ((BIT) == SAI_FIRSTBIT_LSB))
N
N#define IS_SAI_BLOCK_CLOCK_STROBING(CLOCK) (((CLOCK) == SAI_CLOCKSTROBING_FALLINGEDGE) || \
N                                            ((CLOCK) == SAI_CLOCKSTROBING_RISINGEDGE))
X#define IS_SAI_BLOCK_CLOCK_STROBING(CLOCK) (((CLOCK) == SAI_CLOCKSTROBING_FALLINGEDGE) ||                                             ((CLOCK) == SAI_CLOCKSTROBING_RISINGEDGE))
N
N#define IS_SAI_BLOCK_SYNCHRO(SYNCHRO) (((SYNCHRO) == SAI_ASYNCHRONOUS)         || \
N                                       ((SYNCHRO) == SAI_SYNCHRONOUS)          || \
N                                       ((SYNCHRO) == SAI_SYNCHRONOUS_EXT_SAI1) || \
N                                       ((SYNCHRO) == SAI_SYNCHRONOUS_EXT_SAI2))
X#define IS_SAI_BLOCK_SYNCHRO(SYNCHRO) (((SYNCHRO) == SAI_ASYNCHRONOUS)         ||                                        ((SYNCHRO) == SAI_SYNCHRONOUS)          ||                                        ((SYNCHRO) == SAI_SYNCHRONOUS_EXT_SAI1) ||                                        ((SYNCHRO) == SAI_SYNCHRONOUS_EXT_SAI2))
N
N#define IS_SAI_BLOCK_OUTPUT_DRIVE(DRIVE) (((DRIVE) == SAI_OUTPUTDRIVE_DISABLE) || \
N                                          ((DRIVE) == SAI_OUTPUTDRIVE_ENABLE))
X#define IS_SAI_BLOCK_OUTPUT_DRIVE(DRIVE) (((DRIVE) == SAI_OUTPUTDRIVE_DISABLE) ||                                           ((DRIVE) == SAI_OUTPUTDRIVE_ENABLE))
N
N#define IS_SAI_BLOCK_NODIVIDER(NODIVIDER) (((NODIVIDER) == SAI_MASTERDIVIDER_ENABLE) || \
N                                           ((NODIVIDER) == SAI_MASTERDIVIDER_DISABLE))
X#define IS_SAI_BLOCK_NODIVIDER(NODIVIDER) (((NODIVIDER) == SAI_MASTERDIVIDER_ENABLE) ||                                            ((NODIVIDER) == SAI_MASTERDIVIDER_DISABLE))
N
N#define IS_SAI_BLOCK_MUTE_COUNTER(COUNTER) ((COUNTER) <= 63)
N
N#define IS_SAI_BLOCK_MUTE_VALUE(VALUE)    (((VALUE) == SAI_ZERO_VALUE)     || \
N                                           ((VALUE) == SAI_LAST_SENT_VALUE))
X#define IS_SAI_BLOCK_MUTE_VALUE(VALUE)    (((VALUE) == SAI_ZERO_VALUE)     ||                                            ((VALUE) == SAI_LAST_SENT_VALUE))
N
N#define IS_SAI_BLOCK_COMPANDING_MODE(MODE)    (((MODE) == SAI_NOCOMPANDING)         || \
N                                               ((MODE) == SAI_ULAW_1CPL_COMPANDING) || \
N                                               ((MODE) == SAI_ALAW_1CPL_COMPANDING) || \
N                                               ((MODE) == SAI_ULAW_2CPL_COMPANDING) || \
N                                               ((MODE) == SAI_ALAW_2CPL_COMPANDING))
X#define IS_SAI_BLOCK_COMPANDING_MODE(MODE)    (((MODE) == SAI_NOCOMPANDING)         ||                                                ((MODE) == SAI_ULAW_1CPL_COMPANDING) ||                                                ((MODE) == SAI_ALAW_1CPL_COMPANDING) ||                                                ((MODE) == SAI_ULAW_2CPL_COMPANDING) ||                                                ((MODE) == SAI_ALAW_2CPL_COMPANDING))
N
N#define IS_SAI_BLOCK_FIFO_THRESHOLD(THRESHOLD) (((THRESHOLD) == SAI_FIFOTHRESHOLD_EMPTY)   || \
N                                                ((THRESHOLD) == SAI_FIFOTHRESHOLD_1QF)     || \
N                                                ((THRESHOLD) == SAI_FIFOTHRESHOLD_HF)      || \
N                                                ((THRESHOLD) == SAI_FIFOTHRESHOLD_3QF)     || \
N                                                ((THRESHOLD) == SAI_FIFOTHRESHOLD_FULL))
X#define IS_SAI_BLOCK_FIFO_THRESHOLD(THRESHOLD) (((THRESHOLD) == SAI_FIFOTHRESHOLD_EMPTY)   ||                                                 ((THRESHOLD) == SAI_FIFOTHRESHOLD_1QF)     ||                                                 ((THRESHOLD) == SAI_FIFOTHRESHOLD_HF)      ||                                                 ((THRESHOLD) == SAI_FIFOTHRESHOLD_3QF)     ||                                                 ((THRESHOLD) == SAI_FIFOTHRESHOLD_FULL))
N
N#define IS_SAI_BLOCK_TRISTATE_MANAGEMENT(STATE) (((STATE) == SAI_OUTPUT_NOTRELEASED) ||\
N                                                 ((STATE) == SAI_OUTPUT_RELEASED))
X#define IS_SAI_BLOCK_TRISTATE_MANAGEMENT(STATE) (((STATE) == SAI_OUTPUT_NOTRELEASED) ||                                                 ((STATE) == SAI_OUTPUT_RELEASED))
N
N#define IS_SAI_MONO_STEREO_MODE(MODE) (((MODE) == SAI_MONOMODE) ||\
N                                       ((MODE) == SAI_STEREOMODE))
X#define IS_SAI_MONO_STEREO_MODE(MODE) (((MODE) == SAI_MONOMODE) ||                                       ((MODE) == SAI_STEREOMODE))
N
N#define IS_SAI_SLOT_ACTIVE(ACTIVE)  ((ACTIVE) <= SAI_SLOTACTIVE_ALL)
N
N#define IS_SAI_BLOCK_SLOT_NUMBER(NUMBER) ((1 <= (NUMBER)) && ((NUMBER) <= 16))
N
N#define IS_SAI_BLOCK_SLOT_SIZE(SIZE) (((SIZE) == SAI_SLOTSIZE_DATASIZE) || \
N                                      ((SIZE) == SAI_SLOTSIZE_16B)      || \
N                                      ((SIZE) == SAI_SLOTSIZE_32B))
X#define IS_SAI_BLOCK_SLOT_SIZE(SIZE) (((SIZE) == SAI_SLOTSIZE_DATASIZE) ||                                       ((SIZE) == SAI_SLOTSIZE_16B)      ||                                       ((SIZE) == SAI_SLOTSIZE_32B))
N
N#define IS_SAI_BLOCK_FIRSTBIT_OFFSET(OFFSET) ((OFFSET) <= 24)
N
N#define IS_SAI_BLOCK_FS_OFFSET(OFFSET) (((OFFSET) == SAI_FS_FIRSTBIT) || \
N                                        ((OFFSET) == SAI_FS_BEFOREFIRSTBIT))
X#define IS_SAI_BLOCK_FS_OFFSET(OFFSET) (((OFFSET) == SAI_FS_FIRSTBIT) ||                                         ((OFFSET) == SAI_FS_BEFOREFIRSTBIT))
N
N#define IS_SAI_BLOCK_FS_POLARITY(POLARITY) (((POLARITY) == SAI_FS_ACTIVE_LOW) || \
N                                            ((POLARITY) == SAI_FS_ACTIVE_HIGH))
X#define IS_SAI_BLOCK_FS_POLARITY(POLARITY) (((POLARITY) == SAI_FS_ACTIVE_LOW) ||                                             ((POLARITY) == SAI_FS_ACTIVE_HIGH))
N
N#define IS_SAI_BLOCK_FS_DEFINITION(DEFINITION) (((DEFINITION) == SAI_FS_STARTFRAME) || \
N                                                ((DEFINITION) == SAI_FS_CHANNEL_IDENTIFICATION))
X#define IS_SAI_BLOCK_FS_DEFINITION(DEFINITION) (((DEFINITION) == SAI_FS_STARTFRAME) ||                                                 ((DEFINITION) == SAI_FS_CHANNEL_IDENTIFICATION))
N
N#define IS_SAI_BLOCK_MASTER_DIVIDER(DIVIDER) ((DIVIDER) <= 15)
N
N#define IS_SAI_BLOCK_FRAME_LENGTH(LENGTH) ((8 <= (LENGTH)) && ((LENGTH) <= 256))
N
N#define IS_SAI_BLOCK_ACTIVE_FRAME(LENGTH) ((1 <= (LENGTH)) && ((LENGTH) <= 128))
N
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup SAI_Private_Functions SAI Private Functions
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_SAI_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 359 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_SAI_MODULE_ENABLED */
N
N#ifdef HAL_SD_MODULE_ENABLED
N #include "stm32f7xx_hal_sd.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_sd.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_sd.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of SD HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_SD_H
N#define __STM32F7xx_HAL_SD_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_ll_sdmmc.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_ll_sdmmc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_ll_sdmmc.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of SDMMC HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_LL_SDMMC_H
N#define __STM32F7xx_LL_SDMMC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_Driver
N  * @{
N  */
N
N/** @addtogroup SDMMC_LL
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/ 
N/** @defgroup SDMMC_LL_Exported_Types SDMMC_LL Exported Types
N  * @{
N  */
N  
N/** 
N  * @brief  SDMMC Configuration Structure definition  
N  */
Ntypedef struct
N{
N  uint32_t ClockEdge;            /*!< Specifies the clock transition on which the bit capture is made.
N                                      This parameter can be a value of @ref SDMMC_LL_Clock_Edge                 */
N
N  uint32_t ClockBypass;          /*!< Specifies whether the SDMMC Clock divider bypass is
N                                      enabled or disabled.
N                                      This parameter can be a value of @ref SDMMC_LL_Clock_Bypass               */
N
N  uint32_t ClockPowerSave;       /*!< Specifies whether SDMMC Clock output is enabled or
N                                      disabled when the bus is idle.
N                                      This parameter can be a value of @ref SDMMC_LL_Clock_Power_Save           */
N
N  uint32_t BusWide;              /*!< Specifies the SDMMC bus width.
N                                      This parameter can be a value of @ref SDMMC_LL_Bus_Wide                   */
N
N  uint32_t HardwareFlowControl;  /*!< Specifies whether the SDMMC hardware flow control is enabled or disabled.
N                                      This parameter can be a value of @ref SDMMC_LL_Hardware_Flow_Control      */
N
N  uint32_t ClockDiv;             /*!< Specifies the clock frequency of the SDMMC controller.
N                                      This parameter can be a value between Min_Data = 0 and Max_Data = 255 */  
N  
N}SDMMC_InitTypeDef;
N  
N
N/** 
N  * @brief  SDMMC Command Control structure 
N  */
Ntypedef struct                                                                                            
N{
N  uint32_t Argument;            /*!< Specifies the SDMMC command argument which is sent
N                                     to a card as part of a command message. If a command
N                                     contains an argument, it must be loaded into this register
N                                     before writing the command to the command register.              */
N
N  uint32_t CmdIndex;            /*!< Specifies the SDMMC command index. It must be Min_Data = 0 and 
N                                     Max_Data = 64                                                    */
N
N  uint32_t Response;            /*!< Specifies the SDMMC response type.
N                                     This parameter can be a value of @ref SDMMC_LL_Response_Type         */
N
N  uint32_t WaitForInterrupt;    /*!< Specifies whether SDMMC wait for interrupt request is 
N                                     enabled or disabled.
N                                     This parameter can be a value of @ref SDMMC_LL_Wait_Interrupt_State  */
N
N  uint32_t CPSM;                /*!< Specifies whether SDMMC Command path state machine (CPSM)
N                                     is enabled or disabled.
N                                     This parameter can be a value of @ref SDMMC_LL_CPSM_State            */
N}SDMMC_CmdInitTypeDef;
N
N
N/** 
N  * @brief  SDMMC Data Control structure 
N  */
Ntypedef struct
N{
N  uint32_t DataTimeOut;         /*!< Specifies the data timeout period in card bus clock periods.  */
N
N  uint32_t DataLength;          /*!< Specifies the number of data bytes to be transferred.         */
N 
N  uint32_t DataBlockSize;       /*!< Specifies the data block size for block transfer.
N                                     This parameter can be a value of @ref SDMMC_LL_Data_Block_Size    */
N 
N  uint32_t TransferDir;         /*!< Specifies the data transfer direction, whether the transfer
N                                     is a read or write.
N                                     This parameter can be a value of @ref SDMMC_LL_Transfer_Direction */
N 
N  uint32_t TransferMode;        /*!< Specifies whether data transfer is in stream or block mode.
N                                     This parameter can be a value of @ref SDMMC_LL_Transfer_Type      */
N 
N  uint32_t DPSM;                /*!< Specifies whether SDMMC Data path state machine (DPSM)
N                                     is enabled or disabled.
N                                     This parameter can be a value of @ref SDMMC_LL_DPSM_State         */
N}SDMMC_DataInitTypeDef;
N
N/**
N  * @}
N  */
N  
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup SDMMC_LL_Exported_Constants SDMMC_LL Exported Constants
N  * @{
N  */
N
N/** @defgroup SDMMC_LL_Clock_Edge Clock Edge
N  * @{
N  */
N#define SDMMC_CLOCK_EDGE_RISING               ((uint32_t)0x00000000U)
N#define SDMMC_CLOCK_EDGE_FALLING              SDMMC_CLKCR_NEGEDGE
N
N#define IS_SDMMC_CLOCK_EDGE(EDGE) (((EDGE) == SDMMC_CLOCK_EDGE_RISING) || \
N                                  ((EDGE) == SDMMC_CLOCK_EDGE_FALLING))
X#define IS_SDMMC_CLOCK_EDGE(EDGE) (((EDGE) == SDMMC_CLOCK_EDGE_RISING) ||                                   ((EDGE) == SDMMC_CLOCK_EDGE_FALLING))
N/**
N  * @}
N  */
N
N/** @defgroup SDMMC_LL_Clock_Bypass Clock Bypass
N  * @{
N  */
N#define SDMMC_CLOCK_BYPASS_DISABLE             ((uint32_t)0x00000000U)
N#define SDMMC_CLOCK_BYPASS_ENABLE              SDMMC_CLKCR_BYPASS   
N
N#define IS_SDMMC_CLOCK_BYPASS(BYPASS) (((BYPASS) == SDMMC_CLOCK_BYPASS_DISABLE) || \
N                                      ((BYPASS) == SDMMC_CLOCK_BYPASS_ENABLE))
X#define IS_SDMMC_CLOCK_BYPASS(BYPASS) (((BYPASS) == SDMMC_CLOCK_BYPASS_DISABLE) ||                                       ((BYPASS) == SDMMC_CLOCK_BYPASS_ENABLE))
N/**
N  * @}
N  */ 
N
N/** @defgroup SDMMC_LL_Clock_Power_Save Clock Power Saving
N  * @{
N  */
N#define SDMMC_CLOCK_POWER_SAVE_DISABLE         ((uint32_t)0x00000000U)
N#define SDMMC_CLOCK_POWER_SAVE_ENABLE          SDMMC_CLKCR_PWRSAV
N
N#define IS_SDMMC_CLOCK_POWER_SAVE(SAVE) (((SAVE) == SDMMC_CLOCK_POWER_SAVE_DISABLE) || \
N                                        ((SAVE) == SDMMC_CLOCK_POWER_SAVE_ENABLE))
X#define IS_SDMMC_CLOCK_POWER_SAVE(SAVE) (((SAVE) == SDMMC_CLOCK_POWER_SAVE_DISABLE) ||                                         ((SAVE) == SDMMC_CLOCK_POWER_SAVE_ENABLE))
N/**
N  * @}
N  */
N
N/** @defgroup SDMMC_LL_Bus_Wide Bus Width
N  * @{
N  */
N#define SDMMC_BUS_WIDE_1B                      ((uint32_t)0x00000000U)
N#define SDMMC_BUS_WIDE_4B                      SDMMC_CLKCR_WIDBUS_0
N#define SDMMC_BUS_WIDE_8B                      SDMMC_CLKCR_WIDBUS_1
N
N#define IS_SDMMC_BUS_WIDE(WIDE) (((WIDE) == SDMMC_BUS_WIDE_1B) || \
N                                ((WIDE) == SDMMC_BUS_WIDE_4B) || \
N                                ((WIDE) == SDMMC_BUS_WIDE_8B))
X#define IS_SDMMC_BUS_WIDE(WIDE) (((WIDE) == SDMMC_BUS_WIDE_1B) ||                                 ((WIDE) == SDMMC_BUS_WIDE_4B) ||                                 ((WIDE) == SDMMC_BUS_WIDE_8B))
N/**
N  * @}
N  */
N
N/** @defgroup SDMMC_LL_Hardware_Flow_Control Hardware Flow Control
N  * @{
N  */
N#define SDMMC_HARDWARE_FLOW_CONTROL_DISABLE    ((uint32_t)0x00000000U)
N#define SDMMC_HARDWARE_FLOW_CONTROL_ENABLE     SDMMC_CLKCR_HWFC_EN
N
N#define IS_SDMMC_HARDWARE_FLOW_CONTROL(CONTROL) (((CONTROL) == SDMMC_HARDWARE_FLOW_CONTROL_DISABLE) || \
N                                                ((CONTROL) == SDMMC_HARDWARE_FLOW_CONTROL_ENABLE))
X#define IS_SDMMC_HARDWARE_FLOW_CONTROL(CONTROL) (((CONTROL) == SDMMC_HARDWARE_FLOW_CONTROL_DISABLE) ||                                                 ((CONTROL) == SDMMC_HARDWARE_FLOW_CONTROL_ENABLE))
N/**
N  * @}
N  */
N  
N/** @defgroup SDMMC_LL_Clock_Division Clock Division
N  * @{
N  */
N#define IS_SDMMC_CLKDIV(DIV)   ((DIV) <= 0xFF)
N/**
N  * @}
N  */  
N    
N/** @defgroup SDMMC_LL_Command_Index Command Index
N  * @{
N  */
N#define IS_SDMMC_CMD_INDEX(INDEX)            ((INDEX) < 0x40)
N/**
N  * @}
N  */
N
N/** @defgroup SDMMC_LL_Response_Type Response Type
N  * @{
N  */
N#define SDMMC_RESPONSE_NO                    ((uint32_t)0x00000000U)
N#define SDMMC_RESPONSE_SHORT                 SDMMC_CMD_WAITRESP_0
N#define SDMMC_RESPONSE_LONG                  SDMMC_CMD_WAITRESP
N
N#define IS_SDMMC_RESPONSE(RESPONSE) (((RESPONSE) == SDMMC_RESPONSE_NO)    || \
N                                    ((RESPONSE) == SDMMC_RESPONSE_SHORT) || \
N                                    ((RESPONSE) == SDMMC_RESPONSE_LONG))
X#define IS_SDMMC_RESPONSE(RESPONSE) (((RESPONSE) == SDMMC_RESPONSE_NO)    ||                                     ((RESPONSE) == SDMMC_RESPONSE_SHORT) ||                                     ((RESPONSE) == SDMMC_RESPONSE_LONG))
N/**
N  * @}
N  */
N
N/** @defgroup SDMMC_LL_Wait_Interrupt_State Wait Interrupt
N  * @{
N  */
N#define SDMMC_WAIT_NO                        ((uint32_t)0x00000000U)
N#define SDMMC_WAIT_IT                        SDMMC_CMD_WAITINT 
N#define SDMMC_WAIT_PEND                      SDMMC_CMD_WAITPEND
N
N#define IS_SDMMC_WAIT(WAIT) (((WAIT) == SDMMC_WAIT_NO) || \
N                            ((WAIT) == SDMMC_WAIT_IT) || \
N                            ((WAIT) == SDMMC_WAIT_PEND))
X#define IS_SDMMC_WAIT(WAIT) (((WAIT) == SDMMC_WAIT_NO) ||                             ((WAIT) == SDMMC_WAIT_IT) ||                             ((WAIT) == SDMMC_WAIT_PEND))
N/**
N  * @}
N  */
N
N/** @defgroup SDMMC_LL_CPSM_State CPSM State
N  * @{
N  */
N#define SDMMC_CPSM_DISABLE                   ((uint32_t)0x00000000U)
N#define SDMMC_CPSM_ENABLE                    SDMMC_CMD_CPSMEN
N
N#define IS_SDMMC_CPSM(CPSM) (((CPSM) == SDMMC_CPSM_DISABLE) || \
N                            ((CPSM) == SDMMC_CPSM_ENABLE))
X#define IS_SDMMC_CPSM(CPSM) (((CPSM) == SDMMC_CPSM_DISABLE) ||                             ((CPSM) == SDMMC_CPSM_ENABLE))
N/**
N  * @}
N  */  
N
N/** @defgroup SDMMC_LL_Response_Registers Response Register
N  * @{
N  */
N#define SDMMC_RESP1                          ((uint32_t)0x00000000U)
N#define SDMMC_RESP2                          ((uint32_t)0x00000004U)
N#define SDMMC_RESP3                          ((uint32_t)0x00000008U)
N#define SDMMC_RESP4                          ((uint32_t)0x0000000C)
N
N#define IS_SDMMC_RESP(RESP) (((RESP) == SDMMC_RESP1) || \
N                            ((RESP) == SDMMC_RESP2) || \
N                            ((RESP) == SDMMC_RESP3) || \
N                            ((RESP) == SDMMC_RESP4))
X#define IS_SDMMC_RESP(RESP) (((RESP) == SDMMC_RESP1) ||                             ((RESP) == SDMMC_RESP2) ||                             ((RESP) == SDMMC_RESP3) ||                             ((RESP) == SDMMC_RESP4))
N/**
N  * @}
N  */
N
N/** @defgroup SDMMC_LL_Data_Length Data Lenght
N  * @{
N  */
N#define IS_SDMMC_DATA_LENGTH(LENGTH) ((LENGTH) <= 0x01FFFFFF)
N/**
N  * @}
N  */
N
N/** @defgroup SDMMC_LL_Data_Block_Size  Data Block Size
N  * @{
N  */
N#define SDMMC_DATABLOCK_SIZE_1B               ((uint32_t)0x00000000U)
N#define SDMMC_DATABLOCK_SIZE_2B               SDMMC_DCTRL_DBLOCKSIZE_0
N#define SDMMC_DATABLOCK_SIZE_4B               SDMMC_DCTRL_DBLOCKSIZE_1
N#define SDMMC_DATABLOCK_SIZE_8B               (SDMMC_DCTRL_DBLOCKSIZE_0|SDMMC_DCTRL_DBLOCKSIZE_1)
N#define SDMMC_DATABLOCK_SIZE_16B              SDMMC_DCTRL_DBLOCKSIZE_2
N#define SDMMC_DATABLOCK_SIZE_32B              (SDMMC_DCTRL_DBLOCKSIZE_0|SDMMC_DCTRL_DBLOCKSIZE_2)
N#define SDMMC_DATABLOCK_SIZE_64B              (SDMMC_DCTRL_DBLOCKSIZE_1|SDMMC_DCTRL_DBLOCKSIZE_2)
N#define SDMMC_DATABLOCK_SIZE_128B             (SDMMC_DCTRL_DBLOCKSIZE_0|SDMMC_DCTRL_DBLOCKSIZE_1|SDMMC_DCTRL_DBLOCKSIZE_2)
N#define SDMMC_DATABLOCK_SIZE_256B             SDMMC_DCTRL_DBLOCKSIZE_3
N#define SDMMC_DATABLOCK_SIZE_512B             (SDMMC_DCTRL_DBLOCKSIZE_0|SDMMC_DCTRL_DBLOCKSIZE_3)
N#define SDMMC_DATABLOCK_SIZE_1024B            (SDMMC_DCTRL_DBLOCKSIZE_1|SDMMC_DCTRL_DBLOCKSIZE_3)
N#define SDMMC_DATABLOCK_SIZE_2048B            (SDMMC_DCTRL_DBLOCKSIZE_0|SDMMC_DCTRL_DBLOCKSIZE_1|SDMMC_DCTRL_DBLOCKSIZE_3) 
N#define SDMMC_DATABLOCK_SIZE_4096B            (SDMMC_DCTRL_DBLOCKSIZE_2|SDMMC_DCTRL_DBLOCKSIZE_3)
N#define SDMMC_DATABLOCK_SIZE_8192B            (SDMMC_DCTRL_DBLOCKSIZE_0|SDMMC_DCTRL_DBLOCKSIZE_2|SDMMC_DCTRL_DBLOCKSIZE_3)
N#define SDMMC_DATABLOCK_SIZE_16384B           (SDMMC_DCTRL_DBLOCKSIZE_1|SDMMC_DCTRL_DBLOCKSIZE_2|SDMMC_DCTRL_DBLOCKSIZE_3)
N
N#define IS_SDMMC_BLOCK_SIZE(SIZE) (((SIZE) == SDMMC_DATABLOCK_SIZE_1B)    || \
N                                  ((SIZE) == SDMMC_DATABLOCK_SIZE_2B)    || \
N                                  ((SIZE) == SDMMC_DATABLOCK_SIZE_4B)    || \
N                                  ((SIZE) == SDMMC_DATABLOCK_SIZE_8B)    || \
N                                  ((SIZE) == SDMMC_DATABLOCK_SIZE_16B)   || \
N                                  ((SIZE) == SDMMC_DATABLOCK_SIZE_32B)   || \
N                                  ((SIZE) == SDMMC_DATABLOCK_SIZE_64B)   || \
N                                  ((SIZE) == SDMMC_DATABLOCK_SIZE_128B)  || \
N                                  ((SIZE) == SDMMC_DATABLOCK_SIZE_256B)  || \
N                                  ((SIZE) == SDMMC_DATABLOCK_SIZE_512B)  || \
N                                  ((SIZE) == SDMMC_DATABLOCK_SIZE_1024B) || \
N                                  ((SIZE) == SDMMC_DATABLOCK_SIZE_2048B) || \
N                                  ((SIZE) == SDMMC_DATABLOCK_SIZE_4096B) || \
N                                  ((SIZE) == SDMMC_DATABLOCK_SIZE_8192B) || \
N                                  ((SIZE) == SDMMC_DATABLOCK_SIZE_16384B)) 
X#define IS_SDMMC_BLOCK_SIZE(SIZE) (((SIZE) == SDMMC_DATABLOCK_SIZE_1B)    ||                                   ((SIZE) == SDMMC_DATABLOCK_SIZE_2B)    ||                                   ((SIZE) == SDMMC_DATABLOCK_SIZE_4B)    ||                                   ((SIZE) == SDMMC_DATABLOCK_SIZE_8B)    ||                                   ((SIZE) == SDMMC_DATABLOCK_SIZE_16B)   ||                                   ((SIZE) == SDMMC_DATABLOCK_SIZE_32B)   ||                                   ((SIZE) == SDMMC_DATABLOCK_SIZE_64B)   ||                                   ((SIZE) == SDMMC_DATABLOCK_SIZE_128B)  ||                                   ((SIZE) == SDMMC_DATABLOCK_SIZE_256B)  ||                                   ((SIZE) == SDMMC_DATABLOCK_SIZE_512B)  ||                                   ((SIZE) == SDMMC_DATABLOCK_SIZE_1024B) ||                                   ((SIZE) == SDMMC_DATABLOCK_SIZE_2048B) ||                                   ((SIZE) == SDMMC_DATABLOCK_SIZE_4096B) ||                                   ((SIZE) == SDMMC_DATABLOCK_SIZE_8192B) ||                                   ((SIZE) == SDMMC_DATABLOCK_SIZE_16384B)) 
N/**
N  * @}
N  */
N
N/** @defgroup SDMMC_LL_Transfer_Direction Transfer Direction
N  * @{
N  */
N#define SDMMC_TRANSFER_DIR_TO_CARD            ((uint32_t)0x00000000U)
N#define SDMMC_TRANSFER_DIR_TO_SDMMC            SDMMC_DCTRL_DTDIR
N
N#define IS_SDMMC_TRANSFER_DIR(DIR) (((DIR) == SDMMC_TRANSFER_DIR_TO_CARD) || \
N                                   ((DIR) == SDMMC_TRANSFER_DIR_TO_SDMMC))
X#define IS_SDMMC_TRANSFER_DIR(DIR) (((DIR) == SDMMC_TRANSFER_DIR_TO_CARD) ||                                    ((DIR) == SDMMC_TRANSFER_DIR_TO_SDMMC))
N/**
N  * @}
N  */
N
N/** @defgroup SDMMC_LL_Transfer_Type Transfer Type
N  * @{
N  */
N#define SDMMC_TRANSFER_MODE_BLOCK             ((uint32_t)0x00000000U)
N#define SDMMC_TRANSFER_MODE_STREAM            SDMMC_DCTRL_DTMODE
N
N#define IS_SDMMC_TRANSFER_MODE(MODE) (((MODE) == SDMMC_TRANSFER_MODE_BLOCK) || \
N                                     ((MODE) == SDMMC_TRANSFER_MODE_STREAM))
X#define IS_SDMMC_TRANSFER_MODE(MODE) (((MODE) == SDMMC_TRANSFER_MODE_BLOCK) ||                                      ((MODE) == SDMMC_TRANSFER_MODE_STREAM))
N/**
N  * @}
N  */
N
N/** @defgroup SDMMC_LL_DPSM_State DPSM State
N  * @{
N  */
N#define SDMMC_DPSM_DISABLE                    ((uint32_t)0x00000000U)
N#define SDMMC_DPSM_ENABLE                     SDMMC_DCTRL_DTEN
N
N#define IS_SDMMC_DPSM(DPSM) (((DPSM) == SDMMC_DPSM_DISABLE) ||\
N                            ((DPSM) == SDMMC_DPSM_ENABLE))
X#define IS_SDMMC_DPSM(DPSM) (((DPSM) == SDMMC_DPSM_DISABLE) ||                            ((DPSM) == SDMMC_DPSM_ENABLE))
N/**
N  * @}
N  */
N  
N/** @defgroup SDMMC_LL_Read_Wait_Mode Read Wait Mode
N  * @{
N  */
N#define SDMMC_READ_WAIT_MODE_DATA2                ((uint32_t)0x00000000U)
N#define SDMMC_READ_WAIT_MODE_CLK                  (SDMMC_DCTRL_RWMOD)
N
N#define IS_SDMMC_READWAIT_MODE(MODE) (((MODE) == SDMMC_READ_WAIT_MODE_CLK) || \
N                                     ((MODE) == SDMMC_READ_WAIT_MODE_DATA2))
X#define IS_SDMMC_READWAIT_MODE(MODE) (((MODE) == SDMMC_READ_WAIT_MODE_CLK) ||                                      ((MODE) == SDMMC_READ_WAIT_MODE_DATA2))
N/**
N  * @}
N  */  
N
N/** @defgroup SDMMC_LL_Interrupt_sources Interrupt Sources
N  * @{
N  */
N#define SDMMC_IT_CCRCFAIL                    SDMMC_STA_CCRCFAIL
N#define SDMMC_IT_DCRCFAIL                    SDMMC_STA_DCRCFAIL
N#define SDMMC_IT_CTIMEOUT                    SDMMC_STA_CTIMEOUT
N#define SDMMC_IT_DTIMEOUT                    SDMMC_STA_DTIMEOUT
N#define SDMMC_IT_TXUNDERR                    SDMMC_STA_TXUNDERR
N#define SDMMC_IT_RXOVERR                     SDMMC_STA_RXOVERR
N#define SDMMC_IT_CMDREND                     SDMMC_STA_CMDREND
N#define SDMMC_IT_CMDSENT                     SDMMC_STA_CMDSENT
N#define SDMMC_IT_DATAEND                     SDMMC_STA_DATAEND
N#define SDMMC_IT_DBCKEND                     SDMMC_STA_DBCKEND
N#define SDMMC_IT_CMDACT                      SDMMC_STA_CMDACT
N#define SDMMC_IT_TXACT                       SDMMC_STA_TXACT
N#define SDMMC_IT_RXACT                       SDMMC_STA_RXACT
N#define SDMMC_IT_TXFIFOHE                    SDMMC_STA_TXFIFOHE
N#define SDMMC_IT_RXFIFOHF                    SDMMC_STA_RXFIFOHF
N#define SDMMC_IT_TXFIFOF                     SDMMC_STA_TXFIFOF
N#define SDMMC_IT_RXFIFOF                     SDMMC_STA_RXFIFOF
N#define SDMMC_IT_TXFIFOE                     SDMMC_STA_TXFIFOE
N#define SDMMC_IT_RXFIFOE                     SDMMC_STA_RXFIFOE
N#define SDMMC_IT_TXDAVL                      SDMMC_STA_TXDAVL
N#define SDMMC_IT_RXDAVL                      SDMMC_STA_RXDAVL
N#define SDMMC_IT_SDIOIT                      SDMMC_STA_SDIOIT
N/**
N  * @}
N  */ 
N
N/** @defgroup SDMMC_LL_Flags Flags
N  * @{
N  */
N#define SDMMC_FLAG_CCRCFAIL                  SDMMC_STA_CCRCFAIL
N#define SDMMC_FLAG_DCRCFAIL                  SDMMC_STA_DCRCFAIL
N#define SDMMC_FLAG_CTIMEOUT                  SDMMC_STA_CTIMEOUT
N#define SDMMC_FLAG_DTIMEOUT                  SDMMC_STA_DTIMEOUT
N#define SDMMC_FLAG_TXUNDERR                  SDMMC_STA_TXUNDERR
N#define SDMMC_FLAG_RXOVERR                   SDMMC_STA_RXOVERR
N#define SDMMC_FLAG_CMDREND                   SDMMC_STA_CMDREND
N#define SDMMC_FLAG_CMDSENT                   SDMMC_STA_CMDSENT
N#define SDMMC_FLAG_DATAEND                   SDMMC_STA_DATAEND
N#define SDMMC_FLAG_DBCKEND                   SDMMC_STA_DBCKEND
N#define SDMMC_FLAG_CMDACT                    SDMMC_STA_CMDACT
N#define SDMMC_FLAG_TXACT                     SDMMC_STA_TXACT
N#define SDMMC_FLAG_RXACT                     SDMMC_STA_RXACT
N#define SDMMC_FLAG_TXFIFOHE                  SDMMC_STA_TXFIFOHE
N#define SDMMC_FLAG_RXFIFOHF                  SDMMC_STA_RXFIFOHF
N#define SDMMC_FLAG_TXFIFOF                   SDMMC_STA_TXFIFOF
N#define SDMMC_FLAG_RXFIFOF                   SDMMC_STA_RXFIFOF
N#define SDMMC_FLAG_TXFIFOE                   SDMMC_STA_TXFIFOE
N#define SDMMC_FLAG_RXFIFOE                   SDMMC_STA_RXFIFOE
N#define SDMMC_FLAG_TXDAVL                    SDMMC_STA_TXDAVL
N#define SDMMC_FLAG_RXDAVL                    SDMMC_STA_RXDAVL
N#define SDMMC_FLAG_SDIOIT                    SDMMC_STA_SDIOIT
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N  
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup SDMMC_LL_Exported_macros SDMMC_LL Exported Macros
N  * @{
N  */
N  
N/** @defgroup SDMMC_LL_Register Bits And Addresses Definitions
N  * @brief SDMMC_LL registers bit address in the alias region
N  * @{
N  */
N/* ---------------------- SDMMC registers bit mask --------------------------- */
N/* --- CLKCR Register ---*/
N/* CLKCR register clear mask */ 
N#define CLKCR_CLEAR_MASK         ((uint32_t)(SDMMC_CLKCR_CLKDIV  | SDMMC_CLKCR_PWRSAV |\
N                                             SDMMC_CLKCR_BYPASS  | SDMMC_CLKCR_WIDBUS |\
N                                             SDMMC_CLKCR_NEGEDGE | SDMMC_CLKCR_HWFC_EN))
X#define CLKCR_CLEAR_MASK         ((uint32_t)(SDMMC_CLKCR_CLKDIV  | SDMMC_CLKCR_PWRSAV |                                             SDMMC_CLKCR_BYPASS  | SDMMC_CLKCR_WIDBUS |                                             SDMMC_CLKCR_NEGEDGE | SDMMC_CLKCR_HWFC_EN))
N
N/* --- DCTRL Register ---*/
N/* SDMMC DCTRL Clear Mask */
N#define DCTRL_CLEAR_MASK         ((uint32_t)(SDMMC_DCTRL_DTEN    | SDMMC_DCTRL_DTDIR |\
N                                             SDMMC_DCTRL_DTMODE  | SDMMC_DCTRL_DBLOCKSIZE))
X#define DCTRL_CLEAR_MASK         ((uint32_t)(SDMMC_DCTRL_DTEN    | SDMMC_DCTRL_DTDIR |                                             SDMMC_DCTRL_DTMODE  | SDMMC_DCTRL_DBLOCKSIZE))
N
N/* --- CMD Register ---*/
N/* CMD Register clear mask */
N#define CMD_CLEAR_MASK           ((uint32_t)(SDMMC_CMD_CMDINDEX | SDMMC_CMD_WAITRESP |\
N                                             SDMMC_CMD_WAITINT  | SDMMC_CMD_WAITPEND |\
N                                             SDMMC_CMD_CPSMEN   | SDMMC_CMD_SDIOSUSPEND))
X#define CMD_CLEAR_MASK           ((uint32_t)(SDMMC_CMD_CMDINDEX | SDMMC_CMD_WAITRESP |                                             SDMMC_CMD_WAITINT  | SDMMC_CMD_WAITPEND |                                             SDMMC_CMD_CPSMEN   | SDMMC_CMD_SDIOSUSPEND))
N
N/* SDMMC Initialization Frequency (400KHz max) */
N#define SDMMC_INIT_CLK_DIV ((uint8_t)0x76)
N
N/* SDMMC Data Transfer Frequency (25MHz max) */
N#define SDMMC_TRANSFER_CLK_DIV ((uint8_t)0x0)
N
N/**
N  * @}
N  */
N
N/** @defgroup SDMMC_LL_Interrupt_Clock Interrupt And Clock Configuration
N *  @brief macros to handle interrupts and specific clock configurations
N * @{
N */
N 
N/**
N  * @brief  Enable the SDMMC device.
N  * @param  __INSTANCE__: SDMMC Instance  
N  * @retval None
N  */ 
N#define __SDMMC_ENABLE(__INSTANCE__)  ((__INSTANCE__)->CLKCR |= SDMMC_CLKCR_CLKEN)
N
N/**
N  * @brief  Disable the SDMMC device.
N  * @param  __INSTANCE__: SDMMC Instance  
N  * @retval None
N  */
N#define __SDMMC_DISABLE(__INSTANCE__)  ((__INSTANCE__)->CLKCR &= ~SDMMC_CLKCR_CLKEN)
N
N/**
N  * @brief  Enable the SDMMC DMA transfer.
N  * @param  __INSTANCE__: SDMMC Instance  
N  * @retval None
N  */ 
N#define __SDMMC_DMA_ENABLE(__INSTANCE__)  ((__INSTANCE__)->DCTRL |= SDMMC_DCTRL_DMAEN)
N/**
N  * @brief  Disable the SDMMC DMA transfer.
N  * @param  __INSTANCE__: SDMMC Instance   
N  * @retval None
N  */
N#define __SDMMC_DMA_DISABLE(__INSTANCE__)  ((__INSTANCE__)->DCTRL &= ~SDMMC_DCTRL_DMAEN)
N 
N/**
N  * @brief  Enable the SDMMC device interrupt.
N  * @param  __INSTANCE__ : Pointer to SDMMC register base  
N  * @param  __INTERRUPT__ : specifies the SDMMC interrupt sources to be enabled.
N  *         This parameter can be one or a combination of the following values:
N  *            @arg SDMMC_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
N  *            @arg SDMMC_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
N  *            @arg SDMMC_IT_CTIMEOUT: Command response timeout interrupt
N  *            @arg SDMMC_IT_DTIMEOUT: Data timeout interrupt
N  *            @arg SDMMC_IT_TXUNDERR: Transmit FIFO underrun error interrupt
N  *            @arg SDMMC_IT_RXOVERR:  Received FIFO overrun error interrupt
N  *            @arg SDMMC_IT_CMDREND:  Command response received (CRC check passed) interrupt
N  *            @arg SDMMC_IT_CMDSENT:  Command sent (no response required) interrupt
N  *            @arg SDMMC_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is zero) interrupt
N  *            @arg SDMMC_IT_DBCKEND:  Data block sent/received (CRC check passed) interrupt
N  *            @arg SDMMC_IT_CMDACT:   Command transfer in progress interrupt
N  *            @arg SDMMC_IT_TXACT:    Data transmit in progress interrupt
N  *            @arg SDMMC_IT_RXACT:    Data receive in progress interrupt
N  *            @arg SDMMC_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt
N  *            @arg SDMMC_IT_RXFIFOHF: Receive FIFO Half Full interrupt
N  *            @arg SDMMC_IT_TXFIFOF:  Transmit FIFO full interrupt
N  *            @arg SDMMC_IT_RXFIFOF:  Receive FIFO full interrupt
N  *            @arg SDMMC_IT_TXFIFOE:  Transmit FIFO empty interrupt
N  *            @arg SDMMC_IT_RXFIFOE:  Receive FIFO empty interrupt
N  *            @arg SDMMC_IT_TXDAVL:   Data available in transmit FIFO interrupt
N  *            @arg SDMMC_IT_RXDAVL:   Data available in receive FIFO interrupt
N  *            @arg SDMMC_IT_SDIOIT:   SD I/O interrupt received interrupt   
N  * @retval None
N  */
N#define __SDMMC_ENABLE_IT(__INSTANCE__, __INTERRUPT__)  ((__INSTANCE__)->MASK |= (__INTERRUPT__))
N
N/**
N  * @brief  Disable the SDMMC device interrupt.
N  * @param  __INSTANCE__ : Pointer to SDMMC register base   
N  * @param  __INTERRUPT__ : specifies the SDMMC interrupt sources to be disabled.
N  *          This parameter can be one or a combination of the following values:
N  *            @arg SDMMC_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
N  *            @arg SDMMC_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
N  *            @arg SDMMC_IT_CTIMEOUT: Command response timeout interrupt
N  *            @arg SDMMC_IT_DTIMEOUT: Data timeout interrupt
N  *            @arg SDMMC_IT_TXUNDERR: Transmit FIFO underrun error interrupt
N  *            @arg SDMMC_IT_RXOVERR:  Received FIFO overrun error interrupt
N  *            @arg SDMMC_IT_CMDREND:  Command response received (CRC check passed) interrupt
N  *            @arg SDMMC_IT_CMDSENT:  Command sent (no response required) interrupt
N  *            @arg SDMMC_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is zero) interrupt
N  *            @arg SDMMC_IT_DBCKEND:  Data block sent/received (CRC check passed) interrupt
N  *            @arg SDMMC_IT_CMDACT:   Command transfer in progress interrupt
N  *            @arg SDMMC_IT_TXACT:    Data transmit in progress interrupt
N  *            @arg SDMMC_IT_RXACT:    Data receive in progress interrupt
N  *            @arg SDMMC_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt
N  *            @arg SDMMC_IT_RXFIFOHF: Receive FIFO Half Full interrupt
N  *            @arg SDMMC_IT_TXFIFOF:  Transmit FIFO full interrupt
N  *            @arg SDMMC_IT_RXFIFOF:  Receive FIFO full interrupt
N  *            @arg SDMMC_IT_TXFIFOE:  Transmit FIFO empty interrupt
N  *            @arg SDMMC_IT_RXFIFOE:  Receive FIFO empty interrupt
N  *            @arg SDMMC_IT_TXDAVL:   Data available in transmit FIFO interrupt
N  *            @arg SDMMC_IT_RXDAVL:   Data available in receive FIFO interrupt
N  *            @arg SDMMC_IT_SDIOIT:   SD I/O interrupt received interrupt   
N  * @retval None
N  */
N#define __SDMMC_DISABLE_IT(__INSTANCE__, __INTERRUPT__)  ((__INSTANCE__)->MASK &= ~(__INTERRUPT__))
N
N/**
N  * @brief  Checks whether the specified SDMMC flag is set or not. 
N  * @param  __INSTANCE__ : Pointer to SDMMC register base   
N  * @param  __FLAG__: specifies the flag to check. 
N  *          This parameter can be one of the following values:
N  *            @arg SDMMC_FLAG_CCRCFAIL: Command response received (CRC check failed)
N  *            @arg SDMMC_FLAG_DCRCFAIL: Data block sent/received (CRC check failed)
N  *            @arg SDMMC_FLAG_CTIMEOUT: Command response timeout
N  *            @arg SDMMC_FLAG_DTIMEOUT: Data timeout
N  *            @arg SDMMC_FLAG_TXUNDERR: Transmit FIFO underrun error
N  *            @arg SDMMC_FLAG_RXOVERR:  Received FIFO overrun error
N  *            @arg SDMMC_FLAG_CMDREND:  Command response received (CRC check passed)
N  *            @arg SDMMC_FLAG_CMDSENT:  Command sent (no response required)
N  *            @arg SDMMC_FLAG_DATAEND:  Data end (data counter, SDIDCOUNT, is zero)
N  *            @arg SDMMC_FLAG_DBCKEND:  Data block sent/received (CRC check passed)
N  *            @arg SDMMC_FLAG_CMDACT:   Command transfer in progress
N  *            @arg SDMMC_FLAG_TXACT:    Data transmit in progress
N  *            @arg SDMMC_FLAG_RXACT:    Data receive in progress
N  *            @arg SDMMC_FLAG_TXFIFOHE: Transmit FIFO Half Empty
N  *            @arg SDMMC_FLAG_RXFIFOHF: Receive FIFO Half Full
N  *            @arg SDMMC_FLAG_TXFIFOF:  Transmit FIFO full
N  *            @arg SDMMC_FLAG_RXFIFOF:  Receive FIFO full
N  *            @arg SDMMC_FLAG_TXFIFOE:  Transmit FIFO empty
N  *            @arg SDMMC_FLAG_RXFIFOE:  Receive FIFO empty
N  *            @arg SDMMC_FLAG_TXDAVL:   Data available in transmit FIFO
N  *            @arg SDMMC_FLAG_RXDAVL:   Data available in receive FIFO
N  *            @arg SDMMC_FLAG_SDMMCIT:   SD I/O interrupt received
N  * @retval The new state of SDMMC_FLAG (SET or RESET).
N  */
N#define __SDMMC_GET_FLAG(__INSTANCE__, __FLAG__)  (((__INSTANCE__)->STA &(__FLAG__)) != RESET)
N
N
N/**
N  * @brief  Clears the SDMMC pending flags.
N  * @param  __INSTANCE__ : Pointer to SDMMC register base  
N  * @param  __FLAG__: specifies the flag to clear.  
N  *          This parameter can be one or a combination of the following values:
N  *            @arg SDMMC_FLAG_CCRCFAIL: Command response received (CRC check failed)
N  *            @arg SDMMC_FLAG_DCRCFAIL: Data block sent/received (CRC check failed)
N  *            @arg SDMMC_FLAG_CTIMEOUT: Command response timeout
N  *            @arg SDMMC_FLAG_DTIMEOUT: Data timeout
N  *            @arg SDMMC_FLAG_TXUNDERR: Transmit FIFO underrun error
N  *            @arg SDMMC_FLAG_RXOVERR:  Received FIFO overrun error
N  *            @arg SDMMC_FLAG_CMDREND:  Command response received (CRC check passed)
N  *            @arg SDMMC_FLAG_CMDSENT:  Command sent (no response required)
N  *            @arg SDMMC_FLAG_DATAEND:  Data end (data counter, SDIDCOUNT, is zero)
N  *            @arg SDMMC_FLAG_DBCKEND:  Data block sent/received (CRC check passed)
N  *            @arg SDMMC_FLAG_SDMMCIT:   SD I/O interrupt received
N  * @retval None
N  */
N#define __SDMMC_CLEAR_FLAG(__INSTANCE__, __FLAG__)  ((__INSTANCE__)->ICR = (__FLAG__))
N
N/**
N  * @brief  Checks whether the specified SDMMC interrupt has occurred or not.
N  * @param  __INSTANCE__ : Pointer to SDMMC register base   
N  * @param  __INTERRUPT__: specifies the SDMMC interrupt source to check. 
N  *          This parameter can be one of the following values:
N  *            @arg SDMMC_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
N  *            @arg SDMMC_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
N  *            @arg SDMMC_IT_CTIMEOUT: Command response timeout interrupt
N  *            @arg SDMMC_IT_DTIMEOUT: Data timeout interrupt
N  *            @arg SDMMC_IT_TXUNDERR: Transmit FIFO underrun error interrupt
N  *            @arg SDMMC_IT_RXOVERR:  Received FIFO overrun error interrupt
N  *            @arg SDMMC_IT_CMDREND:  Command response received (CRC check passed) interrupt
N  *            @arg SDMMC_IT_CMDSENT:  Command sent (no response required) interrupt
N  *            @arg SDMMC_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is zero) interrupt
N  *            @arg SDMMC_IT_DBCKEND:  Data block sent/received (CRC check passed) interrupt
N  *            @arg SDMMC_IT_CMDACT:   Command transfer in progress interrupt
N  *            @arg SDMMC_IT_TXACT:    Data transmit in progress interrupt
N  *            @arg SDMMC_IT_RXACT:    Data receive in progress interrupt
N  *            @arg SDMMC_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt
N  *            @arg SDMMC_IT_RXFIFOHF: Receive FIFO Half Full interrupt
N  *            @arg SDMMC_IT_TXFIFOF:  Transmit FIFO full interrupt
N  *            @arg SDMMC_IT_RXFIFOF:  Receive FIFO full interrupt
N  *            @arg SDMMC_IT_TXFIFOE:  Transmit FIFO empty interrupt
N  *            @arg SDMMC_IT_RXFIFOE:  Receive FIFO empty interrupt
N  *            @arg SDMMC_IT_TXDAVL:   Data available in transmit FIFO interrupt
N  *            @arg SDMMC_IT_RXDAVL:   Data available in receive FIFO interrupt
N  *            @arg SDMMC_IT_SDIOIT:   SD I/O interrupt received interrupt
N  * @retval The new state of SDMMC_IT (SET or RESET).
N  */
N#define __SDMMC_GET_IT  (__INSTANCE__, __INTERRUPT__)  (((__INSTANCE__)->STA &(__INTERRUPT__)) == (__INTERRUPT__))
N
N/**
N  * @brief  Clears the SDMMC's interrupt pending bits.
N  * @param  __INSTANCE__ : Pointer to SDMMC register base 
N  * @param  __INTERRUPT__: specifies the interrupt pending bit to clear. 
N  *          This parameter can be one or a combination of the following values:
N  *            @arg SDMMC_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
N  *            @arg SDMMC_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
N  *            @arg SDMMC_IT_CTIMEOUT: Command response timeout interrupt
N  *            @arg SDMMC_IT_DTIMEOUT: Data timeout interrupt
N  *            @arg SDMMC_IT_TXUNDERR: Transmit FIFO underrun error interrupt
N  *            @arg SDMMC_IT_RXOVERR:  Received FIFO overrun error interrupt
N  *            @arg SDMMC_IT_CMDREND:  Command response received (CRC check passed) interrupt
N  *            @arg SDMMC_IT_CMDSENT:  Command sent (no response required) interrupt
N  *            @arg SDMMC_IT_DATAEND:  Data end (data counter, SDMMC_DCOUNT, is zero) interrupt
N  *            @arg SDMMC_IT_SDIOIT:   SD I/O interrupt received interrupt
N  * @retval None
N  */
N#define __SDMMC_CLEAR_IT(__INSTANCE__, __INTERRUPT__)  ((__INSTANCE__)->ICR = (__INTERRUPT__))
N
N/**
N  * @brief  Enable Start the SD I/O Read Wait operation.
N  * @param  __INSTANCE__ : Pointer to SDMMC register base  
N  * @retval None
N  */  
N#define __SDMMC_START_READWAIT_ENABLE(__INSTANCE__)  ((__INSTANCE__)->DCTRL |= SDMMC_DCTRL_RWSTART)
N
N/**
N  * @brief  Disable Start the SD I/O Read Wait operations.
N  * @param  __INSTANCE__ : Pointer to SDMMC register base   
N  * @retval None
N  */  
N#define __SDMMC_START_READWAIT_DISABLE(__INSTANCE__)  ((__INSTANCE__)->DCTRL &= ~SDMMC_DCTRL_RWSTART)
N
N/**
N  * @brief  Enable Start the SD I/O Read Wait operation.
N  * @param  __INSTANCE__ : Pointer to SDMMC register base   
N  * @retval None
N  */  
N#define __SDMMC_STOP_READWAIT_ENABLE(__INSTANCE__)  ((__INSTANCE__)->DCTRL |= SDMMC_DCTRL_RWSTOP)
N
N/**
N  * @brief  Disable Stop the SD I/O Read Wait operations.
N  * @param  __INSTANCE__ : Pointer to SDMMC register base  
N  * @retval None
N  */  
N#define __SDMMC_STOP_READWAIT_DISABLE(__INSTANCE__)  ((__INSTANCE__)->DCTRL &= ~SDMMC_DCTRL_RWSTOP)
N
N/**
N  * @brief  Enable the SD I/O Mode Operation.
N  * @param  __INSTANCE__ : Pointer to SDMMC register base   
N  * @retval None
N  */  
N#define __SDMMC_OPERATION_ENABLE(__INSTANCE__)  ((__INSTANCE__)->DCTRL |= SDMMC_DCTRL_SDIOEN) 
N
N/**
N  * @brief  Disable the SD I/O Mode Operation.
N  * @param  __INSTANCE__ : Pointer to SDMMC register base 
N  * @retval None
N  */  
N#define __SDMMC_OPERATION_DISABLE(__INSTANCE__)  ((__INSTANCE__)->DCTRL &= ~SDMMC_DCTRL_SDIOEN) 
N
N/**
N  * @brief  Enable the SD I/O Suspend command sending.
N  * @param  __INSTANCE__ : Pointer to SDMMC register base  
N  * @retval None
N  */  
N#define __SDMMC_SUSPEND_CMD_ENABLE(__INSTANCE__)  ((__INSTANCE__)->CMD |= SDMMC_CMD_SDIOSUSPEND) 
N
N/**
N  * @brief  Disable the SD I/O Suspend command sending.
N  * @param  __INSTANCE__ : Pointer to SDMMC register base  
N  * @retval None
N  */  
N#define __SDMMC_SUSPEND_CMD_DISABLE(__INSTANCE__)  ((__INSTANCE__)->CMD &= ~SDMMC_CMD_SDIOSUSPEND) 
N      
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */  
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup SDMMC_LL_Exported_Functions
N  * @{
N  */
N  
N/* Initialization/de-initialization functions  **********************************/
N/** @addtogroup HAL_SDMMC_LL_Group1
N  * @{
N  */
NHAL_StatusTypeDef SDMMC_Init(SDMMC_TypeDef *SDMMCx, SDMMC_InitTypeDef Init);
N/**
N  * @}
N  */
N  
N/* I/O operation functions  *****************************************************/
N/** @addtogroup HAL_SDMMC_LL_Group2
N  * @{
N  */
N/* Blocking mode: Polling */
Nuint32_t          SDMMC_ReadFIFO(SDMMC_TypeDef *SDMMCx);
NHAL_StatusTypeDef SDMMC_WriteFIFO(SDMMC_TypeDef *SDMMCx, uint32_t *pWriteData);
N/**
N  * @}
N  */
N  
N/* Peripheral Control functions  ************************************************/
N/** @addtogroup HAL_SDMMC_LL_Group3
N  * @{
N  */
NHAL_StatusTypeDef SDMMC_PowerState_ON(SDMMC_TypeDef *SDMMCx);
NHAL_StatusTypeDef SDMMC_PowerState_OFF(SDMMC_TypeDef *SDMMCx);
Nuint32_t          SDMMC_GetPowerState(SDMMC_TypeDef *SDMMCx);
N
N/* Command path state machine (CPSM) management functions */
NHAL_StatusTypeDef SDMMC_SendCommand(SDMMC_TypeDef *SDMMCx, SDMMC_CmdInitTypeDef *Command);
Nuint8_t           SDMMC_GetCommandResponse(SDMMC_TypeDef *SDMMCx);
Nuint32_t          SDMMC_GetResponse(SDMMC_TypeDef *SDMMCx, uint32_t Response);
N
N/* Data path state machine (DPSM) management functions */
NHAL_StatusTypeDef SDMMC_DataConfig(SDMMC_TypeDef *SDMMCx, SDMMC_DataInitTypeDef* Data);
Nuint32_t          SDMMC_GetDataCounter(SDMMC_TypeDef *SDMMCx);
Nuint32_t          SDMMC_GetFIFOCount(SDMMC_TypeDef *SDMMCx);
N
N/* SDMMC Cards mode management functions */
NHAL_StatusTypeDef SDMMC_SetSDMMCReadWaitMode(SDMMC_TypeDef *SDMMCx, uint32_t SDMMC_ReadWaitMode);
N
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_LL_SDMMC_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 48 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_sd.h" 2
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @defgroup SD SD
N  * @brief SD HAL module driver
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/ 
N/** @defgroup SD_Exported_Types SD Exported Types
N  * @{
N  */
N
N/** @defgroup SD_Exported_Types_Group1 SD Handle Structure definition   
N  * @{
N  */
N#define SD_InitTypeDef      SDMMC_InitTypeDef 
N#define SD_TypeDef          SDMMC_TypeDef
N
Ntypedef struct
N{
N  SD_TypeDef                   *Instance;        /*!< SDMMC register base address                     */
X  SDMMC_TypeDef                   *Instance;         
N  
N  SD_InitTypeDef               Init;             /*!< SD required parameters                         */
X  SDMMC_InitTypeDef               Init;              
N  
N  HAL_LockTypeDef              Lock;             /*!< SD locking object                              */
N  
N  uint32_t                     CardType;         /*!< SD card type                                   */
N  
N  uint32_t                     RCA;              /*!< SD relative card address                       */
N  
N  uint32_t                     CSD[4];           /*!< SD card specific data table                    */
N  
N  uint32_t                     CID[4];           /*!< SD card identification number table            */
N  
N  __IO uint32_t                SdTransferCplt;   /*!< SD transfer complete flag in non blocking mode */
X  volatile uint32_t                SdTransferCplt;    
N  
N  __IO uint32_t                SdTransferErr;    /*!< SD transfer error flag in non blocking mode    */
X  volatile uint32_t                SdTransferErr;     
N  
N  __IO uint32_t                DmaTransferCplt;  /*!< SD DMA transfer complete flag                  */
X  volatile uint32_t                DmaTransferCplt;   
N  
N  __IO uint32_t                SdOperation;      /*!< SD transfer operation (read/write)             */
X  volatile uint32_t                SdOperation;       
N  
N  DMA_HandleTypeDef            *hdmarx;          /*!< SD Rx DMA handle parameters                    */
N  
N  DMA_HandleTypeDef            *hdmatx;          /*!< SD Tx DMA handle parameters                    */
N  
N}SD_HandleTypeDef;
N/** 
N  * @}
N  */
N
N/** @defgroup SD_Exported_Types_Group2 Card Specific Data: CSD Register 
N  * @{
N  */ 
Ntypedef struct
N{
N  __IO uint8_t  CSDStruct;            /*!< CSD structure                         */
X  volatile uint8_t  CSDStruct;             
N  __IO uint8_t  SysSpecVersion;       /*!< System specification version          */
X  volatile uint8_t  SysSpecVersion;        
N  __IO uint8_t  Reserved1;            /*!< Reserved                              */
X  volatile uint8_t  Reserved1;             
N  __IO uint8_t  TAAC;                 /*!< Data read access time 1               */
X  volatile uint8_t  TAAC;                  
N  __IO uint8_t  NSAC;                 /*!< Data read access time 2 in CLK cycles */
X  volatile uint8_t  NSAC;                  
N  __IO uint8_t  MaxBusClkFrec;        /*!< Max. bus clock frequency              */
X  volatile uint8_t  MaxBusClkFrec;         
N  __IO uint16_t CardComdClasses;      /*!< Card command classes                  */
X  volatile uint16_t CardComdClasses;       
N  __IO uint8_t  RdBlockLen;           /*!< Max. read data block length           */
X  volatile uint8_t  RdBlockLen;            
N  __IO uint8_t  PartBlockRead;        /*!< Partial blocks for read allowed       */
X  volatile uint8_t  PartBlockRead;         
N  __IO uint8_t  WrBlockMisalign;      /*!< Write block misalignment              */
X  volatile uint8_t  WrBlockMisalign;       
N  __IO uint8_t  RdBlockMisalign;      /*!< Read block misalignment               */
X  volatile uint8_t  RdBlockMisalign;       
N  __IO uint8_t  DSRImpl;              /*!< DSR implemented                       */
X  volatile uint8_t  DSRImpl;               
N  __IO uint8_t  Reserved2;            /*!< Reserved                              */
X  volatile uint8_t  Reserved2;             
N  __IO uint32_t DeviceSize;           /*!< Device Size                           */
X  volatile uint32_t DeviceSize;            
N  __IO uint8_t  MaxRdCurrentVDDMin;   /*!< Max. read current @ VDD min           */
X  volatile uint8_t  MaxRdCurrentVDDMin;    
N  __IO uint8_t  MaxRdCurrentVDDMax;   /*!< Max. read current @ VDD max           */
X  volatile uint8_t  MaxRdCurrentVDDMax;    
N  __IO uint8_t  MaxWrCurrentVDDMin;   /*!< Max. write current @ VDD min          */
X  volatile uint8_t  MaxWrCurrentVDDMin;    
N  __IO uint8_t  MaxWrCurrentVDDMax;   /*!< Max. write current @ VDD max          */
X  volatile uint8_t  MaxWrCurrentVDDMax;    
N  __IO uint8_t  DeviceSizeMul;        /*!< Device size multiplier                */
X  volatile uint8_t  DeviceSizeMul;         
N  __IO uint8_t  EraseGrSize;          /*!< Erase group size                      */
X  volatile uint8_t  EraseGrSize;           
N  __IO uint8_t  EraseGrMul;           /*!< Erase group size multiplier           */
X  volatile uint8_t  EraseGrMul;            
N  __IO uint8_t  WrProtectGrSize;      /*!< Write protect group size              */
X  volatile uint8_t  WrProtectGrSize;       
N  __IO uint8_t  WrProtectGrEnable;    /*!< Write protect group enable            */
X  volatile uint8_t  WrProtectGrEnable;     
N  __IO uint8_t  ManDeflECC;           /*!< Manufacturer default ECC              */
X  volatile uint8_t  ManDeflECC;            
N  __IO uint8_t  WrSpeedFact;          /*!< Write speed factor                    */
X  volatile uint8_t  WrSpeedFact;           
N  __IO uint8_t  MaxWrBlockLen;        /*!< Max. write data block length          */
X  volatile uint8_t  MaxWrBlockLen;         
N  __IO uint8_t  WriteBlockPaPartial;  /*!< Partial blocks for write allowed      */
X  volatile uint8_t  WriteBlockPaPartial;   
N  __IO uint8_t  Reserved3;            /*!< Reserved                              */
X  volatile uint8_t  Reserved3;             
N  __IO uint8_t  ContentProtectAppli;  /*!< Content protection application        */
X  volatile uint8_t  ContentProtectAppli;   
N  __IO uint8_t  FileFormatGrouop;     /*!< File format group                     */
X  volatile uint8_t  FileFormatGrouop;      
N  __IO uint8_t  CopyFlag;             /*!< Copy flag (OTP)                       */
X  volatile uint8_t  CopyFlag;              
N  __IO uint8_t  PermWrProtect;        /*!< Permanent write protection            */
X  volatile uint8_t  PermWrProtect;         
N  __IO uint8_t  TempWrProtect;        /*!< Temporary write protection            */
X  volatile uint8_t  TempWrProtect;         
N  __IO uint8_t  FileFormat;           /*!< File format                           */
X  volatile uint8_t  FileFormat;            
N  __IO uint8_t  ECC;                  /*!< ECC code                              */
X  volatile uint8_t  ECC;                   
N  __IO uint8_t  CSD_CRC;              /*!< CSD CRC                               */
X  volatile uint8_t  CSD_CRC;               
N  __IO uint8_t  Reserved4;            /*!< Always 1                              */
X  volatile uint8_t  Reserved4;             
N
N}HAL_SD_CSDTypedef;
N/** 
N  * @}
N  */
N
N/** @defgroup SD_Exported_Types_Group3 Card Identification Data: CID Register
N  * @{
N  */
Ntypedef struct
N{
N  __IO uint8_t  ManufacturerID;  /*!< Manufacturer ID       */
X  volatile uint8_t  ManufacturerID;   
N  __IO uint16_t OEM_AppliID;     /*!< OEM/Application ID    */
X  volatile uint16_t OEM_AppliID;      
N  __IO uint32_t ProdName1;       /*!< Product Name part1    */
X  volatile uint32_t ProdName1;        
N  __IO uint8_t  ProdName2;       /*!< Product Name part2    */
X  volatile uint8_t  ProdName2;        
N  __IO uint8_t  ProdRev;         /*!< Product Revision      */
X  volatile uint8_t  ProdRev;          
N  __IO uint32_t ProdSN;          /*!< Product Serial Number */
X  volatile uint32_t ProdSN;           
N  __IO uint8_t  Reserved1;       /*!< Reserved1             */
X  volatile uint8_t  Reserved1;        
N  __IO uint16_t ManufactDate;    /*!< Manufacturing Date    */
X  volatile uint16_t ManufactDate;     
N  __IO uint8_t  CID_CRC;         /*!< CID CRC               */
X  volatile uint8_t  CID_CRC;          
N  __IO uint8_t  Reserved2;       /*!< Always 1              */
X  volatile uint8_t  Reserved2;        
N
N}HAL_SD_CIDTypedef;
N/** 
N  * @}
N  */
N
N/** @defgroup SD_Exported_Types_Group4 SD Card Status returned by ACMD13 
N  * @{
N  */
Ntypedef struct
N{
N  __IO uint8_t  DAT_BUS_WIDTH;           /*!< Shows the currently defined data bus width                 */
X  volatile uint8_t  DAT_BUS_WIDTH;            
N  __IO uint8_t  SECURED_MODE;            /*!< Card is in secured mode of operation                       */
X  volatile uint8_t  SECURED_MODE;             
N  __IO uint16_t SD_CARD_TYPE;            /*!< Carries information about card type                        */
X  volatile uint16_t SD_CARD_TYPE;             
N  __IO uint32_t SIZE_OF_PROTECTED_AREA;  /*!< Carries information about the capacity of protected area   */
X  volatile uint32_t SIZE_OF_PROTECTED_AREA;   
N  __IO uint8_t  SPEED_CLASS;             /*!< Carries information about the speed class of the card      */
X  volatile uint8_t  SPEED_CLASS;              
N  __IO uint8_t  PERFORMANCE_MOVE;        /*!< Carries information about the card's performance move      */
X  volatile uint8_t  PERFORMANCE_MOVE;         
N  __IO uint8_t  AU_SIZE;                 /*!< Carries information about the card's allocation unit size  */
X  volatile uint8_t  AU_SIZE;                  
N  __IO uint16_t ERASE_SIZE;              /*!< Determines the number of AUs to be erased in one operation */
X  volatile uint16_t ERASE_SIZE;               
N  __IO uint8_t  ERASE_TIMEOUT;           /*!< Determines the timeout for any number of AU erase          */
X  volatile uint8_t  ERASE_TIMEOUT;            
N  __IO uint8_t  ERASE_OFFSET;            /*!< Carries information about the erase offset                 */
X  volatile uint8_t  ERASE_OFFSET;             
N
N}HAL_SD_CardStatusTypedef;
N/** 
N  * @}
N  */
N
N/** @defgroup SD_Exported_Types_Group5 SD Card information structure 
N  * @{
N  */
Ntypedef struct
N{
N  HAL_SD_CSDTypedef   SD_csd;         /*!< SD card specific data register         */
N  HAL_SD_CIDTypedef   SD_cid;         /*!< SD card identification number register */
N  uint64_t            CardCapacity;   /*!< Card capacity                          */
N  uint32_t            CardBlockSize;  /*!< Card block size                        */
N  uint16_t            RCA;            /*!< SD relative card address               */
N  uint8_t             CardType;       /*!< SD card type                           */
N
N}HAL_SD_CardInfoTypedef;
N/** 
N  * @}
N  */
N
N/** @defgroup SD_Exported_Types_Group6 SD Error status enumeration Structure definition 
N  * @{
N  */
Ntypedef enum
N{
N/** 
N  * @brief  SD specific error defines  
N  */   
N  SD_CMD_CRC_FAIL                    = (1),   /*!< Command response received (but CRC check failed)              */
N  SD_DATA_CRC_FAIL                   = (2),   /*!< Data block sent/received (CRC check failed)                   */
N  SD_CMD_RSP_TIMEOUT                 = (3),   /*!< Command response timeout                                      */
N  SD_DATA_TIMEOUT                    = (4),   /*!< Data timeout                                                  */
N  SD_TX_UNDERRUN                     = (5),   /*!< Transmit FIFO underrun                                        */
N  SD_RX_OVERRUN                      = (6),   /*!< Receive FIFO overrun                                          */
N  SD_START_BIT_ERR                   = (7),   /*!< Start bit not detected on all data signals in wide bus mode   */
N  SD_CMD_OUT_OF_RANGE                = (8),   /*!< Command's argument was out of range.                          */
N  SD_ADDR_MISALIGNED                 = (9),   /*!< Misaligned address                                            */
N  SD_BLOCK_LEN_ERR                   = (10),  /*!< Transferred block length is not allowed for the card or the number of transferred bytes does not match the block length */
N  SD_ERASE_SEQ_ERR                   = (11),  /*!< An error in the sequence of erase command occurs.            */
N  SD_BAD_ERASE_PARAM                 = (12),  /*!< An invalid selection for erase groups                        */
N  SD_WRITE_PROT_VIOLATION            = (13),  /*!< Attempt to program a write protect block                     */
N  SD_LOCK_UNLOCK_FAILED              = (14),  /*!< Sequence or password error has been detected in unlock command or if there was an attempt to access a locked card */
N  SD_COM_CRC_FAILED                  = (15),  /*!< CRC check of the previous command failed                     */
N  SD_ILLEGAL_CMD                     = (16),  /*!< Command is not legal for the card state                      */
N  SD_CARD_ECC_FAILED                 = (17),  /*!< Card internal ECC was applied but failed to correct the data */
N  SD_CC_ERROR                        = (18),  /*!< Internal card controller error                               */
N  SD_GENERAL_UNKNOWN_ERROR           = (19),  /*!< General or unknown error                                     */
N  SD_STREAM_READ_UNDERRUN            = (20),  /*!< The card could not sustain data transfer in stream read operation. */
N  SD_STREAM_WRITE_OVERRUN            = (21),  /*!< The card could not sustain data programming in stream mode   */
N  SD_CID_CSD_OVERWRITE               = (22),  /*!< CID/CSD overwrite error                                      */
N  SD_WP_ERASE_SKIP                   = (23),  /*!< Only partial address space was erased                        */
N  SD_CARD_ECC_DISABLED               = (24),  /*!< Command has been executed without using internal ECC         */
N  SD_ERASE_RESET                     = (25),  /*!< Erase sequence was cleared before executing because an out of erase sequence command was received */
N  SD_AKE_SEQ_ERROR                   = (26),  /*!< Error in sequence of authentication.                         */
N  SD_INVALID_VOLTRANGE               = (27),
N  SD_ADDR_OUT_OF_RANGE               = (28),
N  SD_SWITCH_ERROR                    = (29),
N  SD_SDMMC_DISABLED                  = (30),
N  SD_SDMMC_FUNCTION_BUSY             = (31),
N  SD_SDMMC_FUNCTION_FAILED           = (32),
N  SD_SDMMC_UNKNOWN_FUNCTION          = (33),
N
N/** 
N  * @brief  Standard error defines   
N  */ 
N  SD_INTERNAL_ERROR                  = (34),
N  SD_NOT_CONFIGURED                  = (35),
N  SD_REQUEST_PENDING                 = (36),
N  SD_REQUEST_NOT_APPLICABLE          = (37),
N  SD_INVALID_PARAMETER               = (38),
N  SD_UNSUPPORTED_FEATURE             = (39),
N  SD_UNSUPPORTED_HW                  = (40),
N  SD_ERROR                           = (41),
N  SD_OK                              = (0) 
N
N}HAL_SD_ErrorTypedef;
N/** 
N  * @}
N  */
N
N/** @defgroup SD_Exported_Types_Group7 SD Transfer state enumeration structure
N  * @{
N  */   
Ntypedef enum
N{
N  SD_TRANSFER_OK    = 0,  /*!< Transfer success      */
N  SD_TRANSFER_BUSY  = 1,  /*!< Transfer is occurring */
N  SD_TRANSFER_ERROR = 2   /*!< Transfer failed       */
N
N}HAL_SD_TransferStateTypedef;
N/** 
N  * @}
N  */
N
N/** @defgroup SD_Exported_Types_Group8 SD Card State enumeration structure
N  * @{
N  */   
Ntypedef enum
N{
N  SD_CARD_READY                  = ((uint32_t)0x00000001U),  /*!< Card state is ready                     */
N  SD_CARD_IDENTIFICATION         = ((uint32_t)0x00000002U),  /*!< Card is in identification state         */
N  SD_CARD_STANDBY                = ((uint32_t)0x00000003U),  /*!< Card is in standby state                */
N  SD_CARD_TRANSFER               = ((uint32_t)0x00000004U),  /*!< Card is in transfer state               */  
N  SD_CARD_SENDING                = ((uint32_t)0x00000005U),  /*!< Card is sending an operation            */
N  SD_CARD_RECEIVING              = ((uint32_t)0x00000006U),  /*!< Card is receiving operation information */
N  SD_CARD_PROGRAMMING            = ((uint32_t)0x00000007U),  /*!< Card is in programming state            */
N  SD_CARD_DISCONNECTED           = ((uint32_t)0x00000008U),  /*!< Card is disconnected                    */
N  SD_CARD_ERROR                  = ((uint32_t)0x000000FFU)   /*!< Card is in error state                  */
N
N}HAL_SD_CardStateTypedef;
N/** 
N  * @}
N  */
N
N/** @defgroup SD_Exported_Types_Group9 SD Operation enumeration structure
N  * @{
N  */   
Ntypedef enum
N{
N  SD_READ_SINGLE_BLOCK    = 0U,  /*!< Read single block operation      */
N  SD_READ_MULTIPLE_BLOCK  = 1U,  /*!< Read multiple blocks operation   */
N  SD_WRITE_SINGLE_BLOCK   = 2U,  /*!< Write single block operation     */
N  SD_WRITE_MULTIPLE_BLOCK = 3U   /*!< Write multiple blocks operation  */
N
N}HAL_SD_OperationTypedef;
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup SD_Exported_Constants SD Exported Constants
N  * @{
N  */
N
N/** 
N  * @brief SD Commands Index 
N  */
N#define SD_CMD_GO_IDLE_STATE                       ((uint8_t)0U)   /*!< Resets the SD memory card.                                                               */
N#define SD_CMD_SEND_OP_COND                        ((uint8_t)1U)   /*!< Sends host capacity support information and activates the card's initialization process. */
N#define SD_CMD_ALL_SEND_CID                        ((uint8_t)2U)   /*!< Asks any card connected to the host to send the CID numbers on the CMD line.             */
N#define SD_CMD_SET_REL_ADDR                        ((uint8_t)3U)   /*!< Asks the card to publish a new relative address (RCA).                                   */
N#define SD_CMD_SET_DSR                             ((uint8_t)4U)   /*!< Programs the DSR of all cards.                                                           */
N#define SD_CMD_SDMMC_SEN_OP_COND                   ((uint8_t)5U)   /*!< Sends host capacity support information (HCS) and asks the accessed card to send its 
N                                                                       operating condition register (OCR) content in the response on the CMD line.              */
N#define SD_CMD_HS_SWITCH                           ((uint8_t)6U)   /*!< Checks switchable function (mode 0) and switch card function (mode 1).                   */
N#define SD_CMD_SEL_DESEL_CARD                      ((uint8_t)7U)   /*!< Selects the card by its own relative address and gets deselected by any other address    */
N#define SD_CMD_HS_SEND_EXT_CSD                     ((uint8_t)8U)   /*!< Sends SD Memory Card interface condition, which includes host supply voltage information 
N                                                                       and asks the card whether card supports voltage.                                         */
N#define SD_CMD_SEND_CSD                            ((uint8_t)9U)   /*!< Addressed card sends its card specific data (CSD) on the CMD line.                       */
N#define SD_CMD_SEND_CID                            ((uint8_t)10U)  /*!< Addressed card sends its card identification (CID) on the CMD line.                      */
N#define SD_CMD_READ_DAT_UNTIL_STOP                 ((uint8_t)11U)  /*!< SD card doesn't support it.                                                              */
N#define SD_CMD_STOP_TRANSMISSION                   ((uint8_t)12U)  /*!< Forces the card to stop transmission.                                                    */
N#define SD_CMD_SEND_STATUS                         ((uint8_t)13U)  /*!< Addressed card sends its status register.                                                */
N#define SD_CMD_HS_BUSTEST_READ                     ((uint8_t)14U) 
N#define SD_CMD_GO_INACTIVE_STATE                   ((uint8_t)15U)  /*!< Sends an addressed card into the inactive state.                                         */
N#define SD_CMD_SET_BLOCKLEN                        ((uint8_t)16U)  /*!< Sets the block length (in bytes for SDSC) for all following block commands 
N                                                                       (read, write, lock). Default block length is fixed to 512 Bytes. Not effective 
N                                                                       for SDHS and SDXC.                                                                       */
N#define SD_CMD_READ_SINGLE_BLOCK                   ((uint8_t)17U)  /*!< Reads single block of size selected by SET_BLOCKLEN in case of SDSC, and a block of 
N                                                                       fixed 512 bytes in case of SDHC and SDXC.                                                */
N#define SD_CMD_READ_MULT_BLOCK                     ((uint8_t)18U)  /*!< Continuously transfers data blocks from card to host until interrupted by 
N                                                                       STOP_TRANSMISSION command.                                                               */
N#define SD_CMD_HS_BUSTEST_WRITE                    ((uint8_t)19U)  /*!< 64 bytes tuning pattern is sent for SDR50 and SDR104.                                    */
N#define SD_CMD_WRITE_DAT_UNTIL_STOP                ((uint8_t)20U)  /*!< Speed class control command.                                                             */
N#define SD_CMD_SET_BLOCK_COUNT                     ((uint8_t)23U)  /*!< Specify block count for CMD18 and CMD25.                                                 */
N#define SD_CMD_WRITE_SINGLE_BLOCK                  ((uint8_t)24U)  /*!< Writes single block of size selected by SET_BLOCKLEN in case of SDSC, and a block of 
N                                                                       fixed 512 bytes in case of SDHC and SDXC.                                                */
N#define SD_CMD_WRITE_MULT_BLOCK                    ((uint8_t)25U)  /*!< Continuously writes blocks of data until a STOP_TRANSMISSION follows.                    */
N#define SD_CMD_PROG_CID                            ((uint8_t)26U)  /*!< Reserved for manufacturers.                                                              */
N#define SD_CMD_PROG_CSD                            ((uint8_t)27U)  /*!< Programming of the programmable bits of the CSD.                                         */
N#define SD_CMD_SET_WRITE_PROT                      ((uint8_t)28U)  /*!< Sets the write protection bit of the addressed group.                                    */
N#define SD_CMD_CLR_WRITE_PROT                      ((uint8_t)29U)  /*!< Clears the write protection bit of the addressed group.                                  */
N#define SD_CMD_SEND_WRITE_PROT                     ((uint8_t)30U)  /*!< Asks the card to send the status of the write protection bits.                           */
N#define SD_CMD_SD_ERASE_GRP_START                  ((uint8_t)32U)  /*!< Sets the address of the first write block to be erased. (For SD card only).              */
N#define SD_CMD_SD_ERASE_GRP_END                    ((uint8_t)33U)  /*!< Sets the address of the last write block of the continuous range to be erased.           */
N#define SD_CMD_ERASE_GRP_START                     ((uint8_t)35U)  /*!< Sets the address of the first write block to be erased. Reserved for each command 
N                                                                       system set by switch function command (CMD6).                                            */
N#define SD_CMD_ERASE_GRP_END                       ((uint8_t)36U)  /*!< Sets the address of the last write block of the continuous range to be erased. 
N                                                                       Reserved for each command system set by switch function command (CMD6).                  */
N#define SD_CMD_ERASE                               ((uint8_t)38U)  /*!< Reserved for SD security applications.                                                   */
N#define SD_CMD_FAST_IO                             ((uint8_t)39U)  /*!< SD card doesn't support it (Reserved).                                                   */
N#define SD_CMD_GO_IRQ_STATE                        ((uint8_t)40U)  /*!< SD card doesn't support it (Reserved).                                                   */
N#define SD_CMD_LOCK_UNLOCK                         ((uint8_t)42U)  /*!< Sets/resets the password or lock/unlock the card. The size of the data block is set by 
N                                                                       the SET_BLOCK_LEN command.                                                               */
N#define SD_CMD_APP_CMD                             ((uint8_t)55U)  /*!< Indicates to the card that the next command is an application specific command rather 
N                                                                       than a standard command.                                                                 */
N#define SD_CMD_GEN_CMD                             ((uint8_t)56U)  /*!< Used either to transfer a data block to the card or to get a data block from the card 
N                                                                       for general purpose/application specific commands.                                       */
N#define SD_CMD_NO_CMD                              ((uint8_t)64U) 
N
N/** 
N  * @brief Following commands are SD Card Specific commands.
N  *        SDMMC_APP_CMD should be sent before sending these commands. 
N  */
N#define SD_CMD_APP_SD_SET_BUSWIDTH                 ((uint8_t)6U)   /*!< (ACMD6) Defines the data bus width to be used for data transfer. The allowed data bus 
N                                                                       widths are given in SCR register.                                                          */
N#define SD_CMD_SD_APP_STATUS                       ((uint8_t)13U)  /*!< (ACMD13) Sends the SD status.                                                              */
N#define SD_CMD_SD_APP_SEND_NUM_WRITE_BLOCKS        ((uint8_t)22U)  /*!< (ACMD22) Sends the number of the written (without errors) write blocks. Responds with 
N                                                                       32bit+CRC data block.                                                                      */
N#define SD_CMD_SD_APP_OP_COND                      ((uint8_t)41U)  /*!< (ACMD41) Sends host capacity support information (HCS) and asks the accessed card to 
N                                                                       send its operating condition register (OCR) content in the response on the CMD line.       */
N#define SD_CMD_SD_APP_SET_CLR_CARD_DETECT          ((uint8_t)42U)  /*!< (ACMD42) Connects/Disconnects the 50 KOhm pull-up resistor on CD/DAT3 (pin 1) of the card. */
N#define SD_CMD_SD_APP_SEND_SCR                     ((uint8_t)51U)  /*!< Reads the SD Configuration Register (SCR).                                                 */
N#define SD_CMD_SDMMC_RW_DIRECT                     ((uint8_t)52U)  /*!< For SD I/O card only, reserved for security specification.                                 */
N#define SD_CMD_SDMMC_RW_EXTENDED                   ((uint8_t)53U)  /*!< For SD I/O card only, reserved for security specification.                                 */
N
N/** 
N  * @brief Following commands are SD Card Specific security commands.
N  *        SD_CMD_APP_CMD should be sent before sending these commands. 
N  */
N#define SD_CMD_SD_APP_GET_MKB                      ((uint8_t)43U)  /*!< For SD card only */
N#define SD_CMD_SD_APP_GET_MID                      ((uint8_t)44U)  /*!< For SD card only */
N#define SD_CMD_SD_APP_SET_CER_RN1                  ((uint8_t)45U)  /*!< For SD card only */
N#define SD_CMD_SD_APP_GET_CER_RN2                  ((uint8_t)46U)  /*!< For SD card only */
N#define SD_CMD_SD_APP_SET_CER_RES2                 ((uint8_t)47U)  /*!< For SD card only */
N#define SD_CMD_SD_APP_GET_CER_RES1                 ((uint8_t)48U)  /*!< For SD card only */
N#define SD_CMD_SD_APP_SECURE_READ_MULTIPLE_BLOCK   ((uint8_t)18U)  /*!< For SD card only */
N#define SD_CMD_SD_APP_SECURE_WRITE_MULTIPLE_BLOCK  ((uint8_t)25U)  /*!< For SD card only */
N#define SD_CMD_SD_APP_SECURE_ERASE                 ((uint8_t)38U)  /*!< For SD card only */
N#define SD_CMD_SD_APP_CHANGE_SECURE_AREA           ((uint8_t)49U)  /*!< For SD card only */
N#define SD_CMD_SD_APP_SECURE_WRITE_MKB             ((uint8_t)48U)  /*!< For SD card only */
N
N/** 
N  * @brief Supported SD Memory Cards 
N  */
N#define STD_CAPACITY_SD_CARD_V1_1             ((uint32_t)0x00000000U)
N#define STD_CAPACITY_SD_CARD_V2_0             ((uint32_t)0x00000001U)
N#define HIGH_CAPACITY_SD_CARD                 ((uint32_t)0x00000002U)
N#define MULTIMEDIA_CARD                       ((uint32_t)0x00000003U)
N#define SECURE_DIGITAL_IO_CARD                ((uint32_t)0x00000004U)
N#define HIGH_SPEED_MULTIMEDIA_CARD            ((uint32_t)0x00000005U)
N#define SECURE_DIGITAL_IO_COMBO_CARD          ((uint32_t)0x00000006U)
N#define HIGH_CAPACITY_MMC_CARD                ((uint32_t)0x00000007U)
N/**
N  * @}
N  */
N  
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup SD_Exported_macros SD Exported Macros
N *  @brief macros to handle interrupts and specific clock configurations
N * @{
N */
N 
N/**
N  * @brief  Enable the SD device.
N  * @retval None
N  */ 
N#define __HAL_SD_SDMMC_ENABLE(__HANDLE__) __SDMMC_ENABLE((__HANDLE__)->Instance)
N
N/**
N  * @brief  Disable the SD device.
N  * @retval None
N  */
N#define __HAL_SD_SDMMC_DISABLE(__HANDLE__) __SDMMC_DISABLE((__HANDLE__)->Instance)
N
N/**
N  * @brief  Enable the SDMMC DMA transfer.
N  * @retval None
N  */ 
N#define __HAL_SD_SDMMC_DMA_ENABLE(__HANDLE__) __SDMMC_DMA_ENABLE((__HANDLE__)->Instance)
N
N/**
N  * @brief  Disable the SDMMC DMA transfer.
N  * @retval None
N  */
N#define __HAL_SD_SDMMC_DMA_DISABLE(__HANDLE__)  __SDMMC_DMA_DISABLE((__HANDLE__)->Instance)
N 
N/**
N  * @brief  Enable the SD device interrupt.
N  * @param  __HANDLE__: SD Handle  
N  * @param  __INTERRUPT__: specifies the SDMMC interrupt sources to be enabled.
N  *         This parameter can be one or a combination of the following values:
N  *            @arg SDMMC_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
N  *            @arg SDMMC_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
N  *            @arg SDMMC_IT_CTIMEOUT: Command response timeout interrupt
N  *            @arg SDMMC_IT_DTIMEOUT: Data timeout interrupt
N  *            @arg SDMMC_IT_TXUNDERR: Transmit FIFO underrun error interrupt
N  *            @arg SDMMC_IT_RXOVERR:  Received FIFO overrun error interrupt
N  *            @arg SDMMC_IT_CMDREND:  Command response received (CRC check passed) interrupt
N  *            @arg SDMMC_IT_CMDSENT:  Command sent (no response required) interrupt
N  *            @arg SDMMC_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is zero) interrupt
N  *            @arg SDMMC_IT_DBCKEND:  Data block sent/received (CRC check passed) interrupt
N  *            @arg SDMMC_IT_CMDACT:   Command transfer in progress interrupt
N  *            @arg SDMMC_IT_TXACT:    Data transmit in progress interrupt
N  *            @arg SDMMC_IT_RXACT:    Data receive in progress interrupt
N  *            @arg SDMMC_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt
N  *            @arg SDMMC_IT_RXFIFOHF: Receive FIFO Half Full interrupt
N  *            @arg SDMMC_IT_TXFIFOF:  Transmit FIFO full interrupt
N  *            @arg SDMMC_IT_RXFIFOF:  Receive FIFO full interrupt
N  *            @arg SDMMC_IT_TXFIFOE:  Transmit FIFO empty interrupt
N  *            @arg SDMMC_IT_RXFIFOE:  Receive FIFO empty interrupt
N  *            @arg SDMMC_IT_TXDAVL:   Data available in transmit FIFO interrupt
N  *            @arg SDMMC_IT_RXDAVL:   Data available in receive FIFO interrupt
N  *            @arg SDMMC_IT_SDIOIT:   SD I/O interrupt received interrupt
N  * @retval None
N  */
N#define __HAL_SD_SDMMC_ENABLE_IT(__HANDLE__, __INTERRUPT__) __SDMMC_ENABLE_IT((__HANDLE__)->Instance, (__INTERRUPT__))
N
N/**
N  * @brief  Disable the SD device interrupt.
N  * @param  __HANDLE__: SD Handle   
N  * @param  __INTERRUPT__: specifies the SDMMC interrupt sources to be disabled.
N  *          This parameter can be one or a combination of the following values:
N  *            @arg SDMMC_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
N  *            @arg SDMMC_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
N  *            @arg SDMMC_IT_CTIMEOUT: Command response timeout interrupt
N  *            @arg SDMMC_IT_DTIMEOUT: Data timeout interrupt
N  *            @arg SDMMC_IT_TXUNDERR: Transmit FIFO underrun error interrupt
N  *            @arg SDMMC_IT_RXOVERR:  Received FIFO overrun error interrupt
N  *            @arg SDMMC_IT_CMDREND:  Command response received (CRC check passed) interrupt
N  *            @arg SDMMC_IT_CMDSENT:  Command sent (no response required) interrupt
N  *            @arg SDMMC_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is zero) interrupt
N  *            @arg SDMMC_IT_DBCKEND:  Data block sent/received (CRC check passed) interrupt
N  *            @arg SDMMC_IT_CMDACT:   Command transfer in progress interrupt
N  *            @arg SDMMC_IT_TXACT:    Data transmit in progress interrupt
N  *            @arg SDMMC_IT_RXACT:    Data receive in progress interrupt
N  *            @arg SDMMC_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt
N  *            @arg SDMMC_IT_RXFIFOHF: Receive FIFO Half Full interrupt
N  *            @arg SDMMC_IT_TXFIFOF:  Transmit FIFO full interrupt
N  *            @arg SDMMC_IT_RXFIFOF:  Receive FIFO full interrupt
N  *            @arg SDMMC_IT_TXFIFOE:  Transmit FIFO empty interrupt
N  *            @arg SDMMC_IT_RXFIFOE:  Receive FIFO empty interrupt
N  *            @arg SDMMC_IT_TXDAVL:   Data available in transmit FIFO interrupt
N  *            @arg SDMMC_IT_RXDAVL:   Data available in receive FIFO interrupt
N  *            @arg SDMMC_IT_SDIOIT:   SD I/O interrupt received interrupt   
N  * @retval None
N  */
N#define __HAL_SD_SDMMC_DISABLE_IT(__HANDLE__, __INTERRUPT__) __SDMMC_DISABLE_IT((__HANDLE__)->Instance, (__INTERRUPT__))
N
N/**
N  * @brief  Check whether the specified SD flag is set or not. 
N  * @param  __HANDLE__: SD Handle   
N  * @param  __FLAG__: specifies the flag to check. 
N  *          This parameter can be one of the following values:
N  *            @arg SDMMC_FLAG_CCRCFAIL: Command response received (CRC check failed)
N  *            @arg SDMMC_FLAG_DCRCFAIL: Data block sent/received (CRC check failed)
N  *            @arg SDMMC_FLAG_CTIMEOUT: Command response timeout
N  *            @arg SDMMC_FLAG_DTIMEOUT: Data timeout
N  *            @arg SDMMC_FLAG_TXUNDERR: Transmit FIFO underrun error
N  *            @arg SDMMC_FLAG_RXOVERR:  Received FIFO overrun error
N  *            @arg SDMMC_FLAG_CMDREND:  Command response received (CRC check passed)
N  *            @arg SDMMC_FLAG_CMDSENT:  Command sent (no response required)
N  *            @arg SDMMC_FLAG_DATAEND:  Data end (data counter, SDIDCOUNT, is zero)
N  *            @arg SDMMC_FLAG_DBCKEND:  Data block sent/received (CRC check passed)
N  *            @arg SDMMC_FLAG_CMDACT:   Command transfer in progress
N  *            @arg SDMMC_FLAG_TXACT:    Data transmit in progress
N  *            @arg SDMMC_FLAG_RXACT:    Data receive in progress
N  *            @arg SDMMC_FLAG_TXFIFOHE: Transmit FIFO Half Empty
N  *            @arg SDMMC_FLAG_RXFIFOHF: Receive FIFO Half Full
N  *            @arg SDMMC_FLAG_TXFIFOF:  Transmit FIFO full
N  *            @arg SDMMC_FLAG_RXFIFOF:  Receive FIFO full
N  *            @arg SDMMC_FLAG_TXFIFOE:  Transmit FIFO empty
N  *            @arg SDMMC_FLAG_RXFIFOE:  Receive FIFO empty
N  *            @arg SDMMC_FLAG_TXDAVL:   Data available in transmit FIFO
N  *            @arg SDMMC_FLAG_RXDAVL:   Data available in receive FIFO
N  *            @arg SDMMC_FLAG_SDIOIT:   SD I/O interrupt received
N  * @retval The new state of SD FLAG (SET or RESET).
N  */
N#define __HAL_SD_SDMMC_GET_FLAG(__HANDLE__, __FLAG__) __SDMMC_GET_FLAG((__HANDLE__)->Instance, (__FLAG__))
N
N/**
N  * @brief  Clear the SD's pending flags.
N  * @param  __HANDLE__: SD Handle  
N  * @param  __FLAG__: specifies the flag to clear.  
N  *          This parameter can be one or a combination of the following values:
N  *            @arg SDMMC_FLAG_CCRCFAIL: Command response received (CRC check failed)
N  *            @arg SDMMC_FLAG_DCRCFAIL: Data block sent/received (CRC check failed)
N  *            @arg SDMMC_FLAG_CTIMEOUT: Command response timeout
N  *            @arg SDMMC_FLAG_DTIMEOUT: Data timeout
N  *            @arg SDMMC_FLAG_TXUNDERR: Transmit FIFO underrun error
N  *            @arg SDMMC_FLAG_RXOVERR:  Received FIFO overrun error
N  *            @arg SDMMC_FLAG_CMDREND:  Command response received (CRC check passed)
N  *            @arg SDMMC_FLAG_CMDSENT:  Command sent (no response required)
N  *            @arg SDMMC_FLAG_DATAEND:  Data end (data counter, SDIDCOUNT, is zero)
N  *            @arg SDMMC_FLAG_DBCKEND:  Data block sent/received (CRC check passed)
N  *            @arg SDMMC_FLAG_SDIOIT:   SD I/O interrupt received
N  * @retval None
N  */
N#define __HAL_SD_SDMMC_CLEAR_FLAG(__HANDLE__, __FLAG__) __SDMMC_CLEAR_FLAG((__HANDLE__)->Instance, (__FLAG__))
N
N/**
N  * @brief  Check whether the specified SD interrupt has occurred or not.
N  * @param  __HANDLE__: SD Handle   
N  * @param  __INTERRUPT__: specifies the SDMMC interrupt source to check. 
N  *          This parameter can be one of the following values:
N  *            @arg SDMMC_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
N  *            @arg SDMMC_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
N  *            @arg SDMMC_IT_CTIMEOUT: Command response timeout interrupt
N  *            @arg SDMMC_IT_DTIMEOUT: Data timeout interrupt
N  *            @arg SDMMC_IT_TXUNDERR: Transmit FIFO underrun error interrupt
N  *            @arg SDMMC_IT_RXOVERR:  Received FIFO overrun error interrupt
N  *            @arg SDMMC_IT_CMDREND:  Command response received (CRC check passed) interrupt
N  *            @arg SDMMC_IT_CMDSENT:  Command sent (no response required) interrupt
N  *            @arg SDMMC_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is zero) interrupt
N  *            @arg SDMMC_IT_DBCKEND:  Data block sent/received (CRC check passed) interrupt
N  *            @arg SDMMC_IT_CMDACT:   Command transfer in progress interrupt
N  *            @arg SDMMC_IT_TXACT:    Data transmit in progress interrupt
N  *            @arg SDMMC_IT_RXACT:    Data receive in progress interrupt
N  *            @arg SDMMC_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt
N  *            @arg SDMMC_IT_RXFIFOHF: Receive FIFO Half Full interrupt
N  *            @arg SDMMC_IT_TXFIFOF:  Transmit FIFO full interrupt
N  *            @arg SDMMC_IT_RXFIFOF:  Receive FIFO full interrupt
N  *            @arg SDMMC_IT_TXFIFOE:  Transmit FIFO empty interrupt
N  *            @arg SDMMC_IT_RXFIFOE:  Receive FIFO empty interrupt
N  *            @arg SDMMC_IT_TXDAVL:   Data available in transmit FIFO interrupt
N  *            @arg SDMMC_IT_RXDAVL:   Data available in receive FIFO interrupt
N  *            @arg SDMMC_IT_SDIOIT:   SD I/O interrupt received interrupt
N  * @retval The new state of SD IT (SET or RESET).
N  */
N#define __HAL_SD_SDMMC_GET_IT(__HANDLE__, __INTERRUPT__) __SDMMC_GET_IT((__HANDLE__)->Instance, (__INTERRUPT__))
N
N/**
N  * @brief  Clear the SD's interrupt pending bits.
N  * @param  __HANDLE__: SD Handle
N  * @param  __INTERRUPT__: specifies the interrupt pending bit to clear. 
N  *          This parameter can be one or a combination of the following values:
N  *            @arg SDMMC_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
N  *            @arg SDMMC_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
N  *            @arg SDMMC_IT_CTIMEOUT: Command response timeout interrupt
N  *            @arg SDMMC_IT_DTIMEOUT: Data timeout interrupt
N  *            @arg SDMMC_IT_TXUNDERR: Transmit FIFO underrun error interrupt
N  *            @arg SDMMC_IT_RXOVERR:  Received FIFO overrun error interrupt
N  *            @arg SDMMC_IT_CMDREND:  Command response received (CRC check passed) interrupt
N  *            @arg SDMMC_IT_CMDSENT:  Command sent (no response required) interrupt
N  *            @arg SDMMC_IT_DATAEND:  Data end (data counter, SDMMC_DCOUNT, is zero) interrupt
N  *            @arg SDMMC_IT_SDIOIT:   SD I/O interrupt received interrupt
N  * @retval None
N  */
N#define __HAL_SD_SDMMC_CLEAR_IT(__HANDLE__, __INTERRUPT__) __SDMMC_CLEAR_IT((__HANDLE__)->Instance, (__INTERRUPT__))
N/**
N  * @}
N  */
N  
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup SD_Exported_Functions SD Exported Functions
N  * @{
N  */
N  
N/** @defgroup SD_Exported_Functions_Group1 Initialization and de-initialization functions
N  * @{
N  */
NHAL_SD_ErrorTypedef HAL_SD_Init(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypedef *SDCardInfo);
NHAL_StatusTypeDef   HAL_SD_DeInit (SD_HandleTypeDef *hsd);
Nvoid HAL_SD_MspInit(SD_HandleTypeDef *hsd);
Nvoid HAL_SD_MspDeInit(SD_HandleTypeDef *hsd);
N/**
N  * @}
N  */
N  
N/** @defgroup SD_Exported_Functions_Group2 Input and Output operation functions
N  * @{
N  */
N/* Blocking mode: Polling */
NHAL_SD_ErrorTypedef HAL_SD_ReadBlocks(SD_HandleTypeDef *hsd, uint32_t *pReadBuffer, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumberOfBlocks);
NHAL_SD_ErrorTypedef HAL_SD_WriteBlocks(SD_HandleTypeDef *hsd, uint32_t *pWriteBuffer, uint64_t WriteAddr, uint32_t BlockSize, uint32_t NumberOfBlocks);
NHAL_SD_ErrorTypedef HAL_SD_Erase(SD_HandleTypeDef *hsd, uint64_t startaddr, uint64_t endaddr);
N
N/* Non-Blocking mode: Interrupt */
Nvoid HAL_SD_IRQHandler(SD_HandleTypeDef *hsd);
N
N/* Callback in non blocking modes (DMA) */
Nvoid HAL_SD_DMA_RxCpltCallback(DMA_HandleTypeDef *hdma);
Nvoid HAL_SD_DMA_RxErrorCallback(DMA_HandleTypeDef *hdma);
Nvoid HAL_SD_DMA_TxCpltCallback(DMA_HandleTypeDef *hdma);
Nvoid HAL_SD_DMA_TxErrorCallback(DMA_HandleTypeDef *hdma);
Nvoid HAL_SD_XferCpltCallback(SD_HandleTypeDef *hsd);
Nvoid HAL_SD_XferErrorCallback(SD_HandleTypeDef *hsd);
N
N/* Non-Blocking mode: DMA */
NHAL_SD_ErrorTypedef HAL_SD_ReadBlocks_DMA(SD_HandleTypeDef *hsd, uint32_t *pReadBuffer, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumberOfBlocks);
NHAL_SD_ErrorTypedef HAL_SD_WriteBlocks_DMA(SD_HandleTypeDef *hsd, uint32_t *pWriteBuffer, uint64_t WriteAddr, uint32_t BlockSize, uint32_t NumberOfBlocks);
NHAL_SD_ErrorTypedef HAL_SD_CheckWriteOperation(SD_HandleTypeDef *hsd, uint32_t Timeout);
NHAL_SD_ErrorTypedef HAL_SD_CheckReadOperation(SD_HandleTypeDef *hsd, uint32_t Timeout);
N/**
N  * @}
N  */
N  
N/** @defgroup SD_Exported_Functions_Group3 Peripheral Control functions
N  * @{
N  */
NHAL_SD_ErrorTypedef HAL_SD_Get_CardInfo(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypedef *pCardInfo);
NHAL_SD_ErrorTypedef HAL_SD_WideBusOperation_Config(SD_HandleTypeDef *hsd, uint32_t WideMode);
NHAL_SD_ErrorTypedef HAL_SD_StopTransfer(SD_HandleTypeDef *hsd);
NHAL_SD_ErrorTypedef HAL_SD_HighSpeed (SD_HandleTypeDef *hsd);
N/**
N  * @}
N  */
N  
N/* Peripheral State functions  ************************************************/
N/** @defgroup SD_Exported_Functions_Group4 Peripheral State functions
N  * @{
N  */
NHAL_SD_ErrorTypedef HAL_SD_SendSDStatus(SD_HandleTypeDef *hsd, uint32_t *pSDstatus);
NHAL_SD_ErrorTypedef HAL_SD_GetCardStatus(SD_HandleTypeDef *hsd, HAL_SD_CardStatusTypedef *pCardStatus);
NHAL_SD_TransferStateTypedef HAL_SD_GetStatus(SD_HandleTypeDef *hsd);
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */
N    
N/* Private types -------------------------------------------------------------*/
N/** @defgroup SD_Private_Types SD Private Types
N  * @{
N  */
N
N/**
N  * @}
N  */ 
N
N/* Private defines -----------------------------------------------------------*/
N/** @defgroup SD_Private_Defines SD Private Defines
N  * @{
N  */
N
N/**
N  * @}
N  */ 
N          
N/* Private variables ---------------------------------------------------------*/
N/** @defgroup SD_Private_Variables SD Private Variables
N  * @{
N  */
N
N/**
N  * @}
N  */ 
N
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup SD_Private_Constants SD Private Constants
N  * @{
N  */
N
N/**
N  * @}
N  */ 
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup SD_Private_Macros SD Private Macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/* Private functions prototypes ----------------------------------------------*/
N/** @defgroup SD_Private_Functions_Prototypes SD Private Functions Prototypes
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup SD_Private_Functions SD Private Functions
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif /* __STM32F7xx_HAL_SD_H */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 363 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_SD_MODULE_ENABLED */
N
N#ifdef HAL_SPDIFRX_MODULE_ENABLED
N #include "stm32f7xx_hal_spdifrx.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_spdifrx.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_spdifrx.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of SPDIFRX HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_SPDIFRX_H
N#define __STM32F7xx_HAL_SPDIFRX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"  
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup SPDIFRX
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/ 
N/** @defgroup SPDIFRX_Exported_Types SPDIFRX Exported Types
N  * @{
N  */
N
N/** 
N  * @brief SPDIFRX Init structure definition  
N  */
Ntypedef struct
N{
N  uint32_t InputSelection;           /*!< Specifies the SPDIF input selection.
N                                          This parameter can be a value of @ref SPDIFRX_Input_Selection */
N
N  uint32_t Retries;                  /*!< Specifies the Maximum allowed re-tries during synchronization phase.
N                                          This parameter can be a value of @ref SPDIFRX_Max_Retries */
N
N  uint32_t WaitForActivity;          /*!< Specifies the wait for activity on SPDIF selected input.
N                                          This parameter can be a value of @ref SPDIFRX_Wait_For_Activity. */
N
N  uint32_t ChannelSelection;         /*!< Specifies whether the control flow will take the channel status from channel A or B.
N                                          This parameter can be a value of @ref SPDIFRX_Channel_Selection */
N
N  uint32_t DataFormat;               /*!< Specifies the Data samples format (LSB, MSB, ...).
N                                          This parameter can be a value of @ref SPDIFRX_Data_Format */
N                                               
N  uint32_t StereoMode;               /*!< Specifies whether the peripheral is in stereo or mono mode.
N                                          This parameter can be a value of @ref SPDIFRX_Stereo_Mode */
N
N    uint32_t PreambleTypeMask;          /*!< Specifies whether The preamble type bits are copied or not into the received frame.
N                                                                                   This parameter can be a value of @ref SPDIFRX_PT_Mask */
N
N    uint32_t ChannelStatusMask;        /*!< Specifies whether the channel status and user bits are copied or not into the received frame.
N                                                                                  This parameter can be a value of @ref SPDIFRX_ChannelStatus_Mask */
N    
N    uint32_t ValidityBitMask;          /*!< Specifies whether the validity bit is copied or not into the received frame.
N                                                                                  This parameter can be a value of @ref SPDIFRX_V_Mask */                                                                                
N                                                                                
N    uint32_t ParityErrorMask;          /*!< Specifies whether the parity error bit is copied or not into the received frame.
N                                                                                  This parameter can be a value of @ref SPDIFRX_PE_Mask */
N    
N}SPDIFRX_InitTypeDef;
N
N/** 
N  * @brief SPDIFRX SetDataFormat structure definition  
N  */
Ntypedef struct
N{
N  uint32_t DataFormat;               /*!< Specifies the Data samples format (LSB, MSB, ...).
N                                          This parameter can be a value of @ref SPDIFRX_Data_Format */
N                                               
N  uint32_t StereoMode;               /*!< Specifies whether the peripheral is in stereo or mono mode.
N                                          This parameter can be a value of @ref SPDIFRX_Stereo_Mode */
N
N  uint32_t PreambleTypeMask;          /*!< Specifies whether The preamble type bits are copied or not into the received frame.
N                                                                                   This parameter can be a value of @ref SPDIFRX_PT_Mask */
N
N  uint32_t ChannelStatusMask;        /*!< Specifies whether the channel status and user bits are copied or not into the received frame.
N                                                                                  This parameter can be a value of @ref SPDIFRX_ChannelStatus_Mask */
N    
N  uint32_t ValidityBitMask;          /*!< Specifies whether the validity bit is copied or not into the received frame.
N                                                                                  This parameter can be a value of @ref SPDIFRX_V_Mask */                                                                                
N                                                                                
N  uint32_t ParityErrorMask;          /*!< Specifies whether the parity error bit is copied or not into the received frame.
N                                                                                  This parameter can be a value of @ref SPDIFRX_PE_Mask */
N    
N}SPDIFRX_SetDataFormatTypeDef;
N
N/** 
N  * @brief  HAL State structures definition  
N  */ 
Ntypedef enum
N{
N  HAL_SPDIFRX_STATE_RESET      = 0x00U,  /*!< SPDIFRX not yet initialized or disabled                */
N  HAL_SPDIFRX_STATE_READY      = 0x01U,  /*!< SPDIFRX initialized and ready for use                  */
N  HAL_SPDIFRX_STATE_BUSY       = 0x02U,  /*!< SPDIFRX internal process is ongoing                    */ 
N  HAL_SPDIFRX_STATE_BUSY_RX    = 0x03U,  /*!< SPDIFRX internal Data Flow RX process is ongoing       */  
N  HAL_SPDIFRX_STATE_BUSY_CX    = 0x04U,  /*!< SPDIFRX internal Control Flow RX process is ongoing    */    
N  HAL_SPDIFRX_STATE_ERROR      = 0x07U   /*!< SPDIFRX error state                                    */      
N}HAL_SPDIFRX_StateTypeDef;
N
N/** 
N  * @brief SPDIFRX handle Structure definition  
N  */
Ntypedef struct
N{
N  SPDIFRX_TypeDef            *Instance;    /* SPDIFRX registers base address */
N
N  SPDIFRX_InitTypeDef        Init;         /* SPDIFRX communication parameters */
N                            
N  uint32_t                   *pRxBuffPtr;  /* Pointer to SPDIFRX Rx transfer buffer */
N    
N    uint32_t                   *pCsBuffPtr;  /* Pointer to SPDIFRX Cx transfer buffer */
N  
N  __IO uint16_t              RxXferSize;   /* SPDIFRX Rx transfer size */
X  volatile uint16_t              RxXferSize;    
N  
N  __IO uint16_t              RxXferCount;  /* SPDIFRX Rx transfer counter 
X  volatile uint16_t              RxXferCount;  
N                                              (This field is initialized at the 
N                                               same value as transfer size at the 
N                                               beginning of the transfer and 
N                                               decremented when a sample is received. 
N                                               NbSamplesReceived = RxBufferSize-RxBufferCount) */
N    
N  __IO uint16_t              CsXferSize;   /* SPDIFRX Rx transfer size */
X  volatile uint16_t              CsXferSize;    
N  
N  __IO uint16_t              CsXferCount;  /* SPDIFRX Rx transfer counter 
X  volatile uint16_t              CsXferCount;  
N                                              (This field is initialized at the 
N                                               same value as transfer size at the 
N                                               beginning of the transfer and 
N                                               decremented when a sample is received. 
N                                               NbSamplesReceived = RxBufferSize-RxBufferCount) */
N                                                                                             
N  DMA_HandleTypeDef          *hdmaCsRx;    /* SPDIFRX EC60958_channel_status and user_information DMA handle parameters */
N
N  DMA_HandleTypeDef          *hdmaDrRx;    /* SPDIFRX Rx DMA handle parameters */
N  
N  __IO HAL_LockTypeDef       Lock;         /* SPDIFRX locking object */
X  volatile HAL_LockTypeDef       Lock;          
N  
N  __IO HAL_SPDIFRX_StateTypeDef  State;    /* SPDIFRX communication state */
X  volatile HAL_SPDIFRX_StateTypeDef  State;     
N
N  __IO uint32_t  ErrorCode;                /* SPDIFRX Error code                 */
X  volatile uint32_t  ErrorCode;                 
N
N}SPDIFRX_HandleTypeDef;
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup SPDIFRX_Exported_Constants SPDIFRX Exported Constants
N  * @{
N  */
N/** @defgroup SPDIFRX_ErrorCode SPDIFRX Error Code
N  * @{
N  */ 
N#define HAL_SPDIFRX_ERROR_NONE      ((uint32_t)0x00000000U)  /*!< No error           */
N#define HAL_SPDIFRX_ERROR_TIMEOUT   ((uint32_t)0x00000001U)  /*!< Timeout error      */  
N#define HAL_SPDIFRX_ERROR_OVR       ((uint32_t)0x00000002U)  /*!< OVR error          */
N#define HAL_SPDIFRX_ERROR_PE        ((uint32_t)0x00000004U)  /*!< Parity error       */
N#define HAL_SPDIFRX_ERROR_DMA       ((uint32_t)0x00000008U)  /*!< DMA transfer error */
N#define HAL_SPDIFRX_ERROR_UNKNOWN   ((uint32_t)0x00000010U)  /*!< Unknown Error error */  
N/**
N  * @}
N  */
N  
N/** @defgroup SPDIFRX_Input_Selection SPDIFRX Input Selection
N  * @{
N  */
N#define SPDIFRX_INPUT_IN0               ((uint32_t)0x00000000U)
N#define SPDIFRX_INPUT_IN1               ((uint32_t)0x00010000U)  
N#define SPDIFRX_INPUT_IN2               ((uint32_t)0x00020000U)
N#define SPDIFRX_INPUT_IN3               ((uint32_t)0x00030000U)
N/**
N  * @}
N  */
N
N/** @defgroup SPDIFRX_Max_Retries SPDIFRX Maximum Retries
N  * @{
N  */
N#define SPDIFRX_MAXRETRIES_NONE            ((uint32_t)0x00000000U)
N#define SPDIFRX_MAXRETRIES_3               ((uint32_t)0x00001000U)  
N#define SPDIFRX_MAXRETRIES_15              ((uint32_t)0x00002000U)
N#define SPDIFRX_MAXRETRIES_63              ((uint32_t)0x00003000U)
N/**
N  * @}
N  */
N
N/** @defgroup SPDIFRX_Wait_For_Activity SPDIFRX Wait For Activity
N  * @{
N  */
N#define SPDIFRX_WAITFORACTIVITY_OFF                   ((uint32_t)0x00000000U)
N#define SPDIFRX_WAITFORACTIVITY_ON                    ((uint32_t)SPDIFRX_CR_WFA)
N/**
N  * @}
N  */
N    
N/** @defgroup SPDIFRX_PT_Mask SPDIFRX Preamble Type Mask
N* @{
N*/
N#define SPDIFRX_PREAMBLETYPEMASK_OFF                   ((uint32_t)0x00000000U)
N#define SPDIFRX_PREAMBLETYPEMASK_ON                    ((uint32_t)SPDIFRX_CR_PTMSK)
N/**
N  * @}
N  */
N
N/** @defgroup SPDIFRX_ChannelStatus_Mask  SPDIFRX Channel Status Mask
N* @{
N*/
N#define SPDIFRX_CHANNELSTATUS_OFF                 ((uint32_t)0x00000000U)        /* The channel status and user bits are copied into the SPDIF_DR */
N#define SPDIFRX_CHANNELSTATUS_ON                  ((uint32_t)SPDIFRX_CR_CUMSK)  /* The channel status and user bits are not copied into the SPDIF_DR, zeros are written instead*/
N/**
N  * @}
N  */
N
N/** @defgroup SPDIFRX_V_Mask SPDIFRX Validity Mask
N* @{
N*/
N#define SPDIFRX_VALIDITYMASK_OFF                   ((uint32_t)0x00000000U)
N#define SPDIFRX_VALIDITYMASK_ON                    ((uint32_t)SPDIFRX_CR_VMSK)
N/**
N  * @}
N  */
N
N/** @defgroup SPDIFRX_PE_Mask  SPDIFRX Parity Error Mask
N* @{
N*/
N#define SPDIFRX_PARITYERRORMASK_OFF                   ((uint32_t)0x00000000U)
N#define SPDIFRX_PARITYERRORMASK_ON                    ((uint32_t)SPDIFRX_CR_PMSK)
N/**
N  * @}
N  */
N
N/** @defgroup SPDIFRX_Channel_Selection  SPDIFRX Channel Selection
N  * @{
N  */
N#define SPDIFRX_CHANNEL_A      ((uint32_t)0x00000000U)
N#define SPDIFRX_CHANNEL_B      ((uint32_t)SPDIFRX_CR_CHSEL)
N/**
N  * @}
N  */
N
N/** @defgroup SPDIFRX_Data_Format SPDIFRX Data Format
N  * @{
N  */
N#define SPDIFRX_DATAFORMAT_LSB                   ((uint32_t)0x00000000U)
N#define SPDIFRX_DATAFORMAT_MSB                   ((uint32_t)0x00000010U)
N#define SPDIFRX_DATAFORMAT_32BITS                ((uint32_t)0x00000020U)
N/**
N  * @}
N  */ 
N
N/** @defgroup SPDIFRX_Stereo_Mode SPDIFRX Stereo Mode
N  * @{
N  */
N#define SPDIFRX_STEREOMODE_DISABLE           ((uint32_t)0x00000000U)
N#define SPDIFRX_STEREOMODE_ENABLE           ((uint32_t)SPDIFRX_CR_RXSTEO)
N/**
N  * @}
N  */ 
N
N/** @defgroup SPDIFRX_State SPDIFRX State
N  * @{
N  */
N
N#define SPDIFRX_STATE_IDLE    ((uint32_t)0xFFFFFFFCU)
N#define SPDIFRX_STATE_SYNC    ((uint32_t)0x00000001U)
N#define SPDIFRX_STATE_RCV     ((uint32_t)SPDIFRX_CR_SPDIFEN)
N/**
N  * @}
N  */
N    
N/** @defgroup SPDIFRX_Interrupts_Definition SPDIFRX Interrupts Definition
N  * @{
N  */
N#define SPDIFRX_IT_RXNE                       ((uint32_t)SPDIFRX_IMR_RXNEIE)
N#define SPDIFRX_IT_CSRNE                      ((uint32_t)SPDIFRX_IMR_CSRNEIE)
N#define SPDIFRX_IT_PERRIE                     ((uint32_t)SPDIFRX_IMR_PERRIE)
N#define SPDIFRX_IT_OVRIE                      ((uint32_t)SPDIFRX_IMR_OVRIE)
N#define SPDIFRX_IT_SBLKIE                     ((uint32_t)SPDIFRX_IMR_SBLKIE)
N#define SPDIFRX_IT_SYNCDIE                    ((uint32_t)SPDIFRX_IMR_SYNCDIE)
N#define SPDIFRX_IT_IFEIE                      ((uint32_t)SPDIFRX_IMR_IFEIE )
N/**
N  * @}
N  */
N    
N/** @defgroup SPDIFRX_Flags_Definition SPDIFRX Flags Definition
N  * @{
N  */
N#define SPDIFRX_FLAG_RXNE                   ((uint32_t)SPDIFRX_SR_RXNE)
N#define SPDIFRX_FLAG_CSRNE                  ((uint32_t)SPDIFRX_SR_CSRNE)
N#define SPDIFRX_FLAG_PERR                   ((uint32_t)SPDIFRX_SR_PERR)
N#define SPDIFRX_FLAG_OVR                    ((uint32_t)SPDIFRX_SR_OVR)
N#define SPDIFRX_FLAG_SBD                    ((uint32_t)SPDIFRX_SR_SBD)
N#define SPDIFRX_FLAG_SYNCD                  ((uint32_t)SPDIFRX_SR_SYNCD)
N#define SPDIFRX_FLAG_FERR                   ((uint32_t)SPDIFRX_SR_FERR)
N#define SPDIFRX_FLAG_SERR                   ((uint32_t)SPDIFRX_SR_SERR)
N#define SPDIFRX_FLAG_TERR                   ((uint32_t)SPDIFRX_SR_TERR)
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N  
N/* Exported macros -----------------------------------------------------------*/
N/** @defgroup SPDIFRX_Exported_macros SPDIFRX Exported Macros
N  * @{
N  */
N
N/** @brief  Reset SPDIFRX handle state
N  * @param  __HANDLE__: SPDIFRX handle.
N  * @retval None
N  */
N#define __HAL_SPDIFRX_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = (uint16_t)SPDIFRX_CR_SPDIFEN)
N
N/** @brief  Disable the specified SPDIFRX peripheral (IDLE State).
N  * @param  __HANDLE__: specifies the SPDIFRX Handle. 
N  * @retval None
N  */
N#define __HAL_SPDIFRX_IDLE(__HANDLE__) ((__HANDLE__)->Instance->CR &= SPDIFRX_STATE_IDLE)
N
N/** @brief  Enable the specified SPDIFRX peripheral (SYNC State).
N  * @param  __HANDLE__: specifies the SPDIFRX Handle. 
N  * @retval None
N  */
N#define __HAL_SPDIFRX_SYNC(__HANDLE__) ((__HANDLE__)->Instance->CR |= SPDIFRX_STATE_SYNC)
N
N
N/** @brief  Enable the specified SPDIFRX peripheral (RCV State).
N  * @param  __HANDLE__: specifies the SPDIFRX Handle. 
N  * @retval None
N  */
N#define __HAL_SPDIFRX_RCV(__HANDLE__) ((__HANDLE__)->Instance->CR |= SPDIFRX_STATE_RCV)
N
N
N/** @brief  Enable or disable the specified SPDIFRX interrupts.
N  * @param  __HANDLE__: specifies the SPDIFRX Handle.
N  * @param  __INTERRUPT__: specifies the interrupt source to enable or disable.
N  *        This parameter can be one of the following values:
N  *            @arg SPDIFRX_IT_RXNE
N  *            @arg SPDIFRX_IT_CSRNE
N  *            @arg SPDIFRX_IT_PERRIE
N  *            @arg SPDIFRX_IT_OVRIE
N  *            @arg SPDIFRX_IT_SBLKIE
N  *            @arg SPDIFRX_IT_SYNCDIE
N  *            @arg SPDIFRX_IT_IFEIE
N  * @retval None
N  */  
N#define __HAL_SPDIFRX_ENABLE_IT(__HANDLE__, __INTERRUPT__) ((__HANDLE__)->Instance->IMR |= (__INTERRUPT__))
N#define __HAL_SPDIFRX_DISABLE_IT(__HANDLE__, __INTERRUPT__) ((__HANDLE__)->Instance->IMR &= (uint16_t)(~(__INTERRUPT__)))
N 
N/** @brief  Checks if the specified SPDIFRX interrupt source is enabled or disabled.
N  * @param  __HANDLE__: specifies the SPDIFRX Handle.
N  * @param  __INTERRUPT__: specifies the SPDIFRX interrupt source to check.
N  *          This parameter can be one of the following values:
N  *            @arg SPDIFRX_IT_RXNE
N  *            @arg SPDIFRX_IT_CSRNE
N  *            @arg SPDIFRX_IT_PERRIE
N  *            @arg SPDIFRX_IT_OVRIE
N  *            @arg SPDIFRX_IT_SBLKIE
N  *            @arg SPDIFRX_IT_SYNCDIE
N  *            @arg SPDIFRX_IT_IFEIE
N  * @retval The new state of __IT__ (TRUE or FALSE).
N  */
N#define __HAL_SPDIFRX_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) ((((__HANDLE__)->Instance->IMR & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)
N
N/** @brief  Checks whether the specified SPDIFRX flag is set or not.
N  * @param  __HANDLE__: specifies the SPDIFRX Handle.
N  * @param  __FLAG__: specifies the flag to check.
N  *        This parameter can be one of the following values:
N  *            @arg SPDIFRX_FLAG_RXNE
N  *            @arg SPDIFRX_FLAG_CSRNE
N  *            @arg SPDIFRX_FLAG_PERR
N  *            @arg SPDIFRX_FLAG_OVR
N  *            @arg SPDIFRX_FLAG_SBD
N  *            @arg SPDIFRX_FLAG_SYNCD 
N  *            @arg SPDIFRX_FLAG_FERR 
N  *            @arg SPDIFRX_FLAG_SERR 
N  *            @arg SPDIFRX_FLAG_TERR 
N  * @retval The new state of __FLAG__ (TRUE or FALSE).
N  */
N#define __HAL_SPDIFRX_GET_FLAG(__HANDLE__, __FLAG__) ((((__HANDLE__)->Instance->SR) & (__FLAG__)) == (__FLAG__))
N
N/** @brief  Clears the specified SPDIFRX SR flag, in setting the proper IFCR register bit.
N  * @param  __HANDLE__: specifies the USART Handle.
N  * @param  __IT_CLEAR__: specifies the interrupt clear register flag that needs to be set
N  *                       to clear the corresponding interrupt
N  *          This parameter can be one of the following values:
N  *            @arg SPDIFRX_FLAG_PERR
N  *            @arg SPDIFRX_FLAG_OVR
N  *            @arg SPDIFRX_SR_SBD
N  *            @arg SPDIFRX_SR_SYNCD
N  * @retval None
N  */
N#define __HAL_SPDIFRX_CLEAR_IT(__HANDLE__, __IT_CLEAR__) ((__HANDLE__)->Instance->IFCR = (uint32_t)(__IT_CLEAR__)) 
N  
N/**
N  * @}
N  */
N  
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup SPDIFRX_Exported_Functions
N  * @{
N  */
N                                                
N/** @addtogroup SPDIFRX_Exported_Functions_Group1
N  * @{
N  */
N/* Initialization/de-initialization functions  **********************************/
NHAL_StatusTypeDef HAL_SPDIFRX_Init(SPDIFRX_HandleTypeDef *hspdif);
NHAL_StatusTypeDef HAL_SPDIFRX_DeInit (SPDIFRX_HandleTypeDef *hspdif);
Nvoid HAL_SPDIFRX_MspInit(SPDIFRX_HandleTypeDef *hspdif);
Nvoid HAL_SPDIFRX_MspDeInit(SPDIFRX_HandleTypeDef *hspdif);
NHAL_StatusTypeDef HAL_SPDIFRX_SetDataFormat(SPDIFRX_HandleTypeDef *hspdif, SPDIFRX_SetDataFormatTypeDef  sDataFormat);
N/**
N  * @}
N  */
N
N/** @addtogroup SPDIFRX_Exported_Functions_Group2
N  * @{
N  */
N/* I/O operation functions  ***************************************************/
N /* Blocking mode: Polling */
NHAL_StatusTypeDef HAL_SPDIFRX_ReceiveDataFlow(SPDIFRX_HandleTypeDef *hspdif, uint32_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_SPDIFRX_ReceiveControlFlow(SPDIFRX_HandleTypeDef *hspdif, uint32_t *pData, uint16_t Size, uint32_t Timeout);
N
N /* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_SPDIFRX_ReceiveControlFlow_IT(SPDIFRX_HandleTypeDef *hspdif, uint32_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_SPDIFRX_ReceiveDataFlow_IT(SPDIFRX_HandleTypeDef *hspdif, uint32_t *pData, uint16_t Size);
Nvoid HAL_SPDIFRX_IRQHandler(SPDIFRX_HandleTypeDef *hspdif);
N
N/* Non-Blocking mode: DMA */
NHAL_StatusTypeDef HAL_SPDIFRX_ReceiveControlFlow_DMA(SPDIFRX_HandleTypeDef *hspdif, uint32_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_SPDIFRX_ReceiveDataFlow_DMA(SPDIFRX_HandleTypeDef *hspdif, uint32_t *pData, uint16_t Size);
N
NHAL_StatusTypeDef HAL_SPDIFRX_DMAStop(SPDIFRX_HandleTypeDef *hspdif);
N
N/* Callbacks used in non blocking modes (Interrupt and DMA) *******************/
Nvoid HAL_SPDIFRX_RxHalfCpltCallback(SPDIFRX_HandleTypeDef *hspdif);
Nvoid HAL_SPDIFRX_RxCpltCallback(SPDIFRX_HandleTypeDef *hspdif);
Nvoid HAL_SPDIFRX_ErrorCallback(SPDIFRX_HandleTypeDef *hspdif);
Nvoid HAL_SPDIFRX_CxHalfCpltCallback(SPDIFRX_HandleTypeDef *hspdif);
Nvoid HAL_SPDIFRX_CxCpltCallback(SPDIFRX_HandleTypeDef *hspdif);
N/**
N  * @}
N  */
N
N/** @addtogroup SPDIFRX_Exported_Functions_Group3
N  * @{
N  */
N/* Peripheral Control and State functions  ************************************/
NHAL_SPDIFRX_StateTypeDef HAL_SPDIFRX_GetState(SPDIFRX_HandleTypeDef *hspdif);
Nuint32_t HAL_SPDIFRX_GetError(SPDIFRX_HandleTypeDef *hspdif);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup SPDIFRX_Private_Macros SPDIFRX Private Macros
N  * @{
N  */
N#define IS_SPDIFRX_INPUT_SELECT(INPUT)  (((INPUT) == SPDIFRX_INPUT_IN1) || \
N                                         ((INPUT) == SPDIFRX_INPUT_IN2) || \
N                                         ((INPUT) == SPDIFRX_INPUT_IN3)  || \
N                                         ((INPUT) == SPDIFRX_INPUT_IN0))
X#define IS_SPDIFRX_INPUT_SELECT(INPUT)  (((INPUT) == SPDIFRX_INPUT_IN1) ||                                          ((INPUT) == SPDIFRX_INPUT_IN2) ||                                          ((INPUT) == SPDIFRX_INPUT_IN3)  ||                                          ((INPUT) == SPDIFRX_INPUT_IN0))
N#define IS_SPDIFRX_MAX_RETRIES(RET)   (((RET) == SPDIFRX_MAXRETRIES_NONE) || \
N                                      ((RET) == SPDIFRX_MAXRETRIES_3)  || \
N                                      ((RET) == SPDIFRX_MAXRETRIES_15) || \
N                                      ((RET) == SPDIFRX_MAXRETRIES_63))
X#define IS_SPDIFRX_MAX_RETRIES(RET)   (((RET) == SPDIFRX_MAXRETRIES_NONE) ||                                       ((RET) == SPDIFRX_MAXRETRIES_3)  ||                                       ((RET) == SPDIFRX_MAXRETRIES_15) ||                                       ((RET) == SPDIFRX_MAXRETRIES_63))
N#define IS_SPDIFRX_WAIT_FOR_ACTIVITY(VAL)    (((VAL) == SPDIFRX_WAITFORACTIVITY_ON) || \
N                                               ((VAL) == SPDIFRX_WAITFORACTIVITY_OFF))
X#define IS_SPDIFRX_WAIT_FOR_ACTIVITY(VAL)    (((VAL) == SPDIFRX_WAITFORACTIVITY_ON) ||                                                ((VAL) == SPDIFRX_WAITFORACTIVITY_OFF))
N#define IS_PREAMBLE_TYPE_MASK(VAL)           (((VAL) == SPDIFRX_PREAMBLETYPEMASK_ON) || \
N                                             ((VAL) == SPDIFRX_PREAMBLETYPEMASK_OFF))
X#define IS_PREAMBLE_TYPE_MASK(VAL)           (((VAL) == SPDIFRX_PREAMBLETYPEMASK_ON) ||                                              ((VAL) == SPDIFRX_PREAMBLETYPEMASK_OFF))
N#define IS_VALIDITY_MASK(VAL)               (((VAL) == SPDIFRX_VALIDITYMASK_OFF) || \
N                                             ((VAL) == SPDIFRX_VALIDITYMASK_ON))
X#define IS_VALIDITY_MASK(VAL)               (((VAL) == SPDIFRX_VALIDITYMASK_OFF) ||                                              ((VAL) == SPDIFRX_VALIDITYMASK_ON))
N#define IS_PARITY_ERROR_MASK(VAL)            (((VAL) == SPDIFRX_PARITYERRORMASK_OFF) || \
N                                             ((VAL) == SPDIFRX_PARITYERRORMASK_ON))
X#define IS_PARITY_ERROR_MASK(VAL)            (((VAL) == SPDIFRX_PARITYERRORMASK_OFF) ||                                              ((VAL) == SPDIFRX_PARITYERRORMASK_ON))
N#define IS_SPDIFRX_CHANNEL(CHANNEL)   (((CHANNEL) == SPDIFRX_CHANNEL_A) || \
N                                       ((CHANNEL) == SPDIFRX_CHANNEL_B))
X#define IS_SPDIFRX_CHANNEL(CHANNEL)   (((CHANNEL) == SPDIFRX_CHANNEL_A) ||                                        ((CHANNEL) == SPDIFRX_CHANNEL_B))
N#define IS_SPDIFRX_DATA_FORMAT(FORMAT)           (((FORMAT) == SPDIFRX_DATAFORMAT_LSB) || \
N                                                 ((FORMAT) == SPDIFRX_DATAFORMAT_MSB) || \
N                                                 ((FORMAT) == SPDIFRX_DATAFORMAT_32BITS))
X#define IS_SPDIFRX_DATA_FORMAT(FORMAT)           (((FORMAT) == SPDIFRX_DATAFORMAT_LSB) ||                                                  ((FORMAT) == SPDIFRX_DATAFORMAT_MSB) ||                                                  ((FORMAT) == SPDIFRX_DATAFORMAT_32BITS))
N#define IS_STEREO_MODE(MODE)                 (((MODE) == SPDIFRX_STEREOMODE_DISABLE) || \
N                                             ((MODE) == SPDIFRX_STEREOMODE_ENABLE))
X#define IS_STEREO_MODE(MODE)                 (((MODE) == SPDIFRX_STEREOMODE_DISABLE) ||                                              ((MODE) == SPDIFRX_STEREOMODE_ENABLE))
N                                             
N#define IS_CHANNEL_STATUS_MASK(VAL)          (((VAL) == SPDIFRX_CHANNELSTATUS_ON) || \
N                                              ((VAL) == SPDIFRX_CHANNELSTATUS_OFF))
X#define IS_CHANNEL_STATUS_MASK(VAL)          (((VAL) == SPDIFRX_CHANNELSTATUS_ON) ||                                               ((VAL) == SPDIFRX_CHANNELSTATUS_OFF))
N/**                                                                                    
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup SPDIFRX_Private_Functions SPDIFRX Private Functions
N  * @{
N  */
N/**
N  * @}
N  */
N 
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N    
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif /* __STM32F7xx_HAL_SPDIFRX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 367 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_SPDIFRX_MODULE_ENABLED */
N
N#ifdef HAL_SPI_MODULE_ENABLED
N #include "stm32f7xx_hal_spi.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_spi.h" 1
N /**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_spi.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of SPI HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************  
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_SPI_H
N#define __STM32F7xx_HAL_SPI_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup SPI
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup SPI_Exported_Types SPI Exported Types
N  * @{
N  */
N
N/**
N  * @brief  SPI Configuration Structure definition
N  */
Ntypedef struct
N{
N  uint32_t Mode;                /*!< Specifies the SPI operating mode.
N                                     This parameter can be a value of @ref SPI_Mode */
N
N  uint32_t Direction;           /*!< Specifies the SPI bidirectional mode state.
N                                     This parameter can be a value of @ref SPI_Direction */
N
N  uint32_t DataSize;            /*!< Specifies the SPI data size.
N                                     This parameter can be a value of @ref SPI_Data_Size */
N
N  uint32_t CLKPolarity;         /*!< Specifies the serial clock steady state.
N                                     This parameter can be a value of @ref SPI_Clock_Polarity */
N
N  uint32_t CLKPhase;            /*!< Specifies the clock active edge for the bit capture.
N                                     This parameter can be a value of @ref SPI_Clock_Phase */
N
N  uint32_t NSS;                 /*!< Specifies whether the NSS signal is managed by
N                                     hardware (NSS pin) or by software using the SSI bit.
N                                     This parameter can be a value of @ref SPI_Slave_Select_management */
N
N  uint32_t BaudRatePrescaler;   /*!< Specifies the Baud Rate prescaler value which will be
N                                     used to configure the transmit and receive SCK clock.
N                                     This parameter can be a value of @ref SPI_BaudRate_Prescaler
N                                     @note The communication clock is derived from the master
N                                     clock. The slave clock does not need to be set. */
N
N  uint32_t FirstBit;            /*!< Specifies whether data transfers start from MSB or LSB bit.
N                                     This parameter can be a value of @ref SPI_MSB_LSB_transmission */
N
N  uint32_t TIMode;              /*!< Specifies if the TI mode is enabled or not .
N                                     This parameter can be a value of @ref SPI_TI_mode */
N
N  uint32_t CRCCalculation;      /*!< Specifies if the CRC calculation is enabled or not.
N                                     This parameter can be a value of @ref SPI_CRC_Calculation */
N
N  uint32_t CRCPolynomial;       /*!< Specifies the polynomial used for the CRC calculation.
N                                     This parameter must be a number between Min_Data = 0 and Max_Data = 65535 */
N
N  uint32_t CRCLength;           /*!< Specifies the CRC Length used for the CRC calculation.
N                                     CRC Length is only used with Data8 and Data16, not other data size
N                                     This parameter can be a value of @ref SPI_CRC_length */
N
N  uint32_t NSSPMode;            /*!< Specifies whether the NSSP signal is enabled or not .
N                                     This parameter can be a value of @ref SPI_NSSP_Mode
N                                     This mode is activated by the NSSP bit in the SPIx_CR2 register and
N                                     it takes effect only if the SPI interface is configured as Motorola SPI
N                                     master (FRF=0) with capture on the first edge (SPIx_CR1 CPHA = 0,
N                                     CPOL setting is ignored).. */
N} SPI_InitTypeDef;
N
N/**
N  * @brief  HAL State structures definition
N  */
Ntypedef enum
N{
N  HAL_SPI_STATE_RESET      = 0x00U,    /*!< Peripheral not Initialized                         */
N  HAL_SPI_STATE_READY      = 0x01U,    /*!< Peripheral Initialized and ready for use           */
N  HAL_SPI_STATE_BUSY       = 0x02U,    /*!< an internal process is ongoing                     */
N  HAL_SPI_STATE_BUSY_TX    = 0x03U,    /*!< Data Transmission process is ongoing               */
N  HAL_SPI_STATE_BUSY_RX    = 0x04U,    /*!< Data Reception process is ongoing                  */
N  HAL_SPI_STATE_BUSY_TX_RX = 0x05U,    /*!< Data Transmission and Reception process is ongoing*/
N  HAL_SPI_STATE_ERROR      = 0x06U     /*!< SPI error state                                   */
N}HAL_SPI_StateTypeDef;
N
N/**
N  * @brief  SPI handle Structure definition
N  */
Ntypedef struct __SPI_HandleTypeDef
N{
N  SPI_TypeDef             *Instance;      /* SPI registers base address     */
N
N  SPI_InitTypeDef         Init;           /* SPI communication parameters   */
N
N  uint8_t                 *pTxBuffPtr;    /* Pointer to SPI Tx transfer Buffer */
N
N  uint16_t                TxXferSize;     /* SPI Tx Transfer size */
N
N  uint16_t                TxXferCount;    /* SPI Tx Transfer Counter */
N
N  uint8_t                 *pRxBuffPtr;    /* Pointer to SPI Rx transfer Buffer */
N
N  uint16_t                RxXferSize;     /* SPI Rx Transfer size */
N
N  uint16_t                RxXferCount;    /* SPI Rx Transfer Counter */
N
N  uint32_t                CRCSize;        /* SPI CRC size used for the transfer */
N
N  void (*RxISR)(struct __SPI_HandleTypeDef *hspi); /* function pointer on Rx IRQ handler   */
N
N  void (*TxISR)(struct __SPI_HandleTypeDef *hspi); /* function pointer on Tx IRQ handler   */
N
N  DMA_HandleTypeDef       *hdmatx;        /* SPI Tx DMA Handle parameters   */
N
N  DMA_HandleTypeDef       *hdmarx;        /* SPI Rx DMA Handle parameters   */
N
N  HAL_LockTypeDef         Lock;           /* Locking object                 */
N
N  __IO HAL_SPI_StateTypeDef    State;          /* SPI communication state        */
X  volatile HAL_SPI_StateTypeDef    State;           
N
N  __IO uint32_t                ErrorCode;      /* SPI Error code                 */
X  volatile uint32_t                ErrorCode;       
N
N}SPI_HandleTypeDef;
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup SPI_Exported_Constants SPI Exported Constants
N  * @{
N  */
N
N/** @defgroup SPI_Error_Code SPI Error Code
N  * @{
N  */
N#define HAL_SPI_ERROR_NONE   ((uint32_t)0x00000000U)  /*!< No error                          */
N#define HAL_SPI_ERROR_MODF   ((uint32_t)0x00000001U)  /*!< MODF error                        */
N#define HAL_SPI_ERROR_CRC    ((uint32_t)0x00000002U)  /*!< CRC error                         */
N#define HAL_SPI_ERROR_OVR    ((uint32_t)0x00000004U)  /*!< OVR error                         */
N#define HAL_SPI_ERROR_FRE    ((uint32_t)0x00000008U)  /*!< FRE error                         */
N#define HAL_SPI_ERROR_DMA    ((uint32_t)0x00000010U)  /*!< DMA transfer error                */
N#define HAL_SPI_ERROR_FLAG   ((uint32_t)0x00000020U)  /*!< Error on BSY/TXE/FTLVL/FRLVL Flag */
N#define HAL_SPI_ERROR_UNKNOW ((uint32_t)0x00000040U)  /*!< Unknow Error error                */
N/**
N  * @}
N  */
N
N
N/** @defgroup SPI_Mode SPI Mode
N  * @{
N  */
N#define SPI_MODE_SLAVE                  ((uint32_t)0x00000000U)
N#define SPI_MODE_MASTER                 (SPI_CR1_MSTR | SPI_CR1_SSI)
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Direction SPI Direction Mode
N  * @{
N  */
N#define SPI_DIRECTION_2LINES            ((uint32_t)0x00000000U)
N#define SPI_DIRECTION_2LINES_RXONLY     SPI_CR1_RXONLY
N#define SPI_DIRECTION_1LINE             SPI_CR1_BIDIMODE
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Data_Size SPI Data Size
N  * @{
N  */
N#define SPI_DATASIZE_4BIT               ((uint32_t)0x0300U)
N#define SPI_DATASIZE_5BIT               ((uint32_t)0x0400U)
N#define SPI_DATASIZE_6BIT               ((uint32_t)0x0500U)
N#define SPI_DATASIZE_7BIT               ((uint32_t)0x0600U)
N#define SPI_DATASIZE_8BIT               ((uint32_t)0x0700U)
N#define SPI_DATASIZE_9BIT               ((uint32_t)0x0800U)
N#define SPI_DATASIZE_10BIT              ((uint32_t)0x0900U)
N#define SPI_DATASIZE_11BIT              ((uint32_t)0x0A00U)
N#define SPI_DATASIZE_12BIT              ((uint32_t)0x0B00U)
N#define SPI_DATASIZE_13BIT              ((uint32_t)0x0C00U)
N#define SPI_DATASIZE_14BIT              ((uint32_t)0x0D00U)
N#define SPI_DATASIZE_15BIT              ((uint32_t)0x0E00U)
N#define SPI_DATASIZE_16BIT              ((uint32_t)0x0F00U)
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Clock_Polarity SPI Clock Polarity
N  * @{
N  */
N#define SPI_POLARITY_LOW                ((uint32_t)0x00000000U)
N#define SPI_POLARITY_HIGH               SPI_CR1_CPOL
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Clock_Phase SPI Clock Phase
N  * @{
N  */
N#define SPI_PHASE_1EDGE                 ((uint32_t)0x00000000U)
N#define SPI_PHASE_2EDGE                 SPI_CR1_CPHA
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Slave_Select_management SPI Slave Select management
N  * @{
N  */
N#define SPI_NSS_SOFT                    SPI_CR1_SSM
N#define SPI_NSS_HARD_INPUT              ((uint32_t)0x00000000U)
N#define SPI_NSS_HARD_OUTPUT             ((uint32_t)0x00040000U)
N/**
N  * @}
N  */
N
N/** @defgroup SPI_NSSP_Mode SPI NSS Pulse Mode
N  * @{
N  */
N#define SPI_NSS_PULSE_ENABLE            SPI_CR2_NSSP
N#define SPI_NSS_PULSE_DISABLE           ((uint32_t)0x00000000U)
N/**
N  * @}
N  */
N
N/** @defgroup SPI_BaudRate_Prescaler SPI BaudRate Prescaler
N  * @{
N  */
N#define SPI_BAUDRATEPRESCALER_2         ((uint32_t)0x00000000U)
N#define SPI_BAUDRATEPRESCALER_4         ((uint32_t)0x00000008U)
N#define SPI_BAUDRATEPRESCALER_8         ((uint32_t)0x00000010U)
N#define SPI_BAUDRATEPRESCALER_16        ((uint32_t)0x00000018U)
N#define SPI_BAUDRATEPRESCALER_32        ((uint32_t)0x00000020U)
N#define SPI_BAUDRATEPRESCALER_64        ((uint32_t)0x00000028U)
N#define SPI_BAUDRATEPRESCALER_128       ((uint32_t)0x00000030U)
N#define SPI_BAUDRATEPRESCALER_256       ((uint32_t)0x00000038U)
N/**
N  * @}
N  */
N
N/** @defgroup SPI_MSB_LSB_transmission SPI MSB LSB transmission
N  * @{
N  */
N#define SPI_FIRSTBIT_MSB                ((uint32_t)0x00000000U)
N#define SPI_FIRSTBIT_LSB                SPI_CR1_LSBFIRST
N/**
N  * @}
N  */
N
N/** @defgroup SPI_TI_mode SPI TI mode
N  * @{
N  */
N#define SPI_TIMODE_DISABLE              ((uint32_t)0x00000000U)
N#define SPI_TIMODE_ENABLE               SPI_CR2_FRF
N/**
N  * @}
N  */
N
N/** @defgroup SPI_CRC_Calculation SPI CRC Calculation
N  * @{
N  */
N#define SPI_CRCCALCULATION_DISABLE      ((uint32_t)0x00000000U)
N#define SPI_CRCCALCULATION_ENABLE       SPI_CR1_CRCEN
N/**
N  * @}
N  */
N
N/** @defgroup SPI_CRC_length SPI CRC Length
N  * @{
N  * This parameter can be one of the following values:
N  *     SPI_CRC_LENGTH_DATASIZE: aligned with the data size
N  *     SPI_CRC_LENGTH_8BIT    : CRC 8bit
N  *     SPI_CRC_LENGTH_16BIT   : CRC 16bit
N  */
N#define SPI_CRC_LENGTH_DATASIZE         ((uint32_t)0x00000000U)
N#define SPI_CRC_LENGTH_8BIT             ((uint32_t)0x00000001U)
N#define SPI_CRC_LENGTH_16BIT            ((uint32_t)0x00000002U)
N/**
N  * @}
N  */
N
N/** @defgroup SPI_FIFO_reception_threshold SPI FIFO Reception Threshold
N  * @{
N  * This parameter can be one of the following values:
N  *     SPI_RXFIFO_THRESHOLD or SPI_RXFIFO_THRESHOLD_QF :
N  *          RXNE event is generated if the FIFO
N  *          level is greater or equal to 1/2(16-bits).
N  *     SPI_RXFIFO_THRESHOLD_HF: RXNE event is generated if the FIFO
N  *          level is greater or equal to 1/4(8 bits). */
N#define SPI_RXFIFO_THRESHOLD            SPI_CR2_FRXTH
N#define SPI_RXFIFO_THRESHOLD_QF         SPI_CR2_FRXTH
N#define SPI_RXFIFO_THRESHOLD_HF         ((uint32_t)0x00000000U)
N
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Interrupt_configuration_definition SPI Interrupt configuration definition
N  * @brief SPI Interrupt definition
N  *        Elements values convention: 0xXXXXXXXX
N  *           - XXXXXXXX  : Interrupt control mask
N  * @{
N  */
N#define SPI_IT_TXE                      SPI_CR2_TXEIE
N#define SPI_IT_RXNE                     SPI_CR2_RXNEIE
N#define SPI_IT_ERR                      SPI_CR2_ERRIE
N/**
N  * @}
N  */
N
N
N/** @defgroup SPI_Flag_definition SPI Flag definition
N  * @brief Flag definition
N  *        Elements values convention: 0xXXXXYYYY
N  *           - XXXX  : Flag register Index
N  *           - YYYY  : Flag mask
N  * @{
N  */
N#define SPI_FLAG_RXNE                   SPI_SR_RXNE   /* SPI status flag: Rx buffer not empty flag */
N#define SPI_FLAG_TXE                    SPI_SR_TXE    /* SPI status flag: Tx buffer empty flag */
N#define SPI_FLAG_BSY                    SPI_SR_BSY    /* SPI status flag: Busy flag */
N#define SPI_FLAG_CRCERR                 SPI_SR_CRCERR /* SPI Error flag: CRC error flag */
N#define SPI_FLAG_MODF                   SPI_SR_MODF   /* SPI Error flag: Mode fault flag */
N#define SPI_FLAG_OVR                    SPI_SR_OVR    /* SPI Error flag: Overrun flag */
N#define SPI_FLAG_FRE                    SPI_SR_FRE    /* SPI Error flag: TI mode frame format error flag */
N#define SPI_FLAG_FTLVL                  SPI_SR_FTLVL  /* SPI fifo transmission level */
N#define SPI_FLAG_FRLVL                  SPI_SR_FRLVL  /* SPI fifo reception level */
N/**
N  * @}
N  */
N
N/** @defgroup SPI_transmission_fifo_status_level SPI Transmission FIFO Status Level
N  * @{
N  */
N#define SPI_FTLVL_EMPTY           ((uint32_t)0x0000U)
N#define SPI_FTLVL_QUARTER_FULL    ((uint32_t)0x0800U)
N#define SPI_FTLVL_HALF_FULL       ((uint32_t)0x1000U)
N#define SPI_FTLVL_FULL            ((uint32_t)0x1800U)
N
N/**
N  * @}
N  */
N
N/** @defgroup SPI_reception_fifo_status_level SPI Reception FIFO Status Level
N  * @{
N  */
N#define SPI_FRLVL_EMPTY           ((uint32_t)0x0000U)
N#define SPI_FRLVL_QUARTER_FULL    ((uint32_t)0x0200U)
N#define SPI_FRLVL_HALF_FULL       ((uint32_t)0x0400U)
N#define SPI_FRLVL_FULL            ((uint32_t)0x0600U)
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macros ------------------------------------------------------------*/
N/** @defgroup SPI_Exported_Macros SPI Exported Macros
N  * @{
N  */
N
N/** @brief  Reset SPI handle state
N  * @param  __HANDLE__: SPI handle.
N  * @retval None
N  */
N#define __HAL_SPI_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_SPI_STATE_RESET)
N
N/** @brief  Enables or disables the specified SPI interrupts.
N  * @param  __HANDLE__ : specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @param  __INTERRUPT__ : specifies the interrupt source to enable or disable.
N  *        This parameter can be one of the following values:
N  *            @arg SPI_IT_TXE: Tx buffer empty interrupt enable
N  *            @arg SPI_IT_RXNE: RX buffer not empty interrupt enable
N  *            @arg SPI_IT_ERR: Error interrupt enable
N  * @retval None
N  */
N#define __HAL_SPI_ENABLE_IT(__HANDLE__, __INTERRUPT__)   ((__HANDLE__)->Instance->CR2 |= (__INTERRUPT__))
N#define __HAL_SPI_DISABLE_IT(__HANDLE__, __INTERRUPT__)  ((__HANDLE__)->Instance->CR2 &= (~(__INTERRUPT__)))
N
N/** @brief  Checks if the specified SPI interrupt source is enabled or disabled.
N  * @param  __HANDLE__ : specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @param  __INTERRUPT__ : specifies the SPI interrupt source to check.
N  *          This parameter can be one of the following values:
N  *            @arg SPI_IT_TXE: Tx buffer empty interrupt enable
N  *            @arg SPI_IT_RXNE: RX buffer not empty interrupt enable
N  *            @arg SPI_IT_ERR: Error interrupt enable
N  * @retval The new state of __IT__ (TRUE or FALSE).
N  */
N#define __HAL_SPI_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) ((((__HANDLE__)->Instance->CR2 & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)
N
N/** @brief  Checks whether the specified SPI flag is set or not.
N  * @param  __HANDLE__ : specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @param  __FLAG__ : specifies the flag to check.
N  *        This parameter can be one of the following values:
N  *            @arg SPI_FLAG_RXNE: Receive buffer not empty flag
N  *            @arg SPI_FLAG_TXE: Transmit buffer empty flag
N  *            @arg SPI_FLAG_CRCERR: CRC error flag
N  *            @arg SPI_FLAG_MODF: Mode fault flag
N  *            @arg SPI_FLAG_OVR: Overrun flag
N  *            @arg SPI_FLAG_BSY: Busy flag
N  *            @arg SPI_FLAG_FRE: Frame format error flag
N  *            @arg SPI_FLAG_FTLVL: SPI fifo transmission level
N  *            @arg SPI_FLAG_FRLVL: SPI fifo reception level
N  * @retval The new state of __FLAG__ (TRUE or FALSE).
N  */
N#define __HAL_SPI_GET_FLAG(__HANDLE__, __FLAG__) ((((__HANDLE__)->Instance->SR) & (__FLAG__)) == (__FLAG__))
N
N/** @brief  Clears the SPI CRCERR pending flag.
N  * @param  __HANDLE__ : specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @retval None
N  */
N#define __HAL_SPI_CLEAR_CRCERRFLAG(__HANDLE__) ((__HANDLE__)->Instance->SR = (uint16_t)(~SPI_FLAG_CRCERR))
N
N/** @brief  Clears the SPI MODF pending flag.
N  * @param  __HANDLE__ : specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  *
N  * @retval None
N  */
N#define __HAL_SPI_CLEAR_MODFFLAG(__HANDLE__)        \
N   do{                                              \
N     __IO uint32_t tmpreg;                          \
N     tmpreg = (__HANDLE__)->Instance->SR;           \
N     (__HANDLE__)->Instance->CR1 &= (~SPI_CR1_SPE); \
N     UNUSED(tmpreg);                                \
N   } while(0)
X#define __HAL_SPI_CLEAR_MODFFLAG(__HANDLE__)           do{                                                   __IO uint32_t tmpreg;                               tmpreg = (__HANDLE__)->Instance->SR;                (__HANDLE__)->Instance->CR1 &= (~SPI_CR1_SPE);      UNUSED(tmpreg);                                   } while(0)
N
N/** @brief  Clears the SPI OVR pending flag.
N  * @param  __HANDLE__ : specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  *
N  * @retval None
N  */
N#define __HAL_SPI_CLEAR_OVRFLAG(__HANDLE__)         \
N   do{                                              \
N     __IO uint32_t tmpreg;                          \
N     tmpreg = (__HANDLE__)->Instance->DR;           \
N     tmpreg = (__HANDLE__)->Instance->SR;           \
N     UNUSED(tmpreg);                                \
N   } while(0)
X#define __HAL_SPI_CLEAR_OVRFLAG(__HANDLE__)            do{                                                   __IO uint32_t tmpreg;                               tmpreg = (__HANDLE__)->Instance->DR;                tmpreg = (__HANDLE__)->Instance->SR;                UNUSED(tmpreg);                                   } while(0)
N
N/** @brief  Clears the SPI FRE pending flag.
N  * @param  __HANDLE__ : specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  *
N  * @retval None
N  */
N#define __HAL_SPI_CLEAR_FREFLAG(__HANDLE__)         \
N   do{                                              \
N     __IO uint32_t tmpreg;                          \
N     tmpreg = (__HANDLE__)->Instance->SR;           \
N     UNUSED(tmpreg);                                \
N   } while(0)
X#define __HAL_SPI_CLEAR_FREFLAG(__HANDLE__)            do{                                                   __IO uint32_t tmpreg;                               tmpreg = (__HANDLE__)->Instance->SR;                UNUSED(tmpreg);                                   } while(0)
N
N/** @brief  Enables the SPI.
N  * @param  __HANDLE__ : specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @retval None
N  */
N#define __HAL_SPI_ENABLE(__HANDLE__) ((__HANDLE__)->Instance->CR1 |=  SPI_CR1_SPE)
N
N/** @brief  Disables the SPI.
N  * @param  __HANDLE__ : specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @retval None
N  */
N#define __HAL_SPI_DISABLE(__HANDLE__) ((__HANDLE__)->Instance->CR1 &= (~SPI_CR1_SPE))
N
N/**
N  * @}
N  */
N
N/* Private macros --------------------------------------------------------*/
N/** @defgroup SPI_Private_Macros   SPI Private Macros
N  * @{
N  */
N
N/** @brief  Sets the SPI transmit-only mode.
N  * @param  __HANDLE__ : specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @retval None
N  */
N#define SPI_1LINE_TX(__HANDLE__) ((__HANDLE__)->Instance->CR1 |= SPI_CR1_BIDIOE)
N
N/** @brief  Sets the SPI receive-only mode.
N  * @param  __HANDLE__ : specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @retval None
N  */
N#define SPI_1LINE_RX(__HANDLE__) ((__HANDLE__)->Instance->CR1 &= (~SPI_CR1_BIDIOE))
N
N/** @brief  Resets the CRC calculation of the SPI.
N  * @param  __HANDLE__ : specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @retval None
N  */
N#define SPI_RESET_CRC(__HANDLE__) do{(__HANDLE__)->Instance->CR1 &= (uint16_t)(~SPI_CR1_CRCEN);\
N                                     (__HANDLE__)->Instance->CR1 |= SPI_CR1_CRCEN;}while(0)
X#define SPI_RESET_CRC(__HANDLE__) do{(__HANDLE__)->Instance->CR1 &= (uint16_t)(~SPI_CR1_CRCEN);                                     (__HANDLE__)->Instance->CR1 |= SPI_CR1_CRCEN;}while(0)
N
N#define IS_SPI_MODE(MODE) (((MODE) == SPI_MODE_SLAVE) || \
N                           ((MODE) == SPI_MODE_MASTER))
X#define IS_SPI_MODE(MODE) (((MODE) == SPI_MODE_SLAVE) ||                            ((MODE) == SPI_MODE_MASTER))
N
N#define IS_SPI_DIRECTION(MODE)   (((MODE) == SPI_DIRECTION_2LINES) || \
N                                  ((MODE) == SPI_DIRECTION_2LINES_RXONLY) ||\
N                                  ((MODE) == SPI_DIRECTION_1LINE))
X#define IS_SPI_DIRECTION(MODE)   (((MODE) == SPI_DIRECTION_2LINES) ||                                   ((MODE) == SPI_DIRECTION_2LINES_RXONLY) ||                                  ((MODE) == SPI_DIRECTION_1LINE))
N
N#define IS_SPI_DIRECTION_2LINES(MODE) ((MODE) == SPI_DIRECTION_2LINES)
N
N#define IS_SPI_DIRECTION_2LINES_OR_1LINE(MODE) (((MODE) == SPI_DIRECTION_2LINES)|| \
N                                                 ((MODE) == SPI_DIRECTION_1LINE))
X#define IS_SPI_DIRECTION_2LINES_OR_1LINE(MODE) (((MODE) == SPI_DIRECTION_2LINES)||                                                  ((MODE) == SPI_DIRECTION_1LINE))
N
N#define IS_SPI_DATASIZE(DATASIZE) (((DATASIZE) == SPI_DATASIZE_16BIT) || \
N                                   ((DATASIZE) == SPI_DATASIZE_15BIT) || \
N                                   ((DATASIZE) == SPI_DATASIZE_14BIT) || \
N                                   ((DATASIZE) == SPI_DATASIZE_13BIT) || \
N                                   ((DATASIZE) == SPI_DATASIZE_12BIT) || \
N                                   ((DATASIZE) == SPI_DATASIZE_11BIT) || \
N                                   ((DATASIZE) == SPI_DATASIZE_10BIT) || \
N                                   ((DATASIZE) == SPI_DATASIZE_9BIT)  || \
N                                   ((DATASIZE) == SPI_DATASIZE_8BIT)  || \
N                                   ((DATASIZE) == SPI_DATASIZE_7BIT)  || \
N                                   ((DATASIZE) == SPI_DATASIZE_6BIT)  || \
N                                   ((DATASIZE) == SPI_DATASIZE_5BIT)  || \
N                                   ((DATASIZE) == SPI_DATASIZE_4BIT))
X#define IS_SPI_DATASIZE(DATASIZE) (((DATASIZE) == SPI_DATASIZE_16BIT) ||                                    ((DATASIZE) == SPI_DATASIZE_15BIT) ||                                    ((DATASIZE) == SPI_DATASIZE_14BIT) ||                                    ((DATASIZE) == SPI_DATASIZE_13BIT) ||                                    ((DATASIZE) == SPI_DATASIZE_12BIT) ||                                    ((DATASIZE) == SPI_DATASIZE_11BIT) ||                                    ((DATASIZE) == SPI_DATASIZE_10BIT) ||                                    ((DATASIZE) == SPI_DATASIZE_9BIT)  ||                                    ((DATASIZE) == SPI_DATASIZE_8BIT)  ||                                    ((DATASIZE) == SPI_DATASIZE_7BIT)  ||                                    ((DATASIZE) == SPI_DATASIZE_6BIT)  ||                                    ((DATASIZE) == SPI_DATASIZE_5BIT)  ||                                    ((DATASIZE) == SPI_DATASIZE_4BIT))
N
N#define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_POLARITY_LOW) || \
N                           ((CPOL) == SPI_POLARITY_HIGH))
X#define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_POLARITY_LOW) ||                            ((CPOL) == SPI_POLARITY_HIGH))
N
N#define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_PHASE_1EDGE) || \
N                           ((CPHA) == SPI_PHASE_2EDGE))
X#define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_PHASE_1EDGE) ||                            ((CPHA) == SPI_PHASE_2EDGE))
N
N#define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_SOFT) || \
N                         ((NSS) == SPI_NSS_HARD_INPUT) || \
N                         ((NSS) == SPI_NSS_HARD_OUTPUT))
X#define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_SOFT) ||                          ((NSS) == SPI_NSS_HARD_INPUT) ||                          ((NSS) == SPI_NSS_HARD_OUTPUT))
N
N#define IS_SPI_NSSP(NSSP) (((NSSP) == SPI_NSS_PULSE_ENABLE) || \
N                           ((NSSP) == SPI_NSS_PULSE_DISABLE))
X#define IS_SPI_NSSP(NSSP) (((NSSP) == SPI_NSS_PULSE_ENABLE) ||                            ((NSSP) == SPI_NSS_PULSE_DISABLE))
N
N#define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BAUDRATEPRESCALER_2) || \
N                                              ((PRESCALER) == SPI_BAUDRATEPRESCALER_4) || \
N                                              ((PRESCALER) == SPI_BAUDRATEPRESCALER_8) || \
N                                              ((PRESCALER) == SPI_BAUDRATEPRESCALER_16) || \
N                                              ((PRESCALER) == SPI_BAUDRATEPRESCALER_32) || \
N                                              ((PRESCALER) == SPI_BAUDRATEPRESCALER_64) || \
N                                              ((PRESCALER) == SPI_BAUDRATEPRESCALER_128) || \
N                                              ((PRESCALER) == SPI_BAUDRATEPRESCALER_256))
X#define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BAUDRATEPRESCALER_2) ||                                               ((PRESCALER) == SPI_BAUDRATEPRESCALER_4) ||                                               ((PRESCALER) == SPI_BAUDRATEPRESCALER_8) ||                                               ((PRESCALER) == SPI_BAUDRATEPRESCALER_16) ||                                               ((PRESCALER) == SPI_BAUDRATEPRESCALER_32) ||                                               ((PRESCALER) == SPI_BAUDRATEPRESCALER_64) ||                                               ((PRESCALER) == SPI_BAUDRATEPRESCALER_128) ||                                               ((PRESCALER) == SPI_BAUDRATEPRESCALER_256))
N
N#define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FIRSTBIT_MSB) || \
N                               ((BIT) == SPI_FIRSTBIT_LSB))
X#define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FIRSTBIT_MSB) ||                                ((BIT) == SPI_FIRSTBIT_LSB))
N
N#define IS_SPI_TIMODE(MODE) (((MODE) == SPI_TIMODE_DISABLE) || \
N                             ((MODE) == SPI_TIMODE_ENABLE))
X#define IS_SPI_TIMODE(MODE) (((MODE) == SPI_TIMODE_DISABLE) ||                              ((MODE) == SPI_TIMODE_ENABLE))
N
N#define IS_SPI_CRC_CALCULATION(CALCULATION) (((CALCULATION) == SPI_CRCCALCULATION_DISABLE) || \
N                                             ((CALCULATION) == SPI_CRCCALCULATION_ENABLE))
X#define IS_SPI_CRC_CALCULATION(CALCULATION) (((CALCULATION) == SPI_CRCCALCULATION_DISABLE) ||                                              ((CALCULATION) == SPI_CRCCALCULATION_ENABLE))
N
N#define IS_SPI_CRC_LENGTH(LENGTH) (((LENGTH) == SPI_CRC_LENGTH_DATASIZE) ||\
N                                   ((LENGTH) == SPI_CRC_LENGTH_8BIT)  ||   \
N                                   ((LENGTH) == SPI_CRC_LENGTH_16BIT))
X#define IS_SPI_CRC_LENGTH(LENGTH) (((LENGTH) == SPI_CRC_LENGTH_DATASIZE) ||                                   ((LENGTH) == SPI_CRC_LENGTH_8BIT)  ||                                      ((LENGTH) == SPI_CRC_LENGTH_16BIT))
N
N#define IS_SPI_CRC_POLYNOMIAL(POLYNOMIAL) (((POLYNOMIAL) >= 0x1) && ((POLYNOMIAL) <= 0xFFFF) && (((POLYNOMIAL)&0x1) != 0))
N
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup SPI_Exported_Functions SPI Exported Functions
N  * @{
N  */
N
N/** @addtogroup SPI_Exported_Functions_Group1 Initialization and de-initialization functions
N  * @{
N  */
N
N/* Initialization and de-initialization functions  ****************************/
NHAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi);
NHAL_StatusTypeDef HAL_SPI_DeInit (SPI_HandleTypeDef *hspi);
Nvoid HAL_SPI_MspInit(SPI_HandleTypeDef *hspi);
Nvoid HAL_SPI_MspDeInit(SPI_HandleTypeDef *hspi);
N/**
N  * @}
N  */
N
N/** @addtogroup SPI_Exported_Functions_Group2 IO operation functions
N  * @{
N  */
N
N/* IO operation functions *****************************************************/
NHAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_SPI_Transmit_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_SPI_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_SPI_TransmitReceive_IT(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size);
NHAL_StatusTypeDef HAL_SPI_Transmit_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_SPI_Receive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_SPI_TransmitReceive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size);
NHAL_StatusTypeDef HAL_SPI_DMAPause(SPI_HandleTypeDef *hspi);
NHAL_StatusTypeDef HAL_SPI_DMAResume(SPI_HandleTypeDef *hspi);
NHAL_StatusTypeDef HAL_SPI_DMAStop(SPI_HandleTypeDef *hspi);
N
Nvoid HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi);
Nvoid HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi);
Nvoid HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi);
Nvoid HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi);
Nvoid HAL_SPI_TxHalfCpltCallback(SPI_HandleTypeDef *hspi);
Nvoid HAL_SPI_RxHalfCpltCallback(SPI_HandleTypeDef *hspi);
Nvoid HAL_SPI_TxRxHalfCpltCallback(SPI_HandleTypeDef *hspi);
Nvoid HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi);
N/**
N  * @}
N  */
N
N/** @addtogroup SPI_Exported_Functions_Group3 Peripheral State and Errors functions
N  * @{
N  */
N
N/* Peripheral State and Error functions ***************************************/
NHAL_SPI_StateTypeDef HAL_SPI_GetState(SPI_HandleTypeDef *hspi);
Nuint32_t             HAL_SPI_GetError(SPI_HandleTypeDef *hspi);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_SPI_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 371 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_SPI_MODULE_ENABLED */
N
N#ifdef HAL_TIM_MODULE_ENABLED
N #include "stm32f7xx_hal_tim.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_tim.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_tim.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of TIM HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_TIM_H
N#define __STM32F7xx_HAL_TIM_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup TIM
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup TIM_Exported_Types TIM Exported Types
N  * @{
N  */
N  
N/** 
N  * @brief  TIM Time base Configuration Structure definition  
N  */
Ntypedef struct
N{
N  uint32_t Prescaler;         /*!< Specifies the prescaler value used to divide the TIM clock.
N                                   This parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF */
N
N  uint32_t CounterMode;       /*!< Specifies the counter mode.
N                                   This parameter can be a value of @ref TIM_Counter_Mode */
N
N  uint32_t Period;            /*!< Specifies the period value to be loaded into the active
N                                   Auto-Reload Register at the next update event.
N                                   This parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF.  */
N
N  uint32_t ClockDivision;     /*!< Specifies the clock division.
N                                   This parameter can be a value of @ref TIM_ClockDivision */
N
N  uint32_t RepetitionCounter;  /*!< Specifies the repetition counter value. Each time the RCR down-counter
N                                    reaches zero, an update event is generated and counting restarts
N                                    from the RCR value (N).
N                                    This means in PWM mode that (N+1) corresponds to:
N                                        - the number of PWM periods in edge-aligned mode
N                                        - the number of half PWM period in center-aligned mode
N                                     This parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFF. 
N                                     @note This parameter is valid only for TIM1 and TIM8. */
N} TIM_Base_InitTypeDef;
N
N/** 
N  * @brief  TIM Output Compare Configuration Structure definition  
N  */
N
Ntypedef struct
N{
N  uint32_t OCMode;        /*!< Specifies the TIM mode.
N                               This parameter can be a value of @ref TIMEx_Output_Compare_and_PWM_modes */
N
N  uint32_t Pulse;         /*!< Specifies the pulse value to be loaded into the Capture Compare Register. 
N                               This parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF */
N
N  uint32_t OCPolarity;    /*!< Specifies the output polarity.
N                               This parameter can be a value of @ref TIM_Output_Compare_Polarity */
N
N  uint32_t OCNPolarity;   /*!< Specifies the complementary output polarity.
N                               This parameter can be a value of @ref TIM_Output_Compare_N_Polarity
N                               @note This parameter is valid only for TIM1 and TIM8. */
N  
N  uint32_t OCFastMode;   /*!< Specifies the Fast mode state.
N                               This parameter can be a value of @ref TIM_Output_Fast_State
N                               @note This parameter is valid only in PWM1 and PWM2 mode. */
N
N
N  uint32_t OCIdleState;   /*!< Specifies the TIM Output Compare pin state during Idle state.
N                               This parameter can be a value of @ref TIM_Output_Compare_Idle_State
N                               @note This parameter is valid only for TIM1 and TIM8. */
N
N  uint32_t OCNIdleState;  /*!< Specifies the TIM Output Compare pin state during Idle state.
N                               This parameter can be a value of @ref TIM_Output_Compare_N_Idle_State
N                               @note This parameter is valid only for TIM1 and TIM8. */
N} TIM_OC_InitTypeDef;  
N
N/** 
N  * @brief  TIM One Pulse Mode Configuration Structure definition  
N  */
Ntypedef struct
N{
N  uint32_t OCMode;        /*!< Specifies the TIM mode.
N                               This parameter can be a value of @ref TIMEx_Output_Compare_and_PWM_modes */
N
N  uint32_t Pulse;         /*!< Specifies the pulse value to be loaded into the Capture Compare Register. 
N                               This parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF */
N
N  uint32_t OCPolarity;    /*!< Specifies the output polarity.
N                               This parameter can be a value of @ref TIM_Output_Compare_Polarity */
N
N  uint32_t OCNPolarity;   /*!< Specifies the complementary output polarity.
N                               This parameter can be a value of @ref TIM_Output_Compare_N_Polarity
N                               @note This parameter is valid only for TIM1 and TIM8. */
N
N  uint32_t OCIdleState;   /*!< Specifies the TIM Output Compare pin state during Idle state.
N                               This parameter can be a value of @ref TIM_Output_Compare_Idle_State
N                               @note This parameter is valid only for TIM1 and TIM8. */
N
N  uint32_t OCNIdleState;  /*!< Specifies the TIM Output Compare pin state during Idle state.
N                               This parameter can be a value of @ref TIM_Output_Compare_N_Idle_State
N                               @note This parameter is valid only for TIM1 and TIM8. */
N
N  uint32_t ICPolarity;    /*!< Specifies the active edge of the input signal.
N                               This parameter can be a value of @ref TIM_Input_Capture_Polarity */
N
N  uint32_t ICSelection;   /*!< Specifies the input.
N                              This parameter can be a value of @ref TIM_Input_Capture_Selection */
N
N  uint32_t ICFilter;      /*!< Specifies the input capture filter.
N                              This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF */  
N} TIM_OnePulse_InitTypeDef;  
N
N
N/** 
N  * @brief  TIM Input Capture Configuration Structure definition  
N  */
N
Ntypedef struct
N{
N  uint32_t  ICPolarity;   /*!< Specifies the active edge of the input signal.
N                               This parameter can be a value of @ref TIM_Input_Capture_Polarity */
N
N  uint32_t ICSelection;  /*!< Specifies the input.
N                              This parameter can be a value of @ref TIM_Input_Capture_Selection */
N
N  uint32_t ICPrescaler;  /*!< Specifies the Input Capture Prescaler.
N                              This parameter can be a value of @ref TIM_Input_Capture_Prescaler */
N
N  uint32_t ICFilter;     /*!< Specifies the input capture filter.
N                              This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF */
N} TIM_IC_InitTypeDef;
N
N/** 
N  * @brief  TIM Encoder Configuration Structure definition  
N  */
N
Ntypedef struct
N{
N  uint32_t EncoderMode;   /*!< Specifies the active edge of the input signal.
N                               This parameter can be a value of @ref TIM_Encoder_Mode */
N                                  
N  uint32_t IC1Polarity;   /*!< Specifies the active edge of the input signal.
N                               This parameter can be a value of @ref TIM_Input_Capture_Polarity */
N
N  uint32_t IC1Selection;  /*!< Specifies the input.
N                               This parameter can be a value of @ref TIM_Input_Capture_Selection */
N
N  uint32_t IC1Prescaler;  /*!< Specifies the Input Capture Prescaler.
N                               This parameter can be a value of @ref TIM_Input_Capture_Prescaler */
N
N  uint32_t IC1Filter;     /*!< Specifies the input capture filter.
N                               This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF */
N                                  
N  uint32_t IC2Polarity;   /*!< Specifies the active edge of the input signal.
N                               This parameter can be a value of @ref TIM_Input_Capture_Polarity */
N
N  uint32_t IC2Selection;  /*!< Specifies the input.
N                              This parameter can be a value of @ref TIM_Input_Capture_Selection */
N
N  uint32_t IC2Prescaler;  /*!< Specifies the Input Capture Prescaler.
N                               This parameter can be a value of @ref TIM_Input_Capture_Prescaler */
N
N  uint32_t IC2Filter;     /*!< Specifies the input capture filter.
N                               This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF */
N} TIM_Encoder_InitTypeDef;
N
N/** 
N  * @brief  Clock Configuration Handle Structure definition  
N  */ 
Ntypedef struct
N{
N  uint32_t ClockSource;     /*!< TIM clock sources. 
N                                 This parameter can be a value of @ref TIM_Clock_Source */ 
N  uint32_t ClockPolarity;   /*!< TIM clock polarity. 
N                                 This parameter can be a value of @ref TIM_Clock_Polarity */
N  uint32_t ClockPrescaler;  /*!< TIM clock prescaler. 
N                                 This parameter can be a value of @ref TIM_Clock_Prescaler */
N  uint32_t ClockFilter;    /*!< TIM clock filter. 
N                                This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF */
N}TIM_ClockConfigTypeDef;
N
N/** 
N  * @brief  Clear Input Configuration Handle Structure definition  
N  */ 
Ntypedef struct
N{ 
N  uint32_t ClearInputState;      /*!< TIM clear Input state. 
N                                      This parameter can be ENABLE or DISABLE */  
N  uint32_t ClearInputSource;     /*!< TIM clear Input sources. 
N                                      This parameter can be a value of @ref TIMEx_ClearInput_Source */ 
N  uint32_t ClearInputPolarity;   /*!< TIM Clear Input polarity. 
N                                      This parameter can be a value of @ref TIM_ClearInput_Polarity */
N  uint32_t ClearInputPrescaler;  /*!< TIM Clear Input prescaler. 
N                                      This parameter can be a value of @ref TIM_ClearInput_Prescaler */
N  uint32_t ClearInputFilter;    /*!< TIM Clear Input filter. 
N                                     This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF */
N}TIM_ClearInputConfigTypeDef;
N
N/** 
N  * @brief  TIM Slave configuration Structure definition  
N  */ 
Ntypedef struct {
N  uint32_t  SlaveMode;         /*!< Slave mode selection 
N                                  This parameter can be a value of @ref TIMEx_Slave_Mode */ 
N  uint32_t  InputTrigger;      /*!< Input Trigger source 
N                                  This parameter can be a value of @ref TIM_Trigger_Selection */
N  uint32_t  TriggerPolarity;   /*!< Input Trigger polarity 
N                                  This parameter can be a value of @ref TIM_Trigger_Polarity */
N  uint32_t  TriggerPrescaler;  /*!< Input trigger prescaler 
N                                  This parameter can be a value of @ref TIM_Trigger_Prescaler */
N  uint32_t  TriggerFilter;     /*!< Input trigger filter 
N                                  This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF */  
N
N}TIM_SlaveConfigTypeDef;
N
N/** 
N  * @brief  HAL State structures definition  
N  */ 
Ntypedef enum
N{
N  HAL_TIM_STATE_RESET             = 0x00U,    /*!< Peripheral not yet initialized or disabled  */
N  HAL_TIM_STATE_READY             = 0x01U,    /*!< Peripheral Initialized and ready for use    */
N  HAL_TIM_STATE_BUSY              = 0x02U,    /*!< An internal process is ongoing              */
N  HAL_TIM_STATE_TIMEOUT           = 0x03U,    /*!< Timeout state                               */
N  HAL_TIM_STATE_ERROR             = 0x04U     /*!< Reception process is ongoing                */
N}HAL_TIM_StateTypeDef;
N
N/** 
N  * @brief  HAL Active channel structures definition  
N  */ 
Ntypedef enum
N{
N  HAL_TIM_ACTIVE_CHANNEL_1        = 0x01U,    /*!< The active channel is 1     */
N  HAL_TIM_ACTIVE_CHANNEL_2        = 0x02U,    /*!< The active channel is 2     */
N  HAL_TIM_ACTIVE_CHANNEL_3        = 0x04U,    /*!< The active channel is 3     */
N  HAL_TIM_ACTIVE_CHANNEL_4        = 0x08U,    /*!< The active channel is 4     */
N  HAL_TIM_ACTIVE_CHANNEL_CLEARED  = 0x00U     /*!< All active channels cleared */
N}HAL_TIM_ActiveChannel;
N
N/** 
N  * @brief  TIM Time Base Handle Structure definition  
N  */ 
Ntypedef struct
N{
N  TIM_TypeDef                 *Instance;     /*!< Register base address             */
N  TIM_Base_InitTypeDef        Init;          /*!< TIM Time Base required parameters */
N  HAL_TIM_ActiveChannel       Channel;       /*!< Active channel                    */
N  DMA_HandleTypeDef           *hdma[7];      /*!< DMA Handlers array
N                                             This array is accessed by a @ref DMA_Handle_index */
N  HAL_LockTypeDef             Lock;          /*!< Locking object                    */
N  __IO HAL_TIM_StateTypeDef   State;         /*!< TIM operation state               */
X  volatile HAL_TIM_StateTypeDef   State;          
N}TIM_HandleTypeDef;
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup TIM_Exported_Constants  TIM Exported Constants
N  * @{
N  */
N
N/** @defgroup TIM_Input_Channel_Polarity TIM Input Channel Polarity
N  * @{
N  */
N#define  TIM_INPUTCHANNELPOLARITY_RISING      ((uint32_t)0x00000000U)            /*!< Polarity for TIx source */
N#define  TIM_INPUTCHANNELPOLARITY_FALLING     (TIM_CCER_CC1P)                   /*!< Polarity for TIx source */
N#define  TIM_INPUTCHANNELPOLARITY_BOTHEDGE    (TIM_CCER_CC1P | TIM_CCER_CC1NP)  /*!< Polarity for TIx source */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_ETR_Polarity  TIM ETR Polarity
N  * @{
N  */
N#define TIM_ETRPOLARITY_INVERTED              (TIM_SMCR_ETP)                    /*!< Polarity for ETR source */
N#define TIM_ETRPOLARITY_NONINVERTED           ((uint32_t)0x0000U)                /*!< Polarity for ETR source */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_ETR_Prescaler  TIM ETR Prescaler
N  * @{
N  */
N#define TIM_ETRPRESCALER_DIV1                 ((uint32_t)0x0000U)                /*!< No prescaler is used */
N#define TIM_ETRPRESCALER_DIV2                 (TIM_SMCR_ETPS_0)                 /*!< ETR input source is divided by 2 */
N#define TIM_ETRPRESCALER_DIV4                 (TIM_SMCR_ETPS_1)                 /*!< ETR input source is divided by 4 */
N#define TIM_ETRPRESCALER_DIV8                 (TIM_SMCR_ETPS)                   /*!< ETR input source is divided by 8 */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Counter_Mode  TIM Counter Mode
N  * @{
N  */
N#define TIM_COUNTERMODE_UP                 ((uint32_t)0x0000U)
N#define TIM_COUNTERMODE_DOWN               TIM_CR1_DIR
N#define TIM_COUNTERMODE_CENTERALIGNED1     TIM_CR1_CMS_0
N#define TIM_COUNTERMODE_CENTERALIGNED2     TIM_CR1_CMS_1
N#define TIM_COUNTERMODE_CENTERALIGNED3     TIM_CR1_CMS
N/**
N  * @}
N  */
N
N/** @defgroup TIM_ClockDivision TIM Clock Division
N  * @{
N  */
N#define TIM_CLOCKDIVISION_DIV1                       ((uint32_t)0x0000U)
N#define TIM_CLOCKDIVISION_DIV2                       (TIM_CR1_CKD_0)
N#define TIM_CLOCKDIVISION_DIV4                       (TIM_CR1_CKD_1)
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Output_Compare_State TIM Output Compare State
N  * @{
N  */
N#define TIM_OUTPUTSTATE_DISABLE            ((uint32_t)0x0000U)
N#define TIM_OUTPUTSTATE_ENABLE             (TIM_CCER_CC1E)
N
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Output_Fast_State  TIM Output Fast State 
N  * @{
N  */
N#define TIM_OCFAST_DISABLE                ((uint32_t)0x0000U)
N#define TIM_OCFAST_ENABLE                 (TIM_CCMR1_OC1FE)
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Output_Compare_N_State TIM Complementary Output Compare State
N  * @{
N  */
N#define TIM_OUTPUTNSTATE_DISABLE            ((uint32_t)0x0000U)
N#define TIM_OUTPUTNSTATE_ENABLE             (TIM_CCER_CC1NE)
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_Polarity TIM Output Compare Polarity 
N  * @{
N  */
N#define TIM_OCPOLARITY_HIGH                ((uint32_t)0x0000U)
N#define TIM_OCPOLARITY_LOW                 (TIM_CCER_CC1P)
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Output_Compare_N_Polarity TIM Complementary Output Compare Polarity
N  * @{
N  */
N#define TIM_OCNPOLARITY_HIGH               ((uint32_t)0x0000U)
N#define TIM_OCNPOLARITY_LOW                (TIM_CCER_CC1NP)
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Output_Compare_Idle_State  TIM Output Compare Idle State
N  * @{
N  */
N#define TIM_OCIDLESTATE_SET                (TIM_CR2_OIS1)
N#define TIM_OCIDLESTATE_RESET              ((uint32_t)0x0000U)
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_N_Idle_State  TIM Output Compare N Idle State
N  * @{
N  */
N#define TIM_OCNIDLESTATE_SET               (TIM_CR2_OIS1N)
N#define TIM_OCNIDLESTATE_RESET             ((uint32_t)0x0000U)
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Input_Capture_Polarity  TIM Input Capture Polarity 
N  * @{
N  */
N#define  TIM_ICPOLARITY_RISING             TIM_INPUTCHANNELPOLARITY_RISING
N#define  TIM_ICPOLARITY_FALLING            TIM_INPUTCHANNELPOLARITY_FALLING
N#define  TIM_ICPOLARITY_BOTHEDGE           TIM_INPUTCHANNELPOLARITY_BOTHEDGE
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Input_Capture_Selection  TIM Input Capture Selection
N  * @{
N  */
N#define TIM_ICSELECTION_DIRECTTI           (TIM_CCMR1_CC1S_0)   /*!< TIM Input 1, 2, 3 or 4 is selected to be 
N                                                                     connected to IC1, IC2, IC3 or IC4, respectively */
N#define TIM_ICSELECTION_INDIRECTTI         (TIM_CCMR1_CC1S_1)   /*!< TIM Input 1, 2, 3 or 4 is selected to be
N                                                                     connected to IC2, IC1, IC4 or IC3, respectively */
N#define TIM_ICSELECTION_TRC                (TIM_CCMR1_CC1S)     /*!< TIM Input 1, 2, 3 or 4 is selected to be connected to TRC */
N
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Input_Capture_Prescaler  TIM Input Capture Prescaler
N  * @{
N  */
N#define TIM_ICPSC_DIV1                     ((uint32_t)0x0000U)       /*!< Capture performed each time an edge is detected on the capture input */
N#define TIM_ICPSC_DIV2                     (TIM_CCMR1_IC1PSC_0)     /*!< Capture performed once every 2 events */
N#define TIM_ICPSC_DIV4                     (TIM_CCMR1_IC1PSC_1)     /*!< Capture performed once every 4 events */
N#define TIM_ICPSC_DIV8                     (TIM_CCMR1_IC1PSC)       /*!< Capture performed once every 8 events */
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_One_Pulse_Mode TIM One Pulse Mode
N  * @{
N  */
N#define TIM_OPMODE_SINGLE                  (TIM_CR1_OPM)
N#define TIM_OPMODE_REPETITIVE              ((uint32_t)0x0000U)
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Encoder_Mode TIM Encoder Mode
N  * @{
N  */
N#define TIM_ENCODERMODE_TI1                (TIM_SMCR_SMS_0)
N#define TIM_ENCODERMODE_TI2                (TIM_SMCR_SMS_1)
N#define TIM_ENCODERMODE_TI12               (TIM_SMCR_SMS_1 | TIM_SMCR_SMS_0)
N
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Interrupt_definition  TIM Interrupt definition
N  * @{
N  */ 
N#define TIM_IT_UPDATE           (TIM_DIER_UIE)
N#define TIM_IT_CC1              (TIM_DIER_CC1IE)
N#define TIM_IT_CC2              (TIM_DIER_CC2IE)
N#define TIM_IT_CC3              (TIM_DIER_CC3IE)
N#define TIM_IT_CC4              (TIM_DIER_CC4IE)
N#define TIM_IT_COM              (TIM_DIER_COMIE)
N#define TIM_IT_TRIGGER          (TIM_DIER_TIE)
N#define TIM_IT_BREAK            (TIM_DIER_BIE)
N/**
N  * @}
N  */
N  
N/** @defgroup TIM_Commutation_Source  TIM Commutation Source 
N  * @{
N  */  
N#define TIM_COMMUTATION_TRGI              (TIM_CR2_CCUS)
N#define TIM_COMMUTATION_SOFTWARE          ((uint32_t)0x0000U)
N/**
N  * @}
N  */
N
N/** @defgroup TIM_DMA_sources  TIM DMA sources
N  * @{
N  */
N#define TIM_DMA_UPDATE                     (TIM_DIER_UDE)
N#define TIM_DMA_CC1                        (TIM_DIER_CC1DE)
N#define TIM_DMA_CC2                        (TIM_DIER_CC2DE)
N#define TIM_DMA_CC3                        (TIM_DIER_CC3DE)
N#define TIM_DMA_CC4                        (TIM_DIER_CC4DE)
N#define TIM_DMA_COM                        (TIM_DIER_COMDE)
N#define TIM_DMA_TRIGGER                    (TIM_DIER_TDE)
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Event_Source  TIM Event Source 
N  * @{
N  */
N#define TIM_EVENTSOURCE_UPDATE              TIM_EGR_UG  
N#define TIM_EVENTSOURCE_CC1                 TIM_EGR_CC1G
N#define TIM_EVENTSOURCE_CC2                 TIM_EGR_CC2G
N#define TIM_EVENTSOURCE_CC3                 TIM_EGR_CC3G
N#define TIM_EVENTSOURCE_CC4                 TIM_EGR_CC4G
N#define TIM_EVENTSOURCE_COM                 TIM_EGR_COMG
N#define TIM_EVENTSOURCE_TRIGGER             TIM_EGR_TG  
N#define TIM_EVENTSOURCE_BREAK               TIM_EGR_BG 
N#define TIM_EVENTSOURCE_BREAK2              TIM_EGR_B2G   
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Flag_definition  TIM Flag definition
N  * @{
N  */
N#define TIM_FLAG_UPDATE                    (TIM_SR_UIF)
N#define TIM_FLAG_CC1                       (TIM_SR_CC1IF)
N#define TIM_FLAG_CC2                       (TIM_SR_CC2IF)
N#define TIM_FLAG_CC3                       (TIM_SR_CC3IF)
N#define TIM_FLAG_CC4                       (TIM_SR_CC4IF)
N#define TIM_FLAG_COM                       (TIM_SR_COMIF)
N#define TIM_FLAG_TRIGGER                   (TIM_SR_TIF)
N#define TIM_FLAG_BREAK                     (TIM_SR_BIF)
N#define TIM_FLAG_BREAK2                    (TIM_SR_B2IF)
N#define TIM_FLAG_CC1OF                     (TIM_SR_CC1OF)
N#define TIM_FLAG_CC2OF                     (TIM_SR_CC2OF)
N#define TIM_FLAG_CC3OF                     (TIM_SR_CC3OF)
N#define TIM_FLAG_CC4OF                     (TIM_SR_CC4OF)
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Clock_Source  TIM Clock Source
N  * @{
N  */
N#define	TIM_CLOCKSOURCE_ETRMODE2    (TIM_SMCR_ETPS_1) 
N#define	TIM_CLOCKSOURCE_INTERNAL    (TIM_SMCR_ETPS_0) 
N#define	TIM_CLOCKSOURCE_ITR0        ((uint32_t)0x0000U)
N#define	TIM_CLOCKSOURCE_ITR1        (TIM_SMCR_TS_0)
N#define	TIM_CLOCKSOURCE_ITR2        (TIM_SMCR_TS_1)
N#define	TIM_CLOCKSOURCE_ITR3        (TIM_SMCR_TS_0 | TIM_SMCR_TS_1)
N#define	TIM_CLOCKSOURCE_TI1ED       (TIM_SMCR_TS_2)
N#define	TIM_CLOCKSOURCE_TI1         (TIM_SMCR_TS_0 | TIM_SMCR_TS_2)
N#define	TIM_CLOCKSOURCE_TI2         (TIM_SMCR_TS_1 | TIM_SMCR_TS_2)
N#define	TIM_CLOCKSOURCE_ETRMODE1    (TIM_SMCR_TS)
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Clock_Polarity  TIM Clock Polarity
N  * @{
N  */
N#define TIM_CLOCKPOLARITY_INVERTED           TIM_ETRPOLARITY_INVERTED          /*!< Polarity for ETRx clock sources */ 
N#define TIM_CLOCKPOLARITY_NONINVERTED        TIM_ETRPOLARITY_NONINVERTED       /*!< Polarity for ETRx clock sources */ 
N#define TIM_CLOCKPOLARITY_RISING             TIM_INPUTCHANNELPOLARITY_RISING   /*!< Polarity for TIx clock sources */ 
N#define TIM_CLOCKPOLARITY_FALLING            TIM_INPUTCHANNELPOLARITY_FALLING   /*!< Polarity for TIx clock sources */ 
N#define TIM_CLOCKPOLARITY_BOTHEDGE           TIM_INPUTCHANNELPOLARITY_BOTHEDGE  /*!< Polarity for TIx clock sources */ 
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Clock_Prescaler  TIM Clock Prescaler
N  * @{
N  */
N#define TIM_CLOCKPRESCALER_DIV1              TIM_ETRPRESCALER_DIV1     /*!< No prescaler is used */
N#define TIM_CLOCKPRESCALER_DIV2              TIM_ETRPRESCALER_DIV2     /*!< Prescaler for External ETR Clock: Capture performed once every 2 events. */
N#define TIM_CLOCKPRESCALER_DIV4              TIM_ETRPRESCALER_DIV4     /*!< Prescaler for External ETR Clock: Capture performed once every 4 events. */
N#define TIM_CLOCKPRESCALER_DIV8              TIM_ETRPRESCALER_DIV8     /*!< Prescaler for External ETR Clock: Capture performed once every 8 events. */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_ClearInput_Polarity  TIM Clear Input Polarity
N  * @{
N  */
N#define TIM_CLEARINPUTPOLARITY_INVERTED           TIM_ETRPOLARITY_INVERTED                    /*!< Polarity for ETRx pin */ 
N#define TIM_CLEARINPUTPOLARITY_NONINVERTED        TIM_ETRPOLARITY_NONINVERTED                 /*!< Polarity for ETRx pin */ 
N/**
N  * @}
N  */
N
N/** @defgroup TIM_ClearInput_Prescaler TIM Clear Input Prescaler
N  * @{
N  */
N#define TIM_CLEARINPUTPRESCALER_DIV1                    TIM_ETRPRESCALER_DIV1      /*!< No prescaler is used */
N#define TIM_CLEARINPUTPRESCALER_DIV2                    TIM_ETRPRESCALER_DIV2      /*!< Prescaler for External ETR pin: Capture performed once every 2 events. */
N#define TIM_CLEARINPUTPRESCALER_DIV4                    TIM_ETRPRESCALER_DIV4      /*!< Prescaler for External ETR pin: Capture performed once every 4 events. */
N#define TIM_CLEARINPUTPRESCALER_DIV8                    TIM_ETRPRESCALER_DIV8        /*!< Prescaler for External ETR pin: Capture performed once every 8 events. */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_OSSR_Off_State_Selection_for_Run_mode_state TIM OSSR OffState Selection for Run mode state
N  * @{
N  */  
N#define TIM_OSSR_ENABLE 	      (TIM_BDTR_OSSR)
N#define TIM_OSSR_DISABLE          ((uint32_t)0x0000U)
N/**
N  * @}
N  */
N  
N/** @defgroup TIM_OSSI_Off_State_Selection_for_Idle_mode_state TIM OSSI OffState Selection for Idle mode state
N  * @{
N  */
N#define TIM_OSSI_ENABLE	 	    (TIM_BDTR_OSSI)
N#define TIM_OSSI_DISABLE            ((uint32_t)0x0000U)
N/**
N  * @}
N  */
N  
N/** @defgroup TIM_Lock_level  TIM Lock level
N  * @{
N  */
N#define TIM_LOCKLEVEL_OFF	   ((uint32_t)0x0000U)
N#define TIM_LOCKLEVEL_1            (TIM_BDTR_LOCK_0)
N#define TIM_LOCKLEVEL_2            (TIM_BDTR_LOCK_1)
N#define TIM_LOCKLEVEL_3            (TIM_BDTR_LOCK)
N/**
N  * @}
N  */  
N/** @defgroup TIM_Break_Input_enable_disable  TIM Break Input State
N  * @{
N  */                         
N#define TIM_BREAK_ENABLE          (TIM_BDTR_BKE)
N#define TIM_BREAK_DISABLE         ((uint32_t)0x0000U)
N/**
N  * @}
N  */
N  
N/** @defgroup TIM_Break_Polarity  TIM Break Polarity 
N  * @{
N  */
N#define TIM_BREAKPOLARITY_LOW        ((uint32_t)0x0000U)
N#define TIM_BREAKPOLARITY_HIGH       (TIM_BDTR_BKP)
N/**
N  * @}
N  */
N  
N/** @defgroup TIM_AOE_Bit_Set_Reset  TIM AOE Bit State
N  * @{
N  */
N#define TIM_AUTOMATICOUTPUT_ENABLE           (TIM_BDTR_AOE)
N#define	TIM_AUTOMATICOUTPUT_DISABLE          ((uint32_t)0x0000U)
N/**
N  * @}
N  */  
N  
N/** @defgroup TIM_Master_Mode_Selection TIM Master Mode Selection
N  * @{
N  */  
N#define	TIM_TRGO_RESET            ((uint32_t)0x0000U)             
N#define	TIM_TRGO_ENABLE           (TIM_CR2_MMS_0)           
N#define	TIM_TRGO_UPDATE           (TIM_CR2_MMS_1)             
N#define	TIM_TRGO_OC1              ((TIM_CR2_MMS_1 | TIM_CR2_MMS_0))    
N#define	TIM_TRGO_OC1REF           (TIM_CR2_MMS_2)           
N#define	TIM_TRGO_OC2REF           ((TIM_CR2_MMS_2 | TIM_CR2_MMS_0))          
N#define	TIM_TRGO_OC3REF           ((TIM_CR2_MMS_2 | TIM_CR2_MMS_1))           
N#define	TIM_TRGO_OC4REF           ((TIM_CR2_MMS_2 | TIM_CR2_MMS_1 | TIM_CR2_MMS_0))   
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Master_Slave_Mode  TIM Master Slave Mode
N  * @{
N  */
N#define TIM_MASTERSLAVEMODE_ENABLE          ((uint32_t)0x0080)
N#define TIM_MASTERSLAVEMODE_DISABLE         ((uint32_t)0x0000U)
N/**
N  * @}
N  */ 
N  
N/** @defgroup TIM_Trigger_Selection  TIM Trigger Selection
N  * @{
N  */
N#define TIM_TS_ITR0                        ((uint32_t)0x0000U)
N#define TIM_TS_ITR1                        ((uint32_t)0x0010U)
N#define TIM_TS_ITR2                        ((uint32_t)0x0020U)
N#define TIM_TS_ITR3                        ((uint32_t)0x0030U)
N#define TIM_TS_TI1F_ED                     ((uint32_t)0x0040U)
N#define TIM_TS_TI1FP1                      ((uint32_t)0x0050U)
N#define TIM_TS_TI2FP2                      ((uint32_t)0x0060U)
N#define TIM_TS_ETRF                        ((uint32_t)0x0070U)
N#define TIM_TS_NONE                        ((uint32_t)0xFFFFU)
N/**
N  * @}
N  */  
N
N/** @defgroup TIM_Trigger_Polarity TIM Trigger Polarity
N  * @{
N  */
N#define TIM_TRIGGERPOLARITY_INVERTED           TIM_ETRPOLARITY_INVERTED      /*!< Polarity for ETRx trigger sources */ 
N#define TIM_TRIGGERPOLARITY_NONINVERTED        TIM_ETRPOLARITY_NONINVERTED   /*!< Polarity for ETRx trigger sources */ 
N#define TIM_TRIGGERPOLARITY_RISING             TIM_INPUTCHANNELPOLARITY_RISING        /*!< Polarity for TIxFPx or TI1_ED trigger sources */ 
N#define TIM_TRIGGERPOLARITY_FALLING            TIM_INPUTCHANNELPOLARITY_FALLING       /*!< Polarity for TIxFPx or TI1_ED trigger sources */ 
N#define TIM_TRIGGERPOLARITY_BOTHEDGE           TIM_INPUTCHANNELPOLARITY_BOTHEDGE      /*!< Polarity for TIxFPx or TI1_ED trigger sources */ 
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Trigger_Prescaler TIM Trigger Prescaler
N  * @{
N  */
N#define TIM_TRIGGERPRESCALER_DIV1             TIM_ETRPRESCALER_DIV1     /*!< No prescaler is used */
N#define TIM_TRIGGERPRESCALER_DIV2             TIM_ETRPRESCALER_DIV2     /*!< Prescaler for External ETR Trigger: Capture performed once every 2 events. */
N#define TIM_TRIGGERPRESCALER_DIV4             TIM_ETRPRESCALER_DIV4     /*!< Prescaler for External ETR Trigger: Capture performed once every 4 events. */
N#define TIM_TRIGGERPRESCALER_DIV8             TIM_ETRPRESCALER_DIV8     /*!< Prescaler for External ETR Trigger: Capture performed once every 8 events. */
N/**
N  * @}
N  */
N
N
N/** @defgroup TIM_TI1_Selection TIM TI1 Selection
N  * @{
N  */
N#define TIM_TI1SELECTION_CH1                ((uint32_t)0x0000U)
N#define TIM_TI1SELECTION_XORCOMBINATION     (TIM_CR2_TI1S)
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_DMA_Base_address  TIM DMA Base address
N  * @{
N  */
N#define TIM_DMABASE_CR1                    (0x00000000U)
N#define TIM_DMABASE_CR2                    (0x00000001U)
N#define TIM_DMABASE_SMCR                   (0x00000002U)
N#define TIM_DMABASE_DIER                   (0x00000003U)
N#define TIM_DMABASE_SR                     (0x00000004U)
N#define TIM_DMABASE_EGR                    (0x00000005U)
N#define TIM_DMABASE_CCMR1                  (0x00000006U)
N#define TIM_DMABASE_CCMR2                  (0x00000007U)
N#define TIM_DMABASE_CCER                   (0x00000008U)
N#define TIM_DMABASE_CNT                    (0x00000009U)
N#define TIM_DMABASE_PSC                    (0x0000000AU)
N#define TIM_DMABASE_ARR                    (0x0000000BU)
N#define TIM_DMABASE_RCR                    (0x0000000CU)
N#define TIM_DMABASE_CCR1                   (0x0000000DU)
N#define TIM_DMABASE_CCR2                   (0x0000000EU)
N#define TIM_DMABASE_CCR3                   (0x0000000FU)
N#define TIM_DMABASE_CCR4                   (0x00000010U)
N#define TIM_DMABASE_BDTR                   (0x00000011U)
N#define TIM_DMABASE_DCR                    (0x00000012U)
N#define TIM_DMABASE_OR                     (0x00000013U)
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_DMA_Burst_Length  TIM DMA Burst Length 
N  * @{
N  */
N#define TIM_DMABURSTLENGTH_1TRANSFER           (0x00000000U)
N#define TIM_DMABURSTLENGTH_2TRANSFERS          (0x00000100U)
N#define TIM_DMABURSTLENGTH_3TRANSFERS          (0x00000200U)
N#define TIM_DMABURSTLENGTH_4TRANSFERS          (0x00000300U)
N#define TIM_DMABURSTLENGTH_5TRANSFERS          (0x00000400U)
N#define TIM_DMABURSTLENGTH_6TRANSFERS          (0x00000500U)
N#define TIM_DMABURSTLENGTH_7TRANSFERS          (0x00000600U)
N#define TIM_DMABURSTLENGTH_8TRANSFERS          (0x00000700U)
N#define TIM_DMABURSTLENGTH_9TRANSFERS          (0x00000800U)
N#define TIM_DMABURSTLENGTH_10TRANSFERS         (0x00000900U)
N#define TIM_DMABURSTLENGTH_11TRANSFERS         (0x00000A00U)
N#define TIM_DMABURSTLENGTH_12TRANSFERS         (0x00000B00U)
N#define TIM_DMABURSTLENGTH_13TRANSFERS         (0x00000C00U)
N#define TIM_DMABURSTLENGTH_14TRANSFERS         (0x00000D00U)
N#define TIM_DMABURSTLENGTH_15TRANSFERS         (0x00000E00U)
N#define TIM_DMABURSTLENGTH_16TRANSFERS         (0x00000F00U)
N#define TIM_DMABURSTLENGTH_17TRANSFERS         (0x00001000U)
N#define TIM_DMABURSTLENGTH_18TRANSFERS         (0x00001100U)
N/**
N  * @}
N  */
N
N/** @defgroup DMA_Handle_index  DMA Handle index
N  * @{
N  */
N#define TIM_DMA_ID_UPDATE                ((uint16_t) 0x0U)       /*!< Index of the DMA handle used for Update DMA requests */
N#define TIM_DMA_ID_CC1                   ((uint16_t) 0x1U)       /*!< Index of the DMA handle used for Capture/Compare 1 DMA requests */
N#define TIM_DMA_ID_CC2                   ((uint16_t) 0x2U)       /*!< Index of the DMA handle used for Capture/Compare 2 DMA requests */
N#define TIM_DMA_ID_CC3                   ((uint16_t) 0x3U)       /*!< Index of the DMA handle used for Capture/Compare 3 DMA requests */
N#define TIM_DMA_ID_CC4                   ((uint16_t) 0x4U)       /*!< Index of the DMA handle used for Capture/Compare 4 DMA requests */
N#define TIM_DMA_ID_COMMUTATION           ((uint16_t) 0x5U)       /*!< Index of the DMA handle used for Commutation DMA requests */
N#define TIM_DMA_ID_TRIGGER               ((uint16_t) 0x6U)       /*!< Index of the DMA handle used for Trigger DMA requests */
N/**
N  * @}
N  */ 
N
N/** @defgroup Channel_CC_State  Channel CC State
N  * @{
N  */
N#define TIM_CCx_ENABLE                   ((uint32_t)0x0001U)
N#define TIM_CCx_DISABLE                  ((uint32_t)0x0000U)
N#define TIM_CCxN_ENABLE                  ((uint32_t)0x0004U)
N#define TIM_CCxN_DISABLE                 ((uint32_t)0x0000U)
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */   
N  
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup TIM_Exported_Macros TIM Exported Macros
N  * @{
N  */
N/** @brief Reset TIM handle state
N  * @param  __HANDLE__: TIM handle
N  * @retval None
N  */
N#define __HAL_TIM_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_TIM_STATE_RESET)
N
N/**
N  * @brief  Enable the TIM peripheral.
N  * @param  __HANDLE__: TIM handle
N  * @retval None
N */
N#define __HAL_TIM_ENABLE(__HANDLE__)                 ((__HANDLE__)->Instance->CR1|=(TIM_CR1_CEN))
N
N/**
N  * @brief  Enable the TIM update source request.
N  * @param  __HANDLE__: TIM handle
N  * @retval None
N */
N#define __HAL_TIM_URS_ENABLE(__HANDLE__)             ((__HANDLE__)->Instance->CR1|=(TIM_CR1_URS))
N
N/**
N  * @brief  Enable the TIM main Output.
N  * @param  __HANDLE__: TIM handle
N  * @retval None
N  */
N#define __HAL_TIM_MOE_ENABLE(__HANDLE__)             ((__HANDLE__)->Instance->BDTR|=(TIM_BDTR_MOE))
N
N
N/* The counter of a timer instance is disabled only if all the CCx and CCxN
N   channels have been disabled */
N#define TIM_CCER_CCxE_MASK ((uint32_t)(TIM_CCER_CC1E | TIM_CCER_CC2E | TIM_CCER_CC3E | TIM_CCER_CC4E))
N#define TIM_CCER_CCxNE_MASK ((uint32_t)(TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE))
N
N/**
N  * @brief  Disable the TIM peripheral.
N  * @param  __HANDLE__: TIM handle
N  * @retval None
N  */
N#define __HAL_TIM_DISABLE(__HANDLE__) \
N                        do { \
N                          if (((__HANDLE__)->Instance->CCER & TIM_CCER_CCxE_MASK) == 0) \
N                          { \
N                            if(((__HANDLE__)->Instance->CCER & TIM_CCER_CCxNE_MASK) == 0) \
N                            { \
N                              (__HANDLE__)->Instance->CR1 &= ~(TIM_CR1_CEN); \
N                            } \
N                          } \
N                        } while(0)
X#define __HAL_TIM_DISABLE(__HANDLE__)                         do {                           if (((__HANDLE__)->Instance->CCER & TIM_CCER_CCxE_MASK) == 0)                           {                             if(((__HANDLE__)->Instance->CCER & TIM_CCER_CCxNE_MASK) == 0)                             {                               (__HANDLE__)->Instance->CR1 &= ~(TIM_CR1_CEN);                             }                           }                         } while(0)
N                        
N/**
N  * @brief  Disable the TIM update source request.
N  * @param  __HANDLE__: TIM handle
N  * @retval None
N */
N#define __HAL_TIM_URS_DISABLE(__HANDLE__)            ((__HANDLE__)->Instance->CR1&=~(TIM_CR1_URS))
N
N
N/* The Main Output of a timer instance is disabled only if all the CCx and CCxN
N   channels have been disabled */
N/**
N  * @brief  Disable the TIM main Output.
N  * @param  __HANDLE__: TIM handle
N  * @retval None
N  */
N#define __HAL_TIM_MOE_DISABLE(__HANDLE__) \
N                        do { \
N                          if (((__HANDLE__)->Instance->CCER & TIM_CCER_CCxE_MASK) == 0) \
N                          { \
N                            if(((__HANDLE__)->Instance->CCER & TIM_CCER_CCxNE_MASK) == 0) \
N                            { \
N                              (__HANDLE__)->Instance->BDTR &= ~(TIM_BDTR_MOE); \
N                            } \
N                          } \
N                        } while(0)
X#define __HAL_TIM_MOE_DISABLE(__HANDLE__)                         do {                           if (((__HANDLE__)->Instance->CCER & TIM_CCER_CCxE_MASK) == 0)                           {                             if(((__HANDLE__)->Instance->CCER & TIM_CCER_CCxNE_MASK) == 0)                             {                               (__HANDLE__)->Instance->BDTR &= ~(TIM_BDTR_MOE);                             }                           }                         } while(0)
N
N#define __HAL_TIM_ENABLE_IT(__HANDLE__, __INTERRUPT__)    ((__HANDLE__)->Instance->DIER |= (__INTERRUPT__))
N#define __HAL_TIM_ENABLE_DMA(__HANDLE__, __DMA__)         ((__HANDLE__)->Instance->DIER |= (__DMA__))
N#define __HAL_TIM_DISABLE_IT(__HANDLE__, __INTERRUPT__)   ((__HANDLE__)->Instance->DIER &= ~(__INTERRUPT__))
N#define __HAL_TIM_DISABLE_DMA(__HANDLE__, __DMA__)        ((__HANDLE__)->Instance->DIER &= ~(__DMA__))
N#define __HAL_TIM_GET_FLAG(__HANDLE__, __FLAG__)          (((__HANDLE__)->Instance->SR &(__FLAG__)) == (__FLAG__))
N#define __HAL_TIM_CLEAR_FLAG(__HANDLE__, __FLAG__)        ((__HANDLE__)->Instance->SR = ~(__FLAG__))
N
N#define __HAL_TIM_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) ((((__HANDLE__)->Instance->DIER & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)
N#define __HAL_TIM_CLEAR_IT(__HANDLE__, __INTERRUPT__)     ((__HANDLE__)->Instance->SR = ~(__INTERRUPT__))
N
N#define __HAL_TIM_IS_TIM_COUNTING_DOWN(__HANDLE__)            (((__HANDLE__)->Instance->CR1 &(TIM_CR1_DIR)) == (TIM_CR1_DIR))
N#define __HAL_TIM_SET_PRESCALER (__HANDLE__, __PRESC__)       ((__HANDLE__)->Instance->PSC = (__PRESC__))
N
N#define TIM_SET_ICPRESCALERVALUE(__HANDLE__, __CHANNEL__, __ICPSC__) \
N(((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 |= (__ICPSC__)) :\
N ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCMR1 |= ((__ICPSC__) << 8)) :\
N ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 |= (__ICPSC__)) :\
N ((__HANDLE__)->Instance->CCMR2 |= ((__ICPSC__) << 8)))
X#define TIM_SET_ICPRESCALERVALUE(__HANDLE__, __CHANNEL__, __ICPSC__) (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 |= (__ICPSC__)) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCMR1 |= ((__ICPSC__) << 8)) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 |= (__ICPSC__)) : ((__HANDLE__)->Instance->CCMR2 |= ((__ICPSC__) << 8)))
N
N#define TIM_RESET_ICPRESCALERVALUE(__HANDLE__, __CHANNEL__) \
N(((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 &= (uint16_t)~TIM_CCMR1_IC1PSC) :\
N ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCMR1 &= (uint16_t)~TIM_CCMR1_IC2PSC) :\
N ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 &= (uint16_t)~TIM_CCMR2_IC3PSC) :\
N ((__HANDLE__)->Instance->CCMR2 &= (uint16_t)~TIM_CCMR2_IC4PSC))
X#define TIM_RESET_ICPRESCALERVALUE(__HANDLE__, __CHANNEL__) (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 &= (uint16_t)~TIM_CCMR1_IC1PSC) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCMR1 &= (uint16_t)~TIM_CCMR1_IC2PSC) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 &= (uint16_t)~TIM_CCMR2_IC3PSC) : ((__HANDLE__)->Instance->CCMR2 &= (uint16_t)~TIM_CCMR2_IC4PSC))
N
N#define TIM_SET_CAPTUREPOLARITY(__HANDLE__, __CHANNEL__, __POLARITY__) \
N(((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCER |= (__POLARITY__)) :\
N ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCER |= ((__POLARITY__) << 4)) :\
N ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCER |= ((__POLARITY__) << 8)) :\
N ((__HANDLE__)->Instance->CCER |= (((__POLARITY__) << 12) & TIM_CCER_CC4P)))
X#define TIM_SET_CAPTUREPOLARITY(__HANDLE__, __CHANNEL__, __POLARITY__) (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCER |= (__POLARITY__)) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCER |= ((__POLARITY__) << 4)) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCER |= ((__POLARITY__) << 8)) : ((__HANDLE__)->Instance->CCER |= (((__POLARITY__) << 12) & TIM_CCER_CC4P)))
N
N#define TIM_RESET_CAPTUREPOLARITY(__HANDLE__, __CHANNEL__) \
N(((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCER &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP)) :\
N ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCER &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP)) :\
N ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCER &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP)) :\
N ((__HANDLE__)->Instance->CCER &= (uint16_t)~TIM_CCER_CC4P))
X#define TIM_RESET_CAPTUREPOLARITY(__HANDLE__, __CHANNEL__) (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCER &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP)) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCER &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP)) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCER &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP)) : ((__HANDLE__)->Instance->CCER &= (uint16_t)~TIM_CCER_CC4P))
N 
N/**
N  * @brief  Sets the TIM Counter Register value on runtime.
N  * @param  __HANDLE__: TIM handle.
N  * @param  __COUNTER__: specifies the Counter register new value.
N  * @retval None
N  */
N#define __HAL_TIM_SET_COUNTER(__HANDLE__, __COUNTER__) ((__HANDLE__)->Instance->CNT = (__COUNTER__))
N
N/**
N  * @brief  Gets the TIM Counter Register value on runtime.
N  * @param  __HANDLE__: TIM handle.
N  * @retval None
N  */
N#define __HAL_TIM_GET_COUNTER(__HANDLE__) ((__HANDLE__)->Instance->CNT)
N
N/**
N  * @brief  Sets the TIM Autoreload Register value on runtime without calling 
N  *         another time any Init function.
N  * @param  __HANDLE__: TIM handle.
N  * @param  __AUTORELOAD__: specifies the Counter register new value.
N  * @retval None
N  */
N#define __HAL_TIM_SET_AUTORELOAD(__HANDLE__, __AUTORELOAD__)                  \
N                        do{                                                  \
N                            (__HANDLE__)->Instance->ARR = (__AUTORELOAD__);  \
N                            (__HANDLE__)->Init.Period = (__AUTORELOAD__);    \
N                          } while(0)
X#define __HAL_TIM_SET_AUTORELOAD(__HANDLE__, __AUTORELOAD__)                                          do{                                                                              (__HANDLE__)->Instance->ARR = (__AUTORELOAD__);                              (__HANDLE__)->Init.Period = (__AUTORELOAD__);                              } while(0)
N/**
N  * @brief  Gets the TIM Autoreload Register value on runtime
N  * @param  __HANDLE__: TIM handle.
N  * @retval None
N  */
N#define __HAL_TIM_GET_AUTORELOAD(__HANDLE__) ((__HANDLE__)->Instance->ARR)
N
N/**
N  * @brief  Sets the TIM Clock Division value on runtime without calling 
N  *         another time any Init function. 
N  * @param  __HANDLE__: TIM handle.
N  * @param  __CKD__: specifies the clock division value.
N  *          This parameter can be one of the following value:
N  *            @arg TIM_CLOCKDIVISION_DIV1
N  *            @arg TIM_CLOCKDIVISION_DIV2
N  *            @arg TIM_CLOCKDIVISION_DIV4
N  * @retval None
N  */
N#define __HAL_TIM_SET_CLOCKDIVISION(__HANDLE__, __CKD__) \
N                        do{                                                             \
N                              (__HANDLE__)->Instance->CR1 &= (uint16_t)(~TIM_CR1_CKD);  \
N                              (__HANDLE__)->Instance->CR1 |= (__CKD__);                 \
N                              (__HANDLE__)->Init.ClockDivision = (__CKD__);             \
N                          } while(0)
X#define __HAL_TIM_SET_CLOCKDIVISION(__HANDLE__, __CKD__)                         do{                                                                                           (__HANDLE__)->Instance->CR1 &= (uint16_t)(~TIM_CR1_CKD);                                (__HANDLE__)->Instance->CR1 |= (__CKD__);                                               (__HANDLE__)->Init.ClockDivision = (__CKD__);                                       } while(0)
N/**
N  * @brief  Gets the TIM Clock Division value on runtime
N  * @param  __HANDLE__: TIM handle.
N  * @retval None
N  */
N#define __HAL_TIM_GET_CLOCKDIVISION(__HANDLE__) ((__HANDLE__)->Instance->CR1 & TIM_CR1_CKD)
N
N/**
N  * @brief  Sets the TIM Input Capture prescaler on runtime without calling 
N  *         another time HAL_TIM_IC_ConfigChannel() function.
N  * @param  __HANDLE__: TIM handle.
N  * @param  __CHANNEL__ : TIM Channels to be configured.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
N  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
N  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
N  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
N  * @param  __ICPSC__: specifies the Input Capture4 prescaler new value.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_ICPSC_DIV1: no prescaler
N  *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
N  *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
N  *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
N  * @retval None
N  */
N#define __HAL_TIM_SET_ICPRESCALER(__HANDLE__, __CHANNEL__, __ICPSC__) \
N                        do{                                                    \
N                              TIM_RESET_ICPRESCALERVALUE((__HANDLE__), (__CHANNEL__));  \
N                              TIM_SET_ICPRESCALERVALUE((__HANDLE__), (__CHANNEL__), (__ICPSC__)); \
N                          } while(0)
X#define __HAL_TIM_SET_ICPRESCALER(__HANDLE__, __CHANNEL__, __ICPSC__)                         do{                                                                                  TIM_RESET_ICPRESCALERVALUE((__HANDLE__), (__CHANNEL__));                                TIM_SET_ICPRESCALERVALUE((__HANDLE__), (__CHANNEL__), (__ICPSC__));                           } while(0)
N
N/**
N  * @brief  Gets the TIM Input Capture prescaler on runtime
N  * @param  __HANDLE__: TIM handle.
N  * @param  __CHANNEL__ : TIM Channels to be configured.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_CHANNEL_1: get input capture 1 prescaler value
N  *            @arg TIM_CHANNEL_2: get input capture 2 prescaler value
N  *            @arg TIM_CHANNEL_3: get input capture 3 prescaler value
N  *            @arg TIM_CHANNEL_4: get input capture 4 prescaler value
N  * @retval None
N  */
N#define __HAL_TIM_GET_ICPRESCALER(__HANDLE__, __CHANNEL__)  \
N  (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 & TIM_CCMR1_IC1PSC) :\
N   ((__CHANNEL__) == TIM_CHANNEL_2) ? (((__HANDLE__)->Instance->CCMR1 & TIM_CCMR1_IC2PSC) >> 8) :\
N   ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 & TIM_CCMR2_IC3PSC) :\
N   (((__HANDLE__)->Instance->CCMR2 & TIM_CCMR2_IC4PSC)) >> 8)
X#define __HAL_TIM_GET_ICPRESCALER(__HANDLE__, __CHANNEL__)    (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 & TIM_CCMR1_IC1PSC) :   ((__CHANNEL__) == TIM_CHANNEL_2) ? (((__HANDLE__)->Instance->CCMR1 & TIM_CCMR1_IC2PSC) >> 8) :   ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 & TIM_CCMR2_IC3PSC) :   (((__HANDLE__)->Instance->CCMR2 & TIM_CCMR2_IC4PSC)) >> 8)
N  
N/**
N  * @brief  Sets the TIM Capture x input polarity on runtime.
N  * @param  __HANDLE__: TIM handle.
N  * @param  __CHANNEL__: TIM Channels to be configured.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
N  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
N  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
N  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
N  * @param  __POLARITY__: Polarity for TIx source   
N  *            @arg TIM_INPUTCHANNELPOLARITY_RISING: Rising Edge
N  *            @arg TIM_INPUTCHANNELPOLARITY_FALLING: Falling Edge
N  *            @arg TIM_INPUTCHANNELPOLARITY_BOTHEDGE: Rising and Falling Edge
N  * @note  The polarity TIM_INPUTCHANNELPOLARITY_BOTHEDGE is not authorized  for TIM Channel 4.     
N  * @retval None
N  */
N#define __HAL_TIM_SET_CAPTUREPOLARITY(__HANDLE__, __CHANNEL__, __POLARITY__)                          \
N                       do{                                                                            \
N                           TIM_RESET_CAPTUREPOLARITY((__HANDLE__), (__CHANNEL__));               \
N                           TIM_SET_CAPTUREPOLARITY((__HANDLE__), (__CHANNEL__), (__POLARITY__)); \
N                         }while(0)
X#define __HAL_TIM_SET_CAPTUREPOLARITY(__HANDLE__, __CHANNEL__, __POLARITY__)                                                 do{                                                                                                       TIM_RESET_CAPTUREPOLARITY((__HANDLE__), (__CHANNEL__));                                          TIM_SET_CAPTUREPOLARITY((__HANDLE__), (__CHANNEL__), (__POLARITY__));                          }while(0)
N											 
N/**
N  * @}
N  */
N
N/* Include TIM HAL Extension module */
N#include "stm32f7xx_hal_tim_ex.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_tim_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_tim_ex.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of TIM HAL Extension module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_TIM_EX_H
N#define __STM32F7xx_HAL_TIM_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup TIMEx
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/ 
N/** @defgroup TIMEx_Exported_Types TIM Exported Types
N  * @{
N  */
N  
N/** 
N  * @brief  TIM Hall sensor Configuration Structure definition  
N  */
N
Ntypedef struct
N{
N                                  
N  uint32_t IC1Polarity;            /*!< Specifies the active edge of the input signal.
N                                        This parameter can be a value of @ref TIM_Input_Capture_Polarity */
N                                                                   
N  uint32_t IC1Prescaler;        /*!< Specifies the Input Capture Prescaler.
N                                     This parameter can be a value of @ref TIM_Input_Capture_Prescaler */
N                                  
N  uint32_t IC1Filter;           /*!< Specifies the input capture filter.
N                                     This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF */  
N  uint32_t Commutation_Delay;  /*!< Specifies the pulse value to be loaded into the Capture Compare Register. 
N                                    This parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF */                              
N} TIM_HallSensor_InitTypeDef;
N
N/** 
N  * @brief  TIM Master configuration Structure definition  
N  */ 
Ntypedef struct {
N  uint32_t  MasterOutputTrigger;   /*!< Trigger output (TRGO) selection. 
N                                      This parameter can be a value of @ref TIM_Master_Mode_Selection */ 
N  uint32_t  MasterOutputTrigger2;  /*!< Trigger output2 (TRGO2) selection 
N                                      This parameter can be a value of @ref TIMEx_Master_Mode_Selection_2 */
N  uint32_t  MasterSlaveMode;       /*!< Master/slave mode selection. 
N                                      This parameter can be a value of @ref TIM_Master_Slave_Mode */
N}TIM_MasterConfigTypeDef;
N
N/** 
N  * @brief  TIM Break input(s) and Dead time configuration Structure definition  
N  * @note   2 break inputs can be configured (BKIN and BKIN2) with configurable 
N  *        filter and polarity.
N  */ 
Ntypedef struct
N{
N  uint32_t OffStateRunMode;	    /*!< TIM off state in run mode.
N                                       This parameter can be a value of @ref TIM_OSSR_Off_State_Selection_for_Run_mode_state */
N  uint32_t OffStateIDLEMode;	    /*!< TIM off state in IDLE mode.
N                                       This parameter can be a value of @ref TIM_OSSI_Off_State_Selection_for_Idle_mode_state */
N  uint32_t LockLevel;	 	        /*!< TIM Lock level.
N                                       This parameter can be a value of @ref TIM_Lock_level */                             
N  uint32_t DeadTime;	 	        /*!< TIM dead Time.
N                                       This parameter can be a number between Min_Data = 0x00 and Max_Data = 0xFF */
N  uint32_t BreakState;	 	        /*!< TIM Break State.
N                                       This parameter can be a value of @ref TIM_Break_Input_enable_disable */
N  uint32_t BreakPolarity;           /*!< TIM Break input polarity.
N                                       This parameter can be a value of @ref TIM_Break_Polarity */
N  uint32_t BreakFilter;             /*!< Specifies the break input filter.
N                                       This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF */  
N  uint32_t Break2State;	 	        /*!< TIM Break2 State 
N                                       This parameter can be a value of @ref TIMEx_Break2_Input_enable_disable */
N  uint32_t Break2Polarity;          /*!< TIM Break2 input polarity 
N                                       This parameter can be a value of @ref TIMEx_Break2_Polarity */
N  uint32_t Break2Filter;            /*!< TIM break2 input filter.
N                                       This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF */  
N  uint32_t AutomaticOutput;         /*!< TIM Automatic Output Enable state 
N                                       This parameter can be a value of @ref TIM_AOE_Bit_Set_Reset */           
N} TIM_BreakDeadTimeConfigTypeDef;
N
N#if defined (STM32F765xx) || defined(STM32F767xx) || defined(STM32F769xx) || defined(STM32F777xx) || defined(STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N/** 
N  * @brief  TIM Break/Break2 input configuration   
N  */
Ntypedef struct {
N  uint32_t Source;         /*!< Specifies the source of the timer break input.
N                                This parameter can be a value of @ref TIMEx_Break_Input_Source */
N  uint32_t Enable;         /*!< Specifies whether or not the break input source is enabled.
N                                This parameter can be a value of @ref TIMEx_Break_Input_Source_Enable */
N} TIMEx_BreakInputConfigTypeDef;
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N/**
N  * @}
N  */  
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup TIMEx_Exported_Constants  TIMEx Exported Constants
N  * @{
N  */
N  
N/** @defgroup TIMEx_Channel TIMEx Channel
N  * @{
N  */
N
N#define TIM_CHANNEL_1                      ((uint32_t)0x0000U)
N#define TIM_CHANNEL_2                      ((uint32_t)0x0004U)
N#define TIM_CHANNEL_3                      ((uint32_t)0x0008U)
N#define TIM_CHANNEL_4                      ((uint32_t)0x000CU)
N#define TIM_CHANNEL_5                      ((uint32_t)0x0010U)
N#define TIM_CHANNEL_6                      ((uint32_t)0x0014U)
N#define TIM_CHANNEL_ALL                    ((uint32_t)0x003CU)
N                                 
N/**
N  * @}
N  */ 
N    
N/** @defgroup TIMEx_Output_Compare_and_PWM_modes TIMEx Output Compare and PWM Modes
N  * @{
N  */
N#define TIM_OCMODE_TIMING                   ((uint32_t)0x0000U)
N#define TIM_OCMODE_ACTIVE                   ((uint32_t)TIM_CCMR1_OC1M_0)
N#define TIM_OCMODE_INACTIVE                 ((uint32_t)TIM_CCMR1_OC1M_1)
N#define TIM_OCMODE_TOGGLE                   ((uint32_t)TIM_CCMR1_OC1M_1 | TIM_CCMR1_OC1M_0)
N#define TIM_OCMODE_PWM1                     ((uint32_t)TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_1)
N#define TIM_OCMODE_PWM2                     ((uint32_t)TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_1 | TIM_CCMR1_OC1M_0)
N#define TIM_OCMODE_FORCED_ACTIVE            ((uint32_t)TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_0)
N#define TIM_OCMODE_FORCED_INACTIVE          ((uint32_t)TIM_CCMR1_OC1M_2)
N
N#define TIM_OCMODE_RETRIGERRABLE_OPM1      ((uint32_t)TIM_CCMR1_OC1M_3)
N#define TIM_OCMODE_RETRIGERRABLE_OPM2      ((uint32_t)TIM_CCMR1_OC1M_3 | TIM_CCMR1_OC1M_0)
N#define TIM_OCMODE_COMBINED_PWM1           ((uint32_t)TIM_CCMR1_OC1M_3 | TIM_CCMR1_OC1M_2)
N#define TIM_OCMODE_COMBINED_PWM2           ((uint32_t)TIM_CCMR1_OC1M_3 | TIM_CCMR1_OC1M_0 | TIM_CCMR1_OC1M_2)
N#define TIM_OCMODE_ASSYMETRIC_PWM1         ((uint32_t)TIM_CCMR1_OC1M_3 | TIM_CCMR1_OC1M_1 | TIM_CCMR1_OC1M_2)
N#define TIM_OCMODE_ASSYMETRIC_PWM2         ((uint32_t)TIM_CCMR1_OC1M_3 | TIM_CCMR1_OC1M)
N/**
N  * @}
N  */
N      
N/** @defgroup TIMEx_Remap  TIMEx Remap
N  * @{
N  */
N#define TIM_TIM2_TIM8_TRGO                     (0x00000000U)
N#define TIM_TIM2_ETH_PTP                       (0x00000400U)
N#define TIM_TIM2_USBFS_SOF                     (0x00000800U)
N#define TIM_TIM2_USBHS_SOF                     (0x00000C00U)
N#define TIM_TIM5_GPIO                          (0x00000000U)
N#define TIM_TIM5_LSI                           (0x00000040U)
N#define TIM_TIM5_LSE                           (0x00000080U)
N#define TIM_TIM5_RTC                           (0x000000C0U)
N#define TIM_TIM11_GPIO                         (0x00000000U)
N#define TIM_TIM11_SPDIFRX                      (0x00000001U)
N#define TIM_TIM11_HSE                          (0x00000002U)
N#define TIM_TIM11_MCO1                         (0x00000003U)
N/**
N  * @}
N  */	
N
N/** @defgroup TIMEx_ClearInput_Source TIMEx Clear Input Source
N  * @{
N  */
N#define TIM_CLEARINPUTSOURCE_ETR            ((uint32_t)0x0001U) 
N#define TIM_CLEARINPUTSOURCE_OCREFCLR       ((uint32_t)0x0002U) 
N#define TIM_CLEARINPUTSOURCE_NONE           ((uint32_t)0x0000U)
N/**
N  * @}
N  */
N  
N/** @defgroup TIMEx_Break2_Input_enable_disable  TIMEx Break input 2 Enable
N  * @{
N  */                         
N#define TIM_BREAK2_DISABLE         ((uint32_t)0x00000000U)
N#define TIM_BREAK2_ENABLE          ((uint32_t)TIM_BDTR_BK2E)
N/**
N  * @}
N  */
N    
N/** @defgroup TIMEx_Break2_Polarity TIMEx Break2 Polarity
N  * @{
N  */
N#define TIM_BREAK2POLARITY_LOW        ((uint32_t)0x00000000U)
N#define TIM_BREAK2POLARITY_HIGH       (TIM_BDTR_BK2P)
N/**
N  * @}
N  */
N 
N/** @defgroup TIMEx_Group_Channel5 TIMEx Group Channel 5 and Channel 1, 2 or 3
N  * @{
N  */
N#define TIM_GROUPCH5_NONE       ((uint32_t)0x00000000U)  /* !< No effect of OC5REF on OC1REFC, OC2REFC and OC3REFC */
N#define TIM_GROUPCH5_OC1REFC    (TIM_CCR5_GC5C1)      /* !< OC1REFC is the logical AND of OC1REFC and OC5REF */
N#define TIM_GROUPCH5_OC2REFC    (TIM_CCR5_GC5C2)      /* !< OC2REFC is the logical AND of OC2REFC and OC5REF */
N#define TIM_GROUPCH5_OC3REFC    (TIM_CCR5_GC5C3)       /* !< OC3REFC is the logical AND of OC3REFC and OC5REF */
N/**
N  * @}
N  */
N	
N/** @defgroup TIMEx_Master_Mode_Selection_2 TIMEx Master Mode Selection 2 (TRGO2)
N  * @{
N  */  
N#define	TIM_TRGO2_RESET                          ((uint32_t)0x00000000U)             
N#define	TIM_TRGO2_ENABLE                         ((uint32_t)(TIM_CR2_MMS2_0))          
N#define	TIM_TRGO2_UPDATE                         ((uint32_t)(TIM_CR2_MMS2_1))
N#define	TIM_TRGO2_OC1                            ((uint32_t)(TIM_CR2_MMS2_1 | TIM_CR2_MMS2_0))   
N#define	TIM_TRGO2_OC1REF                         ((uint32_t)(TIM_CR2_MMS2_2))           
N#define	TIM_TRGO2_OC2REF                         ((uint32_t)(TIM_CR2_MMS2_2 | TIM_CR2_MMS2_0))          
N#define	TIM_TRGO2_OC3REF                         ((uint32_t)(TIM_CR2_MMS2_2 | TIM_CR2_MMS2_1))           
N#define	TIM_TRGO2_OC4REF                         ((uint32_t)(TIM_CR2_MMS2_2 | TIM_CR2_MMS2_1 | TIM_CR2_MMS2_0))  
N#define	TIM_TRGO2_OC5REF                         ((uint32_t)(TIM_CR2_MMS2_3))   
N#define	TIM_TRGO2_OC6REF                         ((uint32_t)(TIM_CR2_MMS2_3 | TIM_CR2_MMS2_0))   
N#define	TIM_TRGO2_OC4REF_RISINGFALLING           ((uint32_t)(TIM_CR2_MMS2_3 | TIM_CR2_MMS2_1))   
N#define	TIM_TRGO2_OC6REF_RISINGFALLING           ((uint32_t)(TIM_CR2_MMS2_3 | TIM_CR2_MMS2_1 | TIM_CR2_MMS2_0))   
N#define	TIM_TRGO2_OC4REF_RISING_OC6REF_RISING    ((uint32_t)(TIM_CR2_MMS2_3 | TIM_CR2_MMS2_2))   
N#define	TIM_TRGO2_OC4REF_RISING_OC6REF_FALLING   ((uint32_t)(TIM_CR2_MMS2_3 | TIM_CR2_MMS2_2 | TIM_CR2_MMS2_0))   
N#define	TIM_TRGO2_OC5REF_RISING_OC6REF_RISING    ((uint32_t)(TIM_CR2_MMS2_3 | TIM_CR2_MMS2_2 |TIM_CR2_MMS2_1))   
N#define	TIM_TRGO2_OC5REF_RISING_OC6REF_FALLING   ((uint32_t)(TIM_CR2_MMS2_3 | TIM_CR2_MMS2_2 | TIM_CR2_MMS2_1 | TIM_CR2_MMS2_0))   
N/**
N  * @}
N  */ 
N    
N/** @defgroup TIMEx_Slave_Mode TIMEx Slave mode
N  * @{
N  */
N#define TIM_SLAVEMODE_DISABLE                ((uint32_t)0x0000U)
N#define TIM_SLAVEMODE_RESET                  ((uint32_t)(TIM_SMCR_SMS_2))
N#define TIM_SLAVEMODE_GATED                  ((uint32_t)(TIM_SMCR_SMS_2 | TIM_SMCR_SMS_0))
N#define TIM_SLAVEMODE_TRIGGER                ((uint32_t)(TIM_SMCR_SMS_2 | TIM_SMCR_SMS_1))
N#define TIM_SLAVEMODE_EXTERNAL1              ((uint32_t)(TIM_SMCR_SMS_2 | TIM_SMCR_SMS_1 | TIM_SMCR_SMS_0))
N#define TIM_SLAVEMODE_COMBINED_RESETTRIGGER  ((uint32_t)(TIM_SMCR_SMS_3))
N/**
N  * @}
N  */
N#if defined(STM32F765xx) || defined(STM32F767xx) || defined(STM32F769xx) || defined(STM32F777xx) || defined(STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N/** @defgroup TIMEx_Break_Input TIM  Extended Break input
N  * @{
N  */
N#define TIM_BREAKINPUT_BRK     ((uint32_t)0x00000001U) /* !< Timer break input  */
N#define TIM_BREAKINPUT_BRK2    ((uint32_t)0x00000002U) /* !< Timer break2 input */
N/**
N  * @}
N  */
N
N/** @defgroup TIMEx_Break_Input_Source TIM  Extended Break input source
N  * @{
N  */
N#define TIM_BREAKINPUTSOURCE_BKIN     ((uint32_t)0x00000001U) /* !< An external source (GPIO) is connected to the BKIN pin  */
N#define TIM_BREAKINPUTSOURCE_DFSDM1    ((uint32_t)0x00000008U) /* !< The analog watchdog output of the DFSDM1 peripheral is connected to the break input */
N/**
N  * @}
N  */ 
N
N/** @defgroup TIMEx_Break_Input_Source_Enable TIM Extended Break input source enabling
N  * @{
N  */
N#define TIM_BREAKINPUTSOURCE_DISABLE     ((uint32_t)0x00000000U) /* !< Break input source is disabled */
N#define TIM_BREAKINPUTSOURCE_ENABLE      ((uint32_t)0x00000001U) /* !< Break input source is enabled */
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup TIMEx_Exported_Macros TIMEx Exported Macros
N  * @{
N  */  
N
N/**
N  * @brief  Sets the TIM Capture Compare Register value on runtime without
N  *         calling another time ConfigChannel function.
N  * @param  __HANDLE__: TIM handle.
N  * @param  __CHANNEL__ : TIM Channels to be configured.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
N  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
N  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
N  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
N  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
N  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
N  * @param  __COMPARE__: specifies the Capture Compare register new value.
N  * @retval None
N  */
N#define __HAL_TIM_SET_COMPARE(__HANDLE__, __CHANNEL__, __COMPARE__) \
N(((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCR1 = (__COMPARE__)) :\
N ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCR2 = (__COMPARE__)) :\
N ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCR3 = (__COMPARE__)) :\
N ((__CHANNEL__) == TIM_CHANNEL_4) ? ((__HANDLE__)->Instance->CCR4 = (__COMPARE__)) :\
N ((__CHANNEL__) == TIM_CHANNEL_5) ? ((__HANDLE__)->Instance->CCR5 = (__COMPARE__)) :\
N ((__HANDLE__)->Instance->CCR6 = (__COMPARE__)))
X#define __HAL_TIM_SET_COMPARE(__HANDLE__, __CHANNEL__, __COMPARE__) (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCR1 = (__COMPARE__)) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCR2 = (__COMPARE__)) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCR3 = (__COMPARE__)) : ((__CHANNEL__) == TIM_CHANNEL_4) ? ((__HANDLE__)->Instance->CCR4 = (__COMPARE__)) : ((__CHANNEL__) == TIM_CHANNEL_5) ? ((__HANDLE__)->Instance->CCR5 = (__COMPARE__)) : ((__HANDLE__)->Instance->CCR6 = (__COMPARE__)))
N
N/**
N  * @brief  Gets the TIM Capture Compare Register value on runtime
N  * @param  __HANDLE__: TIM handle.
N  * @param  __CHANNEL__ : TIM Channel associated with the capture compare register
N  *          This parameter can be one of the following values:
N  *            @arg TIM_CHANNEL_1: get capture/compare 1 register value
N  *            @arg TIM_CHANNEL_2: get capture/compare 2 register value
N  *            @arg TIM_CHANNEL_3: get capture/compare 3 register value
N  *            @arg TIM_CHANNEL_4: get capture/compare 4 register value
N  *            @arg TIM_CHANNEL_5: get capture/compare 5 register value
N  *            @arg TIM_CHANNEL_6: get capture/compare 6 register value
N  * @retval None
N  */
N#define __HAL_TIM_GET_COMPARE(__HANDLE__, __CHANNEL__) \
N(((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCR1) :\
N ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCR2) :\
N ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCR3) :\
N ((__CHANNEL__) == TIM_CHANNEL_4) ? ((__HANDLE__)->Instance->CCR4) :\
N ((__CHANNEL__) == TIM_CHANNEL_5) ? ((__HANDLE__)->Instance->CCR5) :\
N ((__HANDLE__)->Instance->CCR6))
X#define __HAL_TIM_GET_COMPARE(__HANDLE__, __CHANNEL__) (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCR1) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCR2) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCR3) : ((__CHANNEL__) == TIM_CHANNEL_4) ? ((__HANDLE__)->Instance->CCR4) : ((__CHANNEL__) == TIM_CHANNEL_5) ? ((__HANDLE__)->Instance->CCR5) : ((__HANDLE__)->Instance->CCR6))
N
N/**
N  * @}
N  */ 
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup TIMEx_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup TIMEx_Exported_Functions_Group1
N  * @{
N  */
N/*  Timer Hall Sensor functions  **********************************************/
NHAL_StatusTypeDef HAL_TIMEx_HallSensor_Init(TIM_HandleTypeDef* htim, TIM_HallSensor_InitTypeDef* sConfig);
NHAL_StatusTypeDef HAL_TIMEx_HallSensor_DeInit(TIM_HandleTypeDef* htim);
N
Nvoid HAL_TIMEx_HallSensor_MspInit(TIM_HandleTypeDef* htim);
Nvoid HAL_TIMEx_HallSensor_MspDeInit(TIM_HandleTypeDef* htim);
N
N /* Blocking mode: Polling */
NHAL_StatusTypeDef HAL_TIMEx_HallSensor_Start(TIM_HandleTypeDef* htim);
NHAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop(TIM_HandleTypeDef* htim);
N/* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_IT(TIM_HandleTypeDef* htim);
NHAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_IT(TIM_HandleTypeDef* htim);
N/* Non-Blocking mode: DMA */
NHAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_DMA(TIM_HandleTypeDef* htim, uint32_t *pData, uint16_t Length);
NHAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_DMA(TIM_HandleTypeDef* htim);
N/**
N  * @}
N  */
N
N/** @addtogroup TIMEx_Exported_Functions_Group2
N  * @{
N  */
N/*  Timer Complementary Output Compare functions  *****************************/
N/* Blocking mode: Polling */
NHAL_StatusTypeDef HAL_TIMEx_OCN_Start(TIM_HandleTypeDef* htim, uint32_t Channel);
NHAL_StatusTypeDef HAL_TIMEx_OCN_Stop(TIM_HandleTypeDef* htim, uint32_t Channel);
N
N/* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_TIMEx_OCN_Start_IT(TIM_HandleTypeDef* htim, uint32_t Channel);
NHAL_StatusTypeDef HAL_TIMEx_OCN_Stop_IT(TIM_HandleTypeDef* htim, uint32_t Channel);
N
N/* Non-Blocking mode: DMA */
NHAL_StatusTypeDef HAL_TIMEx_OCN_Start_DMA(TIM_HandleTypeDef* htim, uint32_t Channel, uint32_t *pData, uint16_t Length);
NHAL_StatusTypeDef HAL_TIMEx_OCN_Stop_DMA(TIM_HandleTypeDef* htim, uint32_t Channel);
N/**
N  * @}
N  */
N
N/** @addtogroup TIMEx_Exported_Functions_Group3
N  * @{
N  */
N/*  Timer Complementary PWM functions  ****************************************/
N/* Blocking mode: Polling */
NHAL_StatusTypeDef HAL_TIMEx_PWMN_Start(TIM_HandleTypeDef* htim, uint32_t Channel);
NHAL_StatusTypeDef HAL_TIMEx_PWMN_Stop(TIM_HandleTypeDef* htim, uint32_t Channel);
N
N/* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_TIMEx_PWMN_Start_IT(TIM_HandleTypeDef* htim, uint32_t Channel);
NHAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_IT(TIM_HandleTypeDef* htim, uint32_t Channel);
N/* Non-Blocking mode: DMA */
NHAL_StatusTypeDef HAL_TIMEx_PWMN_Start_DMA(TIM_HandleTypeDef* htim, uint32_t Channel, uint32_t *pData, uint16_t Length);
NHAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_DMA(TIM_HandleTypeDef* htim, uint32_t Channel);
N/**
N  * @}
N  */
N
N/** @addtogroup TIMEx_Exported_Functions_Group4
N  * @{
N  */
N/*  Timer Complementary One Pulse functions  **********************************/
N/* Blocking mode: Polling */
NHAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start(TIM_HandleTypeDef* htim, uint32_t OutputChannel);
NHAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop(TIM_HandleTypeDef* htim, uint32_t OutputChannel);
N
N/* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start_IT(TIM_HandleTypeDef* htim, uint32_t OutputChannel);
NHAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop_IT(TIM_HandleTypeDef* htim, uint32_t OutputChannel);
N/**
N  * @}
N  */
N
N/** @addtogroup TIMEx_Exported_Functions_Group5
N  * @{
N  */
N/* Extension Control functions  ************************************************/
NHAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent(TIM_HandleTypeDef* htim, uint32_t  InputTrigger, uint32_t  CommutationSource);
NHAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent_IT(TIM_HandleTypeDef* htim, uint32_t  InputTrigger, uint32_t  CommutationSource);
NHAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent_DMA(TIM_HandleTypeDef* htim, uint32_t  InputTrigger, uint32_t  CommutationSource);
NHAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef* htim, TIM_MasterConfigTypeDef * sMasterConfig);
NHAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef* htim, TIM_BreakDeadTimeConfigTypeDef *sBreakDeadTimeConfig);
N#if defined (STM32F765xx) || defined(STM32F767xx) || defined(STM32F769xx) || defined(STM32F777xx) || defined(STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
NHAL_StatusTypeDef HAL_TIMEx_ConfigBreakInput(TIM_HandleTypeDef *htim, uint32_t BreakInput, TIMEx_BreakInputConfigTypeDef *sBreakInputConfig);
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
NHAL_StatusTypeDef HAL_TIMEx_RemapConfig(TIM_HandleTypeDef* htim, uint32_t Remap);
NHAL_StatusTypeDef HAL_TIMEx_GroupChannel5(TIM_HandleTypeDef *htim, uint32_t OCRef);
N/**
N  * @}
N  */
N
N/** @addtogroup TIMEx_Exported_Functions_Group6
N  * @{
N  */ 
N/* Extension Callback *********************************************************/
Nvoid HAL_TIMEx_CommutationCallback(TIM_HandleTypeDef* htim);
Nvoid HAL_TIMEx_BreakCallback(TIM_HandleTypeDef* htim);
Nvoid HAL_TIMEx_DMACommutationCplt(DMA_HandleTypeDef *hdma);
Xvoid TIMEx_DMACommutationCplt(DMA_HandleTypeDef *hdma);
N/**
N  * @}
N  */
N
N/** @addtogroup TIMEx_Exported_Functions_Group7
N  * @{
N  */
N/* Extension Peripheral State functions  **************************************/
NHAL_TIM_StateTypeDef HAL_TIMEx_HallSensor_GetState(TIM_HandleTypeDef* htim);
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup TIMEx_Private_Macros TIMEx Private Macros
N  * @{
N  */
N#define IS_TIM_CHANNELS(CHANNEL) (((CHANNEL) == TIM_CHANNEL_1) || \
N                                  ((CHANNEL) == TIM_CHANNEL_2) || \
N                                  ((CHANNEL) == TIM_CHANNEL_3) || \
N                                  ((CHANNEL) == TIM_CHANNEL_4) || \
N                                  ((CHANNEL) == TIM_CHANNEL_5) || \
N                                  ((CHANNEL) == TIM_CHANNEL_6) || \
N                                  ((CHANNEL) == TIM_CHANNEL_ALL))
X#define IS_TIM_CHANNELS(CHANNEL) (((CHANNEL) == TIM_CHANNEL_1) ||                                   ((CHANNEL) == TIM_CHANNEL_2) ||                                   ((CHANNEL) == TIM_CHANNEL_3) ||                                   ((CHANNEL) == TIM_CHANNEL_4) ||                                   ((CHANNEL) == TIM_CHANNEL_5) ||                                   ((CHANNEL) == TIM_CHANNEL_6) ||                                   ((CHANNEL) == TIM_CHANNEL_ALL))
N                                 
N#define IS_TIM_PWMI_CHANNELS(CHANNEL) (((CHANNEL) == TIM_CHANNEL_1) || \
N                                       ((CHANNEL) == TIM_CHANNEL_2))
X#define IS_TIM_PWMI_CHANNELS(CHANNEL) (((CHANNEL) == TIM_CHANNEL_1) ||                                        ((CHANNEL) == TIM_CHANNEL_2))
N                                      
N#define IS_TIM_OPM_CHANNELS(CHANNEL) (((CHANNEL) == TIM_CHANNEL_1) || \
N                                      ((CHANNEL) == TIM_CHANNEL_2))                                       
X#define IS_TIM_OPM_CHANNELS(CHANNEL) (((CHANNEL) == TIM_CHANNEL_1) ||                                       ((CHANNEL) == TIM_CHANNEL_2))                                       
N
N#define IS_TIM_COMPLEMENTARY_CHANNELS(CHANNEL) (((CHANNEL) == TIM_CHANNEL_1) || \
N                                                ((CHANNEL) == TIM_CHANNEL_2) || \
N                                                ((CHANNEL) == TIM_CHANNEL_3))
X#define IS_TIM_COMPLEMENTARY_CHANNELS(CHANNEL) (((CHANNEL) == TIM_CHANNEL_1) ||                                                 ((CHANNEL) == TIM_CHANNEL_2) ||                                                 ((CHANNEL) == TIM_CHANNEL_3))
N#define IS_TIM_PWM_MODE(MODE) (((MODE) == TIM_OCMODE_PWM1)               || \
N	                       ((MODE) == TIM_OCMODE_PWM2)               || \
N                               ((MODE) == TIM_OCMODE_COMBINED_PWM1)      || \
N                               ((MODE) == TIM_OCMODE_COMBINED_PWM2)      || \
N                               ((MODE) == TIM_OCMODE_ASSYMETRIC_PWM1)    || \
N                               ((MODE) == TIM_OCMODE_ASSYMETRIC_PWM2))
X#define IS_TIM_PWM_MODE(MODE) (((MODE) == TIM_OCMODE_PWM1)               || 	                       ((MODE) == TIM_OCMODE_PWM2)               ||                                ((MODE) == TIM_OCMODE_COMBINED_PWM1)      ||                                ((MODE) == TIM_OCMODE_COMBINED_PWM2)      ||                                ((MODE) == TIM_OCMODE_ASSYMETRIC_PWM1)    ||                                ((MODE) == TIM_OCMODE_ASSYMETRIC_PWM2))
N                              
N#define IS_TIM_OC_MODE(MODE) (((MODE) == TIM_OCMODE_TIMING)             || \
N                             ((MODE) == TIM_OCMODE_ACTIVE)             || \
N                             ((MODE) == TIM_OCMODE_INACTIVE)           || \
N                             ((MODE) == TIM_OCMODE_TOGGLE)             || \
N                             ((MODE) == TIM_OCMODE_FORCED_ACTIVE)      || \
N                             ((MODE) == TIM_OCMODE_FORCED_INACTIVE)    || \
N                             ((MODE) == TIM_OCMODE_RETRIGERRABLE_OPM1) || \
N                             ((MODE) == TIM_OCMODE_RETRIGERRABLE_OPM2))
X#define IS_TIM_OC_MODE(MODE) (((MODE) == TIM_OCMODE_TIMING)             ||                              ((MODE) == TIM_OCMODE_ACTIVE)             ||                              ((MODE) == TIM_OCMODE_INACTIVE)           ||                              ((MODE) == TIM_OCMODE_TOGGLE)             ||                              ((MODE) == TIM_OCMODE_FORCED_ACTIVE)      ||                              ((MODE) == TIM_OCMODE_FORCED_INACTIVE)    ||                              ((MODE) == TIM_OCMODE_RETRIGERRABLE_OPM1) ||                              ((MODE) == TIM_OCMODE_RETRIGERRABLE_OPM2))
N#define IS_TIM_REMAP(__TIM_REMAP__)	 (((__TIM_REMAP__) == TIM_TIM2_TIM8_TRGO)||\
N                                      ((__TIM_REMAP__) == TIM_TIM2_ETH_PTP)||\
N                                      ((__TIM_REMAP__) == TIM_TIM2_USBFS_SOF)||\
N                                      ((__TIM_REMAP__) == TIM_TIM2_USBHS_SOF)||\
N                                      ((__TIM_REMAP__) == TIM_TIM5_GPIO)||\
N                                      ((__TIM_REMAP__) == TIM_TIM5_LSI)||\
N                                      ((__TIM_REMAP__) == TIM_TIM5_LSE)||\
N                                      ((__TIM_REMAP__) == TIM_TIM5_RTC)||\
N                                      ((__TIM_REMAP__) == TIM_TIM11_GPIO)||\
N                                      ((__TIM_REMAP__) == TIM_TIM11_SPDIFRX)||\
N                                      ((__TIM_REMAP__) == TIM_TIM11_HSE)||\
N                                      ((__TIM_REMAP__) == TIM_TIM11_MCO1))  
X#define IS_TIM_REMAP(__TIM_REMAP__)	 (((__TIM_REMAP__) == TIM_TIM2_TIM8_TRGO)||                                      ((__TIM_REMAP__) == TIM_TIM2_ETH_PTP)||                                      ((__TIM_REMAP__) == TIM_TIM2_USBFS_SOF)||                                      ((__TIM_REMAP__) == TIM_TIM2_USBHS_SOF)||                                      ((__TIM_REMAP__) == TIM_TIM5_GPIO)||                                      ((__TIM_REMAP__) == TIM_TIM5_LSI)||                                      ((__TIM_REMAP__) == TIM_TIM5_LSE)||                                      ((__TIM_REMAP__) == TIM_TIM5_RTC)||                                      ((__TIM_REMAP__) == TIM_TIM11_GPIO)||                                      ((__TIM_REMAP__) == TIM_TIM11_SPDIFRX)||                                      ((__TIM_REMAP__) == TIM_TIM11_HSE)||                                      ((__TIM_REMAP__) == TIM_TIM11_MCO1))  
N#define IS_TIM_DEADTIME(__DEADTIME__)      ((__DEADTIME__) <= 0xFF) 
N#define IS_TIM_BREAK_FILTER(__FILTER__) ((__FILTER__) <= 0xF)
N#define IS_TIM_CLEARINPUT_SOURCE(MODE) (((MODE) == TIM_CLEARINPUTSOURCE_ETR)      || \
N                                        ((MODE) == TIM_CLEARINPUTSOURCE_OCREFCLR)  || \
N                                        ((MODE) == TIM_CLEARINPUTSOURCE_NONE))
X#define IS_TIM_CLEARINPUT_SOURCE(MODE) (((MODE) == TIM_CLEARINPUTSOURCE_ETR)      ||                                         ((MODE) == TIM_CLEARINPUTSOURCE_OCREFCLR)  ||                                         ((MODE) == TIM_CLEARINPUTSOURCE_NONE))
N#define IS_TIM_BREAK2_STATE(STATE) (((STATE) == TIM_BREAK2_ENABLE) || \
N                                    ((STATE) == TIM_BREAK2_DISABLE))
X#define IS_TIM_BREAK2_STATE(STATE) (((STATE) == TIM_BREAK2_ENABLE) ||                                     ((STATE) == TIM_BREAK2_DISABLE))
N#define IS_TIM_BREAK2_POLARITY(__POLARITY__) (((__POLARITY__) == TIM_BREAK2POLARITY_LOW) || \
N                                              ((__POLARITY__) == TIM_BREAK2POLARITY_HIGH))
X#define IS_TIM_BREAK2_POLARITY(__POLARITY__) (((__POLARITY__) == TIM_BREAK2POLARITY_LOW) ||                                               ((__POLARITY__) == TIM_BREAK2POLARITY_HIGH))
N#define IS_TIM_GROUPCH5(OCREF) ((((OCREF) & 0x1FFFFFFF) == 0x00000000))
N#define IS_TIM_TRGO2_SOURCE(SOURCE) (((SOURCE) == TIM_TRGO2_RESET)                        || \
N                                     ((SOURCE) == TIM_TRGO2_ENABLE)                       || \
N                                     ((SOURCE) == TIM_TRGO2_UPDATE)                       || \
N                                     ((SOURCE) == TIM_TRGO2_OC1)                          || \
N                                     ((SOURCE) == TIM_TRGO2_OC1REF)                       || \
N                                     ((SOURCE) == TIM_TRGO2_OC2REF)                       || \
N                                     ((SOURCE) == TIM_TRGO2_OC3REF)                       || \
N                                     ((SOURCE) == TIM_TRGO2_OC3REF)                       || \
N                                     ((SOURCE) == TIM_TRGO2_OC4REF)                       || \
N                                     ((SOURCE) == TIM_TRGO2_OC5REF)                       || \
N                                     ((SOURCE) == TIM_TRGO2_OC6REF)                       || \
N                                     ((SOURCE) == TIM_TRGO2_OC4REF_RISINGFALLING)         || \
N                                     ((SOURCE) == TIM_TRGO2_OC6REF_RISINGFALLING)         || \
N                                     ((SOURCE) == TIM_TRGO2_OC4REF_RISING_OC6REF_RISING)  || \
N                                     ((SOURCE) == TIM_TRGO2_OC4REF_RISING_OC6REF_FALLING) || \
N                                     ((SOURCE) == TIM_TRGO2_OC5REF_RISING_OC6REF_RISING)  || \
N                                     ((SOURCE) == TIM_TRGO2_OC5REF_RISING_OC6REF_FALLING))
X#define IS_TIM_TRGO2_SOURCE(SOURCE) (((SOURCE) == TIM_TRGO2_RESET)                        ||                                      ((SOURCE) == TIM_TRGO2_ENABLE)                       ||                                      ((SOURCE) == TIM_TRGO2_UPDATE)                       ||                                      ((SOURCE) == TIM_TRGO2_OC1)                          ||                                      ((SOURCE) == TIM_TRGO2_OC1REF)                       ||                                      ((SOURCE) == TIM_TRGO2_OC2REF)                       ||                                      ((SOURCE) == TIM_TRGO2_OC3REF)                       ||                                      ((SOURCE) == TIM_TRGO2_OC3REF)                       ||                                      ((SOURCE) == TIM_TRGO2_OC4REF)                       ||                                      ((SOURCE) == TIM_TRGO2_OC5REF)                       ||                                      ((SOURCE) == TIM_TRGO2_OC6REF)                       ||                                      ((SOURCE) == TIM_TRGO2_OC4REF_RISINGFALLING)         ||                                      ((SOURCE) == TIM_TRGO2_OC6REF_RISINGFALLING)         ||                                      ((SOURCE) == TIM_TRGO2_OC4REF_RISING_OC6REF_RISING)  ||                                      ((SOURCE) == TIM_TRGO2_OC4REF_RISING_OC6REF_FALLING) ||                                      ((SOURCE) == TIM_TRGO2_OC5REF_RISING_OC6REF_RISING)  ||                                      ((SOURCE) == TIM_TRGO2_OC5REF_RISING_OC6REF_FALLING))
N#define IS_TIM_SLAVE_MODE(MODE) (((MODE) == TIM_SLAVEMODE_DISABLE)   || \
N                                 ((MODE) == TIM_SLAVEMODE_RESET)     || \
N                                 ((MODE) == TIM_SLAVEMODE_GATED)     || \
N                                 ((MODE) == TIM_SLAVEMODE_TRIGGER)   || \
N                                 ((MODE) == TIM_SLAVEMODE_EXTERNAL1) || \
N                                 ((MODE) == TIM_SLAVEMODE_COMBINED_RESETTRIGGER))
X#define IS_TIM_SLAVE_MODE(MODE) (((MODE) == TIM_SLAVEMODE_DISABLE)   ||                                  ((MODE) == TIM_SLAVEMODE_RESET)     ||                                  ((MODE) == TIM_SLAVEMODE_GATED)     ||                                  ((MODE) == TIM_SLAVEMODE_TRIGGER)   ||                                  ((MODE) == TIM_SLAVEMODE_EXTERNAL1) ||                                  ((MODE) == TIM_SLAVEMODE_COMBINED_RESETTRIGGER))
N
N#if defined (STM32F765xx) || defined(STM32F767xx) || defined(STM32F769xx) || defined(STM32F777xx) || defined(STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N#define IS_TIM_BREAKINPUT(__BREAKINPUT__)  (((__BREAKINPUT__) == TIM_BREAKINPUT_BRK)  || \
N                                            ((__BREAKINPUT__) == TIM_BREAKINPUT_BRK2))
X#define IS_TIM_BREAKINPUT(__BREAKINPUT__)  (((__BREAKINPUT__) == TIM_BREAKINPUT_BRK)  ||                                             ((__BREAKINPUT__) == TIM_BREAKINPUT_BRK2))
N                                            
N#define IS_TIM_BREAKINPUTSOURCE(__SOURCE__)  (((__SOURCE__) == TIM_BREAKINPUTSOURCE_BKIN)  || \
N                                              ((__SOURCE__) == TIM_BREAKINPUTSOURCE_DFSDM))
X#define IS_TIM_BREAKINPUTSOURCE(__SOURCE__)  (((__SOURCE__) == TIM_BREAKINPUTSOURCE_BKIN)  ||                                               ((__SOURCE__) == TIM_BREAKINPUTSOURCE_DFSDM))
N
N#define IS_TIM_BREAKINPUTSOURCE_STATE(__STATE__)  (((__STATE__) == TIM_BREAKINPUTSOURCE_DISABLE)  || \
N                                                   ((__STATE__) == TIM_BREAKINPUTSOURCE_ENABLE))
X#define IS_TIM_BREAKINPUTSOURCE_STATE(__STATE__)  (((__STATE__) == TIM_BREAKINPUTSOURCE_DISABLE)  ||                                                    ((__STATE__) == TIM_BREAKINPUTSOURCE_ENABLE))
N                                                   
N#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N/**
N  * @}
N  */  
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup TIMEx_Private_Functions TIMEx Private Functions
N  * @{
N  */
N  
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N    
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_TIM_EX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 1064 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_tim.h" 2
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup TIM_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup TIM_Exported_Functions_Group1
N  * @{
N  */
N
N/* Time Base functions ********************************************************/
NHAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim);
NHAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim);
N/* Blocking mode: Polling */
NHAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim);
NHAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim);
N/* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim);
NHAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim);
N/* Non-Blocking mode: DMA */
NHAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length);
NHAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim);
N/**
N  * @}
N  */
N
N/** @addtogroup TIM_Exported_Functions_Group2
N  * @{
N  */
N/* Timer Output Compare functions **********************************************/
NHAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef *htim);
NHAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim);
N/* Blocking mode: Polling */
NHAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel);
NHAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel);
N/* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel);
NHAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel);
N/* Non-Blocking mode: DMA */
NHAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length);
NHAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel);
N
N/**
N  * @}
N  */
N
N/** @addtogroup TIM_Exported_Functions_Group3
N  * @{
N  */
N/* Timer PWM functions *********************************************************/
NHAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim);
NHAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim);
N/* Blocking mode: Polling */
NHAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel);
NHAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel);
N/* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel);
NHAL_StatusTypeDef HAL_TIM_PWM_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel);
N/* Non-Blocking mode: DMA */
NHAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length);
NHAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel);
N
N/**
N  * @}
N  */
N
N/** @addtogroup TIM_Exported_Functions_Group4
N  * @{
N  */
N/* Timer Input Capture functions ***********************************************/
NHAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim);
NHAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim);
N/* Blocking mode: Polling */
NHAL_StatusTypeDef HAL_TIM_IC_Start(TIM_HandleTypeDef *htim, uint32_t Channel);
NHAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel);
N/* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_TIM_IC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel);
NHAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel);
N/* Non-Blocking mode: DMA */
NHAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length);
NHAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel);
N
N/**
N  * @}
N  */
N
N/** @addtogroup TIM_Exported_Functions_Group5
N  * @{
N  */
N/* Timer One Pulse functions ***************************************************/
NHAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode);
NHAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim);
N/* Blocking mode: Polling */
NHAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel);
NHAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel);
N
N/* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel);
NHAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel);
N
N/**
N  * @}
N  */
N
N/** @addtogroup TIM_Exported_Functions_Group6
N  * @{
N  */
N/* Timer Encoder functions *****************************************************/
NHAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef* sConfig);
NHAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim);
N /* Blocking mode: Polling */
NHAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel);
NHAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel);
N/* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel);
NHAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel);
N/* Non-Blocking mode: DMA */
NHAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1, uint32_t *pData2, uint16_t Length);
NHAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel);
N
N/**
N  * @}
N  */
N
N/** @addtogroup TIM_Exported_Functions_Group7
N  * @{
N  */
N/* Interrupt Handler functions  **********************************************/
Nvoid HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim);
N
N/**
N  * @}
N  */
N
N/** @addtogroup TIM_Exported_Functions_Group8
N  * @{
N  */
N/* Control functions  *********************************************************/
NHAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel);
NHAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel);
NHAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef* sConfig, uint32_t Channel);
NHAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OnePulse_InitTypeDef* sConfig, uint32_t OutputChannel,  uint32_t InputChannel);
NHAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim, TIM_ClearInputConfigTypeDef * sClearInputConfig, uint32_t Channel);
NHAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig);    
NHAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection);
NHAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef * sSlaveConfig);
NHAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization_IT(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef * sSlaveConfig);
NHAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc, \
N                                              uint32_t  *BurstBuffer, uint32_t  BurstLength);
XHAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,                                               uint32_t  *BurstBuffer, uint32_t  BurstLength);
NHAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc);
NHAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc, \
N                                              uint32_t  *BurstBuffer, uint32_t  BurstLength);
XHAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,                                               uint32_t  *BurstBuffer, uint32_t  BurstLength);
NHAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc);
NHAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource);
Nuint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel);
N
N/**
N  * @}
N  */
N
N/** @addtogroup TIM_Exported_Functions_Group9
N  * @{
N  */
N/* Callback in non blocking modes (Interrupt and DMA) *************************/
Nvoid HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim);
N
N/**
N  * @}
N  */
N
N/** @addtogroup TIM_Exported_Functions_Group10
N  * @{
N  */
N/* Peripheral State functions  **************************************************/
NHAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim);
NHAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim);
NHAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim);
NHAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim);
NHAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim);
NHAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim);
N
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */
N  
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup TIM_Private_Macros TIM Private Macros
N  * @{
N  */
N
N/** @defgroup TIM_IS_TIM_Definitions TIM Private macros to check input parameters
N  * @{
N  */
N#define IS_TIM_COUNTER_MODE(__MODE__) (((__MODE__) == TIM_COUNTERMODE_UP)              || \
N                                       ((__MODE__) == TIM_COUNTERMODE_DOWN)            || \
N                                       ((__MODE__) == TIM_COUNTERMODE_CENTERALIGNED1)  || \
N                                       ((__MODE__) == TIM_COUNTERMODE_CENTERALIGNED2)  || \
N                                       ((__MODE__) == TIM_COUNTERMODE_CENTERALIGNED3))
X#define IS_TIM_COUNTER_MODE(__MODE__) (((__MODE__) == TIM_COUNTERMODE_UP)              ||                                        ((__MODE__) == TIM_COUNTERMODE_DOWN)            ||                                        ((__MODE__) == TIM_COUNTERMODE_CENTERALIGNED1)  ||                                        ((__MODE__) == TIM_COUNTERMODE_CENTERALIGNED2)  ||                                        ((__MODE__) == TIM_COUNTERMODE_CENTERALIGNED3))
N
N#define IS_TIM_CLOCKDIVISION_DIV(__DIV__) (((__DIV__) == TIM_CLOCKDIVISION_DIV1) || \
N                                           ((__DIV__) == TIM_CLOCKDIVISION_DIV2) || \
N                                           ((__DIV__) == TIM_CLOCKDIVISION_DIV4))
X#define IS_TIM_CLOCKDIVISION_DIV(__DIV__) (((__DIV__) == TIM_CLOCKDIVISION_DIV1) ||                                            ((__DIV__) == TIM_CLOCKDIVISION_DIV2) ||                                            ((__DIV__) == TIM_CLOCKDIVISION_DIV4))
N
N#define IS_TIM_FAST_STATE(__STATE__) (((__STATE__) == TIM_OCFAST_DISABLE) || \
N                                      ((__STATE__) == TIM_OCFAST_ENABLE))
X#define IS_TIM_FAST_STATE(__STATE__) (((__STATE__) == TIM_OCFAST_DISABLE) ||                                       ((__STATE__) == TIM_OCFAST_ENABLE))
N
N#define IS_TIM_OUTPUT_STATE(STATE) (((STATE) == TIM_OUTPUTSTATE_DISABLE) || \
N                                    ((STATE) == TIM_OUTPUTSTATE_ENABLE))
X#define IS_TIM_OUTPUT_STATE(STATE) (((STATE) == TIM_OUTPUTSTATE_DISABLE) ||                                     ((STATE) == TIM_OUTPUTSTATE_ENABLE))
N
N#define IS_TIM_OUTPUTN_STATE(STATE) (((STATE) == TIM_OUTPUTNSTATE_DISABLE) || \
N                                     ((STATE) == TIM_OUTPUTNSTATE_ENABLE))
X#define IS_TIM_OUTPUTN_STATE(STATE) (((STATE) == TIM_OUTPUTNSTATE_DISABLE) ||                                      ((STATE) == TIM_OUTPUTNSTATE_ENABLE))
N
N#define IS_TIM_OC_POLARITY(__POLARITY__) (((__POLARITY__) == TIM_OCPOLARITY_HIGH) || \
N                                          ((__POLARITY__) == TIM_OCPOLARITY_LOW))
X#define IS_TIM_OC_POLARITY(__POLARITY__) (((__POLARITY__) == TIM_OCPOLARITY_HIGH) ||                                           ((__POLARITY__) == TIM_OCPOLARITY_LOW))
N
N#define IS_TIM_OCN_POLARITY(__POLARITY__) (((__POLARITY__) == TIM_OCNPOLARITY_HIGH) || \
N                                           ((__POLARITY__) == TIM_OCNPOLARITY_LOW))
X#define IS_TIM_OCN_POLARITY(__POLARITY__) (((__POLARITY__) == TIM_OCNPOLARITY_HIGH) ||                                            ((__POLARITY__) == TIM_OCNPOLARITY_LOW))
N
N#define IS_TIM_OCIDLE_STATE(__STATE__) (((__STATE__) == TIM_OCIDLESTATE_SET) || \
N                                        ((__STATE__) == TIM_OCIDLESTATE_RESET))
X#define IS_TIM_OCIDLE_STATE(__STATE__) (((__STATE__) == TIM_OCIDLESTATE_SET) ||                                         ((__STATE__) == TIM_OCIDLESTATE_RESET))
N
N#define IS_TIM_OCNIDLE_STATE(__STATE__) (((__STATE__) == TIM_OCNIDLESTATE_SET) || \
N                                         ((__STATE__) == TIM_OCNIDLESTATE_RESET))
X#define IS_TIM_OCNIDLE_STATE(__STATE__) (((__STATE__) == TIM_OCNIDLESTATE_SET) ||                                          ((__STATE__) == TIM_OCNIDLESTATE_RESET))
N
N#define IS_TIM_IC_POLARITY(__POLARITY__) (((__POLARITY__) == TIM_ICPOLARITY_RISING)   || \
N                                          ((__POLARITY__) == TIM_ICPOLARITY_FALLING)  || \
N                                          ((__POLARITY__) == TIM_ICPOLARITY_BOTHEDGE))
X#define IS_TIM_IC_POLARITY(__POLARITY__) (((__POLARITY__) == TIM_ICPOLARITY_RISING)   ||                                           ((__POLARITY__) == TIM_ICPOLARITY_FALLING)  ||                                           ((__POLARITY__) == TIM_ICPOLARITY_BOTHEDGE))
N
N#define IS_TIM_IC_SELECTION(__SELECTION__) (((__SELECTION__) == TIM_ICSELECTION_DIRECTTI) || \
N                                            ((__SELECTION__) == TIM_ICSELECTION_INDIRECTTI) || \
N                                            ((__SELECTION__) == TIM_ICSELECTION_TRC))
X#define IS_TIM_IC_SELECTION(__SELECTION__) (((__SELECTION__) == TIM_ICSELECTION_DIRECTTI) ||                                             ((__SELECTION__) == TIM_ICSELECTION_INDIRECTTI) ||                                             ((__SELECTION__) == TIM_ICSELECTION_TRC))
N
N#define IS_TIM_IC_PRESCALER(__PRESCALER__) (((__PRESCALER__) == TIM_ICPSC_DIV1) || \
N                                            ((__PRESCALER__) == TIM_ICPSC_DIV2) || \
N                                            ((__PRESCALER__) == TIM_ICPSC_DIV4) || \
N                                            ((__PRESCALER__) == TIM_ICPSC_DIV8))
X#define IS_TIM_IC_PRESCALER(__PRESCALER__) (((__PRESCALER__) == TIM_ICPSC_DIV1) ||                                             ((__PRESCALER__) == TIM_ICPSC_DIV2) ||                                             ((__PRESCALER__) == TIM_ICPSC_DIV4) ||                                             ((__PRESCALER__) == TIM_ICPSC_DIV8))
N
N#define IS_TIM_OPM_MODE(__MODE__) (((__MODE__) == TIM_OPMODE_SINGLE) || \
N                                   ((__MODE__) == TIM_OPMODE_REPETITIVE))
X#define IS_TIM_OPM_MODE(__MODE__) (((__MODE__) == TIM_OPMODE_SINGLE) ||                                    ((__MODE__) == TIM_OPMODE_REPETITIVE))
N
N#define IS_TIM_ENCODER_MODE(__MODE__) (((__MODE__) == TIM_ENCODERMODE_TI1) || \
N                                       ((__MODE__) == TIM_ENCODERMODE_TI2) || \
N                                       ((__MODE__) == TIM_ENCODERMODE_TI12))   
X#define IS_TIM_ENCODER_MODE(__MODE__) (((__MODE__) == TIM_ENCODERMODE_TI1) ||                                        ((__MODE__) == TIM_ENCODERMODE_TI2) ||                                        ((__MODE__) == TIM_ENCODERMODE_TI12))   
N
N#define IS_TIM_IT(__IT__) ((((__IT__) & 0xFFFFFF00U) == 0x00000000U) && ((__IT__) != 0x00000000U))
N
N
N#define IS_TIM_GET_IT(__IT__) (((__IT__) == TIM_IT_UPDATE)  || \
N                               ((__IT__) == TIM_IT_CC1)     || \
N                               ((__IT__) == TIM_IT_CC2)     || \
N                               ((__IT__) == TIM_IT_CC3)     || \
N                               ((__IT__) == TIM_IT_CC4)     || \
N                               ((__IT__) == TIM_IT_COM)     || \
N                               ((__IT__) == TIM_IT_TRIGGER) || \
N                               ((__IT__) == TIM_IT_BREAK))
X#define IS_TIM_GET_IT(__IT__) (((__IT__) == TIM_IT_UPDATE)  ||                                ((__IT__) == TIM_IT_CC1)     ||                                ((__IT__) == TIM_IT_CC2)     ||                                ((__IT__) == TIM_IT_CC3)     ||                                ((__IT__) == TIM_IT_CC4)     ||                                ((__IT__) == TIM_IT_COM)     ||                                ((__IT__) == TIM_IT_TRIGGER) ||                                ((__IT__) == TIM_IT_BREAK))
N
N#define IS_TIM_DMA_SOURCE(__SOURCE__) ((((__SOURCE__) & 0xFFFF80FFU) == 0x00000000U) && ((__SOURCE__) != 0x00000000U))
N
N#define IS_TIM_EVENT_SOURCE(__SOURCE__) ((((__SOURCE__) & 0xFFFFFE00U) == 0x00000000U) && ((__SOURCE__) != 0x00000000U))
N
N#define IS_TIM_FLAG(__FLAG__) (((__FLAG__) == TIM_FLAG_UPDATE) || \
N                               ((__FLAG__) == TIM_FLAG_CC1)     || \
N                               ((__FLAG__) == TIM_FLAG_CC2)     || \
N                               ((__FLAG__) == TIM_FLAG_CC3)     || \
N                               ((__FLAG__) == TIM_FLAG_CC4)     || \
N                               ((__FLAG__) == TIM_FLAG_COM)     || \
N                               ((__FLAG__) == TIM_FLAG_TRIGGER) || \
N                               ((__FLAG__) == TIM_FLAG_BREAK)   || \
N                               ((__FLAG__) == TIM_FLAG_BREAK2)  || \
N                               ((__FLAG__) == TIM_FLAG_CC1OF)   || \
N                               ((__FLAG__) == TIM_FLAG_CC2OF)   || \
N                               ((__FLAG__) == TIM_FLAG_CC3OF)   || \
N                               ((__FLAG__) == TIM_FLAG_CC4OF))
X#define IS_TIM_FLAG(__FLAG__) (((__FLAG__) == TIM_FLAG_UPDATE) ||                                ((__FLAG__) == TIM_FLAG_CC1)     ||                                ((__FLAG__) == TIM_FLAG_CC2)     ||                                ((__FLAG__) == TIM_FLAG_CC3)     ||                                ((__FLAG__) == TIM_FLAG_CC4)     ||                                ((__FLAG__) == TIM_FLAG_COM)     ||                                ((__FLAG__) == TIM_FLAG_TRIGGER) ||                                ((__FLAG__) == TIM_FLAG_BREAK)   ||                                ((__FLAG__) == TIM_FLAG_BREAK2)  ||                                ((__FLAG__) == TIM_FLAG_CC1OF)   ||                                ((__FLAG__) == TIM_FLAG_CC2OF)   ||                                ((__FLAG__) == TIM_FLAG_CC3OF)   ||                                ((__FLAG__) == TIM_FLAG_CC4OF))
N
N#define IS_TIM_CLOCKSOURCE(__CLOCK__) (((__CLOCK__) == TIM_CLOCKSOURCE_INTERNAL) || \
N                                       ((__CLOCK__) == TIM_CLOCKSOURCE_ETRMODE2) || \
N                                       ((__CLOCK__) == TIM_CLOCKSOURCE_ITR0)     || \
N                                       ((__CLOCK__) == TIM_CLOCKSOURCE_ITR1)     || \
N                                       ((__CLOCK__) == TIM_CLOCKSOURCE_ITR2)     || \
N                                       ((__CLOCK__) == TIM_CLOCKSOURCE_ITR3)     || \
N                                       ((__CLOCK__) == TIM_CLOCKSOURCE_TI1ED)    || \
N                                       ((__CLOCK__) == TIM_CLOCKSOURCE_TI1)      || \
N                                       ((__CLOCK__) == TIM_CLOCKSOURCE_TI2)      || \
N                                       ((__CLOCK__) == TIM_CLOCKSOURCE_ETRMODE1))
X#define IS_TIM_CLOCKSOURCE(__CLOCK__) (((__CLOCK__) == TIM_CLOCKSOURCE_INTERNAL) ||                                        ((__CLOCK__) == TIM_CLOCKSOURCE_ETRMODE2) ||                                        ((__CLOCK__) == TIM_CLOCKSOURCE_ITR0)     ||                                        ((__CLOCK__) == TIM_CLOCKSOURCE_ITR1)     ||                                        ((__CLOCK__) == TIM_CLOCKSOURCE_ITR2)     ||                                        ((__CLOCK__) == TIM_CLOCKSOURCE_ITR3)     ||                                        ((__CLOCK__) == TIM_CLOCKSOURCE_TI1ED)    ||                                        ((__CLOCK__) == TIM_CLOCKSOURCE_TI1)      ||                                        ((__CLOCK__) == TIM_CLOCKSOURCE_TI2)      ||                                        ((__CLOCK__) == TIM_CLOCKSOURCE_ETRMODE1))
N
N#define IS_TIM_CLOCKPOLARITY(__POLARITY__) (((__POLARITY__) == TIM_CLOCKPOLARITY_INVERTED)    || \
N                                        ((__POLARITY__) == TIM_CLOCKPOLARITY_NONINVERTED) || \
N                                        ((__POLARITY__) == TIM_CLOCKPOLARITY_RISING)      || \
N                                        ((__POLARITY__) == TIM_CLOCKPOLARITY_FALLING)     || \
N                                        ((__POLARITY__) == TIM_CLOCKPOLARITY_BOTHEDGE))
X#define IS_TIM_CLOCKPOLARITY(__POLARITY__) (((__POLARITY__) == TIM_CLOCKPOLARITY_INVERTED)    ||                                         ((__POLARITY__) == TIM_CLOCKPOLARITY_NONINVERTED) ||                                         ((__POLARITY__) == TIM_CLOCKPOLARITY_RISING)      ||                                         ((__POLARITY__) == TIM_CLOCKPOLARITY_FALLING)     ||                                         ((__POLARITY__) == TIM_CLOCKPOLARITY_BOTHEDGE))
N
N#define IS_TIM_CLOCKPRESCALER(__PRESCALER__) (((__PRESCALER__) == TIM_CLOCKPRESCALER_DIV1) || \
N                                              ((__PRESCALER__) == TIM_CLOCKPRESCALER_DIV2) || \
N                                              ((__PRESCALER__) == TIM_CLOCKPRESCALER_DIV4) || \
N                                              ((__PRESCALER__) == TIM_CLOCKPRESCALER_DIV8)) 
X#define IS_TIM_CLOCKPRESCALER(__PRESCALER__) (((__PRESCALER__) == TIM_CLOCKPRESCALER_DIV1) ||                                               ((__PRESCALER__) == TIM_CLOCKPRESCALER_DIV2) ||                                               ((__PRESCALER__) == TIM_CLOCKPRESCALER_DIV4) ||                                               ((__PRESCALER__) == TIM_CLOCKPRESCALER_DIV8)) 
N
N#define IS_TIM_CLOCKFILTER(__ICFILTER__)      ((__ICFILTER__) <= 0xF) 
N
N#define IS_TIM_CLEARINPUT_POLARITY(__POLARITY__)   (((__POLARITY__) == TIM_CLEARINPUTPOLARITY_INVERTED) || \
N                                                    ((__POLARITY__) == TIM_CLEARINPUTPOLARITY_NONINVERTED))
X#define IS_TIM_CLEARINPUT_POLARITY(__POLARITY__)   (((__POLARITY__) == TIM_CLEARINPUTPOLARITY_INVERTED) ||                                                     ((__POLARITY__) == TIM_CLEARINPUTPOLARITY_NONINVERTED))
N
N#define IS_TIM_CLEARINPUT_PRESCALER(__PRESCALER__)   (((__PRESCALER__) == TIM_CLEARINPUTPRESCALER_DIV1) || \
N                                                 ((__PRESCALER__) == TIM_CLEARINPUTPRESCALER_DIV2) || \
N                                                 ((__PRESCALER__) == TIM_CLEARINPUTPRESCALER_DIV4) || \
N                                                 ((__PRESCALER__) == TIM_CLEARINPUTPRESCALER_DIV8))
X#define IS_TIM_CLEARINPUT_PRESCALER(__PRESCALER__)   (((__PRESCALER__) == TIM_CLEARINPUTPRESCALER_DIV1) ||                                                  ((__PRESCALER__) == TIM_CLEARINPUTPRESCALER_DIV2) ||                                                  ((__PRESCALER__) == TIM_CLEARINPUTPRESCALER_DIV4) ||                                                  ((__PRESCALER__) == TIM_CLEARINPUTPRESCALER_DIV8))
N
N#define IS_TIM_CLEARINPUT_FILTER(__ICFILTER__) ((__ICFILTER__) <= 0xF) 
N
N#define IS_TIM_OSSR_STATE(__STATE__) (((__STATE__) == TIM_OSSR_ENABLE) || \
N                                      ((__STATE__) == TIM_OSSR_DISABLE))
X#define IS_TIM_OSSR_STATE(__STATE__) (((__STATE__) == TIM_OSSR_ENABLE) ||                                       ((__STATE__) == TIM_OSSR_DISABLE))
N
N#define IS_TIM_OSSI_STATE(__STATE__) (((__STATE__) == TIM_OSSI_ENABLE) || \
N                                      ((__STATE__) == TIM_OSSI_DISABLE))
X#define IS_TIM_OSSI_STATE(__STATE__) (((__STATE__) == TIM_OSSI_ENABLE) ||                                       ((__STATE__) == TIM_OSSI_DISABLE))
N
N#define IS_TIM_LOCK_LEVEL(__LEVEL__) (((__LEVEL__) == TIM_LOCKLEVEL_OFF) || \
N                                      ((__LEVEL__) == TIM_LOCKLEVEL_1) || \
N                                      ((__LEVEL__) == TIM_LOCKLEVEL_2) || \
N                                      ((__LEVEL__) == TIM_LOCKLEVEL_3)) 
X#define IS_TIM_LOCK_LEVEL(__LEVEL__) (((__LEVEL__) == TIM_LOCKLEVEL_OFF) ||                                       ((__LEVEL__) == TIM_LOCKLEVEL_1) ||                                       ((__LEVEL__) == TIM_LOCKLEVEL_2) ||                                       ((__LEVEL__) == TIM_LOCKLEVEL_3)) 
N
N#define IS_TIM_BREAK_STATE(__STATE__) (((__STATE__) == TIM_BREAK_ENABLE) || \
N                                       ((__STATE__) == TIM_BREAK_DISABLE))
X#define IS_TIM_BREAK_STATE(__STATE__) (((__STATE__) == TIM_BREAK_ENABLE) ||                                        ((__STATE__) == TIM_BREAK_DISABLE))
N
N#define IS_TIM_BREAK_POLARITY(__POLARITY__) (((__POLARITY__) == TIM_BREAKPOLARITY_LOW) || \
N                                             ((__POLARITY__) == TIM_BREAKPOLARITY_HIGH))
X#define IS_TIM_BREAK_POLARITY(__POLARITY__) (((__POLARITY__) == TIM_BREAKPOLARITY_LOW) ||                                              ((__POLARITY__) == TIM_BREAKPOLARITY_HIGH))
N
N#define IS_TIM_AUTOMATIC_OUTPUT_STATE(__STATE__) (((__STATE__) == TIM_AUTOMATICOUTPUT_ENABLE) || \
N                                                  ((__STATE__) == TIM_AUTOMATICOUTPUT_DISABLE))
X#define IS_TIM_AUTOMATIC_OUTPUT_STATE(__STATE__) (((__STATE__) == TIM_AUTOMATICOUTPUT_ENABLE) ||                                                   ((__STATE__) == TIM_AUTOMATICOUTPUT_DISABLE))
N
N#define IS_TIM_TRGO_SOURCE(__SOURCE__) (((__SOURCE__) == TIM_TRGO_RESET) || \
N                                        ((__SOURCE__) == TIM_TRGO_ENABLE) || \
N                                        ((__SOURCE__) == TIM_TRGO_UPDATE) || \
N                                        ((__SOURCE__) == TIM_TRGO_OC1) || \
N                                        ((__SOURCE__) == TIM_TRGO_OC1REF) || \
N                                        ((__SOURCE__) == TIM_TRGO_OC2REF) || \
N                                        ((__SOURCE__) == TIM_TRGO_OC3REF) || \
N                                        ((__SOURCE__) == TIM_TRGO_OC4REF))
X#define IS_TIM_TRGO_SOURCE(__SOURCE__) (((__SOURCE__) == TIM_TRGO_RESET) ||                                         ((__SOURCE__) == TIM_TRGO_ENABLE) ||                                         ((__SOURCE__) == TIM_TRGO_UPDATE) ||                                         ((__SOURCE__) == TIM_TRGO_OC1) ||                                         ((__SOURCE__) == TIM_TRGO_OC1REF) ||                                         ((__SOURCE__) == TIM_TRGO_OC2REF) ||                                         ((__SOURCE__) == TIM_TRGO_OC3REF) ||                                         ((__SOURCE__) == TIM_TRGO_OC4REF))
N
N#define IS_TIM_MSM_STATE(__STATE__) (((__STATE__) == TIM_MASTERSLAVEMODE_ENABLE) || \
N                                     ((__STATE__) == TIM_MASTERSLAVEMODE_DISABLE))
X#define IS_TIM_MSM_STATE(__STATE__) (((__STATE__) == TIM_MASTERSLAVEMODE_ENABLE) ||                                      ((__STATE__) == TIM_MASTERSLAVEMODE_DISABLE))
N
N#define IS_TIM_TRIGGER_SELECTION(__SELECTION__) (((__SELECTION__) == TIM_TS_ITR0) || \
N                                                 ((__SELECTION__) == TIM_TS_ITR1) || \
N                                                 ((__SELECTION__) == TIM_TS_ITR2) || \
N                                                 ((__SELECTION__) == TIM_TS_ITR3) || \
N                                                 ((__SELECTION__) == TIM_TS_TI1F_ED) || \
N                                                 ((__SELECTION__) == TIM_TS_TI1FP1) || \
N                                                 ((__SELECTION__) == TIM_TS_TI2FP2) || \
N                                                 ((__SELECTION__) == TIM_TS_ETRF))
X#define IS_TIM_TRIGGER_SELECTION(__SELECTION__) (((__SELECTION__) == TIM_TS_ITR0) ||                                                  ((__SELECTION__) == TIM_TS_ITR1) ||                                                  ((__SELECTION__) == TIM_TS_ITR2) ||                                                  ((__SELECTION__) == TIM_TS_ITR3) ||                                                  ((__SELECTION__) == TIM_TS_TI1F_ED) ||                                                  ((__SELECTION__) == TIM_TS_TI1FP1) ||                                                  ((__SELECTION__) == TIM_TS_TI2FP2) ||                                                  ((__SELECTION__) == TIM_TS_ETRF))
N
N#define IS_TIM_INTERNAL_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) || \
N                                                      ((SELECTION) == TIM_TS_ITR1) || \
N                                                      ((SELECTION) == TIM_TS_ITR2) || \
N                                                      ((SELECTION) == TIM_TS_ITR3))
X#define IS_TIM_INTERNAL_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) ||                                                       ((SELECTION) == TIM_TS_ITR1) ||                                                       ((SELECTION) == TIM_TS_ITR2) ||                                                       ((SELECTION) == TIM_TS_ITR3))
N
N#define IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(__SELECTION__) (((__SELECTION__) == TIM_TS_ITR0) || \
N                                                               ((__SELECTION__) == TIM_TS_ITR1) || \
N                                                               ((__SELECTION__) == TIM_TS_ITR2) || \
N                                                               ((__SELECTION__) == TIM_TS_ITR3) || \
N                                                               ((__SELECTION__) == TIM_TS_NONE))
X#define IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(__SELECTION__) (((__SELECTION__) == TIM_TS_ITR0) ||                                                                ((__SELECTION__) == TIM_TS_ITR1) ||                                                                ((__SELECTION__) == TIM_TS_ITR2) ||                                                                ((__SELECTION__) == TIM_TS_ITR3) ||                                                                ((__SELECTION__) == TIM_TS_NONE))
N
N#define IS_TIM_TRIGGERPOLARITY(__POLARITY__)     (((__POLARITY__) == TIM_TRIGGERPOLARITY_INVERTED   ) || \
N                                                  ((__POLARITY__) == TIM_TRIGGERPOLARITY_NONINVERTED) || \
N                                                  ((__POLARITY__) == TIM_TRIGGERPOLARITY_RISING     ) || \
N                                                  ((__POLARITY__) == TIM_TRIGGERPOLARITY_FALLING    ) || \
N                                                  ((__POLARITY__) == TIM_TRIGGERPOLARITY_BOTHEDGE   ))
X#define IS_TIM_TRIGGERPOLARITY(__POLARITY__)     (((__POLARITY__) == TIM_TRIGGERPOLARITY_INVERTED   ) ||                                                   ((__POLARITY__) == TIM_TRIGGERPOLARITY_NONINVERTED) ||                                                   ((__POLARITY__) == TIM_TRIGGERPOLARITY_RISING     ) ||                                                   ((__POLARITY__) == TIM_TRIGGERPOLARITY_FALLING    ) ||                                                   ((__POLARITY__) == TIM_TRIGGERPOLARITY_BOTHEDGE   ))
N
N#define IS_TIM_TRIGGERPRESCALER(__PRESCALER__)  (((__PRESCALER__) == TIM_TRIGGERPRESCALER_DIV1) || \
N                                                 ((__PRESCALER__) == TIM_TRIGGERPRESCALER_DIV2) || \
N                                                 ((__PRESCALER__) == TIM_TRIGGERPRESCALER_DIV4) || \
N                                                 ((__PRESCALER__) == TIM_TRIGGERPRESCALER_DIV8)) 
X#define IS_TIM_TRIGGERPRESCALER(__PRESCALER__)  (((__PRESCALER__) == TIM_TRIGGERPRESCALER_DIV1) ||                                                  ((__PRESCALER__) == TIM_TRIGGERPRESCALER_DIV2) ||                                                  ((__PRESCALER__) == TIM_TRIGGERPRESCALER_DIV4) ||                                                  ((__PRESCALER__) == TIM_TRIGGERPRESCALER_DIV8)) 
N
N#define IS_TIM_TRIGGERFILTER(__ICFILTER__)     ((__ICFILTER__) <= 0xF) 
N
N#define IS_TIM_TI1SELECTION(__TI1SELECTION__)   (((__TI1SELECTION__) == TIM_TI1SELECTION_CH1) || \
N                                                 ((__TI1SELECTION__) == TIM_TI1SELECTION_XORCOMBINATION))
X#define IS_TIM_TI1SELECTION(__TI1SELECTION__)   (((__TI1SELECTION__) == TIM_TI1SELECTION_CH1) ||                                                  ((__TI1SELECTION__) == TIM_TI1SELECTION_XORCOMBINATION))
N
N#define IS_TIM_DMA_BASE(__BASE__) (((__BASE__) == TIM_DMABASE_CR1) || \
N                                   ((__BASE__) == TIM_DMABASE_CR2) || \
N                                   ((__BASE__) == TIM_DMABASE_SMCR) || \
N                                   ((__BASE__) == TIM_DMABASE_DIER) || \
N                                   ((__BASE__) == TIM_DMABASE_SR) || \
N                                   ((__BASE__) == TIM_DMABASE_EGR) || \
N                                   ((__BASE__) == TIM_DMABASE_CCMR1) || \
N                                   ((__BASE__) == TIM_DMABASE_CCMR2) || \
N                                   ((__BASE__) == TIM_DMABASE_CCER) || \
N                                   ((__BASE__) == TIM_DMABASE_CNT) || \
N                                   ((__BASE__) == TIM_DMABASE_PSC) || \
N                                   ((__BASE__) == TIM_DMABASE_ARR) || \
N                                   ((__BASE__) == TIM_DMABASE_RCR) || \
N                                   ((__BASE__) == TIM_DMABASE_CCR1) || \
N                                   ((__BASE__) == TIM_DMABASE_CCR2) || \
N                                   ((__BASE__) == TIM_DMABASE_CCR3) || \
N                                   ((__BASE__) == TIM_DMABASE_CCR4) || \
N                                   ((__BASE__) == TIM_DMABASE_BDTR) || \
N                                   ((__BASE__) == TIM_DMABASE_DCR) || \
N                                   ((__BASE__) == TIM_DMABASE_OR))
X#define IS_TIM_DMA_BASE(__BASE__) (((__BASE__) == TIM_DMABASE_CR1) ||                                    ((__BASE__) == TIM_DMABASE_CR2) ||                                    ((__BASE__) == TIM_DMABASE_SMCR) ||                                    ((__BASE__) == TIM_DMABASE_DIER) ||                                    ((__BASE__) == TIM_DMABASE_SR) ||                                    ((__BASE__) == TIM_DMABASE_EGR) ||                                    ((__BASE__) == TIM_DMABASE_CCMR1) ||                                    ((__BASE__) == TIM_DMABASE_CCMR2) ||                                    ((__BASE__) == TIM_DMABASE_CCER) ||                                    ((__BASE__) == TIM_DMABASE_CNT) ||                                    ((__BASE__) == TIM_DMABASE_PSC) ||                                    ((__BASE__) == TIM_DMABASE_ARR) ||                                    ((__BASE__) == TIM_DMABASE_RCR) ||                                    ((__BASE__) == TIM_DMABASE_CCR1) ||                                    ((__BASE__) == TIM_DMABASE_CCR2) ||                                    ((__BASE__) == TIM_DMABASE_CCR3) ||                                    ((__BASE__) == TIM_DMABASE_CCR4) ||                                    ((__BASE__) == TIM_DMABASE_BDTR) ||                                    ((__BASE__) == TIM_DMABASE_DCR) ||                                    ((__BASE__) == TIM_DMABASE_OR))
N
N#define IS_TIM_DMA_LENGTH(__LENGTH__) (((__LENGTH__) == TIM_DMABURSTLENGTH_1TRANSFER) || \
N                                       ((__LENGTH__) == TIM_DMABURSTLENGTH_2TRANSFERS) || \
N                                       ((__LENGTH__) == TIM_DMABURSTLENGTH_3TRANSFERS) || \
N                                       ((__LENGTH__) == TIM_DMABURSTLENGTH_4TRANSFERS) || \
N                                       ((__LENGTH__) == TIM_DMABURSTLENGTH_5TRANSFERS) || \
N                                       ((__LENGTH__) == TIM_DMABURSTLENGTH_6TRANSFERS) || \
N                                       ((__LENGTH__) == TIM_DMABURSTLENGTH_7TRANSFERS) || \
N                                       ((__LENGTH__) == TIM_DMABURSTLENGTH_8TRANSFERS) || \
N                                       ((__LENGTH__) == TIM_DMABURSTLENGTH_9TRANSFERS) || \
N                                       ((__LENGTH__) == TIM_DMABURSTLENGTH_10TRANSFERS) || \
N                                       ((__LENGTH__) == TIM_DMABURSTLENGTH_11TRANSFERS) || \
N                                       ((__LENGTH__) == TIM_DMABURSTLENGTH_12TRANSFERS) || \
N                                       ((__LENGTH__) == TIM_DMABURSTLENGTH_13TRANSFERS) || \
N                                       ((__LENGTH__) == TIM_DMABURSTLENGTH_14TRANSFERS) || \
N                                       ((__LENGTH__) == TIM_DMABURSTLENGTH_15TRANSFERS) || \
N                                       ((__LENGTH__) == TIM_DMABURSTLENGTH_16TRANSFERS) || \
N                                       ((__LENGTH__) == TIM_DMABURSTLENGTH_17TRANSFERS) || \
N                                       ((__LENGTH__) == TIM_DMABURSTLENGTH_18TRANSFERS))
X#define IS_TIM_DMA_LENGTH(__LENGTH__) (((__LENGTH__) == TIM_DMABURSTLENGTH_1TRANSFER) ||                                        ((__LENGTH__) == TIM_DMABURSTLENGTH_2TRANSFERS) ||                                        ((__LENGTH__) == TIM_DMABURSTLENGTH_3TRANSFERS) ||                                        ((__LENGTH__) == TIM_DMABURSTLENGTH_4TRANSFERS) ||                                        ((__LENGTH__) == TIM_DMABURSTLENGTH_5TRANSFERS) ||                                        ((__LENGTH__) == TIM_DMABURSTLENGTH_6TRANSFERS) ||                                        ((__LENGTH__) == TIM_DMABURSTLENGTH_7TRANSFERS) ||                                        ((__LENGTH__) == TIM_DMABURSTLENGTH_8TRANSFERS) ||                                        ((__LENGTH__) == TIM_DMABURSTLENGTH_9TRANSFERS) ||                                        ((__LENGTH__) == TIM_DMABURSTLENGTH_10TRANSFERS) ||                                        ((__LENGTH__) == TIM_DMABURSTLENGTH_11TRANSFERS) ||                                        ((__LENGTH__) == TIM_DMABURSTLENGTH_12TRANSFERS) ||                                        ((__LENGTH__) == TIM_DMABURSTLENGTH_13TRANSFERS) ||                                        ((__LENGTH__) == TIM_DMABURSTLENGTH_14TRANSFERS) ||                                        ((__LENGTH__) == TIM_DMABURSTLENGTH_15TRANSFERS) ||                                        ((__LENGTH__) == TIM_DMABURSTLENGTH_16TRANSFERS) ||                                        ((__LENGTH__) == TIM_DMABURSTLENGTH_17TRANSFERS) ||                                        ((__LENGTH__) == TIM_DMABURSTLENGTH_18TRANSFERS))
N
N#define IS_TIM_IC_FILTER(ICFILTER) ((ICFILTER) <= 0xF) 
N
N
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup TIM_Private_Functions TIM Private Functions
N  * @{
N  */
Nvoid TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure);
Nvoid TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection, uint32_t TIM_ICFilter);
Nvoid TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
Nvoid TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
Nvoid TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
Nvoid TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
Nvoid TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler, uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter);
N
Nvoid HAL_TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma);
Xvoid TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma);
Nvoid HAL_TIM_DMAError(DMA_HandleTypeDef *hdma);
Xvoid TIM_DMAError(DMA_HandleTypeDef *hdma);
Nvoid HAL_TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma);
Xvoid TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma);
Nvoid TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState);
N/**
N  * @}
N  */ 
N     
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_TIM_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 375 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_TIM_MODULE_ENABLED */
N
N#ifdef HAL_UART_MODULE_ENABLED
N #include "stm32f7xx_hal_uart.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_uart.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_uart.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of UART HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************  
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_UART_H
N#define __STM32F7xx_HAL_UART_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup UART
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup UART_Exported_Types UART Exported Types
N  * @{
N  */
N
N/**
N  * @brief UART Init Structure definition
N  */
Ntypedef struct
N{
N  uint32_t BaudRate;                  /*!< This member configures the UART communication baud rate.
N                                           The baud rate register is computed using the following formula:
N                                           - If oversampling is 16 or in LIN mode,
N                                              Baud Rate Register = ((PCLKx) / ((huart->Init.BaudRate)))
N                                           - If oversampling is 8,
N                                              Baud Rate Register[15:4] = ((2 * PCLKx) / ((huart->Init.BaudRate)))[15:4]
N                                              Baud Rate Register[3] =  0
N                                              Baud Rate Register[2:0] =  (((2 * PCLKx) / ((huart->Init.BaudRate)))[3:0]) >> 1      */
N
N  uint32_t WordLength;                /*!< Specifies the number of data bits transmitted or received in a frame.
N                                           This parameter can be a value of @ref UARTEx_Word_Length */
N
N  uint32_t StopBits;                  /*!< Specifies the number of stop bits transmitted.
N                                           This parameter can be a value of @ref UART_Stop_Bits */
N
N  uint32_t Parity;                    /*!< Specifies the parity mode.
N                                           This parameter can be a value of @ref UART_Parity
N                                           @note When parity is enabled, the computed parity is inserted
N                                                 at the MSB position of the transmitted data (9th bit when
N                                                 the word length is set to 9 data bits; 8th bit when the
N                                                 word length is set to 8 data bits). */
N
N  uint32_t Mode;                      /*!< Specifies whether the Receive or Transmit mode is enabled or disabled.
N                                           This parameter can be a value of @ref UART_Mode */
N
N  uint32_t HwFlowCtl;                 /*!< Specifies whether the hardware flow control mode is enabled
N                                           or disabled.
N                                           This parameter can be a value of @ref UART_Hardware_Flow_Control */
N
N  uint32_t OverSampling;              /*!< Specifies whether the Over sampling 8 is enabled or disabled, to achieve higher speed (up to fPCLK/8).
N                                           This parameter can be a value of @ref UART_Over_Sampling */
N
N  uint32_t OneBitSampling;            /*!< Specifies whether a single sample or three samples' majority vote is selected.
N                                           Selecting the single sample method increases the receiver tolerance to clock
N                                           deviations. This parameter can be a value of @ref UART_OneBit_Sampling */
N}UART_InitTypeDef;
N
N/**
N  * @brief  UART Advanced Features initialization structure definition
N  */
Ntypedef struct
N{
N  uint32_t AdvFeatureInit;        /*!< Specifies which advanced UART features is initialized. Several
N                                       Advanced Features may be initialized at the same time .
N                                       This parameter can be a value of @ref UART_Advanced_Features_Initialization_Type */
N
N  uint32_t TxPinLevelInvert;      /*!< Specifies whether the TX pin active level is inverted.
N                                       This parameter can be a value of @ref UART_Tx_Inv  */
N
N  uint32_t RxPinLevelInvert;      /*!< Specifies whether the RX pin active level is inverted.
N                                       This parameter can be a value of @ref UART_Rx_Inv  */
N
N  uint32_t DataInvert;            /*!< Specifies whether data are inverted (positive/direct logic
N                                       vs negative/inverted logic).
N                                       This parameter can be a value of @ref UART_Data_Inv */
N
N  uint32_t Swap;                  /*!< Specifies whether TX and RX pins are swapped.
N                                       This parameter can be a value of @ref UART_Rx_Tx_Swap */
N
N  uint32_t OverrunDisable;        /*!< Specifies whether the reception overrun detection is disabled.
N                                       This parameter can be a value of @ref UART_Overrun_Disable */
N
N  uint32_t DMADisableonRxError;   /*!< Specifies whether the DMA is disabled in case of reception error.
N                                       This parameter can be a value of @ref UART_DMA_Disable_on_Rx_Error */
N
N  uint32_t AutoBaudRateEnable;    /*!< Specifies whether auto Baud rate detection is enabled.
N                                       This parameter can be a value of @ref UART_AutoBaudRate_Enable */
N
N  uint32_t AutoBaudRateMode;      /*!< If auto Baud rate detection is enabled, specifies how the rate
N                                       detection is carried out.
N                                       This parameter can be a value of @ref UART_AutoBaud_Rate_Mode */
N
N  uint32_t MSBFirst;              /*!< Specifies whether MSB is sent first on UART line.
N                                       This parameter can be a value of @ref UART_MSB_First */
N} UART_AdvFeatureInitTypeDef;
N
N
N
N/**
N  * @brief HAL UART State structures definition
N  * @note  HAL UART State value is a combination of 2 different substates: gState and RxState.
N  *        - gState contains UART state information related to global Handle management 
N  *          and also information related to Tx operations.
N  *          gState value coding follow below described bitmap :
N  *          b7-b6  Error information 
N  *             00 : No Error
N  *             01 : (Not Used)
N  *             10 : Timeout
N  *             11 : Error
N  *          b5     IP initilisation status
N  *             0  : Reset (IP not initialized)
N  *             1  : Init done (IP not initialized. HAL UART Init function already called)
N  *          b4-b3  (not used)
N  *             xx : Should be set to 00
N  *          b2     Intrinsic process state
N  *             0  : Ready
N  *             1  : Busy (IP busy with some configuration or internal operations)
N  *          b1     (not used)
N  *             x  : Should be set to 0
N  *          b0     Tx state
N  *             0  : Ready (no Tx operation ongoing)
N  *             1  : Busy (Tx operation ongoing)
N  *        - RxState contains information related to Rx operations.
N  *          RxState value coding follow below described bitmap :
N  *          b7-b6  (not used)
N  *             xx : Should be set to 00
N  *          b5     IP initilisation status
N  *             0  : Reset (IP not initialized)
N  *             1  : Init done (IP not initialized)
N  *          b4-b2  (not used)
N  *            xxx : Should be set to 000
N  *          b1     Rx state
N  *             0  : Ready (no Rx operation ongoing)
N  *             1  : Busy (Rx operation ongoing)
N  *          b0     (not used)
N  *             x  : Should be set to 0.
N  */
Ntypedef enum
N{
N  HAL_UART_STATE_RESET             = 0x00U,   /*!< Peripheral is not initialized
N                                                   Value is allowed for gState and RxState */
N  HAL_UART_STATE_READY             = 0x20U,   /*!< Peripheral Initialized and ready for use
N                                                   Value is allowed for gState and RxState */
N  HAL_UART_STATE_BUSY              = 0x24U,   /*!< an internal process is ongoing 
N                                                   Value is allowed for gState only */
N  HAL_UART_STATE_BUSY_TX           = 0x21U,   /*!< Data Transmission process is ongoing
N                                                   Value is allowed for gState only */
N  HAL_UART_STATE_BUSY_RX           = 0x22U,   /*!< Data Reception process is ongoing
N                                                   Value is allowed for RxState only */
N  HAL_UART_STATE_BUSY_TX_RX        = 0x23U,   /*!< Data Transmission and Reception process is ongoing
N                                                   Not to be used for neither gState nor RxState.
N                                                   Value is result of combination (Or) between gState and RxState values */
N  HAL_UART_STATE_TIMEOUT           = 0xA0U,   /*!< Timeout state
N                                                   Value is allowed for gState only */
N  HAL_UART_STATE_ERROR             = 0xE0U    /*!< Error
N                                                   Value is allowed for gState only */
N}HAL_UART_StateTypeDef;
N
N/**
N  * @brief UART clock sources definition
N  */
Ntypedef enum
N{
N  UART_CLOCKSOURCE_PCLK1      = 0x00U,    /*!< PCLK1 clock source  */
N  UART_CLOCKSOURCE_PCLK2      = 0x01U,    /*!< PCLK2 clock source  */
N  UART_CLOCKSOURCE_HSI        = 0x02U,    /*!< HSI clock source    */
N  UART_CLOCKSOURCE_SYSCLK     = 0x04U,    /*!< SYSCLK clock source */
N  UART_CLOCKSOURCE_LSE        = 0x08U,    /*!< LSE clock source       */
N  UART_CLOCKSOURCE_UNDEFINED  = 0x10U     /*!< Undefined clock source */
N}UART_ClockSourceTypeDef;
N
N/**
N  * @brief  UART handle Structure definition
N  */
Ntypedef struct
N{
N  USART_TypeDef            *Instance;        /*!< UART registers base address        */
N
N  UART_InitTypeDef         Init;             /*!< UART communication parameters      */
N
N  UART_AdvFeatureInitTypeDef AdvancedInit;   /*!< UART Advanced Features initialization parameters */
N
N  uint8_t                  *pTxBuffPtr;      /*!< Pointer to UART Tx transfer Buffer */
N
N  uint16_t                 TxXferSize;       /*!< UART Tx Transfer size              */
N
N  uint16_t                 TxXferCount;      /*!< UART Tx Transfer Counter           */
N
N  uint8_t                  *pRxBuffPtr;      /*!< Pointer to UART Rx transfer Buffer */
N
N  uint16_t                 RxXferSize;       /*!< UART Rx Transfer size              */
N
N  uint16_t                 RxXferCount;      /*!< UART Rx Transfer Counter           */
N
N  uint16_t                 Mask;             /*!< UART Rx RDR register mask          */
N
N  DMA_HandleTypeDef        *hdmatx;          /*!< UART Tx DMA Handle parameters      */
N
N  DMA_HandleTypeDef        *hdmarx;          /*!< UART Rx DMA Handle parameters      */
N
N  HAL_LockTypeDef           Lock;            /*!< Locking object                     */
N
N  __IO HAL_UART_StateTypeDef    gState;      /*!< UART state information related to global Handle management 
X  volatile HAL_UART_StateTypeDef    gState;      
N                                                  and also related to Tx operations.
N                                                  This parameter can be a value of @ref HAL_UART_StateTypeDef */
N
N  __IO HAL_UART_StateTypeDef    RxState;     /*!< UART state information related to Rx operations.
X  volatile HAL_UART_StateTypeDef    RxState;     
N                                                  This parameter can be a value of @ref HAL_UART_StateTypeDef */
N
N  __IO uint32_t             ErrorCode;   /*!< UART Error code                    */
X  volatile uint32_t             ErrorCode;    
N
N}UART_HandleTypeDef;
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup UART_Exported_Constants UART Exported Constants
N  * @{
N  */
N/** @defgroup UART_Error_Definition   UART Error Definition
N  * @{
N  */
N#define  HAL_UART_ERROR_NONE       ((uint32_t)0x00000000U)    /*!< No error            */
N#define  HAL_UART_ERROR_PE         ((uint32_t)0x00000001U)    /*!< Parity error        */
N#define  HAL_UART_ERROR_NE         ((uint32_t)0x00000002U)    /*!< Noise error         */
N#define  HAL_UART_ERROR_FE         ((uint32_t)0x00000004U)    /*!< frame error         */
N#define  HAL_UART_ERROR_ORE        ((uint32_t)0x00000008U)    /*!< Overrun error       */
N#define  HAL_UART_ERROR_DMA        ((uint32_t)0x00000010U)    /*!< DMA transfer error  */
N/**
N  * @}
N  */
N/** @defgroup UART_Stop_Bits   UART Number of Stop Bits
N  * @{
N  */
N#define UART_STOPBITS_1                     ((uint32_t)0x00000000U)
N#define UART_STOPBITS_2                     ((uint32_t)USART_CR2_STOP_1)
N/**
N  * @}
N  */
N
N/** @defgroup UART_Parity  UART Parity
N  * @{
N  */
N#define UART_PARITY_NONE                    ((uint32_t)0x00000000U)
N#define UART_PARITY_EVEN                    ((uint32_t)USART_CR1_PCE)
N#define UART_PARITY_ODD                     ((uint32_t)(USART_CR1_PCE | USART_CR1_PS))
N/**
N  * @}
N  */
N
N/** @defgroup UART_Hardware_Flow_Control UART Hardware Flow Control
N  * @{
N  */
N#define UART_HWCONTROL_NONE                  ((uint32_t)0x00000000U)
N#define UART_HWCONTROL_RTS                   ((uint32_t)USART_CR3_RTSE)
N#define UART_HWCONTROL_CTS                   ((uint32_t)USART_CR3_CTSE)
N#define UART_HWCONTROL_RTS_CTS               ((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE))
N/**
N  * @}
N  */
N
N/** @defgroup UART_Mode UART Transfer Mode
N  * @{
N  */
N#define UART_MODE_RX                        ((uint32_t)USART_CR1_RE)
N#define UART_MODE_TX                        ((uint32_t)USART_CR1_TE)
N#define UART_MODE_TX_RX                     ((uint32_t)(USART_CR1_TE |USART_CR1_RE))
N/**
N  * @}
N  */
N
N /** @defgroup UART_State  UART State
N  * @{
N  */
N#define UART_STATE_DISABLE                  ((uint32_t)0x00000000U)
N#define UART_STATE_ENABLE                   ((uint32_t)USART_CR1_UE)
N/**
N  * @}
N  */
N
N/** @defgroup UART_Over_Sampling UART Over Sampling
N  * @{
N  */
N#define UART_OVERSAMPLING_16                ((uint32_t)0x00000000U)
N#define UART_OVERSAMPLING_8                 ((uint32_t)USART_CR1_OVER8)
N/**
N  * @}
N  */
N
N/** @defgroup UART_OneBit_Sampling UART One Bit Sampling Method
N  * @{
N  */
N#define UART_ONE_BIT_SAMPLE_DISABLE         ((uint32_t)0x00000000U)
N#define UART_ONE_BIT_SAMPLE_ENABLE          ((uint32_t)USART_CR3_ONEBIT)
N/**
N  * @}
N  */
N
N/** @defgroup UART_AutoBaud_Rate_Mode    UART Advanced Feature AutoBaud Rate Mode
N  * @{
N  */
N#define UART_ADVFEATURE_AUTOBAUDRATE_ONSTARTBIT    ((uint32_t)0x0000U)
N#define UART_ADVFEATURE_AUTOBAUDRATE_ONFALLINGEDGE ((uint32_t)USART_CR2_ABRMODE_0)
N#define UART_ADVFEATURE_AUTOBAUDRATE_ON0X7FFRAME   ((uint32_t)USART_CR2_ABRMODE_1)
N#define UART_ADVFEATURE_AUTOBAUDRATE_ON0X55FRAME   ((uint32_t)USART_CR2_ABRMODE)
N/**
N  * @}
N  */
N
N/** @defgroup UART_Receiver_TimeOut UART Receiver TimeOut
N  * @{
N  */
N#define UART_RECEIVER_TIMEOUT_DISABLE       ((uint32_t)0x00000000U)
N#define UART_RECEIVER_TIMEOUT_ENABLE        ((uint32_t)USART_CR2_RTOEN)
N/**
N  * @}
N  */
N
N/** @defgroup UART_LIN    UART Local Interconnection Network mode
N  * @{
N  */
N#define UART_LIN_DISABLE                    ((uint32_t)0x00000000U)
N#define UART_LIN_ENABLE                     ((uint32_t)USART_CR2_LINEN)
N/**
N  * @}
N  */
N
N/** @defgroup UART_LIN_Break_Detection  UART LIN Break Detection
N  * @{
N  */
N#define UART_LINBREAKDETECTLENGTH_10B       ((uint32_t)0x00000000U)
N#define UART_LINBREAKDETECTLENGTH_11B       ((uint32_t)USART_CR2_LBDL)
N/**
N  * @}
N  */
N
N/** @defgroup UART_DMA_Tx    UART DMA Tx
N  * @{
N  */
N#define UART_DMA_TX_DISABLE                 ((uint32_t)0x00000000U)
N#define UART_DMA_TX_ENABLE                  ((uint32_t)USART_CR3_DMAT)
N/**
N  * @}
N  */
N
N/** @defgroup UART_DMA_Rx   UART DMA Rx
N  * @{
N  */
N#define UART_DMA_RX_DISABLE                 ((uint32_t)0x0000U)
N#define UART_DMA_RX_ENABLE                  ((uint32_t)USART_CR3_DMAR)
N/**
N  * @}
N  */
N
N/** @defgroup UART_Half_Duplex_Selection  UART Half Duplex Selection
N  * @{
N  */
N#define UART_HALF_DUPLEX_DISABLE            ((uint32_t)0x0000U)
N#define UART_HALF_DUPLEX_ENABLE             ((uint32_t)USART_CR3_HDSEL)
N/**
N  * @}
N  */
N
N/** @defgroup UART_WakeUp_Methods   UART WakeUp Methods
N  * @{
N  */
N#define UART_WAKEUPMETHOD_IDLELINE          ((uint32_t)0x00000000U)
N#define UART_WAKEUPMETHOD_ADDRESSMARK       ((uint32_t)USART_CR1_WAKE)
N/**
N  * @}
N  */
N
N/** @defgroup UART_Request_Parameters UART Request Parameters
N  * @{
N  */
N#define UART_AUTOBAUD_REQUEST               ((uint32_t)USART_RQR_ABRRQ)        /*!< Auto-Baud Rate Request */
N#define UART_SENDBREAK_REQUEST              ((uint32_t)USART_RQR_SBKRQ)        /*!< Send Break Request */
N#define UART_MUTE_MODE_REQUEST              ((uint32_t)USART_RQR_MMRQ)         /*!< Mute Mode Request */
N#define UART_RXDATA_FLUSH_REQUEST           ((uint32_t)USART_RQR_RXFRQ)        /*!< Receive Data flush Request */
N#define UART_TXDATA_FLUSH_REQUEST           ((uint32_t)USART_RQR_TXFRQ)        /*!< Transmit data flush Request */
N/**
N  * @}
N  */
N
N/** @defgroup UART_Advanced_Features_Initialization_Type  UART Advanced Feature Initialization Type
N  * @{
N  */
N#define UART_ADVFEATURE_NO_INIT                 ((uint32_t)0x00000000U)
N#define UART_ADVFEATURE_TXINVERT_INIT           ((uint32_t)0x00000001U)
N#define UART_ADVFEATURE_RXINVERT_INIT           ((uint32_t)0x00000002U)
N#define UART_ADVFEATURE_DATAINVERT_INIT         ((uint32_t)0x00000004U)
N#define UART_ADVFEATURE_SWAP_INIT               ((uint32_t)0x00000008U)
N#define UART_ADVFEATURE_RXOVERRUNDISABLE_INIT   ((uint32_t)0x00000010U)
N#define UART_ADVFEATURE_DMADISABLEONERROR_INIT  ((uint32_t)0x00000020U)
N#define UART_ADVFEATURE_AUTOBAUDRATE_INIT       ((uint32_t)0x00000040U)
N#define UART_ADVFEATURE_MSBFIRST_INIT           ((uint32_t)0x00000080U)
N/**
N  * @}
N  */
N
N/** @defgroup UART_Tx_Inv UART Advanced Feature TX Pin Active Level Inversion
N  * @{
N  */
N#define UART_ADVFEATURE_TXINV_DISABLE       ((uint32_t)0x00000000U)
N#define UART_ADVFEATURE_TXINV_ENABLE        ((uint32_t)USART_CR2_TXINV)
N/**
N  * @}
N  */
N
N/** @defgroup UART_Rx_Inv UART Advanced Feature RX Pin Active Level Inversion
N  * @{
N  */
N#define UART_ADVFEATURE_RXINV_DISABLE       ((uint32_t)0x00000000U)
N#define UART_ADVFEATURE_RXINV_ENABLE        ((uint32_t)USART_CR2_RXINV)
N/**
N  * @}
N  */
N
N/** @defgroup UART_Data_Inv  UART Advanced Feature Binary Data Inversion
N  * @{
N  */
N#define UART_ADVFEATURE_DATAINV_DISABLE     ((uint32_t)0x00000000U)
N#define UART_ADVFEATURE_DATAINV_ENABLE      ((uint32_t)USART_CR2_DATAINV)
N/**
N  * @}
N  */
N
N/** @defgroup UART_Rx_Tx_Swap UART Advanced Feature RX TX Pins Swap
N  * @{
N  */
N#define UART_ADVFEATURE_SWAP_DISABLE        ((uint32_t)0x00000000U)
N#define UART_ADVFEATURE_SWAP_ENABLE         ((uint32_t)USART_CR2_SWAP)
N/**
N  * @}
N  */
N
N/** @defgroup UART_Overrun_Disable  UART Advanced Feature Overrun Disable
N  * @{
N  */
N#define UART_ADVFEATURE_OVERRUN_ENABLE      ((uint32_t)0x00000000U)
N#define UART_ADVFEATURE_OVERRUN_DISABLE     ((uint32_t)USART_CR3_OVRDIS)
N/**
N  * @}
N  */
N
N/** @defgroup UART_AutoBaudRate_Enable  UART Advanced Feature Auto BaudRate Enable
N  * @{
N  */
N#define UART_ADVFEATURE_AUTOBAUDRATE_DISABLE   ((uint32_t)0x00000000U)
N#define UART_ADVFEATURE_AUTOBAUDRATE_ENABLE    ((uint32_t)USART_CR2_ABREN)
N/**
N  * @}
N  */
N
N/** @defgroup UART_DMA_Disable_on_Rx_Error   UART Advanced Feature DMA Disable On Rx Error
N  * @{
N  */
N#define UART_ADVFEATURE_DMA_ENABLEONRXERROR    ((uint32_t)0x00000000U)
N#define UART_ADVFEATURE_DMA_DISABLEONRXERROR   ((uint32_t)USART_CR3_DDRE)
N/**
N  * @}
N  */
N
N/** @defgroup UART_MSB_First   UART Advanced Feature MSB First
N  * @{
N  */
N#define UART_ADVFEATURE_MSBFIRST_DISABLE    ((uint32_t)0x00000000U)
N#define UART_ADVFEATURE_MSBFIRST_ENABLE     ((uint32_t)USART_CR2_MSBFIRST)
N/**
N  * @}
N  */
N
N/** @defgroup UART_Mute_Mode   UART Advanced Feature Mute Mode Enable
N  * @{
N  */
N#define UART_ADVFEATURE_MUTEMODE_DISABLE    ((uint32_t)0x00000000U)
N#define UART_ADVFEATURE_MUTEMODE_ENABLE     ((uint32_t)USART_CR1_MME)
N/**
N  * @}
N  */
N
N/** @defgroup UART_CR2_ADDRESS_LSB_POS    UART Address-matching LSB Position In CR2 Register
N  * @{
N  */
N#define UART_CR2_ADDRESS_LSB_POS            ((uint32_t) 24U)
N/**
N  * @}
N  */
N
N/** @defgroup UART_DriverEnable_Polarity      UART DriverEnable Polarity
N  * @{
N  */
N#define UART_DE_POLARITY_HIGH               ((uint32_t)0x00000000U)
N#define UART_DE_POLARITY_LOW                ((uint32_t)USART_CR3_DEP)
N/**
N  * @}
N  */
N
N/** @defgroup UART_CR1_DEAT_ADDRESS_LSB_POS    UART Driver Enable Assertion Time LSB Position In CR1 Register
N  * @{
N  */
N#define UART_CR1_DEAT_ADDRESS_LSB_POS       ((uint32_t) 21U)
N/**
N  * @}
N  */
N
N/** @defgroup UART_CR1_DEDT_ADDRESS_LSB_POS    UART Driver Enable DeAssertion Time LSB Position In CR1 Register
N  * @{
N  */
N#define UART_CR1_DEDT_ADDRESS_LSB_POS       ((uint32_t) 16U)
N/**
N  * @}
N  */
N
N/** @defgroup UART_Interruption_Mask    UART Interruptions Flag Mask
N  * @{
N  */
N#define UART_IT_MASK                        ((uint32_t)0x001FU)
N/**
N  * @}
N  */
N
N/** @defgroup UART_TimeOut_Value    UART polling-based communications time-out value
N  * @{
N  */
N#define HAL_UART_TIMEOUT_VALUE              0x1FFFFFFU
N/**
N  * @}
N  */
N
N/** @defgroup UART_Flags     UART Status Flags
N  *        Elements values convention: 0xXXXX
N  *           - 0xXXXX  : Flag mask in the ISR register
N  * @{
N  */
N#define UART_FLAG_TEACK                     ((uint32_t)0x00200000U)
N#define UART_FLAG_SBKF                      ((uint32_t)0x00040000U)
N#define UART_FLAG_CMF                       ((uint32_t)0x00020000U)
N#define UART_FLAG_BUSY                      ((uint32_t)0x00010000U)
N#define UART_FLAG_ABRF                      ((uint32_t)0x00008000U)
N#define UART_FLAG_ABRE                      ((uint32_t)0x00004000U)
N#define UART_FLAG_EOBF                      ((uint32_t)0x00001000U)
N#define UART_FLAG_RTOF                      ((uint32_t)0x00000800U)
N#define UART_FLAG_CTS                       ((uint32_t)0x00000400U)
N#define UART_FLAG_CTSIF                     ((uint32_t)0x00000200U)
N#define UART_FLAG_LBDF                      ((uint32_t)0x00000100U)
N#define UART_FLAG_TXE                       ((uint32_t)0x00000080U)
N#define UART_FLAG_TC                        ((uint32_t)0x00000040U)
N#define UART_FLAG_RXNE                      ((uint32_t)0x00000020U)
N#define UART_FLAG_IDLE                      ((uint32_t)0x00000010U)
N#define UART_FLAG_ORE                       ((uint32_t)0x00000008U)
N#define UART_FLAG_NE                        ((uint32_t)0x00000004U)
N#define UART_FLAG_FE                        ((uint32_t)0x00000002U)
N#define UART_FLAG_PE                        ((uint32_t)0x00000001U)
N/**
N  * @}
N  */
N
N/** @defgroup UART_Interrupt_definition   UART Interrupts Definition
N  *        Elements values convention: 0000ZZZZ0XXYYYYYb
N  *           - YYYYY  : Interrupt source position in the XX register (5bits)
N  *           - XX  : Interrupt source register (2bits)
N  *                 - 01: CR1 register
N  *                 - 10: CR2 register
N  *                 - 11: CR3 register
N  *           - ZZZZ  : Flag position in the ISR register(4bits)
N  * @{
N  */
N#define UART_IT_PE                          ((uint32_t)0x0028U)
N#define UART_IT_TXE                         ((uint32_t)0x0727U)
N#define UART_IT_TC                          ((uint32_t)0x0626U)
N#define UART_IT_RXNE                        ((uint32_t)0x0525U)
N#define UART_IT_IDLE                        ((uint32_t)0x0424U)
N#define UART_IT_LBD                         ((uint32_t)0x0846U)
N#define UART_IT_CTS                         ((uint32_t)0x096AU)
N#define UART_IT_CM                          ((uint32_t)0x112EU)
N
N/**       Elements values convention: 000000000XXYYYYYb
N  *           - YYYYY  : Interrupt source position in the XX register (5bits)
N  *           - XX  : Interrupt source register (2bits)
N  *                 - 01: CR1 register
N  *                 - 10: CR2 register
N  *                 - 11: CR3 register
N  */
N#define UART_IT_ERR                         ((uint32_t)0x0060U)
N
N/**       Elements values convention: 0000ZZZZ00000000b
N  *           - ZZZZ  : Flag position in the ISR register(4bits)
N  */
N#define UART_IT_ORE                         ((uint32_t)0x0300U)
N#define UART_IT_NE                          ((uint32_t)0x0200U)
N#define UART_IT_FE                          ((uint32_t)0x0100U)
N/**
N  * @}
N  */
N
N/** @defgroup UART_IT_CLEAR_Flags  UART Interruption Clear Flags
N  * @{
N  */
N#define UART_CLEAR_PEF                       USART_ICR_PECF            /*!< Parity Error Clear Flag */
N#define UART_CLEAR_FEF                       USART_ICR_FECF            /*!< Framing Error Clear Flag */
N#define UART_CLEAR_NEF                       USART_ICR_NCF             /*!< Noise detected Clear Flag */
N#define UART_CLEAR_OREF                      USART_ICR_ORECF           /*!< OverRun Error Clear Flag */
N#define UART_CLEAR_IDLEF                     USART_ICR_IDLECF          /*!< IDLE line detected Clear Flag */
N#define UART_CLEAR_TCF                       USART_ICR_TCCF            /*!< Transmission Complete Clear Flag */
N#define UART_CLEAR_LBDF                      USART_ICR_LBDCF           /*!< LIN Break Detection Clear Flag */
N#define UART_CLEAR_CTSF                      USART_ICR_CTSCF           /*!< CTS Interrupt Clear Flag */
N#define UART_CLEAR_RTOF                      USART_ICR_RTOCF           /*!< Receiver Time Out Clear Flag */
N#define UART_CLEAR_EOBF                      USART_ICR_EOBCF           /*!< End Of Block Clear Flag */
N#define UART_CLEAR_CMF                       USART_ICR_CMCF            /*!< Character Match Clear Flag */
N/**
N  * @}
N  */
N
N
N/**
N  * @}
N  */
N
N/* Exported macros -----------------------------------------------------------*/
N/** @defgroup UART_Exported_Macros UART Exported Macros
N  * @{
N  */
N
N/** @brief Reset UART handle state
N  * @param  __HANDLE__: UART handle.
N  * @retval None
N  */
N#define __HAL_UART_RESET_HANDLE_STATE(__HANDLE__)  do{                                                   \
N                                                       (__HANDLE__)->gState = HAL_UART_STATE_RESET;      \
N                                                       (__HANDLE__)->RxState = HAL_UART_STATE_RESET;     \
N                                                     } while(0)
X#define __HAL_UART_RESET_HANDLE_STATE(__HANDLE__)  do{                                                                                                          (__HANDLE__)->gState = HAL_UART_STATE_RESET;                                                             (__HANDLE__)->RxState = HAL_UART_STATE_RESET;                                                          } while(0)
N
N/** @brief  Flush the UART Data registers
N  * @param  __HANDLE__: specifies the UART Handle.
N  */
N#define __HAL_UART_FLUSH_DRREGISTER(__HANDLE__)  \
N  do{                \
N      SET_BIT((__HANDLE__)->Instance->RQR, UART_RXDATA_FLUSH_REQUEST); \
N      SET_BIT((__HANDLE__)->Instance->RQR, UART_TXDATA_FLUSH_REQUEST); \
N    }  while(0)
X#define __HAL_UART_FLUSH_DRREGISTER(__HANDLE__)    do{                      SET_BIT((__HANDLE__)->Instance->RQR, UART_RXDATA_FLUSH_REQUEST);       SET_BIT((__HANDLE__)->Instance->RQR, UART_TXDATA_FLUSH_REQUEST);     }  while(0)
N
N/** @brief  Clears the specified UART ISR flag, in setting the proper ICR register flag.
N  * @param  __HANDLE__: specifies the UART Handle.
N  * @param  __FLAG__: specifies the interrupt clear register flag that needs to be set
N  *                       to clear the corresponding interrupt
N  *          This parameter can be one of the following values:
N  *            @arg UART_CLEAR_PEF: Parity Error Clear Flag
N  *            @arg UART_CLEAR_FEF: Framing Error Clear Flag
N  *            @arg UART_CLEAR_NEF: Noise detected Clear Flag
N  *            @arg UART_CLEAR_OREF: OverRun Error Clear Flag
N  *            @arg UART_CLEAR_IDLEF: IDLE line detected Clear Flag
N  *            @arg UART_CLEAR_TCF: Transmission Complete Clear Flag
N  *            @arg UART_CLEAR_LBDF: LIN Break Detection Clear Flag
N  *            @arg UART_CLEAR_CTSF: CTS Interrupt Clear Flag
N  *            @arg UART_CLEAR_RTOF: Receiver Time Out Clear Flag
N  *            @arg UART_CLEAR_EOBF: End Of Block Clear Flag
N  *            @arg UART_CLEAR_CMF: Character Match Clear Flag
N  * @retval None
N  */
N#define __HAL_UART_CLEAR_IT(__HANDLE__, __FLAG__) ((__HANDLE__)->Instance->ICR = (uint32_t)(__FLAG__))
N
N/** @brief  Clear the UART PE pending flag.
N  * @param  __HANDLE__: specifies the UART Handle.
N  * @retval None
N  */
N#define __HAL_UART_CLEAR_PEFLAG(__HANDLE__)   __HAL_UART_CLEAR_IT((__HANDLE__),UART_CLEAR_PEF)
N
N/** @brief  Clear the UART FE pending flag.
N  * @param  __HANDLE__: specifies the UART Handle.
N  * @retval None
N  */
N#define __HAL_UART_CLEAR_FEFLAG(__HANDLE__)   __HAL_UART_CLEAR_IT((__HANDLE__),UART_CLEAR_FEF)
N
N/** @brief  Clear the UART NE pending flag.
N  * @param  __HANDLE__: specifies the UART Handle.
N  * @retval None
N  */
N#define __HAL_UART_CLEAR_NEFLAG(__HANDLE__)  __HAL_UART_CLEAR_IT((__HANDLE__),UART_CLEAR_NEF)
N
N/** @brief  Clear the UART ORE pending flag.
N  * @param  __HANDLE__: specifies the UART Handle.
N  * @retval None
N  */
N#define __HAL_UART_CLEAR_OREFLAG(__HANDLE__)   __HAL_UART_CLEAR_IT((__HANDLE__),UART_CLEAR_OREF)
N
N/** @brief  Clear the UART IDLE pending flag.
N  * @param  __HANDLE__: specifies the UART Handle.
N  * @retval None
N  */
N#define __HAL_UART_CLEAR_IDLEFLAG(__HANDLE__)   __HAL_UART_CLEAR_IT((__HANDLE__),UART_CLEAR_IDLEF)
N
N/** @brief  Checks whether the specified UART flag is set or not.
N  * @param  __HANDLE__: specifies the UART Handle.
N  * @param  __FLAG__: specifies the flag to check.
N  *        This parameter can be one of the following values:
N  *            @arg UART_FLAG_REACK: Receive enable acknowledge flag
N  *            @arg UART_FLAG_TEACK: Transmit enable acknowledge flag
N  *            @arg UART_FLAG_WUF:   Wake up from stop mode flag
N  *            @arg UART_FLAG_RWU:   Receiver wake up flag (is the UART in mute mode)
N  *            @arg UART_FLAG_SBKF:  Send Break flag
N  *            @arg UART_FLAG_CMF:   Character match flag
N  *            @arg UART_FLAG_BUSY:  Busy flag
N  *            @arg UART_FLAG_ABRF:  Auto Baud rate detection flag
N  *            @arg UART_FLAG_ABRE:  Auto Baud rate detection error flag
N  *            @arg UART_FLAG_EOBF:  End of block flag
N  *            @arg UART_FLAG_RTOF:  Receiver timeout flag
N  *            @arg UART_FLAG_CTS:   CTS Change flag (not available for UART4 and UART5)
N  *            @arg UART_FLAG_LBD:   LIN Break detection flag
N  *            @arg UART_FLAG_TXE:   Transmit data register empty flag
N  *            @arg UART_FLAG_TC:    Transmission Complete flag
N  *            @arg UART_FLAG_RXNE:  Receive data register not empty flag
N  *            @arg UART_FLAG_IDLE:  Idle Line detection flag
N  *            @arg UART_FLAG_ORE:   OverRun Error flag
N  *            @arg UART_FLAG_NE:    Noise Error flag
N  *            @arg UART_FLAG_FE:    Framing Error flag
N  *            @arg UART_FLAG_PE:    Parity Error flag
N  * @retval The new state of __FLAG__ (TRUE or FALSE).
N  */
N#define __HAL_UART_GET_FLAG(__HANDLE__, __FLAG__) (((__HANDLE__)->Instance->ISR & (__FLAG__)) == (__FLAG__))
N
N/** @brief  Enables the specified UART interrupt.
N  * @param  __HANDLE__: specifies the UART Handle.
N  * @param  __INTERRUPT__: specifies the UART interrupt source to enable.
N  *          This parameter can be one of the following values:
N  *            @arg UART_IT_WUF:  Wakeup from stop mode interrupt
N  *            @arg UART_IT_CM:   Character match interrupt
N  *            @arg UART_IT_CTS:  CTS change interrupt
N  *            @arg UART_IT_LBD:  LIN Break detection interrupt
N  *            @arg UART_IT_TXE:  Transmit Data Register empty interrupt
N  *            @arg UART_IT_TC:   Transmission complete interrupt
N  *            @arg UART_IT_RXNE: Receive Data register not empty interrupt
N  *            @arg UART_IT_IDLE: Idle line detection interrupt
N  *            @arg UART_IT_PE:   Parity Error interrupt
N  *            @arg UART_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
N  * @retval None
N  */
N#define __HAL_UART_ENABLE_IT(__HANDLE__, __INTERRUPT__)   (((((uint8_t)(__INTERRUPT__)) >> 5U) == 1)? ((__HANDLE__)->Instance->CR1 |= (1U << ((__INTERRUPT__) & UART_IT_MASK))): \
N                                                           ((((uint8_t)(__INTERRUPT__)) >> 5U) == 2)? ((__HANDLE__)->Instance->CR2 |= (1U << ((__INTERRUPT__) & UART_IT_MASK))): \
N                                                           ((__HANDLE__)->Instance->CR3 |= (1U << ((__INTERRUPT__) & UART_IT_MASK))))
X#define __HAL_UART_ENABLE_IT(__HANDLE__, __INTERRUPT__)   (((((uint8_t)(__INTERRUPT__)) >> 5U) == 1)? ((__HANDLE__)->Instance->CR1 |= (1U << ((__INTERRUPT__) & UART_IT_MASK))):                                                            ((((uint8_t)(__INTERRUPT__)) >> 5U) == 2)? ((__HANDLE__)->Instance->CR2 |= (1U << ((__INTERRUPT__) & UART_IT_MASK))):                                                            ((__HANDLE__)->Instance->CR3 |= (1U << ((__INTERRUPT__) & UART_IT_MASK))))
N
N
N/** @brief  Disables the specified UART interrupt.
N  * @param  __HANDLE__: specifies the UART Handle.
N  * @param  __INTERRUPT__: specifies the UART interrupt source to disable.
N  *          This parameter can be one of the following values:
N  *            @arg UART_IT_CM:   Character match interrupt
N  *            @arg UART_IT_CTS:  CTS change interrupt
N  *            @arg UART_IT_LBD:  LIN Break detection interrupt
N  *            @arg UART_IT_TXE:  Transmit Data Register empty interrupt
N  *            @arg UART_IT_TC:   Transmission complete interrupt
N  *            @arg UART_IT_RXNE: Receive Data register not empty interrupt
N  *            @arg UART_IT_IDLE: Idle line detection interrupt
N  *            @arg UART_IT_PE:   Parity Error interrupt
N  *            @arg UART_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
N  * @retval None
N  */
N#define __HAL_UART_DISABLE_IT(__HANDLE__, __INTERRUPT__)  (((((uint8_t)(__INTERRUPT__)) >> 5U) == 1)? ((__HANDLE__)->Instance->CR1 &= ~ (1U << ((__INTERRUPT__) & UART_IT_MASK))): \
N                                                           ((((uint8_t)(__INTERRUPT__)) >> 5U) == 2)? ((__HANDLE__)->Instance->CR2 &= ~ (1U << ((__INTERRUPT__) & UART_IT_MASK))): \
N                                                           ((__HANDLE__)->Instance->CR3 &= ~ (1U << ((__INTERRUPT__) & UART_IT_MASK))))
X#define __HAL_UART_DISABLE_IT(__HANDLE__, __INTERRUPT__)  (((((uint8_t)(__INTERRUPT__)) >> 5U) == 1)? ((__HANDLE__)->Instance->CR1 &= ~ (1U << ((__INTERRUPT__) & UART_IT_MASK))):                                                            ((((uint8_t)(__INTERRUPT__)) >> 5U) == 2)? ((__HANDLE__)->Instance->CR2 &= ~ (1U << ((__INTERRUPT__) & UART_IT_MASK))):                                                            ((__HANDLE__)->Instance->CR3 &= ~ (1U << ((__INTERRUPT__) & UART_IT_MASK))))
N
N/** @brief  Checks whether the specified UART interrupt has occurred or not.
N  * @param  __HANDLE__: specifies the UART Handle.
N  * @param  __IT__: specifies the UART interrupt to check.
N  *          This parameter can be one of the following values:
N  *            @arg UART_IT_CM:   Character match interrupt
N  *            @arg UART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
N  *            @arg UART_IT_LBD:  LIN Break detection interrupt
N  *            @arg UART_IT_TXE:  Transmit Data Register empty interrupt
N  *            @arg UART_IT_TC:   Transmission complete interrupt
N  *            @arg UART_IT_RXNE: Receive Data register not empty interrupt
N  *            @arg UART_IT_IDLE: Idle line detection interrupt
N  *            @arg UART_IT_ORE:  OverRun Error interrupt
N  *            @arg UART_IT_NE:   Noise Error interrupt
N  *            @arg UART_IT_FE:   Framing Error interrupt
N  *            @arg UART_IT_PE:   Parity Error interrupt
N  * @retval The new state of __IT__ (TRUE or FALSE).
N  */
N#define __HAL_UART_GET_IT(__HANDLE__, __IT__) ((__HANDLE__)->Instance->ISR & ((uint32_t)1 << ((__IT__)>> 0x08)))
N
N/** @brief  Checks whether the specified UART interrupt source is enabled.
N  * @param  __HANDLE__: specifies the UART Handle.
N  * @param  __IT__: specifies the UART interrupt source to check.
N  *          This parameter can be one of the following values:
N  *            @arg UART_IT_CTS: CTS change interrupt (not available for UART4 and UART5)
N  *            @arg UART_IT_LBD: LIN Break detection interrupt
N  *            @arg UART_IT_TXE: Transmit Data Register empty interrupt
N  *            @arg UART_IT_TC:  Transmission complete interrupt
N  *            @arg UART_IT_RXNE: Receive Data register not empty interrupt
N  *            @arg UART_IT_IDLE: Idle line detection interrupt
N  *            @arg UART_IT_ORE: OverRun Error interrupt
N  *            @arg UART_IT_NE: Noise Error interrupt
N  *            @arg UART_IT_FE: Framing Error interrupt
N  *            @arg UART_IT_PE: Parity Error interrupt
N  * @retval The new state of __IT__ (TRUE or FALSE).
N  */
N#define __HAL_UART_GET_IT_SOURCE(__HANDLE__, __IT__) ((((((uint8_t)(__IT__)) >> 5U) == 1)? (__HANDLE__)->Instance->CR1:(((((uint8_t)(__IT__)) >> 5U) == 2)? \
N                                                       (__HANDLE__)->Instance->CR2 : (__HANDLE__)->Instance->CR3)) & ((uint32_t)1 << (((uint16_t)(__IT__)) & UART_IT_MASK)))
X#define __HAL_UART_GET_IT_SOURCE(__HANDLE__, __IT__) ((((((uint8_t)(__IT__)) >> 5U) == 1)? (__HANDLE__)->Instance->CR1:(((((uint8_t)(__IT__)) >> 5U) == 2)?                                                        (__HANDLE__)->Instance->CR2 : (__HANDLE__)->Instance->CR3)) & ((uint32_t)1 << (((uint16_t)(__IT__)) & UART_IT_MASK)))
N
N/** @brief  Set a specific UART request flag.
N  * @param  __HANDLE__: specifies the UART Handle.
N  * @param  __REQ__: specifies the request flag to set
N  *          This parameter can be one of the following values:
N  *            @arg UART_AUTOBAUD_REQUEST: Auto-Baud Rate Request
N  *            @arg UART_SENDBREAK_REQUEST: Send Break Request
N  *            @arg UART_MUTE_MODE_REQUEST: Mute Mode Request
N  *            @arg UART_RXDATA_FLUSH_REQUEST: Receive Data flush Request
N  *            @arg UART_TXDATA_FLUSH_REQUEST: Transmit data flush Request
N  * @retval None
N  */
N#define __HAL_UART_SEND_REQ(__HANDLE__, __REQ__) ((__HANDLE__)->Instance->RQR |= (uint32_t)(__REQ__))
N
N/** @brief  Enables the UART one bit sample method
N  * @param  __HANDLE__: specifies the UART Handle.  
N  * @retval None
N  */     
N#define __HAL_UART_ONE_BIT_SAMPLE_ENABLE(__HANDLE__) ((__HANDLE__)->Instance->CR3|= USART_CR3_ONEBIT)
N
N/** @brief  Disables the UART one bit sample method
N  * @param  __HANDLE__: specifies the UART Handle.  
N  * @retval None
N  */      
N#define __HAL_UART_ONE_BIT_SAMPLE_DISABLE(__HANDLE__) ((__HANDLE__)->Instance->CR3 &= (uint32_t)~((uint32_t)USART_CR3_ONEBIT))
N
N/** @brief  Enable UART
N  * @param  __HANDLE__: specifies the UART Handle.
N  * @retval None
N  */
N#define __HAL_UART_ENABLE(__HANDLE__)                   ((__HANDLE__)->Instance->CR1 |=  USART_CR1_UE)
N
N/** @brief  Disable UART
N  * @param  __HANDLE__: specifies the UART Handle.
N  * @retval None
N  */
N#define __HAL_UART_DISABLE(__HANDLE__)                  ((__HANDLE__)->Instance->CR1 &=  ~USART_CR1_UE)
N
N/** @brief  Enable CTS flow control 
N  *         This macro allows to enable CTS hardware flow control for a given UART instance, 
N  *         without need to call HAL_UART_Init() function.
N  *         As involving direct access to UART registers, usage of this macro should be fully endorsed by user.
N  * @note   As macro is expected to be used for modifying CTS Hw flow control feature activation, without need
N  *         for USART instance Deinit/Init, following conditions for macro call should be fulfilled :
N  *           - UART instance should have already been initialised (through call of HAL_UART_Init() )
N  *           - macro could only be called when corresponding UART instance is disabled (i.e __HAL_UART_DISABLE(__HANDLE__))
N  *             and should be followed by an Enable macro (i.e __HAL_UART_ENABLE(__HANDLE__)).                                                                                                                  
N  * @param  __HANDLE__: specifies the UART Handle.
N  *         The Handle Instance can be USART1, USART2 or LPUART.
N  * @retval None
N  */
N#define __HAL_UART_HWCONTROL_CTS_ENABLE(__HANDLE__)        \
N  do{                                                      \
N    SET_BIT((__HANDLE__)->Instance->CR3, USART_CR3_CTSE);  \
N    (__HANDLE__)->Init.HwFlowCtl |= USART_CR3_CTSE;        \
N  } while(0)
X#define __HAL_UART_HWCONTROL_CTS_ENABLE(__HANDLE__)          do{                                                          SET_BIT((__HANDLE__)->Instance->CR3, USART_CR3_CTSE);      (__HANDLE__)->Init.HwFlowCtl |= USART_CR3_CTSE;          } while(0)
N
N/** @brief  Disable CTS flow control 
N  *         This macro allows to disable CTS hardware flow control for a given UART instance, 
N  *         without need to call HAL_UART_Init() function.
N  *         As involving direct access to UART registers, usage of this macro should be fully endorsed by user.
N  * @note   As macro is expected to be used for modifying CTS Hw flow control feature activation, without need
N  *         for USART instance Deinit/Init, following conditions for macro call should be fulfilled :
N  *           - UART instance should have already been initialised (through call of HAL_UART_Init() )
N  *           - macro could only be called when corresponding UART instance is disabled (i.e __HAL_UART_DISABLE(__HANDLE__))
N  *             and should be followed by an Enable macro (i.e __HAL_UART_ENABLE(__HANDLE__)). 
N  * @param  __HANDLE__: specifies the UART Handle.
N  *         The Handle Instance can be USART1, USART2 or LPUART.
N  * @retval None
N  */
N#define __HAL_UART_HWCONTROL_CTS_DISABLE(__HANDLE__)        \
N  do{                                                       \
N    CLEAR_BIT((__HANDLE__)->Instance->CR3, USART_CR3_CTSE); \
N    (__HANDLE__)->Init.HwFlowCtl &= ~(USART_CR3_CTSE);      \
N  } while(0)
X#define __HAL_UART_HWCONTROL_CTS_DISABLE(__HANDLE__)          do{                                                           CLEAR_BIT((__HANDLE__)->Instance->CR3, USART_CR3_CTSE);     (__HANDLE__)->Init.HwFlowCtl &= ~(USART_CR3_CTSE);        } while(0)
N
N/** @brief  Enable RTS flow control 
N  *         This macro allows to enable RTS hardware flow control for a given UART instance, 
N  *         without need to call HAL_UART_Init() function.
N  *         As involving direct access to UART registers, usage of this macro should be fully endorsed by user.
N  * @note   As macro is expected to be used for modifying RTS Hw flow control feature activation, without need
N  *         for USART instance Deinit/Init, following conditions for macro call should be fulfilled :
N  *           - UART instance should have already been initialised (through call of HAL_UART_Init() )
N  *           - macro could only be called when corresponding UART instance is disabled (i.e __HAL_UART_DISABLE(__HANDLE__))
N  *             and should be followed by an Enable macro (i.e __HAL_UART_ENABLE(__HANDLE__)). 
N  * @param  __HANDLE__: specifies the UART Handle.
N  *         The Handle Instance can be USART1, USART2 or LPUART.
N  * @retval None
N  */
N#define __HAL_UART_HWCONTROL_RTS_ENABLE(__HANDLE__)       \
N  do{                                                     \
N    SET_BIT((__HANDLE__)->Instance->CR3, USART_CR3_RTSE); \
N    (__HANDLE__)->Init.HwFlowCtl |= USART_CR3_RTSE;       \
N  } while(0)
X#define __HAL_UART_HWCONTROL_RTS_ENABLE(__HANDLE__)         do{                                                         SET_BIT((__HANDLE__)->Instance->CR3, USART_CR3_RTSE);     (__HANDLE__)->Init.HwFlowCtl |= USART_CR3_RTSE;         } while(0)
N
N/** @brief  Disable RTS flow control 
N  *         This macro allows to disable RTS hardware flow control for a given UART instance, 
N  *         without need to call HAL_UART_Init() function.
N  *         As involving direct access to UART registers, usage of this macro should be fully endorsed by user.
N  * @note   As macro is expected to be used for modifying RTS Hw flow control feature activation, without need
N  *         for USART instance Deinit/Init, following conditions for macro call should be fulfilled :
N  *           - UART instance should have already been initialised (through call of HAL_UART_Init() )
N  *           - macro could only be called when corresponding UART instance is disabled (i.e __HAL_UART_DISABLE(__HANDLE__))
N  *             and should be followed by an Enable macro (i.e __HAL_UART_ENABLE(__HANDLE__)). 
N  * @param  __HANDLE__: specifies the UART Handle.
N  *         The Handle Instance can be USART1, USART2 or LPUART.
N  * @retval None
N  */
N#define __HAL_UART_HWCONTROL_RTS_DISABLE(__HANDLE__)       \
N  do{                                                      \
N    CLEAR_BIT((__HANDLE__)->Instance->CR3, USART_CR3_RTSE);\
N    (__HANDLE__)->Init.HwFlowCtl &= ~(USART_CR3_RTSE);     \
N  } while(0)
X#define __HAL_UART_HWCONTROL_RTS_DISABLE(__HANDLE__)         do{                                                          CLEAR_BIT((__HANDLE__)->Instance->CR3, USART_CR3_RTSE);    (__HANDLE__)->Init.HwFlowCtl &= ~(USART_CR3_RTSE);       } while(0)
N
N/**
N  * @}
N  */
N
N/* Private macros --------------------------------------------------------*/
N/** @defgroup UART_Private_Macros   UART Private Macros
N  * @{
N  */
N/** @brief  BRR division operation to set BRR register with LPUART
N  * @param  _PCLK_: LPUART clock
N  * @param  _BAUD_: Baud rate set by the user
N  * @retval Division result
N  */
N#define UART_DIV_LPUART(_PCLK_, _BAUD_)                ((((_PCLK_)*256)+((_BAUD_)/2))/((_BAUD_)))
N
N/** @brief  BRR division operation to set BRR register in 8-bit oversampling mode
N  * @param  _PCLK_: UART clock
N  * @param  _BAUD_: Baud rate set by the user
N  * @retval Division result
N  */
N#define UART_DIV_SAMPLING8(_PCLK_, _BAUD_)             ((((_PCLK_)*2)+((_BAUD_)/2))/((_BAUD_)))
N
N/** @brief  BRR division operation to set BRR register in 16-bit oversampling mode
N  * @param  _PCLK_: UART clock
N  * @param  _BAUD_: Baud rate set by the user
N  * @retval Division result
N  */
N#define UART_DIV_SAMPLING16(_PCLK_, _BAUD_)             ((((_PCLK_))+((_BAUD_)/2))/((_BAUD_)))
N
N/** @brief  Check UART Baud rate
N  * @param  BAUDRATE: Baudrate specified by the user
N  *         The maximum Baud Rate is derived from the maximum clock on F7 (i.e. 216 MHz)
N  *         divided by the smallest oversampling used on the USART (i.e. 8)
N  * @retval Test result (TRUE or FALSE).
N  */
N#define IS_UART_BAUDRATE(BAUDRATE) ((BAUDRATE) < 9000001)
N
N/** @brief  Check UART assertion time
N  * @param  TIME: 5-bit value assertion time
N  * @retval Test result (TRUE or FALSE).
N  */
N#define IS_UART_ASSERTIONTIME(TIME)    ((TIME) <= 0x1F)
N
N/** @brief  Check UART deassertion time
N  * @param  TIME: 5-bit value deassertion time
N  * @retval Test result (TRUE or FALSE).
N  */
N#define IS_UART_DEASSERTIONTIME(TIME) ((TIME) <= 0x1F)
N
N#define IS_UART_STOPBITS(STOPBITS) (((STOPBITS) == UART_STOPBITS_1) || \
N                                    ((STOPBITS) == UART_STOPBITS_2))
X#define IS_UART_STOPBITS(STOPBITS) (((STOPBITS) == UART_STOPBITS_1) ||                                     ((STOPBITS) == UART_STOPBITS_2))
N
N#define IS_UART_PARITY(PARITY) (((PARITY) == UART_PARITY_NONE) || \
N                                ((PARITY) == UART_PARITY_EVEN) || \
N                                ((PARITY) == UART_PARITY_ODD))
X#define IS_UART_PARITY(PARITY) (((PARITY) == UART_PARITY_NONE) ||                                 ((PARITY) == UART_PARITY_EVEN) ||                                 ((PARITY) == UART_PARITY_ODD))
N
N#define IS_UART_HARDWARE_FLOW_CONTROL(CONTROL)\
N                              (((CONTROL) == UART_HWCONTROL_NONE) || \
N                               ((CONTROL) == UART_HWCONTROL_RTS) || \
N                               ((CONTROL) == UART_HWCONTROL_CTS) || \
N                               ((CONTROL) == UART_HWCONTROL_RTS_CTS))
X#define IS_UART_HARDWARE_FLOW_CONTROL(CONTROL)                              (((CONTROL) == UART_HWCONTROL_NONE) ||                                ((CONTROL) == UART_HWCONTROL_RTS) ||                                ((CONTROL) == UART_HWCONTROL_CTS) ||                                ((CONTROL) == UART_HWCONTROL_RTS_CTS))
N
N#define IS_UART_MODE(MODE) ((((MODE) & (~((uint32_t)(UART_MODE_TX_RX)))) == (uint32_t)0x00) && ((MODE) != (uint32_t)0x00))
N
N#define IS_UART_STATE(STATE) (((STATE) == UART_STATE_DISABLE) || \
N                              ((STATE) == UART_STATE_ENABLE))
X#define IS_UART_STATE(STATE) (((STATE) == UART_STATE_DISABLE) ||                               ((STATE) == UART_STATE_ENABLE))
N
N#define IS_UART_OVERSAMPLING(SAMPLING) (((SAMPLING) == UART_OVERSAMPLING_16) || \
N                                        ((SAMPLING) == UART_OVERSAMPLING_8))
X#define IS_UART_OVERSAMPLING(SAMPLING) (((SAMPLING) == UART_OVERSAMPLING_16) ||                                         ((SAMPLING) == UART_OVERSAMPLING_8))
N
N#define IS_UART_ONE_BIT_SAMPLE(ONEBIT) (((ONEBIT) == UART_ONE_BIT_SAMPLE_DISABLE) || \
N                                        ((ONEBIT) == UART_ONE_BIT_SAMPLE_ENABLE))
X#define IS_UART_ONE_BIT_SAMPLE(ONEBIT) (((ONEBIT) == UART_ONE_BIT_SAMPLE_DISABLE) ||                                         ((ONEBIT) == UART_ONE_BIT_SAMPLE_ENABLE))
N
N#define IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(MODE)  (((MODE) == UART_ADVFEATURE_AUTOBAUDRATE_ONSTARTBIT) || \
N                                                    ((MODE) == UART_ADVFEATURE_AUTOBAUDRATE_ONFALLINGEDGE) || \
N                                                    ((MODE) == UART_ADVFEATURE_AUTOBAUDRATE_ON0X7FFRAME) || \
N                                                    ((MODE) == UART_ADVFEATURE_AUTOBAUDRATE_ON0X55FRAME))
X#define IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(MODE)  (((MODE) == UART_ADVFEATURE_AUTOBAUDRATE_ONSTARTBIT) ||                                                     ((MODE) == UART_ADVFEATURE_AUTOBAUDRATE_ONFALLINGEDGE) ||                                                     ((MODE) == UART_ADVFEATURE_AUTOBAUDRATE_ON0X7FFRAME) ||                                                     ((MODE) == UART_ADVFEATURE_AUTOBAUDRATE_ON0X55FRAME))
N
N#define IS_UART_RECEIVER_TIMEOUT(TIMEOUT) (((TIMEOUT) == UART_RECEIVER_TIMEOUT_DISABLE) || \
N                                           ((TIMEOUT) == UART_RECEIVER_TIMEOUT_ENABLE))
X#define IS_UART_RECEIVER_TIMEOUT(TIMEOUT) (((TIMEOUT) == UART_RECEIVER_TIMEOUT_DISABLE) ||                                            ((TIMEOUT) == UART_RECEIVER_TIMEOUT_ENABLE))
N
N#define IS_UART_LIN(LIN)            (((LIN) == UART_LIN_DISABLE) || \
N                                     ((LIN) == UART_LIN_ENABLE))
X#define IS_UART_LIN(LIN)            (((LIN) == UART_LIN_DISABLE) ||                                      ((LIN) == UART_LIN_ENABLE))
N
N#define IS_UART_WAKEUPMETHOD(WAKEUP) (((WAKEUP) == UART_WAKEUPMETHOD_IDLELINE) || \
N                                      ((WAKEUP) == UART_WAKEUPMETHOD_ADDRESSMARK))
X#define IS_UART_WAKEUPMETHOD(WAKEUP) (((WAKEUP) == UART_WAKEUPMETHOD_IDLELINE) ||                                       ((WAKEUP) == UART_WAKEUPMETHOD_ADDRESSMARK))
N
N#define IS_UART_LIN_BREAK_DETECT_LENGTH(LENGTH) (((LENGTH) == UART_LINBREAKDETECTLENGTH_10B) || \
N                                                 ((LENGTH) == UART_LINBREAKDETECTLENGTH_11B))
X#define IS_UART_LIN_BREAK_DETECT_LENGTH(LENGTH) (((LENGTH) == UART_LINBREAKDETECTLENGTH_10B) ||                                                  ((LENGTH) == UART_LINBREAKDETECTLENGTH_11B))
N
N#define IS_UART_DMA_TX(DMATX)         (((DMATX) == UART_DMA_TX_DISABLE) || \
N                                       ((DMATX) == UART_DMA_TX_ENABLE))
X#define IS_UART_DMA_TX(DMATX)         (((DMATX) == UART_DMA_TX_DISABLE) ||                                        ((DMATX) == UART_DMA_TX_ENABLE))
N
N#define IS_UART_DMA_RX(DMARX)         (((DMARX) == UART_DMA_RX_DISABLE) || \
N                                       ((DMARX) == UART_DMA_RX_ENABLE))
X#define IS_UART_DMA_RX(DMARX)         (((DMARX) == UART_DMA_RX_DISABLE) ||                                        ((DMARX) == UART_DMA_RX_ENABLE))
N
N#define IS_UART_HALF_DUPLEX(HDSEL)         (((HDSEL) == UART_HALF_DUPLEX_DISABLE) || \
N                                            ((HDSEL) == UART_HALF_DUPLEX_ENABLE))
X#define IS_UART_HALF_DUPLEX(HDSEL)         (((HDSEL) == UART_HALF_DUPLEX_DISABLE) ||                                             ((HDSEL) == UART_HALF_DUPLEX_ENABLE))
N
N#define IS_UART_REQUEST_PARAMETER(PARAM) (((PARAM) == UART_AUTOBAUD_REQUEST) || \
N                                          ((PARAM) == UART_SENDBREAK_REQUEST) || \
N                                          ((PARAM) == UART_MUTE_MODE_REQUEST) || \
N                                          ((PARAM) == UART_RXDATA_FLUSH_REQUEST) || \
N                                          ((PARAM) == UART_TXDATA_FLUSH_REQUEST))
X#define IS_UART_REQUEST_PARAMETER(PARAM) (((PARAM) == UART_AUTOBAUD_REQUEST) ||                                           ((PARAM) == UART_SENDBREAK_REQUEST) ||                                           ((PARAM) == UART_MUTE_MODE_REQUEST) ||                                           ((PARAM) == UART_RXDATA_FLUSH_REQUEST) ||                                           ((PARAM) == UART_TXDATA_FLUSH_REQUEST))
N
N#define IS_UART_ADVFEATURE_INIT(INIT)           ((INIT) <= (UART_ADVFEATURE_NO_INIT | \
N                                                            UART_ADVFEATURE_TXINVERT_INIT | \
N                                                            UART_ADVFEATURE_RXINVERT_INIT | \
N                                                            UART_ADVFEATURE_DATAINVERT_INIT | \
N                                                            UART_ADVFEATURE_SWAP_INIT | \
N                                                            UART_ADVFEATURE_RXOVERRUNDISABLE_INIT | \
N                                                            UART_ADVFEATURE_DMADISABLEONERROR_INIT   | \
N                                                            UART_ADVFEATURE_AUTOBAUDRATE_INIT | \
N                                                            UART_ADVFEATURE_MSBFIRST_INIT))
X#define IS_UART_ADVFEATURE_INIT(INIT)           ((INIT) <= (UART_ADVFEATURE_NO_INIT |                                                             UART_ADVFEATURE_TXINVERT_INIT |                                                             UART_ADVFEATURE_RXINVERT_INIT |                                                             UART_ADVFEATURE_DATAINVERT_INIT |                                                             UART_ADVFEATURE_SWAP_INIT |                                                             UART_ADVFEATURE_RXOVERRUNDISABLE_INIT |                                                             UART_ADVFEATURE_DMADISABLEONERROR_INIT   |                                                             UART_ADVFEATURE_AUTOBAUDRATE_INIT |                                                             UART_ADVFEATURE_MSBFIRST_INIT))
N
N#define IS_UART_ADVFEATURE_TXINV(TXINV) (((TXINV) == UART_ADVFEATURE_TXINV_DISABLE) || \
N                                         ((TXINV) == UART_ADVFEATURE_TXINV_ENABLE))
X#define IS_UART_ADVFEATURE_TXINV(TXINV) (((TXINV) == UART_ADVFEATURE_TXINV_DISABLE) ||                                          ((TXINV) == UART_ADVFEATURE_TXINV_ENABLE))
N
N#define IS_UART_ADVFEATURE_RXINV(RXINV) (((RXINV) == UART_ADVFEATURE_RXINV_DISABLE) || \
N                                         ((RXINV) == UART_ADVFEATURE_RXINV_ENABLE))
X#define IS_UART_ADVFEATURE_RXINV(RXINV) (((RXINV) == UART_ADVFEATURE_RXINV_DISABLE) ||                                          ((RXINV) == UART_ADVFEATURE_RXINV_ENABLE))
N
N#define IS_UART_ADVFEATURE_DATAINV(DATAINV) (((DATAINV) == UART_ADVFEATURE_DATAINV_DISABLE) || \
N                                             ((DATAINV) == UART_ADVFEATURE_DATAINV_ENABLE))
X#define IS_UART_ADVFEATURE_DATAINV(DATAINV) (((DATAINV) == UART_ADVFEATURE_DATAINV_DISABLE) ||                                              ((DATAINV) == UART_ADVFEATURE_DATAINV_ENABLE))
N
N#define IS_UART_ADVFEATURE_SWAP(SWAP) (((SWAP) == UART_ADVFEATURE_SWAP_DISABLE) || \
N                                       ((SWAP) == UART_ADVFEATURE_SWAP_ENABLE))
X#define IS_UART_ADVFEATURE_SWAP(SWAP) (((SWAP) == UART_ADVFEATURE_SWAP_DISABLE) ||                                        ((SWAP) == UART_ADVFEATURE_SWAP_ENABLE))
N
N#define IS_UART_OVERRUN(OVERRUN)         (((OVERRUN) == UART_ADVFEATURE_OVERRUN_ENABLE) || \
N                                          ((OVERRUN) == UART_ADVFEATURE_OVERRUN_DISABLE))
X#define IS_UART_OVERRUN(OVERRUN)         (((OVERRUN) == UART_ADVFEATURE_OVERRUN_ENABLE) ||                                           ((OVERRUN) == UART_ADVFEATURE_OVERRUN_DISABLE))
N
N#define IS_UART_ADVFEATURE_AUTOBAUDRATE(AUTOBAUDRATE)  (((AUTOBAUDRATE) == UART_ADVFEATURE_AUTOBAUDRATE_DISABLE) || \
N                                                        ((AUTOBAUDRATE) == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE))
X#define IS_UART_ADVFEATURE_AUTOBAUDRATE(AUTOBAUDRATE)  (((AUTOBAUDRATE) == UART_ADVFEATURE_AUTOBAUDRATE_DISABLE) ||                                                         ((AUTOBAUDRATE) == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE))
N
N#define IS_UART_ADVFEATURE_DMAONRXERROR(DMA)      (((DMA) == UART_ADVFEATURE_DMA_ENABLEONRXERROR) || \
N                                                   ((DMA) == UART_ADVFEATURE_DMA_DISABLEONRXERROR))
X#define IS_UART_ADVFEATURE_DMAONRXERROR(DMA)      (((DMA) == UART_ADVFEATURE_DMA_ENABLEONRXERROR) ||                                                    ((DMA) == UART_ADVFEATURE_DMA_DISABLEONRXERROR))
N
N#define IS_UART_ADVFEATURE_MSBFIRST(MSBFIRST) (((MSBFIRST) == UART_ADVFEATURE_MSBFIRST_DISABLE) || \
N                                               ((MSBFIRST) == UART_ADVFEATURE_MSBFIRST_ENABLE))
X#define IS_UART_ADVFEATURE_MSBFIRST(MSBFIRST) (((MSBFIRST) == UART_ADVFEATURE_MSBFIRST_DISABLE) ||                                                ((MSBFIRST) == UART_ADVFEATURE_MSBFIRST_ENABLE))
N
N#define IS_UART_MUTE_MODE(MUTE)           (((MUTE) == UART_ADVFEATURE_MUTEMODE_DISABLE) || \
N                                           ((MUTE) == UART_ADVFEATURE_MUTEMODE_ENABLE))
X#define IS_UART_MUTE_MODE(MUTE)           (((MUTE) == UART_ADVFEATURE_MUTEMODE_DISABLE) ||                                            ((MUTE) == UART_ADVFEATURE_MUTEMODE_ENABLE))
N
N#define IS_UART_DE_POLARITY(POLARITY)    (((POLARITY) == UART_DE_POLARITY_HIGH) || \
N                                          ((POLARITY) == UART_DE_POLARITY_LOW))
X#define IS_UART_DE_POLARITY(POLARITY)    (((POLARITY) == UART_DE_POLARITY_HIGH) ||                                           ((POLARITY) == UART_DE_POLARITY_LOW))
N
N/**
N  * @}
N  */
N/* Include UART HAL Extension module */
N#include "stm32f7xx_hal_uart_ex.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_uart_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_uart_ex.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of UART HAL Extension module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************  
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_UART_EX_H
N#define __STM32F7xx_HAL_UART_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup UARTEx
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup UARTEx_Exported_Constants UARTEx Exported Constants
N  * @{
N  */
N  
N/** @defgroup UARTEx_Word_Length UARTEx Word Length
N  * @{
N  */
N#define UART_WORDLENGTH_7B                  ((uint32_t)USART_CR1_M_1)
N#define UART_WORDLENGTH_8B                  ((uint32_t)0x0000U)
N#define UART_WORDLENGTH_9B                  ((uint32_t)USART_CR1_M_0)
N#define IS_UART_WORD_LENGTH(__LENGTH__) (((__LENGTH__) == UART_WORDLENGTH_7B) || \
N                                         ((__LENGTH__) == UART_WORDLENGTH_8B) || \
N                                         ((__LENGTH__) == UART_WORDLENGTH_9B))
X#define IS_UART_WORD_LENGTH(__LENGTH__) (((__LENGTH__) == UART_WORDLENGTH_7B) ||                                          ((__LENGTH__) == UART_WORDLENGTH_8B) ||                                          ((__LENGTH__) == UART_WORDLENGTH_9B))
N#define IS_LIN_WORD_LENGTH(LENGTH) (((LENGTH) == UART_WORDLENGTH_8B))																				 
N/**
N  * @}
N  */
N
N  
N/** @defgroup UARTEx_WakeUp_Address_Length UARTEx WakeUp Address Length
N  * @{
N  */
N#define UART_ADDRESS_DETECT_4B                ((uint32_t)0x00000000U)
N#define UART_ADDRESS_DETECT_7B                ((uint32_t)USART_CR2_ADDM7)
N#define IS_UART_ADDRESSLENGTH_DETECT(__ADDRESS__) (((__ADDRESS__) == UART_ADDRESS_DETECT_4B) || \
N                                                   ((__ADDRESS__) == UART_ADDRESS_DETECT_7B))
X#define IS_UART_ADDRESSLENGTH_DETECT(__ADDRESS__) (((__ADDRESS__) == UART_ADDRESS_DETECT_4B) ||                                                    ((__ADDRESS__) == UART_ADDRESS_DETECT_7B))
N/**
N  * @}
N  */  
N
N  
N/**
N  * @}
N  */  
N  
N/* Exported macro ------------------------------------------------------------*/
N
N/** @defgroup UARTEx_Exported_Macros UARTEx Exported Macros
N  * @{
N  */
N           
N/** @brief  Reports the UART clock source.
N  * @param  __HANDLE__: specifies the UART Handle
N  * @param  __CLOCKSOURCE__: output variable   
N  * @retval UART clocking source, written in __CLOCKSOURCE__.
N  */
N#define UART_GETCLOCKSOURCE(__HANDLE__,__CLOCKSOURCE__) \
N  do {                                                        \
N    if((__HANDLE__)->Instance == USART1)                      \
N    {                                                         \
N       switch(__HAL_RCC_GET_USART1_SOURCE())                  \
N       {                                                      \
N        case RCC_USART1CLKSOURCE_PCLK2:                       \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK2;         \
N          break;                                              \
N        case RCC_USART1CLKSOURCE_HSI:                         \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;           \
N          break;                                              \
N        case RCC_USART1CLKSOURCE_SYSCLK:                      \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;        \
N          break;                                              \
N        case RCC_USART1CLKSOURCE_LSE:                         \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;           \
N          break;                                              \
N        default:                                              \
N          break;                                              \
N       }                                                      \
N    }                                                         \
N    else if((__HANDLE__)->Instance == USART2)                 \
N    {                                                         \
N       switch(__HAL_RCC_GET_USART2_SOURCE())                  \
N       {                                                      \
N        case RCC_USART2CLKSOURCE_PCLK1:                       \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;         \
N          break;                                              \
N        case RCC_USART2CLKSOURCE_HSI:                         \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;           \
N          break;                                              \
N        case RCC_USART2CLKSOURCE_SYSCLK:                      \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;        \
N          break;                                              \
N        case RCC_USART2CLKSOURCE_LSE:                         \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;           \
N          break;                                              \
N        default:                                              \
N          break;                                              \
N       }                                                      \
N    }                                                         \
N    else if((__HANDLE__)->Instance == USART3)                 \
N    {                                                         \
N       switch(__HAL_RCC_GET_USART3_SOURCE())                  \
N       {                                                      \
N        case RCC_USART3CLKSOURCE_PCLK1:                       \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;         \
N          break;                                              \
N        case RCC_USART3CLKSOURCE_HSI:                         \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;           \
N          break;                                              \
N        case RCC_USART3CLKSOURCE_SYSCLK:                      \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;        \
N          break;                                              \
N        case RCC_USART3CLKSOURCE_LSE:                         \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;           \
N          break;                                              \
N        default:                                              \
N          break;                                              \
N       }                                                      \
N    }                                                         \
N    else if((__HANDLE__)->Instance == UART4)                  \
N    {                                                         \
N       switch(__HAL_RCC_GET_UART4_SOURCE())                   \
N       {                                                      \
N        case RCC_UART4CLKSOURCE_PCLK1:                        \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;         \
N          break;                                              \
N        case RCC_UART4CLKSOURCE_HSI:                          \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;           \
N          break;                                              \
N        case RCC_UART4CLKSOURCE_SYSCLK:                       \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;        \
N          break;                                              \
N        case RCC_UART4CLKSOURCE_LSE:                          \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;           \
N          break;                                              \
N        default:                                              \
N          break;                                              \
N       }                                                      \
N    }                                                         \
N    else if ((__HANDLE__)->Instance == UART5)                 \
N    {                                                         \
N       switch(__HAL_RCC_GET_UART5_SOURCE())                   \
N       {                                                      \
N        case RCC_UART5CLKSOURCE_PCLK1:                        \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;         \
N          break;                                              \
N        case RCC_UART5CLKSOURCE_HSI:                          \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;           \
N          break;                                              \
N        case RCC_UART5CLKSOURCE_SYSCLK:                       \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;        \
N          break;                                              \
N        case RCC_UART5CLKSOURCE_LSE:                          \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;           \
N          break;                                              \
N        default:                                              \
N          break;                                              \
N       }                                                      \
N    }                                                         \
N    else if((__HANDLE__)->Instance == USART6)                 \
N    {                                                         \
N       switch(__HAL_RCC_GET_USART6_SOURCE())                  \
N       {                                                      \
N        case RCC_USART6CLKSOURCE_PCLK2:                       \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK2;         \
N          break;                                              \
N        case RCC_USART6CLKSOURCE_HSI:                         \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;           \
N          break;                                              \
N        case RCC_USART6CLKSOURCE_SYSCLK:                      \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;        \
N          break;                                              \
N        case RCC_USART6CLKSOURCE_LSE:                         \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;           \
N          break;                                              \
N        default:                                              \
N          break;                                              \
N       }                                                      \
N    }                                                         \
N    else if ((__HANDLE__)->Instance == UART7)                 \
N    {                                                         \
N       switch(__HAL_RCC_GET_UART7_SOURCE())                   \
N       {                                                      \
N        case RCC_UART7CLKSOURCE_PCLK1:                        \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;         \
N          break;                                              \
N        case RCC_UART7CLKSOURCE_HSI:                          \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;           \
N          break;                                              \
N        case RCC_UART7CLKSOURCE_SYSCLK:                       \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;        \
N          break;                                              \
N        case RCC_UART7CLKSOURCE_LSE:                          \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;           \
N          break;                                              \
N        default:                                              \
N          break;                                              \
N       }                                                      \
N    } 																												\
N    else if ((__HANDLE__)->Instance == UART8)                 \
N    {                                                         \
N       switch(__HAL_RCC_GET_UART8_SOURCE())                   \
N       {                                                      \
N        case RCC_UART8CLKSOURCE_PCLK1:                        \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;         \
N          break;                                              \
N        case RCC_UART8CLKSOURCE_HSI:                          \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;           \
N          break;                                              \
N        case RCC_UART8CLKSOURCE_SYSCLK:                       \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;        \
N          break;                                              \
N        case RCC_UART8CLKSOURCE_LSE:                          \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;           \
N          break;                                              \
N        default:                                              \
N          break;                                              \
N       }                                                      \
N    } 																												\
N  } while(0)
X#define UART_GETCLOCKSOURCE(__HANDLE__,__CLOCKSOURCE__)   do {                                                            if((__HANDLE__)->Instance == USART1)                          {                                                                switch(__HAL_RCC_GET_USART1_SOURCE())                         {                                                              case RCC_USART1CLKSOURCE_PCLK2:                                 (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK2;                   break;                                                      case RCC_USART1CLKSOURCE_HSI:                                   (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;                     break;                                                      case RCC_USART1CLKSOURCE_SYSCLK:                                (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;                  break;                                                      case RCC_USART1CLKSOURCE_LSE:                                   (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;                     break;                                                      default:                                                        break;                                                     }                                                          }                                                             else if((__HANDLE__)->Instance == USART2)                     {                                                                switch(__HAL_RCC_GET_USART2_SOURCE())                         {                                                              case RCC_USART2CLKSOURCE_PCLK1:                                 (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;                   break;                                                      case RCC_USART2CLKSOURCE_HSI:                                   (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;                     break;                                                      case RCC_USART2CLKSOURCE_SYSCLK:                                (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;                  break;                                                      case RCC_USART2CLKSOURCE_LSE:                                   (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;                     break;                                                      default:                                                        break;                                                     }                                                          }                                                             else if((__HANDLE__)->Instance == USART3)                     {                                                                switch(__HAL_RCC_GET_USART3_SOURCE())                         {                                                              case RCC_USART3CLKSOURCE_PCLK1:                                 (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;                   break;                                                      case RCC_USART3CLKSOURCE_HSI:                                   (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;                     break;                                                      case RCC_USART3CLKSOURCE_SYSCLK:                                (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;                  break;                                                      case RCC_USART3CLKSOURCE_LSE:                                   (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;                     break;                                                      default:                                                        break;                                                     }                                                          }                                                             else if((__HANDLE__)->Instance == UART4)                      {                                                                switch(__HAL_RCC_GET_UART4_SOURCE())                          {                                                              case RCC_UART4CLKSOURCE_PCLK1:                                  (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;                   break;                                                      case RCC_UART4CLKSOURCE_HSI:                                    (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;                     break;                                                      case RCC_UART4CLKSOURCE_SYSCLK:                                 (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;                  break;                                                      case RCC_UART4CLKSOURCE_LSE:                                    (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;                     break;                                                      default:                                                        break;                                                     }                                                          }                                                             else if ((__HANDLE__)->Instance == UART5)                     {                                                                switch(__HAL_RCC_GET_UART5_SOURCE())                          {                                                              case RCC_UART5CLKSOURCE_PCLK1:                                  (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;                   break;                                                      case RCC_UART5CLKSOURCE_HSI:                                    (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;                     break;                                                      case RCC_UART5CLKSOURCE_SYSCLK:                                 (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;                  break;                                                      case RCC_UART5CLKSOURCE_LSE:                                    (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;                     break;                                                      default:                                                        break;                                                     }                                                          }                                                             else if((__HANDLE__)->Instance == USART6)                     {                                                                switch(__HAL_RCC_GET_USART6_SOURCE())                         {                                                              case RCC_USART6CLKSOURCE_PCLK2:                                 (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK2;                   break;                                                      case RCC_USART6CLKSOURCE_HSI:                                   (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;                     break;                                                      case RCC_USART6CLKSOURCE_SYSCLK:                                (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;                  break;                                                      case RCC_USART6CLKSOURCE_LSE:                                   (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;                     break;                                                      default:                                                        break;                                                     }                                                          }                                                             else if ((__HANDLE__)->Instance == UART7)                     {                                                                switch(__HAL_RCC_GET_UART7_SOURCE())                          {                                                              case RCC_UART7CLKSOURCE_PCLK1:                                  (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;                   break;                                                      case RCC_UART7CLKSOURCE_HSI:                                    (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;                     break;                                                      case RCC_UART7CLKSOURCE_SYSCLK:                                 (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;                  break;                                                      case RCC_UART7CLKSOURCE_LSE:                                    (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;                     break;                                                      default:                                                        break;                                                     }                                                          } 																												    else if ((__HANDLE__)->Instance == UART8)                     {                                                                switch(__HAL_RCC_GET_UART8_SOURCE())                          {                                                              case RCC_UART8CLKSOURCE_PCLK1:                                  (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;                   break;                                                      case RCC_UART8CLKSOURCE_HSI:                                    (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;                     break;                                                      case RCC_UART8CLKSOURCE_SYSCLK:                                 (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;                  break;                                                      case RCC_UART8CLKSOURCE_LSE:                                    (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;                     break;                                                      default:                                                        break;                                                     }                                                          } 																												  } while(0)
N
N/** @brief  Reports the UART mask to apply to retrieve the received data
N  *         according to the word length and to the parity bits activation.
N  *         If PCE = 1, the parity bit is not included in the data extracted
N  *         by the reception API().
N  *         This masking operation is not carried out in the case of
N  *         DMA transfers.        
N  * @param  __HANDLE__: specifies the UART Handle
N  * @retval mask to apply to UART RDR register value.
N  */
N#define UART_MASK_COMPUTATION(__HANDLE__)                       \
N  do {                                                                \
N  if ((__HANDLE__)->Init.WordLength == UART_WORDLENGTH_9B)            \
N  {                                                                   \
N     if ((__HANDLE__)->Init.Parity == UART_PARITY_NONE)               \
N     {                                                                \
N        (__HANDLE__)->Mask = 0x01FF ;                                 \
N     }                                                                \
N     else                                                             \
N     {                                                                \
N        (__HANDLE__)->Mask = 0x00FF ;                                 \
N     }                                                                \
N  }                                                                   \
N  else if ((__HANDLE__)->Init.WordLength == UART_WORDLENGTH_8B)       \
N  {                                                                   \
N     if ((__HANDLE__)->Init.Parity == UART_PARITY_NONE)               \
N     {                                                                \
N        (__HANDLE__)->Mask = 0x00FF ;                                 \
N     }                                                                \
N     else                                                             \
N     {                                                                \
N        (__HANDLE__)->Mask = 0x007F ;                                 \
N     }                                                                \
N  }                                                                   \
N  else if ((__HANDLE__)->Init.WordLength == UART_WORDLENGTH_7B)       \
N  {                                                                   \
N     if ((__HANDLE__)->Init.Parity == UART_PARITY_NONE)               \
N     {                                                                \
N        (__HANDLE__)->Mask = 0x007F ;                                 \
N     }                                                                \
N     else                                                             \
N     {                                                                \
N        (__HANDLE__)->Mask = 0x003F ;                                 \
N     }                                                                \
N  }                                                                   \
N} while(0)
X#define UART_MASK_COMPUTATION(__HANDLE__)                         do {                                                                  if ((__HANDLE__)->Init.WordLength == UART_WORDLENGTH_9B)              {                                                                        if ((__HANDLE__)->Init.Parity == UART_PARITY_NONE)                    {                                                                        (__HANDLE__)->Mask = 0x01FF ;                                      }                                                                     else                                                                  {                                                                        (__HANDLE__)->Mask = 0x00FF ;                                      }                                                                  }                                                                     else if ((__HANDLE__)->Init.WordLength == UART_WORDLENGTH_8B)         {                                                                        if ((__HANDLE__)->Init.Parity == UART_PARITY_NONE)                    {                                                                        (__HANDLE__)->Mask = 0x00FF ;                                      }                                                                     else                                                                  {                                                                        (__HANDLE__)->Mask = 0x007F ;                                      }                                                                  }                                                                     else if ((__HANDLE__)->Init.WordLength == UART_WORDLENGTH_7B)         {                                                                        if ((__HANDLE__)->Init.Parity == UART_PARITY_NONE)                    {                                                                        (__HANDLE__)->Mask = 0x007F ;                                      }                                                                     else                                                                  {                                                                        (__HANDLE__)->Mask = 0x003F ;                                      }                                                                  }                                                                   } while(0)
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N
N/** @addtogroup UARTEx_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup UARTEx_Exported_Functions_Group1
N  * @{
N  */
N
N/* Initialization and de-initialization functions  ****************************/
NHAL_StatusTypeDef HAL_RS485Ex_Init(UART_HandleTypeDef *huart, uint32_t Polarity, uint32_t AssertionTime, uint32_t DeassertionTime);
N
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */ 
N
N/** @addtogroup UARTEx_Exported_Functions_Group3
N  * @{
N  */
N
N/* Peripheral Control functions  **********************************************/
NHAL_StatusTypeDef HAL_MultiProcessorEx_AddressLength_Set(UART_HandleTypeDef *huart, uint32_t AddressLength);
N
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_UART_EX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 1111 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_uart.h" 2
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup UART_Exported_Functions UART Exported Functions
N  * @{
N  */
N
N/** @addtogroup UART_Exported_Functions_Group1 Initialization and de-initialization functions
N  * @{
N  */
N
N/* Initialization and de-initialization functions  ****************************/
NHAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength);
NHAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod);
NHAL_StatusTypeDef HAL_RS485Ex_Init(UART_HandleTypeDef *huart, uint32_t Polarity, uint32_t AssertionTime, uint32_t DeassertionTime);
NHAL_StatusTypeDef HAL_UART_DeInit (UART_HandleTypeDef *huart);
Nvoid HAL_UART_MspInit(UART_HandleTypeDef *huart);
Nvoid HAL_UART_MspDeInit(UART_HandleTypeDef *huart);
N
N/**
N  * @}
N  */
N
N/** @addtogroup UART_Exported_Functions_Group2 IO operation functions
N  * @{
N  */
N
N/* IO operation functions *****************************************************/
NHAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart);
N
Nvoid HAL_UART_IRQHandler(UART_HandleTypeDef *huart);
Nvoid HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart);
Nvoid HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart);
Nvoid HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart);
Nvoid HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart);
Nvoid HAL_UART_ErrorCallback(UART_HandleTypeDef *huart);
N
N/**
N  * @}
N  */
N
N/** @addtogroup UART_Exported_Functions_Group3 Peripheral Control functions
N  * @{
N  */
N
N/* Peripheral Control functions  ************************************************/
NHAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_MultiProcessorEx_AddressLength_Set(UART_HandleTypeDef *huart, uint32_t AddressLength);
NHAL_StatusTypeDef HAL_MultiProcessor_EnableMuteMode(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_MultiProcessor_DisableMuteMode(UART_HandleTypeDef *huart);
Nvoid HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart);
N
N/**
N  * @}
N  */
N
N/** @addtogroup UART_Exported_Functions_Group4 Peripheral State and Error functions
N  * @{
N  */
N
N/* Peripheral State and Errors functions  **************************************************/
NHAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart);
Nuint32_t HAL_UART_GetError(UART_HandleTypeDef *huart);
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private functions -----------------------------------------------------------*/
N/** @addtogroup UART_Private_Functions UART Private Functions
N  * @{
N  */
N
NHAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout);
Nvoid UART_AdvFeatureConfig(UART_HandleTypeDef *huart);
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_UART_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 379 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_UART_MODULE_ENABLED */
N
N#ifdef HAL_USART_MODULE_ENABLED
N #include "stm32f7xx_hal_usart.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_usart.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_usart.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of USART HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_USART_H
N#define __STM32F7xx_HAL_USART_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup USART
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup USART_Exported_Types USART Exported Types
N  * @{
N  */
N
N/**
N  * @brief USART Init Structure definition
N  */
Ntypedef struct
N{
N  uint32_t BaudRate;                  /*!< This member configures the Usart communication baud rate.
N                                           The baud rate is computed using the following formula:
N                                              Baud Rate Register = ((PCLKx) / ((huart->Init.BaudRate))) */
N
N  uint32_t WordLength;                /*!< Specifies the number of data bits transmitted or received in a frame.
N                                           This parameter can be a value of @ref USARTEx_Word_Length */
N
N  uint32_t StopBits;                  /*!< Specifies the number of stop bits transmitted.
N                                           This parameter can be a value of @ref USART_Stop_Bits */
N
N  uint32_t Parity;                   /*!< Specifies the parity mode.
N                                           This parameter can be a value of @ref USART_Parity
N                                           @note When parity is enabled, the computed parity is inserted
N                                                 at the MSB position of the transmitted data (9th bit when
N                                                 the word length is set to 9 data bits; 8th bit when the
N                                                 word length is set to 8 data bits). */
N
N  uint32_t Mode;                      /*!< Specifies whether the Receive or Transmit mode is enabled or disabled.
N                                           This parameter can be a value of @ref USART_Mode */
N
N  uint32_t OverSampling;              /*!< Specifies whether the Over sampling 8 is enabled or disabled, to achieve higher speed (up to fPCLK/8).
N                                           This parameter can be a value of @ref USART_Over_Sampling */                                                                                        
N
N  uint32_t CLKPolarity;               /*!< Specifies the steady state of the serial clock.
N                                           This parameter can be a value of @ref USART_Clock_Polarity */
N
N  uint32_t CLKPhase;                  /*!< Specifies the clock transition on which the bit capture is made.
N                                           This parameter can be a value of @ref USART_Clock_Phase */
N
N  uint32_t CLKLastBit;                /*!< Specifies whether the clock pulse corresponding to the last transmitted
N                                           data bit (MSB) has to be output on the SCLK pin in synchronous mode.
N                                           This parameter can be a value of @ref USART_Last_Bit */
N}USART_InitTypeDef;
N
N/**
N  * @brief HAL USART State structures definition
N  */
Ntypedef enum
N{
N  HAL_USART_STATE_RESET             = 0x00U,    /*!< Peripheral is not initialized   */
N  HAL_USART_STATE_READY             = 0x01U,    /*!< Peripheral Initialized and ready for use */
N  HAL_USART_STATE_BUSY              = 0x02U,    /*!< an internal process is ongoing */
N  HAL_USART_STATE_BUSY_TX           = 0x12U,    /*!< Data Transmission process is ongoing */
N  HAL_USART_STATE_BUSY_RX           = 0x22U,    /*!< Data Reception process is ongoing */
N  HAL_USART_STATE_BUSY_TX_RX        = 0x32U,    /*!< Data Transmission Reception process is ongoing */
N  HAL_USART_STATE_TIMEOUT           = 0x03U,    /*!< Timeout state */
N  HAL_USART_STATE_ERROR             = 0x04U     /*!< Error */
N}HAL_USART_StateTypeDef;
N
N
N/**
N  * @brief  USART clock sources definitions
N  */
Ntypedef enum
N{
N  USART_CLOCKSOURCE_PCLK1      = 0x00U,    /*!< PCLK1 clock source  */
N  USART_CLOCKSOURCE_PCLK2      = 0x01U,    /*!< PCLK2 clock source  */
N  USART_CLOCKSOURCE_HSI        = 0x02U,    /*!< HSI clock source    */
N  USART_CLOCKSOURCE_SYSCLK     = 0x04U,    /*!< SYSCLK clock source */
N  USART_CLOCKSOURCE_LSE        = 0x08U,    /*!< LSE clock source       */
N  USART_CLOCKSOURCE_UNDEFINED  = 0x10U     /*!< Undefined clock source */
N}USART_ClockSourceTypeDef;
N
N
N/**
N  * @brief  USART handle Structure definition
N  */
Ntypedef struct
N{
N  USART_TypeDef                 *Instance;        /*!<  USART registers base address        */
N
N  USART_InitTypeDef             Init;             /*!< USART communication parameters      */
N
N  uint8_t                       *pTxBuffPtr;      /*!< Pointer to USART Tx transfer Buffer */
N
N  uint16_t                      TxXferSize;       /*!< USART Tx Transfer size              */
N
N  uint16_t                      TxXferCount;      /*!< USART Tx Transfer Counter           */
N
N  uint8_t                       *pRxBuffPtr;      /*!< Pointer to USART Rx transfer Buffer */
N
N  uint16_t                      RxXferSize;       /*!< USART Rx Transfer size              */
N
N  uint16_t                      RxXferCount;      /*!< USART Rx Transfer Counter           */
N
N  uint16_t                      Mask;             /*!< USART Rx RDR register mask          */
N
N  DMA_HandleTypeDef             *hdmatx;          /*!< USART Tx DMA Handle parameters      */
N
N  DMA_HandleTypeDef             *hdmarx;          /*!< USART Rx DMA Handle parameters      */
N
N  HAL_LockTypeDef               Lock;            /*!<  Locking object                      */
N
N  HAL_USART_StateTypeDef        State;           /*!< USART communication state           */
N
N  __IO uint32_t                 ErrorCode;       /*!< USART Error code                    */
X  volatile uint32_t                 ErrorCode;        
N
N}USART_HandleTypeDef;
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup USART_Exported_Constants USART Exported Constants
N  * @{
N  */
N
N/** @defgroup USART_Error_Code USART Error Code
N  * @brief    USART Error Code 
N  * @{
N  */ 
N#define HAL_USART_ERROR_NONE         ((uint32_t)0x00000000U)   /*!< No error            */
N#define HAL_USART_ERROR_PE           ((uint32_t)0x00000001U)   /*!< Parity error        */
N#define HAL_USART_ERROR_NE           ((uint32_t)0x00000002U)   /*!< Noise error         */
N#define HAL_USART_ERROR_FE           ((uint32_t)0x00000004U)   /*!< Frame error         */
N#define HAL_USART_ERROR_ORE          ((uint32_t)0x00000008U)   /*!< Overrun error       */
N#define HAL_USART_ERROR_DMA          ((uint32_t)0x00000010U)   /*!< DMA transfer error  */
N/**
N  * @}
N  */
N
N/** @defgroup USART_Stop_Bits  USART Number of Stop Bits
N  * @{
N  */
N#define USART_STOPBITS_1                     ((uint32_t)0x0000U)
N#define USART_STOPBITS_2                     ((uint32_t)USART_CR2_STOP_1)
N#define USART_STOPBITS_1_5                   ((uint32_t)(USART_CR2_STOP_0 | USART_CR2_STOP_1))
N/**
N  * @}
N  */
N
N/** @defgroup USART_Parity    USART Parity
N  * @{
N  */
N#define USART_PARITY_NONE                   ((uint32_t)0x0000U)
N#define USART_PARITY_EVEN                   ((uint32_t)USART_CR1_PCE)
N#define USART_PARITY_ODD                    ((uint32_t)(USART_CR1_PCE | USART_CR1_PS))
N/**
N  * @}
N  */
N
N/** @defgroup USART_Mode   USART Mode
N  * @{
N  */
N#define USART_MODE_RX                       ((uint32_t)USART_CR1_RE)
N#define USART_MODE_TX                       ((uint32_t)USART_CR1_TE)
N#define USART_MODE_TX_RX                    ((uint32_t)(USART_CR1_TE |USART_CR1_RE))
N/**
N  * @}
N  */
N
N/** @defgroup USART_Over_Sampling USART Over Sampling
N  * @{
N  */
N#define USART_OVERSAMPLING_16               ((uint32_t)0x0000U)
N#define USART_OVERSAMPLING_8                ((uint32_t)USART_CR1_OVER8)
N/**
N  * @}
N  */
N/** @defgroup USART_Clock  USART Clock
N  * @{
N  */
N#define USART_CLOCK_DISABLE                 ((uint32_t)0x0000U)
N#define USART_CLOCK_ENABLE                  ((uint32_t)USART_CR2_CLKEN)
N/**
N  * @}
N  */
N
N/** @defgroup USART_Clock_Polarity  USART Clock Polarity
N  * @{
N  */
N#define USART_POLARITY_LOW                  ((uint32_t)0x0000U)
N#define USART_POLARITY_HIGH                 ((uint32_t)USART_CR2_CPOL)
N/**
N  * @}
N  */
N
N/** @defgroup USART_Clock_Phase   USART Clock Phase
N  * @{
N  */
N#define USART_PHASE_1EDGE                   ((uint32_t)0x0000U)
N#define USART_PHASE_2EDGE                   ((uint32_t)USART_CR2_CPHA)
N/**
N  * @}
N  */
N
N/** @defgroup USART_Last_Bit  USART Last Bit
N  * @{
N  */
N#define USART_LASTBIT_DISABLE               ((uint32_t)0x0000U)
N#define USART_LASTBIT_ENABLE                ((uint32_t)USART_CR2_LBCL)
N/**
N  * @}
N  */
N
N/** @defgroup USART_Request_Parameters  USART Request Parameters
N  * @{
N  */
N#define USART_RXDATA_FLUSH_REQUEST        ((uint32_t)USART_RQR_RXFRQ)        /*!< Receive Data flush Request */ 
N#define USART_TXDATA_FLUSH_REQUEST        ((uint32_t)USART_RQR_TXFRQ)        /*!< Transmit data flush Request */
N/**
N  * @}
N  */
N
N/** @defgroup USART_Flags      USART Flags
N  *        Elements values convention: 0xXXXX
N  *           - 0xXXXX  : Flag mask in the ISR register
N  * @{
N  */
N#define USART_FLAG_REACK                     ((uint32_t)0x00400000U)
N#define USART_FLAG_TEACK                     ((uint32_t)0x00200000U)  
N#define USART_FLAG_BUSY                      ((uint32_t)0x00010000U)
N#define USART_FLAG_CTS                       ((uint32_t)0x00000400U)
N#define USART_FLAG_CTSIF                     ((uint32_t)0x00000200U)
N#define USART_FLAG_LBDF                      ((uint32_t)0x00000100U)
N#define USART_FLAG_TXE                       ((uint32_t)0x00000080U)
N#define USART_FLAG_TC                        ((uint32_t)0x00000040U)
N#define USART_FLAG_RXNE                      ((uint32_t)0x00000020U)
N#define USART_FLAG_IDLE                      ((uint32_t)0x00000010U)
N#define USART_FLAG_ORE                       ((uint32_t)0x00000008U)
N#define USART_FLAG_NE                        ((uint32_t)0x00000004U)
N#define USART_FLAG_FE                        ((uint32_t)0x00000002U)
N#define USART_FLAG_PE                        ((uint32_t)0x00000001U)
N/**
N  * @}
N  */
N
N/** @defgroup USART_Interrupt_definition USART Interrupts Definition
N  *        Elements values convention: 0000ZZZZ0XXYYYYYb
N  *           - YYYYY  : Interrupt source position in the XX register (5bits)
N  *           - XX  : Interrupt source register (2bits)
N  *                 - 01: CR1 register
N  *                 - 10: CR2 register
N  *                 - 11: CR3 register
N  *           - ZZZZ  : Flag position in the ISR register(4bits)
N  * @{
N  */
N
N#define USART_IT_PE                          ((uint16_t)0x0028U)
N#define USART_IT_TXE                         ((uint16_t)0x0727U)
N#define USART_IT_TC                          ((uint16_t)0x0626U)
N#define USART_IT_RXNE                        ((uint16_t)0x0525U)
N#define USART_IT_IDLE                        ((uint16_t)0x0424U)
N#define USART_IT_ERR                         ((uint16_t)0x0060U)
N
N#define USART_IT_ORE                         ((uint16_t)0x0300U)
N#define USART_IT_NE                          ((uint16_t)0x0200U)
N#define USART_IT_FE                          ((uint16_t)0x0100U)
N/**
N  * @}
N  */
N
N/** @defgroup USART_IT_CLEAR_Flags    USART Interruption Clear Flags
N  * @{
N  */
N#define USART_CLEAR_PEF                       USART_ICR_PECF            /*!< Parity Error Clear Flag */
N#define USART_CLEAR_FEF                       USART_ICR_FECF            /*!< Framing Error Clear Flag */
N#define USART_CLEAR_NEF                       USART_ICR_NCF             /*!< Noise detected Clear Flag */
N#define USART_CLEAR_OREF                      USART_ICR_ORECF           /*!< OverRun Error Clear Flag */
N#define USART_CLEAR_IDLEF                     USART_ICR_IDLECF          /*!< IDLE line detected Clear Flag */
N#define USART_CLEAR_TCF                       USART_ICR_TCCF            /*!< Transmission Complete Clear Flag */
N#define USART_CLEAR_CTSF                      USART_ICR_CTSCF           /*!< CTS Interrupt Clear Flag */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macros -----------------------------------------------------------*/
N/** @defgroup USART_Exported_Macros USART Exported Macros
N  * @{
N  */
N
N/** @brief Reset USART handle state
N  * @param  __HANDLE__: USART handle.
N  * @retval None
N  */
N#define __HAL_USART_RESET_HANDLE_STATE(__HANDLE__)  ((__HANDLE__)->State = HAL_USART_STATE_RESET)
N
N/** @brief  Checks whether the specified USART flag is set or not.
N  * @param  __HANDLE__: specifies the USART Handle
N  * @param  __FLAG__: specifies the flag to check.
N  *        This parameter can be one of the following values:
N  *            @arg USART_FLAG_REACK: Receive enable acknowledge flag
N  *            @arg USART_FLAG_TEACK: Transmit enable acknowledge flag
N  *            @arg USART_FLAG_BUSY:  Busy flag
N  *            @arg USART_FLAG_CTS:   CTS Change flag
N  *            @arg USART_FLAG_TXE:   Transmit data register empty flag
N  *            @arg USART_FLAG_TC:    Transmission Complete flag
N  *            @arg USART_FLAG_RXNE:  Receive data register not empty flag
N  *            @arg USART_FLAG_IDLE:  Idle Line detection flag
N  *            @arg USART_FLAG_ORE:   OverRun Error flag
N  *            @arg USART_FLAG_NE:    Noise Error flag
N  *            @arg USART_FLAG_FE:    Framing Error flag
N  *            @arg USART_FLAG_PE:    Parity Error flag
N  * @retval The new state of __FLAG__ (TRUE or FALSE).
N  */
N#define __HAL_USART_GET_FLAG(__HANDLE__, __FLAG__) (((__HANDLE__)->Instance->ISR & (__FLAG__)) == (__FLAG__))
N
N
N/** @brief  Enables the specified USART interrupt.
N  * @param  __HANDLE__: specifies the USART Handle
N  * @param  __INTERRUPT__: specifies the USART interrupt source to enable.
N  *          This parameter can be one of the following values:
N  *            @arg USART_IT_TXE:  Transmit Data Register empty interrupt
N  *            @arg USART_IT_TC:   Transmission complete interrupt
N  *            @arg USART_IT_RXNE: Receive Data register not empty interrupt
N  *            @arg USART_IT_IDLE: Idle line detection interrupt
N  *            @arg USART_IT_PE:   Parity Error interrupt
N  *            @arg USART_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
N  * @retval None
N  */
N#define __HAL_USART_ENABLE_IT(__HANDLE__, __INTERRUPT__)   (((((uint8_t)(__INTERRUPT__)) >> 5U) == 1)? ((__HANDLE__)->Instance->CR1 |= (1U << ((__INTERRUPT__) & USART_IT_MASK))): \
N                                                            ((((uint8_t)(__INTERRUPT__)) >> 5U) == 2)? ((__HANDLE__)->Instance->CR2 |= (1U << ((__INTERRUPT__) & USART_IT_MASK))): \
N                                                            ((__HANDLE__)->Instance->CR3 |= (1U << ((__INTERRUPT__) & USART_IT_MASK))))
X#define __HAL_USART_ENABLE_IT(__HANDLE__, __INTERRUPT__)   (((((uint8_t)(__INTERRUPT__)) >> 5U) == 1)? ((__HANDLE__)->Instance->CR1 |= (1U << ((__INTERRUPT__) & USART_IT_MASK))):                                                             ((((uint8_t)(__INTERRUPT__)) >> 5U) == 2)? ((__HANDLE__)->Instance->CR2 |= (1U << ((__INTERRUPT__) & USART_IT_MASK))):                                                             ((__HANDLE__)->Instance->CR3 |= (1U << ((__INTERRUPT__) & USART_IT_MASK))))
N
N/** @brief  Disables the specified USART interrupt.
N  * @param  __HANDLE__: specifies the USART Handle.
N  * @param  __INTERRUPT__: specifies the USART interrupt source to disable.
N  *          This parameter can be one of the following values:
N  *            @arg USART_IT_TXE:  Transmit Data Register empty interrupt
N  *            @arg USART_IT_TC:   Transmission complete interrupt
N  *            @arg USART_IT_RXNE: Receive Data register not empty interrupt
N  *            @arg USART_IT_IDLE: Idle line detection interrupt
N  *            @arg USART_IT_PE:   Parity Error interrupt
N  *            @arg USART_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
N  * @retval None
N  */
N#define __HAL_USART_DISABLE_IT(__HANDLE__, __INTERRUPT__)  (((((uint8_t)(__INTERRUPT__)) >> 5U) == 1)? ((__HANDLE__)->Instance->CR1 &= ~ (1U << ((__INTERRUPT__) & USART_IT_MASK))): \
N                                                            ((((uint8_t)(__INTERRUPT__)) >> 5U) == 2)? ((__HANDLE__)->Instance->CR2 &= ~ (1U << ((__INTERRUPT__) & USART_IT_MASK))): \
N                                                            ((__HANDLE__)->Instance->CR3 &= ~ (1U << ((__INTERRUPT__) & USART_IT_MASK))))
X#define __HAL_USART_DISABLE_IT(__HANDLE__, __INTERRUPT__)  (((((uint8_t)(__INTERRUPT__)) >> 5U) == 1)? ((__HANDLE__)->Instance->CR1 &= ~ (1U << ((__INTERRUPT__) & USART_IT_MASK))):                                                             ((((uint8_t)(__INTERRUPT__)) >> 5U) == 2)? ((__HANDLE__)->Instance->CR2 &= ~ (1U << ((__INTERRUPT__) & USART_IT_MASK))):                                                             ((__HANDLE__)->Instance->CR3 &= ~ (1U << ((__INTERRUPT__) & USART_IT_MASK))))
N
N
N/** @brief  Checks whether the specified USART interrupt has occurred or not.
N  * @param  __HANDLE__: specifies the USART Handle
N  * @param  __IT__: specifies the USART interrupt source to check.
N  *          This parameter can be one of the following values:
N  *            @arg USART_IT_TXE: Transmit Data Register empty interrupt
N  *            @arg USART_IT_TC:  Transmission complete interrupt
N  *            @arg USART_IT_RXNE: Receive Data register not empty interrupt
N  *            @arg USART_IT_IDLE: Idle line detection interrupt
N  *            @arg USART_IT_ORE: OverRun Error interrupt
N  *            @arg USART_IT_NE: Noise Error interrupt
N  *            @arg USART_IT_FE: Framing Error interrupt
N  *            @arg USART_IT_PE: Parity Error interrupt
N  * @retval The new state of __IT__ (TRUE or FALSE).
N  */
N#define __HAL_USART_GET_IT(__HANDLE__, __IT__) ((__HANDLE__)->Instance->ISR & ((uint32_t)1 << ((__IT__)>> 0x08)))
N
N/** @brief  Checks whether the specified USART interrupt source is enabled.
N  * @param  __HANDLE__: specifies the USART Handle.
N  * @param  __IT__: specifies the USART interrupt source to check.
N  *          This parameter can be one of the following values:
N  *            @arg USART_IT_TXE: Transmit Data Register empty interrupt
N  *            @arg USART_IT_TC:  Transmission complete interrupt
N  *            @arg USART_IT_RXNE: Receive Data register not empty interrupt
N  *            @arg USART_IT_IDLE: Idle line detection interrupt
N  *            @arg USART_IT_ORE: OverRun Error interrupt
N  *            @arg USART_IT_NE: Noise Error interrupt
N  *            @arg USART_IT_FE: Framing Error interrupt
N  *            @arg USART_IT_PE: Parity Error interrupt
N  * @retval The new state of __IT__ (TRUE or FALSE).
N  */
N#define __HAL_USART_GET_IT_SOURCE(__HANDLE__, __IT__) ((((((uint8_t)(__IT__)) >> 5) == 1)? (__HANDLE__)->Instance->CR1:(((((uint8_t)(__IT__)) >> 5) == 2)? \
N                                                   (__HANDLE__)->Instance->CR2 : (__HANDLE__)->Instance->CR3)) & ((uint32_t)1 << \
N                                                   (((uint16_t)(__IT__)) & USART_IT_MASK)))
X#define __HAL_USART_GET_IT_SOURCE(__HANDLE__, __IT__) ((((((uint8_t)(__IT__)) >> 5) == 1)? (__HANDLE__)->Instance->CR1:(((((uint8_t)(__IT__)) >> 5) == 2)?                                                    (__HANDLE__)->Instance->CR2 : (__HANDLE__)->Instance->CR3)) & ((uint32_t)1 <<                                                    (((uint16_t)(__IT__)) & USART_IT_MASK)))
N
N
N/** @brief  Clears the specified USART ISR flag, in setting the proper ICR register flag.
N  * @param  __HANDLE__: specifies the USART Handle.
N  * @param  __IT_CLEAR__: specifies the interrupt clear register flag that needs to be set
N  *                       to clear the corresponding interrupt
N  *          This parameter can be one of the following values:
N  *            @arg USART_CLEAR_PEF: Parity Error Clear Flag
N  *            @arg USART_CLEAR_FEF: Framing Error Clear Flag
N  *            @arg USART_CLEAR_NEF: Noise detected Clear Flag
N  *            @arg USART_CLEAR_OREF: OverRun Error Clear Flag
N  *            @arg USART_CLEAR_IDLEF: IDLE line detected Clear Flag
N  *            @arg USART_CLEAR_TCF: Transmission Complete Clear Flag
N  *            @arg USART_CLEAR_CTSF: CTS Interrupt Clear Flag
N  * @retval None
N  */
N#define __HAL_USART_CLEAR_IT(__HANDLE__, __IT_CLEAR__) ((__HANDLE__)->Instance->ICR = (uint32_t)(__IT_CLEAR__))
N
N/** @brief  Set a specific USART request flag.
N  * @param  __HANDLE__: specifies the USART Handle.
N  * @param  __REQ__: specifies the request flag to set
N  *          This parameter can be one of the following values:
N  *            @arg USART_RXDATA_FLUSH_REQUEST: Receive Data flush Request
N  *            @arg USART_TXDATA_FLUSH_REQUEST: Transmit data flush Request
N  *
N  * @retval None
N  */
N#define __HAL_USART_SEND_REQ(__HANDLE__, __REQ__) ((__HANDLE__)->Instance->RQR |= (uint16_t)(__REQ__)) 
N
N/** @brief  Enable USART
N  * @param  __HANDLE__: specifies the USART Handle.
N  * @retval None
N  */
N#define __HAL_USART_ENABLE(__HANDLE__)                 ((__HANDLE__)->Instance->CR1 |=  USART_CR1_UE)
N
N/** @brief  Disable USART
N  * @param  __HANDLE__: specifies the USART Handle.
N  * @retval None
N  */
N#define __HAL_USART_DISABLE(__HANDLE__)                ((__HANDLE__)->Instance->CR1 &=  ~USART_CR1_UE)
N
N/**
N  * @}
N  */
N/* Include UART HAL Extension module */
N#include "stm32f7xx_hal_usart_ex.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_usart_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_usart_ex.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of USART HAL Extension module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_USART_EX_H
N#define __STM32F7xx_HAL_USART_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup USARTEx
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup USARTEx_Exported_Constants USARTEx Exported Constants
N  * @{
N  */
N
N/** @defgroup USARTEx_Word_Length USARTEx Word Length
N  * @{
N  */
N#define USART_WORDLENGTH_7B                  ((uint32_t)USART_CR1_M_1)
N#define USART_WORDLENGTH_8B                  ((uint32_t)0x00000000U)
N#define USART_WORDLENGTH_9B                  ((uint32_t)USART_CR1_M_0)
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup USARTEx_Private_Macros USARTEx Private Macros
N  * @{
N  */
N
N/** @brief  Computes the USART mask to apply to retrieve the received data
N  *         according to the word length and to the parity bits activation.
N  *         If PCE = 1, the parity bit is not included in the data extracted
N  *         by the reception API().
N  *         This masking operation is not carried out in the case of
N  *         DMA transfers.
N  * @param  __HANDLE__: specifies the USART Handle
N  * @retval none
N  */
N#define __HAL_USART_MASK_COMPUTATION(__HANDLE__)                      \
N  do {                                                                \
N  if ((__HANDLE__)->Init.WordLength == USART_WORDLENGTH_9B)           \
N  {                                                                   \
N     if ((__HANDLE__)->Init.Parity == USART_PARITY_NONE)              \
N     {                                                                \
N        (__HANDLE__)->Mask = 0x01FF ;                                 \
N     }                                                                \
N     else                                                             \
N     {                                                                \
N        (__HANDLE__)->Mask = 0x00FF ;                                 \
N     }                                                                \
N  }                                                                   \
N  else if ((__HANDLE__)->Init.WordLength == USART_WORDLENGTH_8B)      \
N  {                                                                   \
N     if ((__HANDLE__)->Init.Parity == USART_PARITY_NONE)              \
N     {                                                                \
N        (__HANDLE__)->Mask = 0x00FF ;                                 \
N     }                                                                \
N     else                                                             \
N     {                                                                \
N        (__HANDLE__)->Mask = 0x007F ;                                 \
N     }                                                                \
N  }                                                                   \
N  else if ((__HANDLE__)->Init.WordLength == USART_WORDLENGTH_7B)      \
N  {                                                                   \
N     if ((__HANDLE__)->Init.Parity == USART_PARITY_NONE)              \
N     {                                                                \
N        (__HANDLE__)->Mask = 0x007F ;                                 \
N     }                                                                \
N     else                                                             \
N     {                                                                \
N        (__HANDLE__)->Mask = 0x003F ;                                 \
N     }                                                                \
N  }                                                                   \
N} while(0)
X#define __HAL_USART_MASK_COMPUTATION(__HANDLE__)                        do {                                                                  if ((__HANDLE__)->Init.WordLength == USART_WORDLENGTH_9B)             {                                                                        if ((__HANDLE__)->Init.Parity == USART_PARITY_NONE)                   {                                                                        (__HANDLE__)->Mask = 0x01FF ;                                      }                                                                     else                                                                  {                                                                        (__HANDLE__)->Mask = 0x00FF ;                                      }                                                                  }                                                                     else if ((__HANDLE__)->Init.WordLength == USART_WORDLENGTH_8B)        {                                                                        if ((__HANDLE__)->Init.Parity == USART_PARITY_NONE)                   {                                                                        (__HANDLE__)->Mask = 0x00FF ;                                      }                                                                     else                                                                  {                                                                        (__HANDLE__)->Mask = 0x007F ;                                      }                                                                  }                                                                     else if ((__HANDLE__)->Init.WordLength == USART_WORDLENGTH_7B)        {                                                                        if ((__HANDLE__)->Init.Parity == USART_PARITY_NONE)                   {                                                                        (__HANDLE__)->Mask = 0x007F ;                                      }                                                                     else                                                                  {                                                                        (__HANDLE__)->Mask = 0x003F ;                                      }                                                                  }                                                                   } while(0)
N
N#define IS_USART_WORD_LENGTH(__LENGTH__) (((__LENGTH__) == USART_WORDLENGTH_7B) || \
N                                          ((__LENGTH__) == USART_WORDLENGTH_8B) || \
N                                          ((__LENGTH__) == USART_WORDLENGTH_9B))                                 
X#define IS_USART_WORD_LENGTH(__LENGTH__) (((__LENGTH__) == USART_WORDLENGTH_7B) ||                                           ((__LENGTH__) == USART_WORDLENGTH_8B) ||                                           ((__LENGTH__) == USART_WORDLENGTH_9B))                                 
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/* Initialization/de-initialization methods  **********************************/
N/* IO operation methods *******************************************************/
N/* Peripheral Control methods  ************************************************/
N/* Peripheral State methods  **************************************************/
N
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_USART_EX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 481 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_usart.h" 2
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup USART_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup USART_Exported_Functions_Group1
N  * @{
N  */
N/* Initialization/de-initialization functions  **********************************/
NHAL_StatusTypeDef HAL_USART_Init(USART_HandleTypeDef *husart);
NHAL_StatusTypeDef HAL_USART_DeInit(USART_HandleTypeDef *husart);
Nvoid HAL_USART_MspInit(USART_HandleTypeDef *husart);
Nvoid HAL_USART_MspDeInit(USART_HandleTypeDef *husart);
NHAL_StatusTypeDef HAL_USART_CheckIdleState(USART_HandleTypeDef *husart);
N/**
N  * @}
N  */
N
N/** @addtogroup USART_Exported_Functions_Group2
N  * @{
N  */
N/* IO operation functions *******************************************************/
NHAL_StatusTypeDef HAL_USART_Transmit(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_USART_Receive(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_USART_TransmitReceive(USART_HandleTypeDef *husart, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_USART_Transmit_IT(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size);
NHAL_StatusTypeDef HAL_USART_Receive_IT(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size);
NHAL_StatusTypeDef HAL_USART_TransmitReceive_IT(USART_HandleTypeDef *husart, uint8_t *pTxData, uint8_t *pRxData,  uint16_t Size);
NHAL_StatusTypeDef HAL_USART_Transmit_DMA(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size);
NHAL_StatusTypeDef HAL_USART_Receive_DMA(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size);
NHAL_StatusTypeDef HAL_USART_TransmitReceive_DMA(USART_HandleTypeDef *husart, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size);
NHAL_StatusTypeDef HAL_USART_DMAPause(USART_HandleTypeDef *husart);
NHAL_StatusTypeDef HAL_USART_DMAResume(USART_HandleTypeDef *husart);
NHAL_StatusTypeDef HAL_USART_DMAStop(USART_HandleTypeDef *husart);
Nvoid HAL_USART_IRQHandler(USART_HandleTypeDef *husart);
Nvoid HAL_USART_TxHalfCpltCallback(USART_HandleTypeDef *husart);
Nvoid HAL_USART_TxCpltCallback(USART_HandleTypeDef *husart);
Nvoid HAL_USART_RxCpltCallback(USART_HandleTypeDef *husart);
Nvoid HAL_USART_RxHalfCpltCallback(USART_HandleTypeDef *husart);
Nvoid HAL_USART_TxRxCpltCallback(USART_HandleTypeDef *husart);
Nvoid HAL_USART_ErrorCallback(USART_HandleTypeDef *husart);
N
N/**
N  * @}
N  */ 
N
N/** @addtogroup USART_Exported_Functions_Group3
N  * @{
N  */
N/* Peripheral State functions  ************************************************/
NHAL_USART_StateTypeDef HAL_USART_GetState(USART_HandleTypeDef *husart);
Nuint32_t               HAL_USART_GetError(USART_HandleTypeDef *husart);
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup USART_Private_Constants USART Private Constants
N  * @{
N  */
N/** @brief USART interruptions flag mask
N  * 
N  */ 
N#define USART_IT_MASK                             ((uint16_t)0x001FU)
N
N/**
N  * @}
N  */
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup USART_Private_Macros USART Private Macros
N  * @{
N  */
N/** @brief  Reports the USART clock source.
N  * @param  __HANDLE__: specifies the USART Handle
N  * @param  __CLOCKSOURCE__ : output variable
N  * @retval the USART clocking source, written in __CLOCKSOURCE__.
N  */
N#define USART_GETCLOCKSOURCE(__HANDLE__, __CLOCKSOURCE__)\
N  do {                                                         \
N    if((__HANDLE__)->Instance == USART1)                       \
N    {                                                          \
N       switch(__HAL_RCC_GET_USART1_SOURCE())                   \
N       {                                                       \
N        case RCC_USART1CLKSOURCE_PCLK2:                        \
N          (__CLOCKSOURCE__) = USART_CLOCKSOURCE_PCLK2;         \
N          break;                                               \
N        case RCC_USART1CLKSOURCE_HSI:                          \
N          (__CLOCKSOURCE__) = USART_CLOCKSOURCE_HSI;           \
N          break;                                               \
N        case RCC_USART1CLKSOURCE_SYSCLK:                       \
N          (__CLOCKSOURCE__) = USART_CLOCKSOURCE_SYSCLK;        \
N          break;                                               \
N        case RCC_USART1CLKSOURCE_LSE:                          \
N          (__CLOCKSOURCE__) = USART_CLOCKSOURCE_LSE;           \
N          break;                                               \
N        default:                                               \
N          break;                                               \
N       }                                                       \
N    }                                                          \
N    else if((__HANDLE__)->Instance == USART2)                  \
N    {                                                          \
N       switch(__HAL_RCC_GET_USART2_SOURCE())                   \
N       {                                                       \
N        case RCC_USART2CLKSOURCE_PCLK1:                        \
N          (__CLOCKSOURCE__) = USART_CLOCKSOURCE_PCLK1;         \
N          break;                                               \
N        case RCC_USART2CLKSOURCE_HSI:                          \
N          (__CLOCKSOURCE__) = USART_CLOCKSOURCE_HSI;           \
N          break;                                               \
N        case RCC_USART2CLKSOURCE_SYSCLK:                       \
N          (__CLOCKSOURCE__) = USART_CLOCKSOURCE_SYSCLK;        \
N          break;                                               \
N        case RCC_USART2CLKSOURCE_LSE:                          \
N          (__CLOCKSOURCE__) = USART_CLOCKSOURCE_LSE;           \
N          break;                                               \
N        default:                                               \
N          break;                                               \
N       }                                                       \
N    }                                                          \
N    else if((__HANDLE__)->Instance == USART3)                  \
N    {                                                          \
N       switch(__HAL_RCC_GET_USART3_SOURCE())                   \
N       {                                                       \
N        case RCC_USART3CLKSOURCE_PCLK1:                        \
N          (__CLOCKSOURCE__) = USART_CLOCKSOURCE_PCLK1;         \
N          break;                                               \
N        case RCC_USART3CLKSOURCE_HSI:                          \
N          (__CLOCKSOURCE__) = USART_CLOCKSOURCE_HSI;           \
N          break;                                               \
N        case RCC_USART3CLKSOURCE_SYSCLK:                       \
N          (__CLOCKSOURCE__) = USART_CLOCKSOURCE_SYSCLK;        \
N          break;                                               \
N        case RCC_USART3CLKSOURCE_LSE:                          \
N          (__CLOCKSOURCE__) = USART_CLOCKSOURCE_LSE;           \
N          break;                                               \
N        default:                                               \
N          break;                                               \
N       }                                                       \
N    }                                                          \
N    else if((__HANDLE__)->Instance == USART6)                  \
N    {                                                          \
N       switch(__HAL_RCC_GET_USART6_SOURCE())                   \
N       {                                                       \
N        case RCC_USART6CLKSOURCE_PCLK2:                        \
N          (__CLOCKSOURCE__) = USART_CLOCKSOURCE_PCLK2;         \
N          break;                                               \
N        case RCC_USART6CLKSOURCE_HSI:                          \
N          (__CLOCKSOURCE__) = USART_CLOCKSOURCE_HSI;           \
N          break;                                               \
N        case RCC_USART6CLKSOURCE_SYSCLK:                       \
N          (__CLOCKSOURCE__) = USART_CLOCKSOURCE_SYSCLK;        \
N          break;                                               \
N        case RCC_USART6CLKSOURCE_LSE:                          \
N          (__CLOCKSOURCE__) = USART_CLOCKSOURCE_LSE;           \
N          break;                                               \
N        default:                                               \
N          break;                                               \
N       }                                                       \
N    }                                                          \
N } while(0)
X#define USART_GETCLOCKSOURCE(__HANDLE__, __CLOCKSOURCE__)  do {                                                             if((__HANDLE__)->Instance == USART1)                           {                                                                 switch(__HAL_RCC_GET_USART1_SOURCE())                          {                                                               case RCC_USART1CLKSOURCE_PCLK2:                                  (__CLOCKSOURCE__) = USART_CLOCKSOURCE_PCLK2;                   break;                                                       case RCC_USART1CLKSOURCE_HSI:                                    (__CLOCKSOURCE__) = USART_CLOCKSOURCE_HSI;                     break;                                                       case RCC_USART1CLKSOURCE_SYSCLK:                                 (__CLOCKSOURCE__) = USART_CLOCKSOURCE_SYSCLK;                  break;                                                       case RCC_USART1CLKSOURCE_LSE:                                    (__CLOCKSOURCE__) = USART_CLOCKSOURCE_LSE;                     break;                                                       default:                                                         break;                                                      }                                                           }                                                              else if((__HANDLE__)->Instance == USART2)                      {                                                                 switch(__HAL_RCC_GET_USART2_SOURCE())                          {                                                               case RCC_USART2CLKSOURCE_PCLK1:                                  (__CLOCKSOURCE__) = USART_CLOCKSOURCE_PCLK1;                   break;                                                       case RCC_USART2CLKSOURCE_HSI:                                    (__CLOCKSOURCE__) = USART_CLOCKSOURCE_HSI;                     break;                                                       case RCC_USART2CLKSOURCE_SYSCLK:                                 (__CLOCKSOURCE__) = USART_CLOCKSOURCE_SYSCLK;                  break;                                                       case RCC_USART2CLKSOURCE_LSE:                                    (__CLOCKSOURCE__) = USART_CLOCKSOURCE_LSE;                     break;                                                       default:                                                         break;                                                      }                                                           }                                                              else if((__HANDLE__)->Instance == USART3)                      {                                                                 switch(__HAL_RCC_GET_USART3_SOURCE())                          {                                                               case RCC_USART3CLKSOURCE_PCLK1:                                  (__CLOCKSOURCE__) = USART_CLOCKSOURCE_PCLK1;                   break;                                                       case RCC_USART3CLKSOURCE_HSI:                                    (__CLOCKSOURCE__) = USART_CLOCKSOURCE_HSI;                     break;                                                       case RCC_USART3CLKSOURCE_SYSCLK:                                 (__CLOCKSOURCE__) = USART_CLOCKSOURCE_SYSCLK;                  break;                                                       case RCC_USART3CLKSOURCE_LSE:                                    (__CLOCKSOURCE__) = USART_CLOCKSOURCE_LSE;                     break;                                                       default:                                                         break;                                                      }                                                           }                                                              else if((__HANDLE__)->Instance == USART6)                      {                                                                 switch(__HAL_RCC_GET_USART6_SOURCE())                          {                                                               case RCC_USART6CLKSOURCE_PCLK2:                                  (__CLOCKSOURCE__) = USART_CLOCKSOURCE_PCLK2;                   break;                                                       case RCC_USART6CLKSOURCE_HSI:                                    (__CLOCKSOURCE__) = USART_CLOCKSOURCE_HSI;                     break;                                                       case RCC_USART6CLKSOURCE_SYSCLK:                                 (__CLOCKSOURCE__) = USART_CLOCKSOURCE_SYSCLK;                  break;                                                       case RCC_USART6CLKSOURCE_LSE:                                    (__CLOCKSOURCE__) = USART_CLOCKSOURCE_LSE;                     break;                                                       default:                                                         break;                                                      }                                                           }                                                           } while(0)
N  
N
N#define IS_USART_STOPBITS(__STOPBITS__) (((__STOPBITS__) == USART_STOPBITS_1) || \
N                                         ((__STOPBITS__) == USART_STOPBITS_1_5) || \
N                                         ((__STOPBITS__) == USART_STOPBITS_2))
X#define IS_USART_STOPBITS(__STOPBITS__) (((__STOPBITS__) == USART_STOPBITS_1) ||                                          ((__STOPBITS__) == USART_STOPBITS_1_5) ||                                          ((__STOPBITS__) == USART_STOPBITS_2))
N#define IS_USART_PARITY(__PARITY__) (((__PARITY__) == USART_PARITY_NONE) || \
N                                     ((__PARITY__) == USART_PARITY_EVEN) || \
N                                     ((__PARITY__) == USART_PARITY_ODD))
X#define IS_USART_PARITY(__PARITY__) (((__PARITY__) == USART_PARITY_NONE) ||                                      ((__PARITY__) == USART_PARITY_EVEN) ||                                      ((__PARITY__) == USART_PARITY_ODD))
N#define IS_USART_MODE(__MODE__) ((((__MODE__) & (uint32_t)0xFFFFFFF3U) == 0x00U) && ((__MODE__) != (uint32_t)0x00U))
N#define IS_USART_OVERSAMPLING(__SAMPLING__) (((__SAMPLING__) == USART_OVERSAMPLING_16) || \
N                                             ((__SAMPLING__) == USART_OVERSAMPLING_8))
X#define IS_USART_OVERSAMPLING(__SAMPLING__) (((__SAMPLING__) == USART_OVERSAMPLING_16) ||                                              ((__SAMPLING__) == USART_OVERSAMPLING_8))
N#define IS_USART_CLOCK(__CLOCK__)     (((__CLOCK__)== USART_CLOCK_DISABLE) || \
N                                       ((__CLOCK__)== USART_CLOCK_ENABLE))
X#define IS_USART_CLOCK(__CLOCK__)     (((__CLOCK__)== USART_CLOCK_DISABLE) ||                                        ((__CLOCK__)== USART_CLOCK_ENABLE))
N#define IS_USART_POLARITY(__CPOL__) (((__CPOL__) == USART_POLARITY_LOW) || ((__CPOL__) == USART_POLARITY_HIGH))
N#define IS_USART_PHASE(__CPHA__) (((__CPHA__) == USART_PHASE_1EDGE) || ((__CPHA__) == USART_PHASE_2EDGE))
N#define IS_USART_LASTBIT(__LASTBIT__) (((__LASTBIT__) == USART_LASTBIT_DISABLE) || \
N                                       ((__LASTBIT__) == USART_LASTBIT_ENABLE))
X#define IS_USART_LASTBIT(__LASTBIT__) (((__LASTBIT__) == USART_LASTBIT_DISABLE) ||                                        ((__LASTBIT__) == USART_LASTBIT_ENABLE))
N#define IS_USART_REQUEST_PARAMETER(__PARAM__) (((__PARAM__) == USART_RXDATA_FLUSH_REQUEST) || \
N                                               ((__PARAM__) == USART_TXDATA_FLUSH_REQUEST))   
X#define IS_USART_REQUEST_PARAMETER(__PARAM__) (((__PARAM__) == USART_RXDATA_FLUSH_REQUEST) ||                                                ((__PARAM__) == USART_TXDATA_FLUSH_REQUEST))   
N#define IS_USART_BAUDRATE(__BAUDRATE__) ((__BAUDRATE__) < 9000001)
N
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup USART_Private_Functions USART Private Functions
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_USART_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 383 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_USART_MODULE_ENABLED */
N
N#ifdef HAL_IRDA_MODULE_ENABLED
N #include "stm32f7xx_hal_irda.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_irda.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_irda.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of IRDA HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_IRDA_H
N#define __STM32F7xx_HAL_IRDA_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup IRDA
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/ 
N/** @defgroup IRDA_Exported_Types IRDA Exported Types
N  * @{
N  */
N/** 
N  * @brief IRDA Init Structure definition  
N  */ 
Ntypedef struct
N{
N  uint32_t BaudRate;                  /*!< This member configures the IRDA communication baud rate.
N                                           The baud rate register is computed using the following formula:
N                                              Baud Rate Register = ((PCLKx) / ((hirda->Init.BaudRate))) */
N
N  uint32_t WordLength;                /*!< Specifies the number of data bits transmitted or received in a frame.
N                                           This parameter can be a value of @ref IRDAEx_Word_Length */
N
N  uint32_t Parity;                    /*!< Specifies the parity mode.
N                                           This parameter can be a value of @ref IRDA_Parity
N                                           @note When parity is enabled, the computed parity is inserted
N                                                 at the MSB position of the transmitted data (9th bit when
N                                                 the word length is set to 9 data bits; 8th bit when the
N                                                 word length is set to 8 data bits). */
N 
N  uint16_t Mode;                      /*!< Specifies whether the Receive or Transmit mode is enabled or disabled.
N                                           This parameter can be a value of @ref IRDA_Transfer_Mode */
N  
N  uint8_t  Prescaler;                 /*!< Specifies the Prescaler value for dividing the UART/USART source clock
N                                           to achieve low-power frequency.
N                                           @note Prescaler value 0 is forbidden */
N  
N  uint16_t PowerMode;                 /*!< Specifies the IRDA power mode.
N                                           This parameter can be a value of @ref IRDA_Low_Power */
N}IRDA_InitTypeDef;
N
N/** 
N  * @brief HAL IRDA State structures definition 
N  * @note  HAL IRDA State value is a combination of 2 different substates: gState and RxState.
N  *        - gState contains IRDA state information related to global Handle management 
N  *          and also information related to Tx operations.
N  *          gState value coding follow below described bitmap :
N  *          b7-b6  Error information 
N  *             00 : No Error
N  *             01 : (Not Used)
N  *             10 : Timeout
N  *             11 : Error
N  *          b5     IP initilisation status
N  *             0  : Reset (IP not initialized)
N  *             1  : Init done (IP not initialized. HAL IRDA Init function already called)
N  *          b4-b3  (not used)
N  *             xx : Should be set to 00
N  *          b2     Intrinsic process state
N  *             0  : Ready
N  *             1  : Busy (IP busy with some configuration or internal operations)
N  *          b1     (not used)
N  *             x  : Should be set to 0
N  *          b0     Tx state
N  *             0  : Ready (no Tx operation ongoing)
N  *             1  : Busy (Tx operation ongoing)
N  *        - RxState contains information related to Rx operations.
N  *          RxState value coding follow below described bitmap :
N  *          b7-b6  (not used)
N  *             xx : Should be set to 00
N  *          b5     IP initilisation status
N  *             0  : Reset (IP not initialized)
N  *             1  : Init done (IP not initialized)
N  *          b4-b2  (not used)
N  *            xxx : Should be set to 000
N  *          b1     Rx state
N  *             0  : Ready (no Rx operation ongoing)
N  *             1  : Busy (Rx operation ongoing)
N  *          b0     (not used)
N  *             x  : Should be set to 0.
N  */ 
Ntypedef enum
N{
N  HAL_IRDA_STATE_RESET             = 0x00U,    /*!< Peripheral is not yet Initialized 
N                                                   Value is allowed for gState and RxState */
N  HAL_IRDA_STATE_READY             = 0x20U,    /*!< Peripheral Initialized and ready for use 
N                                                   Value is allowed for gState and RxState */
N  HAL_IRDA_STATE_BUSY              = 0x24U,    /*!< An internal process is ongoing 
N                                                   Value is allowed for gState only */
N  HAL_IRDA_STATE_BUSY_TX           = 0x21U,    /*!< Data Transmission process is ongoing 
N                                                   Value is allowed for gState only */
N  HAL_IRDA_STATE_BUSY_RX           = 0x22U,    /*!< Data Reception process is ongoing 
N                                                   Value is allowed for RxState only */
N  HAL_IRDA_STATE_BUSY_TX_RX        = 0x23U,    /*!< Data Transmission and Reception process is ongoing 
N                                                   Not to be used for neither gState nor RxState.
N                                                   Value is result of combination (Or) between gState and RxState values */
N  HAL_IRDA_STATE_TIMEOUT           = 0xA0U,    /*!< Timeout state 
N                                                   Value is allowed for gState only */
N  HAL_IRDA_STATE_ERROR             = 0xE0U     /*!< Error 
N                                                   Value is allowed for gState only */
N}HAL_IRDA_StateTypeDef;
N
N/**
N  * @brief IRDA clock sources definition
N  */
Ntypedef enum
N{
N  IRDA_CLOCKSOURCE_PCLK1      = 0x00U,    /*!< PCLK1 clock source  */
N  IRDA_CLOCKSOURCE_PCLK2      = 0x01U,    /*!< PCLK2 clock source  */
N  IRDA_CLOCKSOURCE_HSI        = 0x02U,    /*!< HSI clock source    */
N  IRDA_CLOCKSOURCE_SYSCLK     = 0x04U,    /*!< SYSCLK clock source */
N  IRDA_CLOCKSOURCE_LSE        = 0x08U     /*!< LSE clock source     */
N}IRDA_ClockSourceTypeDef;
N
N/** 
N  * @brief  IRDA handle Structure definition  
N  */
Ntypedef struct
N{
N  USART_TypeDef            *Instance;        /* IRDA registers base address        */
N
N  IRDA_InitTypeDef         Init;             /* IRDA communication parameters      */
N
N  uint8_t                  *pTxBuffPtr;      /* Pointer to IRDA Tx transfer Buffer */
N
N  uint16_t                 TxXferSize;       /* IRDA Tx Transfer size              */
N
N  uint16_t                 TxXferCount;      /* IRDA Tx Transfer Counter           */
N
N  uint8_t                  *pRxBuffPtr;      /* Pointer to IRDA Rx transfer Buffer */
N
N  uint16_t                 RxXferSize;       /* IRDA Rx Transfer size              */
N
N  uint16_t                 RxXferCount;      /* IRDA Rx Transfer Counter           */
N
N  uint16_t                 Mask;             /* IRDA RX RDR register mask         */
N
N  DMA_HandleTypeDef        *hdmatx;          /* IRDA Tx DMA Handle parameters      */
N
N  DMA_HandleTypeDef        *hdmarx;          /* IRDA Rx DMA Handle parameters      */
N
N  HAL_LockTypeDef          Lock;             /* Locking object                     */
N
N  __IO HAL_IRDA_StateTypeDef  gState;           /* IRDA state information related to global Handle management 
X  volatile HAL_IRDA_StateTypeDef  gState;           
N                                                   and also related to Tx operations.
N                                                   This parameter can be a value of @ref HAL_IRDA_StateTypeDef */
N
N  __IO HAL_IRDA_StateTypeDef  RxState;          /* IRDA state information related to Rx operations.
X  volatile HAL_IRDA_StateTypeDef  RxState;          
N                                                   This parameter can be a value of @ref HAL_IRDA_StateTypeDef */
N
N  __IO uint32_t    ErrorCode;   /* IRDA Error code                    */
X  volatile uint32_t    ErrorCode;    
N
N}IRDA_HandleTypeDef;
N
N/**
N  * @}
N  */ 
N
N/** 
N  * @brief  IRDA Configuration enumeration values definition  
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup IRDA_Exported_Constants IRDA Exported constants
N  * @{
N  */
N/** @defgroup IRDA_Error_Code IRDA Error Code
N  * @brief    IRDA Error Code 
N  * @{
N  */ 
N
N#define HAL_IRDA_ERROR_NONE      ((uint32_t)0x00000000U)    /*!< No error            */
N#define HAL_IRDA_ERROR_PE        ((uint32_t)0x00000001U)    /*!< Parity error        */
N#define HAL_IRDA_ERROR_NE        ((uint32_t)0x00000002U)    /*!< Noise error         */
N#define HAL_IRDA_ERROR_FE        ((uint32_t)0x00000004U)    /*!< frame error         */
N#define HAL_IRDA_ERROR_ORE       ((uint32_t)0x00000008U)    /*!< Overrun error       */
N#define HAL_IRDA_ERROR_DMA       ((uint32_t)0x00000010U)    /*!< DMA transfer error  */
N/**
N  * @}
N  */
N
N/** @defgroup IRDA_Parity IRDA Parity
N  * @{
N  */ 
N#define IRDA_PARITY_NONE                    ((uint32_t)0x0000U)
N#define IRDA_PARITY_EVEN                    ((uint32_t)USART_CR1_PCE)
N#define IRDA_PARITY_ODD                     ((uint32_t)(USART_CR1_PCE | USART_CR1_PS)) 
N/**
N  * @}
N  */ 
N
N
N/** @defgroup IRDA_Transfer_Mode IRDA Transfer Mode
N  * @{
N  */ 
N#define IRDA_MODE_RX                        ((uint32_t)USART_CR1_RE)
N#define IRDA_MODE_TX                        ((uint32_t)USART_CR1_TE)
N#define IRDA_MODE_TX_RX                     ((uint32_t)(USART_CR1_TE |USART_CR1_RE))
N/**
N  * @}
N  */
N
N/** @defgroup IRDA_Low_Power IRDA Low Power
N  * @{
N  */
N#define IRDA_POWERMODE_NORMAL                    ((uint32_t)0x0000U)
N#define IRDA_POWERMODE_LOWPOWER                  ((uint32_t)USART_CR3_IRLP)
N/**
N  * @}
N  */
N    
N /** @defgroup IRDA_State IRDA State
N  * @{
N  */ 
N#define IRDA_STATE_DISABLE                  ((uint32_t)0x0000U)
N#define IRDA_STATE_ENABLE                   ((uint32_t)USART_CR1_UE)
N/**
N  * @}
N  */
N
N /** @defgroup IRDA_Mode IRDA Mode
N  * @{
N  */ 
N#define IRDA_MODE_DISABLE                  ((uint32_t)0x0000U)
N#define IRDA_MODE_ENABLE                   ((uint32_t)USART_CR3_IREN)
N/**
N  * @}
N  */
N
N/** @defgroup IRDA_One_Bit IRDA One Bit
N  * @{
N  */
N#define IRDA_ONE_BIT_SAMPLE_DISABLE          ((uint32_t)0x00000000U)
N#define IRDA_ONE_BIT_SAMPLE_ENABLE           ((uint32_t)USART_CR3_ONEBIT)
N/**
N  * @}
N  */  
N  
N/** @defgroup IRDA_DMA_Tx IRDA DMA Tx
N  * @{
N  */
N#define IRDA_DMA_TX_DISABLE          ((uint32_t)0x00000000U)
N#define IRDA_DMA_TX_ENABLE           ((uint32_t)USART_CR3_DMAT)
N/**
N  * @}
N  */  
N  
N/** @defgroup IRDA_DMA_Rx IRDA DMA Rx
N  * @{
N  */
N#define IRDA_DMA_RX_DISABLE           ((uint32_t)0x0000U)
N#define IRDA_DMA_RX_ENABLE            ((uint32_t)USART_CR3_DMAR)
N/**
N  * @}
N  */
N  
N/** @defgroup IRDA_Flags IRDA Flags
N  *        Elements values convention: 0xXXXX
N  *           - 0xXXXX  : Flag mask in the ISR register
N  * @{
N  */
N#define IRDA_FLAG_REACK                     ((uint32_t)0x00400000U)
N#define IRDA_FLAG_TEACK                     ((uint32_t)0x00200000U)  
N#define IRDA_FLAG_BUSY                      ((uint32_t)0x00010000U)
N#define IRDA_FLAG_ABRF                      ((uint32_t)0x00008000U)  
N#define IRDA_FLAG_ABRE                      ((uint32_t)0x00004000U)
N#define IRDA_FLAG_TXE                       ((uint32_t)0x00000080U)
N#define IRDA_FLAG_TC                        ((uint32_t)0x00000040U)
N#define IRDA_FLAG_RXNE                      ((uint32_t)0x00000020U)
N#define IRDA_FLAG_ORE                       ((uint32_t)0x00000008U)
N#define IRDA_FLAG_NE                        ((uint32_t)0x00000004U)
N#define IRDA_FLAG_FE                        ((uint32_t)0x00000002U)
N#define IRDA_FLAG_PE                        ((uint32_t)0x00000001U)
N/**
N  * @}
N  */ 
N
N/** @defgroup IRDA_Interrupt_definition IRDA Interrupt definition
N  *        Elements values convention: 0000ZZZZ0XXYYYYYb
N  *           - YYYYY  : Interrupt source position in the XX register (5bits)
N  *           - XX  : Interrupt source register (2bits)
N  *                 - 01: CR1 register
N  *                 - 10: CR2 register
N  *                 - 11: CR3 register
N  *           - ZZZZ  : Flag position in the ISR register(4bits)
N  * @{   
N  */  
N#define IRDA_IT_PE                          ((uint16_t)0x0028U)
N#define IRDA_IT_TXE                         ((uint16_t)0x0727U)
N#define IRDA_IT_TC                          ((uint16_t)0x0626U)
N#define IRDA_IT_RXNE                        ((uint16_t)0x0525U)
N#define IRDA_IT_IDLE                        ((uint16_t)0x0424U)
N
N
N                                
N/**       Elements values convention: 000000000XXYYYYYb
N  *           - YYYYY  : Interrupt source position in the XX register (5bits)
N  *           - XX  : Interrupt source register (2bits)
N  *                 - 01: CR1 register
N  *                 - 10: CR2 register
N  *                 - 11: CR3 register
N  */
N#define IRDA_IT_ERR                         ((uint16_t)0x0060U)
N
N/**       Elements values convention: 0000ZZZZ00000000b
N  *           - ZZZZ  : Flag position in the ISR register(4bits)
N  */
N#define IRDA_IT_ORE                         ((uint16_t)0x0300U)
N#define IRDA_IT_NE                          ((uint16_t)0x0200U)
N#define IRDA_IT_FE                          ((uint16_t)0x0100U)
N/**
N  * @}
N  */
N  
N/** @defgroup IRDA_IT_CLEAR_Flags IRDA IT CLEAR Flags
N  * @{
N  */
N#define IRDA_CLEAR_PEF                       USART_ICR_PECF            /*!< Parity Error Clear Flag */          
N#define IRDA_CLEAR_FEF                       USART_ICR_FECF            /*!< Framing Error Clear Flag */         
N#define IRDA_CLEAR_NEF                       USART_ICR_NCF             /*!< Noise detected Clear Flag */        
N#define IRDA_CLEAR_OREF                      USART_ICR_ORECF           /*!< OverRun Error Clear Flag */         
N#define IRDA_CLEAR_TCF                       USART_ICR_TCCF            /*!< Transmission Complete Clear Flag */ 
N/**
N  * @}
N  */ 
N
N
N
N/** @defgroup IRDA_Request_Parameters IRDA Request Parameters
N  * @{
N  */
N#define IRDA_AUTOBAUD_REQUEST            ((uint16_t)USART_RQR_ABRRQ)        /*!< Auto-Baud Rate Request */     
N#define IRDA_RXDATA_FLUSH_REQUEST        ((uint16_t)USART_RQR_RXFRQ)        /*!< Receive Data flush Request */ 
N#define IRDA_TXDATA_FLUSH_REQUEST        ((uint16_t)USART_RQR_TXFRQ)        /*!< Transmit data flush Request */
N/**
N  * @}
N  */
N  
N/**
N * @}
N */
N
N  
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup IRDA_Exported_Macros IRDA Exported Macros
N  * @{
N  */
N
N/** @brief Reset IRDA handle state
N  * @param  __HANDLE__: specifies the IRDA Handle.
N  *         The Handle Instance which can be USART1 or USART2.
N  * @retval None
N  */
N#define __HAL_IRDA_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_IRDA_STATE_RESET)
N
N/** @brief  Check whether the specified IRDA flag is set or not.
N  * @param  __HANDLE__: specifies the IRDA Handle.
N  *         The Handle Instance which can be USART1 or USART2.
N  *         UART peripheral
N  * @param  __FLAG__: specifies the flag to check.
N  *        This parameter can be one of the following values:
N  *            @arg IRDA_FLAG_REACK: Receive enable acknowledge flag
N  *            @arg IRDA_FLAG_TEACK: Transmit enable acknowledge flag
N  *            @arg IRDA_FLAG_BUSY:  Busy flag
N  *            @arg IRDA_FLAG_ABRF:  Auto Baud rate detection flag
N  *            @arg IRDA_FLAG_ABRE:  Auto Baud rate detection error flag
N  *            @arg IRDA_FLAG_TXE:   Transmit data register empty flag
N  *            @arg IRDA_FLAG_TC:    Transmission Complete flag
N  *            @arg IRDA_FLAG_RXNE:  Receive data register not empty flag
N  *            @arg IRDA_FLAG_IDLE:  Idle Line detection flag
N  *            @arg IRDA_FLAG_ORE:   OverRun Error flag
N  *            @arg IRDA_FLAG_NE:    Noise Error flag
N  *            @arg IRDA_FLAG_FE:    Framing Error flag
N  *            @arg IRDA_FLAG_PE:    Parity Error flag
N  * @retval The new state of __FLAG__ (TRUE or FALSE).
N  */
N#define __HAL_IRDA_GET_FLAG(__HANDLE__, __FLAG__) (((__HANDLE__)->Instance->ISR & (__FLAG__)) == (__FLAG__))   
N
N/** @brief  Enable the specified IRDA interrupt.
N  * @param  __HANDLE__: specifies the IRDA Handle.
N  *         The Handle Instance which can be USART1 or USART2.
N  *         UART peripheral
N  * @param  __INTERRUPT__: specifies the IRDA interrupt source to enable.
N  *          This parameter can be one of the following values:
N  *            @arg IRDA_IT_TXE:  Transmit Data Register empty interrupt
N  *            @arg IRDA_IT_TC:   Transmission complete interrupt
N  *            @arg IRDA_IT_RXNE: Receive Data register not empty interrupt
N  *            @arg IRDA_IT_IDLE: Idle line detection interrupt
N  *            @arg IRDA_IT_PE:   Parity Error interrupt
N  *            @arg IRDA_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
N  * @retval None
N  */
N#define __HAL_IRDA_ENABLE_IT(__HANDLE__, __INTERRUPT__) (((((uint8_t)(__INTERRUPT__)) >> 5) == 1)? ((__HANDLE__)->Instance->CR1 |= (1 << ((__INTERRUPT__) & IRDA_IT_MASK))): \
N                                                          ((((uint8_t)(__INTERRUPT__)) >> 5) == 2)? ((__HANDLE__)->Instance->CR2 |= (1 << ((__INTERRUPT__) & IRDA_IT_MASK))): \
N                                                          ((__HANDLE__)->Instance->CR3 |= (1 << ((__INTERRUPT__) & IRDA_IT_MASK))))
X#define __HAL_IRDA_ENABLE_IT(__HANDLE__, __INTERRUPT__) (((((uint8_t)(__INTERRUPT__)) >> 5) == 1)? ((__HANDLE__)->Instance->CR1 |= (1 << ((__INTERRUPT__) & IRDA_IT_MASK))):                                                           ((((uint8_t)(__INTERRUPT__)) >> 5) == 2)? ((__HANDLE__)->Instance->CR2 |= (1 << ((__INTERRUPT__) & IRDA_IT_MASK))):                                                           ((__HANDLE__)->Instance->CR3 |= (1 << ((__INTERRUPT__) & IRDA_IT_MASK))))
N
N/** @brief  Disable the specified IRDA interrupt.
N  * @param  __HANDLE__: specifies the IRDA Handle.
N  *         The Handle Instance which can be USART1 or USART2.
N  * @param  __INTERRUPT__: specifies the IRDA interrupt source to disable.
N  *          This parameter can be one of the following values:
N  *            @arg IRDA_IT_TXE:  Transmit Data Register empty interrupt
N  *            @arg IRDA_IT_TC:   Transmission complete interrupt
N  *            @arg IRDA_IT_RXNE: Receive Data register not empty interrupt
N  *            @arg IRDA_IT_IDLE: Idle line detection interrupt
N  *            @arg IRDA_IT_PE:   Parity Error interrupt
N  *            @arg IRDA_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
N  * @retval None
N  */
N#define __HAL_IRDA_DISABLE_IT(__HANDLE__, __INTERRUPT__)  (((((uint8_t)(__INTERRUPT__)) >> 5) == 1)? ((__HANDLE__)->Instance->CR1 &= ~ ((uint32_t)1 << ((__INTERRUPT__) & IRDA_IT_MASK))): \
N                                                           ((((uint8_t)(__INTERRUPT__)) >> 5) == 2)? ((__HANDLE__)->Instance->CR2 &= ~ ((uint32_t)1 << ((__INTERRUPT__) & IRDA_IT_MASK))): \
N                                                           ((__HANDLE__)->Instance->CR3 &= ~ ((uint32_t)1 << ((__INTERRUPT__) & IRDA_IT_MASK))))
X#define __HAL_IRDA_DISABLE_IT(__HANDLE__, __INTERRUPT__)  (((((uint8_t)(__INTERRUPT__)) >> 5) == 1)? ((__HANDLE__)->Instance->CR1 &= ~ ((uint32_t)1 << ((__INTERRUPT__) & IRDA_IT_MASK))):                                                            ((((uint8_t)(__INTERRUPT__)) >> 5) == 2)? ((__HANDLE__)->Instance->CR2 &= ~ ((uint32_t)1 << ((__INTERRUPT__) & IRDA_IT_MASK))):                                                            ((__HANDLE__)->Instance->CR3 &= ~ ((uint32_t)1 << ((__INTERRUPT__) & IRDA_IT_MASK))))
N
N/** @brief  Check whether the specified IRDA interrupt has occurred or not.
N  * @param  __HANDLE__: specifies the IRDA Handle.
N  *         The Handle Instance which can be USART1 or USART2.
N  * @param  __IT__: specifies the IRDA interrupt source to check.
N  *          This parameter can be one of the following values:
N  *            @arg IRDA_IT_TXE: Transmit Data Register empty interrupt
N  *            @arg IRDA_IT_TC:  Transmission complete interrupt
N  *            @arg IRDA_IT_RXNE: Receive Data register not empty interrupt
N  *            @arg IRDA_IT_IDLE: Idle line detection interrupt
N  *            @arg IRDA_IT_ORE: OverRun Error interrupt
N  *            @arg IRDA_IT_NE: Noise Error interrupt
N  *            @arg IRDA_IT_FE: Framing Error interrupt
N  *            @arg IRDA_IT_PE: Parity Error interrupt  
N  * @retval The new state of __IT__ (TRUE or FALSE).
N  */
N#define __HAL_IRDA_GET_IT(__HANDLE__, __IT__) ((__HANDLE__)->Instance->ISR & ((uint32_t)1 << ((__IT__)>> 0x08))) 
N
N/** @brief  Check whether the specified IRDA interrupt source is enabled.
N  * @param  __HANDLE__: specifies the IRDA Handle.
N  *         The Handle Instance which can be USART1 or USART2.
N  * @param  __IT__: specifies the IRDA interrupt source to check.
N  *          This parameter can be one of the following values:
N  *            @arg IRDA_IT_TXE: Transmit Data Register empty interrupt
N  *            @arg IRDA_IT_TC:  Transmission complete interrupt
N  *            @arg IRDA_IT_RXNE: Receive Data register not empty interrupt
N  *            @arg IRDA_IT_IDLE: Idle line detection interrupt
N  *            @arg IRDA_IT_ORE: OverRun Error interrupt
N  *            @arg IRDA_IT_NE: Noise Error interrupt
N  *            @arg IRDA_IT_FE: Framing Error interrupt
N  *            @arg IRDA_IT_PE: Parity Error interrupt  
N  * @retval The new state of __IT__ (TRUE or FALSE).
N  */
N#define __HAL_IRDA_GET_IT_SOURCE(__HANDLE__, __IT__) ((((((uint8_t)(__IT__)) >> 5) == 1)? (__HANDLE__)->Instance->CR1:(((((uint8_t)(__IT__)) >> 5) == 2)? \
N                                                          (__HANDLE__)->Instance->CR2 : (__HANDLE__)->Instance->CR3)) & ((uint32_t)1 << (((uint16_t)(__IT__)) & IRDA_IT_MASK)))
X#define __HAL_IRDA_GET_IT_SOURCE(__HANDLE__, __IT__) ((((((uint8_t)(__IT__)) >> 5) == 1)? (__HANDLE__)->Instance->CR1:(((((uint8_t)(__IT__)) >> 5) == 2)?                                                           (__HANDLE__)->Instance->CR2 : (__HANDLE__)->Instance->CR3)) & ((uint32_t)1 << (((uint16_t)(__IT__)) & IRDA_IT_MASK)))
N
N/** @brief  Clear the specified IRDA ISR flag, in setting the proper ICR register flag.
N  * @param  __HANDLE__: specifies the IRDA Handle.
N  *         The Handle Instance which can be USART1 or USART2.
N  * @param  __IT_CLEAR__: specifies the interrupt clear register flag that needs to be set
N  *                       to clear the corresponding interrupt
N  *          This parameter can be one of the following values:
N  *            @arg IRDA_CLEAR_PEF: Parity Error Clear Flag
N  *            @arg IRDA_CLEAR_FEF: Framing Error Clear Flag
N  *            @arg IRDA_CLEAR_NEF: Noise detected Clear Flag
N  *            @arg IRDA_CLEAR_OREF: OverRun Error Clear Flag
N  *            @arg IRDA_CLEAR_TCF: Transmission Complete Clear Flag 
N  * @retval None
N  */
N#define __HAL_IRDA_CLEAR_IT(__HANDLE__, __IT_CLEAR__) ((__HANDLE__)->Instance->ICR |= (uint32_t)(__IT_CLEAR__))
N
N/** @brief  Set a specific IRDA request flag.
N  * @param  __HANDLE__: specifies the IRDA Handle.
N  *         The Handle Instance which can be USART1 or USART2.
N  * @param  __REQ__: specifies the request flag to set
N  *          This parameter can be one of the following values:
N  *            @arg IRDA_AUTOBAUD_REQUEST: Auto-Baud Rate Request     
N  *            @arg IRDA_RXDATA_FLUSH_REQUEST: Receive Data flush Request 
N  *            @arg IRDA_TXDATA_FLUSH_REQUEST: Transmit data flush Request 
N  *
N  * @retval None
N  */
N#define __HAL_IRDA_SEND_REQ(__HANDLE__, __REQ__) ((__HANDLE__)->Instance->RQR |= (uint16_t)(__REQ__)) 
N
N/** @brief  Enable UART/USART associated to IRDA Handle
N  * @param  __HANDLE__: specifies the IRDA Handle.
N  *         The Handle Instance which can be USART1 or USART2.
N  * @retval None
N  */
N#define __HAL_IRDA_ENABLE(__HANDLE__)                   ((__HANDLE__)->Instance->CR1 |=  USART_CR1_UE)
N
N/** @brief  Disable UART/USART associated to IRDA Handle
N  * @param  __HANDLE__: specifies the IRDA Handle.
N  *         The Handle Instance which can be USART1 or USART2.
N  * @retval None
N  */
N#define __HAL_IRDA_DISABLE(__HANDLE__)                  ((__HANDLE__)->Instance->CR1 &=  ~USART_CR1_UE)
N
N/**
N  * @}
N  */
N
N/* Include IRDA HAL Extension module */
N#include "stm32f7xx_hal_irda_ex.h"  
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_irda_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_irda_ex.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of IRDA HAL Extension module.
N  ******************************************************************************
N  * @attention
N  *                               
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************  
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_IRDA_EX_H
N#define __STM32F7xx_HAL_IRDA_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup IRDAEx
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup IRDAEx_Extended_Exported_Constants IRDAEx Extended Exported Constants
N  * @{
N  */
N  
N/** @defgroup IRDAEx_Word_Length IRDAEx Word Length
N  * @{
N  */
N#define IRDA_WORDLENGTH_7B                  ((uint32_t)USART_CR1_M_1)
N#define IRDA_WORDLENGTH_8B                  ((uint32_t)0x00000000U)
N#define IRDA_WORDLENGTH_9B                  ((uint32_t)USART_CR1_M_0)
N/**
N  * @}
N  */
N  
N  
N/**
N  * @}
N  */  
N  
N/* Exported macro ------------------------------------------------------------*/
N
N/* Private macros ------------------------------------------------------------*/
N
N/** @defgroup IRDAEx_Private_Macros IRDAEx Private Macros
N  * @{
N  */
N/** @brief  Reports the IRDA clock source.
N  * @param  __HANDLE__: specifies the IRDA Handle
N  * @param  __CLOCKSOURCE__ : output variable
N  * @retval IRDA clocking source, written in __CLOCKSOURCE__.
N  */
N#define IRDA_GETCLOCKSOURCE(__HANDLE__,__CLOCKSOURCE__)       \
N  do {                                                        \
N    if((__HANDLE__)->Instance == USART1)                      \
N    {                                                         \
N       switch(__HAL_RCC_GET_USART1_SOURCE())                  \
N       {                                                      \
N        case RCC_USART1CLKSOURCE_PCLK2:                       \
N          (__CLOCKSOURCE__) = IRDA_CLOCKSOURCE_PCLK2;         \
N          break;                                              \
N        case RCC_USART1CLKSOURCE_HSI:                         \
N          (__CLOCKSOURCE__) = IRDA_CLOCKSOURCE_HSI;           \
N          break;                                              \
N        case RCC_USART1CLKSOURCE_SYSCLK:                      \
N          (__CLOCKSOURCE__) = IRDA_CLOCKSOURCE_SYSCLK;        \
N          break;                                              \
N        case RCC_USART1CLKSOURCE_LSE:                         \
N          (__CLOCKSOURCE__) = IRDA_CLOCKSOURCE_LSE;           \
N          break;                                              \
N        default:                                              \
N          break;                                              \
N       }                                                      \
N    }                                                         \
N    else if((__HANDLE__)->Instance == USART2)                 \
N    {                                                         \
N       switch(__HAL_RCC_GET_USART2_SOURCE())                  \
N       {                                                      \
N        case RCC_USART2CLKSOURCE_PCLK1:                       \
N          (__CLOCKSOURCE__) = IRDA_CLOCKSOURCE_PCLK1;         \
N          break;                                              \
N        case RCC_USART2CLKSOURCE_HSI:                         \
N          (__CLOCKSOURCE__) = IRDA_CLOCKSOURCE_HSI;           \
N          break;                                              \
N        case RCC_USART2CLKSOURCE_SYSCLK:                      \
N          (__CLOCKSOURCE__) = IRDA_CLOCKSOURCE_SYSCLK;        \
N          break;                                              \
N        case RCC_USART2CLKSOURCE_LSE:                         \
N          (__CLOCKSOURCE__) = IRDA_CLOCKSOURCE_LSE;           \
N          break;                                              \
N        default:                                              \
N          break;                                              \
N       }                                                      \
N    }                                                         \
N    else if((__HANDLE__)->Instance == USART3)                 \
N    {                                                         \
N       switch(__HAL_RCC_GET_USART3_SOURCE())                  \
N       {                                                      \
N        case RCC_USART3CLKSOURCE_PCLK1:                       \
N          (__CLOCKSOURCE__) = IRDA_CLOCKSOURCE_PCLK1;         \
N          break;                                              \
N        case RCC_USART3CLKSOURCE_HSI:                         \
N          (__CLOCKSOURCE__) = IRDA_CLOCKSOURCE_HSI;           \
N          break;                                              \
N        case RCC_USART3CLKSOURCE_SYSCLK:                      \
N          (__CLOCKSOURCE__) = IRDA_CLOCKSOURCE_SYSCLK;        \
N          break;                                              \
N        case RCC_USART3CLKSOURCE_LSE:                         \
N          (__CLOCKSOURCE__) = IRDA_CLOCKSOURCE_LSE;           \
N          break;                                              \
N        default:                                              \
N          break;                                              \
N       }                                                      \
N    }                                                         \
N    else if((__HANDLE__)->Instance == USART6)                 \
N    {                                                         \
N       switch(__HAL_RCC_GET_USART6_SOURCE())                  \
N       {                                                      \
N        case RCC_USART6CLKSOURCE_PCLK2:                       \
N          (__CLOCKSOURCE__) = IRDA_CLOCKSOURCE_PCLK2;         \
N          break;                                              \
N        case RCC_USART6CLKSOURCE_HSI:                         \
N          (__CLOCKSOURCE__) = IRDA_CLOCKSOURCE_HSI;           \
N          break;                                              \
N        case RCC_USART6CLKSOURCE_SYSCLK:                      \
N          (__CLOCKSOURCE__) = IRDA_CLOCKSOURCE_SYSCLK;        \
N          break;                                              \
N        case RCC_USART6CLKSOURCE_LSE:                         \
N          (__CLOCKSOURCE__) = IRDA_CLOCKSOURCE_LSE;           \
N          break;                                              \
N        default:                                              \
N          break;                                              \
N       }                                                      \
N    }                                                         \
N	} while(0)
X#define IRDA_GETCLOCKSOURCE(__HANDLE__,__CLOCKSOURCE__)         do {                                                            if((__HANDLE__)->Instance == USART1)                          {                                                                switch(__HAL_RCC_GET_USART1_SOURCE())                         {                                                              case RCC_USART1CLKSOURCE_PCLK2:                                 (__CLOCKSOURCE__) = IRDA_CLOCKSOURCE_PCLK2;                   break;                                                      case RCC_USART1CLKSOURCE_HSI:                                   (__CLOCKSOURCE__) = IRDA_CLOCKSOURCE_HSI;                     break;                                                      case RCC_USART1CLKSOURCE_SYSCLK:                                (__CLOCKSOURCE__) = IRDA_CLOCKSOURCE_SYSCLK;                  break;                                                      case RCC_USART1CLKSOURCE_LSE:                                   (__CLOCKSOURCE__) = IRDA_CLOCKSOURCE_LSE;                     break;                                                      default:                                                        break;                                                     }                                                          }                                                             else if((__HANDLE__)->Instance == USART2)                     {                                                                switch(__HAL_RCC_GET_USART2_SOURCE())                         {                                                              case RCC_USART2CLKSOURCE_PCLK1:                                 (__CLOCKSOURCE__) = IRDA_CLOCKSOURCE_PCLK1;                   break;                                                      case RCC_USART2CLKSOURCE_HSI:                                   (__CLOCKSOURCE__) = IRDA_CLOCKSOURCE_HSI;                     break;                                                      case RCC_USART2CLKSOURCE_SYSCLK:                                (__CLOCKSOURCE__) = IRDA_CLOCKSOURCE_SYSCLK;                  break;                                                      case RCC_USART2CLKSOURCE_LSE:                                   (__CLOCKSOURCE__) = IRDA_CLOCKSOURCE_LSE;                     break;                                                      default:                                                        break;                                                     }                                                          }                                                             else if((__HANDLE__)->Instance == USART3)                     {                                                                switch(__HAL_RCC_GET_USART3_SOURCE())                         {                                                              case RCC_USART3CLKSOURCE_PCLK1:                                 (__CLOCKSOURCE__) = IRDA_CLOCKSOURCE_PCLK1;                   break;                                                      case RCC_USART3CLKSOURCE_HSI:                                   (__CLOCKSOURCE__) = IRDA_CLOCKSOURCE_HSI;                     break;                                                      case RCC_USART3CLKSOURCE_SYSCLK:                                (__CLOCKSOURCE__) = IRDA_CLOCKSOURCE_SYSCLK;                  break;                                                      case RCC_USART3CLKSOURCE_LSE:                                   (__CLOCKSOURCE__) = IRDA_CLOCKSOURCE_LSE;                     break;                                                      default:                                                        break;                                                     }                                                          }                                                             else if((__HANDLE__)->Instance == USART6)                     {                                                                switch(__HAL_RCC_GET_USART6_SOURCE())                         {                                                              case RCC_USART6CLKSOURCE_PCLK2:                                 (__CLOCKSOURCE__) = IRDA_CLOCKSOURCE_PCLK2;                   break;                                                      case RCC_USART6CLKSOURCE_HSI:                                   (__CLOCKSOURCE__) = IRDA_CLOCKSOURCE_HSI;                     break;                                                      case RCC_USART6CLKSOURCE_SYSCLK:                                (__CLOCKSOURCE__) = IRDA_CLOCKSOURCE_SYSCLK;                  break;                                                      case RCC_USART6CLKSOURCE_LSE:                                   (__CLOCKSOURCE__) = IRDA_CLOCKSOURCE_LSE;                     break;                                                      default:                                                        break;                                                     }                                                          }                                                         	} while(0)
N
N/** @brief  Reports the mask to apply to retrieve the received data
N  *         according to the word length and to the parity bits activation.
N  * @param  __HANDLE__: specifies the IRDA Handle
N  * @retval mask to apply to USART RDR register value.
N  */    
N#define IRDA_MASK_COMPUTATION(__HANDLE__)                       \
N  do {                                                                \
N  if ((__HANDLE__)->Init.WordLength == IRDA_WORDLENGTH_9B)            \
N  {                                                                   \
N     if ((__HANDLE__)->Init.Parity == IRDA_PARITY_NONE)               \
N     {                                                                \
N        (__HANDLE__)->Mask = 0x01FF ;                                 \
N     }                                                                \
N     else                                                             \
N     {                                                                \
N        (__HANDLE__)->Mask = 0x00FF ;                                 \
N     }                                                                \
N  }                                                                   \
N  else if ((__HANDLE__)->Init.WordLength == IRDA_WORDLENGTH_8B)       \
N  {                                                                   \
N     if ((__HANDLE__)->Init.Parity == IRDA_PARITY_NONE)               \
N     {                                                                \
N        (__HANDLE__)->Mask = 0x00FF ;                                 \
N     }                                                                \
N     else                                                             \
N     {                                                                \
N        (__HANDLE__)->Mask = 0x007F ;                                 \
N     }                                                                \
N  }                                                                   \
N  else if ((__HANDLE__)->Init.WordLength == IRDA_WORDLENGTH_7B)       \
N  {                                                                   \
N     if ((__HANDLE__)->Init.Parity == IRDA_PARITY_NONE)               \
N     {                                                                \
N        (__HANDLE__)->Mask = 0x007F ;                                 \
N     }                                                                \
N     else                                                             \
N     {                                                                \
N        (__HANDLE__)->Mask = 0x003F ;                                 \
N     }                                                                \
N  }                                                                   \
N} while(0)
X#define IRDA_MASK_COMPUTATION(__HANDLE__)                         do {                                                                  if ((__HANDLE__)->Init.WordLength == IRDA_WORDLENGTH_9B)              {                                                                        if ((__HANDLE__)->Init.Parity == IRDA_PARITY_NONE)                    {                                                                        (__HANDLE__)->Mask = 0x01FF ;                                      }                                                                     else                                                                  {                                                                        (__HANDLE__)->Mask = 0x00FF ;                                      }                                                                  }                                                                     else if ((__HANDLE__)->Init.WordLength == IRDA_WORDLENGTH_8B)         {                                                                        if ((__HANDLE__)->Init.Parity == IRDA_PARITY_NONE)                    {                                                                        (__HANDLE__)->Mask = 0x00FF ;                                      }                                                                     else                                                                  {                                                                        (__HANDLE__)->Mask = 0x007F ;                                      }                                                                  }                                                                     else if ((__HANDLE__)->Init.WordLength == IRDA_WORDLENGTH_7B)         {                                                                        if ((__HANDLE__)->Init.Parity == IRDA_PARITY_NONE)                    {                                                                        (__HANDLE__)->Mask = 0x007F ;                                      }                                                                     else                                                                  {                                                                        (__HANDLE__)->Mask = 0x003F ;                                      }                                                                  }                                                                   } while(0)
N
N#define IS_IRDA_WORD_LENGTH(LENGTH) (((LENGTH) == IRDA_WORDLENGTH_7B) || \
N                                     ((LENGTH) == IRDA_WORDLENGTH_8B) || \
N                                     ((LENGTH) == IRDA_WORDLENGTH_9B))
X#define IS_IRDA_WORD_LENGTH(LENGTH) (((LENGTH) == IRDA_WORDLENGTH_7B) ||                                      ((LENGTH) == IRDA_WORDLENGTH_8B) ||                                      ((LENGTH) == IRDA_WORDLENGTH_9B))
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_IRDA_EX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 545 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_irda.h" 2
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup IRDA_Exported_Functions IrDA Exported Functions
N  * @{
N  */
N
N/** @addtogroup IRDA_Exported_Functions_Group1 IrDA Initialization and de-initialization functions
N  * @{
N  */
N
N/* Initialization and de-initialization functions  ****************************/
NHAL_StatusTypeDef HAL_IRDA_Init(IRDA_HandleTypeDef *hirda);
NHAL_StatusTypeDef HAL_IRDA_DeInit(IRDA_HandleTypeDef *hirda);
Nvoid HAL_IRDA_MspInit(IRDA_HandleTypeDef *hirda);
Nvoid HAL_IRDA_MspDeInit(IRDA_HandleTypeDef *hirda);
N/**
N  * @}
N  */
N
N/** @addtogroup IRDA_Exported_Functions_Group2 IO operation functions
N  * @{
N  */
N
N/* IO operation functions *****************************************************/
NHAL_StatusTypeDef HAL_IRDA_Transmit(IRDA_HandleTypeDef *hirda, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_IRDA_Receive(IRDA_HandleTypeDef *hirda, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_IRDA_Transmit_IT(IRDA_HandleTypeDef *hirda, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_IRDA_Receive_IT(IRDA_HandleTypeDef *hirda, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_IRDA_Transmit_DMA(IRDA_HandleTypeDef *hirda, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_IRDA_Receive_DMA(IRDA_HandleTypeDef *hirda, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_IRDA_DMAPause(IRDA_HandleTypeDef *hirda);
NHAL_StatusTypeDef HAL_IRDA_DMAResume(IRDA_HandleTypeDef *hirda);
NHAL_StatusTypeDef HAL_IRDA_DMAStop(IRDA_HandleTypeDef *hirda);
Nvoid HAL_IRDA_IRQHandler(IRDA_HandleTypeDef *hirda);
Nvoid HAL_IRDA_TxCpltCallback(IRDA_HandleTypeDef *hirda);
Nvoid HAL_IRDA_RxCpltCallback(IRDA_HandleTypeDef *hirda);
Nvoid HAL_IRDA_TxHalfCpltCallback(IRDA_HandleTypeDef *hirda);
Nvoid HAL_IRDA_RxHalfCpltCallback(IRDA_HandleTypeDef *hirda);
Nvoid HAL_IRDA_ErrorCallback(IRDA_HandleTypeDef *hirda);
N/**
N * @}
N */
N
N/** @addtogroup IRDA_Exported_Functions_Group3 Peripheral Control functions
N * @{
N */
N/* Peripheral State methods  **************************************************/
NHAL_IRDA_StateTypeDef HAL_IRDA_GetState(IRDA_HandleTypeDef *hirda);
Nuint32_t HAL_IRDA_GetError(IRDA_HandleTypeDef *hirda);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup IRDA_Private_Constants IRDA Private Constants
N  * @{
N  */
N
N/** @defgroup IRDA_Interruption_Mask IRDA Interruption Mask
N  * @{
N  */ 
N#define IRDA_IT_MASK  ((uint16_t)0x001FU)
N/**
N  * @}
N  */
N/**
N  * @}
N  */
N
N/* Private macros --------------------------------------------------------*/
N/** @defgroup IRDA_Private_Macros   IRDA Private Macros
N  * @{
N  */
N
N/** @brief  Ensure that IRDA Baud rate is less or equal to maximum value
N  * @param  __BAUDRATE__: specifies the IRDA Baudrate set by the user.
N  * @retval True or False
N  */   
N#define IS_IRDA_BAUDRATE(__BAUDRATE__) ((__BAUDRATE__) < 115201)
N
N/** @brief  Ensure that IRDA prescaler value is strictly larger than 0
N  * @param  __PRESCALER__: specifies the IRDA prescaler value set by the user.
N  * @retval True or False
N  */  
N#define IS_IRDA_PRESCALER(__PRESCALER__) ((__PRESCALER__) > 0)
N
N#define IS_IRDA_PARITY(__PARITY__) (((__PARITY__) == IRDA_PARITY_NONE) || \
N                                    ((__PARITY__) == IRDA_PARITY_EVEN) || \
N                                    ((__PARITY__) == IRDA_PARITY_ODD))
X#define IS_IRDA_PARITY(__PARITY__) (((__PARITY__) == IRDA_PARITY_NONE) ||                                     ((__PARITY__) == IRDA_PARITY_EVEN) ||                                     ((__PARITY__) == IRDA_PARITY_ODD))
N								
N#define IS_IRDA_TX_RX_MODE(__MODE__) ((((__MODE__) & (~((uint32_t)(IRDA_MODE_TX_RX)))) == (uint32_t)0x00) && ((__MODE__) != (uint32_t)0x00U))
N
N#define IS_IRDA_POWERMODE(__MODE__) (((__MODE__) == IRDA_POWERMODE_LOWPOWER) || \
N                                     ((__MODE__) == IRDA_POWERMODE_NORMAL))
X#define IS_IRDA_POWERMODE(__MODE__) (((__MODE__) == IRDA_POWERMODE_LOWPOWER) ||                                      ((__MODE__) == IRDA_POWERMODE_NORMAL))
N									 
N#define IS_IRDA_STATE(__STATE__) (((__STATE__) == IRDA_STATE_DISABLE) || \
N                                  ((__STATE__) == IRDA_STATE_ENABLE))
X#define IS_IRDA_STATE(__STATE__) (((__STATE__) == IRDA_STATE_DISABLE) ||                                   ((__STATE__) == IRDA_STATE_ENABLE))
N								  
N#define IS_IRDA_MODE(__STATE__)  (((__STATE__) == IRDA_MODE_DISABLE) || \
N                                  ((__STATE__) == IRDA_MODE_ENABLE))
X#define IS_IRDA_MODE(__STATE__)  (((__STATE__) == IRDA_MODE_DISABLE) ||                                   ((__STATE__) == IRDA_MODE_ENABLE))
N								  
N#define IS_IRDA_ONE_BIT_SAMPLE(__ONEBIT__)     (((__ONEBIT__) == IRDA_ONE_BIT_SAMPLE_DISABLE) || \
N                                               ((__ONEBIT__) == IRDA_ONE_BIT_SAMPLE_ENABLE))
X#define IS_IRDA_ONE_BIT_SAMPLE(__ONEBIT__)     (((__ONEBIT__) == IRDA_ONE_BIT_SAMPLE_DISABLE) ||                                                ((__ONEBIT__) == IRDA_ONE_BIT_SAMPLE_ENABLE))
N
N#define IS_IRDA_DMA_TX(__DMATX__)     (((__DMATX__) == IRDA_DMA_TX_DISABLE) || \
N                                       ((__DMATX__) == IRDA_DMA_TX_ENABLE))		
X#define IS_IRDA_DMA_TX(__DMATX__)     (((__DMATX__) == IRDA_DMA_TX_DISABLE) ||                                        ((__DMATX__) == IRDA_DMA_TX_ENABLE))		
N
N#define IS_IRDA_DMA_RX(__DMARX__)     (((__DMARX__) == IRDA_DMA_RX_DISABLE) || \
N                                       ((__DMARX__) == IRDA_DMA_RX_ENABLE))
X#define IS_IRDA_DMA_RX(__DMARX__)     (((__DMARX__) == IRDA_DMA_RX_DISABLE) ||                                        ((__DMARX__) == IRDA_DMA_RX_ENABLE))
N
N#define IS_IRDA_REQUEST_PARAMETER(PARAM) (((PARAM) == IRDA_AUTOBAUD_REQUEST) || \
N                                          ((PARAM) == IRDA_SENDBREAK_REQUEST) || \
N                                          ((PARAM) == IRDA_MUTE_MODE_REQUEST) || \
N                                          ((PARAM) == IRDA_RXDATA_FLUSH_REQUEST) || \
N                                          ((PARAM) == IRDA_TXDATA_FLUSH_REQUEST))									   
X#define IS_IRDA_REQUEST_PARAMETER(PARAM) (((PARAM) == IRDA_AUTOBAUD_REQUEST) ||                                           ((PARAM) == IRDA_SENDBREAK_REQUEST) ||                                           ((PARAM) == IRDA_MUTE_MODE_REQUEST) ||                                           ((PARAM) == IRDA_RXDATA_FLUSH_REQUEST) ||                                           ((PARAM) == IRDA_TXDATA_FLUSH_REQUEST))									   
N/**
N * @}
N */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup IRDA_Private_Functions IRDA Private Functions
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_IRDA_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 387 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_IRDA_MODULE_ENABLED */
N
N#ifdef HAL_SMARTCARD_MODULE_ENABLED
N #include "stm32f7xx_hal_smartcard.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_smartcard.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_smartcard.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of SMARTCARD HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_SMARTCARD_H
N#define __STM32F7xx_HAL_SMARTCARD_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup SMARTCARD
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/ 
N/** @defgroup SMARTCARD_Exported_Types SMARTCARD Exported Types
N  * @{
N  */
N
N/** 
N  * @brief SMARTCARD Init Structure definition
N  */
Ntypedef struct
N{
N  uint32_t BaudRate;                  /*!< Configures the SmartCard communication baud rate.
N                                           The baud rate register is computed using the following formula:
N                                              Baud Rate Register = ((PCLKx) / ((hsc->Init.BaudRate))) */
N                                           
N  uint32_t WordLength;                /*!< Specifies the number of data bits transmitted or received in a frame.
N                                           This parameter @ref SMARTCARD_Word_Length can only be set to 9 (8 data + 1 parity bits). */
N
N  uint32_t StopBits;                  /*!< Specifies the number of stop bits @ref SMARTCARD_Stop_Bits. 
N                                           Only 1.5 stop bits are authorized in SmartCard mode. */
N
N  uint32_t Parity;                    /*!< Specifies the parity mode.
N                                           This parameter can be a value of @ref SMARTCARD_Parity
N                                           @note The parity is enabled by default (PCE is forced to 1).
N                                                 Since the WordLength is forced to 8 bits + parity, M is
N                                                 forced to 1 and the parity bit is the 9th bit. */
N 
N  uint32_t Mode;                      /*!< Specifies whether the Receive or Transmit mode is enabled or disabled.
N                                           This parameter can be a value of @ref SMARTCARD_Mode */
N
N  uint32_t CLKPolarity;               /*!< Specifies the steady state of the serial clock.
N                                           This parameter can be a value of @ref SMARTCARD_Clock_Polarity */
N
N  uint32_t CLKPhase;                  /*!< Specifies the clock transition on which the bit capture is made.
N                                           This parameter can be a value of @ref SMARTCARD_Clock_Phase */
N
N  uint32_t CLKLastBit;                /*!< Specifies whether the clock pulse corresponding to the last transmitted
N                                           data bit (MSB) has to be output on the SCLK pin in synchronous mode.
N                                           This parameter can be a value of @ref SMARTCARD_Last_Bit */
N                                             
N  uint32_t OneBitSampling;            /*!< Specifies  whether a single sample or three samples' majority vote is selected.
N                                           Selecting the single sample method increases the receiver tolerance to clock
N                                           deviations. This parameter can be a value of @ref SMARTCARD_OneBit_Sampling */
N
N  uint32_t  Prescaler;                 /*!< Specifies the SmartCard Prescaler */
N  
N  uint32_t  GuardTime;                 /*!< Specifies the SmartCard Guard Time */
N  
N  uint32_t NACKState;                  /*!< Specifies whether the SmartCard NACK transmission is enabled
N                                            in case of parity error.
N                                            This parameter can be a value of @ref SMARTCARD_NACK_State */ 
N                                           
N  uint32_t TimeOutEnable;              /*!< Specifies whether the receiver timeout is enabled. 
N                                            This parameter can be a value of @ref SMARTCARD_Timeout_Enable*/
N  
N  uint32_t TimeOutValue;               /*!< Specifies the receiver time out value in number of baud blocks: 
N                                            it is used to implement the Character Wait Time (CWT) and 
N                                            Block Wait Time (BWT). It is coded over 24 bits. */ 
N                                           
N  uint32_t BlockLength;                /*!< Specifies the SmartCard Block Length in T=1 Reception mode.
N                                            This parameter can be any value from 0x0 to 0xFF */ 
N                                           
N  uint32_t AutoRetryCount;              /*!< Specifies the SmartCard auto-retry count (number of retries in
N                                             receive and transmit mode). When set to 0, retransmission is 
N                                             disabled. Otherwise, its maximum value is 7 (before signalling
N                                             an error) */  
N
N}SMARTCARD_InitTypeDef;
N
N/** 
N  * @brief HAL SMARTCARD State structures definition
N  * @note  HAL SMARTCARD State value is a combination of 2 different substates: gState and RxState.
N  *        - gState contains SMARTCARD state information related to global Handle management 
N  *          and also information related to Tx operations.
N  *          gState value coding follow below described bitmap :
N  *          b7-b6  Error information 
N  *             00 : No Error
N  *             01 : (Not Used)
N  *             10 : Timeout
N  *             11 : Error
N  *          b5     IP initilisation status
N  *             0  : Reset (IP not initialized)
N  *             1  : Init done (IP not initialized. HAL SMARTCARD Init function already called)
N  *          b4-b3  (not used)
N  *             xx : Should be set to 00
N  *          b2     Intrinsic process state
N  *             0  : Ready
N  *             1  : Busy (IP busy with some configuration or internal operations)
N  *          b1     (not used)
N  *             x  : Should be set to 0
N  *          b0     Tx state
N  *             0  : Ready (no Tx operation ongoing)
N  *             1  : Busy (Tx operation ongoing)
N  *        - RxState contains information related to Rx operations.
N  *          RxState value coding follow below described bitmap :
N  *          b7-b6  (not used)
N  *             xx : Should be set to 00
N  *          b5     IP initilisation status
N  *             0  : Reset (IP not initialized)
N  *             1  : Init done (IP not initialized)
N  *          b4-b2  (not used)
N  *            xxx : Should be set to 000
N  *          b1     Rx state
N  *             0  : Ready (no Rx operation ongoing)
N  *             1  : Busy (Rx operation ongoing)
N  *          b0     (not used)
N  *             x  : Should be set to 0.
N  */
Ntypedef struct
N{
N  uint32_t AdvFeatureInit;            /*!< Specifies which advanced SMARTCARD features is initialized. Several
N                                           advanced features may be initialized at the same time. This parameter 
N                                           can be a value of @ref SMARTCARD_Advanced_Features_Initialization_Type */
N
N  uint32_t TxPinLevelInvert;          /*!< Specifies whether the TX pin active level is inverted.
N                                           This parameter can be a value of @ref SMARTCARD_Tx_Inv  */
N
N  uint32_t RxPinLevelInvert;          /*!< Specifies whether the RX pin active level is inverted.
N                                           This parameter can be a value of @ref SMARTCARD_Rx_Inv  */
N
N  uint32_t DataInvert;                /*!< Specifies whether data are inverted (positive/direct logic
N                                           vs negative/inverted logic).
N                                           This parameter can be a value of @ref SMARTCARD_Data_Inv */
N
N  uint32_t Swap;                      /*!< Specifies whether TX and RX pins are swapped.   
N                                           This parameter can be a value of @ref SMARTCARD_Rx_Tx_Swap */
N
N  uint32_t OverrunDisable;            /*!< Specifies whether the reception overrun detection is disabled.   
N                                           This parameter can be a value of @ref SMARTCARD_Overrun_Disable */
N
N  uint32_t DMADisableonRxError;       /*!< Specifies whether the DMA is disabled in case of reception error.     
N                                           This parameter can be a value of @ref SMARTCARD_DMA_Disable_on_Rx_Error */
N
N  uint32_t MSBFirst;                  /*!< Specifies whether MSB is sent first on UART line.      
N                                           This parameter can be a value of @ref SMARTCARD_MSB_First */
N}SMARTCARD_AdvFeatureInitTypeDef;
N
N/** 
N  * @brief HAL State structures definition  
N  */ 
Ntypedef enum
N{
N  HAL_SMARTCARD_STATE_RESET             = 0x00U,    /*!< Peripheral is not yet Initialized
N                                                        Value is allowed for gState and RxState */
N  HAL_SMARTCARD_STATE_READY             = 0x20U,    /*!< Peripheral Initialized and ready for use
N                                                        Value is allowed for gState and RxState */
N  HAL_SMARTCARD_STATE_BUSY              = 0x24U,    /*!< an internal process is ongoing
N                                                        Value is allowed for gState only */
N  HAL_SMARTCARD_STATE_BUSY_TX           = 0x21U,    /*!< Data Transmission process is ongoing
N                                                        Value is allowed for gState only */
N  HAL_SMARTCARD_STATE_BUSY_RX           = 0x22U,    /*!< Data Reception process is ongoing
N                                                        Value is allowed for RxState only */
N  HAL_SMARTCARD_STATE_BUSY_TX_RX        = 0x23U,    /*!< Data Transmission and Reception process is ongoing 
N                                                        Not to be used for neither gState nor RxState.
N                                                        Value is result of combination (Or) between gState and RxState values */
N  HAL_SMARTCARD_STATE_TIMEOUT           = 0xA0U,    /*!< Timeout state
N                                                        Value is allowed for gState only */
N  HAL_SMARTCARD_STATE_ERROR             = 0xE0U     /*!< Error
N                                                        Value is allowed for gState only */
N}HAL_SMARTCARD_StateTypeDef;
N
N
N/**
N  * @brief  SMARTCARD clock sources definition
N  */
Ntypedef enum
N{
N  SMARTCARD_CLOCKSOURCE_PCLK1      = 0x00U,    /*!< PCLK1 clock source  */
N  SMARTCARD_CLOCKSOURCE_PCLK2      = 0x01U,    /*!< PCLK2 clock source  */
N  SMARTCARD_CLOCKSOURCE_HSI        = 0x02U,    /*!< HSI clock source    */
N  SMARTCARD_CLOCKSOURCE_SYSCLK     = 0x04U,    /*!< SYSCLK clock source */
N  SMARTCARD_CLOCKSOURCE_LSE        = 0x08U     /*!< LSE clock source    */
N}SMARTCARD_ClockSourceTypeDef;
N
N/** 
N  * @brief  SMARTCARD handle Structure definition
N  */
Ntypedef struct
N{
N  USART_TypeDef                       *Instance;        /* USART registers base address                          */
N
N  SMARTCARD_InitTypeDef               Init;             /* SmartCard communication parameters                    */
N
N  SMARTCARD_AdvFeatureInitTypeDef     AdvancedInit;     /* SmartCard advanced features initialization parameters */
N
N  uint8_t                             *pTxBuffPtr;      /* Pointer to SmartCard Tx transfer Buffer            */
N
N  uint16_t                            TxXferSize;       /* SmartCard Tx Transfer size                         */
N
N  uint16_t                            TxXferCount;      /* SmartCard Tx Transfer Counter                      */
N
N  uint8_t                             *pRxBuffPtr;      /* Pointer to SmartCard Rx transfer Buffer        */
N
N  uint16_t                            RxXferSize;       /* SmartCard Rx Transfer size                     */
N
N  uint16_t                            RxXferCount;      /* SmartCard Rx Transfer Counter                  */
N
N  DMA_HandleTypeDef                   *hdmatx;          /* SmartCard Tx DMA Handle parameters             */
N
N  DMA_HandleTypeDef                   *hdmarx;          /* SmartCard Rx DMA Handle parameters             */
N
N  HAL_LockTypeDef                     Lock;             /* Locking object                                 */
N
N  __IO HAL_SMARTCARD_StateTypeDef    gState;      /*!< UART state information related to global Handle management 
X  volatile HAL_SMARTCARD_StateTypeDef    gState;      
N                                                  and also related to Tx operations.
N                                                  This parameter can be a value of @ref HAL_UART_StateTypeDef */
N
N  __IO HAL_SMARTCARD_StateTypeDef    RxState;     /*!< UART state information related to Rx operations.
X  volatile HAL_SMARTCARD_StateTypeDef    RxState;     
N                                                  This parameter can be a value of @ref HAL_UART_StateTypeDef */
N
N  __IO uint32_t                       ErrorCode;        /* SmartCard Error code                           */
X  volatile uint32_t                       ErrorCode;         
N
N}SMARTCARD_HandleTypeDef;
N
N/**
N  * @}
N  */
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup SMARTCARD_Exported_Constants  SMARTCARD Exported constants
N  * @{
N  */
N/** @defgroup SMARTCARD_Error_Code SMARTCARD Error Code
N  * @brief    SMARTCARD Error Code 
N  * @{
N  */ 
N#define HAL_SMARTCARD_ERROR_NONE      ((uint32_t)0x00U)    /*!< No error                */
N#define HAL_SMARTCARD_ERROR_PE        ((uint32_t)0x01U)    /*!< Parity error            */
N#define HAL_SMARTCARD_ERROR_NE        ((uint32_t)0x02U)    /*!< Noise error             */
N#define HAL_SMARTCARD_ERROR_FE        ((uint32_t)0x04U)    /*!< frame error             */
N#define HAL_SMARTCARD_ERROR_ORE       ((uint32_t)0x08U)    /*!< Overrun error           */
N#define HAL_SMARTCARD_ERROR_DMA       ((uint32_t)0x10U)    /*!< DMA transfer error      */
N#define HAL_SMARTCARD_ERROR_RTO       ((uint32_t)0x20U)    /*!< Receiver TimeOut error  */
N/**
N  * @}
N  */
N
N/** @defgroup SMARTCARD_Word_Length SMARTCARD Word Length
N  * @{
N  */
N#define SMARTCARD_WORDLENGTH_9B                  ((uint32_t)USART_CR1_M_0)
N/**
N  * @}
N  */
N
N/** @defgroup SMARTCARD_Stop_Bits SMARTCARD Number of Stop Bits
N  * @{
N  */
N#define SMARTCARD_STOPBITS_1_5                   ((uint32_t)(USART_CR2_STOP))
N/**
N  * @}
N  */
N
N/** @defgroup SMARTCARD_Parity SMARTCARD Parity
N  * @{
N  */
N#define SMARTCARD_PARITY_EVEN                    ((uint32_t)USART_CR1_PCE)
N#define SMARTCARD_PARITY_ODD                     ((uint32_t)(USART_CR1_PCE | USART_CR1_PS)) 
N/**
N  * @}
N  */
N
N/** @defgroup SMARTCARD_Mode SMARTCARD Mode
N  * @{
N  */
N#define SMARTCARD_MODE_RX                        ((uint32_t)USART_CR1_RE)
N#define SMARTCARD_MODE_TX                        ((uint32_t)USART_CR1_TE)
N#define SMARTCARD_MODE_TX_RX                     ((uint32_t)(USART_CR1_TE |USART_CR1_RE))
N/**
N  * @}
N  */
N
N/** @defgroup SMARTCARD_Clock_Polarity SMARTCARD Clock Polarity
N  * @{
N  */
N#define SMARTCARD_POLARITY_LOW                   ((uint32_t)0x0000U)
N#define SMARTCARD_POLARITY_HIGH                  ((uint32_t)USART_CR2_CPOL)
N/**
N  * @}
N  */ 
N
N/** @defgroup SMARTCARD_Clock_Phase  SMARTCARD Clock Phase
N  * @{
N  */
N#define SMARTCARD_PHASE_1EDGE                    ((uint32_t)0x0000U)
N#define SMARTCARD_PHASE_2EDGE                    ((uint32_t)USART_CR2_CPHA)
N/**
N  * @}
N  */
N
N/** @defgroup SMARTCARD_Last_Bit  SMARTCARD Last Bit
N  * @{
N  */
N#define SMARTCARD_LASTBIT_DISABLE                ((uint32_t)0x0000U)
N#define SMARTCARD_LASTBIT_ENABLE                 ((uint32_t)USART_CR2_LBCL)
N/**
N  * @}
N  */
N
N/** @defgroup SMARTCARD_OneBit_Sampling SMARTCARD OneBit Sampling
N  * @{
N  */
N#define SMARTCARD_ONE_BIT_SAMPLE_DISABLE   ((uint32_t)0x0000U)
N#define SMARTCARD_ONE_BIT_SAMPLE_ENABLE    ((uint32_t)USART_CR3_ONEBIT)
N/**
N  * @}
N  */  
N
N
N/** @defgroup SMARTCARD_NACK_State  SMARTCARD NACK State
N  * @{
N  */
N#define SMARTCARD_NACK_ENABLE           ((uint32_t)USART_CR3_NACK)
N#define SMARTCARD_NACK_DISABLE          ((uint32_t)0x0000U)
N/**
N  * @}
N  */
N
N/** @defgroup SMARTCARD_Timeout_Enable SMARTCARD Timeout Enable
N  * @{
N  */
N#define SMARTCARD_TIMEOUT_DISABLE      ((uint32_t)0x00000000U)
N#define SMARTCARD_TIMEOUT_ENABLE       ((uint32_t)USART_CR2_RTOEN)
N/**
N  * @}
N  */
N  
N/** @defgroup SMARTCARD_DMA_Requests   SMARTCARD DMA requests
N  * @{
N  */
N
N#define SMARTCARD_DMAREQ_TX                    ((uint32_t)USART_CR3_DMAT)
N#define SMARTCARD_DMAREQ_RX                    ((uint32_t)USART_CR3_DMAR)
N
N/**
N  * @}
N  */
N
N/** @defgroup SMARTCARD_Advanced_Features_Initialization_Type SMARTCARD Advanced Features Initialization Type
N  * @{
N  */
N#define SMARTCARD_ADVFEATURE_NO_INIT                 ((uint32_t)0x00000000U)
N#define SMARTCARD_ADVFEATURE_TXINVERT_INIT           ((uint32_t)0x00000001U)
N#define SMARTCARD_ADVFEATURE_RXINVERT_INIT           ((uint32_t)0x00000002U)
N#define SMARTCARD_ADVFEATURE_DATAINVERT_INIT         ((uint32_t)0x00000004U)
N#define SMARTCARD_ADVFEATURE_SWAP_INIT               ((uint32_t)0x00000008U)
N#define SMARTCARD_ADVFEATURE_RXOVERRUNDISABLE_INIT   ((uint32_t)0x00000010U)
N#define SMARTCARD_ADVFEATURE_DMADISABLEONERROR_INIT  ((uint32_t)0x00000020U)
N#define SMARTCARD_ADVFEATURE_MSBFIRST_INIT           ((uint32_t)0x00000080U)
N/**
N  * @}
N  */
N
N/** @defgroup SMARTCARD_Tx_Inv SMARTCARD Tx Inv
N  * @{
N  */
N#define SMARTCARD_ADVFEATURE_TXINV_DISABLE   ((uint32_t)0x00000000U)
N#define SMARTCARD_ADVFEATURE_TXINV_ENABLE    ((uint32_t)USART_CR2_TXINV)
N/**
N  * @}
N  */
N
N/** @defgroup SMARTCARD_Rx_Inv SMARTCARD Rx Inv
N  * @{
N  */
N#define SMARTCARD_ADVFEATURE_RXINV_DISABLE   ((uint32_t)0x00000000U)
N#define SMARTCARD_ADVFEATURE_RXINV_ENABLE    ((uint32_t)USART_CR2_RXINV)
N/**
N  * @}
N  */
N
N/** @defgroup SMARTCARD_Data_Inv SMARTCARD Data Inv
N  * @{
N  */
N#define SMARTCARD_ADVFEATURE_DATAINV_DISABLE     ((uint32_t)0x00000000U)
N#define SMARTCARD_ADVFEATURE_DATAINV_ENABLE      ((uint32_t)USART_CR2_DATAINV)
N/**
N  * @}
N  */ 
N  
N/** @defgroup SMARTCARD_Rx_Tx_Swap SMARTCARD Rx Tx Swap
N  * @{
N  */
N#define SMARTCARD_ADVFEATURE_SWAP_DISABLE   ((uint32_t)0x00000000U)
N#define SMARTCARD_ADVFEATURE_SWAP_ENABLE    ((uint32_t)USART_CR2_SWAP)
N/**
N  * @}
N  */ 
N
N/** @defgroup SMARTCARD_Overrun_Disable SMARTCARD Overrun Disable
N  * @{
N  */
N#define SMARTCARD_ADVFEATURE_OVERRUN_ENABLE   ((uint32_t)0x00000000U)
N#define SMARTCARD_ADVFEATURE_OVERRUN_DISABLE  ((uint32_t)USART_CR3_OVRDIS)
N/**
N  * @}
N  */  
N
N/** @defgroup SMARTCARD_DMA_Disable_on_Rx_Error SMARTCARD DMA Disable on Rx Error
N  * @{
N  */
N#define SMARTCARD_ADVFEATURE_DMA_ENABLEONRXERROR       ((uint32_t)0x00000000U)
N#define SMARTCARD_ADVFEATURE_DMA_DISABLEONRXERROR      ((uint32_t)USART_CR3_DDRE)
N/**
N  * @}
N  */  
N
N/** @defgroup SMARTCARD_MSB_First SMARTCARD MSB First
N  * @{
N  */
N#define SMARTCARD_ADVFEATURE_MSBFIRST_DISABLE      ((uint32_t)0x00000000U)
N#define SMARTCARD_ADVFEATURE_MSBFIRST_ENABLE       ((uint32_t)USART_CR2_MSBFIRST)
N/**
N  * @}
N  */  
N
N/** @defgroup SmartCard_Flags SMARTCARD Flags
N  *        Elements values convention: 0xXXXX
N  *           - 0xXXXX  : Flag mask in the ISR register
N  * @{
N  */
N#define SMARTCARD_FLAG_REACK                     ((uint32_t)0x00400000U)
N#define SMARTCARD_FLAG_TEACK                     ((uint32_t)0x00200000U)
N#define SMARTCARD_FLAG_BUSY                      ((uint32_t)0x00010000U)
N#define SMARTCARD_FLAG_EOBF                      ((uint32_t)0x00001000U)
N#define SMARTCARD_FLAG_RTOF                      ((uint32_t)0x00000800U)
N#define SMARTCARD_FLAG_TXE                       ((uint32_t)0x00000080U)
N#define SMARTCARD_FLAG_TC                        ((uint32_t)0x00000040U)
N#define SMARTCARD_FLAG_RXNE                      ((uint32_t)0x00000020U)
N#define SMARTCARD_FLAG_IDLE                      ((uint32_t)0x00000010U)
N#define SMARTCARD_FLAG_ORE                       ((uint32_t)0x00000008U)
N#define SMARTCARD_FLAG_NE                        ((uint32_t)0x00000004U)
N#define SMARTCARD_FLAG_FE                        ((uint32_t)0x00000002U)
N#define SMARTCARD_FLAG_PE                        ((uint32_t)0x00000001U)
N/**
N  * @}
N  */
N
N/** @defgroup SMARTCARD_Interrupt_definition SMARTCARD Interrupt definition
N  *        Elements values convention: 0000ZZZZ0XXYYYYYb
N  *           - YYYYY  : Interrupt source position in the XX register (5bits)
N  *           - XX  : Interrupt source register (2bits)
N  *                 - 01: CR1 register
N  *                 - 10: CR2 register
N  *                 - 11: CR3 register
N  *           - ZZZZ  : Flag position in the ISR register(4bits)
N  * @{
N  */
N  
N#define SMARTCARD_IT_PE                          ((uint16_t)0x0028U)
N#define SMARTCARD_IT_TXE                         ((uint16_t)0x0727U)
N#define SMARTCARD_IT_TC                          ((uint16_t)0x0626U)
N#define SMARTCARD_IT_RXNE                        ((uint16_t)0x0525U)
N#define SMARTCARD_IT_IDLE                        ((uint16_t)0x0424U)
N#define SMARTCARD_IT_ERR                         ((uint16_t)0x0060U)
N#define SMARTCARD_IT_ORE                         ((uint16_t)0x0300U)
N#define SMARTCARD_IT_NE                          ((uint16_t)0x0200U)
N#define SMARTCARD_IT_FE                          ((uint16_t)0x0100U)
N
N#define SMARTCARD_IT_EOB                         ((uint16_t)0x0C3BU)
N#define SMARTCARD_IT_RTO                         ((uint16_t)0x0B3AU)
N/**
N  * @}
N  */ 
N
N
N/** @defgroup SMARTCARD_IT_CLEAR_Flags SMARTCARD IT CLEAR Flags
N  * @{
N  */
N#define SMARTCARD_CLEAR_PEF                       USART_ICR_PECF            /*!< Parity Error Clear Flag */          
N#define SMARTCARD_CLEAR_FEF                       USART_ICR_FECF            /*!< Framing Error Clear Flag */         
N#define SMARTCARD_CLEAR_NEF                       USART_ICR_NCF             /*!< Noise detected Clear Flag */        
N#define SMARTCARD_CLEAR_OREF                      USART_ICR_ORECF           /*!< OverRun Error Clear Flag */         
N#define SMARTCARD_CLEAR_IDLEF                     USART_ICR_IDLECF          /*!< Idle line detected clear Flag */
N#define SMARTCARD_CLEAR_TCF                       USART_ICR_TCCF            /*!< Transmission Complete Clear Flag */ 
N#define SMARTCARD_CLEAR_RTOF                      USART_ICR_RTOCF           /*!< Receiver Time Out Clear Flag */     
N#define SMARTCARD_CLEAR_EOBF                      USART_ICR_EOBCF           /*!< End Of Block Clear Flag */          
N/**
N  * @}
N  */
N
N/** @defgroup SMARTCARD_Request_Parameters SMARTCARD Request Parameters
N  * @{
N  */        
N#define SMARTCARD_RXDATA_FLUSH_REQUEST        ((uint32_t)USART_RQR_RXFRQ)        /*!< Receive Data flush Request */ 
N#define SMARTCARD_TXDATA_FLUSH_REQUEST        ((uint32_t)USART_RQR_TXFRQ)        /*!< Transmit data flush Request */
N/**
N  * @}
N  */
N  
N  
N/** @defgroup SMARTCARD_CR3_SCAR_CNT_LSB_POS SMARTCARD CR3 SCAR CNT LSB POS
N  * @{
N  */
N#define SMARTCARD_CR3_SCARCNT_LSB_POS            ((uint32_t) 17U)
N/**
N  * @}
N  */
N  
N/** @defgroup SMARTCARD_GTPR_GT_LSBPOS SMARTCARD GTPR GT LSBPOS
N  * @{
N  */
N#define SMARTCARD_GTPR_GT_LSB_POS            ((uint32_t) 8U)
N/**
N  * @}
N  */ 
N  
N/** @defgroup SMARTCARD_RTOR_BLEN_LSBPOS SMARTCARD RTOR BLEN LSBPOS
N  * @{
N  */
N#define SMARTCARD_RTOR_BLEN_LSB_POS          ((uint32_t) 24U)
N/**
N  * @}
N  */    
N 
N/** @defgroup SMARTCARD_Interruption_Mask SMARTCARD Interruption Mask
N  * @{
N  */ 
N#define SMARTCARD_IT_MASK  ((uint16_t)0x001FU)  
N/**
N  * @}
N  */
N    
N/**
N  * @}
N  */    
N    
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup SMARTCARD_Exported_Macros SMARTCARD Exported Macros
N  * @{
N  */
N
N/** @brief Reset SMARTCARD handle state
N  * @param  __HANDLE__: specifies the SMARTCARD Handle.
N  *         The Handle Instance which can be USART1 or USART2
N  * @retval None
N  */
N#define __HAL_SMARTCARD_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_SMARTCARD_STATE_RESET)
N
N/** @brief  Flush the Smartcard DR register 
N  * @param  __HANDLE__: specifies the SMARTCARD Handle.
N  *         The Handle Instance which can be USART1 or USART2.
N  * @retval None
N  */
N#define __HAL_SMARTCARD_FLUSH_DRREGISTER(__HANDLE__) (__HAL_SMARTCARD_SEND_REQ((__HANDLE__), SMARTCARD_RXDATA_FLUSH_REQUEST))
N
N/** @brief  Checks whether the specified Smartcard flag is set or not.
N  * @param  __HANDLE__: specifies the SMARTCARD Handle.
N  *         The Handle Instance which can be USART1 or USART2.
N  * @param  __FLAG__: specifies the flag to check.
N  *        This parameter can be one of the following values:
N  *            @arg SMARTCARD_FLAG_REACK: Receive enable acknowledge flag
N  *            @arg SMARTCARD_FLAG_TEACK: Transmit enable acknowledge flag
N  *            @arg SMARTCARD_FLAG_BUSY:  Busy flag
N  *            @arg SMARTCARD_FLAG_EOBF:  End of block flag   
N  *            @arg SMARTCARD_FLAG_RTOF:  Receiver timeout flag
N  *            @arg SMARTCARD_FLAG_TXE:   Transmit data register empty flag
N  *            @arg SMARTCARD_FLAG_TC:    Transmission Complete flag
N  *            @arg SMARTCARD_FLAG_RXNE:  Receive data register not empty flag
N  *            @arg SMARTCARD_FLAG_ORE:   OverRun Error flag
N  *            @arg SMARTCARD_FLAG_NE:    Noise Error flag
N  *            @arg SMARTCARD_FLAG_FE:    Framing Error flag
N  *            @arg SMARTCARD_FLAG_PE:    Parity Error flag
N  * @retval The new state of __FLAG__ (TRUE or FALSE).
N  */
N#define __HAL_SMARTCARD_GET_FLAG(__HANDLE__, __FLAG__) (((__HANDLE__)->Instance->ISR & (__FLAG__)) == (__FLAG__))
N
N/** @brief  Enables the specified SmartCard interrupt.
N  * @param  __HANDLE__: specifies the SMARTCARD Handle.
N  *         The Handle Instance which can be USART1 or USART2.
N  * @param  __INTERRUPT__: specifies the SMARTCARD interrupt to enable.
N  *          This parameter can be one of the following values:
N  *            @arg SMARTCARD_IT_EOBF: End Of Block interrupt
N  *            @arg SMARTCARD_IT_RTOF: Receive TimeOut interrupt
N  *            @arg SMARTCARD_IT_TXE:  Transmit Data Register empty interrupt
N  *            @arg SMARTCARD_IT_TC:   Transmission complete interrupt
N  *            @arg SMARTCARD_IT_RXNE: Receive Data register not empty interrupt
N  *            @arg SMARTCARD_IT_PE:   Parity Error interrupt
N  *            @arg SMARTCARD_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
N  * @retval None
N  */
N#define __HAL_SMARTCARD_ENABLE_IT(__HANDLE__, __INTERRUPT__)   (((((uint8_t)(__INTERRUPT__)) >> 5) == 1)? ((__HANDLE__)->Instance->CR1 |= (1 << ((__INTERRUPT__) & SMARTCARD_IT_MASK))): \
N                                                        ((((uint8_t)(__INTERRUPT__)) >> 5) == 2)? ((__HANDLE__)->Instance->CR2 |= (1 << ((__INTERRUPT__) & SMARTCARD_IT_MASK))): \
N                                                        ((__HANDLE__)->Instance->CR3 |= (1 << ((__INTERRUPT__) & SMARTCARD_IT_MASK))))
X#define __HAL_SMARTCARD_ENABLE_IT(__HANDLE__, __INTERRUPT__)   (((((uint8_t)(__INTERRUPT__)) >> 5) == 1)? ((__HANDLE__)->Instance->CR1 |= (1 << ((__INTERRUPT__) & SMARTCARD_IT_MASK))):                                                         ((((uint8_t)(__INTERRUPT__)) >> 5) == 2)? ((__HANDLE__)->Instance->CR2 |= (1 << ((__INTERRUPT__) & SMARTCARD_IT_MASK))):                                                         ((__HANDLE__)->Instance->CR3 |= (1 << ((__INTERRUPT__) & SMARTCARD_IT_MASK))))
N/** @brief  Disables the specified SmartCard interrupt.
N  * @param  __HANDLE__: specifies the SMARTCARD Handle.
N  *         The Handle Instance which can be USART1 or USART2.
N  * @param  __INTERRUPT__: specifies the SMARTCARD interrupt to enable.
N  *          This parameter can be one of the following values:
N  *            @arg SMARTCARD_IT_EOBF: End Of Block interrupt
N  *            @arg SMARTCARD_IT_RTOF: Receive TimeOut interrupt
N  *            @arg SMARTCARD_IT_TXE:  Transmit Data Register empty interrupt
N  *            @arg SMARTCARD_IT_TC:   Transmission complete interrupt
N  *            @arg SMARTCARD_IT_RXNE: Receive Data register not empty interrupt
N  *            @arg SMARTCARD_IT_PE:   Parity Error interrupt
N  *            @arg SMARTCARD_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
N  * @retval None
N  */
N#define __HAL_SMARTCARD_DISABLE_IT(__HANDLE__, __INTERRUPT__)  (((((uint8_t)(__INTERRUPT__)) >> 5) == 1)? ((__HANDLE__)->Instance->CR1 &= ~ ((uint32_t)1 << ((__INTERRUPT__) & SMARTCARD_IT_MASK))): \
N                                                        ((((uint8_t)(__INTERRUPT__)) >> 5) == 2)? ((__HANDLE__)->Instance->CR2 &= ~ ((uint32_t)1 << ((__INTERRUPT__) & SMARTCARD_IT_MASK))): \
N                                                        ((__HANDLE__)->Instance->CR3 &= ~ ((uint32_t)1 << ((__INTERRUPT__) & SMARTCARD_IT_MASK))))
X#define __HAL_SMARTCARD_DISABLE_IT(__HANDLE__, __INTERRUPT__)  (((((uint8_t)(__INTERRUPT__)) >> 5) == 1)? ((__HANDLE__)->Instance->CR1 &= ~ ((uint32_t)1 << ((__INTERRUPT__) & SMARTCARD_IT_MASK))):                                                         ((((uint8_t)(__INTERRUPT__)) >> 5) == 2)? ((__HANDLE__)->Instance->CR2 &= ~ ((uint32_t)1 << ((__INTERRUPT__) & SMARTCARD_IT_MASK))):                                                         ((__HANDLE__)->Instance->CR3 &= ~ ((uint32_t)1 << ((__INTERRUPT__) & SMARTCARD_IT_MASK))))
N
N/** @brief  Checks whether the specified SmartCard interrupt has occurred or not.
N  * @param  __HANDLE__: specifies the SMARTCARD Handle.
N  *         The Handle Instance which can be USART1 or USART2.
N  * @param  __IT__: specifies the SMARTCARD interrupt to check.
N  *          This parameter can be one of the following values:
N  *            @arg SMARTCARD_IT_EOBF: End Of Block interrupt
N  *            @arg SMARTCARD_IT_RTOF: Receive TimeOut interrupt  
N  *            @arg SMARTCARD_IT_TXE:  Transmit Data Register empty interrupt
N  *            @arg SMARTCARD_IT_TC:   Transmission complete interrupt
N  *            @arg SMARTCARD_IT_RXNE: Receive Data register not empty interrupt
N  *            @arg SMARTCARD_IT_ORE:  OverRun Error interrupt
N  *            @arg SMARTCARD_IT_NE:   Noise Error interrupt
N  *            @arg SMARTCARD_IT_FE:   Framing Error interrupt
N  *            @arg SMARTCARD_IT_PE:   Parity Error interrupt
N  * @retval The new state of __IT__ (TRUE or FALSE).
N  */
N#define __HAL_SMARTCARD_GET_IT(__HANDLE__, __IT__) ((__HANDLE__)->Instance->ISR & ((uint32_t)1 << ((__IT__)>> 0x08))) 
N
N/** @brief  Checks whether the specified SmartCard interrupt interrupt source is enabled.
N  * @param  __HANDLE__: specifies the SMARTCARD Handle.
N  *         The Handle Instance which can be USART1 or USART2.
N  * @param  __IT__: specifies the SMARTCARD interrupt source to check.
N  *          This parameter can be one of the following values:
N  *            @arg SMARTCARD_IT_EOBF: End Of Block interrupt
N  *            @arg SMARTCARD_IT_RTOF: Receive TimeOut interrupt  
N  *            @arg SMARTCARD_IT_TXE:  Transmit Data Register empty interrupt
N  *            @arg SMARTCARD_IT_TC:   Transmission complete interrupt
N  *            @arg SMARTCARD_IT_RXNE: Receive Data register not empty interrupt
N  *            @arg SMARTCARD_IT_ORE:  OverRun Error interrupt
N  *            @arg SMARTCARD_IT_NE:   Noise Error interrupt
N  *            @arg SMARTCARD_IT_FE:   Framing Error interrupt
N  *            @arg SMARTCARD_IT_PE:   Parity Error interrupt
N  * @retval The new state of __IT__ (TRUE or FALSE).
N  */
N#define __HAL_SMARTCARD_GET_IT_SOURCE(__HANDLE__, __IT__) ((((((uint8_t)(__IT__)) >> 5) == 1)? (__HANDLE__)->Instance->CR1:(((((uint8_t)(__IT__)) >> 5) == 2)? \
N                                                               (__HANDLE__)->Instance->CR2 : (__HANDLE__)->Instance->CR3)) & ((uint32_t)1 << \
N                                                               (((uint16_t)(__IT__)) & SMARTCARD_IT_MASK)))
X#define __HAL_SMARTCARD_GET_IT_SOURCE(__HANDLE__, __IT__) ((((((uint8_t)(__IT__)) >> 5) == 1)? (__HANDLE__)->Instance->CR1:(((((uint8_t)(__IT__)) >> 5) == 2)?                                                                (__HANDLE__)->Instance->CR2 : (__HANDLE__)->Instance->CR3)) & ((uint32_t)1 <<                                                                (((uint16_t)(__IT__)) & SMARTCARD_IT_MASK)))
N
N
N/** @brief  Clears the specified SMARTCARD ISR flag, in setting the proper ICR register flag.
N  * @param  __HANDLE__: specifies the SMARTCARD Handle.
N  *         The Handle Instance which can be USART1 or USART2.
N  * @param  __IT_CLEAR__: specifies the interrupt clear register flag that needs to be set
N  *                       to clear the corresponding interrupt
N  *          This parameter can be one of the following values:
N  *            @arg USART_CLEAR_PEF: Parity Error Clear Flag
N  *            @arg USART_CLEAR_FEF: Framing Error Clear Flag
N  *            @arg USART_CLEAR_NEF: Noise detected Clear Flag
N  *            @arg USART_CLEAR_OREF: OverRun Error Clear Flag
N  *            @arg USART_CLEAR_TCF: Transmission Complete Clear Flag
N  *            @arg USART_CLEAR_RTOF: Receiver Time Out Clear Flag
N  *            @arg USART_CLEAR_EOBF: End Of Block Clear Flag 
N  * @retval None
N  */
N#define __HAL_SMARTCARD_CLEAR_IT(__HANDLE__, __IT_CLEAR__) ((__HANDLE__)->Instance->ICR = (uint32_t)(__IT_CLEAR__)) 
N
N/** @brief  Set a specific SMARTCARD request flag.
N  * @param  __HANDLE__: specifies the SMARTCARD Handle.
N  *         The Handle Instance which can be USART1 or USART2.
N  * @param  __REQ__: specifies the request flag to set
N  *          This parameter can be one of the following values:  
N  *            @arg SMARTCARD_RXDATA_FLUSH_REQUEST: Receive Data flush Request 
N  *            @arg SMARTCARD_TXDATA_FLUSH_REQUEST: Transmit data flush Request 
N  *
N  * @retval None
N  */ 
N#define __HAL_SMARTCARD_SEND_REQ(__HANDLE__, __REQ__) ((__HANDLE__)->Instance->RQR |= (uint32_t)(__REQ__)) 
N
N/** @brief  Enable the USART associated to the SMARTCARD Handle
N  * @param  __HANDLE__: specifies the SMARTCARD Handle.
N  *         The Handle Instance which can be USART1 or USART2.
N  * @retval None
N  */
N#define __HAL_SMARTCARD_ENABLE(__HANDLE__)               ( (__HANDLE__)->Instance->CR1 |=  USART_CR1_UE)
N
N/** @brief  Disable the USART associated to the SMARTCARD Handle
N  * @param  __HANDLE__: specifies the SMARTCARD Handle.
N  *         The Handle Instance which can be USART1 or USART2.
N  * @retval None
N  */
N#define __HAL_SMARTCARD_DISABLE(__HANDLE__)              ( (__HANDLE__)->Instance->CR1 &=  ~USART_CR1_UE)
N
N/** @brief  Macros to enable or disable the SmartCard DMA request.
N  * @param  __HANDLE__: specifies the SMARTCARD Handle.
N  *         The Handle Instance which can be USART1 or USART2.
N  * @param  __REQUEST__: specifies the SmartCard DMA request.
N  *          This parameter can be one of the following values:
N  *            @arg SMARTCARD_DMAREQ_TX: SmartCard DMA transmit request
N  *            @arg SMARTCARD_DMAREQ_RX: SmartCard DMA receive request
N  */
N#define __HAL_SMARTCARD_DMA_REQUEST_ENABLE(__HANDLE__, __REQUEST__)    ((__HANDLE__)->Instance->CR3 |=  (__REQUEST__))
N#define __HAL_SMARTCARD_DMA_REQUEST_DISABLE(__HANDLE__, __REQUEST__)   ((__HANDLE__)->Instance->CR3 &=  ~(__REQUEST__))
N/**
N  * @}
N  */
N
N/* Include SMARTCARD HAL Extension module */
N#include "stm32f7xx_hal_smartcard_ex.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_smartcard_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_smartcard_ex.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of SMARTCARD HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_SMARTCARD_EX_H
N#define __STM32F7xx_HAL_SMARTCARD_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup SMARTCARDEx
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N   
N/** @brief  Reports the SMARTCARD clock source.
N  * @param  __HANDLE__: specifies the USART Handle
N  * @param  __CLOCKSOURCE__ : output variable   
N  * @retval the USART clocking source, written in __CLOCKSOURCE__.
N  */
N#define SMARTCARD_GETCLOCKSOURCE(__HANDLE__,__CLOCKSOURCE__) \
N  do {                                                             \
N    if((__HANDLE__)->Instance == USART1)                           \
N    {                                                              \
N       switch(__HAL_RCC_GET_USART1_SOURCE())                       \
N       {                                                           \
N        case RCC_USART1CLKSOURCE_PCLK2:                            \
N          (__CLOCKSOURCE__) = SMARTCARD_CLOCKSOURCE_PCLK2;         \
N          break;                                                   \
N        case RCC_USART1CLKSOURCE_HSI:                              \
N          (__CLOCKSOURCE__) = SMARTCARD_CLOCKSOURCE_HSI;           \
N          break;                                                   \
N        case RCC_USART1CLKSOURCE_SYSCLK:                           \
N          (__CLOCKSOURCE__) = SMARTCARD_CLOCKSOURCE_SYSCLK;        \
N          break;                                                   \
N        case RCC_USART1CLKSOURCE_LSE:                              \
N          (__CLOCKSOURCE__) = SMARTCARD_CLOCKSOURCE_LSE;           \
N          break;                                                   \
N        default:                                                   \
N          break;                                                   \
N       }                                                           \
N    }                                                              \
N    else if((__HANDLE__)->Instance == USART2)                      \
N    {                                                              \
N       switch(__HAL_RCC_GET_USART2_SOURCE())                       \
N       {                                                           \
N        case RCC_USART2CLKSOURCE_PCLK1:                            \
N          (__CLOCKSOURCE__) = SMARTCARD_CLOCKSOURCE_PCLK1;         \
N          break;                                                   \
N        case RCC_USART2CLKSOURCE_HSI:                              \
N          (__CLOCKSOURCE__) = SMARTCARD_CLOCKSOURCE_HSI;           \
N          break;                                                   \
N        case RCC_USART2CLKSOURCE_SYSCLK:                           \
N          (__CLOCKSOURCE__) = SMARTCARD_CLOCKSOURCE_SYSCLK;        \
N          break;                                                   \
N        case RCC_USART2CLKSOURCE_LSE:                              \
N          (__CLOCKSOURCE__) = SMARTCARD_CLOCKSOURCE_LSE;           \
N          break;                                                   \
N        default:                                                   \
N          break;                                                   \
N       }                                                           \
N    }                                                              \
N    else if((__HANDLE__)->Instance == USART3)                      \
N    {                                                              \
N       switch(__HAL_RCC_GET_USART3_SOURCE())                       \
N       {                                                           \
N        case RCC_USART3CLKSOURCE_PCLK1:                            \
N          (__CLOCKSOURCE__) = SMARTCARD_CLOCKSOURCE_PCLK1;         \
N          break;                                                   \
N        case RCC_USART3CLKSOURCE_HSI:                              \
N          (__CLOCKSOURCE__) = SMARTCARD_CLOCKSOURCE_HSI;           \
N          break;                                                   \
N        case RCC_USART3CLKSOURCE_SYSCLK:                           \
N          (__CLOCKSOURCE__) = SMARTCARD_CLOCKSOURCE_SYSCLK;        \
N          break;                                                   \
N        case RCC_USART3CLKSOURCE_LSE:                              \
N          (__CLOCKSOURCE__) = SMARTCARD_CLOCKSOURCE_LSE;           \
N          break;                                                   \
N        default:                                                   \
N          break;                                                   \
N       }                                                           \
N    }                                                              \
N    else if((__HANDLE__)->Instance == USART6)                      \
N    {                                                              \
N       switch(__HAL_RCC_GET_USART6_SOURCE())                       \
N       {                                                           \
N        case RCC_USART6CLKSOURCE_PCLK2:                            \
N          (__CLOCKSOURCE__) = SMARTCARD_CLOCKSOURCE_PCLK2;         \
N          break;                                                   \
N        case RCC_USART6CLKSOURCE_HSI:                              \
N          (__CLOCKSOURCE__) = SMARTCARD_CLOCKSOURCE_HSI;           \
N          break;                                                   \
N        case RCC_USART6CLKSOURCE_SYSCLK:                           \
N          (__CLOCKSOURCE__) = SMARTCARD_CLOCKSOURCE_SYSCLK;        \
N          break;                                                   \
N        case RCC_USART6CLKSOURCE_LSE:                              \
N          (__CLOCKSOURCE__) = SMARTCARD_CLOCKSOURCE_LSE;           \
N          break;                                                   \
N        default:                                                   \
N          break;                                                   \
N       }                                                           \
N    }                                                              \
N    } while(0)
X#define SMARTCARD_GETCLOCKSOURCE(__HANDLE__,__CLOCKSOURCE__)   do {                                                                 if((__HANDLE__)->Instance == USART1)                               {                                                                     switch(__HAL_RCC_GET_USART1_SOURCE())                              {                                                                   case RCC_USART1CLKSOURCE_PCLK2:                                      (__CLOCKSOURCE__) = SMARTCARD_CLOCKSOURCE_PCLK2;                   break;                                                           case RCC_USART1CLKSOURCE_HSI:                                        (__CLOCKSOURCE__) = SMARTCARD_CLOCKSOURCE_HSI;                     break;                                                           case RCC_USART1CLKSOURCE_SYSCLK:                                     (__CLOCKSOURCE__) = SMARTCARD_CLOCKSOURCE_SYSCLK;                  break;                                                           case RCC_USART1CLKSOURCE_LSE:                                        (__CLOCKSOURCE__) = SMARTCARD_CLOCKSOURCE_LSE;                     break;                                                           default:                                                             break;                                                          }                                                               }                                                                  else if((__HANDLE__)->Instance == USART2)                          {                                                                     switch(__HAL_RCC_GET_USART2_SOURCE())                              {                                                                   case RCC_USART2CLKSOURCE_PCLK1:                                      (__CLOCKSOURCE__) = SMARTCARD_CLOCKSOURCE_PCLK1;                   break;                                                           case RCC_USART2CLKSOURCE_HSI:                                        (__CLOCKSOURCE__) = SMARTCARD_CLOCKSOURCE_HSI;                     break;                                                           case RCC_USART2CLKSOURCE_SYSCLK:                                     (__CLOCKSOURCE__) = SMARTCARD_CLOCKSOURCE_SYSCLK;                  break;                                                           case RCC_USART2CLKSOURCE_LSE:                                        (__CLOCKSOURCE__) = SMARTCARD_CLOCKSOURCE_LSE;                     break;                                                           default:                                                             break;                                                          }                                                               }                                                                  else if((__HANDLE__)->Instance == USART3)                          {                                                                     switch(__HAL_RCC_GET_USART3_SOURCE())                              {                                                                   case RCC_USART3CLKSOURCE_PCLK1:                                      (__CLOCKSOURCE__) = SMARTCARD_CLOCKSOURCE_PCLK1;                   break;                                                           case RCC_USART3CLKSOURCE_HSI:                                        (__CLOCKSOURCE__) = SMARTCARD_CLOCKSOURCE_HSI;                     break;                                                           case RCC_USART3CLKSOURCE_SYSCLK:                                     (__CLOCKSOURCE__) = SMARTCARD_CLOCKSOURCE_SYSCLK;                  break;                                                           case RCC_USART3CLKSOURCE_LSE:                                        (__CLOCKSOURCE__) = SMARTCARD_CLOCKSOURCE_LSE;                     break;                                                           default:                                                             break;                                                          }                                                               }                                                                  else if((__HANDLE__)->Instance == USART6)                          {                                                                     switch(__HAL_RCC_GET_USART6_SOURCE())                              {                                                                   case RCC_USART6CLKSOURCE_PCLK2:                                      (__CLOCKSOURCE__) = SMARTCARD_CLOCKSOURCE_PCLK2;                   break;                                                           case RCC_USART6CLKSOURCE_HSI:                                        (__CLOCKSOURCE__) = SMARTCARD_CLOCKSOURCE_HSI;                     break;                                                           case RCC_USART6CLKSOURCE_SYSCLK:                                     (__CLOCKSOURCE__) = SMARTCARD_CLOCKSOURCE_SYSCLK;                  break;                                                           case RCC_USART6CLKSOURCE_LSE:                                        (__CLOCKSOURCE__) = SMARTCARD_CLOCKSOURCE_LSE;                     break;                                                           default:                                                             break;                                                          }                                                               }                                                                  } while(0)
N
N/* Exported functions --------------------------------------------------------*/
N/* Initialization and de-initialization functions  ****************************/
N/* IO operation functions *****************************************************/
N/* Peripheral Control functions ***********************************************/
Nvoid HAL_SMARTCARDEx_BlockLength_Config(SMARTCARD_HandleTypeDef *hsc, uint8_t BlockLength);
Nvoid HAL_SMARTCARDEx_TimeOut_Config(SMARTCARD_HandleTypeDef *hsc, uint32_t TimeOutValue);
NHAL_StatusTypeDef HAL_SMARTCARDEx_EnableReceiverTimeOut(SMARTCARD_HandleTypeDef *hsc);
NHAL_StatusTypeDef HAL_SMARTCARDEx_DisableReceiverTimeOut(SMARTCARD_HandleTypeDef *hsc);
N
N/* Peripheral State and Error functions ***************************************/
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_SMARTCARD_EX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 755 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_smartcard.h" 2
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup SMARTCARD_Exported_Functions
N  * @{
N  */
N  
N/** @addtogroup SMARTCARD_Exported_Functions_Group1
N  * @{
N  */
N/* Initialization/de-initialization functions  **********************************/
NHAL_StatusTypeDef HAL_SMARTCARD_Init(SMARTCARD_HandleTypeDef *hsc);
NHAL_StatusTypeDef HAL_SMARTCARD_DeInit(SMARTCARD_HandleTypeDef *hsc);
Nvoid HAL_SMARTCARD_MspInit(SMARTCARD_HandleTypeDef *hsc);
Nvoid HAL_SMARTCARD_MspDeInit(SMARTCARD_HandleTypeDef *hsc);
N/**
N  * @}
N  */
N
N/** @addtogroup SMARTCARD_Exported_Functions_Group2
N  * @{
N  */
N/* IO operation functions *******************************************************/
NHAL_StatusTypeDef HAL_SMARTCARD_Transmit(SMARTCARD_HandleTypeDef *hsc, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_SMARTCARD_Receive(SMARTCARD_HandleTypeDef *hsc, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_SMARTCARD_Transmit_IT(SMARTCARD_HandleTypeDef *hsc, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_SMARTCARD_Receive_IT(SMARTCARD_HandleTypeDef *hsc, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_SMARTCARD_Transmit_DMA(SMARTCARD_HandleTypeDef *hsc, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_SMARTCARD_Receive_DMA(SMARTCARD_HandleTypeDef *hsc, uint8_t *pData, uint16_t Size);
Nvoid HAL_SMARTCARD_IRQHandler(SMARTCARD_HandleTypeDef *hsc);
Nvoid HAL_SMARTCARD_TxCpltCallback(SMARTCARD_HandleTypeDef *hsc);
Nvoid HAL_SMARTCARD_RxCpltCallback(SMARTCARD_HandleTypeDef *hsc);
Nvoid HAL_SMARTCARD_ErrorCallback(SMARTCARD_HandleTypeDef *hsc);
N/**
N  * @}
N  */
N
N/** @addtogroup SMARTCARD_Exported_Functions_Group3
N  * @{
N  */
N/* Peripheral State functions  **************************************************/
NHAL_SMARTCARD_StateTypeDef HAL_SMARTCARD_GetState(SMARTCARD_HandleTypeDef *hsc);
Nuint32_t HAL_SMARTCARD_GetError(SMARTCARD_HandleTypeDef *hsc);
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup SMARTCARD_Private_Constants SMARTCARD Private Constants
N  * @{
N  */
N
N#define IS_SMARTCARD_WORD_LENGTH(__LENGTH__) ((__LENGTH__) == SMARTCARD_WORDLENGTH_9B) 
N#define IS_SMARTCARD_STOPBITS(__STOPBITS__) ((__STOPBITS__) == SMARTCARD_STOPBITS_1_5)
N#define IS_SMARTCARD_PARITY(__PARITY__) (((__PARITY__) == SMARTCARD_PARITY_EVEN) || \
N                                         ((__PARITY__) == SMARTCARD_PARITY_ODD))
X#define IS_SMARTCARD_PARITY(__PARITY__) (((__PARITY__) == SMARTCARD_PARITY_EVEN) ||                                          ((__PARITY__) == SMARTCARD_PARITY_ODD))
N#define IS_SMARTCARD_MODE(__MODE__) ((((__MODE__) & (uint32_t)0xFFF3) == 0x00) && ((__MODE__) != (uint32_t)0x00))
N#define IS_SMARTCARD_POLARITY(__CPOL__) (((__CPOL__) == SMARTCARD_POLARITY_LOW) || ((__CPOL__) == SMARTCARD_POLARITY_HIGH))
N#define IS_SMARTCARD_PHASE(__CPHA__) (((__CPHA__) == SMARTCARD_PHASE_1EDGE) || ((__CPHA__) == SMARTCARD_PHASE_2EDGE))
N#define IS_SMARTCARD_LASTBIT(__LASTBIT__) (((__LASTBIT__) == SMARTCARD_LASTBIT_DISABLE) || \
N                                           ((__LASTBIT__) == SMARTCARD_LASTBIT_ENABLE))
X#define IS_SMARTCARD_LASTBIT(__LASTBIT__) (((__LASTBIT__) == SMARTCARD_LASTBIT_DISABLE) ||                                            ((__LASTBIT__) == SMARTCARD_LASTBIT_ENABLE))
N#define IS_SMARTCARD_ONE_BIT_SAMPLE(__ONEBIT__) (((__ONEBIT__) == SMARTCARD_ONE_BIT_SAMPLE_DISABLE) || \
N                                                  ((__ONEBIT__) == SMARTCARD_ONE_BIT_SAMPLE_ENABLE))
X#define IS_SMARTCARD_ONE_BIT_SAMPLE(__ONEBIT__) (((__ONEBIT__) == SMARTCARD_ONE_BIT_SAMPLE_DISABLE) ||                                                   ((__ONEBIT__) == SMARTCARD_ONE_BIT_SAMPLE_ENABLE))
N#define IS_SMARTCARD_NACK(__NACK__) (((__NACK__) == SMARTCARD_NACK_ENABLE) || \
N                                     ((__NACK__) == SMARTCARD_NACK_DISABLE))
X#define IS_SMARTCARD_NACK(__NACK__) (((__NACK__) == SMARTCARD_NACK_ENABLE) ||                                      ((__NACK__) == SMARTCARD_NACK_DISABLE))
N#define IS_SMARTCARD_TIMEOUT(__TIMEOUT__) (((__TIMEOUT__) == SMARTCARD_TIMEOUT_DISABLE) || \
N                                           ((__TIMEOUT__) == SMARTCARD_TIMEOUT_ENABLE))
X#define IS_SMARTCARD_TIMEOUT(__TIMEOUT__) (((__TIMEOUT__) == SMARTCARD_TIMEOUT_DISABLE) ||                                            ((__TIMEOUT__) == SMARTCARD_TIMEOUT_ENABLE))
N#define IS_SMARTCARD_ADVFEATURE_INIT(INIT)           ((INIT) <= (SMARTCARD_ADVFEATURE_NO_INIT | \
N                                                            SMARTCARD_ADVFEATURE_TXINVERT_INIT | \
N                                                            SMARTCARD_ADVFEATURE_RXINVERT_INIT | \
N                                                            SMARTCARD_ADVFEATURE_DATAINVERT_INIT | \
N                                                            SMARTCARD_ADVFEATURE_SWAP_INIT | \
N                                                            SMARTCARD_ADVFEATURE_RXOVERRUNDISABLE_INIT | \
N                                                            SMARTCARD_ADVFEATURE_DMADISABLEONERROR_INIT   | \
N                                                            SMARTCARD_ADVFEATURE_MSBFIRST_INIT))  
X#define IS_SMARTCARD_ADVFEATURE_INIT(INIT)           ((INIT) <= (SMARTCARD_ADVFEATURE_NO_INIT |                                                             SMARTCARD_ADVFEATURE_TXINVERT_INIT |                                                             SMARTCARD_ADVFEATURE_RXINVERT_INIT |                                                             SMARTCARD_ADVFEATURE_DATAINVERT_INIT |                                                             SMARTCARD_ADVFEATURE_SWAP_INIT |                                                             SMARTCARD_ADVFEATURE_RXOVERRUNDISABLE_INIT |                                                             SMARTCARD_ADVFEATURE_DMADISABLEONERROR_INIT   |                                                             SMARTCARD_ADVFEATURE_MSBFIRST_INIT))  
N#define IS_SMARTCARD_ADVFEATURE_TXINV(TXINV) (((TXINV) == SMARTCARD_ADVFEATURE_TXINV_DISABLE) || \
N                                         ((TXINV) == SMARTCARD_ADVFEATURE_TXINV_ENABLE))
X#define IS_SMARTCARD_ADVFEATURE_TXINV(TXINV) (((TXINV) == SMARTCARD_ADVFEATURE_TXINV_DISABLE) ||                                          ((TXINV) == SMARTCARD_ADVFEATURE_TXINV_ENABLE))
N#define IS_SMARTCARD_ADVFEATURE_RXINV(RXINV) (((RXINV) == SMARTCARD_ADVFEATURE_RXINV_DISABLE) || \
N                                         ((RXINV) == SMARTCARD_ADVFEATURE_RXINV_ENABLE))
X#define IS_SMARTCARD_ADVFEATURE_RXINV(RXINV) (((RXINV) == SMARTCARD_ADVFEATURE_RXINV_DISABLE) ||                                          ((RXINV) == SMARTCARD_ADVFEATURE_RXINV_ENABLE))
N#define IS_SMARTCARD_ADVFEATURE_DATAINV(DATAINV) (((DATAINV) == SMARTCARD_ADVFEATURE_DATAINV_DISABLE) || \
N                                             ((DATAINV) == SMARTCARD_ADVFEATURE_DATAINV_ENABLE))
X#define IS_SMARTCARD_ADVFEATURE_DATAINV(DATAINV) (((DATAINV) == SMARTCARD_ADVFEATURE_DATAINV_DISABLE) ||                                              ((DATAINV) == SMARTCARD_ADVFEATURE_DATAINV_ENABLE))
N#define IS_SMARTCARD_ADVFEATURE_SWAP(SWAP) (((SWAP) == SMARTCARD_ADVFEATURE_SWAP_DISABLE) || \
N                                       ((SWAP) == SMARTCARD_ADVFEATURE_SWAP_ENABLE))
X#define IS_SMARTCARD_ADVFEATURE_SWAP(SWAP) (((SWAP) == SMARTCARD_ADVFEATURE_SWAP_DISABLE) ||                                        ((SWAP) == SMARTCARD_ADVFEATURE_SWAP_ENABLE))
N#define IS_SMARTCARD_OVERRUN(OVERRUN)         (((OVERRUN) == SMARTCARD_ADVFEATURE_OVERRUN_ENABLE) || \
N                                          ((OVERRUN) == SMARTCARD_ADVFEATURE_OVERRUN_DISABLE))
X#define IS_SMARTCARD_OVERRUN(OVERRUN)         (((OVERRUN) == SMARTCARD_ADVFEATURE_OVERRUN_ENABLE) ||                                           ((OVERRUN) == SMARTCARD_ADVFEATURE_OVERRUN_DISABLE))
N#define IS_SMARTCARD_ADVFEATURE_DMAONRXERROR(DMA)      (((DMA) == SMARTCARD_ADVFEATURE_DMA_ENABLEONRXERROR) || \
N                                                   ((DMA) == SMARTCARD_ADVFEATURE_DMA_DISABLEONRXERROR))
X#define IS_SMARTCARD_ADVFEATURE_DMAONRXERROR(DMA)      (((DMA) == SMARTCARD_ADVFEATURE_DMA_ENABLEONRXERROR) ||                                                    ((DMA) == SMARTCARD_ADVFEATURE_DMA_DISABLEONRXERROR))
N#define IS_SMARTCARD_BAUDRATE(__BAUDRATE__) ((__BAUDRATE__) < 4500001)
N#define IS_SMARTCARD_BLOCKLENGTH(__LENGTH__) ((__LENGTH__) <= 0xFF)
N#define IS_SMARTCARD_TIMEOUT_VALUE(__TIMEOUTVALUE__)    ((__TIMEOUTVALUE__) <= 0xFFFFFF)
N#define IS_SMARTCARD_AUTORETRY_COUNT(__COUNT__)         ((__COUNT__) <= 0x7)
N#define IS_SMARTCARD_ADVFEATURE_MSBFIRST(MSBFIRST) (((MSBFIRST) == SMARTCARD_ADVFEATURE_MSBFIRST_DISABLE) || \
N                                               ((MSBFIRST) == SMARTCARD_ADVFEATURE_MSBFIRST_ENABLE))
X#define IS_SMARTCARD_ADVFEATURE_MSBFIRST(MSBFIRST) (((MSBFIRST) == SMARTCARD_ADVFEATURE_MSBFIRST_DISABLE) ||                                                ((MSBFIRST) == SMARTCARD_ADVFEATURE_MSBFIRST_ENABLE))
N#define IS_SMARTCARD_REQUEST_PARAMETER(PARAM) (((PARAM) == SMARTCARD_RXDATA_FLUSH_REQUEST) || \
N                                               ((PARAM) == SMARTCARD_TXDATA_FLUSH_REQUEST))   
X#define IS_SMARTCARD_REQUEST_PARAMETER(PARAM) (((PARAM) == SMARTCARD_RXDATA_FLUSH_REQUEST) ||                                                ((PARAM) == SMARTCARD_TXDATA_FLUSH_REQUEST))   
N
N
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup SMARTCARD_Private_Functions SMARTCARD Private Functions
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_SMARTCARD_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 391 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_SMARTCARD_MODULE_ENABLED */
N
N#ifdef HAL_WWDG_MODULE_ENABLED
N #include "stm32f7xx_hal_wwdg.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_wwdg.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_wwdg.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of WWDG HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_WWDG_H
N#define __STM32F7xx_HAL_WWDG_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup WWDG
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/** @defgroup WWDG_Exported_Types WWDG Exported Types
N  * @{
N  */
N
N/** 
N  * @brief  WWDG Init structure definition
N  */
Ntypedef struct
N{
N  uint32_t Prescaler;     /*!< Specifies the prescaler value of the WWDG.
N                               This parameter can be a value of @ref WWDG_Prescaler */
N
N  uint32_t Window;        /*!< Specifies the WWDG window value to be compared to the downcounter.
N                               This parameter must be a number Min_Data = 0x40 and Max_Data = 0x7F */
N
N  uint32_t Counter;       /*!< Specifies the WWDG free-running downcounter  value.
N                               This parameter must be a number between Min_Data = 0x40 and Max_Data = 0x7F */
N
N  uint32_t EWIMode ;      /*!< Specifies if WWDG Early Wakeup Interupt is enable or not.
N                               This parameter can be a value of @ref WWDG_EWI_Mode */
N
N}WWDG_InitTypeDef;
N
N/**
N  * @brief  WWDG handle Structure definition
N  */
Ntypedef struct
N{
N  WWDG_TypeDef                 *Instance;  /*!< Register base address    */
N
N  WWDG_InitTypeDef             Init;       /*!< WWDG required parameters */
N
N}WWDG_HandleTypeDef;
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup WWDG_Exported_Constants WWDG Exported Constants
N  * @{
N  */
N
N/** @defgroup WWDG_Interrupt_definition WWDG Interrupt definition
N  * @{
N  */
N#define WWDG_IT_EWI                         WWDG_CFR_EWI  /*!< Early wakeup interrupt */
N/**
N  * @}
N  */
N
N/** @defgroup WWDG_Flag_definition WWDG Flag definition
N  * @brief WWDG Flag definition
N  * @{
N  */
N#define WWDG_FLAG_EWIF                      WWDG_SR_EWIF  /*!< Early wakeup interrupt flag */
N/**
N  * @}
N  */
N
N/** @defgroup WWDG_Prescaler WWDG Prescaler
N  * @{
N  */
N#define WWDG_PRESCALER_1                    0x00000000U       /*!< WWDG counter clock = (PCLK1/4096)/1 */
N#define WWDG_PRESCALER_2                    WWDG_CFR_WDGTB_0  /*!< WWDG counter clock = (PCLK1/4096)/2 */
N#define WWDG_PRESCALER_4                    WWDG_CFR_WDGTB_1  /*!< WWDG counter clock = (PCLK1/4096)/4 */
N#define WWDG_PRESCALER_8                    WWDG_CFR_WDGTB    /*!< WWDG counter clock = (PCLK1/4096)/8 */
N/**
N  * @}
N  */
N
N/** @defgroup WWDG_EWI_Mode WWDG Early Wakeup Interrupt Mode
N  * @{
N  */
N#define WWDG_EWI_DISABLE                    0x00000000u       /*!< EWI Disable */
N#define WWDG_EWI_ENABLE                     WWDG_CFR_EWI      /*!< EWI Enable */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N
N/** @defgroup WWDG_Private_Macros WWDG Private Macros
N  * @{
N  */
N#define IS_WWDG_PRESCALER(__PRESCALER__)    (((__PRESCALER__) == WWDG_PRESCALER_1) || \
N                                             ((__PRESCALER__) == WWDG_PRESCALER_2) || \
N                                             ((__PRESCALER__) == WWDG_PRESCALER_4) || \
N                                             ((__PRESCALER__) == WWDG_PRESCALER_8))
X#define IS_WWDG_PRESCALER(__PRESCALER__)    (((__PRESCALER__) == WWDG_PRESCALER_1) ||                                              ((__PRESCALER__) == WWDG_PRESCALER_2) ||                                              ((__PRESCALER__) == WWDG_PRESCALER_4) ||                                              ((__PRESCALER__) == WWDG_PRESCALER_8))
N
N#define IS_WWDG_WINDOW(__WINDOW__)          (((__WINDOW__) >= WWDG_CFR_W_6) && ((__WINDOW__) <= WWDG_CFR_W))
N
N#define IS_WWDG_COUNTER(__COUNTER__)        (((__COUNTER__) >= WWDG_CR_T_6) && ((__COUNTER__) <= WWDG_CR_T))
N
N#define IS_WWDG_EWI_MODE(__MODE__)          (((__MODE__) == WWDG_EWI_ENABLE) || \
N                                             ((__MODE__) == WWDG_EWI_DISABLE))
X#define IS_WWDG_EWI_MODE(__MODE__)          (((__MODE__) == WWDG_EWI_ENABLE) ||                                              ((__MODE__) == WWDG_EWI_DISABLE))
N/**
N  * @}
N  */
N
N
N/* Exported macros ------------------------------------------------------------*/
N
N/** @defgroup WWDG_Exported_Macros WWDG Exported Macros
N  * @{
N  */
N
N/**
N  * @brief  Enable the WWDG peripheral.
N  * @param  __HANDLE__  WWDG handle
N  * @retval None
N  */
N#define __HAL_WWDG_ENABLE(__HANDLE__)                         SET_BIT((__HANDLE__)->Instance->CR, WWDG_CR_WDGA)
N
N/**
N  * @brief  Enable the WWDG early wakeup interrupt.
N  * @param  __HANDLE__: WWDG handle
N  * @param  __INTERRUPT__  specifies the interrupt to enable.
N  *         This parameter can be one of the following values:
N  *            @arg WWDG_IT_EWI: Early wakeup interrupt
N  * @note   Once enabled this interrupt cannot be disabled except by a system reset.
N  * @retval None
N  */
N#define __HAL_WWDG_ENABLE_IT(__HANDLE__, __INTERRUPT__)       SET_BIT((__HANDLE__)->Instance->CFR, (__INTERRUPT__))
N
N/**
N  * @brief  Check whether the selected WWDG interrupt has occurred or not.
N  * @param  __HANDLE__  WWDG handle
N  * @param  __INTERRUPT__  specifies the it to check.
N  *        This parameter can be one of the following values:
N  *            @arg WWDG_FLAG_EWIF: Early wakeup interrupt IT
N  * @retval The new state of WWDG_FLAG (SET or RESET).
N  */
N#define __HAL_WWDG_GET_IT(__HANDLE__, __INTERRUPT__)        __HAL_WWDG_GET_FLAG((__HANDLE__),(__INTERRUPT__))
N
N/** @brief  Clear the WWDG interrupt pending bits.
N  *         bits to clear the selected interrupt pending bits.
N  * @param  __HANDLE__  WWDG handle
N  * @param  __INTERRUPT__  specifies the interrupt pending bit to clear.
N  *         This parameter can be one of the following values:
N  *            @arg WWDG_FLAG_EWIF: Early wakeup interrupt flag
N  */
N#define __HAL_WWDG_CLEAR_IT(__HANDLE__, __INTERRUPT__)      __HAL_WWDG_CLEAR_FLAG((__HANDLE__), (__INTERRUPT__))
N
N/**
N  * @brief  Check whether the specified WWDG flag is set or not.
N  * @param  __HANDLE__  WWDG handle
N  * @param  __FLAG__  specifies the flag to check.
N  *         This parameter can be one of the following values:
N  *            @arg WWDG_FLAG_EWIF: Early wakeup interrupt flag
N  * @retval The new state of WWDG_FLAG (SET or RESET).
N  */
N#define __HAL_WWDG_GET_FLAG(__HANDLE__, __FLAG__)           (((__HANDLE__)->Instance->SR & (__FLAG__)) == (__FLAG__))
N
N/**
N  * @brief  Clear the WWDG's pending flags.
N  * @param  __HANDLE__  WWDG handle
N  * @param  __FLAG__  specifies the flag to clear.
N  *         This parameter can be one of the following values:
N  *            @arg WWDG_FLAG_EWIF: Early wakeup interrupt flag
N  * @retval None
N  */
N#define __HAL_WWDG_CLEAR_FLAG(__HANDLE__, __FLAG__)         ((__HANDLE__)->Instance->SR = ~(__FLAG__))
N
N/** @brief  Check whether the specified WWDG interrupt source is enabled or not.
N  * @param  __HANDLE__  WWDG Handle.
N  * @param  __INTERRUPT__  specifies the WWDG interrupt source to check.
N  *         This parameter can be one of the following values:
N  *            @arg WWDG_IT_EWI: Early Wakeup Interrupt
N  * @retval state of __INTERRUPT__ (TRUE or FALSE).
N  */
N#define __HAL_WWDG_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) (((__HANDLE__)->Instance->CFR & (__INTERRUPT__)) == (__INTERRUPT__))
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N
N/** @addtogroup WWDG_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup WWDG_Exported_Functions_Group1
N  * @{
N  */
N/* Initialization/de-initialization functions  **********************************/
NHAL_StatusTypeDef     HAL_WWDG_Init(WWDG_HandleTypeDef *hwwdg);
Nvoid                  HAL_WWDG_MspInit(WWDG_HandleTypeDef *hwwdg);
N/**
N  * @}
N  */
N
N/** @addtogroup WWDG_Exported_Functions_Group2
N  * @{
N  */
N/* I/O operation functions ******************************************************/
NHAL_StatusTypeDef     HAL_WWDG_Refresh(WWDG_HandleTypeDef *hwwdg);
Nvoid                  HAL_WWDG_IRQHandler(WWDG_HandleTypeDef *hwwdg);
Nvoid                  HAL_WWDG_EarlyWakeupCallback(WWDG_HandleTypeDef* hwwdg);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_WWDG_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 395 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_WWDG_MODULE_ENABLED */
N
N#ifdef HAL_PCD_MODULE_ENABLED
N #include "stm32f7xx_hal_pcd.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_pcd.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_pcd.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of PCD HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_PCD_H
N#define __STM32F7xx_HAL_PCD_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_ll_usb.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_ll_usb.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_ll_usb.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of USB Core HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_LL_USB_H
N#define __STM32F7xx_LL_USB_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL
N  * @{
N  */
N
N/** @addtogroup USB_Core
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/ 
N
N/** 
N  * @brief  USB Mode definition  
N  */  
Ntypedef enum 
N{
N   USB_OTG_DEVICE_MODE  = 0U,
N   USB_OTG_HOST_MODE    = 1U,
N   USB_OTG_DRD_MODE     = 2U
N   
N}USB_OTG_ModeTypeDef;
N
N/** 
N  * @brief  URB States definition  
N  */ 
Ntypedef enum {
N  URB_IDLE = 0U,
N  URB_DONE,
N  URB_NOTREADY,
N  URB_NYET,
N  URB_ERROR,
N  URB_STALL
N    
N}USB_OTG_URBStateTypeDef;
N
N/** 
N  * @brief  Host channel States  definition  
N  */ 
Ntypedef enum {
N  HC_IDLE = 0U,
N  HC_XFRC,
N  HC_HALTED,
N  HC_NAK,
N  HC_NYET,
N  HC_STALL,
N  HC_XACTERR,  
N  HC_BBLERR,   
N  HC_DATATGLERR
N    
N}USB_OTG_HCStateTypeDef;
N
N/** 
N  * @brief  PCD Initialization Structure definition  
N  */
Ntypedef struct
N{
N  uint32_t dev_endpoints;        /*!< Device Endpoints number.
N                                      This parameter depends on the used USB core.   
N                                      This parameter must be a number between Min_Data = 1 and Max_Data = 15 */    
N  
N  uint32_t Host_channels;        /*!< Host Channels number.
N                                      This parameter Depends on the used USB core.   
N                                      This parameter must be a number between Min_Data = 1 and Max_Data = 15 */       
N
N  uint32_t speed;                /*!< USB Core speed.
N                                      This parameter can be any value of @ref USB_Core_Speed_                */        
N                               
N  uint32_t dma_enable;           /*!< Enable or disable of the USB embedded DMA.                             */            
N
N  uint32_t ep0_mps;              /*!< Set the Endpoint 0 Max Packet size. 
N                                      This parameter can be any value of @ref USB_EP0_MPS_                   */              
N                       
N  uint32_t phy_itface;           /*!< Select the used PHY interface.
N                                      This parameter can be any value of @ref USB_Core_PHY_                  */ 
N                                
N  uint32_t Sof_enable;           /*!< Enable or disable the output of the SOF signal.                        */     
N                               
N  uint32_t low_power_enable;     /*!< Enable or disable the low power mode.                                  */
N  
N  uint32_t lpm_enable;           /*!< Enable or disable Link Power Management.                               */
N                          
N  uint32_t vbus_sensing_enable;  /*!< Enable or disable the VBUS Sensing feature.                            */ 
N
N  uint32_t use_dedicated_ep1;    /*!< Enable or disable the use of the dedicated EP1 interrupt.              */      
N  
N  uint32_t use_external_vbus;    /*!< Enable or disable the use of the external VBUS.                        */   
N  
N}USB_OTG_CfgTypeDef;
N
Ntypedef struct
N{
N  uint8_t   num;            /*!< Endpoint number
N                                This parameter must be a number between Min_Data = 1 and Max_Data = 15    */ 
N                                
N  uint8_t   is_in;          /*!< Endpoint direction
N                                This parameter must be a number between Min_Data = 0 and Max_Data = 1     */ 
N  
N  uint8_t   is_stall;       /*!< Endpoint stall condition
N                                This parameter must be a number between Min_Data = 0 and Max_Data = 1     */ 
N  
N  uint8_t   type;           /*!< Endpoint type
N                                 This parameter can be any value of @ref USB_EP_Type_                     */ 
N                                
N  uint8_t   data_pid_start; /*!< Initial data PID
N                                This parameter must be a number between Min_Data = 0 and Max_Data = 1     */
N                                
N  uint8_t   even_odd_frame; /*!< IFrame parity
N                                 This parameter must be a number between Min_Data = 0 and Max_Data = 1    */
N                                
N  uint16_t  tx_fifo_num;    /*!< Transmission FIFO number
N                                 This parameter must be a number between Min_Data = 1 and Max_Data = 15   */
N                                
N  uint32_t  maxpacket;      /*!< Endpoint Max packet size
N                                 This parameter must be a number between Min_Data = 0 and Max_Data = 64KB */
N
N  uint8_t   *xfer_buff;     /*!< Pointer to transfer buffer                                               */
N                                
N  uint32_t  dma_addr;       /*!< 32 bits aligned transfer buffer address                                  */
N  
N  uint32_t  xfer_len;       /*!< Current transfer length                                                  */
N  
N  uint32_t  xfer_count;     /*!< Partial transfer length in case of multi packet transfer                 */
N
N}USB_OTG_EPTypeDef;
N
Ntypedef struct
N{
N  uint8_t   dev_addr ;     /*!< USB device address.
N                                This parameter must be a number between Min_Data = 1 and Max_Data = 255    */ 
N
N  uint8_t   ch_num;        /*!< Host channel number.
N                                This parameter must be a number between Min_Data = 1 and Max_Data = 15     */ 
N                                
N  uint8_t   ep_num;        /*!< Endpoint number.
N                                This parameter must be a number between Min_Data = 1 and Max_Data = 15     */ 
N                                
N  uint8_t   ep_is_in;      /*!< Endpoint direction
N                                This parameter must be a number between Min_Data = 0 and Max_Data = 1      */ 
N                                
N  uint8_t   speed;         /*!< USB Host speed.
N                                This parameter can be any value of @ref USB_Core_Speed_                    */
N                                
N  uint8_t   do_ping;       /*!< Enable or disable the use of the PING protocol for HS mode.                */
N  
N  uint8_t   process_ping;  /*!< Execute the PING protocol for HS mode.                                     */
N
N  uint8_t   ep_type;       /*!< Endpoint Type.
N                                This parameter can be any value of @ref USB_EP_Type_                       */
N                                
N  uint16_t  max_packet;    /*!< Endpoint Max packet size.
N                                This parameter must be a number between Min_Data = 0 and Max_Data = 64KB   */
N                                
N  uint8_t   data_pid;      /*!< Initial data PID.
N                                This parameter must be a number between Min_Data = 0 and Max_Data = 1      */
N                                
N  uint8_t   *xfer_buff;    /*!< Pointer to transfer buffer.                                                */
N  
N  uint32_t  xfer_len;      /*!< Current transfer length.                                                   */
N  
N  uint32_t  xfer_count;    /*!< Partial transfer length in case of multi packet transfer.                  */
N  
N  uint8_t   toggle_in;     /*!< IN transfer current toggle flag.
N                                This parameter must be a number between Min_Data = 0 and Max_Data = 1      */
N                                
N  uint8_t   toggle_out;    /*!< OUT transfer current toggle flag
N                                This parameter must be a number between Min_Data = 0 and Max_Data = 1      */
N  
N  uint32_t  dma_addr;      /*!< 32 bits aligned transfer buffer address.                                   */
N  
N  uint32_t  ErrCnt;        /*!< Host channel error count.*/
N  
N  USB_OTG_URBStateTypeDef  urb_state;  /*!< URB state. 
N                                           This parameter can be any value of @ref USB_OTG_URBStateTypeDef */ 
N  
N  USB_OTG_HCStateTypeDef   state;     /*!< Host Channel state. 
N                                           This parameter can be any value of @ref USB_OTG_HCStateTypeDef  */ 
N                                             
N}USB_OTG_HCTypeDef;
N  
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup PCD_Exported_Constants PCD Exported Constants
N  * @{
N  */
N
N/** @defgroup USB_Core_Mode_ USB Core Mode
N  * @{
N  */
N#define USB_OTG_MODE_DEVICE                    0U
N#define USB_OTG_MODE_HOST                      1U
N#define USB_OTG_MODE_DRD                       2U
N/**
N  * @}
N  */
N
N/** @defgroup USB_Core_Speed_   USB Core Speed
N  * @{
N  */  
N#define USB_OTG_SPEED_HIGH                     0U
N#define USB_OTG_SPEED_HIGH_IN_FULL             1U
N#define USB_OTG_SPEED_LOW                      2U  
N#define USB_OTG_SPEED_FULL                     3U
N/**
N  * @}
N  */
N  
N/** @defgroup USB_Core_PHY_   USB Core PHY
N  * @{
N  */   
N#define USB_OTG_ULPI_PHY                       1U
N#define USB_OTG_EMBEDDED_PHY                   2U
N/**
N  * @}
N  */
N  
N/** @defgroup USB_Core_MPS_   USB Core MPS
N  * @{
N  */
N#define USB_OTG_HS_MAX_PACKET_SIZE           512U
N#define USB_OTG_FS_MAX_PACKET_SIZE           64U
N#define USB_OTG_MAX_EP0_SIZE                 64U
N/**
N  * @}
N  */
N
N/** @defgroup USB_Core_Phy_Frequency_   USB Core Phy Frequency
N  * @{
N  */
N#define DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ     (0 << 1)
N#define DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ     (1 << 1)
N#define DSTS_ENUMSPD_LS_PHY_6MHZ               (2 << 1)
N#define DSTS_ENUMSPD_FS_PHY_48MHZ              (3 << 1)
N/**
N  * @}
N  */
N  
N/** @defgroup USB_CORE_Frame_Interval_   USB CORE Frame Interval
N  * @{
N  */  
N#define DCFG_FRAME_INTERVAL_80                 0U
N#define DCFG_FRAME_INTERVAL_85                 1U
N#define DCFG_FRAME_INTERVAL_90                 2U
N#define DCFG_FRAME_INTERVAL_95                 3U
N/**
N  * @}
N  */
N
N/** @defgroup USB_EP0_MPS_  USB EP0 MPS
N  * @{
N  */
N#define DEP0CTL_MPS_64                         0U
N#define DEP0CTL_MPS_32                         1U
N#define DEP0CTL_MPS_16                         2U
N#define DEP0CTL_MPS_8                          3U
N/**
N  * @}
N  */
N
N/** @defgroup USB_EP_Speed_  USB EP Speed
N  * @{
N  */
N#define EP_SPEED_LOW                           0U
N#define EP_SPEED_FULL                          1U
N#define EP_SPEED_HIGH                          2U
N/**
N  * @}
N  */
N
N/** @defgroup USB_EP_Type_  USB EP Type
N  * @{
N  */
N#define EP_TYPE_CTRL                           0U
N#define EP_TYPE_ISOC                           1U
N#define EP_TYPE_BULK                           2U
N#define EP_TYPE_INTR                           3U
N#define EP_TYPE_MSK                            3U
N/**
N  * @}
N  */
N
N/** @defgroup USB_STS_Defines_   USB STS Defines
N  * @{
N  */
N#define STS_GOUT_NAK                           1U
N#define STS_DATA_UPDT                          2U
N#define STS_XFER_COMP                          3U
N#define STS_SETUP_COMP                         4U
N#define STS_SETUP_UPDT                         6U
N/**
N  * @}
N  */
N
N/** @defgroup HCFG_SPEED_Defines_   HCFG SPEED Defines
N  * @{
N  */  
N#define HCFG_30_60_MHZ                         0U
N#define HCFG_48_MHZ                            1U
N#define HCFG_6_MHZ                             2U
N/**
N  * @}
N  */
N    
N/** @defgroup HPRT0_PRTSPD_SPEED_Defines_  HPRT0 PRTSPD SPEED Defines
N  * @{
N  */    
N#define HPRT0_PRTSPD_HIGH_SPEED                0U
N#define HPRT0_PRTSPD_FULL_SPEED                1U
N#define HPRT0_PRTSPD_LOW_SPEED                 2U
N/**
N  * @}
N  */  
N   
N#define HCCHAR_CTRL                            0U
N#define HCCHAR_ISOC                            1U
N#define HCCHAR_BULK                            2U
N#define HCCHAR_INTR                            3U
N       
N#define HC_PID_DATA0                           0U
N#define HC_PID_DATA2                           1U
N#define HC_PID_DATA1                           2U
N#define HC_PID_SETUP                           3U
N
N#define GRXSTS_PKTSTS_IN                       2U
N#define GRXSTS_PKTSTS_IN_XFER_COMP             3U
N#define GRXSTS_PKTSTS_DATA_TOGGLE_ERR          5U
N#define GRXSTS_PKTSTS_CH_HALTED                7U
N    
N#define USBx_PCGCCTL    *(__IO uint32_t *)((uint32_t)USBx + USB_OTG_PCGCCTL_BASE)
N#define USBx_HPRT0      *(__IO uint32_t *)((uint32_t)USBx + USB_OTG_HOST_PORT_BASE)
N
N#define USBx_DEVICE     ((USB_OTG_DeviceTypeDef *)((uint32_t )USBx + USB_OTG_DEVICE_BASE)) 
N#define USBx_INEP(i)    ((USB_OTG_INEndpointTypeDef *)((uint32_t)USBx + USB_OTG_IN_ENDPOINT_BASE + (i)*USB_OTG_EP_REG_SIZE))        
N#define USBx_OUTEP(i)   ((USB_OTG_OUTEndpointTypeDef *)((uint32_t)USBx + USB_OTG_OUT_ENDPOINT_BASE + (i)*USB_OTG_EP_REG_SIZE))        
N#define USBx_DFIFO(i)   *(__IO uint32_t *)((uint32_t)USBx + USB_OTG_FIFO_BASE + (i) * USB_OTG_FIFO_SIZE)
N
N#define USBx_HOST       ((USB_OTG_HostTypeDef *)((uint32_t )USBx + USB_OTG_HOST_BASE))  
N#define USBx_HC(i)      ((USB_OTG_HostChannelTypeDef *)((uint32_t)USBx + USB_OTG_HOST_CHANNEL_BASE + (i)*USB_OTG_HOST_CHANNEL_SIZE))
N/**
N  * @}
N  */
N/* Exported macro ------------------------------------------------------------*/
N#define USB_MASK_INTERRUPT(__INSTANCE__, __INTERRUPT__)     ((__INSTANCE__)->GINTMSK &= ~(__INTERRUPT__))
N#define USB_UNMASK_INTERRUPT(__INSTANCE__, __INTERRUPT__)   ((__INSTANCE__)->GINTMSK |= (__INTERRUPT__))
N    
N#define CLEAR_IN_EP_INTR(__EPNUM__, __INTERRUPT__)          (USBx_INEP(__EPNUM__)->DIEPINT = (__INTERRUPT__))
N#define CLEAR_OUT_EP_INTR(__EPNUM__, __INTERRUPT__)         (USBx_OUTEP(__EPNUM__)->DOEPINT = (__INTERRUPT__))  
N
N/* Exported functions --------------------------------------------------------*/
NHAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef Init);
NHAL_StatusTypeDef USB_DevInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef Init);
NHAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx);
NHAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx);
NHAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode);
NHAL_StatusTypeDef USB_SetDevSpeed(USB_OTG_GlobalTypeDef *USBx , uint8_t speed);
NHAL_StatusTypeDef USB_FlushRxFifo (USB_OTG_GlobalTypeDef *USBx);
NHAL_StatusTypeDef USB_FlushTxFifo (USB_OTG_GlobalTypeDef *USBx, uint32_t num );
NHAL_StatusTypeDef USB_ActivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep);
NHAL_StatusTypeDef USB_DeactivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep);
NHAL_StatusTypeDef USB_ActivateDedicatedEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep);
NHAL_StatusTypeDef USB_DeactivateDedicatedEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep);
NHAL_StatusTypeDef USB_EPStartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma);
NHAL_StatusTypeDef USB_EP0StartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma);
NHAL_StatusTypeDef USB_WritePacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *src, uint8_t ch_ep_num, uint16_t len, uint8_t dma);
Nvoid *            USB_ReadPacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len);
NHAL_StatusTypeDef USB_EPSetStall(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep);
NHAL_StatusTypeDef USB_EPClearStall(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep);
NHAL_StatusTypeDef USB_SetDevAddress (USB_OTG_GlobalTypeDef *USBx, uint8_t address);
NHAL_StatusTypeDef USB_DevConnect (USB_OTG_GlobalTypeDef *USBx);
NHAL_StatusTypeDef USB_DevDisconnect (USB_OTG_GlobalTypeDef *USBx);
NHAL_StatusTypeDef USB_StopDevice(USB_OTG_GlobalTypeDef *USBx);
NHAL_StatusTypeDef USB_ActivateSetup (USB_OTG_GlobalTypeDef *USBx);
NHAL_StatusTypeDef USB_EP0_OutStart(USB_OTG_GlobalTypeDef *USBx, uint8_t dma, uint8_t *psetup);
Nuint8_t           USB_GetDevSpeed(USB_OTG_GlobalTypeDef *USBx);
Nuint32_t          USB_GetMode(USB_OTG_GlobalTypeDef *USBx);
Nuint32_t          USB_ReadInterrupts (USB_OTG_GlobalTypeDef *USBx);
Nuint32_t          USB_ReadDevAllOutEpInterrupt (USB_OTG_GlobalTypeDef *USBx);
Nuint32_t          USB_ReadDevOutEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum);
Nuint32_t          USB_ReadDevAllInEpInterrupt (USB_OTG_GlobalTypeDef *USBx);
Nuint32_t          USB_ReadDevInEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum);
Nvoid              USB_ClearInterrupts (USB_OTG_GlobalTypeDef *USBx, uint32_t interrupt);
N
NHAL_StatusTypeDef USB_HostInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg);
NHAL_StatusTypeDef USB_InitFSLSPClkSel(USB_OTG_GlobalTypeDef *USBx , uint8_t freq);
NHAL_StatusTypeDef USB_ResetPort(USB_OTG_GlobalTypeDef *USBx);
NHAL_StatusTypeDef USB_DriveVbus (USB_OTG_GlobalTypeDef *USBx, uint8_t state);
Nuint32_t          USB_GetHostSpeed (USB_OTG_GlobalTypeDef *USBx);
Nuint32_t          USB_GetCurrentFrame (USB_OTG_GlobalTypeDef *USBx);
NHAL_StatusTypeDef USB_HC_Init(USB_OTG_GlobalTypeDef *USBx,  
N                                  uint8_t ch_num,
N                                  uint8_t epnum,
N                                  uint8_t dev_address,
N                                  uint8_t speed,
N                                  uint8_t ep_type,
N                                  uint16_t mps);
NHAL_StatusTypeDef USB_HC_StartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_HCTypeDef *hc, uint8_t dma);
Nuint32_t          USB_HC_ReadInterrupt (USB_OTG_GlobalTypeDef *USBx);
NHAL_StatusTypeDef USB_HC_Halt(USB_OTG_GlobalTypeDef *USBx , uint8_t hc_num);
NHAL_StatusTypeDef USB_DoPing(USB_OTG_GlobalTypeDef *USBx , uint8_t ch_num);
NHAL_StatusTypeDef USB_StopHost(USB_OTG_GlobalTypeDef *USBx);
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N  
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif /* __STM32F7xx_LL_USB_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 48 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_pcd.h" 2
N   
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup PCD
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/ 
N/** @defgroup PCD_Exported_Types PCD Exported Types
N  * @{
N  */
N   
N/**
N  * @brief  PCD State structure definition
N  */ 
Ntypedef enum 
N{
N  HAL_PCD_STATE_RESET   = 0x00U,
N  HAL_PCD_STATE_READY   = 0x01U,
N  HAL_PCD_STATE_ERROR   = 0x02U,
N  HAL_PCD_STATE_BUSY    = 0x03U,
N  HAL_PCD_STATE_TIMEOUT = 0x04U
N} PCD_StateTypeDef;
N
N/* Device LPM suspend state */
Ntypedef enum  
N{
N  LPM_L0 = 0x00U, /* on */
N  LPM_L1 = 0x01U, /* LPM L1 sleep */
N  LPM_L2 = 0x02U, /* suspend */
N  LPM_L3 = 0x03U, /* off */
N}PCD_LPM_StateTypeDef;
N
Ntypedef USB_OTG_GlobalTypeDef  PCD_TypeDef;
Ntypedef USB_OTG_CfgTypeDef     PCD_InitTypeDef;
Ntypedef USB_OTG_EPTypeDef      PCD_EPTypeDef ;                          
N
N/** 
N  * @brief  PCD Handle Structure definition  
N  */ 
Ntypedef struct
N{
N  PCD_TypeDef             *Instance;   /*!< Register base address              */ 
N  PCD_InitTypeDef         Init;       /*!< PCD required parameters            */
N  PCD_EPTypeDef           IN_ep[15];  /*!< IN endpoint parameters             */
N  PCD_EPTypeDef           OUT_ep[15]; /*!< OUT endpoint parameters            */ 
N  HAL_LockTypeDef         Lock;       /*!< PCD peripheral status              */
N  __IO PCD_StateTypeDef   State;      /*!< PCD communication state            */
X  volatile PCD_StateTypeDef   State;       
N  uint32_t                Setup[12];  /*!< Setup packet buffer                */
N  PCD_LPM_StateTypeDef    LPM_State;    /*!< LPM State                          */
N  uint32_t                BESL;
N  uint32_t                lpm_active;   /*!< Enable or disable the Link Power Management .                                  
N                                        This parameter can be set to ENABLE or DISABLE */
N  void                    *pData;       /*!< Pointer to upper stack Handler */  
N} PCD_HandleTypeDef;
N
N/**
N  * @}
N  */
N    
N/* Include PCD HAL Extension module */
N#include "stm32f7xx_hal_pcd_ex.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_pcd_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_pcd_ex.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of PCD HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_PCD_EX_H
N#define __STM32F7xx_HAL_PCD_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N   
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup PCDEx
N  * @{
N  */
N/* Exported types ------------------------------------------------------------*/
Ntypedef enum  
N{
N  PCD_LPM_L0_ACTIVE = 0x00U, /* on */
N  PCD_LPM_L1_ACTIVE = 0x01U, /* LPM L1 sleep */
N}PCD_LPM_MsgTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N/* Exported macros -----------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup PCDEx_Exported_Functions PCDEx Exported Functions
N  * @{
N  */
N/** @addtogroup PCDEx_Exported_Functions_Group1 Peripheral Control functions
N  * @{
N  */
NHAL_StatusTypeDef HAL_PCDEx_SetTxFiFo(PCD_HandleTypeDef *hpcd, uint8_t fifo, uint16_t size);
NHAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size);
NHAL_StatusTypeDef HAL_PCDEx_ActivateLPM(PCD_HandleTypeDef *hpcd);
NHAL_StatusTypeDef HAL_PCDEx_DeActivateLPM(PCD_HandleTypeDef *hpcd);
Nvoid HAL_PCDEx_LPM_Callback(PCD_HandleTypeDef *hpcd, PCD_LPM_MsgTypeDef msg);
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif /* __STM32F7xx_HAL_PCD_EX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 112 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_pcd.h" 2
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup PCD_Exported_Constants PCD Exported Constants
N  * @{
N  */
N
N/** @defgroup PCD_Speed PCD Speed
N  * @{
N  */
N#define PCD_SPEED_HIGH               0U
N#define PCD_SPEED_HIGH_IN_FULL       1U
N#define PCD_SPEED_FULL               2U
N/**
N  * @}
N  */
N  
N/** @defgroup PCD_PHY_Module PCD PHY Module
N  * @{
N  */
N#define PCD_PHY_ULPI                 1U
N#define PCD_PHY_EMBEDDED             2U
N/**
N  * @}
N  */
N
N/** @defgroup PCD_Turnaround_Timeout Turnaround Timeout Value
N  * @{
N  */
N#ifndef USBD_HS_TRDT_VALUE
N #define USBD_HS_TRDT_VALUE           9U
N#endif /* USBD_HS_TRDT_VALUE */
N#ifndef USBD_FS_TRDT_VALUE
N #define USBD_FS_TRDT_VALUE           5U
N#endif /* USBD_HS_TRDT_VALUE */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N  
N/* Exported macros -----------------------------------------------------------*/
N/** @defgroup PCD_Exported_Macros PCD Exported Macros
N *  @brief macros to handle interrupts and specific clock configurations
N * @{
N */
N#define __HAL_PCD_ENABLE(__HANDLE__)                   USB_EnableGlobalInt ((__HANDLE__)->Instance)
N#define __HAL_PCD_DISABLE(__HANDLE__)                  USB_DisableGlobalInt ((__HANDLE__)->Instance)
N   
N#define __HAL_PCD_GET_FLAG(__HANDLE__, __INTERRUPT__)      ((USB_ReadInterrupts((__HANDLE__)->Instance) & (__INTERRUPT__)) == (__INTERRUPT__))
N#define __HAL_PCD_CLEAR_FLAG(__HANDLE__, __INTERRUPT__)    (((__HANDLE__)->Instance->GINTSTS) = (__INTERRUPT__))
N#define __HAL_PCD_IS_INVALID_INTERRUPT(__HANDLE__)         (USB_ReadInterrupts((__HANDLE__)->Instance) == 0)
N
N
N#define __HAL_PCD_UNGATE_PHYCLOCK(__HANDLE__)             *(__IO uint32_t *)((uint32_t)((__HANDLE__)->Instance) + USB_OTG_PCGCCTL_BASE) &= \
N                                                       ~(USB_OTG_PCGCCTL_STOPCLK)
X#define __HAL_PCD_UNGATE_PHYCLOCK(__HANDLE__)             *(__IO uint32_t *)((uint32_t)((__HANDLE__)->Instance) + USB_OTG_PCGCCTL_BASE) &=                                                        ~(USB_OTG_PCGCCTL_STOPCLK)
N
N#define __HAL_PCD_GATE_PHYCLOCK(__HANDLE__)               *(__IO uint32_t *)((uint32_t)((__HANDLE__)->Instance) + USB_OTG_PCGCCTL_BASE) |= USB_OTG_PCGCCTL_STOPCLK
N                                                      
N#define __HAL_PCD_IS_PHY_SUSPENDED(__HANDLE__)            ((*(__IO uint32_t *)((uint32_t)((__HANDLE__)->Instance) + USB_OTG_PCGCCTL_BASE))&0x10)
N                                                         
N#define USB_OTG_FS_WAKEUP_EXTI_RISING_EDGE                ((uint32_t)0x08U) 
N#define USB_OTG_FS_WAKEUP_EXTI_FALLING_EDGE               ((uint32_t)0x0CU) 
N#define USB_OTG_FS_WAKEUP_EXTI_RISING_FALLING_EDGE        ((uint32_t)0x10U) 
N
N#define USB_OTG_HS_WAKEUP_EXTI_RISING_EDGE                ((uint32_t)0x08U) 
N#define USB_OTG_HS_WAKEUP_EXTI_FALLING_EDGE               ((uint32_t)0x0CU) 
N#define USB_OTG_HS_WAKEUP_EXTI_RISING_FALLING_EDGE        ((uint32_t)0x10U) 
N
N#define USB_OTG_HS_WAKEUP_EXTI_LINE                       ((uint32_t)0x00100000U)  /*!< External interrupt line 20 Connected to the USB HS EXTI Line */
N#define USB_OTG_FS_WAKEUP_EXTI_LINE                       ((uint32_t)0x00040000U)  /*!< External interrupt line 18 Connected to the USB FS EXTI Line */
N
N#define __HAL_USB_OTG_HS_WAKEUP_EXTI_ENABLE_IT()    EXTI->IMR |= (USB_OTG_HS_WAKEUP_EXTI_LINE)
N#define __HAL_USB_OTG_HS_WAKEUP_EXTI_DISABLE_IT()   EXTI->IMR &= ~(USB_OTG_HS_WAKEUP_EXTI_LINE)
N#define __HAL_USB_OTG_HS_WAKEUP_EXTI_GET_FLAG()     EXTI->PR & (USB_OTG_HS_WAKEUP_EXTI_LINE)
N#define __HAL_USB_OTG_HS_WAKEUP_EXTI_CLEAR_FLAG()   EXTI->PR = (USB_OTG_HS_WAKEUP_EXTI_LINE)
N
N#define __HAL_USB_OTG_HS_WAKEUP_EXTI_ENABLE_RISING_EDGE() EXTI->FTSR &= ~(USB_OTG_HS_WAKEUP_EXTI_LINE);\
N                                                          EXTI->RTSR |= USB_OTG_HS_WAKEUP_EXTI_LINE
X#define __HAL_USB_OTG_HS_WAKEUP_EXTI_ENABLE_RISING_EDGE() EXTI->FTSR &= ~(USB_OTG_HS_WAKEUP_EXTI_LINE);                                                          EXTI->RTSR |= USB_OTG_HS_WAKEUP_EXTI_LINE
N                                                      
N#define __HAL_USB_OTG_HS_WAKEUP_EXTI_ENABLE_FALLING_EDGE()  EXTI->FTSR |= (USB_OTG_HS_WAKEUP_EXTI_LINE);\
N                                                            EXTI->RTSR &= ~(USB_OTG_HS_WAKEUP_EXTI_LINE)
X#define __HAL_USB_OTG_HS_WAKEUP_EXTI_ENABLE_FALLING_EDGE()  EXTI->FTSR |= (USB_OTG_HS_WAKEUP_EXTI_LINE);                                                            EXTI->RTSR &= ~(USB_OTG_HS_WAKEUP_EXTI_LINE)
N
N#define __HAL_USB_OTG_HS_WAKEUP_EXTI_ENABLE_RISING_FALLING_EDGE()   EXTI->RTSR &= ~(USB_OTG_HS_WAKEUP_EXTI_LINE);\
N                                                                    EXTI->FTSR &= ~(USB_OTG_HS_WAKEUP_EXTI_LINE;)\
N                                                                    EXTI->RTSR |= USB_OTG_HS_WAKEUP_EXTI_LINE;\
N                                                                    EXTI->FTSR |= USB_OTG_HS_WAKEUP_EXTI_LINE
X#define __HAL_USB_OTG_HS_WAKEUP_EXTI_ENABLE_RISING_FALLING_EDGE()   EXTI->RTSR &= ~(USB_OTG_HS_WAKEUP_EXTI_LINE);                                                                    EXTI->FTSR &= ~(USB_OTG_HS_WAKEUP_EXTI_LINE;)                                                                    EXTI->RTSR |= USB_OTG_HS_WAKEUP_EXTI_LINE;                                                                    EXTI->FTSR |= USB_OTG_HS_WAKEUP_EXTI_LINE
N
N#define __HAL_USB_OTG_HS_WAKEUP_EXTI_GENERATE_SWIT()   (EXTI->SWIER |= USB_OTG_FS_WAKEUP_EXTI_LINE) 
N                                                                                                                    
N#define __HAL_USB_OTG_FS_WAKEUP_EXTI_ENABLE_IT()    EXTI->IMR |= USB_OTG_FS_WAKEUP_EXTI_LINE
N#define __HAL_USB_OTG_FS_WAKEUP_EXTI_DISABLE_IT()   EXTI->IMR &= ~(USB_OTG_FS_WAKEUP_EXTI_LINE)
N#define __HAL_USB_OTG_FS_WAKEUP_EXTI_GET_FLAG()     EXTI->PR & (USB_OTG_FS_WAKEUP_EXTI_LINE)
N#define __HAL_USB_OTG_FS_WAKEUP_EXTI_CLEAR_FLAG()   EXTI->PR = USB_OTG_FS_WAKEUP_EXTI_LINE
N
N#define __HAL_USB_OTG_FS_WAKEUP_EXTI_ENABLE_RISING_EDGE() EXTI->FTSR &= ~(USB_OTG_FS_WAKEUP_EXTI_LINE);\
N                                                          EXTI->RTSR |= USB_OTG_FS_WAKEUP_EXTI_LINE
X#define __HAL_USB_OTG_FS_WAKEUP_EXTI_ENABLE_RISING_EDGE() EXTI->FTSR &= ~(USB_OTG_FS_WAKEUP_EXTI_LINE);                                                          EXTI->RTSR |= USB_OTG_FS_WAKEUP_EXTI_LINE
N
N                                                      
N#define __HAL_USB_OTG_FS_WAKEUP_EXTI_ENABLE_FALLING_EDGE()  EXTI->FTSR |= (USB_OTG_FS_WAKEUP_EXTI_LINE);\
N                                                            EXTI->RTSR &= ~(USB_OTG_FS_WAKEUP_EXTI_LINE)
X#define __HAL_USB_OTG_FS_WAKEUP_EXTI_ENABLE_FALLING_EDGE()  EXTI->FTSR |= (USB_OTG_FS_WAKEUP_EXTI_LINE);                                                            EXTI->RTSR &= ~(USB_OTG_FS_WAKEUP_EXTI_LINE)
N
N#define __HAL_USB_OTG_FS_WAKEUP_EXTI_ENABLE_RISING_FALLING_EDGE()  EXTI->RTSR &= ~(USB_OTG_FS_WAKEUP_EXTI_LINE);\
N                                                                   EXTI->FTSR &= ~(USB_OTG_FS_WAKEUP_EXTI_LINE);\
N                                                                   EXTI->RTSR |= USB_OTG_FS_WAKEUP_EXTI_LINE;\
N                                                                   EXTI->FTSR |= USB_OTG_FS_WAKEUP_EXTI_LINE 
X#define __HAL_USB_OTG_FS_WAKEUP_EXTI_ENABLE_RISING_FALLING_EDGE()  EXTI->RTSR &= ~(USB_OTG_FS_WAKEUP_EXTI_LINE);                                                                   EXTI->FTSR &= ~(USB_OTG_FS_WAKEUP_EXTI_LINE);                                                                   EXTI->RTSR |= USB_OTG_FS_WAKEUP_EXTI_LINE;                                                                   EXTI->FTSR |= USB_OTG_FS_WAKEUP_EXTI_LINE 
N                                                         
N#define __HAL_USB_OTG_FS_WAKEUP_EXTI_GENERATE_SWIT()  (EXTI->SWIER |= USB_OTG_FS_WAKEUP_EXTI_LINE)                                                     
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup PCD_Exported_Functions PCD Exported Functions
N  * @{
N  */
N
N/* Initialization/de-initialization functions  ********************************/
N/** @addtogroup PCD_Exported_Functions_Group1 Initialization and de-initialization functions
N  * @{
N  */
NHAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd);
NHAL_StatusTypeDef HAL_PCD_DeInit (PCD_HandleTypeDef *hpcd);
Nvoid HAL_PCD_MspInit(PCD_HandleTypeDef *hpcd);
Nvoid HAL_PCD_MspDeInit(PCD_HandleTypeDef *hpcd);
N/**
N  * @}
N  */
N
N/* I/O operation functions  ***************************************************/
N/* Non-Blocking mode: Interrupt */
N/** @addtogroup PCD_Exported_Functions_Group2 Input and Output operation functions
N  * @{
N  */
NHAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd);
NHAL_StatusTypeDef HAL_PCD_Stop(PCD_HandleTypeDef *hpcd);
Nvoid HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd);
N
Nvoid HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum);
Nvoid HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum);
Nvoid HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd);
Nvoid HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd);
Nvoid HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd);
Nvoid HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd);
Nvoid HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd);
Nvoid HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum);
Nvoid HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum);
Nvoid HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd);
Nvoid HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd);
N/**
N  * @}
N  */
N
N/* Peripheral Control functions  **********************************************/
N/** @addtogroup PCD_Exported_Functions_Group3 Peripheral Control functions
N  * @{
N  */
NHAL_StatusTypeDef HAL_PCD_DevConnect(PCD_HandleTypeDef *hpcd);
NHAL_StatusTypeDef HAL_PCD_DevDisconnect(PCD_HandleTypeDef *hpcd);
NHAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address);
NHAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint16_t ep_mps, uint8_t ep_type);
NHAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr);
NHAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len);
NHAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len);
Nuint16_t          HAL_PCD_EP_GetRxCount(PCD_HandleTypeDef *hpcd, uint8_t ep_addr);
NHAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr);
NHAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr);
NHAL_StatusTypeDef HAL_PCD_EP_Flush(PCD_HandleTypeDef *hpcd, uint8_t ep_addr);
NHAL_StatusTypeDef HAL_PCD_ActivateRemoteWakeup(PCD_HandleTypeDef *hpcd);
NHAL_StatusTypeDef HAL_PCD_DeActivateRemoteWakeup(PCD_HandleTypeDef *hpcd);
N/**
N  * @}
N  */
N
N/* Peripheral State functions  ************************************************/
N/** @addtogroup PCD_Exported_Functions_Group4 Peripheral State functions
N  * @{
N  */
NPCD_StateTypeDef HAL_PCD_GetState(PCD_HandleTypeDef *hpcd);
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup PCD_Private_Macros PCD Private Macros
N * @{
N */
N/** @defgroup PCD_Instance_definition PCD Instance definition
N  * @{
N  */
N#define IS_PCD_ALL_INSTANCE(INSTANCE) (((INSTANCE) == USB_OTG_FS) || \
N                                       ((INSTANCE) == USB_OTG_HS))
X#define IS_PCD_ALL_INSTANCE(INSTANCE) (((INSTANCE) == USB_OTG_FS) ||                                        ((INSTANCE) == USB_OTG_HS))
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif /* __STM32F7xx_HAL_PCD_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 399 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_PCD_MODULE_ENABLED */
N
N#ifdef HAL_HCD_MODULE_ENABLED
N #include "stm32f7xx_hal_hcd.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_hcd.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_hcd.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of HCD HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_HCD_H
N#define __STM32F7xx_HAL_HCD_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_ll_usb.h"
N   
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @defgroup HCD HCD
N  * @brief HCD HAL module driver
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup HCD_Exported_Types HCD Exported Types
N  * @{
N  */ 
N
N/** @defgroup HCD_Exported_Types_Group1 HCD State Structure definition 
N  * @{
N  */
Ntypedef enum 
N{
N  HAL_HCD_STATE_RESET    = 0x00U,
N  HAL_HCD_STATE_READY    = 0x01U,
N  HAL_HCD_STATE_ERROR    = 0x02U,
N  HAL_HCD_STATE_BUSY     = 0x03U,
N  HAL_HCD_STATE_TIMEOUT  = 0x04U
N} HCD_StateTypeDef;
N
Ntypedef USB_OTG_GlobalTypeDef   HCD_TypeDef;
Ntypedef USB_OTG_CfgTypeDef      HCD_InitTypeDef;
Ntypedef USB_OTG_HCTypeDef       HCD_HCTypeDef ;   
Ntypedef USB_OTG_URBStateTypeDef HCD_URBStateTypeDef ;
Ntypedef USB_OTG_HCStateTypeDef  HCD_HCStateTypeDef ;
N/**
N  * @}
N  */
N
N/** @defgroup HCD_Exported_Types_Group2 HCD Handle Structure definition   
N  * @{
N  */ 
Ntypedef struct
N{
N  HCD_TypeDef               *Instance;  /*!< Register base address    */ 
N  HCD_InitTypeDef           Init;       /*!< HCD required parameters  */
N  HCD_HCTypeDef             hc[15];     /*!< Host channels parameters */
N  HAL_LockTypeDef           Lock;       /*!< HCD peripheral status    */
N  __IO HCD_StateTypeDef     State;      /*!< HCD communication state  */
X  volatile HCD_StateTypeDef     State;       
N  void                      *pData;     /*!< Pointer Stack Handler    */
N} HCD_HandleTypeDef;
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N  
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup HCD_Exported_Constants HCD Exported Constants
N  * @{
N  */
N
N/** @defgroup HCD_Speed HCD Speed
N  * @{
N  */
N#define HCD_SPEED_HIGH               0U
N#define HCD_SPEED_LOW                2U  
N#define HCD_SPEED_FULL               3U
N/**
N  * @}
N  */
N  
N/** @defgroup HCD_PHY_Module HCD PHY Module
N  * @{
N  */
N#define HCD_PHY_ULPI                 1U
N#define HCD_PHY_EMBEDDED             2U
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */ 
N  
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup HCD_Exported_Macros HCD Exported Macros
N *  @brief macros to handle interrupts and specific clock configurations
N * @{
N */
N#define __HAL_HCD_ENABLE(__HANDLE__)                   USB_EnableGlobalInt ((__HANDLE__)->Instance)
N#define __HAL_HCD_DISABLE(__HANDLE__)                  USB_DisableGlobalInt ((__HANDLE__)->Instance)
N
N#define __HAL_HCD_GET_FLAG(__HANDLE__, __INTERRUPT__)      ((USB_ReadInterrupts((__HANDLE__)->Instance) & (__INTERRUPT__)) == (__INTERRUPT__))
N#define __HAL_HCD_CLEAR_FLAG(__HANDLE__, __INTERRUPT__)    (((__HANDLE__)->Instance->GINTSTS) = (__INTERRUPT__))
N#define __HAL_HCD_IS_INVALID_INTERRUPT(__HANDLE__)         (USB_ReadInterrupts((__HANDLE__)->Instance) == 0U)    
N
N#define __HAL_HCD_CLEAR_HC_INT(chnum, __INTERRUPT__)  (USBx_HC(chnum)->HCINT = (__INTERRUPT__)) 
N#define __HAL_HCD_MASK_HALT_HC_INT(chnum)             (USBx_HC(chnum)->HCINTMSK &= ~USB_OTG_HCINTMSK_CHHM) 
N#define __HAL_HCD_UNMASK_HALT_HC_INT(chnum)           (USBx_HC(chnum)->HCINTMSK |= USB_OTG_HCINTMSK_CHHM) 
N#define __HAL_HCD_MASK_ACK_HC_INT(chnum)              (USBx_HC(chnum)->HCINTMSK &= ~USB_OTG_HCINTMSK_ACKM) 
N#define __HAL_HCD_UNMASK_ACK_HC_INT(chnum)            (USBx_HC(chnum)->HCINTMSK |= USB_OTG_HCINTMSK_ACKM) 
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup HCD_Exported_Functions HCD Exported Functions
N  * @{
N  */
N
N/** @defgroup HCD_Exported_Functions_Group1 Initialization and de-initialization functions
N  * @{
N  */
NHAL_StatusTypeDef      HAL_HCD_Init(HCD_HandleTypeDef *hhcd);
NHAL_StatusTypeDef      HAL_HCD_DeInit (HCD_HandleTypeDef *hhcd);
NHAL_StatusTypeDef      HAL_HCD_HC_Init(HCD_HandleTypeDef *hhcd,  
N                                  uint8_t ch_num,
N                                  uint8_t epnum,
N                                  uint8_t dev_address,
N                                  uint8_t speed,
N                                  uint8_t ep_type,
N                                  uint16_t mps);
N
NHAL_StatusTypeDef   HAL_HCD_HC_Halt(HCD_HandleTypeDef *hhcd, uint8_t ch_num);
Nvoid                HAL_HCD_MspInit(HCD_HandleTypeDef *hhcd);
Nvoid                HAL_HCD_MspDeInit(HCD_HandleTypeDef *hhcd);
N/**
N  * @}
N  */
N
N/* I/O operation functions  ***************************************************/
N/** @addtogroup HCD_Exported_Functions_Group2 Input and Output operation functions
N  * @{
N  */
NHAL_StatusTypeDef       HAL_HCD_HC_SubmitRequest(HCD_HandleTypeDef *hhcd,
N                                                 uint8_t pipe, 
N                                                 uint8_t direction ,
N                                                 uint8_t ep_type,  
N                                                 uint8_t token, 
N                                                 uint8_t* pbuff, 
N                                                 uint16_t length,
N                                                 uint8_t do_ping);
N
N /* Non-Blocking mode: Interrupt */
Nvoid                    HAL_HCD_IRQHandler(HCD_HandleTypeDef *hhcd);
Nvoid             HAL_HCD_SOF_Callback(HCD_HandleTypeDef *hhcd);
Nvoid             HAL_HCD_Connect_Callback(HCD_HandleTypeDef *hhcd);
Nvoid             HAL_HCD_Disconnect_Callback(HCD_HandleTypeDef *hhcd);
Nvoid             HAL_HCD_HC_NotifyURBChange_Callback(HCD_HandleTypeDef *hhcd, 
N                                                            uint8_t chnum, 
N                                                            HCD_URBStateTypeDef urb_state);
N/**
N  * @}
N  */
N
N/* Peripheral Control functions  **********************************************/
N/** @addtogroup HCD_Exported_Functions_Group3 Peripheral Control functions
N  * @{
N  */
NHAL_StatusTypeDef       HAL_HCD_ResetPort(HCD_HandleTypeDef *hhcd);
NHAL_StatusTypeDef       HAL_HCD_Start(HCD_HandleTypeDef *hhcd);
NHAL_StatusTypeDef       HAL_HCD_Stop(HCD_HandleTypeDef *hhcd);
N/**
N  * @}
N  */
N
N/* Peripheral State functions  ************************************************/
N/** @addtogroup HCD_Exported_Functions_Group4 Peripheral State functions
N  * @{
N  */
NHCD_StateTypeDef        HAL_HCD_GetState(HCD_HandleTypeDef *hhcd);
NHCD_URBStateTypeDef     HAL_HCD_HC_GetURBState(HCD_HandleTypeDef *hhcd, uint8_t chnum);
Nuint32_t                HAL_HCD_HC_GetXferCount(HCD_HandleTypeDef *hhcd, uint8_t chnum);
NHCD_HCStateTypeDef      HAL_HCD_HC_GetState(HCD_HandleTypeDef *hhcd, uint8_t chnum);
Nuint32_t                HAL_HCD_GetCurrentFrame(HCD_HandleTypeDef *hhcd);
Nuint32_t                HAL_HCD_GetCurrentSpeed(HCD_HandleTypeDef *hhcd);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup HCD_Private_Macros HCD Private Macros
N * @{
N */
N/** @defgroup HCD_Instance_definition HCD Instance definition
N  * @{
N  */
N#define IS_HCD_ALL_INSTANCE(INSTANCE) (((INSTANCE) == USB_OTG_FS) || \
N                                       ((INSTANCE) == USB_OTG_HS))
X#define IS_HCD_ALL_INSTANCE(INSTANCE) (((INSTANCE) == USB_OTG_FS) ||                                        ((INSTANCE) == USB_OTG_HS))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private functions prototypes ----------------------------------------------*/
N/** @defgroup HCD_Private_Functions_Prototypes HCD Private Functions Prototypes
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup HCD_Private_Functions HCD Private Functions
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_HCD_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 403 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_HCD_MODULE_ENABLED */
N
N#ifdef HAL_DFSDM_MODULE_ENABLED
N #include "stm32f7xx_hal_dfsdm.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_dfsdm.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_dfsdm.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of DFSDM HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_DFSDM_H
N#define __STM32F7xx_HAL_DFSDM_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup DFSDM
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup DFSDM_Exported_Types DFSDM Exported Types
N  * @{
N  */
N
N/** 
N  * @brief  HAL DFSDM Channel states definition  
N  */ 
Ntypedef enum
N{
N  HAL_DFSDM_CHANNEL_STATE_RESET = 0x00U, /*!< DFSDM channel not initialized */
N  HAL_DFSDM_CHANNEL_STATE_READY = 0x01U, /*!< DFSDM channel initialized and ready for use */
N  HAL_DFSDM_CHANNEL_STATE_ERROR = 0xFFU  /*!< DFSDM channel state error */
N}HAL_DFSDM_Channel_StateTypeDef;
N
N/** 
N  * @brief  DFSDM channel output clock structure definition  
N  */  
Ntypedef struct
N{
N  FunctionalState Activation; /*!< Output clock enable/disable */
N  uint32_t        Selection;  /*!< Output clock is system clock or audio clock.
N                                   This parameter can be a value of @ref DFSDM_Channel_OuputClock */
N  uint32_t        Divider;    /*!< Output clock divider.
N                                   This parameter must be a number between Min_Data = 2 and Max_Data = 256 */
N}DFSDM_Channel_OutputClockTypeDef;
N
N/** 
N  * @brief  DFSDM channel input structure definition  
N  */  
Ntypedef struct
N{
N  uint32_t Multiplexer; /*!< Input is external serial inputs or internal register.
N                             This parameter can be a value of @ref DFSDM_Channel_InputMultiplexer */
N  uint32_t DataPacking; /*!< Standard, interleaved or dual mode for internal register.
N                             This parameter can be a value of @ref DFSDM_Channel_DataPacking */
N  uint32_t Pins;        /*!< Input pins are taken from same or following channel.
N                             This parameter can be a value of @ref DFSDM_Channel_InputPins */
N}DFSDM_Channel_InputTypeDef;
N
N/** 
N  * @brief  DFSDM channel serial interface structure definition  
N  */  
Ntypedef struct
N{
N  uint32_t Type;     /*!< SPI or Manchester modes.
N                          This parameter can be a value of @ref DFSDM_Channel_SerialInterfaceType */
N  uint32_t SpiClock; /*!< SPI clock select (external or internal with different sampling point).
N                          This parameter can be a value of @ref DFSDM_Channel_SpiClock */
N}DFSDM_Channel_SerialInterfaceTypeDef;
N
N/** 
N  * @brief  DFSDM channel analog watchdog structure definition  
N  */  
Ntypedef struct
N{
N  uint32_t FilterOrder;  /*!< Analog watchdog Sinc filter order.
N                              This parameter can be a value of @ref DFSDM_Channel_AwdFilterOrder */
N  uint32_t Oversampling; /*!< Analog watchdog filter oversampling ratio.
N                              This parameter must be a number between Min_Data = 1 and Max_Data = 32 */
N}DFSDM_Channel_AwdTypeDef;
N
N/** 
N  * @brief  DFSDM channel init structure definition  
N  */  
Ntypedef struct
N{
N  DFSDM_Channel_OutputClockTypeDef     OutputClock;     /*!< DFSDM channel output clock parameters */
N  DFSDM_Channel_InputTypeDef           Input;           /*!< DFSDM channel input parameters */
N  DFSDM_Channel_SerialInterfaceTypeDef SerialInterface; /*!< DFSDM channel serial interface parameters */
N  DFSDM_Channel_AwdTypeDef             Awd;             /*!< DFSDM channel analog watchdog parameters */
N  int32_t                              Offset;          /*!< DFSDM channel offset.
N                                                             This parameter must be a number between Min_Data = -8388608 and Max_Data = 8388607 */
N  uint32_t                             RightBitShift;   /*!< DFSDM channel right bit shift.
N                                                             This parameter must be a number between Min_Data = 0x00 and Max_Data = 0x1F */
N}DFSDM_Channel_InitTypeDef;
N
N/** 
N  * @brief  DFSDM channel handle structure definition  
N  */  
Ntypedef struct
N{
N  DFSDM_Channel_TypeDef          *Instance; /*!< DFSDM channel instance */
N  DFSDM_Channel_InitTypeDef      Init;      /*!< DFSDM channel init parameters */
N  HAL_DFSDM_Channel_StateTypeDef State;     /*!< DFSDM channel state */
N}DFSDM_Channel_HandleTypeDef;
N
N/** 
N  * @brief  HAL DFSDM Filter states definition  
N  */ 
Ntypedef enum
N{
N  HAL_DFSDM_FILTER_STATE_RESET   = 0x00U, /*!< DFSDM filter not initialized */
N  HAL_DFSDM_FILTER_STATE_READY   = 0x01U, /*!< DFSDM filter initialized and ready for use */
N  HAL_DFSDM_FILTER_STATE_REG     = 0x02U, /*!< DFSDM filter regular conversion in progress */
N  HAL_DFSDM_FILTER_STATE_INJ     = 0x03U, /*!< DFSDM filter injected conversion in progress */
N  HAL_DFSDM_FILTER_STATE_REG_INJ = 0x04U, /*!< DFSDM filter regular and injected conversions in progress */
N  HAL_DFSDM_FILTER_STATE_ERROR   = 0xFFU  /*!< DFSDM filter state error */
N}HAL_DFSDM_Filter_StateTypeDef;
N
N/** 
N  * @brief  DFSDM filter regular conversion parameters structure definition  
N  */  
Ntypedef struct
N{
N  uint32_t        Trigger;  /*!< Trigger used to start regular conversion: software or synchronous.
N                                 This parameter can be a value of @ref DFSDM_Filter_Trigger */
N  FunctionalState FastMode; /*!< Enable/disable fast mode for regular conversion */
N  FunctionalState DmaMode;  /*!< Enable/disable DMA for regular conversion */
N}DFSDM_Filter_RegularParamTypeDef;
N
N/** 
N  * @brief  DFSDM filter injected conversion parameters structure definition  
N  */  
Ntypedef struct
N{
N  uint32_t        Trigger;        /*!< Trigger used to start injected conversion: software, external or synchronous.
N                                       This parameter can be a value of @ref DFSDM_Filter_Trigger */
N  FunctionalState ScanMode;       /*!< Enable/disable scanning mode for injected conversion */
N  FunctionalState DmaMode;        /*!< Enable/disable DMA for injected conversion */
N  uint32_t        ExtTrigger;     /*!< External trigger.
N                                       This parameter can be a value of @ref DFSDM_Filter_ExtTrigger */
N  uint32_t        ExtTriggerEdge; /*!< External trigger edge: rising, falling or both.
N                                       This parameter can be a value of @ref DFSDM_Filter_ExtTriggerEdge */
N}DFSDM_Filter_InjectedParamTypeDef;
N
N/** 
N  * @brief  DFSDM filter parameters structure definition  
N  */  
Ntypedef struct
N{
N  uint32_t SincOrder;       /*!< Sinc filter order.
N                                 This parameter can be a value of @ref DFSDM_Filter_SincOrder */
N  uint32_t Oversampling;    /*!< Filter oversampling ratio.
N                                 This parameter must be a number between Min_Data = 1 and Max_Data = 1024 */
N  uint32_t IntOversampling; /*!< Integrator oversampling ratio.
N                                 This parameter must be a number between Min_Data = 1 and Max_Data = 256 */
N}DFSDM_Filter_FilterParamTypeDef;
N
N/** 
N  * @brief  DFSDM filter init structure definition  
N  */  
Ntypedef struct
N{
N  DFSDM_Filter_RegularParamTypeDef  RegularParam;  /*!< DFSDM regular conversion parameters */
N  DFSDM_Filter_InjectedParamTypeDef InjectedParam; /*!< DFSDM injected conversion parameters */
N  DFSDM_Filter_FilterParamTypeDef   FilterParam;   /*!< DFSDM filter parameters */
N}DFSDM_Filter_InitTypeDef;
N
N/** 
N  * @brief  DFSDM filter handle structure definition  
N  */  
Ntypedef struct
N{
N  DFSDM_Filter_TypeDef          *Instance;           /*!< DFSDM filter instance */
N  DFSDM_Filter_InitTypeDef      Init;                /*!< DFSDM filter init parameters */
N  DMA_HandleTypeDef             *hdmaReg;            /*!< Pointer on DMA handler for regular conversions */
N  DMA_HandleTypeDef             *hdmaInj;            /*!< Pointer on DMA handler for injected conversions */
N  uint32_t                      RegularContMode;     /*!< Regular conversion continuous mode */
N  uint32_t                      RegularTrigger;      /*!< Trigger used for regular conversion */
N  uint32_t                      InjectedTrigger;     /*!< Trigger used for injected conversion */
N  uint32_t                      ExtTriggerEdge;      /*!< Rising, falling or both edges selected */
N  FunctionalState               InjectedScanMode;    /*!< Injected scanning mode */
N  uint32_t                      InjectedChannelsNbr; /*!< Number of channels in injected sequence */
N  uint32_t                      InjConvRemaining;    /*!< Injected conversions remaining */
N  HAL_DFSDM_Filter_StateTypeDef State;               /*!< DFSDM filter state */
N  uint32_t                      ErrorCode;           /*!< DFSDM filter error code */  
N}DFSDM_Filter_HandleTypeDef;
N
N/** 
N  * @brief  DFSDM filter analog watchdog parameters structure definition  
N  */  
Ntypedef struct
N{
N  uint32_t DataSource;      /*!< Values from digital filter or from channel watchdog filter.
N                                 This parameter can be a value of @ref DFSDM_Filter_AwdDataSource */
N  uint32_t Channel;         /*!< Analog watchdog channel selection.
N                                 This parameter can be a values combination of @ref DFSDM_Channel_Selection */
N  int32_t  HighThreshold;   /*!< High threshold for the analog watchdog.
N                                 This parameter must be a number between Min_Data = -8388608 and Max_Data = 8388607 */
N  int32_t  LowThreshold;    /*!< Low threshold for the analog watchdog.
N                                 This parameter must be a number between Min_Data = -8388608 and Max_Data = 8388607 */
N  uint32_t HighBreakSignal; /*!< Break signal assigned to analog watchdog high threshold event.
N                                 This parameter can be a values combination of @ref DFSDM_BreakSignals */
N  uint32_t LowBreakSignal;  /*!< Break signal assigned to analog watchdog low threshold event.
N                                 This parameter can be a values combination of @ref DFSDM_BreakSignals */
N}DFSDM_Filter_AwdParamTypeDef;
N
N/**
N  * @}
N  */ 
N/* End of exported types -----------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup DFSDM_Exported_Constants DFSDM Exported Constants
N  * @{
N  */
N
N/** @defgroup DFSDM_Channel_OuputClock DFSDM channel output clock selection
N  * @{
N  */
N#define DFSDM_CHANNEL_OUTPUT_CLOCK_SYSTEM    ((uint32_t)0x00000000U) /*!< Source for ouput clock is system clock */
N#define DFSDM_CHANNEL_OUTPUT_CLOCK_AUDIO     DFSDM_CHCFGR1_CKOUTSRC  /*!< Source for ouput clock is audio clock */
N/**
N  * @}
N  */
N
N/** @defgroup DFSDM_Channel_InputMultiplexer DFSDM channel input multiplexer
N  * @{
N  */
N#define DFSDM_CHANNEL_EXTERNAL_INPUTS    ((uint32_t)0x00000000U) /*!< Data are taken from external inputs */
N#define DFSDM_CHANNEL_INTERNAL_REGISTER  DFSDM_CHCFGR1_DATMPX_1  /*!< Data are taken from internal register */
N/**
N  * @}
N  */
N
N/** @defgroup DFSDM_Channel_DataPacking DFSDM channel input data packing
N  * @{
N  */
N#define DFSDM_CHANNEL_STANDARD_MODE         ((uint32_t)0x00000000U) /*!< Standard data packing mode */
N#define DFSDM_CHANNEL_INTERLEAVED_MODE      DFSDM_CHCFGR1_DATPACK_0 /*!< Interleaved data packing mode */
N#define DFSDM_CHANNEL_DUAL_MODE             DFSDM_CHCFGR1_DATPACK_1 /*!< Dual data packing mode */
N/**
N  * @}
N  */
N
N/** @defgroup DFSDM_Channel_InputPins DFSDM channel input pins
N  * @{
N  */
N#define DFSDM_CHANNEL_SAME_CHANNEL_PINS      ((uint32_t)0x00000000U) /*!< Input from pins on same channel */
N#define DFSDM_CHANNEL_FOLLOWING_CHANNEL_PINS DFSDM_CHCFGR1_CHINSEL   /*!< Input from pins on following channel */
N/**
N  * @}
N  */
N
N/** @defgroup DFSDM_Channel_SerialInterfaceType DFSDM channel serial interface type
N  * @{
N  */
N#define DFSDM_CHANNEL_SPI_RISING         ((uint32_t)0x00000000U) /*!< SPI with rising edge */
N#define DFSDM_CHANNEL_SPI_FALLING        DFSDM_CHCFGR1_SITP_0    /*!< SPI with falling edge */
N#define DFSDM_CHANNEL_MANCHESTER_RISING  DFSDM_CHCFGR1_SITP_1    /*!< Manchester with rising edge */
N#define DFSDM_CHANNEL_MANCHESTER_FALLING DFSDM_CHCFGR1_SITP      /*!< Manchester with falling edge */
N/**
N  * @}
N  */
N
N/** @defgroup DFSDM_Channel_SpiClock DFSDM channel SPI clock selection
N  * @{
N  */
N#define DFSDM_CHANNEL_SPI_CLOCK_EXTERNAL              ((uint32_t)0x00000000U)  /*!< External SPI clock */
N#define DFSDM_CHANNEL_SPI_CLOCK_INTERNAL              DFSDM_CHCFGR1_SPICKSEL_0 /*!< Internal SPI clock */
N#define DFSDM_CHANNEL_SPI_CLOCK_INTERNAL_DIV2_FALLING DFSDM_CHCFGR1_SPICKSEL_1 /*!< Internal SPI clock divided by 2, falling edge */
N#define DFSDM_CHANNEL_SPI_CLOCK_INTERNAL_DIV2_RISING  DFSDM_CHCFGR1_SPICKSEL   /*!< Internal SPI clock divided by 2, rising edge */
N/**
N  * @}
N  */
N
N/** @defgroup DFSDM_Channel_AwdFilterOrder DFSDM channel analog watchdog filter order
N  * @{
N  */
N#define DFSDM_CHANNEL_FASTSINC_ORDER ((uint32_t)0x00000000U) /*!< FastSinc filter type */
N#define DFSDM_CHANNEL_SINC1_ORDER    DFSDM_CHAWSCDR_AWFORD_0 /*!< Sinc 1 filter type */
N#define DFSDM_CHANNEL_SINC2_ORDER    DFSDM_CHAWSCDR_AWFORD_1 /*!< Sinc 2 filter type */
N#define DFSDM_CHANNEL_SINC3_ORDER    DFSDM_CHAWSCDR_AWFORD   /*!< Sinc 3 filter type */
N/**
N  * @}
N  */
N
N/** @defgroup DFSDM_Filter_Trigger DFSDM filter conversion trigger
N  * @{
N  */
N#define DFSDM_FILTER_SW_TRIGGER   ((uint32_t)0x00000000U) /*!< Software trigger */
N#define DFSDM_FILTER_SYNC_TRIGGER ((uint32_t)0x00000001U) /*!< Synchronous with DFSDM_FLT0 */
N#define DFSDM_FILTER_EXT_TRIGGER  ((uint32_t)0x00000002U) /*!< External trigger (only for injected conversion) */
N/**
N  * @}
N  */
N
N/** @defgroup DFSDM_Filter_ExtTrigger DFSDM filter external trigger
N  * @{
N  */
N#define DFSDM_FILTER_EXT_TRIG_TIM1_TRGO  ((uint32_t)0x00000000U)                             /*!< For DFSDM filter 0, 1, 2 and 3 */
N#define DFSDM_FILTER_EXT_TRIG_TIM1_TRGO2 DFSDM_FLTCR1_JEXTSEL_0                              /*!< For DFSDM filter 0, 1, 2 and 3 */ 
N#define DFSDM_FILTER_EXT_TRIG_TIM8_TRGO  DFSDM_FLTCR1_JEXTSEL_1                              /*!< For DFSDM filter 0, 1, 2 and 3 */
N#define DFSDM_FILTER_EXT_TRIG_TIM8_TRGO2 (DFSDM_FLTCR1_JEXTSEL_0 | DFSDM_FLTCR1_JEXTSEL_1)   /*!< For DFSDM filter 0, 1, 2 and 3 */
N#define DFSDM_FILTER_EXT_TRIG_TIM3_TRGO  DFSDM_FLTCR1_JEXTSEL_2                              /*!< For DFSDM filter 0, 1, 2 and 3 */
N#define DFSDM_FILTER_EXT_TRIG_TIM4_TRGO  (DFSDM_FLTCR1_JEXTSEL_0 | DFSDM_FLTCR1_JEXTSEL_2)   /*!< For DFSDM filter 0, 1, 2 and 3 */
N#define DFSDM_FILTER_EXT_TRIG_TIM10_OC1  (DFSDM_FLTCR1_JEXTSEL_1 | DFSDM_FLTCR1_JEXTSEL_2)   /*!< For DFSDM filter 0, 1, 2 and 3 */
N#define DFSDM_FILTER_EXT_TRIG_TIM6_TRGO  (DFSDM_FLTCR1_JEXTSEL_0 | DFSDM_FLTCR1_JEXTSEL_1 | \
N                                         DFSDM_FLTCR1_JEXTSEL_2)                             /*!< For DFSDM filter 0, 1, 2 and 3 */
X#define DFSDM_FILTER_EXT_TRIG_TIM6_TRGO  (DFSDM_FLTCR1_JEXTSEL_0 | DFSDM_FLTCR1_JEXTSEL_1 |                                          DFSDM_FLTCR1_JEXTSEL_2)                              
N#define DFSDM_FILTER_EXT_TRIG_TIM7_TRGO  DFSDM_FLTCR1_JEXTSEL_3                              /*!< For DFSDM filter 0, 1, 2 and 3 */
N#define DFSDM_FILTER_EXT_TRIG_EXTI11     (DFSDM_FLTCR1_JEXTSEL_3 | DFSDM_FLTCR1_JEXTSEL_4)   /*!< For DFSDM filter 0, 1, 2 and 3 */
N#define DFSDM_FILTER_EXT_TRIG_EXTI15     (DFSDM_FLTCR1_JEXTSEL_0 | DFSDM_FLTCR1_JEXTSEL_3 | \
N                                         DFSDM_FLTCR1_JEXTSEL_4)                             /*!< For DFSDM filter 0, 1, 2 and 3 */                         
X#define DFSDM_FILTER_EXT_TRIG_EXTI15     (DFSDM_FLTCR1_JEXTSEL_0 | DFSDM_FLTCR1_JEXTSEL_3 |                                          DFSDM_FLTCR1_JEXTSEL_4)                                                       
N#define DFSDM_FILTER_EXT_TRIG_LPTIM1_OUT (DFSDM_FLTCR1_JEXTSEL_1 | DFSDM_FLTCR1_JEXTSEL_3 | \
N                                         DFSDM_FLTCR1_JEXTSEL_4)                             /*!< For DFSDM filter 0, 1, 2 and 3 */                          
X#define DFSDM_FILTER_EXT_TRIG_LPTIM1_OUT (DFSDM_FLTCR1_JEXTSEL_1 | DFSDM_FLTCR1_JEXTSEL_3 |                                          DFSDM_FLTCR1_JEXTSEL_4)                                                        
N/**
N  * @}
N  */ 
N
N/** @defgroup DFSDM_Filter_ExtTriggerEdge DFSDM filter external trigger edge
N  * @{
N  */
N#define DFSDM_FILTER_EXT_TRIG_RISING_EDGE  DFSDM_FLTCR1_JEXTEN_0 /*!< External rising edge */
N#define DFSDM_FILTER_EXT_TRIG_FALLING_EDGE DFSDM_FLTCR1_JEXTEN_1 /*!< External falling edge */
N#define DFSDM_FILTER_EXT_TRIG_BOTH_EDGES   DFSDM_FLTCR1_JEXTEN   /*!< External rising and falling edges */
N/**
N  * @}
N  */
N
N/** @defgroup DFSDM_Filter_SincOrder DFSDM filter sinc order
N  * @{
N  */
N#define DFSDM_FILTER_FASTSINC_ORDER ((uint32_t)0x00000000U)                     /*!< FastSinc filter type */
N#define DFSDM_FILTER_SINC1_ORDER    DFSDM_FLTFCR_FORD_0                         /*!< Sinc 1 filter type */
N#define DFSDM_FILTER_SINC2_ORDER    DFSDM_FLTFCR_FORD_1                         /*!< Sinc 2 filter type */
N#define DFSDM_FILTER_SINC3_ORDER    (DFSDM_FLTFCR_FORD_0 | DFSDM_FLTFCR_FORD_1) /*!< Sinc 3 filter type */
N#define DFSDM_FILTER_SINC4_ORDER    DFSDM_FLTFCR_FORD_2                         /*!< Sinc 4 filter type */
N#define DFSDM_FILTER_SINC5_ORDER    (DFSDM_FLTFCR_FORD_0 | DFSDM_FLTFCR_FORD_2) /*!< Sinc 5 filter type */
N/**
N  * @}
N  */
N
N/** @defgroup DFSDM_Filter_AwdDataSource DFSDM filter analog watchdog data source
N  * @{
N  */
N#define DFSDM_FILTER_AWD_FILTER_DATA  ((uint32_t)0x00000000U) /*!< From digital filter */
N#define DFSDM_FILTER_AWD_CHANNEL_DATA DFSDM_FLTCR1_AWFSEL     /*!< From analog watchdog channel */
N/**
N  * @}
N  */
N
N/** @defgroup DFSDM_Filter_ErrorCode DFSDM filter error code
N  * @{
N  */ 
N#define DFSDM_FILTER_ERROR_NONE             ((uint32_t)0x00000000U) /*!< No error */
N#define DFSDM_FILTER_ERROR_REGULAR_OVERRUN  ((uint32_t)0x00000001U) /*!< Overrun occurs during regular conversion */
N#define DFSDM_FILTER_ERROR_INJECTED_OVERRUN ((uint32_t)0x00000002U) /*!< Overrun occurs during injected conversion */
N#define DFSDM_FILTER_ERROR_DMA              ((uint32_t)0x00000003U) /*!< DMA error occurs */
N/**
N  * @}
N  */
N
N/** @defgroup DFSDM_BreakSignals DFSDM break signals
N  * @{
N  */
N#define DFSDM_NO_BREAK_SIGNAL ((uint32_t)0x00000000U) /*!< No break signal */
N#define DFSDM_BREAK_SIGNAL_0  ((uint32_t)0x00000001U) /*!< Break signal 0 */
N#define DFSDM_BREAK_SIGNAL_1  ((uint32_t)0x00000002U) /*!< Break signal 1 */
N#define DFSDM_BREAK_SIGNAL_2  ((uint32_t)0x00000004U) /*!< Break signal 2 */
N#define DFSDM_BREAK_SIGNAL_3  ((uint32_t)0x00000008U) /*!< Break signal 3 */
N/**
N  * @}
N  */
N
N/** @defgroup DFSDM_Channel_Selection DFSDM Channel Selection
N  * @{
N  */
N/* DFSDM Channels ------------------------------------------------------------*/
N/* The DFSDM channels are defined as follows:
N   - in 16-bit LSB the channel mask is set
N   - in 16-bit MSB the channel number is set
N   e.g. for channel 5 definition:
N        - the channel mask is 0x00000020 (bit 5 is set)
N        - the channel number 5 is 0x00050000 
N        --> Consequently, channel 5 definition is 0x00000020 | 0x00050000 = 0x00050020 */
N#define DFSDM_CHANNEL_0                              ((uint32_t)0x00000001U)
N#define DFSDM_CHANNEL_1                              ((uint32_t)0x00010002U)
N#define DFSDM_CHANNEL_2                              ((uint32_t)0x00020004U)
N#define DFSDM_CHANNEL_3                              ((uint32_t)0x00030008U)
N#define DFSDM_CHANNEL_4                              ((uint32_t)0x00040010U)
N#define DFSDM_CHANNEL_5                              ((uint32_t)0x00050020U)
N#define DFSDM_CHANNEL_6                              ((uint32_t)0x00060040U)
N#define DFSDM_CHANNEL_7                              ((uint32_t)0x00070080U)
N/**
N  * @}
N  */
N
N/** @defgroup DFSDM_ContinuousMode DFSDM Continuous Mode
N  * @{
N  */
N#define DFSDM_CONTINUOUS_CONV_OFF            ((uint32_t)0x00000000U) /*!< Conversion are not continuous */
N#define DFSDM_CONTINUOUS_CONV_ON             ((uint32_t)0x00000001U) /*!< Conversion are continuous */
N/**
N  * @}
N  */
N
N/** @defgroup DFSDM_AwdThreshold DFSDM analog watchdog threshold
N  * @{
N  */
N#define DFSDM_AWD_HIGH_THRESHOLD            ((uint32_t)0x00000000U) /*!< Analog watchdog high threshold */
N#define DFSDM_AWD_LOW_THRESHOLD             ((uint32_t)0x00000001U) /*!< Analog watchdog low threshold */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N/* End of exported constants -------------------------------------------------*/
N
N/* Exported macros -----------------------------------------------------------*/  
N/** @defgroup DFSDM_Exported_Macros DFSDM Exported Macros
N * @{
N */
N
N/** @brief  Reset DFSDM channel handle state.
N  * @param  __HANDLE__: DFSDM channel handle.
N  * @retval None
N  */
N#define __HAL_DFSDM_CHANNEL_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_DFSDM_CHANNEL_STATE_RESET)
N
N/** @brief  Reset DFSDM filter handle state.
N  * @param  __HANDLE__: DFSDM filter handle.
N  * @retval None
N  */
N#define __HAL_DFSDM_FILTER_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_DFSDM_FILTER_STATE_RESET)
N
N/**
N  * @}
N  */
N/* End of exported macros ----------------------------------------------------*/
N  
N/* Exported functions --------------------------------------------------------*/  
N/** @addtogroup DFSDM_Exported_Functions DFSDM Exported Functions
N  * @{
N  */
N
N/** @addtogroup DFSDM_Exported_Functions_Group1_Channel Channel initialization and de-initialization functions
N  * @{
N  */
N/* Channel initialization and de-initialization functions *********************/
NHAL_StatusTypeDef HAL_DFSDM_ChannelInit(DFSDM_Channel_HandleTypeDef *hdfsdm_channel);
NHAL_StatusTypeDef HAL_DFSDM_ChannelDeInit(DFSDM_Channel_HandleTypeDef *hdfsdm_channel);
Nvoid HAL_DFSDM_ChannelMspInit(DFSDM_Channel_HandleTypeDef *hdfsdm_channel);
Nvoid HAL_DFSDM_ChannelMspDeInit(DFSDM_Channel_HandleTypeDef *hdfsdm_channel);
N/**
N  * @}
N  */
N
N/** @addtogroup DFSDM_Exported_Functions_Group2_Channel Channel operation functions
N  * @{
N  */
N/* Channel operation functions ************************************************/
NHAL_StatusTypeDef HAL_DFSDM_ChannelCkabStart(DFSDM_Channel_HandleTypeDef *hdfsdm_channel);
NHAL_StatusTypeDef HAL_DFSDM_ChannelCkabStart_IT(DFSDM_Channel_HandleTypeDef *hdfsdm_channel);
NHAL_StatusTypeDef HAL_DFSDM_ChannelCkabStop(DFSDM_Channel_HandleTypeDef *hdfsdm_channel);
NHAL_StatusTypeDef HAL_DFSDM_ChannelCkabStop_IT(DFSDM_Channel_HandleTypeDef *hdfsdm_channel);
N
NHAL_StatusTypeDef HAL_DFSDM_ChannelScdStart(DFSDM_Channel_HandleTypeDef *hdfsdm_channel, uint32_t Threshold, uint32_t BreakSignal);
NHAL_StatusTypeDef HAL_DFSDM_ChannelScdStart_IT(DFSDM_Channel_HandleTypeDef *hdfsdm_channel, uint32_t Threshold, uint32_t BreakSignal);
NHAL_StatusTypeDef HAL_DFSDM_ChannelScdStop(DFSDM_Channel_HandleTypeDef *hdfsdm_channel);
NHAL_StatusTypeDef HAL_DFSDM_ChannelScdStop_IT(DFSDM_Channel_HandleTypeDef *hdfsdm_channel);
N
Nint16_t           HAL_DFSDM_ChannelGetAwdValue(DFSDM_Channel_HandleTypeDef *hdfsdm_channel);
NHAL_StatusTypeDef HAL_DFSDM_ChannelModifyOffset(DFSDM_Channel_HandleTypeDef *hdfsdm_channel, int32_t Offset);
N
NHAL_StatusTypeDef HAL_DFSDM_ChannelPollForCkab(DFSDM_Channel_HandleTypeDef *hdfsdm_channel, uint32_t Timeout);
NHAL_StatusTypeDef HAL_DFSDM_ChannelPollForScd(DFSDM_Channel_HandleTypeDef *hdfsdm_channel, uint32_t Timeout);
N
Nvoid HAL_DFSDM_ChannelCkabCallback(DFSDM_Channel_HandleTypeDef *hdfsdm_channel);
Nvoid HAL_DFSDM_ChannelScdCallback(DFSDM_Channel_HandleTypeDef *hdfsdm_channel);
N/**
N  * @}
N  */
N
N/** @defgroup DFSDM_Exported_Functions_Group3_Channel Channel state function
N  * @{
N  */
N/* Channel state function *****************************************************/
NHAL_DFSDM_Channel_StateTypeDef HAL_DFSDM_ChannelGetState(DFSDM_Channel_HandleTypeDef *hdfsdm_channel);
N/**
N  * @}
N  */
N
N/** @addtogroup DFSDM_Exported_Functions_Group1_Filter Filter initialization and de-initialization functions
N  * @{
N  */
N/* Filter initialization and de-initialization functions *********************/
NHAL_StatusTypeDef HAL_DFSDM_FilterInit(DFSDM_Filter_HandleTypeDef *hdfsdm_filter);
NHAL_StatusTypeDef HAL_DFSDM_FilterDeInit(DFSDM_Filter_HandleTypeDef *hdfsdm_filter);
Nvoid HAL_DFSDM_FilterMspInit(DFSDM_Filter_HandleTypeDef *hdfsdm_filter);
Nvoid HAL_DFSDM_FilterMspDeInit(DFSDM_Filter_HandleTypeDef *hdfsdm_filter);
N/**
N  * @}
N  */
N
N/** @addtogroup DFSDM_Exported_Functions_Group2_Filter Filter control functions
N  * @{
N  */
N/* Filter control functions *********************/
NHAL_StatusTypeDef HAL_DFSDM_FilterConfigRegChannel(DFSDM_Filter_HandleTypeDef *hdfsdm_filter,
N                                                   uint32_t                    Channel,
N                                                   uint32_t                    ContinuousMode);
NHAL_StatusTypeDef HAL_DFSDM_FilterConfigInjChannel(DFSDM_Filter_HandleTypeDef *hdfsdm_filter,
N                                                   uint32_t                    Channel);
N/**
N  * @}
N  */
N
N/** @addtogroup DFSDM_Exported_Functions_Group3_Filter Filter operation functions
N  * @{
N  */
N/* Filter operation functions *********************/
NHAL_StatusTypeDef HAL_DFSDM_FilterRegularStart(DFSDM_Filter_HandleTypeDef *hdfsdm_filter);
NHAL_StatusTypeDef HAL_DFSDM_FilterRegularStart_IT(DFSDM_Filter_HandleTypeDef *hdfsdm_filter);
NHAL_StatusTypeDef HAL_DFSDM_FilterRegularStart_DMA(DFSDM_Filter_HandleTypeDef *hdfsdm_filter, int32_t *pData, uint32_t Length);
NHAL_StatusTypeDef HAL_DFSDM_FilterRegularMsbStart_DMA(DFSDM_Filter_HandleTypeDef *hdfsdm_filter, int16_t *pData, uint32_t Length);
NHAL_StatusTypeDef HAL_DFSDM_FilterRegularStop(DFSDM_Filter_HandleTypeDef *hdfsdm_filter);
NHAL_StatusTypeDef HAL_DFSDM_FilterRegularStop_IT(DFSDM_Filter_HandleTypeDef *hdfsdm_filter);
NHAL_StatusTypeDef HAL_DFSDM_FilterRegularStop_DMA(DFSDM_Filter_HandleTypeDef *hdfsdm_filter);
NHAL_StatusTypeDef HAL_DFSDM_FilterInjectedStart(DFSDM_Filter_HandleTypeDef *hdfsdm_filter);
NHAL_StatusTypeDef HAL_DFSDM_FilterInjectedStart_IT(DFSDM_Filter_HandleTypeDef *hdfsdm_filter);
NHAL_StatusTypeDef HAL_DFSDM_FilterInjectedStart_DMA(DFSDM_Filter_HandleTypeDef *hdfsdm_filter, int32_t *pData, uint32_t Length);
NHAL_StatusTypeDef HAL_DFSDM_FilterInjectedMsbStart_DMA(DFSDM_Filter_HandleTypeDef *hdfsdm_filter, int16_t *pData, uint32_t Length);
NHAL_StatusTypeDef HAL_DFSDM_FilterInjectedStop(DFSDM_Filter_HandleTypeDef *hdfsdm_filter);
NHAL_StatusTypeDef HAL_DFSDM_FilterInjectedStop_IT(DFSDM_Filter_HandleTypeDef *hdfsdm_filter);
NHAL_StatusTypeDef HAL_DFSDM_FilterInjectedStop_DMA(DFSDM_Filter_HandleTypeDef *hdfsdm_filter);
NHAL_StatusTypeDef HAL_DFSDM_FilterAwdStart_IT(DFSDM_Filter_HandleTypeDef *hdfsdm_filter,
N                                              DFSDM_Filter_AwdParamTypeDef* awdParam);
NHAL_StatusTypeDef HAL_DFSDM_FilterAwdStop_IT(DFSDM_Filter_HandleTypeDef *hdfsdm_filter);
NHAL_StatusTypeDef HAL_DFSDM_FilterExdStart(DFSDM_Filter_HandleTypeDef *hdfsdm_filter, uint32_t Channel);
NHAL_StatusTypeDef HAL_DFSDM_FilterExdStop(DFSDM_Filter_HandleTypeDef *hdfsdm_filter);
N
Nint32_t  HAL_DFSDM_FilterGetRegularValue(DFSDM_Filter_HandleTypeDef *hdfsdm_filter, uint32_t* Channel);
Nint32_t  HAL_DFSDM_FilterGetInjectedValue(DFSDM_Filter_HandleTypeDef *hdfsdm_filter, uint32_t* Channel);
Nint32_t  HAL_DFSDM_FilterGetExdMaxValue(DFSDM_Filter_HandleTypeDef *hdfsdm_filter, uint32_t* Channel);
Nint32_t  HAL_DFSDM_FilterGetExdMinValue(DFSDM_Filter_HandleTypeDef *hdfsdm_filter, uint32_t* Channel);
Nuint32_t HAL_DFSDM_FilterGetConvTimeValue(DFSDM_Filter_HandleTypeDef *hdfsdm_filter);
N
Nvoid HAL_DFSDM_IRQHandler(DFSDM_Filter_HandleTypeDef *hdfsdm_filter);
N
NHAL_StatusTypeDef HAL_DFSDM_FilterPollForRegConversion(DFSDM_Filter_HandleTypeDef *hdfsdm_filter, uint32_t Timeout);
NHAL_StatusTypeDef HAL_DFSDM_FilterPollForInjConversion(DFSDM_Filter_HandleTypeDef *hdfsdm_filter, uint32_t Timeout);
N
Nvoid HAL_DFSDM_FilterRegConvCpltCallback(DFSDM_Filter_HandleTypeDef *hdfsdm_filter);
Nvoid HAL_DFSDM_FilterRegConvHalfCpltCallback(DFSDM_Filter_HandleTypeDef *hdfsdm_filter);
Nvoid HAL_DFSDM_FilterInjConvCpltCallback(DFSDM_Filter_HandleTypeDef *hdfsdm_filter);
Nvoid HAL_DFSDM_FilterInjConvHalfCpltCallback(DFSDM_Filter_HandleTypeDef *hdfsdm_filter);
Nvoid HAL_DFSDM_FilterAwdCallback(DFSDM_Filter_HandleTypeDef *hdfsdm_filter, uint32_t Channel, uint32_t Threshold);
Nvoid HAL_DFSDM_FilterErrorCallback(DFSDM_Filter_HandleTypeDef *hdfsdm_filter);
N/**
N  * @}
N  */
N
N/** @defgroup DFSDM_Exported_Functions_Group4_Filter Filter state functions
N  * @{
N  */
N/* Filter state functions *****************************************************/
NHAL_DFSDM_Filter_StateTypeDef HAL_DFSDM_FilterGetState(DFSDM_Filter_HandleTypeDef *hdfsdm_filter);
Nuint32_t                      HAL_DFSDM_FilterGetError(DFSDM_Filter_HandleTypeDef *hdfsdm_filter);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/* End of exported functions -------------------------------------------------*/
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup DFSDM_Private_Macros DFSDM Private Macros
N* @{
N*/
N#define IS_DFSDM_CHANNEL_OUTPUT_CLOCK(CLOCK)          (((CLOCK) == DFSDM_CHANNEL_OUTPUT_CLOCK_SYSTEM) || \
N                                                       ((CLOCK) == DFSDM_CHANNEL_OUTPUT_CLOCK_AUDIO))
X#define IS_DFSDM_CHANNEL_OUTPUT_CLOCK(CLOCK)          (((CLOCK) == DFSDM_CHANNEL_OUTPUT_CLOCK_SYSTEM) ||                                                        ((CLOCK) == DFSDM_CHANNEL_OUTPUT_CLOCK_AUDIO))
N#define IS_DFSDM_CHANNEL_OUTPUT_CLOCK_DIVIDER(DIVIDER) ((2 <= (DIVIDER)) && ((DIVIDER) <= 256))
N#define IS_DFSDM_CHANNEL_INPUT(INPUT)                 (((INPUT) == DFSDM_CHANNEL_EXTERNAL_INPUTS) || \
N                                                       ((INPUT) == DFSDM_CHANNEL_INTERNAL_REGISTER))
X#define IS_DFSDM_CHANNEL_INPUT(INPUT)                 (((INPUT) == DFSDM_CHANNEL_EXTERNAL_INPUTS) ||                                                        ((INPUT) == DFSDM_CHANNEL_INTERNAL_REGISTER))
N#define IS_DFSDM_CHANNEL_DATA_PACKING(MODE)           (((MODE) == DFSDM_CHANNEL_STANDARD_MODE) || \
N                                                       ((MODE) == DFSDM_CHANNEL_INTERLEAVED_MODE) || \
N                                                       ((MODE) == DFSDM_CHANNEL_DUAL_MODE))
X#define IS_DFSDM_CHANNEL_DATA_PACKING(MODE)           (((MODE) == DFSDM_CHANNEL_STANDARD_MODE) ||                                                        ((MODE) == DFSDM_CHANNEL_INTERLEAVED_MODE) ||                                                        ((MODE) == DFSDM_CHANNEL_DUAL_MODE))
N#define IS_DFSDM_CHANNEL_INPUT_PINS(PINS)             (((PINS) == DFSDM_CHANNEL_SAME_CHANNEL_PINS) || \
N                                                       ((PINS) == DFSDM_CHANNEL_FOLLOWING_CHANNEL_PINS))
X#define IS_DFSDM_CHANNEL_INPUT_PINS(PINS)             (((PINS) == DFSDM_CHANNEL_SAME_CHANNEL_PINS) ||                                                        ((PINS) == DFSDM_CHANNEL_FOLLOWING_CHANNEL_PINS))
N#define IS_DFSDM_CHANNEL_SERIAL_INTERFACE_TYPE(MODE)  (((MODE) == DFSDM_CHANNEL_SPI_RISING) || \
N                                                       ((MODE) == DFSDM_CHANNEL_SPI_FALLING) || \
N                                                       ((MODE) == DFSDM_CHANNEL_MANCHESTER_RISING) || \
N                                                       ((MODE) == DFSDM_CHANNEL_MANCHESTER_FALLING))
X#define IS_DFSDM_CHANNEL_SERIAL_INTERFACE_TYPE(MODE)  (((MODE) == DFSDM_CHANNEL_SPI_RISING) ||                                                        ((MODE) == DFSDM_CHANNEL_SPI_FALLING) ||                                                        ((MODE) == DFSDM_CHANNEL_MANCHESTER_RISING) ||                                                        ((MODE) == DFSDM_CHANNEL_MANCHESTER_FALLING))
N#define IS_DFSDM_CHANNEL_SPI_CLOCK(TYPE)              (((TYPE) == DFSDM_CHANNEL_SPI_CLOCK_EXTERNAL) || \
N                                                       ((TYPE) == DFSDM_CHANNEL_SPI_CLOCK_INTERNAL) || \
N                                                       ((TYPE) == DFSDM_CHANNEL_SPI_CLOCK_INTERNAL_DIV2_FALLING) || \
N                                                       ((TYPE) == DFSDM_CHANNEL_SPI_CLOCK_INTERNAL_DIV2_RISING))
X#define IS_DFSDM_CHANNEL_SPI_CLOCK(TYPE)              (((TYPE) == DFSDM_CHANNEL_SPI_CLOCK_EXTERNAL) ||                                                        ((TYPE) == DFSDM_CHANNEL_SPI_CLOCK_INTERNAL) ||                                                        ((TYPE) == DFSDM_CHANNEL_SPI_CLOCK_INTERNAL_DIV2_FALLING) ||                                                        ((TYPE) == DFSDM_CHANNEL_SPI_CLOCK_INTERNAL_DIV2_RISING))
N#define IS_DFSDM_CHANNEL_FILTER_ORDER(ORDER)          (((ORDER) == DFSDM_CHANNEL_FASTSINC_ORDER) || \
N                                                       ((ORDER) == DFSDM_CHANNEL_SINC1_ORDER) || \
N                                                       ((ORDER) == DFSDM_CHANNEL_SINC2_ORDER) || \
N                                                       ((ORDER) == DFSDM_CHANNEL_SINC3_ORDER))
X#define IS_DFSDM_CHANNEL_FILTER_ORDER(ORDER)          (((ORDER) == DFSDM_CHANNEL_FASTSINC_ORDER) ||                                                        ((ORDER) == DFSDM_CHANNEL_SINC1_ORDER) ||                                                        ((ORDER) == DFSDM_CHANNEL_SINC2_ORDER) ||                                                        ((ORDER) == DFSDM_CHANNEL_SINC3_ORDER))
N#define IS_DFSDM_CHANNEL_FILTER_OVS_RATIO(RATIO)       ((1 <= (RATIO)) && ((RATIO) <= 32))
N#define IS_DFSDM_CHANNEL_OFFSET(VALUE)                 ((-8388608 <= (VALUE)) && ((VALUE) <= 8388607))
N#define IS_DFSDM_CHANNEL_RIGHT_BIT_SHIFT(VALUE)        ((VALUE) <= 0x1F)
N#define IS_DFSDM_CHANNEL_SCD_THRESHOLD(VALUE)          ((VALUE) <= 0xFF)
N#define IS_DFSDM_FILTER_REG_TRIGGER(TRIG)             (((TRIG) == DFSDM_FILTER_SW_TRIGGER) || \
N                                                       ((TRIG) == DFSDM_FILTER_SYNC_TRIGGER))
X#define IS_DFSDM_FILTER_REG_TRIGGER(TRIG)             (((TRIG) == DFSDM_FILTER_SW_TRIGGER) ||                                                        ((TRIG) == DFSDM_FILTER_SYNC_TRIGGER))
N#define IS_DFSDM_FILTER_INJ_TRIGGER(TRIG)             (((TRIG) == DFSDM_FILTER_SW_TRIGGER) || \
N                                                       ((TRIG) == DFSDM_FILTER_SYNC_TRIGGER) || \
N                                                       ((TRIG) == DFSDM_FILTER_EXT_TRIGGER))
X#define IS_DFSDM_FILTER_INJ_TRIGGER(TRIG)             (((TRIG) == DFSDM_FILTER_SW_TRIGGER) ||                                                        ((TRIG) == DFSDM_FILTER_SYNC_TRIGGER) ||                                                        ((TRIG) == DFSDM_FILTER_EXT_TRIGGER))
N#define IS_DFSDM_FILTER_EXT_TRIG(TRIG)                (((TRIG) == DFSDM_FILTER_EXT_TRIG_TIM1_TRGO) || \
N                                                       ((TRIG) == DFSDM_FILTER_EXT_TRIG_TIM1_TRGO2)|| \
N                                                       ((TRIG) == DFSDM_FILTER_EXT_TRIG_TIM8_TRGO) || \
N                                                       ((TRIG) == DFSDM_FILTER_EXT_TRIG_TIM8_TRGO2)|| \
N                                                       ((TRIG) == DFSDM_FILTER_EXT_TRIG_TIM3_TRGO) || \
N                                                       ((TRIG) == DFSDM_FILTER_EXT_TRIG_TIM4_TRGO) || \
N                                                       ((TRIG) == DFSDM_FILTER_EXT_TRIG_TIM10_OC1) || \
N                                                       ((TRIG) == DFSDM_FILTER_EXT_TRIG_TIM6_TRGO) || \
N                                                       ((TRIG) == DFSDM_FILTER_EXT_TRIG_TIM7_TRGO) || \
N                                                       ((TRIG) == DFSDM_FILTER_EXT_TRIG_EXTI11)    || \
N                                                       ((TRIG) == DFSDM_FILTER_EXT_TRIG_EXTI15)    ||\
N                                                       ((TRIG) == DFSDM_FILTER_EXT_TRIG_LPTIM1_OUT))
X#define IS_DFSDM_FILTER_EXT_TRIG(TRIG)                (((TRIG) == DFSDM_FILTER_EXT_TRIG_TIM1_TRGO) ||                                                        ((TRIG) == DFSDM_FILTER_EXT_TRIG_TIM1_TRGO2)||                                                        ((TRIG) == DFSDM_FILTER_EXT_TRIG_TIM8_TRGO) ||                                                        ((TRIG) == DFSDM_FILTER_EXT_TRIG_TIM8_TRGO2)||                                                        ((TRIG) == DFSDM_FILTER_EXT_TRIG_TIM3_TRGO) ||                                                        ((TRIG) == DFSDM_FILTER_EXT_TRIG_TIM4_TRGO) ||                                                        ((TRIG) == DFSDM_FILTER_EXT_TRIG_TIM10_OC1) ||                                                        ((TRIG) == DFSDM_FILTER_EXT_TRIG_TIM6_TRGO) ||                                                        ((TRIG) == DFSDM_FILTER_EXT_TRIG_TIM7_TRGO) ||                                                        ((TRIG) == DFSDM_FILTER_EXT_TRIG_EXTI11)    ||                                                        ((TRIG) == DFSDM_FILTER_EXT_TRIG_EXTI15)    ||                                                       ((TRIG) == DFSDM_FILTER_EXT_TRIG_LPTIM1_OUT))
N#define IS_DFSDM_FILTER_EXT_TRIG_EDGE(EDGE)           (((EDGE) == DFSDM_FILTER_EXT_TRIG_RISING_EDGE)  || \
N                                                       ((EDGE) == DFSDM_FILTER_EXT_TRIG_FALLING_EDGE)  || \
N                                                       ((EDGE) == DFSDM_FILTER_EXT_TRIG_BOTH_EDGES))
X#define IS_DFSDM_FILTER_EXT_TRIG_EDGE(EDGE)           (((EDGE) == DFSDM_FILTER_EXT_TRIG_RISING_EDGE)  ||                                                        ((EDGE) == DFSDM_FILTER_EXT_TRIG_FALLING_EDGE)  ||                                                        ((EDGE) == DFSDM_FILTER_EXT_TRIG_BOTH_EDGES))
N#define IS_DFSDM_FILTER_SINC_ORDER(ORDER)             (((ORDER) == DFSDM_FILTER_FASTSINC_ORDER) || \
N                                                       ((ORDER) == DFSDM_FILTER_SINC1_ORDER) || \
N                                                       ((ORDER) == DFSDM_FILTER_SINC2_ORDER) || \
N                                                       ((ORDER) == DFSDM_FILTER_SINC3_ORDER) || \
N                                                       ((ORDER) == DFSDM_FILTER_SINC4_ORDER) || \
N                                                       ((ORDER) == DFSDM_FILTER_SINC5_ORDER))
X#define IS_DFSDM_FILTER_SINC_ORDER(ORDER)             (((ORDER) == DFSDM_FILTER_FASTSINC_ORDER) ||                                                        ((ORDER) == DFSDM_FILTER_SINC1_ORDER) ||                                                        ((ORDER) == DFSDM_FILTER_SINC2_ORDER) ||                                                        ((ORDER) == DFSDM_FILTER_SINC3_ORDER) ||                                                        ((ORDER) == DFSDM_FILTER_SINC4_ORDER) ||                                                        ((ORDER) == DFSDM_FILTER_SINC5_ORDER))
N#define IS_DFSDM_FILTER_OVS_RATIO(RATIO)               ((1 <= (RATIO)) && ((RATIO) <= 1024))
N#define IS_DFSDM_FILTER_INTEGRATOR_OVS_RATIO(RATIO)    ((1 <= (RATIO)) && ((RATIO) <= 256))
N#define IS_DFSDM_FILTER_AWD_DATA_SOURCE(DATA)         (((DATA) == DFSDM_FILTER_AWD_FILTER_DATA)  || \
N                                                       ((DATA) == DFSDM_FILTER_AWD_CHANNEL_DATA))
X#define IS_DFSDM_FILTER_AWD_DATA_SOURCE(DATA)         (((DATA) == DFSDM_FILTER_AWD_FILTER_DATA)  ||                                                        ((DATA) == DFSDM_FILTER_AWD_CHANNEL_DATA))
N#define IS_DFSDM_FILTER_AWD_THRESHOLD(VALUE)           ((-8388608 <= (VALUE)) && ((VALUE) <= 8388607))
N#define IS_DFSDM_BREAK_SIGNALS(VALUE)                  ((VALUE) <= 0xFU)
N#define IS_DFSDM_REGULAR_CHANNEL(CHANNEL)             (((CHANNEL) == DFSDM_CHANNEL_0)  || \
N                                                       ((CHANNEL) == DFSDM_CHANNEL_1)  || \
N                                                       ((CHANNEL) == DFSDM_CHANNEL_2)  || \
N                                                       ((CHANNEL) == DFSDM_CHANNEL_3)  || \
N                                                       ((CHANNEL) == DFSDM_CHANNEL_4)  || \
N                                                       ((CHANNEL) == DFSDM_CHANNEL_5)  || \
N                                                       ((CHANNEL) == DFSDM_CHANNEL_6)  || \
N                                                       ((CHANNEL) == DFSDM_CHANNEL_7))
X#define IS_DFSDM_REGULAR_CHANNEL(CHANNEL)             (((CHANNEL) == DFSDM_CHANNEL_0)  ||                                                        ((CHANNEL) == DFSDM_CHANNEL_1)  ||                                                        ((CHANNEL) == DFSDM_CHANNEL_2)  ||                                                        ((CHANNEL) == DFSDM_CHANNEL_3)  ||                                                        ((CHANNEL) == DFSDM_CHANNEL_4)  ||                                                        ((CHANNEL) == DFSDM_CHANNEL_5)  ||                                                        ((CHANNEL) == DFSDM_CHANNEL_6)  ||                                                        ((CHANNEL) == DFSDM_CHANNEL_7))
N#define IS_DFSDM_INJECTED_CHANNEL(CHANNEL)            (((CHANNEL) != 0) && ((CHANNEL) <= 0x000F00FFU))
N#define IS_DFSDM_CONTINUOUS_MODE(MODE)                (((MODE) == DFSDM_CONTINUOUS_CONV_OFF)  || \
N                                                       ((MODE) == DFSDM_CONTINUOUS_CONV_ON))
X#define IS_DFSDM_CONTINUOUS_MODE(MODE)                (((MODE) == DFSDM_CONTINUOUS_CONV_OFF)  ||                                                        ((MODE) == DFSDM_CONTINUOUS_CONV_ON))
N/**
N  * @}
N  */ 
N/* End of private macros -----------------------------------------------------*/
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N#endif /* STM32F765xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */ 
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_DFSDM_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 407 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_DFSDM_MODULE_ENABLED */
N
N#ifdef HAL_DSI_MODULE_ENABLED
S #include "stm32f7xx_hal_dsi.h"
N#endif /* HAL_DSI_MODULE_ENABLED */
N
N#ifdef HAL_JPEG_MODULE_ENABLED
N #include "stm32f7xx_hal_jpeg.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_jpeg.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_jpeg.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of JPEG HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_JPEG_H
N#define __STM32F7xx_HAL_JPEG_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N#if defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 1L || 0L || 0L || 0L
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup JPEG
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup JPEG_Exported_Types JPEG Exported Types
N  * @{
N  */
N
N/** @defgroup JPEG_Configuration_Structure_definition JPEG Configuration for encoding Structure definition
N  * @brief  JPEG encoding configuration Structure definition 
N  * @{
N  */
Ntypedef struct
N{
N  uint8_t  ColorSpace;                /*!< Image Color space : gray-scale, YCBCR, RGB or CMYK
N                                           This parameter can be a value of @ref JPEG_ColorSpace_Type */
N  
N  uint8_t  ChromaSubsampling;         /*!< Chroma Subsampling in case of YCBCR or CMYK color space, 0-> 4:4:4 , 1-> 4:2:2, 2 -> 4:1:1, 3 -> 4:2:0
N                                           This parameter can be a value of @ref JPEG_ChromaSubsampling_Type */
N  
N  uint32_t ImageHeight;               /*!< Image height : number of lines */
N  
N  uint32_t ImageWidth;                /*!< Image width : number of pixels per line */
N  
N  uint8_t  ImageQuality;               /*!< Quality of the JPEG encoding : from 1 to 100 */
N
N}JPEG_ConfTypeDef;
N/** 
N  * @}
N  */
N
N/** @defgroup HAL_JPEG_state_structure_definition HAL JPEG state structure definition
N  * @brief  HAL JPEG State structure definition  
N  * @{
N  */
Ntypedef enum
N{
N  HAL_JPEG_STATE_RESET              = 0x00U,  /*!< JPEG not yet initialized or disabled  */
N  HAL_JPEG_STATE_READY              = 0x01U,  /*!< JPEG initialized and ready for use    */
N  HAL_JPEG_STATE_BUSY               = 0x02U,  /*!< JPEG internal processing is ongoing   */
N  HAL_JPEG_STATE_BUSY_ENCODING      = 0x03U,  /*!< JPEG encoding processing is ongoing   */
N  HAL_JPEG_STATE_BUSY_DECODING      = 0x04U,  /*!< JPEG decoding processing is ongoing   */  
N  HAL_JPEG_STATE_TIMEOUT            = 0x05U,  /*!< JPEG timeout state                    */
N  HAL_JPEG_STATE_ERROR              = 0x06U   /*!< JPEG error state                      */
N}HAL_JPEG_STATETypeDef;
N
N/** 
N  * @}
N  */
N
N
N/** @defgroup JPEG_handle_Structure_definition JPEG handle Structure definition 
N  * @brief  JPEG handle Structure definition  
N  * @{
N  */
Ntypedef struct
N{
N  JPEG_TypeDef             *Instance;        /*!< JPEG peripheral register base address */
N            
N  JPEG_ConfTypeDef         Conf;             /*!< Current JPEG encoding/decoding parameters */
N
N  uint8_t                  *pJpegInBuffPtr;  /*!< Pointer to JPEG processing (encoding, decoding,...) input buffer */
N
N  uint8_t                  *pJpegOutBuffPtr; /*!< Pointer to JPEG processing (encoding, decoding,...) output buffer */
N
N  __IO uint32_t            JpegInCount;      /*!< Internal Counter of input data */
X  volatile uint32_t            JpegInCount;       
N
N  __IO uint32_t            JpegOutCount;     /*!< Internal Counter of output data */
X  volatile uint32_t            JpegOutCount;      
N    
N  uint32_t                 InDataLength;     /*!< Input Buffer Length in Bytes */
N
N  uint32_t                 OutDataLength;    /*!< Output Buffer Length in Bytes */  
N
N  DMA_HandleTypeDef        *hdmain;          /*!< JPEG In DMA handle parameters */
N
N  DMA_HandleTypeDef        *hdmaout;         /*!< JPEG Out DMA handle parameters */
N
N  uint8_t                  CustomQuanTable;  /*!< If set to 1 specify that user customized quantization tables are used */
N      
N  uint8_t                  *QuantTable0;     /*!< Basic Quantization Table for component 0 */
N
N  uint8_t                  *QuantTable1;     /*!< Basic Quantization Table for component 1 */
N      
N  uint8_t                  *QuantTable2;     /*!< Basic Quantization Table for component 2 */
N      
N  uint8_t                  *QuantTable3;     /*!< Basic Quantization Table for component 3 */      
N      
N  HAL_LockTypeDef          Lock;             /*!< JPEG locking object */
N      
N  __IO  HAL_JPEG_STATETypeDef State;         /*!< JPEG peripheral state */
X  volatile  HAL_JPEG_STATETypeDef State;          
N      
N  __IO  uint32_t           ErrorCode;        /*!< JPEG Error code */
X  volatile  uint32_t           ErrorCode;         
N  
N  __IO uint32_t Context;                     /*!< JPEG Internal context */
X  volatile uint32_t Context;                      
N
N}JPEG_HandleTypeDef;
N
N/** 
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup JPEG_Exported_Constants JPEG Exported Constants
N  * @{
N  */
N
N/** @defgroup JPEG_Error_Code_definition JPEG Error Code definition
N  * @brief  JPEG Error Code definition  
N  * @{
N  */ 
N
N#define  HAL_JPEG_ERROR_NONE        ((uint32_t)0x00000000U)    /*!< No error             */
N#define  HAL_JPEG_ERROR_HUFF_TABLE  ((uint32_t)0x00000001U)    /*!< HUffman Table programming error */
N#define  HAL_JPEG_ERROR_QUANT_TABLE ((uint32_t)0x00000002U)    /*!< Quantization Table programming error */
N#define  HAL_JPEG_ERROR_DMA         ((uint32_t)0x00000004U)    /*!< DMA transfer error   */
N#define  HAL_JPEG_ERROR_TIMEOUT     ((uint32_t)0x00000008U)    /*!< Timeout error        */
N
N/** 
N  * @}
N  */
N
N/** @defgroup JPEG_Quantization_Table_Size JPEG Quantization Table Size
N  * @brief  JPEG Quantization Table Size  
N  * @{
N  */
N#define JPEG_QUANT_TABLE_SIZE  ((uint32_t)64U)
N/**
N  * @}
N  */
N
N  
N/** @defgroup JPEG_ColorSpace_Type JPEG ColorSpace
N  * @brief  JPEG Color Space  
N  * @{
N  */
N#define JPEG_GRAYSCALE_COLORSPACE     ((uint32_t)0x00000000U)
N#define JPEG_YCBCR_COLORSPACE         JPEG_CONFR1_COLORSPACE_0
N#define JPEG_CMYK_COLORSPACE          JPEG_CONFR1_COLORSPACE
N
N
N/**
N  * @}
N  */
N
N
N/** @defgroup JPEG_ChromaSubsampling_Type JPEG Chrominance Sampling
N  * @brief  JPEG Chrominance Sampling  
N  * @{
N  */
N#define JPEG_444_SUBSAMPLING     ((uint32_t)0x00000000U)   /*!< Chroma Subsampling 4:4:4 */
N#define JPEG_420_SUBSAMPLING     ((uint32_t)0x00000001U)   /*!< Chroma Subsampling 4:2:0 */
N#define JPEG_422_SUBSAMPLING     ((uint32_t)0x00000002U)   /*!< Chroma Subsampling 4:2:2 */
N
N/**
N  * @}
N  */ 
N
N/** @defgroup JPEG_ImageQuality JPEG Image Quality
N  * @brief  JPEG Min and Max Image Quality  
N  * @{
N  */
N#define JPEG_IMAGE_QUALITY_MIN     ((uint32_t)1U)     /*!< Minimum JPEG quality */
N#define JPEG_IMAGE_QUALITY_MAX     ((uint32_t)100U)   /*!< Maximum JPEG quality */
N
N/**
N  * @}
N  */     
N  
N/** @defgroup JPEG_Interrupt_configuration_definition JPEG Interrupt configuration definition
N  * @brief JPEG Interrupt definition
N  * @{
N  */
N#define JPEG_IT_IFT     ((uint32_t)JPEG_CR_IFTIE)   /*!< Input FIFO Threshold Interrupt */
N#define JPEG_IT_IFNF    ((uint32_t)JPEG_CR_IFNFIE)  /*!< Input FIFO Not Full Interrupt */
N#define JPEG_IT_OFT     ((uint32_t)JPEG_CR_OFTIE)   /*!< Output FIFO Threshold Interrupt */
N#define JPEG_IT_OFNE    ((uint32_t)JPEG_CR_OFTIE)   /*!< Output FIFO Not Empty Interrupt */
N#define JPEG_IT_EOC     ((uint32_t)JPEG_CR_EOCIE)   /*!< End of Conversion Interrupt */
N#define JPEG_IT_HPD     ((uint32_t)JPEG_CR_HPDIE)   /*!< Header Parsing Done Interrupt */ 
N/**
N  * @}
N  */  
N
N/** @defgroup JPEG_Flag_definition JPEG Flag definition
N  * @brief JPEG Flags definition
N  * @{
N  */ 
N#define JPEG_FLAG_IFTF     ((uint32_t)JPEG_SR_IFTF)   /*!< Input FIFO is not full and is bellow its threshold flag */
N#define JPEG_FLAG_IFNFF    ((uint32_t)JPEG_SR_IFNFF)  /*!< Input FIFO Not Full Flag, a data can be written */
N#define JPEG_FLAG_OFTF     ((uint32_t)JPEG_SR_OFTF)   /*!< Output FIFO is not empty and has reach its threshold */
N#define JPEG_FLAG_OFNEF    ((uint32_t)JPEG_SR_OFNEF)  /*!< Output FIFO is not empty, a data is available  */
N#define JPEG_FLAG_EOCF     ((uint32_t)JPEG_SR_EOCF)   /*!< JPEG Codec core has finished the encoding or the decoding process and than last data has been sent to the output FIFO  */
N#define JPEG_FLAG_HPDF     ((uint32_t)JPEG_SR_HPDF)   /*!< JPEG Codec has finished the parsing of the headers and the internal registers have been updated  */
N#define JPEG_FLAG_COF      ((uint32_t)JPEG_SR_COF)    /*!< JPEG Codec operation on going  flag*/
N
N#define JPEG_FLAG_ALL      ((uint32_t)0x000000FEU)     /*!< JPEG Codec All previous flag*/
N/**
N  * @}
N  */
N
N/** @defgroup JPEG_PROCESS_PAUSE_RESUME_definition JPEG Process Pause Resume definition
N  * @brief JPEG process pause, resume definition
N  * @{
N  */  
N#define JPEG_PAUSE_RESUME_INPUT          ((uint32_t)0x00000001U)     /*!< Pause/Resume Input FIFO Xfer*/
N#define JPEG_PAUSE_RESUME_OUTPUT         ((uint32_t)0x00000002U)     /*!< Pause/Resume Output FIFO Xfer*/
N#define JPEG_PAUSE_RESUME_INPUT_OUTPUT   ((uint32_t)0x00000003U)     /*!< Pause/Resume Input and Output FIFO Xfer*/
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/* Exported macro ------------------------------------------------------------*/
N
N/** @defgroup JPEG_Exported_Macros JPEG Exported Macros
N  * @{
N  */
N
N/** @brief Reset JPEG handle state
N  * @param  __HANDLE__: specifies the JPEG handle.
N  * @retval None
N  */
N#define __HAL_JPEG_RESET_HANDLE_STATE(__HANDLE__) ( (__HANDLE__)->State = HAL_JPEG_STATE_RESET)
N
N
N/**
N  * @brief  Enable the JPEG peripheral.
N  * @param  __HANDLE__: specifies the JPEG handle.
N  * @retval None
N  */
N#define __HAL_JPEG_ENABLE(__HANDLE__)  ((__HANDLE__)->Instance->CR |=  JPEG_CR_JCEN)
N
N/**
N  * @brief Disable the JPEG peripheral.
N  * @param  __HANDLE__: specifies the JPEG handle.
N  * @retval None
N  */
N#define __HAL_JPEG_DISABLE(__HANDLE__) ((__HANDLE__)->Instance->CR &=  ~JPEG_CR_JCEN)
N
N
N/**
N  * @brief  Check the specified JPEG status flag.
N  * @param  __HANDLE__: specifies the JPEG handle. 
N  * @param  __FLAG__ : specifies the flag to check
N  *         This parameter can be one of the following values:
N  *         @arg JPEG_FLAG_IFTF  : The input FIFO is not full and is bellow its threshold flag
N  *         @arg JPEG_FLAG_IFNFF : The input FIFO Not Full Flag, a data can be written
N  *         @arg JPEG_FLAG_OFTF  : The output FIFO is not empty and has reach its threshold
N  *         @arg JPEG_FLAG_OFNEF : The output FIFO is not empty, a data is available
N  *         @arg JPEG_FLAG_EOCF  : JPEG Codec core has finished the encoding or the decoding process 
N  *                                and than last data has been sent to the output FIFO
N  *         @arg JPEG_FLAG_HPDF  : JPEG Codec has finished the parsing of the headers 
N  *                                and the internal registers have been updated
N  *         @arg JPEG_FLAG_COF   : JPEG Codec operation on going  flag
N  *                        
N  * @retval : __HAL_JPEG_GET_FLAG : returns The new state of __FLAG__ (TRUE or FALSE)  
N  */
N
N#define __HAL_JPEG_GET_FLAG(__HANDLE__,__FLAG__)  (((__HANDLE__)->Instance->SR & (__FLAG__)))
N
N/**
N  * @brief  Clear the specified JPEG status flag.
N  * @param  __HANDLE__: specifies the JPEG handle. 
N  * @param  __FLAG__ : specifies the flag to clear
N  *         This parameter can be one of the following values:
N  *         @arg JPEG_FLAG_EOCF  : JPEG Codec core has finished the encoding or the decoding process 
N  *                                and than last data has been sent to the output FIFO
N  *         @arg JPEG_FLAG_HPDF  : JPEG Codec has finished the parsing of the headers 
N  * @retval : None    
N  */
N
N#define __HAL_JPEG_CLEAR_FLAG(__HANDLE__,__FLAG__)  (((__HANDLE__)->Instance->CFR |= ((__FLAG__) & (JPEG_FLAG_EOCF | JPEG_FLAG_HPDF))))
N
N
N/**
N  * @brief  Enable Interrupt.
N  * @param   __HANDLE__: specifies the JPEG handle.
N  * @param  __INTERRUPT__ : specifies the interrupt to enable
N  *         This parameter can be one of the following values:
N  *         @arg JPEG_IT_IFT   : Input FIFO Threshold Interrupt
N  *         @arg JPEG_IT_IFNF  : Input FIFO Not Full Interrupt
N  *         @arg JPEG_IT_OFT   : Output FIFO Threshold Interrupt
N  *         @arg JPEG_IT_OFNE  : Output FIFO Not empty Interrupt
N  *         @arg JPEG_IT_EOC   : End of Conversion Interrupt
N  *         @arg JPEG_IT_HPD   : Header Parsing Done Interrupt       
N  *           
N  * @retval : No retrun 
N  */
N#define __HAL_JPEG_ENABLE_IT(__HANDLE__,__INTERRUPT__)  ((__HANDLE__)->Instance->CR |= (__INTERRUPT__) )
N
N/**
N  * @brief  Disable Interrupt.
N  * @param   __HANDLE__: specifies the JPEG handle.
N  * @param  __INTERRUPT__ : specifies the interrupt to disable
N  *         This parameter can be one of the following values:
N  *         @arg JPEG_IT_IFT   : Input FIFO Threshold Interrupt
N  *         @arg JPEG_IT_IFNF  : Input FIFO Not Full Interrupt
N  *         @arg JPEG_IT_OFT   : Output FIFO Threshold Interrupt
N  *         @arg JPEG_IT_OFNE  : Output FIFO Not empty Interrupt
N  *         @arg JPEG_IT_EOC   : End of Conversion Interrupt
N  *         @arg JPEG_IT_HPD   : Header Parsing Done Interrupt       
N  *           
N  * @note  : To disable an IT we must use MODIFY_REG macro to avoid writing "1" to the FIFO flush bits 
N  *          located in the same IT enable register (CR register).  
N  * @retval : No retrun 
N  */
N#define __HAL_JPEG_DISABLE_IT(__HANDLE__,__INTERRUPT__) MODIFY_REG((__HANDLE__)->Instance->CR, (__INTERRUPT__), 0)
N
N
N/**
N  * @brief  Get Interrupt state.
N  * @param   __HANDLE__: specifies the JPEG handle.
N  * @param  __INTERRUPT__ : specifies the interrupt to check
N  *         This parameter can be one of the following values:
N  *         @arg JPEG_IT_IFT   : Input FIFO Threshold Interrupt
N  *         @arg JPEG_IT_IFNF  : Input FIFO Not Full Interrupt
N  *         @arg JPEG_IT_OFT   : Output FIFO Threshold Interrupt
N  *         @arg JPEG_IT_OFNE  : Output FIFO Not empty Interrupt
N  *         @arg JPEG_IT_EOC   : End of Conversion Interrupt
N  *         @arg JPEG_IT_HPD   : Header Parsing Done Interrupt       
N  *           
N  * @retval : returns The new state of __INTERRUPT__ (Enabled or disabled)
N  */
N#define __HAL_JPEG_GET_IT_SOURCE(__HANDLE__,__INTERRUPT__)     ((__HANDLE__)->Instance->CR & (__INTERRUPT__))
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup JPEG_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup JPEG_Exported_Functions_Group1
N  * @{
N  */    
N/* Initialization/de-initialization functions  ********************************/
NHAL_StatusTypeDef HAL_JPEG_Init(JPEG_HandleTypeDef *hjpeg);
NHAL_StatusTypeDef HAL_JPEG_DeInit(JPEG_HandleTypeDef *hjpeg);
Nvoid HAL_JPEG_MspInit(JPEG_HandleTypeDef *hjpeg);
Nvoid HAL_JPEG_MspDeInit(JPEG_HandleTypeDef *hjpeg);
N
N/**
N  * @}
N  */
N
N/** @addtogroup JPEG_Exported_Functions_Group2
N  * @{
N  */ 
N/* Encoding/Decoding Configuration functions  ********************************/
NHAL_StatusTypeDef HAL_JPEG_ConfigEncoding(JPEG_HandleTypeDef *hjpeg, JPEG_ConfTypeDef *pConf);
NHAL_StatusTypeDef HAL_JPEG_GetInfo(JPEG_HandleTypeDef *hjpeg, JPEG_ConfTypeDef *pInfo);
NHAL_StatusTypeDef HAL_JPEG_EnableHeaderParsing(JPEG_HandleTypeDef *hjpeg);
NHAL_StatusTypeDef HAL_JPEG_DisableHeaderParsing(JPEG_HandleTypeDef *hjpeg);
NHAL_StatusTypeDef HAL_JPEG_SetUserQuantTables(JPEG_HandleTypeDef *hjpeg, uint8_t *QTable0, uint8_t *QTable1, uint8_t *QTable2, uint8_t *QTable3);
N
N/**
N  * @}
N  */
N
N/** @addtogroup JPEG_Exported_Functions_Group3
N  * @{
N  */ 
N/* JPEG processing functions  **************************************/
NHAL_StatusTypeDef  HAL_JPEG_Encode(JPEG_HandleTypeDef *hjpeg, uint8_t *pDataInMCU, uint32_t InDataLength, uint8_t *pDataOut, uint32_t OutDataLength, uint32_t Timeout);
NHAL_StatusTypeDef  HAL_JPEG_Decode(JPEG_HandleTypeDef *hjpeg ,uint8_t *pDataIn ,uint32_t InDataLength ,uint8_t *pDataOutMCU ,uint32_t OutDataLength, uint32_t Timeout);
NHAL_StatusTypeDef  HAL_JPEG_Encode_IT(JPEG_HandleTypeDef *hjpeg, uint8_t *pDataInMCU, uint32_t InDataLength, uint8_t *pDataOut, uint32_t OutDataLength);
NHAL_StatusTypeDef  HAL_JPEG_Decode_IT(JPEG_HandleTypeDef *hjpeg ,uint8_t *pDataIn ,uint32_t InDataLength ,uint8_t *pDataOutMCU ,uint32_t OutDataLength);
NHAL_StatusTypeDef  HAL_JPEG_Encode_DMA(JPEG_HandleTypeDef *hjpeg, uint8_t *pDataInMCU, uint32_t InDataLength, uint8_t *pDataOut, uint32_t OutDataLength);
NHAL_StatusTypeDef  HAL_JPEG_Decode_DMA(JPEG_HandleTypeDef *hjpeg ,uint8_t *pDataIn ,uint32_t InDataLength ,uint8_t *pDataOutMCU ,uint32_t OutDataLength);
NHAL_StatusTypeDef  HAL_JPEG_Pause(JPEG_HandleTypeDef *hjpeg, uint32_t XferSelection);
NHAL_StatusTypeDef  HAL_JPEG_Resume(JPEG_HandleTypeDef *hjpeg, uint32_t XferSelection);
Nvoid HAL_JPEG_ConfigInputBuffer(JPEG_HandleTypeDef *hjpeg, uint8_t *pNewInputBuffer, uint32_t InDataLength);
Nvoid HAL_JPEG_ConfigOutputBuffer(JPEG_HandleTypeDef *hjpeg, uint8_t *pNewOutputBuffer, uint32_t OutDataLength);
NHAL_StatusTypeDef HAL_JPEG_Abort(JPEG_HandleTypeDef *hjpeg);
N
N/**
N  * @}
N  */
N
N/** @addtogroup JPEG_Exported_Functions_Group4
N  * @{
N  */ 
N/* JPEG Decode/Encode callback functions  ********************************************************/
Nvoid HAL_JPEG_InfoReadyCallback(JPEG_HandleTypeDef *hjpeg,JPEG_ConfTypeDef *pInfo);
Nvoid HAL_JPEG_EncodeCpltCallback(JPEG_HandleTypeDef *hjpeg);
Nvoid HAL_JPEG_DecodeCpltCallback(JPEG_HandleTypeDef *hjpeg);
Nvoid HAL_JPEG_ErrorCallback(JPEG_HandleTypeDef *hjpeg);
Nvoid HAL_JPEG_GetDataCallback(JPEG_HandleTypeDef *hjpeg, uint32_t NbDecodedData);
Nvoid HAL_JPEG_DataReadyCallback (JPEG_HandleTypeDef *hjpeg, uint8_t *pDataOut, uint32_t OutDataLength);
N
N/**
N  * @}
N  */
N
N/** @addtogroup JPEG_Exported_Functions_Group5
N  * @{
N  */ 
N/* JPEG IRQ handler management  ******************************************************/
Nvoid HAL_JPEG_IRQHandler(JPEG_HandleTypeDef *hjpeg);
N
N/**
N  * @}
N  */
N
N/** @addtogroup JPEG_Exported_Functions_Group6
N  * @{
N  */ 
N/* Peripheral State and Error functions  ************************************************/
NHAL_JPEG_STATETypeDef  HAL_JPEG_GetState(JPEG_HandleTypeDef *hjpeg);
Nuint32_t               HAL_JPEG_GetError(JPEG_HandleTypeDef *hjpeg);
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/* Private types -------------------------------------------------------------*/
N/** @defgroup JPEG_Private_Types JPEG Private Types
N  * @{
N  */
N
N/**
N  * @}
N  */ 
N
N/* Private defines -----------------------------------------------------------*/
N/** @defgroup JPEG_Private_Defines JPEG Private Defines
N  * @{
N  */
N
N/**
N  * @}
N  */ 
N          
N/* Private variables ---------------------------------------------------------*/
N/** @defgroup JPEG_Private_Variables JPEG Private Variables
N  * @{
N  */
N
N/**
N  * @}
N  */ 
N
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup JPEG_Private_Constants JPEG Private Constants
N  * @{
N  */
N
N/**
N  * @}
N  */ 
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup JPEG_Private_Macros JPEG Private Macros
N  * @{
N  */
N
N/** @defgroup JPEG_IS_Definitions JPEG Private macros to check input parameters
N  * @{
N  */
N
N#define IS_JPEG_CHROMASUBSAMPLING(SUBSAMPLING) (((SUBSAMPLING) == JPEG_444_SUBSAMPLING) || \
N                                                ((SUBSAMPLING) == JPEG_420_SUBSAMPLING) || \
N                                                ((SUBSAMPLING) == JPEG_422_SUBSAMPLING))
X#define IS_JPEG_CHROMASUBSAMPLING(SUBSAMPLING) (((SUBSAMPLING) == JPEG_444_SUBSAMPLING) ||                                                 ((SUBSAMPLING) == JPEG_420_SUBSAMPLING) ||                                                 ((SUBSAMPLING) == JPEG_422_SUBSAMPLING))
N
N#define IS_JPEG_IMAGE_QUALITY(NUMBER) (((NUMBER) >= JPEG_IMAGE_QUALITY_MIN) && ((NUMBER) <= JPEG_IMAGE_QUALITY_MAX))
N
N#define IS_JPEG_COLORSPACE(COLORSPACE) (((COLORSPACE) == JPEG_GRAYSCALE_COLORSPACE) || \
N                                        ((COLORSPACE) == JPEG_YCBCR_COLORSPACE)     || \
N                                        ((COLORSPACE) == JPEG_CMYK_COLORSPACE))
X#define IS_JPEG_COLORSPACE(COLORSPACE) (((COLORSPACE) == JPEG_GRAYSCALE_COLORSPACE) ||                                         ((COLORSPACE) == JPEG_YCBCR_COLORSPACE)     ||                                         ((COLORSPACE) == JPEG_CMYK_COLORSPACE))
N
N#define IS_JPEG_PAUSE_RESUME_STATE(VALUE) (((VALUE) == JPEG_PAUSE_RESUME_INPUT) || \
N                                           ((VALUE) == JPEG_PAUSE_RESUME_OUTPUT)|| \
N                                           ((VALUE) == JPEG_PAUSE_RESUME_INPUT_OUTPUT))
X#define IS_JPEG_PAUSE_RESUME_STATE(VALUE) (((VALUE) == JPEG_PAUSE_RESUME_INPUT) ||                                            ((VALUE) == JPEG_PAUSE_RESUME_OUTPUT)||                                            ((VALUE) == JPEG_PAUSE_RESUME_INPUT_OUTPUT))
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/* Private functions prototypes ----------------------------------------------*/
N/** @defgroup JPEG_Private_Functions_Prototypes JPEG Private Functions Prototypes
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup JPEG_Private_Functions JPEG Private Functions
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif /* STM32F767xx ||  STM32F769xx ||  STM32F777xx ||  STM32F779xx */ 
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_JPEG_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 415 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_JPEG_MODULE_ENABLED */
N
N#ifdef HAL_MDIOS_MODULE_ENABLED
N #include "stm32f7xx_hal_mdios.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal_mdios.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal_mdios.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   Header file of MDIOS HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_MDIOS_H
N#define __STM32F7xx_HAL_MDIOS_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#if defined (MDIOS)
X#if 1L
N   
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_def.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup MDIOS
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup MDIOS_Exported_Types MDIOS Exported Types
N  * @{
N  */
N   
N/** @defgroup MDIOS_Exported_Types_Group1 MDIOS State structures definition
N  * @{
N  */
N
Ntypedef enum
N{
N  HAL_MDIOS_STATE_RESET             = 0x00U,    /*!< Peripheral not yet Initialized or disabled         */
N  HAL_MDIOS_STATE_READY             = 0x01U,    /*!< Peripheral Initialized and ready for use           */
N  HAL_MDIOS_STATE_BUSY              = 0x02U,    /*!< an internal process is ongoing                     */
N  HAL_MDIOS_STATE_ERROR             = 0x04U     /*!< Reception process is ongoing                       */
N}HAL_MDIOS_StateTypeDef;
N
N/** 
N  * @}
N  */
N
N/** @defgroup MDIOS_Exported_Types_Group2 MDIOS Init Structure definition
N  * @{
N  */
N
Ntypedef struct
N{
N  uint32_t PortAddress;           /*!< Specifies the MDIOS port address.   
N                                       This parameter can be a value from 0 to 31 */
N  uint32_t PreambleCheck;         /*!< Specifies whether the preamble check is enabled or disabled.   
N                                       This parameter can be a value of @ref MDIOS_Preamble_Check */   
N}MDIOS_InitTypeDef;
N
N/** 
N  * @}
N  */
N
N/** @defgroup MDIOS_Exported_Types_Group4 MDIOS handle Structure definition
N  * @{
N  */
N
Ntypedef struct
N{
N  MDIOS_TypeDef                *Instance;     /*!< Register base address       */
N  
N  MDIOS_InitTypeDef            Init;          /*!< MDIOS Init Structure        */
N  
N  __IO HAL_MDIOS_StateTypeDef  State;         /*!< MDIOS communication state   */
X  volatile HAL_MDIOS_StateTypeDef  State;          
N  
N  HAL_LockTypeDef              Lock;          /*!< MDIOS Lock                  */
N}MDIOS_HandleTypeDef;
N
N/** 
N  * @}
N  */
N
N/** 
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup MDIOS_Exported_Constants MDIOS Exported Constants
N  * @{
N  */
N
N/** @defgroup MDIOS_Preamble_Check  MDIOS Preamble Check
N  * @{
N  */
N#define MDIOS_PREAMBLE_CHECK_ENABLE      ((uint32_t)0x00000000U)
N#define MDIOS_PREAMBLE_CHECK_DISABLE     MDIOS_CR_DPC  
N/**
N  * @}
N  */
N
N/** @defgroup MDIOS_Input_Output_Registers_Definitions MDIOS Input Output Registers Definitions
N  * @{
N  */
N#define MDIOS_REG0                      ((uint32_t)0x00000000U)
N#define MDIOS_REG1                      ((uint32_t)0x00000001U)
N#define MDIOS_REG2                      ((uint32_t)0x00000002U)
N#define MDIOS_REG3                      ((uint32_t)0x00000003U)
N#define MDIOS_REG4                      ((uint32_t)0x00000004U)
N#define MDIOS_REG5                      ((uint32_t)0x00000005U)
N#define MDIOS_REG6                      ((uint32_t)0x00000006U)
N#define MDIOS_REG7                      ((uint32_t)0x00000007U)
N#define MDIOS_REG8                      ((uint32_t)0x00000008U)
N#define MDIOS_REG9                      ((uint32_t)0x00000009U)
N#define MDIOS_REG10                     ((uint32_t)0x0000000AU)
N#define MDIOS_REG11                     ((uint32_t)0x0000000BU)
N#define MDIOS_REG12                     ((uint32_t)0x0000000CU)
N#define MDIOS_REG13                     ((uint32_t)0x0000000DU)
N#define MDIOS_REG14                     ((uint32_t)0x0000000EU)
N#define MDIOS_REG15                     ((uint32_t)0x0000000FU)
N#define MDIOS_REG16                     ((uint32_t)0x00000010U)
N#define MDIOS_REG17                     ((uint32_t)0x00000011U)
N#define MDIOS_REG18                     ((uint32_t)0x00000012U)
N#define MDIOS_REG19                     ((uint32_t)0x00000013U)
N#define MDIOS_REG20                     ((uint32_t)0x00000014U)
N#define MDIOS_REG21                     ((uint32_t)0x00000015U)
N#define MDIOS_REG22                     ((uint32_t)0x00000016U)
N#define MDIOS_REG23                     ((uint32_t)0x00000017U)
N#define MDIOS_REG24                     ((uint32_t)0x00000018U)
N#define MDIOS_REG25                     ((uint32_t)0x00000019U)
N#define MDIOS_REG26                     ((uint32_t)0x0000001AU)
N#define MDIOS_REG27                     ((uint32_t)0x0000001BU)
N#define MDIOS_REG28                     ((uint32_t)0x0000001CU)
N#define MDIOS_REG29                     ((uint32_t)0x0000001DU)
N#define MDIOS_REG30                     ((uint32_t)0x0000001EU)
N#define MDIOS_REG31                     ((uint32_t)0x0000001FU)
N/**
N  * @}
N  */ 
N
N/** @defgroup MDIOS_Registers_Flags  MDIOS Registers Flags
N  * @{
N  */
N#define MDIOS_REG0_FLAG			((uint32_t)0x00000001U)
N#define	MDIOS_REG1_FLAG			((uint32_t)0x00000002U)
N#define	MDIOS_REG2_FLAG			((uint32_t)0x00000004U)
N#define	MDIOS_REG3_FLAG			((uint32_t)0x00000008U)
N#define	MDIOS_REG4_FLAG			((uint32_t)0x00000010U)
N#define	MDIOS_REG5_FLAG			((uint32_t)0x00000020U)
N#define	MDIOS_REG6_FLAG			((uint32_t)0x00000040U)
N#define	MDIOS_REG7_FLAG			((uint32_t)0x00000080U)
N#define	MDIOS_REG8_FLAG			((uint32_t)0x00000100U)
N#define	MDIOS_REG9_FLAG			((uint32_t)0x00000200U)
N#define	MDIOS_REG10_FLAG		((uint32_t)0x00000400U)
N#define	MDIOS_REG11_FLAG		((uint32_t)0x00000800U)
N#define	MDIOS_REG12_FLAG		((uint32_t)0x00001000U)
N#define	MDIOS_REG13_FLAG		((uint32_t)0x00002000U)
N#define	MDIOS_REG14_FLAG		((uint32_t)0x00004000U)
N#define	MDIOS_REG15_FLAG		((uint32_t)0x00008000U)
N#define	MDIOS_REG16_FLAG		((uint32_t)0x00010000U)
N#define	MDIOS_REG17_FLAG		((uint32_t)0x00020000U)
N#define	MDIOS_REG18_FLAG		((uint32_t)0x00040000U)
N#define	MDIOS_REG19_FLAG		((uint32_t)0x00080000U)
N#define	MDIOS_REG20_FLAG		((uint32_t)0x00100000U)
N#define	MDIOS_REG21_FLAG		((uint32_t)0x00200000U)
N#define	MDIOS_REG22_FLAG		((uint32_t)0x00400000U)
N#define	MDIOS_REG23_FLAG		((uint32_t)0x00800000U)
N#define	MDIOS_REG24_FLAG		((uint32_t)0x01000000U)
N#define	MDIOS_REG25_FLAG		((uint32_t)0x02000000U)
N#define	MDIOS_REG26_FLAG		((uint32_t)0x04000000U)
N#define	MDIOS_REG27_FLAG		((uint32_t)0x08000000U)
N#define	MDIOS_REG28_FLAG		((uint32_t)0x10000000U)
N#define	MDIOS_REG29_FLAG		((uint32_t)0x20000000U)
N#define	MDIOS_REG30_FLAG		((uint32_t)0x40000000U)
N#define	MDIOS_REG31_FLAG		((uint32_t)0x80000000U)
N#define	MDIOS_ALLREG_FLAG		((uint32_t)0xFFFFFFFFU)
N/**
N  * @}
N  */
N
N/** @defgroup MDIOS_Interrupt_sources Interrupt Sources
N  * @{
N  */
N#define MDIOS_IT_WRITE                   MDIOS_CR_WRIE
N#define MDIOS_IT_READ                    MDIOS_CR_RDIE
N#define MDIOS_IT_ERROR                   MDIOS_CR_EIE
N/**
N  * @}
N  */
N
N/** @defgroup MDIOS_Interrupt_Flags  MDIOS Interrupt Flags
N  * @{
N  */
N#define	MDIOS_TURNAROUND_ERROR_FLAG       MDIOS_SR_TERF
N#define	MDIOS_START_ERROR_FLAG            MDIOS_SR_SERF
N#define	MDIOS_PREAMBLE_ERROR_FLAG         MDIOS_SR_PERF
N/**
N  * @}
N  */
N
N /** @defgroup MDIOS_Wakeup_Line  MDIOS Wakeup Line
N  * @{
N  */
N#define MDIOS_WAKEUP_EXTI_LINE  ((uint32_t)0x01000000)  /* !<  EXTI Line 24 */
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */
N/* Exported macros -----------------------------------------------------------*/
N/** @defgroup MDIOS_Exported_Macros MDIOS Exported Macros
N  * @{
N  */
N
N/** @brief Reset MDIOS handle state
N  * @param  __HANDLE__: MDIOS handle.
N  * @retval None
N  */
N#define __HAL_MDIOS_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_MDIOS_STATE_RESET)
N
N/**
N  * @brief  Enable/Disable the MDIOS peripheral.
N  * @param  __HANDLE__: specifies the MDIOS handle.
N  * @retval None
N  */
N#define __HAL_MDIOS_ENABLE(__HANDLE__) ((__HANDLE__)->Instance->CR |= MDIOS_CR_EN)
N#define __HAL_MDIOS_DISABLE(__HANDLE__) ((__HANDLE__)->Instance->CR &= ~MDIOS_CR_EN)
N
N
N/**
N  * @brief  Enable the MDIOS device interrupt.
N  * @param  __HANDLE__: specifies the MDIOS handle.
N  * @param  __INTERRUPT__ : specifies the MDIOS interrupt sources to be enabled.
N  *         This parameter can be one or a combination of the following values:
N  *            @arg MDIOS_IT_WRITE: Register write interrupt
N  *            @arg MDIOS_IT_READ: Register read interrupt
N  *            @arg MDIOS_IT_ERROR: Error interrupt 
N  * @retval None
N  */
N#define __HAL_MDIOS_ENABLE_IT(__HANDLE__, __INTERRUPT__)  ((__HANDLE__)->Instance->CR |= (__INTERRUPT__))
N
N/**
N  * @brief  Disable the MDIOS device interrupt.
N  * @param  __HANDLE__: specifies the MDIOS handle.
N  * @param  __INTERRUPT__ : specifies the MDIOS interrupt sources to be disabled.
N  *         This parameter can be one or a combination of the following values:
N  *            @arg MDIOS_IT_WRITE: Register write interrupt
N  *            @arg MDIOS_IT_READ: Register read interrupt
N  *            @arg MDIOS_IT_ERROR: Error interrupt 
N  * @retval None
N  */
N#define __HAL_MDIOS_DISABLE_IT(__HANDLE__, __INTERRUPT__)  ((__HANDLE__)->Instance->CR &= ~(__INTERRUPT__))
N
N/** @brief Set MDIOS slave get write register flag
N  * @param  __HANDLE__: specifies the MDIOS handle.
N  * @param  __FLAG__: specifies the write register flag
N  * @retval The state of write flag
N  */
N#define __HAL_MDIOS_GET_WRITE_FLAG(__HANDLE__, __FLAG__)      ((__HANDLE__)->Instance->WRFR &  (__FLAG__))
N
N/** @brief MDIOS slave get read register flag
N  * @param  __HANDLE__: specifies the MDIOS handle.
N  * @param  __FLAG__: specifies the read register flag
N  * @retval The state of read flag
N  */
N#define __HAL_MDIOS_GET_READ_FLAG(__HANDLE__, __FLAG__)        ((__HANDLE__)->Instance->RDFR &  (__FLAG__))
N
N/** @brief MDIOS slave get interrupt
N  * @param  __HANDLE__: specifies the MDIOS handle.
N  * @param  __FLAG__ : specifies the Error flag.
N  *         This parameter can be one or a combination of the following values:
N  *            @arg MDIOS_TURNARROUND_ERROR_FLAG: Register write interrupt
N  *            @arg MDIOS_START_ERROR_FLAG: Register read interrupt
N  *            @arg MDIOS_PREAMBLE_ERROR_FLAG: Error interrupt 
N  * @retval The state of the error flag
N  */
N#define __HAL_MDIOS_GET_ERROR_FLAG(__HANDLE__, __FLAG__)       ((__HANDLE__)->Instance->SR &  (__FLAG__))
N
N/** @brief  MDIOS slave clear interrupt
N  * @param  __HANDLE__: specifies the MDIOS handle.
N  * @param  __FLAG__ : specifies the Error flag.
N  *         This parameter can be one or a combination of the following values:
N  *            @arg MDIOS_TURNARROUND_ERROR_FLAG: Register write interrupt
N  *            @arg MDIOS_START_ERROR_FLAG: Register read interrupt
N  *            @arg MDIOS_PREAMBLE_ERROR_FLAG: Error interrupt 
N  * @retval none
N  */
N#define __HAL_MDIOS_CLEAR_ERROR_FLAG(__HANDLE__, __FLAG__)       ((__HANDLE__)->Instance->CLRFR) |= (__FLAG__)
N
N/**
N  * @brief  Checks whether the specified MDIOS interrupt is set or not.
N  * @param  __HANDLE__: specifies the MDIOS handle.
N  * @param  __INTERRUPT__ : specifies the MDIOS interrupt sources
N  *            This parameter can be one or a combination of the following values:
N  *            @arg MDIOS_IT_WRITE: Register write interrupt
N  *            @arg MDIOS_IT_READ: Register read interrupt
N  *            @arg MDIOS_IT_ERROR: Error interrupt 
N  * @retval The state of the interrupt source
N  */
N#define __HAL_MDIOS_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) ((__HANDLE__)->Instance->CR & (__INTERRUPT__))
N
N/**
N  * @brief Enable the MDIOS WAKEUP Exti Line.    
N  * @retval None.
N  */
N#define __HAL_MDIOS_WAKEUP_EXTI_ENABLE_IT()   (EXTI->IMR |= (MDIOS_WAKEUP_EXTI_LINE))
N
N/**
N  * @brief Disable the MDIOS WAKEUP Exti Line.    
N  * @retval None.
N  */
N#define __HAL_MDIOS_WAKEUP_EXTI_DISABLE_IT()   (EXTI->IMR &= ~(MDIOS_WAKEUP_EXTI_LINE)) 
N
N/**
N  * @brief Enable event on MDIOS WAKEUP Exti Line.    
N  * @retval None.
N  */
N#define __HAL_MDIOS_WAKEUP_EXTI_ENABLE_EVENT()   (EXTI->EMR |= (MDIOS_WAKEUP_EXTI_LINE))
N
N/**
N  * @brief Disable event on MDIOS WAKEUP Exti Line.    
N  * @retval None.
N  */
N#define __HAL_MDIOS_WAKEUP_EXTI_DISABLE_EVENT()   (EXTI->EMR &= ~(MDIOS_WAKEUP_EXTI_LINE))   
N
N/**
N  * @brief checks whether the specified MDIOS WAKEUP Exti interrupt flag is set or not. 
N  * @retval EXTI MDIOS WAKEUP Line Status.
N  */
N#define __HAL_MDIOS_WAKEUP_EXTI_GET_FLAG()  (EXTI->PR & (MDIOS_WAKEUP_EXTI_LINE))
N
N/**
N  * @brief Clear the MDIOS WAKEUP Exti flag. 
N  * @retval None.
N  */
N#define __HAL_MDIOS_WAKEUP_EXTI_CLEAR_FLAG() (EXTI->PR = (MDIOS_WAKEUP_EXTI_LINE))
N
N/**
N  * @brief  Enables rising edge trigger to the MDIOS External interrupt line.
N  * @retval None
N  */
N#define __HAL_MDIOS_WAKEUP_EXTI_ENABLE_RISING_EDGE_TRIGGER()  EXTI->RTSR |= MDIOS_WAKEUP_EXTI_LINE
N                                                            
N/**
N  * @brief  Disables the rising edge trigger to the MDIOS External interrupt line.
N  * @retval None
N  */
N#define __HAL_MDIOS_WAKEUP_EXTI_DISABLE_RISING_EDGE_TRIGGER()  EXTI->RTSR &= ~(MDIOS_WAKEUP_EXTI_LINE)                                                          
N
N/**
N  * @brief  Enables falling edge trigger to the MDIOS External interrupt line.
N  * @retval None
N  */                                                      
N#define __HAL_MDIOS_WAKEUP_EXTI_ENABLE_FALLING_EDGE_TRIGGER()  EXTI->FTSR |= (MDIOS_WAKEUP_EXTI_LINE)
N
N/**
N  * @brief  Disables falling edge trigger to the MDIOS External interrupt line.
N  * @retval None
N  */
N#define __HAL_MDIOS_WAKEUP_EXTI_DISABLE_FALLING_EDGE_TRIGGER()  EXTI->FTSR &= ~(MDIOS_WAKEUP_EXTI_LINE)
N
N/**
N  * @brief  Enables rising/falling edge trigger to the MDIOS External interrupt line.
N  * @retval None
N  */
N#define __HAL_MDIOS_WAKEUP_EXTI_ENABLE_FALLINGRISING_TRIGGER()  EXTI->RTSR |= MDIOS_WAKEUP_EXTI_LINE;\
N                                                                EXTI->FTSR |= MDIOS_WAKEUP_EXTI_LINE
X#define __HAL_MDIOS_WAKEUP_EXTI_ENABLE_FALLINGRISING_TRIGGER()  EXTI->RTSR |= MDIOS_WAKEUP_EXTI_LINE;                                                                EXTI->FTSR |= MDIOS_WAKEUP_EXTI_LINE
N
N/**
N  * @brief  Disables rising/falling edge trigger to the MDIOS External interrupt line.
N  * @retval None
N  */
N#define __HAL_MDIOS_WAKEUP_EXTI_DISABLE_FALLINGRISING_TRIGGER()  EXTI->RTSR &= ~(MDIOS_WAKEUP_EXTI_LINE);\
N                                                                 EXTI->FTSR &= ~(MDIOS_WAKEUP_EXTI_LINE)
X#define __HAL_MDIOS_WAKEUP_EXTI_DISABLE_FALLINGRISING_TRIGGER()  EXTI->RTSR &= ~(MDIOS_WAKEUP_EXTI_LINE);                                                                 EXTI->FTSR &= ~(MDIOS_WAKEUP_EXTI_LINE)
N/**
N  * @brief  Generates a Software interrupt on selected EXTI line.
N  * @retval None
N  */
N#define __HAL_MDIOS_WAKEUP_EXTI_GENERATE_SWIT() (EXTI->SWIER |= (MDIOS_WAKEUP_EXTI_LINE))  
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup MDIOS_Exported_Functions MDIOS Exported Functions
N  * @{
N  */
N
N/** @addtogroup MDIOS_Exported_Functions_Group1
N  * @{
N  */
NHAL_StatusTypeDef HAL_MDIOS_Init(MDIOS_HandleTypeDef *hmdios);
NHAL_StatusTypeDef HAL_MDIOS_DeInit(MDIOS_HandleTypeDef *hmdios);
Nvoid HAL_MDIOS_MspInit(MDIOS_HandleTypeDef *hmdios);
Nvoid  HAL_MDIOS_MspDeInit(MDIOS_HandleTypeDef *hmdios);
N/**
N  * @}
N  */
N
N/** @addtogroup MDIOS_Exported_Functions_Group2
N  * @{
N  */
NHAL_StatusTypeDef HAL_MDIOS_WriteReg(MDIOS_HandleTypeDef *hmdios,  uint32_t RegNum, uint16_t Data);
NHAL_StatusTypeDef HAL_MDIOS_ReadReg(MDIOS_HandleTypeDef *hmdios,  uint32_t RegNum, uint16_t *pData);
N
Nuint32_t HAL_MDIOS_GetWrittenRegAddress(MDIOS_HandleTypeDef *hmdios);
Nuint32_t HAL_MDIOS_GetReadRegAddress(MDIOS_HandleTypeDef *hmdios);
NHAL_StatusTypeDef HAL_MDIOS_ClearWriteRegAddress(MDIOS_HandleTypeDef *hmdios, uint32_t RegNum);
NHAL_StatusTypeDef HAL_MDIOS_ClearReadRegAddress(MDIOS_HandleTypeDef *hmdios, uint32_t RegNum);
N
NHAL_StatusTypeDef HAL_MDIOS_EnableEvents(MDIOS_HandleTypeDef *hmdios);
Nvoid HAL_MDIOS_IRQHandler(MDIOS_HandleTypeDef *hmdios);
Nvoid HAL_MDIOS_WriteCpltCallback(MDIOS_HandleTypeDef *hmdios);
Nvoid HAL_MDIOS_ReadCpltCallback(MDIOS_HandleTypeDef *hmdios);
Nvoid HAL_MDIOS_ErrorCallback(MDIOS_HandleTypeDef *hmdios);
Nvoid HAL_MDIOS_WakeUpCallback(MDIOS_HandleTypeDef *hmdios);
N/**
N  * @}
N  */
N
N/** @addtogroup MDIOS_Exported_Functions_Group3
N  * @{
N  */
Nuint32_t HAL_MDIOS_GetError(MDIOS_HandleTypeDef *hmdios);
NHAL_MDIOS_StateTypeDef HAL_MDIOS_GetState(MDIOS_HandleTypeDef *hmdios);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private types -------------------------------------------------------------*/
N/** @defgroup MDIOS_Private_Types MDIOS Private Types
N  * @{
N  */
N
N/**
N  * @}
N  */ 
N
N/* Private variables ---------------------------------------------------------*/
N/** @defgroup MDIOS_Private_Variables MDIOS Private Variables
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup MDIOS_Private_Constants MDIOS Private Constants
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup MDIOS_Private_Macros MDIOS Private Macros
N  * @{
N  */
N
N#define IS_MDIOS_PORTADDRESS(__ADDR__) ((__ADDR__) < 32)
N
N#define IS_MDIOS_REGISTER(__REGISTER__) ((__REGISTER__) < 32)
N
N#define IS_MDIOS_PREAMBLECHECK(__PREAMBLECHECK__) (((__PREAMBLECHECK__) == MDIOS_PREAMBLE_CHECK_ENABLE) || \
N                                                   ((__PREAMBLECHECK__) == MDIOS_PREAMBLE_CHECK_DISABLE))
X#define IS_MDIOS_PREAMBLECHECK(__PREAMBLECHECK__) (((__PREAMBLECHECK__) == MDIOS_PREAMBLE_CHECK_ENABLE) ||                                                    ((__PREAMBLECHECK__) == MDIOS_PREAMBLE_CHECK_DISABLE))
N
N /**
N  * @}
N  */
N  
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup MDIOS_Private_Functions MDIOS Private Functions
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif /* MDIOS */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_MDIOS_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 419 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx_hal_conf.h" 2
N#endif /* HAL_MDIOS_MODULE_ENABLED */
N   
N/* Exported macro ------------------------------------------------------------*/
N#ifdef  USE_FULL_ASSERT
S/**
S  * @brief  The assert_param macro is used for function's parameters check.
S  * @param  expr: If expr is false, it calls assert_failed function
S  *         which reports the name of the source file and the source
S  *         line number of the call that failed. 
S  *         If expr is true, it returns no value.
S  * @retval None
S  */
S  #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
S/* Exported functions ------------------------------------------------------- */
S  void assert_failed(uint8_t* file, uint32_t line);
N#else
N  #define assert_param(expr) ((void)0)
N#endif /* USE_FULL_ASSERT */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_CONF_H */
N 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 200 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf\stm32f7xx.h" 2
N#endif /* USE_HAL_DRIVER */
N
N#ifdef __cplusplus
S}
N#endif /* __cplusplus */
N
N#endif /* __STM32F7xx_H */
N
N/**
N  * @}
N  */
N
N  /**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 12 "..\..\MProkaron\Include\Platform/CortexM_RVM/Chips/STM32F767IG/platform_STM32F767IG_RVM.h" 2
N#include "core_cm7.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Core\core_cm7.h" 1
N/**************************************************************************//**
N * @file     core_cm7.h
N * @brief    CMSIS Cortex-M7 Core Peripheral Access Layer Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060183 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM7_H_GENERIC
S#define __CORE_CM7_H_GENERIC
S
S#include <stdint.h>
S
S#ifdef __cplusplus
S extern "C" {
S#endif
S
S/**
S  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
S  CMSIS violates the following MISRA-C:2004 rules:
S
S   \li Required Rule 8.5, object/function definition in header file.<br>
S     Function definitions in header files are used to allow 'inlining'.
S
S   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
S     Unions are used for effective representation of core registers.
S
S   \li Advisory Rule 19.7, Function-like macro defined.<br>
S     Function-like macros are used to allow more efficient code.
S */
S
S
S/*******************************************************************************
S *                 CMSIS definitions
S ******************************************************************************/
S/**
S  \ingroup Cortex_M7
S  @{
S */
S
S/*  CMSIS CM7 definitions */
S#define __CM7_CMSIS_VERSION_MAIN  (0x04U)                                      /*!< [31:16] CMSIS HAL main version */
S#define __CM7_CMSIS_VERSION_SUB   (0x1EU)                                      /*!< [15:0]  CMSIS HAL sub version */
S#define __CM7_CMSIS_VERSION       ((__CM7_CMSIS_VERSION_MAIN << 16U) | \
S                                    __CM7_CMSIS_VERSION_SUB           )        /*!< CMSIS HAL version number */
X#define __CM7_CMSIS_VERSION       ((__CM7_CMSIS_VERSION_MAIN << 16U) |                                     __CM7_CMSIS_VERSION_SUB           )         
S
S#define __CORTEX_M                (0x07U)                                      /*!< Cortex-M Core */
S
S
S#if   defined ( __CC_ARM )
S  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
S  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
S  #define __STATIC_INLINE  static __inline
S
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
S  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
S  #define __STATIC_INLINE  static __inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TMS470__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __CSMC__ )
S  #define __packed
S  #define __ASM            _asm                                      /*!< asm keyword for COSMIC Compiler */
S  #define __INLINE         inline                                    /*!< inline keyword for COSMIC Compiler. Use -pc99 on compile line */
S  #define __STATIC_INLINE  static inline
S
S#else
S  #error Unknown compiler
S#endif
S
S/** __FPU_USED indicates whether an FPU is used or not.
S    For this, __FPU_PRESENT has to be checked prior to making use of FPU specific registers and functions.
S*/
S#if defined ( __CC_ARM )
S  #if defined __TARGET_FPU_VFP
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_PCS_VFP
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1U
S    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __TMS470__ )
S  #if defined __TI_VFP_SUPPORT__
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#endif
S
S#include "core_cmInstr.h"                /* Core Instruction Access */
S#include "core_cmFunc.h"                 /* Core Function Access */
S#include "core_cmSimd.h"                 /* Compiler specific SIMD Intrinsics */
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif /* __CORE_CM7_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM7_H_DEPENDANT
S#define __CORE_CM7_H_DEPENDANT
S
S#ifdef __cplusplus
S extern "C" {
S#endif
S
S/* check device defines and use defaults */
S#if defined __CHECK_DEVICE_DEFINES
S  #ifndef __CM7_REV
S    #define __CM7_REV               0x0000U
S    #warning "__CM7_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __FPU_PRESENT
S    #define __FPU_PRESENT             0U
S    #warning "__FPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0U
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __ICACHE_PRESENT
S    #define __ICACHE_PRESENT          0U
S    #warning "__ICACHE_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __DCACHE_PRESENT
S    #define __DCACHE_PRESENT          0U
S    #warning "__DCACHE_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __DTCM_PRESENT
S    #define __DTCM_PRESENT            0U
S    #warning "__DTCM_PRESENT        not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          3U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
S#endif
S
S/* IO definitions (access restrictions to peripheral registers) */
S/**
S    \defgroup CMSIS_glob_defs CMSIS Global Defines
S
S    <strong>IO Type Qualifiers</strong> are used
S    \li to specify the access to peripheral variables.
S    \li for automatic generation of peripheral register debug information.
S*/
S#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
S#else
S  #define   __I     volatile const       /*!< Defines 'read only' permissions */
S#endif
S#define     __O     volatile             /*!< Defines 'write only' permissions */
S#define     __IO    volatile             /*!< Defines 'read / write' permissions */
S
S/* following defines should be used for structure members */
S#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
S#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
S#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
S
S/*@} end of group Cortex_M7 */
S
S
S
S/*******************************************************************************
S *                 Register Abstraction
S  Core Register contain:
S  - Core Register
S  - Core NVIC Register
S  - Core SCB Register
S  - Core SysTick Register
S  - Core Debug Register
S  - Core MPU Register
S  - Core FPU Register
S ******************************************************************************/
S/**
S  \defgroup CMSIS_core_register Defines and Type Definitions
S  \brief Type definitions and defines for Cortex-M processor based devices.
S*/
S
S/**
S  \ingroup    CMSIS_core_register
S  \defgroup   CMSIS_CORE  Status and Control Registers
S  \brief      Core Register type definitions.
S  @{
S */
S
S/**
S  \brief  Union type to access the Application Program Status Register (APSR).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
S    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved */
S    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
S    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
S    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
S    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
S    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
S  } b;                                   /*!< Structure used for bit  access */
S  uint32_t w;                            /*!< Type      used for word access */
S} APSR_Type;
S
S/* APSR Register Definitions */
S#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
S#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
S
S#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
S#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
S
S#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
S#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
S
S#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
S#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
S
S#define APSR_Q_Pos                         27U                                            /*!< APSR: Q Position */
S#define APSR_Q_Msk                         (1UL << APSR_Q_Pos)                            /*!< APSR: Q Mask */
S
S#define APSR_GE_Pos                        16U                                            /*!< APSR: GE Position */
S#define APSR_GE_Msk                        (0xFUL << APSR_GE_Pos)                         /*!< APSR: GE Mask */
S
S
S/**
S  \brief  Union type to access the Interrupt Program Status Register (IPSR).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
S    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
S  } b;                                   /*!< Structure used for bit  access */
S  uint32_t w;                            /*!< Type      used for word access */
S} IPSR_Type;
S
S/* IPSR Register Definitions */
S#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
S#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
S
S
S/**
S  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
S    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
S    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved */
S    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
S    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0) */
S    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
S    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
S    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
S    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
S    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
S  } b;                                   /*!< Structure used for bit  access */
S  uint32_t w;                            /*!< Type      used for word access */
S} xPSR_Type;
S
S/* xPSR Register Definitions */
S#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
S#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
S
S#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
S#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
S
S#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
S#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
S
S#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
S#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
S
S#define xPSR_Q_Pos                         27U                                            /*!< xPSR: Q Position */
S#define xPSR_Q_Msk                         (1UL << xPSR_Q_Pos)                            /*!< xPSR: Q Mask */
S
S#define xPSR_IT_Pos                        25U                                            /*!< xPSR: IT Position */
S#define xPSR_IT_Msk                        (3UL << xPSR_IT_Pos)                           /*!< xPSR: IT Mask */
S
S#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
S#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
S
S#define xPSR_GE_Pos                        16U                                            /*!< xPSR: GE Position */
S#define xPSR_GE_Msk                        (0xFUL << xPSR_GE_Pos)                         /*!< xPSR: GE Mask */
S
S#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
S#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
S
S
S/**
S  \brief  Union type to access the Control Registers (CONTROL).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
S    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
S    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag */
S    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved */
S  } b;                                   /*!< Structure used for bit  access */
S  uint32_t w;                            /*!< Type      used for word access */
S} CONTROL_Type;
S
S/* CONTROL Register Definitions */
S#define CONTROL_FPCA_Pos                    2U                                            /*!< CONTROL: FPCA Position */
S#define CONTROL_FPCA_Msk                   (1UL << CONTROL_FPCA_Pos)                      /*!< CONTROL: FPCA Mask */
S
S#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
S#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
S
S#define CONTROL_nPRIV_Pos                   0U                                            /*!< CONTROL: nPRIV Position */
S#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
S
S/*@} end of group CMSIS_CORE */
S
S
S/**
S  \ingroup    CMSIS_core_register
S  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
S  \brief      Type definitions for the NVIC Registers
S  @{
S */
S
S/**
S  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
S */
Stypedef struct
S{
S  __IOM uint32_t ISER[8U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
S        uint32_t RESERVED0[24U];
S  __IOM uint32_t ICER[8U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
S        uint32_t RSERVED1[24U];
S  __IOM uint32_t ISPR[8U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
S        uint32_t RESERVED2[24U];
S  __IOM uint32_t ICPR[8U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
S        uint32_t RESERVED3[24U];
S  __IOM uint32_t IABR[8U];               /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register */
S        uint32_t RESERVED4[56U];
S  __IOM uint8_t  IP[240U];               /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
S        uint32_t RESERVED5[644U];
S  __OM  uint32_t STIR;                   /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register */
S}  NVIC_Type;
S
S/* Software Triggered Interrupt Register Definitions */
S#define NVIC_STIR_INTID_Pos                 0U                                         /*!< STIR: INTLINESNUM Position */
S#define NVIC_STIR_INTID_Msk                (0x1FFUL /*<< NVIC_STIR_INTID_Pos*/)        /*!< STIR: INTLINESNUM Mask */
S
S/*@} end of group CMSIS_NVIC */
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_SCB     System Control Block (SCB)
S  \brief    Type definitions for the System Control Block Registers
S  @{
S */
S
S/**
S  \brief  Structure type to access the System Control Block (SCB).
S */
Stypedef struct
S{
S  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
S  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
S  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
S  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
S  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
S  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
S  __IOM uint8_t  SHPR[12U];              /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
S  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
S  __IOM uint32_t CFSR;                   /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register */
S  __IOM uint32_t HFSR;                   /*!< Offset: 0x02C (R/W)  HardFault Status Register */
S  __IOM uint32_t DFSR;                   /*!< Offset: 0x030 (R/W)  Debug Fault Status Register */
S  __IOM uint32_t MMFAR;                  /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register */
S  __IOM uint32_t BFAR;                   /*!< Offset: 0x038 (R/W)  BusFault Address Register */
S  __IOM uint32_t AFSR;                   /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register */
S  __IM  uint32_t ID_PFR[2U];             /*!< Offset: 0x040 (R/ )  Processor Feature Register */
S  __IM  uint32_t ID_DFR;                 /*!< Offset: 0x048 (R/ )  Debug Feature Register */
S  __IM  uint32_t ID_AFR;                 /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register */
S  __IM  uint32_t ID_MFR[4U];             /*!< Offset: 0x050 (R/ )  Memory Model Feature Register */
S  __IM  uint32_t ID_ISAR[5U];            /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register */
S        uint32_t RESERVED0[1U];
S  __IM  uint32_t CLIDR;                  /*!< Offset: 0x078 (R/ )  Cache Level ID register */
S  __IM  uint32_t CTR;                    /*!< Offset: 0x07C (R/ )  Cache Type register */
S  __IM  uint32_t CCSIDR;                 /*!< Offset: 0x080 (R/ )  Cache Size ID Register */
S  __IOM uint32_t CSSELR;                 /*!< Offset: 0x084 (R/W)  Cache Size Selection Register */
S  __IOM uint32_t CPACR;                  /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register */
S        uint32_t RESERVED3[93U];
S  __OM  uint32_t STIR;                   /*!< Offset: 0x200 ( /W)  Software Triggered Interrupt Register */
S        uint32_t RESERVED4[15U];
S  __IM  uint32_t MVFR0;                  /*!< Offset: 0x240 (R/ )  Media and VFP Feature Register 0 */
S  __IM  uint32_t MVFR1;                  /*!< Offset: 0x244 (R/ )  Media and VFP Feature Register 1 */
S  __IM  uint32_t MVFR2;                  /*!< Offset: 0x248 (R/ )  Media and VFP Feature Register 1 */
S        uint32_t RESERVED5[1U];
S  __OM  uint32_t ICIALLU;                /*!< Offset: 0x250 ( /W)  I-Cache Invalidate All to PoU */
S        uint32_t RESERVED6[1U];
S  __OM  uint32_t ICIMVAU;                /*!< Offset: 0x258 ( /W)  I-Cache Invalidate by MVA to PoU */
S  __OM  uint32_t DCIMVAC;                /*!< Offset: 0x25C ( /W)  D-Cache Invalidate by MVA to PoC */
S  __OM  uint32_t DCISW;                  /*!< Offset: 0x260 ( /W)  D-Cache Invalidate by Set-way */
S  __OM  uint32_t DCCMVAU;                /*!< Offset: 0x264 ( /W)  D-Cache Clean by MVA to PoU */
S  __OM  uint32_t DCCMVAC;                /*!< Offset: 0x268 ( /W)  D-Cache Clean by MVA to PoC */
S  __OM  uint32_t DCCSW;                  /*!< Offset: 0x26C ( /W)  D-Cache Clean by Set-way */
S  __OM  uint32_t DCCIMVAC;               /*!< Offset: 0x270 ( /W)  D-Cache Clean and Invalidate by MVA to PoC */
S  __OM  uint32_t DCCISW;                 /*!< Offset: 0x274 ( /W)  D-Cache Clean and Invalidate by Set-way */
S        uint32_t RESERVED7[6U];
S  __IOM uint32_t ITCMCR;                 /*!< Offset: 0x290 (R/W)  Instruction Tightly-Coupled Memory Control Register */
S  __IOM uint32_t DTCMCR;                 /*!< Offset: 0x294 (R/W)  Data Tightly-Coupled Memory Control Registers */
S  __IOM uint32_t AHBPCR;                 /*!< Offset: 0x298 (R/W)  AHBP Control Register */
S  __IOM uint32_t CACR;                   /*!< Offset: 0x29C (R/W)  L1 Cache Control Register */
S  __IOM uint32_t AHBSCR;                 /*!< Offset: 0x2A0 (R/W)  AHB Slave Control Register */
S        uint32_t RESERVED8[1U];
S  __IOM uint32_t ABFSR;                  /*!< Offset: 0x2A8 (R/W)  Auxiliary Bus Fault Status Register */
S} SCB_Type;
S
S/* SCB CPUID Register Definitions */
S#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
S#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
S
S#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
S#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
S
S#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
S#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
S
S#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
S#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
S
S#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
S#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
S
S/* SCB Interrupt Control State Register Definitions */
S#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
S#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
S
S#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
S#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
S
S#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
S#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
S
S#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
S#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
S
S#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
S#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
S
S#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
S#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
S
S#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
S#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
S
S#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
S#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
S
S#define SCB_ICSR_RETTOBASE_Pos             11U                                            /*!< SCB ICSR: RETTOBASE Position */
S#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
S
S#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
S#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
S
S/* SCB Vector Table Offset Register Definitions */
S#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
S#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
S
S/* SCB Application Interrupt and Reset Control Register Definitions */
S#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
S#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
S
S#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
S#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
S
S#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
S#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
S
S#define SCB_AIRCR_PRIGROUP_Pos              8U                                            /*!< SCB AIRCR: PRIGROUP Position */
S#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
S
S#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
S#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
S
S#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
S#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
S
S#define SCB_AIRCR_VECTRESET_Pos             0U                                            /*!< SCB AIRCR: VECTRESET Position */
S#define SCB_AIRCR_VECTRESET_Msk            (1UL /*<< SCB_AIRCR_VECTRESET_Pos*/)           /*!< SCB AIRCR: VECTRESET Mask */
S
S/* SCB System Control Register Definitions */
S#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
S#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
S
S#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
S#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
S
S#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
S#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
S
S/* SCB Configuration Control Register Definitions */
S#define SCB_CCR_BP_Pos                      18U                                           /*!< SCB CCR: Branch prediction enable bit Position */
S#define SCB_CCR_BP_Msk                     (1UL << SCB_CCR_BP_Pos)                        /*!< SCB CCR: Branch prediction enable bit Mask */
S
S#define SCB_CCR_IC_Pos                      17U                                           /*!< SCB CCR: Instruction cache enable bit Position */
S#define SCB_CCR_IC_Msk                     (1UL << SCB_CCR_IC_Pos)                        /*!< SCB CCR: Instruction cache enable bit Mask */
S
S#define SCB_CCR_DC_Pos                      16U                                           /*!< SCB CCR: Cache enable bit Position */
S#define SCB_CCR_DC_Msk                     (1UL << SCB_CCR_DC_Pos)                        /*!< SCB CCR: Cache enable bit Mask */
S
S#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
S#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
S
S#define SCB_CCR_BFHFNMIGN_Pos               8U                                            /*!< SCB CCR: BFHFNMIGN Position */
S#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
S
S#define SCB_CCR_DIV_0_TRP_Pos               4U                                            /*!< SCB CCR: DIV_0_TRP Position */
S#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
S
S#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
S#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
S
S#define SCB_CCR_USERSETMPEND_Pos            1U                                            /*!< SCB CCR: USERSETMPEND Position */
S#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
S
S#define SCB_CCR_NONBASETHRDENA_Pos          0U                                            /*!< SCB CCR: NONBASETHRDENA Position */
S#define SCB_CCR_NONBASETHRDENA_Msk         (1UL /*<< SCB_CCR_NONBASETHRDENA_Pos*/)        /*!< SCB CCR: NONBASETHRDENA Mask */
S
S/* SCB System Handler Control and State Register Definitions */
S#define SCB_SHCSR_USGFAULTENA_Pos          18U                                            /*!< SCB SHCSR: USGFAULTENA Position */
S#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
S
S#define SCB_SHCSR_BUSFAULTENA_Pos          17U                                            /*!< SCB SHCSR: BUSFAULTENA Position */
S#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
S
S#define SCB_SHCSR_MEMFAULTENA_Pos          16U                                            /*!< SCB SHCSR: MEMFAULTENA Position */
S#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
S
S#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
S#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
S
S#define SCB_SHCSR_BUSFAULTPENDED_Pos       14U                                            /*!< SCB SHCSR: BUSFAULTPENDED Position */
S#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
S
S#define SCB_SHCSR_MEMFAULTPENDED_Pos       13U                                            /*!< SCB SHCSR: MEMFAULTPENDED Position */
S#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
S
S#define SCB_SHCSR_USGFAULTPENDED_Pos       12U                                            /*!< SCB SHCSR: USGFAULTPENDED Position */
S#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
S
S#define SCB_SHCSR_SYSTICKACT_Pos           11U                                            /*!< SCB SHCSR: SYSTICKACT Position */
S#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
S
S#define SCB_SHCSR_PENDSVACT_Pos            10U                                            /*!< SCB SHCSR: PENDSVACT Position */
S#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
S
S#define SCB_SHCSR_MONITORACT_Pos            8U                                            /*!< SCB SHCSR: MONITORACT Position */
S#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
S
S#define SCB_SHCSR_SVCALLACT_Pos             7U                                            /*!< SCB SHCSR: SVCALLACT Position */
S#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
S
S#define SCB_SHCSR_USGFAULTACT_Pos           3U                                            /*!< SCB SHCSR: USGFAULTACT Position */
S#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
S
S#define SCB_SHCSR_BUSFAULTACT_Pos           1U                                            /*!< SCB SHCSR: BUSFAULTACT Position */
S#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
S
S#define SCB_SHCSR_MEMFAULTACT_Pos           0U                                            /*!< SCB SHCSR: MEMFAULTACT Position */
S#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL /*<< SCB_SHCSR_MEMFAULTACT_Pos*/)         /*!< SCB SHCSR: MEMFAULTACT Mask */
S
S/* SCB Configurable Fault Status Register Definitions */
S#define SCB_CFSR_USGFAULTSR_Pos            16U                                            /*!< SCB CFSR: Usage Fault Status Register Position */
S#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
S
S#define SCB_CFSR_BUSFAULTSR_Pos             8U                                            /*!< SCB CFSR: Bus Fault Status Register Position */
S#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
S
S#define SCB_CFSR_MEMFAULTSR_Pos             0U                                            /*!< SCB CFSR: Memory Manage Fault Status Register Position */
S#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL /*<< SCB_CFSR_MEMFAULTSR_Pos*/)        /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
S
S/* SCB Hard Fault Status Register Definitions */
S#define SCB_HFSR_DEBUGEVT_Pos              31U                                            /*!< SCB HFSR: DEBUGEVT Position */
S#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
S
S#define SCB_HFSR_FORCED_Pos                30U                                            /*!< SCB HFSR: FORCED Position */
S#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
S
S#define SCB_HFSR_VECTTBL_Pos                1U                                            /*!< SCB HFSR: VECTTBL Position */
S#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
S
S/* SCB Debug Fault Status Register Definitions */
S#define SCB_DFSR_EXTERNAL_Pos               4U                                            /*!< SCB DFSR: EXTERNAL Position */
S#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
S
S#define SCB_DFSR_VCATCH_Pos                 3U                                            /*!< SCB DFSR: VCATCH Position */
S#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
S
S#define SCB_DFSR_DWTTRAP_Pos                2U                                            /*!< SCB DFSR: DWTTRAP Position */
S#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
S
S#define SCB_DFSR_BKPT_Pos                   1U                                            /*!< SCB DFSR: BKPT Position */
S#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
S
S#define SCB_DFSR_HALTED_Pos                 0U                                            /*!< SCB DFSR: HALTED Position */
S#define SCB_DFSR_HALTED_Msk                (1UL /*<< SCB_DFSR_HALTED_Pos*/)               /*!< SCB DFSR: HALTED Mask */
S
S/* SCB Cache Level ID Register Definitions */
S#define SCB_CLIDR_LOUU_Pos                 27U                                            /*!< SCB CLIDR: LoUU Position */
S#define SCB_CLIDR_LOUU_Msk                 (7UL << SCB_CLIDR_LOUU_Pos)                    /*!< SCB CLIDR: LoUU Mask */
S
S#define SCB_CLIDR_LOC_Pos                  24U                                            /*!< SCB CLIDR: LoC Position */
S#define SCB_CLIDR_LOC_Msk                  (7UL << SCB_CLIDR_LOC_Pos)                     /*!< SCB CLIDR: LoC Mask */
S
S/* SCB Cache Type Register Definitions */
S#define SCB_CTR_FORMAT_Pos                 29U                                            /*!< SCB CTR: Format Position */
S#define SCB_CTR_FORMAT_Msk                 (7UL << SCB_CTR_FORMAT_Pos)                    /*!< SCB CTR: Format Mask */
S
S#define SCB_CTR_CWG_Pos                    24U                                            /*!< SCB CTR: CWG Position */
S#define SCB_CTR_CWG_Msk                    (0xFUL << SCB_CTR_CWG_Pos)                     /*!< SCB CTR: CWG Mask */
S
S#define SCB_CTR_ERG_Pos                    20U                                            /*!< SCB CTR: ERG Position */
S#define SCB_CTR_ERG_Msk                    (0xFUL << SCB_CTR_ERG_Pos)                     /*!< SCB CTR: ERG Mask */
S
S#define SCB_CTR_DMINLINE_Pos               16U                                            /*!< SCB CTR: DminLine Position */
S#define SCB_CTR_DMINLINE_Msk               (0xFUL << SCB_CTR_DMINLINE_Pos)                /*!< SCB CTR: DminLine Mask */
S
S#define SCB_CTR_IMINLINE_Pos                0U                                            /*!< SCB CTR: ImInLine Position */
S#define SCB_CTR_IMINLINE_Msk               (0xFUL /*<< SCB_CTR_IMINLINE_Pos*/)            /*!< SCB CTR: ImInLine Mask */
S
S/* SCB Cache Size ID Register Definitions */
S#define SCB_CCSIDR_WT_Pos                  31U                                            /*!< SCB CCSIDR: WT Position */
S#define SCB_CCSIDR_WT_Msk                  (1UL << SCB_CCSIDR_WT_Pos)                     /*!< SCB CCSIDR: WT Mask */
S
S#define SCB_CCSIDR_WB_Pos                  30U                                            /*!< SCB CCSIDR: WB Position */
S#define SCB_CCSIDR_WB_Msk                  (1UL << SCB_CCSIDR_WB_Pos)                     /*!< SCB CCSIDR: WB Mask */
S
S#define SCB_CCSIDR_RA_Pos                  29U                                            /*!< SCB CCSIDR: RA Position */
S#define SCB_CCSIDR_RA_Msk                  (1UL << SCB_CCSIDR_RA_Pos)                     /*!< SCB CCSIDR: RA Mask */
S
S#define SCB_CCSIDR_WA_Pos                  28U                                            /*!< SCB CCSIDR: WA Position */
S#define SCB_CCSIDR_WA_Msk                  (1UL << SCB_CCSIDR_WA_Pos)                     /*!< SCB CCSIDR: WA Mask */
S
S#define SCB_CCSIDR_NUMSETS_Pos             13U                                            /*!< SCB CCSIDR: NumSets Position */
S#define SCB_CCSIDR_NUMSETS_Msk             (0x7FFFUL << SCB_CCSIDR_NUMSETS_Pos)           /*!< SCB CCSIDR: NumSets Mask */
S
S#define SCB_CCSIDR_ASSOCIATIVITY_Pos        3U                                            /*!< SCB CCSIDR: Associativity Position */
S#define SCB_CCSIDR_ASSOCIATIVITY_Msk       (0x3FFUL << SCB_CCSIDR_ASSOCIATIVITY_Pos)      /*!< SCB CCSIDR: Associativity Mask */
S
S#define SCB_CCSIDR_LINESIZE_Pos             0U                                            /*!< SCB CCSIDR: LineSize Position */
S#define SCB_CCSIDR_LINESIZE_Msk            (7UL /*<< SCB_CCSIDR_LINESIZE_Pos*/)           /*!< SCB CCSIDR: LineSize Mask */
S
S/* SCB Cache Size Selection Register Definitions */
S#define SCB_CSSELR_LEVEL_Pos                1U                                            /*!< SCB CSSELR: Level Position */
S#define SCB_CSSELR_LEVEL_Msk               (7UL << SCB_CSSELR_LEVEL_Pos)                  /*!< SCB CSSELR: Level Mask */
S
S#define SCB_CSSELR_IND_Pos                  0U                                            /*!< SCB CSSELR: InD Position */
S#define SCB_CSSELR_IND_Msk                 (1UL /*<< SCB_CSSELR_IND_Pos*/)                /*!< SCB CSSELR: InD Mask */
S
S/* SCB Software Triggered Interrupt Register Definitions */
S#define SCB_STIR_INTID_Pos                  0U                                            /*!< SCB STIR: INTID Position */
S#define SCB_STIR_INTID_Msk                 (0x1FFUL /*<< SCB_STIR_INTID_Pos*/)            /*!< SCB STIR: INTID Mask */
S
S/* SCB D-Cache Invalidate by Set-way Register Definitions */
S#define SCB_DCISW_WAY_Pos                  30U                                            /*!< SCB DCISW: Way Position */
S#define SCB_DCISW_WAY_Msk                  (3UL << SCB_DCISW_WAY_Pos)                     /*!< SCB DCISW: Way Mask */
S
S#define SCB_DCISW_SET_Pos                   5U                                            /*!< SCB DCISW: Set Position */
S#define SCB_DCISW_SET_Msk                  (0x1FFUL << SCB_DCISW_SET_Pos)                 /*!< SCB DCISW: Set Mask */
S
S/* SCB D-Cache Clean by Set-way Register Definitions */
S#define SCB_DCCSW_WAY_Pos                  30U                                            /*!< SCB DCCSW: Way Position */
S#define SCB_DCCSW_WAY_Msk                  (3UL << SCB_DCCSW_WAY_Pos)                     /*!< SCB DCCSW: Way Mask */
S
S#define SCB_DCCSW_SET_Pos                   5U                                            /*!< SCB DCCSW: Set Position */
S#define SCB_DCCSW_SET_Msk                  (0x1FFUL << SCB_DCCSW_SET_Pos)                 /*!< SCB DCCSW: Set Mask */
S
S/* SCB D-Cache Clean and Invalidate by Set-way Register Definitions */
S#define SCB_DCCISW_WAY_Pos                 30U                                            /*!< SCB DCCISW: Way Position */
S#define SCB_DCCISW_WAY_Msk                 (3UL << SCB_DCCISW_WAY_Pos)                    /*!< SCB DCCISW: Way Mask */
S
S#define SCB_DCCISW_SET_Pos                  5U                                            /*!< SCB DCCISW: Set Position */
S#define SCB_DCCISW_SET_Msk                 (0x1FFUL << SCB_DCCISW_SET_Pos)                /*!< SCB DCCISW: Set Mask */
S
S/* Instruction Tightly-Coupled Memory Control Register Definitions */
S#define SCB_ITCMCR_SZ_Pos                   3U                                            /*!< SCB ITCMCR: SZ Position */
S#define SCB_ITCMCR_SZ_Msk                  (0xFUL << SCB_ITCMCR_SZ_Pos)                   /*!< SCB ITCMCR: SZ Mask */
S
S#define SCB_ITCMCR_RETEN_Pos                2U                                            /*!< SCB ITCMCR: RETEN Position */
S#define SCB_ITCMCR_RETEN_Msk               (1UL << SCB_ITCMCR_RETEN_Pos)                  /*!< SCB ITCMCR: RETEN Mask */
S
S#define SCB_ITCMCR_RMW_Pos                  1U                                            /*!< SCB ITCMCR: RMW Position */
S#define SCB_ITCMCR_RMW_Msk                 (1UL << SCB_ITCMCR_RMW_Pos)                    /*!< SCB ITCMCR: RMW Mask */
S
S#define SCB_ITCMCR_EN_Pos                   0U                                            /*!< SCB ITCMCR: EN Position */
S#define SCB_ITCMCR_EN_Msk                  (1UL /*<< SCB_ITCMCR_EN_Pos*/)                 /*!< SCB ITCMCR: EN Mask */
S
S/* Data Tightly-Coupled Memory Control Register Definitions */
S#define SCB_DTCMCR_SZ_Pos                   3U                                            /*!< SCB DTCMCR: SZ Position */
S#define SCB_DTCMCR_SZ_Msk                  (0xFUL << SCB_DTCMCR_SZ_Pos)                   /*!< SCB DTCMCR: SZ Mask */
S
S#define SCB_DTCMCR_RETEN_Pos                2U                                            /*!< SCB DTCMCR: RETEN Position */
S#define SCB_DTCMCR_RETEN_Msk               (1UL << SCB_DTCMCR_RETEN_Pos)                   /*!< SCB DTCMCR: RETEN Mask */
S
S#define SCB_DTCMCR_RMW_Pos                  1U                                            /*!< SCB DTCMCR: RMW Position */
S#define SCB_DTCMCR_RMW_Msk                 (1UL << SCB_DTCMCR_RMW_Pos)                    /*!< SCB DTCMCR: RMW Mask */
S
S#define SCB_DTCMCR_EN_Pos                   0U                                            /*!< SCB DTCMCR: EN Position */
S#define SCB_DTCMCR_EN_Msk                  (1UL /*<< SCB_DTCMCR_EN_Pos*/)                 /*!< SCB DTCMCR: EN Mask */
S
S/* AHBP Control Register Definitions */
S#define SCB_AHBPCR_SZ_Pos                   1U                                            /*!< SCB AHBPCR: SZ Position */
S#define SCB_AHBPCR_SZ_Msk                  (7UL << SCB_AHBPCR_SZ_Pos)                     /*!< SCB AHBPCR: SZ Mask */
S
S#define SCB_AHBPCR_EN_Pos                   0U                                            /*!< SCB AHBPCR: EN Position */
S#define SCB_AHBPCR_EN_Msk                  (1UL /*<< SCB_AHBPCR_EN_Pos*/)                 /*!< SCB AHBPCR: EN Mask */
S
S/* L1 Cache Control Register Definitions */
S#define SCB_CACR_FORCEWT_Pos                2U                                            /*!< SCB CACR: FORCEWT Position */
S#define SCB_CACR_FORCEWT_Msk               (1UL << SCB_CACR_FORCEWT_Pos)                  /*!< SCB CACR: FORCEWT Mask */
S
S#define SCB_CACR_ECCEN_Pos                  1U                                            /*!< SCB CACR: ECCEN Position */
S#define SCB_CACR_ECCEN_Msk                 (1UL << SCB_CACR_ECCEN_Pos)                    /*!< SCB CACR: ECCEN Mask */
S
S#define SCB_CACR_SIWT_Pos                   0U                                            /*!< SCB CACR: SIWT Position */
S#define SCB_CACR_SIWT_Msk                  (1UL /*<< SCB_CACR_SIWT_Pos*/)                 /*!< SCB CACR: SIWT Mask */
S
S/* AHBS Control Register Definitions */
S#define SCB_AHBSCR_INITCOUNT_Pos           11U                                            /*!< SCB AHBSCR: INITCOUNT Position */
S#define SCB_AHBSCR_INITCOUNT_Msk           (0x1FUL << SCB_AHBPCR_INITCOUNT_Pos)           /*!< SCB AHBSCR: INITCOUNT Mask */
S
S#define SCB_AHBSCR_TPRI_Pos                 2U                                            /*!< SCB AHBSCR: TPRI Position */
S#define SCB_AHBSCR_TPRI_Msk                (0x1FFUL << SCB_AHBPCR_TPRI_Pos)               /*!< SCB AHBSCR: TPRI Mask */
S
S#define SCB_AHBSCR_CTL_Pos                  0U                                            /*!< SCB AHBSCR: CTL Position*/
S#define SCB_AHBSCR_CTL_Msk                 (3UL /*<< SCB_AHBPCR_CTL_Pos*/)                /*!< SCB AHBSCR: CTL Mask */
S
S/* Auxiliary Bus Fault Status Register Definitions */
S#define SCB_ABFSR_AXIMTYPE_Pos              8U                                            /*!< SCB ABFSR: AXIMTYPE Position*/
S#define SCB_ABFSR_AXIMTYPE_Msk             (3UL << SCB_ABFSR_AXIMTYPE_Pos)                /*!< SCB ABFSR: AXIMTYPE Mask */
S
S#define SCB_ABFSR_EPPB_Pos                  4U                                            /*!< SCB ABFSR: EPPB Position*/
S#define SCB_ABFSR_EPPB_Msk                 (1UL << SCB_ABFSR_EPPB_Pos)                    /*!< SCB ABFSR: EPPB Mask */
S
S#define SCB_ABFSR_AXIM_Pos                  3U                                            /*!< SCB ABFSR: AXIM Position*/
S#define SCB_ABFSR_AXIM_Msk                 (1UL << SCB_ABFSR_AXIM_Pos)                    /*!< SCB ABFSR: AXIM Mask */
S
S#define SCB_ABFSR_AHBP_Pos                  2U                                            /*!< SCB ABFSR: AHBP Position*/
S#define SCB_ABFSR_AHBP_Msk                 (1UL << SCB_ABFSR_AHBP_Pos)                    /*!< SCB ABFSR: AHBP Mask */
S
S#define SCB_ABFSR_DTCM_Pos                  1U                                            /*!< SCB ABFSR: DTCM Position*/
S#define SCB_ABFSR_DTCM_Msk                 (1UL << SCB_ABFSR_DTCM_Pos)                    /*!< SCB ABFSR: DTCM Mask */
S
S#define SCB_ABFSR_ITCM_Pos                  0U                                            /*!< SCB ABFSR: ITCM Position*/
S#define SCB_ABFSR_ITCM_Msk                 (1UL /*<< SCB_ABFSR_ITCM_Pos*/)                /*!< SCB ABFSR: ITCM Mask */
S
S/*@} end of group CMSIS_SCB */
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
S  \brief    Type definitions for the System Control and ID Register not in the SCB
S  @{
S */
S
S/**
S  \brief  Structure type to access the System Control and ID Register not in the SCB.
S */
Stypedef struct
S{
S        uint32_t RESERVED0[1U];
S  __IM  uint32_t ICTR;                   /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register */
S  __IOM uint32_t ACTLR;                  /*!< Offset: 0x008 (R/W)  Auxiliary Control Register */
S} SCnSCB_Type;
S
S/* Interrupt Controller Type Register Definitions */
S#define SCnSCB_ICTR_INTLINESNUM_Pos         0U                                         /*!< ICTR: INTLINESNUM Position */
S#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: INTLINESNUM Mask */
S
S/* Auxiliary Control Register Definitions */
S#define SCnSCB_ACTLR_DISITMATBFLUSH_Pos    12U                                         /*!< ACTLR: DISITMATBFLUSH Position */
S#define SCnSCB_ACTLR_DISITMATBFLUSH_Msk    (1UL << SCnSCB_ACTLR_DISITMATBFLUSH_Pos)    /*!< ACTLR: DISITMATBFLUSH Mask */
S
S#define SCnSCB_ACTLR_DISRAMODE_Pos         11U                                         /*!< ACTLR: DISRAMODE Position */
S#define SCnSCB_ACTLR_DISRAMODE_Msk         (1UL << SCnSCB_ACTLR_DISRAMODE_Pos)         /*!< ACTLR: DISRAMODE Mask */
S
S#define SCnSCB_ACTLR_FPEXCODIS_Pos         10U                                         /*!< ACTLR: FPEXCODIS Position */
S#define SCnSCB_ACTLR_FPEXCODIS_Msk         (1UL << SCnSCB_ACTLR_FPEXCODIS_Pos)         /*!< ACTLR: FPEXCODIS Mask */
S
S#define SCnSCB_ACTLR_DISFOLD_Pos            2U                                         /*!< ACTLR: DISFOLD Position */
S#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
S
S#define SCnSCB_ACTLR_DISMCYCINT_Pos         0U                                         /*!< ACTLR: DISMCYCINT Position */
S#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL /*<< SCnSCB_ACTLR_DISMCYCINT_Pos*/)    /*!< ACTLR: DISMCYCINT Mask */
S
S/*@} end of group CMSIS_SCnotSCB */
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
S  \brief    Type definitions for the System Timer Registers.
S  @{
S */
S
S/**
S  \brief  Structure type to access the System Timer (SysTick).
S */
Stypedef struct
S{
S  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
S  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
S  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
S  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
S} SysTick_Type;
S
S/* SysTick Control / Status Register Definitions */
S#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
S#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
S
S#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
S#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
S
S#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
S#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
S
S#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
S#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
S
S/* SysTick Reload Register Definitions */
S#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
S#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
S
S/* SysTick Current Register Definitions */
S#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
S#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
S
S/* SysTick Calibration Register Definitions */
S#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
S#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
S
S#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
S#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
S
S#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
S#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
S
S/*@} end of group CMSIS_SysTick */
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
S  \brief    Type definitions for the Instrumentation Trace Macrocell (ITM)
S  @{
S */
S
S/**
S  \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
S */
Stypedef struct
S{
S  __OM  union
S  {
S    __OM  uint8_t    u8;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit */
S    __OM  uint16_t   u16;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit */
S    __OM  uint32_t   u32;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit */
S  }  PORT [32U];                         /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers */
S        uint32_t RESERVED0[864U];
S  __IOM uint32_t TER;                    /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register */
S        uint32_t RESERVED1[15U];
S  __IOM uint32_t TPR;                    /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register */
S        uint32_t RESERVED2[15U];
S  __IOM uint32_t TCR;                    /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register */
S        uint32_t RESERVED3[29U];
S  __OM  uint32_t IWR;                    /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register */
S  __IM  uint32_t IRR;                    /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register */
S  __IOM uint32_t IMCR;                   /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register */
S        uint32_t RESERVED4[43U];
S  __OM  uint32_t LAR;                    /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register */
S  __IM  uint32_t LSR;                    /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register */
S        uint32_t RESERVED5[6U];
S  __IM  uint32_t PID4;                   /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
S  __IM  uint32_t PID5;                   /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
S  __IM  uint32_t PID6;                   /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
S  __IM  uint32_t PID7;                   /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
S  __IM  uint32_t PID0;                   /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
S  __IM  uint32_t PID1;                   /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
S  __IM  uint32_t PID2;                   /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
S  __IM  uint32_t PID3;                   /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
S  __IM  uint32_t CID0;                   /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
S  __IM  uint32_t CID1;                   /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
S  __IM  uint32_t CID2;                   /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
S  __IM  uint32_t CID3;                   /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
S} ITM_Type;
S
S/* ITM Trace Privilege Register Definitions */
S#define ITM_TPR_PRIVMASK_Pos                0U                                            /*!< ITM TPR: PRIVMASK Position */
S#define ITM_TPR_PRIVMASK_Msk               (0xFUL /*<< ITM_TPR_PRIVMASK_Pos*/)            /*!< ITM TPR: PRIVMASK Mask */
S
S/* ITM Trace Control Register Definitions */
S#define ITM_TCR_BUSY_Pos                   23U                                            /*!< ITM TCR: BUSY Position */
S#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
S
S#define ITM_TCR_TraceBusID_Pos             16U                                            /*!< ITM TCR: ATBID Position */
S#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
S
S#define ITM_TCR_GTSFREQ_Pos                10U                                            /*!< ITM TCR: Global timestamp frequency Position */
S#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
S
S#define ITM_TCR_TSPrescale_Pos              8U                                            /*!< ITM TCR: TSPrescale Position */
S#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
S
S#define ITM_TCR_SWOENA_Pos                  4U                                            /*!< ITM TCR: SWOENA Position */
S#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
S
S#define ITM_TCR_DWTENA_Pos                  3U                                            /*!< ITM TCR: DWTENA Position */
S#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
S
S#define ITM_TCR_SYNCENA_Pos                 2U                                            /*!< ITM TCR: SYNCENA Position */
S#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
S
S#define ITM_TCR_TSENA_Pos                   1U                                            /*!< ITM TCR: TSENA Position */
S#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
S
S#define ITM_TCR_ITMENA_Pos                  0U                                            /*!< ITM TCR: ITM Enable bit Position */
S#define ITM_TCR_ITMENA_Msk                 (1UL /*<< ITM_TCR_ITMENA_Pos*/)                /*!< ITM TCR: ITM Enable bit Mask */
S
S/* ITM Integration Write Register Definitions */
S#define ITM_IWR_ATVALIDM_Pos                0U                                            /*!< ITM IWR: ATVALIDM Position */
S#define ITM_IWR_ATVALIDM_Msk               (1UL /*<< ITM_IWR_ATVALIDM_Pos*/)              /*!< ITM IWR: ATVALIDM Mask */
S
S/* ITM Integration Read Register Definitions */
S#define ITM_IRR_ATREADYM_Pos                0U                                            /*!< ITM IRR: ATREADYM Position */
S#define ITM_IRR_ATREADYM_Msk               (1UL /*<< ITM_IRR_ATREADYM_Pos*/)              /*!< ITM IRR: ATREADYM Mask */
S
S/* ITM Integration Mode Control Register Definitions */
S#define ITM_IMCR_INTEGRATION_Pos            0U                                            /*!< ITM IMCR: INTEGRATION Position */
S#define ITM_IMCR_INTEGRATION_Msk           (1UL /*<< ITM_IMCR_INTEGRATION_Pos*/)          /*!< ITM IMCR: INTEGRATION Mask */
S
S/* ITM Lock Status Register Definitions */
S#define ITM_LSR_ByteAcc_Pos                 2U                                            /*!< ITM LSR: ByteAcc Position */
S#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
S
S#define ITM_LSR_Access_Pos                  1U                                            /*!< ITM LSR: Access Position */
S#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
S
S#define ITM_LSR_Present_Pos                 0U                                            /*!< ITM LSR: Present Position */
S#define ITM_LSR_Present_Msk                (1UL /*<< ITM_LSR_Present_Pos*/)               /*!< ITM LSR: Present Mask */
S
S/*@}*/ /* end of group CMSIS_ITM */
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
S  \brief    Type definitions for the Data Watchpoint and Trace (DWT)
S  @{
S */
S
S/**
S  \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
S */
Stypedef struct
S{
S  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  Control Register */
S  __IOM uint32_t CYCCNT;                 /*!< Offset: 0x004 (R/W)  Cycle Count Register */
S  __IOM uint32_t CPICNT;                 /*!< Offset: 0x008 (R/W)  CPI Count Register */
S  __IOM uint32_t EXCCNT;                 /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register */
S  __IOM uint32_t SLEEPCNT;               /*!< Offset: 0x010 (R/W)  Sleep Count Register */
S  __IOM uint32_t LSUCNT;                 /*!< Offset: 0x014 (R/W)  LSU Count Register */
S  __IOM uint32_t FOLDCNT;                /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register */
S  __IM  uint32_t PCSR;                   /*!< Offset: 0x01C (R/ )  Program Counter Sample Register */
S  __IOM uint32_t COMP0;                  /*!< Offset: 0x020 (R/W)  Comparator Register 0 */
S  __IOM uint32_t MASK0;                  /*!< Offset: 0x024 (R/W)  Mask Register 0 */
S  __IOM uint32_t FUNCTION0;              /*!< Offset: 0x028 (R/W)  Function Register 0 */
S        uint32_t RESERVED0[1U];
S  __IOM uint32_t COMP1;                  /*!< Offset: 0x030 (R/W)  Comparator Register 1 */
S  __IOM uint32_t MASK1;                  /*!< Offset: 0x034 (R/W)  Mask Register 1 */
S  __IOM uint32_t FUNCTION1;              /*!< Offset: 0x038 (R/W)  Function Register 1 */
S        uint32_t RESERVED1[1U];
S  __IOM uint32_t COMP2;                  /*!< Offset: 0x040 (R/W)  Comparator Register 2 */
S  __IOM uint32_t MASK2;                  /*!< Offset: 0x044 (R/W)  Mask Register 2 */
S  __IOM uint32_t FUNCTION2;              /*!< Offset: 0x048 (R/W)  Function Register 2 */
S        uint32_t RESERVED2[1U];
S  __IOM uint32_t COMP3;                  /*!< Offset: 0x050 (R/W)  Comparator Register 3 */
S  __IOM uint32_t MASK3;                  /*!< Offset: 0x054 (R/W)  Mask Register 3 */
S  __IOM uint32_t FUNCTION3;              /*!< Offset: 0x058 (R/W)  Function Register 3 */
S        uint32_t RESERVED3[981U];
S  __OM  uint32_t LAR;                    /*!< Offset: 0xFB0 (  W)  Lock Access Register */
S  __IM  uint32_t LSR;                    /*!< Offset: 0xFB4 (R  )  Lock Status Register */
S} DWT_Type;
S
S/* DWT Control Register Definitions */
S#define DWT_CTRL_NUMCOMP_Pos               28U                                         /*!< DWT CTRL: NUMCOMP Position */
S#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
S
S#define DWT_CTRL_NOTRCPKT_Pos              27U                                         /*!< DWT CTRL: NOTRCPKT Position */
S#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
S
S#define DWT_CTRL_NOEXTTRIG_Pos             26U                                         /*!< DWT CTRL: NOEXTTRIG Position */
S#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
S
S#define DWT_CTRL_NOCYCCNT_Pos              25U                                         /*!< DWT CTRL: NOCYCCNT Position */
S#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
S
S#define DWT_CTRL_NOPRFCNT_Pos              24U                                         /*!< DWT CTRL: NOPRFCNT Position */
S#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
S
S#define DWT_CTRL_CYCEVTENA_Pos             22U                                         /*!< DWT CTRL: CYCEVTENA Position */
S#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
S
S#define DWT_CTRL_FOLDEVTENA_Pos            21U                                         /*!< DWT CTRL: FOLDEVTENA Position */
S#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
S
S#define DWT_CTRL_LSUEVTENA_Pos             20U                                         /*!< DWT CTRL: LSUEVTENA Position */
S#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
S
S#define DWT_CTRL_SLEEPEVTENA_Pos           19U                                         /*!< DWT CTRL: SLEEPEVTENA Position */
S#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
S
S#define DWT_CTRL_EXCEVTENA_Pos             18U                                         /*!< DWT CTRL: EXCEVTENA Position */
S#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
S
S#define DWT_CTRL_CPIEVTENA_Pos             17U                                         /*!< DWT CTRL: CPIEVTENA Position */
S#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
S
S#define DWT_CTRL_EXCTRCENA_Pos             16U                                         /*!< DWT CTRL: EXCTRCENA Position */
S#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
S
S#define DWT_CTRL_PCSAMPLENA_Pos            12U                                         /*!< DWT CTRL: PCSAMPLENA Position */
S#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
S
S#define DWT_CTRL_SYNCTAP_Pos               10U                                         /*!< DWT CTRL: SYNCTAP Position */
S#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
S
S#define DWT_CTRL_CYCTAP_Pos                 9U                                         /*!< DWT CTRL: CYCTAP Position */
S#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
S
S#define DWT_CTRL_POSTINIT_Pos               5U                                         /*!< DWT CTRL: POSTINIT Position */
S#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
S
S#define DWT_CTRL_POSTPRESET_Pos             1U                                         /*!< DWT CTRL: POSTPRESET Position */
S#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
S
S#define DWT_CTRL_CYCCNTENA_Pos              0U                                         /*!< DWT CTRL: CYCCNTENA Position */
S#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL /*<< DWT_CTRL_CYCCNTENA_Pos*/)       /*!< DWT CTRL: CYCCNTENA Mask */
S
S/* DWT CPI Count Register Definitions */
S#define DWT_CPICNT_CPICNT_Pos               0U                                         /*!< DWT CPICNT: CPICNT Position */
S#define DWT_CPICNT_CPICNT_Msk              (0xFFUL /*<< DWT_CPICNT_CPICNT_Pos*/)       /*!< DWT CPICNT: CPICNT Mask */
S
S/* DWT Exception Overhead Count Register Definitions */
S#define DWT_EXCCNT_EXCCNT_Pos               0U                                         /*!< DWT EXCCNT: EXCCNT Position */
S#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL /*<< DWT_EXCCNT_EXCCNT_Pos*/)       /*!< DWT EXCCNT: EXCCNT Mask */
S
S/* DWT Sleep Count Register Definitions */
S#define DWT_SLEEPCNT_SLEEPCNT_Pos           0U                                         /*!< DWT SLEEPCNT: SLEEPCNT Position */
S#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL /*<< DWT_SLEEPCNT_SLEEPCNT_Pos*/)   /*!< DWT SLEEPCNT: SLEEPCNT Mask */
S
S/* DWT LSU Count Register Definitions */
S#define DWT_LSUCNT_LSUCNT_Pos               0U                                         /*!< DWT LSUCNT: LSUCNT Position */
S#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL /*<< DWT_LSUCNT_LSUCNT_Pos*/)       /*!< DWT LSUCNT: LSUCNT Mask */
S
S/* DWT Folded-instruction Count Register Definitions */
S#define DWT_FOLDCNT_FOLDCNT_Pos             0U                                         /*!< DWT FOLDCNT: FOLDCNT Position */
S#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL /*<< DWT_FOLDCNT_FOLDCNT_Pos*/)     /*!< DWT FOLDCNT: FOLDCNT Mask */
S
S/* DWT Comparator Mask Register Definitions */
S#define DWT_MASK_MASK_Pos                   0U                                         /*!< DWT MASK: MASK Position */
S#define DWT_MASK_MASK_Msk                  (0x1FUL /*<< DWT_MASK_MASK_Pos*/)           /*!< DWT MASK: MASK Mask */
S
S/* DWT Comparator Function Register Definitions */
S#define DWT_FUNCTION_MATCHED_Pos           24U                                         /*!< DWT FUNCTION: MATCHED Position */
S#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
S
S#define DWT_FUNCTION_DATAVADDR1_Pos        16U                                         /*!< DWT FUNCTION: DATAVADDR1 Position */
S#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
S
S#define DWT_FUNCTION_DATAVADDR0_Pos        12U                                         /*!< DWT FUNCTION: DATAVADDR0 Position */
S#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
S
S#define DWT_FUNCTION_DATAVSIZE_Pos         10U                                         /*!< DWT FUNCTION: DATAVSIZE Position */
S#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
S
S#define DWT_FUNCTION_LNK1ENA_Pos            9U                                         /*!< DWT FUNCTION: LNK1ENA Position */
S#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
S
S#define DWT_FUNCTION_DATAVMATCH_Pos         8U                                         /*!< DWT FUNCTION: DATAVMATCH Position */
S#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
S
S#define DWT_FUNCTION_CYCMATCH_Pos           7U                                         /*!< DWT FUNCTION: CYCMATCH Position */
S#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
S
S#define DWT_FUNCTION_EMITRANGE_Pos          5U                                         /*!< DWT FUNCTION: EMITRANGE Position */
S#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
S
S#define DWT_FUNCTION_FUNCTION_Pos           0U                                         /*!< DWT FUNCTION: FUNCTION Position */
S#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL /*<< DWT_FUNCTION_FUNCTION_Pos*/)    /*!< DWT FUNCTION: FUNCTION Mask */
S
S/*@}*/ /* end of group CMSIS_DWT */
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_TPI     Trace Port Interface (TPI)
S  \brief    Type definitions for the Trace Port Interface (TPI)
S  @{
S */
S
S/**
S  \brief  Structure type to access the Trace Port Interface Register (TPI).
S */
Stypedef struct
S{
S  __IOM uint32_t SSPSR;                  /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register */
S  __IOM uint32_t CSPSR;                  /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
S        uint32_t RESERVED0[2U];
S  __IOM uint32_t ACPR;                   /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
S        uint32_t RESERVED1[55U];
S  __IOM uint32_t SPPR;                   /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
S        uint32_t RESERVED2[131U];
S  __IM  uint32_t FFSR;                   /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
S  __IOM uint32_t FFCR;                   /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
S  __IM  uint32_t FSCR;                   /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
S        uint32_t RESERVED3[759U];
S  __IM  uint32_t TRIGGER;                /*!< Offset: 0xEE8 (R/ )  TRIGGER */
S  __IM  uint32_t FIFO0;                  /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
S  __IM  uint32_t ITATBCTR2;              /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
S        uint32_t RESERVED4[1U];
S  __IM  uint32_t ITATBCTR0;              /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
S  __IM  uint32_t FIFO1;                  /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
S  __IOM uint32_t ITCTRL;                 /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
S        uint32_t RESERVED5[39U];
S  __IOM uint32_t CLAIMSET;               /*!< Offset: 0xFA0 (R/W)  Claim tag set */
S  __IOM uint32_t CLAIMCLR;               /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
S        uint32_t RESERVED7[8U];
S  __IM  uint32_t DEVID;                  /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
S  __IM  uint32_t DEVTYPE;                /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
S} TPI_Type;
S
S/* TPI Asynchronous Clock Prescaler Register Definitions */
S#define TPI_ACPR_PRESCALER_Pos              0U                                         /*!< TPI ACPR: PRESCALER Position */
S#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL /*<< TPI_ACPR_PRESCALER_Pos*/)    /*!< TPI ACPR: PRESCALER Mask */
S
S/* TPI Selected Pin Protocol Register Definitions */
S#define TPI_SPPR_TXMODE_Pos                 0U                                         /*!< TPI SPPR: TXMODE Position */
S#define TPI_SPPR_TXMODE_Msk                (0x3UL /*<< TPI_SPPR_TXMODE_Pos*/)          /*!< TPI SPPR: TXMODE Mask */
S
S/* TPI Formatter and Flush Status Register Definitions */
S#define TPI_FFSR_FtNonStop_Pos              3U                                         /*!< TPI FFSR: FtNonStop Position */
S#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
S
S#define TPI_FFSR_TCPresent_Pos              2U                                         /*!< TPI FFSR: TCPresent Position */
S#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
S
S#define TPI_FFSR_FtStopped_Pos              1U                                         /*!< TPI FFSR: FtStopped Position */
S#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
S
S#define TPI_FFSR_FlInProg_Pos               0U                                         /*!< TPI FFSR: FlInProg Position */
S#define TPI_FFSR_FlInProg_Msk              (0x1UL /*<< TPI_FFSR_FlInProg_Pos*/)        /*!< TPI FFSR: FlInProg Mask */
S
S/* TPI Formatter and Flush Control Register Definitions */
S#define TPI_FFCR_TrigIn_Pos                 8U                                         /*!< TPI FFCR: TrigIn Position */
S#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
S
S#define TPI_FFCR_EnFCont_Pos                1U                                         /*!< TPI FFCR: EnFCont Position */
S#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
S
S/* TPI TRIGGER Register Definitions */
S#define TPI_TRIGGER_TRIGGER_Pos             0U                                         /*!< TPI TRIGGER: TRIGGER Position */
S#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL /*<< TPI_TRIGGER_TRIGGER_Pos*/)      /*!< TPI TRIGGER: TRIGGER Mask */
S
S/* TPI Integration ETM Data Register Definitions (FIFO0) */
S#define TPI_FIFO0_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO0: ITM_ATVALID Position */
S#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
S
S#define TPI_FIFO0_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO0: ITM_bytecount Position */
S#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
S
S#define TPI_FIFO0_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO0: ETM_ATVALID Position */
S#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
S
S#define TPI_FIFO0_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO0: ETM_bytecount Position */
S#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
S
S#define TPI_FIFO0_ETM2_Pos                 16U                                         /*!< TPI FIFO0: ETM2 Position */
S#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
S
S#define TPI_FIFO0_ETM1_Pos                  8U                                         /*!< TPI FIFO0: ETM1 Position */
S#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
S
S#define TPI_FIFO0_ETM0_Pos                  0U                                         /*!< TPI FIFO0: ETM0 Position */
S#define TPI_FIFO0_ETM0_Msk                 (0xFFUL /*<< TPI_FIFO0_ETM0_Pos*/)          /*!< TPI FIFO0: ETM0 Mask */
S
S/* TPI ITATBCTR2 Register Definitions */
S#define TPI_ITATBCTR2_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR2: ATREADY Position */
S#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR2_ATREADY_Pos*/)    /*!< TPI ITATBCTR2: ATREADY Mask */
S
S/* TPI Integration ITM Data Register Definitions (FIFO1) */
S#define TPI_FIFO1_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO1: ITM_ATVALID Position */
S#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
S
S#define TPI_FIFO1_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO1: ITM_bytecount Position */
S#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
S
S#define TPI_FIFO1_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO1: ETM_ATVALID Position */
S#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
S
S#define TPI_FIFO1_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO1: ETM_bytecount Position */
S#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
S
S#define TPI_FIFO1_ITM2_Pos                 16U                                         /*!< TPI FIFO1: ITM2 Position */
S#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
S
S#define TPI_FIFO1_ITM1_Pos                  8U                                         /*!< TPI FIFO1: ITM1 Position */
S#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
S
S#define TPI_FIFO1_ITM0_Pos                  0U                                         /*!< TPI FIFO1: ITM0 Position */
S#define TPI_FIFO1_ITM0_Msk                 (0xFFUL /*<< TPI_FIFO1_ITM0_Pos*/)          /*!< TPI FIFO1: ITM0 Mask */
S
S/* TPI ITATBCTR0 Register Definitions */
S#define TPI_ITATBCTR0_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR0: ATREADY Position */
S#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR0_ATREADY_Pos*/)    /*!< TPI ITATBCTR0: ATREADY Mask */
S
S/* TPI Integration Mode Control Register Definitions */
S#define TPI_ITCTRL_Mode_Pos                 0U                                         /*!< TPI ITCTRL: Mode Position */
S#define TPI_ITCTRL_Mode_Msk                (0x1UL /*<< TPI_ITCTRL_Mode_Pos*/)          /*!< TPI ITCTRL: Mode Mask */
S
S/* TPI DEVID Register Definitions */
S#define TPI_DEVID_NRZVALID_Pos             11U                                         /*!< TPI DEVID: NRZVALID Position */
S#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
S
S#define TPI_DEVID_MANCVALID_Pos            10U                                         /*!< TPI DEVID: MANCVALID Position */
S#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
S
S#define TPI_DEVID_PTINVALID_Pos             9U                                         /*!< TPI DEVID: PTINVALID Position */
S#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
S
S#define TPI_DEVID_MinBufSz_Pos              6U                                         /*!< TPI DEVID: MinBufSz Position */
S#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
S
S#define TPI_DEVID_AsynClkIn_Pos             5U                                         /*!< TPI DEVID: AsynClkIn Position */
S#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
S
S#define TPI_DEVID_NrTraceInput_Pos          0U                                         /*!< TPI DEVID: NrTraceInput Position */
S#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL /*<< TPI_DEVID_NrTraceInput_Pos*/)  /*!< TPI DEVID: NrTraceInput Mask */
S
S/* TPI DEVTYPE Register Definitions */
S#define TPI_DEVTYPE_MajorType_Pos           4U                                         /*!< TPI DEVTYPE: MajorType Position */
S#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
S
S#define TPI_DEVTYPE_SubType_Pos             0U                                         /*!< TPI DEVTYPE: SubType Position */
S#define TPI_DEVTYPE_SubType_Msk            (0xFUL /*<< TPI_DEVTYPE_SubType_Pos*/)      /*!< TPI DEVTYPE: SubType Mask */
S
S/*@}*/ /* end of group CMSIS_TPI */
S
S
S#if (__MPU_PRESENT == 1U)
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
S  \brief    Type definitions for the Memory Protection Unit (MPU)
S  @{
S */
S
S/**
S  \brief  Structure type to access the Memory Protection Unit (MPU).
S */
Stypedef struct
S{
S  __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
S  __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
S  __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
S  __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register */
S  __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register */
S  __IOM uint32_t RBAR_A1;                /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register */
S  __IOM uint32_t RASR_A1;                /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
S  __IOM uint32_t RBAR_A2;                /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register */
S  __IOM uint32_t RASR_A2;                /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
S  __IOM uint32_t RBAR_A3;                /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register */
S  __IOM uint32_t RASR_A3;                /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
S} MPU_Type;
S
S/* MPU Type Register Definitions */
S#define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU TYPE: IREGION Position */
S#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
S
S#define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU TYPE: DREGION Position */
S#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
S
S#define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU TYPE: SEPARATE Position */
S#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
S
S/* MPU Control Register Definitions */
S#define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU CTRL: PRIVDEFENA Position */
S#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
S
S#define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU CTRL: HFNMIENA Position */
S#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
S
S#define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU CTRL: ENABLE Position */
S#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
S
S/* MPU Region Number Register Definitions */
S#define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU RNR: REGION Position */
S#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
S
S/* MPU Region Base Address Register Definitions */
S#define MPU_RBAR_ADDR_Pos                   5U                                            /*!< MPU RBAR: ADDR Position */
S#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
S
S#define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU RBAR: VALID Position */
S#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
S
S#define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU RBAR: REGION Position */
S#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
S
S/* MPU Region Attribute and Size Register Definitions */
S#define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU RASR: MPU Region Attribute field Position */
S#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
S
S#define MPU_RASR_XN_Pos                    28U                                            /*!< MPU RASR: ATTRS.XN Position */
S#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
S
S#define MPU_RASR_AP_Pos                    24U                                            /*!< MPU RASR: ATTRS.AP Position */
S#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
S
S#define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU RASR: ATTRS.TEX Position */
S#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
S
S#define MPU_RASR_S_Pos                     18U                                            /*!< MPU RASR: ATTRS.S Position */
S#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
S
S#define MPU_RASR_C_Pos                     17U                                            /*!< MPU RASR: ATTRS.C Position */
S#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
S
S#define MPU_RASR_B_Pos                     16U                                            /*!< MPU RASR: ATTRS.B Position */
S#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
S
S#define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU RASR: Sub-Region Disable Position */
S#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
S
S#define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU RASR: Region Size Field Position */
S#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
S
S#define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU RASR: Region enable bit Position */
S#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
S
S/*@} end of group CMSIS_MPU */
S#endif
S
S
S#if (__FPU_PRESENT == 1U)
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_FPU     Floating Point Unit (FPU)
S  \brief    Type definitions for the Floating Point Unit (FPU)
S  @{
S */
S
S/**
S  \brief  Structure type to access the Floating Point Unit (FPU).
S */
Stypedef struct
S{
S        uint32_t RESERVED0[1U];
S  __IOM uint32_t FPCCR;                  /*!< Offset: 0x004 (R/W)  Floating-Point Context Control Register */
S  __IOM uint32_t FPCAR;                  /*!< Offset: 0x008 (R/W)  Floating-Point Context Address Register */
S  __IOM uint32_t FPDSCR;                 /*!< Offset: 0x00C (R/W)  Floating-Point Default Status Control Register */
S  __IM  uint32_t MVFR0;                  /*!< Offset: 0x010 (R/ )  Media and FP Feature Register 0 */
S  __IM  uint32_t MVFR1;                  /*!< Offset: 0x014 (R/ )  Media and FP Feature Register 1 */
S  __IM  uint32_t MVFR2;                  /*!< Offset: 0x018 (R/ )  Media and FP Feature Register 2 */
S} FPU_Type;
S
S/* Floating-Point Context Control Register Definitions */
S#define FPU_FPCCR_ASPEN_Pos                31U                                            /*!< FPCCR: ASPEN bit Position */
S#define FPU_FPCCR_ASPEN_Msk                (1UL << FPU_FPCCR_ASPEN_Pos)                   /*!< FPCCR: ASPEN bit Mask */
S
S#define FPU_FPCCR_LSPEN_Pos                30U                                            /*!< FPCCR: LSPEN Position */
S#define FPU_FPCCR_LSPEN_Msk                (1UL << FPU_FPCCR_LSPEN_Pos)                   /*!< FPCCR: LSPEN bit Mask */
S
S#define FPU_FPCCR_MONRDY_Pos                8U                                            /*!< FPCCR: MONRDY Position */
S#define FPU_FPCCR_MONRDY_Msk               (1UL << FPU_FPCCR_MONRDY_Pos)                  /*!< FPCCR: MONRDY bit Mask */
S
S#define FPU_FPCCR_BFRDY_Pos                 6U                                            /*!< FPCCR: BFRDY Position */
S#define FPU_FPCCR_BFRDY_Msk                (1UL << FPU_FPCCR_BFRDY_Pos)                   /*!< FPCCR: BFRDY bit Mask */
S
S#define FPU_FPCCR_MMRDY_Pos                 5U                                            /*!< FPCCR: MMRDY Position */
S#define FPU_FPCCR_MMRDY_Msk                (1UL << FPU_FPCCR_MMRDY_Pos)                   /*!< FPCCR: MMRDY bit Mask */
S
S#define FPU_FPCCR_HFRDY_Pos                 4U                                            /*!< FPCCR: HFRDY Position */
S#define FPU_FPCCR_HFRDY_Msk                (1UL << FPU_FPCCR_HFRDY_Pos)                   /*!< FPCCR: HFRDY bit Mask */
S
S#define FPU_FPCCR_THREAD_Pos                3U                                            /*!< FPCCR: processor mode bit Position */
S#define FPU_FPCCR_THREAD_Msk               (1UL << FPU_FPCCR_THREAD_Pos)                  /*!< FPCCR: processor mode active bit Mask */
S
S#define FPU_FPCCR_USER_Pos                  1U                                            /*!< FPCCR: privilege level bit Position */
S#define FPU_FPCCR_USER_Msk                 (1UL << FPU_FPCCR_USER_Pos)                    /*!< FPCCR: privilege level bit Mask */
S
S#define FPU_FPCCR_LSPACT_Pos                0U                                            /*!< FPCCR: Lazy state preservation active bit Position */
S#define FPU_FPCCR_LSPACT_Msk               (1UL /*<< FPU_FPCCR_LSPACT_Pos*/)              /*!< FPCCR: Lazy state preservation active bit Mask */
S
S/* Floating-Point Context Address Register Definitions */
S#define FPU_FPCAR_ADDRESS_Pos               3U                                            /*!< FPCAR: ADDRESS bit Position */
S#define FPU_FPCAR_ADDRESS_Msk              (0x1FFFFFFFUL << FPU_FPCAR_ADDRESS_Pos)        /*!< FPCAR: ADDRESS bit Mask */
S
S/* Floating-Point Default Status Control Register Definitions */
S#define FPU_FPDSCR_AHP_Pos                 26U                                            /*!< FPDSCR: AHP bit Position */
S#define FPU_FPDSCR_AHP_Msk                 (1UL << FPU_FPDSCR_AHP_Pos)                    /*!< FPDSCR: AHP bit Mask */
S
S#define FPU_FPDSCR_DN_Pos                  25U                                            /*!< FPDSCR: DN bit Position */
S#define FPU_FPDSCR_DN_Msk                  (1UL << FPU_FPDSCR_DN_Pos)                     /*!< FPDSCR: DN bit Mask */
S
S#define FPU_FPDSCR_FZ_Pos                  24U                                            /*!< FPDSCR: FZ bit Position */
S#define FPU_FPDSCR_FZ_Msk                  (1UL << FPU_FPDSCR_FZ_Pos)                     /*!< FPDSCR: FZ bit Mask */
S
S#define FPU_FPDSCR_RMode_Pos               22U                                            /*!< FPDSCR: RMode bit Position */
S#define FPU_FPDSCR_RMode_Msk               (3UL << FPU_FPDSCR_RMode_Pos)                  /*!< FPDSCR: RMode bit Mask */
S
S/* Media and FP Feature Register 0 Definitions */
S#define FPU_MVFR0_FP_rounding_modes_Pos    28U                                            /*!< MVFR0: FP rounding modes bits Position */
S#define FPU_MVFR0_FP_rounding_modes_Msk    (0xFUL << FPU_MVFR0_FP_rounding_modes_Pos)     /*!< MVFR0: FP rounding modes bits Mask */
S
S#define FPU_MVFR0_Short_vectors_Pos        24U                                            /*!< MVFR0: Short vectors bits Position */
S#define FPU_MVFR0_Short_vectors_Msk        (0xFUL << FPU_MVFR0_Short_vectors_Pos)         /*!< MVFR0: Short vectors bits Mask */
S
S#define FPU_MVFR0_Square_root_Pos          20U                                            /*!< MVFR0: Square root bits Position */
S#define FPU_MVFR0_Square_root_Msk          (0xFUL << FPU_MVFR0_Square_root_Pos)           /*!< MVFR0: Square root bits Mask */
S
S#define FPU_MVFR0_Divide_Pos               16U                                            /*!< MVFR0: Divide bits Position */
S#define FPU_MVFR0_Divide_Msk               (0xFUL << FPU_MVFR0_Divide_Pos)                /*!< MVFR0: Divide bits Mask */
S
S#define FPU_MVFR0_FP_excep_trapping_Pos    12U                                            /*!< MVFR0: FP exception trapping bits Position */
S#define FPU_MVFR0_FP_excep_trapping_Msk    (0xFUL << FPU_MVFR0_FP_excep_trapping_Pos)     /*!< MVFR0: FP exception trapping bits Mask */
S
S#define FPU_MVFR0_Double_precision_Pos      8U                                            /*!< MVFR0: Double-precision bits Position */
S#define FPU_MVFR0_Double_precision_Msk     (0xFUL << FPU_MVFR0_Double_precision_Pos)      /*!< MVFR0: Double-precision bits Mask */
S
S#define FPU_MVFR0_Single_precision_Pos      4U                                            /*!< MVFR0: Single-precision bits Position */
S#define FPU_MVFR0_Single_precision_Msk     (0xFUL << FPU_MVFR0_Single_precision_Pos)      /*!< MVFR0: Single-precision bits Mask */
S
S#define FPU_MVFR0_A_SIMD_registers_Pos      0U                                            /*!< MVFR0: A_SIMD registers bits Position */
S#define FPU_MVFR0_A_SIMD_registers_Msk     (0xFUL /*<< FPU_MVFR0_A_SIMD_registers_Pos*/)  /*!< MVFR0: A_SIMD registers bits Mask */
S
S/* Media and FP Feature Register 1 Definitions */
S#define FPU_MVFR1_FP_fused_MAC_Pos         28U                                            /*!< MVFR1: FP fused MAC bits Position */
S#define FPU_MVFR1_FP_fused_MAC_Msk         (0xFUL << FPU_MVFR1_FP_fused_MAC_Pos)          /*!< MVFR1: FP fused MAC bits Mask */
S
S#define FPU_MVFR1_FP_HPFP_Pos              24U                                            /*!< MVFR1: FP HPFP bits Position */
S#define FPU_MVFR1_FP_HPFP_Msk              (0xFUL << FPU_MVFR1_FP_HPFP_Pos)               /*!< MVFR1: FP HPFP bits Mask */
S
S#define FPU_MVFR1_D_NaN_mode_Pos            4U                                            /*!< MVFR1: D_NaN mode bits Position */
S#define FPU_MVFR1_D_NaN_mode_Msk           (0xFUL << FPU_MVFR1_D_NaN_mode_Pos)            /*!< MVFR1: D_NaN mode bits Mask */
S
S#define FPU_MVFR1_FtZ_mode_Pos              0U                                            /*!< MVFR1: FtZ mode bits Position */
S#define FPU_MVFR1_FtZ_mode_Msk             (0xFUL /*<< FPU_MVFR1_FtZ_mode_Pos*/)          /*!< MVFR1: FtZ mode bits Mask */
S
S/* Media and FP Feature Register 2 Definitions */
S
S/*@} end of group CMSIS_FPU */
S#endif
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
S  \brief    Type definitions for the Core Debug Registers
S  @{
S */
S
S/**
S  \brief  Structure type to access the Core Debug Register (CoreDebug).
S */
Stypedef struct
S{
S  __IOM uint32_t DHCSR;                  /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register */
S  __OM  uint32_t DCRSR;                  /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register */
S  __IOM uint32_t DCRDR;                  /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register */
S  __IOM uint32_t DEMCR;                  /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
S} CoreDebug_Type;
S
S/* Debug Halting Control and Status Register Definitions */
S#define CoreDebug_DHCSR_DBGKEY_Pos         16U                                            /*!< CoreDebug DHCSR: DBGKEY Position */
S#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
S
S#define CoreDebug_DHCSR_S_RESET_ST_Pos     25U                                            /*!< CoreDebug DHCSR: S_RESET_ST Position */
S#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
S
S#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24U                                            /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
S#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
S
S#define CoreDebug_DHCSR_S_LOCKUP_Pos       19U                                            /*!< CoreDebug DHCSR: S_LOCKUP Position */
S#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
S
S#define CoreDebug_DHCSR_S_SLEEP_Pos        18U                                            /*!< CoreDebug DHCSR: S_SLEEP Position */
S#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
S
S#define CoreDebug_DHCSR_S_HALT_Pos         17U                                            /*!< CoreDebug DHCSR: S_HALT Position */
S#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
S
S#define CoreDebug_DHCSR_S_REGRDY_Pos       16U                                            /*!< CoreDebug DHCSR: S_REGRDY Position */
S#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
S
S#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5U                                            /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
S#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
S
S#define CoreDebug_DHCSR_C_MASKINTS_Pos      3U                                            /*!< CoreDebug DHCSR: C_MASKINTS Position */
S#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
S
S#define CoreDebug_DHCSR_C_STEP_Pos          2U                                            /*!< CoreDebug DHCSR: C_STEP Position */
S#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
S
S#define CoreDebug_DHCSR_C_HALT_Pos          1U                                            /*!< CoreDebug DHCSR: C_HALT Position */
S#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
S
S#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0U                                            /*!< CoreDebug DHCSR: C_DEBUGEN Position */
S#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL /*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*/)     /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
S
S/* Debug Core Register Selector Register Definitions */
S#define CoreDebug_DCRSR_REGWnR_Pos         16U                                            /*!< CoreDebug DCRSR: REGWnR Position */
S#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
S
S#define CoreDebug_DCRSR_REGSEL_Pos          0U                                            /*!< CoreDebug DCRSR: REGSEL Position */
S#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL /*<< CoreDebug_DCRSR_REGSEL_Pos*/)     /*!< CoreDebug DCRSR: REGSEL Mask */
S
S/* Debug Exception and Monitor Control Register Definitions */
S#define CoreDebug_DEMCR_TRCENA_Pos         24U                                            /*!< CoreDebug DEMCR: TRCENA Position */
S#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
S
S#define CoreDebug_DEMCR_MON_REQ_Pos        19U                                            /*!< CoreDebug DEMCR: MON_REQ Position */
S#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
S
S#define CoreDebug_DEMCR_MON_STEP_Pos       18U                                            /*!< CoreDebug DEMCR: MON_STEP Position */
S#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
S
S#define CoreDebug_DEMCR_MON_PEND_Pos       17U                                            /*!< CoreDebug DEMCR: MON_PEND Position */
S#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
S
S#define CoreDebug_DEMCR_MON_EN_Pos         16U                                            /*!< CoreDebug DEMCR: MON_EN Position */
S#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
S
S#define CoreDebug_DEMCR_VC_HARDERR_Pos     10U                                            /*!< CoreDebug DEMCR: VC_HARDERR Position */
S#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
S
S#define CoreDebug_DEMCR_VC_INTERR_Pos       9U                                            /*!< CoreDebug DEMCR: VC_INTERR Position */
S#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
S
S#define CoreDebug_DEMCR_VC_BUSERR_Pos       8U                                            /*!< CoreDebug DEMCR: VC_BUSERR Position */
S#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
S
S#define CoreDebug_DEMCR_VC_STATERR_Pos      7U                                            /*!< CoreDebug DEMCR: VC_STATERR Position */
S#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
S
S#define CoreDebug_DEMCR_VC_CHKERR_Pos       6U                                            /*!< CoreDebug DEMCR: VC_CHKERR Position */
S#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
S
S#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5U                                            /*!< CoreDebug DEMCR: VC_NOCPERR Position */
S#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
S
S#define CoreDebug_DEMCR_VC_MMERR_Pos        4U                                            /*!< CoreDebug DEMCR: VC_MMERR Position */
S#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
S
S#define CoreDebug_DEMCR_VC_CORERESET_Pos    0U                                            /*!< CoreDebug DEMCR: VC_CORERESET Position */
S#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL /*<< CoreDebug_DEMCR_VC_CORERESET_Pos*/)  /*!< CoreDebug DEMCR: VC_CORERESET Mask */
S
S/*@} end of group CMSIS_CoreDebug */
S
S
S/**
S  \ingroup    CMSIS_core_register
S  \defgroup   CMSIS_core_bitfield     Core register bit field macros
S  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
S  @{
S */
S
S/**
S  \brief   Mask and shift a bit field value for use in a register bit range.
S  \param[in] field  Name of the register bit field.
S  \param[in] value  Value of the bit field.
S  \return           Masked and shifted value.
S*/
S#define _VAL2FLD(field, value)    ((value << field ## _Pos) & field ## _Msk)
S
S/**
S  \brief     Mask and shift a register value to extract a bit filed value.
S  \param[in] field  Name of the register bit field.
S  \param[in] value  Value of register.
S  \return           Masked and shifted bit field value.
S*/
S#define _FLD2VAL(field, value)    ((value & field ## _Msk) >> field ## _Pos)
S
S/*@} end of group CMSIS_core_bitfield */
S
S
S/**
S  \ingroup    CMSIS_core_register
S  \defgroup   CMSIS_core_base     Core Definitions
S  \brief      Definitions for base addresses, unions, and structures.
S  @{
S */
S
S/* Memory mapping of Cortex-M4 Hardware */
S#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
S#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address */
S#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address */
S#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address */
S#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address */
S#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
S#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
S#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
S
S#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
S#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
S#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
S#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
S#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct */
S#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct */
S#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct */
S#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct */
S
S#if (__MPU_PRESENT == 1U)
S  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit */
S  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit */
S#endif
S
S#if (__FPU_PRESENT == 1U)
S  #define FPU_BASE          (SCS_BASE +  0x0F30UL)                    /*!< Floating Point Unit */
S  #define FPU               ((FPU_Type       *)     FPU_BASE      )   /*!< Floating Point Unit */
S#endif
S
S/*@} */
S
S
S
S/*******************************************************************************
S *                Hardware Abstraction Layer
S  Core Function Interface contains:
S  - Core NVIC Functions
S  - Core SysTick Functions
S  - Core Debug Functions
S  - Core Register Access Functions
S ******************************************************************************/
S/**
S  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
S*/
S
S
S
S/* ##########################   NVIC functions  #################################### */
S/**
S  \ingroup  CMSIS_Core_FunctionInterface
S  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
S  \brief    Functions that manage interrupts and exceptions via the NVIC.
S  @{
S */
S
S/**
S  \brief   Set Priority Grouping
S  \details Sets the priority grouping field using the required unlock sequence.
S           The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
S           Only values from 0..7 are used.
S           In case of a conflict between priority grouping and available
S           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
S  \param [in]      PriorityGroup  Priority grouping field.
S */
S__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
S{
S  uint32_t reg_value;
S  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
S
S  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
S  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
S  reg_value  =  (reg_value                                   |
S                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
S                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
S  SCB->AIRCR =  reg_value;
S}
S
S
S/**
S  \brief   Get Priority Grouping
S  \details Reads the priority grouping field from the NVIC Interrupt Controller.
S  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
S */
S__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
S{
S  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
S}
S
S
S/**
S  \brief   Enable External Interrupt
S  \details Enables a device-specific interrupt in the NVIC interrupt controller.
S  \param [in]      IRQn  External interrupt number. Value cannot be negative.
S */
S__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
S{
S  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
S}
S
S
S/**
S  \brief   Disable External Interrupt
S  \details Disables a device-specific interrupt in the NVIC interrupt controller.
S  \param [in]      IRQn  External interrupt number. Value cannot be negative.
S */
S__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
S{
S  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
S}
S
S
S/**
S  \brief   Get Pending Interrupt
S  \details Reads the pending register in the NVIC and returns the pending bit for the specified interrupt.
S  \param [in]      IRQn  Interrupt number.
S  \return             0  Interrupt status is not pending.
S  \return             1  Interrupt status is pending.
S */
S__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
S{
S  return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
S}
S
S
S/**
S  \brief   Set Pending Interrupt
S  \details Sets the pending bit of an external interrupt.
S  \param [in]      IRQn  Interrupt number. Value cannot be negative.
S */
S__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
S{
S  NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
S}
S
S
S/**
S  \brief   Clear Pending Interrupt
S  \details Clears the pending bit of an external interrupt.
S  \param [in]      IRQn  External interrupt number. Value cannot be negative.
S */
S__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
S{
S  NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
S}
S
S
S/**
S  \brief   Get Active Interrupt
S  \details Reads the active register in NVIC and returns the active bit.
S  \param [in]      IRQn  Interrupt number.
S  \return             0  Interrupt status is not active.
S  \return             1  Interrupt status is active.
S */
S__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
S{
S  return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
S}
S
S
S/**
S  \brief   Set Interrupt Priority
S  \details Sets the priority of an interrupt.
S  \note    The priority cannot be set for every core interrupt.
S  \param [in]      IRQn  Interrupt number.
S  \param [in]  priority  Priority to set.
S */
S__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
S{
S  if ((int32_t)(IRQn) < 0)
S  {
S    SCB->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
S  }
S  else
S  {
S    NVIC->IP[((uint32_t)(int32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
S  }
S}
S
S
S/**
S  \brief   Get Interrupt Priority
S  \details Reads the priority of an interrupt.
S           The interrupt number can be positive to specify an external (device specific) interrupt,
S           or negative to specify an internal (core) interrupt.
S  \param [in]   IRQn  Interrupt number.
S  \return             Interrupt Priority.
S                      Value is aligned automatically to the implemented priority bits of the microcontroller.
S */
S__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
S{
S
S  if ((int32_t)(IRQn) < 0)
S  {
S    return(((uint32_t)SCB->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
S  }
S  else
S  {
S    return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]                >> (8U - __NVIC_PRIO_BITS)));
S  }
S}
S
S
S/**
S  \brief   Encode Priority
S  \details Encodes the priority for an interrupt with the given priority group,
S           preemptive priority value, and subpriority value.
S           In case of a conflict between priority grouping and available
S           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
S  \param [in]     PriorityGroup  Used priority group.
S  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
S  \param [in]       SubPriority  Subpriority value (starting from 0).
S  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
S */
S__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
S{
S  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
S  uint32_t PreemptPriorityBits;
S  uint32_t SubPriorityBits;
S
S  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
S  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
S
S  return (
S           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
S           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
S         );
S}
S
S
S/**
S  \brief   Decode Priority
S  \details Decodes an interrupt priority value with a given priority group to
S           preemptive priority value and subpriority value.
S           In case of a conflict between priority grouping and available
S           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
S  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
S  \param [in]     PriorityGroup  Used priority group.
S  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
S  \param [out]     pSubPriority  Subpriority value (starting from 0).
S */
S__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
S{
S  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
S  uint32_t PreemptPriorityBits;
S  uint32_t SubPriorityBits;
S
S  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
S  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
S
S  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
S  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
S}
S
S
S/**
S  \brief   System Reset
S  \details Initiates a system reset request to reset the MCU.
S */
S__STATIC_INLINE void NVIC_SystemReset(void)
S{
S  __DSB();                                                          /* Ensure all outstanding memory accesses included
S                                                                       buffered write are completed before reset */
S  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
S                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
S                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
S  __DSB();                                                          /* Ensure completion of memory access */
S
S  for(;;)                                                           /* wait until reset */
S  {
S    __NOP();
S  }
S}
S
S/*@} end of CMSIS_Core_NVICFunctions */
S
S
S/* ##########################  FPU functions  #################################### */
S/**
S  \ingroup  CMSIS_Core_FunctionInterface
S  \defgroup CMSIS_Core_FpuFunctions FPU Functions
S  \brief    Function that provides FPU type.
S  @{
S */
S
S/**
S  \brief   get FPU type
S  \details returns the FPU type
S  \returns
S   - \b  0: No FPU
S   - \b  1: Single precision FPU
S   - \b  2: Double + Single precision FPU
S */
S__STATIC_INLINE uint32_t SCB_GetFPUType(void)
S{
S  uint32_t mvfr0;
S
S  mvfr0 = SCB->MVFR0;
S  if        ((mvfr0 & 0x00000FF0UL) == 0x220UL)
S  {
S    return 2UL;           /* Double + Single precision FPU */
S  }
S  else if ((mvfr0 & 0x00000FF0UL) == 0x020UL)
S  {
S    return 1UL;           /* Single precision FPU */
S  }
S  else
S  {
S    return 0UL;           /* No FPU */
S  }
S}
S
S
S/*@} end of CMSIS_Core_FpuFunctions */
S
S
S
S/* ##########################  Cache functions  #################################### */
S/**
S  \ingroup  CMSIS_Core_FunctionInterface
S  \defgroup CMSIS_Core_CacheFunctions Cache Functions
S  \brief    Functions that configure Instruction and Data cache.
S  @{
S */
S
S/* Cache Size ID Register Macros */
S#define CCSIDR_WAYS(x)         (((x) & SCB_CCSIDR_ASSOCIATIVITY_Msk) >> SCB_CCSIDR_ASSOCIATIVITY_Pos)
S#define CCSIDR_SETS(x)         (((x) & SCB_CCSIDR_NUMSETS_Msk      ) >> SCB_CCSIDR_NUMSETS_Pos      )
S
S
S/**
S  \brief   Enable I-Cache
S  \details Turns on I-Cache
S  */
S__STATIC_INLINE void SCB_EnableICache (void)
S{
S  #if (__ICACHE_PRESENT == 1U)
S    __DSB();
S    __ISB();
S    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
S    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
S    __DSB();
S    __ISB();
S  #endif
S}
S
S
S/**
S  \brief   Disable I-Cache
S  \details Turns off I-Cache
S  */
S__STATIC_INLINE void SCB_DisableICache (void)
S{
S  #if (__ICACHE_PRESENT == 1U)
S    __DSB();
S    __ISB();
S    SCB->CCR &= ~(uint32_t)SCB_CCR_IC_Msk;  /* disable I-Cache */
S    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
S    __DSB();
S    __ISB();
S  #endif
S}
S
S
S/**
S  \brief   Invalidate I-Cache
S  \details Invalidates I-Cache
S  */
S__STATIC_INLINE void SCB_InvalidateICache (void)
S{
S  #if (__ICACHE_PRESENT == 1U)
S    __DSB();
S    __ISB();
S    SCB->ICIALLU = 0UL;
S    __DSB();
S    __ISB();
S  #endif
S}
S
S
S/**
S  \brief   Enable D-Cache
S  \details Turns on D-Cache
S  */
S__STATIC_INLINE void SCB_EnableDCache (void)
S{
S  #if (__DCACHE_PRESENT == 1U)
S    uint32_t ccsidr;
S    uint32_t sets;
S    uint32_t ways;
S
S    SCB->CSSELR = (0U << 1U) | 0U;          /* Level 1 data cache */
S    __DSB();
S
S    ccsidr = SCB->CCSIDR;
S
S                                            /* invalidate D-Cache */
S    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
S    do {
S      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
S      do {
S        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
S                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
S        #if defined ( __CC_ARM )
S          __schedule_barrier();
S        #endif
S      } while (ways--);
S    } while(sets--);
S    __DSB();
S
S    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
S
S    __DSB();
S    __ISB();
S  #endif
S}
S
S
S/**
S  \brief   Disable D-Cache
S  \details Turns off D-Cache
S  */
S__STATIC_INLINE void SCB_DisableDCache (void)
S{
S  #if (__DCACHE_PRESENT == 1U)
S    uint32_t ccsidr;
S    uint32_t sets;
S    uint32_t ways;
S
S    SCB->CSSELR = (0U << 1U) | 0U;          /* Level 1 data cache */
S    __DSB();
S
S    ccsidr = SCB->CCSIDR;
S
S    SCB->CCR &= ~(uint32_t)SCB_CCR_DC_Msk;  /* disable D-Cache */
S
S                                            /* clean & invalidate D-Cache */
S    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
S    do {
S      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
S      do {
S        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
S                       ((ways << SCB_DCCISW_WAY_Pos) & SCB_DCCISW_WAY_Msk)  );
S        #if defined ( __CC_ARM )
S          __schedule_barrier();
S        #endif
S      } while (ways--);
S    } while(sets--);
S
S    __DSB();
S    __ISB();
S  #endif
S}
S
S
S/**
S  \brief   Invalidate D-Cache
S  \details Invalidates D-Cache
S  */
S__STATIC_INLINE void SCB_InvalidateDCache (void)
S{
S  #if (__DCACHE_PRESENT == 1U)
S    uint32_t ccsidr;
S    uint32_t sets;
S    uint32_t ways;
S
S    SCB->CSSELR = (0U << 1U) | 0U;          /* Level 1 data cache */
S    __DSB();
S
S    ccsidr = SCB->CCSIDR;
S
S                                            /* invalidate D-Cache */
S    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
S    do {
S      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
S      do {
S        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
S                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
S        #if defined ( __CC_ARM )
S          __schedule_barrier();
S        #endif
S      } while (ways--);
S    } while(sets--);
S
S    __DSB();
S    __ISB();
S  #endif
S}
S
S
S/**
S  \brief   Clean D-Cache
S  \details Cleans D-Cache
S  */
S__STATIC_INLINE void SCB_CleanDCache (void)
S{
S  #if (__DCACHE_PRESENT == 1U)
S    uint32_t ccsidr;
S    uint32_t sets;
S    uint32_t ways;
S
S    SCB->CSSELR = (0U << 1U) | 0U;          /* Level 1 data cache */
S    __DSB();
S
S    ccsidr = SCB->CCSIDR;
S
S                                            /* clean D-Cache */
S    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
S    do {
S      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
S      do {
S        SCB->DCCSW = (((sets << SCB_DCCSW_SET_Pos) & SCB_DCCSW_SET_Msk) |
S                      ((ways << SCB_DCCSW_WAY_Pos) & SCB_DCCSW_WAY_Msk)  );
S        #if defined ( __CC_ARM )
S          __schedule_barrier();
S        #endif
S      } while (ways--);
S    } while(sets--);
S
S    __DSB();
S    __ISB();
S  #endif
S}
S
S
S/**
S  \brief   Clean & Invalidate D-Cache
S  \details Cleans and Invalidates D-Cache
S  */
S__STATIC_INLINE void SCB_CleanInvalidateDCache (void)
S{
S  #if (__DCACHE_PRESENT == 1U)
S    uint32_t ccsidr;
S    uint32_t sets;
S    uint32_t ways;
S
S    SCB->CSSELR = (0U << 1U) | 0U;          /* Level 1 data cache */
S    __DSB();
S
S    ccsidr = SCB->CCSIDR;
S
S                                            /* clean & invalidate D-Cache */
S    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
S    do {
S      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
S      do {
S        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
S                       ((ways << SCB_DCCISW_WAY_Pos) & SCB_DCCISW_WAY_Msk)  );
S        #if defined ( __CC_ARM )
S          __schedule_barrier();
S        #endif
S      } while (ways--);
S    } while(sets--);
S
S    __DSB();
S    __ISB();
S  #endif
S}
S
S
S/**
S  \brief   D-Cache Invalidate by address
S  \details Invalidates D-Cache for the given address
S  \param[in]   addr    address (aligned to 32-byte boundary)
S  \param[in]   dsize   size of memory block (in number of bytes)
S*/
S__STATIC_INLINE void SCB_InvalidateDCache_by_Addr (uint32_t *addr, int32_t dsize)
S{
S  #if (__DCACHE_PRESENT == 1U)
S     int32_t op_size = dsize;
S    uint32_t op_addr = (uint32_t)addr;
S     int32_t linesize = 32U;                /* in Cortex-M7 size of cache line is fixed to 8 words (32 bytes) */
S
S    __DSB();
S
S    while (op_size > 0) {
S      SCB->DCIMVAC = op_addr;
S      op_addr += linesize;
S      op_size -= linesize;
S    }
S
S    __DSB();
S    __ISB();
S  #endif
S}
S
S
S/**
S  \brief   D-Cache Clean by address
S  \details Cleans D-Cache for the given address
S  \param[in]   addr    address (aligned to 32-byte boundary)
S  \param[in]   dsize   size of memory block (in number of bytes)
S*/
S__STATIC_INLINE void SCB_CleanDCache_by_Addr (uint32_t *addr, int32_t dsize)
S{
S  #if (__DCACHE_PRESENT == 1)
S     int32_t op_size = dsize;
S    uint32_t op_addr = (uint32_t) addr;
S     int32_t linesize = 32U;                /* in Cortex-M7 size of cache line is fixed to 8 words (32 bytes) */
S
S    __DSB();
S
S    while (op_size > 0) {
S      SCB->DCCMVAC = op_addr;
S      op_addr += linesize;
S      op_size -= linesize;
S    }
S
S    __DSB();
S    __ISB();
S  #endif
S}
S
S
S/**
S  \brief   D-Cache Clean and Invalidate by address
S  \details Cleans and invalidates D_Cache for the given address
S  \param[in]   addr    address (aligned to 32-byte boundary)
S  \param[in]   dsize   size of memory block (in number of bytes)
S*/
S__STATIC_INLINE void SCB_CleanInvalidateDCache_by_Addr (uint32_t *addr, int32_t dsize)
S{
S  #if (__DCACHE_PRESENT == 1U)
S     int32_t op_size = dsize;
S    uint32_t op_addr = (uint32_t) addr;
S     int32_t linesize = 32U;                /* in Cortex-M7 size of cache line is fixed to 8 words (32 bytes) */
S
S    __DSB();
S
S    while (op_size > 0) {
S      SCB->DCCIMVAC = op_addr;
S      op_addr += linesize;
S      op_size -= linesize;
S    }
S
S    __DSB();
S    __ISB();
S  #endif
S}
S
S
S/*@} end of CMSIS_Core_CacheFunctions */
S
S
S
S/* ##################################    SysTick function  ############################################ */
S/**
S  \ingroup  CMSIS_Core_FunctionInterface
S  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
S  \brief    Functions that configure the System.
S  @{
S */
S
S#if (__Vendor_SysTickConfig == 0U)
S
S/**
S  \brief   System Tick Configuration
S  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
S           Counter is in free running mode to generate periodic interrupts.
S  \param [in]  ticks  Number of ticks between two interrupts.
S  \return          0  Function succeeded.
S  \return          1  Function failed.
S  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
S           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
S           must contain a vendor-specific implementation of this function.
S */
S__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
S{
S  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
S  {
S    return (1UL);                                                   /* Reload value impossible */
S  }
S
S  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
S  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
S  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
S  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
S                   SysTick_CTRL_TICKINT_Msk   |
S                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
S  return (0UL);                                                     /* Function successful */
S}
S
S#endif
S
S/*@} end of CMSIS_Core_SysTickFunctions */
S
S
S
S/* ##################################### Debug In/Output function ########################################### */
S/**
S  \ingroup  CMSIS_Core_FunctionInterface
S  \defgroup CMSIS_core_DebugFunctions ITM Functions
S  \brief    Functions that access the ITM debug interface.
S  @{
S */
S
Sextern volatile int32_t ITM_RxBuffer;                    /*!< External variable to receive characters. */
S#define                 ITM_RXBUFFER_EMPTY   0x5AA55AA5U /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
S
S
S/**
S  \brief   ITM Send Character
S  \details Transmits a character via the ITM channel 0, and
S           \li Just returns when no debugger is connected that has booked the output.
S           \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
S  \param [in]     ch  Character to transmit.
S  \returns            Character to transmit.
S */
S__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
S{
S  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
S      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
S  {
S    while (ITM->PORT[0U].u32 == 0UL)
S    {
S      __NOP();
S    }
S    ITM->PORT[0U].u8 = (uint8_t)ch;
S  }
S  return (ch);
S}
S
S
S/**
S  \brief   ITM Receive Character
S  \details Inputs a character via the external variable \ref ITM_RxBuffer.
S  \return             Received character.
S  \return         -1  No character pending.
S */
S__STATIC_INLINE int32_t ITM_ReceiveChar (void)
S{
S  int32_t ch = -1;                           /* no character available */
S
S  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY)
S  {
S    ch = ITM_RxBuffer;
S    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
S  }
S
S  return (ch);
S}
S
S
S/**
S  \brief   ITM Check Character
S  \details Checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
S  \return          0  No character available.
S  \return          1  Character available.
S */
S__STATIC_INLINE int32_t ITM_CheckChar (void)
S{
S
S  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY)
S  {
S    return (0);                              /* no character available */
S  }
S  else
S  {
S    return (1);                              /*    character available */
S  }
S}
S
S/*@} end of CMSIS_core_DebugFunctions */
S
S
S
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif /* __CORE_CM7_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 13 "..\..\MProkaron\Include\Platform/CortexM_RVM/Chips/STM32F767IG/platform_STM32F767IG_RVM.h" 2
N#include "stm32f7xx_hal.h"
L 1 "..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\stm32f7xx_hal.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f7xx_hal.h
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    01-July-2016
N  * @brief   This file contains all the functions prototypes for the HAL 
N  *          module driver.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F7xx_HAL_H
N#define __STM32F7xx_HAL_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f7xx_hal_conf.h"
N
N/** @addtogroup STM32F7xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup HAL
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup SYSCFG_Exported_Constants SYSCFG Exported Constants
N  * @{
N  */
N
N/** @defgroup SYSCFG_BootMode Boot Mode
N  * @{
N  */
N#define SYSCFG_MEM_BOOT_ADD0          ((uint32_t)0x00000000U)
N#define SYSCFG_MEM_BOOT_ADD1          SYSCFG_MEMRMP_MEM_BOOT
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N   
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup HAL_Exported_Macros HAL Exported Macros
N  * @{
N  */
N  
N/** @brief  Freeze/Unfreeze Peripherals in Debug mode 
N  */
N#define __HAL_DBGMCU_FREEZE_TIM2()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM2_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM3()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM3_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM4()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM4_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM5()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM5_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM6()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM6_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM7()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM7_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM12()          (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM12_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM13()          (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM13_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM14()          (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM14_STOP))
N#define __HAL_DBGMCU_FREEZE_LPTIM1()         (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_LPTIM1_STOP))
N#define __HAL_DBGMCU_FREEZE_RTC()            (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_RTC_STOP))
N#define __HAL_DBGMCU_FREEZE_WWDG()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_WWDG_STOP))
N#define __HAL_DBGMCU_FREEZE_IWDG()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_IWDG_STOP))
N#define __HAL_DBGMCU_FREEZE_I2C1_TIMEOUT()   (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT))
N#define __HAL_DBGMCU_FREEZE_I2C2_TIMEOUT()   (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT))
N#define __HAL_DBGMCU_FREEZE_I2C3_TIMEOUT()   (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_I2C3_SMBUS_TIMEOUT))
N#define __HAL_DBGMCU_FREEZE_I2C4_TIMEOUT()   (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_I2C4_SMBUS_TIMEOUT))
N#define __HAL_DBGMCU_FREEZE_CAN1()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_CAN1_STOP))
N#define __HAL_DBGMCU_FREEZE_CAN2()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_CAN2_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM1()           (DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM1_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM8()           (DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM8_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM9()           (DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM9_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM10()          (DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM10_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM11()          (DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM11_STOP))
N
N#define __HAL_DBGMCU_UNFREEZE_TIM2()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM2_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM3()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM3_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM4()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM4_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM5()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM5_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM6()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM6_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM7()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM7_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM12()          (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM12_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM13()          (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM13_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM14()          (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM14_STOP))
N#define __HAL_DBGMCU_UNFREEZE_LPTIM1()         (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_LPTIM1_STOP))
N#define __HAL_DBGMCU_UNFREEZE_RTC()            (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_RTC_STOP))
N#define __HAL_DBGMCU_UNFREEZE_WWDG()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_WWDG_STOP))
N#define __HAL_DBGMCU_UNFREEZE_IWDG()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_IWDG_STOP))
N#define __HAL_DBGMCU_UNFREEZE_I2C1_TIMEOUT()   (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT))
N#define __HAL_DBGMCU_UNFREEZE_I2C2_TIMEOUT()   (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT))
N#define __HAL_DBGMCU_UNFREEZE_I2C3_TIMEOUT()   (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_I2C3_SMBUS_TIMEOUT))
N#define __HAL_DBGMCU_UNFREEZE_I2C4_TIMEOUT()   (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_I2C4_SMBUS_TIMEOUT))
N#define __HAL_DBGMCU_UNFREEZE_CAN1()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_CAN1_STOP))
N#define __HAL_DBGMCU_UNFREEZE_CAN2()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_CAN2_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM1()           (DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM1_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM8()           (DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM8_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM9()           (DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM9_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM10()          (DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM10_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM11()          (DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM11_STOP))
N
N
N/** @brief  FMC (NOR/RAM) mapped at 0x60000000 and SDRAM mapped at 0xC0000000
N  */
N#define __HAL_SYSCFG_REMAPMEMORY_FMC()          (SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_SWP_FMC))
N                                       
N
N/** @brief  FMC/SDRAM  mapped at 0x60000000 (NOR/RAM) mapped at 0xC0000000
N  */
N#define __HAL_SYSCFG_REMAPMEMORY_FMC_SDRAM() do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_SWP_FMC);\
N                                          SYSCFG->MEMRMP |= (SYSCFG_MEMRMP_SWP_FMC_0);\
N                                         }while(0);
X#define __HAL_SYSCFG_REMAPMEMORY_FMC_SDRAM() do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_SWP_FMC);                                          SYSCFG->MEMRMP |= (SYSCFG_MEMRMP_SWP_FMC_0);                                         }while(0);
N/**
N  * @brief  Return the memory boot mapping as configured by user.
N  * @retval The boot mode as configured by user. The returned value can be one
N  *         of the following values:
N  *           @arg @ref SYSCFG_MEM_BOOT_ADD0
N  *           @arg @ref SYSCFG_MEM_BOOT_ADD1
N  */
N#define __HAL_SYSCFG_GET_BOOT_MODE()           READ_BIT(SYSCFG->MEMRMP, SYSCFG_MEMRMP_MEM_BOOT)
N
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
N/** @brief  SYSCFG Break Cortex-M7 Lockup lock.
N  *         Enable and lock the connection of Cortex-M7 LOCKUP (Hardfault) output to TIM1/8 Break input.
N  * @note   The selected configuration is locked and can be unlocked only by system reset.
N  */
N#define __HAL_SYSCFG_BREAK_LOCKUP_LOCK()     SET_BIT(SYSCFG->CBR, SYSCFG_CBR_CLL)
N
N/** @brief  SYSCFG Break PVD lock.
N  *         Enable and lock the PVD connection to Timer1/8 Break input, as well as the PVDE and PLS[2:0] in the PWR_CR1 register.
N  * @note   The selected configuration is locked and can be unlocked only by system reset.
N  */
N#define __HAL_SYSCFG_BREAK_PVD_LOCK()        SET_BIT(SYSCFG->CBR, SYSCFG_CBR_PVDL)
N#endif /* STM32F765xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N
N/**
N  * @}
N  */
N  
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup HAL_Exported_Functions
N  * @{
N  */
N/** @addtogroup HAL_Exported_Functions_Group1
N  * @{
N  */
N/* Initialization and de-initialization functions  ******************************/
NHAL_StatusTypeDef HAL_Init(void);
NHAL_StatusTypeDef HAL_DeInit(void);
Nvoid HAL_MspInit(void);
Nvoid HAL_MspDeInit(void);
NHAL_StatusTypeDef HAL_InitTick (uint32_t TickPriority);
N/**
N  * @}
N  */
N 
N/** @addtogroup HAL_Exported_Functions_Group2
N  * @{
N  */ 
N/* Peripheral Control functions  ************************************************/
Nvoid HAL_IncTick(void);
Nvoid HAL_Delay(__IO uint32_t Delay);
Xvoid HAL_Delay(volatile uint32_t Delay);
Nuint32_t HAL_GetTick(void);
Nvoid HAL_SuspendTick(void);
Nvoid HAL_ResumeTick(void);
Nuint32_t HAL_GetHalVersion(void);
Nuint32_t HAL_GetREVID(void);
Nuint32_t HAL_GetDEVID(void);
Nvoid HAL_DBGMCU_EnableDBGSleepMode(void);
Nvoid HAL_DBGMCU_DisableDBGSleepMode(void);
Nvoid HAL_DBGMCU_EnableDBGStopMode(void);
Nvoid HAL_DBGMCU_DisableDBGStopMode(void);
Nvoid HAL_DBGMCU_EnableDBGStandbyMode(void);
Nvoid HAL_DBGMCU_DisableDBGStandbyMode(void);
Nvoid HAL_EnableCompensationCell(void);
Nvoid HAL_DisableCompensationCell(void);
Nvoid HAL_EnableFMCMemorySwapping(void);
Nvoid HAL_DisableFMCMemorySwapping(void);
N#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
X#if 0L || 1L || 0L || 0L || 0L
Nvoid HAL_EnableMemorySwappingBank(void);
Nvoid HAL_DisableMemorySwappingBank(void);
N#endif /* STM32F765xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */  
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/** @defgroup HAL_Private_Variables HAL Private Variables
N  * @{
N  */
N/**
N  * @}
N  */
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup HAL_Private_Constants HAL Private Constants
N  * @{
N  */
N/**
N  * @}
N  */
N/* Private macros ------------------------------------------------------------*/
N/* Private functions ---------------------------------------------------------*/
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F7xx_HAL_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 14 "..\..\MProkaron\Include\Platform/CortexM_RVM/Chips/STM32F767IG/platform_STM32F767IG_RVM.h" 2
N/* The maximum number of preemption priority levels in the system.
N * This parameter must be divisible by the word length - 32 is usually sufficient */
N#define RMP_MAX_PREEMPT_PRIO         32
N/* The maximum number of slices allowed */
N#define RMP_MAX_SLICES               100000
N/* The maximum number of semaphore counts allowed */
N#define RMP_SEM_MAX_NUM              1000
N/* Are we using custom hooks? */
N#define RMP_USE_HOOKS                RMP_FALSE
N/* The stzck size of the init thread */
N#define RMP_INIT_STACK_SIZE          256
N
N/* The virtual machine settings */
N/* The maximum interrupt vectors for each virtual machine */
N#define RVM_MAX_INTVECT              32
N/* End Defines ***************************************************************/
N
N/* End Of File ***************************************************************/
N
N/* Copyright (C) Evo-Devo Instrum. All rights reserved ***********************/
L 11 "..\..\MProkaron\Include\Platform/CortexM_RVM/platform_cmx_RVM_conf.h" 2
N/* End Config Includes *******************************************************/
N
N/* End Of File ***************************************************************/
N
N/* Copyright (C) Evo-Devo Instrum. All rights reserved ***********************/
L 94 "..\..\MProkaron\Include\Platform/CortexM_RVM/platform_cmx_RVM.h" 2
N/* End System macros *********************************************************/
N
N/* Hypervisor macros *********************************************************/
N#define RVM_MAGIC                0x56495254
N#define RVM_VECT_BITMAP          ((RVM_MAX_INTVECT-1)/RMP_WORD_SIZE+1)
N
N/* Hypercalls */
N/* Enable interrupts */
N#define RVM_HYP_ENAINT           0
N/* Disable interrupts */
N#define RVM_HYP_DISINT           1
N/* Register a vector */
N#define RVM_HYP_REGEVT           2
N/* Delete a vector */
N#define RVM_HYP_DELEVT           3
N/* Wait for an interrupt to come */
N#define RVM_HYP_WAITEVT          4
N/* Trigger a vector */
N#define RVM_HYP_SENDEVT          5
N/* Returning from a vector */
N#define RVM_HYP_QUERYEVT         6
N/* Query the VM's ID given its name */
N#define RVM_HYP_QUERY            7
N/* Send to another VM */
N#define RVM_HYP_TIMPROG          8
N/* Print to the console */
N#define RVM_HYP_PRINT            9
N
N/* System stack size when entering the system - do not need to be changed in most cases */
N#define RMP_INT_STACK_ADDR           (((ptr_t)&__initial_sp)+0x400-64*sizeof(ptr_t))
N    
N/* Generic page table flags */
N#define RME_PGTBL_ORDER(SIZE,NUM)    (((SIZE)<<(sizeof(ptr_t)*4))|(NUM))
N#define RME_PGTBL_READ               (1<<0)
N#define RME_PGTBL_WRITE              (1<<1)
N#define RME_PGTBL_EXECUTE            (1<<2)
N#define RME_PGTBL_CACHEABLE          (1<<3)
N#define RME_PGTBL_BUFFERABLE         (1<<4)
N#define RME_PGTBL_STATIC             (1<<5)
N
N#define RME_PGTBL_ALL_PERM           (RME_PGTBL_READ|RME_PGTBL_WRITE|RME_PGTBL_EXECUTE| \
N                                      RME_PGTBL_CACHEABLE|RME_PGTBL_BUFFERABLE|RME_PGTBL_STATIC)
X#define RME_PGTBL_ALL_PERM           (RME_PGTBL_READ|RME_PGTBL_WRITE|RME_PGTBL_EXECUTE|                                       RME_PGTBL_CACHEABLE|RME_PGTBL_BUFFERABLE|RME_PGTBL_STATIC)
N                                        
N/* Generic page size order definitions */
N#define RME_PGTBL_SIZE_2B            (1)
N#define RME_PGTBL_SIZE_4B            (2)
N#define RME_PGTBL_SIZE_8B            (3)
N#define RME_PGTBL_SIZE_16B           (4)
N#define RME_PGTBL_SIZE_32B           (5)
N#define RME_PGTBL_SIZE_64B           (6)
N#define RME_PGTBL_SIZE_128B          (7)
N#define RME_PGTBL_SIZE_256B          (8)
N#define RME_PGTBL_SIZE_512B          (9)
N#define RME_PGTBL_SIZE_1K            (10)
N#define RME_PGTBL_SIZE_2K            (11)
N#define RME_PGTBL_SIZE_4K            (12)
N#define RME_PGTBL_SIZE_8K            (13)
N#define RME_PGTBL_SIZE_16K           (14)
N#define RME_PGTBL_SIZE_32K           (15)
N#define RME_PGTBL_SIZE_64K           (16)
N#define RME_PGTBL_SIZE_128K          (17)
N#define RME_PGTBL_SIZE_256K          (18)
N#define RME_PGTBL_SIZE_512K          (19)
N#define RME_PGTBL_SIZE_1M            (20)
N#define RME_PGTBL_SIZE_2M            (21)
N#define RME_PGTBL_SIZE_4M            (22)
N#define RME_PGTBL_SIZE_8M            (23)
N#define RME_PGTBL_SIZE_16M           (24)
N#define RME_PGTBL_SIZE_32M           (25)
N#define RME_PGTBL_SIZE_64M           (26)
N#define RME_PGTBL_SIZE_128M          (27)
N#define RME_PGTBL_SIZE_256M          (28)
N#define RME_PGTBL_SIZE_512M          (29)
N#define RME_PGTBL_SIZE_1G            (30)
N#define RME_PGTBL_SIZE_2G            (31)
N#define RME_PGTBL_SIZE_4G            (32)
N
N/* Generic page table entry number definitions */
N#define RME_PGTBL_NUM_2             (1)
N#define RME_PGTBL_NUM_4             (2)
N#define RME_PGTBL_NUM_8             (3)
N#define RME_PGTBL_NUM_16            (4)
N#define RME_PGTBL_NUM_32            (5)
N#define RME_PGTBL_NUM_64            (6)
N#define RME_PGTBL_NUM_128           (7)
N#define RME_PGTBL_NUM_256           (8)
N#define RME_PGTBL_NUM_512           (9)
N#define RME_PGTBL_NUM_1K            (10)
N#define RME_PGTBL_NUM_2K            (11)
N#define RME_PGTBL_NUM_4K            (12)
N#define RME_PGTBL_NUM_8K            (13)
N#define RME_PGTBL_NUM_16K           (14)
N#define RME_PGTBL_NUM_32K           (15)
N#define RME_PGTBL_NUM_64K           (16)
N#define RME_PGTBL_NUM_128K          (17)
N#define RME_PGTBL_NUM_256K          (18)
N#define RME_PGTBL_NUM_512K          (19)
N#define RME_PGTBL_NUM_1M            (20)
N#define RME_PGTBL_NUM_2M            (21)
N#define RME_PGTBL_NUM_4M            (22)
N/* End Hypervisor macros *****************************************************/
N/*****************************************************************************/
N/* __PLATFORM_CMX_RVM_H_DEFS__ */
N#endif
N/* __HDR_DEFS__ */
N#endif
N/* End Defines ***************************************************************/
N
N/* Structs *******************************************************************/
N#ifdef __HDR_STRUCTS__
S#ifndef __PLATFORM_CMX_RVM_H_STRUCTS__
S#define __PLATFORM_CMX_RVM_H_STRUCTS__
S
Sstruct RVM_Reg_Struct
S{
S    ptr_t SP;
S    ptr_t R4;
S    ptr_t R5;
S    ptr_t R6;
S    ptr_t R7;
S    ptr_t R8;
S    ptr_t R9;
S    ptr_t R10;
S    ptr_t R11;
S    ptr_t LR;
S};
S
S/* The coprocessor register set structure. In Cortex-M, if there is a 
S * single-precision FPU, then the FPU S0-S15 is automatically pushed */
Sstruct RVM_Cop_Struct
S{
S    ptr_t S16;
S    ptr_t S17;
S    ptr_t S18;
S    ptr_t S19;
S    ptr_t S20;
S    ptr_t S21;
S    ptr_t S22;
S    ptr_t S23;
S    ptr_t S24;
S    ptr_t S25;
S    ptr_t S26;
S    ptr_t S27;
S    ptr_t S28;
S    ptr_t S29;
S    ptr_t S30;
S    ptr_t S31;
S};
S
Sstruct RVM_Regs
S{
S    struct RVM_Reg_Struct Reg;
S    struct RVM_Cop_Struct Cop_Reg;
S};
S
S/* We used structs in the header */
Sstruct RVM_Param
S{
S    ptr_t Number;
S    ptr_t Param[4];
S};
S
S/* The page table layout is statically decided, the first one being the top-level */
Sstruct RVM_Hdr_Pgtbl
S{
S    /* Its parent's position */
S    ptr_t Parent;
S    /* The start address of the mapping */
S    ptr_t Addr;
S    /* The size order and number order, combined into one word */
S    ptr_t Order;
S    /* The initially mapped pages' data. The only thing stored here
S     * is the RVM standard flags */
S    u8 Flags[8];
S};
S
Sstruct RVM_Int_Flag
S{
S    ptr_t Flags[RVM_VECT_BITMAP];
S};
S
S/* The image structure */
Sstruct RVM_Image
S{
S    /* The magic number;always equal to VIRT(0x56495254) */
S    const ptr_t Magic;
S    /* The name is always 16 bytes long. This is fixed and is not changeable */
S    s8 Name[16];
S
S    /* The entry, stack and stack size of the virtual machines */
S    void* User_Entry;
S    void* User_Stack;
S    ptr_t User_Size;
S    void* Int_Entry;
S    void* Int_Stack;
S    ptr_t Int_Size;
S    
S    /* The parameter space, register set space and interrupt flag space */
S    struct RVM_Param* Param;
S    struct RVM_Regs* Regs;
S    struct RVM_Int_Flag* Int_Flags;
S    
S    /* The console space and size */
S    void* Console_Buf;
S    ptr_t Console_Size;
S    
S    /* The priority and timeslices */
S    ptr_t Prio;
S    ptr_t Slices;
S
S    /* The number of page tables in this image, and where are they stored */
S    ptr_t Pgtbl_Num;
S    const struct RVM_Hdr_Pgtbl* Pgtbl;
S
S    /* Is there any other images? If there is, here is a pointer to the start
S     * of the next one. This is a constant pointer to a constant pointer to a 
S     * constant structure */
S    const struct RVM_Image* const * const Next_Image;
S};
S
S/* Use defines in these headers */
S#define __HDR_DEFS__
S#undef __HDR_DEFS__
S/*****************************************************************************/
S
S/*****************************************************************************/
S/* __PLATFORM_CMX_RVM_H_STRUCTS__ */
S#endif
S/* __HDR_STRUCTS__ */
N#endif
N/* End Structs ***************************************************************/
N
N/* Private Global Variables **************************************************/
N#if(!(defined __HDR_DEFS__||defined __HDR_STRUCTS__))
X#if(!(1L||0L))
S#ifndef __PLATFORM_CMX_RVM_MEMBERS__
S#define __PLATFORM_CMX_RVM_MEMBERS__
S
S/* In this way we can use the data structures and definitions in the headers */
S#define __HDR_DEFS__
S
S#undef __HDR_DEFS__
S
S#define __HDR_STRUCTS__
S
S#undef __HDR_STRUCTS__
S
S/* If the header is not used in the public mode */
S#ifndef __HDR_PUBLIC_MEMBERS__
S/*****************************************************************************/
S
S/*****************************************************************************/
S/* End Private Global Variables **********************************************/
S
S/* Private C Function Prototypes *********************************************/ 
S/*****************************************************************************/
Sstatic ret_t RMP_Hypercall(ptr_t Number, ptr_t Param1, ptr_t Param2, ptr_t Param3, ptr_t Param4);
Sstatic ret_t _RMP_Get_Int(void);
S
S/* Interrupts */
Sstatic void RMP_PendSV_Handler(void);
Sstatic void RMP_SysTick_Handler(void);
S/*****************************************************************************/
S#define __EXTERN__
S/* End Private C Function Prototypes *****************************************/
S
S/* Public Global Variables ***************************************************/
S/* __HDR_PUBLIC_MEMBERS__ */
S#else
S#define __EXTERN__ EXTERN 
S/* __HDR_PUBLIC_MEMBERS__ */
S#endif
S
S/*****************************************************************************/
S/* The debug console buffer and pointer */
S__EXTERN__ s8 RMP_Console[RMP_KERNEL_DEBUG_MAX_STR];
S__EXTERN__ ptr_t RMP_Console_Ptr;
S
S/* The initial stack pointer as defined in assembly */
SEXTERN ptr_t RMP_User_Stack;
SEXTERN ptr_t __initial_sp;
SEXTERN ptr_t RMP_Int_Stack;
S/* The hypercall parameter& structure */
S__EXTERN__ struct RVM_Param RMP_Param;
S__EXTERN__ struct RVM_Regs RMP_Regs;
S/* Just map everything into it */
SEXTERN const struct RVM_Hdr_Pgtbl RMP_Pgtbl[1];
SEXTERN const struct RVM_Image RMP_Image;
S
S/* The interrupt flag used by here */
S__EXTERN__ ptr_t RMP_Ctxsw;
S/* The interrupt handler registration table */
S__EXTERN__ ptr_t RMP_Vect[RVM_MAX_INTVECT];
S/* The interrupt flag registration table */
S__EXTERN__ struct RVM_Int_Flag RMP_Flag;
S/*****************************************************************************/
S
S/* End Public Global Variables ***********************************************/
S
S/* Public C Function Prototypes **********************************************/
S/*****************************************************************************/
SEXTERN void RMP_Disable_Int(void);
SEXTERN void RMP_Enable_Int(void);
S
SEXTERN ptr_t RMP_MSB_Get(ptr_t Val);
SEXTERN ptr_t _RMP_Fetch_And(ptr_t* Ptr, ptr_t Operand);
SEXTERN void _RMP_Start(ptr_t Entry, ptr_t Stack);
SEXTERN void _RMP_Yield(void);
SEXTERN void _RMP_Int_Rcv(void);
S
S
S/* Initialization */
S__EXTERN__ void _RMP_Stack_Init(ptr_t Entry, ptr_t Stack, ptr_t Arg);
S__EXTERN__ void _RMP_Low_Level_Init(void);
S__EXTERN__ void RMP_Putchar(char Char);
S__EXTERN__ void _RMP_Plat_Hook(void);
S
S/* Hypercalls */
SEXTERN void _RMP_Hypercall(void);
SEXTERN void _RMP_Entry(void);
S
S/* Interrupt handler entry */
S__EXTERN__ void _RMP_Int(void);
S
S__EXTERN__ void RMP_Wait_Int(void);
S__EXTERN__ ret_t RMP_Hyp_Reg_Evt(ptr_t Int_Num, ptr_t VMID);
S__EXTERN__ ret_t RMP_Hyp_Del_Evt(cnt_t Evt_ID);
S__EXTERN__ ret_t RVM_Hyp_Send_Evt(ptr_t Evt_ID);
S__EXTERN__ ret_t RVM_Hyp_Query_Evt(ptr_t VMID);
S__EXTERN__ ret_t RVM_Hyp_Query(s8* Name);
S__EXTERN__ ret_t RVM_Hyp_Tim_Prog(ptr_t Period);
S__EXTERN__ ret_t RVM_Hyp_Print(void);
S/*****************************************************************************/
S/* Undefine "__EXTERN__" to avoid redefinition */
S#undef __EXTERN__
S/* __PLATFORM_CMX_RVM_MEMBERS__ */
S#endif
S/* !(defined __HDR_DEFS__||defined __HDR_STRUCTS__) */
N#endif
N/* End Public C Function Prototypes ******************************************/
N
N/* End Of File ***************************************************************/
N
N/* Copyright (C) Evo-Devo Instrum. All rights reserved ***********************/
L 11 "..\..\MProkaron\Include\Platform/RMP_platform.h" 2
N/* End Platform Includes *****************************************************/
N
N/* End Of File ***************************************************************/
N
N/* Copyright (C) Evo-Devo Instrum. All rights reserved ***********************/
L 15 "..\..\MProkaron\Kernel\kernel.c" 2
N#include "Kernel/kernel.h"
L 1 "..\..\MProkaron\Include\Kernel/kernel.h" 1
N/******************************************************************************
NFilename    : kernel.h
NAuthor      : pry
NDate        : 01/04/2017
NLicence     : LGPL v3+; see COPYING for details.
NDescription : The header file for the kernel.
N******************************************************************************/
N
N/* Defines *******************************************************************/
N#ifdef __HDR_DEFS__
N#ifndef __KERNEL_H_DEFS__
N#define __KERNEL_H_DEFS__
N/*****************************************************************************/
N/* Constants */
N#define RMP_TRUE               1
N#define RMP_FALSE              0
N/* States of threads */
N#define RMP_THD_STATE(X)       ((X)&0xFF)
N#define RMP_THD_FLAG(X)        ((X)&~0xFF)
N#define RMP_THD_STATE_SET(X,S) ((X)=(RMP_THD_FLAG(X)|(S)))
N
N/* This thread is currently unused */
N#define RMP_THD_FREE           (0)
N/* This thread is currently running */
N#define RMP_THD_RUNNING        (1)
N/* Blocked on a send endpoint */
N#define RMP_THD_SNDBLK         (2)
N/* Blocked on a send endpoint with a timeout */
N#define RMP_THD_SNDDLY         (3)
N/* Blocked on its own receive endpoint */
N#define RMP_THD_RCVBLK         (4)
N/* Blocked on its own receive endpoint with a timeout */
N#define RMP_THD_RCVDLY         (5)
N/* Just on the timer delay */
N#define RMP_THD_DELAYED        (6)
N/* Blocked on a semaphore */
N#define RMP_THD_SEMBLK         (7)
N/* Blocked on a semaphore with a timeout */
N#define RMP_THD_SEMDLY         (8)
N/* Suspended */
N#define RMP_THD_SUSPENDED      (1<<8)
N/* Mailbox valid */
N#define RMP_THD_MBOXFUL        (RMP_THD_SUSPENDED<<1)
N    
N/* States of semaphores */
N#define RMP_SEM_FREE           (0)
N#define RMP_SEM_USED           (1)
N
N/* Error codes */
N/* This error is thread related */
N#define RMP_ERR_THD            (-1)
N/* This error is priority related */
N#define RMP_ERR_PRIO           (-2)
N/* This error is timeslice related */
N#define RMP_ERR_SLICE          (-3)
N/* This error is thread state related */
N#define RMP_ERR_STATE          (-4)
N/* This error is operation related */
N#define RMP_ERR_OPER           (-5)
N/* This error is semaphore related */
N#define RMP_ERR_SEM            (-6)
N
N/* Word sizes settings */
N#define RMP_WORD_SIZE          (((ptr_t)1)<<RMP_WORD_ORDER)
N#define RMP_WORD_MASK          (~(((ptr_t)(-1))<<(RMP_WORD_ORDER-1)))
N#define RMP_BITMAP_SIZE        ((RMP_MAX_PREEMPT_PRIO-1)/RMP_WORD_SIZE+1)
N#define RMP_ALLBITS            ((ptr_t)(-1))
N
N/* Stack offset macros */
N/* Head offset, for ascending stacks */
N#define RMP_INIT_STACK_HEAD(X)   (((ptr_t)RMP_Init_Stack)+(X)*sizeof(ptr_t))
N/* Tail offset, for descending stacks */
N#define RMP_INIT_STACK_TAIL(X)   (((ptr_t)RMP_Init_Stack)+RMP_INIT_STACK_SIZE-(X)*sizeof(ptr_t))
N
N/* Get the thread from delay list */
N#define RMP_DLY2THD(X)         ((struct RMP_Thd*)(((ptr_t)(X))-sizeof(struct RMP_List)))
N
N/* Printk macros */
N#define RMP_PRINTK_I(INT)      RMP_Print_Int((INT))
N#define RMP_PRINTK_U(UINT)     RMP_Print_Uint((UINT))
N#define RMP_PRINTK_S(STR)      RMP_Print_String((s8*)(STR))
N    
N/* Assert macro */
N#define RMP_ASSERT(X) \
Ndo \
N{ \
N    if((X)==0) \
N    { \
N        RMP_PRINTK_S("\r\n***\r\nKernel panic - not syncing:\r\n"); \
N        RMP_PRINTK_S(__FILE__); \
N        RMP_PRINTK_S(" , Line "); \
N        RMP_PRINTK_I(__LINE__); \
N        RMP_PRINTK_S("\r\n"); \
N        RMP_PRINTK_S(__DATE__); \
N        RMP_PRINTK_S(" , "); \
N        RMP_PRINTK_S(__TIME__); \
N        RMP_PRINTK_S("\r\n"); \
N        while(1); \
N    } \
N} \
Nwhile(0)
X#define RMP_ASSERT(X) do {     if((X)==0)     {         RMP_PRINTK_S("\r\n***\r\nKernel panic - not syncing:\r\n");         RMP_PRINTK_S(__FILE__);         RMP_PRINTK_S(" , Line ");         RMP_PRINTK_I(__LINE__);         RMP_PRINTK_S("\r\n");         RMP_PRINTK_S(__DATE__);         RMP_PRINTK_S(" , ");         RMP_PRINTK_S(__TIME__);         RMP_PRINTK_S("\r\n");         while(1);     } } while(0)
N/*****************************************************************************/
N/* __KERNEL_H_DEFS__ */
N#endif
N/* __HDR_DEFS__ */
N#endif
N/* End Defines ***************************************************************/
N
N/* Structs *******************************************************************/
N#ifdef __HDR_STRUCTS__
S#ifndef __KERNEL_H_STRUCTS__
S#define __KERNEL_H_STRUCTS__
S/* We used structs in the header */
S
S/* Use defines in these headers */
S#define __HDR_DEFS__
S#undef __HDR_DEFS__
S/*****************************************************************************/
S/* The list head structure */
Sstruct RMP_List
S{
S    volatile struct RMP_List* Prev;
S    volatile struct RMP_List* Next;
S};
S
Sstruct RMP_Thd
S{
S    /* The head to insert into the status queue */
S    struct RMP_List Run_Head;
S    /* This is exclusively for the timer queue */
S    struct RMP_List Dly_Head;
S    /* The list of threads suspended on it because of sending */
S    struct RMP_List Snd_List;
S    /* The state of this thread */
S    ptr_t State;
S    /* If it is running, how many timeslices it have */
S    ptr_t Slices;
S    /* If it is running, how many ticks does it have remaining */
S    ptr_t Slices_Left;
S    /* What priority it is running at */
S    ptr_t Prio;
S    /* The timeout time */
S    ptr_t Timeout;
S    /* The mailbox value */
S    ptr_t Mailbox;
S    /* The data to send */  
S    ptr_t Data;
S    /* The stack address */
S    ptr_t Stack;
S    /* The return value of certain function calls */
S    ret_t Retval;
S};
S
S/* The semaphore structure */
Sstruct RMP_Sem
S{
S    /* The waiting queue */
S    struct RMP_List Wait_List;
S    /* The state of the semaphore */
S    ptr_t State;
S    /* The current number of semaphore */
S    ptr_t Cur_Num;
S};
S/*****************************************************************************/
S/* __KERNEL_H_STRUCTS__ */
S#endif
S/* __HDR_STRUCTS__ */
N#endif
N/* End Structs ***************************************************************/
N
N/* Private Global Variables **************************************************/
N#if(!(defined __HDR_DEFS__||defined __HDR_STRUCTS__))
X#if(!(1L||0L))
S#ifndef __KERNEL_MEMBERS__
S#define __KERNEL_MEMBERS__
S
S/* In this way we can use the data structures and definitions in the headers */
S#define __HDR_DEFS__
S
S#undef __HDR_DEFS__
S
S#define __HDR_STRUCTS__
S
S#undef __HDR_STRUCTS__
S
S/* If the header is not used in the public mode */
S#ifndef __HDR_PUBLIC_MEMBERS__
S/*****************************************************************************/
S/* The scheduler bitmap */
Sstatic ptr_t RMP_Bitmap[RMP_BITMAP_SIZE];
Sstatic struct RMP_List RMP_Run[RMP_MAX_PREEMPT_PRIO];
Sstatic struct RMP_List RMP_Delay;
S
S/* The timestamp value */
Sstatic ptr_t RMP_Tick;
S/* Scheduler lock */
Sstatic ptr_t RMP_Sched_Lock_Cnt;
Sstatic ptr_t RMP_Sched_Locked;
S/* Scheduler pending */
Sstatic ptr_t RMP_Sched_Pend;
S/* Timer events pending */
Sstatic ptr_t RMP_Timer_Pend;
S
S/* Init thread */
Sstatic ptr_t RMP_Init_Stack[RMP_INIT_STACK_SIZE>>(RMP_WORD_ORDER-3)];
Sstatic struct RMP_Thd RMP_Init_Thd;
S/*****************************************************************************/
S/* End Private Global Variables **********************************************/
S
S/* Private C Function Prototypes *********************************************/ 
S/*****************************************************************************/
Sstatic void _RMP_Set_Rdy(struct RMP_Thd* Thread);
Sstatic void _RMP_Clr_Rdy(struct RMP_Thd* Thread);
Sstatic void _RMP_Dly_Ins(struct RMP_Thd* Thread, ptr_t Slices);
Sstatic void _RMP_Timer_Proc(void);
S/*****************************************************************************/
S#define __EXTERN__
S/* End Private C Function Prototypes *****************************************/
S
S/* Public Global Variables ***************************************************/
S/* __HDR_PUBLIC_MEMBERS__ */
S#else
S#define __EXTERN__ EXTERN 
S/* __HDR_PUBLIC_MEMBERS__ */
S#endif
S
S/*****************************************************************************/
S
S
S/* The current thread */
S__EXTERN__ struct RMP_Thd* RMP_Cur_Thd;
S__EXTERN__ ptr_t RMP_Cur_SP;
S/*****************************************************************************/
S
S/* End Public Global Variables ***********************************************/
S
S/* Public C Function Prototypes **********************************************/
S/*****************************************************************************/
S/* This is the entry of user applications */
SEXTERN void RMP_Init(void);
S__EXTERN__ void _RMP_Get_High_Rdy(void);
S__EXTERN__ void _RMP_Tick_Handler(ptr_t Ticks);
S__EXTERN__ ptr_t _RMP_Get_Near_Ticks(void);
S__EXTERN__ void RMP_Clear(void* Addr, ptr_t Size);
S
S/* Scheduler locking & unlocking */
S__EXTERN__ void RMP_Lock_Sched(void);
S__EXTERN__ void RMP_Unlock_Sched(void);
S
S/* Debug printing functions */
S__EXTERN__ cnt_t RMP_Print_Int(cnt_t Int);
S__EXTERN__ cnt_t RMP_Print_Uint(ptr_t Uint);
S__EXTERN__ cnt_t RMP_Print_String(s8* String);
S
S/* List operation functions */
S__EXTERN__ void RMP_List_Crt(volatile struct RMP_List* Head);
S__EXTERN__ void RMP_List_Del(volatile struct RMP_List* Prev,volatile struct RMP_List* Next);
S__EXTERN__ void RMP_List_Ins(volatile struct RMP_List* New,
S                             volatile struct RMP_List* Prev,
S                             volatile struct RMP_List* Next);
S
S/* System interfaces */
S__EXTERN__ void RMP_Yield(void);
S__EXTERN__ ret_t RMP_Thd_Crt(struct RMP_Thd* Thread, 
S                             void* Entry, void* Stack, void* Arg, 
S                             ptr_t Prio, ptr_t Slices);
S__EXTERN__ ret_t RMP_Thd_Del(struct RMP_Thd* Thread);
S__EXTERN__ ret_t RMP_Thd_Set(struct RMP_Thd* Thread, ptr_t Prio, ptr_t Slices);
S__EXTERN__ ret_t RMP_Thd_Suspend(struct RMP_Thd* Thread);
S__EXTERN__ ret_t RMP_Thd_Resume(struct RMP_Thd* Thread);
S
S__EXTERN__ ret_t RMP_Thd_Delay(ptr_t Slices);
S__EXTERN__ ret_t RMP_Thd_Cancel(struct RMP_Thd* Thread);
S
S__EXTERN__ ret_t RMP_Thd_Snd(struct RMP_Thd* Thread, ptr_t Data, ptr_t Slices);
S__EXTERN__ ret_t RMP_Thd_Snd_ISR(struct RMP_Thd* Thread, ptr_t Data);
S__EXTERN__ ret_t RMP_Thd_Rcv(ptr_t* Data, ptr_t Slices);
S
S__EXTERN__ ret_t RMP_Sem_Crt(struct RMP_Sem* Semaphore, ptr_t Number);
S__EXTERN__ ret_t RMP_Sem_Del(struct RMP_Sem* Semaphore);
S__EXTERN__ ret_t RMP_Sem_Pend(struct RMP_Sem* Semaphore, ptr_t Slices);
S__EXTERN__ ret_t RMP_Sem_Abort(struct RMP_Thd* Thread);
S__EXTERN__ ret_t RMP_Sem_Post(struct RMP_Sem* Semaphore, ptr_t Number);
S__EXTERN__ ret_t RMP_Sem_Post_ISR(struct RMP_Sem* Semaphore, ptr_t Number);
S
S/* Hook functions */
S#if(RMP_USE_HOOKS==RMP_TRUE)
S    EXTERN void RMP_Start_Hook(void);
S    EXTERN void RMP_Save_Ctx(void);
S    EXTERN void RMP_Load_Ctx(void);
S    EXTERN void RMP_Tick_Hook(ptr_t Ticks);
S#else
S    __EXTERN__ void RMP_Start_Hook(void);
S    __EXTERN__ void RMP_Save_Ctx(void);
S    __EXTERN__ void RMP_Load_Ctx(void);
S    __EXTERN__ void RMP_Tick_Hook(ptr_t Ticks);
S#endif
S
SEXTERN void RMP_Init_Hook(void);
SEXTERN void RMP_Init_Idle(void);
S/*****************************************************************************/
S/* Undefine "__EXTERN__" to avoid redefinition */
S#undef __EXTERN__
S/* __KERNEL_MEMBERS__ */
S#endif
S/* !(defined __HDR_DEFS__||defined __HDR_STRUCTS__) */
N#endif
N/* End Public C Function Prototypes ******************************************/
N
N/* End Of File ***************************************************************/
N
N/* Copyright (C) Evo-Devo Instrum. All rights reserved ***********************/
L 16 "..\..\MProkaron\Kernel\kernel.c" 2
N#undef __HDR_DEFS__
N
N#define __HDR_STRUCTS__
N#include "Platform/RMP_platform.h"
L 1 "..\..\MProkaron\Include\Platform/RMP_platform.h" 1
N/******************************************************************************
NFilename    : RMP_platform.h
NAuthor      : pry 
NDate        : 22/07/2017
NLicence     : LGPL v3+; see COPYING for details.
NDescription : The platform specific types for RMP.
N******************************************************************************/
N
N/* Platform Includes *********************************************************/
N#include "Platform/CortexM_RVM/platform_cmx_RVM.h"
L 1 "..\..\MProkaron\Include\Platform/CortexM_RVM/platform_cmx_RVM.h" 1
N/******************************************************************************
NFilename    : platform_cmx_RVM.h
NAuthor      : pry
NDate        : 01/04/2017
NLicence     : LGPL v3+; see COPYING for details.
NDescription : The header of platform-specific part of RMP for RVM.
N******************************************************************************/
N
N/* Defines *******************************************************************/
N#ifdef __HDR_DEFS__
S#ifndef __PLATFORM_CMX_RVM_H_DEFS__
S#define __PLATFORM_CMX_RVM_H_DEFS__
S/*****************************************************************************/
S/* Basic Types ***************************************************************/
S#if(DEFINE_BASIC_TYPES==TRUE)
S
S#ifndef __S32__
S#define __S32__
Stypedef signed int  s32;
S#endif
S
S#ifndef __S16__
S#define __S16__
Stypedef signed short s16;
S#endif
S
S#ifndef __S8__
S#define __S8__
Stypedef signed char  s8;
S#endif
S
S#ifndef __U32__
S#define __U32__
Stypedef unsigned int  u32;
S#endif
S
S#ifndef __U16__
S#define __U16__
Stypedef unsigned short u16;
S#endif
S
S#ifndef __U8__
S#define __U8__
Stypedef unsigned char  u8;
S#endif
S
S#endif
S/* End Basic Types ***********************************************************/
S
S/* Begin Extended Types ******************************************************/
S#ifndef __TID_T__
S#define __TID_T__
S/* The typedef for the Thread ID */
Stypedef s32 tid_t;
S#endif
S
S#ifndef __PTR_T__
S#define __PTR_T__
S/* The typedef for the pointers - This is the raw style. Pointers must be unsigned */
Stypedef u32 ptr_t;
S#endif
S
S#ifndef __CNT_T__
S#define __CNT_T__
S/* The typedef for the count variables */
Stypedef s32 cnt_t;
S#endif
S
S#ifndef __CID_T__
S#define __CID_T__
S/* The typedef for capability ID */
Stypedef s32 cid_t;
S#endif
S
S#ifndef __RET_T__
S#define __RET_T__
S/* The type for process return value */
Stypedef s32 ret_t;
S#endif
S/* End Extended Types ********************************************************/
S
S/* System macros *************************************************************/
S/* Compiler "extern" keyword setting */
S#define EXTERN                   extern
S/* The order of bits in one CPU machine word */
S#define RMP_WORD_ORDER           5
S/* The maximum length of char printing - no need to change this in most cases */
S#define RMP_KERNEL_DEBUG_MAX_STR 128
S/* The offset of the stack when initializing */
S#define RMP_INIT_STACK           RMP_INIT_STACK_TAIL(17)
S
S/* The CPU and application specific macros are here */
S#include "platform_cmx_RVM_conf.h"
S/* End System macros *********************************************************/
S
S/* Hypervisor macros *********************************************************/
S#define RVM_MAGIC                0x56495254
S#define RVM_VECT_BITMAP          ((RVM_MAX_INTVECT-1)/RMP_WORD_SIZE+1)
S
S/* Hypercalls */
S/* Enable interrupts */
S#define RVM_HYP_ENAINT           0
S/* Disable interrupts */
S#define RVM_HYP_DISINT           1
S/* Register a vector */
S#define RVM_HYP_REGEVT           2
S/* Delete a vector */
S#define RVM_HYP_DELEVT           3
S/* Wait for an interrupt to come */
S#define RVM_HYP_WAITEVT          4
S/* Trigger a vector */
S#define RVM_HYP_SENDEVT          5
S/* Returning from a vector */
S#define RVM_HYP_QUERYEVT         6
S/* Query the VM's ID given its name */
S#define RVM_HYP_QUERY            7
S/* Send to another VM */
S#define RVM_HYP_TIMPROG          8
S/* Print to the console */
S#define RVM_HYP_PRINT            9
S
S/* System stack size when entering the system - do not need to be changed in most cases */
S#define RMP_INT_STACK_ADDR           (((ptr_t)&__initial_sp)+0x400-64*sizeof(ptr_t))
S    
S/* Generic page table flags */
S#define RME_PGTBL_ORDER(SIZE,NUM)    (((SIZE)<<(sizeof(ptr_t)*4))|(NUM))
S#define RME_PGTBL_READ               (1<<0)
S#define RME_PGTBL_WRITE              (1<<1)
S#define RME_PGTBL_EXECUTE            (1<<2)
S#define RME_PGTBL_CACHEABLE          (1<<3)
S#define RME_PGTBL_BUFFERABLE         (1<<4)
S#define RME_PGTBL_STATIC             (1<<5)
S
S#define RME_PGTBL_ALL_PERM           (RME_PGTBL_READ|RME_PGTBL_WRITE|RME_PGTBL_EXECUTE| \
S                                      RME_PGTBL_CACHEABLE|RME_PGTBL_BUFFERABLE|RME_PGTBL_STATIC)
X#define RME_PGTBL_ALL_PERM           (RME_PGTBL_READ|RME_PGTBL_WRITE|RME_PGTBL_EXECUTE|                                       RME_PGTBL_CACHEABLE|RME_PGTBL_BUFFERABLE|RME_PGTBL_STATIC)
S                                        
S/* Generic page size order definitions */
S#define RME_PGTBL_SIZE_2B            (1)
S#define RME_PGTBL_SIZE_4B            (2)
S#define RME_PGTBL_SIZE_8B            (3)
S#define RME_PGTBL_SIZE_16B           (4)
S#define RME_PGTBL_SIZE_32B           (5)
S#define RME_PGTBL_SIZE_64B           (6)
S#define RME_PGTBL_SIZE_128B          (7)
S#define RME_PGTBL_SIZE_256B          (8)
S#define RME_PGTBL_SIZE_512B          (9)
S#define RME_PGTBL_SIZE_1K            (10)
S#define RME_PGTBL_SIZE_2K            (11)
S#define RME_PGTBL_SIZE_4K            (12)
S#define RME_PGTBL_SIZE_8K            (13)
S#define RME_PGTBL_SIZE_16K           (14)
S#define RME_PGTBL_SIZE_32K           (15)
S#define RME_PGTBL_SIZE_64K           (16)
S#define RME_PGTBL_SIZE_128K          (17)
S#define RME_PGTBL_SIZE_256K          (18)
S#define RME_PGTBL_SIZE_512K          (19)
S#define RME_PGTBL_SIZE_1M            (20)
S#define RME_PGTBL_SIZE_2M            (21)
S#define RME_PGTBL_SIZE_4M            (22)
S#define RME_PGTBL_SIZE_8M            (23)
S#define RME_PGTBL_SIZE_16M           (24)
S#define RME_PGTBL_SIZE_32M           (25)
S#define RME_PGTBL_SIZE_64M           (26)
S#define RME_PGTBL_SIZE_128M          (27)
S#define RME_PGTBL_SIZE_256M          (28)
S#define RME_PGTBL_SIZE_512M          (29)
S#define RME_PGTBL_SIZE_1G            (30)
S#define RME_PGTBL_SIZE_2G            (31)
S#define RME_PGTBL_SIZE_4G            (32)
S
S/* Generic page table entry number definitions */
S#define RME_PGTBL_NUM_2             (1)
S#define RME_PGTBL_NUM_4             (2)
S#define RME_PGTBL_NUM_8             (3)
S#define RME_PGTBL_NUM_16            (4)
S#define RME_PGTBL_NUM_32            (5)
S#define RME_PGTBL_NUM_64            (6)
S#define RME_PGTBL_NUM_128           (7)
S#define RME_PGTBL_NUM_256           (8)
S#define RME_PGTBL_NUM_512           (9)
S#define RME_PGTBL_NUM_1K            (10)
S#define RME_PGTBL_NUM_2K            (11)
S#define RME_PGTBL_NUM_4K            (12)
S#define RME_PGTBL_NUM_8K            (13)
S#define RME_PGTBL_NUM_16K           (14)
S#define RME_PGTBL_NUM_32K           (15)
S#define RME_PGTBL_NUM_64K           (16)
S#define RME_PGTBL_NUM_128K          (17)
S#define RME_PGTBL_NUM_256K          (18)
S#define RME_PGTBL_NUM_512K          (19)
S#define RME_PGTBL_NUM_1M            (20)
S#define RME_PGTBL_NUM_2M            (21)
S#define RME_PGTBL_NUM_4M            (22)
S/* End Hypervisor macros *****************************************************/
S/*****************************************************************************/
S/* __PLATFORM_CMX_RVM_H_DEFS__ */
S#endif
S/* __HDR_DEFS__ */
N#endif
N/* End Defines ***************************************************************/
N
N/* Structs *******************************************************************/
N#ifdef __HDR_STRUCTS__
N#ifndef __PLATFORM_CMX_RVM_H_STRUCTS__
N#define __PLATFORM_CMX_RVM_H_STRUCTS__
N
Nstruct RVM_Reg_Struct
N{
N    ptr_t SP;
N    ptr_t R4;
N    ptr_t R5;
N    ptr_t R6;
N    ptr_t R7;
N    ptr_t R8;
N    ptr_t R9;
N    ptr_t R10;
N    ptr_t R11;
N    ptr_t LR;
N};
N
N/* The coprocessor register set structure. In Cortex-M, if there is a 
N * single-precision FPU, then the FPU S0-S15 is automatically pushed */
Nstruct RVM_Cop_Struct
N{
N    ptr_t S16;
N    ptr_t S17;
N    ptr_t S18;
N    ptr_t S19;
N    ptr_t S20;
N    ptr_t S21;
N    ptr_t S22;
N    ptr_t S23;
N    ptr_t S24;
N    ptr_t S25;
N    ptr_t S26;
N    ptr_t S27;
N    ptr_t S28;
N    ptr_t S29;
N    ptr_t S30;
N    ptr_t S31;
N};
N
Nstruct RVM_Regs
N{
N    struct RVM_Reg_Struct Reg;
N    struct RVM_Cop_Struct Cop_Reg;
N};
N
N/* We used structs in the header */
Nstruct RVM_Param
N{
N    ptr_t Number;
N    ptr_t Param[4];
N};
N
N/* The page table layout is statically decided, the first one being the top-level */
Nstruct RVM_Hdr_Pgtbl
N{
N    /* Its parent's position */
N    ptr_t Parent;
N    /* The start address of the mapping */
N    ptr_t Addr;
N    /* The size order and number order, combined into one word */
N    ptr_t Order;
N    /* The initially mapped pages' data. The only thing stored here
N     * is the RVM standard flags */
N    u8 Flags[8];
N};
N
Nstruct RVM_Int_Flag
N{
N    ptr_t Flags[RVM_VECT_BITMAP];
X    ptr_t Flags[((32-1)/(((ptr_t)1)<<5)+1)];
N};
N
N/* The image structure */
Nstruct RVM_Image
N{
N    /* The magic number;always equal to VIRT(0x56495254) */
N    const ptr_t Magic;
N    /* The name is always 16 bytes long. This is fixed and is not changeable */
N    s8 Name[16];
N
N    /* The entry, stack and stack size of the virtual machines */
N    void* User_Entry;
N    void* User_Stack;
N    ptr_t User_Size;
N    void* Int_Entry;
N    void* Int_Stack;
N    ptr_t Int_Size;
N    
N    /* The parameter space, register set space and interrupt flag space */
N    struct RVM_Param* Param;
N    struct RVM_Regs* Regs;
N    struct RVM_Int_Flag* Int_Flags;
N    
N    /* The console space and size */
N    void* Console_Buf;
N    ptr_t Console_Size;
N    
N    /* The priority and timeslices */
N    ptr_t Prio;
N    ptr_t Slices;
N
N    /* The number of page tables in this image, and where are they stored */
N    ptr_t Pgtbl_Num;
N    const struct RVM_Hdr_Pgtbl* Pgtbl;
N
N    /* Is there any other images? If there is, here is a pointer to the start
N     * of the next one. This is a constant pointer to a constant pointer to a 
N     * constant structure */
N    const struct RVM_Image* const * const Next_Image;
N};
N
N/* Use defines in these headers */
N#define __HDR_DEFS__
N#undef __HDR_DEFS__
N/*****************************************************************************/
N
N/*****************************************************************************/
N/* __PLATFORM_CMX_RVM_H_STRUCTS__ */
N#endif
N/* __HDR_STRUCTS__ */
N#endif
N/* End Structs ***************************************************************/
N
N/* Private Global Variables **************************************************/
N#if(!(defined __HDR_DEFS__||defined __HDR_STRUCTS__))
X#if(!(0L||1L))
S#ifndef __PLATFORM_CMX_RVM_MEMBERS__
S#define __PLATFORM_CMX_RVM_MEMBERS__
S
S/* In this way we can use the data structures and definitions in the headers */
S#define __HDR_DEFS__
S
S#undef __HDR_DEFS__
S
S#define __HDR_STRUCTS__
S
S#undef __HDR_STRUCTS__
S
S/* If the header is not used in the public mode */
S#ifndef __HDR_PUBLIC_MEMBERS__
S/*****************************************************************************/
S
S/*****************************************************************************/
S/* End Private Global Variables **********************************************/
S
S/* Private C Function Prototypes *********************************************/ 
S/*****************************************************************************/
Sstatic ret_t RMP_Hypercall(ptr_t Number, ptr_t Param1, ptr_t Param2, ptr_t Param3, ptr_t Param4);
Sstatic ret_t _RMP_Get_Int(void);
S
S/* Interrupts */
Sstatic void RMP_PendSV_Handler(void);
Sstatic void RMP_SysTick_Handler(void);
S/*****************************************************************************/
S#define __EXTERN__
S/* End Private C Function Prototypes *****************************************/
S
S/* Public Global Variables ***************************************************/
S/* __HDR_PUBLIC_MEMBERS__ */
S#else
S#define __EXTERN__ EXTERN 
S/* __HDR_PUBLIC_MEMBERS__ */
S#endif
S
S/*****************************************************************************/
S/* The debug console buffer and pointer */
S__EXTERN__ s8 RMP_Console[RMP_KERNEL_DEBUG_MAX_STR];
S__EXTERN__ ptr_t RMP_Console_Ptr;
S
S/* The initial stack pointer as defined in assembly */
SEXTERN ptr_t RMP_User_Stack;
SEXTERN ptr_t __initial_sp;
SEXTERN ptr_t RMP_Int_Stack;
S/* The hypercall parameter& structure */
S__EXTERN__ struct RVM_Param RMP_Param;
S__EXTERN__ struct RVM_Regs RMP_Regs;
S/* Just map everything into it */
SEXTERN const struct RVM_Hdr_Pgtbl RMP_Pgtbl[1];
SEXTERN const struct RVM_Image RMP_Image;
S
S/* The interrupt flag used by here */
S__EXTERN__ ptr_t RMP_Ctxsw;
S/* The interrupt handler registration table */
S__EXTERN__ ptr_t RMP_Vect[RVM_MAX_INTVECT];
S/* The interrupt flag registration table */
S__EXTERN__ struct RVM_Int_Flag RMP_Flag;
S/*****************************************************************************/
S
S/* End Public Global Variables ***********************************************/
S
S/* Public C Function Prototypes **********************************************/
S/*****************************************************************************/
SEXTERN void RMP_Disable_Int(void);
SEXTERN void RMP_Enable_Int(void);
S
SEXTERN ptr_t RMP_MSB_Get(ptr_t Val);
SEXTERN ptr_t _RMP_Fetch_And(ptr_t* Ptr, ptr_t Operand);
SEXTERN void _RMP_Start(ptr_t Entry, ptr_t Stack);
SEXTERN void _RMP_Yield(void);
SEXTERN void _RMP_Int_Rcv(void);
S
S
S/* Initialization */
S__EXTERN__ void _RMP_Stack_Init(ptr_t Entry, ptr_t Stack, ptr_t Arg);
S__EXTERN__ void _RMP_Low_Level_Init(void);
S__EXTERN__ void RMP_Putchar(char Char);
S__EXTERN__ void _RMP_Plat_Hook(void);
S
S/* Hypercalls */
SEXTERN void _RMP_Hypercall(void);
SEXTERN void _RMP_Entry(void);
S
S/* Interrupt handler entry */
S__EXTERN__ void _RMP_Int(void);
S
S__EXTERN__ void RMP_Wait_Int(void);
S__EXTERN__ ret_t RMP_Hyp_Reg_Evt(ptr_t Int_Num, ptr_t VMID);
S__EXTERN__ ret_t RMP_Hyp_Del_Evt(cnt_t Evt_ID);
S__EXTERN__ ret_t RVM_Hyp_Send_Evt(ptr_t Evt_ID);
S__EXTERN__ ret_t RVM_Hyp_Query_Evt(ptr_t VMID);
S__EXTERN__ ret_t RVM_Hyp_Query(s8* Name);
S__EXTERN__ ret_t RVM_Hyp_Tim_Prog(ptr_t Period);
S__EXTERN__ ret_t RVM_Hyp_Print(void);
S/*****************************************************************************/
S/* Undefine "__EXTERN__" to avoid redefinition */
S#undef __EXTERN__
S/* __PLATFORM_CMX_RVM_MEMBERS__ */
S#endif
S/* !(defined __HDR_DEFS__||defined __HDR_STRUCTS__) */
N#endif
N/* End Public C Function Prototypes ******************************************/
N
N/* End Of File ***************************************************************/
N
N/* Copyright (C) Evo-Devo Instrum. All rights reserved ***********************/
L 11 "..\..\MProkaron\Include\Platform/RMP_platform.h" 2
N/* End Platform Includes *****************************************************/
N
N/* End Of File ***************************************************************/
N
N/* Copyright (C) Evo-Devo Instrum. All rights reserved ***********************/
L 20 "..\..\MProkaron\Kernel\kernel.c" 2
N#include "Kernel/kernel.h"
L 1 "..\..\MProkaron\Include\Kernel/kernel.h" 1
N/******************************************************************************
NFilename    : kernel.h
NAuthor      : pry
NDate        : 01/04/2017
NLicence     : LGPL v3+; see COPYING for details.
NDescription : The header file for the kernel.
N******************************************************************************/
N
N/* Defines *******************************************************************/
N#ifdef __HDR_DEFS__
S#ifndef __KERNEL_H_DEFS__
S#define __KERNEL_H_DEFS__
S/*****************************************************************************/
S/* Constants */
S#define RMP_TRUE               1
S#define RMP_FALSE              0
S/* States of threads */
S#define RMP_THD_STATE(X)       ((X)&0xFF)
S#define RMP_THD_FLAG(X)        ((X)&~0xFF)
S#define RMP_THD_STATE_SET(X,S) ((X)=(RMP_THD_FLAG(X)|(S)))
S
S/* This thread is currently unused */
S#define RMP_THD_FREE           (0)
S/* This thread is currently running */
S#define RMP_THD_RUNNING        (1)
S/* Blocked on a send endpoint */
S#define RMP_THD_SNDBLK         (2)
S/* Blocked on a send endpoint with a timeout */
S#define RMP_THD_SNDDLY         (3)
S/* Blocked on its own receive endpoint */
S#define RMP_THD_RCVBLK         (4)
S/* Blocked on its own receive endpoint with a timeout */
S#define RMP_THD_RCVDLY         (5)
S/* Just on the timer delay */
S#define RMP_THD_DELAYED        (6)
S/* Blocked on a semaphore */
S#define RMP_THD_SEMBLK         (7)
S/* Blocked on a semaphore with a timeout */
S#define RMP_THD_SEMDLY         (8)
S/* Suspended */
S#define RMP_THD_SUSPENDED      (1<<8)
S/* Mailbox valid */
S#define RMP_THD_MBOXFUL        (RMP_THD_SUSPENDED<<1)
S    
S/* States of semaphores */
S#define RMP_SEM_FREE           (0)
S#define RMP_SEM_USED           (1)
S
S/* Error codes */
S/* This error is thread related */
S#define RMP_ERR_THD            (-1)
S/* This error is priority related */
S#define RMP_ERR_PRIO           (-2)
S/* This error is timeslice related */
S#define RMP_ERR_SLICE          (-3)
S/* This error is thread state related */
S#define RMP_ERR_STATE          (-4)
S/* This error is operation related */
S#define RMP_ERR_OPER           (-5)
S/* This error is semaphore related */
S#define RMP_ERR_SEM            (-6)
S
S/* Word sizes settings */
S#define RMP_WORD_SIZE          (((ptr_t)1)<<RMP_WORD_ORDER)
S#define RMP_WORD_MASK          (~(((ptr_t)(-1))<<(RMP_WORD_ORDER-1)))
S#define RMP_BITMAP_SIZE        ((RMP_MAX_PREEMPT_PRIO-1)/RMP_WORD_SIZE+1)
S#define RMP_ALLBITS            ((ptr_t)(-1))
S
S/* Stack offset macros */
S/* Head offset, for ascending stacks */
S#define RMP_INIT_STACK_HEAD(X)   (((ptr_t)RMP_Init_Stack)+(X)*sizeof(ptr_t))
S/* Tail offset, for descending stacks */
S#define RMP_INIT_STACK_TAIL(X)   (((ptr_t)RMP_Init_Stack)+RMP_INIT_STACK_SIZE-(X)*sizeof(ptr_t))
S
S/* Get the thread from delay list */
S#define RMP_DLY2THD(X)         ((struct RMP_Thd*)(((ptr_t)(X))-sizeof(struct RMP_List)))
S
S/* Printk macros */
S#define RMP_PRINTK_I(INT)      RMP_Print_Int((INT))
S#define RMP_PRINTK_U(UINT)     RMP_Print_Uint((UINT))
S#define RMP_PRINTK_S(STR)      RMP_Print_String((s8*)(STR))
S    
S/* Assert macro */
S#define RMP_ASSERT(X) \
Sdo \
S{ \
S    if((X)==0) \
S    { \
S        RMP_PRINTK_S("\r\n***\r\nKernel panic - not syncing:\r\n"); \
S        RMP_PRINTK_S(__FILE__); \
S        RMP_PRINTK_S(" , Line "); \
S        RMP_PRINTK_I(__LINE__); \
S        RMP_PRINTK_S("\r\n"); \
S        RMP_PRINTK_S(__DATE__); \
S        RMP_PRINTK_S(" , "); \
S        RMP_PRINTK_S(__TIME__); \
S        RMP_PRINTK_S("\r\n"); \
S        while(1); \
S    } \
S} \
Swhile(0)
X#define RMP_ASSERT(X) do {     if((X)==0)     {         RMP_PRINTK_S("\r\n***\r\nKernel panic - not syncing:\r\n");         RMP_PRINTK_S(__FILE__);         RMP_PRINTK_S(" , Line ");         RMP_PRINTK_I(__LINE__);         RMP_PRINTK_S("\r\n");         RMP_PRINTK_S(__DATE__);         RMP_PRINTK_S(" , ");         RMP_PRINTK_S(__TIME__);         RMP_PRINTK_S("\r\n");         while(1);     } } while(0)
S/*****************************************************************************/
S/* __KERNEL_H_DEFS__ */
S#endif
S/* __HDR_DEFS__ */
N#endif
N/* End Defines ***************************************************************/
N
N/* Structs *******************************************************************/
N#ifdef __HDR_STRUCTS__
N#ifndef __KERNEL_H_STRUCTS__
N#define __KERNEL_H_STRUCTS__
N/* We used structs in the header */
N
N/* Use defines in these headers */
N#define __HDR_DEFS__
N#undef __HDR_DEFS__
N/*****************************************************************************/
N/* The list head structure */
Nstruct RMP_List
N{
N    volatile struct RMP_List* Prev;
N    volatile struct RMP_List* Next;
N};
N
Nstruct RMP_Thd
N{
N    /* The head to insert into the status queue */
N    struct RMP_List Run_Head;
N    /* This is exclusively for the timer queue */
N    struct RMP_List Dly_Head;
N    /* The list of threads suspended on it because of sending */
N    struct RMP_List Snd_List;
N    /* The state of this thread */
N    ptr_t State;
N    /* If it is running, how many timeslices it have */
N    ptr_t Slices;
N    /* If it is running, how many ticks does it have remaining */
N    ptr_t Slices_Left;
N    /* What priority it is running at */
N    ptr_t Prio;
N    /* The timeout time */
N    ptr_t Timeout;
N    /* The mailbox value */
N    ptr_t Mailbox;
N    /* The data to send */  
N    ptr_t Data;
N    /* The stack address */
N    ptr_t Stack;
N    /* The return value of certain function calls */
N    ret_t Retval;
N};
N
N/* The semaphore structure */
Nstruct RMP_Sem
N{
N    /* The waiting queue */
N    struct RMP_List Wait_List;
N    /* The state of the semaphore */
N    ptr_t State;
N    /* The current number of semaphore */
N    ptr_t Cur_Num;
N};
N/*****************************************************************************/
N/* __KERNEL_H_STRUCTS__ */
N#endif
N/* __HDR_STRUCTS__ */
N#endif
N/* End Structs ***************************************************************/
N
N/* Private Global Variables **************************************************/
N#if(!(defined __HDR_DEFS__||defined __HDR_STRUCTS__))
X#if(!(0L||1L))
S#ifndef __KERNEL_MEMBERS__
S#define __KERNEL_MEMBERS__
S
S/* In this way we can use the data structures and definitions in the headers */
S#define __HDR_DEFS__
S
S#undef __HDR_DEFS__
S
S#define __HDR_STRUCTS__
S
S#undef __HDR_STRUCTS__
S
S/* If the header is not used in the public mode */
S#ifndef __HDR_PUBLIC_MEMBERS__
S/*****************************************************************************/
S/* The scheduler bitmap */
Sstatic ptr_t RMP_Bitmap[RMP_BITMAP_SIZE];
Sstatic struct RMP_List RMP_Run[RMP_MAX_PREEMPT_PRIO];
Sstatic struct RMP_List RMP_Delay;
S
S/* The timestamp value */
Sstatic ptr_t RMP_Tick;
S/* Scheduler lock */
Sstatic ptr_t RMP_Sched_Lock_Cnt;
Sstatic ptr_t RMP_Sched_Locked;
S/* Scheduler pending */
Sstatic ptr_t RMP_Sched_Pend;
S/* Timer events pending */
Sstatic ptr_t RMP_Timer_Pend;
S
S/* Init thread */
Sstatic ptr_t RMP_Init_Stack[RMP_INIT_STACK_SIZE>>(RMP_WORD_ORDER-3)];
Sstatic struct RMP_Thd RMP_Init_Thd;
S/*****************************************************************************/
S/* End Private Global Variables **********************************************/
S
S/* Private C Function Prototypes *********************************************/ 
S/*****************************************************************************/
Sstatic void _RMP_Set_Rdy(struct RMP_Thd* Thread);
Sstatic void _RMP_Clr_Rdy(struct RMP_Thd* Thread);
Sstatic void _RMP_Dly_Ins(struct RMP_Thd* Thread, ptr_t Slices);
Sstatic void _RMP_Timer_Proc(void);
S/*****************************************************************************/
S#define __EXTERN__
S/* End Private C Function Prototypes *****************************************/
S
S/* Public Global Variables ***************************************************/
S/* __HDR_PUBLIC_MEMBERS__ */
S#else
S#define __EXTERN__ EXTERN 
S/* __HDR_PUBLIC_MEMBERS__ */
S#endif
S
S/*****************************************************************************/
S
S
S/* The current thread */
S__EXTERN__ struct RMP_Thd* RMP_Cur_Thd;
S__EXTERN__ ptr_t RMP_Cur_SP;
S/*****************************************************************************/
S
S/* End Public Global Variables ***********************************************/
S
S/* Public C Function Prototypes **********************************************/
S/*****************************************************************************/
S/* This is the entry of user applications */
SEXTERN void RMP_Init(void);
S__EXTERN__ void _RMP_Get_High_Rdy(void);
S__EXTERN__ void _RMP_Tick_Handler(ptr_t Ticks);
S__EXTERN__ ptr_t _RMP_Get_Near_Ticks(void);
S__EXTERN__ void RMP_Clear(void* Addr, ptr_t Size);
S
S/* Scheduler locking & unlocking */
S__EXTERN__ void RMP_Lock_Sched(void);
S__EXTERN__ void RMP_Unlock_Sched(void);
S
S/* Debug printing functions */
S__EXTERN__ cnt_t RMP_Print_Int(cnt_t Int);
S__EXTERN__ cnt_t RMP_Print_Uint(ptr_t Uint);
S__EXTERN__ cnt_t RMP_Print_String(s8* String);
S
S/* List operation functions */
S__EXTERN__ void RMP_List_Crt(volatile struct RMP_List* Head);
S__EXTERN__ void RMP_List_Del(volatile struct RMP_List* Prev,volatile struct RMP_List* Next);
S__EXTERN__ void RMP_List_Ins(volatile struct RMP_List* New,
S                             volatile struct RMP_List* Prev,
S                             volatile struct RMP_List* Next);
S
S/* System interfaces */
S__EXTERN__ void RMP_Yield(void);
S__EXTERN__ ret_t RMP_Thd_Crt(struct RMP_Thd* Thread, 
S                             void* Entry, void* Stack, void* Arg, 
S                             ptr_t Prio, ptr_t Slices);
S__EXTERN__ ret_t RMP_Thd_Del(struct RMP_Thd* Thread);
S__EXTERN__ ret_t RMP_Thd_Set(struct RMP_Thd* Thread, ptr_t Prio, ptr_t Slices);
S__EXTERN__ ret_t RMP_Thd_Suspend(struct RMP_Thd* Thread);
S__EXTERN__ ret_t RMP_Thd_Resume(struct RMP_Thd* Thread);
S
S__EXTERN__ ret_t RMP_Thd_Delay(ptr_t Slices);
S__EXTERN__ ret_t RMP_Thd_Cancel(struct RMP_Thd* Thread);
S
S__EXTERN__ ret_t RMP_Thd_Snd(struct RMP_Thd* Thread, ptr_t Data, ptr_t Slices);
S__EXTERN__ ret_t RMP_Thd_Snd_ISR(struct RMP_Thd* Thread, ptr_t Data);
S__EXTERN__ ret_t RMP_Thd_Rcv(ptr_t* Data, ptr_t Slices);
S
S__EXTERN__ ret_t RMP_Sem_Crt(struct RMP_Sem* Semaphore, ptr_t Number);
S__EXTERN__ ret_t RMP_Sem_Del(struct RMP_Sem* Semaphore);
S__EXTERN__ ret_t RMP_Sem_Pend(struct RMP_Sem* Semaphore, ptr_t Slices);
S__EXTERN__ ret_t RMP_Sem_Abort(struct RMP_Thd* Thread);
S__EXTERN__ ret_t RMP_Sem_Post(struct RMP_Sem* Semaphore, ptr_t Number);
S__EXTERN__ ret_t RMP_Sem_Post_ISR(struct RMP_Sem* Semaphore, ptr_t Number);
S
S/* Hook functions */
S#if(RMP_USE_HOOKS==RMP_TRUE)
S    EXTERN void RMP_Start_Hook(void);
S    EXTERN void RMP_Save_Ctx(void);
S    EXTERN void RMP_Load_Ctx(void);
S    EXTERN void RMP_Tick_Hook(ptr_t Ticks);
S#else
S    __EXTERN__ void RMP_Start_Hook(void);
S    __EXTERN__ void RMP_Save_Ctx(void);
S    __EXTERN__ void RMP_Load_Ctx(void);
S    __EXTERN__ void RMP_Tick_Hook(ptr_t Ticks);
S#endif
S
SEXTERN void RMP_Init_Hook(void);
SEXTERN void RMP_Init_Idle(void);
S/*****************************************************************************/
S/* Undefine "__EXTERN__" to avoid redefinition */
S#undef __EXTERN__
S/* __KERNEL_MEMBERS__ */
S#endif
S/* !(defined __HDR_DEFS__||defined __HDR_STRUCTS__) */
N#endif
N/* End Public C Function Prototypes ******************************************/
N
N/* End Of File ***************************************************************/
N
N/* Copyright (C) Evo-Devo Instrum. All rights reserved ***********************/
L 21 "..\..\MProkaron\Kernel\kernel.c" 2
N#undef __HDR_STRUCTS__
N
N/* Private include */
N#include "Kernel/kernel.h"
L 1 "..\..\MProkaron\Include\Kernel/kernel.h" 1
N/******************************************************************************
NFilename    : kernel.h
NAuthor      : pry
NDate        : 01/04/2017
NLicence     : LGPL v3+; see COPYING for details.
NDescription : The header file for the kernel.
N******************************************************************************/
N
N/* Defines *******************************************************************/
N#ifdef __HDR_DEFS__
S#ifndef __KERNEL_H_DEFS__
S#define __KERNEL_H_DEFS__
S/*****************************************************************************/
S/* Constants */
S#define RMP_TRUE               1
S#define RMP_FALSE              0
S/* States of threads */
S#define RMP_THD_STATE(X)       ((X)&0xFF)
S#define RMP_THD_FLAG(X)        ((X)&~0xFF)
S#define RMP_THD_STATE_SET(X,S) ((X)=(RMP_THD_FLAG(X)|(S)))
S
S/* This thread is currently unused */
S#define RMP_THD_FREE           (0)
S/* This thread is currently running */
S#define RMP_THD_RUNNING        (1)
S/* Blocked on a send endpoint */
S#define RMP_THD_SNDBLK         (2)
S/* Blocked on a send endpoint with a timeout */
S#define RMP_THD_SNDDLY         (3)
S/* Blocked on its own receive endpoint */
S#define RMP_THD_RCVBLK         (4)
S/* Blocked on its own receive endpoint with a timeout */
S#define RMP_THD_RCVDLY         (5)
S/* Just on the timer delay */
S#define RMP_THD_DELAYED        (6)
S/* Blocked on a semaphore */
S#define RMP_THD_SEMBLK         (7)
S/* Blocked on a semaphore with a timeout */
S#define RMP_THD_SEMDLY         (8)
S/* Suspended */
S#define RMP_THD_SUSPENDED      (1<<8)
S/* Mailbox valid */
S#define RMP_THD_MBOXFUL        (RMP_THD_SUSPENDED<<1)
S    
S/* States of semaphores */
S#define RMP_SEM_FREE           (0)
S#define RMP_SEM_USED           (1)
S
S/* Error codes */
S/* This error is thread related */
S#define RMP_ERR_THD            (-1)
S/* This error is priority related */
S#define RMP_ERR_PRIO           (-2)
S/* This error is timeslice related */
S#define RMP_ERR_SLICE          (-3)
S/* This error is thread state related */
S#define RMP_ERR_STATE          (-4)
S/* This error is operation related */
S#define RMP_ERR_OPER           (-5)
S/* This error is semaphore related */
S#define RMP_ERR_SEM            (-6)
S
S/* Word sizes settings */
S#define RMP_WORD_SIZE          (((ptr_t)1)<<RMP_WORD_ORDER)
S#define RMP_WORD_MASK          (~(((ptr_t)(-1))<<(RMP_WORD_ORDER-1)))
S#define RMP_BITMAP_SIZE        ((RMP_MAX_PREEMPT_PRIO-1)/RMP_WORD_SIZE+1)
S#define RMP_ALLBITS            ((ptr_t)(-1))
S
S/* Stack offset macros */
S/* Head offset, for ascending stacks */
S#define RMP_INIT_STACK_HEAD(X)   (((ptr_t)RMP_Init_Stack)+(X)*sizeof(ptr_t))
S/* Tail offset, for descending stacks */
S#define RMP_INIT_STACK_TAIL(X)   (((ptr_t)RMP_Init_Stack)+RMP_INIT_STACK_SIZE-(X)*sizeof(ptr_t))
S
S/* Get the thread from delay list */
S#define RMP_DLY2THD(X)         ((struct RMP_Thd*)(((ptr_t)(X))-sizeof(struct RMP_List)))
S
S/* Printk macros */
S#define RMP_PRINTK_I(INT)      RMP_Print_Int((INT))
S#define RMP_PRINTK_U(UINT)     RMP_Print_Uint((UINT))
S#define RMP_PRINTK_S(STR)      RMP_Print_String((s8*)(STR))
S    
S/* Assert macro */
S#define RMP_ASSERT(X) \
Sdo \
S{ \
S    if((X)==0) \
S    { \
S        RMP_PRINTK_S("\r\n***\r\nKernel panic - not syncing:\r\n"); \
S        RMP_PRINTK_S(__FILE__); \
S        RMP_PRINTK_S(" , Line "); \
S        RMP_PRINTK_I(__LINE__); \
S        RMP_PRINTK_S("\r\n"); \
S        RMP_PRINTK_S(__DATE__); \
S        RMP_PRINTK_S(" , "); \
S        RMP_PRINTK_S(__TIME__); \
S        RMP_PRINTK_S("\r\n"); \
S        while(1); \
S    } \
S} \
Swhile(0)
X#define RMP_ASSERT(X) do {     if((X)==0)     {         RMP_PRINTK_S("\r\n***\r\nKernel panic - not syncing:\r\n");         RMP_PRINTK_S(__FILE__);         RMP_PRINTK_S(" , Line ");         RMP_PRINTK_I(__LINE__);         RMP_PRINTK_S("\r\n");         RMP_PRINTK_S(__DATE__);         RMP_PRINTK_S(" , ");         RMP_PRINTK_S(__TIME__);         RMP_PRINTK_S("\r\n");         while(1);     } } while(0)
S/*****************************************************************************/
S/* __KERNEL_H_DEFS__ */
S#endif
S/* __HDR_DEFS__ */
N#endif
N/* End Defines ***************************************************************/
N
N/* Structs *******************************************************************/
N#ifdef __HDR_STRUCTS__
S#ifndef __KERNEL_H_STRUCTS__
S#define __KERNEL_H_STRUCTS__
S/* We used structs in the header */
S
S/* Use defines in these headers */
S#define __HDR_DEFS__
S#undef __HDR_DEFS__
S/*****************************************************************************/
S/* The list head structure */
Sstruct RMP_List
S{
S    volatile struct RMP_List* Prev;
S    volatile struct RMP_List* Next;
S};
S
Sstruct RMP_Thd
S{
S    /* The head to insert into the status queue */
S    struct RMP_List Run_Head;
S    /* This is exclusively for the timer queue */
S    struct RMP_List Dly_Head;
S    /* The list of threads suspended on it because of sending */
S    struct RMP_List Snd_List;
S    /* The state of this thread */
S    ptr_t State;
S    /* If it is running, how many timeslices it have */
S    ptr_t Slices;
S    /* If it is running, how many ticks does it have remaining */
S    ptr_t Slices_Left;
S    /* What priority it is running at */
S    ptr_t Prio;
S    /* The timeout time */
S    ptr_t Timeout;
S    /* The mailbox value */
S    ptr_t Mailbox;
S    /* The data to send */  
S    ptr_t Data;
S    /* The stack address */
S    ptr_t Stack;
S    /* The return value of certain function calls */
S    ret_t Retval;
S};
S
S/* The semaphore structure */
Sstruct RMP_Sem
S{
S    /* The waiting queue */
S    struct RMP_List Wait_List;
S    /* The state of the semaphore */
S    ptr_t State;
S    /* The current number of semaphore */
S    ptr_t Cur_Num;
S};
S/*****************************************************************************/
S/* __KERNEL_H_STRUCTS__ */
S#endif
S/* __HDR_STRUCTS__ */
N#endif
N/* End Structs ***************************************************************/
N
N/* Private Global Variables **************************************************/
N#if(!(defined __HDR_DEFS__||defined __HDR_STRUCTS__))
X#if(!(0L||0L))
N#ifndef __KERNEL_MEMBERS__
N#define __KERNEL_MEMBERS__
N
N/* In this way we can use the data structures and definitions in the headers */
N#define __HDR_DEFS__
N
N#undef __HDR_DEFS__
N
N#define __HDR_STRUCTS__
N
N#undef __HDR_STRUCTS__
N
N/* If the header is not used in the public mode */
N#ifndef __HDR_PUBLIC_MEMBERS__
N/*****************************************************************************/
N/* The scheduler bitmap */
Nstatic ptr_t RMP_Bitmap[RMP_BITMAP_SIZE];
Xstatic ptr_t RMP_Bitmap[((32-1)/(((ptr_t)1)<<5)+1)];
Nstatic struct RMP_List RMP_Run[RMP_MAX_PREEMPT_PRIO];
Xstatic struct RMP_List RMP_Run[32];
Nstatic struct RMP_List RMP_Delay;
N
N/* The timestamp value */
Nstatic ptr_t RMP_Tick;
N/* Scheduler lock */
Nstatic ptr_t RMP_Sched_Lock_Cnt;
Nstatic ptr_t RMP_Sched_Locked;
N/* Scheduler pending */
Nstatic ptr_t RMP_Sched_Pend;
N/* Timer events pending */
Nstatic ptr_t RMP_Timer_Pend;
N
N/* Init thread */
Nstatic ptr_t RMP_Init_Stack[RMP_INIT_STACK_SIZE>>(RMP_WORD_ORDER-3)];
Xstatic ptr_t RMP_Init_Stack[256>>(5-3)];
Nstatic struct RMP_Thd RMP_Init_Thd;
N/*****************************************************************************/
N/* End Private Global Variables **********************************************/
N
N/* Private C Function Prototypes *********************************************/ 
N/*****************************************************************************/
Nstatic void _RMP_Set_Rdy(struct RMP_Thd* Thread);
Nstatic void _RMP_Clr_Rdy(struct RMP_Thd* Thread);
Nstatic void _RMP_Dly_Ins(struct RMP_Thd* Thread, ptr_t Slices);
Nstatic void _RMP_Timer_Proc(void);
N/*****************************************************************************/
N#define __EXTERN__
N/* End Private C Function Prototypes *****************************************/
N
N/* Public Global Variables ***************************************************/
N/* __HDR_PUBLIC_MEMBERS__ */
N#else
S#define __EXTERN__ EXTERN 
S/* __HDR_PUBLIC_MEMBERS__ */
N#endif
N
N/*****************************************************************************/
N
N
N/* The current thread */
N__EXTERN__ struct RMP_Thd* RMP_Cur_Thd;
X struct RMP_Thd* RMP_Cur_Thd;
N__EXTERN__ ptr_t RMP_Cur_SP;
X ptr_t RMP_Cur_SP;
N/*****************************************************************************/
N
N/* End Public Global Variables ***********************************************/
N
N/* Public C Function Prototypes **********************************************/
N/*****************************************************************************/
N/* This is the entry of user applications */
NEXTERN void RMP_Init(void);
Xextern void RMP_Init(void);
N__EXTERN__ void _RMP_Get_High_Rdy(void);
X void _RMP_Get_High_Rdy(void);
N__EXTERN__ void _RMP_Tick_Handler(ptr_t Ticks);
X void _RMP_Tick_Handler(ptr_t Ticks);
N__EXTERN__ ptr_t _RMP_Get_Near_Ticks(void);
X ptr_t _RMP_Get_Near_Ticks(void);
N__EXTERN__ void RMP_Clear(void* Addr, ptr_t Size);
X void RMP_Clear(void* Addr, ptr_t Size);
N
N/* Scheduler locking & unlocking */
N__EXTERN__ void RMP_Lock_Sched(void);
X void RMP_Lock_Sched(void);
N__EXTERN__ void RMP_Unlock_Sched(void);
X void RMP_Unlock_Sched(void);
N
N/* Debug printing functions */
N__EXTERN__ cnt_t RMP_Print_Int(cnt_t Int);
X cnt_t RMP_Print_Int(cnt_t Int);
N__EXTERN__ cnt_t RMP_Print_Uint(ptr_t Uint);
X cnt_t RMP_Print_Uint(ptr_t Uint);
N__EXTERN__ cnt_t RMP_Print_String(s8* String);
X cnt_t RMP_Print_String(s8* String);
N
N/* List operation functions */
N__EXTERN__ void RMP_List_Crt(volatile struct RMP_List* Head);
X void RMP_List_Crt(volatile struct RMP_List* Head);
N__EXTERN__ void RMP_List_Del(volatile struct RMP_List* Prev,volatile struct RMP_List* Next);
X void RMP_List_Del(volatile struct RMP_List* Prev,volatile struct RMP_List* Next);
N__EXTERN__ void RMP_List_Ins(volatile struct RMP_List* New,
X void RMP_List_Ins(volatile struct RMP_List* New,
N                             volatile struct RMP_List* Prev,
N                             volatile struct RMP_List* Next);
N
N/* System interfaces */
N__EXTERN__ void RMP_Yield(void);
X void RMP_Yield(void);
N__EXTERN__ ret_t RMP_Thd_Crt(struct RMP_Thd* Thread, 
X ret_t RMP_Thd_Crt(struct RMP_Thd* Thread, 
N                             void* Entry, void* Stack, void* Arg, 
N                             ptr_t Prio, ptr_t Slices);
N__EXTERN__ ret_t RMP_Thd_Del(struct RMP_Thd* Thread);
X ret_t RMP_Thd_Del(struct RMP_Thd* Thread);
N__EXTERN__ ret_t RMP_Thd_Set(struct RMP_Thd* Thread, ptr_t Prio, ptr_t Slices);
X ret_t RMP_Thd_Set(struct RMP_Thd* Thread, ptr_t Prio, ptr_t Slices);
N__EXTERN__ ret_t RMP_Thd_Suspend(struct RMP_Thd* Thread);
X ret_t RMP_Thd_Suspend(struct RMP_Thd* Thread);
N__EXTERN__ ret_t RMP_Thd_Resume(struct RMP_Thd* Thread);
X ret_t RMP_Thd_Resume(struct RMP_Thd* Thread);
N
N__EXTERN__ ret_t RMP_Thd_Delay(ptr_t Slices);
X ret_t RMP_Thd_Delay(ptr_t Slices);
N__EXTERN__ ret_t RMP_Thd_Cancel(struct RMP_Thd* Thread);
X ret_t RMP_Thd_Cancel(struct RMP_Thd* Thread);
N
N__EXTERN__ ret_t RMP_Thd_Snd(struct RMP_Thd* Thread, ptr_t Data, ptr_t Slices);
X ret_t RMP_Thd_Snd(struct RMP_Thd* Thread, ptr_t Data, ptr_t Slices);
N__EXTERN__ ret_t RMP_Thd_Snd_ISR(struct RMP_Thd* Thread, ptr_t Data);
X ret_t RMP_Thd_Snd_ISR(struct RMP_Thd* Thread, ptr_t Data);
N__EXTERN__ ret_t RMP_Thd_Rcv(ptr_t* Data, ptr_t Slices);
X ret_t RMP_Thd_Rcv(ptr_t* Data, ptr_t Slices);
N
N__EXTERN__ ret_t RMP_Sem_Crt(struct RMP_Sem* Semaphore, ptr_t Number);
X ret_t RMP_Sem_Crt(struct RMP_Sem* Semaphore, ptr_t Number);
N__EXTERN__ ret_t RMP_Sem_Del(struct RMP_Sem* Semaphore);
X ret_t RMP_Sem_Del(struct RMP_Sem* Semaphore);
N__EXTERN__ ret_t RMP_Sem_Pend(struct RMP_Sem* Semaphore, ptr_t Slices);
X ret_t RMP_Sem_Pend(struct RMP_Sem* Semaphore, ptr_t Slices);
N__EXTERN__ ret_t RMP_Sem_Abort(struct RMP_Thd* Thread);
X ret_t RMP_Sem_Abort(struct RMP_Thd* Thread);
N__EXTERN__ ret_t RMP_Sem_Post(struct RMP_Sem* Semaphore, ptr_t Number);
X ret_t RMP_Sem_Post(struct RMP_Sem* Semaphore, ptr_t Number);
N__EXTERN__ ret_t RMP_Sem_Post_ISR(struct RMP_Sem* Semaphore, ptr_t Number);
X ret_t RMP_Sem_Post_ISR(struct RMP_Sem* Semaphore, ptr_t Number);
N
N/* Hook functions */
N#if(RMP_USE_HOOKS==RMP_TRUE)
X#if(0==1)
S    EXTERN void RMP_Start_Hook(void);
S    EXTERN void RMP_Save_Ctx(void);
S    EXTERN void RMP_Load_Ctx(void);
S    EXTERN void RMP_Tick_Hook(ptr_t Ticks);
N#else
N    __EXTERN__ void RMP_Start_Hook(void);
X     void RMP_Start_Hook(void);
N    __EXTERN__ void RMP_Save_Ctx(void);
X     void RMP_Save_Ctx(void);
N    __EXTERN__ void RMP_Load_Ctx(void);
X     void RMP_Load_Ctx(void);
N    __EXTERN__ void RMP_Tick_Hook(ptr_t Ticks);
X     void RMP_Tick_Hook(ptr_t Ticks);
N#endif
N
NEXTERN void RMP_Init_Hook(void);
Xextern void RMP_Init_Hook(void);
NEXTERN void RMP_Init_Idle(void);
Xextern void RMP_Init_Idle(void);
N/*****************************************************************************/
N/* Undefine "__EXTERN__" to avoid redefinition */
N#undef __EXTERN__
N/* __KERNEL_MEMBERS__ */
N#endif
N/* !(defined __HDR_DEFS__||defined __HDR_STRUCTS__) */
N#endif
N/* End Public C Function Prototypes ******************************************/
N
N/* End Of File ***************************************************************/
N
N/* Copyright (C) Evo-Devo Instrum. All rights reserved ***********************/
L 25 "..\..\MProkaron\Kernel\kernel.c" 2
N
N#define __HDR_PUBLIC_MEMBERS__
N#include "Platform/RMP_platform.h"
L 1 "..\..\MProkaron\Include\Platform/RMP_platform.h" 1
N/******************************************************************************
NFilename    : RMP_platform.h
NAuthor      : pry 
NDate        : 22/07/2017
NLicence     : LGPL v3+; see COPYING for details.
NDescription : The platform specific types for RMP.
N******************************************************************************/
N
N/* Platform Includes *********************************************************/
N#include "Platform/CortexM_RVM/platform_cmx_RVM.h"
L 1 "..\..\MProkaron\Include\Platform/CortexM_RVM/platform_cmx_RVM.h" 1
N/******************************************************************************
NFilename    : platform_cmx_RVM.h
NAuthor      : pry
NDate        : 01/04/2017
NLicence     : LGPL v3+; see COPYING for details.
NDescription : The header of platform-specific part of RMP for RVM.
N******************************************************************************/
N
N/* Defines *******************************************************************/
N#ifdef __HDR_DEFS__
S#ifndef __PLATFORM_CMX_RVM_H_DEFS__
S#define __PLATFORM_CMX_RVM_H_DEFS__
S/*****************************************************************************/
S/* Basic Types ***************************************************************/
S#if(DEFINE_BASIC_TYPES==TRUE)
S
S#ifndef __S32__
S#define __S32__
Stypedef signed int  s32;
S#endif
S
S#ifndef __S16__
S#define __S16__
Stypedef signed short s16;
S#endif
S
S#ifndef __S8__
S#define __S8__
Stypedef signed char  s8;
S#endif
S
S#ifndef __U32__
S#define __U32__
Stypedef unsigned int  u32;
S#endif
S
S#ifndef __U16__
S#define __U16__
Stypedef unsigned short u16;
S#endif
S
S#ifndef __U8__
S#define __U8__
Stypedef unsigned char  u8;
S#endif
S
S#endif
S/* End Basic Types ***********************************************************/
S
S/* Begin Extended Types ******************************************************/
S#ifndef __TID_T__
S#define __TID_T__
S/* The typedef for the Thread ID */
Stypedef s32 tid_t;
S#endif
S
S#ifndef __PTR_T__
S#define __PTR_T__
S/* The typedef for the pointers - This is the raw style. Pointers must be unsigned */
Stypedef u32 ptr_t;
S#endif
S
S#ifndef __CNT_T__
S#define __CNT_T__
S/* The typedef for the count variables */
Stypedef s32 cnt_t;
S#endif
S
S#ifndef __CID_T__
S#define __CID_T__
S/* The typedef for capability ID */
Stypedef s32 cid_t;
S#endif
S
S#ifndef __RET_T__
S#define __RET_T__
S/* The type for process return value */
Stypedef s32 ret_t;
S#endif
S/* End Extended Types ********************************************************/
S
S/* System macros *************************************************************/
S/* Compiler "extern" keyword setting */
S#define EXTERN                   extern
S/* The order of bits in one CPU machine word */
S#define RMP_WORD_ORDER           5
S/* The maximum length of char printing - no need to change this in most cases */
S#define RMP_KERNEL_DEBUG_MAX_STR 128
S/* The offset of the stack when initializing */
S#define RMP_INIT_STACK           RMP_INIT_STACK_TAIL(17)
S
S/* The CPU and application specific macros are here */
S#include "platform_cmx_RVM_conf.h"
S/* End System macros *********************************************************/
S
S/* Hypervisor macros *********************************************************/
S#define RVM_MAGIC                0x56495254
S#define RVM_VECT_BITMAP          ((RVM_MAX_INTVECT-1)/RMP_WORD_SIZE+1)
S
S/* Hypercalls */
S/* Enable interrupts */
S#define RVM_HYP_ENAINT           0
S/* Disable interrupts */
S#define RVM_HYP_DISINT           1
S/* Register a vector */
S#define RVM_HYP_REGEVT           2
S/* Delete a vector */
S#define RVM_HYP_DELEVT           3
S/* Wait for an interrupt to come */
S#define RVM_HYP_WAITEVT          4
S/* Trigger a vector */
S#define RVM_HYP_SENDEVT          5
S/* Returning from a vector */
S#define RVM_HYP_QUERYEVT         6
S/* Query the VM's ID given its name */
S#define RVM_HYP_QUERY            7
S/* Send to another VM */
S#define RVM_HYP_TIMPROG          8
S/* Print to the console */
S#define RVM_HYP_PRINT            9
S
S/* System stack size when entering the system - do not need to be changed in most cases */
S#define RMP_INT_STACK_ADDR           (((ptr_t)&__initial_sp)+0x400-64*sizeof(ptr_t))
S    
S/* Generic page table flags */
S#define RME_PGTBL_ORDER(SIZE,NUM)    (((SIZE)<<(sizeof(ptr_t)*4))|(NUM))
S#define RME_PGTBL_READ               (1<<0)
S#define RME_PGTBL_WRITE              (1<<1)
S#define RME_PGTBL_EXECUTE            (1<<2)
S#define RME_PGTBL_CACHEABLE          (1<<3)
S#define RME_PGTBL_BUFFERABLE         (1<<4)
S#define RME_PGTBL_STATIC             (1<<5)
S
S#define RME_PGTBL_ALL_PERM           (RME_PGTBL_READ|RME_PGTBL_WRITE|RME_PGTBL_EXECUTE| \
S                                      RME_PGTBL_CACHEABLE|RME_PGTBL_BUFFERABLE|RME_PGTBL_STATIC)
X#define RME_PGTBL_ALL_PERM           (RME_PGTBL_READ|RME_PGTBL_WRITE|RME_PGTBL_EXECUTE|                                       RME_PGTBL_CACHEABLE|RME_PGTBL_BUFFERABLE|RME_PGTBL_STATIC)
S                                        
S/* Generic page size order definitions */
S#define RME_PGTBL_SIZE_2B            (1)
S#define RME_PGTBL_SIZE_4B            (2)
S#define RME_PGTBL_SIZE_8B            (3)
S#define RME_PGTBL_SIZE_16B           (4)
S#define RME_PGTBL_SIZE_32B           (5)
S#define RME_PGTBL_SIZE_64B           (6)
S#define RME_PGTBL_SIZE_128B          (7)
S#define RME_PGTBL_SIZE_256B          (8)
S#define RME_PGTBL_SIZE_512B          (9)
S#define RME_PGTBL_SIZE_1K            (10)
S#define RME_PGTBL_SIZE_2K            (11)
S#define RME_PGTBL_SIZE_4K            (12)
S#define RME_PGTBL_SIZE_8K            (13)
S#define RME_PGTBL_SIZE_16K           (14)
S#define RME_PGTBL_SIZE_32K           (15)
S#define RME_PGTBL_SIZE_64K           (16)
S#define RME_PGTBL_SIZE_128K          (17)
S#define RME_PGTBL_SIZE_256K          (18)
S#define RME_PGTBL_SIZE_512K          (19)
S#define RME_PGTBL_SIZE_1M            (20)
S#define RME_PGTBL_SIZE_2M            (21)
S#define RME_PGTBL_SIZE_4M            (22)
S#define RME_PGTBL_SIZE_8M            (23)
S#define RME_PGTBL_SIZE_16M           (24)
S#define RME_PGTBL_SIZE_32M           (25)
S#define RME_PGTBL_SIZE_64M           (26)
S#define RME_PGTBL_SIZE_128M          (27)
S#define RME_PGTBL_SIZE_256M          (28)
S#define RME_PGTBL_SIZE_512M          (29)
S#define RME_PGTBL_SIZE_1G            (30)
S#define RME_PGTBL_SIZE_2G            (31)
S#define RME_PGTBL_SIZE_4G            (32)
S
S/* Generic page table entry number definitions */
S#define RME_PGTBL_NUM_2             (1)
S#define RME_PGTBL_NUM_4             (2)
S#define RME_PGTBL_NUM_8             (3)
S#define RME_PGTBL_NUM_16            (4)
S#define RME_PGTBL_NUM_32            (5)
S#define RME_PGTBL_NUM_64            (6)
S#define RME_PGTBL_NUM_128           (7)
S#define RME_PGTBL_NUM_256           (8)
S#define RME_PGTBL_NUM_512           (9)
S#define RME_PGTBL_NUM_1K            (10)
S#define RME_PGTBL_NUM_2K            (11)
S#define RME_PGTBL_NUM_4K            (12)
S#define RME_PGTBL_NUM_8K            (13)
S#define RME_PGTBL_NUM_16K           (14)
S#define RME_PGTBL_NUM_32K           (15)
S#define RME_PGTBL_NUM_64K           (16)
S#define RME_PGTBL_NUM_128K          (17)
S#define RME_PGTBL_NUM_256K          (18)
S#define RME_PGTBL_NUM_512K          (19)
S#define RME_PGTBL_NUM_1M            (20)
S#define RME_PGTBL_NUM_2M            (21)
S#define RME_PGTBL_NUM_4M            (22)
S/* End Hypervisor macros *****************************************************/
S/*****************************************************************************/
S/* __PLATFORM_CMX_RVM_H_DEFS__ */
S#endif
S/* __HDR_DEFS__ */
N#endif
N/* End Defines ***************************************************************/
N
N/* Structs *******************************************************************/
N#ifdef __HDR_STRUCTS__
S#ifndef __PLATFORM_CMX_RVM_H_STRUCTS__
S#define __PLATFORM_CMX_RVM_H_STRUCTS__
S
Sstruct RVM_Reg_Struct
S{
S    ptr_t SP;
S    ptr_t R4;
S    ptr_t R5;
S    ptr_t R6;
S    ptr_t R7;
S    ptr_t R8;
S    ptr_t R9;
S    ptr_t R10;
S    ptr_t R11;
S    ptr_t LR;
S};
S
S/* The coprocessor register set structure. In Cortex-M, if there is a 
S * single-precision FPU, then the FPU S0-S15 is automatically pushed */
Sstruct RVM_Cop_Struct
S{
S    ptr_t S16;
S    ptr_t S17;
S    ptr_t S18;
S    ptr_t S19;
S    ptr_t S20;
S    ptr_t S21;
S    ptr_t S22;
S    ptr_t S23;
S    ptr_t S24;
S    ptr_t S25;
S    ptr_t S26;
S    ptr_t S27;
S    ptr_t S28;
S    ptr_t S29;
S    ptr_t S30;
S    ptr_t S31;
S};
S
Sstruct RVM_Regs
S{
S    struct RVM_Reg_Struct Reg;
S    struct RVM_Cop_Struct Cop_Reg;
S};
S
S/* We used structs in the header */
Sstruct RVM_Param
S{
S    ptr_t Number;
S    ptr_t Param[4];
S};
S
S/* The page table layout is statically decided, the first one being the top-level */
Sstruct RVM_Hdr_Pgtbl
S{
S    /* Its parent's position */
S    ptr_t Parent;
S    /* The start address of the mapping */
S    ptr_t Addr;
S    /* The size order and number order, combined into one word */
S    ptr_t Order;
S    /* The initially mapped pages' data. The only thing stored here
S     * is the RVM standard flags */
S    u8 Flags[8];
S};
S
Sstruct RVM_Int_Flag
S{
S    ptr_t Flags[RVM_VECT_BITMAP];
S};
S
S/* The image structure */
Sstruct RVM_Image
S{
S    /* The magic number;always equal to VIRT(0x56495254) */
S    const ptr_t Magic;
S    /* The name is always 16 bytes long. This is fixed and is not changeable */
S    s8 Name[16];
S
S    /* The entry, stack and stack size of the virtual machines */
S    void* User_Entry;
S    void* User_Stack;
S    ptr_t User_Size;
S    void* Int_Entry;
S    void* Int_Stack;
S    ptr_t Int_Size;
S    
S    /* The parameter space, register set space and interrupt flag space */
S    struct RVM_Param* Param;
S    struct RVM_Regs* Regs;
S    struct RVM_Int_Flag* Int_Flags;
S    
S    /* The console space and size */
S    void* Console_Buf;
S    ptr_t Console_Size;
S    
S    /* The priority and timeslices */
S    ptr_t Prio;
S    ptr_t Slices;
S
S    /* The number of page tables in this image, and where are they stored */
S    ptr_t Pgtbl_Num;
S    const struct RVM_Hdr_Pgtbl* Pgtbl;
S
S    /* Is there any other images? If there is, here is a pointer to the start
S     * of the next one. This is a constant pointer to a constant pointer to a 
S     * constant structure */
S    const struct RVM_Image* const * const Next_Image;
S};
S
S/* Use defines in these headers */
S#define __HDR_DEFS__
S#undef __HDR_DEFS__
S/*****************************************************************************/
S
S/*****************************************************************************/
S/* __PLATFORM_CMX_RVM_H_STRUCTS__ */
S#endif
S/* __HDR_STRUCTS__ */
N#endif
N/* End Structs ***************************************************************/
N
N/* Private Global Variables **************************************************/
N#if(!(defined __HDR_DEFS__||defined __HDR_STRUCTS__))
X#if(!(0L||0L))
N#ifndef __PLATFORM_CMX_RVM_MEMBERS__
N#define __PLATFORM_CMX_RVM_MEMBERS__
N
N/* In this way we can use the data structures and definitions in the headers */
N#define __HDR_DEFS__
N
N#undef __HDR_DEFS__
N
N#define __HDR_STRUCTS__
N
N#undef __HDR_STRUCTS__
N
N/* If the header is not used in the public mode */
N#ifndef __HDR_PUBLIC_MEMBERS__
S/*****************************************************************************/
S
S/*****************************************************************************/
S/* End Private Global Variables **********************************************/
S
S/* Private C Function Prototypes *********************************************/ 
S/*****************************************************************************/
Sstatic ret_t RMP_Hypercall(ptr_t Number, ptr_t Param1, ptr_t Param2, ptr_t Param3, ptr_t Param4);
Sstatic ret_t _RMP_Get_Int(void);
S
S/* Interrupts */
Sstatic void RMP_PendSV_Handler(void);
Sstatic void RMP_SysTick_Handler(void);
S/*****************************************************************************/
S#define __EXTERN__
S/* End Private C Function Prototypes *****************************************/
S
S/* Public Global Variables ***************************************************/
S/* __HDR_PUBLIC_MEMBERS__ */
N#else
N#define __EXTERN__ EXTERN 
N/* __HDR_PUBLIC_MEMBERS__ */
N#endif
N
N/*****************************************************************************/
N/* The debug console buffer and pointer */
N__EXTERN__ s8 RMP_Console[RMP_KERNEL_DEBUG_MAX_STR];
Xextern s8 RMP_Console[128];
N__EXTERN__ ptr_t RMP_Console_Ptr;
Xextern ptr_t RMP_Console_Ptr;
N
N/* The initial stack pointer as defined in assembly */
NEXTERN ptr_t RMP_User_Stack;
Xextern ptr_t RMP_User_Stack;
NEXTERN ptr_t __initial_sp;
Xextern ptr_t __initial_sp;
NEXTERN ptr_t RMP_Int_Stack;
Xextern ptr_t RMP_Int_Stack;
N/* The hypercall parameter& structure */
N__EXTERN__ struct RVM_Param RMP_Param;
Xextern struct RVM_Param RMP_Param;
N__EXTERN__ struct RVM_Regs RMP_Regs;
Xextern struct RVM_Regs RMP_Regs;
N/* Just map everything into it */
NEXTERN const struct RVM_Hdr_Pgtbl RMP_Pgtbl[1];
Xextern const struct RVM_Hdr_Pgtbl RMP_Pgtbl[1];
NEXTERN const struct RVM_Image RMP_Image;
Xextern const struct RVM_Image RMP_Image;
N
N/* The interrupt flag used by here */
N__EXTERN__ ptr_t RMP_Ctxsw;
Xextern ptr_t RMP_Ctxsw;
N/* The interrupt handler registration table */
N__EXTERN__ ptr_t RMP_Vect[RVM_MAX_INTVECT];
Xextern ptr_t RMP_Vect[32];
N/* The interrupt flag registration table */
N__EXTERN__ struct RVM_Int_Flag RMP_Flag;
Xextern struct RVM_Int_Flag RMP_Flag;
N/*****************************************************************************/
N
N/* End Public Global Variables ***********************************************/
N
N/* Public C Function Prototypes **********************************************/
N/*****************************************************************************/
NEXTERN void RMP_Disable_Int(void);
Xextern void RMP_Disable_Int(void);
NEXTERN void RMP_Enable_Int(void);
Xextern void RMP_Enable_Int(void);
N
NEXTERN ptr_t RMP_MSB_Get(ptr_t Val);
Xextern ptr_t RMP_MSB_Get(ptr_t Val);
NEXTERN ptr_t _RMP_Fetch_And(ptr_t* Ptr, ptr_t Operand);
Xextern ptr_t _RMP_Fetch_And(ptr_t* Ptr, ptr_t Operand);
NEXTERN void _RMP_Start(ptr_t Entry, ptr_t Stack);
Xextern void _RMP_Start(ptr_t Entry, ptr_t Stack);
NEXTERN void _RMP_Yield(void);
Xextern void _RMP_Yield(void);
NEXTERN void _RMP_Int_Rcv(void);
Xextern void _RMP_Int_Rcv(void);
N
N
N/* Initialization */
N__EXTERN__ void _RMP_Stack_Init(ptr_t Entry, ptr_t Stack, ptr_t Arg);
Xextern void _RMP_Stack_Init(ptr_t Entry, ptr_t Stack, ptr_t Arg);
N__EXTERN__ void _RMP_Low_Level_Init(void);
Xextern void _RMP_Low_Level_Init(void);
N__EXTERN__ void RMP_Putchar(char Char);
Xextern void RMP_Putchar(char Char);
N__EXTERN__ void _RMP_Plat_Hook(void);
Xextern void _RMP_Plat_Hook(void);
N
N/* Hypercalls */
NEXTERN void _RMP_Hypercall(void);
Xextern void _RMP_Hypercall(void);
NEXTERN void _RMP_Entry(void);
Xextern void _RMP_Entry(void);
N
N/* Interrupt handler entry */
N__EXTERN__ void _RMP_Int(void);
Xextern void _RMP_Int(void);
N
N__EXTERN__ void RMP_Wait_Int(void);
Xextern void RMP_Wait_Int(void);
N__EXTERN__ ret_t RMP_Hyp_Reg_Evt(ptr_t Int_Num, ptr_t VMID);
Xextern ret_t RMP_Hyp_Reg_Evt(ptr_t Int_Num, ptr_t VMID);
N__EXTERN__ ret_t RMP_Hyp_Del_Evt(cnt_t Evt_ID);
Xextern ret_t RMP_Hyp_Del_Evt(cnt_t Evt_ID);
N__EXTERN__ ret_t RVM_Hyp_Send_Evt(ptr_t Evt_ID);
Xextern ret_t RVM_Hyp_Send_Evt(ptr_t Evt_ID);
N__EXTERN__ ret_t RVM_Hyp_Query_Evt(ptr_t VMID);
Xextern ret_t RVM_Hyp_Query_Evt(ptr_t VMID);
N__EXTERN__ ret_t RVM_Hyp_Query(s8* Name);
Xextern ret_t RVM_Hyp_Query(s8* Name);
N__EXTERN__ ret_t RVM_Hyp_Tim_Prog(ptr_t Period);
Xextern ret_t RVM_Hyp_Tim_Prog(ptr_t Period);
N__EXTERN__ ret_t RVM_Hyp_Print(void);
Xextern ret_t RVM_Hyp_Print(void);
N/*****************************************************************************/
N/* Undefine "__EXTERN__" to avoid redefinition */
N#undef __EXTERN__
N/* __PLATFORM_CMX_RVM_MEMBERS__ */
N#endif
N/* !(defined __HDR_DEFS__||defined __HDR_STRUCTS__) */
N#endif
N/* End Public C Function Prototypes ******************************************/
N
N/* End Of File ***************************************************************/
N
N/* Copyright (C) Evo-Devo Instrum. All rights reserved ***********************/
L 11 "..\..\MProkaron\Include\Platform/RMP_platform.h" 2
N/* End Platform Includes *****************************************************/
N
N/* End Of File ***************************************************************/
N
N/* Copyright (C) Evo-Devo Instrum. All rights reserved ***********************/
L 28 "..\..\MProkaron\Kernel\kernel.c" 2
N#undef __HDR_PUBLIC_MEMBERS__
N/* End Includes **************************************************************/
N
N/* Begin Function:RMP_Clear ***************************************************
NDescription : Memset a memory area to zero.
NInput       : void* Addr - The address to clear.
N              ptr_t Size - The size to clear.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
Nvoid RMP_Clear(void* Addr, ptr_t Size)
N{
N    ptr_t* Word_Inc;
N    u8* Byte_Inc;
N    ptr_t Words;
N    ptr_t Bytes;
N    
N    /* On processors not that fast, copy by word is really important */
N    Word_Inc=(ptr_t*)Addr;
N    for(Words=Size/sizeof(ptr_t);Words>0;Words--)
N    {
N        *Word_Inc=0;
N        Word_Inc++;
N    }
N    
N    /* Get the final bytes */
N    Byte_Inc=(u8*)Word_Inc;
N    for(Bytes=Size%sizeof(ptr_t);Bytes>0;Bytes--)
N    {
N        *Byte_Inc=0;
N        Byte_Inc++;
N    }
N}
N/* End Function:RMP_Clear ****************************************************/
N
N/* Begin Function:RMP_Print_Int ***********************************************
NDescription : Print a signed integer on the debugging console. This integer is
N              printed as decimal with sign.
NInput       : cnt_t Int - The integer to print.
NOutput      : None.
NReturn      : cnt_t - The length of the string printed.
N******************************************************************************/
Ncnt_t RMP_Print_Int(cnt_t Int)
N{
N    ptr_t Iter;
N    cnt_t Count;
N    cnt_t Num;
N    ptr_t Div;
N    
N    /* how many digits are there? */
N    if(Int==0)
N    {
N        RMP_Putchar('0');
N        return 1;
N    }
N    else if(Int<0)
N    {
N        /* How many digits are there? */
N        Count=0;
N        Div=1;
N        Iter=-Int;
N        while(Iter!=0)
N        {
N            Iter/=10;
N            Count++;
N            Div*=10;
N        }
N        Div/=10;
N        
N        RMP_Putchar('-');
N        Iter=-Int;
N        Num=Count+1;
N        
N        while(Count>0)
N        {
N            Count--;
N            RMP_Putchar(Iter/Div+'0');
N            Iter=Iter%Div;
N            Div/=10;
N        }
N    }
N    else
N    {
N        /* How many digits are there? */
N        Count=0;
N        Div=1;
N        Iter=Int;
N        while(Iter!=0)
N        {
N            Iter/=10;
N            Count++;
N            Div*=10;
N        }
N        Div/=10;
N        
N        Iter=Int;
N        Num=Count;
N        
N        while(Count>0)
N        {
N            Count--;
N            RMP_Putchar(Iter/Div+'0');
N            Iter=Iter%Div;
N            Div/=10;
N        }
N    }
N    
N    return Num;
N}
N/* End Function:RMP_Print_Int ************************************************/
N
N/* Begin Function:RMP_Print_Uint **********************************************
NDescription : Print a unsigned integer on the debugging console. This integer is
N              printed as hexadecimal.
NInput       : ptr_t Uint - The unsigned integer to print.
NOutput      : None.
NReturn      : cnt_t - The length of the string printed.
N******************************************************************************/
Ncnt_t RMP_Print_Uint(ptr_t Uint)
N{
N    ptr_t Iter;
N    cnt_t Count;
N    cnt_t Num;
N    
N    /* how many digits are there? */
N    if(Uint==0)
N    {
N        RMP_Putchar('0');
N        return 1;
N    }
N    else
N    {
N        /* Filter out all the zeroes */
N        Count=0;
N        Iter=Uint;
N        while((Iter>>((sizeof(ptr_t)*8)-4))==0)
N        {
N            Iter<<=4;
N            Count++;
N        }
N        /* Count is the number of pts to print */
N        Count=sizeof(ptr_t)*2-Count;
N        Num=Count;
N        while(Count>0)
N        {
N            Count--;
N            Iter=(Uint>>(Count*4))&0x0F;
N            if(Iter<10)
N                RMP_Putchar('0'+Iter);
N            else
N                RMP_Putchar('A'+Iter-10);
N        }
N    }
N    
N    return Num;
N}
N/* End Function:RMP_Print_Uint ***********************************************/
N
N/* Begin Function:RMP_Print_String ********************************************
NDescription : Print a string the kernel console.
N              This is only used for kernel-level debugging.
NInput       : s8* String - The string to print
NOutput      : None.
NReturn      : cnt_t - The length of the string printed, the '\0' is not included.
N******************************************************************************/
Ncnt_t RMP_Print_String(s8* String)
N{
N    cnt_t Count;
N    
N    Count=0;
N    while(Count<RMP_KERNEL_DEBUG_MAX_STR)
X    while(Count<128)
N    {
N        if(String[Count]=='\0')
N            break;
N        
N        RMP_Putchar(String[Count++]);
N    }
N    
N    return Count;
N}
N/* End Function:RMP_Print_String *********************************************/
N
N/* Begin Function:RMP_List_Crt ************************************************
NDescription : Create a doubly linkled list.
NInput       : volatile struct RMP_List* Head - The pointer to the list head.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
Nvoid RMP_List_Crt(volatile struct RMP_List* Head)
N{
N    Head->Prev=(struct RMP_List*)Head;
N    Head->Next=(struct RMP_List*)Head;
N}
N/* End Function:RMP_List_Crt *************************************************/
N
N/* Begin Function:RMP_List_Del ************************************************
NDescription : Delete a node from the doubly-linked list.
NInput       : volatile struct RMP_List* Prev - The prevoius node of the target node.
N              volatile struct RMP_List* Next - The next node of the target node.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
Nvoid RMP_List_Del(volatile struct RMP_List* Prev,volatile struct RMP_List* Next)
N{
N    Next->Prev=(struct RMP_List*)Prev;
N    Prev->Next=(struct RMP_List*)Next;
N}
N/* End Function:RMP_List_Del *************************************************/
N
N/* Begin Function:RMP_List_Ins ************************************************
NDescription : Insert a node to the doubly-linked list.
NInput       : volatile struct RMP_List* New - The new node to insert.
N              volatile struct RMP_List* Prev - The previous node.
N              volatile struct RMP_List* Next - The next node.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
Nvoid RMP_List_Ins(volatile struct RMP_List* New,
N                  volatile struct RMP_List* Prev,
N                  volatile struct RMP_List* Next)
N{
N    Next->Prev=(struct RMP_List*)New;
N    New->Next=(struct RMP_List*)Next;
N    New->Prev=(struct RMP_List*)Prev;
N    Prev->Next=(struct RMP_List*)New;
N}
N/* End Function:RMP_List_Ins *************************************************/
N
N/* Begin Function:RMP_Lock_Sched **********************************************
NDescription : The function locks the scheduler. The locking can be stacked.
NInput       : None.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
Nvoid RMP_Lock_Sched(void)
N{
N    /* Disable first before registering it. If an switch occurs between 
N     * registering and disabling, then register-and-disable will cause fault. */
N    RMP_Sched_Locked=1;
N    RMP_Sched_Lock_Cnt++;
N}
N/* End Function:RMP_Lock_Sched ***********************************************/
N
N/* Begin Function:RMP_Unlock_Sched ********************************************
NDescription : The function unlocks the scheduler. The unlocking can be stacked.
NInput       : None.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
Nvoid RMP_Unlock_Sched(void)
N{
N    if(RMP_Sched_Lock_Cnt==1)
N    {
N        /* Clear the count before enabling */
N        RMP_Sched_Lock_Cnt=0;
N        RMP_Sched_Locked=0;
N        /* Now see if the scheduler scheduling action is pended in the lock-unlock 
N         * period. If yes, perform a schedule now */
N        if(RMP_Sched_Pend!=0)
N        {
N            /* Reset the count and trigger the context switch */
N            RMP_Sched_Pend=0;
N            _RMP_Yield();
N        }
N    }
N    else if(RMP_Sched_Lock_Cnt!=0)
N        RMP_Sched_Lock_Cnt--;
N}
N/* End Function:RMP_Unlock_Sched *********************************************/
N
N/* Begin Function:RMP_Yield ***************************************************
NDescription : Yield to another thread.
NInput       : None.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
Nvoid RMP_Yield(void)
N{
N    if(RMP_Sched_Locked==0)
N    {
N        /* Now see if the scheduler scheduling action is pended in the lock-unlock 
N         * period. If yes, perform a schedule now */
N        _RMP_Yield();
N    }
N    else
N        RMP_Sched_Pend=1;
N}
N/* End Function:RMP_Yield ****************************************************/
N
N/* Begin Function:_RMP_Timer_Proc *********************************************
NDescription : Process RMP timer events.
NInput       : None.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
Nvoid _RMP_Timer_Proc(void)
N{
N    struct RMP_Thd* Thread;
N    
N    /* Process the timer events, if there are any of them */
N    while((&RMP_Delay)!=RMP_Delay.Next)
N    {
N        Thread=RMP_DLY2THD(RMP_Delay.Next);
X        Thread=((struct RMP_Thd*)(((ptr_t)(RMP_Delay . Next))-sizeof(struct RMP_List)));
N        /* If the value is more than this, then it means that the time have
N         * already passed and we have to process this */
N        if((RMP_Tick-Thread->Timeout)>(RMP_ALLBITS>>1))
X        if((RMP_Tick-Thread->Timeout)>(((ptr_t)(-1))>>1))
N            break;
N        
N        /* This thread should be processed */
N        RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
N        switch(RMP_THD_STATE(Thread->State))
X        switch(((Thread->State)&0xFF))
N        {
N            case RMP_THD_SNDDLY:
X            case (3):
N            case RMP_THD_SEMDLY:
X            case (8):
N            {
N                RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
N                Thread->Retval=RMP_ERR_OPER;
X                Thread->Retval=(-5);
N                break;
N            }
N            
N            case RMP_THD_RCVDLY:
X            case (5):
N            {
N                Thread->Retval=RMP_ERR_OPER;
X                Thread->Retval=(-5);
N                break;
N            }
N            
N            case RMP_THD_DELAYED:break;
X            case (6):break;
N            /* Should not get here */
N            default:break;
N        }
N
N        RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
X        ((Thread->State)=(((Thread->State)&~0xFF)|((1))));
N        /* Is it suspended? If yes, we can't directly set it running */
N        if((Thread->State&RMP_THD_SUSPENDED)==0)
X        if((Thread->State&(1<<8))==0)
N        {
N            /* Insert this into the corresponding runqueue */
N            RMP_List_Ins(&(Thread->Run_Head),RMP_Run[Thread->Prio].Prev,&(RMP_Run[Thread->Prio]));
N            /* Set this runlevel as active */
N            RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]|=1<<(Thread->Prio&RMP_WORD_MASK);
X            RMP_Bitmap[Thread->Prio>>5]|=1<<(Thread->Prio&(~(((ptr_t)(-1))<<(5-1))));
N            /* See if we need to pend a scheduling event */
N            if(Thread->Prio>RMP_Cur_Thd->Prio)
N                RMP_Sched_Pend=1;
N        }
N    }
N}
N/* Begin Function:_RMP_Timer_Proc ********************************************/
N
N/* Begin Function:_RMP_Get_High_Rdy *******************************************
NDescription : Get the highest priority ready thread. The return value will be written
N              into the global variables.
NInput       : None.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
Nvoid _RMP_Get_High_Rdy(void)
N{
N    cnt_t Count;
N    
N    /* Write the SP value to thread structure */
N    RMP_Cur_Thd->Stack=RMP_Cur_SP;
N    
N    /* Is the scheduler locked on other threads? If yes, we return without doing anything */
N    if(RMP_Sched_Locked!=0)
N        return;
N    
N    if(RMP_Timer_Pend==1)
N    {
N        RMP_Timer_Pend=0;
N        _RMP_Timer_Proc();
N    }
N    
N    RMP_Sched_Pend=0;
N    /* See which one is ready, and pick it */
N    for(Count=RMP_BITMAP_SIZE-1;Count>=0;Count--)
X    for(Count=((32-1)/(((ptr_t)1)<<5)+1)-1;Count>=0;Count--)
N    {
N        if(RMP_Bitmap[Count]==0)
N            continue;
N        
N        Count=RMP_MSB_Get(RMP_Bitmap[Count])+(Count<<RMP_WORD_ORDER);
X        Count=RMP_MSB_Get(RMP_Bitmap[Count])+(Count<<5);
N        
N        /* See if the current thread and the next thread are the same. If yes, place the current at the end of the queue */
N        if(RMP_Cur_Thd==(struct RMP_Thd*)(RMP_Run[Count].Next))
N        {
N            RMP_List_Del(RMP_Cur_Thd->Run_Head.Prev, RMP_Cur_Thd->Run_Head.Next);
N            RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),
N                         RMP_Run[RMP_Cur_Thd->Prio].Prev,
N                         &(RMP_Run[RMP_Cur_Thd->Prio]));
N        }
N        
N        /* Replenish timeslices */
N        RMP_Cur_Thd->Slices_Left=RMP_Cur_Thd->Slices;
N        RMP_Cur_Thd=(struct RMP_Thd*)(RMP_Run[Count].Next);
N        break;
N    }
N    
N    /* Load the SP value from thread structure */
N    RMP_Cur_SP=RMP_Cur_Thd->Stack;
N}
N/* End Function:_RMP_Get_High_Rdy ********************************************/
N
N/* Begin Function:_RMP_Tick_Handler *******************************************
NDescription : The system tick timer interrupt routine.
NInput       : ptr_t Ticks - How many ticks have passed.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
Nvoid _RMP_Tick_Handler(ptr_t Ticks)
N{
N    struct RMP_Thd* Thread;
N    /* Increase the timestamp as always */
N    RMP_Tick+=Ticks;
N#if(RMP_USE_HOOKS==RMP_TRUE)
X#if(0==1)
S    RMP_Tick_Hook(Ticks);
N#endif
N    /* See if the current thread expired. If yes, trigger a scheduler event */
N    if(Ticks>=RMP_Cur_Thd->Slices_Left)
N        RMP_Sched_Pend=1;
N    else
N        RMP_Cur_Thd->Slices_Left-=Ticks;
N    
N    /* Is the scheduler locked? If yes, we cannot process timer events here and will have to pend them */
N    if((&RMP_Delay)!=RMP_Delay.Next)
N    {
N        Thread=RMP_DLY2THD(RMP_Delay.Next);
X        Thread=((struct RMP_Thd*)(((ptr_t)(RMP_Delay . Next))-sizeof(struct RMP_List)));
N        /* If the value is less than this, then it means that the time have
N         * already passed and we have to process this */
N        if((RMP_Tick-Thread->Timeout)<=(RMP_ALLBITS>>1))
X        if((RMP_Tick-Thread->Timeout)<=(((ptr_t)(-1))>>1))
N        {
N            /* If scheduler locked, we pend the processing until it is unlocked */
N            if(RMP_Sched_Locked!=0)
N                RMP_Timer_Pend=1;
N            else
N                _RMP_Timer_Proc();
N        }
N    }
N    
N    if((RMP_Sched_Locked==0)&&(RMP_Sched_Pend!=0))
N    {
N        RMP_Sched_Pend=0;
N        _RMP_Yield();
N    }
N}
N/* End Function:_RMP_Tick_Handler ********************************************/
N
N/* Begin Function:_RMP_Get_Near_Ticks *****************************************
NDescription : Get the nearest timer interrupt arrival time.
NInput       : None.
NOutput      : None.
NReturn      : ptr_t Ticks - How many ticks until the next timeout.
N******************************************************************************/
Nptr_t _RMP_Get_Near_Ticks(void)
N{
N    ptr_t Value;
N    struct RMP_Thd* Thread;
N    
N    /* What is the current thread's timeout value? */
N    Value=RMP_Cur_Thd->Slices_Left;
N    
N    /* What is the nearest timer timeout value? */
N    if((&RMP_Delay)!=RMP_Delay.Next)
N    {
N        Thread=RMP_DLY2THD(RMP_Delay.Next);
X        Thread=((struct RMP_Thd*)(((ptr_t)(RMP_Delay . Next))-sizeof(struct RMP_List)));
N        /* See if it is nearer - don't worry about the situation that the timer
N         * have overflown, because if that is to happen, it would have been 
N         * already processed by the timeout processing routine just called above. */
N        if((Thread->Timeout-RMP_Tick)<Value)
N            Value=Thread->Timeout-RMP_Tick;
N    }
N    
N    /* The timer setting is at least 1 tick */
N    if(Value==0)
N        Value=1;
N    
N    return Value;
N}
N/* End Function:_RMP_Get_Near_Ticks ******************************************/
N
N/* Begin Function:_RMP_Set_Rdy ************************************************
NDescription : Set the thread as ready to schedule. That means, put the thread into
N              the runqueue. When this is called, please make sure that the scheduler
N              is locked.
NInput       : struct RMP_Thd* Thread - The thread to put into the runqueue.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
Nvoid _RMP_Set_Rdy(struct RMP_Thd* Thread)
N{
N    /* Insert this into the corresponding runqueue */
N    RMP_List_Ins(&(Thread->Run_Head),RMP_Run[Thread->Prio].Prev,&(RMP_Run[Thread->Prio]));
N    /* Set this runlevel as active */
N    RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]|=((ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK);
X    RMP_Bitmap[Thread->Prio>>5]|=((ptr_t)1)<<(Thread->Prio&(~(((ptr_t)(-1))<<(5-1))));
N    
N    /* Compare this with the current one to see if we need a context switch */
N    if(Thread->Prio>RMP_Cur_Thd->Prio)
N        RMP_Sched_Pend=1;
N}
N/* End Function:_RMP_Set_Rdy *************************************************/
N
N/* Begin Function:_RMP_Clr_Rdy ************************************************
NDescription : Clear the thread from the runqueue. When this is called, please 
N              make sure that the scheduler is locked.
NInput       : struct RMP_Thd* Thread - The thread to clear from the runqueue.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
Nvoid _RMP_Clr_Rdy(struct RMP_Thd* Thread)
N{
N    /* See if it is the last thread on the priority level */
N    if(Thread->Run_Head.Prev==Thread->Run_Head.Next)
N        RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]&=~(((ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK));
X        RMP_Bitmap[Thread->Prio>>5]&=~(((ptr_t)1)<<(Thread->Prio&(~(((ptr_t)(-1))<<(5-1)))));
N    
N    /* Insert this into the corresponding runqueue */
N    RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
N    
N    /* If it is the current thread, request a context switch */
N    if(Thread==RMP_Cur_Thd)
N        RMP_Sched_Pend=1;
N}
N/* End Function:_RMP_Clr_Rdy *************************************************/
N
N/* Begin Function:_RMP_Dly_Ins ************************************************
NDescription : Insert the thread into the delay queue, given some timeslices into the
N              future. The thread must not be in the run queue any more.
NInput       : struct RMP_Thd* Thread - The thread to put into the delay queue.
N              ptr_t - The timeslices to delay.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
Nvoid _RMP_Dly_Ins(struct RMP_Thd* Thread, ptr_t Slices)
N{
N    struct RMP_List* Trav_Ptr;
N    struct RMP_Thd* Trav_Thd;
N    
N    Trav_Ptr=(struct RMP_List*)RMP_Delay.Next;
N    while(Trav_Ptr!=&(RMP_Delay))
N    {
N        Trav_Thd=RMP_DLY2THD(Trav_Ptr);
X        Trav_Thd=((struct RMP_Thd*)(((ptr_t)(Trav_Ptr))-sizeof(struct RMP_List)));
N        if((Trav_Thd->Timeout-RMP_Tick)>Slices)
N            break;
N    }
N
N    /* Insert this into the list */
N    Thread->Timeout=RMP_Tick+Slices;
N    RMP_List_Ins(&Thread->Dly_Head,Trav_Ptr->Prev,Trav_Ptr);
N}
N/* End Function:_RMP_Dly_Ins *************************************************/
N
N/* Begin Function:RMP_Thd_Crt *************************************************
NDescription : Create a real-time thread.
NInput       : struct RMP_Thd* Thread - The thread structure provided. The user 
N                                       should make this allocation according to
N                                       his or her needs.
N              void* Entry - The entry of the thread.
N              void* Stack - The stack of this thread.
N              void* Arg - The argument to pass to the thread.
N              ptr_t Prio - The priority of the thread.
N              ptr_t Slices - The number of timeslices to assign to the thread.
NOutput      : None.
NReturn      : ret_t - If successful, 0. on error, return an error code.
N******************************************************************************/
Nret_t RMP_Thd_Crt(struct RMP_Thd* Thread, void* Entry, void* Stack, void* Arg, ptr_t Prio, ptr_t Slices)
N{
N    /* Check if the priority and timeslice range is correct */
N    if(Prio>=RMP_MAX_PREEMPT_PRIO)
X    if(Prio>=32)
N        return RMP_ERR_PRIO;
X        return (-2);
N    if((Slices==0)||(Slices>=RMP_MAX_SLICES))
X    if((Slices==0)||(Slices>=100000))
N        return RMP_ERR_SLICE;
X        return (-3);
N    
N    /* Check if this thread structure could possibly be in use */
N    if(Thread==0)
N        return RMP_ERR_THD;
X        return (-1);
N    
N    RMP_Lock_Sched();
N    
N    if(RMP_THD_STATE(Thread->State)!=RMP_THD_FREE)
X    if(((Thread->State)&0xFF)!=(0))
N    {
N        RMP_Unlock_Sched();
N        return RMP_ERR_THD;
X        return (-1);
N    }
N    
N    /* Create the thread and insert it into the list */
N    Thread->Prio=Prio;
N    Thread->Slices=Slices;
N    Thread->Slices_Left=Slices;
N    Thread->Stack=(ptr_t)Stack;
N    
N    /* Initialize its stack and sending list */
N    _RMP_Stack_Init((ptr_t)Entry, (ptr_t)Stack, (ptr_t)Arg);
N    RMP_List_Crt(&(Thread->Snd_List));
N    
N    /* Notify the scheduler that we have created something new, also check locks */
N    Thread->State=RMP_THD_RUNNING;
X    Thread->State=(1);
N    _RMP_Set_Rdy(Thread);
N    
N    RMP_Unlock_Sched();
N
N    return 0;
N}
N/* End Function:RMP_Thd_Crt **************************************************/
N
N/* Begin Function:RMP_Thd_Del *************************************************
NDescription : Delete a real-time thread.
NInput       : struct RMP_Thd* Thread - The thread structure of the thread.
NOutput      : None.
NReturn      : ret_t - If successful, 0; or an error code.
N******************************************************************************/
Nret_t RMP_Thd_Del(struct RMP_Thd* Thread)
N{
N    struct RMP_Thd* Release;
N    ptr_t Self_Del;
N    
N    /* Check if this thread structure could possibly be in use */
N    if(Thread==0)
N        return RMP_ERR_THD;
X        return (-1);
N    
N    RMP_Lock_Sched();
N    
N    if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
X    if(((Thread->State)&0xFF)==(0))
N    {
N        RMP_Unlock_Sched();
N        return RMP_ERR_THD;
X        return (-1);
N    }
N    
N    /* See if anyone waiting to send to this thread. If there is, release all these threads */
N    while(&(Thread->Snd_List)!=Thread->Snd_List.Next)
N    {
N        Release=(struct RMP_Thd*)(Thread->Snd_List.Next);
N        RMP_List_Del(Release->Run_Head.Prev,Release->Run_Head.Next);
N        if(RMP_THD_STATE(Release->State)==RMP_THD_SNDDLY)
X        if(((Release ->State)&0xFF)==(3))
N            RMP_List_Del(Release->Dly_Head.Prev,Release->Dly_Head.Next);
N
N        RMP_THD_STATE_SET(Release->State,RMP_THD_RUNNING);
X        ((Release ->State)=(((Release ->State)&~0xFF)|((1))));
N
N        /* Is it suspended? If yes, we can't directly send it running */
N        if((Release->State&RMP_THD_SUSPENDED)==0)
X        if((Release->State&(1<<8))==0)
N           _RMP_Set_Rdy(Release);
N        
N        Release->Retval=RMP_ERR_OPER;
X        Release->Retval=(-5);
N    }
N    
N    /* See what is it state */
N    Self_Del=0;
N    if(RMP_Cur_Thd==Thread)
N        Self_Del=1;
N    
N    switch(RMP_THD_STATE(Thread->State))
X    switch(((Thread->State)&0xFF))
N    {
N        case RMP_THD_RUNNING:
X        case (1):
N        {
N            if((Thread->State&RMP_THD_SUSPENDED)==0)
X            if((Thread->State&(1<<8))==0)
N                _RMP_Clr_Rdy(Thread);
N            break;
N        }
N        
N        case RMP_THD_SNDDLY:
X        case (3):
N        case RMP_THD_SEMDLY:
X        case (8):
N        {
N            if((Thread->State&RMP_THD_SUSPENDED)==0)
X            if((Thread->State&(1<<8))==0)
N                RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
N            RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
N            Thread->Retval=RMP_ERR_OPER;
X            Thread->Retval=(-5);
N            break;
N        }
N            
N        case RMP_THD_RCVDLY:
X        case (5):
N        {
N            RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
N            Thread->Retval=RMP_ERR_OPER;
X            Thread->Retval=(-5);
N            break;
N        }
N            
N        case RMP_THD_DELAYED:
X        case (6):
N        {
N            RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
N            Thread->Retval=RMP_ERR_OPER;
X            Thread->Retval=(-5);
N            break;
N        }
N        /* Should not get here */
N        default:break;
N    }
N    Thread->State=RMP_THD_FREE;
X    Thread->State=(0);
N    
N    RMP_Unlock_Sched();
N    
N    /* If we are deleting ourself, just stop the execution here */
N    if(Self_Del!=0)
N        while(1);
N
N    return 0;
N}
N/* End Function:RMP_Thd_Del **************************************************/
N
N/* Begin Function:RMP_Thd_Set *************************************************
NDescription : Change the priority or timeslice of a real-time thread. If one of
N              the changes is not desired, just leave it to RMP_MAX_PREEMPT_PRIO
N              or RMP_MAX_SLICES.
NInput       : struct RMP_Thd* Thread - The thread structure of the thread.
N              ptr_t Prio - The priority of the thread.
N              ptr_t Slices - The new timeslice value for this thread.
NOutput      : None.
NReturn      : ret_t - If successful, 0; else error code.
N******************************************************************************/
Nret_t RMP_Thd_Set(struct RMP_Thd* Thread, ptr_t Prio, ptr_t Slices)
N{
N    /* Check if the priority and timeslice range is correct */
N    if(Slices==0)
N        return RMP_ERR_SLICE;
X        return (-3);
N    
N    /* Check if this thread structure could possibly be in use */
N    if(Thread==0)
N        return RMP_ERR_THD;
X        return (-1);
N    
N    RMP_Lock_Sched();
N    
N    if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
X    if(((Thread->State)&0xFF)==(0))
N    {
N        RMP_Unlock_Sched();
N        return RMP_ERR_THD;
X        return (-1);
N    }
N    
N    /* See if the thread is in running state */
N    if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
X    if(((Thread->State)&0xFF)==(1))
N    {
N        /* See if we are gonna change one of it or both */
N        if(Prio<RMP_MAX_PREEMPT_PRIO)
X        if(Prio<32)
N        {
N            if(Thread->Prio!=Prio)
N            {
N                _RMP_Clr_Rdy(Thread);
N                Thread->Prio=Prio;
N                _RMP_Set_Rdy(Thread);
N            }
N        }
N        
N        if(Slices<RMP_MAX_SLICES)
X        if(Slices<100000)
N            Thread->Slices=Slices;
N    }
N    else
N    {
N        if(Prio<RMP_MAX_PREEMPT_PRIO)
X        if(Prio<32)
N            Thread->Prio=Prio;
N        
N        if(Slices<RMP_MAX_SLICES)
X        if(Slices<100000)
N            Thread->Slices=Slices;
N    }
N    
N    RMP_Unlock_Sched();
N    
N    return 0;
N}
N/* End Function:RMP_Thd_Set **************************************************/
N
N/* Begin Function:RMP_Thd_Suspend *********************************************
NDescription : Suspend the execution of a real-time thread.
NInput       : struct RMP_Thd* Thread - The thread structure of the thread.
NOutput      : None.
NReturn      : ret_t - If successful, 0; else error code.
N******************************************************************************/
Nret_t RMP_Thd_Suspend(struct RMP_Thd* Thread)
N{
N    /* Check if this thread structure could possibly be in use */
N    if(Thread==0)
N        return RMP_ERR_THD;
X        return (-1);
N    
N    RMP_Lock_Sched();
N    
N    if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
X    if(((Thread->State)&0xFF)==(0))
N    {
N        RMP_Unlock_Sched();
N        return RMP_ERR_THD;
X        return (-1);
N    }
N    
N    /* Suspend it */
N    if((Thread->State&RMP_THD_SUSPENDED)!=0)
X    if((Thread->State&(1<<8))!=0)
N    {
N        RMP_Unlock_Sched();
N        return RMP_ERR_STATE;
X        return (-4);
N    }
N    /* Mark this as suspended */
N    Thread->State|=RMP_THD_SUSPENDED;
X    Thread->State|=(1<<8);
N    /* Only when it is running do we clear this */
N    if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
X    if(((Thread->State)&0xFF)==(1))
N        _RMP_Clr_Rdy(Thread);
N    
N    RMP_Unlock_Sched();
N
N    return 0;
N}
N/* End Function:RMP_Thd_Suspend **********************************************/
N
N/* Begin Function:RMP_Thd_Resume **********************************************
NDescription : Resume the execution of a real-time thread.
NInput       : struct RMP_Thd* Thread - The thread structure of the thread.
NOutput      : None.
NReturn      : ret_t - If successful, 0; else error code.
N******************************************************************************/
Nret_t RMP_Thd_Resume(struct RMP_Thd* Thread)
N{
N    ret_t Retval;
N    
N    /* Check if this thread structure could possibly be in use */
N    if(Thread==0)
N        return RMP_ERR_THD;
X        return (-1);
N
N    RMP_Lock_Sched();
N    
N    if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
X    if(((Thread->State)&0xFF)==(0))
N    {
N        RMP_Unlock_Sched();
N        return RMP_ERR_THD;
X        return (-1);
N    }
N    
N    /* Check if the thread is suspended, if not, then throw an error */
N    if((Thread->State&RMP_THD_SUSPENDED)!=0)
X    if((Thread->State&(1<<8))!=0)
N    {
N        /* Suspended */
N        Thread->State&=~RMP_THD_SUSPENDED;
X        Thread->State&=~(1<<8);
N        if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
X        if(((Thread->State)&0xFF)==(1))
N            _RMP_Set_Rdy(Thread);
N        Retval=0;
N    }
N    else
N        Retval=RMP_ERR_STATE;
X        Retval=(-4);
N    
N    RMP_Unlock_Sched();
N
N    return Retval;
N}
N/* End Function:RMP_Thd_Resume ***********************************************/
N
N/* Begin Function:RMP_Thd_Snd *************************************************
NDescription : Send to a real-time thread's mailbox. If the mailbox is full, then
N              this operation can potentially block.
NInput       : struct RMP_Thd* Thread - The thread structure of the thread to send to.
N              ptr_t Data - The data to send to that thread.
N              ptr_t Slices - The timeslice to wait, if the mailbox is already full.
NOutput      : None.
NReturn      : ret_t - If successful,0; or an error code.
N******************************************************************************/
Nret_t RMP_Thd_Snd(struct RMP_Thd* Thread, ptr_t Data, ptr_t Slices)
N{
N    /* Check if this thread structure could possibly be in use */
N    if(Thread==0)
N        return RMP_ERR_THD;
X        return (-1);
N    
N    RMP_Lock_Sched();
N    
N    if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
X    if(((Thread->State)&0xFF)==(0))
N    {
N        RMP_Unlock_Sched();
N        return RMP_ERR_THD;
X        return (-1);
N    }
N    
N    /* Are we sending to ourself? This is not allowed */
N    if(RMP_Cur_Thd==Thread)
N    {
N        RMP_Unlock_Sched();
N        return RMP_ERR_OPER;
X        return (-5);
N    }
N    
N    RMP_Cur_Thd->Retval=0;
N
N    /* See if there are already a value in the mailbox, if there is, we block */
N    if((Thread->State&RMP_THD_MBOXFUL)!=0)
X    if((Thread->State&((1<<8)<<1))!=0)
N    {
N        /* Mailbox full, we block, and put ourself into the queue */
N        if(Slices==0)
N        {
N            RMP_Unlock_Sched();
N            return RMP_ERR_OPER;
X            return (-5);
N        }
N
N        /* We must be running */
N        _RMP_Clr_Rdy(RMP_Cur_Thd);
N        RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Thread->Snd_List.Prev,&(Thread->Snd_List));
N
N        if(Slices<RMP_MAX_SLICES)
X        if(Slices<100000)
N        {
N            _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
N            RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDDLY);
X            ((RMP_Cur_Thd->State)=(((RMP_Cur_Thd->State)&~0xFF)|((3))));
N        }
N        else
N            RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDBLK);
X            ((RMP_Cur_Thd->State)=(((RMP_Cur_Thd->State)&~0xFF)|((2))));
N
N        RMP_Cur_Thd->Data=Data;
N    }
N    else
N    {
N        /* Mailbox not full. We need to check if the receiver is waiting for us */
N        if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
X        if((((Thread->State)&0xFF)==(4))||
N           (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
X           (((Thread->State)&0xFF)==(5)))
N        {
N            /* The receiver is blocked, wake it up and return the value */
N            if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
X            if(((Thread->State)&0xFF)==(5))
N                RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
N            
N            RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
X            ((Thread->State)=(((Thread->State)&~0xFF)|((1))));
N
N            /* Is it suspended? If yes, we can't directly send it running */
N            if((Thread->State&RMP_THD_SUSPENDED)==0)
X            if((Thread->State&(1<<8))==0)
N                _RMP_Set_Rdy(Thread);
N        }
N        
N        /* Set the mailbox */
N        Thread->Mailbox=Data;
N        Thread->State|=RMP_THD_MBOXFUL;
X        Thread->State|=((1<<8)<<1);
N    }
N    
N    RMP_Unlock_Sched();
N
N    return RMP_Cur_Thd->Retval;
N}
N/* End Function:RMP_Thd_Snd **************************************************/
N
N/* Begin Function:RMP_Thd_Snd_ISR *********************************************
NDescription : Send to a real-time thread's mailbox. If the mailbox is full, then
N              this operation will just fail. This function can only be called from
N              an ISR whose priority is below or equal to the context switch handler's.
NInput       : struct RMP_Thd* Thread - The thread structure of the thread to send to.
N              ptr_t Data - The data to send to that thread.
NOutput      : None.
NReturn      : ret_t - If successful,0; or an error code.
N******************************************************************************/
Nret_t RMP_Thd_Snd_ISR(struct RMP_Thd* Thread, ptr_t Data)
N{
N    /* Check if this thread structure could possibly be in use */
N    if(Thread==0)
N        return RMP_ERR_THD;
X        return (-1);
N    
N    if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
X    if(((Thread->State)&0xFF)==(0))
N        return RMP_ERR_THD;
X        return (-1);
N    
N    if(RMP_Sched_Locked!=0)
N        return RMP_ERR_OPER;
X        return (-5);
N
N    /* See if there are already a value in the mailbox, if there is, we abort */
N    if((Thread->State&RMP_THD_MBOXFUL)!=0)
X    if((Thread->State&((1<<8)<<1))!=0)
N        return RMP_ERR_OPER;
X        return (-5);
N    else
N    {
N        /* Mailbox not full. We need to check if the receiver is waiting for us */
N        if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
X        if((((Thread->State)&0xFF)==(4))||
N           (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
X           (((Thread->State)&0xFF)==(5)))
N        {
N            /* The receiver is blocked, wake it up and return the value */
N            if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
X            if(((Thread->State)&0xFF)==(5))
N                RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
N            
N            RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
X            ((Thread->State)=(((Thread->State)&~0xFF)|((1))));
N
N            /* Is it suspended? If yes, we can't directly send it running */
N            if((Thread->State&RMP_THD_SUSPENDED)==0)
X            if((Thread->State&(1<<8))==0)
N            {
N                _RMP_Set_Rdy(Thread);
N                if(Thread->Prio>RMP_Cur_Thd->Prio)
N                    _RMP_Yield();
N            }
N        }
N        
N        /* Set the mailbox */
N        Thread->Mailbox=Data;
N        Thread->State|=RMP_THD_MBOXFUL;
X        Thread->State|=((1<<8)<<1);
N    }
N
N    return 0;
N}
N/* End Function:RMP_Thd_Snd_ISR **********************************************/
N
N/* Begin Function:RMP_Thd_Rcv *************************************************
NDescription : Receive a message from our own mailbox, and this is blocking.
NInput       : ptr_t Slices - The timeslices to wait, if the mailbox is empty.
NOutput      : ptr_t* Data - The pointer to put the data to.
NReturn      : ret_t - If successful,0; or an error code.
N******************************************************************************/
Nret_t RMP_Thd_Rcv(ptr_t* Data, ptr_t Slices)
N{
N    struct RMP_Thd* Sender;
N    
N    RMP_Lock_Sched();
N
N    /* Check if there is a value in our mailbox. If yes, we return with that value */
N    if((RMP_Cur_Thd->State&RMP_THD_MBOXFUL)!=0)
X    if((RMP_Cur_Thd->State&((1<<8)<<1))!=0)
N    {
N        /* Get the value from mailbox */
N        *Data=RMP_Cur_Thd->Mailbox;
N        RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
X        RMP_Cur_Thd->State&=~((1<<8)<<1);
N        RMP_Unlock_Sched();
N        return 0;
N    }
N    else
N    {
N        /* Is there any other guy waiting on us? If there is, unblock it and set it running */
N        if(&(RMP_Cur_Thd->Snd_List)!=RMP_Cur_Thd->Snd_List.Next)
N        {
N            /* Read the data */
N            Sender=(struct RMP_Thd*)(Sender->Snd_List.Next);
N            *Data=Sender->Data;
N            
N            RMP_List_Del(Sender->Run_Head.Prev,Sender->Run_Head.Next);
N            /* Now we unblock it - what state is it in? */
N            if((RMP_THD_STATE(Sender->State)==RMP_THD_SNDDLY))
X            if((((Sender->State)&0xFF)==(3)))
N                RMP_List_Del(Sender->Dly_Head.Prev,Sender->Dly_Head.Next);
N            
N            RMP_THD_STATE_SET(Sender->State,RMP_THD_RUNNING);
X            ((Sender->State)=(((Sender->State)&~0xFF)|((1))));
N
N            /* Is it suspended? If yes, we can't directly send it running */
N            if((Sender->State&RMP_THD_SUSPENDED)==0)
X            if((Sender->State&(1<<8))==0)
N                _RMP_Set_Rdy(Sender);
N            
N            RMP_Unlock_Sched();
N        }
N        /* No sender waiting on us, we need to block */
N        else
N        {
N            /* No such value in our mailbox, we need to block */
N            if(Slices==0)
N            {
N                RMP_Unlock_Sched();
N                return RMP_ERR_OPER;
X                return (-5);
N            }
N
N            /* We must be running */
N            _RMP_Clr_Rdy(RMP_Cur_Thd);
N
N            if(Slices<RMP_MAX_SLICES)
X            if(Slices<100000)
N            {
N                _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
N                RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVDLY);
X                ((RMP_Cur_Thd->State)=(((RMP_Cur_Thd->State)&~0xFF)|((5))));
N            }
N            else
N                RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVBLK);
X                ((RMP_Cur_Thd->State)=(((RMP_Cur_Thd->State)&~0xFF)|((4))));
N            
N            RMP_Unlock_Sched();
N            
N            /* We've been unblocked. There must be something in our mbox, or we should have failed */
N            RMP_Lock_Sched();
N            *Data=RMP_Cur_Thd->Mailbox;
N            RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
X            RMP_Cur_Thd->State&=~((1<<8)<<1);
N            RMP_Unlock_Sched();
N        }
N    }
N    
N    return RMP_Cur_Thd->Retval;
N}
N/* End Function:RMP_Thd_Rcv **************************************************/
N
N/* Begin Function:RMP_Thd_Delay ***********************************************
NDescription : Delay the execution of a real-time thread.
NInput       : ptr_t Slices - The number of timeslices to delay.
NOutput      : None.
NReturn      : ret_t - If successful, 0; else error code.
N******************************************************************************/
Nret_t RMP_Thd_Delay(ptr_t Slices)
N{
N    if((Slices==0)||(Slices>=RMP_MAX_SLICES))
X    if((Slices==0)||(Slices>=100000))
N        return RMP_ERR_SLICE;
X        return (-3);
N    
N    RMP_Lock_Sched();
N
N    /* We must be running */
N    _RMP_Clr_Rdy(RMP_Cur_Thd);
N    RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_DELAYED);
X    ((RMP_Cur_Thd->State)=(((RMP_Cur_Thd->State)&~0xFF)|((6))));
N    _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
N
N    RMP_Cur_Thd->Retval=0;
N    
N    RMP_Unlock_Sched();
N    
N    /* Need to return if successful or not */
N    return RMP_Cur_Thd->Retval;
N}
N/* End Function:RMP_Thd_Delay ************************************************/
N
N/* Begin Function:RMP_Thd_Cancel **********************************************
NDescription : Cancel the real-time thread from a previous delay.
NInput       : struct RMP_Thd* Thread - The thread structure of the thread.
NOutput      : None.
NReturn      : ret_t - If successful, 0; else error code.
N******************************************************************************/
Nret_t RMP_Thd_Cancel(struct RMP_Thd* Thread)
N{
N    /* Check if this thread structure could possibly be in use */
N    if(Thread==0)
N        return RMP_ERR_THD;
X        return (-1);
N    
N    RMP_Lock_Sched();
N    
N    /* Is it delayed? */
N    if(RMP_THD_STATE(Thread->State)!=RMP_THD_DELAYED)
X    if(((Thread->State)&0xFF)!=(6))
N    {
N        RMP_Unlock_Sched();
N        return RMP_ERR_STATE;
X        return (-4);
N    }
N
N    /* Delete it from the delay list */
N    RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
N    RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
X    ((Thread->State)=(((Thread->State)&~0xFF)|((1))));
N    
N    /* Only when when this thread is not suspended do we change it back */
N    if((Thread->State&RMP_THD_SUSPENDED)==0)
X    if((Thread->State&(1<<8))==0)
N        _RMP_Set_Rdy(Thread);
N    
N    Thread->Retval=RMP_ERR_OPER;
X    Thread->Retval=(-5);
N    
N    RMP_Unlock_Sched();
N
N    return 0;
N}
N/* End Function:RMP_Thd_Cancel ***********************************************/
N
N/* Begin Function:RMP_Sem_Crt *************************************************
NDescription : Create a semaphore in the system.
NInput       : struct RMP_Sem* Semaphore - The pointer to the semaphore structure.
N              ptr_t Number - The initial number of this semaphore.
NOutput      : None.
NReturn      : ret_t - If successful, 0; or an error code.
N******************************************************************************/
Nret_t RMP_Sem_Crt(struct RMP_Sem* Semaphore, ptr_t Number)
N{
N    /* Check if this semaphore structure could possibly be in use */
N    if(Semaphore==0)
N        return RMP_ERR_SEM;
X        return (-6);
N    
N    RMP_Lock_Sched();
N    
N    if(Semaphore->State!=RMP_SEM_FREE)
X    if(Semaphore->State!=(0))
N    {
N        RMP_Unlock_Sched();
N        return RMP_ERR_SEM;
X        return (-6);
N    }
N    
N    /* Is the number too great to initialize? */
N    if(Number>=RMP_SEM_MAX_NUM)
X    if(Number>=1000)
N    {
N        RMP_Unlock_Sched();
N        return RMP_ERR_OPER;
X        return (-5);
N    }
N
N    /* Initialize contents */
N    Semaphore->Cur_Num=Number;
N    Semaphore->State=RMP_SEM_USED;
X    Semaphore->State=(1);
N    RMP_List_Crt(&(Semaphore->Wait_List));
N    
N    RMP_Unlock_Sched();
N    
N    return 0;
N}
N/* End Function:RMP_Sem_Crt **************************************************/
N
N/* Begin Function:RMP_Sem_Del *************************************************
NDescription : Delete a semaphore in the system.
NInput       : struct RMP_Sem* Semaphore - The pointer to the semaphore structure.
NOutput      : None.
NReturn      : ret_t - If successful, 0; else error code.
N******************************************************************************/
Nret_t RMP_Sem_Del(struct RMP_Sem* Semaphore)
N{
N    struct RMP_Thd* Thread;
N    
N    /* Check if this semaphore structure could possibly be in use */
N    if(Semaphore==0)
N        return RMP_ERR_SEM;
X        return (-6);
N    
N    RMP_Lock_Sched();
N    
N    if(Semaphore->State!=RMP_SEM_USED)
X    if(Semaphore->State!=(1))
N    {
N        RMP_Unlock_Sched();
N        return RMP_ERR_SEM;
X        return (-6);
N    }
N
N    /* Get rid of all guys waiting on it */
N    while(&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)
N    {
N        Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
N        RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
N        if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
X        if(((Thread->State)&0xFF)==(8))
N            RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
N
N        RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
X        ((Thread->State)=(((Thread->State)&~0xFF)|((1))));
N
N        /* Is it suspended? If yes, we can't directly send it running */
N        if((Thread->State&RMP_THD_SUSPENDED)==0)
X        if((Thread->State&(1<<8))==0)
N           _RMP_Set_Rdy(Thread);
N        
N        Thread->Retval=RMP_ERR_OPER;
X        Thread->Retval=(-5);
N    }
N    Semaphore->State=RMP_SEM_FREE;
X    Semaphore->State=(0);
N    
N    RMP_Unlock_Sched();
N
N    return 0;
N}
N/* End Function:RMP_Sem_Del **************************************************/
N
N/* Begin Function:RMP_Sem_Pend ************************************************
NDescription : Pend on the semaphore, trying to get one.
NInput       : struct RMP_Sem* Semaphore - The pointer to the semaphore structure.
N              ptr_t Slices - The number of slices to wait.
NOutput      : None.
NReturn      : ret_t - If successful, the current semaphore number; else error code.
N******************************************************************************/
Nret_t RMP_Sem_Pend(struct RMP_Sem* Semaphore, ptr_t Slices)
N{
N    /* Check if this semaphore structure could possibly be in use */
N    if(Semaphore==0)
N        return RMP_ERR_SEM;
X        return (-6);
N    
N    RMP_Lock_Sched();
N    
N    if(Semaphore->State!=RMP_SEM_USED)
X    if(Semaphore->State!=(1))
N    {
N        RMP_Unlock_Sched();
N        return RMP_ERR_SEM;
X        return (-6);
N    }
N    
N    /* Check if we can get one immediately */
N    if(Semaphore->Cur_Num!=0)
N    {
N        Semaphore->Cur_Num--;
N        RMP_Unlock_Sched();
N        return Semaphore->Cur_Num;
N    }
N    else
N    {
N        /* Cannot get one, we need to block */
N        if(Slices==0)
N        {
N            RMP_Unlock_Sched();
N            return RMP_ERR_OPER;
X            return (-5);
N        }
N
N        /* We must be running - place into waitlist now */
N        _RMP_Clr_Rdy(RMP_Cur_Thd);
N        RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Semaphore->Wait_List.Prev,&(Semaphore->Wait_List));
N        
N        if(Slices<RMP_MAX_SLICES)
X        if(Slices<100000)
N        {
N            _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
N            RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMDLY);
X            ((RMP_Cur_Thd->State)=(((RMP_Cur_Thd->State)&~0xFF)|((8))));
N        }
N        else
N            RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMBLK);
X            ((RMP_Cur_Thd->State)=(((RMP_Cur_Thd->State)&~0xFF)|((7))));
N        
N        RMP_Cur_Thd->Retval=0;
N    }
N    
N    RMP_Unlock_Sched();
N
N    return RMP_Cur_Thd->Retval;
N}
N/* End Function:RMP_Sem_Pend *************************************************/
N
N/* Begin Function:RMP_Sem_Abort ***********************************************
NDescription : Abort the waiting of one thread on a semaphore.
NInput       : struct RMP_Thd* Thread - The thread structure of the thread.
NOutput      : None.
NReturn      : ret_t - If successful, 0; else error code.
N******************************************************************************/
Nret_t RMP_Sem_Abort(struct RMP_Thd* Thread)
N{
N    /* Check if this thread structure could possibly be in use */
N    if(Thread==0)
N        return RMP_ERR_THD;
X        return (-1);
N
N    RMP_Lock_Sched();
N    
N    if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
X    if(((Thread->State)&0xFF)==(0))
N    {
N        RMP_Unlock_Sched();
N        return RMP_ERR_THD;
X        return (-1);
N    }
N    
N    /* Is it waiting on a semaphore? If no, we abort and return an error code */
N    if((RMP_THD_STATE(Thread->State)!=RMP_THD_SEMBLK)&&
X    if((((Thread->State)&0xFF)!=(7))&&
N       (RMP_THD_STATE(Thread->State)!=RMP_THD_SEMDLY))
X       (((Thread->State)&0xFF)!=(8)))
N    {
N        RMP_Unlock_Sched();
N        return RMP_ERR_STATE;
X        return (-4);
N    }
N
N    /* Waiting for a semaphore. We abort it and return */
N    RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
N    if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
X    if(((Thread->State)&0xFF)==(8))
N        RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
N    
N    RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
X    ((Thread->State)=(((Thread->State)&~0xFF)|((1))));
N
N    /* Only when when this thread is not suspended do we change it back */
N    if((Thread->State&RMP_THD_SUSPENDED)==0)
X    if((Thread->State&(1<<8))==0)
N        _RMP_Set_Rdy(Thread);
N    
N    Thread->Retval=RMP_ERR_OPER;
X    Thread->Retval=(-5);
N    
N    RMP_Unlock_Sched();
N
N    return 0;
N}
N/* End Function:RMP_Sem_Abort ************************************************/
N
N/* Begin Function:RMP_Sem_Post ************************************************
NDescription : Post a number of semaphores to the list. This function can only be
N              called from an ISR whose priority is below or equal to the context
N              switch handler's.
NInput       : struct RMP_Sem* Semaphore - The pointer to the semaphore structure.
N              ptr_t Number - The number to post.
NOutput      : None.
NReturn      : ret_t - If successful, 0; else error code.
N******************************************************************************/
Nret_t RMP_Sem_Post(struct RMP_Sem* Semaphore, ptr_t Number)
N{
N    struct RMP_Thd* Thread;
N    
N    /* Check if this semaphore structure could possibly be in use */
N    if((Semaphore==0)||(Number==0))
N        return RMP_ERR_SEM;
X        return (-6);
N    
N    RMP_Lock_Sched();
N    
N    if(Semaphore->State!=RMP_SEM_USED)
X    if(Semaphore->State!=(1))
N    {
N        RMP_Unlock_Sched();
N        return RMP_ERR_SEM;
X        return (-6);
N    }
N    
N    /* Would the maximum value be exceeded if this is posted? */
N    if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
X    if((Semaphore->Cur_Num+Number)>=1000)
N    {
N        RMP_Unlock_Sched();
N        return RMP_ERR_OPER;
X        return (-5);
N    }
N    
N    Semaphore->Cur_Num+=Number;
N    /* Is there any thread waiting on it? If there are, clean them up*/
N    while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
N    {
N        Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
N        RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
N        if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
X        if(((Thread->State)&0xFF)==(8))
N            RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
N        RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
X        ((Thread->State)=(((Thread->State)&~0xFF)|((1))));
N
N        /* Only when when this thread is not suspended do we change it back */
N        if((Thread->State&RMP_THD_SUSPENDED)==0)
X        if((Thread->State&(1<<8))==0)
N            _RMP_Set_Rdy(Thread);
N
N        /* Finally, return success */
N        Thread->Retval=0;
N        Semaphore->Cur_Num--;
N    }
N
N    RMP_Unlock_Sched();
N
N    return 0;
N}
N/* End Function:RMP_Sem_Post *************************************************/
N
N/* Begin Function:RMP_Sem_Post_ISR ********************************************
NDescription : Post a number of semaphores to the list.
NInput       : struct RMP_Sem* Semaphore - The pointer to the semaphore structure.
N              ptr_t Number - The number to post.
NOutput      : None.
NReturn      : ret_t - If successful, 0; else error code.
N******************************************************************************/
Nret_t RMP_Sem_Post_ISR(struct RMP_Sem* Semaphore, ptr_t Number)
N{
N    struct RMP_Thd* Thread;
N    /* Check if this semaphore structure could possibly be in use */
N    if((Semaphore==0)||(Number==0))
N        return RMP_ERR_SEM;
X        return (-6);
N    
N    if(Semaphore->State!=RMP_SEM_USED)
X    if(Semaphore->State!=(1))
N        return RMP_ERR_SEM;
X        return (-6);
N
N    if(RMP_Sched_Locked!=0)
N        return RMP_ERR_OPER;
X        return (-5);
N
N    /* Would the maximum value be exceeded if this is posted? */
N    if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
X    if((Semaphore->Cur_Num+Number)>=1000)
N        return RMP_ERR_OPER;
X        return (-5);
N    
N    Semaphore->Cur_Num+=Number;
N    /* Is there any thread waiting on it? If there are, clean them up*/
N    while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
N    {
N        Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
N        RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
N        if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
X        if(((Thread->State)&0xFF)==(8))
N            RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
N        
N        RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
X        ((Thread->State)=(((Thread->State)&~0xFF)|((1))));
N
N        /* Only when when this thread is not suspended do we change it back */
N        if((Thread->State&RMP_THD_SUSPENDED)==0)
X        if((Thread->State&(1<<8))==0)
N        {
N            _RMP_Set_Rdy(Thread);
N            if(Thread->Prio>RMP_Cur_Thd->Prio)
N                _RMP_Yield();
N        }
N
N        /* Finally, return success */
N        Thread->Retval=0;
N        Semaphore->Cur_Num--;
N    }
N
N    return 0;
N}
N/* End Function:RMP_Sem_Post_ISR *********************************************/
N
N/* Begin Function:RMP_Start_Hook **********************************************
NDescription : Initialization hook for low-level hardware, executed immediately
N              after the kernel's low-level initialization.
NInput       : None.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
N#if(RMP_USE_HOOKS==RMP_FALSE)
X#if(0==0)
Nvoid RMP_Start_Hook(void)
N{
N    return;
N}
N#endif
N/* End Function:RMP_Start_Hook ***********************************************/
N
N/* Begin Function:RMP_Save_Ctx ************************************************
NDescription : Save hook for extra context, such as FPU, peripherals and MPU.
NInput       : None.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
N#if(RMP_USE_HOOKS==RMP_FALSE)
X#if(0==0)
Nvoid RMP_Save_Ctx(void)
N{
N    return;
N}
N#endif
N/* End Function:RMP_Save_Ctx *************************************************/
N
N/* Begin Function:RMP_Load_Ctx ************************************************
NDescription : Load hook for extra context, such as FPU, peripherals and MPU.
NInput       : None.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
N#if(RMP_USE_HOOKS==RMP_FALSE)
X#if(0==0)
Nvoid RMP_Load_Ctx(void)
N{
N    return;
N}
N#endif
N/* End Function:RMP_Load_Ctx *************************************************/
N
N/* Begin Function:RMP_Tick_Hook ***********************************************
NDescription : Save hook for extra context, such as FPU, peripherals and MPU.
NInput       : ptr_t Ticks - The number of ticks passed. For constant rate ticking
N                            applications this is always 1; For tickless systems this
N                            could be anything.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
N#if(RMP_USE_HOOKS==RMP_FALSE)
X#if(0==0)
Nvoid RMP_Tick_Hook(ptr_t Ticks)
N{
N    return;
N}
N#endif
N/* End Function:RMP_Tick_Hook ************************************************/
N
N/* Begin Function:RMP_Init ****************************************************
NDescription : The entry of the user thread. This is the first user thread that
N              will be created.
N              The user threads should never return.
NInput       : None.
NOutput      : None.
NReturn      : int - This function never returns.
N******************************************************************************/
Nvoid RMP_Init(void)
N{
N    RMP_Lock_Sched();
N    
N    /* Platform will use this hook to do something */
N    _RMP_Plat_Hook();
N    /* Start the second thread here */
N    RMP_Init_Hook();
N    
N    RMP_Unlock_Sched();
N    
N    while(1)
N    {
N        RMP_Init_Idle();
N    };
N}
N/* End Function:RMP_Init *****************************************************/
N
N/* Begin Function:main ********************************************************
NDescription : The entrance of the operating system. This function is for 
N              compatibility with the ARM toolchain.
NInput       : None.
NOutput      : None.
NReturn      : int - This function never returns.
N******************************************************************************/
Nint main(void)
N{
N    cnt_t Count;
N    /* Initialize the kernel data structures first */
N    _RMP_Low_Level_Init();
N    
N#if(RMP_USE_HOOKS==RMP_TRUE)
X#if(0==1)
S    RMP_Start_Hook();
N#endif
N    
N    RMP_Tick=0;
N    /* Now initialize the kernel data structures */
N    RMP_Sched_Lock_Cnt=0;
N    RMP_Sched_Locked=0;
N    RMP_Sched_Pend=0;
N    RMP_Timer_Pend=0;
N    
N    /* Linked lists */
N    RMP_List_Crt(&RMP_Delay);
N    for(Count=0;Count<RMP_MAX_PREEMPT_PRIO;Count++)
X    for(Count=0;Count<32;Count++)
N        RMP_List_Crt(&RMP_Run[Count]);
N    for(Count=0;Count<RMP_BITMAP_SIZE;Count++)
X    for(Count=0;Count<((32-1)/(((ptr_t)1)<<5)+1);Count++)
N        RMP_Bitmap[Count]=0;
N        
N    /* Now boot into the first thread */
N    RMP_Clear(&RMP_Init_Thd,sizeof(struct RMP_Thd));
N    RMP_Init_Thd.Prio=0;
N    RMP_Init_Thd.Slices=RMP_MAX_SLICES-1;
X    RMP_Init_Thd.Slices=100000-1;
N    RMP_Init_Thd.State=RMP_THD_RUNNING;
X    RMP_Init_Thd.State=(1);
N    RMP_Init_Thd.Stack=RMP_INIT_STACK;
X    RMP_Init_Thd.Stack=(((ptr_t)RMP_Init_Stack)+256-(17)*sizeof(ptr_t));
N    
N    /* Initialize sending list */
N    RMP_List_Crt(&(RMP_Init_Thd.Snd_List));
N    
N    /* Insert this into the corresponding runqueue */
N    RMP_List_Ins(&(RMP_Init_Thd.Run_Head),RMP_Run[0].Prev,&(RMP_Run[0]));
N    /* Set this runlevel as active - in fact it is always active */
N    RMP_Bitmap[0]|=1;
N    
N    /* Set current thread and stack */
N    RMP_Cur_Thd=&RMP_Init_Thd;
N    RMP_Cur_SP=RMP_Init_Thd.Stack;
N    
N    /* Now jump to the user function and will never return. Initialization of stack is not needed */
N    _RMP_Start((ptr_t)RMP_Init, (ptr_t)RMP_Init_Thd.Stack);
N    
N    return 0;
N}
N/* End Function:main *********************************************************/
N
N/* End Of File ***************************************************************/
N
N/* Copyright (C) Evo-Devo Instrum. All rights reserved ***********************/
