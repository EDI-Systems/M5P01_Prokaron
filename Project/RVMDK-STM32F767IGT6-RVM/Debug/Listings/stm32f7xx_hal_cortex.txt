; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f7xx_hal_cortex.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f7xx_hal_cortex.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\..\Library\STM32F7xx_HAL_Driver\Core -I..\..\..\..\Library\STM32F7xx_HAL_Driver\Inc -I..\..\..\..\Library\STM32F7xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\32-Bit_MCU\STM32\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f7xx_hal_cortex.crf ..\..\..\..\Library\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_cortex.c]
                          THUMB

                          AREA ||i.HAL_MPU_ConfigRegion||, CODE, READONLY, ALIGN=2

                  HAL_MPU_ConfigRegion PROC
;;;277      */
;;;278    void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
000000  7841              LDRB     r1,[r0,#1]
;;;279    {
;;;280      /* Check the parameters */
;;;281      assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
;;;282      assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));
;;;283    
;;;284      /* Set the Region number */
;;;285      MPU->RNR = MPU_Init->Number;
000002  4a15              LDR      r2,|L1.88|
000004  6011              STR      r1,[r2,#0]
;;;286    
;;;287      if ((MPU_Init->Enable) != RESET)
000006  7801              LDRB     r1,[r0,#0]
000008  b1f9              CBZ      r1,|L1.74|
;;;288      {
;;;289        /* Check the parameters */
;;;290        assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));
;;;291        assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));
;;;292        assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));
;;;293        assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));
;;;294        assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
;;;295        assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
;;;296        assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
;;;297        assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
;;;298        
;;;299        MPU->RBAR = MPU_Init->BaseAddress;
00000a  1d12              ADDS     r2,r2,#4
00000c  6841              LDR      r1,[r0,#4]
00000e  6011              STR      r1,[r2,#0]
;;;300        MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
000010  7b01              LDRB     r1,[r0,#0xc]
000012  0709              LSLS     r1,r1,#28
000014  7ac2              LDRB     r2,[r0,#0xb]
000016  ea416102          ORR      r1,r1,r2,LSL #24
00001a  7a82              LDRB     r2,[r0,#0xa]
00001c  ea4141c2          ORR      r1,r1,r2,LSL #19
000020  7b42              LDRB     r2,[r0,#0xd]
000022  ea414182          ORR      r1,r1,r2,LSL #18
000026  7b82              LDRB     r2,[r0,#0xe]
000028  ea414142          ORR      r1,r1,r2,LSL #17
00002c  7bc2              LDRB     r2,[r0,#0xf]
00002e  ea414102          ORR      r1,r1,r2,LSL #16
000032  7a42              LDRB     r2,[r0,#9]
000034  ea412102          ORR      r1,r1,r2,LSL #8
000038  7a02              LDRB     r2,[r0,#8]
00003a  ea410142          ORR      r1,r1,r2,LSL #1
00003e  7802              LDRB     r2,[r0,#0]
000040  4311              ORRS     r1,r1,r2
000042  4a05              LDR      r2,|L1.88|
000044  3208              ADDS     r2,r2,#8
000046  6011              STR      r1,[r2,#0]
000048  e005              B        |L1.86|
                  |L1.74|
;;;301                    ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
;;;302                    ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
;;;303                    ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
;;;304                    ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
;;;305                    ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
;;;306                    ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
;;;307                    ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
;;;308                    ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
;;;309      }
;;;310      else
;;;311      {
;;;312        MPU->RBAR = 0x00;
00004a  2100              MOVS     r1,#0
00004c  4a02              LDR      r2,|L1.88|
00004e  1d12              ADDS     r2,r2,#4
000050  6011              STR      r1,[r2,#0]
;;;313        MPU->RASR = 0x00;
000052  1d12              ADDS     r2,r2,#4
000054  6011              STR      r1,[r2,#0]
                  |L1.86|
;;;314      }
;;;315    }
000056  4770              BX       lr
;;;316    #endif /* __MPU_PRESENT */
                          ENDP

                  |L1.88|
                          DCD      0xe000ed98

                          AREA ||i.HAL_NVIC_ClearPendingIRQ||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_ClearPendingIRQ PROC
;;;397      */
;;;398    void HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn)
000000  bf00              NOP      
000002  f000021f          AND      r2,r0,#0x1f
000006  2101              MOVS     r1,#1
000008  4091              LSLS     r1,r1,r2
00000a  4a03              LDR      r2,|L2.24|
00000c  0943              LSRS     r3,r0,#5
00000e  f8421023          STR      r1,[r2,r3,LSL #2]
000012  bf00              NOP      
;;;399    {
;;;400      /* Check the parameters */
;;;401      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;402      
;;;403      /* Clear pending interrupt */
;;;404      NVIC_ClearPendingIRQ(IRQn);
;;;405    }
000014  4770              BX       lr
;;;406    
                          ENDP

000016  0000              DCW      0x0000
                  |L2.24|
                          DCD      0xe000e280

                          AREA ||i.HAL_NVIC_DisableIRQ||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_DisableIRQ PROC
;;;220      */
;;;221    void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
000000  bf00              NOP      
000002  f000021f          AND      r2,r0,#0x1f
000006  2101              MOVS     r1,#1
000008  4091              LSLS     r1,r1,r2
00000a  4a03              LDR      r2,|L3.24|
00000c  0943              LSRS     r3,r0,#5
00000e  f8421023          STR      r1,[r2,r3,LSL #2]
000012  bf00              NOP      
;;;222    {
;;;223      /* Check the parameters */
;;;224      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;225      
;;;226      /* Disable interrupt */
;;;227      NVIC_DisableIRQ(IRQn);
;;;228    }
000014  4770              BX       lr
;;;229    
                          ENDP

000016  0000              DCW      0x0000
                  |L3.24|
                          DCD      0xe000e180

                          AREA ||i.HAL_NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_EnableIRQ PROC
;;;204      */
;;;205    void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
000000  bf00              NOP      
000002  f000021f          AND      r2,r0,#0x1f
000006  2101              MOVS     r1,#1
000008  4091              LSLS     r1,r1,r2
00000a  0942              LSRS     r2,r0,#5
00000c  0092              LSLS     r2,r2,#2
00000e  f10222e0          ADD      r2,r2,#0xe000e000
000012  f8c21100          STR      r1,[r2,#0x100]
000016  bf00              NOP      
;;;206    {
;;;207      /* Check the parameters */
;;;208      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;209      
;;;210      /* Enable interrupt */
;;;211      NVIC_EnableIRQ(IRQn);
;;;212    }
000018  4770              BX       lr
;;;213    
                          ENDP


                          AREA ||i.HAL_NVIC_GetActive||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_GetActive PROC
;;;414      */
;;;415    uint32_t HAL_NVIC_GetActive(IRQn_Type IRQn)
000000  b510              PUSH     {r4,lr}
;;;416    {
000002  4601              MOV      r1,r0
;;;417      /* Check the parameters */
;;;418      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;419      
;;;420      /* Return 1 if active else 0 */
;;;421      return NVIC_GetActive(IRQn);
000004  4608              MOV      r0,r1
000006  4a07              LDR      r2,|L5.36|
000008  0943              LSRS     r3,r0,#5
00000a  f8522023          LDR      r2,[r2,r3,LSL #2]
00000e  f000041f          AND      r4,r0,#0x1f
000012  2301              MOVS     r3,#1
000014  40a3              LSLS     r3,r3,r4
000016  401a              ANDS     r2,r2,r3
000018  b10a              CBZ      r2,|L5.30|
00001a  2201              MOVS     r2,#1
00001c  e000              B        |L5.32|
                  |L5.30|
00001e  2200              MOVS     r2,#0
                  |L5.32|
000020  4610              MOV      r0,r2
;;;422    }
000022  bd10              POP      {r4,pc}
;;;423    
                          ENDP

                  |L5.36|
                          DCD      0xe000e300

                          AREA ||i.HAL_NVIC_GetPendingIRQ||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_GetPendingIRQ PROC
;;;381      */
;;;382    uint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn)
000000  b510              PUSH     {r4,lr}
;;;383    {
000002  4601              MOV      r1,r0
;;;384      /* Check the parameters */
;;;385      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;386      
;;;387      /* Return 1 if pending else 0 */
;;;388      return NVIC_GetPendingIRQ(IRQn);
000004  4608              MOV      r0,r1
000006  4a07              LDR      r2,|L6.36|
000008  0943              LSRS     r3,r0,#5
00000a  f8522023          LDR      r2,[r2,r3,LSL #2]
00000e  f000041f          AND      r4,r0,#0x1f
000012  2301              MOVS     r3,#1
000014  40a3              LSLS     r3,r3,r4
000016  401a              ANDS     r2,r2,r3
000018  b10a              CBZ      r2,|L6.30|
00001a  2201              MOVS     r2,#1
00001c  e000              B        |L6.32|
                  |L6.30|
00001e  2200              MOVS     r2,#0
                  |L6.32|
000020  4610              MOV      r0,r2
;;;389    }
000022  bd10              POP      {r4,pc}
;;;390    
                          ENDP

                  |L6.36|
                          DCD      0xe000e200

                          AREA ||i.HAL_NVIC_GetPriority||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_GetPriority PROC
;;;348      */
;;;349    void HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t *pPreemptPriority, uint32_t *pSubPriority)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;350    {
000004  4604              MOV      r4,r0
;;;351      /* Check the parameters */
;;;352      assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
;;;353     /* Get priority for Cortex-M system or device specific interrupts */
;;;354      NVIC_DecodePriority(NVIC_GetPriority(IRQn), PriorityGroup, pPreemptPriority, pSubPriority);
000006  4620              MOV      r0,r4
000008  2800              CMP      r0,#0
00000a  da08              BGE      |L7.30|
00000c  4f1f              LDR      r7,|L7.140|
00000e  f0000c0f          AND      r12,r0,#0xf
000012  f1ac0c04          SUB      r12,r12,#4
000016  f817700c          LDRB     r7,[r7,r12]
00001a  093f              LSRS     r7,r7,#4
00001c  e002              B        |L7.36|
                  |L7.30|
00001e  4f1c              LDR      r7,|L7.144|
000020  5c3f              LDRB     r7,[r7,r0]
000022  093f              LSRS     r7,r7,#4
                  |L7.36|
000024  463d              MOV      r5,r7
000026  460e              MOV      r6,r1
000028  f0060007          AND      r0,r6,#7
00002c  f1c00807          RSB      r8,r0,#7
000030  f1b80f04          CMP      r8,#4
000034  d902              BLS      |L7.60|
000036  f04f0804          MOV      r8,#4
00003a  e001              B        |L7.64|
                  |L7.60|
00003c  f1c00807          RSB      r8,r0,#7
                  |L7.64|
000040  46c4              MOV      r12,r8
000042  f1000804          ADD      r8,r0,#4
000046  f1b80f07          CMP      r8,#7
00004a  d202              BCS      |L7.82|
00004c  f04f0800          MOV      r8,#0
000050  e001              B        |L7.86|
                  |L7.82|
000052  f1a00803          SUB      r8,r0,#3
                  |L7.86|
000056  4647              MOV      r7,r8
000058  fa25f807          LSR      r8,r5,r7
00005c  f04f0901          MOV      r9,#1
000060  fa09f90c          LSL      r9,r9,r12
000064  f1a90901          SUB      r9,r9,#1
000068  ea080809          AND      r8,r8,r9
00006c  f8c28000          STR      r8,[r2,#0]
000070  f04f0801          MOV      r8,#1
000074  fa08f807          LSL      r8,r8,r7
000078  f1a80801          SUB      r8,r8,#1
00007c  ea080805          AND      r8,r8,r5
000080  f8c38000          STR      r8,[r3,#0]
000084  bf00              NOP      
;;;355    }
000086  e8bd83f0          POP      {r4-r9,pc}
;;;356    
                          ENDP

00008a  0000              DCW      0x0000
                  |L7.140|
                          DCD      0xe000ed18
                  |L7.144|
                          DCD      0xe000e400

                          AREA ||i.HAL_NVIC_GetPriorityGrouping||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_GetPriorityGrouping PROC
;;;321      */
;;;322    uint32_t HAL_NVIC_GetPriorityGrouping(void)
000000  b510              PUSH     {r4,lr}
;;;323    {
;;;324      /* Get the PRIGROUP[10:8] field value */
;;;325      return NVIC_GetPriorityGrouping();
000002  f7fffffe          BL       NVIC_GetPriorityGrouping
;;;326    }
000006  bd10              POP      {r4,pc}
;;;327    
                          ENDP


                          AREA ||i.HAL_NVIC_SetPendingIRQ||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_SetPendingIRQ PROC
;;;363      */
;;;364    void HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn)
000000  bf00              NOP      
000002  f000021f          AND      r2,r0,#0x1f
000006  2101              MOVS     r1,#1
000008  4091              LSLS     r1,r1,r2
00000a  4a03              LDR      r2,|L9.24|
00000c  0943              LSRS     r3,r0,#5
00000e  f8421023          STR      r1,[r2,r3,LSL #2]
000012  bf00              NOP      
;;;365    {
;;;366      /* Check the parameters */
;;;367      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;368      
;;;369      /* Set interrupt pending */
;;;370      NVIC_SetPendingIRQ(IRQn);
;;;371    }
000014  4770              BX       lr
;;;372    
                          ENDP

000016  0000              DCW      0x0000
                  |L9.24|
                          DCD      0xe000e200

                          AREA ||i.HAL_NVIC_SetPriority||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_SetPriority PROC
;;;182      */
;;;183    void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;184    { 
000004  4680              MOV      r8,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;185      uint32_t prioritygroup = 0x00;
00000a  2700              MOVS     r7,#0
;;;186      
;;;187      /* Check the parameters */
;;;188      assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
;;;189      assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
;;;190      
;;;191      prioritygroup = NVIC_GetPriorityGrouping();
00000c  f7fffffe          BL       NVIC_GetPriorityGrouping
000010  4607              MOV      r7,r0
;;;192      
;;;193      NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
000012  4639              MOV      r1,r7
000014  462a              MOV      r2,r5
000016  4633              MOV      r3,r6
000018  f0010007          AND      r0,r1,#7
00001c  f1c00a07          RSB      r10,r0,#7
000020  f1ba0f04          CMP      r10,#4
000024  d902              BLS      |L10.44|
000026  f04f0a04          MOV      r10,#4
00002a  e001              B        |L10.48|
                  |L10.44|
00002c  f1c00a07          RSB      r10,r0,#7
                  |L10.48|
000030  46d1              MOV      r9,r10
000032  f1000a04          ADD      r10,r0,#4
000036  f1ba0f07          CMP      r10,#7
00003a  d202              BCS      |L10.66|
00003c  f04f0a00          MOV      r10,#0
000040  e001              B        |L10.70|
                  |L10.66|
000042  f1a00a03          SUB      r10,r0,#3
                  |L10.70|
000046  46d4              MOV      r12,r10
000048  f04f0a01          MOV      r10,#1
00004c  fa0afa09          LSL      r10,r10,r9
000050  f1aa0a01          SUB      r10,r10,#1
000054  ea0a0a02          AND      r10,r10,r2
000058  fa0afa0c          LSL      r10,r10,r12
00005c  f04f0b01          MOV      r11,#1
000060  fa0bfb0c          LSL      r11,r11,r12
000064  f1ab0b01          SUB      r11,r11,#1
000068  ea0b0b03          AND      r11,r11,r3
00006c  ea4a040b          ORR      r4,r10,r11
000070  4621              MOV      r1,r4
000072  4640              MOV      r0,r8
000074  f7fffffe          BL       NVIC_SetPriority
;;;194    }
000078  e8bd9ff0          POP      {r4-r12,pc}
;;;195    
                          ENDP


                          AREA ||i.HAL_NVIC_SetPriorityGrouping||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_SetPriorityGrouping PROC
;;;160      */
;;;161    void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
000000  bf00              NOP      
000002  f0000207          AND      r2,r0,#7
000006  4b06              LDR      r3,|L11.32|
000008  6819              LDR      r1,[r3,#0]
00000a  f64f03ff          MOV      r3,#0xf8ff
00000e  4019              ANDS     r1,r1,r3
000010  4b04              LDR      r3,|L11.36|
000012  430b              ORRS     r3,r3,r1
000014  ea432102          ORR      r1,r3,r2,LSL #8
000018  4b01              LDR      r3,|L11.32|
00001a  6019              STR      r1,[r3,#0]
00001c  bf00              NOP      
;;;162    {
;;;163      /* Check the parameters */
;;;164      assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
;;;165      
;;;166      /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
;;;167      NVIC_SetPriorityGrouping(PriorityGroup);
;;;168    }
00001e  4770              BX       lr
;;;169    
                          ENDP

                  |L11.32|
                          DCD      0xe000ed0c
                  |L11.36|
                          DCD      0x05fa0000

                          AREA ||i.HAL_NVIC_SystemReset||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_SystemReset PROC
;;;233      */
;;;234    void HAL_NVIC_SystemReset(void)
000000  bf00              NOP      
000002  bf00              NOP      
000004  bf00              NOP      
000006  bf00              NOP      
000008  bf00              NOP      
00000a  f3bf8f4f          DSB      
00000e  bf00              NOP      
000010  bf00              NOP      
000012  bf00              NOP      
000014  4809              LDR      r0,|L12.60|
000016  6800              LDR      r0,[r0,#0]
000018  f40060e0          AND      r0,r0,#0x700
00001c  4908              LDR      r1,|L12.64|
00001e  4308              ORRS     r0,r0,r1
000020  1d00              ADDS     r0,r0,#4
000022  4906              LDR      r1,|L12.60|
000024  6008              STR      r0,[r1,#0]
000026  bf00              NOP      
000028  bf00              NOP      
00002a  bf00              NOP      
00002c  f3bf8f4f          DSB      
000030  bf00              NOP      
000032  bf00              NOP      
000034  bf00              NOP      
000036  bf00              NOP      
                  |L12.56|
000038  bf00              NOP      
00003a  e7fd              B        |L12.56|
;;;235    {
;;;236      /* System Reset */
;;;237      NVIC_SystemReset();
;;;238    }
;;;239    
                          ENDP

                  |L12.60|
                          DCD      0xe000ed0c
                  |L12.64|
                          DCD      0x05fa0000

                          AREA ||i.HAL_SYSTICK_CLKSourceConfig||, CODE, READONLY, ALIGN=1

                  HAL_SYSTICK_CLKSourceConfig PROC
;;;431      */
;;;432    void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
000000  2804              CMP      r0,#4
;;;433    {
;;;434      /* Check the parameters */
;;;435      assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
;;;436      if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
000002  d108              BNE      |L13.22|
;;;437      {
;;;438        SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
000004  f04f21e0          MOV      r1,#0xe000e000
000008  6909              LDR      r1,[r1,#0x10]
00000a  f0410104          ORR      r1,r1,#4
00000e  f04f22e0          MOV      r2,#0xe000e000
000012  6111              STR      r1,[r2,#0x10]
000014  e007              B        |L13.38|
                  |L13.22|
;;;439      }
;;;440      else
;;;441      {
;;;442        SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
000016  f04f21e0          MOV      r1,#0xe000e000
00001a  6909              LDR      r1,[r1,#0x10]
00001c  f0210104          BIC      r1,r1,#4
000020  f04f22e0          MOV      r2,#0xe000e000
000024  6111              STR      r1,[r2,#0x10]
                  |L13.38|
;;;443      }
;;;444    }
000026  4770              BX       lr
;;;445    
                          ENDP


                          AREA ||i.HAL_SYSTICK_Callback||, CODE, READONLY, ALIGN=1

                  HAL_SYSTICK_Callback PROC
;;;458      */
;;;459    __weak void HAL_SYSTICK_Callback(void)
000000  4770              BX       lr
;;;460    {
;;;461      /* NOTE : This function Should not be modified, when the callback is needed,
;;;462                the HAL_SYSTICK_Callback could be implemented in the user file
;;;463       */
;;;464    }
;;;465    
                          ENDP


                          AREA ||i.HAL_SYSTICK_Config||, CODE, READONLY, ALIGN=1

                  HAL_SYSTICK_Config PROC
;;;246      */
;;;247    uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
000000  b570              PUSH     {r4-r6,lr}
;;;248    {
000002  4604              MOV      r4,r0
;;;249       return SysTick_Config(TicksNumb);
000004  4625              MOV      r5,r4
000006  1e68              SUBS     r0,r5,#1
000008  f1b07f80          CMP      r0,#0x1000000
00000c  d301              BCC      |L15.18|
00000e  2001              MOVS     r0,#1
000010  e00f              B        |L15.50|
                  |L15.18|
000012  1e68              SUBS     r0,r5,#1
000014  f04f21e0          MOV      r1,#0xe000e000
000018  6148              STR      r0,[r1,#0x14]
00001a  210f              MOVS     r1,#0xf
00001c  f04f30ff          MOV      r0,#0xffffffff
000020  f7fffffe          BL       NVIC_SetPriority
000024  2000              MOVS     r0,#0
000026  f04f21e0          MOV      r1,#0xe000e000
00002a  6188              STR      r0,[r1,#0x18]
00002c  2007              MOVS     r0,#7
00002e  6108              STR      r0,[r1,#0x10]
000030  2000              MOVS     r0,#0
                  |L15.50|
;;;250    }
000032  bd70              POP      {r4-r6,pc}
;;;251    /**
                          ENDP


                          AREA ||i.HAL_SYSTICK_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_SYSTICK_IRQHandler PROC
;;;449      */
;;;450    void HAL_SYSTICK_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;451    {
;;;452      HAL_SYSTICK_Callback();
000002  f7fffffe          BL       HAL_SYSTICK_Callback
;;;453    }
000006  bd10              POP      {r4,pc}
;;;454    
                          ENDP


                          AREA ||i.NVIC_GetPriorityGrouping||, CODE, READONLY, ALIGN=2

                  NVIC_GetPriorityGrouping PROC
;;;1822    */
;;;1823   __STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
000000  4802              LDR      r0,|L17.12|
;;;1824   {
;;;1825     return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
000002  6800              LDR      r0,[r0,#0]
000004  f3c02002          UBFX     r0,r0,#8,#3
;;;1826   }
000008  4770              BX       lr
;;;1827   
                          ENDP

00000a  0000              DCW      0x0000
                  |L17.12|
                          DCD      0xe000ed0c

                          AREA ||i.NVIC_SetPriority||, CODE, READONLY, ALIGN=2

                  NVIC_SetPriority PROC
;;;1905    */
;;;1906   __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000000  b510              PUSH     {r4,lr}
;;;1907   {
;;;1908     if ((int32_t)(IRQn) < 0)
000002  2800              CMP      r0,#0
000004  da07              BGE      |L18.22|
;;;1909     {
;;;1910       SCB->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
000006  070a              LSLS     r2,r1,#28
000008  0e14              LSRS     r4,r2,#24
00000a  4a05              LDR      r2,|L18.32|
00000c  f000030f          AND      r3,r0,#0xf
000010  1f1b              SUBS     r3,r3,#4
000012  54d4              STRB     r4,[r2,r3]
000014  e003              B        |L18.30|
                  |L18.22|
;;;1911     }
;;;1912     else
;;;1913     {
;;;1914       NVIC->IP[((uint32_t)(int32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
000016  070a              LSLS     r2,r1,#28
000018  0e13              LSRS     r3,r2,#24
00001a  4a02              LDR      r2,|L18.36|
00001c  5413              STRB     r3,[r2,r0]
                  |L18.30|
;;;1915     }
;;;1916   }
00001e  bd10              POP      {r4,pc}
;;;1917   
                          ENDP

                  |L18.32|
                          DCD      0xe000ed18
                  |L18.36|
                          DCD      0xe000e400

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_cortex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f7xx_hal_cortex_c_2992dbc0____REV16|
#line 388 "..\\..\\..\\..\\Library\\STM32F7xx_HAL_Driver\\Core\\cmsis_armcc.h"
|__asm___22_stm32f7xx_hal_cortex_c_2992dbc0____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f7xx_hal_cortex_c_2992dbc0____REVSH|
#line 402
|__asm___22_stm32f7xx_hal_cortex_c_2992dbc0____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f7xx_hal_cortex_c_2992dbc0____RRX|
#line 587
|__asm___22_stm32f7xx_hal_cortex_c_2992dbc0____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
