; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\kernel.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\kernel.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Core -I..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-RVM\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\kernel.crf ..\..\MProkaron\Kernel\kernel.c]
                          THUMB

                          AREA ||i.RMP_Clear||, CODE, READONLY, ALIGN=1

                  RMP_Clear PROC
;;;37     ******************************************************************************/
;;;38     void RMP_Clear(void* Addr, ptr_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;39     {
000002  4604              MOV      r4,r0
;;;40         ptr_t* Word_Inc;
;;;41         u8* Byte_Inc;
;;;42         ptr_t Words;
;;;43         ptr_t Bytes;
;;;44         
;;;45         /* On processors not that fast, copy by word is really important */
;;;46         Word_Inc=(ptr_t*)Addr;
000004  4620              MOV      r0,r4
;;;47         for(Words=Size/sizeof(ptr_t);Words>0;Words--)
000006  088d              LSRS     r5,r1,#2
000008  e003              B        |L1.18|
                  |L1.10|
;;;48         {
;;;49             *Word_Inc=0;
00000a  2600              MOVS     r6,#0
00000c  6006              STR      r6,[r0,#0]
;;;50             Word_Inc++;
00000e  1d00              ADDS     r0,r0,#4
000010  1e6d              SUBS     r5,r5,#1              ;47
                  |L1.18|
000012  2d00              CMP      r5,#0                 ;47
000014  d1f9              BNE      |L1.10|
;;;51         }
;;;52         
;;;53         /* Get the final bytes */
;;;54         Byte_Inc=(u8*)Word_Inc;
000016  4602              MOV      r2,r0
;;;55         for(Bytes=Size%sizeof(ptr_t);Bytes>0;Bytes--)
000018  f0010303          AND      r3,r1,#3
00001c  e003              B        |L1.38|
                  |L1.30|
;;;56         {
;;;57             *Byte_Inc=0;
00001e  2600              MOVS     r6,#0
000020  7016              STRB     r6,[r2,#0]
;;;58             Byte_Inc++;
000022  1c52              ADDS     r2,r2,#1
000024  1e5b              SUBS     r3,r3,#1              ;55
                  |L1.38|
000026  2b00              CMP      r3,#0                 ;55
000028  d1f9              BNE      |L1.30|
;;;59         }
;;;60     }
00002a  bd70              POP      {r4-r6,pc}
;;;61     /* End Function:RMP_Clear ****************************************************/
                          ENDP


                          AREA ||i.RMP_Init||, CODE, READONLY, ALIGN=1

                  RMP_Init PROC
;;;1503   ******************************************************************************/
;;;1504   void RMP_Init(void)
000000  f7fffffe          BL       RMP_Lock_Sched
;;;1505   {
;;;1506       RMP_Lock_Sched();
;;;1507       
;;;1508       /* Platform will use this hook to do something */
;;;1509       _RMP_Plat_Hook();
000004  f7fffffe          BL       _RMP_Plat_Hook
;;;1510       /* Start the second thread here */
;;;1511       RMP_Init_Hook();
000008  f7fffffe          BL       RMP_Init_Hook
;;;1512       
;;;1513       RMP_Unlock_Sched();
00000c  f7fffffe          BL       RMP_Unlock_Sched
;;;1514       
;;;1515       while(1)
000010  e001              B        |L2.22|
                  |L2.18|
;;;1516       {
;;;1517           RMP_Init_Idle();
000012  f7fffffe          BL       RMP_Init_Idle
                  |L2.22|
000016  e7fc              B        |L2.18|
;;;1518       };
;;;1519   }
;;;1520   /* End Function:RMP_Init *****************************************************/
                          ENDP


                          AREA ||i.RMP_List_Crt||, CODE, READONLY, ALIGN=1

                  RMP_List_Crt PROC
;;;215    ******************************************************************************/
;;;216    void RMP_List_Crt(volatile struct RMP_List* Head)
000000  6000              STR      r0,[r0,#0]
;;;217    {
;;;218        Head->Prev=(struct RMP_List*)Head;
;;;219        Head->Next=(struct RMP_List*)Head;
000002  6040              STR      r0,[r0,#4]
;;;220    }
000004  4770              BX       lr
;;;221    /* End Function:RMP_List_Crt *************************************************/
                          ENDP


                          AREA ||i.RMP_List_Del||, CODE, READONLY, ALIGN=1

                  RMP_List_Del PROC
;;;229    ******************************************************************************/
;;;230    void RMP_List_Del(volatile struct RMP_List* Prev,volatile struct RMP_List* Next)
000000  6008              STR      r0,[r1,#0]
;;;231    {
;;;232        Next->Prev=(struct RMP_List*)Prev;
;;;233        Prev->Next=(struct RMP_List*)Next;
000002  6041              STR      r1,[r0,#4]
;;;234    }
000004  4770              BX       lr
;;;235    /* End Function:RMP_List_Del *************************************************/
                          ENDP


                          AREA ||i.RMP_List_Ins||, CODE, READONLY, ALIGN=1

                  RMP_List_Ins PROC
;;;244    ******************************************************************************/
;;;245    void RMP_List_Ins(volatile struct RMP_List* New,
000000  6010              STR      r0,[r2,#0]
;;;246                      volatile struct RMP_List* Prev,
;;;247                      volatile struct RMP_List* Next)
;;;248    {
;;;249        Next->Prev=(struct RMP_List*)New;
;;;250        New->Next=(struct RMP_List*)Next;
000002  6042              STR      r2,[r0,#4]
;;;251        New->Prev=(struct RMP_List*)Prev;
000004  6001              STR      r1,[r0,#0]
;;;252        Prev->Next=(struct RMP_List*)New;
000006  6048              STR      r0,[r1,#4]
;;;253    }
000008  4770              BX       lr
;;;254    /* End Function:RMP_List_Ins *************************************************/
                          ENDP


                          AREA ||i.RMP_Load_Ctx||, CODE, READONLY, ALIGN=1

                  RMP_Load_Ctx PROC
;;;1472   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1473   void RMP_Load_Ctx(void)
000000  4770              BX       lr
;;;1474   {
;;;1475       return;
;;;1476   }
;;;1477   #endif
                          ENDP


                          AREA ||i.RMP_Lock_Sched||, CODE, READONLY, ALIGN=2

                  RMP_Lock_Sched PROC
;;;261    ******************************************************************************/
;;;262    void RMP_Lock_Sched(void)
000000  2001              MOVS     r0,#1
;;;263    {
;;;264        /* Disable first before registering it. If an switch occurs between 
;;;265         * registering and disabling, then register-and-disable will cause fault. */
;;;266        RMP_Sched_Locked=1;
000002  4904              LDR      r1,|L7.20|
000004  6008              STR      r0,[r1,#0]  ; RMP_Sched_Locked
;;;267        RMP_Sched_Lock_Cnt++;
000006  4804              LDR      r0,|L7.24|
000008  6800              LDR      r0,[r0,#0]  ; RMP_Sched_Lock_Cnt
00000a  1c40              ADDS     r0,r0,#1
00000c  4902              LDR      r1,|L7.24|
00000e  6008              STR      r0,[r1,#0]  ; RMP_Sched_Lock_Cnt
;;;268    }
000010  4770              BX       lr
;;;269    /* End Function:RMP_Lock_Sched ***********************************************/
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      RMP_Sched_Locked
                  |L7.24|
                          DCD      RMP_Sched_Lock_Cnt

                          AREA ||i.RMP_Print_Int||, CODE, READONLY, ALIGN=1

                  RMP_Print_Int PROC
;;;69     ******************************************************************************/
;;;70     cnt_t RMP_Print_Int(cnt_t Int)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;71     {
000004  4607              MOV      r7,r0
;;;72         ptr_t Iter;
;;;73         cnt_t Count;
;;;74         cnt_t Num;
;;;75         ptr_t Div;
;;;76         
;;;77         /* how many digits are there? */
;;;78         if(Int==0)
000006  b92f              CBNZ     r7,|L8.20|
;;;79         {
;;;80             RMP_Putchar('0');
000008  2030              MOVS     r0,#0x30
00000a  f7fffffe          BL       RMP_Putchar
;;;81             return 1;
00000e  2001              MOVS     r0,#1
                  |L8.16|
;;;82         }
;;;83         else if(Int<0)
;;;84         {
;;;85             /* How many digits are there? */
;;;86             Count=0;
;;;87             Div=1;
;;;88             Iter=-Int;
;;;89             while(Iter!=0)
;;;90             {
;;;91                 Iter/=10;
;;;92                 Count++;
;;;93                 Div*=10;
;;;94             }
;;;95             Div/=10;
;;;96             
;;;97             RMP_Putchar('-');
;;;98             Iter=-Int;
;;;99             Num=Count+1;
;;;100            
;;;101            while(Count>0)
;;;102            {
;;;103                Count--;
;;;104                RMP_Putchar(Iter/Div+'0');
;;;105                Iter=Iter%Div;
;;;106                Div/=10;
;;;107            }
;;;108        }
;;;109        else
;;;110        {
;;;111            /* How many digits are there? */
;;;112            Count=0;
;;;113            Div=1;
;;;114            Iter=Int;
;;;115            while(Iter!=0)
;;;116            {
;;;117                Iter/=10;
;;;118                Count++;
;;;119                Div*=10;
;;;120            }
;;;121            Div/=10;
;;;122            
;;;123            Iter=Int;
;;;124            Num=Count;
;;;125            
;;;126            while(Count>0)
;;;127            {
;;;128                Count--;
;;;129                RMP_Putchar(Iter/Div+'0');
;;;130                Iter=Iter%Div;
;;;131                Div/=10;
;;;132            }
;;;133        }
;;;134        
;;;135        return Num;
;;;136    }
000010  e8bd87f0          POP      {r4-r10,pc}
                  |L8.20|
000014  2f00              CMP      r7,#0                 ;83
000016  da29              BGE      |L8.108|
000018  2600              MOVS     r6,#0                 ;86
00001a  2401              MOVS     r4,#1                 ;87
00001c  427d              RSBS     r5,r7,#0              ;88
00001e  e006              B        |L8.46|
                  |L8.32|
000020  200a              MOVS     r0,#0xa               ;91
000022  fbb5f5f0          UDIV     r5,r5,r0              ;91
000026  1c76              ADDS     r6,r6,#1              ;92
000028  eb040084          ADD      r0,r4,r4,LSL #2       ;93
00002c  0044              LSLS     r4,r0,#1              ;93
                  |L8.46|
00002e  2d00              CMP      r5,#0                 ;89
000030  d1f6              BNE      |L8.32|
000032  200a              MOVS     r0,#0xa               ;95
000034  fbb4f4f0          UDIV     r4,r4,r0              ;95
000038  202d              MOVS     r0,#0x2d              ;97
00003a  f7fffffe          BL       RMP_Putchar
00003e  427d              RSBS     r5,r7,#0              ;98
000040  f1060801          ADD      r8,r6,#1              ;99
000044  e00f              B        |L8.102|
                  |L8.70|
000046  1e76              SUBS     r6,r6,#1              ;103
000048  fbb5f0f4          UDIV     r0,r5,r4              ;104
00004c  3030              ADDS     r0,r0,#0x30           ;104
00004e  fa4ff980          SXTB     r9,r0                 ;104
000052  4648              MOV      r0,r9                 ;104
000054  f7fffffe          BL       RMP_Putchar
000058  fbb5f0f4          UDIV     r0,r5,r4              ;105
00005c  fb045510          MLS      r5,r4,r0,r5           ;105
000060  200a              MOVS     r0,#0xa               ;106
000062  fbb4f4f0          UDIV     r4,r4,r0              ;106
                  |L8.102|
000066  2e00              CMP      r6,#0                 ;101
000068  dced              BGT      |L8.70|
00006a  e024              B        |L8.182|
                  |L8.108|
00006c  2600              MOVS     r6,#0                 ;112
00006e  2401              MOVS     r4,#1                 ;113
000070  463d              MOV      r5,r7                 ;114
000072  e006              B        |L8.130|
                  |L8.116|
000074  200a              MOVS     r0,#0xa               ;117
000076  fbb5f5f0          UDIV     r5,r5,r0              ;117
00007a  1c76              ADDS     r6,r6,#1              ;118
00007c  eb040084          ADD      r0,r4,r4,LSL #2       ;119
000080  0044              LSLS     r4,r0,#1              ;119
                  |L8.130|
000082  2d00              CMP      r5,#0                 ;115
000084  d1f6              BNE      |L8.116|
000086  200a              MOVS     r0,#0xa               ;121
000088  fbb4f4f0          UDIV     r4,r4,r0              ;121
00008c  463d              MOV      r5,r7                 ;123
00008e  46b0              MOV      r8,r6                 ;124
000090  e00f              B        |L8.178|
                  |L8.146|
000092  1e76              SUBS     r6,r6,#1              ;128
000094  fbb5f0f4          UDIV     r0,r5,r4              ;129
000098  3030              ADDS     r0,r0,#0x30           ;129
00009a  fa4ff980          SXTB     r9,r0                 ;129
00009e  4648              MOV      r0,r9                 ;129
0000a0  f7fffffe          BL       RMP_Putchar
0000a4  fbb5f0f4          UDIV     r0,r5,r4              ;130
0000a8  fb045510          MLS      r5,r4,r0,r5           ;130
0000ac  200a              MOVS     r0,#0xa               ;131
0000ae  fbb4f4f0          UDIV     r4,r4,r0              ;131
                  |L8.178|
0000b2  2e00              CMP      r6,#0                 ;126
0000b4  dced              BGT      |L8.146|
                  |L8.182|
0000b6  4640              MOV      r0,r8                 ;135
0000b8  e7aa              B        |L8.16|
;;;137    /* End Function:RMP_Print_Int ************************************************/
                          ENDP


                          AREA ||i.RMP_Print_String||, CODE, READONLY, ALIGN=1

                  RMP_Print_String PROC
;;;192    ******************************************************************************/
;;;193    cnt_t RMP_Print_String(s8* String)
000000  b570              PUSH     {r4-r6,lr}
;;;194    {
000002  4605              MOV      r5,r0
;;;195        cnt_t Count;
;;;196        
;;;197        Count=0;
000004  2400              MOVS     r4,#0
;;;198        while(Count<RMP_KERNEL_DEBUG_MAX_STR)
000006  e007              B        |L9.24|
                  |L9.8|
;;;199        {
;;;200            if(String[Count]=='\0')
000008  5d28              LDRB     r0,[r5,r4]
00000a  b900              CBNZ     r0,|L9.14|
;;;201                break;
00000c  e006              B        |L9.28|
                  |L9.14|
;;;202            
;;;203            RMP_Putchar(String[Count++]);
00000e  4621              MOV      r1,r4
000010  1c64              ADDS     r4,r4,#1
000012  5668              LDRSB    r0,[r5,r1]
000014  f7fffffe          BL       RMP_Putchar
                  |L9.24|
000018  2c80              CMP      r4,#0x80              ;198
00001a  dbf5              BLT      |L9.8|
                  |L9.28|
00001c  bf00              NOP                            ;201
;;;204        }
;;;205        
;;;206        return Count;
00001e  4620              MOV      r0,r4
;;;207    }
000020  bd70              POP      {r4-r6,pc}
;;;208    /* End Function:RMP_Print_String *********************************************/
                          ENDP


                          AREA ||i.RMP_Print_Uint||, CODE, READONLY, ALIGN=1

                  RMP_Print_Uint PROC
;;;145    ******************************************************************************/
;;;146    cnt_t RMP_Print_Uint(ptr_t Uint)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;147    {
000004  4606              MOV      r6,r0
;;;148        ptr_t Iter;
;;;149        cnt_t Count;
;;;150        cnt_t Num;
;;;151        
;;;152        /* how many digits are there? */
;;;153        if(Uint==0)
000006  b92e              CBNZ     r6,|L10.20|
;;;154        {
;;;155            RMP_Putchar('0');
000008  2030              MOVS     r0,#0x30
00000a  f7fffffe          BL       RMP_Putchar
;;;156            return 1;
00000e  2001              MOVS     r0,#1
                  |L10.16|
;;;157        }
;;;158        else
;;;159        {
;;;160            /* Filter out all the zeroes */
;;;161            Count=0;
;;;162            Iter=Uint;
;;;163            while((Iter>>((sizeof(ptr_t)*8)-4))==0)
;;;164            {
;;;165                Iter<<=4;
;;;166                Count++;
;;;167            }
;;;168            /* Count is the number of pts to print */
;;;169            Count=sizeof(ptr_t)*2-Count;
;;;170            Num=Count;
;;;171            while(Count>0)
;;;172            {
;;;173                Count--;
;;;174                Iter=(Uint>>(Count*4))&0x0F;
;;;175                if(Iter<10)
;;;176                    RMP_Putchar('0'+Iter);
;;;177                else
;;;178                    RMP_Putchar('A'+Iter-10);
;;;179            }
;;;180        }
;;;181        
;;;182        return Num;
;;;183    }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L10.20|
000014  2400              MOVS     r4,#0                 ;161
000016  4635              MOV      r5,r6                 ;162
000018  e001              B        |L10.30|
                  |L10.26|
00001a  012d              LSLS     r5,r5,#4              ;165
00001c  1c64              ADDS     r4,r4,#1              ;166
                  |L10.30|
00001e  0f28              LSRS     r0,r5,#28             ;163
000020  2800              CMP      r0,#0                 ;163
000022  d0fa              BEQ      |L10.26|
000024  f1c40408          RSB      r4,r4,#8              ;169
000028  4627              MOV      r7,r4                 ;170
00002a  e012              B        |L10.82|
                  |L10.44|
00002c  1e64              SUBS     r4,r4,#1              ;173
00002e  00a0              LSLS     r0,r4,#2              ;174
000030  fa26f000          LSR      r0,r6,r0              ;174
000034  f000050f          AND      r5,r0,#0xf            ;174
000038  2d0a              CMP      r5,#0xa               ;175
00003a  d205              BCS      |L10.72|
00003c  f1050130          ADD      r1,r5,#0x30           ;176
000040  b248              SXTB     r0,r1                 ;176
000042  f7fffffe          BL       RMP_Putchar
000046  e004              B        |L10.82|
                  |L10.72|
000048  f1050137          ADD      r1,r5,#0x37           ;178
00004c  b248              SXTB     r0,r1                 ;178
00004e  f7fffffe          BL       RMP_Putchar
                  |L10.82|
000052  2c00              CMP      r4,#0                 ;171
000054  dcea              BGT      |L10.44|
000056  4638              MOV      r0,r7                 ;182
000058  e7da              B        |L10.16|
;;;184    /* End Function:RMP_Print_Uint ***********************************************/
                          ENDP


                          AREA ||i.RMP_Save_Ctx||, CODE, READONLY, ALIGN=1

                  RMP_Save_Ctx PROC
;;;1458   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1459   void RMP_Save_Ctx(void)
000000  4770              BX       lr
;;;1460   {
;;;1461       return;
;;;1462   }
;;;1463   #endif
                          ENDP


                          AREA ||i.RMP_Sem_Abort||, CODE, READONLY, ALIGN=1

                  RMP_Sem_Abort PROC
;;;1286   ******************************************************************************/
;;;1287   ret_t RMP_Sem_Abort(struct RMP_Thd* Thread)
000000  b510              PUSH     {r4,lr}
;;;1288   {
000002  4604              MOV      r4,r0
;;;1289       /* Check if this thread structure could possibly be in use */
;;;1290       if(Thread==0)
000004  b914              CBNZ     r4,|L12.12|
;;;1291           return RMP_ERR_THD;
000006  f04f30ff          MOV      r0,#0xffffffff
                  |L12.10|
;;;1292   
;;;1293       RMP_Lock_Sched();
;;;1294       
;;;1295       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;1296       {
;;;1297           RMP_Unlock_Sched();
;;;1298           return RMP_ERR_THD;
;;;1299       }
;;;1300       
;;;1301       /* Is it waiting on a semaphore? If no, we abort and return an error code */
;;;1302       if((RMP_THD_STATE(Thread->State)!=RMP_THD_SEMBLK)&&
;;;1303          (RMP_THD_STATE(Thread->State)!=RMP_THD_SEMDLY))
;;;1304       {
;;;1305           RMP_Unlock_Sched();
;;;1306           return RMP_ERR_STATE;
;;;1307       }
;;;1308   
;;;1309       /* Waiting for a semaphore. We abort it and return */
;;;1310       RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1311       if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1312           RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1313       
;;;1314       RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1315   
;;;1316       /* Only when when this thread is not suspended do we change it back */
;;;1317       if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1318           _RMP_Set_Rdy(Thread);
;;;1319       
;;;1320       Thread->Retval=RMP_ERR_OPER;
;;;1321       
;;;1322       RMP_Unlock_Sched();
;;;1323   
;;;1324       return 0;
;;;1325   }
00000a  bd10              POP      {r4,pc}
                  |L12.12|
00000c  f7fffffe          BL       RMP_Lock_Sched
000010  7e20              LDRB     r0,[r4,#0x18]         ;1295
000012  b920              CBNZ     r0,|L12.30|
000014  f7fffffe          BL       RMP_Unlock_Sched
000018  f04f30ff          MOV      r0,#0xffffffff        ;1298
00001c  e7f5              B        |L12.10|
                  |L12.30|
00001e  7e20              LDRB     r0,[r4,#0x18]         ;1302
000020  2807              CMP      r0,#7                 ;1302
000022  d007              BEQ      |L12.52|
000024  7e20              LDRB     r0,[r4,#0x18]         ;1303
000026  2808              CMP      r0,#8                 ;1303
000028  d004              BEQ      |L12.52|
00002a  f7fffffe          BL       RMP_Unlock_Sched
00002e  f06f0003          MVN      r0,#3                 ;1306
000032  e7ea              B        |L12.10|
                  |L12.52|
000034  e9d40100          LDRD     r0,r1,[r4,#0]         ;1310
000038  f7fffffe          BL       RMP_List_Del
00003c  7e20              LDRB     r0,[r4,#0x18]         ;1311
00003e  2808              CMP      r0,#8                 ;1311
000040  d103              BNE      |L12.74|
000042  e9d40102          LDRD     r0,r1,[r4,#8]         ;1312
000046  f7fffffe          BL       RMP_List_Del
                  |L12.74|
00004a  69a0              LDR      r0,[r4,#0x18]         ;1314
00004c  f02000ff          BIC      r0,r0,#0xff           ;1314
000050  1c40              ADDS     r0,r0,#1              ;1314
000052  61a0              STR      r0,[r4,#0x18]         ;1314
000054  8b20              LDRH     r0,[r4,#0x18]         ;1317
000056  f4007080          AND      r0,r0,#0x100          ;1317
00005a  b910              CBNZ     r0,|L12.98|
00005c  4620              MOV      r0,r4                 ;1318
00005e  f7fffffe          BL       _RMP_Set_Rdy
                  |L12.98|
000062  f06f0004          MVN      r0,#4                 ;1320
000066  63a0              STR      r0,[r4,#0x38]         ;1320
000068  f7fffffe          BL       RMP_Unlock_Sched
00006c  2000              MOVS     r0,#0                 ;1324
00006e  e7cc              B        |L12.10|
;;;1326   /* End Function:RMP_Sem_Abort ************************************************/
                          ENDP


                          AREA ||i.RMP_Sem_Crt||, CODE, READONLY, ALIGN=1

                  RMP_Sem_Crt PROC
;;;1144   ******************************************************************************/
;;;1145   ret_t RMP_Sem_Crt(struct RMP_Sem* Semaphore, ptr_t Number)
000000  b570              PUSH     {r4-r6,lr}
;;;1146   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1147       /* Check if this semaphore structure could possibly be in use */
;;;1148       if(Semaphore==0)
000006  b914              CBNZ     r4,|L13.14|
;;;1149           return RMP_ERR_SEM;
000008  f06f0005          MVN      r0,#5
                  |L13.12|
;;;1150       
;;;1151       RMP_Lock_Sched();
;;;1152       
;;;1153       if(Semaphore->State!=RMP_SEM_FREE)
;;;1154       {
;;;1155           RMP_Unlock_Sched();
;;;1156           return RMP_ERR_SEM;
;;;1157       }
;;;1158       
;;;1159       /* Is the number too great to initialize? */
;;;1160       if(Number>=RMP_SEM_MAX_NUM)
;;;1161       {
;;;1162           RMP_Unlock_Sched();
;;;1163           return RMP_ERR_OPER;
;;;1164       }
;;;1165   
;;;1166       /* Initialize contents */
;;;1167       Semaphore->Cur_Num=Number;
;;;1168       Semaphore->State=RMP_SEM_USED;
;;;1169       RMP_List_Crt(&(Semaphore->Wait_List));
;;;1170       
;;;1171       RMP_Unlock_Sched();
;;;1172       
;;;1173       return 0;
;;;1174   }
00000c  bd70              POP      {r4-r6,pc}
                  |L13.14|
00000e  f7fffffe          BL       RMP_Lock_Sched
000012  68a0              LDR      r0,[r4,#8]            ;1153
000014  b120              CBZ      r0,|L13.32|
000016  f7fffffe          BL       RMP_Unlock_Sched
00001a  f06f0005          MVN      r0,#5                 ;1156
00001e  e7f5              B        |L13.12|
                  |L13.32|
000020  f5b57f7a          CMP      r5,#0x3e8             ;1160
000024  d304              BCC      |L13.48|
000026  f7fffffe          BL       RMP_Unlock_Sched
00002a  f06f0004          MVN      r0,#4                 ;1163
00002e  e7ed              B        |L13.12|
                  |L13.48|
000030  60e5              STR      r5,[r4,#0xc]          ;1167
000032  2001              MOVS     r0,#1                 ;1168
000034  60a0              STR      r0,[r4,#8]            ;1168
000036  4620              MOV      r0,r4                 ;1169
000038  f7fffffe          BL       RMP_List_Crt
00003c  f7fffffe          BL       RMP_Unlock_Sched
000040  2000              MOVS     r0,#0                 ;1173
000042  e7e3              B        |L13.12|
;;;1175   /* End Function:RMP_Sem_Crt **************************************************/
                          ENDP


                          AREA ||i.RMP_Sem_Del||, CODE, READONLY, ALIGN=1

                  RMP_Sem_Del PROC
;;;1182   ******************************************************************************/
;;;1183   ret_t RMP_Sem_Del(struct RMP_Sem* Semaphore)
000000  b570              PUSH     {r4-r6,lr}
;;;1184   {
000002  4605              MOV      r5,r0
;;;1185       struct RMP_Thd* Thread;
;;;1186       
;;;1187       /* Check if this semaphore structure could possibly be in use */
;;;1188       if(Semaphore==0)
000004  b915              CBNZ     r5,|L14.12|
;;;1189           return RMP_ERR_SEM;
000006  f06f0005          MVN      r0,#5
                  |L14.10|
;;;1190       
;;;1191       RMP_Lock_Sched();
;;;1192       
;;;1193       if(Semaphore->State!=RMP_SEM_USED)
;;;1194       {
;;;1195           RMP_Unlock_Sched();
;;;1196           return RMP_ERR_SEM;
;;;1197       }
;;;1198   
;;;1199       /* Get rid of all guys waiting on it */
;;;1200       while(&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)
;;;1201       {
;;;1202           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1203           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1204           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1205               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1206   
;;;1207           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1208   
;;;1209           /* Is it suspended? If yes, we can't directly send it running */
;;;1210           if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1211              _RMP_Set_Rdy(Thread);
;;;1212           
;;;1213           Thread->Retval=RMP_ERR_OPER;
;;;1214       }
;;;1215       Semaphore->State=RMP_SEM_FREE;
;;;1216       
;;;1217       RMP_Unlock_Sched();
;;;1218   
;;;1219       return 0;
;;;1220   }
00000a  bd70              POP      {r4-r6,pc}
                  |L14.12|
00000c  f7fffffe          BL       RMP_Lock_Sched
000010  68a8              LDR      r0,[r5,#8]            ;1193
000012  2801              CMP      r0,#1                 ;1193
000014  d004              BEQ      |L14.32|
000016  f7fffffe          BL       RMP_Unlock_Sched
00001a  f06f0005          MVN      r0,#5                 ;1196
00001e  e7f4              B        |L14.10|
                  |L14.32|
000020  e01a              B        |L14.88|
                  |L14.34|
000022  686c              LDR      r4,[r5,#4]            ;1202
000024  e9d40100          LDRD     r0,r1,[r4,#0]         ;1203
000028  f7fffffe          BL       RMP_List_Del
00002c  7e20              LDRB     r0,[r4,#0x18]         ;1204
00002e  2808              CMP      r0,#8                 ;1204
000030  d103              BNE      |L14.58|
000032  e9d40102          LDRD     r0,r1,[r4,#8]         ;1205
000036  f7fffffe          BL       RMP_List_Del
                  |L14.58|
00003a  69a0              LDR      r0,[r4,#0x18]         ;1207
00003c  f02000ff          BIC      r0,r0,#0xff           ;1207
000040  1c40              ADDS     r0,r0,#1              ;1207
000042  61a0              STR      r0,[r4,#0x18]         ;1207
000044  8b20              LDRH     r0,[r4,#0x18]         ;1210
000046  f4007080          AND      r0,r0,#0x100          ;1210
00004a  b910              CBNZ     r0,|L14.82|
00004c  4620              MOV      r0,r4                 ;1211
00004e  f7fffffe          BL       _RMP_Set_Rdy
                  |L14.82|
000052  f06f0004          MVN      r0,#4                 ;1213
000056  63a0              STR      r0,[r4,#0x38]         ;1213
                  |L14.88|
000058  6868              LDR      r0,[r5,#4]            ;1200
00005a  42a8              CMP      r0,r5                 ;1200
00005c  d1e1              BNE      |L14.34|
00005e  2000              MOVS     r0,#0                 ;1215
000060  60a8              STR      r0,[r5,#8]            ;1215
000062  f7fffffe          BL       RMP_Unlock_Sched
000066  2000              MOVS     r0,#0                 ;1219
000068  e7cf              B        |L14.10|
;;;1221   /* End Function:RMP_Sem_Del **************************************************/
                          ENDP


                          AREA ||i.RMP_Sem_Pend||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Pend PROC
;;;1229   ******************************************************************************/
;;;1230   ret_t RMP_Sem_Pend(struct RMP_Sem* Semaphore, ptr_t Slices)
000000  b570              PUSH     {r4-r6,lr}
;;;1231   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1232       /* Check if this semaphore structure could possibly be in use */
;;;1233       if(Semaphore==0)
000006  b914              CBNZ     r4,|L15.14|
;;;1234           return RMP_ERR_SEM;
000008  f06f0005          MVN      r0,#5
                  |L15.12|
;;;1235       
;;;1236       RMP_Lock_Sched();
;;;1237       
;;;1238       if(Semaphore->State!=RMP_SEM_USED)
;;;1239       {
;;;1240           RMP_Unlock_Sched();
;;;1241           return RMP_ERR_SEM;
;;;1242       }
;;;1243       
;;;1244       /* Check if we can get one immediately */
;;;1245       if(Semaphore->Cur_Num!=0)
;;;1246       {
;;;1247           Semaphore->Cur_Num--;
;;;1248           RMP_Unlock_Sched();
;;;1249           return Semaphore->Cur_Num;
;;;1250       }
;;;1251       else
;;;1252       {
;;;1253           /* Cannot get one, we need to block */
;;;1254           if(Slices==0)
;;;1255           {
;;;1256               RMP_Unlock_Sched();
;;;1257               return RMP_ERR_OPER;
;;;1258           }
;;;1259   
;;;1260           /* We must be running - place into waitlist now */
;;;1261           _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1262           RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Semaphore->Wait_List.Prev,&(Semaphore->Wait_List));
;;;1263           
;;;1264           if(Slices<RMP_MAX_SLICES)
;;;1265           {
;;;1266               _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1267               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMDLY);
;;;1268           }
;;;1269           else
;;;1270               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMBLK);
;;;1271           
;;;1272           RMP_Cur_Thd->Retval=0;
;;;1273       }
;;;1274       
;;;1275       RMP_Unlock_Sched();
;;;1276   
;;;1277       return RMP_Cur_Thd->Retval;
;;;1278   }
00000c  bd70              POP      {r4-r6,pc}
                  |L15.14|
00000e  f7fffffe          BL       RMP_Lock_Sched
000012  68a0              LDR      r0,[r4,#8]            ;1238
000014  2801              CMP      r0,#1                 ;1238
000016  d004              BEQ      |L15.34|
000018  f7fffffe          BL       RMP_Unlock_Sched
00001c  f06f0005          MVN      r0,#5                 ;1241
000020  e7f4              B        |L15.12|
                  |L15.34|
000022  68e0              LDR      r0,[r4,#0xc]          ;1245
000024  b130              CBZ      r0,|L15.52|
000026  68e0              LDR      r0,[r4,#0xc]          ;1247
000028  1e40              SUBS     r0,r0,#1              ;1247
00002a  60e0              STR      r0,[r4,#0xc]          ;1247
00002c  f7fffffe          BL       RMP_Unlock_Sched
000030  68e0              LDR      r0,[r4,#0xc]          ;1249
000032  e7eb              B        |L15.12|
                  |L15.52|
000034  b925              CBNZ     r5,|L15.64|
000036  f7fffffe          BL       RMP_Unlock_Sched
00003a  f06f0004          MVN      r0,#4                 ;1257
00003e  e7e5              B        |L15.12|
                  |L15.64|
000040  4817              LDR      r0,|L15.160|
000042  6800              LDR      r0,[r0,#0]            ;1261  ; RMP_Cur_Thd
000044  f7fffffe          BL       _RMP_Clr_Rdy
000048  4622              MOV      r2,r4                 ;1262
00004a  4815              LDR      r0,|L15.160|
00004c  6821              LDR      r1,[r4,#0]            ;1262
00004e  6800              LDR      r0,[r0,#0]            ;1262  ; RMP_Cur_Thd
000050  f7fffffe          BL       RMP_List_Ins
000054  4813              LDR      r0,|L15.164|
000056  4285              CMP      r5,r0                 ;1264
000058  d20f              BCS      |L15.122|
00005a  4629              MOV      r1,r5                 ;1266
00005c  4810              LDR      r0,|L15.160|
00005e  6800              LDR      r0,[r0,#0]            ;1266  ; RMP_Cur_Thd
000060  f7fffffe          BL       _RMP_Dly_Ins
000064  480e              LDR      r0,|L15.160|
000066  6800              LDR      r0,[r0,#0]            ;1267  ; RMP_Cur_Thd
000068  6980              LDR      r0,[r0,#0x18]         ;1267
00006a  f02000ff          BIC      r0,r0,#0xff           ;1267
00006e  f0400008          ORR      r0,r0,#8              ;1267
000072  490b              LDR      r1,|L15.160|
000074  6809              LDR      r1,[r1,#0]            ;1267  ; RMP_Cur_Thd
000076  6188              STR      r0,[r1,#0x18]         ;1267
000078  e008              B        |L15.140|
                  |L15.122|
00007a  4809              LDR      r0,|L15.160|
00007c  6800              LDR      r0,[r0,#0]            ;1270  ; RMP_Cur_Thd
00007e  6980              LDR      r0,[r0,#0x18]         ;1270
000080  f02000ff          BIC      r0,r0,#0xff           ;1270
000084  1dc0              ADDS     r0,r0,#7              ;1270
000086  4906              LDR      r1,|L15.160|
000088  6809              LDR      r1,[r1,#0]            ;1270  ; RMP_Cur_Thd
00008a  6188              STR      r0,[r1,#0x18]         ;1270
                  |L15.140|
00008c  2000              MOVS     r0,#0                 ;1272
00008e  4904              LDR      r1,|L15.160|
000090  6809              LDR      r1,[r1,#0]            ;1272  ; RMP_Cur_Thd
000092  6388              STR      r0,[r1,#0x38]         ;1272
000094  f7fffffe          BL       RMP_Unlock_Sched
000098  4801              LDR      r0,|L15.160|
00009a  6800              LDR      r0,[r0,#0]            ;1277  ; RMP_Cur_Thd
00009c  6b80              LDR      r0,[r0,#0x38]         ;1277
00009e  e7b5              B        |L15.12|
;;;1279   /* End Function:RMP_Sem_Pend *************************************************/
                          ENDP

                  |L15.160|
                          DCD      RMP_Cur_Thd
                  |L15.164|
                          DCD      0x000186a0

                          AREA ||i.RMP_Sem_Post||, CODE, READONLY, ALIGN=1

                  RMP_Sem_Post PROC
;;;1336   ******************************************************************************/
;;;1337   ret_t RMP_Sem_Post(struct RMP_Sem* Semaphore, ptr_t Number)
000000  b570              PUSH     {r4-r6,lr}
;;;1338   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;1339       struct RMP_Thd* Thread;
;;;1340       
;;;1341       /* Check if this semaphore structure could possibly be in use */
;;;1342       if((Semaphore==0)||(Number==0))
000006  b104              CBZ      r4,|L16.10|
000008  b916              CBNZ     r6,|L16.16|
                  |L16.10|
;;;1343           return RMP_ERR_SEM;
00000a  f06f0005          MVN      r0,#5
                  |L16.14|
;;;1344       
;;;1345       RMP_Lock_Sched();
;;;1346       
;;;1347       if(Semaphore->State!=RMP_SEM_USED)
;;;1348       {
;;;1349           RMP_Unlock_Sched();
;;;1350           return RMP_ERR_SEM;
;;;1351       }
;;;1352       
;;;1353       /* Would the maximum value be exceeded if this is posted? */
;;;1354       if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
;;;1355       {
;;;1356           RMP_Unlock_Sched();
;;;1357           return RMP_ERR_OPER;
;;;1358       }
;;;1359       
;;;1360       Semaphore->Cur_Num+=Number;
;;;1361       /* Is there any thread waiting on it? If there are, clean them up*/
;;;1362       while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
;;;1363       {
;;;1364           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1365           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1366           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1367               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1368           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1369   
;;;1370           /* Only when when this thread is not suspended do we change it back */
;;;1371           if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1372               _RMP_Set_Rdy(Thread);
;;;1373   
;;;1374           /* Finally, return success */
;;;1375           Thread->Retval=0;
;;;1376           Semaphore->Cur_Num--;
;;;1377       }
;;;1378   
;;;1379       RMP_Unlock_Sched();
;;;1380   
;;;1381       return 0;
;;;1382   }
00000e  bd70              POP      {r4-r6,pc}
                  |L16.16|
000010  f7fffffe          BL       RMP_Lock_Sched
000014  68a0              LDR      r0,[r4,#8]            ;1347
000016  2801              CMP      r0,#1                 ;1347
000018  d004              BEQ      |L16.36|
00001a  f7fffffe          BL       RMP_Unlock_Sched
00001e  f06f0005          MVN      r0,#5                 ;1350
000022  e7f4              B        |L16.14|
                  |L16.36|
000024  68e0              LDR      r0,[r4,#0xc]          ;1354
000026  4430              ADD      r0,r0,r6              ;1354
000028  f5b07f7a          CMP      r0,#0x3e8             ;1354
00002c  d304              BCC      |L16.56|
00002e  f7fffffe          BL       RMP_Unlock_Sched
000032  f06f0004          MVN      r0,#4                 ;1357
000036  e7ea              B        |L16.14|
                  |L16.56|
000038  68e0              LDR      r0,[r4,#0xc]          ;1360
00003a  4430              ADD      r0,r0,r6              ;1360
00003c  60e0              STR      r0,[r4,#0xc]          ;1360
00003e  e01c              B        |L16.122|
                  |L16.64|
000040  6865              LDR      r5,[r4,#4]            ;1364
000042  e9d50100          LDRD     r0,r1,[r5,#0]         ;1365
000046  f7fffffe          BL       RMP_List_Del
00004a  7e28              LDRB     r0,[r5,#0x18]         ;1366
00004c  2808              CMP      r0,#8                 ;1366
00004e  d103              BNE      |L16.88|
000050  e9d50102          LDRD     r0,r1,[r5,#8]         ;1367
000054  f7fffffe          BL       RMP_List_Del
                  |L16.88|
000058  69a8              LDR      r0,[r5,#0x18]         ;1368
00005a  f02000ff          BIC      r0,r0,#0xff           ;1368
00005e  1c40              ADDS     r0,r0,#1              ;1368
000060  61a8              STR      r0,[r5,#0x18]         ;1368
000062  8b28              LDRH     r0,[r5,#0x18]         ;1371
000064  f4007080          AND      r0,r0,#0x100          ;1371
000068  b910              CBNZ     r0,|L16.112|
00006a  4628              MOV      r0,r5                 ;1372
00006c  f7fffffe          BL       _RMP_Set_Rdy
                  |L16.112|
000070  2000              MOVS     r0,#0                 ;1375
000072  63a8              STR      r0,[r5,#0x38]         ;1375
000074  68e0              LDR      r0,[r4,#0xc]          ;1376
000076  1e40              SUBS     r0,r0,#1              ;1376
000078  60e0              STR      r0,[r4,#0xc]          ;1376
                  |L16.122|
00007a  6860              LDR      r0,[r4,#4]            ;1362
00007c  42a0              CMP      r0,r4                 ;1362
00007e  d002              BEQ      |L16.134|
000080  68e0              LDR      r0,[r4,#0xc]          ;1362
000082  2800              CMP      r0,#0                 ;1362
000084  d1dc              BNE      |L16.64|
                  |L16.134|
000086  f7fffffe          BL       RMP_Unlock_Sched
00008a  2000              MOVS     r0,#0                 ;1381
00008c  e7bf              B        |L16.14|
;;;1383   /* End Function:RMP_Sem_Post *************************************************/
                          ENDP


                          AREA ||i.RMP_Sem_Post_ISR||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Post_ISR PROC
;;;1391   ******************************************************************************/
;;;1392   ret_t RMP_Sem_Post_ISR(struct RMP_Sem* Semaphore, ptr_t Number)
000000  b570              PUSH     {r4-r6,lr}
;;;1393   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;1394       struct RMP_Thd* Thread;
;;;1395       /* Check if this semaphore structure could possibly be in use */
;;;1396       if((Semaphore==0)||(Number==0))
000006  b104              CBZ      r4,|L17.10|
000008  b916              CBNZ     r6,|L17.16|
                  |L17.10|
;;;1397           return RMP_ERR_SEM;
00000a  f06f0005          MVN      r0,#5
                  |L17.14|
;;;1398       
;;;1399       if(Semaphore->State!=RMP_SEM_USED)
;;;1400           return RMP_ERR_SEM;
;;;1401   
;;;1402       if(RMP_Sched_Locked!=0)
;;;1403           return RMP_ERR_OPER;
;;;1404   
;;;1405       /* Would the maximum value be exceeded if this is posted? */
;;;1406       if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
;;;1407           return RMP_ERR_OPER;
;;;1408       
;;;1409       Semaphore->Cur_Num+=Number;
;;;1410       /* Is there any thread waiting on it? If there are, clean them up*/
;;;1411       while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
;;;1412       {
;;;1413           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1414           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1415           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1416               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1417           
;;;1418           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1419   
;;;1420           /* Only when when this thread is not suspended do we change it back */
;;;1421           if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1422           {
;;;1423               _RMP_Set_Rdy(Thread);
;;;1424               if(Thread->Prio>RMP_Cur_Thd->Prio)
;;;1425                   _RMP_Yield();
;;;1426           }
;;;1427   
;;;1428           /* Finally, return success */
;;;1429           Thread->Retval=0;
;;;1430           Semaphore->Cur_Num--;
;;;1431       }
;;;1432   
;;;1433       return 0;
;;;1434   }
00000e  bd70              POP      {r4-r6,pc}
                  |L17.16|
000010  68a0              LDR      r0,[r4,#8]            ;1399
000012  2801              CMP      r0,#1                 ;1399
000014  d002              BEQ      |L17.28|
000016  f06f0005          MVN      r0,#5                 ;1400
00001a  e7f8              B        |L17.14|
                  |L17.28|
00001c  481f              LDR      r0,|L17.156|
00001e  6800              LDR      r0,[r0,#0]            ;1402  ; RMP_Sched_Locked
000020  b110              CBZ      r0,|L17.40|
000022  f06f0004          MVN      r0,#4                 ;1403
000026  e7f2              B        |L17.14|
                  |L17.40|
000028  68e0              LDR      r0,[r4,#0xc]          ;1406
00002a  4430              ADD      r0,r0,r6              ;1406
00002c  f5b07f7a          CMP      r0,#0x3e8             ;1406
000030  d302              BCC      |L17.56|
000032  f06f0004          MVN      r0,#4                 ;1407
000036  e7ea              B        |L17.14|
                  |L17.56|
000038  68e0              LDR      r0,[r4,#0xc]          ;1409
00003a  4430              ADD      r0,r0,r6              ;1409
00003c  60e0              STR      r0,[r4,#0xc]          ;1409
00003e  e024              B        |L17.138|
                  |L17.64|
000040  6865              LDR      r5,[r4,#4]            ;1413
000042  e9d50100          LDRD     r0,r1,[r5,#0]         ;1414
000046  f7fffffe          BL       RMP_List_Del
00004a  7e28              LDRB     r0,[r5,#0x18]         ;1415
00004c  2808              CMP      r0,#8                 ;1415
00004e  d103              BNE      |L17.88|
000050  e9d50102          LDRD     r0,r1,[r5,#8]         ;1416
000054  f7fffffe          BL       RMP_List_Del
                  |L17.88|
000058  69a8              LDR      r0,[r5,#0x18]         ;1418
00005a  f02000ff          BIC      r0,r0,#0xff           ;1418
00005e  1c40              ADDS     r0,r0,#1              ;1418
000060  61a8              STR      r0,[r5,#0x18]         ;1418
000062  8b28              LDRH     r0,[r5,#0x18]         ;1421
000064  f4007080          AND      r0,r0,#0x100          ;1421
000068  b950              CBNZ     r0,|L17.128|
00006a  4628              MOV      r0,r5                 ;1423
00006c  f7fffffe          BL       _RMP_Set_Rdy
000070  490b              LDR      r1,|L17.160|
000072  6a68              LDR      r0,[r5,#0x24]         ;1424
000074  6809              LDR      r1,[r1,#0]            ;1424  ; RMP_Cur_Thd
000076  6a49              LDR      r1,[r1,#0x24]         ;1424
000078  4288              CMP      r0,r1                 ;1424
00007a  d901              BLS      |L17.128|
00007c  f7fffffe          BL       _RMP_Yield
                  |L17.128|
000080  2000              MOVS     r0,#0                 ;1429
000082  63a8              STR      r0,[r5,#0x38]         ;1429
000084  68e0              LDR      r0,[r4,#0xc]          ;1430
000086  1e40              SUBS     r0,r0,#1              ;1430
000088  60e0              STR      r0,[r4,#0xc]          ;1430
                  |L17.138|
00008a  6860              LDR      r0,[r4,#4]            ;1411
00008c  42a0              CMP      r0,r4                 ;1411
00008e  d002              BEQ      |L17.150|
000090  68e0              LDR      r0,[r4,#0xc]          ;1411
000092  2800              CMP      r0,#0                 ;1411
000094  d1d4              BNE      |L17.64|
                  |L17.150|
000096  2000              MOVS     r0,#0                 ;1433
000098  e7b9              B        |L17.14|
;;;1435   /* End Function:RMP_Sem_Post_ISR *********************************************/
                          ENDP

00009a  0000              DCW      0x0000
                  |L17.156|
                          DCD      RMP_Sched_Locked
                  |L17.160|
                          DCD      RMP_Cur_Thd

                          AREA ||i.RMP_Start_Hook||, CODE, READONLY, ALIGN=1

                  RMP_Start_Hook PROC
;;;1444   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1445   void RMP_Start_Hook(void)
000000  4770              BX       lr
;;;1446   {
;;;1447       return;
;;;1448   }
;;;1449   #endif
                          ENDP


                          AREA ||i.RMP_Thd_Cancel||, CODE, READONLY, ALIGN=1

                  RMP_Thd_Cancel PROC
;;;1106   ******************************************************************************/
;;;1107   ret_t RMP_Thd_Cancel(struct RMP_Thd* Thread)
000000  b510              PUSH     {r4,lr}
;;;1108   {
000002  4604              MOV      r4,r0
;;;1109       /* Check if this thread structure could possibly be in use */
;;;1110       if(Thread==0)
000004  b914              CBNZ     r4,|L19.12|
;;;1111           return RMP_ERR_THD;
000006  f04f30ff          MOV      r0,#0xffffffff
                  |L19.10|
;;;1112       
;;;1113       RMP_Lock_Sched();
;;;1114       
;;;1115       /* Is it delayed? */
;;;1116       if(RMP_THD_STATE(Thread->State)!=RMP_THD_DELAYED)
;;;1117       {
;;;1118           RMP_Unlock_Sched();
;;;1119           return RMP_ERR_STATE;
;;;1120       }
;;;1121   
;;;1122       /* Delete it from the delay list */
;;;1123       RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1124       RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1125       
;;;1126       /* Only when when this thread is not suspended do we change it back */
;;;1127       if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1128           _RMP_Set_Rdy(Thread);
;;;1129       
;;;1130       Thread->Retval=RMP_ERR_OPER;
;;;1131       
;;;1132       RMP_Unlock_Sched();
;;;1133   
;;;1134       return 0;
;;;1135   }
00000a  bd10              POP      {r4,pc}
                  |L19.12|
00000c  f7fffffe          BL       RMP_Lock_Sched
000010  7e20              LDRB     r0,[r4,#0x18]         ;1116
000012  2806              CMP      r0,#6                 ;1116
000014  d004              BEQ      |L19.32|
000016  f7fffffe          BL       RMP_Unlock_Sched
00001a  f06f0003          MVN      r0,#3                 ;1119
00001e  e7f4              B        |L19.10|
                  |L19.32|
000020  e9d40102          LDRD     r0,r1,[r4,#8]         ;1123
000024  f7fffffe          BL       RMP_List_Del
000028  69a0              LDR      r0,[r4,#0x18]         ;1124
00002a  f02000ff          BIC      r0,r0,#0xff           ;1124
00002e  1c40              ADDS     r0,r0,#1              ;1124
000030  61a0              STR      r0,[r4,#0x18]         ;1124
000032  8b20              LDRH     r0,[r4,#0x18]         ;1127
000034  f4007080          AND      r0,r0,#0x100          ;1127
000038  b910              CBNZ     r0,|L19.64|
00003a  4620              MOV      r0,r4                 ;1128
00003c  f7fffffe          BL       _RMP_Set_Rdy
                  |L19.64|
000040  f06f0004          MVN      r0,#4                 ;1130
000044  63a0              STR      r0,[r4,#0x38]         ;1130
000046  f7fffffe          BL       RMP_Unlock_Sched
00004a  2000              MOVS     r0,#0                 ;1134
00004c  e7dd              B        |L19.10|
;;;1136   /* End Function:RMP_Thd_Cancel ***********************************************/
                          ENDP


                          AREA ||i.RMP_Thd_Crt||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Crt PROC
;;;587    ******************************************************************************/
;;;588    ret_t RMP_Thd_Crt(struct RMP_Thd* Thread, void* Entry, void* Stack, void* Arg, ptr_t Prio, ptr_t Slices)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;589    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
00000a  4698              MOV      r8,r3
00000c  e9dd9508          LDRD     r9,r5,[sp,#0x20]
;;;590        /* Check if the priority and timeslice range is correct */
;;;591        if(Prio>=RMP_MAX_PREEMPT_PRIO)
000010  f1b90f20          CMP      r9,#0x20
000014  d303              BCC      |L20.30|
;;;592            return RMP_ERR_PRIO;
000016  f06f0001          MVN      r0,#1
                  |L20.26|
;;;593        if((Slices==0)||(Slices>=RMP_MAX_SLICES))
;;;594            return RMP_ERR_SLICE;
;;;595        
;;;596        /* Check if this thread structure could possibly be in use */
;;;597        if(Thread==0)
;;;598            return RMP_ERR_THD;
;;;599        
;;;600        RMP_Lock_Sched();
;;;601        
;;;602        if(RMP_THD_STATE(Thread->State)!=RMP_THD_FREE)
;;;603        {
;;;604            RMP_Unlock_Sched();
;;;605            return RMP_ERR_THD;
;;;606        }
;;;607        
;;;608        /* Create the thread and insert it into the list */
;;;609        Thread->Prio=Prio;
;;;610        Thread->Slices=Slices;
;;;611        Thread->Slices_Left=Slices;
;;;612        Thread->Stack=(ptr_t)Stack;
;;;613        
;;;614        /* Initialize its stack and sending list */
;;;615        _RMP_Stack_Init((ptr_t)Entry, (ptr_t)Stack, (ptr_t)Arg);
;;;616        RMP_List_Crt(&(Thread->Snd_List));
;;;617        
;;;618        /* Notify the scheduler that we have created something new, also check locks */
;;;619        Thread->State=RMP_THD_RUNNING;
;;;620        _RMP_Set_Rdy(Thread);
;;;621        
;;;622        RMP_Unlock_Sched();
;;;623    
;;;624        return 0;
;;;625    }
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L20.30|
00001e  b115              CBZ      r5,|L20.38|
000020  4814              LDR      r0,|L20.116|
000022  4285              CMP      r5,r0                 ;593
000024  d302              BCC      |L20.44|
                  |L20.38|
000026  f06f0002          MVN      r0,#2                 ;594
00002a  e7f6              B        |L20.26|
                  |L20.44|
00002c  b914              CBNZ     r4,|L20.52|
00002e  f04f30ff          MOV      r0,#0xffffffff        ;598
000032  e7f2              B        |L20.26|
                  |L20.52|
000034  f7fffffe          BL       RMP_Lock_Sched
000038  7e20              LDRB     r0,[r4,#0x18]         ;602
00003a  b120              CBZ      r0,|L20.70|
00003c  f7fffffe          BL       RMP_Unlock_Sched
000040  f04f30ff          MOV      r0,#0xffffffff        ;605
000044  e7e9              B        |L20.26|
                  |L20.70|
000046  f8c49024          STR      r9,[r4,#0x24]         ;609
00004a  61e5              STR      r5,[r4,#0x1c]         ;610
00004c  6225              STR      r5,[r4,#0x20]         ;611
00004e  6366              STR      r6,[r4,#0x34]         ;612
000050  4642              MOV      r2,r8                 ;615
000052  4631              MOV      r1,r6                 ;615
000054  4638              MOV      r0,r7                 ;615
000056  f7fffffe          BL       _RMP_Stack_Init
00005a  f1040010          ADD      r0,r4,#0x10           ;616
00005e  f7fffffe          BL       RMP_List_Crt
000062  2001              MOVS     r0,#1                 ;619
000064  61a0              STR      r0,[r4,#0x18]         ;619
000066  4620              MOV      r0,r4                 ;620
000068  f7fffffe          BL       _RMP_Set_Rdy
00006c  f7fffffe          BL       RMP_Unlock_Sched
000070  2000              MOVS     r0,#0                 ;624
000072  e7d2              B        |L20.26|
;;;626    /* End Function:RMP_Thd_Crt **************************************************/
                          ENDP

                  |L20.116|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Del||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Del PROC
;;;633    ******************************************************************************/
;;;634    ret_t RMP_Thd_Del(struct RMP_Thd* Thread)
000000  b570              PUSH     {r4-r6,lr}
;;;635    {
000002  4604              MOV      r4,r0
;;;636        struct RMP_Thd* Release;
;;;637        ptr_t Self_Del;
;;;638        
;;;639        /* Check if this thread structure could possibly be in use */
;;;640        if(Thread==0)
000004  b914              CBNZ     r4,|L21.12|
;;;641            return RMP_ERR_THD;
000006  f04f30ff          MOV      r0,#0xffffffff
                  |L21.10|
;;;642        
;;;643        RMP_Lock_Sched();
;;;644        
;;;645        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;646        {
;;;647            RMP_Unlock_Sched();
;;;648            return RMP_ERR_THD;
;;;649        }
;;;650        
;;;651        /* See if anyone waiting to send to this thread. If there is, release all these threads */
;;;652        while(&(Thread->Snd_List)!=Thread->Snd_List.Next)
;;;653        {
;;;654            Release=(struct RMP_Thd*)(Thread->Snd_List.Next);
;;;655            RMP_List_Del(Release->Run_Head.Prev,Release->Run_Head.Next);
;;;656            if(RMP_THD_STATE(Release->State)==RMP_THD_SNDDLY)
;;;657                RMP_List_Del(Release->Dly_Head.Prev,Release->Dly_Head.Next);
;;;658    
;;;659            RMP_THD_STATE_SET(Release->State,RMP_THD_RUNNING);
;;;660    
;;;661            /* Is it suspended? If yes, we can't directly send it running */
;;;662            if((Release->State&RMP_THD_SUSPENDED)==0)
;;;663               _RMP_Set_Rdy(Release);
;;;664            
;;;665            Release->Retval=RMP_ERR_OPER;
;;;666        }
;;;667        
;;;668        /* See what is it state */
;;;669        Self_Del=0;
;;;670        if(RMP_Cur_Thd==Thread)
;;;671            Self_Del=1;
;;;672        
;;;673        switch(RMP_THD_STATE(Thread->State))
;;;674        {
;;;675            case RMP_THD_RUNNING:
;;;676            {
;;;677                if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;678                    _RMP_Clr_Rdy(Thread);
;;;679                break;
;;;680            }
;;;681            
;;;682            case RMP_THD_SNDDLY:
;;;683            case RMP_THD_SEMDLY:
;;;684            {
;;;685                if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;686                    RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;687                RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;688                Thread->Retval=RMP_ERR_OPER;
;;;689                break;
;;;690            }
;;;691                
;;;692            case RMP_THD_RCVDLY:
;;;693            {
;;;694                RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;695                Thread->Retval=RMP_ERR_OPER;
;;;696                break;
;;;697            }
;;;698                
;;;699            case RMP_THD_DELAYED:
;;;700            {
;;;701                RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;702                Thread->Retval=RMP_ERR_OPER;
;;;703                break;
;;;704            }
;;;705            /* Should not get here */
;;;706            default:break;
;;;707        }
;;;708        Thread->State=RMP_THD_FREE;
;;;709        
;;;710        RMP_Unlock_Sched();
;;;711        
;;;712        /* If we are deleting ourself, just stop the execution here */
;;;713        if(Self_Del!=0)
;;;714            while(1);
;;;715    
;;;716        return 0;
;;;717    }
00000a  bd70              POP      {r4-r6,pc}
                  |L21.12|
00000c  f7fffffe          BL       RMP_Lock_Sched
000010  7e20              LDRB     r0,[r4,#0x18]         ;645
000012  b920              CBNZ     r0,|L21.30|
000014  f7fffffe          BL       RMP_Unlock_Sched
000018  f04f30ff          MOV      r0,#0xffffffff        ;648
00001c  e7f5              B        |L21.10|
                  |L21.30|
00001e  e01a              B        |L21.86|
                  |L21.32|
000020  6965              LDR      r5,[r4,#0x14]         ;654
000022  e9d50100          LDRD     r0,r1,[r5,#0]         ;655
000026  f7fffffe          BL       RMP_List_Del
00002a  7e28              LDRB     r0,[r5,#0x18]         ;656
00002c  2803              CMP      r0,#3                 ;656
00002e  d103              BNE      |L21.56|
000030  e9d50102          LDRD     r0,r1,[r5,#8]         ;657
000034  f7fffffe          BL       RMP_List_Del
                  |L21.56|
000038  69a8              LDR      r0,[r5,#0x18]         ;659
00003a  f02000ff          BIC      r0,r0,#0xff           ;659
00003e  1c40              ADDS     r0,r0,#1              ;659
000040  61a8              STR      r0,[r5,#0x18]         ;659
000042  8b28              LDRH     r0,[r5,#0x18]         ;662
000044  f4007080          AND      r0,r0,#0x100          ;662
000048  b910              CBNZ     r0,|L21.80|
00004a  4628              MOV      r0,r5                 ;663
00004c  f7fffffe          BL       _RMP_Set_Rdy
                  |L21.80|
000050  f06f0004          MVN      r0,#4                 ;665
000054  63a8              STR      r0,[r5,#0x38]         ;665
                  |L21.86|
000056  f1040010          ADD      r0,r4,#0x10           ;652
00005a  6961              LDR      r1,[r4,#0x14]         ;652
00005c  4281              CMP      r1,r0                 ;652
00005e  d1df              BNE      |L21.32|
000060  2600              MOVS     r6,#0                 ;669
000062  4821              LDR      r0,|L21.232|
000064  6800              LDR      r0,[r0,#0]            ;670  ; RMP_Cur_Thd
000066  42a0              CMP      r0,r4                 ;670
000068  d100              BNE      |L21.108|
00006a  2601              MOVS     r6,#1                 ;671
                  |L21.108|
00006c  7e20              LDRB     r0,[r4,#0x18]         ;673
00006e  2809              CMP      r0,#9                 ;673
000070  d22f              BCS      |L21.210|
000072  e8dff000          TBB      [pc,r0]               ;673
000076  2e05              DCB      0x2e,0x05
000078  2e0d2e1e          DCB      0x2e,0x0d,0x2e,0x1e
00007c  262e0e00          DCB      0x26,0x2e,0x0e,0x00
000080  8b20              LDRH     r0,[r4,#0x18]         ;677
000082  f4007080          AND      r0,r0,#0x100          ;677
000086  b910              CBNZ     r0,|L21.142|
000088  4620              MOV      r0,r4                 ;678
00008a  f7fffffe          BL       _RMP_Clr_Rdy
                  |L21.142|
00008e  e021              B        |L21.212|
000090  bf00              NOP                            ;683
000092  8b20              LDRH     r0,[r4,#0x18]         ;685
000094  f4007080          AND      r0,r0,#0x100          ;685
000098  b918              CBNZ     r0,|L21.162|
00009a  e9d40100          LDRD     r0,r1,[r4,#0]         ;686
00009e  f7fffffe          BL       RMP_List_Del
                  |L21.162|
0000a2  e9d40102          LDRD     r0,r1,[r4,#8]         ;687
0000a6  f7fffffe          BL       RMP_List_Del
0000aa  f06f0004          MVN      r0,#4                 ;688
0000ae  63a0              STR      r0,[r4,#0x38]         ;688
0000b0  e010              B        |L21.212|
0000b2  e9d40102          LDRD     r0,r1,[r4,#8]         ;694
0000b6  f7fffffe          BL       RMP_List_Del
0000ba  f06f0004          MVN      r0,#4                 ;695
0000be  63a0              STR      r0,[r4,#0x38]         ;695
0000c0  e008              B        |L21.212|
0000c2  e9d40102          LDRD     r0,r1,[r4,#8]         ;701
0000c6  f7fffffe          BL       RMP_List_Del
0000ca  f06f0004          MVN      r0,#4                 ;702
0000ce  63a0              STR      r0,[r4,#0x38]         ;702
0000d0  e000              B        |L21.212|
                  |L21.210|
0000d2  bf00              NOP                            ;706
                  |L21.212|
0000d4  bf00              NOP                            ;679
0000d6  2000              MOVS     r0,#0                 ;708
0000d8  61a0              STR      r0,[r4,#0x18]         ;708
0000da  f7fffffe          BL       RMP_Unlock_Sched
0000de  b10e              CBZ      r6,|L21.228|
0000e0  bf00              NOP                            ;714
                  |L21.226|
0000e2  e7fe              B        |L21.226|
                  |L21.228|
0000e4  2000              MOVS     r0,#0                 ;716
0000e6  e790              B        |L21.10|
;;;718    /* End Function:RMP_Thd_Del **************************************************/
                          ENDP

                  |L21.232|
                          DCD      RMP_Cur_Thd

                          AREA ||i.RMP_Thd_Delay||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Delay PROC
;;;1079   ******************************************************************************/
;;;1080   ret_t RMP_Thd_Delay(ptr_t Slices)
000000  b510              PUSH     {r4,lr}
;;;1081   {
000002  4604              MOV      r4,r0
;;;1082       if((Slices==0)||(Slices>=RMP_MAX_SLICES))
000004  b114              CBZ      r4,|L22.12|
000006  4812              LDR      r0,|L22.80|
000008  4284              CMP      r4,r0
00000a  d302              BCC      |L22.18|
                  |L22.12|
;;;1083           return RMP_ERR_SLICE;
00000c  f06f0002          MVN      r0,#2
                  |L22.16|
;;;1084       
;;;1085       RMP_Lock_Sched();
;;;1086   
;;;1087       /* We must be running */
;;;1088       _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1089       RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_DELAYED);
;;;1090       _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1091   
;;;1092       RMP_Cur_Thd->Retval=0;
;;;1093       
;;;1094       RMP_Unlock_Sched();
;;;1095       
;;;1096       /* Need to return if successful or not */
;;;1097       return RMP_Cur_Thd->Retval;
;;;1098   }
000010  bd10              POP      {r4,pc}
                  |L22.18|
000012  f7fffffe          BL       RMP_Lock_Sched
000016  480f              LDR      r0,|L22.84|
000018  6800              LDR      r0,[r0,#0]            ;1088  ; RMP_Cur_Thd
00001a  f7fffffe          BL       _RMP_Clr_Rdy
00001e  480d              LDR      r0,|L22.84|
000020  6800              LDR      r0,[r0,#0]            ;1089  ; RMP_Cur_Thd
000022  6980              LDR      r0,[r0,#0x18]         ;1089
000024  f02000ff          BIC      r0,r0,#0xff           ;1089
000028  1d80              ADDS     r0,r0,#6              ;1089
00002a  490a              LDR      r1,|L22.84|
00002c  6809              LDR      r1,[r1,#0]            ;1089  ; RMP_Cur_Thd
00002e  6188              STR      r0,[r1,#0x18]         ;1089
000030  4621              MOV      r1,r4                 ;1090
000032  4808              LDR      r0,|L22.84|
000034  6800              LDR      r0,[r0,#0]            ;1090  ; RMP_Cur_Thd
000036  f7fffffe          BL       _RMP_Dly_Ins
00003a  2000              MOVS     r0,#0                 ;1092
00003c  4905              LDR      r1,|L22.84|
00003e  6809              LDR      r1,[r1,#0]            ;1092  ; RMP_Cur_Thd
000040  6388              STR      r0,[r1,#0x38]         ;1092
000042  f7fffffe          BL       RMP_Unlock_Sched
000046  4803              LDR      r0,|L22.84|
000048  6800              LDR      r0,[r0,#0]            ;1097  ; RMP_Cur_Thd
00004a  6b80              LDR      r0,[r0,#0x38]         ;1097
00004c  e7e0              B        |L22.16|
;;;1099   /* End Function:RMP_Thd_Delay ************************************************/
                          ENDP

00004e  0000              DCW      0x0000
                  |L22.80|
                          DCD      0x000186a0
                  |L22.84|
                          DCD      RMP_Cur_Thd

                          AREA ||i.RMP_Thd_Rcv||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Rcv PROC
;;;1001   ******************************************************************************/
;;;1002   ret_t RMP_Thd_Rcv(ptr_t* Data, ptr_t Slices)
000000  b570              PUSH     {r4-r6,lr}
;;;1003   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;1004       struct RMP_Thd* Sender;
;;;1005       
;;;1006       RMP_Lock_Sched();
000006  f7fffffe          BL       RMP_Lock_Sched
;;;1007   
;;;1008       /* Check if there is a value in our mailbox. If yes, we return with that value */
;;;1009       if((RMP_Cur_Thd->State&RMP_THD_MBOXFUL)!=0)
00000a  483b              LDR      r0,|L23.248|
00000c  6800              LDR      r0,[r0,#0]  ; RMP_Cur_Thd
00000e  8b00              LDRH     r0,[r0,#0x18]
000010  f4007000          AND      r0,r0,#0x200
000014  b178              CBZ      r0,|L23.54|
;;;1010       {
;;;1011           /* Get the value from mailbox */
;;;1012           *Data=RMP_Cur_Thd->Mailbox;
000016  4838              LDR      r0,|L23.248|
000018  6800              LDR      r0,[r0,#0]  ; RMP_Cur_Thd
00001a  6ac0              LDR      r0,[r0,#0x2c]
00001c  6028              STR      r0,[r5,#0]
;;;1013           RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
00001e  4836              LDR      r0,|L23.248|
000020  6800              LDR      r0,[r0,#0]  ; RMP_Cur_Thd
000022  6980              LDR      r0,[r0,#0x18]
000024  f4207000          BIC      r0,r0,#0x200
000028  4933              LDR      r1,|L23.248|
00002a  6809              LDR      r1,[r1,#0]  ; RMP_Cur_Thd
00002c  6188              STR      r0,[r1,#0x18]
;;;1014           RMP_Unlock_Sched();
00002e  f7fffffe          BL       RMP_Unlock_Sched
;;;1015           return 0;
000032  2000              MOVS     r0,#0
                  |L23.52|
;;;1016       }
;;;1017       else
;;;1018       {
;;;1019           /* Is there any other guy waiting on us? If there is, unblock it and set it running */
;;;1020           if(&(RMP_Cur_Thd->Snd_List)!=RMP_Cur_Thd->Snd_List.Next)
;;;1021           {
;;;1022               /* Read the data */
;;;1023               Sender=(struct RMP_Thd*)(Sender->Snd_List.Next);
;;;1024               *Data=Sender->Data;
;;;1025               
;;;1026               RMP_List_Del(Sender->Run_Head.Prev,Sender->Run_Head.Next);
;;;1027               /* Now we unblock it - what state is it in? */
;;;1028               if((RMP_THD_STATE(Sender->State)==RMP_THD_SNDDLY))
;;;1029                   RMP_List_Del(Sender->Dly_Head.Prev,Sender->Dly_Head.Next);
;;;1030               
;;;1031               RMP_THD_STATE_SET(Sender->State,RMP_THD_RUNNING);
;;;1032   
;;;1033               /* Is it suspended? If yes, we can't directly send it running */
;;;1034               if((Sender->State&RMP_THD_SUSPENDED)==0)
;;;1035                   _RMP_Set_Rdy(Sender);
;;;1036               
;;;1037               RMP_Unlock_Sched();
;;;1038           }
;;;1039           /* No sender waiting on us, we need to block */
;;;1040           else
;;;1041           {
;;;1042               /* No such value in our mailbox, we need to block */
;;;1043               if(Slices==0)
;;;1044               {
;;;1045                   RMP_Unlock_Sched();
;;;1046                   return RMP_ERR_OPER;
;;;1047               }
;;;1048   
;;;1049               /* We must be running */
;;;1050               _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1051   
;;;1052               if(Slices<RMP_MAX_SLICES)
;;;1053               {
;;;1054                   _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1055                   RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVDLY);
;;;1056               }
;;;1057               else
;;;1058                   RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVBLK);
;;;1059               
;;;1060               RMP_Unlock_Sched();
;;;1061               
;;;1062               /* We've been unblocked. There must be something in our mbox, or we should have failed */
;;;1063               RMP_Lock_Sched();
;;;1064               *Data=RMP_Cur_Thd->Mailbox;
;;;1065               RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
;;;1066               RMP_Unlock_Sched();
;;;1067           }
;;;1068       }
;;;1069       
;;;1070       return RMP_Cur_Thd->Retval;
;;;1071   }
000034  bd70              POP      {r4-r6,pc}
                  |L23.54|
000036  4830              LDR      r0,|L23.248|
000038  6800              LDR      r0,[r0,#0]            ;1020  ; RMP_Cur_Thd
00003a  6941              LDR      r1,[r0,#0x14]         ;1020
00003c  482e              LDR      r0,|L23.248|
00003e  6800              LDR      r0,[r0,#0]            ;1020  ; RMP_Cur_Thd
000040  3010              ADDS     r0,r0,#0x10           ;1020
000042  4281              CMP      r1,r0                 ;1020
000044  d01c              BEQ      |L23.128|
000046  6964              LDR      r4,[r4,#0x14]         ;1023
000048  6b20              LDR      r0,[r4,#0x30]         ;1024
00004a  6028              STR      r0,[r5,#0]            ;1024
00004c  e9d40100          LDRD     r0,r1,[r4,#0]         ;1026
000050  f7fffffe          BL       RMP_List_Del
000054  7e20              LDRB     r0,[r4,#0x18]         ;1028
000056  2803              CMP      r0,#3                 ;1028
000058  d103              BNE      |L23.98|
00005a  e9d40102          LDRD     r0,r1,[r4,#8]         ;1029
00005e  f7fffffe          BL       RMP_List_Del
                  |L23.98|
000062  69a0              LDR      r0,[r4,#0x18]         ;1031
000064  f02000ff          BIC      r0,r0,#0xff           ;1031
000068  1c40              ADDS     r0,r0,#1              ;1031
00006a  61a0              STR      r0,[r4,#0x18]         ;1031
00006c  8b20              LDRH     r0,[r4,#0x18]         ;1034
00006e  f4007080          AND      r0,r0,#0x100          ;1034
000072  b910              CBNZ     r0,|L23.122|
000074  4620              MOV      r0,r4                 ;1035
000076  f7fffffe          BL       _RMP_Set_Rdy
                  |L23.122|
00007a  f7fffffe          BL       RMP_Unlock_Sched
00007e  e036              B        |L23.238|
                  |L23.128|
000080  b926              CBNZ     r6,|L23.140|
000082  f7fffffe          BL       RMP_Unlock_Sched
000086  f06f0004          MVN      r0,#4                 ;1046
00008a  e7d3              B        |L23.52|
                  |L23.140|
00008c  481a              LDR      r0,|L23.248|
00008e  6800              LDR      r0,[r0,#0]            ;1050  ; RMP_Cur_Thd
000090  f7fffffe          BL       _RMP_Clr_Rdy
000094  4819              LDR      r0,|L23.252|
000096  4286              CMP      r6,r0                 ;1052
000098  d20e              BCS      |L23.184|
00009a  4631              MOV      r1,r6                 ;1054
00009c  4816              LDR      r0,|L23.248|
00009e  6800              LDR      r0,[r0,#0]            ;1054  ; RMP_Cur_Thd
0000a0  f7fffffe          BL       _RMP_Dly_Ins
0000a4  4814              LDR      r0,|L23.248|
0000a6  6800              LDR      r0,[r0,#0]            ;1055  ; RMP_Cur_Thd
0000a8  6980              LDR      r0,[r0,#0x18]         ;1055
0000aa  f02000ff          BIC      r0,r0,#0xff           ;1055
0000ae  1d40              ADDS     r0,r0,#5              ;1055
0000b0  4911              LDR      r1,|L23.248|
0000b2  6809              LDR      r1,[r1,#0]            ;1055  ; RMP_Cur_Thd
0000b4  6188              STR      r0,[r1,#0x18]         ;1055
0000b6  e008              B        |L23.202|
                  |L23.184|
0000b8  480f              LDR      r0,|L23.248|
0000ba  6800              LDR      r0,[r0,#0]            ;1058  ; RMP_Cur_Thd
0000bc  6980              LDR      r0,[r0,#0x18]         ;1058
0000be  f02000ff          BIC      r0,r0,#0xff           ;1058
0000c2  1d00              ADDS     r0,r0,#4              ;1058
0000c4  490c              LDR      r1,|L23.248|
0000c6  6809              LDR      r1,[r1,#0]            ;1058  ; RMP_Cur_Thd
0000c8  6188              STR      r0,[r1,#0x18]         ;1058
                  |L23.202|
0000ca  f7fffffe          BL       RMP_Unlock_Sched
0000ce  f7fffffe          BL       RMP_Lock_Sched
0000d2  4809              LDR      r0,|L23.248|
0000d4  6800              LDR      r0,[r0,#0]            ;1064  ; RMP_Cur_Thd
0000d6  6ac0              LDR      r0,[r0,#0x2c]         ;1064
0000d8  6028              STR      r0,[r5,#0]            ;1064
0000da  4807              LDR      r0,|L23.248|
0000dc  6800              LDR      r0,[r0,#0]            ;1065  ; RMP_Cur_Thd
0000de  6980              LDR      r0,[r0,#0x18]         ;1065
0000e0  f4207000          BIC      r0,r0,#0x200          ;1065
0000e4  4904              LDR      r1,|L23.248|
0000e6  6809              LDR      r1,[r1,#0]            ;1065  ; RMP_Cur_Thd
0000e8  6188              STR      r0,[r1,#0x18]         ;1065
0000ea  f7fffffe          BL       RMP_Unlock_Sched
                  |L23.238|
0000ee  4802              LDR      r0,|L23.248|
0000f0  6800              LDR      r0,[r0,#0]            ;1070  ; RMP_Cur_Thd
0000f2  6b80              LDR      r0,[r0,#0x38]         ;1070
0000f4  e79e              B        |L23.52|
;;;1072   /* End Function:RMP_Thd_Rcv **************************************************/
                          ENDP

0000f6  0000              DCW      0x0000
                  |L23.248|
                          DCD      RMP_Cur_Thd
                  |L23.252|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Resume||, CODE, READONLY, ALIGN=1

                  RMP_Thd_Resume PROC
;;;823    ******************************************************************************/
;;;824    ret_t RMP_Thd_Resume(struct RMP_Thd* Thread)
000000  b570              PUSH     {r4-r6,lr}
;;;825    {
000002  4604              MOV      r4,r0
;;;826        ret_t Retval;
;;;827        
;;;828        /* Check if this thread structure could possibly be in use */
;;;829        if(Thread==0)
000004  b914              CBNZ     r4,|L24.12|
;;;830            return RMP_ERR_THD;
000006  f04f30ff          MOV      r0,#0xffffffff
                  |L24.10|
;;;831    
;;;832        RMP_Lock_Sched();
;;;833        
;;;834        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;835        {
;;;836            RMP_Unlock_Sched();
;;;837            return RMP_ERR_THD;
;;;838        }
;;;839        
;;;840        /* Check if the thread is suspended, if not, then throw an error */
;;;841        if((Thread->State&RMP_THD_SUSPENDED)!=0)
;;;842        {
;;;843            /* Suspended */
;;;844            Thread->State&=~RMP_THD_SUSPENDED;
;;;845            if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;846                _RMP_Set_Rdy(Thread);
;;;847            Retval=0;
;;;848        }
;;;849        else
;;;850            Retval=RMP_ERR_STATE;
;;;851        
;;;852        RMP_Unlock_Sched();
;;;853    
;;;854        return Retval;
;;;855    }
00000a  bd70              POP      {r4-r6,pc}
                  |L24.12|
00000c  f7fffffe          BL       RMP_Lock_Sched
000010  7e20              LDRB     r0,[r4,#0x18]         ;834
000012  b920              CBNZ     r0,|L24.30|
000014  f7fffffe          BL       RMP_Unlock_Sched
000018  f04f30ff          MOV      r0,#0xffffffff        ;837
00001c  e7f5              B        |L24.10|
                  |L24.30|
00001e  8b20              LDRH     r0,[r4,#0x18]         ;841
000020  f4007080          AND      r0,r0,#0x100          ;841
000024  b158              CBZ      r0,|L24.62|
000026  69a0              LDR      r0,[r4,#0x18]         ;844
000028  f4207080          BIC      r0,r0,#0x100          ;844
00002c  61a0              STR      r0,[r4,#0x18]         ;844
00002e  7e20              LDRB     r0,[r4,#0x18]         ;845
000030  2801              CMP      r0,#1                 ;845
000032  d102              BNE      |L24.58|
000034  4620              MOV      r0,r4                 ;846
000036  f7fffffe          BL       _RMP_Set_Rdy
                  |L24.58|
00003a  2500              MOVS     r5,#0                 ;847
00003c  e001              B        |L24.66|
                  |L24.62|
00003e  f06f0503          MVN      r5,#3                 ;850
                  |L24.66|
000042  f7fffffe          BL       RMP_Unlock_Sched
000046  4628              MOV      r0,r5                 ;854
000048  e7df              B        |L24.10|
;;;856    /* End Function:RMP_Thd_Resume ***********************************************/
                          ENDP


                          AREA ||i.RMP_Thd_Set||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Set PROC
;;;729    ******************************************************************************/
;;;730    ret_t RMP_Thd_Set(struct RMP_Thd* Thread, ptr_t Prio, ptr_t Slices)
000000  b570              PUSH     {r4-r6,lr}
;;;731    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;732        /* Check if the priority and timeslice range is correct */
;;;733        if(Slices==0)
000008  b915              CBNZ     r5,|L25.16|
;;;734            return RMP_ERR_SLICE;
00000a  f06f0002          MVN      r0,#2
                  |L25.14|
;;;735        
;;;736        /* Check if this thread structure could possibly be in use */
;;;737        if(Thread==0)
;;;738            return RMP_ERR_THD;
;;;739        
;;;740        RMP_Lock_Sched();
;;;741        
;;;742        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;743        {
;;;744            RMP_Unlock_Sched();
;;;745            return RMP_ERR_THD;
;;;746        }
;;;747        
;;;748        /* See if the thread is in running state */
;;;749        if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;750        {
;;;751            /* See if we are gonna change one of it or both */
;;;752            if(Prio<RMP_MAX_PREEMPT_PRIO)
;;;753            {
;;;754                if(Thread->Prio!=Prio)
;;;755                {
;;;756                    _RMP_Clr_Rdy(Thread);
;;;757                    Thread->Prio=Prio;
;;;758                    _RMP_Set_Rdy(Thread);
;;;759                }
;;;760            }
;;;761            
;;;762            if(Slices<RMP_MAX_SLICES)
;;;763                Thread->Slices=Slices;
;;;764        }
;;;765        else
;;;766        {
;;;767            if(Prio<RMP_MAX_PREEMPT_PRIO)
;;;768                Thread->Prio=Prio;
;;;769            
;;;770            if(Slices<RMP_MAX_SLICES)
;;;771                Thread->Slices=Slices;
;;;772        }
;;;773        
;;;774        RMP_Unlock_Sched();
;;;775        
;;;776        return 0;
;;;777    }
00000e  bd70              POP      {r4-r6,pc}
                  |L25.16|
000010  b914              CBNZ     r4,|L25.24|
000012  f04f30ff          MOV      r0,#0xffffffff        ;738
000016  e7fa              B        |L25.14|
                  |L25.24|
000018  f7fffffe          BL       RMP_Lock_Sched
00001c  7e20              LDRB     r0,[r4,#0x18]         ;742
00001e  b920              CBNZ     r0,|L25.42|
000020  f7fffffe          BL       RMP_Unlock_Sched
000024  f04f30ff          MOV      r0,#0xffffffff        ;745
000028  e7f1              B        |L25.14|
                  |L25.42|
00002a  7e20              LDRB     r0,[r4,#0x18]         ;749
00002c  2801              CMP      r0,#1                 ;749
00002e  d110              BNE      |L25.82|
000030  2e20              CMP      r6,#0x20              ;752
000032  d209              BCS      |L25.72|
000034  6a60              LDR      r0,[r4,#0x24]         ;754
000036  42b0              CMP      r0,r6                 ;754
000038  d006              BEQ      |L25.72|
00003a  4620              MOV      r0,r4                 ;756
00003c  f7fffffe          BL       _RMP_Clr_Rdy
000040  6266              STR      r6,[r4,#0x24]         ;757
000042  4620              MOV      r0,r4                 ;758
000044  f7fffffe          BL       _RMP_Set_Rdy
                  |L25.72|
000048  4807              LDR      r0,|L25.104|
00004a  4285              CMP      r5,r0                 ;762
00004c  d208              BCS      |L25.96|
00004e  61e5              STR      r5,[r4,#0x1c]         ;763
000050  e006              B        |L25.96|
                  |L25.82|
000052  2e20              CMP      r6,#0x20              ;767
000054  d200              BCS      |L25.88|
000056  6266              STR      r6,[r4,#0x24]         ;768
                  |L25.88|
000058  4803              LDR      r0,|L25.104|
00005a  4285              CMP      r5,r0                 ;770
00005c  d200              BCS      |L25.96|
00005e  61e5              STR      r5,[r4,#0x1c]         ;771
                  |L25.96|
000060  f7fffffe          BL       RMP_Unlock_Sched
000064  2000              MOVS     r0,#0                 ;776
000066  e7d2              B        |L25.14|
;;;778    /* End Function:RMP_Thd_Set **************************************************/
                          ENDP

                  |L25.104|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Snd||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Snd PROC
;;;866    ******************************************************************************/
;;;867    ret_t RMP_Thd_Snd(struct RMP_Thd* Thread, ptr_t Data, ptr_t Slices)
000000  b570              PUSH     {r4-r6,lr}
;;;868    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;869        /* Check if this thread structure could possibly be in use */
;;;870        if(Thread==0)
000008  b914              CBNZ     r4,|L26.16|
;;;871            return RMP_ERR_THD;
00000a  f04f30ff          MOV      r0,#0xffffffff
                  |L26.14|
;;;872        
;;;873        RMP_Lock_Sched();
;;;874        
;;;875        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;876        {
;;;877            RMP_Unlock_Sched();
;;;878            return RMP_ERR_THD;
;;;879        }
;;;880        
;;;881        /* Are we sending to ourself? This is not allowed */
;;;882        if(RMP_Cur_Thd==Thread)
;;;883        {
;;;884            RMP_Unlock_Sched();
;;;885            return RMP_ERR_OPER;
;;;886        }
;;;887        
;;;888        RMP_Cur_Thd->Retval=0;
;;;889    
;;;890        /* See if there are already a value in the mailbox, if there is, we block */
;;;891        if((Thread->State&RMP_THD_MBOXFUL)!=0)
;;;892        {
;;;893            /* Mailbox full, we block, and put ourself into the queue */
;;;894            if(Slices==0)
;;;895            {
;;;896                RMP_Unlock_Sched();
;;;897                return RMP_ERR_OPER;
;;;898            }
;;;899    
;;;900            /* We must be running */
;;;901            _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;902            RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Thread->Snd_List.Prev,&(Thread->Snd_List));
;;;903    
;;;904            if(Slices<RMP_MAX_SLICES)
;;;905            {
;;;906                _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;907                RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDDLY);
;;;908            }
;;;909            else
;;;910                RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDBLK);
;;;911    
;;;912            RMP_Cur_Thd->Data=Data;
;;;913        }
;;;914        else
;;;915        {
;;;916            /* Mailbox not full. We need to check if the receiver is waiting for us */
;;;917            if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
;;;918               (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
;;;919            {
;;;920                /* The receiver is blocked, wake it up and return the value */
;;;921                if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
;;;922                    RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;923                
;;;924                RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;925    
;;;926                /* Is it suspended? If yes, we can't directly send it running */
;;;927                if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;928                    _RMP_Set_Rdy(Thread);
;;;929            }
;;;930            
;;;931            /* Set the mailbox */
;;;932            Thread->Mailbox=Data;
;;;933            Thread->State|=RMP_THD_MBOXFUL;
;;;934        }
;;;935        
;;;936        RMP_Unlock_Sched();
;;;937    
;;;938        return RMP_Cur_Thd->Retval;
;;;939    }
00000e  bd70              POP      {r4-r6,pc}
                  |L26.16|
000010  f7fffffe          BL       RMP_Lock_Sched
000014  7e20              LDRB     r0,[r4,#0x18]         ;875
000016  b920              CBNZ     r0,|L26.34|
000018  f7fffffe          BL       RMP_Unlock_Sched
00001c  f04f30ff          MOV      r0,#0xffffffff        ;878
000020  e7f5              B        |L26.14|
                  |L26.34|
000022  4833              LDR      r0,|L26.240|
000024  6800              LDR      r0,[r0,#0]            ;882  ; RMP_Cur_Thd
000026  42a0              CMP      r0,r4                 ;882
000028  d104              BNE      |L26.52|
00002a  f7fffffe          BL       RMP_Unlock_Sched
00002e  f06f0004          MVN      r0,#4                 ;885
000032  e7ec              B        |L26.14|
                  |L26.52|
000034  2000              MOVS     r0,#0                 ;888
000036  492e              LDR      r1,|L26.240|
000038  6809              LDR      r1,[r1,#0]            ;888  ; RMP_Cur_Thd
00003a  6388              STR      r0,[r1,#0x38]         ;888
00003c  8b20              LDRH     r0,[r4,#0x18]         ;891
00003e  f4007000          AND      r0,r0,#0x200          ;891
000042  b378              CBZ      r0,|L26.164|
000044  b925              CBNZ     r5,|L26.80|
000046  f7fffffe          BL       RMP_Unlock_Sched
00004a  f06f0004          MVN      r0,#4                 ;897
00004e  e7de              B        |L26.14|
                  |L26.80|
000050  4827              LDR      r0,|L26.240|
000052  6800              LDR      r0,[r0,#0]            ;901  ; RMP_Cur_Thd
000054  f7fffffe          BL       _RMP_Clr_Rdy
000058  f1040210          ADD      r2,r4,#0x10           ;902
00005c  4824              LDR      r0,|L26.240|
00005e  6921              LDR      r1,[r4,#0x10]         ;902
000060  6800              LDR      r0,[r0,#0]            ;902  ; RMP_Cur_Thd
000062  f7fffffe          BL       RMP_List_Ins
000066  4823              LDR      r0,|L26.244|
000068  4285              CMP      r5,r0                 ;904
00006a  d20e              BCS      |L26.138|
00006c  4629              MOV      r1,r5                 ;906
00006e  4820              LDR      r0,|L26.240|
000070  6800              LDR      r0,[r0,#0]            ;906  ; RMP_Cur_Thd
000072  f7fffffe          BL       _RMP_Dly_Ins
000076  481e              LDR      r0,|L26.240|
000078  6800              LDR      r0,[r0,#0]            ;907  ; RMP_Cur_Thd
00007a  6980              LDR      r0,[r0,#0x18]         ;907
00007c  f02000ff          BIC      r0,r0,#0xff           ;907
000080  1cc0              ADDS     r0,r0,#3              ;907
000082  491b              LDR      r1,|L26.240|
000084  6809              LDR      r1,[r1,#0]            ;907  ; RMP_Cur_Thd
000086  6188              STR      r0,[r1,#0x18]         ;907
000088  e008              B        |L26.156|
                  |L26.138|
00008a  4819              LDR      r0,|L26.240|
00008c  6800              LDR      r0,[r0,#0]            ;910  ; RMP_Cur_Thd
00008e  6980              LDR      r0,[r0,#0x18]         ;910
000090  f02000ff          BIC      r0,r0,#0xff           ;910
000094  1c80              ADDS     r0,r0,#2              ;910
000096  4916              LDR      r1,|L26.240|
000098  6809              LDR      r1,[r1,#0]            ;910  ; RMP_Cur_Thd
00009a  6188              STR      r0,[r1,#0x18]         ;910
                  |L26.156|
00009c  4814              LDR      r0,|L26.240|
00009e  6800              LDR      r0,[r0,#0]            ;912  ; RMP_Cur_Thd
0000a0  6306              STR      r6,[r0,#0x30]         ;912
0000a2  e01e              B        |L26.226|
                  |L26.164|
0000a4  e7ff              B        |L26.166|
                  |L26.166|
0000a6  7e20              LDRB     r0,[r4,#0x18]         ;917
0000a8  2804              CMP      r0,#4                 ;917
0000aa  d002              BEQ      |L26.178|
0000ac  7e20              LDRB     r0,[r4,#0x18]         ;918
0000ae  2805              CMP      r0,#5                 ;918
0000b0  d112              BNE      |L26.216|
                  |L26.178|
0000b2  7e20              LDRB     r0,[r4,#0x18]         ;921
0000b4  2805              CMP      r0,#5                 ;921
0000b6  d103              BNE      |L26.192|
0000b8  e9d40102          LDRD     r0,r1,[r4,#8]         ;922
0000bc  f7fffffe          BL       RMP_List_Del
                  |L26.192|
0000c0  69a0              LDR      r0,[r4,#0x18]         ;924
0000c2  f02000ff          BIC      r0,r0,#0xff           ;924
0000c6  1c40              ADDS     r0,r0,#1              ;924
0000c8  61a0              STR      r0,[r4,#0x18]         ;924
0000ca  8b20              LDRH     r0,[r4,#0x18]         ;927
0000cc  f4007080          AND      r0,r0,#0x100          ;927
0000d0  b910              CBNZ     r0,|L26.216|
0000d2  4620              MOV      r0,r4                 ;928
0000d4  f7fffffe          BL       _RMP_Set_Rdy
                  |L26.216|
0000d8  62e6              STR      r6,[r4,#0x2c]         ;932
0000da  69a0              LDR      r0,[r4,#0x18]         ;933
0000dc  f4407000          ORR      r0,r0,#0x200          ;933
0000e0  61a0              STR      r0,[r4,#0x18]         ;933
                  |L26.226|
0000e2  f7fffffe          BL       RMP_Unlock_Sched
0000e6  4802              LDR      r0,|L26.240|
0000e8  6800              LDR      r0,[r0,#0]            ;938  ; RMP_Cur_Thd
0000ea  6b80              LDR      r0,[r0,#0x38]         ;938
0000ec  e78f              B        |L26.14|
;;;940    /* End Function:RMP_Thd_Snd **************************************************/
                          ENDP

0000ee  0000              DCW      0x0000
                  |L26.240|
                          DCD      RMP_Cur_Thd
                  |L26.244|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Snd_ISR||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Snd_ISR PROC
;;;950    ******************************************************************************/
;;;951    ret_t RMP_Thd_Snd_ISR(struct RMP_Thd* Thread, ptr_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;952    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;953        /* Check if this thread structure could possibly be in use */
;;;954        if(Thread==0)
000006  b914              CBNZ     r4,|L27.14|
;;;955            return RMP_ERR_THD;
000008  f04f30ff          MOV      r0,#0xffffffff
                  |L27.12|
;;;956        
;;;957        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;958            return RMP_ERR_THD;
;;;959        
;;;960        if(RMP_Sched_Locked!=0)
;;;961            return RMP_ERR_OPER;
;;;962    
;;;963        /* See if there are already a value in the mailbox, if there is, we abort */
;;;964        if((Thread->State&RMP_THD_MBOXFUL)!=0)
;;;965            return RMP_ERR_OPER;
;;;966        else
;;;967        {
;;;968            /* Mailbox not full. We need to check if the receiver is waiting for us */
;;;969            if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
;;;970               (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
;;;971            {
;;;972                /* The receiver is blocked, wake it up and return the value */
;;;973                if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
;;;974                    RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;975                
;;;976                RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;977    
;;;978                /* Is it suspended? If yes, we can't directly send it running */
;;;979                if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;980                {
;;;981                    _RMP_Set_Rdy(Thread);
;;;982                    if(Thread->Prio>RMP_Cur_Thd->Prio)
;;;983                        _RMP_Yield();
;;;984                }
;;;985            }
;;;986            
;;;987            /* Set the mailbox */
;;;988            Thread->Mailbox=Data;
;;;989            Thread->State|=RMP_THD_MBOXFUL;
;;;990        }
;;;991    
;;;992        return 0;
;;;993    }
00000c  bd70              POP      {r4-r6,pc}
                  |L27.14|
00000e  7e20              LDRB     r0,[r4,#0x18]         ;957
000010  b910              CBNZ     r0,|L27.24|
000012  f04f30ff          MOV      r0,#0xffffffff        ;958
000016  e7f9              B        |L27.12|
                  |L27.24|
000018  481a              LDR      r0,|L27.132|
00001a  6800              LDR      r0,[r0,#0]            ;960  ; RMP_Sched_Locked
00001c  b110              CBZ      r0,|L27.36|
00001e  f06f0004          MVN      r0,#4                 ;961
000022  e7f3              B        |L27.12|
                  |L27.36|
000024  8b20              LDRH     r0,[r4,#0x18]         ;964
000026  f4007000          AND      r0,r0,#0x200          ;964
00002a  b110              CBZ      r0,|L27.50|
00002c  f06f0004          MVN      r0,#4                 ;965
000030  e7ec              B        |L27.12|
                  |L27.50|
000032  7e20              LDRB     r0,[r4,#0x18]         ;969
000034  2804              CMP      r0,#4                 ;969
000036  d002              BEQ      |L27.62|
000038  7e20              LDRB     r0,[r4,#0x18]         ;970
00003a  2805              CMP      r0,#5                 ;970
00003c  d11a              BNE      |L27.116|
                  |L27.62|
00003e  7e20              LDRB     r0,[r4,#0x18]         ;973
000040  2805              CMP      r0,#5                 ;973
000042  d103              BNE      |L27.76|
000044  e9d40102          LDRD     r0,r1,[r4,#8]         ;974
000048  f7fffffe          BL       RMP_List_Del
                  |L27.76|
00004c  69a0              LDR      r0,[r4,#0x18]         ;976
00004e  f02000ff          BIC      r0,r0,#0xff           ;976
000052  1c40              ADDS     r0,r0,#1              ;976
000054  61a0              STR      r0,[r4,#0x18]         ;976
000056  8b20              LDRH     r0,[r4,#0x18]         ;979
000058  f4007080          AND      r0,r0,#0x100          ;979
00005c  b950              CBNZ     r0,|L27.116|
00005e  4620              MOV      r0,r4                 ;981
000060  f7fffffe          BL       _RMP_Set_Rdy
000064  4908              LDR      r1,|L27.136|
000066  6a60              LDR      r0,[r4,#0x24]         ;982
000068  6809              LDR      r1,[r1,#0]            ;982  ; RMP_Cur_Thd
00006a  6a49              LDR      r1,[r1,#0x24]         ;982
00006c  4288              CMP      r0,r1                 ;982
00006e  d901              BLS      |L27.116|
000070  f7fffffe          BL       _RMP_Yield
                  |L27.116|
000074  62e5              STR      r5,[r4,#0x2c]         ;988
000076  69a0              LDR      r0,[r4,#0x18]         ;989
000078  f4407000          ORR      r0,r0,#0x200          ;989
00007c  61a0              STR      r0,[r4,#0x18]         ;989
00007e  2000              MOVS     r0,#0                 ;992
000080  e7c4              B        |L27.12|
;;;994    /* End Function:RMP_Thd_Snd_ISR **********************************************/
                          ENDP

000082  0000              DCW      0x0000
                  |L27.132|
                          DCD      RMP_Sched_Locked
                  |L27.136|
                          DCD      RMP_Cur_Thd

                          AREA ||i.RMP_Thd_Suspend||, CODE, READONLY, ALIGN=1

                  RMP_Thd_Suspend PROC
;;;785    ******************************************************************************/
;;;786    ret_t RMP_Thd_Suspend(struct RMP_Thd* Thread)
000000  b510              PUSH     {r4,lr}
;;;787    {
000002  4604              MOV      r4,r0
;;;788        /* Check if this thread structure could possibly be in use */
;;;789        if(Thread==0)
000004  b914              CBNZ     r4,|L28.12|
;;;790            return RMP_ERR_THD;
000006  f04f30ff          MOV      r0,#0xffffffff
                  |L28.10|
;;;791        
;;;792        RMP_Lock_Sched();
;;;793        
;;;794        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;795        {
;;;796            RMP_Unlock_Sched();
;;;797            return RMP_ERR_THD;
;;;798        }
;;;799        
;;;800        /* Suspend it */
;;;801        if((Thread->State&RMP_THD_SUSPENDED)!=0)
;;;802        {
;;;803            RMP_Unlock_Sched();
;;;804            return RMP_ERR_STATE;
;;;805        }
;;;806        /* Mark this as suspended */
;;;807        Thread->State|=RMP_THD_SUSPENDED;
;;;808        /* Only when it is running do we clear this */
;;;809        if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;810            _RMP_Clr_Rdy(Thread);
;;;811        
;;;812        RMP_Unlock_Sched();
;;;813    
;;;814        return 0;
;;;815    }
00000a  bd10              POP      {r4,pc}
                  |L28.12|
00000c  f7fffffe          BL       RMP_Lock_Sched
000010  7e20              LDRB     r0,[r4,#0x18]         ;794
000012  b920              CBNZ     r0,|L28.30|
000014  f7fffffe          BL       RMP_Unlock_Sched
000018  f04f30ff          MOV      r0,#0xffffffff        ;797
00001c  e7f5              B        |L28.10|
                  |L28.30|
00001e  8b20              LDRH     r0,[r4,#0x18]         ;801
000020  f4007080          AND      r0,r0,#0x100          ;801
000024  b120              CBZ      r0,|L28.48|
000026  f7fffffe          BL       RMP_Unlock_Sched
00002a  f06f0003          MVN      r0,#3                 ;804
00002e  e7ec              B        |L28.10|
                  |L28.48|
000030  69a0              LDR      r0,[r4,#0x18]         ;807
000032  f4407080          ORR      r0,r0,#0x100          ;807
000036  61a0              STR      r0,[r4,#0x18]         ;807
000038  7e20              LDRB     r0,[r4,#0x18]         ;809
00003a  2801              CMP      r0,#1                 ;809
00003c  d102              BNE      |L28.68|
00003e  4620              MOV      r0,r4                 ;810
000040  f7fffffe          BL       _RMP_Clr_Rdy
                  |L28.68|
000044  f7fffffe          BL       RMP_Unlock_Sched
000048  2000              MOVS     r0,#0                 ;814
00004a  e7de              B        |L28.10|
;;;816    /* End Function:RMP_Thd_Suspend **********************************************/
                          ENDP


                          AREA ||i.RMP_Tick_Hook||, CODE, READONLY, ALIGN=1

                  RMP_Tick_Hook PROC
;;;1488   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1489   void RMP_Tick_Hook(ptr_t Ticks)
000000  4770              BX       lr
;;;1490   {
;;;1491       return;
;;;1492   }
;;;1493   #endif
                          ENDP


                          AREA ||i.RMP_Unlock_Sched||, CODE, READONLY, ALIGN=2

                  RMP_Unlock_Sched PROC
;;;276    ******************************************************************************/
;;;277    void RMP_Unlock_Sched(void)
000000  b510              PUSH     {r4,lr}
;;;278    {
;;;279        if(RMP_Sched_Lock_Cnt==1)
000002  480d              LDR      r0,|L30.56|
000004  6800              LDR      r0,[r0,#0]  ; RMP_Sched_Lock_Cnt
000006  2801              CMP      r0,#1
000008  d10d              BNE      |L30.38|
;;;280        {
;;;281            /* Clear the count before enabling */
;;;282            RMP_Sched_Lock_Cnt=0;
00000a  2000              MOVS     r0,#0
00000c  490a              LDR      r1,|L30.56|
00000e  6008              STR      r0,[r1,#0]  ; RMP_Sched_Lock_Cnt
;;;283            RMP_Sched_Locked=0;
000010  490a              LDR      r1,|L30.60|
000012  6008              STR      r0,[r1,#0]  ; RMP_Sched_Locked
;;;284            /* Now see if the scheduler scheduling action is pended in the lock-unlock 
;;;285             * period. If yes, perform a schedule now */
;;;286            if(RMP_Sched_Pend!=0)
000014  480a              LDR      r0,|L30.64|
000016  6800              LDR      r0,[r0,#0]  ; RMP_Sched_Pend
000018  b168              CBZ      r0,|L30.54|
;;;287            {
;;;288                /* Reset the count and trigger the context switch */
;;;289                RMP_Sched_Pend=0;
00001a  2000              MOVS     r0,#0
00001c  4908              LDR      r1,|L30.64|
00001e  6008              STR      r0,[r1,#0]  ; RMP_Sched_Pend
;;;290                _RMP_Yield();
000020  f7fffffe          BL       _RMP_Yield
000024  e007              B        |L30.54|
                  |L30.38|
;;;291            }
;;;292        }
;;;293        else if(RMP_Sched_Lock_Cnt!=0)
000026  4804              LDR      r0,|L30.56|
000028  6800              LDR      r0,[r0,#0]  ; RMP_Sched_Lock_Cnt
00002a  b120              CBZ      r0,|L30.54|
;;;294            RMP_Sched_Lock_Cnt--;
00002c  4802              LDR      r0,|L30.56|
00002e  6800              LDR      r0,[r0,#0]  ; RMP_Sched_Lock_Cnt
000030  1e40              SUBS     r0,r0,#1
000032  4901              LDR      r1,|L30.56|
000034  6008              STR      r0,[r1,#0]  ; RMP_Sched_Lock_Cnt
                  |L30.54|
;;;295    }
000036  bd10              POP      {r4,pc}
;;;296    /* End Function:RMP_Unlock_Sched *********************************************/
                          ENDP

                  |L30.56|
                          DCD      RMP_Sched_Lock_Cnt
                  |L30.60|
                          DCD      RMP_Sched_Locked
                  |L30.64|
                          DCD      RMP_Sched_Pend

                          AREA ||i.RMP_Yield||, CODE, READONLY, ALIGN=2

                  RMP_Yield PROC
;;;303    ******************************************************************************/
;;;304    void RMP_Yield(void)
000000  b510              PUSH     {r4,lr}
;;;305    {
;;;306        if(RMP_Sched_Locked==0)
000002  4805              LDR      r0,|L31.24|
000004  6800              LDR      r0,[r0,#0]  ; RMP_Sched_Locked
000006  b910              CBNZ     r0,|L31.14|
;;;307        {
;;;308            /* Now see if the scheduler scheduling action is pended in the lock-unlock 
;;;309             * period. If yes, perform a schedule now */
;;;310            _RMP_Yield();
000008  f7fffffe          BL       _RMP_Yield
00000c  e002              B        |L31.20|
                  |L31.14|
;;;311        }
;;;312        else
;;;313            RMP_Sched_Pend=1;
00000e  2001              MOVS     r0,#1
000010  4902              LDR      r1,|L31.28|
000012  6008              STR      r0,[r1,#0]  ; RMP_Sched_Pend
                  |L31.20|
;;;314    }
000014  bd10              POP      {r4,pc}
;;;315    /* End Function:RMP_Yield ****************************************************/
                          ENDP

000016  0000              DCW      0x0000
                  |L31.24|
                          DCD      RMP_Sched_Locked
                  |L31.28|
                          DCD      RMP_Sched_Pend

                          AREA ||i._RMP_Clr_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Clr_Rdy PROC
;;;532    ******************************************************************************/
;;;533    void _RMP_Clr_Rdy(struct RMP_Thd* Thread)
000000  b500              PUSH     {lr}
;;;534    {
000002  4602              MOV      r2,r0
;;;535        /* See if it is the last thread on the priority level */
;;;536        if(Thread->Run_Head.Prev==Thread->Run_Head.Next)
000004  e9d20100          LDRD     r0,r1,[r2,#0]
000008  4288              CMP      r0,r1
00000a  d110              BNE      |L32.46|
;;;537            RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]&=~(((ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK));
00000c  6a50              LDR      r0,[r2,#0x24]
00000e  0940              LSRS     r0,r0,#5
000010  490d              LDR      r1,|L32.72|
000012  f8510020          LDR      r0,[r1,r0,LSL #2]
000016  f8921024          LDRB     r1,[r2,#0x24]
00001a  f001030f          AND      r3,r1,#0xf
00001e  2101              MOVS     r1,#1
000020  4099              LSLS     r1,r1,r3
000022  4388              BICS     r0,r0,r1
000024  6a51              LDR      r1,[r2,#0x24]
000026  0949              LSRS     r1,r1,#5
000028  4b07              LDR      r3,|L32.72|
00002a  f8430021          STR      r0,[r3,r1,LSL #2]
                  |L32.46|
;;;538        
;;;539        /* Insert this into the corresponding runqueue */
;;;540        RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
00002e  e9d20100          LDRD     r0,r1,[r2,#0]
000032  f7fffffe          BL       RMP_List_Del
;;;541        
;;;542        /* If it is the current thread, request a context switch */
;;;543        if(Thread==RMP_Cur_Thd)
000036  4805              LDR      r0,|L32.76|
000038  6800              LDR      r0,[r0,#0]  ; RMP_Cur_Thd
00003a  4282              CMP      r2,r0
00003c  d102              BNE      |L32.68|
;;;544            RMP_Sched_Pend=1;
00003e  2001              MOVS     r0,#1
000040  4903              LDR      r1,|L32.80|
000042  6008              STR      r0,[r1,#0]  ; RMP_Sched_Pend
                  |L32.68|
;;;545    }
000044  bd00              POP      {pc}
;;;546    /* End Function:_RMP_Clr_Rdy *************************************************/
                          ENDP

000046  0000              DCW      0x0000
                  |L32.72|
                          DCD      RMP_Bitmap
                  |L32.76|
                          DCD      RMP_Cur_Thd
                  |L32.80|
                          DCD      RMP_Sched_Pend

                          AREA ||i._RMP_Dly_Ins||, CODE, READONLY, ALIGN=2

                  _RMP_Dly_Ins PROC
;;;555    ******************************************************************************/
;;;556    void _RMP_Dly_Ins(struct RMP_Thd* Thread, ptr_t Slices)
000000  b570              PUSH     {r4-r6,lr}
;;;557    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;558        struct RMP_List* Trav_Ptr;
;;;559        struct RMP_Thd* Trav_Thd;
;;;560        
;;;561        Trav_Ptr=(struct RMP_List*)RMP_Delay.Next;
000006  480d              LDR      r0,|L33.60|
000008  6843              LDR      r3,[r0,#4]  ; RMP_Delay
;;;562        while(Trav_Ptr!=&(RMP_Delay))
00000a  e008              B        |L33.30|
                  |L33.12|
;;;563        {
;;;564            Trav_Thd=RMP_DLY2THD(Trav_Ptr);
00000c  f1a30608          SUB      r6,r3,#8
;;;565            if((Trav_Thd->Timeout-RMP_Tick)>Slices)
000010  490b              LDR      r1,|L33.64|
000012  6ab0              LDR      r0,[r6,#0x28]
000014  6809              LDR      r1,[r1,#0]  ; RMP_Tick
000016  1a40              SUBS     r0,r0,r1
000018  42a8              CMP      r0,r5
00001a  d900              BLS      |L33.30|
;;;566                break;
00001c  e002              B        |L33.36|
                  |L33.30|
00001e  4807              LDR      r0,|L33.60|
000020  4283              CMP      r3,r0                 ;562
000022  d1f3              BNE      |L33.12|
                  |L33.36|
000024  bf00              NOP      
;;;567        }
;;;568    
;;;569        /* Insert this into the list */
;;;570        Thread->Timeout=RMP_Tick+Slices;
000026  4806              LDR      r0,|L33.64|
000028  6800              LDR      r0,[r0,#0]  ; RMP_Tick
00002a  4428              ADD      r0,r0,r5
00002c  62a0              STR      r0,[r4,#0x28]
;;;571        RMP_List_Ins(&Thread->Dly_Head,Trav_Ptr->Prev,Trav_Ptr);
00002e  461a              MOV      r2,r3
000030  f1040008          ADD      r0,r4,#8
000034  6819              LDR      r1,[r3,#0]
000036  f7fffffe          BL       RMP_List_Ins
;;;572    }
00003a  bd70              POP      {r4-r6,pc}
;;;573    /* End Function:_RMP_Dly_Ins *************************************************/
                          ENDP

                  |L33.60|
                          DCD      RMP_Delay
                  |L33.64|
                          DCD      RMP_Tick

                          AREA ||i._RMP_Get_High_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Get_High_Rdy PROC
;;;381    ******************************************************************************/
;;;382    void _RMP_Get_High_Rdy(void)
000000  b510              PUSH     {r4,lr}
;;;383    {
;;;384        cnt_t Count;
;;;385        
;;;386        /* Write the SP value to thread structure */
;;;387        RMP_Cur_Thd->Stack=RMP_Cur_SP;
000002  482d              LDR      r0,|L34.184|
000004  6800              LDR      r0,[r0,#0]  ; RMP_Cur_SP
000006  492d              LDR      r1,|L34.188|
000008  6809              LDR      r1,[r1,#0]  ; RMP_Cur_Thd
00000a  6348              STR      r0,[r1,#0x34]
;;;388        
;;;389        /* Is the scheduler locked on other threads? If yes, we return without doing anything */
;;;390        if(RMP_Sched_Locked!=0)
00000c  482c              LDR      r0,|L34.192|
00000e  6800              LDR      r0,[r0,#0]  ; RMP_Sched_Locked
000010  b100              CBZ      r0,|L34.20|
                  |L34.18|
;;;391            return;
;;;392        
;;;393        if(RMP_Timer_Pend==1)
;;;394        {
;;;395            RMP_Timer_Pend=0;
;;;396            _RMP_Timer_Proc();
;;;397        }
;;;398        
;;;399        RMP_Sched_Pend=0;
;;;400        /* See which one is ready, and pick it */
;;;401        for(Count=RMP_BITMAP_SIZE-1;Count>=0;Count--)
;;;402        {
;;;403            if(RMP_Bitmap[Count]==0)
;;;404                continue;
;;;405            
;;;406            Count=RMP_MSB_Get(RMP_Bitmap[Count])+(Count<<RMP_WORD_ORDER);
;;;407            
;;;408            /* See if the current thread and the next thread are the same. If yes, place the current at the end of the queue */
;;;409            if(RMP_Cur_Thd==(struct RMP_Thd*)(RMP_Run[Count].Next))
;;;410            {
;;;411                RMP_List_Del(RMP_Cur_Thd->Run_Head.Prev, RMP_Cur_Thd->Run_Head.Next);
;;;412                RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),
;;;413                             RMP_Run[RMP_Cur_Thd->Prio].Prev,
;;;414                             &(RMP_Run[RMP_Cur_Thd->Prio]));
;;;415            }
;;;416            
;;;417            /* Replenish timeslices */
;;;418            RMP_Cur_Thd->Slices_Left=RMP_Cur_Thd->Slices;
;;;419            RMP_Cur_Thd=(struct RMP_Thd*)(RMP_Run[Count].Next);
;;;420            break;
;;;421        }
;;;422        
;;;423        /* Load the SP value from thread structure */
;;;424        RMP_Cur_SP=RMP_Cur_Thd->Stack;
;;;425    }
000012  bd10              POP      {r4,pc}
                  |L34.20|
000014  482b              LDR      r0,|L34.196|
000016  6800              LDR      r0,[r0,#0]            ;393  ; RMP_Timer_Pend
000018  2801              CMP      r0,#1                 ;393
00001a  d104              BNE      |L34.38|
00001c  2000              MOVS     r0,#0                 ;395
00001e  4929              LDR      r1,|L34.196|
000020  6008              STR      r0,[r1,#0]            ;395  ; RMP_Timer_Pend
000022  f7fffffe          BL       _RMP_Timer_Proc
                  |L34.38|
000026  2000              MOVS     r0,#0                 ;399
000028  4927              LDR      r1,|L34.200|
00002a  6008              STR      r0,[r1,#0]            ;399  ; RMP_Sched_Pend
00002c  2400              MOVS     r4,#0                 ;401
00002e  e038              B        |L34.162|
                  |L34.48|
000030  4826              LDR      r0,|L34.204|
000032  f8500024          LDR      r0,[r0,r4,LSL #2]     ;403
000036  b900              CBNZ     r0,|L34.58|
000038  e032              B        |L34.160|
                  |L34.58|
00003a  4924              LDR      r1,|L34.204|
00003c  f8510024          LDR      r0,[r1,r4,LSL #2]     ;406
000040  f7fffffe          BL       RMP_MSB_Get
000044  eb001444          ADD      r4,r0,r4,LSL #5       ;406
000048  4821              LDR      r0,|L34.208|
00004a  eb0000c4          ADD      r0,r0,r4,LSL #3       ;409
00004e  6840              LDR      r0,[r0,#4]            ;409
000050  491a              LDR      r1,|L34.188|
000052  6809              LDR      r1,[r1,#0]            ;409  ; RMP_Cur_Thd
000054  4288              CMP      r0,r1                 ;409
000056  d116              BNE      |L34.134|
000058  4a18              LDR      r2,|L34.188|
00005a  6812              LDR      r2,[r2,#0]            ;411  ; RMP_Cur_Thd
00005c  6851              LDR      r1,[r2,#4]            ;411
00005e  4a17              LDR      r2,|L34.188|
000060  6812              LDR      r2,[r2,#0]            ;411  ; RMP_Cur_Thd
000062  6810              LDR      r0,[r2,#0]            ;411
000064  f7fffffe          BL       RMP_List_Del
000068  4814              LDR      r0,|L34.188|
00006a  6800              LDR      r0,[r0,#0]            ;412  ; RMP_Cur_Thd
00006c  6a40              LDR      r0,[r0,#0x24]         ;412
00006e  4b18              LDR      r3,|L34.208|
000070  eb0302c0          ADD      r2,r3,r0,LSL #3       ;412
000074  4811              LDR      r0,|L34.188|
000076  6800              LDR      r0,[r0,#0]            ;412  ; RMP_Cur_Thd
000078  6a40              LDR      r0,[r0,#0x24]         ;412
00007a  f8531030          LDR      r1,[r3,r0,LSL #3]     ;412
00007e  480f              LDR      r0,|L34.188|
000080  6800              LDR      r0,[r0,#0]            ;412  ; RMP_Cur_Thd
000082  f7fffffe          BL       RMP_List_Ins
                  |L34.134|
000086  480d              LDR      r0,|L34.188|
000088  6800              LDR      r0,[r0,#0]            ;418  ; RMP_Cur_Thd
00008a  69c0              LDR      r0,[r0,#0x1c]         ;418
00008c  490b              LDR      r1,|L34.188|
00008e  6809              LDR      r1,[r1,#0]            ;418  ; RMP_Cur_Thd
000090  6208              STR      r0,[r1,#0x20]         ;418
000092  480f              LDR      r0,|L34.208|
000094  eb0000c4          ADD      r0,r0,r4,LSL #3       ;419
000098  6840              LDR      r0,[r0,#4]            ;419
00009a  4908              LDR      r1,|L34.188|
00009c  6008              STR      r0,[r1,#0]            ;419  ; RMP_Cur_Thd
00009e  e002              B        |L34.166|
                  |L34.160|
0000a0  1e64              SUBS     r4,r4,#1              ;401
                  |L34.162|
0000a2  2c00              CMP      r4,#0                 ;401
0000a4  dac4              BGE      |L34.48|
                  |L34.166|
0000a6  bf00              NOP                            ;420
0000a8  4804              LDR      r0,|L34.188|
0000aa  6800              LDR      r0,[r0,#0]            ;424  ; RMP_Cur_Thd
0000ac  6b40              LDR      r0,[r0,#0x34]         ;424
0000ae  4902              LDR      r1,|L34.184|
0000b0  6008              STR      r0,[r1,#0]            ;424  ; RMP_Cur_SP
0000b2  bf00              NOP      
0000b4  e7ad              B        |L34.18|
;;;426    /* End Function:_RMP_Get_High_Rdy ********************************************/
                          ENDP

0000b6  0000              DCW      0x0000
                  |L34.184|
                          DCD      RMP_Cur_SP
                  |L34.188|
                          DCD      RMP_Cur_Thd
                  |L34.192|
                          DCD      RMP_Sched_Locked
                  |L34.196|
                          DCD      RMP_Timer_Pend
                  |L34.200|
                          DCD      RMP_Sched_Pend
                  |L34.204|
                          DCD      RMP_Bitmap
                  |L34.208|
                          DCD      RMP_Run

                          AREA ||i._RMP_Get_Near_Ticks||, CODE, READONLY, ALIGN=2

                  _RMP_Get_Near_Ticks PROC
;;;477    ******************************************************************************/
;;;478    ptr_t _RMP_Get_Near_Ticks(void)
000000  4a0c              LDR      r2,|L35.52|
;;;479    {
;;;480        ptr_t Value;
;;;481        struct RMP_Thd* Thread;
;;;482        
;;;483        /* What is the current thread's timeout value? */
;;;484        Value=RMP_Cur_Thd->Slices_Left;
000002  6812              LDR      r2,[r2,#0]  ; RMP_Cur_Thd
000004  6a10              LDR      r0,[r2,#0x20]
;;;485        
;;;486        /* What is the nearest timer timeout value? */
;;;487        if((&RMP_Delay)!=RMP_Delay.Next)
000006  4a0c              LDR      r2,|L35.56|
000008  6852              LDR      r2,[r2,#4]  ; RMP_Delay
00000a  4b0b              LDR      r3,|L35.56|
00000c  429a              CMP      r2,r3
00000e  d00d              BEQ      |L35.44|
;;;488        {
;;;489            Thread=RMP_DLY2THD(RMP_Delay.Next);
000010  461a              MOV      r2,r3
000012  6852              LDR      r2,[r2,#4]  ; RMP_Delay
000014  f1a20108          SUB      r1,r2,#8
;;;490            /* See if it is nearer - don't worry about the situation that the timer
;;;491             * have overflown, because if that is to happen, it would have been 
;;;492             * already processed by the timeout processing routine just called above. */
;;;493            if((Thread->Timeout-RMP_Tick)<Value)
000018  4b08              LDR      r3,|L35.60|
00001a  6a8a              LDR      r2,[r1,#0x28]
00001c  681b              LDR      r3,[r3,#0]  ; RMP_Tick
00001e  1ad2              SUBS     r2,r2,r3
000020  4282              CMP      r2,r0
000022  d203              BCS      |L35.44|
;;;494                Value=Thread->Timeout-RMP_Tick;
000024  4b05              LDR      r3,|L35.60|
000026  6a8a              LDR      r2,[r1,#0x28]
000028  681b              LDR      r3,[r3,#0]  ; RMP_Tick
00002a  1ad0              SUBS     r0,r2,r3
                  |L35.44|
;;;495        }
;;;496        
;;;497        /* The timer setting is at least 1 tick */
;;;498        if(Value==0)
00002c  b900              CBNZ     r0,|L35.48|
;;;499            Value=1;
00002e  2001              MOVS     r0,#1
                  |L35.48|
;;;500        
;;;501        return Value;
;;;502    }
000030  4770              BX       lr
;;;503    /* End Function:_RMP_Get_Near_Ticks ******************************************/
                          ENDP

000032  0000              DCW      0x0000
                  |L35.52|
                          DCD      RMP_Cur_Thd
                  |L35.56|
                          DCD      RMP_Delay
                  |L35.60|
                          DCD      RMP_Tick

                          AREA ||i._RMP_Set_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Set_Rdy PROC
;;;512    ******************************************************************************/
;;;513    void _RMP_Set_Rdy(struct RMP_Thd* Thread)
000000  b510              PUSH     {r4,lr}
;;;514    {
000002  4603              MOV      r3,r0
;;;515        /* Insert this into the corresponding runqueue */
;;;516        RMP_List_Ins(&(Thread->Run_Head),RMP_Run[Thread->Prio].Prev,&(RMP_Run[Thread->Prio]));
000004  4c11              LDR      r4,|L36.76|
000006  6a58              LDR      r0,[r3,#0x24]
000008  eb0402c0          ADD      r2,r4,r0,LSL #3
00000c  f8541030          LDR      r1,[r4,r0,LSL #3]
000010  4618              MOV      r0,r3
000012  f7fffffe          BL       RMP_List_Ins
;;;517        /* Set this runlevel as active */
;;;518        RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]|=((ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK);
000016  6a58              LDR      r0,[r3,#0x24]
000018  0940              LSRS     r0,r0,#5
00001a  490d              LDR      r1,|L36.80|
00001c  f8510020          LDR      r0,[r1,r0,LSL #2]
000020  f8931024          LDRB     r1,[r3,#0x24]
000024  f001020f          AND      r2,r1,#0xf
000028  2101              MOVS     r1,#1
00002a  4091              LSLS     r1,r1,r2
00002c  4308              ORRS     r0,r0,r1
00002e  6a59              LDR      r1,[r3,#0x24]
000030  0949              LSRS     r1,r1,#5
000032  4a07              LDR      r2,|L36.80|
000034  f8420021          STR      r0,[r2,r1,LSL #2]
;;;519        
;;;520        /* Compare this with the current one to see if we need a context switch */
;;;521        if(Thread->Prio>RMP_Cur_Thd->Prio)
000038  4906              LDR      r1,|L36.84|
00003a  6a58              LDR      r0,[r3,#0x24]
00003c  6809              LDR      r1,[r1,#0]  ; RMP_Cur_Thd
00003e  6a49              LDR      r1,[r1,#0x24]
000040  4288              CMP      r0,r1
000042  d902              BLS      |L36.74|
;;;522            RMP_Sched_Pend=1;
000044  2001              MOVS     r0,#1
000046  4904              LDR      r1,|L36.88|
000048  6008              STR      r0,[r1,#0]  ; RMP_Sched_Pend
                  |L36.74|
;;;523    }
00004a  bd10              POP      {r4,pc}
;;;524    /* End Function:_RMP_Set_Rdy *************************************************/
                          ENDP

                  |L36.76|
                          DCD      RMP_Run
                  |L36.80|
                          DCD      RMP_Bitmap
                  |L36.84|
                          DCD      RMP_Cur_Thd
                  |L36.88|
                          DCD      RMP_Sched_Pend

                          AREA ||i._RMP_Tick_Handler||, CODE, READONLY, ALIGN=2

                  _RMP_Tick_Handler PROC
;;;433    ******************************************************************************/
;;;434    void _RMP_Tick_Handler(ptr_t Ticks)
000000  b570              PUSH     {r4-r6,lr}
;;;435    {
000002  4604              MOV      r4,r0
;;;436        struct RMP_Thd* Thread;
;;;437        /* Increase the timestamp as always */
;;;438        RMP_Tick+=Ticks;
000004  481c              LDR      r0,|L37.120|
000006  6800              LDR      r0,[r0,#0]  ; RMP_Tick
000008  4420              ADD      r0,r0,r4
00000a  491b              LDR      r1,|L37.120|
00000c  6008              STR      r0,[r1,#0]  ; RMP_Tick
;;;439    #if(RMP_USE_HOOKS==RMP_TRUE)
;;;440        RMP_Tick_Hook(Ticks);
;;;441    #endif
;;;442        /* See if the current thread expired. If yes, trigger a scheduler event */
;;;443        if(Ticks>=RMP_Cur_Thd->Slices_Left)
00000e  481b              LDR      r0,|L37.124|
000010  6800              LDR      r0,[r0,#0]  ; RMP_Cur_Thd
000012  6a00              LDR      r0,[r0,#0x20]
000014  42a0              CMP      r0,r4
000016  d803              BHI      |L37.32|
;;;444            RMP_Sched_Pend=1;
000018  2001              MOVS     r0,#1
00001a  4919              LDR      r1,|L37.128|
00001c  6008              STR      r0,[r1,#0]  ; RMP_Sched_Pend
00001e  e006              B        |L37.46|
                  |L37.32|
;;;445        else
;;;446            RMP_Cur_Thd->Slices_Left-=Ticks;
000020  4816              LDR      r0,|L37.124|
000022  6800              LDR      r0,[r0,#0]  ; RMP_Cur_Thd
000024  6a00              LDR      r0,[r0,#0x20]
000026  1b00              SUBS     r0,r0,r4
000028  4914              LDR      r1,|L37.124|
00002a  6809              LDR      r1,[r1,#0]  ; RMP_Cur_Thd
00002c  6208              STR      r0,[r1,#0x20]
                  |L37.46|
;;;447        
;;;448        /* Is the scheduler locked? If yes, we cannot process timer events here and will have to pend them */
;;;449        if((&RMP_Delay)!=RMP_Delay.Next)
00002e  4815              LDR      r0,|L37.132|
000030  6840              LDR      r0,[r0,#4]  ; RMP_Delay
000032  4914              LDR      r1,|L37.132|
000034  4288              CMP      r0,r1
000036  d013              BEQ      |L37.96|
;;;450        {
;;;451            Thread=RMP_DLY2THD(RMP_Delay.Next);
000038  4608              MOV      r0,r1
00003a  6840              LDR      r0,[r0,#4]  ; RMP_Delay
00003c  f1a00508          SUB      r5,r0,#8
;;;452            /* If the value is less than this, then it means that the time have
;;;453             * already passed and we have to process this */
;;;454            if((RMP_Tick-Thread->Timeout)<=(RMP_ALLBITS>>1))
000040  490d              LDR      r1,|L37.120|
000042  6aa8              LDR      r0,[r5,#0x28]
000044  6809              LDR      r1,[r1,#0]  ; RMP_Tick
000046  1a08              SUBS     r0,r1,r0
000048  f1b04f00          CMP      r0,#0x80000000
00004c  d208              BCS      |L37.96|
;;;455            {
;;;456                /* If scheduler locked, we pend the processing until it is unlocked */
;;;457                if(RMP_Sched_Locked!=0)
00004e  480e              LDR      r0,|L37.136|
000050  6800              LDR      r0,[r0,#0]  ; RMP_Sched_Locked
000052  b118              CBZ      r0,|L37.92|
;;;458                    RMP_Timer_Pend=1;
000054  2001              MOVS     r0,#1
000056  490d              LDR      r1,|L37.140|
000058  6008              STR      r0,[r1,#0]  ; RMP_Timer_Pend
00005a  e001              B        |L37.96|
                  |L37.92|
;;;459                else
;;;460                    _RMP_Timer_Proc();
00005c  f7fffffe          BL       _RMP_Timer_Proc
                  |L37.96|
;;;461            }
;;;462        }
;;;463        
;;;464        if((RMP_Sched_Locked==0)&&(RMP_Sched_Pend!=0))
000060  4809              LDR      r0,|L37.136|
000062  6800              LDR      r0,[r0,#0]  ; RMP_Sched_Locked
000064  b938              CBNZ     r0,|L37.118|
000066  4806              LDR      r0,|L37.128|
000068  6800              LDR      r0,[r0,#0]  ; RMP_Sched_Pend
00006a  b120              CBZ      r0,|L37.118|
;;;465        {
;;;466            RMP_Sched_Pend=0;
00006c  2000              MOVS     r0,#0
00006e  4904              LDR      r1,|L37.128|
000070  6008              STR      r0,[r1,#0]  ; RMP_Sched_Pend
;;;467            _RMP_Yield();
000072  f7fffffe          BL       _RMP_Yield
                  |L37.118|
;;;468        }
;;;469    }
000076  bd70              POP      {r4-r6,pc}
;;;470    /* End Function:_RMP_Tick_Handler ********************************************/
                          ENDP

                  |L37.120|
                          DCD      RMP_Tick
                  |L37.124|
                          DCD      RMP_Cur_Thd
                  |L37.128|
                          DCD      RMP_Sched_Pend
                  |L37.132|
                          DCD      RMP_Delay
                  |L37.136|
                          DCD      RMP_Sched_Locked
                  |L37.140|
                          DCD      RMP_Timer_Pend

                          AREA ||i._RMP_Timer_Proc||, CODE, READONLY, ALIGN=2

                  _RMP_Timer_Proc PROC
;;;322    ******************************************************************************/
;;;323    void _RMP_Timer_Proc(void)
000000  b510              PUSH     {r4,lr}
;;;324    {
;;;325        struct RMP_Thd* Thread;
;;;326        
;;;327        /* Process the timer events, if there are any of them */
;;;328        while((&RMP_Delay)!=RMP_Delay.Next)
000002  e055              B        |L38.176|
                  |L38.4|
;;;329        {
;;;330            Thread=RMP_DLY2THD(RMP_Delay.Next);
000004  482e              LDR      r0,|L38.192|
000006  6840              LDR      r0,[r0,#4]  ; RMP_Delay
000008  f1a00308          SUB      r3,r0,#8
;;;331            /* If the value is more than this, then it means that the time have
;;;332             * already passed and we have to process this */
;;;333            if((RMP_Tick-Thread->Timeout)>(RMP_ALLBITS>>1))
00000c  492d              LDR      r1,|L38.196|
00000e  6a98              LDR      r0,[r3,#0x28]
000010  6809              LDR      r1,[r1,#0]  ; RMP_Tick
000012  1a08              SUBS     r0,r1,r0
000014  f1b04f00          CMP      r0,#0x80000000
000018  d300              BCC      |L38.28|
;;;334                break;
00001a  e04e              B        |L38.186|
                  |L38.28|
;;;335            
;;;336            /* This thread should be processed */
;;;337            RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
00001c  e9d30102          LDRD     r0,r1,[r3,#8]
000020  f7fffffe          BL       RMP_List_Del
;;;338            switch(RMP_THD_STATE(Thread->State))
000024  7e18              LDRB     r0,[r3,#0x18]
000026  2803              CMP      r0,#3
000028  d006              BEQ      |L38.56|
00002a  2805              CMP      r0,#5
00002c  d00d              BEQ      |L38.74|
00002e  2806              CMP      r0,#6
000030  d00f              BEQ      |L38.82|
000032  2808              CMP      r0,#8
000034  d10e              BNE      |L38.84|
000036  e000              B        |L38.58|
                  |L38.56|
;;;339            {
;;;340                case RMP_THD_SNDDLY:
;;;341                case RMP_THD_SEMDLY:
000038  bf00              NOP      
                  |L38.58|
;;;342                {
;;;343                    RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
00003a  e9d30100          LDRD     r0,r1,[r3,#0]
00003e  f7fffffe          BL       RMP_List_Del
;;;344                    Thread->Retval=RMP_ERR_OPER;
000042  f06f0004          MVN      r0,#4
000046  6398              STR      r0,[r3,#0x38]
;;;345                    break;
000048  e005              B        |L38.86|
                  |L38.74|
;;;346                }
;;;347                
;;;348                case RMP_THD_RCVDLY:
;;;349                {
;;;350                    Thread->Retval=RMP_ERR_OPER;
00004a  f06f0004          MVN      r0,#4
00004e  6398              STR      r0,[r3,#0x38]
;;;351                    break;
000050  e001              B        |L38.86|
                  |L38.82|
;;;352                }
;;;353                
;;;354                case RMP_THD_DELAYED:break;
000052  e000              B        |L38.86|
                  |L38.84|
;;;355                /* Should not get here */
;;;356                default:break;
000054  bf00              NOP      
                  |L38.86|
000056  bf00              NOP                            ;345
;;;357            }
;;;358    
;;;359            RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
000058  6998              LDR      r0,[r3,#0x18]
00005a  f02000ff          BIC      r0,r0,#0xff
00005e  1c40              ADDS     r0,r0,#1
000060  6198              STR      r0,[r3,#0x18]
;;;360            /* Is it suspended? If yes, we can't directly set it running */
;;;361            if((Thread->State&RMP_THD_SUSPENDED)==0)
000062  8b18              LDRH     r0,[r3,#0x18]
000064  f4007080          AND      r0,r0,#0x100
000068  bb10              CBNZ     r0,|L38.176|
;;;362            {
;;;363                /* Insert this into the corresponding runqueue */
;;;364                RMP_List_Ins(&(Thread->Run_Head),RMP_Run[Thread->Prio].Prev,&(RMP_Run[Thread->Prio]));
00006a  4c17              LDR      r4,|L38.200|
00006c  6a58              LDR      r0,[r3,#0x24]
00006e  eb0402c0          ADD      r2,r4,r0,LSL #3
000072  f8541030          LDR      r1,[r4,r0,LSL #3]
000076  4618              MOV      r0,r3
000078  f7fffffe          BL       RMP_List_Ins
;;;365                /* Set this runlevel as active */
;;;366                RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]|=1<<(Thread->Prio&RMP_WORD_MASK);
00007c  6a58              LDR      r0,[r3,#0x24]
00007e  0940              LSRS     r0,r0,#5
000080  4912              LDR      r1,|L38.204|
000082  f8510020          LDR      r0,[r1,r0,LSL #2]
000086  f8931024          LDRB     r1,[r3,#0x24]
00008a  f001020f          AND      r2,r1,#0xf
00008e  2101              MOVS     r1,#1
000090  4091              LSLS     r1,r1,r2
000092  4308              ORRS     r0,r0,r1
000094  6a59              LDR      r1,[r3,#0x24]
000096  0949              LSRS     r1,r1,#5
000098  4a0c              LDR      r2,|L38.204|
00009a  f8420021          STR      r0,[r2,r1,LSL #2]
;;;367                /* See if we need to pend a scheduling event */
;;;368                if(Thread->Prio>RMP_Cur_Thd->Prio)
00009e  490c              LDR      r1,|L38.208|
0000a0  6a58              LDR      r0,[r3,#0x24]
0000a2  6809              LDR      r1,[r1,#0]  ; RMP_Cur_Thd
0000a4  6a49              LDR      r1,[r1,#0x24]
0000a6  4288              CMP      r0,r1
0000a8  d902              BLS      |L38.176|
;;;369                    RMP_Sched_Pend=1;
0000aa  2001              MOVS     r0,#1
0000ac  4909              LDR      r1,|L38.212|
0000ae  6008              STR      r0,[r1,#0]  ; RMP_Sched_Pend
                  |L38.176|
0000b0  4803              LDR      r0,|L38.192|
0000b2  6840              LDR      r0,[r0,#4]            ;328  ; RMP_Delay
0000b4  4902              LDR      r1,|L38.192|
0000b6  4288              CMP      r0,r1                 ;328
0000b8  d1a4              BNE      |L38.4|
                  |L38.186|
0000ba  bf00              NOP                            ;334
;;;370            }
;;;371        }
;;;372    }
0000bc  bd10              POP      {r4,pc}
;;;373    /* Begin Function:_RMP_Timer_Proc ********************************************/
                          ENDP

0000be  0000              DCW      0x0000
                  |L38.192|
                          DCD      RMP_Delay
                  |L38.196|
                          DCD      RMP_Tick
                  |L38.200|
                          DCD      RMP_Run
                  |L38.204|
                          DCD      RMP_Bitmap
                  |L38.208|
                          DCD      RMP_Cur_Thd
                  |L38.212|
                          DCD      RMP_Sched_Pend

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;1528   ******************************************************************************/
;;;1529   int main(void)
000000  b510              PUSH     {r4,lr}
;;;1530   {
;;;1531       cnt_t Count;
;;;1532       /* Initialize the kernel data structures first */
;;;1533       _RMP_Low_Level_Init();
000002  f7fffffe          BL       _RMP_Low_Level_Init
;;;1534       
;;;1535   #if(RMP_USE_HOOKS==RMP_TRUE)
;;;1536       RMP_Start_Hook();
;;;1537   #endif
;;;1538       
;;;1539       RMP_Tick=0;
000006  2000              MOVS     r0,#0
000008  4924              LDR      r1,|L39.156|
00000a  6008              STR      r0,[r1,#0]  ; RMP_Tick
;;;1540       /* Now initialize the kernel data structures */
;;;1541       RMP_Sched_Lock_Cnt=0;
00000c  4924              LDR      r1,|L39.160|
00000e  6008              STR      r0,[r1,#0]  ; RMP_Sched_Lock_Cnt
;;;1542       RMP_Sched_Locked=0;
000010  4924              LDR      r1,|L39.164|
000012  6008              STR      r0,[r1,#0]  ; RMP_Sched_Locked
;;;1543       RMP_Sched_Pend=0;
000014  4924              LDR      r1,|L39.168|
000016  6008              STR      r0,[r1,#0]  ; RMP_Sched_Pend
;;;1544       RMP_Timer_Pend=0;
000018  4924              LDR      r1,|L39.172|
00001a  6008              STR      r0,[r1,#0]  ; RMP_Timer_Pend
;;;1545       
;;;1546       /* Linked lists */
;;;1547       RMP_List_Crt(&RMP_Delay);
00001c  4824              LDR      r0,|L39.176|
00001e  f7fffffe          BL       RMP_List_Crt
;;;1548       for(Count=0;Count<RMP_MAX_PREEMPT_PRIO;Count++)
000022  2400              MOVS     r4,#0
000024  e005              B        |L39.50|
                  |L39.38|
;;;1549           RMP_List_Crt(&RMP_Run[Count]);
000026  4923              LDR      r1,|L39.180|
000028  eb0100c4          ADD      r0,r1,r4,LSL #3
00002c  f7fffffe          BL       RMP_List_Crt
000030  1c64              ADDS     r4,r4,#1              ;1548
                  |L39.50|
000032  2c20              CMP      r4,#0x20              ;1548
000034  dbf7              BLT      |L39.38|
;;;1550       for(Count=0;Count<RMP_BITMAP_SIZE;Count++)
000036  2400              MOVS     r4,#0
000038  e004              B        |L39.68|
                  |L39.58|
;;;1551           RMP_Bitmap[Count]=0;
00003a  2000              MOVS     r0,#0
00003c  491e              LDR      r1,|L39.184|
00003e  f8410024          STR      r0,[r1,r4,LSL #2]
000042  1c64              ADDS     r4,r4,#1              ;1550
                  |L39.68|
000044  2c00              CMP      r4,#0                 ;1550
000046  d0f8              BEQ      |L39.58|
;;;1552           
;;;1553       /* Now boot into the first thread */
;;;1554       RMP_Clear(&RMP_Init_Thd,sizeof(struct RMP_Thd));
000048  213c              MOVS     r1,#0x3c
00004a  481c              LDR      r0,|L39.188|
00004c  f7fffffe          BL       RMP_Clear
;;;1555       RMP_Init_Thd.Prio=0;
000050  2000              MOVS     r0,#0
000052  491a              LDR      r1,|L39.188|
000054  6248              STR      r0,[r1,#0x24]  ; RMP_Init_Thd
;;;1556       RMP_Init_Thd.Slices=RMP_MAX_SLICES-1;
000056  481a              LDR      r0,|L39.192|
000058  61c8              STR      r0,[r1,#0x1c]  ; RMP_Init_Thd
;;;1557       RMP_Init_Thd.State=RMP_THD_RUNNING;
00005a  2001              MOVS     r0,#1
00005c  6188              STR      r0,[r1,#0x18]  ; RMP_Init_Thd
;;;1558       RMP_Init_Thd.Stack=RMP_INIT_STACK;
00005e  4819              LDR      r0,|L39.196|
000060  6348              STR      r0,[r1,#0x34]  ; RMP_Init_Thd
;;;1559       
;;;1560       /* Initialize sending list */
;;;1561       RMP_List_Crt(&(RMP_Init_Thd.Snd_List));
000062  f1010010          ADD      r0,r1,#0x10
000066  f7fffffe          BL       RMP_List_Crt
;;;1562       
;;;1563       /* Insert this into the corresponding runqueue */
;;;1564       RMP_List_Ins(&(RMP_Init_Thd.Run_Head),RMP_Run[0].Prev,&(RMP_Run[0]));
00006a  4812              LDR      r0,|L39.180|
00006c  4602              MOV      r2,r0
00006e  6801              LDR      r1,[r0,#0]  ; RMP_Run
000070  4812              LDR      r0,|L39.188|
000072  f7fffffe          BL       RMP_List_Ins
;;;1565       /* Set this runlevel as active - in fact it is always active */
;;;1566       RMP_Bitmap[0]|=1;
000076  4810              LDR      r0,|L39.184|
000078  6800              LDR      r0,[r0,#0]  ; RMP_Bitmap
00007a  f0400001          ORR      r0,r0,#1
00007e  490e              LDR      r1,|L39.184|
000080  6008              STR      r0,[r1,#0]  ; RMP_Bitmap
;;;1567       
;;;1568       /* Set current thread and stack */
;;;1569       RMP_Cur_Thd=&RMP_Init_Thd;
000082  480e              LDR      r0,|L39.188|
000084  4910              LDR      r1,|L39.200|
000086  6008              STR      r0,[r1,#0]  ; RMP_Cur_Thd
;;;1570       RMP_Cur_SP=RMP_Init_Thd.Stack;
000088  6b40              LDR      r0,[r0,#0x34]  ; RMP_Init_Thd
00008a  4910              LDR      r1,|L39.204|
00008c  6008              STR      r0,[r1,#0]  ; RMP_Cur_SP
;;;1571       
;;;1572       /* Now jump to the user function and will never return. Initialization of stack is not needed */
;;;1573       _RMP_Start((ptr_t)RMP_Init, (ptr_t)RMP_Init_Thd.Stack);
00008e  480b              LDR      r0,|L39.188|
000090  6b41              LDR      r1,[r0,#0x34]  ; RMP_Init_Thd
000092  480f              LDR      r0,|L39.208|
000094  f7fffffe          BL       _RMP_Start
;;;1574       
;;;1575       return 0;
000098  2000              MOVS     r0,#0
;;;1576   }
00009a  bd10              POP      {r4,pc}
;;;1577   /* End Function:main *********************************************************/
                          ENDP

                  |L39.156|
                          DCD      RMP_Tick
                  |L39.160|
                          DCD      RMP_Sched_Lock_Cnt
                  |L39.164|
                          DCD      RMP_Sched_Locked
                  |L39.168|
                          DCD      RMP_Sched_Pend
                  |L39.172|
                          DCD      RMP_Timer_Pend
                  |L39.176|
                          DCD      RMP_Delay
                  |L39.180|
                          DCD      RMP_Run
                  |L39.184|
                          DCD      RMP_Bitmap
                  |L39.188|
                          DCD      RMP_Init_Thd
                  |L39.192|
                          DCD      0x0001869f
                  |L39.196|
                          DCD      RMP_Init_Stack+0xbc
                  |L39.200|
                          DCD      RMP_Cur_Thd
                  |L39.204|
                          DCD      RMP_Cur_SP
                  |L39.208|
                          DCD      RMP_Init

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  RMP_Run
                          %        256
                  RMP_Init_Stack
                          %        256
                  RMP_Init_Thd
                          %        60

                          AREA ||.data||, DATA, ALIGN=2

                  RMP_Bitmap
                          DCD      0x00000000
                  RMP_Delay
                          %        8
                  RMP_Tick
                          DCD      0x00000000
                  RMP_Sched_Lock_Cnt
                          DCD      0x00000000
                  RMP_Sched_Locked
                          DCD      0x00000000
                  RMP_Sched_Pend
                          DCD      0x00000000
                  RMP_Timer_Pend
                          DCD      0x00000000
                  RMP_Cur_Thd
                          DCD      0x00000000
                  RMP_Cur_SP
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\MProkaron\\Kernel\\kernel.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_kernel_c_346ad0e8____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32F7xx_HAL_Driver\\Core\\cmsis_armcc.h"
|__asm___8_kernel_c_346ad0e8____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_kernel_c_346ad0e8____REVSH|
#line 402
|__asm___8_kernel_c_346ad0e8____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___8_kernel_c_346ad0e8____RRX|
#line 587
|__asm___8_kernel_c_346ad0e8____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
