; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f7xx_hal_pwr_ex.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f7xx_hal_pwr_ex.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\..\Library\STM32F7xx_HAL_Driver\Core -I..\..\..\..\Library\STM32F7xx_HAL_Driver\Inc -I..\..\..\..\Library\STM32F7xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\32-Bit_MCU\STM32\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f7xx_hal_pwr_ex.crf ..\..\..\..\Library\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_pwr_ex.c]
                          THUMB

                          AREA ||i.HAL_PWREx_ControlVoltageScaling||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_ControlVoltageScaling PROC
;;;494      */
;;;495    HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
000000  b538              PUSH     {r3-r5,lr}
;;;496    {
000002  4605              MOV      r5,r0
;;;497      uint32_t tickstart = 0;
000004  2400              MOVS     r4,#0
;;;498    
;;;499      assert_param(IS_PWR_REGULATOR_VOLTAGE(VoltageScaling));
;;;500    
;;;501      /* Enable Power ctrl clock */
;;;502      __HAL_RCC_PWR_CLK_ENABLE();
000006  bf00              NOP      
000008  4836              LDR      r0,|L1.228|
00000a  6800              LDR      r0,[r0,#0]
00000c  f0405080          ORR      r0,r0,#0x10000000
000010  4934              LDR      r1,|L1.228|
000012  6008              STR      r0,[r1,#0]
000014  4608              MOV      r0,r1
000016  6800              LDR      r0,[r0,#0]
000018  f0005080          AND      r0,r0,#0x10000000
00001c  9000              STR      r0,[sp,#0]
00001e  bf00              NOP      
000020  bf00              NOP      
;;;503    
;;;504      /* Check if the PLL is used as system clock or not */
;;;505      if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
000022  4830              LDR      r0,|L1.228|
000024  3838              SUBS     r0,r0,#0x38
000026  6800              LDR      r0,[r0,#0]
000028  f000000c          AND      r0,r0,#0xc
00002c  2808              CMP      r0,#8
00002e  d055              BEQ      |L1.220|
;;;506      {
;;;507        /* Disable the main PLL */
;;;508        __HAL_RCC_PLL_DISABLE();
000030  482c              LDR      r0,|L1.228|
000032  3840              SUBS     r0,r0,#0x40
000034  6800              LDR      r0,[r0,#0]
000036  f0207080          BIC      r0,r0,#0x1000000
00003a  492a              LDR      r1,|L1.228|
00003c  3940              SUBS     r1,r1,#0x40
00003e  6008              STR      r0,[r1,#0]
;;;509        
;;;510        /* Get Start Tick */
;;;511        tickstart = HAL_GetTick();    
000040  f7fffffe          BL       HAL_GetTick
000044  4604              MOV      r4,r0
;;;512        /* Wait till PLL is disabled */  
;;;513        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
000046  e006              B        |L1.86|
                  |L1.72|
;;;514        {
;;;515          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
000048  f7fffffe          BL       HAL_GetTick
00004c  1b00              SUBS     r0,r0,r4
00004e  2802              CMP      r0,#2
000050  d901              BLS      |L1.86|
;;;516          {
;;;517            return HAL_TIMEOUT;
000052  2003              MOVS     r0,#3
                  |L1.84|
;;;518          }
;;;519        }
;;;520        
;;;521        /* Set Range */
;;;522        __HAL_PWR_VOLTAGESCALING_CONFIG(VoltageScaling);
;;;523        
;;;524        /* Enable the main PLL */
;;;525        __HAL_RCC_PLL_ENABLE();
;;;526        
;;;527        /* Get Start Tick */
;;;528        tickstart = HAL_GetTick();
;;;529        /* Wait till PLL is ready */  
;;;530        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
;;;531        {
;;;532          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
;;;533          {
;;;534            return HAL_TIMEOUT;
;;;535          } 
;;;536        }
;;;537        
;;;538        /* Get Start Tick */
;;;539        tickstart = HAL_GetTick();
;;;540        while((__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY) == RESET))
;;;541        {
;;;542          if((HAL_GetTick() - tickstart ) > PWR_VOSRDY_TIMEOUT_VALUE)
;;;543          {
;;;544            return HAL_TIMEOUT;
;;;545          } 
;;;546        }
;;;547      }
;;;548      else
;;;549      {
;;;550        return HAL_ERROR;
;;;551      }
;;;552      return HAL_OK;
;;;553    }
000054  bd38              POP      {r3-r5,pc}
                  |L1.86|
000056  4823              LDR      r0,|L1.228|
000058  3840              SUBS     r0,r0,#0x40           ;513
00005a  6800              LDR      r0,[r0,#0]            ;513
00005c  f3c06040          UBFX     r0,r0,#25,#1          ;513
000060  2800              CMP      r0,#0                 ;513
000062  d1f1              BNE      |L1.72|
000064  bf00              NOP                            ;522
000066  4820              LDR      r0,|L1.232|
000068  6800              LDR      r0,[r0,#0]            ;522
00006a  f4204040          BIC      r0,r0,#0xc000         ;522
00006e  4328              ORRS     r0,r0,r5              ;522
000070  491d              LDR      r1,|L1.232|
000072  6008              STR      r0,[r1,#0]            ;522
000074  4608              MOV      r0,r1                 ;522
000076  6800              LDR      r0,[r0,#0]            ;522
000078  f4004040          AND      r0,r0,#0xc000         ;522
00007c  9000              STR      r0,[sp,#0]            ;522
00007e  bf00              NOP                            ;522
000080  bf00              NOP                            ;522
000082  4818              LDR      r0,|L1.228|
000084  3840              SUBS     r0,r0,#0x40           ;525
000086  6800              LDR      r0,[r0,#0]            ;525
000088  f0407080          ORR      r0,r0,#0x1000000      ;525
00008c  4915              LDR      r1,|L1.228|
00008e  3940              SUBS     r1,r1,#0x40           ;525
000090  6008              STR      r0,[r1,#0]            ;525
000092  f7fffffe          BL       HAL_GetTick
000096  4604              MOV      r4,r0                 ;528
000098  e006              B        |L1.168|
                  |L1.154|
00009a  f7fffffe          BL       HAL_GetTick
00009e  1b00              SUBS     r0,r0,r4              ;532
0000a0  2802              CMP      r0,#2                 ;532
0000a2  d901              BLS      |L1.168|
0000a4  2003              MOVS     r0,#3                 ;534
0000a6  e7d5              B        |L1.84|
                  |L1.168|
0000a8  480e              LDR      r0,|L1.228|
0000aa  3840              SUBS     r0,r0,#0x40           ;530
0000ac  6800              LDR      r0,[r0,#0]            ;530
0000ae  f3c06040          UBFX     r0,r0,#25,#1          ;530
0000b2  2800              CMP      r0,#0                 ;530
0000b4  d0f1              BEQ      |L1.154|
0000b6  f7fffffe          BL       HAL_GetTick
0000ba  4604              MOV      r4,r0                 ;539
0000bc  e007              B        |L1.206|
                  |L1.190|
0000be  f7fffffe          BL       HAL_GetTick
0000c2  1b00              SUBS     r0,r0,r4              ;542
0000c4  f5b07f7a          CMP      r0,#0x3e8             ;542
0000c8  d901              BLS      |L1.206|
0000ca  2003              MOVS     r0,#3                 ;544
0000cc  e7c2              B        |L1.84|
                  |L1.206|
0000ce  4806              LDR      r0,|L1.232|
0000d0  6840              LDR      r0,[r0,#4]            ;540
0000d2  f3c03080          UBFX     r0,r0,#14,#1          ;540
0000d6  2800              CMP      r0,#0                 ;540
0000d8  d0f1              BEQ      |L1.190|
0000da  e001              B        |L1.224|
                  |L1.220|
0000dc  2001              MOVS     r0,#1                 ;550
0000de  e7b9              B        |L1.84|
                  |L1.224|
0000e0  2000              MOVS     r0,#0                 ;552
0000e2  e7b7              B        |L1.84|
;;;554    
                          ENDP

                  |L1.228|
                          DCD      0x40023840
                  |L1.232|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableBkUpReg||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableBkUpReg PROC
;;;181      */
;;;182    HAL_StatusTypeDef HAL_PWREx_DisableBkUpReg(void)
000000  b510              PUSH     {r4,lr}
;;;183    {
;;;184      uint32_t tickstart = 0;
000002  2400              MOVS     r4,#0
;;;185      
;;;186      /* Disable Backup regulator */
;;;187      PWR->CSR1 &= (uint32_t)~((uint32_t)PWR_CSR1_BRE);
000004  480f              LDR      r0,|L2.68|
000006  6840              LDR      r0,[r0,#4]
000008  f4207000          BIC      r0,r0,#0x200
00000c  490d              LDR      r1,|L2.68|
00000e  6048              STR      r0,[r1,#4]
;;;188      
;;;189      /* Workaround for the following hardware bug: */
;;;190      /* Id 19: PWR : No STANDBY wake-up when Back-up RAM enabled (ref. Errata Sheet p23) */
;;;191      PWR->CSR1 |= PWR_CSR1_EIWUP;
000010  4608              MOV      r0,r1
000012  6840              LDR      r0,[r0,#4]
000014  f4407080          ORR      r0,r0,#0x100
000018  6048              STR      r0,[r1,#4]
;;;192    
;;;193      /* Get tick */
;;;194      tickstart = HAL_GetTick();
00001a  f7fffffe          BL       HAL_GetTick
00001e  4604              MOV      r4,r0
;;;195    
;;;196      /* Wait till Backup regulator ready flag is set */  
;;;197      while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) != RESET)
000020  e007              B        |L2.50|
                  |L2.34|
;;;198      {
;;;199        if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)
000022  f7fffffe          BL       HAL_GetTick
000026  1b00              SUBS     r0,r0,r4
000028  f5b07f7a          CMP      r0,#0x3e8
00002c  d901              BLS      |L2.50|
;;;200        {
;;;201          return HAL_TIMEOUT;
00002e  2003              MOVS     r0,#3
                  |L2.48|
;;;202        } 
;;;203      }
;;;204      return HAL_OK;
;;;205    }
000030  bd10              POP      {r4,pc}
                  |L2.50|
000032  4804              LDR      r0,|L2.68|
000034  6840              LDR      r0,[r0,#4]            ;197
000036  f3c000c0          UBFX     r0,r0,#3,#1           ;197
00003a  2800              CMP      r0,#0                 ;197
00003c  d1f1              BNE      |L2.34|
00003e  bf00              NOP                            ;204
000040  e7f6              B        |L2.48|
;;;206    
                          ENDP

000042  0000              DCW      0x0000
                  |L2.68|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableFlashPowerDown||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableFlashPowerDown PROC
;;;220      */
;;;221    void HAL_PWREx_DisableFlashPowerDown(void)
000000  4803              LDR      r0,|L3.16|
;;;222    {
;;;223      /* Disable the Flash Power Down */
;;;224      PWR->CR1 &= (uint32_t)~((uint32_t)PWR_CR1_FPDS);
000002  6800              LDR      r0,[r0,#0]
000004  f4207000          BIC      r0,r0,#0x200
000008  4901              LDR      r1,|L3.16|
00000a  6008              STR      r0,[r1,#0]
;;;225    }
00000c  4770              BX       lr
;;;226    
                          ENDP

00000e  0000              DCW      0x0000
                  |L3.16|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableLowRegulatorLowVoltage||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableLowRegulatorLowVoltage PROC
;;;260      */
;;;261    void HAL_PWREx_DisableLowRegulatorLowVoltage(void)
000000  4803              LDR      r0,|L4.16|
;;;262    {
;;;263      /* Disable low power regulator */
;;;264      PWR->CR1 &= (uint32_t)~((uint32_t)PWR_CR1_LPUDS);
000002  6800              LDR      r0,[r0,#0]
000004  f4206080          BIC      r0,r0,#0x400
000008  4901              LDR      r1,|L4.16|
00000a  6008              STR      r0,[r1,#0]
;;;265    }
00000c  4770              BX       lr
;;;266    
                          ENDP

00000e  0000              DCW      0x0000
                  |L4.16|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableMainRegulatorLowVoltage||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableMainRegulatorLowVoltage PROC
;;;240      */
;;;241    void HAL_PWREx_DisableMainRegulatorLowVoltage(void)
000000  4803              LDR      r0,|L5.16|
;;;242    {  
;;;243      /* Disable Main regulator low voltage */
;;;244      PWR->CR1 &= (uint32_t)~((uint32_t)PWR_CR1_MRUDS);
000002  6800              LDR      r0,[r0,#0]
000004  f4206000          BIC      r0,r0,#0x800
000008  4901              LDR      r1,|L5.16|
00000a  6008              STR      r0,[r1,#0]
;;;245    }
00000c  4770              BX       lr
;;;246    
                          ENDP

00000e  0000              DCW      0x0000
                  |L5.16|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableOverDrive||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableOverDrive PROC
;;;322      */
;;;323    HAL_StatusTypeDef HAL_PWREx_DisableOverDrive(void)
000000  b538              PUSH     {r3-r5,lr}
;;;324    {
;;;325      uint32_t tickstart = 0;
000002  2400              MOVS     r4,#0
;;;326      
;;;327      __HAL_RCC_PWR_CLK_ENABLE();
000004  bf00              NOP      
000006  4820              LDR      r0,|L6.136|
000008  6800              LDR      r0,[r0,#0]
00000a  f0405080          ORR      r0,r0,#0x10000000
00000e  491e              LDR      r1,|L6.136|
000010  6008              STR      r0,[r1,#0]
000012  4608              MOV      r0,r1
000014  6800              LDR      r0,[r0,#0]
000016  f0005080          AND      r0,r0,#0x10000000
00001a  9000              STR      r0,[sp,#0]
00001c  bf00              NOP      
00001e  bf00              NOP      
;;;328        
;;;329      /* Disable the Over-drive switch */
;;;330      __HAL_PWR_OVERDRIVESWITCHING_DISABLE();
000020  481a              LDR      r0,|L6.140|
000022  6800              LDR      r0,[r0,#0]
000024  f4203000          BIC      r0,r0,#0x20000
000028  4918              LDR      r1,|L6.140|
00002a  6008              STR      r0,[r1,#0]
;;;331      
;;;332      /* Get tick */
;;;333      tickstart = HAL_GetTick();
00002c  f7fffffe          BL       HAL_GetTick
000030  4604              MOV      r4,r0
;;;334     
;;;335      while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
000032  e007              B        |L6.68|
                  |L6.52|
;;;336      {
;;;337        if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
000034  f7fffffe          BL       HAL_GetTick
000038  1b00              SUBS     r0,r0,r4
00003a  f5b07f7a          CMP      r0,#0x3e8
00003e  d901              BLS      |L6.68|
;;;338        {
;;;339          return HAL_TIMEOUT;
000040  2003              MOVS     r0,#3
                  |L6.66|
;;;340        }
;;;341      } 
;;;342      
;;;343      /* Disable the Over-drive */
;;;344      __HAL_PWR_OVERDRIVE_DISABLE();
;;;345    
;;;346      /* Get tick */
;;;347      tickstart = HAL_GetTick();
;;;348    
;;;349      while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
;;;350      {
;;;351        if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
;;;352        {
;;;353          return HAL_TIMEOUT;
;;;354        }
;;;355      }
;;;356      
;;;357      return HAL_OK;
;;;358    }
000042  bd38              POP      {r3-r5,pc}
                  |L6.68|
000044  4811              LDR      r0,|L6.140|
000046  6840              LDR      r0,[r0,#4]            ;335
000048  f4003000          AND      r0,r0,#0x20000        ;335
00004c  f5b03f00          CMP      r0,#0x20000           ;335
000050  d0f0              BEQ      |L6.52|
000052  480e              LDR      r0,|L6.140|
000054  6800              LDR      r0,[r0,#0]            ;344
000056  f4203080          BIC      r0,r0,#0x10000        ;344
00005a  490c              LDR      r1,|L6.140|
00005c  6008              STR      r0,[r1,#0]            ;344
00005e  f7fffffe          BL       HAL_GetTick
000062  4604              MOV      r4,r0                 ;347
000064  e007              B        |L6.118|
                  |L6.102|
000066  f7fffffe          BL       HAL_GetTick
00006a  1b00              SUBS     r0,r0,r4              ;351
00006c  f5b07f7a          CMP      r0,#0x3e8             ;351
000070  d901              BLS      |L6.118|
000072  2003              MOVS     r0,#3                 ;353
000074  e7e5              B        |L6.66|
                  |L6.118|
000076  4805              LDR      r0,|L6.140|
000078  6840              LDR      r0,[r0,#4]            ;349
00007a  f4003080          AND      r0,r0,#0x10000        ;349
00007e  f5b03f80          CMP      r0,#0x10000           ;349
000082  d0f0              BEQ      |L6.102|
000084  2000              MOVS     r0,#0                 ;357
000086  e7dc              B        |L6.66|
;;;359    
                          ENDP

                  |L6.136|
                          DCD      0x40023840
                  |L6.140|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableBkUpReg||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableBkUpReg PROC
;;;152      */
;;;153    HAL_StatusTypeDef HAL_PWREx_EnableBkUpReg(void)
000000  b510              PUSH     {r4,lr}
;;;154    {
;;;155      uint32_t tickstart = 0;
000002  2400              MOVS     r4,#0
;;;156    
;;;157      /* Enable Backup regulator */
;;;158      PWR->CSR1 |= PWR_CSR1_BRE;
000004  480f              LDR      r0,|L7.68|
000006  6840              LDR      r0,[r0,#4]
000008  f4407000          ORR      r0,r0,#0x200
00000c  490d              LDR      r1,|L7.68|
00000e  6048              STR      r0,[r1,#4]
;;;159        
;;;160      /* Workaround for the following hardware bug: */
;;;161      /* Id 19: PWR : No STANDBY wake-up when Back-up RAM enabled (ref. Errata Sheet p23) */
;;;162      PWR->CSR1 |= PWR_CSR1_EIWUP;
000010  4608              MOV      r0,r1
000012  6840              LDR      r0,[r0,#4]
000014  f4407080          ORR      r0,r0,#0x100
000018  6048              STR      r0,[r1,#4]
;;;163    
;;;164      /* Get tick */
;;;165      tickstart = HAL_GetTick();
00001a  f7fffffe          BL       HAL_GetTick
00001e  4604              MOV      r4,r0
;;;166    
;;;167      /* Wait till Backup regulator ready flag is set */  
;;;168      while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) == RESET)
000020  e007              B        |L7.50|
                  |L7.34|
;;;169      {
;;;170        if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)
000022  f7fffffe          BL       HAL_GetTick
000026  1b00              SUBS     r0,r0,r4
000028  f5b07f7a          CMP      r0,#0x3e8
00002c  d901              BLS      |L7.50|
;;;171        {
;;;172          return HAL_TIMEOUT;
00002e  2003              MOVS     r0,#3
                  |L7.48|
;;;173        } 
;;;174      }
;;;175      return HAL_OK;
;;;176    }
000030  bd10              POP      {r4,pc}
                  |L7.50|
000032  4804              LDR      r0,|L7.68|
000034  6840              LDR      r0,[r0,#4]            ;168
000036  f3c000c0          UBFX     r0,r0,#3,#1           ;168
00003a  2800              CMP      r0,#0                 ;168
00003c  d0f1              BEQ      |L7.34|
00003e  2000              MOVS     r0,#0                 ;175
000040  e7f6              B        |L7.48|
;;;177    
                          ENDP

000042  0000              DCW      0x0000
                  |L7.68|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableFlashPowerDown||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableFlashPowerDown PROC
;;;210      */
;;;211    void HAL_PWREx_EnableFlashPowerDown(void)
000000  4803              LDR      r0,|L8.16|
;;;212    {
;;;213      /* Enable the Flash Power Down */
;;;214      PWR->CR1 |= PWR_CR1_FPDS;
000002  6800              LDR      r0,[r0,#0]
000004  f4407000          ORR      r0,r0,#0x200
000008  4901              LDR      r1,|L8.16|
00000a  6008              STR      r0,[r1,#0]
;;;215    }
00000c  4770              BX       lr
;;;216    
                          ENDP

00000e  0000              DCW      0x0000
                  |L8.16|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableLowRegulatorLowVoltage||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableLowRegulatorLowVoltage PROC
;;;250      */
;;;251    void HAL_PWREx_EnableLowRegulatorLowVoltage(void)
000000  4803              LDR      r0,|L9.16|
;;;252    {
;;;253      /* Enable low power regulator */
;;;254      PWR->CR1 |= PWR_CR1_LPUDS;
000002  6800              LDR      r0,[r0,#0]
000004  f4406080          ORR      r0,r0,#0x400
000008  4901              LDR      r1,|L9.16|
00000a  6008              STR      r0,[r1,#0]
;;;255    }
00000c  4770              BX       lr
;;;256    
                          ENDP

00000e  0000              DCW      0x0000
                  |L9.16|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableMainRegulatorLowVoltage||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableMainRegulatorLowVoltage PROC
;;;230      */
;;;231    void HAL_PWREx_EnableMainRegulatorLowVoltage(void)
000000  4803              LDR      r0,|L10.16|
;;;232    {
;;;233      /* Enable Main regulator low voltage */
;;;234      PWR->CR1 |= PWR_CR1_MRUDS;
000002  6800              LDR      r0,[r0,#0]
000004  f4406000          ORR      r0,r0,#0x800
000008  4901              LDR      r1,|L10.16|
00000a  6008              STR      r0,[r1,#0]
;;;235    }
00000c  4770              BX       lr
;;;236    
                          ENDP

00000e  0000              DCW      0x0000
                  |L10.16|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableOverDrive||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableOverDrive PROC
;;;276      */
;;;277    HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
000000  b538              PUSH     {r3-r5,lr}
;;;278    {
;;;279      uint32_t tickstart = 0;
000002  2400              MOVS     r4,#0
;;;280    
;;;281      __HAL_RCC_PWR_CLK_ENABLE();
000004  bf00              NOP      
000006  4820              LDR      r0,|L11.136|
000008  6800              LDR      r0,[r0,#0]
00000a  f0405080          ORR      r0,r0,#0x10000000
00000e  491e              LDR      r1,|L11.136|
000010  6008              STR      r0,[r1,#0]
000012  4608              MOV      r0,r1
000014  6800              LDR      r0,[r0,#0]
000016  f0005080          AND      r0,r0,#0x10000000
00001a  9000              STR      r0,[sp,#0]
00001c  bf00              NOP      
00001e  bf00              NOP      
;;;282      
;;;283      /* Enable the Over-drive to extend the clock frequency to 216 MHz */
;;;284      __HAL_PWR_OVERDRIVE_ENABLE();
000020  481a              LDR      r0,|L11.140|
000022  6800              LDR      r0,[r0,#0]
000024  f4403080          ORR      r0,r0,#0x10000
000028  4918              LDR      r1,|L11.140|
00002a  6008              STR      r0,[r1,#0]
;;;285    
;;;286      /* Get tick */
;;;287      tickstart = HAL_GetTick();
00002c  f7fffffe          BL       HAL_GetTick
000030  4604              MOV      r4,r0
;;;288    
;;;289      while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
000032  e007              B        |L11.68|
                  |L11.52|
;;;290      {
;;;291        if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
000034  f7fffffe          BL       HAL_GetTick
000038  1b00              SUBS     r0,r0,r4
00003a  f5b07f7a          CMP      r0,#0x3e8
00003e  d901              BLS      |L11.68|
;;;292        {
;;;293          return HAL_TIMEOUT;
000040  2003              MOVS     r0,#3
                  |L11.66|
;;;294        }
;;;295      }
;;;296      
;;;297      /* Enable the Over-drive switch */
;;;298      __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
;;;299    
;;;300      /* Get tick */
;;;301      tickstart = HAL_GetTick();
;;;302    
;;;303      while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
;;;304      {
;;;305        if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
;;;306        {
;;;307          return HAL_TIMEOUT;
;;;308        }
;;;309      } 
;;;310      return HAL_OK;
;;;311    }
000042  bd38              POP      {r3-r5,pc}
                  |L11.68|
000044  4811              LDR      r0,|L11.140|
000046  6840              LDR      r0,[r0,#4]            ;289
000048  f4003080          AND      r0,r0,#0x10000        ;289
00004c  f5b03f80          CMP      r0,#0x10000           ;289
000050  d1f0              BNE      |L11.52|
000052  480e              LDR      r0,|L11.140|
000054  6800              LDR      r0,[r0,#0]            ;298
000056  f4403000          ORR      r0,r0,#0x20000        ;298
00005a  490c              LDR      r1,|L11.140|
00005c  6008              STR      r0,[r1,#0]            ;298
00005e  f7fffffe          BL       HAL_GetTick
000062  4604              MOV      r4,r0                 ;301
000064  e007              B        |L11.118|
                  |L11.102|
000066  f7fffffe          BL       HAL_GetTick
00006a  1b00              SUBS     r0,r0,r4              ;305
00006c  f5b07f7a          CMP      r0,#0x3e8             ;305
000070  d901              BLS      |L11.118|
000072  2003              MOVS     r0,#3                 ;307
000074  e7e5              B        |L11.66|
                  |L11.118|
000076  4805              LDR      r0,|L11.140|
000078  6840              LDR      r0,[r0,#4]            ;303
00007a  f4003000          AND      r0,r0,#0x20000        ;303
00007e  f5b03f00          CMP      r0,#0x20000           ;303
000082  d1f0              BNE      |L11.102|
000084  2000              MOVS     r0,#0                 ;310
000086  e7dc              B        |L11.66|
;;;312    
                          ENDP

                  |L11.136|
                          DCD      0x40023840
                  |L11.140|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnterUnderDriveSTOPMode||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnterUnderDriveSTOPMode PROC
;;;396      */
;;;397    HAL_StatusTypeDef HAL_PWREx_EnterUnderDriveSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
000000  b5f8              PUSH     {r3-r7,lr}
;;;398    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;399      uint32_t tempreg = 0;
000006  2400              MOVS     r4,#0
;;;400      uint32_t tickstart = 0;
000008  2700              MOVS     r7,#0
;;;401      
;;;402      /* Check the parameters */
;;;403      assert_param(IS_PWR_REGULATOR_UNDERDRIVE(Regulator));
;;;404      assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
;;;405      
;;;406      /* Enable Power ctrl clock */
;;;407      __HAL_RCC_PWR_CLK_ENABLE();
00000a  bf00              NOP      
00000c  4822              LDR      r0,|L12.152|
00000e  6800              LDR      r0,[r0,#0]
000010  f0405080          ORR      r0,r0,#0x10000000
000014  4920              LDR      r1,|L12.152|
000016  6008              STR      r0,[r1,#0]
000018  4608              MOV      r0,r1
00001a  6800              LDR      r0,[r0,#0]
00001c  f0005080          AND      r0,r0,#0x10000000
000020  9000              STR      r0,[sp,#0]
000022  bf00              NOP      
000024  bf00              NOP      
;;;408      /* Enable the Under-drive Mode ---------------------------------------------*/
;;;409      /* Clear Under-drive flag */
;;;410      __HAL_PWR_CLEAR_ODRUDR_FLAG();
000026  481d              LDR      r0,|L12.156|
000028  6840              LDR      r0,[r0,#4]
00002a  f4402040          ORR      r0,r0,#0xc0000
00002e  491b              LDR      r1,|L12.156|
000030  6048              STR      r0,[r1,#4]
;;;411      
;;;412      /* Enable the Under-drive */ 
;;;413      __HAL_PWR_UNDERDRIVE_ENABLE();
000032  4608              MOV      r0,r1
000034  6800              LDR      r0,[r0,#0]
000036  f4402040          ORR      r0,r0,#0xc0000
00003a  6008              STR      r0,[r1,#0]
;;;414    
;;;415      /* Get tick */
;;;416      tickstart = HAL_GetTick();
00003c  f7fffffe          BL       HAL_GetTick
000040  4607              MOV      r7,r0
;;;417    
;;;418      /* Wait for UnderDrive mode is ready */
;;;419      while(__HAL_PWR_GET_FLAG(PWR_FLAG_UDRDY))
000042  e007              B        |L12.84|
                  |L12.68|
;;;420      {
;;;421        if((HAL_GetTick() - tickstart ) > PWR_UDERDRIVE_TIMEOUT_VALUE)
000044  f7fffffe          BL       HAL_GetTick
000048  1bc0              SUBS     r0,r0,r7
00004a  f5b07f7a          CMP      r0,#0x3e8
00004e  d901              BLS      |L12.84|
;;;422        {
;;;423          return HAL_TIMEOUT;
000050  2003              MOVS     r0,#3
                  |L12.82|
;;;424        }
;;;425      }
;;;426      
;;;427      /* Select the regulator state in STOP mode ---------------------------------*/
;;;428      tempreg = PWR->CR1;
;;;429      /* Clear PDDS, LPDS, MRLUDS and LPLUDS bits */
;;;430      tempreg &= (uint32_t)~(PWR_CR1_PDDS | PWR_CR1_LPDS | PWR_CR1_LPUDS | PWR_CR1_MRUDS);
;;;431      
;;;432      /* Set LPDS, MRLUDS and LPLUDS bits according to PWR_Regulator value */
;;;433      tempreg |= Regulator;
;;;434      
;;;435      /* Store the new value */
;;;436      PWR->CR1 = tempreg;
;;;437      
;;;438      /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;439      SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
;;;440      
;;;441      /* Select STOP mode entry --------------------------------------------------*/
;;;442      if(STOPEntry == PWR_SLEEPENTRY_WFI)
;;;443      {   
;;;444        /* Request Wait For Interrupt */
;;;445        __WFI();
;;;446      }
;;;447      else
;;;448      {
;;;449        /* Request Wait For Event */
;;;450        __WFE();
;;;451      }
;;;452      /* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;453      SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
;;;454    
;;;455      return HAL_OK;  
;;;456    }
000052  bdf8              POP      {r3-r7,pc}
                  |L12.84|
000054  4811              LDR      r0,|L12.156|
000056  6840              LDR      r0,[r0,#4]            ;419
000058  f4002040          AND      r0,r0,#0xc0000        ;419
00005c  f5b02f40          CMP      r0,#0xc0000           ;419
000060  d0f0              BEQ      |L12.68|
000062  480e              LDR      r0,|L12.156|
000064  6804              LDR      r4,[r0,#0]            ;428
000066  f6404003          MOV      r0,#0xc03             ;430
00006a  4384              BICS     r4,r4,r0              ;430
00006c  432c              ORRS     r4,r4,r5              ;433
00006e  480b              LDR      r0,|L12.156|
000070  6004              STR      r4,[r0,#0]            ;436
000072  480b              LDR      r0,|L12.160|
000074  6800              LDR      r0,[r0,#0]            ;439
000076  f0400004          ORR      r0,r0,#4              ;439
00007a  4909              LDR      r1,|L12.160|
00007c  6008              STR      r0,[r1,#0]            ;439
00007e  2e01              CMP      r6,#1                 ;442
000080  d101              BNE      |L12.134|
000082  bf30              WFI                            ;445
000084  e000              B        |L12.136|
                  |L12.134|
000086  bf20              WFE                            ;450
                  |L12.136|
000088  4805              LDR      r0,|L12.160|
00008a  6800              LDR      r0,[r0,#0]            ;453
00008c  f0200004          BIC      r0,r0,#4              ;453
000090  4903              LDR      r1,|L12.160|
000092  6008              STR      r0,[r1,#0]            ;453
000094  2000              MOVS     r0,#0                 ;455
000096  e7dc              B        |L12.82|
;;;457    
                          ENDP

                  |L12.152|
                          DCD      0x40023840
                  |L12.156|
                          DCD      0x40007000
                  |L12.160|
                          DCD      0xe000ed10

                          AREA ||i.HAL_PWREx_GetVoltageRange||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_GetVoltageRange PROC
;;;462      */  
;;;463    uint32_t HAL_PWREx_GetVoltageRange(void)
000000  4802              LDR      r0,|L13.12|
;;;464    {
;;;465      return  (PWR->CR1 & PWR_CR1_VOS);
000002  6800              LDR      r0,[r0,#0]
000004  f4004040          AND      r0,r0,#0xc000
;;;466    }
000008  4770              BX       lr
;;;467    
                          ENDP

00000a  0000              DCW      0x0000
                  |L13.12|
                          DCD      0x40007000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_pwr_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f7xx_hal_pwr_ex_c_1028ebfa____REV16|
#line 388 "..\\..\\..\\..\\Library\\STM32F7xx_HAL_Driver\\Core\\cmsis_armcc.h"
|__asm___22_stm32f7xx_hal_pwr_ex_c_1028ebfa____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f7xx_hal_pwr_ex_c_1028ebfa____REVSH|
#line 402
|__asm___22_stm32f7xx_hal_pwr_ex_c_1028ebfa____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f7xx_hal_pwr_ex_c_1028ebfa____RRX|
#line 587
|__asm___22_stm32f7xx_hal_pwr_ex_c_1028ebfa____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
