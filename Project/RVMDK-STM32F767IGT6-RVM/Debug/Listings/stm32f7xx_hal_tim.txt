; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f7xx_hal_tim.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f7xx_hal_tim.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\..\Library\STM32F7xx_HAL_Driver\Core -I..\..\..\..\Library\STM32F7xx_HAL_Driver\Inc -I..\..\..\..\Library\STM32F7xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\32-Bit_MCU\STM32\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f7xx_hal_tim.crf ..\..\..\..\Library\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_tim.c]
                          THUMB

                          AREA ||i.HAL_TIM_Base_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_DeInit PROC
;;;237      */
;;;238    HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;239    {  
000002  4604              MOV      r4,r0
;;;240      /* Check the parameters */
;;;241      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;242    
;;;243      htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  63e0              STR      r0,[r4,#0x3c]
;;;244       
;;;245      /* Disable the TIM Peripheral Clock */
;;;246      __HAL_TIM_DISABLE(htim);
000008  bf00              NOP      
00000a  6820              LDR      r0,[r4,#0]
00000c  6a00              LDR      r0,[r0,#0x20]
00000e  f2411111          MOV      r1,#0x1111
000012  4008              ANDS     r0,r0,r1
000014  b950              CBNZ     r0,|L1.44|
000016  6820              LDR      r0,[r4,#0]
000018  6a00              LDR      r0,[r0,#0x20]
00001a  1089              ASRS     r1,r1,#2
00001c  4008              ANDS     r0,r0,r1
00001e  b928              CBNZ     r0,|L1.44|
000020  6820              LDR      r0,[r4,#0]
000022  6800              LDR      r0,[r0,#0]
000024  f0200001          BIC      r0,r0,#1
000028  6821              LDR      r1,[r4,#0]
00002a  6008              STR      r0,[r1,#0]
                  |L1.44|
00002c  bf00              NOP      
;;;247        
;;;248      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;249      HAL_TIM_Base_MspDeInit(htim);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       HAL_TIM_Base_MspDeInit
;;;250      
;;;251      /* Change TIM state */  
;;;252      htim->State = HAL_TIM_STATE_RESET; 
000034  2000              MOVS     r0,#0
000036  63e0              STR      r0,[r4,#0x3c]
;;;253      
;;;254      /* Release Lock */
;;;255      __HAL_UNLOCK(htim);
000038  bf00              NOP      
00003a  63a0              STR      r0,[r4,#0x38]
00003c  bf00              NOP      
;;;256    
;;;257      return HAL_OK;
;;;258    }
00003e  bd10              POP      {r4,pc}
;;;259    
                          ENDP


                          AREA ||i.HAL_TIM_Base_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_GetState PROC
;;;4536     */
;;;4537   HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;4538   {
;;;4539     return htim->State;
000002  6bc8              LDR      r0,[r1,#0x3c]
;;;4540   }
000004  4770              BX       lr
;;;4541   
                          ENDP


                          AREA ||i.HAL_TIM_Base_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Init PROC
;;;200      */
;;;201    HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;202    { 
000002  4604              MOV      r4,r0
;;;203      /* Check the TIM handle allocation */
;;;204      if(htim == NULL)
000004  b90c              CBNZ     r4,|L3.10|
;;;205      {
;;;206        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L3.8|
;;;207      }
;;;208      
;;;209      /* Check the parameters */
;;;210      assert_param(IS_TIM_INSTANCE(htim->Instance)); 
;;;211      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;212      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;213      
;;;214      if(htim->State == HAL_TIM_STATE_RESET)
;;;215      {  
;;;216        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;217        HAL_TIM_Base_MspInit(htim);
;;;218      }
;;;219      
;;;220      /* Set the TIM state */
;;;221      htim->State= HAL_TIM_STATE_BUSY;
;;;222      
;;;223      /* Set the Time Base configuration */
;;;224      TIM_Base_SetConfig(htim->Instance, &htim->Init); 
;;;225      
;;;226      /* Initialize the TIM state*/
;;;227      htim->State= HAL_TIM_STATE_READY;
;;;228      
;;;229      return HAL_OK;
;;;230    }
000008  bd10              POP      {r4,pc}
                  |L3.10|
00000a  6be0              LDR      r0,[r4,#0x3c]         ;214
00000c  b910              CBNZ     r0,|L3.20|
00000e  4620              MOV      r0,r4                 ;217
000010  f7fffffe          BL       HAL_TIM_Base_MspInit
                  |L3.20|
000014  2002              MOVS     r0,#2                 ;221
000016  63e0              STR      r0,[r4,#0x3c]         ;221
000018  1d21              ADDS     r1,r4,#4              ;224
00001a  6820              LDR      r0,[r4,#0]            ;224
00001c  f7fffffe          BL       TIM_Base_SetConfig
000020  2001              MOVS     r0,#1                 ;227
000022  63e0              STR      r0,[r4,#0x3c]         ;227
000024  2000              MOVS     r0,#0                 ;229
000026  e7ef              B        |L3.8|
;;;231    
                          ENDP


                          AREA ||i.HAL_TIM_Base_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_MspDeInit PROC
;;;281      */
;;;282    __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;283    {
;;;284      /* Prevent unused argument(s) compilation warning */
;;;285      UNUSED(htim);
;;;286     
;;;287      /* NOTE : This function Should not be modified, when the callback is needed,
;;;288                the HAL_TIM_Base_MspDeInit could be implemented in the user file
;;;289       */
;;;290    }
;;;291    
                          ENDP


                          AREA ||i.HAL_TIM_Base_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_MspInit PROC
;;;265      */
;;;266    __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;267    {
;;;268      /* Prevent unused argument(s) compilation warning */
;;;269      UNUSED(htim);
;;;270     
;;;271      /* NOTE : This function Should not be modified, when the callback is needed,
;;;272                the HAL_TIM_Base_MspInit could be implemented in the user file
;;;273       */
;;;274    }
;;;275    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Start PROC
;;;297      */
;;;298    HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;299    {
;;;300      /* Check the parameters */
;;;301      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;302      
;;;303      /* Set the TIM state */
;;;304      htim->State= HAL_TIM_STATE_BUSY;
000002  2002              MOVS     r0,#2
000004  63c8              STR      r0,[r1,#0x3c]
;;;305      
;;;306      /* Enable the Peripheral */
;;;307      __HAL_TIM_ENABLE(htim);
000006  6808              LDR      r0,[r1,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  f0400001          ORR      r0,r0,#1
00000e  680a              LDR      r2,[r1,#0]
000010  6010              STR      r0,[r2,#0]
;;;308      
;;;309      /* Change the TIM state*/
;;;310      htim->State= HAL_TIM_STATE_READY;
000012  2001              MOVS     r0,#1
000014  63c8              STR      r0,[r1,#0x3c]
;;;311      
;;;312      /* Return function status */
;;;313      return HAL_OK;
000016  2000              MOVS     r0,#0
;;;314    }
000018  4770              BX       lr
;;;315    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Base_Start_DMA PROC
;;;388      */
;;;389    HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;390    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;391      /* Check the parameters */
;;;392      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance)); 
;;;393      
;;;394      if((htim->State == HAL_TIM_STATE_BUSY))
000008  6be0              LDR      r0,[r4,#0x3c]
00000a  2802              CMP      r0,#2
00000c  d100              BNE      |L7.16|
                  |L7.14|
;;;395      {
;;;396         return HAL_BUSY;
;;;397      }
;;;398      else if((htim->State == HAL_TIM_STATE_READY))
;;;399      {
;;;400        if((pData == 0 ) && (Length > 0)) 
;;;401        {
;;;402          return HAL_ERROR;                                    
;;;403        }
;;;404        else
;;;405        {
;;;406          htim->State = HAL_TIM_STATE_BUSY;
;;;407        }
;;;408      }  
;;;409      /* Set the DMA Period elapsed callback */
;;;410      htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;411         
;;;412      /* Set the DMA error callback */
;;;413      htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = HAL_TIM_DMAError ;
;;;414      
;;;415      /* Enable the DMA Stream */
;;;416      HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length);
;;;417      
;;;418      /* Enable the TIM Update DMA request */
;;;419      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
;;;420    
;;;421      /* Enable the Peripheral */
;;;422      __HAL_TIM_ENABLE(htim);  
;;;423      
;;;424      /* Return function status */
;;;425      return HAL_OK;
;;;426    }
00000e  bd70              POP      {r4-r6,pc}
                  |L7.16|
000010  6be0              LDR      r0,[r4,#0x3c]         ;398
000012  2801              CMP      r0,#1                 ;398
000014  d105              BNE      |L7.34|
000016  b916              CBNZ     r6,|L7.30|
000018  2d00              CMP      r5,#0                 ;400
00001a  dd00              BLE      |L7.30|
00001c  e7f7              B        |L7.14|
                  |L7.30|
00001e  2002              MOVS     r0,#2                 ;406
000020  63e0              STR      r0,[r4,#0x3c]         ;406
                  |L7.34|
000022  480e              LDR      r0,|L7.92|
000024  69e1              LDR      r1,[r4,#0x1c]         ;410
000026  6408              STR      r0,[r1,#0x40]         ;410
000028  480d              LDR      r0,|L7.96|
00002a  69e1              LDR      r1,[r4,#0x1c]         ;413
00002c  6508              STR      r0,[r1,#0x50]         ;413
00002e  6821              LDR      r1,[r4,#0]            ;416
000030  f101022c          ADD      r2,r1,#0x2c           ;416
000034  462b              MOV      r3,r5                 ;416
000036  4631              MOV      r1,r6                 ;416
000038  69e0              LDR      r0,[r4,#0x1c]         ;416
00003a  f7fffffe          BL       HAL_DMA_Start_IT
00003e  6820              LDR      r0,[r4,#0]            ;419
000040  68c0              LDR      r0,[r0,#0xc]          ;419
000042  f4407080          ORR      r0,r0,#0x100          ;419
000046  6821              LDR      r1,[r4,#0]            ;419
000048  60c8              STR      r0,[r1,#0xc]          ;419
00004a  6820              LDR      r0,[r4,#0]            ;422
00004c  6800              LDR      r0,[r0,#0]            ;422
00004e  f0400001          ORR      r0,r0,#1              ;422
000052  6821              LDR      r1,[r4,#0]            ;422
000054  6008              STR      r0,[r1,#0]            ;422
000056  2000              MOVS     r0,#0                 ;425
000058  e7d9              B        |L7.14|
;;;427    
                          ENDP

00005a  0000              DCW      0x0000
                  |L7.92|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L7.96|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_Base_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Start_IT PROC
;;;345      */
;;;346    HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;347    {
;;;348      /* Check the parameters */
;;;349      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;350      
;;;351      /* Enable the TIM Update interrupt */
;;;352      __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
000002  6808              LDR      r0,[r1,#0]
000004  68c0              LDR      r0,[r0,#0xc]
000006  f0400001          ORR      r0,r0,#1
00000a  680a              LDR      r2,[r1,#0]
00000c  60d0              STR      r0,[r2,#0xc]
;;;353          
;;;354      /* Enable the Peripheral */
;;;355      __HAL_TIM_ENABLE(htim);
00000e  6808              LDR      r0,[r1,#0]
000010  6800              LDR      r0,[r0,#0]
000012  f0400001          ORR      r0,r0,#1
000016  680a              LDR      r2,[r1,#0]
000018  6010              STR      r0,[r2,#0]
;;;356          
;;;357      /* Return function status */
;;;358      return HAL_OK;
00001a  2000              MOVS     r0,#0
;;;359    }
00001c  4770              BX       lr
;;;360    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop PROC
;;;321      */
;;;322    HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;323    {
;;;324      /* Check the parameters */
;;;325      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;326      
;;;327      /* Set the TIM state */
;;;328      htim->State= HAL_TIM_STATE_BUSY;
000002  2002              MOVS     r0,#2
000004  63c8              STR      r0,[r1,#0x3c]
;;;329      
;;;330      /* Disable the Peripheral */
;;;331      __HAL_TIM_DISABLE(htim);
000006  bf00              NOP      
000008  6808              LDR      r0,[r1,#0]
00000a  6a00              LDR      r0,[r0,#0x20]
00000c  f2411211          MOV      r2,#0x1111
000010  4010              ANDS     r0,r0,r2
000012  b950              CBNZ     r0,|L9.42|
000014  6808              LDR      r0,[r1,#0]
000016  6a00              LDR      r0,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4010              ANDS     r0,r0,r2
00001c  b928              CBNZ     r0,|L9.42|
00001e  6808              LDR      r0,[r1,#0]
000020  6800              LDR      r0,[r0,#0]
000022  f0200001          BIC      r0,r0,#1
000026  680a              LDR      r2,[r1,#0]
000028  6010              STR      r0,[r2,#0]
                  |L9.42|
00002a  bf00              NOP      
;;;332      
;;;333      /* Change the TIM state*/
;;;334      htim->State= HAL_TIM_STATE_READY;
00002c  2001              MOVS     r0,#1
00002e  63c8              STR      r0,[r1,#0x3c]
;;;335      
;;;336      /* Return function status */
;;;337      return HAL_OK;
000030  2000              MOVS     r0,#0
;;;338    }
000032  4770              BX       lr
;;;339    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop_DMA PROC
;;;433      */
;;;434    HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;435    {
;;;436      /* Check the parameters */
;;;437      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
;;;438      
;;;439      /* Disable the TIM Update DMA request */
;;;440      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
000002  6808              LDR      r0,[r1,#0]
000004  68c0              LDR      r0,[r0,#0xc]
000006  f4207080          BIC      r0,r0,#0x100
00000a  680a              LDR      r2,[r1,#0]
00000c  60d0              STR      r0,[r2,#0xc]
;;;441          
;;;442      /* Disable the Peripheral */
;;;443      __HAL_TIM_DISABLE(htim);
00000e  bf00              NOP      
000010  6808              LDR      r0,[r1,#0]
000012  6a00              LDR      r0,[r0,#0x20]
000014  f2411211          MOV      r2,#0x1111
000018  4010              ANDS     r0,r0,r2
00001a  b950              CBNZ     r0,|L10.50|
00001c  6808              LDR      r0,[r1,#0]
00001e  6a00              LDR      r0,[r0,#0x20]
000020  1092              ASRS     r2,r2,#2
000022  4010              ANDS     r0,r0,r2
000024  b928              CBNZ     r0,|L10.50|
000026  6808              LDR      r0,[r1,#0]
000028  6800              LDR      r0,[r0,#0]
00002a  f0200001          BIC      r0,r0,#1
00002e  680a              LDR      r2,[r1,#0]
000030  6010              STR      r0,[r2,#0]
                  |L10.50|
000032  bf00              NOP      
;;;444        
;;;445      /* Change the htim state */
;;;446      htim->State = HAL_TIM_STATE_READY;
000034  2001              MOVS     r0,#1
000036  63c8              STR      r0,[r1,#0x3c]
;;;447          
;;;448      /* Return function status */
;;;449      return HAL_OK;
000038  2000              MOVS     r0,#0
;;;450    }
00003a  4770              BX       lr
;;;451    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop_IT PROC
;;;366      */
;;;367    HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;368    {
;;;369      /* Check the parameters */
;;;370      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;371      /* Disable the TIM Update interrupt */
;;;372      __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
000002  6808              LDR      r0,[r1,#0]
000004  68c0              LDR      r0,[r0,#0xc]
000006  f0200001          BIC      r0,r0,#1
00000a  680a              LDR      r2,[r1,#0]
00000c  60d0              STR      r0,[r2,#0xc]
;;;373          
;;;374      /* Disable the Peripheral */
;;;375      __HAL_TIM_DISABLE(htim);
00000e  bf00              NOP      
000010  6808              LDR      r0,[r1,#0]
000012  6a00              LDR      r0,[r0,#0x20]
000014  f2411211          MOV      r2,#0x1111
000018  4010              ANDS     r0,r0,r2
00001a  b950              CBNZ     r0,|L11.50|
00001c  6808              LDR      r0,[r1,#0]
00001e  6a00              LDR      r0,[r0,#0x20]
000020  1092              ASRS     r2,r2,#2
000022  4010              ANDS     r0,r0,r2
000024  b928              CBNZ     r0,|L11.50|
000026  6808              LDR      r0,[r1,#0]
000028  6800              LDR      r0,[r0,#0]
00002a  f0200001          BIC      r0,r0,#1
00002e  680a              LDR      r2,[r1,#0]
000030  6010              STR      r0,[r2,#0]
                  |L11.50|
000032  bf00              NOP      
;;;376        
;;;377      /* Return function status */
;;;378      return HAL_OK;
000034  2000              MOVS     r0,#0
;;;379    }
000036  4770              BX       lr
;;;380    
                          ENDP


                          AREA ||i.HAL_TIM_ConfigClockSource||, CODE, READONLY, ALIGN=2

                  HAL_TIM_ConfigClockSource PROC
;;;3959     */ 
;;;3960   HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)    
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3961   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;3962     uint32_t tmpsmcr = 0;
000008  2600              MOVS     r6,#0
;;;3963       
;;;3964     /* Process Locked */
;;;3965     __HAL_LOCK(htim);
00000a  bf00              NOP      
00000c  6ba0              LDR      r0,[r4,#0x38]
00000e  2801              CMP      r0,#1
000010  d102              BNE      |L12.24|
000012  2002              MOVS     r0,#2
                  |L12.20|
;;;3966     
;;;3967     htim->State = HAL_TIM_STATE_BUSY;
;;;3968     
;;;3969     /* Check the parameters */
;;;3970     assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
;;;3971     
;;;3972     /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
;;;3973     tmpsmcr = htim->Instance->SMCR;
;;;3974     tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
;;;3975     tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
;;;3976     htim->Instance->SMCR = tmpsmcr;
;;;3977     
;;;3978     switch (sClockSourceConfig->ClockSource)
;;;3979     {
;;;3980       case TIM_CLOCKSOURCE_INTERNAL:
;;;3981       { 
;;;3982         assert_param(IS_TIM_INSTANCE(htim->Instance));      
;;;3983         /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;3984         htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3985       }
;;;3986       break;
;;;3987       
;;;3988       case TIM_CLOCKSOURCE_ETRMODE1:
;;;3989       {
;;;3990         assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
;;;3991         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;3992         assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
;;;3993         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;3994         /* Configure the ETR Clock source */
;;;3995         TIM_ETR_SetConfig(htim->Instance, 
;;;3996                           sClockSourceConfig->ClockPrescaler, 
;;;3997                           sClockSourceConfig->ClockPolarity, 
;;;3998                           sClockSourceConfig->ClockFilter);
;;;3999         /* Get the TIMx SMCR register value */
;;;4000         tmpsmcr = htim->Instance->SMCR;
;;;4001         /* Reset the SMS and TS Bits */
;;;4002         tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
;;;4003         /* Select the External clock mode1 and the ETRF trigger */
;;;4004         tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
;;;4005         /* Write to TIMx SMCR */
;;;4006         htim->Instance->SMCR = tmpsmcr;
;;;4007       }
;;;4008       break;
;;;4009       
;;;4010       case TIM_CLOCKSOURCE_ETRMODE2:
;;;4011       {
;;;4012         assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
;;;4013         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4014         assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
;;;4015         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4016         
;;;4017         /* Configure the ETR Clock source */
;;;4018         TIM_ETR_SetConfig(htim->Instance, 
;;;4019                           sClockSourceConfig->ClockPrescaler, 
;;;4020                           sClockSourceConfig->ClockPolarity,
;;;4021                           sClockSourceConfig->ClockFilter);
;;;4022         /* Enable the External clock mode2 */
;;;4023         htim->Instance->SMCR |= TIM_SMCR_ECE;
;;;4024       }
;;;4025       break;
;;;4026       
;;;4027       case TIM_CLOCKSOURCE_TI1:
;;;4028       {
;;;4029         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;4030     
;;;4031         /* Check TI1 input conditioning related parameters */
;;;4032         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4033         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4034   
;;;4035         TIM_TI1_ConfigInputStage(htim->Instance, 
;;;4036                           sClockSourceConfig->ClockPolarity, 
;;;4037                           sClockSourceConfig->ClockFilter);
;;;4038         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
;;;4039       }
;;;4040       break;
;;;4041       case TIM_CLOCKSOURCE_TI2:
;;;4042       {
;;;4043         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;4044         
;;;4045         /* Check TI1 input conditioning related parameters */
;;;4046         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4047         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4048   
;;;4049         TIM_TI2_ConfigInputStage(htim->Instance, 
;;;4050                           sClockSourceConfig->ClockPolarity, 
;;;4051                           sClockSourceConfig->ClockFilter);
;;;4052         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
;;;4053       }
;;;4054       break;
;;;4055       case TIM_CLOCKSOURCE_TI1ED:
;;;4056       {
;;;4057         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;4058         /* Check TI1 input conditioning related parameters */
;;;4059         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4060         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4061     
;;;4062         TIM_TI1_ConfigInputStage(htim->Instance, 
;;;4063                           sClockSourceConfig->ClockPolarity,
;;;4064                           sClockSourceConfig->ClockFilter);
;;;4065         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
;;;4066       }
;;;4067       break;
;;;4068       case TIM_CLOCKSOURCE_ITR0:
;;;4069       {
;;;4070         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4071         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR0);
;;;4072       }
;;;4073       break;
;;;4074       case TIM_CLOCKSOURCE_ITR1:
;;;4075       {
;;;4076         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4077         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR1);
;;;4078       }
;;;4079       break;
;;;4080       case TIM_CLOCKSOURCE_ITR2:
;;;4081       {
;;;4082         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4083         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR2);
;;;4084       }
;;;4085       break;
;;;4086       case TIM_CLOCKSOURCE_ITR3:
;;;4087       {
;;;4088         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4089         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR3);
;;;4090       }
;;;4091       break;
;;;4092       
;;;4093       default:
;;;4094       break;    
;;;4095     }
;;;4096     htim->State = HAL_TIM_STATE_READY;
;;;4097     
;;;4098     __HAL_UNLOCK(htim);
;;;4099     
;;;4100     return HAL_OK;
;;;4101   }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L12.24|
000018  2001              MOVS     r0,#1                 ;3965
00001a  63a0              STR      r0,[r4,#0x38]         ;3965
00001c  bf00              NOP                            ;3965
00001e  2002              MOVS     r0,#2                 ;3967
000020  63e0              STR      r0,[r4,#0x3c]         ;3967
000022  6820              LDR      r0,[r4,#0]            ;3973
000024  6886              LDR      r6,[r0,#8]            ;3973
000026  4841              LDR      r0,|L12.300|
000028  4006              ANDS     r6,r6,r0              ;3974
00002a  f426467f          BIC      r6,r6,#0xff00         ;3975
00002e  6820              LDR      r0,[r4,#0]            ;3976
000030  6086              STR      r6,[r0,#8]            ;3976
000032  6828              LDR      r0,[r5,#0]            ;3978
000034  2850              CMP      r0,#0x50              ;3978
000036  d03c              BEQ      |L12.178|
000038  dc0c              BGT      |L12.84|
00003a  2820              CMP      r0,#0x20              ;3978
00003c  d061              BEQ      |L12.258|
00003e  dc04              BGT      |L12.74|
000040  2800              CMP      r0,#0                 ;3978
000042  d054              BEQ      |L12.238|
000044  2810              CMP      r0,#0x10              ;3978
000046  d166              BNE      |L12.278|
000048  e056              B        |L12.248|
                  |L12.74|
00004a  2830              CMP      r0,#0x30              ;3978
00004c  d05e              BEQ      |L12.268|
00004e  2840              CMP      r0,#0x40              ;3978
000050  d161              BNE      |L12.278|
000052  e042              B        |L12.218|
                  |L12.84|
000054  2860              CMP      r0,#0x60              ;3978
000056  d036              BEQ      |L12.198|
000058  2870              CMP      r0,#0x70              ;3978
00005a  d00e              BEQ      |L12.122|
00005c  f5b05f80          CMP      r0,#0x1000            ;3978
000060  d003              BEQ      |L12.106|
000062  f5b05f00          CMP      r0,#0x2000            ;3978
000066  d156              BNE      |L12.278|
000068  e016              B        |L12.152|
                  |L12.106|
00006a  6820              LDR      r0,[r4,#0]            ;3984
00006c  6880              LDR      r0,[r0,#8]            ;3984
00006e  492f              LDR      r1,|L12.300|
000070  3170              ADDS     r1,r1,#0x70           ;3984
000072  4008              ANDS     r0,r0,r1              ;3984
000074  6821              LDR      r1,[r4,#0]            ;3984
000076  6088              STR      r0,[r1,#8]            ;3984
000078  e04e              B        |L12.280|
                  |L12.122|
00007a  e9d51302          LDRD     r1,r3,[r5,#8]         ;3995
00007e  686a              LDR      r2,[r5,#4]            ;3995
000080  6820              LDR      r0,[r4,#0]            ;3995
000082  f7fffffe          BL       TIM_ETR_SetConfig
000086  6820              LDR      r0,[r4,#0]            ;4000
000088  6886              LDR      r6,[r0,#8]            ;4000
00008a  4828              LDR      r0,|L12.300|
00008c  4006              ANDS     r6,r6,r0              ;4002
00008e  f0460677          ORR      r6,r6,#0x77           ;4004
000092  6820              LDR      r0,[r4,#0]            ;4006
000094  6086              STR      r6,[r0,#8]            ;4006
000096  e03f              B        |L12.280|
                  |L12.152|
000098  e9d51302          LDRD     r1,r3,[r5,#8]         ;4018
00009c  686a              LDR      r2,[r5,#4]            ;4018
00009e  6820              LDR      r0,[r4,#0]            ;4018
0000a0  f7fffffe          BL       TIM_ETR_SetConfig
0000a4  6820              LDR      r0,[r4,#0]            ;4023
0000a6  6880              LDR      r0,[r0,#8]            ;4023
0000a8  f4404080          ORR      r0,r0,#0x4000         ;4023
0000ac  6821              LDR      r1,[r4,#0]            ;4023
0000ae  6088              STR      r0,[r1,#8]            ;4023
0000b0  e032              B        |L12.280|
                  |L12.178|
0000b2  68ea              LDR      r2,[r5,#0xc]          ;4035
0000b4  6869              LDR      r1,[r5,#4]            ;4035
0000b6  6820              LDR      r0,[r4,#0]            ;4035
0000b8  f7fffffe          BL       TIM_TI1_ConfigInputStage
0000bc  2150              MOVS     r1,#0x50              ;4038
0000be  6820              LDR      r0,[r4,#0]            ;4038
0000c0  f7fffffe          BL       TIM_ITRx_SetConfig
0000c4  e028              B        |L12.280|
                  |L12.198|
0000c6  68ea              LDR      r2,[r5,#0xc]          ;4049
0000c8  6869              LDR      r1,[r5,#4]            ;4049
0000ca  6820              LDR      r0,[r4,#0]            ;4049
0000cc  f7fffffe          BL       TIM_TI2_ConfigInputStage
0000d0  2160              MOVS     r1,#0x60              ;4052
0000d2  6820              LDR      r0,[r4,#0]            ;4052
0000d4  f7fffffe          BL       TIM_ITRx_SetConfig
0000d8  e01e              B        |L12.280|
                  |L12.218|
0000da  68ea              LDR      r2,[r5,#0xc]          ;4062
0000dc  6869              LDR      r1,[r5,#4]            ;4062
0000de  6820              LDR      r0,[r4,#0]            ;4062
0000e0  f7fffffe          BL       TIM_TI1_ConfigInputStage
0000e4  2140              MOVS     r1,#0x40              ;4065
0000e6  6820              LDR      r0,[r4,#0]            ;4065
0000e8  f7fffffe          BL       TIM_ITRx_SetConfig
0000ec  e014              B        |L12.280|
                  |L12.238|
0000ee  2100              MOVS     r1,#0                 ;4071
0000f0  6820              LDR      r0,[r4,#0]            ;4071
0000f2  f7fffffe          BL       TIM_ITRx_SetConfig
0000f6  e00f              B        |L12.280|
                  |L12.248|
0000f8  2110              MOVS     r1,#0x10              ;4077
0000fa  6820              LDR      r0,[r4,#0]            ;4077
0000fc  f7fffffe          BL       TIM_ITRx_SetConfig
000100  e00a              B        |L12.280|
                  |L12.258|
000102  2120              MOVS     r1,#0x20              ;4083
000104  6820              LDR      r0,[r4,#0]            ;4083
000106  f7fffffe          BL       TIM_ITRx_SetConfig
00010a  e005              B        |L12.280|
                  |L12.268|
00010c  2130              MOVS     r1,#0x30              ;4089
00010e  6820              LDR      r0,[r4,#0]            ;4089
000110  f7fffffe          BL       TIM_ITRx_SetConfig
000114  e000              B        |L12.280|
                  |L12.278|
000116  bf00              NOP                            ;4094
                  |L12.280|
000118  bf00              NOP                            ;3986
00011a  2001              MOVS     r0,#1                 ;4096
00011c  63e0              STR      r0,[r4,#0x3c]         ;4096
00011e  bf00              NOP                            ;4098
000120  2000              MOVS     r0,#0                 ;4098
000122  63a0              STR      r0,[r4,#0x38]         ;4098
000124  bf00              NOP                            ;4098
000126  bf00              NOP                            ;4100
000128  e774              B        |L12.20|
;;;4102   
                          ENDP

00012a  0000              DCW      0x0000
                  |L12.300|
                          DCD      0xfffeff88

                          AREA ||i.HAL_TIM_ConfigOCrefClear||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigOCrefClear PROC
;;;3855     */ 
;;;3856   __weak HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim, TIM_ClearInputConfigTypeDef * sClearInputConfig, uint32_t Channel)
000000  b5f0              PUSH     {r4-r7,lr}
;;;3857   { 
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;3858     /* Check the parameters */
;;;3859     assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3860     assert_param(IS_TIM_CHANNELS(Channel));
;;;3861     assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
;;;3862      
;;;3863     /* Process Locked */
;;;3864     __HAL_LOCK(htim);
000008  bf00              NOP      
00000a  6ba0              LDR      r0,[r4,#0x38]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L13.20|
000010  2002              MOVS     r0,#2
                  |L13.18|
;;;3865     
;;;3866     htim->State = HAL_TIM_STATE_BUSY;
;;;3867     
;;;3868     if(sClearInputConfig->ClearInputSource == TIM_CLEARINPUTSOURCE_ETR)
;;;3869     {
;;;3870       assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
;;;3871       assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
;;;3872       assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
;;;3873     
;;;3874       TIM_ETR_SetConfig(htim->Instance, 
;;;3875                         sClearInputConfig->ClearInputPrescaler,
;;;3876                         sClearInputConfig->ClearInputPolarity,
;;;3877                         sClearInputConfig->ClearInputFilter);
;;;3878     }
;;;3879     
;;;3880     switch (Channel)
;;;3881     {
;;;3882       case TIM_CHANNEL_1:
;;;3883       {        
;;;3884         if(sClearInputConfig->ClearInputState != RESET)  
;;;3885         {
;;;3886           /* Enable the Ocref clear feature for Channel 1 */
;;;3887           htim->Instance->CCMR1 |= TIM_CCMR1_OC1CE;
;;;3888         }
;;;3889         else
;;;3890         {
;;;3891           /* Disable the Ocref clear feature for Channel 1 */
;;;3892           htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1CE;      
;;;3893         }
;;;3894       }    
;;;3895       break;
;;;3896       case TIM_CHANNEL_2:    
;;;3897       { 
;;;3898         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance)); 
;;;3899         if(sClearInputConfig->ClearInputState != RESET)  
;;;3900         {
;;;3901           /* Enable the Ocref clear feature for Channel 2 */
;;;3902           htim->Instance->CCMR1 |= TIM_CCMR1_OC2CE;
;;;3903         }
;;;3904         else
;;;3905         {
;;;3906           /* Disable the Ocref clear feature for Channel 2 */
;;;3907           htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2CE;      
;;;3908         }
;;;3909       } 
;;;3910       break;
;;;3911       case TIM_CHANNEL_3:   
;;;3912       {  
;;;3913         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3914         if(sClearInputConfig->ClearInputState != RESET)  
;;;3915         {
;;;3916           /* Enable the Ocref clear feature for Channel 3 */
;;;3917           htim->Instance->CCMR2 |= TIM_CCMR2_OC3CE;
;;;3918         }
;;;3919         else
;;;3920         {
;;;3921           /* Disable the Ocref clear feature for Channel 3 */
;;;3922           htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3CE;      
;;;3923         }
;;;3924       } 
;;;3925       break;
;;;3926       case TIM_CHANNEL_4:    
;;;3927       {  
;;;3928         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3929         if(sClearInputConfig->ClearInputState != RESET)  
;;;3930         {
;;;3931           /* Enable the Ocref clear feature for Channel 4 */
;;;3932           htim->Instance->CCMR2 |= TIM_CCMR2_OC4CE;
;;;3933         }
;;;3934         else
;;;3935         {
;;;3936           /* Disable the Ocref clear feature for Channel 4 */
;;;3937           htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4CE;      
;;;3938         }
;;;3939       } 
;;;3940       break;
;;;3941       default:  
;;;3942       break;
;;;3943     } 
;;;3944   
;;;3945     htim->State = HAL_TIM_STATE_READY;
;;;3946     
;;;3947     __HAL_UNLOCK(htim);
;;;3948     
;;;3949     return HAL_OK;  
;;;3950   }  
000012  bdf0              POP      {r4-r7,pc}
                  |L13.20|
000014  2001              MOVS     r0,#1                 ;3864
000016  63a0              STR      r0,[r4,#0x38]         ;3864
000018  bf00              NOP                            ;3864
00001a  2002              MOVS     r0,#2                 ;3866
00001c  63e0              STR      r0,[r4,#0x3c]         ;3866
00001e  6868              LDR      r0,[r5,#4]            ;3868
000020  2801              CMP      r0,#1                 ;3868
000022  d105              BNE      |L13.48|
000024  e9d51303          LDRD     r1,r3,[r5,#0xc]       ;3874
000028  68aa              LDR      r2,[r5,#8]            ;3874
00002a  6820              LDR      r0,[r4,#0]            ;3874
00002c  f7fffffe          BL       TIM_ETR_SetConfig
                  |L13.48|
000030  b136              CBZ      r6,|L13.64|
000032  2e04              CMP      r6,#4                 ;3880
000034  d014              BEQ      |L13.96|
000036  2e08              CMP      r6,#8                 ;3880
000038  d022              BEQ      |L13.128|
00003a  2e0c              CMP      r6,#0xc               ;3880
00003c  d140              BNE      |L13.192|
00003e  e02f              B        |L13.160|
                  |L13.64|
000040  6828              LDR      r0,[r5,#0]            ;3884
000042  b130              CBZ      r0,|L13.82|
000044  6820              LDR      r0,[r4,#0]            ;3887
000046  6980              LDR      r0,[r0,#0x18]         ;3887
000048  f0400080          ORR      r0,r0,#0x80           ;3887
00004c  6821              LDR      r1,[r4,#0]            ;3887
00004e  6188              STR      r0,[r1,#0x18]         ;3887
000050  e005              B        |L13.94|
                  |L13.82|
000052  6820              LDR      r0,[r4,#0]            ;3892
000054  6980              LDR      r0,[r0,#0x18]         ;3892
000056  f0200080          BIC      r0,r0,#0x80           ;3892
00005a  6821              LDR      r1,[r4,#0]            ;3892
00005c  6188              STR      r0,[r1,#0x18]         ;3892
                  |L13.94|
00005e  e030              B        |L13.194|
                  |L13.96|
000060  6828              LDR      r0,[r5,#0]            ;3899
000062  b130              CBZ      r0,|L13.114|
000064  6820              LDR      r0,[r4,#0]            ;3902
000066  6980              LDR      r0,[r0,#0x18]         ;3902
000068  f4404000          ORR      r0,r0,#0x8000         ;3902
00006c  6821              LDR      r1,[r4,#0]            ;3902
00006e  6188              STR      r0,[r1,#0x18]         ;3902
000070  e005              B        |L13.126|
                  |L13.114|
000072  6820              LDR      r0,[r4,#0]            ;3907
000074  6980              LDR      r0,[r0,#0x18]         ;3907
000076  f4204000          BIC      r0,r0,#0x8000         ;3907
00007a  6821              LDR      r1,[r4,#0]            ;3907
00007c  6188              STR      r0,[r1,#0x18]         ;3907
                  |L13.126|
00007e  e020              B        |L13.194|
                  |L13.128|
000080  6828              LDR      r0,[r5,#0]            ;3914
000082  b130              CBZ      r0,|L13.146|
000084  6820              LDR      r0,[r4,#0]            ;3917
000086  69c0              LDR      r0,[r0,#0x1c]         ;3917
000088  f0400080          ORR      r0,r0,#0x80           ;3917
00008c  6821              LDR      r1,[r4,#0]            ;3917
00008e  61c8              STR      r0,[r1,#0x1c]         ;3917
000090  e005              B        |L13.158|
                  |L13.146|
000092  6820              LDR      r0,[r4,#0]            ;3922
000094  69c0              LDR      r0,[r0,#0x1c]         ;3922
000096  f0200080          BIC      r0,r0,#0x80           ;3922
00009a  6821              LDR      r1,[r4,#0]            ;3922
00009c  61c8              STR      r0,[r1,#0x1c]         ;3922
                  |L13.158|
00009e  e010              B        |L13.194|
                  |L13.160|
0000a0  6828              LDR      r0,[r5,#0]            ;3929
0000a2  b130              CBZ      r0,|L13.178|
0000a4  6820              LDR      r0,[r4,#0]            ;3932
0000a6  69c0              LDR      r0,[r0,#0x1c]         ;3932
0000a8  f4404000          ORR      r0,r0,#0x8000         ;3932
0000ac  6821              LDR      r1,[r4,#0]            ;3932
0000ae  61c8              STR      r0,[r1,#0x1c]         ;3932
0000b0  e005              B        |L13.190|
                  |L13.178|
0000b2  6820              LDR      r0,[r4,#0]            ;3937
0000b4  69c0              LDR      r0,[r0,#0x1c]         ;3937
0000b6  f4204000          BIC      r0,r0,#0x8000         ;3937
0000ba  6821              LDR      r1,[r4,#0]            ;3937
0000bc  61c8              STR      r0,[r1,#0x1c]         ;3937
                  |L13.190|
0000be  e000              B        |L13.194|
                  |L13.192|
0000c0  bf00              NOP                            ;3942
                  |L13.194|
0000c2  bf00              NOP                            ;3895
0000c4  2001              MOVS     r0,#1                 ;3945
0000c6  63e0              STR      r0,[r4,#0x3c]         ;3945
0000c8  bf00              NOP                            ;3947
0000ca  2000              MOVS     r0,#0                 ;3947
0000cc  63a0              STR      r0,[r4,#0x38]         ;3947
0000ce  bf00              NOP                            ;3947
0000d0  bf00              NOP                            ;3949
0000d2  e79e              B        |L13.18|
;;;3951   
                          ENDP


                          AREA ||i.HAL_TIM_ConfigTI1Input||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigTI1Input PROC
;;;4115     */
;;;4116   HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
000000  4602              MOV      r2,r0
;;;4117   {
000002  460b              MOV      r3,r1
;;;4118     uint32_t tmpcr2 = 0;
000004  2100              MOVS     r1,#0
;;;4119     
;;;4120     /* Check the parameters */
;;;4121     assert_param(IS_TIM_XOR_INSTANCE(htim->Instance)); 
;;;4122     assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
;;;4123   
;;;4124     /* Get the TIMx CR2 register value */
;;;4125     tmpcr2 = htim->Instance->CR2;
000006  6810              LDR      r0,[r2,#0]
000008  6841              LDR      r1,[r0,#4]
;;;4126   
;;;4127     /* Reset the TI1 selection */
;;;4128     tmpcr2 &= ~TIM_CR2_TI1S;
00000a  f0210180          BIC      r1,r1,#0x80
;;;4129   
;;;4130     /* Set the TI1 selection */
;;;4131     tmpcr2 |= TI1_Selection;
00000e  4319              ORRS     r1,r1,r3
;;;4132     
;;;4133     /* Write to TIMxCR2 */
;;;4134     htim->Instance->CR2 = tmpcr2;
000010  6810              LDR      r0,[r2,#0]
000012  6041              STR      r1,[r0,#4]
;;;4135   
;;;4136     return HAL_OK;
000014  2000              MOVS     r0,#0
;;;4137   }
000016  4770              BX       lr
;;;4138   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_ReadStart||, CODE, READONLY, ALIGN=2

                  HAL_TIM_DMABurst_ReadStart PROC
;;;3610     */
;;;3611   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3612                                                uint32_t  *BurstBuffer, uint32_t  BurstLength)
;;;3613   {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  9d06              LDR      r5,[sp,#0x18]
;;;3614     /* Check the parameters */
;;;3615     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;3616     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;3617     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3618     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;3619     
;;;3620     if((htim->State == HAL_TIM_STATE_BUSY))
00000e  6be0              LDR      r0,[r4,#0x3c]
000010  2802              CMP      r0,#2
000012  d101              BNE      |L15.24|
                  |L15.20|
;;;3621     {
;;;3622        return HAL_BUSY;
;;;3623     }
;;;3624     else if((htim->State == HAL_TIM_STATE_READY))
;;;3625     {
;;;3626       if((BurstBuffer == 0 ) && (BurstLength > 0)) 
;;;3627       {
;;;3628         return HAL_ERROR;                                    
;;;3629       }
;;;3630       else
;;;3631       {
;;;3632         htim->State = HAL_TIM_STATE_BUSY;
;;;3633       }
;;;3634     }  
;;;3635     switch(BurstRequestSrc)
;;;3636     {
;;;3637       case TIM_DMA_UPDATE:
;;;3638       {  
;;;3639         /* Set the DMA Period elapsed callback */
;;;3640         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;3641        
;;;3642         /* Set the DMA error callback */
;;;3643         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3644     
;;;3645         /* Enable the DMA Stream */
;;;3646          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);     
;;;3647       }
;;;3648       break;
;;;3649       case TIM_DMA_CC1:
;;;3650       {  
;;;3651         /* Set the DMA Period elapsed callback */
;;;3652         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;3653        
;;;3654         /* Set the DMA error callback */
;;;3655         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3656     
;;;3657         /* Enable the DMA Stream */
;;;3658         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3659       }
;;;3660       break;
;;;3661       case TIM_DMA_CC2:
;;;3662       {  
;;;3663         /* Set the DMA Period elapsed callback */
;;;3664         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;3665        
;;;3666         /* Set the DMA error callback */
;;;3667         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3668     
;;;3669         /* Enable the DMA Stream */
;;;3670         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);     
;;;3671       }
;;;3672       break;
;;;3673       case TIM_DMA_CC3:
;;;3674       {  
;;;3675         /* Set the DMA Period elapsed callback */
;;;3676         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;3677        
;;;3678         /* Set the DMA error callback */
;;;3679         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3680     
;;;3681         /* Enable the DMA Stream */
;;;3682         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3683       }
;;;3684       break;
;;;3685       case TIM_DMA_CC4:
;;;3686       {  
;;;3687         /* Set the DMA Period elapsed callback */
;;;3688         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;3689        
;;;3690         /* Set the DMA error callback */
;;;3691         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3692     
;;;3693         /* Enable the DMA Stream */
;;;3694         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3695       }
;;;3696       break;
;;;3697       case TIM_DMA_COM:
;;;3698       {  
;;;3699         /* Set the DMA Period elapsed callback */
;;;3700         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = HAL_TIMEx_DMACommutationCplt;
;;;3701        
;;;3702         /* Set the DMA error callback */
;;;3703         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3704     
;;;3705         /* Enable the DMA Stream */
;;;3706         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3707       }
;;;3708       break;
;;;3709       case TIM_DMA_TRIGGER:
;;;3710       {  
;;;3711         /* Set the DMA Period elapsed callback */
;;;3712         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;3713        
;;;3714         /* Set the DMA error callback */
;;;3715         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3716     
;;;3717         /* Enable the DMA Stream */
;;;3718         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3719       }
;;;3720       break;
;;;3721       default:
;;;3722       break;  
;;;3723     }
;;;3724   
;;;3725     /* configure the DMA Burst Mode */
;;;3726     htim->Instance->DCR = BurstBaseAddress | BurstLength;  
;;;3727     
;;;3728     /* Enable the TIM DMA Request */
;;;3729     __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
;;;3730     
;;;3731     htim->State = HAL_TIM_STATE_READY;
;;;3732     
;;;3733     /* Return function status */
;;;3734     return HAL_OK;
;;;3735   }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L15.24|
000018  6be0              LDR      r0,[r4,#0x3c]         ;3624
00001a  2801              CMP      r0,#1                 ;3624
00001c  d104              BNE      |L15.40|
00001e  b90f              CBNZ     r7,|L15.36|
000020  b105              CBZ      r5,|L15.36|
000022  e7f7              B        |L15.20|
                  |L15.36|
000024  2002              MOVS     r0,#2                 ;3632
000026  63e0              STR      r0,[r4,#0x3c]         ;3632
                  |L15.40|
000028  f5b66f00          CMP      r6,#0x800             ;3635
00002c  d047              BEQ      |L15.190|
00002e  dc09              BGT      |L15.68|
000030  f5b67f80          CMP      r6,#0x100             ;3635
000034  d010              BEQ      |L15.88|
000036  f5b67f00          CMP      r6,#0x200             ;3635
00003a  d01e              BEQ      |L15.122|
00003c  f5b66f80          CMP      r6,#0x400             ;3635
000040  d170              BNE      |L15.292|
000042  e02b              B        |L15.156|
                  |L15.68|
000044  f5b65f80          CMP      r6,#0x1000            ;3635
000048  d04a              BEQ      |L15.224|
00004a  f5b65f00          CMP      r6,#0x2000            ;3635
00004e  d058              BEQ      |L15.258|
000050  f5b64f80          CMP      r6,#0x4000            ;3635
000054  d178              BNE      |L15.328|
000056  e066              B        |L15.294|
                  |L15.88|
000058  4843              LDR      r0,|L15.360|
00005a  69e1              LDR      r1,[r4,#0x1c]         ;3640
00005c  6408              STR      r0,[r1,#0x40]         ;3640
00005e  4843              LDR      r0,|L15.364|
000060  69e1              LDR      r1,[r4,#0x1c]         ;3643
000062  6508              STR      r0,[r1,#0x50]         ;3643
000064  2201              MOVS     r2,#1                 ;3646
000066  eb022315          ADD      r3,r2,r5,LSR #8       ;3646
00006a  6822              LDR      r2,[r4,#0]            ;3646
00006c  f102014c          ADD      r1,r2,#0x4c           ;3646
000070  463a              MOV      r2,r7                 ;3646
000072  69e0              LDR      r0,[r4,#0x1c]         ;3646
000074  f7fffffe          BL       HAL_DMA_Start_IT
000078  e067              B        |L15.330|
                  |L15.122|
00007a  493d              LDR      r1,|L15.368|
00007c  6a20              LDR      r0,[r4,#0x20]         ;3652
00007e  6401              STR      r1,[r0,#0x40]         ;3652
000080  493a              LDR      r1,|L15.364|
000082  6a20              LDR      r0,[r4,#0x20]         ;3655
000084  6501              STR      r1,[r0,#0x50]         ;3655
000086  2201              MOVS     r2,#1                 ;3658
000088  eb022315          ADD      r3,r2,r5,LSR #8       ;3658
00008c  6822              LDR      r2,[r4,#0]            ;3658
00008e  f102014c          ADD      r1,r2,#0x4c           ;3658
000092  463a              MOV      r2,r7                 ;3658
000094  6a20              LDR      r0,[r4,#0x20]         ;3658
000096  f7fffffe          BL       HAL_DMA_Start_IT
00009a  e056              B        |L15.330|
                  |L15.156|
00009c  4934              LDR      r1,|L15.368|
00009e  6a60              LDR      r0,[r4,#0x24]         ;3664
0000a0  6401              STR      r1,[r0,#0x40]         ;3664
0000a2  4932              LDR      r1,|L15.364|
0000a4  6a60              LDR      r0,[r4,#0x24]         ;3667
0000a6  6501              STR      r1,[r0,#0x50]         ;3667
0000a8  2201              MOVS     r2,#1                 ;3670
0000aa  eb022315          ADD      r3,r2,r5,LSR #8       ;3670
0000ae  6822              LDR      r2,[r4,#0]            ;3670
0000b0  f102014c          ADD      r1,r2,#0x4c           ;3670
0000b4  463a              MOV      r2,r7                 ;3670
0000b6  6a60              LDR      r0,[r4,#0x24]         ;3670
0000b8  f7fffffe          BL       HAL_DMA_Start_IT
0000bc  e045              B        |L15.330|
                  |L15.190|
0000be  492c              LDR      r1,|L15.368|
0000c0  6aa0              LDR      r0,[r4,#0x28]         ;3676
0000c2  6401              STR      r1,[r0,#0x40]         ;3676
0000c4  4929              LDR      r1,|L15.364|
0000c6  6aa0              LDR      r0,[r4,#0x28]         ;3679
0000c8  6501              STR      r1,[r0,#0x50]         ;3679
0000ca  2201              MOVS     r2,#1                 ;3682
0000cc  eb022315          ADD      r3,r2,r5,LSR #8       ;3682
0000d0  6822              LDR      r2,[r4,#0]            ;3682
0000d2  f102014c          ADD      r1,r2,#0x4c           ;3682
0000d6  463a              MOV      r2,r7                 ;3682
0000d8  6aa0              LDR      r0,[r4,#0x28]         ;3682
0000da  f7fffffe          BL       HAL_DMA_Start_IT
0000de  e034              B        |L15.330|
                  |L15.224|
0000e0  4923              LDR      r1,|L15.368|
0000e2  6ae0              LDR      r0,[r4,#0x2c]         ;3688
0000e4  6401              STR      r1,[r0,#0x40]         ;3688
0000e6  4921              LDR      r1,|L15.364|
0000e8  6ae0              LDR      r0,[r4,#0x2c]         ;3691
0000ea  6501              STR      r1,[r0,#0x50]         ;3691
0000ec  2201              MOVS     r2,#1                 ;3694
0000ee  eb022315          ADD      r3,r2,r5,LSR #8       ;3694
0000f2  6822              LDR      r2,[r4,#0]            ;3694
0000f4  f102014c          ADD      r1,r2,#0x4c           ;3694
0000f8  463a              MOV      r2,r7                 ;3694
0000fa  6ae0              LDR      r0,[r4,#0x2c]         ;3694
0000fc  f7fffffe          BL       HAL_DMA_Start_IT
000100  e023              B        |L15.330|
                  |L15.258|
000102  491c              LDR      r1,|L15.372|
000104  6b20              LDR      r0,[r4,#0x30]         ;3700
000106  6401              STR      r1,[r0,#0x40]         ;3700
000108  4918              LDR      r1,|L15.364|
00010a  6b20              LDR      r0,[r4,#0x30]         ;3703
00010c  6501              STR      r1,[r0,#0x50]         ;3703
00010e  2201              MOVS     r2,#1                 ;3706
000110  eb022315          ADD      r3,r2,r5,LSR #8       ;3706
000114  6822              LDR      r2,[r4,#0]            ;3706
000116  f102014c          ADD      r1,r2,#0x4c           ;3706
00011a  463a              MOV      r2,r7                 ;3706
00011c  6b20              LDR      r0,[r4,#0x30]         ;3706
00011e  f7fffffe          BL       HAL_DMA_Start_IT
000122  e012              B        |L15.330|
                  |L15.292|
000124  e010              B        |L15.328|
                  |L15.294|
000126  4914              LDR      r1,|L15.376|
000128  6b60              LDR      r0,[r4,#0x34]         ;3712
00012a  6401              STR      r1,[r0,#0x40]         ;3712
00012c  490f              LDR      r1,|L15.364|
00012e  6b60              LDR      r0,[r4,#0x34]         ;3715
000130  6501              STR      r1,[r0,#0x50]         ;3715
000132  2201              MOVS     r2,#1                 ;3718
000134  eb022315          ADD      r3,r2,r5,LSR #8       ;3718
000138  6822              LDR      r2,[r4,#0]            ;3718
00013a  f102014c          ADD      r1,r2,#0x4c           ;3718
00013e  463a              MOV      r2,r7                 ;3718
000140  6b60              LDR      r0,[r4,#0x34]         ;3718
000142  f7fffffe          BL       HAL_DMA_Start_IT
000146  e000              B        |L15.330|
                  |L15.328|
000148  bf00              NOP                            ;3722
                  |L15.330|
00014a  bf00              NOP                            ;3648
00014c  ea480005          ORR      r0,r8,r5              ;3726
000150  6821              LDR      r1,[r4,#0]            ;3726
000152  6488              STR      r0,[r1,#0x48]         ;3726
000154  6820              LDR      r0,[r4,#0]            ;3729
000156  68c0              LDR      r0,[r0,#0xc]          ;3729
000158  4330              ORRS     r0,r0,r6              ;3729
00015a  6821              LDR      r1,[r4,#0]            ;3729
00015c  60c8              STR      r0,[r1,#0xc]          ;3729
00015e  2001              MOVS     r0,#1                 ;3731
000160  63e0              STR      r0,[r4,#0x3c]         ;3731
000162  2000              MOVS     r0,#0                 ;3734
000164  e756              B        |L15.20|
;;;3736   
                          ENDP

000166  0000              DCW      0x0000
                  |L15.360|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L15.364|
                          DCD      TIM_DMAError
                  |L15.368|
                          DCD      TIM_DMACaptureCplt
                  |L15.372|
                          DCD      TIMEx_DMACommutationCplt
                  |L15.376|
                          DCD      TIM_DMATriggerCplt

                          AREA ||i.HAL_TIM_DMABurst_ReadStop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_ReadStop PROC
;;;3743     */
;;;3744   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
000000  b570              PUSH     {r4-r6,lr}
;;;3745   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;3746     /* Check the parameters */
;;;3747     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3748     
;;;3749     /* Abort the DMA transfer (at least disable the DMA channel) */
;;;3750     switch(BurstRequestSrc)
000006  f5b56f00          CMP      r5,#0x800
00000a  d020              BEQ      |L16.78|
00000c  dc09              BGT      |L16.34|
00000e  f5b57f80          CMP      r5,#0x100
000012  d010              BEQ      |L16.54|
000014  f5b57f00          CMP      r5,#0x200
000018  d011              BEQ      |L16.62|
00001a  f5b56f80          CMP      r5,#0x400
00001e  d126              BNE      |L16.110|
000020  e011              B        |L16.70|
                  |L16.34|
000022  f5b55f80          CMP      r5,#0x1000
000026  d016              BEQ      |L16.86|
000028  f5b55f00          CMP      r5,#0x2000
00002c  d017              BEQ      |L16.94|
00002e  f5b54f80          CMP      r5,#0x4000
000032  d11c              BNE      |L16.110|
000034  e017              B        |L16.102|
                  |L16.54|
;;;3751     {
;;;3752       case TIM_DMA_UPDATE:
;;;3753       {  
;;;3754         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
000036  69e0              LDR      r0,[r4,#0x1c]
000038  f7fffffe          BL       HAL_DMA_Abort
;;;3755       }
;;;3756       break;
00003c  e018              B        |L16.112|
                  |L16.62|
;;;3757       case TIM_DMA_CC1:
;;;3758       {  
;;;3759         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
00003e  6a20              LDR      r0,[r4,#0x20]
000040  f7fffffe          BL       HAL_DMA_Abort
;;;3760       }
;;;3761       break;
000044  e014              B        |L16.112|
                  |L16.70|
;;;3762       case TIM_DMA_CC2:
;;;3763       {  
;;;3764         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
000046  6a60              LDR      r0,[r4,#0x24]
000048  f7fffffe          BL       HAL_DMA_Abort
;;;3765       }
;;;3766       break;
00004c  e010              B        |L16.112|
                  |L16.78|
;;;3767       case TIM_DMA_CC3:
;;;3768       {  
;;;3769         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
00004e  6aa0              LDR      r0,[r4,#0x28]
000050  f7fffffe          BL       HAL_DMA_Abort
;;;3770       }
;;;3771       break;
000054  e00c              B        |L16.112|
                  |L16.86|
;;;3772       case TIM_DMA_CC4:
;;;3773       {  
;;;3774         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
000056  6ae0              LDR      r0,[r4,#0x2c]
000058  f7fffffe          BL       HAL_DMA_Abort
;;;3775       }
;;;3776       break;
00005c  e008              B        |L16.112|
                  |L16.94|
;;;3777       case TIM_DMA_COM:
;;;3778       {  
;;;3779         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
00005e  6b20              LDR      r0,[r4,#0x30]
000060  f7fffffe          BL       HAL_DMA_Abort
;;;3780       }
;;;3781       break;
000064  e004              B        |L16.112|
                  |L16.102|
;;;3782       case TIM_DMA_TRIGGER:
;;;3783       {  
;;;3784         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
000066  6b60              LDR      r0,[r4,#0x34]
000068  f7fffffe          BL       HAL_DMA_Abort
;;;3785       }
;;;3786       break;
00006c  e000              B        |L16.112|
                  |L16.110|
;;;3787       default:
;;;3788       break;  
00006e  bf00              NOP      
                  |L16.112|
000070  bf00              NOP                            ;3756
;;;3789     }
;;;3790     
;;;3791     /* Disable the TIM Update DMA request */
;;;3792     __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
000072  6820              LDR      r0,[r4,#0]
000074  68c0              LDR      r0,[r0,#0xc]
000076  43a8              BICS     r0,r0,r5
000078  6821              LDR      r1,[r4,#0]
00007a  60c8              STR      r0,[r1,#0xc]
;;;3793         
;;;3794     /* Return function status */
;;;3795     return HAL_OK;  
00007c  2000              MOVS     r0,#0
;;;3796   }
00007e  bd70              POP      {r4-r6,pc}
;;;3797   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_WriteStart||, CODE, READONLY, ALIGN=2

                  HAL_TIM_DMABurst_WriteStart PROC
;;;3385     */
;;;3386   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3387                                                 uint32_t* BurstBuffer, uint32_t  BurstLength)
;;;3388   {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  9d06              LDR      r5,[sp,#0x18]
;;;3389     /* Check the parameters */
;;;3390     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;3391     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;3392     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3393     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;3394     
;;;3395     if((htim->State == HAL_TIM_STATE_BUSY))
00000e  6be0              LDR      r0,[r4,#0x3c]
000010  2802              CMP      r0,#2
000012  d101              BNE      |L17.24|
                  |L17.20|
;;;3396     {
;;;3397        return HAL_BUSY;
;;;3398     }
;;;3399     else if((htim->State == HAL_TIM_STATE_READY))
;;;3400     {
;;;3401       if((BurstBuffer == 0 ) && (BurstLength > 0)) 
;;;3402       {
;;;3403         return HAL_ERROR;                                    
;;;3404       }
;;;3405       else
;;;3406       {
;;;3407         htim->State = HAL_TIM_STATE_BUSY;
;;;3408       }
;;;3409     }
;;;3410     switch(BurstRequestSrc)
;;;3411     {
;;;3412       case TIM_DMA_UPDATE:
;;;3413       {  
;;;3414         /* Set the DMA Period elapsed callback */
;;;3415         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;3416        
;;;3417         /* Set the DMA error callback */
;;;3418         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3419     
;;;3420         /* Enable the DMA Stream */
;;;3421         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1); 
;;;3422       }
;;;3423       break;
;;;3424       case TIM_DMA_CC1:
;;;3425       {  
;;;3426         /* Set the DMA Period elapsed callback */
;;;3427         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;3428        
;;;3429         /* Set the DMA error callback */
;;;3430         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3431     
;;;3432         /* Enable the DMA Stream */
;;;3433         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3434       }
;;;3435       break;
;;;3436       case TIM_DMA_CC2:
;;;3437       {  
;;;3438         /* Set the DMA Period elapsed callback */
;;;3439         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;3440        
;;;3441         /* Set the DMA error callback */
;;;3442         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3443     
;;;3444         /* Enable the DMA Stream */
;;;3445         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3446       }
;;;3447       break;
;;;3448       case TIM_DMA_CC3:
;;;3449       {  
;;;3450         /* Set the DMA Period elapsed callback */
;;;3451         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;3452        
;;;3453         /* Set the DMA error callback */
;;;3454         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3455     
;;;3456         /* Enable the DMA Stream */
;;;3457         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3458       }
;;;3459       break;
;;;3460       case TIM_DMA_CC4:
;;;3461       {  
;;;3462         /* Set the DMA Period elapsed callback */
;;;3463         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;3464        
;;;3465         /* Set the DMA error callback */
;;;3466         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3467     
;;;3468         /* Enable the DMA Stream */
;;;3469         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3470       }
;;;3471       break;
;;;3472       case TIM_DMA_COM:
;;;3473       {  
;;;3474         /* Set the DMA Period elapsed callback */
;;;3475         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = HAL_TIMEx_DMACommutationCplt;
;;;3476        
;;;3477         /* Set the DMA error callback */
;;;3478         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3479     
;;;3480         /* Enable the DMA Stream */
;;;3481         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3482       }
;;;3483       break;
;;;3484       case TIM_DMA_TRIGGER:
;;;3485       {  
;;;3486         /* Set the DMA Period elapsed callback */
;;;3487         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;3488        
;;;3489         /* Set the DMA error callback */
;;;3490         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3491     
;;;3492         /* Enable the DMA Stream */
;;;3493         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3494       }
;;;3495       break;
;;;3496       default:
;;;3497       break;  
;;;3498     }
;;;3499      /* configure the DMA Burst Mode */
;;;3500      htim->Instance->DCR = BurstBaseAddress | BurstLength;  
;;;3501      
;;;3502      /* Enable the TIM DMA Request */
;;;3503      __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);  
;;;3504      
;;;3505      htim->State = HAL_TIM_STATE_READY;
;;;3506     
;;;3507     /* Return function status */
;;;3508     return HAL_OK;
;;;3509   }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L17.24|
000018  6be0              LDR      r0,[r4,#0x3c]         ;3399
00001a  2801              CMP      r0,#1                 ;3399
00001c  d104              BNE      |L17.40|
00001e  b90f              CBNZ     r7,|L17.36|
000020  b105              CBZ      r5,|L17.36|
000022  e7f7              B        |L17.20|
                  |L17.36|
000024  2002              MOVS     r0,#2                 ;3407
000026  63e0              STR      r0,[r4,#0x3c]         ;3407
                  |L17.40|
000028  f5b66f00          CMP      r6,#0x800             ;3410
00002c  d047              BEQ      |L17.190|
00002e  dc09              BGT      |L17.68|
000030  f5b67f80          CMP      r6,#0x100             ;3410
000034  d010              BEQ      |L17.88|
000036  f5b67f00          CMP      r6,#0x200             ;3410
00003a  d01e              BEQ      |L17.122|
00003c  f5b66f80          CMP      r6,#0x400             ;3410
000040  d170              BNE      |L17.292|
000042  e02b              B        |L17.156|
                  |L17.68|
000044  f5b65f80          CMP      r6,#0x1000            ;3410
000048  d04a              BEQ      |L17.224|
00004a  f5b65f00          CMP      r6,#0x2000            ;3410
00004e  d058              BEQ      |L17.258|
000050  f5b64f80          CMP      r6,#0x4000            ;3410
000054  d178              BNE      |L17.328|
000056  e066              B        |L17.294|
                  |L17.88|
000058  4843              LDR      r0,|L17.360|
00005a  69e1              LDR      r1,[r4,#0x1c]         ;3415
00005c  6408              STR      r0,[r1,#0x40]         ;3415
00005e  4843              LDR      r0,|L17.364|
000060  69e1              LDR      r1,[r4,#0x1c]         ;3418
000062  6508              STR      r0,[r1,#0x50]         ;3418
000064  2101              MOVS     r1,#1                 ;3421
000066  eb012315          ADD      r3,r1,r5,LSR #8       ;3421
00006a  6821              LDR      r1,[r4,#0]            ;3421
00006c  f101024c          ADD      r2,r1,#0x4c           ;3421
000070  4639              MOV      r1,r7                 ;3421
000072  69e0              LDR      r0,[r4,#0x1c]         ;3421
000074  f7fffffe          BL       HAL_DMA_Start_IT
000078  e067              B        |L17.330|
                  |L17.122|
00007a  493d              LDR      r1,|L17.368|
00007c  6a20              LDR      r0,[r4,#0x20]         ;3427
00007e  6401              STR      r1,[r0,#0x40]         ;3427
000080  493a              LDR      r1,|L17.364|
000082  6a20              LDR      r0,[r4,#0x20]         ;3430
000084  6501              STR      r1,[r0,#0x50]         ;3430
000086  2101              MOVS     r1,#1                 ;3433
000088  eb012315          ADD      r3,r1,r5,LSR #8       ;3433
00008c  6821              LDR      r1,[r4,#0]            ;3433
00008e  f101024c          ADD      r2,r1,#0x4c           ;3433
000092  4639              MOV      r1,r7                 ;3433
000094  6a20              LDR      r0,[r4,#0x20]         ;3433
000096  f7fffffe          BL       HAL_DMA_Start_IT
00009a  e056              B        |L17.330|
                  |L17.156|
00009c  4934              LDR      r1,|L17.368|
00009e  6a60              LDR      r0,[r4,#0x24]         ;3439
0000a0  6401              STR      r1,[r0,#0x40]         ;3439
0000a2  4932              LDR      r1,|L17.364|
0000a4  6a60              LDR      r0,[r4,#0x24]         ;3442
0000a6  6501              STR      r1,[r0,#0x50]         ;3442
0000a8  2101              MOVS     r1,#1                 ;3445
0000aa  eb012315          ADD      r3,r1,r5,LSR #8       ;3445
0000ae  6821              LDR      r1,[r4,#0]            ;3445
0000b0  f101024c          ADD      r2,r1,#0x4c           ;3445
0000b4  4639              MOV      r1,r7                 ;3445
0000b6  6a60              LDR      r0,[r4,#0x24]         ;3445
0000b8  f7fffffe          BL       HAL_DMA_Start_IT
0000bc  e045              B        |L17.330|
                  |L17.190|
0000be  492c              LDR      r1,|L17.368|
0000c0  6aa0              LDR      r0,[r4,#0x28]         ;3451
0000c2  6401              STR      r1,[r0,#0x40]         ;3451
0000c4  4929              LDR      r1,|L17.364|
0000c6  6aa0              LDR      r0,[r4,#0x28]         ;3454
0000c8  6501              STR      r1,[r0,#0x50]         ;3454
0000ca  2101              MOVS     r1,#1                 ;3457
0000cc  eb012315          ADD      r3,r1,r5,LSR #8       ;3457
0000d0  6821              LDR      r1,[r4,#0]            ;3457
0000d2  f101024c          ADD      r2,r1,#0x4c           ;3457
0000d6  4639              MOV      r1,r7                 ;3457
0000d8  6aa0              LDR      r0,[r4,#0x28]         ;3457
0000da  f7fffffe          BL       HAL_DMA_Start_IT
0000de  e034              B        |L17.330|
                  |L17.224|
0000e0  4923              LDR      r1,|L17.368|
0000e2  6ae0              LDR      r0,[r4,#0x2c]         ;3463
0000e4  6401              STR      r1,[r0,#0x40]         ;3463
0000e6  4921              LDR      r1,|L17.364|
0000e8  6ae0              LDR      r0,[r4,#0x2c]         ;3466
0000ea  6501              STR      r1,[r0,#0x50]         ;3466
0000ec  2101              MOVS     r1,#1                 ;3469
0000ee  eb012315          ADD      r3,r1,r5,LSR #8       ;3469
0000f2  6821              LDR      r1,[r4,#0]            ;3469
0000f4  f101024c          ADD      r2,r1,#0x4c           ;3469
0000f8  4639              MOV      r1,r7                 ;3469
0000fa  6ae0              LDR      r0,[r4,#0x2c]         ;3469
0000fc  f7fffffe          BL       HAL_DMA_Start_IT
000100  e023              B        |L17.330|
                  |L17.258|
000102  491c              LDR      r1,|L17.372|
000104  6b20              LDR      r0,[r4,#0x30]         ;3475
000106  6401              STR      r1,[r0,#0x40]         ;3475
000108  4918              LDR      r1,|L17.364|
00010a  6b20              LDR      r0,[r4,#0x30]         ;3478
00010c  6501              STR      r1,[r0,#0x50]         ;3478
00010e  2101              MOVS     r1,#1                 ;3481
000110  eb012315          ADD      r3,r1,r5,LSR #8       ;3481
000114  6821              LDR      r1,[r4,#0]            ;3481
000116  f101024c          ADD      r2,r1,#0x4c           ;3481
00011a  4639              MOV      r1,r7                 ;3481
00011c  6b20              LDR      r0,[r4,#0x30]         ;3481
00011e  f7fffffe          BL       HAL_DMA_Start_IT
000122  e012              B        |L17.330|
                  |L17.292|
000124  e010              B        |L17.328|
                  |L17.294|
000126  4914              LDR      r1,|L17.376|
000128  6b60              LDR      r0,[r4,#0x34]         ;3487
00012a  6401              STR      r1,[r0,#0x40]         ;3487
00012c  490f              LDR      r1,|L17.364|
00012e  6b60              LDR      r0,[r4,#0x34]         ;3490
000130  6501              STR      r1,[r0,#0x50]         ;3490
000132  2101              MOVS     r1,#1                 ;3493
000134  eb012315          ADD      r3,r1,r5,LSR #8       ;3493
000138  6821              LDR      r1,[r4,#0]            ;3493
00013a  f101024c          ADD      r2,r1,#0x4c           ;3493
00013e  4639              MOV      r1,r7                 ;3493
000140  6b60              LDR      r0,[r4,#0x34]         ;3493
000142  f7fffffe          BL       HAL_DMA_Start_IT
000146  e000              B        |L17.330|
                  |L17.328|
000148  bf00              NOP                            ;3497
                  |L17.330|
00014a  bf00              NOP                            ;3423
00014c  ea480005          ORR      r0,r8,r5              ;3500
000150  6821              LDR      r1,[r4,#0]            ;3500
000152  6488              STR      r0,[r1,#0x48]         ;3500
000154  6820              LDR      r0,[r4,#0]            ;3503
000156  68c0              LDR      r0,[r0,#0xc]          ;3503
000158  4330              ORRS     r0,r0,r6              ;3503
00015a  6821              LDR      r1,[r4,#0]            ;3503
00015c  60c8              STR      r0,[r1,#0xc]          ;3503
00015e  2001              MOVS     r0,#1                 ;3505
000160  63e0              STR      r0,[r4,#0x3c]         ;3505
000162  2000              MOVS     r0,#0                 ;3508
000164  e756              B        |L17.20|
;;;3510   
                          ENDP

000166  0000              DCW      0x0000
                  |L17.360|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L17.364|
                          DCD      TIM_DMAError
                  |L17.368|
                          DCD      TIM_DMADelayPulseCplt
                  |L17.372|
                          DCD      TIMEx_DMACommutationCplt
                  |L17.376|
                          DCD      TIM_DMATriggerCplt

                          AREA ||i.HAL_TIM_DMABurst_WriteStop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_WriteStop PROC
;;;3517     */
;;;3518   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
000000  b570              PUSH     {r4-r6,lr}
;;;3519   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;3520     /* Check the parameters */
;;;3521     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3522     
;;;3523     /* Abort the DMA transfer (at least disable the DMA channel) */
;;;3524     switch(BurstRequestSrc)
000006  f5b56f00          CMP      r5,#0x800
00000a  d020              BEQ      |L18.78|
00000c  dc09              BGT      |L18.34|
00000e  f5b57f80          CMP      r5,#0x100
000012  d010              BEQ      |L18.54|
000014  f5b57f00          CMP      r5,#0x200
000018  d011              BEQ      |L18.62|
00001a  f5b56f80          CMP      r5,#0x400
00001e  d126              BNE      |L18.110|
000020  e011              B        |L18.70|
                  |L18.34|
000022  f5b55f80          CMP      r5,#0x1000
000026  d016              BEQ      |L18.86|
000028  f5b55f00          CMP      r5,#0x2000
00002c  d017              BEQ      |L18.94|
00002e  f5b54f80          CMP      r5,#0x4000
000032  d11c              BNE      |L18.110|
000034  e017              B        |L18.102|
                  |L18.54|
;;;3525     {
;;;3526       case TIM_DMA_UPDATE:
;;;3527       {  
;;;3528         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
000036  69e0              LDR      r0,[r4,#0x1c]
000038  f7fffffe          BL       HAL_DMA_Abort
;;;3529       }
;;;3530       break;
00003c  e018              B        |L18.112|
                  |L18.62|
;;;3531       case TIM_DMA_CC1:
;;;3532       {  
;;;3533         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
00003e  6a20              LDR      r0,[r4,#0x20]
000040  f7fffffe          BL       HAL_DMA_Abort
;;;3534       }
;;;3535       break;
000044  e014              B        |L18.112|
                  |L18.70|
;;;3536       case TIM_DMA_CC2:
;;;3537       {  
;;;3538         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
000046  6a60              LDR      r0,[r4,#0x24]
000048  f7fffffe          BL       HAL_DMA_Abort
;;;3539       }
;;;3540       break;
00004c  e010              B        |L18.112|
                  |L18.78|
;;;3541       case TIM_DMA_CC3:
;;;3542       {  
;;;3543         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
00004e  6aa0              LDR      r0,[r4,#0x28]
000050  f7fffffe          BL       HAL_DMA_Abort
;;;3544       }
;;;3545       break;
000054  e00c              B        |L18.112|
                  |L18.86|
;;;3546       case TIM_DMA_CC4:
;;;3547       {  
;;;3548         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
000056  6ae0              LDR      r0,[r4,#0x2c]
000058  f7fffffe          BL       HAL_DMA_Abort
;;;3549       }
;;;3550       break;
00005c  e008              B        |L18.112|
                  |L18.94|
;;;3551       case TIM_DMA_COM:
;;;3552       {  
;;;3553         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
00005e  6b20              LDR      r0,[r4,#0x30]
000060  f7fffffe          BL       HAL_DMA_Abort
;;;3554       }
;;;3555       break;
000064  e004              B        |L18.112|
                  |L18.102|
;;;3556       case TIM_DMA_TRIGGER:
;;;3557       {  
;;;3558         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
000066  6b60              LDR      r0,[r4,#0x34]
000068  f7fffffe          BL       HAL_DMA_Abort
;;;3559       }
;;;3560       break;
00006c  e000              B        |L18.112|
                  |L18.110|
;;;3561       default:
;;;3562       break;
00006e  bf00              NOP      
                  |L18.112|
000070  bf00              NOP                            ;3530
;;;3563     }
;;;3564   
;;;3565     /* Disable the TIM Update DMA request */
;;;3566     __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
000072  6820              LDR      r0,[r4,#0]
000074  68c0              LDR      r0,[r0,#0xc]
000076  43a8              BICS     r0,r0,r5
000078  6821              LDR      r1,[r4,#0]
00007a  60c8              STR      r0,[r1,#0xc]
;;;3567         
;;;3568     /* Return function status */
;;;3569     return HAL_OK;  
00007c  2000              MOVS     r0,#0
;;;3570   }
00007e  bd70              POP      {r4-r6,pc}
;;;3571   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_DeInit PROC
;;;2368     */
;;;2369   HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;2370   {
000002  4604              MOV      r4,r0
;;;2371     /* Check the parameters */
;;;2372     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2373     
;;;2374     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  63e0              STR      r0,[r4,#0x3c]
;;;2375     
;;;2376     /* Disable the TIM Peripheral Clock */
;;;2377     __HAL_TIM_DISABLE(htim);
000008  bf00              NOP      
00000a  6820              LDR      r0,[r4,#0]
00000c  6a00              LDR      r0,[r0,#0x20]
00000e  f2411111          MOV      r1,#0x1111
000012  4008              ANDS     r0,r0,r1
000014  b950              CBNZ     r0,|L19.44|
000016  6820              LDR      r0,[r4,#0]
000018  6a00              LDR      r0,[r0,#0x20]
00001a  1089              ASRS     r1,r1,#2
00001c  4008              ANDS     r0,r0,r1
00001e  b928              CBNZ     r0,|L19.44|
000020  6820              LDR      r0,[r4,#0]
000022  6800              LDR      r0,[r0,#0]
000024  f0200001          BIC      r0,r0,#1
000028  6821              LDR      r1,[r4,#0]
00002a  6008              STR      r0,[r1,#0]
                  |L19.44|
00002c  bf00              NOP      
;;;2378     
;;;2379     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;2380     HAL_TIM_Encoder_MspDeInit(htim);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       HAL_TIM_Encoder_MspDeInit
;;;2381       
;;;2382     /* Change TIM state */  
;;;2383     htim->State = HAL_TIM_STATE_RESET;
000034  2000              MOVS     r0,#0
000036  63e0              STR      r0,[r4,#0x3c]
;;;2384    
;;;2385     /* Release Lock */
;;;2386     __HAL_UNLOCK(htim);
000038  bf00              NOP      
00003a  63a0              STR      r0,[r4,#0x38]
00003c  bf00              NOP      
;;;2387   
;;;2388     return HAL_OK;
;;;2389   }
00003e  bd10              POP      {r4,pc}
;;;2390   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_GetState PROC
;;;4591     */
;;;4592   HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;4593   {
;;;4594     return htim->State;
000002  6bc8              LDR      r0,[r1,#0x3c]
;;;4595   }
000004  4770              BX       lr
;;;4596   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Init||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Init PROC
;;;2279     */
;;;2280   HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef* sConfig)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2281   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;2282     uint32_t tmpsmcr = 0;
000008  f04f0800          MOV      r8,#0
;;;2283     uint32_t tmpccmr1 = 0;
00000c  2600              MOVS     r6,#0
;;;2284     uint32_t tmpccer = 0;
00000e  2700              MOVS     r7,#0
;;;2285     
;;;2286     /* Check the TIM handle allocation */
;;;2287     if(htim == NULL)
000010  b914              CBNZ     r4,|L21.24|
;;;2288     {
;;;2289       return HAL_ERROR;
000012  2001              MOVS     r0,#1
                  |L21.20|
;;;2290     }
;;;2291      
;;;2292     /* Check the parameters */
;;;2293     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2294     assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
;;;2295     assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
;;;2296     assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
;;;2297     assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
;;;2298     assert_param(IS_TIM_IC_POLARITY(sConfig->IC2Polarity));
;;;2299     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
;;;2300     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
;;;2301     assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
;;;2302     assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
;;;2303   
;;;2304     if(htim->State == HAL_TIM_STATE_RESET)
;;;2305     { 
;;;2306       /* Allocate lock resource and initialize it */
;;;2307       htim->Lock = HAL_UNLOCKED;  
;;;2308       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;2309       HAL_TIM_Encoder_MspInit(htim);
;;;2310     }
;;;2311     
;;;2312     /* Set the TIM state */
;;;2313     htim->State= HAL_TIM_STATE_BUSY;   
;;;2314       
;;;2315     /* Reset the SMS bits */
;;;2316     htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;2317     
;;;2318     /* Configure the Time base in the Encoder Mode */
;;;2319     TIM_Base_SetConfig(htim->Instance, &htim->Init);  
;;;2320     
;;;2321     /* Get the TIMx SMCR register value */
;;;2322     tmpsmcr = htim->Instance->SMCR;
;;;2323   
;;;2324     /* Get the TIMx CCMR1 register value */
;;;2325     tmpccmr1 = htim->Instance->CCMR1;
;;;2326   
;;;2327     /* Get the TIMx CCER register value */
;;;2328     tmpccer = htim->Instance->CCER;
;;;2329   
;;;2330     /* Set the encoder Mode */
;;;2331     tmpsmcr |= sConfig->EncoderMode;
;;;2332   
;;;2333     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;2334     tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
;;;2335     tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8));
;;;2336     
;;;2337     /* Set the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
;;;2338     tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
;;;2339     tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
;;;2340     tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8);
;;;2341     tmpccmr1 |= (sConfig->IC1Filter << 4) | (sConfig->IC2Filter << 12);
;;;2342   
;;;2343     /* Set the TI1 and the TI2 Polarities */
;;;2344     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
;;;2345     tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
;;;2346     tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4);
;;;2347     
;;;2348     /* Write to TIMx SMCR */
;;;2349     htim->Instance->SMCR = tmpsmcr;
;;;2350   
;;;2351     /* Write to TIMx CCMR1 */
;;;2352     htim->Instance->CCMR1 = tmpccmr1;
;;;2353   
;;;2354     /* Write to TIMx CCER */
;;;2355     htim->Instance->CCER = tmpccer;
;;;2356     
;;;2357     /* Initialize the TIM state*/
;;;2358     htim->State= HAL_TIM_STATE_READY;
;;;2359     
;;;2360     return HAL_OK;
;;;2361   }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L21.24|
000018  6be0              LDR      r0,[r4,#0x3c]         ;2304
00001a  b920              CBNZ     r0,|L21.38|
00001c  2000              MOVS     r0,#0                 ;2307
00001e  63a0              STR      r0,[r4,#0x38]         ;2307
000020  4620              MOV      r0,r4                 ;2309
000022  f7fffffe          BL       HAL_TIM_Encoder_MspInit
                  |L21.38|
000026  2002              MOVS     r0,#2                 ;2313
000028  63e0              STR      r0,[r4,#0x3c]         ;2313
00002a  6820              LDR      r0,[r4,#0]            ;2316
00002c  6880              LDR      r0,[r0,#8]            ;2316
00002e  491f              LDR      r1,|L21.172|
000030  4008              ANDS     r0,r0,r1              ;2316
000032  6821              LDR      r1,[r4,#0]            ;2316
000034  6088              STR      r0,[r1,#8]            ;2316
000036  1d21              ADDS     r1,r4,#4              ;2319
000038  6820              LDR      r0,[r4,#0]            ;2319
00003a  f7fffffe          BL       TIM_Base_SetConfig
00003e  6820              LDR      r0,[r4,#0]            ;2322
000040  f8d08008          LDR      r8,[r0,#8]            ;2322
000044  6820              LDR      r0,[r4,#0]            ;2325
000046  6986              LDR      r6,[r0,#0x18]         ;2325
000048  6820              LDR      r0,[r4,#0]            ;2328
00004a  6a07              LDR      r7,[r0,#0x20]         ;2328
00004c  6828              LDR      r0,[r5,#0]            ;2331
00004e  ea400808          ORR      r8,r0,r8              ;2331
000052  f2403003          MOV      r0,#0x303             ;2334
000056  4386              BICS     r6,r6,r0              ;2334
000058  69a9              LDR      r1,[r5,#0x18]         ;2335
00005a  68a8              LDR      r0,[r5,#8]            ;2335
00005c  ea402001          ORR      r0,r0,r1,LSL #8       ;2335
000060  4306              ORRS     r6,r6,r0              ;2335
000062  f640400c          MOV      r0,#0xc0c             ;2338
000066  4386              BICS     r6,r6,r0              ;2338
000068  f24f00f0          MOV      r0,#0xf0f0            ;2339
00006c  4386              BICS     r6,r6,r0              ;2339
00006e  69e9              LDR      r1,[r5,#0x1c]         ;2340
000070  68e8              LDR      r0,[r5,#0xc]          ;2340
000072  ea402001          ORR      r0,r0,r1,LSL #8       ;2340
000076  4306              ORRS     r6,r6,r0              ;2340
000078  6928              LDR      r0,[r5,#0x10]         ;2341
00007a  0100              LSLS     r0,r0,#4              ;2341
00007c  6a29              LDR      r1,[r5,#0x20]         ;2341
00007e  ea403001          ORR      r0,r0,r1,LSL #12      ;2341
000082  4306              ORRS     r6,r6,r0              ;2341
000084  f0270722          BIC      r7,r7,#0x22           ;2344
000088  f0270788          BIC      r7,r7,#0x88           ;2345
00008c  6969              LDR      r1,[r5,#0x14]         ;2346
00008e  6868              LDR      r0,[r5,#4]            ;2346
000090  ea401001          ORR      r0,r0,r1,LSL #4       ;2346
000094  4307              ORRS     r7,r7,r0              ;2346
000096  6820              LDR      r0,[r4,#0]            ;2349
000098  f8c08008          STR      r8,[r0,#8]            ;2349
00009c  6820              LDR      r0,[r4,#0]            ;2352
00009e  6186              STR      r6,[r0,#0x18]         ;2352
0000a0  6820              LDR      r0,[r4,#0]            ;2355
0000a2  6207              STR      r7,[r0,#0x20]         ;2355
0000a4  2001              MOVS     r0,#1                 ;2358
0000a6  63e0              STR      r0,[r4,#0x3c]         ;2358
0000a8  2000              MOVS     r0,#0                 ;2360
0000aa  e7b3              B        |L21.20|
;;;2362   
                          ENDP

                  |L21.172|
                          DCD      0xfffefff8

                          AREA ||i.HAL_TIM_Encoder_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_MspDeInit PROC
;;;2412     */
;;;2413   __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2414   {
;;;2415     /* Prevent unused argument(s) compilation warning */
;;;2416     UNUSED(htim);
;;;2417    
;;;2418     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2419               the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
;;;2420      */
;;;2421   }
;;;2422   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_MspInit PROC
;;;2396     */
;;;2397   __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2398   {
;;;2399     /* Prevent unused argument(s) compilation warning */
;;;2400     UNUSED(htim);
;;;2401    
;;;2402     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2403               the HAL_TIM_Encoder_MspInit could be implemented in the user file
;;;2404      */
;;;2405   }
;;;2406   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Start PROC
;;;2433     */
;;;2434   HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;2435   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2436     /* Check the parameters */
;;;2437     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2438     
;;;2439     /* Enable the encoder interface channels */
;;;2440     switch (Channel)
000006  b115              CBZ      r5,|L24.14|
000008  2d04              CMP      r5,#4
00000a  d10c              BNE      |L24.38|
00000c  e005              B        |L24.26|
                  |L24.14|
;;;2441     {
;;;2442       case TIM_CHANNEL_1:
;;;2443       {
;;;2444         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
00000e  2201              MOVS     r2,#1
000010  2100              MOVS     r1,#0
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       TIM_CCxChannelCmd
;;;2445         break; 
000018  e010              B        |L24.60|
                  |L24.26|
;;;2446       }
;;;2447       case TIM_CHANNEL_2:
;;;2448       { 
;;;2449         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
00001a  2201              MOVS     r2,#1
00001c  2104              MOVS     r1,#4
00001e  6820              LDR      r0,[r4,#0]
000020  f7fffffe          BL       TIM_CCxChannelCmd
;;;2450         break;
000024  e00a              B        |L24.60|
                  |L24.38|
;;;2451       }  
;;;2452       default :
;;;2453       {
;;;2454        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000026  2201              MOVS     r2,#1
000028  2100              MOVS     r1,#0
00002a  6820              LDR      r0,[r4,#0]
00002c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2455        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000030  2201              MOVS     r2,#1
000032  2104              MOVS     r1,#4
000034  6820              LDR      r0,[r4,#0]
000036  f7fffffe          BL       TIM_CCxChannelCmd
;;;2456        break; 
00003a  bf00              NOP      
                  |L24.60|
00003c  bf00              NOP                            ;2445
;;;2457       }
;;;2458     }  
;;;2459     /* Enable the Peripheral */
;;;2460     __HAL_TIM_ENABLE(htim);
00003e  6820              LDR      r0,[r4,#0]
000040  6800              LDR      r0,[r0,#0]
000042  f0400001          ORR      r0,r0,#1
000046  6821              LDR      r1,[r4,#0]
000048  6008              STR      r0,[r1,#0]
;;;2461     
;;;2462     /* Return function status */
;;;2463     return HAL_OK;
00004a  2000              MOVS     r0,#0
;;;2464   }
00004c  bd30              POP      {r4,r5,pc}
;;;2465   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Start_DMA PROC
;;;2624     */
;;;2625   HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1, uint32_t *pData2, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2626   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;2627     /* Check the parameters */
;;;2628     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2629     
;;;2630     if((htim->State == HAL_TIM_STATE_BUSY))
000010  6be0              LDR      r0,[r4,#0x3c]
000012  2802              CMP      r0,#2
000014  d101              BNE      |L25.26|
                  |L25.22|
;;;2631     {
;;;2632        return HAL_BUSY;
;;;2633     }
;;;2634     else if((htim->State == HAL_TIM_STATE_READY))
;;;2635     {
;;;2636       if((((pData1 == 0) || (pData2 == 0) )) && (Length > 0)) 
;;;2637       {
;;;2638         return HAL_ERROR;                                    
;;;2639       }
;;;2640       else
;;;2641       {
;;;2642         htim->State = HAL_TIM_STATE_BUSY;
;;;2643       }
;;;2644     }  
;;;2645      
;;;2646     switch (Channel)
;;;2647     {
;;;2648       case TIM_CHANNEL_1:
;;;2649       {
;;;2650         /* Set the DMA Period elapsed callback */
;;;2651         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;2652        
;;;2653         /* Set the DMA error callback */
;;;2654         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;2655         
;;;2656         /* Enable the DMA Stream */
;;;2657         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t )pData1, Length); 
;;;2658         
;;;2659         /* Enable the TIM Input Capture DMA request */      
;;;2660         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;2661               
;;;2662         /* Enable the Peripheral */
;;;2663         __HAL_TIM_ENABLE(htim);
;;;2664         
;;;2665         /* Enable the Capture compare channel */
;;;2666         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2667       }
;;;2668       break;
;;;2669       
;;;2670       case TIM_CHANNEL_2:
;;;2671       {
;;;2672         /* Set the DMA Period elapsed callback */
;;;2673         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;2674        
;;;2675         /* Set the DMA error callback */
;;;2676         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError;
;;;2677         /* Enable the DMA Stream */
;;;2678         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
;;;2679         
;;;2680         /* Enable the TIM Input Capture  DMA request */
;;;2681         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;2682        
;;;2683         /* Enable the Peripheral */
;;;2684         __HAL_TIM_ENABLE(htim);
;;;2685         
;;;2686         /* Enable the Capture compare channel */
;;;2687         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2688       }
;;;2689       break;
;;;2690       
;;;2691       case TIM_CHANNEL_ALL:
;;;2692       {
;;;2693         /* Set the DMA Period elapsed callback */
;;;2694         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;2695        
;;;2696         /* Set the DMA error callback */
;;;2697         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;2698         
;;;2699         /* Enable the DMA Stream */
;;;2700         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length);
;;;2701         
;;;2702         /* Set the DMA Period elapsed callback */
;;;2703         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;2704        
;;;2705         /* Set the DMA error callback */
;;;2706         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;2707         
;;;2708         /* Enable the DMA Stream */
;;;2709         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
;;;2710             
;;;2711        /* Enable the Peripheral */
;;;2712         __HAL_TIM_ENABLE(htim);
;;;2713         
;;;2714         /* Enable the Capture compare channel */
;;;2715         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2716         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2717         
;;;2718         /* Enable the TIM Input Capture  DMA request */
;;;2719         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;2720         /* Enable the TIM Input Capture  DMA request */
;;;2721         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;2722       }
;;;2723       break;
;;;2724       
;;;2725       default:
;;;2726       break;
;;;2727     }  
;;;2728     /* Return function status */
;;;2729     return HAL_OK;
;;;2730   }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L25.26|
00001a  6be0              LDR      r0,[r4,#0x3c]         ;2634
00001c  2801              CMP      r0,#1                 ;2634
00001e  d108              BNE      |L25.50|
000020  b107              CBZ      r7,|L25.36|
000022  b925              CBNZ     r5,|L25.46|
                  |L25.36|
000024  f1b80f00          CMP      r8,#0                 ;2636
000028  dd01              BLE      |L25.46|
00002a  2001              MOVS     r0,#1                 ;2638
00002c  e7f3              B        |L25.22|
                  |L25.46|
00002e  2002              MOVS     r0,#2                 ;2642
000030  63e0              STR      r0,[r4,#0x3c]         ;2642
                  |L25.50|
000032  b126              CBZ      r6,|L25.62|
000034  2e04              CMP      r6,#4                 ;2646
000036  d022              BEQ      |L25.126|
000038  2e3c              CMP      r6,#0x3c              ;2646
00003a  d17a              BNE      |L25.306|
00003c  e03f              B        |L25.190|
                  |L25.62|
00003e  493f              LDR      r1,|L25.316|
000040  6a20              LDR      r0,[r4,#0x20]         ;2651
000042  6401              STR      r1,[r0,#0x40]         ;2651
000044  493e              LDR      r1,|L25.320|
000046  6a20              LDR      r0,[r4,#0x20]         ;2654
000048  6501              STR      r1,[r0,#0x50]         ;2654
00004a  6822              LDR      r2,[r4,#0]            ;2657
00004c  f1020134          ADD      r1,r2,#0x34           ;2657
000050  4643              MOV      r3,r8                 ;2657
000052  463a              MOV      r2,r7                 ;2657
000054  6a20              LDR      r0,[r4,#0x20]         ;2657
000056  f7fffffe          BL       HAL_DMA_Start_IT
00005a  6820              LDR      r0,[r4,#0]            ;2660
00005c  68c0              LDR      r0,[r0,#0xc]          ;2660
00005e  f4407000          ORR      r0,r0,#0x200          ;2660
000062  6821              LDR      r1,[r4,#0]            ;2660
000064  60c8              STR      r0,[r1,#0xc]          ;2660
000066  6820              LDR      r0,[r4,#0]            ;2663
000068  6800              LDR      r0,[r0,#0]            ;2663
00006a  f0400001          ORR      r0,r0,#1              ;2663
00006e  6821              LDR      r1,[r4,#0]            ;2663
000070  6008              STR      r0,[r1,#0]            ;2663
000072  2201              MOVS     r2,#1                 ;2666
000074  2100              MOVS     r1,#0                 ;2666
000076  6820              LDR      r0,[r4,#0]            ;2666
000078  f7fffffe          BL       TIM_CCxChannelCmd
00007c  e05a              B        |L25.308|
                  |L25.126|
00007e  492f              LDR      r1,|L25.316|
000080  6a60              LDR      r0,[r4,#0x24]         ;2673
000082  6401              STR      r1,[r0,#0x40]         ;2673
000084  492e              LDR      r1,|L25.320|
000086  6a60              LDR      r0,[r4,#0x24]         ;2676
000088  6501              STR      r1,[r0,#0x50]         ;2676
00008a  6822              LDR      r2,[r4,#0]            ;2678
00008c  f1020138          ADD      r1,r2,#0x38           ;2678
000090  4643              MOV      r3,r8                 ;2678
000092  462a              MOV      r2,r5                 ;2678
000094  6a60              LDR      r0,[r4,#0x24]         ;2678
000096  f7fffffe          BL       HAL_DMA_Start_IT
00009a  6820              LDR      r0,[r4,#0]            ;2681
00009c  68c0              LDR      r0,[r0,#0xc]          ;2681
00009e  f4406080          ORR      r0,r0,#0x400          ;2681
0000a2  6821              LDR      r1,[r4,#0]            ;2681
0000a4  60c8              STR      r0,[r1,#0xc]          ;2681
0000a6  6820              LDR      r0,[r4,#0]            ;2684
0000a8  6800              LDR      r0,[r0,#0]            ;2684
0000aa  f0400001          ORR      r0,r0,#1              ;2684
0000ae  6821              LDR      r1,[r4,#0]            ;2684
0000b0  6008              STR      r0,[r1,#0]            ;2684
0000b2  2201              MOVS     r2,#1                 ;2687
0000b4  2104              MOVS     r1,#4                 ;2687
0000b6  6820              LDR      r0,[r4,#0]            ;2687
0000b8  f7fffffe          BL       TIM_CCxChannelCmd
0000bc  e03a              B        |L25.308|
                  |L25.190|
0000be  491f              LDR      r1,|L25.316|
0000c0  6a20              LDR      r0,[r4,#0x20]         ;2694
0000c2  6401              STR      r1,[r0,#0x40]         ;2694
0000c4  491e              LDR      r1,|L25.320|
0000c6  6a20              LDR      r0,[r4,#0x20]         ;2697
0000c8  6501              STR      r1,[r0,#0x50]         ;2697
0000ca  6822              LDR      r2,[r4,#0]            ;2700
0000cc  f1020134          ADD      r1,r2,#0x34           ;2700
0000d0  4643              MOV      r3,r8                 ;2700
0000d2  463a              MOV      r2,r7                 ;2700
0000d4  6a20              LDR      r0,[r4,#0x20]         ;2700
0000d6  f7fffffe          BL       HAL_DMA_Start_IT
0000da  4918              LDR      r1,|L25.316|
0000dc  6a60              LDR      r0,[r4,#0x24]         ;2703
0000de  6401              STR      r1,[r0,#0x40]         ;2703
0000e0  4917              LDR      r1,|L25.320|
0000e2  6a60              LDR      r0,[r4,#0x24]         ;2706
0000e4  6501              STR      r1,[r0,#0x50]         ;2706
0000e6  6822              LDR      r2,[r4,#0]            ;2709
0000e8  f1020138          ADD      r1,r2,#0x38           ;2709
0000ec  4643              MOV      r3,r8                 ;2709
0000ee  462a              MOV      r2,r5                 ;2709
0000f0  6a60              LDR      r0,[r4,#0x24]         ;2709
0000f2  f7fffffe          BL       HAL_DMA_Start_IT
0000f6  6820              LDR      r0,[r4,#0]            ;2712
0000f8  6800              LDR      r0,[r0,#0]            ;2712
0000fa  f0400001          ORR      r0,r0,#1              ;2712
0000fe  6821              LDR      r1,[r4,#0]            ;2712
000100  6008              STR      r0,[r1,#0]            ;2712
000102  2201              MOVS     r2,#1                 ;2715
000104  2100              MOVS     r1,#0                 ;2715
000106  6820              LDR      r0,[r4,#0]            ;2715
000108  f7fffffe          BL       TIM_CCxChannelCmd
00010c  2201              MOVS     r2,#1                 ;2716
00010e  2104              MOVS     r1,#4                 ;2716
000110  6820              LDR      r0,[r4,#0]            ;2716
000112  f7fffffe          BL       TIM_CCxChannelCmd
000116  6820              LDR      r0,[r4,#0]            ;2719
000118  68c0              LDR      r0,[r0,#0xc]          ;2719
00011a  f4407000          ORR      r0,r0,#0x200          ;2719
00011e  6821              LDR      r1,[r4,#0]            ;2719
000120  60c8              STR      r0,[r1,#0xc]          ;2719
000122  6820              LDR      r0,[r4,#0]            ;2721
000124  68c0              LDR      r0,[r0,#0xc]          ;2721
000126  f4406080          ORR      r0,r0,#0x400          ;2721
00012a  6821              LDR      r1,[r4,#0]            ;2721
00012c  60c8              STR      r0,[r1,#0xc]          ;2721
00012e  e001              B        |L25.308|
000130  e7ff              B        |L25.306|
                  |L25.306|
000132  bf00              NOP                            ;2726
                  |L25.308|
000134  bf00              NOP                            ;2668
000136  2000              MOVS     r0,#0                 ;2729
000138  e76d              B        |L25.22|
;;;2731   
                          ENDP

00013a  0000              DCW      0x0000
                  |L25.316|
                          DCD      TIM_DMACaptureCplt
                  |L25.320|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_Encoder_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Start_IT PROC
;;;2520     */
;;;2521   HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;2522   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2523     /* Check the parameters */
;;;2524     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2525     
;;;2526     /* Enable the encoder interface channels */
;;;2527     /* Enable the capture compare Interrupts 1 and/or 2 */
;;;2528     switch (Channel)
000006  b115              CBZ      r5,|L26.14|
000008  2d04              CMP      r5,#4
00000a  d118              BNE      |L26.62|
00000c  e00b              B        |L26.38|
                  |L26.14|
;;;2529     {
;;;2530       case TIM_CHANNEL_1:
;;;2531       {
;;;2532         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
00000e  2201              MOVS     r2,#1
000010  2100              MOVS     r1,#0
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       TIM_CCxChannelCmd
;;;2533         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000018  6820              LDR      r0,[r4,#0]
00001a  68c0              LDR      r0,[r0,#0xc]
00001c  f0400002          ORR      r0,r0,#2
000020  6821              LDR      r1,[r4,#0]
000022  60c8              STR      r0,[r1,#0xc]
;;;2534         break; 
000024  e022              B        |L26.108|
                  |L26.38|
;;;2535       }
;;;2536       case TIM_CHANNEL_2:
;;;2537       { 
;;;2538         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000026  2201              MOVS     r2,#1
000028  2104              MOVS     r1,#4
00002a  6820              LDR      r0,[r4,#0]
00002c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2539         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2); 
000030  6820              LDR      r0,[r4,#0]
000032  68c0              LDR      r0,[r0,#0xc]
000034  f0400004          ORR      r0,r0,#4
000038  6821              LDR      r1,[r4,#0]
00003a  60c8              STR      r0,[r1,#0xc]
;;;2540         break;
00003c  e016              B        |L26.108|
                  |L26.62|
;;;2541       }  
;;;2542       default :
;;;2543       {
;;;2544        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
00003e  2201              MOVS     r2,#1
000040  2100              MOVS     r1,#0
000042  6820              LDR      r0,[r4,#0]
000044  f7fffffe          BL       TIM_CCxChannelCmd
;;;2545        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000048  2201              MOVS     r2,#1
00004a  2104              MOVS     r1,#4
00004c  6820              LDR      r0,[r4,#0]
00004e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2546        __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000052  6820              LDR      r0,[r4,#0]
000054  68c0              LDR      r0,[r0,#0xc]
000056  f0400002          ORR      r0,r0,#2
00005a  6821              LDR      r1,[r4,#0]
00005c  60c8              STR      r0,[r1,#0xc]
;;;2547        __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00005e  6820              LDR      r0,[r4,#0]
000060  68c0              LDR      r0,[r0,#0xc]
000062  f0400004          ORR      r0,r0,#4
000066  6821              LDR      r1,[r4,#0]
000068  60c8              STR      r0,[r1,#0xc]
;;;2548        break; 
00006a  bf00              NOP      
                  |L26.108|
00006c  bf00              NOP                            ;2534
;;;2549       }
;;;2550     }
;;;2551     
;;;2552     /* Enable the Peripheral */
;;;2553     __HAL_TIM_ENABLE(htim);
00006e  6820              LDR      r0,[r4,#0]
000070  6800              LDR      r0,[r0,#0]
000072  f0400001          ORR      r0,r0,#1
000076  6821              LDR      r1,[r4,#0]
000078  6008              STR      r0,[r1,#0]
;;;2554     
;;;2555     /* Return function status */
;;;2556     return HAL_OK;
00007a  2000              MOVS     r0,#0
;;;2557   }
00007c  bd30              POP      {r4,r5,pc}
;;;2558   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Stop PROC
;;;2476     */
;;;2477   HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;2478   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2479     /* Check the parameters */
;;;2480       assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2481       
;;;2482      /* Disable the Input Capture channels 1 and 2
;;;2483       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
;;;2484     switch (Channel)
000006  b115              CBZ      r5,|L27.14|
000008  2d04              CMP      r5,#4
00000a  d10c              BNE      |L27.38|
00000c  e005              B        |L27.26|
                  |L27.14|
;;;2485     {
;;;2486       case TIM_CHANNEL_1:
;;;2487       {
;;;2488         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
00000e  2200              MOVS     r2,#0
000010  4611              MOV      r1,r2
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       TIM_CCxChannelCmd
;;;2489         break; 
000018  e010              B        |L27.60|
                  |L27.26|
;;;2490       }
;;;2491       case TIM_CHANNEL_2:
;;;2492       { 
;;;2493         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
00001a  2200              MOVS     r2,#0
00001c  2104              MOVS     r1,#4
00001e  6820              LDR      r0,[r4,#0]
000020  f7fffffe          BL       TIM_CCxChannelCmd
;;;2494         break;
000024  e00a              B        |L27.60|
                  |L27.38|
;;;2495       }  
;;;2496       default :
;;;2497       {
;;;2498        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000026  2200              MOVS     r2,#0
000028  4611              MOV      r1,r2
00002a  6820              LDR      r0,[r4,#0]
00002c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2499        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000030  2200              MOVS     r2,#0
000032  2104              MOVS     r1,#4
000034  6820              LDR      r0,[r4,#0]
000036  f7fffffe          BL       TIM_CCxChannelCmd
;;;2500        break; 
00003a  bf00              NOP      
                  |L27.60|
00003c  bf00              NOP                            ;2489
;;;2501       }
;;;2502     }  
;;;2503     /* Disable the Peripheral */
;;;2504     __HAL_TIM_DISABLE(htim);
00003e  bf00              NOP      
000040  6820              LDR      r0,[r4,#0]
000042  6a00              LDR      r0,[r0,#0x20]
000044  f2411111          MOV      r1,#0x1111
000048  4008              ANDS     r0,r0,r1
00004a  b950              CBNZ     r0,|L27.98|
00004c  6820              LDR      r0,[r4,#0]
00004e  6a00              LDR      r0,[r0,#0x20]
000050  1089              ASRS     r1,r1,#2
000052  4008              ANDS     r0,r0,r1
000054  b928              CBNZ     r0,|L27.98|
000056  6820              LDR      r0,[r4,#0]
000058  6800              LDR      r0,[r0,#0]
00005a  f0200001          BIC      r0,r0,#1
00005e  6821              LDR      r1,[r4,#0]
000060  6008              STR      r0,[r1,#0]
                  |L27.98|
000062  bf00              NOP      
;;;2505     
;;;2506     /* Return function status */
;;;2507     return HAL_OK;
000064  2000              MOVS     r0,#0
;;;2508   }
000066  bd30              POP      {r4,r5,pc}
;;;2509   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Stop_DMA PROC
;;;2742     */
;;;2743   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;2744   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2745     /* Check the parameters */
;;;2746     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2747     
;;;2748     /* Disable the Input Capture channels 1 and 2
;;;2749       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
;;;2750     if(Channel == TIM_CHANNEL_1)
000006  b95d              CBNZ     r5,|L28.32|
;;;2751     {
;;;2752       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
000008  2200              MOVS     r2,#0
00000a  4611              MOV      r1,r2
00000c  6820              LDR      r0,[r4,#0]
00000e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2753       
;;;2754       /* Disable the capture compare DMA Request 1 */
;;;2755       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000012  6820              LDR      r0,[r4,#0]
000014  68c0              LDR      r0,[r0,#0xc]
000016  f4207000          BIC      r0,r0,#0x200
00001a  6821              LDR      r1,[r4,#0]
00001c  60c8              STR      r0,[r1,#0xc]
00001e  e023              B        |L28.104|
                  |L28.32|
;;;2756     }  
;;;2757     else if(Channel == TIM_CHANNEL_2)
000020  2d04              CMP      r5,#4
000022  d10b              BNE      |L28.60|
;;;2758     {  
;;;2759       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
000024  2200              MOVS     r2,#0
000026  2104              MOVS     r1,#4
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;2760       
;;;2761       /* Disable the capture compare DMA Request 2 */
;;;2762       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00002e  6820              LDR      r0,[r4,#0]
000030  68c0              LDR      r0,[r0,#0xc]
000032  f4206080          BIC      r0,r0,#0x400
000036  6821              LDR      r1,[r4,#0]
000038  60c8              STR      r0,[r1,#0xc]
00003a  e015              B        |L28.104|
                  |L28.60|
;;;2763     }  
;;;2764     else
;;;2765     {
;;;2766       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
00003c  2200              MOVS     r2,#0
00003e  4611              MOV      r1,r2
000040  6820              LDR      r0,[r4,#0]
000042  f7fffffe          BL       TIM_CCxChannelCmd
;;;2767       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
000046  2200              MOVS     r2,#0
000048  2104              MOVS     r1,#4
00004a  6820              LDR      r0,[r4,#0]
00004c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2768       
;;;2769       /* Disable the capture compare DMA Request 1 and 2 */
;;;2770       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000050  6820              LDR      r0,[r4,#0]
000052  68c0              LDR      r0,[r0,#0xc]
000054  f4207000          BIC      r0,r0,#0x200
000058  6821              LDR      r1,[r4,#0]
00005a  60c8              STR      r0,[r1,#0xc]
;;;2771       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00005c  6820              LDR      r0,[r4,#0]
00005e  68c0              LDR      r0,[r0,#0xc]
000060  f4206080          BIC      r0,r0,#0x400
000064  6821              LDR      r1,[r4,#0]
000066  60c8              STR      r0,[r1,#0xc]
                  |L28.104|
;;;2772     }
;;;2773     
;;;2774     /* Disable the Peripheral */
;;;2775     __HAL_TIM_DISABLE(htim);
000068  bf00              NOP      
00006a  6820              LDR      r0,[r4,#0]
00006c  6a00              LDR      r0,[r0,#0x20]
00006e  f2411111          MOV      r1,#0x1111
000072  4008              ANDS     r0,r0,r1
000074  b950              CBNZ     r0,|L28.140|
000076  6820              LDR      r0,[r4,#0]
000078  6a00              LDR      r0,[r0,#0x20]
00007a  1089              ASRS     r1,r1,#2
00007c  4008              ANDS     r0,r0,r1
00007e  b928              CBNZ     r0,|L28.140|
000080  6820              LDR      r0,[r4,#0]
000082  6800              LDR      r0,[r0,#0]
000084  f0200001          BIC      r0,r0,#1
000088  6821              LDR      r1,[r4,#0]
00008a  6008              STR      r0,[r1,#0]
                  |L28.140|
00008c  bf00              NOP      
;;;2776     
;;;2777     /* Change the htim state */
;;;2778     htim->State = HAL_TIM_STATE_READY;
00008e  2001              MOVS     r0,#1
000090  63e0              STR      r0,[r4,#0x3c]
;;;2779     
;;;2780     /* Return function status */
;;;2781     return HAL_OK;
000092  2000              MOVS     r0,#0
;;;2782   }
000094  bd30              POP      {r4,r5,pc}
;;;2783   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Stop_IT PROC
;;;2569     */
;;;2570   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;2571   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2572     /* Check the parameters */
;;;2573     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2574       
;;;2575     /* Disable the Input Capture channels 1 and 2
;;;2576       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
;;;2577     if(Channel == TIM_CHANNEL_1)
000006  b95d              CBNZ     r5,|L29.32|
;;;2578     {
;;;2579       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
000008  2200              MOVS     r2,#0
00000a  4611              MOV      r1,r2
00000c  6820              LDR      r0,[r4,#0]
00000e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2580       
;;;2581       /* Disable the capture compare Interrupts 1 */
;;;2582     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000012  6820              LDR      r0,[r4,#0]
000014  68c0              LDR      r0,[r0,#0xc]
000016  f0200002          BIC      r0,r0,#2
00001a  6821              LDR      r1,[r4,#0]
00001c  60c8              STR      r0,[r1,#0xc]
00001e  e023              B        |L29.104|
                  |L29.32|
;;;2583     }  
;;;2584     else if(Channel == TIM_CHANNEL_2)
000020  2d04              CMP      r5,#4
000022  d10b              BNE      |L29.60|
;;;2585     {  
;;;2586       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
000024  2200              MOVS     r2,#0
000026  2104              MOVS     r1,#4
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;2587       
;;;2588       /* Disable the capture compare Interrupts 2 */
;;;2589     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00002e  6820              LDR      r0,[r4,#0]
000030  68c0              LDR      r0,[r0,#0xc]
000032  f0200004          BIC      r0,r0,#4
000036  6821              LDR      r1,[r4,#0]
000038  60c8              STR      r0,[r1,#0xc]
00003a  e015              B        |L29.104|
                  |L29.60|
;;;2590     }  
;;;2591     else
;;;2592     {
;;;2593       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
00003c  2200              MOVS     r2,#0
00003e  4611              MOV      r1,r2
000040  6820              LDR      r0,[r4,#0]
000042  f7fffffe          BL       TIM_CCxChannelCmd
;;;2594       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
000046  2200              MOVS     r2,#0
000048  2104              MOVS     r1,#4
00004a  6820              LDR      r0,[r4,#0]
00004c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2595       
;;;2596       /* Disable the capture compare Interrupts 1 and 2 */
;;;2597       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000050  6820              LDR      r0,[r4,#0]
000052  68c0              LDR      r0,[r0,#0xc]
000054  f0200002          BIC      r0,r0,#2
000058  6821              LDR      r1,[r4,#0]
00005a  60c8              STR      r0,[r1,#0xc]
;;;2598       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00005c  6820              LDR      r0,[r4,#0]
00005e  68c0              LDR      r0,[r0,#0xc]
000060  f0200004          BIC      r0,r0,#4
000064  6821              LDR      r1,[r4,#0]
000066  60c8              STR      r0,[r1,#0xc]
                  |L29.104|
;;;2599     }
;;;2600       
;;;2601     /* Disable the Peripheral */
;;;2602     __HAL_TIM_DISABLE(htim);
000068  bf00              NOP      
00006a  6820              LDR      r0,[r4,#0]
00006c  6a00              LDR      r0,[r0,#0x20]
00006e  f2411111          MOV      r1,#0x1111
000072  4008              ANDS     r0,r0,r1
000074  b950              CBNZ     r0,|L29.140|
000076  6820              LDR      r0,[r4,#0]
000078  6a00              LDR      r0,[r0,#0x20]
00007a  1089              ASRS     r1,r1,#2
00007c  4008              ANDS     r0,r0,r1
00007e  b928              CBNZ     r0,|L29.140|
000080  6820              LDR      r0,[r4,#0]
000082  6800              LDR      r0,[r0,#0]
000084  f0200001          BIC      r0,r0,#1
000088  6821              LDR      r1,[r4,#0]
00008a  6008              STR      r0,[r1,#0]
                  |L29.140|
00008c  bf00              NOP      
;;;2603     
;;;2604     /* Change the htim state */
;;;2605     htim->State = HAL_TIM_STATE_READY;
00008e  2001              MOVS     r0,#1
000090  63e0              STR      r0,[r4,#0x3c]
;;;2606     
;;;2607     /* Return function status */
;;;2608     return HAL_OK;
000092  2000              MOVS     r0,#0
;;;2609   }
000094  bd30              POP      {r4,r5,pc}
;;;2610   
                          ENDP


                          AREA ||i.HAL_TIM_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ErrorCallback PROC
;;;4501     */
;;;4502   __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4503   {
;;;4504     /* Prevent unused argument(s) compilation warning */
;;;4505     UNUSED(htim);
;;;4506    
;;;4507     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4508               the HAL_TIM_ErrorCallback could be implemented in the user file
;;;4509      */
;;;4510   }
;;;4511   
                          ENDP


                          AREA ||i.HAL_TIM_GenerateEvent||, CODE, READONLY, ALIGN=1

                  HAL_TIM_GenerateEvent PROC
;;;3817   
;;;3818   HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
000000  4602              MOV      r2,r0
;;;3819   {
;;;3820     /* Check the parameters */
;;;3821     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;3822     assert_param(IS_TIM_EVENT_SOURCE(EventSource));
;;;3823     
;;;3824     /* Process Locked */
;;;3825     __HAL_LOCK(htim);
000002  bf00              NOP      
000004  6b90              LDR      r0,[r2,#0x38]
000006  2801              CMP      r0,#1
000008  d101              BNE      |L31.14|
00000a  2002              MOVS     r0,#2
                  |L31.12|
;;;3826     
;;;3827     /* Change the TIM state */
;;;3828     htim->State = HAL_TIM_STATE_BUSY;
;;;3829     
;;;3830     /* Set the event sources */
;;;3831     htim->Instance->EGR = EventSource;
;;;3832     
;;;3833     /* Change the TIM state */
;;;3834     htim->State = HAL_TIM_STATE_READY;
;;;3835     
;;;3836     __HAL_UNLOCK(htim);
;;;3837     
;;;3838     /* Return function status */
;;;3839     return HAL_OK;  
;;;3840   }
00000c  4770              BX       lr
                  |L31.14|
00000e  2001              MOVS     r0,#1                 ;3825
000010  6390              STR      r0,[r2,#0x38]         ;3825
000012  bf00              NOP                            ;3825
000014  2002              MOVS     r0,#2                 ;3828
000016  63d0              STR      r0,[r2,#0x3c]         ;3828
000018  6810              LDR      r0,[r2,#0]            ;3831
00001a  6141              STR      r1,[r0,#0x14]         ;3831
00001c  2001              MOVS     r0,#1                 ;3834
00001e  63d0              STR      r0,[r2,#0x3c]         ;3834
000020  bf00              NOP                            ;3836
000022  2000              MOVS     r0,#0                 ;3836
000024  6390              STR      r0,[r2,#0x38]         ;3836
000026  bf00              NOP                            ;3836
000028  bf00              NOP                            ;3839
00002a  e7ef              B        |L31.12|
;;;3841   
                          ENDP


                          AREA ||i.HAL_TIM_IC_CaptureCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_CaptureCallback PROC
;;;4453     */
;;;4454   __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4455   {
;;;4456     /* Prevent unused argument(s) compilation warning */
;;;4457     UNUSED(htim);
;;;4458    
;;;4459     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4460               the __HAL_TIM_IC_CaptureCallback could be implemented in the user file
;;;4461      */
;;;4462   }
;;;4463   
                          ENDP


                          AREA ||i.HAL_TIM_IC_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_ConfigChannel PROC
;;;3050     */
;;;3051   HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef* sConfig, uint32_t Channel)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3052   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;3053     /* Check the parameters */
;;;3054     assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3055     assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
;;;3056     assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
;;;3057     assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
;;;3058     assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
;;;3059     
;;;3060     __HAL_LOCK(htim);
00000a  bf00              NOP      
00000c  6ba0              LDR      r0,[r4,#0x38]
00000e  2801              CMP      r0,#1
000010  d102              BNE      |L33.24|
000012  2002              MOVS     r0,#2
                  |L33.20|
;;;3061     
;;;3062     htim->State = HAL_TIM_STATE_BUSY;
;;;3063     
;;;3064     if (Channel == TIM_CHANNEL_1)
;;;3065     {
;;;3066       /* TI1 Configuration */
;;;3067       TIM_TI1_SetConfig(htim->Instance,
;;;3068                  sConfig->ICPolarity,
;;;3069                  sConfig->ICSelection,
;;;3070                  sConfig->ICFilter);
;;;3071                  
;;;3072       /* Reset the IC1PSC Bits */
;;;3073       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;3074   
;;;3075       /* Set the IC1PSC value */
;;;3076       htim->Instance->CCMR1 |= sConfig->ICPrescaler;
;;;3077     }
;;;3078     else if (Channel == TIM_CHANNEL_2)
;;;3079     {
;;;3080       /* TI2 Configuration */
;;;3081       assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3082       
;;;3083       TIM_TI2_SetConfig(htim->Instance, 
;;;3084                         sConfig->ICPolarity,
;;;3085                         sConfig->ICSelection,
;;;3086                         sConfig->ICFilter);
;;;3087                  
;;;3088       /* Reset the IC2PSC Bits */
;;;3089       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;3090   
;;;3091       /* Set the IC2PSC value */
;;;3092       htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8);
;;;3093     }
;;;3094     else if (Channel == TIM_CHANNEL_3)
;;;3095     {
;;;3096       /* TI3 Configuration */
;;;3097       assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3098       
;;;3099       TIM_TI3_SetConfig(htim->Instance,  
;;;3100                  sConfig->ICPolarity,
;;;3101                  sConfig->ICSelection,
;;;3102                  sConfig->ICFilter);
;;;3103                  
;;;3104       /* Reset the IC3PSC Bits */
;;;3105       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
;;;3106   
;;;3107       /* Set the IC3PSC value */
;;;3108       htim->Instance->CCMR2 |= sConfig->ICPrescaler;
;;;3109     }
;;;3110     else
;;;3111     {
;;;3112       /* TI4 Configuration */
;;;3113       assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3114       
;;;3115       TIM_TI4_SetConfig(htim->Instance, 
;;;3116                  sConfig->ICPolarity,
;;;3117                  sConfig->ICSelection,
;;;3118                  sConfig->ICFilter);
;;;3119                  
;;;3120       /* Reset the IC4PSC Bits */
;;;3121       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
;;;3122   
;;;3123       /* Set the IC4PSC value */
;;;3124       htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8);
;;;3125     }
;;;3126     
;;;3127     htim->State = HAL_TIM_STATE_READY;
;;;3128       
;;;3129     __HAL_UNLOCK(htim);
;;;3130     
;;;3131     return HAL_OK; 
;;;3132   }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L33.24|
000018  2001              MOVS     r0,#1                 ;3060
00001a  63a0              STR      r0,[r4,#0x38]         ;3060
00001c  bf00              NOP                            ;3060
00001e  2002              MOVS     r0,#2                 ;3062
000020  63e0              STR      r0,[r4,#0x3c]         ;3062
000022  b996              CBNZ     r6,|L33.74|
000024  68eb              LDR      r3,[r5,#0xc]          ;3067
000026  e9d51200          LDRD     r1,r2,[r5,#0]         ;3067
00002a  6820              LDR      r0,[r4,#0]            ;3067
00002c  f7fffffe          BL       TIM_TI1_SetConfig
000030  6820              LDR      r0,[r4,#0]            ;3073
000032  6980              LDR      r0,[r0,#0x18]         ;3073
000034  f020000c          BIC      r0,r0,#0xc            ;3073
000038  6821              LDR      r1,[r4,#0]            ;3073
00003a  6188              STR      r0,[r1,#0x18]         ;3073
00003c  6820              LDR      r0,[r4,#0]            ;3076
00003e  6980              LDR      r0,[r0,#0x18]         ;3076
000040  68a9              LDR      r1,[r5,#8]            ;3076
000042  4308              ORRS     r0,r0,r1              ;3076
000044  6821              LDR      r1,[r4,#0]            ;3076
000046  6188              STR      r0,[r1,#0x18]         ;3076
000048  e03d              B        |L33.198|
                  |L33.74|
00004a  2e04              CMP      r6,#4                 ;3078
00004c  d113              BNE      |L33.118|
00004e  68eb              LDR      r3,[r5,#0xc]          ;3083
000050  e9d51200          LDRD     r1,r2,[r5,#0]         ;3083
000054  6820              LDR      r0,[r4,#0]            ;3083
000056  f7fffffe          BL       TIM_TI2_SetConfig
00005a  6820              LDR      r0,[r4,#0]            ;3089
00005c  6980              LDR      r0,[r0,#0x18]         ;3089
00005e  f4206040          BIC      r0,r0,#0xc00          ;3089
000062  6821              LDR      r1,[r4,#0]            ;3089
000064  6188              STR      r0,[r1,#0x18]         ;3089
000066  6820              LDR      r0,[r4,#0]            ;3092
000068  6980              LDR      r0,[r0,#0x18]         ;3092
00006a  68a9              LDR      r1,[r5,#8]            ;3092
00006c  ea402001          ORR      r0,r0,r1,LSL #8       ;3092
000070  6821              LDR      r1,[r4,#0]            ;3092
000072  6188              STR      r0,[r1,#0x18]         ;3092
000074  e027              B        |L33.198|
                  |L33.118|
000076  2e08              CMP      r6,#8                 ;3094
000078  d112              BNE      |L33.160|
00007a  68eb              LDR      r3,[r5,#0xc]          ;3099
00007c  e9d51200          LDRD     r1,r2,[r5,#0]         ;3099
000080  6820              LDR      r0,[r4,#0]            ;3099
000082  f7fffffe          BL       TIM_TI3_SetConfig
000086  6820              LDR      r0,[r4,#0]            ;3105
000088  69c0              LDR      r0,[r0,#0x1c]         ;3105
00008a  f020000c          BIC      r0,r0,#0xc            ;3105
00008e  6821              LDR      r1,[r4,#0]            ;3105
000090  61c8              STR      r0,[r1,#0x1c]         ;3105
000092  6820              LDR      r0,[r4,#0]            ;3108
000094  69c0              LDR      r0,[r0,#0x1c]         ;3108
000096  68a9              LDR      r1,[r5,#8]            ;3108
000098  4308              ORRS     r0,r0,r1              ;3108
00009a  6821              LDR      r1,[r4,#0]            ;3108
00009c  61c8              STR      r0,[r1,#0x1c]         ;3108
00009e  e012              B        |L33.198|
                  |L33.160|
0000a0  68eb              LDR      r3,[r5,#0xc]          ;3115
0000a2  e9d51200          LDRD     r1,r2,[r5,#0]         ;3115
0000a6  6820              LDR      r0,[r4,#0]            ;3115
0000a8  f7fffffe          BL       TIM_TI4_SetConfig
0000ac  6820              LDR      r0,[r4,#0]            ;3121
0000ae  69c0              LDR      r0,[r0,#0x1c]         ;3121
0000b0  f4206040          BIC      r0,r0,#0xc00          ;3121
0000b4  6821              LDR      r1,[r4,#0]            ;3121
0000b6  61c8              STR      r0,[r1,#0x1c]         ;3121
0000b8  6820              LDR      r0,[r4,#0]            ;3124
0000ba  69c0              LDR      r0,[r0,#0x1c]         ;3124
0000bc  68a9              LDR      r1,[r5,#8]            ;3124
0000be  ea402001          ORR      r0,r0,r1,LSL #8       ;3124
0000c2  6821              LDR      r1,[r4,#0]            ;3124
0000c4  61c8              STR      r0,[r1,#0x1c]         ;3124
                  |L33.198|
0000c6  2001              MOVS     r0,#1                 ;3127
0000c8  63e0              STR      r0,[r4,#0x3c]         ;3127
0000ca  bf00              NOP                            ;3129
0000cc  2000              MOVS     r0,#0                 ;3129
0000ce  63a0              STR      r0,[r4,#0x38]         ;3129
0000d0  bf00              NOP                            ;3129
0000d2  bf00              NOP                            ;3131
0000d4  e79e              B        |L33.20|
;;;3133   
                          ENDP


                          AREA ||i.HAL_TIM_IC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_DeInit PROC
;;;1555     */
;;;1556   HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1557   {
000002  4604              MOV      r4,r0
;;;1558     /* Check the parameters */
;;;1559     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1560   
;;;1561     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  63e0              STR      r0,[r4,#0x3c]
;;;1562     
;;;1563     /* Disable the TIM Peripheral Clock */
;;;1564     __HAL_TIM_DISABLE(htim);
000008  bf00              NOP      
00000a  6820              LDR      r0,[r4,#0]
00000c  6a00              LDR      r0,[r0,#0x20]
00000e  f2411111          MOV      r1,#0x1111
000012  4008              ANDS     r0,r0,r1
000014  b950              CBNZ     r0,|L34.44|
000016  6820              LDR      r0,[r4,#0]
000018  6a00              LDR      r0,[r0,#0x20]
00001a  1089              ASRS     r1,r1,#2
00001c  4008              ANDS     r0,r0,r1
00001e  b928              CBNZ     r0,|L34.44|
000020  6820              LDR      r0,[r4,#0]
000022  6800              LDR      r0,[r0,#0]
000024  f0200001          BIC      r0,r0,#1
000028  6821              LDR      r1,[r4,#0]
00002a  6008              STR      r0,[r1,#0]
                  |L34.44|
00002c  bf00              NOP      
;;;1565       
;;;1566     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;1567     HAL_TIM_IC_MspDeInit(htim);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       HAL_TIM_IC_MspDeInit
;;;1568       
;;;1569     /* Change TIM state */  
;;;1570     htim->State = HAL_TIM_STATE_RESET;
000034  2000              MOVS     r0,#0
000036  63e0              STR      r0,[r4,#0x3c]
;;;1571   
;;;1572     /* Release Lock */
;;;1573     __HAL_UNLOCK(htim);
000038  bf00              NOP      
00003a  63a0              STR      r0,[r4,#0x38]
00003c  bf00              NOP      
;;;1574   
;;;1575     return HAL_OK;
;;;1576   }
00003e  bd10              POP      {r4,pc}
;;;1577   
                          ENDP


                          AREA ||i.HAL_TIM_IC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_GetState PROC
;;;4569     */
;;;4570   HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;4571   {
;;;4572     return htim->State;
000002  6bc8              LDR      r0,[r1,#0x3c]
;;;4573   }
000004  4770              BX       lr
;;;4574   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Init PROC
;;;1516     */
;;;1517   HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1518   {
000002  4604              MOV      r4,r0
;;;1519     /* Check the TIM handle allocation */
;;;1520     if(htim == NULL)
000004  b90c              CBNZ     r4,|L36.10|
;;;1521     {
;;;1522       return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L36.8|
;;;1523     }
;;;1524   
;;;1525     /* Check the parameters */
;;;1526     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1527     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1528     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision)); 
;;;1529   
;;;1530     if(htim->State == HAL_TIM_STATE_RESET)
;;;1531     { 
;;;1532       /* Allocate lock resource and initialize it */
;;;1533       htim->Lock = HAL_UNLOCKED;   
;;;1534       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1535       HAL_TIM_IC_MspInit(htim);
;;;1536     }
;;;1537     
;;;1538     /* Set the TIM state */
;;;1539     htim->State= HAL_TIM_STATE_BUSY;   
;;;1540     
;;;1541     /* Init the base time for the input capture */  
;;;1542     TIM_Base_SetConfig(htim->Instance, &htim->Init); 
;;;1543      
;;;1544     /* Initialize the TIM state*/
;;;1545     htim->State= HAL_TIM_STATE_READY;
;;;1546     
;;;1547     return HAL_OK;
;;;1548   }
000008  bd10              POP      {r4,pc}
                  |L36.10|
00000a  6be0              LDR      r0,[r4,#0x3c]         ;1530
00000c  b920              CBNZ     r0,|L36.24|
00000e  2000              MOVS     r0,#0                 ;1533
000010  63a0              STR      r0,[r4,#0x38]         ;1533
000012  4620              MOV      r0,r4                 ;1535
000014  f7fffffe          BL       HAL_TIM_IC_MspInit
                  |L36.24|
000018  2002              MOVS     r0,#2                 ;1539
00001a  63e0              STR      r0,[r4,#0x3c]         ;1539
00001c  1d21              ADDS     r1,r4,#4              ;1542
00001e  6820              LDR      r0,[r4,#0]            ;1542
000020  f7fffffe          BL       TIM_Base_SetConfig
000024  2001              MOVS     r0,#1                 ;1545
000026  63e0              STR      r0,[r4,#0x3c]         ;1545
000028  2000              MOVS     r0,#0                 ;1547
00002a  e7ed              B        |L36.8|
;;;1549   
                          ENDP


                          AREA ||i.HAL_TIM_IC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_MspDeInit PROC
;;;1599     */
;;;1600   __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1601   {
;;;1602     /* Prevent unused argument(s) compilation warning */
;;;1603     UNUSED(htim);
;;;1604      
;;;1605     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1606               the HAL_TIM_IC_MspDeInit could be implemented in the user file
;;;1607      */
;;;1608   }
;;;1609   
                          ENDP


                          AREA ||i.HAL_TIM_IC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_MspInit PROC
;;;1583     */
;;;1584   __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1585   {
;;;1586     /* Prevent unused argument(s) compilation warning */
;;;1587     UNUSED(htim);
;;;1588    
;;;1589     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1590               the HAL_TIM_IC_MspInit could be implemented in the user file
;;;1591      */
;;;1592   }
;;;1593   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Start PROC
;;;1621     */
;;;1622   HAL_StatusTypeDef HAL_TIM_IC_Start (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1623   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1624     /* Check the parameters */
;;;1625     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1626     
;;;1627     /* Enable the Input Capture channel */
;;;1628     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000006  2201              MOVS     r2,#1
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;1629       
;;;1630     /* Enable the Peripheral */
;;;1631     __HAL_TIM_ENABLE(htim);  
000010  6820              LDR      r0,[r4,#0]
000012  6800              LDR      r0,[r0,#0]
000014  f0400001          ORR      r0,r0,#1
000018  6821              LDR      r1,[r4,#0]
00001a  6008              STR      r0,[r1,#0]
;;;1632   
;;;1633     /* Return function status */
;;;1634     return HAL_OK;  
00001c  2000              MOVS     r0,#0
;;;1635   } 
00001e  bd30              POP      {r4,r5,pc}
;;;1636   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_IC_Start_DMA PROC
;;;1798     */
;;;1799   HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1800   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1801     /* Check the parameters */
;;;1802     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1803     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;1804     
;;;1805     if((htim->State == HAL_TIM_STATE_BUSY))
00000c  6be0              LDR      r0,[r4,#0x3c]
00000e  2802              CMP      r0,#2
000010  d101              BNE      |L40.22|
                  |L40.18|
;;;1806     {
;;;1807        return HAL_BUSY;
;;;1808     }
;;;1809     else if((htim->State == HAL_TIM_STATE_READY))
;;;1810     {
;;;1811       if((pData == 0 ) && (Length > 0)) 
;;;1812       {
;;;1813         return HAL_ERROR;                                    
;;;1814       }
;;;1815       else
;;;1816       {
;;;1817         htim->State = HAL_TIM_STATE_BUSY;
;;;1818       }
;;;1819     }  
;;;1820      
;;;1821     switch (Channel)
;;;1822     {
;;;1823       case TIM_CHANNEL_1:
;;;1824       {
;;;1825         /* Set the DMA Period elapsed callback */
;;;1826         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;1827        
;;;1828         /* Set the DMA error callback */
;;;1829         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1830         
;;;1831         /* Enable the DMA Stream */
;;;1832         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length); 
;;;1833         
;;;1834         /* Enable the TIM Capture/Compare 1 DMA request */      
;;;1835         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1836       }
;;;1837       break;
;;;1838       
;;;1839       case TIM_CHANNEL_2:
;;;1840       {
;;;1841         /* Set the DMA Period elapsed callback */
;;;1842         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;1843        
;;;1844         /* Set the DMA error callback */
;;;1845         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1846         
;;;1847         /* Enable the DMA Stream */
;;;1848         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length);
;;;1849         
;;;1850         /* Enable the TIM Capture/Compare 2  DMA request */
;;;1851         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1852       }
;;;1853       break;
;;;1854       
;;;1855       case TIM_CHANNEL_3:
;;;1856       {
;;;1857         /* Set the DMA Period elapsed callback */
;;;1858         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;1859        
;;;1860         /* Set the DMA error callback */
;;;1861         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1862         
;;;1863         /* Enable the DMA Stream */
;;;1864         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length);
;;;1865         
;;;1866         /* Enable the TIM Capture/Compare 3  DMA request */
;;;1867         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1868       }
;;;1869       break;
;;;1870       
;;;1871       case TIM_CHANNEL_4:
;;;1872       {
;;;1873         /* Set the DMA Period elapsed callback */
;;;1874         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;1875        
;;;1876         /* Set the DMA error callback */
;;;1877         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1878         
;;;1879         /* Enable the DMA Stream */
;;;1880         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length);
;;;1881         
;;;1882         /* Enable the TIM Capture/Compare 4  DMA request */
;;;1883         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1884       }
;;;1885       break;
;;;1886       
;;;1887       default:
;;;1888       break;
;;;1889     }
;;;1890   
;;;1891     /* Enable the Input Capture channel */
;;;1892     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1893      
;;;1894     /* Enable the Peripheral */
;;;1895     __HAL_TIM_ENABLE(htim); 
;;;1896     
;;;1897     /* Return function status */
;;;1898     return HAL_OK;
;;;1899   }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L40.22|
000016  6be0              LDR      r0,[r4,#0x3c]         ;1809
000018  2801              CMP      r0,#1                 ;1809
00001a  d105              BNE      |L40.40|
00001c  b916              CBNZ     r6,|L40.36|
00001e  2f00              CMP      r7,#0                 ;1811
000020  dd00              BLE      |L40.36|
000022  e7f6              B        |L40.18|
                  |L40.36|
000024  2002              MOVS     r0,#2                 ;1817
000026  63e0              STR      r0,[r4,#0x3c]         ;1817
                  |L40.40|
000028  b135              CBZ      r5,|L40.56|
00002a  2d04              CMP      r5,#4                 ;1821
00002c  d019              BEQ      |L40.98|
00002e  2d08              CMP      r5,#8                 ;1821
000030  d02c              BEQ      |L40.140|
000032  2d0c              CMP      r5,#0xc               ;1821
000034  d154              BNE      |L40.224|
000036  e03e              B        |L40.182|
                  |L40.56|
000038  4931              LDR      r1,|L40.256|
00003a  6a20              LDR      r0,[r4,#0x20]         ;1826
00003c  6401              STR      r1,[r0,#0x40]         ;1826
00003e  4931              LDR      r1,|L40.260|
000040  6a20              LDR      r0,[r4,#0x20]         ;1829
000042  6501              STR      r1,[r0,#0x50]         ;1829
000044  6822              LDR      r2,[r4,#0]            ;1832
000046  f1020134          ADD      r1,r2,#0x34           ;1832
00004a  463b              MOV      r3,r7                 ;1832
00004c  4632              MOV      r2,r6                 ;1832
00004e  6a20              LDR      r0,[r4,#0x20]         ;1832
000050  f7fffffe          BL       HAL_DMA_Start_IT
000054  6820              LDR      r0,[r4,#0]            ;1835
000056  68c0              LDR      r0,[r0,#0xc]          ;1835
000058  f4407000          ORR      r0,r0,#0x200          ;1835
00005c  6821              LDR      r1,[r4,#0]            ;1835
00005e  60c8              STR      r0,[r1,#0xc]          ;1835
000060  e03f              B        |L40.226|
                  |L40.98|
000062  4927              LDR      r1,|L40.256|
000064  6a60              LDR      r0,[r4,#0x24]         ;1842
000066  6401              STR      r1,[r0,#0x40]         ;1842
000068  4926              LDR      r1,|L40.260|
00006a  6a60              LDR      r0,[r4,#0x24]         ;1845
00006c  6501              STR      r1,[r0,#0x50]         ;1845
00006e  6822              LDR      r2,[r4,#0]            ;1848
000070  f1020138          ADD      r1,r2,#0x38           ;1848
000074  463b              MOV      r3,r7                 ;1848
000076  4632              MOV      r2,r6                 ;1848
000078  6a60              LDR      r0,[r4,#0x24]         ;1848
00007a  f7fffffe          BL       HAL_DMA_Start_IT
00007e  6820              LDR      r0,[r4,#0]            ;1851
000080  68c0              LDR      r0,[r0,#0xc]          ;1851
000082  f4406080          ORR      r0,r0,#0x400          ;1851
000086  6821              LDR      r1,[r4,#0]            ;1851
000088  60c8              STR      r0,[r1,#0xc]          ;1851
00008a  e02a              B        |L40.226|
                  |L40.140|
00008c  491c              LDR      r1,|L40.256|
00008e  6aa0              LDR      r0,[r4,#0x28]         ;1858
000090  6401              STR      r1,[r0,#0x40]         ;1858
000092  491c              LDR      r1,|L40.260|
000094  6aa0              LDR      r0,[r4,#0x28]         ;1861
000096  6501              STR      r1,[r0,#0x50]         ;1861
000098  6822              LDR      r2,[r4,#0]            ;1864
00009a  f102013c          ADD      r1,r2,#0x3c           ;1864
00009e  463b              MOV      r3,r7                 ;1864
0000a0  4632              MOV      r2,r6                 ;1864
0000a2  6aa0              LDR      r0,[r4,#0x28]         ;1864
0000a4  f7fffffe          BL       HAL_DMA_Start_IT
0000a8  6820              LDR      r0,[r4,#0]            ;1867
0000aa  68c0              LDR      r0,[r0,#0xc]          ;1867
0000ac  f4406000          ORR      r0,r0,#0x800          ;1867
0000b0  6821              LDR      r1,[r4,#0]            ;1867
0000b2  60c8              STR      r0,[r1,#0xc]          ;1867
0000b4  e015              B        |L40.226|
                  |L40.182|
0000b6  4912              LDR      r1,|L40.256|
0000b8  6ae0              LDR      r0,[r4,#0x2c]         ;1874
0000ba  6401              STR      r1,[r0,#0x40]         ;1874
0000bc  4911              LDR      r1,|L40.260|
0000be  6ae0              LDR      r0,[r4,#0x2c]         ;1877
0000c0  6501              STR      r1,[r0,#0x50]         ;1877
0000c2  6822              LDR      r2,[r4,#0]            ;1880
0000c4  f1020140          ADD      r1,r2,#0x40           ;1880
0000c8  463b              MOV      r3,r7                 ;1880
0000ca  4632              MOV      r2,r6                 ;1880
0000cc  6ae0              LDR      r0,[r4,#0x2c]         ;1880
0000ce  f7fffffe          BL       HAL_DMA_Start_IT
0000d2  6820              LDR      r0,[r4,#0]            ;1883
0000d4  68c0              LDR      r0,[r0,#0xc]          ;1883
0000d6  f4405080          ORR      r0,r0,#0x1000         ;1883
0000da  6821              LDR      r1,[r4,#0]            ;1883
0000dc  60c8              STR      r0,[r1,#0xc]          ;1883
0000de  e000              B        |L40.226|
                  |L40.224|
0000e0  bf00              NOP                            ;1888
                  |L40.226|
0000e2  bf00              NOP                            ;1837
0000e4  2201              MOVS     r2,#1                 ;1892
0000e6  4629              MOV      r1,r5                 ;1892
0000e8  6820              LDR      r0,[r4,#0]            ;1892
0000ea  f7fffffe          BL       TIM_CCxChannelCmd
0000ee  6820              LDR      r0,[r4,#0]            ;1895
0000f0  6800              LDR      r0,[r0,#0]            ;1895
0000f2  f0400001          ORR      r0,r0,#1              ;1895
0000f6  6821              LDR      r1,[r4,#0]            ;1895
0000f8  6008              STR      r0,[r1,#0]            ;1895
0000fa  2000              MOVS     r0,#0                 ;1898
0000fc  e789              B        |L40.18|
;;;1900   
                          ENDP

0000fe  0000              DCW      0x0000
                  |L40.256|
                          DCD      TIM_DMACaptureCplt
                  |L40.260|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_IC_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Start_IT PROC
;;;1675     */
;;;1676   HAL_StatusTypeDef HAL_TIM_IC_Start_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1677   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1678     /* Check the parameters */
;;;1679     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1680     
;;;1681     switch (Channel)
000006  b135              CBZ      r5,|L41.22|
000008  2d04              CMP      r5,#4
00000a  d00b              BEQ      |L41.36|
00000c  2d08              CMP      r5,#8
00000e  d010              BEQ      |L41.50|
000010  2d0c              CMP      r5,#0xc
000012  d11c              BNE      |L41.78|
000014  e014              B        |L41.64|
                  |L41.22|
;;;1682     {
;;;1683       case TIM_CHANNEL_1:
;;;1684       {       
;;;1685         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1686         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f0400002          ORR      r0,r0,#2
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;1687       }
;;;1688       break;
000022  e015              B        |L41.80|
                  |L41.36|
;;;1689       
;;;1690       case TIM_CHANNEL_2:
;;;1691       {
;;;1692         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1693         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f0400004          ORR      r0,r0,#4
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;1694       }
;;;1695       break;
000030  e00e              B        |L41.80|
                  |L41.50|
;;;1696       
;;;1697       case TIM_CHANNEL_3:
;;;1698       {
;;;1699         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1700         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  f0400008          ORR      r0,r0,#8
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;1701       }
;;;1702       break;
00003e  e007              B        |L41.80|
                  |L41.64|
;;;1703       
;;;1704       case TIM_CHANNEL_4:
;;;1705       {
;;;1706         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1707         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f0400010          ORR      r0,r0,#0x10
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;1708       }
;;;1709       break;
00004c  e000              B        |L41.80|
                  |L41.78|
;;;1710       
;;;1711       default:
;;;1712       break;
00004e  bf00              NOP      
                  |L41.80|
000050  bf00              NOP                            ;1688
;;;1713     }  
;;;1714     /* Enable the Input Capture channel */
;;;1715     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000052  2201              MOVS     r2,#1
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;1716       
;;;1717     /* Enable the Peripheral */
;;;1718     __HAL_TIM_ENABLE(htim);  
00005c  6820              LDR      r0,[r4,#0]
00005e  6800              LDR      r0,[r0,#0]
000060  f0400001          ORR      r0,r0,#1
000064  6821              LDR      r1,[r4,#0]
000066  6008              STR      r0,[r1,#0]
;;;1719   
;;;1720     /* Return function status */
;;;1721     return HAL_OK;  
000068  2000              MOVS     r0,#0
;;;1722   } 
00006a  bd30              POP      {r4,r5,pc}
;;;1723   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop PROC
;;;1648     */
;;;1649   HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1650   { 
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1651     /* Check the parameters */
;;;1652     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1653     
;;;1654     /* Disable the Input Capture channel */
;;;1655     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000006  2200              MOVS     r2,#0
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;1656     
;;;1657     /* Disable the Peripheral */
;;;1658     __HAL_TIM_DISABLE(htim); 
000010  bf00              NOP      
000012  6820              LDR      r0,[r4,#0]
000014  6a00              LDR      r0,[r0,#0x20]
000016  f2411111          MOV      r1,#0x1111
00001a  4008              ANDS     r0,r0,r1
00001c  b950              CBNZ     r0,|L42.52|
00001e  6820              LDR      r0,[r4,#0]
000020  6a00              LDR      r0,[r0,#0x20]
000022  1089              ASRS     r1,r1,#2
000024  4008              ANDS     r0,r0,r1
000026  b928              CBNZ     r0,|L42.52|
000028  6820              LDR      r0,[r4,#0]
00002a  6800              LDR      r0,[r0,#0]
00002c  f0200001          BIC      r0,r0,#1
000030  6821              LDR      r1,[r4,#0]
000032  6008              STR      r0,[r1,#0]
                  |L42.52|
000034  bf00              NOP      
;;;1659     
;;;1660     /* Return function status */
;;;1661     return HAL_OK;
000036  2000              MOVS     r0,#0
;;;1662   }
000038  bd30              POP      {r4,r5,pc}
;;;1663   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop_DMA PROC
;;;1912     */
;;;1913   HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1914   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1915     /* Check the parameters */
;;;1916     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1917     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;1918     
;;;1919     switch (Channel)
000006  b135              CBZ      r5,|L43.22|
000008  2d04              CMP      r5,#4
00000a  d00b              BEQ      |L43.36|
00000c  2d08              CMP      r5,#8
00000e  d010              BEQ      |L43.50|
000010  2d0c              CMP      r5,#0xc
000012  d11c              BNE      |L43.78|
000014  e014              B        |L43.64|
                  |L43.22|
;;;1920     {
;;;1921       case TIM_CHANNEL_1:
;;;1922       {       
;;;1923         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1924         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f4207000          BIC      r0,r0,#0x200
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;1925       }
;;;1926       break;
000022  e015              B        |L43.80|
                  |L43.36|
;;;1927       
;;;1928       case TIM_CHANNEL_2:
;;;1929       {
;;;1930         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1931         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f4206080          BIC      r0,r0,#0x400
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;1932       }
;;;1933       break;
000030  e00e              B        |L43.80|
                  |L43.50|
;;;1934       
;;;1935       case TIM_CHANNEL_3:
;;;1936       {
;;;1937         /* Disable the TIM Capture/Compare 3  DMA request */
;;;1938         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  f4206000          BIC      r0,r0,#0x800
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;1939       }
;;;1940       break;
00003e  e007              B        |L43.80|
                  |L43.64|
;;;1941       
;;;1942       case TIM_CHANNEL_4:
;;;1943       {
;;;1944         /* Disable the TIM Capture/Compare 4  DMA request */
;;;1945         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f4205080          BIC      r0,r0,#0x1000
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;1946       }
;;;1947       break;
00004c  e000              B        |L43.80|
                  |L43.78|
;;;1948       
;;;1949       default:
;;;1950       break;
00004e  bf00              NOP      
                  |L43.80|
000050  bf00              NOP                            ;1926
;;;1951     }
;;;1952   
;;;1953     /* Disable the Input Capture channel */
;;;1954     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000052  2200              MOVS     r2,#0
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;1955     
;;;1956     /* Disable the Peripheral */
;;;1957     __HAL_TIM_DISABLE(htim); 
00005c  bf00              NOP      
00005e  6820              LDR      r0,[r4,#0]
000060  6a00              LDR      r0,[r0,#0x20]
000062  f2411111          MOV      r1,#0x1111
000066  4008              ANDS     r0,r0,r1
000068  b950              CBNZ     r0,|L43.128|
00006a  6820              LDR      r0,[r4,#0]
00006c  6a00              LDR      r0,[r0,#0x20]
00006e  1089              ASRS     r1,r1,#2
000070  4008              ANDS     r0,r0,r1
000072  b928              CBNZ     r0,|L43.128|
000074  6820              LDR      r0,[r4,#0]
000076  6800              LDR      r0,[r0,#0]
000078  f0200001          BIC      r0,r0,#1
00007c  6821              LDR      r1,[r4,#0]
00007e  6008              STR      r0,[r1,#0]
                  |L43.128|
000080  bf00              NOP      
;;;1958     
;;;1959     /* Change the htim state */
;;;1960     htim->State = HAL_TIM_STATE_READY;
000082  2001              MOVS     r0,#1
000084  63e0              STR      r0,[r4,#0x3c]
;;;1961     
;;;1962     /* Return function status */
;;;1963     return HAL_OK;
000086  2000              MOVS     r0,#0
;;;1964   }  
000088  bd30              POP      {r4,r5,pc}
;;;1965   /**
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop_IT PROC
;;;1735     */
;;;1736   HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1737   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1738     /* Check the parameters */
;;;1739     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1740     
;;;1741     switch (Channel)
000006  b135              CBZ      r5,|L44.22|
000008  2d04              CMP      r5,#4
00000a  d00b              BEQ      |L44.36|
00000c  2d08              CMP      r5,#8
00000e  d010              BEQ      |L44.50|
000010  2d0c              CMP      r5,#0xc
000012  d11c              BNE      |L44.78|
000014  e014              B        |L44.64|
                  |L44.22|
;;;1742     {
;;;1743       case TIM_CHANNEL_1:
;;;1744       {       
;;;1745         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1746         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f0200002          BIC      r0,r0,#2
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;1747       }
;;;1748       break;
000022  e015              B        |L44.80|
                  |L44.36|
;;;1749       
;;;1750       case TIM_CHANNEL_2:
;;;1751       {
;;;1752         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1753         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f0200004          BIC      r0,r0,#4
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;1754       }
;;;1755       break;
000030  e00e              B        |L44.80|
                  |L44.50|
;;;1756       
;;;1757       case TIM_CHANNEL_3:
;;;1758       {
;;;1759         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1760         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  f0200008          BIC      r0,r0,#8
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;1761       }
;;;1762       break;
00003e  e007              B        |L44.80|
                  |L44.64|
;;;1763       
;;;1764       case TIM_CHANNEL_4:
;;;1765       {
;;;1766         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1767         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f0200010          BIC      r0,r0,#0x10
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;1768       }
;;;1769       break;
00004c  e000              B        |L44.80|
                  |L44.78|
;;;1770       
;;;1771       default:
;;;1772       break; 
00004e  bf00              NOP      
                  |L44.80|
000050  bf00              NOP                            ;1748
;;;1773     } 
;;;1774     
;;;1775     /* Disable the Input Capture channel */
;;;1776     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE); 
000052  2200              MOVS     r2,#0
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;1777     
;;;1778     /* Disable the Peripheral */
;;;1779     __HAL_TIM_DISABLE(htim); 
00005c  bf00              NOP      
00005e  6820              LDR      r0,[r4,#0]
000060  6a00              LDR      r0,[r0,#0x20]
000062  f2411111          MOV      r1,#0x1111
000066  4008              ANDS     r0,r0,r1
000068  b950              CBNZ     r0,|L44.128|
00006a  6820              LDR      r0,[r4,#0]
00006c  6a00              LDR      r0,[r0,#0x20]
00006e  1089              ASRS     r1,r1,#2
000070  4008              ANDS     r0,r0,r1
000072  b928              CBNZ     r0,|L44.128|
000074  6820              LDR      r0,[r4,#0]
000076  6800              LDR      r0,[r0,#0]
000078  f0200001          BIC      r0,r0,#1
00007c  6821              LDR      r1,[r4,#0]
00007e  6008              STR      r0,[r1,#0]
                  |L44.128|
000080  bf00              NOP      
;;;1780     
;;;1781     /* Return function status */
;;;1782     return HAL_OK;
000082  2000              MOVS     r0,#0
;;;1783   }
000084  bd30              POP      {r4,r5,pc}
;;;1784   
                          ENDP


                          AREA ||i.HAL_TIM_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IRQHandler PROC
;;;2805     */
;;;2806   void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;2807   {
000002  4604              MOV      r4,r0
;;;2808     /* Capture compare 1 event */
;;;2809     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
000004  6820              LDR      r0,[r4,#0]
000006  6900              LDR      r0,[r0,#0x10]
000008  f3c00040          UBFX     r0,r0,#1,#1
00000c  b1d8              CBZ      r0,|L45.70|
;;;2810     {
;;;2811       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
00000e  6820              LDR      r0,[r4,#0]
000010  68c0              LDR      r0,[r0,#0xc]
000012  f3c00040          UBFX     r0,r0,#1,#1
000016  b1b0              CBZ      r0,|L45.70|
;;;2812       {
;;;2813         {
;;;2814           __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
000018  f06f0002          MVN      r0,#2
00001c  6821              LDR      r1,[r4,#0]
00001e  6108              STR      r0,[r1,#0x10]
;;;2815           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000020  2001              MOVS     r0,#1
000022  61a0              STR      r0,[r4,#0x18]
;;;2816           
;;;2817           /* Input capture event */
;;;2818           if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00)
000024  6820              LDR      r0,[r4,#0]
000026  6980              LDR      r0,[r0,#0x18]
000028  f0000003          AND      r0,r0,#3
00002c  b118              CBZ      r0,|L45.54|
;;;2819           {
;;;2820             HAL_TIM_IC_CaptureCallback(htim);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
000034  e005              B        |L45.66|
                  |L45.54|
;;;2821           }
;;;2822           /* Output compare event */
;;;2823           else
;;;2824           {
;;;2825             HAL_TIM_OC_DelayElapsedCallback(htim);
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2826             HAL_TIM_PWM_PulseFinishedCallback(htim);
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.66|
;;;2827           }
;;;2828           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000042  2000              MOVS     r0,#0
000044  61a0              STR      r0,[r4,#0x18]
                  |L45.70|
;;;2829         }
;;;2830       }
;;;2831     }
;;;2832     /* Capture compare 2 event */
;;;2833     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
000046  6820              LDR      r0,[r4,#0]
000048  6900              LDR      r0,[r0,#0x10]
00004a  f3c00080          UBFX     r0,r0,#2,#1
00004e  b1d8              CBZ      r0,|L45.136|
;;;2834     {
;;;2835       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
000050  6820              LDR      r0,[r4,#0]
000052  68c0              LDR      r0,[r0,#0xc]
000054  f3c00080          UBFX     r0,r0,#2,#1
000058  b1b0              CBZ      r0,|L45.136|
;;;2836       {
;;;2837         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
00005a  f06f0004          MVN      r0,#4
00005e  6821              LDR      r1,[r4,#0]
000060  6108              STR      r0,[r1,#0x10]
;;;2838         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
000062  2002              MOVS     r0,#2
000064  61a0              STR      r0,[r4,#0x18]
;;;2839         /* Input capture event */
;;;2840         if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
000066  6820              LDR      r0,[r4,#0]
000068  6980              LDR      r0,[r0,#0x18]
00006a  f4007040          AND      r0,r0,#0x300
00006e  b118              CBZ      r0,|L45.120|
;;;2841         {          
;;;2842           HAL_TIM_IC_CaptureCallback(htim);
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
000076  e005              B        |L45.132|
                  |L45.120|
;;;2843         }
;;;2844         /* Output compare event */
;;;2845         else
;;;2846         {
;;;2847           HAL_TIM_OC_DelayElapsedCallback(htim);
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2848           HAL_TIM_PWM_PulseFinishedCallback(htim);
00007e  4620              MOV      r0,r4
000080  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.132|
;;;2849         }
;;;2850         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000084  2000              MOVS     r0,#0
000086  61a0              STR      r0,[r4,#0x18]
                  |L45.136|
;;;2851       }
;;;2852     }
;;;2853     /* Capture compare 3 event */
;;;2854     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
000088  6820              LDR      r0,[r4,#0]
00008a  6900              LDR      r0,[r0,#0x10]
00008c  f3c000c0          UBFX     r0,r0,#3,#1
000090  b1d8              CBZ      r0,|L45.202|
;;;2855     {
;;;2856       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
000092  6820              LDR      r0,[r4,#0]
000094  68c0              LDR      r0,[r0,#0xc]
000096  f3c000c0          UBFX     r0,r0,#3,#1
00009a  b1b0              CBZ      r0,|L45.202|
;;;2857       {
;;;2858         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
00009c  f06f0008          MVN      r0,#8
0000a0  6821              LDR      r1,[r4,#0]
0000a2  6108              STR      r0,[r1,#0x10]
;;;2859         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
0000a4  2004              MOVS     r0,#4
0000a6  61a0              STR      r0,[r4,#0x18]
;;;2860         /* Input capture event */
;;;2861         if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
0000a8  6820              LDR      r0,[r4,#0]
0000aa  69c0              LDR      r0,[r0,#0x1c]
0000ac  f0000003          AND      r0,r0,#3
0000b0  b118              CBZ      r0,|L45.186|
;;;2862         {          
;;;2863           HAL_TIM_IC_CaptureCallback(htim);
0000b2  4620              MOV      r0,r4
0000b4  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
0000b8  e005              B        |L45.198|
                  |L45.186|
;;;2864         }
;;;2865         /* Output compare event */
;;;2866         else
;;;2867         {
;;;2868           HAL_TIM_OC_DelayElapsedCallback(htim);
0000ba  4620              MOV      r0,r4
0000bc  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2869           HAL_TIM_PWM_PulseFinishedCallback(htim); 
0000c0  4620              MOV      r0,r4
0000c2  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.198|
;;;2870         }
;;;2871         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
0000c6  2000              MOVS     r0,#0
0000c8  61a0              STR      r0,[r4,#0x18]
                  |L45.202|
;;;2872       }
;;;2873     }
;;;2874     /* Capture compare 4 event */
;;;2875     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
0000ca  6820              LDR      r0,[r4,#0]
0000cc  6900              LDR      r0,[r0,#0x10]
0000ce  f3c01000          UBFX     r0,r0,#4,#1
0000d2  b1d8              CBZ      r0,|L45.268|
;;;2876     {
;;;2877       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
0000d4  6820              LDR      r0,[r4,#0]
0000d6  68c0              LDR      r0,[r0,#0xc]
0000d8  f3c01000          UBFX     r0,r0,#4,#1
0000dc  b1b0              CBZ      r0,|L45.268|
;;;2878       {
;;;2879         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
0000de  f06f0010          MVN      r0,#0x10
0000e2  6821              LDR      r1,[r4,#0]
0000e4  6108              STR      r0,[r1,#0x10]
;;;2880         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
0000e6  2008              MOVS     r0,#8
0000e8  61a0              STR      r0,[r4,#0x18]
;;;2881         /* Input capture event */
;;;2882         if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
0000ea  6820              LDR      r0,[r4,#0]
0000ec  69c0              LDR      r0,[r0,#0x1c]
0000ee  f4007040          AND      r0,r0,#0x300
0000f2  b118              CBZ      r0,|L45.252|
;;;2883         {          
;;;2884           HAL_TIM_IC_CaptureCallback(htim);
0000f4  4620              MOV      r0,r4
0000f6  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
0000fa  e005              B        |L45.264|
                  |L45.252|
;;;2885         }
;;;2886         /* Output compare event */
;;;2887         else
;;;2888         {
;;;2889           HAL_TIM_OC_DelayElapsedCallback(htim);
0000fc  4620              MOV      r0,r4
0000fe  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2890           HAL_TIM_PWM_PulseFinishedCallback(htim);
000102  4620              MOV      r0,r4
000104  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.264|
;;;2891         }
;;;2892         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000108  2000              MOVS     r0,#0
00010a  61a0              STR      r0,[r4,#0x18]
                  |L45.268|
;;;2893       }
;;;2894     }
;;;2895     /* TIM Update event */
;;;2896     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
00010c  6820              LDR      r0,[r4,#0]
00010e  6900              LDR      r0,[r0,#0x10]
000110  f0000001          AND      r0,r0,#1
000114  b158              CBZ      r0,|L45.302|
;;;2897     {
;;;2898       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
000116  6820              LDR      r0,[r4,#0]
000118  68c0              LDR      r0,[r0,#0xc]
00011a  f0000001          AND      r0,r0,#1
00011e  b130              CBZ      r0,|L45.302|
;;;2899       {
;;;2900         __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
000120  f06f0001          MVN      r0,#1
000124  6821              LDR      r1,[r4,#0]
000126  6108              STR      r0,[r1,#0x10]
;;;2901         HAL_TIM_PeriodElapsedCallback(htim);
000128  4620              MOV      r0,r4
00012a  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
                  |L45.302|
;;;2902       }
;;;2903     }
;;;2904     /* TIM Break input event */
;;;2905     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
00012e  6820              LDR      r0,[r4,#0]
000130  6900              LDR      r0,[r0,#0x10]
000132  f3c010c0          UBFX     r0,r0,#7,#1
000136  b158              CBZ      r0,|L45.336|
;;;2906     {
;;;2907       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
000138  6820              LDR      r0,[r4,#0]
00013a  68c0              LDR      r0,[r0,#0xc]
00013c  f3c010c0          UBFX     r0,r0,#7,#1
000140  b130              CBZ      r0,|L45.336|
;;;2908       {
;;;2909         __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
000142  f06f0080          MVN      r0,#0x80
000146  6821              LDR      r1,[r4,#0]
000148  6108              STR      r0,[r1,#0x10]
;;;2910         HAL_TIMEx_BreakCallback(htim);
00014a  4620              MOV      r0,r4
00014c  f7fffffe          BL       HAL_TIMEx_BreakCallback
                  |L45.336|
;;;2911       }
;;;2912     }
;;;2913     
;;;2914       /* TIM Break input event */
;;;2915     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
000150  6820              LDR      r0,[r4,#0]
000152  6900              LDR      r0,[r0,#0x10]
000154  f3c02000          UBFX     r0,r0,#8,#1
000158  b158              CBZ      r0,|L45.370|
;;;2916     {
;;;2917       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
00015a  6820              LDR      r0,[r4,#0]
00015c  68c0              LDR      r0,[r0,#0xc]
00015e  f3c010c0          UBFX     r0,r0,#7,#1
000162  b130              CBZ      r0,|L45.370|
;;;2918       {
;;;2919         __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
000164  f06f0080          MVN      r0,#0x80
000168  6821              LDR      r1,[r4,#0]
00016a  6108              STR      r0,[r1,#0x10]
;;;2920         HAL_TIMEx_BreakCallback(htim);
00016c  4620              MOV      r0,r4
00016e  f7fffffe          BL       HAL_TIMEx_BreakCallback
                  |L45.370|
;;;2921       }
;;;2922     }
;;;2923   
;;;2924     /* TIM Trigger detection event */
;;;2925     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
000172  6820              LDR      r0,[r4,#0]
000174  6900              LDR      r0,[r0,#0x10]
000176  f3c01080          UBFX     r0,r0,#6,#1
00017a  b158              CBZ      r0,|L45.404|
;;;2926     {
;;;2927       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
00017c  6820              LDR      r0,[r4,#0]
00017e  68c0              LDR      r0,[r0,#0xc]
000180  f3c01080          UBFX     r0,r0,#6,#1
000184  b130              CBZ      r0,|L45.404|
;;;2928       {
;;;2929         __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
000186  f06f0040          MVN      r0,#0x40
00018a  6821              LDR      r1,[r4,#0]
00018c  6108              STR      r0,[r1,#0x10]
;;;2930         HAL_TIM_TriggerCallback(htim);
00018e  4620              MOV      r0,r4
000190  f7fffffe          BL       HAL_TIM_TriggerCallback
                  |L45.404|
;;;2931       }
;;;2932     }
;;;2933     /* TIM commutation event */
;;;2934     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
000194  6820              LDR      r0,[r4,#0]
000196  6900              LDR      r0,[r0,#0x10]
000198  f3c01040          UBFX     r0,r0,#5,#1
00019c  b158              CBZ      r0,|L45.438|
;;;2935     {
;;;2936       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
00019e  6820              LDR      r0,[r4,#0]
0001a0  68c0              LDR      r0,[r0,#0xc]
0001a2  f3c01040          UBFX     r0,r0,#5,#1
0001a6  b130              CBZ      r0,|L45.438|
;;;2937       {
;;;2938         __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
0001a8  f06f0020          MVN      r0,#0x20
0001ac  6821              LDR      r1,[r4,#0]
0001ae  6108              STR      r0,[r1,#0x10]
;;;2939         HAL_TIMEx_CommutationCallback(htim);
0001b0  4620              MOV      r0,r4
0001b2  f7fffffe          BL       HAL_TIMEx_CommutationCallback
                  |L45.438|
;;;2940       }
;;;2941     }
;;;2942   }
0001b6  bd10              POP      {r4,pc}
;;;2943   
                          ENDP


                          AREA ||i.HAL_TIM_OC_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_ConfigChannel PROC
;;;2980     */
;;;2981   __weak HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;2982   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;2983     /* Check the parameters */ 
;;;2984     assert_param(IS_TIM_CHANNELS(Channel)); 
;;;2985     assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
;;;2986     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;2987     
;;;2988     /* Check input state */
;;;2989     __HAL_LOCK(htim); 
000008  bf00              NOP      
00000a  6ba0              LDR      r0,[r4,#0x38]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L46.20|
000010  2002              MOVS     r0,#2
                  |L46.18|
;;;2990     
;;;2991     htim->State = HAL_TIM_STATE_BUSY;
;;;2992     
;;;2993     switch (Channel)
;;;2994     {
;;;2995       case TIM_CHANNEL_1:
;;;2996       {
;;;2997         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;2998         /* Configure the TIM Channel 1 in Output Compare */
;;;2999         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;3000       }
;;;3001       break;
;;;3002       
;;;3003       case TIM_CHANNEL_2:
;;;3004       {
;;;3005         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3006         /* Configure the TIM Channel 2 in Output Compare */
;;;3007         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;3008       }
;;;3009       break;
;;;3010       
;;;3011       case TIM_CHANNEL_3:
;;;3012       {
;;;3013          assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3014         /* Configure the TIM Channel 3 in Output Compare */
;;;3015         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;3016       }
;;;3017       break;
;;;3018       
;;;3019       case TIM_CHANNEL_4:
;;;3020       {
;;;3021         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3022         /* Configure the TIM Channel 4 in Output Compare */
;;;3023         TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;3024       }
;;;3025       break;
;;;3026       
;;;3027       default:
;;;3028       break;    
;;;3029     }
;;;3030     htim->State = HAL_TIM_STATE_READY;
;;;3031     
;;;3032     __HAL_UNLOCK(htim); 
;;;3033     
;;;3034     return HAL_OK;
;;;3035   }
000012  bd70              POP      {r4-r6,pc}
                  |L46.20|
000014  2001              MOVS     r0,#1                 ;2989
000016  63a0              STR      r0,[r4,#0x38]         ;2989
000018  bf00              NOP                            ;2989
00001a  2002              MOVS     r0,#2                 ;2991
00001c  63e0              STR      r0,[r4,#0x3c]         ;2991
00001e  b135              CBZ      r5,|L46.46|
000020  2d04              CMP      r5,#4                 ;2993
000022  d009              BEQ      |L46.56|
000024  2d08              CMP      r5,#8                 ;2993
000026  d00c              BEQ      |L46.66|
000028  2d0c              CMP      r5,#0xc               ;2993
00002a  d114              BNE      |L46.86|
00002c  e00e              B        |L46.76|
                  |L46.46|
00002e  4631              MOV      r1,r6                 ;2999
000030  6820              LDR      r0,[r4,#0]            ;2999
000032  f7fffffe          BL       TIM_OC1_SetConfig
000036  e00f              B        |L46.88|
                  |L46.56|
000038  4631              MOV      r1,r6                 ;3007
00003a  6820              LDR      r0,[r4,#0]            ;3007
00003c  f7fffffe          BL       TIM_OC2_SetConfig
000040  e00a              B        |L46.88|
                  |L46.66|
000042  4631              MOV      r1,r6                 ;3015
000044  6820              LDR      r0,[r4,#0]            ;3015
000046  f7fffffe          BL       TIM_OC3_SetConfig
00004a  e005              B        |L46.88|
                  |L46.76|
00004c  4631              MOV      r1,r6                 ;3023
00004e  6820              LDR      r0,[r4,#0]            ;3023
000050  f7fffffe          BL       TIM_OC4_SetConfig
000054  e000              B        |L46.88|
                  |L46.86|
000056  bf00              NOP                            ;3028
                  |L46.88|
000058  bf00              NOP                            ;3001
00005a  2001              MOVS     r0,#1                 ;3030
00005c  63e0              STR      r0,[r4,#0x3c]         ;3030
00005e  bf00              NOP                            ;3032
000060  2000              MOVS     r0,#0                 ;3032
000062  63a0              STR      r0,[r4,#0x38]         ;3032
000064  bf00              NOP                            ;3032
000066  bf00              NOP                            ;3034
000068  e7d3              B        |L46.18|
;;;3036   
                          ENDP


                          AREA ||i.HAL_TIM_OC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_DeInit PROC
;;;522      */
;;;523    HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;524    {
000002  4604              MOV      r4,r0
;;;525      /* Check the parameters */
;;;526      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;527      
;;;528       htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  63e0              STR      r0,[r4,#0x3c]
;;;529       
;;;530      /* Disable the TIM Peripheral Clock */
;;;531      __HAL_TIM_DISABLE(htim);
000008  bf00              NOP      
00000a  6820              LDR      r0,[r4,#0]
00000c  6a00              LDR      r0,[r0,#0x20]
00000e  f2411111          MOV      r1,#0x1111
000012  4008              ANDS     r0,r0,r1
000014  b950              CBNZ     r0,|L47.44|
000016  6820              LDR      r0,[r4,#0]
000018  6a00              LDR      r0,[r0,#0x20]
00001a  1089              ASRS     r1,r1,#2
00001c  4008              ANDS     r0,r0,r1
00001e  b928              CBNZ     r0,|L47.44|
000020  6820              LDR      r0,[r4,#0]
000022  6800              LDR      r0,[r0,#0]
000024  f0200001          BIC      r0,r0,#1
000028  6821              LDR      r1,[r4,#0]
00002a  6008              STR      r0,[r1,#0]
                  |L47.44|
00002c  bf00              NOP      
;;;532      
;;;533      /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;534      HAL_TIM_OC_MspDeInit(htim);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       HAL_TIM_OC_MspDeInit
;;;535        
;;;536      /* Change TIM state */  
;;;537      htim->State = HAL_TIM_STATE_RESET; 
000034  2000              MOVS     r0,#0
000036  63e0              STR      r0,[r4,#0x3c]
;;;538    
;;;539      /* Release Lock */
;;;540      __HAL_UNLOCK(htim);
000038  bf00              NOP      
00003a  63a0              STR      r0,[r4,#0x38]
00003c  bf00              NOP      
;;;541    
;;;542      return HAL_OK;
;;;543    }
00003e  bd10              POP      {r4,pc}
;;;544    
                          ENDP


                          AREA ||i.HAL_TIM_OC_DelayElapsedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_DelayElapsedCallback PROC
;;;4438     */
;;;4439   __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4440   {
;;;4441     /* Prevent unused argument(s) compilation warning */
;;;4442     UNUSED(htim);
;;;4443    
;;;4444     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4445               the __HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
;;;4446      */
;;;4447   }
;;;4448   /**
                          ENDP


                          AREA ||i.HAL_TIM_OC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_GetState PROC
;;;4547     */
;;;4548   HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;4549   {
;;;4550     return htim->State;
000002  6bc8              LDR      r0,[r1,#0x3c]
;;;4551   }
000004  4770              BX       lr
;;;4552   
                          ENDP


                          AREA ||i.HAL_TIM_OC_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_Init PROC
;;;483      */
;;;484    HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef* htim)
000000  b510              PUSH     {r4,lr}
;;;485    {
000002  4604              MOV      r4,r0
;;;486      /* Check the TIM handle allocation */
;;;487      if(htim == NULL)
000004  b90c              CBNZ     r4,|L50.10|
;;;488      {
;;;489        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L50.8|
;;;490      }
;;;491    
;;;492      /* Check the parameters */
;;;493      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;494      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;495      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;496     
;;;497      if(htim->State == HAL_TIM_STATE_RESET)
;;;498      { 
;;;499        /* Allocate lock resource and initialize it */
;;;500        htim->Lock = HAL_UNLOCKED;  
;;;501        /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;502        HAL_TIM_OC_MspInit(htim);
;;;503      }
;;;504      
;;;505      /* Set the TIM state */
;;;506      htim->State= HAL_TIM_STATE_BUSY;
;;;507      
;;;508      /* Init the base time for the Output Compare */  
;;;509      TIM_Base_SetConfig(htim->Instance,  &htim->Init); 
;;;510      
;;;511      /* Initialize the TIM state*/
;;;512      htim->State= HAL_TIM_STATE_READY;
;;;513      
;;;514      return HAL_OK;
;;;515    }
000008  bd10              POP      {r4,pc}
                  |L50.10|
00000a  6be0              LDR      r0,[r4,#0x3c]         ;497
00000c  b920              CBNZ     r0,|L50.24|
00000e  2000              MOVS     r0,#0                 ;500
000010  63a0              STR      r0,[r4,#0x38]         ;500
000012  4620              MOV      r0,r4                 ;502
000014  f7fffffe          BL       HAL_TIM_OC_MspInit
                  |L50.24|
000018  2002              MOVS     r0,#2                 ;506
00001a  63e0              STR      r0,[r4,#0x3c]         ;506
00001c  1d21              ADDS     r1,r4,#4              ;509
00001e  6820              LDR      r0,[r4,#0]            ;509
000020  f7fffffe          BL       TIM_Base_SetConfig
000024  2001              MOVS     r0,#1                 ;512
000026  63e0              STR      r0,[r4,#0x3c]         ;512
000028  2000              MOVS     r0,#0                 ;514
00002a  e7ed              B        |L50.8|
;;;516    
                          ENDP


                          AREA ||i.HAL_TIM_OC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_MspDeInit PROC
;;;566      */
;;;567    __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;568    {
;;;569      /* Prevent unused argument(s) compilation warning */
;;;570      UNUSED(htim);
;;;571     
;;;572      /* NOTE : This function Should not be modified, when the callback is needed,
;;;573                the HAL_TIM_OC_MspDeInit could be implemented in the user file
;;;574       */
;;;575    }
;;;576    
                          ENDP


                          AREA ||i.HAL_TIM_OC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_MspInit PROC
;;;550      */
;;;551    __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;552    {
;;;553      /* Prevent unused argument(s) compilation warning */
;;;554      UNUSED(htim);
;;;555     
;;;556      /* NOTE : This function Should not be modified, when the callback is needed,
;;;557                the HAL_TIM_OC_MspInit could be implemented in the user file
;;;558       */
;;;559    }
;;;560    
                          ENDP


                          AREA ||i.HAL_TIM_OC_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start PROC
;;;588      */
;;;589    HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;590    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;591      /* Check the parameters */
;;;592      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;593      
;;;594      /* Enable the Output compare channel */
;;;595      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000006  2201              MOVS     r2,#1
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;596      
;;;597      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000010  490c              LDR      r1,|L53.68|
000012  6820              LDR      r0,[r4,#0]
000014  4288              CMP      r0,r1
000016  d003              BEQ      |L53.32|
000018  490b              LDR      r1,|L53.72|
00001a  6820              LDR      r0,[r4,#0]
00001c  4288              CMP      r0,r1
00001e  d101              BNE      |L53.36|
                  |L53.32|
000020  2001              MOVS     r0,#1
000022  e000              B        |L53.38|
                  |L53.36|
000024  2000              MOVS     r0,#0
                  |L53.38|
000026  b128              CBZ      r0,|L53.52|
;;;598      {
;;;599        /* Enable the main output */
;;;600        __HAL_TIM_MOE_ENABLE(htim);
000028  6820              LDR      r0,[r4,#0]
00002a  6c40              LDR      r0,[r0,#0x44]
00002c  f4404000          ORR      r0,r0,#0x8000
000030  6821              LDR      r1,[r4,#0]
000032  6448              STR      r0,[r1,#0x44]
                  |L53.52|
;;;601      }
;;;602      
;;;603      /* Enable the Peripheral */
;;;604      __HAL_TIM_ENABLE(htim); 
000034  6820              LDR      r0,[r4,#0]
000036  6800              LDR      r0,[r0,#0]
000038  f0400001          ORR      r0,r0,#1
00003c  6821              LDR      r1,[r4,#0]
00003e  6008              STR      r0,[r1,#0]
;;;605      
;;;606      /* Return function status */
;;;607      return HAL_OK;
000040  2000              MOVS     r0,#0
;;;608    }
000042  bd30              POP      {r4,r5,pc}
;;;609    
                          ENDP

                  |L53.68|
                          DCD      0x40010000
                  |L53.72|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start_DMA PROC
;;;790      */
;;;791    HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;792    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
;;;793      /* Check the parameters */
;;;794      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;795      
;;;796      if((htim->State == HAL_TIM_STATE_BUSY))
00000c  6be0              LDR      r0,[r4,#0x3c]
00000e  2802              CMP      r0,#2
000010  d101              BNE      |L54.22|
                  |L54.18|
;;;797      {
;;;798         return HAL_BUSY;
;;;799      }
;;;800      else if((htim->State == HAL_TIM_STATE_READY))
;;;801      {
;;;802        if(((uint32_t)pData == 0 ) && (Length > 0)) 
;;;803        {
;;;804          return HAL_ERROR;                                    
;;;805        }
;;;806        else
;;;807        {
;;;808          htim->State = HAL_TIM_STATE_BUSY;
;;;809        }
;;;810      }    
;;;811      switch (Channel)
;;;812      {
;;;813        case TIM_CHANNEL_1:
;;;814        {      
;;;815          /* Set the DMA Period elapsed callback */
;;;816          htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;817         
;;;818          /* Set the DMA error callback */
;;;819          htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;820          
;;;821          /* Enable the DMA Stream */
;;;822          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;823          
;;;824          /* Enable the TIM Capture/Compare 1 DMA request */
;;;825          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;826        }
;;;827        break;
;;;828        
;;;829        case TIM_CHANNEL_2:
;;;830        {
;;;831          /* Set the DMA Period elapsed callback */
;;;832          htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;833         
;;;834          /* Set the DMA error callback */
;;;835          htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;836          
;;;837          /* Enable the DMA Stream */
;;;838          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;839          
;;;840          /* Enable the TIM Capture/Compare 2 DMA request */
;;;841          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;842        }
;;;843        break;
;;;844        
;;;845        case TIM_CHANNEL_3:
;;;846        {
;;;847          /* Set the DMA Period elapsed callback */
;;;848          htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;849         
;;;850          /* Set the DMA error callback */
;;;851          htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
;;;852          
;;;853          /* Enable the DMA Stream */
;;;854          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;855          
;;;856          /* Enable the TIM Capture/Compare 3 DMA request */
;;;857          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;858        }
;;;859        break;
;;;860        
;;;861        case TIM_CHANNEL_4:
;;;862        {
;;;863         /* Set the DMA Period elapsed callback */
;;;864          htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;865         
;;;866          /* Set the DMA error callback */
;;;867          htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
;;;868          
;;;869          /* Enable the DMA Stream */
;;;870          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;871          
;;;872          /* Enable the TIM Capture/Compare 4 DMA request */
;;;873          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;874        }
;;;875        break;
;;;876        
;;;877        default:
;;;878        break;
;;;879      }
;;;880    
;;;881      /* Enable the Output compare channel */
;;;882      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;883      
;;;884      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
;;;885      {
;;;886        /* Enable the main output */
;;;887        __HAL_TIM_MOE_ENABLE(htim);
;;;888      }  
;;;889      
;;;890      /* Enable the Peripheral */
;;;891      __HAL_TIM_ENABLE(htim); 
;;;892      
;;;893      /* Return function status */
;;;894      return HAL_OK;
;;;895    }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L54.22|
000016  6be0              LDR      r0,[r4,#0x3c]         ;800
000018  2801              CMP      r0,#1                 ;800
00001a  d105              BNE      |L54.40|
00001c  b915              CBNZ     r5,|L54.36|
00001e  2f00              CMP      r7,#0                 ;802
000020  dd00              BLE      |L54.36|
000022  e7f6              B        |L54.18|
                  |L54.36|
000024  2002              MOVS     r0,#2                 ;808
000026  63e0              STR      r0,[r4,#0x3c]         ;808
                  |L54.40|
000028  b136              CBZ      r6,|L54.56|
00002a  2e04              CMP      r6,#4                 ;811
00002c  d019              BEQ      |L54.98|
00002e  2e08              CMP      r6,#8                 ;811
000030  d02c              BEQ      |L54.140|
000032  2e0c              CMP      r6,#0xc               ;811
000034  d154              BNE      |L54.224|
000036  e03e              B        |L54.182|
                  |L54.56|
000038  493a              LDR      r1,|L54.292|
00003a  6a20              LDR      r0,[r4,#0x20]         ;816
00003c  6401              STR      r1,[r0,#0x40]         ;816
00003e  493a              LDR      r1,|L54.296|
000040  6a20              LDR      r0,[r4,#0x20]         ;819
000042  6501              STR      r1,[r0,#0x50]         ;819
000044  6821              LDR      r1,[r4,#0]            ;822
000046  f1010234          ADD      r2,r1,#0x34           ;822
00004a  463b              MOV      r3,r7                 ;822
00004c  4629              MOV      r1,r5                 ;822
00004e  6a20              LDR      r0,[r4,#0x20]         ;822
000050  f7fffffe          BL       HAL_DMA_Start_IT
000054  6820              LDR      r0,[r4,#0]            ;825
000056  68c0              LDR      r0,[r0,#0xc]          ;825
000058  f4407000          ORR      r0,r0,#0x200          ;825
00005c  6821              LDR      r1,[r4,#0]            ;825
00005e  60c8              STR      r0,[r1,#0xc]          ;825
000060  e03f              B        |L54.226|
                  |L54.98|
000062  4930              LDR      r1,|L54.292|
000064  6a60              LDR      r0,[r4,#0x24]         ;832
000066  6401              STR      r1,[r0,#0x40]         ;832
000068  492f              LDR      r1,|L54.296|
00006a  6a60              LDR      r0,[r4,#0x24]         ;835
00006c  6501              STR      r1,[r0,#0x50]         ;835
00006e  6821              LDR      r1,[r4,#0]            ;838
000070  f1010238          ADD      r2,r1,#0x38           ;838
000074  463b              MOV      r3,r7                 ;838
000076  4629              MOV      r1,r5                 ;838
000078  6a60              LDR      r0,[r4,#0x24]         ;838
00007a  f7fffffe          BL       HAL_DMA_Start_IT
00007e  6820              LDR      r0,[r4,#0]            ;841
000080  68c0              LDR      r0,[r0,#0xc]          ;841
000082  f4406080          ORR      r0,r0,#0x400          ;841
000086  6821              LDR      r1,[r4,#0]            ;841
000088  60c8              STR      r0,[r1,#0xc]          ;841
00008a  e02a              B        |L54.226|
                  |L54.140|
00008c  4925              LDR      r1,|L54.292|
00008e  6aa0              LDR      r0,[r4,#0x28]         ;848
000090  6401              STR      r1,[r0,#0x40]         ;848
000092  4925              LDR      r1,|L54.296|
000094  6aa0              LDR      r0,[r4,#0x28]         ;851
000096  6501              STR      r1,[r0,#0x50]         ;851
000098  6821              LDR      r1,[r4,#0]            ;854
00009a  f101023c          ADD      r2,r1,#0x3c           ;854
00009e  463b              MOV      r3,r7                 ;854
0000a0  4629              MOV      r1,r5                 ;854
0000a2  6aa0              LDR      r0,[r4,#0x28]         ;854
0000a4  f7fffffe          BL       HAL_DMA_Start_IT
0000a8  6820              LDR      r0,[r4,#0]            ;857
0000aa  68c0              LDR      r0,[r0,#0xc]          ;857
0000ac  f4406000          ORR      r0,r0,#0x800          ;857
0000b0  6821              LDR      r1,[r4,#0]            ;857
0000b2  60c8              STR      r0,[r1,#0xc]          ;857
0000b4  e015              B        |L54.226|
                  |L54.182|
0000b6  491b              LDR      r1,|L54.292|
0000b8  6ae0              LDR      r0,[r4,#0x2c]         ;864
0000ba  6401              STR      r1,[r0,#0x40]         ;864
0000bc  491a              LDR      r1,|L54.296|
0000be  6ae0              LDR      r0,[r4,#0x2c]         ;867
0000c0  6501              STR      r1,[r0,#0x50]         ;867
0000c2  6821              LDR      r1,[r4,#0]            ;870
0000c4  f1010240          ADD      r2,r1,#0x40           ;870
0000c8  463b              MOV      r3,r7                 ;870
0000ca  4629              MOV      r1,r5                 ;870
0000cc  6ae0              LDR      r0,[r4,#0x2c]         ;870
0000ce  f7fffffe          BL       HAL_DMA_Start_IT
0000d2  6820              LDR      r0,[r4,#0]            ;873
0000d4  68c0              LDR      r0,[r0,#0xc]          ;873
0000d6  f4405080          ORR      r0,r0,#0x1000         ;873
0000da  6821              LDR      r1,[r4,#0]            ;873
0000dc  60c8              STR      r0,[r1,#0xc]          ;873
0000de  e000              B        |L54.226|
                  |L54.224|
0000e0  bf00              NOP                            ;878
                  |L54.226|
0000e2  bf00              NOP                            ;827
0000e4  2201              MOVS     r2,#1                 ;882
0000e6  4631              MOV      r1,r6                 ;882
0000e8  6820              LDR      r0,[r4,#0]            ;882
0000ea  f7fffffe          BL       TIM_CCxChannelCmd
0000ee  490f              LDR      r1,|L54.300|
0000f0  6820              LDR      r0,[r4,#0]            ;884
0000f2  4288              CMP      r0,r1                 ;884
0000f4  d003              BEQ      |L54.254|
0000f6  490e              LDR      r1,|L54.304|
0000f8  6820              LDR      r0,[r4,#0]            ;884
0000fa  4288              CMP      r0,r1                 ;884
0000fc  d101              BNE      |L54.258|
                  |L54.254|
0000fe  2001              MOVS     r0,#1                 ;884
000100  e000              B        |L54.260|
                  |L54.258|
000102  2000              MOVS     r0,#0                 ;884
                  |L54.260|
000104  b128              CBZ      r0,|L54.274|
000106  6820              LDR      r0,[r4,#0]            ;887
000108  6c40              LDR      r0,[r0,#0x44]         ;887
00010a  f4404000          ORR      r0,r0,#0x8000         ;887
00010e  6821              LDR      r1,[r4,#0]            ;887
000110  6448              STR      r0,[r1,#0x44]         ;887
                  |L54.274|
000112  6820              LDR      r0,[r4,#0]            ;891
000114  6800              LDR      r0,[r0,#0]            ;891
000116  f0400001          ORR      r0,r0,#1              ;891
00011a  6821              LDR      r1,[r4,#0]            ;891
00011c  6008              STR      r0,[r1,#0]            ;891
00011e  2000              MOVS     r0,#0                 ;894
000120  e777              B        |L54.18|
;;;896    
                          ENDP

000122  0000              DCW      0x0000
                  |L54.292|
                          DCD      TIM_DMADelayPulseCplt
                  |L54.296|
                          DCD      TIM_DMAError
                  |L54.300|
                          DCD      0x40010000
                  |L54.304|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OC_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start_IT PROC
;;;654      */
;;;655    HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;656    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;657      /* Check the parameters */
;;;658      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;659      
;;;660      switch (Channel)
000006  b135              CBZ      r5,|L55.22|
000008  2d04              CMP      r5,#4
00000a  d00b              BEQ      |L55.36|
00000c  2d08              CMP      r5,#8
00000e  d010              BEQ      |L55.50|
000010  2d0c              CMP      r5,#0xc
000012  d11c              BNE      |L55.78|
000014  e014              B        |L55.64|
                  |L55.22|
;;;661      {
;;;662        case TIM_CHANNEL_1:
;;;663        {       
;;;664          /* Enable the TIM Capture/Compare 1 interrupt */
;;;665          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f0400002          ORR      r0,r0,#2
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;666        }
;;;667        break;
000022  e015              B        |L55.80|
                  |L55.36|
;;;668        
;;;669        case TIM_CHANNEL_2:
;;;670        {
;;;671          /* Enable the TIM Capture/Compare 2 interrupt */
;;;672          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f0400004          ORR      r0,r0,#4
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;673        }
;;;674        break;
000030  e00e              B        |L55.80|
                  |L55.50|
;;;675        
;;;676        case TIM_CHANNEL_3:
;;;677        {
;;;678          /* Enable the TIM Capture/Compare 3 interrupt */
;;;679          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  f0400008          ORR      r0,r0,#8
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;680        }
;;;681        break;
00003e  e007              B        |L55.80|
                  |L55.64|
;;;682        
;;;683        case TIM_CHANNEL_4:
;;;684        {
;;;685          /* Enable the TIM Capture/Compare 4 interrupt */
;;;686          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f0400010          ORR      r0,r0,#0x10
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;687        }
;;;688        break;
00004c  e000              B        |L55.80|
                  |L55.78|
;;;689        
;;;690        default:
;;;691        break;
00004e  bf00              NOP      
                  |L55.80|
000050  bf00              NOP                            ;667
;;;692      } 
;;;693    
;;;694      /* Enable the Output compare channel */
;;;695      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000052  2201              MOVS     r2,#1
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;696      
;;;697      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00005c  490c              LDR      r1,|L55.144|
00005e  6820              LDR      r0,[r4,#0]
000060  4288              CMP      r0,r1
000062  d003              BEQ      |L55.108|
000064  490b              LDR      r1,|L55.148|
000066  6820              LDR      r0,[r4,#0]
000068  4288              CMP      r0,r1
00006a  d101              BNE      |L55.112|
                  |L55.108|
00006c  2001              MOVS     r0,#1
00006e  e000              B        |L55.114|
                  |L55.112|
000070  2000              MOVS     r0,#0
                  |L55.114|
000072  b128              CBZ      r0,|L55.128|
;;;698      {
;;;699        /* Enable the main output */
;;;700        __HAL_TIM_MOE_ENABLE(htim);
000074  6820              LDR      r0,[r4,#0]
000076  6c40              LDR      r0,[r0,#0x44]
000078  f4404000          ORR      r0,r0,#0x8000
00007c  6821              LDR      r1,[r4,#0]
00007e  6448              STR      r0,[r1,#0x44]
                  |L55.128|
;;;701      }
;;;702    
;;;703      /* Enable the Peripheral */
;;;704      __HAL_TIM_ENABLE(htim);
000080  6820              LDR      r0,[r4,#0]
000082  6800              LDR      r0,[r0,#0]
000084  f0400001          ORR      r0,r0,#1
000088  6821              LDR      r1,[r4,#0]
00008a  6008              STR      r0,[r1,#0]
;;;705      
;;;706      /* Return function status */
;;;707      return HAL_OK;
00008c  2000              MOVS     r0,#0
;;;708    }
00008e  bd30              POP      {r4,r5,pc}
;;;709    
                          ENDP

                  |L55.144|
                          DCD      0x40010000
                  |L55.148|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OC_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop PROC
;;;621      */
;;;622    HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;623    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;624      /* Check the parameters */
;;;625      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;626      
;;;627      /* Disable the Output compare channel */
;;;628      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000006  2200              MOVS     r2,#0
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;629      
;;;630      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000010  4919              LDR      r1,|L56.120|
000012  6820              LDR      r0,[r4,#0]
000014  4288              CMP      r0,r1
000016  d003              BEQ      |L56.32|
000018  4918              LDR      r1,|L56.124|
00001a  6820              LDR      r0,[r4,#0]
00001c  4288              CMP      r0,r1
00001e  d101              BNE      |L56.36|
                  |L56.32|
000020  2001              MOVS     r0,#1
000022  e000              B        |L56.38|
                  |L56.36|
000024  2000              MOVS     r0,#0
                  |L56.38|
000026  b190              CBZ      r0,|L56.78|
;;;631      {
;;;632        /* Disable the Main Output */
;;;633        __HAL_TIM_MOE_DISABLE(htim);
000028  bf00              NOP      
00002a  6820              LDR      r0,[r4,#0]
00002c  6a00              LDR      r0,[r0,#0x20]
00002e  f2411111          MOV      r1,#0x1111
000032  4008              ANDS     r0,r0,r1
000034  b950              CBNZ     r0,|L56.76|
000036  6820              LDR      r0,[r4,#0]
000038  6a00              LDR      r0,[r0,#0x20]
00003a  1089              ASRS     r1,r1,#2
00003c  4008              ANDS     r0,r0,r1
00003e  b928              CBNZ     r0,|L56.76|
000040  6820              LDR      r0,[r4,#0]
000042  6c40              LDR      r0,[r0,#0x44]
000044  f4204000          BIC      r0,r0,#0x8000
000048  6821              LDR      r1,[r4,#0]
00004a  6448              STR      r0,[r1,#0x44]
                  |L56.76|
00004c  bf00              NOP      
                  |L56.78|
;;;634      }  
;;;635      
;;;636      /* Disable the Peripheral */
;;;637      __HAL_TIM_DISABLE(htim);  
00004e  bf00              NOP      
000050  6820              LDR      r0,[r4,#0]
000052  6a00              LDR      r0,[r0,#0x20]
000054  f2411111          MOV      r1,#0x1111
000058  4008              ANDS     r0,r0,r1
00005a  b950              CBNZ     r0,|L56.114|
00005c  6820              LDR      r0,[r4,#0]
00005e  6a00              LDR      r0,[r0,#0x20]
000060  1089              ASRS     r1,r1,#2
000062  4008              ANDS     r0,r0,r1
000064  b928              CBNZ     r0,|L56.114|
000066  6820              LDR      r0,[r4,#0]
000068  6800              LDR      r0,[r0,#0]
00006a  f0200001          BIC      r0,r0,#1
00006e  6821              LDR      r1,[r4,#0]
000070  6008              STR      r0,[r1,#0]
                  |L56.114|
000072  bf00              NOP      
;;;638      
;;;639      /* Return function status */
;;;640      return HAL_OK;
000074  2000              MOVS     r0,#0
;;;641    }  
000076  bd30              POP      {r4,r5,pc}
;;;642    
                          ENDP

                  |L56.120|
                          DCD      0x40010000
                  |L56.124|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OC_Stop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop_DMA PROC
;;;908      */
;;;909    HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;910    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;911      /* Check the parameters */
;;;912      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;913      
;;;914      switch (Channel)
000006  b135              CBZ      r5,|L57.22|
000008  2d04              CMP      r5,#4
00000a  d00b              BEQ      |L57.36|
00000c  2d08              CMP      r5,#8
00000e  d010              BEQ      |L57.50|
000010  2d0c              CMP      r5,#0xc
000012  d11c              BNE      |L57.78|
000014  e014              B        |L57.64|
                  |L57.22|
;;;915      {
;;;916        case TIM_CHANNEL_1:
;;;917        {       
;;;918          /* Disable the TIM Capture/Compare 1 DMA request */
;;;919          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f4207000          BIC      r0,r0,#0x200
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;920        }
;;;921        break;
000022  e015              B        |L57.80|
                  |L57.36|
;;;922        
;;;923        case TIM_CHANNEL_2:
;;;924        {
;;;925          /* Disable the TIM Capture/Compare 2 DMA request */
;;;926          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f4206080          BIC      r0,r0,#0x400
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;927        }
;;;928        break;
000030  e00e              B        |L57.80|
                  |L57.50|
;;;929        
;;;930        case TIM_CHANNEL_3:
;;;931        {
;;;932          /* Disable the TIM Capture/Compare 3 DMA request */
;;;933          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  f4206000          BIC      r0,r0,#0x800
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;934        }
;;;935        break;
00003e  e007              B        |L57.80|
                  |L57.64|
;;;936        
;;;937        case TIM_CHANNEL_4:
;;;938        {
;;;939          /* Disable the TIM Capture/Compare 4 interrupt */
;;;940          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f4205080          BIC      r0,r0,#0x1000
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;941        }
;;;942        break;
00004c  e000              B        |L57.80|
                  |L57.78|
;;;943        
;;;944        default:
;;;945        break;
00004e  bf00              NOP      
                  |L57.80|
000050  bf00              NOP                            ;921
;;;946      } 
;;;947      
;;;948      /* Disable the Output compare channel */
;;;949      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000052  2200              MOVS     r2,#0
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;950      
;;;951      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00005c  491a              LDR      r1,|L57.200|
00005e  6820              LDR      r0,[r4,#0]
000060  4288              CMP      r0,r1
000062  d003              BEQ      |L57.108|
000064  4919              LDR      r1,|L57.204|
000066  6820              LDR      r0,[r4,#0]
000068  4288              CMP      r0,r1
00006a  d101              BNE      |L57.112|
                  |L57.108|
00006c  2001              MOVS     r0,#1
00006e  e000              B        |L57.114|
                  |L57.112|
000070  2000              MOVS     r0,#0
                  |L57.114|
000072  b190              CBZ      r0,|L57.154|
;;;952      {
;;;953        /* Disable the Main Output */
;;;954        __HAL_TIM_MOE_DISABLE(htim);
000074  bf00              NOP      
000076  6820              LDR      r0,[r4,#0]
000078  6a00              LDR      r0,[r0,#0x20]
00007a  f2411111          MOV      r1,#0x1111
00007e  4008              ANDS     r0,r0,r1
000080  b950              CBNZ     r0,|L57.152|
000082  6820              LDR      r0,[r4,#0]
000084  6a00              LDR      r0,[r0,#0x20]
000086  1089              ASRS     r1,r1,#2
000088  4008              ANDS     r0,r0,r1
00008a  b928              CBNZ     r0,|L57.152|
00008c  6820              LDR      r0,[r4,#0]
00008e  6c40              LDR      r0,[r0,#0x44]
000090  f4204000          BIC      r0,r0,#0x8000
000094  6821              LDR      r1,[r4,#0]
000096  6448              STR      r0,[r1,#0x44]
                  |L57.152|
000098  bf00              NOP      
                  |L57.154|
;;;955      }
;;;956      
;;;957      /* Disable the Peripheral */
;;;958      __HAL_TIM_DISABLE(htim);
00009a  bf00              NOP      
00009c  6820              LDR      r0,[r4,#0]
00009e  6a00              LDR      r0,[r0,#0x20]
0000a0  f2411111          MOV      r1,#0x1111
0000a4  4008              ANDS     r0,r0,r1
0000a6  b950              CBNZ     r0,|L57.190|
0000a8  6820              LDR      r0,[r4,#0]
0000aa  6a00              LDR      r0,[r0,#0x20]
0000ac  1089              ASRS     r1,r1,#2
0000ae  4008              ANDS     r0,r0,r1
0000b0  b928              CBNZ     r0,|L57.190|
0000b2  6820              LDR      r0,[r4,#0]
0000b4  6800              LDR      r0,[r0,#0]
0000b6  f0200001          BIC      r0,r0,#1
0000ba  6821              LDR      r1,[r4,#0]
0000bc  6008              STR      r0,[r1,#0]
                  |L57.190|
0000be  bf00              NOP      
;;;959      
;;;960      /* Change the htim state */
;;;961      htim->State = HAL_TIM_STATE_READY;
0000c0  2001              MOVS     r0,#1
0000c2  63e0              STR      r0,[r4,#0x3c]
;;;962      
;;;963      /* Return function status */
;;;964      return HAL_OK;
0000c4  2000              MOVS     r0,#0
;;;965    }
0000c6  bd30              POP      {r4,r5,pc}
;;;966    
                          ENDP

                  |L57.200|
                          DCD      0x40010000
                  |L57.204|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OC_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop_IT PROC
;;;721      */
;;;722    HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;723    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;724      /* Check the parameters */
;;;725      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;726      
;;;727      switch (Channel)
000006  b135              CBZ      r5,|L58.22|
000008  2d04              CMP      r5,#4
00000a  d00b              BEQ      |L58.36|
00000c  2d08              CMP      r5,#8
00000e  d010              BEQ      |L58.50|
000010  2d0c              CMP      r5,#0xc
000012  d11c              BNE      |L58.78|
000014  e014              B        |L58.64|
                  |L58.22|
;;;728      {
;;;729        case TIM_CHANNEL_1:
;;;730        {       
;;;731          /* Disable the TIM Capture/Compare 1 interrupt */
;;;732          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f0200002          BIC      r0,r0,#2
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;733        }
;;;734        break;
000022  e015              B        |L58.80|
                  |L58.36|
;;;735        
;;;736        case TIM_CHANNEL_2:
;;;737        {
;;;738          /* Disable the TIM Capture/Compare 2 interrupt */
;;;739          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f0200004          BIC      r0,r0,#4
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;740        }
;;;741        break;
000030  e00e              B        |L58.80|
                  |L58.50|
;;;742        
;;;743        case TIM_CHANNEL_3:
;;;744        {
;;;745          /* Disable the TIM Capture/Compare 3 interrupt */
;;;746          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  f0200008          BIC      r0,r0,#8
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;747        }
;;;748        break;
00003e  e007              B        |L58.80|
                  |L58.64|
;;;749        
;;;750        case TIM_CHANNEL_4:
;;;751        {
;;;752          /* Disable the TIM Capture/Compare 4 interrupt */
;;;753          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f0200010          BIC      r0,r0,#0x10
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;754        }
;;;755        break;
00004c  e000              B        |L58.80|
                  |L58.78|
;;;756        
;;;757        default:
;;;758        break; 
00004e  bf00              NOP      
                  |L58.80|
000050  bf00              NOP                            ;734
;;;759      } 
;;;760      
;;;761      /* Disable the Output compare channel */
;;;762      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE); 
000052  2200              MOVS     r2,#0
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;763      
;;;764      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00005c  4919              LDR      r1,|L58.196|
00005e  6820              LDR      r0,[r4,#0]
000060  4288              CMP      r0,r1
000062  d003              BEQ      |L58.108|
000064  4918              LDR      r1,|L58.200|
000066  6820              LDR      r0,[r4,#0]
000068  4288              CMP      r0,r1
00006a  d101              BNE      |L58.112|
                  |L58.108|
00006c  2001              MOVS     r0,#1
00006e  e000              B        |L58.114|
                  |L58.112|
000070  2000              MOVS     r0,#0
                  |L58.114|
000072  b190              CBZ      r0,|L58.154|
;;;765      {
;;;766        /* Disable the Main Output */
;;;767        __HAL_TIM_MOE_DISABLE(htim);
000074  bf00              NOP      
000076  6820              LDR      r0,[r4,#0]
000078  6a00              LDR      r0,[r0,#0x20]
00007a  f2411111          MOV      r1,#0x1111
00007e  4008              ANDS     r0,r0,r1
000080  b950              CBNZ     r0,|L58.152|
000082  6820              LDR      r0,[r4,#0]
000084  6a00              LDR      r0,[r0,#0x20]
000086  1089              ASRS     r1,r1,#2
000088  4008              ANDS     r0,r0,r1
00008a  b928              CBNZ     r0,|L58.152|
00008c  6820              LDR      r0,[r4,#0]
00008e  6c40              LDR      r0,[r0,#0x44]
000090  f4204000          BIC      r0,r0,#0x8000
000094  6821              LDR      r1,[r4,#0]
000096  6448              STR      r0,[r1,#0x44]
                  |L58.152|
000098  bf00              NOP      
                  |L58.154|
;;;768      }
;;;769      
;;;770      /* Disable the Peripheral */
;;;771      __HAL_TIM_DISABLE(htim);  
00009a  bf00              NOP      
00009c  6820              LDR      r0,[r4,#0]
00009e  6a00              LDR      r0,[r0,#0x20]
0000a0  f2411111          MOV      r1,#0x1111
0000a4  4008              ANDS     r0,r0,r1
0000a6  b950              CBNZ     r0,|L58.190|
0000a8  6820              LDR      r0,[r4,#0]
0000aa  6a00              LDR      r0,[r0,#0x20]
0000ac  1089              ASRS     r1,r1,#2
0000ae  4008              ANDS     r0,r0,r1
0000b0  b928              CBNZ     r0,|L58.190|
0000b2  6820              LDR      r0,[r4,#0]
0000b4  6800              LDR      r0,[r0,#0]
0000b6  f0200001          BIC      r0,r0,#1
0000ba  6821              LDR      r1,[r4,#0]
0000bc  6008              STR      r0,[r1,#0]
                  |L58.190|
0000be  bf00              NOP      
;;;772      
;;;773      /* Return function status */
;;;774      return HAL_OK;
0000c0  2000              MOVS     r0,#0
;;;775    }
0000c2  bd30              POP      {r4,r5,pc}
;;;776    
                          ENDP

                  |L58.196|
                          DCD      0x40010000
                  |L58.200|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OnePulse_ConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_ConfigChannel PROC
;;;3248     */
;;;3249   HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef* sConfig, uint32_t OutputChannel,  uint32_t InputChannel)
000000  b5f0              PUSH     {r4-r7,lr}
;;;3250   {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;3251     TIM_OC_InitTypeDef temp1;
;;;3252     
;;;3253     /* Check the parameters */
;;;3254     assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
;;;3255     assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
;;;3256   
;;;3257     if(OutputChannel != InputChannel)  
00000c  42be              CMP      r6,r7
00000e  d07f              BEQ      |L59.272|
;;;3258     {
;;;3259       __HAL_LOCK(htim);
000010  bf00              NOP      
000012  6ba0              LDR      r0,[r4,#0x38]
000014  2801              CMP      r0,#1
000016  d102              BNE      |L59.30|
000018  2002              MOVS     r0,#2
                  |L59.26|
;;;3260     
;;;3261       htim->State = HAL_TIM_STATE_BUSY;
;;;3262   
;;;3263       /* Extract the Output compare configuration from sConfig structure */  
;;;3264       temp1.OCMode = sConfig->OCMode;
;;;3265       temp1.Pulse = sConfig->Pulse;
;;;3266       temp1.OCPolarity = sConfig->OCPolarity;
;;;3267       temp1.OCNPolarity = sConfig->OCNPolarity;
;;;3268       temp1.OCIdleState = sConfig->OCIdleState;
;;;3269       temp1.OCNIdleState = sConfig->OCNIdleState; 
;;;3270       
;;;3271       switch (OutputChannel)
;;;3272       {
;;;3273         case TIM_CHANNEL_1:
;;;3274         {
;;;3275           assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3276         
;;;3277           TIM_OC1_SetConfig(htim->Instance, &temp1); 
;;;3278         }
;;;3279         break;
;;;3280         case TIM_CHANNEL_2:
;;;3281         {
;;;3282           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3283         
;;;3284           TIM_OC2_SetConfig(htim->Instance, &temp1);
;;;3285         }
;;;3286         break;
;;;3287         default:
;;;3288         break;  
;;;3289       } 
;;;3290       switch (InputChannel)
;;;3291       {
;;;3292         case TIM_CHANNEL_1:
;;;3293         {
;;;3294           assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3295         
;;;3296           TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;3297                           sConfig->ICSelection, sConfig->ICFilter);
;;;3298                  
;;;3299           /* Reset the IC1PSC Bits */
;;;3300           htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;3301   
;;;3302           /* Select the Trigger source */
;;;3303           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;3304           htim->Instance->SMCR |= TIM_TS_TI1FP1;
;;;3305         
;;;3306           /* Select the Slave Mode */      
;;;3307           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3308           htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;3309         }
;;;3310         break;
;;;3311         case TIM_CHANNEL_2:
;;;3312         {
;;;3313           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3314         
;;;3315           TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;3316                    sConfig->ICSelection, sConfig->ICFilter);
;;;3317                  
;;;3318           /* Reset the IC2PSC Bits */
;;;3319           htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;3320   
;;;3321           /* Select the Trigger source */
;;;3322           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;3323           htim->Instance->SMCR |= TIM_TS_TI2FP2;
;;;3324         
;;;3325           /* Select the Slave Mode */      
;;;3326           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3327           htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;3328         }
;;;3329         break;
;;;3330       
;;;3331         default:
;;;3332         break;  
;;;3333       }
;;;3334     
;;;3335       htim->State = HAL_TIM_STATE_READY;
;;;3336       
;;;3337       __HAL_UNLOCK(htim);
;;;3338     
;;;3339       return HAL_OK;
;;;3340     }
;;;3341     else
;;;3342     {
;;;3343       return HAL_ERROR;
;;;3344     }
;;;3345   } 
00001a  b007              ADD      sp,sp,#0x1c
00001c  bdf0              POP      {r4-r7,pc}
                  |L59.30|
00001e  2001              MOVS     r0,#1                 ;3259
000020  63a0              STR      r0,[r4,#0x38]         ;3259
000022  bf00              NOP                            ;3259
000024  2002              MOVS     r0,#2                 ;3261
000026  63e0              STR      r0,[r4,#0x3c]         ;3261
000028  6828              LDR      r0,[r5,#0]            ;3264
00002a  9000              STR      r0,[sp,#0]            ;3264
00002c  6868              LDR      r0,[r5,#4]            ;3265
00002e  9001              STR      r0,[sp,#4]            ;3265
000030  68a8              LDR      r0,[r5,#8]            ;3266
000032  9002              STR      r0,[sp,#8]            ;3266
000034  68e8              LDR      r0,[r5,#0xc]          ;3267
000036  9003              STR      r0,[sp,#0xc]          ;3267
000038  6928              LDR      r0,[r5,#0x10]         ;3268
00003a  9005              STR      r0,[sp,#0x14]         ;3268
00003c  6968              LDR      r0,[r5,#0x14]         ;3269
00003e  9006              STR      r0,[sp,#0x18]         ;3269
000040  b116              CBZ      r6,|L59.72|
000042  2e04              CMP      r6,#4                 ;3271
000044  d10a              BNE      |L59.92|
000046  e004              B        |L59.82|
                  |L59.72|
000048  4669              MOV      r1,sp                 ;3277
00004a  6820              LDR      r0,[r4,#0]            ;3277
00004c  f7fffffe          BL       TIM_OC1_SetConfig
000050  e005              B        |L59.94|
                  |L59.82|
000052  4669              MOV      r1,sp                 ;3284
000054  6820              LDR      r0,[r4,#0]            ;3284
000056  f7fffffe          BL       TIM_OC2_SetConfig
00005a  e000              B        |L59.94|
                  |L59.92|
00005c  bf00              NOP                            ;3288
                  |L59.94|
00005e  bf00              NOP                            ;3279
000060  b117              CBZ      r7,|L59.104|
000062  2f04              CMP      r7,#4                 ;3290
000064  d14b              BNE      |L59.254|
000066  e024              B        |L59.178|
                  |L59.104|
000068  e9d52307          LDRD     r2,r3,[r5,#0x1c]      ;3296
00006c  69a9              LDR      r1,[r5,#0x18]         ;3296
00006e  6820              LDR      r0,[r4,#0]            ;3296
000070  f7fffffe          BL       TIM_TI1_SetConfig
000074  6820              LDR      r0,[r4,#0]            ;3300
000076  6980              LDR      r0,[r0,#0x18]         ;3300
000078  f020000c          BIC      r0,r0,#0xc            ;3300
00007c  6821              LDR      r1,[r4,#0]            ;3300
00007e  6188              STR      r0,[r1,#0x18]         ;3300
000080  6820              LDR      r0,[r4,#0]            ;3303
000082  6880              LDR      r0,[r0,#8]            ;3303
000084  f0200070          BIC      r0,r0,#0x70           ;3303
000088  6821              LDR      r1,[r4,#0]            ;3303
00008a  6088              STR      r0,[r1,#8]            ;3303
00008c  6820              LDR      r0,[r4,#0]            ;3304
00008e  6880              LDR      r0,[r0,#8]            ;3304
000090  f0400050          ORR      r0,r0,#0x50           ;3304
000094  6821              LDR      r1,[r4,#0]            ;3304
000096  6088              STR      r0,[r1,#8]            ;3304
000098  6820              LDR      r0,[r4,#0]            ;3307
00009a  6880              LDR      r0,[r0,#8]            ;3307
00009c  491d              LDR      r1,|L59.276|
00009e  4008              ANDS     r0,r0,r1              ;3307
0000a0  6821              LDR      r1,[r4,#0]            ;3307
0000a2  6088              STR      r0,[r1,#8]            ;3307
0000a4  6820              LDR      r0,[r4,#0]            ;3308
0000a6  6880              LDR      r0,[r0,#8]            ;3308
0000a8  f0400006          ORR      r0,r0,#6              ;3308
0000ac  6821              LDR      r1,[r4,#0]            ;3308
0000ae  6088              STR      r0,[r1,#8]            ;3308
0000b0  e026              B        |L59.256|
                  |L59.178|
0000b2  e9d52307          LDRD     r2,r3,[r5,#0x1c]      ;3315
0000b6  69a9              LDR      r1,[r5,#0x18]         ;3315
0000b8  6820              LDR      r0,[r4,#0]            ;3315
0000ba  f7fffffe          BL       TIM_TI2_SetConfig
0000be  6820              LDR      r0,[r4,#0]            ;3319
0000c0  6980              LDR      r0,[r0,#0x18]         ;3319
0000c2  f4206040          BIC      r0,r0,#0xc00          ;3319
0000c6  6821              LDR      r1,[r4,#0]            ;3319
0000c8  6188              STR      r0,[r1,#0x18]         ;3319
0000ca  6820              LDR      r0,[r4,#0]            ;3322
0000cc  6880              LDR      r0,[r0,#8]            ;3322
0000ce  f0200070          BIC      r0,r0,#0x70           ;3322
0000d2  6821              LDR      r1,[r4,#0]            ;3322
0000d4  6088              STR      r0,[r1,#8]            ;3322
0000d6  6820              LDR      r0,[r4,#0]            ;3323
0000d8  6880              LDR      r0,[r0,#8]            ;3323
0000da  f0400060          ORR      r0,r0,#0x60           ;3323
0000de  6821              LDR      r1,[r4,#0]            ;3323
0000e0  6088              STR      r0,[r1,#8]            ;3323
0000e2  6820              LDR      r0,[r4,#0]            ;3326
0000e4  6880              LDR      r0,[r0,#8]            ;3326
0000e6  490b              LDR      r1,|L59.276|
0000e8  4008              ANDS     r0,r0,r1              ;3326
0000ea  6821              LDR      r1,[r4,#0]            ;3326
0000ec  6088              STR      r0,[r1,#8]            ;3326
0000ee  6820              LDR      r0,[r4,#0]            ;3327
0000f0  6880              LDR      r0,[r0,#8]            ;3327
0000f2  f0400006          ORR      r0,r0,#6              ;3327
0000f6  6821              LDR      r1,[r4,#0]            ;3327
0000f8  6088              STR      r0,[r1,#8]            ;3327
0000fa  e001              B        |L59.256|
0000fc  e008              B        |L59.272|
                  |L59.254|
0000fe  bf00              NOP                            ;3332
                  |L59.256|
000100  bf00              NOP                            ;3310
000102  2001              MOVS     r0,#1                 ;3335
000104  63e0              STR      r0,[r4,#0x3c]         ;3335
000106  bf00              NOP                            ;3337
000108  2000              MOVS     r0,#0                 ;3337
00010a  63a0              STR      r0,[r4,#0x38]         ;3337
00010c  bf00              NOP                            ;3337
00010e  e784              B        |L59.26|
                  |L59.272|
000110  2001              MOVS     r0,#1                 ;3343
000112  e782              B        |L59.26|
;;;3346   
                          ENDP

                  |L59.276|
                          DCD      0xfffefff8

                          AREA ||i.HAL_TIM_OnePulse_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_DeInit PROC
;;;2046     */
;;;2047   HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;2048   {
000002  4604              MOV      r4,r0
;;;2049     /* Check the parameters */
;;;2050     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2051     
;;;2052     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  63e0              STR      r0,[r4,#0x3c]
;;;2053     
;;;2054     /* Disable the TIM Peripheral Clock */
;;;2055     __HAL_TIM_DISABLE(htim);
000008  bf00              NOP      
00000a  6820              LDR      r0,[r4,#0]
00000c  6a00              LDR      r0,[r0,#0x20]
00000e  f2411111          MOV      r1,#0x1111
000012  4008              ANDS     r0,r0,r1
000014  b950              CBNZ     r0,|L60.44|
000016  6820              LDR      r0,[r4,#0]
000018  6a00              LDR      r0,[r0,#0x20]
00001a  1089              ASRS     r1,r1,#2
00001c  4008              ANDS     r0,r0,r1
00001e  b928              CBNZ     r0,|L60.44|
000020  6820              LDR      r0,[r4,#0]
000022  6800              LDR      r0,[r0,#0]
000024  f0200001          BIC      r0,r0,#1
000028  6821              LDR      r1,[r4,#0]
00002a  6008              STR      r0,[r1,#0]
                  |L60.44|
00002c  bf00              NOP      
;;;2056     
;;;2057     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;2058     HAL_TIM_OnePulse_MspDeInit(htim);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       HAL_TIM_OnePulse_MspDeInit
;;;2059       
;;;2060     /* Change TIM state */  
;;;2061     htim->State = HAL_TIM_STATE_RESET;
000034  2000              MOVS     r0,#0
000036  63e0              STR      r0,[r4,#0x3c]
;;;2062   
;;;2063     /* Release Lock */
;;;2064     __HAL_UNLOCK(htim);
000038  bf00              NOP      
00003a  63a0              STR      r0,[r4,#0x38]
00003c  bf00              NOP      
;;;2065   
;;;2066     return HAL_OK;
;;;2067   }
00003e  bd10              POP      {r4,pc}
;;;2068   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_GetState PROC
;;;4580     */
;;;4581   HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;4582   {
;;;4583     return htim->State;
000002  6bc8              LDR      r0,[r1,#0x3c]
;;;4584   }
000004  4770              BX       lr
;;;4585   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_Init PROC
;;;2000     */
;;;2001   HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
000000  b570              PUSH     {r4-r6,lr}
;;;2002   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2003     /* Check the TIM handle allocation */
;;;2004     if(htim == NULL)
000006  b90c              CBNZ     r4,|L62.12|
;;;2005     {
;;;2006       return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L62.10|
;;;2007     }
;;;2008   
;;;2009     /* Check the parameters */
;;;2010     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2011     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;2012     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;2013     assert_param(IS_TIM_OPM_MODE(OnePulseMode));
;;;2014     
;;;2015     if(htim->State == HAL_TIM_STATE_RESET)
;;;2016     { 
;;;2017       /* Allocate lock resource and initialize it */
;;;2018       htim->Lock = HAL_UNLOCKED;    
;;;2019       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;2020       HAL_TIM_OnePulse_MspInit(htim);
;;;2021     }
;;;2022     
;;;2023     /* Set the TIM state */
;;;2024     htim->State= HAL_TIM_STATE_BUSY;  
;;;2025     
;;;2026     /* Configure the Time base in the One Pulse Mode */
;;;2027     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;2028     
;;;2029     /* Reset the OPM Bit */
;;;2030     htim->Instance->CR1 &= ~TIM_CR1_OPM;
;;;2031   
;;;2032     /* Configure the OPM Mode */
;;;2033     htim->Instance->CR1 |= OnePulseMode;
;;;2034      
;;;2035     /* Initialize the TIM state*/
;;;2036     htim->State= HAL_TIM_STATE_READY;
;;;2037     
;;;2038     return HAL_OK;
;;;2039   }
00000a  bd70              POP      {r4-r6,pc}
                  |L62.12|
00000c  6be0              LDR      r0,[r4,#0x3c]         ;2015
00000e  b920              CBNZ     r0,|L62.26|
000010  2000              MOVS     r0,#0                 ;2018
000012  63a0              STR      r0,[r4,#0x38]         ;2018
000014  4620              MOV      r0,r4                 ;2020
000016  f7fffffe          BL       HAL_TIM_OnePulse_MspInit
                  |L62.26|
00001a  2002              MOVS     r0,#2                 ;2024
00001c  63e0              STR      r0,[r4,#0x3c]         ;2024
00001e  1d21              ADDS     r1,r4,#4              ;2027
000020  6820              LDR      r0,[r4,#0]            ;2027
000022  f7fffffe          BL       TIM_Base_SetConfig
000026  6820              LDR      r0,[r4,#0]            ;2030
000028  6800              LDR      r0,[r0,#0]            ;2030
00002a  f0200008          BIC      r0,r0,#8              ;2030
00002e  6821              LDR      r1,[r4,#0]            ;2030
000030  6008              STR      r0,[r1,#0]            ;2030
000032  6820              LDR      r0,[r4,#0]            ;2033
000034  6800              LDR      r0,[r0,#0]            ;2033
000036  4328              ORRS     r0,r0,r5              ;2033
000038  6821              LDR      r1,[r4,#0]            ;2033
00003a  6008              STR      r0,[r1,#0]            ;2033
00003c  2001              MOVS     r0,#1                 ;2036
00003e  63e0              STR      r0,[r4,#0x3c]         ;2036
000040  2000              MOVS     r0,#0                 ;2038
000042  e7e2              B        |L62.10|
;;;2040   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_MspDeInit PROC
;;;2090     */
;;;2091   __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2092   {
;;;2093     /* Prevent unused argument(s) compilation warning */
;;;2094     UNUSED(htim);
;;;2095    
;;;2096     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2097               the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
;;;2098      */
;;;2099   }
;;;2100   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_MspInit PROC
;;;2074     */
;;;2075   __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2076   {
;;;2077     /* Prevent unused argument(s) compilation warning */
;;;2078     UNUSED(htim);
;;;2079    
;;;2080     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2081               the HAL_TIM_OnePulse_MspInit could be implemented in the user file
;;;2082      */
;;;2083   }
;;;2084   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Start PROC
;;;2110     */
;;;2111   HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b530              PUSH     {r4,r5,lr}
;;;2112   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2113     /* Enable the Capture compare and the Input Capture channels 
;;;2114       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2115       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2116       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2117       in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
;;;2118       
;;;2119       No need to enable the counter, it's enabled automatically by hardware 
;;;2120       (the counter starts in response to a stimulus and generate a pulse */
;;;2121     
;;;2122     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
000006  2201              MOVS     r2,#1
000008  2100              MOVS     r1,#0
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2123     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
000010  2201              MOVS     r2,#1
000012  2104              MOVS     r1,#4
000014  6820              LDR      r0,[r4,#0]
000016  f7fffffe          BL       TIM_CCxChannelCmd
;;;2124     
;;;2125     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00001a  490a              LDR      r1,|L65.68|
00001c  6820              LDR      r0,[r4,#0]
00001e  4288              CMP      r0,r1
000020  d003              BEQ      |L65.42|
000022  4909              LDR      r1,|L65.72|
000024  6820              LDR      r0,[r4,#0]
000026  4288              CMP      r0,r1
000028  d101              BNE      |L65.46|
                  |L65.42|
00002a  2001              MOVS     r0,#1
00002c  e000              B        |L65.48|
                  |L65.46|
00002e  2000              MOVS     r0,#0
                  |L65.48|
000030  b128              CBZ      r0,|L65.62|
;;;2126     {
;;;2127       /* Enable the main output */
;;;2128       __HAL_TIM_MOE_ENABLE(htim);
000032  6820              LDR      r0,[r4,#0]
000034  6c40              LDR      r0,[r0,#0x44]
000036  f4404000          ORR      r0,r0,#0x8000
00003a  6821              LDR      r1,[r4,#0]
00003c  6448              STR      r0,[r1,#0x44]
                  |L65.62|
;;;2129     }
;;;2130     
;;;2131     /* Return function status */
;;;2132     return HAL_OK;
00003e  2000              MOVS     r0,#0
;;;2133   }
000040  bd30              POP      {r4,r5,pc}
;;;2134   
                          ENDP

000042  0000              DCW      0x0000
                  |L65.68|
                          DCD      0x40010000
                  |L65.72|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OnePulse_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Start_IT PROC
;;;2178     */
;;;2179   HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b530              PUSH     {r4,r5,lr}
;;;2180   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2181     /* Enable the Capture compare and the Input Capture channels 
;;;2182       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2183       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2184       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2185       in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
;;;2186       
;;;2187       No need to enable the counter, it's enabled automatically by hardware 
;;;2188       (the counter starts in response to a stimulus and generate a pulse */
;;;2189    
;;;2190     /* Enable the TIM Capture/Compare 1 interrupt */
;;;2191     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000006  6820              LDR      r0,[r4,#0]
000008  68c0              LDR      r0,[r0,#0xc]
00000a  f0400002          ORR      r0,r0,#2
00000e  6821              LDR      r1,[r4,#0]
000010  60c8              STR      r0,[r1,#0xc]
;;;2192     
;;;2193     /* Enable the TIM Capture/Compare 2 interrupt */
;;;2194     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000012  6820              LDR      r0,[r4,#0]
000014  68c0              LDR      r0,[r0,#0xc]
000016  f0400004          ORR      r0,r0,#4
00001a  6821              LDR      r1,[r4,#0]
00001c  60c8              STR      r0,[r1,#0xc]
;;;2195     
;;;2196     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
00001e  2201              MOVS     r2,#1
000020  2100              MOVS     r1,#0
000022  6820              LDR      r0,[r4,#0]
000024  f7fffffe          BL       TIM_CCxChannelCmd
;;;2197     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
000028  2201              MOVS     r2,#1
00002a  2104              MOVS     r1,#4
00002c  6820              LDR      r0,[r4,#0]
00002e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2198     
;;;2199     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000032  490a              LDR      r1,|L66.92|
000034  6820              LDR      r0,[r4,#0]
000036  4288              CMP      r0,r1
000038  d003              BEQ      |L66.66|
00003a  4909              LDR      r1,|L66.96|
00003c  6820              LDR      r0,[r4,#0]
00003e  4288              CMP      r0,r1
000040  d101              BNE      |L66.70|
                  |L66.66|
000042  2001              MOVS     r0,#1
000044  e000              B        |L66.72|
                  |L66.70|
000046  2000              MOVS     r0,#0
                  |L66.72|
000048  b128              CBZ      r0,|L66.86|
;;;2200     {
;;;2201       /* Enable the main output */
;;;2202       __HAL_TIM_MOE_ENABLE(htim);
00004a  6820              LDR      r0,[r4,#0]
00004c  6c40              LDR      r0,[r0,#0x44]
00004e  f4404000          ORR      r0,r0,#0x8000
000052  6821              LDR      r1,[r4,#0]
000054  6448              STR      r0,[r1,#0x44]
                  |L66.86|
;;;2203     }
;;;2204     
;;;2205     /* Return function status */
;;;2206     return HAL_OK;
000056  2000              MOVS     r0,#0
;;;2207   }
000058  bd30              POP      {r4,r5,pc}
;;;2208   
                          ENDP

00005a  0000              DCW      0x0000
                  |L66.92|
                          DCD      0x40010000
                  |L66.96|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OnePulse_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Stop PROC
;;;2144     */
;;;2145   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b530              PUSH     {r4,r5,lr}
;;;2146   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2147     /* Disable the Capture compare and the Input Capture channels 
;;;2148     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2149     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2150     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2151     in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
;;;2152     
;;;2153     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
000006  2200              MOVS     r2,#0
000008  4611              MOV      r1,r2
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2154     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
000010  2200              MOVS     r2,#0
000012  2104              MOVS     r1,#4
000014  6820              LDR      r0,[r4,#0]
000016  f7fffffe          BL       TIM_CCxChannelCmd
;;;2155       
;;;2156     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00001a  491a              LDR      r1,|L67.132|
00001c  6820              LDR      r0,[r4,#0]
00001e  4288              CMP      r0,r1
000020  d003              BEQ      |L67.42|
000022  4919              LDR      r1,|L67.136|
000024  6820              LDR      r0,[r4,#0]
000026  4288              CMP      r0,r1
000028  d101              BNE      |L67.46|
                  |L67.42|
00002a  2001              MOVS     r0,#1
00002c  e000              B        |L67.48|
                  |L67.46|
00002e  2000              MOVS     r0,#0
                  |L67.48|
000030  b190              CBZ      r0,|L67.88|
;;;2157     {
;;;2158       /* Disable the Main Output */
;;;2159       __HAL_TIM_MOE_DISABLE(htim);
000032  bf00              NOP      
000034  6820              LDR      r0,[r4,#0]
000036  6a00              LDR      r0,[r0,#0x20]
000038  f2411111          MOV      r1,#0x1111
00003c  4008              ANDS     r0,r0,r1
00003e  b950              CBNZ     r0,|L67.86|
000040  6820              LDR      r0,[r4,#0]
000042  6a00              LDR      r0,[r0,#0x20]
000044  1089              ASRS     r1,r1,#2
000046  4008              ANDS     r0,r0,r1
000048  b928              CBNZ     r0,|L67.86|
00004a  6820              LDR      r0,[r4,#0]
00004c  6c40              LDR      r0,[r0,#0x44]
00004e  f4204000          BIC      r0,r0,#0x8000
000052  6821              LDR      r1,[r4,#0]
000054  6448              STR      r0,[r1,#0x44]
                  |L67.86|
000056  bf00              NOP      
                  |L67.88|
;;;2160     }
;;;2161       
;;;2162     /* Disable the Peripheral */
;;;2163     __HAL_TIM_DISABLE(htim); 
000058  bf00              NOP      
00005a  6820              LDR      r0,[r4,#0]
00005c  6a00              LDR      r0,[r0,#0x20]
00005e  f2411111          MOV      r1,#0x1111
000062  4008              ANDS     r0,r0,r1
000064  b950              CBNZ     r0,|L67.124|
000066  6820              LDR      r0,[r4,#0]
000068  6a00              LDR      r0,[r0,#0x20]
00006a  1089              ASRS     r1,r1,#2
00006c  4008              ANDS     r0,r0,r1
00006e  b928              CBNZ     r0,|L67.124|
000070  6820              LDR      r0,[r4,#0]
000072  6800              LDR      r0,[r0,#0]
000074  f0200001          BIC      r0,r0,#1
000078  6821              LDR      r1,[r4,#0]
00007a  6008              STR      r0,[r1,#0]
                  |L67.124|
00007c  bf00              NOP      
;;;2164     
;;;2165     /* Return function status */
;;;2166     return HAL_OK;
00007e  2000              MOVS     r0,#0
;;;2167   }
000080  bd30              POP      {r4,r5,pc}
;;;2168   
                          ENDP

000082  0000              DCW      0x0000
                  |L67.132|
                          DCD      0x40010000
                  |L67.136|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OnePulse_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Stop_IT PROC
;;;2218     */
;;;2219   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b530              PUSH     {r4,r5,lr}
;;;2220   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2221     /* Disable the TIM Capture/Compare 1 interrupt */
;;;2222     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);  
000006  6820              LDR      r0,[r4,#0]
000008  68c0              LDR      r0,[r0,#0xc]
00000a  f0200002          BIC      r0,r0,#2
00000e  6821              LDR      r1,[r4,#0]
000010  60c8              STR      r0,[r1,#0xc]
;;;2223     
;;;2224     /* Disable the TIM Capture/Compare 2 interrupt */
;;;2225     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000012  6820              LDR      r0,[r4,#0]
000014  68c0              LDR      r0,[r0,#0xc]
000016  f0200004          BIC      r0,r0,#4
00001a  6821              LDR      r1,[r4,#0]
00001c  60c8              STR      r0,[r1,#0xc]
;;;2226     
;;;2227     /* Disable the Capture compare and the Input Capture channels 
;;;2228     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2229     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2230     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2231     in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */  
;;;2232     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
00001e  2200              MOVS     r2,#0
000020  4611              MOV      r1,r2
000022  6820              LDR      r0,[r4,#0]
000024  f7fffffe          BL       TIM_CCxChannelCmd
;;;2233     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
000028  2200              MOVS     r2,#0
00002a  2104              MOVS     r1,#4
00002c  6820              LDR      r0,[r4,#0]
00002e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2234       
;;;2235     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000032  491a              LDR      r1,|L68.156|
000034  6820              LDR      r0,[r4,#0]
000036  4288              CMP      r0,r1
000038  d003              BEQ      |L68.66|
00003a  4919              LDR      r1,|L68.160|
00003c  6820              LDR      r0,[r4,#0]
00003e  4288              CMP      r0,r1
000040  d101              BNE      |L68.70|
                  |L68.66|
000042  2001              MOVS     r0,#1
000044  e000              B        |L68.72|
                  |L68.70|
000046  2000              MOVS     r0,#0
                  |L68.72|
000048  b190              CBZ      r0,|L68.112|
;;;2236     {
;;;2237       /* Disable the Main Output */
;;;2238       __HAL_TIM_MOE_DISABLE(htim);
00004a  bf00              NOP      
00004c  6820              LDR      r0,[r4,#0]
00004e  6a00              LDR      r0,[r0,#0x20]
000050  f2411111          MOV      r1,#0x1111
000054  4008              ANDS     r0,r0,r1
000056  b950              CBNZ     r0,|L68.110|
000058  6820              LDR      r0,[r4,#0]
00005a  6a00              LDR      r0,[r0,#0x20]
00005c  1089              ASRS     r1,r1,#2
00005e  4008              ANDS     r0,r0,r1
000060  b928              CBNZ     r0,|L68.110|
000062  6820              LDR      r0,[r4,#0]
000064  6c40              LDR      r0,[r0,#0x44]
000066  f4204000          BIC      r0,r0,#0x8000
00006a  6821              LDR      r1,[r4,#0]
00006c  6448              STR      r0,[r1,#0x44]
                  |L68.110|
00006e  bf00              NOP      
                  |L68.112|
;;;2239     }
;;;2240       
;;;2241     /* Disable the Peripheral */
;;;2242      __HAL_TIM_DISABLE(htim);  
000070  bf00              NOP      
000072  6820              LDR      r0,[r4,#0]
000074  6a00              LDR      r0,[r0,#0x20]
000076  f2411111          MOV      r1,#0x1111
00007a  4008              ANDS     r0,r0,r1
00007c  b950              CBNZ     r0,|L68.148|
00007e  6820              LDR      r0,[r4,#0]
000080  6a00              LDR      r0,[r0,#0x20]
000082  1089              ASRS     r1,r1,#2
000084  4008              ANDS     r0,r0,r1
000086  b928              CBNZ     r0,|L68.148|
000088  6820              LDR      r0,[r4,#0]
00008a  6800              LDR      r0,[r0,#0]
00008c  f0200001          BIC      r0,r0,#1
000090  6821              LDR      r1,[r4,#0]
000092  6008              STR      r0,[r1,#0]
                  |L68.148|
000094  bf00              NOP      
;;;2243     
;;;2244     /* Return function status */
;;;2245     return HAL_OK;
000096  2000              MOVS     r0,#0
;;;2246   }
000098  bd30              POP      {r4,r5,pc}
;;;2247   
                          ENDP

00009a  0000              DCW      0x0000
                  |L68.156|
                          DCD      0x40010000
                  |L68.160|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PWM_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_ConfigChannel PROC
;;;3147     */
;;;3148   __weak HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;3149   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;3150     __HAL_LOCK(htim);
000008  bf00              NOP      
00000a  6ba0              LDR      r0,[r4,#0x38]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L69.20|
000010  2002              MOVS     r0,#2
                  |L69.18|
;;;3151     
;;;3152     /* Check the parameters */ 
;;;3153     assert_param(IS_TIM_CHANNELS(Channel)); 
;;;3154     assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
;;;3155     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;3156     assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode)); 
;;;3157     
;;;3158     htim->State = HAL_TIM_STATE_BUSY;
;;;3159       
;;;3160     switch (Channel)
;;;3161     {
;;;3162       case TIM_CHANNEL_1:
;;;3163       {
;;;3164         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3165         /* Configure the Channel 1 in PWM mode */
;;;3166         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;3167         
;;;3168         /* Set the Preload enable bit for channel1 */
;;;3169         htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
;;;3170         
;;;3171         /* Configure the Output Fast mode */
;;;3172         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
;;;3173         htim->Instance->CCMR1 |= sConfig->OCFastMode;
;;;3174       }
;;;3175       break;
;;;3176       
;;;3177       case TIM_CHANNEL_2:
;;;3178       {
;;;3179         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3180         /* Configure the Channel 2 in PWM mode */
;;;3181         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;3182         
;;;3183         /* Set the Preload enable bit for channel2 */
;;;3184         htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
;;;3185         
;;;3186         /* Configure the Output Fast mode */
;;;3187         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
;;;3188         htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
;;;3189       }
;;;3190       break;
;;;3191       
;;;3192       case TIM_CHANNEL_3:
;;;3193       {
;;;3194         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3195         /* Configure the Channel 3 in PWM mode */
;;;3196         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;3197         
;;;3198         /* Set the Preload enable bit for channel3 */
;;;3199         htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
;;;3200         
;;;3201        /* Configure the Output Fast mode */
;;;3202         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
;;;3203         htim->Instance->CCMR2 |= sConfig->OCFastMode;  
;;;3204       }
;;;3205       break;
;;;3206       
;;;3207       case TIM_CHANNEL_4:
;;;3208       {
;;;3209         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3210         /* Configure the Channel 4 in PWM mode */
;;;3211         TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;3212         
;;;3213         /* Set the Preload enable bit for channel4 */
;;;3214         htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
;;;3215         
;;;3216        /* Configure the Output Fast mode */
;;;3217         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
;;;3218         htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;  
;;;3219       }
;;;3220       break;
;;;3221       
;;;3222       default:
;;;3223       break;    
;;;3224     }
;;;3225     
;;;3226     htim->State = HAL_TIM_STATE_READY;
;;;3227       
;;;3228     __HAL_UNLOCK(htim);
;;;3229     
;;;3230     return HAL_OK;
;;;3231   }
000012  bd70              POP      {r4-r6,pc}
                  |L69.20|
000014  2001              MOVS     r0,#1                 ;3150
000016  63a0              STR      r0,[r4,#0x38]         ;3150
000018  bf00              NOP                            ;3150
00001a  2002              MOVS     r0,#2                 ;3158
00001c  63e0              STR      r0,[r4,#0x3c]         ;3158
00001e  b136              CBZ      r6,|L69.46|
000020  2e04              CMP      r6,#4                 ;3160
000022  d01b              BEQ      |L69.92|
000024  2e08              CMP      r6,#8                 ;3160
000026  d031              BEQ      |L69.140|
000028  2e0c              CMP      r6,#0xc               ;3160
00002a  d15e              BNE      |L69.234|
00002c  e045              B        |L69.186|
                  |L69.46|
00002e  4629              MOV      r1,r5                 ;3166
000030  6820              LDR      r0,[r4,#0]            ;3166
000032  f7fffffe          BL       TIM_OC1_SetConfig
000036  6820              LDR      r0,[r4,#0]            ;3169
000038  6980              LDR      r0,[r0,#0x18]         ;3169
00003a  f0400008          ORR      r0,r0,#8              ;3169
00003e  6821              LDR      r1,[r4,#0]            ;3169
000040  6188              STR      r0,[r1,#0x18]         ;3169
000042  6820              LDR      r0,[r4,#0]            ;3172
000044  6980              LDR      r0,[r0,#0x18]         ;3172
000046  f0200004          BIC      r0,r0,#4              ;3172
00004a  6821              LDR      r1,[r4,#0]            ;3172
00004c  6188              STR      r0,[r1,#0x18]         ;3172
00004e  6820              LDR      r0,[r4,#0]            ;3173
000050  6980              LDR      r0,[r0,#0x18]         ;3173
000052  6929              LDR      r1,[r5,#0x10]         ;3173
000054  4308              ORRS     r0,r0,r1              ;3173
000056  6821              LDR      r1,[r4,#0]            ;3173
000058  6188              STR      r0,[r1,#0x18]         ;3173
00005a  e047              B        |L69.236|
                  |L69.92|
00005c  4629              MOV      r1,r5                 ;3181
00005e  6820              LDR      r0,[r4,#0]            ;3181
000060  f7fffffe          BL       TIM_OC2_SetConfig
000064  6820              LDR      r0,[r4,#0]            ;3184
000066  6980              LDR      r0,[r0,#0x18]         ;3184
000068  f4406000          ORR      r0,r0,#0x800          ;3184
00006c  6821              LDR      r1,[r4,#0]            ;3184
00006e  6188              STR      r0,[r1,#0x18]         ;3184
000070  6820              LDR      r0,[r4,#0]            ;3187
000072  6980              LDR      r0,[r0,#0x18]         ;3187
000074  f4206080          BIC      r0,r0,#0x400          ;3187
000078  6821              LDR      r1,[r4,#0]            ;3187
00007a  6188              STR      r0,[r1,#0x18]         ;3187
00007c  6820              LDR      r0,[r4,#0]            ;3188
00007e  6980              LDR      r0,[r0,#0x18]         ;3188
000080  6929              LDR      r1,[r5,#0x10]         ;3188
000082  ea402001          ORR      r0,r0,r1,LSL #8       ;3188
000086  6821              LDR      r1,[r4,#0]            ;3188
000088  6188              STR      r0,[r1,#0x18]         ;3188
00008a  e02f              B        |L69.236|
                  |L69.140|
00008c  4629              MOV      r1,r5                 ;3196
00008e  6820              LDR      r0,[r4,#0]            ;3196
000090  f7fffffe          BL       TIM_OC3_SetConfig
000094  6820              LDR      r0,[r4,#0]            ;3199
000096  69c0              LDR      r0,[r0,#0x1c]         ;3199
000098  f0400008          ORR      r0,r0,#8              ;3199
00009c  6821              LDR      r1,[r4,#0]            ;3199
00009e  61c8              STR      r0,[r1,#0x1c]         ;3199
0000a0  6820              LDR      r0,[r4,#0]            ;3202
0000a2  69c0              LDR      r0,[r0,#0x1c]         ;3202
0000a4  f0200004          BIC      r0,r0,#4              ;3202
0000a8  6821              LDR      r1,[r4,#0]            ;3202
0000aa  61c8              STR      r0,[r1,#0x1c]         ;3202
0000ac  6820              LDR      r0,[r4,#0]            ;3203
0000ae  69c0              LDR      r0,[r0,#0x1c]         ;3203
0000b0  6929              LDR      r1,[r5,#0x10]         ;3203
0000b2  4308              ORRS     r0,r0,r1              ;3203
0000b4  6821              LDR      r1,[r4,#0]            ;3203
0000b6  61c8              STR      r0,[r1,#0x1c]         ;3203
0000b8  e018              B        |L69.236|
                  |L69.186|
0000ba  4629              MOV      r1,r5                 ;3211
0000bc  6820              LDR      r0,[r4,#0]            ;3211
0000be  f7fffffe          BL       TIM_OC4_SetConfig
0000c2  6820              LDR      r0,[r4,#0]            ;3214
0000c4  69c0              LDR      r0,[r0,#0x1c]         ;3214
0000c6  f4406000          ORR      r0,r0,#0x800          ;3214
0000ca  6821              LDR      r1,[r4,#0]            ;3214
0000cc  61c8              STR      r0,[r1,#0x1c]         ;3214
0000ce  6820              LDR      r0,[r4,#0]            ;3217
0000d0  69c0              LDR      r0,[r0,#0x1c]         ;3217
0000d2  f4206080          BIC      r0,r0,#0x400          ;3217
0000d6  6821              LDR      r1,[r4,#0]            ;3217
0000d8  61c8              STR      r0,[r1,#0x1c]         ;3217
0000da  6820              LDR      r0,[r4,#0]            ;3218
0000dc  69c0              LDR      r0,[r0,#0x1c]         ;3218
0000de  6929              LDR      r1,[r5,#0x10]         ;3218
0000e0  ea402001          ORR      r0,r0,r1,LSL #8       ;3218
0000e4  6821              LDR      r1,[r4,#0]            ;3218
0000e6  61c8              STR      r0,[r1,#0x1c]         ;3218
0000e8  e000              B        |L69.236|
                  |L69.234|
0000ea  bf00              NOP                            ;3223
                  |L69.236|
0000ec  bf00              NOP                            ;3175
0000ee  2001              MOVS     r0,#1                 ;3226
0000f0  63e0              STR      r0,[r4,#0x3c]         ;3226
0000f2  bf00              NOP                            ;3228
0000f4  2000              MOVS     r0,#0                 ;3228
0000f6  63a0              STR      r0,[r4,#0x38]         ;3228
0000f8  bf00              NOP                            ;3228
0000fa  bf00              NOP                            ;3230
0000fc  e789              B        |L69.18|
;;;3232   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_DeInit PROC
;;;1037     */
;;;1038   HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1039   {
000002  4604              MOV      r4,r0
;;;1040     /* Check the parameters */
;;;1041     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1042     
;;;1043     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  63e0              STR      r0,[r4,#0x3c]
;;;1044     
;;;1045     /* Disable the TIM Peripheral Clock */
;;;1046     __HAL_TIM_DISABLE(htim);
000008  bf00              NOP      
00000a  6820              LDR      r0,[r4,#0]
00000c  6a00              LDR      r0,[r0,#0x20]
00000e  f2411111          MOV      r1,#0x1111
000012  4008              ANDS     r0,r0,r1
000014  b950              CBNZ     r0,|L70.44|
000016  6820              LDR      r0,[r4,#0]
000018  6a00              LDR      r0,[r0,#0x20]
00001a  1089              ASRS     r1,r1,#2
00001c  4008              ANDS     r0,r0,r1
00001e  b928              CBNZ     r0,|L70.44|
000020  6820              LDR      r0,[r4,#0]
000022  6800              LDR      r0,[r0,#0]
000024  f0200001          BIC      r0,r0,#1
000028  6821              LDR      r1,[r4,#0]
00002a  6008              STR      r0,[r1,#0]
                  |L70.44|
00002c  bf00              NOP      
;;;1047       
;;;1048     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;1049     HAL_TIM_PWM_MspDeInit(htim);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       HAL_TIM_PWM_MspDeInit
;;;1050       
;;;1051     /* Change TIM state */  
;;;1052     htim->State = HAL_TIM_STATE_RESET; 
000034  2000              MOVS     r0,#0
000036  63e0              STR      r0,[r4,#0x3c]
;;;1053   
;;;1054     /* Release Lock */
;;;1055     __HAL_UNLOCK(htim);
000038  bf00              NOP      
00003a  63a0              STR      r0,[r4,#0x38]
00003c  bf00              NOP      
;;;1056   
;;;1057     return HAL_OK;
;;;1058   }
00003e  bd10              POP      {r4,pc}
;;;1059   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_GetState PROC
;;;4558     */
;;;4559   HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;4560   {
;;;4561     return htim->State;
000002  6bc8              LDR      r0,[r1,#0x3c]
;;;4562   }
000004  4770              BX       lr
;;;4563   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_Init PROC
;;;998      */
;;;999    HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1000   {
000002  4604              MOV      r4,r0
;;;1001     /* Check the TIM handle allocation */
;;;1002     if(htim == NULL)
000004  b90c              CBNZ     r4,|L72.10|
;;;1003     {
;;;1004       return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L72.8|
;;;1005     }
;;;1006   
;;;1007     /* Check the parameters */
;;;1008     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1009     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1010     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;1011   
;;;1012     if(htim->State == HAL_TIM_STATE_RESET)
;;;1013     {
;;;1014       /* Allocate lock resource and initialize it */
;;;1015       htim->Lock = HAL_UNLOCKED;  
;;;1016       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1017       HAL_TIM_PWM_MspInit(htim);
;;;1018     }
;;;1019   
;;;1020     /* Set the TIM state */
;;;1021     htim->State= HAL_TIM_STATE_BUSY;  
;;;1022     
;;;1023     /* Init the base time for the PWM */  
;;;1024     TIM_Base_SetConfig(htim->Instance, &htim->Init); 
;;;1025      
;;;1026     /* Initialize the TIM state*/
;;;1027     htim->State= HAL_TIM_STATE_READY;
;;;1028     
;;;1029     return HAL_OK;
;;;1030   }  
000008  bd10              POP      {r4,pc}
                  |L72.10|
00000a  6be0              LDR      r0,[r4,#0x3c]         ;1012
00000c  b920              CBNZ     r0,|L72.24|
00000e  2000              MOVS     r0,#0                 ;1015
000010  63a0              STR      r0,[r4,#0x38]         ;1015
000012  4620              MOV      r0,r4                 ;1017
000014  f7fffffe          BL       HAL_TIM_PWM_MspInit
                  |L72.24|
000018  2002              MOVS     r0,#2                 ;1021
00001a  63e0              STR      r0,[r4,#0x3c]         ;1021
00001c  1d21              ADDS     r1,r4,#4              ;1024
00001e  6820              LDR      r0,[r4,#0]            ;1024
000020  f7fffffe          BL       TIM_Base_SetConfig
000024  2001              MOVS     r0,#1                 ;1027
000026  63e0              STR      r0,[r4,#0x3c]         ;1027
000028  2000              MOVS     r0,#0                 ;1029
00002a  e7ed              B        |L72.8|
;;;1031   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_MspDeInit PROC
;;;1081     */
;;;1082   __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1083   {
;;;1084     /* Prevent unused argument(s) compilation warning */
;;;1085     UNUSED(htim);
;;;1086    
;;;1087     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1088               the HAL_TIM_PWM_MspDeInit could be implemented in the user file
;;;1089      */
;;;1090   }
;;;1091   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_MspInit PROC
;;;1065     */
;;;1066   __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1067   {
;;;1068     /* Prevent unused argument(s) compilation warning */
;;;1069     UNUSED(htim);
;;;1070    
;;;1071     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1072               the HAL_TIM_PWM_MspInit could be implemented in the user file
;;;1073      */
;;;1074   }
;;;1075   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_PulseFinishedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_PulseFinishedCallback PROC
;;;4469     */
;;;4470   __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4471   {
;;;4472     /* Prevent unused argument(s) compilation warning */
;;;4473     UNUSED(htim);
;;;4474    
;;;4475     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4476               the __HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
;;;4477      */
;;;4478   }
;;;4479   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start PROC
;;;1103     */
;;;1104   HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1105   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1106     /* Check the parameters */
;;;1107     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1108   
;;;1109     /* Enable the Capture compare channel */
;;;1110     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000006  2201              MOVS     r2,#1
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;1111     
;;;1112     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000010  490c              LDR      r1,|L76.68|
000012  6820              LDR      r0,[r4,#0]
000014  4288              CMP      r0,r1
000016  d003              BEQ      |L76.32|
000018  490b              LDR      r1,|L76.72|
00001a  6820              LDR      r0,[r4,#0]
00001c  4288              CMP      r0,r1
00001e  d101              BNE      |L76.36|
                  |L76.32|
000020  2001              MOVS     r0,#1
000022  e000              B        |L76.38|
                  |L76.36|
000024  2000              MOVS     r0,#0
                  |L76.38|
000026  b128              CBZ      r0,|L76.52|
;;;1113     {
;;;1114       /* Enable the main output */
;;;1115       __HAL_TIM_MOE_ENABLE(htim);
000028  6820              LDR      r0,[r4,#0]
00002a  6c40              LDR      r0,[r0,#0x44]
00002c  f4404000          ORR      r0,r0,#0x8000
000030  6821              LDR      r1,[r4,#0]
000032  6448              STR      r0,[r1,#0x44]
                  |L76.52|
;;;1116     }
;;;1117       
;;;1118     /* Enable the Peripheral */
;;;1119     __HAL_TIM_ENABLE(htim);
000034  6820              LDR      r0,[r4,#0]
000036  6800              LDR      r0,[r0,#0]
000038  f0400001          ORR      r0,r0,#1
00003c  6821              LDR      r1,[r4,#0]
00003e  6008              STR      r0,[r1,#0]
;;;1120     
;;;1121     /* Return function status */
;;;1122     return HAL_OK;
000040  2000              MOVS     r0,#0
;;;1123   } 
000042  bd30              POP      {r4,r5,pc}
;;;1124   
                          ENDP

                  |L76.68|
                          DCD      0x40010000
                  |L76.72|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PWM_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start_DMA PROC
;;;1308     */
;;;1309   HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1310   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
;;;1311     /* Check the parameters */
;;;1312     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1313     
;;;1314     if((htim->State == HAL_TIM_STATE_BUSY))
00000c  6be0              LDR      r0,[r4,#0x3c]
00000e  2802              CMP      r0,#2
000010  d101              BNE      |L77.22|
                  |L77.18|
;;;1315     {
;;;1316        return HAL_BUSY;
;;;1317     }
;;;1318     else if((htim->State == HAL_TIM_STATE_READY))
;;;1319     {
;;;1320       if(((uint32_t)pData == 0 ) && (Length > 0)) 
;;;1321       {
;;;1322         return HAL_ERROR;                                    
;;;1323       }
;;;1324       else
;;;1325       {
;;;1326         htim->State = HAL_TIM_STATE_BUSY;
;;;1327       }
;;;1328     }    
;;;1329     switch (Channel)
;;;1330     {
;;;1331       case TIM_CHANNEL_1:
;;;1332       {      
;;;1333         /* Set the DMA Period elapsed callback */
;;;1334         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;1335        
;;;1336         /* Set the DMA error callback */
;;;1337         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1338         
;;;1339         /* Enable the DMA Stream */
;;;1340         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;1341         
;;;1342         /* Enable the TIM Capture/Compare 1 DMA request */
;;;1343         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1344       }
;;;1345       break;
;;;1346       
;;;1347       case TIM_CHANNEL_2:
;;;1348       {
;;;1349         /* Set the DMA Period elapsed callback */
;;;1350         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;1351        
;;;1352         /* Set the DMA error callback */
;;;1353         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1354         
;;;1355         /* Enable the DMA Stream */
;;;1356         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;1357         
;;;1358         /* Enable the TIM Capture/Compare 2 DMA request */
;;;1359         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1360       }
;;;1361       break;
;;;1362       
;;;1363       case TIM_CHANNEL_3:
;;;1364       {
;;;1365         /* Set the DMA Period elapsed callback */
;;;1366         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;1367        
;;;1368         /* Set the DMA error callback */
;;;1369         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1370         
;;;1371         /* Enable the DMA Stream */
;;;1372         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;1373         
;;;1374         /* Enable the TIM Output Capture/Compare 3 request */
;;;1375         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1376       }
;;;1377       break;
;;;1378       
;;;1379       case TIM_CHANNEL_4:
;;;1380       {
;;;1381        /* Set the DMA Period elapsed callback */
;;;1382         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;1383        
;;;1384         /* Set the DMA error callback */
;;;1385         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1386         
;;;1387         /* Enable the DMA Stream */
;;;1388         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;1389         
;;;1390         /* Enable the TIM Capture/Compare 4 DMA request */
;;;1391         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1392       }
;;;1393       break;
;;;1394       
;;;1395       default:
;;;1396       break;
;;;1397     }
;;;1398   
;;;1399     /* Enable the Capture compare channel */
;;;1400     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1401       
;;;1402     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
;;;1403     {
;;;1404       /* Enable the main output */
;;;1405       __HAL_TIM_MOE_ENABLE(htim);
;;;1406     }
;;;1407     
;;;1408     /* Enable the Peripheral */
;;;1409     __HAL_TIM_ENABLE(htim); 
;;;1410     
;;;1411     /* Return function status */
;;;1412     return HAL_OK;
;;;1413   }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L77.22|
000016  6be0              LDR      r0,[r4,#0x3c]         ;1318
000018  2801              CMP      r0,#1                 ;1318
00001a  d105              BNE      |L77.40|
00001c  b915              CBNZ     r5,|L77.36|
00001e  2f00              CMP      r7,#0                 ;1320
000020  dd00              BLE      |L77.36|
000022  e7f6              B        |L77.18|
                  |L77.36|
000024  2002              MOVS     r0,#2                 ;1326
000026  63e0              STR      r0,[r4,#0x3c]         ;1326
                  |L77.40|
000028  b136              CBZ      r6,|L77.56|
00002a  2e04              CMP      r6,#4                 ;1329
00002c  d019              BEQ      |L77.98|
00002e  2e08              CMP      r6,#8                 ;1329
000030  d02c              BEQ      |L77.140|
000032  2e0c              CMP      r6,#0xc               ;1329
000034  d154              BNE      |L77.224|
000036  e03e              B        |L77.182|
                  |L77.56|
000038  493a              LDR      r1,|L77.292|
00003a  6a20              LDR      r0,[r4,#0x20]         ;1334
00003c  6401              STR      r1,[r0,#0x40]         ;1334
00003e  493a              LDR      r1,|L77.296|
000040  6a20              LDR      r0,[r4,#0x20]         ;1337
000042  6501              STR      r1,[r0,#0x50]         ;1337
000044  6821              LDR      r1,[r4,#0]            ;1340
000046  f1010234          ADD      r2,r1,#0x34           ;1340
00004a  463b              MOV      r3,r7                 ;1340
00004c  4629              MOV      r1,r5                 ;1340
00004e  6a20              LDR      r0,[r4,#0x20]         ;1340
000050  f7fffffe          BL       HAL_DMA_Start_IT
000054  6820              LDR      r0,[r4,#0]            ;1343
000056  68c0              LDR      r0,[r0,#0xc]          ;1343
000058  f4407000          ORR      r0,r0,#0x200          ;1343
00005c  6821              LDR      r1,[r4,#0]            ;1343
00005e  60c8              STR      r0,[r1,#0xc]          ;1343
000060  e03f              B        |L77.226|
                  |L77.98|
000062  4930              LDR      r1,|L77.292|
000064  6a60              LDR      r0,[r4,#0x24]         ;1350
000066  6401              STR      r1,[r0,#0x40]         ;1350
000068  492f              LDR      r1,|L77.296|
00006a  6a60              LDR      r0,[r4,#0x24]         ;1353
00006c  6501              STR      r1,[r0,#0x50]         ;1353
00006e  6821              LDR      r1,[r4,#0]            ;1356
000070  f1010238          ADD      r2,r1,#0x38           ;1356
000074  463b              MOV      r3,r7                 ;1356
000076  4629              MOV      r1,r5                 ;1356
000078  6a60              LDR      r0,[r4,#0x24]         ;1356
00007a  f7fffffe          BL       HAL_DMA_Start_IT
00007e  6820              LDR      r0,[r4,#0]            ;1359
000080  68c0              LDR      r0,[r0,#0xc]          ;1359
000082  f4406080          ORR      r0,r0,#0x400          ;1359
000086  6821              LDR      r1,[r4,#0]            ;1359
000088  60c8              STR      r0,[r1,#0xc]          ;1359
00008a  e02a              B        |L77.226|
                  |L77.140|
00008c  4925              LDR      r1,|L77.292|
00008e  6aa0              LDR      r0,[r4,#0x28]         ;1366
000090  6401              STR      r1,[r0,#0x40]         ;1366
000092  4925              LDR      r1,|L77.296|
000094  6aa0              LDR      r0,[r4,#0x28]         ;1369
000096  6501              STR      r1,[r0,#0x50]         ;1369
000098  6821              LDR      r1,[r4,#0]            ;1372
00009a  f101023c          ADD      r2,r1,#0x3c           ;1372
00009e  463b              MOV      r3,r7                 ;1372
0000a0  4629              MOV      r1,r5                 ;1372
0000a2  6aa0              LDR      r0,[r4,#0x28]         ;1372
0000a4  f7fffffe          BL       HAL_DMA_Start_IT
0000a8  6820              LDR      r0,[r4,#0]            ;1375
0000aa  68c0              LDR      r0,[r0,#0xc]          ;1375
0000ac  f4406000          ORR      r0,r0,#0x800          ;1375
0000b0  6821              LDR      r1,[r4,#0]            ;1375
0000b2  60c8              STR      r0,[r1,#0xc]          ;1375
0000b4  e015              B        |L77.226|
                  |L77.182|
0000b6  491b              LDR      r1,|L77.292|
0000b8  6ae0              LDR      r0,[r4,#0x2c]         ;1382
0000ba  6401              STR      r1,[r0,#0x40]         ;1382
0000bc  491a              LDR      r1,|L77.296|
0000be  6ae0              LDR      r0,[r4,#0x2c]         ;1385
0000c0  6501              STR      r1,[r0,#0x50]         ;1385
0000c2  6821              LDR      r1,[r4,#0]            ;1388
0000c4  f1010240          ADD      r2,r1,#0x40           ;1388
0000c8  463b              MOV      r3,r7                 ;1388
0000ca  4629              MOV      r1,r5                 ;1388
0000cc  6ae0              LDR      r0,[r4,#0x2c]         ;1388
0000ce  f7fffffe          BL       HAL_DMA_Start_IT
0000d2  6820              LDR      r0,[r4,#0]            ;1391
0000d4  68c0              LDR      r0,[r0,#0xc]          ;1391
0000d6  f4405080          ORR      r0,r0,#0x1000         ;1391
0000da  6821              LDR      r1,[r4,#0]            ;1391
0000dc  60c8              STR      r0,[r1,#0xc]          ;1391
0000de  e000              B        |L77.226|
                  |L77.224|
0000e0  bf00              NOP                            ;1396
                  |L77.226|
0000e2  bf00              NOP                            ;1345
0000e4  2201              MOVS     r2,#1                 ;1400
0000e6  4631              MOV      r1,r6                 ;1400
0000e8  6820              LDR      r0,[r4,#0]            ;1400
0000ea  f7fffffe          BL       TIM_CCxChannelCmd
0000ee  490f              LDR      r1,|L77.300|
0000f0  6820              LDR      r0,[r4,#0]            ;1402
0000f2  4288              CMP      r0,r1                 ;1402
0000f4  d003              BEQ      |L77.254|
0000f6  490e              LDR      r1,|L77.304|
0000f8  6820              LDR      r0,[r4,#0]            ;1402
0000fa  4288              CMP      r0,r1                 ;1402
0000fc  d101              BNE      |L77.258|
                  |L77.254|
0000fe  2001              MOVS     r0,#1                 ;1402
000100  e000              B        |L77.260|
                  |L77.258|
000102  2000              MOVS     r0,#0                 ;1402
                  |L77.260|
000104  b128              CBZ      r0,|L77.274|
000106  6820              LDR      r0,[r4,#0]            ;1405
000108  6c40              LDR      r0,[r0,#0x44]         ;1405
00010a  f4404000          ORR      r0,r0,#0x8000         ;1405
00010e  6821              LDR      r1,[r4,#0]            ;1405
000110  6448              STR      r0,[r1,#0x44]         ;1405
                  |L77.274|
000112  6820              LDR      r0,[r4,#0]            ;1409
000114  6800              LDR      r0,[r0,#0]            ;1409
000116  f0400001          ORR      r0,r0,#1              ;1409
00011a  6821              LDR      r1,[r4,#0]            ;1409
00011c  6008              STR      r0,[r1,#0]            ;1409
00011e  2000              MOVS     r0,#0                 ;1412
000120  e777              B        |L77.18|
;;;1414   
                          ENDP

000122  0000              DCW      0x0000
                  |L77.292|
                          DCD      TIM_DMADelayPulseCplt
                  |L77.296|
                          DCD      TIM_DMAError
                  |L77.300|
                          DCD      0x40010000
                  |L77.304|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PWM_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start_IT PROC
;;;1172     */
;;;1173   HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1174   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1175     /* Check the parameters */
;;;1176     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1177     
;;;1178     switch (Channel)
000006  b135              CBZ      r5,|L78.22|
000008  2d04              CMP      r5,#4
00000a  d00b              BEQ      |L78.36|
00000c  2d08              CMP      r5,#8
00000e  d010              BEQ      |L78.50|
000010  2d0c              CMP      r5,#0xc
000012  d11c              BNE      |L78.78|
000014  e014              B        |L78.64|
                  |L78.22|
;;;1179     {
;;;1180       case TIM_CHANNEL_1:
;;;1181       {       
;;;1182         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1183         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f0400002          ORR      r0,r0,#2
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;1184       }
;;;1185       break;
000022  e015              B        |L78.80|
                  |L78.36|
;;;1186       
;;;1187       case TIM_CHANNEL_2:
;;;1188       {
;;;1189         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1190         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f0400004          ORR      r0,r0,#4
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;1191       }
;;;1192       break;
000030  e00e              B        |L78.80|
                  |L78.50|
;;;1193       
;;;1194       case TIM_CHANNEL_3:
;;;1195       {
;;;1196         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1197         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  f0400008          ORR      r0,r0,#8
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;1198       }
;;;1199       break;
00003e  e007              B        |L78.80|
                  |L78.64|
;;;1200       
;;;1201       case TIM_CHANNEL_4:
;;;1202       {
;;;1203         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1204         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f0400010          ORR      r0,r0,#0x10
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;1205       }
;;;1206       break;
00004c  e000              B        |L78.80|
                  |L78.78|
;;;1207       
;;;1208       default:
;;;1209       break;
00004e  bf00              NOP      
                  |L78.80|
000050  bf00              NOP                            ;1185
;;;1210     } 
;;;1211     
;;;1212     /* Enable the Capture compare channel */
;;;1213     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000052  2201              MOVS     r2,#1
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;1214     
;;;1215     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00005c  490c              LDR      r1,|L78.144|
00005e  6820              LDR      r0,[r4,#0]
000060  4288              CMP      r0,r1
000062  d003              BEQ      |L78.108|
000064  490b              LDR      r1,|L78.148|
000066  6820              LDR      r0,[r4,#0]
000068  4288              CMP      r0,r1
00006a  d101              BNE      |L78.112|
                  |L78.108|
00006c  2001              MOVS     r0,#1
00006e  e000              B        |L78.114|
                  |L78.112|
000070  2000              MOVS     r0,#0
                  |L78.114|
000072  b128              CBZ      r0,|L78.128|
;;;1216     {
;;;1217       /* Enable the main output */
;;;1218       __HAL_TIM_MOE_ENABLE(htim);
000074  6820              LDR      r0,[r4,#0]
000076  6c40              LDR      r0,[r0,#0x44]
000078  f4404000          ORR      r0,r0,#0x8000
00007c  6821              LDR      r1,[r4,#0]
00007e  6448              STR      r0,[r1,#0x44]
                  |L78.128|
;;;1219     }
;;;1220   
;;;1221     /* Enable the Peripheral */
;;;1222     __HAL_TIM_ENABLE(htim);
000080  6820              LDR      r0,[r4,#0]
000082  6800              LDR      r0,[r0,#0]
000084  f0400001          ORR      r0,r0,#1
000088  6821              LDR      r1,[r4,#0]
00008a  6008              STR      r0,[r1,#0]
;;;1223     
;;;1224     /* Return function status */
;;;1225     return HAL_OK;
00008c  2000              MOVS     r0,#0
;;;1226   } 
00008e  bd30              POP      {r4,r5,pc}
;;;1227   
                          ENDP

                  |L78.144|
                          DCD      0x40010000
                  |L78.148|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PWM_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop PROC
;;;1136     */
;;;1137   HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1138   { 
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1139     /* Check the parameters */
;;;1140     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1141       
;;;1142     /* Disable the Capture compare channel */
;;;1143     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000006  2200              MOVS     r2,#0
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;1144     
;;;1145     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000010  491a              LDR      r1,|L79.124|
000012  6820              LDR      r0,[r4,#0]
000014  4288              CMP      r0,r1
000016  d003              BEQ      |L79.32|
000018  4919              LDR      r1,|L79.128|
00001a  6820              LDR      r0,[r4,#0]
00001c  4288              CMP      r0,r1
00001e  d101              BNE      |L79.36|
                  |L79.32|
000020  2001              MOVS     r0,#1
000022  e000              B        |L79.38|
                  |L79.36|
000024  2000              MOVS     r0,#0
                  |L79.38|
000026  b190              CBZ      r0,|L79.78|
;;;1146     {
;;;1147       /* Disable the Main Output */
;;;1148       __HAL_TIM_MOE_DISABLE(htim);
000028  bf00              NOP      
00002a  6820              LDR      r0,[r4,#0]
00002c  6a00              LDR      r0,[r0,#0x20]
00002e  f2411111          MOV      r1,#0x1111
000032  4008              ANDS     r0,r0,r1
000034  b950              CBNZ     r0,|L79.76|
000036  6820              LDR      r0,[r4,#0]
000038  6a00              LDR      r0,[r0,#0x20]
00003a  1089              ASRS     r1,r1,#2
00003c  4008              ANDS     r0,r0,r1
00003e  b928              CBNZ     r0,|L79.76|
000040  6820              LDR      r0,[r4,#0]
000042  6c40              LDR      r0,[r0,#0x44]
000044  f4204000          BIC      r0,r0,#0x8000
000048  6821              LDR      r1,[r4,#0]
00004a  6448              STR      r0,[r1,#0x44]
                  |L79.76|
00004c  bf00              NOP      
                  |L79.78|
;;;1149     }
;;;1150     
;;;1151     /* Disable the Peripheral */
;;;1152     __HAL_TIM_DISABLE(htim);
00004e  bf00              NOP      
000050  6820              LDR      r0,[r4,#0]
000052  6a00              LDR      r0,[r0,#0x20]
000054  f2411111          MOV      r1,#0x1111
000058  4008              ANDS     r0,r0,r1
00005a  b950              CBNZ     r0,|L79.114|
00005c  6820              LDR      r0,[r4,#0]
00005e  6a00              LDR      r0,[r0,#0x20]
000060  1089              ASRS     r1,r1,#2
000062  4008              ANDS     r0,r0,r1
000064  b928              CBNZ     r0,|L79.114|
000066  6820              LDR      r0,[r4,#0]
000068  6800              LDR      r0,[r0,#0]
00006a  f0200001          BIC      r0,r0,#1
00006e  6821              LDR      r1,[r4,#0]
000070  6008              STR      r0,[r1,#0]
                  |L79.114|
000072  bf00              NOP      
;;;1153     
;;;1154     /* Change the htim state */
;;;1155     htim->State = HAL_TIM_STATE_READY;
000074  2001              MOVS     r0,#1
000076  63e0              STR      r0,[r4,#0x3c]
;;;1156     
;;;1157     /* Return function status */
;;;1158     return HAL_OK;
000078  2000              MOVS     r0,#0
;;;1159   } 
00007a  bd30              POP      {r4,r5,pc}
;;;1160   
                          ENDP

                  |L79.124|
                          DCD      0x40010000
                  |L79.128|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PWM_Stop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop_DMA PROC
;;;1426     */
;;;1427   HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1428   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1429     /* Check the parameters */
;;;1430     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1431     
;;;1432     switch (Channel)
000006  b135              CBZ      r5,|L80.22|
000008  2d04              CMP      r5,#4
00000a  d00b              BEQ      |L80.36|
00000c  2d08              CMP      r5,#8
00000e  d010              BEQ      |L80.50|
000010  2d0c              CMP      r5,#0xc
000012  d11c              BNE      |L80.78|
000014  e014              B        |L80.64|
                  |L80.22|
;;;1433     {
;;;1434       case TIM_CHANNEL_1:
;;;1435       {       
;;;1436         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1437         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f4207000          BIC      r0,r0,#0x200
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;1438       }
;;;1439       break;
000022  e015              B        |L80.80|
                  |L80.36|
;;;1440       
;;;1441       case TIM_CHANNEL_2:
;;;1442       {
;;;1443         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1444         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f4206080          BIC      r0,r0,#0x400
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;1445       }
;;;1446       break;
000030  e00e              B        |L80.80|
                  |L80.50|
;;;1447       
;;;1448       case TIM_CHANNEL_3:
;;;1449       {
;;;1450         /* Disable the TIM Capture/Compare 3 DMA request */
;;;1451         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  f4206000          BIC      r0,r0,#0x800
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;1452       }
;;;1453       break;
00003e  e007              B        |L80.80|
                  |L80.64|
;;;1454       
;;;1455       case TIM_CHANNEL_4:
;;;1456       {
;;;1457         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1458         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f4205080          BIC      r0,r0,#0x1000
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;1459       }
;;;1460       break;
00004c  e000              B        |L80.80|
                  |L80.78|
;;;1461       
;;;1462       default:
;;;1463       break;
00004e  bf00              NOP      
                  |L80.80|
000050  bf00              NOP                            ;1439
;;;1464     } 
;;;1465     
;;;1466     /* Disable the Capture compare channel */
;;;1467     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000052  2200              MOVS     r2,#0
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;1468     
;;;1469     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00005c  491a              LDR      r1,|L80.200|
00005e  6820              LDR      r0,[r4,#0]
000060  4288              CMP      r0,r1
000062  d003              BEQ      |L80.108|
000064  4919              LDR      r1,|L80.204|
000066  6820              LDR      r0,[r4,#0]
000068  4288              CMP      r0,r1
00006a  d101              BNE      |L80.112|
                  |L80.108|
00006c  2001              MOVS     r0,#1
00006e  e000              B        |L80.114|
                  |L80.112|
000070  2000              MOVS     r0,#0
                  |L80.114|
000072  b190              CBZ      r0,|L80.154|
;;;1470     {
;;;1471       /* Disable the Main Output */
;;;1472       __HAL_TIM_MOE_DISABLE(htim);
000074  bf00              NOP      
000076  6820              LDR      r0,[r4,#0]
000078  6a00              LDR      r0,[r0,#0x20]
00007a  f2411111          MOV      r1,#0x1111
00007e  4008              ANDS     r0,r0,r1
000080  b950              CBNZ     r0,|L80.152|
000082  6820              LDR      r0,[r4,#0]
000084  6a00              LDR      r0,[r0,#0x20]
000086  1089              ASRS     r1,r1,#2
000088  4008              ANDS     r0,r0,r1
00008a  b928              CBNZ     r0,|L80.152|
00008c  6820              LDR      r0,[r4,#0]
00008e  6c40              LDR      r0,[r0,#0x44]
000090  f4204000          BIC      r0,r0,#0x8000
000094  6821              LDR      r1,[r4,#0]
000096  6448              STR      r0,[r1,#0x44]
                  |L80.152|
000098  bf00              NOP      
                  |L80.154|
;;;1473     }
;;;1474     
;;;1475     /* Disable the Peripheral */
;;;1476     __HAL_TIM_DISABLE(htim);
00009a  bf00              NOP      
00009c  6820              LDR      r0,[r4,#0]
00009e  6a00              LDR      r0,[r0,#0x20]
0000a0  f2411111          MOV      r1,#0x1111
0000a4  4008              ANDS     r0,r0,r1
0000a6  b950              CBNZ     r0,|L80.190|
0000a8  6820              LDR      r0,[r4,#0]
0000aa  6a00              LDR      r0,[r0,#0x20]
0000ac  1089              ASRS     r1,r1,#2
0000ae  4008              ANDS     r0,r0,r1
0000b0  b928              CBNZ     r0,|L80.190|
0000b2  6820              LDR      r0,[r4,#0]
0000b4  6800              LDR      r0,[r0,#0]
0000b6  f0200001          BIC      r0,r0,#1
0000ba  6821              LDR      r1,[r4,#0]
0000bc  6008              STR      r0,[r1,#0]
                  |L80.190|
0000be  bf00              NOP      
;;;1477     
;;;1478     /* Change the htim state */
;;;1479     htim->State = HAL_TIM_STATE_READY;
0000c0  2001              MOVS     r0,#1
0000c2  63e0              STR      r0,[r4,#0x3c]
;;;1480     
;;;1481     /* Return function status */
;;;1482     return HAL_OK;
0000c4  2000              MOVS     r0,#0
;;;1483   }
0000c6  bd30              POP      {r4,r5,pc}
;;;1484   
                          ENDP

                  |L80.200|
                          DCD      0x40010000
                  |L80.204|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PWM_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop_IT PROC
;;;1239     */
;;;1240   HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1241   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1242     /* Check the parameters */
;;;1243     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1244     
;;;1245     switch (Channel)
000006  b135              CBZ      r5,|L81.22|
000008  2d04              CMP      r5,#4
00000a  d00b              BEQ      |L81.36|
00000c  2d08              CMP      r5,#8
00000e  d010              BEQ      |L81.50|
000010  2d0c              CMP      r5,#0xc
000012  d11c              BNE      |L81.78|
000014  e014              B        |L81.64|
                  |L81.22|
;;;1246     {
;;;1247       case TIM_CHANNEL_1:
;;;1248       {       
;;;1249         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1250         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f0200002          BIC      r0,r0,#2
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;1251       }
;;;1252       break;
000022  e015              B        |L81.80|
                  |L81.36|
;;;1253       
;;;1254       case TIM_CHANNEL_2:
;;;1255       {
;;;1256         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1257         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f0200004          BIC      r0,r0,#4
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;1258       }
;;;1259       break;
000030  e00e              B        |L81.80|
                  |L81.50|
;;;1260       
;;;1261       case TIM_CHANNEL_3:
;;;1262       {
;;;1263         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1264         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  f0200008          BIC      r0,r0,#8
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;1265       }
;;;1266       break;
00003e  e007              B        |L81.80|
                  |L81.64|
;;;1267       
;;;1268       case TIM_CHANNEL_4:
;;;1269       {
;;;1270         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1271         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f0200010          BIC      r0,r0,#0x10
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;1272       }
;;;1273       break;
00004c  e000              B        |L81.80|
                  |L81.78|
;;;1274       
;;;1275       default:
;;;1276       break; 
00004e  bf00              NOP      
                  |L81.80|
000050  bf00              NOP                            ;1252
;;;1277     }
;;;1278     
;;;1279     /* Disable the Capture compare channel */
;;;1280     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000052  2200              MOVS     r2,#0
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;1281     
;;;1282     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00005c  4919              LDR      r1,|L81.196|
00005e  6820              LDR      r0,[r4,#0]
000060  4288              CMP      r0,r1
000062  d003              BEQ      |L81.108|
000064  4918              LDR      r1,|L81.200|
000066  6820              LDR      r0,[r4,#0]
000068  4288              CMP      r0,r1
00006a  d101              BNE      |L81.112|
                  |L81.108|
00006c  2001              MOVS     r0,#1
00006e  e000              B        |L81.114|
                  |L81.112|
000070  2000              MOVS     r0,#0
                  |L81.114|
000072  b190              CBZ      r0,|L81.154|
;;;1283     {
;;;1284       /* Disable the Main Output */
;;;1285       __HAL_TIM_MOE_DISABLE(htim);
000074  bf00              NOP      
000076  6820              LDR      r0,[r4,#0]
000078  6a00              LDR      r0,[r0,#0x20]
00007a  f2411111          MOV      r1,#0x1111
00007e  4008              ANDS     r0,r0,r1
000080  b950              CBNZ     r0,|L81.152|
000082  6820              LDR      r0,[r4,#0]
000084  6a00              LDR      r0,[r0,#0x20]
000086  1089              ASRS     r1,r1,#2
000088  4008              ANDS     r0,r0,r1
00008a  b928              CBNZ     r0,|L81.152|
00008c  6820              LDR      r0,[r4,#0]
00008e  6c40              LDR      r0,[r0,#0x44]
000090  f4204000          BIC      r0,r0,#0x8000
000094  6821              LDR      r1,[r4,#0]
000096  6448              STR      r0,[r1,#0x44]
                  |L81.152|
000098  bf00              NOP      
                  |L81.154|
;;;1286     }
;;;1287     
;;;1288     /* Disable the Peripheral */
;;;1289     __HAL_TIM_DISABLE(htim);
00009a  bf00              NOP      
00009c  6820              LDR      r0,[r4,#0]
00009e  6a00              LDR      r0,[r0,#0x20]
0000a0  f2411111          MOV      r1,#0x1111
0000a4  4008              ANDS     r0,r0,r1
0000a6  b950              CBNZ     r0,|L81.190|
0000a8  6820              LDR      r0,[r4,#0]
0000aa  6a00              LDR      r0,[r0,#0x20]
0000ac  1089              ASRS     r1,r1,#2
0000ae  4008              ANDS     r0,r0,r1
0000b0  b928              CBNZ     r0,|L81.190|
0000b2  6820              LDR      r0,[r4,#0]
0000b4  6800              LDR      r0,[r0,#0]
0000b6  f0200001          BIC      r0,r0,#1
0000ba  6821              LDR      r1,[r4,#0]
0000bc  6008              STR      r0,[r1,#0]
                  |L81.190|
0000be  bf00              NOP      
;;;1290     
;;;1291     /* Return function status */
;;;1292     return HAL_OK;
0000c0  2000              MOVS     r0,#0
;;;1293   } 
0000c2  bd30              POP      {r4,r5,pc}
;;;1294   
                          ENDP

                  |L81.196|
                          DCD      0x40010000
                  |L81.200|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PeriodElapsedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PeriodElapsedCallback PROC
;;;4422     */
;;;4423   __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4424   {
;;;4425     /* Prevent unused argument(s) compilation warning */
;;;4426     UNUSED(htim);
;;;4427    
;;;4428     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4429               the __HAL_TIM_PeriodElapsedCallback could be implemented in the user file
;;;4430      */
;;;4431     
;;;4432   }
;;;4433   /**
                          ENDP


                          AREA ||i.HAL_TIM_ReadCapturedValue||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ReadCapturedValue PROC
;;;4334     */
;;;4335   uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  4602              MOV      r2,r0
;;;4336   {
;;;4337     uint32_t tmpreg = 0;
000002  2300              MOVS     r3,#0
;;;4338     
;;;4339     __HAL_LOCK(htim);
000004  bf00              NOP      
000006  6b90              LDR      r0,[r2,#0x38]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L83.16|
00000c  2002              MOVS     r0,#2
                  |L83.14|
;;;4340     
;;;4341     switch (Channel)
;;;4342     {
;;;4343       case TIM_CHANNEL_1:
;;;4344       {
;;;4345         /* Check the parameters */
;;;4346         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4347         
;;;4348         /* Return the capture 1 value */
;;;4349         tmpreg = htim->Instance->CCR1;
;;;4350         
;;;4351         break;
;;;4352       }
;;;4353       case TIM_CHANNEL_2:
;;;4354       {
;;;4355         /* Check the parameters */
;;;4356         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4357         
;;;4358         /* Return the capture 2 value */
;;;4359         tmpreg = htim->Instance->CCR2;
;;;4360         
;;;4361         break;
;;;4362       }
;;;4363       
;;;4364       case TIM_CHANNEL_3:
;;;4365       {
;;;4366         /* Check the parameters */
;;;4367         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;4368         
;;;4369         /* Return the capture 3 value */
;;;4370         tmpreg = htim->Instance->CCR3;
;;;4371         
;;;4372         break;
;;;4373       }
;;;4374       
;;;4375       case TIM_CHANNEL_4:
;;;4376       {
;;;4377         /* Check the parameters */
;;;4378         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;4379         
;;;4380         /* Return the capture 4 value */
;;;4381         tmpreg = htim->Instance->CCR4;
;;;4382         
;;;4383         break;
;;;4384       }
;;;4385       
;;;4386       default:
;;;4387       break;  
;;;4388     }
;;;4389        
;;;4390     __HAL_UNLOCK(htim);  
;;;4391     return tmpreg;
;;;4392   }
00000e  4770              BX       lr
                  |L83.16|
000010  2001              MOVS     r0,#1                 ;4339
000012  6390              STR      r0,[r2,#0x38]         ;4339
000014  bf00              NOP                            ;4339
000016  b131              CBZ      r1,|L83.38|
000018  2904              CMP      r1,#4                 ;4341
00001a  d007              BEQ      |L83.44|
00001c  2908              CMP      r1,#8                 ;4341
00001e  d008              BEQ      |L83.50|
000020  290c              CMP      r1,#0xc               ;4341
000022  d10c              BNE      |L83.62|
000024  e008              B        |L83.56|
                  |L83.38|
000026  6810              LDR      r0,[r2,#0]            ;4349
000028  6b43              LDR      r3,[r0,#0x34]         ;4349
00002a  e009              B        |L83.64|
                  |L83.44|
00002c  6810              LDR      r0,[r2,#0]            ;4359
00002e  6b83              LDR      r3,[r0,#0x38]         ;4359
000030  e006              B        |L83.64|
                  |L83.50|
000032  6810              LDR      r0,[r2,#0]            ;4370
000034  6bc3              LDR      r3,[r0,#0x3c]         ;4370
000036  e003              B        |L83.64|
                  |L83.56|
000038  6810              LDR      r0,[r2,#0]            ;4381
00003a  6c03              LDR      r3,[r0,#0x40]         ;4381
00003c  e000              B        |L83.64|
                  |L83.62|
00003e  bf00              NOP                            ;4387
                  |L83.64|
000040  bf00              NOP                            ;4351
000042  bf00              NOP                            ;4390
000044  2000              MOVS     r0,#0                 ;4390
000046  6390              STR      r0,[r2,#0x38]         ;4390
000048  bf00              NOP                            ;4390
00004a  4618              MOV      r0,r3                 ;4391
00004c  e7df              B        |L83.14|
;;;4393   
                          ENDP


                          AREA ||i.HAL_TIM_SlaveConfigSynchronization||, CODE, READONLY, ALIGN=2

                  HAL_TIM_SlaveConfigSynchronization PROC
;;;4148     */
;;;4149   HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef * sSlaveConfig)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4150   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;4151     uint32_t tmpsmcr  = 0;
000008  2600              MOVS     r6,#0
;;;4152     uint32_t tmpccmr1 = 0;
00000a  2700              MOVS     r7,#0
;;;4153     uint32_t tmpccer = 0;
00000c  46b0              MOV      r8,r6
;;;4154   
;;;4155     /* Check the parameters */
;;;4156     assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
;;;4157     assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
;;;4158     assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
;;;4159      
;;;4160     __HAL_LOCK(htim);
00000e  bf00              NOP      
000010  6ba0              LDR      r0,[r4,#0x38]
000012  2801              CMP      r0,#1
000014  d102              BNE      |L84.28|
000016  2002              MOVS     r0,#2
                  |L84.24|
;;;4161     
;;;4162     htim->State = HAL_TIM_STATE_BUSY;
;;;4163   
;;;4164     /* Get the TIMx SMCR register value */
;;;4165     tmpsmcr = htim->Instance->SMCR;
;;;4166   
;;;4167     /* Reset the Trigger Selection Bits */
;;;4168     tmpsmcr &= ~TIM_SMCR_TS;
;;;4169     /* Set the Input Trigger source */
;;;4170     tmpsmcr |= sSlaveConfig->InputTrigger;
;;;4171   
;;;4172     /* Reset the slave mode Bits */
;;;4173     tmpsmcr &= ~TIM_SMCR_SMS;
;;;4174     /* Set the slave mode */
;;;4175     tmpsmcr |= sSlaveConfig->SlaveMode;
;;;4176   
;;;4177     /* Write to TIMx SMCR */
;;;4178     htim->Instance->SMCR = tmpsmcr;
;;;4179     
;;;4180     /* Configure the trigger prescaler, filter, and polarity */
;;;4181     switch (sSlaveConfig->InputTrigger)
;;;4182     {
;;;4183     case TIM_TS_ETRF:
;;;4184       {
;;;4185         /* Check the parameters */
;;;4186         assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
;;;4187         assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
;;;4188         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;4189         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4190         /* Configure the ETR Trigger source */
;;;4191         TIM_ETR_SetConfig(htim->Instance, 
;;;4192                           sSlaveConfig->TriggerPrescaler, 
;;;4193                           sSlaveConfig->TriggerPolarity, 
;;;4194                           sSlaveConfig->TriggerFilter);
;;;4195       }
;;;4196       break;
;;;4197       
;;;4198     case TIM_TS_TI1F_ED:
;;;4199       {
;;;4200         /* Check the parameters */
;;;4201         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4202         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4203         
;;;4204         /* Disable the Channel 1: Reset the CC1E Bit */
;;;4205         tmpccer = htim->Instance->CCER;
;;;4206         htim->Instance->CCER &= ~TIM_CCER_CC1E;
;;;4207         tmpccmr1 = htim->Instance->CCMR1;    
;;;4208         
;;;4209         /* Set the filter */
;;;4210         tmpccmr1 &= ~TIM_CCMR1_IC1F;
;;;4211         tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4);
;;;4212         
;;;4213         /* Write to TIMx CCMR1 and CCER registers */
;;;4214         htim->Instance->CCMR1 = tmpccmr1;
;;;4215         htim->Instance->CCER = tmpccer;                               
;;;4216                                  
;;;4217       }
;;;4218       break;
;;;4219       
;;;4220     case TIM_TS_TI1FP1:
;;;4221       {
;;;4222         /* Check the parameters */
;;;4223         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4224         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;4225         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4226   
;;;4227         /* Configure TI1 Filter and Polarity */
;;;4228         TIM_TI1_ConfigInputStage(htim->Instance,
;;;4229                                  sSlaveConfig->TriggerPolarity,
;;;4230                                  sSlaveConfig->TriggerFilter);
;;;4231       }
;;;4232       break;
;;;4233       
;;;4234     case TIM_TS_TI2FP2:
;;;4235       {
;;;4236         /* Check the parameters */
;;;4237         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4238         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;4239         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4240         
;;;4241         /* Configure TI2 Filter and Polarity */
;;;4242         TIM_TI2_ConfigInputStage(htim->Instance,
;;;4243                                   sSlaveConfig->TriggerPolarity,
;;;4244                                   sSlaveConfig->TriggerFilter);
;;;4245       }
;;;4246       break;
;;;4247       
;;;4248     case TIM_TS_ITR0:
;;;4249       {
;;;4250         /* Check the parameter */
;;;4251         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4252       }
;;;4253       break;
;;;4254       
;;;4255     case TIM_TS_ITR1:
;;;4256       {
;;;4257         /* Check the parameter */
;;;4258         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4259       }
;;;4260       break;
;;;4261       
;;;4262     case TIM_TS_ITR2:
;;;4263       {
;;;4264         /* Check the parameter */
;;;4265         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4266       }
;;;4267       break;
;;;4268       
;;;4269     case TIM_TS_ITR3:
;;;4270       {
;;;4271         /* Check the parameter */
;;;4272         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4273       }
;;;4274       break;
;;;4275          
;;;4276     default:
;;;4277       break;
;;;4278     }
;;;4279     
;;;4280     htim->State = HAL_TIM_STATE_READY;
;;;4281        
;;;4282     __HAL_UNLOCK(htim);  
;;;4283     
;;;4284     return HAL_OK;
;;;4285   } 
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L84.28|
00001c  2001              MOVS     r0,#1                 ;4160
00001e  63a0              STR      r0,[r4,#0x38]         ;4160
000020  bf00              NOP                            ;4160
000022  2002              MOVS     r0,#2                 ;4162
000024  63e0              STR      r0,[r4,#0x3c]         ;4162
000026  6820              LDR      r0,[r4,#0]            ;4165
000028  6886              LDR      r6,[r0,#8]            ;4165
00002a  f0260670          BIC      r6,r6,#0x70           ;4168
00002e  6868              LDR      r0,[r5,#4]            ;4170
000030  4306              ORRS     r6,r6,r0              ;4170
000032  4825              LDR      r0,|L84.200|
000034  4006              ANDS     r6,r6,r0              ;4173
000036  6828              LDR      r0,[r5,#0]            ;4175
000038  4306              ORRS     r6,r6,r0              ;4175
00003a  6820              LDR      r0,[r4,#0]            ;4178
00003c  6086              STR      r6,[r0,#8]            ;4178
00003e  6868              LDR      r0,[r5,#4]            ;4181
000040  f000010f          AND      r1,r0,#0xf            ;4181
000044  2900              CMP      r1,#0                 ;4181
000046  d135              BNE      |L84.180|
000048  1100              ASRS     r0,r0,#4              ;4181
00004a  2808              CMP      r0,#8                 ;4181
00004c  d232              BCS      |L84.180|
00004e  e8dff000          TBB      [pc,r0]               ;4181
000052  2d2e              DCB      0x2d,0x2e
000054  2f300b21          DCB      0x2f,0x30,0x0b,0x21
000058  2704              DCB      0x27,0x04
00005a  e9d51303          LDRD     r1,r3,[r5,#0xc]       ;4191
00005e  68aa              LDR      r2,[r5,#8]            ;4191
000060  6820              LDR      r0,[r4,#0]            ;4191
000062  f7fffffe          BL       TIM_ETR_SetConfig
000066  e026              B        |L84.182|
000068  6820              LDR      r0,[r4,#0]            ;4205
00006a  f8d08020          LDR      r8,[r0,#0x20]         ;4205
00006e  6820              LDR      r0,[r4,#0]            ;4206
000070  6a00              LDR      r0,[r0,#0x20]         ;4206
000072  f0200001          BIC      r0,r0,#1              ;4206
000076  6821              LDR      r1,[r4,#0]            ;4206
000078  6208              STR      r0,[r1,#0x20]         ;4206
00007a  6820              LDR      r0,[r4,#0]            ;4207
00007c  6987              LDR      r7,[r0,#0x18]         ;4207
00007e  f02707f0          BIC      r7,r7,#0xf0           ;4210
000082  6928              LDR      r0,[r5,#0x10]         ;4211
000084  ea471700          ORR      r7,r7,r0,LSL #4       ;4211
000088  6820              LDR      r0,[r4,#0]            ;4214
00008a  6187              STR      r7,[r0,#0x18]         ;4214
00008c  6820              LDR      r0,[r4,#0]            ;4215
00008e  f8c08020          STR      r8,[r0,#0x20]         ;4215
000092  e010              B        |L84.182|
000094  692a              LDR      r2,[r5,#0x10]         ;4228
000096  68a9              LDR      r1,[r5,#8]            ;4228
000098  6820              LDR      r0,[r4,#0]            ;4228
00009a  f7fffffe          BL       TIM_TI1_ConfigInputStage
00009e  e00a              B        |L84.182|
0000a0  692a              LDR      r2,[r5,#0x10]         ;4242
0000a2  68a9              LDR      r1,[r5,#8]            ;4242
0000a4  6820              LDR      r0,[r4,#0]            ;4242
0000a6  f7fffffe          BL       TIM_TI2_ConfigInputStage
0000aa  e004              B        |L84.182|
0000ac  e003              B        |L84.182|
0000ae  e002              B        |L84.182|
0000b0  e001              B        |L84.182|
0000b2  e000              B        |L84.182|
                  |L84.180|
0000b4  bf00              NOP                            ;4277
                  |L84.182|
0000b6  bf00              NOP                            ;4196
0000b8  2001              MOVS     r0,#1                 ;4280
0000ba  63e0              STR      r0,[r4,#0x3c]         ;4280
0000bc  bf00              NOP                            ;4282
0000be  2000              MOVS     r0,#0                 ;4282
0000c0  63a0              STR      r0,[r4,#0x38]         ;4282
0000c2  bf00              NOP                            ;4282
0000c4  bf00              NOP                            ;4284
0000c6  e7a7              B        |L84.24|
;;;4286   
                          ENDP

                  |L84.200|
                          DCD      0xfffefff8

                          AREA ||i.HAL_TIM_SlaveConfigSynchronization_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_SlaveConfigSynchronization_IT PROC
;;;4295     */
;;;4296   HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization_IT(TIM_HandleTypeDef *htim, 
000000  b570              PUSH     {r4-r6,lr}
;;;4297                                                           TIM_SlaveConfigTypeDef * sSlaveConfig)
;;;4298   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;4299     /* Check the parameters */
;;;4300     assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
;;;4301     assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
;;;4302     assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
;;;4303     
;;;4304     __HAL_LOCK(htim);
000006  bf00              NOP      
000008  6ba0              LDR      r0,[r4,#0x38]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L85.18|
00000e  2002              MOVS     r0,#2
                  |L85.16|
;;;4305   
;;;4306     htim->State = HAL_TIM_STATE_BUSY;
;;;4307     
;;;4308     TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
;;;4309     
;;;4310     /* Enable Trigger Interrupt */
;;;4311     __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
;;;4312     
;;;4313     /* Disable Trigger DMA request */
;;;4314     __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
;;;4315     
;;;4316     htim->State = HAL_TIM_STATE_READY;
;;;4317        
;;;4318     __HAL_UNLOCK(htim);  
;;;4319     
;;;4320     return HAL_OK;
;;;4321   }
000010  bd70              POP      {r4-r6,pc}
                  |L85.18|
000012  2001              MOVS     r0,#1                 ;4304
000014  63a0              STR      r0,[r4,#0x38]         ;4304
000016  bf00              NOP                            ;4304
000018  2002              MOVS     r0,#2                 ;4306
00001a  63e0              STR      r0,[r4,#0x3c]         ;4306
00001c  4629              MOV      r1,r5                 ;4308
00001e  4620              MOV      r0,r4                 ;4308
000020  f7fffffe          BL       TIM_SlaveTimer_SetConfig
000024  6820              LDR      r0,[r4,#0]            ;4311
000026  68c0              LDR      r0,[r0,#0xc]          ;4311
000028  f0400040          ORR      r0,r0,#0x40           ;4311
00002c  6821              LDR      r1,[r4,#0]            ;4311
00002e  60c8              STR      r0,[r1,#0xc]          ;4311
000030  6820              LDR      r0,[r4,#0]            ;4314
000032  68c0              LDR      r0,[r0,#0xc]          ;4314
000034  f4204080          BIC      r0,r0,#0x4000         ;4314
000038  6821              LDR      r1,[r4,#0]            ;4314
00003a  60c8              STR      r0,[r1,#0xc]          ;4314
00003c  2001              MOVS     r0,#1                 ;4316
00003e  63e0              STR      r0,[r4,#0x3c]         ;4316
000040  bf00              NOP                            ;4318
000042  2000              MOVS     r0,#0                 ;4318
000044  63a0              STR      r0,[r4,#0x38]         ;4318
000046  bf00              NOP                            ;4318
000048  bf00              NOP                            ;4320
00004a  e7e1              B        |L85.16|
;;;4322   
                          ENDP


                          AREA ||i.HAL_TIM_TriggerCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_TriggerCallback PROC
;;;4485     */
;;;4486   __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4487   {
;;;4488     /* Prevent unused argument(s) compilation warning */
;;;4489     UNUSED(htim);
;;;4490    
;;;4491     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4492               the HAL_TIM_TriggerCallback could be implemented in the user file
;;;4493      */
;;;4494   }
;;;4495   
                          ENDP


                          AREA ||i.TIM_Base_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_Base_SetConfig PROC
;;;4719     */
;;;4720   void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
000000  2200              MOVS     r2,#0
;;;4721   {
;;;4722     uint32_t tmpcr1 = 0;
;;;4723     tmpcr1 = TIMx->CR1;
000002  6802              LDR      r2,[r0,#0]
;;;4724     
;;;4725     /* Set TIM Time Base Unit parameters ---------------------------------------*/
;;;4726     if(IS_TIM_CC3_INSTANCE(TIMx) != RESET)   
000004  4b2c              LDR      r3,|L87.184|
000006  4298              CMP      r0,r3
000008  d00e              BEQ      |L87.40|
00000a  f1b04f80          CMP      r0,#0x40000000
00000e  d00b              BEQ      |L87.40|
000010  4b2a              LDR      r3,|L87.188|
000012  4298              CMP      r0,r3
000014  d008              BEQ      |L87.40|
000016  4b2a              LDR      r3,|L87.192|
000018  4298              CMP      r0,r3
00001a  d005              BEQ      |L87.40|
00001c  4b29              LDR      r3,|L87.196|
00001e  4298              CMP      r0,r3
000020  d002              BEQ      |L87.40|
000022  4b29              LDR      r3,|L87.200|
000024  4298              CMP      r0,r3
000026  d101              BNE      |L87.44|
                  |L87.40|
000028  2301              MOVS     r3,#1
00002a  e000              B        |L87.46|
                  |L87.44|
00002c  2300              MOVS     r3,#0
                  |L87.46|
00002e  b11b              CBZ      r3,|L87.56|
;;;4727     {
;;;4728       /* Select the Counter Mode */
;;;4729       tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
000030  f0220270          BIC      r2,r2,#0x70
;;;4730       tmpcr1 |= Structure->CounterMode;
000034  684b              LDR      r3,[r1,#4]
000036  431a              ORRS     r2,r2,r3
                  |L87.56|
;;;4731     }
;;;4732    
;;;4733     if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)  
000038  4b1f              LDR      r3,|L87.184|
00003a  4298              CMP      r0,r3
00003c  d020              BEQ      |L87.128|
00003e  f1b04f80          CMP      r0,#0x40000000
000042  d01d              BEQ      |L87.128|
000044  4b1d              LDR      r3,|L87.188|
000046  4298              CMP      r0,r3
000048  d01a              BEQ      |L87.128|
00004a  4b1d              LDR      r3,|L87.192|
00004c  4298              CMP      r0,r3
00004e  d017              BEQ      |L87.128|
000050  4b1c              LDR      r3,|L87.196|
000052  4298              CMP      r0,r3
000054  d014              BEQ      |L87.128|
000056  4b1c              LDR      r3,|L87.200|
000058  4298              CMP      r0,r3
00005a  d011              BEQ      |L87.128|
00005c  4b1b              LDR      r3,|L87.204|
00005e  4298              CMP      r0,r3
000060  d00e              BEQ      |L87.128|
000062  4b1b              LDR      r3,|L87.208|
000064  4298              CMP      r0,r3
000066  d00b              BEQ      |L87.128|
000068  4b1a              LDR      r3,|L87.212|
00006a  4298              CMP      r0,r3
00006c  d008              BEQ      |L87.128|
00006e  4b1a              LDR      r3,|L87.216|
000070  4298              CMP      r0,r3
000072  d005              BEQ      |L87.128|
000074  4b19              LDR      r3,|L87.220|
000076  4298              CMP      r0,r3
000078  d002              BEQ      |L87.128|
00007a  4b19              LDR      r3,|L87.224|
00007c  4298              CMP      r0,r3
00007e  d101              BNE      |L87.132|
                  |L87.128|
000080  2301              MOVS     r3,#1
000082  e000              B        |L87.134|
                  |L87.132|
000084  2300              MOVS     r3,#0
                  |L87.134|
000086  b11b              CBZ      r3,|L87.144|
;;;4734     {
;;;4735       /* Set the clock division */
;;;4736       tmpcr1 &= ~TIM_CR1_CKD;
000088  f4227240          BIC      r2,r2,#0x300
;;;4737       tmpcr1 |= (uint32_t)Structure->ClockDivision;
00008c  68cb              LDR      r3,[r1,#0xc]
00008e  431a              ORRS     r2,r2,r3
                  |L87.144|
;;;4738     }
;;;4739   
;;;4740     TIMx->CR1 = tmpcr1;
000090  6002              STR      r2,[r0,#0]
;;;4741   
;;;4742     /* Set the Auto-reload value */
;;;4743     TIMx->ARR = (uint32_t)Structure->Period ;
000092  688b              LDR      r3,[r1,#8]
000094  62c3              STR      r3,[r0,#0x2c]
;;;4744    
;;;4745     /* Set the Prescaler value */
;;;4746     TIMx->PSC = (uint32_t)Structure->Prescaler;
000096  680b              LDR      r3,[r1,#0]
000098  6283              STR      r3,[r0,#0x28]
;;;4747       
;;;4748     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)  
00009a  4b07              LDR      r3,|L87.184|
00009c  4298              CMP      r0,r3
00009e  d002              BEQ      |L87.166|
0000a0  4b09              LDR      r3,|L87.200|
0000a2  4298              CMP      r0,r3
0000a4  d101              BNE      |L87.170|
                  |L87.166|
0000a6  2301              MOVS     r3,#1
0000a8  e000              B        |L87.172|
                  |L87.170|
0000aa  2300              MOVS     r3,#0
                  |L87.172|
0000ac  b10b              CBZ      r3,|L87.178|
;;;4749     {
;;;4750       /* Set the Repetition Counter value */
;;;4751       TIMx->RCR = Structure->RepetitionCounter;
0000ae  690b              LDR      r3,[r1,#0x10]
0000b0  6303              STR      r3,[r0,#0x30]
                  |L87.178|
;;;4752     }
;;;4753   
;;;4754     /* Generate an update event to reload the Prescaler 
;;;4755        and the repetition counter(only for TIM1 and TIM8) value immediately */
;;;4756     TIMx->EGR = TIM_EGR_UG;
0000b2  2301              MOVS     r3,#1
0000b4  6143              STR      r3,[r0,#0x14]
;;;4757   }
0000b6  4770              BX       lr
;;;4758   
                          ENDP

                  |L87.184|
                          DCD      0x40010000
                  |L87.188|
                          DCD      0x40000400
                  |L87.192|
                          DCD      0x40000800
                  |L87.196|
                          DCD      0x40000c00
                  |L87.200|
                          DCD      0x40010400
                  |L87.204|
                          DCD      0x40014000
                  |L87.208|
                          DCD      0x40014400
                  |L87.212|
                          DCD      0x40014800
                  |L87.216|
                          DCD      0x40001800
                  |L87.220|
                          DCD      0x40001c00
                  |L87.224|
                          DCD      0x40002000

                          AREA ||i.TIM_CCxChannelCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxChannelCmd PROC
;;;5490     */
;;;5491   void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
000000  b530              PUSH     {r4,r5,lr}
;;;5492   {
;;;5493     uint32_t tmp = 0;
000002  2300              MOVS     r3,#0
;;;5494   
;;;5495     /* Check the parameters */
;;;5496     assert_param(IS_TIM_CC1_INSTANCE(TIMx)); 
;;;5497     assert_param(IS_TIM_CHANNELS(Channel));
;;;5498   
;;;5499     tmp = TIM_CCER_CC1E << Channel;
000004  2401              MOVS     r4,#1
000006  fa04f301          LSL      r3,r4,r1
;;;5500   
;;;5501     /* Reset the CCxE Bit */
;;;5502     TIMx->CCER &= ~tmp;
00000a  6a04              LDR      r4,[r0,#0x20]
00000c  439c              BICS     r4,r4,r3
00000e  6204              STR      r4,[r0,#0x20]
;;;5503   
;;;5504     /* Set or reset the CCxE Bit */ 
;;;5505     TIMx->CCER |= (uint32_t)(ChannelState << Channel);
000010  6a04              LDR      r4,[r0,#0x20]
000012  fa02f501          LSL      r5,r2,r1
000016  432c              ORRS     r4,r4,r5
000018  6204              STR      r4,[r0,#0x20]
;;;5506   }
00001a  bd30              POP      {r4,r5,pc}
;;;5507   
                          ENDP


                          AREA ||i.TIM_DMACaptureCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMACaptureCplt PROC
;;;4654     */
;;;4655   void HAL_TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;4656   {
000002  4605              MOV      r5,r0
;;;4657     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bec              LDR      r4,[r5,#0x3c]
;;;4658       
;;;4659      htim->State= HAL_TIM_STATE_READY; 
000006  2001              MOVS     r0,#1
000008  63e0              STR      r0,[r4,#0x3c]
;;;4660       
;;;4661     if (hdma == htim->hdma[TIM_DMA_ID_CC1])
00000a  6a20              LDR      r0,[r4,#0x20]
00000c  42a8              CMP      r0,r5
00000e  d102              BNE      |L89.22|
;;;4662     {
;;;4663       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000010  2001              MOVS     r0,#1
000012  61a0              STR      r0,[r4,#0x18]
000014  e010              B        |L89.56|
                  |L89.22|
;;;4664     }
;;;4665     else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
000016  6a60              LDR      r0,[r4,#0x24]
000018  42a8              CMP      r0,r5
00001a  d102              BNE      |L89.34|
;;;4666     {
;;;4667       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
00001c  2002              MOVS     r0,#2
00001e  61a0              STR      r0,[r4,#0x18]
000020  e00a              B        |L89.56|
                  |L89.34|
;;;4668     }
;;;4669     else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
000022  6aa0              LDR      r0,[r4,#0x28]
000024  42a8              CMP      r0,r5
000026  d102              BNE      |L89.46|
;;;4670     {
;;;4671       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000028  2004              MOVS     r0,#4
00002a  61a0              STR      r0,[r4,#0x18]
00002c  e004              B        |L89.56|
                  |L89.46|
;;;4672     }
;;;4673     else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
00002e  6ae0              LDR      r0,[r4,#0x2c]
000030  42a8              CMP      r0,r5
000032  d101              BNE      |L89.56|
;;;4674     {
;;;4675       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
000034  2008              MOVS     r0,#8
000036  61a0              STR      r0,[r4,#0x18]
                  |L89.56|
;;;4676     }
;;;4677     
;;;4678     HAL_TIM_IC_CaptureCallback(htim); 
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
;;;4679     
;;;4680     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
00003e  2000              MOVS     r0,#0
000040  61a0              STR      r0,[r4,#0x18]
;;;4681   
;;;4682   }
000042  bd70              POP      {r4-r6,pc}
;;;4683   
                          ENDP


                          AREA ||i.TIM_DMADelayPulseCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMADelayPulseCplt PROC
;;;4621     */
;;;4622   void HAL_TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;4623   {
000002  4605              MOV      r5,r0
;;;4624     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bec              LDR      r4,[r5,#0x3c]
;;;4625     
;;;4626     htim->State= HAL_TIM_STATE_READY; 
000006  2001              MOVS     r0,#1
000008  63e0              STR      r0,[r4,#0x3c]
;;;4627     
;;;4628     if (hdma == htim->hdma[TIM_DMA_ID_CC1])
00000a  6a20              LDR      r0,[r4,#0x20]
00000c  42a8              CMP      r0,r5
00000e  d102              BNE      |L90.22|
;;;4629     {
;;;4630       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000010  2001              MOVS     r0,#1
000012  61a0              STR      r0,[r4,#0x18]
000014  e010              B        |L90.56|
                  |L90.22|
;;;4631     }
;;;4632     else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
000016  6a60              LDR      r0,[r4,#0x24]
000018  42a8              CMP      r0,r5
00001a  d102              BNE      |L90.34|
;;;4633     {
;;;4634       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
00001c  2002              MOVS     r0,#2
00001e  61a0              STR      r0,[r4,#0x18]
000020  e00a              B        |L90.56|
                  |L90.34|
;;;4635     }
;;;4636     else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
000022  6aa0              LDR      r0,[r4,#0x28]
000024  42a8              CMP      r0,r5
000026  d102              BNE      |L90.46|
;;;4637     {
;;;4638       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000028  2004              MOVS     r0,#4
00002a  61a0              STR      r0,[r4,#0x18]
00002c  e004              B        |L90.56|
                  |L90.46|
;;;4639     }
;;;4640     else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
00002e  6ae0              LDR      r0,[r4,#0x2c]
000030  42a8              CMP      r0,r5
000032  d101              BNE      |L90.56|
;;;4641     {
;;;4642       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
000034  2008              MOVS     r0,#8
000036  61a0              STR      r0,[r4,#0x18]
                  |L90.56|
;;;4643     }
;;;4644   
;;;4645     HAL_TIM_PWM_PulseFinishedCallback(htim);
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
;;;4646   
;;;4647     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
00003e  2000              MOVS     r0,#0
000040  61a0              STR      r0,[r4,#0x18]
;;;4648   }
000042  bd70              POP      {r4-r6,pc}
;;;4649   /**
                          ENDP


                          AREA ||i.TIM_DMAError||, CODE, READONLY, ALIGN=1

                  TIM_DMAError PROC
;;;4606     */
;;;4607   void HAL_TIM_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;4608   {
000002  4604              MOV      r4,r0
;;;4609     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6be5              LDR      r5,[r4,#0x3c]
;;;4610     
;;;4611     htim->State= HAL_TIM_STATE_READY;
000006  2001              MOVS     r0,#1
000008  63e8              STR      r0,[r5,#0x3c]
;;;4612      
;;;4613     HAL_TIM_ErrorCallback(htim);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       HAL_TIM_ErrorCallback
;;;4614   }
000010  bd70              POP      {r4-r6,pc}
;;;4615   
                          ENDP


                          AREA ||i.TIM_DMAPeriodElapsedCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMAPeriodElapsedCplt PROC
;;;4689     */
;;;4690   static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;4691   {
000002  4604              MOV      r4,r0
;;;4692     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6be5              LDR      r5,[r4,#0x3c]
;;;4693     
;;;4694     htim->State= HAL_TIM_STATE_READY;
000006  2001              MOVS     r0,#1
000008  63e8              STR      r0,[r5,#0x3c]
;;;4695     
;;;4696     HAL_TIM_PeriodElapsedCallback(htim);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
;;;4697   }
000010  bd70              POP      {r4-r6,pc}
;;;4698   
                          ENDP


                          AREA ||i.TIM_DMATriggerCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMATriggerCplt PROC
;;;4704     */
;;;4705   static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;4706   {
000002  4604              MOV      r4,r0
;;;4707     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;  
000004  6be5              LDR      r5,[r4,#0x3c]
;;;4708     
;;;4709     htim->State= HAL_TIM_STATE_READY; 
000006  2001              MOVS     r0,#1
000008  63e8              STR      r0,[r5,#0x3c]
;;;4710     
;;;4711     HAL_TIM_TriggerCallback(htim);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       HAL_TIM_TriggerCallback
;;;4712   }
000010  bd70              POP      {r4-r6,pc}
;;;4713   
                          ENDP


                          AREA ||i.TIM_ETR_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_ETR_SetConfig PROC
;;;5460     */
;;;5461   void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
000000  b530              PUSH     {r4,r5,lr}
;;;5462                          uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
;;;5463   {
000002  460c              MOV      r4,r1
;;;5464     uint32_t tmpsmcr = 0;
000004  2100              MOVS     r1,#0
;;;5465   
;;;5466     tmpsmcr = TIMx->SMCR;
000006  6881              LDR      r1,[r0,#8]
;;;5467   
;;;5468     /* Reset the ETR Bits */
;;;5469     tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
000008  f421417f          BIC      r1,r1,#0xff00
;;;5470   
;;;5471     /* Set the Prescaler, the Filter value and the Polarity */
;;;5472     tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8)));
00000c  ea422503          ORR      r5,r2,r3,LSL #8
000010  4325              ORRS     r5,r5,r4
000012  4329              ORRS     r1,r1,r5
;;;5473   
;;;5474     /* Write to TIMx SMCR */
;;;5475     TIMx->SMCR = tmpsmcr;
000014  6081              STR      r1,[r0,#8]
;;;5476   } 
000016  bd30              POP      {r4,r5,pc}
;;;5477   
                          ENDP


                          AREA ||i.TIM_ITRx_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITRx_SetConfig PROC
;;;5429     */
;;;5430   static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t TIM_ITRx)
000000  460a              MOV      r2,r1
;;;5431   {
;;;5432     uint32_t tmpsmcr = 0;
000002  2100              MOVS     r1,#0
;;;5433     
;;;5434      /* Get the TIMx SMCR register value */
;;;5435      tmpsmcr = TIMx->SMCR;
000004  6881              LDR      r1,[r0,#8]
;;;5436      /* Reset the TS Bits */
;;;5437      tmpsmcr &= ~TIM_SMCR_TS;
000006  f0210170          BIC      r1,r1,#0x70
;;;5438      /* Set the Input Trigger source and the slave mode*/
;;;5439      tmpsmcr |= TIM_ITRx | TIM_SLAVEMODE_EXTERNAL1;
00000a  f0420307          ORR      r3,r2,#7
00000e  4319              ORRS     r1,r1,r3
;;;5440      /* Write to TIMx SMCR */
;;;5441      TIMx->SMCR = tmpsmcr;
000010  6081              STR      r1,[r0,#8]
;;;5442   }
000012  4770              BX       lr
;;;5443   
                          ENDP


                          AREA ||i.TIM_OC1_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC1_SetConfig PROC
;;;4764     */
;;;4765   void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b530              PUSH     {r4,r5,lr}
;;;4766   {
;;;4767     uint32_t tmpccmrx = 0;
000002  2400              MOVS     r4,#0
;;;4768     uint32_t tmpccer = 0;
000004  2200              MOVS     r2,#0
;;;4769     uint32_t tmpcr2 = 0;  
000006  2300              MOVS     r3,#0
;;;4770   
;;;4771     /* Disable the Channel 1: Reset the CC1E Bit */
;;;4772     TIMx->CCER &= ~TIM_CCER_CC1E;
000008  6a05              LDR      r5,[r0,#0x20]
00000a  f0250501          BIC      r5,r5,#1
00000e  6205              STR      r5,[r0,#0x20]
;;;4773     
;;;4774     /* Get the TIMx CCER register value */
;;;4775     tmpccer = TIMx->CCER;
000010  6a02              LDR      r2,[r0,#0x20]
;;;4776     /* Get the TIMx CR2 register value */
;;;4777     tmpcr2 = TIMx->CR2;
000012  6843              LDR      r3,[r0,#4]
;;;4778     
;;;4779     /* Get the TIMx CCMR1 register value */
;;;4780     tmpccmrx = TIMx->CCMR1;
000014  6984              LDR      r4,[r0,#0x18]
;;;4781       
;;;4782     /* Reset the Output Compare Mode Bits */
;;;4783     tmpccmrx &= ~TIM_CCMR1_OC1M;
000016  4d14              LDR      r5,|L96.104|
000018  402c              ANDS     r4,r4,r5
;;;4784     tmpccmrx &= ~TIM_CCMR1_CC1S;
00001a  f0240403          BIC      r4,r4,#3
;;;4785     /* Select the Output Compare Mode */
;;;4786     tmpccmrx |= OC_Config->OCMode;
00001e  680d              LDR      r5,[r1,#0]
000020  432c              ORRS     r4,r4,r5
;;;4787     
;;;4788     /* Reset the Output Polarity level */
;;;4789     tmpccer &= ~TIM_CCER_CC1P;
000022  f0220202          BIC      r2,r2,#2
;;;4790     /* Set the Output Compare Polarity */
;;;4791     tmpccer |= OC_Config->OCPolarity;
000026  688d              LDR      r5,[r1,#8]
000028  432a              ORRS     r2,r2,r5
;;;4792   
;;;4793       
;;;4794     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
00002a  4d10              LDR      r5,|L96.108|
00002c  42a8              CMP      r0,r5
00002e  d002              BEQ      |L96.54|
000030  4d0f              LDR      r5,|L96.112|
000032  42a8              CMP      r0,r5
000034  d101              BNE      |L96.58|
                  |L96.54|
000036  2501              MOVS     r5,#1
000038  e000              B        |L96.60|
                  |L96.58|
00003a  2500              MOVS     r5,#0
                  |L96.60|
00003c  b16d              CBZ      r5,|L96.90|
;;;4795     {   
;;;4796       /* Reset the Output N Polarity level */
;;;4797       tmpccer &= ~TIM_CCER_CC1NP;
00003e  f0220208          BIC      r2,r2,#8
;;;4798       /* Set the Output N Polarity */
;;;4799       tmpccer |= OC_Config->OCNPolarity;
000042  68cd              LDR      r5,[r1,#0xc]
000044  432a              ORRS     r2,r2,r5
;;;4800       /* Reset the Output N State */
;;;4801       tmpccer &= ~TIM_CCER_CC1NE;
000046  f0220204          BIC      r2,r2,#4
;;;4802       
;;;4803       /* Reset the Output Compare and Output Compare N IDLE State */
;;;4804       tmpcr2 &= ~TIM_CR2_OIS1;
00004a  f4237380          BIC      r3,r3,#0x100
;;;4805       tmpcr2 &= ~TIM_CR2_OIS1N;
00004e  f4237300          BIC      r3,r3,#0x200
;;;4806       /* Set the Output Idle state */
;;;4807       tmpcr2 |= OC_Config->OCIdleState;
000052  694d              LDR      r5,[r1,#0x14]
000054  432b              ORRS     r3,r3,r5
;;;4808       /* Set the Output N Idle state */
;;;4809       tmpcr2 |= OC_Config->OCNIdleState;
000056  698d              LDR      r5,[r1,#0x18]
000058  432b              ORRS     r3,r3,r5
                  |L96.90|
;;;4810     }
;;;4811     /* Write to TIMx CR2 */
;;;4812     TIMx->CR2 = tmpcr2;
00005a  6043              STR      r3,[r0,#4]
;;;4813     
;;;4814     /* Write to TIMx CCMR1 */
;;;4815     TIMx->CCMR1 = tmpccmrx;
00005c  6184              STR      r4,[r0,#0x18]
;;;4816     
;;;4817     /* Set the Capture Compare Register value */
;;;4818     TIMx->CCR1 = OC_Config->Pulse;
00005e  684d              LDR      r5,[r1,#4]
000060  6345              STR      r5,[r0,#0x34]
;;;4819     
;;;4820     /* Write to TIMx CCER */
;;;4821     TIMx->CCER = tmpccer;  
000062  6202              STR      r2,[r0,#0x20]
;;;4822   } 
000064  bd30              POP      {r4,r5,pc}
;;;4823   
                          ENDP

000066  0000              DCW      0x0000
                  |L96.104|
                          DCD      0xfffeff8f
                  |L96.108|
                          DCD      0x40010000
                  |L96.112|
                          DCD      0x40010400

                          AREA ||i.TIM_OC2_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC2_SetConfig PROC
;;;4829     */
;;;4830   void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b530              PUSH     {r4,r5,lr}
;;;4831   {
;;;4832     uint32_t tmpccmrx = 0;
000002  2400              MOVS     r4,#0
;;;4833     uint32_t tmpccer = 0;
000004  2200              MOVS     r2,#0
;;;4834     uint32_t tmpcr2 = 0;
000006  2300              MOVS     r3,#0
;;;4835      
;;;4836     /* Disable the Channel 2: Reset the CC2E Bit */
;;;4837     TIMx->CCER &= ~TIM_CCER_CC2E;
000008  6a05              LDR      r5,[r0,#0x20]
00000a  f0250510          BIC      r5,r5,#0x10
00000e  6205              STR      r5,[r0,#0x20]
;;;4838     
;;;4839     /* Get the TIMx CCER register value */  
;;;4840     tmpccer = TIMx->CCER;
000010  6a02              LDR      r2,[r0,#0x20]
;;;4841     /* Get the TIMx CR2 register value */
;;;4842     tmpcr2 = TIMx->CR2;
000012  6843              LDR      r3,[r0,#4]
;;;4843     
;;;4844     /* Get the TIMx CCMR1 register value */
;;;4845     tmpccmrx = TIMx->CCMR1;
000014  6984              LDR      r4,[r0,#0x18]
;;;4846       
;;;4847     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;4848     tmpccmrx &= ~TIM_CCMR1_OC2M;
000016  4d16              LDR      r5,|L97.112|
000018  402c              ANDS     r4,r4,r5
;;;4849     tmpccmrx &= ~TIM_CCMR1_CC2S;
00001a  f4247440          BIC      r4,r4,#0x300
;;;4850     
;;;4851     /* Select the Output Compare Mode */
;;;4852     tmpccmrx |= (OC_Config->OCMode << 8);
00001e  680d              LDR      r5,[r1,#0]
000020  ea442405          ORR      r4,r4,r5,LSL #8
;;;4853     
;;;4854     /* Reset the Output Polarity level */
;;;4855     tmpccer &= ~TIM_CCER_CC2P;
000024  f0220220          BIC      r2,r2,#0x20
;;;4856     /* Set the Output Compare Polarity */
;;;4857     tmpccer |= (OC_Config->OCPolarity << 4);
000028  688d              LDR      r5,[r1,#8]
00002a  ea421205          ORR      r2,r2,r5,LSL #4
;;;4858       
;;;4859     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
00002e  4d11              LDR      r5,|L97.116|
000030  42a8              CMP      r0,r5
000032  d002              BEQ      |L97.58|
000034  4d10              LDR      r5,|L97.120|
000036  42a8              CMP      r0,r5
000038  d101              BNE      |L97.62|
                  |L97.58|
00003a  2501              MOVS     r5,#1
00003c  e000              B        |L97.64|
                  |L97.62|
00003e  2500              MOVS     r5,#0
                  |L97.64|
000040  b185              CBZ      r5,|L97.100|
;;;4860     {
;;;4861       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;4862       
;;;4863       /* Reset the Output N Polarity level */
;;;4864       tmpccer &= ~TIM_CCER_CC2NP;
000042  f0220280          BIC      r2,r2,#0x80
;;;4865       /* Set the Output N Polarity */
;;;4866       tmpccer |= (OC_Config->OCNPolarity << 4);
000046  68cd              LDR      r5,[r1,#0xc]
000048  ea421205          ORR      r2,r2,r5,LSL #4
;;;4867       /* Reset the Output N State */
;;;4868       tmpccer &= ~TIM_CCER_CC2NE;
00004c  f0220240          BIC      r2,r2,#0x40
;;;4869       
;;;4870       /* Reset the Output Compare and Output Compare N IDLE State */
;;;4871       tmpcr2 &= ~TIM_CR2_OIS2;
000050  f4236380          BIC      r3,r3,#0x400
;;;4872       tmpcr2 &= ~TIM_CR2_OIS2N;
000054  f4236300          BIC      r3,r3,#0x800
;;;4873       /* Set the Output Idle state */
;;;4874       tmpcr2 |= (OC_Config->OCIdleState << 2);
000058  694d              LDR      r5,[r1,#0x14]
00005a  ea430385          ORR      r3,r3,r5,LSL #2
;;;4875       /* Set the Output N Idle state */
;;;4876       tmpcr2 |= (OC_Config->OCNIdleState << 2);
00005e  698d              LDR      r5,[r1,#0x18]
000060  ea430385          ORR      r3,r3,r5,LSL #2
                  |L97.100|
;;;4877     }
;;;4878     /* Write to TIMx CR2 */
;;;4879     TIMx->CR2 = tmpcr2;
000064  6043              STR      r3,[r0,#4]
;;;4880     
;;;4881     /* Write to TIMx CCMR1 */
;;;4882     TIMx->CCMR1 = tmpccmrx;
000066  6184              STR      r4,[r0,#0x18]
;;;4883     
;;;4884     /* Set the Capture Compare Register value */
;;;4885     TIMx->CCR2 = OC_Config->Pulse;
000068  684d              LDR      r5,[r1,#4]
00006a  6385              STR      r5,[r0,#0x38]
;;;4886     
;;;4887     /* Write to TIMx CCER */
;;;4888     TIMx->CCER = tmpccer;
00006c  6202              STR      r2,[r0,#0x20]
;;;4889   }
00006e  bd30              POP      {r4,r5,pc}
;;;4890   
                          ENDP

                  |L97.112|
                          DCD      0xfeff8fff
                  |L97.116|
                          DCD      0x40010000
                  |L97.120|
                          DCD      0x40010400

                          AREA ||i.TIM_OC3_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC3_SetConfig PROC
;;;4896     */
;;;4897   void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b530              PUSH     {r4,r5,lr}
;;;4898   {
;;;4899     uint32_t tmpccmrx = 0;
000002  2400              MOVS     r4,#0
;;;4900     uint32_t tmpccer = 0;
000004  2200              MOVS     r2,#0
;;;4901     uint32_t tmpcr2 = 0;   
000006  2300              MOVS     r3,#0
;;;4902   
;;;4903     /* Disable the Channel 3: Reset the CC2E Bit */
;;;4904     TIMx->CCER &= ~TIM_CCER_CC3E;
000008  6a05              LDR      r5,[r0,#0x20]
00000a  f4257580          BIC      r5,r5,#0x100
00000e  6205              STR      r5,[r0,#0x20]
;;;4905     
;;;4906     /* Get the TIMx CCER register value */
;;;4907     tmpccer = TIMx->CCER;
000010  6a02              LDR      r2,[r0,#0x20]
;;;4908     /* Get the TIMx CR2 register value */
;;;4909     tmpcr2 = TIMx->CR2;
000012  6843              LDR      r3,[r0,#4]
;;;4910     
;;;4911     /* Get the TIMx CCMR2 register value */
;;;4912     tmpccmrx = TIMx->CCMR2;
000014  69c4              LDR      r4,[r0,#0x1c]
;;;4913       
;;;4914     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;4915     tmpccmrx &= ~TIM_CCMR2_OC3M;
000016  4d16              LDR      r5,|L98.112|
000018  402c              ANDS     r4,r4,r5
;;;4916     tmpccmrx &= ~TIM_CCMR2_CC3S;  
00001a  f0240403          BIC      r4,r4,#3
;;;4917     /* Select the Output Compare Mode */
;;;4918     tmpccmrx |= OC_Config->OCMode;
00001e  680d              LDR      r5,[r1,#0]
000020  432c              ORRS     r4,r4,r5
;;;4919     
;;;4920     /* Reset the Output Polarity level */
;;;4921     tmpccer &= ~TIM_CCER_CC3P;
000022  f4227200          BIC      r2,r2,#0x200
;;;4922     /* Set the Output Compare Polarity */
;;;4923     tmpccer |= (OC_Config->OCPolarity << 8);
000026  688d              LDR      r5,[r1,#8]
000028  ea422205          ORR      r2,r2,r5,LSL #8
;;;4924       
;;;4925     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
00002c  4d11              LDR      r5,|L98.116|
00002e  42a8              CMP      r0,r5
000030  d002              BEQ      |L98.56|
000032  4d11              LDR      r5,|L98.120|
000034  42a8              CMP      r0,r5
000036  d101              BNE      |L98.60|
                  |L98.56|
000038  2501              MOVS     r5,#1
00003a  e000              B        |L98.62|
                  |L98.60|
00003c  2500              MOVS     r5,#0
                  |L98.62|
00003e  b185              CBZ      r5,|L98.98|
;;;4926     {
;;;4927       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;4928       
;;;4929       /* Reset the Output N Polarity level */
;;;4930       tmpccer &= ~TIM_CCER_CC3NP;
000040  f4226200          BIC      r2,r2,#0x800
;;;4931       /* Set the Output N Polarity */
;;;4932       tmpccer |= (OC_Config->OCNPolarity << 8);
000044  68cd              LDR      r5,[r1,#0xc]
000046  ea422205          ORR      r2,r2,r5,LSL #8
;;;4933       /* Reset the Output N State */
;;;4934       tmpccer &= ~TIM_CCER_CC3NE;
00004a  f4226280          BIC      r2,r2,#0x400
;;;4935       
;;;4936       /* Reset the Output Compare and Output Compare N IDLE State */
;;;4937       tmpcr2 &= ~TIM_CR2_OIS3;
00004e  f4235380          BIC      r3,r3,#0x1000
;;;4938       tmpcr2 &= ~TIM_CR2_OIS3N;
000052  f4235300          BIC      r3,r3,#0x2000
;;;4939       /* Set the Output Idle state */
;;;4940       tmpcr2 |= (OC_Config->OCIdleState << 4);
000056  694d              LDR      r5,[r1,#0x14]
000058  ea431305          ORR      r3,r3,r5,LSL #4
;;;4941       /* Set the Output N Idle state */
;;;4942       tmpcr2 |= (OC_Config->OCNIdleState << 4);
00005c  698d              LDR      r5,[r1,#0x18]
00005e  ea431305          ORR      r3,r3,r5,LSL #4
                  |L98.98|
;;;4943     }
;;;4944     /* Write to TIMx CR2 */
;;;4945     TIMx->CR2 = tmpcr2;
000062  6043              STR      r3,[r0,#4]
;;;4946     
;;;4947     /* Write to TIMx CCMR2 */
;;;4948     TIMx->CCMR2 = tmpccmrx;
000064  61c4              STR      r4,[r0,#0x1c]
;;;4949     
;;;4950     /* Set the Capture Compare Register value */
;;;4951     TIMx->CCR3 = OC_Config->Pulse;
000066  684d              LDR      r5,[r1,#4]
000068  63c5              STR      r5,[r0,#0x3c]
;;;4952     
;;;4953     /* Write to TIMx CCER */
;;;4954     TIMx->CCER = tmpccer;
00006a  6202              STR      r2,[r0,#0x20]
;;;4955   }
00006c  bd30              POP      {r4,r5,pc}
;;;4956   
                          ENDP

00006e  0000              DCW      0x0000
                  |L98.112|
                          DCD      0xfffeff8f
                  |L98.116|
                          DCD      0x40010000
                  |L98.120|
                          DCD      0x40010400

                          AREA ||i.TIM_OC4_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC4_SetConfig PROC
;;;4962     */
;;;4963   void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b530              PUSH     {r4,r5,lr}
;;;4964   {
;;;4965     uint32_t tmpccmrx = 0;
000002  2200              MOVS     r2,#0
;;;4966     uint32_t tmpccer = 0;
000004  2300              MOVS     r3,#0
;;;4967     uint32_t tmpcr2 = 0;
000006  2400              MOVS     r4,#0
;;;4968   
;;;4969     /* Disable the Channel 4: Reset the CC4E Bit */
;;;4970     TIMx->CCER &= ~TIM_CCER_CC4E;
000008  6a05              LDR      r5,[r0,#0x20]
00000a  f4255580          BIC      r5,r5,#0x1000
00000e  6205              STR      r5,[r0,#0x20]
;;;4971     
;;;4972     /* Get the TIMx CCER register value */
;;;4973     tmpccer = TIMx->CCER;
000010  6a03              LDR      r3,[r0,#0x20]
;;;4974     /* Get the TIMx CR2 register value */
;;;4975     tmpcr2 = TIMx->CR2;
000012  6844              LDR      r4,[r0,#4]
;;;4976     
;;;4977     /* Get the TIMx CCMR2 register value */
;;;4978     tmpccmrx = TIMx->CCMR2;
000014  69c2              LDR      r2,[r0,#0x1c]
;;;4979       
;;;4980     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;4981     tmpccmrx &= ~TIM_CCMR2_OC4M;
000016  4d10              LDR      r5,|L99.88|
000018  402a              ANDS     r2,r2,r5
;;;4982     tmpccmrx &= ~TIM_CCMR2_CC4S;
00001a  f4227240          BIC      r2,r2,#0x300
;;;4983     
;;;4984     /* Select the Output Compare Mode */
;;;4985     tmpccmrx |= (OC_Config->OCMode << 8);
00001e  680d              LDR      r5,[r1,#0]
000020  ea422205          ORR      r2,r2,r5,LSL #8
;;;4986     
;;;4987     /* Reset the Output Polarity level */
;;;4988     tmpccer &= ~TIM_CCER_CC4P;
000024  f4235300          BIC      r3,r3,#0x2000
;;;4989     /* Set the Output Compare Polarity */
;;;4990     tmpccer |= (OC_Config->OCPolarity << 12);
000028  688d              LDR      r5,[r1,#8]
00002a  ea433305          ORR      r3,r3,r5,LSL #12
;;;4991      
;;;4992     /*if((TIMx == TIM1) || (TIMx == TIM8))*/
;;;4993     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
00002e  4d0b              LDR      r5,|L99.92|
000030  42a8              CMP      r0,r5
000032  d002              BEQ      |L99.58|
000034  4d0a              LDR      r5,|L99.96|
000036  42a8              CMP      r0,r5
000038  d101              BNE      |L99.62|
                  |L99.58|
00003a  2501              MOVS     r5,#1
00003c  e000              B        |L99.64|
                  |L99.62|
00003e  2500              MOVS     r5,#0
                  |L99.64|
000040  b125              CBZ      r5,|L99.76|
;;;4994     {
;;;4995       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;4996       /* Reset the Output Compare IDLE State */
;;;4997       tmpcr2 &= ~TIM_CR2_OIS4;
000042  f4244480          BIC      r4,r4,#0x4000
;;;4998       /* Set the Output Idle state */
;;;4999       tmpcr2 |= (OC_Config->OCIdleState << 6);
000046  694d              LDR      r5,[r1,#0x14]
000048  ea441485          ORR      r4,r4,r5,LSL #6
                  |L99.76|
;;;5000     }
;;;5001     /* Write to TIMx CR2 */
;;;5002     TIMx->CR2 = tmpcr2;
00004c  6044              STR      r4,[r0,#4]
;;;5003     
;;;5004     /* Write to TIMx CCMR2 */  
;;;5005     TIMx->CCMR2 = tmpccmrx;
00004e  61c2              STR      r2,[r0,#0x1c]
;;;5006       
;;;5007     /* Set the Capture Compare Register value */
;;;5008     TIMx->CCR4 = OC_Config->Pulse;
000050  684d              LDR      r5,[r1,#4]
000052  6405              STR      r5,[r0,#0x40]
;;;5009     
;;;5010     /* Write to TIMx CCER */
;;;5011     TIMx->CCER = tmpccer;
000054  6203              STR      r3,[r0,#0x20]
;;;5012   }
000056  bd30              POP      {r4,r5,pc}
;;;5013   
                          ENDP

                  |L99.88|
                          DCD      0xfeff8fff
                  |L99.92|
                          DCD      0x40010000
                  |L99.96|
                          DCD      0x40010400

                          AREA ||i.TIM_SlaveTimer_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_SlaveTimer_SetConfig PROC
;;;5020     */
;;;5021   static void TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;5022                                 TIM_SlaveConfigTypeDef * sSlaveConfig)
;;;5023   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;5024     uint32_t tmpsmcr = 0;
000008  2600              MOVS     r6,#0
;;;5025     uint32_t tmpccmr1 = 0;
00000a  2700              MOVS     r7,#0
;;;5026     uint32_t tmpccer = 0;
00000c  46b0              MOV      r8,r6
;;;5027   
;;;5028    /* Get the TIMx SMCR register value */
;;;5029     tmpsmcr = htim->Instance->SMCR;
00000e  6820              LDR      r0,[r4,#0]
000010  6886              LDR      r6,[r0,#8]
;;;5030   
;;;5031     /* Reset the Trigger Selection Bits */
;;;5032     tmpsmcr &= ~TIM_SMCR_TS;
000012  f0260670          BIC      r6,r6,#0x70
;;;5033     /* Set the Input Trigger source */
;;;5034     tmpsmcr |= sSlaveConfig->InputTrigger;
000016  6868              LDR      r0,[r5,#4]
000018  4306              ORRS     r6,r6,r0
;;;5035   
;;;5036     /* Reset the slave mode Bits */
;;;5037     tmpsmcr &= ~TIM_SMCR_SMS;
00001a  4822              LDR      r0,|L100.164|
00001c  4006              ANDS     r6,r6,r0
;;;5038     /* Set the slave mode */
;;;5039     tmpsmcr |= sSlaveConfig->SlaveMode;
00001e  6828              LDR      r0,[r5,#0]
000020  4306              ORRS     r6,r6,r0
;;;5040   
;;;5041     /* Write to TIMx SMCR */
;;;5042     htim->Instance->SMCR = tmpsmcr;
000022  6820              LDR      r0,[r4,#0]
000024  6086              STR      r6,[r0,#8]
;;;5043    
;;;5044     /* Configure the trigger prescaler, filter, and polarity */
;;;5045     switch (sSlaveConfig->InputTrigger)
000026  6868              LDR      r0,[r5,#4]
000028  f000010f          AND      r1,r0,#0xf
00002c  2900              CMP      r1,#0
00002e  d135              BNE      |L100.156|
000030  1100              ASRS     r0,r0,#4
000032  2808              CMP      r0,#8
000034  d232              BCS      |L100.156|
000036  e8dff000          TBB      [pc,r0]
00003a  2d2e              DCB      0x2d,0x2e
00003c  2f300b21          DCB      0x2f,0x30,0x0b,0x21
000040  2704              DCB      0x27,0x04
;;;5046     {
;;;5047     case TIM_TS_ETRF:
;;;5048       {
;;;5049         /* Check the parameters */
;;;5050         assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
;;;5051         assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
;;;5052         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;5053         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;5054         /* Configure the ETR Trigger source */
;;;5055         TIM_ETR_SetConfig(htim->Instance, 
000042  e9d51303          LDRD     r1,r3,[r5,#0xc]
000046  68aa              LDR      r2,[r5,#8]
000048  6820              LDR      r0,[r4,#0]
00004a  f7fffffe          BL       TIM_ETR_SetConfig
;;;5056                           sSlaveConfig->TriggerPrescaler, 
;;;5057                           sSlaveConfig->TriggerPolarity, 
;;;5058                           sSlaveConfig->TriggerFilter);
;;;5059       }
;;;5060       break;
00004e  e026              B        |L100.158|
;;;5061       
;;;5062     case TIM_TS_TI1F_ED:
;;;5063       {
;;;5064         /* Check the parameters */
;;;5065         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;5066         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;5067         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;5068     
;;;5069         /* Disable the Channel 1: Reset the CC1E Bit */
;;;5070         tmpccer = htim->Instance->CCER;
000050  6820              LDR      r0,[r4,#0]
000052  f8d08020          LDR      r8,[r0,#0x20]
;;;5071         htim->Instance->CCER &= ~TIM_CCER_CC1E;
000056  6820              LDR      r0,[r4,#0]
000058  6a00              LDR      r0,[r0,#0x20]
00005a  f0200001          BIC      r0,r0,#1
00005e  6821              LDR      r1,[r4,#0]
000060  6208              STR      r0,[r1,#0x20]
;;;5072         tmpccmr1 = htim->Instance->CCMR1;    
000062  6820              LDR      r0,[r4,#0]
000064  6987              LDR      r7,[r0,#0x18]
;;;5073         
;;;5074         /* Set the filter */
;;;5075         tmpccmr1 &= ~TIM_CCMR1_IC1F;
000066  f02707f0          BIC      r7,r7,#0xf0
;;;5076         tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4);
00006a  6928              LDR      r0,[r5,#0x10]
00006c  ea471700          ORR      r7,r7,r0,LSL #4
;;;5077         
;;;5078         /* Write to TIMx CCMR1 and CCER registers */
;;;5079         htim->Instance->CCMR1 = tmpccmr1;
000070  6820              LDR      r0,[r4,#0]
000072  6187              STR      r7,[r0,#0x18]
;;;5080         htim->Instance->CCER = tmpccer;                               
000074  6820              LDR      r0,[r4,#0]
000076  f8c08020          STR      r8,[r0,#0x20]
;;;5081                                  
;;;5082       }
;;;5083       break;
00007a  e010              B        |L100.158|
;;;5084       
;;;5085     case TIM_TS_TI1FP1:
;;;5086       {
;;;5087         /* Check the parameters */
;;;5088         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;5089         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;5090         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;5091   
;;;5092         /* Configure TI1 Filter and Polarity */
;;;5093         TIM_TI1_ConfigInputStage(htim->Instance,
00007c  692a              LDR      r2,[r5,#0x10]
00007e  68a9              LDR      r1,[r5,#8]
000080  6820              LDR      r0,[r4,#0]
000082  f7fffffe          BL       TIM_TI1_ConfigInputStage
;;;5094                                  sSlaveConfig->TriggerPolarity,
;;;5095                                  sSlaveConfig->TriggerFilter);
;;;5096       }
;;;5097       break;
000086  e00a              B        |L100.158|
;;;5098       
;;;5099     case TIM_TS_TI2FP2:
;;;5100       {
;;;5101         /* Check the parameters */
;;;5102         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5103         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;5104         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;5105     
;;;5106         /* Configure TI2 Filter and Polarity */
;;;5107         TIM_TI2_ConfigInputStage(htim->Instance,
000088  692a              LDR      r2,[r5,#0x10]
00008a  68a9              LDR      r1,[r5,#8]
00008c  6820              LDR      r0,[r4,#0]
00008e  f7fffffe          BL       TIM_TI2_ConfigInputStage
;;;5108                                   sSlaveConfig->TriggerPolarity,
;;;5109                                   sSlaveConfig->TriggerFilter);
;;;5110       }
;;;5111       break;
000092  e004              B        |L100.158|
;;;5112       
;;;5113     case TIM_TS_ITR0:
;;;5114       {
;;;5115         /* Check the parameter */
;;;5116         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5117       }
;;;5118       break;
000094  e003              B        |L100.158|
;;;5119       
;;;5120     case TIM_TS_ITR1:
;;;5121       {
;;;5122         /* Check the parameter */
;;;5123         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5124       }
;;;5125       break;
000096  e002              B        |L100.158|
;;;5126       
;;;5127     case TIM_TS_ITR2:
;;;5128       {
;;;5129         /* Check the parameter */
;;;5130         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5131       }
;;;5132       break;
000098  e001              B        |L100.158|
;;;5133       
;;;5134     case TIM_TS_ITR3:
;;;5135       {
;;;5136         /* Check the parameter */
;;;5137         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5138       }
;;;5139       break;
00009a  e000              B        |L100.158|
                  |L100.156|
;;;5140          
;;;5141     default:
;;;5142       break;
00009c  bf00              NOP      
                  |L100.158|
00009e  bf00              NOP                            ;5060
;;;5143     }
;;;5144   }
0000a0  e8bd81f0          POP      {r4-r8,pc}
;;;5145   
                          ENDP

                  |L100.164|
                          DCD      0xfffefff8

                          AREA ||i.TIM_TI1_ConfigInputStage||, CODE, READONLY, ALIGN=1

                  TIM_TI1_ConfigInputStage PROC
;;;5212     */
;;;5213   static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
000000  b530              PUSH     {r4,r5,lr}
;;;5214   {
000002  460b              MOV      r3,r1
000004  4614              MOV      r4,r2
;;;5215     uint32_t tmpccmr1 = 0;
000006  2100              MOVS     r1,#0
;;;5216     uint32_t tmpccer = 0;
000008  2200              MOVS     r2,#0
;;;5217     
;;;5218     /* Disable the Channel 1: Reset the CC1E Bit */
;;;5219     tmpccer = TIMx->CCER;
00000a  6a02              LDR      r2,[r0,#0x20]
;;;5220     TIMx->CCER &= ~TIM_CCER_CC1E;
00000c  6a05              LDR      r5,[r0,#0x20]
00000e  f0250501          BIC      r5,r5,#1
000012  6205              STR      r5,[r0,#0x20]
;;;5221     tmpccmr1 = TIMx->CCMR1;    
000014  6981              LDR      r1,[r0,#0x18]
;;;5222     
;;;5223     /* Set the filter */
;;;5224     tmpccmr1 &= ~TIM_CCMR1_IC1F;
000016  f02101f0          BIC      r1,r1,#0xf0
;;;5225     tmpccmr1 |= (TIM_ICFilter << 4);
00001a  ea411104          ORR      r1,r1,r4,LSL #4
;;;5226     
;;;5227     /* Select the Polarity and set the CC1E Bit */
;;;5228     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
00001e  f022020a          BIC      r2,r2,#0xa
;;;5229     tmpccer |= TIM_ICPolarity;
000022  431a              ORRS     r2,r2,r3
;;;5230     
;;;5231     /* Write to TIMx CCMR1 and CCER registers */
;;;5232     TIMx->CCMR1 = tmpccmr1;
000024  6181              STR      r1,[r0,#0x18]
;;;5233     TIMx->CCER = tmpccer;
000026  6202              STR      r2,[r0,#0x20]
;;;5234   }
000028  bd30              POP      {r4,r5,pc}
;;;5235   
                          ENDP


                          AREA ||i.TIM_TI1_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_TI1_SetConfig PROC
;;;5165     */
;;;5166   void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b570              PUSH     {r4-r6,lr}
;;;5167                          uint32_t TIM_ICFilter)
;;;5168   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;5169     uint32_t tmpccmr1 = 0;
000006  2100              MOVS     r1,#0
;;;5170     uint32_t tmpccer = 0;
000008  2200              MOVS     r2,#0
;;;5171   
;;;5172     /* Disable the Channel 1: Reset the CC1E Bit */
;;;5173     TIMx->CCER &= ~TIM_CCER_CC1E;
00000a  6a06              LDR      r6,[r0,#0x20]
00000c  f0260601          BIC      r6,r6,#1
000010  6206              STR      r6,[r0,#0x20]
;;;5174     tmpccmr1 = TIMx->CCMR1;
000012  6981              LDR      r1,[r0,#0x18]
;;;5175     tmpccer = TIMx->CCER;
000014  6a02              LDR      r2,[r0,#0x20]
;;;5176   
;;;5177     /* Select the Input */
;;;5178     if(IS_TIM_CC2_INSTANCE(TIMx) != RESET)
000016  4e18              LDR      r6,|L102.120|
000018  42b0              CMP      r0,r6
00001a  d014              BEQ      |L102.70|
00001c  f1b04f80          CMP      r0,#0x40000000
000020  d011              BEQ      |L102.70|
000022  4e16              LDR      r6,|L102.124|
000024  42b0              CMP      r0,r6
000026  d00e              BEQ      |L102.70|
000028  4e15              LDR      r6,|L102.128|
00002a  42b0              CMP      r0,r6
00002c  d00b              BEQ      |L102.70|
00002e  4e15              LDR      r6,|L102.132|
000030  42b0              CMP      r0,r6
000032  d008              BEQ      |L102.70|
000034  4e14              LDR      r6,|L102.136|
000036  42b0              CMP      r0,r6
000038  d005              BEQ      |L102.70|
00003a  4e14              LDR      r6,|L102.140|
00003c  42b0              CMP      r0,r6
00003e  d002              BEQ      |L102.70|
000040  4e13              LDR      r6,|L102.144|
000042  42b0              CMP      r0,r6
000044  d101              BNE      |L102.74|
                  |L102.70|
000046  2601              MOVS     r6,#1
000048  e000              B        |L102.76|
                  |L102.74|
00004a  2600              MOVS     r6,#0
                  |L102.76|
00004c  b11e              CBZ      r6,|L102.86|
;;;5179     {
;;;5180       tmpccmr1 &= ~TIM_CCMR1_CC1S;
00004e  f0210103          BIC      r1,r1,#3
;;;5181       tmpccmr1 |= TIM_ICSelection;
000052  4329              ORRS     r1,r1,r5
000054  e001              B        |L102.90|
                  |L102.86|
;;;5182     } 
;;;5183     else
;;;5184     {
;;;5185       tmpccmr1 |= TIM_CCMR1_CC1S_0;
000056  f0410101          ORR      r1,r1,#1
                  |L102.90|
;;;5186     }
;;;5187     
;;;5188     /* Set the filter */
;;;5189     tmpccmr1 &= ~TIM_CCMR1_IC1F;
00005a  f02101f0          BIC      r1,r1,#0xf0
;;;5190     tmpccmr1 |= ((TIM_ICFilter << 4) & TIM_CCMR1_IC1F);
00005e  26f0              MOVS     r6,#0xf0
000060  ea061603          AND      r6,r6,r3,LSL #4
000064  4331              ORRS     r1,r1,r6
;;;5191   
;;;5192     /* Select the Polarity and set the CC1E Bit */
;;;5193     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
000066  f022020a          BIC      r2,r2,#0xa
;;;5194     tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
00006a  f004060a          AND      r6,r4,#0xa
00006e  4332              ORRS     r2,r2,r6
;;;5195   
;;;5196     /* Write to TIMx CCMR1 and CCER registers */
;;;5197     TIMx->CCMR1 = tmpccmr1;
000070  6181              STR      r1,[r0,#0x18]
;;;5198     TIMx->CCER = tmpccer;
000072  6202              STR      r2,[r0,#0x20]
;;;5199   }
000074  bd70              POP      {r4-r6,pc}
;;;5200   
                          ENDP

000076  0000              DCW      0x0000
                  |L102.120|
                          DCD      0x40010000
                  |L102.124|
                          DCD      0x40000400
                  |L102.128|
                          DCD      0x40000800
                  |L102.132|
                          DCD      0x40000c00
                  |L102.136|
                          DCD      0x40010400
                  |L102.140|
                          DCD      0x40014000
                  |L102.144|
                          DCD      0x40001800

                          AREA ||i.TIM_TI2_ConfigInputStage||, CODE, READONLY, ALIGN=1

                  TIM_TI2_ConfigInputStage PROC
;;;5295     */
;;;5296   static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
000000  b530              PUSH     {r4,r5,lr}
;;;5297   {
000002  460b              MOV      r3,r1
000004  4614              MOV      r4,r2
;;;5298   uint32_t tmpccmr1 = 0;
000006  2100              MOVS     r1,#0
;;;5299     uint32_t tmpccer = 0;
000008  2200              MOVS     r2,#0
;;;5300     
;;;5301     /* Disable the Channel 2: Reset the CC2E Bit */
;;;5302     TIMx->CCER &= ~TIM_CCER_CC2E;
00000a  6a05              LDR      r5,[r0,#0x20]
00000c  f0250510          BIC      r5,r5,#0x10
000010  6205              STR      r5,[r0,#0x20]
;;;5303     tmpccmr1 = TIMx->CCMR1;
000012  6981              LDR      r1,[r0,#0x18]
;;;5304     tmpccer = TIMx->CCER;
000014  6a02              LDR      r2,[r0,#0x20]
;;;5305     
;;;5306     /* Set the filter */
;;;5307     tmpccmr1 &= ~TIM_CCMR1_IC2F;
000016  f4214170          BIC      r1,r1,#0xf000
;;;5308     tmpccmr1 |= (TIM_ICFilter << 12);
00001a  ea413104          ORR      r1,r1,r4,LSL #12
;;;5309   
;;;5310     /* Select the Polarity and set the CC2E Bit */
;;;5311     tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
00001e  f02202a0          BIC      r2,r2,#0xa0
;;;5312     tmpccer |= (TIM_ICPolarity << 4);
000022  ea421203          ORR      r2,r2,r3,LSL #4
;;;5313   
;;;5314     /* Write to TIMx CCMR1 and CCER registers */
;;;5315     TIMx->CCMR1 = tmpccmr1 ;
000026  6181              STR      r1,[r0,#0x18]
;;;5316     TIMx->CCER = tmpccer;
000028  6202              STR      r2,[r0,#0x20]
;;;5317   }
00002a  bd30              POP      {r4,r5,pc}
;;;5318   
                          ENDP


                          AREA ||i.TIM_TI2_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_TI2_SetConfig PROC
;;;5255     */
;;;5256   static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b570              PUSH     {r4-r6,lr}
;;;5257                          uint32_t TIM_ICFilter)
;;;5258   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;5259     uint32_t tmpccmr1 = 0;
000006  2100              MOVS     r1,#0
;;;5260     uint32_t tmpccer = 0;
000008  2200              MOVS     r2,#0
;;;5261   
;;;5262     /* Disable the Channel 2: Reset the CC2E Bit */
;;;5263     TIMx->CCER &= ~TIM_CCER_CC2E;
00000a  6a06              LDR      r6,[r0,#0x20]
00000c  f0260610          BIC      r6,r6,#0x10
000010  6206              STR      r6,[r0,#0x20]
;;;5264     tmpccmr1 = TIMx->CCMR1;
000012  6981              LDR      r1,[r0,#0x18]
;;;5265     tmpccer = TIMx->CCER;
000014  6a02              LDR      r2,[r0,#0x20]
;;;5266   
;;;5267     /* Select the Input */
;;;5268     tmpccmr1 &= ~TIM_CCMR1_CC2S;
000016  f4217140          BIC      r1,r1,#0x300
;;;5269     tmpccmr1 |= (TIM_ICSelection << 8);
00001a  ea412105          ORR      r1,r1,r5,LSL #8
;;;5270   
;;;5271     /* Set the filter */
;;;5272     tmpccmr1 &= ~TIM_CCMR1_IC2F;
00001e  f4214170          BIC      r1,r1,#0xf000
;;;5273     tmpccmr1 |= ((TIM_ICFilter << 12) & TIM_CCMR1_IC2F);
000022  f44f4670          MOV      r6,#0xf000
000026  ea063603          AND      r6,r6,r3,LSL #12
00002a  4331              ORRS     r1,r1,r6
;;;5274   
;;;5275     /* Select the Polarity and set the CC2E Bit */
;;;5276     tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
00002c  f02202a0          BIC      r2,r2,#0xa0
;;;5277     tmpccer |= ((TIM_ICPolarity << 4) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
000030  26a0              MOVS     r6,#0xa0
000032  ea061604          AND      r6,r6,r4,LSL #4
000036  4332              ORRS     r2,r2,r6
;;;5278   
;;;5279     /* Write to TIMx CCMR1 and CCER registers */
;;;5280     TIMx->CCMR1 = tmpccmr1 ;
000038  6181              STR      r1,[r0,#0x18]
;;;5281     TIMx->CCER = tmpccer;
00003a  6202              STR      r2,[r0,#0x20]
;;;5282   }
00003c  bd70              POP      {r4-r6,pc}
;;;5283   
                          ENDP


                          AREA ||i.TIM_TI3_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_TI3_SetConfig PROC
;;;5338     */
;;;5339   static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b570              PUSH     {r4-r6,lr}
;;;5340                          uint32_t TIM_ICFilter)
;;;5341   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;5342     uint32_t tmpccmr2 = 0;
000006  2100              MOVS     r1,#0
;;;5343     uint32_t tmpccer = 0;
000008  2200              MOVS     r2,#0
;;;5344   
;;;5345     /* Disable the Channel 3: Reset the CC3E Bit */
;;;5346     TIMx->CCER &= ~TIM_CCER_CC3E;
00000a  6a06              LDR      r6,[r0,#0x20]
00000c  f4267680          BIC      r6,r6,#0x100
000010  6206              STR      r6,[r0,#0x20]
;;;5347     tmpccmr2 = TIMx->CCMR2;
000012  69c1              LDR      r1,[r0,#0x1c]
;;;5348     tmpccer = TIMx->CCER;
000014  6a02              LDR      r2,[r0,#0x20]
;;;5349   
;;;5350     /* Select the Input */
;;;5351     tmpccmr2 &= ~TIM_CCMR2_CC3S;
000016  f0210103          BIC      r1,r1,#3
;;;5352     tmpccmr2 |= TIM_ICSelection;
00001a  4329              ORRS     r1,r1,r5
;;;5353   
;;;5354     /* Set the filter */
;;;5355     tmpccmr2 &= ~TIM_CCMR2_IC3F;
00001c  f02101f0          BIC      r1,r1,#0xf0
;;;5356     tmpccmr2 |= ((TIM_ICFilter << 4) & TIM_CCMR2_IC3F);
000020  26f0              MOVS     r6,#0xf0
000022  ea061603          AND      r6,r6,r3,LSL #4
000026  4331              ORRS     r1,r1,r6
;;;5357   
;;;5358     /* Select the Polarity and set the CC3E Bit */
;;;5359     tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
000028  f4226220          BIC      r2,r2,#0xa00
;;;5360     tmpccer |= ((TIM_ICPolarity << 8) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
00002c  f44f6620          MOV      r6,#0xa00
000030  ea062604          AND      r6,r6,r4,LSL #8
000034  4332              ORRS     r2,r2,r6
;;;5361   
;;;5362     /* Write to TIMx CCMR2 and CCER registers */
;;;5363     TIMx->CCMR2 = tmpccmr2;
000036  61c1              STR      r1,[r0,#0x1c]
;;;5364     TIMx->CCER = tmpccer;
000038  6202              STR      r2,[r0,#0x20]
;;;5365   }
00003a  bd70              POP      {r4-r6,pc}
;;;5366   
                          ENDP


                          AREA ||i.TIM_TI4_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_TI4_SetConfig PROC
;;;5386     */
;;;5387   static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b570              PUSH     {r4-r6,lr}
;;;5388                          uint32_t TIM_ICFilter)
;;;5389   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;5390     uint32_t tmpccmr2 = 0;
000006  2100              MOVS     r1,#0
;;;5391     uint32_t tmpccer = 0;
000008  2200              MOVS     r2,#0
;;;5392   
;;;5393     /* Disable the Channel 4: Reset the CC4E Bit */
;;;5394     TIMx->CCER &= ~TIM_CCER_CC4E;
00000a  6a06              LDR      r6,[r0,#0x20]
00000c  f4265680          BIC      r6,r6,#0x1000
000010  6206              STR      r6,[r0,#0x20]
;;;5395     tmpccmr2 = TIMx->CCMR2;
000012  69c1              LDR      r1,[r0,#0x1c]
;;;5396     tmpccer = TIMx->CCER;
000014  6a02              LDR      r2,[r0,#0x20]
;;;5397   
;;;5398     /* Select the Input */
;;;5399     tmpccmr2 &= ~TIM_CCMR2_CC4S;
000016  f4217140          BIC      r1,r1,#0x300
;;;5400     tmpccmr2 |= (TIM_ICSelection << 8);
00001a  ea412105          ORR      r1,r1,r5,LSL #8
;;;5401   
;;;5402     /* Set the filter */
;;;5403     tmpccmr2 &= ~TIM_CCMR2_IC4F;
00001e  f4214170          BIC      r1,r1,#0xf000
;;;5404     tmpccmr2 |= ((TIM_ICFilter << 12) & TIM_CCMR2_IC4F);
000022  f44f4670          MOV      r6,#0xf000
000026  ea063603          AND      r6,r6,r3,LSL #12
00002a  4331              ORRS     r1,r1,r6
;;;5405   
;;;5406     /* Select the Polarity and set the CC4E Bit */
;;;5407     tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
00002c  f4224220          BIC      r2,r2,#0xa000
;;;5408     tmpccer |= ((TIM_ICPolarity << 12) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
000030  f44f4620          MOV      r6,#0xa000
000034  ea063604          AND      r6,r6,r4,LSL #12
000038  4332              ORRS     r2,r2,r6
;;;5409   
;;;5410     /* Write to TIMx CCMR2 and CCER registers */
;;;5411     TIMx->CCMR2 = tmpccmr2;
00003a  61c1              STR      r1,[r0,#0x1c]
;;;5412     TIMx->CCER = tmpccer ;
00003c  6202              STR      r2,[r0,#0x20]
;;;5413   }
00003e  bd70              POP      {r4-r6,pc}
;;;5414   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_tim.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_tim_c_a9d95b52____REV16|
#line 388 "..\\..\\..\\..\\Library\\STM32F7xx_HAL_Driver\\Core\\cmsis_armcc.h"
|__asm___19_stm32f7xx_hal_tim_c_a9d95b52____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_tim_c_a9d95b52____REVSH|
#line 402
|__asm___19_stm32f7xx_hal_tim_c_a9d95b52____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_tim_c_a9d95b52____RRX|
#line 587
|__asm___19_stm32f7xx_hal_tim_c_a9d95b52____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
