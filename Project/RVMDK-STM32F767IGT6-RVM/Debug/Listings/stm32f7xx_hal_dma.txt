; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f7xx_hal_dma.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f7xx_hal_dma.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\..\Library\STM32F7xx_HAL_Driver\Core -I..\..\..\..\Library\STM32F7xx_HAL_Driver\Inc -I..\..\..\..\Library\STM32F7xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\32-Bit_MCU\STM32\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f7xx_hal_dma.crf ..\..\..\..\Library\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_dma.c]
                          THUMB

                          AREA ||i.DMA_CalcBaseAndBitshift||, CODE, READONLY, ALIGN=2

                  DMA_CalcBaseAndBitshift PROC
;;;1189     */
;;;1190   static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
000000  4601              MOV      r1,r0
;;;1191   {
;;;1192     uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
000002  7808              LDRB     r0,[r1,#0]
000004  3810              SUBS     r0,r0,#0x10
000006  2318              MOVS     r3,#0x18
000008  fbb0f2f3          UDIV     r2,r0,r3
;;;1193     
;;;1194     /* lookup table for necessary bitshift of flags within status registers */
;;;1195     static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
;;;1196     hdma->StreamIndex = flagBitshiftOffset[stream_number];
00000c  4808              LDR      r0,|L1.48|
00000e  5c80              LDRB     r0,[r0,r2]
000010  6608              STR      r0,[r1,#0x60]
;;;1197     
;;;1198     if (stream_number > 3U)
000012  2a03              CMP      r2,#3
000014  d905              BLS      |L1.34|
;;;1199     {
;;;1200       /* return pointer to HISR and HIFCR */
;;;1201       hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
000016  6808              LDR      r0,[r1,#0]
000018  f36f0009          BFC      r0,#0,#10
00001c  1d00              ADDS     r0,r0,#4
00001e  65c8              STR      r0,[r1,#0x5c]
000020  e003              B        |L1.42|
                  |L1.34|
;;;1202     }
;;;1203     else
;;;1204     {
;;;1205       /* return pointer to LISR and LIFCR */
;;;1206       hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
000022  6808              LDR      r0,[r1,#0]
000024  f36f0009          BFC      r0,#0,#10
000028  65c8              STR      r0,[r1,#0x5c]
                  |L1.42|
;;;1207     }
;;;1208     
;;;1209     return hdma->StreamBaseAddress;
00002a  6dc8              LDR      r0,[r1,#0x5c]
;;;1210   }
00002c  4770              BX       lr
;;;1211   
                          ENDP

00002e  0000              DCW      0x0000
                  |L1.48|
                          DCD      flagBitshiftOffset

                          AREA ||i.DMA_CheckFifoParam||, CODE, READONLY, ALIGN=1

                  DMA_CheckFifoParam PROC
;;;1217     */
;;;1218   static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
000000  4601              MOV      r1,r0
;;;1219   {
;;;1220     HAL_StatusTypeDef status = HAL_OK;
000002  2000              MOVS     r0,#0
;;;1221     uint32_t tmp = hdma->Init.FIFOThreshold;
000004  6a8a              LDR      r2,[r1,#0x28]
;;;1222     
;;;1223     /* Memory Data size equal to Byte */
;;;1224     if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
000006  698b              LDR      r3,[r1,#0x18]
000008  bb03              CBNZ     r3,|L2.76|
;;;1225     {
;;;1226       switch (tmp)
00000a  b132              CBZ      r2,|L2.26|
00000c  2a01              CMP      r2,#1
00000e  d00c              BEQ      |L2.42|
000010  2a02              CMP      r2,#2
000012  d010              BEQ      |L2.54|
000014  2a03              CMP      r2,#3
000016  d117              BNE      |L2.72|
000018  e015              B        |L2.70|
                  |L2.26|
;;;1227       {
;;;1228         case DMA_FIFO_THRESHOLD_1QUARTERFULL:
;;;1229           if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
00001a  6acb              LDR      r3,[r1,#0x2c]
00001c  f0037380          AND      r3,r3,#0x1000000
000020  f1b37f80          CMP      r3,#0x1000000
000024  d100              BNE      |L2.40|
;;;1230           {
;;;1231             status = HAL_ERROR;
000026  2001              MOVS     r0,#1
                  |L2.40|
;;;1232           }
;;;1233           break;
000028  e00f              B        |L2.74|
                  |L2.42|
;;;1234         case DMA_FIFO_THRESHOLD_HALFFULL:
;;;1235           if (hdma->Init.MemBurst == DMA_MBURST_INC16)
00002a  6acb              LDR      r3,[r1,#0x2c]
00002c  f1b37fc0          CMP      r3,#0x1800000
000030  d100              BNE      |L2.52|
;;;1236           {
;;;1237             status = HAL_ERROR;
000032  2001              MOVS     r0,#1
                  |L2.52|
;;;1238           }
;;;1239           break;
000034  e009              B        |L2.74|
                  |L2.54|
;;;1240         case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
;;;1241           if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
000036  6acb              LDR      r3,[r1,#0x2c]
000038  f0037380          AND      r3,r3,#0x1000000
00003c  f1b37f80          CMP      r3,#0x1000000
000040  d100              BNE      |L2.68|
;;;1242           {
;;;1243             status = HAL_ERROR;
000042  2001              MOVS     r0,#1
                  |L2.68|
;;;1244           }
;;;1245           break;
000044  e001              B        |L2.74|
                  |L2.70|
;;;1246         case DMA_FIFO_THRESHOLD_FULL:
;;;1247           break;
000046  e000              B        |L2.74|
                  |L2.72|
;;;1248         default:
;;;1249           break;
000048  bf00              NOP      
                  |L2.74|
00004a  e035              B        |L2.184|
                  |L2.76|
;;;1250       }
;;;1251     }
;;;1252     
;;;1253     /* Memory Data size equal to Half-Word */
;;;1254     else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
00004c  698b              LDR      r3,[r1,#0x18]
00004e  f5b35f00          CMP      r3,#0x2000
000052  d11b              BNE      |L2.140|
;;;1255     {
;;;1256       switch (tmp)
000054  b132              CBZ      r2,|L2.100|
000056  2a01              CMP      r2,#1
000058  d006              BEQ      |L2.104|
00005a  2a02              CMP      r2,#2
00005c  d00c              BEQ      |L2.120|
00005e  2a03              CMP      r2,#3
000060  d112              BNE      |L2.136|
000062  e00b              B        |L2.124|
                  |L2.100|
;;;1257       {
;;;1258         case DMA_FIFO_THRESHOLD_1QUARTERFULL:
;;;1259           status = HAL_ERROR;
000064  2001              MOVS     r0,#1
;;;1260           break;
000066  e010              B        |L2.138|
                  |L2.104|
;;;1261         case DMA_FIFO_THRESHOLD_HALFFULL:
;;;1262           if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
000068  6acb              LDR      r3,[r1,#0x2c]
00006a  f0037380          AND      r3,r3,#0x1000000
00006e  f1b37f80          CMP      r3,#0x1000000
000072  d100              BNE      |L2.118|
;;;1263           {
;;;1264             status = HAL_ERROR;
000074  2001              MOVS     r0,#1
                  |L2.118|
;;;1265           }
;;;1266           break;
000076  e008              B        |L2.138|
                  |L2.120|
;;;1267         case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
;;;1268           status = HAL_ERROR;
000078  2001              MOVS     r0,#1
;;;1269           break;
00007a  e006              B        |L2.138|
                  |L2.124|
;;;1270         case DMA_FIFO_THRESHOLD_FULL:
;;;1271           if (hdma->Init.MemBurst == DMA_MBURST_INC16)
00007c  6acb              LDR      r3,[r1,#0x2c]
00007e  f1b37fc0          CMP      r3,#0x1800000
000082  d100              BNE      |L2.134|
;;;1272           {
;;;1273             status = HAL_ERROR;
000084  2001              MOVS     r0,#1
                  |L2.134|
;;;1274           }
;;;1275           break;   
000086  e000              B        |L2.138|
                  |L2.136|
;;;1276         default:
;;;1277           break;
000088  bf00              NOP      
                  |L2.138|
00008a  e015              B        |L2.184|
                  |L2.140|
;;;1278       }
;;;1279     }
;;;1280     
;;;1281     /* Memory Data size equal to Word */
;;;1282     else
;;;1283     {
;;;1284       switch (tmp)
00008c  b132              CBZ      r2,|L2.156|
00008e  2a01              CMP      r2,#1
000090  d005              BEQ      |L2.158|
000092  2a02              CMP      r2,#2
000094  d004              BEQ      |L2.160|
000096  2a03              CMP      r2,#3
000098  d10c              BNE      |L2.180|
00009a  e003              B        |L2.164|
                  |L2.156|
;;;1285       {
;;;1286         case DMA_FIFO_THRESHOLD_1QUARTERFULL:
;;;1287         case DMA_FIFO_THRESHOLD_HALFFULL:
00009c  bf00              NOP      
                  |L2.158|
;;;1288         case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
00009e  bf00              NOP      
                  |L2.160|
;;;1289           status = HAL_ERROR;
0000a0  2001              MOVS     r0,#1
;;;1290           break;
0000a2  e008              B        |L2.182|
                  |L2.164|
;;;1291         case DMA_FIFO_THRESHOLD_FULL:
;;;1292           if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
0000a4  6acb              LDR      r3,[r1,#0x2c]
0000a6  f0037380          AND      r3,r3,#0x1000000
0000aa  f1b37f80          CMP      r3,#0x1000000
0000ae  d100              BNE      |L2.178|
;;;1293           {
;;;1294             status = HAL_ERROR;
0000b0  2001              MOVS     r0,#1
                  |L2.178|
;;;1295           }
;;;1296   		break;
0000b2  e000              B        |L2.182|
                  |L2.180|
;;;1297         default:
;;;1298           break;
0000b4  bf00              NOP      
                  |L2.182|
0000b6  bf00              NOP                            ;1290
                  |L2.184|
;;;1299       }
;;;1300     } 
;;;1301     
;;;1302     return status; 
;;;1303   }
0000b8  4770              BX       lr
;;;1304   
                          ENDP


                          AREA ||i.DMA_SetConfig||, CODE, READONLY, ALIGN=1

                  DMA_SetConfig PROC
;;;1155     */
;;;1156   static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  b530              PUSH     {r4,r5,lr}
;;;1157   {
;;;1158     /* Clear DBM bit */
;;;1159     hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
000002  6804              LDR      r4,[r0,#0]
000004  6824              LDR      r4,[r4,#0]
000006  f4242480          BIC      r4,r4,#0x40000
00000a  6805              LDR      r5,[r0,#0]
00000c  602c              STR      r4,[r5,#0]
;;;1160   
;;;1161     /* Configure DMA Stream data length */
;;;1162     hdma->Instance->NDTR = DataLength;
00000e  6804              LDR      r4,[r0,#0]
000010  6063              STR      r3,[r4,#4]
;;;1163   
;;;1164     /* Peripheral to Memory */
;;;1165     if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
000012  6884              LDR      r4,[r0,#8]
000014  2c40              CMP      r4,#0x40
000016  d104              BNE      |L3.34|
;;;1166     {
;;;1167       /* Configure DMA Stream destination address */
;;;1168       hdma->Instance->PAR = DstAddress;
000018  6804              LDR      r4,[r0,#0]
00001a  60a2              STR      r2,[r4,#8]
;;;1169   
;;;1170       /* Configure DMA Stream source address */
;;;1171       hdma->Instance->M0AR = SrcAddress;
00001c  6804              LDR      r4,[r0,#0]
00001e  60e1              STR      r1,[r4,#0xc]
000020  e003              B        |L3.42|
                  |L3.34|
;;;1172     }
;;;1173     /* Memory to Peripheral */
;;;1174     else
;;;1175     {
;;;1176       /* Configure DMA Stream source address */
;;;1177       hdma->Instance->PAR = SrcAddress;
000022  6804              LDR      r4,[r0,#0]
000024  60a1              STR      r1,[r4,#8]
;;;1178       
;;;1179       /* Configure DMA Stream destination address */
;;;1180       hdma->Instance->M0AR = DstAddress;
000026  6804              LDR      r4,[r0,#0]
000028  60e2              STR      r2,[r4,#0xc]
                  |L3.42|
;;;1181     }
;;;1182   }
00002a  bd30              POP      {r4,r5,pc}
;;;1183   
                          ENDP


                          AREA ||i.HAL_DMA_Abort||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Abort PROC
;;;519      */
;;;520    HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;521    {
000002  4604              MOV      r4,r0
;;;522      /* calculate DMA base and stream number */
;;;523      DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
000004  6de5              LDR      r5,[r4,#0x5c]
;;;524      
;;;525      uint32_t tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
00000a  4606              MOV      r6,r0
;;;526      
;;;527      if(hdma->State != HAL_DMA_STATE_BUSY)
00000c  6ba0              LDR      r0,[r4,#0x38]
00000e  2802              CMP      r0,#2
000010  d007              BEQ      |L4.34|
;;;528      {
;;;529        hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
000012  2080              MOVS     r0,#0x80
000014  65a0              STR      r0,[r4,#0x58]
;;;530        
;;;531        /* Process Unlocked */
;;;532        __HAL_UNLOCK(hdma);
000016  bf00              NOP      
000018  2000              MOVS     r0,#0
00001a  6360              STR      r0,[r4,#0x34]
00001c  bf00              NOP      
;;;533        
;;;534        return HAL_ERROR;
00001e  2001              MOVS     r0,#1
                  |L4.32|
;;;535      }
;;;536      else
;;;537      {
;;;538        /* Disable all the transfer interrupts */
;;;539        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
;;;540        hdma->Instance->FCR &= ~(DMA_IT_FE);
;;;541        
;;;542        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
;;;543        {
;;;544          hdma->Instance->CR  &= ~(DMA_IT_HT);
;;;545        }
;;;546        
;;;547        /* Disable the stream */
;;;548        __HAL_DMA_DISABLE(hdma);
;;;549        
;;;550        /* Check if the DMA Stream is effectively disabled */
;;;551        while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
;;;552        {
;;;553          /* Check for the Timeout */
;;;554          if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
;;;555          {
;;;556            /* Update error code */
;;;557            hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
;;;558            
;;;559            /* Process Unlocked */
;;;560            __HAL_UNLOCK(hdma);
;;;561            
;;;562            /* Change the DMA state */
;;;563            hdma->State = HAL_DMA_STATE_TIMEOUT;
;;;564            
;;;565            return HAL_TIMEOUT;
;;;566          }
;;;567        }
;;;568        
;;;569        /* Clear all interrupt flags at correct offset within the register */
;;;570        regs->IFCR = 0x3FU << hdma->StreamIndex;
;;;571        
;;;572        /* Process Unlocked */
;;;573        __HAL_UNLOCK(hdma);
;;;574        
;;;575        /* Change the DMA state*/
;;;576        hdma->State = HAL_DMA_STATE_READY;
;;;577      }
;;;578      return HAL_OK;
;;;579    }
000020  bd70              POP      {r4-r6,pc}
                  |L4.34|
000022  6820              LDR      r0,[r4,#0]            ;539
000024  6800              LDR      r0,[r0,#0]            ;539
000026  f0200016          BIC      r0,r0,#0x16           ;539
00002a  6821              LDR      r1,[r4,#0]            ;539
00002c  6008              STR      r0,[r1,#0]            ;539
00002e  6820              LDR      r0,[r4,#0]            ;540
000030  6940              LDR      r0,[r0,#0x14]         ;540
000032  f0200080          BIC      r0,r0,#0x80           ;540
000036  6821              LDR      r1,[r4,#0]            ;540
000038  6148              STR      r0,[r1,#0x14]         ;540
00003a  6c60              LDR      r0,[r4,#0x44]         ;542
00003c  b908              CBNZ     r0,|L4.66|
00003e  6ce0              LDR      r0,[r4,#0x4c]         ;542
000040  b128              CBZ      r0,|L4.78|
                  |L4.66|
000042  6820              LDR      r0,[r4,#0]            ;544
000044  6800              LDR      r0,[r0,#0]            ;544
000046  f0200008          BIC      r0,r0,#8              ;544
00004a  6821              LDR      r1,[r4,#0]            ;544
00004c  6008              STR      r0,[r1,#0]            ;544
                  |L4.78|
00004e  6820              LDR      r0,[r4,#0]            ;548
000050  6800              LDR      r0,[r0,#0]            ;548
000052  f0200001          BIC      r0,r0,#1              ;548
000056  6821              LDR      r1,[r4,#0]            ;548
000058  6008              STR      r0,[r1,#0]            ;548
00005a  e00d              B        |L4.120|
                  |L4.92|
00005c  f7fffffe          BL       HAL_GetTick
000060  1b80              SUBS     r0,r0,r6              ;554
000062  2805              CMP      r0,#5                 ;554
000064  d908              BLS      |L4.120|
000066  2020              MOVS     r0,#0x20              ;557
000068  65a0              STR      r0,[r4,#0x58]         ;557
00006a  bf00              NOP                            ;560
00006c  2000              MOVS     r0,#0                 ;560
00006e  6360              STR      r0,[r4,#0x34]         ;560
000070  bf00              NOP                            ;560
000072  2003              MOVS     r0,#3                 ;563
000074  63a0              STR      r0,[r4,#0x38]         ;563
000076  e7d3              B        |L4.32|
                  |L4.120|
000078  6820              LDR      r0,[r4,#0]            ;551
00007a  6800              LDR      r0,[r0,#0]            ;551
00007c  f0000001          AND      r0,r0,#1              ;551
000080  2800              CMP      r0,#0                 ;551
000082  d1eb              BNE      |L4.92|
000084  f8941060          LDRB     r1,[r4,#0x60]         ;570
000088  203f              MOVS     r0,#0x3f              ;570
00008a  4088              LSLS     r0,r0,r1              ;570
00008c  60a8              STR      r0,[r5,#8]            ;570
00008e  bf00              NOP                            ;573
000090  2000              MOVS     r0,#0                 ;573
000092  6360              STR      r0,[r4,#0x34]         ;573
000094  bf00              NOP                            ;573
000096  2001              MOVS     r0,#1                 ;576
000098  63a0              STR      r0,[r4,#0x38]         ;576
00009a  2000              MOVS     r0,#0                 ;578
00009c  e7c0              B        |L4.32|
;;;580    
                          ENDP


                          AREA ||i.HAL_DMA_Abort_IT||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Abort_IT PROC
;;;586      */
;;;587    HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
000000  4601              MOV      r1,r0
;;;588    {
;;;589      if(hdma->State != HAL_DMA_STATE_BUSY)
000002  6b88              LDR      r0,[r1,#0x38]
000004  2802              CMP      r0,#2
000006  d003              BEQ      |L5.16|
;;;590      {
;;;591        hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
000008  2080              MOVS     r0,#0x80
00000a  6588              STR      r0,[r1,#0x58]
;;;592        return HAL_ERROR;
00000c  2001              MOVS     r0,#1
                  |L5.14|
;;;593      }
;;;594      else
;;;595      {
;;;596        /* Set Abort State  */
;;;597        hdma->State = HAL_DMA_STATE_ABORT;
;;;598        
;;;599        /* Disable the stream */
;;;600        __HAL_DMA_DISABLE(hdma);
;;;601      }
;;;602    
;;;603      return HAL_OK;
;;;604    }
00000e  4770              BX       lr
                  |L5.16|
000010  2005              MOVS     r0,#5                 ;597
000012  6388              STR      r0,[r1,#0x38]         ;597
000014  6808              LDR      r0,[r1,#0]            ;600
000016  6800              LDR      r0,[r0,#0]            ;600
000018  f0200001          BIC      r0,r0,#1              ;600
00001c  680a              LDR      r2,[r1,#0]            ;600
00001e  6010              STR      r0,[r2,#0]            ;600
000020  2000              MOVS     r0,#0                 ;603
000022  e7f4              B        |L5.14|
;;;605    
                          ENDP


                          AREA ||i.HAL_DMA_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_DMA_DeInit PROC
;;;325      */
;;;326    HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;327    {
000002  4604              MOV      r4,r0
;;;328      DMA_Base_Registers *regs;
;;;329    
;;;330      /* Check the DMA peripheral state */
;;;331      if(hdma == NULL)
000004  b90c              CBNZ     r4,|L6.10|
;;;332      {
;;;333        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L6.8|
;;;334      }
;;;335      
;;;336      /* Check the DMA peripheral state */
;;;337      if(hdma->State == HAL_DMA_STATE_BUSY)
;;;338      {
;;;339        /* Return error status */
;;;340        return HAL_BUSY;
;;;341      }
;;;342    
;;;343      /* Disable the selected DMA Streamx */
;;;344      __HAL_DMA_DISABLE(hdma);
;;;345    
;;;346      /* Reset DMA Streamx control register */
;;;347      hdma->Instance->CR   = 0U;
;;;348    
;;;349      /* Reset DMA Streamx number of data to transfer register */
;;;350      hdma->Instance->NDTR = 0U;
;;;351    
;;;352      /* Reset DMA Streamx peripheral address register */
;;;353      hdma->Instance->PAR  = 0U;
;;;354    
;;;355      /* Reset DMA Streamx memory 0 address register */
;;;356      hdma->Instance->M0AR = 0U;
;;;357      
;;;358      /* Reset DMA Streamx memory 1 address register */
;;;359      hdma->Instance->M1AR = 0U;
;;;360      
;;;361      /* Reset DMA Streamx FIFO control register */
;;;362      hdma->Instance->FCR  = (uint32_t)0x00000021U;
;;;363      
;;;364      /* Get DMA steam Base Address */  
;;;365      regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
;;;366      
;;;367      /* Clear all interrupt flags at correct offset within the register */
;;;368      regs->IFCR = 0x3FU << hdma->StreamIndex;
;;;369    
;;;370      /* Initialize the error code */
;;;371      hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;372    
;;;373      /* Initialize the DMA state */
;;;374      hdma->State = HAL_DMA_STATE_RESET;
;;;375    
;;;376      /* Release Lock */
;;;377      __HAL_UNLOCK(hdma);
;;;378    
;;;379      return HAL_OK;
;;;380    }
000008  bd70              POP      {r4-r6,pc}
                  |L6.10|
00000a  6ba0              LDR      r0,[r4,#0x38]         ;337
00000c  2802              CMP      r0,#2                 ;337
00000e  d100              BNE      |L6.18|
000010  e7fa              B        |L6.8|
                  |L6.18|
000012  6820              LDR      r0,[r4,#0]            ;344
000014  6800              LDR      r0,[r0,#0]            ;344
000016  f0200001          BIC      r0,r0,#1              ;344
00001a  6821              LDR      r1,[r4,#0]            ;344
00001c  6008              STR      r0,[r1,#0]            ;344
00001e  2000              MOVS     r0,#0                 ;347
000020  6821              LDR      r1,[r4,#0]            ;347
000022  6008              STR      r0,[r1,#0]            ;347
000024  6821              LDR      r1,[r4,#0]            ;350
000026  6048              STR      r0,[r1,#4]            ;350
000028  6821              LDR      r1,[r4,#0]            ;353
00002a  6088              STR      r0,[r1,#8]            ;353
00002c  6821              LDR      r1,[r4,#0]            ;356
00002e  60c8              STR      r0,[r1,#0xc]          ;356
000030  6821              LDR      r1,[r4,#0]            ;359
000032  6108              STR      r0,[r1,#0x10]         ;359
000034  2021              MOVS     r0,#0x21              ;362
000036  6821              LDR      r1,[r4,#0]            ;362
000038  6148              STR      r0,[r1,#0x14]         ;362
00003a  4620              MOV      r0,r4                 ;365
00003c  f7fffffe          BL       DMA_CalcBaseAndBitshift
000040  4605              MOV      r5,r0                 ;365
000042  f8941060          LDRB     r1,[r4,#0x60]         ;368
000046  203f              MOVS     r0,#0x3f              ;368
000048  4088              LSLS     r0,r0,r1              ;368
00004a  60a8              STR      r0,[r5,#8]            ;368
00004c  2000              MOVS     r0,#0                 ;371
00004e  65a0              STR      r0,[r4,#0x58]         ;371
000050  63a0              STR      r0,[r4,#0x38]         ;374
000052  bf00              NOP                            ;377
000054  6360              STR      r0,[r4,#0x34]         ;377
000056  bf00              NOP                            ;377
000058  bf00              NOP                            ;379
00005a  e7d5              B        |L6.8|
;;;381    
                          ENDP


                          AREA ||i.HAL_DMA_GetError||, CODE, READONLY, ALIGN=1

                  HAL_DMA_GetError PROC
;;;1129     */
;;;1130   uint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)
000000  4601              MOV      r1,r0
;;;1131   {
;;;1132     return hdma->ErrorCode;
000002  6d88              LDR      r0,[r1,#0x58]
;;;1133   }
000004  4770              BX       lr
;;;1134   
                          ENDP


                          AREA ||i.HAL_DMA_GetState||, CODE, READONLY, ALIGN=1

                  HAL_DMA_GetState PROC
;;;1118     */
;;;1119   HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)
000000  4601              MOV      r1,r0
;;;1120   {
;;;1121     return hdma->State;
000002  6b88              LDR      r0,[r1,#0x38]
;;;1122   }
000004  4770              BX       lr
;;;1123   
                          ENDP


                          AREA ||i.HAL_DMA_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_DMA_IRQHandler PROC
;;;752      */
;;;753    void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
000000  b5f8              PUSH     {r3-r7,lr}
;;;754    {
000002  4604              MOV      r4,r0
;;;755      uint32_t tmpisr;
;;;756      __IO uint32_t count = 0;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;757      uint32_t timeout = SystemCoreClock / 9600;
000008  4889              LDR      r0,|L9.560|
00000a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000c  f44f5116          MOV      r1,#0x2580
000010  fbb0f7f1          UDIV     r7,r0,r1
;;;758    
;;;759      /* calculate DMA base and stream number */
;;;760      DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
000014  6de5              LDR      r5,[r4,#0x5c]
;;;761    
;;;762      tmpisr = regs->ISR;
000016  682e              LDR      r6,[r5,#0]
;;;763    
;;;764      /* Transfer Error Interrupt management ***************************************/
;;;765      if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
000018  f8941060          LDRB     r1,[r4,#0x60]
00001c  2008              MOVS     r0,#8
00001e  4088              LSLS     r0,r0,r1
000020  4030              ANDS     r0,r0,r6
000022  b198              CBZ      r0,|L9.76|
;;;766      {
;;;767        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
000024  6820              LDR      r0,[r4,#0]
000026  6800              LDR      r0,[r0,#0]
000028  f0000004          AND      r0,r0,#4
00002c  b170              CBZ      r0,|L9.76|
;;;768        {
;;;769          /* Disable the transfer error interrupt */
;;;770          hdma->Instance->CR  &= ~(DMA_IT_TE);
00002e  6820              LDR      r0,[r4,#0]
000030  6800              LDR      r0,[r0,#0]
000032  f0200004          BIC      r0,r0,#4
000036  6821              LDR      r1,[r4,#0]
000038  6008              STR      r0,[r1,#0]
;;;771          
;;;772          /* Clear the transfer error flag */
;;;773          regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
00003a  f8941060          LDRB     r1,[r4,#0x60]
00003e  2008              MOVS     r0,#8
000040  4088              LSLS     r0,r0,r1
000042  60a8              STR      r0,[r5,#8]
;;;774          
;;;775          /* Update error code */
;;;776          hdma->ErrorCode |= HAL_DMA_ERROR_TE;
000044  6da0              LDR      r0,[r4,#0x58]
000046  f0400001          ORR      r0,r0,#1
00004a  65a0              STR      r0,[r4,#0x58]
                  |L9.76|
;;;777        }
;;;778      }
;;;779      /* FIFO Error Interrupt management ******************************************/
;;;780      if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
00004c  f8941060          LDRB     r1,[r4,#0x60]
000050  4878              LDR      r0,|L9.564|
000052  4088              LSLS     r0,r0,r1
000054  4030              ANDS     r0,r0,r6
000056  b168              CBZ      r0,|L9.116|
;;;781      {
;;;782        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
000058  6820              LDR      r0,[r4,#0]
00005a  6940              LDR      r0,[r0,#0x14]
00005c  f0000080          AND      r0,r0,#0x80
000060  b140              CBZ      r0,|L9.116|
;;;783        {
;;;784          /* Clear the FIFO error flag */
;;;785          regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
000062  f8941060          LDRB     r1,[r4,#0x60]
000066  4873              LDR      r0,|L9.564|
000068  4088              LSLS     r0,r0,r1
00006a  60a8              STR      r0,[r5,#8]
;;;786    
;;;787          /* Update error code */
;;;788          hdma->ErrorCode |= HAL_DMA_ERROR_FE;
00006c  6da0              LDR      r0,[r4,#0x58]
00006e  f0400002          ORR      r0,r0,#2
000072  65a0              STR      r0,[r4,#0x58]
                  |L9.116|
;;;789        }
;;;790      }
;;;791      /* Direct Mode Error Interrupt management ***********************************/
;;;792      if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
000074  f8941060          LDRB     r1,[r4,#0x60]
000078  486e              LDR      r0,|L9.564|
00007a  1cc0              ADDS     r0,r0,#3
00007c  4088              LSLS     r0,r0,r1
00007e  4030              ANDS     r0,r0,r6
000080  b170              CBZ      r0,|L9.160|
;;;793      {
;;;794        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
000082  6820              LDR      r0,[r4,#0]
000084  6800              LDR      r0,[r0,#0]
000086  f0000002          AND      r0,r0,#2
00008a  b148              CBZ      r0,|L9.160|
;;;795        {
;;;796          /* Clear the direct mode error flag */
;;;797          regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
00008c  f8941060          LDRB     r1,[r4,#0x60]
000090  4868              LDR      r0,|L9.564|
000092  1cc0              ADDS     r0,r0,#3
000094  4088              LSLS     r0,r0,r1
000096  60a8              STR      r0,[r5,#8]
;;;798    
;;;799          /* Update error code */
;;;800          hdma->ErrorCode |= HAL_DMA_ERROR_DME;
000098  6da0              LDR      r0,[r4,#0x58]
00009a  f0400004          ORR      r0,r0,#4
00009e  65a0              STR      r0,[r4,#0x58]
                  |L9.160|
;;;801        }
;;;802      }
;;;803      /* Half Transfer Complete Interrupt management ******************************/
;;;804      if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
0000a0  f8941060          LDRB     r1,[r4,#0x60]
0000a4  2010              MOVS     r0,#0x10
0000a6  4088              LSLS     r0,r0,r1
0000a8  4030              ANDS     r0,r0,r6
0000aa  b378              CBZ      r0,|L9.268|
;;;805      {
;;;806        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
0000ac  6820              LDR      r0,[r4,#0]
0000ae  6800              LDR      r0,[r0,#0]
0000b0  f0000008          AND      r0,r0,#8
0000b4  b350              CBZ      r0,|L9.268|
;;;807        {
;;;808          /* Clear the half transfer complete flag */
;;;809          regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
0000b6  f8941060          LDRB     r1,[r4,#0x60]
0000ba  2010              MOVS     r0,#0x10
0000bc  4088              LSLS     r0,r0,r1
0000be  60a8              STR      r0,[r5,#8]
;;;810          
;;;811          /* Multi_Buffering mode enabled */
;;;812          if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
0000c0  6820              LDR      r0,[r4,#0]
0000c2  6800              LDR      r0,[r0,#0]
0000c4  f4002080          AND      r0,r0,#0x40000
0000c8  b180              CBZ      r0,|L9.236|
;;;813          {
;;;814            /* Current memory buffer used is Memory 0 */
;;;815            if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
0000ca  6820              LDR      r0,[r4,#0]
0000cc  6800              LDR      r0,[r0,#0]
0000ce  f4002000          AND      r0,r0,#0x80000
0000d2  b928              CBNZ     r0,|L9.224|
;;;816            {
;;;817              if(hdma->XferHalfCpltCallback != NULL)
0000d4  6c60              LDR      r0,[r4,#0x44]
0000d6  b1c8              CBZ      r0,|L9.268|
;;;818              {
;;;819                /* Half transfer callback */
;;;820                hdma->XferHalfCpltCallback(hdma);
0000d8  4620              MOV      r0,r4
0000da  6c61              LDR      r1,[r4,#0x44]
0000dc  4788              BLX      r1
0000de  e015              B        |L9.268|
                  |L9.224|
;;;821              }
;;;822            }
;;;823            /* Current memory buffer used is Memory 1 */
;;;824            else
;;;825            {
;;;826              if(hdma->XferM1HalfCpltCallback != NULL)
0000e0  6ce0              LDR      r0,[r4,#0x4c]
0000e2  b198              CBZ      r0,|L9.268|
;;;827              {
;;;828                /* Half transfer callback */
;;;829                hdma->XferM1HalfCpltCallback(hdma);
0000e4  4620              MOV      r0,r4
0000e6  6ce1              LDR      r1,[r4,#0x4c]
0000e8  4788              BLX      r1
0000ea  e00f              B        |L9.268|
                  |L9.236|
;;;830              }
;;;831            }
;;;832          }
;;;833          else
;;;834          {
;;;835            /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
;;;836            if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
0000ec  6820              LDR      r0,[r4,#0]
0000ee  6800              LDR      r0,[r0,#0]
0000f0  f4007080          AND      r0,r0,#0x100
0000f4  b928              CBNZ     r0,|L9.258|
;;;837            {
;;;838              /* Disable the half transfer interrupt */
;;;839              hdma->Instance->CR  &= ~(DMA_IT_HT);
0000f6  6820              LDR      r0,[r4,#0]
0000f8  6800              LDR      r0,[r0,#0]
0000fa  f0200008          BIC      r0,r0,#8
0000fe  6821              LDR      r1,[r4,#0]
000100  6008              STR      r0,[r1,#0]
                  |L9.258|
;;;840            }
;;;841            
;;;842            if(hdma->XferHalfCpltCallback != NULL)
000102  6c60              LDR      r0,[r4,#0x44]
000104  b110              CBZ      r0,|L9.268|
;;;843            {
;;;844              /* Half transfer callback */
;;;845              hdma->XferHalfCpltCallback(hdma);
000106  4620              MOV      r0,r4
000108  6c61              LDR      r1,[r4,#0x44]
00010a  4788              BLX      r1
                  |L9.268|
;;;846            }
;;;847          }
;;;848        }
;;;849      }
;;;850      /* Transfer Complete Interrupt management ***********************************/
;;;851      if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
00010c  f8941060          LDRB     r1,[r4,#0x60]
000110  2020              MOVS     r0,#0x20
000112  4088              LSLS     r0,r0,r1
000114  4030              ANDS     r0,r0,r6
000116  2800              CMP      r0,#0
000118  d060              BEQ      |L9.476|
;;;852      {
;;;853        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
00011a  6820              LDR      r0,[r4,#0]
00011c  6800              LDR      r0,[r0,#0]
00011e  f0000010          AND      r0,r0,#0x10
000122  2800              CMP      r0,#0
000124  d05a              BEQ      |L9.476|
;;;854        {
;;;855          /* Clear the transfer complete flag */
;;;856          regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
000126  f8941060          LDRB     r1,[r4,#0x60]
00012a  2020              MOVS     r0,#0x20
00012c  4088              LSLS     r0,r0,r1
00012e  60a8              STR      r0,[r5,#8]
;;;857          
;;;858          if(HAL_DMA_STATE_ABORT == hdma->State)
000130  6ba0              LDR      r0,[r4,#0x38]
000132  2805              CMP      r0,#5
000134  d126              BNE      |L9.388|
;;;859          {
;;;860            /* Disable all the transfer interrupts */
;;;861            hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
000136  6820              LDR      r0,[r4,#0]
000138  6800              LDR      r0,[r0,#0]
00013a  f0200016          BIC      r0,r0,#0x16
00013e  6821              LDR      r1,[r4,#0]
000140  6008              STR      r0,[r1,#0]
;;;862            hdma->Instance->FCR &= ~(DMA_IT_FE);
000142  6820              LDR      r0,[r4,#0]
000144  6940              LDR      r0,[r0,#0x14]
000146  f0200080          BIC      r0,r0,#0x80
00014a  6821              LDR      r1,[r4,#0]
00014c  6148              STR      r0,[r1,#0x14]
;;;863            
;;;864            if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
00014e  6c60              LDR      r0,[r4,#0x44]
000150  b908              CBNZ     r0,|L9.342|
000152  6ce0              LDR      r0,[r4,#0x4c]
000154  b128              CBZ      r0,|L9.354|
                  |L9.342|
;;;865            {
;;;866              hdma->Instance->CR  &= ~(DMA_IT_HT);
000156  6820              LDR      r0,[r4,#0]
000158  6800              LDR      r0,[r0,#0]
00015a  f0200008          BIC      r0,r0,#8
00015e  6821              LDR      r1,[r4,#0]
000160  6008              STR      r0,[r1,#0]
                  |L9.354|
;;;867            }
;;;868    
;;;869            /* Clear all interrupt flags at correct offset within the register */
;;;870            regs->IFCR = 0x3FU << hdma->StreamIndex;
000162  f8941060          LDRB     r1,[r4,#0x60]
000166  203f              MOVS     r0,#0x3f
000168  4088              LSLS     r0,r0,r1
00016a  60a8              STR      r0,[r5,#8]
;;;871    
;;;872            /* Process Unlocked */
;;;873            __HAL_UNLOCK(hdma);
00016c  bf00              NOP      
00016e  2000              MOVS     r0,#0
000170  6360              STR      r0,[r4,#0x34]
000172  bf00              NOP      
;;;874             
;;;875            /* Change the DMA state */
;;;876            hdma->State = HAL_DMA_STATE_READY;
000174  2001              MOVS     r0,#1
000176  63a0              STR      r0,[r4,#0x38]
;;;877    	
;;;878            if(hdma->XferAbortCallback != NULL)
000178  6d60              LDR      r0,[r4,#0x54]
00017a  b110              CBZ      r0,|L9.386|
;;;879            {
;;;880              hdma->XferAbortCallback(hdma);
00017c  4620              MOV      r0,r4
00017e  6d61              LDR      r1,[r4,#0x54]
000180  4788              BLX      r1
                  |L9.386|
;;;881            }
;;;882            return;
;;;883          }
;;;884          
;;;885          if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
;;;886          {
;;;887            /* Current memory buffer used is Memory 0 */
;;;888            if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
;;;889            {
;;;890              if(hdma->XferM1CpltCallback != NULL)
;;;891              {
;;;892                /* Transfer complete Callback for memory1 */
;;;893                hdma->XferM1CpltCallback(hdma);
;;;894              }
;;;895            }
;;;896            /* Current memory buffer used is Memory 1 */
;;;897            else
;;;898            {
;;;899              if(hdma->XferCpltCallback != NULL)
;;;900              {
;;;901                /* Transfer complete Callback for memory0 */
;;;902                hdma->XferCpltCallback(hdma);
;;;903              }
;;;904            }
;;;905          }
;;;906          /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
;;;907          else
;;;908          {
;;;909            if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
;;;910            {
;;;911              /* Disable the transfer complete interrupt */
;;;912              hdma->Instance->CR  &= ~(DMA_IT_TC);
;;;913    
;;;914              /* Process Unlocked */
;;;915              __HAL_UNLOCK(hdma);
;;;916              
;;;917              /* Change the DMA state */
;;;918              hdma->State = HAL_DMA_STATE_READY;
;;;919            }
;;;920            
;;;921            if(hdma->XferCpltCallback != NULL)
;;;922            {
;;;923              /* Transfer complete callback */
;;;924              hdma->XferCpltCallback(hdma);
;;;925            }
;;;926          }
;;;927        }
;;;928      }
;;;929      
;;;930      /* manage error case */
;;;931      if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
;;;932      {
;;;933        if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
;;;934        {
;;;935          hdma->State = HAL_DMA_STATE_ABORT;
;;;936          
;;;937          /* Disable the stream */
;;;938          __HAL_DMA_DISABLE(hdma);
;;;939          
;;;940          do
;;;941          {
;;;942            if (++count > timeout)
;;;943            {
;;;944              break;
;;;945            }
;;;946          }
;;;947          while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
;;;948    
;;;949          /* Process Unlocked */
;;;950          __HAL_UNLOCK(hdma);
;;;951    
;;;952          /* Change the DMA state */
;;;953          hdma->State = HAL_DMA_STATE_READY;
;;;954        }
;;;955        
;;;956        if(hdma->XferErrorCallback != NULL)
;;;957        {
;;;958          /* Transfer error callback */
;;;959          hdma->XferErrorCallback(hdma);
;;;960        }
;;;961      }
;;;962    }
000182  bdf8              POP      {r3-r7,pc}
                  |L9.388|
000184  6820              LDR      r0,[r4,#0]            ;885
000186  6800              LDR      r0,[r0,#0]            ;885
000188  f4002080          AND      r0,r0,#0x40000        ;885
00018c  b180              CBZ      r0,|L9.432|
00018e  6820              LDR      r0,[r4,#0]            ;888
000190  6800              LDR      r0,[r0,#0]            ;888
000192  f4002000          AND      r0,r0,#0x80000        ;888
000196  b928              CBNZ     r0,|L9.420|
000198  6ca0              LDR      r0,[r4,#0x48]         ;890
00019a  b110              CBZ      r0,|L9.418|
00019c  4620              MOV      r0,r4                 ;893
00019e  6ca1              LDR      r1,[r4,#0x48]         ;893
0001a0  4788              BLX      r1                    ;893
                  |L9.418|
0001a2  e01b              B        |L9.476|
                  |L9.420|
0001a4  6c20              LDR      r0,[r4,#0x40]         ;899
0001a6  b1c8              CBZ      r0,|L9.476|
0001a8  4620              MOV      r0,r4                 ;902
0001aa  6c21              LDR      r1,[r4,#0x40]         ;902
0001ac  4788              BLX      r1                    ;902
0001ae  e015              B        |L9.476|
                  |L9.432|
0001b0  6820              LDR      r0,[r4,#0]            ;909
0001b2  6800              LDR      r0,[r0,#0]            ;909
0001b4  f4007080          AND      r0,r0,#0x100          ;909
0001b8  b958              CBNZ     r0,|L9.466|
0001ba  6820              LDR      r0,[r4,#0]            ;912
0001bc  6800              LDR      r0,[r0,#0]            ;912
0001be  f0200010          BIC      r0,r0,#0x10           ;912
0001c2  6821              LDR      r1,[r4,#0]            ;912
0001c4  6008              STR      r0,[r1,#0]            ;912
0001c6  bf00              NOP                            ;915
0001c8  2000              MOVS     r0,#0                 ;915
0001ca  6360              STR      r0,[r4,#0x34]         ;915
0001cc  bf00              NOP                            ;915
0001ce  2001              MOVS     r0,#1                 ;918
0001d0  63a0              STR      r0,[r4,#0x38]         ;918
                  |L9.466|
0001d2  6c20              LDR      r0,[r4,#0x40]         ;921
0001d4  b110              CBZ      r0,|L9.476|
0001d6  4620              MOV      r0,r4                 ;924
0001d8  6c21              LDR      r1,[r4,#0x40]         ;924
0001da  4788              BLX      r1                    ;924
                  |L9.476|
0001dc  6da0              LDR      r0,[r4,#0x58]         ;931
0001de  b320              CBZ      r0,|L9.554|
0001e0  6da0              LDR      r0,[r4,#0x58]         ;933
0001e2  f0000001          AND      r0,r0,#1              ;933
0001e6  b1d8              CBZ      r0,|L9.544|
0001e8  2005              MOVS     r0,#5                 ;935
0001ea  63a0              STR      r0,[r4,#0x38]         ;935
0001ec  6820              LDR      r0,[r4,#0]            ;938
0001ee  6800              LDR      r0,[r0,#0]            ;938
0001f0  f0200001          BIC      r0,r0,#1              ;938
0001f4  6821              LDR      r1,[r4,#0]            ;938
0001f6  6008              STR      r0,[r1,#0]            ;938
0001f8  bf00              NOP                            ;940
                  |L9.506|
0001fa  9800              LDR      r0,[sp,#0]            ;942
0001fc  1c40              ADDS     r0,r0,#1              ;942
0001fe  9000              STR      r0,[sp,#0]            ;942
000200  42b8              CMP      r0,r7                 ;942
000202  d900              BLS      |L9.518|
000204  e005              B        |L9.530|
                  |L9.518|
000206  6820              LDR      r0,[r4,#0]            ;947
000208  6800              LDR      r0,[r0,#0]            ;947
00020a  f0000001          AND      r0,r0,#1              ;947
00020e  2800              CMP      r0,#0                 ;947
000210  d1f3              BNE      |L9.506|
                  |L9.530|
000212  bf00              NOP                            ;944
000214  bf00              NOP                            ;950
000216  2000              MOVS     r0,#0                 ;950
000218  6360              STR      r0,[r4,#0x34]         ;950
00021a  bf00              NOP                            ;950
00021c  2001              MOVS     r0,#1                 ;953
00021e  63a0              STR      r0,[r4,#0x38]         ;953
                  |L9.544|
000220  6d20              LDR      r0,[r4,#0x50]         ;956
000222  b110              CBZ      r0,|L9.554|
000224  4620              MOV      r0,r4                 ;959
000226  6d21              LDR      r1,[r4,#0x50]         ;959
000228  4788              BLX      r1                    ;959
                  |L9.554|
00022a  bf00              NOP      
00022c  e7a9              B        |L9.386|
;;;963    
                          ENDP

00022e  0000              DCW      0x0000
                  |L9.560|
                          DCD      SystemCoreClock
                  |L9.564|
                          DCD      0x00800001

                          AREA ||i.HAL_DMA_Init||, CODE, READONLY, ALIGN=2

                  HAL_DMA_Init PROC
;;;191      */
;;;192    HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;193    {
000004  4604              MOV      r4,r0
;;;194      uint32_t tmp = 0U;
000006  2500              MOVS     r5,#0
;;;195      uint32_t tickstart = HAL_GetTick();
000008  f7fffffe          BL       HAL_GetTick
00000c  4607              MOV      r7,r0
;;;196      DMA_Base_Registers *regs;
;;;197    
;;;198      /* Check the DMA peripheral state */
;;;199      if(hdma == NULL)
00000e  b914              CBNZ     r4,|L10.22|
;;;200      {
;;;201        return HAL_ERROR;
000010  2001              MOVS     r0,#1
                  |L10.18|
;;;202      }
;;;203    
;;;204      /* Check the parameters */
;;;205      assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance));
;;;206      assert_param(IS_DMA_CHANNEL(hdma->Init.Channel));
;;;207      assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
;;;208      assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
;;;209      assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
;;;210      assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
;;;211      assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
;;;212      assert_param(IS_DMA_MODE(hdma->Init.Mode));
;;;213      assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
;;;214      assert_param(IS_DMA_FIFO_MODE_STATE(hdma->Init.FIFOMode));
;;;215      /* Check the memory burst, peripheral burst and FIFO threshold parameters only
;;;216         when FIFO mode is enabled */
;;;217      if(hdma->Init.FIFOMode != DMA_FIFOMODE_DISABLE)
;;;218      {
;;;219        assert_param(IS_DMA_FIFO_THRESHOLD(hdma->Init.FIFOThreshold));
;;;220        assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
;;;221        assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
;;;222      }
;;;223      
;;;224      /* Allocate lock resource */
;;;225      __HAL_UNLOCK(hdma);
;;;226    
;;;227      /* Change DMA peripheral state */
;;;228      hdma->State = HAL_DMA_STATE_BUSY;
;;;229      
;;;230      /* Disable the peripheral */
;;;231      __HAL_DMA_DISABLE(hdma);
;;;232      
;;;233      /* Check if the DMA Stream is effectively disabled */
;;;234      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
;;;235      {
;;;236        /* Check for the Timeout */
;;;237        if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
;;;238        {
;;;239          /* Update error code */
;;;240          hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
;;;241          
;;;242          /* Change the DMA state */
;;;243          hdma->State = HAL_DMA_STATE_TIMEOUT;
;;;244          
;;;245          return HAL_TIMEOUT;
;;;246        }
;;;247      }
;;;248      
;;;249      /* Get the CR register value */
;;;250      tmp = hdma->Instance->CR;
;;;251    
;;;252      /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
;;;253      tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
;;;254                          DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
;;;255                          DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
;;;256                          DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));
;;;257    
;;;258      /* Prepare the DMA Stream configuration */
;;;259      tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
;;;260              hdma->Init.PeriphInc           | hdma->Init.MemInc           |
;;;261              hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
;;;262              hdma->Init.Mode                | hdma->Init.Priority;
;;;263    
;;;264      /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
;;;265      if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
;;;266      {
;;;267        /* Get memory burst and peripheral burst */
;;;268        tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
;;;269      }
;;;270      
;;;271      /* Write to DMA Stream CR register */
;;;272      hdma->Instance->CR = tmp;  
;;;273    
;;;274      /* Get the FCR register value */
;;;275      tmp = hdma->Instance->FCR;
;;;276    
;;;277      /* Clear Direct mode and FIFO threshold bits */
;;;278      tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
;;;279    
;;;280      /* Prepare the DMA Stream FIFO configuration */
;;;281      tmp |= hdma->Init.FIFOMode;
;;;282    
;;;283      /* the FIFO threshold is not used when the FIFO mode is disabled */
;;;284      if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
;;;285      {
;;;286        /* Get the FIFO threshold */
;;;287        tmp |= hdma->Init.FIFOThreshold;
;;;288        
;;;289        if (DMA_CheckFifoParam(hdma) != HAL_OK)
;;;290        {
;;;291          /* Update error code */
;;;292          hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
;;;293          
;;;294          /* Change the DMA state */
;;;295          hdma->State = HAL_DMA_STATE_READY;
;;;296          
;;;297          return HAL_ERROR; 
;;;298        }
;;;299      }
;;;300      
;;;301      /* Write to DMA Stream FCR */
;;;302      hdma->Instance->FCR = tmp;
;;;303    
;;;304      /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
;;;305         DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
;;;306      regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
;;;307      
;;;308      /* Clear all interrupt flags */
;;;309      regs->IFCR = 0x3FU << hdma->StreamIndex;
;;;310    
;;;311      /* Initialize the error code */
;;;312      hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;313                                                                                         
;;;314      /* Initialize the DMA state */
;;;315      hdma->State = HAL_DMA_STATE_READY;
;;;316    
;;;317      return HAL_OK;
;;;318    }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L10.22|
000016  6a60              LDR      r0,[r4,#0x24]         ;217
000018  b100              CBZ      r0,|L10.28|
00001a  bf00              NOP                            ;221
                  |L10.28|
00001c  bf00              NOP                            ;225
00001e  2000              MOVS     r0,#0                 ;225
000020  6360              STR      r0,[r4,#0x34]         ;225
000022  bf00              NOP                            ;225
000024  2002              MOVS     r0,#2                 ;228
000026  63a0              STR      r0,[r4,#0x38]         ;228
000028  6820              LDR      r0,[r4,#0]            ;231
00002a  6800              LDR      r0,[r0,#0]            ;231
00002c  f0200001          BIC      r0,r0,#1              ;231
000030  6821              LDR      r1,[r4,#0]            ;231
000032  6008              STR      r0,[r1,#0]            ;231
000034  e009              B        |L10.74|
                  |L10.54|
000036  f7fffffe          BL       HAL_GetTick
00003a  1bc0              SUBS     r0,r0,r7              ;237
00003c  2805              CMP      r0,#5                 ;237
00003e  d904              BLS      |L10.74|
000040  2020              MOVS     r0,#0x20              ;240
000042  65a0              STR      r0,[r4,#0x58]         ;240
000044  2003              MOVS     r0,#3                 ;243
000046  63a0              STR      r0,[r4,#0x38]         ;243
000048  e7e3              B        |L10.18|
                  |L10.74|
00004a  6820              LDR      r0,[r4,#0]            ;234
00004c  6800              LDR      r0,[r0,#0]            ;234
00004e  f0000001          AND      r0,r0,#1              ;234
000052  2800              CMP      r0,#0                 ;234
000054  d1ef              BNE      |L10.54|
000056  6820              LDR      r0,[r4,#0]            ;250
000058  6805              LDR      r5,[r0,#0]            ;250
00005a  4820              LDR      r0,|L10.220|
00005c  4005              ANDS     r5,r5,r0              ;253
00005e  e9d40101          LDRD     r0,r1,[r4,#4]         ;259
000062  4308              ORRS     r0,r0,r1              ;259
000064  68e1              LDR      r1,[r4,#0xc]          ;259
000066  4308              ORRS     r0,r0,r1              ;259
000068  6921              LDR      r1,[r4,#0x10]         ;259
00006a  4308              ORRS     r0,r0,r1              ;259
00006c  6961              LDR      r1,[r4,#0x14]         ;259
00006e  4308              ORRS     r0,r0,r1              ;259
000070  69a1              LDR      r1,[r4,#0x18]         ;259
000072  4308              ORRS     r0,r0,r1              ;259
000074  69e1              LDR      r1,[r4,#0x1c]         ;259
000076  4308              ORRS     r0,r0,r1              ;259
000078  6a21              LDR      r1,[r4,#0x20]         ;259
00007a  4308              ORRS     r0,r0,r1              ;259
00007c  4305              ORRS     r5,r5,r0              ;259
00007e  6a60              LDR      r0,[r4,#0x24]         ;265
000080  2804              CMP      r0,#4                 ;265
000082  d103              BNE      |L10.140|
000084  e9d4010b          LDRD     r0,r1,[r4,#0x2c]      ;268
000088  4308              ORRS     r0,r0,r1              ;268
00008a  4305              ORRS     r5,r5,r0              ;268
                  |L10.140|
00008c  6820              LDR      r0,[r4,#0]            ;272
00008e  6005              STR      r5,[r0,#0]            ;272
000090  6820              LDR      r0,[r4,#0]            ;275
000092  6945              LDR      r5,[r0,#0x14]         ;275
000094  f0250507          BIC      r5,r5,#7              ;278
000098  6a60              LDR      r0,[r4,#0x24]         ;281
00009a  4305              ORRS     r5,r5,r0              ;281
00009c  6a60              LDR      r0,[r4,#0x24]         ;284
00009e  2804              CMP      r0,#4                 ;284
0000a0  d10a              BNE      |L10.184|
0000a2  6aa0              LDR      r0,[r4,#0x28]         ;287
0000a4  4305              ORRS     r5,r5,r0              ;287
0000a6  4620              MOV      r0,r4                 ;289
0000a8  f7fffffe          BL       DMA_CheckFifoParam
0000ac  b120              CBZ      r0,|L10.184|
0000ae  2040              MOVS     r0,#0x40              ;292
0000b0  65a0              STR      r0,[r4,#0x58]         ;292
0000b2  2001              MOVS     r0,#1                 ;295
0000b4  63a0              STR      r0,[r4,#0x38]         ;295
0000b6  e7ac              B        |L10.18|
                  |L10.184|
0000b8  6820              LDR      r0,[r4,#0]            ;302
0000ba  6145              STR      r5,[r0,#0x14]         ;302
0000bc  4620              MOV      r0,r4                 ;306
0000be  f7fffffe          BL       DMA_CalcBaseAndBitshift
0000c2  4606              MOV      r6,r0                 ;306
0000c4  f8941060          LDRB     r1,[r4,#0x60]         ;309
0000c8  203f              MOVS     r0,#0x3f              ;309
0000ca  4088              LSLS     r0,r0,r1              ;309
0000cc  60b0              STR      r0,[r6,#8]            ;309
0000ce  2000              MOVS     r0,#0                 ;312
0000d0  65a0              STR      r0,[r4,#0x58]         ;312
0000d2  2001              MOVS     r0,#1                 ;315
0000d4  63a0              STR      r0,[r4,#0x38]         ;315
0000d6  2000              MOVS     r0,#0                 ;317
0000d8  e79b              B        |L10.18|
;;;319    
                          ENDP

0000da  0000              DCW      0x0000
                  |L10.220|
                          DCD      0xe010803f

                          AREA ||i.HAL_DMA_PollForTransfer||, CODE, READONLY, ALIGN=2

                  HAL_DMA_PollForTransfer PROC
;;;616      */
;;;617    HAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, HAL_DMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;618    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4617              MOV      r7,r2
;;;619      HAL_StatusTypeDef status = HAL_OK; 
00000a  f04f0a00          MOV      r10,#0
;;;620      uint32_t mask_cpltlevel;
;;;621      uint32_t tickstart = HAL_GetTick(); 
00000e  f7fffffe          BL       HAL_GetTick
000012  4683              MOV      r11,r0
;;;622      uint32_t tmpisr;
;;;623      
;;;624      /* calculate DMA base and stream number */
;;;625      DMA_Base_Registers *regs;
;;;626      
;;;627      if(HAL_DMA_STATE_BUSY != hdma->State)
000014  6ba0              LDR      r0,[r4,#0x38]
000016  2802              CMP      r0,#2
000018  d008              BEQ      |L11.44|
;;;628      {
;;;629        /* No transfer ongoing */
;;;630        hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
00001a  2080              MOVS     r0,#0x80
00001c  65a0              STR      r0,[r4,#0x58]
;;;631        __HAL_UNLOCK(hdma);
00001e  bf00              NOP      
000020  2000              MOVS     r0,#0
000022  6360              STR      r0,[r4,#0x34]
000024  bf00              NOP      
;;;632        return HAL_ERROR;
000026  2001              MOVS     r0,#1
                  |L11.40|
;;;633      }
;;;634      
;;;635      /* Polling mode not supported in circular mode and double buffering mode */
;;;636      if ((hdma->Instance->CR & DMA_SxCR_CIRC) != RESET)
;;;637      {
;;;638        hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
;;;639        return HAL_ERROR;
;;;640      }
;;;641      
;;;642      /* Get the level transfer complete flag */
;;;643      if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
;;;644      {
;;;645        /* Transfer Complete flag */
;;;646        mask_cpltlevel = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
;;;647      }
;;;648      else
;;;649      {
;;;650        /* Half Transfer Complete flag */
;;;651        mask_cpltlevel = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
;;;652      }
;;;653      
;;;654      regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
;;;655      tmpisr = regs->ISR;
;;;656      
;;;657      while(((tmpisr & mask_cpltlevel) == RESET) && ((hdma->ErrorCode & HAL_DMA_ERROR_TE) == RESET))
;;;658      {
;;;659        /* Check for the Timeout (Not applicable in circular mode)*/
;;;660        if(Timeout != HAL_MAX_DELAY)
;;;661        {
;;;662          if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
;;;663          {
;;;664            /* Update error code */
;;;665            hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
;;;666    
;;;667            /* Process Unlocked */
;;;668            __HAL_UNLOCK(hdma);
;;;669            
;;;670            /* Change the DMA state */
;;;671            hdma->State = HAL_DMA_STATE_READY;
;;;672            
;;;673            return HAL_TIMEOUT;
;;;674          }
;;;675        }
;;;676        
;;;677        /* Get the ISR register value */
;;;678        tmpisr = regs->ISR;
;;;679        
;;;680        if((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
;;;681        {
;;;682          /* Update error code */
;;;683          hdma->ErrorCode |= HAL_DMA_ERROR_TE;
;;;684          
;;;685          /* Clear the transfer error flag */
;;;686          regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
;;;687        }
;;;688        
;;;689        if((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
;;;690        {
;;;691          /* Update error code */
;;;692          hdma->ErrorCode |= HAL_DMA_ERROR_FE;
;;;693          
;;;694          /* Clear the FIFO error flag */
;;;695          regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
;;;696        }
;;;697        
;;;698        if((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
;;;699        {
;;;700          /* Update error code */
;;;701          hdma->ErrorCode |= HAL_DMA_ERROR_DME;
;;;702          
;;;703          /* Clear the Direct Mode error flag */
;;;704          regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
;;;705        }
;;;706      }
;;;707      
;;;708      if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
;;;709      {
;;;710        if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
;;;711        {
;;;712          HAL_DMA_Abort(hdma);
;;;713        
;;;714          /* Clear the half transfer and transfer complete flags */
;;;715          regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;
;;;716        
;;;717          /* Process Unlocked */
;;;718          __HAL_UNLOCK(hdma);
;;;719    
;;;720          /* Change the DMA state */
;;;721          hdma->State= HAL_DMA_STATE_READY;
;;;722    
;;;723          return HAL_ERROR;
;;;724       }
;;;725      }
;;;726      
;;;727      /* Get the level transfer complete flag */
;;;728      if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
;;;729      {
;;;730        /* Clear the half transfer and transfer complete flags */
;;;731        regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;
;;;732        
;;;733        /* Process Unlocked */
;;;734        __HAL_UNLOCK(hdma);
;;;735    
;;;736        hdma->State = HAL_DMA_STATE_READY;
;;;737      }
;;;738      else
;;;739      {
;;;740        /* Clear the half transfer and transfer complete flags */
;;;741        regs->IFCR = (DMA_FLAG_HTIF0_4) << hdma->StreamIndex;
;;;742      }
;;;743      
;;;744      return status;
;;;745    }
000028  e8bd9ff0          POP      {r4-r12,pc}
                  |L11.44|
00002c  6820              LDR      r0,[r4,#0]            ;636
00002e  6800              LDR      r0,[r0,#0]            ;636
000030  f4007080          AND      r0,r0,#0x100          ;636
000034  b120              CBZ      r0,|L11.64|
000036  f44f7080          MOV      r0,#0x100             ;638
00003a  65a0              STR      r0,[r4,#0x58]         ;638
00003c  2001              MOVS     r0,#1                 ;639
00003e  e7f3              B        |L11.40|
                  |L11.64|
000040  f1b80f00          CMP      r8,#0                 ;643
000044  d105              BNE      |L11.82|
000046  f8941060          LDRB     r1,[r4,#0x60]         ;646
00004a  2020              MOVS     r0,#0x20              ;646
00004c  fa00f901          LSL      r9,r0,r1              ;646
000050  e004              B        |L11.92|
                  |L11.82|
000052  f8941060          LDRB     r1,[r4,#0x60]         ;651
000056  2010              MOVS     r0,#0x10              ;651
000058  fa00f901          LSL      r9,r0,r1              ;651
                  |L11.92|
00005c  6de5              LDR      r5,[r4,#0x5c]         ;654
00005e  682e              LDR      r6,[r5,#0]            ;655
000060  e042              B        |L11.232|
                  |L11.98|
000062  1c78              ADDS     r0,r7,#1              ;660
000064  b180              CBZ      r0,|L11.136|
000066  b12f              CBZ      r7,|L11.116|
000068  f7fffffe          BL       HAL_GetTick
00006c  eba0000b          SUB      r0,r0,r11             ;662
000070  42b8              CMP      r0,r7                 ;662
000072  d909              BLS      |L11.136|
                  |L11.116|
000074  2020              MOVS     r0,#0x20              ;665
000076  65a0              STR      r0,[r4,#0x58]         ;665
000078  bf00              NOP                            ;668
00007a  2000              MOVS     r0,#0                 ;668
00007c  6360              STR      r0,[r4,#0x34]         ;668
00007e  bf00              NOP                            ;668
000080  2001              MOVS     r0,#1                 ;671
000082  63a0              STR      r0,[r4,#0x38]         ;671
000084  2003              MOVS     r0,#3                 ;673
000086  e7cf              B        |L11.40|
                  |L11.136|
000088  682e              LDR      r6,[r5,#0]            ;678
00008a  f8941060          LDRB     r1,[r4,#0x60]         ;680
00008e  2008              MOVS     r0,#8                 ;680
000090  4088              LSLS     r0,r0,r1              ;680
000092  4030              ANDS     r0,r0,r6              ;680
000094  b140              CBZ      r0,|L11.168|
000096  6da0              LDR      r0,[r4,#0x58]         ;683
000098  f0400001          ORR      r0,r0,#1              ;683
00009c  65a0              STR      r0,[r4,#0x58]         ;683
00009e  f8941060          LDRB     r1,[r4,#0x60]         ;686
0000a2  2008              MOVS     r0,#8                 ;686
0000a4  4088              LSLS     r0,r0,r1              ;686
0000a6  60a8              STR      r0,[r5,#8]            ;686
                  |L11.168|
0000a8  f8941060          LDRB     r1,[r4,#0x60]         ;689
0000ac  4828              LDR      r0,|L11.336|
0000ae  4088              LSLS     r0,r0,r1              ;689
0000b0  4030              ANDS     r0,r0,r6              ;689
0000b2  b140              CBZ      r0,|L11.198|
0000b4  6da0              LDR      r0,[r4,#0x58]         ;692
0000b6  f0400002          ORR      r0,r0,#2              ;692
0000ba  65a0              STR      r0,[r4,#0x58]         ;692
0000bc  f8941060          LDRB     r1,[r4,#0x60]         ;695
0000c0  4823              LDR      r0,|L11.336|
0000c2  4088              LSLS     r0,r0,r1              ;695
0000c4  60a8              STR      r0,[r5,#8]            ;695
                  |L11.198|
0000c6  f8941060          LDRB     r1,[r4,#0x60]         ;698
0000ca  4821              LDR      r0,|L11.336|
0000cc  1cc0              ADDS     r0,r0,#3              ;698
0000ce  4088              LSLS     r0,r0,r1              ;698
0000d0  4030              ANDS     r0,r0,r6              ;698
0000d2  b148              CBZ      r0,|L11.232|
0000d4  6da0              LDR      r0,[r4,#0x58]         ;701
0000d6  f0400004          ORR      r0,r0,#4              ;701
0000da  65a0              STR      r0,[r4,#0x58]         ;701
0000dc  f8941060          LDRB     r1,[r4,#0x60]         ;704
0000e0  481b              LDR      r0,|L11.336|
0000e2  1cc0              ADDS     r0,r0,#3              ;704
0000e4  4088              LSLS     r0,r0,r1              ;704
0000e6  60a8              STR      r0,[r5,#8]            ;704
                  |L11.232|
0000e8  ea060009          AND      r0,r6,r9              ;657
0000ec  b920              CBNZ     r0,|L11.248|
0000ee  6da0              LDR      r0,[r4,#0x58]         ;657
0000f0  f0000001          AND      r0,r0,#1              ;657
0000f4  2800              CMP      r0,#0                 ;657
0000f6  d0b4              BEQ      |L11.98|
                  |L11.248|
0000f8  6da0              LDR      r0,[r4,#0x58]         ;708
0000fa  b190              CBZ      r0,|L11.290|
0000fc  6da0              LDR      r0,[r4,#0x58]         ;710
0000fe  f0000001          AND      r0,r0,#1              ;710
000102  b170              CBZ      r0,|L11.290|
000104  4620              MOV      r0,r4                 ;712
000106  f7fffffe          BL       HAL_DMA_Abort
00010a  f8941060          LDRB     r1,[r4,#0x60]         ;715
00010e  2030              MOVS     r0,#0x30              ;715
000110  4088              LSLS     r0,r0,r1              ;715
000112  60a8              STR      r0,[r5,#8]            ;715
000114  bf00              NOP                            ;718
000116  2000              MOVS     r0,#0                 ;718
000118  6360              STR      r0,[r4,#0x34]         ;718
00011a  bf00              NOP                            ;718
00011c  2001              MOVS     r0,#1                 ;721
00011e  63a0              STR      r0,[r4,#0x38]         ;721
000120  e782              B        |L11.40|
                  |L11.290|
000122  f1b80f00          CMP      r8,#0                 ;728
000126  d10b              BNE      |L11.320|
000128  f8941060          LDRB     r1,[r4,#0x60]         ;731
00012c  2030              MOVS     r0,#0x30              ;731
00012e  4088              LSLS     r0,r0,r1              ;731
000130  60a8              STR      r0,[r5,#8]            ;731
000132  bf00              NOP                            ;734
000134  2000              MOVS     r0,#0                 ;734
000136  6360              STR      r0,[r4,#0x34]         ;734
000138  bf00              NOP                            ;734
00013a  2001              MOVS     r0,#1                 ;736
00013c  63a0              STR      r0,[r4,#0x38]         ;736
00013e  e004              B        |L11.330|
                  |L11.320|
000140  f8941060          LDRB     r1,[r4,#0x60]         ;741
000144  2010              MOVS     r0,#0x10              ;741
000146  4088              LSLS     r0,r0,r1              ;741
000148  60a8              STR      r0,[r5,#8]            ;741
                  |L11.330|
00014a  4650              MOV      r0,r10                ;744
00014c  e76c              B        |L11.40|
;;;746    
                          ENDP

00014e  0000              DCW      0x0000
                  |L11.336|
                          DCD      0x00800001

                          AREA ||i.HAL_DMA_RegisterCallback||, CODE, READONLY, ALIGN=1

                  HAL_DMA_RegisterCallback PROC
;;;973      */                      
;;;974    HAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)(DMA_HandleTypeDef *_hdma))
000000  b510              PUSH     {r4,lr}
;;;975    {
000002  4603              MOV      r3,r0
;;;976    
;;;977      HAL_StatusTypeDef status = HAL_OK;
000004  2400              MOVS     r4,#0
;;;978    
;;;979      /* Process locked */
;;;980      __HAL_LOCK(hdma);
000006  bf00              NOP      
000008  6b58              LDR      r0,[r3,#0x34]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L12.18|
00000e  2002              MOVS     r0,#2
                  |L12.16|
;;;981    
;;;982      if(HAL_DMA_STATE_READY == hdma->State)
;;;983      {
;;;984        switch (CallbackID)
;;;985        {
;;;986        case  HAL_DMA_XFER_CPLT_CB_ID:
;;;987          hdma->XferCpltCallback = pCallback;
;;;988          break;
;;;989          
;;;990        case  HAL_DMA_XFER_HALFCPLT_CB_ID:
;;;991          hdma->XferHalfCpltCallback = pCallback;
;;;992          break;
;;;993          
;;;994        case  HAL_DMA_XFER_M1CPLT_CB_ID:
;;;995          hdma->XferM1CpltCallback = pCallback;
;;;996          break;
;;;997          
;;;998        case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
;;;999          hdma->XferM1HalfCpltCallback = pCallback;
;;;1000         break;
;;;1001         
;;;1002       case  HAL_DMA_XFER_ERROR_CB_ID:
;;;1003         hdma->XferErrorCallback = pCallback;
;;;1004         break;
;;;1005         
;;;1006       case  HAL_DMA_XFER_ABORT_CB_ID:
;;;1007         hdma->XferAbortCallback = pCallback;
;;;1008         break;
;;;1009         
;;;1010       default:
;;;1011         break;
;;;1012       }
;;;1013     }
;;;1014     else
;;;1015     {
;;;1016       /* Return error status */
;;;1017       status =  HAL_ERROR;
;;;1018     }
;;;1019   
;;;1020     /* Release Lock */
;;;1021     __HAL_UNLOCK(hdma);
;;;1022     
;;;1023     return status;
;;;1024   }
000010  bd10              POP      {r4,pc}
                  |L12.18|
000012  2001              MOVS     r0,#1                 ;980
000014  6358              STR      r0,[r3,#0x34]         ;980
000016  bf00              NOP                            ;980
000018  6b98              LDR      r0,[r3,#0x38]         ;982
00001a  2801              CMP      r0,#1                 ;982
00001c  d114              BNE      |L12.72|
00001e  2906              CMP      r1,#6                 ;984
000020  d210              BCS      |L12.68|
000022  e8dff001          TBB      [pc,r1]               ;984
000026  0305              DCB      0x03,0x05
000028  07090b0d          DCB      0x07,0x09,0x0b,0x0d
00002c  641a              STR      r2,[r3,#0x40]         ;987
00002e  e00a              B        |L12.70|
000030  645a              STR      r2,[r3,#0x44]         ;991
000032  e008              B        |L12.70|
000034  649a              STR      r2,[r3,#0x48]         ;995
000036  e006              B        |L12.70|
000038  64da              STR      r2,[r3,#0x4c]         ;999
00003a  e004              B        |L12.70|
00003c  651a              STR      r2,[r3,#0x50]         ;1003
00003e  e002              B        |L12.70|
000040  655a              STR      r2,[r3,#0x54]         ;1007
000042  e000              B        |L12.70|
                  |L12.68|
000044  bf00              NOP                            ;1011
                  |L12.70|
000046  e000              B        |L12.74|
                  |L12.72|
000048  2401              MOVS     r4,#1                 ;1017
                  |L12.74|
00004a  bf00              NOP                            ;1021
00004c  2000              MOVS     r0,#0                 ;1021
00004e  6358              STR      r0,[r3,#0x34]         ;1021
000050  bf00              NOP                            ;1021
000052  4620              MOV      r0,r4                 ;1023
000054  e7dc              B        |L12.16|
;;;1025   
                          ENDP


                          AREA ||i.HAL_DMA_Start||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Start PROC
;;;412      */
;;;413    HAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;414    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;415      HAL_StatusTypeDef status = HAL_OK;
00000c  f04f0800          MOV      r8,#0
;;;416      
;;;417      /* Check the parameters */
;;;418      assert_param(IS_DMA_BUFFER_SIZE(DataLength));
;;;419    
;;;420      /* Process locked */
;;;421      __HAL_LOCK(hdma);
000010  bf00              NOP      
000012  6b60              LDR      r0,[r4,#0x34]
000014  2801              CMP      r0,#1
000016  d102              BNE      |L13.30|
000018  2002              MOVS     r0,#2
                  |L13.26|
;;;422    
;;;423      if(HAL_DMA_STATE_READY == hdma->State)
;;;424      {
;;;425        /* Change DMA peripheral state */
;;;426        hdma->State = HAL_DMA_STATE_BUSY;
;;;427        
;;;428        /* Initialize the error code */
;;;429        hdma->ErrorCode = HAL_DMA_ERROR_NONE;    
;;;430        
;;;431        /* Configure the source, destination address and the data length */
;;;432        DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
;;;433    
;;;434        /* Enable the Peripheral */
;;;435        __HAL_DMA_ENABLE(hdma);
;;;436      }
;;;437      else
;;;438      {
;;;439        /* Process unlocked */
;;;440        __HAL_UNLOCK(hdma);
;;;441        
;;;442        /* Return error status */
;;;443        status = HAL_BUSY;
;;;444      } 
;;;445      return status; 
;;;446    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L13.30|
00001e  2001              MOVS     r0,#1                 ;421
000020  6360              STR      r0,[r4,#0x34]         ;421
000022  bf00              NOP                            ;421
000024  6ba0              LDR      r0,[r4,#0x38]         ;423
000026  2801              CMP      r0,#1                 ;423
000028  d110              BNE      |L13.76|
00002a  2002              MOVS     r0,#2                 ;426
00002c  63a0              STR      r0,[r4,#0x38]         ;426
00002e  2000              MOVS     r0,#0                 ;429
000030  65a0              STR      r0,[r4,#0x58]         ;429
000032  463b              MOV      r3,r7                 ;432
000034  4632              MOV      r2,r6                 ;432
000036  4629              MOV      r1,r5                 ;432
000038  4620              MOV      r0,r4                 ;432
00003a  f7fffffe          BL       DMA_SetConfig
00003e  6820              LDR      r0,[r4,#0]            ;435
000040  6800              LDR      r0,[r0,#0]            ;435
000042  f0400001          ORR      r0,r0,#1              ;435
000046  6821              LDR      r1,[r4,#0]            ;435
000048  6008              STR      r0,[r1,#0]            ;435
00004a  e005              B        |L13.88|
                  |L13.76|
00004c  bf00              NOP                            ;440
00004e  2000              MOVS     r0,#0                 ;440
000050  6360              STR      r0,[r4,#0x34]         ;440
000052  bf00              NOP                            ;440
000054  f04f0802          MOV      r8,#2                 ;443
                  |L13.88|
000058  4640              MOV      r0,r8                 ;445
00005a  e7de              B        |L13.26|
;;;447    
                          ENDP


                          AREA ||i.HAL_DMA_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Start_IT PROC
;;;456      */
;;;457    HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;458    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;459      HAL_StatusTypeDef status = HAL_OK;
00000c  f04f0800          MOV      r8,#0
;;;460    
;;;461      /* calculate DMA base and stream number */
;;;462      DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
000010  f8d4905c          LDR      r9,[r4,#0x5c]
;;;463      
;;;464      /* Check the parameters */
;;;465      assert_param(IS_DMA_BUFFER_SIZE(DataLength));
;;;466     
;;;467      /* Process locked */
;;;468      __HAL_LOCK(hdma);
000014  bf00              NOP      
000016  6b60              LDR      r0,[r4,#0x34]
000018  2801              CMP      r0,#1
00001a  d102              BNE      |L14.34|
00001c  2002              MOVS     r0,#2
                  |L14.30|
;;;469      
;;;470      if(HAL_DMA_STATE_READY == hdma->State)
;;;471      {
;;;472        /* Change DMA peripheral state */
;;;473        hdma->State = HAL_DMA_STATE_BUSY;
;;;474        
;;;475        /* Initialize the error code */
;;;476        hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;477        
;;;478        /* Configure the source, destination address and the data length */
;;;479        DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
;;;480        
;;;481        /* Clear all interrupt flags at correct offset within the register */
;;;482        regs->IFCR = 0x3FU << hdma->StreamIndex;
;;;483        
;;;484        /* Enable Common interrupts*/
;;;485        hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
;;;486        hdma->Instance->FCR |= DMA_IT_FE;
;;;487        
;;;488        if(hdma->XferHalfCpltCallback != NULL)
;;;489        {
;;;490          hdma->Instance->CR  |= DMA_IT_HT;
;;;491        }
;;;492        
;;;493        /* Enable the Peripheral */
;;;494        __HAL_DMA_ENABLE(hdma);
;;;495      }
;;;496      else
;;;497      {
;;;498        /* Process unlocked */
;;;499        __HAL_UNLOCK(hdma);	  
;;;500        
;;;501        /* Return error status */
;;;502        status = HAL_BUSY;
;;;503      }
;;;504      
;;;505      return status;
;;;506    }
00001e  e8bd87f0          POP      {r4-r10,pc}
                  |L14.34|
000022  2001              MOVS     r0,#1                 ;468
000024  6360              STR      r0,[r4,#0x34]         ;468
000026  bf00              NOP                            ;468
000028  6ba0              LDR      r0,[r4,#0x38]         ;470
00002a  2801              CMP      r0,#1                 ;470
00002c  d12a              BNE      |L14.132|
00002e  2002              MOVS     r0,#2                 ;473
000030  63a0              STR      r0,[r4,#0x38]         ;473
000032  2000              MOVS     r0,#0                 ;476
000034  65a0              STR      r0,[r4,#0x58]         ;476
000036  463b              MOV      r3,r7                 ;479
000038  4632              MOV      r2,r6                 ;479
00003a  4629              MOV      r1,r5                 ;479
00003c  4620              MOV      r0,r4                 ;479
00003e  f7fffffe          BL       DMA_SetConfig
000042  f8941060          LDRB     r1,[r4,#0x60]         ;482
000046  203f              MOVS     r0,#0x3f              ;482
000048  4088              LSLS     r0,r0,r1              ;482
00004a  f8c90008          STR      r0,[r9,#8]            ;482
00004e  6820              LDR      r0,[r4,#0]            ;485
000050  6800              LDR      r0,[r0,#0]            ;485
000052  f0400016          ORR      r0,r0,#0x16           ;485
000056  6821              LDR      r1,[r4,#0]            ;485
000058  6008              STR      r0,[r1,#0]            ;485
00005a  6820              LDR      r0,[r4,#0]            ;486
00005c  6940              LDR      r0,[r0,#0x14]         ;486
00005e  f0400080          ORR      r0,r0,#0x80           ;486
000062  6821              LDR      r1,[r4,#0]            ;486
000064  6148              STR      r0,[r1,#0x14]         ;486
000066  6c60              LDR      r0,[r4,#0x44]         ;488
000068  b128              CBZ      r0,|L14.118|
00006a  6820              LDR      r0,[r4,#0]            ;490
00006c  6800              LDR      r0,[r0,#0]            ;490
00006e  f0400008          ORR      r0,r0,#8              ;490
000072  6821              LDR      r1,[r4,#0]            ;490
000074  6008              STR      r0,[r1,#0]            ;490
                  |L14.118|
000076  6820              LDR      r0,[r4,#0]            ;494
000078  6800              LDR      r0,[r0,#0]            ;494
00007a  f0400001          ORR      r0,r0,#1              ;494
00007e  6821              LDR      r1,[r4,#0]            ;494
000080  6008              STR      r0,[r1,#0]            ;494
000082  e005              B        |L14.144|
                  |L14.132|
000084  bf00              NOP                            ;499
000086  2000              MOVS     r0,#0                 ;499
000088  6360              STR      r0,[r4,#0x34]         ;499
00008a  bf00              NOP                            ;499
00008c  f04f0802          MOV      r8,#2                 ;502
                  |L14.144|
000090  4640              MOV      r0,r8                 ;505
000092  e7c4              B        |L14.30|
;;;507    
                          ENDP


                          AREA ||i.HAL_DMA_UnRegisterCallback||, CODE, READONLY, ALIGN=1

                  HAL_DMA_UnRegisterCallback PROC
;;;1033     */              
;;;1034   HAL_StatusTypeDef HAL_DMA_UnRegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID)
000000  4602              MOV      r2,r0
;;;1035   {
;;;1036     HAL_StatusTypeDef status = HAL_OK;
000002  2300              MOVS     r3,#0
;;;1037     
;;;1038     /* Process locked */
;;;1039     __HAL_LOCK(hdma);
000004  bf00              NOP      
000006  6b50              LDR      r0,[r2,#0x34]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L15.16|
00000c  2002              MOVS     r0,#2
                  |L15.14|
;;;1040     
;;;1041     if(HAL_DMA_STATE_READY == hdma->State)
;;;1042     {
;;;1043       switch (CallbackID)
;;;1044       {
;;;1045       case  HAL_DMA_XFER_CPLT_CB_ID:
;;;1046         hdma->XferCpltCallback = NULL;
;;;1047         break;
;;;1048         
;;;1049       case  HAL_DMA_XFER_HALFCPLT_CB_ID:
;;;1050         hdma->XferHalfCpltCallback = NULL;
;;;1051         break;
;;;1052         
;;;1053       case  HAL_DMA_XFER_M1CPLT_CB_ID:
;;;1054         hdma->XferM1CpltCallback = NULL;
;;;1055         break;
;;;1056         
;;;1057       case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
;;;1058         hdma->XferM1HalfCpltCallback = NULL;
;;;1059         break;
;;;1060         
;;;1061       case  HAL_DMA_XFER_ERROR_CB_ID:
;;;1062         hdma->XferErrorCallback = NULL;
;;;1063         break;
;;;1064         
;;;1065       case  HAL_DMA_XFER_ABORT_CB_ID:
;;;1066         hdma->XferAbortCallback = NULL;
;;;1067         break; 
;;;1068         
;;;1069       case   HAL_DMA_XFER_ALL_CB_ID:
;;;1070         hdma->XferCpltCallback = NULL;
;;;1071         hdma->XferHalfCpltCallback = NULL;
;;;1072         hdma->XferM1CpltCallback = NULL;
;;;1073         hdma->XferM1HalfCpltCallback = NULL;
;;;1074         hdma->XferErrorCallback = NULL;
;;;1075         hdma->XferAbortCallback = NULL;
;;;1076         break; 
;;;1077         
;;;1078       default:
;;;1079         status = HAL_ERROR;
;;;1080         break;
;;;1081       }
;;;1082     }
;;;1083     else
;;;1084     {
;;;1085       status = HAL_ERROR;
;;;1086     }
;;;1087     
;;;1088     /* Release Lock */
;;;1089     __HAL_UNLOCK(hdma);
;;;1090     
;;;1091     return status;
;;;1092   }
00000e  4770              BX       lr
                  |L15.16|
000010  2001              MOVS     r0,#1                 ;1039
000012  6350              STR      r0,[r2,#0x34]         ;1039
000014  bf00              NOP                            ;1039
000016  6b90              LDR      r0,[r2,#0x38]         ;1041
000018  2801              CMP      r0,#1                 ;1041
00001a  d124              BNE      |L15.102|
00001c  2907              CMP      r1,#7                 ;1043
00001e  d21f              BCS      |L15.96|
000020  e8dff001          TBB      [pc,r1]               ;1043
000024  04070a0d          DCB      0x04,0x07,0x0a,0x0d
000028  10131600          DCB      0x10,0x13,0x16,0x00
00002c  2000              MOVS     r0,#0                 ;1046
00002e  6410              STR      r0,[r2,#0x40]         ;1046
000030  e018              B        |L15.100|
000032  2000              MOVS     r0,#0                 ;1050
000034  6450              STR      r0,[r2,#0x44]         ;1050
000036  e015              B        |L15.100|
000038  2000              MOVS     r0,#0                 ;1054
00003a  6490              STR      r0,[r2,#0x48]         ;1054
00003c  e012              B        |L15.100|
00003e  2000              MOVS     r0,#0                 ;1058
000040  64d0              STR      r0,[r2,#0x4c]         ;1058
000042  e00f              B        |L15.100|
000044  2000              MOVS     r0,#0                 ;1062
000046  6510              STR      r0,[r2,#0x50]         ;1062
000048  e00c              B        |L15.100|
00004a  2000              MOVS     r0,#0                 ;1066
00004c  6550              STR      r0,[r2,#0x54]         ;1066
00004e  e009              B        |L15.100|
000050  2000              MOVS     r0,#0                 ;1070
000052  6410              STR      r0,[r2,#0x40]         ;1070
000054  6450              STR      r0,[r2,#0x44]         ;1071
000056  6490              STR      r0,[r2,#0x48]         ;1072
000058  64d0              STR      r0,[r2,#0x4c]         ;1073
00005a  6510              STR      r0,[r2,#0x50]         ;1074
00005c  6550              STR      r0,[r2,#0x54]         ;1075
00005e  e001              B        |L15.100|
                  |L15.96|
000060  2301              MOVS     r3,#1                 ;1079
000062  bf00              NOP                            ;1080
                  |L15.100|
000064  e000              B        |L15.104|
                  |L15.102|
000066  2301              MOVS     r3,#1                 ;1085
                  |L15.104|
000068  bf00              NOP                            ;1089
00006a  2000              MOVS     r0,#0                 ;1089
00006c  6350              STR      r0,[r2,#0x34]         ;1089
00006e  bf00              NOP                            ;1089
000070  4618              MOV      r0,r3                 ;1091
000072  e7cc              B        |L15.14|
;;;1093   
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  flagBitshiftOffset
000000  00061016          DCB      0x00,0x06,0x10,0x16
000004  00061016          DCB      0x00,0x06,0x10,0x16

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_dma.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_dma_c_c25f65ec____REV16|
#line 388 "..\\..\\..\\..\\Library\\STM32F7xx_HAL_Driver\\Core\\cmsis_armcc.h"
|__asm___19_stm32f7xx_hal_dma_c_c25f65ec____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_dma_c_c25f65ec____REVSH|
#line 402
|__asm___19_stm32f7xx_hal_dma_c_c25f65ec____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_dma_c_c25f65ec____RRX|
#line 587
|__asm___19_stm32f7xx_hal_dma_c_c25f65ec____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
