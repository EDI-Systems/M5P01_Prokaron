; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f10x_tim.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f10x_tim.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32F10x_StdPeriph_Lib_V3.3.0\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\M0P0_Library\STM32F10x_StdPeriph_Lib_V3.3.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\..\M0P0_Library\STM32F10x_StdPeriph_Lib_V3.3.0\Libraries\CMSIS -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F103RET6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f10x_tim.crf ..\..\..\M0P0_Library\STM32F10x_StdPeriph_Lib_V3.3.0\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_tim.c]
                          THUMB

                          AREA ||i.TIM_ARRPreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_ARRPreloadConfig PROC
;;;1398     */
;;;1399   void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1400   {
;;;1401     /* Check the parameters */
;;;1402     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1403     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1404     if (NewState != DISABLE)
;;;1405     {
;;;1406       /* Set the ARR Preload Bit */
;;;1407       TIMx->CR1 |= TIM_CR1_ARPE;
;;;1408     }
;;;1409     else
;;;1410     {
;;;1411       /* Reset the ARR Preload Bit */
;;;1412       TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_ARPE);
000002  8801              LDRH     r1,[r0,#0]
000004  bf14              ITE      NE                    ;1407
000006  f0410180          ORRNE    r1,r1,#0x80           ;1407
00000a  f0210180          BICEQ    r1,r1,#0x80
00000e  8001              STRH     r1,[r0,#0]            ;1407
;;;1413     }
;;;1414   }
000010  4770              BX       lr
;;;1415   
                          ENDP


                          AREA ||i.TIM_BDTRConfig||, CODE, READONLY, ALIGN=1

                  TIM_BDTRConfig PROC
;;;701      */
;;;702    void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
000000  880a              LDRH     r2,[r1,#0]
;;;703    {
;;;704      /* Check the parameters */
;;;705      assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;706      assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
;;;707      assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
;;;708      assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
;;;709      assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
;;;710      assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
;;;711      assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
;;;712      /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
;;;713         the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;714      TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
000002  884b              LDRH     r3,[r1,#2]
000004  f8b1c006          LDRH     r12,[r1,#6]
000008  431a              ORRS     r2,r2,r3
00000a  888b              LDRH     r3,[r1,#4]
00000c  ea43030c          ORR      r3,r3,r12
000010  431a              ORRS     r2,r2,r3
000012  890b              LDRH     r3,[r1,#8]
000014  431a              ORRS     r2,r2,r3
000016  894b              LDRH     r3,[r1,#0xa]
000018  8989              LDRH     r1,[r1,#0xc]
00001a  431a              ORRS     r2,r2,r3
00001c  4311              ORRS     r1,r1,r2
00001e  f8a01044          STRH     r1,[r0,#0x44]
;;;715                 TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
;;;716                 TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
;;;717                 TIM_BDTRInitStruct->TIM_AutomaticOutput;
;;;718    }
000022  4770              BX       lr
;;;719    
                          ENDP


                          AREA ||i.TIM_BDTRStructInit||, CODE, READONLY, ALIGN=1

                  TIM_BDTRStructInit PROC
;;;776      */
;;;777    void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
000000  2100              MOVS     r1,#0
;;;778    {
;;;779      /* Set the default configuration */
;;;780      TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
000002  8001              STRH     r1,[r0,#0]
;;;781      TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;782      TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
000006  8081              STRH     r1,[r0,#4]
;;;783      TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
000008  80c1              STRH     r1,[r0,#6]
;;;784      TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
00000a  8101              STRH     r1,[r0,#8]
;;;785      TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
00000c  8141              STRH     r1,[r0,#0xa]
;;;786      TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
00000e  8181              STRH     r1,[r0,#0xc]
;;;787    }
000010  4770              BX       lr
;;;788    
                          ENDP


                          AREA ||i.TIM_CCPreloadControl||, CODE, READONLY, ALIGN=1

                  TIM_CCPreloadControl PROC
;;;1472     */
;;;1473   void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1474   { 
;;;1475     /* Check the parameters */
;;;1476     assert_param(IS_TIM_LIST5_PERIPH(TIMx));
;;;1477     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1478     if (NewState != DISABLE)
;;;1479     {
;;;1480       /* Set the CCPC Bit */
;;;1481       TIMx->CR2 |= TIM_CR2_CCPC;
;;;1482     }
;;;1483     else
;;;1484     {
;;;1485       /* Reset the CCPC Bit */
;;;1486       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCPC);
000002  8881              LDRH     r1,[r0,#4]
000004  bf14              ITE      NE                    ;1481
000006  f0410101          ORRNE    r1,r1,#1              ;1481
00000a  f0210101          BICEQ    r1,r1,#1
00000e  8081              STRH     r1,[r0,#4]            ;1481
;;;1487     }
;;;1488   }
000010  4770              BX       lr
;;;1489   
                          ENDP


                          AREA ||i.TIM_CCxCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxCmd PROC
;;;1963     */
;;;1964   void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
000000  2301              MOVS     r3,#1
;;;1965   {
;;;1966     uint16_t tmp = 0;
;;;1967   
;;;1968     /* Check the parameters */
;;;1969     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;1970     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;1971     assert_param(IS_TIM_CCX(TIM_CCx));
;;;1972   
;;;1973     tmp = CCER_CCE_Set << TIM_Channel;
;;;1974   
;;;1975     /* Reset the CCxE Bit */
;;;1976     TIMx->CCER &= (uint16_t)~ tmp;
000002  f8b0c020          LDRH     r12,[r0,#0x20]
000006  408b              LSLS     r3,r3,r1              ;1973
000008  ea2c0303          BIC      r3,r12,r3
00000c  8403              STRH     r3,[r0,#0x20]
;;;1977   
;;;1978     /* Set or reset the CCxE Bit */ 
;;;1979     TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
00000e  8c03              LDRH     r3,[r0,#0x20]
000010  fa02f101          LSL      r1,r2,r1
000014  4319              ORRS     r1,r1,r3
000016  8401              STRH     r1,[r0,#0x20]
;;;1980   }
000018  4770              BX       lr
;;;1981   
                          ENDP


                          AREA ||i.TIM_CCxNCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxNCmd PROC
;;;1993     */
;;;1994   void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
000000  2304              MOVS     r3,#4
;;;1995   {
;;;1996     uint16_t tmp = 0;
;;;1997   
;;;1998     /* Check the parameters */
;;;1999     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2000     assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
;;;2001     assert_param(IS_TIM_CCXN(TIM_CCxN));
;;;2002   
;;;2003     tmp = CCER_CCNE_Set << TIM_Channel;
;;;2004   
;;;2005     /* Reset the CCxNE Bit */
;;;2006     TIMx->CCER &= (uint16_t) ~tmp;
000002  f8b0c020          LDRH     r12,[r0,#0x20]
000006  408b              LSLS     r3,r3,r1              ;2003
000008  ea2c0303          BIC      r3,r12,r3
00000c  8403              STRH     r3,[r0,#0x20]
;;;2007   
;;;2008     /* Set or reset the CCxNE Bit */ 
;;;2009     TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
00000e  8c03              LDRH     r3,[r0,#0x20]
000010  fa02f101          LSL      r1,r2,r1
000014  4319              ORRS     r1,r1,r3
000016  8401              STRH     r1,[r0,#0x20]
;;;2010   }
000018  4770              BX       lr
;;;2011   
                          ENDP


                          AREA ||i.TIM_ClearFlag||, CODE, READONLY, ALIGN=1

                  TIM_ClearFlag PROC
;;;2589     */
;;;2590   void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000000  43c9              MVNS     r1,r1
;;;2591   {  
;;;2592     /* Check the parameters */
;;;2593     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2594     assert_param(IS_TIM_CLEAR_FLAG(TIM_FLAG));
;;;2595      
;;;2596     /* Clear the flags */
;;;2597     TIMx->SR = (uint16_t)~TIM_FLAG;
000002  8201              STRH     r1,[r0,#0x10]
;;;2598   }
000004  4770              BX       lr
;;;2599   
                          ENDP


                          AREA ||i.TIM_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  TIM_ClearITPendingBit PROC
;;;2665     */
;;;2666   void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000000  43c9              MVNS     r1,r1
;;;2667   {
;;;2668     /* Check the parameters */
;;;2669     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2670     assert_param(IS_TIM_IT(TIM_IT));
;;;2671     /* Clear the IT pending Bit */
;;;2672     TIMx->SR = (uint16_t)~TIM_IT;
000002  8201              STRH     r1,[r0,#0x10]
;;;2673   }
000004  4770              BX       lr
;;;2674   
                          ENDP


                          AREA ||i.TIM_ClearOC1Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC1Ref PROC
;;;1696     */
;;;1697   void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1698   {
;;;1699     uint16_t tmpccmr1 = 0;
;;;1700     /* Check the parameters */
;;;1701     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1702     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1703   
;;;1704     tmpccmr1 = TIMx->CCMR1;
;;;1705   
;;;1706     /* Reset the OC1CE Bit */
;;;1707     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1CE);
000002  f0220280          BIC      r2,r2,#0x80
;;;1708     /* Enable or Disable the Output Compare Clear Bit */
;;;1709     tmpccmr1 |= TIM_OCClear;
000006  4311              ORRS     r1,r1,r2
;;;1710     /* Write to TIMx CCMR1 register */
;;;1711     TIMx->CCMR1 = tmpccmr1;
000008  8301              STRH     r1,[r0,#0x18]
;;;1712   }
00000a  4770              BX       lr
;;;1713   
                          ENDP


                          AREA ||i.TIM_ClearOC2Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC2Ref PROC
;;;1722     */
;;;1723   void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1724   {
;;;1725     uint16_t tmpccmr1 = 0;
;;;1726     /* Check the parameters */
;;;1727     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1728     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1729     tmpccmr1 = TIMx->CCMR1;
;;;1730     /* Reset the OC2CE Bit */
;;;1731     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2CE);
;;;1732     /* Enable or Disable the Output Compare Clear Bit */
;;;1733     tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f3c2020e          UBFX     r2,r2,#0,#15          ;1731
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1734     /* Write to TIMx CCMR1 register */
;;;1735     TIMx->CCMR1 = tmpccmr1;
000010  8301              STRH     r1,[r0,#0x18]
;;;1736   }
000012  4770              BX       lr
;;;1737   
                          ENDP


                          AREA ||i.TIM_ClearOC3Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC3Ref PROC
;;;1746     */
;;;1747   void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1748   {
;;;1749     uint16_t tmpccmr2 = 0;
;;;1750     /* Check the parameters */
;;;1751     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1752     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1753     tmpccmr2 = TIMx->CCMR2;
;;;1754     /* Reset the OC3CE Bit */
;;;1755     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3CE);
000002  f0220280          BIC      r2,r2,#0x80
;;;1756     /* Enable or Disable the Output Compare Clear Bit */
;;;1757     tmpccmr2 |= TIM_OCClear;
000006  4311              ORRS     r1,r1,r2
;;;1758     /* Write to TIMx CCMR2 register */
;;;1759     TIMx->CCMR2 = tmpccmr2;
000008  8381              STRH     r1,[r0,#0x1c]
;;;1760   }
00000a  4770              BX       lr
;;;1761   
                          ENDP


                          AREA ||i.TIM_ClearOC4Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC4Ref PROC
;;;1770     */
;;;1771   void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1772   {
;;;1773     uint16_t tmpccmr2 = 0;
;;;1774     /* Check the parameters */
;;;1775     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1776     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1777     tmpccmr2 = TIMx->CCMR2;
;;;1778     /* Reset the OC4CE Bit */
;;;1779     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4CE);
;;;1780     /* Enable or Disable the Output Compare Clear Bit */
;;;1781     tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f3c2020e          UBFX     r2,r2,#0,#15          ;1779
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1782     /* Write to TIMx CCMR2 register */
;;;1783     TIMx->CCMR2 = tmpccmr2;
000010  8381              STRH     r1,[r0,#0x1c]
;;;1784   }
000012  4770              BX       lr
;;;1785   
                          ENDP


                          AREA ||i.TIM_Cmd||, CODE, READONLY, ALIGN=1

                  TIM_Cmd PROC
;;;795      */
;;;796    void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;797    {
;;;798      /* Check the parameters */
;;;799      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;800      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;801      
;;;802      if (NewState != DISABLE)
;;;803      {
;;;804        /* Enable the TIM Counter */
;;;805        TIMx->CR1 |= TIM_CR1_CEN;
;;;806      }
;;;807      else
;;;808      {
;;;809        /* Disable the TIM Counter */
;;;810        TIMx->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN));
000002  8801              LDRH     r1,[r0,#0]
000004  bf14              ITE      NE                    ;805
000006  f0410101          ORRNE    r1,r1,#1              ;805
00000a  f0210101          BICEQ    r1,r1,#1
00000e  8001              STRH     r1,[r0,#0]            ;805
;;;811      }
;;;812    }
000010  4770              BX       lr
;;;813    
                          ENDP


                          AREA ||i.TIM_CounterModeConfig||, CODE, READONLY, ALIGN=1

                  TIM_CounterModeConfig PROC
;;;1188     */
;;;1189   void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
000000  8802              LDRH     r2,[r0,#0]
;;;1190   {
;;;1191     uint16_t tmpcr1 = 0;
;;;1192     /* Check the parameters */
;;;1193     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1194     assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
;;;1195     tmpcr1 = TIMx->CR1;
;;;1196     /* Reset the CMS and DIR Bits */
;;;1197     tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
000002  f0220270          BIC      r2,r2,#0x70
;;;1198     /* Set the Counter Mode */
;;;1199     tmpcr1 |= TIM_CounterMode;
000006  4311              ORRS     r1,r1,r2
;;;1200     /* Write to TIMx CR1 register */
;;;1201     TIMx->CR1 = tmpcr1;
000008  8001              STRH     r1,[r0,#0]
;;;1202   }
00000a  4770              BX       lr
;;;1203   
                          ENDP


                          AREA ||i.TIM_CtrlPWMOutputs||, CODE, READONLY, ALIGN=1

                  TIM_CtrlPWMOutputs PROC
;;;820      */
;;;821    void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;822    {
;;;823      /* Check the parameters */
;;;824      assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;825      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;826      if (NewState != DISABLE)
;;;827      {
;;;828        /* Enable the TIM Main Output */
;;;829        TIMx->BDTR |= TIM_BDTR_MOE;
;;;830      }
;;;831      else
;;;832      {
;;;833        /* Disable the TIM Main Output */
;;;834        TIMx->BDTR &= (uint16_t)(~((uint16_t)TIM_BDTR_MOE));
000002  f8b01044          LDRH     r1,[r0,#0x44]
000006  bf14              ITE      NE                    ;829
000008  f4414100          ORRNE    r1,r1,#0x8000         ;829
00000c  f3c1010e          UBFXEQ   r1,r1,#0,#15
000010  f8a01044          STRH     r1,[r0,#0x44]         ;829
;;;835      }  
;;;836    }
000014  4770              BX       lr
;;;837    
                          ENDP


                          AREA ||i.TIM_DMACmd||, CODE, READONLY, ALIGN=1

                  TIM_DMACmd PROC
;;;953      */
;;;954    void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;955    { 
;;;956      /* Check the parameters */
;;;957      assert_param(IS_TIM_LIST9_PERIPH(TIMx));
;;;958      assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
;;;959      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;960      
;;;961      if (NewState != DISABLE)
;;;962      {
;;;963        /* Enable the DMA sources */
;;;964        TIMx->DIER |= TIM_DMASource; 
;;;965      }
;;;966      else
;;;967      {
;;;968        /* Disable the DMA sources */
;;;969        TIMx->DIER &= (uint16_t)~TIM_DMASource;
000002  8982              LDRH     r2,[r0,#0xc]
000004  bf14              ITE      NE                    ;964
000006  4311              ORRNE    r1,r1,r2              ;964
000008  ea220101          BICEQ    r1,r2,r1
00000c  8181              STRH     r1,[r0,#0xc]          ;964
;;;970      }
;;;971    }
00000e  4770              BX       lr
;;;972    
                          ENDP


                          AREA ||i.TIM_DMAConfig||, CODE, READONLY, ALIGN=1

                  TIM_DMAConfig PROC
;;;926      */
;;;927    void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
000000  4311              ORRS     r1,r1,r2
;;;928    {
;;;929      /* Check the parameters */
;;;930      assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;931      assert_param(IS_TIM_DMA_BASE(TIM_DMABase));
;;;932      assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
;;;933      /* Set the DMA Base and the DMA Burst Length */
;;;934      TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
000002  f8a01048          STRH     r1,[r0,#0x48]
;;;935    }
000006  4770              BX       lr
;;;936    
                          ENDP


                          AREA ||i.TIM_DeInit||, CODE, READONLY, ALIGN=1

                  TIM_DeInit PROC
;;;120      */
;;;121    void TIM_DeInit(TIM_TypeDef* TIMx)
000000  b510              PUSH     {r4,lr}
;;;122    {
;;;123      /* Check the parameters */
;;;124      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;125     
;;;126      if (TIMx == TIM1)
000002  f1a04180          SUB      r1,r0,#0x40000000
000006  f5b13196          SUBS     r1,r1,#0x12c00
00000a  d03b              BEQ      |L18.132|
;;;127      {
;;;128        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
;;;129        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
;;;130      }     
;;;131      else if (TIMx == TIM2)
00000c  f1b04f80          CMP      r0,#0x40000000
000010  d04d              BEQ      |L18.174|
;;;132      {
;;;133        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
;;;134        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
;;;135      }
;;;136      else if (TIMx == TIM3)
000012  f5113194          ADDS     r1,r1,#0x12800
000016  d040              BEQ      |L18.154|
;;;137      {
;;;138        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
;;;139        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
;;;140      }
;;;141      else if (TIMx == TIM4)
000018  f5b16180          SUBS     r1,r1,#0x400
00001c  d051              BEQ      |L18.194|
;;;142      {
;;;143        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
;;;144        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
;;;145      } 
;;;146      else if (TIMx == TIM5)
00001e  f5b16180          SUBS     r1,r1,#0x400
000022  d058              BEQ      |L18.214|
;;;147      {
;;;148        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
;;;149        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
;;;150      } 
;;;151      else if (TIMx == TIM6)
000024  f5b16180          SUBS     r1,r1,#0x400
000028  d05f              BEQ      |L18.234|
;;;152      {
;;;153        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
;;;154        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
;;;155      } 
;;;156      else if (TIMx == TIM7)
00002a  f5b16180          SUBS     r1,r1,#0x400
00002e  d066              BEQ      |L18.254|
;;;157      {
;;;158        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
;;;159        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
;;;160      } 
;;;161      else if (TIMx == TIM8)
000030  f5b13190          SUBS     r1,r1,#0x12000
000034  d06d              BEQ      |L18.274|
;;;162      {
;;;163        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
;;;164        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);
;;;165      }
;;;166      else if (TIMx == TIM9)
000036  f5b151c0          SUBS     r1,r1,#0x1800
00003a  d075              BEQ      |L18.296|
;;;167      {      
;;;168        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
;;;169        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
;;;170       }  
;;;171      else if (TIMx == TIM10)
00003c  f5b16180          SUBS     r1,r1,#0x400
000040  d07d              BEQ      |L18.318|
;;;172      {      
;;;173        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
;;;174        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
;;;175      }  
;;;176      else if (TIMx == TIM11) 
000042  f5b16180          SUBS     r1,r1,#0x400
000046  d07d              BEQ      |L18.324|
;;;177      {     
;;;178        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
;;;179        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
;;;180      }  
;;;181      else if (TIMx == TIM12)
000048  f511319e          ADDS     r1,r1,#0x13c00
00004c  d07b              BEQ      |L18.326|
;;;182      {      
;;;183        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
;;;184        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
;;;185      }  
;;;186      else if (TIMx == TIM13) 
00004e  f5b16180          SUBS     r1,r1,#0x400
000052  d079              BEQ      |L18.328|
;;;187      {       
;;;188        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
;;;189        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  
;;;190      }
;;;191      else if (TIMx == TIM14) 
000054  f5b16180          SUBS     r1,r1,#0x400
000058  d077              BEQ      |L18.330|
;;;192      {       
;;;193        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
;;;194        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE);  
;;;195      }        
;;;196      else if (TIMx == TIM15)
00005a  f5b13190          SUBS     r1,r1,#0x12000
00005e  d075              BEQ      |L18.332|
;;;197      {
;;;198        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, ENABLE);
;;;199        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, DISABLE);
;;;200      } 
;;;201      else if (TIMx == TIM16)
000060  f5b16180          SUBS     r1,r1,#0x400
000064  d073              BEQ      |L18.334|
;;;202      {
;;;203        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, ENABLE);
;;;204        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, DISABLE);
;;;205      } 
;;;206      else
;;;207      {
;;;208        if (TIMx == TIM17)
000066  f5b16180          SUBS     r1,r1,#0x400
;;;209        {
;;;210          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, ENABLE);
;;;211          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, DISABLE);
;;;212        }  
;;;213      }
;;;214    }
00006a  bf18              IT       NE
00006c  bd10              POPNE    {r4,pc}
00006e  2101              MOVS     r1,#1                 ;210
000070  0488              LSLS     r0,r1,#18             ;210
000072  f7fffffe          BL       RCC_APB2PeriphResetCmd
000076  e8bd4010          POP      {r4,lr}               ;211
00007a  2100              MOVS     r1,#0                 ;211
00007c  f44f2080          MOV      r0,#0x40000           ;211
000080  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L18.132|
000084  2101              MOVS     r1,#1                 ;128
000086  02c8              LSLS     r0,r1,#11             ;128
000088  f7fffffe          BL       RCC_APB2PeriphResetCmd
00008c  e8bd4010          POP      {r4,lr}               ;129
000090  2100              MOVS     r1,#0                 ;129
000092  f44f6000          MOV      r0,#0x800             ;129
000096  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L18.154|
00009a  2101              MOVS     r1,#1                 ;138
00009c  2002              MOVS     r0,#2                 ;138
00009e  f7fffffe          BL       RCC_APB1PeriphResetCmd
0000a2  2100              MOVS     r1,#0                 ;139
0000a4  e8bd4010          POP      {r4,lr}               ;139
0000a8  2002              MOVS     r0,#2                 ;139
0000aa  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L18.174|
0000ae  2101              MOVS     r1,#1                 ;133
0000b0  4608              MOV      r0,r1                 ;133
0000b2  f7fffffe          BL       RCC_APB1PeriphResetCmd
0000b6  2100              MOVS     r1,#0                 ;134
0000b8  e8bd4010          POP      {r4,lr}               ;134
0000bc  2001              MOVS     r0,#1                 ;134
0000be  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L18.194|
0000c2  2101              MOVS     r1,#1                 ;143
0000c4  2004              MOVS     r0,#4                 ;143
0000c6  f7fffffe          BL       RCC_APB1PeriphResetCmd
0000ca  2100              MOVS     r1,#0                 ;144
0000cc  e8bd4010          POP      {r4,lr}               ;144
0000d0  2004              MOVS     r0,#4                 ;144
0000d2  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L18.214|
0000d6  2101              MOVS     r1,#1                 ;148
0000d8  2008              MOVS     r0,#8                 ;148
0000da  f7fffffe          BL       RCC_APB1PeriphResetCmd
0000de  2100              MOVS     r1,#0                 ;149
0000e0  e8bd4010          POP      {r4,lr}               ;149
0000e4  2008              MOVS     r0,#8                 ;149
0000e6  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L18.234|
0000ea  2101              MOVS     r1,#1                 ;153
0000ec  2010              MOVS     r0,#0x10              ;153
0000ee  f7fffffe          BL       RCC_APB1PeriphResetCmd
0000f2  2100              MOVS     r1,#0                 ;154
0000f4  e8bd4010          POP      {r4,lr}               ;154
0000f8  2010              MOVS     r0,#0x10              ;154
0000fa  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L18.254|
0000fe  2101              MOVS     r1,#1                 ;158
000100  2020              MOVS     r0,#0x20              ;158
000102  f7fffffe          BL       RCC_APB1PeriphResetCmd
000106  2100              MOVS     r1,#0                 ;159
000108  e8bd4010          POP      {r4,lr}               ;159
00010c  2020              MOVS     r0,#0x20              ;159
00010e  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L18.274|
000112  2101              MOVS     r1,#1                 ;163
000114  0348              LSLS     r0,r1,#13             ;163
000116  f7fffffe          BL       RCC_APB2PeriphResetCmd
00011a  e8bd4010          POP      {r4,lr}               ;164
00011e  2100              MOVS     r1,#0                 ;164
000120  f44f5000          MOV      r0,#0x2000            ;164
000124  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L18.296|
000128  2101              MOVS     r1,#1                 ;168
00012a  04c8              LSLS     r0,r1,#19             ;168
00012c  f7fffffe          BL       RCC_APB2PeriphResetCmd
000130  e8bd4010          POP      {r4,lr}               ;169
000134  2100              MOVS     r1,#0                 ;169
000136  f44f2000          MOV      r0,#0x80000           ;169
00013a  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L18.318|
00013e  2101              MOVS     r1,#1                 ;173
000140  0508              LSLS     r0,r1,#20             ;173
000142  e005              B        |L18.336|
                  |L18.324|
000144  e00d              B        |L18.354|
                  |L18.326|
000146  e017              B        |L18.376|
                  |L18.328|
000148  e020              B        |L18.396|
                  |L18.330|
00014a  e029              B        |L18.416|
                  |L18.332|
00014c  e033              B        |L18.438|
                  |L18.334|
00014e  e03d              B        |L18.460|
                  |L18.336|
000150  f7fffffe          BL       RCC_APB2PeriphResetCmd
000154  e8bd4010          POP      {r4,lr}               ;174
000158  2100              MOVS     r1,#0                 ;174
00015a  f44f1080          MOV      r0,#0x100000          ;174
00015e  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L18.354|
000162  2101              MOVS     r1,#1                 ;178
000164  0548              LSLS     r0,r1,#21             ;178
000166  f7fffffe          BL       RCC_APB2PeriphResetCmd
00016a  e8bd4010          POP      {r4,lr}               ;179
00016e  2100              MOVS     r1,#0                 ;179
000170  f44f1000          MOV      r0,#0x200000          ;179
000174  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L18.376|
000178  2101              MOVS     r1,#1                 ;183
00017a  2040              MOVS     r0,#0x40              ;183
00017c  f7fffffe          BL       RCC_APB1PeriphResetCmd
000180  2100              MOVS     r1,#0                 ;184
000182  e8bd4010          POP      {r4,lr}               ;184
000186  2040              MOVS     r0,#0x40              ;184
000188  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L18.396|
00018c  2101              MOVS     r1,#1                 ;188
00018e  2080              MOVS     r0,#0x80              ;188
000190  f7fffffe          BL       RCC_APB1PeriphResetCmd
000194  2100              MOVS     r1,#0                 ;189
000196  e8bd4010          POP      {r4,lr}               ;189
00019a  2080              MOVS     r0,#0x80              ;189
00019c  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L18.416|
0001a0  2101              MOVS     r1,#1                 ;193
0001a2  0208              LSLS     r0,r1,#8              ;193
0001a4  f7fffffe          BL       RCC_APB1PeriphResetCmd
0001a8  e8bd4010          POP      {r4,lr}               ;194
0001ac  2100              MOVS     r1,#0                 ;194
0001ae  f44f7080          MOV      r0,#0x100             ;194
0001b2  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L18.438|
0001b6  2101              MOVS     r1,#1                 ;198
0001b8  0408              LSLS     r0,r1,#16             ;198
0001ba  f7fffffe          BL       RCC_APB2PeriphResetCmd
0001be  e8bd4010          POP      {r4,lr}               ;199
0001c2  2100              MOVS     r1,#0                 ;199
0001c4  f44f3080          MOV      r0,#0x10000           ;199
0001c8  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L18.460|
0001cc  2101              MOVS     r1,#1                 ;203
0001ce  0448              LSLS     r0,r1,#17             ;203
0001d0  f7fffffe          BL       RCC_APB2PeriphResetCmd
0001d4  e8bd4010          POP      {r4,lr}               ;204
0001d8  2100              MOVS     r1,#0                 ;204
0001da  f44f3000          MOV      r0,#0x20000           ;204
0001de  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
;;;215    
                          ENDP


                          AREA ||i.TIM_ETRClockMode1Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode1Config PROC
;;;1064     */
;;;1065   void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
000000  b410              PUSH     {r4}
000002  f8b0c008          LDRH     r12,[r0,#8]
000006  f64f74ff          MOV      r4,#0xffff
00000a  ea042303          AND      r3,r4,r3,LSL #8
00000e  431a              ORRS     r2,r2,r3
000010  f00c0cff          AND      r12,r12,#0xff
000014  4311              ORRS     r1,r1,r2
000016  ea41010c          ORR      r1,r1,r12
00001a  8101              STRH     r1,[r0,#8]
;;;1066                                uint16_t ExtTRGFilter)
;;;1067   {
;;;1068     uint16_t tmpsmcr = 0;
;;;1069     /* Check the parameters */
;;;1070     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1071     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1072     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1073     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1074     /* Configure the ETR Clock source */
;;;1075     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
;;;1076     
;;;1077     /* Get the TIMx SMCR register value */
;;;1078     tmpsmcr = TIMx->SMCR;
00001c  8901              LDRH     r1,[r0,#8]
;;;1079     /* Reset the SMS Bits */
;;;1080     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
;;;1081     /* Select the External clock mode1 */
;;;1082     tmpsmcr |= TIM_SlaveMode_External1;
;;;1083     /* Select the Trigger selection : ETRF */
;;;1084     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
;;;1085     tmpsmcr |= TIM_TS_ETRF;
00001e  f0410177          ORR      r1,r1,#0x77
;;;1086     /* Write to TIMx SMCR */
;;;1087     TIMx->SMCR = tmpsmcr;
000022  8101              STRH     r1,[r0,#8]
;;;1088   }
000024  bc10              POP      {r4}
000026  4770              BX       lr
;;;1089   
                          ENDP


                          AREA ||i.TIM_ETRClockMode2Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode2Config PROC
;;;1106     */
;;;1107   void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
000000  b410              PUSH     {r4}
000002  f8b0c008          LDRH     r12,[r0,#8]
000006  f64f74ff          MOV      r4,#0xffff
00000a  ea042303          AND      r3,r4,r3,LSL #8
00000e  431a              ORRS     r2,r2,r3
000010  f00c0cff          AND      r12,r12,#0xff
000014  4311              ORRS     r1,r1,r2
000016  ea41010c          ORR      r1,r1,r12
00001a  8101              STRH     r1,[r0,#8]
;;;1108                                uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;1109   {
;;;1110     /* Check the parameters */
;;;1111     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1112     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1113     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1114     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1115     /* Configure the ETR Clock source */
;;;1116     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
;;;1117     /* Enable the External clock mode2 */
;;;1118     TIMx->SMCR |= TIM_SMCR_ECE;
00001c  8901              LDRH     r1,[r0,#8]
00001e  f4414180          ORR      r1,r1,#0x4000
000022  8101              STRH     r1,[r0,#8]
;;;1119   }
000024  bc10              POP      {r4}
000026  4770              BX       lr
;;;1120   
                          ENDP


                          AREA ||i.TIM_ETRConfig||, CODE, READONLY, ALIGN=1

                  TIM_ETRConfig PROC
;;;1137     */
;;;1138   void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
000000  b410              PUSH     {r4}
;;;1139                      uint16_t ExtTRGFilter)
;;;1140   {
;;;1141     uint16_t tmpsmcr = 0;
;;;1142     /* Check the parameters */
;;;1143     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1144     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1145     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1146     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1147     tmpsmcr = TIMx->SMCR;
000002  f8b0c008          LDRH     r12,[r0,#8]
;;;1148     /* Reset the ETR Bits */
;;;1149     tmpsmcr &= SMCR_ETR_Mask;
;;;1150     /* Set the Prescaler, the Filter value and the Polarity */
;;;1151     tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
000006  f64f74ff          MOV      r4,#0xffff
00000a  ea042303          AND      r3,r4,r3,LSL #8
00000e  431a              ORRS     r2,r2,r3
000010  f00c0cff          AND      r12,r12,#0xff         ;1149
000014  4311              ORRS     r1,r1,r2
000016  ea41010c          ORR      r1,r1,r12
;;;1152     /* Write to TIMx SMCR */
;;;1153     TIMx->SMCR = tmpsmcr;
00001a  8101              STRH     r1,[r0,#8]
;;;1154   }
00001c  bc10              POP      {r4}
00001e  4770              BX       lr
;;;1155   
                          ENDP


                          AREA ||i.TIM_EncoderInterfaceConfig||, CODE, READONLY, ALIGN=1

                  TIM_EncoderInterfaceConfig PROC
;;;1253     */
;;;1254   void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
000000  b430              PUSH     {r4,r5}
;;;1255                                   uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
;;;1256   {
;;;1257     uint16_t tmpsmcr = 0;
;;;1258     uint16_t tmpccmr1 = 0;
;;;1259     uint16_t tmpccer = 0;
;;;1260       
;;;1261     /* Check the parameters */
;;;1262     assert_param(IS_TIM_LIST5_PERIPH(TIMx));
;;;1263     assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
;;;1264     assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
;;;1265     assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
;;;1266   
;;;1267     /* Get the TIMx SMCR register value */
;;;1268     tmpsmcr = TIMx->SMCR;
000002  8905              LDRH     r5,[r0,#8]
;;;1269     
;;;1270     /* Get the TIMx CCMR1 register value */
;;;1271     tmpccmr1 = TIMx->CCMR1;
000004  f8b0c018          LDRH     r12,[r0,#0x18]
;;;1272     
;;;1273     /* Get the TIMx CCER register value */
;;;1274     tmpccer = TIMx->CCER;
000008  8c04              LDRH     r4,[r0,#0x20]
;;;1275     
;;;1276     /* Set the encoder Mode */
;;;1277     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
00000a  f0250507          BIC      r5,r5,#7
;;;1278     tmpsmcr |= TIM_EncoderMode;
00000e  4329              ORRS     r1,r1,r5
;;;1279     
;;;1280     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;1281     tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S)));
000010  f02c0c03          BIC      r12,r12,#3
000014  f42c7c40          BIC      r12,r12,#0x300
;;;1282     tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
000018  f2401501          MOV      r5,#0x101
00001c  ea4c0c05          ORR      r12,r12,r5
;;;1283     
;;;1284     /* Set the TI1 and the TI2 Polarities */
;;;1285     tmpccer &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCER_CC1P)) & ((uint16_t)~((uint16_t)TIM_CCER_CC2P)));
;;;1286     tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
000020  f64f75ff          MOV      r5,#0xffff
000024  ea051303          AND      r3,r5,r3,LSL #4
000028  f0240422          BIC      r4,r4,#0x22           ;1285
00002c  431a              ORRS     r2,r2,r3
00002e  4322              ORRS     r2,r2,r4
;;;1287     
;;;1288     /* Write to TIMx SMCR */
;;;1289     TIMx->SMCR = tmpsmcr;
000030  8101              STRH     r1,[r0,#8]
;;;1290     /* Write to TIMx CCMR1 */
;;;1291     TIMx->CCMR1 = tmpccmr1;
000032  f8a0c018          STRH     r12,[r0,#0x18]
;;;1292     /* Write to TIMx CCER */
;;;1293     TIMx->CCER = tmpccer;
000036  8402              STRH     r2,[r0,#0x20]
;;;1294   }
000038  bc30              POP      {r4,r5}
00003a  4770              BX       lr
;;;1295   
                          ENDP


                          AREA ||i.TIM_ForcedOC1Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC1Config PROC
;;;1304     */
;;;1305   void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1306   {
;;;1307     uint16_t tmpccmr1 = 0;
;;;1308     /* Check the parameters */
;;;1309     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;1310     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1311     tmpccmr1 = TIMx->CCMR1;
;;;1312     /* Reset the OC1M Bits */
;;;1313     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1M);
000002  f0220270          BIC      r2,r2,#0x70
;;;1314     /* Configure The Forced output Mode */
;;;1315     tmpccmr1 |= TIM_ForcedAction;
000006  4311              ORRS     r1,r1,r2
;;;1316     /* Write to TIMx CCMR1 register */
;;;1317     TIMx->CCMR1 = tmpccmr1;
000008  8301              STRH     r1,[r0,#0x18]
;;;1318   }
00000a  4770              BX       lr
;;;1319   
                          ENDP


                          AREA ||i.TIM_ForcedOC2Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC2Config PROC
;;;1328     */
;;;1329   void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1330   {
;;;1331     uint16_t tmpccmr1 = 0;
;;;1332     /* Check the parameters */
;;;1333     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1334     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1335     tmpccmr1 = TIMx->CCMR1;
;;;1336     /* Reset the OC2M Bits */
;;;1337     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2M);
;;;1338     /* Configure The Forced output Mode */
;;;1339     tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f42242e0          BIC      r2,r2,#0x7000         ;1337
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1340     /* Write to TIMx CCMR1 register */
;;;1341     TIMx->CCMR1 = tmpccmr1;
000010  8301              STRH     r1,[r0,#0x18]
;;;1342   }
000012  4770              BX       lr
;;;1343   
                          ENDP


                          AREA ||i.TIM_ForcedOC3Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC3Config PROC
;;;1352     */
;;;1353   void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1354   {
;;;1355     uint16_t tmpccmr2 = 0;
;;;1356     /* Check the parameters */
;;;1357     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1358     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1359     tmpccmr2 = TIMx->CCMR2;
;;;1360     /* Reset the OC1M Bits */
;;;1361     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3M);
000002  f0220270          BIC      r2,r2,#0x70
;;;1362     /* Configure The Forced output Mode */
;;;1363     tmpccmr2 |= TIM_ForcedAction;
000006  4311              ORRS     r1,r1,r2
;;;1364     /* Write to TIMx CCMR2 register */
;;;1365     TIMx->CCMR2 = tmpccmr2;
000008  8381              STRH     r1,[r0,#0x1c]
;;;1366   }
00000a  4770              BX       lr
;;;1367   
                          ENDP


                          AREA ||i.TIM_ForcedOC4Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC4Config PROC
;;;1376     */
;;;1377   void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1378   {
;;;1379     uint16_t tmpccmr2 = 0;
;;;1380     /* Check the parameters */
;;;1381     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1382     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1383     tmpccmr2 = TIMx->CCMR2;
;;;1384     /* Reset the OC2M Bits */
;;;1385     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4M);
;;;1386     /* Configure The Forced output Mode */
;;;1387     tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f42242e0          BIC      r2,r2,#0x7000         ;1385
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1388     /* Write to TIMx CCMR2 register */
;;;1389     TIMx->CCMR2 = tmpccmr2;
000010  8381              STRH     r1,[r0,#0x1c]
;;;1390   }
000012  4770              BX       lr
;;;1391   
                          ENDP


                          AREA ||i.TIM_GenerateEvent||, CODE, READONLY, ALIGN=1

                  TIM_GenerateEvent PROC
;;;898      */
;;;899    void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
000000  8281              STRH     r1,[r0,#0x14]
;;;900    { 
;;;901      /* Check the parameters */
;;;902      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;903      assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
;;;904      
;;;905      /* Set the event sources */
;;;906      TIMx->EGR = TIM_EventSource;
;;;907    }
000002  4770              BX       lr
;;;908    
                          ENDP


                          AREA ||i.TIM_GetCapture1||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture1 PROC
;;;2446     */
;;;2447   uint16_t TIM_GetCapture1(TIM_TypeDef* TIMx)
000000  8e80              LDRH     r0,[r0,#0x34]
;;;2448   {
;;;2449     /* Check the parameters */
;;;2450     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;2451     /* Get the Capture 1 Register value */
;;;2452     return TIMx->CCR1;
;;;2453   }
000002  4770              BX       lr
;;;2454   
                          ENDP


                          AREA ||i.TIM_GetCapture2||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture2 PROC
;;;2459     */
;;;2460   uint16_t TIM_GetCapture2(TIM_TypeDef* TIMx)
000000  8f00              LDRH     r0,[r0,#0x38]
;;;2461   {
;;;2462     /* Check the parameters */
;;;2463     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2464     /* Get the Capture 2 Register value */
;;;2465     return TIMx->CCR2;
;;;2466   }
000002  4770              BX       lr
;;;2467   
                          ENDP


                          AREA ||i.TIM_GetCapture3||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture3 PROC
;;;2472     */
;;;2473   uint16_t TIM_GetCapture3(TIM_TypeDef* TIMx)
000000  8f80              LDRH     r0,[r0,#0x3c]
;;;2474   {
;;;2475     /* Check the parameters */
;;;2476     assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;2477     /* Get the Capture 3 Register value */
;;;2478     return TIMx->CCR3;
;;;2479   }
000002  4770              BX       lr
;;;2480   
                          ENDP


                          AREA ||i.TIM_GetCapture4||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture4 PROC
;;;2485     */
;;;2486   uint16_t TIM_GetCapture4(TIM_TypeDef* TIMx)
000000  f8b00040          LDRH     r0,[r0,#0x40]
;;;2487   {
;;;2488     /* Check the parameters */
;;;2489     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2490     /* Get the Capture 4 Register value */
;;;2491     return TIMx->CCR4;
;;;2492   }
000004  4770              BX       lr
;;;2493   
                          ENDP


                          AREA ||i.TIM_GetCounter||, CODE, READONLY, ALIGN=1

                  TIM_GetCounter PROC
;;;2498     */
;;;2499   uint16_t TIM_GetCounter(TIM_TypeDef* TIMx)
000000  8c80              LDRH     r0,[r0,#0x24]
;;;2500   {
;;;2501     /* Check the parameters */
;;;2502     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2503     /* Get the Counter Register value */
;;;2504     return TIMx->CNT;
;;;2505   }
000002  4770              BX       lr
;;;2506   
                          ENDP


                          AREA ||i.TIM_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetFlagStatus PROC
;;;2545     */
;;;2546   FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000000  4602              MOV      r2,r0
;;;2547   { 
;;;2548     ITStatus bitstatus = RESET;  
000002  2000              MOVS     r0,#0
;;;2549     /* Check the parameters */
;;;2550     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2551     assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
;;;2552     
;;;2553     if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
000004  8a12              LDRH     r2,[r2,#0x10]
000006  420a              TST      r2,r1
;;;2554     {
;;;2555       bitstatus = SET;
000008  bf18              IT       NE
00000a  2001              MOVNE    r0,#1
;;;2556     }
;;;2557     else
;;;2558     {
;;;2559       bitstatus = RESET;
;;;2560     }
;;;2561     return bitstatus;
;;;2562   }
00000c  4770              BX       lr
;;;2563   
                          ENDP


                          AREA ||i.TIM_GetITStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetITStatus PROC
;;;2621     */
;;;2622   ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000000  8a03              LDRH     r3,[r0,#0x10]
;;;2623   {
;;;2624     ITStatus bitstatus = RESET;  
000002  2200              MOVS     r2,#0
;;;2625     uint16_t itstatus = 0x0, itenable = 0x0;
;;;2626     /* Check the parameters */
;;;2627     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2628     assert_param(IS_TIM_GET_IT(TIM_IT));
;;;2629      
;;;2630     itstatus = TIMx->SR & TIM_IT;
;;;2631     
;;;2632     itenable = TIMx->DIER & TIM_IT;
000004  8980              LDRH     r0,[r0,#0xc]
000006  420b              TST      r3,r1                 ;2630
000008  ea000001          AND      r0,r0,r1
;;;2633     if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
00000c  bf1c              ITT      NE
00000e  2800              CMPNE    r0,#0
;;;2634     {
;;;2635       bitstatus = SET;
000010  2201              MOVNE    r2,#1
;;;2636     }
;;;2637     else
;;;2638     {
;;;2639       bitstatus = RESET;
;;;2640     }
;;;2641     return bitstatus;
000012  4610              MOV      r0,r2
;;;2642   }
000014  4770              BX       lr
;;;2643   
                          ENDP


                          AREA ||i.TIM_GetPrescaler||, CODE, READONLY, ALIGN=1

                  TIM_GetPrescaler PROC
;;;2511     */
;;;2512   uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
000000  8d00              LDRH     r0,[r0,#0x28]
;;;2513   {
;;;2514     /* Check the parameters */
;;;2515     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2516     /* Get the Prescaler Register value */
;;;2517     return TIMx->PSC;
;;;2518   }
000002  4770              BX       lr
;;;2519   
                          ENDP


                          AREA ||i.TIM_ICInit||, CODE, READONLY, ALIGN=1

                  TIM_ICInit PROC
;;;584      */
;;;585    void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  b470              PUSH     {r4-r6}
;;;586    {
;;;587      /* Check the parameters */
;;;588      assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct->TIM_Channel));
;;;589      assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
;;;590      assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
;;;591      assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
;;;592      assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
;;;593      
;;;594      if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000002  880d              LDRH     r5,[r1,#0]
;;;595      {
;;;596        assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;597        /* TI1 Configuration */
;;;598        TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000004  884c              LDRH     r4,[r1,#2]
000006  f8b1c004          LDRH     r12,[r1,#4]
00000a  890b              LDRH     r3,[r1,#8]
00000c  f64f72ff          MOV      r2,#0xffff
000010  b355              CBZ      r5,|L36.104|
;;;599                   TIM_ICInitStruct->TIM_ICSelection,
;;;600                   TIM_ICInitStruct->TIM_ICFilter);
;;;601        /* Set the Input Capture Prescaler value */
;;;602        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;603      }
;;;604      else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
000012  2d04              CMP      r5,#4
000014  d044              BEQ      |L36.160|
;;;605      {
;;;606        assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;607        /* TI2 Configuration */
;;;608        TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
;;;609                   TIM_ICInitStruct->TIM_ICSelection,
;;;610                   TIM_ICInitStruct->TIM_ICFilter);
;;;611        /* Set the Input Capture Prescaler value */
;;;612        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;613      }
;;;614      else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
000016  2d08              CMP      r5,#8
000018  8c05              LDRH     r5,[r0,#0x20]
00001a  d067              BEQ      |L36.236|
00001c  f4255580          BIC      r5,r5,#0x1000
000020  8405              STRH     r5,[r0,#0x20]
000022  8b86              LDRH     r6,[r0,#0x1c]
000024  8c05              LDRH     r5,[r0,#0x20]
000026  f4264673          BIC      r6,r6,#0xf300
00002a  ea022c0c          AND      r12,r2,r12,LSL #8
00002e  ea4c0c06          ORR      r12,r12,r6
000032  ea023303          AND      r3,r2,r3,LSL #12
000036  ea43030c          ORR      r3,r3,r12
00003a  ea023404          AND      r4,r2,r4,LSL #12
00003e  f4255c00          BIC      r12,r5,#0x2000
000042  ea4c0c04          ORR      r12,r12,r4
000046  f44c5c80          ORR      r12,r12,#0x1000
00004a  8383              STRH     r3,[r0,#0x1c]
00004c  f8a0c020          STRH     r12,[r0,#0x20]
;;;615      {
;;;616        assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;617        /* TI3 Configuration */
;;;618        TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
;;;619                   TIM_ICInitStruct->TIM_ICSelection,
;;;620                   TIM_ICInitStruct->TIM_ICFilter);
;;;621        /* Set the Input Capture Prescaler value */
;;;622        TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;623      }
;;;624      else
;;;625      {
;;;626        assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;627        /* TI4 Configuration */
;;;628        TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
;;;629                   TIM_ICInitStruct->TIM_ICSelection,
;;;630                   TIM_ICInitStruct->TIM_ICFilter);
;;;631        /* Set the Input Capture Prescaler value */
;;;632        TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000050  7989              LDRB     r1,[r1,#6]
000052  8b83              LDRH     r3,[r0,#0x1c]
000054  f4236340          BIC      r3,r3,#0xc00
000058  8383              STRH     r3,[r0,#0x1c]
00005a  8b83              LDRH     r3,[r0,#0x1c]
00005c  ea022101          AND      r1,r2,r1,LSL #8
000060  4319              ORRS     r1,r1,r3
                  |L36.98|
000062  8381              STRH     r1,[r0,#0x1c]
;;;633      }
;;;634    }
000064  bc70              POP      {r4-r6}
000066  4770              BX       lr
                  |L36.104|
000068  8c05              LDRH     r5,[r0,#0x20]
00006a  f0250501          BIC      r5,r5,#1
00006e  8405              STRH     r5,[r0,#0x20]
000070  8b06              LDRH     r6,[r0,#0x18]
000072  8c05              LDRH     r5,[r0,#0x20]
000074  ea021203          AND      r2,r2,r3,LSL #4
000078  f02606f3          BIC      r6,r6,#0xf3
00007c  ea42020c          ORR      r2,r2,r12
000080  4332              ORRS     r2,r2,r6
000082  f0250302          BIC      r3,r5,#2
000086  4323              ORRS     r3,r3,r4
000088  f0430301          ORR      r3,r3,#1
00008c  8302              STRH     r2,[r0,#0x18]
00008e  8403              STRH     r3,[r0,#0x20]
000090  88c9              LDRH     r1,[r1,#6]            ;602
000092  8b02              LDRH     r2,[r0,#0x18]         ;602
000094  f022020c          BIC      r2,r2,#0xc            ;602
000098  8302              STRH     r2,[r0,#0x18]         ;602
00009a  8b02              LDRH     r2,[r0,#0x18]         ;602
00009c  4311              ORRS     r1,r1,r2              ;602
00009e  e022              B        |L36.230|
                  |L36.160|
0000a0  8c05              LDRH     r5,[r0,#0x20]         ;602
0000a2  f0250510          BIC      r5,r5,#0x10           ;602
0000a6  8405              STRH     r5,[r0,#0x20]         ;602
0000a8  8b06              LDRH     r6,[r0,#0x18]         ;602
0000aa  8c05              LDRH     r5,[r0,#0x20]         ;602
0000ac  f4264673          BIC      r6,r6,#0xf300         ;602
0000b0  ea023303          AND      r3,r2,r3,LSL #12      ;602
0000b4  4333              ORRS     r3,r3,r6              ;602
0000b6  ea022c0c          AND      r12,r2,r12,LSL #8     ;602
0000ba  ea4c0303          ORR      r3,r12,r3             ;602
0000be  ea021404          AND      r4,r2,r4,LSL #4       ;602
0000c2  f0250c20          BIC      r12,r5,#0x20          ;602
0000c6  ea4c0c04          ORR      r12,r12,r4            ;602
0000ca  f04c0c10          ORR      r12,r12,#0x10         ;602
0000ce  8303              STRH     r3,[r0,#0x18]         ;602
0000d0  f8a0c020          STRH     r12,[r0,#0x20]        ;602
0000d4  7989              LDRB     r1,[r1,#6]            ;612
0000d6  8b03              LDRH     r3,[r0,#0x18]         ;612
0000d8  f4236340          BIC      r3,r3,#0xc00          ;612
0000dc  8303              STRH     r3,[r0,#0x18]         ;612
0000de  8b03              LDRH     r3,[r0,#0x18]         ;612
0000e0  ea022101          AND      r1,r2,r1,LSL #8       ;612
0000e4  4319              ORRS     r1,r1,r3              ;612
                  |L36.230|
0000e6  8301              STRH     r1,[r0,#0x18]         ;612
0000e8  bc70              POP      {r4-r6}
0000ea  4770              BX       lr
                  |L36.236|
0000ec  f4257580          BIC      r5,r5,#0x100
0000f0  8405              STRH     r5,[r0,#0x20]
0000f2  8b86              LDRH     r6,[r0,#0x1c]
0000f4  8c05              LDRH     r5,[r0,#0x20]
0000f6  ea022404          AND      r4,r2,r4,LSL #8
0000fa  ea021203          AND      r2,r2,r3,LSL #4
0000fe  f02606f3          BIC      r6,r6,#0xf3
000102  ea42020c          ORR      r2,r2,r12
000106  4332              ORRS     r2,r2,r6
000108  f4257300          BIC      r3,r5,#0x200
00010c  4323              ORRS     r3,r3,r4
00010e  f4437380          ORR      r3,r3,#0x100
000112  8382              STRH     r2,[r0,#0x1c]
000114  8403              STRH     r3,[r0,#0x20]
000116  88c9              LDRH     r1,[r1,#6]            ;622
000118  8b82              LDRH     r2,[r0,#0x1c]         ;622
00011a  f022020c          BIC      r2,r2,#0xc            ;622
00011e  8382              STRH     r2,[r0,#0x1c]         ;622
000120  8b82              LDRH     r2,[r0,#0x1c]         ;622
000122  4311              ORRS     r1,r1,r2              ;622
000124  e79d              B        |L36.98|
;;;635    
                          ENDP


                          AREA ||i.TIM_ICStructInit||, CODE, READONLY, ALIGN=1

                  TIM_ICStructInit PROC
;;;760      */
;;;761    void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  2100              MOVS     r1,#0
;;;762    {
;;;763      /* Set the default configuration */
;;;764      TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
000002  8001              STRH     r1,[r0,#0]
;;;765      TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
000004  8041              STRH     r1,[r0,#2]
;;;766      TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
000006  2201              MOVS     r2,#1
000008  8082              STRH     r2,[r0,#4]
;;;767      TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
00000a  80c1              STRH     r1,[r0,#6]
;;;768      TIM_ICInitStruct->TIM_ICFilter = 0x00;
00000c  8101              STRH     r1,[r0,#8]
;;;769    }
00000e  4770              BX       lr
;;;770    
                          ENDP


                          AREA ||i.TIM_ITConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITConfig PROC
;;;861      */
;;;862    void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;863    {  
;;;864      /* Check the parameters */
;;;865      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;866      assert_param(IS_TIM_IT(TIM_IT));
;;;867      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;868      
;;;869      if (NewState != DISABLE)
;;;870      {
;;;871        /* Enable the Interrupt sources */
;;;872        TIMx->DIER |= TIM_IT;
;;;873      }
;;;874      else
;;;875      {
;;;876        /* Disable the Interrupt sources */
;;;877        TIMx->DIER &= (uint16_t)~TIM_IT;
000002  8982              LDRH     r2,[r0,#0xc]
000004  bf14              ITE      NE                    ;872
000006  4311              ORRNE    r1,r1,r2              ;872
000008  ea220101          BICEQ    r1,r2,r1
00000c  8181              STRH     r1,[r0,#0xc]          ;872
;;;878      }
;;;879    }
00000e  4770              BX       lr
;;;880    
                          ENDP


                          AREA ||i.TIM_ITRxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITRxExternalClockConfig PROC
;;;997      */
;;;998    void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000000  8902              LDRH     r2,[r0,#8]
000002  f0220270          BIC      r2,r2,#0x70
000006  4311              ORRS     r1,r1,r2
000008  8101              STRH     r1,[r0,#8]
;;;999    {
;;;1000     /* Check the parameters */
;;;1001     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1002     assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;1003     /* Select the Internal Trigger */
;;;1004     TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
;;;1005     /* Select the External clock mode1 */
;;;1006     TIMx->SMCR |= TIM_SlaveMode_External1;
00000a  8901              LDRH     r1,[r0,#8]
00000c  f0410107          ORR      r1,r1,#7
000010  8101              STRH     r1,[r0,#8]
;;;1007   }
000012  4770              BX       lr
;;;1008   
                          ENDP


                          AREA ||i.TIM_InternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_InternalClockConfig PROC
;;;978      */
;;;979    void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
000000  8901              LDRH     r1,[r0,#8]
;;;980    {
;;;981      /* Check the parameters */
;;;982      assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;983      /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;984      TIMx->SMCR &=  (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
000002  f0210107          BIC      r1,r1,#7
000006  8101              STRH     r1,[r0,#8]
;;;985    }
000008  4770              BX       lr
;;;986    
                          ENDP


                          AREA ||i.TIM_OC1FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1FastConfig PROC
;;;1595     */
;;;1596   void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1597   {
;;;1598     uint16_t tmpccmr1 = 0;
;;;1599     /* Check the parameters */
;;;1600     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;1601     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1602     /* Get the TIMx CCMR1 register value */
;;;1603     tmpccmr1 = TIMx->CCMR1;
;;;1604     /* Reset the OC1FE Bit */
;;;1605     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1FE);
000002  f0220204          BIC      r2,r2,#4
;;;1606     /* Enable or Disable the Output Compare Fast Bit */
;;;1607     tmpccmr1 |= TIM_OCFast;
000006  4311              ORRS     r1,r1,r2
;;;1608     /* Write to TIMx CCMR1 */
;;;1609     TIMx->CCMR1 = tmpccmr1;
000008  8301              STRH     r1,[r0,#0x18]
;;;1610   }
00000a  4770              BX       lr
;;;1611   
                          ENDP


                          AREA ||i.TIM_OC1Init||, CODE, READONLY, ALIGN=1

                  TIM_OC1Init PROC
;;;276      */
;;;277    void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b410              PUSH     {r4}
;;;278    {
;;;279      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;280       
;;;281      /* Check the parameters */
;;;282      assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;283      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;284      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;285      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;286     /* Disable the Channel 1: Reset the CC1E Bit */
;;;287      TIMx->CCER &= (uint16_t)(~(uint16_t)TIM_CCER_CC1E);
000002  8c02              LDRH     r2,[r0,#0x20]
000004  f0220201          BIC      r2,r2,#1
000008  8402              STRH     r2,[r0,#0x20]
;;;288      /* Get the TIMx CCER register value */
;;;289      tmpccer = TIMx->CCER;
00000a  8c02              LDRH     r2,[r0,#0x20]
;;;290      /* Get the TIMx CR2 register value */
;;;291      tmpcr2 =  TIMx->CR2;
00000c  8883              LDRH     r3,[r0,#4]
;;;292      
;;;293      /* Get the TIMx CCMR1 register value */
;;;294      tmpccmrx = TIMx->CCMR1;
00000e  f8b0c018          LDRH     r12,[r0,#0x18]
;;;295        
;;;296      /* Reset the Output Compare Mode Bits */
;;;297      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC1M));
;;;298      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC1S));
;;;299    
;;;300      /* Select the Output Compare Mode */
;;;301      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
000012  880c              LDRH     r4,[r1,#0]
000014  f02c0c73          BIC      r12,r12,#0x73         ;298
000018  ea440c0c          ORR      r12,r4,r12
;;;302      
;;;303      /* Reset the Output Polarity level */
;;;304      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1P));
;;;305      /* Set the Output Compare Polarity */
;;;306      tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
00001c  890c              LDRH     r4,[r1,#8]
00001e  f0220202          BIC      r2,r2,#2              ;304
000022  4322              ORRS     r2,r2,r4
;;;307      
;;;308      /* Set the Output State */
;;;309      tmpccer |= TIM_OCInitStruct->TIM_OutputState;
000024  884c              LDRH     r4,[r1,#2]
000026  4322              ORRS     r2,r2,r4
;;;310        
;;;311      if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15)||
000028  f1a04480          SUB      r4,r0,#0x40000000
00002c  f5b43496          SUBS     r4,r4,#0x12c00
000030  bf1c              ITT      NE
000032  f1a04480          SUBNE    r4,r0,#0x40000000
000036  f5b4349a          SUBSNE   r4,r4,#0x13400
00003a  d00d              BEQ      |L42.88|
00003c  f1a04480          SUB      r4,r0,#0x40000000
000040  f5b434a0          SUBS     r4,r4,#0x14000
;;;312         (TIMx == TIM16)|| (TIMx == TIM17))
000044  bf1f              ITTTT    NE
000046  f1a04480          SUBNE    r4,r0,#0x40000000
00004a  f5b434a2          SUBSNE   r4,r4,#0x14400
00004e  f1a04480          SUBNE    r4,r0,#0x40000000
000052  f5b434a4          SUBSNE   r4,r4,#0x14800
000056  d10d              BNE      |L42.116|
                  |L42.88|
;;;313      {
;;;314        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;315        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;316        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;317        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;318        
;;;319        /* Reset the Output N Polarity level */
;;;320        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NP));
;;;321        /* Set the Output N Polarity */
;;;322        tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
000058  894c              LDRH     r4,[r1,#0xa]
00005a  f0220208          BIC      r2,r2,#8              ;320
00005e  4322              ORRS     r2,r2,r4
;;;323        
;;;324        /* Reset the Output N State */
;;;325        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NE));    
;;;326        /* Set the Output N State */
;;;327        tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
000060  888c              LDRH     r4,[r1,#4]
000062  f0220204          BIC      r2,r2,#4              ;325
000066  4322              ORRS     r2,r2,r4
;;;328        
;;;329        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;330        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1));
;;;331        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1N));
;;;332        
;;;333        /* Set the Output Idle state */
;;;334        tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
000068  898c              LDRH     r4,[r1,#0xc]
00006a  f4237340          BIC      r3,r3,#0x300          ;331
00006e  4323              ORRS     r3,r3,r4
;;;335        /* Set the Output N Idle state */
;;;336        tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
000070  89cc              LDRH     r4,[r1,#0xe]
000072  4323              ORRS     r3,r3,r4
                  |L42.116|
;;;337      }
;;;338      /* Write to TIMx CR2 */
;;;339      TIMx->CR2 = tmpcr2;
000074  8083              STRH     r3,[r0,#4]
;;;340      
;;;341      /* Write to TIMx CCMR1 */
;;;342      TIMx->CCMR1 = tmpccmrx;
000076  f8a0c018          STRH     r12,[r0,#0x18]
;;;343    
;;;344      /* Set the Capture Compare Register value */
;;;345      TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse; 
00007a  88c9              LDRH     r1,[r1,#6]
00007c  8681              STRH     r1,[r0,#0x34]
;;;346     
;;;347      /* Write to TIMx CCER */
;;;348      TIMx->CCER = tmpccer;
00007e  8402              STRH     r2,[r0,#0x20]
;;;349    }
000080  bc10              POP      {r4}
000082  4770              BX       lr
;;;350    
                          ENDP


                          AREA ||i.TIM_OC1NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1NPolarityConfig PROC
;;;1817     */
;;;1818   void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1819   {
;;;1820     uint16_t tmpccer = 0;
;;;1821     /* Check the parameters */
;;;1822     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1823     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1824      
;;;1825     tmpccer = TIMx->CCER;
;;;1826     /* Set or Reset the CC1NP Bit */
;;;1827     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1NP);
000002  f0220208          BIC      r2,r2,#8
;;;1828     tmpccer |= TIM_OCNPolarity;
000006  4311              ORRS     r1,r1,r2
;;;1829     /* Write to TIMx CCER register */
;;;1830     TIMx->CCER = tmpccer;
000008  8401              STRH     r1,[r0,#0x20]
;;;1831   }
00000a  4770              BX       lr
;;;1832   
                          ENDP


                          AREA ||i.TIM_OC1PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PolarityConfig PROC
;;;1794     */
;;;1795   void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1796   {
;;;1797     uint16_t tmpccer = 0;
;;;1798     /* Check the parameters */
;;;1799     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;1800     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1801     tmpccer = TIMx->CCER;
;;;1802     /* Set or Reset the CC1P Bit */
;;;1803     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1P);
000002  f0220202          BIC      r2,r2,#2
;;;1804     tmpccer |= TIM_OCPolarity;
000006  4311              ORRS     r1,r1,r2
;;;1805     /* Write to TIMx CCER register */
;;;1806     TIMx->CCER = tmpccer;
000008  8401              STRH     r1,[r0,#0x20]
;;;1807   }
00000a  4770              BX       lr
;;;1808   
                          ENDP


                          AREA ||i.TIM_OC1PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PreloadConfig PROC
;;;1498     */
;;;1499   void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1500   {
;;;1501     uint16_t tmpccmr1 = 0;
;;;1502     /* Check the parameters */
;;;1503     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;1504     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1505     tmpccmr1 = TIMx->CCMR1;
;;;1506     /* Reset the OC1PE Bit */
;;;1507     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1PE);
000002  f0220208          BIC      r2,r2,#8
;;;1508     /* Enable or Disable the Output Compare Preload feature */
;;;1509     tmpccmr1 |= TIM_OCPreload;
000006  4311              ORRS     r1,r1,r2
;;;1510     /* Write to TIMx CCMR1 register */
;;;1511     TIMx->CCMR1 = tmpccmr1;
000008  8301              STRH     r1,[r0,#0x18]
;;;1512   }
00000a  4770              BX       lr
;;;1513   
                          ENDP


                          AREA ||i.TIM_OC2FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2FastConfig PROC
;;;1621     */
;;;1622   void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1623   {
;;;1624     uint16_t tmpccmr1 = 0;
;;;1625     /* Check the parameters */
;;;1626     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1627     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1628     /* Get the TIMx CCMR1 register value */
;;;1629     tmpccmr1 = TIMx->CCMR1;
;;;1630     /* Reset the OC2FE Bit */
;;;1631     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2FE);
;;;1632     /* Enable or Disable the Output Compare Fast Bit */
;;;1633     tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f4226280          BIC      r2,r2,#0x400          ;1631
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1634     /* Write to TIMx CCMR1 */
;;;1635     TIMx->CCMR1 = tmpccmr1;
000010  8301              STRH     r1,[r0,#0x18]
;;;1636   }
000012  4770              BX       lr
;;;1637   
                          ENDP


                          AREA ||i.TIM_OC2Init||, CODE, READONLY, ALIGN=1

                  TIM_OC2Init PROC
;;;359      */
;;;360    void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b430              PUSH     {r4,r5}
;;;361    {
;;;362      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;363       
;;;364      /* Check the parameters */
;;;365      assert_param(IS_TIM_LIST6_PERIPH(TIMx)); 
;;;366      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;367      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;368      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;369       /* Disable the Channel 2: Reset the CC2E Bit */
;;;370      TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC2E));
000002  8c02              LDRH     r2,[r0,#0x20]
000004  f0220210          BIC      r2,r2,#0x10
000008  8402              STRH     r2,[r0,#0x20]
;;;371      
;;;372      /* Get the TIMx CCER register value */  
;;;373      tmpccer = TIMx->CCER;
00000a  8c03              LDRH     r3,[r0,#0x20]
;;;374      /* Get the TIMx CR2 register value */
;;;375      tmpcr2 =  TIMx->CR2;
00000c  f8b0c004          LDRH     r12,[r0,#4]
;;;376      
;;;377      /* Get the TIMx CCMR1 register value */
;;;378      tmpccmrx = TIMx->CCMR1;
000010  8b02              LDRH     r2,[r0,#0x18]
;;;379        
;;;380      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;381      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC2M));
;;;382      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S));
;;;383      
;;;384      /* Select the Output Compare Mode */
;;;385      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
000012  880d              LDRH     r5,[r1,#0]
000014  f42244e6          BIC      r4,r2,#0x7300         ;382
000018  f64f72ff          MOV      r2,#0xffff
00001c  ea022505          AND      r5,r2,r5,LSL #8
000020  432c              ORRS     r4,r4,r5
;;;386      
;;;387      /* Reset the Output Polarity level */
;;;388      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2P));
;;;389      /* Set the Output Compare Polarity */
;;;390      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
000022  890d              LDRH     r5,[r1,#8]
000024  f0230320          BIC      r3,r3,#0x20           ;388
000028  ea021505          AND      r5,r2,r5,LSL #4
00002c  432b              ORRS     r3,r3,r5
;;;391      
;;;392      /* Set the Output State */
;;;393      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
00002e  884d              LDRH     r5,[r1,#2]
000030  ea021505          AND      r5,r2,r5,LSL #4
000034  432b              ORRS     r3,r3,r5
;;;394        
;;;395      if((TIMx == TIM1) || (TIMx == TIM8))
000036  f1a04580          SUB      r5,r0,#0x40000000
00003a  f5b53596          SUBS     r5,r5,#0x12c00
00003e  bf1c              ITT      NE
000040  f1a04580          SUBNE    r5,r0,#0x40000000
000044  f5b5359a          SUBSNE   r5,r5,#0x13400
000048  d117              BNE      |L47.122|
;;;396      {
;;;397        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;398        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;399        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;400        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;401        
;;;402        /* Reset the Output N Polarity level */
;;;403        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NP));
;;;404        /* Set the Output N Polarity */
;;;405        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
00004a  894d              LDRH     r5,[r1,#0xa]
00004c  f0230380          BIC      r3,r3,#0x80           ;403
000050  ea021505          AND      r5,r2,r5,LSL #4
000054  432b              ORRS     r3,r3,r5
;;;406        
;;;407        /* Reset the Output N State */
;;;408        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NE));    
;;;409        /* Set the Output N State */
;;;410        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
000056  888d              LDRH     r5,[r1,#4]
000058  f0230340          BIC      r3,r3,#0x40           ;408
00005c  ea021505          AND      r5,r2,r5,LSL #4
000060  432b              ORRS     r3,r3,r5
;;;411        
;;;412        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;413        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2));
;;;414        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2N));
;;;415        
;;;416        /* Set the Output Idle state */
;;;417        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
000062  898d              LDRH     r5,[r1,#0xc]
000064  f42c6c40          BIC      r12,r12,#0xc00        ;414
000068  ea020585          AND      r5,r2,r5,LSL #2
00006c  ea450c0c          ORR      r12,r5,r12
;;;418        /* Set the Output N Idle state */
;;;419        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
000070  89cd              LDRH     r5,[r1,#0xe]
000072  ea020285          AND      r2,r2,r5,LSL #2
000076  ea420c0c          ORR      r12,r2,r12
                  |L47.122|
;;;420      }
;;;421      /* Write to TIMx CR2 */
;;;422      TIMx->CR2 = tmpcr2;
00007a  f8a0c004          STRH     r12,[r0,#4]
;;;423      
;;;424      /* Write to TIMx CCMR1 */
;;;425      TIMx->CCMR1 = tmpccmrx;
00007e  8304              STRH     r4,[r0,#0x18]
;;;426    
;;;427      /* Set the Capture Compare Register value */
;;;428      TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
000080  88c9              LDRH     r1,[r1,#6]
000082  8701              STRH     r1,[r0,#0x38]
;;;429      
;;;430      /* Write to TIMx CCER */
;;;431      TIMx->CCER = tmpccer;
000084  8403              STRH     r3,[r0,#0x20]
;;;432    }
000086  bc30              POP      {r4,r5}
000088  4770              BX       lr
;;;433    
                          ENDP


                          AREA ||i.TIM_OC2NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2NPolarityConfig PROC
;;;1864     */
;;;1865   void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1866   {
;;;1867     uint16_t tmpccer = 0;
;;;1868     /* Check the parameters */
;;;1869     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1870     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1871     
;;;1872     tmpccer = TIMx->CCER;
;;;1873     /* Set or Reset the CC2NP Bit */
;;;1874     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2NP);
;;;1875     tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
000002  f64f73ff          MOV      r3,#0xffff
000006  f0220280          BIC      r2,r2,#0x80           ;1874
00000a  ea031101          AND      r1,r3,r1,LSL #4
00000e  4311              ORRS     r1,r1,r2
;;;1876     /* Write to TIMx CCER register */
;;;1877     TIMx->CCER = tmpccer;
000010  8401              STRH     r1,[r0,#0x20]
;;;1878   }
000012  4770              BX       lr
;;;1879   
                          ENDP


                          AREA ||i.TIM_OC2PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PolarityConfig PROC
;;;1841     */
;;;1842   void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1843   {
;;;1844     uint16_t tmpccer = 0;
;;;1845     /* Check the parameters */
;;;1846     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1847     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1848     tmpccer = TIMx->CCER;
;;;1849     /* Set or Reset the CC2P Bit */
;;;1850     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2P);
;;;1851     tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
000002  f64f73ff          MOV      r3,#0xffff
000006  f0220220          BIC      r2,r2,#0x20           ;1850
00000a  ea031101          AND      r1,r3,r1,LSL #4
00000e  4311              ORRS     r1,r1,r2
;;;1852     /* Write to TIMx CCER register */
;;;1853     TIMx->CCER = tmpccer;
000010  8401              STRH     r1,[r0,#0x20]
;;;1854   }
000012  4770              BX       lr
;;;1855   
                          ENDP


                          AREA ||i.TIM_OC2PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PreloadConfig PROC
;;;1523     */
;;;1524   void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1525   {
;;;1526     uint16_t tmpccmr1 = 0;
;;;1527     /* Check the parameters */
;;;1528     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1529     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1530     tmpccmr1 = TIMx->CCMR1;
;;;1531     /* Reset the OC2PE Bit */
;;;1532     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2PE);
;;;1533     /* Enable or Disable the Output Compare Preload feature */
;;;1534     tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f4226200          BIC      r2,r2,#0x800          ;1532
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1535     /* Write to TIMx CCMR1 register */
;;;1536     TIMx->CCMR1 = tmpccmr1;
000010  8301              STRH     r1,[r0,#0x18]
;;;1537   }
000012  4770              BX       lr
;;;1538   
                          ENDP


                          AREA ||i.TIM_OC3FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3FastConfig PROC
;;;1646     */
;;;1647   void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1648   {
;;;1649     uint16_t tmpccmr2 = 0;
;;;1650     /* Check the parameters */
;;;1651     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1652     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1653     /* Get the TIMx CCMR2 register value */
;;;1654     tmpccmr2 = TIMx->CCMR2;
;;;1655     /* Reset the OC3FE Bit */
;;;1656     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3FE);
000002  f0220204          BIC      r2,r2,#4
;;;1657     /* Enable or Disable the Output Compare Fast Bit */
;;;1658     tmpccmr2 |= TIM_OCFast;
000006  4311              ORRS     r1,r1,r2
;;;1659     /* Write to TIMx CCMR2 */
;;;1660     TIMx->CCMR2 = tmpccmr2;
000008  8381              STRH     r1,[r0,#0x1c]
;;;1661   }
00000a  4770              BX       lr
;;;1662   
                          ENDP


                          AREA ||i.TIM_OC3Init||, CODE, READONLY, ALIGN=1

                  TIM_OC3Init PROC
;;;441      */
;;;442    void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b430              PUSH     {r4,r5}
;;;443    {
;;;444      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;445       
;;;446      /* Check the parameters */
;;;447      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;448      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;449      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;450      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;451      /* Disable the Channel 2: Reset the CC2E Bit */
;;;452      TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC3E));
000002  8c02              LDRH     r2,[r0,#0x20]
000004  f4227280          BIC      r2,r2,#0x100
000008  8402              STRH     r2,[r0,#0x20]
;;;453      
;;;454      /* Get the TIMx CCER register value */
;;;455      tmpccer = TIMx->CCER;
00000a  8c02              LDRH     r2,[r0,#0x20]
;;;456      /* Get the TIMx CR2 register value */
;;;457      tmpcr2 =  TIMx->CR2;
00000c  8883              LDRH     r3,[r0,#4]
;;;458      
;;;459      /* Get the TIMx CCMR2 register value */
;;;460      tmpccmrx = TIMx->CCMR2;
00000e  f8b0c01c          LDRH     r12,[r0,#0x1c]
;;;461        
;;;462      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;463      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC3M));
;;;464      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC3S));  
;;;465      /* Select the Output Compare Mode */
;;;466      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
000012  880c              LDRH     r4,[r1,#0]
000014  f02c0c73          BIC      r12,r12,#0x73         ;464
000018  ea44040c          ORR      r4,r4,r12
;;;467      
;;;468      /* Reset the Output Polarity level */
;;;469      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3P));
00001c  f4227c00          BIC      r12,r2,#0x200
;;;470      /* Set the Output Compare Polarity */
;;;471      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
000020  890d              LDRH     r5,[r1,#8]
000022  f64f72ff          MOV      r2,#0xffff
000026  ea022505          AND      r5,r2,r5,LSL #8
00002a  ea450c0c          ORR      r12,r5,r12
;;;472      
;;;473      /* Set the Output State */
;;;474      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
00002e  884d              LDRH     r5,[r1,#2]
000030  ea022505          AND      r5,r2,r5,LSL #8
000034  ea450c0c          ORR      r12,r5,r12
;;;475        
;;;476      if((TIMx == TIM1) || (TIMx == TIM8))
000038  f1a04580          SUB      r5,r0,#0x40000000
00003c  f5b53596          SUBS     r5,r5,#0x12c00
000040  bf1c              ITT      NE
000042  f1a04580          SUBNE    r5,r0,#0x40000000
000046  f5b5359a          SUBSNE   r5,r5,#0x13400
00004a  d117              BNE      |L52.124|
;;;477      {
;;;478        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;479        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;480        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;481        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;482        
;;;483        /* Reset the Output N Polarity level */
;;;484        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NP));
;;;485        /* Set the Output N Polarity */
;;;486        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
00004c  894d              LDRH     r5,[r1,#0xa]
00004e  f42c6c00          BIC      r12,r12,#0x800        ;484
000052  ea022505          AND      r5,r2,r5,LSL #8
000056  ea450c0c          ORR      r12,r5,r12
;;;487        /* Reset the Output N State */
;;;488        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NE));
;;;489        
;;;490        /* Set the Output N State */
;;;491        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
00005a  888d              LDRH     r5,[r1,#4]
00005c  f42c6c80          BIC      r12,r12,#0x400        ;488
000060  ea022505          AND      r5,r2,r5,LSL #8
000064  ea450c0c          ORR      r12,r5,r12
;;;492        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;493        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3));
;;;494        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3N));
;;;495        /* Set the Output Idle state */
;;;496        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
000068  898d              LDRH     r5,[r1,#0xc]
00006a  f4235340          BIC      r3,r3,#0x3000         ;494
00006e  ea021505          AND      r5,r2,r5,LSL #4
000072  432b              ORRS     r3,r3,r5
;;;497        /* Set the Output N Idle state */
;;;498        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
000074  89cd              LDRH     r5,[r1,#0xe]
000076  ea021205          AND      r2,r2,r5,LSL #4
00007a  4313              ORRS     r3,r3,r2
                  |L52.124|
;;;499      }
;;;500      /* Write to TIMx CR2 */
;;;501      TIMx->CR2 = tmpcr2;
00007c  8083              STRH     r3,[r0,#4]
;;;502      
;;;503      /* Write to TIMx CCMR2 */
;;;504      TIMx->CCMR2 = tmpccmrx;
00007e  8384              STRH     r4,[r0,#0x1c]
;;;505    
;;;506      /* Set the Capture Compare Register value */
;;;507      TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
000080  88c9              LDRH     r1,[r1,#6]
000082  8781              STRH     r1,[r0,#0x3c]
;;;508      
;;;509      /* Write to TIMx CCER */
;;;510      TIMx->CCER = tmpccer;
000084  f8a0c020          STRH     r12,[r0,#0x20]
;;;511    }
000088  bc30              POP      {r4,r5}
00008a  4770              BX       lr
;;;512    
                          ENDP


                          AREA ||i.TIM_OC3NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3NPolarityConfig PROC
;;;1911     */
;;;1912   void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1913   {
;;;1914     uint16_t tmpccer = 0;
;;;1915    
;;;1916     /* Check the parameters */
;;;1917     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1918     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1919       
;;;1920     tmpccer = TIMx->CCER;
;;;1921     /* Set or Reset the CC3NP Bit */
;;;1922     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3NP);
;;;1923     tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f4226200          BIC      r2,r2,#0x800          ;1922
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1924     /* Write to TIMx CCER register */
;;;1925     TIMx->CCER = tmpccer;
000010  8401              STRH     r1,[r0,#0x20]
;;;1926   }
000012  4770              BX       lr
;;;1927   
                          ENDP


                          AREA ||i.TIM_OC3PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PolarityConfig PROC
;;;1888     */
;;;1889   void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1890   {
;;;1891     uint16_t tmpccer = 0;
;;;1892     /* Check the parameters */
;;;1893     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1894     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1895     tmpccer = TIMx->CCER;
;;;1896     /* Set or Reset the CC3P Bit */
;;;1897     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3P);
;;;1898     tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f4227200          BIC      r2,r2,#0x200          ;1897
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1899     /* Write to TIMx CCER register */
;;;1900     TIMx->CCER = tmpccer;
000010  8401              STRH     r1,[r0,#0x20]
;;;1901   }
000012  4770              BX       lr
;;;1902   
                          ENDP


                          AREA ||i.TIM_OC3PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PreloadConfig PROC
;;;1547     */
;;;1548   void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1549   {
;;;1550     uint16_t tmpccmr2 = 0;
;;;1551     /* Check the parameters */
;;;1552     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1553     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1554     tmpccmr2 = TIMx->CCMR2;
;;;1555     /* Reset the OC3PE Bit */
;;;1556     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3PE);
000002  f0220208          BIC      r2,r2,#8
;;;1557     /* Enable or Disable the Output Compare Preload feature */
;;;1558     tmpccmr2 |= TIM_OCPreload;
000006  4311              ORRS     r1,r1,r2
;;;1559     /* Write to TIMx CCMR2 register */
;;;1560     TIMx->CCMR2 = tmpccmr2;
000008  8381              STRH     r1,[r0,#0x1c]
;;;1561   }
00000a  4770              BX       lr
;;;1562   
                          ENDP


                          AREA ||i.TIM_OC4FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4FastConfig PROC
;;;1671     */
;;;1672   void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1673   {
;;;1674     uint16_t tmpccmr2 = 0;
;;;1675     /* Check the parameters */
;;;1676     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1677     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1678     /* Get the TIMx CCMR2 register value */
;;;1679     tmpccmr2 = TIMx->CCMR2;
;;;1680     /* Reset the OC4FE Bit */
;;;1681     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4FE);
;;;1682     /* Enable or Disable the Output Compare Fast Bit */
;;;1683     tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f4226280          BIC      r2,r2,#0x400          ;1681
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1684     /* Write to TIMx CCMR2 */
;;;1685     TIMx->CCMR2 = tmpccmr2;
000010  8381              STRH     r1,[r0,#0x1c]
;;;1686   }
000012  4770              BX       lr
;;;1687   
                          ENDP


                          AREA ||i.TIM_OC4Init||, CODE, READONLY, ALIGN=1

                  TIM_OC4Init PROC
;;;520      */
;;;521    void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b430              PUSH     {r4,r5}
;;;522    {
;;;523      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;524       
;;;525      /* Check the parameters */
;;;526      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;527      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;528      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;529      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;530      /* Disable the Channel 2: Reset the CC4E Bit */
;;;531      TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC4E));
000002  8c02              LDRH     r2,[r0,#0x20]
000004  f4225280          BIC      r2,r2,#0x1000
000008  8402              STRH     r2,[r0,#0x20]
;;;532      
;;;533      /* Get the TIMx CCER register value */
;;;534      tmpccer = TIMx->CCER;
00000a  8c04              LDRH     r4,[r0,#0x20]
;;;535      /* Get the TIMx CR2 register value */
;;;536      tmpcr2 =  TIMx->CR2;
00000c  8882              LDRH     r2,[r0,#4]
;;;537      
;;;538      /* Get the TIMx CCMR2 register value */
;;;539      tmpccmrx = TIMx->CCMR2;
00000e  8b83              LDRH     r3,[r0,#0x1c]
;;;540        
;;;541      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;542      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC4M));
;;;543      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC4S));
;;;544      
;;;545      /* Select the Output Compare Mode */
;;;546      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
000010  880d              LDRH     r5,[r1,#0]
000012  f4234ce6          BIC      r12,r3,#0x7300        ;543
000016  f64f73ff          MOV      r3,#0xffff
00001a  ea032505          AND      r5,r3,r5,LSL #8
00001e  ea450c0c          ORR      r12,r5,r12
;;;547      
;;;548      /* Reset the Output Polarity level */
;;;549      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC4P));
;;;550      /* Set the Output Compare Polarity */
;;;551      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
000022  890d              LDRH     r5,[r1,#8]
000024  f4245400          BIC      r4,r4,#0x2000         ;549
000028  ea033505          AND      r5,r3,r5,LSL #12
00002c  432c              ORRS     r4,r4,r5
;;;552      
;;;553      /* Set the Output State */
;;;554      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
00002e  884d              LDRH     r5,[r1,#2]
000030  ea033505          AND      r5,r3,r5,LSL #12
000034  432c              ORRS     r4,r4,r5
;;;555        
;;;556      if((TIMx == TIM1) || (TIMx == TIM8))
000036  f1a04580          SUB      r5,r0,#0x40000000
00003a  f5b53596          SUBS     r5,r5,#0x12c00
00003e  bf1c              ITT      NE
000040  f1a04580          SUBNE    r5,r0,#0x40000000
000044  f5b5359a          SUBSNE   r5,r5,#0x13400
000048  d105              BNE      |L57.86|
;;;557      {
;;;558        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;559        /* Reset the Ouput Compare IDLE State */
;;;560        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS4));
;;;561        /* Set the Output Idle state */
;;;562        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
00004a  898d              LDRH     r5,[r1,#0xc]
00004c  f4224280          BIC      r2,r2,#0x4000         ;560
000050  ea031385          AND      r3,r3,r5,LSL #6
000054  431a              ORRS     r2,r2,r3
                  |L57.86|
;;;563      }
;;;564      /* Write to TIMx CR2 */
;;;565      TIMx->CR2 = tmpcr2;
000056  8082              STRH     r2,[r0,#4]
;;;566      
;;;567      /* Write to TIMx CCMR2 */  
;;;568      TIMx->CCMR2 = tmpccmrx;
000058  f8a0c01c          STRH     r12,[r0,#0x1c]
;;;569    
;;;570      /* Set the Capture Compare Register value */
;;;571      TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
00005c  88c9              LDRH     r1,[r1,#6]
00005e  f8a01040          STRH     r1,[r0,#0x40]
;;;572      
;;;573      /* Write to TIMx CCER */
;;;574      TIMx->CCER = tmpccer;
000062  8404              STRH     r4,[r0,#0x20]
;;;575    }
000064  bc30              POP      {r4,r5}
000066  4770              BX       lr
;;;576    
                          ENDP


                          AREA ||i.TIM_OC4PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PolarityConfig PROC
;;;1936     */
;;;1937   void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1938   {
;;;1939     uint16_t tmpccer = 0;
;;;1940     /* Check the parameters */
;;;1941     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1942     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1943     tmpccer = TIMx->CCER;
;;;1944     /* Set or Reset the CC4P Bit */
;;;1945     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC4P);
;;;1946     tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
000002  f64f73ff          MOV      r3,#0xffff
000006  f4225200          BIC      r2,r2,#0x2000         ;1945
00000a  ea033101          AND      r1,r3,r1,LSL #12
00000e  4311              ORRS     r1,r1,r2
;;;1947     /* Write to TIMx CCER register */
;;;1948     TIMx->CCER = tmpccer;
000010  8401              STRH     r1,[r0,#0x20]
;;;1949   }
000012  4770              BX       lr
;;;1950   
                          ENDP


                          AREA ||i.TIM_OC4PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PreloadConfig PROC
;;;1571     */
;;;1572   void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1573   {
;;;1574     uint16_t tmpccmr2 = 0;
;;;1575     /* Check the parameters */
;;;1576     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1577     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1578     tmpccmr2 = TIMx->CCMR2;
;;;1579     /* Reset the OC4PE Bit */
;;;1580     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4PE);
;;;1581     /* Enable or Disable the Output Compare Preload feature */
;;;1582     tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f4226200          BIC      r2,r2,#0x800          ;1580
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1583     /* Write to TIMx CCMR2 register */
;;;1584     TIMx->CCMR2 = tmpccmr2;
000010  8381              STRH     r1,[r0,#0x1c]
;;;1585   }
000012  4770              BX       lr
;;;1586   
                          ENDP


                          AREA ||i.TIM_OCStructInit||, CODE, READONLY, ALIGN=1

                  TIM_OCStructInit PROC
;;;741      */
;;;742    void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  2100              MOVS     r1,#0
;;;743    {
;;;744      /* Set the default configuration */
;;;745      TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
000002  8001              STRH     r1,[r0,#0]
;;;746      TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;747      TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
000006  8081              STRH     r1,[r0,#4]
;;;748      TIM_OCInitStruct->TIM_Pulse = 0x0000;
000008  80c1              STRH     r1,[r0,#6]
;;;749      TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
00000a  8101              STRH     r1,[r0,#8]
;;;750      TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
00000c  8141              STRH     r1,[r0,#0xa]
;;;751      TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
00000e  8181              STRH     r1,[r0,#0xc]
;;;752      TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
000010  81c1              STRH     r1,[r0,#0xe]
;;;753    }
000012  4770              BX       lr
;;;754    
                          ENDP


                          AREA ||i.TIM_PWMIConfig||, CODE, READONLY, ALIGN=1

                  TIM_PWMIConfig PROC
;;;643      */
;;;644    void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  e92d01f0          PUSH     {r4-r8}
;;;645    {
;;;646      uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
;;;647      uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
;;;648      /* Check the parameters */
;;;649      assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;650      /* Select the Opposite Input Polarity */
;;;651      if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
000004  884e              LDRH     r6,[r1,#2]
000006  2300              MOVS     r3,#0                 ;646
000008  2201              MOVS     r2,#1                 ;647
00000a  2e00              CMP      r6,#0
;;;652      {
;;;653        icoppositepolarity = TIM_ICPolarity_Falling;
00000c  bf08              IT       EQ
00000e  2302              MOVEQ    r3,#2
;;;654      }
;;;655      else
;;;656      {
;;;657        icoppositepolarity = TIM_ICPolarity_Rising;
;;;658      }
;;;659      /* Select the Opposite Input */
;;;660      if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
000010  888d              LDRH     r5,[r1,#4]
000012  2d01              CMP      r5,#1
;;;661      {
;;;662        icoppositeselection = TIM_ICSelection_IndirectTI;
000014  bf08              IT       EQ
000016  2202              MOVEQ    r2,#2
;;;663      }
;;;664      else
;;;665      {
;;;666        icoppositeselection = TIM_ICSelection_DirectTI;
;;;667      }
;;;668      if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000018  880f              LDRH     r7,[r1,#0]
;;;669      {
;;;670        /* TI1 Configuration */
;;;671        TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
00001a  890c              LDRH     r4,[r1,#8]
00001c  2f00              CMP      r7,#0                 ;668
00001e  8c07              LDRH     r7,[r0,#0x20]         ;668
000020  f64f7cff          MOV      r12,#0xffff           ;668
000024  d042              BEQ      |L61.172|
000026  f0270710          BIC      r7,r7,#0x10           ;645
00002a  8407              STRH     r7,[r0,#0x20]         ;645
00002c  f8b08018          LDRH     r8,[r0,#0x18]         ;645
000030  8c07              LDRH     r7,[r0,#0x20]         ;645
000032  f4284873          BIC      r8,r8,#0xf300         ;645
000036  ea0c3404          AND      r4,r12,r4,LSL #12     ;645
00003a  ea440408          ORR      r4,r4,r8              ;645
00003e  ea0c2505          AND      r5,r12,r5,LSL #8      ;645
000042  432c              ORRS     r4,r4,r5              ;645
000044  ea0c1606          AND      r6,r12,r6,LSL #4      ;645
000048  f0270520          BIC      r5,r7,#0x20           ;645
00004c  4335              ORRS     r5,r5,r6              ;645
00004e  f0450510          ORR      r5,r5,#0x10           ;645
000052  8304              STRH     r4,[r0,#0x18]         ;645
000054  8405              STRH     r5,[r0,#0x20]         ;645
;;;672                   TIM_ICInitStruct->TIM_ICFilter);
;;;673        /* Set the Input Capture Prescaler value */
;;;674        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;675        /* TI2 Configuration */
;;;676        TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
;;;677        /* Set the Input Capture Prescaler value */
;;;678        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;679      }
;;;680      else
;;;681      { 
;;;682        /* TI2 Configuration */
;;;683        TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
;;;684                   TIM_ICInitStruct->TIM_ICFilter);
;;;685        /* Set the Input Capture Prescaler value */
;;;686        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000056  798c              LDRB     r4,[r1,#6]
000058  8b05              LDRH     r5,[r0,#0x18]
00005a  f4256540          BIC      r5,r5,#0xc00
00005e  8305              STRH     r5,[r0,#0x18]
000060  8b05              LDRH     r5,[r0,#0x18]
000062  ea0c2404          AND      r4,r12,r4,LSL #8
000066  432c              ORRS     r4,r4,r5
000068  8304              STRH     r4,[r0,#0x18]
;;;687        /* TI1 Configuration */
;;;688        TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
00006a  890c              LDRH     r4,[r1,#8]
00006c  8c05              LDRH     r5,[r0,#0x20]
00006e  f0250501          BIC      r5,r5,#1
000072  8405              STRH     r5,[r0,#0x20]
000074  8b06              LDRH     r6,[r0,#0x18]
000076  8c05              LDRH     r5,[r0,#0x20]
000078  ea0c1c04          AND      r12,r12,r4,LSL #4
00007c  ea4c0202          ORR      r2,r12,r2
000080  f02606f3          BIC      r6,r6,#0xf3
000084  f0250c02          BIC      r12,r5,#2
000088  4332              ORRS     r2,r2,r6
00008a  ea4c0303          ORR      r3,r12,r3
00008e  f0430301          ORR      r3,r3,#1
000092  8302              STRH     r2,[r0,#0x18]
000094  8403              STRH     r3,[r0,#0x20]
;;;689        /* Set the Input Capture Prescaler value */
;;;690        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000096  88c9              LDRH     r1,[r1,#6]
000098  8b02              LDRH     r2,[r0,#0x18]
00009a  f022020c          BIC      r2,r2,#0xc
00009e  8302              STRH     r2,[r0,#0x18]
0000a0  8b02              LDRH     r2,[r0,#0x18]
0000a2  4311              ORRS     r1,r1,r2
0000a4  8301              STRH     r1,[r0,#0x18]
;;;691      }
;;;692    }
0000a6  e8bd01f0          POP      {r4-r8}
0000aa  4770              BX       lr
                  |L61.172|
0000ac  f0270701          BIC      r7,r7,#1
0000b0  8407              STRH     r7,[r0,#0x20]
0000b2  8b07              LDRH     r7,[r0,#0x18]
0000b4  f8b08020          LDRH     r8,[r0,#0x20]
0000b8  ea0c1404          AND      r4,r12,r4,LSL #4
0000bc  432c              ORRS     r4,r4,r5
0000be  f02707f3          BIC      r7,r7,#0xf3
0000c2  433c              ORRS     r4,r4,r7
0000c4  f0280502          BIC      r5,r8,#2
0000c8  4335              ORRS     r5,r5,r6
0000ca  f0450501          ORR      r5,r5,#1
0000ce  8304              STRH     r4,[r0,#0x18]
0000d0  8405              STRH     r5,[r0,#0x20]
0000d2  88cc              LDRH     r4,[r1,#6]            ;674
0000d4  8b05              LDRH     r5,[r0,#0x18]         ;674
0000d6  f025050c          BIC      r5,r5,#0xc            ;674
0000da  8305              STRH     r5,[r0,#0x18]         ;674
0000dc  8b05              LDRH     r5,[r0,#0x18]         ;674
0000de  432c              ORRS     r4,r4,r5              ;674
0000e0  8304              STRH     r4,[r0,#0x18]         ;674
0000e2  7a0c              LDRB     r4,[r1,#8]            ;676
0000e4  8c05              LDRH     r5,[r0,#0x20]         ;676
0000e6  f0250510          BIC      r5,r5,#0x10           ;676
0000ea  8405              STRH     r5,[r0,#0x20]         ;676
0000ec  8b05              LDRH     r5,[r0,#0x18]         ;676
0000ee  8c06              LDRH     r6,[r0,#0x20]         ;676
0000f0  f4254573          BIC      r5,r5,#0xf300         ;676
0000f4  ea0c3404          AND      r4,r12,r4,LSL #12     ;676
0000f8  432c              ORRS     r4,r4,r5              ;676
0000fa  ea0c2202          AND      r2,r12,r2,LSL #8      ;676
0000fe  4322              ORRS     r2,r2,r4              ;676
000100  ea0c1303          AND      r3,r12,r3,LSL #4      ;676
000104  f0260420          BIC      r4,r6,#0x20           ;676
000108  4323              ORRS     r3,r3,r4              ;676
00010a  f0430310          ORR      r3,r3,#0x10           ;676
00010e  8302              STRH     r2,[r0,#0x18]         ;676
000110  8403              STRH     r3,[r0,#0x20]         ;676
000112  7989              LDRB     r1,[r1,#6]            ;678
000114  8b02              LDRH     r2,[r0,#0x18]         ;678
000116  f4226240          BIC      r2,r2,#0xc00          ;678
00011a  8302              STRH     r2,[r0,#0x18]         ;678
00011c  8b02              LDRH     r2,[r0,#0x18]         ;678
00011e  ea0c2101          AND      r1,r12,r1,LSL #8      ;678
000122  4311              ORRS     r1,r1,r2              ;678
000124  8301              STRH     r1,[r0,#0x18]         ;678
000126  e8bd01f0          POP      {r4-r8}
00012a  4770              BX       lr
;;;693    
                          ENDP


                          AREA ||i.TIM_PrescalerConfig||, CODE, READONLY, ALIGN=1

                  TIM_PrescalerConfig PROC
;;;1165     */
;;;1166   void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
000000  8501              STRH     r1,[r0,#0x28]
;;;1167   {
;;;1168     /* Check the parameters */
;;;1169     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1170     assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
;;;1171     /* Set the Prescaler value */
;;;1172     TIMx->PSC = Prescaler;
;;;1173     /* Set or reset the UG Bit */
;;;1174     TIMx->EGR = TIM_PSCReloadMode;
000002  8282              STRH     r2,[r0,#0x14]
;;;1175   }
000004  4770              BX       lr
;;;1176   
                          ENDP


                          AREA ||i.TIM_SelectCCDMA||, CODE, READONLY, ALIGN=1

                  TIM_SelectCCDMA PROC
;;;1447     */
;;;1448   void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1449   {
;;;1450     /* Check the parameters */
;;;1451     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1452     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1453     if (NewState != DISABLE)
;;;1454     {
;;;1455       /* Set the CCDS Bit */
;;;1456       TIMx->CR2 |= TIM_CR2_CCDS;
;;;1457     }
;;;1458     else
;;;1459     {
;;;1460       /* Reset the CCDS Bit */
;;;1461       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCDS);
000002  8881              LDRH     r1,[r0,#4]
000004  bf14              ITE      NE                    ;1456
000006  f0410108          ORRNE    r1,r1,#8              ;1456
00000a  f0210108          BICEQ    r1,r1,#8
00000e  8081              STRH     r1,[r0,#4]            ;1456
;;;1462     }
;;;1463   }
000010  4770              BX       lr
;;;1464   
                          ENDP


                          AREA ||i.TIM_SelectCOM||, CODE, READONLY, ALIGN=1

                  TIM_SelectCOM PROC
;;;1422     */
;;;1423   void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1424   {
;;;1425     /* Check the parameters */
;;;1426     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1427     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1428     if (NewState != DISABLE)
;;;1429     {
;;;1430       /* Set the COM Bit */
;;;1431       TIMx->CR2 |= TIM_CR2_CCUS;
;;;1432     }
;;;1433     else
;;;1434     {
;;;1435       /* Reset the COM Bit */
;;;1436       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCUS);
000002  8881              LDRH     r1,[r0,#4]
000004  bf14              ITE      NE                    ;1431
000006  f0410104          ORRNE    r1,r1,#4              ;1431
00000a  f0210104          BICEQ    r1,r1,#4
00000e  8081              STRH     r1,[r0,#4]            ;1431
;;;1437     }
;;;1438   }
000010  4770              BX       lr
;;;1439   
                          ENDP


                          AREA ||i.TIM_SelectHallSensor||, CODE, READONLY, ALIGN=1

                  TIM_SelectHallSensor PROC
;;;2133     */
;;;2134   void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;2135   {
;;;2136     /* Check the parameters */
;;;2137     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2138     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2139     if (NewState != DISABLE)
;;;2140     {
;;;2141       /* Set the TI1S Bit */
;;;2142       TIMx->CR2 |= TIM_CR2_TI1S;
;;;2143     }
;;;2144     else
;;;2145     {
;;;2146       /* Reset the TI1S Bit */
;;;2147       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_TI1S);
000002  8881              LDRH     r1,[r0,#4]
000004  bf14              ITE      NE                    ;2142
000006  f0410180          ORRNE    r1,r1,#0x80           ;2142
00000a  f0210180          BICEQ    r1,r1,#0x80
00000e  8081              STRH     r1,[r0,#4]            ;2142
;;;2148     }
;;;2149   }
000010  4770              BX       lr
;;;2150   
                          ENDP


                          AREA ||i.TIM_SelectInputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectInputTrigger PROC
;;;1218     */
;;;1219   void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000000  8902              LDRH     r2,[r0,#8]
;;;1220   {
;;;1221     uint16_t tmpsmcr = 0;
;;;1222     /* Check the parameters */
;;;1223     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1224     assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;1225     /* Get the TIMx SMCR register value */
;;;1226     tmpsmcr = TIMx->SMCR;
;;;1227     /* Reset the TS Bits */
;;;1228     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
000002  f0220270          BIC      r2,r2,#0x70
;;;1229     /* Set the Input Trigger source */
;;;1230     tmpsmcr |= TIM_InputTriggerSource;
000006  4311              ORRS     r1,r1,r2
;;;1231     /* Write to TIMx SMCR */
;;;1232     TIMx->SMCR = tmpsmcr;
000008  8101              STRH     r1,[r0,#8]
;;;1233   }
00000a  4770              BX       lr
;;;1234   
                          ENDP


                          AREA ||i.TIM_SelectMasterSlaveMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectMasterSlaveMode PROC
;;;2235     */
;;;2236   void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
000000  8902              LDRH     r2,[r0,#8]
;;;2237   {
;;;2238     /* Check the parameters */
;;;2239     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2240     assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
;;;2241     /* Reset the MSM Bit */
;;;2242     TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_MSM);
000002  f0220280          BIC      r2,r2,#0x80
000006  8102              STRH     r2,[r0,#8]
;;;2243     
;;;2244     /* Set or Reset the MSM Bit */
;;;2245     TIMx->SMCR |= TIM_MasterSlaveMode;
000008  8902              LDRH     r2,[r0,#8]
00000a  4311              ORRS     r1,r1,r2
00000c  8101              STRH     r1,[r0,#8]
;;;2246   }
00000e  4770              BX       lr
;;;2247   
                          ENDP


                          AREA ||i.TIM_SelectOCxM||, CODE, READONLY, ALIGN=1

                  TIM_SelectOCxM PROC
;;;2034     */
;;;2035   void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
000000  b410              PUSH     {r4}
;;;2036   {
;;;2037     uint32_t tmp = 0;
;;;2038     uint16_t tmp1 = 0;
;;;2039   
;;;2040     /* Check the parameters */
;;;2041     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;2042     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;2043     assert_param(IS_TIM_OCM(TIM_OCMode));
;;;2044   
;;;2045     tmp = (uint32_t) TIMx;
;;;2046     tmp += CCMR_Offset;
;;;2047   
;;;2048     tmp1 = CCER_CCE_Set << (uint16_t)TIM_Channel;
000002  f04f0c01          MOV      r12,#1
;;;2049   
;;;2050     /* Disable the Channel: Reset the CCxE Bit */
;;;2051     TIMx->CCER &= (uint16_t) ~tmp1;
000006  8c04              LDRH     r4,[r0,#0x20]
000008  f1000318          ADD      r3,r0,#0x18           ;2046
00000c  fa0cfc01          LSL      r12,r12,r1            ;2048
000010  ea240c0c          BIC      r12,r4,r12
000014  f8a0c020          STRH     r12,[r0,#0x20]
;;;2052   
;;;2053     if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
000018  2900              CMP      r1,#0
00001a  bf18              IT       NE
00001c  2908              CMPNE    r1,#8
00001e  d010              BEQ      |L68.66|
;;;2054     {
;;;2055       tmp += (TIM_Channel>>1);
;;;2056   
;;;2057       /* Reset the OCxM bits in the CCMRx register */
;;;2058       *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC1M);
;;;2059      
;;;2060       /* Configure the OCxM bits in the CCMRx register */
;;;2061       *(__IO uint32_t *) tmp |= TIM_OCMode;
;;;2062     }
;;;2063     else
;;;2064     {
;;;2065       tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
000020  1f08              SUBS     r0,r1,#4
000022  f3c0004e          UBFX     r0,r0,#1,#15
000026  4418              ADD      r0,r0,r3
;;;2066   
;;;2067       /* Reset the OCxM bits in the CCMRx register */
;;;2068       *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC2M);
000028  6801              LDR      r1,[r0,#0]
00002a  f42141e0          BIC      r1,r1,#0x7000
00002e  6001              STR      r1,[r0,#0]
;;;2069       
;;;2070       /* Configure the OCxM bits in the CCMRx register */
;;;2071       *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
000030  6801              LDR      r1,[r0,#0]
000032  f64f73ff          MOV      r3,#0xffff
000036  ea032202          AND      r2,r3,r2,LSL #8
00003a  4311              ORRS     r1,r1,r2
00003c  6001              STR      r1,[r0,#0]
;;;2072     }
;;;2073   }
00003e  bc10              POP      {r4}
000040  4770              BX       lr
                  |L68.66|
000042  eb030051          ADD      r0,r3,r1,LSR #1       ;2055
000046  6801              LDR      r1,[r0,#0]            ;2058
000048  f0210170          BIC      r1,r1,#0x70           ;2058
00004c  6001              STR      r1,[r0,#0]            ;2058
00004e  6801              LDR      r1,[r0,#0]            ;2061
000050  4311              ORRS     r1,r1,r2              ;2061
000052  6001              STR      r1,[r0,#0]            ;2061
000054  bc10              POP      {r4}
000056  4770              BX       lr
;;;2074   
                          ENDP


                          AREA ||i.TIM_SelectOnePulseMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectOnePulseMode PROC
;;;2159     */
;;;2160   void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
000000  8802              LDRH     r2,[r0,#0]
;;;2161   {
;;;2162     /* Check the parameters */
;;;2163     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2164     assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
;;;2165     /* Reset the OPM Bit */
;;;2166     TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_OPM);
000002  f0220208          BIC      r2,r2,#8
000006  8002              STRH     r2,[r0,#0]
;;;2167     /* Configure the OPM Mode */
;;;2168     TIMx->CR1 |= TIM_OPMode;
000008  8802              LDRH     r2,[r0,#0]
00000a  4311              ORRS     r1,r1,r2
00000c  8001              STRH     r1,[r0,#0]
;;;2169   }
00000e  4770              BX       lr
;;;2170   
                          ENDP


                          AREA ||i.TIM_SelectOutputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectOutputTrigger PROC
;;;2191     */
;;;2192   void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
000000  8882              LDRH     r2,[r0,#4]
;;;2193   {
;;;2194     /* Check the parameters */
;;;2195     assert_param(IS_TIM_LIST7_PERIPH(TIMx));
;;;2196     assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
;;;2197     /* Reset the MMS Bits */
;;;2198     TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_MMS);
000002  f0220270          BIC      r2,r2,#0x70
000006  8082              STRH     r2,[r0,#4]
;;;2199     /* Select the TRGO source */
;;;2200     TIMx->CR2 |=  TIM_TRGOSource;
000008  8882              LDRH     r2,[r0,#4]
00000a  4311              ORRS     r1,r1,r2
00000c  8081              STRH     r1,[r0,#4]
;;;2201   }
00000e  4770              BX       lr
;;;2202   
                          ENDP


                          AREA ||i.TIM_SelectSlaveMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectSlaveMode PROC
;;;2214     */
;;;2215   void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
000000  8902              LDRH     r2,[r0,#8]
;;;2216   {
;;;2217     /* Check the parameters */
;;;2218     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2219     assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
;;;2220    /* Reset the SMS Bits */
;;;2221     TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_SMS);
000002  f0220207          BIC      r2,r2,#7
000006  8102              STRH     r2,[r0,#8]
;;;2222     /* Select the Slave Mode */
;;;2223     TIMx->SMCR |= TIM_SlaveMode;
000008  8902              LDRH     r2,[r0,#8]
00000a  4311              ORRS     r1,r1,r2
00000c  8101              STRH     r1,[r0,#8]
;;;2224   }
00000e  4770              BX       lr
;;;2225   
                          ENDP


                          AREA ||i.TIM_SetAutoreload||, CODE, READONLY, ALIGN=1

                  TIM_SetAutoreload PROC
;;;2267     */
;;;2268   void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint16_t Autoreload)
000000  8581              STRH     r1,[r0,#0x2c]
;;;2269   {
;;;2270     /* Check the parameters */
;;;2271     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2272     /* Set the Autoreload Register value */
;;;2273     TIMx->ARR = Autoreload;
;;;2274   }
000002  4770              BX       lr
;;;2275   
                          ENDP


                          AREA ||i.TIM_SetClockDivision||, CODE, READONLY, ALIGN=1

                  TIM_SetClockDivision PROC
;;;2430     */
;;;2431   void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
000000  8802              LDRH     r2,[r0,#0]
;;;2432   {
;;;2433     /* Check the parameters */
;;;2434     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;2435     assert_param(IS_TIM_CKD_DIV(TIM_CKD));
;;;2436     /* Reset the CKD Bits */
;;;2437     TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_CKD);
000002  f4227240          BIC      r2,r2,#0x300
000006  8002              STRH     r2,[r0,#0]
;;;2438     /* Set the CKD value */
;;;2439     TIMx->CR1 |= TIM_CKD;
000008  8802              LDRH     r2,[r0,#0]
00000a  4311              ORRS     r1,r1,r2
00000c  8001              STRH     r1,[r0,#0]
;;;2440   }
00000e  4770              BX       lr
;;;2441   
                          ENDP


                          AREA ||i.TIM_SetCompare1||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare1 PROC
;;;2281     */
;;;2282   void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1)
000000  8681              STRH     r1,[r0,#0x34]
;;;2283   {
;;;2284     /* Check the parameters */
;;;2285     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;2286     /* Set the Capture Compare1 Register value */
;;;2287     TIMx->CCR1 = Compare1;
;;;2288   }
000002  4770              BX       lr
;;;2289   
                          ENDP


                          AREA ||i.TIM_SetCompare2||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare2 PROC
;;;2295     */
;;;2296   void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2)
000000  8701              STRH     r1,[r0,#0x38]
;;;2297   {
;;;2298     /* Check the parameters */
;;;2299     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2300     /* Set the Capture Compare2 Register value */
;;;2301     TIMx->CCR2 = Compare2;
;;;2302   }
000002  4770              BX       lr
;;;2303   
                          ENDP


                          AREA ||i.TIM_SetCompare3||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare3 PROC
;;;2309     */
;;;2310   void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3)
000000  8781              STRH     r1,[r0,#0x3c]
;;;2311   {
;;;2312     /* Check the parameters */
;;;2313     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2314     /* Set the Capture Compare3 Register value */
;;;2315     TIMx->CCR3 = Compare3;
;;;2316   }
000002  4770              BX       lr
;;;2317   
                          ENDP


                          AREA ||i.TIM_SetCompare4||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare4 PROC
;;;2323     */
;;;2324   void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4)
000000  f8a01040          STRH     r1,[r0,#0x40]
;;;2325   {
;;;2326     /* Check the parameters */
;;;2327     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2328     /* Set the Capture Compare4 Register value */
;;;2329     TIMx->CCR4 = Compare4;
;;;2330   }
000004  4770              BX       lr
;;;2331   
                          ENDP


                          AREA ||i.TIM_SetCounter||, CODE, READONLY, ALIGN=1

                  TIM_SetCounter PROC
;;;2253     */
;;;2254   void TIM_SetCounter(TIM_TypeDef* TIMx, uint16_t Counter)
000000  8481              STRH     r1,[r0,#0x24]
;;;2255   {
;;;2256     /* Check the parameters */
;;;2257     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2258     /* Set the Counter Register value */
;;;2259     TIMx->CNT = Counter;
;;;2260   }
000002  4770              BX       lr
;;;2261   
                          ENDP


                          AREA ||i.TIM_SetIC1Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC1Prescaler PROC
;;;2342     */
;;;2343   void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;2344   {
;;;2345     /* Check the parameters */
;;;2346     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;2347     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2348     /* Reset the IC1PSC Bits */
;;;2349     TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC1PSC);
000002  f022020c          BIC      r2,r2,#0xc
000006  8302              STRH     r2,[r0,#0x18]
;;;2350     /* Set the IC1PSC value */
;;;2351     TIMx->CCMR1 |= TIM_ICPSC;
000008  8b02              LDRH     r2,[r0,#0x18]
00000a  4311              ORRS     r1,r1,r2
00000c  8301              STRH     r1,[r0,#0x18]
;;;2352   }
00000e  4770              BX       lr
;;;2353   
                          ENDP


                          AREA ||i.TIM_SetIC2Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC2Prescaler PROC
;;;2364     */
;;;2365   void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;2366   {
;;;2367     /* Check the parameters */
;;;2368     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2369     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2370     /* Reset the IC2PSC Bits */
;;;2371     TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC2PSC);
000002  f4226240          BIC      r2,r2,#0xc00
000006  8302              STRH     r2,[r0,#0x18]
;;;2372     /* Set the IC2PSC value */
;;;2373     TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
000008  8b02              LDRH     r2,[r0,#0x18]
00000a  f64f73ff          MOV      r3,#0xffff
00000e  ea032101          AND      r1,r3,r1,LSL #8
000012  4311              ORRS     r1,r1,r2
000014  8301              STRH     r1,[r0,#0x18]
;;;2374   }
000016  4770              BX       lr
;;;2375   
                          ENDP


                          AREA ||i.TIM_SetIC3Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC3Prescaler PROC
;;;2386     */
;;;2387   void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;2388   {
;;;2389     /* Check the parameters */
;;;2390     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2391     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2392     /* Reset the IC3PSC Bits */
;;;2393     TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC3PSC);
000002  f022020c          BIC      r2,r2,#0xc
000006  8382              STRH     r2,[r0,#0x1c]
;;;2394     /* Set the IC3PSC value */
;;;2395     TIMx->CCMR2 |= TIM_ICPSC;
000008  8b82              LDRH     r2,[r0,#0x1c]
00000a  4311              ORRS     r1,r1,r2
00000c  8381              STRH     r1,[r0,#0x1c]
;;;2396   }
00000e  4770              BX       lr
;;;2397   
                          ENDP


                          AREA ||i.TIM_SetIC4Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC4Prescaler PROC
;;;2408     */
;;;2409   void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;2410   {  
;;;2411     /* Check the parameters */
;;;2412     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2413     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2414     /* Reset the IC4PSC Bits */
;;;2415     TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC4PSC);
000002  f4226240          BIC      r2,r2,#0xc00
000006  8382              STRH     r2,[r0,#0x1c]
;;;2416     /* Set the IC4PSC value */
;;;2417     TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
000008  8b82              LDRH     r2,[r0,#0x1c]
00000a  f64f73ff          MOV      r3,#0xffff
00000e  ea032101          AND      r1,r3,r1,LSL #8
000012  4311              ORRS     r1,r1,r2
000014  8381              STRH     r1,[r0,#0x1c]
;;;2418   }
000016  4770              BX       lr
;;;2419   
                          ENDP


                          AREA ||i.TIM_TIxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_TIxExternalClockConfig PROC
;;;1024     */
;;;1025   void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
000000  b430              PUSH     {r4,r5}
000002  8c04              LDRH     r4,[r0,#0x20]
000004  f64f7cff          MOV      r12,#0xffff
;;;1026                                   uint16_t TIM_ICPolarity, uint16_t ICFilter)
;;;1027   {
;;;1028     /* Check the parameters */
;;;1029     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1030     assert_param(IS_TIM_TIXCLK_SOURCE(TIM_TIxExternalCLKSource));
;;;1031     assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
;;;1032     assert_param(IS_TIM_IC_FILTER(ICFilter));
;;;1033     /* Configure the Timer Input Clock Source */
;;;1034     if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
000008  2960              CMP      r1,#0x60
00000a  d01e              BEQ      |L83.74|
00000c  f0240401          BIC      r4,r4,#1              ;1027
000010  8404              STRH     r4,[r0,#0x20]         ;1027
000012  8b05              LDRH     r5,[r0,#0x18]         ;1027
000014  8c04              LDRH     r4,[r0,#0x20]         ;1027
000016  ea0c1303          AND      r3,r12,r3,LSL #4      ;1027
00001a  f02505f3          BIC      r5,r5,#0xf3           ;1027
00001e  f0430301          ORR      r3,r3,#1              ;1027
000022  f0240c02          BIC      r12,r4,#2             ;1027
000026  432b              ORRS     r3,r3,r5              ;1027
000028  ea4c0202          ORR      r2,r12,r2             ;1027
00002c  f0420201          ORR      r2,r2,#1              ;1027
000030  8303              STRH     r3,[r0,#0x18]         ;1027
000032  8402              STRH     r2,[r0,#0x20]         ;1027
                  |L83.52|
000034  8902              LDRH     r2,[r0,#8]            ;1027
000036  f0220270          BIC      r2,r2,#0x70           ;1027
00003a  4311              ORRS     r1,r1,r2              ;1027
00003c  8101              STRH     r1,[r0,#8]            ;1027
;;;1035     {
;;;1036       TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
;;;1037     }
;;;1038     else
;;;1039     {
;;;1040       TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
;;;1041     }
;;;1042     /* Select the Trigger source */
;;;1043     TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
;;;1044     /* Select the External clock mode1 */
;;;1045     TIMx->SMCR |= TIM_SlaveMode_External1;
00003e  8901              LDRH     r1,[r0,#8]
000040  f0410107          ORR      r1,r1,#7
000044  8101              STRH     r1,[r0,#8]
;;;1046   }
000046  bc30              POP      {r4,r5}
000048  4770              BX       lr
                  |L83.74|
00004a  f0240410          BIC      r4,r4,#0x10
00004e  8404              STRH     r4,[r0,#0x20]
000050  8b05              LDRH     r5,[r0,#0x18]
000052  8c04              LDRH     r4,[r0,#0x20]
000054  ea0c3303          AND      r3,r12,r3,LSL #12
000058  ea0c1202          AND      r2,r12,r2,LSL #4
00005c  f4254573          BIC      r5,r5,#0xf300
000060  432b              ORRS     r3,r3,r5
000062  f0240c20          BIC      r12,r4,#0x20
000066  f4437380          ORR      r3,r3,#0x100
00006a  ea4c0202          ORR      r2,r12,r2
00006e  f0420210          ORR      r2,r2,#0x10
000072  8303              STRH     r3,[r0,#0x18]
000074  8402              STRH     r2,[r0,#0x20]
000076  e7dd              B        |L83.52|
;;;1047   
                          ENDP


                          AREA ||i.TIM_TimeBaseInit||, CODE, READONLY, ALIGN=2

                  TIM_TimeBaseInit PROC
;;;223      */
;;;224    void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  b410              PUSH     {r4}
;;;225    {
;;;226      uint16_t tmpcr1 = 0;
;;;227    
;;;228      /* Check the parameters */
;;;229      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;230      assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
;;;231      assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
;;;232    
;;;233      tmpcr1 = TIMx->CR1;  
000002  8802              LDRH     r2,[r0,#0]
;;;234    
;;;235      if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
000004  4b23              LDR      r3,|L84.148|
000006  f8dfc090          LDR      r12,|L84.152|
00000a  4298              CMP      r0,r3
00000c  bf18              IT       NE
00000e  4560              CMPNE    r0,r12
000010  d011              BEQ      |L84.54|
000012  f1b04f80          CMP      r0,#0x40000000
000016  bf1c              ITT      NE
000018  f1a04480          SUBNE    r4,r0,#0x40000000
00001c  f5b46480          SUBSNE   r4,r4,#0x400
000020  d009              BEQ      |L84.54|
;;;236         (TIMx == TIM4) || (TIMx == TIM5)) 
000022  f1a04480          SUB      r4,r0,#0x40000000
000026  f5b46400          SUBS     r4,r4,#0x800
00002a  bf1c              ITT      NE
00002c  f1a04480          SUBNE    r4,r0,#0x40000000
000030  f5b46440          SUBSNE   r4,r4,#0xc00
000034  d103              BNE      |L84.62|
                  |L84.54|
;;;237      {
;;;238        /* Select the Counter Mode */
;;;239        tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
;;;240        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
000036  884c              LDRH     r4,[r1,#2]
000038  f0220270          BIC      r2,r2,#0x70           ;239
00003c  4322              ORRS     r2,r2,r4
                  |L84.62|
;;;241      }
;;;242     
;;;243      if((TIMx != TIM6) && (TIMx != TIM7))
00003e  f1a04480          SUB      r4,r0,#0x40000000
000042  f5b45480          SUBS     r4,r4,#0x1000
000046  bf1c              ITT      NE
000048  f1a04480          SUBNE    r4,r0,#0x40000000
00004c  f5b454a0          SUBSNE   r4,r4,#0x1400
000050  d003              BEQ      |L84.90|
;;;244      {
;;;245        /* Set the clock division */
;;;246        tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
;;;247        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
000052  88cc              LDRH     r4,[r1,#6]
000054  f4227240          BIC      r2,r2,#0x300          ;246
000058  4322              ORRS     r2,r2,r4
                  |L84.90|
;;;248      }
;;;249    
;;;250      TIMx->CR1 = tmpcr1;
00005a  8002              STRH     r2,[r0,#0]
;;;251    
;;;252      /* Set the Autoreload value */
;;;253      TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
00005c  888a              LDRH     r2,[r1,#4]
00005e  8582              STRH     r2,[r0,#0x2c]
;;;254     
;;;255      /* Set the Prescaler value */
;;;256      TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
000060  880a              LDRH     r2,[r1,#0]
000062  8502              STRH     r2,[r0,#0x28]
;;;257        
;;;258      if ((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15)|| (TIMx == TIM16) || (TIMx == TIM17))  
000064  4298              CMP      r0,r3
000066  bf18              IT       NE
000068  4560              CMPNE    r0,r12
00006a  d00d              BEQ      |L84.136|
00006c  f1a04280          SUB      r2,r0,#0x40000000
000070  f5b232a0          SUBS     r2,r2,#0x14000
000074  bf1f              ITTTT    NE
000076  f1a04280          SUBNE    r2,r0,#0x40000000
00007a  f5b232a2          SUBSNE   r2,r2,#0x14400
00007e  f1a04280          SUBNE    r2,r0,#0x40000000
000082  f5b232a4          SUBSNE   r2,r2,#0x14800
000086  d101              BNE      |L84.140|
                  |L84.136|
;;;259      {
;;;260        /* Set the Repetition Counter value */
;;;261        TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
000088  7a09              LDRB     r1,[r1,#8]
00008a  8601              STRH     r1,[r0,#0x30]
                  |L84.140|
;;;262      }
;;;263    
;;;264      /* Generate an update event to reload the Prescaler and the Repetition counter
;;;265         values immediately */
;;;266      TIMx->EGR = TIM_PSCReloadMode_Immediate;           
00008c  2101              MOVS     r1,#1
00008e  8281              STRH     r1,[r0,#0x14]
;;;267    }
000090  bc10              POP      {r4}
000092  4770              BX       lr
;;;268    
                          ENDP

                  |L84.148|
                          DCD      0x40012c00
                  |L84.152|
                          DCD      0x40013400

                          AREA ||i.TIM_TimeBaseStructInit||, CODE, READONLY, ALIGN=1

                  TIM_TimeBaseStructInit PROC
;;;725      */
;;;726    void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  f64f71ff          MOV      r1,#0xffff
;;;727    {
;;;728      /* Set the default configuration */
;;;729      TIM_TimeBaseInitStruct->TIM_Period = 0xFFFF;
000004  8081              STRH     r1,[r0,#4]
;;;730      TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
000006  2100              MOVS     r1,#0
000008  8001              STRH     r1,[r0,#0]
;;;731      TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
00000a  80c1              STRH     r1,[r0,#6]
;;;732      TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
00000c  8041              STRH     r1,[r0,#2]
;;;733      TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
00000e  7201              STRB     r1,[r0,#8]
;;;734    }
000010  4770              BX       lr
;;;735    
                          ENDP


                          AREA ||i.TIM_UpdateDisableConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateDisableConfig PROC
;;;2081     */
;;;2082   void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;2083   {
;;;2084     /* Check the parameters */
;;;2085     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2086     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2087     if (NewState != DISABLE)
;;;2088     {
;;;2089       /* Set the Update Disable Bit */
;;;2090       TIMx->CR1 |= TIM_CR1_UDIS;
;;;2091     }
;;;2092     else
;;;2093     {
;;;2094       /* Reset the Update Disable Bit */
;;;2095       TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_UDIS);
000002  8801              LDRH     r1,[r0,#0]
000004  bf14              ITE      NE                    ;2090
000006  f0410102          ORRNE    r1,r1,#2              ;2090
00000a  f0210102          BICEQ    r1,r1,#2
00000e  8001              STRH     r1,[r0,#0]            ;2090
;;;2096     }
;;;2097   }
000010  4770              BX       lr
;;;2098   
                          ENDP


                          AREA ||i.TIM_UpdateRequestConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateRequestConfig PROC
;;;2109     */
;;;2110   void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
000000  2900              CMP      r1,#0
;;;2111   {
;;;2112     /* Check the parameters */
;;;2113     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2114     assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
;;;2115     if (TIM_UpdateSource != TIM_UpdateSource_Global)
;;;2116     {
;;;2117       /* Set the URS Bit */
;;;2118       TIMx->CR1 |= TIM_CR1_URS;
;;;2119     }
;;;2120     else
;;;2121     {
;;;2122       /* Reset the URS Bit */
;;;2123       TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_URS);
000002  8801              LDRH     r1,[r0,#0]
000004  bf14              ITE      NE                    ;2118
000006  f0410104          ORRNE    r1,r1,#4              ;2118
00000a  f0210104          BICEQ    r1,r1,#4
00000e  8001              STRH     r1,[r0,#0]            ;2118
;;;2124     }
;;;2125   }
000010  4770              BX       lr
;;;2126   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32F10x_StdPeriph_Lib_V3.3.0\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_tim.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f10x_tim_c_c458916b____REV16|
#line 464 "D:\\Program_Files_x86\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.1.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___15_stm32f10x_tim_c_c458916b____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f10x_tim_c_c458916b____REVSH|
#line 479
|__asm___15_stm32f10x_tim_c_c458916b____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f10x_tim_c_c458916b____RRX|
#line 666
|__asm___15_stm32f10x_tim_c_c458916b____RRX| PROC
#line 667

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
