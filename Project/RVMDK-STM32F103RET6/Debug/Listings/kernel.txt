; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\kernel.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\kernel.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32F10x_StdPeriph_Lib_V3.3.0\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\M0P0_Library\STM32F10x_StdPeriph_Lib_V3.3.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\..\M0P0_Library\STM32F10x_StdPeriph_Lib_V3.3.0\Libraries\CMSIS -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F103RET6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --enum_is_int --signed_chars --omf_browse=.\debug\output\kernel.crf ..\..\MProkaron\Kernel\kernel.c]
                          THUMB

                          AREA ||i.RMP_Clear||, CODE, READONLY, ALIGN=1

                  RMP_Clear PROC
;;;37     ******************************************************************************/
;;;38     void RMP_Clear(volatile void* Addr, ptr_t Size)
000000  b410              PUSH     {r4}
;;;39     {
;;;40         ptr_t* Word_Inc;
;;;41         u8* Byte_Inc;
;;;42         ptr_t Words;
;;;43         ptr_t Bytes;
;;;44         
;;;45         /* On processors not that fast, copy by word is really important */
;;;46         Word_Inc=(ptr_t*)Addr;
;;;47         for(Words=Size/sizeof(ptr_t);Words>0;Words--)
000002  088c              LSRS     r4,r1,#2
000004  2200              MOVS     r2,#0
000006  2903              CMP      r1,#3
000008  d910              BLS      |L1.44|
00000a  1f03              SUBS     r3,r0,#4
;;;48         {
;;;49             *Word_Inc=0;
;;;50             Word_Inc++;
;;;51         }
;;;52         
;;;53         /* Get the final bytes */
;;;54         Byte_Inc=(u8*)Word_Inc;
;;;55         for(Bytes=Size%sizeof(ptr_t);Bytes>0;Bytes--)
;;;56         {
;;;57             *Byte_Inc=0;
;;;58             Byte_Inc++;
;;;59         }
;;;60     }
00000c  f0140f01          TST      r4,#1
000010  bf18              IT       NE                    ;49
000012  f8432f04          STRNE    r2,[r3,#4]!           ;49
000016  ea5f0c64          ASRS     r12,r4,#1             ;47
00001a  d005              BEQ      |L1.40|
                  |L1.28|
00001c  605a              STR      r2,[r3,#4]            ;49
00001e  f8432f08          STR      r2,[r3,#8]!           ;49
000022  f1bc0c01          SUBS     r12,r12,#1            ;49
000026  d1f9              BNE      |L1.28|
                  |L1.40|
000028  eb000084          ADD      r0,r0,r4,LSL #2       ;51
                  |L1.44|
00002c  f0010303          AND      r3,r1,#3              ;55
000030  f0110f03          TST      r1,#3                 ;55
000034  bf04              ITT      EQ
000036  bc10              POPEQ    {r4}
000038  4770              BXEQ     lr
00003a  1e40              SUBS     r0,r0,#1
00003c  f0130f01          TST      r3,#1
000040  bf18              IT       NE                    ;57
000042  f8002f01          STRBNE   r2,[r0,#1]!           ;57
000046  0859              LSRS     r1,r3,#1              ;55
000048  bf04              ITT      EQ
00004a  bc10              POPEQ    {r4}
00004c  4770              BXEQ     lr
                  |L1.78|
00004e  7042              STRB     r2,[r0,#1]            ;57
000050  f8002f02          STRB     r2,[r0,#2]!           ;57
000054  1e49              SUBS     r1,r1,#1              ;57
000056  d1fa              BNE      |L1.78|
000058  bc10              POP      {r4}
00005a  4770              BX       lr
;;;61     /* End Function:RMP_Clear ****************************************************/
                          ENDP


                          AREA ||i.RMP_Init||, CODE, READONLY, ALIGN=2

                  RMP_Init PROC
;;;1506   ******************************************************************************/
;;;1507   void RMP_Init(void)
000000  4807              LDR      r0,|L2.32|
000002  2101              MOVS     r1,#1
000004  60c1              STR      r1,[r0,#0xc]  ; RMP_Sched_Locked
000006  6881              LDR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
000008  1c49              ADDS     r1,r1,#1
00000a  6081              STR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
;;;1508   {
;;;1509       RMP_Lock_Sched();
;;;1510       
;;;1511       /* Platform will use this hook to do something */
;;;1512       _RMP_Plat_Hook();
00000c  f7fffffe          BL       _RMP_Plat_Hook
;;;1513       /* Start the second thread here */
;;;1514       RMP_Init_Hook();
000010  f7fffffe          BL       RMP_Init_Hook
;;;1515       
;;;1516       RMP_Unlock_Sched();
000014  f7fffffe          BL       RMP_Unlock_Sched
                  |L2.24|
;;;1517       
;;;1518       while(1)
;;;1519       {
;;;1520           RMP_Init_Idle();
000018  f7fffffe          BL       RMP_Init_Idle
00001c  e7fc              B        |L2.24|
;;;1521       };
;;;1522   }
;;;1523   /* End Function:RMP_Init *****************************************************/
                          ENDP

00001e  0000              DCW      0x0000
                  |L2.32|
                          DCD      ||.data||

                          AREA ||i.RMP_List_Crt||, CODE, READONLY, ALIGN=1

                  RMP_List_Crt PROC
;;;215    ******************************************************************************/
;;;216    void RMP_List_Crt(volatile struct RMP_List* Head)
000000  6000              STR      r0,[r0,#0]
;;;217    {
;;;218        Head->Prev=(struct RMP_List*)Head;
;;;219        Head->Next=(struct RMP_List*)Head;
000002  6040              STR      r0,[r0,#4]
;;;220    }
000004  4770              BX       lr
;;;221    /* End Function:RMP_List_Crt *************************************************/
                          ENDP


                          AREA ||i.RMP_List_Del||, CODE, READONLY, ALIGN=1

                  RMP_List_Del PROC
;;;229    ******************************************************************************/
;;;230    void RMP_List_Del(volatile struct RMP_List* Prev,volatile struct RMP_List* Next)
000000  6008              STR      r0,[r1,#0]
;;;231    {
;;;232        Next->Prev=(struct RMP_List*)Prev;
;;;233        Prev->Next=(struct RMP_List*)Next;
000002  6041              STR      r1,[r0,#4]
;;;234    }
000004  4770              BX       lr
;;;235    /* End Function:RMP_List_Del *************************************************/
                          ENDP


                          AREA ||i.RMP_List_Ins||, CODE, READONLY, ALIGN=1

                  RMP_List_Ins PROC
;;;244    ******************************************************************************/
;;;245    void RMP_List_Ins(volatile struct RMP_List* New,
000000  6010              STR      r0,[r2,#0]
;;;246                      volatile struct RMP_List* Prev,
;;;247                      volatile struct RMP_List* Next)
;;;248    {
;;;249        Next->Prev=(struct RMP_List*)New;
;;;250        New->Next=(struct RMP_List*)Next;
000002  6042              STR      r2,[r0,#4]
;;;251        New->Prev=(struct RMP_List*)Prev;
000004  6001              STR      r1,[r0,#0]
;;;252        Prev->Next=(struct RMP_List*)New;
000006  6048              STR      r0,[r1,#4]
;;;253    }
000008  4770              BX       lr
;;;254    /* End Function:RMP_List_Ins *************************************************/
                          ENDP


                          AREA ||i.RMP_Load_Ctx||, CODE, READONLY, ALIGN=1

                  RMP_Load_Ctx PROC
;;;1474   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1475   void RMP_Load_Ctx(void)
000000  4770              BX       lr
;;;1476   {
;;;1477       return;
;;;1478   }
;;;1479   #endif
                          ENDP


                          AREA ||i.RMP_Lock_Sched||, CODE, READONLY, ALIGN=2

                  RMP_Lock_Sched PROC
;;;261    ******************************************************************************/
;;;262    void RMP_Lock_Sched(void)
000000  4803              LDR      r0,|L7.16|
;;;263    {
;;;264        RMP_Sched_Locked=1;
000002  2101              MOVS     r1,#1
000004  60c1              STR      r1,[r0,#0xc]  ; RMP_Sched_Locked
;;;265        RMP_Sched_Lock_Cnt++;
000006  6881              LDR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
000008  1c49              ADDS     r1,r1,#1
00000a  6081              STR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
;;;266    }
00000c  4770              BX       lr
;;;267    /* End Function:RMP_Lock_Sched ***********************************************/
                          ENDP

00000e  0000              DCW      0x0000
                  |L7.16|
                          DCD      ||.data||

                          AREA ||i.RMP_Print_Int||, CODE, READONLY, ALIGN=2

                  RMP_Print_Int PROC
;;;69     ******************************************************************************/
;;;70     cnt_t RMP_Print_Int(cnt_t Int)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;71     {
;;;72         ptr_t Iter;
;;;73         cnt_t Count;
;;;74         cnt_t Num;
;;;75         ptr_t Div;
;;;76         
;;;77         /* how many digits are there? */
;;;78         if(Int==0)
;;;79         {
;;;80             RMP_Putchar('0');
;;;81             return 1;
;;;82         }
;;;83         else if(Int<0)
;;;84         {
;;;85             /* How many digits are there? */
;;;86             Count=0;
;;;87             Div=1;
;;;88             Iter=-Int;
;;;89             while(Iter!=0)
;;;90             {
;;;91                 Iter/=10;
000004  f8df80b8          LDR      r8,|L8.192|
000008  1e05              SUBS     r5,r0,#0              ;71
;;;92                 Count++;
;;;93                 Div*=10;
;;;94             }
;;;95             Div/=10;
;;;96             
;;;97             RMP_Putchar('-');
;;;98             Iter=-Int;
;;;99             Num=Count+1;
;;;100            
;;;101            while(Count>0)
;;;102            {
;;;103                Count--;
;;;104                RMP_Putchar(Iter/Div+'0');
;;;105                Iter=Iter%Div;
;;;106                Div/=10;
;;;107            }
;;;108        }
;;;109        else
;;;110        {
;;;111            /* How many digits are there? */
;;;112            Count=0;
00000a  bfc4              ITT      GT
00000c  2400              MOVGT    r4,#0
;;;113            Div=1;
00000e  2101              MOVGT    r1,#1
000010  d02b              BEQ      |L8.106|
000012  da30              BGE      |L8.118|
000014  2600              MOVS     r6,#0                 ;86
000016  2101              MOVS     r1,#1                 ;87
000018  4244              RSBS     r4,r0,#0              ;88
00001a  4625              MOV      r5,r4                 ;88
00001c  d00a              BEQ      |L8.52|
00001e  bf00              NOP                            ;91
                  |L8.32|
000020  fba82004          UMULL    r2,r0,r8,r4           ;91
000024  08c4              LSRS     r4,r0,#3              ;91
000026  eb010081          ADD      r0,r1,r1,LSL #2       ;93
00002a  ea4f0140          LSL      r1,r0,#1              ;93
00002e  f1060601          ADD      r6,r6,#1              ;93
000032  d1f5              BNE      |L8.32|
                  |L8.52|
000034  fba81001          UMULL    r1,r0,r8,r1           ;95
000038  08c7              LSRS     r7,r0,#3              ;95
00003a  202d              MOVS     r0,#0x2d              ;97
00003c  f7fffffe          BL       RMP_Putchar
000040  f1060901          ADD      r9,r6,#1              ;99
000044  2e00              CMP      r6,#0                 ;101
000046  dd37              BLE      |L8.184|
                  |L8.72|
000048  fbb5f0f7          UDIV     r0,r5,r7              ;104
00004c  3030              ADDS     r0,r0,#0x30           ;104
00004e  b240              SXTB     r0,r0                 ;104
000050  1e76              SUBS     r6,r6,#1              ;104
000052  f7fffffe          BL       RMP_Putchar
000056  fbb5f0f7          UDIV     r0,r5,r7              ;105
00005a  fb075510          MLS      r5,r7,r0,r5           ;105
00005e  fba81007          UMULL    r1,r0,r8,r7           ;106
000062  08c7              LSRS     r7,r0,#3              ;106
000064  2e00              CMP      r6,#0                 ;101
000066  dcef              BGT      |L8.72|
000068  e026              B        |L8.184|
                  |L8.106|
00006a  2030              MOVS     r0,#0x30              ;80
00006c  f7fffffe          BL       RMP_Putchar
000070  2001              MOVS     r0,#1                 ;81
;;;114            Iter=Int;
;;;115            while(Iter!=0)
;;;116            {
;;;117                Iter/=10;
;;;118                Count++;
;;;119                Div*=10;
;;;120            }
;;;121            Div/=10;
;;;122            
;;;123            Iter=Int;
;;;124            Num=Count;
;;;125            
;;;126            while(Count>0)
;;;127            {
;;;128                Count--;
;;;129                RMP_Putchar(Iter/Div+'0');
;;;130                Iter=Iter%Div;
;;;131                Div/=10;
;;;132            }
;;;133        }
;;;134        
;;;135        return Num;
;;;136    }
000072  e8bd87f0          POP      {r4-r10,pc}
                  |L8.118|
000076  fba82000          UMULL    r2,r0,r8,r0           ;117
00007a  eb010181          ADD      r1,r1,r1,LSL #2       ;119
00007e  08c0              LSRS     r0,r0,#3              ;117
000080  ea4f0141          LSL      r1,r1,#1              ;119
000084  f1040401          ADD      r4,r4,#1              ;119
000088  d1f5              BNE      |L8.118|
00008a  fba81001          UMULL    r1,r0,r8,r1           ;121
00008e  08c6              LSRS     r6,r0,#3              ;121
000090  f1b40900          SUBS     r9,r4,#0              ;124
000094  dd10              BLE      |L8.184|
000096  bf00              NOP                            ;129
                  |L8.152|
000098  fbb5f0f6          UDIV     r0,r5,r6              ;129
00009c  3030              ADDS     r0,r0,#0x30           ;129
00009e  b240              SXTB     r0,r0                 ;129
0000a0  1e64              SUBS     r4,r4,#1              ;129
0000a2  f7fffffe          BL       RMP_Putchar
0000a6  fbb5f0f6          UDIV     r0,r5,r6              ;130
0000aa  fb065510          MLS      r5,r6,r0,r5           ;130
0000ae  fba81006          UMULL    r1,r0,r8,r6           ;131
0000b2  08c6              LSRS     r6,r0,#3              ;131
0000b4  2c00              CMP      r4,#0                 ;126
0000b6  dcef              BGT      |L8.152|
                  |L8.184|
0000b8  4648              MOV      r0,r9                 ;135
0000ba  e8bd87f0          POP      {r4-r10,pc}
;;;137    /* End Function:RMP_Print_Int ************************************************/
                          ENDP

0000be  0000              DCW      0x0000
                  |L8.192|
                          DCD      0xcccccccd

                          AREA ||i.RMP_Print_String||, CODE, READONLY, ALIGN=1

                  RMP_Print_String PROC
;;;192    ******************************************************************************/
;;;193    cnt_t RMP_Print_String(s8* String)
000000  b570              PUSH     {r4-r6,lr}
;;;194    {
000002  4605              MOV      r5,r0
;;;195        cnt_t Count;
;;;196        
;;;197        Count=0;
000004  2400              MOVS     r4,#0
                  |L9.6|
;;;198        while(Count<RMP_KERNEL_DEBUG_MAX_STR)
;;;199        {
;;;200            if(String[Count]=='\0')
000006  5728              LDRSB    r0,[r5,r4]
000008  b120              CBZ      r0,|L9.20|
00000a  1c64              ADDS     r4,r4,#1
;;;201                break;
;;;202            
;;;203            RMP_Putchar(String[Count++]);
00000c  f7fffffe          BL       RMP_Putchar
000010  2cff              CMP      r4,#0xff              ;198
000012  dbf8              BLT      |L9.6|
                  |L9.20|
;;;204        }
;;;205        
;;;206        return Count;
000014  4620              MOV      r0,r4
;;;207    }
000016  bd70              POP      {r4-r6,pc}
;;;208    /* End Function:RMP_Print_String *********************************************/
                          ENDP


                          AREA ||i.RMP_Print_Uint||, CODE, READONLY, ALIGN=1

                  RMP_Print_Uint PROC
;;;145    ******************************************************************************/
;;;146    cnt_t RMP_Print_Uint(ptr_t Uint)
000000  b570              PUSH     {r4-r6,lr}
;;;147    {
000002  0005              MOVS     r5,r0
000004  d003              BEQ      |L10.14|
;;;148        ptr_t Iter;
;;;149        cnt_t Count;
;;;150        cnt_t Num;
;;;151        
;;;152        /* how many digits are there? */
;;;153        if(Uint==0)
;;;154        {
;;;155            RMP_Putchar('0');
;;;156            return 1;
;;;157        }
;;;158        else
;;;159        {
;;;160            /* Filter out all the zeroes */
;;;161            Count=0;
000006  2100              MOVS     r1,#0
;;;162            Iter=Uint;
;;;163            while((Iter>>((sizeof(ptr_t)*8)-4))==0)
000008  0f02              LSRS     r2,r0,#28
00000a  d005              BEQ      |L10.24|
00000c  e008              B        |L10.32|
                  |L10.14|
00000e  2030              MOVS     r0,#0x30              ;155
000010  f7fffffe          BL       RMP_Putchar
000014  2001              MOVS     r0,#1                 ;156
;;;164            {
;;;165                Iter<<=4;
;;;166                Count++;
;;;167            }
;;;168            /* Count is the number of pts to print */
;;;169            Count=sizeof(ptr_t)*2-Count;
;;;170            Num=Count;
;;;171            while(Count>0)
;;;172            {
;;;173                Count--;
;;;174                Iter=(Uint>>(Count*4))&0x0F;
;;;175                if(Iter<10)
;;;176                    RMP_Putchar('0'+Iter);
;;;177                else
;;;178                    RMP_Putchar('A'+Iter-10);
;;;179            }
;;;180        }
;;;181        
;;;182        return Num;
;;;183    }
000016  bd70              POP      {r4-r6,pc}
                  |L10.24|
000018  0100              LSLS     r0,r0,#4              ;165
00001a  1c49              ADDS     r1,r1,#1              ;165
00001c  0f02              LSRS     r2,r0,#28             ;163
00001e  d0fb              BEQ      |L10.24|
                  |L10.32|
000020  f1c10408          RSB      r4,r1,#8              ;169
000024  1e26              SUBS     r6,r4,#0              ;170
000026  dd0f              BLE      |L10.72|
                  |L10.40|
000028  4620              MOV      r0,r4                 ;173
00002a  1e64              SUBS     r4,r4,#1              ;173
00002c  0080              LSLS     r0,r0,#2
00002e  1f00              SUBS     r0,r0,#4
000030  fa25f000          LSR      r0,r5,r0              ;174
000034  f000000f          AND      r0,r0,#0xf            ;174
000038  280a              CMP      r0,#0xa               ;175
00003a  bf34              ITE      CC                    ;175
00003c  3030              ADDCC    r0,r0,#0x30           ;175
00003e  3037              ADDCS    r0,r0,#0x37           ;175
000040  f7fffffe          BL       RMP_Putchar
000044  2c00              CMP      r4,#0                 ;171
000046  dcef              BGT      |L10.40|
                  |L10.72|
000048  4630              MOV      r0,r6                 ;182
00004a  bd70              POP      {r4-r6,pc}
;;;184    /* End Function:RMP_Print_Uint ***********************************************/
                          ENDP


                          AREA ||i.RMP_Save_Ctx||, CODE, READONLY, ALIGN=1

                  RMP_Save_Ctx PROC
;;;1460   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1461   void RMP_Save_Ctx(void)
000000  4770              BX       lr
;;;1462   {
;;;1463       return;
;;;1464   }
;;;1465   #endif
                          ENDP


                          AREA ||i.RMP_Sem_Abort||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Abort PROC
;;;1288   ******************************************************************************/
;;;1289   ret_t RMP_Sem_Abort(volatile struct RMP_Thd* Thread)
000000  2800              CMP      r0,#0
;;;1290   {
;;;1291       /* Check if this thread structure could possibly be in use */
;;;1292       if(Thread==0)
;;;1293           return RMP_ERR_THD;
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;1294   
;;;1295       RMP_Lock_Sched();
;;;1296       
;;;1297       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;1298       {
;;;1299           RMP_Unlock_Sched();
;;;1300           return RMP_ERR_THD;
;;;1301       }
;;;1302       
;;;1303       /* Is it waiting on a semaphore? If no, we abort and return an error code */
;;;1304       if((RMP_THD_STATE(Thread->State)!=RMP_THD_SEMBLK)&&
;;;1305          (RMP_THD_STATE(Thread->State)!=RMP_THD_SEMDLY))
;;;1306       {
;;;1307           RMP_Unlock_Sched();
;;;1308           return RMP_ERR_STATE;
;;;1309       }
;;;1310   
;;;1311       /* Waiting for a semaphore. We abort it and return */
;;;1312       RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1313       if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1314           RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1315       
;;;1316       RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1317   
;;;1318       /* Only when when this thread is not suspended do we change it back */
;;;1319       if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1320           _RMP_Set_Rdy(Thread);
;;;1321       
;;;1322       Thread->Retval=RMP_ERR_OPER;
;;;1323       
;;;1324       RMP_Unlock_Sched();
;;;1325   
;;;1326       return 0;
;;;1327   }
000008  4770              BXEQ     lr
00000a  b510              PUSH     {r4,lr}               ;1290
00000c  4604              MOV      r4,r0                 ;1290
00000e  481e              LDR      r0,|L12.136|
000010  2101              MOVS     r1,#1                 ;1290
000012  60c1              STR      r1,[r0,#0xc]          ;1290  ; RMP_Sched_Locked
000014  6881              LDR      r1,[r0,#8]            ;1290  ; RMP_Sched_Lock_Cnt
000016  1c49              ADDS     r1,r1,#1              ;1290
000018  6081              STR      r1,[r0,#8]            ;1290  ; RMP_Sched_Lock_Cnt
00001a  69a0              LDR      r0,[r4,#0x18]         ;1297
00001c  f0100fff          TST      r0,#0xff              ;1297
000020  d00c              BEQ      |L12.60|
000022  69a0              LDR      r0,[r4,#0x18]         ;1304
000024  b2c0              UXTB     r0,r0                 ;1304
000026  2807              CMP      r0,#7                 ;1304
000028  d00d              BEQ      |L12.70|
00002a  69a0              LDR      r0,[r4,#0x18]         ;1305
00002c  b2c0              UXTB     r0,r0                 ;1305
00002e  2808              CMP      r0,#8                 ;1305
000030  d009              BEQ      |L12.70|
000032  f7fffffe          BL       RMP_Unlock_Sched
000036  f06f0003          MVN      r0,#3                 ;1308
00003a  bd10              POP      {r4,pc}
                  |L12.60|
00003c  f7fffffe          BL       RMP_Unlock_Sched
000040  f04f30ff          MOV      r0,#0xffffffff        ;1300
000044  bd10              POP      {r4,pc}
                  |L12.70|
000046  6820              LDR      r0,[r4,#0]            ;1312
000048  6861              LDR      r1,[r4,#4]            ;1312
00004a  6008              STR      r0,[r1,#0]            ;1312
00004c  6041              STR      r1,[r0,#4]            ;1312
00004e  69a0              LDR      r0,[r4,#0x18]         ;1313
000050  b2c0              UXTB     r0,r0                 ;1313
000052  2808              CMP      r0,#8                 ;1313
000054  d103              BNE      |L12.94|
000056  68a1              LDR      r1,[r4,#8]            ;1314
000058  68e0              LDR      r0,[r4,#0xc]          ;1314
00005a  6001              STR      r1,[r0,#0]            ;1314
00005c  6048              STR      r0,[r1,#4]            ;1314
                  |L12.94|
00005e  69a0              LDR      r0,[r4,#0x18]         ;1316
000060  f02000ff          BIC      r0,r0,#0xff           ;1316
000064  f0400001          ORR      r0,r0,#1              ;1316
000068  61a0              STR      r0,[r4,#0x18]         ;1316
00006a  69a0              LDR      r0,[r4,#0x18]         ;1319
00006c  f4107f80          TST      r0,#0x100             ;1319
000070  bf04              ITT      EQ                    ;1320
000072  4620              MOVEQ    r0,r4                 ;1320
000074  f7fffffe          BLEQ     _RMP_Set_Rdy
000078  f06f0004          MVN      r0,#4                 ;1322
00007c  63a0              STR      r0,[r4,#0x38]         ;1322
00007e  f7fffffe          BL       RMP_Unlock_Sched
000082  2000              MOVS     r0,#0                 ;1326
000084  bd10              POP      {r4,pc}
;;;1328   /* End Function:RMP_Sem_Abort ************************************************/
                          ENDP

000086  0000              DCW      0x0000
                  |L12.136|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Crt||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Crt PROC
;;;1146   ******************************************************************************/
;;;1147   ret_t RMP_Sem_Crt(volatile struct RMP_Sem* Semaphore, ptr_t Number)
000000  b510              PUSH     {r4,lr}
;;;1148   {
;;;1149       /* Check if this semaphore structure could possibly be in use */
;;;1150       if(Semaphore==0)
000002  2800              CMP      r0,#0
;;;1151           return RMP_ERR_SEM;
000004  bf04              ITT      EQ
000006  f06f0005          MVNEQ    r0,#5
;;;1152       
;;;1153       RMP_Lock_Sched();
;;;1154       
;;;1155       if(Semaphore->State!=RMP_SEM_FREE)
;;;1156       {
;;;1157           RMP_Unlock_Sched();
;;;1158           return RMP_ERR_SEM;
;;;1159       }
;;;1160       
;;;1161       /* Is the number too great to initialize? */
;;;1162       if(Number>=RMP_SEM_MAX_NUM)
;;;1163       {
;;;1164           RMP_Unlock_Sched();
;;;1165           return RMP_ERR_OPER;
;;;1166       }
;;;1167   
;;;1168       /* Initialize contents */
;;;1169       Semaphore->Cur_Num=Number;
;;;1170       Semaphore->State=RMP_SEM_USED;
;;;1171       RMP_List_Crt(&(Semaphore->Wait_List));
;;;1172       
;;;1173       RMP_Unlock_Sched();
;;;1174       
;;;1175       return 0;
;;;1176   }
00000a  bd10              POPEQ    {r4,pc}
00000c  2301              MOVS     r3,#1
00000e  4a0f              LDR      r2,|L13.76|
000010  60d3              STR      r3,[r2,#0xc]  ; RMP_Sched_Locked
000012  f8d2c008          LDR      r12,[r2,#8]  ; RMP_Sched_Lock_Cnt
000016  f10c0c01          ADD      r12,r12,#1
00001a  f8c2c008          STR      r12,[r2,#8]  ; RMP_Sched_Lock_Cnt
00001e  6882              LDR      r2,[r0,#8]            ;1155
000020  b122              CBZ      r2,|L13.44|
000022  f7fffffe          BL       RMP_Unlock_Sched
000026  f06f0005          MVN      r0,#5                 ;1158
00002a  bd10              POP      {r4,pc}
                  |L13.44|
00002c  f5b17f7a          CMP      r1,#0x3e8             ;1162
000030  d304              BCC      |L13.60|
000032  f7fffffe          BL       RMP_Unlock_Sched
000036  f06f0004          MVN      r0,#4                 ;1165
00003a  bd10              POP      {r4,pc}
                  |L13.60|
00003c  60c1              STR      r1,[r0,#0xc]          ;1169
00003e  6083              STR      r3,[r0,#8]            ;1170
000040  6000              STR      r0,[r0,#0]            ;1170
000042  6040              STR      r0,[r0,#4]            ;1170
000044  f7fffffe          BL       RMP_Unlock_Sched
000048  2000              MOVS     r0,#0                 ;1175
00004a  bd10              POP      {r4,pc}
;;;1177   /* End Function:RMP_Sem_Crt **************************************************/
                          ENDP

                  |L13.76|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Del||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Del PROC
;;;1184   ******************************************************************************/
;;;1185   ret_t RMP_Sem_Del(volatile struct RMP_Sem* Semaphore)
000000  2800              CMP      r0,#0
;;;1186   {
;;;1187       struct RMP_Thd* Thread;
;;;1188       
;;;1189       /* Check if this semaphore structure could possibly be in use */
;;;1190       if(Semaphore==0)
;;;1191           return RMP_ERR_SEM;
000002  bf04              ITT      EQ
000004  f06f0005          MVNEQ    r0,#5
;;;1192       
;;;1193       RMP_Lock_Sched();
;;;1194       
;;;1195       if(Semaphore->State!=RMP_SEM_USED)
;;;1196       {
;;;1197           RMP_Unlock_Sched();
;;;1198           return RMP_ERR_SEM;
;;;1199       }
;;;1200   
;;;1201       /* Get rid of all guys waiting on it */
;;;1202       while(&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)
;;;1203       {
;;;1204           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1205           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1206           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1207               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1208   
;;;1209           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1210   
;;;1211           /* Is it suspended? If yes, we can't directly send it running */
;;;1212           if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1213              _RMP_Set_Rdy(Thread);
;;;1214           
;;;1215           Thread->Retval=RMP_ERR_OPER;
;;;1216       }
;;;1217       Semaphore->State=RMP_SEM_FREE;
;;;1218       
;;;1219       RMP_Unlock_Sched();
;;;1220   
;;;1221       return 0;
;;;1222   }
000008  4770              BXEQ     lr
00000a  b570              PUSH     {r4-r6,lr}            ;1186
00000c  4605              MOV      r5,r0                 ;1186
00000e  481b              LDR      r0,|L14.124|
000010  2101              MOVS     r1,#1                 ;1186
000012  60c1              STR      r1,[r0,#0xc]          ;1186  ; RMP_Sched_Locked
000014  6881              LDR      r1,[r0,#8]            ;1186  ; RMP_Sched_Lock_Cnt
000016  1c49              ADDS     r1,r1,#1              ;1186
000018  6081              STR      r1,[r0,#8]            ;1186  ; RMP_Sched_Lock_Cnt
00001a  68a8              LDR      r0,[r5,#8]            ;1195
00001c  2801              CMP      r0,#1                 ;1195
00001e  d004              BEQ      |L14.42|
000020  f7fffffe          BL       RMP_Unlock_Sched
000024  f06f0005          MVN      r0,#5                 ;1198
000028  bd70              POP      {r4-r6,pc}
                  |L14.42|
00002a  6868              LDR      r0,[r5,#4]            ;1202
00002c  42a8              CMP      r0,r5                 ;1202
00002e  bf18              IT       NE                    ;1215
000030  f06f0604          MVNNE    r6,#4                 ;1215
000034  d01b              BEQ      |L14.110|
                  |L14.54|
000036  686c              LDR      r4,[r5,#4]            ;1204
000038  e9d40100          LDRD     r0,r1,[r4,#0]         ;1204
00003c  6008              STR      r0,[r1,#0]            ;1204
00003e  6041              STR      r1,[r0,#4]            ;1204
000040  7e20              LDRB     r0,[r4,#0x18]         ;1206
000042  2808              CMP      r0,#8                 ;1206
000044  d103              BNE      |L14.78|
000046  e9d40102          LDRD     r0,r1,[r4,#8]         ;1206
00004a  6008              STR      r0,[r1,#0]            ;1206
00004c  6041              STR      r1,[r0,#4]            ;1206
                  |L14.78|
00004e  69a0              LDR      r0,[r4,#0x18]         ;1209
000050  f02000ff          BIC      r0,r0,#0xff           ;1209
000054  f0400001          ORR      r0,r0,#1              ;1209
000058  f4107f80          TST      r0,#0x100             ;1212
00005c  61a0              STR      r0,[r4,#0x18]         ;1212
00005e  bf04              ITT      EQ                    ;1213
000060  4620              MOVEQ    r0,r4                 ;1213
000062  f7fffffe          BLEQ     _RMP_Set_Rdy
000066  63a6              STR      r6,[r4,#0x38]         ;1202
000068  6868              LDR      r0,[r5,#4]            ;1202
00006a  42a8              CMP      r0,r5                 ;1202
00006c  d1e3              BNE      |L14.54|
                  |L14.110|
00006e  2000              MOVS     r0,#0                 ;1217
000070  60a8              STR      r0,[r5,#8]            ;1217
000072  f7fffffe          BL       RMP_Unlock_Sched
000076  2000              MOVS     r0,#0                 ;1221
000078  bd70              POP      {r4-r6,pc}
;;;1223   /* End Function:RMP_Sem_Del **************************************************/
                          ENDP

00007a  0000              DCW      0x0000
                  |L14.124|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Pend||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Pend PROC
;;;1231   ******************************************************************************/
;;;1232   ret_t RMP_Sem_Pend(volatile struct RMP_Sem* Semaphore, ptr_t Slices)
000000  2800              CMP      r0,#0
;;;1233   {
;;;1234       /* Check if this semaphore structure could possibly be in use */
;;;1235       if(Semaphore==0)
;;;1236           return RMP_ERR_SEM;
000002  bf04              ITT      EQ
000004  f06f0005          MVNEQ    r0,#5
;;;1237       
;;;1238       RMP_Lock_Sched();
;;;1239       
;;;1240       if(Semaphore->State!=RMP_SEM_USED)
;;;1241       {
;;;1242           RMP_Unlock_Sched();
;;;1243           return RMP_ERR_SEM;
;;;1244       }
;;;1245       
;;;1246       /* Check if we can get one immediately */
;;;1247       if(Semaphore->Cur_Num!=0)
;;;1248       {
;;;1249           Semaphore->Cur_Num--;
;;;1250           RMP_Unlock_Sched();
;;;1251           return Semaphore->Cur_Num;
;;;1252       }
;;;1253       else
;;;1254       {
;;;1255           /* Cannot get one, we need to block */
;;;1256           if(Slices==0)
;;;1257           {
;;;1258               RMP_Unlock_Sched();
;;;1259               return RMP_ERR_OPER;
;;;1260           }
;;;1261   
;;;1262           /* We must be running - place into waitlist now */
;;;1263           _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1264           RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Semaphore->Wait_List.Prev,&(Semaphore->Wait_List));
;;;1265           
;;;1266           if(Slices<RMP_MAX_SLICES)
;;;1267           {
;;;1268               _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1269               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMDLY);
;;;1270           }
;;;1271           else
;;;1272               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMBLK);
;;;1273           
;;;1274           RMP_Cur_Thd->Retval=0;
;;;1275       }
;;;1276       
;;;1277       RMP_Unlock_Sched();
;;;1278   
;;;1279       return RMP_Cur_Thd->Retval;
;;;1280   }
000008  4770              BXEQ     lr
00000a  b570              PUSH     {r4-r6,lr}            ;1233
00000c  4c30              LDR      r4,|L15.208|
00000e  4605              MOV      r5,r0                 ;1233
000010  2001              MOVS     r0,#1                 ;1233
000012  460e              MOV      r6,r1                 ;1233
000014  60e0              STR      r0,[r4,#0xc]          ;1233  ; RMP_Sched_Locked
000016  68a0              LDR      r0,[r4,#8]            ;1233  ; RMP_Sched_Lock_Cnt
000018  1c40              ADDS     r0,r0,#1              ;1233
00001a  60a0              STR      r0,[r4,#8]            ;1233  ; RMP_Sched_Lock_Cnt
00001c  68a8              LDR      r0,[r5,#8]            ;1240
00001e  2801              CMP      r0,#1                 ;1240
000020  d004              BEQ      |L15.44|
000022  f7fffffe          BL       RMP_Unlock_Sched
000026  f06f0005          MVN      r0,#5                 ;1243
00002a  bd70              POP      {r4-r6,pc}
                  |L15.44|
00002c  68e8              LDR      r0,[r5,#0xc]          ;1247
00002e  b130              CBZ      r0,|L15.62|
000030  68e8              LDR      r0,[r5,#0xc]          ;1249
000032  1e40              SUBS     r0,r0,#1              ;1249
000034  60e8              STR      r0,[r5,#0xc]          ;1249
000036  f7fffffe          BL       RMP_Unlock_Sched
00003a  68e8              LDR      r0,[r5,#0xc]          ;1251
00003c  bd70              POP      {r4-r6,pc}
                  |L15.62|
00003e  b38e              CBZ      r6,|L15.164|
000040  69a0              LDR      r0,[r4,#0x18]         ;1263  ; RMP_Cur_Thd
000042  f7fffffe          BL       _RMP_Clr_Rdy
000046  69a0              LDR      r0,[r4,#0x18]         ;1264  ; RMP_Cur_Thd
000048  6829              LDR      r1,[r5,#0]            ;1264
00004a  6028              STR      r0,[r5,#0]            ;1264
00004c  6045              STR      r5,[r0,#4]            ;1264
00004e  6001              STR      r1,[r0,#0]            ;1264
000050  6048              STR      r0,[r1,#4]            ;1264
000052  4820              LDR      r0,|L15.212|
000054  4286              CMP      r6,r0                 ;1266
000056  d22b              BCS      |L15.176|
000058  f8d4c018          LDR      r12,[r4,#0x18]        ;1268  ; RMP_Cur_Thd
00005c  491e              LDR      r1,|L15.216|
00005e  6848              LDR      r0,[r1,#4]            ;1268  ; RMP_Delay
000060  4288              CMP      r0,r1                 ;1268
000062  bf1c              ITT      NE                    ;1268
000064  f1a00208          SUBNE    r2,r0,#8              ;1268
000068  6a03              LDRNE    r3,[r0,#0x20]         ;1268
00006a  d005              BEQ      |L15.120|
                  |L15.108|
00006c  6862              LDR      r2,[r4,#4]            ;1268  ; RMP_Tick
00006e  1a9a              SUBS     r2,r3,r2              ;1268
000070  42b2              CMP      r2,r6                 ;1268
000072  d801              BHI      |L15.120|
000074  4288              CMP      r0,r1                 ;1268
000076  d1f9              BNE      |L15.108|
                  |L15.120|
000078  6861              LDR      r1,[r4,#4]            ;1268  ; RMP_Tick
00007a  4431              ADD      r1,r1,r6              ;1268
00007c  f8cc1028          STR      r1,[r12,#0x28]        ;1268
000080  f10c0108          ADD      r1,r12,#8             ;1268
000084  6802              LDR      r2,[r0,#0]            ;1268
000086  6001              STR      r1,[r0,#0]            ;1268
000088  f8cc000c          STR      r0,[r12,#0xc]         ;1268
00008c  f8cc2008          STR      r2,[r12,#8]           ;1268
000090  6051              STR      r1,[r2,#4]            ;1268
000092  69a0              LDR      r0,[r4,#0x18]         ;1269  ; RMP_Cur_Thd
000094  69a1              LDR      r1,[r4,#0x18]         ;1269  ; RMP_Cur_Thd
000096  6980              LDR      r0,[r0,#0x18]         ;1269
000098  f02000ff          BIC      r0,r0,#0xff           ;1269
00009c  f0400008          ORR      r0,r0,#8              ;1269
0000a0  6188              STR      r0,[r1,#0x18]         ;1269
0000a2  e00d              B        |L15.192|
                  |L15.164|
0000a4  e7ff              B        |L15.166|
                  |L15.166|
0000a6  f7fffffe          BL       RMP_Unlock_Sched
0000aa  f06f0004          MVN      r0,#4                 ;1259
0000ae  bd70              POP      {r4-r6,pc}
                  |L15.176|
0000b0  69a0              LDR      r0,[r4,#0x18]         ;1272  ; RMP_Cur_Thd
0000b2  69a1              LDR      r1,[r4,#0x18]         ;1272  ; RMP_Cur_Thd
0000b4  6980              LDR      r0,[r0,#0x18]         ;1272
0000b6  f02000ff          BIC      r0,r0,#0xff           ;1272
0000ba  f0400007          ORR      r0,r0,#7              ;1272
0000be  6188              STR      r0,[r1,#0x18]         ;1272
                  |L15.192|
0000c0  69a1              LDR      r1,[r4,#0x18]         ;1274  ; RMP_Cur_Thd
0000c2  2000              MOVS     r0,#0                 ;1274
0000c4  6388              STR      r0,[r1,#0x38]         ;1277
0000c6  f7fffffe          BL       RMP_Unlock_Sched
0000ca  69a0              LDR      r0,[r4,#0x18]         ;1279  ; RMP_Cur_Thd
0000cc  6b80              LDR      r0,[r0,#0x38]         ;1279
0000ce  bd70              POP      {r4-r6,pc}
;;;1281   /* End Function:RMP_Sem_Pend *************************************************/
                          ENDP

                  |L15.208|
                          DCD      ||.data||
                  |L15.212|
                          DCD      0x000186a0
                  |L15.216|
                          DCD      ||.data||+0x20

                          AREA ||i.RMP_Sem_Post||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Post PROC
;;;1338   ******************************************************************************/
;;;1339   ret_t RMP_Sem_Post(volatile struct RMP_Sem* Semaphore, ptr_t Number)
000000  2800              CMP      r0,#0
;;;1340   {
;;;1341       struct RMP_Thd* Thread;
;;;1342       
;;;1343       /* Check if this semaphore structure could possibly be in use */
;;;1344       if((Semaphore==0)||(Number==0))
000002  bf12              ITEE     NE
000004  2900              CMPNE    r1,#0
;;;1345           return RMP_ERR_SEM;
000006  f06f0005          MVNEQ    r0,#5
;;;1346       
;;;1347       RMP_Lock_Sched();
;;;1348       
;;;1349       if(Semaphore->State!=RMP_SEM_USED)
;;;1350       {
;;;1351           RMP_Unlock_Sched();
;;;1352           return RMP_ERR_SEM;
;;;1353       }
;;;1354       
;;;1355       /* Would the maximum value be exceeded if this is posted? */
;;;1356       if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
;;;1357       {
;;;1358           RMP_Unlock_Sched();
;;;1359           return RMP_ERR_OPER;
;;;1360       }
;;;1361       
;;;1362       Semaphore->Cur_Num+=Number;
;;;1363       /* Is there any thread waiting on it? If there are, clean them up*/
;;;1364       while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
;;;1365       {
;;;1366           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1367           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1368           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1369               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1370           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1371   
;;;1372           /* Only when when this thread is not suspended do we change it back */
;;;1373           if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1374               _RMP_Set_Rdy(Thread);
;;;1375   
;;;1376           /* Finally, return success */
;;;1377           Thread->Retval=0;
;;;1378           Semaphore->Cur_Num--;
;;;1379       }
;;;1380   
;;;1381       RMP_Unlock_Sched();
;;;1382   
;;;1383       return 0;
;;;1384   }
00000a  4770              BXEQ     lr
00000c  b570              PUSH     {r4-r6,lr}            ;1340
00000e  4604              MOV      r4,r0                 ;1340
000010  4821              LDR      r0,|L16.152|
000012  2201              MOVS     r2,#1                 ;1340
000014  60c2              STR      r2,[r0,#0xc]          ;1340  ; RMP_Sched_Locked
000016  6882              LDR      r2,[r0,#8]            ;1340  ; RMP_Sched_Lock_Cnt
000018  1c52              ADDS     r2,r2,#1              ;1340
00001a  6082              STR      r2,[r0,#8]            ;1340  ; RMP_Sched_Lock_Cnt
00001c  68a0              LDR      r0,[r4,#8]            ;1349
00001e  2801              CMP      r0,#1                 ;1349
000020  d004              BEQ      |L16.44|
000022  f7fffffe          BL       RMP_Unlock_Sched
000026  f06f0005          MVN      r0,#5                 ;1352
00002a  bd70              POP      {r4-r6,pc}
                  |L16.44|
00002c  68e0              LDR      r0,[r4,#0xc]          ;1356
00002e  4408              ADD      r0,r0,r1              ;1356
000030  f5b07f7a          CMP      r0,#0x3e8             ;1356
000034  d304              BCC      |L16.64|
000036  f7fffffe          BL       RMP_Unlock_Sched
00003a  f06f0004          MVN      r0,#4                 ;1359
00003e  bd70              POP      {r4-r6,pc}
                  |L16.64|
000040  68e0              LDR      r0,[r4,#0xc]          ;1362
000042  4408              ADD      r0,r0,r1              ;1362
000044  60e0              STR      r0,[r4,#0xc]          ;1362
000046  2600              MOVS     r6,#0                 ;1362
                  |L16.72|
000048  6860              LDR      r0,[r4,#4]            ;1364
00004a  42a0              CMP      r0,r4                 ;1364
00004c  bf1c              ITT      NE                    ;1364
00004e  68e0              LDRNE    r0,[r4,#0xc]          ;1364
000050  2800              CMPNE    r0,#0                 ;1364
000052  d01c              BEQ      |L16.142|
000054  6865              LDR      r5,[r4,#4]            ;1366
000056  e9d50100          LDRD     r0,r1,[r5,#0]         ;1366
00005a  6008              STR      r0,[r1,#0]            ;1366
00005c  6041              STR      r1,[r0,#4]            ;1366
00005e  7e28              LDRB     r0,[r5,#0x18]         ;1368
000060  2808              CMP      r0,#8                 ;1368
000062  d103              BNE      |L16.108|
000064  e9d50102          LDRD     r0,r1,[r5,#8]         ;1368
000068  6008              STR      r0,[r1,#0]            ;1368
00006a  6041              STR      r1,[r0,#4]            ;1368
                  |L16.108|
00006c  69a8              LDR      r0,[r5,#0x18]         ;1370
00006e  f02000ff          BIC      r0,r0,#0xff           ;1370
000072  f0400001          ORR      r0,r0,#1              ;1370
000076  f4107f80          TST      r0,#0x100             ;1373
00007a  61a8              STR      r0,[r5,#0x18]         ;1373
00007c  bf04              ITT      EQ                    ;1374
00007e  4628              MOVEQ    r0,r5                 ;1374
000080  f7fffffe          BLEQ     _RMP_Set_Rdy
000084  63ae              STR      r6,[r5,#0x38]         ;1378
000086  68e0              LDR      r0,[r4,#0xc]          ;1378
000088  1e40              SUBS     r0,r0,#1              ;1378
00008a  60e0              STR      r0,[r4,#0xc]          ;1378
00008c  e7dc              B        |L16.72|
                  |L16.142|
00008e  f7fffffe          BL       RMP_Unlock_Sched
000092  2000              MOVS     r0,#0                 ;1383
000094  bd70              POP      {r4-r6,pc}
;;;1385   /* End Function:RMP_Sem_Post *************************************************/
                          ENDP

000096  0000              DCW      0x0000
                  |L16.152|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Post_ISR||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Post_ISR PROC
;;;1393   ******************************************************************************/
;;;1394   ret_t RMP_Sem_Post_ISR(volatile struct RMP_Sem* Semaphore, ptr_t Number)
000000  2800              CMP      r0,#0
;;;1395   {
;;;1396       struct RMP_Thd* Thread;
;;;1397       /* Check if this semaphore structure could possibly be in use */
;;;1398       if((Semaphore==0)||(Number==0))
000002  bf12              ITEE     NE
000004  2900              CMPNE    r1,#0
;;;1399           return RMP_ERR_SEM;
000006  f06f0005          MVNEQ    r0,#5
;;;1400       
;;;1401       if(Semaphore->State!=RMP_SEM_USED)
;;;1402           return RMP_ERR_SEM;
;;;1403   
;;;1404       if(RMP_Sched_Locked!=0)
;;;1405           return RMP_ERR_OPER;
;;;1406   
;;;1407       /* Would the maximum value be exceeded if this is posted? */
;;;1408       if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
;;;1409           return RMP_ERR_OPER;
;;;1410       
;;;1411       Semaphore->Cur_Num+=Number;
;;;1412       /* Is there any thread waiting on it? If there are, clean them up*/
;;;1413       while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
;;;1414       {
;;;1415           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1416           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1417           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1418               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1419           
;;;1420           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1421   
;;;1422           /* Only when when this thread is not suspended do we change it back */
;;;1423           if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1424           {
;;;1425               _RMP_Set_Rdy(Thread);
;;;1426               if(Thread->Prio>RMP_Cur_Thd->Prio)
;;;1427                   _RMP_Yield();
;;;1428           }
;;;1429   
;;;1430           /* Finally, return success */
;;;1431           Thread->Retval=0;
;;;1432           Semaphore->Cur_Num--;
;;;1433       }
;;;1434   
;;;1435       return 0;
;;;1436   }
00000a  4770              BXEQ     lr
00000c  e92d41f0          PUSH     {r4-r8,lr}            ;1395
000010  4604              MOV      r4,r0                 ;1395
000012  6880              LDR      r0,[r0,#8]            ;1401
000014  2801              CMP      r0,#1                 ;1401
000016  bf1c              ITT      NE                    ;1402
000018  f06f0005          MVNNE    r0,#5                 ;1402
00001c  e8bd81f0          POPNE    {r4-r8,pc}
000020  4e1e              LDR      r6,|L17.156|
000022  68f0              LDR      r0,[r6,#0xc]          ;1404  ; RMP_Sched_Locked
000024  b920              CBNZ     r0,|L17.48|
000026  68e0              LDR      r0,[r4,#0xc]          ;1408
000028  4408              ADD      r0,r0,r1              ;1408
00002a  f5b07f7a          CMP      r0,#0x3e8             ;1408
00002e  d303              BCC      |L17.56|
                  |L17.48|
000030  f06f0004          MVN      r0,#4                 ;1409
000034  e8bd81f0          POP      {r4-r8,pc}
                  |L17.56|
000038  68e0              LDR      r0,[r4,#0xc]          ;1411
00003a  4408              ADD      r0,r0,r1              ;1411
00003c  60e0              STR      r0,[r4,#0xc]          ;1411
00003e  2700              MOVS     r7,#0                 ;1411
000040  e022              B        |L17.136|
                  |L17.66|
000042  6865              LDR      r5,[r4,#4]            ;1415
000044  e9d50100          LDRD     r0,r1,[r5,#0]         ;1415
000048  6008              STR      r0,[r1,#0]            ;1415
00004a  6041              STR      r1,[r0,#4]            ;1415
00004c  7e28              LDRB     r0,[r5,#0x18]         ;1417
00004e  2808              CMP      r0,#8                 ;1417
000050  d103              BNE      |L17.90|
000052  e9d50102          LDRD     r0,r1,[r5,#8]         ;1417
000056  6008              STR      r0,[r1,#0]            ;1417
000058  6041              STR      r1,[r0,#4]            ;1417
                  |L17.90|
00005a  69a8              LDR      r0,[r5,#0x18]         ;1420
00005c  f02000ff          BIC      r0,r0,#0xff           ;1420
000060  f0400001          ORR      r0,r0,#1              ;1420
000064  f4107f80          TST      r0,#0x100             ;1423
000068  61a8              STR      r0,[r5,#0x18]         ;1423
00006a  d109              BNE      |L17.128|
00006c  4628              MOV      r0,r5                 ;1425
00006e  f7fffffe          BL       _RMP_Set_Rdy
000072  6a68              LDR      r0,[r5,#0x24]         ;1426
000074  69b1              LDR      r1,[r6,#0x18]         ;1426  ; RMP_Cur_Thd
000076  6a49              LDR      r1,[r1,#0x24]         ;1426
000078  4288              CMP      r0,r1                 ;1426
00007a  bf88              IT       HI                    ;1427
00007c  f7fffffe          BLHI     _RMP_Yield
                  |L17.128|
000080  63af              STR      r7,[r5,#0x38]         ;1432
000082  68e0              LDR      r0,[r4,#0xc]          ;1432
000084  1e40              SUBS     r0,r0,#1              ;1432
000086  60e0              STR      r0,[r4,#0xc]          ;1432
                  |L17.136|
000088  6860              LDR      r0,[r4,#4]            ;1413
00008a  42a0              CMP      r0,r4                 ;1413
00008c  bf1c              ITT      NE                    ;1413
00008e  68e0              LDRNE    r0,[r4,#0xc]          ;1413
000090  2800              CMPNE    r0,#0                 ;1413
000092  d1d6              BNE      |L17.66|
000094  2000              MOVS     r0,#0                 ;1435
000096  e8bd81f0          POP      {r4-r8,pc}
;;;1437   /* End Function:RMP_Sem_Post_ISR *********************************************/
                          ENDP

00009a  0000              DCW      0x0000
                  |L17.156|
                          DCD      ||.data||

                          AREA ||i.RMP_Start_Hook||, CODE, READONLY, ALIGN=1

                  RMP_Start_Hook PROC
;;;1446   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1447   void RMP_Start_Hook(void)
000000  4770              BX       lr
;;;1448   {
;;;1449       return;
;;;1450   }
;;;1451   #endif
                          ENDP


                          AREA ||i.RMP_Thd_Cancel||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Cancel PROC
;;;1108   ******************************************************************************/
;;;1109   ret_t RMP_Thd_Cancel(volatile struct RMP_Thd* Thread)
000000  2800              CMP      r0,#0
;;;1110   {
;;;1111       /* Check if this thread structure could possibly be in use */
;;;1112       if(Thread==0)
;;;1113           return RMP_ERR_THD;
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;1114       
;;;1115       RMP_Lock_Sched();
;;;1116       
;;;1117       /* Is it delayed? */
;;;1118       if(RMP_THD_STATE(Thread->State)!=RMP_THD_DELAYED)
;;;1119       {
;;;1120           RMP_Unlock_Sched();
;;;1121           return RMP_ERR_STATE;
;;;1122       }
;;;1123   
;;;1124       /* Delete it from the delay list */
;;;1125       RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1126       RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1127       
;;;1128       /* Only when when this thread is not suspended do we change it back */
;;;1129       if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1130           _RMP_Set_Rdy(Thread);
;;;1131       
;;;1132       Thread->Retval=RMP_ERR_OPER;
;;;1133       
;;;1134       RMP_Unlock_Sched();
;;;1135   
;;;1136       return 0;
;;;1137   }
000008  4770              BXEQ     lr
00000a  b510              PUSH     {r4,lr}               ;1110
00000c  4604              MOV      r4,r0                 ;1110
00000e  4813              LDR      r0,|L19.92|
000010  2101              MOVS     r1,#1                 ;1110
000012  60c1              STR      r1,[r0,#0xc]          ;1110  ; RMP_Sched_Locked
000014  6881              LDR      r1,[r0,#8]            ;1110  ; RMP_Sched_Lock_Cnt
000016  1c49              ADDS     r1,r1,#1              ;1110
000018  6081              STR      r1,[r0,#8]            ;1110  ; RMP_Sched_Lock_Cnt
00001a  69a0              LDR      r0,[r4,#0x18]         ;1118
00001c  b2c0              UXTB     r0,r0                 ;1118
00001e  2806              CMP      r0,#6                 ;1118
000020  d004              BEQ      |L19.44|
000022  f7fffffe          BL       RMP_Unlock_Sched
000026  f06f0003          MVN      r0,#3                 ;1121
00002a  bd10              POP      {r4,pc}
                  |L19.44|
00002c  68a0              LDR      r0,[r4,#8]            ;1125
00002e  68e1              LDR      r1,[r4,#0xc]          ;1125
000030  6008              STR      r0,[r1,#0]            ;1125
000032  6041              STR      r1,[r0,#4]            ;1125
000034  69a0              LDR      r0,[r4,#0x18]         ;1126
000036  f02000ff          BIC      r0,r0,#0xff           ;1126
00003a  f0400001          ORR      r0,r0,#1              ;1126
00003e  61a0              STR      r0,[r4,#0x18]         ;1126
000040  69a0              LDR      r0,[r4,#0x18]         ;1129
000042  f4107f80          TST      r0,#0x100             ;1129
000046  bf04              ITT      EQ                    ;1130
000048  4620              MOVEQ    r0,r4                 ;1130
00004a  f7fffffe          BLEQ     _RMP_Set_Rdy
00004e  f06f0004          MVN      r0,#4                 ;1132
000052  63a0              STR      r0,[r4,#0x38]         ;1132
000054  f7fffffe          BL       RMP_Unlock_Sched
000058  2000              MOVS     r0,#0                 ;1136
00005a  bd10              POP      {r4,pc}
;;;1138   /* End Function:RMP_Thd_Cancel ***********************************************/
                          ENDP

                  |L19.92|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Crt||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Crt PROC
;;;588    ******************************************************************************/
;;;589    ret_t RMP_Thd_Crt(volatile struct RMP_Thd* Thread, void* Entry, void* Stack, void* Arg, ptr_t Prio, ptr_t Slices)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;590    {
000004  4694              MOV      r12,r2
000006  4604              MOV      r4,r0
000008  e9dd2006          LDRD     r2,r0,[sp,#0x18]
00000c  460e              MOV      r6,r1
;;;591        /* Check if the priority and timeslice range is correct */
;;;592        if(Prio>=RMP_MAX_PREEMPT_PRIO)
00000e  2a20              CMP      r2,#0x20
;;;593            return RMP_ERR_PRIO;
000010  bf24              ITT      CS
000012  f06f0001          MVNCS    r0,#1
;;;594        if((Slices==0)||(Slices>=RMP_MAX_SLICES))
;;;595            return RMP_ERR_SLICE;
;;;596        
;;;597        /* Check if this thread structure could possibly be in use */
;;;598        if(Thread==0)
;;;599            return RMP_ERR_THD;
;;;600        
;;;601        RMP_Lock_Sched();
;;;602        
;;;603        if(RMP_THD_STATE(Thread->State)!=RMP_THD_FREE)
;;;604        {
;;;605            RMP_Unlock_Sched();
;;;606            return RMP_ERR_THD;
;;;607        }
;;;608        
;;;609        /* Create the thread and insert it into the list */
;;;610        Thread->Prio=Prio;
;;;611        Thread->Slices=Slices;
;;;612        Thread->Slices_Left=Slices;
;;;613        Thread->Stack=(ptr_t)Stack;
;;;614        
;;;615        /* Initialize its stack and sending list */
;;;616        _RMP_Stack_Init((ptr_t)Entry, (ptr_t)Stack, (ptr_t)Arg);
;;;617        RMP_List_Crt(&(Thread->Snd_List));
;;;618        
;;;619        /* Notify the scheduler that we have created something new, also check locks */
;;;620        Thread->State=RMP_THD_RUNNING;
;;;621        _RMP_Set_Rdy(Thread);
;;;622        
;;;623        RMP_Unlock_Sched();
;;;624    
;;;625        return 0;
;;;626    }
000016  e8bd81f0          POPCS    {r4-r8,pc}
00001a  2800              CMP      r0,#0                 ;594
00001c  bf1c              ITT      NE                    ;594
00001e  4919              LDRNE    r1,|L20.132|
000020  4288              CMPNE    r0,r1                 ;594
000022  bf24              ITT      CS                    ;595
000024  f06f0002          MVNCS    r0,#2                 ;595
000028  e8bd81f0          POPCS    {r4-r8,pc}
00002c  2c00              CMP      r4,#0                 ;598
00002e  bf04              ITT      EQ                    ;599
000030  f04f30ff          MOVEQ    r0,#0xffffffff        ;599
000034  e8bd81f0          POPEQ    {r4-r8,pc}
000038  2501              MOVS     r5,#1
00003a  4913              LDR      r1,|L20.136|
00003c  60cd              STR      r5,[r1,#0xc]  ; RMP_Sched_Locked
00003e  688f              LDR      r7,[r1,#8]  ; RMP_Sched_Lock_Cnt
000040  1c7f              ADDS     r7,r7,#1
000042  608f              STR      r7,[r1,#8]  ; RMP_Sched_Lock_Cnt
000044  69a1              LDR      r1,[r4,#0x18]         ;603
000046  f0110fff          TST      r1,#0xff              ;603
00004a  d004              BEQ      |L20.86|
00004c  f7fffffe          BL       RMP_Unlock_Sched
000050  1ea8              SUBS     r0,r5,#2              ;606
000052  e8bd81f0          POP      {r4-r8,pc}
                  |L20.86|
000056  6262              STR      r2,[r4,#0x24]         ;610
000058  61e0              STR      r0,[r4,#0x1c]         ;611
00005a  6220              STR      r0,[r4,#0x20]         ;612
00005c  f8c4c034          STR      r12,[r4,#0x34]        ;613
000060  461a              MOV      r2,r3                 ;616
000062  4661              MOV      r1,r12                ;616
000064  4630              MOV      r0,r6                 ;616
000066  f7fffffe          BL       _RMP_Stack_Init
00006a  f1040010          ADD      r0,r4,#0x10           ;617
00006e  6120              STR      r0,[r4,#0x10]         ;617
000070  6160              STR      r0,[r4,#0x14]         ;617
000072  61a5              STR      r5,[r4,#0x18]         ;620
000074  4620              MOV      r0,r4                 ;621
000076  f7fffffe          BL       _RMP_Set_Rdy
00007a  f7fffffe          BL       RMP_Unlock_Sched
00007e  2000              MOVS     r0,#0                 ;625
000080  e8bd81f0          POP      {r4-r8,pc}
;;;627    /* End Function:RMP_Thd_Crt **************************************************/
                          ENDP

                  |L20.132|
                          DCD      0x000186a0
                  |L20.136|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Del||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Del PROC
;;;634    ******************************************************************************/
;;;635    ret_t RMP_Thd_Del(volatile struct RMP_Thd* Thread)
000000  2800              CMP      r0,#0
;;;636    {
;;;637        struct RMP_Thd* Release;
;;;638        ptr_t Self_Del;
;;;639        
;;;640        /* Check if this thread structure could possibly be in use */
;;;641        if(Thread==0)
;;;642            return RMP_ERR_THD;
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;643        
;;;644        RMP_Lock_Sched();
;;;645        
;;;646        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;647        {
;;;648            RMP_Unlock_Sched();
;;;649            return RMP_ERR_THD;
;;;650        }
;;;651        
;;;652        /* See if anyone waiting to send to this thread. If there is, release all these threads */
;;;653        while(&(Thread->Snd_List)!=Thread->Snd_List.Next)
;;;654        {
;;;655            Release=(struct RMP_Thd*)(Thread->Snd_List.Next);
;;;656            RMP_List_Del(Release->Run_Head.Prev,Release->Run_Head.Next);
;;;657            if(RMP_THD_STATE(Release->State)==RMP_THD_SNDDLY)
;;;658                RMP_List_Del(Release->Dly_Head.Prev,Release->Dly_Head.Next);
;;;659    
;;;660            RMP_THD_STATE_SET(Release->State,RMP_THD_RUNNING);
;;;661    
;;;662            /* Is it suspended? If yes, we can't directly send it running */
;;;663            if((Release->State&RMP_THD_SUSPENDED)==0)
;;;664               _RMP_Set_Rdy(Release);
;;;665            
;;;666            Release->Retval=RMP_ERR_OPER;
;;;667        }
;;;668        
;;;669        /* See what is it state */
;;;670        Self_Del=0;
;;;671        if(RMP_Cur_Thd==Thread)
;;;672            Self_Del=1;
;;;673        
;;;674        switch(RMP_THD_STATE(Thread->State))
;;;675        {
;;;676            case RMP_THD_RUNNING:
;;;677            {
;;;678                if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;679                    _RMP_Clr_Rdy(Thread);
;;;680                break;
;;;681            }
;;;682            
;;;683            case RMP_THD_SNDDLY:
;;;684            case RMP_THD_SEMDLY:
;;;685            {
;;;686                if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;687                    RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;688                RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;689                Thread->Retval=RMP_ERR_OPER;
;;;690                break;
;;;691            }
;;;692                
;;;693            case RMP_THD_RCVDLY:
;;;694            {
;;;695                RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;696                Thread->Retval=RMP_ERR_OPER;
;;;697                break;
;;;698            }
;;;699                
;;;700            case RMP_THD_DELAYED:
;;;701            {
;;;702                RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;703                Thread->Retval=RMP_ERR_OPER;
;;;704                break;
;;;705            }
;;;706            /* Should not get here */
;;;707            default:break;
;;;708        }
;;;709        Thread->State=RMP_THD_FREE;
;;;710        
;;;711        RMP_Unlock_Sched();
;;;712        
;;;713        /* If we are deleting ourself, just stop the execution here */
;;;714        if(Self_Del!=0)
;;;715            while(1);
;;;716    
;;;717        return 0;
;;;718    }
000008  4770              BXEQ     lr
00000a  e92d41f0          PUSH     {r4-r8,lr}            ;636
00000e  f8df80e8          LDR      r8,|L21.248|
000012  4604              MOV      r4,r0                 ;636
000014  2001              MOVS     r0,#1                 ;636
000016  f8c8000c          STR      r0,[r8,#0xc]          ;636  ; RMP_Sched_Locked
00001a  f8d80008          LDR      r0,[r8,#8]            ;636  ; RMP_Sched_Lock_Cnt
00001e  1c40              ADDS     r0,r0,#1              ;636
000020  f8c80008          STR      r0,[r8,#8]            ;636  ; RMP_Sched_Lock_Cnt
000024  69a0              LDR      r0,[r4,#0x18]         ;646
000026  f0100fff          TST      r0,#0xff              ;646
00002a  d00f              BEQ      |L21.76|
00002c  6960              LDR      r0,[r4,#0x14]         ;653
00002e  f1040710          ADD      r7,r4,#0x10           ;653
000032  f06f0604          MVN      r6,#4                 ;666
000036  42b8              CMP      r0,r7                 ;653
000038  d022              BEQ      |L21.128|
                  |L21.58|
00003a  6965              LDR      r5,[r4,#0x14]         ;655
00003c  e9d50100          LDRD     r0,r1,[r5,#0]         ;655
000040  6008              STR      r0,[r1,#0]            ;655
000042  6041              STR      r1,[r0,#4]            ;655
000044  7e28              LDRB     r0,[r5,#0x18]         ;657
000046  2803              CMP      r0,#3                 ;657
000048  d10a              BNE      |L21.96|
00004a  e005              B        |L21.88|
                  |L21.76|
00004c  f7fffffe          BL       RMP_Unlock_Sched
000050  f04f30ff          MOV      r0,#0xffffffff        ;649
000054  e8bd81f0          POP      {r4-r8,pc}
                  |L21.88|
000058  e9d50102          LDRD     r0,r1,[r5,#8]
00005c  6008              STR      r0,[r1,#0]
00005e  6041              STR      r1,[r0,#4]
                  |L21.96|
000060  69a8              LDR      r0,[r5,#0x18]         ;660
000062  f02000ff          BIC      r0,r0,#0xff           ;660
000066  f0400001          ORR      r0,r0,#1              ;660
00006a  f4107f80          TST      r0,#0x100             ;663
00006e  61a8              STR      r0,[r5,#0x18]         ;663
000070  bf04              ITT      EQ                    ;664
000072  4628              MOVEQ    r0,r5                 ;664
000074  f7fffffe          BLEQ     _RMP_Set_Rdy
000078  63ae              STR      r6,[r5,#0x38]         ;653
00007a  6960              LDR      r0,[r4,#0x14]         ;653
00007c  42b8              CMP      r0,r7                 ;653
00007e  d1dc              BNE      |L21.58|
                  |L21.128|
000080  f8d80018          LDR      r0,[r8,#0x18]         ;671  ; RMP_Cur_Thd
000084  2500              MOVS     r5,#0                 ;670
000086  42a0              CMP      r0,r4                 ;671
000088  bf08              IT       EQ                    ;672
00008a  2501              MOVEQ    r5,#1                 ;672
00008c  69a0              LDR      r0,[r4,#0x18]         ;674
00008e  b2c0              UXTB     r0,r0                 ;674
000090  2809              CMP      r0,#9                 ;674
000092  d226              BCS      |L21.226|
000094  e8dff000          TBB      [pc,r0]               ;674
000098  2505250d          DCB      0x25,0x05,0x25,0x0d
00009c  251b2025          DCB      0x25,0x1b,0x20,0x25
0000a0  0d00              DCB      0x0d,0x00
0000a2  69a0              LDR      r0,[r4,#0x18]         ;678
0000a4  f4107f80          TST      r0,#0x100             ;678
0000a8  bf04              ITT      EQ                    ;679
0000aa  4620              MOVEQ    r0,r4                 ;679
0000ac  f7fffffe          BLEQ     _RMP_Clr_Rdy
0000b0  e017              B        |L21.226|
0000b2  69a0              LDR      r0,[r4,#0x18]         ;686
0000b4  f4107f80          TST      r0,#0x100             ;686
0000b8  d103              BNE      |L21.194|
0000ba  6820              LDR      r0,[r4,#0]            ;687
0000bc  6861              LDR      r1,[r4,#4]            ;687
0000be  6008              STR      r0,[r1,#0]            ;687
0000c0  6041              STR      r1,[r0,#4]            ;687
                  |L21.194|
0000c2  68a0              LDR      r0,[r4,#8]            ;688
0000c4  68e1              LDR      r1,[r4,#0xc]          ;688
0000c6  6008              STR      r0,[r1,#0]            ;688
0000c8  6041              STR      r1,[r0,#4]            ;688
                  |L21.202|
0000ca  63a6              STR      r6,[r4,#0x38]         ;689
0000cc  e009              B        |L21.226|
0000ce  68a1              LDR      r1,[r4,#8]            ;695
0000d0  68e0              LDR      r0,[r4,#0xc]          ;695
0000d2  6001              STR      r1,[r0,#0]            ;695
0000d4  6048              STR      r0,[r1,#4]            ;695
0000d6  e7f8              B        |L21.202|
0000d8  68a1              LDR      r1,[r4,#8]            ;702
0000da  68e0              LDR      r0,[r4,#0xc]          ;702
0000dc  6001              STR      r1,[r0,#0]            ;702
0000de  6048              STR      r0,[r1,#4]            ;702
0000e0  63a6              STR      r6,[r4,#0x38]         ;703
                  |L21.226|
0000e2  2000              MOVS     r0,#0                 ;709
0000e4  61a0              STR      r0,[r4,#0x18]         ;709
0000e6  f7fffffe          BL       RMP_Unlock_Sched
0000ea  2d00              CMP      r5,#0                 ;714
0000ec  bf04              ITT      EQ                    ;717
0000ee  2000              MOVEQ    r0,#0                 ;717
0000f0  e8bd81f0          POPEQ    {r4-r8,pc}
                  |L21.244|
0000f4  e7fe              B        |L21.244|
;;;719    /* End Function:RMP_Thd_Del **************************************************/
                          ENDP

0000f6  0000              DCW      0x0000
                  |L21.248|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Delay||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Delay PROC
;;;1081   ******************************************************************************/
;;;1082   ret_t RMP_Thd_Delay(ptr_t Slices)
000000  b570              PUSH     {r4-r6,lr}
;;;1083   {
000002  0005              MOVS     r5,r0
;;;1084       if((Slices==0)||(Slices>=RMP_MAX_SLICES))
000004  bf1c              ITT      NE
000006  481e              LDRNE    r0,|L22.128|
000008  42a8              CMPNE    r0,r5
;;;1085           return RMP_ERR_SLICE;
00000a  bf9c              ITT      LS
00000c  f06f0002          MVNLS    r0,#2
;;;1086       
;;;1087       RMP_Lock_Sched();
;;;1088   
;;;1089       /* We must be running */
;;;1090       _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1091       RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_DELAYED);
;;;1092       _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1093   
;;;1094       RMP_Cur_Thd->Retval=0;
;;;1095       
;;;1096       RMP_Unlock_Sched();
;;;1097       
;;;1098       /* Need to return if successful or not */
;;;1099       return RMP_Cur_Thd->Retval;
;;;1100   }
000010  bd70              POPLS    {r4-r6,pc}
000012  2001              MOVS     r0,#1
000014  4c1b              LDR      r4,|L22.132|
000016  60e0              STR      r0,[r4,#0xc]  ; RMP_Sched_Locked
000018  68a0              LDR      r0,[r4,#8]  ; RMP_Sched_Lock_Cnt
00001a  1c40              ADDS     r0,r0,#1
00001c  60a0              STR      r0,[r4,#8]  ; RMP_Sched_Lock_Cnt
00001e  69a0              LDR      r0,[r4,#0x18]         ;1090  ; RMP_Cur_Thd
000020  f7fffffe          BL       _RMP_Clr_Rdy
000024  69a0              LDR      r0,[r4,#0x18]         ;1091  ; RMP_Cur_Thd
000026  69a1              LDR      r1,[r4,#0x18]         ;1091  ; RMP_Cur_Thd
000028  6980              LDR      r0,[r0,#0x18]         ;1091
00002a  f02000ff          BIC      r0,r0,#0xff           ;1091
00002e  f0400006          ORR      r0,r0,#6              ;1091
000032  6188              STR      r0,[r1,#0x18]         ;1092
000034  f8d4c018          LDR      r12,[r4,#0x18]        ;1092  ; RMP_Cur_Thd
000038  f1040020          ADD      r0,r4,#0x20           ;1092
00003c  6841              LDR      r1,[r0,#4]            ;1092  ; RMP_Delay
00003e  4281              CMP      r1,r0                 ;1092
000040  bf1c              ITT      NE                    ;1092
000042  f1a10208          SUBNE    r2,r1,#8              ;1092
000046  6a0a              LDRNE    r2,[r1,#0x20]         ;1092
000048  d005              BEQ      |L22.86|
                  |L22.74|
00004a  6863              LDR      r3,[r4,#4]            ;1092  ; RMP_Tick
00004c  1ad3              SUBS     r3,r2,r3              ;1092
00004e  42ab              CMP      r3,r5                 ;1092
000050  d801              BHI      |L22.86|
000052  4281              CMP      r1,r0                 ;1092
000054  d1f9              BNE      |L22.74|
                  |L22.86|
000056  6860              LDR      r0,[r4,#4]            ;1092  ; RMP_Tick
000058  4428              ADD      r0,r0,r5              ;1092
00005a  f8cc0028          STR      r0,[r12,#0x28]        ;1092
00005e  f10c0008          ADD      r0,r12,#8             ;1092
000062  680a              LDR      r2,[r1,#0]            ;1092
000064  6008              STR      r0,[r1,#0]            ;1092
000066  f8cc100c          STR      r1,[r12,#0xc]         ;1092
00006a  f8cc2008          STR      r2,[r12,#8]           ;1092
00006e  6050              STR      r0,[r2,#4]            ;1092
000070  69a1              LDR      r1,[r4,#0x18]         ;1094  ; RMP_Cur_Thd
000072  2000              MOVS     r0,#0                 ;1094
000074  6388              STR      r0,[r1,#0x38]         ;1096
000076  f7fffffe          BL       RMP_Unlock_Sched
00007a  69a0              LDR      r0,[r4,#0x18]         ;1099  ; RMP_Cur_Thd
00007c  6b80              LDR      r0,[r0,#0x38]         ;1099
00007e  bd70              POP      {r4-r6,pc}
;;;1101   /* End Function:RMP_Thd_Delay ************************************************/
                          ENDP

                  |L22.128|
                          DCD      0x000186a0
                  |L22.132|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Rcv||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Rcv PROC
;;;1002   ******************************************************************************/
;;;1003   ret_t RMP_Thd_Rcv(ptr_t* Data, ptr_t Slices)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1004   {
000004  4c45              LDR      r4,|L23.284|
000006  2701              MOVS     r7,#1
000008  460e              MOV      r6,r1
00000a  4605              MOV      r5,r0
00000c  60e7              STR      r7,[r4,#0xc]  ; RMP_Sched_Locked
00000e  68a0              LDR      r0,[r4,#8]  ; RMP_Sched_Lock_Cnt
000010  1c40              ADDS     r0,r0,#1
000012  60a0              STR      r0,[r4,#8]  ; RMP_Sched_Lock_Cnt
;;;1005       struct RMP_Thd* Sender;
;;;1006       
;;;1007       RMP_Lock_Sched();
;;;1008   
;;;1009       /* Check if there is a value in our mailbox. If yes, we return with that value */
;;;1010       if((RMP_Cur_Thd->State&RMP_THD_MBOXFUL)!=0)
000014  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
000016  8b00              LDRH     r0,[r0,#0x18]
000018  f4107f00          TST      r0,#0x200
;;;1011       {
;;;1012           /* Get the value from mailbox */
;;;1013           *Data=RMP_Cur_Thd->Mailbox;
;;;1014           RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
;;;1015           RMP_Unlock_Sched();
;;;1016           return 0;
;;;1017       }
;;;1018       else
;;;1019       {
;;;1020           /* Is there any other guy waiting on us? If there is, unblock it and set it running */
;;;1021           if(&(RMP_Cur_Thd->Snd_List)!=RMP_Cur_Thd->Snd_List.Next)
00001c  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
00001e  d00b              BEQ      |L23.56|
000020  6ac0              LDR      r0,[r0,#0x2c]         ;1013
000022  6028              STR      r0,[r5,#0]            ;1014
000024  69a0              LDR      r0,[r4,#0x18]         ;1014  ; RMP_Cur_Thd
000026  6981              LDR      r1,[r0,#0x18]         ;1014
000028  f4217100          BIC      r1,r1,#0x200          ;1014
00002c  6181              STR      r1,[r0,#0x18]         ;1015
00002e  f7fffffe          BL       RMP_Unlock_Sched
000032  2000              MOVS     r0,#0                 ;1016
;;;1022           {
;;;1023               /* Read the data */
;;;1024               Sender=(struct RMP_Thd*)(RMP_Cur_Thd->Snd_List.Next);
;;;1025               RMP_List_Del(Sender->Run_Head.Prev,Sender->Run_Head.Next);
;;;1026               *Data=Sender->Data;
;;;1027               /* Now we unblock it - what state is it in? */
;;;1028               if((RMP_THD_STATE(Sender->State)==RMP_THD_SNDDLY))
;;;1029                   RMP_List_Del(Sender->Dly_Head.Prev,Sender->Dly_Head.Next);
;;;1030               
;;;1031               RMP_THD_STATE_SET(Sender->State,RMP_THD_RUNNING);
;;;1032   
;;;1033               /* Is it suspended? If yes, we can't directly send it running */
;;;1034               if((Sender->State&RMP_THD_SUSPENDED)==0)
;;;1035                   _RMP_Set_Rdy(Sender);
;;;1036               
;;;1037               RMP_Unlock_Sched();
;;;1038           }
;;;1039           /* No sender waiting on us, we need to block */
;;;1040           else
;;;1041           {
;;;1042               /* No such value in our mailbox, we need to block */
;;;1043               if(Slices==0)
;;;1044               {
;;;1045                   RMP_Unlock_Sched();
;;;1046                   return RMP_ERR_OPER;
;;;1047               }
;;;1048   
;;;1049               /* We must be running */
;;;1050               _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1051   
;;;1052               if(Slices<RMP_MAX_SLICES)
;;;1053               {
;;;1054                   _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1055                   RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVDLY);
;;;1056               }
;;;1057               else
;;;1058                   RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVBLK);
;;;1059               
;;;1060               RMP_Unlock_Sched();
;;;1061               /* Dummy read - to separate the lock & unlock. If the compiler optimizes these two
;;;1062                * functions(inline them) on some architectures sometimes we never block. */
;;;1063               *Data=RMP_Cur_Thd->Mailbox;
;;;1064               /* We've been unblocked. There must be something in our mbox, or we should have failed */
;;;1065               RMP_Lock_Sched();
;;;1066               *Data=RMP_Cur_Thd->Mailbox;
;;;1067               RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
;;;1068               RMP_Unlock_Sched();
;;;1069           }
;;;1070       }
;;;1071       
;;;1072       return RMP_Cur_Thd->Retval;
;;;1073   }
000034  e8bd81f0          POP      {r4-r8,pc}
                  |L23.56|
000038  6940              LDR      r0,[r0,#0x14]         ;1021
00003a  69a1              LDR      r1,[r4,#0x18]         ;1021  ; RMP_Cur_Thd
00003c  3110              ADDS     r1,r1,#0x10           ;1021
00003e  4288              CMP      r0,r1                 ;1021
000040  d01c              BEQ      |L23.124|
000042  69a0              LDR      r0,[r4,#0x18]         ;1024  ; RMP_Cur_Thd
000044  6940              LDR      r0,[r0,#0x14]         ;1024
000046  e9d01200          LDRD     r1,r2,[r0,#0]         ;1024
00004a  6011              STR      r1,[r2,#0]            ;1024
00004c  604a              STR      r2,[r1,#4]            ;1024
00004e  6b01              LDR      r1,[r0,#0x30]         ;1026
000050  6029              STR      r1,[r5,#0]            ;1028
000052  7e01              LDRB     r1,[r0,#0x18]         ;1028
000054  2903              CMP      r1,#3                 ;1028
000056  d103              BNE      |L23.96|
000058  e9d01202          LDRD     r1,r2,[r0,#8]         ;1028
00005c  6011              STR      r1,[r2,#0]            ;1028
00005e  604a              STR      r2,[r1,#4]            ;1028
                  |L23.96|
000060  6981              LDR      r1,[r0,#0x18]         ;1031
000062  f02101ff          BIC      r1,r1,#0xff           ;1031
000066  f0410101          ORR      r1,r1,#1              ;1031
00006a  f4117f80          TST      r1,#0x100             ;1034
00006e  6181              STR      r1,[r0,#0x18]         ;1034
000070  bf08              IT       EQ                    ;1035
000072  f7fffffe          BLEQ     _RMP_Set_Rdy
000076  f7fffffe          BL       RMP_Unlock_Sched
00007a  e04b              B        |L23.276|
                  |L23.124|
00007c  b34e              CBZ      r6,|L23.210|
00007e  69a0              LDR      r0,[r4,#0x18]         ;1050  ; RMP_Cur_Thd
000080  f7fffffe          BL       _RMP_Clr_Rdy
000084  4826              LDR      r0,|L23.288|
000086  4286              CMP      r6,r0                 ;1052
000088  d229              BCS      |L23.222|
00008a  69a3              LDR      r3,[r4,#0x18]         ;1054  ; RMP_Cur_Thd
00008c  f8dfc094          LDR      r12,|L23.292|
000090  f8dc2004          LDR      r2,[r12,#4]           ;1054  ; RMP_Delay
000094  4562              CMP      r2,r12                ;1054
000096  bf1c              ITT      NE                    ;1054
000098  f1a20008          SUBNE    r0,r2,#8              ;1054
00009c  6a11              LDRNE    r1,[r2,#0x20]         ;1054
00009e  d005              BEQ      |L23.172|
                  |L23.160|
0000a0  6860              LDR      r0,[r4,#4]            ;1054  ; RMP_Tick
0000a2  1a08              SUBS     r0,r1,r0              ;1054
0000a4  42b0              CMP      r0,r6                 ;1054
0000a6  d801              BHI      |L23.172|
0000a8  4562              CMP      r2,r12                ;1054
0000aa  d1f9              BNE      |L23.160|
                  |L23.172|
0000ac  6860              LDR      r0,[r4,#4]            ;1054  ; RMP_Tick
0000ae  4430              ADD      r0,r0,r6              ;1054
0000b0  6298              STR      r0,[r3,#0x28]         ;1054
0000b2  f1030008          ADD      r0,r3,#8              ;1054
0000b6  6811              LDR      r1,[r2,#0]            ;1054
0000b8  6010              STR      r0,[r2,#0]            ;1054
0000ba  60da              STR      r2,[r3,#0xc]          ;1054
0000bc  6099              STR      r1,[r3,#8]            ;1054
0000be  6048              STR      r0,[r1,#4]            ;1054
0000c0  69a0              LDR      r0,[r4,#0x18]         ;1055  ; RMP_Cur_Thd
0000c2  69a1              LDR      r1,[r4,#0x18]         ;1055  ; RMP_Cur_Thd
0000c4  6980              LDR      r0,[r0,#0x18]         ;1055
0000c6  f02000ff          BIC      r0,r0,#0xff           ;1055
0000ca  f0400005          ORR      r0,r0,#5              ;1055
0000ce  6188              STR      r0,[r1,#0x18]         ;1055
0000d0  e00d              B        |L23.238|
                  |L23.210|
0000d2  f7fffffe          BL       RMP_Unlock_Sched
0000d6  f06f0004          MVN      r0,#4                 ;1046
0000da  e8bd81f0          POP      {r4-r8,pc}
                  |L23.222|
0000de  69a0              LDR      r0,[r4,#0x18]         ;1058  ; RMP_Cur_Thd
0000e0  69a1              LDR      r1,[r4,#0x18]         ;1058  ; RMP_Cur_Thd
0000e2  6980              LDR      r0,[r0,#0x18]         ;1058
0000e4  f02000ff          BIC      r0,r0,#0xff           ;1058
0000e8  f0400004          ORR      r0,r0,#4              ;1058
0000ec  6188              STR      r0,[r1,#0x18]         ;1058
                  |L23.238|
0000ee  f7fffffe          BL       RMP_Unlock_Sched
0000f2  69a0              LDR      r0,[r4,#0x18]         ;1063  ; RMP_Cur_Thd
0000f4  6ac0              LDR      r0,[r0,#0x2c]         ;1063
0000f6  6028              STR      r0,[r5,#0]            ;1063
0000f8  60e7              STR      r7,[r4,#0xc]          ;1063  ; RMP_Sched_Locked
0000fa  68a0              LDR      r0,[r4,#8]            ;1063  ; RMP_Sched_Lock_Cnt
0000fc  1c40              ADDS     r0,r0,#1              ;1063
0000fe  60a0              STR      r0,[r4,#8]            ;1063  ; RMP_Sched_Lock_Cnt
000100  69a0              LDR      r0,[r4,#0x18]         ;1066  ; RMP_Cur_Thd
000102  6ac0              LDR      r0,[r0,#0x2c]         ;1066
000104  6028              STR      r0,[r5,#0]            ;1067
000106  69a0              LDR      r0,[r4,#0x18]         ;1067  ; RMP_Cur_Thd
000108  6981              LDR      r1,[r0,#0x18]         ;1067
00010a  f4217100          BIC      r1,r1,#0x200          ;1067
00010e  6181              STR      r1,[r0,#0x18]         ;1068
000110  f7fffffe          BL       RMP_Unlock_Sched
                  |L23.276|
000114  69a0              LDR      r0,[r4,#0x18]         ;1072  ; RMP_Cur_Thd
000116  6b80              LDR      r0,[r0,#0x38]         ;1072
000118  e8bd81f0          POP      {r4-r8,pc}
;;;1074   /* End Function:RMP_Thd_Rcv **************************************************/
                          ENDP

                  |L23.284|
                          DCD      ||.data||
                  |L23.288|
                          DCD      0x000186a0
                  |L23.292|
                          DCD      ||.data||+0x20

                          AREA ||i.RMP_Thd_Resume||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Resume PROC
;;;824    ******************************************************************************/
;;;825    ret_t RMP_Thd_Resume(volatile struct RMP_Thd* Thread)
000000  b510              PUSH     {r4,lr}
;;;826    {
;;;827        ret_t Retval;
;;;828        
;;;829        /* Check if this thread structure could possibly be in use */
;;;830        if(Thread==0)
000002  2800              CMP      r0,#0
;;;831            return RMP_ERR_THD;
000004  bf04              ITT      EQ
000006  f04f30ff          MOVEQ    r0,#0xffffffff
;;;832    
;;;833        RMP_Lock_Sched();
;;;834        
;;;835        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;836        {
;;;837            RMP_Unlock_Sched();
;;;838            return RMP_ERR_THD;
;;;839        }
;;;840        
;;;841        /* Check if the thread is suspended, if not, then throw an error */
;;;842        if((Thread->State&RMP_THD_SUSPENDED)!=0)
;;;843        {
;;;844            /* Suspended */
;;;845            Thread->State&=~RMP_THD_SUSPENDED;
;;;846            if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;847                _RMP_Set_Rdy(Thread);
;;;848            Retval=0;
;;;849        }
;;;850        else
;;;851            Retval=RMP_ERR_STATE;
;;;852        
;;;853        RMP_Unlock_Sched();
;;;854    
;;;855        return Retval;
;;;856    }
00000a  bd10              POPEQ    {r4,pc}
00000c  2201              MOVS     r2,#1
00000e  4912              LDR      r1,|L24.88|
000010  60ca              STR      r2,[r1,#0xc]  ; RMP_Sched_Locked
000012  688a              LDR      r2,[r1,#8]  ; RMP_Sched_Lock_Cnt
000014  1c52              ADDS     r2,r2,#1
000016  608a              STR      r2,[r1,#8]  ; RMP_Sched_Lock_Cnt
000018  6981              LDR      r1,[r0,#0x18]         ;835
00001a  f0110fff          TST      r1,#0xff              ;835
00001e  d015              BEQ      |L24.76|
000020  6981              LDR      r1,[r0,#0x18]         ;842
000022  f4117f80          TST      r1,#0x100             ;842
000026  bf08              IT       EQ                    ;851
000028  f06f0403          MVNEQ    r4,#3                 ;851
00002c  d00a              BEQ      |L24.68|
00002e  6981              LDR      r1,[r0,#0x18]         ;845
000030  f4217180          BIC      r1,r1,#0x100          ;845
000034  6181              STR      r1,[r0,#0x18]         ;845
000036  6981              LDR      r1,[r0,#0x18]         ;846
000038  b2c9              UXTB     r1,r1                 ;846
00003a  2901              CMP      r1,#1                 ;846
00003c  bf08              IT       EQ                    ;847
00003e  f7fffffe          BLEQ     _RMP_Set_Rdy
000042  2400              MOVS     r4,#0                 ;848
                  |L24.68|
000044  f7fffffe          BL       RMP_Unlock_Sched
000048  4620              MOV      r0,r4                 ;855
00004a  bd10              POP      {r4,pc}
                  |L24.76|
00004c  f7fffffe          BL       RMP_Unlock_Sched
000050  f04f30ff          MOV      r0,#0xffffffff        ;838
000054  bd10              POP      {r4,pc}
;;;857    /* End Function:RMP_Thd_Resume ***********************************************/
                          ENDP

000056  0000              DCW      0x0000
                  |L24.88|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Set||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Set PROC
;;;730    ******************************************************************************/
;;;731    ret_t RMP_Thd_Set(volatile struct RMP_Thd* Thread, ptr_t Prio, ptr_t Slices)
000000  2a00              CMP      r2,#0
;;;732    {
;;;733        /* Check if the priority and timeslice range is correct */
;;;734        if(Slices==0)
;;;735            return RMP_ERR_SLICE;
000002  bf04              ITT      EQ
000004  f06f0002          MVNEQ    r0,#2
;;;736        
;;;737        /* Check if this thread structure could possibly be in use */
;;;738        if(Thread==0)
;;;739            return RMP_ERR_THD;
;;;740        
;;;741        RMP_Lock_Sched();
;;;742        
;;;743        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;744        {
;;;745            RMP_Unlock_Sched();
;;;746            return RMP_ERR_THD;
;;;747        }
;;;748        
;;;749        /* See if the thread is in running state */
;;;750        if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;751        {
;;;752            /* See if we are gonna change one of it or both */
;;;753            if(Prio<RMP_MAX_PREEMPT_PRIO)
;;;754            {
;;;755                if(Thread->Prio!=Prio)
;;;756                {
;;;757                    _RMP_Clr_Rdy(Thread);
;;;758                    Thread->Prio=Prio;
;;;759                    _RMP_Set_Rdy(Thread);
;;;760                }
;;;761            }
;;;762            
;;;763            if(Slices<RMP_MAX_SLICES)
;;;764                Thread->Slices=Slices;
;;;765        }
;;;766        else
;;;767        {
;;;768            if(Prio<RMP_MAX_PREEMPT_PRIO)
;;;769                Thread->Prio=Prio;
;;;770            
;;;771            if(Slices<RMP_MAX_SLICES)
;;;772                Thread->Slices=Slices;
;;;773        }
;;;774        
;;;775        RMP_Unlock_Sched();
;;;776        
;;;777        return 0;
;;;778    }
000008  4770              BXEQ     lr
00000a  2800              CMP      r0,#0                 ;738
00000c  bf04              ITT      EQ                    ;739
00000e  f04f30ff          MOVEQ    r0,#0xffffffff        ;739
000012  4770              BXEQ     lr
000014  e92d41f0          PUSH     {r4-r8,lr}            ;732
000018  4604              MOV      r4,r0                 ;732
00001a  4818              LDR      r0,|L25.124|
00001c  460e              MOV      r6,r1                 ;732
00001e  2101              MOVS     r1,#1                 ;732
000020  4615              MOV      r5,r2                 ;732
000022  60c1              STR      r1,[r0,#0xc]          ;732  ; RMP_Sched_Locked
000024  6881              LDR      r1,[r0,#8]            ;732  ; RMP_Sched_Lock_Cnt
000026  1c49              ADDS     r1,r1,#1              ;732
000028  6081              STR      r1,[r0,#8]            ;732  ; RMP_Sched_Lock_Cnt
00002a  69a0              LDR      r0,[r4,#0x18]         ;743
00002c  f0100fff          TST      r0,#0xff              ;743
000030  d00f              BEQ      |L25.82|
000032  69a0              LDR      r0,[r4,#0x18]         ;750
000034  4f12              LDR      r7,|L25.128|
000036  b2c0              UXTB     r0,r0                 ;750
000038  2801              CMP      r0,#1                 ;750
00003a  d010              BEQ      |L25.94|
00003c  2e20              CMP      r6,#0x20              ;768
00003e  bf38              IT       CC                    ;769
000040  6266              STRCC    r6,[r4,#0x24]         ;769
000042  42bd              CMP      r5,r7                 ;771
000044  d200              BCS      |L25.72|
                  |L25.70|
000046  61e5              STR      r5,[r4,#0x1c]         ;772
                  |L25.72|
000048  f7fffffe          BL       RMP_Unlock_Sched
00004c  2000              MOVS     r0,#0                 ;777
00004e  e8bd81f0          POP      {r4-r8,pc}
                  |L25.82|
000052  f7fffffe          BL       RMP_Unlock_Sched
000056  f04f30ff          MOV      r0,#0xffffffff        ;746
00005a  e8bd81f0          POP      {r4-r8,pc}
                  |L25.94|
00005e  2e20              CMP      r6,#0x20              ;753
000060  d209              BCS      |L25.118|
000062  6a60              LDR      r0,[r4,#0x24]         ;755
000064  42b0              CMP      r0,r6                 ;755
000066  d006              BEQ      |L25.118|
000068  4620              MOV      r0,r4                 ;757
00006a  f7fffffe          BL       _RMP_Clr_Rdy
00006e  6266              STR      r6,[r4,#0x24]         ;758
000070  4620              MOV      r0,r4                 ;759
000072  f7fffffe          BL       _RMP_Set_Rdy
                  |L25.118|
000076  42bd              CMP      r5,r7                 ;763
000078  d2e6              BCS      |L25.72|
00007a  e7e4              B        |L25.70|
;;;779    /* End Function:RMP_Thd_Set **************************************************/
                          ENDP

                  |L25.124|
                          DCD      ||.data||
                  |L25.128|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Snd||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Snd PROC
;;;867    ******************************************************************************/
;;;868    ret_t RMP_Thd_Snd(volatile struct RMP_Thd* Thread, ptr_t Data, ptr_t Slices)
000000  2800              CMP      r0,#0
;;;869    {
;;;870        /* Check if this thread structure could possibly be in use */
;;;871        if(Thread==0)
;;;872            return RMP_ERR_THD;
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;873        
;;;874        RMP_Lock_Sched();
;;;875        
;;;876        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;877        {
;;;878            RMP_Unlock_Sched();
;;;879            return RMP_ERR_THD;
;;;880        }
;;;881        
;;;882        /* Are we sending to ourself? This is not allowed */
;;;883        if(RMP_Cur_Thd==Thread)
;;;884        {
;;;885            RMP_Unlock_Sched();
;;;886            return RMP_ERR_OPER;
;;;887        }
;;;888        
;;;889        RMP_Cur_Thd->Retval=0;
;;;890    
;;;891        /* See if there are already a value in the mailbox, if there is, we block */
;;;892        if((Thread->State&RMP_THD_MBOXFUL)!=0)
;;;893        {
;;;894            /* Mailbox full, we block, and put ourself into the queue */
;;;895            if(Slices==0)
;;;896            {
;;;897                RMP_Unlock_Sched();
;;;898                return RMP_ERR_OPER;
;;;899            }
;;;900    
;;;901            /* We must be running */
;;;902            _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;903            RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Thread->Snd_List.Prev,&(Thread->Snd_List));
;;;904    
;;;905            if(Slices<RMP_MAX_SLICES)
;;;906            {
;;;907                _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;908                RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDDLY);
;;;909            }
;;;910            else
;;;911                RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDBLK);
;;;912    
;;;913            RMP_Cur_Thd->Data=Data;
;;;914        }
;;;915        else
;;;916        {
;;;917            /* Mailbox not full. We need to check if the receiver is waiting for us */
;;;918            if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
;;;919               (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
;;;920            {
;;;921                /* The receiver is blocked, wake it up and return the value */
;;;922                if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
;;;923                    RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;924                
;;;925                RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;926    
;;;927                /* Is it suspended? If yes, we can't directly send it running */
;;;928                if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;929                    _RMP_Set_Rdy(Thread);
;;;930            }
;;;931            
;;;932            /* Set the mailbox */
;;;933            Thread->Mailbox=Data;
;;;934            Thread->State|=RMP_THD_MBOXFUL;
;;;935        }
;;;936        
;;;937        RMP_Unlock_Sched();
;;;938    
;;;939        return RMP_Cur_Thd->Retval;
;;;940    }
000008  4770              BXEQ     lr
00000a  e92d41f0          PUSH     {r4-r8,lr}            ;869
00000e  4e46              LDR      r6,|L26.296|
000010  4604              MOV      r4,r0                 ;869
000012  2001              MOVS     r0,#1                 ;869
000014  4615              MOV      r5,r2                 ;869
000016  460f              MOV      r7,r1                 ;869
000018  60f0              STR      r0,[r6,#0xc]          ;869  ; RMP_Sched_Locked
00001a  68b0              LDR      r0,[r6,#8]            ;869  ; RMP_Sched_Lock_Cnt
00001c  1c40              ADDS     r0,r0,#1              ;869
00001e  60b0              STR      r0,[r6,#8]            ;869  ; RMP_Sched_Lock_Cnt
000020  69a0              LDR      r0,[r4,#0x18]         ;876
000022  f0100fff          TST      r0,#0xff              ;876
000026  d03f              BEQ      |L26.168|
000028  69b0              LDR      r0,[r6,#0x18]         ;883  ; RMP_Cur_Thd
00002a  42a0              CMP      r0,r4                 ;883
00002c  d042              BEQ      |L26.180|
00002e  69b1              LDR      r1,[r6,#0x18]         ;889  ; RMP_Cur_Thd
000030  2000              MOVS     r0,#0                 ;889
000032  6388              STR      r0,[r1,#0x38]         ;892
000034  69a0              LDR      r0,[r4,#0x18]         ;892
000036  f4107f00          TST      r0,#0x200             ;892
00003a  d04c              BEQ      |L26.214|
00003c  2d00              CMP      r5,#0                 ;895
00003e  d039              BEQ      |L26.180|
000040  69b0              LDR      r0,[r6,#0x18]         ;902  ; RMP_Cur_Thd
000042  f7fffffe          BL       _RMP_Clr_Rdy
000046  69b0              LDR      r0,[r6,#0x18]         ;903  ; RMP_Cur_Thd
000048  f8541f10          LDR      r1,[r4,#0x10]!        ;903
00004c  6020              STR      r0,[r4,#0]            ;903
00004e  6044              STR      r4,[r0,#4]            ;903
000050  6001              STR      r1,[r0,#0]            ;903
000052  6048              STR      r0,[r1,#4]            ;903
000054  4835              LDR      r0,|L26.300|
000056  4285              CMP      r5,r0                 ;905
000058  d232              BCS      |L26.192|
00005a  f8d6c018          LDR      r12,[r6,#0x18]        ;907  ; RMP_Cur_Thd
00005e  f1060320          ADD      r3,r6,#0x20           ;907
000062  6858              LDR      r0,[r3,#4]            ;907  ; RMP_Delay
000064  4298              CMP      r0,r3                 ;907
000066  bf1c              ITT      NE                    ;907
000068  f1a00108          SUBNE    r1,r0,#8              ;907
00006c  6a02              LDRNE    r2,[r0,#0x20]         ;907
00006e  d005              BEQ      |L26.124|
                  |L26.112|
000070  6871              LDR      r1,[r6,#4]            ;907  ; RMP_Tick
000072  1a51              SUBS     r1,r2,r1              ;907
000074  42a9              CMP      r1,r5                 ;907
000076  d801              BHI      |L26.124|
000078  4298              CMP      r0,r3                 ;907
00007a  d1f9              BNE      |L26.112|
                  |L26.124|
00007c  6871              LDR      r1,[r6,#4]            ;907  ; RMP_Tick
00007e  4429              ADD      r1,r1,r5              ;907
000080  f8cc1028          STR      r1,[r12,#0x28]        ;907
000084  f10c0108          ADD      r1,r12,#8             ;907
000088  6802              LDR      r2,[r0,#0]            ;907
00008a  6001              STR      r1,[r0,#0]            ;907
00008c  f8cc000c          STR      r0,[r12,#0xc]         ;907
000090  f8cc2008          STR      r2,[r12,#8]           ;907
000094  6051              STR      r1,[r2,#4]            ;907
000096  69b0              LDR      r0,[r6,#0x18]         ;908  ; RMP_Cur_Thd
000098  69b1              LDR      r1,[r6,#0x18]         ;908  ; RMP_Cur_Thd
00009a  6980              LDR      r0,[r0,#0x18]         ;908
00009c  f02000ff          BIC      r0,r0,#0xff           ;908
0000a0  f0400003          ORR      r0,r0,#3              ;908
0000a4  6188              STR      r0,[r1,#0x18]         ;908
0000a6  e013              B        |L26.208|
                  |L26.168|
0000a8  f7fffffe          BL       RMP_Unlock_Sched
0000ac  f04f30ff          MOV      r0,#0xffffffff        ;879
0000b0  e8bd81f0          POP      {r4-r8,pc}
                  |L26.180|
0000b4  f7fffffe          BL       RMP_Unlock_Sched
0000b8  f06f0004          MVN      r0,#4                 ;898
0000bc  e8bd81f0          POP      {r4-r8,pc}
                  |L26.192|
0000c0  69b0              LDR      r0,[r6,#0x18]         ;911  ; RMP_Cur_Thd
0000c2  69b1              LDR      r1,[r6,#0x18]         ;911  ; RMP_Cur_Thd
0000c4  6980              LDR      r0,[r0,#0x18]         ;911
0000c6  f02000ff          BIC      r0,r0,#0xff           ;911
0000ca  f0400002          ORR      r0,r0,#2              ;911
0000ce  6188              STR      r0,[r1,#0x18]         ;911
                  |L26.208|
0000d0  69b0              LDR      r0,[r6,#0x18]         ;913  ; RMP_Cur_Thd
0000d2  6307              STR      r7,[r0,#0x30]         ;913
0000d4  e021              B        |L26.282|
                  |L26.214|
0000d6  69a0              LDR      r0,[r4,#0x18]         ;918
0000d8  b2c0              UXTB     r0,r0                 ;918
0000da  2804              CMP      r0,#4                 ;918
0000dc  d003              BEQ      |L26.230|
0000de  69a0              LDR      r0,[r4,#0x18]         ;919
0000e0  b2c0              UXTB     r0,r0                 ;919
0000e2  2805              CMP      r0,#5                 ;919
0000e4  d114              BNE      |L26.272|
                  |L26.230|
0000e6  69a0              LDR      r0,[r4,#0x18]         ;922
0000e8  b2c0              UXTB     r0,r0                 ;922
0000ea  2805              CMP      r0,#5                 ;922
0000ec  d103              BNE      |L26.246|
0000ee  68a0              LDR      r0,[r4,#8]            ;923
0000f0  68e1              LDR      r1,[r4,#0xc]          ;923
0000f2  6008              STR      r0,[r1,#0]            ;923
0000f4  6041              STR      r1,[r0,#4]            ;923
                  |L26.246|
0000f6  69a0              LDR      r0,[r4,#0x18]         ;925
0000f8  f02000ff          BIC      r0,r0,#0xff           ;925
0000fc  f0400001          ORR      r0,r0,#1              ;925
000100  61a0              STR      r0,[r4,#0x18]         ;925
000102  69a0              LDR      r0,[r4,#0x18]         ;928
000104  f4107f80          TST      r0,#0x100             ;928
000108  bf04              ITT      EQ                    ;929
00010a  4620              MOVEQ    r0,r4                 ;929
00010c  f7fffffe          BLEQ     _RMP_Set_Rdy
                  |L26.272|
000110  62e7              STR      r7,[r4,#0x2c]         ;933
000112  69a0              LDR      r0,[r4,#0x18]         ;934
000114  f4407000          ORR      r0,r0,#0x200          ;934
000118  61a0              STR      r0,[r4,#0x18]         ;934
                  |L26.282|
00011a  f7fffffe          BL       RMP_Unlock_Sched
00011e  69b0              LDR      r0,[r6,#0x18]         ;939  ; RMP_Cur_Thd
000120  6b80              LDR      r0,[r0,#0x38]         ;939
000122  e8bd81f0          POP      {r4-r8,pc}
;;;941    /* End Function:RMP_Thd_Snd **************************************************/
                          ENDP

000126  0000              DCW      0x0000
                  |L26.296|
                          DCD      ||.data||
                  |L26.300|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Snd_ISR||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Snd_ISR PROC
;;;951    ******************************************************************************/
;;;952    ret_t RMP_Thd_Snd_ISR(volatile struct RMP_Thd* Thread, ptr_t Data)
000000  2800              CMP      r0,#0
;;;953    {
;;;954        /* Check if this thread structure could possibly be in use */
;;;955        if(Thread==0)
;;;956            return RMP_ERR_THD;
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;957        
;;;958        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;959            return RMP_ERR_THD;
;;;960        
;;;961        if(RMP_Sched_Locked!=0)
;;;962            return RMP_ERR_OPER;
;;;963    
;;;964        /* See if there are already a value in the mailbox, if there is, we abort */
;;;965        if((Thread->State&RMP_THD_MBOXFUL)!=0)
;;;966            return RMP_ERR_OPER;
;;;967        else
;;;968        {
;;;969            /* Mailbox not full. We need to check if the receiver is waiting for us */
;;;970            if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
;;;971               (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
;;;972            {
;;;973                /* The receiver is blocked, wake it up and return the value */
;;;974                if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
;;;975                    RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;976                
;;;977                RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;978    
;;;979                /* Is it suspended? If yes, we can't directly send it running */
;;;980                if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;981                {
;;;982                    _RMP_Set_Rdy(Thread);
;;;983                    if(Thread->Prio>RMP_Cur_Thd->Prio)
;;;984                        _RMP_Yield();
;;;985                }
;;;986            }
;;;987            
;;;988            /* Set the mailbox */
;;;989            Thread->Mailbox=Data;
;;;990            Thread->State|=RMP_THD_MBOXFUL;
;;;991        }
;;;992    
;;;993        return 0;
;;;994    }
000008  4770              BXEQ     lr
00000a  b570              PUSH     {r4-r6,lr}            ;953
00000c  4604              MOV      r4,r0                 ;953
00000e  6980              LDR      r0,[r0,#0x18]         ;958
000010  460e              MOV      r6,r1                 ;953
000012  f0100fff          TST      r0,#0xff              ;958
000016  bf04              ITT      EQ                    ;959
000018  f04f30ff          MOVEQ    r0,#0xffffffff        ;959
00001c  bd70              POPEQ    {r4-r6,pc}
00001e  4d1a              LDR      r5,|L27.136|
000020  68e8              LDR      r0,[r5,#0xc]          ;961  ; RMP_Sched_Locked
000022  2800              CMP      r0,#0                 ;961
000024  bf07              ITTEE    EQ                    ;965
000026  69a0              LDREQ    r0,[r4,#0x18]         ;965
000028  f4107f00          TSTEQ    r0,#0x200             ;965
00002c  f06f0004          MVNNE    r0,#4                 ;966
000030  bd70              POPNE    {r4-r6,pc}
000032  69a0              LDR      r0,[r4,#0x18]         ;970
000034  b2c0              UXTB     r0,r0                 ;970
000036  2804              CMP      r0,#4                 ;970
000038  d003              BEQ      |L27.66|
00003a  69a0              LDR      r0,[r4,#0x18]         ;971
00003c  b2c0              UXTB     r0,r0                 ;971
00003e  2805              CMP      r0,#5                 ;971
000040  d11b              BNE      |L27.122|
                  |L27.66|
000042  69a0              LDR      r0,[r4,#0x18]         ;974
000044  b2c0              UXTB     r0,r0                 ;974
000046  2805              CMP      r0,#5                 ;974
000048  d103              BNE      |L27.82|
00004a  68a0              LDR      r0,[r4,#8]            ;975
00004c  68e2              LDR      r2,[r4,#0xc]          ;975
00004e  6010              STR      r0,[r2,#0]            ;975
000050  6042              STR      r2,[r0,#4]            ;975
                  |L27.82|
000052  69a0              LDR      r0,[r4,#0x18]         ;977
000054  f02000ff          BIC      r0,r0,#0xff           ;977
000058  f0400001          ORR      r0,r0,#1              ;977
00005c  61a0              STR      r0,[r4,#0x18]         ;977
00005e  69a0              LDR      r0,[r4,#0x18]         ;980
000060  f4107f80          TST      r0,#0x100             ;980
000064  d109              BNE      |L27.122|
000066  4620              MOV      r0,r4                 ;982
000068  f7fffffe          BL       _RMP_Set_Rdy
00006c  6a60              LDR      r0,[r4,#0x24]         ;983
00006e  69a9              LDR      r1,[r5,#0x18]         ;983  ; RMP_Cur_Thd
000070  6a49              LDR      r1,[r1,#0x24]         ;983
000072  4288              CMP      r0,r1                 ;983
000074  bf88              IT       HI                    ;984
000076  f7fffffe          BLHI     _RMP_Yield
                  |L27.122|
00007a  62e6              STR      r6,[r4,#0x2c]         ;989
00007c  69a0              LDR      r0,[r4,#0x18]         ;990
00007e  f4407000          ORR      r0,r0,#0x200          ;990
000082  61a0              STR      r0,[r4,#0x18]         ;990
000084  2000              MOVS     r0,#0                 ;993
000086  bd70              POP      {r4-r6,pc}
;;;995    /* End Function:RMP_Thd_Snd_ISR **********************************************/
                          ENDP

                  |L27.136|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Suspend||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Suspend PROC
;;;786    ******************************************************************************/
;;;787    ret_t RMP_Thd_Suspend(volatile struct RMP_Thd* Thread)
000000  b510              PUSH     {r4,lr}
;;;788    {
;;;789        /* Check if this thread structure could possibly be in use */
;;;790        if(Thread==0)
000002  2800              CMP      r0,#0
;;;791            return RMP_ERR_THD;
000004  bf04              ITT      EQ
000006  f04f30ff          MOVEQ    r0,#0xffffffff
;;;792        
;;;793        RMP_Lock_Sched();
;;;794        
;;;795        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;796        {
;;;797            RMP_Unlock_Sched();
;;;798            return RMP_ERR_THD;
;;;799        }
;;;800        
;;;801        /* Suspend it */
;;;802        if((Thread->State&RMP_THD_SUSPENDED)!=0)
;;;803        {
;;;804            RMP_Unlock_Sched();
;;;805            return RMP_ERR_STATE;
;;;806        }
;;;807        /* Mark this as suspended */
;;;808        Thread->State|=RMP_THD_SUSPENDED;
;;;809        /* Only when it is running do we clear this */
;;;810        if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;811            _RMP_Clr_Rdy(Thread);
;;;812        
;;;813        RMP_Unlock_Sched();
;;;814    
;;;815        return 0;
;;;816    }
00000a  bd10              POPEQ    {r4,pc}
00000c  2201              MOVS     r2,#1
00000e  4912              LDR      r1,|L28.88|
000010  60ca              STR      r2,[r1,#0xc]  ; RMP_Sched_Locked
000012  688a              LDR      r2,[r1,#8]  ; RMP_Sched_Lock_Cnt
000014  1c52              ADDS     r2,r2,#1
000016  608a              STR      r2,[r1,#8]  ; RMP_Sched_Lock_Cnt
000018  6981              LDR      r1,[r0,#0x18]         ;795
00001a  f0110fff          TST      r1,#0xff              ;795
00001e  d008              BEQ      |L28.50|
000020  6981              LDR      r1,[r0,#0x18]         ;802
000022  f4117f80          TST      r1,#0x100             ;802
000026  d009              BEQ      |L28.60|
000028  f7fffffe          BL       RMP_Unlock_Sched
00002c  f06f0003          MVN      r0,#3                 ;805
000030  bd10              POP      {r4,pc}
                  |L28.50|
000032  f7fffffe          BL       RMP_Unlock_Sched
000036  f04f30ff          MOV      r0,#0xffffffff        ;798
00003a  bd10              POP      {r4,pc}
                  |L28.60|
00003c  6981              LDR      r1,[r0,#0x18]         ;808
00003e  f4417180          ORR      r1,r1,#0x100          ;808
000042  6181              STR      r1,[r0,#0x18]         ;808
000044  6981              LDR      r1,[r0,#0x18]         ;810
000046  b2c9              UXTB     r1,r1                 ;810
000048  2901              CMP      r1,#1                 ;810
00004a  bf08              IT       EQ                    ;811
00004c  f7fffffe          BLEQ     _RMP_Clr_Rdy
000050  f7fffffe          BL       RMP_Unlock_Sched
000054  2000              MOVS     r0,#0                 ;815
000056  bd10              POP      {r4,pc}
;;;817    /* End Function:RMP_Thd_Suspend **********************************************/
                          ENDP

                  |L28.88|
                          DCD      ||.data||

                          AREA ||i.RMP_Tick_Hook||, CODE, READONLY, ALIGN=1

                  RMP_Tick_Hook PROC
;;;1490   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1491   void RMP_Tick_Hook(ptr_t Ticks)
000000  4770              BX       lr
;;;1492   {
;;;1493       Ticks=Ticks;
;;;1494       return;
;;;1495   }
;;;1496   #endif
                          ENDP


                          AREA ||i.RMP_Unlock_Sched||, CODE, READONLY, ALIGN=2

                  RMP_Unlock_Sched PROC
;;;274    ******************************************************************************/
;;;275    void RMP_Unlock_Sched(void)
000000  480a              LDR      r0,|L30.44|
;;;276    {
;;;277        if(RMP_Sched_Lock_Cnt==1)
000002  6881              LDR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
000004  2901              CMP      r1,#1
000006  d006              BEQ      |L30.22|
;;;278        {
;;;279            /* Clear the count before enabling */
;;;280            RMP_Sched_Lock_Cnt=0;
;;;281            RMP_Sched_Locked=0;
;;;282            /* Now see if the scheduler scheduling action is pended in the lock-unlock 
;;;283             * period. If yes, perform a schedule now */
;;;284            if(RMP_Sched_Pend!=0)
;;;285            {
;;;286                /* Reset the count and trigger the context switch */
;;;287                RMP_Sched_Pend=0;
;;;288                _RMP_Yield();
;;;289            }
;;;290        }
;;;291        else if(RMP_Sched_Lock_Cnt>1)
000008  6881              LDR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
00000a  2901              CMP      r1,#1
00000c  d90d              BLS      |L30.42|
;;;292            RMP_Sched_Lock_Cnt--;
00000e  6881              LDR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
000010  1e49              SUBS     r1,r1,#1
000012  6081              STR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
;;;293        /* Trying to unlock a scheduler that is not locked */
;;;294        else
;;;295            while(1);
;;;296    }
000014  4770              BX       lr
                  |L30.22|
000016  2100              MOVS     r1,#0                 ;280
000018  6081              STR      r1,[r0,#8]            ;280  ; RMP_Sched_Lock_Cnt
00001a  60c1              STR      r1,[r0,#0xc]          ;281  ; RMP_Sched_Locked
00001c  6902              LDR      r2,[r0,#0x10]         ;284  ; RMP_Sched_Pend
00001e  2a00              CMP      r2,#0                 ;284
000020  bf08              IT       EQ
000022  4770              BXEQ     lr
000024  6101              STR      r1,[r0,#0x10]         ;287  ; RMP_Sched_Pend
000026  f7ffbffe          B.W      _RMP_Yield
                  |L30.42|
00002a  e7fe              B        |L30.42|
;;;297    /* End Function:RMP_Unlock_Sched *********************************************/
                          ENDP

                  |L30.44|
                          DCD      ||.data||

                          AREA ||i.RMP_Yield||, CODE, READONLY, ALIGN=2

                  RMP_Yield PROC
;;;304    ******************************************************************************/
;;;305    void RMP_Yield(void)
000000  4804              LDR      r0,|L31.20|
;;;306    {
;;;307        if(RMP_Sched_Locked==0)
000002  68c1              LDR      r1,[r0,#0xc]  ; RMP_Sched_Locked
000004  2900              CMP      r1,#0
;;;308        {
;;;309            /* Now see if the scheduler scheduling action is pended in the lock-unlock 
;;;310             * period. If yes, perform a schedule now */
;;;311            _RMP_Yield();
;;;312        }
;;;313        else
;;;314            RMP_Sched_Pend=1;
000006  bf1e              ITTT     NE
000008  2101              MOVNE    r1,#1
00000a  6101              STRNE    r1,[r0,#0x10]  ; RMP_Sched_Pend
;;;315    }
00000c  4770              BXNE     lr
00000e  f7ffbffe          B.W      _RMP_Yield
;;;316    /* End Function:RMP_Yield ****************************************************/
                          ENDP

000012  0000              DCW      0x0000
                  |L31.20|
                          DCD      ||.data||

                          AREA ||i._RMP_Clr_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Clr_Rdy PROC
;;;533    ******************************************************************************/
;;;534    void _RMP_Clr_Rdy(volatile struct RMP_Thd* Thread)
000000  6801              LDR      r1,[r0,#0]
;;;535    {
;;;536        /* See if it is the last thread on the priority level */
;;;537        if(Thread->Run_Head.Prev==Thread->Run_Head.Next)
000002  6842              LDR      r2,[r0,#4]
;;;538            RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]&=~(((ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK));
000004  2301              MOVS     r3,#1
000006  4291              CMP      r1,r2                 ;537
000008  d10e              BNE      |L32.40|
00000a  6a41              LDR      r1,[r0,#0x24]
00000c  4a0b              LDR      r2,|L32.60|
00000e  0949              LSRS     r1,r1,#5
000010  eb020181          ADD      r1,r2,r1,LSL #2
000014  680a              LDR      r2,[r1,#0]
000016  f8d0c024          LDR      r12,[r0,#0x24]
00001a  f00c0c0f          AND      r12,r12,#0xf
00001e  fa03fc0c          LSL      r12,r3,r12
000022  ea22020c          BIC      r2,r2,r12
000026  600a              STR      r2,[r1,#0]
                  |L32.40|
;;;539        
;;;540        /* Insert this into the corresponding runqueue */
;;;541        RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
000028  6801              LDR      r1,[r0,#0]
00002a  6842              LDR      r2,[r0,#4]
00002c  6011              STR      r1,[r2,#0]
00002e  604a              STR      r2,[r1,#4]
;;;542        
;;;543        /* If it is the current thread, request a context switch */
;;;544        if(Thread==RMP_Cur_Thd)
000030  4902              LDR      r1,|L32.60|
000032  698a              LDR      r2,[r1,#0x18]  ; RMP_Cur_Thd
000034  4290              CMP      r0,r2
;;;545            RMP_Sched_Pend=1;
000036  bf08              IT       EQ
000038  610b              STREQ    r3,[r1,#0x10]  ; RMP_Sched_Pend
;;;546    }
00003a  4770              BX       lr
;;;547    /* End Function:_RMP_Clr_Rdy *************************************************/
                          ENDP

                  |L32.60|
                          DCD      ||.data||

                          AREA ||i._RMP_Get_High_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Get_High_Rdy PROC
;;;382    ******************************************************************************/
;;;383    void _RMP_Get_High_Rdy(void)
000000  b570              PUSH     {r4-r6,lr}
;;;384    {
;;;385        cnt_t Count;
;;;386        
;;;387        /* Write the SP value to thread structure */
;;;388        RMP_Cur_Thd->Stack=RMP_Cur_SP;
000002  4c1e              LDR      r4,|L33.124|
000004  69e0              LDR      r0,[r4,#0x1c]  ; RMP_Cur_SP
000006  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
;;;389        
;;;390        /* Is the scheduler locked on other threads? If yes, we return without doing anything */
;;;391        if(RMP_Sched_Locked!=0)
000008  6348              STR      r0,[r1,#0x34]
00000a  68e0              LDR      r0,[r4,#0xc]  ; RMP_Sched_Locked
00000c  2800              CMP      r0,#0                 ;384
;;;392            return;
;;;393        
;;;394        if(RMP_Timer_Pend==1)
;;;395        {
;;;396            RMP_Timer_Pend=0;
;;;397            _RMP_Timer_Proc();
;;;398        }
;;;399        
;;;400        RMP_Sched_Pend=0;
;;;401        /* See which one is ready, and pick it */
;;;402        for(Count=RMP_BITMAP_SIZE-1;Count>=0;Count--)
;;;403        {
;;;404            if(RMP_Bitmap[Count]==0)
;;;405                continue;
;;;406            
;;;407            Count=RMP_MSB_Get(RMP_Bitmap[Count])+(Count<<RMP_WORD_ORDER);
;;;408            
;;;409            /* See if the current thread and the next thread are the same. If yes, place the current at the end of the queue */
;;;410            if(RMP_Cur_Thd==(struct RMP_Thd*)(RMP_Run[Count].Next))
;;;411            {
;;;412                RMP_List_Del(RMP_Cur_Thd->Run_Head.Prev, RMP_Cur_Thd->Run_Head.Next);
;;;413                RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),
;;;414                             RMP_Run[RMP_Cur_Thd->Prio].Prev,
;;;415                             &(RMP_Run[RMP_Cur_Thd->Prio]));
;;;416            }
;;;417            
;;;418            /* Replenish timeslices */
;;;419            RMP_Cur_Thd->Slices_Left=RMP_Cur_Thd->Slices;
;;;420            RMP_Cur_Thd=(struct RMP_Thd*)(RMP_Run[Count].Next);
;;;421            break;
;;;422        }
;;;423        
;;;424        /* Load the SP value from thread structure */
;;;425        RMP_Cur_SP=RMP_Cur_Thd->Stack;
;;;426    }
00000e  bf18              IT       NE
000010  bd70              POPNE    {r4-r6,pc}
000012  6960              LDR      r0,[r4,#0x14]         ;394  ; RMP_Timer_Pend
000014  2500              MOVS     r5,#0                 ;394
000016  2801              CMP      r0,#1                 ;394
000018  bf04              ITT      EQ                    ;396
00001a  6165              STREQ    r5,[r4,#0x14]         ;396  ; RMP_Timer_Pend
00001c  f7fffffe          BLEQ     _RMP_Timer_Proc
000020  6125              STR      r5,[r4,#0x10]         ;400  ; RMP_Sched_Pend
000022  4816              LDR      r0,|L33.124|
000024  6801              LDR      r1,[r0,#0]            ;404
000026  b321              CBZ      r1,|L33.114|
000028  6800              LDR      r0,[r0,#0]            ;407
00002a  f7fffffe          BL       RMP_MSB_Get
00002e  4914              LDR      r1,|L33.128|
000030  eb0103c0          ADD      r3,r1,r0,LSL #3       ;410
000034  6858              LDR      r0,[r3,#4]            ;410
000036  69a2              LDR      r2,[r4,#0x18]         ;410  ; RMP_Cur_Thd
000038  4290              CMP      r0,r2                 ;410
00003a  d114              BNE      |L33.102|
00003c  69a0              LDR      r0,[r4,#0x18]         ;412  ; RMP_Cur_Thd
00003e  69a2              LDR      r2,[r4,#0x18]         ;412  ; RMP_Cur_Thd
000040  6800              LDR      r0,[r0,#0]            ;412
000042  6852              LDR      r2,[r2,#4]            ;412
000044  6010              STR      r0,[r2,#0]            ;412
000046  6042              STR      r2,[r0,#4]            ;412
000048  69a0              LDR      r0,[r4,#0x18]         ;413  ; RMP_Cur_Thd
00004a  69a2              LDR      r2,[r4,#0x18]         ;413  ; RMP_Cur_Thd
00004c  6a52              LDR      r2,[r2,#0x24]         ;413
00004e  f8512032          LDR      r2,[r1,r2,LSL #3]     ;413
000052  f8d4c018          LDR      r12,[r4,#0x18]        ;413  ; RMP_Cur_Thd
000056  f8dcc024          LDR      r12,[r12,#0x24]       ;413
00005a  eb0101cc          ADD      r1,r1,r12,LSL #3      ;413
00005e  6008              STR      r0,[r1,#0]            ;413
000060  6041              STR      r1,[r0,#4]            ;413
000062  6002              STR      r2,[r0,#0]            ;413
000064  6050              STR      r0,[r2,#4]            ;413
                  |L33.102|
000066  69a0              LDR      r0,[r4,#0x18]         ;419  ; RMP_Cur_Thd
000068  69a1              LDR      r1,[r4,#0x18]         ;419  ; RMP_Cur_Thd
00006a  69c0              LDR      r0,[r0,#0x1c]         ;419
00006c  6208              STR      r0,[r1,#0x20]         ;420
00006e  6858              LDR      r0,[r3,#4]            ;420
000070  61a0              STR      r0,[r4,#0x18]         ;420  ; RMP_Cur_Thd
                  |L33.114|
000072  69a0              LDR      r0,[r4,#0x18]         ;425  ; RMP_Cur_Thd
000074  6b40              LDR      r0,[r0,#0x34]         ;425
000076  61e0              STR      r0,[r4,#0x1c]         ;425  ; RMP_Cur_SP
000078  bd70              POP      {r4-r6,pc}
;;;427    /* End Function:_RMP_Get_High_Rdy ********************************************/
                          ENDP

00007a  0000              DCW      0x0000
                  |L33.124|
                          DCD      ||.data||
                  |L33.128|
                          DCD      ||.bss||

                          AREA ||i._RMP_Get_Near_Ticks||, CODE, READONLY, ALIGN=2

                  _RMP_Get_Near_Ticks PROC
;;;478    ******************************************************************************/
;;;479    ptr_t _RMP_Get_Near_Ticks(void)
000000  4a0c              LDR      r2,|L34.52|
;;;480    {
;;;481        ptr_t Value;
;;;482        struct RMP_Thd* Thread;
;;;483        
;;;484        /* What is the current thread's timeout value? */
;;;485        Value=RMP_Cur_Thd->Slices_Left;
000002  6990              LDR      r0,[r2,#0x18]  ; RMP_Cur_Thd
;;;486        
;;;487        /* What is the nearest timer timeout value? */
;;;488        if((&RMP_Delay)!=RMP_Delay.Next)
000004  f1020120          ADD      r1,r2,#0x20
000008  6a00              LDR      r0,[r0,#0x20]         ;485
00000a  684b              LDR      r3,[r1,#4]  ; RMP_Delay
00000c  428b              CMP      r3,r1
00000e  d008              BEQ      |L34.34|
;;;489        {
;;;490            Thread=RMP_DLY2THD(RMP_Delay.Next);
000010  6849              LDR      r1,[r1,#4]  ; RMP_Delay
;;;491            /* See if it is nearer - don't worry about the situation that the timer
;;;492             * have overflown, because if that is to happen, it would have been 
;;;493             * already processed by the timeout processing routine just called above. */
;;;494            if((Thread->Timeout-RMP_Tick)<Value)
;;;495                Value=Thread->Timeout-RMP_Tick;
000012  f8d2c004          LDR      r12,[r2,#4]  ; RMP_Tick
000016  6a0b              LDR      r3,[r1,#0x20]
000018  3908              SUBS     r1,r1,#8
00001a  eba3030c          SUB      r3,r3,r12
00001e  4283              CMP      r3,r0
000020  d303              BCC      |L34.42|
                  |L34.34|
;;;496        }
;;;497        
;;;498        /* The timer setting is at least 1 tick */
;;;499        if(Value==0)
000022  2800              CMP      r0,#0
;;;500            Value=1;
000024  bf08              IT       EQ
000026  2001              MOVEQ    r0,#1
;;;501        
;;;502        return Value;
;;;503    }
000028  4770              BX       lr
                  |L34.42|
00002a  6a88              LDR      r0,[r1,#0x28]         ;495
00002c  6851              LDR      r1,[r2,#4]            ;495  ; RMP_Tick
00002e  1a40              SUBS     r0,r0,r1              ;495
000030  e7f7              B        |L34.34|
;;;504    /* End Function:_RMP_Get_Near_Ticks ******************************************/
                          ENDP

000032  0000              DCW      0x0000
                  |L34.52|
                          DCD      ||.data||

                          AREA ||i._RMP_Set_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Set_Rdy PROC
;;;513    ******************************************************************************/
;;;514    void _RMP_Set_Rdy(volatile struct RMP_Thd* Thread)
000000  6a41              LDR      r1,[r0,#0x24]
;;;515    {
;;;516        /* Insert this into the corresponding runqueue */
;;;517        RMP_List_Ins(&(Thread->Run_Head),RMP_Run[Thread->Prio].Prev,&(RMP_Run[Thread->Prio]));
000002  4a10              LDR      r2,|L35.68|
000004  f8521031          LDR      r1,[r2,r1,LSL #3]
000008  6a43              LDR      r3,[r0,#0x24]
00000a  eb0202c3          ADD      r2,r2,r3,LSL #3
00000e  6010              STR      r0,[r2,#0]
000010  6042              STR      r2,[r0,#4]
000012  6001              STR      r1,[r0,#0]
000014  6048              STR      r0,[r1,#4]
;;;518        /* Set this runlevel as active */
;;;519        RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]|=((ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK);
000016  6a41              LDR      r1,[r0,#0x24]
000018  4a0b              LDR      r2,|L35.72|
00001a  0949              LSRS     r1,r1,#5
00001c  eb020181          ADD      r1,r2,r1,LSL #2
000020  680b              LDR      r3,[r1,#0]
000022  6a42              LDR      r2,[r0,#0x24]
000024  f0020c0f          AND      r12,r2,#0xf
000028  2201              MOVS     r2,#1
00002a  fa02fc0c          LSL      r12,r2,r12
00002e  ea43030c          ORR      r3,r3,r12
000032  600b              STR      r3,[r1,#0]
;;;520        
;;;521        /* Compare this with the current one to see if we need a context switch */
;;;522        if(Thread->Prio>RMP_Cur_Thd->Prio)
000034  6a41              LDR      r1,[r0,#0x24]
000036  4804              LDR      r0,|L35.72|
000038  6983              LDR      r3,[r0,#0x18]  ; RMP_Cur_Thd
00003a  6a5b              LDR      r3,[r3,#0x24]
00003c  4299              CMP      r1,r3
;;;523            RMP_Sched_Pend=1;
00003e  bf88              IT       HI
000040  6102              STRHI    r2,[r0,#0x10]  ; RMP_Sched_Pend
;;;524    }
000042  4770              BX       lr
;;;525    /* End Function:_RMP_Set_Rdy *************************************************/
                          ENDP

                  |L35.68|
                          DCD      ||.bss||
                  |L35.72|
                          DCD      ||.data||

                          AREA ||i._RMP_Tick_Handler||, CODE, READONLY, ALIGN=2

                  _RMP_Tick_Handler PROC
;;;434    ******************************************************************************/
;;;435    void _RMP_Tick_Handler(ptr_t Ticks)
000000  b510              PUSH     {r4,lr}
;;;436    {
;;;437        struct RMP_Thd* Thread;
;;;438        /* Increase the timestamp as always */
;;;439        RMP_Tick+=Ticks;
000002  4c17              LDR      r4,|L36.96|
000004  6861              LDR      r1,[r4,#4]  ; RMP_Tick
000006  4401              ADD      r1,r1,r0
000008  6061              STR      r1,[r4,#4]  ; RMP_Tick
;;;440    #if(RMP_USE_HOOKS==RMP_TRUE)
;;;441        RMP_Tick_Hook(Ticks);
;;;442    #endif
;;;443        /* See if the current thread expired. If yes, trigger a scheduler event */
;;;444        if(Ticks>=RMP_Cur_Thd->Slices_Left)
00000a  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
;;;445            RMP_Sched_Pend=1;
00000c  2201              MOVS     r2,#1
00000e  6a09              LDR      r1,[r1,#0x20]         ;444
000010  4281              CMP      r1,r0                 ;444
000012  bf98              IT       LS
000014  6122              STRLS    r2,[r4,#0x10]  ; RMP_Sched_Pend
000016  d903              BLS      |L36.32|
;;;446        else
;;;447            RMP_Cur_Thd->Slices_Left-=Ticks;
000018  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
00001a  6a0b              LDR      r3,[r1,#0x20]
00001c  1a18              SUBS     r0,r3,r0
00001e  6208              STR      r0,[r1,#0x20]
                  |L36.32|
;;;448        
;;;449        /* Is the scheduler locked? If yes, we cannot process timer events here and will have to pend them */
;;;450        if((&RMP_Delay)!=RMP_Delay.Next)
000020  4810              LDR      r0,|L36.100|
000022  6841              LDR      r1,[r0,#4]  ; RMP_Delay
000024  4281              CMP      r1,r0
000026  d00c              BEQ      |L36.66|
;;;451        {
;;;452            Thread=RMP_DLY2THD(RMP_Delay.Next);
000028  6840              LDR      r0,[r0,#4]  ; RMP_Delay
;;;453            /* If the value is less than this, then it means that the time have
;;;454             * already passed and we have to process this */
;;;455            if((RMP_Tick-Thread->Timeout)<=(RMP_ALLBITS>>1))
00002a  6861              LDR      r1,[r4,#4]  ; RMP_Tick
00002c  6a00              LDR      r0,[r0,#0x20]
00002e  1a08              SUBS     r0,r1,r0
000030  f1b04f00          CMP      r0,#0x80000000
000034  d205              BCS      |L36.66|
;;;456            {
;;;457                /* If scheduler locked, we pend the processing until it is unlocked */
;;;458                if(RMP_Sched_Locked!=0)
000036  68e0              LDR      r0,[r4,#0xc]  ; RMP_Sched_Locked
000038  2800              CMP      r0,#0
;;;459                    RMP_Timer_Pend=1;
00003a  bf14              ITE      NE
00003c  6162              STRNE    r2,[r4,#0x14]  ; RMP_Timer_Pend
;;;460                else
;;;461                    _RMP_Timer_Proc();
00003e  f7fffffe          BLEQ     _RMP_Timer_Proc
                  |L36.66|
;;;462            }
;;;463        }
;;;464        
;;;465        if((RMP_Sched_Locked==0)&&(RMP_Sched_Pend!=0))
000042  68e0              LDR      r0,[r4,#0xc]  ; RMP_Sched_Locked
000044  2800              CMP      r0,#0
;;;466        {
;;;467            RMP_Sched_Pend=0;
;;;468            _RMP_Yield();
;;;469        }
;;;470    }
000046  bf18              IT       NE
000048  bd10              POPNE    {r4,pc}
00004a  6920              LDR      r0,[r4,#0x10]         ;465  ; RMP_Sched_Pend
00004c  2800              CMP      r0,#0                 ;465
00004e  bf08              IT       EQ
000050  bd10              POPEQ    {r4,pc}
000052  2000              MOVS     r0,#0                 ;467
000054  6120              STR      r0,[r4,#0x10]         ;467  ; RMP_Sched_Pend
000056  e8bd4010          POP      {r4,lr}               ;468
00005a  f7ffbffe          B.W      _RMP_Yield
;;;471    /* End Function:_RMP_Tick_Handler ********************************************/
                          ENDP

00005e  0000              DCW      0x0000
                  |L36.96|
                          DCD      ||.data||
                  |L36.100|
                          DCD      ||.data||+0x20

                          AREA ||i._RMP_Timer_Proc||, CODE, READONLY, ALIGN=2

                  _RMP_Timer_Proc PROC
;;;323    ******************************************************************************/
;;;324    void _RMP_Timer_Proc(void)
000000  4a2a              LDR      r2,|L37.172|
;;;325    {
;;;326        struct RMP_Thd* Thread;
;;;327        
;;;328        /* Process the timer events, if there are any of them */
;;;329        while((&RMP_Delay)!=RMP_Delay.Next)
000002  6850              LDR      r0,[r2,#4]  ; RMP_Delay
000004  4290              CMP      r0,r2
;;;330        {
;;;331            Thread=RMP_DLY2THD(RMP_Delay.Next);
;;;332            /* If the value is more than this, then it means that the time have
;;;333             * already passed and we have to process this */
;;;334            if((RMP_Tick-Thread->Timeout)>(RMP_ALLBITS>>1))
;;;335                break;
;;;336            
;;;337            /* This thread should be processed */
;;;338            RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;339            switch(RMP_THD_STATE(Thread->State))
;;;340            {
;;;341                case RMP_THD_SNDDLY:
;;;342                case RMP_THD_SEMDLY:
;;;343                {
;;;344                    RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;345                    Thread->Retval=RMP_ERR_OPER;
;;;346                    break;
;;;347                }
;;;348                
;;;349                case RMP_THD_RCVDLY:
;;;350                {
;;;351                    Thread->Retval=RMP_ERR_OPER;
;;;352                    break;
;;;353                }
;;;354                
;;;355                case RMP_THD_DELAYED:break;
;;;356                /* Should not get here */
;;;357                default:break;
;;;358            }
;;;359    
;;;360            RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;361            /* Is it suspended? If yes, we can't directly set it running */
;;;362            if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;363            {
;;;364                /* Insert this into the corresponding runqueue */
;;;365                RMP_List_Ins(&(Thread->Run_Head),RMP_Run[Thread->Prio].Prev,&(RMP_Run[Thread->Prio]));
;;;366                /* Set this runlevel as active */
;;;367                RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]|=1<<(Thread->Prio&RMP_WORD_MASK);
;;;368                /* See if we need to pend a scheduling event */
;;;369                if(Thread->Prio>RMP_Cur_Thd->Prio)
;;;370                    RMP_Sched_Pend=1;
;;;371            }
;;;372        }
;;;373    }
000006  bf08              IT       EQ
000008  4770              BXEQ     lr
00000a  e92d01f0          PUSH     {r4-r8}               ;325
00000e  f8dfc0a4          LDR      r12,|L37.180|
000012  4b27              LDR      r3,|L37.176|
000014  f06f0704          MVN      r7,#4                 ;345
000018  4661              MOV      r1,r12                ;334
00001a  2401              MOVS     r4,#1                 ;367
                  |L37.28|
00001c  6850              LDR      r0,[r2,#4]            ;331  ; RMP_Delay
00001e  684e              LDR      r6,[r1,#4]            ;334  ; RMP_Tick
000020  6a05              LDR      r5,[r0,#0x20]         ;334
000022  3808              SUBS     r0,r0,#8              ;334
000024  1b75              SUBS     r5,r6,r5              ;334
000026  f1b54f00          CMP      r5,#0x80000000        ;334
00002a  bf24              ITT      CS
00002c  e8bd01f0          POPCS    {r4-r8}
000030  4770              BXCS     lr
000032  e9d05602          LDRD     r5,r6,[r0,#8]
000036  6035              STR      r5,[r6,#0]
000038  606e              STR      r6,[r5,#4]
00003a  7e05              LDRB     r5,[r0,#0x18]         ;339
00003c  2d03              CMP      r5,#3                 ;339
00003e  d006              BEQ      |L37.78|
000040  2d05              CMP      r5,#5                 ;339
000042  bf0c              ITE      EQ                    ;351
000044  6387              STREQ    r7,[r0,#0x38]         ;351
000046  2d06              CMPNE    r5,#6                 ;339
000048  d006              BEQ      |L37.88|
00004a  2d08              CMP      r5,#8                 ;339
00004c  d104              BNE      |L37.88|
                  |L37.78|
00004e  e9d05600          LDRD     r5,r6,[r0,#0]         ;339
000052  6035              STR      r5,[r6,#0]            ;339
000054  606e              STR      r6,[r5,#4]            ;339
000056  6387              STR      r7,[r0,#0x38]         ;345
                  |L37.88|
000058  6985              LDR      r5,[r0,#0x18]         ;360
00005a  f02505ff          BIC      r5,r5,#0xff           ;360
00005e  f0450501          ORR      r5,r5,#1              ;360
000062  f4157f80          TST      r5,#0x100             ;362
000066  6185              STR      r5,[r0,#0x18]         ;362
000068  d11a              BNE      |L37.160|
00006a  6a45              LDR      r5,[r0,#0x24]         ;365
00006c  f8536035          LDR      r6,[r3,r5,LSL #3]     ;365
000070  eb0305c5          ADD      r5,r3,r5,LSL #3       ;365
000074  6028              STR      r0,[r5,#0]            ;365
000076  6045              STR      r5,[r0,#4]            ;365
000078  6006              STR      r6,[r0,#0]            ;365
00007a  6070              STR      r0,[r6,#4]            ;365
00007c  6a45              LDR      r5,[r0,#0x24]         ;367
00007e  096e              LSRS     r6,r5,#5              ;367
000080  f85c8026          LDR      r8,[r12,r6,LSL #2]    ;367
000084  f005050f          AND      r5,r5,#0xf            ;367
000088  fa04f505          LSL      r5,r4,r5              ;367
00008c  ea480505          ORR      r5,r8,r5              ;367
000090  f84c5026          STR      r5,[r12,r6,LSL #2]    ;367
000094  6a40              LDR      r0,[r0,#0x24]         ;369
000096  698d              LDR      r5,[r1,#0x18]         ;369  ; RMP_Cur_Thd
000098  6a6d              LDR      r5,[r5,#0x24]         ;369
00009a  42a8              CMP      r0,r5                 ;369
00009c  bf88              IT       HI                    ;370
00009e  610c              STRHI    r4,[r1,#0x10]         ;370  ; RMP_Sched_Pend
                  |L37.160|
0000a0  6850              LDR      r0,[r2,#4]            ;329  ; RMP_Delay
0000a2  4290              CMP      r0,r2                 ;329
0000a4  d1ba              BNE      |L37.28|
0000a6  e8bd01f0          POP      {r4-r8}
0000aa  4770              BX       lr
;;;374    /* Begin Function:_RMP_Timer_Proc ********************************************/
                          ENDP

                  |L37.172|
                          DCD      ||.data||+0x20
                  |L37.176|
                          DCD      ||.bss||
                  |L37.180|
                          DCD      ||.data||

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;1531   ******************************************************************************/
;;;1532   int main(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1533   {
;;;1534       ptr_t Count;
;;;1535       /* Initialize the kernel data structures first */
;;;1536       _RMP_Low_Level_Init();
000004  f7fffffe          BL       _RMP_Low_Level_Init
;;;1537       
;;;1538   #if(RMP_USE_HOOKS==RMP_TRUE)
;;;1539       RMP_Start_Hook();
;;;1540   #endif
;;;1541       
;;;1542       RMP_Tick=0;
000008  4b2f              LDR      r3,|L38.200|
00000a  2000              MOVS     r0,#0
00000c  6058              STR      r0,[r3,#4]  ; RMP_Tick
;;;1543       /* Now initialize the kernel data structures */
;;;1544       RMP_Sched_Lock_Cnt=0;
00000e  6098              STR      r0,[r3,#8]  ; RMP_Sched_Lock_Cnt
;;;1545       RMP_Sched_Locked=0;
000010  60d8              STR      r0,[r3,#0xc]  ; RMP_Sched_Locked
;;;1546       RMP_Sched_Pend=0;
000012  6118              STR      r0,[r3,#0x10]  ; RMP_Sched_Pend
;;;1547       RMP_Timer_Pend=0;
000014  6158              STR      r0,[r3,#0x14]  ; RMP_Timer_Pend
;;;1548       
;;;1549       /* Linked lists */
;;;1550       RMP_List_Crt(&RMP_Delay);
000016  f1030120          ADD      r1,r3,#0x20
00001a  6009              STR      r1,[r1,#0]
00001c  6049              STR      r1,[r1,#4]
;;;1551       for(Count=0;Count<RMP_MAX_PREEMPT_PRIO;Count++)
;;;1552           RMP_List_Crt(&RMP_Run[Count]);
00001e  4c2b              LDR      r4,|L38.204|
000020  4601              MOV      r1,r0                 ;1551
000022  bf00              NOP      
                  |L38.36|
000024  eb0402c1          ADD      r2,r4,r1,LSL #3
000028  6012              STR      r2,[r2,#0]
00002a  6052              STR      r2,[r2,#4]
00002c  1c49              ADDS     r1,r1,#1
00002e  2920              CMP      r1,#0x20
000030  d3f8              BCC      |L38.36|
;;;1553       for(Count=0;Count<RMP_BITMAP_SIZE;Count++)
;;;1554           RMP_Bitmap[Count]=0;
000032  4d25              LDR      r5,|L38.200|
000034  6028              STR      r0,[r5,#0]  ; RMP_Bitmap
;;;1555           
;;;1556       /* Now boot into the first thread */
;;;1557       RMP_Clear(&RMP_Init_Thd,sizeof(struct RMP_Thd));
000036  f8dfc098          LDR      r12,|L38.208|
00003a  273c              MOVS     r7,#0x3c
00003c  2601              MOVS     r6,#1
00003e  f04f080f          MOV      r8,#0xf
000042  4661              MOV      r1,r12
000044  2207              MOVS     r2,#7
000046  f8cc0000          STR      r0,[r12,#0]
                  |L38.74|
00004a  6048              STR      r0,[r1,#4]
00004c  f8410f08          STR      r0,[r1,#8]!
000050  1e52              SUBS     r2,r2,#1
000052  d1fa              BNE      |L38.74|
000054  eb0c0188          ADD      r1,r12,r8,LSL #2
000058  f0070203          AND      r2,r7,#3
00005c  f0170f03          TST      r7,#3
000060  d00c              BEQ      |L38.124|
000062  1e49              SUBS     r1,r1,#1
000064  f0120f01          TST      r2,#1
000068  bf18              IT       NE
00006a  f8010f01          STRBNE   r0,[r1,#1]!
00006e  0852              LSRS     r2,r2,#1
000070  d004              BEQ      |L38.124|
                  |L38.114|
000072  7048              STRB     r0,[r1,#1]
000074  f8010f02          STRB     r0,[r1,#2]!
000078  1e52              SUBS     r2,r2,#1
00007a  d1fa              BNE      |L38.114|
                  |L38.124|
;;;1558       RMP_Init_Thd.Prio=0;
00007c  4a14              LDR      r2,|L38.208|
00007e  6250              STR      r0,[r2,#0x24]  ; RMP_Init_Thd
;;;1559       RMP_Init_Thd.Slices=10;
000080  200a              MOVS     r0,#0xa
000082  61d0              STR      r0,[r2,#0x1c]  ; RMP_Init_Thd
;;;1560       RMP_Init_Thd.Slices_Left=10;
000084  6210              STR      r0,[r2,#0x20]  ; RMP_Init_Thd
;;;1561       RMP_Init_Thd.State=RMP_THD_RUNNING;
000086  6196              STR      r6,[r2,#0x18]  ; RMP_Init_Thd
;;;1562       RMP_Init_Thd.Stack=RMP_INIT_STACK;
000088  f1a20044          SUB      r0,r2,#0x44
00008c  6350              STR      r0,[r2,#0x34]  ; RMP_Init_Thd
;;;1563       
;;;1564       /* Initialize sending list */
;;;1565       RMP_List_Crt(&(RMP_Init_Thd.Snd_List));
00008e  f1020110          ADD      r1,r2,#0x10
000092  6111              STR      r1,[r2,#0x10]
000094  6151              STR      r1,[r2,#0x14]
;;;1566       
;;;1567       /* Insert this into the corresponding runqueue */
;;;1568       RMP_List_Ins(&(RMP_Init_Thd.Run_Head),RMP_Run[0].Prev,&(RMP_Run[0]));
000096  6821              LDR      r1,[r4,#0]  ; RMP_Run
000098  3044              ADDS     r0,r0,#0x44
00009a  f5a07c00          SUB      r12,r0,#0x200
00009e  f8cc0000          STR      r0,[r12,#0]
0000a2  f8c0c004          STR      r12,[r0,#4]
0000a6  6001              STR      r1,[r0,#0]
0000a8  6048              STR      r0,[r1,#4]
;;;1569       /* Set this runlevel as active - in fact it is always active */
;;;1570       RMP_Bitmap[0]|=1;
0000aa  6828              LDR      r0,[r5,#0]  ; RMP_Bitmap
0000ac  f0400001          ORR      r0,r0,#1
0000b0  6028              STR      r0,[r5,#0]  ; RMP_Bitmap
;;;1571       
;;;1572       /* Set current thread and stack */
;;;1573       RMP_Cur_Thd=(struct RMP_Thd*)(&RMP_Init_Thd);
0000b2  619a              STR      r2,[r3,#0x18]  ; RMP_Cur_Thd
;;;1574       RMP_Cur_SP=RMP_Init_Thd.Stack;
0000b4  6b50              LDR      r0,[r2,#0x34]  ; RMP_Init_Thd
0000b6  61d8              STR      r0,[r3,#0x1c]  ; RMP_Cur_SP
;;;1575       
;;;1576       /* Now jump to the user function and will never return. Initialization of stack is not needed */
;;;1577       _RMP_Start((ptr_t)RMP_Init, (ptr_t)RMP_Init_Thd.Stack);
0000b8  6b51              LDR      r1,[r2,#0x34]  ; RMP_Init_Thd
0000ba  4806              LDR      r0,|L38.212|
0000bc  f7fffffe          BL       _RMP_Start
;;;1578       
;;;1579       return 0;
0000c0  2000              MOVS     r0,#0
;;;1580   }
0000c2  e8bd81f0          POP      {r4-r8,pc}
;;;1581   /* End Function:main *********************************************************/
                          ENDP

0000c6  0000              DCW      0x0000
                  |L38.200|
                          DCD      ||.data||
                  |L38.204|
                          DCD      ||.bss||
                  |L38.208|
                          DCD      ||.bss||+0x200
                  |L38.212|
                          DCD      RMP_Init

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  RMP_Run
                          %        256
                  RMP_Init_Stack
                          %        256
                  RMP_Init_Thd
                          %        60

                          AREA ||.data||, DATA, ALIGN=2

                  RMP_Bitmap
                          DCD      0x00000000
                  RMP_Tick
                          DCD      0x00000000
                  RMP_Sched_Lock_Cnt
                          DCD      0x00000000
                  RMP_Sched_Locked
                          DCD      0x00000000
                  RMP_Sched_Pend
                          DCD      0x00000000
                  RMP_Timer_Pend
                          DCD      0x00000000
                  RMP_Cur_Thd
                          DCD      0x00000000
                  RMP_Cur_SP
                          DCD      0x00000000
                  RMP_Delay
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\..\\MProkaron\\Kernel\\kernel.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_kernel_c_346ad0e8____REV16|
#line 464 "D:\\Program_Files_x86\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.1.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___8_kernel_c_346ad0e8____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_kernel_c_346ad0e8____REVSH|
#line 479
|__asm___8_kernel_c_346ad0e8____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___8_kernel_c_346ad0e8____RRX|
#line 666
|__asm___8_kernel_c_346ad0e8____RRX| PROC
#line 667

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
