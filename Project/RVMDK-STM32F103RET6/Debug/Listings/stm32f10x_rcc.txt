; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f10x_rcc.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f10x_rcc.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32F10x_StdPeriph_Lib_V3.3.0\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\M0P0_Library\STM32F10x_StdPeriph_Lib_V3.3.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\..\M0P0_Library\STM32F10x_StdPeriph_Lib_V3.3.0\Libraries\CMSIS -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F103RET6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f10x_rcc.crf ..\..\..\M0P0_Library\STM32F10x_StdPeriph_Lib_V3.3.0\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_rcc.c]
                          THUMB

                          AREA ||i.RCC_ADCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_ADCCLKConfig PROC
;;;774      */
;;;775    void RCC_ADCCLKConfig(uint32_t RCC_PCLK2)
000000  4903              LDR      r1,|L1.16|
;;;776    {
;;;777      uint32_t tmpreg = 0;
;;;778      /* Check the parameters */
;;;779      assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
;;;780      tmpreg = RCC->CFGR;
000002  684a              LDR      r2,[r1,#4]
;;;781      /* Clear ADCPRE[1:0] bits */
;;;782      tmpreg &= CFGR_ADCPRE_Reset_Mask;
000004  f4224240          BIC      r2,r2,#0xc000
;;;783      /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
;;;784      tmpreg |= RCC_PCLK2;
000008  4310              ORRS     r0,r0,r2
;;;785      /* Store the new value */
;;;786      RCC->CFGR = tmpreg;
00000a  6048              STR      r0,[r1,#4]
;;;787    }
00000c  4770              BX       lr
;;;788    
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      0x40021000

                          AREA ||i.RCC_AHBPeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHBPeriphClockCmd PROC
;;;1070     */
;;;1071   void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
000000  4a04              LDR      r2,|L2.20|
;;;1072   {
;;;1073     /* Check the parameters */
;;;1074     assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
;;;1075     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1076   
;;;1077     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1078     {
;;;1079       RCC->AHBENR |= RCC_AHBPeriph;
;;;1080     }
;;;1081     else
;;;1082     {
;;;1083       RCC->AHBENR &= ~RCC_AHBPeriph;
000004  6951              LDR      r1,[r2,#0x14]
000006  bf14              ITE      NE                    ;1079
000008  4308              ORRNE    r0,r0,r1              ;1079
00000a  ea210000          BICEQ    r0,r1,r0
00000e  6150              STR      r0,[r2,#0x14]         ;1079
;;;1084     }
;;;1085   }
000010  4770              BX       lr
;;;1086   
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockCmd PROC
;;;1132     */
;;;1133   void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L3.20|
;;;1134   {
;;;1135     /* Check the parameters */
;;;1136     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1137     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1138     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1139     {
;;;1140       RCC->APB1ENR |= RCC_APB1Periph;
;;;1141     }
;;;1142     else
;;;1143     {
;;;1144       RCC->APB1ENR &= ~RCC_APB1Periph;
000004  69d1              LDR      r1,[r2,#0x1c]
000006  bf14              ITE      NE                    ;1140
000008  4308              ORRNE    r0,r0,r1              ;1140
00000a  ea210000          BICEQ    r0,r1,r0
00000e  61d0              STR      r0,[r2,#0x1c]         ;1140
;;;1145     }
;;;1146   }
000010  4770              BX       lr
;;;1147   
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphResetCmd PROC
;;;1222     */
;;;1223   void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L4.20|
;;;1224   {
;;;1225     /* Check the parameters */
;;;1226     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1227     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1228     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1229     {
;;;1230       RCC->APB1RSTR |= RCC_APB1Periph;
;;;1231     }
;;;1232     else
;;;1233     {
;;;1234       RCC->APB1RSTR &= ~RCC_APB1Periph;
000004  6911              LDR      r1,[r2,#0x10]
000006  bf14              ITE      NE                    ;1230
000008  4308              ORRNE    r0,r0,r1              ;1230
00000a  ea210000          BICEQ    r0,r1,r0
00000e  6110              STR      r0,[r2,#0x10]         ;1230
;;;1235     }
;;;1236   }
000010  4770              BX       lr
;;;1237   
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockCmd PROC
;;;1101     */
;;;1102   void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L5.20|
;;;1103   {
;;;1104     /* Check the parameters */
;;;1105     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1106     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1107     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1108     {
;;;1109       RCC->APB2ENR |= RCC_APB2Periph;
;;;1110     }
;;;1111     else
;;;1112     {
;;;1113       RCC->APB2ENR &= ~RCC_APB2Periph;
000004  6991              LDR      r1,[r2,#0x18]
000006  bf14              ITE      NE                    ;1109
000008  4308              ORRNE    r0,r0,r1              ;1109
00000a  ea210000          BICEQ    r0,r1,r0
00000e  6190              STR      r0,[r2,#0x18]         ;1109
;;;1114     }
;;;1115   }
000010  4770              BX       lr
;;;1116   
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphResetCmd PROC
;;;1191     */
;;;1192   void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L6.20|
;;;1193   {
;;;1194     /* Check the parameters */
;;;1195     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1196     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1197     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1198     {
;;;1199       RCC->APB2RSTR |= RCC_APB2Periph;
;;;1200     }
;;;1201     else
;;;1202     {
;;;1203       RCC->APB2RSTR &= ~RCC_APB2Periph;
000004  68d1              LDR      r1,[r2,#0xc]
000006  bf14              ITE      NE                    ;1199
000008  4308              ORRNE    r0,r0,r1              ;1199
00000a  ea210000          BICEQ    r0,r1,r0
00000e  60d0              STR      r0,[r2,#0xc]          ;1199
;;;1204     }
;;;1205   }
000010  4770              BX       lr
;;;1206   
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      0x40021000

                          AREA ||i.RCC_AdjustHSICalibrationValue||, CODE, READONLY, ALIGN=2

                  RCC_AdjustHSICalibrationValue PROC
;;;342      */
;;;343    void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
000000  4903              LDR      r1,|L7.16|
;;;344    {
;;;345      uint32_t tmpreg = 0;
;;;346      /* Check the parameters */
;;;347      assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
;;;348      tmpreg = RCC->CR;
000002  680a              LDR      r2,[r1,#0]
;;;349      /* Clear HSITRIM[4:0] bits */
;;;350      tmpreg &= CR_HSITRIM_Mask;
000004  f02202f8          BIC      r2,r2,#0xf8
;;;351      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;352      tmpreg |= (uint32_t)HSICalibrationValue << 3;
000008  ea4200c0          ORR      r0,r2,r0,LSL #3
;;;353      /* Store the new value */
;;;354      RCC->CR = tmpreg;
00000c  6008              STR      r0,[r1,#0]
;;;355    }
00000e  4770              BX       lr
;;;356    
                          ENDP

                  |L7.16|
                          DCD      0x40021000

                          AREA ||i.RCC_BackupResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_BackupResetCmd PROC
;;;1243     */
;;;1244   void RCC_BackupResetCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L8.8|
;;;1245   {
;;;1246     /* Check the parameters */
;;;1247     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1248     *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;1249   }
000004  4770              BX       lr
;;;1250   
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      0x42420440

                          AREA ||i.RCC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RCC_ClearFlag PROC
;;;1377     */
;;;1378   void RCC_ClearFlag(void)
000000  4802              LDR      r0,|L9.12|
;;;1379   {
;;;1380     /* Set RMVF bit to clear the reset flags */
;;;1381     RCC->CSR |= CSR_RMVF_Set;
000002  6a41              LDR      r1,[r0,#0x24]
000004  f0417180          ORR      r1,r1,#0x1000000
000008  6241              STR      r1,[r0,#0x24]
;;;1382   }
00000a  4770              BX       lr
;;;1383   
                          ENDP

                  |L9.12|
                          DCD      0x40021000

                          AREA ||i.RCC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RCC_ClearITPendingBit PROC
;;;1454     */
;;;1455   void RCC_ClearITPendingBit(uint8_t RCC_IT)
000000  4901              LDR      r1,|L10.8|
;;;1456   {
;;;1457     /* Check the parameters */
;;;1458     assert_param(IS_RCC_CLEAR_IT(RCC_IT));
;;;1459   
;;;1460     /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
;;;1461        pending bits */
;;;1462     *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
000002  7288              STRB     r0,[r1,#0xa]
;;;1463   }
000004  4770              BX       lr
;;;1464   
                          ENDP

000006  0000              DCW      0x0000
                  |L10.8|
                          DCD      0x40021000

                          AREA ||i.RCC_ClockSecuritySystemCmd||, CODE, READONLY, ALIGN=2

                  RCC_ClockSecuritySystemCmd PROC
;;;1256     */
;;;1257   void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L11.8|
;;;1258   {
;;;1259     /* Check the parameters */
;;;1260     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1261     *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
000002  64c8              STR      r0,[r1,#0x4c]
;;;1262   }
000004  4770              BX       lr
;;;1263   
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      0x42420000

                          AREA ||i.RCC_DeInit||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;225      */
;;;226    void RCC_DeInit(void)
000000  480d              LDR      r0,|L12.56|
;;;227    {
;;;228      /* Set HSION bit */
;;;229      RCC->CR |= (uint32_t)0x00000001;
000002  6801              LDR      r1,[r0,#0]
000004  f0410101          ORR      r1,r1,#1
000008  6001              STR      r1,[r0,#0]
;;;230    
;;;231      /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
;;;232    #ifndef STM32F10X_CL
;;;233      RCC->CFGR &= (uint32_t)0xF8FF0000;
00000a  6841              LDR      r1,[r0,#4]
00000c  4a0b              LDR      r2,|L12.60|
00000e  4011              ANDS     r1,r1,r2
000010  6041              STR      r1,[r0,#4]
;;;234    #else
;;;235      RCC->CFGR &= (uint32_t)0xF0FF0000;
;;;236    #endif /* STM32F10X_CL */   
;;;237      
;;;238      /* Reset HSEON, CSSON and PLLON bits */
;;;239      RCC->CR &= (uint32_t)0xFEF6FFFF;
000012  6801              LDR      r1,[r0,#0]
000014  f4212110          BIC      r1,r1,#0x90000
000018  f0217180          BIC      r1,r1,#0x1000000
00001c  6001              STR      r1,[r0,#0]
;;;240    
;;;241      /* Reset HSEBYP bit */
;;;242      RCC->CR &= (uint32_t)0xFFFBFFFF;
00001e  6801              LDR      r1,[r0,#0]
000020  f4212180          BIC      r1,r1,#0x40000
000024  6001              STR      r1,[r0,#0]
;;;243    
;;;244      /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
;;;245      RCC->CFGR &= (uint32_t)0xFF80FFFF;
000026  6841              LDR      r1,[r0,#4]
000028  f42101fe          BIC      r1,r1,#0x7f0000
00002c  6041              STR      r1,[r0,#4]
;;;246    
;;;247    #ifdef STM32F10X_CL
;;;248      /* Reset PLL2ON and PLL3ON bits */
;;;249      RCC->CR &= (uint32_t)0xEBFFFFFF;
;;;250    
;;;251      /* Disable all interrupts and clear pending bits  */
;;;252      RCC->CIR = 0x00FF0000;
;;;253    
;;;254      /* Reset CFGR2 register */
;;;255      RCC->CFGR2 = 0x00000000;
;;;256    #elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) 
;;;257      /* Disable all interrupts and clear pending bits  */
;;;258      RCC->CIR = 0x009F0000;
;;;259    
;;;260      /* Reset CFGR2 register */
;;;261      RCC->CFGR2 = 0x00000000;      
;;;262    #else
;;;263      /* Disable all interrupts and clear pending bits  */
;;;264      RCC->CIR = 0x009F0000;
00002e  f44f011f          MOV      r1,#0x9f0000
000032  6081              STR      r1,[r0,#8]
;;;265    #endif /* STM32F10X_CL */
;;;266    
;;;267    }
000034  4770              BX       lr
;;;268    
                          ENDP

000036  0000              DCW      0x0000
                  |L12.56|
                          DCD      0x40021000
                  |L12.60|
                          DCD      0xf8ff0000

                          AREA ||i.RCC_GetClocksFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetClocksFreq PROC
;;;914      */
;;;915    void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
000000  4925              LDR      r1,|L13.152|
;;;916    {
000002  b410              PUSH     {r4}
;;;917      uint32_t tmp = 0, pllmull = 0, pllsource = 0, presc = 0;
;;;918    
;;;919    #ifdef  STM32F10X_CL
;;;920      uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;
;;;921    #endif /* STM32F10X_CL */
;;;922    
;;;923    #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL)
;;;924      uint32_t prediv1factor = 0;
;;;925    #endif
;;;926        
;;;927      /* Get SYSCLK source -------------------------------------------------------*/
;;;928      tmp = RCC->CFGR & CFGR_SWS_Mask;
000004  684a              LDR      r2,[r1,#4]
000006  f012030c          ANDS     r3,r2,#0xc
;;;929      
;;;930      switch (tmp)
;;;931      {
;;;932        case 0x00:  /* HSI used as system clock */
;;;933          RCC_Clocks->SYSCLK_Frequency = HSI_Value;
00000a  4a24              LDR      r2,|L13.156|
00000c  bf18              IT       NE                    ;930
00000e  2b04              CMPNE    r3,#4                 ;930
000010  d001              BEQ      |L13.22|
000012  2b08              CMP      r3,#8                 ;930
000014  d001              BEQ      |L13.26|
                  |L13.22|
;;;934          break;
000016  6002              STR      r2,[r0,#0]
000018  e015              B        |L13.70|
                  |L13.26|
;;;935        case 0x04:  /* HSE used as system clock */
;;;936          RCC_Clocks->SYSCLK_Frequency = HSE_Value;
;;;937          break;
;;;938        case 0x08:  /* PLL used as system clock */
;;;939    
;;;940          /* Get PLL clock source and multiplication factor ----------------------*/
;;;941          pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
00001a  684a              LDR      r2,[r1,#4]
;;;942          pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
00001c  684b              LDR      r3,[r1,#4]
00001e  f4021270          AND      r2,r2,#0x3c0000       ;941
;;;943          
;;;944    #ifndef STM32F10X_CL      
;;;945          pllmull = ( pllmull >> 18) + 2;
000022  f04f0c02          MOV      r12,#2
000026  f4133f80          TST      r3,#0x10000           ;942
00002a  eb0c4292          ADD      r2,r12,r2,LSR #18
;;;946          
;;;947          if (pllsource == 0x00)
00002e  d003              BEQ      |L13.56|
;;;948          {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;949            RCC_Clocks->SYSCLK_Frequency = (HSI_Value >> 1) * pllmull;
;;;950          }
;;;951          else
;;;952          {
;;;953     #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL)
;;;954           prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
;;;955           /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;956           RCC_Clocks->SYSCLK_Frequency = (HSE_Value / prediv1factor) * pllmull; 
;;;957     #else
;;;958            /* HSE selected as PLL clock entry */
;;;959            if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
000030  684b              LDR      r3,[r1,#4]
000032  f4133f00          TST      r3,#0x20000
000036  d003              BEQ      |L13.64|
                  |L13.56|
;;;960            {/* HSE oscillator clock divided by 2 */
;;;961              RCC_Clocks->SYSCLK_Frequency = (HSE_Value >> 1) * pllmull;
000038  4b19              LDR      r3,|L13.160|
00003a  435a              MULS     r2,r3,r2
00003c  6002              STR      r2,[r0,#0]
00003e  e002              B        |L13.70|
                  |L13.64|
;;;962            }
;;;963            else
;;;964            {
;;;965              RCC_Clocks->SYSCLK_Frequency = HSE_Value * pllmull;
000040  4b16              LDR      r3,|L13.156|
000042  435a              MULS     r2,r3,r2
000044  6002              STR      r2,[r0,#0]
                  |L13.70|
;;;966            }
;;;967     #endif
;;;968          }
;;;969    #else
;;;970          pllmull = pllmull >> 18;
;;;971          
;;;972          if (pllmull != 0x0D)
;;;973          {
;;;974             pllmull += 2;
;;;975          }
;;;976          else
;;;977          { /* PLL multiplication factor = PLL input clock * 6.5 */
;;;978            pllmull = 13 / 2; 
;;;979          }
;;;980                
;;;981          if (pllsource == 0x00)
;;;982          {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;983            RCC_Clocks->SYSCLK_Frequency = (HSI_Value >> 1) * pllmull;
;;;984          }
;;;985          else
;;;986          {/* PREDIV1 selected as PLL clock entry */
;;;987            
;;;988            /* Get PREDIV1 clock source and division factor */
;;;989            prediv1source = RCC->CFGR2 & CFGR2_PREDIV1SRC;
;;;990            prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
;;;991            
;;;992            if (prediv1source == 0)
;;;993            { /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;994              RCC_Clocks->SYSCLK_Frequency = (HSE_Value / prediv1factor) * pllmull;          
;;;995            }
;;;996            else
;;;997            {/* PLL2 clock selected as PREDIV1 clock entry */
;;;998              
;;;999              /* Get PREDIV2 division factor and PLL2 multiplication factor */
;;;1000             prediv2factor = ((RCC->CFGR2 & CFGR2_PREDIV2) >> 4) + 1;
;;;1001             pll2mull = ((RCC->CFGR2 & CFGR2_PLL2MUL) >> 8 ) + 2; 
;;;1002             RCC_Clocks->SYSCLK_Frequency = (((HSE_Value / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
;;;1003           }
;;;1004         }
;;;1005   #endif /* STM32F10X_CL */ 
;;;1006         break;
;;;1007   
;;;1008       default:
;;;1009         RCC_Clocks->SYSCLK_Frequency = HSI_Value;
;;;1010         break;
;;;1011     }
;;;1012   
;;;1013     /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
;;;1014     /* Get HCLK prescaler */
;;;1015     tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
000046  684a              LDR      r2,[r1,#4]
;;;1016     tmp = tmp >> 4;
;;;1017     presc = APBAHBPrescTable[tmp];
;;;1018     /* HCLK clock frequency */
;;;1019     RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
;;;1020     /* Get PCLK1 prescaler */
;;;1021     tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
;;;1022     tmp = tmp >> 8;
;;;1023     presc = APBAHBPrescTable[tmp];
;;;1024     /* PCLK1 clock frequency */
;;;1025     RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
;;;1026     /* Get PCLK2 prescaler */
;;;1027     tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
;;;1028     tmp = tmp >> 11;
;;;1029     presc = APBAHBPrescTable[tmp];
;;;1030     /* PCLK2 clock frequency */
;;;1031     RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
;;;1032     /* Get ADCCLK prescaler */
;;;1033     tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
;;;1034     tmp = tmp >> 14;
;;;1035     presc = ADCPrescTable[tmp];
;;;1036     /* ADCCLK clock frequency */
;;;1037     RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
;;;1038   }
000048  230f              MOVS     r3,#0xf
00004a  ea031212          AND      r2,r3,r2,LSR #4
00004e  4b15              LDR      r3,|L13.164|
000050  5c9a              LDRB     r2,[r3,r2]            ;1017
000052  f8d0c000          LDR      r12,[r0,#0]           ;1019
000056  fa2cf202          LSR      r2,r12,r2             ;1019
00005a  6042              STR      r2,[r0,#4]            ;1021
00005c  f8d1c004          LDR      r12,[r1,#4]           ;1021
000060  2407              MOVS     r4,#7
000062  ea042c1c          AND      r12,r4,r12,LSR #8
000066  f813c00c          LDRB     r12,[r3,r12]          ;1023
00006a  fa22fc0c          LSR      r12,r2,r12            ;1025
00006e  f8c0c008          STR      r12,[r0,#8]           ;1027
000072  f8d1c004          LDR      r12,[r1,#4]           ;1027
000076  ea042cdc          AND      r12,r4,r12,LSR #11
00007a  f813300c          LDRB     r3,[r3,r12]           ;1029
00007e  40da              LSRS     r2,r2,r3              ;1031
000080  60c2              STR      r2,[r0,#0xc]          ;1033
000082  6849              LDR      r1,[r1,#4]            ;1033
000084  2303              MOVS     r3,#3
000086  ea033191          AND      r1,r3,r1,LSR #14
00008a  4b07              LDR      r3,|L13.168|
00008c  5c59              LDRB     r1,[r3,r1]            ;1035
00008e  fbb2f1f1          UDIV     r1,r2,r1              ;1037
000092  6101              STR      r1,[r0,#0x10]         ;1037
000094  bc10              POP      {r4}
000096  4770              BX       lr
;;;1039   
                          ENDP

                  |L13.152|
                          DCD      0x40021000
                  |L13.156|
                          DCD      0x007a1200
                  |L13.160|
                          DCD      0x003d0900
                  |L13.164|
                          DCD      ||.data||+0x4
                  |L13.168|
                          DCD      ||.data||

                          AREA ||i.RCC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetFlagStatus PROC
;;;1332     */
;;;1333   FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
000000  2200              MOVS     r2,#0
;;;1334   {
;;;1335     uint32_t tmp = 0;
;;;1336     uint32_t statusreg = 0;
;;;1337     FlagStatus bitstatus = RESET;
;;;1338     /* Check the parameters */
;;;1339     assert_param(IS_RCC_FLAG(RCC_FLAG));
;;;1340   
;;;1341     /* Get the RCC register index */
;;;1342     tmp = RCC_FLAG >> 5;
000002  0943              LSRS     r3,r0,#5
;;;1343     if (tmp == 1)               /* The flag to check is in CR register */
;;;1344     {
;;;1345       statusreg = RCC->CR;
000004  4909              LDR      r1,|L14.44|
000006  2b01              CMP      r3,#1                 ;1343
000008  bf08              IT       EQ
00000a  6809              LDREQ    r1,[r1,#0]
00000c  d003              BEQ      |L14.22|
;;;1346     }
;;;1347     else if (tmp == 2)          /* The flag to check is in BDCR register */
00000e  2b02              CMP      r3,#2
;;;1348     {
;;;1349       statusreg = RCC->BDCR;
000010  bf0c              ITE      EQ
000012  6a09              LDREQ    r1,[r1,#0x20]
;;;1350     }
;;;1351     else                       /* The flag to check is in CSR register */
;;;1352     {
;;;1353       statusreg = RCC->CSR;
000014  6a49              LDRNE    r1,[r1,#0x24]
                  |L14.22|
;;;1354     }
;;;1355   
;;;1356     /* Get the flag position */
;;;1357     tmp = RCC_FLAG & FLAG_Mask;
000016  f000001f          AND      r0,r0,#0x1f
;;;1358     if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
00001a  2301              MOVS     r3,#1
00001c  fa03f000          LSL      r0,r3,r0
000020  4208              TST      r0,r1
;;;1359     {
;;;1360       bitstatus = SET;
000022  bf18              IT       NE
000024  2201              MOVNE    r2,#1
;;;1361     }
;;;1362     else
;;;1363     {
;;;1364       bitstatus = RESET;
;;;1365     }
;;;1366   
;;;1367     /* Return the flag status */
;;;1368     return bitstatus;
000026  4610              MOV      r0,r2
;;;1369   }
000028  4770              BX       lr
;;;1370   
                          ENDP

00002a  0000              DCW      0x0000
                  |L14.44|
                          DCD      0x40021000

                          AREA ||i.RCC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetITStatus PROC
;;;1408     */
;;;1409   ITStatus RCC_GetITStatus(uint8_t RCC_IT)
000000  4a03              LDR      r2,|L15.16|
;;;1410   {
000002  4601              MOV      r1,r0
;;;1411     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1412     /* Check the parameters */
;;;1413     assert_param(IS_RCC_GET_IT(RCC_IT));
;;;1414   
;;;1415     /* Check the status of the specified RCC interrupt */
;;;1416     if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
000006  6892              LDR      r2,[r2,#8]
000008  420a              TST      r2,r1
;;;1417     {
;;;1418       bitstatus = SET;
00000a  bf18              IT       NE
00000c  2001              MOVNE    r0,#1
;;;1419     }
;;;1420     else
;;;1421     {
;;;1422       bitstatus = RESET;
;;;1423     }
;;;1424   
;;;1425     /* Return the RCC_IT status */
;;;1426     return  bitstatus;
;;;1427   }
00000e  4770              BX       lr
;;;1428   
                          ENDP

                  |L15.16|
                          DCD      0x40021000

                          AREA ||i.RCC_GetSYSCLKSource||, CODE, READONLY, ALIGN=2

                  RCC_GetSYSCLKSource PROC
;;;595      */
;;;596    uint8_t RCC_GetSYSCLKSource(void)
000000  4802              LDR      r0,|L16.12|
;;;597    {
;;;598      return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));
000002  6840              LDR      r0,[r0,#4]
000004  f000000c          AND      r0,r0,#0xc
;;;599    }
000008  4770              BX       lr
;;;600    
                          ENDP

00000a  0000              DCW      0x0000
                  |L16.12|
                          DCD      0x40021000

                          AREA ||i.RCC_HCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_HCLKConfig PROC
;;;616      */
;;;617    void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
000000  4903              LDR      r1,|L17.16|
;;;618    {
;;;619      uint32_t tmpreg = 0;
;;;620      /* Check the parameters */
;;;621      assert_param(IS_RCC_HCLK(RCC_SYSCLK));
;;;622      tmpreg = RCC->CFGR;
000002  684a              LDR      r2,[r1,#4]
;;;623      /* Clear HPRE[3:0] bits */
;;;624      tmpreg &= CFGR_HPRE_Reset_Mask;
000004  f02202f0          BIC      r2,r2,#0xf0
;;;625      /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;626      tmpreg |= RCC_SYSCLK;
000008  4310              ORRS     r0,r0,r2
;;;627      /* Store the new value */
;;;628      RCC->CFGR = tmpreg;
00000a  6048              STR      r0,[r1,#4]
;;;629    }
00000c  4770              BX       lr
;;;630    
                          ENDP

00000e  0000              DCW      0x0000
                  |L17.16|
                          DCD      0x40021000

                          AREA ||i.RCC_HSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_HSEConfig PROC
;;;278      */
;;;279    void RCC_HSEConfig(uint32_t RCC_HSE)
000000  490c              LDR      r1,|L18.52|
;;;280    {
;;;281      /* Check the parameters */
;;;282      assert_param(IS_RCC_HSE(RCC_HSE));
;;;283      /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
;;;284      /* Reset HSEON bit */
;;;285      RCC->CR &= CR_HSEON_Reset;
000002  680a              LDR      r2,[r1,#0]
000004  f4223280          BIC      r2,r2,#0x10000
000008  600a              STR      r2,[r1,#0]
;;;286      /* Reset HSEBYP bit */
;;;287      RCC->CR &= CR_HSEBYP_Reset;
00000a  680a              LDR      r2,[r1,#0]
00000c  f4222280          BIC      r2,r2,#0x40000
000010  600a              STR      r2,[r1,#0]
;;;288      /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
;;;289      switch(RCC_HSE)
000012  f5b03f80          CMP      r0,#0x10000
;;;290      {
;;;291        case RCC_HSE_ON:
;;;292          /* Set HSEON bit */
;;;293          RCC->CR |= CR_HSEON_Set;
000016  bf04              ITT      EQ
000018  6808              LDREQ    r0,[r1,#0]
00001a  f4403080          ORREQ    r0,r0,#0x10000
00001e  d006              BEQ      |L18.46|
000020  f5b02f80          CMP      r0,#0x40000           ;289
;;;294          break;
;;;295          
;;;296        case RCC_HSE_Bypass:
;;;297          /* Set HSEBYP and HSEON bits */
;;;298          RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
000024  bf06              ITTE     EQ
000026  6808              LDREQ    r0,[r1,#0]
000028  f44020a0          ORREQ    r0,r0,#0x50000
;;;299          break;
;;;300          
;;;301        default:
;;;302          break;
;;;303      }
;;;304    }
00002c  4770              BXNE     lr
                  |L18.46|
00002e  6008              STR      r0,[r1,#0]            ;298
000030  4770              BX       lr
;;;305    
                          ENDP

000032  0000              DCW      0x0000
                  |L18.52|
                          DCD      0x40021000

                          AREA ||i.RCC_HSICmd||, CODE, READONLY, ALIGN=2

                  RCC_HSICmd PROC
;;;362      */
;;;363    void RCC_HSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L19.8|
;;;364    {
;;;365      /* Check the parameters */
;;;366      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;367      *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;368    }
000004  4770              BX       lr
;;;369    
                          ENDP

000006  0000              DCW      0x0000
                  |L19.8|
                          DCD      0x42420000

                          AREA ||i.RCC_ITConfig||, CODE, READONLY, ALIGN=2

                  RCC_ITConfig PROC
;;;708      */
;;;709    void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
000000  4a04              LDR      r2,|L20.20|
;;;710    {
;;;711      /* Check the parameters */
;;;712      assert_param(IS_RCC_IT(RCC_IT));
;;;713      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;714      if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;715      {
;;;716        /* Perform Byte access to RCC_CIR bits to enable the selected interrupts */
;;;717        *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
;;;718      }
;;;719      else
;;;720      {
;;;721        /* Perform Byte access to RCC_CIR bits to disable the selected interrupts */
;;;722        *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
000004  7a51              LDRB     r1,[r2,#9]
000006  bf14              ITE      NE                    ;717
000008  4308              ORRNE    r0,r0,r1              ;717
00000a  ea210000          BICEQ    r0,r1,r0
00000e  7250              STRB     r0,[r2,#9]            ;717
;;;723      }
;;;724    }
000010  4770              BX       lr
;;;725    
                          ENDP

000012  0000              DCW      0x0000
                  |L20.20|
                          DCD      0x40021000

                          AREA ||i.RCC_LSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_LSEConfig PROC
;;;837      */
;;;838    void RCC_LSEConfig(uint8_t RCC_LSE)
000000  4907              LDR      r1,|L21.32|
;;;839    {
;;;840      /* Check the parameters */
;;;841      assert_param(IS_RCC_LSE(RCC_LSE));
;;;842      /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
;;;843      /* Reset LSEON bit */
;;;844      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
000002  2200              MOVS     r2,#0
000004  f8812020          STRB     r2,[r1,#0x20]
;;;845      /* Reset LSEBYP bit */
;;;846      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
000008  f8812020          STRB     r2,[r1,#0x20]
;;;847      /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
;;;848      switch(RCC_LSE)
00000c  2801              CMP      r0,#1
00000e  d003              BEQ      |L21.24|
000010  2804              CMP      r0,#4
;;;849      {
;;;850        case RCC_LSE_ON:
;;;851          /* Set LSEON bit */
;;;852          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
;;;853          break;
;;;854          
;;;855        case RCC_LSE_Bypass:
;;;856          /* Set LSEBYP and LSEON bits */
;;;857          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
000012  bf0c              ITE      EQ
000014  2005              MOVEQ    r0,#5
;;;858          break;            
;;;859          
;;;860        default:
;;;861          break;      
;;;862      }
;;;863    }
000016  4770              BXNE     lr
                  |L21.24|
000018  f8810020          STRB     r0,[r1,#0x20]         ;857
00001c  4770              BX       lr
;;;864    
                          ENDP

00001e  0000              DCW      0x0000
                  |L21.32|
                          DCD      0x40021000

                          AREA ||i.RCC_LSICmd||, CODE, READONLY, ALIGN=2

                  RCC_LSICmd PROC
;;;870      */
;;;871    void RCC_LSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L22.8|
;;;872    {
;;;873      /* Check the parameters */
;;;874      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;875      *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;876    }
000004  4770              BX       lr
;;;877    
                          ENDP

000006  0000              DCW      0x0000
                  |L22.8|
                          DCD      0x42420480

                          AREA ||i.RCC_MCOConfig||, CODE, READONLY, ALIGN=2

                  RCC_MCOConfig PROC
;;;1288     */
;;;1289   void RCC_MCOConfig(uint8_t RCC_MCO)
000000  4901              LDR      r1,|L23.8|
;;;1290   {
;;;1291     /* Check the parameters */
;;;1292     assert_param(IS_RCC_MCO(RCC_MCO));
;;;1293   
;;;1294     /* Perform Byte access to MCO bits to select the MCO source */
;;;1295     *(__IO uint8_t *) CFGR_BYTE4_ADDRESS = RCC_MCO;
000002  71c8              STRB     r0,[r1,#7]
;;;1296   }
000004  4770              BX       lr
;;;1297   
                          ENDP

000006  0000              DCW      0x0000
                  |L23.8|
                          DCD      0x40021000

                          AREA ||i.RCC_PCLK1Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK1Config PROC
;;;642      */
;;;643    void RCC_PCLK1Config(uint32_t RCC_HCLK)
000000  4903              LDR      r1,|L24.16|
;;;644    {
;;;645      uint32_t tmpreg = 0;
;;;646      /* Check the parameters */
;;;647      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;648      tmpreg = RCC->CFGR;
000002  684a              LDR      r2,[r1,#4]
;;;649      /* Clear PPRE1[2:0] bits */
;;;650      tmpreg &= CFGR_PPRE1_Reset_Mask;
000004  f42262e0          BIC      r2,r2,#0x700
;;;651      /* Set PPRE1[2:0] bits according to RCC_HCLK value */
;;;652      tmpreg |= RCC_HCLK;
000008  4310              ORRS     r0,r0,r2
;;;653      /* Store the new value */
;;;654      RCC->CFGR = tmpreg;
00000a  6048              STR      r0,[r1,#4]
;;;655    }
00000c  4770              BX       lr
;;;656    
                          ENDP

00000e  0000              DCW      0x0000
                  |L24.16|
                          DCD      0x40021000

                          AREA ||i.RCC_PCLK2Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK2Config PROC
;;;668      */
;;;669    void RCC_PCLK2Config(uint32_t RCC_HCLK)
000000  4903              LDR      r1,|L25.16|
;;;670    {
;;;671      uint32_t tmpreg = 0;
;;;672      /* Check the parameters */
;;;673      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;674      tmpreg = RCC->CFGR;
000002  684a              LDR      r2,[r1,#4]
;;;675      /* Clear PPRE2[2:0] bits */
;;;676      tmpreg &= CFGR_PPRE2_Reset_Mask;
000004  f4225260          BIC      r2,r2,#0x3800
;;;677      /* Set PPRE2[2:0] bits according to RCC_HCLK value */
;;;678      tmpreg |= RCC_HCLK << 3;
000008  ea4200c0          ORR      r0,r2,r0,LSL #3
;;;679      /* Store the new value */
;;;680      RCC->CFGR = tmpreg;
00000c  6048              STR      r0,[r1,#4]
;;;681    }
00000e  4770              BX       lr
;;;682    
                          ENDP

                  |L25.16|
                          DCD      0x40021000

                          AREA ||i.RCC_PLLCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLCmd PROC
;;;409      */
;;;410    void RCC_PLLCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L26.8|
;;;411    {
;;;412      /* Check the parameters */
;;;413      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;414    
;;;415      *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
000002  6608              STR      r0,[r1,#0x60]
;;;416    }
000004  4770              BX       lr
;;;417    
                          ENDP

000006  0000              DCW      0x0000
                  |L26.8|
                          DCD      0x42420000

                          AREA ||i.RCC_PLLConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLConfig PROC
;;;386      */
;;;387    void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
000000  4a03              LDR      r2,|L27.16|
;;;388    {
;;;389      uint32_t tmpreg = 0;
;;;390    
;;;391      /* Check the parameters */
;;;392      assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
;;;393      assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
;;;394    
;;;395      tmpreg = RCC->CFGR;
000002  6853              LDR      r3,[r2,#4]
;;;396      /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
;;;397      tmpreg &= CFGR_PLL_Mask;
;;;398      /* Set the PLL configuration bits */
;;;399      tmpreg |= RCC_PLLSource | RCC_PLLMul;
000004  4308              ORRS     r0,r0,r1
000006  f423137c          BIC      r3,r3,#0x3f0000       ;397
00000a  4318              ORRS     r0,r0,r3
;;;400      /* Store the new value */
;;;401      RCC->CFGR = tmpreg;
00000c  6050              STR      r0,[r2,#4]
;;;402    }
00000e  4770              BX       lr
;;;403    
                          ENDP

                  |L27.16|
                          DCD      0x40021000

                          AREA ||i.RCC_RTCCLKCmd||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKCmd PROC
;;;901      */
;;;902    void RCC_RTCCLKCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L28.8|
;;;903    {
;;;904      /* Check the parameters */
;;;905      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;906      *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;907    }
000004  4770              BX       lr
;;;908    
                          ENDP

000006  0000              DCW      0x0000
                  |L28.8|
                          DCD      0x4242043c

                          AREA ||i.RCC_RTCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKConfig PROC
;;;887      */
;;;888    void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
000000  4902              LDR      r1,|L29.12|
;;;889    {
;;;890      /* Check the parameters */
;;;891      assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
;;;892      /* Select the RTC clock source */
;;;893      RCC->BDCR |= RCC_RTCCLKSource;
000002  6a0a              LDR      r2,[r1,#0x20]
000004  4310              ORRS     r0,r0,r2
000006  6208              STR      r0,[r1,#0x20]
;;;894    }
000008  4770              BX       lr
;;;895    
                          ENDP

00000a  0000              DCW      0x0000
                  |L29.12|
                          DCD      0x40021000

                          AREA ||i.RCC_SYSCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SYSCLKConfig PROC
;;;572      */
;;;573    void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
000000  4903              LDR      r1,|L30.16|
;;;574    {
;;;575      uint32_t tmpreg = 0;
;;;576      /* Check the parameters */
;;;577      assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
;;;578      tmpreg = RCC->CFGR;
000002  684a              LDR      r2,[r1,#4]
;;;579      /* Clear SW[1:0] bits */
;;;580      tmpreg &= CFGR_SW_Mask;
000004  f0220203          BIC      r2,r2,#3
;;;581      /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;582      tmpreg |= RCC_SYSCLKSource;
000008  4310              ORRS     r0,r0,r2
;;;583      /* Store the new value */
;;;584      RCC->CFGR = tmpreg;
00000a  6048              STR      r0,[r1,#4]
;;;585    }
00000c  4770              BX       lr
;;;586    
                          ENDP

00000e  0000              DCW      0x0000
                  |L30.16|
                          DCD      0x40021000

                          AREA ||i.RCC_USBCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_USBCLKConfig PROC
;;;736      */
;;;737    void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
000000  4901              LDR      r1,|L31.8|
;;;738    {
;;;739      /* Check the parameters */
;;;740      assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));
;;;741    
;;;742      *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;
000002  f8c100d8          STR      r0,[r1,#0xd8]
;;;743    }
000006  4770              BX       lr
;;;744    #else
                          ENDP

                  |L31.8|
                          DCD      0x42420000

                          AREA ||i.RCC_WaitForHSEStartUp||, CODE, READONLY, ALIGN=2

                  RCC_WaitForHSEStartUp PROC
;;;312      */
;;;313    ErrorStatus RCC_WaitForHSEStartUp(void)
000000  b081              SUB      sp,sp,#4
;;;314    {
;;;315      __IO uint32_t StartUpCounter = 0;
000002  2000              MOVS     r0,#0
000004  490b              LDR      r1,|L32.52|
000006  9000              STR      r0,[sp,#0]
                  |L32.8|
000008  2000              MOVS     r0,#0
00000a  680a              LDR      r2,[r1,#0]
00000c  f4123f00          TST      r2,#0x20000
000010  bf18              IT       NE
000012  2001              MOVNE    r0,#1
;;;316      ErrorStatus status = ERROR;
;;;317      FlagStatus HSEStatus = RESET;
;;;318      
;;;319      /* Wait till HSE is ready and if Time out is reached exit */
;;;320      do
;;;321      {
;;;322        HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
;;;323        StartUpCounter++;  
000014  9a00              LDR      r2,[sp,#0]
000016  1c52              ADDS     r2,r2,#1
;;;324      } while((StartUpCounter != HSEStartUp_TimeOut) && (HSEStatus == RESET));
000018  9200              STR      r2,[sp,#0]
00001a  f5b26fa0          CMP      r2,#0x500
00001e  d001              BEQ      |L32.36|
000020  2800              CMP      r0,#0
000022  d0f1              BEQ      |L32.8|
                  |L32.36|
000024  6808              LDR      r0,[r1,#0]
000026  f4103000          ANDS     r0,r0,#0x20000
;;;325      
;;;326      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
;;;327      {
;;;328        status = SUCCESS;
00002a  bf18              IT       NE
00002c  2001              MOVNE    r0,#1
;;;329      }
;;;330      else
;;;331      {
;;;332        status = ERROR;
;;;333      }  
;;;334      return (status);
;;;335    }
00002e  b001              ADD      sp,sp,#4
000030  4770              BX       lr
;;;336    
                          ENDP

000032  0000              DCW      0x0000
                  |L32.52|
                          DCD      0x40021000

                          AREA ||.data||, DATA, ALIGN=0

                  ADCPrescTable
000000  02040608          DCB      0x02,0x04,0x06,0x08
                  APBAHBPrescTable
000004  00000000          DCB      0x00,0x00,0x00,0x00
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  01020304          DCB      0x01,0x02,0x03,0x04
000010  06070809          DCB      0x06,0x07,0x08,0x09

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32F10x_StdPeriph_Lib_V3.3.0\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f10x_rcc_c_49e27980____REV16|
#line 464 "D:\\Program_Files_x86\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.1.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___15_stm32f10x_rcc_c_49e27980____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f10x_rcc_c_49e27980____REVSH|
#line 479
|__asm___15_stm32f10x_rcc_c_49e27980____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f10x_rcc_c_49e27980____RRX|
#line 666
|__asm___15_stm32f10x_rcc_c_49e27980____RRX| PROC
#line 667

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
