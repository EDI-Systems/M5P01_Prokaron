; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f7xx_hal_cortex.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f7xx_hal_cortex.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Core -I..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f7xx_hal_cortex.crf ..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_cortex.c]
                          THUMB

                          AREA ||i.HAL_MPU_ConfigRegion||, CODE, READONLY, ALIGN=2

                  HAL_MPU_ConfigRegion PROC
;;;277      */
;;;278    void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
000000  f8dfc058          LDR      r12,|L1.92|
;;;279    {
000004  b4f0              PUSH     {r4-r7}
;;;280      /* Check the parameters */
;;;281      assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
;;;282      assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));
;;;283    
;;;284      /* Set the Region number */
;;;285      MPU->RNR = MPU_Init->Number;
000006  7843              LDRB     r3,[r0,#1]
;;;286    
;;;287      if ((MPU_Init->Enable) != RESET)
;;;288      {
;;;289        /* Check the parameters */
;;;290        assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));
;;;291        assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));
;;;292        assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));
;;;293        assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));
;;;294        assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
;;;295        assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
;;;296        assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
;;;297        assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
;;;298        
;;;299        MPU->RBAR = MPU_Init->BaseAddress;
000008  f10c0204          ADD      r2,r12,#4
;;;300        MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
00000c  1d11              ADDS     r1,r2,#4
00000e  f8cc3000          STR      r3,[r12,#0]           ;285
000012  7803              LDRB     r3,[r0,#0]            ;287
000014  2b00              CMP      r3,#0                 ;287
;;;301                    ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
;;;302                    ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
;;;303                    ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
;;;304                    ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
;;;305                    ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
;;;306                    ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
;;;307                    ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
;;;308                    ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
;;;309      }
;;;310      else
;;;311      {
;;;312        MPU->RBAR = 0x00;
000016  bf04              ITT      EQ
000018  2000              MOVEQ    r0,#0
00001a  6010              STREQ    r0,[r2,#0]
00001c  d01b              BEQ      |L1.86|
00001e  6843              LDR      r3,[r0,#4]            ;299
000020  6013              STR      r3,[r2,#0]            ;299
000022  7b05              LDRB     r5,[r0,#0xc]          ;300
000024  7ac3              LDRB     r3,[r0,#0xb]          ;300
000026  7a82              LDRB     r2,[r0,#0xa]          ;300
000028  f890c00d          LDRB     r12,[r0,#0xd]         ;300
00002c  072f              LSLS     r7,r5,#28             ;300
00002e  7b84              LDRB     r4,[r0,#0xe]          ;300
000030  ea476703          ORR      r7,r7,r3,LSL #24      ;300
000034  7bc5              LDRB     r5,[r0,#0xf]          ;300
000036  ea4742c2          ORR      r2,r7,r2,LSL #19      ;300
00003a  7a46              LDRB     r6,[r0,#9]            ;300
00003c  ea42428c          ORR      r2,r2,r12,LSL #18     ;300
000040  7a03              LDRB     r3,[r0,#8]            ;300
000042  ea424244          ORR      r2,r2,r4,LSL #17      ;300
000046  ea424205          ORR      r2,r2,r5,LSL #16      ;300
00004a  7800              LDRB     r0,[r0,#0]            ;300
00004c  ea422206          ORR      r2,r2,r6,LSL #8       ;300
000050  ea420243          ORR      r2,r2,r3,LSL #1       ;300
000054  4310              ORRS     r0,r0,r2              ;300
                  |L1.86|
000056  6008              STR      r0,[r1,#0]            ;300
;;;313        MPU->RASR = 0x00;
;;;314      }
;;;315    }
000058  bcf0              POP      {r4-r7}
00005a  4770              BX       lr
;;;316    #endif /* __MPU_PRESENT */
                          ENDP

                  |L1.92|
                          DCD      0xe000ed98

                          AREA ||i.HAL_NVIC_ClearPendingIRQ||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_ClearPendingIRQ PROC
;;;397      */
;;;398    void HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn)
000000  0941              LSRS     r1,r0,#5
000002  f000001f          AND      r0,r0,#0x1f
000006  008a              LSLS     r2,r1,#2
000008  2101              MOVS     r1,#1
00000a  f10222e0          ADD      r2,r2,#0xe000e000
00000e  fa01f000          LSL      r0,r1,r0
000012  f8c20280          STR      r0,[r2,#0x280]
;;;399    {
;;;400      /* Check the parameters */
;;;401      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;402      
;;;403      /* Clear pending interrupt */
;;;404      NVIC_ClearPendingIRQ(IRQn);
;;;405    }
000016  4770              BX       lr
;;;406    
                          ENDP


                          AREA ||i.HAL_NVIC_DisableIRQ||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_DisableIRQ PROC
;;;220      */
;;;221    void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
000000  0941              LSRS     r1,r0,#5
000002  f000001f          AND      r0,r0,#0x1f
000006  008a              LSLS     r2,r1,#2
000008  2101              MOVS     r1,#1
00000a  f10222e0          ADD      r2,r2,#0xe000e000
00000e  fa01f000          LSL      r0,r1,r0
000012  f8c20180          STR      r0,[r2,#0x180]
;;;222    {
;;;223      /* Check the parameters */
;;;224      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;225      
;;;226      /* Disable interrupt */
;;;227      NVIC_DisableIRQ(IRQn);
;;;228    }
000016  4770              BX       lr
;;;229    
                          ENDP


                          AREA ||i.HAL_NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_EnableIRQ PROC
;;;204      */
;;;205    void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
000000  0941              LSRS     r1,r0,#5
000002  f000001f          AND      r0,r0,#0x1f
000006  008a              LSLS     r2,r1,#2
000008  2101              MOVS     r1,#1
00000a  f10222e0          ADD      r2,r2,#0xe000e000
00000e  fa01f000          LSL      r0,r1,r0
000012  f8c20100          STR      r0,[r2,#0x100]
;;;206    {
;;;207      /* Check the parameters */
;;;208      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;209      
;;;210      /* Enable interrupt */
;;;211      NVIC_EnableIRQ(IRQn);
;;;212    }
000016  4770              BX       lr
;;;213    
                          ENDP


                          AREA ||i.HAL_NVIC_GetActive||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_GetActive PROC
;;;414      */
;;;415    uint32_t HAL_NVIC_GetActive(IRQn_Type IRQn)
000000  0941              LSRS     r1,r0,#5
;;;416    {
;;;417      /* Check the parameters */
;;;418      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;419      
;;;420      /* Return 1 if active else 0 */
;;;421      return NVIC_GetActive(IRQn);
000002  f000001f          AND      r0,r0,#0x1f
000006  008a              LSLS     r2,r1,#2
000008  f10222e0          ADD      r2,r2,#0xe000e000
00000c  2101              MOVS     r1,#1
00000e  f8d22300          LDR      r2,[r2,#0x300]
000012  fa01f000          LSL      r0,r1,r0
000016  4010              ANDS     r0,r0,r2
000018  bf18              IT       NE
00001a  2001              MOVNE    r0,#1
;;;422    }
00001c  4770              BX       lr
;;;423    
                          ENDP


                          AREA ||i.HAL_NVIC_GetPendingIRQ||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_GetPendingIRQ PROC
;;;381      */
;;;382    uint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn)
000000  0941              LSRS     r1,r0,#5
;;;383    {
;;;384      /* Check the parameters */
;;;385      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;386      
;;;387      /* Return 1 if pending else 0 */
;;;388      return NVIC_GetPendingIRQ(IRQn);
000002  f000001f          AND      r0,r0,#0x1f
000006  008a              LSLS     r2,r1,#2
000008  f10222e0          ADD      r2,r2,#0xe000e000
00000c  2101              MOVS     r1,#1
00000e  f8d22200          LDR      r2,[r2,#0x200]
000012  fa01f000          LSL      r0,r1,r0
000016  4010              ANDS     r0,r0,r2
000018  bf18              IT       NE
00001a  2001              MOVNE    r0,#1
;;;389    }
00001c  4770              BX       lr
;;;390    
                          ENDP


                          AREA ||i.HAL_NVIC_GetPriority||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_GetPriority PROC
;;;348      */
;;;349    void HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t *pPreemptPriority, uint32_t *pSubPriority)
000000  2800              CMP      r0,#0
;;;350    {
000002  b430              PUSH     {r4,r5}
000004  bfb8              IT       LT
000006  f000000f          ANDLT    r0,r0,#0xf
00000a  f10020e0          ADD      r0,r0,#0xe000e000
00000e  bfb4              ITE      LT
000010  f8900d14          LDRBLT   r0,[r0,#0xd14]
000014  f8900400          LDRBGE   r0,[r0,#0x400]
000018  0900              LSRS     r0,r0,#4
00001a  f0010c07          AND      r12,r1,#7
00001e  f1cc0107          RSB      r1,r12,#7
000022  2904              CMP      r1,#4
000024  bf88              IT       HI
000026  2104              MOVHI    r1,#4
000028  f10c0404          ADD      r4,r12,#4
00002c  2c07              CMP      r4,#7
00002e  bf34              ITE      CC
000030  f04f0c00          MOVCC    r12,#0
000034  f1ac0c03          SUBCS    r12,r12,#3
000038  2401              MOVS     r4,#1
00003a  fa20f50c          LSR      r5,r0,r12
00003e  fa04f101          LSL      r1,r4,r1
000042  fa04f40c          LSL      r4,r4,r12
000046  f1a10c01          SUB      r12,r1,#1
00004a  1e61              SUBS     r1,r4,#1
00004c  ea050c0c          AND      r12,r5,r12
000050  f8c2c000          STR      r12,[r2,#0]
000054  4008              ANDS     r0,r0,r1
000056  6018              STR      r0,[r3,#0]
;;;351      /* Check the parameters */
;;;352      assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
;;;353     /* Get priority for Cortex-M system or device specific interrupts */
;;;354      NVIC_DecodePriority(NVIC_GetPriority(IRQn), PriorityGroup, pPreemptPriority, pSubPriority);
;;;355    }
000058  bc30              POP      {r4,r5}
00005a  4770              BX       lr
;;;356    
                          ENDP


                          AREA ||i.HAL_NVIC_GetPriorityGrouping||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_GetPriorityGrouping PROC
;;;321      */
;;;322    uint32_t HAL_NVIC_GetPriorityGrouping(void)
000000  4802              LDR      r0,|L8.12|
;;;323    {
;;;324      /* Get the PRIGROUP[10:8] field value */
;;;325      return NVIC_GetPriorityGrouping();
000002  6800              LDR      r0,[r0,#0]
000004  f3c02002          UBFX     r0,r0,#8,#3
;;;326    }
000008  4770              BX       lr
;;;327    
                          ENDP

00000a  0000              DCW      0x0000
                  |L8.12|
                          DCD      0xe000ed0c

                          AREA ||i.HAL_NVIC_SetPendingIRQ||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_SetPendingIRQ PROC
;;;363      */
;;;364    void HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn)
000000  0941              LSRS     r1,r0,#5
000002  f000001f          AND      r0,r0,#0x1f
000006  008a              LSLS     r2,r1,#2
000008  2101              MOVS     r1,#1
00000a  f10222e0          ADD      r2,r2,#0xe000e000
00000e  fa01f000          LSL      r0,r1,r0
000012  f8c20200          STR      r0,[r2,#0x200]
;;;365    {
;;;366      /* Check the parameters */
;;;367      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;368      
;;;369      /* Set interrupt pending */
;;;370      NVIC_SetPendingIRQ(IRQn);
;;;371    }
000016  4770              BX       lr
;;;372    
                          ENDP


                          AREA ||i.HAL_NVIC_SetPriority||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_SetPriority PROC
;;;182      */
;;;183    void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
000000  4b16              LDR      r3,|L10.92|
;;;184    { 
000002  b430              PUSH     {r4,r5}
000004  681b              LDR      r3,[r3,#0]
000006  f3c32302          UBFX     r3,r3,#8,#3
00000a  f1c30c07          RSB      r12,r3,#7
00000e  f1bc0f04          CMP      r12,#4
000012  bf88              IT       HI
000014  f04f0c04          MOVHI    r12,#4
000018  1d1c              ADDS     r4,r3,#4
00001a  2c07              CMP      r4,#7
00001c  bf34              ITE      CC
00001e  2300              MOVCC    r3,#0
000020  1edb              SUBCS    r3,r3,#3
000022  2401              MOVS     r4,#1
000024  fa04fc0c          LSL      r12,r4,r12
000028  fa04f503          LSL      r5,r4,r3
00002c  f1ac0401          SUB      r4,r12,#1
000030  4021              ANDS     r1,r1,r4
000032  f1a50c01          SUB      r12,r5,#1
000036  4099              LSLS     r1,r1,r3
000038  ea0c0202          AND      r2,r12,r2
00003c  4311              ORRS     r1,r1,r2
00003e  2800              CMP      r0,#0
000040  ea4f1101          LSL      r1,r1,#4
000044  bfb8              IT       LT
000046  f000000f          ANDLT    r0,r0,#0xf
00004a  f10020e0          ADD      r0,r0,#0xe000e000
00004e  bfb4              ITE      LT
000050  f8801d14          STRBLT   r1,[r0,#0xd14]
000054  f8801400          STRBGE   r1,[r0,#0x400]
;;;185      uint32_t prioritygroup = 0x00;
;;;186      
;;;187      /* Check the parameters */
;;;188      assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
;;;189      assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
;;;190      
;;;191      prioritygroup = NVIC_GetPriorityGrouping();
;;;192      
;;;193      NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
;;;194    }
000058  bc30              POP      {r4,r5}
00005a  4770              BX       lr
;;;195    
                          ENDP

                  |L10.92|
                          DCD      0xe000ed0c

                          AREA ||i.HAL_NVIC_SetPriorityGrouping||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_SetPriorityGrouping PROC
;;;160      */
;;;161    void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
000000  4907              LDR      r1,|L11.32|
000002  f0000007          AND      r0,r0,#7
000006  f64f03ff          MOV      r3,#0xf8ff
00000a  680a              LDR      r2,[r1,#0]
00000c  401a              ANDS     r2,r2,r3
00000e  ea422000          ORR      r0,r2,r0,LSL #8
000012  f04070fd          ORR      r0,r0,#0x1fa0000
000016  f0406080          ORR      r0,r0,#0x4000000
00001a  6008              STR      r0,[r1,#0]
;;;162    {
;;;163      /* Check the parameters */
;;;164      assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
;;;165      
;;;166      /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
;;;167      NVIC_SetPriorityGrouping(PriorityGroup);
;;;168    }
00001c  4770              BX       lr
;;;169    
                          ENDP

00001e  0000              DCW      0x0000
                  |L11.32|
                          DCD      0xe000ed0c

                          AREA ||i.HAL_NVIC_SystemReset||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_SystemReset PROC
;;;233      */
;;;234    void HAL_NVIC_SystemReset(void)
000000  f3bf8f4f          DSB      
000004  4805              LDR      r0,|L12.28|
000006  4906              LDR      r1,|L12.32|
000008  6802              LDR      r2,[r0,#0]
00000a  f40262e0          AND      r2,r2,#0x700
00000e  4311              ORRS     r1,r1,r2
000010  6001              STR      r1,[r0,#0]
000012  f3bf8f4f          DSB      
                  |L12.22|
000016  bf00              NOP      
000018  e7fd              B        |L12.22|
;;;235    {
;;;236      /* System Reset */
;;;237      NVIC_SystemReset();
;;;238    }
;;;239    
                          ENDP

00001a  0000              DCW      0x0000
                  |L12.28|
                          DCD      0xe000ed0c
                  |L12.32|
                          DCD      0x05fa0004

                          AREA ||i.HAL_SYSTICK_CLKSourceConfig||, CODE, READONLY, ALIGN=1

                  HAL_SYSTICK_CLKSourceConfig PROC
;;;431      */
;;;432    void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
000000  2804              CMP      r0,#4
;;;433    {
;;;434      /* Check the parameters */
;;;435      assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
;;;436      if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
;;;437      {
;;;438        SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
000002  f04f20e0          MOV      r0,#0xe000e000
;;;439      }
;;;440      else
;;;441      {
;;;442        SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
000006  6901              LDR      r1,[r0,#0x10]
000008  bf0c              ITE      EQ                    ;438
00000a  f0410104          ORREQ    r1,r1,#4              ;438
00000e  f0210104          BICNE    r1,r1,#4
000012  6101              STR      r1,[r0,#0x10]         ;438
;;;443      }
;;;444    }
000014  4770              BX       lr
;;;445    
                          ENDP


                          AREA ||i.HAL_SYSTICK_Callback||, CODE, READONLY, ALIGN=1

                  HAL_SYSTICK_Callback PROC
;;;458      */
;;;459    __weak void HAL_SYSTICK_Callback(void)
000000  4770              BX       lr
;;;460    {
;;;461      /* NOTE : This function Should not be modified, when the callback is needed,
;;;462                the HAL_SYSTICK_Callback could be implemented in the user file
;;;463       */
;;;464    }
;;;465    
                          ENDP


                          AREA ||i.HAL_SYSTICK_Config||, CODE, READONLY, ALIGN=2

                  HAL_SYSTICK_Config PROC
;;;246      */
;;;247    uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
000000  1e40              SUBS     r0,r0,#1
000002  f1b07f80          CMP      r0,#0x1000000
000006  bf24              ITT      CS
000008  2001              MOVCS    r0,#1
;;;248    {
;;;249       return SysTick_Config(TicksNumb);
;;;250    }
00000a  4770              BXCS     lr
00000c  f04f21e0          MOV      r1,#0xe000e000
000010  6148              STR      r0,[r1,#0x14]
000012  20f0              MOVS     r0,#0xf0
000014  4a03              LDR      r2,|L15.36|
000016  f8820d14          STRB     r0,[r2,#0xd14]
00001a  2000              MOVS     r0,#0
00001c  2207              MOVS     r2,#7
00001e  6188              STR      r0,[r1,#0x18]
000020  610a              STR      r2,[r1,#0x10]
000022  4770              BX       lr
;;;251    /**
                          ENDP

                  |L15.36|
                          DCD      0xe000e00f

                          AREA ||i.HAL_SYSTICK_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_SYSTICK_IRQHandler PROC
;;;449      */
;;;450    void HAL_SYSTICK_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;451    {
;;;452      HAL_SYSTICK_Callback();
000002  f7fffffe          BL       HAL_SYSTICK_Callback
;;;453    }
000006  bd10              POP      {r4,pc}
;;;454    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_cortex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f7xx_hal_cortex_c_2992dbc0____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32F7xx_HAL_Driver\\Core\\cmsis_armcc.h"
|__asm___22_stm32f7xx_hal_cortex_c_2992dbc0____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f7xx_hal_cortex_c_2992dbc0____REVSH|
#line 402
|__asm___22_stm32f7xx_hal_cortex_c_2992dbc0____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f7xx_hal_cortex_c_2992dbc0____RRX|
#line 587
|__asm___22_stm32f7xx_hal_cortex_c_2992dbc0____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
