; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f0xx_hal_tim.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f0xx_hal_tim.d --cpu=Cortex-M0 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F0_V1.9.0\Drivers\STM32F0xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_F0_V1.9.0\Drivers\CMSIS\Device\ST\STM32L0xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F0_V1.9.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F0_V1.9.0\Drivers\STM32F0xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F030F4P6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F0xx_DFP\2.0.0\Drivers\CMSIS\Device\ST\STM32F0xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F030x6 -DSTM32F030x6 -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f0xx_hal_tim.crf ..\..\..\M0P0_Library\STM32Cube_FW_F0_V1.9.0\Drivers\STM32F0xx_HAL_Driver\Src\stm32f0xx_hal_tim.c]
                          THUMB

                          AREA ||i.HAL_TIM_Base_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Base_DeInit PROC
;;;242      */
;;;243    HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;244    {
000002  4604              MOV      r4,r0
;;;245      /* Check the parameters */
;;;246      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;247    
;;;248      htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  6420              STR      r0,[r4,#0x40]
;;;249    
;;;250      /* Disable the TIM Peripheral Clock */
;;;251      __HAL_TIM_DISABLE(htim);
000008  6820              LDR      r0,[r4,#0]
00000a  6a01              LDR      r1,[r0,#0x20]
00000c  4a08              LDR      r2,|L1.48|
00000e  4211              TST      r1,r2
000010  d107              BNE      |L1.34|
000012  6a01              LDR      r1,[r0,#0x20]
000014  1092              ASRS     r2,r2,#2
000016  4211              TST      r1,r2
000018  d103              BNE      |L1.34|
00001a  6801              LDR      r1,[r0,#0]
00001c  0849              LSRS     r1,r1,#1
00001e  0049              LSLS     r1,r1,#1
000020  6001              STR      r1,[r0,#0]
                  |L1.34|
;;;252    
;;;253      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;254      HAL_TIM_Base_MspDeInit(htim);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       HAL_TIM_Base_MspDeInit
;;;255    
;;;256      /* Change TIM state */
;;;257      htim->State = HAL_TIM_STATE_RESET;
000028  2000              MOVS     r0,#0
00002a  6420              STR      r0,[r4,#0x40]
;;;258    
;;;259      /* Release Lock */
;;;260      __HAL_UNLOCK(htim);
00002c  63e0              STR      r0,[r4,#0x3c]
;;;261    
;;;262      return HAL_OK;
;;;263    }
00002e  bd10              POP      {r4,pc}
;;;264    
                          ENDP

                  |L1.48|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_Base_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_GetState PROC
;;;4492     */
;;;4493   HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
000000  6c00              LDR      r0,[r0,#0x40]
;;;4494   {
;;;4495     return htim->State;
;;;4496   }
000002  4770              BX       lr
;;;4497   
                          ENDP


                          AREA ||i.HAL_TIM_Base_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Init PROC
;;;202      */
;;;203    HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
000000  2800              CMP      r0,#0
;;;204    {
;;;205      /* Check the TIM handle allocation */
;;;206      if(htim == NULL)
000002  d101              BNE      |L3.8|
;;;207      {
;;;208        return HAL_ERROR;
000004  2001              MOVS     r0,#1
;;;209      }
;;;210    
;;;211      /* Check the parameters */
;;;212      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;213      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;214      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;215      assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;216    
;;;217      if(htim->State == HAL_TIM_STATE_RESET)
;;;218      {
;;;219        /* Allocate lock resource and initialize it */
;;;220        htim->Lock = HAL_UNLOCKED;
;;;221    
;;;222        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;223        HAL_TIM_Base_MspInit(htim);
;;;224      }
;;;225    
;;;226      /* Set the TIM state */
;;;227      htim->State= HAL_TIM_STATE_BUSY;
;;;228    
;;;229      /* Set the Time Base configuration */
;;;230      TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;231    
;;;232      /* Initialize the TIM state*/
;;;233      htim->State= HAL_TIM_STATE_READY;
;;;234    
;;;235      return HAL_OK;
;;;236    }
000006  4770              BX       lr
                  |L3.8|
000008  b510              PUSH     {r4,lr}               ;204
00000a  4604              MOV      r4,r0                 ;204
00000c  6c00              LDR      r0,[r0,#0x40]         ;217
00000e  2800              CMP      r0,#0                 ;217
000010  d103              BNE      |L3.26|
000012  63e0              STR      r0,[r4,#0x3c]         ;223
000014  4620              MOV      r0,r4                 ;223
000016  f7fffffe          BL       HAL_TIM_Base_MspInit
                  |L3.26|
00001a  2002              MOVS     r0,#2                 ;227
00001c  6420              STR      r0,[r4,#0x40]         ;227
00001e  1d21              ADDS     r1,r4,#4              ;230
000020  6820              LDR      r0,[r4,#0]            ;230
000022  f7fffffe          BL       TIM_Base_SetConfig
000026  2001              MOVS     r0,#1                 ;233
000028  6420              STR      r0,[r4,#0x40]         ;233
00002a  2000              MOVS     r0,#0                 ;235
00002c  bd10              POP      {r4,pc}
;;;237    
                          ENDP


                          AREA ||i.HAL_TIM_Base_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_MspDeInit PROC
;;;284      */
;;;285    __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;286    {
;;;287      /* Prevent unused argument(s) compilation warning */
;;;288      UNUSED(htim);
;;;289    
;;;290      /* NOTE : This function Should not be modified, when the callback is needed,
;;;291                the HAL_TIM_Base_MspDeInit could be implemented in the user file
;;;292       */
;;;293    }
;;;294    
                          ENDP


                          AREA ||i.HAL_TIM_Base_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_MspInit PROC
;;;269      */
;;;270    __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;271    {
;;;272      /* Prevent unused argument(s) compilation warning */
;;;273      UNUSED(htim);
;;;274    
;;;275      /* NOTE : This function Should not be modified, when the callback is needed,
;;;276                the HAL_TIM_Base_MspInit could be implemented in the user file
;;;277       */
;;;278    }
;;;279    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Start PROC
;;;300    */
;;;301    HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
000000  2102              MOVS     r1,#2
;;;302    {
;;;303      /* Check the parameters */
;;;304      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;305    
;;;306      /* Set the TIM state */
;;;307      htim->State= HAL_TIM_STATE_BUSY;
000002  6401              STR      r1,[r0,#0x40]
;;;308    
;;;309      /* Enable the Peripheral */
;;;310      __HAL_TIM_ENABLE(htim);
000004  6802              LDR      r2,[r0,#0]
000006  6813              LDR      r3,[r2,#0]
000008  2101              MOVS     r1,#1
00000a  430b              ORRS     r3,r3,r1
00000c  6013              STR      r3,[r2,#0]
;;;311    
;;;312      /* Change the TIM state*/
;;;313      htim->State= HAL_TIM_STATE_READY;
00000e  6401              STR      r1,[r0,#0x40]
;;;314    
;;;315      /* Return function status */
;;;316      return HAL_OK;
000010  2000              MOVS     r0,#0
;;;317    }
000012  4770              BX       lr
;;;318    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Base_Start_DMA PROC
;;;387    */
;;;388    HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;389    {
000002  4604              MOV      r4,r0
;;;390      /* Check the parameters */
;;;391      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
;;;392    
;;;393      if((htim->State == HAL_TIM_STATE_BUSY))
000004  6c00              LDR      r0,[r0,#0x40]
000006  2802              CMP      r0,#2
000008  d006              BEQ      |L7.24|
;;;394      {
;;;395         return HAL_BUSY;
;;;396      }
;;;397      else if((htim->State == HAL_TIM_STATE_READY))
00000a  6c20              LDR      r0,[r4,#0x40]
00000c  2801              CMP      r0,#1
00000e  d106              BNE      |L7.30|
;;;398      {
;;;399        if((pData == 0 ) && (Length > 0))
000010  2900              CMP      r1,#0
000012  d102              BNE      |L7.26|
000014  2a00              CMP      r2,#0
000016  d000              BEQ      |L7.26|
                  |L7.24|
;;;400        {
;;;401          return HAL_ERROR;
;;;402        }
;;;403        else
;;;404        {
;;;405          htim->State = HAL_TIM_STATE_BUSY;
;;;406        }
;;;407      }
;;;408      /* Set the DMA Period elapsed callback */
;;;409      htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;410    
;;;411      /* Set the DMA error callback */
;;;412      htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;413    
;;;414      /* Enable the DMA channel */
;;;415      HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length);
;;;416    
;;;417      /* Enable the TIM Update DMA request */
;;;418      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
;;;419    
;;;420      /* Enable the Peripheral */
;;;421      __HAL_TIM_ENABLE(htim);
;;;422    
;;;423      /* Return function status */
;;;424      return HAL_OK;
;;;425    }
000018  bd70              POP      {r4-r6,pc}
                  |L7.26|
00001a  2002              MOVS     r0,#2                 ;405
00001c  6420              STR      r0,[r4,#0x40]         ;405
                  |L7.30|
00001e  6a23              LDR      r3,[r4,#0x20]         ;409
000020  480c              LDR      r0,|L7.84|
000022  62d8              STR      r0,[r3,#0x2c]         ;412
000024  6a23              LDR      r3,[r4,#0x20]         ;412
000026  480c              LDR      r0,|L7.88|
000028  6358              STR      r0,[r3,#0x34]         ;415
00002a  6825              LDR      r5,[r4,#0]            ;415
00002c  4613              MOV      r3,r2                 ;415
00002e  462a              MOV      r2,r5                 ;415
000030  322c              ADDS     r2,r2,#0x2c           ;415
000032  6a20              LDR      r0,[r4,#0x20]         ;415
000034  f7fffffe          BL       HAL_DMA_Start_IT
000038  6820              LDR      r0,[r4,#0]            ;418
00003a  68c1              LDR      r1,[r0,#0xc]          ;418
00003c  22ff              MOVS     r2,#0xff              ;418
00003e  3201              ADDS     r2,#1                 ;418
000040  4311              ORRS     r1,r1,r2              ;418
000042  60c1              STR      r1,[r0,#0xc]          ;418
000044  6820              LDR      r0,[r4,#0]            ;421
000046  6801              LDR      r1,[r0,#0]            ;421
000048  2201              MOVS     r2,#1                 ;421
00004a  4311              ORRS     r1,r1,r2              ;421
00004c  6001              STR      r1,[r0,#0]            ;421
00004e  2000              MOVS     r0,#0                 ;424
000050  bd70              POP      {r4-r6,pc}
;;;426    
                          ENDP

000052  0000              DCW      0x0000
                  |L7.84|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L7.88|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_Base_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Start_IT PROC
;;;346    */
;;;347    HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
000000  6802              LDR      r2,[r0,#0]
;;;348    {
;;;349      /* Check the parameters */
;;;350      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;351    
;;;352       /* Enable the TIM Update interrupt */
;;;353       __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
000002  68d3              LDR      r3,[r2,#0xc]
000004  2101              MOVS     r1,#1
000006  430b              ORRS     r3,r3,r1
000008  60d3              STR      r3,[r2,#0xc]
;;;354    
;;;355       /* Enable the Peripheral */
;;;356      __HAL_TIM_ENABLE(htim);
00000a  6800              LDR      r0,[r0,#0]
00000c  6802              LDR      r2,[r0,#0]
00000e  430a              ORRS     r2,r2,r1
000010  6002              STR      r2,[r0,#0]
;;;357    
;;;358      /* Return function status */
;;;359      return HAL_OK;
000012  2000              MOVS     r0,#0
;;;360    }
000014  4770              BX       lr
;;;361    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Base_Stop PROC
;;;323    */
;;;324    HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
000000  2102              MOVS     r1,#2
;;;325    {
;;;326      /* Check the parameters */
;;;327      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;328    
;;;329      /* Set the TIM state */
;;;330      htim->State= HAL_TIM_STATE_BUSY;
000002  6401              STR      r1,[r0,#0x40]
;;;331    
;;;332      /* Disable the Peripheral */
;;;333      __HAL_TIM_DISABLE(htim);
000004  6801              LDR      r1,[r0,#0]
000006  6a0a              LDR      r2,[r1,#0x20]
000008  4b07              LDR      r3,|L9.40|
00000a  421a              TST      r2,r3
00000c  d107              BNE      |L9.30|
00000e  6a0a              LDR      r2,[r1,#0x20]
000010  109b              ASRS     r3,r3,#2
000012  421a              TST      r2,r3
000014  d103              BNE      |L9.30|
000016  680a              LDR      r2,[r1,#0]
000018  0852              LSRS     r2,r2,#1
00001a  0052              LSLS     r2,r2,#1
00001c  600a              STR      r2,[r1,#0]
                  |L9.30|
;;;334    
;;;335      /* Change the TIM state*/
;;;336      htim->State= HAL_TIM_STATE_READY;
00001e  2101              MOVS     r1,#1
000020  6401              STR      r1,[r0,#0x40]
;;;337    
;;;338      /* Return function status */
;;;339      return HAL_OK;
000022  2000              MOVS     r0,#0
;;;340    }
000024  4770              BX       lr
;;;341    
                          ENDP

000026  0000              DCW      0x0000
                  |L9.40|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_Base_Stop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Base_Stop_DMA PROC
;;;431    */
;;;432    HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
000000  6801              LDR      r1,[r0,#0]
;;;433    {
;;;434      /* Check the parameters */
;;;435      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
;;;436    
;;;437      /* Disable the TIM Update DMA request */
;;;438      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
000002  68ca              LDR      r2,[r1,#0xc]
000004  23ff              MOVS     r3,#0xff
000006  3301              ADDS     r3,#1
000008  439a              BICS     r2,r2,r3
00000a  60ca              STR      r2,[r1,#0xc]
;;;439    
;;;440      /* Disable the Peripheral */
;;;441      __HAL_TIM_DISABLE(htim);
00000c  6801              LDR      r1,[r0,#0]
00000e  6a0a              LDR      r2,[r1,#0x20]
000010  4b07              LDR      r3,|L10.48|
000012  421a              TST      r2,r3
000014  d107              BNE      |L10.38|
000016  6a0a              LDR      r2,[r1,#0x20]
000018  109b              ASRS     r3,r3,#2
00001a  421a              TST      r2,r3
00001c  d103              BNE      |L10.38|
00001e  680a              LDR      r2,[r1,#0]
000020  0852              LSRS     r2,r2,#1
000022  0052              LSLS     r2,r2,#1
000024  600a              STR      r2,[r1,#0]
                  |L10.38|
;;;442    
;;;443      /* Change the htim state */
;;;444      htim->State = HAL_TIM_STATE_READY;
000026  2101              MOVS     r1,#1
000028  6401              STR      r1,[r0,#0x40]
;;;445    
;;;446      /* Return function status */
;;;447      return HAL_OK;
00002a  2000              MOVS     r0,#0
;;;448    }
00002c  4770              BX       lr
;;;449    
                          ENDP

00002e  0000              DCW      0x0000
                  |L10.48|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_Base_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Base_Stop_IT PROC
;;;366    */
;;;367    HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
000000  6801              LDR      r1,[r0,#0]
;;;368    {
;;;369      /* Check the parameters */
;;;370      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;371      /* Disable the TIM Update interrupt */
;;;372      __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
000002  68ca              LDR      r2,[r1,#0xc]
000004  0852              LSRS     r2,r2,#1
000006  0052              LSLS     r2,r2,#1
000008  60ca              STR      r2,[r1,#0xc]
;;;373    
;;;374      /* Disable the Peripheral */
;;;375      __HAL_TIM_DISABLE(htim);
00000a  6800              LDR      r0,[r0,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  4a06              LDR      r2,|L11.40|
000010  4211              TST      r1,r2
000012  d107              BNE      |L11.36|
000014  6a01              LDR      r1,[r0,#0x20]
000016  1092              ASRS     r2,r2,#2
000018  4211              TST      r1,r2
00001a  d103              BNE      |L11.36|
00001c  6801              LDR      r1,[r0,#0]
00001e  0849              LSRS     r1,r1,#1
000020  0049              LSLS     r1,r1,#1
000022  6001              STR      r1,[r0,#0]
                  |L11.36|
;;;376    
;;;377      /* Return function status */
;;;378      return HAL_OK;
000024  2000              MOVS     r0,#0
;;;379    }
000026  4770              BX       lr
;;;380    
                          ENDP

                  |L11.40|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_ConfigClockSource||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigClockSource PROC
;;;4018     */ 
;;;4019   HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)
000000  6bc2              LDR      r2,[r0,#0x3c]
;;;4020   {
;;;4021     uint32_t tmpsmcr = 0U;
;;;4022   
;;;4023     /* Process Locked */
;;;4024     __HAL_LOCK(htim);
000002  2a01              CMP      r2,#1
000004  d002              BEQ      |L12.12|
000006  2201              MOVS     r2,#1
000008  63c2              STR      r2,[r0,#0x3c]
00000a  e001              B        |L12.16|
                  |L12.12|
00000c  2002              MOVS     r0,#2
;;;4025   
;;;4026     htim->State = HAL_TIM_STATE_BUSY;
;;;4027   
;;;4028     /* Check the parameters */
;;;4029     assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
;;;4030   
;;;4031     /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
;;;4032     tmpsmcr = htim->Instance->SMCR;
;;;4033     tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
;;;4034     tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
;;;4035     htim->Instance->SMCR = tmpsmcr;
;;;4036   
;;;4037     switch (sClockSourceConfig->ClockSource)
;;;4038     {
;;;4039     case TIM_CLOCKSOURCE_INTERNAL:
;;;4040       {
;;;4041         assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;4042         /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;4043         htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;4044       }
;;;4045       break;
;;;4046   
;;;4047     case TIM_CLOCKSOURCE_ETRMODE1:
;;;4048       {
;;;4049         /* Check whether or not the timer instance supports external trigger input mode 1 (ETRF)*/
;;;4050         assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
;;;4051   
;;;4052         /* Check ETR input conditioning related parameters */
;;;4053         assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
;;;4054         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4055         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4056         
;;;4057         /* Configure the ETR Clock source */
;;;4058         TIM_ETR_SetConfig(htim->Instance,
;;;4059                           sClockSourceConfig->ClockPrescaler,
;;;4060                           sClockSourceConfig->ClockPolarity,
;;;4061                           sClockSourceConfig->ClockFilter);
;;;4062         /* Get the TIMx SMCR register value */
;;;4063         tmpsmcr = htim->Instance->SMCR;
;;;4064         /* Reset the SMS and TS Bits */
;;;4065         tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
;;;4066         /* Select the External clock mode1 and the ETRF trigger */
;;;4067         tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
;;;4068         /* Write to TIMx SMCR */
;;;4069         htim->Instance->SMCR = tmpsmcr;
;;;4070       }
;;;4071       break;
;;;4072   
;;;4073     case TIM_CLOCKSOURCE_ETRMODE2:
;;;4074       {
;;;4075         /* Check whether or not the timer instance supports external trigger input mode 2 (ETRF)*/
;;;4076         assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
;;;4077   
;;;4078         /* Check ETR input conditioning related parameters */
;;;4079         assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
;;;4080         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4081         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4082         
;;;4083         /* Configure the ETR Clock source */
;;;4084         TIM_ETR_SetConfig(htim->Instance,
;;;4085                           sClockSourceConfig->ClockPrescaler,
;;;4086                           sClockSourceConfig->ClockPolarity,
;;;4087                           sClockSourceConfig->ClockFilter);
;;;4088         /* Enable the External clock mode2 */
;;;4089         htim->Instance->SMCR |= TIM_SMCR_ECE;
;;;4090       }
;;;4091       break;
;;;4092   
;;;4093     case TIM_CLOCKSOURCE_TI1:
;;;4094       {
;;;4095         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4096         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;4097   
;;;4098         /* Check TI1 input conditioning related parameters */
;;;4099         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4100         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4101         
;;;4102         TIM_TI1_ConfigInputStage(htim->Instance,
;;;4103                                  sClockSourceConfig->ClockPolarity,
;;;4104                                  sClockSourceConfig->ClockFilter);
;;;4105         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
;;;4106       }
;;;4107       break;
;;;4108     case TIM_CLOCKSOURCE_TI2:
;;;4109       {
;;;4110         /* Check whether or not the timer instance supports external clock mode 1 (ETRF)*/
;;;4111         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;4112   
;;;4113          /* Check TI2 input conditioning related parameters */
;;;4114         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4115         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4116   
;;;4117         TIM_TI2_ConfigInputStage(htim->Instance,
;;;4118                                  sClockSourceConfig->ClockPolarity,
;;;4119                                  sClockSourceConfig->ClockFilter);
;;;4120         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
;;;4121       }
;;;4122       break;
;;;4123     case TIM_CLOCKSOURCE_TI1ED:
;;;4124       {
;;;4125         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4126         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;4127   
;;;4128         /* Check TI1 input conditioning related parameters */
;;;4129         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4130         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4131   
;;;4132         TIM_TI1_ConfigInputStage(htim->Instance,
;;;4133                                  sClockSourceConfig->ClockPolarity,
;;;4134                                  sClockSourceConfig->ClockFilter);
;;;4135         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
;;;4136       }
;;;4137       break;
;;;4138     case TIM_CLOCKSOURCE_ITR0:
;;;4139       {
;;;4140         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4141         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4142   
;;;4143         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR0);
;;;4144       }
;;;4145       break;
;;;4146     case TIM_CLOCKSOURCE_ITR1:
;;;4147       {
;;;4148         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4149         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4150   
;;;4151         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR1);
;;;4152       }
;;;4153       break;
;;;4154     case TIM_CLOCKSOURCE_ITR2:
;;;4155       {
;;;4156         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4157         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4158   
;;;4159         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR2);
;;;4160       }
;;;4161       break;
;;;4162     case TIM_CLOCKSOURCE_ITR3:
;;;4163       {
;;;4164         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4165         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4166   
;;;4167         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR3);
;;;4168       }
;;;4169       break;
;;;4170   
;;;4171     default:
;;;4172       break;
;;;4173     }
;;;4174     htim->State = HAL_TIM_STATE_READY;
;;;4175   
;;;4176     __HAL_UNLOCK(htim);
;;;4177   
;;;4178     return HAL_OK;
;;;4179   }
00000e  4770              BX       lr
                  |L12.16|
000010  b4f0              PUSH     {r4-r7}               ;4020
000012  2202              MOVS     r2,#2                 ;4026
000014  6402              STR      r2,[r0,#0x40]         ;4026
000016  6803              LDR      r3,[r0,#0]            ;4032
000018  689a              LDR      r2,[r3,#8]            ;4032
00001a  2477              MOVS     r4,#0x77              ;4033
00001c  25ff              MOVS     r5,#0xff              ;4034
00001e  43a2              BICS     r2,r2,r4              ;4033
000020  022d              LSLS     r5,r5,#8              ;4034
000022  43aa              BICS     r2,r2,r5              ;4034
000024  609a              STR      r2,[r3,#8]            ;4035
000026  680f              LDR      r7,[r1,#0]            ;4037
000028  26f0              MOVS     r6,#0xf0              ;4037
00002a  2270              MOVS     r2,#0x70              ;4037
00002c  2307              MOVS     r3,#7                 ;4037
00002e  2f50              CMP      r7,#0x50              ;4037
000030  d03f              BEQ      |L12.178|
000032  dc0c              BGT      |L12.78|
000034  2f20              CMP      r7,#0x20              ;4037
000036  d075              BEQ      |L12.292|
000038  dc04              BGT      |L12.68|
00003a  2f00              CMP      r7,#0                 ;4037
00003c  d073              BEQ      |L12.294|
00003e  2f10              CMP      r7,#0x10              ;4037
000040  d151              BNE      |L12.230|
000042  e093              B        |L12.364|
                  |L12.68|
000044  2f30              CMP      r7,#0x30              ;4037
000046  d06f              BEQ      |L12.296|
000048  2f40              CMP      r7,#0x40              ;4037
00004a  d14c              BNE      |L12.230|
00004c  e06d              B        |L12.298|
                  |L12.78|
00004e  2f60              CMP      r7,#0x60              ;4037
000050  d04a              BEQ      |L12.232|
000052  2f70              CMP      r7,#0x70              ;4037
000054  d01c              BEQ      |L12.144|
000056  2201              MOVS     r2,#1                 ;4037
000058  0312              LSLS     r2,r2,#12             ;4037
00005a  1abb              SUBS     r3,r7,r2              ;4037
00005c  d013              BEQ      |L12.134|
00005e  4293              CMP      r3,r2                 ;4037
000060  d141              BNE      |L12.230|
000062  6802              LDR      r2,[r0,#0]            ;4084
000064  688e              LDR      r6,[r1,#8]            ;4084
000066  684c              LDR      r4,[r1,#4]            ;4084
000068  68cb              LDR      r3,[r1,#0xc]          ;4084
00006a  6891              LDR      r1,[r2,#8]            ;4084
00006c  021b              LSLS     r3,r3,#8              ;4084
00006e  4323              ORRS     r3,r3,r4              ;4084
000070  43a9              BICS     r1,r1,r5              ;4084
000072  4333              ORRS     r3,r3,r6              ;4084
000074  430b              ORRS     r3,r3,r1              ;4084
000076  6093              STR      r3,[r2,#8]            ;4084
000078  6801              LDR      r1,[r0,#0]            ;4089
00007a  688a              LDR      r2,[r1,#8]            ;4089
00007c  2301              MOVS     r3,#1                 ;4089
00007e  039b              LSLS     r3,r3,#14             ;4089
000080  431a              ORRS     r2,r2,r3              ;4089
                  |L12.130|
000082  608a              STR      r2,[r1,#8]            ;4043
000084  e089              B        |L12.410|
                  |L12.134|
000086  6801              LDR      r1,[r0,#0]            ;4043
000088  688a              LDR      r2,[r1,#8]            ;4043
00008a  08d2              LSRS     r2,r2,#3              ;4043
00008c  00d2              LSLS     r2,r2,#3              ;4043
00008e  e7f8              B        |L12.130|
                  |L12.144|
000090  6802              LDR      r2,[r0,#0]            ;4058
000092  68cf              LDR      r7,[r1,#0xc]          ;4058
000094  688e              LDR      r6,[r1,#8]            ;4058
000096  684b              LDR      r3,[r1,#4]            ;4058
000098  6891              LDR      r1,[r2,#8]            ;4058
00009a  43a9              BICS     r1,r1,r5              ;4058
00009c  023d              LSLS     r5,r7,#8              ;4058
00009e  431d              ORRS     r5,r5,r3              ;4058
0000a0  4335              ORRS     r5,r5,r6              ;4058
0000a2  430d              ORRS     r5,r5,r1              ;4058
0000a4  6095              STR      r5,[r2,#8]            ;4058
0000a6  6802              LDR      r2,[r0,#0]            ;4063
0000a8  6891              LDR      r1,[r2,#8]            ;4063
0000aa  43a1              BICS     r1,r1,r4              ;4065
0000ac  4321              ORRS     r1,r1,r4              ;4067
0000ae  6091              STR      r1,[r2,#8]            ;4069
0000b0  e073              B        |L12.410|
                  |L12.178|
0000b2  6804              LDR      r4,[r0,#0]            ;4102
0000b4  684d              LDR      r5,[r1,#4]            ;4102
0000b6  68cf              LDR      r7,[r1,#0xc]          ;4102
0000b8  6a21              LDR      r1,[r4,#0x20]         ;4102
0000ba  46ac              MOV      r12,r5                ;4102
0000bc  6a25              LDR      r5,[r4,#0x20]         ;4102
0000be  086d              LSRS     r5,r5,#1              ;4102
0000c0  006d              LSLS     r5,r5,#1              ;4102
0000c2  6225              STR      r5,[r4,#0x20]         ;4102
0000c4  69a5              LDR      r5,[r4,#0x18]         ;4102
0000c6  43b5              BICS     r5,r5,r6              ;4102
0000c8  013e              LSLS     r6,r7,#4              ;4102
0000ca  432e              ORRS     r6,r6,r5              ;4102
0000cc  250a              MOVS     r5,#0xa               ;4102
0000ce  43a9              BICS     r1,r1,r5              ;4102
0000d0  4665              MOV      r5,r12                ;4102
0000d2  4329              ORRS     r1,r1,r5              ;4102
0000d4  61a6              STR      r6,[r4,#0x18]         ;4102
0000d6  6221              STR      r1,[r4,#0x20]         ;4102
0000d8  6804              LDR      r4,[r0,#0]            ;4102
0000da  2550              MOVS     r5,#0x50              ;4105
0000dc  68a1              LDR      r1,[r4,#8]            ;4105
0000de  4391              BICS     r1,r1,r2              ;4105
0000e0  4329              ORRS     r1,r1,r5              ;4105
0000e2  4319              ORRS     r1,r1,r3              ;4105
0000e4  60a1              STR      r1,[r4,#8]            ;4105
                  |L12.230|
0000e6  e058              B        |L12.410|
                  |L12.232|
0000e8  6804              LDR      r4,[r0,#0]            ;4117
0000ea  684f              LDR      r7,[r1,#4]            ;4117
0000ec  68ce              LDR      r6,[r1,#0xc]          ;4117
0000ee  6a21              LDR      r1,[r4,#0x20]         ;4117
0000f0  46bc              MOV      r12,r7                ;4117
0000f2  2510              MOVS     r5,#0x10              ;4117
0000f4  43a9              BICS     r1,r1,r5              ;4117
0000f6  6221              STR      r1,[r4,#0x20]         ;4117
0000f8  69a1              LDR      r1,[r4,#0x18]         ;4117
0000fa  6a25              LDR      r5,[r4,#0x20]         ;4117
0000fc  270f              MOVS     r7,#0xf               ;4117
0000fe  033f              LSLS     r7,r7,#12             ;4117
000100  43b9              BICS     r1,r1,r7              ;4117
000102  0336              LSLS     r6,r6,#12             ;4117
000104  430e              ORRS     r6,r6,r1              ;4117
000106  21a0              MOVS     r1,#0xa0              ;4117
000108  438d              BICS     r5,r5,r1              ;4117
00010a  4667              MOV      r7,r12                ;4117
00010c  0139              LSLS     r1,r7,#4              ;4117
00010e  4329              ORRS     r1,r1,r5              ;4117
000110  61a6              STR      r6,[r4,#0x18]         ;4117
000112  6221              STR      r1,[r4,#0x20]         ;4117
000114  6804              LDR      r4,[r0,#0]            ;4117
000116  2560              MOVS     r5,#0x60              ;4120
000118  68a1              LDR      r1,[r4,#8]            ;4120
00011a  4391              BICS     r1,r1,r2              ;4120
00011c  4329              ORRS     r1,r1,r5              ;4120
00011e  4319              ORRS     r1,r1,r3              ;4120
000120  60a1              STR      r1,[r4,#8]            ;4120
000122  e03a              B        |L12.410|
                  |L12.292|
000124  e02a              B        |L12.380|
                  |L12.294|
000126  e01b              B        |L12.352|
                  |L12.296|
000128  e030              B        |L12.396|
                  |L12.298|
00012a  6804              LDR      r4,[r0,#0]            ;4132
00012c  684d              LDR      r5,[r1,#4]            ;4132
00012e  68cf              LDR      r7,[r1,#0xc]          ;4132
000130  6a21              LDR      r1,[r4,#0x20]         ;4132
000132  46ac              MOV      r12,r5                ;4132
000134  6a25              LDR      r5,[r4,#0x20]         ;4132
000136  086d              LSRS     r5,r5,#1              ;4132
000138  006d              LSLS     r5,r5,#1              ;4132
00013a  6225              STR      r5,[r4,#0x20]         ;4132
00013c  69a5              LDR      r5,[r4,#0x18]         ;4132
00013e  43b5              BICS     r5,r5,r6              ;4132
000140  013e              LSLS     r6,r7,#4              ;4132
000142  432e              ORRS     r6,r6,r5              ;4132
000144  250a              MOVS     r5,#0xa               ;4132
000146  43a9              BICS     r1,r1,r5              ;4132
000148  4665              MOV      r5,r12                ;4132
00014a  4329              ORRS     r1,r1,r5              ;4132
00014c  61a6              STR      r6,[r4,#0x18]         ;4132
00014e  6221              STR      r1,[r4,#0x20]         ;4132
000150  6804              LDR      r4,[r0,#0]            ;4132
000152  2540              MOVS     r5,#0x40              ;4135
000154  68a1              LDR      r1,[r4,#8]            ;4135
000156  4391              BICS     r1,r1,r2              ;4135
000158  4329              ORRS     r1,r1,r5              ;4135
00015a  4319              ORRS     r1,r1,r3              ;4135
00015c  60a1              STR      r1,[r4,#8]            ;4135
00015e  e01c              B        |L12.410|
                  |L12.352|
000160  6804              LDR      r4,[r0,#0]            ;4137
000162  68a1              LDR      r1,[r4,#8]            ;4137
000164  4391              BICS     r1,r1,r2              ;4137
000166  4319              ORRS     r1,r1,r3              ;4137
000168  60a1              STR      r1,[r4,#8]            ;4137
00016a  e016              B        |L12.410|
                  |L12.364|
00016c  6804              LDR      r4,[r0,#0]            ;4145
00016e  2510              MOVS     r5,#0x10              ;4151
000170  68a1              LDR      r1,[r4,#8]            ;4151
000172  4391              BICS     r1,r1,r2              ;4151
000174  4329              ORRS     r1,r1,r5              ;4151
000176  4319              ORRS     r1,r1,r3              ;4151
000178  60a1              STR      r1,[r4,#8]            ;4151
00017a  e00e              B        |L12.410|
                  |L12.380|
00017c  6804              LDR      r4,[r0,#0]            ;4153
00017e  2520              MOVS     r5,#0x20              ;4159
000180  68a1              LDR      r1,[r4,#8]            ;4159
000182  4391              BICS     r1,r1,r2              ;4159
000184  4329              ORRS     r1,r1,r5              ;4159
000186  4319              ORRS     r1,r1,r3              ;4159
000188  60a1              STR      r1,[r4,#8]            ;4159
00018a  e006              B        |L12.410|
                  |L12.396|
00018c  6804              LDR      r4,[r0,#0]            ;4161
00018e  2530              MOVS     r5,#0x30              ;4167
000190  68a1              LDR      r1,[r4,#8]            ;4167
000192  4391              BICS     r1,r1,r2              ;4167
000194  4329              ORRS     r1,r1,r5              ;4167
000196  4319              ORRS     r1,r1,r3              ;4167
000198  60a1              STR      r1,[r4,#8]            ;4167
                  |L12.410|
00019a  2101              MOVS     r1,#1                 ;4174
00019c  6401              STR      r1,[r0,#0x40]         ;4174
00019e  2100              MOVS     r1,#0                 ;4176
0001a0  63c1              STR      r1,[r0,#0x3c]         ;4178
0001a2  bcf0              POP      {r4-r7}
0001a4  4608              MOV      r0,r1                 ;4178
0001a6  4770              BX       lr
;;;4180   
                          ENDP


                          AREA ||i.HAL_TIM_ConfigOCrefClear||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigOCrefClear PROC
;;;3890     */ 
;;;3891   __weak HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim, TIM_ClearInputConfigTypeDef * sClearInputConfig, uint32_t Channel)
000000  b4f0              PUSH     {r4-r7}
;;;3892   {
000002  4694              MOV      r12,r2
;;;3893     uint32_t tmpsmcr = 0;
;;;3894   
;;;3895     /* Check the parameters */
;;;3896     assert_param(IS_TIM_OCXREF_CLEAR_INSTANCE(htim->Instance));
;;;3897     assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
;;;3898     assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
;;;3899     assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
;;;3900     assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
;;;3901   
;;;3902     /* Process Locked */
;;;3903     __HAL_LOCK(htim);
000004  6bc2              LDR      r2,[r0,#0x3c]
000006  2a01              CMP      r2,#1
000008  d00b              BEQ      |L13.34|
00000a  2201              MOVS     r2,#1
;;;3904   
;;;3905     htim->State = HAL_TIM_STATE_BUSY;
00000c  63c2              STR      r2,[r0,#0x3c]
00000e  2202              MOVS     r2,#2
000010  6402              STR      r2,[r0,#0x40]
;;;3906   
;;;3907     switch (sClearInputConfig->ClearInputSource)
;;;3908     {
;;;3909       case TIM_CLEARINPUTSOURCE_NONE:
;;;3910       {
;;;3911         /* Get the TIMx SMCR register value */
;;;3912         tmpsmcr = htim->Instance->SMCR;
;;;3913         
;;;3914         /* Clear the OCREF clear selection bit */
;;;3915         tmpsmcr &= ~TIM_SMCR_OCCS;
;;;3916   
;;;3917         /* Clear the ETR Bits */
;;;3918         tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
000012  25ff              MOVS     r5,#0xff
000014  684a              LDR      r2,[r1,#4]            ;3907
000016  022d              LSLS     r5,r5,#8
000018  2a00              CMP      r2,#0                 ;3907
00001a  d005              BEQ      |L13.40|
00001c  2a01              CMP      r2,#1                 ;3907
00001e  d11a              BNE      |L13.86|
000020  e009              B        |L13.54|
                  |L13.34|
;;;3919   
;;;3920         /* Set TIMx_SMCR */
;;;3921         htim->Instance->SMCR = tmpsmcr;
;;;3922      }
;;;3923       break;
;;;3924   
;;;3925       case TIM_CLEARINPUTSOURCE_ETR:
;;;3926       {
;;;3927         TIM_ETR_SetConfig(htim->Instance,
;;;3928                           sClearInputConfig->ClearInputPrescaler,
;;;3929                           sClearInputConfig->ClearInputPolarity,
;;;3930                           sClearInputConfig->ClearInputFilter);
;;;3931   
;;;3932         /* Set the OCREF clear selection bit */
;;;3933         htim->Instance->SMCR |= TIM_SMCR_OCCS;
;;;3934       }
;;;3935       break;
;;;3936       default:
;;;3937       break;
;;;3938     }
;;;3939   
;;;3940     switch (Channel)
;;;3941     {
;;;3942       case TIM_CHANNEL_1:
;;;3943         {
;;;3944           if(sClearInputConfig->ClearInputState != RESET)
;;;3945           {
;;;3946             /* Enable the Ocref clear feature for Channel 1 */
;;;3947             htim->Instance->CCMR1 |= TIM_CCMR1_OC1CE;
;;;3948           }
;;;3949           else
;;;3950           {
;;;3951             /* Disable the Ocref clear feature for Channel 1 */
;;;3952           htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1CE;
;;;3953           }
;;;3954         }
;;;3955         break;
;;;3956       case TIM_CHANNEL_2:
;;;3957         {
;;;3958           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3959           if(sClearInputConfig->ClearInputState != RESET)
;;;3960           {
;;;3961             /* Enable the Ocref clear feature for Channel 2 */
;;;3962             htim->Instance->CCMR1 |= TIM_CCMR1_OC2CE;
;;;3963           }
;;;3964           else
;;;3965           {
;;;3966             /* Disable the Ocref clear feature for Channel 2 */
;;;3967             htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2CE;
;;;3968           }
;;;3969         }
;;;3970       break;
;;;3971       case TIM_CHANNEL_3:
;;;3972         {
;;;3973           assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3974           if(sClearInputConfig->ClearInputState != RESET)
;;;3975           {
;;;3976             /* Enable the Ocref clear feature for Channel 3 */
;;;3977             htim->Instance->CCMR2 |= TIM_CCMR2_OC3CE;
;;;3978           }
;;;3979           else
;;;3980           {
;;;3981             /* Disable the Ocref clear feature for Channel 3 */
;;;3982           htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3CE;
;;;3983           }
;;;3984         }
;;;3985       break;
;;;3986       case TIM_CHANNEL_4:
;;;3987         {
;;;3988           assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3989           if(sClearInputConfig->ClearInputState != RESET)
;;;3990           {
;;;3991             /* Enable the Ocref clear feature for Channel 4 */
;;;3992             htim->Instance->CCMR2 |= TIM_CCMR2_OC4CE;
;;;3993           }
;;;3994           else
;;;3995           {
;;;3996             /* Disable the Ocref clear feature for Channel 4 */
;;;3997           htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4CE;
;;;3998           }
;;;3999         }
;;;4000       break;
;;;4001       default:
;;;4002       break;
;;;4003     }
;;;4004   
;;;4005     htim->State = HAL_TIM_STATE_READY;
;;;4006   
;;;4007     __HAL_UNLOCK(htim);
;;;4008   
;;;4009     return HAL_OK;
;;;4010   }
000022  bcf0              POP      {r4-r7}
000024  2002              MOVS     r0,#2                 ;3903
000026  4770              BX       lr
                  |L13.40|
000028  6803              LDR      r3,[r0,#0]            ;3912
00002a  689a              LDR      r2,[r3,#8]            ;3912
00002c  2408              MOVS     r4,#8                 ;3915
00002e  43a2              BICS     r2,r2,r4              ;3915
000030  43aa              BICS     r2,r2,r5              ;3918
000032  609a              STR      r2,[r3,#8]            ;3921
000034  e00f              B        |L13.86|
                  |L13.54|
000036  6804              LDR      r4,[r0,#0]            ;3927
000038  690f              LDR      r7,[r1,#0x10]         ;3927
00003a  68ce              LDR      r6,[r1,#0xc]          ;3927
00003c  688a              LDR      r2,[r1,#8]            ;3927
00003e  68a3              LDR      r3,[r4,#8]            ;3927
000040  43ab              BICS     r3,r3,r5              ;3927
000042  023d              LSLS     r5,r7,#8              ;3927
000044  4315              ORRS     r5,r5,r2              ;3927
000046  4335              ORRS     r5,r5,r6              ;3927
000048  431d              ORRS     r5,r5,r3              ;3927
00004a  60a5              STR      r5,[r4,#8]            ;3927
00004c  6802              LDR      r2,[r0,#0]            ;3933
00004e  6893              LDR      r3,[r2,#8]            ;3933
000050  2408              MOVS     r4,#8                 ;3933
000052  4323              ORRS     r3,r3,r4              ;3933
000054  6093              STR      r3,[r2,#8]            ;3933
                  |L13.86|
000056  4664              MOV      r4,r12                ;3940
000058  2280              MOVS     r2,#0x80              ;3947
00005a  2c00              CMP      r4,#0                 ;3940
00005c  d007              BEQ      |L13.110|
00005e  0213              LSLS     r3,r2,#8              ;3962
000060  2c04              CMP      r4,#4                 ;3940
000062  d00e              BEQ      |L13.130|
000064  2c08              CMP      r4,#8                 ;3940
000066  d016              BEQ      |L13.150|
000068  2c0c              CMP      r4,#0xc               ;3940
00006a  d127              BNE      |L13.188|
00006c  e01d              B        |L13.170|
                  |L13.110|
00006e  6809              LDR      r1,[r1,#0]            ;3944
000070  2900              CMP      r1,#0                 ;3944
000072  6801              LDR      r1,[r0,#0]            ;3952
000074  698b              LDR      r3,[r1,#0x18]         ;3952
000076  d001              BEQ      |L13.124|
000078  4313              ORRS     r3,r3,r2              ;3947
00007a  e000              B        |L13.126|
                  |L13.124|
00007c  4393              BICS     r3,r3,r2              ;3952
                  |L13.126|
00007e  618b              STR      r3,[r1,#0x18]         ;3947
000080  e01c              B        |L13.188|
                  |L13.130|
000082  6809              LDR      r1,[r1,#0]            ;3959
000084  2900              CMP      r1,#0                 ;3959
000086  6801              LDR      r1,[r0,#0]            ;3967
000088  698a              LDR      r2,[r1,#0x18]         ;3967
00008a  d001              BEQ      |L13.144|
00008c  431a              ORRS     r2,r2,r3              ;3962
00008e  e000              B        |L13.146|
                  |L13.144|
000090  439a              BICS     r2,r2,r3              ;3967
                  |L13.146|
000092  618a              STR      r2,[r1,#0x18]         ;3962
000094  e012              B        |L13.188|
                  |L13.150|
000096  6809              LDR      r1,[r1,#0]            ;3974
000098  2900              CMP      r1,#0                 ;3974
00009a  6801              LDR      r1,[r0,#0]            ;3982
00009c  69cb              LDR      r3,[r1,#0x1c]         ;3982
00009e  d001              BEQ      |L13.164|
0000a0  4313              ORRS     r3,r3,r2              ;3977
0000a2  e000              B        |L13.166|
                  |L13.164|
0000a4  4393              BICS     r3,r3,r2              ;3982
                  |L13.166|
0000a6  61cb              STR      r3,[r1,#0x1c]         ;3977
0000a8  e008              B        |L13.188|
                  |L13.170|
0000aa  6809              LDR      r1,[r1,#0]            ;3989
0000ac  2900              CMP      r1,#0                 ;3989
0000ae  6801              LDR      r1,[r0,#0]            ;3997
0000b0  69ca              LDR      r2,[r1,#0x1c]         ;3997
0000b2  d001              BEQ      |L13.184|
0000b4  431a              ORRS     r2,r2,r3              ;3992
0000b6  e000              B        |L13.186|
                  |L13.184|
0000b8  439a              BICS     r2,r2,r3              ;3997
                  |L13.186|
0000ba  61ca              STR      r2,[r1,#0x1c]         ;3992
                  |L13.188|
0000bc  2101              MOVS     r1,#1                 ;4005
0000be  6401              STR      r1,[r0,#0x40]         ;4005
0000c0  2100              MOVS     r1,#0                 ;4007
0000c2  63c1              STR      r1,[r0,#0x3c]         ;4009
0000c4  bcf0              POP      {r4-r7}
0000c6  4608              MOV      r0,r1                 ;4009
0000c8  4770              BX       lr
;;;4011   
                          ENDP


                          AREA ||i.HAL_TIM_ConfigTI1Input||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigTI1Input PROC
;;;4192     */
;;;4193   HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
000000  6802              LDR      r2,[r0,#0]
;;;4194   {
;;;4195     uint32_t tmpcr2 = 0U;
;;;4196   
;;;4197     /* Check the parameters */
;;;4198     assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;4199     assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
;;;4200   
;;;4201     /* Get the TIMx CR2 register value */
;;;4202     tmpcr2 = htim->Instance->CR2;
000002  6850              LDR      r0,[r2,#4]
;;;4203   
;;;4204     /* Reset the TI1 selection */
;;;4205     tmpcr2 &= ~TIM_CR2_TI1S;
000004  2380              MOVS     r3,#0x80
000006  4398              BICS     r0,r0,r3
;;;4206   
;;;4207     /* Set the the TI1 selection */
;;;4208     tmpcr2 |= TI1_Selection;
000008  4308              ORRS     r0,r0,r1
;;;4209   
;;;4210     /* Write to TIMxCR2 */
;;;4211     htim->Instance->CR2 = tmpcr2;
00000a  6050              STR      r0,[r2,#4]
;;;4212   
;;;4213     return HAL_OK;
00000c  2000              MOVS     r0,#0
;;;4214   }
00000e  4770              BX       lr
;;;4215   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_MultiReadStart||, CODE, READONLY, ALIGN=2

                  HAL_TIM_DMABurst_MultiReadStart PROC
;;;3648     */
;;;3649   HAL_StatusTypeDef HAL_TIM_DMABurst_MultiReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
000000  b5ff              PUSH     {r0-r7,lr}
;;;3650                                                     uint32_t  *BurstBuffer, uint32_t  BurstLength, uint32_t  DataLength)
;;;3651   {
000002  b081              SUB      sp,sp,#4
000004  469c              MOV      r12,r3
000006  4604              MOV      r4,r0
;;;3652     /* Check the parameters */
;;;3653     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;3654     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;3655     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3656     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;3657     assert_param(IS_TIM_DMA_DATA_LENGTH(DataLength));
;;;3658   
;;;3659     if((htim->State == HAL_TIM_STATE_BUSY))
000008  9e0a              LDR      r6,[sp,#0x28]
00000a  9b0b              LDR      r3,[sp,#0x2c]
00000c  6c00              LDR      r0,[r0,#0x40]
00000e  4615              MOV      r5,r2                 ;3651
000010  2802              CMP      r0,#2
000012  d008              BEQ      |L15.38|
;;;3660     {
;;;3661        return HAL_BUSY;
;;;3662     }
;;;3663     else if((htim->State == HAL_TIM_STATE_READY))
000014  6c20              LDR      r0,[r4,#0x40]
000016  2801              CMP      r0,#1
000018  d109              BNE      |L15.46|
;;;3664     {
;;;3665       if((BurstBuffer == 0U ) && (BurstLength > 0U))
00001a  4660              MOV      r0,r12
00001c  2800              CMP      r0,#0
00001e  d104              BNE      |L15.42|
000020  2e00              CMP      r6,#0
000022  d002              BEQ      |L15.42|
;;;3666       {
;;;3667         return HAL_ERROR;
000024  2001              MOVS     r0,#1
                  |L15.38|
;;;3668       }
;;;3669       else
;;;3670       {
;;;3671         htim->State = HAL_TIM_STATE_BUSY;
;;;3672       }
;;;3673     }
;;;3674     switch(BurstRequestSrc)
;;;3675     {
;;;3676       case TIM_DMA_UPDATE:
;;;3677       {
;;;3678         /* Set the DMA Period elapsed callback */
;;;3679         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;3680   
;;;3681         /* Set the DMA error callback */
;;;3682         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;3683   
;;;3684         /* Enable the DMA channel */
;;;3685          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, DataLength);
;;;3686       }
;;;3687       break;
;;;3688       case TIM_DMA_CC1:
;;;3689       {
;;;3690         /* Set the DMA Period elapsed callback */
;;;3691         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback =  TIM_DMACaptureCplt;
;;;3692   
;;;3693         /* Set the DMA error callback */
;;;3694         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;3695   
;;;3696         /* Enable the DMA channel */
;;;3697         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, DataLength);
;;;3698       }
;;;3699       break;
;;;3700       case TIM_DMA_CC2:
;;;3701       {
;;;3702         /* Set the DMA Period elapsed callback */
;;;3703         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback =  TIM_DMACaptureCplt;
;;;3704   
;;;3705         /* Set the DMA error callback */
;;;3706         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;3707   
;;;3708         /* Enable the DMA channel */
;;;3709         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, DataLength);
;;;3710       }
;;;3711       break;
;;;3712       case TIM_DMA_CC3:
;;;3713       {
;;;3714         /* Set the DMA Period elapsed callback */
;;;3715         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback =  TIM_DMACaptureCplt;
;;;3716   
;;;3717         /* Set the DMA error callback */
;;;3718         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;3719   
;;;3720         /* Enable the DMA channel */
;;;3721         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, DataLength);
;;;3722       }
;;;3723       break;
;;;3724       case TIM_DMA_CC4:
;;;3725       {
;;;3726         /* Set the DMA Period elapsed callback */
;;;3727         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback =  TIM_DMACaptureCplt;
;;;3728   
;;;3729         /* Set the DMA error callback */
;;;3730         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;3731   
;;;3732         /* Enable the DMA channel */
;;;3733         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, DataLength);
;;;3734       }
;;;3735       break;
;;;3736       case TIM_DMA_COM:
;;;3737       {
;;;3738         /* Set the DMA Period elapsed callback */
;;;3739         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
;;;3740   
;;;3741         /* Set the DMA error callback */
;;;3742         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
;;;3743   
;;;3744         /* Enable the DMA channel */
;;;3745         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, DataLength);
;;;3746       }
;;;3747       break;
;;;3748       case TIM_DMA_TRIGGER:
;;;3749       {
;;;3750         /* Set the DMA Period elapsed callback */
;;;3751         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;3752   
;;;3753         /* Set the DMA error callback */
;;;3754         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
;;;3755   
;;;3756         /* Enable the DMA channel */
;;;3757         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, DataLength);
;;;3758       }
;;;3759       break;
;;;3760       default:
;;;3761       break;
;;;3762     }
;;;3763   
;;;3764     /* configure the DMA Burst Mode */
;;;3765     htim->Instance->DCR = BurstBaseAddress | BurstLength;
;;;3766   
;;;3767     /* Enable the TIM DMA Request */
;;;3768     __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
;;;3769   
;;;3770     htim->State = HAL_TIM_STATE_READY;
;;;3771   
;;;3772     /* Return function status */
;;;3773     return HAL_OK;
;;;3774   }
000026  b005              ADD      sp,sp,#0x14
000028  bdf0              POP      {r4-r7,pc}
                  |L15.42|
00002a  2002              MOVS     r0,#2                 ;3671
00002c  6420              STR      r0,[r4,#0x40]         ;3671
                  |L15.46|
00002e  2201              MOVS     r2,#1                 ;3674
000030  02d2              LSLS     r2,r2,#11             ;3674
000032  1aaf              SUBS     r7,r5,r2              ;3674
000034  483a              LDR      r0,|L15.288|
000036  493b              LDR      r1,|L15.292|
000038  4295              CMP      r5,r2                 ;3674
00003a  d04f              BEQ      |L15.220|
00003c  dc0a              BGT      |L15.84|
00003e  1fea              SUBS     r2,r5,#7              ;3674
000040  3af9              SUBS     r2,r2,#0xf9           ;3674
000042  d029              BEQ      |L15.152|
000044  3aff              SUBS     r2,r2,#0xff           ;3674
000046  1e52              SUBS     r2,r2,#1              ;3674
000048  d032              BEQ      |L15.176|
00004a  3aff              SUBS     r2,r2,#0xff           ;3674
00004c  3aff              SUBS     r2,r2,#0xff           ;3674
00004e  2a02              CMP      r2,#2                 ;3674
000050  d115              BNE      |L15.126|
000052  e038              B        |L15.198|
                  |L15.84|
000054  1aba              SUBS     r2,r7,r2              ;3674
000056  d04c              BEQ      |L15.242|
000058  2101              MOVS     r1,#1                 ;3674
00005a  0309              LSLS     r1,r1,#12             ;3674
00005c  1a51              SUBS     r1,r2,r1              ;3674
00005e  d053              BEQ      |L15.264|
000060  2201              MOVS     r2,#1                 ;3674
000062  0352              LSLS     r2,r2,#13             ;3674
000064  4291              CMP      r1,r2                 ;3674
000066  d10a              BNE      |L15.126|
000068  6ba2              LDR      r2,[r4,#0x38]         ;3751
00006a  492f              LDR      r1,|L15.296|
00006c  62d1              STR      r1,[r2,#0x2c]         ;3754
00006e  6ba1              LDR      r1,[r4,#0x38]         ;3754
000070  4662              MOV      r2,r12                ;3757
000072  6348              STR      r0,[r1,#0x34]         ;3757
000074  6821              LDR      r1,[r4,#0]            ;3757
000076  6ba0              LDR      r0,[r4,#0x38]         ;3757
000078  314c              ADDS     r1,r1,#0x4c           ;3757
00007a  f7fffffe          BL       HAL_DMA_Start_IT
                  |L15.126|
00007e  9802              LDR      r0,[sp,#8]            ;3765
000080  6821              LDR      r1,[r4,#0]            ;3765
000082  4330              ORRS     r0,r0,r6              ;3765
000084  6488              STR      r0,[r1,#0x48]         ;3765
000086  6820              LDR      r0,[r4,#0]            ;3768
000088  68c1              LDR      r1,[r0,#0xc]          ;3768
00008a  4329              ORRS     r1,r1,r5              ;3768
00008c  60c1              STR      r1,[r0,#0xc]          ;3768
00008e  2001              MOVS     r0,#1                 ;3770
000090  6420              STR      r0,[r4,#0x40]         ;3770
000092  2000              MOVS     r0,#0                 ;3773
000094  b005              ADD      sp,sp,#0x14
000096  bdf0              POP      {r4-r7,pc}
                  |L15.152|
000098  6a22              LDR      r2,[r4,#0x20]         ;3679
00009a  4924              LDR      r1,|L15.300|
00009c  62d1              STR      r1,[r2,#0x2c]         ;3682
00009e  6a21              LDR      r1,[r4,#0x20]         ;3682
0000a0  4662              MOV      r2,r12                ;3685
0000a2  6348              STR      r0,[r1,#0x34]         ;3685
0000a4  6821              LDR      r1,[r4,#0]            ;3685
0000a6  6a20              LDR      r0,[r4,#0x20]         ;3685
0000a8  314c              ADDS     r1,r1,#0x4c           ;3685
0000aa  f7fffffe          BL       HAL_DMA_Start_IT
0000ae  e7e6              B        |L15.126|
                  |L15.176|
0000b0  6a62              LDR      r2,[r4,#0x24]         ;3691
0000b2  62d1              STR      r1,[r2,#0x2c]         ;3694
0000b4  6a61              LDR      r1,[r4,#0x24]         ;3694
0000b6  4662              MOV      r2,r12                ;3697
0000b8  6348              STR      r0,[r1,#0x34]         ;3697
0000ba  6821              LDR      r1,[r4,#0]            ;3697
0000bc  6a60              LDR      r0,[r4,#0x24]         ;3697
0000be  314c              ADDS     r1,r1,#0x4c           ;3697
0000c0  f7fffffe          BL       HAL_DMA_Start_IT
0000c4  e7db              B        |L15.126|
                  |L15.198|
0000c6  6aa2              LDR      r2,[r4,#0x28]         ;3703
0000c8  62d1              STR      r1,[r2,#0x2c]         ;3706
0000ca  6aa1              LDR      r1,[r4,#0x28]         ;3706
0000cc  4662              MOV      r2,r12                ;3709
0000ce  6348              STR      r0,[r1,#0x34]         ;3709
0000d0  6821              LDR      r1,[r4,#0]            ;3709
0000d2  6aa0              LDR      r0,[r4,#0x28]         ;3709
0000d4  314c              ADDS     r1,r1,#0x4c           ;3709
0000d6  f7fffffe          BL       HAL_DMA_Start_IT
0000da  e7d0              B        |L15.126|
                  |L15.220|
0000dc  6ae2              LDR      r2,[r4,#0x2c]         ;3715
0000de  62d1              STR      r1,[r2,#0x2c]         ;3718
0000e0  6ae1              LDR      r1,[r4,#0x2c]         ;3718
0000e2  4662              MOV      r2,r12                ;3721
0000e4  6348              STR      r0,[r1,#0x34]         ;3721
0000e6  6821              LDR      r1,[r4,#0]            ;3721
0000e8  6ae0              LDR      r0,[r4,#0x2c]         ;3721
0000ea  314c              ADDS     r1,r1,#0x4c           ;3721
0000ec  f7fffffe          BL       HAL_DMA_Start_IT
0000f0  e7c5              B        |L15.126|
                  |L15.242|
0000f2  6b22              LDR      r2,[r4,#0x30]         ;3727
0000f4  62d1              STR      r1,[r2,#0x2c]         ;3730
0000f6  6b21              LDR      r1,[r4,#0x30]         ;3730
0000f8  4662              MOV      r2,r12                ;3733
0000fa  6348              STR      r0,[r1,#0x34]         ;3733
0000fc  6821              LDR      r1,[r4,#0]            ;3733
0000fe  6b20              LDR      r0,[r4,#0x30]         ;3733
000100  314c              ADDS     r1,r1,#0x4c           ;3733
000102  f7fffffe          BL       HAL_DMA_Start_IT
000106  e7ba              B        |L15.126|
                  |L15.264|
000108  6b62              LDR      r2,[r4,#0x34]         ;3739
00010a  4909              LDR      r1,|L15.304|
00010c  62d1              STR      r1,[r2,#0x2c]         ;3742
00010e  6b61              LDR      r1,[r4,#0x34]         ;3742
000110  4662              MOV      r2,r12                ;3745
000112  6348              STR      r0,[r1,#0x34]         ;3745
000114  6821              LDR      r1,[r4,#0]            ;3745
000116  6b60              LDR      r0,[r4,#0x34]         ;3745
000118  314c              ADDS     r1,r1,#0x4c           ;3745
00011a  f7fffffe          BL       HAL_DMA_Start_IT
00011e  e7ae              B        |L15.126|
;;;3775   
                          ENDP

                  |L15.288|
                          DCD      TIM_DMAError
                  |L15.292|
                          DCD      TIM_DMACaptureCplt
                  |L15.296|
                          DCD      TIM_DMATriggerCplt
                  |L15.300|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L15.304|
                          DCD      TIMEx_DMACommutationCplt

                          AREA ||i.HAL_TIM_DMABurst_MultiWriteStart||, CODE, READONLY, ALIGN=2

                  HAL_TIM_DMABurst_MultiWriteStart PROC
;;;3378     */
;;;3379   HAL_StatusTypeDef HAL_TIM_DMABurst_MultiWriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
000000  b5ff              PUSH     {r0-r7,lr}
;;;3380                                                      uint32_t* BurstBuffer, uint32_t  BurstLength,  uint32_t  DataLength)
;;;3381   {
000002  b081              SUB      sp,sp,#4
000004  469c              MOV      r12,r3
000006  4604              MOV      r4,r0
;;;3382     /* Check the parameters */
;;;3383     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;3384     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;3385     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3386     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;3387     assert_param(IS_TIM_DMA_DATA_LENGTH(DataLength));
;;;3388   
;;;3389     if((htim->State == HAL_TIM_STATE_BUSY))
000008  9e0a              LDR      r6,[sp,#0x28]
00000a  9b0b              LDR      r3,[sp,#0x2c]
00000c  6c00              LDR      r0,[r0,#0x40]
00000e  4615              MOV      r5,r2                 ;3381
000010  2802              CMP      r0,#2
000012  d008              BEQ      |L16.38|
;;;3390     {
;;;3391        return HAL_BUSY;
;;;3392     }
;;;3393     else if((htim->State == HAL_TIM_STATE_READY))
000014  6c20              LDR      r0,[r4,#0x40]
000016  2801              CMP      r0,#1
000018  d109              BNE      |L16.46|
;;;3394     {
;;;3395       if((BurstBuffer == 0U ) && (BurstLength > 0U))
00001a  4660              MOV      r0,r12
00001c  2800              CMP      r0,#0
00001e  d104              BNE      |L16.42|
000020  2e00              CMP      r6,#0
000022  d002              BEQ      |L16.42|
;;;3396       {
;;;3397         return HAL_ERROR;
000024  2001              MOVS     r0,#1
                  |L16.38|
;;;3398       }
;;;3399       else
;;;3400       {
;;;3401         htim->State = HAL_TIM_STATE_BUSY;
;;;3402       }
;;;3403     }
;;;3404     switch(BurstRequestSrc)
;;;3405     {
;;;3406       case TIM_DMA_UPDATE:
;;;3407       {
;;;3408         /* Set the DMA Period elapsed callback */
;;;3409         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;3410   
;;;3411         /* Set the DMA error callback */
;;;3412         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;3413   
;;;3414         /* Enable the DMA channel */
;;;3415         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, DataLength);
;;;3416       }
;;;3417       break;
;;;3418       case TIM_DMA_CC1:
;;;3419       {
;;;3420         /* Set the DMA Period elapsed callback */
;;;3421         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback =  TIM_DMADelayPulseCplt;
;;;3422   
;;;3423         /* Set the DMA error callback */
;;;3424         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;3425   
;;;3426         /* Enable the DMA channel */
;;;3427         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, DataLength);
;;;3428       }
;;;3429       break;
;;;3430       case TIM_DMA_CC2:
;;;3431       {
;;;3432         /* Set the DMA Period elapsed callback */
;;;3433         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback =  TIM_DMADelayPulseCplt;
;;;3434   
;;;3435         /* Set the DMA error callback */
;;;3436         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;3437   
;;;3438         /* Enable the DMA channel */
;;;3439         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, DataLength);
;;;3440       }
;;;3441       break;
;;;3442       case TIM_DMA_CC3:
;;;3443       {
;;;3444         /* Set the DMA Period elapsed callback */
;;;3445         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback =  TIM_DMADelayPulseCplt;
;;;3446   
;;;3447         /* Set the DMA error callback */
;;;3448         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;3449   
;;;3450         /* Enable the DMA channel */
;;;3451         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, DataLength);
;;;3452       }
;;;3453       break;
;;;3454       case TIM_DMA_CC4:
;;;3455       {
;;;3456         /* Set the DMA Period elapsed callback */
;;;3457         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback =  TIM_DMADelayPulseCplt;
;;;3458   
;;;3459         /* Set the DMA error callback */
;;;3460         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;3461   
;;;3462         /* Enable the DMA channel */
;;;3463         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, DataLength);
;;;3464       }
;;;3465       break;
;;;3466       case TIM_DMA_COM:
;;;3467       {
;;;3468         /* Set the DMA Period elapsed callback */
;;;3469         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
;;;3470   
;;;3471         /* Set the DMA error callback */
;;;3472         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
;;;3473   
;;;3474         /* Enable the DMA channel */
;;;3475         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, DataLength);
;;;3476       }
;;;3477       break;
;;;3478       case TIM_DMA_TRIGGER:
;;;3479       {
;;;3480         /* Set the DMA Period elapsed callback */
;;;3481         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;3482   
;;;3483         /* Set the DMA error callback */
;;;3484         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
;;;3485   
;;;3486         /* Enable the DMA channel */
;;;3487         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, DataLength);
;;;3488       }
;;;3489       break;
;;;3490       default:
;;;3491       break;
;;;3492     }
;;;3493      /* configure the DMA Burst Mode */
;;;3494      htim->Instance->DCR = BurstBaseAddress | BurstLength;
;;;3495   
;;;3496      /* Enable the TIM DMA Request */
;;;3497      __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
;;;3498   
;;;3499      htim->State = HAL_TIM_STATE_READY;
;;;3500   
;;;3501     /* Return function status */
;;;3502     return HAL_OK;
;;;3503   }
000026  b005              ADD      sp,sp,#0x14
000028  bdf0              POP      {r4-r7,pc}
                  |L16.42|
00002a  2002              MOVS     r0,#2                 ;3401
00002c  6420              STR      r0,[r4,#0x40]         ;3401
                  |L16.46|
00002e  2701              MOVS     r7,#1                 ;3404
000030  02ff              LSLS     r7,r7,#11             ;3404
000032  1be9              SUBS     r1,r5,r7              ;3404
000034  483a              LDR      r0,|L16.288|
000036  4a3b              LDR      r2,|L16.292|
000038  42bd              CMP      r5,r7                 ;3404
00003a  d04e              BEQ      |L16.218|
00003c  dc0a              BGT      |L16.84|
00003e  1fe9              SUBS     r1,r5,#7              ;3404
000040  39f9              SUBS     r1,r1,#0xf9           ;3404
000042  d028              BEQ      |L16.150|
000044  39ff              SUBS     r1,r1,#0xff           ;3404
000046  1e49              SUBS     r1,r1,#1              ;3404
000048  d031              BEQ      |L16.174|
00004a  39ff              SUBS     r1,r1,#0xff           ;3404
00004c  39ff              SUBS     r1,r1,#0xff           ;3404
00004e  2902              CMP      r1,#2                 ;3404
000050  d114              BNE      |L16.124|
000052  e037              B        |L16.196|
                  |L16.84|
000054  1bc9              SUBS     r1,r1,r7              ;3404
000056  d04b              BEQ      |L16.240|
000058  2201              MOVS     r2,#1                 ;3404
00005a  0312              LSLS     r2,r2,#12             ;3404
00005c  1a89              SUBS     r1,r1,r2              ;3404
00005e  d052              BEQ      |L16.262|
000060  0052              LSLS     r2,r2,#1              ;3404
000062  4291              CMP      r1,r2                 ;3404
000064  d10a              BNE      |L16.124|
000066  6ba2              LDR      r2,[r4,#0x38]         ;3481
000068  492f              LDR      r1,|L16.296|
00006a  62d1              STR      r1,[r2,#0x2c]         ;3484
00006c  6ba1              LDR      r1,[r4,#0x38]         ;3484
00006e  6348              STR      r0,[r1,#0x34]         ;3487
000070  6822              LDR      r2,[r4,#0]            ;3487
000072  4661              MOV      r1,r12                ;3487
000074  324c              ADDS     r2,r2,#0x4c           ;3487
000076  6ba0              LDR      r0,[r4,#0x38]         ;3487
000078  f7fffffe          BL       HAL_DMA_Start_IT
                  |L16.124|
00007c  9802              LDR      r0,[sp,#8]            ;3494
00007e  6821              LDR      r1,[r4,#0]            ;3494
000080  4330              ORRS     r0,r0,r6              ;3494
000082  6488              STR      r0,[r1,#0x48]         ;3494
000084  6820              LDR      r0,[r4,#0]            ;3497
000086  68c1              LDR      r1,[r0,#0xc]          ;3497
000088  4329              ORRS     r1,r1,r5              ;3497
00008a  60c1              STR      r1,[r0,#0xc]          ;3497
00008c  2001              MOVS     r0,#1                 ;3499
00008e  6420              STR      r0,[r4,#0x40]         ;3499
000090  2000              MOVS     r0,#0                 ;3502
000092  b005              ADD      sp,sp,#0x14
000094  bdf0              POP      {r4-r7,pc}
                  |L16.150|
000096  6a22              LDR      r2,[r4,#0x20]         ;3409
000098  4924              LDR      r1,|L16.300|
00009a  62d1              STR      r1,[r2,#0x2c]         ;3412
00009c  6a21              LDR      r1,[r4,#0x20]         ;3412
00009e  6348              STR      r0,[r1,#0x34]         ;3415
0000a0  6822              LDR      r2,[r4,#0]            ;3415
0000a2  4661              MOV      r1,r12                ;3415
0000a4  324c              ADDS     r2,r2,#0x4c           ;3415
0000a6  6a20              LDR      r0,[r4,#0x20]         ;3415
0000a8  f7fffffe          BL       HAL_DMA_Start_IT
0000ac  e7e6              B        |L16.124|
                  |L16.174|
0000ae  6a61              LDR      r1,[r4,#0x24]         ;3421
0000b0  62ca              STR      r2,[r1,#0x2c]         ;3424
0000b2  6a61              LDR      r1,[r4,#0x24]         ;3424
0000b4  6348              STR      r0,[r1,#0x34]         ;3427
0000b6  6822              LDR      r2,[r4,#0]            ;3427
0000b8  4661              MOV      r1,r12                ;3427
0000ba  324c              ADDS     r2,r2,#0x4c           ;3427
0000bc  6a60              LDR      r0,[r4,#0x24]         ;3427
0000be  f7fffffe          BL       HAL_DMA_Start_IT
0000c2  e7db              B        |L16.124|
                  |L16.196|
0000c4  6aa1              LDR      r1,[r4,#0x28]         ;3433
0000c6  62ca              STR      r2,[r1,#0x2c]         ;3436
0000c8  6aa1              LDR      r1,[r4,#0x28]         ;3436
0000ca  6348              STR      r0,[r1,#0x34]         ;3439
0000cc  6822              LDR      r2,[r4,#0]            ;3439
0000ce  4661              MOV      r1,r12                ;3439
0000d0  324c              ADDS     r2,r2,#0x4c           ;3439
0000d2  6aa0              LDR      r0,[r4,#0x28]         ;3439
0000d4  f7fffffe          BL       HAL_DMA_Start_IT
0000d8  e7d0              B        |L16.124|
                  |L16.218|
0000da  6ae1              LDR      r1,[r4,#0x2c]         ;3445
0000dc  62ca              STR      r2,[r1,#0x2c]         ;3448
0000de  6ae1              LDR      r1,[r4,#0x2c]         ;3448
0000e0  6348              STR      r0,[r1,#0x34]         ;3451
0000e2  6822              LDR      r2,[r4,#0]            ;3451
0000e4  4661              MOV      r1,r12                ;3451
0000e6  324c              ADDS     r2,r2,#0x4c           ;3451
0000e8  6ae0              LDR      r0,[r4,#0x2c]         ;3451
0000ea  f7fffffe          BL       HAL_DMA_Start_IT
0000ee  e7c5              B        |L16.124|
                  |L16.240|
0000f0  6b21              LDR      r1,[r4,#0x30]         ;3457
0000f2  62ca              STR      r2,[r1,#0x2c]         ;3460
0000f4  6b21              LDR      r1,[r4,#0x30]         ;3460
0000f6  6348              STR      r0,[r1,#0x34]         ;3463
0000f8  6822              LDR      r2,[r4,#0]            ;3463
0000fa  4661              MOV      r1,r12                ;3463
0000fc  324c              ADDS     r2,r2,#0x4c           ;3463
0000fe  6b20              LDR      r0,[r4,#0x30]         ;3463
000100  f7fffffe          BL       HAL_DMA_Start_IT
000104  e7ba              B        |L16.124|
                  |L16.262|
000106  6b62              LDR      r2,[r4,#0x34]         ;3469
000108  4909              LDR      r1,|L16.304|
00010a  62d1              STR      r1,[r2,#0x2c]         ;3472
00010c  6b61              LDR      r1,[r4,#0x34]         ;3472
00010e  6348              STR      r0,[r1,#0x34]         ;3475
000110  6822              LDR      r2,[r4,#0]            ;3475
000112  4661              MOV      r1,r12                ;3475
000114  324c              ADDS     r2,r2,#0x4c           ;3475
000116  6b60              LDR      r0,[r4,#0x34]         ;3475
000118  f7fffffe          BL       HAL_DMA_Start_IT
00011c  e7ae              B        |L16.124|
;;;3504   
                          ENDP

00011e  0000              DCW      0x0000
                  |L16.288|
                          DCD      TIM_DMAError
                  |L16.292|
                          DCD      TIM_DMADelayPulseCplt
                  |L16.296|
                          DCD      TIM_DMATriggerCplt
                  |L16.300|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L16.304|
                          DCD      TIMEx_DMACommutationCplt

                          AREA ||i.HAL_TIM_DMABurst_ReadStart||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_ReadStart PROC
;;;3602     */
;;;3603   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
000000  b530              PUSH     {r4,r5,lr}
;;;3604                                                uint32_t  *BurstBuffer, uint32_t  BurstLength)
;;;3605   {
000002  b083              SUB      sp,sp,#0xc
;;;3606   return HAL_TIM_DMABurst_MultiReadStart(htim, BurstBaseAddress, BurstRequestSrc, BurstBuffer, BurstLength, ((BurstLength) >> 8U) + 1U);
000004  9c06              LDR      r4,[sp,#0x18]
000006  9400              STR      r4,[sp,#0]
000008  0a25              LSRS     r5,r4,#8
00000a  1c6d              ADDS     r5,r5,#1
00000c  9501              STR      r5,[sp,#4]
00000e  f7fffffe          BL       HAL_TIM_DMABurst_MultiReadStart
;;;3607   }
000012  b003              ADD      sp,sp,#0xc
000014  bd30              POP      {r4,r5,pc}
;;;3608   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_ReadStop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_ReadStop PROC
;;;3781     */
;;;3782   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
000000  b570              PUSH     {r4-r6,lr}
;;;3783   {
000002  4604              MOV      r4,r0
;;;3784     /* Check the parameters */
;;;3785     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3786   
;;;3787     /* Abort the DMA transfer (at least disable the DMA channel) */
;;;3788     switch(BurstRequestSrc)
000004  2001              MOVS     r0,#1
000006  460d              MOV      r5,r1                 ;3783
000008  02c0              LSLS     r0,r0,#11
00000a  1a09              SUBS     r1,r1,r0
00000c  4285              CMP      r5,r0
00000e  d023              BEQ      |L18.88|
000010  dc0a              BGT      |L18.40|
000012  1fe8              SUBS     r0,r5,#7
000014  38f9              SUBS     r0,r0,#0xf9
000016  d019              BEQ      |L18.76|
000018  38ff              SUBS     r0,r0,#0xff
00001a  1e40              SUBS     r0,r0,#1
00001c  d018              BEQ      |L18.80|
00001e  38ff              SUBS     r0,r0,#0xff
000020  38ff              SUBS     r0,r0,#0xff
000022  2802              CMP      r0,#2
000024  d10c              BNE      |L18.64|
000026  e015              B        |L18.84|
                  |L18.40|
000028  1a08              SUBS     r0,r1,r0
00002a  d017              BEQ      |L18.92|
00002c  2101              MOVS     r1,#1
00002e  0309              LSLS     r1,r1,#12
000030  1a40              SUBS     r0,r0,r1
000032  d015              BEQ      |L18.96|
000034  0049              LSLS     r1,r1,#1
000036  4288              CMP      r0,r1
000038  d102              BNE      |L18.64|
;;;3789     {
;;;3790       case TIM_DMA_UPDATE:
;;;3791       {
;;;3792         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
;;;3793       }
;;;3794       break;
;;;3795       case TIM_DMA_CC1:
;;;3796       {
;;;3797         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
;;;3798       }
;;;3799       break;
;;;3800       case TIM_DMA_CC2:
;;;3801       {
;;;3802         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
;;;3803       }
;;;3804       break;
;;;3805       case TIM_DMA_CC3:
;;;3806       {
;;;3807         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
;;;3808       }
;;;3809       break;
;;;3810       case TIM_DMA_CC4:
;;;3811       {
;;;3812         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
;;;3813       }
;;;3814       break;
;;;3815       case TIM_DMA_COM:
;;;3816       {
;;;3817         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
;;;3818       }
;;;3819       break;
;;;3820       case TIM_DMA_TRIGGER:
;;;3821       {
;;;3822         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
00003a  6ba0              LDR      r0,[r4,#0x38]
00003c  f7fffffe          BL       HAL_DMA_Abort
                  |L18.64|
;;;3823       }
;;;3824       break;
;;;3825       default:
;;;3826       break;
;;;3827     }
;;;3828   
;;;3829     /* Disable the TIM Update DMA request */
;;;3830     __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
000040  6820              LDR      r0,[r4,#0]
000042  68c1              LDR      r1,[r0,#0xc]
000044  43a9              BICS     r1,r1,r5
000046  60c1              STR      r1,[r0,#0xc]
;;;3831   
;;;3832     /* Return function status */
;;;3833     return HAL_OK;
000048  2000              MOVS     r0,#0
;;;3834   }
00004a  bd70              POP      {r4-r6,pc}
                  |L18.76|
00004c  6a20              LDR      r0,[r4,#0x20]         ;3794
00004e  e008              B        |L18.98|
                  |L18.80|
000050  6a60              LDR      r0,[r4,#0x24]         ;3799
000052  e006              B        |L18.98|
                  |L18.84|
000054  6aa0              LDR      r0,[r4,#0x28]         ;3804
000056  e004              B        |L18.98|
                  |L18.88|
000058  6ae0              LDR      r0,[r4,#0x2c]         ;3809
00005a  e002              B        |L18.98|
                  |L18.92|
00005c  6b20              LDR      r0,[r4,#0x30]         ;3814
00005e  e000              B        |L18.98|
                  |L18.96|
000060  6b60              LDR      r0,[r4,#0x34]         ;3817
                  |L18.98|
000062  f7fffffe          BL       HAL_DMA_Abort
000066  e7eb              B        |L18.64|
;;;3835   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_WriteStart||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_WriteStart PROC
;;;3332     */
;;;3333   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
000000  b530              PUSH     {r4,r5,lr}
;;;3334                                                 uint32_t  *BurstBuffer, uint32_t  BurstLength)
;;;3335   {
000002  b083              SUB      sp,sp,#0xc
;;;3336   return HAL_TIM_DMABurst_MultiWriteStart(htim, BurstBaseAddress, BurstRequestSrc, BurstBuffer, BurstLength, ((BurstLength) >> 8U) + 1U);
000004  9c06              LDR      r4,[sp,#0x18]
000006  9400              STR      r4,[sp,#0]
000008  0a25              LSRS     r5,r4,#8
00000a  1c6d              ADDS     r5,r5,#1
00000c  9501              STR      r5,[sp,#4]
00000e  f7fffffe          BL       HAL_TIM_DMABurst_MultiWriteStart
;;;3337   }
000012  b003              ADD      sp,sp,#0xc
000014  bd30              POP      {r4,r5,pc}
;;;3338   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_WriteStop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_WriteStop PROC
;;;3510     */
;;;3511   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
000000  b570              PUSH     {r4-r6,lr}
;;;3512   {
000002  4604              MOV      r4,r0
;;;3513     /* Check the parameters */
;;;3514     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3515   
;;;3516     /* Abort the DMA transfer (at least disable the DMA channel) */
;;;3517     switch(BurstRequestSrc)
000004  2001              MOVS     r0,#1
000006  460d              MOV      r5,r1                 ;3512
000008  02c0              LSLS     r0,r0,#11
00000a  1a09              SUBS     r1,r1,r0
00000c  4285              CMP      r5,r0
00000e  d023              BEQ      |L20.88|
000010  dc0a              BGT      |L20.40|
000012  1fe8              SUBS     r0,r5,#7
000014  38f9              SUBS     r0,r0,#0xf9
000016  d019              BEQ      |L20.76|
000018  38ff              SUBS     r0,r0,#0xff
00001a  1e40              SUBS     r0,r0,#1
00001c  d018              BEQ      |L20.80|
00001e  38ff              SUBS     r0,r0,#0xff
000020  38ff              SUBS     r0,r0,#0xff
000022  2802              CMP      r0,#2
000024  d10c              BNE      |L20.64|
000026  e015              B        |L20.84|
                  |L20.40|
000028  1a08              SUBS     r0,r1,r0
00002a  d017              BEQ      |L20.92|
00002c  2101              MOVS     r1,#1
00002e  0309              LSLS     r1,r1,#12
000030  1a40              SUBS     r0,r0,r1
000032  d015              BEQ      |L20.96|
000034  0049              LSLS     r1,r1,#1
000036  4288              CMP      r0,r1
000038  d102              BNE      |L20.64|
;;;3518     {
;;;3519       case TIM_DMA_UPDATE:
;;;3520       {
;;;3521         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
;;;3522       }
;;;3523       break;
;;;3524       case TIM_DMA_CC1:
;;;3525       {
;;;3526         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
;;;3527       }
;;;3528       break;
;;;3529       case TIM_DMA_CC2:
;;;3530       {
;;;3531         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
;;;3532       }
;;;3533       break;
;;;3534       case TIM_DMA_CC3:
;;;3535       {
;;;3536         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
;;;3537       }
;;;3538       break;
;;;3539       case TIM_DMA_CC4:
;;;3540       {
;;;3541         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
;;;3542       }
;;;3543       break;
;;;3544       case TIM_DMA_COM:
;;;3545       {
;;;3546         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
;;;3547       }
;;;3548       break;
;;;3549       case TIM_DMA_TRIGGER:
;;;3550       {
;;;3551         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
00003a  6ba0              LDR      r0,[r4,#0x38]
00003c  f7fffffe          BL       HAL_DMA_Abort
                  |L20.64|
;;;3552       }
;;;3553       break;
;;;3554       default:
;;;3555       break;
;;;3556     }
;;;3557   
;;;3558     /* Disable the TIM Update DMA request */
;;;3559     __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
000040  6820              LDR      r0,[r4,#0]
000042  68c1              LDR      r1,[r0,#0xc]
000044  43a9              BICS     r1,r1,r5
000046  60c1              STR      r1,[r0,#0xc]
;;;3560   
;;;3561     /* Return function status */
;;;3562     return HAL_OK;
000048  2000              MOVS     r0,#0
;;;3563   }
00004a  bd70              POP      {r4-r6,pc}
                  |L20.76|
00004c  6a20              LDR      r0,[r4,#0x20]         ;3523
00004e  e008              B        |L20.98|
                  |L20.80|
000050  6a60              LDR      r0,[r4,#0x24]         ;3528
000052  e006              B        |L20.98|
                  |L20.84|
000054  6aa0              LDR      r0,[r4,#0x28]         ;3533
000056  e004              B        |L20.98|
                  |L20.88|
000058  6ae0              LDR      r0,[r4,#0x2c]         ;3538
00005a  e002              B        |L20.98|
                  |L20.92|
00005c  6b20              LDR      r0,[r4,#0x30]         ;3543
00005e  e000              B        |L20.98|
                  |L20.96|
000060  6b60              LDR      r0,[r4,#0x34]         ;3546
                  |L20.98|
000062  f7fffffe          BL       HAL_DMA_Abort
000066  e7eb              B        |L20.64|
;;;3564   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_DeInit PROC
;;;2339     */
;;;2340   HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;2341   {
000002  4604              MOV      r4,r0
;;;2342     /* Check the parameters */
;;;2343     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2344   
;;;2345     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  6420              STR      r0,[r4,#0x40]
;;;2346   
;;;2347     /* Disable the TIM Peripheral Clock */
;;;2348     __HAL_TIM_DISABLE(htim);
000008  6820              LDR      r0,[r4,#0]
00000a  6a01              LDR      r1,[r0,#0x20]
00000c  4a08              LDR      r2,|L21.48|
00000e  4211              TST      r1,r2
000010  d107              BNE      |L21.34|
000012  6a01              LDR      r1,[r0,#0x20]
000014  1092              ASRS     r2,r2,#2
000016  4211              TST      r1,r2
000018  d103              BNE      |L21.34|
00001a  6801              LDR      r1,[r0,#0]
00001c  0849              LSRS     r1,r1,#1
00001e  0049              LSLS     r1,r1,#1
000020  6001              STR      r1,[r0,#0]
                  |L21.34|
;;;2349   
;;;2350     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;2351     HAL_TIM_Encoder_MspDeInit(htim);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       HAL_TIM_Encoder_MspDeInit
;;;2352   
;;;2353     /* Change TIM state */
;;;2354     htim->State = HAL_TIM_STATE_RESET;
000028  2000              MOVS     r0,#0
00002a  6420              STR      r0,[r4,#0x40]
;;;2355   
;;;2356     /* Release Lock */
;;;2357     __HAL_UNLOCK(htim);
00002c  63e0              STR      r0,[r4,#0x3c]
;;;2358   
;;;2359     return HAL_OK;
;;;2360   }
00002e  bd10              POP      {r4,pc}
;;;2361   
                          ENDP

                  |L21.48|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_Encoder_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_GetState PROC
;;;4542     */
;;;4543   HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
000000  6c00              LDR      r0,[r0,#0x40]
;;;4544   {
;;;4545     return htim->State;
;;;4546   }
000002  4770              BX       lr
;;;4547   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Init||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Init PROC
;;;2246     */
;;;2247   HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef* sConfig)
000000  2800              CMP      r0,#0
;;;2248   {
;;;2249     uint32_t tmpsmcr = 0U;
;;;2250     uint32_t tmpccmr1 = 0U;
;;;2251     uint32_t tmpccer = 0U;
;;;2252   
;;;2253     /* Check the TIM handle allocation */
;;;2254     if(htim == NULL)
000002  d101              BNE      |L23.8|
;;;2255     {
;;;2256       return HAL_ERROR;
000004  2001              MOVS     r0,#1
;;;2257     }
;;;2258   
;;;2259     /* Check the parameters */
;;;2260     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2261     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;2262     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;2263     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;2264     assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
;;;2265     assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
;;;2266     assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
;;;2267     assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
;;;2268     assert_param(IS_TIM_IC_POLARITY(sConfig->IC2Polarity));
;;;2269     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
;;;2270     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
;;;2271     assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
;;;2272     assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
;;;2273   
;;;2274     if(htim->State == HAL_TIM_STATE_RESET)
;;;2275     {
;;;2276       /* Allocate lock resource and initialize it */
;;;2277       htim->Lock = HAL_UNLOCKED;
;;;2278   
;;;2279       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;2280       HAL_TIM_Encoder_MspInit(htim);
;;;2281     }
;;;2282   
;;;2283     /* Set the TIM state */
;;;2284     htim->State= HAL_TIM_STATE_BUSY;
;;;2285   
;;;2286     /* Reset the SMS bits */
;;;2287     htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;2288   
;;;2289     /* Configure the Time base in the Encoder Mode */
;;;2290     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;2291   
;;;2292     /* Get the TIMx SMCR register value */
;;;2293     tmpsmcr = htim->Instance->SMCR;
;;;2294   
;;;2295     /* Get the TIMx CCMR1 register value */
;;;2296     tmpccmr1 = htim->Instance->CCMR1;
;;;2297   
;;;2298     /* Get the TIMx CCER register value */
;;;2299     tmpccer = htim->Instance->CCER;
;;;2300   
;;;2301     /* Set the encoder Mode */
;;;2302     tmpsmcr |= sConfig->EncoderMode;
;;;2303   
;;;2304     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;2305     tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
;;;2306     tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
;;;2307   
;;;2308     /* Set the the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
;;;2309     tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
;;;2310     tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
;;;2311     tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8U);
;;;2312     tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
;;;2313   
;;;2314     /* Set the TI1 and the TI2 Polarities */
;;;2315     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
;;;2316     tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
;;;2317     tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
;;;2318   
;;;2319     /* Write to TIMx SMCR */
;;;2320     htim->Instance->SMCR = tmpsmcr;
;;;2321   
;;;2322     /* Write to TIMx CCMR1 */
;;;2323     htim->Instance->CCMR1 = tmpccmr1;
;;;2324   
;;;2325     /* Write to TIMx CCER */
;;;2326     htim->Instance->CCER = tmpccer;
;;;2327   
;;;2328     /* Initialize the TIM state*/
;;;2329     htim->State= HAL_TIM_STATE_READY;
;;;2330   
;;;2331     return HAL_OK;
;;;2332   }
000006  4770              BX       lr
                  |L23.8|
000008  b5f8              PUSH     {r3-r7,lr}            ;2248
00000a  4604              MOV      r4,r0                 ;2248
00000c  6c00              LDR      r0,[r0,#0x40]         ;2274
00000e  460d              MOV      r5,r1                 ;2248
000010  2800              CMP      r0,#0                 ;2274
000012  d103              BNE      |L23.28|
000014  63e0              STR      r0,[r4,#0x3c]         ;2280
000016  4620              MOV      r0,r4                 ;2280
000018  f7fffffe          BL       HAL_TIM_Encoder_MspInit
                  |L23.28|
00001c  2002              MOVS     r0,#2                 ;2284
00001e  6420              STR      r0,[r4,#0x40]         ;2284
000020  6820              LDR      r0,[r4,#0]            ;2287
000022  6881              LDR      r1,[r0,#8]            ;2287
000024  08c9              LSRS     r1,r1,#3              ;2287
000026  00c9              LSLS     r1,r1,#3              ;2287
000028  6081              STR      r1,[r0,#8]            ;2287
00002a  1d21              ADDS     r1,r4,#4              ;2290
00002c  6820              LDR      r0,[r4,#0]            ;2290
00002e  f7fffffe          BL       TIM_Base_SetConfig
000032  6822              LDR      r2,[r4,#0]            ;2293
000034  6896              LDR      r6,[r2,#8]            ;2293
000036  6991              LDR      r1,[r2,#0x18]         ;2296
000038  6a10              LDR      r0,[r2,#0x20]         ;2299
00003a  682b              LDR      r3,[r5,#0]            ;2302
00003c  69af              LDR      r7,[r5,#0x18]         ;2306
00003e  4333              ORRS     r3,r3,r6              ;2302
000040  4e11              LDR      r6,|L23.136|
000042  023f              LSLS     r7,r7,#8              ;2306
000044  4031              ANDS     r1,r1,r6              ;2305
000046  430f              ORRS     r7,r7,r1              ;2306
000048  68ae              LDR      r6,[r5,#8]            ;2306
00004a  4910              LDR      r1,|L23.140|
00004c  433e              ORRS     r6,r6,r7              ;2306
00004e  400e              ANDS     r6,r6,r1              ;2309
000050  69e9              LDR      r1,[r5,#0x1c]         ;2311
000052  68ef              LDR      r7,[r5,#0xc]          ;2311
000054  0209              LSLS     r1,r1,#8              ;2311
000056  4331              ORRS     r1,r1,r6              ;2311
000058  430f              ORRS     r7,r7,r1              ;2311
00005a  6929              LDR      r1,[r5,#0x10]         ;2312
00005c  6a2e              LDR      r6,[r5,#0x20]         ;2312
00005e  0109              LSLS     r1,r1,#4              ;2312
000060  0336              LSLS     r6,r6,#12             ;2312
000062  4331              ORRS     r1,r1,r6              ;2312
000064  26aa              MOVS     r6,#0xaa              ;2315
000066  43b0              BICS     r0,r0,r6              ;2315
000068  686e              LDR      r6,[r5,#4]            ;2317
00006a  696d              LDR      r5,[r5,#0x14]         ;2317
00006c  4339              ORRS     r1,r1,r7              ;2312
00006e  012d              LSLS     r5,r5,#4              ;2317
000070  4305              ORRS     r5,r5,r0              ;2317
000072  432e              ORRS     r6,r6,r5              ;2317
000074  6093              STR      r3,[r2,#8]            ;2320
000076  6820              LDR      r0,[r4,#0]            ;2323
000078  6181              STR      r1,[r0,#0x18]         ;2323
00007a  6820              LDR      r0,[r4,#0]            ;2326
00007c  6206              STR      r6,[r0,#0x20]         ;2326
00007e  2001              MOVS     r0,#1                 ;2329
000080  6420              STR      r0,[r4,#0x40]         ;2329
000082  2000              MOVS     r0,#0                 ;2331
000084  bdf8              POP      {r3-r7,pc}
;;;2333   
                          ENDP

000086  0000              DCW      0x0000
                  |L23.136|
                          DCD      0xfffffcfc
                  |L23.140|
                          DCD      0xffff0303

                          AREA ||i.HAL_TIM_Encoder_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_MspDeInit PROC
;;;2381     */
;;;2382   __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2383   {
;;;2384     /* Prevent unused argument(s) compilation warning */
;;;2385     UNUSED(htim);
;;;2386   
;;;2387     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2388               the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
;;;2389      */
;;;2390   }
;;;2391   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_MspInit PROC
;;;2366     */
;;;2367   __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2368   {
;;;2369     /* Prevent unused argument(s) compilation warning */
;;;2370     UNUSED(htim);
;;;2371   
;;;2372     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2373               the HAL_TIM_Encoder_MspInit could be implemented in the user file
;;;2374      */
;;;2375   }
;;;2376   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Start PROC
;;;2401   */
;;;2402   HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b430              PUSH     {r4,r5}
;;;2403   {
;;;2404     /* Check the parameters */
;;;2405     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2406   
;;;2407     /* Enable the encoder interface channels */
;;;2408     switch (Channel)
;;;2409     {
;;;2410       case TIM_CHANNEL_1:
;;;2411     {
;;;2412       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000002  2301              MOVS     r3,#1
000004  6802              LDR      r2,[r0,#0]            ;2408
000006  2900              CMP      r1,#0                 ;2408
000008  d017              BEQ      |L26.58|
00000a  2410              MOVS     r4,#0x10              ;2403
00000c  2904              CMP      r1,#4                 ;2408
00000e  d01b              BEQ      |L26.72|
000010  6a11              LDR      r1,[r2,#0x20]         ;2408
000012  4399              BICS     r1,r1,r3              ;2408
000014  6211              STR      r1,[r2,#0x20]         ;2408
000016  6a11              LDR      r1,[r2,#0x20]         ;2408
000018  4319              ORRS     r1,r1,r3              ;2408
00001a  6211              STR      r1,[r2,#0x20]         ;2408
00001c  6801              LDR      r1,[r0,#0]            ;2408
00001e  2210              MOVS     r2,#0x10              ;2408
000020  6a0d              LDR      r5,[r1,#0x20]         ;2408
000022  4395              BICS     r5,r5,r2              ;2408
000024  620d              STR      r5,[r1,#0x20]         ;2408
000026  6a0a              LDR      r2,[r1,#0x20]         ;2408
000028  4322              ORRS     r2,r2,r4              ;2408
00002a  620a              STR      r2,[r1,#0x20]         ;2408
                  |L26.44|
;;;2413         break;
;;;2414     }
;;;2415       case TIM_CHANNEL_2:
;;;2416     {
;;;2417       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2418         break;
;;;2419     }
;;;2420       default :
;;;2421     {
;;;2422        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2423        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2424        break;
;;;2425       }
;;;2426     }
;;;2427     /* Enable the Peripheral */
;;;2428     __HAL_TIM_ENABLE(htim);
00002c  6800              LDR      r0,[r0,#0]
00002e  6801              LDR      r1,[r0,#0]
000030  4319              ORRS     r1,r1,r3
000032  6001              STR      r1,[r0,#0]
;;;2429   
;;;2430     /* Return function status */
;;;2431     return HAL_OK;
;;;2432   }
000034  bc30              POP      {r4,r5}
000036  2000              MOVS     r0,#0                 ;2431
000038  4770              BX       lr
                  |L26.58|
00003a  6a11              LDR      r1,[r2,#0x20]
00003c  0849              LSRS     r1,r1,#1
00003e  0049              LSLS     r1,r1,#1
000040  6211              STR      r1,[r2,#0x20]
000042  6a11              LDR      r1,[r2,#0x20]
000044  4319              ORRS     r1,r1,r3
000046  e005              B        |L26.84|
                  |L26.72|
000048  6a15              LDR      r5,[r2,#0x20]         ;2413
00004a  2110              MOVS     r1,#0x10              ;2413
00004c  438d              BICS     r5,r5,r1              ;2413
00004e  6215              STR      r5,[r2,#0x20]         ;2413
000050  6a11              LDR      r1,[r2,#0x20]         ;2413
000052  4321              ORRS     r1,r1,r4              ;2413
                  |L26.84|
000054  6211              STR      r1,[r2,#0x20]         ;2413
000056  e7e9              B        |L26.44|
;;;2433   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Start_DMA PROC
;;;2589   */
;;;2590   HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1, uint32_t *pData2, uint16_t Length)
000000  b5ff              PUSH     {r0-r7,lr}
;;;2591   {
000002  4604              MOV      r4,r0
;;;2592     /* Check the parameters */
;;;2593     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2594   
;;;2595     if((htim->State == HAL_TIM_STATE_BUSY))
000004  6c00              LDR      r0,[r0,#0x40]
000006  b081              SUB      sp,sp,#4              ;2591
000008  2802              CMP      r0,#2
00000a  d00b              BEQ      |L27.36|
;;;2596     {
;;;2597        return HAL_BUSY;
;;;2598     }
;;;2599     else if((htim->State == HAL_TIM_STATE_READY))
00000c  6c20              LDR      r0,[r4,#0x40]
00000e  2801              CMP      r0,#1
000010  d10c              BNE      |L27.44|
;;;2600     {
;;;2601       if((((pData1 == 0U) || (pData2 == 0U) )) && (Length > 0U))
000012  2a00              CMP      r2,#0
000014  d002              BEQ      |L27.28|
000016  9804              LDR      r0,[sp,#0x10]
000018  2800              CMP      r0,#0
00001a  d105              BNE      |L27.40|
                  |L27.28|
00001c  980a              LDR      r0,[sp,#0x28]
00001e  2800              CMP      r0,#0
000020  d002              BEQ      |L27.40|
;;;2602       {
;;;2603         return HAL_ERROR;
000022  2001              MOVS     r0,#1
                  |L27.36|
;;;2604       }
;;;2605       else
;;;2606       {
;;;2607         htim->State = HAL_TIM_STATE_BUSY;
;;;2608       }
;;;2609     }
;;;2610   
;;;2611     switch (Channel)
;;;2612     {
;;;2613       case TIM_CHANNEL_1:
;;;2614       {
;;;2615         /* Set the DMA Period elapsed callback */
;;;2616         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2617   
;;;2618         /* Set the DMA error callback */
;;;2619         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;2620   
;;;2621         /* Enable the DMA channel */
;;;2622         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t )pData1, Length);
;;;2623   
;;;2624         /* Enable the TIM Input Capture DMA request */
;;;2625         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;2626   
;;;2627         /* Enable the Peripheral */
;;;2628         __HAL_TIM_ENABLE(htim);
;;;2629   
;;;2630         /* Enable the Capture compare channel */
;;;2631         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2632       }
;;;2633       break;
;;;2634   
;;;2635       case TIM_CHANNEL_2:
;;;2636       {
;;;2637         /* Set the DMA Period elapsed callback */
;;;2638         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2639   
;;;2640         /* Set the DMA error callback */
;;;2641         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError;
;;;2642         /* Enable the DMA channel */
;;;2643         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
;;;2644   
;;;2645         /* Enable the TIM Input Capture  DMA request */
;;;2646         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;2647   
;;;2648         /* Enable the Peripheral */
;;;2649         __HAL_TIM_ENABLE(htim);
;;;2650   
;;;2651         /* Enable the Capture compare channel */
;;;2652         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2653       }
;;;2654       break;
;;;2655   
;;;2656       case TIM_CHANNEL_ALL:
;;;2657       {
;;;2658         /* Set the DMA Period elapsed callback */
;;;2659         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2660   
;;;2661         /* Set the DMA error callback */
;;;2662         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;2663   
;;;2664         /* Enable the DMA channel */
;;;2665         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length);
;;;2666   
;;;2667         /* Set the DMA Period elapsed callback */
;;;2668         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2669   
;;;2670         /* Set the DMA error callback */
;;;2671         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;2672   
;;;2673         /* Enable the DMA channel */
;;;2674         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
;;;2675   
;;;2676        /* Enable the Peripheral */
;;;2677         __HAL_TIM_ENABLE(htim);
;;;2678   
;;;2679         /* Enable the Capture compare channel */
;;;2680         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2681         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2682   
;;;2683         /* Enable the TIM Input Capture  DMA request */
;;;2684         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;2685         /* Enable the TIM Input Capture  DMA request */
;;;2686         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;2687       }
;;;2688       break;
;;;2689   
;;;2690       default:
;;;2691       break;
;;;2692     }
;;;2693     /* Return function status */
;;;2694     return HAL_OK;
;;;2695   }
000024  b005              ADD      sp,sp,#0x14
000026  bdf0              POP      {r4-r7,pc}
                  |L27.40|
000028  2002              MOVS     r0,#2                 ;2607
00002a  6420              STR      r0,[r4,#0x40]         ;2607
                  |L27.44|
00002c  2501              MOVS     r5,#1                 ;2603
00002e  4e3d              LDR      r6,|L27.292|
000030  4f3d              LDR      r7,|L27.296|
000032  2900              CMP      r1,#0                 ;2611
000034  d004              BEQ      |L27.64|
000036  2904              CMP      r1,#4                 ;2611
000038  d01e              BEQ      |L27.120|
00003a  2918              CMP      r1,#0x18              ;2611
00003c  d16f              BNE      |L27.286|
00003e  e03a              B        |L27.182|
                  |L27.64|
000040  6a60              LDR      r0,[r4,#0x24]         ;2616
000042  62c6              STR      r6,[r0,#0x2c]         ;2619
000044  6a60              LDR      r0,[r4,#0x24]         ;2619
000046  6347              STR      r7,[r0,#0x34]         ;2622
000048  6821              LDR      r1,[r4,#0]            ;2622
00004a  6a60              LDR      r0,[r4,#0x24]         ;2622
00004c  3134              ADDS     r1,r1,#0x34           ;2622
00004e  9b0a              LDR      r3,[sp,#0x28]         ;2622
000050  f7fffffe          BL       HAL_DMA_Start_IT
000054  6820              LDR      r0,[r4,#0]            ;2625
000056  68c1              LDR      r1,[r0,#0xc]          ;2625
000058  2201              MOVS     r2,#1                 ;2625
00005a  0252              LSLS     r2,r2,#9              ;2625
00005c  4311              ORRS     r1,r1,r2              ;2625
00005e  60c1              STR      r1,[r0,#0xc]          ;2625
000060  6820              LDR      r0,[r4,#0]            ;2628
000062  6801              LDR      r1,[r0,#0]            ;2628
000064  4329              ORRS     r1,r1,r5              ;2628
000066  6001              STR      r1,[r0,#0]            ;2628
000068  6820              LDR      r0,[r4,#0]            ;2628
00006a  6a01              LDR      r1,[r0,#0x20]         ;2628
00006c  0849              LSRS     r1,r1,#1              ;2628
00006e  0049              LSLS     r1,r1,#1              ;2628
000070  6201              STR      r1,[r0,#0x20]         ;2628
000072  6a01              LDR      r1,[r0,#0x20]         ;2628
000074  4329              ORRS     r1,r1,r5              ;2628
000076  e01c              B        |L27.178|
                  |L27.120|
000078  6aa0              LDR      r0,[r4,#0x28]         ;2638
00007a  62c6              STR      r6,[r0,#0x2c]         ;2641
00007c  6aa0              LDR      r0,[r4,#0x28]         ;2641
00007e  6347              STR      r7,[r0,#0x34]         ;2643
000080  6821              LDR      r1,[r4,#0]            ;2643
000082  6aa0              LDR      r0,[r4,#0x28]         ;2643
000084  3138              ADDS     r1,r1,#0x38           ;2643
000086  9b0a              LDR      r3,[sp,#0x28]         ;2643
000088  9a04              LDR      r2,[sp,#0x10]         ;2643
00008a  f7fffffe          BL       HAL_DMA_Start_IT
00008e  6820              LDR      r0,[r4,#0]            ;2646
000090  68c2              LDR      r2,[r0,#0xc]          ;2646
000092  2101              MOVS     r1,#1                 ;2646
000094  0289              LSLS     r1,r1,#10             ;2646
000096  430a              ORRS     r2,r2,r1              ;2646
000098  60c2              STR      r2,[r0,#0xc]          ;2646
00009a  6820              LDR      r0,[r4,#0]            ;2649
00009c  6801              LDR      r1,[r0,#0]            ;2649
00009e  4329              ORRS     r1,r1,r5              ;2649
0000a0  6001              STR      r1,[r0,#0]            ;2649
0000a2  6820              LDR      r0,[r4,#0]            ;2649
0000a4  2110              MOVS     r1,#0x10              ;2649
0000a6  6a02              LDR      r2,[r0,#0x20]         ;2649
0000a8  438a              BICS     r2,r2,r1              ;2649
0000aa  6202              STR      r2,[r0,#0x20]         ;2649
0000ac  6a01              LDR      r1,[r0,#0x20]         ;2649
0000ae  2210              MOVS     r2,#0x10              ;2649
0000b0  4311              ORRS     r1,r1,r2              ;2649
                  |L27.178|
0000b2  6201              STR      r1,[r0,#0x20]         ;2649
0000b4  e033              B        |L27.286|
                  |L27.182|
0000b6  6a60              LDR      r0,[r4,#0x24]         ;2659
0000b8  62c6              STR      r6,[r0,#0x2c]         ;2662
0000ba  6a60              LDR      r0,[r4,#0x24]         ;2662
0000bc  6347              STR      r7,[r0,#0x34]         ;2665
0000be  6821              LDR      r1,[r4,#0]            ;2665
0000c0  6a60              LDR      r0,[r4,#0x24]         ;2665
0000c2  3134              ADDS     r1,r1,#0x34           ;2665
0000c4  9b0a              LDR      r3,[sp,#0x28]         ;2665
0000c6  f7fffffe          BL       HAL_DMA_Start_IT
0000ca  6aa0              LDR      r0,[r4,#0x28]         ;2668
0000cc  62c6              STR      r6,[r0,#0x2c]         ;2671
0000ce  6aa0              LDR      r0,[r4,#0x28]         ;2671
0000d0  6347              STR      r7,[r0,#0x34]         ;2674
0000d2  6821              LDR      r1,[r4,#0]            ;2674
0000d4  6aa0              LDR      r0,[r4,#0x28]         ;2674
0000d6  3138              ADDS     r1,r1,#0x38           ;2674
0000d8  9b0a              LDR      r3,[sp,#0x28]         ;2674
0000da  9a04              LDR      r2,[sp,#0x10]         ;2674
0000dc  f7fffffe          BL       HAL_DMA_Start_IT
0000e0  6820              LDR      r0,[r4,#0]            ;2677
0000e2  6801              LDR      r1,[r0,#0]            ;2677
0000e4  4329              ORRS     r1,r1,r5              ;2677
0000e6  6001              STR      r1,[r0,#0]            ;2677
0000e8  6820              LDR      r0,[r4,#0]            ;2677
0000ea  6a01              LDR      r1,[r0,#0x20]         ;2677
0000ec  0849              LSRS     r1,r1,#1              ;2677
0000ee  0049              LSLS     r1,r1,#1              ;2677
0000f0  6201              STR      r1,[r0,#0x20]         ;2677
0000f2  6a01              LDR      r1,[r0,#0x20]         ;2677
0000f4  4329              ORRS     r1,r1,r5              ;2677
0000f6  6201              STR      r1,[r0,#0x20]         ;2677
0000f8  6820              LDR      r0,[r4,#0]            ;2677
0000fa  2110              MOVS     r1,#0x10              ;2677
0000fc  6a02              LDR      r2,[r0,#0x20]         ;2677
0000fe  438a              BICS     r2,r2,r1              ;2677
000100  6202              STR      r2,[r0,#0x20]         ;2677
000102  6a01              LDR      r1,[r0,#0x20]         ;2677
000104  2210              MOVS     r2,#0x10              ;2677
000106  4311              ORRS     r1,r1,r2              ;2677
000108  6201              STR      r1,[r0,#0x20]         ;2677
00010a  6820              LDR      r0,[r4,#0]            ;2684
00010c  68c1              LDR      r1,[r0,#0xc]          ;2684
00010e  0152              LSLS     r2,r2,#5              ;2684
000110  4311              ORRS     r1,r1,r2              ;2684
000112  60c1              STR      r1,[r0,#0xc]          ;2684
000114  6820              LDR      r0,[r4,#0]            ;2686
000116  68c1              LDR      r1,[r0,#0xc]          ;2686
000118  0052              LSLS     r2,r2,#1              ;2686
00011a  4311              ORRS     r1,r1,r2              ;2686
00011c  60c1              STR      r1,[r0,#0xc]          ;2686
                  |L27.286|
00011e  2000              MOVS     r0,#0                 ;2694
000120  b005              ADD      sp,sp,#0x14
000122  bdf0              POP      {r4-r7,pc}
;;;2696   
                          ENDP

                  |L27.292|
                          DCD      TIM_DMACaptureCplt
                  |L27.296|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_Encoder_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Start_IT PROC
;;;2487   */
;;;2488   HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b4f0              PUSH     {r4-r7}
;;;2489   {
;;;2490     /* Check the parameters */
;;;2491     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2492   
;;;2493     /* Enable the encoder interface channels */
;;;2494     /* Enable the capture compare Interrupts 1 and/or 2 */
;;;2495     switch (Channel)
;;;2496     {
;;;2497       case TIM_CHANNEL_1:
;;;2498     {
;;;2499       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2500       __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000002  2402              MOVS     r4,#2
000004  2301              MOVS     r3,#1                 ;2499
000006  6802              LDR      r2,[r0,#0]            ;2495
000008  2900              CMP      r1,#0                 ;2495
00000a  d020              BEQ      |L28.78|
00000c  2504              MOVS     r5,#4                 ;2489
00000e  2610              MOVS     r6,#0x10              ;2489
000010  2904              CMP      r1,#4                 ;2495
000012  d027              BEQ      |L28.100|
000014  6a11              LDR      r1,[r2,#0x20]         ;2495
000016  4399              BICS     r1,r1,r3              ;2495
000018  6211              STR      r1,[r2,#0x20]         ;2495
00001a  6a11              LDR      r1,[r2,#0x20]         ;2495
00001c  4319              ORRS     r1,r1,r3              ;2495
00001e  6211              STR      r1,[r2,#0x20]         ;2495
000020  6801              LDR      r1,[r0,#0]            ;2495
000022  2210              MOVS     r2,#0x10              ;2495
000024  6a0f              LDR      r7,[r1,#0x20]         ;2495
000026  4397              BICS     r7,r7,r2              ;2495
000028  620f              STR      r7,[r1,#0x20]         ;2495
00002a  6a0a              LDR      r2,[r1,#0x20]         ;2495
00002c  4332              ORRS     r2,r2,r6              ;2495
00002e  620a              STR      r2,[r1,#0x20]         ;2495
;;;2501         break;
;;;2502     }
;;;2503       case TIM_CHANNEL_2:
;;;2504     {
;;;2505       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2506       __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
;;;2507         break;
;;;2508     }
;;;2509       default :
;;;2510     {
;;;2511        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2512        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2513        __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000030  6801              LDR      r1,[r0,#0]
000032  68ca              LDR      r2,[r1,#0xc]
000034  4322              ORRS     r2,r2,r4
000036  60ca              STR      r2,[r1,#0xc]
;;;2514        __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000038  6801              LDR      r1,[r0,#0]
00003a  68ca              LDR      r2,[r1,#0xc]
00003c  432a              ORRS     r2,r2,r5
00003e  60ca              STR      r2,[r1,#0xc]
                  |L28.64|
;;;2515        break;
;;;2516       }
;;;2517     }
;;;2518   
;;;2519     /* Enable the Peripheral */
;;;2520     __HAL_TIM_ENABLE(htim);
000040  6800              LDR      r0,[r0,#0]
000042  6801              LDR      r1,[r0,#0]
000044  4319              ORRS     r1,r1,r3
000046  6001              STR      r1,[r0,#0]
;;;2521   
;;;2522     /* Return function status */
;;;2523     return HAL_OK;
;;;2524   }
000048  bcf0              POP      {r4-r7}
00004a  2000              MOVS     r0,#0                 ;2523
00004c  4770              BX       lr
                  |L28.78|
00004e  6a11              LDR      r1,[r2,#0x20]
000050  0849              LSRS     r1,r1,#1
000052  0049              LSLS     r1,r1,#1
000054  6211              STR      r1,[r2,#0x20]
000056  6a11              LDR      r1,[r2,#0x20]
000058  4319              ORRS     r1,r1,r3
00005a  6211              STR      r1,[r2,#0x20]
00005c  6801              LDR      r1,[r0,#0]            ;2500
00005e  68ca              LDR      r2,[r1,#0xc]          ;2500
000060  4322              ORRS     r2,r2,r4              ;2500
000062  e009              B        |L28.120|
                  |L28.100|
000064  6a14              LDR      r4,[r2,#0x20]         ;2501
000066  2110              MOVS     r1,#0x10              ;2501
000068  438c              BICS     r4,r4,r1              ;2501
00006a  6214              STR      r4,[r2,#0x20]         ;2501
00006c  6a11              LDR      r1,[r2,#0x20]         ;2501
00006e  4331              ORRS     r1,r1,r6              ;2501
000070  6211              STR      r1,[r2,#0x20]         ;2501
000072  6801              LDR      r1,[r0,#0]            ;2506
000074  68ca              LDR      r2,[r1,#0xc]          ;2506
000076  432a              ORRS     r2,r2,r5              ;2506
                  |L28.120|
000078  60ca              STR      r2,[r1,#0xc]          ;2500
00007a  e7e1              B        |L28.64|
;;;2525   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Stop PROC
;;;2443   */
;;;2444   HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
;;;2445   {
;;;2446     /* Check the parameters */
;;;2447       assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2448   
;;;2449      /* Disable the Input Capture channels 1 and 2
;;;2450       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
;;;2451     switch (Channel)
000002  2900              CMP      r1,#0
000004  d01d              BEQ      |L29.66|
000006  2904              CMP      r1,#4
000008  d022              BEQ      |L29.80|
00000a  6a11              LDR      r1,[r2,#0x20]
00000c  0849              LSRS     r1,r1,#1
00000e  0049              LSLS     r1,r1,#1
000010  6211              STR      r1,[r2,#0x20]
000012  6a11              LDR      r1,[r2,#0x20]
000014  6211              STR      r1,[r2,#0x20]
000016  6801              LDR      r1,[r0,#0]
000018  2210              MOVS     r2,#0x10
00001a  6a0b              LDR      r3,[r1,#0x20]
00001c  4393              BICS     r3,r3,r2
00001e  620b              STR      r3,[r1,#0x20]
000020  6a0a              LDR      r2,[r1,#0x20]
000022  620a              STR      r2,[r1,#0x20]
                  |L29.36|
;;;2452     {
;;;2453       case TIM_CHANNEL_1:
;;;2454     {
;;;2455        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
;;;2456         break;
;;;2457     }
;;;2458       case TIM_CHANNEL_2:
;;;2459     {
;;;2460       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
;;;2461         break;
;;;2462     }
;;;2463       default :
;;;2464     {
;;;2465       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
;;;2466       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
;;;2467        break;
;;;2468       }
;;;2469     }
;;;2470   
;;;2471     /* Disable the Peripheral */
;;;2472     __HAL_TIM_DISABLE(htim);
000024  6800              LDR      r0,[r0,#0]
000026  6a01              LDR      r1,[r0,#0x20]
000028  4a0d              LDR      r2,|L29.96|
00002a  4211              TST      r1,r2
00002c  d107              BNE      |L29.62|
00002e  6a01              LDR      r1,[r0,#0x20]
000030  1092              ASRS     r2,r2,#2
000032  4211              TST      r1,r2
000034  d103              BNE      |L29.62|
000036  6801              LDR      r1,[r0,#0]
000038  0849              LSRS     r1,r1,#1
00003a  0049              LSLS     r1,r1,#1
00003c  6001              STR      r1,[r0,#0]
                  |L29.62|
;;;2473   
;;;2474     /* Return function status */
;;;2475     return HAL_OK;
00003e  2000              MOVS     r0,#0
;;;2476   }
000040  4770              BX       lr
                  |L29.66|
000042  6a11              LDR      r1,[r2,#0x20]
000044  0849              LSRS     r1,r1,#1
000046  0049              LSLS     r1,r1,#1
000048  6211              STR      r1,[r2,#0x20]
00004a  6a11              LDR      r1,[r2,#0x20]
00004c  6211              STR      r1,[r2,#0x20]
00004e  e7e9              B        |L29.36|
                  |L29.80|
000050  6a13              LDR      r3,[r2,#0x20]         ;2456
000052  2110              MOVS     r1,#0x10              ;2456
000054  438b              BICS     r3,r3,r1              ;2456
000056  6213              STR      r3,[r2,#0x20]         ;2456
000058  6a11              LDR      r1,[r2,#0x20]         ;2456
00005a  6211              STR      r1,[r2,#0x20]         ;2456
00005c  e7e2              B        |L29.36|
;;;2477   
                          ENDP

00005e  0000              DCW      0x0000
                  |L29.96|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_Encoder_Stop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Stop_DMA PROC
;;;2706   */
;;;2707   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b470              PUSH     {r4-r6}
;;;2708   {
;;;2709     /* Check the parameters */
;;;2710     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2711   
;;;2712     /* Disable the Input Capture channels 1 and 2
;;;2713       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
;;;2714     if(Channel == TIM_CHANNEL_1)
;;;2715     {
;;;2716       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
;;;2717   
;;;2718       /* Disable the capture compare DMA Request 1 */
;;;2719       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000002  2301              MOVS     r3,#1
000004  025b              LSLS     r3,r3,#9
000006  2401              MOVS     r4,#1
000008  6802              LDR      r2,[r0,#0]            ;2714
00000a  2900              CMP      r1,#0                 ;2714
00000c  d027              BEQ      |L30.94|
;;;2720     }
;;;2721     else if(Channel == TIM_CHANNEL_2)
;;;2722     {
;;;2723       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
;;;2724   
;;;2725       /* Disable the capture compare DMA Request 2 */
;;;2726       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00000e  005d              LSLS     r5,r3,#1
000010  2904              CMP      r1,#4                 ;2721
000012  d02e              BEQ      |L30.114|
000014  6a11              LDR      r1,[r2,#0x20]         ;2721
000016  43a1              BICS     r1,r1,r4              ;2721
000018  6211              STR      r1,[r2,#0x20]         ;2721
00001a  6a11              LDR      r1,[r2,#0x20]         ;2721
00001c  6211              STR      r1,[r2,#0x20]         ;2721
00001e  6801              LDR      r1,[r0,#0]            ;2721
000020  2210              MOVS     r2,#0x10              ;2721
000022  6a0e              LDR      r6,[r1,#0x20]         ;2721
000024  4396              BICS     r6,r6,r2              ;2721
000026  620e              STR      r6,[r1,#0x20]         ;2721
000028  6a0a              LDR      r2,[r1,#0x20]         ;2721
00002a  620a              STR      r2,[r1,#0x20]         ;2721
;;;2727     }
;;;2728     else
;;;2729     {
;;;2730       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
;;;2731       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
;;;2732   
;;;2733       /* Disable the capture compare DMA Request 1 and 2 */
;;;2734       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
00002c  6801              LDR      r1,[r0,#0]
00002e  68ca              LDR      r2,[r1,#0xc]
000030  439a              BICS     r2,r2,r3
000032  60ca              STR      r2,[r1,#0xc]
;;;2735       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000034  6801              LDR      r1,[r0,#0]
000036  68ca              LDR      r2,[r1,#0xc]
000038  43aa              BICS     r2,r2,r5
00003a  60ca              STR      r2,[r1,#0xc]
                  |L30.60|
;;;2736     }
;;;2737   
;;;2738     /* Disable the Peripheral */
;;;2739     __HAL_TIM_DISABLE(htim);
00003c  6801              LDR      r1,[r0,#0]
00003e  6a0a              LDR      r2,[r1,#0x20]
000040  4b11              LDR      r3,|L30.136|
000042  421a              TST      r2,r3
000044  d107              BNE      |L30.86|
000046  6a0a              LDR      r2,[r1,#0x20]
000048  109b              ASRS     r3,r3,#2
00004a  421a              TST      r2,r3
00004c  d103              BNE      |L30.86|
00004e  680a              LDR      r2,[r1,#0]
000050  0852              LSRS     r2,r2,#1
000052  0052              LSLS     r2,r2,#1
000054  600a              STR      r2,[r1,#0]
                  |L30.86|
;;;2740   
;;;2741     /* Change the htim state */
;;;2742     htim->State = HAL_TIM_STATE_READY;
000056  6404              STR      r4,[r0,#0x40]
;;;2743   
;;;2744     /* Return function status */
;;;2745     return HAL_OK;
;;;2746   }
000058  bc70              POP      {r4-r6}
00005a  2000              MOVS     r0,#0                 ;2745
00005c  4770              BX       lr
                  |L30.94|
00005e  6a11              LDR      r1,[r2,#0x20]
000060  0849              LSRS     r1,r1,#1
000062  0049              LSLS     r1,r1,#1
000064  6211              STR      r1,[r2,#0x20]
000066  6a11              LDR      r1,[r2,#0x20]
000068  6211              STR      r1,[r2,#0x20]
00006a  6801              LDR      r1,[r0,#0]            ;2719
00006c  68ca              LDR      r2,[r1,#0xc]          ;2719
00006e  439a              BICS     r2,r2,r3              ;2719
000070  e008              B        |L30.132|
                  |L30.114|
000072  6a13              LDR      r3,[r2,#0x20]         ;2719
000074  2110              MOVS     r1,#0x10              ;2719
000076  438b              BICS     r3,r3,r1              ;2719
000078  6213              STR      r3,[r2,#0x20]         ;2719
00007a  6a11              LDR      r1,[r2,#0x20]         ;2719
00007c  6211              STR      r1,[r2,#0x20]         ;2719
00007e  6801              LDR      r1,[r0,#0]            ;2726
000080  68ca              LDR      r2,[r1,#0xc]          ;2726
000082  43aa              BICS     r2,r2,r5              ;2726
                  |L30.132|
000084  60ca              STR      r2,[r1,#0xc]          ;2726
000086  e7d9              B        |L30.60|
;;;2747   
                          ENDP

                  |L30.136|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_Encoder_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Stop_IT PROC
;;;2535   */
;;;2536   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b470              PUSH     {r4-r6}
;;;2537   {
;;;2538     /* Check the parameters */
;;;2539     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2540   
;;;2541     /* Disable the Input Capture channels 1 and 2
;;;2542       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
;;;2543     if(Channel == TIM_CHANNEL_1)
;;;2544     {
;;;2545       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
;;;2546   
;;;2547       /* Disable the capture compare Interrupts 1 */
;;;2548     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000002  2302              MOVS     r3,#2
000004  2401              MOVS     r4,#1
000006  6802              LDR      r2,[r0,#0]            ;2543
000008  2900              CMP      r1,#0                 ;2543
00000a  d027              BEQ      |L31.92|
00000c  2504              MOVS     r5,#4                 ;2537
;;;2549     }
;;;2550     else if(Channel == TIM_CHANNEL_2)
00000e  2904              CMP      r1,#4
000010  d02e              BEQ      |L31.112|
000012  6a11              LDR      r1,[r2,#0x20]
000014  43a1              BICS     r1,r1,r4
000016  6211              STR      r1,[r2,#0x20]
000018  6a11              LDR      r1,[r2,#0x20]
00001a  6211              STR      r1,[r2,#0x20]
00001c  6801              LDR      r1,[r0,#0]
00001e  2210              MOVS     r2,#0x10
000020  6a0e              LDR      r6,[r1,#0x20]
000022  4396              BICS     r6,r6,r2
000024  620e              STR      r6,[r1,#0x20]
000026  6a0a              LDR      r2,[r1,#0x20]
000028  620a              STR      r2,[r1,#0x20]
;;;2551     {
;;;2552       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
;;;2553   
;;;2554       /* Disable the capture compare Interrupts 2 */
;;;2555     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
;;;2556     }
;;;2557     else
;;;2558     {
;;;2559       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
;;;2560       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
;;;2561   
;;;2562       /* Disable the capture compare Interrupts 1 and 2 */
;;;2563       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
00002a  6801              LDR      r1,[r0,#0]
00002c  68ca              LDR      r2,[r1,#0xc]
00002e  439a              BICS     r2,r2,r3
000030  60ca              STR      r2,[r1,#0xc]
;;;2564       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000032  6801              LDR      r1,[r0,#0]
000034  68ca              LDR      r2,[r1,#0xc]
000036  43aa              BICS     r2,r2,r5
000038  60ca              STR      r2,[r1,#0xc]
                  |L31.58|
;;;2565     }
;;;2566   
;;;2567     /* Disable the Peripheral */
;;;2568     __HAL_TIM_DISABLE(htim);
00003a  6801              LDR      r1,[r0,#0]
00003c  6a0a              LDR      r2,[r1,#0x20]
00003e  4b12              LDR      r3,|L31.136|
000040  421a              TST      r2,r3
000042  d107              BNE      |L31.84|
000044  6a0a              LDR      r2,[r1,#0x20]
000046  109b              ASRS     r3,r3,#2
000048  421a              TST      r2,r3
00004a  d103              BNE      |L31.84|
00004c  680a              LDR      r2,[r1,#0]
00004e  0852              LSRS     r2,r2,#1
000050  0052              LSLS     r2,r2,#1
000052  600a              STR      r2,[r1,#0]
                  |L31.84|
;;;2569   
;;;2570     /* Change the htim state */
;;;2571     htim->State = HAL_TIM_STATE_READY;
000054  6404              STR      r4,[r0,#0x40]
;;;2572   
;;;2573     /* Return function status */
;;;2574     return HAL_OK;
;;;2575   }
000056  bc70              POP      {r4-r6}
000058  2000              MOVS     r0,#0                 ;2574
00005a  4770              BX       lr
                  |L31.92|
00005c  6a11              LDR      r1,[r2,#0x20]
00005e  0849              LSRS     r1,r1,#1
000060  0049              LSLS     r1,r1,#1
000062  6211              STR      r1,[r2,#0x20]
000064  6a11              LDR      r1,[r2,#0x20]
000066  6211              STR      r1,[r2,#0x20]
000068  6801              LDR      r1,[r0,#0]            ;2548
00006a  68ca              LDR      r2,[r1,#0xc]          ;2548
00006c  439a              BICS     r2,r2,r3              ;2548
00006e  e008              B        |L31.130|
                  |L31.112|
000070  6a13              LDR      r3,[r2,#0x20]         ;2548
000072  2110              MOVS     r1,#0x10              ;2548
000074  438b              BICS     r3,r3,r1              ;2548
000076  6213              STR      r3,[r2,#0x20]         ;2548
000078  6a11              LDR      r1,[r2,#0x20]         ;2548
00007a  6211              STR      r1,[r2,#0x20]         ;2548
00007c  6801              LDR      r1,[r0,#0]            ;2555
00007e  68ca              LDR      r2,[r1,#0xc]          ;2555
000080  43aa              BICS     r2,r2,r5              ;2555
                  |L31.130|
000082  60ca              STR      r2,[r1,#0xc]          ;2555
000084  e7d9              B        |L31.58|
;;;2576   
                          ENDP

000086  0000              DCW      0x0000
                  |L31.136|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ErrorCallback PROC
;;;4458     */
;;;4459   __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4460   {
;;;4461     /* Prevent unused argument(s) compilation warning */
;;;4462     UNUSED(htim);
;;;4463   
;;;4464     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4465               the HAL_TIM_ErrorCallback could be implemented in the user file
;;;4466      */
;;;4467   }
;;;4468   
                          ENDP


                          AREA ||i.HAL_TIM_GenerateEvent||, CODE, READONLY, ALIGN=1

                  HAL_TIM_GenerateEvent PROC
;;;3853   
;;;3854   HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
000000  6bc2              LDR      r2,[r0,#0x3c]
;;;3855   {
;;;3856     /* Check the parameters */
;;;3857     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;3858     assert_param(IS_TIM_EVENT_SOURCE(EventSource));
;;;3859   
;;;3860     /* Process Locked */
;;;3861     __HAL_LOCK(htim);
000002  2a01              CMP      r2,#1
000004  d009              BEQ      |L33.26|
000006  2201              MOVS     r2,#1
;;;3862   
;;;3863     /* Change the TIM state */
;;;3864     htim->State = HAL_TIM_STATE_BUSY;
000008  2302              MOVS     r3,#2
00000a  6403              STR      r3,[r0,#0x40]
;;;3865   
;;;3866     /* Set the event sources */
;;;3867     htim->Instance->EGR = EventSource;
00000c  6803              LDR      r3,[r0,#0]
00000e  6159              STR      r1,[r3,#0x14]
;;;3868   
;;;3869     /* Change the TIM state */
;;;3870     htim->State = HAL_TIM_STATE_READY;
000010  6402              STR      r2,[r0,#0x40]
;;;3871   
;;;3872     __HAL_UNLOCK(htim);
000012  2100              MOVS     r1,#0
;;;3873   
;;;3874     /* Return function status */
;;;3875     return HAL_OK;
000014  63c1              STR      r1,[r0,#0x3c]
000016  4608              MOV      r0,r1
;;;3876   }
000018  4770              BX       lr
                  |L33.26|
00001a  2002              MOVS     r0,#2                 ;3861
00001c  4770              BX       lr
;;;3877   
                          ENDP


                          AREA ||i.HAL_TIM_IC_CaptureCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_CaptureCallback PROC
;;;4413     */
;;;4414   __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4415   {
;;;4416     /* Prevent unused argument(s) compilation warning */
;;;4417     UNUSED(htim);
;;;4418   
;;;4419     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4420               the __HAL_TIM_IC_CaptureCallback could be implemented in the user file
;;;4421      */
;;;4422   }
;;;4423   
                          ENDP


                          AREA ||i.HAL_TIM_IC_ConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_TIM_IC_ConfigChannel PROC
;;;3000     */
;;;3001   HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef* sConfig, uint32_t Channel)
000000  b4f0              PUSH     {r4-r7}
;;;3002   {
;;;3003     /* Check the parameters */
;;;3004     assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3005     assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
;;;3006     assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
;;;3007     assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
;;;3008     assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
;;;3009   
;;;3010     __HAL_LOCK(htim);
000002  6bc3              LDR      r3,[r0,#0x3c]
000004  2b01              CMP      r3,#1
000006  d03d              BEQ      |L35.132|
000008  2301              MOVS     r3,#1
;;;3011   
;;;3012     htim->State = HAL_TIM_STATE_BUSY;
00000a  63c3              STR      r3,[r0,#0x3c]
00000c  2302              MOVS     r3,#2
00000e  6403              STR      r3,[r0,#0x40]
;;;3013   
;;;3014     if (Channel == TIM_CHANNEL_1)
000010  2a00              CMP      r2,#0
000012  d03a              BEQ      |L35.138|
000014  2603              MOVS     r6,#3                 ;3010
000016  0236              LSLS     r6,r6,#8              ;3010
;;;3015     {
;;;3016       /* TI1 Configuration */
;;;3017       TIM_TI1_SetConfig(htim->Instance,
;;;3018                  sConfig->ICPolarity,
;;;3019                  sConfig->ICSelection,
;;;3020                  sConfig->ICFilter);
;;;3021   
;;;3022       /* Reset the IC1PSC Bits */
;;;3023       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;3024   
;;;3025       /* Set the IC1PSC value */
;;;3026       htim->Instance->CCMR1 |= sConfig->ICPrescaler;
;;;3027     }
;;;3028     else if (Channel == TIM_CHANNEL_2)
000018  2a04              CMP      r2,#4
00001a  d063              BEQ      |L35.228|
;;;3029     {
;;;3030       /* TI2 Configuration */
;;;3031       assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3032   
;;;3033       TIM_TI2_SetConfig(htim->Instance,
;;;3034                         sConfig->ICPolarity,
;;;3035                         sConfig->ICSelection,
;;;3036                         sConfig->ICFilter);
;;;3037   
;;;3038       /* Reset the IC2PSC Bits */
;;;3039       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;3040   
;;;3041       /* Set the IC2PSC value */
;;;3042       htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8U);
;;;3043     }
;;;3044     else if (Channel == TIM_CHANNEL_3)
00001c  2a08              CMP      r2,#8
00001e  d07d              BEQ      |L35.284|
;;;3045     {
;;;3046       /* TI3 Configuration */
;;;3047       assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3048   
;;;3049       TIM_TI3_SetConfig(htim->Instance,
;;;3050                  sConfig->ICPolarity,
;;;3051                  sConfig->ICSelection,
;;;3052                  sConfig->ICFilter);
;;;3053   
;;;3054       /* Reset the IC3PSC Bits */
;;;3055       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
;;;3056   
;;;3057       /* Set the IC3PSC value */
;;;3058       htim->Instance->CCMR2 |= sConfig->ICPrescaler;
;;;3059     }
;;;3060     else
;;;3061     {
;;;3062       /* TI4 Configuration */
;;;3063       assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3064   
;;;3065       TIM_TI4_SetConfig(htim->Instance,
000020  684b              LDR      r3,[r1,#4]
000022  6802              LDR      r2,[r0,#0]
000024  469c              MOV      r12,r3
000026  7b0f              LDRB     r7,[r1,#0xc]
000028  680d              LDR      r5,[r1,#0]
00002a  6a13              LDR      r3,[r2,#0x20]
00002c  2401              MOVS     r4,#1
00002e  0324              LSLS     r4,r4,#12
000030  43a3              BICS     r3,r3,r4
000032  6213              STR      r3,[r2,#0x20]
000034  69d3              LDR      r3,[r2,#0x1c]
000036  6a14              LDR      r4,[r2,#0x20]
000038  43b3              BICS     r3,r3,r6
00003a  4666              MOV      r6,r12
00003c  0236              LSLS     r6,r6,#8
00003e  431e              ORRS     r6,r6,r3
000040  230f              MOVS     r3,#0xf
000042  031b              LSLS     r3,r3,#12
000044  439e              BICS     r6,r6,r3
000046  073b              LSLS     r3,r7,#28
000048  0c1b              LSRS     r3,r3,#16
00004a  4333              ORRS     r3,r3,r6
00004c  2605              MOVS     r6,#5
00004e  0376              LSLS     r6,r6,#13
000050  43b4              BICS     r4,r4,r6
000052  260a              MOVS     r6,#0xa
000054  4035              ANDS     r5,r5,r6
000056  032d              LSLS     r5,r5,#12
000058  4325              ORRS     r5,r5,r4
00005a  61d3              STR      r3,[r2,#0x1c]
00005c  6215              STR      r5,[r2,#0x20]
;;;3066                  sConfig->ICPolarity,
;;;3067                  sConfig->ICSelection,
;;;3068                  sConfig->ICFilter);
;;;3069   
;;;3070       /* Reset the IC4PSC Bits */
;;;3071       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
00005e  6802              LDR      r2,[r0,#0]
000060  69d4              LDR      r4,[r2,#0x1c]
000062  2303              MOVS     r3,#3
000064  029b              LSLS     r3,r3,#10
000066  439c              BICS     r4,r4,r3
000068  61d4              STR      r4,[r2,#0x1c]
;;;3072   
;;;3073       /* Set the IC4PSC value */
;;;3074       htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);
00006a  6802              LDR      r2,[r0,#0]
00006c  69d3              LDR      r3,[r2,#0x1c]
00006e  6889              LDR      r1,[r1,#8]
000070  0209              LSLS     r1,r1,#8
000072  430b              ORRS     r3,r3,r1
000074  61d3              STR      r3,[r2,#0x1c]
                  |L35.118|
;;;3075     }
;;;3076   
;;;3077     htim->State = HAL_TIM_STATE_READY;
000076  2101              MOVS     r1,#1
000078  6401              STR      r1,[r0,#0x40]
;;;3078   
;;;3079     __HAL_UNLOCK(htim);
00007a  2100              MOVS     r1,#0
;;;3080   
;;;3081     return HAL_OK;
00007c  63c1              STR      r1,[r0,#0x3c]
;;;3082   }
00007e  bcf0              POP      {r4-r7}
000080  4608              MOV      r0,r1                 ;3081
000082  4770              BX       lr
                  |L35.132|
000084  bcf0              POP      {r4-r7}
000086  2002              MOVS     r0,#2                 ;3010
000088  4770              BX       lr
                  |L35.138|
00008a  684a              LDR      r2,[r1,#4]            ;3017
00008c  6803              LDR      r3,[r0,#0]            ;3017
00008e  4694              MOV      r12,r2                ;3017
000090  68ce              LDR      r6,[r1,#0xc]          ;3017
000092  680c              LDR      r4,[r1,#0]            ;3017
000094  6a1a              LDR      r2,[r3,#0x20]         ;3017
000096  0852              LSRS     r2,r2,#1              ;3017
000098  0052              LSLS     r2,r2,#1              ;3017
00009a  621a              STR      r2,[r3,#0x20]         ;3017
00009c  699a              LDR      r2,[r3,#0x18]         ;3017
00009e  6a1d              LDR      r5,[r3,#0x20]         ;3017
0000a0  4f39              LDR      r7,|L35.392|
0000a2  42bb              CMP      r3,r7                 ;3017
0000a4  d002              BEQ      |L35.172|
0000a6  4f39              LDR      r7,|L35.396|
0000a8  42bb              CMP      r3,r7                 ;3017
0000aa  d103              BNE      |L35.180|
                  |L35.172|
0000ac  0892              LSRS     r2,r2,#2              ;3017
0000ae  0092              LSLS     r2,r2,#2              ;3017
0000b0  4667              MOV      r7,r12                ;3017
0000b2  e000              B        |L35.182|
                  |L35.180|
0000b4  2701              MOVS     r7,#1                 ;3017
                  |L35.182|
0000b6  433a              ORRS     r2,r2,r7              ;3017
0000b8  27f0              MOVS     r7,#0xf0              ;3017
0000ba  0736              LSLS     r6,r6,#28             ;3017
0000bc  43ba              BICS     r2,r2,r7              ;3017
0000be  0e36              LSRS     r6,r6,#24             ;3017
0000c0  4316              ORRS     r6,r6,r2              ;3017
0000c2  220a              MOVS     r2,#0xa               ;3017
0000c4  4395              BICS     r5,r5,r2              ;3017
0000c6  4014              ANDS     r4,r4,r2              ;3017
0000c8  432c              ORRS     r4,r4,r5              ;3017
0000ca  619e              STR      r6,[r3,#0x18]         ;3017
0000cc  621c              STR      r4,[r3,#0x20]         ;3017
0000ce  6802              LDR      r2,[r0,#0]            ;3023
0000d0  6993              LDR      r3,[r2,#0x18]         ;3023
0000d2  240c              MOVS     r4,#0xc               ;3023
0000d4  43a3              BICS     r3,r3,r4              ;3023
0000d6  6193              STR      r3,[r2,#0x18]         ;3023
0000d8  6802              LDR      r2,[r0,#0]            ;3026
0000da  6993              LDR      r3,[r2,#0x18]         ;3026
0000dc  6889              LDR      r1,[r1,#8]            ;3026
0000de  430b              ORRS     r3,r3,r1              ;3026
0000e0  6193              STR      r3,[r2,#0x18]         ;3026
0000e2  e7c8              B        |L35.118|
                  |L35.228|
0000e4  680b              LDR      r3,[r1,#0]            ;3033
0000e6  6802              LDR      r2,[r0,#0]            ;3033
0000e8  469c              MOV      r12,r3                ;3033
0000ea  7b0d              LDRB     r5,[r1,#0xc]          ;3033
0000ec  684f              LDR      r7,[r1,#4]            ;3033
0000ee  6a13              LDR      r3,[r2,#0x20]         ;3033
0000f0  2410              MOVS     r4,#0x10              ;3033
0000f2  43a3              BICS     r3,r3,r4              ;3033
0000f4  6213              STR      r3,[r2,#0x20]         ;3033
0000f6  6993              LDR      r3,[r2,#0x18]         ;3033
0000f8  6a14              LDR      r4,[r2,#0x20]         ;3033
0000fa  43b3              BICS     r3,r3,r6              ;3033
0000fc  023e              LSLS     r6,r7,#8              ;3033
0000fe  431e              ORRS     r6,r6,r3              ;3033
000100  230f              MOVS     r3,#0xf               ;3033
000102  031b              LSLS     r3,r3,#12             ;3033
000104  439e              BICS     r6,r6,r3              ;3033
000106  072b              LSLS     r3,r5,#28             ;3033
000108  0c1f              LSRS     r7,r3,#16             ;3033
00010a  25a0              MOVS     r5,#0xa0              ;3033
00010c  4663              MOV      r3,r12                ;3033
00010e  4337              ORRS     r7,r7,r6              ;3033
000110  011b              LSLS     r3,r3,#4              ;3033
000112  43ac              BICS     r4,r4,r5              ;3033
000114  402b              ANDS     r3,r3,r5              ;3033
000116  4323              ORRS     r3,r3,r4              ;3033
000118  6197              STR      r7,[r2,#0x18]         ;3033
00011a  e000              B        |L35.286|
                  |L35.284|
00011c  e00d              B        |L35.314|
                  |L35.286|
00011e  6213              STR      r3,[r2,#0x20]         ;3033
000120  6802              LDR      r2,[r0,#0]            ;3039
000122  6993              LDR      r3,[r2,#0x18]         ;3039
000124  2403              MOVS     r4,#3                 ;3039
000126  02a4              LSLS     r4,r4,#10             ;3039
000128  43a3              BICS     r3,r3,r4              ;3039
00012a  6193              STR      r3,[r2,#0x18]         ;3039
00012c  6802              LDR      r2,[r0,#0]            ;3042
00012e  6993              LDR      r3,[r2,#0x18]         ;3042
000130  6889              LDR      r1,[r1,#8]            ;3042
000132  0209              LSLS     r1,r1,#8              ;3042
000134  430b              ORRS     r3,r3,r1              ;3042
000136  6193              STR      r3,[r2,#0x18]         ;3042
000138  e79d              B        |L35.118|
                  |L35.314|
00013a  6803              LDR      r3,[r0,#0]            ;3049
00013c  7b0e              LDRB     r6,[r1,#0xc]          ;3049
00013e  684f              LDR      r7,[r1,#4]            ;3049
000140  680d              LDR      r5,[r1,#0]            ;3049
000142  6a1a              LDR      r2,[r3,#0x20]         ;3049
000144  24ff              MOVS     r4,#0xff              ;3049
000146  3401              ADDS     r4,#1                 ;3049
000148  43a2              BICS     r2,r2,r4              ;3049
00014a  621a              STR      r2,[r3,#0x20]         ;3049
00014c  69da              LDR      r2,[r3,#0x1c]         ;3049
00014e  6a1c              LDR      r4,[r3,#0x20]         ;3049
000150  0892              LSRS     r2,r2,#2              ;3049
000152  0092              LSLS     r2,r2,#2              ;3049
000154  433a              ORRS     r2,r2,r7              ;3049
000156  27f0              MOVS     r7,#0xf0              ;3049
000158  0736              LSLS     r6,r6,#28             ;3049
00015a  43ba              BICS     r2,r2,r7              ;3049
00015c  0e36              LSRS     r6,r6,#24             ;3049
00015e  4316              ORRS     r6,r6,r2              ;3049
000160  2205              MOVS     r2,#5                 ;3049
000162  0252              LSLS     r2,r2,#9              ;3049
000164  4394              BICS     r4,r4,r2              ;3049
000166  220a              MOVS     r2,#0xa               ;3049
000168  4015              ANDS     r5,r5,r2              ;3049
00016a  022a              LSLS     r2,r5,#8              ;3049
00016c  4322              ORRS     r2,r2,r4              ;3049
00016e  61de              STR      r6,[r3,#0x1c]         ;3049
000170  621a              STR      r2,[r3,#0x20]         ;3049
000172  6802              LDR      r2,[r0,#0]            ;3055
000174  69d4              LDR      r4,[r2,#0x1c]         ;3055
000176  230c              MOVS     r3,#0xc               ;3055
000178  439c              BICS     r4,r4,r3              ;3055
00017a  61d4              STR      r4,[r2,#0x1c]         ;3055
00017c  6802              LDR      r2,[r0,#0]            ;3058
00017e  69d3              LDR      r3,[r2,#0x1c]         ;3058
000180  6889              LDR      r1,[r1,#8]            ;3058
000182  430b              ORRS     r3,r3,r1              ;3058
000184  61d3              STR      r3,[r2,#0x1c]         ;3058
000186  e776              B        |L35.118|
;;;3083   
                          ENDP

                  |L35.392|
                          DCD      0x40012c00
                  |L35.396|
                          DCD      0x40000400

                          AREA ||i.HAL_TIM_IC_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_TIM_IC_DeInit PROC
;;;1537     */
;;;1538   HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1539   {
000002  4604              MOV      r4,r0
;;;1540     /* Check the parameters */
;;;1541     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1542   
;;;1543     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  6420              STR      r0,[r4,#0x40]
;;;1544   
;;;1545     /* Disable the TIM Peripheral Clock */
;;;1546     __HAL_TIM_DISABLE(htim);
000008  6820              LDR      r0,[r4,#0]
00000a  6a01              LDR      r1,[r0,#0x20]
00000c  4a08              LDR      r2,|L36.48|
00000e  4211              TST      r1,r2
000010  d107              BNE      |L36.34|
000012  6a01              LDR      r1,[r0,#0x20]
000014  1092              ASRS     r2,r2,#2
000016  4211              TST      r1,r2
000018  d103              BNE      |L36.34|
00001a  6801              LDR      r1,[r0,#0]
00001c  0849              LSRS     r1,r1,#1
00001e  0049              LSLS     r1,r1,#1
000020  6001              STR      r1,[r0,#0]
                  |L36.34|
;;;1547   
;;;1548     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;1549     HAL_TIM_IC_MspDeInit(htim);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       HAL_TIM_IC_MspDeInit
;;;1550   
;;;1551     /* Change TIM state */
;;;1552     htim->State = HAL_TIM_STATE_RESET;
000028  2000              MOVS     r0,#0
00002a  6420              STR      r0,[r4,#0x40]
;;;1553   
;;;1554     /* Release Lock */
;;;1555     __HAL_UNLOCK(htim);
00002c  63e0              STR      r0,[r4,#0x3c]
;;;1556   
;;;1557     return HAL_OK;
;;;1558   }
00002e  bd10              POP      {r4,pc}
;;;1559   
                          ENDP

                  |L36.48|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_IC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_GetState PROC
;;;4522     */
;;;4523   HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
000000  6c00              LDR      r0,[r0,#0x40]
;;;4524   {
;;;4525     return htim->State;
;;;4526   }
000002  4770              BX       lr
;;;4527   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Init PROC
;;;1497     */
;;;1498   HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
000000  2800              CMP      r0,#0
;;;1499   {
;;;1500     /* Check the TIM handle allocation */
;;;1501     if(htim == NULL)
000002  d101              BNE      |L38.8|
;;;1502     {
;;;1503       return HAL_ERROR;
000004  2001              MOVS     r0,#1
;;;1504     }
;;;1505   
;;;1506     /* Check the parameters */
;;;1507     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1508     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1509     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;1510     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;1511   
;;;1512     if(htim->State == HAL_TIM_STATE_RESET)
;;;1513     {
;;;1514       /* Allocate lock resource and initialize it */
;;;1515       htim->Lock = HAL_UNLOCKED;
;;;1516   
;;;1517       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1518       HAL_TIM_IC_MspInit(htim);
;;;1519     }
;;;1520   
;;;1521     /* Set the TIM state */
;;;1522     htim->State= HAL_TIM_STATE_BUSY;
;;;1523   
;;;1524     /* Init the base time for the input capture */
;;;1525     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;1526   
;;;1527     /* Initialize the TIM state*/
;;;1528     htim->State= HAL_TIM_STATE_READY;
;;;1529   
;;;1530     return HAL_OK;
;;;1531   }
000006  4770              BX       lr
                  |L38.8|
000008  b510              PUSH     {r4,lr}               ;1499
00000a  4604              MOV      r4,r0                 ;1499
00000c  6c00              LDR      r0,[r0,#0x40]         ;1512
00000e  2800              CMP      r0,#0                 ;1512
000010  d103              BNE      |L38.26|
000012  63e0              STR      r0,[r4,#0x3c]         ;1518
000014  4620              MOV      r0,r4                 ;1518
000016  f7fffffe          BL       HAL_TIM_IC_MspInit
                  |L38.26|
00001a  2002              MOVS     r0,#2                 ;1522
00001c  6420              STR      r0,[r4,#0x40]         ;1522
00001e  1d21              ADDS     r1,r4,#4              ;1525
000020  6820              LDR      r0,[r4,#0]            ;1525
000022  f7fffffe          BL       TIM_Base_SetConfig
000026  2001              MOVS     r0,#1                 ;1528
000028  6420              STR      r0,[r4,#0x40]         ;1528
00002a  2000              MOVS     r0,#0                 ;1530
00002c  bd10              POP      {r4,pc}
;;;1532   
                          ENDP


                          AREA ||i.HAL_TIM_IC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_MspDeInit PROC
;;;1579     */
;;;1580   __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1581   {
;;;1582     /* Prevent unused argument(s) compilation warning */
;;;1583     UNUSED(htim);
;;;1584   
;;;1585     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1586               the HAL_TIM_IC_MspDeInit could be implemented in the user file
;;;1587      */
;;;1588   }
;;;1589   
                          ENDP


                          AREA ||i.HAL_TIM_IC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_MspInit PROC
;;;1564     */
;;;1565   __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1566   {
;;;1567     /* Prevent unused argument(s) compilation warning */
;;;1568     UNUSED(htim);
;;;1569   
;;;1570     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1571               the HAL_TIM_IC_MspInit could be implemented in the user file
;;;1572      */
;;;1573   }
;;;1574   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Start PROC
;;;1600   */
;;;1601   HAL_StatusTypeDef HAL_TIM_IC_Start (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b410              PUSH     {r4}
000002  2401              MOVS     r4,#1
000004  4622              MOV      r2,r4
000006  6803              LDR      r3,[r0,#0]
000008  408a              LSLS     r2,r2,r1
00000a  6a19              LDR      r1,[r3,#0x20]
00000c  4391              BICS     r1,r1,r2
00000e  6219              STR      r1,[r3,#0x20]
000010  6a19              LDR      r1,[r3,#0x20]
000012  4311              ORRS     r1,r1,r2
000014  6219              STR      r1,[r3,#0x20]
;;;1602   {
;;;1603     /* Check the parameters */
;;;1604     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1605   
;;;1606     /* Enable the Input Capture channel */
;;;1607     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1608   
;;;1609     /* Enable the Peripheral */
;;;1610     __HAL_TIM_ENABLE(htim);
000016  6800              LDR      r0,[r0,#0]
000018  6801              LDR      r1,[r0,#0]
00001a  4321              ORRS     r1,r1,r4
00001c  6001              STR      r1,[r0,#0]
;;;1611   
;;;1612     /* Return function status */
;;;1613     return HAL_OK;
;;;1614   }
00001e  bc10              POP      {r4}
000020  2000              MOVS     r0,#0                 ;1613
000022  4770              BX       lr
;;;1615   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_IC_Start_DMA PROC
;;;1773   */
;;;1774   HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;1775   {
000002  4604              MOV      r4,r0
;;;1776     /* Check the parameters */
;;;1777     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1778     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;1779   
;;;1780     if((htim->State == HAL_TIM_STATE_BUSY))
000004  6c00              LDR      r0,[r0,#0x40]
000006  460d              MOV      r5,r1                 ;1775
000008  2802              CMP      r0,#2
00000a  d006              BEQ      |L42.26|
;;;1781     {
;;;1782        return HAL_BUSY;
;;;1783     }
;;;1784     else if((htim->State == HAL_TIM_STATE_READY))
00000c  6c20              LDR      r0,[r4,#0x40]
00000e  2801              CMP      r0,#1
000010  d106              BNE      |L42.32|
;;;1785     {
;;;1786       if((pData == 0U ) && (Length > 0U))
000012  2a00              CMP      r2,#0
000014  d102              BNE      |L42.28|
000016  2b00              CMP      r3,#0
000018  d000              BEQ      |L42.28|
                  |L42.26|
;;;1787       {
;;;1788         return HAL_ERROR;
;;;1789       }
;;;1790       else
;;;1791       {
;;;1792         htim->State = HAL_TIM_STATE_BUSY;
;;;1793       }
;;;1794     }
;;;1795   
;;;1796     switch (Channel)
;;;1797     {
;;;1798       case TIM_CHANNEL_1:
;;;1799       {
;;;1800         /* Set the DMA Period elapsed callback */
;;;1801         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1802   
;;;1803         /* Set the DMA error callback */
;;;1804         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;1805   
;;;1806         /* Enable the DMA channel */
;;;1807         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length);
;;;1808   
;;;1809         /* Enable the TIM Capture/Compare 1 DMA request */
;;;1810         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1811       }
;;;1812       break;
;;;1813   
;;;1814       case TIM_CHANNEL_2:
;;;1815       {
;;;1816         /* Set the DMA Period elapsed callback */
;;;1817         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1818   
;;;1819         /* Set the DMA error callback */
;;;1820         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;1821   
;;;1822         /* Enable the DMA channel */
;;;1823         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length);
;;;1824   
;;;1825         /* Enable the TIM Capture/Compare 2  DMA request */
;;;1826         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1827       }
;;;1828       break;
;;;1829   
;;;1830       case TIM_CHANNEL_3:
;;;1831       {
;;;1832         /* Set the DMA Period elapsed callback */
;;;1833         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1834   
;;;1835         /* Set the DMA error callback */
;;;1836         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;1837   
;;;1838         /* Enable the DMA channel */
;;;1839         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length);
;;;1840   
;;;1841         /* Enable the TIM Capture/Compare 3  DMA request */
;;;1842         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1843       }
;;;1844       break;
;;;1845   
;;;1846       case TIM_CHANNEL_4:
;;;1847       {
;;;1848         /* Set the DMA Period elapsed callback */
;;;1849         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1850   
;;;1851         /* Set the DMA error callback */
;;;1852         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;1853   
;;;1854         /* Enable the DMA channel */
;;;1855         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length);
;;;1856   
;;;1857         /* Enable the TIM Capture/Compare 4  DMA request */
;;;1858         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1859       }
;;;1860       break;
;;;1861   
;;;1862       default:
;;;1863       break;
;;;1864     }
;;;1865   
;;;1866     /* Enable the Input Capture channel */
;;;1867     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1868   
;;;1869     /* Enable the Peripheral */
;;;1870     __HAL_TIM_ENABLE(htim);
;;;1871   
;;;1872     /* Return function status */
;;;1873     return HAL_OK;
;;;1874   }
00001a  bd70              POP      {r4-r6,pc}
                  |L42.28|
00001c  2002              MOVS     r0,#2                 ;1792
00001e  6420              STR      r0,[r4,#0x40]         ;1792
                  |L42.32|
000020  482c              LDR      r0,|L42.212|
000022  492d              LDR      r1,|L42.216|
000024  2d00              CMP      r5,#0                 ;1796
000026  d006              BEQ      |L42.54|
000028  2d04              CMP      r5,#4                 ;1796
00002a  d014              BEQ      |L42.86|
00002c  2d08              CMP      r5,#8                 ;1796
00002e  d022              BEQ      |L42.118|
000030  2d0c              CMP      r5,#0xc               ;1796
000032  d13f              BNE      |L42.180|
000034  e02f              B        |L42.150|
                  |L42.54|
000036  6a66              LDR      r6,[r4,#0x24]         ;1801
000038  62f0              STR      r0,[r6,#0x2c]         ;1804
00003a  6a60              LDR      r0,[r4,#0x24]         ;1804
00003c  6341              STR      r1,[r0,#0x34]         ;1807
00003e  6821              LDR      r1,[r4,#0]            ;1807
000040  6a60              LDR      r0,[r4,#0x24]         ;1807
000042  3134              ADDS     r1,r1,#0x34           ;1807
000044  f7fffffe          BL       HAL_DMA_Start_IT
000048  6820              LDR      r0,[r4,#0]            ;1810
00004a  68c1              LDR      r1,[r0,#0xc]          ;1810
00004c  2201              MOVS     r2,#1                 ;1810
00004e  0252              LSLS     r2,r2,#9              ;1810
000050  4311              ORRS     r1,r1,r2              ;1810
000052  60c1              STR      r1,[r0,#0xc]          ;1810
000054  e02e              B        |L42.180|
                  |L42.86|
000056  6aa6              LDR      r6,[r4,#0x28]         ;1817
000058  62f0              STR      r0,[r6,#0x2c]         ;1820
00005a  6aa0              LDR      r0,[r4,#0x28]         ;1820
00005c  6341              STR      r1,[r0,#0x34]         ;1823
00005e  6821              LDR      r1,[r4,#0]            ;1823
000060  6aa0              LDR      r0,[r4,#0x28]         ;1823
000062  3138              ADDS     r1,r1,#0x38           ;1823
000064  f7fffffe          BL       HAL_DMA_Start_IT
000068  6820              LDR      r0,[r4,#0]            ;1826
00006a  68c1              LDR      r1,[r0,#0xc]          ;1826
00006c  2201              MOVS     r2,#1                 ;1826
00006e  0292              LSLS     r2,r2,#10             ;1826
000070  4311              ORRS     r1,r1,r2              ;1826
000072  60c1              STR      r1,[r0,#0xc]          ;1826
000074  e01e              B        |L42.180|
                  |L42.118|
000076  6ae6              LDR      r6,[r4,#0x2c]         ;1833
000078  62f0              STR      r0,[r6,#0x2c]         ;1836
00007a  6ae0              LDR      r0,[r4,#0x2c]         ;1836
00007c  6341              STR      r1,[r0,#0x34]         ;1839
00007e  6821              LDR      r1,[r4,#0]            ;1839
000080  6ae0              LDR      r0,[r4,#0x2c]         ;1839
000082  313c              ADDS     r1,r1,#0x3c           ;1839
000084  f7fffffe          BL       HAL_DMA_Start_IT
000088  6820              LDR      r0,[r4,#0]            ;1842
00008a  68c1              LDR      r1,[r0,#0xc]          ;1842
00008c  2201              MOVS     r2,#1                 ;1842
00008e  02d2              LSLS     r2,r2,#11             ;1842
000090  4311              ORRS     r1,r1,r2              ;1842
000092  60c1              STR      r1,[r0,#0xc]          ;1842
000094  e00e              B        |L42.180|
                  |L42.150|
000096  6b26              LDR      r6,[r4,#0x30]         ;1849
000098  62f0              STR      r0,[r6,#0x2c]         ;1852
00009a  6b20              LDR      r0,[r4,#0x30]         ;1852
00009c  6341              STR      r1,[r0,#0x34]         ;1855
00009e  6821              LDR      r1,[r4,#0]            ;1855
0000a0  6b20              LDR      r0,[r4,#0x30]         ;1855
0000a2  3140              ADDS     r1,r1,#0x40           ;1855
0000a4  f7fffffe          BL       HAL_DMA_Start_IT
0000a8  6820              LDR      r0,[r4,#0]            ;1858
0000aa  68c1              LDR      r1,[r0,#0xc]          ;1858
0000ac  2201              MOVS     r2,#1                 ;1858
0000ae  0312              LSLS     r2,r2,#12             ;1858
0000b0  4311              ORRS     r1,r1,r2              ;1858
0000b2  60c1              STR      r1,[r0,#0xc]          ;1858
                  |L42.180|
0000b4  6821              LDR      r1,[r4,#0]            ;1858
0000b6  2201              MOVS     r2,#1                 ;1858
0000b8  4610              MOV      r0,r2                 ;1858
0000ba  6a0b              LDR      r3,[r1,#0x20]         ;1858
0000bc  40a8              LSLS     r0,r0,r5              ;1858
0000be  4383              BICS     r3,r3,r0              ;1858
0000c0  620b              STR      r3,[r1,#0x20]         ;1858
0000c2  6a0b              LDR      r3,[r1,#0x20]         ;1858
0000c4  4303              ORRS     r3,r3,r0              ;1858
0000c6  620b              STR      r3,[r1,#0x20]         ;1858
0000c8  6820              LDR      r0,[r4,#0]            ;1870
0000ca  6801              LDR      r1,[r0,#0]            ;1870
0000cc  4311              ORRS     r1,r1,r2              ;1870
0000ce  6001              STR      r1,[r0,#0]            ;1870
0000d0  2000              MOVS     r0,#0                 ;1873
0000d2  bd70              POP      {r4-r6,pc}
;;;1875   
                          ENDP

                  |L42.212|
                          DCD      TIM_DMACaptureCplt
                  |L42.216|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_IC_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Start_IT PROC
;;;1652   */
;;;1653   HAL_StatusTypeDef HAL_TIM_IC_Start_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b410              PUSH     {r4}
;;;1654   {
;;;1655     /* Check the parameters */
;;;1656     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1657   
;;;1658     switch (Channel)
000002  6802              LDR      r2,[r0,#0]
000004  2900              CMP      r1,#0
000006  d006              BEQ      |L43.22|
000008  2904              CMP      r1,#4
00000a  d009              BEQ      |L43.32|
00000c  2908              CMP      r1,#8
00000e  d00c              BEQ      |L43.42|
000010  290c              CMP      r1,#0xc
000012  d113              BNE      |L43.60|
000014  e00e              B        |L43.52|
                  |L43.22|
;;;1659     {
;;;1660       case TIM_CHANNEL_1:
;;;1661       {
;;;1662         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1663         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000016  68d3              LDR      r3,[r2,#0xc]
000018  2402              MOVS     r4,#2
00001a  4323              ORRS     r3,r3,r4
00001c  60d3              STR      r3,[r2,#0xc]
;;;1664       }
;;;1665       break;
00001e  e00d              B        |L43.60|
                  |L43.32|
;;;1666   
;;;1667       case TIM_CHANNEL_2:
;;;1668       {
;;;1669         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1670         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000020  68d3              LDR      r3,[r2,#0xc]
000022  2404              MOVS     r4,#4
000024  4323              ORRS     r3,r3,r4
000026  60d3              STR      r3,[r2,#0xc]
;;;1671       }
;;;1672       break;
000028  e008              B        |L43.60|
                  |L43.42|
;;;1673   
;;;1674       case TIM_CHANNEL_3:
;;;1675       {
;;;1676         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1677         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
00002a  68d3              LDR      r3,[r2,#0xc]
00002c  2408              MOVS     r4,#8
00002e  4323              ORRS     r3,r3,r4
000030  60d3              STR      r3,[r2,#0xc]
;;;1678       }
;;;1679       break;
000032  e003              B        |L43.60|
                  |L43.52|
;;;1680   
;;;1681       case TIM_CHANNEL_4:
;;;1682       {
;;;1683         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1684         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000034  68d3              LDR      r3,[r2,#0xc]
000036  2410              MOVS     r4,#0x10
000038  4323              ORRS     r3,r3,r4
00003a  60d3              STR      r3,[r2,#0xc]
                  |L43.60|
00003c  2401              MOVS     r4,#1
00003e  4622              MOV      r2,r4
000040  6803              LDR      r3,[r0,#0]
000042  408a              LSLS     r2,r2,r1
000044  6a19              LDR      r1,[r3,#0x20]
000046  4391              BICS     r1,r1,r2
000048  6219              STR      r1,[r3,#0x20]
00004a  6a19              LDR      r1,[r3,#0x20]
00004c  4311              ORRS     r1,r1,r2
00004e  6219              STR      r1,[r3,#0x20]
;;;1685       }
;;;1686       break;
;;;1687   
;;;1688       default:
;;;1689       break;
;;;1690     }
;;;1691     /* Enable the Input Capture channel */
;;;1692     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1693   
;;;1694     /* Enable the Peripheral */
;;;1695     __HAL_TIM_ENABLE(htim);
000050  6800              LDR      r0,[r0,#0]
000052  6801              LDR      r1,[r0,#0]
000054  4321              ORRS     r1,r1,r4
000056  6001              STR      r1,[r0,#0]
;;;1696   
;;;1697     /* Return function status */
;;;1698     return HAL_OK;
;;;1699   }
000058  bc10              POP      {r4}
00005a  2000              MOVS     r0,#0                 ;1698
00005c  4770              BX       lr
;;;1700   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_IC_Stop PROC
;;;1626   */
;;;1627   HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b430              PUSH     {r4,r5}
000002  6802              LDR      r2,[r0,#0]
;;;1628   {
;;;1629     /* Check the parameters */
;;;1630     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1631   
;;;1632     /* Disable the Input Capture channel */
;;;1633     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000004  2400              MOVS     r4,#0
000006  2301              MOVS     r3,#1
000008  6a15              LDR      r5,[r2,#0x20]
00000a  408b              LSLS     r3,r3,r1
00000c  439d              BICS     r5,r5,r3
00000e  6215              STR      r5,[r2,#0x20]
000010  6a13              LDR      r3,[r2,#0x20]
000012  408c              LSLS     r4,r4,r1
000014  4323              ORRS     r3,r3,r4
000016  6213              STR      r3,[r2,#0x20]
;;;1634   
;;;1635     /* Disable the Peripheral */
;;;1636     __HAL_TIM_DISABLE(htim);
000018  6800              LDR      r0,[r0,#0]
00001a  6a01              LDR      r1,[r0,#0x20]
00001c  4a06              LDR      r2,|L44.56|
00001e  4211              TST      r1,r2
000020  d107              BNE      |L44.50|
000022  6a01              LDR      r1,[r0,#0x20]
000024  1092              ASRS     r2,r2,#2
000026  4211              TST      r1,r2
000028  d103              BNE      |L44.50|
00002a  6801              LDR      r1,[r0,#0]
00002c  0849              LSRS     r1,r1,#1
00002e  0049              LSLS     r1,r1,#1
000030  6001              STR      r1,[r0,#0]
                  |L44.50|
;;;1637   
;;;1638     /* Return function status */
;;;1639     return HAL_OK;
;;;1640   }
000032  bc30              POP      {r4,r5}
000034  2000              MOVS     r0,#0                 ;1639
000036  4770              BX       lr
;;;1641   
                          ENDP

                  |L44.56|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_IC_Stop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_IC_Stop_DMA PROC
;;;1886   */
;;;1887   HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b470              PUSH     {r4-r6}
;;;1888   {
;;;1889     /* Check the parameters */
;;;1890     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1891     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;1892   
;;;1893     switch (Channel)
000002  6802              LDR      r2,[r0,#0]
000004  2900              CMP      r1,#0
000006  d006              BEQ      |L45.22|
000008  2904              CMP      r1,#4
00000a  d00a              BEQ      |L45.34|
00000c  2908              CMP      r1,#8
00000e  d00e              BEQ      |L45.46|
000010  290c              CMP      r1,#0xc
000012  d117              BNE      |L45.68|
000014  e011              B        |L45.58|
                  |L45.22|
;;;1894     {
;;;1895       case TIM_CHANNEL_1:
;;;1896       {
;;;1897         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1898         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000016  68d3              LDR      r3,[r2,#0xc]
000018  2401              MOVS     r4,#1
00001a  0264              LSLS     r4,r4,#9
00001c  43a3              BICS     r3,r3,r4
00001e  60d3              STR      r3,[r2,#0xc]
;;;1899       }
;;;1900       break;
000020  e010              B        |L45.68|
                  |L45.34|
;;;1901   
;;;1902       case TIM_CHANNEL_2:
;;;1903       {
;;;1904         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1905         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000022  68d3              LDR      r3,[r2,#0xc]
000024  2401              MOVS     r4,#1
000026  02a4              LSLS     r4,r4,#10
000028  43a3              BICS     r3,r3,r4
00002a  60d3              STR      r3,[r2,#0xc]
;;;1906       }
;;;1907       break;
00002c  e00a              B        |L45.68|
                  |L45.46|
;;;1908   
;;;1909       case TIM_CHANNEL_3:
;;;1910       {
;;;1911         /* Disable the TIM Capture/Compare 3  DMA request */
;;;1912         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
00002e  68d3              LDR      r3,[r2,#0xc]
000030  2401              MOVS     r4,#1
000032  02e4              LSLS     r4,r4,#11
000034  43a3              BICS     r3,r3,r4
000036  60d3              STR      r3,[r2,#0xc]
;;;1913       }
;;;1914       break;
000038  e004              B        |L45.68|
                  |L45.58|
;;;1915   
;;;1916       case TIM_CHANNEL_4:
;;;1917       {
;;;1918         /* Disable the TIM Capture/Compare 4  DMA request */
;;;1919         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
00003a  68d3              LDR      r3,[r2,#0xc]
00003c  2401              MOVS     r4,#1
00003e  0324              LSLS     r4,r4,#12
000040  43a3              BICS     r3,r3,r4
000042  60d3              STR      r3,[r2,#0xc]
                  |L45.68|
000044  6802              LDR      r2,[r0,#0]
000046  2401              MOVS     r4,#1
;;;1920       }
;;;1921       break;
;;;1922   
;;;1923       default:
;;;1924       break;
;;;1925     }
;;;1926   
;;;1927     /* Disable the Input Capture channel */
;;;1928     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000048  2500              MOVS     r5,#0
00004a  4623              MOV      r3,r4
00004c  6a16              LDR      r6,[r2,#0x20]
00004e  408b              LSLS     r3,r3,r1
000050  439e              BICS     r6,r6,r3
000052  6216              STR      r6,[r2,#0x20]
000054  6a13              LDR      r3,[r2,#0x20]
000056  408d              LSLS     r5,r5,r1
000058  432b              ORRS     r3,r3,r5
00005a  6213              STR      r3,[r2,#0x20]
;;;1929   
;;;1930     /* Disable the Peripheral */
;;;1931     __HAL_TIM_DISABLE(htim);
00005c  6801              LDR      r1,[r0,#0]
00005e  6a0a              LDR      r2,[r1,#0x20]
000060  4b06              LDR      r3,|L45.124|
000062  421a              TST      r2,r3
000064  d106              BNE      |L45.116|
000066  6a0a              LDR      r2,[r1,#0x20]
000068  109b              ASRS     r3,r3,#2
00006a  421a              TST      r2,r3
00006c  d102              BNE      |L45.116|
00006e  680a              LDR      r2,[r1,#0]
000070  43a2              BICS     r2,r2,r4
000072  600a              STR      r2,[r1,#0]
                  |L45.116|
;;;1932   
;;;1933     /* Change the htim state */
;;;1934     htim->State = HAL_TIM_STATE_READY;
000074  6404              STR      r4,[r0,#0x40]
;;;1935   
;;;1936     /* Return function status */
;;;1937     return HAL_OK;
;;;1938   }
000076  bc70              POP      {r4-r6}
000078  2000              MOVS     r0,#0                 ;1937
00007a  4770              BX       lr
;;;1939   /**
                          ENDP

                  |L45.124|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_IC_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_IC_Stop_IT PROC
;;;1711   */
;;;1712   HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b430              PUSH     {r4,r5}
;;;1713   {
;;;1714     /* Check the parameters */
;;;1715     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1716   
;;;1717     switch (Channel)
000002  6802              LDR      r2,[r0,#0]
000004  2900              CMP      r1,#0
000006  d006              BEQ      |L46.22|
000008  2904              CMP      r1,#4
00000a  d009              BEQ      |L46.32|
00000c  2908              CMP      r1,#8
00000e  d00c              BEQ      |L46.42|
000010  290c              CMP      r1,#0xc
000012  d113              BNE      |L46.60|
000014  e00e              B        |L46.52|
                  |L46.22|
;;;1718     {
;;;1719       case TIM_CHANNEL_1:
;;;1720       {
;;;1721         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1722         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000016  68d3              LDR      r3,[r2,#0xc]
000018  2402              MOVS     r4,#2
00001a  43a3              BICS     r3,r3,r4
00001c  60d3              STR      r3,[r2,#0xc]
;;;1723       }
;;;1724       break;
00001e  e00d              B        |L46.60|
                  |L46.32|
;;;1725   
;;;1726       case TIM_CHANNEL_2:
;;;1727       {
;;;1728         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1729         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000020  68d3              LDR      r3,[r2,#0xc]
000022  2404              MOVS     r4,#4
000024  43a3              BICS     r3,r3,r4
000026  60d3              STR      r3,[r2,#0xc]
;;;1730       }
;;;1731       break;
000028  e008              B        |L46.60|
                  |L46.42|
;;;1732   
;;;1733       case TIM_CHANNEL_3:
;;;1734       {
;;;1735         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1736         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
00002a  68d3              LDR      r3,[r2,#0xc]
00002c  2408              MOVS     r4,#8
00002e  43a3              BICS     r3,r3,r4
000030  60d3              STR      r3,[r2,#0xc]
;;;1737       }
;;;1738       break;
000032  e003              B        |L46.60|
                  |L46.52|
;;;1739   
;;;1740       case TIM_CHANNEL_4:
;;;1741       {
;;;1742         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1743         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
000034  68d3              LDR      r3,[r2,#0xc]
000036  2410              MOVS     r4,#0x10
000038  43a3              BICS     r3,r3,r4
00003a  60d3              STR      r3,[r2,#0xc]
                  |L46.60|
00003c  6802              LDR      r2,[r0,#0]
;;;1744       }
;;;1745       break;
;;;1746   
;;;1747       default:
;;;1748       break;
;;;1749     }
;;;1750   
;;;1751     /* Disable the Input Capture channel */
;;;1752     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
00003e  2300              MOVS     r3,#0
000040  2401              MOVS     r4,#1
000042  6a15              LDR      r5,[r2,#0x20]
000044  408c              LSLS     r4,r4,r1
000046  43a5              BICS     r5,r5,r4
000048  6215              STR      r5,[r2,#0x20]
00004a  6a14              LDR      r4,[r2,#0x20]
00004c  408b              LSLS     r3,r3,r1
00004e  431c              ORRS     r4,r4,r3
000050  6214              STR      r4,[r2,#0x20]
;;;1753   
;;;1754     /* Disable the Peripheral */
;;;1755     __HAL_TIM_DISABLE(htim);
000052  6800              LDR      r0,[r0,#0]
000054  6a01              LDR      r1,[r0,#0x20]
000056  4a07              LDR      r2,|L46.116|
000058  4211              TST      r1,r2
00005a  d107              BNE      |L46.108|
00005c  6a01              LDR      r1,[r0,#0x20]
00005e  1092              ASRS     r2,r2,#2
000060  4211              TST      r1,r2
000062  d103              BNE      |L46.108|
000064  6801              LDR      r1,[r0,#0]
000066  0849              LSRS     r1,r1,#1
000068  0049              LSLS     r1,r1,#1
00006a  6001              STR      r1,[r0,#0]
                  |L46.108|
;;;1756   
;;;1757     /* Return function status */
;;;1758     return HAL_OK;
;;;1759   }
00006c  bc30              POP      {r4,r5}
00006e  2000              MOVS     r0,#0                 ;1758
000070  4770              BX       lr
;;;1760   
                          ENDP

000072  0000              DCW      0x0000
                  |L46.116|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IRQHandler PROC
;;;2768     */
;;;2769   void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
000000  b570              PUSH     {r4-r6,lr}
;;;2770   {
000002  4604              MOV      r4,r0
;;;2771     /* Capture compare 1 event */
;;;2772     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
000004  6800              LDR      r0,[r0,#0]
000006  6901              LDR      r1,[r0,#0x10]
000008  2500              MOVS     r5,#0
00000a  43c9              MVNS     r1,r1
00000c  0789              LSLS     r1,r1,#30
00000e  2900              CMP      r1,#0
000010  db15              BLT      |L47.62|
;;;2773     {
;;;2774       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
000012  68c1              LDR      r1,[r0,#0xc]
000014  43c9              MVNS     r1,r1
000016  0789              LSLS     r1,r1,#30
000018  d411              BMI      |L47.62|
;;;2775       {
;;;2776         {
;;;2777           __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
00001a  1ee9              SUBS     r1,r5,#3
00001c  6101              STR      r1,[r0,#0x10]
;;;2778           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
00001e  2001              MOVS     r0,#1
;;;2779   
;;;2780           /* Input capture event */
;;;2781           if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
000020  61e0              STR      r0,[r4,#0x1c]
000022  6820              LDR      r0,[r4,#0]
000024  6980              LDR      r0,[r0,#0x18]
000026  0780              LSLS     r0,r0,#30
;;;2782           {
;;;2783             HAL_TIM_IC_CaptureCallback(htim);
;;;2784           }
;;;2785           /* Output compare event */
;;;2786           else
;;;2787           {
;;;2788             HAL_TIM_OC_DelayElapsedCallback(htim);
000028  4620              MOV      r0,r4
00002a  d002              BEQ      |L47.50|
00002c  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
000030  e004              B        |L47.60|
                  |L47.50|
000032  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2789             HAL_TIM_PWM_PulseFinishedCallback(htim);
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L47.60|
;;;2790           }
;;;2791           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
00003c  61e5              STR      r5,[r4,#0x1c]
                  |L47.62|
;;;2792         }
;;;2793       }
;;;2794     }
;;;2795     /* Capture compare 2 event */
;;;2796     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
00003e  6820              LDR      r0,[r4,#0]
000040  6901              LDR      r1,[r0,#0x10]
000042  43c9              MVNS     r1,r1
000044  0749              LSLS     r1,r1,#29
000046  d417              BMI      |L47.120|
;;;2797     {
;;;2798       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
000048  68c1              LDR      r1,[r0,#0xc]
00004a  43c9              MVNS     r1,r1
00004c  0749              LSLS     r1,r1,#29
00004e  d413              BMI      |L47.120|
;;;2799       {
;;;2800         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
000050  2104              MOVS     r1,#4
000052  43c9              MVNS     r1,r1
000054  6101              STR      r1,[r0,#0x10]
;;;2801         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
000056  2002              MOVS     r0,#2
;;;2802         /* Input capture event */
;;;2803         if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
000058  61e0              STR      r0,[r4,#0x1c]
00005a  6820              LDR      r0,[r4,#0]
00005c  6980              LDR      r0,[r0,#0x18]
00005e  0580              LSLS     r0,r0,#22
000060  0f80              LSRS     r0,r0,#30
;;;2804         {
;;;2805           HAL_TIM_IC_CaptureCallback(htim);
;;;2806         }
;;;2807         /* Output compare event */
;;;2808         else
;;;2809         {
;;;2810           HAL_TIM_OC_DelayElapsedCallback(htim);
000062  4620              MOV      r0,r4
000064  d002              BEQ      |L47.108|
000066  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
00006a  e004              B        |L47.118|
                  |L47.108|
00006c  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2811           HAL_TIM_PWM_PulseFinishedCallback(htim);
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L47.118|
;;;2812         }
;;;2813         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000076  61e5              STR      r5,[r4,#0x1c]
                  |L47.120|
;;;2814       }
;;;2815     }
;;;2816     /* Capture compare 3 event */
;;;2817     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
000078  6820              LDR      r0,[r4,#0]
00007a  6901              LDR      r1,[r0,#0x10]
00007c  43c9              MVNS     r1,r1
00007e  0709              LSLS     r1,r1,#28
000080  d416              BMI      |L47.176|
;;;2818     {
;;;2819       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
000082  68c1              LDR      r1,[r0,#0xc]
000084  43c9              MVNS     r1,r1
000086  0709              LSLS     r1,r1,#28
000088  d412              BMI      |L47.176|
;;;2820       {
;;;2821         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
00008a  2108              MOVS     r1,#8
00008c  43c9              MVNS     r1,r1
00008e  6101              STR      r1,[r0,#0x10]
;;;2822         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000090  2004              MOVS     r0,#4
;;;2823         /* Input capture event */
;;;2824         if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
000092  61e0              STR      r0,[r4,#0x1c]
000094  6820              LDR      r0,[r4,#0]
000096  69c0              LDR      r0,[r0,#0x1c]
000098  0780              LSLS     r0,r0,#30
;;;2825         {
;;;2826           HAL_TIM_IC_CaptureCallback(htim);
;;;2827         }
;;;2828         /* Output compare event */
;;;2829         else
;;;2830         {
;;;2831           HAL_TIM_OC_DelayElapsedCallback(htim);
00009a  4620              MOV      r0,r4
00009c  d002              BEQ      |L47.164|
00009e  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
0000a2  e004              B        |L47.174|
                  |L47.164|
0000a4  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2832           HAL_TIM_PWM_PulseFinishedCallback(htim);
0000a8  4620              MOV      r0,r4
0000aa  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L47.174|
;;;2833         }
;;;2834         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
0000ae  61e5              STR      r5,[r4,#0x1c]
                  |L47.176|
;;;2835       }
;;;2836     }
;;;2837     /* Capture compare 4 event */
;;;2838     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
0000b0  6820              LDR      r0,[r4,#0]
0000b2  6901              LDR      r1,[r0,#0x10]
0000b4  43c9              MVNS     r1,r1
0000b6  06c9              LSLS     r1,r1,#27
0000b8  d417              BMI      |L47.234|
;;;2839     {
;;;2840       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
0000ba  68c1              LDR      r1,[r0,#0xc]
0000bc  43c9              MVNS     r1,r1
0000be  06c9              LSLS     r1,r1,#27
0000c0  d413              BMI      |L47.234|
;;;2841       {
;;;2842         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
0000c2  2110              MOVS     r1,#0x10
0000c4  43c9              MVNS     r1,r1
0000c6  6101              STR      r1,[r0,#0x10]
;;;2843         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
0000c8  2008              MOVS     r0,#8
;;;2844         /* Input capture event */
;;;2845         if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
0000ca  61e0              STR      r0,[r4,#0x1c]
0000cc  6820              LDR      r0,[r4,#0]
0000ce  69c0              LDR      r0,[r0,#0x1c]
0000d0  0580              LSLS     r0,r0,#22
0000d2  0f80              LSRS     r0,r0,#30
;;;2846         {
;;;2847           HAL_TIM_IC_CaptureCallback(htim);
;;;2848         }
;;;2849         /* Output compare event */
;;;2850         else
;;;2851         {
;;;2852           HAL_TIM_OC_DelayElapsedCallback(htim);
0000d4  4620              MOV      r0,r4
0000d6  d002              BEQ      |L47.222|
0000d8  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
0000dc  e004              B        |L47.232|
                  |L47.222|
0000de  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2853           HAL_TIM_PWM_PulseFinishedCallback(htim);
0000e2  4620              MOV      r0,r4
0000e4  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L47.232|
;;;2854         }
;;;2855         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
0000e8  61e5              STR      r5,[r4,#0x1c]
                  |L47.234|
;;;2856       }
;;;2857     }
;;;2858     /* TIM Update event */
;;;2859     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
0000ea  6820              LDR      r0,[r4,#0]
0000ec  6901              LDR      r1,[r0,#0x10]
0000ee  43c9              MVNS     r1,r1
0000f0  07c9              LSLS     r1,r1,#31
0000f2  d108              BNE      |L47.262|
;;;2860     {
;;;2861       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
0000f4  68c1              LDR      r1,[r0,#0xc]
0000f6  43c9              MVNS     r1,r1
0000f8  07c9              LSLS     r1,r1,#31
0000fa  d104              BNE      |L47.262|
;;;2862       {
;;;2863         __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
0000fc  1e89              SUBS     r1,r1,#2
0000fe  6101              STR      r1,[r0,#0x10]
;;;2864         HAL_TIM_PeriodElapsedCallback(htim);
000100  4620              MOV      r0,r4
000102  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
                  |L47.262|
;;;2865       }
;;;2866     }
;;;2867     /* TIM Break input event */
;;;2868     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
000106  6820              LDR      r0,[r4,#0]
000108  6901              LDR      r1,[r0,#0x10]
00010a  43c9              MVNS     r1,r1
00010c  0609              LSLS     r1,r1,#24
00010e  d409              BMI      |L47.292|
;;;2869     {
;;;2870       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
000110  68c1              LDR      r1,[r0,#0xc]
000112  43c9              MVNS     r1,r1
000114  0609              LSLS     r1,r1,#24
000116  d405              BMI      |L47.292|
;;;2871       {
;;;2872         __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
000118  2180              MOVS     r1,#0x80
00011a  43c9              MVNS     r1,r1
00011c  6101              STR      r1,[r0,#0x10]
;;;2873         HAL_TIMEx_BreakCallback(htim);
00011e  4620              MOV      r0,r4
000120  f7fffffe          BL       HAL_TIMEx_BreakCallback
                  |L47.292|
;;;2874       }
;;;2875     }
;;;2876     /* TIM Trigger detection event */
;;;2877     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
000124  6820              LDR      r0,[r4,#0]
000126  6901              LDR      r1,[r0,#0x10]
000128  43c9              MVNS     r1,r1
00012a  0649              LSLS     r1,r1,#25
00012c  d409              BMI      |L47.322|
;;;2878     {
;;;2879       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
00012e  68c1              LDR      r1,[r0,#0xc]
000130  43c9              MVNS     r1,r1
000132  0649              LSLS     r1,r1,#25
000134  d405              BMI      |L47.322|
;;;2880       {
;;;2881         __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
000136  2140              MOVS     r1,#0x40
000138  43c9              MVNS     r1,r1
00013a  6101              STR      r1,[r0,#0x10]
;;;2882         HAL_TIM_TriggerCallback(htim);
00013c  4620              MOV      r0,r4
00013e  f7fffffe          BL       HAL_TIM_TriggerCallback
                  |L47.322|
;;;2883       }
;;;2884     }
;;;2885     /* TIM commutation event */
;;;2886     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
000142  6820              LDR      r0,[r4,#0]
000144  6901              LDR      r1,[r0,#0x10]
000146  43c9              MVNS     r1,r1
000148  0689              LSLS     r1,r1,#26
00014a  d409              BMI      |L47.352|
;;;2887     {
;;;2888       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
00014c  68c1              LDR      r1,[r0,#0xc]
00014e  43c9              MVNS     r1,r1
000150  0689              LSLS     r1,r1,#26
000152  d405              BMI      |L47.352|
;;;2889       {
;;;2890         __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
000154  2120              MOVS     r1,#0x20
000156  43c9              MVNS     r1,r1
000158  6101              STR      r1,[r0,#0x10]
;;;2891         HAL_TIMEx_CommutationCallback(htim);
00015a  4620              MOV      r0,r4
00015c  f7fffffe          BL       HAL_TIMEx_CommutationCallback
                  |L47.352|
;;;2892       }
;;;2893     }
;;;2894   }
000160  bd70              POP      {r4-r6,pc}
;;;2895   
                          ENDP


                          AREA ||i.HAL_TIM_OC_ConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_ConfigChannel PROC
;;;2931     */
;;;2932   HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2933   {
000002  4604              MOV      r4,r0
;;;2934     /* Check the parameters */
;;;2935     assert_param(IS_TIM_CHANNELS(Channel));
;;;2936     assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
;;;2937     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;2938   
;;;2939     /* Check input state */
;;;2940     __HAL_LOCK(htim);
000004  6bc0              LDR      r0,[r0,#0x3c]
000006  2801              CMP      r0,#1
000008  d00d              BEQ      |L48.38|
00000a  2001              MOVS     r0,#1
;;;2941   
;;;2942     htim->State = HAL_TIM_STATE_BUSY;
00000c  63e0              STR      r0,[r4,#0x3c]
00000e  2002              MOVS     r0,#2
000010  6420              STR      r0,[r4,#0x40]
;;;2943   
;;;2944     switch (Channel)
000012  2a00              CMP      r2,#0
000014  d009              BEQ      |L48.42|
000016  2a04              CMP      r2,#4
000018  d00b              BEQ      |L48.50|
00001a  4d39              LDR      r5,|L48.256|
00001c  2a08              CMP      r2,#8
00001e  d00c              BEQ      |L48.58|
000020  2a0c              CMP      r2,#0xc
000022  d168              BNE      |L48.246|
000024  e03f              B        |L48.166|
                  |L48.38|
000026  2002              MOVS     r0,#2                 ;2940
;;;2945     {
;;;2946       case TIM_CHANNEL_1:
;;;2947       {
;;;2948         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;2949         /* Configure the TIM Channel 1 in Output Compare */
;;;2950         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;2951       }
;;;2952       break;
;;;2953   
;;;2954       case TIM_CHANNEL_2:
;;;2955       {
;;;2956         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2957         /* Configure the TIM Channel 2 in Output Compare */
;;;2958         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;2959       }
;;;2960       break;
;;;2961   
;;;2962       case TIM_CHANNEL_3:
;;;2963       {
;;;2964          assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;2965         /* Configure the TIM Channel 3 in Output Compare */
;;;2966         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;2967       }
;;;2968       break;
;;;2969   
;;;2970       case TIM_CHANNEL_4:
;;;2971       {
;;;2972         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;2973          /* Configure the TIM Channel 4 in Output Compare */
;;;2974          TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;2975       }
;;;2976       break;
;;;2977   
;;;2978       default:
;;;2979       break;
;;;2980     }
;;;2981     htim->State = HAL_TIM_STATE_READY;
;;;2982   
;;;2983     __HAL_UNLOCK(htim);
;;;2984   
;;;2985     return HAL_OK;
;;;2986   }
000028  bdf8              POP      {r3-r7,pc}
                  |L48.42|
00002a  6820              LDR      r0,[r4,#0]            ;2950
00002c  f7fffffe          BL       TIM_OC1_SetConfig
000030  e061              B        |L48.246|
                  |L48.50|
000032  6820              LDR      r0,[r4,#0]            ;2958
000034  f7fffffe          BL       TIM_OC2_SetConfig
000038  e05d              B        |L48.246|
                  |L48.58|
00003a  6822              LDR      r2,[r4,#0]            ;2960
00003c  6a10              LDR      r0,[r2,#0x20]         ;2960
00003e  23ff              MOVS     r3,#0xff              ;2960
000040  3301              ADDS     r3,#1                 ;2960
000042  4398              BICS     r0,r0,r3              ;2960
000044  6210              STR      r0,[r2,#0x20]         ;2960
000046  6a16              LDR      r6,[r2,#0x20]         ;2960
000048  6850              LDR      r0,[r2,#4]            ;2960
00004a  69d3              LDR      r3,[r2,#0x1c]         ;2960
00004c  2770              MOVS     r7,#0x70              ;2960
00004e  43bb              BICS     r3,r3,r7              ;2960
000050  089b              LSRS     r3,r3,#2              ;2960
000052  680f              LDR      r7,[r1,#0]            ;2960
000054  009b              LSLS     r3,r3,#2              ;2960
000056  431f              ORRS     r7,r7,r3              ;2960
000058  2301              MOVS     r3,#1                 ;2960
00005a  025b              LSLS     r3,r3,#9              ;2960
00005c  439e              BICS     r6,r6,r3              ;2960
00005e  688b              LDR      r3,[r1,#8]            ;2960
000060  021b              LSLS     r3,r3,#8              ;2960
000062  4333              ORRS     r3,r3,r6              ;2960
000064  42aa              CMP      r2,r5                 ;2960
000066  d109              BNE      |L48.124|
000068  2501              MOVS     r5,#1                 ;2960
00006a  02ed              LSLS     r5,r5,#11             ;2960
00006c  43ab              BICS     r3,r3,r5              ;2960
00006e  68cd              LDR      r5,[r1,#0xc]          ;2960
000070  2601              MOVS     r6,#1                 ;2960
000072  022d              LSLS     r5,r5,#8              ;2960
000074  432b              ORRS     r3,r3,r5              ;2960
000076  02b6              LSLS     r6,r6,#10             ;2960
000078  43b3              BICS     r3,r3,r6              ;2960
00007a  e005              B        |L48.136|
                  |L48.124|
00007c  4d21              LDR      r5,|L48.260|
00007e  42aa              CMP      r2,r5                 ;2960
000080  d002              BEQ      |L48.136|
000082  4d21              LDR      r5,|L48.264|
000084  42aa              CMP      r2,r5                 ;2960
000086  d108              BNE      |L48.154|
                  |L48.136|
000088  2503              MOVS     r5,#3                 ;2960
00008a  032d              LSLS     r5,r5,#12             ;2960
00008c  43a8              BICS     r0,r0,r5              ;2960
00008e  694d              LDR      r5,[r1,#0x14]         ;2960
000090  012d              LSLS     r5,r5,#4              ;2960
000092  4305              ORRS     r5,r5,r0              ;2960
000094  6988              LDR      r0,[r1,#0x18]         ;2960
000096  0100              LSLS     r0,r0,#4              ;2960
000098  4328              ORRS     r0,r0,r5              ;2960
                  |L48.154|
00009a  6050              STR      r0,[r2,#4]            ;2960
00009c  61d7              STR      r7,[r2,#0x1c]         ;2960
00009e  6848              LDR      r0,[r1,#4]            ;2960
0000a0  63d0              STR      r0,[r2,#0x3c]         ;2960
0000a2  6213              STR      r3,[r2,#0x20]         ;2960
0000a4  e027              B        |L48.246|
                  |L48.166|
0000a6  6822              LDR      r2,[r4,#0]            ;2968
0000a8  6a13              LDR      r3,[r2,#0x20]         ;2968
0000aa  2001              MOVS     r0,#1                 ;2968
0000ac  0300              LSLS     r0,r0,#12             ;2968
0000ae  4383              BICS     r3,r3,r0              ;2968
0000b0  6213              STR      r3,[r2,#0x20]         ;2968
0000b2  6a16              LDR      r6,[r2,#0x20]         ;2968
0000b4  6853              LDR      r3,[r2,#4]            ;2968
0000b6  69d0              LDR      r0,[r2,#0x1c]         ;2968
0000b8  2773              MOVS     r7,#0x73              ;2968
0000ba  023f              LSLS     r7,r7,#8              ;2968
0000bc  43b8              BICS     r0,r0,r7              ;2968
0000be  680f              LDR      r7,[r1,#0]            ;2968
0000c0  023f              LSLS     r7,r7,#8              ;2968
0000c2  4307              ORRS     r7,r7,r0              ;2968
0000c4  2001              MOVS     r0,#1                 ;2968
0000c6  0340              LSLS     r0,r0,#13             ;2968
0000c8  4386              BICS     r6,r6,r0              ;2968
0000ca  6888              LDR      r0,[r1,#8]            ;2968
0000cc  0300              LSLS     r0,r0,#12             ;2968
0000ce  4330              ORRS     r0,r0,r6              ;2968
0000d0  42aa              CMP      r2,r5                 ;2968
0000d2  d005              BEQ      |L48.224|
0000d4  4d0b              LDR      r5,|L48.260|
0000d6  42aa              CMP      r2,r5                 ;2974
0000d8  d002              BEQ      |L48.224|
0000da  4d0b              LDR      r5,|L48.264|
0000dc  42aa              CMP      r2,r5                 ;2974
0000de  d105              BNE      |L48.236|
                  |L48.224|
0000e0  2501              MOVS     r5,#1                 ;2974
0000e2  03ad              LSLS     r5,r5,#14             ;2974
0000e4  43ab              BICS     r3,r3,r5              ;2974
0000e6  694d              LDR      r5,[r1,#0x14]         ;2974
0000e8  01ad              LSLS     r5,r5,#6              ;2974
0000ea  432b              ORRS     r3,r3,r5              ;2974
                  |L48.236|
0000ec  6053              STR      r3,[r2,#4]            ;2974
0000ee  61d7              STR      r7,[r2,#0x1c]         ;2974
0000f0  6849              LDR      r1,[r1,#4]            ;2974
0000f2  6411              STR      r1,[r2,#0x40]         ;2974
0000f4  6210              STR      r0,[r2,#0x20]         ;2974
                  |L48.246|
0000f6  2001              MOVS     r0,#1                 ;2981
0000f8  6420              STR      r0,[r4,#0x40]         ;2981
0000fa  2000              MOVS     r0,#0                 ;2983
0000fc  63e0              STR      r0,[r4,#0x3c]         ;2983
0000fe  bdf8              POP      {r3-r7,pc}
;;;2987   
                          ENDP

                  |L48.256|
                          DCD      0x40012c00
                  |L48.260|
                          DCD      0x40014400
                  |L48.264|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_OC_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_DeInit PROC
;;;520      */
;;;521    HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;522    {
000002  4604              MOV      r4,r0
;;;523      /* Check the parameters */
;;;524      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;525    
;;;526       htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  6420              STR      r0,[r4,#0x40]
;;;527    
;;;528      /* Disable the TIM Peripheral Clock */
;;;529      __HAL_TIM_DISABLE(htim);
000008  6820              LDR      r0,[r4,#0]
00000a  6a01              LDR      r1,[r0,#0x20]
00000c  4a08              LDR      r2,|L49.48|
00000e  4211              TST      r1,r2
000010  d107              BNE      |L49.34|
000012  6a01              LDR      r1,[r0,#0x20]
000014  1092              ASRS     r2,r2,#2
000016  4211              TST      r1,r2
000018  d103              BNE      |L49.34|
00001a  6801              LDR      r1,[r0,#0]
00001c  0849              LSRS     r1,r1,#1
00001e  0049              LSLS     r1,r1,#1
000020  6001              STR      r1,[r0,#0]
                  |L49.34|
;;;530    
;;;531      /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;532      HAL_TIM_OC_MspDeInit(htim);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       HAL_TIM_OC_MspDeInit
;;;533    
;;;534      /* Change TIM state */
;;;535      htim->State = HAL_TIM_STATE_RESET;
000028  2000              MOVS     r0,#0
00002a  6420              STR      r0,[r4,#0x40]
;;;536    
;;;537      /* Release Lock */
;;;538      __HAL_UNLOCK(htim);
00002c  63e0              STR      r0,[r4,#0x3c]
;;;539    
;;;540      return HAL_OK;
;;;541    }
00002e  bd10              POP      {r4,pc}
;;;542    
                          ENDP

                  |L49.48|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_OC_DelayElapsedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_DelayElapsedCallback PROC
;;;4399     */
;;;4400   __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4401   {
;;;4402     /* Prevent unused argument(s) compilation warning */
;;;4403     UNUSED(htim);
;;;4404   
;;;4405     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4406               the __HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
;;;4407      */
;;;4408   }
;;;4409   /**
                          ENDP


                          AREA ||i.HAL_TIM_OC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_GetState PROC
;;;4502     */
;;;4503   HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
000000  6c00              LDR      r0,[r0,#0x40]
;;;4504   {
;;;4505     return htim->State;
;;;4506   }
000002  4770              BX       lr
;;;4507   
                          ENDP


                          AREA ||i.HAL_TIM_OC_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_Init PROC
;;;480      */
;;;481    HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef* htim)
000000  2800              CMP      r0,#0
;;;482    {
;;;483      /* Check the TIM handle allocation */
;;;484      if(htim == NULL)
000002  d101              BNE      |L52.8|
;;;485      {
;;;486        return HAL_ERROR;
000004  2001              MOVS     r0,#1
;;;487      }
;;;488    
;;;489      /* Check the parameters */
;;;490      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;491      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;492      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;493      assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;494    
;;;495      if(htim->State == HAL_TIM_STATE_RESET)
;;;496      {
;;;497        /* Allocate lock resource and initialize it */
;;;498        htim->Lock = HAL_UNLOCKED;
;;;499    
;;;500        /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;501        HAL_TIM_OC_MspInit(htim);
;;;502      }
;;;503    
;;;504      /* Set the TIM state */
;;;505      htim->State= HAL_TIM_STATE_BUSY;
;;;506    
;;;507      /* Init the base time for the Output Compare */
;;;508      TIM_Base_SetConfig(htim->Instance,  &htim->Init);
;;;509    
;;;510      /* Initialize the TIM state*/
;;;511      htim->State= HAL_TIM_STATE_READY;
;;;512    
;;;513      return HAL_OK;
;;;514    }
000006  4770              BX       lr
                  |L52.8|
000008  b510              PUSH     {r4,lr}               ;482
00000a  4604              MOV      r4,r0                 ;482
00000c  6c00              LDR      r0,[r0,#0x40]         ;495
00000e  2800              CMP      r0,#0                 ;495
000010  d103              BNE      |L52.26|
000012  63e0              STR      r0,[r4,#0x3c]         ;501
000014  4620              MOV      r0,r4                 ;501
000016  f7fffffe          BL       HAL_TIM_OC_MspInit
                  |L52.26|
00001a  2002              MOVS     r0,#2                 ;505
00001c  6420              STR      r0,[r4,#0x40]         ;505
00001e  1d21              ADDS     r1,r4,#4              ;508
000020  6820              LDR      r0,[r4,#0]            ;508
000022  f7fffffe          BL       TIM_Base_SetConfig
000026  2001              MOVS     r0,#1                 ;511
000028  6420              STR      r0,[r4,#0x40]         ;511
00002a  2000              MOVS     r0,#0                 ;513
00002c  bd10              POP      {r4,pc}
;;;515    
                          ENDP


                          AREA ||i.HAL_TIM_OC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_MspDeInit PROC
;;;562      */
;;;563    __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;564    {
;;;565      /* Prevent unused argument(s) compilation warning */
;;;566      UNUSED(htim);
;;;567    
;;;568      /* NOTE : This function Should not be modified, when the callback is needed,
;;;569                the HAL_TIM_OC_MspDeInit could be implemented in the user file
;;;570       */
;;;571    }
;;;572    
                          ENDP


                          AREA ||i.HAL_TIM_OC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_MspInit PROC
;;;547      */
;;;548    __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;549    {
;;;550      /* Prevent unused argument(s) compilation warning */
;;;551      UNUSED(htim);
;;;552    
;;;553      /* NOTE : This function Should not be modified, when the callback is needed,
;;;554                the HAL_TIM_OC_MspInit could be implemented in the user file
;;;555       */
;;;556    }
;;;557    
                          ENDP


                          AREA ||i.HAL_TIM_OC_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start PROC
;;;583    */
;;;584    HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b410              PUSH     {r4}
000002  2401              MOVS     r4,#1
000004  4622              MOV      r2,r4
000006  6803              LDR      r3,[r0,#0]
000008  408a              LSLS     r2,r2,r1
00000a  6a19              LDR      r1,[r3,#0x20]
00000c  4391              BICS     r1,r1,r2
00000e  6219              STR      r1,[r3,#0x20]
000010  6a19              LDR      r1,[r3,#0x20]
000012  4311              ORRS     r1,r1,r2
000014  6219              STR      r1,[r3,#0x20]
;;;585    {
;;;586      /* Check the parameters */
;;;587      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;588    
;;;589      /* Enable the Output compare channel */
;;;590      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;591    
;;;592      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000016  4a0b              LDR      r2,|L55.68|
000018  6801              LDR      r1,[r0,#0]
00001a  4291              CMP      r1,r2
00001c  d005              BEQ      |L55.42|
00001e  4a0a              LDR      r2,|L55.72|
000020  4291              CMP      r1,r2
000022  d002              BEQ      |L55.42|
000024  4a09              LDR      r2,|L55.76|
000026  4291              CMP      r1,r2
000028  d104              BNE      |L55.52|
                  |L55.42|
;;;593      {
;;;594        /* Enable the main output */
;;;595        __HAL_TIM_MOE_ENABLE(htim);
00002a  6c4a              LDR      r2,[r1,#0x44]
00002c  2301              MOVS     r3,#1
00002e  03db              LSLS     r3,r3,#15
000030  431a              ORRS     r2,r2,r3
000032  644a              STR      r2,[r1,#0x44]
                  |L55.52|
;;;596      }
;;;597    
;;;598      /* Enable the Peripheral */
;;;599      __HAL_TIM_ENABLE(htim);
000034  6800              LDR      r0,[r0,#0]
000036  6801              LDR      r1,[r0,#0]
000038  4321              ORRS     r1,r1,r4
00003a  6001              STR      r1,[r0,#0]
;;;600    
;;;601      /* Return function status */
;;;602      return HAL_OK;
;;;603    }
00003c  bc10              POP      {r4}
00003e  2000              MOVS     r0,#0                 ;602
000040  4770              BX       lr
;;;604    
                          ENDP

000042  0000              DCW      0x0000
                  |L55.68|
                          DCD      0x40012c00
                  |L55.72|
                          DCD      0x40014400
                  |L55.76|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_OC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start_DMA PROC
;;;781    */
;;;782    HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;783    {
000002  4604              MOV      r4,r0
;;;784      /* Check the parameters */
;;;785      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;786    
;;;787      if((htim->State == HAL_TIM_STATE_BUSY))
000004  6c00              LDR      r0,[r0,#0x40]
000006  4616              MOV      r6,r2                 ;783
000008  460d              MOV      r5,r1                 ;783
00000a  2802              CMP      r0,#2
00000c  d006              BEQ      |L56.28|
;;;788      {
;;;789         return HAL_BUSY;
;;;790      }
;;;791      else if((htim->State == HAL_TIM_STATE_READY))
00000e  6c20              LDR      r0,[r4,#0x40]
000010  2801              CMP      r0,#1
000012  d106              BNE      |L56.34|
;;;792      {
;;;793        if(((uint32_t)pData == 0U ) && (Length > 0U))
000014  2e00              CMP      r6,#0
000016  d102              BNE      |L56.30|
000018  2b00              CMP      r3,#0
00001a  d000              BEQ      |L56.30|
                  |L56.28|
;;;794        {
;;;795          return HAL_ERROR;
;;;796        }
;;;797        else
;;;798        {
;;;799          htim->State = HAL_TIM_STATE_BUSY;
;;;800        }
;;;801      }
;;;802      switch (Channel)
;;;803      {
;;;804        case TIM_CHANNEL_1:
;;;805        {
;;;806          /* Set the DMA Period elapsed callback */
;;;807          htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;808    
;;;809          /* Set the DMA error callback */
;;;810          htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;811    
;;;812          /* Enable the DMA channel */
;;;813          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;814    
;;;815          /* Enable the TIM Capture/Compare 1 DMA request */
;;;816          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;817        }
;;;818        break;
;;;819    
;;;820        case TIM_CHANNEL_2:
;;;821        {
;;;822          /* Set the DMA Period elapsed callback */
;;;823          htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;824    
;;;825          /* Set the DMA error callback */
;;;826          htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;827    
;;;828          /* Enable the DMA channel */
;;;829          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;830    
;;;831          /* Enable the TIM Capture/Compare 2 DMA request */
;;;832          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;833        }
;;;834        break;
;;;835    
;;;836        case TIM_CHANNEL_3:
;;;837        {
;;;838          /* Set the DMA Period elapsed callback */
;;;839          htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;840    
;;;841          /* Set the DMA error callback */
;;;842          htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;843    
;;;844          /* Enable the DMA channel */
;;;845          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;846    
;;;847          /* Enable the TIM Capture/Compare 3 DMA request */
;;;848          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;849        }
;;;850        break;
;;;851    
;;;852        case TIM_CHANNEL_4:
;;;853        {
;;;854         /* Set the DMA Period elapsed callback */
;;;855          htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;856    
;;;857          /* Set the DMA error callback */
;;;858          htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;859    
;;;860          /* Enable the DMA channel */
;;;861          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;862    
;;;863          /* Enable the TIM Capture/Compare 4 DMA request */
;;;864          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;865        }
;;;866        break;
;;;867    
;;;868        default:
;;;869        break;
;;;870      }
;;;871    
;;;872      /* Enable the Output compare channel */
;;;873      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;874    
;;;875      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;876      {
;;;877        /* Enable the main output */
;;;878        __HAL_TIM_MOE_ENABLE(htim);
;;;879      }
;;;880    
;;;881      /* Enable the Peripheral */
;;;882      __HAL_TIM_ENABLE(htim);
;;;883    
;;;884      /* Return function status */
;;;885      return HAL_OK;
;;;886    }
00001c  bd70              POP      {r4-r6,pc}
                  |L56.30|
00001e  2002              MOVS     r0,#2                 ;799
000020  6420              STR      r0,[r4,#0x40]         ;799
                  |L56.34|
000022  4836              LDR      r0,|L56.252|
000024  4936              LDR      r1,|L56.256|
000026  2d00              CMP      r5,#0                 ;802
000028  d006              BEQ      |L56.56|
00002a  2d04              CMP      r5,#4                 ;802
00002c  d015              BEQ      |L56.90|
00002e  2d08              CMP      r5,#8                 ;802
000030  d024              BEQ      |L56.124|
000032  2d0c              CMP      r5,#0xc               ;802
000034  d143              BNE      |L56.190|
000036  e032              B        |L56.158|
                  |L56.56|
000038  6a62              LDR      r2,[r4,#0x24]         ;807
00003a  62d0              STR      r0,[r2,#0x2c]         ;810
00003c  6a60              LDR      r0,[r4,#0x24]         ;810
00003e  6341              STR      r1,[r0,#0x34]         ;813
000040  6822              LDR      r2,[r4,#0]            ;813
000042  4631              MOV      r1,r6                 ;813
000044  3234              ADDS     r2,r2,#0x34           ;813
000046  6a60              LDR      r0,[r4,#0x24]         ;813
000048  f7fffffe          BL       HAL_DMA_Start_IT
00004c  6820              LDR      r0,[r4,#0]            ;816
00004e  68c1              LDR      r1,[r0,#0xc]          ;816
000050  2201              MOVS     r2,#1                 ;816
000052  0252              LSLS     r2,r2,#9              ;816
000054  4311              ORRS     r1,r1,r2              ;816
000056  60c1              STR      r1,[r0,#0xc]          ;816
000058  e031              B        |L56.190|
                  |L56.90|
00005a  6aa2              LDR      r2,[r4,#0x28]         ;823
00005c  62d0              STR      r0,[r2,#0x2c]         ;826
00005e  6aa0              LDR      r0,[r4,#0x28]         ;826
000060  6341              STR      r1,[r0,#0x34]         ;829
000062  6822              LDR      r2,[r4,#0]            ;829
000064  4631              MOV      r1,r6                 ;829
000066  3238              ADDS     r2,r2,#0x38           ;829
000068  6aa0              LDR      r0,[r4,#0x28]         ;829
00006a  f7fffffe          BL       HAL_DMA_Start_IT
00006e  6820              LDR      r0,[r4,#0]            ;832
000070  68c1              LDR      r1,[r0,#0xc]          ;832
000072  2201              MOVS     r2,#1                 ;832
000074  0292              LSLS     r2,r2,#10             ;832
000076  4311              ORRS     r1,r1,r2              ;832
000078  60c1              STR      r1,[r0,#0xc]          ;832
00007a  e020              B        |L56.190|
                  |L56.124|
00007c  6ae2              LDR      r2,[r4,#0x2c]         ;839
00007e  62d0              STR      r0,[r2,#0x2c]         ;842
000080  6ae0              LDR      r0,[r4,#0x2c]         ;842
000082  6341              STR      r1,[r0,#0x34]         ;845
000084  6822              LDR      r2,[r4,#0]            ;845
000086  4631              MOV      r1,r6                 ;845
000088  323c              ADDS     r2,r2,#0x3c           ;845
00008a  6ae0              LDR      r0,[r4,#0x2c]         ;845
00008c  f7fffffe          BL       HAL_DMA_Start_IT
000090  6820              LDR      r0,[r4,#0]            ;848
000092  68c1              LDR      r1,[r0,#0xc]          ;848
000094  2201              MOVS     r2,#1                 ;848
000096  02d2              LSLS     r2,r2,#11             ;848
000098  4311              ORRS     r1,r1,r2              ;848
00009a  60c1              STR      r1,[r0,#0xc]          ;848
00009c  e00f              B        |L56.190|
                  |L56.158|
00009e  6b22              LDR      r2,[r4,#0x30]         ;855
0000a0  62d0              STR      r0,[r2,#0x2c]         ;858
0000a2  6b20              LDR      r0,[r4,#0x30]         ;858
0000a4  6341              STR      r1,[r0,#0x34]         ;861
0000a6  6822              LDR      r2,[r4,#0]            ;861
0000a8  4631              MOV      r1,r6                 ;861
0000aa  3240              ADDS     r2,r2,#0x40           ;861
0000ac  6b20              LDR      r0,[r4,#0x30]         ;861
0000ae  f7fffffe          BL       HAL_DMA_Start_IT
0000b2  6820              LDR      r0,[r4,#0]            ;864
0000b4  68c1              LDR      r1,[r0,#0xc]          ;864
0000b6  2201              MOVS     r2,#1                 ;864
0000b8  0312              LSLS     r2,r2,#12             ;864
0000ba  4311              ORRS     r1,r1,r2              ;864
0000bc  60c1              STR      r1,[r0,#0xc]          ;864
                  |L56.190|
0000be  6821              LDR      r1,[r4,#0]            ;864
0000c0  2201              MOVS     r2,#1                 ;864
0000c2  4610              MOV      r0,r2                 ;864
0000c4  6a0b              LDR      r3,[r1,#0x20]         ;864
0000c6  40a8              LSLS     r0,r0,r5              ;864
0000c8  4383              BICS     r3,r3,r0              ;864
0000ca  620b              STR      r3,[r1,#0x20]         ;864
0000cc  6a0b              LDR      r3,[r1,#0x20]         ;864
0000ce  4303              ORRS     r3,r3,r0              ;864
0000d0  620b              STR      r3,[r1,#0x20]         ;864
0000d2  480c              LDR      r0,|L56.260|
0000d4  6821              LDR      r1,[r4,#0]            ;875
0000d6  4281              CMP      r1,r0                 ;875
0000d8  d005              BEQ      |L56.230|
0000da  480b              LDR      r0,|L56.264|
0000dc  4281              CMP      r1,r0                 ;875
0000de  d002              BEQ      |L56.230|
0000e0  480a              LDR      r0,|L56.268|
0000e2  4281              CMP      r1,r0                 ;875
0000e4  d104              BNE      |L56.240|
                  |L56.230|
0000e6  6c48              LDR      r0,[r1,#0x44]         ;878
0000e8  2301              MOVS     r3,#1                 ;878
0000ea  03db              LSLS     r3,r3,#15             ;878
0000ec  4318              ORRS     r0,r0,r3              ;878
0000ee  6448              STR      r0,[r1,#0x44]         ;878
                  |L56.240|
0000f0  6820              LDR      r0,[r4,#0]            ;882
0000f2  6801              LDR      r1,[r0,#0]            ;882
0000f4  4311              ORRS     r1,r1,r2              ;882
0000f6  6001              STR      r1,[r0,#0]            ;882
0000f8  2000              MOVS     r0,#0                 ;885
0000fa  bd70              POP      {r4-r6,pc}
;;;887    
                          ENDP

                  |L56.252|
                          DCD      TIM_DMADelayPulseCplt
                  |L56.256|
                          DCD      TIM_DMAError
                  |L56.260|
                          DCD      0x40012c00
                  |L56.264|
                          DCD      0x40014400
                  |L56.268|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_OC_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start_IT PROC
;;;647    */
;;;648    HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b410              PUSH     {r4}
;;;649    {
;;;650      /* Check the parameters */
;;;651      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;652    
;;;653      switch (Channel)
000002  6802              LDR      r2,[r0,#0]
000004  2900              CMP      r1,#0
000006  d006              BEQ      |L57.22|
000008  2904              CMP      r1,#4
00000a  d009              BEQ      |L57.32|
00000c  2908              CMP      r1,#8
00000e  d00c              BEQ      |L57.42|
000010  290c              CMP      r1,#0xc
000012  d113              BNE      |L57.60|
000014  e00e              B        |L57.52|
                  |L57.22|
;;;654      {
;;;655        case TIM_CHANNEL_1:
;;;656        {
;;;657          /* Enable the TIM Capture/Compare 1 interrupt */
;;;658          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000016  68d3              LDR      r3,[r2,#0xc]
000018  2402              MOVS     r4,#2
00001a  4323              ORRS     r3,r3,r4
00001c  60d3              STR      r3,[r2,#0xc]
;;;659        }
;;;660        break;
00001e  e00d              B        |L57.60|
                  |L57.32|
;;;661    
;;;662        case TIM_CHANNEL_2:
;;;663        {
;;;664          /* Enable the TIM Capture/Compare 2 interrupt */
;;;665          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000020  68d3              LDR      r3,[r2,#0xc]
000022  2404              MOVS     r4,#4
000024  4323              ORRS     r3,r3,r4
000026  60d3              STR      r3,[r2,#0xc]
;;;666        }
;;;667        break;
000028  e008              B        |L57.60|
                  |L57.42|
;;;668    
;;;669        case TIM_CHANNEL_3:
;;;670        {
;;;671          /* Enable the TIM Capture/Compare 3 interrupt */
;;;672          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
00002a  68d3              LDR      r3,[r2,#0xc]
00002c  2408              MOVS     r4,#8
00002e  4323              ORRS     r3,r3,r4
000030  60d3              STR      r3,[r2,#0xc]
;;;673        }
;;;674        break;
000032  e003              B        |L57.60|
                  |L57.52|
;;;675    
;;;676        case TIM_CHANNEL_4:
;;;677        {
;;;678          /* Enable the TIM Capture/Compare 4 interrupt */
;;;679          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000034  68d3              LDR      r3,[r2,#0xc]
000036  2410              MOVS     r4,#0x10
000038  4323              ORRS     r3,r3,r4
00003a  60d3              STR      r3,[r2,#0xc]
                  |L57.60|
00003c  2401              MOVS     r4,#1
00003e  4622              MOV      r2,r4
000040  6803              LDR      r3,[r0,#0]
000042  408a              LSLS     r2,r2,r1
000044  6a19              LDR      r1,[r3,#0x20]
000046  4391              BICS     r1,r1,r2
000048  6219              STR      r1,[r3,#0x20]
00004a  6a19              LDR      r1,[r3,#0x20]
00004c  4311              ORRS     r1,r1,r2
00004e  6219              STR      r1,[r3,#0x20]
;;;680        }
;;;681        break;
;;;682    
;;;683        default:
;;;684        break;
;;;685      }
;;;686    
;;;687      /* Enable the Output compare channel */
;;;688      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;689    
;;;690      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000050  4a0a              LDR      r2,|L57.124|
000052  6801              LDR      r1,[r0,#0]
000054  4291              CMP      r1,r2
000056  d005              BEQ      |L57.100|
000058  4a09              LDR      r2,|L57.128|
00005a  4291              CMP      r1,r2
00005c  d002              BEQ      |L57.100|
00005e  4a09              LDR      r2,|L57.132|
000060  4291              CMP      r1,r2
000062  d104              BNE      |L57.110|
                  |L57.100|
;;;691      {
;;;692        /* Enable the main output */
;;;693        __HAL_TIM_MOE_ENABLE(htim);
000064  6c4a              LDR      r2,[r1,#0x44]
000066  2301              MOVS     r3,#1
000068  03db              LSLS     r3,r3,#15
00006a  431a              ORRS     r2,r2,r3
00006c  644a              STR      r2,[r1,#0x44]
                  |L57.110|
;;;694      }
;;;695    
;;;696      /* Enable the Peripheral */
;;;697      __HAL_TIM_ENABLE(htim);
00006e  6800              LDR      r0,[r0,#0]
000070  6801              LDR      r1,[r0,#0]
000072  4321              ORRS     r1,r1,r4
000074  6001              STR      r1,[r0,#0]
;;;698    
;;;699      /* Return function status */
;;;700      return HAL_OK;
;;;701    }
000076  bc10              POP      {r4}
000078  2000              MOVS     r0,#0                 ;700
00007a  4770              BX       lr
;;;702    
                          ENDP

                  |L57.124|
                          DCD      0x40012c00
                  |L57.128|
                          DCD      0x40014400
                  |L57.132|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_OC_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop PROC
;;;615    */
;;;616    HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b430              PUSH     {r4,r5}
000002  6802              LDR      r2,[r0,#0]
;;;617    {
;;;618      /* Check the parameters */
;;;619      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;620    
;;;621      /* Disable the Output compare channel */
;;;622      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000004  2400              MOVS     r4,#0
000006  2301              MOVS     r3,#1
000008  6a15              LDR      r5,[r2,#0x20]
00000a  408b              LSLS     r3,r3,r1
00000c  439d              BICS     r5,r5,r3
00000e  6215              STR      r5,[r2,#0x20]
000010  6a13              LDR      r3,[r2,#0x20]
000012  408c              LSLS     r4,r4,r1
000014  4323              ORRS     r3,r3,r4
000016  6213              STR      r3,[r2,#0x20]
;;;623    
;;;624      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;625      {
;;;626        /* Disable the Main Ouput */
;;;627        __HAL_TIM_MOE_DISABLE(htim);
000018  4b13              LDR      r3,|L58.104|
00001a  4c12              LDR      r4,|L58.100|
00001c  6801              LDR      r1,[r0,#0]            ;624
00001e  109a              ASRS     r2,r3,#2
000020  42a1              CMP      r1,r4                 ;624
000022  d005              BEQ      |L58.48|
000024  4c11              LDR      r4,|L58.108|
000026  42a1              CMP      r1,r4                 ;624
000028  d002              BEQ      |L58.48|
00002a  4c11              LDR      r4,|L58.112|
00002c  42a1              CMP      r1,r4                 ;624
00002e  d10a              BNE      |L58.70|
                  |L58.48|
000030  6a0c              LDR      r4,[r1,#0x20]
000032  421c              TST      r4,r3
000034  d107              BNE      |L58.70|
000036  6a0c              LDR      r4,[r1,#0x20]
000038  4214              TST      r4,r2
00003a  d104              BNE      |L58.70|
00003c  6c4c              LDR      r4,[r1,#0x44]
00003e  2501              MOVS     r5,#1
000040  03ed              LSLS     r5,r5,#15
000042  43ac              BICS     r4,r4,r5
000044  644c              STR      r4,[r1,#0x44]
                  |L58.70|
;;;628      }
;;;629    
;;;630      /* Disable the Peripheral */
;;;631      __HAL_TIM_DISABLE(htim);
000046  6800              LDR      r0,[r0,#0]
000048  6a01              LDR      r1,[r0,#0x20]
00004a  4219              TST      r1,r3
00004c  d106              BNE      |L58.92|
00004e  6a01              LDR      r1,[r0,#0x20]
000050  4211              TST      r1,r2
000052  d103              BNE      |L58.92|
000054  6801              LDR      r1,[r0,#0]
000056  0849              LSRS     r1,r1,#1
000058  0049              LSLS     r1,r1,#1
00005a  6001              STR      r1,[r0,#0]
                  |L58.92|
;;;632    
;;;633      /* Return function status */
;;;634      return HAL_OK;
;;;635    }
00005c  bc30              POP      {r4,r5}
00005e  2000              MOVS     r0,#0                 ;634
000060  4770              BX       lr
;;;636    
                          ENDP

000062  0000              DCW      0x0000
                  |L58.100|
                          DCD      0x40012c00
                  |L58.104|
                          DCD      0x00001111
                  |L58.108|
                          DCD      0x40014400
                  |L58.112|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_OC_Stop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop_DMA PROC
;;;898    */
;;;899    HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b470              PUSH     {r4-r6}
;;;900    {
;;;901      /* Check the parameters */
;;;902      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;903    
;;;904      switch (Channel)
000002  6802              LDR      r2,[r0,#0]
000004  2900              CMP      r1,#0
000006  d006              BEQ      |L59.22|
000008  2904              CMP      r1,#4
00000a  d00a              BEQ      |L59.34|
00000c  2908              CMP      r1,#8
00000e  d00e              BEQ      |L59.46|
000010  290c              CMP      r1,#0xc
000012  d117              BNE      |L59.68|
000014  e011              B        |L59.58|
                  |L59.22|
;;;905      {
;;;906        case TIM_CHANNEL_1:
;;;907        {
;;;908          /* Disable the TIM Capture/Compare 1 DMA request */
;;;909          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000016  68d3              LDR      r3,[r2,#0xc]
000018  2401              MOVS     r4,#1
00001a  0264              LSLS     r4,r4,#9
00001c  43a3              BICS     r3,r3,r4
00001e  60d3              STR      r3,[r2,#0xc]
;;;910        }
;;;911        break;
000020  e010              B        |L59.68|
                  |L59.34|
;;;912    
;;;913        case TIM_CHANNEL_2:
;;;914        {
;;;915          /* Disable the TIM Capture/Compare 2 DMA request */
;;;916          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000022  68d3              LDR      r3,[r2,#0xc]
000024  2401              MOVS     r4,#1
000026  02a4              LSLS     r4,r4,#10
000028  43a3              BICS     r3,r3,r4
00002a  60d3              STR      r3,[r2,#0xc]
;;;917        }
;;;918        break;
00002c  e00a              B        |L59.68|
                  |L59.46|
;;;919    
;;;920        case TIM_CHANNEL_3:
;;;921        {
;;;922          /* Disable the TIM Capture/Compare 3 DMA request */
;;;923          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
00002e  68d3              LDR      r3,[r2,#0xc]
000030  2401              MOVS     r4,#1
000032  02e4              LSLS     r4,r4,#11
000034  43a3              BICS     r3,r3,r4
000036  60d3              STR      r3,[r2,#0xc]
;;;924        }
;;;925        break;
000038  e004              B        |L59.68|
                  |L59.58|
;;;926    
;;;927        case TIM_CHANNEL_4:
;;;928        {
;;;929          /* Disable the TIM Capture/Compare 4 interrupt */
;;;930          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
00003a  68d3              LDR      r3,[r2,#0xc]
00003c  2401              MOVS     r4,#1
00003e  0324              LSLS     r4,r4,#12
000040  43a3              BICS     r3,r3,r4
000042  60d3              STR      r3,[r2,#0xc]
                  |L59.68|
000044  6802              LDR      r2,[r0,#0]
000046  2401              MOVS     r4,#1
;;;931        }
;;;932        break;
;;;933    
;;;934        default:
;;;935        break;
;;;936      }
;;;937    
;;;938      /* Disable the Output compare channel */
;;;939      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000048  2500              MOVS     r5,#0
00004a  4623              MOV      r3,r4
00004c  6a16              LDR      r6,[r2,#0x20]
00004e  408b              LSLS     r3,r3,r1
000050  439e              BICS     r6,r6,r3
000052  6216              STR      r6,[r2,#0x20]
000054  6a13              LDR      r3,[r2,#0x20]
000056  408d              LSLS     r5,r5,r1
000058  432b              ORRS     r3,r3,r5
00005a  6213              STR      r3,[r2,#0x20]
;;;940    
;;;941      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;942      {
;;;943        /* Disable the Main Ouput */
;;;944        __HAL_TIM_MOE_DISABLE(htim);
00005c  4a13              LDR      r2,|L59.172|
00005e  4d12              LDR      r5,|L59.168|
000060  6801              LDR      r1,[r0,#0]            ;941
000062  1093              ASRS     r3,r2,#2
000064  42a9              CMP      r1,r5                 ;941
000066  d005              BEQ      |L59.116|
000068  4d11              LDR      r5,|L59.176|
00006a  42a9              CMP      r1,r5                 ;941
00006c  d002              BEQ      |L59.116|
00006e  4d11              LDR      r5,|L59.180|
000070  42a9              CMP      r1,r5                 ;941
000072  d10a              BNE      |L59.138|
                  |L59.116|
000074  6a0d              LDR      r5,[r1,#0x20]
000076  4215              TST      r5,r2
000078  d107              BNE      |L59.138|
00007a  6a0d              LDR      r5,[r1,#0x20]
00007c  421d              TST      r5,r3
00007e  d104              BNE      |L59.138|
000080  6c4d              LDR      r5,[r1,#0x44]
000082  2601              MOVS     r6,#1
000084  03f6              LSLS     r6,r6,#15
000086  43b5              BICS     r5,r5,r6
000088  644d              STR      r5,[r1,#0x44]
                  |L59.138|
;;;945      }
;;;946    
;;;947      /* Disable the Peripheral */
;;;948      __HAL_TIM_DISABLE(htim);
00008a  6801              LDR      r1,[r0,#0]
00008c  6a0d              LDR      r5,[r1,#0x20]
00008e  4215              TST      r5,r2
000090  d106              BNE      |L59.160|
000092  6a0a              LDR      r2,[r1,#0x20]
000094  421a              TST      r2,r3
000096  d103              BNE      |L59.160|
000098  680a              LDR      r2,[r1,#0]
00009a  0852              LSRS     r2,r2,#1
00009c  0052              LSLS     r2,r2,#1
00009e  600a              STR      r2,[r1,#0]
                  |L59.160|
;;;949    
;;;950      /* Change the htim state */
;;;951      htim->State = HAL_TIM_STATE_READY;
0000a0  6404              STR      r4,[r0,#0x40]
;;;952    
;;;953      /* Return function status */
;;;954      return HAL_OK;
;;;955    }
0000a2  bc70              POP      {r4-r6}
0000a4  2000              MOVS     r0,#0                 ;954
0000a6  4770              BX       lr
;;;956    
                          ENDP

                  |L59.168|
                          DCD      0x40012c00
                  |L59.172|
                          DCD      0x00001111
                  |L59.176|
                          DCD      0x40014400
                  |L59.180|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_OC_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop_IT PROC
;;;713    */
;;;714    HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b430              PUSH     {r4,r5}
;;;715    {
;;;716      /* Check the parameters */
;;;717      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;718    
;;;719      switch (Channel)
000002  6802              LDR      r2,[r0,#0]
000004  2900              CMP      r1,#0
000006  d006              BEQ      |L60.22|
000008  2904              CMP      r1,#4
00000a  d009              BEQ      |L60.32|
00000c  2908              CMP      r1,#8
00000e  d00c              BEQ      |L60.42|
000010  290c              CMP      r1,#0xc
000012  d113              BNE      |L60.60|
000014  e00e              B        |L60.52|
                  |L60.22|
;;;720      {
;;;721        case TIM_CHANNEL_1:
;;;722        {
;;;723          /* Disable the TIM Capture/Compare 1 interrupt */
;;;724          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000016  68d3              LDR      r3,[r2,#0xc]
000018  2402              MOVS     r4,#2
00001a  43a3              BICS     r3,r3,r4
00001c  60d3              STR      r3,[r2,#0xc]
;;;725        }
;;;726        break;
00001e  e00d              B        |L60.60|
                  |L60.32|
;;;727    
;;;728        case TIM_CHANNEL_2:
;;;729        {
;;;730          /* Disable the TIM Capture/Compare 2 interrupt */
;;;731          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000020  68d3              LDR      r3,[r2,#0xc]
000022  2404              MOVS     r4,#4
000024  43a3              BICS     r3,r3,r4
000026  60d3              STR      r3,[r2,#0xc]
;;;732        }
;;;733        break;
000028  e008              B        |L60.60|
                  |L60.42|
;;;734    
;;;735        case TIM_CHANNEL_3:
;;;736        {
;;;737          /* Disable the TIM Capture/Compare 3 interrupt */
;;;738          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
00002a  68d3              LDR      r3,[r2,#0xc]
00002c  2408              MOVS     r4,#8
00002e  43a3              BICS     r3,r3,r4
000030  60d3              STR      r3,[r2,#0xc]
;;;739        }
;;;740        break;
000032  e003              B        |L60.60|
                  |L60.52|
;;;741    
;;;742        case TIM_CHANNEL_4:
;;;743        {
;;;744          /* Disable the TIM Capture/Compare 4 interrupt */
;;;745          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
000034  68d3              LDR      r3,[r2,#0xc]
000036  2410              MOVS     r4,#0x10
000038  43a3              BICS     r3,r3,r4
00003a  60d3              STR      r3,[r2,#0xc]
                  |L60.60|
00003c  6802              LDR      r2,[r0,#0]
;;;746        }
;;;747        break;
;;;748    
;;;749        default:
;;;750        break;
;;;751      }
;;;752    
;;;753      /* Disable the Output compare channel */
;;;754      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
00003e  2400              MOVS     r4,#0
000040  2301              MOVS     r3,#1
000042  6a15              LDR      r5,[r2,#0x20]
000044  408b              LSLS     r3,r3,r1
000046  439d              BICS     r5,r5,r3
000048  6215              STR      r5,[r2,#0x20]
00004a  6a13              LDR      r3,[r2,#0x20]
00004c  408c              LSLS     r4,r4,r1
00004e  4323              ORRS     r3,r3,r4
000050  6213              STR      r3,[r2,#0x20]
;;;755    
;;;756      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;757      {
;;;758        /* Disable the Main Ouput */
;;;759        __HAL_TIM_MOE_DISABLE(htim);
000052  4b13              LDR      r3,|L60.160|
000054  4c11              LDR      r4,|L60.156|
000056  6801              LDR      r1,[r0,#0]            ;756
000058  109a              ASRS     r2,r3,#2
00005a  42a1              CMP      r1,r4                 ;756
00005c  d005              BEQ      |L60.106|
00005e  4c11              LDR      r4,|L60.164|
000060  42a1              CMP      r1,r4                 ;756
000062  d002              BEQ      |L60.106|
000064  4c10              LDR      r4,|L60.168|
000066  42a1              CMP      r1,r4                 ;756
000068  d10a              BNE      |L60.128|
                  |L60.106|
00006a  6a0c              LDR      r4,[r1,#0x20]
00006c  421c              TST      r4,r3
00006e  d107              BNE      |L60.128|
000070  6a0c              LDR      r4,[r1,#0x20]
000072  4214              TST      r4,r2
000074  d104              BNE      |L60.128|
000076  6c4c              LDR      r4,[r1,#0x44]
000078  2501              MOVS     r5,#1
00007a  03ed              LSLS     r5,r5,#15
00007c  43ac              BICS     r4,r4,r5
00007e  644c              STR      r4,[r1,#0x44]
                  |L60.128|
;;;760      }
;;;761    
;;;762      /* Disable the Peripheral */
;;;763      __HAL_TIM_DISABLE(htim);
000080  6800              LDR      r0,[r0,#0]
000082  6a01              LDR      r1,[r0,#0x20]
000084  4219              TST      r1,r3
000086  d106              BNE      |L60.150|
000088  6a01              LDR      r1,[r0,#0x20]
00008a  4211              TST      r1,r2
00008c  d103              BNE      |L60.150|
00008e  6801              LDR      r1,[r0,#0]
000090  0849              LSRS     r1,r1,#1
000092  0049              LSLS     r1,r1,#1
000094  6001              STR      r1,[r0,#0]
                  |L60.150|
;;;764    
;;;765      /* Return function status */
;;;766      return HAL_OK;
;;;767    }
000096  bc30              POP      {r4,r5}
000098  2000              MOVS     r0,#0                 ;766
00009a  4770              BX       lr
;;;768    
                          ENDP

                  |L60.156|
                          DCD      0x40012c00
                  |L60.160|
                          DCD      0x00001111
                  |L60.164|
                          DCD      0x40014400
                  |L60.168|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_OnePulse_ConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_ConfigChannel PROC
;;;3196     */
;;;3197   HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef* sConfig, uint32_t OutputChannel,  uint32_t InputChannel)
000000  b5f0              PUSH     {r4-r7,lr}
;;;3198   {
000002  461e              MOV      r6,r3
000004  b087              SUB      sp,sp,#0x1c
000006  460d              MOV      r5,r1
000008  4604              MOV      r4,r0
;;;3199     TIM_OC_InitTypeDef temp1;
;;;3200   
;;;3201     /* Check the parameters */
;;;3202     assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
;;;3203     assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
;;;3204   
;;;3205     if(OutputChannel != InputChannel)
00000a  42b2              CMP      r2,r6
00000c  d07e              BEQ      |L61.268|
;;;3206     {
;;;3207     __HAL_LOCK(htim);
00000e  6be0              LDR      r0,[r4,#0x3c]
000010  2801              CMP      r0,#1
000012  d014              BEQ      |L61.62|
000014  2001              MOVS     r0,#1
;;;3208   
;;;3209     htim->State = HAL_TIM_STATE_BUSY;
000016  63e0              STR      r0,[r4,#0x3c]
000018  2002              MOVS     r0,#2
00001a  6420              STR      r0,[r4,#0x40]
;;;3210   
;;;3211     /* Extract the Ouput compare configuration from sConfig structure */
;;;3212     temp1.OCMode = sConfig->OCMode;
00001c  6828              LDR      r0,[r5,#0]
;;;3213     temp1.Pulse = sConfig->Pulse;
00001e  9000              STR      r0,[sp,#0]
000020  6868              LDR      r0,[r5,#4]
;;;3214     temp1.OCPolarity = sConfig->OCPolarity;
000022  9001              STR      r0,[sp,#4]
000024  68a8              LDR      r0,[r5,#8]
;;;3215     temp1.OCNPolarity = sConfig->OCNPolarity;
000026  9002              STR      r0,[sp,#8]
000028  68e8              LDR      r0,[r5,#0xc]
;;;3216     temp1.OCIdleState = sConfig->OCIdleState;
00002a  9003              STR      r0,[sp,#0xc]
00002c  6928              LDR      r0,[r5,#0x10]
;;;3217     temp1.OCNIdleState = sConfig->OCNIdleState;
00002e  9005              STR      r0,[sp,#0x14]
000030  6968              LDR      r0,[r5,#0x14]
;;;3218   
;;;3219       switch (OutputChannel)
000032  9006              STR      r0,[sp,#0x18]
000034  2a00              CMP      r2,#0
000036  d005              BEQ      |L61.68|
000038  2a04              CMP      r2,#4
00003a  d10c              BNE      |L61.86|
00003c  e007              B        |L61.78|
                  |L61.62|
00003e  2002              MOVS     r0,#2                 ;3207
;;;3220     {
;;;3221       case TIM_CHANNEL_1:
;;;3222       {
;;;3223           assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3224   
;;;3225         TIM_OC1_SetConfig(htim->Instance, &temp1);
;;;3226       }
;;;3227       break;
;;;3228       case TIM_CHANNEL_2:
;;;3229       {
;;;3230           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3231   
;;;3232         TIM_OC2_SetConfig(htim->Instance, &temp1);
;;;3233       }
;;;3234       break;
;;;3235       default:
;;;3236       break;
;;;3237     }
;;;3238     switch (InputChannel)
;;;3239     {
;;;3240       case TIM_CHANNEL_1:
;;;3241       {
;;;3242         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3243   
;;;3244         TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;3245                           sConfig->ICSelection, sConfig->ICFilter);
;;;3246   
;;;3247         /* Reset the IC1PSC Bits */
;;;3248       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;3249   
;;;3250         /* Select the Trigger source */
;;;3251           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;3252         htim->Instance->SMCR |= TIM_TS_TI1FP1;
;;;3253   
;;;3254         /* Select the Slave Mode */
;;;3255           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3256         htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;3257       }
;;;3258       break;
;;;3259       case TIM_CHANNEL_2:
;;;3260       {
;;;3261         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3262   
;;;3263         TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;3264                    sConfig->ICSelection, sConfig->ICFilter);
;;;3265   
;;;3266         /* Reset the IC2PSC Bits */
;;;3267           htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;3268   
;;;3269         /* Select the Trigger source */
;;;3270           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;3271         htim->Instance->SMCR |= TIM_TS_TI2FP2;
;;;3272   
;;;3273         /* Select the Slave Mode */
;;;3274           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3275         htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;3276       }
;;;3277       break;
;;;3278   
;;;3279       default:
;;;3280       break;
;;;3281     }
;;;3282   
;;;3283     htim->State = HAL_TIM_STATE_READY;
;;;3284   
;;;3285     __HAL_UNLOCK(htim);
;;;3286   
;;;3287     return HAL_OK;
;;;3288   }
;;;3289     else
;;;3290     {
;;;3291       return HAL_ERROR;
;;;3292     }
;;;3293   }
000040  b007              ADD      sp,sp,#0x1c
000042  bdf0              POP      {r4-r7,pc}
                  |L61.68|
000044  4669              MOV      r1,sp                 ;3225
000046  6820              LDR      r0,[r4,#0]            ;3225
000048  f7fffffe          BL       TIM_OC1_SetConfig
00004c  e003              B        |L61.86|
                  |L61.78|
00004e  4669              MOV      r1,sp                 ;3232
000050  6820              LDR      r0,[r4,#0]            ;3232
000052  f7fffffe          BL       TIM_OC2_SetConfig
                  |L61.86|
000056  2e00              CMP      r6,#0                 ;3238
000058  d002              BEQ      |L61.96|
00005a  2e04              CMP      r6,#4                 ;3238
00005c  d171              BNE      |L61.322|
00005e  e039              B        |L61.212|
                  |L61.96|
000060  6821              LDR      r1,[r4,#0]            ;3244
000062  69ee              LDR      r6,[r5,#0x1c]         ;3244
000064  69aa              LDR      r2,[r5,#0x18]         ;3244
000066  6a2d              LDR      r5,[r5,#0x20]         ;3244
000068  6a08              LDR      r0,[r1,#0x20]         ;3244
00006a  0840              LSRS     r0,r0,#1              ;3244
00006c  0040              LSLS     r0,r0,#1              ;3244
00006e  6208              STR      r0,[r1,#0x20]         ;3244
000070  6988              LDR      r0,[r1,#0x18]         ;3244
000072  6a0b              LDR      r3,[r1,#0x20]         ;3244
000074  4f37              LDR      r7,|L61.340|
000076  42b9              CMP      r1,r7                 ;3244
000078  d002              BEQ      |L61.128|
00007a  4f37              LDR      r7,|L61.344|
00007c  42b9              CMP      r1,r7                 ;3244
00007e  d102              BNE      |L61.134|
                  |L61.128|
000080  0880              LSRS     r0,r0,#2              ;3244
000082  0080              LSLS     r0,r0,#2              ;3244
000084  e000              B        |L61.136|
                  |L61.134|
000086  2601              MOVS     r6,#1                 ;3244
                  |L61.136|
000088  4330              ORRS     r0,r0,r6              ;3244
00008a  26f0              MOVS     r6,#0xf0              ;3244
00008c  072d              LSLS     r5,r5,#28             ;3244
00008e  43b0              BICS     r0,r0,r6              ;3244
000090  0e2d              LSRS     r5,r5,#24             ;3244
000092  4305              ORRS     r5,r5,r0              ;3244
000094  200a              MOVS     r0,#0xa               ;3244
000096  4383              BICS     r3,r3,r0              ;3244
000098  4002              ANDS     r2,r2,r0              ;3244
00009a  431a              ORRS     r2,r2,r3              ;3244
00009c  618d              STR      r5,[r1,#0x18]         ;3244
00009e  620a              STR      r2,[r1,#0x20]         ;3244
0000a0  6820              LDR      r0,[r4,#0]            ;3248
0000a2  6981              LDR      r1,[r0,#0x18]         ;3248
0000a4  220c              MOVS     r2,#0xc               ;3248
0000a6  4391              BICS     r1,r1,r2              ;3248
0000a8  6181              STR      r1,[r0,#0x18]         ;3248
0000aa  6820              LDR      r0,[r4,#0]            ;3251
0000ac  6882              LDR      r2,[r0,#8]            ;3251
0000ae  2170              MOVS     r1,#0x70              ;3251
0000b0  438a              BICS     r2,r2,r1              ;3251
0000b2  6082              STR      r2,[r0,#8]            ;3251
0000b4  6820              LDR      r0,[r4,#0]            ;3252
0000b6  6881              LDR      r1,[r0,#8]            ;3252
0000b8  2250              MOVS     r2,#0x50              ;3252
0000ba  4311              ORRS     r1,r1,r2              ;3252
0000bc  6081              STR      r1,[r0,#8]            ;3252
0000be  6820              LDR      r0,[r4,#0]            ;3255
0000c0  6881              LDR      r1,[r0,#8]            ;3255
0000c2  08c9              LSRS     r1,r1,#3              ;3255
0000c4  00c9              LSLS     r1,r1,#3              ;3255
0000c6  6081              STR      r1,[r0,#8]            ;3255
0000c8  6820              LDR      r0,[r4,#0]            ;3256
0000ca  6881              LDR      r1,[r0,#8]            ;3256
0000cc  2206              MOVS     r2,#6                 ;3256
0000ce  4311              ORRS     r1,r1,r2              ;3256
0000d0  6081              STR      r1,[r0,#8]            ;3256
0000d2  e036              B        |L61.322|
                  |L61.212|
0000d4  6820              LDR      r0,[r4,#0]            ;3263
0000d6  69ae              LDR      r6,[r5,#0x18]         ;3263
0000d8  69eb              LDR      r3,[r5,#0x1c]         ;3263
0000da  8c2d              LDRH     r5,[r5,#0x20]         ;3263
0000dc  6a01              LDR      r1,[r0,#0x20]         ;3263
0000de  2210              MOVS     r2,#0x10              ;3263
0000e0  4391              BICS     r1,r1,r2              ;3263
0000e2  6201              STR      r1,[r0,#0x20]         ;3263
0000e4  6981              LDR      r1,[r0,#0x18]         ;3263
0000e6  6a02              LDR      r2,[r0,#0x20]         ;3263
0000e8  2703              MOVS     r7,#3                 ;3263
0000ea  023f              LSLS     r7,r7,#8              ;3263
0000ec  43b9              BICS     r1,r1,r7              ;3263
0000ee  021b              LSLS     r3,r3,#8              ;3263
0000f0  430b              ORRS     r3,r3,r1              ;3263
0000f2  210f              MOVS     r1,#0xf               ;3263
0000f4  0309              LSLS     r1,r1,#12             ;3263
0000f6  438b              BICS     r3,r3,r1              ;3263
0000f8  0729              LSLS     r1,r5,#28             ;3263
0000fa  0c09              LSRS     r1,r1,#16             ;3263
0000fc  4319              ORRS     r1,r1,r3              ;3263
0000fe  25a0              MOVS     r5,#0xa0              ;3263
000100  0133              LSLS     r3,r6,#4              ;3263
000102  43aa              BICS     r2,r2,r5              ;3263
000104  402b              ANDS     r3,r3,r5              ;3263
000106  4313              ORRS     r3,r3,r2              ;3263
000108  6181              STR      r1,[r0,#0x18]         ;3263
00010a  e000              B        |L61.270|
                  |L61.268|
00010c  e01f              B        |L61.334|
                  |L61.270|
00010e  6203              STR      r3,[r0,#0x20]         ;3263
000110  6820              LDR      r0,[r4,#0]            ;3267
000112  6981              LDR      r1,[r0,#0x18]         ;3267
000114  00ba              LSLS     r2,r7,#2              ;3267
000116  4391              BICS     r1,r1,r2              ;3267
000118  6181              STR      r1,[r0,#0x18]         ;3267
00011a  6820              LDR      r0,[r4,#0]            ;3270
00011c  6881              LDR      r1,[r0,#8]            ;3270
00011e  2270              MOVS     r2,#0x70              ;3270
000120  4391              BICS     r1,r1,r2              ;3270
000122  6081              STR      r1,[r0,#8]            ;3270
000124  6820              LDR      r0,[r4,#0]            ;3271
000126  6881              LDR      r1,[r0,#8]            ;3271
000128  2260              MOVS     r2,#0x60              ;3271
00012a  4311              ORRS     r1,r1,r2              ;3271
00012c  6081              STR      r1,[r0,#8]            ;3271
00012e  6820              LDR      r0,[r4,#0]            ;3274
000130  6881              LDR      r1,[r0,#8]            ;3274
000132  08c9              LSRS     r1,r1,#3              ;3274
000134  00c9              LSLS     r1,r1,#3              ;3274
000136  6081              STR      r1,[r0,#8]            ;3274
000138  6820              LDR      r0,[r4,#0]            ;3275
00013a  6881              LDR      r1,[r0,#8]            ;3275
00013c  2206              MOVS     r2,#6                 ;3275
00013e  4311              ORRS     r1,r1,r2              ;3275
000140  6081              STR      r1,[r0,#8]            ;3275
                  |L61.322|
000142  2001              MOVS     r0,#1                 ;3283
000144  6420              STR      r0,[r4,#0x40]         ;3283
000146  2000              MOVS     r0,#0                 ;3285
000148  63e0              STR      r0,[r4,#0x3c]         ;3287
00014a  b007              ADD      sp,sp,#0x1c
00014c  bdf0              POP      {r4-r7,pc}
                  |L61.334|
00014e  2001              MOVS     r0,#1                 ;3291
000150  b007              ADD      sp,sp,#0x1c
000152  bdf0              POP      {r4-r7,pc}
;;;3294   
                          ENDP

                  |L61.340|
                          DCD      0x40012c00
                  |L61.344|
                          DCD      0x40000400

                          AREA ||i.HAL_TIM_OnePulse_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_DeInit PROC
;;;2020     */
;;;2021   HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;2022   {
000002  4604              MOV      r4,r0
;;;2023     /* Check the parameters */
;;;2024     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2025   
;;;2026     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  6420              STR      r0,[r4,#0x40]
;;;2027   
;;;2028     /* Disable the TIM Peripheral Clock */
;;;2029     __HAL_TIM_DISABLE(htim);
000008  6820              LDR      r0,[r4,#0]
00000a  6a01              LDR      r1,[r0,#0x20]
00000c  4a08              LDR      r2,|L62.48|
00000e  4211              TST      r1,r2
000010  d107              BNE      |L62.34|
000012  6a01              LDR      r1,[r0,#0x20]
000014  1092              ASRS     r2,r2,#2
000016  4211              TST      r1,r2
000018  d103              BNE      |L62.34|
00001a  6801              LDR      r1,[r0,#0]
00001c  0849              LSRS     r1,r1,#1
00001e  0049              LSLS     r1,r1,#1
000020  6001              STR      r1,[r0,#0]
                  |L62.34|
;;;2030   
;;;2031     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;2032     HAL_TIM_OnePulse_MspDeInit(htim);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       HAL_TIM_OnePulse_MspDeInit
;;;2033   
;;;2034     /* Change TIM state */
;;;2035     htim->State = HAL_TIM_STATE_RESET;
000028  2000              MOVS     r0,#0
00002a  6420              STR      r0,[r4,#0x40]
;;;2036   
;;;2037     /* Release Lock */
;;;2038     __HAL_UNLOCK(htim);
00002c  63e0              STR      r0,[r4,#0x3c]
;;;2039   
;;;2040     return HAL_OK;
;;;2041   }
00002e  bd10              POP      {r4,pc}
;;;2042   
                          ENDP

                  |L62.48|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_OnePulse_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_GetState PROC
;;;4532     */
;;;4533   HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
000000  6c00              LDR      r0,[r0,#0x40]
;;;4534   {
;;;4535     return htim->State;
;;;4536   }
000002  4770              BX       lr
;;;4537   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_Init PROC
;;;1973     */
;;;1974   HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
000000  2800              CMP      r0,#0
;;;1975   {
;;;1976     /* Check the TIM handle allocation */
;;;1977     if(htim == NULL)
000002  d101              BNE      |L64.8|
;;;1978     {
;;;1979       return HAL_ERROR;
000004  2001              MOVS     r0,#1
;;;1980     }
;;;1981   
;;;1982     /* Check the parameters */
;;;1983     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1984     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1985     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;1986     assert_param(IS_TIM_OPM_MODE(OnePulseMode));
;;;1987     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;1988   
;;;1989     if(htim->State == HAL_TIM_STATE_RESET)
;;;1990     {
;;;1991       /* Allocate lock resource and initialize it */
;;;1992       htim->Lock = HAL_UNLOCKED;
;;;1993   
;;;1994       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1995       HAL_TIM_OnePulse_MspInit(htim);
;;;1996     }
;;;1997   
;;;1998     /* Set the TIM state */
;;;1999     htim->State= HAL_TIM_STATE_BUSY;
;;;2000   
;;;2001     /* Configure the Time base in the One Pulse Mode */
;;;2002     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;2003   
;;;2004     /* Reset the OPM Bit */
;;;2005     htim->Instance->CR1 &= ~TIM_CR1_OPM;
;;;2006   
;;;2007     /* Configure the OPM Mode */
;;;2008     htim->Instance->CR1 |= OnePulseMode;
;;;2009   
;;;2010     /* Initialize the TIM state*/
;;;2011     htim->State= HAL_TIM_STATE_READY;
;;;2012   
;;;2013     return HAL_OK;
;;;2014   }
000006  4770              BX       lr
                  |L64.8|
000008  b570              PUSH     {r4-r6,lr}            ;1975
00000a  4604              MOV      r4,r0                 ;1975
00000c  6c00              LDR      r0,[r0,#0x40]         ;1989
00000e  460d              MOV      r5,r1                 ;1975
000010  2800              CMP      r0,#0                 ;1989
000012  d103              BNE      |L64.28|
000014  63e0              STR      r0,[r4,#0x3c]         ;1995
000016  4620              MOV      r0,r4                 ;1995
000018  f7fffffe          BL       HAL_TIM_OnePulse_MspInit
                  |L64.28|
00001c  2002              MOVS     r0,#2                 ;1999
00001e  6420              STR      r0,[r4,#0x40]         ;1999
000020  1d21              ADDS     r1,r4,#4              ;2002
000022  6820              LDR      r0,[r4,#0]            ;2002
000024  f7fffffe          BL       TIM_Base_SetConfig
000028  6820              LDR      r0,[r4,#0]            ;2005
00002a  6801              LDR      r1,[r0,#0]            ;2005
00002c  2208              MOVS     r2,#8                 ;2005
00002e  4391              BICS     r1,r1,r2              ;2005
000030  6001              STR      r1,[r0,#0]            ;2005
000032  6820              LDR      r0,[r4,#0]            ;2008
000034  6801              LDR      r1,[r0,#0]            ;2008
000036  4329              ORRS     r1,r1,r5              ;2008
000038  6001              STR      r1,[r0,#0]            ;2008
00003a  2001              MOVS     r0,#1                 ;2011
00003c  6420              STR      r0,[r4,#0x40]         ;2011
00003e  2000              MOVS     r0,#0                 ;2013
000040  bd70              POP      {r4-r6,pc}
;;;2015   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_MspDeInit PROC
;;;2062     */
;;;2063   __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2064   {
;;;2065     /* Prevent unused argument(s) compilation warning */
;;;2066     UNUSED(htim);
;;;2067   
;;;2068     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2069               the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
;;;2070      */
;;;2071   }
;;;2072   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_MspInit PROC
;;;2047     */
;;;2048   __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2049   {
;;;2050     /* Prevent unused argument(s) compilation warning */
;;;2051     UNUSED(htim);
;;;2052   
;;;2053     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2054               the HAL_TIM_OnePulse_MspInit could be implemented in the user file
;;;2055      */
;;;2056   }
;;;2057   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Start PROC
;;;2081   */
;;;2082   HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  6801              LDR      r1,[r0,#0]
000002  2201              MOVS     r2,#1
000004  6a0b              LDR      r3,[r1,#0x20]
000006  4393              BICS     r3,r3,r2
000008  620b              STR      r3,[r1,#0x20]
00000a  6a0b              LDR      r3,[r1,#0x20]
00000c  4313              ORRS     r3,r3,r2
00000e  620b              STR      r3,[r1,#0x20]
000010  6801              LDR      r1,[r0,#0]
000012  2210              MOVS     r2,#0x10
000014  6a0b              LDR      r3,[r1,#0x20]
000016  4393              BICS     r3,r3,r2
000018  620b              STR      r3,[r1,#0x20]
00001a  6a0a              LDR      r2,[r1,#0x20]
00001c  2310              MOVS     r3,#0x10
00001e  431a              ORRS     r2,r2,r3
000020  620a              STR      r2,[r1,#0x20]
;;;2083   {
;;;2084     /* Enable the Capture compare and the Input Capture channels 
;;;2085       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2086       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2087       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2088       in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
;;;2089   
;;;2090       No need to enable the counter, it's enabled automatically by hardware 
;;;2091       (the counter starts in response to a stimulus and generate a pulse */
;;;2092   
;;;2093     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2094     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2095   
;;;2096     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000022  6800              LDR      r0,[r0,#0]
000024  4907              LDR      r1,|L67.68|
000026  4288              CMP      r0,r1
000028  d005              BEQ      |L67.54|
00002a  4907              LDR      r1,|L67.72|
00002c  4288              CMP      r0,r1
00002e  d002              BEQ      |L67.54|
000030  4906              LDR      r1,|L67.76|
000032  4288              CMP      r0,r1
000034  d104              BNE      |L67.64|
                  |L67.54|
;;;2097     {
;;;2098       /* Enable the main output */
;;;2099       __HAL_TIM_MOE_ENABLE(htim);
000036  6c41              LDR      r1,[r0,#0x44]
000038  2201              MOVS     r2,#1
00003a  03d2              LSLS     r2,r2,#15
00003c  4311              ORRS     r1,r1,r2
00003e  6441              STR      r1,[r0,#0x44]
                  |L67.64|
;;;2100     }
;;;2101   
;;;2102     /* Return function status */
;;;2103     return HAL_OK;
000040  2000              MOVS     r0,#0
;;;2104   }
000042  4770              BX       lr
;;;2105   
                          ENDP

                  |L67.68|
                          DCD      0x40012c00
                  |L67.72|
                          DCD      0x40014400
                  |L67.76|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_OnePulse_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Start_IT PROC
;;;2147   */
;;;2148   HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  6801              LDR      r1,[r0,#0]
;;;2149   {
;;;2150     /* Enable the Capture compare and the Input Capture channels 
;;;2151       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2152       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2153       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2154       in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
;;;2155   
;;;2156       No need to enable the counter, it's enabled automatically by hardware 
;;;2157       (the counter starts in response to a stimulus and generate a pulse */
;;;2158   
;;;2159     /* Enable the TIM Capture/Compare 1 interrupt */
;;;2160     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000002  68ca              LDR      r2,[r1,#0xc]
000004  2302              MOVS     r3,#2
000006  431a              ORRS     r2,r2,r3
000008  60ca              STR      r2,[r1,#0xc]
;;;2161   
;;;2162     /* Enable the TIM Capture/Compare 2 interrupt */
;;;2163     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00000a  6801              LDR      r1,[r0,#0]
00000c  68ca              LDR      r2,[r1,#0xc]
00000e  2304              MOVS     r3,#4
000010  431a              ORRS     r2,r2,r3
000012  60ca              STR      r2,[r1,#0xc]
000014  6801              LDR      r1,[r0,#0]
000016  2201              MOVS     r2,#1
000018  6a0b              LDR      r3,[r1,#0x20]
00001a  4393              BICS     r3,r3,r2
00001c  620b              STR      r3,[r1,#0x20]
00001e  6a0b              LDR      r3,[r1,#0x20]
000020  4313              ORRS     r3,r3,r2
000022  620b              STR      r3,[r1,#0x20]
000024  6801              LDR      r1,[r0,#0]
000026  2210              MOVS     r2,#0x10
000028  6a0b              LDR      r3,[r1,#0x20]
00002a  4393              BICS     r3,r3,r2
00002c  620b              STR      r3,[r1,#0x20]
00002e  6a0a              LDR      r2,[r1,#0x20]
000030  2310              MOVS     r3,#0x10
000032  431a              ORRS     r2,r2,r3
000034  620a              STR      r2,[r1,#0x20]
;;;2164   
;;;2165     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2166     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2167   
;;;2168     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000036  6800              LDR      r0,[r0,#0]
000038  4907              LDR      r1,|L68.88|
00003a  4288              CMP      r0,r1
00003c  d005              BEQ      |L68.74|
00003e  4907              LDR      r1,|L68.92|
000040  4288              CMP      r0,r1
000042  d002              BEQ      |L68.74|
000044  4906              LDR      r1,|L68.96|
000046  4288              CMP      r0,r1
000048  d104              BNE      |L68.84|
                  |L68.74|
;;;2169     {
;;;2170       /* Enable the main output */
;;;2171       __HAL_TIM_MOE_ENABLE(htim);
00004a  6c41              LDR      r1,[r0,#0x44]
00004c  2201              MOVS     r2,#1
00004e  03d2              LSLS     r2,r2,#15
000050  4311              ORRS     r1,r1,r2
000052  6441              STR      r1,[r0,#0x44]
                  |L68.84|
;;;2172     }
;;;2173   
;;;2174     /* Return function status */
;;;2175     return HAL_OK;
000054  2000              MOVS     r0,#0
;;;2176   }
000056  4770              BX       lr
;;;2177   
                          ENDP

                  |L68.88|
                          DCD      0x40012c00
                  |L68.92|
                          DCD      0x40014400
                  |L68.96|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_OnePulse_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Stop PROC
;;;2114   */
;;;2115   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b430              PUSH     {r4,r5}
000002  6801              LDR      r1,[r0,#0]
000004  6a0a              LDR      r2,[r1,#0x20]
000006  0852              LSRS     r2,r2,#1
000008  0052              LSLS     r2,r2,#1
00000a  620a              STR      r2,[r1,#0x20]
00000c  6a0a              LDR      r2,[r1,#0x20]
00000e  620a              STR      r2,[r1,#0x20]
000010  6801              LDR      r1,[r0,#0]
000012  2210              MOVS     r2,#0x10
000014  6a0b              LDR      r3,[r1,#0x20]
000016  4393              BICS     r3,r3,r2
000018  620b              STR      r3,[r1,#0x20]
00001a  6a0a              LDR      r2,[r1,#0x20]
00001c  620a              STR      r2,[r1,#0x20]
;;;2116   {
;;;2117     /* Disable the Capture compare and the Input Capture channels 
;;;2118     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2119     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2120     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2121     in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
;;;2122   
;;;2123     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
;;;2124     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
;;;2125   
;;;2126     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;2127     {
;;;2128       /* Disable the Main Ouput */
;;;2129       __HAL_TIM_MOE_DISABLE(htim);
00001e  4a13              LDR      r2,|L69.108|
000020  4c11              LDR      r4,|L69.104|
000022  6801              LDR      r1,[r0,#0]            ;2126
000024  1093              ASRS     r3,r2,#2
000026  42a1              CMP      r1,r4                 ;2126
000028  d005              BEQ      |L69.54|
00002a  4c11              LDR      r4,|L69.112|
00002c  42a1              CMP      r1,r4                 ;2126
00002e  d002              BEQ      |L69.54|
000030  4c10              LDR      r4,|L69.116|
000032  42a1              CMP      r1,r4                 ;2126
000034  d10a              BNE      |L69.76|
                  |L69.54|
000036  6a0c              LDR      r4,[r1,#0x20]
000038  4214              TST      r4,r2
00003a  d107              BNE      |L69.76|
00003c  6a0c              LDR      r4,[r1,#0x20]
00003e  421c              TST      r4,r3
000040  d104              BNE      |L69.76|
000042  6c4c              LDR      r4,[r1,#0x44]
000044  2501              MOVS     r5,#1
000046  03ed              LSLS     r5,r5,#15
000048  43ac              BICS     r4,r4,r5
00004a  644c              STR      r4,[r1,#0x44]
                  |L69.76|
;;;2130     }
;;;2131   
;;;2132     /* Disable the Peripheral */
;;;2133     __HAL_TIM_DISABLE(htim);
00004c  6800              LDR      r0,[r0,#0]
00004e  6a01              LDR      r1,[r0,#0x20]
000050  4211              TST      r1,r2
000052  d106              BNE      |L69.98|
000054  6a01              LDR      r1,[r0,#0x20]
000056  4219              TST      r1,r3
000058  d103              BNE      |L69.98|
00005a  6801              LDR      r1,[r0,#0]
00005c  0849              LSRS     r1,r1,#1
00005e  0049              LSLS     r1,r1,#1
000060  6001              STR      r1,[r0,#0]
                  |L69.98|
;;;2134   
;;;2135     /* Return function status */
;;;2136     return HAL_OK;
;;;2137   }
000062  bc30              POP      {r4,r5}
000064  2000              MOVS     r0,#0                 ;2136
000066  4770              BX       lr
;;;2138   
                          ENDP

                  |L69.104|
                          DCD      0x40012c00
                  |L69.108|
                          DCD      0x00001111
                  |L69.112|
                          DCD      0x40014400
                  |L69.116|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_OnePulse_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Stop_IT PROC
;;;2186   */
;;;2187   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b430              PUSH     {r4,r5}
;;;2188   {
;;;2189     /* Disable the TIM Capture/Compare 1 interrupt */
;;;2190     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000002  6801              LDR      r1,[r0,#0]
000004  68ca              LDR      r2,[r1,#0xc]
000006  2302              MOVS     r3,#2
000008  439a              BICS     r2,r2,r3
00000a  60ca              STR      r2,[r1,#0xc]
;;;2191   
;;;2192     /* Disable the TIM Capture/Compare 2 interrupt */
;;;2193     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00000c  6801              LDR      r1,[r0,#0]
00000e  68cb              LDR      r3,[r1,#0xc]
000010  2204              MOVS     r2,#4
000012  4393              BICS     r3,r3,r2
000014  60cb              STR      r3,[r1,#0xc]
000016  6801              LDR      r1,[r0,#0]
000018  6a0a              LDR      r2,[r1,#0x20]
00001a  0852              LSRS     r2,r2,#1
00001c  0052              LSLS     r2,r2,#1
00001e  620a              STR      r2,[r1,#0x20]
000020  6a0a              LDR      r2,[r1,#0x20]
000022  620a              STR      r2,[r1,#0x20]
000024  6801              LDR      r1,[r0,#0]
000026  2210              MOVS     r2,#0x10
000028  6a0b              LDR      r3,[r1,#0x20]
00002a  4393              BICS     r3,r3,r2
00002c  620b              STR      r3,[r1,#0x20]
00002e  6a0a              LDR      r2,[r1,#0x20]
000030  620a              STR      r2,[r1,#0x20]
;;;2194   
;;;2195     /* Disable the Capture compare and the Input Capture channels 
;;;2196     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2197     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2198     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2199     in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
;;;2200     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
;;;2201     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
;;;2202   
;;;2203     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;2204     {
;;;2205       /* Disable the Main Ouput */
;;;2206       __HAL_TIM_MOE_DISABLE(htim);
000032  4a13              LDR      r2,|L70.128|
000034  4c11              LDR      r4,|L70.124|
000036  6801              LDR      r1,[r0,#0]            ;2203
000038  1093              ASRS     r3,r2,#2
00003a  42a1              CMP      r1,r4                 ;2203
00003c  d005              BEQ      |L70.74|
00003e  4c11              LDR      r4,|L70.132|
000040  42a1              CMP      r1,r4                 ;2203
000042  d002              BEQ      |L70.74|
000044  4c10              LDR      r4,|L70.136|
000046  42a1              CMP      r1,r4                 ;2203
000048  d10a              BNE      |L70.96|
                  |L70.74|
00004a  6a0c              LDR      r4,[r1,#0x20]
00004c  4214              TST      r4,r2
00004e  d107              BNE      |L70.96|
000050  6a0c              LDR      r4,[r1,#0x20]
000052  421c              TST      r4,r3
000054  d104              BNE      |L70.96|
000056  6c4c              LDR      r4,[r1,#0x44]
000058  2501              MOVS     r5,#1
00005a  03ed              LSLS     r5,r5,#15
00005c  43ac              BICS     r4,r4,r5
00005e  644c              STR      r4,[r1,#0x44]
                  |L70.96|
;;;2207     }
;;;2208   
;;;2209     /* Disable the Peripheral */
;;;2210      __HAL_TIM_DISABLE(htim);
000060  6800              LDR      r0,[r0,#0]
000062  6a01              LDR      r1,[r0,#0x20]
000064  4211              TST      r1,r2
000066  d106              BNE      |L70.118|
000068  6a01              LDR      r1,[r0,#0x20]
00006a  4219              TST      r1,r3
00006c  d103              BNE      |L70.118|
00006e  6801              LDR      r1,[r0,#0]
000070  0849              LSRS     r1,r1,#1
000072  0049              LSLS     r1,r1,#1
000074  6001              STR      r1,[r0,#0]
                  |L70.118|
;;;2211   
;;;2212     /* Return function status */
;;;2213     return HAL_OK;
;;;2214   }
000076  bc30              POP      {r4,r5}
000078  2000              MOVS     r0,#0                 ;2213
00007a  4770              BX       lr
;;;2215   
                          ENDP

                  |L70.124|
                          DCD      0x40012c00
                  |L70.128|
                          DCD      0x00001111
                  |L70.132|
                          DCD      0x40014400
                  |L70.136|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_PWM_ConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_ConfigChannel PROC
;;;3096     */
;;;3097   HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
000000  b5f8              PUSH     {r3-r7,lr}
;;;3098   {
000002  4604              MOV      r4,r0
;;;3099     __HAL_LOCK(htim);
000004  6bc0              LDR      r0,[r0,#0x3c]
000006  460d              MOV      r5,r1                 ;3098
000008  2801              CMP      r0,#1
00000a  d00d              BEQ      |L71.40|
00000c  2001              MOVS     r0,#1
;;;3100   
;;;3101     /* Check the parameters */
;;;3102     assert_param(IS_TIM_CHANNELS(Channel));
;;;3103     assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
;;;3104     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;3105     assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
;;;3106   
;;;3107     htim->State = HAL_TIM_STATE_BUSY;
00000e  63e0              STR      r0,[r4,#0x3c]
000010  2002              MOVS     r0,#2
000012  6420              STR      r0,[r4,#0x40]
;;;3108   
;;;3109     switch (Channel)
000014  2a00              CMP      r2,#0
000016  d009              BEQ      |L71.44|
;;;3110     {
;;;3111       case TIM_CHANNEL_1:
;;;3112       {
;;;3113         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3114         /* Configure the Channel 1 in PWM mode */
;;;3115         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;3116   
;;;3117         /* Set the Preload enable bit for channel1 */
;;;3118         htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
;;;3119   
;;;3120         /* Configure the Output Fast mode */
;;;3121         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
;;;3122         htim->Instance->CCMR1 |= sConfig->OCFastMode;
;;;3123       }
;;;3124       break;
;;;3125   
;;;3126       case TIM_CHANNEL_2:
;;;3127       {
;;;3128         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3129         /* Configure the Channel 2 in PWM mode */
;;;3130         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;3131   
;;;3132         /* Set the Preload enable bit for channel2 */
;;;3133         htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
000018  0286              LSLS     r6,r0,#10
00001a  2a04              CMP      r2,#4                 ;3109
00001c  d019              BEQ      |L71.82|
00001e  2a08              CMP      r2,#8                 ;3109
000020  d02b              BEQ      |L71.122|
000022  2a0c              CMP      r2,#0xc               ;3109
000024  d16c              BNE      |L71.256|
000026  e06c              B        |L71.258|
                  |L71.40|
000028  2002              MOVS     r0,#2                 ;3099
;;;3134   
;;;3135         /* Configure the Output Fast mode */
;;;3136         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
;;;3137         htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
;;;3138       }
;;;3139       break;
;;;3140   
;;;3141       case TIM_CHANNEL_3:
;;;3142       {
;;;3143         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3144         /* Configure the Channel 3 in PWM mode */
;;;3145         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;3146   
;;;3147         /* Set the Preload enable bit for channel3 */
;;;3148         htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
;;;3149   
;;;3150        /* Configure the Output Fast mode */
;;;3151         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
;;;3152         htim->Instance->CCMR2 |= sConfig->OCFastMode;
;;;3153       }
;;;3154       break;
;;;3155   
;;;3156       case TIM_CHANNEL_4:
;;;3157       {
;;;3158         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3159         /* Configure the Channel 4 in PWM mode */
;;;3160         TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;3161   
;;;3162         /* Set the Preload enable bit for channel4 */
;;;3163         htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
;;;3164   
;;;3165        /* Configure the Output Fast mode */
;;;3166         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
;;;3167         htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
;;;3168       }
;;;3169       break;
;;;3170   
;;;3171       default:
;;;3172       break;
;;;3173     }
;;;3174   
;;;3175     htim->State = HAL_TIM_STATE_READY;
;;;3176   
;;;3177     __HAL_UNLOCK(htim);
;;;3178   
;;;3179     return HAL_OK;
;;;3180   }
00002a  bdf8              POP      {r3-r7,pc}
                  |L71.44|
00002c  6820              LDR      r0,[r4,#0]            ;3115
00002e  f7fffffe          BL       TIM_OC1_SetConfig
000032  6820              LDR      r0,[r4,#0]            ;3118
000034  6981              LDR      r1,[r0,#0x18]         ;3118
000036  2208              MOVS     r2,#8                 ;3118
000038  4311              ORRS     r1,r1,r2              ;3118
00003a  6181              STR      r1,[r0,#0x18]         ;3118
00003c  6820              LDR      r0,[r4,#0]            ;3121
00003e  6981              LDR      r1,[r0,#0x18]         ;3121
000040  2204              MOVS     r2,#4                 ;3121
000042  4391              BICS     r1,r1,r2              ;3121
000044  6181              STR      r1,[r0,#0x18]         ;3121
000046  6820              LDR      r0,[r4,#0]            ;3122
000048  6981              LDR      r1,[r0,#0x18]         ;3122
00004a  692a              LDR      r2,[r5,#0x10]         ;3122
00004c  4311              ORRS     r1,r1,r2              ;3122
00004e  6181              STR      r1,[r0,#0x18]         ;3122
000050  e091              B        |L71.374|
                  |L71.82|
000052  6820              LDR      r0,[r4,#0]            ;3130
000054  f7fffffe          BL       TIM_OC2_SetConfig
000058  6820              LDR      r0,[r4,#0]            ;3133
00005a  6981              LDR      r1,[r0,#0x18]         ;3133
00005c  4331              ORRS     r1,r1,r6              ;3133
00005e  6181              STR      r1,[r0,#0x18]         ;3133
000060  6820              LDR      r0,[r4,#0]            ;3136
000062  6981              LDR      r1,[r0,#0x18]         ;3136
000064  2201              MOVS     r2,#1                 ;3136
000066  0292              LSLS     r2,r2,#10             ;3136
000068  4391              BICS     r1,r1,r2              ;3136
00006a  6181              STR      r1,[r0,#0x18]         ;3136
00006c  6820              LDR      r0,[r4,#0]            ;3137
00006e  6981              LDR      r1,[r0,#0x18]         ;3137
000070  692a              LDR      r2,[r5,#0x10]         ;3137
000072  0212              LSLS     r2,r2,#8              ;3137
000074  4311              ORRS     r1,r1,r2              ;3137
000076  6181              STR      r1,[r0,#0x18]         ;3137
000078  e07d              B        |L71.374|
                  |L71.122|
00007a  6820              LDR      r0,[r4,#0]            ;3139
00007c  6a01              LDR      r1,[r0,#0x20]         ;3139
00007e  22ff              MOVS     r2,#0xff              ;3139
000080  3201              ADDS     r2,#1                 ;3139
000082  4391              BICS     r1,r1,r2              ;3139
000084  6201              STR      r1,[r0,#0x20]         ;3139
000086  6a07              LDR      r7,[r0,#0x20]         ;3139
000088  6842              LDR      r2,[r0,#4]            ;3139
00008a  69c1              LDR      r1,[r0,#0x1c]         ;3139
00008c  2370              MOVS     r3,#0x70              ;3139
00008e  4399              BICS     r1,r1,r3              ;3139
000090  0889              LSRS     r1,r1,#2              ;3139
000092  682b              LDR      r3,[r5,#0]            ;3139
000094  0089              LSLS     r1,r1,#2              ;3139
000096  430b              ORRS     r3,r3,r1              ;3139
000098  2101              MOVS     r1,#1                 ;3139
00009a  0249              LSLS     r1,r1,#9              ;3139
00009c  438f              BICS     r7,r7,r1              ;3139
00009e  68a9              LDR      r1,[r5,#8]            ;3139
0000a0  0209              LSLS     r1,r1,#8              ;3139
0000a2  4339              ORRS     r1,r1,r7              ;3139
0000a4  4f36              LDR      r7,|L71.384|
0000a6  42b8              CMP      r0,r7                 ;3139
0000a8  d107              BNE      |L71.186|
0000aa  460f              MOV      r7,r1                 ;3139
0000ac  68e9              LDR      r1,[r5,#0xc]          ;3139
0000ae  43b7              BICS     r7,r7,r6              ;3139
0000b0  0209              LSLS     r1,r1,#8              ;3139
0000b2  4339              ORRS     r1,r1,r7              ;3139
0000b4  1506              ASRS     r6,r0,#20             ;3139
0000b6  43b1              BICS     r1,r1,r6              ;3139
0000b8  e005              B        |L71.198|
                  |L71.186|
0000ba  4e32              LDR      r6,|L71.388|
0000bc  42b0              CMP      r0,r6                 ;3139
0000be  d002              BEQ      |L71.198|
0000c0  4e31              LDR      r6,|L71.392|
0000c2  42b0              CMP      r0,r6                 ;3139
0000c4  d108              BNE      |L71.216|
                  |L71.198|
0000c6  2603              MOVS     r6,#3                 ;3139
0000c8  0336              LSLS     r6,r6,#12             ;3139
0000ca  43b2              BICS     r2,r2,r6              ;3139
0000cc  696e              LDR      r6,[r5,#0x14]         ;3139
0000ce  0136              LSLS     r6,r6,#4              ;3139
0000d0  4316              ORRS     r6,r6,r2              ;3139
0000d2  69aa              LDR      r2,[r5,#0x18]         ;3139
0000d4  0112              LSLS     r2,r2,#4              ;3139
0000d6  4332              ORRS     r2,r2,r6              ;3139
                  |L71.216|
0000d8  6042              STR      r2,[r0,#4]            ;3139
0000da  61c3              STR      r3,[r0,#0x1c]         ;3139
0000dc  686a              LDR      r2,[r5,#4]            ;3139
0000de  63c2              STR      r2,[r0,#0x3c]         ;3139
0000e0  6201              STR      r1,[r0,#0x20]         ;3139
0000e2  6820              LDR      r0,[r4,#0]            ;3148
0000e4  69c1              LDR      r1,[r0,#0x1c]         ;3148
0000e6  2208              MOVS     r2,#8                 ;3148
0000e8  4311              ORRS     r1,r1,r2              ;3148
0000ea  61c1              STR      r1,[r0,#0x1c]         ;3148
0000ec  6820              LDR      r0,[r4,#0]            ;3151
0000ee  69c2              LDR      r2,[r0,#0x1c]         ;3151
0000f0  2104              MOVS     r1,#4                 ;3151
0000f2  438a              BICS     r2,r2,r1              ;3151
0000f4  61c2              STR      r2,[r0,#0x1c]         ;3151
0000f6  6820              LDR      r0,[r4,#0]            ;3152
0000f8  69c1              LDR      r1,[r0,#0x1c]         ;3152
0000fa  692a              LDR      r2,[r5,#0x10]         ;3152
0000fc  4311              ORRS     r1,r1,r2              ;3152
0000fe  61c1              STR      r1,[r0,#0x1c]         ;3152
                  |L71.256|
000100  e039              B        |L71.374|
                  |L71.258|
000102  6820              LDR      r0,[r4,#0]            ;3154
000104  6a02              LDR      r2,[r0,#0x20]         ;3154
000106  2101              MOVS     r1,#1                 ;3154
000108  0309              LSLS     r1,r1,#12             ;3154
00010a  438a              BICS     r2,r2,r1              ;3154
00010c  6202              STR      r2,[r0,#0x20]         ;3154
00010e  6a02              LDR      r2,[r0,#0x20]         ;3154
000110  6841              LDR      r1,[r0,#4]            ;3154
000112  69c7              LDR      r7,[r0,#0x1c]         ;3154
000114  2373              MOVS     r3,#0x73              ;3154
000116  021b              LSLS     r3,r3,#8              ;3154
000118  439f              BICS     r7,r7,r3              ;3154
00011a  682b              LDR      r3,[r5,#0]            ;3154
00011c  021b              LSLS     r3,r3,#8              ;3154
00011e  433b              ORRS     r3,r3,r7              ;3154
000120  2701              MOVS     r7,#1                 ;3154
000122  037f              LSLS     r7,r7,#13             ;3154
000124  43ba              BICS     r2,r2,r7              ;3154
000126  68af              LDR      r7,[r5,#8]            ;3154
000128  033f              LSLS     r7,r7,#12             ;3154
00012a  4317              ORRS     r7,r7,r2              ;3154
00012c  4a14              LDR      r2,|L71.384|
00012e  4290              CMP      r0,r2                 ;3154
000130  d005              BEQ      |L71.318|
000132  4a14              LDR      r2,|L71.388|
000134  4290              CMP      r0,r2                 ;3160
000136  d002              BEQ      |L71.318|
000138  4a13              LDR      r2,|L71.392|
00013a  4290              CMP      r0,r2                 ;3160
00013c  d106              BNE      |L71.332|
                  |L71.318|
00013e  460a              MOV      r2,r1                 ;3160
000140  2101              MOVS     r1,#1                 ;3160
000142  0389              LSLS     r1,r1,#14             ;3160
000144  438a              BICS     r2,r2,r1              ;3160
000146  6969              LDR      r1,[r5,#0x14]         ;3160
000148  0189              LSLS     r1,r1,#6              ;3160
00014a  4311              ORRS     r1,r1,r2              ;3160
                  |L71.332|
00014c  6041              STR      r1,[r0,#4]            ;3160
00014e  61c3              STR      r3,[r0,#0x1c]         ;3160
000150  6869              LDR      r1,[r5,#4]            ;3160
000152  6401              STR      r1,[r0,#0x40]         ;3160
000154  6207              STR      r7,[r0,#0x20]         ;3160
000156  6820              LDR      r0,[r4,#0]            ;3163
000158  69c1              LDR      r1,[r0,#0x1c]         ;3163
00015a  4331              ORRS     r1,r1,r6              ;3163
00015c  61c1              STR      r1,[r0,#0x1c]         ;3163
00015e  6820              LDR      r0,[r4,#0]            ;3166
000160  69c2              LDR      r2,[r0,#0x1c]         ;3166
000162  2101              MOVS     r1,#1                 ;3166
000164  0289              LSLS     r1,r1,#10             ;3166
000166  438a              BICS     r2,r2,r1              ;3166
000168  61c2              STR      r2,[r0,#0x1c]         ;3166
00016a  6820              LDR      r0,[r4,#0]            ;3167
00016c  69c1              LDR      r1,[r0,#0x1c]         ;3167
00016e  692a              LDR      r2,[r5,#0x10]         ;3167
000170  0212              LSLS     r2,r2,#8              ;3167
000172  4311              ORRS     r1,r1,r2              ;3167
000174  61c1              STR      r1,[r0,#0x1c]         ;3167
                  |L71.374|
000176  2001              MOVS     r0,#1                 ;3175
000178  6420              STR      r0,[r4,#0x40]         ;3175
00017a  2000              MOVS     r0,#0                 ;3177
00017c  63e0              STR      r0,[r4,#0x3c]         ;3177
00017e  bdf8              POP      {r3-r7,pc}
;;;3181   
                          ENDP

                  |L71.384|
                          DCD      0x40012c00
                  |L71.388|
                          DCD      0x40014400
                  |L71.392|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_PWM_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_DeInit PROC
;;;1027     */
;;;1028   HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1029   {
000002  4604              MOV      r4,r0
;;;1030     /* Check the parameters */
;;;1031     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1032   
;;;1033     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  6420              STR      r0,[r4,#0x40]
;;;1034   
;;;1035     /* Disable the TIM Peripheral Clock */
;;;1036     __HAL_TIM_DISABLE(htim);
000008  6820              LDR      r0,[r4,#0]
00000a  6a01              LDR      r1,[r0,#0x20]
00000c  4a08              LDR      r2,|L72.48|
00000e  4211              TST      r1,r2
000010  d107              BNE      |L72.34|
000012  6a01              LDR      r1,[r0,#0x20]
000014  1092              ASRS     r2,r2,#2
000016  4211              TST      r1,r2
000018  d103              BNE      |L72.34|
00001a  6801              LDR      r1,[r0,#0]
00001c  0849              LSRS     r1,r1,#1
00001e  0049              LSLS     r1,r1,#1
000020  6001              STR      r1,[r0,#0]
                  |L72.34|
;;;1037   
;;;1038     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;1039     HAL_TIM_PWM_MspDeInit(htim);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       HAL_TIM_PWM_MspDeInit
;;;1040   
;;;1041     /* Change TIM state */
;;;1042     htim->State = HAL_TIM_STATE_RESET;
000028  2000              MOVS     r0,#0
00002a  6420              STR      r0,[r4,#0x40]
;;;1043   
;;;1044     /* Release Lock */
;;;1045     __HAL_UNLOCK(htim);
00002c  63e0              STR      r0,[r4,#0x3c]
;;;1046   
;;;1047     return HAL_OK;
;;;1048   }
00002e  bd10              POP      {r4,pc}
;;;1049   
                          ENDP

                  |L72.48|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_PWM_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_GetState PROC
;;;4512     */
;;;4513   HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
000000  6c00              LDR      r0,[r0,#0x40]
;;;4514   {
;;;4515     return htim->State;
;;;4516   }
000002  4770              BX       lr
;;;4517   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_Init PROC
;;;987      */
;;;988    HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
000000  2800              CMP      r0,#0
;;;989    {
;;;990      /* Check the TIM handle allocation */
;;;991      if(htim == NULL)
000002  d101              BNE      |L74.8|
;;;992      {
;;;993        return HAL_ERROR;
000004  2001              MOVS     r0,#1
;;;994      }
;;;995    
;;;996      /* Check the parameters */
;;;997      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;998      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;999      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;1000     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;1001   
;;;1002     if(htim->State == HAL_TIM_STATE_RESET)
;;;1003     {
;;;1004       /* Allocate lock resource and initialize it */
;;;1005       htim->Lock = HAL_UNLOCKED;
;;;1006   
;;;1007       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1008       HAL_TIM_PWM_MspInit(htim);
;;;1009     }
;;;1010   
;;;1011     /* Set the TIM state */
;;;1012     htim->State= HAL_TIM_STATE_BUSY;
;;;1013   
;;;1014     /* Init the base time for the PWM */
;;;1015     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;1016   
;;;1017     /* Initialize the TIM state*/
;;;1018     htim->State= HAL_TIM_STATE_READY;
;;;1019   
;;;1020     return HAL_OK;
;;;1021   }
000006  4770              BX       lr
                  |L74.8|
000008  b510              PUSH     {r4,lr}               ;989
00000a  4604              MOV      r4,r0                 ;989
00000c  6c00              LDR      r0,[r0,#0x40]         ;1002
00000e  2800              CMP      r0,#0                 ;1002
000010  d103              BNE      |L74.26|
000012  63e0              STR      r0,[r4,#0x3c]         ;1008
000014  4620              MOV      r0,r4                 ;1008
000016  f7fffffe          BL       HAL_TIM_PWM_MspInit
                  |L74.26|
00001a  2002              MOVS     r0,#2                 ;1012
00001c  6420              STR      r0,[r4,#0x40]         ;1012
00001e  1d21              ADDS     r1,r4,#4              ;1015
000020  6820              LDR      r0,[r4,#0]            ;1015
000022  f7fffffe          BL       TIM_Base_SetConfig
000026  2001              MOVS     r0,#1                 ;1018
000028  6420              STR      r0,[r4,#0x40]         ;1018
00002a  2000              MOVS     r0,#0                 ;1020
00002c  bd10              POP      {r4,pc}
;;;1022   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_MspDeInit PROC
;;;1069     */
;;;1070   __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1071   {
;;;1072     /* Prevent unused argument(s) compilation warning */
;;;1073     UNUSED(htim);
;;;1074   
;;;1075     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1076               the HAL_TIM_PWM_MspDeInit could be implemented in the user file
;;;1077      */
;;;1078   }
;;;1079   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_MspInit PROC
;;;1054     */
;;;1055   __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1056   {
;;;1057     /* Prevent unused argument(s) compilation warning */
;;;1058     UNUSED(htim);
;;;1059   
;;;1060     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1061               the HAL_TIM_PWM_MspInit could be implemented in the user file
;;;1062      */
;;;1063   }
;;;1064   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_PulseFinishedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_PulseFinishedCallback PROC
;;;4428     */
;;;4429   __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4430   {
;;;4431     /* Prevent unused argument(s) compilation warning */
;;;4432     UNUSED(htim);
;;;4433   
;;;4434     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4435               the __HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
;;;4436      */
;;;4437   }
;;;4438   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start PROC
;;;1090   */
;;;1091   HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b410              PUSH     {r4}
000002  2401              MOVS     r4,#1
000004  4622              MOV      r2,r4
000006  6803              LDR      r3,[r0,#0]
000008  408a              LSLS     r2,r2,r1
00000a  6a19              LDR      r1,[r3,#0x20]
00000c  4391              BICS     r1,r1,r2
00000e  6219              STR      r1,[r3,#0x20]
000010  6a19              LDR      r1,[r3,#0x20]
000012  4311              ORRS     r1,r1,r2
000014  6219              STR      r1,[r3,#0x20]
;;;1092   {
;;;1093     /* Check the parameters */
;;;1094     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1095   
;;;1096     /* Enable the Capture compare channel */
;;;1097     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1098   
;;;1099     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000016  4a0b              LDR      r2,|L78.68|
000018  6801              LDR      r1,[r0,#0]
00001a  4291              CMP      r1,r2
00001c  d005              BEQ      |L78.42|
00001e  4a0a              LDR      r2,|L78.72|
000020  4291              CMP      r1,r2
000022  d002              BEQ      |L78.42|
000024  4a09              LDR      r2,|L78.76|
000026  4291              CMP      r1,r2
000028  d104              BNE      |L78.52|
                  |L78.42|
;;;1100     {
;;;1101       /* Enable the main output */
;;;1102       __HAL_TIM_MOE_ENABLE(htim);
00002a  6c4a              LDR      r2,[r1,#0x44]
00002c  2301              MOVS     r3,#1
00002e  03db              LSLS     r3,r3,#15
000030  431a              ORRS     r2,r2,r3
000032  644a              STR      r2,[r1,#0x44]
                  |L78.52|
;;;1103     }
;;;1104   
;;;1105     /* Enable the Peripheral */
;;;1106     __HAL_TIM_ENABLE(htim);
000034  6800              LDR      r0,[r0,#0]
000036  6801              LDR      r1,[r0,#0]
000038  4321              ORRS     r1,r1,r4
00003a  6001              STR      r1,[r0,#0]
;;;1107   
;;;1108     /* Return function status */
;;;1109     return HAL_OK;
;;;1110   }
00003c  bc10              POP      {r4}
00003e  2000              MOVS     r0,#0                 ;1109
000040  4770              BX       lr
;;;1111   
                          ENDP

000042  0000              DCW      0x0000
                  |L78.68|
                          DCD      0x40012c00
                  |L78.72|
                          DCD      0x40014400
                  |L78.76|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_PWM_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start_DMA PROC
;;;1291   */
;;;1292   HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;1293   {
000002  4604              MOV      r4,r0
;;;1294     /* Check the parameters */
;;;1295     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1296   
;;;1297     if((htim->State == HAL_TIM_STATE_BUSY))
000004  6c00              LDR      r0,[r0,#0x40]
000006  4616              MOV      r6,r2                 ;1293
000008  460d              MOV      r5,r1                 ;1293
00000a  2802              CMP      r0,#2
00000c  d006              BEQ      |L79.28|
;;;1298     {
;;;1299        return HAL_BUSY;
;;;1300     }
;;;1301     else if((htim->State == HAL_TIM_STATE_READY))
00000e  6c20              LDR      r0,[r4,#0x40]
000010  2801              CMP      r0,#1
000012  d106              BNE      |L79.34|
;;;1302     {
;;;1303       if(((uint32_t)pData == 0U ) && (Length > 0U))
000014  2e00              CMP      r6,#0
000016  d102              BNE      |L79.30|
000018  2b00              CMP      r3,#0
00001a  d000              BEQ      |L79.30|
                  |L79.28|
;;;1304       {
;;;1305         return HAL_ERROR;
;;;1306       }
;;;1307       else
;;;1308       {
;;;1309         htim->State = HAL_TIM_STATE_BUSY;
;;;1310       }
;;;1311     }
;;;1312     switch (Channel)
;;;1313     {
;;;1314       case TIM_CHANNEL_1:
;;;1315       {
;;;1316         /* Set the DMA Period elapsed callback */
;;;1317         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1318   
;;;1319         /* Set the DMA error callback */
;;;1320         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;1321   
;;;1322         /* Enable the DMA channel */
;;;1323         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;1324   
;;;1325         /* Enable the TIM Capture/Compare 1 DMA request */
;;;1326         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1327       }
;;;1328       break;
;;;1329   
;;;1330       case TIM_CHANNEL_2:
;;;1331       {
;;;1332         /* Set the DMA Period elapsed callback */
;;;1333         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1334   
;;;1335         /* Set the DMA error callback */
;;;1336         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;1337   
;;;1338         /* Enable the DMA channel */
;;;1339         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;1340   
;;;1341         /* Enable the TIM Capture/Compare 2 DMA request */
;;;1342         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1343       }
;;;1344       break;
;;;1345   
;;;1346       case TIM_CHANNEL_3:
;;;1347       {
;;;1348         /* Set the DMA Period elapsed callback */
;;;1349         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1350   
;;;1351         /* Set the DMA error callback */
;;;1352         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;1353   
;;;1354         /* Enable the DMA channel */
;;;1355         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;1356   
;;;1357         /* Enable the TIM Output Capture/Compare 3 request */
;;;1358         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1359       }
;;;1360       break;
;;;1361   
;;;1362       case TIM_CHANNEL_4:
;;;1363       {
;;;1364        /* Set the DMA Period elapsed callback */
;;;1365         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1366   
;;;1367         /* Set the DMA error callback */
;;;1368         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;1369   
;;;1370         /* Enable the DMA channel */
;;;1371         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;1372   
;;;1373         /* Enable the TIM Capture/Compare 4 DMA request */
;;;1374         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1375       }
;;;1376       break;
;;;1377   
;;;1378       default:
;;;1379       break;
;;;1380     }
;;;1381   
;;;1382     /* Enable the Capture compare channel */
;;;1383     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1384   
;;;1385     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;1386     {
;;;1387       /* Enable the main output */
;;;1388       __HAL_TIM_MOE_ENABLE(htim);
;;;1389     }
;;;1390   
;;;1391     /* Enable the Peripheral */
;;;1392     __HAL_TIM_ENABLE(htim);
;;;1393   
;;;1394     /* Return function status */
;;;1395     return HAL_OK;
;;;1396   }
00001c  bd70              POP      {r4-r6,pc}
                  |L79.30|
00001e  2002              MOVS     r0,#2                 ;1309
000020  6420              STR      r0,[r4,#0x40]         ;1309
                  |L79.34|
000022  4836              LDR      r0,|L79.252|
000024  4936              LDR      r1,|L79.256|
000026  2d00              CMP      r5,#0                 ;1312
000028  d006              BEQ      |L79.56|
00002a  2d04              CMP      r5,#4                 ;1312
00002c  d015              BEQ      |L79.90|
00002e  2d08              CMP      r5,#8                 ;1312
000030  d024              BEQ      |L79.124|
000032  2d0c              CMP      r5,#0xc               ;1312
000034  d143              BNE      |L79.190|
000036  e032              B        |L79.158|
                  |L79.56|
000038  6a62              LDR      r2,[r4,#0x24]         ;1317
00003a  62d0              STR      r0,[r2,#0x2c]         ;1320
00003c  6a60              LDR      r0,[r4,#0x24]         ;1320
00003e  6341              STR      r1,[r0,#0x34]         ;1323
000040  6822              LDR      r2,[r4,#0]            ;1323
000042  4631              MOV      r1,r6                 ;1323
000044  3234              ADDS     r2,r2,#0x34           ;1323
000046  6a60              LDR      r0,[r4,#0x24]         ;1323
000048  f7fffffe          BL       HAL_DMA_Start_IT
00004c  6820              LDR      r0,[r4,#0]            ;1326
00004e  68c1              LDR      r1,[r0,#0xc]          ;1326
000050  2201              MOVS     r2,#1                 ;1326
000052  0252              LSLS     r2,r2,#9              ;1326
000054  4311              ORRS     r1,r1,r2              ;1326
000056  60c1              STR      r1,[r0,#0xc]          ;1326
000058  e031              B        |L79.190|
                  |L79.90|
00005a  6aa2              LDR      r2,[r4,#0x28]         ;1333
00005c  62d0              STR      r0,[r2,#0x2c]         ;1336
00005e  6aa0              LDR      r0,[r4,#0x28]         ;1336
000060  6341              STR      r1,[r0,#0x34]         ;1339
000062  6822              LDR      r2,[r4,#0]            ;1339
000064  4631              MOV      r1,r6                 ;1339
000066  3238              ADDS     r2,r2,#0x38           ;1339
000068  6aa0              LDR      r0,[r4,#0x28]         ;1339
00006a  f7fffffe          BL       HAL_DMA_Start_IT
00006e  6820              LDR      r0,[r4,#0]            ;1342
000070  68c1              LDR      r1,[r0,#0xc]          ;1342
000072  2201              MOVS     r2,#1                 ;1342
000074  0292              LSLS     r2,r2,#10             ;1342
000076  4311              ORRS     r1,r1,r2              ;1342
000078  60c1              STR      r1,[r0,#0xc]          ;1342
00007a  e020              B        |L79.190|
                  |L79.124|
00007c  6ae2              LDR      r2,[r4,#0x2c]         ;1349
00007e  62d0              STR      r0,[r2,#0x2c]         ;1352
000080  6ae0              LDR      r0,[r4,#0x2c]         ;1352
000082  6341              STR      r1,[r0,#0x34]         ;1355
000084  6822              LDR      r2,[r4,#0]            ;1355
000086  4631              MOV      r1,r6                 ;1355
000088  323c              ADDS     r2,r2,#0x3c           ;1355
00008a  6ae0              LDR      r0,[r4,#0x2c]         ;1355
00008c  f7fffffe          BL       HAL_DMA_Start_IT
000090  6820              LDR      r0,[r4,#0]            ;1358
000092  68c1              LDR      r1,[r0,#0xc]          ;1358
000094  2201              MOVS     r2,#1                 ;1358
000096  02d2              LSLS     r2,r2,#11             ;1358
000098  4311              ORRS     r1,r1,r2              ;1358
00009a  60c1              STR      r1,[r0,#0xc]          ;1358
00009c  e00f              B        |L79.190|
                  |L79.158|
00009e  6b22              LDR      r2,[r4,#0x30]         ;1365
0000a0  62d0              STR      r0,[r2,#0x2c]         ;1368
0000a2  6b20              LDR      r0,[r4,#0x30]         ;1368
0000a4  6341              STR      r1,[r0,#0x34]         ;1371
0000a6  6822              LDR      r2,[r4,#0]            ;1371
0000a8  4631              MOV      r1,r6                 ;1371
0000aa  3240              ADDS     r2,r2,#0x40           ;1371
0000ac  6b20              LDR      r0,[r4,#0x30]         ;1371
0000ae  f7fffffe          BL       HAL_DMA_Start_IT
0000b2  6820              LDR      r0,[r4,#0]            ;1374
0000b4  68c1              LDR      r1,[r0,#0xc]          ;1374
0000b6  2201              MOVS     r2,#1                 ;1374
0000b8  0312              LSLS     r2,r2,#12             ;1374
0000ba  4311              ORRS     r1,r1,r2              ;1374
0000bc  60c1              STR      r1,[r0,#0xc]          ;1374
                  |L79.190|
0000be  6821              LDR      r1,[r4,#0]            ;1374
0000c0  2201              MOVS     r2,#1                 ;1374
0000c2  4610              MOV      r0,r2                 ;1374
0000c4  6a0b              LDR      r3,[r1,#0x20]         ;1374
0000c6  40a8              LSLS     r0,r0,r5              ;1374
0000c8  4383              BICS     r3,r3,r0              ;1374
0000ca  620b              STR      r3,[r1,#0x20]         ;1374
0000cc  6a0b              LDR      r3,[r1,#0x20]         ;1374
0000ce  4303              ORRS     r3,r3,r0              ;1374
0000d0  620b              STR      r3,[r1,#0x20]         ;1374
0000d2  480c              LDR      r0,|L79.260|
0000d4  6821              LDR      r1,[r4,#0]            ;1385
0000d6  4281              CMP      r1,r0                 ;1385
0000d8  d005              BEQ      |L79.230|
0000da  480b              LDR      r0,|L79.264|
0000dc  4281              CMP      r1,r0                 ;1385
0000de  d002              BEQ      |L79.230|
0000e0  480a              LDR      r0,|L79.268|
0000e2  4281              CMP      r1,r0                 ;1385
0000e4  d104              BNE      |L79.240|
                  |L79.230|
0000e6  6c48              LDR      r0,[r1,#0x44]         ;1388
0000e8  2301              MOVS     r3,#1                 ;1388
0000ea  03db              LSLS     r3,r3,#15             ;1388
0000ec  4318              ORRS     r0,r0,r3              ;1388
0000ee  6448              STR      r0,[r1,#0x44]         ;1388
                  |L79.240|
0000f0  6820              LDR      r0,[r4,#0]            ;1392
0000f2  6801              LDR      r1,[r0,#0]            ;1392
0000f4  4311              ORRS     r1,r1,r2              ;1392
0000f6  6001              STR      r1,[r0,#0]            ;1392
0000f8  2000              MOVS     r0,#0                 ;1395
0000fa  bd70              POP      {r4-r6,pc}
;;;1397   
                          ENDP

                  |L79.252|
                          DCD      TIM_DMADelayPulseCplt
                  |L79.256|
                          DCD      TIM_DMAError
                  |L79.260|
                          DCD      0x40012c00
                  |L79.264|
                          DCD      0x40014400
                  |L79.268|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_PWM_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start_IT PROC
;;;1157   */
;;;1158   HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b410              PUSH     {r4}
;;;1159   {
;;;1160     /* Check the parameters */
;;;1161     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1162   
;;;1163     switch (Channel)
000002  6802              LDR      r2,[r0,#0]
000004  2900              CMP      r1,#0
000006  d006              BEQ      |L80.22|
000008  2904              CMP      r1,#4
00000a  d009              BEQ      |L80.32|
00000c  2908              CMP      r1,#8
00000e  d00c              BEQ      |L80.42|
000010  290c              CMP      r1,#0xc
000012  d113              BNE      |L80.60|
000014  e00e              B        |L80.52|
                  |L80.22|
;;;1164     {
;;;1165       case TIM_CHANNEL_1:
;;;1166       {
;;;1167         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1168         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000016  68d3              LDR      r3,[r2,#0xc]
000018  2402              MOVS     r4,#2
00001a  4323              ORRS     r3,r3,r4
00001c  60d3              STR      r3,[r2,#0xc]
;;;1169       }
;;;1170       break;
00001e  e00d              B        |L80.60|
                  |L80.32|
;;;1171   
;;;1172       case TIM_CHANNEL_2:
;;;1173       {
;;;1174         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1175         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000020  68d3              LDR      r3,[r2,#0xc]
000022  2404              MOVS     r4,#4
000024  4323              ORRS     r3,r3,r4
000026  60d3              STR      r3,[r2,#0xc]
;;;1176       }
;;;1177       break;
000028  e008              B        |L80.60|
                  |L80.42|
;;;1178   
;;;1179       case TIM_CHANNEL_3:
;;;1180       {
;;;1181         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1182         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
00002a  68d3              LDR      r3,[r2,#0xc]
00002c  2408              MOVS     r4,#8
00002e  4323              ORRS     r3,r3,r4
000030  60d3              STR      r3,[r2,#0xc]
;;;1183       }
;;;1184       break;
000032  e003              B        |L80.60|
                  |L80.52|
;;;1185   
;;;1186       case TIM_CHANNEL_4:
;;;1187       {
;;;1188         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1189         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000034  68d3              LDR      r3,[r2,#0xc]
000036  2410              MOVS     r4,#0x10
000038  4323              ORRS     r3,r3,r4
00003a  60d3              STR      r3,[r2,#0xc]
                  |L80.60|
00003c  2401              MOVS     r4,#1
00003e  4622              MOV      r2,r4
000040  6803              LDR      r3,[r0,#0]
000042  408a              LSLS     r2,r2,r1
000044  6a19              LDR      r1,[r3,#0x20]
000046  4391              BICS     r1,r1,r2
000048  6219              STR      r1,[r3,#0x20]
00004a  6a19              LDR      r1,[r3,#0x20]
00004c  4311              ORRS     r1,r1,r2
00004e  6219              STR      r1,[r3,#0x20]
;;;1190       }
;;;1191       break;
;;;1192   
;;;1193       default:
;;;1194       break;
;;;1195     }
;;;1196   
;;;1197     /* Enable the Capture compare channel */
;;;1198     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1199   
;;;1200     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000050  4a0a              LDR      r2,|L80.124|
000052  6801              LDR      r1,[r0,#0]
000054  4291              CMP      r1,r2
000056  d005              BEQ      |L80.100|
000058  4a09              LDR      r2,|L80.128|
00005a  4291              CMP      r1,r2
00005c  d002              BEQ      |L80.100|
00005e  4a09              LDR      r2,|L80.132|
000060  4291              CMP      r1,r2
000062  d104              BNE      |L80.110|
                  |L80.100|
;;;1201     {
;;;1202       /* Enable the main output */
;;;1203       __HAL_TIM_MOE_ENABLE(htim);
000064  6c4a              LDR      r2,[r1,#0x44]
000066  2301              MOVS     r3,#1
000068  03db              LSLS     r3,r3,#15
00006a  431a              ORRS     r2,r2,r3
00006c  644a              STR      r2,[r1,#0x44]
                  |L80.110|
;;;1204     }
;;;1205   
;;;1206     /* Enable the Peripheral */
;;;1207     __HAL_TIM_ENABLE(htim);
00006e  6800              LDR      r0,[r0,#0]
000070  6801              LDR      r1,[r0,#0]
000072  4321              ORRS     r1,r1,r4
000074  6001              STR      r1,[r0,#0]
;;;1208   
;;;1209     /* Return function status */
;;;1210     return HAL_OK;
;;;1211   }
000076  bc10              POP      {r4}
000078  2000              MOVS     r0,#0                 ;1210
00007a  4770              BX       lr
;;;1212   
                          ENDP

                  |L80.124|
                          DCD      0x40012c00
                  |L80.128|
                          DCD      0x40014400
                  |L80.132|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_PWM_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop PROC
;;;1122   */
;;;1123   HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b470              PUSH     {r4-r6}
000002  6802              LDR      r2,[r0,#0]
000004  2401              MOVS     r4,#1
;;;1124   {
;;;1125     /* Check the parameters */
;;;1126     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1127   
;;;1128     /* Disable the Capture compare channel */
;;;1129     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000006  2500              MOVS     r5,#0
000008  4623              MOV      r3,r4
00000a  6a16              LDR      r6,[r2,#0x20]
00000c  408b              LSLS     r3,r3,r1
00000e  439e              BICS     r6,r6,r3
000010  6216              STR      r6,[r2,#0x20]
000012  6a13              LDR      r3,[r2,#0x20]
000014  408d              LSLS     r5,r5,r1
000016  432b              ORRS     r3,r3,r5
000018  6213              STR      r3,[r2,#0x20]
;;;1130   
;;;1131     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;1132     {
;;;1133       /* Disable the Main Ouput */
;;;1134       __HAL_TIM_MOE_DISABLE(htim);
00001a  4a14              LDR      r2,|L81.108|
00001c  4d12              LDR      r5,|L81.104|
00001e  6801              LDR      r1,[r0,#0]            ;1131
000020  1093              ASRS     r3,r2,#2
000022  42a9              CMP      r1,r5                 ;1131
000024  d005              BEQ      |L81.50|
000026  4d12              LDR      r5,|L81.112|
000028  42a9              CMP      r1,r5                 ;1131
00002a  d002              BEQ      |L81.50|
00002c  4d11              LDR      r5,|L81.116|
00002e  42a9              CMP      r1,r5                 ;1131
000030  d10a              BNE      |L81.72|
                  |L81.50|
000032  6a0d              LDR      r5,[r1,#0x20]
000034  4215              TST      r5,r2
000036  d107              BNE      |L81.72|
000038  6a0d              LDR      r5,[r1,#0x20]
00003a  421d              TST      r5,r3
00003c  d104              BNE      |L81.72|
00003e  6c4d              LDR      r5,[r1,#0x44]
000040  2601              MOVS     r6,#1
000042  03f6              LSLS     r6,r6,#15
000044  43b5              BICS     r5,r5,r6
000046  644d              STR      r5,[r1,#0x44]
                  |L81.72|
;;;1135     }
;;;1136   
;;;1137     /* Disable the Peripheral */
;;;1138     __HAL_TIM_DISABLE(htim);
000048  6801              LDR      r1,[r0,#0]
00004a  6a0d              LDR      r5,[r1,#0x20]
00004c  4215              TST      r5,r2
00004e  d106              BNE      |L81.94|
000050  6a0a              LDR      r2,[r1,#0x20]
000052  421a              TST      r2,r3
000054  d103              BNE      |L81.94|
000056  680a              LDR      r2,[r1,#0]
000058  0852              LSRS     r2,r2,#1
00005a  0052              LSLS     r2,r2,#1
00005c  600a              STR      r2,[r1,#0]
                  |L81.94|
;;;1139   
;;;1140     /* Change the htim state */
;;;1141     htim->State = HAL_TIM_STATE_READY;
00005e  6404              STR      r4,[r0,#0x40]
;;;1142   
;;;1143     /* Return function status */
;;;1144     return HAL_OK;
;;;1145   }
000060  bc70              POP      {r4-r6}
000062  2000              MOVS     r0,#0                 ;1144
000064  4770              BX       lr
;;;1146   
                          ENDP

000066  0000              DCW      0x0000
                  |L81.104|
                          DCD      0x40012c00
                  |L81.108|
                          DCD      0x00001111
                  |L81.112|
                          DCD      0x40014400
                  |L81.116|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_PWM_Stop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop_DMA PROC
;;;1408   */
;;;1409   HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b470              PUSH     {r4-r6}
;;;1410   {
;;;1411     /* Check the parameters */
;;;1412     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1413   
;;;1414     switch (Channel)
000002  6802              LDR      r2,[r0,#0]
000004  2900              CMP      r1,#0
000006  d006              BEQ      |L82.22|
000008  2904              CMP      r1,#4
00000a  d00a              BEQ      |L82.34|
00000c  2908              CMP      r1,#8
00000e  d00e              BEQ      |L82.46|
000010  290c              CMP      r1,#0xc
000012  d117              BNE      |L82.68|
000014  e011              B        |L82.58|
                  |L82.22|
;;;1415     {
;;;1416       case TIM_CHANNEL_1:
;;;1417       {
;;;1418         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1419         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000016  68d3              LDR      r3,[r2,#0xc]
000018  2401              MOVS     r4,#1
00001a  0264              LSLS     r4,r4,#9
00001c  43a3              BICS     r3,r3,r4
00001e  60d3              STR      r3,[r2,#0xc]
;;;1420       }
;;;1421       break;
000020  e010              B        |L82.68|
                  |L82.34|
;;;1422   
;;;1423       case TIM_CHANNEL_2:
;;;1424       {
;;;1425         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1426         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000022  68d3              LDR      r3,[r2,#0xc]
000024  2401              MOVS     r4,#1
000026  02a4              LSLS     r4,r4,#10
000028  43a3              BICS     r3,r3,r4
00002a  60d3              STR      r3,[r2,#0xc]
;;;1427       }
;;;1428       break;
00002c  e00a              B        |L82.68|
                  |L82.46|
;;;1429   
;;;1430       case TIM_CHANNEL_3:
;;;1431       {
;;;1432         /* Disable the TIM Capture/Compare 3 DMA request */
;;;1433         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
00002e  68d3              LDR      r3,[r2,#0xc]
000030  2401              MOVS     r4,#1
000032  02e4              LSLS     r4,r4,#11
000034  43a3              BICS     r3,r3,r4
000036  60d3              STR      r3,[r2,#0xc]
;;;1434       }
;;;1435       break;
000038  e004              B        |L82.68|
                  |L82.58|
;;;1436   
;;;1437       case TIM_CHANNEL_4:
;;;1438       {
;;;1439         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1440         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
00003a  68d3              LDR      r3,[r2,#0xc]
00003c  2401              MOVS     r4,#1
00003e  0324              LSLS     r4,r4,#12
000040  43a3              BICS     r3,r3,r4
000042  60d3              STR      r3,[r2,#0xc]
                  |L82.68|
000044  6802              LDR      r2,[r0,#0]
000046  2401              MOVS     r4,#1
;;;1441       }
;;;1442       break;
;;;1443   
;;;1444       default:
;;;1445       break;
;;;1446     }
;;;1447   
;;;1448     /* Disable the Capture compare channel */
;;;1449     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000048  2500              MOVS     r5,#0
00004a  4623              MOV      r3,r4
00004c  6a16              LDR      r6,[r2,#0x20]
00004e  408b              LSLS     r3,r3,r1
000050  439e              BICS     r6,r6,r3
000052  6216              STR      r6,[r2,#0x20]
000054  6a13              LDR      r3,[r2,#0x20]
000056  408d              LSLS     r5,r5,r1
000058  432b              ORRS     r3,r3,r5
00005a  6213              STR      r3,[r2,#0x20]
;;;1450   
;;;1451     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;1452     {
;;;1453       /* Disable the Main Ouput */
;;;1454       __HAL_TIM_MOE_DISABLE(htim);
00005c  4a13              LDR      r2,|L82.172|
00005e  4d12              LDR      r5,|L82.168|
000060  6801              LDR      r1,[r0,#0]            ;1451
000062  1093              ASRS     r3,r2,#2
000064  42a9              CMP      r1,r5                 ;1451
000066  d005              BEQ      |L82.116|
000068  4d11              LDR      r5,|L82.176|
00006a  42a9              CMP      r1,r5                 ;1451
00006c  d002              BEQ      |L82.116|
00006e  4d11              LDR      r5,|L82.180|
000070  42a9              CMP      r1,r5                 ;1451
000072  d10a              BNE      |L82.138|
                  |L82.116|
000074  6a0d              LDR      r5,[r1,#0x20]
000076  4215              TST      r5,r2
000078  d107              BNE      |L82.138|
00007a  6a0d              LDR      r5,[r1,#0x20]
00007c  421d              TST      r5,r3
00007e  d104              BNE      |L82.138|
000080  6c4d              LDR      r5,[r1,#0x44]
000082  2601              MOVS     r6,#1
000084  03f6              LSLS     r6,r6,#15
000086  43b5              BICS     r5,r5,r6
000088  644d              STR      r5,[r1,#0x44]
                  |L82.138|
;;;1455     }
;;;1456   
;;;1457     /* Disable the Peripheral */
;;;1458     __HAL_TIM_DISABLE(htim);
00008a  6801              LDR      r1,[r0,#0]
00008c  6a0d              LDR      r5,[r1,#0x20]
00008e  4215              TST      r5,r2
000090  d106              BNE      |L82.160|
000092  6a0a              LDR      r2,[r1,#0x20]
000094  421a              TST      r2,r3
000096  d103              BNE      |L82.160|
000098  680a              LDR      r2,[r1,#0]
00009a  0852              LSRS     r2,r2,#1
00009c  0052              LSLS     r2,r2,#1
00009e  600a              STR      r2,[r1,#0]
                  |L82.160|
;;;1459   
;;;1460     /* Change the htim state */
;;;1461     htim->State = HAL_TIM_STATE_READY;
0000a0  6404              STR      r4,[r0,#0x40]
;;;1462   
;;;1463     /* Return function status */
;;;1464     return HAL_OK;
;;;1465   }
0000a2  bc70              POP      {r4-r6}
0000a4  2000              MOVS     r0,#0                 ;1464
0000a6  4770              BX       lr
;;;1466   
                          ENDP

                  |L82.168|
                          DCD      0x40012c00
                  |L82.172|
                          DCD      0x00001111
                  |L82.176|
                          DCD      0x40014400
                  |L82.180|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_PWM_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop_IT PROC
;;;1223   */
;;;1224   HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b430              PUSH     {r4,r5}
;;;1225   {
;;;1226     /* Check the parameters */
;;;1227     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1228   
;;;1229     switch (Channel)
000002  6802              LDR      r2,[r0,#0]
000004  2900              CMP      r1,#0
000006  d006              BEQ      |L83.22|
000008  2904              CMP      r1,#4
00000a  d009              BEQ      |L83.32|
00000c  2908              CMP      r1,#8
00000e  d00c              BEQ      |L83.42|
000010  290c              CMP      r1,#0xc
000012  d113              BNE      |L83.60|
000014  e00e              B        |L83.52|
                  |L83.22|
;;;1230     {
;;;1231       case TIM_CHANNEL_1:
;;;1232       {
;;;1233         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1234         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000016  68d3              LDR      r3,[r2,#0xc]
000018  2402              MOVS     r4,#2
00001a  43a3              BICS     r3,r3,r4
00001c  60d3              STR      r3,[r2,#0xc]
;;;1235       }
;;;1236       break;
00001e  e00d              B        |L83.60|
                  |L83.32|
;;;1237   
;;;1238       case TIM_CHANNEL_2:
;;;1239       {
;;;1240         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1241         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000020  68d3              LDR      r3,[r2,#0xc]
000022  2404              MOVS     r4,#4
000024  43a3              BICS     r3,r3,r4
000026  60d3              STR      r3,[r2,#0xc]
;;;1242       }
;;;1243       break;
000028  e008              B        |L83.60|
                  |L83.42|
;;;1244   
;;;1245       case TIM_CHANNEL_3:
;;;1246       {
;;;1247         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1248         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
00002a  68d3              LDR      r3,[r2,#0xc]
00002c  2408              MOVS     r4,#8
00002e  43a3              BICS     r3,r3,r4
000030  60d3              STR      r3,[r2,#0xc]
;;;1249       }
;;;1250       break;
000032  e003              B        |L83.60|
                  |L83.52|
;;;1251   
;;;1252       case TIM_CHANNEL_4:
;;;1253       {
;;;1254         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1255         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
000034  68d3              LDR      r3,[r2,#0xc]
000036  2410              MOVS     r4,#0x10
000038  43a3              BICS     r3,r3,r4
00003a  60d3              STR      r3,[r2,#0xc]
                  |L83.60|
00003c  6802              LDR      r2,[r0,#0]
;;;1256       }
;;;1257       break;
;;;1258   
;;;1259       default:
;;;1260       break;
;;;1261     }
;;;1262   
;;;1263     /* Disable the Capture compare channel */
;;;1264     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
00003e  2400              MOVS     r4,#0
000040  2301              MOVS     r3,#1
000042  6a15              LDR      r5,[r2,#0x20]
000044  408b              LSLS     r3,r3,r1
000046  439d              BICS     r5,r5,r3
000048  6215              STR      r5,[r2,#0x20]
00004a  6a13              LDR      r3,[r2,#0x20]
00004c  408c              LSLS     r4,r4,r1
00004e  4323              ORRS     r3,r3,r4
000050  6213              STR      r3,[r2,#0x20]
;;;1265   
;;;1266     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;1267     {
;;;1268       /* Disable the Main Ouput */
;;;1269       __HAL_TIM_MOE_DISABLE(htim);
000052  4b13              LDR      r3,|L83.160|
000054  4c11              LDR      r4,|L83.156|
000056  6801              LDR      r1,[r0,#0]            ;1266
000058  109a              ASRS     r2,r3,#2
00005a  42a1              CMP      r1,r4                 ;1266
00005c  d005              BEQ      |L83.106|
00005e  4c11              LDR      r4,|L83.164|
000060  42a1              CMP      r1,r4                 ;1266
000062  d002              BEQ      |L83.106|
000064  4c10              LDR      r4,|L83.168|
000066  42a1              CMP      r1,r4                 ;1266
000068  d10a              BNE      |L83.128|
                  |L83.106|
00006a  6a0c              LDR      r4,[r1,#0x20]
00006c  421c              TST      r4,r3
00006e  d107              BNE      |L83.128|
000070  6a0c              LDR      r4,[r1,#0x20]
000072  4214              TST      r4,r2
000074  d104              BNE      |L83.128|
000076  6c4c              LDR      r4,[r1,#0x44]
000078  2501              MOVS     r5,#1
00007a  03ed              LSLS     r5,r5,#15
00007c  43ac              BICS     r4,r4,r5
00007e  644c              STR      r4,[r1,#0x44]
                  |L83.128|
;;;1270     }
;;;1271   
;;;1272     /* Disable the Peripheral */
;;;1273     __HAL_TIM_DISABLE(htim);
000080  6800              LDR      r0,[r0,#0]
000082  6a01              LDR      r1,[r0,#0x20]
000084  4219              TST      r1,r3
000086  d106              BNE      |L83.150|
000088  6a01              LDR      r1,[r0,#0x20]
00008a  4211              TST      r1,r2
00008c  d103              BNE      |L83.150|
00008e  6801              LDR      r1,[r0,#0]
000090  0849              LSRS     r1,r1,#1
000092  0049              LSLS     r1,r1,#1
000094  6001              STR      r1,[r0,#0]
                  |L83.150|
;;;1274   
;;;1275     /* Return function status */
;;;1276     return HAL_OK;
;;;1277   }
000096  bc30              POP      {r4,r5}
000098  2000              MOVS     r0,#0                 ;1276
00009a  4770              BX       lr
;;;1278   
                          ENDP

                  |L83.156|
                          DCD      0x40012c00
                  |L83.160|
                          DCD      0x00001111
                  |L83.164|
                          DCD      0x40014400
                  |L83.168|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_PeriodElapsedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PeriodElapsedCallback PROC
;;;4384     */
;;;4385   __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4386   {
;;;4387     /* Prevent unused argument(s) compilation warning */
;;;4388     UNUSED(htim);
;;;4389   
;;;4390     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4391               the __HAL_TIM_PeriodElapsedCallback could be implemented in the user file
;;;4392      */
;;;4393   
;;;4394   }
;;;4395   /**
                          ENDP


                          AREA ||i.HAL_TIM_ReadCapturedValue||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ReadCapturedValue PROC
;;;4297     */
;;;4298   uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6bc3              LDR      r3,[r0,#0x3c]
;;;4299   {
;;;4300     uint32_t tmpreg = 0U;
000002  2200              MOVS     r2,#0
;;;4301   
;;;4302     __HAL_LOCK(htim);
000004  2b01              CMP      r3,#1
000006  d00a              BEQ      |L85.30|
000008  2301              MOVS     r3,#1
;;;4303   
;;;4304     switch (Channel)
00000a  63c3              STR      r3,[r0,#0x3c]
00000c  2900              CMP      r1,#0
00000e  d008              BEQ      |L85.34|
000010  2904              CMP      r1,#4
000012  d009              BEQ      |L85.40|
000014  2908              CMP      r1,#8
000016  d00a              BEQ      |L85.46|
000018  290c              CMP      r1,#0xc
00001a  d10d              BNE      |L85.56|
00001c  e00a              B        |L85.52|
                  |L85.30|
00001e  2002              MOVS     r0,#2                 ;4302
;;;4305     {
;;;4306     case TIM_CHANNEL_1:
;;;4307       {
;;;4308         /* Check the parameters */
;;;4309         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4310   
;;;4311         /* Return the capture 1 value */
;;;4312         tmpreg =  htim->Instance->CCR1;
;;;4313   
;;;4314         break;
;;;4315       }
;;;4316     case TIM_CHANNEL_2:
;;;4317       {
;;;4318         /* Check the parameters */
;;;4319         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4320   
;;;4321         /* Return the capture 2 value */
;;;4322         tmpreg =   htim->Instance->CCR2;
;;;4323   
;;;4324         break;
;;;4325       }
;;;4326   
;;;4327     case TIM_CHANNEL_3:
;;;4328       {
;;;4329         /* Check the parameters */
;;;4330         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;4331   
;;;4332         /* Return the capture 3 value */
;;;4333         tmpreg =   htim->Instance->CCR3;
;;;4334   
;;;4335         break;
;;;4336       }
;;;4337   
;;;4338     case TIM_CHANNEL_4:
;;;4339       {
;;;4340         /* Check the parameters */
;;;4341         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;4342   
;;;4343         /* Return the capture 4 value */
;;;4344         tmpreg =   htim->Instance->CCR4;
;;;4345   
;;;4346         break;
;;;4347       }
;;;4348   
;;;4349     default:
;;;4350       break;
;;;4351     }
;;;4352   
;;;4353     __HAL_UNLOCK(htim);
;;;4354     return tmpreg;
;;;4355   }
000020  4770              BX       lr
                  |L85.34|
000022  6801              LDR      r1,[r0,#0]            ;4312
000024  6b4a              LDR      r2,[r1,#0x34]         ;4312
000026  e007              B        |L85.56|
                  |L85.40|
000028  6801              LDR      r1,[r0,#0]            ;4322
00002a  6b8a              LDR      r2,[r1,#0x38]         ;4322
00002c  e004              B        |L85.56|
                  |L85.46|
00002e  6801              LDR      r1,[r0,#0]            ;4333
000030  6bca              LDR      r2,[r1,#0x3c]         ;4333
000032  e001              B        |L85.56|
                  |L85.52|
000034  6801              LDR      r1,[r0,#0]            ;4344
000036  6c0a              LDR      r2,[r1,#0x40]         ;4344
                  |L85.56|
000038  2100              MOVS     r1,#0                 ;4353
00003a  63c1              STR      r1,[r0,#0x3c]         ;4354
00003c  4610              MOV      r0,r2                 ;4354
00003e  4770              BX       lr
;;;4356   
                          ENDP


                          AREA ||i.HAL_TIM_SlaveConfigSynchronization||, CODE, READONLY, ALIGN=1

                  HAL_TIM_SlaveConfigSynchronization PROC
;;;4224     */
;;;4225   HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef * sSlaveConfig)
000000  b570              PUSH     {r4-r6,lr}
;;;4226   {
000002  4604              MOV      r4,r0
;;;4227     /* Check the parameters */
;;;4228     assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
;;;4229     assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
;;;4230     assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
;;;4231   
;;;4232     __HAL_LOCK(htim);
000004  6bc0              LDR      r0,[r0,#0x3c]
000006  2801              CMP      r0,#1
000008  d014              BEQ      |L86.52|
00000a  2501              MOVS     r5,#1
;;;4233   
;;;4234     htim->State = HAL_TIM_STATE_BUSY;
00000c  2002              MOVS     r0,#2
00000e  63e5              STR      r5,[r4,#0x3c]
000010  6420              STR      r0,[r4,#0x40]
;;;4235   
;;;4236     TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       TIM_SlaveTimer_SetConfig
;;;4237   
;;;4238     /* Disable Trigger Interrupt */
;;;4239     __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);
000018  6820              LDR      r0,[r4,#0]
00001a  68c1              LDR      r1,[r0,#0xc]
00001c  2240              MOVS     r2,#0x40
00001e  4391              BICS     r1,r1,r2
000020  60c1              STR      r1,[r0,#0xc]
;;;4240   
;;;4241     /* Disable Trigger DMA request */
;;;4242     __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
000022  6820              LDR      r0,[r4,#0]
000024  68c1              LDR      r1,[r0,#0xc]
000026  0212              LSLS     r2,r2,#8
000028  4391              BICS     r1,r1,r2
00002a  60c1              STR      r1,[r0,#0xc]
;;;4243   
;;;4244     htim->State = HAL_TIM_STATE_READY;
00002c  6425              STR      r5,[r4,#0x40]
;;;4245   
;;;4246     __HAL_UNLOCK(htim);
00002e  2000              MOVS     r0,#0
000030  63e0              STR      r0,[r4,#0x3c]         ;4232
;;;4247   
;;;4248     return HAL_OK;
;;;4249       }
000032  bd70              POP      {r4-r6,pc}
                  |L86.52|
000034  2002              MOVS     r0,#2                 ;4232
000036  bd70              POP      {r4-r6,pc}
;;;4250   
                          ENDP


                          AREA ||i.HAL_TIM_SlaveConfigSynchronization_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_SlaveConfigSynchronization_IT PROC
;;;4259     */
;;;4260   HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization_IT(TIM_HandleTypeDef *htim,
000000  b570              PUSH     {r4-r6,lr}
;;;4261                                                           TIM_SlaveConfigTypeDef * sSlaveConfig)
;;;4262       {
000002  4604              MOV      r4,r0
;;;4263         /* Check the parameters */
;;;4264     assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
;;;4265     assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
;;;4266     assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
;;;4267   
;;;4268     __HAL_LOCK(htim);
000004  6bc0              LDR      r0,[r0,#0x3c]
000006  2801              CMP      r0,#1
000008  d014              BEQ      |L87.52|
00000a  2501              MOVS     r5,#1
;;;4269   
;;;4270     htim->State = HAL_TIM_STATE_BUSY;
00000c  2002              MOVS     r0,#2
00000e  63e5              STR      r5,[r4,#0x3c]
000010  6420              STR      r0,[r4,#0x40]
;;;4271   
;;;4272     TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       TIM_SlaveTimer_SetConfig
;;;4273   
;;;4274     /* Enable Trigger Interrupt */
;;;4275     __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
000018  6820              LDR      r0,[r4,#0]
00001a  68c1              LDR      r1,[r0,#0xc]
00001c  2240              MOVS     r2,#0x40
00001e  4311              ORRS     r1,r1,r2
000020  60c1              STR      r1,[r0,#0xc]
;;;4276   
;;;4277     /* Disable Trigger DMA request */
;;;4278     __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
000022  6820              LDR      r0,[r4,#0]
000024  68c1              LDR      r1,[r0,#0xc]
000026  0212              LSLS     r2,r2,#8
000028  4391              BICS     r1,r1,r2
00002a  60c1              STR      r1,[r0,#0xc]
;;;4279   
;;;4280     htim->State = HAL_TIM_STATE_READY;
00002c  6425              STR      r5,[r4,#0x40]
;;;4281   
;;;4282     __HAL_UNLOCK(htim);
00002e  2000              MOVS     r0,#0
000030  63e0              STR      r0,[r4,#0x3c]         ;4268
;;;4283   
;;;4284     return HAL_OK;
;;;4285   }
000032  bd70              POP      {r4-r6,pc}
                  |L87.52|
000034  2002              MOVS     r0,#2                 ;4268
000036  bd70              POP      {r4-r6,pc}
;;;4286   
                          ENDP


                          AREA ||i.HAL_TIM_TriggerCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_TriggerCallback PROC
;;;4443     */
;;;4444   __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4445   {
;;;4446     /* Prevent unused argument(s) compilation warning */
;;;4447     UNUSED(htim);
;;;4448   
;;;4449     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4450               the HAL_TIM_TriggerCallback could be implemented in the user file
;;;4451      */
;;;4452   }
;;;4453   
                          ENDP


                          AREA ||i.TIM_Base_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_Base_SetConfig PROC
;;;4672     */
;;;4673   void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
000000  b470              PUSH     {r4-r6}
;;;4674   {
;;;4675     uint32_t tmpcr1 = 0U;
;;;4676     tmpcr1 = TIMx->CR1;
000002  6802              LDR      r2,[r0,#0]
;;;4677   
;;;4678     /* Set TIM Time Base Unit parameters ---------------------------------------*/
;;;4679     if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
000004  4b18              LDR      r3,|L89.104|
000006  4e19              LDR      r6,|L89.108|
000008  4298              CMP      r0,r3
00000a  d001              BEQ      |L89.16|
00000c  42b0              CMP      r0,r6
00000e  d103              BNE      |L89.24|
                  |L89.16|
;;;4680     {
;;;4681       /* Select the Counter Mode */
;;;4682       tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
000010  2470              MOVS     r4,#0x70
000012  43a2              BICS     r2,r2,r4
;;;4683       tmpcr1 |= Structure->CounterMode;
000014  684c              LDR      r4,[r1,#4]
000016  4322              ORRS     r2,r2,r4
                  |L89.24|
;;;4684     }
;;;4685   
;;;4686     if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
000018  4c15              LDR      r4,|L89.112|
00001a  4d16              LDR      r5,|L89.116|
00001c  4298              CMP      r0,r3
00001e  d008              BEQ      |L89.50|
000020  42b0              CMP      r0,r6
000022  d006              BEQ      |L89.50|
000024  4e14              LDR      r6,|L89.120|
000026  42b0              CMP      r0,r6
000028  d003              BEQ      |L89.50|
00002a  42a0              CMP      r0,r4
00002c  d001              BEQ      |L89.50|
00002e  42a8              CMP      r0,r5
000030  d104              BNE      |L89.60|
                  |L89.50|
;;;4687     {
;;;4688       /* Set the clock division */
;;;4689       tmpcr1 &= ~TIM_CR1_CKD;
000032  2603              MOVS     r6,#3
000034  0236              LSLS     r6,r6,#8
000036  43b2              BICS     r2,r2,r6
;;;4690       tmpcr1 |= (uint32_t)Structure->ClockDivision;
000038  68ce              LDR      r6,[r1,#0xc]
00003a  4332              ORRS     r2,r2,r6
                  |L89.60|
;;;4691     }
;;;4692   
;;;4693     /* Set the auto-reload preload */
;;;4694     MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
00003c  2680              MOVS     r6,#0x80
00003e  43b2              BICS     r2,r2,r6
000040  694e              LDR      r6,[r1,#0x14]
000042  4332              ORRS     r2,r2,r6
;;;4695   
;;;4696     TIMx->CR1 = tmpcr1;
000044  6002              STR      r2,[r0,#0]
;;;4697   
;;;4698     /* Set the Autoreload value */
;;;4699     TIMx->ARR = (uint32_t)Structure->Period ;
000046  688a              LDR      r2,[r1,#8]
000048  62c2              STR      r2,[r0,#0x2c]
;;;4700   
;;;4701     /* Set the Prescaler value */
;;;4702     TIMx->PSC = (uint32_t)Structure->Prescaler;
00004a  680a              LDR      r2,[r1,#0]
00004c  6282              STR      r2,[r0,#0x28]
;;;4703   
;;;4704     if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
00004e  4298              CMP      r0,r3
000050  d003              BEQ      |L89.90|
000052  42a0              CMP      r0,r4
000054  d001              BEQ      |L89.90|
000056  42a8              CMP      r0,r5
000058  d101              BNE      |L89.94|
                  |L89.90|
;;;4705     {
;;;4706       /* Set the Repetition Counter value */
;;;4707       TIMx->RCR = Structure->RepetitionCounter;
00005a  6909              LDR      r1,[r1,#0x10]
00005c  6301              STR      r1,[r0,#0x30]
                  |L89.94|
;;;4708     }
;;;4709   
;;;4710     /* Generate an update event to reload the Prescaler 
;;;4711        and the repetition counter(only for TIM1 and TIM8) value immediatly */
;;;4712     TIMx->EGR = TIM_EGR_UG;
00005e  2101              MOVS     r1,#1
000060  6141              STR      r1,[r0,#0x14]
;;;4713   }
000062  bc70              POP      {r4-r6}
000064  4770              BX       lr
;;;4714   
                          ENDP

000066  0000              DCW      0x0000
                  |L89.104|
                          DCD      0x40012c00
                  |L89.108|
                          DCD      0x40000400
                  |L89.112|
                          DCD      0x40014400
                  |L89.116|
                          DCD      0x40014800
                  |L89.120|
                          DCD      0x40002000

                          AREA ||i.TIM_CCxChannelCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxChannelCmd PROC
;;;5464     */
;;;5465   void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
000000  b410              PUSH     {r4}
;;;5466   {
;;;5467     uint32_t tmp = 0U;
;;;5468   
;;;5469     /* Check the parameters */
;;;5470     assert_param(IS_TIM_CC1_INSTANCE(TIMx));
;;;5471     assert_param(IS_TIM_CHANNELS(Channel));
;;;5472   
;;;5473     tmp = TIM_CCER_CC1E << Channel;
000002  2301              MOVS     r3,#1
;;;5474   
;;;5475     /* Reset the CCxE Bit */
;;;5476     TIMx->CCER &= ~tmp;
000004  6a04              LDR      r4,[r0,#0x20]
000006  408b              LSLS     r3,r3,r1              ;5473
000008  439c              BICS     r4,r4,r3
00000a  6204              STR      r4,[r0,#0x20]
;;;5477   
;;;5478     /* Set or reset the CCxE Bit */
;;;5479     TIMx->CCER |=  (uint32_t)(ChannelState << Channel);
00000c  6a03              LDR      r3,[r0,#0x20]
00000e  408a              LSLS     r2,r2,r1
000010  4313              ORRS     r3,r3,r2
000012  6203              STR      r3,[r0,#0x20]
;;;5480   }
000014  bc10              POP      {r4}
000016  4770              BX       lr
;;;5481   
                          ENDP


                          AREA ||i.TIM_DMACaptureCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMACaptureCplt PROC
;;;4610     */
;;;4611   void TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4612   {
;;;4613     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
;;;4614   
;;;4615     htim->State= HAL_TIM_STATE_READY;
000002  6a84              LDR      r4,[r0,#0x28]
000004  2101              MOVS     r1,#1
000006  6421              STR      r1,[r4,#0x40]
;;;4616   
;;;4617     if (hdma == htim->hdma[TIM_DMA_ID_CC1])
000008  6a62              LDR      r2,[r4,#0x24]
00000a  4282              CMP      r2,r0
00000c  d101              BNE      |L91.18|
;;;4618     {
;;;4619       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
00000e  61e1              STR      r1,[r4,#0x1c]
000010  e00f              B        |L91.50|
                  |L91.18|
;;;4620     }
;;;4621     else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
000012  6aa1              LDR      r1,[r4,#0x28]
000014  4281              CMP      r1,r0
000016  d102              BNE      |L91.30|
;;;4622     {
;;;4623       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
000018  2002              MOVS     r0,#2
00001a  61e0              STR      r0,[r4,#0x1c]
00001c  e009              B        |L91.50|
                  |L91.30|
;;;4624     }
;;;4625     else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
00001e  6ae1              LDR      r1,[r4,#0x2c]
000020  4281              CMP      r1,r0
000022  d101              BNE      |L91.40|
;;;4626     {
;;;4627       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000024  2004              MOVS     r0,#4
000026  e003              B        |L91.48|
                  |L91.40|
;;;4628     }
;;;4629     else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
000028  6b21              LDR      r1,[r4,#0x30]
00002a  4281              CMP      r1,r0
00002c  d101              BNE      |L91.50|
;;;4630     {
;;;4631       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
00002e  2008              MOVS     r0,#8
                  |L91.48|
000030  61e0              STR      r0,[r4,#0x1c]
                  |L91.50|
;;;4632     }
;;;4633   
;;;4634     HAL_TIM_IC_CaptureCallback(htim);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
;;;4635   
;;;4636     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000038  2000              MOVS     r0,#0
00003a  61e0              STR      r0,[r4,#0x1c]
;;;4637   }
00003c  bd10              POP      {r4,pc}
;;;4638   
                          ENDP


                          AREA ||i.TIM_DMADelayPulseCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMADelayPulseCplt PROC
;;;4578     */
;;;4579   void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4580   {
;;;4581     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
;;;4582   
;;;4583     htim->State= HAL_TIM_STATE_READY;
000002  6a84              LDR      r4,[r0,#0x28]
000004  2101              MOVS     r1,#1
000006  6421              STR      r1,[r4,#0x40]
;;;4584   
;;;4585     if (hdma == htim->hdma[TIM_DMA_ID_CC1])
000008  6a62              LDR      r2,[r4,#0x24]
00000a  4282              CMP      r2,r0
00000c  d101              BNE      |L92.18|
;;;4586     {
;;;4587       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
00000e  61e1              STR      r1,[r4,#0x1c]
000010  e00f              B        |L92.50|
                  |L92.18|
;;;4588     }
;;;4589     else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
000012  6aa1              LDR      r1,[r4,#0x28]
000014  4281              CMP      r1,r0
000016  d102              BNE      |L92.30|
;;;4590     {
;;;4591       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
000018  2002              MOVS     r0,#2
00001a  61e0              STR      r0,[r4,#0x1c]
00001c  e009              B        |L92.50|
                  |L92.30|
;;;4592     }
;;;4593     else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
00001e  6ae1              LDR      r1,[r4,#0x2c]
000020  4281              CMP      r1,r0
000022  d101              BNE      |L92.40|
;;;4594     {
;;;4595       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000024  2004              MOVS     r0,#4
000026  e003              B        |L92.48|
                  |L92.40|
;;;4596     }
;;;4597     else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
000028  6b21              LDR      r1,[r4,#0x30]
00002a  4281              CMP      r1,r0
00002c  d101              BNE      |L92.50|
;;;4598     {
;;;4599       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
00002e  2008              MOVS     r0,#8
                  |L92.48|
000030  61e0              STR      r0,[r4,#0x1c]
                  |L92.50|
;;;4600     }
;;;4601   
;;;4602     HAL_TIM_PWM_PulseFinishedCallback(htim);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
;;;4603   
;;;4604     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000038  2000              MOVS     r0,#0
00003a  61e0              STR      r0,[r4,#0x1c]
;;;4605   }
00003c  bd10              POP      {r4,pc}
;;;4606   /**
                          ENDP


                          AREA ||i.TIM_DMAError||, CODE, READONLY, ALIGN=1

                  TIM_DMAError PROC
;;;4564     */
;;;4565   void TIM_DMAError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4566   {
;;;4567     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a80              LDR      r0,[r0,#0x28]
;;;4568   
;;;4569     htim->State= HAL_TIM_STATE_READY;
000004  2101              MOVS     r1,#1
000006  6401              STR      r1,[r0,#0x40]
;;;4570   
;;;4571     HAL_TIM_ErrorCallback(htim);
000008  f7fffffe          BL       HAL_TIM_ErrorCallback
;;;4572   }
00000c  bd10              POP      {r4,pc}
;;;4573   
                          ENDP


                          AREA ||i.TIM_DMAPeriodElapsedCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMAPeriodElapsedCplt PROC
;;;4643     */
;;;4644   static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4645   {
;;;4646     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a80              LDR      r0,[r0,#0x28]
;;;4647   
;;;4648     htim->State= HAL_TIM_STATE_READY;
000004  2101              MOVS     r1,#1
000006  6401              STR      r1,[r0,#0x40]
;;;4649   
;;;4650     HAL_TIM_PeriodElapsedCallback(htim);
000008  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
;;;4651   }
00000c  bd10              POP      {r4,pc}
;;;4652   
                          ENDP


                          AREA ||i.TIM_DMATriggerCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMATriggerCplt PROC
;;;4657     */
;;;4658   static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4659   {
;;;4660     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a80              LDR      r0,[r0,#0x28]
;;;4661   
;;;4662     htim->State= HAL_TIM_STATE_READY;
000004  2101              MOVS     r1,#1
000006  6401              STR      r1,[r0,#0x40]
;;;4663   
;;;4664     HAL_TIM_TriggerCallback(htim);
000008  f7fffffe          BL       HAL_TIM_TriggerCallback
;;;4665   }
00000c  bd10              POP      {r4,pc}
;;;4666   
                          ENDP


                          AREA ||i.TIM_ETR_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_ETR_SetConfig PROC
;;;5434     */
;;;5435   void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
000000  b430              PUSH     {r4,r5}
;;;5436                          uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
;;;5437   {
;;;5438     uint32_t tmpsmcr = 0U;
;;;5439   
;;;5440     tmpsmcr = TIMx->SMCR;
000002  6884              LDR      r4,[r0,#8]
;;;5441   
;;;5442     /* Reset the ETR Bits */
;;;5443     tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
000004  25ff              MOVS     r5,#0xff
000006  022d              LSLS     r5,r5,#8
;;;5444   
;;;5445     /* Set the Prescaler, the Filter value and the Polarity */
;;;5446     tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
000008  021b              LSLS     r3,r3,#8
00000a  4313              ORRS     r3,r3,r2
00000c  43ac              BICS     r4,r4,r5              ;5443
00000e  430b              ORRS     r3,r3,r1
000010  4323              ORRS     r3,r3,r4
;;;5447   
;;;5448     /* Write to TIMx SMCR */
;;;5449     TIMx->SMCR = tmpsmcr;
000012  6083              STR      r3,[r0,#8]
;;;5450   }
000014  bc30              POP      {r4,r5}
000016  4770              BX       lr
;;;5451   
                          ENDP


                          AREA ||i.TIM_OC1_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC1_SetConfig PROC
;;;4720     */
;;;4721   static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b4f0              PUSH     {r4-r7}
;;;4722   {
;;;4723     uint32_t tmpccmrx = 0U;
;;;4724     uint32_t tmpccer = 0U;
;;;4725     uint32_t tmpcr2 = 0U;
;;;4726   
;;;4727      /* Disable the Channel 1: Reset the CC1E Bit */
;;;4728     TIMx->CCER &= ~TIM_CCER_CC1E;
000002  6a02              LDR      r2,[r0,#0x20]
000004  0852              LSRS     r2,r2,#1
000006  0052              LSLS     r2,r2,#1
000008  6202              STR      r2,[r0,#0x20]
;;;4729   
;;;4730     /* Get the TIMx CCER register value */
;;;4731     tmpccer = TIMx->CCER;
00000a  6a05              LDR      r5,[r0,#0x20]
;;;4732     /* Get the TIMx CR2 register value */
;;;4733     tmpcr2 =  TIMx->CR2;
00000c  6843              LDR      r3,[r0,#4]
;;;4734   
;;;4735     /* Get the TIMx CCMR1 register value */
;;;4736     tmpccmrx = TIMx->CCMR1;
00000e  6982              LDR      r2,[r0,#0x18]
;;;4737   
;;;4738     /* Reset the Output Compare Mode Bits */
;;;4739     tmpccmrx &= ~TIM_CCMR1_OC1M;
000010  2470              MOVS     r4,#0x70
000012  43a2              BICS     r2,r2,r4
;;;4740     tmpccmrx &= ~TIM_CCMR1_CC1S;
000014  0892              LSRS     r2,r2,#2
;;;4741     /* Select the Output Compare Mode */
;;;4742     tmpccmrx |= OC_Config->OCMode;
000016  680c              LDR      r4,[r1,#0]
000018  0092              LSLS     r2,r2,#2              ;4740
00001a  4314              ORRS     r4,r4,r2
;;;4743   
;;;4744     /* Reset the Output Polarity level */
;;;4745     tmpccer &= ~TIM_CCER_CC1P;
00001c  2202              MOVS     r2,#2
00001e  4395              BICS     r5,r5,r2
;;;4746     /* Set the Output Compare Polarity */
;;;4747     tmpccer |= OC_Config->OCPolarity;
000020  688a              LDR      r2,[r1,#8]
;;;4748   
;;;4749     if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
000022  4e14              LDR      r6,|L97.116|
000024  432a              ORRS     r2,r2,r5              ;4747
000026  4d12              LDR      r5,|L97.112|
000028  42a8              CMP      r0,r5
00002a  d004              BEQ      |L97.54|
00002c  42b0              CMP      r0,r6
00002e  d002              BEQ      |L97.54|
000030  4f11              LDR      r7,|L97.120|
000032  42b8              CMP      r0,r7
000034  d106              BNE      |L97.68|
                  |L97.54|
;;;4750     {
;;;4751       /* Check parameters */
;;;4752       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;4753   
;;;4754       /* Reset the Output N Polarity level */
;;;4755       tmpccer &= ~TIM_CCER_CC1NP;
000036  2708              MOVS     r7,#8
000038  43ba              BICS     r2,r2,r7
;;;4756       /* Set the Output N Polarity */
;;;4757       tmpccer |= OC_Config->OCNPolarity;
00003a  68cf              LDR      r7,[r1,#0xc]
00003c  4317              ORRS     r7,r7,r2
;;;4758       /* Reset the Output N State */
;;;4759       tmpccer &= ~TIM_CCER_CC1NE;
00003e  2204              MOVS     r2,#4
000040  4397              BICS     r7,r7,r2
000042  463a              MOV      r2,r7
                  |L97.68|
;;;4760     }
;;;4761   
;;;4762     if(IS_TIM_BREAK_INSTANCE(TIMx))
000044  42a8              CMP      r0,r5
000046  d004              BEQ      |L97.82|
000048  42b0              CMP      r0,r6
00004a  d002              BEQ      |L97.82|
00004c  4d0a              LDR      r5,|L97.120|
00004e  42a8              CMP      r0,r5
000050  d106              BNE      |L97.96|
                  |L97.82|
;;;4763     {
;;;4764       /* Check parameters */
;;;4765       assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
;;;4766       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;4767   
;;;4768       /* Reset the Output Compare and Output Compare N IDLE State */
;;;4769       tmpcr2 &= ~TIM_CR2_OIS1;
000052  2503              MOVS     r5,#3
000054  022d              LSLS     r5,r5,#8
000056  43ab              BICS     r3,r3,r5
;;;4770       tmpcr2 &= ~TIM_CR2_OIS1N;
;;;4771       /* Set the Output Idle state */
;;;4772       tmpcr2 |= OC_Config->OCIdleState;
000058  694d              LDR      r5,[r1,#0x14]
00005a  431d              ORRS     r5,r5,r3
;;;4773       /* Set the Output N Idle state */
;;;4774       tmpcr2 |= OC_Config->OCNIdleState;
00005c  698b              LDR      r3,[r1,#0x18]
00005e  432b              ORRS     r3,r3,r5
                  |L97.96|
;;;4775     }
;;;4776     /* Write to TIMx CR2 */
;;;4777     TIMx->CR2 = tmpcr2;
000060  6043              STR      r3,[r0,#4]
;;;4778   
;;;4779     /* Write to TIMx CCMR1 */
;;;4780     TIMx->CCMR1 = tmpccmrx;
000062  6184              STR      r4,[r0,#0x18]
;;;4781   
;;;4782     /* Set the Capture Compare Register value */
;;;4783     TIMx->CCR1 = OC_Config->Pulse;
000064  6849              LDR      r1,[r1,#4]
000066  6341              STR      r1,[r0,#0x34]
;;;4784   
;;;4785     /* Write to TIMx CCER */
;;;4786     TIMx->CCER = tmpccer;
000068  6202              STR      r2,[r0,#0x20]
;;;4787   }
00006a  bcf0              POP      {r4-r7}
00006c  4770              BX       lr
;;;4788   
                          ENDP

00006e  0000              DCW      0x0000
                  |L97.112|
                          DCD      0x40012c00
                  |L97.116|
                          DCD      0x40014400
                  |L97.120|
                          DCD      0x40014800

                          AREA ||i.TIM_OC2_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC2_SetConfig PROC
;;;4794     */
;;;4795   void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b470              PUSH     {r4-r6}
;;;4796   {
;;;4797     uint32_t tmpccmrx = 0U;
;;;4798     uint32_t tmpccer = 0U;
;;;4799     uint32_t tmpcr2 = 0U;
;;;4800   
;;;4801     /* Disable the Channel 2: Reset the CC2E Bit */
;;;4802     TIMx->CCER &= ~TIM_CCER_CC2E;
000002  6a02              LDR      r2,[r0,#0x20]
000004  2310              MOVS     r3,#0x10
000006  439a              BICS     r2,r2,r3
000008  6202              STR      r2,[r0,#0x20]
;;;4803   
;;;4804     /* Get the TIMx CCER register value */
;;;4805     tmpccer = TIMx->CCER;
00000a  6a04              LDR      r4,[r0,#0x20]
;;;4806     /* Get the TIMx CR2 register value */
;;;4807     tmpcr2 =  TIMx->CR2;
00000c  6843              LDR      r3,[r0,#4]
;;;4808   
;;;4809     /* Get the TIMx CCMR1 register value */
;;;4810     tmpccmrx = TIMx->CCMR1;
00000e  6982              LDR      r2,[r0,#0x18]
;;;4811   
;;;4812     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;4813     tmpccmrx &= ~TIM_CCMR1_OC2M;
000010  2573              MOVS     r5,#0x73
000012  022d              LSLS     r5,r5,#8
000014  43aa              BICS     r2,r2,r5
;;;4814     tmpccmrx &= ~TIM_CCMR1_CC2S;
;;;4815   
;;;4816     /* Select the Output Compare Mode */
;;;4817     tmpccmrx |= (OC_Config->OCMode << 8U);
000016  680d              LDR      r5,[r1,#0]
000018  022d              LSLS     r5,r5,#8
00001a  4315              ORRS     r5,r5,r2
;;;4818   
;;;4819     /* Reset the Output Polarity level */
;;;4820     tmpccer &= ~TIM_CCER_CC2P;
00001c  2220              MOVS     r2,#0x20
00001e  4394              BICS     r4,r4,r2
;;;4821     /* Set the Output Compare Polarity */
;;;4822     tmpccer |= (OC_Config->OCPolarity << 4U);
000020  688a              LDR      r2,[r1,#8]
000022  0112              LSLS     r2,r2,#4
000024  4322              ORRS     r2,r2,r4
;;;4823   
;;;4824     if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
000026  4c11              LDR      r4,|L98.108|
000028  42a0              CMP      r0,r4
00002a  d108              BNE      |L98.62|
;;;4825     {
;;;4826       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;4827   
;;;4828       /* Reset the Output N Polarity level */
;;;4829       tmpccer &= ~TIM_CCER_CC2NP;
00002c  4614              MOV      r4,r2
;;;4830       /* Set the Output N Polarity */
;;;4831       tmpccer |= (OC_Config->OCNPolarity << 4U);
00002e  68ca              LDR      r2,[r1,#0xc]
000030  2680              MOVS     r6,#0x80              ;4829
000032  43b4              BICS     r4,r4,r6              ;4829
000034  0112              LSLS     r2,r2,#4
000036  4322              ORRS     r2,r2,r4
;;;4832       /* Reset the Output N State */
;;;4833       tmpccer &= ~TIM_CCER_CC2NE;
000038  2440              MOVS     r4,#0x40
00003a  43a2              BICS     r2,r2,r4
00003c  e005              B        |L98.74|
                  |L98.62|
;;;4834   
;;;4835     }
;;;4836   
;;;4837     if(IS_TIM_BREAK_INSTANCE(TIMx))
00003e  4c0c              LDR      r4,|L98.112|
000040  42a0              CMP      r0,r4
000042  d002              BEQ      |L98.74|
000044  4c0b              LDR      r4,|L98.116|
000046  42a0              CMP      r0,r4
000048  d108              BNE      |L98.92|
                  |L98.74|
;;;4838     {
;;;4839       /* Check parameters */
;;;4840       assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
;;;4841       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;4842   
;;;4843       /* Reset the Output Compare and Output Compare N IDLE State */
;;;4844       tmpcr2 &= ~TIM_CR2_OIS2;
00004a  2403              MOVS     r4,#3
00004c  02a4              LSLS     r4,r4,#10
00004e  43a3              BICS     r3,r3,r4
;;;4845       tmpcr2 &= ~TIM_CR2_OIS2N;
;;;4846       /* Set the Output Idle state */
;;;4847       tmpcr2 |= (OC_Config->OCIdleState << 2U);
000050  694c              LDR      r4,[r1,#0x14]
000052  00a4              LSLS     r4,r4,#2
000054  431c              ORRS     r4,r4,r3
;;;4848       /* Set the Output N Idle state */
;;;4849       tmpcr2 |= (OC_Config->OCNIdleState << 2U);
000056  698b              LDR      r3,[r1,#0x18]
000058  009b              LSLS     r3,r3,#2
00005a  4323              ORRS     r3,r3,r4
                  |L98.92|
;;;4850     }
;;;4851   
;;;4852     /* Write to TIMx CR2 */
;;;4853     TIMx->CR2 = tmpcr2;
00005c  6043              STR      r3,[r0,#4]
;;;4854   
;;;4855     /* Write to TIMx CCMR1 */
;;;4856     TIMx->CCMR1 = tmpccmrx;
00005e  6185              STR      r5,[r0,#0x18]
;;;4857   
;;;4858     /* Set the Capture Compare Register value */
;;;4859     TIMx->CCR2 = OC_Config->Pulse;
000060  6849              LDR      r1,[r1,#4]
000062  6381              STR      r1,[r0,#0x38]
;;;4860   
;;;4861     /* Write to TIMx CCER */
;;;4862     TIMx->CCER = tmpccer;
000064  6202              STR      r2,[r0,#0x20]
;;;4863   }
000066  bc70              POP      {r4-r6}
000068  4770              BX       lr
;;;4864   
                          ENDP

00006a  0000              DCW      0x0000
                  |L98.108|
                          DCD      0x40012c00
                  |L98.112|
                          DCD      0x40014400
                  |L98.116|
                          DCD      0x40014800

                          AREA ||i.TIM_SlaveTimer_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_SlaveTimer_SetConfig PROC
;;;4996   
;;;4997   static void TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
000000  b430              PUSH     {r4,r5}
;;;4998                                 TIM_SlaveConfigTypeDef * sSlaveConfig)
;;;4999   {
;;;5000     uint32_t tmpsmcr = 0U;
;;;5001     uint32_t tmpccmr1 = 0U;
;;;5002     uint32_t tmpccer = 0U;
;;;5003   
;;;5004     /* Get the TIMx SMCR register value */
;;;5005     tmpsmcr = htim->Instance->SMCR;
000002  6804              LDR      r4,[r0,#0]
000004  68a2              LDR      r2,[r4,#8]
;;;5006   
;;;5007     /* Reset the Trigger Selection Bits */
;;;5008     tmpsmcr &= ~TIM_SMCR_TS;
000006  2370              MOVS     r3,#0x70
000008  439a              BICS     r2,r2,r3
;;;5009     /* Set the Input Trigger source */
;;;5010     tmpsmcr |= sSlaveConfig->InputTrigger;
00000a  684b              LDR      r3,[r1,#4]
00000c  4313              ORRS     r3,r3,r2
;;;5011   
;;;5012     /* Reset the slave mode Bits */
;;;5013     tmpsmcr &= ~TIM_SMCR_SMS;
00000e  08db              LSRS     r3,r3,#3
;;;5014     /* Set the slave mode */
;;;5015     tmpsmcr |= sSlaveConfig->SlaveMode;
000010  680a              LDR      r2,[r1,#0]
000012  00db              LSLS     r3,r3,#3              ;5013
000014  431a              ORRS     r2,r2,r3
;;;5016   
;;;5017     /* Write to TIMx SMCR */
;;;5018     htim->Instance->SMCR = tmpsmcr;
000016  60a2              STR      r2,[r4,#8]
;;;5019   
;;;5020     /* Configure the trigger prescaler, filter, and polarity */
;;;5021     switch (sSlaveConfig->InputTrigger)
000018  684a              LDR      r2,[r1,#4]
00001a  0713              LSLS     r3,r2,#28
00001c  0f1b              LSRS     r3,r3,#28
00001e  d119              BNE      |L99.84|
000020  1112              ASRS     r2,r2,#4
;;;5022     {
;;;5023     case TIM_TS_ETRF:
;;;5024       {
;;;5025         /* Check the parameters */
;;;5026         assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
;;;5027         assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
;;;5028         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;5029         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;5030         /* Configure the ETR Trigger source */
;;;5031         TIM_ETR_SetConfig(htim->Instance,
;;;5032                           sSlaveConfig->TriggerPrescaler,
;;;5033                           sSlaveConfig->TriggerPolarity,
;;;5034                           sSlaveConfig->TriggerFilter);
;;;5035       }
;;;5036       break;
;;;5037   
;;;5038     case TIM_TS_TI1F_ED:
;;;5039       {
;;;5040         /* Check the parameters */
;;;5041         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;5042         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;5043   
;;;5044         /* Disable the Channel 1: Reset the CC1E Bit */
;;;5045         tmpccer = htim->Instance->CCER;
;;;5046         htim->Instance->CCER &= ~TIM_CCER_CC1E;
;;;5047         tmpccmr1 = htim->Instance->CCMR1;
;;;5048   
;;;5049         /* Set the filter */
;;;5050         tmpccmr1 &= ~TIM_CCMR1_IC1F;
000022  23f0              MOVS     r3,#0xf0
000024  2a08              CMP      r2,#8                 ;5021
000026  d215              BCS      |L99.84|
000028  0014              MOVS     r4,r2                 ;5021
00002a  447c              ADD      r4,r4,pc              ;5021
00002c  7924              LDRB     r4,[r4,#4]            ;5021
00002e  1924              ADDS     r4,r4,r4              ;5021
000030  44a7              ADD      pc,pc,r4              ;5021
000032  1010              DCB      0x10,0x10
000034  10101223          DCB      0x10,0x10,0x12,0x23
000038  3603              DCB      0x36,0x03
00003a  6802              LDR      r2,[r0,#0]            ;5031
00003c  688c              LDR      r4,[r1,#8]            ;5031
00003e  68cb              LDR      r3,[r1,#0xc]          ;5031
000040  6909              LDR      r1,[r1,#0x10]         ;5031
000042  6890              LDR      r0,[r2,#8]            ;5031
000044  25ff              MOVS     r5,#0xff              ;5031
000046  022d              LSLS     r5,r5,#8              ;5031
000048  0209              LSLS     r1,r1,#8              ;5031
00004a  4321              ORRS     r1,r1,r4              ;5031
00004c  43a8              BICS     r0,r0,r5              ;5031
00004e  4319              ORRS     r1,r1,r3              ;5031
000050  4301              ORRS     r1,r1,r0              ;5031
000052  6091              STR      r1,[r2,#8]            ;5031
                  |L99.84|
;;;5051         tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4U);
;;;5052   
;;;5053         /* Write to TIMx CCMR1 and CCER registers */
;;;5054         htim->Instance->CCMR1 = tmpccmr1;
;;;5055         htim->Instance->CCER = tmpccer;
;;;5056   
;;;5057       }
;;;5058       break;
;;;5059   
;;;5060     case TIM_TS_TI1FP1:
;;;5061       {
;;;5062         /* Check the parameters */
;;;5063         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;5064         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;5065         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;5066   
;;;5067         /* Configure TI1 Filter and Polarity */
;;;5068         TIM_TI1_ConfigInputStage(htim->Instance,
;;;5069                                  sSlaveConfig->TriggerPolarity,
;;;5070                                  sSlaveConfig->TriggerFilter);
;;;5071       }
;;;5072       break;
;;;5073   
;;;5074     case TIM_TS_TI2FP2:
;;;5075       {
;;;5076         /* Check the parameters */
;;;5077         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5078         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;5079         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;5080   
;;;5081         /* Configure TI2 Filter and Polarity */
;;;5082         TIM_TI2_ConfigInputStage(htim->Instance,
;;;5083                                   sSlaveConfig->TriggerPolarity,
;;;5084                                   sSlaveConfig->TriggerFilter);
;;;5085       }
;;;5086       break;
;;;5087   
;;;5088     case TIM_TS_ITR0:
;;;5089       {
;;;5090         /* Check the parameter */
;;;5091         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5092       }
;;;5093       break;
;;;5094   
;;;5095     case TIM_TS_ITR1:
;;;5096       {
;;;5097         /* Check the parameter */
;;;5098         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5099       }
;;;5100       break;
;;;5101   
;;;5102     case TIM_TS_ITR2:
;;;5103       {
;;;5104         /* Check the parameter */
;;;5105         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5106       }
;;;5107       break;
;;;5108   
;;;5109     case TIM_TS_ITR3:
;;;5110       {
;;;5111         /* Check the parameter */
;;;5112         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5113       }
;;;5114       break;
;;;5115   
;;;5116     default:
;;;5117       break;
;;;5118     }
;;;5119   }
000054  bc30              POP      {r4,r5}
000056  4770              BX       lr
000058  6802              LDR      r2,[r0,#0]            ;5045
00005a  6a14              LDR      r4,[r2,#0x20]         ;5045
00005c  6a15              LDR      r5,[r2,#0x20]         ;5046
00005e  086d              LSRS     r5,r5,#1              ;5046
000060  006d              LSLS     r5,r5,#1              ;5046
000062  6215              STR      r5,[r2,#0x20]         ;5046
000064  6805              LDR      r5,[r0,#0]            ;5047
000066  69aa              LDR      r2,[r5,#0x18]         ;5047
000068  6909              LDR      r1,[r1,#0x10]         ;5051
00006a  439a              BICS     r2,r2,r3              ;5050
00006c  0109              LSLS     r1,r1,#4              ;5051
00006e  4311              ORRS     r1,r1,r2              ;5051
000070  61a9              STR      r1,[r5,#0x18]         ;5054
000072  6800              LDR      r0,[r0,#0]            ;5055
000074  6204              STR      r4,[r0,#0x20]         ;5055
000076  bc30              POP      {r4,r5}
000078  4770              BX       lr
00007a  6802              LDR      r2,[r0,#0]            ;5068
00007c  690d              LDR      r5,[r1,#0x10]         ;5068
00007e  688c              LDR      r4,[r1,#8]            ;5068
000080  6a10              LDR      r0,[r2,#0x20]         ;5068
000082  6a11              LDR      r1,[r2,#0x20]         ;5068
000084  0849              LSRS     r1,r1,#1              ;5068
000086  0049              LSLS     r1,r1,#1              ;5068
000088  6211              STR      r1,[r2,#0x20]         ;5068
00008a  6991              LDR      r1,[r2,#0x18]         ;5068
00008c  4399              BICS     r1,r1,r3              ;5068
00008e  012b              LSLS     r3,r5,#4              ;5068
000090  430b              ORRS     r3,r3,r1              ;5068
000092  210a              MOVS     r1,#0xa               ;5068
000094  4388              BICS     r0,r0,r1              ;5068
000096  4320              ORRS     r0,r0,r4              ;5068
000098  6193              STR      r3,[r2,#0x18]         ;5068
00009a  6210              STR      r0,[r2,#0x20]         ;5068
00009c  bc30              POP      {r4,r5}
00009e  4770              BX       lr
0000a0  6800              LDR      r0,[r0,#0]            ;5082
0000a2  688c              LDR      r4,[r1,#8]            ;5082
0000a4  690b              LDR      r3,[r1,#0x10]         ;5082
0000a6  6a01              LDR      r1,[r0,#0x20]         ;5082
0000a8  2210              MOVS     r2,#0x10              ;5082
0000aa  4391              BICS     r1,r1,r2              ;5082
0000ac  6201              STR      r1,[r0,#0x20]         ;5082
0000ae  6981              LDR      r1,[r0,#0x18]         ;5082
0000b0  6a02              LDR      r2,[r0,#0x20]         ;5082
0000b2  250f              MOVS     r5,#0xf               ;5082
0000b4  032d              LSLS     r5,r5,#12             ;5082
0000b6  43a9              BICS     r1,r1,r5              ;5082
0000b8  031b              LSLS     r3,r3,#12             ;5082
0000ba  430b              ORRS     r3,r3,r1              ;5082
0000bc  21a0              MOVS     r1,#0xa0              ;5082
0000be  438a              BICS     r2,r2,r1              ;5082
0000c0  0121              LSLS     r1,r4,#4              ;5082
0000c2  4311              ORRS     r1,r1,r2              ;5082
0000c4  6183              STR      r3,[r0,#0x18]         ;5082
0000c6  6201              STR      r1,[r0,#0x20]         ;5082
0000c8  bc30              POP      {r4,r5}
0000ca  4770              BX       lr
;;;5120   
                          ENDP


                          AREA ||i.TIM_TI1_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_TI1_SetConfig PROC
;;;5140     */
;;;5141   void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b470              PUSH     {r4-r6}
;;;5142                          uint32_t TIM_ICFilter)
;;;5143   {
;;;5144     uint32_t tmpccmr1 = 0U;
;;;5145     uint32_t tmpccer = 0U;
;;;5146   
;;;5147     /* Disable the Channel 1: Reset the CC1E Bit */
;;;5148     TIMx->CCER &= ~TIM_CCER_CC1E;
000002  6a04              LDR      r4,[r0,#0x20]
000004  0864              LSRS     r4,r4,#1
000006  0064              LSLS     r4,r4,#1
000008  6204              STR      r4,[r0,#0x20]
;;;5149     tmpccmr1 = TIMx->CCMR1;
00000a  6984              LDR      r4,[r0,#0x18]
;;;5150     tmpccer = TIMx->CCER;
00000c  6a05              LDR      r5,[r0,#0x20]
;;;5151   
;;;5152     /* Select the Input */
;;;5153     if(IS_TIM_CC2_INSTANCE(TIMx) != RESET)
00000e  4e0c              LDR      r6,|L100.64|
000010  42b0              CMP      r0,r6
000012  d002              BEQ      |L100.26|
000014  4e0b              LDR      r6,|L100.68|
000016  42b0              CMP      r0,r6
000018  d102              BNE      |L100.32|
                  |L100.26|
;;;5154     {
;;;5155       tmpccmr1 &= ~TIM_CCMR1_CC1S;
00001a  08a4              LSRS     r4,r4,#2
00001c  00a4              LSLS     r4,r4,#2
;;;5156       tmpccmr1 |= TIM_ICSelection;
00001e  e000              B        |L100.34|
                  |L100.32|
;;;5157     }
;;;5158     else
;;;5159     {
;;;5160       tmpccmr1 |= TIM_CCMR1_CC1S_0;
000020  2201              MOVS     r2,#1
                  |L100.34|
000022  4314              ORRS     r4,r4,r2
;;;5161     }
;;;5162   
;;;5163     /* Set the filter */
;;;5164     tmpccmr1 &= ~TIM_CCMR1_IC1F;
000024  22f0              MOVS     r2,#0xf0
000026  4394              BICS     r4,r4,r2
000028  071a              LSLS     r2,r3,#28
;;;5165     tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);
00002a  0e12              LSRS     r2,r2,#24
;;;5166   
;;;5167     /* Select the Polarity and set the CC1E Bit */
;;;5168     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
00002c  230a              MOVS     r3,#0xa
00002e  4322              ORRS     r2,r2,r4              ;5165
000030  439d              BICS     r5,r5,r3
;;;5169     tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
000032  4019              ANDS     r1,r1,r3
000034  4329              ORRS     r1,r1,r5
;;;5170   
;;;5171     /* Write to TIMx CCMR1 and CCER registers */
;;;5172     TIMx->CCMR1 = tmpccmr1;
000036  6182              STR      r2,[r0,#0x18]
;;;5173     TIMx->CCER = tmpccer;
000038  6201              STR      r1,[r0,#0x20]
;;;5174   }
00003a  bc70              POP      {r4-r6}
00003c  4770              BX       lr
;;;5175   
                          ENDP

00003e  0000              DCW      0x0000
                  |L100.64|
                          DCD      0x40012c00
                  |L100.68|
                          DCD      0x40000400

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F0_V1.9.0\\Drivers\\STM32F0xx_HAL_Driver\\Src\\stm32f0xx_hal_tim.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f0xx_hal_tim_c_a9d95b52____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F0_V1.9.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f0xx_hal_tim_c_a9d95b52____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f0xx_hal_tim_c_a9d95b52____REVSH|
#line 402
|__asm___19_stm32f0xx_hal_tim_c_a9d95b52____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
