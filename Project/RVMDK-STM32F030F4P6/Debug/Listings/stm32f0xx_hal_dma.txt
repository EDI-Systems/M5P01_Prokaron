; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f0xx_hal_dma.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f0xx_hal_dma.d --cpu=Cortex-M0 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F0_V1.9.0\Drivers\STM32F0xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_F0_V1.9.0\Drivers\CMSIS\Device\ST\STM32L0xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F0_V1.9.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F0_V1.9.0\Drivers\STM32F0xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F030F4P6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F0xx_DFP\2.0.0\Drivers\CMSIS\Device\ST\STM32F0xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F030x6 -DSTM32F030x6 -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f0xx_hal_dma.crf ..\..\..\M0P0_Library\STM32Cube_FW_F0_V1.9.0\Drivers\STM32F0xx_HAL_Driver\Src\stm32f0xx_hal_dma.c]
                          THUMB

                          AREA ||i.HAL_DMA_Abort||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Abort PROC
;;;400      */
;;;401    HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
000000  6801              LDR      r1,[r0,#0]
;;;402    {
;;;403    	/* Disable DMA IT */
;;;404    	 hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
000002  680a              LDR      r2,[r1,#0]
000004  230e              MOVS     r3,#0xe
000006  439a              BICS     r2,r2,r3
000008  600a              STR      r2,[r1,#0]
;;;405    	
;;;406    	/* Disable the channel */
;;;407    	hdma->Instance->CCR &= ~DMA_CCR_EN;
00000a  6801              LDR      r1,[r0,#0]
00000c  680a              LDR      r2,[r1,#0]
00000e  0852              LSRS     r2,r2,#1
000010  0052              LSLS     r2,r2,#1
000012  600a              STR      r2,[r1,#0]
;;;408    	
;;;409    	/* Clear all flags */
;;;410    	hdma->DmaBaseAddress->IFCR = (DMA_FLAG_GL1 << hdma->ChannelIndex);
000014  2101              MOVS     r1,#1
000016  6c43              LDR      r3,[r0,#0x44]
000018  460a              MOV      r2,r1
00001a  409a              LSLS     r2,r2,r3
00001c  6c03              LDR      r3,[r0,#0x40]
00001e  605a              STR      r2,[r3,#4]
;;;411    	
;;;412    	/* Change the DMA state*/
;;;413    	hdma->State = HAL_DMA_STATE_READY; 
000020  6241              STR      r1,[r0,#0x24]
;;;414    	
;;;415    	/* Process Unlocked */
;;;416    	__HAL_UNLOCK(hdma);
000022  2100              MOVS     r1,#0
;;;417    	
;;;418    	return HAL_OK; 
000024  6201              STR      r1,[r0,#0x20]
000026  4608              MOV      r0,r1
;;;419    }
000028  4770              BX       lr
;;;420    
                          ENDP


                          AREA ||i.HAL_DMA_Abort_IT||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Abort_IT PROC
;;;426      */
;;;427    HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;428    {  
;;;429      HAL_StatusTypeDef status = HAL_OK;
;;;430      
;;;431      if(HAL_DMA_STATE_BUSY != hdma->State)
000002  6a41              LDR      r1,[r0,#0x24]
000004  2400              MOVS     r4,#0                 ;429
000006  2902              CMP      r1,#2
000008  d003              BEQ      |L2.18|
;;;432      {
;;;433        /* no transfer ongoing */
;;;434        hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
00000a  2104              MOVS     r1,#4
00000c  63c1              STR      r1,[r0,#0x3c]
;;;435            
;;;436        status = HAL_ERROR;
00000e  2401              MOVS     r4,#1
000010  e016              B        |L2.64|
                  |L2.18|
;;;437      }
;;;438      else
;;;439      { 
;;;440      
;;;441        /* Disable DMA IT */
;;;442        hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
000012  6801              LDR      r1,[r0,#0]
000014  680a              LDR      r2,[r1,#0]
000016  230e              MOVS     r3,#0xe
000018  439a              BICS     r2,r2,r3
00001a  600a              STR      r2,[r1,#0]
;;;443        
;;;444        /* Disable the channel */
;;;445        hdma->Instance->CCR &= ~DMA_CCR_EN;
00001c  6801              LDR      r1,[r0,#0]
00001e  680a              LDR      r2,[r1,#0]
000020  0852              LSRS     r2,r2,#1
000022  0052              LSLS     r2,r2,#1
000024  600a              STR      r2,[r1,#0]
;;;446        
;;;447        /* Clear all flags */
;;;448        hdma->DmaBaseAddress->IFCR = DMA_FLAG_GL1 << hdma->ChannelIndex;
000026  2101              MOVS     r1,#1
000028  6c43              LDR      r3,[r0,#0x44]
00002a  460a              MOV      r2,r1
00002c  409a              LSLS     r2,r2,r3
00002e  6c03              LDR      r3,[r0,#0x40]
000030  605a              STR      r2,[r3,#4]
;;;449        
;;;450        /* Change the DMA state */
;;;451        hdma->State = HAL_DMA_STATE_READY;
000032  6241              STR      r1,[r0,#0x24]
;;;452        
;;;453        /* Process Unlocked */
;;;454        __HAL_UNLOCK(hdma);
000034  2100              MOVS     r1,#0
;;;455        
;;;456        /* Call User Abort callback */ 
;;;457        if(hdma->XferAbortCallback != NULL)
000036  6201              STR      r1,[r0,#0x20]
000038  6b81              LDR      r1,[r0,#0x38]
00003a  2900              CMP      r1,#0
00003c  d000              BEQ      |L2.64|
;;;458        {
;;;459          hdma->XferAbortCallback(hdma);
00003e  4788              BLX      r1
                  |L2.64|
;;;460        } 
;;;461      }
;;;462      return status;
000040  4620              MOV      r0,r4
;;;463    }
000042  bd10              POP      {r4,pc}
;;;464    
                          ENDP


                          AREA ||i.HAL_DMA_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_DMA_DeInit PROC
;;;221      */
;;;222    HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
000000  2800              CMP      r0,#0
;;;223    {
;;;224      /* Check the DMA handle allocation */
;;;225      if(NULL == hdma)
000002  d101              BNE      |L3.8|
;;;226      {
;;;227        return HAL_ERROR;
000004  2001              MOVS     r0,#1
;;;228      }
;;;229      
;;;230      /* Check the parameters */
;;;231      assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));
;;;232    
;;;233      /* Disable the selected DMA Channelx */
;;;234      hdma->Instance->CCR &= ~DMA_CCR_EN;
;;;235    
;;;236      /* Reset DMA Channel control register */
;;;237      hdma->Instance->CCR  = 0U;
;;;238    
;;;239      /* Reset DMA Channel Number of Data to Transfer register */
;;;240      hdma->Instance->CNDTR = 0U;
;;;241    
;;;242      /* Reset DMA Channel peripheral address register */
;;;243      hdma->Instance->CPAR  = 0U;
;;;244      
;;;245      /* Reset DMA Channel memory address register */
;;;246      hdma->Instance->CMAR = 0U;
;;;247    
;;;248    /* Get DMA Base Address */  
;;;249      DMA_CalcBaseAndBitshift(hdma);
;;;250    
;;;251      /* Clear all flags */
;;;252      hdma->DmaBaseAddress->IFCR = DMA_FLAG_GL1 << hdma->ChannelIndex;
;;;253    
;;;254      /* Initialize the error code */
;;;255      hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;256    
;;;257      /* Initialize the DMA state */
;;;258      hdma->State = HAL_DMA_STATE_RESET;
;;;259    
;;;260      /* Release Lock */
;;;261      __HAL_UNLOCK(hdma);
;;;262    
;;;263      return HAL_OK;
;;;264    }
000006  4770              BX       lr
                  |L3.8|
000008  b570              PUSH     {r4-r6,lr}            ;223
00000a  4604              MOV      r4,r0                 ;223
00000c  6800              LDR      r0,[r0,#0]            ;234
00000e  6801              LDR      r1,[r0,#0]            ;234
000010  0849              LSRS     r1,r1,#1              ;234
000012  0049              LSLS     r1,r1,#1              ;234
000014  6001              STR      r1,[r0,#0]            ;234
000016  6820              LDR      r0,[r4,#0]            ;237
000018  2500              MOVS     r5,#0                 ;237
00001a  6005              STR      r5,[r0,#0]            ;237
00001c  6820              LDR      r0,[r4,#0]            ;240
00001e  6045              STR      r5,[r0,#4]            ;240
000020  6820              LDR      r0,[r4,#0]            ;243
000022  6085              STR      r5,[r0,#8]            ;243
000024  6820              LDR      r0,[r4,#0]            ;246
000026  60c5              STR      r5,[r0,#0xc]          ;246
000028  4908              LDR      r1,|L3.76|
00002a  6820              LDR      r0,[r4,#0]            ;246
00002c  1840              ADDS     r0,r0,r1              ;246
00002e  2114              MOVS     r1,#0x14              ;246
000030  f7fffffe          BL       __aeabi_uidivmod
000034  0081              LSLS     r1,r0,#2              ;246
000036  4806              LDR      r0,|L3.80|
000038  2201              MOVS     r2,#1                 ;252
00003a  6461              STR      r1,[r4,#0x44]         ;252
00003c  408a              LSLS     r2,r2,r1              ;252
00003e  6420              STR      r0,[r4,#0x40]         ;252
000040  6042              STR      r2,[r0,#4]            ;252
000042  63e5              STR      r5,[r4,#0x3c]         ;255
000044  6265              STR      r5,[r4,#0x24]         ;258
000046  2000              MOVS     r0,#0                 ;263
000048  6225              STR      r5,[r4,#0x20]         ;263
00004a  bd70              POP      {r4-r6,pc}
;;;265    
                          ENDP

                  |L3.76|
                          DCD      0xbffdfff8
                  |L3.80|
                          DCD      0x40020000

                          AREA ||i.HAL_DMA_GetError||, CODE, READONLY, ALIGN=1

                  HAL_DMA_GetError PROC
;;;803      */
;;;804    uint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)
000000  6bc0              LDR      r0,[r0,#0x3c]
;;;805    {
;;;806      return hdma->ErrorCode;
;;;807    }
000002  4770              BX       lr
;;;808    
                          ENDP


                          AREA ||i.HAL_DMA_GetState||, CODE, READONLY, ALIGN=1

                  HAL_DMA_GetState PROC
;;;792      */
;;;793    HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)
000000  6a40              LDR      r0,[r0,#0x24]
;;;794    {
;;;795      return hdma->State;
;;;796    }
000002  4770              BX       lr
;;;797    
                          ENDP


                          AREA ||i.HAL_DMA_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_DMA_IRQHandler PROC
;;;573      */
;;;574    void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
000000  b4f0              PUSH     {r4-r7}
;;;575    {
;;;576    	uint32_t flag_it = hdma->DmaBaseAddress->ISR;
000002  6c01              LDR      r1,[r0,#0x40]
000004  680d              LDR      r5,[r1,#0]
;;;577      uint32_t source_it = hdma->Instance->CCR;
000006  6801              LDR      r1,[r0,#0]
000008  680c              LDR      r4,[r1,#0]
;;;578              
;;;579      /* Half Transfer Complete Interrupt management ******************************/
;;;580      if ((RESET != (flag_it & (DMA_FLAG_HT1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_HT)))
00000a  2204              MOVS     r2,#4
00000c  6c46              LDR      r6,[r0,#0x44]
00000e  4613              MOV      r3,r2
000010  40b3              LSLS     r3,r3,r6
000012  422b              TST      r3,r5
000014  d010              BEQ      |L6.56|
000016  0763              LSLS     r3,r4,#29
000018  d50e              BPL      |L6.56|
;;;581      {
;;;582      	/* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
;;;583      	if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
00001a  680b              LDR      r3,[r1,#0]
00001c  069b              LSLS     r3,r3,#26
00001e  d402              BMI      |L6.38|
;;;584      	{
;;;585      		/* Disable the half transfer interrupt */
;;;586      		hdma->Instance->CCR &= ~DMA_IT_HT;
000020  680b              LDR      r3,[r1,#0]
000022  4393              BICS     r3,r3,r2
000024  600b              STR      r3,[r1,#0]
                  |L6.38|
;;;587      	}
;;;588      	
;;;589      	/* Clear the half transfer complete flag */
;;;590      	hdma->DmaBaseAddress->IFCR = DMA_FLAG_HT1 << hdma->ChannelIndex;
000026  6c41              LDR      r1,[r0,#0x44]
000028  408a              LSLS     r2,r2,r1
00002a  6c01              LDR      r1,[r0,#0x40]
00002c  604a              STR      r2,[r1,#4]
;;;591      	
;;;592      	/* DMA peripheral state is not updated in Half Transfer */
;;;593      	/* State is updated only in Transfer Complete case */
;;;594      	
;;;595      	if(hdma->XferHalfCpltCallback != NULL)
00002e  6b01              LDR      r1,[r0,#0x30]
000030  2900              CMP      r1,#0
000032  d133              BNE      |L6.156|
;;;596      	{
;;;597      		/* Half transfer callback */
;;;598      		hdma->XferHalfCpltCallback(hdma);
;;;599      	}
;;;600      }
;;;601      
;;;602      /* Transfer Complete Interrupt management ***********************************/
;;;603      else if ((RESET != (flag_it & (DMA_FLAG_TC1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_TC)))
;;;604      {
;;;605      	if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
;;;606      	{
;;;607      		/* Disable the transfer complete  & transfer error interrupts */
;;;608      		/* if the DMA mode is not CIRCULAR */
;;;609      		hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_TE);
;;;610      		
;;;611      		/* Change the DMA state */
;;;612      		hdma->State = HAL_DMA_STATE_READY;
;;;613      	}
;;;614      	
;;;615      	/* Clear the transfer complete flag */
;;;616      	hdma->DmaBaseAddress->IFCR = DMA_FLAG_TC1 << hdma->ChannelIndex;
;;;617      	
;;;618      	/* Process Unlocked */
;;;619      	__HAL_UNLOCK(hdma);
;;;620      	
;;;621      	if(hdma->XferCpltCallback != NULL)
;;;622      	{
;;;623      		/* Transfer complete callback */
;;;624      		hdma->XferCpltCallback(hdma);
;;;625      	}
;;;626      }
;;;627      
;;;628      /* Transfer Error Interrupt management ***************************************/
;;;629      else if (( RESET != (flag_it & (DMA_FLAG_TE1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_TE)))
;;;630      {
;;;631      	/* When a DMA transfer error occurs */
;;;632        /* A hardware clear of its EN bits is performed */
;;;633        /* Then, disable all DMA interrupts */
;;;634        hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
;;;635        
;;;636        /* Clear all flags */
;;;637        hdma->DmaBaseAddress->IFCR = DMA_FLAG_GL1 << hdma->ChannelIndex;
;;;638        
;;;639        /* Update error code */
;;;640        hdma->ErrorCode = HAL_DMA_ERROR_TE;
;;;641        
;;;642        /* Change the DMA state */
;;;643        hdma->State = HAL_DMA_STATE_READY;    
;;;644        
;;;645        /* Process Unlocked */
;;;646        __HAL_UNLOCK(hdma); 
;;;647        
;;;648        if(hdma->XferErrorCallback != NULL)
;;;649        {
;;;650        	/* Transfer error callback */
;;;651        	hdma->XferErrorCallback(hdma);
;;;652        }
;;;653       }
;;;654    }  
000034  bcf0              POP      {r4-r7}
000036  4770              BX       lr
                  |L6.56|
000038  2302              MOVS     r3,#2                 ;603
00003a  461f              MOV      r7,r3                 ;603
00003c  40b7              LSLS     r7,r7,r6              ;603
00003e  402f              ANDS     r7,r7,r5              ;603
000040  2201              MOVS     r2,#1                 ;612
000042  2f00              CMP      r7,#0                 ;603
000044  d014              BEQ      |L6.112|
000046  07a7              LSLS     r7,r4,#30             ;603
000048  d512              BPL      |L6.112|
00004a  680c              LDR      r4,[r1,#0]            ;605
00004c  06a4              LSLS     r4,r4,#26             ;605
00004e  d404              BMI      |L6.90|
000050  680c              LDR      r4,[r1,#0]            ;609
000052  250a              MOVS     r5,#0xa               ;609
000054  43ac              BICS     r4,r4,r5              ;609
000056  600c              STR      r4,[r1,#0]            ;609
000058  6242              STR      r2,[r0,#0x24]         ;612
                  |L6.90|
00005a  6c41              LDR      r1,[r0,#0x44]         ;616
00005c  408b              LSLS     r3,r3,r1              ;616
00005e  6c01              LDR      r1,[r0,#0x40]         ;616
000060  604b              STR      r3,[r1,#4]            ;616
000062  2100              MOVS     r1,#0                 ;619
000064  6201              STR      r1,[r0,#0x20]         ;621
000066  6ac1              LDR      r1,[r0,#0x2c]         ;621
000068  2900              CMP      r1,#0                 ;621
00006a  d117              BNE      |L6.156|
                  |L6.108|
00006c  bcf0              POP      {r4-r7}
00006e  4770              BX       lr
                  |L6.112|
000070  2308              MOVS     r3,#8                 ;629
000072  40b3              LSLS     r3,r3,r6              ;629
000074  422b              TST      r3,r5                 ;629
000076  d0f9              BEQ      |L6.108|
000078  0723              LSLS     r3,r4,#28             ;629
00007a  d5f7              BPL      |L6.108|
00007c  680b              LDR      r3,[r1,#0]            ;634
00007e  240e              MOVS     r4,#0xe               ;634
000080  43a3              BICS     r3,r3,r4              ;634
000082  600b              STR      r3,[r1,#0]            ;634
000084  6c43              LDR      r3,[r0,#0x44]         ;637
000086  4611              MOV      r1,r2                 ;637
000088  4099              LSLS     r1,r1,r3              ;637
00008a  6c03              LDR      r3,[r0,#0x40]         ;637
00008c  6059              STR      r1,[r3,#4]            ;637
00008e  63c2              STR      r2,[r0,#0x3c]         ;640
000090  6242              STR      r2,[r0,#0x24]         ;643
000092  2100              MOVS     r1,#0                 ;646
000094  6201              STR      r1,[r0,#0x20]         ;648
000096  6b41              LDR      r1,[r0,#0x34]         ;648
000098  2900              CMP      r1,#0                 ;648
00009a  d0e7              BEQ      |L6.108|
                  |L6.156|
00009c  bcf0              POP      {r4-r7}               ;651
00009e  4708              BX       r1                    ;651
;;;655    
                          ENDP


                          AREA ||i.HAL_DMA_Init||, CODE, READONLY, ALIGN=2

                  HAL_DMA_Init PROC
;;;153      */
;;;154    HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
000000  2800              CMP      r0,#0
;;;155    { 
;;;156      uint32_t tmp = 0U;
;;;157      
;;;158      /* Check the DMA handle allocation */
;;;159      if(NULL == hdma)
000002  d101              BNE      |L7.8|
;;;160      {
;;;161        return HAL_ERROR;
000004  2001              MOVS     r0,#1
;;;162      }
;;;163      
;;;164      /* Check the parameters */
;;;165      assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));
;;;166      assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
;;;167      assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
;;;168      assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
;;;169      assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
;;;170      assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
;;;171      assert_param(IS_DMA_MODE(hdma->Init.Mode));
;;;172      assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
;;;173      
;;;174      /* Change DMA peripheral state */
;;;175      hdma->State = HAL_DMA_STATE_BUSY;
;;;176    
;;;177      /* Get the CR register value */
;;;178      tmp = hdma->Instance->CCR;
;;;179      
;;;180      /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR bits */
;;;181      tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
;;;182                          DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
;;;183                          DMA_CCR_DIR));
;;;184      
;;;185      /* Prepare the DMA Channel configuration */
;;;186      tmp |=  hdma->Init.Direction        |
;;;187              hdma->Init.PeriphInc           | hdma->Init.MemInc           |
;;;188              hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
;;;189              hdma->Init.Mode                | hdma->Init.Priority;
;;;190    
;;;191      /* Write to DMA Channel CR register */
;;;192      hdma->Instance->CCR = tmp;  
;;;193      
;;;194      /* Initialize DmaBaseAddress and ChannelIndex parameters used 
;;;195         by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
;;;196      DMA_CalcBaseAndBitshift(hdma);
;;;197      
;;;198      /* Clean callbacks */
;;;199      hdma->XferCpltCallback = NULL;
;;;200      hdma->XferHalfCpltCallback = NULL;
;;;201      hdma->XferErrorCallback = NULL;
;;;202      hdma->XferAbortCallback = NULL;
;;;203      
;;;204      /* Initialise the error code */
;;;205      hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;206    
;;;207      /* Initialize the DMA state*/
;;;208      hdma->State = HAL_DMA_STATE_READY;
;;;209      
;;;210      /* Allocate lock resource and initialize it */
;;;211      hdma->Lock = HAL_UNLOCKED;
;;;212      
;;;213      return HAL_OK;
;;;214    }  
000006  4770              BX       lr
                  |L7.8|
000008  b570              PUSH     {r4-r6,lr}            ;155
00000a  4604              MOV      r4,r0                 ;155
00000c  2002              MOVS     r0,#2                 ;175
00000e  6260              STR      r0,[r4,#0x24]         ;175
000010  6822              LDR      r2,[r4,#0]            ;178
000012  6811              LDR      r1,[r2,#0]            ;178
000014  4812              LDR      r0,|L7.96|
000016  68a3              LDR      r3,[r4,#8]            ;186
000018  4001              ANDS     r1,r1,r0              ;181
00001a  6860              LDR      r0,[r4,#4]            ;186
00001c  6925              LDR      r5,[r4,#0x10]         ;186
00001e  4318              ORRS     r0,r0,r3              ;186
000020  68e3              LDR      r3,[r4,#0xc]          ;186
000022  432b              ORRS     r3,r3,r5              ;186
000024  4318              ORRS     r0,r0,r3              ;186
000026  6963              LDR      r3,[r4,#0x14]         ;186
000028  4318              ORRS     r0,r0,r3              ;186
00002a  69a3              LDR      r3,[r4,#0x18]         ;186
00002c  4318              ORRS     r0,r0,r3              ;186
00002e  69e3              LDR      r3,[r4,#0x1c]         ;186
000030  4318              ORRS     r0,r0,r3              ;186
000032  4308              ORRS     r0,r0,r1              ;186
000034  6010              STR      r0,[r2,#0]            ;192
000036  490b              LDR      r1,|L7.100|
000038  6820              LDR      r0,[r4,#0]            ;192
00003a  1840              ADDS     r0,r0,r1              ;192
00003c  2114              MOVS     r1,#0x14              ;192
00003e  f7fffffe          BL       __aeabi_uidivmod
000042  0080              LSLS     r0,r0,#2              ;192
000044  6460              STR      r0,[r4,#0x44]         ;192
000046  4808              LDR      r0,|L7.104|
000048  6420              STR      r0,[r4,#0x40]         ;199
00004a  2000              MOVS     r0,#0                 ;199
00004c  62e0              STR      r0,[r4,#0x2c]         ;200
00004e  6320              STR      r0,[r4,#0x30]         ;201
000050  6360              STR      r0,[r4,#0x34]         ;202
000052  63a0              STR      r0,[r4,#0x38]         ;205
000054  63e0              STR      r0,[r4,#0x3c]         ;205
000056  2101              MOVS     r1,#1                 ;208
000058  6261              STR      r1,[r4,#0x24]         ;208
00005a  6220              STR      r0,[r4,#0x20]         ;211
00005c  bd70              POP      {r4-r6,pc}
;;;215      
                          ENDP

00005e  0000              DCW      0x0000
                  |L7.96|
                          DCD      0xffffc00f
                  |L7.100|
                          DCD      0xbffdfff8
                  |L7.104|
                          DCD      0x40020000

                          AREA ||i.HAL_DMA_PollForTransfer||, CODE, READONLY, ALIGN=1

                  HAL_DMA_PollForTransfer PROC
;;;472      */
;;;473    HAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, uint32_t CompleteLevel, uint32_t Timeout)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;474    {
000002  4604              MOV      r4,r0
;;;475      uint32_t temp;
;;;476      uint32_t tickstart = 0U;
;;;477      
;;;478      if(HAL_DMA_STATE_BUSY != hdma->State)
000004  6a40              LDR      r0,[r0,#0x24]
000006  b082              SUB      sp,sp,#8              ;474
000008  4616              MOV      r6,r2                 ;474
00000a  2802              CMP      r0,#2
00000c  d006              BEQ      |L8.28|
;;;479      {
;;;480        /* no transfer ongoing */
;;;481        hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
00000e  2004              MOVS     r0,#4
000010  63e0              STR      r0,[r4,#0x3c]
;;;482        __HAL_UNLOCK(hdma);
000012  2000              MOVS     r0,#0
;;;483        return HAL_ERROR;
000014  6220              STR      r0,[r4,#0x20]
000016  2001              MOVS     r0,#1
;;;484      }
;;;485      
;;;486      /* Polling mode not supported in circular mode */
;;;487      if (RESET != (hdma->Instance->CCR & DMA_CCR_CIRC))
;;;488      {
;;;489        hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
;;;490        return HAL_ERROR;
;;;491      }
;;;492      
;;;493      /* Get the level transfer complete flag */
;;;494      if(HAL_DMA_FULL_TRANSFER == CompleteLevel)
;;;495      {
;;;496        /* Transfer Complete flag */
;;;497        temp = DMA_FLAG_TC1 << hdma->ChannelIndex;
;;;498      }
;;;499      else
;;;500      {
;;;501        /* Half Transfer Complete flag */
;;;502        temp = DMA_FLAG_HT1 << hdma->ChannelIndex;
;;;503      }
;;;504    
;;;505      /* Get tick */
;;;506      tickstart = HAL_GetTick();
;;;507    
;;;508      while(RESET == (hdma->DmaBaseAddress->ISR & temp))
;;;509      {
;;;510        if(RESET != (hdma->DmaBaseAddress->ISR & (DMA_FLAG_TE1 << hdma->ChannelIndex)))
;;;511        {      
;;;512          /* When a DMA transfer error occurs */
;;;513          /* A hardware clear of its EN bits is performed */
;;;514          /* Clear all flags */
;;;515          hdma->DmaBaseAddress->IFCR = DMA_FLAG_GL1 << hdma->ChannelIndex;
;;;516          
;;;517          /* Update error code */
;;;518          hdma->ErrorCode = HAL_DMA_ERROR_TE;
;;;519    
;;;520          /* Change the DMA state */
;;;521          hdma->State= HAL_DMA_STATE_READY;       
;;;522          
;;;523          /* Process Unlocked */
;;;524          __HAL_UNLOCK(hdma);
;;;525          
;;;526          return HAL_ERROR;      
;;;527        }      
;;;528        /* Check for the Timeout */
;;;529        if(Timeout != HAL_MAX_DELAY)
;;;530        {
;;;531          if((Timeout == 0U) || ((HAL_GetTick() - tickstart) > Timeout))
;;;532          {
;;;533            /* Update error code */
;;;534            hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
;;;535            
;;;536            /* Change the DMA state */
;;;537            hdma->State = HAL_DMA_STATE_READY;
;;;538    
;;;539            /* Process Unlocked */
;;;540            __HAL_UNLOCK(hdma);
;;;541    
;;;542            return HAL_ERROR;
;;;543          }
;;;544        }
;;;545      }
;;;546    
;;;547      if(HAL_DMA_FULL_TRANSFER == CompleteLevel)
;;;548      {
;;;549        /* Clear the transfer complete flag */
;;;550        hdma->DmaBaseAddress->IFCR = DMA_FLAG_TC1 << hdma->ChannelIndex;
;;;551    
;;;552        /* The selected Channelx EN bit is cleared (DMA is disabled and 
;;;553        all transfers are complete) */
;;;554        hdma->State = HAL_DMA_STATE_READY;
;;;555      }
;;;556      else
;;;557      { 
;;;558        /* Clear the half transfer complete flag */
;;;559        hdma->DmaBaseAddress->IFCR = DMA_FLAG_HT1 << hdma->ChannelIndex;
;;;560      }
;;;561      
;;;562      /* Process unlocked */
;;;563      __HAL_UNLOCK(hdma);  
;;;564    
;;;565      return HAL_OK;
;;;566    }
000018  b005              ADD      sp,sp,#0x14
00001a  bdf0              POP      {r4-r7,pc}
                  |L8.28|
00001c  6820              LDR      r0,[r4,#0]            ;487
00001e  6800              LDR      r0,[r0,#0]            ;487
000020  0680              LSLS     r0,r0,#26             ;487
000022  d503              BPL      |L8.44|
000024  20ff              MOVS     r0,#0xff              ;489
000026  3001              ADDS     r0,#1                 ;489
000028  63e0              STR      r0,[r4,#0x3c]         ;489
00002a  e032              B        |L8.146|
                  |L8.44|
00002c  9803              LDR      r0,[sp,#0xc]          ;494
00002e  2800              CMP      r0,#0                 ;494
000030  6c60              LDR      r0,[r4,#0x44]         ;494
000032  d01c              BEQ      |L8.110|
000034  2504              MOVS     r5,#4                 ;502
                  |L8.54|
000036  4085              LSLS     r5,r5,r0              ;502
000038  f7fffffe          BL       HAL_GetTick
00003c  9000              STR      r0,[sp,#0]            ;508
00003e  6c20              LDR      r0,[r4,#0x40]         ;508
000040  6800              LDR      r0,[r0,#0]            ;508
000042  4228              TST      r0,r5                 ;508
000044  d12c              BNE      |L8.160|
000046  2708              MOVS     r7,#8                 ;510
                  |L8.72|
000048  6c20              LDR      r0,[r4,#0x40]         ;510
00004a  6800              LDR      r0,[r0,#0]            ;510
00004c  6c62              LDR      r2,[r4,#0x44]         ;510
00004e  4639              MOV      r1,r7                 ;510
000050  4091              LSLS     r1,r1,r2              ;510
000052  4208              TST      r0,r1                 ;510
000054  d00d              BEQ      |L8.114|
000056  2001              MOVS     r0,#1                 ;515
000058  4601              MOV      r1,r0                 ;515
00005a  4091              LSLS     r1,r1,r2              ;515
00005c  6c22              LDR      r2,[r4,#0x40]         ;515
00005e  6051              STR      r1,[r2,#4]            ;515
000060  63e0              STR      r0,[r4,#0x3c]         ;518
000062  6260              STR      r0,[r4,#0x24]         ;521
000064  2000              MOVS     r0,#0                 ;524
000066  6220              STR      r0,[r4,#0x20]         ;526
000068  2001              MOVS     r0,#1                 ;526
00006a  b005              ADD      sp,sp,#0x14
00006c  bdf0              POP      {r4-r7,pc}
                  |L8.110|
00006e  2502              MOVS     r5,#2                 ;497
000070  e7e1              B        |L8.54|
                  |L8.114|
000072  1c70              ADDS     r0,r6,#1              ;529
000074  d010              BEQ      |L8.152|
000076  2e00              CMP      r6,#0                 ;531
000078  d005              BEQ      |L8.134|
00007a  f7fffffe          BL       HAL_GetTick
00007e  9900              LDR      r1,[sp,#0]            ;531
000080  1a40              SUBS     r0,r0,r1              ;531
000082  42b0              CMP      r0,r6                 ;531
000084  d908              BLS      |L8.152|
                  |L8.134|
000086  2020              MOVS     r0,#0x20              ;534
000088  63e0              STR      r0,[r4,#0x3c]         ;534
00008a  2001              MOVS     r0,#1                 ;537
00008c  6260              STR      r0,[r4,#0x24]         ;537
00008e  2000              MOVS     r0,#0                 ;540
000090  6220              STR      r0,[r4,#0x20]         ;540
                  |L8.146|
000092  2001              MOVS     r0,#1                 ;542
000094  b005              ADD      sp,sp,#0x14
000096  bdf0              POP      {r4-r7,pc}
                  |L8.152|
000098  6c20              LDR      r0,[r4,#0x40]         ;542
00009a  6800              LDR      r0,[r0,#0]            ;542
00009c  4228              TST      r0,r5                 ;542
00009e  d0d3              BEQ      |L8.72|
                  |L8.160|
0000a0  9803              LDR      r0,[sp,#0xc]          ;547
0000a2  6c61              LDR      r1,[r4,#0x44]         ;547
0000a4  2800              CMP      r0,#0                 ;547
0000a6  d007              BEQ      |L8.184|
0000a8  2004              MOVS     r0,#4                 ;559
0000aa  4088              LSLS     r0,r0,r1              ;559
0000ac  6c21              LDR      r1,[r4,#0x40]         ;559
0000ae  6048              STR      r0,[r1,#4]            ;559
                  |L8.176|
0000b0  2000              MOVS     r0,#0                 ;563
0000b2  6220              STR      r0,[r4,#0x20]         ;565
0000b4  b005              ADD      sp,sp,#0x14
0000b6  bdf0              POP      {r4-r7,pc}
                  |L8.184|
0000b8  2002              MOVS     r0,#2                 ;550
0000ba  4088              LSLS     r0,r0,r1              ;550
0000bc  6c21              LDR      r1,[r4,#0x40]         ;550
0000be  6048              STR      r0,[r1,#4]            ;550
0000c0  2001              MOVS     r0,#1                 ;554
0000c2  6260              STR      r0,[r4,#0x24]         ;554
0000c4  e7f4              B        |L8.176|
;;;567    
                          ENDP


                          AREA ||i.HAL_DMA_RegisterCallback||, CODE, READONLY, ALIGN=1

                  HAL_DMA_RegisterCallback PROC
;;;665      */                          
;;;666    HAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)( DMA_HandleTypeDef * _hdma))
000000  b410              PUSH     {r4}
;;;667    {
;;;668      HAL_StatusTypeDef status = HAL_OK;
;;;669      
;;;670      /* Process locked */
;;;671      __HAL_LOCK(hdma);
000002  6a04              LDR      r4,[r0,#0x20]
000004  2300              MOVS     r3,#0                 ;668
000006  2c01              CMP      r4,#1
000008  d005              BEQ      |L9.22|
00000a  2401              MOVS     r4,#1
;;;672      
;;;673      if(HAL_DMA_STATE_READY == hdma->State)
00000c  6204              STR      r4,[r0,#0x20]
00000e  6a44              LDR      r4,[r0,#0x24]
000010  2c01              CMP      r4,#1
000012  d003              BEQ      |L9.28|
000014  e00a              B        |L9.44|
                  |L9.22|
;;;674      {
;;;675        switch (CallbackID)
;;;676        {
;;;677         case  HAL_DMA_XFER_CPLT_CB_ID:
;;;678               hdma->XferCpltCallback = pCallback;
;;;679               break;
;;;680           
;;;681         case  HAL_DMA_XFER_HALFCPLT_CB_ID:
;;;682               hdma->XferHalfCpltCallback = pCallback;
;;;683               break;         
;;;684    
;;;685         case  HAL_DMA_XFER_ERROR_CB_ID:
;;;686               hdma->XferErrorCallback = pCallback;
;;;687               break;         
;;;688               
;;;689         case  HAL_DMA_XFER_ABORT_CB_ID:
;;;690               hdma->XferAbortCallback = pCallback;
;;;691               break; 
;;;692               
;;;693         default:
;;;694               status = HAL_ERROR;
;;;695               break;                                                            
;;;696        }
;;;697      }
;;;698      else
;;;699      {
;;;700        status = HAL_ERROR;
;;;701      } 
;;;702      
;;;703      /* Release Lock */
;;;704      __HAL_UNLOCK(hdma);
;;;705      
;;;706      return status;
;;;707    }
000016  bc10              POP      {r4}
000018  2002              MOVS     r0,#2                 ;671
00001a  4770              BX       lr
                  |L9.28|
00001c  2900              CMP      r1,#0                 ;675
00001e  d00b              BEQ      |L9.56|
000020  2901              CMP      r1,#1                 ;675
000022  d00b              BEQ      |L9.60|
000024  2902              CMP      r1,#2                 ;675
000026  d00b              BEQ      |L9.64|
000028  2903              CMP      r1,#3                 ;675
00002a  d00b              BEQ      |L9.68|
                  |L9.44|
00002c  2301              MOVS     r3,#1                 ;694
                  |L9.46|
00002e  2100              MOVS     r1,#0                 ;704
000030  6201              STR      r1,[r0,#0x20]         ;706
000032  bc10              POP      {r4}
000034  4618              MOV      r0,r3                 ;706
000036  4770              BX       lr
                  |L9.56|
000038  62c2              STR      r2,[r0,#0x2c]         ;679
00003a  e7f8              B        |L9.46|
                  |L9.60|
00003c  6302              STR      r2,[r0,#0x30]         ;683
00003e  e7f6              B        |L9.46|
                  |L9.64|
000040  6342              STR      r2,[r0,#0x34]         ;687
000042  e7f4              B        |L9.46|
                  |L9.68|
000044  6382              STR      r2,[r0,#0x38]         ;691
000046  e7f2              B        |L9.46|
;;;708    
                          ENDP


                          AREA ||i.HAL_DMA_Start||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Start PROC
;;;297      */
;;;298    HAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  b4f0              PUSH     {r4-r7}
;;;299    {
;;;300    	HAL_StatusTypeDef status = HAL_OK;
;;;301    
;;;302      /* Check the parameters */
;;;303      assert_param(IS_DMA_BUFFER_SIZE(DataLength));
;;;304      
;;;305      /* Process locked */
;;;306      __HAL_LOCK(hdma);
000002  6a04              LDR      r4,[r0,#0x20]
000004  2500              MOVS     r5,#0                 ;300
000006  2c01              CMP      r4,#1
000008  d00a              BEQ      |L10.32|
00000a  2401              MOVS     r4,#1
;;;307      
;;;308      if(HAL_DMA_STATE_READY == hdma->State)
00000c  6204              STR      r4,[r0,#0x20]
00000e  6a47              LDR      r7,[r0,#0x24]
000010  2600              MOVS     r6,#0
000012  2f01              CMP      r7,#1
000014  d007              BEQ      |L10.38|
;;;309      {
;;;310      	/* Change DMA peripheral state */  
;;;311      	hdma->State = HAL_DMA_STATE_BUSY;
;;;312      	
;;;313      	hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;314      	
;;;315      	/* Disable the peripheral */
;;;316      	hdma->Instance->CCR &= ~DMA_CCR_EN;  
;;;317      	
;;;318      	/* Configure the source, destination address and the data length */
;;;319      	DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
;;;320      	
;;;321      	/* Enable the Peripheral */
;;;322      	hdma->Instance->CCR |= DMA_CCR_EN;  
;;;323      }
;;;324      else
;;;325      {
;;;326      	/* Process Unlocked */
;;;327      	__HAL_UNLOCK(hdma);
;;;328      	
;;;329      	/* Remain BUSY */
;;;330      	status = HAL_BUSY;
000016  2502              MOVS     r5,#2
000018  6206              STR      r6,[r0,#0x20]
                  |L10.26|
;;;331      }  
;;;332    
;;;333      return status; 
00001a  4628              MOV      r0,r5
;;;334    } 
00001c  bcf0              POP      {r4-r7}
00001e  4770              BX       lr
                  |L10.32|
000020  bcf0              POP      {r4-r7}
000022  2002              MOVS     r0,#2                 ;306
000024  4770              BX       lr
                  |L10.38|
000026  2702              MOVS     r7,#2                 ;311
000028  6247              STR      r7,[r0,#0x24]         ;311
00002a  63c6              STR      r6,[r0,#0x3c]         ;313
00002c  6806              LDR      r6,[r0,#0]            ;316
00002e  6837              LDR      r7,[r6,#0]            ;316
000030  087f              LSRS     r7,r7,#1              ;316
000032  007f              LSLS     r7,r7,#1              ;316
000034  6037              STR      r7,[r6,#0]            ;316
000036  6c46              LDR      r6,[r0,#0x44]         ;316
000038  4627              MOV      r7,r4                 ;316
00003a  40b7              LSLS     r7,r7,r6              ;316
00003c  6c06              LDR      r6,[r0,#0x40]         ;316
00003e  6077              STR      r7,[r6,#4]            ;316
000040  6806              LDR      r6,[r0,#0]            ;316
000042  6073              STR      r3,[r6,#4]            ;316
000044  6843              LDR      r3,[r0,#4]            ;316
000046  2b10              CMP      r3,#0x10              ;316
000048  6803              LDR      r3,[r0,#0]            ;316
00004a  d007              BEQ      |L10.92|
00004c  6099              STR      r1,[r3,#8]            ;316
00004e  6801              LDR      r1,[r0,#0]            ;316
000050  60ca              STR      r2,[r1,#0xc]          ;316
                  |L10.82|
000052  6800              LDR      r0,[r0,#0]            ;322
000054  6801              LDR      r1,[r0,#0]            ;322
000056  4321              ORRS     r1,r1,r4              ;322
000058  6001              STR      r1,[r0,#0]            ;322
00005a  e7de              B        |L10.26|
                  |L10.92|
00005c  609a              STR      r2,[r3,#8]            ;322
00005e  6802              LDR      r2,[r0,#0]            ;322
000060  60d1              STR      r1,[r2,#0xc]          ;322
000062  e7f6              B        |L10.82|
;;;335    
                          ENDP


                          AREA ||i.HAL_DMA_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Start_IT PROC
;;;344      */
;;;345    HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  b4f0              PUSH     {r4-r7}
;;;346    {
;;;347    	HAL_StatusTypeDef status = HAL_OK;
;;;348    
;;;349      /* Check the parameters */
;;;350      assert_param(IS_DMA_BUFFER_SIZE(DataLength));
;;;351      
;;;352      /* Process locked */
;;;353      __HAL_LOCK(hdma);
000002  6a04              LDR      r4,[r0,#0x20]
000004  2500              MOVS     r5,#0                 ;347
000006  2c01              CMP      r4,#1
000008  d00a              BEQ      |L11.32|
00000a  2401              MOVS     r4,#1
;;;354      
;;;355      if(HAL_DMA_STATE_READY == hdma->State)
00000c  6204              STR      r4,[r0,#0x20]
00000e  6a47              LDR      r7,[r0,#0x24]
000010  2600              MOVS     r6,#0
000012  2f01              CMP      r7,#1
000014  d007              BEQ      |L11.38|
;;;356      {
;;;357      	/* Change DMA peripheral state */  
;;;358      	hdma->State = HAL_DMA_STATE_BUSY;
;;;359      	
;;;360      	hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;361      	
;;;362      	/* Disable the peripheral */
;;;363      	hdma->Instance->CCR &= ~DMA_CCR_EN;
;;;364      	
;;;365      	/* Configure the source, destination address and the data length */  
;;;366      	DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
;;;367      	
;;;368      	/* Enable the transfer complete, & transfer error interrupts */
;;;369      	/* Half transfer interrupt is optional: enable it only if associated callback is available */
;;;370        if(NULL != hdma->XferHalfCpltCallback )
;;;371        {
;;;372          hdma->Instance->CCR |= (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
;;;373        }
;;;374      	else
;;;375      	{
;;;376      		hdma->Instance->CCR |= (DMA_IT_TC | DMA_IT_TE);
;;;377      		hdma->Instance->CCR &= ~DMA_IT_HT;
;;;378      	}
;;;379      	
;;;380      	/* Enable the Peripheral */
;;;381      	hdma->Instance->CCR |= DMA_CCR_EN;
;;;382      }
;;;383      else
;;;384      {
;;;385      	/* Process Unlocked */
;;;386        __HAL_UNLOCK(hdma); 
;;;387      
;;;388        /* Remain BUSY */
;;;389        status = HAL_BUSY;
000016  2502              MOVS     r5,#2
000018  6206              STR      r6,[r0,#0x20]
                  |L11.26|
;;;390      }     
;;;391      
;;;392      return status;    
00001a  4628              MOV      r0,r5
;;;393    } 
00001c  bcf0              POP      {r4-r7}
00001e  4770              BX       lr
                  |L11.32|
000020  bcf0              POP      {r4-r7}
000022  2002              MOVS     r0,#2                 ;353
000024  4770              BX       lr
                  |L11.38|
000026  2702              MOVS     r7,#2                 ;358
000028  6247              STR      r7,[r0,#0x24]         ;358
00002a  63c6              STR      r6,[r0,#0x3c]         ;360
00002c  6806              LDR      r6,[r0,#0]            ;363
00002e  6837              LDR      r7,[r6,#0]            ;363
000030  087f              LSRS     r7,r7,#1              ;363
000032  007f              LSLS     r7,r7,#1              ;363
000034  6037              STR      r7,[r6,#0]            ;363
000036  6c46              LDR      r6,[r0,#0x44]         ;363
000038  4627              MOV      r7,r4                 ;363
00003a  40b7              LSLS     r7,r7,r6              ;363
00003c  6c06              LDR      r6,[r0,#0x40]         ;363
00003e  6077              STR      r7,[r6,#4]            ;363
000040  6806              LDR      r6,[r0,#0]            ;363
000042  6073              STR      r3,[r6,#4]            ;363
000044  6843              LDR      r3,[r0,#4]            ;363
000046  2b10              CMP      r3,#0x10              ;363
000048  6803              LDR      r3,[r0,#0]            ;363
00004a  d00a              BEQ      |L11.98|
00004c  6099              STR      r1,[r3,#8]            ;363
00004e  6801              LDR      r1,[r0,#0]            ;363
000050  60ca              STR      r2,[r1,#0xc]          ;363
                  |L11.82|
000052  6b01              LDR      r1,[r0,#0x30]         ;370
000054  2900              CMP      r1,#0                 ;370
000056  6801              LDR      r1,[r0,#0]            ;376
000058  680a              LDR      r2,[r1,#0]            ;376
00005a  d006              BEQ      |L11.106|
00005c  230e              MOVS     r3,#0xe               ;372
00005e  431a              ORRS     r2,r2,r3              ;372
000060  e00a              B        |L11.120|
                  |L11.98|
000062  609a              STR      r2,[r3,#8]            ;372
000064  6802              LDR      r2,[r0,#0]            ;372
000066  60d1              STR      r1,[r2,#0xc]          ;372
000068  e7f3              B        |L11.82|
                  |L11.106|
00006a  230a              MOVS     r3,#0xa               ;376
00006c  431a              ORRS     r2,r2,r3              ;376
00006e  600a              STR      r2,[r1,#0]            ;376
000070  6801              LDR      r1,[r0,#0]            ;377
000072  680a              LDR      r2,[r1,#0]            ;377
000074  2304              MOVS     r3,#4                 ;377
000076  439a              BICS     r2,r2,r3              ;377
                  |L11.120|
000078  600a              STR      r2,[r1,#0]            ;377
00007a  6800              LDR      r0,[r0,#0]            ;381
00007c  6801              LDR      r1,[r0,#0]            ;381
00007e  4321              ORRS     r1,r1,r4              ;381
000080  6001              STR      r1,[r0,#0]            ;381
000082  e7ca              B        |L11.26|
;;;394    
                          ENDP


                          AREA ||i.HAL_DMA_UnRegisterCallback||, CODE, READONLY, ALIGN=1

                  HAL_DMA_UnRegisterCallback PROC
;;;716      */              
;;;717    HAL_StatusTypeDef HAL_DMA_UnRegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID)
000000  6a02              LDR      r2,[r0,#0x20]
;;;718    {
;;;719      HAL_StatusTypeDef status = HAL_OK;
000002  2300              MOVS     r3,#0
;;;720    
;;;721        /* Process locked */
;;;722      __HAL_LOCK(hdma);
000004  2a01              CMP      r2,#1
000006  d101              BNE      |L12.12|
000008  2002              MOVS     r0,#2
;;;723      
;;;724      if(HAL_DMA_STATE_READY == hdma->State)
;;;725      {
;;;726        switch (CallbackID)
;;;727        {
;;;728         case  HAL_DMA_XFER_CPLT_CB_ID:
;;;729               hdma->XferCpltCallback = NULL;
;;;730               break;
;;;731           
;;;732         case  HAL_DMA_XFER_HALFCPLT_CB_ID:
;;;733               hdma->XferHalfCpltCallback = NULL;
;;;734               break;         
;;;735    
;;;736         case  HAL_DMA_XFER_ERROR_CB_ID:
;;;737               hdma->XferErrorCallback = NULL;
;;;738               break;         
;;;739               
;;;740         case  HAL_DMA_XFER_ABORT_CB_ID:
;;;741               hdma->XferAbortCallback = NULL;
;;;742               break; 
;;;743         
;;;744        case   HAL_DMA_XFER_ALL_CB_ID:
;;;745               hdma->XferCpltCallback = NULL;
;;;746               hdma->XferHalfCpltCallback = NULL;
;;;747               hdma->XferErrorCallback = NULL;
;;;748               hdma->XferAbortCallback = NULL;
;;;749               break; 
;;;750         
;;;751        default:
;;;752               status = HAL_ERROR;
;;;753               break;                                                            
;;;754        }
;;;755      }
;;;756      else
;;;757      {
;;;758        status = HAL_ERROR;
;;;759      } 
;;;760      
;;;761      /* Release Lock */
;;;762      __HAL_UNLOCK(hdma);
;;;763      
;;;764      return status;
;;;765    }
00000a  4770              BX       lr
                  |L12.12|
00000c  b410              PUSH     {r4}                  ;718
00000e  2201              MOVS     r2,#1                 ;722
000010  6202              STR      r2,[r0,#0x20]         ;724
000012  6a44              LDR      r4,[r0,#0x24]         ;724
000014  2200              MOVS     r2,#0                 ;724
000016  2c01              CMP      r4,#1                 ;724
000018  d116              BNE      |L12.72|
00001a  2905              CMP      r1,#5                 ;726
00001c  d214              BCS      |L12.72|
00001e  000c              MOVS     r4,r1                 ;726
000020  447c              ADD      r4,r4,pc              ;726
000022  7924              LDRB     r4,[r4,#4]            ;726
000024  1924              ADDS     r4,r4,r4              ;726
000026  44a7              ADD      pc,pc,r4              ;726
000028  02040608          DCB      0x02,0x04,0x06,0x08
00002c  0a00              DCB      0x0a,0x00
00002e  62c2              STR      r2,[r0,#0x2c]         ;730
000030  e00b              B        |L12.74|
000032  6302              STR      r2,[r0,#0x30]         ;734
000034  e009              B        |L12.74|
000036  6342              STR      r2,[r0,#0x34]         ;738
000038  e007              B        |L12.74|
00003a  6382              STR      r2,[r0,#0x38]         ;742
00003c  e005              B        |L12.74|
00003e  62c2              STR      r2,[r0,#0x2c]         ;746
000040  6302              STR      r2,[r0,#0x30]         ;747
000042  6342              STR      r2,[r0,#0x34]         ;748
000044  6382              STR      r2,[r0,#0x38]         ;749
000046  e000              B        |L12.74|
                  |L12.72|
000048  2301              MOVS     r3,#1                 ;752
                  |L12.74|
00004a  6202              STR      r2,[r0,#0x20]         ;764
00004c  bc10              POP      {r4}
00004e  4618              MOV      r0,r3                 ;764
000050  4770              BX       lr
;;;766    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F0_V1.9.0\\Drivers\\STM32F0xx_HAL_Driver\\Src\\stm32f0xx_hal_dma.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f0xx_hal_dma_c_c25f65ec____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F0_V1.9.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f0xx_hal_dma_c_c25f65ec____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f0xx_hal_dma_c_c25f65ec____REVSH|
#line 402
|__asm___19_stm32f0xx_hal_dma_c_c25f65ec____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
