; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f0xx_hal_rcc.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f0xx_hal_rcc.d --cpu=Cortex-M0 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F0_V1.9.0\Drivers\STM32F0xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_F0_V1.9.0\Drivers\CMSIS\Device\ST\STM32L0xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F0_V1.9.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F0_V1.9.0\Drivers\STM32F0xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F030F4P6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F0xx_DFP\2.0.0\Drivers\CMSIS\Device\ST\STM32F0xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F030x6 -DSTM32F030x6 -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f0xx_hal_rcc.crf ..\..\..\M0P0_Library\STM32Cube_FW_F0_V1.9.0\Drivers\STM32F0xx_HAL_Driver\Src\stm32f0xx_hal_rcc.c]
                          THUMB

                          AREA ||i.HAL_RCC_CSSCallback||, CODE, READONLY, ALIGN=1

                  HAL_RCC_CSSCallback PROC
;;;1307     */
;;;1308   __weak void HAL_RCC_CSSCallback(void)
000000  4770              BX       lr
;;;1309   {
;;;1310     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1311       the HAL_RCC_CSSCallback could be implemented in the user file
;;;1312       */ 
;;;1313   }
;;;1314   
                          ENDP


                          AREA ||i.HAL_RCC_ClockConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_ClockConfig PROC
;;;724      */
;;;725    HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
000000  b5f0              PUSH     {r4-r7,lr}
;;;726    {
000002  4605              MOV      r5,r0
;;;727      uint32_t tickstart = 0U;
;;;728      
;;;729      /* Check the parameters */
;;;730      assert_param(RCC_ClkInitStruct != NULL);
;;;731      assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
;;;732      assert_param(IS_FLASH_LATENCY(FLatency));
;;;733    
;;;734      /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
;;;735      must be correctly programmed according to the frequency of the CPU clock 
;;;736        (HCLK) of the device. */
;;;737    
;;;738      /* Increasing the number of wait states because of higher CPU frequency */
;;;739      if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
000004  4861              LDR      r0,|L2.396|
000006  b089              SUB      sp,sp,#0x24           ;726
000008  6800              LDR      r0,[r0,#0]
00000a  460f              MOV      r7,r1                 ;726
00000c  07c0              LSLS     r0,r0,#31
00000e  0fc0              LSRS     r0,r0,#31
000010  42b8              CMP      r0,r7
000012  d20a              BCS      |L2.42|
;;;740      {    
;;;741        /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
;;;742        __HAL_FLASH_SET_LATENCY(FLatency);
000014  485d              LDR      r0,|L2.396|
000016  6801              LDR      r1,[r0,#0]
000018  0849              LSRS     r1,r1,#1
00001a  0049              LSLS     r1,r1,#1
00001c  4339              ORRS     r1,r1,r7
00001e  6001              STR      r1,[r0,#0]
;;;743        
;;;744        /* Check that the new number of wait states is taken into account to access the Flash
;;;745        memory by reading the FLASH_ACR register */
;;;746        if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
000020  6800              LDR      r0,[r0,#0]
000022  07c0              LSLS     r0,r0,#31
000024  0fc0              LSRS     r0,r0,#31
000026  42b8              CMP      r0,r7
000028  d171              BNE      |L2.270|
                  |L2.42|
;;;747        {
;;;748          return HAL_ERROR;
;;;749        }
;;;750      }
;;;751    
;;;752      /*-------------------------- HCLK Configuration --------------------------*/
;;;753      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
00002a  7828              LDRB     r0,[r5,#0]
00002c  0780              LSLS     r0,r0,#30
00002e  d506              BPL      |L2.62|
;;;754      {
;;;755        assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
;;;756        MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
000030  4857              LDR      r0,|L2.400|
000032  6841              LDR      r1,[r0,#4]
000034  22f0              MOVS     r2,#0xf0
000036  4391              BICS     r1,r1,r2
000038  68aa              LDR      r2,[r5,#8]
00003a  4311              ORRS     r1,r1,r2
00003c  6041              STR      r1,[r0,#4]
                  |L2.62|
;;;757      }
;;;758    
;;;759      /*------------------------- SYSCLK Configuration ---------------------------*/ 
;;;760      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
00003e  7828              LDRB     r0,[r5,#0]
000040  07c0              LSLS     r0,r0,#31
000042  d054              BEQ      |L2.238|
;;;761      {    
;;;762        assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
;;;763        
;;;764        /* HSE is selected as System Clock Source */
;;;765        if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
000044  6868              LDR      r0,[r5,#4]
000046  2801              CMP      r0,#1
000048  d021              BEQ      |L2.142|
;;;766        {
;;;767          /* Check the HSE ready flag */  
;;;768          if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
;;;769          {
;;;770            return HAL_ERROR;
;;;771          }
;;;772        }
;;;773        /* PLL is selected as System Clock Source */
;;;774        else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
;;;775        {
;;;776          /* Check the PLL ready flag */  
;;;777          if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
;;;778          {
;;;779            return HAL_ERROR;
;;;780          }
;;;781        }
;;;782    #if defined(RCC_CFGR_SWS_HSI48)
;;;783        /* HSI48 is selected as System Clock Source */
;;;784        else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI48)
;;;785        {
;;;786          /* Check the HSI48 ready flag */
;;;787          if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == RESET)
;;;788          {
;;;789            return HAL_ERROR;
;;;790          }
;;;791        }
;;;792    #endif /* RCC_CFGR_SWS_HSI48 */
;;;793        /* HSI is selected as System Clock Source */
;;;794        else
;;;795        {
;;;796          /* Check the HSI ready flag */  
;;;797          if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
00004a  4951              LDR      r1,|L2.400|
00004c  2802              CMP      r0,#2                 ;774
00004e  6809              LDR      r1,[r1,#0]
000050  d022              BEQ      |L2.152|
000052  0789              LSLS     r1,r1,#30
000054  d55b              BPL      |L2.270|
                  |L2.86|
;;;798          {
;;;799            return HAL_ERROR;
;;;800          }
;;;801        }
;;;802        __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
000056  4c4e              LDR      r4,|L2.400|
000058  6861              LDR      r1,[r4,#4]
00005a  0889              LSRS     r1,r1,#2
00005c  0089              LSLS     r1,r1,#2
00005e  4301              ORRS     r1,r1,r0
000060  6061              STR      r1,[r4,#4]
;;;803    
;;;804        /* Get Start Tick */
;;;805        tickstart = HAL_GetTick();
000062  f7fffffe          BL       HAL_GetTick
000066  4606              MOV      r6,r0
;;;806        
;;;807        if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
000068  6869              LDR      r1,[r5,#4]
;;;808        {
;;;809          while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
;;;810          {
;;;811            if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
00006a  484a              LDR      r0,|L2.404|
00006c  2901              CMP      r1,#1                 ;807
00006e  d016              BEQ      |L2.158|
;;;812            {
;;;813              return HAL_TIMEOUT;
;;;814            }
;;;815          }
;;;816        }
;;;817        else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
;;;818        {
;;;819          while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
;;;820          {
;;;821            if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
;;;822            {
;;;823              return HAL_TIMEOUT;
;;;824            }
;;;825          }
;;;826        }
;;;827    #if defined(RCC_CFGR_SWS_HSI48)
;;;828        else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI48)
;;;829        {
;;;830          while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI48)
;;;831          {
;;;832            if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
;;;833            {
;;;834              return HAL_TIMEOUT;
;;;835            }
;;;836          }
;;;837        }
;;;838    #endif /* RCC_CFGR_SWS_HSI48 */
;;;839        else
;;;840        {
;;;841          while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
000070  6862              LDR      r2,[r4,#4]
000072  2902              CMP      r1,#2                 ;817
000074  d025              BEQ      |L2.194|
000076  0712              LSLS     r2,r2,#28
000078  0f92              LSRS     r2,r2,#30
00007a  d038              BEQ      |L2.238|
00007c  4604              MOV      r4,r0                 ;811
                  |L2.126|
;;;842          {
;;;843            if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
00007e  f7fffffe          BL       HAL_GetTick
000082  1b80              SUBS     r0,r0,r6
000084  42a0              CMP      r0,r4
000086  d92d              BLS      |L2.228|
                  |L2.136|
;;;844            {
;;;845              return HAL_TIMEOUT;
000088  2003              MOVS     r0,#3
;;;846            }
;;;847          }
;;;848        }      
;;;849      }    
;;;850      /* Decreasing the number of wait states because of lower CPU frequency */
;;;851      if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
;;;852      {    
;;;853        /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
;;;854        __HAL_FLASH_SET_LATENCY(FLatency);
;;;855        
;;;856        /* Check that the new number of wait states is taken into account to access the Flash
;;;857        memory by reading the FLASH_ACR register */
;;;858        if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
;;;859        {
;;;860          return HAL_ERROR;
;;;861        }
;;;862      }    
;;;863    
;;;864      /*-------------------------- PCLK1 Configuration ---------------------------*/ 
;;;865      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
;;;866      {
;;;867        assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
;;;868        MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE, RCC_ClkInitStruct->APB1CLKDivider);
;;;869      }
;;;870      
;;;871      /* Update the SystemCoreClock global variable */
;;;872      SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_BITNUMBER];
;;;873    
;;;874      /* Configure the source of time base considering new system clocks settings*/
;;;875      HAL_InitTick (TICK_INT_PRIORITY);
;;;876      
;;;877      return HAL_OK;
;;;878    }
00008a  b009              ADD      sp,sp,#0x24
00008c  bdf0              POP      {r4-r7,pc}
                  |L2.142|
00008e  4940              LDR      r1,|L2.400|
000090  6809              LDR      r1,[r1,#0]            ;768
000092  0389              LSLS     r1,r1,#14             ;768
000094  d53b              BPL      |L2.270|
000096  e7de              B        |L2.86|
                  |L2.152|
000098  0189              LSLS     r1,r1,#6              ;777
00009a  d538              BPL      |L2.270|
00009c  e7db              B        |L2.86|
                  |L2.158|
00009e  6862              LDR      r2,[r4,#4]            ;809
0000a0  0712              LSLS     r2,r2,#28             ;809
0000a2  0f92              LSRS     r2,r2,#30             ;809
0000a4  2a01              CMP      r2,#1                 ;809
0000a6  d022              BEQ      |L2.238|
0000a8  4604              MOV      r4,r0                 ;811
                  |L2.170|
0000aa  f7fffffe          BL       HAL_GetTick
0000ae  1b80              SUBS     r0,r0,r6              ;811
0000b0  42a0              CMP      r0,r4                 ;811
0000b2  d8e9              BHI      |L2.136|
0000b4  4836              LDR      r0,|L2.400|
0000b6  6840              LDR      r0,[r0,#4]            ;809
0000b8  0700              LSLS     r0,r0,#28             ;809
0000ba  0f80              LSRS     r0,r0,#30             ;809
0000bc  2801              CMP      r0,#1                 ;809
0000be  d1f4              BNE      |L2.170|
0000c0  e015              B        |L2.238|
                  |L2.194|
0000c2  0712              LSLS     r2,r2,#28             ;819
0000c4  0f92              LSRS     r2,r2,#30             ;819
0000c6  2a02              CMP      r2,#2                 ;819
0000c8  d011              BEQ      |L2.238|
0000ca  4604              MOV      r4,r0                 ;811
                  |L2.204|
0000cc  f7fffffe          BL       HAL_GetTick
0000d0  1b80              SUBS     r0,r0,r6              ;821
0000d2  42a0              CMP      r0,r4                 ;821
0000d4  d8d8              BHI      |L2.136|
0000d6  482e              LDR      r0,|L2.400|
0000d8  6840              LDR      r0,[r0,#4]            ;819
0000da  0700              LSLS     r0,r0,#28             ;819
0000dc  0f80              LSRS     r0,r0,#30             ;819
0000de  2802              CMP      r0,#2                 ;819
0000e0  d1f4              BNE      |L2.204|
0000e2  e004              B        |L2.238|
                  |L2.228|
0000e4  482a              LDR      r0,|L2.400|
0000e6  6840              LDR      r0,[r0,#4]            ;841
0000e8  0700              LSLS     r0,r0,#28             ;841
0000ea  0f80              LSRS     r0,r0,#30             ;841
0000ec  d1c7              BNE      |L2.126|
                  |L2.238|
0000ee  4827              LDR      r0,|L2.396|
0000f0  6801              LDR      r1,[r0,#0]            ;851
0000f2  07c9              LSLS     r1,r1,#31             ;851
0000f4  0fc9              LSRS     r1,r1,#31             ;851
0000f6  42b9              CMP      r1,r7                 ;851
0000f8  d90c              BLS      |L2.276|
0000fa  6801              LDR      r1,[r0,#0]            ;854
0000fc  0849              LSRS     r1,r1,#1              ;854
0000fe  0049              LSLS     r1,r1,#1              ;854
000100  4339              ORRS     r1,r1,r7              ;854
000102  6001              STR      r1,[r0,#0]            ;854
000104  6800              LDR      r0,[r0,#0]            ;858
000106  07c0              LSLS     r0,r0,#31             ;858
000108  0fc0              LSRS     r0,r0,#31             ;858
00010a  42b8              CMP      r0,r7                 ;858
00010c  d002              BEQ      |L2.276|
                  |L2.270|
00010e  2001              MOVS     r0,#1                 ;860
000110  b009              ADD      sp,sp,#0x24
000112  bdf0              POP      {r4-r7,pc}
                  |L2.276|
000114  7828              LDRB     r0,[r5,#0]            ;865
000116  0740              LSLS     r0,r0,#29             ;865
000118  d507              BPL      |L2.298|
00011a  481d              LDR      r0,|L2.400|
00011c  6841              LDR      r1,[r0,#4]            ;868
00011e  2207              MOVS     r2,#7                 ;868
000120  0212              LSLS     r2,r2,#8              ;868
000122  4391              BICS     r1,r1,r2              ;868
000124  68ea              LDR      r2,[r5,#0xc]          ;868
000126  4311              ORRS     r1,r1,r2              ;868
000128  6041              STR      r1,[r0,#4]            ;868
                  |L2.298|
00012a  4a1b              LDR      r2,|L2.408|
00012c  466c              MOV      r4,sp                 ;868
00012e  ca0f              LDM      r2,{r0-r3}            ;868
000130  c40f              STM      r4!,{r0-r3}           ;868
000132  4b1a              LDR      r3,|L2.412|
000134  4d16              LDR      r5,|L2.400|
000136  cb0f              LDM      r3,{r0-r3}            ;868
000138  c40f              STM      r4!,{r0-r3}           ;868
00013a  686a              LDR      r2,[r5,#4]            ;868
00013c  200c              MOVS     r0,#0xc               ;868
00013e  4611              MOV      r1,r2                 ;868
000140  4001              ANDS     r1,r1,r0              ;868
000142  4817              LDR      r0,|L2.416|
000144  2904              CMP      r1,#4                 ;868
000146  d013              BEQ      |L2.368|
000148  2908              CMP      r1,#8                 ;868
00014a  d111              BNE      |L2.368|
00014c  0291              LSLS     r1,r2,#10             ;868
00014e  0f09              LSRS     r1,r1,#28             ;868
000150  466b              MOV      r3,sp                 ;868
000152  5c5c              LDRB     r4,[r3,r1]            ;868
000154  6ae9              LDR      r1,[r5,#0x2c]         ;868
000156  ab04              ADD      r3,sp,#0x10           ;868
000158  0709              LSLS     r1,r1,#28             ;868
00015a  0f09              LSRS     r1,r1,#28             ;868
00015c  5c59              LDRB     r1,[r3,r1]            ;868
00015e  03d2              LSLS     r2,r2,#15             ;868
000160  d503              BPL      |L2.362|
000162  f7fffffe          BL       __aeabi_uidivmod
000166  4360              MULS     r0,r4,r0              ;868
000168  e002              B        |L2.368|
                  |L2.362|
00016a  490e              LDR      r1,|L2.420|
00016c  4620              MOV      r0,r4                 ;868
00016e  4348              MULS     r0,r1,r0              ;868
                  |L2.368|
000170  6869              LDR      r1,[r5,#4]            ;872
000172  4a0d              LDR      r2,|L2.424|
000174  0609              LSLS     r1,r1,#24             ;872
000176  0f09              LSRS     r1,r1,#28             ;872
000178  5c51              LDRB     r1,[r2,r1]            ;872
00017a  40c8              LSRS     r0,r0,r1              ;872
00017c  490b              LDR      r1,|L2.428|
00017e  6008              STR      r0,[r1,#0]            ;875  ; SystemCoreClock
000180  2003              MOVS     r0,#3                 ;875
000182  f7fffffe          BL       HAL_InitTick
000186  2000              MOVS     r0,#0                 ;877
000188  b009              ADD      sp,sp,#0x24
00018a  bdf0              POP      {r4-r7,pc}
;;;879    
                          ENDP

                  |L2.396|
                          DCD      0x40022000
                  |L2.400|
                          DCD      0x40021000
                  |L2.404|
                          DCD      0x00001388
                  |L2.408|
                          DCD      ||i.HAL_RCC_GetSysClockFreq||+0x50
                  |L2.412|
                          DCD      ||i.HAL_RCC_GetSysClockFreq||+0x60
                  |L2.416|
                          DCD      0x007a1200
                  |L2.420|
                          DCD      0x003d0900
                  |L2.424|
                          DCD      AHBPrescTable
                  |L2.428|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_RCC_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_RCC_DeInit PROC
;;;224      */
;;;225    void HAL_RCC_DeInit(void)
000000  480d              LDR      r0,|L3.56|
;;;226    {
;;;227      /* Set HSION bit, HSITRIM[4:0] bits to the reset value*/
;;;228      SET_BIT(RCC->CR, RCC_CR_HSION | RCC_CR_HSITRIM_4); 
000002  6801              LDR      r1,[r0,#0]
000004  2281              MOVS     r2,#0x81
000006  4311              ORRS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;229    
;;;230      /* Reset SW[1:0], HPRE[3:0], PPRE[2:0] and MCOSEL[2:0] bits */
;;;231      CLEAR_BIT(RCC->CFGR, RCC_CFGR_SW | RCC_CFGR_HPRE | RCC_CFGR_PPRE | RCC_CFGR_MCO);
00000a  6841              LDR      r1,[r0,#4]
00000c  4a0b              LDR      r2,|L3.60|
00000e  4011              ANDS     r1,r1,r2
000010  6041              STR      r1,[r0,#4]
;;;232    
;;;233      /* Reset HSEON, CSSON, PLLON bits */
;;;234      CLEAR_BIT(RCC->CR, RCC_CR_PLLON | RCC_CR_CSSON | RCC_CR_HSEON);
000012  6801              LDR      r1,[r0,#0]
000014  4a0a              LDR      r2,|L3.64|
000016  4011              ANDS     r1,r1,r2
000018  6001              STR      r1,[r0,#0]
;;;235      
;;;236      /* Reset HSEBYP bit */
;;;237      CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
00001a  6801              LDR      r1,[r0,#0]
00001c  2201              MOVS     r2,#1
00001e  0492              LSLS     r2,r2,#18
000020  4391              BICS     r1,r1,r2
000022  6001              STR      r1,[r0,#0]
;;;238    
;;;239      /* Reset CFGR register */
;;;240      CLEAR_REG(RCC->CFGR);
000024  2100              MOVS     r1,#0
000026  6041              STR      r1,[r0,#4]
;;;241      
;;;242      /* Reset CFGR2 register */
;;;243      CLEAR_REG(RCC->CFGR2);
000028  62c1              STR      r1,[r0,#0x2c]
;;;244      
;;;245      /* Reset CFGR3 register */
;;;246      CLEAR_REG(RCC->CFGR3);
00002a  6301              STR      r1,[r0,#0x30]
;;;247      
;;;248      /* Disable all interrupts */
;;;249      CLEAR_REG(RCC->CIR);
00002c  6081              STR      r1,[r0,#8]
;;;250    
;;;251      /* Update the SystemCoreClock global variable */
;;;252      SystemCoreClock = HSI_VALUE;
00002e  4906              LDR      r1,|L3.72|
000030  4804              LDR      r0,|L3.68|
000032  6008              STR      r0,[r1,#0]  ; SystemCoreClock
;;;253    }
000034  4770              BX       lr
;;;254    
                          ENDP

000036  0000              DCW      0x0000
                  |L3.56|
                          DCD      0x40021000
                  |L3.60|
                          DCD      0xf0fff80c
                  |L3.64|
                          DCD      0xfef6ffff
                  |L3.68|
                          DCD      0x007a1200
                  |L3.72|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_RCC_DisableCSS||, CODE, READONLY, ALIGN=2

                  HAL_RCC_DisableCSS PROC
;;;1027     */
;;;1028   void HAL_RCC_DisableCSS(void)
000000  4803              LDR      r0,|L4.16|
;;;1029   {
;;;1030     CLEAR_BIT(RCC->CR, RCC_CR_CSSON) ;
000002  6801              LDR      r1,[r0,#0]
000004  2201              MOVS     r2,#1
000006  04d2              LSLS     r2,r2,#19
000008  4391              BICS     r1,r1,r2
00000a  6001              STR      r1,[r0,#0]
;;;1031   }
00000c  4770              BX       lr
;;;1032   
                          ENDP

00000e  0000              DCW      0x0000
                  |L4.16|
                          DCD      0x40021000

                          AREA ||i.HAL_RCC_EnableCSS||, CODE, READONLY, ALIGN=2

                  HAL_RCC_EnableCSS PROC
;;;1018     */
;;;1019   void HAL_RCC_EnableCSS(void)
000000  4803              LDR      r0,|L5.16|
;;;1020   {
;;;1021     SET_BIT(RCC->CR, RCC_CR_CSSON) ;
000002  6801              LDR      r1,[r0,#0]
000004  2201              MOVS     r2,#1
000006  04d2              LSLS     r2,r2,#19
000008  4311              ORRS     r1,r1,r2
00000a  6001              STR      r1,[r0,#0]
;;;1022   }
00000c  4770              BX       lr
;;;1023   
                          ENDP

00000e  0000              DCW      0x0000
                  |L5.16|
                          DCD      0x40021000

                          AREA ||i.HAL_RCC_GetClockConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetClockConfig PROC
;;;1264     */
;;;1265   void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
000000  b410              PUSH     {r4}
;;;1266   {
;;;1267     /* Check the parameters */
;;;1268     assert_param(RCC_ClkInitStruct != NULL);
;;;1269     assert_param(pFLatency != NULL);
;;;1270   
;;;1271     /* Set all possible values for the Clock type parameter --------------------*/
;;;1272     RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1;
000002  2207              MOVS     r2,#7
;;;1273     
;;;1274     /* Get the SYSCLK configuration --------------------------------------------*/ 
;;;1275     RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
000004  6002              STR      r2,[r0,#0]
000006  4a0a              LDR      r2,|L6.48|
000008  6853              LDR      r3,[r2,#4]
00000a  079b              LSLS     r3,r3,#30
00000c  0f9b              LSRS     r3,r3,#30
;;;1276     
;;;1277     /* Get the HCLK configuration ----------------------------------------------*/ 
;;;1278     RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE); 
00000e  6043              STR      r3,[r0,#4]
000010  6853              LDR      r3,[r2,#4]
000012  24f0              MOVS     r4,#0xf0
000014  4023              ANDS     r3,r3,r4
;;;1279     
;;;1280     /* Get the APB1 configuration ----------------------------------------------*/ 
;;;1281     RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE);   
000016  6083              STR      r3,[r0,#8]
000018  6852              LDR      r2,[r2,#4]
00001a  2307              MOVS     r3,#7
00001c  021b              LSLS     r3,r3,#8
00001e  401a              ANDS     r2,r2,r3
;;;1282     /* Get the Flash Wait State (Latency) configuration ------------------------*/   
;;;1283     *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY); 
000020  60c2              STR      r2,[r0,#0xc]
000022  4804              LDR      r0,|L6.52|
000024  6800              LDR      r0,[r0,#0]
000026  07c0              LSLS     r0,r0,#31
000028  0fc0              LSRS     r0,r0,#31
00002a  6008              STR      r0,[r1,#0]
;;;1284   }
00002c  bc10              POP      {r4}
00002e  4770              BX       lr
;;;1285   
                          ENDP

                  |L6.48|
                          DCD      0x40021000
                  |L6.52|
                          DCD      0x40022000

                          AREA ||i.HAL_RCC_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetHCLKFreq PROC
;;;1138     */
;;;1139   uint32_t HAL_RCC_GetHCLKFreq(void)
000000  4801              LDR      r0,|L7.8|
;;;1140   {
;;;1141     return SystemCoreClock;
000002  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;1142   }
000004  4770              BX       lr
;;;1143   
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_RCC_GetOscConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetOscConfig PROC
;;;1162     */
;;;1163   void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
000000  b430              PUSH     {r4,r5}
;;;1164   {
;;;1165     /* Check the parameters */
;;;1166     assert_param(RCC_OscInitStruct != NULL);
;;;1167   
;;;1168     /* Set all possible values for the Oscillator type parameter ---------------*/
;;;1169     RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI  \
000002  211f              MOVS     r1,#0x1f
;;;1170                     | RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_HSI14;
;;;1171   #if defined(RCC_HSI48_SUPPORT)
;;;1172     RCC_OscInitStruct->OscillatorType |= RCC_OSCILLATORTYPE_HSI48;
;;;1173   #endif /* RCC_HSI48_SUPPORT */
;;;1174   
;;;1175   
;;;1176     /* Get the HSE configuration -----------------------------------------------*/
;;;1177     if((RCC->CR &RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
000004  6001              STR      r1,[r0,#0]
000006  4926              LDR      r1,|L8.160|
000008  680a              LDR      r2,[r1,#0]
;;;1178     {
;;;1179       RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
00000a  2405              MOVS     r4,#5
00000c  0355              LSLS     r5,r2,#13             ;1177
00000e  2300              MOVS     r3,#0
;;;1180     }
;;;1181     else if((RCC->CR &RCC_CR_HSEON) == RCC_CR_HSEON)
;;;1182     {
;;;1183       RCC_OscInitStruct->HSEState = RCC_HSE_ON;
000010  2201              MOVS     r2,#1
000012  2d00              CMP      r5,#0                 ;1177
000014  da01              BGE      |L8.26|
000016  6044              STR      r4,[r0,#4]            ;1179
000018  e005              B        |L8.38|
                  |L8.26|
00001a  680d              LDR      r5,[r1,#0]            ;1181
00001c  03ed              LSLS     r5,r5,#15             ;1181
00001e  d501              BPL      |L8.36|
000020  6042              STR      r2,[r0,#4]
000022  e000              B        |L8.38|
                  |L8.36|
;;;1184     }
;;;1185     else
;;;1186     {
;;;1187       RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
000024  6043              STR      r3,[r0,#4]
                  |L8.38|
;;;1188     }
;;;1189   
;;;1190     /* Get the HSI configuration -----------------------------------------------*/
;;;1191     if((RCC->CR &RCC_CR_HSION) == RCC_CR_HSION)
000026  680d              LDR      r5,[r1,#0]
000028  07ed              LSLS     r5,r5,#31
00002a  d001              BEQ      |L8.48|
;;;1192     {
;;;1193       RCC_OscInitStruct->HSIState = RCC_HSI_ON;
00002c  60c2              STR      r2,[r0,#0xc]
00002e  e000              B        |L8.50|
                  |L8.48|
;;;1194     }
;;;1195     else
;;;1196     {
;;;1197       RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
000030  60c3              STR      r3,[r0,#0xc]
                  |L8.50|
;;;1198     }
;;;1199     
;;;1200     RCC_OscInitStruct->HSICalibrationValue = (uint32_t)((RCC->CR &RCC_CR_HSITRIM) >> RCC_CR_HSITRIM_BitNumber);
000032  680d              LDR      r5,[r1,#0]
000034  062d              LSLS     r5,r5,#24
000036  0eed              LSRS     r5,r5,#27
;;;1201     
;;;1202     /* Get the LSE configuration -----------------------------------------------*/
;;;1203     if((RCC->BDCR &RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
000038  6105              STR      r5,[r0,#0x10]
00003a  6a0d              LDR      r5,[r1,#0x20]
00003c  076d              LSLS     r5,r5,#29
00003e  d501              BPL      |L8.68|
;;;1204     {
;;;1205       RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
000040  6084              STR      r4,[r0,#8]
000042  e005              B        |L8.80|
                  |L8.68|
;;;1206     }
;;;1207     else if((RCC->BDCR &RCC_BDCR_LSEON) == RCC_BDCR_LSEON)
000044  6a0c              LDR      r4,[r1,#0x20]
000046  07e4              LSLS     r4,r4,#31
000048  d001              BEQ      |L8.78|
;;;1208     {
;;;1209       RCC_OscInitStruct->LSEState = RCC_LSE_ON;
00004a  6082              STR      r2,[r0,#8]
00004c  e000              B        |L8.80|
                  |L8.78|
;;;1210     }
;;;1211     else
;;;1212     {
;;;1213       RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
00004e  6083              STR      r3,[r0,#8]
                  |L8.80|
;;;1214     }
;;;1215     
;;;1216     /* Get the LSI configuration -----------------------------------------------*/
;;;1217     if((RCC->CSR &RCC_CSR_LSION) == RCC_CSR_LSION)
000050  6a4c              LDR      r4,[r1,#0x24]
000052  07e4              LSLS     r4,r4,#31
000054  d001              BEQ      |L8.90|
;;;1218     {
;;;1219       RCC_OscInitStruct->LSIState = RCC_LSI_ON;
000056  61c2              STR      r2,[r0,#0x1c]
000058  e000              B        |L8.92|
                  |L8.90|
;;;1220     }
;;;1221     else
;;;1222     {
;;;1223       RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
00005a  61c3              STR      r3,[r0,#0x1c]
                  |L8.92|
;;;1224     }
;;;1225     
;;;1226     /* Get the HSI14 configuration -----------------------------------------------*/
;;;1227     if((RCC->CR2 & RCC_CR2_HSI14ON) == RCC_CR2_HSI14ON)
00005c  6b4c              LDR      r4,[r1,#0x34]
00005e  07e4              LSLS     r4,r4,#31
000060  d001              BEQ      |L8.102|
;;;1228     {
;;;1229       RCC_OscInitStruct->HSI14State = RCC_HSI_ON;
000062  6142              STR      r2,[r0,#0x14]
000064  e000              B        |L8.104|
                  |L8.102|
;;;1230     }
;;;1231     else
;;;1232     {
;;;1233       RCC_OscInitStruct->HSI14State = RCC_HSI_OFF;
000066  6143              STR      r3,[r0,#0x14]
                  |L8.104|
;;;1234     }
;;;1235   
;;;1236     RCC_OscInitStruct->HSI14CalibrationValue = (uint32_t)((RCC->CR2 & RCC_CR2_HSI14TRIM) >> RCC_HSI14TRIM_BIT_NUMBER);
000068  6b4b              LDR      r3,[r1,#0x34]
00006a  061b              LSLS     r3,r3,#24
00006c  0edb              LSRS     r3,r3,#27
;;;1237     
;;;1238   #if defined(RCC_HSI48_SUPPORT)
;;;1239     /* Get the HSI48 configuration if any-----------------------------------------*/
;;;1240     RCC_OscInitStruct->HSI48State = __HAL_RCC_GET_HSI48_STATE();
;;;1241   #endif /* RCC_HSI48_SUPPORT */
;;;1242   
;;;1243     /* Get the PLL configuration -----------------------------------------------*/
;;;1244     if((RCC->CR &RCC_CR_PLLON) == RCC_CR_PLLON)
00006e  6183              STR      r3,[r0,#0x18]
000070  680b              LDR      r3,[r1,#0]
000072  01db              LSLS     r3,r3,#7
000074  d502              BPL      |L8.124|
;;;1245     {
;;;1246       RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
000076  2202              MOVS     r2,#2
000078  6202              STR      r2,[r0,#0x20]
00007a  e000              B        |L8.126|
                  |L8.124|
;;;1247     }
;;;1248     else
;;;1249     {
;;;1250       RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
00007c  6202              STR      r2,[r0,#0x20]
                  |L8.126|
;;;1251     }
;;;1252     RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLSRC);
00007e  684a              LDR      r2,[r1,#4]
000080  2301              MOVS     r3,#1
000082  041b              LSLS     r3,r3,#16
000084  401a              ANDS     r2,r2,r3
;;;1253     RCC_OscInitStruct->PLL.PLLMUL = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLMUL);
000086  6242              STR      r2,[r0,#0x24]
000088  684a              LDR      r2,[r1,#4]
00008a  230f              MOVS     r3,#0xf
00008c  049b              LSLS     r3,r3,#18
00008e  401a              ANDS     r2,r2,r3
;;;1254     RCC_OscInitStruct->PLL.PREDIV = (uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV);
000090  6282              STR      r2,[r0,#0x28]
000092  6ac9              LDR      r1,[r1,#0x2c]
000094  0709              LSLS     r1,r1,#28
000096  0f09              LSRS     r1,r1,#28
000098  62c1              STR      r1,[r0,#0x2c]
;;;1255   }
00009a  bc30              POP      {r4,r5}
00009c  4770              BX       lr
;;;1256   
                          ENDP

00009e  0000              DCW      0x0000
                  |L8.160|
                          DCD      0x40021000

                          AREA ||i.HAL_RCC_GetPCLK1Freq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetPCLK1Freq PROC
;;;1149     */
;;;1150   uint32_t HAL_RCC_GetPCLK1Freq(void)
000000  4804              LDR      r0,|L9.20|
;;;1151   {
;;;1152     /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
;;;1153     return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE) >> RCC_CFGR_PPRE_BITNUMBER]);
000002  4905              LDR      r1,|L9.24|
000004  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000006  6849              LDR      r1,[r1,#4]
000008  4a04              LDR      r2,|L9.28|
00000a  0549              LSLS     r1,r1,#21
00000c  0f49              LSRS     r1,r1,#29
00000e  5c51              LDRB     r1,[r2,r1]
000010  40c8              LSRS     r0,r0,r1
;;;1154   }    
000012  4770              BX       lr
;;;1155   
                          ENDP

                  |L9.20|
                          DCD      SystemCoreClock
                  |L9.24|
                          DCD      0x40021000
                  |L9.28|
                          DCD      APBPrescTable

                          AREA ||i.HAL_RCC_GetSysClockFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetSysClockFreq PROC
;;;1063     */
;;;1064   uint32_t HAL_RCC_GetSysClockFreq(void)
000000  b510              PUSH     {r4,lr}
;;;1065   {
;;;1066     const uint8_t aPLLMULFactorTable[16] = { 2U,  3U,  4U,  5U,  6U,  7U,  8U,  9U,
000002  a013              ADR      r0,|L10.80|
000004  c80f              LDM      r0,{r0-r3}
000006  b088              SUB      sp,sp,#0x20           ;1065
000008  466c              MOV      r4,sp
00000a  c40f              STM      r4!,{r0-r3}
;;;1067                                            10U, 11U, 12U, 13U, 14U, 15U, 16U, 16U};
;;;1068     const uint8_t aPredivFactorTable[16] = { 1U, 2U,  3U,  4U,  5U,  6U,  7U,  8U,
00000c  a314              ADR      r3,|L10.96|
00000e  cb0f              LDM      r3,{r0-r3}
000010  c40f              STM      r4!,{r0-r3}
;;;1069                                              9U,10U, 11U, 12U, 13U, 14U, 15U, 16U};
;;;1070   
;;;1071     uint32_t tmpreg = 0U, prediv = 0U, pllclk = 0U, pllmul = 0U;
;;;1072     uint32_t sysclockfreq = 0U;
;;;1073     
;;;1074     tmpreg = RCC->CFGR;
000012  4917              LDR      r1,|L10.112|
000014  684a              LDR      r2,[r1,#4]
;;;1075     
;;;1076     /* Get SYSCLK source -------------------------------------------------------*/
;;;1077     switch (tmpreg & RCC_CFGR_SWS)
000016  200c              MOVS     r0,#0xc
000018  4613              MOV      r3,r2
00001a  4003              ANDS     r3,r3,r0
;;;1078     {
;;;1079       case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock */
;;;1080       {
;;;1081         sysclockfreq = HSE_VALUE;
00001c  4815              LDR      r0,|L10.116|
00001e  2b04              CMP      r3,#4                 ;1077
000020  d00f              BEQ      |L10.66|
000022  2b08              CMP      r3,#8                 ;1077
000024  d10d              BNE      |L10.66|
;;;1082         break;
;;;1083       }
;;;1084       case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
;;;1085       {
;;;1086         pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_BITNUMBER];
000026  0293              LSLS     r3,r2,#10
000028  0f1c              LSRS     r4,r3,#28
00002a  466b              MOV      r3,sp
00002c  5d1c              LDRB     r4,[r3,r4]
;;;1087         prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV) >> RCC_CFGR2_PREDIV_BITNUMBER];
00002e  6ac9              LDR      r1,[r1,#0x2c]
000030  ab04              ADD      r3,sp,#0x10
000032  0709              LSLS     r1,r1,#28
000034  0f09              LSRS     r1,r1,#28
000036  5c59              LDRB     r1,[r3,r1]
;;;1088         if ((tmpreg & RCC_CFGR_PLLSRC) == RCC_PLLSOURCE_HSE)
000038  03d2              LSLS     r2,r2,#15
00003a  d504              BPL      |L10.70|
;;;1089         {
;;;1090           /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV * PLLMUL */
;;;1091           pllclk = (HSE_VALUE / prediv) * pllmul;
00003c  f7fffffe          BL       __aeabi_uidivmod
000040  4360              MULS     r0,r4,r0
                  |L10.66|
;;;1092         }
;;;1093   #if defined(RCC_CFGR_PLLSRC_HSI48_PREDIV)
;;;1094         else if ((tmpreg & RCC_CFGR_PLLSRC) == RCC_PLLSOURCE_HSI48)
;;;1095         {
;;;1096           /* HSI48 used as PLL clock source : PLLCLK = HSI48/PREDIV * PLLMUL */
;;;1097           pllclk = (HSI48_VALUE / prediv) * pllmul;
;;;1098         }
;;;1099   #endif /* RCC_CFGR_PLLSRC_HSI48_PREDIV */
;;;1100         else
;;;1101         {
;;;1102   #if  (defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F070x6) || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB) || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F030xC))
;;;1103           /* HSI used as PLL clock source : PLLCLK = HSI/PREDIV * PLLMUL */
;;;1104           pllclk = (HSI_VALUE / prediv) * pllmul;
;;;1105   #else
;;;1106           /* HSI used as PLL clock source : PLLCLK = HSI/2 * PLLMUL */
;;;1107           pllclk = (uint32_t)((HSI_VALUE >> 1U) * pllmul);
;;;1108   #endif
;;;1109         }
;;;1110         sysclockfreq = pllclk;
;;;1111         break;
;;;1112       }
;;;1113   #if defined(RCC_CFGR_SWS_HSI48)
;;;1114       case RCC_SYSCLKSOURCE_STATUS_HSI48:    /* HSI48 used as system clock source */
;;;1115       {
;;;1116         sysclockfreq = HSI48_VALUE;
;;;1117         break;
;;;1118       }
;;;1119   #endif /* RCC_CFGR_SWS_HSI48 */
;;;1120       case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
;;;1121       default: /* HSI used as system clock */
;;;1122       {
;;;1123         sysclockfreq = HSI_VALUE;
;;;1124         break;
;;;1125       }
;;;1126     }
;;;1127     return sysclockfreq;
;;;1128   }
000042  b008              ADD      sp,sp,#0x20
000044  bd10              POP      {r4,pc}
                  |L10.70|
000046  480c              LDR      r0,|L10.120|
000048  b008              ADD      sp,sp,#0x20
00004a  4360              MULS     r0,r4,r0              ;1107
00004c  bd10              POP      {r4,pc}
;;;1129   
                          ENDP

00004e  0000              DCW      0x0000
                  |L10.80|
000050  02030405          DCB      2,3,4,5,6,"\a\b\t\n\v\f\r",14,15,16,16
000054  06070809
000058  0a0b0c0d
00005c  0e0f1010
                  |L10.96|
000060  01020304          DCB      1,2,3,4,5,6,"\a\b\t\n\v\f\r",14,15,16
000064  05060708
000068  090a0b0c
00006c  0d0e0f10
                  |L10.112|
                          DCD      0x40021000
                  |L10.116|
                          DCD      0x007a1200
                  |L10.120|
                          DCD      0x003d0900

                          AREA ||i.HAL_RCC_MCOConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_MCOConfig PROC
;;;984    #endif
;;;985    void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
000000  b570              PUSH     {r4-r6,lr}
;;;986    {
000002  b086              SUB      sp,sp,#0x18
;;;987      GPIO_InitTypeDef gpio;
;;;988    
;;;989      /* Check the parameters */
;;;990      assert_param(IS_RCC_MCO(RCC_MCOx));
;;;991      assert_param(IS_RCC_MCODIV(RCC_MCODiv));
;;;992      assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));
;;;993      
;;;994      /* Configure the MCO1 pin in alternate function mode */
;;;995      gpio.Mode      = GPIO_MODE_AF_PP;
000004  2002              MOVS     r0,#2
;;;996      gpio.Speed     = GPIO_SPEED_FREQ_HIGH;
000006  9001              STR      r0,[sp,#4]
000008  2003              MOVS     r0,#3
;;;997      gpio.Pull      = GPIO_NOPULL;
00000a  9003              STR      r0,[sp,#0xc]
00000c  2000              MOVS     r0,#0
00000e  460d              MOV      r5,r1                 ;986
;;;998      gpio.Pin       = MCO1_PIN;
000010  21ff              MOVS     r1,#0xff
000012  3101              ADDS     r1,#1
;;;999      gpio.Alternate = GPIO_AF0_MCO;
;;;1000   
;;;1001     /* MCO1 Clock Enable */
;;;1002     MCO1_CLK_ENABLE();
000014  4c0d              LDR      r4,|L11.76|
000016  9002              STR      r0,[sp,#8]            ;999
000018  9100              STR      r1,[sp,#0]
00001a  9004              STR      r0,[sp,#0x10]
00001c  6961              LDR      r1,[r4,#0x14]
00001e  4616              MOV      r6,r2                 ;986
000020  2001              MOVS     r0,#1
000022  0440              LSLS     r0,r0,#17
000024  4301              ORRS     r1,r1,r0
000026  6161              STR      r1,[r4,#0x14]
000028  6961              LDR      r1,[r4,#0x14]
00002a  4001              ANDS     r1,r1,r0
;;;1003     
;;;1004     HAL_GPIO_Init(MCO1_GPIO_PORT, &gpio);
00002c  9105              STR      r1,[sp,#0x14]
00002e  2009              MOVS     r0,#9
000030  4669              MOV      r1,sp
000032  06c0              LSLS     r0,r0,#27
000034  f7fffffe          BL       HAL_GPIO_Init
;;;1005     
;;;1006     /* Configure the MCO clock source */
;;;1007     __HAL_RCC_MCO1_CONFIG(RCC_MCOSource, RCC_MCODiv);
000038  6860              LDR      r0,[r4,#4]
00003a  217f              MOVS     r1,#0x7f
00003c  0609              LSLS     r1,r1,#24
00003e  4388              BICS     r0,r0,r1
000040  4335              ORRS     r5,r5,r6
000042  4328              ORRS     r0,r0,r5
000044  6060              STR      r0,[r4,#4]
;;;1008   }
000046  b006              ADD      sp,sp,#0x18
000048  bd70              POP      {r4-r6,pc}
;;;1009   
                          ENDP

00004a  0000              DCW      0x0000
                  |L11.76|
                          DCD      0x40021000

                          AREA ||i.HAL_RCC_NMI_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_RCC_NMI_IRQHandler PROC
;;;1290     */
;;;1291   void HAL_RCC_NMI_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1292   {
;;;1293     /* Check RCC CSSF flag  */
;;;1294     if(__HAL_RCC_GET_IT(RCC_IT_CSS))
000002  4c04              LDR      r4,|L12.20|
000004  68a0              LDR      r0,[r4,#8]
000006  0600              LSLS     r0,r0,#24
000008  d503              BPL      |L12.18|
;;;1295     {
;;;1296       /* RCC Clock Security System interrupt user callback */
;;;1297       HAL_RCC_CSSCallback();
00000a  f7fffffe          BL       HAL_RCC_CSSCallback
;;;1298       
;;;1299       /* Clear RCC CSS pending bit */
;;;1300       __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
00000e  2080              MOVS     r0,#0x80
000010  72a0              STRB     r0,[r4,#0xa]
                  |L12.18|
;;;1301     }
;;;1302   }
000012  bd10              POP      {r4,pc}
;;;1303   
                          ENDP

                  |L12.20|
                          DCD      0x40021000

                          AREA ||i.HAL_RCC_OscConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_OscConfig PROC
;;;268      */
;;;269    HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
000000  b5f8              PUSH     {r3-r7,lr}
;;;270    {
000002  4604              MOV      r4,r0
;;;271       uint32_t tickstart = 0U;
;;;272      
;;;273      /* Check the parameters */
;;;274      assert_param(RCC_OscInitStruct != NULL);
;;;275      assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
;;;276    
;;;277      /*------------------------------- HSE Configuration ------------------------*/ 
;;;278      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
000004  7800              LDRB     r0,[r0,#0]
;;;279      {
;;;280        /* Check the parameters */
;;;281        assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
;;;282    
;;;283        /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
;;;284        if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
000006  4de2              LDR      r5,|L13.912|
000008  07c0              LSLS     r0,r0,#31             ;278
00000a  d04b              BEQ      |L13.164|
00000c  6868              LDR      r0,[r5,#4]
00000e  0700              LSLS     r0,r0,#28
000010  0f80              LSRS     r0,r0,#30
000012  2801              CMP      r0,#1
000014  d007              BEQ      |L13.38|
000016  6868              LDR      r0,[r5,#4]
000018  0700              LSLS     r0,r0,#28
00001a  0f80              LSRS     r0,r0,#30
00001c  2802              CMP      r0,#2
00001e  d109              BNE      |L13.52|
000020  6868              LDR      r0,[r5,#4]
000022  03c0              LSLS     r0,r0,#15
000024  d506              BPL      |L13.52|
                  |L13.38|
;;;285           || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
;;;286        {
;;;287          if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
000026  6828              LDR      r0,[r5,#0]
000028  0380              LSLS     r0,r0,#14
00002a  d53b              BPL      |L13.164|
00002c  6860              LDR      r0,[r4,#4]
00002e  2800              CMP      r0,#0
000030  d07e              BEQ      |L13.304|
000032  e037              B        |L13.164|
                  |L13.52|
;;;288          {
;;;289            return HAL_ERROR;
;;;290          }
;;;291        }
;;;292        else
;;;293        {
;;;294          /* Set the new HSE configuration ---------------------------------------*/
;;;295          __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
000034  2001              MOVS     r0,#1
000036  6862              LDR      r2,[r4,#4]
000038  0400              LSLS     r0,r0,#16
00003a  2a01              CMP      r2,#1
00003c  d01c              BEQ      |L13.120|
00003e  0081              LSLS     r1,r0,#2
000040  2a00              CMP      r2,#0
000042  d001              BEQ      |L13.72|
000044  2a05              CMP      r2,#5
000046  d01b              BEQ      |L13.128|
                  |L13.72|
000048  682a              LDR      r2,[r5,#0]
00004a  4382              BICS     r2,r2,r0
00004c  602a              STR      r2,[r5,#0]
00004e  6828              LDR      r0,[r5,#0]
000050  4388              BICS     r0,r0,r1
000052  6028              STR      r0,[r5,#0]
                  |L13.84|
;;;296          
;;;297    
;;;298           /* Check the HSE State */
;;;299          if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
000054  6860              LDR      r0,[r4,#4]
000056  2800              CMP      r0,#0
000058  d016              BEQ      |L13.136|
;;;300          {
;;;301            /* Get Start Tick */
;;;302            tickstart = HAL_GetTick();
00005a  f7fffffe          BL       HAL_GetTick
00005e  4606              MOV      r6,r0
;;;303            
;;;304            /* Wait till HSE is ready */
;;;305            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
000060  6828              LDR      r0,[r5,#0]
000062  0380              LSLS     r0,r0,#14
000064  d41e              BMI      |L13.164|
                  |L13.102|
;;;306            {
;;;307              if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
000066  f7fffffe          BL       HAL_GetTick
00006a  1b80              SUBS     r0,r0,r6
00006c  2864              CMP      r0,#0x64
00006e  d878              BHI      |L13.354|
;;;308              {
;;;309                return HAL_TIMEOUT;
000070  6828              LDR      r0,[r5,#0]
000072  0380              LSLS     r0,r0,#14
000074  d5f7              BPL      |L13.102|
000076  e015              B        |L13.164|
                  |L13.120|
000078  6829              LDR      r1,[r5,#0]            ;295
00007a  4301              ORRS     r1,r1,r0              ;295
00007c  6029              STR      r1,[r5,#0]            ;295
00007e  e7e9              B        |L13.84|
                  |L13.128|
000080  682a              LDR      r2,[r5,#0]            ;295
000082  430a              ORRS     r2,r2,r1              ;295
000084  602a              STR      r2,[r5,#0]            ;295
000086  e7f7              B        |L13.120|
                  |L13.136|
;;;310              }
;;;311            }
;;;312          }
;;;313          else
;;;314          {
;;;315            /* Get Start Tick */
;;;316            tickstart = HAL_GetTick();
000088  f7fffffe          BL       HAL_GetTick
00008c  4606              MOV      r6,r0
;;;317            
;;;318            /* Wait till HSE is disabled */
;;;319            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
00008e  6828              LDR      r0,[r5,#0]
000090  0380              LSLS     r0,r0,#14
000092  d507              BPL      |L13.164|
                  |L13.148|
;;;320            {
;;;321               if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
000094  f7fffffe          BL       HAL_GetTick
000098  1b80              SUBS     r0,r0,r6
00009a  2864              CMP      r0,#0x64
00009c  d861              BHI      |L13.354|
;;;322              {
;;;323                return HAL_TIMEOUT;
00009e  6828              LDR      r0,[r5,#0]
0000a0  0380              LSLS     r0,r0,#14
0000a2  d4f7              BMI      |L13.148|
                  |L13.164|
;;;324              }
;;;325            }
;;;326          }
;;;327        }
;;;328      }
;;;329      /*----------------------------- HSI Configuration --------------------------*/ 
;;;330      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
0000a4  7820              LDRB     r0,[r4,#0]
0000a6  0780              LSLS     r0,r0,#30
0000a8  d540              BPL      |L13.300|
;;;331      {
;;;332        /* Check the parameters */
;;;333        assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
;;;334        assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
;;;335        
;;;336        /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
;;;337        if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
0000aa  6868              LDR      r0,[r5,#4]
0000ac  0700              LSLS     r0,r0,#28
0000ae  0f80              LSRS     r0,r0,#30
0000b0  d007              BEQ      |L13.194|
0000b2  6868              LDR      r0,[r5,#4]
0000b4  0700              LSLS     r0,r0,#28
0000b6  0f80              LSRS     r0,r0,#30
0000b8  2802              CMP      r0,#2
0000ba  d109              BNE      |L13.208|
0000bc  6868              LDR      r0,[r5,#4]
0000be  03c0              LSLS     r0,r0,#15
0000c0  d406              BMI      |L13.208|
                  |L13.194|
;;;338           || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
;;;339        {
;;;340          /* When HSI is used as system clock it will not disabled */
;;;341          if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
0000c2  6828              LDR      r0,[r5,#0]
0000c4  0780              LSLS     r0,r0,#30
0000c6  d518              BPL      |L13.250|
0000c8  68e0              LDR      r0,[r4,#0xc]
0000ca  2801              CMP      r0,#1
0000cc  d130              BNE      |L13.304|
0000ce  e014              B        |L13.250|
                  |L13.208|
;;;342          {
;;;343            return HAL_ERROR;
;;;344          }
;;;345          /* Otherwise, just the calibration is allowed */
;;;346          else
;;;347          {
;;;348            /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
;;;349            __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
;;;350          }
;;;351        }
;;;352        else
;;;353        {
;;;354          /* Check the HSI State */
;;;355          if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
0000d0  68e0              LDR      r0,[r4,#0xc]
0000d2  2800              CMP      r0,#0
;;;356          {
;;;357           /* Enable the Internal High Speed oscillator (HSI). */
;;;358            __HAL_RCC_HSI_ENABLE();
;;;359            
;;;360            /* Get Start Tick */
;;;361            tickstart = HAL_GetTick();
;;;362            
;;;363            /* Wait till HSI is ready */
;;;364            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
;;;365            {
;;;366              if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
;;;367              {
;;;368                return HAL_TIMEOUT;
;;;369              }
;;;370            }
;;;371                    
;;;372            /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
;;;373            __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
;;;374          }
;;;375          else
;;;376          {
;;;377            /* Disable the Internal High Speed oscillator (HSI). */
;;;378            __HAL_RCC_HSI_DISABLE();
0000d4  6828              LDR      r0,[r5,#0]
0000d6  d018              BEQ      |L13.266|
0000d8  2101              MOVS     r1,#1                 ;358
0000da  4308              ORRS     r0,r0,r1              ;358
0000dc  6028              STR      r0,[r5,#0]            ;358
0000de  f7fffffe          BL       HAL_GetTick
0000e2  4606              MOV      r6,r0                 ;361
0000e4  6828              LDR      r0,[r5,#0]            ;364
0000e6  0780              LSLS     r0,r0,#30             ;364
0000e8  d407              BMI      |L13.250|
                  |L13.234|
0000ea  f7fffffe          BL       HAL_GetTick
0000ee  1b80              SUBS     r0,r0,r6              ;366
0000f0  2802              CMP      r0,#2                 ;366
0000f2  d836              BHI      |L13.354|
0000f4  6828              LDR      r0,[r5,#0]            ;368
0000f6  0780              LSLS     r0,r0,#30             ;368
0000f8  d5f7              BPL      |L13.234|
                  |L13.250|
0000fa  6828              LDR      r0,[r5,#0]            ;373
0000fc  21f8              MOVS     r1,#0xf8              ;373
0000fe  4388              BICS     r0,r0,r1              ;373
000100  6921              LDR      r1,[r4,#0x10]         ;373
000102  00c9              LSLS     r1,r1,#3              ;373
000104  4308              ORRS     r0,r0,r1              ;373
000106  6028              STR      r0,[r5,#0]            ;373
000108  e010              B        |L13.300|
                  |L13.266|
00010a  0840              LSRS     r0,r0,#1
00010c  0040              LSLS     r0,r0,#1
00010e  6028              STR      r0,[r5,#0]
;;;379            
;;;380            /* Get Start Tick */
;;;381            tickstart = HAL_GetTick();
000110  f7fffffe          BL       HAL_GetTick
000114  4606              MOV      r6,r0
;;;382            
;;;383            /* Wait till HSI is disabled */
;;;384            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
000116  6828              LDR      r0,[r5,#0]
000118  0780              LSLS     r0,r0,#30
00011a  d507              BPL      |L13.300|
                  |L13.284|
;;;385            {
;;;386              if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
00011c  f7fffffe          BL       HAL_GetTick
000120  1b80              SUBS     r0,r0,r6
000122  2802              CMP      r0,#2
000124  d81d              BHI      |L13.354|
;;;387              {
;;;388                return HAL_TIMEOUT;
000126  6828              LDR      r0,[r5,#0]
000128  0780              LSLS     r0,r0,#30
00012a  d4f7              BMI      |L13.284|
                  |L13.300|
;;;389              }
;;;390            }
;;;391          }
;;;392        }
;;;393      }
;;;394      /*------------------------------ LSI Configuration -------------------------*/ 
;;;395      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
00012c  7820              LDRB     r0,[r4,#0]
00012e  e000              B        |L13.306|
                  |L13.304|
000130  e12b              B        |L13.906|
                  |L13.306|
000132  0700              LSLS     r0,r0,#28
000134  d528              BPL      |L13.392|
;;;396      {
;;;397        /* Check the parameters */
;;;398        assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
;;;399        
;;;400        /* Check the LSI State */
;;;401        if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
000136  69e0              LDR      r0,[r4,#0x1c]
000138  2800              CMP      r0,#0
00013a  d013              BEQ      |L13.356|
;;;402        {
;;;403          /* Enable the Internal Low Speed oscillator (LSI). */
;;;404          __HAL_RCC_LSI_ENABLE();
00013c  6a69              LDR      r1,[r5,#0x24]
00013e  2001              MOVS     r0,#1
000140  4301              ORRS     r1,r1,r0
000142  6269              STR      r1,[r5,#0x24]
;;;405          
;;;406          /* Get Start Tick */
;;;407          tickstart = HAL_GetTick();
000144  f7fffffe          BL       HAL_GetTick
000148  4606              MOV      r6,r0
;;;408          
;;;409          /* Wait till LSI is ready */  
;;;410          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
00014a  6a68              LDR      r0,[r5,#0x24]
00014c  0780              LSLS     r0,r0,#30
00014e  d41b              BMI      |L13.392|
                  |L13.336|
;;;411          {
;;;412            if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
000150  f7fffffe          BL       HAL_GetTick
000154  1b80              SUBS     r0,r0,r6
000156  2802              CMP      r0,#2
000158  d803              BHI      |L13.354|
;;;413            {
;;;414              return HAL_TIMEOUT;
00015a  6a68              LDR      r0,[r5,#0x24]
00015c  0780              LSLS     r0,r0,#30
00015e  d5f7              BPL      |L13.336|
000160  e012              B        |L13.392|
                  |L13.354|
000162  e08d              B        |L13.640|
                  |L13.356|
;;;415            }
;;;416          }
;;;417        }
;;;418        else
;;;419        {
;;;420          /* Disable the Internal Low Speed oscillator (LSI). */
;;;421          __HAL_RCC_LSI_DISABLE();
000164  6a68              LDR      r0,[r5,#0x24]
000166  0840              LSRS     r0,r0,#1
000168  0040              LSLS     r0,r0,#1
00016a  6268              STR      r0,[r5,#0x24]
;;;422          
;;;423          /* Get Start Tick */
;;;424          tickstart = HAL_GetTick();
00016c  f7fffffe          BL       HAL_GetTick
000170  4606              MOV      r6,r0
;;;425          
;;;426          /* Wait till LSI is disabled */  
;;;427          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
000172  6a68              LDR      r0,[r5,#0x24]
000174  0780              LSLS     r0,r0,#30
000176  d507              BPL      |L13.392|
                  |L13.376|
;;;428          {
;;;429            if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
000178  f7fffffe          BL       HAL_GetTick
00017c  1b80              SUBS     r0,r0,r6
00017e  2802              CMP      r0,#2
000180  d87e              BHI      |L13.640|
;;;430            {
;;;431              return HAL_TIMEOUT;
000182  6a68              LDR      r0,[r5,#0x24]
000184  0780              LSLS     r0,r0,#30
000186  d4f7              BMI      |L13.376|
                  |L13.392|
;;;432            }
;;;433          }
;;;434        }
;;;435      }
;;;436      /*------------------------------ LSE Configuration -------------------------*/ 
;;;437      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
000188  7820              LDRB     r0,[r4,#0]
00018a  0740              LSLS     r0,r0,#29
00018c  d568              BPL      |L13.608|
;;;438      {
;;;439        FlagStatus       pwrclkchanged = RESET;
00018e  2000              MOVS     r0,#0
;;;440        
;;;441        /* Check the parameters */
;;;442        assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
;;;443    
;;;444        /* Update LSE configuration in Backup Domain control register    */
;;;445        /* Requires to enable write access to Backup Domain of necessary */
;;;446        if(__HAL_RCC_PWR_IS_CLK_DISABLED())
000190  9000              STR      r0,[sp,#0]
000192  69e8              LDR      r0,[r5,#0x1c]
000194  00c0              LSLS     r0,r0,#3
000196  d408              BMI      |L13.426|
;;;447        {
;;;448          __HAL_RCC_PWR_CLK_ENABLE();
000198  69e8              LDR      r0,[r5,#0x1c]
00019a  2101              MOVS     r1,#1
00019c  0709              LSLS     r1,r1,#28
00019e  4308              ORRS     r0,r0,r1
0001a0  61e8              STR      r0,[r5,#0x1c]
0001a2  69e8              LDR      r0,[r5,#0x1c]
0001a4  4008              ANDS     r0,r0,r1
;;;449          pwrclkchanged = SET;
0001a6  2001              MOVS     r0,#1
0001a8  9000              STR      r0,[sp,#0]
                  |L13.426|
;;;450        }
;;;451        
;;;452        if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
0001aa  4f7a              LDR      r7,|L13.916|
0001ac  6838              LDR      r0,[r7,#0]
0001ae  05c0              LSLS     r0,r0,#23
0001b0  d411              BMI      |L13.470|
;;;453        {
;;;454          /* Enable write access to Backup domain */
;;;455          SET_BIT(PWR->CR, PWR_CR_DBP);
0001b2  6838              LDR      r0,[r7,#0]
0001b4  15b9              ASRS     r1,r7,#22
0001b6  4308              ORRS     r0,r0,r1
0001b8  6038              STR      r0,[r7,#0]
;;;456          
;;;457          /* Wait for Backup domain Write protection disable */
;;;458          tickstart = HAL_GetTick();
0001ba  f7fffffe          BL       HAL_GetTick
0001be  4606              MOV      r6,r0
;;;459    
;;;460          while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
0001c0  6838              LDR      r0,[r7,#0]
0001c2  05c0              LSLS     r0,r0,#23
0001c4  d407              BMI      |L13.470|
                  |L13.454|
;;;461          {
;;;462            if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
0001c6  f7fffffe          BL       HAL_GetTick
0001ca  1b80              SUBS     r0,r0,r6
0001cc  2864              CMP      r0,#0x64
0001ce  d857              BHI      |L13.640|
;;;463            {
;;;464              return HAL_TIMEOUT;
0001d0  6838              LDR      r0,[r7,#0]
0001d2  05c0              LSLS     r0,r0,#23
0001d4  d5f7              BPL      |L13.454|
                  |L13.470|
;;;465            }
;;;466          }
;;;467        }
;;;468    
;;;469        /* Set the new LSE configuration -----------------------------------------*/
;;;470        __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
0001d6  68a0              LDR      r0,[r4,#8]
0001d8  2801              CMP      r0,#1
0001da  d01e              BEQ      |L13.538|
0001dc  2800              CMP      r0,#0
0001de  d001              BEQ      |L13.484|
0001e0  2805              CMP      r0,#5
0001e2  d01e              BEQ      |L13.546|
                  |L13.484|
0001e4  6a28              LDR      r0,[r5,#0x20]
0001e6  0840              LSRS     r0,r0,#1
0001e8  0040              LSLS     r0,r0,#1
0001ea  6228              STR      r0,[r5,#0x20]
0001ec  6a29              LDR      r1,[r5,#0x20]
0001ee  2004              MOVS     r0,#4
0001f0  4381              BICS     r1,r1,r0
                  |L13.498|
0001f2  6229              STR      r1,[r5,#0x20]
                  |L13.500|
;;;471        /* Check the LSE State */
;;;472        if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
0001f4  68a0              LDR      r0,[r4,#8]
;;;473        {
;;;474          /* Get Start Tick */
;;;475          tickstart = HAL_GetTick();
;;;476          
;;;477          /* Wait till LSE is ready */  
;;;478          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
;;;479          {
;;;480            if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
0001f6  4e68              LDR      r6,|L13.920|
0001f8  2800              CMP      r0,#0                 ;472
0001fa  d01b              BEQ      |L13.564|
0001fc  f7fffffe          BL       HAL_GetTick
000200  4607              MOV      r7,r0                 ;475
000202  6a28              LDR      r0,[r5,#0x20]         ;478
000204  0780              LSLS     r0,r0,#30             ;478
000206  d423              BMI      |L13.592|
                  |L13.520|
000208  f7fffffe          BL       HAL_GetTick
00020c  1bc0              SUBS     r0,r0,r7
00020e  42b0              CMP      r0,r6
000210  d860              BHI      |L13.724|
;;;481            {
;;;482              return HAL_TIMEOUT;
000212  6a28              LDR      r0,[r5,#0x20]
000214  0780              LSLS     r0,r0,#30
000216  d5f7              BPL      |L13.520|
000218  e01a              B        |L13.592|
                  |L13.538|
00021a  6a29              LDR      r1,[r5,#0x20]         ;470
00021c  2001              MOVS     r0,#1                 ;470
00021e  4301              ORRS     r1,r1,r0              ;470
000220  e7e7              B        |L13.498|
                  |L13.546|
000222  6a28              LDR      r0,[r5,#0x20]         ;470
000224  2104              MOVS     r1,#4                 ;470
000226  4308              ORRS     r0,r0,r1              ;470
000228  6228              STR      r0,[r5,#0x20]         ;470
00022a  6a28              LDR      r0,[r5,#0x20]         ;470
00022c  2101              MOVS     r1,#1                 ;470
00022e  4308              ORRS     r0,r0,r1              ;470
000230  6228              STR      r0,[r5,#0x20]         ;470
000232  e7df              B        |L13.500|
                  |L13.564|
;;;483            }
;;;484          }
;;;485        }
;;;486        else
;;;487        {
;;;488          /* Get Start Tick */
;;;489          tickstart = HAL_GetTick();
000234  f7fffffe          BL       HAL_GetTick
000238  4607              MOV      r7,r0
;;;490          
;;;491          /* Wait till LSE is disabled */  
;;;492          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
00023a  6a28              LDR      r0,[r5,#0x20]
00023c  0780              LSLS     r0,r0,#30
00023e  d507              BPL      |L13.592|
                  |L13.576|
;;;493          {
;;;494            if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
000240  f7fffffe          BL       HAL_GetTick
000244  1bc0              SUBS     r0,r0,r7
000246  42b0              CMP      r0,r6
000248  d844              BHI      |L13.724|
;;;495            {
;;;496              return HAL_TIMEOUT;
00024a  6a28              LDR      r0,[r5,#0x20]
00024c  0780              LSLS     r0,r0,#30
00024e  d4f7              BMI      |L13.576|
                  |L13.592|
;;;497            }
;;;498          }
;;;499        }
;;;500    
;;;501        /* Require to disable power clock if necessary */
;;;502        if(pwrclkchanged == SET)
000250  9800              LDR      r0,[sp,#0]
000252  2800              CMP      r0,#0
000254  d004              BEQ      |L13.608|
;;;503        {
;;;504          __HAL_RCC_PWR_CLK_DISABLE();
000256  69e9              LDR      r1,[r5,#0x1c]
000258  2001              MOVS     r0,#1
00025a  0700              LSLS     r0,r0,#28
00025c  4381              BICS     r1,r1,r0
00025e  61e9              STR      r1,[r5,#0x1c]
                  |L13.608|
;;;505        }
;;;506      }
;;;507    
;;;508      /*----------------------------- HSI14 Configuration --------------------------*/
;;;509      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI14) == RCC_OSCILLATORTYPE_HSI14)
000260  7820              LDRB     r0,[r4,#0]
000262  06c0              LSLS     r0,r0,#27
000264  d51c              BPL      |L13.672|
;;;510      {
;;;511        /* Check the parameters */
;;;512        assert_param(IS_RCC_HSI14(RCC_OscInitStruct->HSI14State));
;;;513        assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSI14CalibrationValue));
;;;514    
;;;515        /* Check the HSI14 State */
;;;516        if(RCC_OscInitStruct->HSI14State == RCC_HSI14_ON)
000266  6960              LDR      r0,[r4,#0x14]
000268  2801              CMP      r0,#1
00026a  d035              BEQ      |L13.728|
00026c  1d40              ADDS     r0,r0,#5
;;;517        {
;;;518          /* Disable ADC control of the Internal High Speed oscillator HSI14 */
;;;519          __HAL_RCC_HSI14ADC_DISABLE();
;;;520    
;;;521          /* Enable the Internal High Speed oscillator (HSI). */
;;;522          __HAL_RCC_HSI14_ENABLE();
;;;523    
;;;524          /* Get Start Tick */
;;;525          tickstart = HAL_GetTick();
;;;526          
;;;527          /* Wait till HSI is ready */  
;;;528          while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) == RESET)
;;;529          {
;;;530            if((HAL_GetTick() - tickstart) > HSI14_TIMEOUT_VALUE)
;;;531            {
;;;532              return HAL_TIMEOUT;
;;;533            }      
;;;534          } 
;;;535    
;;;536          /* Adjusts the Internal High Speed oscillator 14Mhz (HSI14) calibration value. */
;;;537          __HAL_RCC_HSI14_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSI14CalibrationValue);
;;;538        }
;;;539        else if(RCC_OscInitStruct->HSI14State == RCC_HSI14_ADC_CONTROL)
00026e  d051              BEQ      |L13.788|
;;;540        {
;;;541          /* Enable ADC control of the Internal High Speed oscillator HSI14 */
;;;542          __HAL_RCC_HSI14ADC_ENABLE();
;;;543    
;;;544          /* Adjusts the Internal High Speed oscillator 14Mhz (HSI14) calibration value. */
;;;545          __HAL_RCC_HSI14_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSI14CalibrationValue);
;;;546        }
;;;547        else
;;;548        {
;;;549          /* Disable ADC control of the Internal High Speed oscillator HSI14 */
;;;550          __HAL_RCC_HSI14ADC_DISABLE();
000270  6b68              LDR      r0,[r5,#0x34]
000272  2104              MOVS     r1,#4
000274  4308              ORRS     r0,r0,r1
000276  6368              STR      r0,[r5,#0x34]
;;;551    
;;;552          /* Disable the Internal High Speed oscillator (HSI). */
;;;553          __HAL_RCC_HSI14_DISABLE();
000278  6b68              LDR      r0,[r5,#0x34]
00027a  0840              LSRS     r0,r0,#1
00027c  0040              LSLS     r0,r0,#1
00027e  e000              B        |L13.642|
                  |L13.640|
000280  e028              B        |L13.724|
                  |L13.642|
000282  6368              STR      r0,[r5,#0x34]
;;;554    
;;;555          /* Get Start Tick */
;;;556          tickstart = HAL_GetTick();
000284  f7fffffe          BL       HAL_GetTick
000288  4606              MOV      r6,r0
;;;557          
;;;558          /* Wait till HSI is ready */  
;;;559          while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) != RESET)
00028a  6b68              LDR      r0,[r5,#0x34]
00028c  0780              LSLS     r0,r0,#30
00028e  d507              BPL      |L13.672|
                  |L13.656|
;;;560          {
;;;561            if((HAL_GetTick() - tickstart) > HSI14_TIMEOUT_VALUE)
000290  f7fffffe          BL       HAL_GetTick
000294  1b80              SUBS     r0,r0,r6
000296  2802              CMP      r0,#2
000298  d81c              BHI      |L13.724|
;;;562            {
;;;563              return HAL_TIMEOUT;
00029a  6b68              LDR      r0,[r5,#0x34]
00029c  0780              LSLS     r0,r0,#30
00029e  d4f7              BMI      |L13.656|
                  |L13.672|
;;;564            }
;;;565          }
;;;566        }
;;;567      }
;;;568    
;;;569    #if defined(RCC_HSI48_SUPPORT)
;;;570      /*----------------------------- HSI48 Configuration --------------------------*/
;;;571      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
;;;572      {
;;;573        /* Check the parameters */
;;;574        assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));
;;;575    
;;;576        /* When the HSI48 is used as system clock it is not allowed to be disabled */
;;;577        if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI48) ||
;;;578           ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI48)))
;;;579        {
;;;580          if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != RESET) && (RCC_OscInitStruct->HSI48State != RCC_HSI48_ON))
;;;581          {
;;;582            return HAL_ERROR;
;;;583          }
;;;584        }
;;;585        else
;;;586        {
;;;587          /* Check the HSI48 State */
;;;588          if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
;;;589          {
;;;590            /* Enable the Internal High Speed oscillator (HSI48). */
;;;591            __HAL_RCC_HSI48_ENABLE();
;;;592    
;;;593            /* Get Start Tick */
;;;594            tickstart = HAL_GetTick();
;;;595          
;;;596            /* Wait till HSI48 is ready */  
;;;597            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == RESET)
;;;598            {
;;;599              if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
;;;600              {
;;;601                return HAL_TIMEOUT;
;;;602              }
;;;603            } 
;;;604          }
;;;605          else
;;;606          {
;;;607            /* Disable the Internal High Speed oscillator (HSI48). */
;;;608            __HAL_RCC_HSI48_DISABLE();
;;;609    
;;;610            /* Get Start Tick */
;;;611            tickstart = HAL_GetTick();
;;;612          
;;;613            /* Wait till HSI48 is ready */  
;;;614            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != RESET)
;;;615            {
;;;616              if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
;;;617              {
;;;618                return HAL_TIMEOUT;
;;;619              }
;;;620            }
;;;621          }
;;;622        }
;;;623      }
;;;624    #endif /* RCC_HSI48_SUPPORT */
;;;625           
;;;626      /*-------------------------------- PLL Configuration -----------------------*/
;;;627      /* Check the parameters */
;;;628      assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
;;;629      if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
0002a0  6a20              LDR      r0,[r4,#0x20]
0002a2  2800              CMP      r0,#0
0002a4  d06f              BEQ      |L13.902|
;;;630      {
;;;631        /* Check if the PLL is used as system clock or not */
;;;632        if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
0002a6  6869              LDR      r1,[r5,#4]
0002a8  0709              LSLS     r1,r1,#28
0002aa  0f89              LSRS     r1,r1,#30
0002ac  2902              CMP      r1,#2
0002ae  d06c              BEQ      |L13.906|
;;;633        { 
;;;634          if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
;;;635          {
;;;636            /* Check the parameters */
;;;637            assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
;;;638            assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));
;;;639            assert_param(IS_RCC_PREDIV(RCC_OscInitStruct->PLL.PREDIV));
;;;640      
;;;641            /* Disable the main PLL. */
;;;642            __HAL_RCC_PLL_DISABLE();
0002b0  2601              MOVS     r6,#1
0002b2  0636              LSLS     r6,r6,#24
0002b4  2802              CMP      r0,#2                 ;634
;;;643            
;;;644            /* Get Start Tick */
;;;645            tickstart = HAL_GetTick();
;;;646            
;;;647            /* Wait till PLL is disabled */
;;;648            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
;;;649            {
;;;650              if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
;;;651              {
;;;652                return HAL_TIMEOUT;
;;;653              }
;;;654            }
;;;655    
;;;656            /* Configure the main PLL clock source, predivider and multiplication factor. */
;;;657            __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
;;;658                                 RCC_OscInitStruct->PLL.PREDIV,
;;;659                                 RCC_OscInitStruct->PLL.PLLMUL);
;;;660            /* Enable the main PLL. */
;;;661            __HAL_RCC_PLL_ENABLE();
;;;662            
;;;663            /* Get Start Tick */
;;;664            tickstart = HAL_GetTick();
;;;665            
;;;666            /* Wait till PLL is ready */
;;;667            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
;;;668            {
;;;669              if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
;;;670              {
;;;671                return HAL_TIMEOUT;
;;;672              }
;;;673            }
;;;674          }
;;;675          else
;;;676          {
;;;677            /* Disable the main PLL. */
;;;678            __HAL_RCC_PLL_DISABLE();
0002b6  6828              LDR      r0,[r5,#0]
0002b8  d031              BEQ      |L13.798|
0002ba  43b0              BICS     r0,r0,r6
0002bc  6028              STR      r0,[r5,#0]
;;;679     
;;;680            /* Get Start Tick */
;;;681            tickstart = HAL_GetTick();
0002be  f7fffffe          BL       HAL_GetTick
0002c2  4604              MOV      r4,r0
;;;682            
;;;683            /* Wait till PLL is disabled */  
;;;684            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
0002c4  6828              LDR      r0,[r5,#0]
0002c6  0180              LSLS     r0,r0,#6
0002c8  d55d              BPL      |L13.902|
                  |L13.714|
;;;685            {
;;;686              if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
0002ca  f7fffffe          BL       HAL_GetTick
0002ce  1b00              SUBS     r0,r0,r4
0002d0  2802              CMP      r0,#2
0002d2  d955              BLS      |L13.896|
                  |L13.724|
;;;687              {
;;;688                return HAL_TIMEOUT;
0002d4  2003              MOVS     r0,#3
;;;689              }
;;;690            }
;;;691          }
;;;692        }
;;;693        else
;;;694        {
;;;695          return HAL_ERROR;
;;;696        }
;;;697      }
;;;698      
;;;699      return HAL_OK;
;;;700    }
0002d6  bdf8              POP      {r3-r7,pc}
                  |L13.728|
0002d8  6b69              LDR      r1,[r5,#0x34]         ;519
0002da  2004              MOVS     r0,#4                 ;519
0002dc  4301              ORRS     r1,r1,r0              ;519
0002de  6369              STR      r1,[r5,#0x34]         ;519
0002e0  6b68              LDR      r0,[r5,#0x34]         ;522
0002e2  2101              MOVS     r1,#1                 ;522
0002e4  4308              ORRS     r0,r0,r1              ;522
0002e6  6368              STR      r0,[r5,#0x34]         ;522
0002e8  f7fffffe          BL       HAL_GetTick
0002ec  4606              MOV      r6,r0                 ;525
0002ee  6b68              LDR      r0,[r5,#0x34]         ;528
0002f0  0780              LSLS     r0,r0,#30             ;528
0002f2  d407              BMI      |L13.772|
                  |L13.756|
0002f4  f7fffffe          BL       HAL_GetTick
0002f8  1b80              SUBS     r0,r0,r6              ;530
0002fa  2802              CMP      r0,#2                 ;530
0002fc  d8ea              BHI      |L13.724|
0002fe  6b68              LDR      r0,[r5,#0x34]         ;532
000300  0780              LSLS     r0,r0,#30             ;532
000302  d5f7              BPL      |L13.756|
                  |L13.772|
000304  6b68              LDR      r0,[r5,#0x34]         ;537
000306  21f8              MOVS     r1,#0xf8              ;537
000308  4388              BICS     r0,r0,r1              ;537
00030a  69a1              LDR      r1,[r4,#0x18]         ;537
00030c  00c9              LSLS     r1,r1,#3              ;537
00030e  4308              ORRS     r0,r0,r1              ;537
000310  6368              STR      r0,[r5,#0x34]         ;537
000312  e7c5              B        |L13.672|
                  |L13.788|
000314  6b69              LDR      r1,[r5,#0x34]         ;542
000316  2004              MOVS     r0,#4                 ;542
000318  4381              BICS     r1,r1,r0              ;542
00031a  6369              STR      r1,[r5,#0x34]         ;542
00031c  e7f2              B        |L13.772|
                  |L13.798|
00031e  43b0              BICS     r0,r0,r6              ;642
000320  6028              STR      r0,[r5,#0]            ;642
000322  f7fffffe          BL       HAL_GetTick
000326  4607              MOV      r7,r0                 ;645
000328  6828              LDR      r0,[r5,#0]            ;648
00032a  0180              LSLS     r0,r0,#6              ;648
00032c  d507              BPL      |L13.830|
                  |L13.814|
00032e  f7fffffe          BL       HAL_GetTick
000332  1bc0              SUBS     r0,r0,r7              ;650
000334  2802              CMP      r0,#2                 ;650
000336  d8cd              BHI      |L13.724|
000338  6828              LDR      r0,[r5,#0]            ;652
00033a  0180              LSLS     r0,r0,#6              ;652
00033c  d4f7              BMI      |L13.814|
                  |L13.830|
00033e  6ae8              LDR      r0,[r5,#0x2c]         ;657
000340  6ae1              LDR      r1,[r4,#0x2c]         ;657
000342  0900              LSRS     r0,r0,#4              ;657
000344  0100              LSLS     r0,r0,#4              ;657
000346  4308              ORRS     r0,r0,r1              ;657
000348  62e8              STR      r0,[r5,#0x2c]         ;657
00034a  6aa1              LDR      r1,[r4,#0x28]         ;657
00034c  6a60              LDR      r0,[r4,#0x24]         ;657
00034e  4301              ORRS     r1,r1,r0              ;657
000350  6868              LDR      r0,[r5,#4]            ;657
000352  223d              MOVS     r2,#0x3d              ;657
000354  0412              LSLS     r2,r2,#16             ;657
000356  4390              BICS     r0,r0,r2              ;657
000358  4301              ORRS     r1,r1,r0              ;657
00035a  6069              STR      r1,[r5,#4]            ;657
00035c  6828              LDR      r0,[r5,#0]            ;661
00035e  4330              ORRS     r0,r0,r6              ;661
000360  6028              STR      r0,[r5,#0]            ;661
000362  f7fffffe          BL       HAL_GetTick
000366  4604              MOV      r4,r0                 ;664
000368  6828              LDR      r0,[r5,#0]            ;667
00036a  0180              LSLS     r0,r0,#6              ;667
00036c  d40b              BMI      |L13.902|
                  |L13.878|
00036e  f7fffffe          BL       HAL_GetTick
000372  1b00              SUBS     r0,r0,r4              ;669
000374  2802              CMP      r0,#2                 ;669
000376  d8ad              BHI      |L13.724|
000378  6828              LDR      r0,[r5,#0]            ;671
00037a  0180              LSLS     r0,r0,#6              ;671
00037c  d5f7              BPL      |L13.878|
00037e  e002              B        |L13.902|
                  |L13.896|
000380  6828              LDR      r0,[r5,#0]            ;688
000382  0180              LSLS     r0,r0,#6              ;688
000384  d4a1              BMI      |L13.714|
                  |L13.902|
000386  2000              MOVS     r0,#0                 ;699
000388  bdf8              POP      {r3-r7,pc}
                  |L13.906|
00038a  2001              MOVS     r0,#1                 ;695
00038c  bdf8              POP      {r3-r7,pc}
;;;701    
                          ENDP

00038e  0000              DCW      0x0000
                  |L13.912|
                          DCD      0x40021000
                  |L13.916|
                          DCD      0x40007000
                  |L13.920|
                          DCD      0x00001388

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F0_V1.9.0\\Drivers\\STM32F0xx_HAL_Driver\\Src\\stm32f0xx_hal_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f0xx_hal_rcc_c_b7071a4b____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F0_V1.9.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f0xx_hal_rcc_c_b7071a4b____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f0xx_hal_rcc_c_b7071a4b____REVSH|
#line 402
|__asm___19_stm32f0xx_hal_rcc_c_b7071a4b____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
