; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\kernel.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\kernel.d --cpu=Cortex-M0 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F0_V1.9.0\Drivers\STM32F0xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_F0_V1.9.0\Drivers\CMSIS\Device\ST\STM32L0xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F0_V1.9.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F0_V1.9.0\Drivers\STM32F0xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F030F4P6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F0xx_DFP\2.0.0\Drivers\CMSIS\Device\ST\STM32F0xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F030x6 -DSTM32F030x6 -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\kernel.crf ..\..\MProkaron\Kernel\kernel.c]
                          THUMB

                          AREA ||i.RMP_Clear||, CODE, READONLY, ALIGN=1

                  RMP_Clear PROC
;;;37     ******************************************************************************/
;;;38     void RMP_Clear(volatile void* Addr, ptr_t Size)
000000  b430              PUSH     {r4,r5}
;;;39     {
;;;40         ptr_t* Word_Inc;
;;;41         u8* Byte_Inc;
;;;42         ptr_t Words;
;;;43         ptr_t Bytes;
;;;44         
;;;45         /* On processors not that fast, copy by word is really important */
;;;46         Word_Inc=(ptr_t*)Addr;
;;;47         for(Words=Size/sizeof(ptr_t);Words>0;Words--)
000002  088d              LSRS     r5,r1,#2
000004  2400              MOVS     r4,#0
000006  2903              CMP      r1,#3
000008  d90d              BLS      |L1.38|
00000a  1f02              SUBS     r2,r0,#4
;;;48         {
;;;49             *Word_Inc=0;
;;;50             Word_Inc++;
;;;51         }
;;;52         
;;;53         /* Get the final bytes */
;;;54         Byte_Inc=(u8*)Word_Inc;
;;;55         for(Bytes=Size%sizeof(ptr_t);Bytes>0;Bytes--)
;;;56         {
;;;57             *Byte_Inc=0;
;;;58             Byte_Inc++;
;;;59         }
;;;60     }
00000c  07eb              LSLS     r3,r5,#31
00000e  d001              BEQ      |L1.20|
000010  6054              STR      r4,[r2,#4]            ;49
000012  1d12              ADDS     r2,r2,#4              ;49
                  |L1.20|
000014  106b              ASRS     r3,r5,#1              ;47
000016  d004              BEQ      |L1.34|
                  |L1.24|
000018  6054              STR      r4,[r2,#4]            ;49
00001a  6094              STR      r4,[r2,#8]            ;49
00001c  3208              ADDS     r2,r2,#8              ;49
00001e  1e5b              SUBS     r3,r3,#1              ;49
000020  d1fa              BNE      |L1.24|
                  |L1.34|
000022  00aa              LSLS     r2,r5,#2              ;49
000024  1810              ADDS     r0,r2,r0              ;51
                  |L1.38|
000026  078a              LSLS     r2,r1,#30             ;55
000028  0f92              LSRS     r2,r2,#30             ;55
00002a  0789              LSLS     r1,r1,#30             ;55
00002c  d00b              BEQ      |L1.70|
00002e  1e40              SUBS     r0,r0,#1              ;55
000030  07d1              LSLS     r1,r2,#31
000032  d001              BEQ      |L1.56|
000034  7044              STRB     r4,[r0,#1]            ;57
000036  1c40              ADDS     r0,r0,#1              ;57
                  |L1.56|
000038  0851              LSRS     r1,r2,#1              ;55
00003a  d004              BEQ      |L1.70|
                  |L1.60|
00003c  7044              STRB     r4,[r0,#1]            ;57
00003e  7084              STRB     r4,[r0,#2]            ;57
000040  1c80              ADDS     r0,r0,#2              ;57
000042  1e49              SUBS     r1,r1,#1              ;57
000044  d1fa              BNE      |L1.60|
                  |L1.70|
000046  bc30              POP      {r4,r5}
000048  4770              BX       lr
;;;61     /* End Function:RMP_Clear ****************************************************/
                          ENDP


                          AREA ||i.RMP_Init||, CODE, READONLY, ALIGN=2

                  RMP_Init PROC
;;;1506   ******************************************************************************/
;;;1507   void RMP_Init(void)
000000  4807              LDR      r0,|L2.32|
000002  2101              MOVS     r1,#1
000004  60c1              STR      r1,[r0,#0xc]  ; RMP_Sched_Locked
000006  6881              LDR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
000008  1c49              ADDS     r1,r1,#1
00000a  6081              STR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
;;;1508   {
;;;1509       RMP_Lock_Sched();
;;;1510       
;;;1511       /* Platform will use this hook to do something */
;;;1512       _RMP_Plat_Hook();
00000c  f7fffffe          BL       _RMP_Plat_Hook
;;;1513       /* Start the second thread here */
;;;1514       RMP_Init_Hook();
000010  f7fffffe          BL       RMP_Init_Hook
;;;1515       
;;;1516       RMP_Unlock_Sched();
000014  f7fffffe          BL       RMP_Unlock_Sched
                  |L2.24|
;;;1517       
;;;1518       while(1)
;;;1519       {
;;;1520           RMP_Init_Idle();
000018  f7fffffe          BL       RMP_Init_Idle
00001c  e7fc              B        |L2.24|
;;;1521       };
;;;1522   }
;;;1523   /* End Function:RMP_Init *****************************************************/
                          ENDP

00001e  0000              DCW      0x0000
                  |L2.32|
                          DCD      ||.data||

                          AREA ||i.RMP_List_Crt||, CODE, READONLY, ALIGN=1

                  RMP_List_Crt PROC
;;;215    ******************************************************************************/
;;;216    void RMP_List_Crt(volatile struct RMP_List* Head)
000000  6000              STR      r0,[r0,#0]
;;;217    {
;;;218        Head->Prev=(struct RMP_List*)Head;
;;;219        Head->Next=(struct RMP_List*)Head;
000002  6040              STR      r0,[r0,#4]
;;;220    }
000004  4770              BX       lr
;;;221    /* End Function:RMP_List_Crt *************************************************/
                          ENDP


                          AREA ||i.RMP_List_Del||, CODE, READONLY, ALIGN=1

                  RMP_List_Del PROC
;;;229    ******************************************************************************/
;;;230    void RMP_List_Del(volatile struct RMP_List* Prev,volatile struct RMP_List* Next)
000000  6008              STR      r0,[r1,#0]
;;;231    {
;;;232        Next->Prev=(struct RMP_List*)Prev;
;;;233        Prev->Next=(struct RMP_List*)Next;
000002  6041              STR      r1,[r0,#4]
;;;234    }
000004  4770              BX       lr
;;;235    /* End Function:RMP_List_Del *************************************************/
                          ENDP


                          AREA ||i.RMP_List_Ins||, CODE, READONLY, ALIGN=1

                  RMP_List_Ins PROC
;;;244    ******************************************************************************/
;;;245    void RMP_List_Ins(volatile struct RMP_List* New,
000000  6010              STR      r0,[r2,#0]
;;;246                      volatile struct RMP_List* Prev,
;;;247                      volatile struct RMP_List* Next)
;;;248    {
;;;249        Next->Prev=(struct RMP_List*)New;
;;;250        New->Next=(struct RMP_List*)Next;
000002  6042              STR      r2,[r0,#4]
;;;251        New->Prev=(struct RMP_List*)Prev;
000004  6001              STR      r1,[r0,#0]
;;;252        Prev->Next=(struct RMP_List*)New;
000006  6048              STR      r0,[r1,#4]
;;;253    }
000008  4770              BX       lr
;;;254    /* End Function:RMP_List_Ins *************************************************/
                          ENDP


                          AREA ||i.RMP_Load_Ctx||, CODE, READONLY, ALIGN=1

                  RMP_Load_Ctx PROC
;;;1474   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1475   void RMP_Load_Ctx(void)
000000  4770              BX       lr
;;;1476   {
;;;1477       return;
;;;1478   }
;;;1479   #endif
                          ENDP


                          AREA ||i.RMP_Lock_Sched||, CODE, READONLY, ALIGN=2

                  RMP_Lock_Sched PROC
;;;261    ******************************************************************************/
;;;262    void RMP_Lock_Sched(void)
000000  4803              LDR      r0,|L7.16|
;;;263    {
;;;264        RMP_Sched_Locked=1;
000002  2101              MOVS     r1,#1
000004  60c1              STR      r1,[r0,#0xc]  ; RMP_Sched_Locked
;;;265        RMP_Sched_Lock_Cnt++;
000006  6881              LDR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
000008  1c49              ADDS     r1,r1,#1
00000a  6081              STR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
;;;266    }
00000c  4770              BX       lr
;;;267    /* End Function:RMP_Lock_Sched ***********************************************/
                          ENDP

00000e  0000              DCW      0x0000
                  |L7.16|
                          DCD      ||.data||

                          AREA ||i.RMP_Print_Int||, CODE, READONLY, ALIGN=1

                  RMP_Print_Int PROC
;;;69     ******************************************************************************/
;;;70     cnt_t RMP_Print_Int(cnt_t Int)
000000  b5f8              PUSH     {r3-r7,lr}
;;;71     {
000002  0006              MOVS     r6,r0
000004  d02b              BEQ      |L8.94|
;;;72         ptr_t Iter;
;;;73         cnt_t Count;
;;;74         cnt_t Num;
;;;75         ptr_t Div;
;;;76         
;;;77         /* how many digits are there? */
;;;78         if(Int==0)
;;;79         {
;;;80             RMP_Putchar('0');
;;;81             return 1;
;;;82         }
;;;83         else if(Int<0)
000006  2e00              CMP      r6,#0
000008  da2e              BGE      |L8.104|
;;;84         {
;;;85             /* How many digits are there? */
;;;86             Count=0;
00000a  2400              MOVS     r4,#0
;;;87             Div=1;
00000c  2501              MOVS     r5,#1
;;;88             Iter=-Int;
00000e  4240              RSBS     r0,r0,#0
000010  4606              MOV      r6,r0
;;;89             while(Iter!=0)
000012  d007              BEQ      |L8.36|
                  |L8.20|
;;;90             {
;;;91                 Iter/=10;
000014  210a              MOVS     r1,#0xa
000016  f7fffffe          BL       __aeabi_uidivmod
;;;92                 Count++;
;;;93                 Div*=10;
00001a  210a              MOVS     r1,#0xa
00001c  434d              MULS     r5,r1,r5
00001e  1c64              ADDS     r4,r4,#1
000020  2800              CMP      r0,#0                 ;89
000022  d1f7              BNE      |L8.20|
                  |L8.36|
;;;94             }
;;;95             Div/=10;
000024  210a              MOVS     r1,#0xa
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       __aeabi_uidivmod
00002c  4605              MOV      r5,r0
;;;96             
;;;97             RMP_Putchar('-');
00002e  202d              MOVS     r0,#0x2d
000030  f7fffffe          BL       RMP_Putchar
;;;98             Iter=-Int;
;;;99             Num=Count+1;
000034  1c67              ADDS     r7,r4,#1
;;;100            
;;;101            while(Count>0)
000036  2c00              CMP      r4,#0
000038  dd37              BLE      |L8.170|
                  |L8.58|
;;;102            {
;;;103                Count--;
;;;104                RMP_Putchar(Iter/Div+'0');
00003a  4629              MOV      r1,r5
00003c  4630              MOV      r0,r6
00003e  1e64              SUBS     r4,r4,#1
000040  f7fffffe          BL       __aeabi_uidivmod
000044  3030              ADDS     r0,r0,#0x30
000046  460e              MOV      r6,r1
000048  b240              SXTB     r0,r0
00004a  f7fffffe          BL       RMP_Putchar
;;;105                Iter=Iter%Div;
;;;106                Div/=10;
00004e  210a              MOVS     r1,#0xa
000050  4628              MOV      r0,r5
000052  f7fffffe          BL       __aeabi_uidivmod
000056  4605              MOV      r5,r0
000058  2c00              CMP      r4,#0                 ;101
00005a  dcee              BGT      |L8.58|
00005c  e025              B        |L8.170|
                  |L8.94|
00005e  2030              MOVS     r0,#0x30              ;80
000060  f7fffffe          BL       RMP_Putchar
000064  2001              MOVS     r0,#1                 ;81
;;;107            }
;;;108        }
;;;109        else
;;;110        {
;;;111            /* How many digits are there? */
;;;112            Count=0;
;;;113            Div=1;
;;;114            Iter=Int;
;;;115            while(Iter!=0)
;;;116            {
;;;117                Iter/=10;
;;;118                Count++;
;;;119                Div*=10;
;;;120            }
;;;121            Div/=10;
;;;122            
;;;123            Iter=Int;
;;;124            Num=Count;
;;;125            
;;;126            while(Count>0)
;;;127            {
;;;128                Count--;
;;;129                RMP_Putchar(Iter/Div+'0');
;;;130                Iter=Iter%Div;
;;;131                Div/=10;
;;;132            }
;;;133        }
;;;134        
;;;135        return Num;
;;;136    }
000066  bdf8              POP      {r3-r7,pc}
                  |L8.104|
000068  2500              MOVS     r5,#0                 ;112
00006a  2401              MOVS     r4,#1                 ;113
                  |L8.108|
00006c  210a              MOVS     r1,#0xa               ;117
00006e  f7fffffe          BL       __aeabi_uidivmod
000072  210a              MOVS     r1,#0xa               ;119
000074  434c              MULS     r4,r1,r4              ;119
000076  1c6d              ADDS     r5,r5,#1              ;119
000078  2800              CMP      r0,#0                 ;115
00007a  d1f7              BNE      |L8.108|
00007c  4620              MOV      r0,r4                 ;121
00007e  f7fffffe          BL       __aeabi_uidivmod
000082  4604              MOV      r4,r0                 ;121
000084  1e2f              SUBS     r7,r5,#0              ;124
000086  dd10              BLE      |L8.170|
                  |L8.136|
000088  4601              MOV      r1,r0                 ;129
00008a  4630              MOV      r0,r6                 ;129
00008c  1e6d              SUBS     r5,r5,#1              ;129
00008e  f7fffffe          BL       __aeabi_uidivmod
000092  3030              ADDS     r0,r0,#0x30           ;129
000094  460e              MOV      r6,r1                 ;129
000096  b240              SXTB     r0,r0                 ;129
000098  f7fffffe          BL       RMP_Putchar
00009c  210a              MOVS     r1,#0xa               ;131
00009e  4620              MOV      r0,r4                 ;131
0000a0  f7fffffe          BL       __aeabi_uidivmod
0000a4  4604              MOV      r4,r0                 ;131
0000a6  2d00              CMP      r5,#0                 ;126
0000a8  dcee              BGT      |L8.136|
                  |L8.170|
0000aa  4638              MOV      r0,r7                 ;135
0000ac  bdf8              POP      {r3-r7,pc}
;;;137    /* End Function:RMP_Print_Int ************************************************/
                          ENDP


                          AREA ||i.RMP_Print_String||, CODE, READONLY, ALIGN=1

                  RMP_Print_String PROC
;;;192    ******************************************************************************/
;;;193    cnt_t RMP_Print_String(s8* String)
000000  b570              PUSH     {r4-r6,lr}
;;;194    {
000002  4605              MOV      r5,r0
;;;195        cnt_t Count;
;;;196        
;;;197        Count=0;
000004  2400              MOVS     r4,#0
                  |L9.6|
;;;198        while(Count<RMP_KERNEL_DEBUG_MAX_STR)
;;;199        {
;;;200            if(String[Count]=='\0')
000006  5728              LDRSB    r0,[r5,r4]
000008  2800              CMP      r0,#0
00000a  d004              BEQ      |L9.22|
00000c  1c64              ADDS     r4,r4,#1
;;;201                break;
;;;202            
;;;203            RMP_Putchar(String[Count++]);
00000e  f7fffffe          BL       RMP_Putchar
000012  2cff              CMP      r4,#0xff              ;198
000014  dbf7              BLT      |L9.6|
                  |L9.22|
;;;204        }
;;;205        
;;;206        return Count;
000016  4620              MOV      r0,r4
;;;207    }
000018  bd70              POP      {r4-r6,pc}
;;;208    /* End Function:RMP_Print_String *********************************************/
                          ENDP


                          AREA ||i.RMP_Print_Uint||, CODE, READONLY, ALIGN=1

                  RMP_Print_Uint PROC
;;;145    ******************************************************************************/
;;;146    cnt_t RMP_Print_Uint(ptr_t Uint)
000000  b570              PUSH     {r4-r6,lr}
;;;147    {
000002  0004              MOVS     r4,r0
000004  d003              BEQ      |L10.14|
;;;148        ptr_t Iter;
;;;149        cnt_t Count;
;;;150        cnt_t Num;
;;;151        
;;;152        /* how many digits are there? */
;;;153        if(Uint==0)
;;;154        {
;;;155            RMP_Putchar('0');
;;;156            return 1;
;;;157        }
;;;158        else
;;;159        {
;;;160            /* Filter out all the zeroes */
;;;161            Count=0;
000006  2100              MOVS     r1,#0
;;;162            Iter=Uint;
;;;163            while((Iter>>((sizeof(ptr_t)*8)-4))==0)
000008  0f02              LSRS     r2,r0,#28
00000a  d005              BEQ      |L10.24|
00000c  e008              B        |L10.32|
                  |L10.14|
00000e  2030              MOVS     r0,#0x30              ;155
000010  f7fffffe          BL       RMP_Putchar
000014  2001              MOVS     r0,#1                 ;156
;;;164            {
;;;165                Iter<<=4;
;;;166                Count++;
;;;167            }
;;;168            /* Count is the number of pts to print */
;;;169            Count=sizeof(ptr_t)*2-Count;
;;;170            Num=Count;
;;;171            while(Count>0)
;;;172            {
;;;173                Count--;
;;;174                Iter=(Uint>>(Count*4))&0x0F;
;;;175                if(Iter<10)
;;;176                    RMP_Putchar('0'+Iter);
;;;177                else
;;;178                    RMP_Putchar('A'+Iter-10);
;;;179            }
;;;180        }
;;;181        
;;;182        return Num;
;;;183    }
000016  bd70              POP      {r4-r6,pc}
                  |L10.24|
000018  0100              LSLS     r0,r0,#4              ;165
00001a  1c49              ADDS     r1,r1,#1              ;165
00001c  0f02              LSRS     r2,r0,#28             ;163
00001e  d0fb              BEQ      |L10.24|
                  |L10.32|
000020  2008              MOVS     r0,#8                 ;169
000022  1a45              SUBS     r5,r0,r1              ;169
000024  1e2e              SUBS     r6,r5,#0              ;170
000026  dd10              BLE      |L10.74|
                  |L10.40|
000028  4628              MOV      r0,r5                 ;173
00002a  1e6d              SUBS     r5,r5,#1              ;173
00002c  0080              LSLS     r0,r0,#2
00002e  4621              MOV      r1,r4
000030  1f00              SUBS     r0,r0,#4
000032  40c1              LSRS     r1,r1,r0              ;174
000034  0708              LSLS     r0,r1,#28             ;174
000036  0f00              LSRS     r0,r0,#28             ;174
000038  280a              CMP      r0,#0xa               ;175
00003a  d201              BCS      |L10.64|
00003c  3030              ADDS     r0,r0,#0x30           ;175
00003e  e000              B        |L10.66|
                  |L10.64|
000040  3037              ADDS     r0,r0,#0x37           ;176
                  |L10.66|
000042  f7fffffe          BL       RMP_Putchar
000046  2d00              CMP      r5,#0                 ;171
000048  dcee              BGT      |L10.40|
                  |L10.74|
00004a  4630              MOV      r0,r6                 ;182
00004c  bd70              POP      {r4-r6,pc}
;;;184    /* End Function:RMP_Print_Uint ***********************************************/
                          ENDP


                          AREA ||i.RMP_Save_Ctx||, CODE, READONLY, ALIGN=1

                  RMP_Save_Ctx PROC
;;;1460   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1461   void RMP_Save_Ctx(void)
000000  4770              BX       lr
;;;1462   {
;;;1463       return;
;;;1464   }
;;;1465   #endif
                          ENDP


                          AREA ||i.RMP_Sem_Abort||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Abort PROC
;;;1288   ******************************************************************************/
;;;1289   ret_t RMP_Sem_Abort(volatile struct RMP_Thd* Thread)
000000  b570              PUSH     {r4-r6,lr}
;;;1290   {
;;;1291       /* Check if this thread structure could possibly be in use */
;;;1292       if(Thread==0)
;;;1293           return RMP_ERR_THD;
000002  4d1e              LDR      r5,|L12.124|
000004  0004              MOVS     r4,r0                 ;1290
000006  d015              BEQ      |L12.52|
000008  481d              LDR      r0,|L12.128|
00000a  2101              MOVS     r1,#1                 ;1290
00000c  60c1              STR      r1,[r0,#0xc]          ;1290  ; RMP_Sched_Locked
00000e  6881              LDR      r1,[r0,#8]            ;1290  ; RMP_Sched_Lock_Cnt
000010  1c49              ADDS     r1,r1,#1              ;1290
000012  6081              STR      r1,[r0,#8]            ;1290  ; RMP_Sched_Lock_Cnt
;;;1294   
;;;1295       RMP_Lock_Sched();
;;;1296       
;;;1297       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
000014  69a0              LDR      r0,[r4,#0x18]
000016  0600              LSLS     r0,r0,#24
000018  0e00              LSRS     r0,r0,#24
00001a  d00d              BEQ      |L12.56|
;;;1298       {
;;;1299           RMP_Unlock_Sched();
;;;1300           return RMP_ERR_THD;
;;;1301       }
;;;1302       
;;;1303       /* Is it waiting on a semaphore? If no, we abort and return an error code */
;;;1304       if((RMP_THD_STATE(Thread->State)!=RMP_THD_SEMBLK)&&
00001c  69a0              LDR      r0,[r4,#0x18]
00001e  b2c0              UXTB     r0,r0
000020  2807              CMP      r0,#7
000022  d00d              BEQ      |L12.64|
;;;1305          (RMP_THD_STATE(Thread->State)!=RMP_THD_SEMDLY))
000024  69a0              LDR      r0,[r4,#0x18]
000026  b2c0              UXTB     r0,r0
000028  2808              CMP      r0,#8
00002a  d009              BEQ      |L12.64|
;;;1306       {
;;;1307           RMP_Unlock_Sched();
00002c  f7fffffe          BL       RMP_Unlock_Sched
;;;1308           return RMP_ERR_STATE;
000030  00a8              LSLS     r0,r5,#2
;;;1309       }
;;;1310   
;;;1311       /* Waiting for a semaphore. We abort it and return */
;;;1312       RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1313       if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1314           RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1315       
;;;1316       RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1317   
;;;1318       /* Only when when this thread is not suspended do we change it back */
;;;1319       if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1320           _RMP_Set_Rdy(Thread);
;;;1321       
;;;1322       Thread->Retval=RMP_ERR_OPER;
;;;1323       
;;;1324       RMP_Unlock_Sched();
;;;1325   
;;;1326       return 0;
;;;1327   }
000032  bd70              POP      {r4-r6,pc}
                  |L12.52|
000034  4628              MOV      r0,r5                 ;1293
000036  bd70              POP      {r4-r6,pc}
                  |L12.56|
000038  f7fffffe          BL       RMP_Unlock_Sched
00003c  4628              MOV      r0,r5                 ;1300
00003e  bd70              POP      {r4-r6,pc}
                  |L12.64|
000040  6821              LDR      r1,[r4,#0]            ;1312
000042  6860              LDR      r0,[r4,#4]            ;1312
000044  6001              STR      r1,[r0,#0]            ;1312
000046  6048              STR      r0,[r1,#4]            ;1312
000048  69a0              LDR      r0,[r4,#0x18]         ;1313
00004a  b2c0              UXTB     r0,r0                 ;1313
00004c  2808              CMP      r0,#8                 ;1313
00004e  d103              BNE      |L12.88|
000050  68a1              LDR      r1,[r4,#8]            ;1314
000052  68e0              LDR      r0,[r4,#0xc]          ;1314
000054  6001              STR      r1,[r0,#0]            ;1314
000056  6048              STR      r0,[r1,#4]            ;1314
                  |L12.88|
000058  69a0              LDR      r0,[r4,#0x18]         ;1316
00005a  0a00              LSRS     r0,r0,#8              ;1316
00005c  0200              LSLS     r0,r0,#8              ;1316
00005e  1c40              ADDS     r0,r0,#1              ;1316
000060  61a0              STR      r0,[r4,#0x18]         ;1316
000062  69a0              LDR      r0,[r4,#0x18]         ;1319
000064  05c0              LSLS     r0,r0,#23             ;1319
000066  d402              BMI      |L12.110|
000068  4620              MOV      r0,r4                 ;1320
00006a  f7fffffe          BL       _RMP_Set_Rdy
                  |L12.110|
00006e  2004              MOVS     r0,#4                 ;1322
000070  43c0              MVNS     r0,r0                 ;1322
000072  63a0              STR      r0,[r4,#0x38]         ;1322
000074  f7fffffe          BL       RMP_Unlock_Sched
000078  2000              MOVS     r0,#0                 ;1326
00007a  bd70              POP      {r4-r6,pc}
;;;1328   /* End Function:RMP_Sem_Abort ************************************************/
                          ENDP

                  |L12.124|
                          DCD      0xffffffff
                  |L12.128|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Crt||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Crt PROC
;;;1146   ******************************************************************************/
;;;1147   ret_t RMP_Sem_Crt(volatile struct RMP_Sem* Semaphore, ptr_t Number)
000000  b570              PUSH     {r4-r6,lr}
;;;1148   {
;;;1149       /* Check if this semaphore structure could possibly be in use */
;;;1150       if(Semaphore==0)
;;;1151           return RMP_ERR_SEM;
000002  2405              MOVS     r4,#5
000004  43e4              MVNS     r4,r4
000006  2800              CMP      r0,#0                 ;1150
000008  d00c              BEQ      |L13.36|
00000a  4a10              LDR      r2,|L13.76|
00000c  2301              MOVS     r3,#1                 ;1148
00000e  60d3              STR      r3,[r2,#0xc]          ;1148  ; RMP_Sched_Locked
000010  6895              LDR      r5,[r2,#8]            ;1148  ; RMP_Sched_Lock_Cnt
000012  1c6d              ADDS     r5,r5,#1              ;1148
000014  6095              STR      r5,[r2,#8]            ;1148  ; RMP_Sched_Lock_Cnt
;;;1152       
;;;1153       RMP_Lock_Sched();
;;;1154       
;;;1155       if(Semaphore->State!=RMP_SEM_FREE)
000016  6882              LDR      r2,[r0,#8]
000018  2a00              CMP      r2,#0
00001a  d005              BEQ      |L13.40|
;;;1156       {
;;;1157           RMP_Unlock_Sched();
00001c  f7fffffe          BL       RMP_Unlock_Sched
;;;1158           return RMP_ERR_SEM;
000020  4620              MOV      r0,r4
;;;1159       }
;;;1160       
;;;1161       /* Is the number too great to initialize? */
;;;1162       if(Number>=RMP_SEM_MAX_NUM)
;;;1163       {
;;;1164           RMP_Unlock_Sched();
;;;1165           return RMP_ERR_OPER;
;;;1166       }
;;;1167   
;;;1168       /* Initialize contents */
;;;1169       Semaphore->Cur_Num=Number;
;;;1170       Semaphore->State=RMP_SEM_USED;
;;;1171       RMP_List_Crt(&(Semaphore->Wait_List));
;;;1172       
;;;1173       RMP_Unlock_Sched();
;;;1174       
;;;1175       return 0;
;;;1176   }
000022  bd70              POP      {r4-r6,pc}
                  |L13.36|
000024  4620              MOV      r0,r4                 ;1151
000026  bd70              POP      {r4-r6,pc}
                  |L13.40|
000028  227d              MOVS     r2,#0x7d              ;1162
00002a  00d2              LSLS     r2,r2,#3              ;1162
00002c  4291              CMP      r1,r2                 ;1162
00002e  d304              BCC      |L13.58|
000030  f7fffffe          BL       RMP_Unlock_Sched
000034  2004              MOVS     r0,#4                 ;1165
000036  43c0              MVNS     r0,r0                 ;1165
000038  bd70              POP      {r4-r6,pc}
                  |L13.58|
00003a  60c1              STR      r1,[r0,#0xc]          ;1169
00003c  6083              STR      r3,[r0,#8]            ;1170
00003e  6000              STR      r0,[r0,#0]            ;1170
000040  6040              STR      r0,[r0,#4]            ;1170
000042  f7fffffe          BL       RMP_Unlock_Sched
000046  2000              MOVS     r0,#0                 ;1175
000048  bd70              POP      {r4-r6,pc}
;;;1177   /* End Function:RMP_Sem_Crt **************************************************/
                          ENDP

00004a  0000              DCW      0x0000
                  |L13.76|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Del||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Del PROC
;;;1184   ******************************************************************************/
;;;1185   ret_t RMP_Sem_Del(volatile struct RMP_Sem* Semaphore)
000000  b570              PUSH     {r4-r6,lr}
;;;1186   {
;;;1187       struct RMP_Thd* Thread;
;;;1188       
;;;1189       /* Check if this semaphore structure could possibly be in use */
;;;1190       if(Semaphore==0)
;;;1191           return RMP_ERR_SEM;
000002  4c1b              LDR      r4,|L14.112|
000004  0005              MOVS     r5,r0                 ;1186
000006  d00c              BEQ      |L14.34|
000008  481a              LDR      r0,|L14.116|
00000a  2101              MOVS     r1,#1                 ;1186
00000c  60c1              STR      r1,[r0,#0xc]          ;1186  ; RMP_Sched_Locked
00000e  6881              LDR      r1,[r0,#8]            ;1186  ; RMP_Sched_Lock_Cnt
000010  1c49              ADDS     r1,r1,#1              ;1186
000012  6081              STR      r1,[r0,#8]            ;1186  ; RMP_Sched_Lock_Cnt
;;;1192       
;;;1193       RMP_Lock_Sched();
;;;1194       
;;;1195       if(Semaphore->State!=RMP_SEM_USED)
000014  68a8              LDR      r0,[r5,#8]
000016  2801              CMP      r0,#1
000018  d005              BEQ      |L14.38|
;;;1196       {
;;;1197           RMP_Unlock_Sched();
00001a  f7fffffe          BL       RMP_Unlock_Sched
;;;1198           return RMP_ERR_SEM;
00001e  4620              MOV      r0,r4
;;;1199       }
;;;1200   
;;;1201       /* Get rid of all guys waiting on it */
;;;1202       while(&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)
;;;1203       {
;;;1204           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1205           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1206           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1207               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1208   
;;;1209           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1210   
;;;1211           /* Is it suspended? If yes, we can't directly send it running */
;;;1212           if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1213              _RMP_Set_Rdy(Thread);
;;;1214           
;;;1215           Thread->Retval=RMP_ERR_OPER;
;;;1216       }
;;;1217       Semaphore->State=RMP_SEM_FREE;
;;;1218       
;;;1219       RMP_Unlock_Sched();
;;;1220   
;;;1221       return 0;
;;;1222   }
000020  bd70              POP      {r4-r6,pc}
                  |L14.34|
000022  4620              MOV      r0,r4                 ;1191
000024  bd70              POP      {r4-r6,pc}
                  |L14.38|
000026  6868              LDR      r0,[r5,#4]            ;1202
000028  42a8              CMP      r0,r5                 ;1202
00002a  d01b              BEQ      |L14.100|
00002c  2604              MOVS     r6,#4                 ;1215
00002e  43f6              MVNS     r6,r6                 ;1215
                  |L14.48|
000030  686c              LDR      r4,[r5,#4]            ;1204
000032  6861              LDR      r1,[r4,#4]            ;1204
000034  6820              LDR      r0,[r4,#0]            ;1204
000036  6008              STR      r0,[r1,#0]            ;1204
000038  6041              STR      r1,[r0,#4]            ;1204
00003a  7e20              LDRB     r0,[r4,#0x18]         ;1206
00003c  2808              CMP      r0,#8                 ;1206
00003e  d103              BNE      |L14.72|
000040  68e1              LDR      r1,[r4,#0xc]          ;1206
000042  68a0              LDR      r0,[r4,#8]            ;1206
000044  6008              STR      r0,[r1,#0]            ;1206
000046  6041              STR      r1,[r0,#4]            ;1206
                  |L14.72|
000048  69a0              LDR      r0,[r4,#0x18]         ;1209
00004a  0a00              LSRS     r0,r0,#8              ;1209
00004c  0200              LSLS     r0,r0,#8              ;1209
00004e  1c40              ADDS     r0,r0,#1              ;1209
000050  61a0              STR      r0,[r4,#0x18]         ;1212
000052  05c0              LSLS     r0,r0,#23             ;1212
000054  d402              BMI      |L14.92|
000056  4620              MOV      r0,r4                 ;1213
000058  f7fffffe          BL       _RMP_Set_Rdy
                  |L14.92|
00005c  63a6              STR      r6,[r4,#0x38]         ;1202
00005e  6868              LDR      r0,[r5,#4]            ;1202
000060  42a8              CMP      r0,r5                 ;1202
000062  d1e5              BNE      |L14.48|
                  |L14.100|
000064  2000              MOVS     r0,#0                 ;1217
000066  60a8              STR      r0,[r5,#8]            ;1217
000068  f7fffffe          BL       RMP_Unlock_Sched
00006c  2000              MOVS     r0,#0                 ;1221
00006e  bd70              POP      {r4-r6,pc}
;;;1223   /* End Function:RMP_Sem_Del **************************************************/
                          ENDP

                  |L14.112|
                          DCD      0xfffffffa
                  |L14.116|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Pend||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Pend PROC
;;;1231   ******************************************************************************/
;;;1232   ret_t RMP_Sem_Pend(volatile struct RMP_Sem* Semaphore, ptr_t Slices)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1233   {
;;;1234       /* Check if this semaphore structure could possibly be in use */
;;;1235       if(Semaphore==0)
;;;1236           return RMP_ERR_SEM;
000002  4f2d              LDR      r7,|L15.184|
000004  460c              MOV      r4,r1                 ;1233
000006  0006              MOVS     r6,r0                 ;1233
000008  d00c              BEQ      |L15.36|
00000a  4d2c              LDR      r5,|L15.188|
00000c  2001              MOVS     r0,#1                 ;1233
00000e  60e8              STR      r0,[r5,#0xc]          ;1233  ; RMP_Sched_Locked
000010  68a8              LDR      r0,[r5,#8]            ;1233  ; RMP_Sched_Lock_Cnt
000012  1c40              ADDS     r0,r0,#1              ;1233
000014  60a8              STR      r0,[r5,#8]            ;1233  ; RMP_Sched_Lock_Cnt
;;;1237       
;;;1238       RMP_Lock_Sched();
;;;1239       
;;;1240       if(Semaphore->State!=RMP_SEM_USED)
000016  68b0              LDR      r0,[r6,#8]
000018  2801              CMP      r0,#1
00001a  d005              BEQ      |L15.40|
;;;1241       {
;;;1242           RMP_Unlock_Sched();
00001c  f7fffffe          BL       RMP_Unlock_Sched
;;;1243           return RMP_ERR_SEM;
000020  4638              MOV      r0,r7
;;;1244       }
;;;1245       
;;;1246       /* Check if we can get one immediately */
;;;1247       if(Semaphore->Cur_Num!=0)
;;;1248       {
;;;1249           Semaphore->Cur_Num--;
;;;1250           RMP_Unlock_Sched();
;;;1251           return Semaphore->Cur_Num;
;;;1252       }
;;;1253       else
;;;1254       {
;;;1255           /* Cannot get one, we need to block */
;;;1256           if(Slices==0)
;;;1257           {
;;;1258               RMP_Unlock_Sched();
;;;1259               return RMP_ERR_OPER;
;;;1260           }
;;;1261   
;;;1262           /* We must be running - place into waitlist now */
;;;1263           _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1264           RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Semaphore->Wait_List.Prev,&(Semaphore->Wait_List));
;;;1265           
;;;1266           if(Slices<RMP_MAX_SLICES)
;;;1267           {
;;;1268               _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1269               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMDLY);
;;;1270           }
;;;1271           else
;;;1272               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMBLK);
;;;1273           
;;;1274           RMP_Cur_Thd->Retval=0;
;;;1275       }
;;;1276       
;;;1277       RMP_Unlock_Sched();
;;;1278   
;;;1279       return RMP_Cur_Thd->Retval;
;;;1280   }
000022  bdf8              POP      {r3-r7,pc}
                  |L15.36|
000024  4638              MOV      r0,r7                 ;1236
000026  bdf8              POP      {r3-r7,pc}
                  |L15.40|
000028  68f0              LDR      r0,[r6,#0xc]          ;1247
00002a  2800              CMP      r0,#0                 ;1247
00002c  d006              BEQ      |L15.60|
00002e  68f0              LDR      r0,[r6,#0xc]          ;1249
000030  1e40              SUBS     r0,r0,#1              ;1249
000032  60f0              STR      r0,[r6,#0xc]          ;1249
000034  f7fffffe          BL       RMP_Unlock_Sched
000038  68f0              LDR      r0,[r6,#0xc]          ;1251
00003a  bdf8              POP      {r3-r7,pc}
                  |L15.60|
00003c  2c00              CMP      r4,#0                 ;1256
00003e  d02f              BEQ      |L15.160|
000040  69a8              LDR      r0,[r5,#0x18]         ;1263  ; RMP_Cur_Thd
000042  f7fffffe          BL       _RMP_Clr_Rdy
000046  69a8              LDR      r0,[r5,#0x18]         ;1264  ; RMP_Cur_Thd
000048  6831              LDR      r1,[r6,#0]            ;1264
00004a  6030              STR      r0,[r6,#0]            ;1264
00004c  6046              STR      r6,[r0,#4]            ;1264
00004e  6001              STR      r1,[r0,#0]            ;1264
000050  6048              STR      r0,[r1,#4]            ;1264
000052  481b              LDR      r0,|L15.192|
000054  4284              CMP      r4,r0                 ;1266
000056  d228              BCS      |L15.170|
000058  69aa              LDR      r2,[r5,#0x18]         ;1268  ; RMP_Cur_Thd
00005a  4b1a              LDR      r3,|L15.196|
00005c  6858              LDR      r0,[r3,#4]            ;1268  ; RMP_Delay
00005e  4298              CMP      r0,r3                 ;1268
000060  d006              BEQ      |L15.112|
000062  6a06              LDR      r6,[r0,#0x20]         ;1268
                  |L15.100|
000064  6869              LDR      r1,[r5,#4]            ;1268  ; RMP_Tick
000066  1a71              SUBS     r1,r6,r1              ;1268
000068  42a1              CMP      r1,r4                 ;1268
00006a  d801              BHI      |L15.112|
00006c  4298              CMP      r0,r3                 ;1268
00006e  d1f9              BNE      |L15.100|
                  |L15.112|
000070  6869              LDR      r1,[r5,#4]            ;1268  ; RMP_Tick
000072  1909              ADDS     r1,r1,r4              ;1268
000074  6291              STR      r1,[r2,#0x28]         ;1268
000076  3208              ADDS     r2,r2,#8              ;1268
000078  6801              LDR      r1,[r0,#0]            ;1268
00007a  6002              STR      r2,[r0,#0]            ;1268
00007c  6050              STR      r0,[r2,#4]            ;1268
00007e  6011              STR      r1,[r2,#0]            ;1268
000080  604a              STR      r2,[r1,#4]            ;1268
000082  69a8              LDR      r0,[r5,#0x18]         ;1269  ; RMP_Cur_Thd
000084  69a9              LDR      r1,[r5,#0x18]         ;1269  ; RMP_Cur_Thd
000086  6980              LDR      r0,[r0,#0x18]         ;1269
000088  0a00              LSRS     r0,r0,#8              ;1269
00008a  0200              LSLS     r0,r0,#8              ;1269
00008c  3008              ADDS     r0,r0,#8              ;1269
                  |L15.142|
00008e  6188              STR      r0,[r1,#0x18]         ;1274
000090  69a9              LDR      r1,[r5,#0x18]         ;1274  ; RMP_Cur_Thd
000092  2000              MOVS     r0,#0                 ;1274
000094  6388              STR      r0,[r1,#0x38]         ;1277
000096  f7fffffe          BL       RMP_Unlock_Sched
00009a  69a8              LDR      r0,[r5,#0x18]         ;1279  ; RMP_Cur_Thd
00009c  6b80              LDR      r0,[r0,#0x38]         ;1279
00009e  bdf8              POP      {r3-r7,pc}
                  |L15.160|
0000a0  f7fffffe          BL       RMP_Unlock_Sched
0000a4  2004              MOVS     r0,#4                 ;1259
0000a6  43c0              MVNS     r0,r0                 ;1259
0000a8  bdf8              POP      {r3-r7,pc}
                  |L15.170|
0000aa  69a8              LDR      r0,[r5,#0x18]         ;1272  ; RMP_Cur_Thd
0000ac  69a9              LDR      r1,[r5,#0x18]         ;1272  ; RMP_Cur_Thd
0000ae  6980              LDR      r0,[r0,#0x18]         ;1272
0000b0  0a00              LSRS     r0,r0,#8              ;1272
0000b2  0200              LSLS     r0,r0,#8              ;1272
0000b4  1dc0              ADDS     r0,r0,#7              ;1272
0000b6  e7ea              B        |L15.142|
;;;1281   /* End Function:RMP_Sem_Pend *************************************************/
                          ENDP

                  |L15.184|
                          DCD      0xfffffffa
                  |L15.188|
                          DCD      ||.data||
                  |L15.192|
                          DCD      0x000186a0
                  |L15.196|
                          DCD      ||.data||+0x20

                          AREA ||i.RMP_Sem_Post||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Post PROC
;;;1338   ******************************************************************************/
;;;1339   ret_t RMP_Sem_Post(volatile struct RMP_Sem* Semaphore, ptr_t Number)
000000  b570              PUSH     {r4-r6,lr}
;;;1340   {
;;;1341       struct RMP_Thd* Thread;
;;;1342       
;;;1343       /* Check if this semaphore structure could possibly be in use */
;;;1344       if((Semaphore==0)||(Number==0))
;;;1345           return RMP_ERR_SEM;
000002  4d24              LDR      r5,|L16.148|
000004  0004              MOVS     r4,r0                 ;1340
000006  d00e              BEQ      |L16.38|
000008  2900              CMP      r1,#0                 ;1344
00000a  d00c              BEQ      |L16.38|
00000c  4822              LDR      r0,|L16.152|
00000e  2201              MOVS     r2,#1                 ;1344
000010  60c2              STR      r2,[r0,#0xc]          ;1344  ; RMP_Sched_Locked
000012  6882              LDR      r2,[r0,#8]            ;1344  ; RMP_Sched_Lock_Cnt
000014  1c52              ADDS     r2,r2,#1              ;1344
000016  6082              STR      r2,[r0,#8]            ;1344  ; RMP_Sched_Lock_Cnt
;;;1346       
;;;1347       RMP_Lock_Sched();
;;;1348       
;;;1349       if(Semaphore->State!=RMP_SEM_USED)
000018  68a0              LDR      r0,[r4,#8]
00001a  2801              CMP      r0,#1
00001c  d005              BEQ      |L16.42|
;;;1350       {
;;;1351           RMP_Unlock_Sched();
00001e  f7fffffe          BL       RMP_Unlock_Sched
;;;1352           return RMP_ERR_SEM;
000022  4628              MOV      r0,r5
;;;1353       }
;;;1354       
;;;1355       /* Would the maximum value be exceeded if this is posted? */
;;;1356       if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
;;;1357       {
;;;1358           RMP_Unlock_Sched();
;;;1359           return RMP_ERR_OPER;
;;;1360       }
;;;1361       
;;;1362       Semaphore->Cur_Num+=Number;
;;;1363       /* Is there any thread waiting on it? If there are, clean them up*/
;;;1364       while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
;;;1365       {
;;;1366           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1367           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1368           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1369               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1370           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1371   
;;;1372           /* Only when when this thread is not suspended do we change it back */
;;;1373           if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1374               _RMP_Set_Rdy(Thread);
;;;1375   
;;;1376           /* Finally, return success */
;;;1377           Thread->Retval=0;
;;;1378           Semaphore->Cur_Num--;
;;;1379       }
;;;1380   
;;;1381       RMP_Unlock_Sched();
;;;1382   
;;;1383       return 0;
;;;1384   }
000024  bd70              POP      {r4-r6,pc}
                  |L16.38|
000026  4628              MOV      r0,r5                 ;1345
000028  bd70              POP      {r4-r6,pc}
                  |L16.42|
00002a  68e0              LDR      r0,[r4,#0xc]          ;1356
00002c  227d              MOVS     r2,#0x7d              ;1356
00002e  1840              ADDS     r0,r0,r1              ;1356
000030  00d2              LSLS     r2,r2,#3              ;1356
000032  4290              CMP      r0,r2                 ;1356
000034  d304              BCC      |L16.64|
000036  f7fffffe          BL       RMP_Unlock_Sched
00003a  2004              MOVS     r0,#4                 ;1359
00003c  43c0              MVNS     r0,r0                 ;1359
00003e  bd70              POP      {r4-r6,pc}
                  |L16.64|
000040  68e0              LDR      r0,[r4,#0xc]          ;1362
000042  1840              ADDS     r0,r0,r1              ;1362
000044  60e0              STR      r0,[r4,#0xc]          ;1362
000046  2600              MOVS     r6,#0                 ;1362
000048  e019              B        |L16.126|
                  |L16.74|
00004a  6865              LDR      r5,[r4,#4]            ;1366
00004c  6869              LDR      r1,[r5,#4]            ;1366
00004e  6828              LDR      r0,[r5,#0]            ;1366
000050  6008              STR      r0,[r1,#0]            ;1366
000052  6041              STR      r1,[r0,#4]            ;1366
000054  7e28              LDRB     r0,[r5,#0x18]         ;1368
000056  2808              CMP      r0,#8                 ;1368
000058  d103              BNE      |L16.98|
00005a  68e9              LDR      r1,[r5,#0xc]          ;1368
00005c  68a8              LDR      r0,[r5,#8]            ;1368
00005e  6008              STR      r0,[r1,#0]            ;1368
000060  6041              STR      r1,[r0,#4]            ;1368
                  |L16.98|
000062  69a8              LDR      r0,[r5,#0x18]         ;1370
000064  0a00              LSRS     r0,r0,#8              ;1370
000066  0200              LSLS     r0,r0,#8              ;1370
000068  1c40              ADDS     r0,r0,#1              ;1370
00006a  61a8              STR      r0,[r5,#0x18]         ;1373
00006c  05c0              LSLS     r0,r0,#23             ;1373
00006e  d402              BMI      |L16.118|
000070  4628              MOV      r0,r5                 ;1374
000072  f7fffffe          BL       _RMP_Set_Rdy
                  |L16.118|
000076  63ae              STR      r6,[r5,#0x38]         ;1378
000078  68e0              LDR      r0,[r4,#0xc]          ;1378
00007a  1e40              SUBS     r0,r0,#1              ;1378
00007c  60e0              STR      r0,[r4,#0xc]          ;1378
                  |L16.126|
00007e  6860              LDR      r0,[r4,#4]            ;1364
000080  42a0              CMP      r0,r4                 ;1364
000082  d002              BEQ      |L16.138|
000084  68e0              LDR      r0,[r4,#0xc]          ;1364
000086  2800              CMP      r0,#0                 ;1364
000088  d1df              BNE      |L16.74|
                  |L16.138|
00008a  f7fffffe          BL       RMP_Unlock_Sched
00008e  2000              MOVS     r0,#0                 ;1383
000090  bd70              POP      {r4-r6,pc}
;;;1385   /* End Function:RMP_Sem_Post *************************************************/
                          ENDP

000092  0000              DCW      0x0000
                  |L16.148|
                          DCD      0xfffffffa
                  |L16.152|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Post_ISR||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Post_ISR PROC
;;;1393   ******************************************************************************/
;;;1394   ret_t RMP_Sem_Post_ISR(volatile struct RMP_Sem* Semaphore, ptr_t Number)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1395   {
000002  0004              MOVS     r4,r0
;;;1396       struct RMP_Thd* Thread;
;;;1397       /* Check if this semaphore structure could possibly be in use */
;;;1398       if((Semaphore==0)||(Number==0))
;;;1399           return RMP_ERR_SEM;
000004  481f              LDR      r0,|L17.132|
000006  d03c              BEQ      |L17.130|
000008  2900              CMP      r1,#0                 ;1398
00000a  d03a              BEQ      |L17.130|
;;;1400       
;;;1401       if(Semaphore->State!=RMP_SEM_USED)
00000c  68a2              LDR      r2,[r4,#8]
00000e  2a01              CMP      r2,#1
000010  d137              BNE      |L17.130|
;;;1402           return RMP_ERR_SEM;
;;;1403   
;;;1404       if(RMP_Sched_Locked!=0)
000012  4e1d              LDR      r6,|L17.136|
000014  68f2              LDR      r2,[r6,#0xc]  ; RMP_Sched_Locked
;;;1405           return RMP_ERR_OPER;
000016  1c40              ADDS     r0,r0,#1
000018  2a00              CMP      r2,#0                 ;1404
00001a  d132              BNE      |L17.130|
;;;1406   
;;;1407       /* Would the maximum value be exceeded if this is posted? */
;;;1408       if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
00001c  68e2              LDR      r2,[r4,#0xc]
00001e  237d              MOVS     r3,#0x7d
000020  1852              ADDS     r2,r2,r1
000022  00db              LSLS     r3,r3,#3
000024  429a              CMP      r2,r3
000026  d22c              BCS      |L17.130|
;;;1409           return RMP_ERR_OPER;
;;;1410       
;;;1411       Semaphore->Cur_Num+=Number;
000028  68e0              LDR      r0,[r4,#0xc]
00002a  1840              ADDS     r0,r0,r1
00002c  60e0              STR      r0,[r4,#0xc]
00002e  2700              MOVS     r7,#0
;;;1412       /* Is there any thread waiting on it? If there are, clean them up*/
;;;1413       while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
000030  e020              B        |L17.116|
                  |L17.50|
;;;1414       {
;;;1415           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
000032  6865              LDR      r5,[r4,#4]
000034  6869              LDR      r1,[r5,#4]
000036  6828              LDR      r0,[r5,#0]
000038  6008              STR      r0,[r1,#0]
00003a  6041              STR      r1,[r0,#4]
;;;1416           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1417           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
00003c  7e28              LDRB     r0,[r5,#0x18]
00003e  2808              CMP      r0,#8
000040  d103              BNE      |L17.74|
000042  68e9              LDR      r1,[r5,#0xc]
000044  68a8              LDR      r0,[r5,#8]
000046  6008              STR      r0,[r1,#0]
000048  6041              STR      r1,[r0,#4]
                  |L17.74|
;;;1418               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1419           
;;;1420           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
00004a  69a8              LDR      r0,[r5,#0x18]
00004c  0a00              LSRS     r0,r0,#8
00004e  0200              LSLS     r0,r0,#8
000050  1c40              ADDS     r0,r0,#1
;;;1421   
;;;1422           /* Only when when this thread is not suspended do we change it back */
;;;1423           if((Thread->State&RMP_THD_SUSPENDED)==0)
000052  61a8              STR      r0,[r5,#0x18]
000054  05c0              LSLS     r0,r0,#23
000056  d409              BMI      |L17.108|
;;;1424           {
;;;1425               _RMP_Set_Rdy(Thread);
000058  4628              MOV      r0,r5
00005a  f7fffffe          BL       _RMP_Set_Rdy
;;;1426               if(Thread->Prio>RMP_Cur_Thd->Prio)
00005e  6a68              LDR      r0,[r5,#0x24]
000060  69b1              LDR      r1,[r6,#0x18]  ; RMP_Cur_Thd
000062  6a49              LDR      r1,[r1,#0x24]
000064  4288              CMP      r0,r1
000066  d901              BLS      |L17.108|
;;;1427                   _RMP_Yield();
000068  f7fffffe          BL       _RMP_Yield
                  |L17.108|
;;;1428           }
;;;1429   
;;;1430           /* Finally, return success */
;;;1431           Thread->Retval=0;
;;;1432           Semaphore->Cur_Num--;
00006c  63af              STR      r7,[r5,#0x38]
00006e  68e0              LDR      r0,[r4,#0xc]
000070  1e40              SUBS     r0,r0,#1
000072  60e0              STR      r0,[r4,#0xc]
                  |L17.116|
000074  6860              LDR      r0,[r4,#4]            ;1413
000076  42a0              CMP      r0,r4                 ;1413
000078  d002              BEQ      |L17.128|
00007a  68e0              LDR      r0,[r4,#0xc]          ;1413
00007c  2800              CMP      r0,#0                 ;1413
00007e  d1d8              BNE      |L17.50|
                  |L17.128|
;;;1433       }
;;;1434   
;;;1435       return 0;
000080  2000              MOVS     r0,#0
                  |L17.130|
;;;1436   }
000082  bdf8              POP      {r3-r7,pc}
;;;1437   /* End Function:RMP_Sem_Post_ISR *********************************************/
                          ENDP

                  |L17.132|
                          DCD      0xfffffffa
                  |L17.136|
                          DCD      ||.data||

                          AREA ||i.RMP_Start_Hook||, CODE, READONLY, ALIGN=1

                  RMP_Start_Hook PROC
;;;1446   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1447   void RMP_Start_Hook(void)
000000  4770              BX       lr
;;;1448   {
;;;1449       return;
;;;1450   }
;;;1451   #endif
                          ENDP


                          AREA ||i.RMP_Thd_Cancel||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Cancel PROC
;;;1108   ******************************************************************************/
;;;1109   ret_t RMP_Thd_Cancel(volatile struct RMP_Thd* Thread)
000000  2800              CMP      r0,#0
;;;1110   {
;;;1111       /* Check if this thread structure could possibly be in use */
;;;1112       if(Thread==0)
000002  d101              BNE      |L19.8|
;;;1113           return RMP_ERR_THD;
000004  1e40              SUBS     r0,r0,#1
;;;1114       
;;;1115       RMP_Lock_Sched();
;;;1116       
;;;1117       /* Is it delayed? */
;;;1118       if(RMP_THD_STATE(Thread->State)!=RMP_THD_DELAYED)
;;;1119       {
;;;1120           RMP_Unlock_Sched();
;;;1121           return RMP_ERR_STATE;
;;;1122       }
;;;1123   
;;;1124       /* Delete it from the delay list */
;;;1125       RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1126       RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1127       
;;;1128       /* Only when when this thread is not suspended do we change it back */
;;;1129       if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1130           _RMP_Set_Rdy(Thread);
;;;1131       
;;;1132       Thread->Retval=RMP_ERR_OPER;
;;;1133       
;;;1134       RMP_Unlock_Sched();
;;;1135   
;;;1136       return 0;
;;;1137   }
000006  4770              BX       lr
                  |L19.8|
000008  b510              PUSH     {r4,lr}               ;1110
00000a  4604              MOV      r4,r0                 ;1110
00000c  4812              LDR      r0,|L19.88|
00000e  2101              MOVS     r1,#1                 ;1110
000010  60c1              STR      r1,[r0,#0xc]          ;1110  ; RMP_Sched_Locked
000012  6881              LDR      r1,[r0,#8]            ;1110  ; RMP_Sched_Lock_Cnt
000014  1c49              ADDS     r1,r1,#1              ;1110
000016  6081              STR      r1,[r0,#8]            ;1110  ; RMP_Sched_Lock_Cnt
000018  69a0              LDR      r0,[r4,#0x18]         ;1118
00001a  b2c0              UXTB     r0,r0                 ;1118
00001c  2806              CMP      r0,#6                 ;1118
00001e  d004              BEQ      |L19.42|
000020  f7fffffe          BL       RMP_Unlock_Sched
000024  2003              MOVS     r0,#3                 ;1121
000026  43c0              MVNS     r0,r0                 ;1121
000028  bd10              POP      {r4,pc}
                  |L19.42|
00002a  68a1              LDR      r1,[r4,#8]            ;1125
00002c  68e0              LDR      r0,[r4,#0xc]          ;1125
00002e  6001              STR      r1,[r0,#0]            ;1125
000030  6048              STR      r0,[r1,#4]            ;1125
000032  69a0              LDR      r0,[r4,#0x18]         ;1126
000034  0a00              LSRS     r0,r0,#8              ;1126
000036  0200              LSLS     r0,r0,#8              ;1126
000038  1c40              ADDS     r0,r0,#1              ;1126
00003a  61a0              STR      r0,[r4,#0x18]         ;1126
00003c  69a0              LDR      r0,[r4,#0x18]         ;1129
00003e  05c0              LSLS     r0,r0,#23             ;1129
000040  d402              BMI      |L19.72|
000042  4620              MOV      r0,r4                 ;1130
000044  f7fffffe          BL       _RMP_Set_Rdy
                  |L19.72|
000048  2004              MOVS     r0,#4                 ;1132
00004a  43c0              MVNS     r0,r0                 ;1132
00004c  63a0              STR      r0,[r4,#0x38]         ;1132
00004e  f7fffffe          BL       RMP_Unlock_Sched
000052  2000              MOVS     r0,#0                 ;1136
000054  bd10              POP      {r4,pc}
;;;1138   /* End Function:RMP_Thd_Cancel ***********************************************/
                          ENDP

000056  0000              DCW      0x0000
                  |L19.88|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Crt||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Crt PROC
;;;588    ******************************************************************************/
;;;589    ret_t RMP_Thd_Crt(volatile struct RMP_Thd* Thread, void* Entry, void* Stack, void* Arg, ptr_t Prio, ptr_t Slices)
000000  b5f8              PUSH     {r3-r7,lr}
;;;590    {
000002  4615              MOV      r5,r2
000004  4604              MOV      r4,r0
;;;591        /* Check if the priority and timeslice range is correct */
;;;592        if(Prio>=RMP_MAX_PREEMPT_PRIO)
000006  9a06              LDR      r2,[sp,#0x18]
000008  9807              LDR      r0,[sp,#0x1c]
00000a  469c              MOV      r12,r3                ;590
00000c  468e              MOV      lr,r1                 ;590
00000e  2a20              CMP      r2,#0x20
000010  d302              BCC      |L20.24|
;;;593            return RMP_ERR_PRIO;
000012  2001              MOVS     r0,#1
000014  43c0              MVNS     r0,r0
;;;594        if((Slices==0)||(Slices>=RMP_MAX_SLICES))
;;;595            return RMP_ERR_SLICE;
;;;596        
;;;597        /* Check if this thread structure could possibly be in use */
;;;598        if(Thread==0)
;;;599            return RMP_ERR_THD;
;;;600        
;;;601        RMP_Lock_Sched();
;;;602        
;;;603        if(RMP_THD_STATE(Thread->State)!=RMP_THD_FREE)
;;;604        {
;;;605            RMP_Unlock_Sched();
;;;606            return RMP_ERR_THD;
;;;607        }
;;;608        
;;;609        /* Create the thread and insert it into the list */
;;;610        Thread->Prio=Prio;
;;;611        Thread->Slices=Slices;
;;;612        Thread->Slices_Left=Slices;
;;;613        Thread->Stack=(ptr_t)Stack;
;;;614        
;;;615        /* Initialize its stack and sending list */
;;;616        _RMP_Stack_Init((ptr_t)Entry, (ptr_t)Stack, (ptr_t)Arg);
;;;617        RMP_List_Crt(&(Thread->Snd_List));
;;;618        
;;;619        /* Notify the scheduler that we have created something new, also check locks */
;;;620        Thread->State=RMP_THD_RUNNING;
;;;621        _RMP_Set_Rdy(Thread);
;;;622        
;;;623        RMP_Unlock_Sched();
;;;624    
;;;625        return 0;
;;;626    }
000016  bdf8              POP      {r3-r7,pc}
                  |L20.24|
000018  2800              CMP      r0,#0                 ;594
00001a  d002              BEQ      |L20.34|
00001c  4917              LDR      r1,|L20.124|
00001e  4288              CMP      r0,r1                 ;594
000020  d302              BCC      |L20.40|
                  |L20.34|
000022  2002              MOVS     r0,#2                 ;595
000024  43c0              MVNS     r0,r0                 ;595
000026  bdf8              POP      {r3-r7,pc}
                  |L20.40|
000028  2700              MOVS     r7,#0                 ;599
00002a  43ff              MVNS     r7,r7                 ;599
00002c  2c00              CMP      r4,#0                 ;598
00002e  d00d              BEQ      |L20.76|
000030  4913              LDR      r1,|L20.128|
000032  2601              MOVS     r6,#1                 ;598
000034  60ce              STR      r6,[r1,#0xc]          ;598  ; RMP_Sched_Locked
000036  688b              LDR      r3,[r1,#8]            ;598  ; RMP_Sched_Lock_Cnt
000038  1c5b              ADDS     r3,r3,#1              ;598
00003a  608b              STR      r3,[r1,#8]            ;598  ; RMP_Sched_Lock_Cnt
00003c  69a1              LDR      r1,[r4,#0x18]         ;603
00003e  0609              LSLS     r1,r1,#24             ;603
000040  0e09              LSRS     r1,r1,#24             ;603
000042  d005              BEQ      |L20.80|
000044  f7fffffe          BL       RMP_Unlock_Sched
000048  4638              MOV      r0,r7                 ;606
00004a  bdf8              POP      {r3-r7,pc}
                  |L20.76|
00004c  4638              MOV      r0,r7                 ;599
00004e  bdf8              POP      {r3-r7,pc}
                  |L20.80|
000050  6262              STR      r2,[r4,#0x24]         ;610
000052  61e0              STR      r0,[r4,#0x1c]         ;611
000054  6220              STR      r0,[r4,#0x20]         ;612
000056  6365              STR      r5,[r4,#0x34]         ;613
000058  4662              MOV      r2,r12                ;616
00005a  4629              MOV      r1,r5                 ;616
00005c  4670              MOV      r0,lr                 ;616
00005e  f7fffffe          BL       _RMP_Stack_Init
000062  4620              MOV      r0,r4                 ;617
000064  3010              ADDS     r0,r0,#0x10           ;617
000066  6120              STR      r0,[r4,#0x10]         ;617
000068  6160              STR      r0,[r4,#0x14]         ;617
00006a  61a6              STR      r6,[r4,#0x18]         ;620
00006c  4620              MOV      r0,r4                 ;621
00006e  f7fffffe          BL       _RMP_Set_Rdy
000072  f7fffffe          BL       RMP_Unlock_Sched
000076  2000              MOVS     r0,#0                 ;625
000078  bdf8              POP      {r3-r7,pc}
;;;627    /* End Function:RMP_Thd_Crt **************************************************/
                          ENDP

00007a  0000              DCW      0x0000
                  |L20.124|
                          DCD      0x000186a0
                  |L20.128|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Del||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Del PROC
;;;634    ******************************************************************************/
;;;635    ret_t RMP_Thd_Del(volatile struct RMP_Thd* Thread)
000000  b5f8              PUSH     {r3-r7,lr}
;;;636    {
;;;637        struct RMP_Thd* Release;
;;;638        ptr_t Self_Del;
;;;639        
;;;640        /* Check if this thread structure could possibly be in use */
;;;641        if(Thread==0)
;;;642            return RMP_ERR_THD;
000002  4d37              LDR      r5,|L21.224|
000004  0004              MOVS     r4,r0                 ;636
000006  d018              BEQ      |L21.58|
000008  4836              LDR      r0,|L21.228|
00000a  2101              MOVS     r1,#1                 ;636
00000c  60c1              STR      r1,[r0,#0xc]          ;636  ; RMP_Sched_Locked
00000e  6881              LDR      r1,[r0,#8]            ;636  ; RMP_Sched_Lock_Cnt
000010  1c49              ADDS     r1,r1,#1              ;636
000012  6081              STR      r1,[r0,#8]            ;636  ; RMP_Sched_Lock_Cnt
;;;643        
;;;644        RMP_Lock_Sched();
;;;645        
;;;646        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
000014  69a0              LDR      r0,[r4,#0x18]
000016  0600              LSLS     r0,r0,#24
000018  0e00              LSRS     r0,r0,#24
00001a  d010              BEQ      |L21.62|
;;;647        {
;;;648            RMP_Unlock_Sched();
;;;649            return RMP_ERR_THD;
;;;650        }
;;;651        
;;;652        /* See if anyone waiting to send to this thread. If there is, release all these threads */
;;;653        while(&(Thread->Snd_List)!=Thread->Snd_List.Next)
00001c  6960              LDR      r0,[r4,#0x14]
00001e  4627              MOV      r7,r4
000020  3710              ADDS     r7,r7,#0x10
;;;654        {
;;;655            Release=(struct RMP_Thd*)(Thread->Snd_List.Next);
;;;656            RMP_List_Del(Release->Run_Head.Prev,Release->Run_Head.Next);
;;;657            if(RMP_THD_STATE(Release->State)==RMP_THD_SNDDLY)
;;;658                RMP_List_Del(Release->Dly_Head.Prev,Release->Dly_Head.Next);
;;;659    
;;;660            RMP_THD_STATE_SET(Release->State,RMP_THD_RUNNING);
;;;661    
;;;662            /* Is it suspended? If yes, we can't directly send it running */
;;;663            if((Release->State&RMP_THD_SUSPENDED)==0)
;;;664               _RMP_Set_Rdy(Release);
;;;665            
;;;666            Release->Retval=RMP_ERR_OPER;
000022  1f2e              SUBS     r6,r5,#4
000024  42b8              CMP      r0,r7                 ;653
000026  d020              BEQ      |L21.106|
                  |L21.40|
000028  6965              LDR      r5,[r4,#0x14]         ;655
00002a  6869              LDR      r1,[r5,#4]            ;655
00002c  6828              LDR      r0,[r5,#0]            ;655
00002e  6008              STR      r0,[r1,#0]            ;655
000030  6041              STR      r1,[r0,#4]            ;655
000032  7e28              LDRB     r0,[r5,#0x18]         ;657
000034  2803              CMP      r0,#3                 ;657
000036  d006              BEQ      |L21.70|
000038  e009              B        |L21.78|
                  |L21.58|
00003a  4628              MOV      r0,r5                 ;642
;;;667        }
;;;668        
;;;669        /* See what is it state */
;;;670        Self_Del=0;
;;;671        if(RMP_Cur_Thd==Thread)
;;;672            Self_Del=1;
;;;673        
;;;674        switch(RMP_THD_STATE(Thread->State))
;;;675        {
;;;676            case RMP_THD_RUNNING:
;;;677            {
;;;678                if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;679                    _RMP_Clr_Rdy(Thread);
;;;680                break;
;;;681            }
;;;682            
;;;683            case RMP_THD_SNDDLY:
;;;684            case RMP_THD_SEMDLY:
;;;685            {
;;;686                if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;687                    RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;688                RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;689                Thread->Retval=RMP_ERR_OPER;
;;;690                break;
;;;691            }
;;;692                
;;;693            case RMP_THD_RCVDLY:
;;;694            {
;;;695                RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;696                Thread->Retval=RMP_ERR_OPER;
;;;697                break;
;;;698            }
;;;699                
;;;700            case RMP_THD_DELAYED:
;;;701            {
;;;702                RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;703                Thread->Retval=RMP_ERR_OPER;
;;;704                break;
;;;705            }
;;;706            /* Should not get here */
;;;707            default:break;
;;;708        }
;;;709        Thread->State=RMP_THD_FREE;
;;;710        
;;;711        RMP_Unlock_Sched();
;;;712        
;;;713        /* If we are deleting ourself, just stop the execution here */
;;;714        if(Self_Del!=0)
;;;715            while(1);
;;;716    
;;;717        return 0;
;;;718    }
00003c  bdf8              POP      {r3-r7,pc}
                  |L21.62|
00003e  f7fffffe          BL       RMP_Unlock_Sched
000042  4628              MOV      r0,r5                 ;649
000044  bdf8              POP      {r3-r7,pc}
                  |L21.70|
000046  68e9              LDR      r1,[r5,#0xc]
000048  68a8              LDR      r0,[r5,#8]
00004a  6008              STR      r0,[r1,#0]
00004c  6041              STR      r1,[r0,#4]
                  |L21.78|
00004e  69a8              LDR      r0,[r5,#0x18]         ;660
000050  0a00              LSRS     r0,r0,#8              ;660
000052  0200              LSLS     r0,r0,#8              ;660
000054  1c40              ADDS     r0,r0,#1              ;660
000056  61a8              STR      r0,[r5,#0x18]         ;663
000058  05c0              LSLS     r0,r0,#23             ;663
00005a  d402              BMI      |L21.98|
00005c  4628              MOV      r0,r5                 ;664
00005e  f7fffffe          BL       _RMP_Set_Rdy
                  |L21.98|
000062  63ae              STR      r6,[r5,#0x38]         ;653
000064  6960              LDR      r0,[r4,#0x14]         ;653
000066  42b8              CMP      r0,r7                 ;653
000068  d1de              BNE      |L21.40|
                  |L21.106|
00006a  481e              LDR      r0,|L21.228|
00006c  2500              MOVS     r5,#0                 ;670
00006e  6980              LDR      r0,[r0,#0x18]         ;671  ; RMP_Cur_Thd
000070  42a0              CMP      r0,r4                 ;671
000072  d100              BNE      |L21.118|
000074  2501              MOVS     r5,#1                 ;672
                  |L21.118|
000076  69a0              LDR      r0,[r4,#0x18]         ;674
000078  b2c0              UXTB     r0,r0                 ;674
00007a  2809              CMP      r0,#9                 ;674
00007c  d227              BCS      |L21.206|
00007e  0001              MOVS     r1,r0                 ;674
000080  4479              ADD      r1,r1,pc              ;674
000082  7909              LDRB     r1,[r1,#4]            ;674
000084  1849              ADDS     r1,r1,r1              ;674
000086  448f              ADD      pc,pc,r1              ;674
000088  2204220b          DCB      0x22,0x04,0x22,0x0b
00008c  22181d22          DCB      0x22,0x18,0x1d,0x22
000090  0b00              DCB      0x0b,0x00
000092  69a0              LDR      r0,[r4,#0x18]         ;678
000094  05c0              LSLS     r0,r0,#23             ;678
000096  d41a              BMI      |L21.206|
000098  4620              MOV      r0,r4                 ;679
00009a  f7fffffe          BL       _RMP_Clr_Rdy
00009e  e016              B        |L21.206|
0000a0  69a0              LDR      r0,[r4,#0x18]         ;686
0000a2  05c0              LSLS     r0,r0,#23             ;686
0000a4  d403              BMI      |L21.174|
0000a6  6821              LDR      r1,[r4,#0]            ;687
0000a8  6860              LDR      r0,[r4,#4]            ;687
0000aa  6001              STR      r1,[r0,#0]            ;687
0000ac  6048              STR      r0,[r1,#4]            ;687
                  |L21.174|
0000ae  68a0              LDR      r0,[r4,#8]            ;688
0000b0  68e1              LDR      r1,[r4,#0xc]          ;688
0000b2  6008              STR      r0,[r1,#0]            ;688
0000b4  6041              STR      r1,[r0,#4]            ;688
                  |L21.182|
0000b6  63a6              STR      r6,[r4,#0x38]         ;689
0000b8  e009              B        |L21.206|
0000ba  68a1              LDR      r1,[r4,#8]            ;695
0000bc  68e0              LDR      r0,[r4,#0xc]          ;695
0000be  6001              STR      r1,[r0,#0]            ;695
0000c0  6048              STR      r0,[r1,#4]            ;695
0000c2  e7f8              B        |L21.182|
0000c4  68a1              LDR      r1,[r4,#8]            ;702
0000c6  68e0              LDR      r0,[r4,#0xc]          ;702
0000c8  6001              STR      r1,[r0,#0]            ;702
0000ca  6048              STR      r0,[r1,#4]            ;702
0000cc  63a6              STR      r6,[r4,#0x38]         ;703
                  |L21.206|
0000ce  2000              MOVS     r0,#0                 ;709
0000d0  61a0              STR      r0,[r4,#0x18]         ;709
0000d2  f7fffffe          BL       RMP_Unlock_Sched
0000d6  2d00              CMP      r5,#0                 ;714
0000d8  d000              BEQ      |L21.220|
                  |L21.218|
0000da  e7fe              B        |L21.218|
                  |L21.220|
0000dc  2000              MOVS     r0,#0                 ;717
0000de  bdf8              POP      {r3-r7,pc}
;;;719    /* End Function:RMP_Thd_Del **************************************************/
                          ENDP

                  |L21.224|
                          DCD      0xffffffff
                  |L21.228|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Delay||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Delay PROC
;;;1081   ******************************************************************************/
;;;1082   ret_t RMP_Thd_Delay(ptr_t Slices)
000000  b570              PUSH     {r4-r6,lr}
;;;1083   {
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L22.12|
;;;1084       if((Slices==0)||(Slices>=RMP_MAX_SLICES))
000006  4819              LDR      r0,|L22.108|
000008  4284              CMP      r4,r0
00000a  d302              BCC      |L22.18|
                  |L22.12|
;;;1085           return RMP_ERR_SLICE;
00000c  2002              MOVS     r0,#2
00000e  43c0              MVNS     r0,r0
;;;1086       
;;;1087       RMP_Lock_Sched();
;;;1088   
;;;1089       /* We must be running */
;;;1090       _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1091       RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_DELAYED);
;;;1092       _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1093   
;;;1094       RMP_Cur_Thd->Retval=0;
;;;1095       
;;;1096       RMP_Unlock_Sched();
;;;1097       
;;;1098       /* Need to return if successful or not */
;;;1099       return RMP_Cur_Thd->Retval;
;;;1100   }
000010  bd70              POP      {r4-r6,pc}
                  |L22.18|
000012  4d17              LDR      r5,|L22.112|
000014  2001              MOVS     r0,#1
000016  60e8              STR      r0,[r5,#0xc]  ; RMP_Sched_Locked
000018  68a8              LDR      r0,[r5,#8]  ; RMP_Sched_Lock_Cnt
00001a  1c40              ADDS     r0,r0,#1
00001c  60a8              STR      r0,[r5,#8]  ; RMP_Sched_Lock_Cnt
00001e  69a8              LDR      r0,[r5,#0x18]         ;1090  ; RMP_Cur_Thd
000020  f7fffffe          BL       _RMP_Clr_Rdy
000024  69a8              LDR      r0,[r5,#0x18]         ;1091  ; RMP_Cur_Thd
000026  69a9              LDR      r1,[r5,#0x18]         ;1091  ; RMP_Cur_Thd
000028  6980              LDR      r0,[r0,#0x18]         ;1091
00002a  0a00              LSRS     r0,r0,#8              ;1091
00002c  0200              LSLS     r0,r0,#8              ;1091
00002e  1d80              ADDS     r0,r0,#6              ;1091
000030  6188              STR      r0,[r1,#0x18]         ;1092
000032  69aa              LDR      r2,[r5,#0x18]         ;1092  ; RMP_Cur_Thd
000034  480f              LDR      r0,|L22.116|
000036  6841              LDR      r1,[r0,#4]            ;1092  ; RMP_Delay
000038  4281              CMP      r1,r0                 ;1092
00003a  d006              BEQ      |L22.74|
00003c  6a0b              LDR      r3,[r1,#0x20]         ;1092
                  |L22.62|
00003e  686e              LDR      r6,[r5,#4]            ;1092  ; RMP_Tick
000040  1b9e              SUBS     r6,r3,r6              ;1092
000042  42a6              CMP      r6,r4                 ;1092
000044  d801              BHI      |L22.74|
000046  4281              CMP      r1,r0                 ;1092
000048  d1f9              BNE      |L22.62|
                  |L22.74|
00004a  6868              LDR      r0,[r5,#4]            ;1092  ; RMP_Tick
00004c  1900              ADDS     r0,r0,r4              ;1092
00004e  6290              STR      r0,[r2,#0x28]         ;1092
000050  3208              ADDS     r2,r2,#8              ;1092
000052  6808              LDR      r0,[r1,#0]            ;1092
000054  600a              STR      r2,[r1,#0]            ;1092
000056  6051              STR      r1,[r2,#4]            ;1092
000058  6010              STR      r0,[r2,#0]            ;1092
00005a  6042              STR      r2,[r0,#4]            ;1092
00005c  69a9              LDR      r1,[r5,#0x18]         ;1094  ; RMP_Cur_Thd
00005e  2000              MOVS     r0,#0                 ;1094
000060  6388              STR      r0,[r1,#0x38]         ;1096
000062  f7fffffe          BL       RMP_Unlock_Sched
000066  69a8              LDR      r0,[r5,#0x18]         ;1099  ; RMP_Cur_Thd
000068  6b80              LDR      r0,[r0,#0x38]         ;1099
00006a  bd70              POP      {r4-r6,pc}
;;;1101   /* End Function:RMP_Thd_Delay ************************************************/
                          ENDP

                  |L22.108|
                          DCD      0x000186a0
                  |L22.112|
                          DCD      ||.data||
                  |L22.116|
                          DCD      ||.data||+0x20

                          AREA ||i.RMP_Thd_Rcv||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Rcv PROC
;;;1002   ******************************************************************************/
;;;1003   ret_t RMP_Thd_Rcv(ptr_t* Data, ptr_t Slices)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1004   {
000002  4606              MOV      r6,r0
000004  4c3f              LDR      r4,|L23.260|
000006  2001              MOVS     r0,#1
000008  460d              MOV      r5,r1
00000a  60e0              STR      r0,[r4,#0xc]  ; RMP_Sched_Locked
00000c  68a0              LDR      r0,[r4,#8]  ; RMP_Sched_Lock_Cnt
00000e  1c40              ADDS     r0,r0,#1
000010  60a0              STR      r0,[r4,#8]  ; RMP_Sched_Lock_Cnt
;;;1005       struct RMP_Thd* Sender;
;;;1006       
;;;1007       RMP_Lock_Sched();
;;;1008   
;;;1009       /* Check if there is a value in our mailbox. If yes, we return with that value */
;;;1010       if((RMP_Cur_Thd->State&RMP_THD_MBOXFUL)!=0)
000012  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
000014  8b00              LDRH     r0,[r0,#0x18]
000016  0580              LSLS     r0,r0,#22
;;;1011       {
;;;1012           /* Get the value from mailbox */
;;;1013           *Data=RMP_Cur_Thd->Mailbox;
;;;1014           RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
;;;1015           RMP_Unlock_Sched();
;;;1016           return 0;
;;;1017       }
;;;1018       else
;;;1019       {
;;;1020           /* Is there any other guy waiting on us? If there is, unblock it and set it running */
;;;1021           if(&(RMP_Cur_Thd->Snd_List)!=RMP_Cur_Thd->Snd_List.Next)
000018  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
00001a  d50b              BPL      |L23.52|
00001c  6ac0              LDR      r0,[r0,#0x2c]         ;1013
00001e  6030              STR      r0,[r6,#0]            ;1014
000020  69a0              LDR      r0,[r4,#0x18]         ;1014  ; RMP_Cur_Thd
000022  2101              MOVS     r1,#1                 ;1014
000024  6982              LDR      r2,[r0,#0x18]         ;1014
000026  0249              LSLS     r1,r1,#9              ;1014
000028  438a              BICS     r2,r2,r1              ;1014
00002a  6182              STR      r2,[r0,#0x18]         ;1015
00002c  f7fffffe          BL       RMP_Unlock_Sched
000030  2000              MOVS     r0,#0                 ;1016
;;;1022           {
;;;1023               /* Read the data */
;;;1024               Sender=(struct RMP_Thd*)(RMP_Cur_Thd->Snd_List.Next);
;;;1025               RMP_List_Del(Sender->Run_Head.Prev,Sender->Run_Head.Next);
;;;1026               *Data=Sender->Data;
;;;1027               /* Now we unblock it - what state is it in? */
;;;1028               if((RMP_THD_STATE(Sender->State)==RMP_THD_SNDDLY))
;;;1029                   RMP_List_Del(Sender->Dly_Head.Prev,Sender->Dly_Head.Next);
;;;1030               
;;;1031               RMP_THD_STATE_SET(Sender->State,RMP_THD_RUNNING);
;;;1032   
;;;1033               /* Is it suspended? If yes, we can't directly send it running */
;;;1034               if((Sender->State&RMP_THD_SUSPENDED)==0)
;;;1035                   _RMP_Set_Rdy(Sender);
;;;1036               
;;;1037               RMP_Unlock_Sched();
;;;1038           }
;;;1039           /* No sender waiting on us, we need to block */
;;;1040           else
;;;1041           {
;;;1042               /* No such value in our mailbox, we need to block */
;;;1043               if(Slices==0)
;;;1044               {
;;;1045                   RMP_Unlock_Sched();
;;;1046                   return RMP_ERR_OPER;
;;;1047               }
;;;1048   
;;;1049               /* We must be running */
;;;1050               _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1051   
;;;1052               if(Slices<RMP_MAX_SLICES)
;;;1053               {
;;;1054                   _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1055                   RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVDLY);
;;;1056               }
;;;1057               else
;;;1058                   RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVBLK);
;;;1059               
;;;1060               RMP_Unlock_Sched();
;;;1061               /* Dummy read - to separate the lock & unlock. If the compiler optimizes these two
;;;1062                * functions(inline them) on some architectures sometimes we never block. */
;;;1063               *Data=RMP_Cur_Thd->Mailbox;
;;;1064               /* We've been unblocked. There must be something in our mbox, or we should have failed */
;;;1065               RMP_Lock_Sched();
;;;1066               *Data=RMP_Cur_Thd->Mailbox;
;;;1067               RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
;;;1068               RMP_Unlock_Sched();
;;;1069           }
;;;1070       }
;;;1071       
;;;1072       return RMP_Cur_Thd->Retval;
;;;1073   }
000032  bdf8              POP      {r3-r7,pc}
                  |L23.52|
000034  6941              LDR      r1,[r0,#0x14]         ;1021
000036  69a0              LDR      r0,[r4,#0x18]         ;1021  ; RMP_Cur_Thd
000038  3010              ADDS     r0,r0,#0x10           ;1021
00003a  4281              CMP      r1,r0                 ;1021
00003c  d01a              BEQ      |L23.116|
00003e  69a0              LDR      r0,[r4,#0x18]         ;1024  ; RMP_Cur_Thd
000040  6940              LDR      r0,[r0,#0x14]         ;1024
000042  6842              LDR      r2,[r0,#4]            ;1024
000044  6801              LDR      r1,[r0,#0]            ;1024
000046  6011              STR      r1,[r2,#0]            ;1024
000048  604a              STR      r2,[r1,#4]            ;1024
00004a  6b01              LDR      r1,[r0,#0x30]         ;1026
00004c  6031              STR      r1,[r6,#0]            ;1028
00004e  7e01              LDRB     r1,[r0,#0x18]         ;1028
000050  2903              CMP      r1,#3                 ;1028
000052  d103              BNE      |L23.92|
000054  68c2              LDR      r2,[r0,#0xc]          ;1028
000056  6881              LDR      r1,[r0,#8]            ;1028
000058  6011              STR      r1,[r2,#0]            ;1028
00005a  604a              STR      r2,[r1,#4]            ;1028
                  |L23.92|
00005c  6981              LDR      r1,[r0,#0x18]         ;1031
00005e  0a09              LSRS     r1,r1,#8              ;1031
000060  0209              LSLS     r1,r1,#8              ;1031
000062  1c49              ADDS     r1,r1,#1              ;1031
000064  6181              STR      r1,[r0,#0x18]         ;1034
000066  05c9              LSLS     r1,r1,#23             ;1034
000068  d401              BMI      |L23.110|
00006a  f7fffffe          BL       _RMP_Set_Rdy
                  |L23.110|
00006e  f7fffffe          BL       RMP_Unlock_Sched
000072  e038              B        |L23.230|
                  |L23.116|
000074  2d00              CMP      r5,#0                 ;1043
000076  d039              BEQ      |L23.236|
000078  69a0              LDR      r0,[r4,#0x18]         ;1050  ; RMP_Cur_Thd
00007a  f7fffffe          BL       _RMP_Clr_Rdy
00007e  4822              LDR      r0,|L23.264|
000080  4285              CMP      r5,r0                 ;1052
000082  d238              BCS      |L23.246|
000084  69a2              LDR      r2,[r4,#0x18]         ;1054  ; RMP_Cur_Thd
000086  4921              LDR      r1,|L23.268|
000088  6848              LDR      r0,[r1,#4]            ;1054  ; RMP_Delay
00008a  4288              CMP      r0,r1                 ;1054
00008c  d006              BEQ      |L23.156|
00008e  6a03              LDR      r3,[r0,#0x20]         ;1054
                  |L23.144|
000090  6867              LDR      r7,[r4,#4]            ;1054  ; RMP_Tick
000092  1bdf              SUBS     r7,r3,r7              ;1054
000094  42af              CMP      r7,r5                 ;1054
000096  d801              BHI      |L23.156|
000098  4288              CMP      r0,r1                 ;1054
00009a  d1f9              BNE      |L23.144|
                  |L23.156|
00009c  6861              LDR      r1,[r4,#4]            ;1054  ; RMP_Tick
00009e  1949              ADDS     r1,r1,r5              ;1054
0000a0  6291              STR      r1,[r2,#0x28]         ;1054
0000a2  3208              ADDS     r2,r2,#8              ;1054
0000a4  6801              LDR      r1,[r0,#0]            ;1054
0000a6  6002              STR      r2,[r0,#0]            ;1054
0000a8  6050              STR      r0,[r2,#4]            ;1054
0000aa  6011              STR      r1,[r2,#0]            ;1054
0000ac  604a              STR      r2,[r1,#4]            ;1054
0000ae  69a0              LDR      r0,[r4,#0x18]         ;1055  ; RMP_Cur_Thd
0000b0  69a1              LDR      r1,[r4,#0x18]         ;1055  ; RMP_Cur_Thd
0000b2  6980              LDR      r0,[r0,#0x18]         ;1055
0000b4  0a00              LSRS     r0,r0,#8              ;1055
0000b6  0200              LSLS     r0,r0,#8              ;1055
0000b8  1d40              ADDS     r0,r0,#5              ;1055
                  |L23.186|
0000ba  6188              STR      r0,[r1,#0x18]         ;1060
0000bc  f7fffffe          BL       RMP_Unlock_Sched
0000c0  69a0              LDR      r0,[r4,#0x18]         ;1063  ; RMP_Cur_Thd
0000c2  6ac0              LDR      r0,[r0,#0x2c]         ;1063
0000c4  6030              STR      r0,[r6,#0]            ;1063
0000c6  2001              MOVS     r0,#1                 ;1063
0000c8  60e0              STR      r0,[r4,#0xc]          ;1063  ; RMP_Sched_Locked
0000ca  68a0              LDR      r0,[r4,#8]            ;1063  ; RMP_Sched_Lock_Cnt
0000cc  1c40              ADDS     r0,r0,#1              ;1063
0000ce  60a0              STR      r0,[r4,#8]            ;1063  ; RMP_Sched_Lock_Cnt
0000d0  69a0              LDR      r0,[r4,#0x18]         ;1066  ; RMP_Cur_Thd
0000d2  6ac0              LDR      r0,[r0,#0x2c]         ;1066
0000d4  6030              STR      r0,[r6,#0]            ;1067
0000d6  69a0              LDR      r0,[r4,#0x18]         ;1067  ; RMP_Cur_Thd
0000d8  2201              MOVS     r2,#1                 ;1067
0000da  6981              LDR      r1,[r0,#0x18]         ;1067
0000dc  0252              LSLS     r2,r2,#9              ;1067
0000de  4391              BICS     r1,r1,r2              ;1067
0000e0  6181              STR      r1,[r0,#0x18]         ;1068
0000e2  f7fffffe          BL       RMP_Unlock_Sched
                  |L23.230|
0000e6  69a0              LDR      r0,[r4,#0x18]         ;1072  ; RMP_Cur_Thd
0000e8  6b80              LDR      r0,[r0,#0x38]         ;1072
0000ea  bdf8              POP      {r3-r7,pc}
                  |L23.236|
0000ec  f7fffffe          BL       RMP_Unlock_Sched
0000f0  2004              MOVS     r0,#4                 ;1046
0000f2  43c0              MVNS     r0,r0                 ;1046
0000f4  bdf8              POP      {r3-r7,pc}
                  |L23.246|
0000f6  69a0              LDR      r0,[r4,#0x18]         ;1058  ; RMP_Cur_Thd
0000f8  69a1              LDR      r1,[r4,#0x18]         ;1058  ; RMP_Cur_Thd
0000fa  6980              LDR      r0,[r0,#0x18]         ;1058
0000fc  0a00              LSRS     r0,r0,#8              ;1058
0000fe  0200              LSLS     r0,r0,#8              ;1058
000100  1d00              ADDS     r0,r0,#4              ;1058
000102  e7da              B        |L23.186|
;;;1074   /* End Function:RMP_Thd_Rcv **************************************************/
                          ENDP

                  |L23.260|
                          DCD      ||.data||
                  |L23.264|
                          DCD      0x000186a0
                  |L23.268|
                          DCD      ||.data||+0x20

                          AREA ||i.RMP_Thd_Resume||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Resume PROC
;;;824    ******************************************************************************/
;;;825    ret_t RMP_Thd_Resume(volatile struct RMP_Thd* Thread)
000000  b510              PUSH     {r4,lr}
;;;826    {
;;;827        ret_t Retval;
;;;828        
;;;829        /* Check if this thread structure could possibly be in use */
;;;830        if(Thread==0)
;;;831            return RMP_ERR_THD;
000002  2400              MOVS     r4,#0
000004  43e4              MVNS     r4,r4
000006  2800              CMP      r0,#0                 ;830
000008  d016              BEQ      |L24.56|
00000a  4911              LDR      r1,|L24.80|
00000c  2201              MOVS     r2,#1                 ;826
00000e  60ca              STR      r2,[r1,#0xc]          ;826  ; RMP_Sched_Locked
000010  688a              LDR      r2,[r1,#8]            ;826  ; RMP_Sched_Lock_Cnt
000012  1c52              ADDS     r2,r2,#1              ;826
000014  608a              STR      r2,[r1,#8]            ;826  ; RMP_Sched_Lock_Cnt
;;;832    
;;;833        RMP_Lock_Sched();
;;;834        
;;;835        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
000016  6981              LDR      r1,[r0,#0x18]
000018  0609              LSLS     r1,r1,#24
00001a  0e09              LSRS     r1,r1,#24
00001c  d014              BEQ      |L24.72|
;;;836        {
;;;837            RMP_Unlock_Sched();
;;;838            return RMP_ERR_THD;
;;;839        }
;;;840        
;;;841        /* Check if the thread is suspended, if not, then throw an error */
;;;842        if((Thread->State&RMP_THD_SUSPENDED)!=0)
00001e  6981              LDR      r1,[r0,#0x18]
000020  05c9              LSLS     r1,r1,#23
000022  d50f              BPL      |L24.68|
;;;843        {
;;;844            /* Suspended */
;;;845            Thread->State&=~RMP_THD_SUSPENDED;
000024  6981              LDR      r1,[r0,#0x18]
000026  22ff              MOVS     r2,#0xff
000028  3201              ADDS     r2,#1
00002a  4391              BICS     r1,r1,r2
00002c  6181              STR      r1,[r0,#0x18]
;;;846            if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
00002e  6981              LDR      r1,[r0,#0x18]
000030  b2c9              UXTB     r1,r1
000032  2901              CMP      r1,#1
000034  d002              BEQ      |L24.60|
000036  e003              B        |L24.64|
                  |L24.56|
000038  4620              MOV      r0,r4                 ;831
;;;847                _RMP_Set_Rdy(Thread);
;;;848            Retval=0;
;;;849        }
;;;850        else
;;;851            Retval=RMP_ERR_STATE;
;;;852        
;;;853        RMP_Unlock_Sched();
;;;854    
;;;855        return Retval;
;;;856    }
00003a  bd10              POP      {r4,pc}
                  |L24.60|
00003c  f7fffffe          BL       _RMP_Set_Rdy
                  |L24.64|
000040  2400              MOVS     r4,#0                 ;848
000042  e001              B        |L24.72|
                  |L24.68|
000044  2403              MOVS     r4,#3                 ;851
000046  43e4              MVNS     r4,r4                 ;851
                  |L24.72|
000048  f7fffffe          BL       RMP_Unlock_Sched
00004c  4620              MOV      r0,r4                 ;855
00004e  bd10              POP      {r4,pc}
;;;857    /* End Function:RMP_Thd_Resume ***********************************************/
                          ENDP

                  |L24.80|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Set||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Set PROC
;;;730    ******************************************************************************/
;;;731    ret_t RMP_Thd_Set(volatile struct RMP_Thd* Thread, ptr_t Prio, ptr_t Slices)
000000  2a00              CMP      r2,#0
;;;732    {
;;;733        /* Check if the priority and timeslice range is correct */
;;;734        if(Slices==0)
000002  d101              BNE      |L25.8|
;;;735            return RMP_ERR_SLICE;
000004  1ed0              SUBS     r0,r2,#3
;;;736        
;;;737        /* Check if this thread structure could possibly be in use */
;;;738        if(Thread==0)
;;;739            return RMP_ERR_THD;
;;;740        
;;;741        RMP_Lock_Sched();
;;;742        
;;;743        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;744        {
;;;745            RMP_Unlock_Sched();
;;;746            return RMP_ERR_THD;
;;;747        }
;;;748        
;;;749        /* See if the thread is in running state */
;;;750        if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;751        {
;;;752            /* See if we are gonna change one of it or both */
;;;753            if(Prio<RMP_MAX_PREEMPT_PRIO)
;;;754            {
;;;755                if(Thread->Prio!=Prio)
;;;756                {
;;;757                    _RMP_Clr_Rdy(Thread);
;;;758                    Thread->Prio=Prio;
;;;759                    _RMP_Set_Rdy(Thread);
;;;760                }
;;;761            }
;;;762            
;;;763            if(Slices<RMP_MAX_SLICES)
;;;764                Thread->Slices=Slices;
;;;765        }
;;;766        else
;;;767        {
;;;768            if(Prio<RMP_MAX_PREEMPT_PRIO)
;;;769                Thread->Prio=Prio;
;;;770            
;;;771            if(Slices<RMP_MAX_SLICES)
;;;772                Thread->Slices=Slices;
;;;773        }
;;;774        
;;;775        RMP_Unlock_Sched();
;;;776        
;;;777        return 0;
;;;778    }
000006  4770              BX       lr
                  |L25.8|
000008  b5f8              PUSH     {r3-r7,lr}            ;732
00000a  4f19              LDR      r7,|L25.112|
00000c  4615              MOV      r5,r2                 ;732
00000e  460e              MOV      r6,r1                 ;732
000010  0004              MOVS     r4,r0                 ;732
000012  d018              BEQ      |L25.70|
000014  4817              LDR      r0,|L25.116|
000016  2101              MOVS     r1,#1                 ;735
000018  60c1              STR      r1,[r0,#0xc]          ;735  ; RMP_Sched_Locked
00001a  6881              LDR      r1,[r0,#8]            ;735  ; RMP_Sched_Lock_Cnt
00001c  1c49              ADDS     r1,r1,#1              ;735
00001e  6081              STR      r1,[r0,#8]            ;735  ; RMP_Sched_Lock_Cnt
000020  69a0              LDR      r0,[r4,#0x18]         ;743
000022  0600              LSLS     r0,r0,#24             ;743
000024  0e00              LSRS     r0,r0,#24             ;743
000026  d010              BEQ      |L25.74|
000028  69a0              LDR      r0,[r4,#0x18]         ;750
00002a  4f13              LDR      r7,|L25.120|
00002c  b2c0              UXTB     r0,r0                 ;750
00002e  2801              CMP      r0,#1                 ;750
000030  d00f              BEQ      |L25.82|
000032  2e20              CMP      r6,#0x20              ;768
000034  d200              BCS      |L25.56|
000036  6266              STR      r6,[r4,#0x24]         ;769
                  |L25.56|
000038  42bd              CMP      r5,r7                 ;771
00003a  d200              BCS      |L25.62|
                  |L25.60|
00003c  61e5              STR      r5,[r4,#0x1c]         ;772
                  |L25.62|
00003e  f7fffffe          BL       RMP_Unlock_Sched
000042  2000              MOVS     r0,#0                 ;777
000044  bdf8              POP      {r3-r7,pc}
                  |L25.70|
000046  4638              MOV      r0,r7                 ;739
000048  bdf8              POP      {r3-r7,pc}
                  |L25.74|
00004a  f7fffffe          BL       RMP_Unlock_Sched
00004e  4638              MOV      r0,r7                 ;746
000050  bdf8              POP      {r3-r7,pc}
                  |L25.82|
000052  2e20              CMP      r6,#0x20              ;753
000054  d209              BCS      |L25.106|
000056  6a60              LDR      r0,[r4,#0x24]         ;755
000058  42b0              CMP      r0,r6                 ;755
00005a  d006              BEQ      |L25.106|
00005c  4620              MOV      r0,r4                 ;757
00005e  f7fffffe          BL       _RMP_Clr_Rdy
000062  6266              STR      r6,[r4,#0x24]         ;758
000064  4620              MOV      r0,r4                 ;759
000066  f7fffffe          BL       _RMP_Set_Rdy
                  |L25.106|
00006a  42bd              CMP      r5,r7                 ;763
00006c  d3e6              BCC      |L25.60|
00006e  e7e6              B        |L25.62|
;;;779    /* End Function:RMP_Thd_Set **************************************************/
                          ENDP

                  |L25.112|
                          DCD      0xffffffff
                  |L25.116|
                          DCD      ||.data||
                  |L25.120|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Snd||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Snd PROC
;;;867    ******************************************************************************/
;;;868    ret_t RMP_Thd_Snd(volatile struct RMP_Thd* Thread, ptr_t Data, ptr_t Slices)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;869    {
;;;870        /* Check if this thread structure could possibly be in use */
;;;871        if(Thread==0)
;;;872            return RMP_ERR_THD;
000002  4f3f              LDR      r7,|L26.256|
000004  4614              MOV      r4,r2                 ;869
000006  0006              MOVS     r6,r0                 ;869
000008  d042              BEQ      |L26.144|
00000a  4d3e              LDR      r5,|L26.260|
00000c  2001              MOVS     r0,#1                 ;869
00000e  60e8              STR      r0,[r5,#0xc]          ;869  ; RMP_Sched_Locked
000010  68a8              LDR      r0,[r5,#8]            ;869  ; RMP_Sched_Lock_Cnt
000012  1c40              ADDS     r0,r0,#1              ;869
000014  60a8              STR      r0,[r5,#8]            ;869  ; RMP_Sched_Lock_Cnt
;;;873        
;;;874        RMP_Lock_Sched();
;;;875        
;;;876        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
000016  69b0              LDR      r0,[r6,#0x18]
000018  0600              LSLS     r0,r0,#24
00001a  0e00              LSRS     r0,r0,#24
00001c  d03b              BEQ      |L26.150|
;;;877        {
;;;878            RMP_Unlock_Sched();
;;;879            return RMP_ERR_THD;
;;;880        }
;;;881        
;;;882        /* Are we sending to ourself? This is not allowed */
;;;883        if(RMP_Cur_Thd==Thread)
00001e  69a8              LDR      r0,[r5,#0x18]  ; RMP_Cur_Thd
;;;884        {
;;;885            RMP_Unlock_Sched();
;;;886            return RMP_ERR_OPER;
000020  1f3f              SUBS     r7,r7,#4
000022  42b0              CMP      r0,r6                 ;883
000024  d037              BEQ      |L26.150|
;;;887        }
;;;888        
;;;889        RMP_Cur_Thd->Retval=0;
000026  69a9              LDR      r1,[r5,#0x18]  ; RMP_Cur_Thd
000028  2000              MOVS     r0,#0
;;;890    
;;;891        /* See if there are already a value in the mailbox, if there is, we block */
;;;892        if((Thread->State&RMP_THD_MBOXFUL)!=0)
00002a  6388              STR      r0,[r1,#0x38]
00002c  69b0              LDR      r0,[r6,#0x18]
00002e  0580              LSLS     r0,r0,#22
000030  d53d              BPL      |L26.174|
;;;893        {
;;;894            /* Mailbox full, we block, and put ourself into the queue */
;;;895            if(Slices==0)
000032  2c00              CMP      r4,#0
000034  d02f              BEQ      |L26.150|
;;;896            {
;;;897                RMP_Unlock_Sched();
;;;898                return RMP_ERR_OPER;
;;;899            }
;;;900    
;;;901            /* We must be running */
;;;902            _RMP_Clr_Rdy(RMP_Cur_Thd);
000036  69a8              LDR      r0,[r5,#0x18]  ; RMP_Cur_Thd
000038  f7fffffe          BL       _RMP_Clr_Rdy
;;;903            RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Thread->Snd_List.Prev,&(Thread->Snd_List));
00003c  69a8              LDR      r0,[r5,#0x18]  ; RMP_Cur_Thd
00003e  6931              LDR      r1,[r6,#0x10]
000040  6130              STR      r0,[r6,#0x10]
000042  3610              ADDS     r6,r6,#0x10
000044  6046              STR      r6,[r0,#4]
000046  6001              STR      r1,[r0,#0]
000048  6048              STR      r0,[r1,#4]
;;;904    
;;;905            if(Slices<RMP_MAX_SLICES)
00004a  482f              LDR      r0,|L26.264|
00004c  4284              CMP      r4,r0
00004e  d227              BCS      |L26.160|
;;;906            {
;;;907                _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
000050  69ab              LDR      r3,[r5,#0x18]  ; RMP_Cur_Thd
000052  4a2e              LDR      r2,|L26.268|
000054  6850              LDR      r0,[r2,#4]  ; RMP_Delay
000056  4290              CMP      r0,r2
000058  d006              BEQ      |L26.104|
00005a  6a06              LDR      r6,[r0,#0x20]
                  |L26.92|
00005c  6869              LDR      r1,[r5,#4]  ; RMP_Tick
00005e  1a71              SUBS     r1,r6,r1
000060  42a1              CMP      r1,r4
000062  d801              BHI      |L26.104|
000064  4290              CMP      r0,r2
000066  d1f9              BNE      |L26.92|
                  |L26.104|
000068  6869              LDR      r1,[r5,#4]  ; RMP_Tick
00006a  1909              ADDS     r1,r1,r4
00006c  6299              STR      r1,[r3,#0x28]
00006e  3308              ADDS     r3,r3,#8
000070  6801              LDR      r1,[r0,#0]
000072  6003              STR      r3,[r0,#0]
000074  6058              STR      r0,[r3,#4]
000076  6019              STR      r1,[r3,#0]
000078  604b              STR      r3,[r1,#4]
;;;908                RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDDLY);
00007a  69a8              LDR      r0,[r5,#0x18]  ; RMP_Cur_Thd
00007c  69a9              LDR      r1,[r5,#0x18]  ; RMP_Cur_Thd
00007e  6980              LDR      r0,[r0,#0x18]
000080  0a00              LSRS     r0,r0,#8
000082  0200              LSLS     r0,r0,#8
000084  1cc0              ADDS     r0,r0,#3
                  |L26.134|
;;;909            }
;;;910            else
;;;911                RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDBLK);
;;;912    
;;;913            RMP_Cur_Thd->Data=Data;
000086  6188              STR      r0,[r1,#0x18]
000088  9801              LDR      r0,[sp,#4]
00008a  69a9              LDR      r1,[r5,#0x18]  ; RMP_Cur_Thd
00008c  6308              STR      r0,[r1,#0x30]
00008e  e030              B        |L26.242|
                  |L26.144|
000090  4638              MOV      r0,r7                 ;872
;;;914        }
;;;915        else
;;;916        {
;;;917            /* Mailbox not full. We need to check if the receiver is waiting for us */
;;;918            if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
;;;919               (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
;;;920            {
;;;921                /* The receiver is blocked, wake it up and return the value */
;;;922                if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
;;;923                    RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;924                
;;;925                RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;926    
;;;927                /* Is it suspended? If yes, we can't directly send it running */
;;;928                if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;929                    _RMP_Set_Rdy(Thread);
;;;930            }
;;;931            
;;;932            /* Set the mailbox */
;;;933            Thread->Mailbox=Data;
;;;934            Thread->State|=RMP_THD_MBOXFUL;
;;;935        }
;;;936        
;;;937        RMP_Unlock_Sched();
;;;938    
;;;939        return RMP_Cur_Thd->Retval;
;;;940    }
000092  b003              ADD      sp,sp,#0xc
000094  bdf0              POP      {r4-r7,pc}
                  |L26.150|
000096  f7fffffe          BL       RMP_Unlock_Sched
00009a  4638              MOV      r0,r7                 ;898
00009c  b003              ADD      sp,sp,#0xc
00009e  bdf0              POP      {r4-r7,pc}
                  |L26.160|
0000a0  69a8              LDR      r0,[r5,#0x18]         ;911  ; RMP_Cur_Thd
0000a2  69a9              LDR      r1,[r5,#0x18]         ;911  ; RMP_Cur_Thd
0000a4  6980              LDR      r0,[r0,#0x18]         ;911
0000a6  0a00              LSRS     r0,r0,#8              ;911
0000a8  0200              LSLS     r0,r0,#8              ;911
0000aa  1c80              ADDS     r0,r0,#2              ;911
0000ac  e7eb              B        |L26.134|
                  |L26.174|
0000ae  69b0              LDR      r0,[r6,#0x18]         ;918
0000b0  b2c0              UXTB     r0,r0                 ;918
0000b2  2804              CMP      r0,#4                 ;918
0000b4  d003              BEQ      |L26.190|
0000b6  69b0              LDR      r0,[r6,#0x18]         ;919
0000b8  b2c0              UXTB     r0,r0                 ;919
0000ba  2805              CMP      r0,#5                 ;919
0000bc  d112              BNE      |L26.228|
                  |L26.190|
0000be  69b0              LDR      r0,[r6,#0x18]         ;922
0000c0  b2c0              UXTB     r0,r0                 ;922
0000c2  2805              CMP      r0,#5                 ;922
0000c4  d103              BNE      |L26.206|
0000c6  68b1              LDR      r1,[r6,#8]            ;923
0000c8  68f0              LDR      r0,[r6,#0xc]          ;923
0000ca  6001              STR      r1,[r0,#0]            ;923
0000cc  6048              STR      r0,[r1,#4]            ;923
                  |L26.206|
0000ce  69b0              LDR      r0,[r6,#0x18]         ;925
0000d0  0a00              LSRS     r0,r0,#8              ;925
0000d2  0200              LSLS     r0,r0,#8              ;925
0000d4  1c40              ADDS     r0,r0,#1              ;925
0000d6  61b0              STR      r0,[r6,#0x18]         ;925
0000d8  69b0              LDR      r0,[r6,#0x18]         ;928
0000da  05c0              LSLS     r0,r0,#23             ;928
0000dc  d402              BMI      |L26.228|
0000de  4630              MOV      r0,r6                 ;929
0000e0  f7fffffe          BL       _RMP_Set_Rdy
                  |L26.228|
0000e4  9801              LDR      r0,[sp,#4]            ;933
0000e6  62f0              STR      r0,[r6,#0x2c]         ;933
0000e8  69b0              LDR      r0,[r6,#0x18]         ;934
0000ea  2101              MOVS     r1,#1                 ;934
0000ec  0249              LSLS     r1,r1,#9              ;934
0000ee  4308              ORRS     r0,r0,r1              ;934
0000f0  61b0              STR      r0,[r6,#0x18]         ;934
                  |L26.242|
0000f2  f7fffffe          BL       RMP_Unlock_Sched
0000f6  69a8              LDR      r0,[r5,#0x18]         ;939  ; RMP_Cur_Thd
0000f8  6b80              LDR      r0,[r0,#0x38]         ;939
0000fa  b003              ADD      sp,sp,#0xc
0000fc  bdf0              POP      {r4-r7,pc}
;;;941    /* End Function:RMP_Thd_Snd **************************************************/
                          ENDP

0000fe  0000              DCW      0x0000
                  |L26.256|
                          DCD      0xffffffff
                  |L26.260|
                          DCD      ||.data||
                  |L26.264|
                          DCD      0x000186a0
                  |L26.268|
                          DCD      ||.data||+0x20

                          AREA ||i.RMP_Thd_Snd_ISR||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Snd_ISR PROC
;;;951    ******************************************************************************/
;;;952    ret_t RMP_Thd_Snd_ISR(volatile struct RMP_Thd* Thread, ptr_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;953    {
000002  0004              MOVS     r4,r0
;;;954        /* Check if this thread structure could possibly be in use */
;;;955        if(Thread==0)
;;;956            return RMP_ERR_THD;
000004  481c              LDR      r0,|L27.120|
000006  460e              MOV      r6,r1                 ;953
000008  d034              BEQ      |L27.116|
;;;957        
;;;958        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
00000a  69a1              LDR      r1,[r4,#0x18]
00000c  0609              LSLS     r1,r1,#24
00000e  0e09              LSRS     r1,r1,#24
000010  d030              BEQ      |L27.116|
;;;959            return RMP_ERR_THD;
;;;960        
;;;961        if(RMP_Sched_Locked!=0)
000012  4d1a              LDR      r5,|L27.124|
000014  68e9              LDR      r1,[r5,#0xc]  ; RMP_Sched_Locked
;;;962            return RMP_ERR_OPER;
000016  1f00              SUBS     r0,r0,#4
000018  2900              CMP      r1,#0                 ;961
00001a  d12b              BNE      |L27.116|
;;;963    
;;;964        /* See if there are already a value in the mailbox, if there is, we abort */
;;;965        if((Thread->State&RMP_THD_MBOXFUL)!=0)
00001c  69a1              LDR      r1,[r4,#0x18]
00001e  0589              LSLS     r1,r1,#22
000020  d428              BMI      |L27.116|
;;;966            return RMP_ERR_OPER;
;;;967        else
;;;968        {
;;;969            /* Mailbox not full. We need to check if the receiver is waiting for us */
;;;970            if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
000022  69a0              LDR      r0,[r4,#0x18]
000024  b2c0              UXTB     r0,r0
000026  2804              CMP      r0,#4
000028  d003              BEQ      |L27.50|
;;;971               (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
00002a  69a0              LDR      r0,[r4,#0x18]
00002c  b2c0              UXTB     r0,r0
00002e  2805              CMP      r0,#5
000030  d119              BNE      |L27.102|
                  |L27.50|
;;;972            {
;;;973                /* The receiver is blocked, wake it up and return the value */
;;;974                if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
000032  69a0              LDR      r0,[r4,#0x18]
000034  b2c0              UXTB     r0,r0
000036  2805              CMP      r0,#5
000038  d103              BNE      |L27.66|
;;;975                    RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
00003a  68a0              LDR      r0,[r4,#8]
00003c  68e1              LDR      r1,[r4,#0xc]
00003e  6008              STR      r0,[r1,#0]
000040  6041              STR      r1,[r0,#4]
                  |L27.66|
;;;976                
;;;977                RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
000042  69a0              LDR      r0,[r4,#0x18]
000044  0a00              LSRS     r0,r0,#8
000046  0200              LSLS     r0,r0,#8
000048  1c40              ADDS     r0,r0,#1
00004a  61a0              STR      r0,[r4,#0x18]
;;;978    
;;;979                /* Is it suspended? If yes, we can't directly send it running */
;;;980                if((Thread->State&RMP_THD_SUSPENDED)==0)
00004c  69a0              LDR      r0,[r4,#0x18]
00004e  05c0              LSLS     r0,r0,#23
000050  d409              BMI      |L27.102|
;;;981                {
;;;982                    _RMP_Set_Rdy(Thread);
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       _RMP_Set_Rdy
;;;983                    if(Thread->Prio>RMP_Cur_Thd->Prio)
000058  6a60              LDR      r0,[r4,#0x24]
00005a  69a9              LDR      r1,[r5,#0x18]  ; RMP_Cur_Thd
00005c  6a49              LDR      r1,[r1,#0x24]
00005e  4288              CMP      r0,r1
000060  d901              BLS      |L27.102|
;;;984                        _RMP_Yield();
000062  f7fffffe          BL       _RMP_Yield
                  |L27.102|
;;;985                }
;;;986            }
;;;987            
;;;988            /* Set the mailbox */
;;;989            Thread->Mailbox=Data;
000066  62e6              STR      r6,[r4,#0x2c]
;;;990            Thread->State|=RMP_THD_MBOXFUL;
000068  69a0              LDR      r0,[r4,#0x18]
00006a  2101              MOVS     r1,#1
00006c  0249              LSLS     r1,r1,#9
00006e  4308              ORRS     r0,r0,r1
000070  61a0              STR      r0,[r4,#0x18]
;;;991        }
;;;992    
;;;993        return 0;
000072  2000              MOVS     r0,#0
                  |L27.116|
;;;994    }
000074  bd70              POP      {r4-r6,pc}
;;;995    /* End Function:RMP_Thd_Snd_ISR **********************************************/
                          ENDP

000076  0000              DCW      0x0000
                  |L27.120|
                          DCD      0xffffffff
                  |L27.124|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Suspend||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Suspend PROC
;;;786    ******************************************************************************/
;;;787    ret_t RMP_Thd_Suspend(volatile struct RMP_Thd* Thread)
000000  b510              PUSH     {r4,lr}
;;;788    {
;;;789        /* Check if this thread structure could possibly be in use */
;;;790        if(Thread==0)
;;;791            return RMP_ERR_THD;
000002  2400              MOVS     r4,#0
000004  43e4              MVNS     r4,r4
000006  2800              CMP      r0,#0                 ;790
000008  d010              BEQ      |L28.44|
00000a  4913              LDR      r1,|L28.88|
00000c  2201              MOVS     r2,#1                 ;788
00000e  60ca              STR      r2,[r1,#0xc]          ;788  ; RMP_Sched_Locked
000010  688a              LDR      r2,[r1,#8]            ;788  ; RMP_Sched_Lock_Cnt
000012  1c52              ADDS     r2,r2,#1              ;788
000014  608a              STR      r2,[r1,#8]            ;788  ; RMP_Sched_Lock_Cnt
;;;792        
;;;793        RMP_Lock_Sched();
;;;794        
;;;795        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
000016  6981              LDR      r1,[r0,#0x18]
000018  0609              LSLS     r1,r1,#24
00001a  0e09              LSRS     r1,r1,#24
00001c  d008              BEQ      |L28.48|
;;;796        {
;;;797            RMP_Unlock_Sched();
;;;798            return RMP_ERR_THD;
;;;799        }
;;;800        
;;;801        /* Suspend it */
;;;802        if((Thread->State&RMP_THD_SUSPENDED)!=0)
00001e  6981              LDR      r1,[r0,#0x18]
000020  05c9              LSLS     r1,r1,#23
000022  d509              BPL      |L28.56|
;;;803        {
;;;804            RMP_Unlock_Sched();
000024  f7fffffe          BL       RMP_Unlock_Sched
;;;805            return RMP_ERR_STATE;
000028  00a0              LSLS     r0,r4,#2
;;;806        }
;;;807        /* Mark this as suspended */
;;;808        Thread->State|=RMP_THD_SUSPENDED;
;;;809        /* Only when it is running do we clear this */
;;;810        if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;811            _RMP_Clr_Rdy(Thread);
;;;812        
;;;813        RMP_Unlock_Sched();
;;;814    
;;;815        return 0;
;;;816    }
00002a  bd10              POP      {r4,pc}
                  |L28.44|
00002c  4620              MOV      r0,r4                 ;791
00002e  bd10              POP      {r4,pc}
                  |L28.48|
000030  f7fffffe          BL       RMP_Unlock_Sched
000034  4620              MOV      r0,r4                 ;798
000036  bd10              POP      {r4,pc}
                  |L28.56|
000038  6981              LDR      r1,[r0,#0x18]         ;808
00003a  22ff              MOVS     r2,#0xff              ;808
00003c  3201              ADDS     r2,#1                 ;808
00003e  4311              ORRS     r1,r1,r2              ;808
000040  6181              STR      r1,[r0,#0x18]         ;808
000042  6981              LDR      r1,[r0,#0x18]         ;810
000044  b2c9              UXTB     r1,r1                 ;810
000046  2901              CMP      r1,#1                 ;810
000048  d101              BNE      |L28.78|
00004a  f7fffffe          BL       _RMP_Clr_Rdy
                  |L28.78|
00004e  f7fffffe          BL       RMP_Unlock_Sched
000052  2000              MOVS     r0,#0                 ;815
000054  bd10              POP      {r4,pc}
;;;817    /* End Function:RMP_Thd_Suspend **********************************************/
                          ENDP

000056  0000              DCW      0x0000
                  |L28.88|
                          DCD      ||.data||

                          AREA ||i.RMP_Tick_Hook||, CODE, READONLY, ALIGN=1

                  RMP_Tick_Hook PROC
;;;1490   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1491   void RMP_Tick_Hook(ptr_t Ticks)
000000  4770              BX       lr
;;;1492   {
;;;1493       Ticks=Ticks;
;;;1494       return;
;;;1495   }
;;;1496   #endif
                          ENDP


                          AREA ||i.RMP_Unlock_Sched||, CODE, READONLY, ALIGN=2

                  RMP_Unlock_Sched PROC
;;;274    ******************************************************************************/
;;;275    void RMP_Unlock_Sched(void)
000000  b510              PUSH     {r4,lr}
;;;276    {
;;;277        if(RMP_Sched_Lock_Cnt==1)
000002  480b              LDR      r0,|L30.48|
000004  6881              LDR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
000006  2901              CMP      r1,#1
000008  d006              BEQ      |L30.24|
;;;278        {
;;;279            /* Clear the count before enabling */
;;;280            RMP_Sched_Lock_Cnt=0;
;;;281            RMP_Sched_Locked=0;
;;;282            /* Now see if the scheduler scheduling action is pended in the lock-unlock 
;;;283             * period. If yes, perform a schedule now */
;;;284            if(RMP_Sched_Pend!=0)
;;;285            {
;;;286                /* Reset the count and trigger the context switch */
;;;287                RMP_Sched_Pend=0;
;;;288                _RMP_Yield();
;;;289            }
;;;290        }
;;;291        else if(RMP_Sched_Lock_Cnt>1)
00000a  6881              LDR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
00000c  2901              CMP      r1,#1
00000e  d90d              BLS      |L30.44|
;;;292            RMP_Sched_Lock_Cnt--;
000010  6881              LDR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
000012  1e49              SUBS     r1,r1,#1
000014  6081              STR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
                  |L30.22|
;;;293        /* Trying to unlock a scheduler that is not locked */
;;;294        else
;;;295            while(1);
;;;296    }
000016  bd10              POP      {r4,pc}
                  |L30.24|
000018  2100              MOVS     r1,#0                 ;280
00001a  6081              STR      r1,[r0,#8]            ;280  ; RMP_Sched_Lock_Cnt
00001c  60c1              STR      r1,[r0,#0xc]          ;281  ; RMP_Sched_Locked
00001e  6902              LDR      r2,[r0,#0x10]         ;284  ; RMP_Sched_Pend
000020  2a00              CMP      r2,#0                 ;284
000022  d0f8              BEQ      |L30.22|
000024  6101              STR      r1,[r0,#0x10]         ;287  ; RMP_Sched_Pend
000026  f7fffffe          BL       _RMP_Yield
00002a  bd10              POP      {r4,pc}
                  |L30.44|
00002c  e7fe              B        |L30.44|
;;;297    /* End Function:RMP_Unlock_Sched *********************************************/
                          ENDP

00002e  0000              DCW      0x0000
                  |L30.48|
                          DCD      ||.data||

                          AREA ||i.RMP_Yield||, CODE, READONLY, ALIGN=2

                  RMP_Yield PROC
;;;304    ******************************************************************************/
;;;305    void RMP_Yield(void)
000000  b510              PUSH     {r4,lr}
;;;306    {
;;;307        if(RMP_Sched_Locked==0)
000002  4805              LDR      r0,|L31.24|
000004  68c1              LDR      r1,[r0,#0xc]  ; RMP_Sched_Locked
000006  2900              CMP      r1,#0
000008  d002              BEQ      |L31.16|
;;;308        {
;;;309            /* Now see if the scheduler scheduling action is pended in the lock-unlock 
;;;310             * period. If yes, perform a schedule now */
;;;311            _RMP_Yield();
;;;312        }
;;;313        else
;;;314            RMP_Sched_Pend=1;
00000a  2101              MOVS     r1,#1
00000c  6101              STR      r1,[r0,#0x10]  ; RMP_Sched_Pend
;;;315    }
00000e  bd10              POP      {r4,pc}
                  |L31.16|
000010  f7fffffe          BL       _RMP_Yield
000014  bd10              POP      {r4,pc}
;;;316    /* End Function:RMP_Yield ****************************************************/
                          ENDP

000016  0000              DCW      0x0000
                  |L31.24|
                          DCD      ||.data||

                          AREA ||i._RMP_Clr_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Clr_Rdy PROC
;;;533    ******************************************************************************/
;;;534    void _RMP_Clr_Rdy(volatile struct RMP_Thd* Thread)
000000  b430              PUSH     {r4,r5}
;;;535    {
;;;536        /* See if it is the last thread on the priority level */
;;;537        if(Thread->Run_Head.Prev==Thread->Run_Head.Next)
000002  6801              LDR      r1,[r0,#0]
000004  6843              LDR      r3,[r0,#4]
;;;538            RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]&=~(((ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK));
000006  2201              MOVS     r2,#1
000008  4299              CMP      r1,r3                 ;537
00000a  d10c              BNE      |L32.38|
00000c  6a41              LDR      r1,[r0,#0x24]
00000e  4b0b              LDR      r3,|L32.60|
000010  0949              LSRS     r1,r1,#5
000012  0089              LSLS     r1,r1,#2
000014  18c9              ADDS     r1,r1,r3
000016  680b              LDR      r3,[r1,#0]
000018  6a44              LDR      r4,[r0,#0x24]
00001a  0725              LSLS     r5,r4,#28
00001c  0f2d              LSRS     r5,r5,#28
00001e  4614              MOV      r4,r2
000020  40ac              LSLS     r4,r4,r5
000022  43a3              BICS     r3,r3,r4
000024  600b              STR      r3,[r1,#0]
                  |L32.38|
;;;539        
;;;540        /* Insert this into the corresponding runqueue */
;;;541        RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
000026  6803              LDR      r3,[r0,#0]
000028  6841              LDR      r1,[r0,#4]
00002a  600b              STR      r3,[r1,#0]
00002c  6059              STR      r1,[r3,#4]
;;;542        
;;;543        /* If it is the current thread, request a context switch */
;;;544        if(Thread==RMP_Cur_Thd)
00002e  4903              LDR      r1,|L32.60|
000030  698b              LDR      r3,[r1,#0x18]  ; RMP_Cur_Thd
000032  4298              CMP      r0,r3
000034  d100              BNE      |L32.56|
;;;545            RMP_Sched_Pend=1;
000036  610a              STR      r2,[r1,#0x10]  ; RMP_Sched_Pend
                  |L32.56|
;;;546    }
000038  bc30              POP      {r4,r5}
00003a  4770              BX       lr
;;;547    /* End Function:_RMP_Clr_Rdy *************************************************/
                          ENDP

                  |L32.60|
                          DCD      ||.data||

                          AREA ||i._RMP_Get_High_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Get_High_Rdy PROC
;;;382    ******************************************************************************/
;;;383    void _RMP_Get_High_Rdy(void)
000000  b570              PUSH     {r4-r6,lr}
;;;384    {
;;;385        cnt_t Count;
;;;386        
;;;387        /* Write the SP value to thread structure */
;;;388        RMP_Cur_Thd->Stack=RMP_Cur_SP;
000002  4c1d              LDR      r4,|L33.120|
000004  69e0              LDR      r0,[r4,#0x1c]  ; RMP_Cur_SP
000006  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
;;;389        
;;;390        /* Is the scheduler locked on other threads? If yes, we return without doing anything */
;;;391        if(RMP_Sched_Locked!=0)
000008  6348              STR      r0,[r1,#0x34]
00000a  68e0              LDR      r0,[r4,#0xc]  ; RMP_Sched_Locked
00000c  2800              CMP      r0,#0
00000e  d131              BNE      |L33.116|
;;;392            return;
;;;393        
;;;394        if(RMP_Timer_Pend==1)
000010  6960              LDR      r0,[r4,#0x14]  ; RMP_Timer_Pend
000012  2500              MOVS     r5,#0
000014  2801              CMP      r0,#1
000016  d102              BNE      |L33.30|
;;;395        {
;;;396            RMP_Timer_Pend=0;
000018  6165              STR      r5,[r4,#0x14]  ; RMP_Timer_Pend
;;;397            _RMP_Timer_Proc();
00001a  f7fffffe          BL       _RMP_Timer_Proc
                  |L33.30|
;;;398        }
;;;399        
;;;400        RMP_Sched_Pend=0;
00001e  6125              STR      r5,[r4,#0x10]  ; RMP_Sched_Pend
;;;401        /* See which one is ready, and pick it */
;;;402        for(Count=RMP_BITMAP_SIZE-1;Count>=0;Count--)
;;;403        {
;;;404            if(RMP_Bitmap[Count]==0)
000020  4815              LDR      r0,|L33.120|
000022  6801              LDR      r1,[r0,#0]
000024  2900              CMP      r1,#0
000026  d022              BEQ      |L33.110|
;;;405                continue;
;;;406            
;;;407            Count=RMP_MSB_Get(RMP_Bitmap[Count])+(Count<<RMP_WORD_ORDER);
000028  6800              LDR      r0,[r0,#0]
00002a  f7fffffe          BL       RMP_MSB_Get
;;;408            
;;;409            /* See if the current thread and the next thread are the same. If yes, place the current at the end of the queue */
;;;410            if(RMP_Cur_Thd==(struct RMP_Thd*)(RMP_Run[Count].Next))
00002e  4913              LDR      r1,|L33.124|
000030  00c0              LSLS     r0,r0,#3
000032  1843              ADDS     r3,r0,r1
000034  6858              LDR      r0,[r3,#4]
000036  69a2              LDR      r2,[r4,#0x18]  ; RMP_Cur_Thd
000038  4290              CMP      r0,r2
00003a  d112              BNE      |L33.98|
;;;411            {
;;;412                RMP_List_Del(RMP_Cur_Thd->Run_Head.Prev, RMP_Cur_Thd->Run_Head.Next);
00003c  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
00003e  6802              LDR      r2,[r0,#0]
000040  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
000042  6840              LDR      r0,[r0,#4]
000044  6002              STR      r2,[r0,#0]
000046  6050              STR      r0,[r2,#4]
;;;413                RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),
000048  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
00004a  69a2              LDR      r2,[r4,#0x18]  ; RMP_Cur_Thd
00004c  6a52              LDR      r2,[r2,#0x24]
00004e  00d2              LSLS     r2,r2,#3
000050  588a              LDR      r2,[r1,r2]
000052  69a5              LDR      r5,[r4,#0x18]  ; RMP_Cur_Thd
000054  6a6d              LDR      r5,[r5,#0x24]
000056  00ed              LSLS     r5,r5,#3
000058  1869              ADDS     r1,r5,r1
00005a  6008              STR      r0,[r1,#0]
00005c  6041              STR      r1,[r0,#4]
00005e  6002              STR      r2,[r0,#0]
000060  6050              STR      r0,[r2,#4]
                  |L33.98|
;;;414                             RMP_Run[RMP_Cur_Thd->Prio].Prev,
;;;415                             &(RMP_Run[RMP_Cur_Thd->Prio]));
;;;416            }
;;;417            
;;;418            /* Replenish timeslices */
;;;419            RMP_Cur_Thd->Slices_Left=RMP_Cur_Thd->Slices;
000062  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
000064  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
000066  69c0              LDR      r0,[r0,#0x1c]
;;;420            RMP_Cur_Thd=(struct RMP_Thd*)(RMP_Run[Count].Next);
000068  6208              STR      r0,[r1,#0x20]
00006a  6858              LDR      r0,[r3,#4]
00006c  61a0              STR      r0,[r4,#0x18]  ; RMP_Cur_Thd
                  |L33.110|
;;;421            break;
;;;422        }
;;;423        
;;;424        /* Load the SP value from thread structure */
;;;425        RMP_Cur_SP=RMP_Cur_Thd->Stack;
00006e  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
000070  6b40              LDR      r0,[r0,#0x34]
000072  61e0              STR      r0,[r4,#0x1c]  ; RMP_Cur_SP
                  |L33.116|
;;;426    }
000074  bd70              POP      {r4-r6,pc}
;;;427    /* End Function:_RMP_Get_High_Rdy ********************************************/
                          ENDP

000076  0000              DCW      0x0000
                  |L33.120|
                          DCD      ||.data||
                  |L33.124|
                          DCD      ||.bss||

                          AREA ||i._RMP_Get_Near_Ticks||, CODE, READONLY, ALIGN=2

                  _RMP_Get_Near_Ticks PROC
;;;478    ******************************************************************************/
;;;479    ptr_t _RMP_Get_Near_Ticks(void)
000000  b410              PUSH     {r4}
;;;480    {
;;;481        ptr_t Value;
;;;482        struct RMP_Thd* Thread;
;;;483        
;;;484        /* What is the current thread's timeout value? */
;;;485        Value=RMP_Cur_Thd->Slices_Left;
000002  4a0b              LDR      r2,|L34.48|
000004  6990              LDR      r0,[r2,#0x18]  ; RMP_Cur_Thd
;;;486        
;;;487        /* What is the nearest timer timeout value? */
;;;488        if((&RMP_Delay)!=RMP_Delay.Next)
000006  490b              LDR      r1,|L34.52|
000008  6a00              LDR      r0,[r0,#0x20]         ;485
00000a  684b              LDR      r3,[r1,#4]  ; RMP_Delay
00000c  428b              CMP      r3,r1
00000e  d006              BEQ      |L34.30|
;;;489        {
;;;490            Thread=RMP_DLY2THD(RMP_Delay.Next);
000010  6849              LDR      r1,[r1,#4]  ; RMP_Delay
;;;491            /* See if it is nearer - don't worry about the situation that the timer
;;;492             * have overflown, because if that is to happen, it would have been 
;;;493             * already processed by the timeout processing routine just called above. */
;;;494            if((Thread->Timeout-RMP_Tick)<Value)
;;;495                Value=Thread->Timeout-RMP_Tick;
000012  6854              LDR      r4,[r2,#4]  ; RMP_Tick
000014  6a0b              LDR      r3,[r1,#0x20]
000016  3908              SUBS     r1,r1,#8
000018  1b1b              SUBS     r3,r3,r4
00001a  4283              CMP      r3,r0
00001c  d304              BCC      |L34.40|
                  |L34.30|
;;;496        }
;;;497        
;;;498        /* The timer setting is at least 1 tick */
;;;499        if(Value==0)
00001e  2800              CMP      r0,#0
000020  d100              BNE      |L34.36|
;;;500            Value=1;
000022  2001              MOVS     r0,#1
                  |L34.36|
;;;501        
;;;502        return Value;
;;;503    }
000024  bc10              POP      {r4}
000026  4770              BX       lr
                  |L34.40|
000028  6a88              LDR      r0,[r1,#0x28]         ;495
00002a  6851              LDR      r1,[r2,#4]            ;495  ; RMP_Tick
00002c  1a40              SUBS     r0,r0,r1              ;495
00002e  e7f6              B        |L34.30|
;;;504    /* End Function:_RMP_Get_Near_Ticks ******************************************/
                          ENDP

                  |L34.48|
                          DCD      ||.data||
                  |L34.52|
                          DCD      ||.data||+0x20

                          AREA ||i._RMP_Set_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Set_Rdy PROC
;;;513    ******************************************************************************/
;;;514    void _RMP_Set_Rdy(volatile struct RMP_Thd* Thread)
000000  b430              PUSH     {r4,r5}
;;;515    {
;;;516        /* Insert this into the corresponding runqueue */
;;;517        RMP_List_Ins(&(Thread->Run_Head),RMP_Run[Thread->Prio].Prev,&(RMP_Run[Thread->Prio]));
000002  6a41              LDR      r1,[r0,#0x24]
000004  4a10              LDR      r2,|L35.72|
000006  00c9              LSLS     r1,r1,#3
000008  5851              LDR      r1,[r2,r1]
00000a  6a43              LDR      r3,[r0,#0x24]
00000c  00db              LSLS     r3,r3,#3
00000e  189a              ADDS     r2,r3,r2
000010  6010              STR      r0,[r2,#0]
000012  6042              STR      r2,[r0,#4]
000014  6001              STR      r1,[r0,#0]
000016  6048              STR      r0,[r1,#4]
;;;518        /* Set this runlevel as active */
;;;519        RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]|=((ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK);
000018  6a41              LDR      r1,[r0,#0x24]
00001a  4a0c              LDR      r2,|L35.76|
00001c  0949              LSRS     r1,r1,#5
00001e  0089              LSLS     r1,r1,#2
000020  1889              ADDS     r1,r1,r2
000022  680b              LDR      r3,[r1,#0]
000024  6a42              LDR      r2,[r0,#0x24]
000026  0715              LSLS     r5,r2,#28
000028  2201              MOVS     r2,#1
00002a  0f2d              LSRS     r5,r5,#28
00002c  4614              MOV      r4,r2
00002e  40ac              LSLS     r4,r4,r5
000030  4323              ORRS     r3,r3,r4
000032  600b              STR      r3,[r1,#0]
;;;520        
;;;521        /* Compare this with the current one to see if we need a context switch */
;;;522        if(Thread->Prio>RMP_Cur_Thd->Prio)
000034  6a41              LDR      r1,[r0,#0x24]
000036  4805              LDR      r0,|L35.76|
000038  6983              LDR      r3,[r0,#0x18]  ; RMP_Cur_Thd
00003a  6a5b              LDR      r3,[r3,#0x24]
00003c  4299              CMP      r1,r3
00003e  d900              BLS      |L35.66|
;;;523            RMP_Sched_Pend=1;
000040  6102              STR      r2,[r0,#0x10]  ; RMP_Sched_Pend
                  |L35.66|
;;;524    }
000042  bc30              POP      {r4,r5}
000044  4770              BX       lr
;;;525    /* End Function:_RMP_Set_Rdy *************************************************/
                          ENDP

000046  0000              DCW      0x0000
                  |L35.72|
                          DCD      ||.bss||
                  |L35.76|
                          DCD      ||.data||

                          AREA ||i._RMP_Tick_Handler||, CODE, READONLY, ALIGN=2

                  _RMP_Tick_Handler PROC
;;;434    ******************************************************************************/
;;;435    void _RMP_Tick_Handler(ptr_t Ticks)
000000  b510              PUSH     {r4,lr}
;;;436    {
;;;437        struct RMP_Thd* Thread;
;;;438        /* Increase the timestamp as always */
;;;439        RMP_Tick+=Ticks;
000002  4c16              LDR      r4,|L36.92|
000004  6861              LDR      r1,[r4,#4]  ; RMP_Tick
000006  1809              ADDS     r1,r1,r0
000008  6061              STR      r1,[r4,#4]  ; RMP_Tick
;;;440    #if(RMP_USE_HOOKS==RMP_TRUE)
;;;441        RMP_Tick_Hook(Ticks);
;;;442    #endif
;;;443        /* See if the current thread expired. If yes, trigger a scheduler event */
;;;444        if(Ticks>=RMP_Cur_Thd->Slices_Left)
00000a  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
;;;445            RMP_Sched_Pend=1;
00000c  2201              MOVS     r2,#1
00000e  6a09              LDR      r1,[r1,#0x20]         ;444
000010  4281              CMP      r1,r0                 ;444
000012  d801              BHI      |L36.24|
000014  6122              STR      r2,[r4,#0x10]  ; RMP_Sched_Pend
000016  e003              B        |L36.32|
                  |L36.24|
;;;446        else
;;;447            RMP_Cur_Thd->Slices_Left-=Ticks;
000018  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
00001a  6a0b              LDR      r3,[r1,#0x20]
00001c  1a18              SUBS     r0,r3,r0
00001e  6208              STR      r0,[r1,#0x20]
                  |L36.32|
;;;448        
;;;449        /* Is the scheduler locked? If yes, we cannot process timer events here and will have to pend them */
;;;450        if((&RMP_Delay)!=RMP_Delay.Next)
000020  480f              LDR      r0,|L36.96|
000022  6841              LDR      r1,[r0,#4]  ; RMP_Delay
000024  4281              CMP      r1,r0
000026  d00d              BEQ      |L36.68|
;;;451        {
;;;452            Thread=RMP_DLY2THD(RMP_Delay.Next);
000028  6840              LDR      r0,[r0,#4]  ; RMP_Delay
;;;453            /* If the value is less than this, then it means that the time have
;;;454             * already passed and we have to process this */
;;;455            if((RMP_Tick-Thread->Timeout)<=(RMP_ALLBITS>>1))
00002a  6861              LDR      r1,[r4,#4]  ; RMP_Tick
00002c  6a00              LDR      r0,[r0,#0x20]
00002e  1a08              SUBS     r0,r1,r0
000030  490c              LDR      r1,|L36.100|
000032  4288              CMP      r0,r1
000034  d806              BHI      |L36.68|
;;;456            {
;;;457                /* If scheduler locked, we pend the processing until it is unlocked */
;;;458                if(RMP_Sched_Locked!=0)
000036  68e0              LDR      r0,[r4,#0xc]  ; RMP_Sched_Locked
000038  2800              CMP      r0,#0
00003a  d001              BEQ      |L36.64|
;;;459                    RMP_Timer_Pend=1;
00003c  6162              STR      r2,[r4,#0x14]  ; RMP_Timer_Pend
00003e  e001              B        |L36.68|
                  |L36.64|
;;;460                else
;;;461                    _RMP_Timer_Proc();
000040  f7fffffe          BL       _RMP_Timer_Proc
                  |L36.68|
;;;462            }
;;;463        }
;;;464        
;;;465        if((RMP_Sched_Locked==0)&&(RMP_Sched_Pend!=0))
000044  68e0              LDR      r0,[r4,#0xc]  ; RMP_Sched_Locked
000046  2800              CMP      r0,#0
000048  d106              BNE      |L36.88|
00004a  6920              LDR      r0,[r4,#0x10]  ; RMP_Sched_Pend
00004c  2800              CMP      r0,#0
00004e  d003              BEQ      |L36.88|
;;;466        {
;;;467            RMP_Sched_Pend=0;
000050  2000              MOVS     r0,#0
000052  6120              STR      r0,[r4,#0x10]  ; RMP_Sched_Pend
;;;468            _RMP_Yield();
000054  f7fffffe          BL       _RMP_Yield
                  |L36.88|
;;;469        }
;;;470    }
000058  bd10              POP      {r4,pc}
;;;471    /* End Function:_RMP_Tick_Handler ********************************************/
                          ENDP

00005a  0000              DCW      0x0000
                  |L36.92|
                          DCD      ||.data||
                  |L36.96|
                          DCD      ||.data||+0x20
                  |L36.100|
                          DCD      0x7fffffff

                          AREA ||i._RMP_Timer_Proc||, CODE, READONLY, ALIGN=2

                  _RMP_Timer_Proc PROC
;;;323    ******************************************************************************/
;;;324    void _RMP_Timer_Proc(void)
000000  4a26              LDR      r2,|L37.156|
;;;325    {
;;;326        struct RMP_Thd* Thread;
;;;327        
;;;328        /* Process the timer events, if there are any of them */
;;;329        while((&RMP_Delay)!=RMP_Delay.Next)
000002  6850              LDR      r0,[r2,#4]  ; RMP_Delay
000004  4290              CMP      r0,r2
000006  d048              BEQ      |L37.154|
000008  b4f0              PUSH     {r4-r7}               ;325
;;;330        {
;;;331            Thread=RMP_DLY2THD(RMP_Delay.Next);
;;;332            /* If the value is more than this, then it means that the time have
;;;333             * already passed and we have to process this */
;;;334            if((RMP_Tick-Thread->Timeout)>(RMP_ALLBITS>>1))
;;;335                break;
;;;336            
;;;337            /* This thread should be processed */
;;;338            RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;339            switch(RMP_THD_STATE(Thread->State))
;;;340            {
;;;341                case RMP_THD_SNDDLY:
;;;342                case RMP_THD_SEMDLY:
;;;343                {
;;;344                    RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;345                    Thread->Retval=RMP_ERR_OPER;
;;;346                    break;
;;;347                }
;;;348                
;;;349                case RMP_THD_RCVDLY:
;;;350                {
;;;351                    Thread->Retval=RMP_ERR_OPER;
;;;352                    break;
;;;353                }
;;;354                
;;;355                case RMP_THD_DELAYED:break;
;;;356                /* Should not get here */
;;;357                default:break;
;;;358            }
;;;359    
;;;360            RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;361            /* Is it suspended? If yes, we can't directly set it running */
;;;362            if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;363            {
;;;364                /* Insert this into the corresponding runqueue */
;;;365                RMP_List_Ins(&(Thread->Run_Head),RMP_Run[Thread->Prio].Prev,&(RMP_Run[Thread->Prio]));
;;;366                /* Set this runlevel as active */
;;;367                RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]|=1<<(Thread->Prio&RMP_WORD_MASK);
00000a  4f25              LDR      r7,|L37.160|
00000c  4639              MOV      r1,r7                 ;334
                  |L37.14|
00000e  6850              LDR      r0,[r2,#4]            ;331  ; RMP_Delay
000010  684c              LDR      r4,[r1,#4]            ;334  ; RMP_Tick
000012  6a03              LDR      r3,[r0,#0x20]         ;334
000014  3808              SUBS     r0,r0,#8              ;334
000016  1ae3              SUBS     r3,r4,r3              ;334
000018  4c22              LDR      r4,|L37.164|
00001a  42a3              CMP      r3,r4                 ;334
00001c  d83b              BHI      |L37.150|
00001e  68c4              LDR      r4,[r0,#0xc]          ;334
000020  6883              LDR      r3,[r0,#8]            ;334
000022  6023              STR      r3,[r4,#0]            ;334
000024  605c              STR      r4,[r3,#4]            ;334
000026  7e03              LDRB     r3,[r0,#0x18]         ;339
000028  2b03              CMP      r3,#3                 ;339
00002a  d005              BEQ      |L37.56|
00002c  2b05              CMP      r3,#5                 ;339
00002e  d00b              BEQ      |L37.72|
000030  2b06              CMP      r3,#6                 ;339
000032  d00c              BEQ      |L37.78|
000034  2b08              CMP      r3,#8                 ;339
000036  d10a              BNE      |L37.78|
                  |L37.56|
000038  6844              LDR      r4,[r0,#4]            ;339
00003a  6803              LDR      r3,[r0,#0]            ;339
00003c  6023              STR      r3,[r4,#0]            ;339
00003e  605c              STR      r4,[r3,#4]            ;339
000040  2304              MOVS     r3,#4                 ;345
000042  43db              MVNS     r3,r3                 ;345
000044  6383              STR      r3,[r0,#0x38]         ;346
000046  e002              B        |L37.78|
                  |L37.72|
000048  2304              MOVS     r3,#4                 ;351
00004a  43db              MVNS     r3,r3                 ;351
00004c  6383              STR      r3,[r0,#0x38]         ;351
                  |L37.78|
00004e  6983              LDR      r3,[r0,#0x18]         ;360
000050  0a1b              LSRS     r3,r3,#8              ;360
000052  021b              LSLS     r3,r3,#8              ;360
000054  1c5b              ADDS     r3,r3,#1              ;360
000056  6183              STR      r3,[r0,#0x18]         ;362
000058  05db              LSLS     r3,r3,#23             ;362
00005a  d419              BMI      |L37.144|
00005c  6a43              LDR      r3,[r0,#0x24]         ;365
00005e  00dd              LSLS     r5,r3,#3              ;365
000060  4b11              LDR      r3,|L37.168|
000062  595c              LDR      r4,[r3,r5]            ;365
000064  18eb              ADDS     r3,r5,r3              ;365
000066  6018              STR      r0,[r3,#0]            ;365
000068  6043              STR      r3,[r0,#4]            ;365
00006a  6004              STR      r4,[r0,#0]            ;365
00006c  6060              STR      r0,[r4,#4]            ;365
00006e  6a43              LDR      r3,[r0,#0x24]
000070  095c              LSRS     r4,r3,#5
000072  00a4              LSLS     r4,r4,#2
000074  593d              LDR      r5,[r7,r4]
000076  071e              LSLS     r6,r3,#28
000078  0f36              LSRS     r6,r6,#28
00007a  2301              MOVS     r3,#1
00007c  40b3              LSLS     r3,r3,r6
00007e  431d              ORRS     r5,r5,r3
000080  513d              STR      r5,[r7,r4]
;;;368                /* See if we need to pend a scheduling event */
;;;369                if(Thread->Prio>RMP_Cur_Thd->Prio)
000082  6a40              LDR      r0,[r0,#0x24]
000084  698b              LDR      r3,[r1,#0x18]  ; RMP_Cur_Thd
000086  6a5b              LDR      r3,[r3,#0x24]
000088  4298              CMP      r0,r3
00008a  d901              BLS      |L37.144|
;;;370                    RMP_Sched_Pend=1;
00008c  2001              MOVS     r0,#1
00008e  6108              STR      r0,[r1,#0x10]  ; RMP_Sched_Pend
                  |L37.144|
000090  6850              LDR      r0,[r2,#4]            ;329  ; RMP_Delay
000092  4290              CMP      r0,r2                 ;329
000094  d1bb              BNE      |L37.14|
                  |L37.150|
;;;371            }
;;;372        }
;;;373    }
000096  bcf0              POP      {r4-r7}
000098  4770              BX       lr
                  |L37.154|
00009a  4770              BX       lr
;;;374    /* Begin Function:_RMP_Timer_Proc ********************************************/
                          ENDP

                  |L37.156|
                          DCD      ||.data||+0x20
                  |L37.160|
                          DCD      ||.data||
                  |L37.164|
                          DCD      0x7fffffff
                  |L37.168|
                          DCD      ||.bss||

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;1531   ******************************************************************************/
;;;1532   int main(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1533   {
;;;1534       ptr_t Count;
;;;1535       /* Initialize the kernel data structures first */
;;;1536       _RMP_Low_Level_Init();
000002  f7fffffe          BL       _RMP_Low_Level_Init
;;;1537       
;;;1538   #if(RMP_USE_HOOKS==RMP_TRUE)
;;;1539       RMP_Start_Hook();
;;;1540   #endif
;;;1541       
;;;1542       RMP_Tick=0;
000006  4929              LDR      r1,|L38.172|
000008  2000              MOVS     r0,#0
00000a  6048              STR      r0,[r1,#4]  ; RMP_Tick
;;;1543       /* Now initialize the kernel data structures */
;;;1544       RMP_Sched_Lock_Cnt=0;
00000c  6088              STR      r0,[r1,#8]  ; RMP_Sched_Lock_Cnt
;;;1545       RMP_Sched_Locked=0;
00000e  60c8              STR      r0,[r1,#0xc]  ; RMP_Sched_Locked
;;;1546       RMP_Sched_Pend=0;
000010  6108              STR      r0,[r1,#0x10]  ; RMP_Sched_Pend
;;;1547       RMP_Timer_Pend=0;
000012  6148              STR      r0,[r1,#0x14]  ; RMP_Timer_Pend
;;;1548       
;;;1549       /* Linked lists */
;;;1550       RMP_List_Crt(&RMP_Delay);
000014  4926              LDR      r1,|L38.176|
000016  6009              STR      r1,[r1,#0]
000018  6049              STR      r1,[r1,#4]
;;;1551       for(Count=0;Count<RMP_MAX_PREEMPT_PRIO;Count++)
;;;1552           RMP_List_Crt(&RMP_Run[Count]);
00001a  4d26              LDR      r5,|L38.180|
00001c  4601              MOV      r1,r0                 ;1551
                  |L38.30|
00001e  00ca              LSLS     r2,r1,#3
000020  1952              ADDS     r2,r2,r5
000022  6012              STR      r2,[r2,#0]
000024  6052              STR      r2,[r2,#4]
000026  1c49              ADDS     r1,r1,#1
000028  2920              CMP      r1,#0x20
00002a  d3f8              BCC      |L38.30|
;;;1553       for(Count=0;Count<RMP_BITMAP_SIZE;Count++)
;;;1554           RMP_Bitmap[Count]=0;
00002c  4f1f              LDR      r7,|L38.172|
00002e  6038              STR      r0,[r7,#0]  ; RMP_Bitmap
;;;1555           
;;;1556       /* Now boot into the first thread */
;;;1557       RMP_Clear(&RMP_Init_Thd,sizeof(struct RMP_Thd));
000030  4b21              LDR      r3,|L38.184|
000032  243c              MOVS     r4,#0x3c
000034  260f              MOVS     r6,#0xf
000036  4619              MOV      r1,r3
000038  2207              MOVS     r2,#7
00003a  6018              STR      r0,[r3,#0]
                  |L38.60|
00003c  6048              STR      r0,[r1,#4]
00003e  6088              STR      r0,[r1,#8]
000040  3108              ADDS     r1,r1,#8
000042  1e52              SUBS     r2,r2,#1
000044  d1fa              BNE      |L38.60|
000046  00b1              LSLS     r1,r6,#2
000048  07a2              LSLS     r2,r4,#30
00004a  18c9              ADDS     r1,r1,r3
00004c  0f92              LSRS     r2,r2,#30
00004e  07a3              LSLS     r3,r4,#30
000050  d00b              BEQ      |L38.106|
000052  1e49              SUBS     r1,r1,#1
000054  07d3              LSLS     r3,r2,#31
000056  d001              BEQ      |L38.92|
000058  7048              STRB     r0,[r1,#1]
00005a  1c49              ADDS     r1,r1,#1
                  |L38.92|
00005c  0852              LSRS     r2,r2,#1
00005e  d004              BEQ      |L38.106|
                  |L38.96|
000060  7048              STRB     r0,[r1,#1]
000062  7088              STRB     r0,[r1,#2]
000064  1c89              ADDS     r1,r1,#2
000066  1e52              SUBS     r2,r2,#1
000068  d1fa              BNE      |L38.96|
                  |L38.106|
;;;1558       RMP_Init_Thd.Prio=0;
00006a  4913              LDR      r1,|L38.184|
00006c  6248              STR      r0,[r1,#0x24]  ; RMP_Init_Thd
;;;1559       RMP_Init_Thd.Slices=10;
00006e  200a              MOVS     r0,#0xa
000070  61c8              STR      r0,[r1,#0x1c]  ; RMP_Init_Thd
;;;1560       RMP_Init_Thd.Slices_Left=10;
000072  6208              STR      r0,[r1,#0x20]  ; RMP_Init_Thd
;;;1561       RMP_Init_Thd.State=RMP_THD_RUNNING;
000074  2201              MOVS     r2,#1
000076  618a              STR      r2,[r1,#0x18]  ; RMP_Init_Thd
;;;1562       RMP_Init_Thd.Stack=RMP_INIT_STACK;
000078  4810              LDR      r0,|L38.188|
00007a  6348              STR      r0,[r1,#0x34]  ; RMP_Init_Thd
;;;1563       
;;;1564       /* Initialize sending list */
;;;1565       RMP_List_Crt(&(RMP_Init_Thd.Snd_List));
00007c  4810              LDR      r0,|L38.192|
00007e  6000              STR      r0,[r0,#0]
000080  6040              STR      r0,[r0,#4]
;;;1566       
;;;1567       /* Insert this into the corresponding runqueue */
;;;1568       RMP_List_Ins(&(RMP_Init_Thd.Run_Head),RMP_Run[0].Prev,&(RMP_Run[0]));
000082  682b              LDR      r3,[r5,#0]  ; RMP_Run
000084  3810              SUBS     r0,r0,#0x10
000086  4c0b              LDR      r4,|L38.180|
000088  6020              STR      r0,[r4,#0]
00008a  6044              STR      r4,[r0,#4]
00008c  6003              STR      r3,[r0,#0]
00008e  6058              STR      r0,[r3,#4]
;;;1569       /* Set this runlevel as active - in fact it is always active */
;;;1570       RMP_Bitmap[0]|=1;
000090  6838              LDR      r0,[r7,#0]  ; RMP_Bitmap
000092  4310              ORRS     r0,r0,r2
000094  6038              STR      r0,[r7,#0]  ; RMP_Bitmap
;;;1571       
;;;1572       /* Set current thread and stack */
;;;1573       RMP_Cur_Thd=(struct RMP_Thd*)(&RMP_Init_Thd);
000096  4805              LDR      r0,|L38.172|
000098  6181              STR      r1,[r0,#0x18]  ; RMP_Cur_Thd
;;;1574       RMP_Cur_SP=RMP_Init_Thd.Stack;
00009a  6b4a              LDR      r2,[r1,#0x34]  ; RMP_Init_Thd
00009c  61c2              STR      r2,[r0,#0x1c]  ; RMP_Cur_SP
;;;1575       
;;;1576       /* Now jump to the user function and will never return. Initialization of stack is not needed */
;;;1577       _RMP_Start((ptr_t)RMP_Init, (ptr_t)RMP_Init_Thd.Stack);
00009e  6b49              LDR      r1,[r1,#0x34]  ; RMP_Init_Thd
0000a0  4808              LDR      r0,|L38.196|
0000a2  f7fffffe          BL       _RMP_Start
;;;1578       
;;;1579       return 0;
0000a6  2000              MOVS     r0,#0
;;;1580   }
0000a8  bdf8              POP      {r3-r7,pc}
;;;1581   /* End Function:main *********************************************************/
                          ENDP

0000aa  0000              DCW      0x0000
                  |L38.172|
                          DCD      ||.data||
                  |L38.176|
                          DCD      ||.data||+0x20
                  |L38.180|
                          DCD      ||.bss||
                  |L38.184|
                          DCD      ||.bss||+0x200
                  |L38.188|
                          DCD      ||.bss||+0x1bc
                  |L38.192|
                          DCD      ||.bss||+0x210
                  |L38.196|
                          DCD      RMP_Init

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  RMP_Run
                          %        256
                  RMP_Init_Stack
                          %        256
                  RMP_Init_Thd
                          %        60

                          AREA ||.data||, DATA, ALIGN=2

                  RMP_Bitmap
                          DCD      0x00000000
                  RMP_Tick
                          DCD      0x00000000
                  RMP_Sched_Lock_Cnt
                          DCD      0x00000000
                  RMP_Sched_Locked
                          DCD      0x00000000
                  RMP_Sched_Pend
                          DCD      0x00000000
                  RMP_Timer_Pend
                          DCD      0x00000000
                  RMP_Cur_Thd
                          DCD      0x00000000
                  RMP_Cur_SP
                          DCD      0x00000000
                  RMP_Delay
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\..\\MProkaron\\Kernel\\kernel.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_kernel_c_346ad0e8____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F0_V1.9.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___8_kernel_c_346ad0e8____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_kernel_c_346ad0e8____REVSH|
#line 402
|__asm___8_kernel_c_346ad0e8____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
