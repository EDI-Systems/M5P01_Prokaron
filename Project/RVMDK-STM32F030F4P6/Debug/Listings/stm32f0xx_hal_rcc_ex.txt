; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f0xx_hal_rcc_ex.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f0xx_hal_rcc_ex.d --cpu=Cortex-M0 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F0_V1.9.0\Drivers\STM32F0xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_F0_V1.9.0\Drivers\CMSIS\Device\ST\STM32L0xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F0_V1.9.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F0_V1.9.0\Drivers\STM32F0xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F030F4P6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F0xx_DFP\2.0.0\Drivers\CMSIS\Device\ST\STM32F0xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F030x6 -DSTM32F030x6 -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f0xx_hal_rcc_ex.crf ..\..\..\M0P0_Library\STM32Cube_FW_F0_V1.9.0\Drivers\STM32F0xx_HAL_Driver\Src\stm32f0xx_hal_rcc_ex.c]
                          THUMB

                          AREA ||i.HAL_RCCEx_GetPeriphCLKConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_GetPeriphCLKConfig PROC
;;;285      */
;;;286    void HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
000000  4908              LDR      r1,|L1.36|
;;;287    {
;;;288      /* Set all possible values for the extended clock type parameter------------*/
;;;289      /* Common part first */
;;;290      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART1 | RCC_PERIPHCLK_I2C1   | RCC_PERIPHCLK_RTC;  
;;;291      /* Get the RTC configuration --------------------------------------------*/
;;;292      PeriphClkInit->RTCClockSelection = __HAL_RCC_GET_RTC_SOURCE();
000002  6001              STR      r1,[r0,#0]
000004  4908              LDR      r1,|L1.40|
000006  6a0a              LDR      r2,[r1,#0x20]
000008  2303              MOVS     r3,#3
00000a  021b              LSLS     r3,r3,#8
00000c  401a              ANDS     r2,r2,r3
;;;293      /* Get the USART1 clock configuration --------------------------------------------*/
;;;294      PeriphClkInit->Usart1ClockSelection = __HAL_RCC_GET_USART1_SOURCE();
00000e  6042              STR      r2,[r0,#4]
000010  6b0a              LDR      r2,[r1,#0x30]
000012  0792              LSLS     r2,r2,#30
000014  0f92              LSRS     r2,r2,#30
;;;295      /* Get the I2C1 clock source -----------------------------------------------*/
;;;296      PeriphClkInit->I2c1ClockSelection = __HAL_RCC_GET_I2C1_SOURCE();
000016  6082              STR      r2,[r0,#8]
000018  6b09              LDR      r1,[r1,#0x30]
00001a  2210              MOVS     r2,#0x10
00001c  4011              ANDS     r1,r1,r2
00001e  60c1              STR      r1,[r0,#0xc]
;;;297    
;;;298    #if defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
;;;299     || defined(STM32F091xC) || defined(STM32F098xx)
;;;300      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_USART2;
;;;301      /* Get the USART2 clock source ---------------------------------------------*/
;;;302      PeriphClkInit->Usart2ClockSelection = __HAL_RCC_GET_USART2_SOURCE();
;;;303    #endif /* STM32F071xB || STM32F072xB || STM32F078xx || */
;;;304           /* STM32F091xC || STM32F098xx */
;;;305    
;;;306    #if defined(STM32F091xC) || defined(STM32F098xx)
;;;307      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_USART3;
;;;308      /* Get the USART3 clock source ---------------------------------------------*/
;;;309      PeriphClkInit->Usart3ClockSelection = __HAL_RCC_GET_USART3_SOURCE();
;;;310    #endif /* STM32F091xC || STM32F098xx */
;;;311    
;;;312    #if defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB) || defined(STM32F070x6)
;;;313      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_USB;
;;;314      /* Get the USB clock source ---------------------------------------------*/
;;;315      PeriphClkInit->UsbClockSelection = __HAL_RCC_GET_USB_SOURCE();
;;;316    #endif /* STM32F042x6 || STM32F048xx || STM32F072xB || STM32F078xx || STM32F070xB || STM32F070x6 */
;;;317    
;;;318    #if defined(STM32F042x6) || defined(STM32F048xx)\
;;;319     || defined(STM32F051x8) || defined(STM32F058xx)\
;;;320     || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
;;;321     || defined(STM32F091xC) || defined(STM32F098xx)
;;;322      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_CEC;
;;;323      /* Get the CEC clock source ------------------------------------------------*/
;;;324      PeriphClkInit->CecClockSelection = __HAL_RCC_GET_CEC_SOURCE();
;;;325    #endif /* STM32F042x6 || STM32F048xx ||                */
;;;326           /* STM32F051x8 || STM32F058xx ||                */
;;;327           /* STM32F071xB || STM32F072xB || STM32F078xx || */
;;;328           /* STM32F091xC || STM32F098xx */
;;;329    
;;;330    }
000020  4770              BX       lr
;;;331    
                          ENDP

000022  0000              DCW      0x0000
                  |L1.36|
                          DCD      0x00010021
                  |L1.40|
                          DCD      0x40021000

                          AREA ||i.HAL_RCCEx_GetPeriphCLKFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_GetPeriphCLKFreq PROC
;;;385      */
;;;386    uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
000000  b570              PUSH     {r4-r6,lr}
;;;387    {
000002  4602              MOV      r2,r0
;;;388      /* frequency == 0 : means that no available frequency for the peripheral */
;;;389      uint32_t frequency = 0U;
;;;390      
;;;391      uint32_t srcclk = 0U;
;;;392    #if defined(USB)
;;;393      uint32_t pllmull = 0U, pllsource = 0U, predivfactor = 0U;
;;;394    #endif /* USB */
;;;395    
;;;396      /* Check the parameters */
;;;397      assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));
;;;398      
;;;399      switch (PeriphClk)
;;;400      {
;;;401      case RCC_PERIPHCLK_RTC:
;;;402        {
;;;403          /* Get the current RTC source */
;;;404          srcclk = __HAL_RCC_GET_RTC_SOURCE();
;;;405    
;;;406          /* Check if LSE is ready and if RTC clock selection is LSE */
;;;407          if ((srcclk == RCC_RTCCLKSOURCE_LSE) && (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)))
;;;408          {
;;;409            frequency = LSE_VALUE;
000004  2301              MOVS     r3,#1
000006  2000              MOVS     r0,#0                 ;389
000008  03db              LSLS     r3,r3,#15
;;;410          }
;;;411          /* Check if LSI is ready and if RTC clock selection is LSI */
;;;412          else if ((srcclk == RCC_RTCCLKSOURCE_LSI) && (HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY)))
;;;413          {
;;;414            frequency = LSI_VALUE;
;;;415          }
;;;416          /* Check if HSE is ready  and if RTC clock selection is HSI_DIV32*/
;;;417          else if ((srcclk == RCC_RTCCLKSOURCE_HSE_DIV32) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)))
;;;418          {
;;;419            frequency = HSE_VALUE / 32U;
;;;420          }
;;;421          break;
;;;422        }
;;;423      case RCC_PERIPHCLK_USART1:
;;;424        {
;;;425          /* Get the current USART1 source */
;;;426          srcclk = __HAL_RCC_GET_USART1_SOURCE();
;;;427    
;;;428          /* Check if USART1 clock selection is PCLK1 */
;;;429          if (srcclk == RCC_USART1CLKSOURCE_PCLK1)
;;;430          {
;;;431            frequency = HAL_RCC_GetPCLK1Freq();
;;;432          }
;;;433          /* Check if HSI is ready and if USART1 clock selection is HSI */
;;;434          else if ((srcclk == RCC_USART1CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
;;;435          {
;;;436            frequency = HSI_VALUE;
00000a  4c24              LDR      r4,|L2.156|
00000c  4924              LDR      r1,|L2.160|
00000e  2a01              CMP      r2,#1                 ;399
000010  d01f              BEQ      |L2.82|
000012  2a20              CMP      r2,#0x20              ;399
000014  d036              BEQ      |L2.132|
000016  005c              LSLS     r4,r3,#1              ;399
000018  42a2              CMP      r2,r4                 ;399
00001a  d10d              BNE      |L2.56|
00001c  6a0a              LDR      r2,[r1,#0x20]         ;404
00001e  2403              MOVS     r4,#3                 ;404
000020  0224              LSLS     r4,r4,#8              ;404
000022  4022              ANDS     r2,r2,r4              ;404
000024  154d              ASRS     r5,r1,#21             ;412
000026  1fd6              SUBS     r6,r2,#7              ;407
000028  3ef9              SUBS     r6,r6,#0xf9           ;407
00002a  d006              BEQ      |L2.58|
00002c  42aa              CMP      r2,r5                 ;412
00002e  d109              BNE      |L2.68|
000030  6a49              LDR      r1,[r1,#0x24]         ;412
000032  0789              LSLS     r1,r1,#30             ;412
000034  d500              BPL      |L2.56|
000036  481b              LDR      r0,|L2.164|
                  |L2.56|
;;;437          }
;;;438          /* Check if USART1 clock selection is SYSCLK */
;;;439          else if (srcclk == RCC_USART1CLKSOURCE_SYSCLK)
;;;440          {
;;;441            frequency = HAL_RCC_GetSysClockFreq();
;;;442          }
;;;443          /* Check if LSE is ready  and if USART1 clock selection is LSE */
;;;444          else if ((srcclk == RCC_USART1CLKSOURCE_LSE) && (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)))
;;;445          {
;;;446            frequency = LSE_VALUE;
;;;447          }
;;;448          break;
;;;449        }
;;;450    #if defined(RCC_CFGR3_USART2SW)
;;;451      case RCC_PERIPHCLK_USART2:
;;;452        {
;;;453          /* Get the current USART2 source */
;;;454          srcclk = __HAL_RCC_GET_USART2_SOURCE();
;;;455    
;;;456          /* Check if USART2 clock selection is PCLK1 */
;;;457          if (srcclk == RCC_USART2CLKSOURCE_PCLK1)
;;;458          {
;;;459            frequency = HAL_RCC_GetPCLK1Freq();
;;;460          }
;;;461          /* Check if HSI is ready and if USART2 clock selection is HSI */
;;;462          else if ((srcclk == RCC_USART2CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
;;;463          {
;;;464            frequency = HSI_VALUE;
;;;465          }
;;;466          /* Check if USART2 clock selection is SYSCLK */
;;;467          else if (srcclk == RCC_USART2CLKSOURCE_SYSCLK)
;;;468          {
;;;469            frequency = HAL_RCC_GetSysClockFreq();
;;;470          }
;;;471          /* Check if LSE is ready  and if USART2 clock selection is LSE */
;;;472          else if ((srcclk == RCC_USART2CLKSOURCE_LSE) && (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)))
;;;473          {
;;;474            frequency = LSE_VALUE;
;;;475          }
;;;476          break;
;;;477        }
;;;478    #endif /* RCC_CFGR3_USART2SW */
;;;479    #if defined(RCC_CFGR3_USART3SW)
;;;480      case RCC_PERIPHCLK_USART3:
;;;481        {
;;;482          /* Get the current USART3 source */
;;;483          srcclk = __HAL_RCC_GET_USART3_SOURCE();
;;;484    
;;;485          /* Check if USART3 clock selection is PCLK1 */
;;;486          if (srcclk == RCC_USART3CLKSOURCE_PCLK1)
;;;487          {
;;;488            frequency = HAL_RCC_GetPCLK1Freq();
;;;489          }
;;;490          /* Check if HSI is ready and if USART3 clock selection is HSI */
;;;491          else if ((srcclk == RCC_USART3CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
;;;492          {
;;;493            frequency = HSI_VALUE;
;;;494          }
;;;495          /* Check if USART3 clock selection is SYSCLK */
;;;496          else if (srcclk == RCC_USART3CLKSOURCE_SYSCLK)
;;;497          {
;;;498            frequency = HAL_RCC_GetSysClockFreq();
;;;499          }
;;;500          /* Check if LSE is ready  and if USART3 clock selection is LSE */
;;;501          else if ((srcclk == RCC_USART3CLKSOURCE_LSE) && (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)))
;;;502          {
;;;503            frequency = LSE_VALUE;
;;;504          }
;;;505          break;
;;;506        }
;;;507    #endif /* RCC_CFGR3_USART3SW */
;;;508      case RCC_PERIPHCLK_I2C1:
;;;509        {
;;;510          /* Get the current I2C1 source */
;;;511          srcclk = __HAL_RCC_GET_I2C1_SOURCE();
;;;512    
;;;513          /* Check if HSI is ready and if I2C1 clock selection is HSI */
;;;514          if ((srcclk == RCC_I2C1CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
;;;515          {
;;;516            frequency = HSI_VALUE;
;;;517          }
;;;518          /* Check if I2C1 clock selection is SYSCLK */
;;;519          else if (srcclk == RCC_I2C1CLKSOURCE_SYSCLK)
;;;520          {
;;;521            frequency = HAL_RCC_GetSysClockFreq();
;;;522          }
;;;523          break;
;;;524        }
;;;525    #if defined(USB)
;;;526      case RCC_PERIPHCLK_USB:
;;;527        {
;;;528          /* Get the current USB source */
;;;529          srcclk = __HAL_RCC_GET_USB_SOURCE();
;;;530    
;;;531          /* Check if PLL is ready and if USB clock selection is PLL */
;;;532          if ((srcclk == RCC_USBCLKSOURCE_PLL) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLRDY)))
;;;533          {
;;;534            /* Get PLL clock source and multiplication factor ----------------------*/
;;;535            pllmull      = RCC->CFGR & RCC_CFGR_PLLMUL;
;;;536            pllsource    = RCC->CFGR & RCC_CFGR_PLLSRC;
;;;537            pllmull      = (pllmull >> RCC_CFGR_PLLMUL_BITNUMBER) + 2U;
;;;538            predivfactor = (RCC->CFGR2 & RCC_CFGR2_PREDIV) + 1U;
;;;539    
;;;540            if (pllsource == RCC_CFGR_PLLSRC_HSE_PREDIV)
;;;541            {
;;;542              /* HSE used as PLL clock source : frequency = HSE/PREDIV * PLLMUL */
;;;543              frequency = (HSE_VALUE/predivfactor) * pllmull;
;;;544            }
;;;545    #if defined(RCC_CR2_HSI48ON)
;;;546            else if (pllsource == RCC_CFGR_PLLSRC_HSI48_PREDIV)
;;;547            {
;;;548              /* HSI48 used as PLL clock source : frequency = HSI48/PREDIV * PLLMUL */
;;;549              frequency = (HSI48_VALUE / predivfactor) * pllmull;
;;;550            }
;;;551    #endif /* RCC_CR2_HSI48ON */
;;;552            else
;;;553            {
;;;554    #if defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F078xx) || defined(STM32F072xB) || defined(STM32F070xB)
;;;555              /* HSI used as PLL clock source : frequency = HSI/PREDIV * PLLMUL */
;;;556              frequency = (HSI_VALUE / predivfactor) * pllmull;
;;;557    #else
;;;558              /* HSI used as PLL clock source : frequency = HSI/2U * PLLMUL */
;;;559              frequency = (HSI_VALUE >> 1U) * pllmull;
;;;560    #endif /* STM32F042x6 || STM32F048xx || STM32F072xB || STM32F078xx || STM32F070xB */
;;;561            }
;;;562          }
;;;563    #if defined(RCC_CR2_HSI48ON)
;;;564          /* Check if HSI48 is ready and if USB clock selection is HSI48 */
;;;565          else if ((srcclk == RCC_USBCLKSOURCE_HSI48) && (HAL_IS_BIT_SET(RCC->CR2, RCC_CR2_HSI48RDY)))
;;;566          {
;;;567            frequency = HSI48_VALUE;
;;;568          }
;;;569    #endif /* RCC_CR2_HSI48ON */
;;;570          break;
;;;571        }
;;;572    #endif /* USB */
;;;573    #if defined(CEC)
;;;574      case RCC_PERIPHCLK_CEC:
;;;575        {
;;;576          /* Get the current CEC source */
;;;577          srcclk = __HAL_RCC_GET_CEC_SOURCE();
;;;578    
;;;579          /* Check if HSI is ready and if CEC clock selection is HSI */
;;;580          if ((srcclk == RCC_CECCLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
;;;581          {
;;;582            frequency = HSI_VALUE;
;;;583          }
;;;584          /* Check if LSE is ready  and if CEC clock selection is LSE */
;;;585          else if ((srcclk == RCC_CECCLKSOURCE_LSE) && (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)))
;;;586          {
;;;587            frequency = LSE_VALUE;
;;;588          }
;;;589          break;
;;;590        }
;;;591    #endif /* CEC */
;;;592      default: 
;;;593        {
;;;594          break;
;;;595        }
;;;596      }
;;;597      return(frequency);
;;;598    }
000038  bd70              POP      {r4-r6,pc}
                  |L2.58|
00003a  6a09              LDR      r1,[r1,#0x20]         ;407
00003c  0789              LSLS     r1,r1,#30             ;407
00003e  d5fb              BPL      |L2.56|
                  |L2.64|
000040  4618              MOV      r0,r3                 ;409
                  |L2.66|
000042  bd70              POP      {r4-r6,pc}
                  |L2.68|
000044  42a2              CMP      r2,r4                 ;417
000046  d1fc              BNE      |L2.66|
000048  6809              LDR      r1,[r1,#0]            ;417
00004a  0389              LSLS     r1,r1,#14             ;417
00004c  d5f9              BPL      |L2.66|
00004e  4816              LDR      r0,|L2.168|
                  |L2.80|
000050  bd70              POP      {r4-r6,pc}
                  |L2.82|
000052  6b0a              LDR      r2,[r1,#0x30]         ;426
000054  0792              LSLS     r2,r2,#30             ;426
000056  0f92              LSRS     r2,r2,#30             ;426
000058  d009              BEQ      |L2.110|
00005a  2a03              CMP      r2,#3                 ;434
00005c  d00a              BEQ      |L2.116|
00005e  2a01              CMP      r2,#1                 ;439
000060  d00d              BEQ      |L2.126|
000062  2a02              CMP      r2,#2                 ;444
000064  d1f4              BNE      |L2.80|
000066  6a09              LDR      r1,[r1,#0x20]         ;444
000068  0789              LSLS     r1,r1,#30             ;444
00006a  d4e9              BMI      |L2.64|
00006c  bd70              POP      {r4-r6,pc}
                  |L2.110|
00006e  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
                  |L2.114|
000072  bd70              POP      {r4-r6,pc}
                  |L2.116|
000074  6809              LDR      r1,[r1,#0]            ;434
000076  0789              LSLS     r1,r1,#30             ;434
000078  d5fb              BPL      |L2.114|
                  |L2.122|
00007a  4620              MOV      r0,r4                 ;436
00007c  bd70              POP      {r4-r6,pc}
                  |L2.126|
00007e  f7fffffe          BL       HAL_RCC_GetSysClockFreq
000082  bd70              POP      {r4-r6,pc}
                  |L2.132|
000084  6b0a              LDR      r2,[r1,#0x30]         ;511
000086  2310              MOVS     r3,#0x10              ;511
000088  401a              ANDS     r2,r2,r3              ;511
00008a  d002              BEQ      |L2.146|
00008c  2a10              CMP      r2,#0x10              ;519
00008e  d0f6              BEQ      |L2.126|
000090  bd70              POP      {r4-r6,pc}
                  |L2.146|
000092  6809              LDR      r1,[r1,#0]            ;514
000094  0789              LSLS     r1,r1,#30             ;514
000096  d4f0              BMI      |L2.122|
000098  bd70              POP      {r4-r6,pc}
;;;599    
                          ENDP

00009a  0000              DCW      0x0000
                  |L2.156|
                          DCD      0x007a1200
                  |L2.160|
                          DCD      0x40021000
                  |L2.164|
                          DCD      0x00009c40
                  |L2.168|
                          DCD      0x0003d090

                          AREA ||i.HAL_RCCEx_PeriphCLKConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_PeriphCLKConfig PROC
;;;119      */
;;;120    HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
000000  b5f8              PUSH     {r3-r7,lr}
;;;121    {
000002  4604              MOV      r4,r0
;;;122      uint32_t tickstart = 0U;
;;;123      uint32_t temp_reg = 0U;
;;;124    
;;;125      /* Check the parameters */
;;;126      assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
;;;127      
;;;128      /*---------------------------- RTC configuration -------------------------------*/
;;;129      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
000004  6800              LDR      r0,[r0,#0]
000006  03c0              LSLS     r0,r0,#15
000008  d55b              BPL      |L3.194|
;;;130      {
;;;131        /* check for RTC Parameters used to output RTCCLK */
;;;132        assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
;;;133        
;;;134        FlagStatus       pwrclkchanged = RESET;
;;;135    
;;;136        /* As soon as function is called to change RTC clock source, activation of the 
;;;137           power domain is done. */
;;;138        /* Requires to enable write access to Backup Domain of necessary */
;;;139        if(__HAL_RCC_PWR_IS_CLK_DISABLED())
00000a  4839              LDR      r0,|L3.240|
00000c  2700              MOVS     r7,#0                 ;134
00000e  69c0              LDR      r0,[r0,#0x1c]
000010  00c0              LSLS     r0,r0,#3
000012  d408              BMI      |L3.38|
;;;140        {
;;;141        __HAL_RCC_PWR_CLK_ENABLE();
000014  4836              LDR      r0,|L3.240|
000016  69c2              LDR      r2,[r0,#0x1c]
000018  0401              LSLS     r1,r0,#16
00001a  430a              ORRS     r2,r2,r1
00001c  61c2              STR      r2,[r0,#0x1c]
00001e  69c0              LDR      r0,[r0,#0x1c]
000020  4008              ANDS     r0,r0,r1
;;;142          pwrclkchanged = SET;
000022  2701              MOVS     r7,#1
000024  9000              STR      r0,[sp,#0]
                  |L3.38|
;;;143        }
;;;144        
;;;145        if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
000026  4d33              LDR      r5,|L3.244|
000028  6828              LDR      r0,[r5,#0]
00002a  05c0              LSLS     r0,r0,#23
00002c  d411              BMI      |L3.82|
;;;146        {
;;;147          /* Enable write access to Backup domain */
;;;148          SET_BIT(PWR->CR, PWR_CR_DBP);
00002e  6828              LDR      r0,[r5,#0]
000030  15a9              ASRS     r1,r5,#22
000032  4308              ORRS     r0,r0,r1
000034  6028              STR      r0,[r5,#0]
;;;149          
;;;150          /* Wait for Backup domain Write protection disable */
;;;151          tickstart = HAL_GetTick();
000036  f7fffffe          BL       HAL_GetTick
00003a  4606              MOV      r6,r0
;;;152          
;;;153          while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
00003c  6828              LDR      r0,[r5,#0]
00003e  05c0              LSLS     r0,r0,#23
000040  d407              BMI      |L3.82|
                  |L3.66|
;;;154          {
;;;155            if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
000042  f7fffffe          BL       HAL_GetTick
000046  1b80              SUBS     r0,r0,r6
000048  2864              CMP      r0,#0x64
00004a  d826              BHI      |L3.154|
;;;156            {
;;;157              return HAL_TIMEOUT;
00004c  6828              LDR      r0,[r5,#0]
00004e  05c0              LSLS     r0,r0,#23
000050  d5f7              BPL      |L3.66|
                  |L3.82|
;;;158            }
;;;159          }
;;;160        }
;;;161        
;;;162        /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */ 
;;;163        temp_reg = (RCC->BDCR & RCC_BDCR_RTCSEL);
000052  4827              LDR      r0,|L3.240|
000054  6a00              LDR      r0,[r0,#0x20]
000056  2103              MOVS     r1,#3
000058  0209              LSLS     r1,r1,#8
00005a  4008              ANDS     r0,r0,r1
;;;164        if((temp_reg != 0x00000000U) && (temp_reg != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
00005c  d023              BEQ      |L3.166|
00005e  6862              LDR      r2,[r4,#4]
000060  400a              ANDS     r2,r2,r1
000062  4282              CMP      r2,r0
000064  d01f              BEQ      |L3.166|
;;;165        {
;;;166          /* Store the content of BDCR register before the reset of Backup Domain */
;;;167          temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
000066  4e22              LDR      r6,|L3.240|
000068  6a30              LDR      r0,[r6,#0x20]
;;;168          /* RTC Clock selection can be changed only if the Backup Domain is reset */
;;;169          __HAL_RCC_BACKUPRESET_FORCE();
00006a  6a32              LDR      r2,[r6,#0x20]
00006c  4388              BICS     r0,r0,r1              ;167
00006e  2101              MOVS     r1,#1
000070  0409              LSLS     r1,r1,#16
000072  430a              ORRS     r2,r2,r1
000074  6232              STR      r2,[r6,#0x20]
;;;170          __HAL_RCC_BACKUPRESET_RELEASE();
000076  6a32              LDR      r2,[r6,#0x20]
000078  438a              BICS     r2,r2,r1
00007a  6232              STR      r2,[r6,#0x20]
;;;171          /* Restore the Content of BDCR register */
;;;172          RCC->BDCR = temp_reg;
00007c  6230              STR      r0,[r6,#0x20]
;;;173          
;;;174          /* Wait for LSERDY if LSE was enabled */
;;;175          if (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSEON))
00007e  07c0              LSLS     r0,r0,#31
000080  d011              BEQ      |L3.166|
;;;176          {
;;;177            /* Get Start Tick */
;;;178            tickstart = HAL_GetTick();
000082  f7fffffe          BL       HAL_GetTick
;;;179            
;;;180            /* Wait till LSE is ready */  
;;;181            while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
000086  6a31              LDR      r1,[r6,#0x20]
000088  4605              MOV      r5,r0                 ;178
00008a  0789              LSLS     r1,r1,#30
00008c  d40b              BMI      |L3.166|
;;;182            {
;;;183              if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
00008e  4e1a              LDR      r6,|L3.248|
                  |L3.144|
000090  f7fffffe          BL       HAL_GetTick
000094  1b40              SUBS     r0,r0,r5
000096  42b0              CMP      r0,r6
000098  d901              BLS      |L3.158|
                  |L3.154|
;;;184              {
;;;185                return HAL_TIMEOUT;
00009a  2003              MOVS     r0,#3
;;;186              }
;;;187            }
;;;188          }
;;;189        }
;;;190        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
;;;191    
;;;192        /* Require to disable power clock if necessary */
;;;193        if(pwrclkchanged == SET)
;;;194        {
;;;195          __HAL_RCC_PWR_CLK_DISABLE();
;;;196        }
;;;197      }
;;;198    
;;;199      /*------------------------------- USART1 Configuration ------------------------*/ 
;;;200      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
;;;201      {
;;;202        /* Check the parameters */
;;;203        assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));
;;;204        
;;;205        /* Configure the USART1 clock source */
;;;206        __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
;;;207      }
;;;208      
;;;209    #if defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
;;;210     || defined(STM32F091xC) || defined(STM32F098xx)
;;;211      /*----------------------------- USART2 Configuration --------------------------*/ 
;;;212      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
;;;213      {
;;;214        /* Check the parameters */
;;;215        assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));
;;;216        
;;;217        /* Configure the USART2 clock source */
;;;218        __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
;;;219      }
;;;220    #endif /* STM32F071xB || STM32F072xB || STM32F078xx || */
;;;221           /* STM32F091xC || STM32F098xx */
;;;222    
;;;223    #if defined(STM32F091xC) || defined(STM32F098xx)
;;;224      /*----------------------------- USART3 Configuration --------------------------*/ 
;;;225      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
;;;226      {
;;;227        /* Check the parameters */
;;;228        assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));
;;;229        
;;;230        /* Configure the USART3 clock source */
;;;231        __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
;;;232      }
;;;233    #endif /* STM32F091xC || STM32F098xx */  
;;;234    
;;;235      /*------------------------------ I2C1 Configuration ------------------------*/ 
;;;236      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
;;;237      {
;;;238        /* Check the parameters */
;;;239        assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));
;;;240        
;;;241        /* Configure the I2C1 clock source */
;;;242        __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
;;;243      }
;;;244    
;;;245    #if defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB) || defined(STM32F070x6)
;;;246      /*------------------------------ USB Configuration ------------------------*/ 
;;;247      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
;;;248      {
;;;249        /* Check the parameters */
;;;250        assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
;;;251        
;;;252        /* Configure the USB clock source */
;;;253        __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
;;;254      }
;;;255    #endif /* STM32F042x6 || STM32F048xx || STM32F072xB || STM32F078xx || STM32F070xB || STM32F070x6 */
;;;256    
;;;257    #if defined(STM32F042x6) || defined(STM32F048xx)\
;;;258     || defined(STM32F051x8) || defined(STM32F058xx)\
;;;259     || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
;;;260     || defined(STM32F091xC) || defined(STM32F098xx)
;;;261      /*------------------------------ CEC clock Configuration -------------------*/ 
;;;262      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
;;;263      {
;;;264        /* Check the parameters */
;;;265        assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));
;;;266        
;;;267        /* Configure the CEC clock source */
;;;268        __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
;;;269      }
;;;270    #endif /* STM32F042x6 || STM32F048xx ||                */
;;;271           /* STM32F051x8 || STM32F058xx ||                */
;;;272           /* STM32F071xB || STM32F072xB || STM32F078xx || */
;;;273           /* STM32F091xC || STM32F098xx */
;;;274      
;;;275      return HAL_OK;
;;;276    }
00009c  bdf8              POP      {r3-r7,pc}
                  |L3.158|
00009e  4814              LDR      r0,|L3.240|
0000a0  6a00              LDR      r0,[r0,#0x20]         ;185
0000a2  0780              LSLS     r0,r0,#30             ;185
0000a4  d5f4              BPL      |L3.144|
                  |L3.166|
0000a6  4812              LDR      r0,|L3.240|
0000a8  6a01              LDR      r1,[r0,#0x20]         ;190
0000aa  2203              MOVS     r2,#3                 ;190
0000ac  0212              LSLS     r2,r2,#8              ;190
0000ae  4391              BICS     r1,r1,r2              ;190
0000b0  6862              LDR      r2,[r4,#4]            ;190
0000b2  4311              ORRS     r1,r1,r2              ;190
0000b4  6201              STR      r1,[r0,#0x20]         ;190
0000b6  2f00              CMP      r7,#0                 ;193
0000b8  d003              BEQ      |L3.194|
0000ba  69c2              LDR      r2,[r0,#0x1c]         ;195
0000bc  0401              LSLS     r1,r0,#16             ;195
0000be  438a              BICS     r2,r2,r1              ;195
0000c0  61c2              STR      r2,[r0,#0x1c]         ;195
                  |L3.194|
0000c2  7820              LDRB     r0,[r4,#0]            ;200
0000c4  07c0              LSLS     r0,r0,#31             ;200
0000c6  d006              BEQ      |L3.214|
0000c8  4809              LDR      r0,|L3.240|
0000ca  6b01              LDR      r1,[r0,#0x30]         ;206
0000cc  68a2              LDR      r2,[r4,#8]            ;206
0000ce  0889              LSRS     r1,r1,#2              ;206
0000d0  0089              LSLS     r1,r1,#2              ;206
0000d2  4311              ORRS     r1,r1,r2              ;206
0000d4  6301              STR      r1,[r0,#0x30]         ;206
                  |L3.214|
0000d6  7820              LDRB     r0,[r4,#0]            ;236
0000d8  0680              LSLS     r0,r0,#26             ;236
0000da  d506              BPL      |L3.234|
0000dc  4804              LDR      r0,|L3.240|
0000de  6b01              LDR      r1,[r0,#0x30]         ;242
0000e0  2210              MOVS     r2,#0x10              ;242
0000e2  4391              BICS     r1,r1,r2              ;242
0000e4  68e2              LDR      r2,[r4,#0xc]          ;242
0000e6  4311              ORRS     r1,r1,r2              ;242
0000e8  6301              STR      r1,[r0,#0x30]         ;242
                  |L3.234|
0000ea  2000              MOVS     r0,#0                 ;275
0000ec  bdf8              POP      {r3-r7,pc}
;;;277    
                          ENDP

0000ee  0000              DCW      0x0000
                  |L3.240|
                          DCD      0x40021000
                  |L3.244|
                          DCD      0x40007000
                  |L3.248|
                          DCD      0x00001388

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F0_V1.9.0\\Drivers\\STM32F0xx_HAL_Driver\\Src\\stm32f0xx_hal_rcc_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f0xx_hal_rcc_ex_c_bed13b44____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F0_V1.9.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___22_stm32f0xx_hal_rcc_ex_c_bed13b44____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f0xx_hal_rcc_ex_c_bed13b44____REVSH|
#line 402
|__asm___22_stm32f0xx_hal_rcc_ex_c_bed13b44____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
