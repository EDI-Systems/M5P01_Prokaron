; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f7xx_hal_uart.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f7xx_hal_uart.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Core -I..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f7xx_hal_uart.crf ..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_uart.c]
                          THUMB

                          AREA ||i.HAL_HalfDuplex_EnableReceiver||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableReceiver PROC
;;;2083     */
;;;2084   HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
000000  6e81              LDR      r1,[r0,#0x68]
;;;2085   {
;;;2086     /* Process Locked */
;;;2087     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;2088     huart->gState = HAL_UART_STATE_BUSY;
;;;2089   
;;;2090     /* Clear TE and RE bits */
;;;2091     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));
;;;2092     /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
;;;2093     SET_BIT(huart->Instance->CR1, USART_CR1_RE);
;;;2094   
;;;2095     huart->gState = HAL_UART_STATE_READY;
;;;2096     /* Process Unlocked */
;;;2097     __HAL_UNLOCK(huart);
;;;2098   
;;;2099     return HAL_OK;
;;;2100   }
000008  4770              BXEQ     lr
00000a  2201              MOVS     r2,#1                 ;2087
00000c  2124              MOVS     r1,#0x24              ;2088
00000e  6682              STR      r2,[r0,#0x68]         ;2097
000010  2320              MOVS     r3,#0x20              ;2095
000012  66c1              STR      r1,[r0,#0x6c]         ;2088
000014  2200              MOVS     r2,#0                 ;2097
000016  6801              LDR      r1,[r0,#0]            ;2091
000018  f8d1c000          LDR      r12,[r1,#0]           ;2091
00001c  f02c0c0c          BIC      r12,r12,#0xc          ;2091
000020  f8c1c000          STR      r12,[r1,#0]           ;2091
000024  6801              LDR      r1,[r0,#0]            ;2093
000026  f8d1c000          LDR      r12,[r1,#0]           ;2093
00002a  f04c0c04          ORR      r12,r12,#4            ;2093
00002e  f8c1c000          STR      r12,[r1,#0]           ;2093
000032  66c3              STR      r3,[r0,#0x6c]         ;2095
000034  6682              STR      r2,[r0,#0x68]         ;2099
000036  4610              MOV      r0,r2                 ;2099
000038  4770              BX       lr
;;;2101   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_EnableTransmitter||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableTransmitter PROC
;;;2060     */
;;;2061   HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
000000  6e81              LDR      r1,[r0,#0x68]
;;;2062   {
;;;2063     /* Process Locked */
;;;2064     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;2065     huart->gState = HAL_UART_STATE_BUSY;
;;;2066   
;;;2067     /* Clear TE and RE bits */
;;;2068     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));
;;;2069     /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
;;;2070     SET_BIT(huart->Instance->CR1, USART_CR1_TE);
;;;2071   
;;;2072     huart->gState= HAL_UART_STATE_READY;
;;;2073     /* Process Unlocked */
;;;2074     __HAL_UNLOCK(huart);
;;;2075   
;;;2076     return HAL_OK;
;;;2077   }
000008  4770              BXEQ     lr
00000a  2201              MOVS     r2,#1                 ;2064
00000c  2124              MOVS     r1,#0x24              ;2065
00000e  6682              STR      r2,[r0,#0x68]         ;2074
000010  2320              MOVS     r3,#0x20              ;2072
000012  66c1              STR      r1,[r0,#0x6c]         ;2065
000014  2200              MOVS     r2,#0                 ;2074
000016  6801              LDR      r1,[r0,#0]            ;2068
000018  f8d1c000          LDR      r12,[r1,#0]           ;2068
00001c  f02c0c0c          BIC      r12,r12,#0xc          ;2068
000020  f8c1c000          STR      r12,[r1,#0]           ;2068
000024  6801              LDR      r1,[r0,#0]            ;2070
000026  f8d1c000          LDR      r12,[r1,#0]           ;2070
00002a  f04c0c08          ORR      r12,r12,#8            ;2070
00002e  f8c1c000          STR      r12,[r1,#0]           ;2070
000032  66c3              STR      r3,[r0,#0x6c]         ;2072
000034  6682              STR      r2,[r0,#0x68]         ;2076
000036  4610              MOV      r0,r2                 ;2076
000038  4770              BX       lr
;;;2078   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_Init||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_Init PROC
;;;305      */
;;;306    HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
000000  2800              CMP      r0,#0
;;;307    {
;;;308      /* Check the UART handle allocation */
;;;309      if(huart == NULL)
;;;310      {
;;;311        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;312      }
;;;313    
;;;314      if(huart->gState == HAL_UART_STATE_RESET)
;;;315      {
;;;316        /* Allocate lock resource and initialize it */
;;;317        huart->Lock = HAL_UNLOCKED;
;;;318    
;;;319        /* Init the low level hardware : GPIO, CLOCK */
;;;320        HAL_UART_MspInit(huart);
;;;321      }
;;;322    
;;;323      huart->gState = HAL_UART_STATE_BUSY;
;;;324    
;;;325      /* Disable the Peripheral */
;;;326      __HAL_UART_DISABLE(huart);
;;;327    
;;;328      /* Set the UART Communication parameters */
;;;329      if (UART_SetConfig(huart) == HAL_ERROR)
;;;330      {
;;;331        return HAL_ERROR;
;;;332      }
;;;333    
;;;334      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;335      {
;;;336        UART_AdvFeatureConfig(huart);
;;;337      }
;;;338    
;;;339      /* In half-duplex mode, the following bits must be kept cleared:
;;;340      - LINEN and CLKEN bits in the USART_CR2 register,
;;;341      - SCEN and IREN bits in the USART_CR3 register.*/
;;;342      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;343      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
;;;344    
;;;345      /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;346      SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
;;;347    
;;;348      /* Enable the Peripheral */
;;;349      __HAL_UART_ENABLE(huart);
;;;350    
;;;351      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;352      return (UART_CheckIdleState(huart));
;;;353    }
000006  4770              BXEQ     lr
000008  b510              PUSH     {r4,lr}               ;307
00000a  4604              MOV      r4,r0                 ;307
00000c  6ec0              LDR      r0,[r0,#0x6c]         ;314
00000e  b920              CBNZ     r0,|L3.26|
000010  2000              MOVS     r0,#0                 ;317
000012  66a0              STR      r0,[r4,#0x68]         ;320
000014  4620              MOV      r0,r4                 ;320
000016  f7fffffe          BL       HAL_UART_MspInit
                  |L3.26|
00001a  2024              MOVS     r0,#0x24              ;323
00001c  66e0              STR      r0,[r4,#0x6c]         ;323
00001e  6820              LDR      r0,[r4,#0]            ;326
000020  6801              LDR      r1,[r0,#0]            ;326
000022  f0210101          BIC      r1,r1,#1              ;326
000026  6001              STR      r1,[r0,#0]            ;326
000028  4620              MOV      r0,r4                 ;329
00002a  f7fffffe          BL       UART_SetConfig
00002e  2801              CMP      r0,#1                 ;329
000030  bf08              IT       EQ
000032  bd10              POPEQ    {r4,pc}
000034  6a60              LDR      r0,[r4,#0x24]         ;334
000036  2800              CMP      r0,#0                 ;334
000038  bf1c              ITT      NE                    ;336
00003a  4620              MOVNE    r0,r4                 ;336
00003c  f7fffffe          BLNE     UART_AdvFeatureConfig
000040  6820              LDR      r0,[r4,#0]            ;342
000042  6841              LDR      r1,[r0,#4]            ;342
000044  f4214190          BIC      r1,r1,#0x4800         ;342
000048  6041              STR      r1,[r0,#4]            ;342
00004a  6820              LDR      r0,[r4,#0]            ;343
00004c  6881              LDR      r1,[r0,#8]            ;343
00004e  f0210122          BIC      r1,r1,#0x22           ;343
000052  6081              STR      r1,[r0,#8]            ;343
000054  6820              LDR      r0,[r4,#0]            ;346
000056  6881              LDR      r1,[r0,#8]            ;346
000058  f0410108          ORR      r1,r1,#8              ;346
00005c  6081              STR      r1,[r0,#8]            ;346
00005e  6820              LDR      r0,[r4,#0]            ;349
000060  6801              LDR      r1,[r0,#0]            ;349
000062  f0410101          ORR      r1,r1,#1              ;349
000066  6001              STR      r1,[r0,#0]            ;349
000068  4620              MOV      r0,r4                 ;352
00006a  e8bd4010          POP      {r4,lr}               ;352
00006e  f7ffbffe          B.W      UART_CheckIdleState
;;;354    
                          ENDP


                          AREA ||i.HAL_LIN_Init||, CODE, READONLY, ALIGN=1

                  HAL_LIN_Init PROC
;;;365      */
;;;366    HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
000000  2800              CMP      r0,#0
;;;367    {
;;;368      /* Check the UART handle allocation */
;;;369      if(huart == NULL)
;;;370      {
;;;371        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;372      }
;;;373    
;;;374      /* Check the parameters */
;;;375      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;376      assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
;;;377      assert_param(IS_LIN_WORD_LENGTH(huart->Init.WordLength));
;;;378    
;;;379      if(huart->gState == HAL_UART_STATE_RESET)
;;;380      {
;;;381        /* Allocate lock resource and initialize it */
;;;382        huart->Lock = HAL_UNLOCKED;
;;;383    
;;;384        /* Init the low level hardware : GPIO, CLOCK */
;;;385        HAL_UART_MspInit(huart);
;;;386      }
;;;387    
;;;388      huart->gState = HAL_UART_STATE_BUSY;
;;;389    
;;;390      /* Disable the Peripheral */
;;;391      __HAL_UART_DISABLE(huart);
;;;392    
;;;393      /* Set the UART Communication parameters */
;;;394      if (UART_SetConfig(huart) == HAL_ERROR)
;;;395      {
;;;396        return HAL_ERROR;
;;;397      }
;;;398    
;;;399      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;400      {
;;;401        UART_AdvFeatureConfig(huart);
;;;402      }
;;;403    
;;;404      /* In LIN mode, the following bits must be kept cleared:
;;;405      - LINEN and CLKEN bits in the USART_CR2 register,
;;;406      - SCEN and IREN bits in the USART_CR3 register.*/
;;;407      CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
;;;408      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
;;;409    
;;;410      /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;411      SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
;;;412    
;;;413      /* Set the USART LIN Break detection length. */
;;;414      MODIFY_REG(huart->Instance->CR2, USART_CR2_LBDL, BreakDetectLength);
;;;415    
;;;416      /* Enable the Peripheral */
;;;417      __HAL_UART_ENABLE(huart);
;;;418    
;;;419      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;420      return (UART_CheckIdleState(huart));
;;;421    }
000006  4770              BXEQ     lr
000008  b570              PUSH     {r4-r6,lr}            ;367
00000a  4604              MOV      r4,r0                 ;367
00000c  6ec0              LDR      r0,[r0,#0x6c]         ;379
00000e  460d              MOV      r5,r1                 ;367
000010  b920              CBNZ     r0,|L4.28|
000012  2000              MOVS     r0,#0                 ;382
000014  66a0              STR      r0,[r4,#0x68]         ;385
000016  4620              MOV      r0,r4                 ;385
000018  f7fffffe          BL       HAL_UART_MspInit
                  |L4.28|
00001c  2024              MOVS     r0,#0x24              ;388
00001e  66e0              STR      r0,[r4,#0x6c]         ;388
000020  6820              LDR      r0,[r4,#0]            ;391
000022  6801              LDR      r1,[r0,#0]            ;391
000024  f0210101          BIC      r1,r1,#1              ;391
000028  6001              STR      r1,[r0,#0]            ;391
00002a  4620              MOV      r0,r4                 ;394
00002c  f7fffffe          BL       UART_SetConfig
000030  2801              CMP      r0,#1                 ;394
000032  bf08              IT       EQ
000034  bd70              POPEQ    {r4-r6,pc}
000036  6a60              LDR      r0,[r4,#0x24]         ;399
000038  2800              CMP      r0,#0                 ;399
00003a  bf1c              ITT      NE                    ;401
00003c  4620              MOVNE    r0,r4                 ;401
00003e  f7fffffe          BLNE     UART_AdvFeatureConfig
000042  6820              LDR      r0,[r4,#0]            ;407
000044  6841              LDR      r1,[r0,#4]            ;407
000046  f4216100          BIC      r1,r1,#0x800          ;407
00004a  6041              STR      r1,[r0,#4]            ;407
00004c  6820              LDR      r0,[r4,#0]            ;408
00004e  6881              LDR      r1,[r0,#8]            ;408
000050  f021012a          BIC      r1,r1,#0x2a           ;408
000054  6081              STR      r1,[r0,#8]            ;408
000056  6820              LDR      r0,[r4,#0]            ;411
000058  6841              LDR      r1,[r0,#4]            ;411
00005a  f4414180          ORR      r1,r1,#0x4000         ;411
00005e  6041              STR      r1,[r0,#4]            ;411
000060  6820              LDR      r0,[r4,#0]            ;414
000062  6841              LDR      r1,[r0,#4]            ;414
000064  f0210120          BIC      r1,r1,#0x20           ;414
000068  4329              ORRS     r1,r1,r5              ;414
00006a  6041              STR      r1,[r0,#4]            ;414
00006c  6820              LDR      r0,[r4,#0]            ;417
00006e  6801              LDR      r1,[r0,#0]            ;417
000070  f0410101          ORR      r1,r1,#1              ;417
000074  6001              STR      r1,[r0,#0]            ;417
000076  4620              MOV      r0,r4                 ;420
000078  e8bd4070          POP      {r4-r6,lr}            ;420
00007c  f7ffbffe          B.W      UART_CheckIdleState
;;;422    
                          ENDP


                          AREA ||i.HAL_LIN_SendBreak||, CODE, READONLY, ALIGN=1

                  HAL_LIN_SendBreak PROC
;;;2107     */
;;;2108   HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
000000  6e81              LDR      r1,[r0,#0x68]
;;;2109   {
;;;2110     /* Check the parameters */
;;;2111     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;2112   
;;;2113     /* Process Locked */
;;;2114     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;2115   
;;;2116     huart->gState = HAL_UART_STATE_BUSY;
;;;2117   
;;;2118     /* Send break characters */
;;;2119     SET_BIT(huart->Instance->RQR, UART_SENDBREAK_REQUEST);
;;;2120   
;;;2121     huart->gState = HAL_UART_STATE_READY;
;;;2122   
;;;2123     /* Process Unlocked */
;;;2124     __HAL_UNLOCK(huart);
;;;2125   
;;;2126     return HAL_OK;
;;;2127   }
000008  4770              BXEQ     lr
00000a  2201              MOVS     r2,#1                 ;2114
00000c  2124              MOVS     r1,#0x24              ;2116
00000e  6682              STR      r2,[r0,#0x68]         ;2124
000010  2320              MOVS     r3,#0x20              ;2121
000012  66c1              STR      r1,[r0,#0x6c]         ;2116
000014  2200              MOVS     r2,#0                 ;2124
000016  6801              LDR      r1,[r0,#0]            ;2119
000018  f8d1c018          LDR      r12,[r1,#0x18]        ;2119
00001c  f04c0c02          ORR      r12,r12,#2            ;2119
000020  f8c1c018          STR      r12,[r1,#0x18]        ;2119
000024  66c3              STR      r3,[r0,#0x6c]         ;2121
000026  6682              STR      r2,[r0,#0x68]         ;2126
000028  4610              MOV      r0,r2                 ;2126
00002a  4770              BX       lr
;;;2128   
                          ENDP


                          AREA ||i.HAL_MultiProcessorEx_AddressLength_Set||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessorEx_AddressLength_Set PROC
;;;2141     */
;;;2142   HAL_StatusTypeDef HAL_MultiProcessorEx_AddressLength_Set(UART_HandleTypeDef *huart, uint32_t AddressLength)
000000  2800              CMP      r0,#0
;;;2143   {
;;;2144     /* Check the UART handle allocation */
;;;2145     if(huart == NULL)
;;;2146     {
;;;2147       return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;2148     }
;;;2149   
;;;2150     /* Check the address length parameter */
;;;2151     assert_param(IS_UART_ADDRESSLENGTH_DETECT(AddressLength));
;;;2152   
;;;2153     huart->gState = HAL_UART_STATE_BUSY;
;;;2154   
;;;2155     /* Disable the Peripheral */
;;;2156     __HAL_UART_DISABLE(huart);
;;;2157   
;;;2158     /* Set the address length */
;;;2159     MODIFY_REG(huart->Instance->CR2, USART_CR2_ADDM7, AddressLength);
;;;2160   
;;;2161     /* Enable the Peripheral */
;;;2162     __HAL_UART_ENABLE(huart);
;;;2163   
;;;2164     /* TEACK and/or REACK to check before moving huart->gState to Ready */
;;;2165     return (UART_CheckIdleState(huart));
;;;2166   }
000006  4770              BXEQ     lr
000008  2224              MOVS     r2,#0x24              ;2153
00000a  66c2              STR      r2,[r0,#0x6c]         ;2153
00000c  6802              LDR      r2,[r0,#0]            ;2156
00000e  6813              LDR      r3,[r2,#0]            ;2156
000010  f0230301          BIC      r3,r3,#1              ;2156
000014  6013              STR      r3,[r2,#0]            ;2156
000016  6802              LDR      r2,[r0,#0]            ;2159
000018  6853              LDR      r3,[r2,#4]            ;2159
00001a  f0230310          BIC      r3,r3,#0x10           ;2159
00001e  4319              ORRS     r1,r1,r3              ;2159
000020  6051              STR      r1,[r2,#4]            ;2159
000022  6801              LDR      r1,[r0,#0]            ;2162
000024  680a              LDR      r2,[r1,#0]            ;2162
000026  f0420201          ORR      r2,r2,#1              ;2162
00002a  600a              STR      r2,[r1,#0]            ;2162
00002c  f7ffbffe          B.W      UART_CheckIdleState
;;;2167   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_DisableMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_DisableMuteMode PROC
;;;1769     */
;;;1770   HAL_StatusTypeDef HAL_MultiProcessor_DisableMuteMode(UART_HandleTypeDef *huart)
000000  6e81              LDR      r1,[r0,#0x68]
;;;1771   {
;;;1772     /* Process Locked */
;;;1773     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;1774   
;;;1775     huart->gState = HAL_UART_STATE_BUSY;
;;;1776   
;;;1777      /* Disable USART mute mode by clearing the MME bit in the CR1 register */
;;;1778     CLEAR_BIT(huart->Instance->CR1, USART_CR1_MME);
;;;1779   
;;;1780     huart->gState = HAL_UART_STATE_READY;
;;;1781   
;;;1782     return (UART_CheckIdleState(huart));
;;;1783   }
000008  4770              BXEQ     lr
00000a  2201              MOVS     r2,#1                 ;1773
00000c  2124              MOVS     r1,#0x24              ;1775
00000e  6682              STR      r2,[r0,#0x68]         ;1780
000010  2220              MOVS     r2,#0x20              ;1780
000012  66c1              STR      r1,[r0,#0x6c]         ;1775
000014  6801              LDR      r1,[r0,#0]            ;1778
000016  680b              LDR      r3,[r1,#0]            ;1778
000018  f4235300          BIC      r3,r3,#0x2000         ;1778
00001c  600b              STR      r3,[r1,#0]            ;1778
00001e  66c2              STR      r2,[r0,#0x6c]         ;1780
000020  f7ffbffe          B.W      UART_CheckIdleState
;;;1784   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnableMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnableMuteMode PROC
;;;1748     */
;;;1749   HAL_StatusTypeDef HAL_MultiProcessor_EnableMuteMode(UART_HandleTypeDef *huart)
000000  6e81              LDR      r1,[r0,#0x68]
;;;1750   {
;;;1751     /* Process Locked */
;;;1752     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;1753   
;;;1754     huart->gState = HAL_UART_STATE_BUSY;
;;;1755   
;;;1756     /* Enable USART mute mode by setting the MME bit in the CR1 register */
;;;1757     SET_BIT(huart->Instance->CR1, USART_CR1_MME);
;;;1758   
;;;1759     huart->gState = HAL_UART_STATE_READY;
;;;1760   
;;;1761     return (UART_CheckIdleState(huart));
;;;1762   }
000008  4770              BXEQ     lr
00000a  2201              MOVS     r2,#1                 ;1752
00000c  2124              MOVS     r1,#0x24              ;1754
00000e  6682              STR      r2,[r0,#0x68]         ;1759
000010  2220              MOVS     r2,#0x20              ;1759
000012  66c1              STR      r1,[r0,#0x6c]         ;1754
000014  6801              LDR      r1,[r0,#0]            ;1757
000016  680b              LDR      r3,[r1,#0]            ;1757
000018  f4435300          ORR      r3,r3,#0x2000         ;1757
00001c  600b              STR      r3,[r1,#0]            ;1757
00001e  66c2              STR      r2,[r0,#0x6c]         ;1759
000020  f7ffbffe          B.W      UART_CheckIdleState
;;;1763   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnterMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnterMuteMode PROC
;;;1790     */
;;;1791   void HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
000000  6800              LDR      r0,[r0,#0]
;;;1792   {
;;;1793     __HAL_UART_SEND_REQ(huart, UART_MUTE_MODE_REQUEST);
000002  6981              LDR      r1,[r0,#0x18]
000004  f0410104          ORR      r1,r1,#4
000008  6181              STR      r1,[r0,#0x18]
;;;1794   }
00000a  4770              BX       lr
;;;1795   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_Init||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_Init PROC
;;;439      */
;;;440    HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
000000  2800              CMP      r0,#0
;;;441    {
;;;442      /* Check the UART handle allocation */
;;;443      if(huart == NULL)
;;;444      {
;;;445        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;446      }
;;;447    
;;;448      /* Check the wake up method parameter */
;;;449      assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
;;;450    
;;;451      if(huart->gState == HAL_UART_STATE_RESET)
;;;452      {
;;;453        /* Allocate lock resource and initialize it */
;;;454        huart->Lock = HAL_UNLOCKED;
;;;455    
;;;456        /* Init the low level hardware : GPIO, CLOCK */
;;;457        HAL_UART_MspInit(huart);
;;;458      }
;;;459    
;;;460      huart->gState = HAL_UART_STATE_BUSY;
;;;461    
;;;462      /* Disable the Peripheral */
;;;463      __HAL_UART_DISABLE(huart);
;;;464    
;;;465      /* Set the UART Communication parameters */
;;;466      if (UART_SetConfig(huart) == HAL_ERROR)
;;;467      {
;;;468        return HAL_ERROR;
;;;469      }
;;;470    
;;;471      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;472      {
;;;473        UART_AdvFeatureConfig(huart);
;;;474      }
;;;475    
;;;476      /* In multiprocessor mode, the following bits must be kept cleared:
;;;477      - LINEN and CLKEN bits in the USART_CR2 register,
;;;478      - SCEN, HDSEL and IREN  bits in the USART_CR3 register. */
;;;479      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;480      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;481    
;;;482      if (WakeUpMethod == UART_WAKEUPMETHOD_ADDRESSMARK)
;;;483      {
;;;484        /* If address mark wake up method is chosen, set the USART address node */
;;;485        MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, ((uint32_t)Address << UART_CR2_ADDRESS_LSB_POS));
;;;486      }
;;;487    
;;;488      /* Set the wake up method by setting the WAKE bit in the CR1 register */
;;;489      MODIFY_REG(huart->Instance->CR1, USART_CR1_WAKE, WakeUpMethod);
;;;490    
;;;491      /* Enable the Peripheral */
;;;492      __HAL_UART_ENABLE(huart);
;;;493    
;;;494      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;495      return (UART_CheckIdleState(huart));
;;;496    }
000006  4770              BXEQ     lr
000008  b570              PUSH     {r4-r6,lr}            ;441
00000a  4604              MOV      r4,r0                 ;441
00000c  6ec0              LDR      r0,[r0,#0x6c]         ;451
00000e  4615              MOV      r5,r2                 ;441
000010  460e              MOV      r6,r1                 ;441
000012  b920              CBNZ     r0,|L10.30|
000014  2000              MOVS     r0,#0                 ;454
000016  66a0              STR      r0,[r4,#0x68]         ;457
000018  4620              MOV      r0,r4                 ;457
00001a  f7fffffe          BL       HAL_UART_MspInit
                  |L10.30|
00001e  2024              MOVS     r0,#0x24              ;460
000020  66e0              STR      r0,[r4,#0x6c]         ;460
000022  6820              LDR      r0,[r4,#0]            ;463
000024  6801              LDR      r1,[r0,#0]            ;463
000026  f0210101          BIC      r1,r1,#1              ;463
00002a  6001              STR      r1,[r0,#0]            ;463
00002c  4620              MOV      r0,r4                 ;466
00002e  f7fffffe          BL       UART_SetConfig
000032  2801              CMP      r0,#1                 ;466
000034  bf08              IT       EQ
000036  bd70              POPEQ    {r4-r6,pc}
000038  6a60              LDR      r0,[r4,#0x24]         ;471
00003a  2800              CMP      r0,#0                 ;471
00003c  bf1c              ITT      NE                    ;473
00003e  4620              MOVNE    r0,r4                 ;473
000040  f7fffffe          BLNE     UART_AdvFeatureConfig
000044  6820              LDR      r0,[r4,#0]            ;482
000046  f5b56f00          CMP      r5,#0x800             ;482
00004a  6841              LDR      r1,[r0,#4]            ;479
00004c  f4214190          BIC      r1,r1,#0x4800         ;479
000050  6041              STR      r1,[r0,#4]            ;479
000052  6820              LDR      r0,[r4,#0]            ;480
000054  6881              LDR      r1,[r0,#8]            ;480
000056  f021012a          BIC      r1,r1,#0x2a           ;480
00005a  6081              STR      r1,[r0,#8]            ;480
00005c  d104              BNE      |L10.104|
00005e  6820              LDR      r0,[r4,#0]            ;485
000060  6841              LDR      r1,[r0,#4]            ;485
000062  f366611f          BFI      r1,r6,#24,#8          ;485
000066  6041              STR      r1,[r0,#4]            ;485
                  |L10.104|
000068  6820              LDR      r0,[r4,#0]            ;489
00006a  6801              LDR      r1,[r0,#0]            ;489
00006c  f4216100          BIC      r1,r1,#0x800          ;489
000070  4329              ORRS     r1,r1,r5              ;489
000072  6001              STR      r1,[r0,#0]            ;489
000074  6820              LDR      r0,[r4,#0]            ;492
000076  6801              LDR      r1,[r0,#0]            ;492
000078  f0410101          ORR      r1,r1,#1              ;492
00007c  6001              STR      r1,[r0,#0]            ;492
00007e  4620              MOV      r0,r4                 ;495
000080  e8bd4070          POP      {r4-r6,lr}            ;495
000084  f7ffbffe          B.W      UART_CheckIdleState
;;;497    
                          ENDP


                          AREA ||i.HAL_RS485Ex_Init||, CODE, READONLY, ALIGN=1

                  HAL_RS485Ex_Init PROC
;;;517      */
;;;518    HAL_StatusTypeDef HAL_RS485Ex_Init(UART_HandleTypeDef *huart, uint32_t Polarity, uint32_t AssertionTime, uint32_t DeassertionTime)
000000  2800              CMP      r0,#0
;;;519    {
;;;520      uint32_t temp = 0x0;
;;;521    
;;;522      /* Check the UART handle allocation */
;;;523      if(huart == NULL)
;;;524      {
;;;525        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;526      }
;;;527      /* Check the Driver Enable UART instance */
;;;528      assert_param(IS_UART_DRIVER_ENABLE_INSTANCE(huart->Instance));
;;;529    
;;;530      /* Check the Driver Enable polarity */
;;;531      assert_param(IS_UART_DE_POLARITY(Polarity));
;;;532    
;;;533      /* Check the Driver Enable assertion time */
;;;534      assert_param(IS_UART_ASSERTIONTIME(AssertionTime));
;;;535    
;;;536      /* Check the Driver Enable deassertion time */
;;;537      assert_param(IS_UART_DEASSERTIONTIME(DeassertionTime));
;;;538    
;;;539      if(huart->gState == HAL_UART_STATE_RESET)
;;;540      {
;;;541        /* Allocate lock resource and initialize it */
;;;542        huart->Lock = HAL_UNLOCKED;
;;;543    
;;;544        /* Init the low level hardware : GPIO, CLOCK, CORTEX */
;;;545        HAL_UART_MspInit(huart);
;;;546      }
;;;547    
;;;548      huart->gState = HAL_UART_STATE_BUSY;
;;;549    
;;;550      /* Disable the Peripheral */
;;;551      __HAL_UART_DISABLE(huart);
;;;552    
;;;553      /* Set the UART Communication parameters */
;;;554      if (UART_SetConfig(huart) == HAL_ERROR)
;;;555      {
;;;556        return HAL_ERROR;
;;;557      }
;;;558    
;;;559      if(huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;560      {
;;;561        UART_AdvFeatureConfig(huart);
;;;562      }
;;;563    
;;;564      /* Enable the Driver Enable mode by setting the DEM bit in the CR3 register */
;;;565      SET_BIT(huart->Instance->CR3, USART_CR3_DEM);
;;;566    
;;;567      /* Set the Driver Enable polarity */
;;;568      MODIFY_REG(huart->Instance->CR3, USART_CR3_DEP, Polarity);
;;;569    
;;;570      /* Set the Driver Enable assertion and deassertion times */
;;;571      temp = (AssertionTime << UART_CR1_DEAT_ADDRESS_LSB_POS);
;;;572      temp |= (DeassertionTime << UART_CR1_DEDT_ADDRESS_LSB_POS);
;;;573      MODIFY_REG(huart->Instance->CR1, (USART_CR1_DEDT|USART_CR1_DEAT), temp);
;;;574    
;;;575      /* Enable the Peripheral */
;;;576      __HAL_UART_ENABLE(huart);
;;;577    
;;;578      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;579      return (UART_CheckIdleState(huart));
;;;580    }
000006  4770              BXEQ     lr
000008  e92d41f0          PUSH     {r4-r8,lr}            ;519
00000c  4604              MOV      r4,r0                 ;519
00000e  6ec0              LDR      r0,[r0,#0x6c]         ;539
000010  461d              MOV      r5,r3                 ;519
000012  4616              MOV      r6,r2                 ;519
000014  460f              MOV      r7,r1                 ;519
000016  b920              CBNZ     r0,|L11.34|
000018  2000              MOVS     r0,#0                 ;542
00001a  66a0              STR      r0,[r4,#0x68]         ;545
00001c  4620              MOV      r0,r4                 ;545
00001e  f7fffffe          BL       HAL_UART_MspInit
                  |L11.34|
000022  2024              MOVS     r0,#0x24              ;548
000024  66e0              STR      r0,[r4,#0x6c]         ;548
000026  6820              LDR      r0,[r4,#0]            ;551
000028  6801              LDR      r1,[r0,#0]            ;551
00002a  f0210101          BIC      r1,r1,#1              ;551
00002e  6001              STR      r1,[r0,#0]            ;551
000030  4620              MOV      r0,r4                 ;554
000032  f7fffffe          BL       UART_SetConfig
000036  2801              CMP      r0,#1                 ;554
000038  bf08              IT       EQ
00003a  e8bd81f0          POPEQ    {r4-r8,pc}
00003e  6a60              LDR      r0,[r4,#0x24]         ;559
000040  2800              CMP      r0,#0                 ;559
000042  bf1c              ITT      NE                    ;561
000044  4620              MOVNE    r0,r4                 ;561
000046  f7fffffe          BLNE     UART_AdvFeatureConfig
00004a  0571              LSLS     r1,r6,#21             ;571
00004c  6820              LDR      r0,[r4,#0]            ;565
00004e  6882              LDR      r2,[r0,#8]            ;565
000050  ea414105          ORR      r1,r1,r5,LSL #16      ;572
000054  f4424280          ORR      r2,r2,#0x4000         ;565
000058  6082              STR      r2,[r0,#8]            ;565
00005a  6820              LDR      r0,[r4,#0]            ;568
00005c  6882              LDR      r2,[r0,#8]            ;568
00005e  f4224200          BIC      r2,r2,#0x8000         ;568
000062  433a              ORRS     r2,r2,r7              ;568
000064  6082              STR      r2,[r0,#8]            ;568
000066  6820              LDR      r0,[r4,#0]            ;573
000068  6802              LDR      r2,[r0,#0]            ;573
00006a  f36f4219          BFC      r2,#16,#10            ;573
00006e  4311              ORRS     r1,r1,r2              ;573
000070  6001              STR      r1,[r0,#0]            ;573
000072  6820              LDR      r0,[r4,#0]            ;576
000074  6801              LDR      r1,[r0,#0]            ;576
000076  f0410101          ORR      r1,r1,#1              ;576
00007a  6001              STR      r1,[r0,#0]            ;576
00007c  4620              MOV      r0,r4                 ;579
00007e  e8bd41f0          POP      {r4-r8,lr}            ;579
000082  f7ffbffe          B.W      UART_CheckIdleState
;;;581    
                          ENDP


                          AREA ||i.HAL_UART_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAPause PROC
;;;1076     */
;;;1077   HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
000000  6e81              LDR      r1,[r0,#0x68]
;;;1078   {
;;;1079     /* Process Locked */
;;;1080     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;1081   
;;;1082     if ((huart->gState == HAL_UART_STATE_BUSY_TX) &&
;;;1083         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)))
;;;1084     {
;;;1085       /* Disable the UART DMA Tx request */
;;;1086       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1087     }
;;;1088     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) &&
;;;1089         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
;;;1090     {
;;;1091       /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1092       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1093       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1094   
;;;1095       /* Disable the UART DMA Rx request */
;;;1096       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1097     }
;;;1098   
;;;1099     /* Process Unlocked */
;;;1100     __HAL_UNLOCK(huart);
;;;1101   
;;;1102     return HAL_OK;
;;;1103   }
000008  4770              BXEQ     lr
00000a  6ec2              LDR      r2,[r0,#0x6c]         ;1082
00000c  2101              MOVS     r1,#1                 ;1080
00000e  6681              STR      r1,[r0,#0x68]         ;1082
000010  2a21              CMP      r2,#0x21              ;1082
000012  d108              BNE      |L12.38|
000014  6801              LDR      r1,[r0,#0]            ;1082
000016  688a              LDR      r2,[r1,#8]            ;1082
000018  f0120f80          TST      r2,#0x80              ;1082
00001c  d003              BEQ      |L12.38|
00001e  688a              LDR      r2,[r1,#8]            ;1086
000020  f0220280          BIC      r2,r2,#0x80           ;1086
000024  608a              STR      r2,[r1,#8]            ;1086
                  |L12.38|
000026  6f01              LDR      r1,[r0,#0x70]         ;1088
000028  2922              CMP      r1,#0x22              ;1088
00002a  d112              BNE      |L12.82|
00002c  6801              LDR      r1,[r0,#0]            ;1088
00002e  688a              LDR      r2,[r1,#8]            ;1088
000030  f0120f40          TST      r2,#0x40              ;1088
000034  d00d              BEQ      |L12.82|
000036  680a              LDR      r2,[r1,#0]            ;1092
000038  f4227280          BIC      r2,r2,#0x100          ;1092
00003c  600a              STR      r2,[r1,#0]            ;1092
00003e  6801              LDR      r1,[r0,#0]            ;1093
000040  688a              LDR      r2,[r1,#8]            ;1093
000042  f0220201          BIC      r2,r2,#1              ;1093
000046  608a              STR      r2,[r1,#8]            ;1093
000048  6801              LDR      r1,[r0,#0]            ;1096
00004a  688a              LDR      r2,[r1,#8]            ;1096
00004c  f0220240          BIC      r2,r2,#0x40           ;1096
000050  608a              STR      r2,[r1,#8]            ;1096
                  |L12.82|
000052  2100              MOVS     r1,#0                 ;1100
000054  6681              STR      r1,[r0,#0x68]         ;1102
000056  4608              MOV      r0,r1                 ;1102
000058  4770              BX       lr
;;;1104   
                          ENDP


                          AREA ||i.HAL_UART_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAResume PROC
;;;1109     */
;;;1110   HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
000000  6e81              LDR      r1,[r0,#0x68]
;;;1111   {
;;;1112     /* Process Locked */
;;;1113     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;1114   
;;;1115     if(huart->gState == HAL_UART_STATE_BUSY_TX)
;;;1116     {
;;;1117       /* Enable the UART DMA Tx request */
;;;1118       SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1119     }
;;;1120     if(huart->RxState == HAL_UART_STATE_BUSY_RX)
;;;1121     {
;;;1122       /* Clear the Overrun flag before resuming the Rx transfer*/
;;;1123       __HAL_UART_CLEAR_IT(huart, UART_CLEAR_OREF);
;;;1124   
;;;1125       /* Reenable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1126       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1127       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1128   
;;;1129       /* Enable the UART DMA Rx request */
;;;1130       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1131     }
;;;1132   
;;;1133     /* If the UART peripheral is still not enabled, enable it */
;;;1134     if ((huart->Instance->CR1 & USART_CR1_UE) == 0U)
;;;1135     {
;;;1136       /* Enable UART peripheral */
;;;1137       __HAL_UART_ENABLE(huart);
;;;1138     }
;;;1139   
;;;1140     return HAL_OK;
;;;1141   }
000008  4770              BXEQ     lr
00000a  6ec2              LDR      r2,[r0,#0x6c]         ;1115
00000c  2101              MOVS     r1,#1                 ;1113
00000e  6681              STR      r1,[r0,#0x68]         ;1115
000010  2a21              CMP      r2,#0x21              ;1115
000012  d104              BNE      |L13.30|
000014  6801              LDR      r1,[r0,#0]            ;1118
000016  688a              LDR      r2,[r1,#8]            ;1118
000018  f0420280          ORR      r2,r2,#0x80           ;1118
00001c  608a              STR      r2,[r1,#8]            ;1118
                  |L13.30|
00001e  6f01              LDR      r1,[r0,#0x70]         ;1120
000020  2922              CMP      r1,#0x22              ;1120
000022  d111              BNE      |L13.72|
000024  6802              LDR      r2,[r0,#0]            ;1123
000026  2108              MOVS     r1,#8                 ;1123
000028  6211              STR      r1,[r2,#0x20]         ;1123
00002a  6801              LDR      r1,[r0,#0]            ;1126
00002c  680a              LDR      r2,[r1,#0]            ;1126
00002e  f4427280          ORR      r2,r2,#0x100          ;1126
000032  600a              STR      r2,[r1,#0]            ;1126
000034  6801              LDR      r1,[r0,#0]            ;1127
000036  688a              LDR      r2,[r1,#8]            ;1127
000038  f0420201          ORR      r2,r2,#1              ;1127
00003c  608a              STR      r2,[r1,#8]            ;1127
00003e  6801              LDR      r1,[r0,#0]            ;1130
000040  688a              LDR      r2,[r1,#8]            ;1130
000042  f0420240          ORR      r2,r2,#0x40           ;1130
000046  608a              STR      r2,[r1,#8]            ;1130
                  |L13.72|
000048  6800              LDR      r0,[r0,#0]            ;1134
00004a  6801              LDR      r1,[r0,#0]            ;1134
00004c  f0110f01          TST      r1,#1                 ;1134
000050  d103              BNE      |L13.90|
000052  6801              LDR      r1,[r0,#0]            ;1137
000054  f0410101          ORR      r1,r1,#1              ;1137
000058  6001              STR      r1,[r0,#0]            ;1137
                  |L13.90|
00005a  2000              MOVS     r0,#0                 ;1140
00005c  4770              BX       lr
;;;1142   
                          ENDP


                          AREA ||i.HAL_UART_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAStop PROC
;;;1147     */
;;;1148   HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1149   {
000002  4604              MOV      r4,r0
;;;1150     /* The Lock is not implemented on this API to allow the user application
;;;1151        to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback() /
;;;1152        HAL_UART_TxHalfCpltCallback / HAL_UART_RxHalfCpltCallback:
;;;1153        indeed, when HAL_DMA_Abort() API is called, the DMA TX/RX Transfer or Half Transfer complete
;;;1154        interrupt is generated if the DMA transfer interruption occurs at the middle or at the end of
;;;1155        the stream and the corresponding call back is executed. */
;;;1156   
;;;1157     /* Stop UART DMA Tx request if ongoing */
;;;1158     if ((huart->gState == HAL_UART_STATE_BUSY_TX) &&
000004  6ec0              LDR      r0,[r0,#0x6c]
000006  2520              MOVS     r5,#0x20
000008  2821              CMP      r0,#0x21
00000a  d113              BNE      |L14.52|
;;;1159         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)))
00000c  6820              LDR      r0,[r4,#0]
00000e  6881              LDR      r1,[r0,#8]
000010  f0110f80          TST      r1,#0x80
000014  d00e              BEQ      |L14.52|
;;;1160     {
;;;1161       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000016  6881              LDR      r1,[r0,#8]
000018  f0210180          BIC      r1,r1,#0x80
00001c  6081              STR      r1,[r0,#8]
;;;1162   
;;;1163       /* Abort the UART DMA Tx channel */
;;;1164       if(huart->hdmatx != NULL)
00001e  6e20              LDR      r0,[r4,#0x60]
000020  2800              CMP      r0,#0
;;;1165       {
;;;1166         HAL_DMA_Abort(huart->hdmatx);
000022  bf18              IT       NE
000024  f7fffffe          BLNE     HAL_DMA_Abort
000028  6820              LDR      r0,[r4,#0]
00002a  6801              LDR      r1,[r0,#0]
00002c  f02101c0          BIC      r1,r1,#0xc0
000030  6001              STR      r1,[r0,#0]
000032  66e5              STR      r5,[r4,#0x6c]
                  |L14.52|
;;;1167       }
;;;1168   
;;;1169       UART_EndTxTransfer(huart);
;;;1170     }
;;;1171   
;;;1172     /* Stop UART DMA Rx request if ongoing */
;;;1173     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) &&
000034  6f20              LDR      r0,[r4,#0x70]
000036  2822              CMP      r0,#0x22
000038  d118              BNE      |L14.108|
;;;1174         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
00003a  6820              LDR      r0,[r4,#0]
00003c  6881              LDR      r1,[r0,#8]
00003e  f0110f40          TST      r1,#0x40
000042  d013              BEQ      |L14.108|
;;;1175     {
;;;1176       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000044  6881              LDR      r1,[r0,#8]
000046  f0210140          BIC      r1,r1,#0x40
00004a  6081              STR      r1,[r0,#8]
;;;1177   
;;;1178       /* Abort the UART DMA Rx channel */
;;;1179       if(huart->hdmarx != NULL)
00004c  6e60              LDR      r0,[r4,#0x64]
00004e  2800              CMP      r0,#0
;;;1180       {
;;;1181         HAL_DMA_Abort(huart->hdmarx);
000050  bf18              IT       NE
000052  f7fffffe          BLNE     HAL_DMA_Abort
000056  6820              LDR      r0,[r4,#0]
000058  6801              LDR      r1,[r0,#0]
00005a  f4217190          BIC      r1,r1,#0x120
00005e  6001              STR      r1,[r0,#0]
000060  6820              LDR      r0,[r4,#0]
000062  6881              LDR      r1,[r0,#8]
000064  f0210101          BIC      r1,r1,#1
000068  6081              STR      r1,[r0,#8]
00006a  6725              STR      r5,[r4,#0x70]
                  |L14.108|
;;;1182       }
;;;1183   
;;;1184       UART_EndRxTransfer(huart);
;;;1185     }
;;;1186   
;;;1187     return HAL_OK;
00006c  2000              MOVS     r0,#0
;;;1188   }
00006e  bd70              POP      {r4-r6,pc}
;;;1189   
                          ENDP


                          AREA ||i.HAL_UART_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_DeInit PROC
;;;586      */
;;;587    HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
000000  2800              CMP      r0,#0
;;;588    {
;;;589      /* Check the UART handle allocation */
;;;590      if(huart == NULL)
;;;591      {
;;;592        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;593      }
;;;594    
;;;595      /* Check the parameters */
;;;596      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;597    
;;;598      huart->gState = HAL_UART_STATE_BUSY;
;;;599    
;;;600      /* Disable the Peripheral */
;;;601      __HAL_UART_DISABLE(huart);
;;;602    
;;;603      huart->Instance->CR1 = 0x0U;
;;;604      huart->Instance->CR2 = 0x0U;
;;;605      huart->Instance->CR3 = 0x0U;
;;;606    
;;;607      /* DeInit the low level hardware */
;;;608      HAL_UART_MspDeInit(huart);
;;;609    
;;;610      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;611      huart->gState    = HAL_UART_STATE_RESET;
;;;612      huart->RxState   = HAL_UART_STATE_RESET;
;;;613    
;;;614      /* Process Unlock */
;;;615      __HAL_UNLOCK(huart);
;;;616    
;;;617      return HAL_OK;
;;;618    }
000006  4770              BXEQ     lr
000008  b570              PUSH     {r4-r6,lr}            ;588
00000a  4604              MOV      r4,r0                 ;588
00000c  2024              MOVS     r0,#0x24              ;598
00000e  2500              MOVS     r5,#0                 ;603
000010  66e0              STR      r0,[r4,#0x6c]         ;598
000012  6820              LDR      r0,[r4,#0]            ;601
000014  6801              LDR      r1,[r0,#0]            ;601
000016  f0210101          BIC      r1,r1,#1              ;601
00001a  6001              STR      r1,[r0,#0]            ;601
00001c  6820              LDR      r0,[r4,#0]            ;603
00001e  6005              STR      r5,[r0,#0]            ;603
000020  6820              LDR      r0,[r4,#0]            ;604
000022  6045              STR      r5,[r0,#4]            ;604
000024  6820              LDR      r0,[r4,#0]            ;605
000026  6085              STR      r5,[r0,#8]            ;605
000028  4620              MOV      r0,r4                 ;608
00002a  f7fffffe          BL       HAL_UART_MspDeInit
00002e  6765              STR      r5,[r4,#0x74]         ;610
000030  66e5              STR      r5,[r4,#0x6c]         ;611
000032  6725              STR      r5,[r4,#0x70]         ;612
000034  2000              MOVS     r0,#0                 ;617
000036  66a5              STR      r5,[r4,#0x68]         ;617
000038  bd70              POP      {r4-r6,pc}
;;;619    
                          ENDP


                          AREA ||i.HAL_UART_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_ErrorCallback PROC
;;;1550     */
;;;1551    __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1552   {
;;;1553     /* Prevent unused argument(s) compilation warning */
;;;1554     UNUSED(huart);
;;;1555   
;;;1556     /* NOTE : This function should not be modified, when the callback is needed,
;;;1557               the HAL_UART_ErrorCallback can be implemented in the user file
;;;1558      */
;;;1559   }
;;;1560   
                          ENDP


                          AREA ||i.HAL_UART_GetError||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetError PROC
;;;1817   */
;;;1818   uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
000000  6f40              LDR      r0,[r0,#0x74]
;;;1819   {
;;;1820     return huart->ErrorCode;
;;;1821   }
000002  4770              BX       lr
;;;1822   
                          ENDP


                          AREA ||i.HAL_UART_GetState||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetState PROC
;;;1802     */
;;;1803   HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
000000  6ec1              LDR      r1,[r0,#0x6c]
;;;1804   {
;;;1805     uint32_t temp1= 0x00U, temp2 = 0x00U;
;;;1806     temp1 = huart->gState;
;;;1807     temp2 = huart->RxState;
000002  6f00              LDR      r0,[r0,#0x70]
;;;1808   
;;;1809     return (HAL_UART_StateTypeDef)(temp1 | temp2);
000004  4308              ORRS     r0,r0,r1
;;;1810   }
000006  4770              BX       lr
;;;1811   
                          ENDP


                          AREA ||i.HAL_UART_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_UART_IRQHandler PROC
;;;1194     */
;;;1195   void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1196   {
;;;1197     uint32_t isrflags   = READ_REG(huart->Instance->ISR);
000002  6801              LDR      r1,[r0,#0]
000004  4604              MOV      r4,r0                 ;1196
000006  2520              MOVS     r5,#0x20              ;1196
000008  69c8              LDR      r0,[r1,#0x1c]
;;;1198     uint32_t cr1its     = READ_REG(huart->Instance->CR1);
00000a  680a              LDR      r2,[r1,#0]
;;;1199     uint32_t cr3its     = READ_REG(huart->Instance->CR3);
00000c  688b              LDR      r3,[r1,#8]
;;;1200     uint32_t errorflags;
;;;1201   
;;;1202     /* If no error occurs */
;;;1203     errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE));
00000e  f0100f0f          TST      r0,#0xf
000012  d05b              BEQ      |L19.204|
;;;1204     if (errorflags == RESET)
;;;1205     {
;;;1206       /* UART in mode Receiver ---------------------------------------------------*/
;;;1207       if(((isrflags & USART_ISR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
;;;1208       {
;;;1209         UART_Receive_IT(huart);
;;;1210         return;
;;;1211       }
;;;1212     }
;;;1213   
;;;1214     /* If some errors occur */
;;;1215     if((errorflags != RESET) && ((cr3its & (USART_CR3_EIE | USART_CR1_PEIE)) != RESET))
000014  f2401c01          MOV      r12,#0x101
000018  ea130f0c          TST      r3,r12
00001c  f00080f2          BEQ.W    |L19.516|
;;;1216     {
;;;1217   
;;;1218       /* UART parity error interrupt occurred -------------------------------------*/
;;;1219       if(((isrflags & USART_ISR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
000020  f0100f01          TST      r0,#1
000024  bf18              IT       NE
000026  f4127f80          TSTNE    r2,#0x100
00002a  d007              BEQ      |L19.60|
;;;1220       {
;;;1221         __HAL_UART_CLEAR_IT(huart, UART_CLEAR_PEF);
00002c  f04f0c01          MOV      r12,#1
000030  f8c1c020          STR      r12,[r1,#0x20]
;;;1222   
;;;1223         huart->ErrorCode |= HAL_UART_ERROR_PE;
000034  6f61              LDR      r1,[r4,#0x74]
000036  f0410101          ORR      r1,r1,#1
00003a  6761              STR      r1,[r4,#0x74]
                  |L19.60|
;;;1224       }
;;;1225   
;;;1226       /* UART frame error interrupt occurred --------------------------------------*/
;;;1227       if(((isrflags & USART_ISR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
00003c  f0100f02          TST      r0,#2
000040  bf18              IT       NE
000042  f0130f01          TSTNE    r3,#1
000046  d008              BEQ      |L19.90|
;;;1228       {
;;;1229         __HAL_UART_CLEAR_IT(huart, UART_CLEAR_FEF);
000048  f8d4c000          LDR      r12,[r4,#0]
00004c  2102              MOVS     r1,#2
00004e  f8cc1020          STR      r1,[r12,#0x20]
;;;1230   
;;;1231         huart->ErrorCode |= HAL_UART_ERROR_FE;
000052  6f61              LDR      r1,[r4,#0x74]
000054  f0410104          ORR      r1,r1,#4
000058  6761              STR      r1,[r4,#0x74]
                  |L19.90|
;;;1232       }
;;;1233   
;;;1234       /* UART noise error interrupt occurred --------------------------------------*/
;;;1235       if(((isrflags & USART_ISR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
00005a  f0100f04          TST      r0,#4
00005e  bf18              IT       NE
000060  f0130f01          TSTNE    r3,#1
000064  d008              BEQ      |L19.120|
;;;1236       {
;;;1237         __HAL_UART_CLEAR_IT(huart, UART_CLEAR_NEF);
000066  f8d4c000          LDR      r12,[r4,#0]
00006a  2104              MOVS     r1,#4
00006c  f8cc1020          STR      r1,[r12,#0x20]
;;;1238   
;;;1239         huart->ErrorCode |= HAL_UART_ERROR_NE;
000070  6f61              LDR      r1,[r4,#0x74]
000072  f0410102          ORR      r1,r1,#2
000076  6761              STR      r1,[r4,#0x74]
                  |L19.120|
;;;1240       }
;;;1241       
;;;1242       /* UART Over-Run interrupt occurred -----------------------------------------*/
;;;1243       if(((isrflags & USART_ISR_ORE) != RESET) &&
000078  f0100f08          TST      r0,#8
00007c  d00c              BEQ      |L19.152|
;;;1244          (((cr1its & USART_CR1_RXNEIE) != RESET) || ((cr3its & USART_CR3_EIE) != RESET)))
00007e  f0020120          AND      r1,r2,#0x20
000082  f0030301          AND      r3,r3,#1
000086  4319              ORRS     r1,r1,r3
000088  d006              BEQ      |L19.152|
;;;1245       {
;;;1246         __HAL_UART_CLEAR_IT(huart, UART_CLEAR_OREF);
00008a  6823              LDR      r3,[r4,#0]
00008c  2108              MOVS     r1,#8
00008e  6219              STR      r1,[r3,#0x20]
;;;1247   
;;;1248         huart->ErrorCode |= HAL_UART_ERROR_ORE;
000090  6f61              LDR      r1,[r4,#0x74]
000092  f0410108          ORR      r1,r1,#8
000096  6761              STR      r1,[r4,#0x74]
                  |L19.152|
;;;1249       }
;;;1250   
;;;1251       /* Call UART Error Call back function if need be --------------------------*/
;;;1252       if(huart->ErrorCode != HAL_UART_ERROR_NONE)
000098  6f61              LDR      r1,[r4,#0x74]
00009a  2900              CMP      r1,#0
;;;1253       {
;;;1254         /* UART in mode Receiver ---------------------------------------------------*/
;;;1255         if(((isrflags & USART_ISR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
;;;1256         {
;;;1257           UART_Receive_IT(huart);
;;;1258         }
;;;1259   
;;;1260         /* If Overrun error occurs, or if any error occurs in DMA mode reception,
;;;1261            consider error as blocking */
;;;1262         if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) ||
;;;1263             (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
;;;1264         {
;;;1265           /* Blocking error : transfer is aborted
;;;1266              Set the UART state ready to be able to start again the process,
;;;1267              Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
;;;1268           UART_EndRxTransfer(huart);
;;;1269   
;;;1270           /* Disable the UART DMA Rx request if enabled */
;;;1271           if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
;;;1272           {
;;;1273             CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1274   
;;;1275             /* Abort the UART DMA Rx channel */
;;;1276             if(huart->hdmarx != NULL)
;;;1277             {
;;;1278               /* Set the UART DMA Abort callback :
;;;1279               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
;;;1280               huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
;;;1281   
;;;1282               /* Abort DMA RX */
;;;1283               if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
;;;1284               {
;;;1285                 /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
;;;1286                 huart->hdmarx->XferAbortCallback(huart->hdmarx);
;;;1287               }
;;;1288             }
;;;1289             else
;;;1290             {
;;;1291               /* Call user error callback */
;;;1292               HAL_UART_ErrorCallback(huart);
;;;1293             }
;;;1294           }
;;;1295           else
;;;1296           {
;;;1297             /* Call user error callback */
;;;1298             HAL_UART_ErrorCallback(huart);
;;;1299           }
;;;1300         }
;;;1301         else
;;;1302         {
;;;1303           /* Non Blocking error : transfer could go on.
;;;1304              Error is notified to user through user error callback */
;;;1305           HAL_UART_ErrorCallback(huart);
;;;1306           huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1307         }
;;;1308       }
;;;1309       return;
;;;1310   
;;;1311     } /* End if some error occurs */
;;;1312   
;;;1313     /* UART in mode Transmitter ------------------------------------------------*/
;;;1314     if(((isrflags & USART_ISR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
;;;1315     {
;;;1316       UART_Transmit_IT(huart);
;;;1317       return;
;;;1318     }
;;;1319   
;;;1320     /* UART in mode Transmitter (transmission end) -----------------------------*/
;;;1321     if(((isrflags & USART_ISR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
;;;1322     {
;;;1323       UART_EndTransmit_IT(huart);
;;;1324       return;
;;;1325     }
;;;1326   
;;;1327   }
00009c  bf08              IT       EQ
00009e  bd70              POPEQ    {r4-r6,pc}
0000a0  f0100f20          TST      r0,#0x20              ;1255
0000a4  bf18              IT       NE                    ;1255
0000a6  f0120f20          TSTNE    r2,#0x20              ;1255
0000aa  d00a              BEQ      |L19.194|
0000ac  6f22              LDR      r2,[r4,#0x70]         ;1255
0000ae  4620              MOV      r0,r4                 ;1257
0000b0  f8b4105c          LDRH     r1,[r4,#0x5c]         ;1257
0000b4  2a22              CMP      r2,#0x22              ;1257
0000b6  d045              BEQ      |L19.324|
0000b8  6820              LDR      r0,[r4,#0]            ;1257
0000ba  6981              LDR      r1,[r0,#0x18]         ;1257
0000bc  f0410108          ORR      r1,r1,#8              ;1257
0000c0  6181              STR      r1,[r0,#0x18]         ;1257
                  |L19.194|
0000c2  6f60              LDR      r0,[r4,#0x74]         ;1262
0000c4  f0100f08          TST      r0,#8                 ;1262
0000c8  d16d              BNE      |L19.422|
0000ca  e067              B        |L19.412|
                  |L19.204|
0000cc  f0100f20          TST      r0,#0x20              ;1207
0000d0  bf18              IT       NE                    ;1207
0000d2  f0120f20          TSTNE    r2,#0x20              ;1207
0000d6  d07d              BEQ      |L19.468|
0000d8  6f23              LDR      r3,[r4,#0x70]         ;1207
0000da  4620              MOV      r0,r4                 ;1209
0000dc  f8b4205c          LDRH     r2,[r4,#0x5c]         ;1209
0000e0  2b22              CMP      r3,#0x22              ;1209
0000e2  d004              BEQ      |L19.238|
0000e4  6988              LDR      r0,[r1,#0x18]         ;1209
0000e6  f0400008          ORR      r0,r0,#8              ;1209
0000ea  6188              STR      r0,[r1,#0x18]         ;1209
0000ec  bd70              POP      {r4-r6,pc}
                  |L19.238|
0000ee  6883              LDR      r3,[r0,#8]
0000f0  f5b35f80          CMP      r3,#0x1000
0000f4  bf04              ITT      EQ
0000f6  6903              LDREQ    r3,[r0,#0x10]
0000f8  2b00              CMPEQ    r3,#0
0000fa  6a4b              LDR      r3,[r1,#0x24]
0000fc  6d41              LDR      r1,[r0,#0x54]
0000fe  ea030202          AND      r2,r3,r2
000102  d01a              BEQ      |L19.314|
000104  1c4b              ADDS     r3,r1,#1
000106  6543              STR      r3,[r0,#0x54]
000108  f8812000          STRB.W   r2,[r1,#0]
                  |L19.268|
00010c  f8b0105a          LDRH     r1,[r0,#0x5a]
000110  1e49              SUBS     r1,r1,#1
000112  0409              LSLS     r1,r1,#16
000114  0c09              LSRS     r1,r1,#16
000116  f8a0105a          STRH     r1,[r0,#0x5a]
00011a  bf18              IT       NE
00011c  bd70              POPNE    {r4-r6,pc}
00011e  6801              LDR      r1,[r0,#0]
000120  680a              LDR      r2,[r1,#0]
000122  f4227290          BIC      r2,r2,#0x120
000126  600a              STR      r2,[r1,#0]
000128  6801              LDR      r1,[r0,#0]
00012a  688a              LDR      r2,[r1,#8]
00012c  f0220201          BIC      r2,r2,#1
000130  608a              STR      r2,[r1,#8]
000132  6705              STR      r5,[r0,#0x70]
000134  f7fffffe          BL       HAL_UART_RxCpltCallback
000138  bd70              POP      {r4-r6,pc}
                  |L19.314|
00013a  800a              STRH     r2,[r1,#0]
00013c  6d41              LDR      r1,[r0,#0x54]
00013e  1c89              ADDS     r1,r1,#2
000140  6541              STR      r1,[r0,#0x54]
000142  e7e3              B        |L19.268|
                  |L19.324|
000144  6882              LDR      r2,[r0,#8]
000146  f5b25f80          CMP      r2,#0x1000
00014a  bf04              ITT      EQ
00014c  6902              LDREQ    r2,[r0,#0x10]
00014e  2a00              CMPEQ    r2,#0
000150  6803              LDR      r3,[r0,#0]
000152  6d42              LDR      r2,[r0,#0x54]
000154  6a5b              LDR      r3,[r3,#0x24]
000156  d01b              BEQ      |L19.400|
000158  f1020c01          ADD      r12,r2,#1
00015c  f8c0c054          STR      r12,[r0,#0x54]
000160  4019              ANDS     r1,r1,r3
000162  7011              STRB     r1,[r2,#0]
                  |L19.356|
000164  f8b0105a          LDRH     r1,[r0,#0x5a]
000168  1e49              SUBS     r1,r1,#1
00016a  0409              LSLS     r1,r1,#16
00016c  0c09              LSRS     r1,r1,#16
00016e  f8a0105a          STRH     r1,[r0,#0x5a]
000172  d1a6              BNE      |L19.194|
000174  6801              LDR      r1,[r0,#0]
000176  680a              LDR      r2,[r1,#0]
000178  f4227290          BIC      r2,r2,#0x120
00017c  600a              STR      r2,[r1,#0]
00017e  6801              LDR      r1,[r0,#0]
000180  688a              LDR      r2,[r1,#8]
000182  f0220201          BIC      r2,r2,#1
000186  608a              STR      r2,[r1,#8]
000188  6705              STR      r5,[r0,#0x70]
00018a  f7fffffe          BL       HAL_UART_RxCpltCallback
00018e  e798              B        |L19.194|
                  |L19.400|
000190  4019              ANDS     r1,r1,r3
000192  8011              STRH     r1,[r2,#0]
000194  6d41              LDR      r1,[r0,#0x54]
000196  1c89              ADDS     r1,r1,#2
000198  6541              STR      r1,[r0,#0x54]
00019a  e7e3              B        |L19.356|
                  |L19.412|
00019c  6820              LDR      r0,[r4,#0]            ;1263
00019e  6880              LDR      r0,[r0,#8]            ;1263
0001a0  f0100f40          TST      r0,#0x40              ;1263
0001a4  d028              BEQ      |L19.504|
                  |L19.422|
0001a6  6820              LDR      r0,[r4,#0]            ;1263
0001a8  6801              LDR      r1,[r0,#0]            ;1263
0001aa  f4217190          BIC      r1,r1,#0x120          ;1263
0001ae  6001              STR      r1,[r0,#0]            ;1263
0001b0  6820              LDR      r0,[r4,#0]            ;1263
0001b2  6881              LDR      r1,[r0,#8]            ;1263
0001b4  f0210101          BIC      r1,r1,#1              ;1263
0001b8  6081              STR      r1,[r0,#8]            ;1263
0001ba  6725              STR      r5,[r4,#0x70]         ;1263
0001bc  6820              LDR      r0,[r4,#0]            ;1271
0001be  6881              LDR      r1,[r0,#8]            ;1271
0001c0  f0110f40          TST      r1,#0x40              ;1271
0001c4  d014              BEQ      |L19.496|
0001c6  6881              LDR      r1,[r0,#8]            ;1273
0001c8  f0210140          BIC      r1,r1,#0x40           ;1273
0001cc  6081              STR      r1,[r0,#8]            ;1273
0001ce  6e60              LDR      r0,[r4,#0x64]         ;1276
0001d0  b170              CBZ      r0,|L19.496|
0001d2  e000              B        |L19.470|
                  |L19.468|
0001d4  e016              B        |L19.516|
                  |L19.470|
0001d6  492c              LDR      r1,|L19.648|
0001d8  6541              STR      r1,[r0,#0x54]         ;1283
0001da  6e60              LDR      r0,[r4,#0x64]         ;1283
0001dc  f7fffffe          BL       HAL_DMA_Abort_IT
0001e0  2800              CMP      r0,#0                 ;1283
0001e2  bf08              IT       EQ
0001e4  bd70              POPEQ    {r4-r6,pc}
0001e6  6e60              LDR      r0,[r4,#0x64]         ;1286
0001e8  6d41              LDR      r1,[r0,#0x54]         ;1286
0001ea  e8bd4070          POP      {r4-r6,lr}            ;1286
0001ee  4708              BX       r1                    ;1286
                  |L19.496|
0001f0  4620              MOV      r0,r4                 ;1298
0001f2  f7fffffe          BL       HAL_UART_ErrorCallback
0001f6  bd70              POP      {r4-r6,pc}
                  |L19.504|
0001f8  4620              MOV      r0,r4                 ;1305
0001fa  f7fffffe          BL       HAL_UART_ErrorCallback
0001fe  2000              MOVS     r0,#0                 ;1306
000200  6760              STR      r0,[r4,#0x74]         ;1306
000202  bd70              POP      {r4-r6,pc}
                  |L19.516|
000204  f0100f80          TST      r0,#0x80              ;1314
000208  bf18              IT       NE                    ;1314
00020a  f0120f80          TSTNE    r2,#0x80              ;1314
00020e  d02b              BEQ      |L19.616|
000210  6ee0              LDR      r0,[r4,#0x6c]         ;1314
000212  2821              CMP      r0,#0x21              ;1314
000214  bf18              IT       NE
000216  bd70              POPNE    {r4-r6,pc}
000218  f8b40052          LDRH     r0,[r4,#0x52]
00021c  b190              CBZ      r0,|L19.580|
00021e  68a0              LDR      r0,[r4,#8]
000220  f5b05f80          CMP      r0,#0x1000
000224  bf04              ITT      EQ
000226  6920              LDREQ    r0,[r4,#0x10]
000228  2800              CMPEQ    r0,#0
00022a  6ce0              LDR      r0,[r4,#0x4c]
00022c  d014              BEQ      |L19.600|
00022e  1c41              ADDS     r1,r0,#1
000230  64e1              STR      r1,[r4,#0x4c]
000232  6821              LDR      r1,[r4,#0]
000234  7800              LDRB     r0,[r0,#0]
000236  6288              STR      r0,[r1,#0x28]
                  |L19.568|
000238  f8b40052          LDRH     r0,[r4,#0x52]
00023c  1e40              SUBS     r0,r0,#1
00023e  f8a40052          STRH     r0,[r4,#0x52]
000242  bd70              POP      {r4-r6,pc}
                  |L19.580|
000244  6808              LDR      r0,[r1,#0]
000246  f0200080          BIC      r0,r0,#0x80
00024a  6008              STR      r0,[r1,#0]
00024c  6820              LDR      r0,[r4,#0]
00024e  6801              LDR      r1,[r0,#0]
000250  f0410140          ORR      r1,r1,#0x40
000254  6001              STR      r1,[r0,#0]
000256  bd70              POP      {r4-r6,pc}
                  |L19.600|
000258  8800              LDRH     r0,[r0,#0]
00025a  f3c00008          UBFX     r0,r0,#0,#9
00025e  6288              STR      r0,[r1,#0x28]
000260  6ce0              LDR      r0,[r4,#0x4c]
000262  1c80              ADDS     r0,r0,#2
000264  64e0              STR      r0,[r4,#0x4c]
000266  e7e7              B        |L19.568|
                  |L19.616|
000268  f0100f40          TST      r0,#0x40              ;1321
00026c  bf14              ITE      NE                    ;1321
00026e  f0120f40          TSTNE    r2,#0x40              ;1321
000272  bd70              POPEQ    {r4-r6,pc}
000274  680a              LDR      r2,[r1,#0]
000276  4620              MOV      r0,r4                 ;1323
000278  f0220240          BIC      r2,r2,#0x40           ;1323
00027c  600a              STR      r2,[r1,#0]            ;1323
00027e  66e5              STR      r5,[r4,#0x6c]         ;1323
000280  f7fffffe          BL       HAL_UART_TxCpltCallback
000284  bd70              POP      {r4-r6,pc}
;;;1328   
                          ENDP

000286  0000              DCW      0x0000
                  |L19.648|
                          DCD      UART_DMAAbortOnError

                          AREA ||i.HAL_UART_Init||, CODE, READONLY, ALIGN=1

                  HAL_UART_Init PROC
;;;242      */
;;;243    HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
000000  2800              CMP      r0,#0
;;;244    {
;;;245      /* Check the UART handle allocation */
;;;246      if(huart == NULL)
;;;247      {
;;;248        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;249      }
;;;250    
;;;251      if(huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
;;;252      {
;;;253        /* Check the parameters */
;;;254        assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
;;;255      }
;;;256      else
;;;257      {
;;;258        /* Check the parameters */
;;;259        assert_param(IS_UART_INSTANCE(huart->Instance));
;;;260      }
;;;261    
;;;262      if(huart->gState == HAL_UART_STATE_RESET)
;;;263      {
;;;264        /* Allocate lock resource and initialize it */
;;;265        huart->Lock = HAL_UNLOCKED;
;;;266    
;;;267        /* Init the low level hardware : GPIO, CLOCK */
;;;268        HAL_UART_MspInit(huart);
;;;269      }
;;;270    
;;;271      huart->gState = HAL_UART_STATE_BUSY;
;;;272    
;;;273      /* Disable the Peripheral */
;;;274      __HAL_UART_DISABLE(huart);
;;;275    
;;;276      /* Set the UART Communication parameters */
;;;277      if (UART_SetConfig(huart) == HAL_ERROR)
;;;278      {
;;;279        return HAL_ERROR;
;;;280      }
;;;281    
;;;282      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;283      {
;;;284        UART_AdvFeatureConfig(huart);
;;;285      }
;;;286    
;;;287      /* In asynchronous mode, the following bits must be kept cleared:
;;;288      - LINEN and CLKEN bits in the USART_CR2 register,
;;;289      - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
;;;290      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;291      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;292    
;;;293      /* Enable the Peripheral */
;;;294      __HAL_UART_ENABLE(huart);
;;;295    
;;;296      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;297      return (UART_CheckIdleState(huart));
;;;298    }
000006  4770              BXEQ     lr
000008  b510              PUSH     {r4,lr}               ;244
00000a  4604              MOV      r4,r0                 ;244
00000c  6ec0              LDR      r0,[r0,#0x6c]         ;262
00000e  b920              CBNZ     r0,|L20.26|
000010  2000              MOVS     r0,#0                 ;265
000012  66a0              STR      r0,[r4,#0x68]         ;268
000014  4620              MOV      r0,r4                 ;268
000016  f7fffffe          BL       HAL_UART_MspInit
                  |L20.26|
00001a  2024              MOVS     r0,#0x24              ;271
00001c  66e0              STR      r0,[r4,#0x6c]         ;271
00001e  6820              LDR      r0,[r4,#0]            ;274
000020  6801              LDR      r1,[r0,#0]            ;274
000022  f0210101          BIC      r1,r1,#1              ;274
000026  6001              STR      r1,[r0,#0]            ;274
000028  4620              MOV      r0,r4                 ;277
00002a  f7fffffe          BL       UART_SetConfig
00002e  2801              CMP      r0,#1                 ;277
000030  bf08              IT       EQ
000032  bd10              POPEQ    {r4,pc}
000034  6a60              LDR      r0,[r4,#0x24]         ;282
000036  2800              CMP      r0,#0                 ;282
000038  bf1c              ITT      NE                    ;284
00003a  4620              MOVNE    r0,r4                 ;284
00003c  f7fffffe          BLNE     UART_AdvFeatureConfig
000040  6820              LDR      r0,[r4,#0]            ;290
000042  6841              LDR      r1,[r0,#4]            ;290
000044  f4214190          BIC      r1,r1,#0x4800         ;290
000048  6041              STR      r1,[r0,#4]            ;290
00004a  6820              LDR      r0,[r4,#0]            ;291
00004c  6881              LDR      r1,[r0,#8]            ;291
00004e  f021012a          BIC      r1,r1,#0x2a           ;291
000052  6081              STR      r1,[r0,#8]            ;291
000054  6820              LDR      r0,[r4,#0]            ;294
000056  6801              LDR      r1,[r0,#0]            ;294
000058  f0410101          ORR      r1,r1,#1              ;294
00005c  6001              STR      r1,[r0,#0]            ;294
00005e  4620              MOV      r0,r4                 ;297
000060  e8bd4010          POP      {r4,lr}               ;297
000064  f7ffbffe          B.W      UART_CheckIdleState
;;;299    
                          ENDP


                          AREA ||i.HAL_UART_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspDeInit PROC
;;;639      */
;;;640    __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;641    {
;;;642      /* Prevent unused argument(s) compilation warning */
;;;643      UNUSED(huart);
;;;644    
;;;645      /* NOTE : This function should not be modified, when the callback is needed,
;;;646                the HAL_UART_MspDeInit can be implemented in the user file
;;;647       */
;;;648    }
;;;649    
                          ENDP


                          AREA ||i.HAL_UART_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspInit PROC
;;;624      */
;;;625    __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;626    {
;;;627      /* Prevent unused argument(s) compilation warning */
;;;628      UNUSED(huart);
;;;629    
;;;630      /* NOTE : This function should not be modified, when the callback is needed,
;;;631                the HAL_UART_MspInit can be implemented in the user file
;;;632       */
;;;633    }
;;;634    
                          ENDP


                          AREA ||i.HAL_UART_Receive||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive PROC
;;;786      */
;;;787    HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;788    {
000004  4604              MOV      r4,r0
;;;789      uint16_t* tmp;
;;;790      uint16_t uhMask;
;;;791      uint32_t tickstart = 0U;
;;;792    
;;;793      /* Check that a Rx process is not already ongoing */
;;;794      if(huart->RxState == HAL_UART_STATE_READY)
000006  6f00              LDR      r0,[r0,#0x70]
000008  461d              MOV      r5,r3                 ;788
00000a  4617              MOV      r7,r2                 ;788
00000c  460e              MOV      r6,r1                 ;788
00000e  2820              CMP      r0,#0x20
000010  d17e              BNE      |L23.272|
;;;795      {
;;;796        if((pData == NULL ) || (Size == 0U))
000012  2e00              CMP      r6,#0
000014  bf12              ITEE     NE
000016  2f00              CMPNE    r7,#0
;;;797        {
;;;798          return  HAL_ERROR;
000018  2001              MOVEQ    r0,#1
;;;799        }
;;;800    
;;;801        /* Process Locked */
;;;802        __HAL_LOCK(huart);
;;;803    
;;;804        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;805        huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;806    
;;;807        /* Init tickstart for timeout managment*/
;;;808        tickstart = HAL_GetTick();
;;;809    
;;;810        huart->RxXferSize = Size;
;;;811        huart->RxXferCount = Size;
;;;812    
;;;813        /* Computation of UART mask to apply to RDR register */
;;;814        UART_MASK_COMPUTATION(huart);
;;;815        uhMask = huart->Mask;
;;;816    
;;;817        /* as long as data have to be received */
;;;818        while(huart->RxXferCount > 0U)
;;;819        {
;;;820          huart->RxXferCount--;
;;;821          if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;822          {
;;;823            return HAL_TIMEOUT;
;;;824          }
;;;825          if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;826          {
;;;827            tmp = (uint16_t*) pData ;
;;;828            *tmp = (uint16_t)(huart->Instance->RDR & uhMask);
;;;829            pData +=2U;
;;;830          }
;;;831          else
;;;832          {
;;;833            *pData++ = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
;;;834          }
;;;835        }
;;;836    
;;;837        /* At end of Rx process, restore huart->RxState to Ready */
;;;838        huart->RxState = HAL_UART_STATE_READY;
;;;839    
;;;840        /* Process Unlocked */
;;;841        __HAL_UNLOCK(huart);
;;;842    
;;;843        return HAL_OK;
;;;844      }
;;;845      else
;;;846      {
;;;847        return HAL_BUSY;
;;;848      }
;;;849    }
00001a  e8bd9ff0          POPEQ    {r4-r12,pc}
00001e  6ea0              LDR      r0,[r4,#0x68]         ;802
000020  2801              CMP      r0,#1                 ;802
000022  d075              BEQ      |L23.272|
000024  2001              MOVS     r0,#1                 ;802
000026  f04f0b00          MOV      r11,#0                ;804
00002a  f8c4b074          STR      r11,[r4,#0x74]        ;804
00002e  2122              MOVS     r1,#0x22              ;805
000030  66a0              STR      r0,[r4,#0x68]         ;804
000032  6721              STR      r1,[r4,#0x70]         ;805
000034  f7fffffe          BL       HAL_GetTick
000038  4680              MOV      r8,r0                 ;808
00003a  68a0              LDR      r0,[r4,#8]            ;810
00003c  21ff              MOVS     r1,#0xff              ;814
00003e  f8a47058          STRH     r7,[r4,#0x58]         ;810
000042  f5b05f80          CMP      r0,#0x1000            ;814
000046  f8a4705a          STRH     r7,[r4,#0x5a]         ;811
00004a  d006              BEQ      |L23.90|
00004c  f04f027f          MOV      r2,#0x7f              ;814
000050  b150              CBZ      r0,|L23.104|
000052  f1b05f80          CMP      r0,#0x10000000        ;814
000056  d00c              BEQ      |L23.114|
000058  e012              B        |L23.128|
                  |L23.90|
00005a  6920              LDR      r0,[r4,#0x10]         ;814
00005c  2800              CMP      r0,#0                 ;814
00005e  bf08              IT       EQ                    ;814
000060  f24010ff          MOVEQ    r0,#0x1ff             ;814
000064  d102              BNE      |L23.108|
000066  e009              B        |L23.124|
                  |L23.104|
000068  6920              LDR      r0,[r4,#0x10]         ;814
00006a  bba8              CBNZ     r0,|L23.216|
                  |L23.108|
00006c  f8a4105c          STRH     r1,[r4,#0x5c]         ;814
000070  e006              B        |L23.128|
                  |L23.114|
000072  6920              LDR      r0,[r4,#0x10]         ;814
000074  2800              CMP      r0,#0                 ;814
000076  bf18              IT       NE                    ;814
000078  203f              MOVNE    r0,#0x3f              ;814
00007a  d02e              BEQ      |L23.218|
                  |L23.124|
00007c  f8a4005c          STRH     r0,[r4,#0x5c]         ;814
                  |L23.128|
000080  f8b4905c          LDRH     r9,[r4,#0x5c]         ;815
000084  f0090aff          AND      r10,r9,#0xff          ;833
                  |L23.136|
000088  f8b4005a          LDRH     r0,[r4,#0x5a]         ;820
00008c  1e40              SUBS     r0,r0,#1              ;820
00008e  f8a4005a          STRH     r0,[r4,#0x5a]         ;820
000092  6820              LDR      r0,[r4,#0]            ;820
000094  2720              MOVS     r7,#0x20              ;821
000096  69c0              LDR      r0,[r0,#0x1c]         ;821
000098  ea370000          BICS     r0,r7,r0              ;821
00009c  d025              BEQ      |L23.234|
00009e  bf00              NOP                            ;821
                  |L23.160|
0000a0  f1b53fff          CMP      r5,#0xffffffff        ;821
0000a4  d01c              BEQ      |L23.224|
0000a6  b12d              CBZ      r5,|L23.180|
0000a8  f7fffffe          BL       HAL_GetTick
0000ac  eba00108          SUB      r1,r0,r8              ;821
0000b0  42a9              CMP      r1,r5                 ;821
0000b2  d315              BCC      |L23.224|
                  |L23.180|
0000b4  6821              LDR      r1,[r4,#0]            ;821
0000b6  2020              MOVS     r0,#0x20              ;821
0000b8  680a              LDR      r2,[r1,#0]            ;821
0000ba  f42272d0          BIC      r2,r2,#0x1a0          ;821
0000be  600a              STR      r2,[r1,#0]            ;821
0000c0  6821              LDR      r1,[r4,#0]            ;821
0000c2  688a              LDR      r2,[r1,#8]            ;821
0000c4  f0220201          BIC      r2,r2,#1              ;821
0000c8  608a              STR      r2,[r1,#8]            ;821
0000ca  66e0              STR      r0,[r4,#0x6c]         ;821
0000cc  6720              STR      r0,[r4,#0x70]         ;821
0000ce  2003              MOVS     r0,#3                 ;823
0000d0  f8c4b068          STR      r11,[r4,#0x68]        ;823
0000d4  e8bd9ff0          POP      {r4-r12,pc}
                  |L23.216|
0000d8  e7ff              B        |L23.218|
                  |L23.218|
0000da  f8a4205c          STRH     r2,[r4,#0x5c]         ;814
0000de  e7cf              B        |L23.128|
                  |L23.224|
0000e0  6820              LDR      r0,[r4,#0]            ;814
0000e2  69c0              LDR      r0,[r0,#0x1c]         ;814
0000e4  ea370000          BICS     r0,r7,r0              ;814
0000e8  d1da              BNE      |L23.160|
                  |L23.234|
0000ea  68a0              LDR      r0,[r4,#8]            ;825
0000ec  f5b05f80          CMP      r0,#0x1000            ;825
0000f0  bf04              ITT      EQ                    ;825
0000f2  6920              LDREQ    r0,[r4,#0x10]         ;825
0000f4  2800              CMPEQ    r0,#0                 ;825
0000f6  d012              BEQ      |L23.286|
0000f8  6820              LDR      r0,[r4,#0]            ;833
0000fa  6a40              LDR      r0,[r0,#0x24]         ;833
0000fc  ea00000a          AND      r0,r0,r10             ;833
000100  f8060b01          STRB     r0,[r6],#1            ;833
                  |L23.260|
000104  f8b4005a          LDRH     r0,[r4,#0x5a]         ;833
000108  2800              CMP      r0,#0                 ;833
00010a  d1bd              BNE      |L23.136|
00010c  2020              MOVS     r0,#0x20              ;838
00010e  e000              B        |L23.274|
                  |L23.272|
000110  e00d              B        |L23.302|
                  |L23.274|
000112  6720              STR      r0,[r4,#0x70]         ;838
000114  2000              MOVS     r0,#0                 ;843
000116  f8c4b068          STR      r11,[r4,#0x68]        ;843
00011a  e8bd9ff0          POP      {r4-r12,pc}
                  |L23.286|
00011e  6821              LDR      r1,[r4,#0]            ;828
000120  4630              MOV      r0,r6                 ;827
000122  1cb6              ADDS     r6,r6,#2              ;829
000124  6a49              LDR      r1,[r1,#0x24]         ;828
000126  ea010109          AND      r1,r1,r9              ;828
00012a  8001              STRH     r1,[r0,#0]            ;828
00012c  e7ea              B        |L23.260|
                  |L23.302|
00012e  2002              MOVS     r0,#2                 ;847
000130  e8bd9ff0          POP      {r4-r12,pc}
;;;850    
                          ENDP


                          AREA ||i.HAL_UART_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive_DMA PROC
;;;1013     */
;;;1014   HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;1015   {
000002  4604              MOV      r4,r0
;;;1016     uint32_t *tmp;
;;;1017   
;;;1018     /* Check that a Rx process is not already ongoing */
;;;1019     if(huart->RxState == HAL_UART_STATE_READY)
000004  6f00              LDR      r0,[r0,#0x70]
000006  2820              CMP      r0,#0x20
000008  d137              BNE      |L24.122|
;;;1020     {
;;;1021       if((pData == NULL ) || (Size == 0U))
00000a  2900              CMP      r1,#0
00000c  bf12              ITEE     NE
00000e  2a00              CMPNE    r2,#0
;;;1022       {
;;;1023         return HAL_ERROR;
000010  2001              MOVEQ    r0,#1
;;;1024       }
;;;1025   
;;;1026       /* Process Locked */
;;;1027       __HAL_LOCK(huart);
;;;1028   
;;;1029       huart->pRxBuffPtr = pData;
;;;1030       huart->RxXferSize = Size;
;;;1031   
;;;1032       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1033       huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;1034   
;;;1035       /* Set the UART DMA transfer complete callback */
;;;1036       huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
;;;1037   
;;;1038       /* Set the UART DMA Half transfer complete callback */
;;;1039       huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
;;;1040   
;;;1041       /* Set the DMA error callback */
;;;1042       huart->hdmarx->XferErrorCallback = UART_DMAError;
;;;1043   
;;;1044       /* Set the DMA abort callback */
;;;1045       huart->hdmarx->XferAbortCallback = NULL;
;;;1046   
;;;1047       /* Enable the DMA channel */
;;;1048       tmp = (uint32_t*)&pData;
;;;1049       HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->RDR, *(uint32_t*)tmp, Size);
;;;1050   
;;;1051       /* Process Unlocked */
;;;1052       __HAL_UNLOCK(huart);
;;;1053   
;;;1054       /* Enable the UART Parity Error Interrupt */
;;;1055       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1056   
;;;1057       /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1058       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1059   
;;;1060       /* Enable the DMA transfer for the receiver request by setting the DMAR bit
;;;1061       in the UART CR3 register */
;;;1062       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1063   
;;;1064       return HAL_OK;
;;;1065     }
;;;1066     else
;;;1067     {
;;;1068       return HAL_BUSY;
;;;1069     }
;;;1070   }
000012  bd70              POPEQ    {r4-r6,pc}
000014  6ea0              LDR      r0,[r4,#0x68]         ;1027
000016  2801              CMP      r0,#1                 ;1027
000018  d02f              BEQ      |L24.122|
00001a  2301              MOVS     r3,#1                 ;1027
00001c  66a3              STR      r3,[r4,#0x68]         ;1030
00001e  6561              STR      r1,[r4,#0x54]         ;1030
000020  2500              MOVS     r5,#0                 ;1032
000022  f8a42058          STRH     r2,[r4,#0x58]         ;1030
000026  2022              MOVS     r0,#0x22              ;1033
000028  6765              STR      r5,[r4,#0x74]         ;1032
00002a  6720              STR      r0,[r4,#0x70]         ;1033
00002c  6e63              LDR      r3,[r4,#0x64]         ;1036
00002e  4814              LDR      r0,|L24.128|
000030  6418              STR      r0,[r3,#0x40]         ;1039
000032  6e63              LDR      r3,[r4,#0x64]         ;1039
000034  4813              LDR      r0,|L24.132|
000036  6458              STR      r0,[r3,#0x44]         ;1042
000038  6e63              LDR      r3,[r4,#0x64]         ;1042
00003a  4813              LDR      r0,|L24.136|
00003c  6518              STR      r0,[r3,#0x50]         ;1045
00003e  4613              MOV      r3,r2                 ;1049
000040  6e60              LDR      r0,[r4,#0x64]         ;1045
000042  6545              STR      r5,[r0,#0x54]         ;1045
000044  4608              MOV      r0,r1                 ;1045
000046  f8d4c064          LDR      r12,[r4,#0x64]        ;1049
00004a  4602              MOV      r2,r0                 ;1049
00004c  6821              LDR      r1,[r4,#0]            ;1049
00004e  4660              MOV      r0,r12                ;1049
000050  3124              ADDS     r1,r1,#0x24           ;1049
000052  f7fffffe          BL       HAL_DMA_Start_IT
000056  66a5              STR      r5,[r4,#0x68]         ;1055
000058  6820              LDR      r0,[r4,#0]            ;1055
00005a  6801              LDR      r1,[r0,#0]            ;1055
00005c  f4417180          ORR      r1,r1,#0x100          ;1055
000060  6001              STR      r1,[r0,#0]            ;1055
000062  6820              LDR      r0,[r4,#0]            ;1058
000064  6881              LDR      r1,[r0,#8]            ;1058
000066  f0410101          ORR      r1,r1,#1              ;1058
00006a  6081              STR      r1,[r0,#8]            ;1058
00006c  6820              LDR      r0,[r4,#0]            ;1062
00006e  6881              LDR      r1,[r0,#8]            ;1062
000070  f0410140          ORR      r1,r1,#0x40           ;1062
000074  6081              STR      r1,[r0,#8]            ;1062
000076  2000              MOVS     r0,#0                 ;1064
000078  bd70              POP      {r4-r6,pc}
                  |L24.122|
00007a  2002              MOVS     r0,#2                 ;1068
00007c  bd70              POP      {r4-r6,pc}
;;;1071   
                          ENDP

00007e  0000              DCW      0x0000
                  |L24.128|
                          DCD      UART_DMAReceiveCplt
                  |L24.132|
                          DCD      UART_DMARxHalfCplt
                  |L24.136|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Receive_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive_IT PROC
;;;898      */
;;;899    HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  6f03              LDR      r3,[r0,#0x70]
;;;900    {
;;;901      /* Check that a Rx process is not already ongoing */
;;;902      if(huart->RxState == HAL_UART_STATE_READY)
000002  2b20              CMP      r3,#0x20
000004  d146              BNE      |L25.148|
;;;903      {
;;;904        if((pData == NULL ) || (Size == 0U))
000006  2900              CMP      r1,#0
000008  bf12              ITEE     NE
00000a  2a00              CMPNE    r2,#0
;;;905        {
;;;906          return HAL_ERROR;
00000c  2001              MOVEQ    r0,#1
;;;907        }
;;;908    
;;;909        /* Process Locked */
;;;910        __HAL_LOCK(huart);
;;;911    
;;;912        huart->pRxBuffPtr = pData;
;;;913        huart->RxXferSize = Size;
;;;914        huart->RxXferCount = Size;
;;;915    
;;;916        /* Computation of UART mask to apply to RDR register */
;;;917        UART_MASK_COMPUTATION(huart);
;;;918    
;;;919        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;920        huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;921    
;;;922        /* Process Unlocked */
;;;923        __HAL_UNLOCK(huart);
;;;924    
;;;925        /* Enable the UART Parity Error Interrupt */
;;;926        SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;927    
;;;928        /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;929        SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;930    
;;;931        /* Enable the UART Data Register not empty Interrupt */
;;;932        SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE);
;;;933    
;;;934        return HAL_OK;
;;;935      }
;;;936      else
;;;937      {
;;;938        return HAL_BUSY;
;;;939      }
;;;940    }
00000e  4770              BXEQ     lr
000010  6e83              LDR      r3,[r0,#0x68]         ;910
000012  2b01              CMP      r3,#1                 ;910
000014  d03e              BEQ      |L25.148|
000016  6883              LDR      r3,[r0,#8]            ;912
000018  f04f0c01          MOV      r12,#1                ;910
00001c  f8c0c068          STR      r12,[r0,#0x68]        ;913
000020  6541              STR      r1,[r0,#0x54]         ;913
000022  f5b35f80          CMP      r3,#0x1000            ;917
000026  f8a02058          STRH     r2,[r0,#0x58]         ;913
00002a  f04f01ff          MOV      r1,#0xff              ;917
00002e  f8a0205a          STRH     r2,[r0,#0x5a]         ;914
000032  d006              BEQ      |L25.66|
000034  f04f027f          MOV      r2,#0x7f              ;917
000038  b14b              CBZ      r3,|L25.78|
00003a  f1b35f80          CMP      r3,#0x10000000        ;917
00003e  d009              BEQ      |L25.84|
000040  e00f              B        |L25.98|
                  |L25.66|
000042  6902              LDR      r2,[r0,#0x10]         ;917
000044  2a00              CMP      r2,#0                 ;917
000046  bf08              IT       EQ                    ;917
000048  f24011ff          MOVEQ    r1,#0x1ff             ;917
00004c  e007              B        |L25.94|
                  |L25.78|
00004e  6903              LDR      r3,[r0,#0x10]         ;917
000050  b9eb              CBNZ     r3,|L25.142|
000052  e004              B        |L25.94|
                  |L25.84|
000054  6901              LDR      r1,[r0,#0x10]         ;917
000056  2900              CMP      r1,#0                 ;917
000058  bf18              IT       NE                    ;917
00005a  213f              MOVNE    r1,#0x3f              ;917
00005c  d017              BEQ      |L25.142|
                  |L25.94|
00005e  f8a0105c          STRH     r1,[r0,#0x5c]         ;917
                  |L25.98|
000062  2100              MOVS     r1,#0                 ;919
000064  2222              MOVS     r2,#0x22              ;920
000066  6741              STR      r1,[r0,#0x74]         ;919
000068  6702              STR      r2,[r0,#0x70]         ;920
00006a  6681              STR      r1,[r0,#0x68]         ;926
00006c  6801              LDR      r1,[r0,#0]            ;926
00006e  680a              LDR      r2,[r1,#0]            ;926
000070  f4427280          ORR      r2,r2,#0x100          ;926
000074  600a              STR      r2,[r1,#0]            ;926
000076  6801              LDR      r1,[r0,#0]            ;929
000078  688a              LDR      r2,[r1,#8]            ;929
00007a  f0420201          ORR      r2,r2,#1              ;929
00007e  608a              STR      r2,[r1,#8]            ;929
000080  6800              LDR      r0,[r0,#0]            ;932
000082  6801              LDR      r1,[r0,#0]            ;932
000084  f0410120          ORR      r1,r1,#0x20           ;932
000088  6001              STR      r1,[r0,#0]            ;932
00008a  2000              MOVS     r0,#0                 ;934
00008c  4770              BX       lr
                  |L25.142|
00008e  f8a0205c          STRH     r2,[r0,#0x5c]         ;917
000092  e7e6              B        |L25.98|
                  |L25.148|
000094  2002              MOVS     r0,#2                 ;938
000096  4770              BX       lr
;;;941    
                          ENDP


                          AREA ||i.HAL_UART_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxCpltCallback PROC
;;;1520     */
;;;1521   __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1522   {
;;;1523     /* Prevent unused argument(s) compilation warning */
;;;1524     UNUSED(huart);
;;;1525   
;;;1526     /* NOTE : This function should not be modified, when the callback is needed,
;;;1527               the HAL_UART_RxCpltCallback can be implemented in the user file
;;;1528      */
;;;1529   }
;;;1530   
                          ENDP


                          AREA ||i.HAL_UART_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxHalfCpltCallback PROC
;;;1535     */
;;;1536   __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1537   {
;;;1538     /* Prevent unused argument(s) compilation warning */
;;;1539     UNUSED(huart);
;;;1540   
;;;1541     /* NOTE: This function should not be modified, when the callback is needed,
;;;1542              the HAL_UART_RxHalfCpltCallback can be implemented in the user file
;;;1543      */
;;;1544   }
;;;1545   
                          ENDP


                          AREA ||i.HAL_UART_Transmit||, CODE, READONLY, ALIGN=2

                  HAL_UART_Transmit PROC
;;;717      */
;;;718    HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;719    {
000004  4604              MOV      r4,r0
;;;720      uint16_t* tmp;
;;;721      uint32_t tickstart = 0U;
;;;722    
;;;723      /* Check that a Tx process is not already ongoing */
;;;724      if(huart->gState == HAL_UART_STATE_READY)
000006  6ec0              LDR      r0,[r0,#0x6c]
000008  461d              MOV      r5,r3                 ;719
00000a  4617              MOV      r7,r2                 ;719
00000c  460e              MOV      r6,r1                 ;719
00000e  2820              CMP      r0,#0x20
000010  d16c              BNE      |L28.236|
;;;725      {
;;;726        if((pData == NULL ) || (Size == 0U))
000012  2e00              CMP      r6,#0
000014  bf12              ITEE     NE
000016  2f00              CMPNE    r7,#0
;;;727        {
;;;728          return  HAL_ERROR;
000018  2001              MOVEQ    r0,#1
;;;729        }
;;;730    
;;;731        /* Process Locked */
;;;732        __HAL_LOCK(huart);
;;;733    
;;;734        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;735        huart->gState = HAL_UART_STATE_BUSY_TX;
;;;736    
;;;737        /* Init tickstart for timeout managment*/
;;;738        tickstart = HAL_GetTick();
;;;739    
;;;740        huart->TxXferSize = Size;
;;;741        huart->TxXferCount = Size;
;;;742        while(huart->TxXferCount > 0U)
;;;743        {
;;;744          huart->TxXferCount--;
;;;745          if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;746          {
;;;747            return HAL_TIMEOUT;
;;;748          }
;;;749          if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;750          {
;;;751            tmp = (uint16_t*) pData;
;;;752            huart->Instance->TDR = (*tmp & (uint16_t)0x01FFU);
;;;753            pData += 2;
;;;754          }
;;;755          else
;;;756          {
;;;757            huart->Instance->TDR = (*pData++ & (uint8_t)0xFFU);
;;;758          }
;;;759        }
;;;760        if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;761        {
;;;762          return HAL_TIMEOUT;
;;;763        }
;;;764    
;;;765        /* At end of Tx process, restore huart->gState to Ready */
;;;766        huart->gState = HAL_UART_STATE_READY;
;;;767    
;;;768        /* Process Unlocked */
;;;769        __HAL_UNLOCK(huart);
;;;770    
;;;771        return HAL_OK;
;;;772      }
;;;773      else
;;;774      {
;;;775        return HAL_BUSY;
;;;776      }
;;;777    }
00001a  e8bd8ff8          POPEQ    {r3-r11,pc}
00001e  6ea0              LDR      r0,[r4,#0x68]         ;732
000020  2801              CMP      r0,#1                 ;732
000022  d063              BEQ      |L28.236|
000024  2001              MOVS     r0,#1                 ;732
000026  f04f0a00          MOV      r10,#0                ;734
00002a  f8c4a074          STR      r10,[r4,#0x74]        ;734
00002e  2121              MOVS     r1,#0x21              ;735
000030  66a0              STR      r0,[r4,#0x68]         ;734
000032  66e1              STR      r1,[r4,#0x6c]         ;735
000034  f7fffffe          BL       HAL_GetTick
000038  f8a47050          STRH     r7,[r4,#0x50]         ;740
00003c  4680              MOV      r8,r0                 ;738
00003e  f04f0920          MOV      r9,#0x20              ;738
000042  f8a47052          STRH     r7,[r4,#0x52]         ;741
000046  bf00              NOP                            ;744
                  |L28.72|
000048  f8b40052          LDRH     r0,[r4,#0x52]         ;744
00004c  1e40              SUBS     r0,r0,#1              ;744
00004e  f8a40052          STRH     r0,[r4,#0x52]         ;744
000052  6820              LDR      r0,[r4,#0]            ;744
000054  2780              MOVS     r7,#0x80              ;745
000056  69c0              LDR      r0,[r0,#0x1c]         ;745
000058  ea370000          BICS     r0,r7,r0              ;745
00005c  d022              BEQ      |L28.164|
00005e  bf00              NOP                            ;745
                  |L28.96|
000060  f1b53fff          CMP      r5,#0xffffffff        ;745
000064  d019              BEQ      |L28.154|
000066  b12d              CBZ      r5,|L28.116|
000068  f7fffffe          BL       HAL_GetTick
00006c  eba00108          SUB      r1,r0,r8              ;745
000070  42a9              CMP      r1,r5                 ;745
000072  d312              BCC      |L28.154|
                  |L28.116|
000074  6820              LDR      r0,[r4,#0]            ;745
000076  6801              LDR      r1,[r0,#0]            ;745
000078  f42171d0          BIC      r1,r1,#0x1a0          ;745
00007c  6001              STR      r1,[r0,#0]            ;745
00007e  6820              LDR      r0,[r4,#0]            ;745
000080  6881              LDR      r1,[r0,#8]            ;745
000082  f0210101          BIC      r1,r1,#1              ;745
000086  6081              STR      r1,[r0,#8]            ;745
000088  f8c4906c          STR      r9,[r4,#0x6c]         ;745
00008c  f8c49070          STR      r9,[r4,#0x70]         ;745
000090  2003              MOVS     r0,#3                 ;747
000092  f8c4a068          STR      r10,[r4,#0x68]        ;747
000096  e8bd8ff8          POP      {r3-r11,pc}
                  |L28.154|
00009a  6820              LDR      r0,[r4,#0]
00009c  69c0              LDR      r0,[r0,#0x1c]
00009e  ea370000          BICS     r0,r7,r0
0000a2  d1dd              BNE      |L28.96|
                  |L28.164|
0000a4  68a0              LDR      r0,[r4,#8]            ;749
0000a6  f5b05f80          CMP      r0,#0x1000            ;749
0000aa  bf05              ITTET    EQ                    ;749
0000ac  6920              LDREQ    r0,[r4,#0x10]         ;749
0000ae  2800              CMPEQ    r0,#0                 ;749
0000b0  f8160b01          LDRBNE   r0,[r6],#1            ;757
0000b4  f8360b02          LDRHEQ   r0,[r6],#2            ;752
0000b8  6821              LDR      r1,[r4,#0]            ;752
0000ba  bf08              IT       EQ                    ;752
0000bc  f3c00008          UBFXEQ   r0,r0,#0,#9           ;752
0000c0  6288              STR      r0,[r1,#0x28]         ;757
0000c2  f8b40052          LDRH     r0,[r4,#0x52]         ;757
0000c6  2800              CMP      r0,#0                 ;749
0000c8  d1be              BNE      |L28.72|
0000ca  2200              MOVS     r2,#0                 ;760
0000cc  4643              MOV      r3,r8                 ;760
0000ce  2140              MOVS     r1,#0x40              ;760
0000d0  4620              MOV      r0,r4                 ;760
0000d2  9500              STR      r5,[sp,#0]            ;760
0000d4  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
0000d8  2800              CMP      r0,#0                 ;760
0000da  bf11              ITEEE    NE                    ;762
0000dc  2003              MOVNE    r0,#3                 ;762
0000de  f8c4906c          STREQ    r9,[r4,#0x6c]         ;766
0000e2  2000              MOVEQ    r0,#0                 ;771
0000e4  f8c4a068          STREQ    r10,[r4,#0x68]        ;771
0000e8  e8bd8ff8          POP      {r3-r11,pc}
                  |L28.236|
0000ec  2002              MOVS     r0,#2                 ;775
0000ee  e8bd8ff8          POP      {r3-r11,pc}
;;;778    
                          ENDP


                          AREA ||i.HAL_UART_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Transmit_DMA PROC
;;;948      */
;;;949    HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;950    {
000002  4604              MOV      r4,r0
;;;951      uint32_t *tmp;
;;;952    
;;;953      /* Check that a Tx process is not already ongoing */
;;;954      if(huart->gState == HAL_UART_STATE_READY)
000004  6ec0              LDR      r0,[r0,#0x6c]
000006  2820              CMP      r0,#0x20
000008  d130              BNE      |L29.108|
;;;955      {
;;;956        if((pData == NULL ) || (Size == 0U))
00000a  2900              CMP      r1,#0
00000c  bf12              ITEE     NE
00000e  2a00              CMPNE    r2,#0
;;;957        {
;;;958          return HAL_ERROR;
000010  2001              MOVEQ    r0,#1
;;;959        }
;;;960    
;;;961        /* Process Locked */
;;;962        __HAL_LOCK(huart);
;;;963    
;;;964        huart->pTxBuffPtr = pData;
;;;965        huart->TxXferSize = Size;
;;;966        huart->TxXferCount = Size;
;;;967    
;;;968        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;969        huart->gState = HAL_UART_STATE_BUSY_TX;
;;;970    
;;;971        /* Set the UART DMA transfer complete callback */
;;;972        huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
;;;973    
;;;974        /* Set the UART DMA Half transfer complete callback */
;;;975        huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
;;;976    
;;;977        /* Set the DMA error callback */
;;;978        huart->hdmatx->XferErrorCallback = UART_DMAError;
;;;979    
;;;980        /* Set the DMA abort callback */
;;;981        huart->hdmatx->XferAbortCallback = NULL;
;;;982    
;;;983        /* Enable the UART transmit DMA channel */
;;;984        tmp = (uint32_t*)&pData;
;;;985        HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t*)tmp, (uint32_t)&huart->Instance->TDR, Size);
;;;986    
;;;987        /* Clear the TC flag in the SR register by writing 0 to it */
;;;988        __HAL_UART_CLEAR_IT(huart, UART_FLAG_TC);
;;;989    
;;;990        /* Process Unlocked */
;;;991        __HAL_UNLOCK(huart);
;;;992    
;;;993        /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;994           in the UART CR3 register */
;;;995        SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;996    
;;;997        return HAL_OK;
;;;998      }
;;;999      else
;;;1000     {
;;;1001       return HAL_BUSY;
;;;1002     }
;;;1003   }
000012  bd70              POPEQ    {r4-r6,pc}
000014  6ea0              LDR      r0,[r4,#0x68]         ;962
000016  2801              CMP      r0,#1                 ;962
000018  d028              BEQ      |L29.108|
00001a  2301              MOVS     r3,#1                 ;962
00001c  66a3              STR      r3,[r4,#0x68]         ;965
00001e  64e1              STR      r1,[r4,#0x4c]         ;965
000020  2500              MOVS     r5,#0                 ;968
000022  f8a42050          STRH     r2,[r4,#0x50]         ;965
000026  2021              MOVS     r0,#0x21              ;969
000028  f8a42052          STRH     r2,[r4,#0x52]         ;966
00002c  6765              STR      r5,[r4,#0x74]         ;968
00002e  66e0              STR      r0,[r4,#0x6c]         ;969
000030  6e23              LDR      r3,[r4,#0x60]         ;972
000032  480f              LDR      r0,|L29.112|
000034  6418              STR      r0,[r3,#0x40]         ;975
000036  6e23              LDR      r3,[r4,#0x60]         ;975
000038  480e              LDR      r0,|L29.116|
00003a  6458              STR      r0,[r3,#0x44]         ;978
00003c  6e23              LDR      r3,[r4,#0x60]         ;978
00003e  480e              LDR      r0,|L29.120|
000040  6518              STR      r0,[r3,#0x50]         ;981
000042  6e20              LDR      r0,[r4,#0x60]         ;981
000044  6545              STR      r5,[r0,#0x54]         ;985
000046  6823              LDR      r3,[r4,#0]            ;985
000048  6e20              LDR      r0,[r4,#0x60]         ;985
00004a  f1030c28          ADD      r12,r3,#0x28          ;985
00004e  4613              MOV      r3,r2                 ;985
000050  4662              MOV      r2,r12                ;985
000052  f7fffffe          BL       HAL_DMA_Start_IT
000056  6821              LDR      r1,[r4,#0]            ;988
000058  2040              MOVS     r0,#0x40              ;988
00005a  6208              STR      r0,[r1,#0x20]         ;988
00005c  66a5              STR      r5,[r4,#0x68]         ;995
00005e  6820              LDR      r0,[r4,#0]            ;995
000060  6881              LDR      r1,[r0,#8]            ;995
000062  f0410180          ORR      r1,r1,#0x80           ;995
000066  6081              STR      r1,[r0,#8]            ;995
000068  2000              MOVS     r0,#0                 ;997
00006a  bd70              POP      {r4-r6,pc}
                  |L29.108|
00006c  2002              MOVS     r0,#2                 ;1001
00006e  bd70              POP      {r4-r6,pc}
;;;1004   
                          ENDP

                  |L29.112|
                          DCD      UART_DMATransmitCplt
                  |L29.116|
                          DCD      UART_DMATxHalfCplt
                  |L29.120|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit_IT PROC
;;;857      */
;;;858    HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  6ec3              LDR      r3,[r0,#0x6c]
;;;859    {
;;;860      /* Check that a Tx process is not already ongoing */
;;;861      if(huart->gState == HAL_UART_STATE_READY)
000002  2b20              CMP      r3,#0x20
000004  d118              BNE      |L30.56|
;;;862      {
;;;863        if((pData == NULL ) || (Size == 0U))
000006  2900              CMP      r1,#0
000008  bf12              ITEE     NE
00000a  2a00              CMPNE    r2,#0
;;;864        {
;;;865          return HAL_ERROR;
00000c  2001              MOVEQ    r0,#1
;;;866        }
;;;867    
;;;868        /* Process Locked */
;;;869        __HAL_LOCK(huart);
;;;870    
;;;871        huart->pTxBuffPtr = pData;
;;;872        huart->TxXferSize = Size;
;;;873        huart->TxXferCount = Size;
;;;874    
;;;875        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;876        huart->gState = HAL_UART_STATE_BUSY_TX;
;;;877    
;;;878        /* Process Unlocked */
;;;879        __HAL_UNLOCK(huart);
;;;880    
;;;881        /* Enable the UART Transmit Data Register Empty Interrupt */
;;;882        SET_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
;;;883    
;;;884        return HAL_OK;
;;;885      }
;;;886      else
;;;887      {
;;;888        return HAL_BUSY;
;;;889      }
;;;890    }
00000e  4770              BXEQ     lr
000010  6e83              LDR      r3,[r0,#0x68]         ;869
000012  2b01              CMP      r3,#1                 ;869
000014  d010              BEQ      |L30.56|
000016  64c1              STR      r1,[r0,#0x4c]         ;872
000018  2100              MOVS     r1,#0                 ;875
00001a  f8a02050          STRH     r2,[r0,#0x50]         ;872
00001e  2321              MOVS     r3,#0x21              ;876
000020  f8a02052          STRH     r2,[r0,#0x52]         ;873
000024  6741              STR      r1,[r0,#0x74]         ;875
000026  66c3              STR      r3,[r0,#0x6c]         ;876
000028  6681              STR      r1,[r0,#0x68]         ;882
00002a  6800              LDR      r0,[r0,#0]            ;882
00002c  6801              LDR      r1,[r0,#0]            ;882
00002e  f0410180          ORR      r1,r1,#0x80           ;882
000032  6001              STR      r1,[r0,#0]            ;882
000034  2000              MOVS     r0,#0                 ;884
000036  4770              BX       lr
                  |L30.56|
000038  2002              MOVS     r0,#2                 ;888
00003a  4770              BX       lr
;;;891    
                          ENDP


                          AREA ||i.HAL_UART_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxCpltCallback PROC
;;;1490     */
;;;1491    __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1492   {
;;;1493     /* Prevent unused argument(s) compilation warning */
;;;1494     UNUSED(huart);
;;;1495   
;;;1496     /* NOTE : This function should not be modified, when the callback is needed,
;;;1497               the HAL_UART_TxCpltCallback can be implemented in the user file
;;;1498      */
;;;1499   }
;;;1500   
                          ENDP


                          AREA ||i.HAL_UART_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxHalfCpltCallback PROC
;;;1505     */
;;;1506    __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1507   {
;;;1508     /* Prevent unused argument(s) compilation warning */
;;;1509     UNUSED(huart);
;;;1510   
;;;1511     /* NOTE: This function should not be modified, when the callback is needed,
;;;1512              the HAL_UART_TxHalfCpltCallback can be implemented in the user file
;;;1513      */
;;;1514   }
;;;1515   
                          ENDP


                          AREA ||i.UART_AdvFeatureConfig||, CODE, READONLY, ALIGN=1

                  UART_AdvFeatureConfig PROC
;;;1938     */
;;;1939   void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
000000  f8901024          LDRB     r1,[r0,#0x24]
;;;1940   {
;;;1941     /* Check whether the set of advanced features to configure is properly set */
;;;1942     assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
;;;1943   
;;;1944     /* if required, configure TX pin active level inversion */
;;;1945     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
000004  f0110f01          TST      r1,#1
000008  d006              BEQ      |L33.24|
;;;1946     {
;;;1947       assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
;;;1948       MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
00000a  6801              LDR      r1,[r0,#0]
00000c  6a82              LDR      r2,[r0,#0x28]
00000e  684b              LDR      r3,[r1,#4]
000010  f4233300          BIC      r3,r3,#0x20000
000014  431a              ORRS     r2,r2,r3
000016  604a              STR      r2,[r1,#4]
                  |L33.24|
;;;1949     }
;;;1950   
;;;1951     /* if required, configure RX pin active level inversion */
;;;1952     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
000018  f8901024          LDRB     r1,[r0,#0x24]
00001c  f0110f02          TST      r1,#2
000020  d006              BEQ      |L33.48|
;;;1953     {
;;;1954       assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
;;;1955       MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
000022  6801              LDR      r1,[r0,#0]
000024  6ac2              LDR      r2,[r0,#0x2c]
000026  684b              LDR      r3,[r1,#4]
000028  f4233380          BIC      r3,r3,#0x10000
00002c  431a              ORRS     r2,r2,r3
00002e  604a              STR      r2,[r1,#4]
                  |L33.48|
;;;1956     }
;;;1957   
;;;1958     /* if required, configure data inversion */
;;;1959     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
000030  f8901024          LDRB     r1,[r0,#0x24]
000034  f0110f04          TST      r1,#4
000038  d006              BEQ      |L33.72|
;;;1960     {
;;;1961       assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
;;;1962       MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
00003a  6801              LDR      r1,[r0,#0]
00003c  6b02              LDR      r2,[r0,#0x30]
00003e  684b              LDR      r3,[r1,#4]
000040  f4232380          BIC      r3,r3,#0x40000
000044  431a              ORRS     r2,r2,r3
000046  604a              STR      r2,[r1,#4]
                  |L33.72|
;;;1963     }
;;;1964   
;;;1965     /* if required, configure RX/TX pins swap */
;;;1966     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
000048  f8901024          LDRB     r1,[r0,#0x24]
00004c  f0110f08          TST      r1,#8
000050  d006              BEQ      |L33.96|
;;;1967     {
;;;1968       assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
;;;1969       MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
000052  6801              LDR      r1,[r0,#0]
000054  6b42              LDR      r2,[r0,#0x34]
000056  684b              LDR      r3,[r1,#4]
000058  f4234300          BIC      r3,r3,#0x8000
00005c  431a              ORRS     r2,r2,r3
00005e  604a              STR      r2,[r1,#4]
                  |L33.96|
;;;1970     }
;;;1971   
;;;1972     /* if required, configure RX overrun detection disabling */
;;;1973     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
000060  f8901024          LDRB     r1,[r0,#0x24]
000064  f0110f10          TST      r1,#0x10
000068  d006              BEQ      |L33.120|
;;;1974     {
;;;1975       assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
;;;1976       MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
00006a  6801              LDR      r1,[r0,#0]
00006c  6b82              LDR      r2,[r0,#0x38]
00006e  688b              LDR      r3,[r1,#8]
000070  f4235380          BIC      r3,r3,#0x1000
000074  431a              ORRS     r2,r2,r3
000076  608a              STR      r2,[r1,#8]
                  |L33.120|
;;;1977     }
;;;1978   
;;;1979     /* if required, configure DMA disabling on reception error */
;;;1980     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
000078  f8901024          LDRB     r1,[r0,#0x24]
00007c  f0110f20          TST      r1,#0x20
000080  d006              BEQ      |L33.144|
;;;1981     {
;;;1982       assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
;;;1983       MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
000082  6801              LDR      r1,[r0,#0]
000084  6bc2              LDR      r2,[r0,#0x3c]
000086  688b              LDR      r3,[r1,#8]
000088  f4235300          BIC      r3,r3,#0x2000
00008c  431a              ORRS     r2,r2,r3
00008e  608a              STR      r2,[r1,#8]
                  |L33.144|
;;;1984     }
;;;1985   
;;;1986     /* if required, configure auto Baud rate detection scheme */
;;;1987     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
000090  f8901024          LDRB     r1,[r0,#0x24]
000094  f0110f40          TST      r1,#0x40
000098  d011              BEQ      |L33.190|
;;;1988     {
;;;1989       assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
;;;1990       MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
00009a  6801              LDR      r1,[r0,#0]
00009c  6c02              LDR      r2,[r0,#0x40]
00009e  684b              LDR      r3,[r1,#4]
0000a0  f4231380          BIC      r3,r3,#0x100000
0000a4  431a              ORRS     r2,r2,r3
0000a6  604a              STR      r2,[r1,#4]
;;;1991       /* set auto Baudrate detection parameters if detection is enabled */
;;;1992       if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
0000a8  6c01              LDR      r1,[r0,#0x40]
0000aa  f5b11f80          CMP      r1,#0x100000
0000ae  d106              BNE      |L33.190|
;;;1993       {
;;;1994         assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
;;;1995         MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
0000b0  6801              LDR      r1,[r0,#0]
0000b2  6c42              LDR      r2,[r0,#0x44]
0000b4  684b              LDR      r3,[r1,#4]
0000b6  f42303c0          BIC      r3,r3,#0x600000
0000ba  431a              ORRS     r2,r2,r3
0000bc  604a              STR      r2,[r1,#4]
                  |L33.190|
;;;1996       }
;;;1997     }
;;;1998   
;;;1999     /* if required, configure MSB first on communication line */
;;;2000     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
0000be  f8901024          LDRB     r1,[r0,#0x24]
0000c2  f0110f80          TST      r1,#0x80
;;;2001     {
;;;2002       assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
;;;2003       MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
;;;2004     }
;;;2005   }
0000c6  bf08              IT       EQ
0000c8  4770              BXEQ     lr
0000ca  6801              LDR      r1,[r0,#0]            ;2003
0000cc  6c80              LDR      r0,[r0,#0x48]         ;2003
0000ce  684a              LDR      r2,[r1,#4]            ;2003
0000d0  f4222200          BIC      r2,r2,#0x80000        ;2003
0000d4  4310              ORRS     r0,r0,r2              ;2003
0000d6  6048              STR      r0,[r1,#4]            ;2003
0000d8  4770              BX       lr
;;;2006   
                          ENDP


                          AREA ||i.UART_CheckIdleState||, CODE, READONLY, ALIGN=1

                  UART_CheckIdleState PROC
;;;2013     */
;;;2014   HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2015   {
;;;2016     uint32_t tickstart = 0U;
;;;2017   
;;;2018     /* Initialize the UART ErrorCode */
;;;2019     huart->ErrorCode = HAL_UART_ERROR_NONE;
000002  2500              MOVS     r5,#0
000004  4604              MOV      r4,r0                 ;2015
000006  6745              STR      r5,[r0,#0x74]
;;;2020   
;;;2021     /* Init tickstart for timeout managment*/
;;;2022     tickstart = HAL_GetTick();
000008  f7fffffe          BL       HAL_GetTick
00000c  4607              MOV      r7,r0
;;;2023   
;;;2024     /* Check if the Transmitter is enabled */
;;;2025     if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
00000e  6820              LDR      r0,[r4,#0]
;;;2026     {
;;;2027       /* Wait until TEACK flag is set */
;;;2028       if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
000010  f06f467e          MVN      r6,#0xfe000000
000014  6800              LDR      r0,[r0,#0]            ;2025
000016  f0100f08          TST      r0,#8                 ;2025
00001a  d008              BEQ      |L34.46|
00001c  2200              MOVS     r2,#0
00001e  463b              MOV      r3,r7
000020  f44f1100          MOV      r1,#0x200000
000024  4620              MOV      r0,r4
000026  9600              STR      r6,[sp,#0]
000028  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
00002c  b968              CBNZ     r0,|L34.74|
                  |L34.46|
;;;2029       {
;;;2030         /* Timeout Occurred */
;;;2031         return HAL_TIMEOUT;
;;;2032       }
;;;2033     }
;;;2034     /* Check if the Receiver is enabled */
;;;2035     if((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
00002e  6820              LDR      r0,[r4,#0]
000030  6800              LDR      r0,[r0,#0]
000032  f0100f04          TST      r0,#4
000036  d00a              BEQ      |L34.78|
;;;2036     {
;;;2037       /* Wait until REACK flag is set */
;;;2038       if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
000038  2200              MOVS     r2,#0
00003a  463b              MOV      r3,r7
00003c  f44f0180          MOV      r1,#0x400000
000040  4620              MOV      r0,r4
000042  9600              STR      r6,[sp,#0]
000044  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000048  b108              CBZ      r0,|L34.78|
                  |L34.74|
;;;2039       {
;;;2040         /* Timeout Occurred */
;;;2041         return HAL_TIMEOUT;
00004a  2003              MOVS     r0,#3
;;;2042       }
;;;2043     }
;;;2044   
;;;2045     /* Initialize the UART State */
;;;2046     huart->gState= HAL_UART_STATE_READY;
;;;2047     huart->RxState= HAL_UART_STATE_READY;
;;;2048   
;;;2049     /* Process Unlocked */
;;;2050     __HAL_UNLOCK(huart);
;;;2051   
;;;2052     return HAL_OK;
;;;2053   }
00004c  bdf8              POP      {r3-r7,pc}
                  |L34.78|
00004e  2020              MOVS     r0,#0x20              ;2046
000050  66e0              STR      r0,[r4,#0x6c]         ;2046
000052  66a5              STR      r5,[r4,#0x68]         ;2047
000054  6720              STR      r0,[r4,#0x70]         ;2047
000056  2000              MOVS     r0,#0                 ;2052
000058  bdf8              POP      {r3-r7,pc}
;;;2054   
                          ENDP


                          AREA ||i.UART_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  UART_DMAAbortOnError PROC
;;;1476     */
;;;1477   static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1478   {
;;;1479     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)(hdma->Parent);
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;1480     huart->RxXferCount = 0U;
000004  2100              MOVS     r1,#0
000006  f8a0105a          STRH     r1,[r0,#0x5a]
;;;1481     huart->TxXferCount = 0U;
00000a  f8a01052          STRH     r1,[r0,#0x52]
;;;1482   
;;;1483     HAL_UART_ErrorCallback(huart);
00000e  f7fffffe          BL       HAL_UART_ErrorCallback
;;;1484   }
000012  bd10              POP      {r4,pc}
;;;1485   
                          ENDP


                          AREA ||i.UART_DMAError||, CODE, READONLY, ALIGN=1

                  UART_DMAError PROC
;;;1448     */
;;;1449   static void UART_DMAError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1450   {
;;;1451     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;1452     huart->RxXferCount = 0U;
000004  2100              MOVS     r1,#0
000006  2220              MOVS     r2,#0x20
000008  f8a0105a          STRH     r1,[r0,#0x5a]
;;;1453     huart->TxXferCount = 0U;
00000c  f8a01052          STRH     r1,[r0,#0x52]
;;;1454     /* Stop UART DMA Tx request if ongoing */
;;;1455     if (  (huart->gState == HAL_UART_STATE_BUSY_TX)
000010  6ec1              LDR      r1,[r0,#0x6c]
000012  2921              CMP      r1,#0x21
000014  d109              BNE      |L36.42|
;;;1456         &&(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) )
000016  6801              LDR      r1,[r0,#0]
000018  688b              LDR      r3,[r1,#8]
00001a  f0130f80          TST      r3,#0x80
00001e  d004              BEQ      |L36.42|
000020  680b              LDR      r3,[r1,#0]
000022  f02303c0          BIC      r3,r3,#0xc0
000026  600b              STR      r3,[r1,#0]
000028  66c2              STR      r2,[r0,#0x6c]
                  |L36.42|
;;;1457     {
;;;1458       UART_EndTxTransfer(huart);
;;;1459     }
;;;1460   
;;;1461     /* Stop UART DMA Rx request if ongoing */
;;;1462     if (  (huart->RxState == HAL_UART_STATE_BUSY_RX)
00002a  6f01              LDR      r1,[r0,#0x70]
00002c  2922              CMP      r1,#0x22
00002e  d10e              BNE      |L36.78|
;;;1463         &&(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) )
000030  6801              LDR      r1,[r0,#0]
000032  688b              LDR      r3,[r1,#8]
000034  f0130f40          TST      r3,#0x40
000038  d009              BEQ      |L36.78|
00003a  680b              LDR      r3,[r1,#0]
00003c  f4237390          BIC      r3,r3,#0x120
000040  600b              STR      r3,[r1,#0]
000042  6801              LDR      r1,[r0,#0]
000044  688b              LDR      r3,[r1,#8]
000046  f0230301          BIC      r3,r3,#1
00004a  608b              STR      r3,[r1,#8]
00004c  6702              STR      r2,[r0,#0x70]
                  |L36.78|
;;;1464     {
;;;1465       UART_EndRxTransfer(huart);
;;;1466     }
;;;1467     SET_BIT(huart->ErrorCode, HAL_UART_ERROR_DMA);
00004e  6f41              LDR      r1,[r0,#0x74]
000050  f0410110          ORR      r1,r1,#0x10
000054  6741              STR      r1,[r0,#0x74]
;;;1468     HAL_UART_ErrorCallback(huart);
000056  f7fffffe          BL       HAL_UART_ErrorCallback
;;;1469   }
00005a  bd10              POP      {r4,pc}
;;;1470   
                          ENDP


                          AREA ||i.UART_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  UART_DMAReceiveCplt PROC
;;;1408     */
;;;1409   static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1410   {
;;;1411     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
;;;1412   
;;;1413     /* DMA Normal mode */
;;;1414     if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
000002  6801              LDR      r1,[r0,#0]
000004  6809              LDR      r1,[r1,#0]
000006  6bc0              LDR      r0,[r0,#0x3c]         ;1411
000008  f4117f80          TST      r1,#0x100
00000c  d113              BNE      |L37.54|
;;;1415     {
;;;1416       huart->RxXferCount = 0U;
00000e  2100              MOVS     r1,#0
000010  f8a0105a          STRH     r1,[r0,#0x5a]
;;;1417   
;;;1418       /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1419       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
000014  6801              LDR      r1,[r0,#0]
;;;1420       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1421   
;;;1422       /* Disable the DMA transfer for the receiver request by setting the DMAR bit
;;;1423       in the UART CR3 register */
;;;1424       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1425   
;;;1426   	/* At end of Rx process, restore huart->RxState to Ready */
;;;1427       huart->RxState = HAL_UART_STATE_READY;
000016  2220              MOVS     r2,#0x20
000018  680b              LDR      r3,[r1,#0]            ;1419
00001a  f4237380          BIC      r3,r3,#0x100          ;1419
00001e  600b              STR      r3,[r1,#0]            ;1419
000020  6801              LDR      r1,[r0,#0]            ;1420
000022  688b              LDR      r3,[r1,#8]            ;1420
000024  f0230301          BIC      r3,r3,#1              ;1420
000028  608b              STR      r3,[r1,#8]            ;1420
00002a  6801              LDR      r1,[r0,#0]            ;1424
00002c  688b              LDR      r3,[r1,#8]            ;1424
00002e  f0230340          BIC      r3,r3,#0x40           ;1424
000032  608b              STR      r3,[r1,#8]            ;1424
000034  6702              STR      r2,[r0,#0x70]
                  |L37.54|
;;;1428     }
;;;1429     HAL_UART_RxCpltCallback(huart);
000036  f7fffffe          BL       HAL_UART_RxCpltCallback
;;;1430   }
00003a  bd10              POP      {r4,pc}
;;;1431   
                          ENDP


                          AREA ||i.UART_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMARxHalfCplt PROC
;;;1436     */
;;;1437   static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1438   {
;;;1439     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;1440   
;;;1441     HAL_UART_RxHalfCpltCallback(huart);
000004  f7fffffe          BL       HAL_UART_RxHalfCpltCallback
;;;1442   }
000008  bd10              POP      {r4,pc}
;;;1443   
                          ENDP


                          AREA ||i.UART_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATransmitCplt PROC
;;;1368     */
;;;1369   static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1370   {
;;;1371     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
;;;1372   
;;;1373     /* DMA Normal mode*/
;;;1374     if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
000002  6801              LDR      r1,[r0,#0]
000004  6809              LDR      r1,[r1,#0]
000006  6bc0              LDR      r0,[r0,#0x3c]         ;1371
000008  f4117f80          TST      r1,#0x100
00000c  d002              BEQ      |L39.20|
;;;1375     {
;;;1376       huart->TxXferCount = 0U;
;;;1377   
;;;1378       /* Disable the DMA transfer for transmit request by setting the DMAT bit
;;;1379          in the UART CR3 register */
;;;1380       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1381   
;;;1382       /* Enable the UART Transmit Complete Interrupt */
;;;1383       SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
;;;1384     }
;;;1385     /* DMA Circular mode */
;;;1386     else
;;;1387     {
;;;1388       HAL_UART_TxCpltCallback(huart);
00000e  f7fffffe          BL       HAL_UART_TxCpltCallback
;;;1389     }
;;;1390   }
000012  bd10              POP      {r4,pc}
                  |L39.20|
000014  2100              MOVS     r1,#0                 ;1376
000016  f8a01052          STRH     r1,[r0,#0x52]         ;1376
00001a  6801              LDR      r1,[r0,#0]            ;1380
00001c  688a              LDR      r2,[r1,#8]            ;1380
00001e  f0220280          BIC      r2,r2,#0x80           ;1380
000022  608a              STR      r2,[r1,#8]            ;1380
000024  6800              LDR      r0,[r0,#0]            ;1383
000026  6801              LDR      r1,[r0,#0]            ;1383
000028  f0410140          ORR      r1,r1,#0x40           ;1383
00002c  6001              STR      r1,[r0,#0]            ;1383
00002e  bd10              POP      {r4,pc}
;;;1391   
                          ENDP


                          AREA ||i.UART_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATxHalfCplt PROC
;;;1396     */
;;;1397   static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1398   {
;;;1399     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;1400   
;;;1401     HAL_UART_TxHalfCpltCallback(huart);
000004  f7fffffe          BL       HAL_UART_TxHalfCpltCallback
;;;1402   }
000008  bd10              POP      {r4,pc}
;;;1403   
                          ENDP


                          AREA ||i.UART_SetConfig||, CODE, READONLY, ALIGN=2

                  UART_SetConfig PROC
;;;1827     */
;;;1828   HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1829   {
;;;1830     uint32_t tmpreg                     = 0x00000000U;
;;;1831     UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
;;;1832     uint16_t brrtemp                    = 0x0000U;
;;;1833     uint16_t usartdiv                   = 0x0000U;
;;;1834     HAL_StatusTypeDef ret               = HAL_OK;
;;;1835   
;;;1836     /* Check the parameters */
;;;1837     assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
;;;1838     assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;1839     assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
;;;1840     assert_param(IS_UART_PARITY(huart->Init.Parity));
;;;1841     assert_param(IS_UART_MODE(huart->Init.Mode));
;;;1842     assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
;;;1843     assert_param(IS_UART_ONE_BIT_SAMPLE(huart->Init.OneBitSampling));
;;;1844   
;;;1845   
;;;1846     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;1847     /* Clear M, PCE, PS, TE, RE and OVER8 bits and configure
;;;1848      *  the UART Word Length, Parity, Mode and oversampling:
;;;1849      *  set the M bits according to huart->Init.WordLength value
;;;1850      *  set PCE and PS bits according to huart->Init.Parity value
;;;1851      *  set TE and RE bits according to huart->Init.Mode value
;;;1852      *  set OVER8 bit according to huart->Init.OverSampling value */
;;;1853     tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
;;;1854     MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
000004  f8d0c01c          LDR      r12,[r0,#0x1c]
000008  4604              MOV      r4,r0                 ;1829
00000a  6881              LDR      r1,[r0,#8]
00000c  6800              LDR      r0,[r0,#0]
00000e  e9d45204          LDRD     r5,r2,[r4,#0x10]
000012  4b9f              LDR      r3,|L41.656|
000014  430d              ORRS     r5,r5,r1              ;1853
000016  6807              LDR      r7,[r0,#0]
000018  2110              MOVS     r1,#0x10              ;1831
00001a  ea420c0c          ORR      r12,r2,r12            ;1853
00001e  2200              MOVS     r2,#0                 ;1833
000020  ea450c0c          ORR      r12,r5,r12            ;1853
000024  4615              MOV      r5,r2                 ;1834
000026  401f              ANDS     r7,r7,r3
;;;1855   
;;;1856     /*-------------------------- USART CR2 Configuration -----------------------*/
;;;1857     /* Configure the UART Stop Bits: Set STOP[13:12] bits according
;;;1858      * to huart->Init.StopBits value */
;;;1859     MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
;;;1860   
;;;1861     /*-------------------------- USART CR3 Configuration -----------------------*/
;;;1862     /* Configure
;;;1863      * - UART HardWare Flow Control: set CTSE and RTSE bits according
;;;1864      *   to huart->Init.HwFlowCtl value
;;;1865      * - one-bit sampling method versus three samples' majority rule according
;;;1866      *   to huart->Init.OneBitSampling */
;;;1867     tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
;;;1868     MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
;;;1869   
;;;1870     /*-------------------------- USART BRR Configuration -----------------------*/
;;;1871     UART_GETCLOCKSOURCE(huart, clocksource);
000028  4b9a              LDR      r3,|L41.660|
00002a  ea470c0c          ORR      r12,r7,r12            ;1854
00002e  f8c0c000          STR      r12,[r0,#0]           ;1854
000032  6820              LDR      r0,[r4,#0]            ;1859
000034  f8d4c00c          LDR      r12,[r4,#0xc]         ;1859
000038  6847              LDR      r7,[r0,#4]            ;1859
00003a  f4275740          BIC      r7,r7,#0x3000         ;1859
00003e  ea470c0c          ORR      r12,r7,r12            ;1859
000042  f8c0c004          STR      r12,[r0,#4]           ;1859
000046  6820              LDR      r0,[r4,#0]            ;1868
000048  f8d4c018          LDR      r12,[r4,#0x18]        ;1867
00004c  f8d48020          LDR      r8,[r4,#0x20]         ;1868
000050  6887              LDR      r7,[r0,#8]            ;1868
000052  ea4c0c08          ORR      r12,r12,r8            ;1867
000056  f4276730          BIC      r7,r7,#0xb00          ;1868
00005a  ea470c0c          ORR      r12,r7,r12            ;1868
00005e  f8c0c008          STR      r12,[r0,#8]           ;1868
000062  6820              LDR      r0,[r4,#0]
000064  f1a04680          SUB      r6,r0,#0x40000000
000068  f5b63688          SUBS     r6,r6,#0x11000
00006c  d015              BEQ      |L41.154|
00006e  f5164c4c          ADDS     r12,r6,#0xcc00
000072  d01d              BEQ      |L41.176|
000074  f5164c48          ADDS     r12,r6,#0xc800
000078  d025              BEQ      |L41.198|
00007a  f5164c44          ADDS     r12,r6,#0xc400
00007e  d02d              BEQ      |L41.220|
000080  f5164c40          ADDS     r12,r6,#0xc000
000084  d035              BEQ      |L41.242|
000086  f5b66c80          SUBS     r12,r6,#0x400
00008a  d040              BEQ      |L41.270|
00008c  f5164c18          ADDS     r12,r6,#0x9800
000090  d04d              BEQ      |L41.302|
000092  f5164c14          ADDS     r12,r6,#0x9400
000096  d058              BEQ      |L41.330|
000098  e06c              B        |L41.372|
                  |L41.154|
00009a  681b              LDR      r3,[r3,#0]
00009c  f0130303          ANDS     r3,r3,#3
0000a0  d043              BEQ      |L41.298|
0000a2  2b01              CMP      r3,#1
0000a4  d063              BEQ      |L41.366|
0000a6  2b02              CMP      r3,#2
0000a8  d05f              BEQ      |L41.362|
0000aa  2b03              CMP      r3,#3
0000ac  d061              BEQ      |L41.370|
0000ae  e061              B        |L41.372|
                  |L41.176|
0000b0  681b              LDR      r3,[r3,#0]
0000b2  f013030c          ANDS     r3,r3,#0xc
0000b6  d056              BEQ      |L41.358|
0000b8  2b04              CMP      r3,#4
0000ba  d058              BEQ      |L41.366|
0000bc  2b08              CMP      r3,#8
0000be  d054              BEQ      |L41.362|
0000c0  2b0c              CMP      r3,#0xc
0000c2  d056              BEQ      |L41.370|
0000c4  e056              B        |L41.372|
                  |L41.198|
0000c6  681b              LDR      r3,[r3,#0]
0000c8  f0130330          ANDS     r3,r3,#0x30
0000cc  d04b              BEQ      |L41.358|
0000ce  2b10              CMP      r3,#0x10
0000d0  d04d              BEQ      |L41.366|
0000d2  2b20              CMP      r3,#0x20
0000d4  d049              BEQ      |L41.362|
0000d6  2b30              CMP      r3,#0x30
0000d8  d04b              BEQ      |L41.370|
0000da  e04b              B        |L41.372|
                  |L41.220|
0000dc  681b              LDR      r3,[r3,#0]
0000de  f01303c0          ANDS     r3,r3,#0xc0
0000e2  d040              BEQ      |L41.358|
0000e4  2b40              CMP      r3,#0x40
0000e6  d042              BEQ      |L41.366|
0000e8  2b80              CMP      r3,#0x80
0000ea  d03e              BEQ      |L41.362|
0000ec  2bc0              CMP      r3,#0xc0
0000ee  d040              BEQ      |L41.370|
0000f0  e040              B        |L41.372|
                  |L41.242|
0000f2  681b              LDR      r3,[r3,#0]
0000f4  f4137340          ANDS     r3,r3,#0x300
0000f8  d035              BEQ      |L41.358|
0000fa  f5b37f80          CMP      r3,#0x100
0000fe  d036              BEQ      |L41.366|
000100  f5b37f00          CMP      r3,#0x200
000104  d031              BEQ      |L41.362|
000106  f5b37f40          CMP      r3,#0x300
00010a  d032              BEQ      |L41.370|
00010c  e032              B        |L41.372|
                  |L41.270|
00010e  681b              LDR      r3,[r3,#0]
000110  f4136340          ANDS     r3,r3,#0xc00
000114  d009              BEQ      |L41.298|
000116  f5b36f80          CMP      r3,#0x400
00011a  d028              BEQ      |L41.366|
00011c  f5b36f00          CMP      r3,#0x800
000120  d023              BEQ      |L41.362|
000122  f5b36f40          CMP      r3,#0xc00
000126  d024              BEQ      |L41.370|
000128  e024              B        |L41.372|
                  |L41.298|
00012a  2101              MOVS     r1,#1
00012c  e022              B        |L41.372|
                  |L41.302|
00012e  681b              LDR      r3,[r3,#0]
000130  f4135340          ANDS     r3,r3,#0x3000
000134  d017              BEQ      |L41.358|
000136  f5b35f80          CMP      r3,#0x1000
00013a  d018              BEQ      |L41.366|
00013c  f5b35f00          CMP      r3,#0x2000
000140  d013              BEQ      |L41.362|
000142  f5b35f40          CMP      r3,#0x3000
000146  d014              BEQ      |L41.370|
000148  e014              B        |L41.372|
                  |L41.330|
00014a  681b              LDR      r3,[r3,#0]
00014c  f4134340          ANDS     r3,r3,#0xc000
000150  d009              BEQ      |L41.358|
000152  f5b34f80          CMP      r3,#0x4000
000156  d00a              BEQ      |L41.366|
000158  f5b34f00          CMP      r3,#0x8000
00015c  d005              BEQ      |L41.362|
00015e  f5b34f40          CMP      r3,#0xc000
000162  d006              BEQ      |L41.370|
000164  e006              B        |L41.372|
                  |L41.358|
000166  2100              MOVS     r1,#0
000168  e004              B        |L41.372|
                  |L41.362|
00016a  2102              MOVS     r1,#2
00016c  e002              B        |L41.372|
                  |L41.366|
00016e  2104              MOVS     r1,#4
000170  e000              B        |L41.372|
                  |L41.370|
000172  2108              MOVS     r1,#8
                  |L41.372|
;;;1872   
;;;1873     /* Check UART Over Sampling to set Baud Rate Register */
;;;1874     if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
000174  69e3              LDR      r3,[r4,#0x1c]
000176  f5b34f00          CMP      r3,#0x8000
00017a  d008              BEQ      |L41.398|
;;;1875     {
;;;1876       switch (clocksource)
;;;1877       {
;;;1878       case UART_CLOCKSOURCE_PCLK1:
;;;1879           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
;;;1880         break;
;;;1881       case UART_CLOCKSOURCE_PCLK2:
;;;1882           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
;;;1883         break;
;;;1884       case UART_CLOCKSOURCE_HSI:
;;;1885           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
;;;1886         break;
;;;1887       case UART_CLOCKSOURCE_SYSCLK:
;;;1888           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
;;;1889         break;
;;;1890       case UART_CLOCKSOURCE_LSE:
;;;1891           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
;;;1892         break;
;;;1893         case UART_CLOCKSOURCE_UNDEFINED:
;;;1894       default:
;;;1895           ret = HAL_ERROR;
;;;1896         break;
;;;1897       }
;;;1898   
;;;1899       brrtemp = usartdiv & 0xFFF0U;
;;;1900       brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
;;;1901       huart->Instance->BRR = brrtemp;
;;;1902     }
;;;1903     else
;;;1904     {
;;;1905       switch (clocksource)
00017c  2909              CMP      r1,#9
00017e  d277              BCS      |L41.624|
000180  e8dff001          TBB      [pc,r1]
000184  49556181          DCB      0x49,0x55,0x61,0x81
000188  6a818181          DCB      0x6a,0x81,0x81,0x81
00018c  7700              DCB      0x77,0x00
                  |L41.398|
00018e  2909              CMP      r1,#9                 ;1876
000190  d238              BCS      |L41.516|
000192  e8dff001          TBB      [pc,r1]               ;1876
000196  0510              DCB      0x05,0x10
000198  1b372337          DCB      0x1b,0x37,0x23,0x37
00019c  37372e00          DCB      0x37,0x37,0x2e,0x00
0001a0  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0001a4  4601              MOV      r1,r0                 ;1879
0001a6  6860              LDR      r0,[r4,#4]            ;1879
0001a8  0049              LSLS     r1,r1,#1              ;1879
0001aa  eb010150          ADD      r1,r1,r0,LSR #1       ;1879
0001ae  fbb1f0f0          UDIV     r0,r1,r0              ;1879
0001b2  b282              UXTH     r2,r0                 ;1879
0001b4  e027              B        |L41.518|
0001b6  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
0001ba  4601              MOV      r1,r0                 ;1882
0001bc  6860              LDR      r0,[r4,#4]            ;1882
0001be  0049              LSLS     r1,r1,#1              ;1882
0001c0  eb010150          ADD      r1,r1,r0,LSR #1       ;1882
0001c4  fbb1f0f0          UDIV     r0,r1,r0              ;1882
0001c8  b282              UXTH     r2,r0                 ;1882
0001ca  e01c              B        |L41.518|
0001cc  6860              LDR      r0,[r4,#4]            ;1885
0001ce  4932              LDR      r1,|L41.664|
0001d0  eb010150          ADD      r1,r1,r0,LSR #1       ;1885
0001d4  fbb1f0f0          UDIV     r0,r1,r0              ;1885
0001d8  b282              UXTH     r2,r0                 ;1885
0001da  e014              B        |L41.518|
0001dc  f7fffffe          BL       HAL_RCC_GetSysClockFreq
0001e0  4601              MOV      r1,r0                 ;1888
0001e2  6860              LDR      r0,[r4,#4]            ;1888
0001e4  0049              LSLS     r1,r1,#1              ;1888
0001e6  eb010150          ADD      r1,r1,r0,LSR #1       ;1888
0001ea  fbb1f0f0          UDIV     r0,r1,r0              ;1888
0001ee  b282              UXTH     r2,r0                 ;1888
0001f0  e009              B        |L41.518|
0001f2  6860              LDR      r0,[r4,#4]            ;1891
0001f4  f44f3180          MOV      r1,#0x10000           ;1891
0001f8  eb010150          ADD      r1,r1,r0,LSR #1       ;1891
0001fc  fbb1f0f0          UDIV     r0,r1,r0              ;1891
000200  b282              UXTH     r2,r0                 ;1891
000202  e000              B        |L41.518|
                  |L41.516|
000204  2501              MOVS     r5,#1                 ;1895
                  |L41.518|
000206  6821              LDR      r1,[r4,#0]            ;1901
000208  f022000f          BIC      r0,r2,#0xf            ;1899
00020c  f3c20242          UBFX     r2,r2,#1,#3           ;1900
000210  4310              ORRS     r0,r0,r2              ;1900
000212  60c8              STR      r0,[r1,#0xc]          ;1901
000214  e038              B        |L41.648|
;;;1906       {
;;;1907       case UART_CLOCKSOURCE_PCLK1:
;;;1908           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
000216  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
00021a  4601              MOV      r1,r0
00021c  e9d42000          LDRD     r2,r0,[r4,#0]
000220  eb010150          ADD      r1,r1,r0,LSR #1
000224  fbb1f0f0          UDIV     r0,r1,r0
000228  b280              UXTH     r0,r0
00022a  60d0              STR      r0,[r2,#0xc]
;;;1909         break;
00022c  e02c              B        |L41.648|
;;;1910       case UART_CLOCKSOURCE_PCLK2:
;;;1911           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
00022e  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000232  4601              MOV      r1,r0
000234  e9d42000          LDRD     r2,r0,[r4,#0]
000238  eb010150          ADD      r1,r1,r0,LSR #1
00023c  fbb1f0f0          UDIV     r0,r1,r0
000240  b280              UXTH     r0,r0
000242  60d0              STR      r0,[r2,#0xc]
;;;1912         break;
000244  e020              B        |L41.648|
;;;1913       case UART_CLOCKSOURCE_HSI:
;;;1914           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
000246  6861              LDR      r1,[r4,#4]
000248  4a14              LDR      r2,|L41.668|
00024a  eb020251          ADD      r2,r2,r1,LSR #1
00024e  fbb2f1f1          UDIV     r1,r2,r1
000252  b289              UXTH     r1,r1
000254  60c1              STR      r1,[r0,#0xc]
;;;1915         break;
000256  e017              B        |L41.648|
;;;1916       case UART_CLOCKSOURCE_SYSCLK:
;;;1917           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
000258  f7fffffe          BL       HAL_RCC_GetSysClockFreq
00025c  4601              MOV      r1,r0
00025e  e9d42000          LDRD     r2,r0,[r4,#0]
000262  eb010150          ADD      r1,r1,r0,LSR #1
000266  fbb1f0f0          UDIV     r0,r1,r0
00026a  b280              UXTH     r0,r0
00026c  60d0              STR      r0,[r2,#0xc]
;;;1918         break;
00026e  e00b              B        |L41.648|
                  |L41.624|
000270  e009              B        |L41.646|
;;;1919       case UART_CLOCKSOURCE_LSE:
;;;1920           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
000272  6861              LDR      r1,[r4,#4]
000274  f44f4200          MOV      r2,#0x8000
000278  eb020251          ADD      r2,r2,r1,LSR #1
00027c  fbb2f1f1          UDIV     r1,r2,r1
000280  b289              UXTH     r1,r1
000282  60c1              STR      r1,[r0,#0xc]
;;;1921         break;
000284  e000              B        |L41.648|
                  |L41.646|
;;;1922         case UART_CLOCKSOURCE_UNDEFINED:
;;;1923       default:
;;;1924           ret = HAL_ERROR;
000286  2501              MOVS     r5,#1
                  |L41.648|
;;;1925         break;
;;;1926       }
;;;1927     }
;;;1928   
;;;1929     return ret;
000288  4628              MOV      r0,r5
;;;1930   
;;;1931   }
00028a  e8bd81f0          POP      {r4-r8,pc}
;;;1932   
                          ENDP

00028e  0000              DCW      0x0000
                  |L41.656|
                          DCD      0xefff69f3
                  |L41.660|
                          DCD      0x40023890
                  |L41.664|
                          DCD      0x01e84800
                  |L41.668|
                          DCD      0x00f42400

                          AREA ||i.UART_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  UART_WaitOnFlagUntilTimeout PROC
;;;1337     */
;;;1338   HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1339   {
000004  4604              MOV      r4,r0
;;;1340     /* Wait until flag is set */
;;;1341     while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
000006  6800              LDR      r0,[r0,#0]
000008  4698              MOV      r8,r3                 ;1339
00000a  4615              MOV      r5,r2                 ;1339
00000c  9f06              LDR      r7,[sp,#0x18]
00000e  460e              MOV      r6,r1                 ;1339
000010  69c0              LDR      r0,[r0,#0x1c]
000012  ea310000          BICS     r0,r1,r0
000016  bf0c              ITE      EQ
000018  2001              MOVEQ    r0,#1
00001a  2000              MOVNE    r0,#0
00001c  42a8              CMP      r0,r5
00001e  d124              BNE      |L42.106|
                  |L42.32|
;;;1342     {
;;;1343       /* Check for the Timeout */
;;;1344       if(Timeout != HAL_MAX_DELAY)
000020  f1b73fff          CMP      r7,#0xffffffff
000024  d018              BEQ      |L42.88|
;;;1345       {
;;;1346         if((Timeout == 0U)||((HAL_GetTick()-Tickstart) >=  Timeout))
000026  b12f              CBZ      r7,|L42.52|
000028  f7fffffe          BL       HAL_GetTick
00002c  eba00008          SUB      r0,r0,r8
000030  42b8              CMP      r0,r7
000032  d311              BCC      |L42.88|
                  |L42.52|
;;;1347         {
;;;1348           /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;1349           CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
000034  6820              LDR      r0,[r4,#0]
;;;1350           CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1351   
;;;1352           huart->gState = HAL_UART_STATE_READY;
000036  2120              MOVS     r1,#0x20
;;;1353           huart->RxState = HAL_UART_STATE_READY;
;;;1354   
;;;1355           /* Process Unlocked */
;;;1356           __HAL_UNLOCK(huart);
000038  2200              MOVS     r2,#0
00003a  6803              LDR      r3,[r0,#0]            ;1349
00003c  f42373d0          BIC      r3,r3,#0x1a0          ;1349
000040  6003              STR      r3,[r0,#0]            ;1349
000042  6820              LDR      r0,[r4,#0]            ;1350
000044  6883              LDR      r3,[r0,#8]            ;1350
000046  f0230301          BIC      r3,r3,#1              ;1350
00004a  6083              STR      r3,[r0,#8]            ;1350
00004c  66e1              STR      r1,[r4,#0x6c]         ;1352
00004e  6721              STR      r1,[r4,#0x70]         ;1353
;;;1357           return HAL_TIMEOUT;
000050  2003              MOVS     r0,#3
000052  66a2              STR      r2,[r4,#0x68]
;;;1358         }
;;;1359       }
;;;1360     }
;;;1361     return HAL_OK;
;;;1362   }
000054  e8bd81f0          POP      {r4-r8,pc}
                  |L42.88|
000058  6820              LDR      r0,[r4,#0]            ;1357
00005a  69c0              LDR      r0,[r0,#0x1c]         ;1357
00005c  ea360000          BICS     r0,r6,r0              ;1357
000060  bf0c              ITE      EQ                    ;1357
000062  2001              MOVEQ    r0,#1                 ;1357
000064  2000              MOVNE    r0,#0                 ;1357
000066  42a8              CMP      r0,r5                 ;1357
000068  d0da              BEQ      |L42.32|
                  |L42.106|
00006a  2000              MOVS     r0,#0                 ;1361
00006c  e8bd81f0          POP      {r4-r8,pc}
;;;1363   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f7xx_hal_uart_c_d497114f____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32F7xx_HAL_Driver\\Core\\cmsis_armcc.h"
|__asm___20_stm32f7xx_hal_uart_c_d497114f____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f7xx_hal_uart_c_d497114f____REVSH|
#line 402
|__asm___20_stm32f7xx_hal_uart_c_d497114f____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f7xx_hal_uart_c_d497114f____RRX|
#line 587
|__asm___20_stm32f7xx_hal_uart_c_d497114f____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
