Disassembly Listing for RMP
Generated From:
F:/Code_Library/MCU/Mutatus/M5P1_MuProkaron/Project/MPLAB-PIC32MZ2048EFM100/RMP.X/dist/PIC32MZ2048_SK/debug/RMP.X.debug.elf
Feb 28, 2018 1:35:24 PM

---  f:/code_library/mcu/mutatus/m5p1_muprokaron/mprokaron/platform/mipsm/platform_mipsm.c  -------------
1:                   /******************************************************************************
2:                   Filename    : platform_mipsm.c
3:                   Author      : pry
4:                   Date        : 04/02/2018
5:                   Licence     : LGPL v3+; see COPYING for details.
6:                   Description : The platform specific file for MIPS M-class. 
7:                                 Currently M4k and M14kF is supported.
8:                                 Beware that sometimes GCC-based compilers will use the LWX 
9:                                 instruction, which belongs to the DSP ASE expansion. We do not
10:                                enable DSP ASE by default however, so passing no ASE flags to the
11:                                compiler is necessary.
12:                                Add -mno-dsp and -mno-dspr2
13:                  ******************************************************************************/
14:                  
15:                  /* Includes ******************************************************************/
16:                  #define __HDR_DEFS__
17:                  #include "Platform/MIPSM/platform_mipsm.h"
18:                  #include "Kernel/kernel.h"
19:                  #undef __HDR_DEFS__
20:                  
21:                  #define __HDR_STRUCTS__
22:                  #include "Platform/MIPSM/platform_mipsm.h"
23:                  #include "Kernel/kernel.h"
24:                  #undef __HDR_STRUCTS__
25:                  
26:                  /* Private include */
27:                  #include "Platform/MIPSM/platform_mipsm.h"
28:                  
29:                  #define __HDR_PUBLIC_MEMBERS__
30:                  #include "Kernel/kernel.h"
31:                  #undef __HDR_PUBLIC_MEMBERS__
32:                  /* End Includes **************************************************************/
33:                  
34:                  /* Begin Function:_RMP_Clear_Soft_Flag ****************************************
35:                  Description : Clear the software interrupt flag in the interrupt controller.
36:                  Input       : None.
37:                  Output      : None.
38:                  Return      : None.
39:                  ******************************************************************************/
40:                  void _RMP_Clear_Soft_Flag(void)
41:                  {
42:                      RMP_MIPSM_CLEAR_SOFT_FLAG();
9D00450C  24030002   ADDIU V1, ZERO, 2
9D004510  3C02BF81   LUI V0, -16511
9D004514  AC430044   SW V1, 68(V0)
9D004518  03E00008   JR RA
9D00451C  00000000   NOP
43:                  }
44:                  /* End Function:_RMP_Clear_Soft_Flag *****************************************/
45:                  
46:                  /* Begin Function:_RMP_Clear_Timer_Flag ***************************************
47:                  Description : Clear the timer interrupt flag in the interrupt controller.
48:                  Input       : None.
49:                  Output      : None.
50:                  Return      : None.
51:                  ******************************************************************************/
52:                  void _RMP_Clear_Timer_Flag(void)
53:                  {
9D004520  27BDFFE8   ADDIU SP, SP, -24
9D004524  AFBF0014   SW RA, 20(SP)
54:                      _RMP_Set_Timer(RMP_MIPSM_TICK_VAL/2);
9D004528  0F4012EE   JAL _RMP_Set_Timer
9D00452C  24042710   ADDIU A0, ZERO, 10000
55:                      RMP_MIPSM_CLEAR_TIMER_FLAG();
9D004530  24030001   ADDIU V1, ZERO, 1
9D004534  3C02BF81   LUI V0, -16511
9D004538  AC430044   SW V1, 68(V0)
56:                  }
9D00453C  8FBF0014   LW RA, 20(SP)
9D004540  03E00008   JR RA
9D004544  27BD0018   ADDIU SP, SP, 24
57:                  /* End Function:_RMP_Clear_Timer_Flag ****************************************/
58:                  
59:                  /* Begin Function:_RMP_Stack_Init *********************************************
60:                  Description : Initiate the process stack when trying to start a process. Never
61:                                call this function in user application.
62:                  Input       : ptr_t Entry - The entry of the thread.
63:                                ptr_t Stack - The stack address of the thread.
64:                                ptr_t Arg - The argument to pass to the thread.
65:                  Output      : None.
66:                  Return      : None.
67:                  ******************************************************************************/
68:                  void _RMP_Stack_Init(ptr_t Entry, ptr_t Stack, ptr_t Arg)
69:                  {
70:                      ptr_t* Stack_Ptr;
71:                      
72:                      Stack_Ptr=(ptr_t*)Stack;
73:                      /* General purpose registers */
74:                  #if(RMP_MIPSM_INIT_EXTRA==1U)
75:                      Stack_Ptr[0]=0x01010101;                                    /* R1 */
9D004548  3C020101   LUI V0, 257
9D00454C  24420101   ADDIU V0, V0, 257
9D004550  ACA20000   SW V0, 0(A1)
76:                      Stack_Ptr[1]=0x02020202;                                    /* R2 */
9D004560  3C070202   LUI A3, 514
9D004564  24E70202   ADDIU A3, A3, 514
9D004568  ACA70004   SW A3, 4(A1)
77:                      Stack_Ptr[2]=0x03030303;                                    /* R3 */
9D00456C  3C070303   LUI A3, 771
9D004570  24E70303   ADDIU A3, A3, 771
9D004574  ACA70008   SW A3, 8(A1)
78:                  #endif
79:                      Stack_Ptr[3]=Arg;                                           /* R4 */
9D004578  ACA6000C   SW A2, 12(A1)
80:                  #if(RMP_MIPSM_INIT_EXTRA==1U)
81:                      Stack_Ptr[4]=0x05050505;                                    /* R5 */
9D00457C  3C060505   LUI A2, 1285
9D004580  24C60505   ADDIU A2, A2, 1285
9D004584  ACA60010   SW A2, 16(A1)
82:                      Stack_Ptr[5]=0x06060606;                                    /* R6 */
9D004588  3C060606   LUI A2, 1542
9D00458C  24C60606   ADDIU A2, A2, 1542
9D004590  ACA60014   SW A2, 20(A1)
83:                      Stack_Ptr[6]=0x07070707;                                    /* R7 */
9D004594  3C060707   LUI A2, 1799
9D004598  24C60707   ADDIU A2, A2, 1799
9D00459C  ACA60018   SW A2, 24(A1)
84:                      Stack_Ptr[7]=0x08080808;                                    /* R8 */
9D0045A0  3C060808   LUI A2, 2056
9D0045A4  24C60808   ADDIU A2, A2, 2056
9D0045A8  ACA6001C   SW A2, 28(A1)
85:                      Stack_Ptr[8]=0x09090909;                                    /* R9 */
9D0045AC  3C060909   LUI A2, 2313
9D0045B0  24C60909   ADDIU A2, A2, 2313
9D0045B4  ACA60020   SW A2, 32(A1)
86:                      Stack_Ptr[9]=0x10101010;                                    /* R10 */
9D0045B8  3C061010   LUI A2, 4112
9D0045BC  24C61010   ADDIU A2, A2, 4112
9D0045C0  ACA60024   SW A2, 36(A1)
87:                      Stack_Ptr[10]=0x11111111;                                   /* R11 */
9D0045C4  3C061111   LUI A2, 4369
9D0045C8  24C61111   ADDIU A2, A2, 4369
9D0045CC  ACA60028   SW A2, 40(A1)
88:                      Stack_Ptr[11]=0x12121212;                                   /* R12 */
9D0045D0  3C061212   LUI A2, 4626
9D0045D4  24C61212   ADDIU A2, A2, 4626
9D0045D8  ACA6002C   SW A2, 44(A1)
89:                      Stack_Ptr[12]=0x13131313;                                   /* R13 */
9D0045DC  3C061313   LUI A2, 4883
9D0045E0  24C61313   ADDIU A2, A2, 4883
9D0045E4  ACA60030   SW A2, 48(A1)
90:                      Stack_Ptr[13]=0x14141414;                                   /* R14 */
9D0045E8  3C061414   LUI A2, 5140
9D0045EC  24C61414   ADDIU A2, A2, 5140
9D0045F0  ACA60034   SW A2, 52(A1)
91:                      Stack_Ptr[14]=0x15151515;                                   /* R15 */
9D004558  3C021515   LUI V0, 5397
9D00455C  24421515   ADDIU V0, V0, 5397
9D0045F4  ACA20038   SW V0, 56(A1)
92:                      Stack_Ptr[15]=0x16161616;                                   /* R16 */
9D0045F8  3C061616   LUI A2, 5654
9D0045FC  24C61616   ADDIU A2, A2, 5654
9D004600  ACA6003C   SW A2, 60(A1)
93:                      Stack_Ptr[16]=0x17171717;                                   /* R17 */
9D004604  3C061717   LUI A2, 5911
9D004608  24C61717   ADDIU A2, A2, 5911
9D00460C  ACA60040   SW A2, 64(A1)
94:                      Stack_Ptr[17]=0x18181818;                                   /* R18 */
9D004610  3C061818   LUI A2, 6168
9D004614  24C61818   ADDIU A2, A2, 6168
9D004618  ACA60044   SW A2, 68(A1)
95:                      Stack_Ptr[18]=0x19191919;                                   /* R19 */
9D00461C  3C061919   LUI A2, 6425
9D004620  24C61919   ADDIU A2, A2, 6425
9D004624  ACA60048   SW A2, 72(A1)
96:                      Stack_Ptr[19]=0x24242424;                                   /* R24 */
9D004628  3C062424   LUI A2, 9252
9D00462C  24C62424   ADDIU A2, A2, 9252
9D004630  ACA6004C   SW A2, 76(A1)
97:                      Stack_Ptr[20]=0x25252525;                                   /* R25 */
9D004634  3C062525   LUI A2, 9509
9D004638  24C62525   ADDIU A2, A2, 9509
9D00463C  ACA60050   SW A2, 80(A1)
98:                      Stack_Ptr[21]=0x30303030;                                   /* R30 */
9D004640  3C063030   LUI A2, 12336
9D004644  24C63030   ADDIU A2, A2, 12336
9D004648  ACA60054   SW A2, 84(A1)
99:                      Stack_Ptr[22]=0x31313131;                                   /* R31 */
9D00464C  3C063131   LUI A2, 12593
9D004650  24C63131   ADDIU A2, A2, 12593
9D004654  ACA60058   SW A2, 88(A1)
100:                     /* Kernel registers */
101:                     Stack_Ptr[23]=0x26262626;                                   /* R26 */
9D004658  3C062626   LUI A2, 9766
9D00465C  24C62626   ADDIU A2, A2, 9766
9D004660  ACA6005C   SW A2, 92(A1)
102:                     Stack_Ptr[24]=0x27272727;                                   /* R27 */
9D004664  3C062727   LUI A2, 10023
9D004668  24C62727   ADDIU A2, A2, 10023
9D00466C  ACA60060   SW A2, 96(A1)
103:                 #endif
104:                     Stack_Ptr[25]=RMP_GP_Val;                                   /* R28 */
9D004554  8F838094   LW V1, -32620(GP)
9D004670  ACA30064   SW V1, 100(A1)
105:                 #if(RMP_MIPSM_INIT_EXTRA==1U)
106:                     /* Multiply/divide */
107:                     Stack_Ptr[26]=0x15151515;                                    /* LO */
9D004674  ACA20068   SW V0, 104(A1)
108:                     Stack_Ptr[27]=0x51515151;                                    /* HI */
9D004678  3C025151   LUI V0, 20817
9D00467C  24425151   ADDIU V0, V0, 20817
9D004680  ACA2006C   SW V0, 108(A1)
109:                 #endif
110:                     /* Status registers */
111:                     Stack_Ptr[28]=RMP_MIPSM_STATUS_IE|RMP_MIPSM_STATUS_EXL;     /* CP0_STATUS */
9D004684  24020003   ADDIU V0, ZERO, 3
9D004688  ACA20070   SW V0, 112(A1)
112:                     Stack_Ptr[29]=Entry;                                        /* CP0_EPC */
9D00468C  ACA40074   SW A0, 116(A1)
113:                 #if(RMP_MIPSM_INIT_EXTRA==1U)
114:                     /* Some general-purpose scratch regs */
115:                     Stack_Ptr[30]=0x20202020;                                   /* R20 */
9D004690  3C022020   LUI V0, 8224
9D004694  24422020   ADDIU V0, V0, 8224
9D004698  ACA20078   SW V0, 120(A1)
116:                     Stack_Ptr[31]=0x21212121;                                   /* R21 */
9D00469C  3C022121   LUI V0, 8481
9D0046A0  24422121   ADDIU V0, V0, 8481
9D0046A4  ACA2007C   SW V0, 124(A1)
117:                     Stack_Ptr[32]=0x22222222;                                   /* R22 */
9D0046A8  3C022222   LUI V0, 8738
9D0046AC  24422222   ADDIU V0, V0, 8738
9D0046B0  ACA20080   SW V0, 128(A1)
118:                     Stack_Ptr[33]=0x23232323;                                   /* R23 */
9D0046B4  3C022323   LUI V0, 8995
9D0046B8  24422323   ADDIU V0, V0, 8995
9D0046BC  03E00008   JR RA
9D0046C0  ACA20084   SW V0, 132(A1)
119:                 #endif
120:                 }
121:                 /* End Function:_RMP_Stack_Init **********************************************/
122:                 
123:                 /* Begin Function:_RMP_Low_Level_Init *****************************************
124:                 Description : Initialize the low level hardware of the system.
125:                 Input       : None
126:                 Output      : None.
127:                 Return      : None.
128:                 ******************************************************************************/
129:                 void _RMP_Low_Level_Init(void)
130:                 {
9D0046C4  27BDFFE8   ADDIU SP, SP, -24
9D0046C8  AFBF0014   SW RA, 20(SP)
131:                     RMP_MIPSM_LOW_LEVEL_INIT();
9D0046CC  3C02BF80   LUI V0, -16512
9D0046D0  3C03AA99   LUI V1, -21863
9D0046D4  24636655   ADDIU V1, V1, 26197
9D0046D8  AC430030   SW V1, 48(V0)
9D0046DC  3C035566   LUI V1, 21862
9D0046E0  346399AA   ORI V1, V1, -26198
9D0046E4  AC430030   SW V1, 48(V0)
9D0046E8  94431310   LHU V1, 4880(V0)
9D0046EC  24040004   ADDIU A0, ZERO, 4
9D0046F0  7C833004   INS V1, A0, 0, 7
9D0046F4  A4431310   SH V1, 4880(V0)
9D0046F8  94431320   LHU V1, 4896(V0)
9D0046FC  7C833004   INS V1, A0, 0, 7
9D004700  A4431320   SH V1, 4896(V0)
9D004704  94431330   LHU V1, 4912(V0)
9D004708  7C033004   INS V1, ZERO, 0, 7
9D00470C  A4431330   SH V1, 4912(V0)
9D004710  AC400030   SW ZERO, 48(V0)
9D004714  41626000   DI V0
9D004718  000000C0   EHB
9D00471C  3C020080   LUI V0, 128
9D004720  40036800   MFC0 V1, Cause
9D004724  00621025   OR V0, V1, V0
9D004728  40826800   MTC0 V0, Cause
9D00472C  000000C0   EHB
9D004730  3C02BF82   LUI V0, -16510
9D004734  3C03BF81   LUI V1, -16511
9D004738  24040003   ADDIU A0, ZERO, 3
9D00473C  24051000   ADDIU A1, ZERO, 4096
9D004740  AC650008   SW A1, 8(V1)
9D004744  AC640044   SW A0, 68(V1)
9D004748  24051F1F   ADDIU A1, ZERO, 7967
9D00474C  AC650144   SW A1, 324(V1)
9D004750  24050404   ADDIU A1, ZERO, 1028
9D004754  AC650148   SW A1, 328(V1)
9D004758  24050002   ADDIU A1, ZERO, 2
9D00475C  AC6500C4   SW A1, 196(V1)
9D004760  AC6400C8   SW A0, 200(V1)
9D004764  AC402000   SW ZERO, 8192(V0)
9D004768  8C442010   LW A0, 8208(V0)
9D00476C  24030001   ADDIU V1, ZERO, 1
9D004770  7C645284   INS A0, V1, 10, 1
9D004774  AC442010   SW A0, 8208(V0)
9D004778  94452000   LHU A1, 8192(V0)
9D00477C  3C04BF80   LUI A0, -16512
9D004780  7C6518C4   INS A1, V1, 3, 1
9D004784  A4452000   SH A1, 8192(V0)
9D004788  24050056   ADDIU A1, ZERO, 86
9D00478C  AC452040   SW A1, 8256(V0)
9D004790  908515FC   LBU A1, 5628(A0)
9D004794  7C651804   INS A1, V1, 0, 4
9D004798  A08515FC   SB A1, 5628(A0)
9D00479C  34038000   ORI V1, ZERO, -32768
9D0047A0  AC432008   SW V1, 8200(V0)
132:                     
133:                     RMP_Int_Disable();
9D0047A4  0F4012E8   JAL RMP_Int_Disable
9D0047A8  00000000   NOP
134:                     RMP_Int_Nest=0;
9D0047B0  AF808098   SW ZERO, -32616(GP)
135:                     
136:                     /* Set the timer timeout value */
137:                     _RMP_Set_Timer(RMP_MIPSM_TICK_VAL/2);
9D0047AC  24042710   ADDIU A0, ZERO, 10000
9D0047B8  0B4012EE   J _RMP_Set_Timer
9D0047BC  27BD0018   ADDIU SP, SP, 24
138:                 }
9D0047B4  8FBF0014   LW RA, 20(SP)
139:                 /* End Function:_RMP_Low_Level_Init ******************************************/
140:                 
141:                 /* Begin Function:_RMP_Plat_Hook **********************************************
142:                 Description : Platform-specific hook for system initialization.
143:                 Input       : None
144:                 Output      : None.
145:                 Return      : None.
146:                 ******************************************************************************/
147:                 void _RMP_Plat_Hook(void)
148:                 {
149:                     RMP_Int_Enable();
9D0047C0  0B4012EB   J RMP_Int_Enable
9D0047C4  00000000   NOP
150:                 }
151:                 /* End Function:_RMP_Plat_Hook ***********************************************/
152:                 
153:                 /* Begin Function:RMP_Putchar *************************************************
154:                 Description : Print a character to the debug console.
155:                 Input       : char Char - The character to print.
156:                 Output      : None.
157:                 Return      : None.
158:                 ******************************************************************************/
159:                 void RMP_Putchar(char Char)
160:                 {
9D0047C8  3C03BF82   LUI V1, -16510
161:                     RMP_MIPSM_PUTCHAR(Char);
9D0047CC  8C622010   LW V0, 8208(V1)
162:                 }
163:                 /* End Function:RMP_Putchar **************************************************/
164:                 
165:                 /* End Of File ***************************************************************/
166:                 
167:                 /* Copyright (C) Evo-Devo Instrum. All rights reserved ***********************/
---  f:/code_library/mcu/mutatus/m5p1_muprokaron/mprokaron/kernel/kernel.c  -----------------------------
1:                   /******************************************************************************
2:                   Filename    : kernel.c
3:                   Author      : pry
4:                   Date        : 04/02/2018
5:                   Licence     : LGPL v3+; see COPYING for details.
6:                   Description : The RMP RTOS single-file kernel.
7:                                 This is a single-process kernel that does nothing but simple thread
8:                                 context switches. This operating system's kernel object allocation
9:                                 policy is totally exported, so the user assume full control over this.
10:                  ******************************************************************************/
11:                  
12:                  /* Includes ******************************************************************/
13:                  #define __HDR_DEFS__
14:                  #include "Platform/RMP_platform.h"
15:                  #include "Kernel/kernel.h"
16:                  #undef __HDR_DEFS__
17:                  
18:                  #define __HDR_STRUCTS__
19:                  #include "Platform/RMP_platform.h"
20:                  #include "Kernel/kernel.h"
21:                  #undef __HDR_STRUCTS__
22:                  
23:                  /* Private include */
24:                  #include "Kernel/kernel.h"
25:                  
26:                  #define __HDR_PUBLIC_MEMBERS__
27:                  #include "Platform/RMP_platform.h"
28:                  #undef __HDR_PUBLIC_MEMBERS__
29:                  /* End Includes **************************************************************/
30:                  
31:                  /* Begin Function:RMP_Clear ***************************************************
32:                  Description : Memset a memory area to zero.
33:                  Input       : void* Addr - The address to clear.
34:                                ptr_t Size - The size to clear.
35:                  Output      : None.
36:                  Return      : None.
37:                  ******************************************************************************/
38:                  void RMP_Clear(void* Addr, ptr_t Size)
39:                  {
9D00093C  27BDFFE0   ADDIU SP, SP, -32
9D000940  AFBF001C   SW RA, 28(SP)
9D000944  AFB20018   SW S2, 24(SP)
9D000948  AFB10014   SW S1, 20(SP)
9D00094C  AFB00010   SW S0, 16(SP)
9D000950  00A08821   ADDU S1, A1, ZERO
40:                      ptr_t* Word_Inc;
41:                      u8* Byte_Inc;
42:                      ptr_t Words;
43:                      ptr_t Bytes;
44:                      
45:                      /* On processors not that fast, copy by word is really important */
46:                      Word_Inc=(ptr_t*)Addr;
47:                      for(Words=Size/sizeof(ptr_t);Words>0;Words--)
9D000954  00053082   SRL A2, A1, 2
9D000958  10C00006   BEQ A2, ZERO, 0x9D000974
9D00095C  00808021   ADDU S0, A0, ZERO
48:                      {
49:                          *Word_Inc=0;
9D000960  00069080   SLL S2, A2, 2
9D000964  00002821   ADDU A1, ZERO, ZERO
9D000968  0F401295   JAL memset
9D00096C  02403021   ADDU A2, S2, ZERO
9D000970  02128021   ADDU S0, S0, S2
50:                          Word_Inc++;
51:                      }
52:                      
53:                      /* Get the final bytes */
54:                      Byte_Inc=(u8*)Word_Inc;
55:                      for(Bytes=Size%sizeof(ptr_t);Bytes>0;Bytes--)
9D000974  32260003   ANDI A2, S1, 3
9D000978  10C00008   BEQ A2, ZERO, .LVL22
9D00097C  02002021   ADDU A0, S0, ZERO
9D000980  00002821   ADDU A1, ZERO, ZERO
56:                      {
57:                          *Byte_Inc=0;
58:                          Byte_Inc++;
59:                      }
60:                  }
9D000984  8FBF001C   LW RA, 28(SP)
9D000988  8FB20018   LW S2, 24(SP)
9D00098C  8FB10014   LW S1, 20(SP)
9D000990  8FB00010   LW S0, 16(SP)
9D000994  0B401295   J memset
9D000998  27BD0020   ADDIU SP, SP, 32
9D00099C  8FBF001C   LW RA, 28(SP)
9D0009A0  8FB20018   LW S2, 24(SP)
9D0009A4  8FB10014   LW S1, 20(SP)
9D0009A8  8FB00010   LW S0, 16(SP)
9D0009AC  03E00008   JR RA
9D0009B0  27BD0020   ADDIU SP, SP, 32
61:                  /* End Function:RMP_Clear ****************************************************/
62:                  
63:                  /* Begin Function:RMP_Int_Print ***********************************************
64:                  Description : Print a signed integer on the debugging console. This integer is
65:                                printed as decimal with sign.
66:                  Input       : cnt_t Int - The integer to print.
67:                  Output      : None.
68:                  Return      : cnt_t - The length of the string printed.
69:                  ******************************************************************************/
70:                  cnt_t RMP_Int_Print(cnt_t Int)
71:                  {
9D0009B4  27BDFFD8   ADDIU SP, SP, -40
9D0009B8  AFBF0024   SW RA, 36(SP)
9D0009BC  AFB40020   SW S4, 32(SP)
9D0009C0  AFB3001C   SW S3, 28(SP)
9D0009C4  AFB20018   SW S2, 24(SP)
9D0009C8  AFB10014   SW S1, 20(SP)
72:                      ptr_t Iter;
73:                      cnt_t Count;
74:                      cnt_t Num;
75:                      ptr_t Div;
76:                      
77:                      /* how many digits are there? */
78:                      if(Int==0)
9D0009CC  10800050   BEQ A0, ZERO, 0x9D000B10
9D0009D0  AFB00010   SW S0, 16(SP)
79:                      {
80:                          RMP_Putchar('0');
9D000B10  0F4011F2   JAL RMP_Putchar
9D000B14  24040030   ADDIU A0, ZERO, 48
81:                          return 1;
9D000B18  24020001   ADDIU V0, ZERO, 1
82:                      }
83:                      else if(Int<0)
9D0009D4  04800028   BLTZ A0, 0x9D000A78
9D0009D8  00801821   ADDU V1, A0, ZERO
84:                      {
85:                          /* How many digits are there? */
86:                          Count=0;
9D000A88  00001821   ADDU V1, ZERO, ZERO
87:                          Div=1;
88:                          Iter=-Int;
9D000A78  00049823   SUBU S3, ZERO, A0
89:                          while(Iter!=0)
9D000A7C  1260002F   BEQ S3, ZERO, 0x9D000B3C
9D000A80  24110001   ADDIU S1, ZERO, 1
9D000A84  02601021   ADDU V0, S3, ZERO
9D000AB4  1440FFF8   BNE V0, ZERO, 0x9D000A98
9D000AB8  00918821   ADDU S1, A0, S1
90:                          {
91:                              Iter/=10;
9D000A8C  3C05CCCC   LUI A1, -13108
9D000A90  0B4002A7   J 0x9D000A9C
9D000A94  34A5CCCD   ORI A1, A1, -13107
9D000A9C  00450019   MULTU 0, V0, A1
9D000AA0  00001010   MFHI V0
9D000AB0  000210C2   SRL V0, V0, 3
92:                              Count++;
9D000A98  02001821   ADDU V1, S0, ZERO
9D000AAC  24700001   ADDIU S0, V1, 1
93:                              Div*=10;
9D000AA4  00112040   SLL A0, S1, 1
9D000AA8  001188C0   SLL S1, S1, 3
94:                          }
95:                          Div/=10;
9D000ABC  02250019   MULTU 0, S1, A1
9D000AC0  00008810   MFHI S1
96:                          
97:                          RMP_Putchar('-');
9D000AC4  2404002D   ADDIU A0, ZERO, 45
9D000AD0  0F4011F2   JAL RMP_Putchar
9D000AD4  001188C2   SRL S1, S1, 3
9D000B3C  0F4011F2   JAL RMP_Putchar
9D000B40  2404002D   ADDIU A0, ZERO, 45
98:                          Iter=-Int;
99:                          Num=Count+1;
9D000AC8  24720002   ADDIU S2, V1, 2
9D000B44  0B400296   J 0x9D000A58
9D000B48  24020001   ADDIU V0, ZERO, 1
100:                         
101:                         while(Count>0)
9D000B00  1600FFF5   BNE S0, ZERO, .LVL50
9D000B04  001188C2   SRL S1, S1, 3
9D000B08  0B400296   J 0x9D000A58
9D000B0C  02401021   ADDU V0, S2, ZERO
102:                         {
103:                             Count--;
9D000AE8  2610FFFF   ADDIU S0, S0, -1
104:                             RMP_Putchar(Iter/Div+'0');
9D000AD8  0271001B   DIVU S3, S1
9D000ADC  022001F4   TEQ S1, ZERO
9D000AE0  00009810   MFHI S3
9D000AE4  00002012   MFLO A0
9D000AEC  24840030   ADDIU A0, A0, 48
9D000AF0  0F4011F2   JAL RMP_Putchar
9D000AF4  7C042420   SEB A0, A0
105:                             Iter=Iter%Div;
106:                             Div/=10;
9D000ACC  00A0A021   ADDU S4, A1, ZERO
9D000AF8  02340019   MULTU 0, S1, S4
9D000AFC  00008810   MFHI S1
107:                         }
108:                     }
109:                     else
110:                     {
111:                         /* How many digits are there? */
112:                         Count=0;
9D0009E0  00009021   ADDU S2, ZERO, ZERO
113:                         Div=1;
9D0009DC  24100001   ADDIU S0, ZERO, 1
114:                         Iter=Int;
115:                         while(Iter!=0)
9D000A04  1460FFF9   BNE V1, ZERO, 0x9D0009EC
9D000A08  00508021   ADDU S0, V0, S0
116:                         {
117:                             Iter/=10;
9D0009E4  3C05CCCC   LUI A1, -13108
9D0009E8  34A5CCCD   ORI A1, A1, -13107
9D0009EC  00650019   MULTU 0, V1, A1
9D0009F0  00001810   MFHI V1
9D000A00  000318C2   SRL V1, V1, 3
118:                             Count++;
9D0009FC  26520001   ADDIU S2, S2, 1
119:                             Div*=10;
9D0009F4  00101040   SLL V0, S0, 1
9D0009F8  001080C0   SLL S0, S0, 3
120:                         }
121:                         Div/=10;
9D000A0C  02050019   MULTU 0, S0, A1
9D000A10  00008010   MFHI S0
9D000A14  02408821   ADDU S1, S2, ZERO
9D000A1C  001080C2   SRL S0, S0, 3
122:                         
123:                         Iter=Int;
124:                         Num=Count;
125:                         
126:                         while(Count>0)
9D000A4C  1620FFF4   BNE S1, ZERO, 0x9D000A20
9D000A50  001080C2   SRL S0, S0, 3
9D000A54  02401021   ADDU V0, S2, ZERO
127:                         {
128:                             Count--;
9D000A30  2631FFFF   ADDIU S1, S1, -1
129:                             RMP_Putchar(Iter/Div+'0');
9D000A20  0090001B   DIVU A0, S0
9D000A24  020001F4   TEQ S0, ZERO
9D000A28  00009810   MFHI S3
9D000A2C  00002012   MFLO A0
9D000A34  24840030   ADDIU A0, A0, 48
9D000A38  0F4011F2   JAL RMP_Putchar
9D000A3C  7C042420   SEB A0, A0
130:                             Iter=Iter%Div;
9D000A48  02602021   ADDU A0, S3, ZERO
131:                             Div/=10;
9D000A18  00A0A021   ADDU S4, A1, ZERO
9D000A40  02140019   MULTU 0, S0, S4
9D000A44  00008010   MFHI S0
132:                         }
133:                     }
134:                     
135:                     return Num;
136:                 }
9D000A58  8FBF0024   LW RA, 36(SP)
9D000A5C  8FB40020   LW S4, 32(SP)
9D000A60  8FB3001C   LW S3, 28(SP)
9D000A64  8FB20018   LW S2, 24(SP)
9D000A68  8FB10014   LW S1, 20(SP)
9D000A6C  8FB00010   LW S0, 16(SP)
9D000A70  03E00008   JR RA
9D000A74  27BD0028   ADDIU SP, SP, 40
9D000B1C  8FBF0024   LW RA, 36(SP)
9D000B20  8FB40020   LW S4, 32(SP)
9D000B24  8FB3001C   LW S3, 28(SP)
9D000B28  8FB20018   LW S2, 24(SP)
9D000B2C  8FB10014   LW S1, 20(SP)
9D000B30  8FB00010   LW S0, 16(SP)
9D000B34  03E00008   JR RA
9D000B38  27BD0028   ADDIU SP, SP, 40
137:                 /* End Function:RMP_Int_Print ************************************************/
138:                 
139:                 /* Begin Function:RMP_Hex_Print **********************************************
140:                 Description : Print a unsigned integer on the debugging console. This integer is
141:                               printed as hexadecimal.
142:                 Input       : ptr_t Uint - The unsigned integer to print.
143:                 Output      : None.
144:                 Return      : cnt_t - The length of the string printed.
145:                 ******************************************************************************/
146:                 cnt_t RMP_Hex_Print(ptr_t Uint)
147:                 {
9D000B4C  27BDFFD8   ADDIU SP, SP, -40
9D000B50  AFBF0024   SW RA, 36(SP)
9D000B54  AFB30020   SW S3, 32(SP)
9D000B58  AFB2001C   SW S2, 28(SP)
9D000B5C  AFB10018   SW S1, 24(SP)
9D000B60  AFB00014   SW S0, 20(SP)
148:                     ptr_t Iter;
149:                     cnt_t Count;
150:                     cnt_t Num;
151:                     
152:                     /* how many digits are there? */
153:                     if(Uint==0)
9D000B64  10800023   BEQ A0, ZERO, 0x9D000BF4
9D000B68  00809021   ADDU S2, A0, ZERO
154:                     {
155:                         RMP_Putchar('0');
9D000BF4  0F4011F2   JAL RMP_Putchar
9D000BF8  24040030   ADDIU A0, ZERO, 48
156:                         return 1;
9D000BFC  24020001   ADDIU V0, ZERO, 1
157:                     }
158:                     else
159:                     {
160:                         /* Filter out all the zeroes */
161:                         Count=0;
162:                         Iter=Uint;
163:                         while((Iter>>((sizeof(ptr_t)*8)-4))==0)
9D000B6C  00042702   SRL A0, A0, 28
9D000B70  02401821   ADDU V1, S2, ZERO
9D000B74  14800029   BNE A0, ZERO, 0x9D000C1C
9D000B78  00001021   ADDU V0, ZERO, ZERO
9D000B80  00032F02   SRL A1, V1, 28
9D000B84  10A0FFFD   BEQ A1, ZERO, 0x9D000B7C
9D000B88  24420001   ADDIU V0, V0, 1
9D000BA4  02608021   ADDU S0, S3, ZERO
164:                         {
165:                             Iter<<=4;
9D000B7C  00031900   SLL V1, V1, 4
166:                             Count++;
167:                         }
168:                         /* Count is the number of pts to print */
169:                         Count=sizeof(ptr_t)*2-Count;
9D000B8C  24130008   ADDIU S3, ZERO, 8
9D000B90  02621023   SUBU V0, S3, V0
9D000C1C  0B4002E7   J 0x9D000B9C
9D000C20  24130008   ADDIU S3, ZERO, 8
170:                         Num=Count;
171:                         while(Count>0)
9D000B94  18400010   BLEZ V0, 0x9D000BD8
9D000B98  00409821   ADDU S3, V0, ZERO
9D000B9C  2671FFFF   ADDIU S1, S3, -1
9D000BA0  00118880   SLL S1, S1, 2
9D000BCC  1E00FFF7   BGTZ S0, 0x9D000BAC
9D000BD0  02321806   SRLV V1, S2, S1
9D000BD4  02601021   ADDU V0, S3, ZERO
172:                         {
173:                             Count--;
174:                             Iter=(Uint>>(Count*4))&0x0F;
9D000BA8  02321806   SRLV V1, S2, S1
9D000BAC  3063000F   ANDI V1, V1, 15
175:                             if(Iter<10)
9D000BB0  2C65000A   SLTIU A1, V1, 10
9D000BB8  14A00002   BNE A1, ZERO, 0x9D000BC4
9D000BBC  2610FFFF   ADDIU S0, S0, -1
176:                                 RMP_Putchar('0'+Iter);
9D000BB4  24640030   ADDIU A0, V1, 48
177:                             else
178:                                 RMP_Putchar('A'+Iter-10);
9D000BC0  24640037   ADDIU A0, V1, 55
9D000BC4  0F4011F2   JAL RMP_Putchar
9D000BC8  2631FFFC   ADDIU S1, S1, -4
179:                         }
180:                     }
181:                     
182:                     return Num;
183:                 }
9D000BD8  8FBF0024   LW RA, 36(SP)
9D000BDC  8FB30020   LW S3, 32(SP)
9D000BE0  8FB2001C   LW S2, 28(SP)
9D000BE4  8FB10018   LW S1, 24(SP)
9D000BE8  8FB00014   LW S0, 20(SP)
9D000BEC  03E00008   JR RA
9D000BF0  27BD0028   ADDIU SP, SP, 40
9D000C00  8FBF0024   LW RA, 36(SP)
9D000C04  8FB30020   LW S3, 32(SP)
9D000C08  8FB2001C   LW S2, 28(SP)
9D000C0C  8FB10018   LW S1, 24(SP)
9D000C10  8FB00014   LW S0, 20(SP)
9D000C14  03E00008   JR RA
9D000C18  27BD0028   ADDIU SP, SP, 40
184:                 /* End Function:RMP_Hex_Print ***********************************************/
185:                 
186:                 /* Begin Function:RMP_Str_Print ********************************************
187:                 Description : Print a string the kernel console.
188:                               This is only used for kernel-level debugging.
189:                 Input       : s8* String - The string to print
190:                 Output      : None.
191:                 Return      : cnt_t - The length of the string printed, the '\0' is not included.
192:                 ******************************************************************************/
193:                 cnt_t RMP_Str_Print(s8* String)
194:                 {
9D000C24  27BDFFE0   ADDIU SP, SP, -32
9D000C28  AFBF001C   SW RA, 28(SP)
9D000C2C  AFB20018   SW S2, 24(SP)
9D000C30  AFB10014   SW S1, 20(SP)
9D000C34  AFB00010   SW S0, 16(SP)
9D000C38  00808821   ADDU S1, A0, ZERO
195:                     cnt_t Count;
196:                     
197:                     Count=0;
9D000C3C  00008021   ADDU S0, ZERO, ZERO
198:                     while(Count<RMP_DEBUG_PRINT_MAX)
9D000C40  0B400316   J 0x9D000C58
9D000C44  241200FF   ADDIU S2, ZERO, 255
9D000C50  12120006   BEQ S0, S2, 0x9D000C6C
9D000C54  02001021   ADDU V0, S0, ZERO
9D000C58  02301021   ADDU V0, S1, S0
199:                     {
200:                         if(String[Count]=='\0')
9D000C5C  80420000   LB V0, 0(V0)
9D000C60  1440FFF9   BNE V0, ZERO, 0x9D000C48
9D000C64  00402021   ADDU A0, V0, ZERO
201:                             break;
202:                         
203:                         RMP_Putchar(String[Count++]);
9D000C48  0F4011F2   JAL RMP_Putchar
9D000C4C  26100001   ADDIU S0, S0, 1
204:                     }
205:                     
206:                     return Count;
207:                 }
9D000C68  02001021   ADDU V0, S0, ZERO
9D000C6C  8FBF001C   LW RA, 28(SP)
9D000C70  8FB20018   LW S2, 24(SP)
9D000C74  8FB10014   LW S1, 20(SP)
9D000C78  8FB00010   LW S0, 16(SP)
9D000C7C  03E00008   JR RA
9D000C80  27BD0020   ADDIU SP, SP, 32
208:                 /* End Function:RMP_Str_Print *********************************************/
209:                 
210:                 /* Begin Function:RMP_List_Crt ************************************************
211:                 Description : Create a doubly linkled list.
212:                 Input       : volatile struct RMP_List* Head - The pointer to the list head.
213:                 Output      : None.
214:                 Return      : None.
215:                 ******************************************************************************/
216:                 void RMP_List_Crt(volatile struct RMP_List* Head)
217:                 {
218:                     Head->Prev=(struct RMP_List*)Head;
9D000C84  AC840000   SW A0, 0(A0)
9D00103C  AE040010   SW A0, 16(S0)
9D00282C  AC840000   SW A0, 0(A0)
9D003708  27848078   ADDIU A0, GP, -32648
9D003728  AF848078   SW A0, -32648(GP)
9D003730  AC420000   SW V0, 0(V0)
9D003760  3C028000   LUI V0, -32768
9D003764  244214A4   ADDIU V0, V0, 5284
9D00378C  AE020010   SW V0, 16(S0)
219:                     Head->Next=(struct RMP_List*)Head;
9D000C88  AC840004   SW A0, 4(A0)
9D000C8C  03E00008   JR RA
9D000C90  00000000   NOP
9D00104C  AE040014   SW A0, 20(S0)
9D002830  AC840004   SW A0, 4(A0)
9D00372C  AF84807C   SW A0, -32644(GP)
9D003734  AC420004   SW V0, 4(V0)
9D003790  AE020014   SW V0, 20(S0)
220:                 }
221:                 /* End Function:RMP_List_Crt *************************************************/
222:                 
223:                 /* Begin Function:RMP_List_Del ************************************************
224:                 Description : Delete a node from the doubly-linked list.
225:                 Input       : volatile struct RMP_List* Prev - The prevoius node of the target node.
226:                               volatile struct RMP_List* Next - The next node of the target node.
227:                 Output      : None.
228:                 Return      : None.
229:                 ******************************************************************************/
230:                 void RMP_List_Del(volatile struct RMP_List* Prev,volatile struct RMP_List* Next)
231:                 {
232:                     Next->Prev=(struct RMP_List*)Prev;
9D00089C  ACC50000   SW A1, 0(A2)
9D000924  ACA40000   SW A0, 0(A1)
9D000C94  ACA40000   SW A0, 0(A1)
9D000E6C  ACA40000   SW A0, 0(A1)
9D001280  ACC50000   SW A1, 0(A2)
9D001368  ACC50000   SW A1, 0(A2)
9D0013C0  AC620000   SW V0, 0(V1)
9D001474  AC620000   SW V0, 0(V1)
9D001484  AC620000   SW V0, 0(V1)
9D0015B4  AC620000   SW V0, 0(V1)
9D0017B8  AC620000   SW V0, 0(V1)
9D001B80  AD070000   SW A3, 0(T0)
9D001D88  ACC30000   SW V1, 0(A2)
9D002000  ACC30000   SW V1, 0(A2)
9D002084  AC830000   SW V1, 0(A0)
9D0021FC  ACA40000   SW A0, 0(A1)
9D002228  ACC40000   SW A0, 0(A2)
9D0024BC  ACA30000   SW V1, 0(A1)
9D0025A8  ACA30000   SW V1, 0(A1)
9D002658  ACC50000   SW A1, 0(A2)
9D002A48  ACC50000   SW A1, 0(A2)
9D002A60  ACC50000   SW A1, 0(A2)
9D002C4C  ACE60000   SW A2, 0(A3)
9D002FC4  ACC50000   SW A1, 0(A2)
9D003040  ACA30000   SW V1, 0(A1)
9D0032D4  ACE60000   SW A2, 0(A3)
9D0032EC  ACE60000   SW A2, 0(A3)
9D0035C0  AC830000   SW V1, 0(A0)
9D00368C  AC830000   SW V1, 0(A0)
233:                     Prev->Next=(struct RMP_List*)Next;
9D0008A0  ACA60004   SW A2, 4(A1)
9D000928  AC850004   SW A1, 4(A0)
9D000C98  AC850004   SW A1, 4(A0)
9D000C9C  03E00008   JR RA
9D000CA0  00000000   NOP
9D000E70  AC850004   SW A1, 4(A0)
9D001284  ACA60004   SW A2, 4(A1)
9D00136C  ACA60004   SW A2, 4(A1)
9D0013C4  AC430004   SW V1, 4(V0)
9D001478  AC430004   SW V1, 4(V0)
9D001488  AC430004   SW V1, 4(V0)
9D0015B8  AC430004   SW V1, 4(V0)
9D0017BC  AC430004   SW V1, 4(V0)
9D001B84  ACE80004   SW T0, 4(A3)
9D001D8C  AC660004   SW A2, 4(V1)
9D002004  AC660004   SW A2, 4(V1)
9D002088  AC640004   SW A0, 4(V1)
9D002200  AC850004   SW A1, 4(A0)
9D00222C  AC860004   SW A2, 4(A0)
9D0024C0  AC650004   SW A1, 4(V1)
9D0025AC  AC650004   SW A1, 4(V1)
9D00265C  ACA60004   SW A2, 4(A1)
9D002A4C  ACA60004   SW A2, 4(A1)
9D002A64  ACA60004   SW A2, 4(A1)
9D002C50  ACC70004   SW A3, 4(A2)
9D002FC8  ACA60004   SW A2, 4(A1)
9D003044  AC650004   SW A1, 4(V1)
9D0032D8  ACC70004   SW A3, 4(A2)
9D0032F0  ACC70004   SW A3, 4(A2)
9D0035C4  AC640004   SW A0, 4(V1)
9D003690  AC640004   SW A0, 4(V1)
234:                 }
235:                 /* End Function:RMP_List_Del *************************************************/
236:                 
237:                 /* Begin Function:RMP_List_Ins ************************************************
238:                 Description : Insert a node to the doubly-linked list.
239:                 Input       : volatile struct RMP_List* New - The new node to insert.
240:                               volatile struct RMP_List* Prev - The previous node.
241:                               volatile struct RMP_List* Next - The next node.
242:                 Output      : None.
243:                 Return      : None.
244:                 ******************************************************************************/
245:                 void RMP_List_Ins(volatile struct RMP_List* New,
246:                                   volatile struct RMP_List* Prev,
247:                                   volatile struct RMP_List* Next)
248:                 {
249:                     Next->Prev=(struct RMP_List*)New;
9D0008DC  AC820000   SW V0, 0(A0)
9D000CA4  ACC40000   SW A0, 0(A2)
9D000E9C  ACC40000   SW A0, 0(A2)
9D001068  AC700000   SW S0, 0(V1)
9D0012C0  ACA20000   SW V0, 0(A1)
9D0015F4  AC440000   SW A0, 0(V0)
9D001A50  ACA40000   SW A0, 0(A1)
9D001BAC  AC820010   SW V0, 16(A0)
9D001CBC  AC640000   SW A0, 0(V1)
9D001D48  AC470000   SW A3, 0(V0)
9D001F84  ACC40000   SW A0, 0(A2)
9D0021AC  AC820000   SW V0, 0(A0)
9D002394  AC460000   SW A2, 0(V0)
9D002528  AC460000   SW A2, 0(V0)
9D0026D4  ACA40000   SW A0, 0(A1)
9D002A88  ACA20000   SW V0, 0(A1)
9D002C74  AE220000   SW V0, 0(S1)
9D002DAC  AC460000   SW A2, 0(V0)
9D003080  AC640000   SW A0, 0(V1)
9D003314  ACC20000   SW V0, 0(A2)
9D0035F0  AC700000   SW S0, 0(V1)
9D003798  AE501CD0   SW S0, 7376(S2)
250:                     New->Next=(struct RMP_List*)Next;
9D0008E4  AC440004   SW A0, 4(V0)
9D000CA8  AC860004   SW A2, 4(A0)
9D000EA0  AC860004   SW A2, 4(A0)
9D00106C  AE030004   SW V1, 4(S0)
9D0012C8  AC450004   SW A1, 4(V0)
9D0015F8  AC820004   SW V0, 4(A0)
9D001A5C  AC850004   SW A1, 4(A0)
9D001BB0  AC480004   SW T0, 4(V0)
9D001CC8  AC830004   SW V1, 4(A0)
9D001D4C  AC62000C   SW V0, 12(V1)
9D001F90  AC860004   SW A2, 4(A0)
9D0021B8  AC440004   SW A0, 4(V0)
9D002398  AC62000C   SW V0, 12(V1)
9D00252C  ACA2000C   SW V0, 12(A1)
9D0026E0  AC850004   SW A1, 4(A0)
9D002A90  AC450004   SW A1, 4(V0)
9D002C78  AC510004   SW S1, 4(V0)
9D002DB0  AC62000C   SW V0, 12(V1)
9D00308C  AC830004   SW V1, 4(A0)
9D00331C  AC460004   SW A2, 4(V0)
9D0035F8  AE030004   SW V1, 4(S0)
9D00379C  AE110004   SW S1, 4(S0)
251:                     New->Prev=(struct RMP_List*)Prev;
9D0008E8  ACE6FFF8   SW A2, -8(A3)
9D000CAC  AC850000   SW A1, 0(A0)
9D000EA4  AC850000   SW A1, 0(A0)
9D001070  AE050000   SW A1, 0(S0)
9D0012CC  AC480000   SW T0, 0(V0)
9D0015FC  AC870000   SW A3, 0(A0)
9D001A60  AC870000   SW A3, 0(A0)
9D001BB4  AC430000   SW V1, 0(V0)
9D001CCC  AC880000   SW T0, 0(A0)
9D001D50  AC640008   SW A0, 8(V1)
9D001F94  AC880000   SW T0, 0(A0)
9D0021BC  AC460000   SW A2, 0(V0)
9D00239C  AC640008   SW A0, 8(V1)
9D002530  ACA30008   SW V1, 8(A1)
9D0026E4  AC870000   SW A3, 0(A0)
9D002A94  AC470000   SW A3, 0(V0)
9D002C7C  AC430000   SW V1, 0(V0)
9D002DB4  AC640008   SW A0, 8(V1)
9D003090  AC860000   SW A2, 0(A0)
9D003320  AC480000   SW T0, 0(V0)
9D0035FC  AE050000   SW A1, 0(S0)
9D0037A0  AE621494   SW V0, 5268(S3)
252:                     Prev->Next=(struct RMP_List*)New;
9D0008EC  ACC20004   SW V0, 4(A2)
9D000CB0  ACA40004   SW A0, 4(A1)
9D000CB4  03E00008   JR RA
9D000CB8  00000000   NOP
9D000EA8  ACA40004   SW A0, 4(A1)
9D001074  ACB00004   SW S0, 4(A1)
9D0012D0  AD020004   SW V0, 4(T0)
9D001600  ACE40004   SW A0, 4(A3)
9D001A64  ACE40004   SW A0, 4(A3)
9D001BB8  AC620004   SW V0, 4(V1)
9D001CD0  AD040004   SW A0, 4(T0)
9D001D54  AC870004   SW A3, 4(A0)
9D001F98  AD040004   SW A0, 4(T0)
9D0021C0  ACC20004   SW V0, 4(A2)
9D0023A0  AC860004   SW A2, 4(A0)
9D002534  AC660004   SW A2, 4(V1)
9D0026E8  ACE40004   SW A0, 4(A3)
9D002A98  ACE20004   SW V0, 4(A3)
9D002C80  AC620004   SW V0, 4(V1)
9D002DB8  AC860004   SW A2, 4(A0)
9D003094  ACC40004   SW A0, 4(A2)
9D003324  AD020004   SW V0, 4(T0)
9D003600  ACB00004   SW S0, 4(A1)
9D0037A4  AC500004   SW S0, 4(V0)
253:                 }
254:                 /* End Function:RMP_List_Ins *************************************************/
255:                 
256:                 /* Begin Function:RMP_Sched_Lock **********************************************
257:                 Description : The function locks the scheduler. The locking can be stacked.
258:                 Input       : None.
259:                 Output      : None.
260:                 Return      : None.
261:                 ******************************************************************************/
262:                 void RMP_Sched_Lock(void)
263:                 {
264:                     RMP_Sched_Locked=1;
9D000CBC  24020001   ADDIU V0, ZERO, 1
9D000CC0  AF82806C   SW V0, -32660(GP)
9D000D44  24020001   ADDIU V0, ZERO, 1
9D001000  AF91806C   SW S1, -32660(GP)
9D001214  24020001   ADDIU V0, ZERO, 1
9D001218  AF82806C   SW V0, -32660(GP)
9D0014E8  AF82806C   SW V0, -32660(GP)
9D001730  24020001   ADDIU V0, ZERO, 1
9D001734  AF82806C   SW V0, -32660(GP)
9D001960  24030001   ADDIU V1, ZERO, 1
9D001964  AF83806C   SW V1, -32660(GP)
9D001B24  24030001   ADDIU V1, ZERO, 1
9D001B28  AF83806C   SW V1, -32660(GP)
9D00202C  24020001   ADDIU V0, ZERO, 1
9D002030  AF82806C   SW V0, -32660(GP)
9D002294  24020001   ADDIU V0, ZERO, 1
9D00229C  AF82806C   SW V0, -32660(GP)
9D00234C  0B4008A6   J 0x9D002298
9D002350  24020001   ADDIU V0, ZERO, 1
9D002494  24070001   ADDIU A3, ZERO, 1
9D00261C  24020001   ADDIU V0, ZERO, 1
9D002620  AF82806C   SW V0, -32660(GP)
9D002804  24020001   ADDIU V0, ZERO, 1
9D002808  AF82806C   SW V0, -32660(GP)
9D0029C8  24020001   ADDIU V0, ZERO, 1
9D0029CC  AF82806C   SW V0, -32660(GP)
9D002C04  24020001   ADDIU V0, ZERO, 1
9D002C08  AF82806C   SW V0, -32660(GP)
9D002F8C  24050001   ADDIU A1, ZERO, 1
9D002F90  AF85806C   SW A1, -32660(GP)
9D003238  AF82806C   SW V0, -32660(GP)
265:                     RMP_Sched_Lock_Cnt++;
9D000CC4  8F828070   LW V0, -32656(GP)
9D000CC8  24420001   ADDIU V0, V0, 1
9D000CCC  AF828070   SW V0, -32656(GP)
9D000CD0  03E00008   JR RA
9D000CD4  00000000   NOP
9D000D4C  8F828070   LW V0, -32656(GP)
9D001004  8F888070   LW T0, -32656(GP)
9D00100C  25080001   ADDIU T0, T0, 1
9D001010  AF888070   SW T0, -32656(GP)
9D00121C  8F828070   LW V0, -32656(GP)
9D001224  24420001   ADDIU V0, V0, 1
9D00122C  AF828070   SW V0, -32656(GP)
9D0014EC  8F838070   LW V1, -32656(GP)
9D0014F4  24630001   ADDIU V1, V1, 1
9D0014F8  AF838070   SW V1, -32656(GP)
9D001738  8F868070   LW A2, -32656(GP)
9D001740  24C60001   ADDIU A2, A2, 1
9D001748  AF868070   SW A2, -32656(GP)
9D001968  8F868070   LW A2, -32656(GP)
9D001970  24C60001   ADDIU A2, A2, 1
9D001978  AF868070   SW A2, -32656(GP)
9D001B2C  8F888070   LW T0, -32656(GP)
9D001B34  25080001   ADDIU T0, T0, 1
9D001B3C  AF888070   SW T0, -32656(GP)
9D002034  8F838070   LW V1, -32656(GP)
9D00203C  24630001   ADDIU V1, V1, 1
9D002040  AF838070   SW V1, -32656(GP)
9D0022A0  8F848070   LW A0, -32656(GP)
9D0022A8  24840001   ADDIU A0, A0, 1
9D0022AC  AF848070   SW A0, -32656(GP)
9D00249C  8F828070   LW V0, -32656(GP)
9D002624  8F858070   LW A1, -32656(GP)
9D00262C  24A50001   ADDIU A1, A1, 1
9D002634  AF858070   SW A1, -32656(GP)
9D00280C  8F868070   LW A2, -32656(GP)
9D002814  24C60001   ADDIU A2, A2, 1
9D002818  AF868070   SW A2, -32656(GP)
9D0029D0  8F858070   LW A1, -32656(GP)
9D0029D8  24A50001   ADDIU A1, A1, 1
9D0029DC  AF858070   SW A1, -32656(GP)
9D002C0C  8F868070   LW A2, -32656(GP)
9D002C14  24C60001   ADDIU A2, A2, 1
9D002C18  AF868070   SW A2, -32656(GP)
9D002F94  8F868070   LW A2, -32656(GP)
9D002F9C  24C60001   ADDIU A2, A2, 1
9D002FA4  AF868070   SW A2, -32656(GP)
9D00323C  8F838070   LW V1, -32656(GP)
9D003244  24630001   ADDIU V1, V1, 1
9D003248  AF838070   SW V1, -32656(GP)
266:                 }
267:                 /* End Function:RMP_Sched_Lock ***********************************************/
268:                 
269:                 /* Begin Function:RMP_Sched_Unlock ********************************************
270:                 Description : The function unlocks the scheduler. The unlocking can be stacked.
271:                 Input       : None.
272:                 Output      : None.
273:                 Return      : None.
274:                 ******************************************************************************/
275:                 void RMP_Sched_Unlock(void)
276:                 {
277:                     if(RMP_Sched_Lock_Cnt==1)
9D000CD8  8F838070   LW V1, -32656(GP)
9D000CDC  24020001   ADDIU V0, ZERO, 1
9D000CE0  1062000A   BEQ V1, V0, 0x9D000D0C
9D000CE4  00000000   NOP
9D0010A0  8F838070   LW V1, -32656(GP)
9D0010A4  24020001   ADDIU V0, ZERO, 1
9D0010A8  1062000F   BEQ V1, V0, 0x9D0010E8
9D0010AC  00000000   NOP
9D001128  8F828070   LW V0, -32656(GP)
9D00112C  10510018   BEQ V0, S1, 0x9D001190
9D001130  00000000   NOP
9D0013D8  8F838070   LW V1, -32656(GP)
9D0013DC  24020001   ADDIU V0, ZERO, 1
9D0013E0  10620013   BEQ V1, V0, 0x9D001430
9D0013E4  AE200018   SW ZERO, 24(S1)
9D001528  8F838070   LW V1, -32656(GP)
9D00152C  24020001   ADDIU V0, ZERO, 1
9D001530  10620043   BEQ V1, V0, 0x9D001640
9D001534  00000000   NOP
9D001674  8F838070   LW V1, -32656(GP)
9D001678  1062001C   BEQ V1, V0, 0x9D0016EC
9D00167C  00000000   NOP
9D001764  8F838070   LW V1, -32656(GP)
9D001768  24020001   ADDIU V0, ZERO, 1
9D00176C  1062001C   BEQ V1, V0, 0x9D0017E0
9D001770  00000000   NOP
9D0017D0  8F838070   LW V1, -32656(GP)
9D0017D4  24020001   ADDIU V0, ZERO, 1
9D0017D8  1462FFE6   BNE V1, V0, 0x9D001774
9D0017DC  00000000   NOP
9D00181C  8F838070   LW V1, -32656(GP)
9D001820  1062001C   BEQ V1, V0, 0x9D001894
9D001824  00000000   NOP
9D0018BC  8F838070   LW V1, -32656(GP)
9D0018C0  10620016   BEQ V1, V0, 0x9D00191C
9D0018C4  00000000   NOP
9D00199C  8F838070   LW V1, -32656(GP)
9D0019A0  24020001   ADDIU V0, ZERO, 1
9D0019A4  1062000D   BEQ V1, V0, 0x9D0019DC
9D0019A8  00000000   NOP
9D001A98  8F828070   LW V0, -32656(GP)
9D001A9C  1043000E   BEQ V0, V1, 0x9D001AD8
9D001AA0  00000000   NOP
9D001BE4  8F838070   LW V1, -32656(GP)
9D001BE8  24020001   ADDIU V0, ZERO, 1
9D001BEC  14620019   BNE V1, V0, 0x9D001C54
9D001BF0  00000000   NOP
9D001C44  8F838070   LW V1, -32656(GP)
9D001C48  24020001   ADDIU V0, ZERO, 1
9D001C4C  1062FFE9   BEQ V1, V0, 0x9D001BF4
9D001C50  00000000   NOP
9D001D98  8F828070   LW V0, -32656(GP)
9D001D9C  10430010   BEQ V0, V1, 0x9D001DE0
9D001DA0  00000000   NOP
9D001E4C  8F828070   LW V0, -32656(GP)
9D001E50  10430017   BEQ V0, V1, .LBE461
9D001E54  00000000   NOP
9D001E84  8F828070   LW V0, -32656(GP)
9D001E88  10430009   BEQ V0, V1, .LBE461
9D001E8C  00000000   NOP
9D0020BC  8F838070   LW V1, -32656(GP)
9D002114  8F848070   LW A0, -32656(GP)
9D002128  10820071   BEQ A0, V0, 0x9D0022F0
9D00212C  AC650018   SW A1, 24(V1)
9D002268  8F838070   LW V1, -32656(GP)
9D00226C  24020001   ADDIU V0, ZERO, 1
9D002270  1062002E   BEQ V1, V0, 0x9D00232C
9D002274  00000000   NOP
9D0022C0  8F848070   LW A0, -32656(GP)
9D0022D0  1082FFA4   BEQ A0, V0, 0x9D002164
9D0022D4  AC650018   SW A1, 24(V1)
9D0023FC  8F838070   LW V1, -32656(GP)
9D002400  10620012   BEQ V1, V0, 0x9D00244C
9D002404  00000000   NOP
9D00253C  8F838070   LW V1, -32656(GP)
9D002544  24020001   ADDIU V0, ZERO, 1
9D002548  10620021   BEQ V1, V0, 0x9D0025D0
9D00254C  00000000   NOP
9D002668  8F838070   LW V1, -32656(GP)
9D002674  24020001   ADDIU V0, ZERO, 1
9D002678  1062002D   BEQ V1, V0, 0x9D002730
9D00267C  00000000   NOP
9D002718  8F838070   LW V1, -32656(GP)
9D002724  24020001   ADDIU V0, ZERO, 1
9D002728  1462FFD5   BNE V1, V0, 0x9D002680
9D00272C  00000000   NOP
9D00276C  8F838070   LW V1, -32656(GP)
9D002770  10620016   BEQ V1, V0, 0x9D0027CC
9D002774  00000000   NOP
9D002834  8F838070   LW V1, -32656(GP)
9D00283C  1062000E   BEQ V1, V0, 0x9D002878
9D002840  AC820008   SW V0, 8(A0)
9D0028CC  8F838070   LW V1, -32656(GP)
9D0028D0  10620020   BEQ V1, V0, 0x9D002954
9D0028D4  00000000   NOP
9D00290C  8F838070   LW V1, -32656(GP)
9D002910  1062001C   BEQ V1, V0, 0x9D002984
9D002914  00000000   NOP
9D002AD8  8F838070   LW V1, -32656(GP)
9D002ADC  24020001   ADDIU V0, ZERO, 1
9D002AE0  1062000E   BEQ V1, V0, 0x9D002B1C
9D002AE4  AC800008   SW ZERO, 8(A0)
9D002B58  8F838070   LW V1, -32656(GP)
9D002B5C  10620016   BEQ V1, V0, 0x9D002BB8
9D002B60  00000000   NOP
9D002CA8  8F838070   LW V1, -32656(GP)
9D002CB0  24020001   ADDIU V0, ZERO, 1
9D002CB4  10620023   BEQ V1, V0, 0x9D002D44
9D002CB8  00000000   NOP
9D002CF8  8F828070   LW V0, -32656(GP)
9D002D00  10430044   BEQ V0, V1, 0x9D002E14
9D002D04  AC90000C   SW S0, 12(A0)
9D002E6C  8F838070   LW V1, -32656(GP)
9D002E70  10620022   BEQ V1, V0, 0x9D002EFC
9D002E74  00000000   NOP
9D002EB0  8F828070   LW V0, -32656(GP)
9D002EB4  10430023   BEQ V0, V1, 0x9D002F44
9D002EB8  00000000   NOP
9D002FEC  8F838070   LW V1, -32656(GP)
9D002FF8  24020001   ADDIU V0, ZERO, 1
9D002FFC  10620038   BEQ V1, V0, 0x9D0030E0
9D003000  00000000   NOP
9D0030C8  8F838070   LW V1, -32656(GP)
9D0030D4  24020001   ADDIU V0, ZERO, 1
9D0030D8  1462FFCA   BNE V1, V0, 0x9D003004
9D0030DC  00000000   NOP
9D003134  8F828070   LW V0, -32656(GP)
9D003138  10450020   BEQ V0, A1, 0x9D0031BC
9D00313C  00000000   NOP
9D003174  8F828070   LW V0, -32656(GP)
9D003178  1045001C   BEQ V0, A1, 0x9D0031EC
9D00317C  00000000   NOP
9D003368  8F838070   LW V1, -32656(GP)
9D00336C  24020001   ADDIU V0, ZERO, 1
9D003370  10620012   BEQ V1, V0, 0x9D0033BC
9D003374  00000000   NOP
9D0033AC  8F838070   LW V1, -32656(GP)
9D0033B0  24020001   ADDIU V0, ZERO, 1
9D0033B4  1462FFF0   BNE V1, V0, 0x9D003378
9D0033B8  00000000   NOP
9D003410  8F828070   LW V0, -32656(GP)
9D003414  10460020   BEQ V0, A2, 0x9D003498
9D003418  00000000   NOP
9D003450  8F838070   LW V1, -32656(GP)
9D003454  1062001C   BEQ V1, V0, 0x9D0034C8
9D003458  00000000   NOP
278:                     {
279:                         /* Clear the count before enabling */
280:                         RMP_Sched_Lock_Cnt=0;
9D000D0C  AF808070   SW ZERO, -32656(GP)
9D0010E8  AF808070   SW ZERO, -32656(GP)
9D001190  AF808070   SW ZERO, -32656(GP)
9D001430  AF808070   SW ZERO, -32656(GP)
9D001640  AF808070   SW ZERO, -32656(GP)
9D0016EC  AF808070   SW ZERO, -32656(GP)
9D0017E0  AF808070   SW ZERO, -32656(GP)
9D001894  AF808070   SW ZERO, -32656(GP)
9D00191C  AF808070   SW ZERO, -32656(GP)
9D0019DC  AF808070   SW ZERO, -32656(GP)
9D001AD8  AF808070   SW ZERO, -32656(GP)
9D001BF4  AF808070   SW ZERO, -32656(GP)
9D001DE0  AF808070   SW ZERO, -32656(GP)
9D001EB0  AF808070   SW ZERO, -32656(GP)
9D002164  AF808070   SW ZERO, -32656(GP)
9D0022F0  AF808070   SW ZERO, -32656(GP)
9D00232C  AF808070   SW ZERO, -32656(GP)
9D00244C  AF808070   SW ZERO, -32656(GP)
9D0025D0  AF808070   SW ZERO, -32656(GP)
9D002730  AF808070   SW ZERO, -32656(GP)
9D0027CC  AF808070   SW ZERO, -32656(GP)
9D002878  AF808070   SW ZERO, -32656(GP)
9D002954  AF808070   SW ZERO, -32656(GP)
9D002984  AF808070   SW ZERO, -32656(GP)
9D002B1C  AF808070   SW ZERO, -32656(GP)
9D002BB8  AF808070   SW ZERO, -32656(GP)
9D002D44  AF808070   SW ZERO, -32656(GP)
9D002E14  AF808070   SW ZERO, -32656(GP)
9D002EFC  AF808070   SW ZERO, -32656(GP)
9D002F44  AF808070   SW ZERO, -32656(GP)
9D0030E0  AF808070   SW ZERO, -32656(GP)
9D0031BC  AF808070   SW ZERO, -32656(GP)
9D0031EC  AF808070   SW ZERO, -32656(GP)
9D0033BC  AF808070   SW ZERO, -32656(GP)
9D003498  AF808070   SW ZERO, -32656(GP)
9D0034C8  AF808070   SW ZERO, -32656(GP)
281:                         RMP_Sched_Locked=0;
9D000D10  AF80806C   SW ZERO, -32660(GP)
9D0010EC  AF80806C   SW ZERO, -32660(GP)
9D001194  AF80806C   SW ZERO, -32660(GP)
9D001434  AF80806C   SW ZERO, -32660(GP)
9D001644  AF80806C   SW ZERO, -32660(GP)
9D0016F0  AF80806C   SW ZERO, -32660(GP)
9D0017E4  AF80806C   SW ZERO, -32660(GP)
9D001898  AF80806C   SW ZERO, -32660(GP)
9D001920  AF80806C   SW ZERO, -32660(GP)
9D0019E0  AF80806C   SW ZERO, -32660(GP)
9D001ADC  AF80806C   SW ZERO, -32660(GP)
9D001BF8  AF80806C   SW ZERO, -32660(GP)
9D001DE4  AF80806C   SW ZERO, -32660(GP)
9D001EB4  AF80806C   SW ZERO, -32660(GP)
9D002168  AF80806C   SW ZERO, -32660(GP)
9D0022F4  AF80806C   SW ZERO, -32660(GP)
9D002330  AF80806C   SW ZERO, -32660(GP)
9D002450  AF80806C   SW ZERO, -32660(GP)
9D0025D4  AF80806C   SW ZERO, -32660(GP)
9D002734  AF80806C   SW ZERO, -32660(GP)
9D0027D0  AF80806C   SW ZERO, -32660(GP)
9D00287C  AF80806C   SW ZERO, -32660(GP)
9D002958  AF80806C   SW ZERO, -32660(GP)
9D002988  AF80806C   SW ZERO, -32660(GP)
9D002B20  AF80806C   SW ZERO, -32660(GP)
9D002BBC  AF80806C   SW ZERO, -32660(GP)
9D002D48  AF80806C   SW ZERO, -32660(GP)
9D002E18  AF80806C   SW ZERO, -32660(GP)
9D002F00  AF80806C   SW ZERO, -32660(GP)
9D002F48  AF80806C   SW ZERO, -32660(GP)
9D0030E4  AF80806C   SW ZERO, -32660(GP)
9D0031C0  AF80806C   SW ZERO, -32660(GP)
9D0031F0  AF80806C   SW ZERO, -32660(GP)
9D0033C0  AF80806C   SW ZERO, -32660(GP)
9D00349C  AF80806C   SW ZERO, -32660(GP)
9D0034CC  AF80806C   SW ZERO, -32660(GP)
282:                         /* Now see if the scheduler scheduling action is pended in the lock-unlock 
283:                          * period. If yes, perform a schedule now */
284:                         if(RMP_Sched_Pend!=0)
9D000D14  8F828068   LW V0, -32664(GP)
9D000D18  14400005   BNE V0, ZERO, 0x9D000D30
9D000D1C  00000000   NOP
9D000D20  03E00008   JR RA
9D000D24  00000000   NOP
9D000D28  0B40034A   J 0x9D000D28
9D000D2C  00000000   NOP
9D0010F0  8F828068   LW V0, -32664(GP)
9D0010F4  1040FFF6   BEQ V0, ZERO, 0x9D0010D0
9D0010F8  00008021   ADDU S0, ZERO, ZERO
9D001198  8F828068   LW V0, -32664(GP)
9D00119C  1440000E   BNE V0, ZERO, 0x9D0011D8
9D0011A0  00000000   NOP
9D001438  8F828068   LW V0, -32664(GP)
9D00143C  1040FFF1   BEQ V0, ZERO, 0x9D001404
9D001440  00000000   NOP
9D001648  8F828068   LW V0, -32664(GP)
9D00164C  1040FFC2   BEQ V0, ZERO, 0x9D001558
9D001650  00008021   ADDU S0, ZERO, ZERO
9D0016F4  8F828068   LW V0, -32664(GP)
9D0016F8  5040FFEF   BEQL V0, ZERO, 0x9D0016B8
9D0016FC  2410FFFF   ADDIU S0, ZERO, -1
9D0017E8  8F828068   LW V0, -32664(GP)
9D0017EC  1040FFE9   BEQ V0, ZERO, 0x9D001794
9D0017F0  00008021   ADDU S0, ZERO, ZERO
9D00189C  8F828068   LW V0, -32664(GP)
9D0018A0  1440FFD4   BNE V0, ZERO, 0x9D0017F4
9D0018A4  2410FFFC   ADDIU S0, ZERO, -4
9D001924  8F828068   LW V0, -32664(GP)
9D001928  5040FFF5   BEQL V0, ZERO, 0x9D001900
9D00192C  2410FFFF   ADDIU S0, ZERO, -1
9D0019E4  8F828068   LW V0, -32664(GP)
9D0019E8  1040FFF8   BEQ V0, ZERO, 0x9D0019CC
9D0019EC  02001021   ADDU V0, S0, ZERO
9D001AE0  8F828068   LW V0, -32664(GP)
9D001AE4  5040FFCD   BEQL V0, ZERO, 0x9D001A1C
9D001AE8  2410FFFF   ADDIU S0, ZERO, -1
9D001BFC  8F828068   LW V0, -32664(GP)
9D001C00  10400004   BEQ V0, ZERO, .LVL241
9D001C04  00000000   NOP
9D001DE8  8F828068   LW V0, -32664(GP)
9D001DEC  10400005   BEQ V0, ZERO, 0x9D001E04
9D001DF0  2402FFFF   ADDIU V0, ZERO, -1
9D001EB8  8F828068   LW V0, -32664(GP)
9D001EBC  10400005   BEQ V0, ZERO, 0x9D001ED4
9D001EC0  2402FFFB   ADDIU V0, ZERO, -5
9D00216C  8F828068   LW V0, -32664(GP)
9D002170  1040FFDD   BEQ V0, ZERO, 0x9D0020E8
9D002174  00000000   NOP
9D0022F8  8F828068   LW V0, -32664(GP)
9D0022FC  1040FF7C   BEQ V0, ZERO, 0x9D0020F0
9D002300  00008021   ADDU S0, ZERO, ZERO
9D002334  8F828068   LW V0, -32664(GP)
9D002338  5040FFD7   BEQL V0, ZERO, 0x9D002298
9D00233C  24020001   ADDIU V0, ZERO, 1
9D002454  8F828068   LW V0, -32664(GP)
9D002458  1440FFAA   BNE V0, ZERO, .LBB571
9D00245C  2410FFFB   ADDIU S0, ZERO, -5
9D0025D8  8F828068   LW V0, -32664(GP)
9D0025DC  1040FFE3   BEQ V0, ZERO, 0x9D00256C
9D0025E0  00000000   NOP
9D002738  8F828068   LW V0, -32664(GP)
9D00273C  1040FFD8   BEQ V0, ZERO, 0x9D0026A0
9D002740  00008021   ADDU S0, ZERO, ZERO
9D0027D4  8F828068   LW V0, -32664(GP)
9D0027D8  1440FFDA   BNE V0, ZERO, 0x9D002744
9D0027DC  2410FFFC   ADDIU S0, ZERO, -4
9D002880  8F828068   LW V0, -32664(GP)
9D002884  1040FFF7   BEQ V0, ZERO, 0x9D002864
9D002888  00008021   ADDU S0, ZERO, ZERO
9D00295C  8F828068   LW V0, -32664(GP)
9D002960  1440FFCA   BNE V0, ZERO, 0x9D00288C
9D002964  2410FFFB   ADDIU S0, ZERO, -5
9D00298C  8F828068   LW V0, -32664(GP)
9D002990  5040FFC9   BEQL V0, ZERO, 0x9D0028B8
9D002994  2410FFFA   ADDIU S0, ZERO, -6
9D002B24  8F828068   LW V0, -32664(GP)
9D002B28  1040FFF7   BEQ V0, ZERO, 0x9D002B08
9D002B2C  00008021   ADDU S0, ZERO, ZERO
9D002BC0  8F828068   LW V0, -32664(GP)
9D002BC4  5040FFF5   BEQL V0, ZERO, 0x9D002B9C
9D002BC8  2410FFFA   ADDIU S0, ZERO, -6
9D002D4C  8F828068   LW V0, -32664(GP)
9D002D50  1040FFE1   BEQ V0, ZERO, 0x9D002CD8
9D002D54  00000000   NOP
9D002E1C  8F828068   LW V0, -32664(GP)
9D002E20  1040FFB0   BEQ V0, ZERO, 0x9D002CE4
9D002E24  02001021   ADDU V0, S0, ZERO
9D002F04  8F828068   LW V0, -32664(GP)
9D002F08  5040FFD2   BEQL V0, ZERO, 0x9D002E54
9D002F0C  2410FFFA   ADDIU S0, ZERO, -6
9D002F4C  8F828068   LW V0, -32664(GP)
9D002F50  1040FF63   BEQ V0, ZERO, 0x9D002CE0
9D002F54  2410FFFB   ADDIU S0, ZERO, -5
9D0030E8  8F828068   LW V0, -32664(GP)
9D0030EC  1040FFCD   BEQ V0, ZERO, 0x9D003024
9D0030F0  00008021   ADDU S0, ZERO, ZERO
9D0031C4  8F828068   LW V0, -32664(GP)
9D0031C8  1440FFCA   BNE V0, ZERO, 0x9D0030F4
9D0031CC  2410FFFC   ADDIU S0, ZERO, -4
9D0031F4  8F828068   LW V0, -32664(GP)
9D0031F8  5040FFC9   BEQL V0, ZERO, 0x9D003120
9D0031FC  2410FFFF   ADDIU S0, ZERO, -1
9D0033C4  8F828068   LW V0, -32664(GP)
9D0033C8  1040FFF3   BEQ V0, ZERO, 0x9D003398
9D0033CC  00008021   ADDU S0, ZERO, ZERO
9D0034A0  8F828068   LW V0, -32664(GP)
9D0034A4  1440FFCA   BNE V0, ZERO, 0x9D0033D0
9D0034A8  2410FFFB   ADDIU S0, ZERO, -5
9D0034D0  8F828068   LW V0, -32664(GP)
9D0034D4  5040FFC9   BEQL V0, ZERO, 0x9D0033FC
9D0034D8  2410FFFA   ADDIU S0, ZERO, -6
285:                         {
286:                             /* Reset the count and trigger the context switch */
287:                             RMP_Sched_Pend=0;
9D000D30  AF808068   SW ZERO, -32664(GP)
9D0010FC  AF808068   SW ZERO, -32664(GP)
9D0011D8  AF808068   SW ZERO, -32664(GP)
9D001444  AF808068   SW ZERO, -32664(GP)
9D001654  AF808068   SW ZERO, -32664(GP)
9D001700  AF808068   SW ZERO, -32664(GP)
9D0017F4  AF808068   SW ZERO, -32664(GP)
9D001930  AF808068   SW ZERO, -32664(GP)
9D0019F0  AF808068   SW ZERO, -32664(GP)
9D001AEC  AF808068   SW ZERO, -32664(GP)
9D001C08  AF808068   SW ZERO, -32664(GP)
9D001DF4  AF808068   SW ZERO, -32664(GP)
9D001EC4  AF808068   SW ZERO, -32664(GP)
9D002178  AF808068   SW ZERO, -32664(GP)
9D002304  AF808068   SW ZERO, -32664(GP)
9D002340  AF808068   SW ZERO, -32664(GP)
9D0025E4  AF808068   SW ZERO, -32664(GP)
9D002744  AF808068   SW ZERO, -32664(GP)
9D00288C  AF808068   SW ZERO, -32664(GP)
9D002998  AF808068   SW ZERO, -32664(GP)
9D002B30  AF808068   SW ZERO, -32664(GP)
9D002BCC  AF808068   SW ZERO, -32664(GP)
9D002D58  AF808068   SW ZERO, -32664(GP)
9D002E28  AF808068   SW ZERO, -32664(GP)
9D002F10  AF808068   SW ZERO, -32664(GP)
9D002F58  AF808068   SW ZERO, -32664(GP)
9D0030F4  AF808068   SW ZERO, -32664(GP)
9D003200  AF808068   SW ZERO, -32664(GP)
9D0033D0  AF808068   SW ZERO, -32664(GP)
9D0034DC  AF808068   SW ZERO, -32664(GP)
288:                             _RMP_Yield();
9D000D34  0B4012F8   J _RMP_Yield
9D000D38  00000000   NOP
9D001100  0F4012F8   JAL _RMP_Yield
9D001104  00000000   NOP
9D0011DC  0F4012F8   JAL _RMP_Yield
9D0011E0  2410FFFF   ADDIU S0, ZERO, -1
9D001448  0F4012F8   JAL _RMP_Yield
9D00144C  00000000   NOP
9D001658  0F4012F8   JAL _RMP_Yield
9D00165C  00000000   NOP
9D001704  0F4012F8   JAL _RMP_Yield
9D001708  2410FFFF   ADDIU S0, ZERO, -1
9D0017F8  0F4012F8   JAL _RMP_Yield
9D0017FC  00000000   NOP
9D001934  0F4012F8   JAL _RMP_Yield
9D001938  2410FFFF   ADDIU S0, ZERO, -1
9D0019F4  0F4012F8   JAL _RMP_Yield
9D0019F8  00000000   NOP
9D001AF0  0F4012F8   JAL _RMP_Yield
9D001AF4  2410FFFF   ADDIU S0, ZERO, -1
9D001C0C  0F4012F8   JAL _RMP_Yield
9D001C10  00000000   NOP
9D001DF8  0F4012F8   JAL _RMP_Yield
9D001DFC  00000000   NOP
9D001EC8  0F4012F8   JAL _RMP_Yield
9D001ECC  00000000   NOP
9D00217C  0F4012F8   JAL _RMP_Yield
9D002180  00000000   NOP
9D002184  0B40083A   J 0x9D0020E8
9D002188  00000000   NOP
9D002308  0F4012F8   JAL _RMP_Yield
9D00230C  00000000   NOP
9D002344  0F4012F8   JAL _RMP_Yield
9D002348  00000000   NOP
9D0025E8  0F4012F8   JAL _RMP_Yield
9D0025EC  00000000   NOP
9D002748  0F4012F8   JAL _RMP_Yield
9D00274C  00000000   NOP
9D002890  0F4012F8   JAL _RMP_Yield
9D002894  00000000   NOP
9D00299C  0F4012F8   JAL _RMP_Yield
9D0029A0  2410FFFA   ADDIU S0, ZERO, -6
9D002B34  0F4012F8   JAL _RMP_Yield
9D002B38  00000000   NOP
9D002BD0  0F4012F8   JAL _RMP_Yield
9D002BD4  2410FFFA   ADDIU S0, ZERO, -6
9D002D5C  0F4012F8   JAL _RMP_Yield
9D002D60  00000000   NOP
9D002D64  0B400B36   J 0x9D002CD8
9D002D68  00000000   NOP
9D002E2C  0F4012F8   JAL _RMP_Yield
9D002E30  00000000   NOP
9D002E34  8E30000C   LW S0, 12(S1)
9D002F14  0F4012F8   JAL _RMP_Yield
9D002F18  2410FFFA   ADDIU S0, ZERO, -6
9D002F5C  0F4012F8   JAL _RMP_Yield
9D002F60  00000000   NOP
9D0030F8  0F4012F8   JAL _RMP_Yield
9D0030FC  00000000   NOP
9D003204  0F4012F8   JAL _RMP_Yield
9D003208  2410FFFF   ADDIU S0, ZERO, -1
9D0033D4  0F4012F8   JAL _RMP_Yield
9D0033D8  00000000   NOP
9D0034E0  0F4012F8   JAL _RMP_Yield
9D0034E4  2410FFFA   ADDIU S0, ZERO, -6
289:                         }
290:                     }
291:                     else if(RMP_Sched_Lock_Cnt>1)
9D000CE8  8F828070   LW V0, -32656(GP)
9D000CEC  2C420002   SLTIU V0, V0, 2
9D000CF0  1440000D   BNE V0, ZERO, 0x9D000D28
9D000CF4  00000000   NOP
9D0010B0  8F828070   LW V0, -32656(GP)
9D0010B4  2C420002   SLTIU V0, V0, 2
9D0010B8  14400019   BNE V0, ZERO, 0x9D001120
9D0010BC  00000000   NOP
9D001134  8F828070   LW V0, -32656(GP)
9D001138  2C420002   SLTIU V0, V0, 2
9D00113C  14400012   BNE V0, ZERO, 0x9D001188
9D001140  00000000   NOP
9D0013E8  8F828070   LW V0, -32656(GP)
9D0013EC  2C420002   SLTIU V0, V0, 2
9D0013F0  1440000D   BNE V0, ZERO, 0x9D001428
9D0013F4  00000000   NOP
9D001538  8F828070   LW V0, -32656(GP)
9D00153C  2C420002   SLTIU V0, V0, 2
9D001540  1440003D   BNE V0, ZERO, 0x9D001638
9D001544  00000000   NOP
9D001680  8F828070   LW V0, -32656(GP)
9D001684  2C420002   SLTIU V0, V0, 2
9D001688  14400016   BNE V0, ZERO, 0x9D0016E4
9D00168C  00000000   NOP
9D001774  8F828070   LW V0, -32656(GP)
9D001778  2C420002   SLTIU V0, V0, 2
9D00177C  14400025   BNE V0, ZERO, 0x9D001814
9D001780  00000000   NOP
9D001828  8F828070   LW V0, -32656(GP)
9D00182C  2C420002   SLTIU V0, V0, 2
9D001830  14400016   BNE V0, ZERO, 0x9D00188C
9D001834  00000000   NOP
9D0018C8  8F828070   LW V0, -32656(GP)
9D0018CC  2C420002   SLTIU V0, V0, 2
9D0018D0  14400010   BNE V0, ZERO, 0x9D001914
9D0018D4  00000000   NOP
9D0019AC  8F828070   LW V0, -32656(GP)
9D0019B0  2C420002   SLTIU V0, V0, 2
9D0019B4  14400016   BNE V0, ZERO, 0x9D001A10
9D0019B8  00000000   NOP
9D001AA4  8F828070   LW V0, -32656(GP)
9D001AA8  2C420002   SLTIU V0, V0, 2
9D001AAC  14400017   BNE V0, ZERO, 0x9D001B0C
9D001AB0  00000000   NOP
9D001C54  8F828070   LW V0, -32656(GP)
9D001C58  2C420002   SLTIU V0, V0, 2
9D001C5C  14400047   BNE V0, ZERO, 0x9D001D7C
9D001C60  00000000   NOP
9D001DA4  8F828070   LW V0, -32656(GP)
9D001DA8  2C420002   SLTIU V0, V0, 2
9D001DAC  1440000A   BNE V0, ZERO, 0x9D001DD8
9D001DB0  00000000   NOP
9D001E58  8F828070   LW V0, -32656(GP)
9D001E5C  2C420002   SLTIU V0, V0, 2
9D001E60  14400011   BNE V0, ZERO, 0x9D001EA8
9D001E64  00000000   NOP
9D001E90  8F828070   LW V0, -32656(GP)
9D001E94  2C420002   SLTIU V0, V0, 2
9D001E98  1040FFF3   BEQ V0, ZERO, 0x9D001E68
9D001E9C  00000000   NOP
9D001EA0  0B4007A8   J 0x9D001EA0
9D001EA4  00000000   NOP
9D001EA8  0B4007AA   J 0x9D001EA8
9D001EAC  00000000   NOP
9D0020CC  8F828070   LW V0, -32656(GP)
9D002130  8F828070   LW V0, -32656(GP)
9D002134  2C420002   SLTIU V0, V0, 2
9D002138  144000C0   BNE V0, ZERO, 0x9D00243C
9D00213C  00000000   NOP
9D002278  8F828070   LW V0, -32656(GP)
9D00227C  2C420002   SLTIU V0, V0, 2
9D002280  14400028   BNE V0, ZERO, 0x9D002324
9D002284  00000000   NOP
9D0022D8  8F828070   LW V0, -32656(GP)
9D0022DC  2C420002   SLTIU V0, V0, 2
9D0022E0  1040FF7E   BEQ V0, ZERO, .LBE524, .LBB526
9D0022E4  00000000   NOP
9D0022E8  0B4008BA   J 0x9D0022E8
9D0022EC  00000000   NOP
9D002408  8F828070   LW V0, -32656(GP)
9D00240C  2C420002   SLTIU V0, V0, 2
9D002410  1440000C   BNE V0, ZERO, 0x9D002444
9D002414  00000000   NOP
9D002550  8F828070   LW V0, -32656(GP)
9D002554  2C420002   SLTIU V0, V0, 2
9D002558  1440001B   BNE V0, ZERO, 0x9D0025C8
9D00255C  00000000   NOP
9D002680  8F828070   LW V0, -32656(GP)
9D002684  2C420002   SLTIU V0, V0, 2
9D002688  14400036   BNE V0, ZERO, 0x9D002764
9D00268C  00000000   NOP
9D002778  8F828070   LW V0, -32656(GP)
9D00277C  2C420002   SLTIU V0, V0, 2
9D002780  14400010   BNE V0, ZERO, 0x9D0027C4
9D002784  00000000   NOP
9D002844  8F828070   LW V0, -32656(GP)
9D002848  2C420002   SLTIU V0, V0, 2
9D00284C  14400017   BNE V0, ZERO, 0x9D0028AC
9D002850  00000000   NOP
9D0028D8  8F828070   LW V0, -32656(GP)
9D0028DC  2C420002   SLTIU V0, V0, 2
9D0028E0  1440001A   BNE V0, ZERO, 0x9D00294C
9D0028E4  00000000   NOP
9D002918  8F828070   LW V0, -32656(GP)
9D00291C  2C420002   SLTIU V0, V0, 2
9D002920  14400016   BNE V0, ZERO, 0x9D00297C
9D002924  00000000   NOP
9D002AE8  8F828070   LW V0, -32656(GP)
9D002AEC  2C420002   SLTIU V0, V0, 2
9D002AF0  14400017   BNE V0, ZERO, 0x9D002B50
9D002AF4  00000000   NOP
9D002B64  8F828070   LW V0, -32656(GP)
9D002B68  2C420002   SLTIU V0, V0, 2
9D002B6C  14400010   BNE V0, ZERO, 0x9D002BB0
9D002B70  00000000   NOP
9D002CBC  8F828070   LW V0, -32656(GP)
9D002CC0  2C420002   SLTIU V0, V0, 2
9D002CC4  1440001D   BNE V0, ZERO, 0x9D002D3C
9D002CC8  00000000   NOP
9D002D08  8F828070   LW V0, -32656(GP)
9D002D0C  2C420002   SLTIU V0, V0, 2
9D002D10  14400088   BNE V0, ZERO, 0x9D002F34
9D002D14  00000000   NOP
9D002E78  8F828070   LW V0, -32656(GP)
9D002E7C  2C420002   SLTIU V0, V0, 2
9D002E80  1440001C   BNE V0, ZERO, 0x9D002EF4
9D002E84  00000000   NOP
9D002EBC  8F828070   LW V0, -32656(GP)
9D002EC0  2C420002   SLTIU V0, V0, 2
9D002EC4  1440001D   BNE V0, ZERO, 0x9D002F3C
9D002EC8  00000000   NOP
9D003004  8F828070   LW V0, -32656(GP)
9D003008  2C420002   SLTIU V0, V0, 2
9D00300C  14400041   BNE V0, ZERO, 0x9D003114
9D003010  00000000   NOP
9D003140  8F828070   LW V0, -32656(GP)
9D003144  2C420002   SLTIU V0, V0, 2
9D003148  1440001A   BNE V0, ZERO, 0x9D0031B4
9D00314C  00000000   NOP
9D003180  8F828070   LW V0, -32656(GP)
9D003184  2C420002   SLTIU V0, V0, 2
9D003188  14400016   BNE V0, ZERO, 0x9D0031E4
9D00318C  00000000   NOP
9D003378  8F828070   LW V0, -32656(GP)
9D00337C  2C420002   SLTIU V0, V0, 2
9D003380  1440001B   BNE V0, ZERO, 0x9D0033F0
9D003384  00000000   NOP
9D00341C  8F828070   LW V0, -32656(GP)
9D003420  2C420002   SLTIU V0, V0, 2
9D003424  1440001A   BNE V0, ZERO, 0x9D003490
9D003428  00000000   NOP
9D00345C  8F828070   LW V0, -32656(GP)
9D003460  2C420002   SLTIU V0, V0, 2
9D003464  14400016   BNE V0, ZERO, 0x9D0034C0
9D003468  00000000   NOP
292:                         RMP_Sched_Lock_Cnt--;
9D000CF8  8F828070   LW V0, -32656(GP)
9D000CFC  2442FFFF   ADDIU V0, V0, -1
9D000D00  AF828070   SW V0, -32656(GP)
9D000D04  03E00008   JR RA
9D000D08  00000000   NOP
9D0010C0  8F828070   LW V0, -32656(GP)
9D0010C8  2442FFFF   ADDIU V0, V0, -1
9D0010CC  AF828070   SW V0, -32656(GP)
9D001144  8F828070   LW V0, -32656(GP)
9D00114C  2442FFFF   ADDIU V0, V0, -1
9D001150  AF828070   SW V0, -32656(GP)
9D0013F8  8F828070   LW V0, -32656(GP)
9D0013FC  2442FFFF   ADDIU V0, V0, -1
9D001400  AF828070   SW V0, -32656(GP)
9D001548  8F828070   LW V0, -32656(GP)
9D001550  2442FFFF   ADDIU V0, V0, -1
9D001554  AF828070   SW V0, -32656(GP)
9D001690  8F828070   LW V0, -32656(GP)
9D001698  2442FFFF   ADDIU V0, V0, -1
9D00169C  AF828070   SW V0, -32656(GP)
9D001784  8F828070   LW V0, -32656(GP)
9D00178C  2442FFFF   ADDIU V0, V0, -1
9D001790  AF828070   SW V0, -32656(GP)
9D001838  8F828070   LW V0, -32656(GP)
9D001840  2442FFFF   ADDIU V0, V0, -1
9D001844  AF828070   SW V0, -32656(GP)
9D0018D8  8F828070   LW V0, -32656(GP)
9D0018E0  2442FFFF   ADDIU V0, V0, -1
9D0018E4  AF828070   SW V0, -32656(GP)
9D0019BC  8F828070   LW V0, -32656(GP)
9D0019C0  2442FFFF   ADDIU V0, V0, -1
9D0019C4  AF828070   SW V0, -32656(GP)
9D001AB4  8F828070   LW V0, -32656(GP)
9D001ABC  2442FFFF   ADDIU V0, V0, -1
9D001AC0  AF828070   SW V0, -32656(GP)
9D001C64  8F828070   LW V0, -32656(GP)
9D001C68  2442FFFF   ADDIU V0, V0, -1
9D001C6C  AF828070   SW V0, -32656(GP)
9D001C70  0B400705   J .LVL241
9D001C74  00000000   NOP
9D001DB4  8F838070   LW V1, -32656(GP)
9D001DBC  2463FFFF   ADDIU V1, V1, -1
9D001DC0  AF838070   SW V1, -32656(GP)
9D001E68  8F838070   LW V1, -32656(GP)
9D001E70  2463FFFF   ADDIU V1, V1, -1
9D001E74  AF838070   SW V1, -32656(GP)
9D0020DC  8F828070   LW V0, -32656(GP)
9D0020E0  2442FFFF   ADDIU V0, V0, -1
9D0020E4  AF828070   SW V0, -32656(GP)
9D002140  8F828070   LW V0, -32656(GP)
9D002148  2442FFFF   ADDIU V0, V0, -1
9D00214C  AF828070   SW V0, -32656(GP)
9D002288  8F828070   LW V0, -32656(GP)
9D00228C  2442FFFF   ADDIU V0, V0, -1
9D002290  AF828070   SW V0, -32656(GP)
9D002418  8F828070   LW V0, -32656(GP)
9D002420  2442FFFF   ADDIU V0, V0, -1
9D002424  AF828070   SW V0, -32656(GP)
9D002560  8F828070   LW V0, -32656(GP)
9D002564  2442FFFF   ADDIU V0, V0, -1
9D002568  AF828070   SW V0, -32656(GP)
9D002690  8F828070   LW V0, -32656(GP)
9D002698  2442FFFF   ADDIU V0, V0, -1
9D00269C  AF828070   SW V0, -32656(GP)
9D002788  8F828070   LW V0, -32656(GP)
9D002790  2442FFFF   ADDIU V0, V0, -1
9D002794  AF828070   SW V0, -32656(GP)
9D002854  8F828070   LW V0, -32656(GP)
9D00285C  2442FFFF   ADDIU V0, V0, -1
9D002860  AF828070   SW V0, -32656(GP)
9D0028E8  8F828070   LW V0, -32656(GP)
9D0028F0  2442FFFF   ADDIU V0, V0, -1
9D0028F4  AF828070   SW V0, -32656(GP)
9D002928  8F828070   LW V0, -32656(GP)
9D002930  2442FFFF   ADDIU V0, V0, -1
9D002934  AF828070   SW V0, -32656(GP)
9D002AF8  8F828070   LW V0, -32656(GP)
9D002B00  2442FFFF   ADDIU V0, V0, -1
9D002B04  AF828070   SW V0, -32656(GP)
9D002B74  8F828070   LW V0, -32656(GP)
9D002B7C  2442FFFF   ADDIU V0, V0, -1
9D002B80  AF828070   SW V0, -32656(GP)
9D002CCC  8F828070   LW V0, -32656(GP)
9D002CD0  2442FFFF   ADDIU V0, V0, -1
9D002CD4  AF828070   SW V0, -32656(GP)
9D002D18  8F828070   LW V0, -32656(GP)
9D002D1C  2442FFFF   ADDIU V0, V0, -1
9D002D20  AF828070   SW V0, -32656(GP)
9D002E88  8F828070   LW V0, -32656(GP)
9D002E90  2442FFFF   ADDIU V0, V0, -1
9D002E94  AF828070   SW V0, -32656(GP)
9D002ECC  8F828070   LW V0, -32656(GP)
9D002ED4  2442FFFF   ADDIU V0, V0, -1
9D002ED8  AF828070   SW V0, -32656(GP)
9D003014  8F828070   LW V0, -32656(GP)
9D00301C  2442FFFF   ADDIU V0, V0, -1
9D003020  AF828070   SW V0, -32656(GP)
9D003150  8F828070   LW V0, -32656(GP)
9D003158  2442FFFF   ADDIU V0, V0, -1
9D00315C  AF828070   SW V0, -32656(GP)
9D003190  8F828070   LW V0, -32656(GP)
9D003198  2442FFFF   ADDIU V0, V0, -1
9D00319C  AF828070   SW V0, -32656(GP)
9D003388  8F828070   LW V0, -32656(GP)
9D003390  2442FFFF   ADDIU V0, V0, -1
9D003394  AF828070   SW V0, -32656(GP)
9D00342C  8F828070   LW V0, -32656(GP)
9D003434  2442FFFF   ADDIU V0, V0, -1
9D003438  AF828070   SW V0, -32656(GP)
9D00346C  8F828070   LW V0, -32656(GP)
9D003474  2442FFFF   ADDIU V0, V0, -1
9D003478  AF828070   SW V0, -32656(GP)
293:                     /* Trying to unlock a scheduler that is not locked */
294:                     else
295:                         while(1);
296:                 }
297:                 /* End Function:RMP_Sched_Unlock *********************************************/
298:                 
299:                 /* Begin Function:RMP_Yield ***************************************************
300:                 Description : Yield to another thread.
301:                 Input       : None.
302:                 Output      : None.
303:                 Return      : None.
304:                 ******************************************************************************/
305:                 void RMP_Yield(void)
306:                 {
307:                     if(RMP_Sched_Locked==0)
9D000D88  8F82806C   LW V0, -32660(GP)
9D000D8C  10400004   BEQ V0, ZERO, 0x9D000DA0
9D000D90  24020001   ADDIU V0, ZERO, 1
308:                     {
309:                         /* Now see if the scheduler scheduling action is pended in the lock-unlock 
310:                          * period. If yes, perform a schedule now */
311:                         _RMP_Yield();
9D000DA0  0B4012F8   J _RMP_Yield
9D000DA4  00000000   NOP
312:                     }
313:                     else
314:                         RMP_Sched_Pend=1;
9D000D94  AF828068   SW V0, -32664(GP)
9D000D98  03E00008   JR RA
9D000D9C  00000000   NOP
315:                 }
316:                 /* End Function:RMP_Yield ****************************************************/
317:                 
318:                 /* Begin Function:_RMP_Timer_Proc *********************************************
319:                 Description : Process RMP timer events.
320:                 Input       : None.
321:                 Output      : None.
322:                 Return      : None.
323:                 ******************************************************************************/
324:                 void _RMP_Timer_Proc(void)
325:                 {
9D000810  27888078   ADDIU T0, GP, -32648
326:                     struct RMP_Thd* Thread;
327:                     
328:                     /* Process the timer events, if there are any of them */
329:                     while((&RMP_Delay)!=RMP_Delay.Next)
9D000834  0B400219   J 0x9D000864
9D000838  24180001   ADDIU T8, ZERO, 1
9D000864  8F82807C   LW V0, -32644(GP)
9D000868  10480032   BEQ V0, T0, 0x9D000934
9D00086C  00000000   NOP
330:                     {
331:                         Thread=RMP_DLY2THD(RMP_Delay.Next);
9D000870  8F87807C   LW A3, -32644(GP)
9D000878  24E2FFF8   ADDIU V0, A3, -8
332:                         /* If the value is more than this, then it means that the time have
333:                          * already passed and we have to process this */
334:                         if((RMP_Tick-Thread->Timeout)>(RMP_ALLBITS>>1))
9D000874  8F848074   LW A0, -32652(GP)
9D00087C  8C430028   LW V1, 40(V0)
9D000880  00831823   SUBU V1, A0, V1
9D000884  0460002B   BLTZ V1, 0x9D000934
9D000888  00000000   NOP
335:                             break;
336:                         
337:                         /* This thread should be processed */
338:                         RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
9D000890  8C450008   LW A1, 8(V0)
9D000894  8C46000C   LW A2, 12(V0)
339:                         switch(RMP_THD_STATE(Thread->State))
9D000814  24090005   ADDIU T1, ZERO, 5
9D00081C  240A0008   ADDIU T2, ZERO, 8
9D000820  240C0003   ADDIU T4, ZERO, 3
9D00083C  508A0038   BEQL A0, T2, 0x9D000920
9D000840  8CE4FFF8   LW A0, -8(A3)
9D000844  508C0036   BEQL A0, T4, 0x9D000920
9D000848  8CE4FFF8   LW A0, -8(A3)
9D00088C  8C430018   LW V1, 24(V0)
9D000898  306400FF   ANDI A0, V1, 255
9D0008A4  1489FFE5   BNE A0, T1, 0x9D00083C
9D0008A8  2405FF00   ADDIU A1, ZERO, -256
340:                         {
341:                             case RMP_THD_SNDDLY:
342:                             case RMP_THD_SEMDLY:
343:                             {
344:                                 RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
9D000920  8C450004   LW A1, 4(V0)
345:                                 Thread->Retval=RMP_ERR_OPER;
346:                                 break;
9D00092C  0B400213   J 0x9D00084C
9D000930  AC4B0038   SW T3, 56(V0)
9D000934  03E00008   JR RA
9D000938  00000000   NOP
347:                             }
348:                             
349:                             case RMP_THD_RCVDLY:
350:                             {
351:                                 Thread->Retval=RMP_ERR_OPER;
9D000818  240BFFFB   ADDIU T3, ZERO, -5
9D0008AC  AC4B0038   SW T3, 56(V0)
352:                                 break;
353:                             }
354:                             
355:                             case RMP_THD_DELAYED:break;
356:                             /* Should not get here */
357:                             default:break;
358:                         }
359:                 
360:                         RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
9D00084C  2405FF00   ADDIU A1, ZERO, -256
9D000850  00652024   AND A0, V1, A1
9D000854  34840001   ORI A0, A0, 1
9D0008B0  00652024   AND A0, V1, A1
9D0008B4  34840001   ORI A0, A0, 1
361:                         /* Is it suspended? If yes, we can't directly set it running */
362:                         if((Thread->State&RMP_THD_SUSPENDED)==0)
9D000858  30630100   ANDI V1, V1, 256
9D00085C  10600019   BEQ V1, ZERO, 0x9D0008C4
9D000860  AC440018   SW A0, 24(V0)
9D0008B8  30630100   ANDI V1, V1, 256
9D0008BC  1460FFE9   BNE V1, ZERO, 0x9D000864
9D0008C0  AC440018   SW A0, 24(V0)
363:                         {
364:                             /* Insert this into the corresponding runqueue */
365:                             RMP_List_Ins(&(Thread->Run_Head),RMP_Run[Thread->Prio].Prev,&(RMP_Run[Thread->Prio]));
9D000824  3C028000   LUI V0, -32768
9D000828  244F1CD0   ADDIU T7, V0, 7376
9D0008C4  8C430024   LW V1, 36(V0)
9D0008C8  000320C0   SLL A0, V1, 3
9D0008CC  008F2021   ADDU A0, A0, T7
9D0008D0  8C860000   LW A2, 0(A0)
366:                             /* Set this runlevel as active */
367:                             RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]|=1<<(Thread->Prio&RMP_WORD_MASK);
9D00082C  278E8080   ADDIU T6, GP, -32640
9D000830  240D0001   ADDIU T5, ZERO, 1
9D0008D4  00032942   SRL A1, V1, 5
9D0008D8  00052880   SLL A1, A1, 2
9D0008E0  01C52821   ADDU A1, T6, A1
9D0008F0  8CA40000   LW A0, 0(A1)
9D0008F4  3062000F   ANDI V0, V1, 15
9D0008F8  004D1004   SLLV V0, T5, V0
9D0008FC  00441025   OR V0, V0, A0
9D000900  ACA20000   SW V0, 0(A1)
368:                             /* See if we need to pend a scheduling event */
369:                             if(Thread->Prio>RMP_Thd_Cur->Prio)
9D000904  8F828084   LW V0, -32636(GP)
9D000908  8C420024   LW V0, 36(V0)
9D00090C  0043182B   SLTU V1, V0, V1
9D000910  5460FFD4   BNEL V1, ZERO, 0x9D000864
9D000914  AF988068   SW T8, -32664(GP)
9D000918  0B400219   J 0x9D000864
9D00091C  00000000   NOP
370:                                 RMP_Sched_Pend=1;
371:                         }
372:                     }
373:                 }
374:                 /* Begin Function:_RMP_Timer_Proc ********************************************/
375:                 
376:                 /* Begin Function:_RMP_Run_High *******************************************
377:                 Description : Get the highest priority ready thread. The return value will be written
378:                               into the global variables.
379:                 Input       : None.
380:                 Output      : None.
381:                 Return      : None.
382:                 ******************************************************************************/
383:                 void _RMP_Run_High(void)
384:                 {
9D000DA8  27BDFFE8   ADDIU SP, SP, -24
9D000DAC  AFBF0014   SW RA, 20(SP)
385:                     cnt_t Count;
386:                     
387:                     /* Write the SP value to thread structure */
388:                     RMP_Thd_Cur->Stack=RMP_SP_Cur;
9D000DB0  8F838084   LW V1, -32636(GP)
9D000DB4  8F848088   LW A0, -32632(GP)
389:                     
390:                     /* Is the scheduler locked on other threads? If yes, we return without doing anything */
391:                     if(RMP_Sched_Locked!=0)
9D000DB8  8F82806C   LW V0, -32660(GP)
9D000DBC  1440000C   BNE V0, ZERO, 0x9D000DF0
9D000DC0  AC640034   SW A0, 52(V1)
392:                         return;
393:                     
394:                     if(RMP_Timer_Pend==1)
9D000DC4  8F838064   LW V1, -32668(GP)
9D000DC8  24020001   ADDIU V0, ZERO, 1
9D000DCC  1062001E   BEQ V1, V0, 0x9D000E48
9D000DD0  00000000   NOP
395:                     {
396:                         RMP_Timer_Pend=0;
9D000E48  AF808064   SW ZERO, -32668(GP)
397:                         _RMP_Timer_Proc();
9D000E4C  0F400204   JAL .LFE5, .LFB14, _RMP_Timer_Proc, .Ltext0
9D000E50  00000000   NOP
9D000E54  0B400375   J 0x9D000DD4
9D000E58  00000000   NOP
398:                     }
399:                     
400:                     RMP_Sched_Pend=0;
9D000DD4  AF808068   SW ZERO, -32664(GP)
401:                     /* See which one is ready, and pick it */
402:                     for(Count=RMP_BITMAP_SIZE-1;Count>=0;Count--)
403:                     {
404:                         if(RMP_Bitmap[Count]==0)
9D000DD8  8F828080   LW V0, -32640(GP)
9D000DDC  14400007   BNE V0, ZERO, 0x9D000DFC
9D000DE0  00000000   NOP
405:                             continue;
406:                         
407:                         Count=RMP_MSB_Get(RMP_Bitmap[Count])+(Count<<RMP_WORD_ORDER);
9D000DFC  8F848080   LW A0, -32640(GP)
9D000E00  0F4012F3   JAL RMP_MSB_Get
9D000E04  00000000   NOP
408:                         
409:                         /* See if the current thread and the next thread are the same. If yes, place the current at the end of the queue */
410:                         if(RMP_Thd_Cur==(struct RMP_Thd*)(RMP_Run[Count].Next))
9D000E08  3C038000   LUI V1, -32768
9D000E0C  24631CD0   ADDIU V1, V1, 7376
9D000E10  000210C0   SLL V0, V0, 3
9D000E14  00622021   ADDU A0, V1, V0
9D000E18  8C850004   LW A1, 4(A0)
9D000E1C  8F848084   LW A0, -32636(GP)
9D000E20  10A4000E   BEQ A1, A0, 0x9D000E5C
9D000E24  00000000   NOP
411:                         {
412:                             RMP_List_Del(RMP_Thd_Cur->Run_Head.Prev, RMP_Thd_Cur->Run_Head.Next);
9D000E5C  8F848084   LW A0, -32636(GP)
9D000E60  8F858084   LW A1, -32636(GP)
9D000E64  8C840000   LW A0, 0(A0)
9D000E68  8CA50004   LW A1, 4(A1)
413:                             RMP_List_Ins(&(RMP_Thd_Cur->Run_Head),
9D000E74  8F848084   LW A0, -32636(GP)
9D000E80  000528C0   SLL A1, A1, 3
9D000E84  00A32821   ADDU A1, A1, V1
9D000E88  8CA50000   LW A1, 0(A1)
9D000E90  8CC60024   LW A2, 36(A2)
9D000E94  000630C0   SLL A2, A2, 3
9D000E98  00663021   ADDU A2, V1, A2
414:                                          RMP_Run[RMP_Thd_Cur->Prio].Prev,
9D000E78  8F858084   LW A1, -32636(GP)
9D000E7C  8CA50024   LW A1, 36(A1)
415:                                          &(RMP_Run[RMP_Thd_Cur->Prio]));
9D000E8C  8F868084   LW A2, -32636(GP)
416:                         }
417:                         
418:                         /* Replenish timeslices */
419:                         RMP_Thd_Cur->Slice_Left=RMP_Thd_Cur->Slice;
9D000E28  8F848084   LW A0, -32636(GP)
9D000E2C  8F858084   LW A1, -32636(GP)
9D000E38  8CA2001C   LW V0, 28(A1)
420:                         RMP_Thd_Cur=(struct RMP_Thd*)(RMP_Run[Count].Next);
9D000E30  00621821   ADDU V1, V1, V0
9D000E34  8C630004   LW V1, 4(V1)
9D000E3C  AF838084   SW V1, -32636(GP)
421:                         break;
9D000E40  0B400379   J 0x9D000DE4
9D000E44  AC820020   SW V0, 32(A0)
422:                     }
423:                     
424:                     /* Load the SP value from thread structure */
425:                     RMP_SP_Cur=RMP_Thd_Cur->Stack;
9D000DE4  8F828084   LW V0, -32636(GP)
9D000DE8  8C420034   LW V0, 52(V0)
9D000DEC  AF828088   SW V0, -32632(GP)
426:                 }
9D000DF0  8FBF0014   LW RA, 20(SP)
9D000DF4  03E00008   JR RA
9D000DF8  27BD0018   ADDIU SP, SP, 24
427:                 /* End Function:_RMP_Run_High ********************************************/
428:                 
429:                 /* Begin Function:_RMP_Tick_Handler *******************************************
430:                 Description : The system tick timer interrupt routine.
431:                 Input       : ptr_t Ticks - How many ticks have passed.
432:                 Output      : None.
433:                 Return      : None.
434:                 ******************************************************************************/
435:                 void _RMP_Tick_Handler(ptr_t Ticks)
436:                 {
9D000EB4  27BDFFE8   ADDIU SP, SP, -24
9D000EB8  AFBF0014   SW RA, 20(SP)
437:                     struct RMP_Thd* Thread;
438:                     /* Increase the timestamp as always */
439:                     RMP_Tick+=Ticks;
9D000EBC  8F828074   LW V0, -32652(GP)
9D000EC0  00821021   ADDU V0, A0, V0
9D000EC4  AF828074   SW V0, -32652(GP)
440:                 #if(RMP_HOOK_EXTRA==1U)
441:                     RMP_Tick_Hook(Ticks);
442:                 #endif
443:                     /* See if the current thread expired. If yes, trigger a scheduler event */
444:                     if(Ticks>=RMP_Thd_Cur->Slice_Left)
9D000EC8  8F828084   LW V0, -32636(GP)
9D000ECC  8C420020   LW V0, 32(V0)
9D000ED0  0082102B   SLTU V0, A0, V0
9D000ED4  14400018   BNE V0, ZERO, 0x9D000F38
9D000ED8  24020001   ADDIU V0, ZERO, 1
445:                         RMP_Sched_Pend=1;
9D000EDC  AF828068   SW V0, -32664(GP)
446:                     else
447:                         RMP_Thd_Cur->Slice_Left-=Ticks;
9D000F38  8F828084   LW V0, -32636(GP)
9D000F3C  8C430020   LW V1, 32(V0)
9D000F40  00642023   SUBU A0, V1, A0
9D000F44  0B4003B8   J 0x9D000EE0
9D000F48  AC440020   SW A0, 32(V0)
448:                     
449:                     /* Is the scheduler locked? If yes, we cannot process timer events here and will have to pend them */
450:                     if((&RMP_Delay)!=RMP_Delay.Next)
9D000EE0  8F83807C   LW V1, -32644(GP)
9D000EE4  27828078   ADDIU V0, GP, -32648
9D000EE8  1062000B   BEQ V1, V0, 0x9D000F18
9D000EEC  00000000   NOP
451:                     {
452:                         Thread=RMP_DLY2THD(RMP_Delay.Next);
9D000EF0  8F82807C   LW V0, -32644(GP)
453:                         /* If the value is less than this, then it means that the time have
454:                          * already passed and we have to process this */
455:                         if((RMP_Tick-Thread->Timeout)<=(RMP_ALLBITS>>1))
9D000EF4  8F838074   LW V1, -32652(GP)
9D000EF8  8C420020   LW V0, 32(V0)
9D000EFC  00621023   SUBU V0, V1, V0
9D000F00  04400005   BLTZ V0, 0x9D000F18
9D000F04  00000000   NOP
456:                         {
457:                             /* If scheduler locked, we pend the processing until it is unlocked */
458:                             if(RMP_Sched_Locked!=0)
9D000F08  8F82806C   LW V0, -32660(GP)
9D000F0C  10400013   BEQ V0, ZERO, .LVL109
9D000F10  24020001   ADDIU V0, ZERO, 1
459:                                 RMP_Timer_Pend=1;
9D000F14  AF828064   SW V0, -32668(GP)
460:                             else
461:                                 _RMP_Timer_Proc();
9D000F5C  0F400204   JAL .LFE5, .LFB14, _RMP_Timer_Proc, .Ltext0
9D000F60  00000000   NOP
9D000F64  0B4003C6   J 0x9D000F18
9D000F68  00000000   NOP
462:                         }
463:                     }
464:                     
465:                     if((RMP_Sched_Locked==0)&&(RMP_Sched_Pend!=0))
9D000F18  8F82806C   LW V0, -32660(GP)
9D000F1C  14400004   BNE V0, ZERO, 0x9D000F30
9D000F20  8FBF0014   LW RA, 20(SP)
9D000F24  8F828068   LW V0, -32664(GP)
9D000F28  14400008   BNE V0, ZERO, 0x9D000F4C
9D000F2C  00000000   NOP
466:                     {
467:                         RMP_Sched_Pend=0;
9D000F4C  AF808068   SW ZERO, -32664(GP)
468:                         _RMP_Yield();
9D000F54  0B4012F8   J _RMP_Yield
9D000F58  27BD0018   ADDIU SP, SP, 24
469:                     }
470:                 }
9D000F30  03E00008   JR RA
9D000F34  27BD0018   ADDIU SP, SP, 24
9D000F50  8FBF0014   LW RA, 20(SP)
471:                 /* End Function:_RMP_Tick_Handler ********************************************/
472:                 
473:                 /* Begin Function:_RMP_Tick_Near *****************************************
474:                 Description : Get the nearest timer interrupt arrival time.
475:                 Input       : None.
476:                 Output      : None.
477:                 Return      : ptr_t Ticks - How many ticks until the next timeout.
478:                 ******************************************************************************/
479:                 ptr_t _RMP_Tick_Near(void)
480:                 {
481:                     ptr_t Value;
482:                     struct RMP_Thd* Thread;
483:                     
484:                     /* What is the current thread's timeout value? */
485:                     Value=RMP_Thd_Cur->Slice_Left;
9D000F6C  8F828084   LW V0, -32636(GP)
486:                     
487:                     /* What is the nearest timer timeout value? */
488:                     if((&RMP_Delay)!=RMP_Delay.Next)
9D000F70  8F84807C   LW A0, -32644(GP)
9D000F74  27838078   ADDIU V1, GP, -32648
9D000F78  1083000A   BEQ A0, V1, 0x9D000FA4
9D000F7C  8C420020   LW V0, 32(V0)
489:                     {
490:                         Thread=RMP_DLY2THD(RMP_Delay.Next);
9D000F80  8F83807C   LW V1, -32644(GP)
491:                         /* See if it is nearer - don't worry about the situation that the timer
492:                          * have overflown, because if that is to happen, it would have been 
493:                          * already processed by the timeout processing routine just called above. */
494:                         if((Thread->Timeout-RMP_Tick)<Value)
9D000F84  8F848074   LW A0, -32652(GP)
9D000F88  8C630020   LW V1, 32(V1)
9D000F8C  00642023   SUBU A0, V1, A0
9D000F90  0082202B   SLTU A0, A0, V0
9D000F94  50800004   BEQL A0, ZERO, 0x9D000FA8
9D000F98  24030001   ADDIU V1, ZERO, 1
495:                             Value=Thread->Timeout-RMP_Tick;
9D000F9C  8F828074   LW V0, -32652(GP)
9D000FA0  00621023   SUBU V0, V1, V0
496:                     }
497:                     
498:                     /* The timer setting is at least 1 tick */
499:                     if(Value==0)
500:                         Value=1;
9D000FA4  24030001   ADDIU V1, ZERO, 1
501:                     
502:                     return Value;
503:                 }
9D000FA8  03E00008   JR RA
9D000FAC  0062100A   MOVZ V0, V1, V0
504:                 /* End Function:_RMP_Tick_Near ******************************************/
505:                 
506:                 /* Begin Function:_RMP_Run_Ins ************************************************
507:                 Description : Set the thread as ready to schedule. That means, put the thread into
508:                               the runqueue. When this is called, please make sure that the scheduler
509:                               is locked.
510:                 Input       : struct RMP_Thd* Thread - The thread to put into the runqueue.
511:                 Output      : None.
512:                 Return      : None.
513:                 ******************************************************************************/
514:                 void _RMP_Run_Ins(struct RMP_Thd* Thread)
515:                 {
516:                     /* Insert this into the corresponding runqueue */
517:                     RMP_List_Ins(&(Thread->Run_Head),RMP_Run[Thread->Prio].Prev,&(RMP_Run[Thread->Prio]));
9D001030  8E020024   LW V0, 36(S0)
9D001038  000228C0   SLL A1, V0, 3
9D001040  3C038000   LUI V1, -32768
9D001044  24631CD0   ADDIU V1, V1, 7376
9D001048  00A31821   ADDU V1, A1, V1
9D001050  8C650000   LW A1, 0(V1)
9D001248  3C0D8000   LUI T5, -32768
9D00124C  25AD1CD0   ADDIU T5, T5, 7376
9D0012A8  8C430024   LW V1, 36(V0)
9D0012AC  000328C0   SLL A1, V1, 3
9D0012B0  00AD2821   ADDU A1, A1, T5
9D0012B4  8CA80000   LW T0, 0(A1)
9D0015D0  000518C0   SLL V1, A1, 3
9D0015D4  3C028000   LUI V0, -32768
9D0015D8  24421CD0   ADDIU V0, V0, 7376
9D0015DC  00621021   ADDU V0, V1, V0
9D0015E0  8C470000   LW A3, 0(V0)
9D001A30  8C830024   LW V1, 36(A0)
9D001C9C  8C820024   LW V0, 36(A0)
9D001F64  8C820024   LW V0, 36(A0)
9D00218C  8C430024   LW V1, 36(V0)
9D0026B4  8C830024   LW V1, 36(A0)
9D0029F8  3C0D8000   LUI T5, -32768
9D0029FC  25AD1CD0   ADDIU T5, T5, 7376
9D002A70  8C430024   LW V1, 36(V0)
9D002A74  000328C0   SLL A1, V1, 3
9D002A78  00AD2821   ADDU A1, A1, T5
9D002A7C  8CA70000   LW A3, 0(A1)
9D003060  8C820024   LW V0, 36(A0)
9D003280  3C0D8000   LUI T5, -32768
9D003284  25AD1CD0   ADDIU T5, T5, 7376
9D0032FC  8C450024   LW A1, 36(V0)
9D003300  000530C0   SLL A2, A1, 3
9D003304  00CD3021   ADDU A2, A2, T5
9D003308  8CC80000   LW T0, 0(A2)
9D00356C  3C158000   LUI S5, -32768
9D003570  26B51CD0   ADDIU S5, S5, 7376
9D0035D8  8E020024   LW V0, 36(S0)
9D0035DC  000218C0   SLL V1, V0, 3
9D0035E0  00751821   ADDU V1, V1, S5
9D0035E4  8C650000   LW A1, 0(V1)
518:                     /* Set this runlevel as active */
519:                     RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]|=((ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK);
9D001054  00022142   SRL A0, V0, 5
9D001058  00042080   SLL A0, A0, 2
9D001060  27868080   ADDIU A2, GP, -32640
9D001064  00C42021   ADDU A0, A2, A0
9D001078  8C830000   LW V1, 0(A0)
9D00107C  3045000F   ANDI A1, V0, 15
9D001080  00B12804   SLLV A1, S1, A1
9D001084  00A31825   OR V1, A1, V1
9D001088  AC830000   SW V1, 0(A0)
9D001250  278C8080   ADDIU T4, GP, -32640
9D001254  240A0001   ADDIU T2, ZERO, 1
9D0012B8  00033142   SRL A2, V1, 5
9D0012BC  00063080   SLL A2, A2, 2
9D0012C4  01863021   ADDU A2, T4, A2
9D0012D4  8CC50000   LW A1, 0(A2)
9D0012D8  3068000F   ANDI T0, V1, 15
9D0012DC  010A4004   SLLV T0, T2, T0
9D0012E0  01052825   OR A1, T0, A1
9D0012E4  ACC50000   SW A1, 0(A2)
9D0015E4  00051942   SRL V1, A1, 5
9D0015E8  00031880   SLL V1, V1, 2
9D0015F0  01231821   ADDU V1, T1, V1
9D001604  8C670000   LW A3, 0(V1)
9D001608  30A8000F   ANDI T0, A1, 15
9D00160C  24020001   ADDIU V0, ZERO, 1
9D001610  01024004   SLLV T0, V0, T0
9D001614  01073825   OR A3, T0, A3
9D001618  AC670000   SW A3, 0(V1)
9D001A48  00033142   SRL A2, V1, 5
9D001A54  27888080   ADDIU T0, GP, -32640
9D001A68  8CC40000   LW A0, 0(A2)
9D001CB4  00023942   SRL A3, V0, 5
9D001CC0  27898080   ADDIU T1, GP, -32640
9D001CD4  8CE80000   LW T0, 0(A3)
9D001F7C  00023942   SRL A3, V0, 5
9D001F88  27898080   ADDIU T1, GP, -32640
9D001F9C  8CE90000   LW T1, 0(A3)
9D0021A4  00032942   SRL A1, V1, 5
9D0021B0  27878080   ADDIU A3, GP, -32640
9D0021C4  8CA40000   LW A0, 0(A1)
9D0026CC  00033142   SRL A2, V1, 5
9D0026D8  27888080   ADDIU T0, GP, -32640
9D0026EC  8CC50000   LW A1, 0(A2)
9D002A00  278C8080   ADDIU T4, GP, -32640
9D002A04  240B0001   ADDIU T3, ZERO, 1
9D002A80  00033142   SRL A2, V1, 5
9D002A84  00063080   SLL A2, A2, 2
9D002A8C  01863021   ADDU A2, T4, A2
9D002A9C  8CC50000   LW A1, 0(A2)
9D002AA0  3067000F   ANDI A3, V1, 15
9D002AA4  00EB3804   SLLV A3, T3, A3
9D002AA8  00E52825   OR A1, A3, A1
9D002AAC  ACC50000   SW A1, 0(A2)
9D003078  00022942   SRL A1, V0, 5
9D003084  27878080   ADDIU A3, GP, -32640
9D003098  8CA60000   LW A2, 0(A1)
9D003288  278C8080   ADDIU T4, GP, -32640
9D00328C  0B400CAD   J 0x9D0032B4
9D003290  240B0001   ADDIU T3, ZERO, 1
9D00330C  00053942   SRL A3, A1, 5
9D003310  00073880   SLL A3, A3, 2
9D003318  01873821   ADDU A3, T4, A3
9D003328  8CE60000   LW A2, 0(A3)
9D00332C  30A8000F   ANDI T0, A1, 15
9D003330  010B4004   SLLV T0, T3, T0
9D003334  01063025   OR A2, T0, A2
9D003338  ACE60000   SW A2, 0(A3)
9D003574  27948080   ADDIU S4, GP, -32640
9D003578  0B400D68   J 0x9D0035A0
9D00357C  24130001   ADDIU S3, ZERO, 1
9D0035E8  00022142   SRL A0, V0, 5
9D0035EC  00042080   SLL A0, A0, 2
9D0035F4  02842021   ADDU A0, S4, A0
9D003604  8C850000   LW A1, 0(A0)
9D003608  3043000F   ANDI V1, V0, 15
9D00360C  00731804   SLLV V1, S3, V1
9D003610  00651825   OR V1, V1, A1
9D003614  AC830000   SW V1, 0(A0)
520:                     
521:                     /* Compare this with the current one to see if we need a context switch */
522:                     if(Thread->Prio>RMP_Thd_Cur->Prio)
9D00108C  8F838084   LW V1, -32636(GP)
9D001090  8C630024   LW V1, 36(V1)
9D001094  0062102B   SLTU V0, V1, V0
9D001098  54400001   BNEL V0, ZERO, .LBB160
9D00109C  AF918068   SW S1, -32664(GP)
9D0012E8  8F858084   LW A1, -32636(GP)
9D0012EC  8CA50024   LW A1, 36(A1)
9D0012F0  00A3182B   SLTU V1, A1, V1
9D0012F4  5060FFDB   BEQL V1, ZERO, 0x9D001264
9D0012F8  AC490038   SW T1, 56(V0)
9D00161C  8F838084   LW V1, -32636(GP)
9D001620  8C630024   LW V1, 36(V1)
9D001624  0065282B   SLTU A1, V1, A1
9D001628  54A0FFBA   BNEL A1, ZERO, 0x9D001514
9D00162C  AF828068   SW V0, -32664(GP)
9D001A7C  8F848084   LW A0, -32636(GP)
9D001CEC  8F878084   LW A3, -32636(GP)
9D001FB4  8F878084   LW A3, -32636(GP)
9D0021DC  8F848084   LW A0, -32636(GP)
9D002700  8F858084   LW A1, -32636(GP)
9D002AB0  8F858084   LW A1, -32636(GP)
9D002AB4  8CA50024   LW A1, 36(A1)
9D002AB8  00A3182B   SLTU V1, A1, V1
9D002ABC  5060FFD7   BEQL V1, ZERO, 0x9D002A1C
9D002AC0  AC490038   SW T1, 56(V0)
9D0030B0  8F858084   LW A1, -32636(GP)
9D00333C  8F868084   LW A2, -32636(GP)
9D003340  8CC60024   LW A2, 36(A2)
9D003344  00C5282B   SLTU A1, A2, A1
9D003348  50A0FFD5   BEQL A1, ZERO, 0x9D0032A0
9D00334C  AC400038   SW ZERO, 56(V0)
9D003618  8F838084   LW V1, -32636(GP)
9D00361C  8C630024   LW V1, 36(V1)
9D003620  0062182B   SLTU V1, V1, V0
9D003624  54600001   BNEL V1, ZERO, 0x9D00362C
9D003628  AF938068   SW S3, -32664(GP)
523:                         RMP_Sched_Pend=1;
9D0012FC  AF8A8068   SW T2, -32664(GP)
9D002714  AF828068   SW V0, -32664(GP)
9D002AC4  AF8B8068   SW T3, -32664(GP)
9D0030C4  AF838068   SW V1, -32664(GP)
9D003350  AF8B8068   SW T3, -32664(GP)
524:                 }
525:                 /* End Function:_RMP_Run_Ins *************************************************/
526:                 
527:                 /* Begin Function:_RMP_Run_Del ************************************************
528:                 Description : Clear the thread from the runqueue. When this is called, please 
529:                               make sure that the scheduler is locked.
530:                 Input       : struct RMP_Thd* Thread - The thread to clear from the runqueue.
531:                 Output      : None.
532:                 Return      : None.
533:                 ******************************************************************************/
534:                 void _RMP_Run_Del(struct RMP_Thd* Thread)
535:                 {
536:                     /* See if it is the last thread on the priority level */
537:                     if(Thread->Run_Head.Prev==Thread->Run_Head.Next)
9D001384  8E220000   LW V0, 0(S1)
9D001580  8C820000   LW V0, 0(A0)
9D0017A8  8C820000   LW V0, 0(A0)
9D0017AC  8C830004   LW V1, 4(A0)
9D0017B0  5043002A   BEQL V0, V1, 0x9D00185C
9D0017B4  8C870024   LW A3, 36(A0)
9D001B70  8C470000   LW A3, 0(V0)
9D001B74  8C480004   LW T0, 4(V0)
9D001B78  50E800A8   BEQL A3, T0, 0x9D001E1C
9D001B7C  8C4A0024   LW T2, 36(V0)
9D002218  8C640000   LW A0, 0(V1)
9D00221C  8C660004   LW A2, 4(V1)
9D002220  5086006A   BEQL A0, A2, 0x9D0023CC
9D002224  8C680024   LW T0, 36(V1)
9D0024AC  8C430000   LW V1, 0(V0)
9D0024B0  8C450004   LW A1, 4(V0)
9D0024B4  50650032   BEQL V1, A1, 0x9D002580
9D0024B8  8C480024   LW T0, 36(V0)
9D002C3C  8C460000   LW A2, 0(V0)
9D002C40  8C470004   LW A3, 4(V0)
9D002C44  50C70067   BEQL A2, A3, 0x9D002DE4
9D002C48  8C490024   LW T1, 36(V0)
538:                         RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]&=~(((ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK));
9D001394  8E260024   LW A2, 36(S1)
9D001590  00085142   SRL T2, T0, 5
9D00185C  00073142   SRL A2, A3, 5
9D001860  00063080   SLL A2, A2, 2
9D001864  27888080   ADDIU T0, GP, -32640
9D001868  01063021   ADDU A2, T0, A2
9D00186C  8CC80000   LW T0, 0(A2)
9D001870  30E7000F   ANDI A3, A3, 15
9D001874  00E52804   SLLV A1, A1, A3
9D001878  00052827   NOR A1, ZERO, A1
9D00187C  00A82824   AND A1, A1, T0
9D001880  ACC50000   SW A1, 0(A2)
9D001884  0B4005EE   J .LBB319
9D001888  00000000   NOP
9D00188C  0B400623   J 0x9D00188C
9D001890  00000000   NOP
9D001E1C  000A4942   SRL T1, T2, 5
9D001E20  00094880   SLL T1, T1, 2
9D001E24  278B8080   ADDIU T3, GP, -32640
9D001E28  01694821   ADDU T1, T3, T1
9D001E2C  8D2B0000   LW T3, 0(T1)
9D001E30  314A000F   ANDI T2, T2, 15
9D001E34  01431804   SLLV V1, V1, T2
9D001E38  00031827   NOR V1, ZERO, V1
9D001E3C  006B1824   AND V1, V1, T3
9D001E40  AD230000   SW V1, 0(T1)
9D001E44  0B4006E0   J .LBB422
9D001E48  00000000   NOP
9D0023CC  00083942   SRL A3, T0, 5
9D0023D0  00073880   SLL A3, A3, 2
9D0023D4  27898080   ADDIU T1, GP, -32640
9D0023D8  01273821   ADDU A3, T1, A3
9D0023DC  8CE90000   LW T1, 0(A3)
9D0023E0  3108000F   ANDI T0, T0, 15
9D0023E4  01021004   SLLV V0, V0, T0
9D0023E8  00021027   NOR V0, ZERO, V0
9D0023EC  00491024   AND V0, V0, T1
9D0023F0  ACE20000   SW V0, 0(A3)
9D0023F4  0B40088A   J .LBB553
9D0023F8  00000000   NOP
9D002580  00083142   SRL A2, T0, 5
9D002584  00063080   SLL A2, A2, 2
9D002588  27898080   ADDIU T1, GP, -32640
9D00258C  01263021   ADDU A2, T1, A2
9D002590  8CC90000   LW T1, 0(A2)
9D002594  3108000F   ANDI T0, T0, 15
9D002598  01073804   SLLV A3, A3, T0
9D00259C  00073827   NOR A3, ZERO, A3
9D0025A0  00E93824   AND A3, A3, T1
9D0025A4  ACC70000   SW A3, 0(A2)
9D002DE4  00094142   SRL T0, T1, 5
9D002DE8  00084080   SLL T0, T0, 2
9D002DEC  278A8080   ADDIU T2, GP, -32640
9D002DF0  01484021   ADDU T0, T2, T0
9D002DF4  8D0A0000   LW T2, 0(T0)
9D002DF8  3129000F   ANDI T1, T1, 15
9D002DFC  01231804   SLLV V1, V1, T1
9D002E00  00031827   NOR V1, ZERO, V1
9D002E04  006A1824   AND V1, V1, T2
9D002E08  AD030000   SW V1, 0(T0)
9D002E0C  0B400B13   J .LBB810
9D002E10  00000000   NOP
539:                     
540:                     /* Insert this into the corresponding runqueue */
541:                     RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
542:                     
543:                     /* If it is the current thread, request a context switch */
544:                     if(Thread==RMP_Thd_Cur)
9D0013C8  8F828084   LW V0, -32636(GP)
9D0015BC  8F828084   LW V0, -32636(GP)
9D0017C0  8F828084   LW V0, -32636(GP)
9D0017C4  1482FFE7   BNE A0, V0, .LBB310
9D0017C8  24020001   ADDIU V0, ZERO, 1
9D001B88  8F838084   LW V1, -32636(GP)
9D001B8C  104300A0   BEQ V0, V1, 0x9D001E10
9D001B90  24020001   ADDIU V0, ZERO, 1
9D002230  8F828084   LW V0, -32636(GP)
9D002234  10620062   BEQ V1, V0, 0x9D0023C0
9D002238  24020001   ADDIU V0, ZERO, 1
9D0024C4  8F838084   LW V1, -32636(GP)
9D0024C8  1043003C   BEQ V0, V1, 0x9D0025BC
9D0024CC  24020001   ADDIU V0, ZERO, 1
9D0025B0  8F838084   LW V1, -32636(GP)
9D0025B4  1443FFC6   BNE V0, V1, 0x9D0024D0
9D0025B8  24020001   ADDIU V0, ZERO, 1
9D002C54  8F838084   LW V1, -32636(GP)
9D002C58  1043005F   BEQ V0, V1, 0x9D002DD8
9D002C5C  24020001   ADDIU V0, ZERO, 1
545:                         RMP_Sched_Pend=1;
9D0013D4  AF828068   SW V0, -32664(GP)
9D0015C8  24020001   ADDIU V0, ZERO, 1
9D0017CC  AF828068   SW V0, -32664(GP)
9D001E10  AF828068   SW V0, -32664(GP)
9D001E14  0B4006E5   J 0x9D001B94
9D001E18  00000000   NOP
9D0023C0  AF828068   SW V0, -32664(GP)
9D0025BC  AF828068   SW V0, -32664(GP)
9D0025C0  0B400934   J 0x9D0024D0
9D0025C4  00000000   NOP
9D0025C8  0B400972   J 0x9D0025C8
9D0025CC  00000000   NOP
9D002DD8  AF828068   SW V0, -32664(GP)
9D002DDC  0B400B18   J 0x9D002C60
9D002DE0  00000000   NOP
546:                 }
547:                 /* End Function:_RMP_Run_Del *************************************************/
548:                 
549:                 /* Begin Function:_RMP_Dly_Ins ************************************************
550:                 Description : Insert the thread into the delay queue, given some timeslices into the
551:                               future. The thread must not be in the run queue any more.
552:                 Input       : struct RMP_Thd* Thread - The thread to put into the delay queue.
553:                               ptr_t - The timeslices to delay.
554:                 Output      : None.
555:                 Return      : None.
556:                 ******************************************************************************/
557:                 void _RMP_Dly_Ins(struct RMP_Thd* Thread, ptr_t Slice)
558:                 {
559:                     struct RMP_List* Trav_Ptr;
560:                     struct RMP_Thd* Trav_Thd;
561:                     
562:                     Trav_Ptr=(struct RMP_List*)RMP_Delay.Next;
9D001D0C  8F82807C   LW V0, -32644(GP)
9D002358  8F82807C   LW V0, -32644(GP)
9D0024DC  8F82807C   LW V0, -32644(GP)
9D002D70  8F82807C   LW V0, -32644(GP)
563:                     while(Trav_Ptr!=&(RMP_Delay))
9D001D10  27848078   ADDIU A0, GP, -32648
9D00235C  27848078   ADDIU A0, GP, -32648
9D0024F0  27838078   ADDIU V1, GP, -32648
9D0024F4  10430007   BEQ V0, V1, 0x9D002514
9D0024F8  00000000   NOP
9D002D74  27848078   ADDIU A0, GP, -32648
564:                     {
565:                         Trav_Thd=RMP_DLY2THD(Trav_Ptr);
566:                         if((Trav_Thd->Timeout-RMP_Tick)>Slice)
9D001D1C  8C440020   LW A0, 32(V0)
9D002368  8C440020   LW A0, 32(V0)
9D0024FC  8C460020   LW A2, 32(V0)
9D002500  8F838074   LW V1, -32652(GP)
9D002504  00C31823   SUBU V1, A2, V1
9D002508  0083182B   SLTU V1, A0, V1
9D00250C  1060FFFC   BEQ V1, ZERO, 0x9D002500
9D002510  00000000   NOP
9D002D80  8C440020   LW A0, 32(V0)
567:                             break;
568:                     }
569:                 
570:                     /* Insert this into the list */
571:                     Thread->Timeout=RMP_Tick+Slice;
9D001D34  8F888074   LW T0, -32652(GP)
9D001D40  00C83021   ADDU A2, A2, T0
9D002380  8F878074   LW A3, -32652(GP)
9D00238C  00A72821   ADDU A1, A1, A3
9D002514  8F878074   LW A3, -32652(GP)
9D002520  00872021   ADDU A0, A0, A3
9D002524  ACA40028   SW A0, 40(A1)
9D002D98  8F878074   LW A3, -32652(GP)
9D002DA4  00A72821   ADDU A1, A1, A3
572:                     RMP_List_Ins(&Thread->Dly_Head,Trav_Ptr->Prev,Trav_Ptr);
9D001D38  8C440000   LW A0, 0(V0)
9D002384  8C440000   LW A0, 0(V0)
9D002518  8C430000   LW V1, 0(V0)
9D00251C  24A60008   ADDIU A2, A1, 8
9D002D9C  8C440000   LW A0, 0(V0)
573:                 }
574:                 /* End Function:_RMP_Dly_Ins *************************************************/
575:                 
576:                 /* Begin Function:RMP_Thd_Crt *************************************************
577:                 Description : Create a real-time thread.
578:                 Input       : struct RMP_Thd* Thread - The thread structure provided. The user 
579:                                                        should make this allocation according to
580:                                                        his or her needs.
581:                               void* Entry - The entry of the thread.
582:                               void* Stack - The stack of this thread.
583:                               void* Arg - The argument to pass to the thread.
584:                               ptr_t Prio - The priority of the thread.
585:                               ptr_t Slice - The number of timeslices to assign to the thread.
586:                 Output      : None.
587:                 Return      : ret_t - If successful, 0. on error, return an error code.
588:                 ******************************************************************************/
589:                 ret_t RMP_Thd_Crt(struct RMP_Thd* Thread, void* Entry, void* Stack, void* Arg, ptr_t Prio, ptr_t Slice)
590:                 {
9D000FB0  27BDFFE0   ADDIU SP, SP, -32
9D000FB4  AFBF001C   SW RA, 28(SP)
9D000FB8  AFB10018   SW S1, 24(SP)
9D000FBC  AFB00014   SW S0, 20(SP)
9D000FC0  8FA30030   LW V1, 48(SP)
591:                     /* Check if the priority and timeslice range is correct */
592:                     if(Prio>=RMP_PREEMPT_PRIO_NUM)
9D000FC4  2C680020   SLTIU T0, V1, 32
9D000FC8  11000068   BEQ T0, ZERO, 0x9D00116C
9D000FCC  8FA20034   LW V0, 52(SP)
9D000FD0  00808021   ADDU S0, A0, ZERO
9D000FD4  00A02021   ADDU A0, A1, ZERO
9D000FD8  00C02821   ADDU A1, A2, ZERO
9D000FDC  00E03021   ADDU A2, A3, ZERO
593:                         return RMP_ERR_PRIO;
9D00116C  2410FFFE   ADDIU S0, ZERO, -2
594:                     if((Slice==0)||(Slice>=RMP_SLICE_MAX))
9D000FE0  2448FFFF   ADDIU T0, V0, -1
9D000FE4  3C070001   LUI A3, 1
9D000FE8  34E7869F   ORI A3, A3, -31073
9D000FEC  0107382B   SLTU A3, T0, A3
9D000FF0  50E00073   BEQL A3, ZERO, 0x9D0011C0
9D000FF4  2410FFFD   ADDIU S0, ZERO, -3
595:                         return RMP_ERR_SLICE;
596:                     
597:                     /* Check if this thread structure could possibly be in use */
598:                     if(Thread==0)
9D000FF8  1200006A   BEQ S0, ZERO, 0x9D0011A4
9D000FFC  24110001   ADDIU S1, ZERO, 1
599:                         return RMP_ERR_THD;
9D0011A4  2410FFFF   ADDIU S0, ZERO, -1
600:                     
601:                     RMP_Sched_Lock();
602:                     
603:                     if(RMP_THD_STATE(Thread->State)!=RMP_THD_FREE)
9D001008  92070018   LBU A3, 24(S0)
9D001014  14E00044   BNE A3, ZERO, .LBB168
9D001018  00000000   NOP
604:                     {
605:                         RMP_Sched_Unlock();
606:                         return RMP_ERR_THD;
9D001148  2410FFFF   ADDIU S0, ZERO, -1
607:                     }
608:                     
609:                     /* Create the thread and insert it into the list */
610:                     Thread->Prio=Prio;
9D00101C  AE030024   SW V1, 36(S0)
611:                     Thread->Slice=Slice;
9D001020  AE02001C   SW V0, 28(S0)
612:                     Thread->Slice_Left=Slice;
9D001024  AE020020   SW V0, 32(S0)
613:                     Thread->Stack=(ptr_t)Stack;
614:                     
615:                     /* Initialize its stack and sending list */
616:                     _RMP_Stack_Init((ptr_t)Entry, (ptr_t)Stack, (ptr_t)Arg);
9D001028  0F401152   JAL _RMP_Stack_Init
9D00102C  AE050034   SW A1, 52(S0)
617:                     RMP_List_Crt(&(Thread->Snd_List));
9D001034  26040010   ADDIU A0, S0, 16
618:                     
619:                     /* Notify the scheduler that we have created something new, also check locks */
620:                     Thread->State=RMP_THD_RUNNING;
9D00105C  AE110018   SW S1, 24(S0)
621:                     _RMP_Run_Ins(Thread);
622:                     
623:                     RMP_Sched_Unlock();
624:                 
625:                     return 0;
9D0010C4  00008021   ADDU S0, ZERO, ZERO
626:                 }
9D0010D0  02001021   ADDU V0, S0, ZERO
9D0010D4  8FBF001C   LW RA, 28(SP)
9D0010D8  8FB10018   LW S1, 24(SP)
9D0010DC  8FB00014   LW S0, 20(SP)
9D0010E0  03E00008   JR RA
9D0010E4  27BD0020   ADDIU SP, SP, 32
9D001108  02001021   ADDU V0, S0, ZERO
9D00110C  8FBF001C   LW RA, 28(SP)
9D001110  8FB10018   LW S1, 24(SP)
9D001114  8FB00014   LW S0, 20(SP)
9D001118  03E00008   JR RA
9D00111C  27BD0020   ADDIU SP, SP, 32
9D001120  0B400448   J 0x9D001120
9D001124  00000000   NOP
9D001154  02001021   ADDU V0, S0, ZERO
9D001158  8FBF001C   LW RA, 28(SP)
9D00115C  8FB10018   LW S1, 24(SP)
9D001160  8FB00014   LW S0, 20(SP)
9D001164  03E00008   JR RA
9D001168  27BD0020   ADDIU SP, SP, 32
9D001170  02001021   ADDU V0, S0, ZERO
9D001174  8FBF001C   LW RA, 28(SP)
9D001178  8FB10018   LW S1, 24(SP)
9D00117C  8FB00014   LW S0, 20(SP)
9D001180  03E00008   JR RA
9D001184  27BD0020   ADDIU SP, SP, 32
9D001188  0B400462   J 0x9D001188
9D00118C  00000000   NOP
9D0011A8  02001021   ADDU V0, S0, ZERO
9D0011AC  8FBF001C   LW RA, 28(SP)
9D0011B0  8FB10018   LW S1, 24(SP)
9D0011B4  8FB00014   LW S0, 20(SP)
9D0011B8  03E00008   JR RA
9D0011BC  27BD0020   ADDIU SP, SP, 32
9D0011C0  02001021   ADDU V0, S0, ZERO
9D0011C4  8FBF001C   LW RA, 28(SP)
9D0011C8  8FB10018   LW S1, 24(SP)
9D0011CC  8FB00014   LW S0, 20(SP)
9D0011D0  03E00008   JR RA
9D0011D4  27BD0020   ADDIU SP, SP, 32
9D0011E4  02001021   ADDU V0, S0, ZERO
9D0011E8  8FBF001C   LW RA, 28(SP)
9D0011EC  8FB10018   LW S1, 24(SP)
9D0011F0  8FB00014   LW S0, 20(SP)
9D0011F4  03E00008   JR RA
9D0011F8  27BD0020   ADDIU SP, SP, 32
627:                 /* End Function:RMP_Thd_Crt **************************************************/
628:                 
629:                 /* Begin Function:RMP_Thd_Del *************************************************
630:                 Description : Delete a real-time thread.
631:                 Input       : struct RMP_Thd* Thread - The thread structure of the thread.
632:                 Output      : None.
633:                 Return      : ret_t - If successful, 0; or an error code.
634:                 ******************************************************************************/
635:                 ret_t RMP_Thd_Del(struct RMP_Thd* Thread)
636:                 {
9D0011FC  27BDFFE0   ADDIU SP, SP, -32
9D001200  AFBF001C   SW RA, 28(SP)
9D001204  AFB10018   SW S1, 24(SP)
9D001208  AFB00014   SW S0, 20(SP)
637:                     struct RMP_Thd* Release;
638:                     ptr_t Self_Del;
639:                     
640:                     /* Check if this thread structure could possibly be in use */
641:                     if(Thread==0)
9D00120C  108000AA   BEQ A0, ZERO, 0x9D0014B8
9D001210  00808821   ADDU S1, A0, ZERO
642:                         return RMP_ERR_THD;
9D0014B8  2402FFFF   ADDIU V0, ZERO, -1
643:                     
644:                     RMP_Sched_Lock();
645:                     
646:                     if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
9D001220  8C850018   LW A1, 24(A0)
9D001228  30A300FF   ANDI V1, A1, 255
9D001230  10600099   BEQ V1, ZERO, 0x9D001498
9D001234  24870010   ADDIU A3, A0, 16
647:                     {
648:                         RMP_Sched_Unlock();
9D001498  0F400336   JAL .LFB12, .LFE11, RMP_Sched_Unlock
9D00149C  00000000   NOP
649:                         return RMP_ERR_THD;
9D0014A0  2402FFFF   ADDIU V0, ZERO, -1
650:                     }
651:                     
652:                     /* See if anyone waiting to send to this thread. If there is, release all these threads */
653:                     while(&(Thread->Snd_List)!=Thread->Snd_List.Next)
9D001238  8C820014   LW V0, 20(A0)
9D00123C  50E20036   BEQL A3, V0, 0x9D001318
9D001240  00A01021   ADDU V0, A1, ZERO
9D001264  8E220014   LW V0, 20(S1)
9D001268  5047002A   BEQL V0, A3, 0x9D001314
9D00126C  8E220018   LW V0, 24(S1)
9D001304  8E220014   LW V0, 20(S1)
9D001308  5447FFDA   BNEL V0, A3, 0x9D001274
9D00130C  8C430018   LW V1, 24(V0)
9D001310  8E220018   LW V0, 24(S1)
9D001314  304300FF   ANDI V1, V0, 255
654:                     {
655:                         Release=(struct RMP_Thd*)(Thread->Snd_List.Next);
656:                         RMP_List_Del(Release->Run_Head.Prev,Release->Run_Head.Next);
9D001274  8C450000   LW A1, 0(V0)
9D001278  8C460004   LW A2, 4(V0)
657:                         if(RMP_THD_STATE(Release->State)==RMP_THD_SNDDLY)
9D001244  240B0003   ADDIU T3, ZERO, 3
9D001270  8C430018   LW V1, 24(V0)
9D00127C  306800FF   ANDI T0, V1, 255
9D001288  510B0036   BEQL T0, T3, 0x9D001364
9D00128C  8C450008   LW A1, 8(V0)
658:                             RMP_List_Del(Release->Dly_Head.Prev,Release->Dly_Head.Next);
9D001364  8C46000C   LW A2, 12(V0)
659:                 
660:                         RMP_THD_STATE_SET(Release->State,RMP_THD_RUNNING);
9D001290  2404FF00   ADDIU A0, ZERO, -256
9D001294  00642824   AND A1, V1, A0
9D001298  34A50001   ORI A1, A1, 1
9D001370  0B4004A5   J 0x9D001294
9D001374  2404FF00   ADDIU A0, ZERO, -256
661:                 
662:                         /* Is it suspended? If yes, we can't directly send it running */
663:                         if((Release->State&RMP_THD_SUSPENDED)==0)
9D00129C  30630100   ANDI V1, V1, 256
9D0012A0  1460FFEF   BNE V1, ZERO, 0x9D001260
9D0012A4  AC450018   SW A1, 24(V0)
664:                            _RMP_Run_Ins(Release);
665:                         
666:                         Release->Retval=RMP_ERR_OPER;
9D001258  0B40049C   J 0x9D001270
9D00125C  2409FFFB   ADDIU T1, ZERO, -5
9D001260  AC490038   SW T1, 56(V0)
9D001300  AC490038   SW T1, 56(V0)
667:                     }
668:                     
669:                     /* See what is it state */
670:                     Self_Del=0;
671:                     if(RMP_Thd_Cur==Thread)
9D00131C  8F908084   LW S0, -32636(GP)
672:                         Self_Del=1;
673:                     
674:                     switch(RMP_THD_STATE(Thread->State))
9D001318  2C650009   SLTIU A1, V1, 9
9D001320  10A0002D   BEQ A1, ZERO, .LBE224, .LBB228
9D001324  00031880   SLL V1, V1, 2
9D001328  3C059D00   LUI A1, -25344
9D00132C  24A51340   ADDIU A1, A1, 4928
9D001330  00A31821   ADDU V1, A1, V1
9D001334  8C630000   LW V1, 0(V1)
9D001338  00600008   JR V1
9D00133C  00000000   NOP
675:                     {
676:                         case RMP_THD_RUNNING:
677:                         {
678:                             if((Thread->State&RMP_THD_SUSPENDED)==0)
9D001378  30420100   ANDI V0, V0, 256
9D00137C  14400016   BNE V0, ZERO, .LBE224, .LBB228
9D001380  00000000   NOP
679:                                 _RMP_Run_Del(Thread);
680:                             break;
681:                         }
682:                         
683:                         case RMP_THD_SNDDLY:
684:                         case RMP_THD_SEMDLY:
685:                         {
686:                             if((Thread->State&RMP_THD_SUSPENDED)==0)
9D001460  30420100   ANDI V0, V0, 256
9D001464  54400006   BNEL V0, ZERO, 0x9D001480
9D001468  8E220008   LW V0, 8(S1)
687:                                 RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
9D00146C  8E220000   LW V0, 0(S1)
9D001470  8E230004   LW V1, 4(S1)
688:                             RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
689:                             Thread->Retval=RMP_ERR_OPER;
690:                             break;
691:                         }
692:                             
693:                         case RMP_THD_RCVDLY:
694:                         {
695:                             RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
696:                             Thread->Retval=RMP_ERR_OPER;
697:                             break;
698:                         }
699:                             
700:                         case RMP_THD_DELAYED:
701:                         {
702:                             RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
9D00147C  8E220008   LW V0, 8(S1)
9D001480  8E23000C   LW V1, 12(S1)
703:                             Thread->Retval=RMP_ERR_OPER;
9D00148C  2402FFFB   ADDIU V0, ZERO, -5
704:                             break;
9D001490  0B4004F6   J .LBE224, .LBB228
9D001494  AE220038   SW V0, 56(S1)
705:                         }
706:                         /* Should not get here */
707:                         default:break;
708:                     }
709:                     Thread->State=RMP_THD_FREE;
710:                     
711:                     RMP_Sched_Unlock();
712:                     
713:                     /* If we are deleting ourself, just stop the execution here */
714:                     if(Self_Del!=0)
9D001404  16300003   BNE S1, S0, 0x9D001414
9D001408  00001021   ADDU V0, ZERO, ZERO
9D00140C  0B400503   J 0x9D00140C
9D001410  00000000   NOP
9D001450  1230FFEE   BEQ S1, S0, 0x9D00140C
9D001454  00001021   ADDU V0, ZERO, ZERO
715:                         while(1);
716:                 
717:                     return 0;
718:                 }
9D001414  8FBF001C   LW RA, 28(SP)
9D001418  8FB10018   LW S1, 24(SP)
9D00141C  8FB00014   LW S0, 20(SP)
9D001420  03E00008   JR RA
9D001424  27BD0020   ADDIU SP, SP, 32
9D001428  0B40050A   J 0x9D001428
9D00142C  00000000   NOP
9D001458  0B400506   J 0x9D001418
9D00145C  8FBF001C   LW RA, 28(SP)
9D0014A4  8FBF001C   LW RA, 28(SP)
9D0014A8  8FB10018   LW S1, 24(SP)
9D0014AC  8FB00014   LW S0, 20(SP)
9D0014B0  03E00008   JR RA
9D0014B4  27BD0020   ADDIU SP, SP, 32
9D0014BC  8FBF001C   LW RA, 28(SP)
9D0014C0  8FB10018   LW S1, 24(SP)
9D0014C4  8FB00014   LW S0, 20(SP)
9D0014C8  03E00008   JR RA
9D0014CC  27BD0020   ADDIU SP, SP, 32
719:                 /* End Function:RMP_Thd_Del **************************************************/
720:                 
721:                 /* Begin Function:RMP_Thd_Set *************************************************
722:                 Description : Change the priority or timeslice of a real-time thread. If one of
723:                               the changes is not desired, just leave it to RMP_PREEMPT_PRIO_NUM
724:                               or RMP_SLICE_MAX.
725:                 Input       : struct RMP_Thd* Thread - The thread structure of the thread.
726:                               ptr_t Prio - The priority of the thread.
727:                               ptr_t Slice - The new timeslice value for this thread.
728:                 Output      : None.
729:                 Return      : ret_t - If successful, 0; else error code.
730:                 ******************************************************************************/
731:                 ret_t RMP_Thd_Set(struct RMP_Thd* Thread, ptr_t Prio, ptr_t Slice)
732:                 {
9D0014D0  27BDFFE8   ADDIU SP, SP, -24
9D0014D4  AFBF0014   SW RA, 20(SP)
733:                     /* Check if the priority and timeslice range is correct */
734:                     if(Slice==0)
9D0014D8  10C0007C   BEQ A2, ZERO, 0x9D0016CC
9D0014DC  AFB00010   SW S0, 16(SP)
735:                         return RMP_ERR_SLICE;
9D0016CC  2410FFFD   ADDIU S0, ZERO, -3
736:                     
737:                     /* Check if this thread structure could possibly be in use */
738:                     if(Thread==0)
9D0014E0  10800074   BEQ A0, ZERO, 0x9D0016B4
9D0014E4  24020001   ADDIU V0, ZERO, 1
739:                         return RMP_ERR_THD;
9D0016B4  2410FFFF   ADDIU S0, ZERO, -1
740:                     
741:                     RMP_Sched_Lock();
742:                     
743:                     if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
9D0014F0  90870018   LBU A3, 24(A0)
9D0014FC  10E0005D   BEQ A3, ZERO, .LBB278
9D001500  00000000   NOP
744:                     {
745:                         RMP_Sched_Unlock();
746:                         return RMP_ERR_THD;
9D001694  2410FFFF   ADDIU S0, ZERO, -1
747:                     }
748:                     
749:                     /* See if the thread is in running state */
750:                     if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
9D001504  10E20019   BEQ A3, V0, 0x9D00156C
9D001508  2CA20020   SLTIU V0, A1, 32
751:                     {
752:                         /* See if we are gonna change one of it or both */
753:                         if(Prio<RMP_PREEMPT_PRIO_NUM)
9D00156C  1040FFEA   BEQ V0, ZERO, 0x9D001518
9D001570  3C020001   LUI V0, 1
754:                         {
755:                             if(Thread->Prio!=Prio)
9D001574  8C880024   LW T0, 36(A0)
9D001578  1105FFE8   BEQ T0, A1, 0x9D00151C
9D00157C  344286A0   ORI V0, V0, -31072
756:                             {
757:                                 _RMP_Run_Del(Thread);
758:                                 Thread->Prio=Prio;
9D0015EC  AC850024   SW A1, 36(A0)
759:                                 _RMP_Run_Ins(Thread);
760:                             }
761:                         }
762:                         
763:                         if(Slice<RMP_SLICE_MAX)
764:                             Thread->Slice=Slice;
765:                     }
766:                     else
767:                     {
768:                         if(Prio<RMP_PREEMPT_PRIO_NUM)
9D00150C  54400001   BNEL V0, ZERO, 0x9D001514
9D001510  AC850024   SW A1, 36(A0)
769:                             Thread->Prio=Prio;
770:                         
771:                         if(Slice<RMP_SLICE_MAX)
9D001514  3C020001   LUI V0, 1
9D001518  344286A0   ORI V0, V0, -31072
9D00151C  00C2102B   SLTU V0, A2, V0
9D001520  54400001   BNEL V0, ZERO, .LBB260
9D001524  AC86001C   SW A2, 28(A0)
9D001630  0B400546   J 0x9D001518
9D001634  3C020001   LUI V0, 1
9D001638  0B40058E   J 0x9D001638
9D00163C  00000000   NOP
772:                             Thread->Slice=Slice;
773:                     }
774:                     
775:                     RMP_Sched_Unlock();
776:                     
777:                     return 0;
9D00154C  00008021   ADDU S0, ZERO, ZERO
778:                 }
9D001558  02001021   ADDU V0, S0, ZERO
9D00155C  8FBF0014   LW RA, 20(SP)
9D001560  8FB00010   LW S0, 16(SP)
9D001564  03E00008   JR RA
9D001568  27BD0018   ADDIU SP, SP, 24
9D001660  02001021   ADDU V0, S0, ZERO
9D001664  8FBF0014   LW RA, 20(SP)
9D001668  8FB00010   LW S0, 16(SP)
9D00166C  03E00008   JR RA
9D001670  27BD0018   ADDIU SP, SP, 24
9D0016A0  02001021   ADDU V0, S0, ZERO
9D0016A4  8FBF0014   LW RA, 20(SP)
9D0016A8  8FB00010   LW S0, 16(SP)
9D0016AC  03E00008   JR RA
9D0016B0  27BD0018   ADDIU SP, SP, 24
9D0016B8  02001021   ADDU V0, S0, ZERO
9D0016BC  8FBF0014   LW RA, 20(SP)
9D0016C0  8FB00010   LW S0, 16(SP)
9D0016C4  03E00008   JR RA
9D0016C8  27BD0018   ADDIU SP, SP, 24
9D0016D0  02001021   ADDU V0, S0, ZERO
9D0016D4  8FBF0014   LW RA, 20(SP)
9D0016D8  8FB00010   LW S0, 16(SP)
9D0016DC  03E00008   JR RA
9D0016E0  27BD0018   ADDIU SP, SP, 24
9D0016E4  0B4005B9   J 0x9D0016E4
9D0016E8  00000000   NOP
9D00170C  02001021   ADDU V0, S0, ZERO
9D001710  8FBF0014   LW RA, 20(SP)
9D001714  8FB00010   LW S0, 16(SP)
9D001718  03E00008   JR RA
9D00171C  27BD0018   ADDIU SP, SP, 24
779:                 /* End Function:RMP_Thd_Set **************************************************/
780:                 
781:                 /* Begin Function:RMP_Thd_Suspend *********************************************
782:                 Description : Suspend the execution of a real-time thread.
783:                 Input       : struct RMP_Thd* Thread - The thread structure of the thread.
784:                 Output      : None.
785:                 Return      : ret_t - If successful, 0; else error code.
786:                 ******************************************************************************/
787:                 ret_t RMP_Thd_Suspend(struct RMP_Thd* Thread)
788:                 {
9D001720  27BDFFE8   ADDIU SP, SP, -24
9D001724  AFBF0014   SW RA, 20(SP)
789:                     /* Check if this thread structure could possibly be in use */
790:                     if(Thread==0)
9D001728  10800074   BEQ A0, ZERO, 0x9D0018FC
9D00172C  AFB00010   SW S0, 16(SP)
791:                         return RMP_ERR_THD;
9D0018FC  2410FFFF   ADDIU S0, ZERO, -1
792:                     
793:                     RMP_Sched_Lock();
794:                     
795:                     if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
9D00173C  8C830018   LW V1, 24(A0)
9D001744  306500FF   ANDI A1, V1, 255
9D00174C  10A0005B   BEQ A1, ZERO, .LBB332
9D001750  30660100   ANDI A2, V1, 256
796:                     {
797:                         RMP_Sched_Unlock();
798:                         return RMP_ERR_THD;
9D0018DC  2410FFFF   ADDIU S0, ZERO, -1
799:                     }
800:                     
801:                     /* Suspend it */
802:                     if((Thread->State&RMP_THD_SUSPENDED)!=0)
9D001754  14C00031   BNE A2, ZERO, .LBB323
9D001758  34630100   ORI V1, V1, 256
803:                     {
804:                         RMP_Sched_Unlock();
805:                         return RMP_ERR_STATE;
9D00183C  2410FFFC   ADDIU S0, ZERO, -4
806:                     }
807:                     /* Mark this as suspended */
808:                     Thread->State|=RMP_THD_SUSPENDED;
809:                     /* Only when it is running do we clear this */
810:                     if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
9D00175C  10A20012   BEQ A1, V0, .LBB317
9D001760  AC830018   SW V1, 24(A0)
811:                         _RMP_Run_Del(Thread);
812:                     
813:                     RMP_Sched_Unlock();
814:                 
815:                     return 0;
9D001788  00008021   ADDU S0, ZERO, ZERO
816:                 }
9D001794  02001021   ADDU V0, S0, ZERO
9D001798  8FBF0014   LW RA, 20(SP)
9D00179C  8FB00010   LW S0, 16(SP)
9D0017A0  03E00008   JR RA
9D0017A4  27BD0018   ADDIU SP, SP, 24
9D001800  02001021   ADDU V0, S0, ZERO
9D001804  8FBF0014   LW RA, 20(SP)
9D001808  8FB00010   LW S0, 16(SP)
9D00180C  03E00008   JR RA
9D001810  27BD0018   ADDIU SP, SP, 24
9D001814  0B400605   J 0x9D001814
9D001818  00000000   NOP
9D001848  02001021   ADDU V0, S0, ZERO
9D00184C  8FBF0014   LW RA, 20(SP)
9D001850  8FB00010   LW S0, 16(SP)
9D001854  03E00008   JR RA
9D001858  27BD0018   ADDIU SP, SP, 24
9D0018A8  02001021   ADDU V0, S0, ZERO
9D0018AC  8FBF0014   LW RA, 20(SP)
9D0018B0  8FB00010   LW S0, 16(SP)
9D0018B4  03E00008   JR RA
9D0018B8  27BD0018   ADDIU SP, SP, 24
9D0018E8  02001021   ADDU V0, S0, ZERO
9D0018EC  8FBF0014   LW RA, 20(SP)
9D0018F0  8FB00010   LW S0, 16(SP)
9D0018F4  03E00008   JR RA
9D0018F8  27BD0018   ADDIU SP, SP, 24
9D001900  02001021   ADDU V0, S0, ZERO
9D001904  8FBF0014   LW RA, 20(SP)
9D001908  8FB00010   LW S0, 16(SP)
9D00190C  03E00008   JR RA
9D001910  27BD0018   ADDIU SP, SP, 24
9D001914  0B400645   J 0x9D001914
9D001918  00000000   NOP
9D00193C  02001021   ADDU V0, S0, ZERO
9D001940  8FBF0014   LW RA, 20(SP)
9D001944  8FB00010   LW S0, 16(SP)
9D001948  03E00008   JR RA
9D00194C  27BD0018   ADDIU SP, SP, 24
817:                 /* End Function:RMP_Thd_Suspend **********************************************/
818:                 
819:                 /* Begin Function:RMP_Thd_Resume **********************************************
820:                 Description : Resume the execution of a real-time thread.
821:                 Input       : struct RMP_Thd* Thread - The thread structure of the thread.
822:                 Output      : None.
823:                 Return      : ret_t - If successful, 0; else error code.
824:                 ******************************************************************************/
825:                 ret_t RMP_Thd_Resume(struct RMP_Thd* Thread)
826:                 {
9D001950  27BDFFE8   ADDIU SP, SP, -24
9D001954  AFBF0014   SW RA, 20(SP)
827:                     ret_t Retval;
828:                     
829:                     /* Check if this thread structure could possibly be in use */
830:                     if(Thread==0)
9D001958  1080002F   BEQ A0, ZERO, 0x9D001A18
9D00195C  AFB00010   SW S0, 16(SP)
831:                         return RMP_ERR_THD;
9D001A18  2410FFFF   ADDIU S0, ZERO, -1
832:                 
833:                     RMP_Sched_Lock();
834:                     
835:                     if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
9D00196C  8C850018   LW A1, 24(A0)
9D001974  30A200FF   ANDI V0, A1, 255
9D00197C  10400046   BEQ V0, ZERO, .LBB372
9D001980  30A60100   ANDI A2, A1, 256
836:                     {
837:                         RMP_Sched_Unlock();
838:                         return RMP_ERR_THD;
9D001AB8  2410FFFF   ADDIU S0, ZERO, -1
839:                     }
840:                     
841:                     /* Check if the thread is suspended, if not, then throw an error */
842:                     if((Thread->State&RMP_THD_SUSPENDED)!=0)
9D001984  10C00005   BEQ A2, ZERO, .LBB360
9D001988  2410FFFC   ADDIU S0, ZERO, -4
843:                     {
844:                         /* Suspended */
845:                         Thread->State&=~RMP_THD_SUSPENDED;
9D00198C  7C054204   INS A1, ZERO, 8, 1
846:                         if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
9D001990  10430027   BEQ V0, V1, .LBB366
9D001994  AC850018   SW A1, 24(A0)
847:                             _RMP_Run_Ins(Thread);
848:                         Retval=0;
9D001998  00008021   ADDU S0, ZERO, ZERO
9D001A90  0B400667   J .LBB360
9D001A94  00008021   ADDU S0, ZERO, ZERO
849:                     }
850:                     else
851:                         Retval=RMP_ERR_STATE;
852:                     
853:                     RMP_Sched_Unlock();
854:                 
855:                     return Retval;
856:                 }
9D0019C8  02001021   ADDU V0, S0, ZERO
9D0019CC  8FBF0014   LW RA, 20(SP)
9D0019D0  8FB00010   LW S0, 16(SP)
9D0019D4  03E00008   JR RA
9D0019D8  27BD0018   ADDIU SP, SP, 24
9D0019FC  02001021   ADDU V0, S0, ZERO
9D001A00  8FBF0014   LW RA, 20(SP)
9D001A04  8FB00010   LW S0, 16(SP)
9D001A08  03E00008   JR RA
9D001A0C  27BD0018   ADDIU SP, SP, 24
9D001A10  0B400684   J 0x9D001A10
9D001A14  00000000   NOP
9D001A1C  02001021   ADDU V0, S0, ZERO
9D001A20  8FBF0014   LW RA, 20(SP)
9D001A24  8FB00010   LW S0, 16(SP)
9D001A28  03E00008   JR RA
9D001A2C  27BD0018   ADDIU SP, SP, 24
9D001AC4  02001021   ADDU V0, S0, ZERO
9D001AC8  8FBF0014   LW RA, 20(SP)
9D001ACC  8FB00010   LW S0, 16(SP)
9D001AD0  03E00008   JR RA
9D001AD4  27BD0018   ADDIU SP, SP, 24
9D001AF8  02001021   ADDU V0, S0, ZERO
9D001AFC  8FBF0014   LW RA, 20(SP)
9D001B00  8FB00010   LW S0, 16(SP)
9D001B04  03E00008   JR RA
9D001B08  27BD0018   ADDIU SP, SP, 24
9D001B0C  0B4006C3   J 0x9D001B0C
9D001B10  00000000   NOP
857:                 /* End Function:RMP_Thd_Resume ***********************************************/
858:                 
859:                 /* Begin Function:RMP_Thd_Snd *************************************************
860:                 Description : Send to a real-time thread's mailbox. If the mailbox is full, then
861:                               this operation can potentially block.
862:                 Input       : struct RMP_Thd* Thread - The thread structure of the thread to send to.
863:                               ptr_t Data - The data to send to that thread.
864:                               ptr_t Slice - The timeslice to wait, if the mailbox is already full.
865:                 Output      : None.
866:                 Return      : ret_t - If successful,0; or an error code.
867:                 ******************************************************************************/
868:                 ret_t RMP_Thd_Snd(struct RMP_Thd* Thread, ptr_t Data, ptr_t Slice)
869:                 {
9D001B1C  27BDFFE8   ADDIU SP, SP, -24
9D001B20  AFBF0014   SW RA, 20(SP)
870:                     /* Check if this thread structure could possibly be in use */
871:                     if(Thread==0)
9D001B14  108000AE   BEQ A0, ZERO, 0x9D001DD0
9D001B18  00000000   NOP
872:                         return RMP_ERR_THD;
873:                     
874:                     RMP_Sched_Lock();
875:                     
876:                     if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
9D001B30  8C820018   LW V0, 24(A0)
9D001B38  304700FF   ANDI A3, V0, 255
9D001B40  10E00095   BEQ A3, ZERO, .LBB445
9D001B44  00000000   NOP
877:                     {
878:                         RMP_Sched_Unlock();
879:                         return RMP_ERR_THD;
9D001DB8  2402FFFF   ADDIU V0, ZERO, -1
9D001E00  2402FFFF   ADDIU V0, ZERO, -1
880:                     }
881:                     
882:                     /* Are we sending to ourself? This is not allowed */
883:                     if(RMP_Thd_Cur==Thread)
9D001B48  8F888084   LW T0, -32636(GP)
9D001B4C  110400CD   BEQ T0, A0, .LBB461
9D001B50  00000000   NOP
884:                     {
885:                         RMP_Sched_Unlock();
886:                         return RMP_ERR_OPER;
887:                     }
888:                     
889:                     RMP_Thd_Cur->Retval=0;
9D001B54  8F898084   LW T1, -32636(GP)
890:                 
891:                     /* See if there are already a value in the mailbox, if there is, we block */
892:                     if((Thread->State&RMP_THD_MBOXFUL)!=0)
9D001B58  30480200   ANDI T0, V0, 512
9D001B5C  11000032   BEQ T0, ZERO, 0x9D001C28
9D001B60  AD200038   SW ZERO, 56(T1)
893:                     {
894:                         /* Mailbox full, we block, and put ourself into the queue */
895:                         if(Slice==0)
9D001B64  10C000B9   BEQ A2, ZERO, .LBB454
9D001B68  00000000   NOP
896:                         {
897:                             RMP_Sched_Unlock();
898:                             return RMP_ERR_OPER;
9D001E6C  2402FFFB   ADDIU V0, ZERO, -5
9D001ED0  2402FFFB   ADDIU V0, ZERO, -5
899:                         }
900:                 
901:                         /* We must be running */
902:                         _RMP_Run_Del(RMP_Thd_Cur);
9D001B6C  8F828084   LW V0, -32636(GP)
903:                         RMP_List_Ins(&(RMP_Thd_Cur->Run_Head),Thread->Snd_List.Prev,&(Thread->Snd_List));
9D001B94  8F828084   LW V0, -32636(GP)
9D001B98  8C830010   LW V1, 16(A0)
9D001B9C  24880010   ADDIU T0, A0, 16
904:                 
905:                         if(Slice<RMP_SLICE_MAX)
9D001BA0  3C070001   LUI A3, 1
9D001BA4  34E786A0   ORI A3, A3, -31072
9D001BA8  00C7382B   SLTU A3, A2, A3
9D001BBC  14E00052   BNE A3, ZERO, 0x9D001D08
9D001BC0  00000000   NOP
906:                         {
907:                             _RMP_Dly_Ins(RMP_Thd_Cur, Slice);
9D001D08  8F838084   LW V1, -32636(GP)
908:                             RMP_THD_STATE_SET(RMP_Thd_Cur->State,RMP_THD_SNDDLY);
9D001D58  8F828084   LW V0, -32636(GP)
9D001D5C  8F838084   LW V1, -32636(GP)
9D001D60  8C630018   LW V1, 24(V1)
9D001D64  7C033804   INS V1, ZERO, 0, 8
9D001D68  34630003   ORI V1, V1, 3
9D001D6C  AC430018   SW V1, 24(V0)
909:                         }
910:                         else
911:                             RMP_THD_STATE_SET(RMP_Thd_Cur->State,RMP_THD_SNDBLK);
9D001BC4  8F828084   LW V0, -32636(GP)
9D001BC8  8F838084   LW V1, -32636(GP)
9D001BCC  8C630018   LW V1, 24(V1)
9D001BD0  7C033804   INS V1, ZERO, 0, 8
9D001BD4  34630002   ORI V1, V1, 2
9D001BD8  AC430018   SW V1, 24(V0)
912:                 
913:                         RMP_Thd_Cur->Data=Data;
9D001BDC  8F828084   LW V0, -32636(GP)
9D001BE0  AC450030   SW A1, 48(V0)
9D001D70  8F828084   LW V0, -32636(GP)
9D001D74  0B4006F9   J .LBB427
9D001D78  AC450030   SW A1, 48(V0)
9D001D7C  0B40075F   J 0x9D001D7C
9D001D80  00000000   NOP
914:                     }
915:                     else
916:                     {
917:                         /* Mailbox not full. We need to check if the receiver is waiting for us */
918:                         if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
9D001C28  24E3FFFC   ADDIU V1, A3, -4
9D001C2C  2C630002   SLTIU V1, V1, 2
9D001C30  14600011   BNE V1, ZERO, 0x9D001C78
9D001C34  00403021   ADDU A2, V0, ZERO
919:                            (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
920:                         {
921:                             /* The receiver is blocked, wake it up and return the value */
922:                             if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
9D001C78  24030005   ADDIU V1, ZERO, 5
9D001C7C  50E30041   BEQL A3, V1, 0x9D001D84
9D001C80  8C830008   LW V1, 8(A0)
923:                                 RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
9D001D84  8C86000C   LW A2, 12(A0)
924:                             
925:                             RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
9D001C84  2403FF00   ADDIU V1, ZERO, -256
9D001C88  00433024   AND A2, V0, V1
9D001C8C  34C60001   ORI A2, A2, 1
9D001D90  0B400722   J 0x9D001C88
9D001D94  2403FF00   ADDIU V1, ZERO, -256
926:                 
927:                             /* Is it suspended? If yes, we can't directly send it running */
928:                             if((Thread->State&RMP_THD_SUSPENDED)==0)
9D001C90  30420100   ANDI V0, V0, 256
9D001C94  1440FFE8   BNE V0, ZERO, 0x9D001C38
9D001C98  AC860018   SW A2, 24(A0)
929:                                 _RMP_Run_Ins(Thread);
930:                         }
931:                         
932:                         /* Set the mailbox */
933:                         Thread->Mailbox=Data;
9D001C3C  AC85002C   SW A1, 44(A0)
934:                         Thread->State|=RMP_THD_MBOXFUL;
9D001C38  34C60200   ORI A2, A2, 512
9D001C40  AC860018   SW A2, 24(A0)
9D001D00  0B40070F   J 0x9D001C3C
9D001D04  34C60200   ORI A2, A2, 512
935:                     }
936:                     
937:                     RMP_Sched_Unlock();
938:                 
939:                     return RMP_Thd_Cur->Retval;
9D001C14  8F828084   LW V0, -32636(GP)
9D001C18  8C420038   LW V0, 56(V0)
940:                 }
9D001C1C  8FBF0014   LW RA, 20(SP)
9D001C20  03E00008   JR RA
9D001C24  27BD0018   ADDIU SP, SP, 24
9D001DC4  8FBF0014   LW RA, 20(SP)
9D001DC8  03E00008   JR RA
9D001DCC  27BD0018   ADDIU SP, SP, 24
9D001DD0  03E00008   JR RA
9D001DD4  2402FFFF   ADDIU V0, ZERO, -1
9D001DD8  0B400776   J 0x9D001DD8
9D001DDC  00000000   NOP
9D001E04  8FBF0014   LW RA, 20(SP)
9D001E08  03E00008   JR RA
9D001E0C  27BD0018   ADDIU SP, SP, 24
9D001E78  8FBF0014   LW RA, 20(SP)
9D001E7C  03E00008   JR RA
9D001E80  27BD0018   ADDIU SP, SP, 24
9D001ED4  8FBF0014   LW RA, 20(SP)
9D001ED8  03E00008   JR RA
9D001EDC  27BD0018   ADDIU SP, SP, 24
941:                 /* End Function:RMP_Thd_Snd **************************************************/
942:                 
943:                 /* Begin Function:RMP_Thd_Snd_ISR *********************************************
944:                 Description : Send to a real-time thread's mailbox. If the mailbox is full, then
945:                               this operation will just fail. This function can only be called from
946:                               an ISR whose priority is below or equal to the context switch handler's.
947:                 Input       : struct RMP_Thd* Thread - The thread structure of the thread to send to.
948:                               ptr_t Data - The data to send to that thread.
949:                 Output      : None.
950:                 Return      : ret_t - If successful,0; or an error code.
951:                 ******************************************************************************/
952:                 ret_t RMP_Thd_Snd_ISR(struct RMP_Thd* Thread, ptr_t Data)
953:                 {
9D001EF8  27BDFFE0   ADDIU SP, SP, -32
9D001EFC  AFBF001C   SW RA, 28(SP)
954:                     /* Check if this thread structure could possibly be in use */
955:                     if(Thread==0)
9D001EE0  1080004D   BEQ A0, ZERO, 0x9D002018
9D001EE4  00000000   NOP
956:                         return RMP_ERR_THD;
9D002018  03E00008   JR RA
9D00201C  2402FFFF   ADDIU V0, ZERO, -1
957:                     
958:                     if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
9D001EE8  8C820018   LW V0, 24(A0)
9D001EEC  304300FF   ANDI V1, V0, 255
9D001EF0  10600049   BEQ V1, ZERO, 0x9D002018
9D001EF4  00000000   NOP
959:                         return RMP_ERR_THD;
960:                     
961:                     if(RMP_Sched_Locked!=0)
9D001F00  8F86806C   LW A2, -32660(GP)
9D001F04  14C00042   BNE A2, ZERO, 0x9D002010
9D001F08  30460200   ANDI A2, V0, 512
962:                         return RMP_ERR_OPER;
9D002010  0B4007CC   J 0x9D001F30
9D002014  2402FFFB   ADDIU V0, ZERO, -5
963:                 
964:                     /* See if there are already a value in the mailbox, if there is, we abort */
965:                     if((Thread->State&RMP_THD_MBOXFUL)!=0)
9D001F0C  14C00040   BNE A2, ZERO, 0x9D002010
9D001F10  2467FFFC   ADDIU A3, V1, -4
966:                         return RMP_ERR_OPER;
967:                     else
968:                     {
969:                         /* Mailbox not full. We need to check if the receiver is waiting for us */
970:                         if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
9D001F14  2CE70002   SLTIU A3, A3, 2
9D001F18  14E00008   BNE A3, ZERO, 0x9D001F3C
9D001F1C  00403021   ADDU A2, V0, ZERO
971:                            (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
972:                         {
973:                             /* The receiver is blocked, wake it up and return the value */
974:                             if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
9D001F3C  24060005   ADDIU A2, ZERO, 5
9D001F40  5066002E   BEQL V1, A2, 0x9D001FFC
9D001F44  8C830008   LW V1, 8(A0)
975:                                 RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
9D001FFC  8C86000C   LW A2, 12(A0)
976:                             
977:                             RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
9D001F48  2406FF00   ADDIU A2, ZERO, -256
9D001F4C  00461824   AND V1, V0, A2
9D001F50  34630001   ORI V1, V1, 1
9D001F58  AC830018   SW V1, 24(A0)
9D002008  0B4007D3   J 0x9D001F4C
9D00200C  2406FF00   ADDIU A2, ZERO, -256
978:                 
979:                             /* Is it suspended? If yes, we can't directly send it running */
980:                             if((Thread->State&RMP_THD_SUSPENDED)==0)
9D001F54  30420100   ANDI V0, V0, 256
9D001F5C  1440FFF0   BNE V0, ZERO, 0x9D001F20
9D001F60  00603021   ADDU A2, V1, ZERO
981:                             {
982:                                 _RMP_Run_Ins(Thread);
983:                                 if(Thread->Prio>RMP_Thd_Cur->Prio)
9D001FC8  8F878084   LW A3, -32636(GP)
9D001FCC  00603021   ADDU A2, V1, ZERO
9D001FD0  8CE30024   LW V1, 36(A3)
9D001FD4  0062102B   SLTU V0, V1, V0
9D001FD8  5040FFD2   BEQL V0, ZERO, 0x9D001F24
9D001FDC  34C60200   ORI A2, A2, 512
984:                                     _RMP_Yield();
9D001FE0  AFA40010   SW A0, 16(SP)
9D001FE4  0F4012F8   JAL _RMP_Yield
9D001FE8  AFA50014   SW A1, 20(SP)
9D001FEC  8FA40010   LW A0, 16(SP)
9D001FF0  8C860018   LW A2, 24(A0)
9D001FF4  0B4007C8   J 0x9D001F20
9D001FF8  8FA50014   LW A1, 20(SP)
985:                             }
986:                         }
987:                         
988:                         /* Set the mailbox */
989:                         Thread->Mailbox=Data;
9D001F24  AC85002C   SW A1, 44(A0)
990:                         Thread->State|=RMP_THD_MBOXFUL;
9D001F20  34C60200   ORI A2, A2, 512
9D001F28  AC860018   SW A2, 24(A0)
991:                     }
992:                 
993:                     return 0;
9D001F2C  00001021   ADDU V0, ZERO, ZERO
994:                 }
9D001F30  8FBF001C   LW RA, 28(SP)
9D001F34  03E00008   JR RA
9D001F38  27BD0020   ADDIU SP, SP, 32
995:                 /* End Function:RMP_Thd_Snd_ISR **********************************************/
996:                 
997:                 /* Begin Function:RMP_Thd_Rcv *************************************************
998:                 Description : Receive a message from our own mailbox, and this is blocking.
999:                 Input       : ptr_t Slice - The timeslices to wait, if the mailbox is empty.
1000:                Output      : ptr_t* Data - The pointer to put the data to.
1001:                Return      : ret_t - If successful,0; or an error code.
1002:                ******************************************************************************/
1003:                ret_t RMP_Thd_Rcv(ptr_t* Data, ptr_t Slice)
1004:                {
9D002020  27BDFFE8   ADDIU SP, SP, -24
9D002024  AFBF0014   SW RA, 20(SP)
9D002028  AFB00010   SW S0, 16(SP)
9D002038  00808021   ADDU S0, A0, ZERO
1005:                    struct RMP_Thd* Sender;
1006:                    
1007:                    RMP_Sched_Lock();
1008:                
1009:                    /* Check if there is a value in our mailbox. If yes, we return with that value */
1010:                    if((RMP_Thd_Cur->State&RMP_THD_MBOXFUL)!=0)
9D002044  8F838084   LW V1, -32636(GP)
9D002048  8C630018   LW V1, 24(V1)
9D00204C  30630200   ANDI V1, V1, 512
9D002050  1460002E   BNE V1, ZERO, 0x9D00210C
9D002054  00000000   NOP
1011:                    {
1012:                        /* Get the value from mailbox */
1013:                        *Data=RMP_Thd_Cur->Mailbox;
9D00210C  8F858084   LW A1, -32636(GP)
9D002118  8CA5002C   LW A1, 44(A1)
9D00211C  AE050000   SW A1, 0(S0)
1014:                        RMP_Thd_Cur->State&=~RMP_THD_MBOXFUL;
9D002110  8F838084   LW V1, -32636(GP)
9D002120  8C650018   LW A1, 24(V1)
9D002124  7C054A44   INS A1, ZERO, 9, 1
1015:                        RMP_Sched_Unlock();
1016:                        return 0;
9D002144  00008021   ADDU S0, ZERO, ZERO
1017:                    }
1018:                    else
1019:                    {
1020:                        /* Is there any other guy waiting on us? If there is, unblock it and set it running */
1021:                        if(&(RMP_Thd_Cur->Snd_List)!=RMP_Thd_Cur->Snd_List.Next)
9D002058  8F838084   LW V1, -32636(GP)
9D00205C  8F848084   LW A0, -32636(GP)
9D002060  24630010   ADDIU V1, V1, 16
9D002064  8C840014   LW A0, 20(A0)
9D002068  10830068   BEQ A0, V1, 0x9D00220C
9D00206C  00000000   NOP
1022:                        {
1023:                            /* Read the data */
1024:                            Sender=(struct RMP_Thd*)(RMP_Thd_Cur->Snd_List.Next);
9D002070  8F828084   LW V0, -32636(GP)
9D002074  8C420014   LW V0, 20(V0)
1025:                            RMP_List_Del(Sender->Run_Head.Prev,Sender->Run_Head.Next);
9D002078  8C430000   LW V1, 0(V0)
9D00207C  8C440004   LW A0, 4(V0)
1026:                            *Data=Sender->Data;
9D002080  8C450030   LW A1, 48(V0)
9D00208C  AE050000   SW A1, 0(S0)
1027:                            /* Now we unblock it - what state is it in? */
1028:                            if((RMP_THD_STATE(Sender->State)==RMP_THD_SNDDLY))
9D002090  8C430018   LW V1, 24(V0)
9D002094  306500FF   ANDI A1, V1, 255
9D002098  24040003   ADDIU A0, ZERO, 3
9D00209C  50A40056   BEQL A1, A0, .LBE543
9D0020A0  8C440008   LW A0, 8(V0)
1029:                                RMP_List_Del(Sender->Dly_Head.Prev,Sender->Dly_Head.Next);
9D0021F8  8C45000C   LW A1, 12(V0)
1030:                            
1031:                            RMP_THD_STATE_SET(Sender->State,RMP_THD_RUNNING);
9D0020A4  2405FF00   ADDIU A1, ZERO, -256
9D0020A8  00652024   AND A0, V1, A1
9D0020AC  34840001   ORI A0, A0, 1
9D002204  0B40082A   J 0x9D0020A8
9D002208  2405FF00   ADDIU A1, ZERO, -256
1032:                
1033:                            /* Is it suspended? If yes, we can't directly send it running */
1034:                            if((Sender->State&RMP_THD_SUSPENDED)==0)
9D0020B0  30630100   ANDI V1, V1, 256
9D0020B4  10600035   BEQ V1, ZERO, .LBB543
9D0020B8  AC440018   SW A0, 24(V0)
1035:                                _RMP_Run_Ins(Sender);
1036:                            
1037:                            RMP_Sched_Unlock();
1038:                        }
1039:                        /* No sender waiting on us, we need to block */
1040:                        else
1041:                        {
1042:                            /* No such value in our mailbox, we need to block */
1043:                            if(Slice==0)
9D00220C  10A0007B   BEQ A1, ZERO, 0x9D0023FC
9D002210  00000000   NOP
1044:                            {
1045:                                RMP_Sched_Unlock();
1046:                                return RMP_ERR_OPER;
9D00241C  2410FFFB   ADDIU S0, ZERO, -5
1047:                            }
1048:                
1049:                            /* We must be running */
1050:                            _RMP_Run_Del(RMP_Thd_Cur);
9D002214  8F838084   LW V1, -32636(GP)
1051:                
1052:                            if(Slice<RMP_SLICE_MAX)
9D00223C  3C020001   LUI V0, 1
9D002240  344286A0   ORI V0, V0, -31072
9D002244  00A2102B   SLTU V0, A1, V0
9D002248  14400042   BNE V0, ZERO, 0x9D002354
9D00224C  00000000   NOP
9D0023C4  0B400890   J 0x9D002240
9D0023C8  3C020001   LUI V0, 1
1053:                            {
1054:                                _RMP_Dly_Ins(RMP_Thd_Cur, Slice);
9D002354  8F838084   LW V1, -32636(GP)
1055:                                RMP_THD_STATE_SET(RMP_Thd_Cur->State,RMP_THD_RCVDLY);
9D0023A4  8F828084   LW V0, -32636(GP)
9D0023A8  8F838084   LW V1, -32636(GP)
9D0023AC  8C630018   LW V1, 24(V1)
9D0023B0  7C033804   INS V1, ZERO, 0, 8
9D0023B4  34630005   ORI V1, V1, 5
9D0023B8  0B40089A   J .LBB557
9D0023BC  AC430018   SW V1, 24(V0)
1056:                            }
1057:                            else
1058:                                RMP_THD_STATE_SET(RMP_Thd_Cur->State,RMP_THD_RCVBLK);
9D002250  8F828084   LW V0, -32636(GP)
9D002254  8F838084   LW V1, -32636(GP)
9D002258  8C630018   LW V1, 24(V1)
9D00225C  7C033804   INS V1, ZERO, 0, 8
9D002260  34630004   ORI V1, V1, 4
9D002264  AC430018   SW V1, 24(V0)
1059:                            
1060:                            RMP_Sched_Unlock();
1061:                            /* Dummy read - to separate the lock & unlock. If the compiler optimizes these two
1062:                             * functions(inline them) on some architectures sometimes we never block. */
1063:                            *Data=RMP_Thd_Cur->Mailbox;
9D002298  8F838084   LW V1, -32636(GP)
9D0022A4  8C63002C   LW V1, 44(V1)
9D0022B4  AE030000   SW V1, 0(S0)
1064:                            /* We've been unblocked. There must be something in our mbox, or we should have failed */
1065:                            RMP_Sched_Lock();
1066:                            *Data=RMP_Thd_Cur->Mailbox;
9D0022B0  8F848084   LW A0, -32636(GP)
9D0022BC  8C85002C   LW A1, 44(A0)
9D0022C4  AE050000   SW A1, 0(S0)
1067:                            RMP_Thd_Cur->State&=~RMP_THD_MBOXFUL;
9D0022B8  8F838084   LW V1, -32636(GP)
9D0022C8  8C650018   LW A1, 24(V1)
9D0022CC  7C054A44   INS A1, ZERO, 9, 1
1068:                            RMP_Sched_Unlock();
1069:                        }
1070:                    }
1071:                    
1072:                    return RMP_Thd_Cur->Retval;
9D0020E8  8F828084   LW V0, -32636(GP)
9D0020EC  8C500038   LW S0, 56(V0)
1073:                }
9D0020F0  02001021   ADDU V0, S0, ZERO
9D0020F4  8FBF0014   LW RA, 20(SP)
9D0020F8  8FB00010   LW S0, 16(SP)
9D0020FC  03E00008   JR RA
9D002100  27BD0018   ADDIU SP, SP, 24
9D002104  0B400841   J 0x9D002104
9D002108  00000000   NOP
9D002150  02001021   ADDU V0, S0, ZERO
9D002154  8FBF0014   LW RA, 20(SP)
9D002158  8FB00010   LW S0, 16(SP)
9D00215C  03E00008   JR RA
9D002160  27BD0018   ADDIU SP, SP, 24
9D002310  02001021   ADDU V0, S0, ZERO
9D002314  8FBF0014   LW RA, 20(SP)
9D002318  8FB00010   LW S0, 16(SP)
9D00231C  03E00008   JR RA
9D002320  27BD0018   ADDIU SP, SP, 24
9D002324  0B4008C9   J 0x9D002324
9D002328  00000000   NOP
9D002428  02001021   ADDU V0, S0, ZERO
9D00242C  8FBF0014   LW RA, 20(SP)
9D002430  8FB00010   LW S0, 16(SP)
9D002434  03E00008   JR RA
9D002438  27BD0018   ADDIU SP, SP, 24
9D00243C  0B40090F   J 0x9D00243C
9D002440  00000000   NOP
9D002444  0B400911   J 0x9D002444
9D002448  00000000   NOP
9D002460  02001021   ADDU V0, S0, ZERO
9D002464  8FBF0014   LW RA, 20(SP)
9D002468  8FB00010   LW S0, 16(SP)
9D00246C  03E00008   JR RA
9D002470  27BD0018   ADDIU SP, SP, 24
1074:                /* End Function:RMP_Thd_Rcv **************************************************/
1075:                
1076:                /* Begin Function:RMP_Thd_Delay ***********************************************
1077:                Description : Delay the execution of a real-time thread.
1078:                Input       : ptr_t Slice - The number of timeslices to delay.
1079:                Output      : None.
1080:                Return      : ret_t - If successful, 0; else error code.
1081:                ******************************************************************************/
1082:                ret_t RMP_Thd_Delay(ptr_t Slice)
1083:                {
9D00248C  27BDFFE8   ADDIU SP, SP, -24
9D002490  AFBF0014   SW RA, 20(SP)
1084:                    if((Slice==0)||(Slice>=RMP_SLICE_MAX))
9D002474  2483FFFF   ADDIU V1, A0, -1
9D002478  3C020001   LUI V0, 1
9D00247C  3442869F   ORI V0, V0, -31073
9D002480  0062102B   SLTU V0, V1, V0
9D002484  1040005F   BEQ V0, ZERO, 0x9D002604
9D002488  00000000   NOP
1085:                        return RMP_ERR_SLICE;
9D002604  03E00008   JR RA
9D002608  2402FFFD   ADDIU V0, ZERO, -3
1086:                    
1087:                    RMP_Sched_Lock();
1088:                
1089:                    /* We must be running */
1090:                    _RMP_Run_Del(RMP_Thd_Cur);
9D0024A8  8F828084   LW V0, -32636(GP)
1091:                    RMP_THD_STATE_SET(RMP_Thd_Cur->State,RMP_THD_DELAYED);
9D0024D0  8F838084   LW V1, -32636(GP)
9D0024D4  8F868084   LW A2, -32636(GP)
9D0024E0  8CC60018   LW A2, 24(A2)
9D0024E4  7C063804   INS A2, ZERO, 0, 8
9D0024E8  34C60006   ORI A2, A2, 6
9D0024EC  AC660018   SW A2, 24(V1)
1092:                    _RMP_Dly_Ins(RMP_Thd_Cur, Slice);
9D0024D8  8F858084   LW A1, -32636(GP)
1093:                
1094:                    RMP_Thd_Cur->Retval=0;
9D002538  8F828084   LW V0, -32636(GP)
9D002540  AC400038   SW ZERO, 56(V0)
1095:                    
1096:                    RMP_Sched_Unlock();
1097:                    
1098:                    /* Need to return if successful or not */
1099:                    return RMP_Thd_Cur->Retval;
9D00256C  8F828084   LW V0, -32636(GP)
9D002570  8C420038   LW V0, 56(V0)
9D0025F0  8F828084   LW V0, -32636(GP)
9D0025F4  8C420038   LW V0, 56(V0)
1100:                }
9D002574  8FBF0014   LW RA, 20(SP)
9D002578  03E00008   JR RA
9D00257C  27BD0018   ADDIU SP, SP, 24
9D0025F8  8FBF0014   LW RA, 20(SP)
9D0025FC  03E00008   JR RA
9D002600  27BD0018   ADDIU SP, SP, 24
1101:                /* End Function:RMP_Thd_Delay ************************************************/
1102:                
1103:                /* Begin Function:RMP_Thd_Cancel **********************************************
1104:                Description : Cancel the real-time thread from a previous delay.
1105:                Input       : struct RMP_Thd* Thread - The thread structure of the thread.
1106:                Output      : None.
1107:                Return      : ret_t - If successful, 0; else error code.
1108:                ******************************************************************************/
1109:                ret_t RMP_Thd_Cancel(struct RMP_Thd* Thread)
1110:                {
9D00260C  27BDFFE8   ADDIU SP, SP, -24
9D002610  AFBF0014   SW RA, 20(SP)
1111:                    /* Check if this thread structure could possibly be in use */
1112:                    if(Thread==0)
9D002614  10800065   BEQ A0, ZERO, 0x9D0027AC
9D002618  AFB00010   SW S0, 16(SP)
1113:                        return RMP_ERR_THD;
9D0027AC  2410FFFF   ADDIU S0, ZERO, -1
1114:                    
1115:                    RMP_Sched_Lock();
1116:                    
1117:                    /* Is it delayed? */
1118:                    if(RMP_THD_STATE(Thread->State)!=RMP_THD_DELAYED)
9D002628  8C830018   LW V1, 24(A0)
9D002630  306600FF   ANDI A2, V1, 255
9D002638  24050006   ADDIU A1, ZERO, 6
9D00263C  14C5004B   BNE A2, A1, .LBB670
9D002640  2408FF00   ADDIU T0, ZERO, -256
1119:                    {
1120:                        RMP_Sched_Unlock();
1121:                        return RMP_ERR_STATE;
9D00278C  2410FFFC   ADDIU S0, ZERO, -4
1122:                    }
1123:                
1124:                    /* Delete it from the delay list */
1125:                    RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
9D002644  8C850008   LW A1, 8(A0)
9D002648  8C86000C   LW A2, 12(A0)
1126:                    RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
9D00264C  00683824   AND A3, V1, T0
9D002650  34E70001   ORI A3, A3, 1
1127:                    
1128:                    /* Only when when this thread is not suspended do we change it back */
1129:                    if((Thread->State&RMP_THD_SUSPENDED)==0)
9D002654  30630100   ANDI V1, V1, 256
9D002660  10600014   BEQ V1, ZERO, .LBB662
9D002664  AC870018   SW A3, 24(A0)
1130:                        _RMP_Run_Ins(Thread);
1131:                    
1132:                    Thread->Retval=RMP_ERR_OPER;
9D00266C  2402FFFB   ADDIU V0, ZERO, -5
9D002670  AC820038   SW V0, 56(A0)
9D00271C  2402FFFB   ADDIU V0, ZERO, -5
9D002720  AC820038   SW V0, 56(A0)
1133:                    
1134:                    RMP_Sched_Unlock();
1135:                
1136:                    return 0;
9D002694  00008021   ADDU S0, ZERO, ZERO
1137:                }
9D0026A0  02001021   ADDU V0, S0, ZERO
9D0026A4  8FBF0014   LW RA, 20(SP)
9D0026A8  8FB00010   LW S0, 16(SP)
9D0026AC  03E00008   JR RA
9D0026B0  27BD0018   ADDIU SP, SP, 24
9D002750  02001021   ADDU V0, S0, ZERO
9D002754  8FBF0014   LW RA, 20(SP)
9D002758  8FB00010   LW S0, 16(SP)
9D00275C  03E00008   JR RA
9D002760  27BD0018   ADDIU SP, SP, 24
9D002764  0B4009D9   J 0x9D002764
9D002768  00000000   NOP
9D002798  02001021   ADDU V0, S0, ZERO
9D00279C  8FBF0014   LW RA, 20(SP)
9D0027A0  8FB00010   LW S0, 16(SP)
9D0027A4  03E00008   JR RA
9D0027A8  27BD0018   ADDIU SP, SP, 24
9D0027B0  02001021   ADDU V0, S0, ZERO
9D0027B4  8FBF0014   LW RA, 20(SP)
9D0027B8  8FB00010   LW S0, 16(SP)
9D0027BC  03E00008   JR RA
9D0027C0  27BD0018   ADDIU SP, SP, 24
9D0027C4  0B4009F1   J 0x9D0027C4
9D0027C8  00000000   NOP
9D0027E0  02001021   ADDU V0, S0, ZERO
9D0027E4  8FBF0014   LW RA, 20(SP)
9D0027E8  8FB00010   LW S0, 16(SP)
9D0027EC  03E00008   JR RA
9D0027F0  27BD0018   ADDIU SP, SP, 24
1138:                /* End Function:RMP_Thd_Cancel ***********************************************/
1139:                
1140:                /* Begin Function:RMP_Sem_Crt *************************************************
1141:                Description : Create a semaphore in the system.
1142:                Input       : struct RMP_Sem* Semaphore - The pointer to the semaphore structure.
1143:                              ptr_t Number - The initial number of this semaphore.
1144:                Output      : None.
1145:                Return      : ret_t - If successful, 0; or an error code.
1146:                ******************************************************************************/
1147:                ret_t RMP_Sem_Crt(struct RMP_Sem* Semaphore, ptr_t Number)
1148:                {
9D0027F4  27BDFFE8   ADDIU SP, SP, -24
9D0027F8  AFBF0014   SW RA, 20(SP)
1149:                    /* Check if this semaphore structure could possibly be in use */
1150:                    if(Semaphore==0)
9D0027FC  1080002D   BEQ A0, ZERO, 0x9D0028B4
9D002800  AFB00010   SW S0, 16(SP)
1151:                        return RMP_ERR_SEM;
9D0028B4  2410FFFA   ADDIU S0, ZERO, -6
1152:                    
1153:                    RMP_Sched_Lock();
1154:                    
1155:                    if(Semaphore->State!=RMP_SEM_FREE)
9D002810  8C830008   LW V1, 8(A0)
9D00281C  1460003B   BNE V1, ZERO, .LBB717
9D002820  2CA303E8   SLTIU V1, A1, 1000
1156:                    {
1157:                        RMP_Sched_Unlock();
1158:                        return RMP_ERR_SEM;
9D00292C  2410FFFA   ADDIU S0, ZERO, -6
1159:                    }
1160:                    
1161:                    /* Is the number too great to initialize? */
1162:                    if(Number>=RMP_SEM_CNT_MAX)
9D002824  10600029   BEQ V1, ZERO, .LBB710
9D002828  00000000   NOP
1163:                    {
1164:                        RMP_Sched_Unlock();
1165:                        return RMP_ERR_OPER;
9D0028EC  2410FFFB   ADDIU S0, ZERO, -5
1166:                    }
1167:                
1168:                    /* Initialize contents */
1169:                    Semaphore->Cur_Num=Number;
9D002838  AC85000C   SW A1, 12(A0)
1170:                    Semaphore->State=RMP_SEM_USED;
1171:                    RMP_List_Crt(&(Semaphore->Wait_List));
1172:                    
1173:                    RMP_Sched_Unlock();
1174:                    
1175:                    return 0;
9D002858  00008021   ADDU S0, ZERO, ZERO
1176:                }
9D002864  02001021   ADDU V0, S0, ZERO
9D002868  8FBF0014   LW RA, 20(SP)
9D00286C  8FB00010   LW S0, 16(SP)
9D002870  03E00008   JR RA
9D002874  27BD0018   ADDIU SP, SP, 24
9D002898  02001021   ADDU V0, S0, ZERO
9D00289C  8FBF0014   LW RA, 20(SP)
9D0028A0  8FB00010   LW S0, 16(SP)
9D0028A4  03E00008   JR RA
9D0028A8  27BD0018   ADDIU SP, SP, 24
9D0028AC  0B400A2B   J 0x9D0028AC
9D0028B0  00000000   NOP
9D0028B8  02001021   ADDU V0, S0, ZERO
9D0028BC  8FBF0014   LW RA, 20(SP)
9D0028C0  8FB00010   LW S0, 16(SP)
9D0028C4  03E00008   JR RA
9D0028C8  27BD0018   ADDIU SP, SP, 24
9D0028F8  02001021   ADDU V0, S0, ZERO
9D0028FC  8FBF0014   LW RA, 20(SP)
9D002900  8FB00010   LW S0, 16(SP)
9D002904  03E00008   JR RA
9D002908  27BD0018   ADDIU SP, SP, 24
9D002938  02001021   ADDU V0, S0, ZERO
9D00293C  8FBF0014   LW RA, 20(SP)
9D002940  8FB00010   LW S0, 16(SP)
9D002944  03E00008   JR RA
9D002948  27BD0018   ADDIU SP, SP, 24
9D00294C  0B400A53   J 0x9D00294C
9D002950  00000000   NOP
9D002968  02001021   ADDU V0, S0, ZERO
9D00296C  8FBF0014   LW RA, 20(SP)
9D002970  8FB00010   LW S0, 16(SP)
9D002974  03E00008   JR RA
9D002978  27BD0018   ADDIU SP, SP, 24
9D00297C  0B400A5F   J 0x9D00297C
9D002980  00000000   NOP
9D0029A4  02001021   ADDU V0, S0, ZERO
9D0029A8  8FBF0014   LW RA, 20(SP)
9D0029AC  8FB00010   LW S0, 16(SP)
9D0029B0  03E00008   JR RA
9D0029B4  27BD0018   ADDIU SP, SP, 24
1177:                /* End Function:RMP_Sem_Crt **************************************************/
1178:                
1179:                /* Begin Function:RMP_Sem_Del *************************************************
1180:                Description : Delete a semaphore in the system.
1181:                Input       : struct RMP_Sem* Semaphore - The pointer to the semaphore structure.
1182:                Output      : None.
1183:                Return      : ret_t - If successful, 0; else error code.
1184:                ******************************************************************************/
1185:                ret_t RMP_Sem_Del(struct RMP_Sem* Semaphore)
1186:                {
9D0029B8  27BDFFE8   ADDIU SP, SP, -24
9D0029BC  AFBF0014   SW RA, 20(SP)
1187:                    struct RMP_Thd* Thread;
1188:                    
1189:                    /* Check if this semaphore structure could possibly be in use */
1190:                    if(Semaphore==0)
9D0029C0  10800075   BEQ A0, ZERO, 0x9D002B98
9D0029C4  AFB00010   SW S0, 16(SP)
1191:                        return RMP_ERR_SEM;
9D002B98  2410FFFA   ADDIU S0, ZERO, -6
1192:                    
1193:                    RMP_Sched_Lock();
1194:                    
1195:                    if(Semaphore->State!=RMP_SEM_USED)
9D0029D4  8C830008   LW V1, 8(A0)
9D0029E0  1462005D   BNE V1, V0, .LBB768
9D0029E4  00000000   NOP
1196:                    {
1197:                        RMP_Sched_Unlock();
1198:                        return RMP_ERR_SEM;
9D002B78  2410FFFA   ADDIU S0, ZERO, -6
1199:                    }
1200:                
1201:                    /* Get rid of all guys waiting on it */
1202:                    while(&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)
9D0029E8  8C820004   LW V0, 4(A0)
9D0029EC  1082003A   BEQ A0, V0, .LBB760
9D0029F0  00000000   NOP
9D002A1C  8C820004   LW V0, 4(A0)
9D002A20  1044002D   BEQ V0, A0, .LBB760
9D002A24  00000000   NOP
9D002ACC  8C820004   LW V0, 4(A0)
9D002AD0  5444FFD6   BNEL V0, A0, 0x9D002A2C
9D002AD4  8C430018   LW V1, 24(V0)
1203:                    {
1204:                        Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
1205:                        RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
9D002A2C  8C450000   LW A1, 0(V0)
9D002A30  8C460004   LW A2, 4(V0)
1206:                        if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
9D0029F4  240A0008   ADDIU T2, ZERO, 8
9D002A28  8C430018   LW V1, 24(V0)
9D002A3C  306800FF   ANDI T0, V1, 255
9D002A50  150AFFEF   BNE T0, T2, 0x9D002A10
9D002A54  00000000   NOP
1207:                            RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
9D002A58  8C450008   LW A1, 8(V0)
9D002A5C  8C46000C   LW A2, 12(V0)
1208:                
1209:                        RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
9D002A34  2408FF00   ADDIU T0, ZERO, -256
9D002A38  00683824   AND A3, V1, T0
9D002A40  34E70001   ORI A3, A3, 1
1210:                
1211:                        /* Is it suspended? If yes, we can't directly send it running */
1212:                        if((Thread->State&RMP_THD_SUSPENDED)==0)
9D002A10  10600017   BEQ V1, ZERO, 0x9D002A70
9D002A14  AC470018   SW A3, 24(V0)
9D002A44  30630100   ANDI V1, V1, 256
9D002A68  1460FFEB   BNE V1, ZERO, 0x9D002A18
9D002A6C  AC470018   SW A3, 24(V0)
1213:                           _RMP_Run_Ins(Thread);
1214:                        
1215:                        Thread->Retval=RMP_ERR_OPER;
9D002A08  0B400A8A   J 0x9D002A28
9D002A0C  2409FFFB   ADDIU T1, ZERO, -5
9D002A18  AC490038   SW T1, 56(V0)
9D002AC8  AC490038   SW T1, 56(V0)
1216:                    }
1217:                    Semaphore->State=RMP_SEM_FREE;
1218:                    
1219:                    RMP_Sched_Unlock();
1220:                
1221:                    return 0;
9D002AFC  00008021   ADDU S0, ZERO, ZERO
1222:                }
9D002B08  02001021   ADDU V0, S0, ZERO
9D002B0C  8FBF0014   LW RA, 20(SP)
9D002B10  8FB00010   LW S0, 16(SP)
9D002B14  03E00008   JR RA
9D002B18  27BD0018   ADDIU SP, SP, 24
9D002B3C  02001021   ADDU V0, S0, ZERO
9D002B40  8FBF0014   LW RA, 20(SP)
9D002B44  8FB00010   LW S0, 16(SP)
9D002B48  03E00008   JR RA
9D002B4C  27BD0018   ADDIU SP, SP, 24
9D002B50  0B400AD4   J 0x9D002B50
9D002B54  00000000   NOP
9D002B84  02001021   ADDU V0, S0, ZERO
9D002B88  8FBF0014   LW RA, 20(SP)
9D002B8C  8FB00010   LW S0, 16(SP)
9D002B90  03E00008   JR RA
9D002B94  27BD0018   ADDIU SP, SP, 24
9D002B9C  02001021   ADDU V0, S0, ZERO
9D002BA0  8FBF0014   LW RA, 20(SP)
9D002BA4  8FB00010   LW S0, 16(SP)
9D002BA8  03E00008   JR RA
9D002BAC  27BD0018   ADDIU SP, SP, 24
9D002BB0  0B400AEC   J 0x9D002BB0
9D002BB4  00000000   NOP
9D002BD8  02001021   ADDU V0, S0, ZERO
9D002BDC  8FBF0014   LW RA, 20(SP)
9D002BE0  8FB00010   LW S0, 16(SP)
9D002BE4  03E00008   JR RA
9D002BE8  27BD0018   ADDIU SP, SP, 24
1223:                /* End Function:RMP_Sem_Del **************************************************/
1224:                
1225:                /* Begin Function:RMP_Sem_Pend ************************************************
1226:                Description : Pend on the semaphore, trying to get one.
1227:                Input       : struct RMP_Sem* Semaphore - The pointer to the semaphore structure.
1228:                              ptr_t Slice - The number of slices to wait.
1229:                Output      : None.
1230:                Return      : ret_t - If successful, the current semaphore number; else error code.
1231:                ******************************************************************************/
1232:                ret_t RMP_Sem_Pend(struct RMP_Sem* Semaphore, ptr_t Slice)
1233:                {
9D002BEC  27BDFFE0   ADDIU SP, SP, -32
9D002BF0  AFBF001C   SW RA, 28(SP)
9D002BF4  AFB10018   SW S1, 24(SP)
9D002BF8  AFB00014   SW S0, 20(SP)
1234:                    /* Check if this semaphore structure could possibly be in use */
1235:                    if(Semaphore==0)
9D002BFC  10800094   BEQ A0, ZERO, 0x9D002E50
9D002C00  00808821   ADDU S1, A0, ZERO
1236:                        return RMP_ERR_SEM;
9D002E50  2410FFFA   ADDIU S0, ZERO, -6
1237:                    
1238:                    RMP_Sched_Lock();
1239:                    
1240:                    if(Semaphore->State!=RMP_SEM_USED)
9D002C10  8C830008   LW V1, 8(A0)
9D002C1C  14620093   BNE V1, V0, .LBB836
9D002C20  00000000   NOP
1241:                    {
1242:                        RMP_Sched_Unlock();
1243:                        return RMP_ERR_SEM;
9D002E8C  2410FFFA   ADDIU S0, ZERO, -6
1244:                    }
1245:                    
1246:                    /* Check if we can get one immediately */
1247:                    if(Semaphore->Cur_Num!=0)
9D002C24  8C90000C   LW S0, 12(A0)
9D002C28  16000033   BNE S0, ZERO, .LBB822
9D002C2C  00000000   NOP
1248:                    {
1249:                        Semaphore->Cur_Num--;
9D002CFC  2610FFFF   ADDIU S0, S0, -1
1250:                        RMP_Sched_Unlock();
1251:                        return Semaphore->Cur_Num;
1252:                    }
1253:                    else
1254:                    {
1255:                        /* Cannot get one, we need to block */
1256:                        if(Slice==0)
9D002C30  10A0009F   BEQ A1, ZERO, .LBB843
9D002C34  00000000   NOP
1257:                        {
1258:                            RMP_Sched_Unlock();
1259:                            return RMP_ERR_OPER;
9D002ED0  2410FFFB   ADDIU S0, ZERO, -5
1260:                        }
1261:                
1262:                        /* We must be running - place into waitlist now */
1263:                        _RMP_Run_Del(RMP_Thd_Cur);
9D002C38  8F828084   LW V0, -32636(GP)
1264:                        RMP_List_Ins(&(RMP_Thd_Cur->Run_Head),Semaphore->Wait_List.Prev,&(Semaphore->Wait_List));
9D002C60  8F828084   LW V0, -32636(GP)
9D002C64  8E230000   LW V1, 0(S1)
1265:                        
1266:                        if(Slice<RMP_SLICE_MAX)
9D002C68  3C060001   LUI A2, 1
9D002C6C  34C686A0   ORI A2, A2, -31072
9D002C70  00A6302B   SLTU A2, A1, A2
9D002C84  14C00039   BNE A2, ZERO, 0x9D002D6C
9D002C88  00000000   NOP
1267:                        {
1268:                            _RMP_Dly_Ins(RMP_Thd_Cur, Slice);
9D002D6C  8F838084   LW V1, -32636(GP)
1269:                            RMP_THD_STATE_SET(RMP_Thd_Cur->State,RMP_THD_SEMDLY);
9D002DBC  8F828084   LW V0, -32636(GP)
9D002DC0  8F838084   LW V1, -32636(GP)
9D002DC4  8C630018   LW V1, 24(V1)
9D002DC8  7C033804   INS V1, ZERO, 0, 8
9D002DCC  34630008   ORI V1, V1, 8
9D002DD0  0B400B29   J 0x9D002CA4
9D002DD4  AC430018   SW V1, 24(V0)
1270:                        }
1271:                        else
1272:                            RMP_THD_STATE_SET(RMP_Thd_Cur->State,RMP_THD_SEMBLK);
9D002C8C  8F828084   LW V0, -32636(GP)
9D002C90  8F838084   LW V1, -32636(GP)
9D002C94  8C630018   LW V1, 24(V1)
9D002C98  7C033804   INS V1, ZERO, 0, 8
9D002C9C  34630007   ORI V1, V1, 7
9D002CA0  AC430018   SW V1, 24(V0)
1273:                        
1274:                        RMP_Thd_Cur->Retval=0;
9D002CA4  8F828084   LW V0, -32636(GP)
9D002CAC  AC400038   SW ZERO, 56(V0)
1275:                    }
1276:                    
1277:                    RMP_Sched_Unlock();
1278:                
1279:                    return RMP_Thd_Cur->Retval;
9D002CD8  8F828084   LW V0, -32636(GP)
9D002CDC  8C500038   LW S0, 56(V0)
1280:                }
9D002CE0  02001021   ADDU V0, S0, ZERO
9D002CE4  8FBF001C   LW RA, 28(SP)
9D002CE8  8FB10018   LW S1, 24(SP)
9D002CEC  8FB00014   LW S0, 20(SP)
9D002CF0  03E00008   JR RA
9D002CF4  27BD0020   ADDIU SP, SP, 32
9D002D24  02001021   ADDU V0, S0, ZERO
9D002D28  8FBF001C   LW RA, 28(SP)
9D002D2C  8FB10018   LW S1, 24(SP)
9D002D30  8FB00014   LW S0, 20(SP)
9D002D34  03E00008   JR RA
9D002D38  27BD0020   ADDIU SP, SP, 32
9D002D3C  0B400B4F   J 0x9D002D3C
9D002D40  00000000   NOP
9D002E38  02001021   ADDU V0, S0, ZERO
9D002E3C  8FBF001C   LW RA, 28(SP)
9D002E40  8FB10018   LW S1, 24(SP)
9D002E44  8FB00014   LW S0, 20(SP)
9D002E48  03E00008   JR RA
9D002E4C  27BD0020   ADDIU SP, SP, 32
9D002E54  02001021   ADDU V0, S0, ZERO
9D002E58  8FBF001C   LW RA, 28(SP)
9D002E5C  8FB10018   LW S1, 24(SP)
9D002E60  8FB00014   LW S0, 20(SP)
9D002E64  03E00008   JR RA
9D002E68  27BD0020   ADDIU SP, SP, 32
9D002E98  02001021   ADDU V0, S0, ZERO
9D002E9C  8FBF001C   LW RA, 28(SP)
9D002EA0  8FB10018   LW S1, 24(SP)
9D002EA4  8FB00014   LW S0, 20(SP)
9D002EA8  03E00008   JR RA
9D002EAC  27BD0020   ADDIU SP, SP, 32
9D002EDC  02001021   ADDU V0, S0, ZERO
9D002EE0  8FBF001C   LW RA, 28(SP)
9D002EE4  8FB10018   LW S1, 24(SP)
9D002EE8  8FB00014   LW S0, 20(SP)
9D002EEC  03E00008   JR RA
9D002EF0  27BD0020   ADDIU SP, SP, 32
9D002EF4  0B400BBD   J 0x9D002EF4
9D002EF8  00000000   NOP
9D002F1C  02001021   ADDU V0, S0, ZERO
9D002F20  8FBF001C   LW RA, 28(SP)
9D002F24  8FB10018   LW S1, 24(SP)
9D002F28  8FB00014   LW S0, 20(SP)
9D002F2C  03E00008   JR RA
9D002F30  27BD0020   ADDIU SP, SP, 32
9D002F34  0B400BCD   J 0x9D002F34
9D002F38  00000000   NOP
9D002F3C  0B400BCF   J 0x9D002F3C
9D002F40  00000000   NOP
9D002F64  02001021   ADDU V0, S0, ZERO
9D002F68  8FBF001C   LW RA, 28(SP)
9D002F6C  8FB10018   LW S1, 24(SP)
9D002F70  8FB00014   LW S0, 20(SP)
9D002F74  03E00008   JR RA
9D002F78  27BD0020   ADDIU SP, SP, 32
1281:                /* End Function:RMP_Sem_Pend *************************************************/
1282:                
1283:                /* Begin Function:RMP_Sem_Abort ***********************************************
1284:                Description : Abort the waiting of one thread on a semaphore.
1285:                Input       : struct RMP_Thd* Thread - The thread structure of the thread.
1286:                Output      : None.
1287:                Return      : ret_t - If successful, 0; else error code.
1288:                ******************************************************************************/
1289:                ret_t RMP_Sem_Abort(struct RMP_Thd* Thread)
1290:                {
9D002F7C  27BDFFE8   ADDIU SP, SP, -24
9D002F80  AFBF0014   SW RA, 20(SP)
1291:                    /* Check if this thread structure could possibly be in use */
1292:                    if(Thread==0)
9D002F84  10800065   BEQ A0, ZERO, 0x9D00311C
9D002F88  AFB00010   SW S0, 16(SP)
1293:                        return RMP_ERR_THD;
9D00311C  2410FFFF   ADDIU S0, ZERO, -1
1294:                
1295:                    RMP_Sched_Lock();
1296:                    
1297:                    if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
9D002F98  8C820018   LW V0, 24(A0)
9D002FA0  304300FF   ANDI V1, V0, 255
9D002FA8  10600072   BEQ V1, ZERO, .LBB909
9D002FAC  2466FFF9   ADDIU A2, V1, -7
1298:                    {
1299:                        RMP_Sched_Unlock();
1300:                        return RMP_ERR_THD;
9D003194  2410FFFF   ADDIU S0, ZERO, -1
1301:                    }
1302:                    
1303:                    /* Is it waiting on a semaphore? If no, we abort and return an error code */
1304:                    if((RMP_THD_STATE(Thread->State)!=RMP_THD_SEMBLK)&&
9D002FB0  2CC60002   SLTIU A2, A2, 2
9D002FB4  10C0005F   BEQ A2, ZERO, .LBB902
9D002FB8  00000000   NOP
1305:                       (RMP_THD_STATE(Thread->State)!=RMP_THD_SEMDLY))
1306:                    {
1307:                        RMP_Sched_Unlock();
1308:                        return RMP_ERR_STATE;
9D003154  2410FFFC   ADDIU S0, ZERO, -4
1309:                    }
1310:                
1311:                    /* Waiting for a semaphore. We abort it and return */
1312:                    RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
9D002FBC  8C850000   LW A1, 0(A0)
9D002FC0  8C860004   LW A2, 4(A0)
1313:                    if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
9D002FCC  24050008   ADDIU A1, ZERO, 8
9D002FD0  10650019   BEQ V1, A1, 0x9D003038
9D002FD4  2405FF00   ADDIU A1, ZERO, -256
1314:                        RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
9D003038  8C830008   LW V1, 8(A0)
9D00303C  8C85000C   LW A1, 12(A0)
1315:                    
1316:                    RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
9D002FD8  00451824   AND V1, V0, A1
9D002FDC  34630001   ORI V1, V1, 1
9D003048  2405FF00   ADDIU A1, ZERO, -256
9D00304C  00451824   AND V1, V0, A1
9D003050  34630001   ORI V1, V1, 1
1317:                
1318:                    /* Only when when this thread is not suspended do we change it back */
1319:                    if((Thread->State&RMP_THD_SUSPENDED)==0)
9D002FE0  30420100   ANDI V0, V0, 256
9D002FE4  1040001E   BEQ V0, ZERO, .LBB894
9D002FE8  AC830018   SW V1, 24(A0)
9D003054  30420100   ANDI V0, V0, 256
9D003058  1440FFE4   BNE V0, ZERO, .LBB882
9D00305C  AC830018   SW V1, 24(A0)
1320:                        _RMP_Run_Ins(Thread);
1321:                    
1322:                    Thread->Retval=RMP_ERR_OPER;
9D002FF0  2402FFFB   ADDIU V0, ZERO, -5
9D002FF4  AC820038   SW V0, 56(A0)
9D0030CC  2402FFFB   ADDIU V0, ZERO, -5
9D0030D0  AC820038   SW V0, 56(A0)
1323:                    
1324:                    RMP_Sched_Unlock();
1325:                
1326:                    return 0;
9D003018  00008021   ADDU S0, ZERO, ZERO
1327:                }
9D003024  02001021   ADDU V0, S0, ZERO
9D003028  8FBF0014   LW RA, 20(SP)
9D00302C  8FB00010   LW S0, 16(SP)
9D003030  03E00008   JR RA
9D003034  27BD0018   ADDIU SP, SP, 24
9D003100  02001021   ADDU V0, S0, ZERO
9D003104  8FBF0014   LW RA, 20(SP)
9D003108  8FB00010   LW S0, 16(SP)
9D00310C  03E00008   JR RA
9D003110  27BD0018   ADDIU SP, SP, 24
9D003114  0B400C45   J 0x9D003114
9D003118  00000000   NOP
9D003120  02001021   ADDU V0, S0, ZERO
9D003124  8FBF0014   LW RA, 20(SP)
9D003128  8FB00010   LW S0, 16(SP)
9D00312C  03E00008   JR RA
9D003130  27BD0018   ADDIU SP, SP, 24
9D003160  02001021   ADDU V0, S0, ZERO
9D003164  8FBF0014   LW RA, 20(SP)
9D003168  8FB00010   LW S0, 16(SP)
9D00316C  03E00008   JR RA
9D003170  27BD0018   ADDIU SP, SP, 24
9D0031A0  02001021   ADDU V0, S0, ZERO
9D0031A4  8FBF0014   LW RA, 20(SP)
9D0031A8  8FB00010   LW S0, 16(SP)
9D0031AC  03E00008   JR RA
9D0031B0  27BD0018   ADDIU SP, SP, 24
9D0031B4  0B400C6D   J 0x9D0031B4
9D0031B8  00000000   NOP
9D0031D0  02001021   ADDU V0, S0, ZERO
9D0031D4  8FBF0014   LW RA, 20(SP)
9D0031D8  8FB00010   LW S0, 16(SP)
9D0031DC  03E00008   JR RA
9D0031E0  27BD0018   ADDIU SP, SP, 24
9D0031E4  0B400C79   J 0x9D0031E4
9D0031E8  00000000   NOP
9D00320C  02001021   ADDU V0, S0, ZERO
9D003210  8FBF0014   LW RA, 20(SP)
9D003214  8FB00010   LW S0, 16(SP)
9D003218  03E00008   JR RA
9D00321C  27BD0018   ADDIU SP, SP, 24
1328:                /* End Function:RMP_Sem_Abort ************************************************/
1329:                
1330:                /* Begin Function:RMP_Sem_Post ************************************************
1331:                Description : Post a number of semaphores to the list. This function can only be
1332:                              called from an ISR whose priority is below or equal to the context
1333:                              switch handler's.
1334:                Input       : struct RMP_Sem* Semaphore - The pointer to the semaphore structure.
1335:                              ptr_t Number - The number to post.
1336:                Output      : None.
1337:                Return      : ret_t - If successful, 0; else error code.
1338:                ******************************************************************************/
1339:                ret_t RMP_Sem_Post(struct RMP_Sem* Semaphore, ptr_t Number)
1340:                {
9D003220  27BDFFE8   ADDIU SP, SP, -24
9D003224  AFBF0014   SW RA, 20(SP)
1341:                    struct RMP_Thd* Thread;
1342:                    
1343:                    /* Check if this semaphore structure could possibly be in use */
1344:                    if((Semaphore==0)||(Number==0))
9D003228  10800073   BEQ A0, ZERO, 0x9D0033F8
9D00322C  AFB00010   SW S0, 16(SP)
9D003230  10A00071   BEQ A1, ZERO, 0x9D0033F8
9D003234  24020001   ADDIU V0, ZERO, 1
1345:                        return RMP_ERR_SEM;
9D0033F8  2410FFFA   ADDIU S0, ZERO, -6
1346:                    
1347:                    RMP_Sched_Lock();
1348:                    
1349:                    if(Semaphore->State!=RMP_SEM_USED)
9D003240  8C860008   LW A2, 8(A0)
9D00324C  14C20080   BNE A2, V0, .LBB971
9D003250  00000000   NOP
1350:                    {
1351:                        RMP_Sched_Unlock();
1352:                        return RMP_ERR_SEM;
9D003470  2410FFFA   ADDIU S0, ZERO, -6
1353:                    }
1354:                    
1355:                    /* Would the maximum value be exceeded if this is posted? */
1356:                    if((Semaphore->Cur_Num+Number)>=RMP_SEM_CNT_MAX)
9D003254  8C83000C   LW V1, 12(A0)
9D003258  00A31821   ADDU V1, A1, V1
9D00325C  2C6203E8   SLTIU V0, V1, 1000
9D003260  1040006B   BEQ V0, ZERO, .LBB964
9D003264  00000000   NOP
1357:                    {
1358:                        RMP_Sched_Unlock();
1359:                        return RMP_ERR_OPER;
9D003430  2410FFFB   ADDIU S0, ZERO, -5
1360:                    }
1361:                    
1362:                    Semaphore->Cur_Num+=Number;
1363:                    /* Is there any thread waiting on it? If there are, clean them up*/
1364:                    while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
9D003268  8C820004   LW V0, 4(A0)
9D00326C  1082003E   BEQ A0, V0, .LBB956
9D003270  AC83000C   SW V1, 12(A0)
9D003274  1060003C   BEQ V1, ZERO, .LBB956
9D003278  00000000   NOP
9D0032A0  8C820004   LW V0, 4(A0)
9D0032A4  1044002F   BEQ V0, A0, 0x9D003364
9D0032A8  2463FFFF   ADDIU V1, V1, -1
9D0032AC  5060003F   BEQL V1, ZERO, 0x9D0033AC
9D0032B0  AC80000C   SW ZERO, 12(A0)
9D003358  8C820004   LW V0, 4(A0)
9D00335C  1444FFD3   BNE V0, A0, 0x9D0032AC
9D003360  2463FFFF   ADDIU V1, V1, -1
9D003364  AC43000C   SW V1, 12(V0)
1365:                    {
1366:                        Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
1367:                        RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
9D0032B8  8C460000   LW A2, 0(V0)
9D0032BC  8C470004   LW A3, 4(V0)
1368:                        if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
9D00327C  240A0008   ADDIU T2, ZERO, 8
9D0032B4  8C450018   LW A1, 24(V0)
9D0032C8  30A900FF   ANDI T1, A1, 255
9D0032DC  152AFFED   BNE T1, T2, 0x9D003294
9D0032E0  00000000   NOP
1369:                            RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
9D0032E4  8C460008   LW A2, 8(V0)
9D0032E8  8C47000C   LW A3, 12(V0)
1370:                        RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
9D0032C0  2409FF00   ADDIU T1, ZERO, -256
9D0032C4  00A94024   AND T0, A1, T1
9D0032CC  35080001   ORI T0, T0, 1
1371:                
1372:                        /* Only when when this thread is not suspended do we change it back */
1373:                        if((Thread->State&RMP_THD_SUSPENDED)==0)
9D003294  10A00019   BEQ A1, ZERO, 0x9D0032FC
9D003298  AC480018   SW T0, 24(V0)
9D0032D0  30A50100   ANDI A1, A1, 256
9D0032F4  14A0FFE9   BNE A1, ZERO, 0x9D00329C
9D0032F8  AC480018   SW T0, 24(V0)
1374:                            _RMP_Run_Ins(Thread);
1375:                
1376:                        /* Finally, return success */
1377:                        Thread->Retval=0;
9D00329C  AC400038   SW ZERO, 56(V0)
9D003354  AC400038   SW ZERO, 56(V0)
1378:                        Semaphore->Cur_Num--;
1379:                    }
1380:                
1381:                    RMP_Sched_Unlock();
1382:                
1383:                    return 0;
9D00338C  00008021   ADDU S0, ZERO, ZERO
1384:                }
9D003398  02001021   ADDU V0, S0, ZERO
9D00339C  8FBF0014   LW RA, 20(SP)
9D0033A0  8FB00010   LW S0, 16(SP)
9D0033A4  03E00008   JR RA
9D0033A8  27BD0018   ADDIU SP, SP, 24
9D0033DC  02001021   ADDU V0, S0, ZERO
9D0033E0  8FBF0014   LW RA, 20(SP)
9D0033E4  8FB00010   LW S0, 16(SP)
9D0033E8  03E00008   JR RA
9D0033EC  27BD0018   ADDIU SP, SP, 24
9D0033F0  0B400CFC   J 0x9D0033F0
9D0033F4  00000000   NOP
9D0033FC  02001021   ADDU V0, S0, ZERO
9D003400  8FBF0014   LW RA, 20(SP)
9D003404  8FB00010   LW S0, 16(SP)
9D003408  03E00008   JR RA
9D00340C  27BD0018   ADDIU SP, SP, 24
9D00343C  02001021   ADDU V0, S0, ZERO
9D003440  8FBF0014   LW RA, 20(SP)
9D003444  8FB00010   LW S0, 16(SP)
9D003448  03E00008   JR RA
9D00344C  27BD0018   ADDIU SP, SP, 24
9D00347C  02001021   ADDU V0, S0, ZERO
9D003480  8FBF0014   LW RA, 20(SP)
9D003484  8FB00010   LW S0, 16(SP)
9D003488  03E00008   JR RA
9D00348C  27BD0018   ADDIU SP, SP, 24
9D003490  0B400D24   J 0x9D003490
9D003494  00000000   NOP
9D0034AC  02001021   ADDU V0, S0, ZERO
9D0034B0  8FBF0014   LW RA, 20(SP)
9D0034B4  8FB00010   LW S0, 16(SP)
9D0034B8  03E00008   JR RA
9D0034BC  27BD0018   ADDIU SP, SP, 24
9D0034C0  0B400D30   J 0x9D0034C0
9D0034C4  00000000   NOP
9D0034E8  02001021   ADDU V0, S0, ZERO
9D0034EC  8FBF0014   LW RA, 20(SP)
9D0034F0  8FB00010   LW S0, 16(SP)
9D0034F4  03E00008   JR RA
9D0034F8  27BD0018   ADDIU SP, SP, 24
1385:                /* End Function:RMP_Sem_Post *************************************************/
1386:                
1387:                /* Begin Function:RMP_Sem_Post_ISR ********************************************
1388:                Description : Post a number of semaphores to the list.
1389:                Input       : struct RMP_Sem* Semaphore - The pointer to the semaphore structure.
1390:                              ptr_t Number - The number to post.
1391:                Output      : None.
1392:                Return      : ret_t - If successful, 0; else error code.
1393:                ******************************************************************************/
1394:                ret_t RMP_Sem_Post_ISR(struct RMP_Sem* Semaphore, ptr_t Number)
1395:                {
9D0034FC  27BDFFD0   ADDIU SP, SP, -48
9D003500  AFBF002C   SW RA, 44(SP)
9D003504  AFB50028   SW S5, 40(SP)
9D003508  AFB40024   SW S4, 36(SP)
9D00350C  AFB30020   SW S3, 32(SP)
9D003510  AFB2001C   SW S2, 28(SP)
9D003514  AFB10018   SW S1, 24(SP)
9D003518  AFB00014   SW S0, 20(SP)
1396:                    struct RMP_Thd* Thread;
1397:                    /* Check if this semaphore structure could possibly be in use */
1398:                    if((Semaphore==0)||(Number==0))
9D00351C  1080005F   BEQ A0, ZERO, .LBE998
9D003520  00808821   ADDU S1, A0, ZERO
9D003524  10A0005D   BEQ A1, ZERO, .LBE998
9D003528  24020001   ADDIU V0, ZERO, 1
1399:                        return RMP_ERR_SEM;
9D00369C  2402FFFA   ADDIU V0, ZERO, -6
1400:                    
1401:                    if(Semaphore->State!=RMP_SEM_USED)
9D00352C  8C830008   LW V1, 8(A0)
9D003530  1462005B   BNE V1, V0, 0x9D0036A0
9D003534  2402FFFA   ADDIU V0, ZERO, -6
1402:                        return RMP_ERR_SEM;
1403:                
1404:                    if(RMP_Sched_Locked!=0)
9D003538  8F82806C   LW V0, -32660(GP)
9D00353C  14400049   BNE V0, ZERO, 0x9D003664
9D003540  2402FFFB   ADDIU V0, ZERO, -5
1405:                        return RMP_ERR_OPER;
1406:                
1407:                    /* Would the maximum value be exceeded if this is posted? */
1408:                    if((Semaphore->Cur_Num+Number)>=RMP_SEM_CNT_MAX)
9D003544  8C82000C   LW V0, 12(A0)
9D003548  00A22821   ADDU A1, A1, V0
9D00354C  2CA203E8   SLTIU V0, A1, 1000
9D003550  50400044   BEQL V0, ZERO, 0x9D003664
9D003554  2402FFFB   ADDIU V0, ZERO, -5
1409:                        return RMP_ERR_OPER;
1410:                    
1411:                    Semaphore->Cur_Num+=Number;
1412:                    /* Is there any thread waiting on it? If there are, clean them up*/
1413:                    while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
9D003558  8C900004   LW S0, 4(A0)
9D00355C  10900040   BEQ A0, S0, 0x9D003660
9D003560  AC85000C   SW A1, 12(A0)
9D003564  10A0003E   BEQ A1, ZERO, 0x9D003660
9D003568  24120008   ADDIU S2, ZERO, 8
9D003588  8E300004   LW S0, 4(S1)
9D003590  12110033   BEQ S0, S1, 0x9D003660
9D003594  AE22000C   SW V0, 12(S1)
9D003598  10400032   BEQ V0, ZERO, 0x9D003664
9D00359C  00001021   ADDU V0, ZERO, ZERO
9D003650  8E300004   LW S0, 4(S1)
9D003658  1611FFCF   BNE S0, S1, 0x9D003598
9D00365C  AE22000C   SW V0, 12(S1)
1414:                    {
1415:                        Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
1416:                        RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
9D0035A4  8E030000   LW V1, 0(S0)
9D0035A8  8E040004   LW A0, 4(S0)
1417:                        if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
9D0035A0  8E020018   LW V0, 24(S0)
9D0035B4  304600FF   ANDI A2, V0, 255
9D0035C8  50D2002F   BEQL A2, S2, 0x9D003688
9D0035CC  8E030008   LW V1, 8(S0)
1418:                            RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
9D003688  8E04000C   LW A0, 12(S0)
1419:                        
1420:                        RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
9D0035AC  2406FF00   ADDIU A2, ZERO, -256
9D0035B0  00462824   AND A1, V0, A2
9D0035B8  34A50001   ORI A1, A1, 1
1421:                
1422:                        /* Only when when this thread is not suspended do we change it back */
1423:                        if((Thread->State&RMP_THD_SUSPENDED)==0)
9D0035BC  30420100   ANDI V0, V0, 256
9D0035D0  1440FFEB   BNE V0, ZERO, 0x9D003580
9D0035D4  AE050018   SW A1, 24(S0)
1424:                        {
1425:                            _RMP_Run_Ins(Thread);
1426:                            if(Thread->Prio>RMP_Thd_Cur->Prio)
9D00362C  8F838084   LW V1, -32636(GP)
9D003630  8C630024   LW V1, 36(V1)
9D003634  0062102B   SLTU V0, V1, V0
9D003638  5040FFD2   BEQL V0, ZERO, 0x9D003584
9D00363C  AE000038   SW ZERO, 56(S0)
1427:                                _RMP_Yield();
9D003640  0F4012F8   JAL _RMP_Yield
9D003644  00000000   NOP
1428:                        }
1429:                
1430:                        /* Finally, return success */
1431:                        Thread->Retval=0;
9D003580  AE000038   SW ZERO, 56(S0)
9D003648  AE000038   SW ZERO, 56(S0)
1432:                        Semaphore->Cur_Num--;
9D003584  8E22000C   LW V0, 12(S1)
9D00358C  2442FFFF   ADDIU V0, V0, -1
9D00364C  8E22000C   LW V0, 12(S1)
9D003654  2442FFFF   ADDIU V0, V0, -1
1433:                    }
1434:                
1435:                    return 0;
9D003660  00001021   ADDU V0, ZERO, ZERO
1436:                }
9D003664  8FBF002C   LW RA, 44(SP)
9D003668  8FB50028   LW S5, 40(SP)
9D00366C  8FB40024   LW S4, 36(SP)
9D003670  8FB30020   LW S3, 32(SP)
9D003674  8FB2001C   LW S2, 28(SP)
9D003678  8FB10018   LW S1, 24(SP)
9D00367C  8FB00014   LW S0, 20(SP)
9D003680  03E00008   JR RA
9D003684  27BD0030   ADDIU SP, SP, 48
9D0036A0  8FBF002C   LW RA, 44(SP)
9D0036A4  8FB50028   LW S5, 40(SP)
9D0036A8  8FB40024   LW S4, 36(SP)
9D0036AC  8FB30020   LW S3, 32(SP)
9D0036B0  8FB2001C   LW S2, 28(SP)
9D0036B4  8FB10018   LW S1, 24(SP)
9D0036B8  8FB00014   LW S0, 20(SP)
9D0036BC  03E00008   JR RA
9D0036C0  27BD0030   ADDIU SP, SP, 48
1437:                /* End Function:RMP_Sem_Post_ISR *********************************************/
1438:                
1439:                /* Begin Function:RMP_Start_Hook **********************************************
1440:                Description : Initialization hook for low-level hardware, executed immediately
1441:                              after the kernel's low-level initialization.
1442:                Input       : None.
1443:                Output      : None.
1444:                Return      : None.
1445:                ******************************************************************************/
1446:                #if(RMP_HOOK_EXTRA==0U)
1447:                void RMP_Start_Hook(void)
1448:                {
9D0036C4  03E00008   JR RA
9D0036C8  00000000   NOP
1449:                    return;
1450:                }
1451:                #endif
1452:                /* End Function:RMP_Start_Hook ***********************************************/
1453:                
1454:                /* Begin Function:RMP_Ctx_Save ************************************************
1455:                Description : Save hook for extra context, such as FPU, peripherals and MPU.
1456:                Input       : None.
1457:                Output      : None.
1458:                Return      : None.
1459:                ******************************************************************************/
1460:                #if(RMP_HOOK_EXTRA==0U)
1461:                void RMP_Ctx_Save(void)
1462:                {
9D0036CC  03E00008   JR RA
9D0036D0  00000000   NOP
1463:                    return;
1464:                }
1465:                #endif
1466:                /* End Function:RMP_Ctx_Save *************************************************/
1467:                
1468:                /* Begin Function:RMP_Ctx_Load ************************************************
1469:                Description : Load hook for extra context, such as FPU, peripherals and MPU.
1470:                Input       : None.
1471:                Output      : None.
1472:                Return      : None.
1473:                ******************************************************************************/
1474:                #if(RMP_HOOK_EXTRA==0U)
1475:                void RMP_Ctx_Load(void)
1476:                {
9D0036D4  03E00008   JR RA
9D0036D8  00000000   NOP
1477:                    return;
1478:                }
1479:                #endif
1480:                /* End Function:RMP_Ctx_Load *************************************************/
1481:                
1482:                /* Begin Function:RMP_Tick_Hook ***********************************************
1483:                Description : Save hook for extra context, such as FPU, peripherals and MPU.
1484:                Input       : ptr_t Ticks - The number of ticks passed. For constant rate ticking
1485:                                            applications this is always 1; For tickless systems this
1486:                                            could be anything.
1487:                Output      : None.
1488:                Return      : None.
1489:                ******************************************************************************/
1490:                #if(RMP_HOOK_EXTRA==0U)
1491:                void RMP_Tick_Hook(ptr_t Ticks)
1492:                {
9D0036DC  03E00008   JR RA
9D0036E0  00000000   NOP
1493:                    Ticks=Ticks;
1494:                    return;
1495:                }
1496:                #endif
1497:                /* End Function:RMP_Tick_Hook ************************************************/
1498:                
1499:                /* Begin Function:RMP_Init ****************************************************
1500:                Description : The entry of the user thread. This is the first user thread that
1501:                              will be created.
1502:                              The user threads should never return.
1503:                Input       : None.
1504:                Output      : None.
1505:                Return      : int - This function never returns.
1506:                ******************************************************************************/
1507:                void RMP_Init(void)
1508:                {
9D000D3C  27BDFFE8   ADDIU SP, SP, -24
9D000D40  AFBF0014   SW RA, 20(SP)
1509:                    RMP_Sched_Lock();
1510:                    
1511:                    /* Platform will use this hook to do something */
1512:                    _RMP_Plat_Hook();
9D000D58  0F4011F0   JAL _RMP_Plat_Hook
9D000D5C  00000000   NOP
1513:                    /* Start the second thread here */
1514:                    RMP_Init_Hook();
9D000D60  0F401012   JAL RMP_Init_Hook
9D000D64  00000000   NOP
1515:                    
1516:                    RMP_Sched_Unlock();
9D000D68  0F400336   JAL .LFB12, .LFE11, RMP_Sched_Unlock
9D000D6C  00000000   NOP
1517:                    
1518:                    while(1)
1519:                    {
1520:                        RMP_Init_Idle();
9D000D70  0F401049   JAL RMP_Init_Idle
9D000D74  00000000   NOP
9D000D78  0F401049   JAL RMP_Init_Idle
9D000D7C  00000000   NOP
9D000D80  0B40035C   J .LVL89
9D000D84  00000000   NOP
1521:                    };
1522:                }
1523:                /* End Function:RMP_Init *****************************************************/
1524:                
1525:                /* Begin Function:main ********************************************************
1526:                Description : The entrance of the operating system. This function is for 
1527:                              compatibility with the ARM toolchain.
1528:                Input       : None.
1529:                Output      : None.
1530:                Return      : int - This function never returns.
1531:                ******************************************************************************/
1532:                int main(void)
1533:                {
9D0036E4  27BDFFD8   ADDIU SP, SP, -40
9D0036E8  AFBF0024   SW RA, 36(SP)
9D0036EC  AFB30020   SW S3, 32(SP)
9D0036F0  AFB2001C   SW S2, 28(SP)
9D0036F4  AFB10018   SW S1, 24(SP)
9D0036F8  AFB00014   SW S0, 20(SP)
1534:                    ptr_t Count;
1535:                    /* Initialize the kernel data structures first */
1536:                    _RMP_Low_Level_Init();
9D0036FC  0F4011B1   JAL _RMP_Low_Level_Init
9D003700  3C128000   LUI S2, -32768
9D003704  26511CD0   ADDIU S1, S2, 7376
1537:                    
1538:                #if(RMP_HOOK_EXTRA==1U)
1539:                    RMP_Start_Hook();
1540:                #endif
1541:                    
1542:                    RMP_Tick=0;
9D00370C  AF808074   SW ZERO, -32652(GP)
9D003710  02201021   ADDU V0, S1, ZERO
1543:                    /* Now initialize the kernel data structures */
1544:                    RMP_Sched_Lock_Cnt=0;
9D003714  AF808070   SW ZERO, -32656(GP)
9D003718  26230100   ADDIU V1, S1, 256
1545:                    RMP_Sched_Locked=0;
9D00371C  AF80806C   SW ZERO, -32660(GP)
1546:                    RMP_Sched_Pend=0;
9D003720  AF808068   SW ZERO, -32664(GP)
1547:                    RMP_Timer_Pend=0;
9D003724  AF808064   SW ZERO, -32668(GP)
1548:                    
1549:                    /* Linked lists */
1550:                    RMP_List_Crt(&RMP_Delay);
1551:                    for(Count=0;Count<RMP_PREEMPT_PRIO_NUM;Count++)
9D00373C  1443FFFC   BNE V0, V1, .LBB1004
9D003740  3C138000   LUI S3, -32768
9D003744  26701494   ADDIU S0, S3, 5268
9D003748  02002021   ADDU A0, S0, ZERO
9D00374C  00002821   ADDU A1, ZERO, ZERO
9D003750  2406003C   ADDIU A2, ZERO, 60
1552:                        RMP_List_Crt(&RMP_Run[Count]);
1553:                    for(Count=0;Count<RMP_BITMAP_SIZE;Count++)
1554:                        RMP_Bitmap[Count]=0;
9D003754  AF808080   SW ZERO, -32640(GP)
9D003758  0F401295   JAL memset
9D00375C  00000000   NOP
1555:                        
1556:                    /* Now boot into the first thread */
1557:                    RMP_Clear(&RMP_Init_Thd,sizeof(struct RMP_Thd));
1558:                    RMP_Init_Thd.Prio=0;
9D00376C  AE000024   SW ZERO, 36(S0)
1559:                    RMP_Init_Thd.Slice=10;
9D003768  2403000A   ADDIU V1, ZERO, 10
9D003770  AE03001C   SW V1, 28(S0)
1560:                    RMP_Init_Thd.Slice_Left=10;
9D003774  AE030020   SW V1, 32(S0)
1561:                    RMP_Init_Thd.State=RMP_THD_RUNNING;
9D003778  24030001   ADDIU V1, ZERO, 1
9D00377C  AE030018   SW V1, 24(S0)
1562:                    RMP_Init_Thd.Stack=RMP_INIT_STACK;
9D003780  3C038000   LUI V1, -32768
9D003784  24631BD0   ADDIU V1, V1, 7120
9D003788  AE030034   SW V1, 52(S0)
1563:                    
1564:                    /* Initialize sending list */
1565:                    RMP_List_Crt(&(RMP_Init_Thd.Snd_List));
1566:                    
1567:                    /* Insert this into the corresponding runqueue */
1568:                    RMP_List_Ins(&(RMP_Init_Thd.Run_Head),RMP_Run[0].Prev,&(RMP_Run[0]));
9D003794  8E421CD0   LW V0, 7376(S2)
1569:                    /* Set this runlevel as active - in fact it is always active */
1570:                    RMP_Bitmap[0]|=1;
9D0037A8  8F828080   LW V0, -32640(GP)
9D0037B4  34420001   ORI V0, V0, 1
9D0037B8  AF828080   SW V0, -32640(GP)
1571:                    
1572:                    /* Set current thread and stack */
1573:                    RMP_Thd_Cur=&RMP_Init_Thd;
9D0037BC  AF908084   SW S0, -32636(GP)
1574:                    RMP_SP_Cur=RMP_Init_Thd.Stack;
9D0037C0  8E020034   LW V0, 52(S0)
9D0037C4  AF828088   SW V0, -32632(GP)
1575:                    
1576:                    /* Now jump to the user function and will never return. Initialization of stack is not needed */
1577:                    _RMP_Start((ptr_t)RMP_Init, (ptr_t)RMP_Init_Thd.Stack);
9D0037AC  3C049D00   LUI A0, -25344
9D0037B0  24840D3C   ADDIU A0, A0, 3388
9D0037C8  8E050034   LW A1, 52(S0)
9D0037CC  0F4012FD   JAL _RMP_Start
9D0037D0  00000000   NOP
1578:                    
1579:                    return 0;
1580:                }
9D0037D4  00001021   ADDU V0, ZERO, ZERO
1581:                /* End Function:main *********************************************************/
1582:                
1583:                /* End Of File ***************************************************************/
1584:                
1585:                /* Copyright (C) Evo-Devo Instrum. All rights reserved ***********************/
---  f:/code_library/mcu/mutatus/m5p1_muprokaron/mprokaron/benchmark/test.c  ----------------------------
1:                   /******************************************************************************
2:                   Filename    : test.c
3:                   Author      : pry 
4:                   Date        : 22/07/2017
5:                   Licence     : LGPL v3+; see COPYING for details.
6:                   Description : The performance testbench for RMP. Do not modify this file; what
7:                                 you need to modify is the test chip header and the platform chip
8:                                 header.
9:                   ******************************************************************************/
10:                  
11:                  /* Includes ******************************************************************/
12:                  #include "test.h"
13:                  /* End Includes **************************************************************/
14:                  
15:                  /* Globals *******************************************************************/
16:                  #ifndef MINIMAL_SIZE
17:                  volatile tim_t Start=0;
18:                  volatile tim_t End=0;
19:                  volatile ptr_t Total=0;
20:                  volatile ptr_t Temp=0;
21:                  /* Test results also written here */
22:                  volatile ptr_t Yield_Time=0;
23:                  volatile ptr_t Mailbox_Time=0;
24:                  volatile ptr_t Semaphore_Time=0;
25:                  volatile ptr_t Mailbox_ISR_Time=0;
26:                  volatile ptr_t Semaphore_ISR_Time=0;
27:                  /* Kernel objects */
28:                  volatile struct RMP_Thd Thd_1;
29:                  volatile struct RMP_Thd Thd_2;
30:                  volatile struct RMP_Sem Sem_1;
31:                  /* End Globals ***************************************************************/
32:                  
33:                  /* Begin Function:Func_1 ******************************************************
34:                  Description : The test function group 1.
35:                  Input       : None.
36:                  Output      : None.
37:                  Return      : None.
38:                  ******************************************************************************/
39:                  void Test_Yield_1(void)
40:                  {
9D003980  27BDFFE0   ADDIU SP, SP, -32
9D003984  AFBF001C   SW RA, 28(SP)
9D003988  AFB10018   SW S1, 24(SP)
9D00398C  AFB00014   SW S0, 20(SP)
9D003990  24102710   ADDIU S0, ZERO, 10000
9D003994  3C11BF84   LUI S1, -16508
41:                      cnt_t Count;
42:                      for(Count=0;Count<10000;Count++)
9D0039B8  1600FFF7   BNE S0, ZERO, 0x9D003998
9D0039BC  8FBF001C   LW RA, 28(SP)
43:                      {
44:                          /* Read counter here */
45:                          Start=RMP_CNT_READ();
9D003998  8E220010   LW V0, 16(S1)
9D00399C  2610FFFF   ADDIU S0, S0, -1
9D0039A0  00021880   SLL V1, V0, 2
9D0039A4  00431021   ADDU V0, V0, V1
9D0039A8  3042FFFF   ANDI V0, V0, -1
9D0039AC  A7828062   SH V0, -32670(GP)
46:                          RMP_Yield();
9D0039B0  0F400362   JAL RMP_Yield
9D0039B4  00000000   NOP
47:                      }
48:                  }
9D0039C0  8FB10018   LW S1, 24(SP)
9D0039C4  8FB00014   LW S0, 20(SP)
9D0039C8  03E00008   JR RA
9D0039CC  27BD0020   ADDIU SP, SP, 32
49:                  
50:                  void Test_Mail_1(void)
51:                  {
9D0039D0  27BDFFE0   ADDIU SP, SP, -32
9D0039D4  AFBF001C   SW RA, 28(SP)
9D0039D8  AFB20018   SW S2, 24(SP)
9D0039DC  AFB10014   SW S1, 20(SP)
9D0039E0  AFB00010   SW S0, 16(SP)
52:                      static cnt_t Count;
53:                      for(Count=0;Count<10000;Count++)
9D0039E4  AF808040   SW ZERO, -32704(GP)
9D0039E8  3C12BF84   LUI S2, -16508
9D003A24  8F828040   LW V0, -32704(GP)
9D003A28  24420001   ADDIU V0, V0, 1
9D003A2C  28432710   SLTI V1, V0, 10000
9D003A30  1460FFF2   BNE V1, ZERO, 0x9D0039FC
9D003A34  AF828040   SW V0, -32704(GP)
54:                      {
55:                          /* Read counter here */
56:                          Start=RMP_CNT_READ();
9D0039FC  8E420010   LW V0, 16(S2)
9D003A08  00021880   SLL V1, V0, 2
9D003A0C  00431021   ADDU V0, V0, V1
9D003A10  3042FFFF   ANDI V0, V0, -1
9D003A18  A7828062   SH V0, -32670(GP)
57:                          RMP_Thd_Snd(&Thd_2, 1, RMP_SLICE_MAX);
9D0039EC  3C118000   LUI S1, -32768
9D0039F0  26311448   ADDIU S1, S1, 5192
9D0039F4  3C100001   LUI S0, 1
9D0039F8  361086A0   ORI S0, S0, -31072
9D003A00  02202021   ADDU A0, S1, ZERO
9D003A04  24050001   ADDIU A1, ZERO, 1
9D003A14  02003021   ADDU A2, S0, ZERO
9D003A1C  0F4006C5   JAL RMP_Thd_Snd
9D003A20  00000000   NOP
58:                      }
59:                  }
9D003A38  8FBF001C   LW RA, 28(SP)
9D003A3C  8FB20018   LW S2, 24(SP)
9D003A40  8FB10014   LW S1, 20(SP)
9D003A44  8FB00010   LW S0, 16(SP)
9D003A48  03E00008   JR RA
9D003A4C  27BD0020   ADDIU SP, SP, 32
60:                  
61:                  void Test_Sem_1(void)
62:                  {
9D003A50  27BDFFE0   ADDIU SP, SP, -32
9D003A54  AFBF001C   SW RA, 28(SP)
9D003A58  AFB20018   SW S2, 24(SP)
9D003A5C  AFB10014   SW S1, 20(SP)
9D003A60  AFB00010   SW S0, 16(SP)
9D003A64  24102710   ADDIU S0, ZERO, 10000
9D003A68  3C12BF84   LUI S2, -16508
63:                      cnt_t Count;
64:                      for(Count=0;Count<10000;Count++)
9D003A9C  1600FFF5   BNE S0, ZERO, 0x9D003A74
9D003AA0  8FBF001C   LW RA, 28(SP)
65:                      {
66:                          /* Read counter here */
67:                          Start=RMP_CNT_READ();
9D003A74  8E420010   LW V0, 16(S2)
9D003A80  00021880   SLL V1, V0, 2
9D003A84  00431021   ADDU V0, V0, V1
9D003A88  3042FFFF   ANDI V0, V0, -1
9D003A8C  2610FFFF   ADDIU S0, S0, -1
9D003A90  A7828062   SH V0, -32670(GP)
68:                          RMP_Sem_Post(&Sem_1, 1);
9D003A6C  3C118000   LUI S1, -32768
9D003A70  26311484   ADDIU S1, S1, 5252
9D003A78  02202021   ADDU A0, S1, ZERO
9D003A7C  24050001   ADDIU A1, ZERO, 1
9D003A94  0F400C88   JAL RMP_Sem_Post
9D003A98  00000000   NOP
69:                      }
70:                  }
9D003AA4  8FB20018   LW S2, 24(SP)
9D003AA8  8FB10014   LW S1, 20(SP)
9D003AAC  8FB00010   LW S0, 16(SP)
9D003AB0  03E00008   JR RA
9D003AB4  27BD0020   ADDIU SP, SP, 32
71:                  
72:                  void Func_1(void)
73:                  {
9D003AB8  27BDFFE8   ADDIU SP, SP, -24
9D003ABC  AFBF0014   SW RA, 20(SP)
74:                      Test_Yield_1();
9D003AC0  0F400E60   JAL Test_Yield_1
9D003AC4  00000000   NOP
75:                      /* Change priority of thread 2 */
76:                      RMP_Thd_Set(&Thd_2,2,RMP_SLICE_MAX);
9D003AC8  3C048000   LUI A0, -32768
9D003ACC  24841448   ADDIU A0, A0, 5192
9D003AD0  24050002   ADDIU A1, ZERO, 2
9D003AD4  3C060001   LUI A2, 1
9D003AD8  0F400534   JAL RMP_Thd_Set
9D003ADC  34C686A0   ORI A2, A2, -31072
77:                      Test_Mail_1();
9D003AE0  0F400E74   JAL Test_Mail_1
9D003AE4  00000000   NOP
78:                      Test_Sem_1();
9D003AE8  0F400E94   JAL Test_Sem_1
9D003AEC  00000000   NOP
9D003AF0  0B400EBC   J .LVL18
9D003AF4  00000000   NOP
79:                      while(1);
80:                  }
81:                  /* End Function:Test_Yield ***************************************************/
82:                  
83:                  /* Begin Function:Func_2 ******************************************************
84:                  Description : The test function group 2.
85:                  Input       : None.
86:                  Output      : None.
87:                  Return      : None.
88:                  ******************************************************************************/
89:                  void Test_Yield_2(void)
90:                  {
9D003AF8  27BDFFE0   ADDIU SP, SP, -32
9D003AFC  AFBF001C   SW RA, 28(SP)
9D003B00  AFB10018   SW S1, 24(SP)
9D003B04  AFB00014   SW S0, 20(SP)
9D003B08  24102710   ADDIU S0, ZERO, 10000
9D003B0C  3C11BF84   LUI S1, -16508
91:                      cnt_t Count;
92:                      for(Count=0;Count<10000;Count++)
9D003B4C  1600FFF0   BNE S0, ZERO, 0x9D003B10
9D003B50  8FBF001C   LW RA, 28(SP)
93:                      {
94:                          RMP_Yield();
9D003B10  0F400362   JAL RMP_Yield
9D003B14  00000000   NOP
95:                          /* Read counter here */
96:                          End=RMP_CNT_READ();
9D003B18  8E220010   LW V0, 16(S1)
9D003B1C  2610FFFF   ADDIU S0, S0, -1
9D003B20  00021880   SLL V1, V0, 2
9D003B24  00431021   ADDU V0, V0, V1
9D003B28  3042FFFF   ANDI V0, V0, -1
9D003B2C  A7828060   SH V0, -32672(GP)
97:                          Total+=(tim_t)(End-Start);
9D003B30  97848060   LHU A0, -32672(GP)
9D003B34  97828062   LHU V0, -32670(GP)
9D003B38  8F83805C   LW V1, -32676(GP)
9D003B3C  00821023   SUBU V0, A0, V0
9D003B40  3042FFFF   ANDI V0, V0, -1
9D003B44  00431021   ADDU V0, V0, V1
9D003B48  AF82805C   SW V0, -32676(GP)
98:                      };
99:                  }
9D003B54  8FB10018   LW S1, 24(SP)
9D003B58  8FB00014   LW S0, 20(SP)
9D003B5C  03E00008   JR RA
9D003B60  27BD0020   ADDIU SP, SP, 32
100:                 
101:                 void Test_Mail_2(void)
102:                 {
9D003B64  27BDFFD8   ADDIU SP, SP, -40
9D003B68  AFBF0024   SW RA, 36(SP)
9D003B6C  AFB20020   SW S2, 32(SP)
9D003B70  AFB1001C   SW S1, 28(SP)
9D003B74  AFB00018   SW S0, 24(SP)
9D003B78  24102710   ADDIU S0, ZERO, 10000
9D003B7C  3C12BF84   LUI S2, -16508
103:                     ptr_t Data;
104:                     cnt_t Count;
105:                     for(Count=0;Count<10000;Count++)
9D003BC8  5600FFF0   BNEL S0, ZERO, 0x9D003B8C
9D003BCC  27A40010   ADDIU A0, SP, 16
106:                     {
107:                         RMP_Thd_Rcv(&Data, RMP_SLICE_MAX);
9D003B80  3C110001   LUI S1, 1
9D003B84  363186A0   ORI S1, S1, -31072
9D003B88  27A40010   ADDIU A0, SP, 16
9D003B8C  0F400808   JAL RMP_Thd_Rcv
9D003B90  02202821   ADDU A1, S1, ZERO
108:                         /* Read counter here */
109:                         End=RMP_CNT_READ();
9D003B94  8E420010   LW V0, 16(S2)
9D003B98  2610FFFF   ADDIU S0, S0, -1
9D003B9C  00021880   SLL V1, V0, 2
9D003BA0  00431021   ADDU V0, V0, V1
9D003BA4  3042FFFF   ANDI V0, V0, -1
9D003BA8  A7828060   SH V0, -32672(GP)
110:                         Total+=(tim_t)(End-Start);
9D003BAC  97848060   LHU A0, -32672(GP)
9D003BB0  97828062   LHU V0, -32670(GP)
9D003BB4  8F83805C   LW V1, -32676(GP)
9D003BB8  00821023   SUBU V0, A0, V0
9D003BBC  3042FFFF   ANDI V0, V0, -1
9D003BC0  00431021   ADDU V0, V0, V1
9D003BC4  AF82805C   SW V0, -32676(GP)
111:                     };
112:                 }
9D003BD0  8FBF0024   LW RA, 36(SP)
9D003BD4  8FB20020   LW S2, 32(SP)
9D003BD8  8FB1001C   LW S1, 28(SP)
9D003BDC  8FB00018   LW S0, 24(SP)
9D003BE0  03E00008   JR RA
9D003BE4  27BD0028   ADDIU SP, SP, 40
113:                 
114:                 void Test_Sem_2(void)
115:                 {
9D003BE8  27BDFFD8   ADDIU SP, SP, -40
9D003BEC  AFBF0024   SW RA, 36(SP)
9D003BF0  AFB30020   SW S3, 32(SP)
9D003BF4  AFB2001C   SW S2, 28(SP)
9D003BF8  AFB10018   SW S1, 24(SP)
9D003BFC  AFB00014   SW S0, 20(SP)
9D003C00  24102710   ADDIU S0, ZERO, 10000
9D003C04  3C13BF84   LUI S3, -16508
116:                     cnt_t Count;
117:                     for(Count=0;Count<10000;Count++)
9D003C58  5600FFF0   BNEL S0, ZERO, 0x9D003C1C
9D003C5C  02402021   ADDU A0, S2, ZERO
118:                     {
119:                         RMP_Sem_Pend(&Sem_1, RMP_SLICE_MAX);
9D003C08  3C128000   LUI S2, -32768
9D003C0C  26521484   ADDIU S2, S2, 5252
9D003C10  3C110001   LUI S1, 1
9D003C14  363186A0   ORI S1, S1, -31072
9D003C18  02402021   ADDU A0, S2, ZERO
9D003C1C  0F400AFB   JAL RMP_Sem_Pend
9D003C20  02202821   ADDU A1, S1, ZERO
120:                         /* Read counter here */
121:                         End=RMP_CNT_READ();
9D003C24  8E620010   LW V0, 16(S3)
9D003C28  2610FFFF   ADDIU S0, S0, -1
9D003C2C  00021880   SLL V1, V0, 2
9D003C30  00431021   ADDU V0, V0, V1
9D003C34  3042FFFF   ANDI V0, V0, -1
9D003C38  A7828060   SH V0, -32672(GP)
122:                         Total+=(tim_t)(End-Start);
9D003C3C  97848060   LHU A0, -32672(GP)
9D003C40  97828062   LHU V0, -32670(GP)
9D003C44  8F83805C   LW V1, -32676(GP)
9D003C48  00821023   SUBU V0, A0, V0
9D003C4C  3042FFFF   ANDI V0, V0, -1
9D003C50  00431021   ADDU V0, V0, V1
9D003C54  AF82805C   SW V0, -32676(GP)
123:                     };
124:                 }
9D003C60  8FBF0024   LW RA, 36(SP)
9D003C64  8FB30020   LW S3, 32(SP)
9D003C68  8FB2001C   LW S2, 28(SP)
9D003C6C  8FB10018   LW S1, 24(SP)
9D003C70  8FB00014   LW S0, 20(SP)
9D003C74  03E00008   JR RA
9D003C78  27BD0028   ADDIU SP, SP, 40
125:                 
126:                 void Test_Mail_ISR(void)
127:                 {
9D003C7C  27BDFFD8   ADDIU SP, SP, -40
9D003C80  AFBF0024   SW RA, 36(SP)
9D003C84  AFB10020   SW S1, 32(SP)
9D003C88  AFB0001C   SW S0, 28(SP)
128:                     ptr_t Data;
129:                     static cnt_t Count;
130:                     for(Count=0;Count<10000;Count++)
9D003C8C  AF80803C   SW ZERO, -32708(GP)
9D003C90  3C11BF84   LUI S1, -16508
9D003CC8  8F82803C   LW V0, -32708(GP)
9D003CCC  24420001   ADDIU V0, V0, 1
9D003CDC  28432710   SLTI V1, V0, 10000
9D003CE4  1460FFED   BNE V1, ZERO, 0x9D003C9C
9D003CE8  AF82803C   SW V0, -32708(GP)
131:                     {
132:                         RMP_Thd_Rcv(&Data, RMP_SLICE_MAX);
9D003C94  3C100001   LUI S0, 1
9D003C98  361086A0   ORI S0, S0, -31072
9D003C9C  27A40010   ADDIU A0, SP, 16
9D003CA0  0F400808   JAL RMP_Thd_Rcv
9D003CA4  02002821   ADDU A1, S0, ZERO
133:                         /* Read counter here */
134:                         End=RMP_CNT_READ();
9D003CA8  8E220010   LW V0, 16(S1)
9D003CAC  00021880   SLL V1, V0, 2
9D003CB0  00431021   ADDU V0, V0, V1
9D003CB4  3042FFFF   ANDI V0, V0, -1
9D003CB8  A7828060   SH V0, -32672(GP)
135:                         Total+=(tim_t)(End-Start);
9D003CBC  97858060   LHU A1, -32672(GP)
9D003CC0  97848062   LHU A0, -32670(GP)
9D003CC4  8F83805C   LW V1, -32676(GP)
9D003CD0  00A42023   SUBU A0, A1, A0
9D003CD4  3084FFFF   ANDI A0, A0, -1
9D003CD8  00832021   ADDU A0, A0, V1
9D003CE0  AF84805C   SW A0, -32676(GP)
136:                     };
137:                 }
9D003CEC  8FBF0024   LW RA, 36(SP)
9D003CF0  8FB10020   LW S1, 32(SP)
9D003CF4  8FB0001C   LW S0, 28(SP)
9D003CF8  03E00008   JR RA
9D003CFC  27BD0028   ADDIU SP, SP, 40
138:                 
139:                 void Test_Sem_ISR(void)
140:                 {
9D003D00  27BDFFE0   ADDIU SP, SP, -32
9D003D04  AFBF001C   SW RA, 28(SP)
9D003D08  AFB20018   SW S2, 24(SP)
9D003D0C  AFB10014   SW S1, 20(SP)
9D003D10  AFB00010   SW S0, 16(SP)
141:                     static cnt_t Count;
142:                     for(Count=0;Count<10000;Count++)
9D003D14  AF808038   SW ZERO, -32712(GP)
9D003D18  3C12BF84   LUI S2, -16508
9D003D58  8F828038   LW V0, -32712(GP)
9D003D5C  24420001   ADDIU V0, V0, 1
9D003D6C  28432710   SLTI V1, V0, 10000
9D003D74  1460FFED   BNE V1, ZERO, 0x9D003D2C
9D003D78  AF828038   SW V0, -32712(GP)
143:                     {
144:                         RMP_Sem_Pend(&Sem_1, RMP_SLICE_MAX);
9D003D1C  3C118000   LUI S1, -32768
9D003D20  26311484   ADDIU S1, S1, 5252
9D003D24  3C100001   LUI S0, 1
9D003D28  361086A0   ORI S0, S0, -31072
9D003D2C  02202021   ADDU A0, S1, ZERO
9D003D30  0F400AFB   JAL RMP_Sem_Pend
9D003D34  02002821   ADDU A1, S0, ZERO
145:                         /* Read counter here */
146:                         End=RMP_CNT_READ();
9D003D38  8E420010   LW V0, 16(S2)
9D003D3C  00021880   SLL V1, V0, 2
9D003D40  00431021   ADDU V0, V0, V1
9D003D44  3042FFFF   ANDI V0, V0, -1
9D003D48  A7828060   SH V0, -32672(GP)
147:                         Total+=(tim_t)(End-Start);
9D003D4C  97868060   LHU A2, -32672(GP)
9D003D50  97848062   LHU A0, -32670(GP)
9D003D54  8F83805C   LW V1, -32676(GP)
9D003D60  00C43023   SUBU A2, A2, A0
9D003D64  30C6FFFF   ANDI A2, A2, -1
9D003D68  00C33021   ADDU A2, A2, V1
9D003D70  AF86805C   SW A2, -32676(GP)
148:                     };
149:                 }
9D003D7C  8FBF001C   LW RA, 28(SP)
9D003D80  8FB20018   LW S2, 24(SP)
9D003D84  8FB10014   LW S1, 20(SP)
9D003D88  8FB00010   LW S0, 16(SP)
9D003D8C  03E00008   JR RA
9D003D90  27BD0020   ADDIU SP, SP, 32
150:                 
151:                 void Func_2(void)
152:                 {
9D003D94  27BDFFE0   ADDIU SP, SP, -32
9D003D98  AFBF001C   SW RA, 28(SP)
9D003D9C  AFB10018   SW S1, 24(SP)
9D003DA0  AFB00014   SW S0, 20(SP)
153:                     /* Yield tests */
154:                     Total=0;
9D003DA4  AF80805C   SW ZERO, -32676(GP)
155:                     Test_Yield_2();
9D003DA8  0F400EBE   JAL Test_Yield_2
9D003DAC  00000000   NOP
156:                     RMP_LOG_S("Yield: ");
9D003DB0  3C049D00   LUI A0, -25344
9D003DB4  0F400309   JAL RMP_Str_Print
9D003DB8  24844B50   ADDIU A0, A0, 19280
157:                     
158:                     Yield_Time=Total/10000;
9D003DBC  8F82805C   LW V0, -32676(GP)
9D003DC0  3C11D1B7   LUI S1, -11849
9D003DC4  26311759   ADDIU S1, S1, 5977
9D003DC8  00510019   MULTU 0, V0, S1
9D003DCC  00001010   MFHI V0
9D003DD4  00021342   SRL V0, V0, 13
9D003DD8  AF828054   SW V0, -32684(GP)
159:                     RMP_LOG_I(Yield_Time);
9D003DDC  8F848054   LW A0, -32684(GP)
9D003DE0  0F40026D   JAL RMP_Int_Print
9D003DE4  00000000   NOP
160:                     RMP_LOG_S(" cycles.\r\n");
9D003DD0  3C109D00   LUI S0, -25344
9D003DE8  0F400309   JAL RMP_Str_Print
9D003DEC  26044B58   ADDIU A0, S0, 19288
161:                     /* Change priority of thread 2, just in case */
162:                     RMP_Thd_Set(&Thd_2,2,RMP_SLICE_MAX);
9D003DF0  24050002   ADDIU A1, ZERO, 2
9D003DF4  3C060001   LUI A2, 1
9D003DF8  34C686A0   ORI A2, A2, -31072
9D003DFC  3C048000   LUI A0, -32768
9D003E00  0F400534   JAL RMP_Thd_Set
9D003E04  24841448   ADDIU A0, A0, 5192
163:                     
164:                     /* Mailbox tests */
165:                     Total=0;
9D003E08  AF80805C   SW ZERO, -32676(GP)
166:                     Test_Mail_2();
9D003E0C  0F400ED9   JAL Test_Mail_2
9D003E10  00000000   NOP
167:                     RMP_LOG_S("Mailbox: ");
9D003E14  3C049D00   LUI A0, -25344
9D003E18  0F400309   JAL RMP_Str_Print
9D003E1C  24844B64   ADDIU A0, A0, 19300
168:                     Mailbox_Time=Total/10000;
9D003E20  8F82805C   LW V0, -32676(GP)
9D003E24  00510019   MULTU 0, V0, S1
9D003E28  00001010   MFHI V0
9D003E2C  00021342   SRL V0, V0, 13
9D003E30  AF828050   SW V0, -32688(GP)
169:                     RMP_LOG_I(Mailbox_Time);
9D003E34  8F848050   LW A0, -32688(GP)
9D003E38  0F40026D   JAL RMP_Int_Print
9D003E3C  00000000   NOP
170:                     RMP_LOG_S(" cycles.\r\n");
9D003E40  0F400309   JAL RMP_Str_Print
9D003E44  26044B58   ADDIU A0, S0, 19288
171:                     
172:                     /* Semaphore tests */
173:                     Total=0;
9D003E48  AF80805C   SW ZERO, -32676(GP)
174:                     Test_Sem_2();
9D003E4C  0F400EFA   JAL Test_Sem_2
9D003E50  00000000   NOP
175:                     RMP_LOG_S("Semaphore: ");
9D003E54  3C049D00   LUI A0, -25344
9D003E58  0F400309   JAL RMP_Str_Print
9D003E5C  24844B70   ADDIU A0, A0, 19312
176:                     Semaphore_Time=Total/10000;
9D003E60  8F82805C   LW V0, -32676(GP)
9D003E64  00510019   MULTU 0, V0, S1
9D003E68  00001010   MFHI V0
9D003E6C  00021342   SRL V0, V0, 13
9D003E70  AF82804C   SW V0, -32692(GP)
177:                     RMP_LOG_I(Semaphore_Time);
9D003E74  8F84804C   LW A0, -32692(GP)
9D003E78  0F40026D   JAL RMP_Int_Print
9D003E7C  00000000   NOP
178:                     RMP_LOG_S(" cycles.\r\n");
9D003E80  0F400309   JAL RMP_Str_Print
9D003E84  26044B58   ADDIU A0, S0, 19288
179:                     
180:                     /* Mailbox from interrupt tests */
181:                     Total=0;
9D003E94  AF80805C   SW ZERO, -32676(GP)
182:                     Int_Init();
183:                     Test_Mail_ISR();
9D003EC0  0F400F1F   JAL Test_Mail_ISR
9D003EC4  00000000   NOP
184:                     
185:                     /* Semaphore from interrupt tests */
186:                     Temp=Total;
9D003EC8  8F82805C   LW V0, -32676(GP)
9D003ECC  AF828058   SW V0, -32680(GP)
187:                     Total=0;
9D003ED0  AF80805C   SW ZERO, -32676(GP)
188:                     Test_Sem_ISR();
9D003ED4  0F400F40   JAL Test_Sem_ISR
9D003ED8  00000000   NOP
189:                     
190:                     RMP_LOG_S("Mailbox-ISR: ");
9D003EDC  3C049D00   LUI A0, -25344
9D003EE0  0F400309   JAL RMP_Str_Print
9D003EE4  24844B7C   ADDIU A0, A0, 19324
191:                     Mailbox_ISR_Time=Temp/10000;
9D003EE8  8F828058   LW V0, -32680(GP)
9D003EEC  00510019   MULTU 0, V0, S1
9D003EF0  00001010   MFHI V0
9D003EF4  00021342   SRL V0, V0, 13
9D003EF8  AF828048   SW V0, -32696(GP)
192:                     RMP_LOG_I(Mailbox_ISR_Time);
9D003EFC  8F848048   LW A0, -32696(GP)
9D003F00  0F40026D   JAL RMP_Int_Print
9D003F04  00000000   NOP
193:                     RMP_LOG_S(" cycles.\r\n");
9D003F08  0F400309   JAL RMP_Str_Print
9D003F0C  26044B58   ADDIU A0, S0, 19288
194:                     RMP_LOG_S("Semaphore-ISR: ");
9D003F10  3C049D00   LUI A0, -25344
9D003F14  0F400309   JAL RMP_Str_Print
9D003F18  24844B8C   ADDIU A0, A0, 19340
195:                     Semaphore_ISR_Time=Total/10000;
9D003F1C  8F82805C   LW V0, -32676(GP)
9D003F20  00510019   MULTU 0, V0, S1
9D003F24  00001010   MFHI V0
9D003F28  00021342   SRL V0, V0, 13
9D003F2C  AF828044   SW V0, -32700(GP)
196:                     RMP_LOG_I(Semaphore_ISR_Time);
9D003F30  8F848044   LW A0, -32700(GP)
9D003F34  0F40026D   JAL RMP_Int_Print
9D003F38  00000000   NOP
197:                     RMP_LOG_S(" cycles.\r\n");
9D003F3C  0F400309   JAL RMP_Str_Print
9D003F40  26044B58   ADDIU A0, S0, 19288
9D003F44  0B400FD1   J .LVL50
9D003F48  00000000   NOP
198:                     
199:                     while(1);
200:                 }
201:                 /* End Function:Func_2 *******************************************************/
202:                 
203:                 /* Begin Function:Int_Handler *************************************************
204:                 Description : The interrupt handler. Call this in your periodic ISR.
205:                 Input       : None.
206:                 Output      : None.
207:                 Return      : None.
208:                 ******************************************************************************/
209:                 void Int_Handler(void)
210:                 {
9D003F4C  27BDFFE8   ADDIU SP, SP, -24
9D003F50  AFBF0014   SW RA, 20(SP)
211:                     static cnt_t Count=0;
212:                     
213:                     if(Count<10000)
9D00385C  8F828034   LW V0, -32716(GP)
9D003860  28432710   SLTI V1, V0, 10000
9D003864  1460000A   BNE V1, ZERO, 0x9D003890
9D003868  28434E20   SLTI V1, V0, 20000
9D003F54  8F828034   LW V0, -32716(GP)
9D003F58  28432710   SLTI V1, V0, 10000
9D003F5C  14600008   BNE V1, ZERO, 0x9D003F80
9D003F60  28434E20   SLTI V1, V0, 20000
214:                     {
215:                         Count++;
9D003898  24420001   ADDIU V0, V0, 1
9D0038B4  AF828034   SW V0, -32716(GP)
9D003F88  24420001   ADDIU V0, V0, 1
9D003FA4  AF828034   SW V0, -32716(GP)
216:                         Start=RMP_CNT_READ();
9D003890  3C03BF84   LUI V1, -16508
9D003894  8C630010   LW V1, 16(V1)
9D00389C  00032080   SLL A0, V1, 2
9D0038A0  00641821   ADDU V1, V1, A0
9D0038A4  3063FFFF   ANDI V1, V1, -1
9D0038B8  A7838062   SH V1, -32670(GP)
9D003F80  3C03BF84   LUI V1, -16508
9D003F84  8C630010   LW V1, 16(V1)
9D003F8C  00032080   SLL A0, V1, 2
9D003F90  00641821   ADDU V1, V1, A0
9D003F94  3063FFFF   ANDI V1, V1, -1
9D003FA8  A7838062   SH V1, -32670(GP)
217:                         if(RMP_Thd_Snd_ISR(&Thd_2, 1)<0)
9D0038A8  3C048000   LUI A0, -32768
9D0038AC  24841448   ADDIU A0, A0, 5192
9D0038B0  24050001   ADDIU A1, ZERO, 1
9D0038BC  0F4007B8   JAL RMP_Thd_Snd_ISR
9D0038C0  00000000   NOP
9D0038C4  04400020   BLTZ V0, 0x9D003948
9D0038C8  3C049D00   LUI A0, -25344
9D0038CC  3C02BF81   LUI V0, -16511
9D003F98  3C048000   LUI A0, -32768
9D003F9C  24841448   ADDIU A0, A0, 5192
9D003FA0  24050001   ADDIU A1, ZERO, 1
9D003FAC  0F4007B8   JAL RMP_Thd_Snd_ISR
9D003FB0  00000000   NOP
9D003FB4  0441FFF0   BGEZ V0, 0x9D003F78
9D003FB8  8FBF0014   LW RA, 20(SP)
218:                         {
219:                             RMP_LOG_S("ISR Mailbox send failure: ");
9D003948  0F400309   JAL RMP_Str_Print
9D00394C  24844AFC   ADDIU A0, A0, 19196
9D003FBC  3C049D00   LUI A0, -25344
9D003FC0  0F400309   JAL RMP_Str_Print
9D003FC4  24844AFC   ADDIU A0, A0, 19196
220:                             RMP_LOG_I(Count);
9D003950  0F40026D   JAL RMP_Int_Print
9D003954  8F848034   LW A0, -32716(GP)
9D003FC8  0F40026D   JAL RMP_Int_Print
9D003FCC  8F848034   LW A0, -32716(GP)
221:                             RMP_LOG_S(" sends.\r\n");
9D003958  3C049D00   LUI A0, -25344
9D00395C  0F400309   JAL RMP_Str_Print
9D003960  24844B18   ADDIU A0, A0, 19224
9D003964  0B400E59   J .LVL7
9D003968  00000000   NOP
9D003FD0  3C049D00   LUI A0, -25344
9D003FD4  0F400309   JAL RMP_Str_Print
9D003FD8  24844B18   ADDIU A0, A0, 19224
9D003FDC  0B400FF7   J .LVL54
9D003FE0  00000000   NOP
222:                             while(1);
223:                         }
224:                     }
225:                     else if(Count<20000)
9D00386C  1460001D   BNE V1, ZERO, 0x9D0038E4
9D003870  24030200   ADDIU V1, ZERO, 512
9D003F64  1460001F   BNE V1, ZERO, 0x9D003FE4
9D003F68  24030200   ADDIU V1, ZERO, 512
226:                     {
227:                         Count++;
9D0038EC  24420001   ADDIU V0, V0, 1
9D003908  AF828034   SW V0, -32716(GP)
9D003FEC  24420001   ADDIU V0, V0, 1
9D004008  AF828034   SW V0, -32716(GP)
228:                         Start=RMP_CNT_READ();
9D0038E4  3C03BF84   LUI V1, -16508
9D0038E8  8C630010   LW V1, 16(V1)
9D0038F0  00032080   SLL A0, V1, 2
9D0038F4  00641821   ADDU V1, V1, A0
9D0038F8  3063FFFF   ANDI V1, V1, -1
9D00390C  A7838062   SH V1, -32670(GP)
9D003FE4  3C03BF84   LUI V1, -16508
9D003FE8  8C630010   LW V1, 16(V1)
9D003FF0  00032080   SLL A0, V1, 2
9D003FF4  00641821   ADDU V1, V1, A0
9D003FF8  3063FFFF   ANDI V1, V1, -1
9D00400C  A7838062   SH V1, -32670(GP)
229:                         if(RMP_Sem_Post_ISR(&Sem_1, 1)<0)
9D0038FC  3C048000   LUI A0, -32768
9D003900  24841484   ADDIU A0, A0, 5252
9D003904  24050001   ADDIU A1, ZERO, 1
9D003910  0F400D3F   JAL RMP_Sem_Post_ISR
9D003914  00000000   NOP
9D003918  0441FFED   BGEZ V0, 0x9D0038D0
9D00391C  3C02BF81   LUI V0, -16511
9D003FFC  3C048000   LUI A0, -32768
9D004000  24841484   ADDIU A0, A0, 5252
9D004004  24050001   ADDIU A1, ZERO, 1
9D004010  0F400D3F   JAL RMP_Sem_Post_ISR
9D004014  00000000   NOP
9D004018  0441FFD7   BGEZ V0, 0x9D003F78
9D00401C  8FBF0014   LW RA, 20(SP)
230:                         {
231:                             RMP_LOG_S("ISR semaphore post failure: ");
9D003920  3C049D00   LUI A0, -25344
9D003924  0F400309   JAL RMP_Str_Print
9D003928  24844B24   ADDIU A0, A0, 19236
9D004020  3C049D00   LUI A0, -25344
9D004024  0F400309   JAL RMP_Str_Print
9D004028  24844B24   ADDIU A0, A0, 19236
232:                             RMP_LOG_I(Count);
9D00392C  0F40026D   JAL RMP_Int_Print
9D003930  8F848034   LW A0, -32716(GP)
9D00402C  0F40026D   JAL RMP_Int_Print
9D004030  8F848034   LW A0, -32716(GP)
233:                             RMP_LOG_S(" posts.\r\n");
9D003934  3C049D00   LUI A0, -25344
9D003938  0F400309   JAL RMP_Str_Print
9D00393C  24844B44   ADDIU A0, A0, 19268
9D003940  0B400E50   J .LVL4
9D003944  00000000   NOP
9D004034  3C049D00   LUI A0, -25344
9D004038  0F400309   JAL RMP_Str_Print
9D00403C  24844B44   ADDIU A0, A0, 19268
9D004040  0B401010   J .LVL58
9D004044  00000000   NOP
234:                             while(1);
235:                         }
236:                     }
237:                     else
238:                         Int_Disable();
239:                 }
9D003F74  8FBF0014   LW RA, 20(SP)
9D003F78  03E00008   JR RA
9D003F7C  27BD0018   ADDIU SP, SP, 24
240:                 #endif
241:                 /* End Function:Int_Handler **************************************************/
242:                 
243:                 /* Begin Function:RMP_Init ****************************************************
244:                 Description : The init thread hook functions.
245:                 Input       : None.
246:                 Output      : None.
247:                 Return      : None.
248:                 ******************************************************************************/
249:                 void RMP_Init_Hook(void)
250:                 {
9D004048  27BDFFD0   ADDIU SP, SP, -48
9D00404C  AFBF002C   SW RA, 44(SP)
9D004050  AFB30028   SW S3, 40(SP)
9D004054  AFB20024   SW S2, 36(SP)
9D004058  AFB10020   SW S1, 32(SP)
9D00405C  AFB0001C   SW S0, 28(SP)
251:                 #ifndef MINIMAL_SIZE
252:                     /* Init the timer */
253:                     Timer_Init();
254:                     /* Clean up the structures */
255:                     RMP_Clear(&Thd_1,sizeof(struct RMP_Thd));
9D004060  3C138000   LUI S3, -32768
9D004068  2664140C   ADDIU A0, S3, 5132
9D00406C  2405003C   ADDIU A1, ZERO, 60
9D004090  0F40024F   JAL .LFB4, .LFE14, RMP_Clear
9D004094  24120001   ADDIU S2, ZERO, 1
256:                     RMP_Clear(&Thd_2,sizeof(struct RMP_Thd));
9D004070  3C108000   LUI S0, -32768
9D004098  26041448   ADDIU A0, S0, 5192
9D00409C  0F40024F   JAL .LFB4, .LFE14, RMP_Clear
9D0040A0  2405003C   ADDIU A1, ZERO, 60
257:                     RMP_Clear(&Sem_1,sizeof(struct RMP_Sem));
9D004078  3C118000   LUI S1, -32768
9D0040A4  26241484   ADDIU A0, S1, 5252
9D0040A8  0F40024F   JAL .LFB4, .LFE14, RMP_Clear
9D0040AC  24050010   ADDIU A1, ZERO, 16
258:                     /* Create counting semaphore */
259:                     RMP_Sem_Crt(&Sem_1,0);
9D0040B0  26241484   ADDIU A0, S1, 5252
9D0040B4  0F4009FD   JAL RMP_Sem_Crt
9D0040B8  00002821   ADDU A1, ZERO, ZERO
260:                     /* Start threads */
261:                     RMP_Thd_Crt(&Thd_1, Func_1, THD1_STACK, (void*)0x1234, 1, 5);
9D0040BC  24110005   ADDIU S1, ZERO, 5
9D0040C0  2664140C   ADDIU A0, S3, 5132
9D0040C4  3C059D00   LUI A1, -25344
9D0040C8  24A53AB8   ADDIU A1, A1, 15032
9D0040CC  3C068000   LUI A2, -32768
9D0040D0  24C610BC   ADDIU A2, A2, 4284
9D0040D4  24071234   ADDIU A3, ZERO, 4660
9D0040D8  AFB20010   SW S2, 16(SP)
9D0040DC  0F4003EC   JAL RMP_Thd_Crt
9D0040E0  AFB10014   SW S1, 20(SP)
262:                     RMP_Thd_Crt(&Thd_2, Func_2, THD2_STACK, (void*)0x4321, 1, 5);
9D0040E4  AFB20010   SW S2, 16(SP)
9D0040E8  AFB10014   SW S1, 20(SP)
9D0040EC  26041448   ADDIU A0, S0, 5192
9D0040F0  3C059D00   LUI A1, -25344
9D0040F4  24A53D94   ADDIU A1, A1, 15764
9D0040F8  3C068000   LUI A2, -32768
9D0040FC  24C608BC   ADDIU A2, A2, 2236
9D004100  0F4003EC   JAL RMP_Thd_Crt
9D004104  24074321   ADDIU A3, ZERO, 17185
263:                 #endif
264:                 }
9D004108  8FBF002C   LW RA, 44(SP)
9D00410C  8FB30028   LW S3, 40(SP)
9D004110  8FB20024   LW S2, 36(SP)
9D004114  8FB10020   LW S1, 32(SP)
9D004118  8FB0001C   LW S0, 28(SP)
9D00411C  03E00008   JR RA
9D004120  27BD0030   ADDIU SP, SP, 48
265:                 
266:                 void RMP_Init_Idle(void)
267:                 {
9D004124  03E00008   JR RA
268:                     return;
269:                 }
270:                 /* End Function:RMP_Init *****************************************************/
271:                 
272:                 /* End Of File ***************************************************************/
273:                 
274:                 /* Copyright (C) Evo-Devo Instrum. All rights reserved ***********************/
---  f:/code_library/mcu/mutatus/m5p1_muprokaron/mprokaron/benchmark/platform/test_pic32mz2048efm100.h  -
1:                   /******************************************************************************
2:                   Filename    : test_PIC32MZ2048EFM100.h
3:                   Author      : pry 
4:                   Date        : 22/07/2017
5:                   Licence     : LGPL v3+; see COPYING for details.
6:                   Description : The testbench for PIC32MZ2048EFM100.
7:                   ******************************************************************************/
8:                   
9:                   /* Includes ******************************************************************/
10:                  #include "RMP.h"
11:                  /* End Includes **************************************************************/
12:                  
13:                  /* Defines *******************************************************************/
14:                  /* Where are the initial stacks */
15:                  #define THD1_STACK          (&Stack_1[300])
16:                  #define THD2_STACK          (&Stack_2[300])
17:                  /* How to read counter */
18:                  #define RMP_CNT_READ()      (TMR1*5)
19:                  /* Are we doing minimal measurements? */
20:                  /* #define MINIMAL_SIZE */
21:                  /* The PIC32 timers are all 16 bits, so */
22:                  typedef u16 tim_t;
23:                  
24:                  /* The pragmas for PIC32 fuse */
25:                  /*** DEVCFG0 ***/
26:                  #pragma config DEBUG =      OFF
27:                  #pragma config JTAGEN =     OFF
28:                  #pragma config ICESEL =     ICS_PGx2
29:                  #pragma config TRCEN =      OFF
30:                  #pragma config BOOTISA =    MIPS32
31:                  #pragma config FECCCON =    OFF_UNLOCKED
32:                  #pragma config FSLEEP =     OFF
33:                  #pragma config DBGPER =     ALLOW_PG2
34:                  #pragma config SMCLR =      MCLR_NORM
35:                  #pragma config SOSCGAIN =   GAIN_2X
36:                  #pragma config SOSCBOOST =  ON
37:                  #pragma config POSCGAIN =   GAIN_2X
38:                  #pragma config POSCBOOST =  ON
39:                  #pragma config EJTAGBEN =   NORMAL
40:                  #pragma config CP =         OFF
41:                  
42:                  /*** DEVCFG1 ***/
43:                  #pragma config FNOSC =      SPLL
44:                  #pragma config DMTINTV =    WIN_127_128
45:                  #pragma config FSOSCEN =    OFF
46:                  #pragma config IESO =       OFF
47:                  #pragma config POSCMOD =    EC
48:                  #pragma config OSCIOFNC =   OFF
49:                  #pragma config FCKSM =      CSECME
50:                  #pragma config WDTPS =      PS1048576
51:                  #pragma config WDTSPGM =    STOP
52:                  #pragma config FWDTEN =     OFF
53:                  #pragma config WINDIS =     NORMAL
54:                  #pragma config FWDTWINSZ =  WINSZ_25
55:                  #pragma config DMTCNT =     DMT9
56:                  #pragma config FDMTEN =     OFF
57:                  
58:                  /*** DEVCFG2 ***/
59:                  #pragma config FPLLIDIV =   DIV_3
60:                  #pragma config FPLLRNG =    RANGE_8_16_MHZ
61:                  #pragma config FPLLICLK =   PLL_POSC
62:                  #pragma config FPLLMULT =   MUL_50
63:                  #pragma config FPLLODIV =   DIV_2
64:                  #pragma config UPLLFSEL =   FREQ_24MHZ
65:                  
66:                  /*** DEVCFG3 ***/
67:                  #pragma config USERID =     0xffff
68:                  #pragma config FMIIEN =     OFF
69:                  #pragma config FETHIO =     ON
70:                  #pragma config PGL1WAY =    ON
71:                  #pragma config PMDL1WAY =   ON
72:                  #pragma config IOL1WAY =    ON
73:                  #pragma config FUSBIDIO =   OFF
74:                  
75:                  /*** BF1SEQ0 ***/
76:                  #pragma config TSEQ =       0x0000
77:                  #pragma config CSEQ =       0xffff
78:                  /* End Defines ***************************************************************/
79:                  
80:                  /* Globals *******************************************************************/
81:                  #ifndef MINIMAL_SIZE
82:                  void Int_Handler(void);
83:                  ptr_t Stack_1[512];
84:                  ptr_t Stack_2[512];
85:                  /* End Globals ***************************************************************/
86:                  
87:                  /* Begin Function:Timer_Init **************************************************
88:                  Description : Initialize the timer for timing measurements. This function needs
89:                                to be adapted to your specific hardware.
90:                  Input       : None.
91:                  Output      : None.
92:                  Return      : None.
93:                  ******************************************************************************/
94:                  void Timer_Init(void)
95:                  {
96:                      /* TIM1 clock = 1/5 CPU clock */
97:                      T1CON=0;
9D0037F4  3C02BF84   LUI V0, -16508
9D0037F8  AC400000   SW ZERO, 0(V0)
9D004064  3C02BF84   LUI V0, -16508
9D004074  AC400000   SW ZERO, 0(V0)
98:                      TMR1=0;
9D0037FC  AC400010   SW ZERO, 16(V0)
9D00407C  AC400010   SW ZERO, 16(V0)
99:                      PR1=0xFFFF;
9D003800  3403FFFF   ORI V1, ZERO, -1
9D003804  AC430020   SW V1, 32(V0)
9D004080  3403FFFF   ORI V1, ZERO, -1
9D004084  AC430020   SW V1, 32(V0)
100:                     /* Start the timer */
101:                     T1CONSET=(1<<15);
9D003808  34038000   ORI V1, ZERO, -32768
9D00380C  AC430008   SW V1, 8(V0)
9D003810  03E00008   JR RA
9D003814  00000000   NOP
9D004088  34038000   ORI V1, ZERO, -32768
9D00408C  AC430008   SW V1, 8(V0)
102:                 }
103:                 /* End Function:Timer_Init ***************************************************/
104:                 
105:                 /* Begin Function:Int_Init ****************************************************
106:                 Description : Initialize an periodic interrupt source. This function needs
107:                               to be adapted to your specific hardware.
108:                 Input       : None.
109:                 Output      : None.
110:                 Return      : None.
111:                 ******************************************************************************/
112:                 void Int_Init(void)
113:                 {
114:                     /* TIM2 clock = 1/5 CPU clock */
115:                     T2CON=0;
9D003818  3C02BF84   LUI V0, -16508
9D003824  AC400200   SW ZERO, 512(V0)
9D003E88  3C02BF84   LUI V0, -16508
9D003E98  AC400200   SW ZERO, 512(V0)
116:                     TMR2=0;
9D003828  AC400210   SW ZERO, 528(V0)
9D003E9C  AC400210   SW ZERO, 528(V0)
117:                     PR2=20000;
9D00382C  24054E20   ADDIU A1, ZERO, 20000
9D003830  AC450220   SW A1, 544(V0)
9D003EA0  24054E20   ADDIU A1, ZERO, 20000
9D003EA4  AC450220   SW A1, 544(V0)
118:                     /* Lowest interrupt level */
119:                     IPC2SET=(1<<_IPC2_T2IP_POSITION)|(0<<_IPC2_T2IS_POSITION);
9D00381C  3C03BF81   LUI V1, -16511
9D003834  24050400   ADDIU A1, ZERO, 1024
9D003838  AC650168   SW A1, 360(V1)
9D003E8C  3C03BF81   LUI V1, -16511
9D003EA8  24050400   ADDIU A1, ZERO, 1024
9D003EAC  AC650168   SW A1, 360(V1)
120:                     IFS0CLR=_IFS0_T2IF_MASK;
9D003820  24040200   ADDIU A0, ZERO, 512
9D00383C  AC640044   SW A0, 68(V1)
9D003E90  24040200   ADDIU A0, ZERO, 512
9D003EB0  AC640044   SW A0, 68(V1)
121:                     IEC0SET=(1<<_IEC0_T2IE_POSITION);
9D003840  AC6400C8   SW A0, 200(V1)
9D003EB4  AC6400C8   SW A0, 200(V1)
122:                     /* Start the timer */
123:                     T2CONSET=(1<<15);
9D003844  34038000   ORI V1, ZERO, -32768
9D003848  AC430208   SW V1, 520(V0)
9D00384C  03E00008   JR RA
9D003850  00000000   NOP
9D003EB8  34038000   ORI V1, ZERO, -32768
9D003EBC  AC430208   SW V1, 520(V0)
124:                 }
125:                 
126:                 /* The interrupt handler with shadow register sets */
127:                 void Tim2_Interrupt(void)
128:                 {
9D003854  27BDFFE8   ADDIU SP, SP, -24
9D003858  AFBF0014   SW RA, 20(SP)
129:                     Int_Handler();
130:                     /* Clear flags */
131:                     IFS0CLR=_IFS0_T2IF_MASK;
9D00387C  24030200   ADDIU V1, ZERO, 512
9D003880  AC430044   SW V1, 68(V0)
9D0038D0  24030200   ADDIU V1, ZERO, 512
9D0038D4  AC430044   SW V1, 68(V0)
132:                 }
9D003884  8FBF0014   LW RA, 20(SP)
9D003888  03E00008   JR RA
9D00388C  27BD0018   ADDIU SP, SP, 24
9D0038D8  8FBF0014   LW RA, 20(SP)
9D0038DC  03E00008   JR RA
9D0038E0  27BD0018   ADDIU SP, SP, 24
133:                 /* End Function:Int_Init *****************************************************/
134:                 
135:                 /* Begin Function:Int_Disable *************************************************
136:                 Description : Disable the periodic interrupt source. This function needs
137:                               to be adapted to your specific hardware.
138:                 Input       : None.
139:                 Output      : None.
140:                 Return      : None.
141:                 ******************************************************************************/
142:                 void Int_Disable(void)
143:                 {
144:                     /* Disable timer 2 interrupt */
145:                     IEC0CLR=_IEC0_T2IE_MASK;
9D003874  3C02BF81   LUI V0, -16511
9D00396C  24030200   ADDIU V1, ZERO, 512
9D003970  3C02BF81   LUI V0, -16511
9D003974  AC4300C4   SW V1, 196(V0)
9D003978  03E00008   JR RA
9D00397C  00000000   NOP
9D003F6C  3C02BF81   LUI V0, -16511
146:                 }
147:                 #endif
148:                 /* End Function:Int_Disable **************************************************/
149:                 
150:                 /* End Of File ***************************************************************/
151:                 
152:                 /* Copyright (C) Evo-Devo Instrum. All rights reserved ***********************/
---  F:/Code_Library/MCU/Mutatus/M5P1_MuProkaron/MProkaron/Platform/MIPSM/platform_mipsm_asm.s  ---------
                                                  1:     /******************************************************************************
                                                  2:     Filename    : platform_mipsm_asm.s
                                                  3:     Author      : pry
                                                  4:     Date        : 10/04/2012
                                                  5:     Description : The assembly part of the RMP RTOS.
                                                  6:     ******************************************************************************/
                                                  7:         
                                                  8:     /* The MIPS M-Class Structure *************************************************
                                                  9:     R0:Hardwired register containing "0". 
                                                  10:    R1-R31:General purpose registers that can only be reached by 32-bit instructions.
                                                  11:    HI:Multiply/divide unit high register.
                                                  12:    LO:Multiply/divide unit low register.
                                                  13:    PC:Program counter.
                                                  14:    The processor also include a single-accuracy FPU.
                                                  15:    Detailed usage convention for R0-R31:
                                                  16:    No.    Name       Explanation
                                                  17:    R0     $zero      constant 0
                                                  18:    R1     $at        reserved for assembler
                                                  19:    R2     $v0        expression evaluation and results of a function
                                                  20:    R3     $v1        expression evaluation and results of a function
                                                  21:    R4     $a0	      argument 1
                                                  22:    R5     $a1  	  argument 2
                                                  23:    R6     $a2        argument 3
                                                  24:    R7     $a3        argument 4
                                                  25:    R8     $t0  	  temporary (not preserved across call)
                                                  26:    R9     $t1        temporary (not preserved across call)
                                                  27:    R10    $t2        temporary (not preserved across call)
                                                  28:    R11    $t3        temporary (not preserved across call)
                                                  29:    R12    $t4        temporary (not preserved across call)
                                                  30:    R13    $t5        temporary (not preserved across call)
                                                  31:    R14    $t6        temporary (not preserved across call)
                                                  32:    R15    $t7        temporary (not preserved across call)
                                                  33:    R16    $s0        saved temporary (preserved across call)
                                                  34:    R17    $s1        saved temporary (preserved across call)
                                                  35:    R18    $s2        saved temporary (preserved across call)
                                                  36:    R19    $s3        saved temporary (preserved across call)
                                                  37:    R20    $s4        saved temporary (preserved across call)
                                                  38:    R21    $s5        saved temporary (preserved across call)
                                                  39:    R22    $s6        saved temporary (preserved across call)
                                                  40:    R23    $s7        saved temporary (preserved across call)
                                                  41:    R24    $t8        temporary (not preserved across call)
                                                  42:    R25    $t9        temporary (not preserved across call)
                                                  43:    R26    $k0        reserved for OS kernel
                                                  44:    R27    $k1        reserved for OS kernel
                                                  45:    R28    $gp        pointer to global area
                                                  46:    R29    $sp        stack pointer
                                                  47:    R30    $fp        frame pointer
                                                  48:    R31    $ra        return address (used by function call)
                                                  49:    ******************************************************************************/
                                                  50:        
                                                  51:    /* Begin Header **************************************************************/
                                                  52:                    .text
                                                  53:                    .align 4
                                                  54:    /* End Header ****************************************************************/
                                                  55:    
                                                  56:    /* Begin Exports *************************************************************/
                                                  57:                    /* Disable all interrupts */
                                                  58:                    .global          RMP_Int_Disable      
                                                  59:                    /* Enable all interrupts */        
                                                  60:                    .global          RMP_Int_Enable   
                                                  61:                    /* Get the MSB */
                                                  62:                    .global          RMP_MSB_Get
                                                  63:                    /* Start the first thread */
                                                  64:                    .global          _RMP_Start
                                                  65:                    /* The context switch trigger */
                                                  66:                    .global          _RMP_Yield
                                                  67:                    /* The system pending service routine */
                                                  68:                    .global          PendSV_Handler 
                                                  69:                    /* The systick timer routine */
                                                  70:                    .global          SysTick_Handler
                                                  71:                    /* Set timer overflow value */
                                                  72:                    .global          _RMP_Set_Timer
                                                  73:    /* End Exports ***************************************************************/
                                                  74:    
                                                  75:    /* Begin Imports *************************************************************/
                                                  76:                    /* The real task switch handling function */
                                                  77:                    .extern         _RMP_Run_High 
                                                  78:                    /* The real systick handler function */
                                                  79:                    .extern          _RMP_Tick_Handler
                                                  80:                    /* The PID of the current thread */
                                                  81:                    .extern          RMP_Thd_Cur
                                                  82:                    /* The stack address of current thread */
                                                  83:                    .extern          RMP_SP_Cur
                                                  84:                    /* Save and load extra contexts, such as FPU, peripherals and MPU */
                                                  85:                    .extern          RMP_Ctx_Save
                                                  86:                    .extern          RMP_Ctx_Load
                                                  87:                    /* The place where we store the kernel gp/sp value */
                                                  88:                    .extern          RMP_GP_Val
                                                  89:                    .extern          RMP_SP_Val
                                                  90:                    /* The interrupt nesting value */
                                                  91:                    .extern          RMP_Int_Nest
                                                  92:                    /* Clear timer & software interrupt flags */
                                                  93:                    .extern          _RMP_Clear_Soft_Flag
                                                  94:                    .extern          _RMP_Clear_Timer_Flag
                                                  95:    /* End Imports ***************************************************************/
                                                  96:    
                                                  97:    /* Begin Macros **************************************************************/
                                                  98:                    .equ             CP0_COUNT,$9
                                                  99:                    .equ             CP0_COMPARE,$11
                                                  100:                   .equ             CP0_STATUS,$12
                                                  101:                   .equ             CP0_CAUSE,$13
                                                  102:                   .equ             CP0_EPC,$14
                                                  103:                   .equ             CTX_SIZE,136
                                                  104:                   .equ             CORE_SW0,0x100
                                                  105:   /* Interrupt context - this is for generic support. These interrupts should not use DSP & FPU */
                                                  106:   .macro	SAVE_CONTEXT
                                                  107:                   /* Make room for the context */
                                                  108:                   addiu            $sp,$sp,-CTX_SIZE
                                                  109:                   /* Save three regs first so that we can enable interrupts as soon as possible */
                                                  110:                   sw               $23,132($sp)
                                                  111:                   sw               $22,128($sp)
                                                  112:                   sw               $21,124($sp)
                                                  113:                   sw               $20,120($sp)
                                                  114:                   /* Increase interrupt nesting count */
                                                  115:                   lui              $23,%hi(RMP_Int_Nest)
                                                  116:                   ori              $23,$23,%lo(RMP_Int_Nest)
                                                  117:                   lw               $22,($23)
                                                  118:                   nop
                                                  119:                   addiu            $21,$22,1
                                                  120:                   sw               $21,($23)
                                                  121:                   /* Branch taken when already in system stack */
                                                  122:                   bne              $22,$0,1f 
                                                  123:                   nop
                                                  124:                   /* Need to save the old sp first */
                                                  125:                   lui              $23,%hi(RMP_Old_SP_Val)
                                                  126:                   ori              $23,$23,%lo(RMP_Old_SP_Val)
                                                  127:                   sw               $sp,($23)
                                                  128:                   move             $20,$sp
                                                  129:                   /* We need to swap to system stack for execution */
                                                  130:                   lui              $23,%hi(RMP_SP_Val)
                                                  131:                   ori              $23,$23,%lo(RMP_SP_Val)
                                                  132:                   lw               $sp,($23)
                                                  133:                   b                2f
                                                  134:                   nop
                                                  135:   1:              move             $20,$sp
                                                  136:                   /* Save all status registers, except for CAUSE */
                                                  137:   2:              mfc0             $23,CP0_EPC
                                                  138:                   mfc0             $22,CP0_CAUSE
                                                  139:   	            mfc0             $21,CP0_STATUS
                                                  140:                   sw               $23,116($20)
                                                  141:                   sw               $21,112($20)
                                                  142:                   /* Now we reenable interrupts */
                                                  143:                   ins              $21,$0,1,15             /* Clear IPL, UM, ERL, EXL from STATUS */
                                                  144:                   ext              $23,$22,10,6            /* Extract RIPL from CAUSE */
                                                  145:                   ins              $21,$23,10,6            /* Set current IPL */
                                                  146:                   mtc0             $21,CP0_STATUS          /* Write status back */
                                                  147:                   /* Save mutiply/divide registers */
                                                  148:                   mfhi             $23
                                                  149:                   mflo             $22
                                                  150:                   sw               $23,108($20)
                                                  151:                   sw               $22,104($20)
                                                  152:                   /* Save "kernel only" registers - we do not expect the user to abide by the rule */
                                                  153:                   sw               $28,100($20)
                                                  154:                   sw               $27,96($20)
                                                  155:                   sw               $26,92($20)
                                                  156:                   /* Save everything else */
                                                  157:                   sw               $31,88($20)
                                                  158:                   sw               $30,84($20)
                                                  159:                   sw               $25,80($20)
                                                  160:                   sw               $24,76($20)
                                                  161:                   sw               $19,72($20)
                                                  162:                   sw               $18,68($20)
                                                  163:                   sw               $17,64($20)
                                                  164:                   sw               $16,60($20)
                                                  165:                   sw               $15,56($20)
                                                  166:                   sw               $14,52($20)
                                                  167:                   sw               $13,48($20)
                                                  168:                   sw               $12,44($20)
                                                  169:                   sw               $11,40($20)
                                                  170:                   sw               $10,36($20)
                                                  171:                   sw               $9,32($20)
                                                  172:                   sw               $8,28($20)
                                                  173:                   sw               $7,24($20)
                                                  174:                   sw               $6,20($20)
                                                  175:                   sw               $5,16($20)
                                                  176:                   sw               $4,12($20)
                                                  177:                   sw               $3,8($20)
                                                  178:                   sw               $2,4($20)
                                                  179:                   sw               $1,0($20)
                                                  180:   .endm
                                                  181:                   
                                                  182:                   /* Context restoring */
                                                  183:   .macro LOAD_CONTEXT
                                                  184:                   /* Protect access to c0 registers */
                                                  185:                   di
                                                  186:                   ehb
                                                  187:                   /* Decrease interrupt nesting count */
                                                  188:                   lui              $23,%hi(RMP_Int_Nest)
                                                  189:                   ori              $23,$23,%lo(RMP_Int_Nest)
                                                  190:                   lw               $22,($23)
                                                  191:                   nop
                                                  192:                   addiu            $21,$22,-1
                                                  193:                   sw               $21,($23)
                                                  194:                   /* Branch taken when going to return to user stack */
                                                  195:                   bne              $21,$0,1f 
                                                  196:                   nop
                                                  197:                   /* Need to load back the old sp */
                                                  198:                   lui              $23,%hi(RMP_Old_SP_Val)
                                                  199:                   ori              $23,$23,%lo(RMP_Old_SP_Val)
                                                  200:                   lw               $sp,($23)
                                                  201:                   nop
                                                  202:   1:              move             $20,$sp
                                                  203:                   /* Restore all status registers, except for CAUSE */
                                                  204:                   lw               $21,112($20)
                                                  205:                   lw               $23,116($20)
                                                  206:                   mtc0             $23,CP0_EPC
                                                  207:                   /* Make sure status is recovered at last */
                                                  208:   	            mtc0             $21,CP0_STATUS
                                                  209:                   /* Restore everything else */
                                                  210:                   lw               $1,0($20)
                                                  211:                   lw               $2,4($20)
                                                  212:                   lw               $3,8($20)
                                                  213:                   lw               $4,12($20)
                                                  214:                   lw               $5,16($20)
                                                  215:                   lw               $6,20($20)
                                                  216:                   lw               $7,24($20)
                                                  217:                   lw               $8,28($20)
                                                  218:                   lw               $9,32($20)
                                                  219:                   lw               $10,36($20)
                                                  220:                   lw               $11,40($20)
                                                  221:                   lw               $12,44($20)
                                                  222:                   lw               $13,48($20)
                                                  223:                   lw               $14,52($20)
                                                  224:                   lw               $15,56($20)
                                                  225:                   lw               $16,60($20)
                                                  226:                   lw               $17,64($20)
                                                  227:                   lw               $18,68($20)
                                                  228:                   lw               $19,72($20)
                                                  229:                   lw               $24,76($20)
                                                  230:                   lw               $25,80($20)
                                                  231:                   lw               $30,84($20)
                                                  232:                   lw               $31,88($20)
                                                  233:                   /* Restore "kernel only" registers */
                                                  234:                   lw               $26,92($20)
                                                  235:                   lw               $27,96($20)
                                                  236:                   lw               $28,100($20)
                                                  237:                   /* Restore mutiply/divide registers */
                                                  238:                   lw               $22,104($20)
                                                  239:                   lw               $23,108($20)
                                                  240:                   mtlo             $22
                                                  241:                   mthi             $23
                                                  242:                   /* Restore four temporary regs */
                                                  243:                   lw               $20,120($sp)
                                                  244:                   lw               $21,124($sp)
                                                  245:                   lw               $22,128($sp)
                                                  246:                   lw               $23,132($sp)
                                                  247:                   /* Restore the SP */
                                                  248:                   addiu            $sp,$sp,CTX_SIZE
                                                  249:                   eret
                                                  250:                   nop
                                                  251:   .endm
                                                  252:   /* End Macros ****************************************************************/
                                                  253:   
                                                  254:   /* Begin Function:RMP_Int_Disable *********************************************
                                                  255:   Description    : The function for disabling all interrupts. Does not allow nesting.
                                                  256:   Input          : None.
                                                  257:   Output         : None.    
                                                  258:   Register Usage : None.                                  
                                                  259:   ******************************************************************************/
                                                  260:                  	.set             nomips16
                                                  261:                   .set             nomicromips
                                                  262:                   .set             noreorder
                                                  263:                   .set             noat
                                                  264:                   .ent             RMP_Int_Disable
                                                  265:   RMP_Int_Disable:
                                                  266:                   /* Disable all interrupts */
9D004BA0  41606000   DI ZERO                      267:                   di
9D004BA4  03E00008   JR RA                        268:                   jr               $ra
9D004BA8  00000000   NOP                          269:                   nop
                                                  270:                   .end             RMP_Int_Disable
                                                  271:   /* End Function:RMP_Int_Disable **********************************************/
                                                  272:   
                                                  273:   /* Begin Function:RMP_Int_Enable **********************************************
                                                  274:   Description    : The function for enabling all interrupts. Does not allow nesting.
                                                  275:   Input          : None.
                                                  276:   Output         : None.    
                                                  277:   Register Usage : None.                                  
                                                  278:   ******************************************************************************/
                                                  279:                  	.set             nomips16
                                                  280:                   .set             nomicromips
                                                  281:                   .set             noreorder
                                                  282:                   .set             noat
                                                  283:                   .ent             RMP_Int_Enable
                                                  284:   RMP_Int_Enable:
                                                  285:                   /* Enable all interrupts */
9D004BAC  41606020   EI ZERO                      286:                   ei
9D004BB0  03E00008   JR RA                        287:                   jr               $ra
9D004BB4  00000000   NOP                          288:                   nop
                                                  289:                   .end             RMP_Int_Enable
                                                  290:   /* End Function:RMP_Int_Enable ***********************************************/
                                                  291:   
                                                  292:   /* Begin Function:_RMP_Set_Timer **********************************************
                                                  293:   Description    : The function for setting the timer.
                                                  294:   Input          : $a0 - Timer overflow value.
                                                  295:   Output         : None.    
                                                  296:   Register Usage : None.                                  
                                                  297:   ******************************************************************************/
                                                  298:                  	.set             nomips16
                                                  299:                   .set             nomicromips
                                                  300:                   .set             noreorder
                                                  301:                   .set             noat
                                                  302:                   .ent             _RMP_Set_Timer
                                                  303:   _RMP_Set_Timer:
9D004BB8  40845800   MTC0 A0, Compare             304:                   mtc0             $a0,CP0_COMPARE
9D004BBC  24040000   ADDIU A0, ZERO, 0            305:                   li               $a0,0
9D004BC0  40844800   MTC0 A0, Count               306:                   mtc0             $a0,CP0_COUNT
9D004BC4  03E00008   JR RA                        307:                   jr               $ra
9D004BC8  00000000   NOP                          308:                   nop
                                                  309:                   .end             _RMP_Set_Timer
                                                  310:   /* End Function:_RMP_Set_Timer ***********************************************/
                                                  311:   
                                                  312:   /* Begin Function:RMP_MSB_Get *************************************************
                                                  313:   Description    : Get the MSB of the word.
                                                  314:   Input          : ptr_t Val - The value.
                                                  315:   Output         : None.
                                                  316:   Return         : ptr_t - The MSB position.   
                                                  317:   Register Usage : None. 
                                                  318:   ******************************************************************************/
                                                  319:                  	.set             nomips16
                                                  320:                   .set             nomicromips
                                                  321:                   .set             noreorder
                                                  322:                   .set             noat
                                                  323:                   .ent             RMP_MSB_Get
                                                  324:   RMP_MSB_Get:
9D004BCC  70842020   CLZ A0, A0                   325:                   clz              $a0,$a0
9D004BD0  2402001F   ADDIU V0, ZERO, 31           326:                   li               $v0,31
9D004BD4  00441022   SUB V0, V0, A0               327:                   sub              $v0,$a0
9D004BD8  03E00008   JR RA                        328:                   jr               $ra
9D004BDC  00000000   NOP                          329:                   nop
                                                  330:                   .end             RMP_MSB_Get
                                                  331:   /* End Function:RMP_MSB_Get **************************************************/
                                                  332:   
                                                  333:   /* Begin Function:_RMP_Yield **************************************************
                                                  334:   Description : Trigger a yield to another thread.
                                                  335:   Input       : None.
                                                  336:   Output      : None.                                      
                                                  337:   ******************************************************************************/
                                                  338:                  	.set             nomips16
                                                  339:                   .set             nomicromips
                                                  340:                   .set             noreorder
                                                  341:                   .set             noat
                                                  342:                   .ent             _RMP_Yield
                                                  343:   _RMP_Yield:
                                                  344:                   /* Get the cause for this */
9D004BE0  40086800   MFC0 T0, Cause               345:                   mfc0             $t0,$13
9D004BE4  35080100   ORI T0, T0, 256              346:                   or               $t0,CORE_SW0
                                                  347:                   /* Now write back to trigger the software interrupt */
9D004BE8  40886800   MTC0 T0, Cause               348:                   mtc0             $t0,$13
9D004BEC  03E00008   JR RA                        349:                   jr               $ra
9D004BF0  00000000   NOP                          350:                   nop
                                                  351:                   .end             _RMP_Yield                                           
                                                  352:   /* End Function:_RMP_Yield ***************************************************/
                                                  353:   
                                                  354:   ;/* Begin Function:_RMP_Start *************************************************
                                                  355:   ;Description : Jump to the user function and will never return from it.
                                                  356:   ;Input       : R0 - The address to branch to.
                                                  357:                  R1 - The stack to use.
                                                  358:   ;Output      : None.                                      
                                                  359:   ;*****************************************************************************/
                                                  360:                  	.set             nomips16
                                                  361:                   .set             nomicromips
                                                  362:                   .set             noreorder
                                                  363:                   .set             noat
                                                  364:                   .ent             _RMP_Start
                                                  365:   _RMP_Start:
9D004BF4  3C068000   LUI A2, -32768               366:                   lui              $a2,%hi(RMP_SP_Val)          /* Store the SP to a global */
9D004BF8  34C603FC   ORI A2, A2, 1020             367:                   ori              $a2,$a2,%lo(RMP_SP_Val)
9D004BFC  ACDD0000   SW SP, 0(A2)                 368:                   sw               $sp,($a2)
                                                  369:                   
9D004C00  3C068000   LUI A2, -32768               370:                   lui              $a2,%hi(RMP_GP_Val)          /* Store the GP to a global */
9D004C04  34C60404   ORI A2, A2, 1028             371:                   ori              $a2,$a2,%lo(RMP_GP_Val)
9D004C08  ACDC0000   SW GP, 0(A2)                 372:                   sw               $gp,($a2)
                                                  373:                   
9D004C0C  20BDFF80   ADDI SP, A1, -128            374:                   sub              $sp,$a1,128                  /* Set the new SP */
9D004C10  0080F809   JALR A0                      375:                   jal              $a0                          /* Branch to target */
9D004C14  00000000   NOP                          376:                   nop
9D004C18  0B401306   J 0x9D004C18                 377:   __Loop:         j                __Loop                       /* Dead loop to capture faults */
9D004C1C  00000000   NOP                          378:                   nop
                                                  379:                   .end             _RMP_Start
                                                  380:   /* End Function:_RMP_Start ***************************************************/
                                                  381:   
                                                  382:   /* Begin Function:PendSV_Handler **********************************************
                                                  383:   Description : The PendSV interrupt routine. In fact, it will call a C function
                                                  384:                 directly. The reason why the interrupt routine must be an assembly
                                                  385:                 function is that the compiler may deal with the stack in a different 
                                                  386:                 way when different optimization level is chosen. An assembly function
                                                  387:                 can make way around this problem.
                                                  388:                 However, if your compiler support inline assembly functions, this
                                                  389:                 can also be written in C.
                                                  390:   Input       : None.
                                                  391:   Output      : None.                                      
                                                  392:   ******************************************************************************/
                                                  393:                  	.set             nomips16
                                                  394:                   .set             nomicromips
                                                  395:                   .set             noreorder
                                                  396:                   .set             noat
                                                  397:                   .equ             __vector_dispatch_1,PendSV_Handler
                                                  398:                   .global          __vector_dispatch_1
                                                  399:                   .section         .vector_1,code
                                                  400:                   .ent             PendSV_Handler
                                                  401:   PendSV_Handler:
                                                  402:                   /* Make room for the context */
9D0003EC  27BDFF78   ADDIU SP, SP, -136           403:                   addiu            $sp,$sp,-CTX_SIZE
                                                  404:                   /* Save three regs first so that we can ena \ble interrupts as soon as possible */
9D0003F0  AFB70084   SW S7, 132(SP)               405:                   sw               $23,132($sp)
9D0003F4  AFB60080   SW S6, 128(SP)               406:                   sw               $22,128($sp)
9D0003F8  AFB5007C   SW S5, 124(SP)               407:                   sw               $21,124($sp)
9D0003FC  AFB40078   SW S4, 120(SP)               408:                   sw               $20,120($sp)
                                                  409:                   /* Increase interrupt nesting count */
9D000400  3C178000   LUI S7, -32768               410:                   lui              $23,%hi(RMP_Int_Nest)
9D000404  36F70408   ORI S7, S7, 1032             411:                   ori              $23,$23,%lo(RMP_Int_Nest)
9D000408  8EF60000   LW S6, 0(S7)                 412:                   lw               $22,($23)
9D00040C  00000000   NOP                          413:                   nop
9D000410  26D50001   ADDIU S5, S6, 1              414:                   addiu            $21,$22,1
9D000414  AEF50000   SW S5, 0(S7)                 415:                   sw               $21,($23)
                                                  416:                   /* We always need to swap to system stack for execution */
9D000418  3C178000   LUI S7, -32768               417:                   lui              $23,%hi(RMP_SP_Val)
9D00041C  36F703FC   ORI S7, S7, 1020             418:                   ori              $23,$23,%lo(RMP_SP_Val)
9D000420  03A0A021   ADDU S4, SP, ZERO            419:                   move             $20,$sp
9D000424  8EFD0000   LW SP, 0(S7)                 420:                   lw               $sp,($23)
                                                  421:                   /* Save all status registers, except for CAUSE */
9D000428  40177000   MFC0 S7, EPC                 422:                   mfc0             $23,CP0_EPC
9D00042C  40166800   MFC0 S6, Cause               423:                   mfc0             $22,CP0_CAUSE
9D000430  40156000   MFC0 S5, Status              424:   	            mfc0             $21,CP0_STATUS
9D000434  AE970074   SW S7, 116(S4)               425:                   sw               $23,116($20)
9D000438  AE950070   SW S5, 112(S4)               426:                   sw               $21,112($20)
                                                  427:                   /* Clear the software interrupt in the core */
9D00043C  40166800   MFC0 S6, Cause               428:                   mfc0             $22,CP0_CAUSE
9D000440  7C164204   INS S6, ZERO, 8, 1           429:                   ins              $22,$0,8,1
9D000444  40966800   MTC0 S6, Cause               430:                   mtc0             $22,CP0_CAUSE
9D000448  000000C0   EHB                          431:                   ehb
                                                  432:                   /* Now we reenable interrupts */
9D00044C  7C157844   INS S5, ZERO, 1, 15          433:                   ins              $21,$0,1,15             /* Clear IPL, UM, ERL, EXL from STATUS */
9D000450  7ED72A80   EXT S7, S6, 10, 6            434:                   ext              $23,$22,10,6            /* Extract RIPL from CAUSE */
9D000454  7EF57A84   INS S5, S7, 10, 6            435:                   ins              $21,$23,10,6            /* Set current IPL */
9D000458  40956000   MTC0 S5, Status              436:                   mtc0             $21,CP0_STATUS          /* Write status back */
9D00045C  000000C0   EHB                          437:                   ehb
                                                  438:                   /* Save mutiply/divide registers */
9D000460  0000B810   MFHI S7                      439:                   mfhi             $23
9D000464  0000B012   MFLO S6                      440:                   mflo             $22
9D000468  AE97006C   SW S7, 108(S4)               441:                   sw               $23,108($20)
9D00046C  AE960068   SW S6, 104(S4)               442:                   sw               $22,104($20)
                                                  443:                   /* Save "kernel only" registers - we do not expect the user to abide by the rule */
9D000470  AE9C0064   SW GP, 100(S4)               444:                   sw               $28,100($20)
9D000474  AE9B0060   SW K1, 96(S4)                445:                   sw               $27,96($20)
9D000478  AE9A005C   SW K0, 92(S4)                446:                   sw               $26,92($20)
                                                  447:                   /* Save everything else */
9D00047C  AE9F0058   SW RA, 88(S4)                448:                   sw               $31,88($20)
9D000480  AE9E0054   SW FP, 84(S4)                449:                   sw               $30,84($20)
9D000484  AE990050   SW T9, 80(S4)                450:                   sw               $25,80($20)
9D000488  AE98004C   SW T8, 76(S4)                451:                   sw               $24,76($20)
9D00048C  AE930048   SW S3, 72(S4)                452:                   sw               $19,72($20)
9D000490  AE920044   SW S2, 68(S4)                453:                   sw               $18,68($20)
9D000494  AE910040   SW S1, 64(S4)                454:                   sw               $17,64($20)
9D000498  AE90003C   SW S0, 60(S4)                455:                   sw               $16,60($20)
9D00049C  AE8F0038   SW T7, 56(S4)                456:                   sw               $15,56($20)
9D0004A0  AE8E0034   SW T6, 52(S4)                457:                   sw               $14,52($20)
9D0004A4  AE8D0030   SW T5, 48(S4)                458:                   sw               $13,48($20)
9D0004A8  AE8C002C   SW T4, 44(S4)                459:                   sw               $12,44($20)
9D0004AC  AE8B0028   SW T3, 40(S4)                460:                   sw               $11,40($20)
9D0004B0  AE8A0024   SW T2, 36(S4)                461:                   sw               $10,36($20)
9D0004B4  AE890020   SW T1, 32(S4)                462:                   sw               $9,32($20)
9D0004B8  AE88001C   SW T0, 28(S4)                463:                   sw               $8,28($20)
9D0004BC  AE870018   SW A3, 24(S4)                464:                   sw               $7,24($20)
9D0004C0  AE860014   SW A2, 20(S4)                465:                   sw               $6,20($20)
9D0004C4  AE850010   SW A1, 16(S4)                466:                   sw               $5,16($20)
9D0004C8  AE84000C   SW A0, 12(S4)                467:                   sw               $4,12($20)
9D0004CC  AE830008   SW V1, 8(S4)                 468:                   sw               $3,8($20)
9D0004D0  AE820004   SW V0, 4(S4)                 469:                   sw               $2,4($20)
9D0004D4  AE810000   SW AT, 0(S4)                 470:                   sw               $1,0($20)
                                                  471:                   
                                                  472:                   /* Save the SP to control block */
9D0004D8  3C048000   LUI A0, -32768               473:                   lui              $a0,%hi(RMP_SP_Cur)
9D0004DC  348403F8   ORI A0, A0, 1016             474:                   ori              $a0,$a0,%lo(RMP_SP_Cur)
9D0004E0  AC940000   SW S4, 0(A0)                 475:                   sw               $20,($a0)
                                                  476:                   /* Now load our own gp for system use */
9D0004E4  3C1C8000   LUI GP, -32768               477:                   lui              $gp,%hi(RMP_GP_Val)
9D0004E8  379C0404   ORI GP, GP, 1028             478:                   ori              $gp,$gp,%lo(RMP_GP_Val)
9D0004EC  8F9C0000   LW GP, 0(GP)                 479:                   lw               $gp,($gp)
                                                  480:                   /* Save extra registers */
9D0004F0  0F400DB3   JAL 0x9D0036CC               481:                   jal              RMP_Ctx_Save
9D0004F4  00000000   NOP                          482:                   nop
                                                  483:                   /* Get the highest priority ready task */
9D0004F8  0F40036A   JAL 0x9D000DA8               484:                   jal              _RMP_Run_High
9D0004FC  00000000   NOP                          485:                   nop
                                                  486:                   /* Restore extra registers */
9D000500  0F400DB5   JAL 0x9D0036D4               487:                   jal              RMP_Ctx_Load
9D000504  00000000   NOP                          488:                   nop
                                                  489:                   /* Load the SP from control block */
9D000508  3C048000   LUI A0, -32768               490:                   lui              $a0,%hi(RMP_SP_Cur)
9D00050C  348403F8   ORI A0, A0, 1016             491:                   ori              $a0,$a0, %lo(RMP_SP_Cur)
9D000510  8C940000   LW S4, 0(A0)                 492:                   lw               $20,($a0)
9D000514  00000000   NOP                          493:                   nop
                                                  494:                   /* Clear the interrupt flag */
9D000518  0F401143   JAL 0x9D00450C               495:                   jal              _RMP_Clear_Soft_Flag
9D00051C  00000000   NOP                          496:                   nop
                                                  497:                   
                                                  498:                   /* Restore everything else */
9D000520  8E810000   LW AT, 0(S4)                 499:                   lw               $1,0($20)
9D000524  8E820004   LW V0, 4(S4)                 500:                   lw               $2,4($20)
9D000528  8E830008   LW V1, 8(S4)                 501:                   lw               $3,8($20)
9D00052C  8E84000C   LW A0, 12(S4)                502:                   lw               $4,12($20)
9D000530  8E850010   LW A1, 16(S4)                503:                   lw               $5,16($20)
9D000534  8E860014   LW A2, 20(S4)                504:                   lw               $6,20($20)
9D000538  8E870018   LW A3, 24(S4)                505:                   lw               $7,24($20)
9D00053C  8E88001C   LW T0, 28(S4)                506:                   lw               $8,28($20)
9D000540  8E890020   LW T1, 32(S4)                507:                   lw               $9,32($20)
9D000544  8E8A0024   LW T2, 36(S4)                508:                   lw               $10,36($20)
9D000548  8E8B0028   LW T3, 40(S4)                509:                   lw               $11,40($20)
9D00054C  8E8C002C   LW T4, 44(S4)                510:                   lw               $12,44($20)
9D000550  8E8D0030   LW T5, 48(S4)                511:                   lw               $13,48($20)
9D000554  8E8E0034   LW T6, 52(S4)                512:                   lw               $14,52($20)
9D000558  8E8F0038   LW T7, 56(S4)                513:                   lw               $15,56($20)
9D00055C  8E90003C   LW S0, 60(S4)                514:                   lw               $16,60($20)
9D000560  8E910040   LW S1, 64(S4)                515:                   lw               $17,64($20)
9D000564  8E920044   LW S2, 68(S4)                516:                   lw               $18,68($20)
9D000568  8E930048   LW S3, 72(S4)                517:                   lw               $19,72($20)
9D00056C  8E98004C   LW T8, 76(S4)                518:                   lw               $24,76($20)
9D000570  8E990050   LW T9, 80(S4)                519:                   lw               $25,80($20)
9D000574  8E9E0054   LW FP, 84(S4)                520:                   lw               $30,84($20)
9D000578  8E9F0058   LW RA, 88(S4)                521:                   lw               $31,88($20)
                                                  522:                   /* Restore "kernel only" registers */
9D00057C  8E9A005C   LW K0, 92(S4)                523:                   lw               $26,92($20)
9D000580  8E9B0060   LW K1, 96(S4)                524:                   lw               $27,96($20)
9D000584  8E9C0064   LW GP, 100(S4)               525:                   lw               $28,100($20)
                                                  526:                   /* Restore mutiply/divide registers */
9D000588  8E960068   LW S6, 104(S4)               527:                   lw               $22,104($20)
9D00058C  8E97006C   LW S7, 108(S4)               528:                   lw               $23,108($20)
9D000590  02C00013   MTLO S6                      529:                   mtlo             $22
9D000594  02E00011   MTHI S7                      530:                   mthi             $23
                                                  531:                   /* Protect access to c0 registers */
9D000598  41606000   DI ZERO                      532:                   di
9D00059C  000000C0   EHB                          533:                   ehb
                                                  534:                   /* Switch back to the user stack */
9D0005A0  0280E821   ADDU SP, S4, ZERO            535:                   move             $sp,$20
                                                  536:                   /* Decrease interrupt nesting count */
9D0005A4  3C178000   LUI S7, -32768               537:                   lui              $23,%hi(RMP_Int_Nest)
9D0005A8  36F70408   ORI S7, S7, 1032             538:                   ori              $23,$23,%lo(RMP_Int_Nest)
9D0005AC  8EF60000   LW S6, 0(S7)                 539:                   lw               $22,($23)
9D0005B0  00000000   NOP                          540:                   nop
9D0005B4  26D5FFFF   ADDIU S5, S6, -1             541:                   addiu            $21,$22,-1
9D0005B8  AEF50000   SW S5, 0(S7)                 542:                   sw               $21,($23)
                                                  543:                   /* Restore all status registers, except for CAUSE */
9D0005BC  8E950070   LW S5, 112(S4)               544:                   lw               $21,112($20)
9D0005C0  8E970074   LW S7, 116(S4)               545:                   lw               $23,116($20)
9D0005C4  40977000   MTC0 S7, EPC                 546:                   mtc0             $23,CP0_EPC
                                                  547:                   /* Make sure status is recovered at last */
9D0005C8  40956000   MTC0 S5, Status              548:   	            mtc0             $21,CP0_STATUS
                                                  549:                   /* Restore four temporary regs */
9D0005CC  8FB40078   LW S4, 120(SP)               550:                   lw               $20,120($sp)
9D0005D0  8FB5007C   LW S5, 124(SP)               551:                   lw               $21,124($sp)
9D0005D4  8FB60080   LW S6, 128(SP)               552:                   lw               $22,128($sp)
9D0005D8  8FB70084   LW S7, 132(SP)               553:                   lw               $23,132($sp)
                                                  554:                   /* Restore the SP */
9D0005DC  27BD0088   ADDIU SP, SP, 136            555:                   addiu            $sp,$sp,CTX_SIZE
9D0005E0  42000018   ERET                         556:                   eret
9D0005E4  00000000   NOP                          557:                   nop
                                                  558:                   .end             PendSV_Handler
                                                  559:   /* End Function:PendSV_Handler ***********************************************/
                                                  560:   
                                                  561:   /* Begin Function:SysTick_Handler *********************************************
                                                  562:   Description : The SysTick interrupt routine. In fact, it will call a C function
                                                  563:                 directly. The reason why the interrupt routine must be an assembly
                                                  564:                 function is that the compiler may deal with the stack in a different 
                                                  565:                 way when different optimization level is chosen. An assembly function
                                                  566:                 can make way around this problem.
                                                  567:                 However, if your compiler support inline assembly functions, this
                                                  568:                 can also be written in C.
                                                  569:   Input       : None.
                                                  570:   Output      : None.                                      
                                                  571:   ******************************************************************************/
                                                  572:                  	.set             nomips16
                                                  573:                   .set             nomicromips
                                                  574:                   .set             noreorder
                                                  575:                   .set             noat
                                                  576:                   .equ             __vector_dispatch_0,SysTick_Handler
                                                  577:                   .global          __vector_dispatch_0
                                                  578:                   .section         .vector_0,code,keep
                                                  579:                   .ent             SysTick_Handler
                                                  580:   SysTick_Handler:
                                                  581:                   /* Note the system that we have entered an interrupt. We are not using tickless */
9D000200  27BDFF78   ADDIU SP, SP, -136           582:                   SAVE_CONTEXT
                                                  583:                   
9D0002F8  24040001   ADDIU A0, ZERO, 1            584:                   li               $a0,1
9D0002FC  0F4003AD   JAL 0x9D000EB4               585:                   jal              _RMP_Tick_Handler
9D000300  00000000   NOP                          586:                   nop
                                                  587:                   /* Clear the interrupt flag */
9D000304  0F401148   JAL 0x9D004520               588:                   jal              _RMP_Clear_Timer_Flag
9D000308  00000000   NOP                          589:                   nop
                                                  590:                   
9D00030C  41606000   DI ZERO                      591:                   LOAD_CONTEXT
                                                  592:                   .end SysTick_Handler
                                                  593:   /* End Function:SysTick_Handler **********************************************/
                                                  594:                   
                                                  595:   /* End Of File ***************************************************************/
                                                  596:   
                                                  597:   /* Copyright (C) Evo-Devo Instrum. All rights reserved ***********************/
---  F:/Code_Library/MCU/Mutatus/M5P1_MuProkaron/MProkaron/Benchmark/Platform/test_PIC32MZ2048EFM100_extra.s
                                                  1:     /******************************************************************************
                                                  2:     Filename    : test_PIC32MZ2048EFM100_extra.s
                                                  3:     Author      : pry
                                                  4:     Date        : 10/04/2012
                                                  5:     Description : The extra testing file for this chip.
                                                  6:     ******************************************************************************/
                                                  7:         
                                                  8:     /* Begin Header **************************************************************/
                                                  9:                     .text
                                                  10:                    .align 4
                                                  11:    /* End Header ****************************************************************/
                                                  12:    
                                                  13:    /* Begin Imports *************************************************************/
                                                  14:                    /* The place where we store the kernel gp/sp value */
                                                  15:                    .extern          RMP_GP_Val
                                                  16:                    .extern          RMP_SP_Val
                                                  17:                    /* The interrupt nesting value */
                                                  18:                    .extern          RMP_Int_Nest
                                                  19:                    /* The extra routine */
                                                  20:                    .extern          Tim2_Interrupt    
                                                  21:    /* End Imports ***************************************************************/
                                                  22:    
                                                  23:    /* Begin Macros **************************************************************/
                                                  24:                    .equ             CP0_COUNT,$9
                                                  25:                    .equ             CP0_COMPARE,$11
                                                  26:                    .equ             CP0_STATUS,$12
                                                  27:                    .equ             CP0_CAUSE,$13
                                                  28:                    .equ             CP0_EPC,$14
                                                  29:                    .equ             CTX_SIZE,136
                                                  30:                    .equ             CORE_SW0,0x100
                                                  31:    /* Interrupt context - this is for generic support. These interrupts should not use DSP & FPU */
                                                  32:    .macro	SAVE_CONTEXT
                                                  33:                    /* Make room for the context */
                                                  34:                    addiu            $sp,$sp,-CTX_SIZE
                                                  35:                    /* Save three regs first so that we can enable interrupts as soon as possible */
                                                  36:                    sw               $23,132($sp)
                                                  37:                    sw               $22,128($sp)
                                                  38:                    sw               $21,124($sp)
                                                  39:                    sw               $20,120($sp)
                                                  40:                    /* Increase interrupt nesting count */
                                                  41:                    lui              $23,%hi(RMP_Int_Nest)
                                                  42:                    ori              $23,$23,%lo(RMP_Int_Nest)
                                                  43:                    lw               $22,($23)
                                                  44:                    nop
                                                  45:                    addiu            $21,$22,1
                                                  46:                    sw               $21,($23)
                                                  47:                    /* Branch taken when already in system stack */
                                                  48:                    bne              $22,$0,1f 
                                                  49:                    nop
                                                  50:                    /* Need to save the old sp first */
                                                  51:                    lui              $23,%hi(RMP_Old_SP_Val)
                                                  52:                    ori              $23,$23,%lo(RMP_Old_SP_Val)
                                                  53:                    sw               $sp,($23)
                                                  54:                    move             $20,$sp
                                                  55:                    /* We need to swap to system stack for execution */
                                                  56:                    lui              $23,%hi(RMP_SP_Val)
                                                  57:                    ori              $23,$23,%lo(RMP_SP_Val)
                                                  58:                    lw               $sp,($23)
                                                  59:                    b                2f
                                                  60:                    nop
                                                  61:    1:              move             $20,$sp
                                                  62:                    /* Save all status registers, except for CAUSE */
                                                  63:    2:              mfc0             $23,CP0_EPC
                                                  64:                    mfc0             $22,CP0_CAUSE
                                                  65:    	            mfc0             $21,CP0_STATUS
                                                  66:                    sw               $23,116($20)
                                                  67:                    sw               $21,112($20)
                                                  68:                    /* Now we reenable interrupts */
                                                  69:                    ins              $21,$0,1,15             /* Clear IPL, UM, ERL, EXL from STATUS */
                                                  70:                    ext              $23,$22,10,6            /* Extract RIPL from CAUSE */
                                                  71:                    ins              $21,$23,10,6            /* Set current IPL */
                                                  72:                    mtc0             $21,CP0_STATUS          /* Write status back */
                                                  73:                    /* Save mutiply/divide registers */
                                                  74:                    mfhi             $23
                                                  75:                    mflo             $22
                                                  76:                    sw               $23,108($20)
                                                  77:                    sw               $22,104($20)
                                                  78:                    /* Save "kernel only" registers - we do not expect the user to abide by the rule */
                                                  79:                    sw               $28,100($20)
                                                  80:                    sw               $27,96($20)
                                                  81:                    sw               $26,92($20)
                                                  82:                    /* Save everything else */
                                                  83:                    sw               $31,88($20)
                                                  84:                    sw               $30,84($20)
                                                  85:                    sw               $25,80($20)
                                                  86:                    sw               $24,76($20)
                                                  87:                    sw               $19,72($20)
                                                  88:                    sw               $18,68($20)
                                                  89:                    sw               $17,64($20)
                                                  90:                    sw               $16,60($20)
                                                  91:                    sw               $15,56($20)
                                                  92:                    sw               $14,52($20)
                                                  93:                    sw               $13,48($20)
                                                  94:                    sw               $12,44($20)
                                                  95:                    sw               $11,40($20)
                                                  96:                    sw               $10,36($20)
                                                  97:                    sw               $9,32($20)
                                                  98:                    sw               $8,28($20)
                                                  99:                    sw               $7,24($20)
                                                  100:                   sw               $6,20($20)
                                                  101:                   sw               $5,16($20)
                                                  102:                   sw               $4,12($20)
                                                  103:                   sw               $3,8($20)
                                                  104:                   sw               $2,4($20)
                                                  105:                   sw               $1,0($20)
                                                  106:   .endm
                                                  107:                   
                                                  108:                   /* Context restoring */
                                                  109:   .macro LOAD_CONTEXT
                                                  110:                   /* Protect access to c0 registers */
                                                  111:                   di
                                                  112:                   ehb
                                                  113:                   /* Decrease interrupt nesting count */
                                                  114:                   lui              $23,%hi(RMP_Int_Nest)
                                                  115:                   ori              $23,$23,%lo(RMP_Int_Nest)
                                                  116:                   lw               $22,($23)
                                                  117:                   nop
                                                  118:                   addiu            $21,$22,-1
                                                  119:                   sw               $21,($23)
                                                  120:                   /* Branch taken when going to return to user stack */
                                                  121:                   bne              $21,$0,1f 
                                                  122:                   nop
                                                  123:                   /* Need to load back the old sp */
                                                  124:                   lui              $23,%hi(RMP_Old_SP_Val)
                                                  125:                   ori              $23,$23,%lo(RMP_Old_SP_Val)
                                                  126:                   lw               $sp,($23)
                                                  127:                   nop
                                                  128:   1:              move             $20,$sp
                                                  129:                   /* Restore all status registers, except for CAUSE */
                                                  130:                   lw               $21,112($20)
                                                  131:                   lw               $23,116($20)
                                                  132:                   mtc0             $23,CP0_EPC
                                                  133:                   /* Make sure status is recovered at last */
                                                  134:   	            mtc0             $21,CP0_STATUS
                                                  135:                   /* Restore everything else */
                                                  136:                   lw               $1,0($20)
                                                  137:                   lw               $2,4($20)
                                                  138:                   lw               $3,8($20)
                                                  139:                   lw               $4,12($20)
                                                  140:                   lw               $5,16($20)
                                                  141:                   lw               $6,20($20)
                                                  142:                   lw               $7,24($20)
                                                  143:                   lw               $8,28($20)
                                                  144:                   lw               $9,32($20)
                                                  145:                   lw               $10,36($20)
                                                  146:                   lw               $11,40($20)
                                                  147:                   lw               $12,44($20)
                                                  148:                   lw               $13,48($20)
                                                  149:                   lw               $14,52($20)
                                                  150:                   lw               $15,56($20)
                                                  151:                   lw               $16,60($20)
                                                  152:                   lw               $17,64($20)
                                                  153:                   lw               $18,68($20)
                                                  154:                   lw               $19,72($20)
                                                  155:                   lw               $24,76($20)
                                                  156:                   lw               $25,80($20)
                                                  157:                   lw               $30,84($20)
                                                  158:                   lw               $31,88($20)
                                                  159:                   /* Restore "kernel only" registers */
                                                  160:                   lw               $26,92($20)
                                                  161:                   lw               $27,96($20)
                                                  162:                   lw               $28,100($20)
                                                  163:                   /* Restore mutiply/divide registers */
                                                  164:                   lw               $22,104($20)
                                                  165:                   lw               $23,108($20)
                                                  166:                   mtlo             $22
                                                  167:                   mthi             $23
                                                  168:                   /* Restore four temporary regs */
                                                  169:                   lw               $20,120($sp)
                                                  170:                   lw               $21,124($sp)
                                                  171:                   lw               $22,128($sp)
                                                  172:                   lw               $23,132($sp)
                                                  173:                   /* Restore the SP */
                                                  174:                   addiu            $sp,$sp,CTX_SIZE
                                                  175:                   eret
                                                  176:                   nop
                                                  177:   .endm
                                                  178:   /* End Macros ****************************************************************/
                                                  179:   
                                                  180:   /* Begin Function:Tim2_Handler ************************************************
                                                  181:   Description : The timer 2 interrupt routine.
                                                  182:   Input       : None.
                                                  183:   Output      : None.                                      
                                                  184:   ******************************************************************************/
                                                  185:                   .set             nomips16
                                                  186:                   .set             nomicromips
                                                  187:                   .set             noreorder
                                                  188:                   .set             noat
                                                  189:                   .equ             __vector_dispatch_9,Tim2_Handler
                                                  190:                   .global          __vector_dispatch_9
                                                  191:                   .section         .vector_9,code,keep
                                                  192:                   .ent             Tim2_Handler
                                                  193:   Tim2_Handler:
                                                  194:                   /* Note the system that we have entered an interrupt. We are not using tickless */
9D0005E8  27BDFF78   ADDIU SP, SP, -136           195:                   SAVE_CONTEXT
                                                  196:                   
9D0006E0  0F400E15   JAL 0x9D003854               197:                   jal              Tim2_Interrupt
9D0006E4  00000000   NOP                          198:                   nop
                                                  199:                   
9D0006E8  41606000   DI ZERO                      200:                   LOAD_CONTEXT
                                                  201:                   .end Tim2_Handler
                                                  202:   /* End Function:Tim2_Handler *************************************************/
                                                  203:   
                                                  204:   /* End Of File ***************************************************************/
                                                  205:   
                                                  206:   /* Copyright (C) Evo-Devo Instrum. All rights reserved ***********************/
