; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f4xx_tim.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f4xx_tim.d --cpu=Cortex-M4.fp --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\M0P0_Library\STM32F4xx_StdPeriph_Driver\CMSIS\ST\STM32F4xx\Include -I..\..\..\M0P0_Library\STM32F4xx_StdPeriph_Driver\CMSIS\Include -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F405RGT6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.11.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F405xx -DSTM32F4XX -DUSE_STDPERIPH_DRIVER -DHSE_VALUE=8000000 -DPLL_M=8 --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f4xx_tim.crf ..\..\..\M0P0_Library\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_tim.c]
                          THUMB

                          AREA ||i.TIM_ARRPreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_ARRPreloadConfig PROC
;;;515      */
;;;516    void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;517    {
;;;518      /* Check the parameters */
;;;519      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;520      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;521    
;;;522      if (NewState != DISABLE)
;;;523      {
;;;524        /* Set the ARR Preload Bit */
;;;525        TIMx->CR1 |= TIM_CR1_ARPE;
;;;526      }
;;;527      else
;;;528      {
;;;529        /* Reset the ARR Preload Bit */
;;;530        TIMx->CR1 &= (uint16_t)~TIM_CR1_ARPE;
000002  8801              LDRH     r1,[r0,#0]
000004  bf14              ITE      NE                    ;525
000006  f0410180          ORRNE    r1,r1,#0x80           ;525
00000a  f0210180          BICEQ    r1,r1,#0x80
00000e  8001              STRH     r1,[r0,#0]            ;525
;;;531      }
;;;532    }
000010  4770              BX       lr
;;;533    
                          ENDP


                          AREA ||i.TIM_BDTRConfig||, CODE, READONLY, ALIGN=1

                  TIM_BDTRConfig PROC
;;;2210     */
;;;2211   void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
000000  880a              LDRH     r2,[r1,#0]
;;;2212   {
;;;2213     /* Check the parameters */
;;;2214     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2215     assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
;;;2216     assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
;;;2217     assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
;;;2218     assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
;;;2219     assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
;;;2220     assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
;;;2221   
;;;2222     /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
;;;2223        the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;2224     TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
000002  884b              LDRH     r3,[r1,#2]
000004  f8b1c006          LDRH     r12,[r1,#6]
000008  431a              ORRS     r2,r2,r3
00000a  888b              LDRH     r3,[r1,#4]
00000c  ea43030c          ORR      r3,r3,r12
000010  431a              ORRS     r2,r2,r3
000012  890b              LDRH     r3,[r1,#8]
000014  431a              ORRS     r2,r2,r3
000016  894b              LDRH     r3,[r1,#0xa]
000018  8989              LDRH     r1,[r1,#0xc]
00001a  431a              ORRS     r2,r2,r3
00001c  4311              ORRS     r1,r1,r2
00001e  f8a01044          STRH     r1,[r0,#0x44]
;;;2225                TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
;;;2226                TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
;;;2227                TIM_BDTRInitStruct->TIM_AutomaticOutput;
;;;2228   }
000022  4770              BX       lr
;;;2229   
                          ENDP


                          AREA ||i.TIM_BDTRStructInit||, CODE, READONLY, ALIGN=1

                  TIM_BDTRStructInit PROC
;;;2235     */
;;;2236   void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
000000  2100              MOVS     r1,#0
;;;2237   {
;;;2238     /* Set the default configuration */
;;;2239     TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
000002  8001              STRH     r1,[r0,#0]
;;;2240     TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;2241     TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
000006  8081              STRH     r1,[r0,#4]
;;;2242     TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
000008  80c1              STRH     r1,[r0,#6]
;;;2243     TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
00000a  8101              STRH     r1,[r0,#8]
;;;2244     TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
00000c  8141              STRH     r1,[r0,#0xa]
;;;2245     TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
00000e  8181              STRH     r1,[r0,#0xc]
;;;2246   }
000010  4770              BX       lr
;;;2247   
                          ENDP


                          AREA ||i.TIM_CCPreloadControl||, CODE, READONLY, ALIGN=1

                  TIM_CCPreloadControl PROC
;;;2304     */
;;;2305   void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;2306   { 
;;;2307     /* Check the parameters */
;;;2308     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2309     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2310     if (NewState != DISABLE)
;;;2311     {
;;;2312       /* Set the CCPC Bit */
;;;2313       TIMx->CR2 |= TIM_CR2_CCPC;
;;;2314     }
;;;2315     else
;;;2316     {
;;;2317       /* Reset the CCPC Bit */
;;;2318       TIMx->CR2 &= (uint16_t)~TIM_CR2_CCPC;
000002  8881              LDRH     r1,[r0,#4]
000004  bf14              ITE      NE                    ;2313
000006  f0410101          ORRNE    r1,r1,#1              ;2313
00000a  f0210101          BICEQ    r1,r1,#1
00000e  8081              STRH     r1,[r0,#4]            ;2313
;;;2319     }
;;;2320   }
000010  4770              BX       lr
;;;2321   /**
                          ENDP


                          AREA ||i.TIM_CCxCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxCmd PROC
;;;1777     */
;;;1778   void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
000000  2301              MOVS     r3,#1
;;;1779   {
;;;1780     uint16_t tmp = 0;
;;;1781   
;;;1782     /* Check the parameters */
;;;1783     assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
;;;1784     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;1785     assert_param(IS_TIM_CCX(TIM_CCx));
;;;1786   
;;;1787     tmp = CCER_CCE_SET << TIM_Channel;
;;;1788   
;;;1789     /* Reset the CCxE Bit */
;;;1790     TIMx->CCER &= (uint16_t)~ tmp;
000002  f8b0c020          LDRH     r12,[r0,#0x20]
000006  408b              LSLS     r3,r3,r1              ;1787
000008  ea2c0303          BIC      r3,r12,r3
00000c  8403              STRH     r3,[r0,#0x20]
;;;1791   
;;;1792     /* Set or reset the CCxE Bit */ 
;;;1793     TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
00000e  8c03              LDRH     r3,[r0,#0x20]
000010  fa02f101          LSL      r1,r2,r1
000014  4319              ORRS     r1,r1,r3
000016  8401              STRH     r1,[r0,#0x20]
;;;1794   }
000018  4770              BX       lr
;;;1795   
                          ENDP


                          AREA ||i.TIM_CCxNCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxNCmd PROC
;;;1807     */
;;;1808   void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
000000  2304              MOVS     r3,#4
;;;1809   {
;;;1810     uint16_t tmp = 0;
;;;1811   
;;;1812     /* Check the parameters */
;;;1813     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1814     assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
;;;1815     assert_param(IS_TIM_CCXN(TIM_CCxN));
;;;1816   
;;;1817     tmp = CCER_CCNE_SET << TIM_Channel;
;;;1818   
;;;1819     /* Reset the CCxNE Bit */
;;;1820     TIMx->CCER &= (uint16_t) ~tmp;
000002  f8b0c020          LDRH     r12,[r0,#0x20]
000006  408b              LSLS     r3,r3,r1              ;1817
000008  ea2c0303          BIC      r3,r12,r3
00000c  8403              STRH     r3,[r0,#0x20]
;;;1821   
;;;1822     /* Set or reset the CCxNE Bit */ 
;;;1823     TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
00000e  8c03              LDRH     r3,[r0,#0x20]
000010  fa02f101          LSL      r1,r2,r1
000014  4319              ORRS     r1,r1,r3
000016  8401              STRH     r1,[r0,#0x20]
;;;1824   }
000018  4770              BX       lr
;;;1825   /**
                          ENDP


                          AREA ||i.TIM_ClearFlag||, CODE, READONLY, ALIGN=1

                  TIM_ClearFlag PROC
;;;2474     */
;;;2475   void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000000  43c9              MVNS     r1,r1
;;;2476   {  
;;;2477     /* Check the parameters */
;;;2478     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2479      
;;;2480     /* Clear the flags */
;;;2481     TIMx->SR = (uint16_t)~TIM_FLAG;
000002  8201              STRH     r1,[r0,#0x10]
;;;2482   }
000004  4770              BX       lr
;;;2483   
                          ENDP


                          AREA ||i.TIM_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  TIM_ClearITPendingBit PROC
;;;2543     */
;;;2544   void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000000  43c9              MVNS     r1,r1
;;;2545   {
;;;2546     /* Check the parameters */
;;;2547     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2548   
;;;2549     /* Clear the IT pending Bit */
;;;2550     TIMx->SR = (uint16_t)~TIM_IT;
000002  8201              STRH     r1,[r0,#0x10]
;;;2551   }
000004  4770              BX       lr
;;;2552   
                          ENDP


                          AREA ||i.TIM_ClearOC1Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC1Ref PROC
;;;1467     */
;;;1468   void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1469   {
;;;1470     uint16_t tmpccmr1 = 0;
;;;1471   
;;;1472     /* Check the parameters */
;;;1473     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1474     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1475   
;;;1476     tmpccmr1 = TIMx->CCMR1;
;;;1477   
;;;1478     /* Reset the OC1CE Bit */
;;;1479     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1CE;
000002  f0220280          BIC      r2,r2,#0x80
;;;1480   
;;;1481     /* Enable or Disable the Output Compare Clear Bit */
;;;1482     tmpccmr1 |= TIM_OCClear;
000006  4311              ORRS     r1,r1,r2
;;;1483   
;;;1484     /* Write to TIMx CCMR1 register */
;;;1485     TIMx->CCMR1 = tmpccmr1;
000008  8301              STRH     r1,[r0,#0x18]
;;;1486   }
00000a  4770              BX       lr
;;;1487   
                          ENDP


                          AREA ||i.TIM_ClearOC2Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC2Ref PROC
;;;1497     */
;;;1498   void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1499   {
;;;1500     uint16_t tmpccmr1 = 0;
;;;1501   
;;;1502     /* Check the parameters */
;;;1503     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1504     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1505   
;;;1506     tmpccmr1 = TIMx->CCMR1;
;;;1507   
;;;1508     /* Reset the OC2CE Bit */
;;;1509     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2CE;
;;;1510   
;;;1511     /* Enable or Disable the Output Compare Clear Bit */
;;;1512     tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f3c2020e          UBFX     r2,r2,#0,#15          ;1509
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1513   
;;;1514     /* Write to TIMx CCMR1 register */
;;;1515     TIMx->CCMR1 = tmpccmr1;
000010  8301              STRH     r1,[r0,#0x18]
;;;1516   }
000012  4770              BX       lr
;;;1517   
                          ENDP


                          AREA ||i.TIM_ClearOC3Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC3Ref PROC
;;;1526     */
;;;1527   void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1528   {
;;;1529     uint16_t tmpccmr2 = 0;
;;;1530   
;;;1531     /* Check the parameters */
;;;1532     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1533     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1534   
;;;1535     tmpccmr2 = TIMx->CCMR2;
;;;1536   
;;;1537     /* Reset the OC3CE Bit */
;;;1538     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3CE;
000002  f0220280          BIC      r2,r2,#0x80
;;;1539   
;;;1540     /* Enable or Disable the Output Compare Clear Bit */
;;;1541     tmpccmr2 |= TIM_OCClear;
000006  4311              ORRS     r1,r1,r2
;;;1542   
;;;1543     /* Write to TIMx CCMR2 register */
;;;1544     TIMx->CCMR2 = tmpccmr2;
000008  8381              STRH     r1,[r0,#0x1c]
;;;1545   }
00000a  4770              BX       lr
;;;1546   
                          ENDP


                          AREA ||i.TIM_ClearOC4Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC4Ref PROC
;;;1555     */
;;;1556   void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1557   {
;;;1558     uint16_t tmpccmr2 = 0;
;;;1559   
;;;1560     /* Check the parameters */
;;;1561     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1562     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1563   
;;;1564     tmpccmr2 = TIMx->CCMR2;
;;;1565   
;;;1566     /* Reset the OC4CE Bit */
;;;1567     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4CE;
;;;1568   
;;;1569     /* Enable or Disable the Output Compare Clear Bit */
;;;1570     tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f3c2020e          UBFX     r2,r2,#0,#15          ;1567
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1571   
;;;1572     /* Write to TIMx CCMR2 register */
;;;1573     TIMx->CCMR2 = tmpccmr2;
000010  8381              STRH     r1,[r0,#0x1c]
;;;1574   }
000012  4770              BX       lr
;;;1575   
                          ENDP


                          AREA ||i.TIM_Cmd||, CODE, READONLY, ALIGN=1

                  TIM_Cmd PROC
;;;585      */
;;;586    void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;587    {
;;;588      /* Check the parameters */
;;;589      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;590      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;591      
;;;592      if (NewState != DISABLE)
;;;593      {
;;;594        /* Enable the TIM Counter */
;;;595        TIMx->CR1 |= TIM_CR1_CEN;
;;;596      }
;;;597      else
;;;598      {
;;;599        /* Disable the TIM Counter */
;;;600        TIMx->CR1 &= (uint16_t)~TIM_CR1_CEN;
000002  8801              LDRH     r1,[r0,#0]
000004  bf14              ITE      NE                    ;595
000006  f0410101          ORRNE    r1,r1,#1              ;595
00000a  f0210101          BICEQ    r1,r1,#1
00000e  8001              STRH     r1,[r0,#0]            ;595
;;;601      }
;;;602    }
000010  4770              BX       lr
;;;603    /**
                          ENDP


                          AREA ||i.TIM_CounterModeConfig||, CODE, READONLY, ALIGN=1

                  TIM_CounterModeConfig PROC
;;;376      */
;;;377    void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
000000  8802              LDRH     r2,[r0,#0]
;;;378    {
;;;379      uint16_t tmpcr1 = 0;
;;;380    
;;;381      /* Check the parameters */
;;;382      assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;383      assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
;;;384    
;;;385      tmpcr1 = TIMx->CR1;
;;;386    
;;;387      /* Reset the CMS and DIR Bits */
;;;388      tmpcr1 &= (uint16_t)~(TIM_CR1_DIR | TIM_CR1_CMS);
000002  f0220270          BIC      r2,r2,#0x70
;;;389    
;;;390      /* Set the Counter Mode */
;;;391      tmpcr1 |= TIM_CounterMode;
000006  4311              ORRS     r1,r1,r2
;;;392    
;;;393      /* Write to TIMx CR1 register */
;;;394      TIMx->CR1 = tmpcr1;
000008  8001              STRH     r1,[r0,#0]
;;;395    }
00000a  4770              BX       lr
;;;396    
                          ENDP


                          AREA ||i.TIM_CtrlPWMOutputs||, CODE, READONLY, ALIGN=1

                  TIM_CtrlPWMOutputs PROC
;;;2254     */
;;;2255   void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;2256   {
;;;2257     /* Check the parameters */
;;;2258     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2259     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2260   
;;;2261     if (NewState != DISABLE)
;;;2262     {
;;;2263       /* Enable the TIM Main Output */
;;;2264       TIMx->BDTR |= TIM_BDTR_MOE;
;;;2265     }
;;;2266     else
;;;2267     {
;;;2268       /* Disable the TIM Main Output */
;;;2269       TIMx->BDTR &= (uint16_t)~TIM_BDTR_MOE;
000002  f8b01044          LDRH     r1,[r0,#0x44]
000006  bf14              ITE      NE                    ;2264
000008  f4414100          ORRNE    r1,r1,#0x8000         ;2264
00000c  f3c1010e          UBFXEQ   r1,r1,#0,#15
000010  f8a01044          STRH     r1,[r0,#0x44]         ;2264
;;;2270     }  
;;;2271   }
000014  4770              BX       lr
;;;2272   
                          ENDP


                          AREA ||i.TIM_DMACmd||, CODE, READONLY, ALIGN=1

                  TIM_DMACmd PROC
;;;2607     */
;;;2608   void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;2609   { 
;;;2610     /* Check the parameters */
;;;2611     assert_param(IS_TIM_LIST5_PERIPH(TIMx)); 
;;;2612     assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
;;;2613     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2614     
;;;2615     if (NewState != DISABLE)
;;;2616     {
;;;2617       /* Enable the DMA sources */
;;;2618       TIMx->DIER |= TIM_DMASource; 
;;;2619     }
;;;2620     else
;;;2621     {
;;;2622       /* Disable the DMA sources */
;;;2623       TIMx->DIER &= (uint16_t)~TIM_DMASource;
000002  8982              LDRH     r2,[r0,#0xc]
000004  bf14              ITE      NE                    ;2618
000006  4311              ORRNE    r1,r1,r2              ;2618
000008  ea220101          BICEQ    r1,r2,r1
00000c  8181              STRH     r1,[r0,#0xc]          ;2618
;;;2624     }
;;;2625   }
00000e  4770              BX       lr
;;;2626   
                          ENDP


                          AREA ||i.TIM_DMAConfig||, CODE, READONLY, ALIGN=1

                  TIM_DMAConfig PROC
;;;2580     */
;;;2581   void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
000000  4311              ORRS     r1,r1,r2
;;;2582   {
;;;2583     /* Check the parameters */
;;;2584     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2585     assert_param(IS_TIM_DMA_BASE(TIM_DMABase)); 
;;;2586     assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
;;;2587   
;;;2588     /* Set the DMA Base and the DMA Burst Length */
;;;2589     TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
000002  f8a01048          STRH     r1,[r0,#0x48]
;;;2590   }
000006  4770              BX       lr
;;;2591   
                          ENDP


                          AREA ||i.TIM_DeInit||, CODE, READONLY, ALIGN=1

                  TIM_DeInit PROC
;;;193      */
;;;194    void TIM_DeInit(TIM_TypeDef* TIMx)
000000  b510              PUSH     {r4,lr}
;;;195    {
;;;196      /* Check the parameters */
;;;197      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;198     
;;;199      if (TIMx == TIM1)
000002  f1a04180          SUB      r1,r0,#0x40000000
000006  f5b13180          SUBS     r1,r1,#0x10000
00000a  d032              BEQ      |L18.114|
;;;200      {
;;;201        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
;;;202        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
;;;203      } 
;;;204      else if (TIMx == TIM2) 
00000c  f1b04f80          CMP      r0,#0x40000000
000010  d043              BEQ      |L18.154|
;;;205      {     
;;;206        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
;;;207        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
;;;208      }  
;;;209      else if (TIMx == TIM3)
000012  f511417c          ADDS     r1,r1,#0xfc00
000016  d036              BEQ      |L18.134|
;;;210      { 
;;;211        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
;;;212        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
;;;213      }  
;;;214      else if (TIMx == TIM4)
000018  f5b16180          SUBS     r1,r1,#0x400
00001c  d047              BEQ      |L18.174|
;;;215      { 
;;;216        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
;;;217        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
;;;218      }  
;;;219      else if (TIMx == TIM5)
00001e  f5b16180          SUBS     r1,r1,#0x400
000022  d04e              BEQ      |L18.194|
;;;220      {      
;;;221        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
;;;222        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
;;;223      }  
;;;224      else if (TIMx == TIM6)  
000024  f5b16180          SUBS     r1,r1,#0x400
000028  d055              BEQ      |L18.214|
;;;225      {    
;;;226        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
;;;227        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
;;;228      }  
;;;229      else if (TIMx == TIM7)
00002a  f5b16180          SUBS     r1,r1,#0x400
00002e  d05c              BEQ      |L18.234|
;;;230      {      
;;;231        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
;;;232        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
;;;233      }  
;;;234      else if (TIMx == TIM8)
000030  f5b14170          SUBS     r1,r1,#0xf000
000034  d063              BEQ      |L18.254|
;;;235      {      
;;;236        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
;;;237        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
;;;238      }  
;;;239      else if (TIMx == TIM9)
000036  f5b15170          SUBS     r1,r1,#0x3c00
00003a  d06a              BEQ      |L18.274|
;;;240      {      
;;;241        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
;;;242        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
;;;243       }  
;;;244      else if (TIMx == TIM10)
00003c  f5b16180          SUBS     r1,r1,#0x400
000040  d072              BEQ      |L18.296|
;;;245      {      
;;;246        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
;;;247        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
;;;248      }  
;;;249      else if (TIMx == TIM11) 
000042  f5b16180          SUBS     r1,r1,#0x400
000046  d07a              BEQ      |L18.318|
;;;250      {     
;;;251        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
;;;252        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
;;;253      }  
;;;254      else if (TIMx == TIM12)
000048  f5113198          ADDS     r1,r1,#0x13000
00004c  d07d              BEQ      |L18.330|
;;;255      {      
;;;256        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
;;;257        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
;;;258      }  
;;;259      else if (TIMx == TIM13) 
00004e  f5b16180          SUBS     r1,r1,#0x400
000052  d07b              BEQ      |L18.332|
;;;260      {       
;;;261        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
;;;262        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  
;;;263      }  
;;;264      else
;;;265      { 
;;;266        if (TIMx == TIM14) 
000054  f5b16180          SUBS     r1,r1,#0x400
;;;267        {     
;;;268          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
;;;269          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
;;;270        }   
;;;271      }
;;;272    }
000058  bf18              IT       NE
00005a  bd10              POPNE    {r4,pc}
00005c  2101              MOVS     r1,#1                 ;268
00005e  0208              LSLS     r0,r1,#8              ;268
000060  f7fffffe          BL       RCC_APB1PeriphResetCmd
000064  e8bd4010          POP      {r4,lr}               ;269
000068  2100              MOVS     r1,#0                 ;269
00006a  f44f7080          MOV      r0,#0x100             ;269
00006e  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L18.114|
000072  2101              MOVS     r1,#1                 ;201
000074  4608              MOV      r0,r1                 ;201
000076  f7fffffe          BL       RCC_APB2PeriphResetCmd
00007a  2100              MOVS     r1,#0                 ;202
00007c  e8bd4010          POP      {r4,lr}               ;202
000080  2001              MOVS     r0,#1                 ;202
000082  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L18.134|
000086  2101              MOVS     r1,#1                 ;211
000088  2002              MOVS     r0,#2                 ;211
00008a  f7fffffe          BL       RCC_APB1PeriphResetCmd
00008e  2100              MOVS     r1,#0                 ;212
000090  e8bd4010          POP      {r4,lr}               ;212
000094  2002              MOVS     r0,#2                 ;212
000096  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L18.154|
00009a  2101              MOVS     r1,#1                 ;206
00009c  4608              MOV      r0,r1                 ;206
00009e  f7fffffe          BL       RCC_APB1PeriphResetCmd
0000a2  2100              MOVS     r1,#0                 ;207
0000a4  e8bd4010          POP      {r4,lr}               ;207
0000a8  2001              MOVS     r0,#1                 ;207
0000aa  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L18.174|
0000ae  2101              MOVS     r1,#1                 ;216
0000b0  2004              MOVS     r0,#4                 ;216
0000b2  f7fffffe          BL       RCC_APB1PeriphResetCmd
0000b6  2100              MOVS     r1,#0                 ;217
0000b8  e8bd4010          POP      {r4,lr}               ;217
0000bc  2004              MOVS     r0,#4                 ;217
0000be  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L18.194|
0000c2  2101              MOVS     r1,#1                 ;221
0000c4  2008              MOVS     r0,#8                 ;221
0000c6  f7fffffe          BL       RCC_APB1PeriphResetCmd
0000ca  2100              MOVS     r1,#0                 ;222
0000cc  e8bd4010          POP      {r4,lr}               ;222
0000d0  2008              MOVS     r0,#8                 ;222
0000d2  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L18.214|
0000d6  2101              MOVS     r1,#1                 ;226
0000d8  2010              MOVS     r0,#0x10              ;226
0000da  f7fffffe          BL       RCC_APB1PeriphResetCmd
0000de  2100              MOVS     r1,#0                 ;227
0000e0  e8bd4010          POP      {r4,lr}               ;227
0000e4  2010              MOVS     r0,#0x10              ;227
0000e6  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L18.234|
0000ea  2101              MOVS     r1,#1                 ;231
0000ec  2020              MOVS     r0,#0x20              ;231
0000ee  f7fffffe          BL       RCC_APB1PeriphResetCmd
0000f2  2100              MOVS     r1,#0                 ;232
0000f4  e8bd4010          POP      {r4,lr}               ;232
0000f8  2020              MOVS     r0,#0x20              ;232
0000fa  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L18.254|
0000fe  2101              MOVS     r1,#1                 ;236
000100  2002              MOVS     r0,#2                 ;236
000102  f7fffffe          BL       RCC_APB2PeriphResetCmd
000106  2100              MOVS     r1,#0                 ;237
000108  e8bd4010          POP      {r4,lr}               ;237
00010c  2002              MOVS     r0,#2                 ;237
00010e  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L18.274|
000112  2101              MOVS     r1,#1                 ;241
000114  0408              LSLS     r0,r1,#16             ;241
000116  f7fffffe          BL       RCC_APB2PeriphResetCmd
00011a  e8bd4010          POP      {r4,lr}               ;242
00011e  2100              MOVS     r1,#0                 ;242
000120  f44f3080          MOV      r0,#0x10000           ;242
000124  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L18.296|
000128  2101              MOVS     r1,#1                 ;246
00012a  0448              LSLS     r0,r1,#17             ;246
00012c  f7fffffe          BL       RCC_APB2PeriphResetCmd
000130  e8bd4010          POP      {r4,lr}               ;247
000134  2100              MOVS     r1,#0                 ;247
000136  f44f3000          MOV      r0,#0x20000           ;247
00013a  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L18.318|
00013e  2101              MOVS     r1,#1                 ;251
000140  0488              LSLS     r0,r1,#18             ;251
000142  f7fffffe          BL       RCC_APB2PeriphResetCmd
000146  2100              MOVS     r1,#0                 ;252
000148  e001              B        |L18.334|
                  |L18.330|
00014a  e006              B        |L18.346|
                  |L18.332|
00014c  e00f              B        |L18.366|
                  |L18.334|
00014e  e8bd4010          POP      {r4,lr}               ;252
000152  f44f2080          MOV      r0,#0x40000           ;252
000156  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L18.346|
00015a  2101              MOVS     r1,#1                 ;256
00015c  2040              MOVS     r0,#0x40              ;256
00015e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000162  2100              MOVS     r1,#0                 ;257
000164  e8bd4010          POP      {r4,lr}               ;257
000168  2040              MOVS     r0,#0x40              ;257
00016a  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L18.366|
00016e  2101              MOVS     r1,#1                 ;261
000170  2080              MOVS     r0,#0x80              ;261
000172  f7fffffe          BL       RCC_APB1PeriphResetCmd
000176  2100              MOVS     r1,#0                 ;262
000178  e8bd4010          POP      {r4,lr}               ;262
00017c  2080              MOVS     r0,#0x80              ;262
00017e  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
;;;273    
                          ENDP


                          AREA ||i.TIM_ETRClockMode1Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode1Config PROC
;;;2763     */
;;;2764   void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
000000  b410              PUSH     {r4}
000002  f8b0c008          LDRH     r12,[r0,#8]
000006  f64f74ff          MOV      r4,#0xffff
00000a  ea042303          AND      r3,r4,r3,LSL #8
00000e  431a              ORRS     r2,r2,r3
000010  f00c0cff          AND      r12,r12,#0xff
000014  4311              ORRS     r1,r1,r2
000016  ea41010c          ORR      r1,r1,r12
00001a  8101              STRH     r1,[r0,#8]
;;;2765                               uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;2766   {
;;;2767     uint16_t tmpsmcr = 0;
;;;2768   
;;;2769     /* Check the parameters */
;;;2770     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2771     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;2772     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;2773     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;2774     /* Configure the ETR Clock source */
;;;2775     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
;;;2776     
;;;2777     /* Get the TIMx SMCR register value */
;;;2778     tmpsmcr = TIMx->SMCR;
00001c  8901              LDRH     r1,[r0,#8]
;;;2779   
;;;2780     /* Reset the SMS Bits */
;;;2781     tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
;;;2782   
;;;2783     /* Select the External clock mode1 */
;;;2784     tmpsmcr |= TIM_SlaveMode_External1;
;;;2785   
;;;2786     /* Select the Trigger selection : ETRF */
;;;2787     tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
;;;2788     tmpsmcr |= TIM_TS_ETRF;
00001e  f0410177          ORR      r1,r1,#0x77
;;;2789   
;;;2790     /* Write to TIMx SMCR */
;;;2791     TIMx->SMCR = tmpsmcr;
000022  8101              STRH     r1,[r0,#8]
;;;2792   }
000024  bc10              POP      {r4}
000026  4770              BX       lr
;;;2793   
                          ENDP


                          AREA ||i.TIM_ETRClockMode2Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode2Config PROC
;;;2810     */
;;;2811   void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
000000  b410              PUSH     {r4}
000002  f8b0c008          LDRH     r12,[r0,#8]
000006  f64f74ff          MOV      r4,#0xffff
00000a  ea042303          AND      r3,r4,r3,LSL #8
00000e  431a              ORRS     r2,r2,r3
000010  f00c0cff          AND      r12,r12,#0xff
000014  4311              ORRS     r1,r1,r2
000016  ea41010c          ORR      r1,r1,r12
00001a  8101              STRH     r1,[r0,#8]
;;;2812                                uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;2813   {
;;;2814     /* Check the parameters */
;;;2815     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2816     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;2817     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;2818     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;2819   
;;;2820     /* Configure the ETR Clock source */
;;;2821     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
;;;2822   
;;;2823     /* Enable the External clock mode2 */
;;;2824     TIMx->SMCR |= TIM_SMCR_ECE;
00001c  8901              LDRH     r1,[r0,#8]
00001e  f4414180          ORR      r1,r1,#0x4000
000022  8101              STRH     r1,[r0,#8]
;;;2825   }
000024  bc10              POP      {r4}
000026  4770              BX       lr
;;;2826   /**
                          ENDP


                          AREA ||i.TIM_ETRConfig||, CODE, READONLY, ALIGN=1

                  TIM_ETRConfig PROC
;;;2998     */
;;;2999   void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
000000  b410              PUSH     {r4}
;;;3000                      uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;3001   {
;;;3002     uint16_t tmpsmcr = 0;
;;;3003   
;;;3004     /* Check the parameters */
;;;3005     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;3006     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;3007     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;3008     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;3009   
;;;3010     tmpsmcr = TIMx->SMCR;
000002  f8b0c008          LDRH     r12,[r0,#8]
;;;3011   
;;;3012     /* Reset the ETR Bits */
;;;3013     tmpsmcr &= SMCR_ETR_MASK;
;;;3014   
;;;3015     /* Set the Prescaler, the Filter value and the Polarity */
;;;3016     tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
000006  f64f74ff          MOV      r4,#0xffff
00000a  ea042303          AND      r3,r4,r3,LSL #8
00000e  431a              ORRS     r2,r2,r3
000010  f00c0cff          AND      r12,r12,#0xff         ;3013
000014  4311              ORRS     r1,r1,r2
000016  ea41010c          ORR      r1,r1,r12
;;;3017   
;;;3018     /* Write to TIMx SMCR */
;;;3019     TIMx->SMCR = tmpsmcr;
00001a  8101              STRH     r1,[r0,#8]
;;;3020   }
00001c  bc10              POP      {r4}
00001e  4770              BX       lr
;;;3021   /**
                          ENDP


                          AREA ||i.TIM_EncoderInterfaceConfig||, CODE, READONLY, ALIGN=1

                  TIM_EncoderInterfaceConfig PROC
;;;3056     */
;;;3057   void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
000000  b430              PUSH     {r4,r5}
;;;3058                                   uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
;;;3059   {
;;;3060     uint16_t tmpsmcr = 0;
;;;3061     uint16_t tmpccmr1 = 0;
;;;3062     uint16_t tmpccer = 0;
;;;3063       
;;;3064     /* Check the parameters */
;;;3065     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;3066     assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
;;;3067     assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
;;;3068     assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
;;;3069   
;;;3070     /* Get the TIMx SMCR register value */
;;;3071     tmpsmcr = TIMx->SMCR;
000002  8905              LDRH     r5,[r0,#8]
;;;3072   
;;;3073     /* Get the TIMx CCMR1 register value */
;;;3074     tmpccmr1 = TIMx->CCMR1;
000004  f8b0c018          LDRH     r12,[r0,#0x18]
;;;3075   
;;;3076     /* Get the TIMx CCER register value */
;;;3077     tmpccer = TIMx->CCER;
000008  8c04              LDRH     r4,[r0,#0x20]
;;;3078   
;;;3079     /* Set the encoder Mode */
;;;3080     tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
00000a  f0250507          BIC      r5,r5,#7
;;;3081     tmpsmcr |= TIM_EncoderMode;
00000e  4329              ORRS     r1,r1,r5
;;;3082   
;;;3083     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;3084     tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
000010  f02c0c03          BIC      r12,r12,#3
000014  f42c7c40          BIC      r12,r12,#0x300
;;;3085     tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
000018  f2401501          MOV      r5,#0x101
00001c  ea4c0c05          ORR      r12,r12,r5
;;;3086   
;;;3087     /* Set the TI1 and the TI2 Polarities */
;;;3088     tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
;;;3089     tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
000020  f64f75ff          MOV      r5,#0xffff
000024  ea051303          AND      r3,r5,r3,LSL #4
000028  f0240422          BIC      r4,r4,#0x22           ;3088
00002c  431a              ORRS     r2,r2,r3
00002e  4322              ORRS     r2,r2,r4
;;;3090   
;;;3091     /* Write to TIMx SMCR */
;;;3092     TIMx->SMCR = tmpsmcr;
000030  8101              STRH     r1,[r0,#8]
;;;3093   
;;;3094     /* Write to TIMx CCMR1 */
;;;3095     TIMx->CCMR1 = tmpccmr1;
000032  f8a0c018          STRH     r12,[r0,#0x18]
;;;3096   
;;;3097     /* Write to TIMx CCER */
;;;3098     TIMx->CCER = tmpccer;
000036  8402              STRH     r2,[r0,#0x20]
;;;3099   }
000038  bc30              POP      {r4,r5}
00003a  4770              BX       lr
;;;3100   
                          ENDP


                          AREA ||i.TIM_ForcedOC1Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC1Config PROC
;;;1115     */
;;;1116   void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1117   {
;;;1118     uint16_t tmpccmr1 = 0;
;;;1119   
;;;1120     /* Check the parameters */
;;;1121     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1122     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1123     tmpccmr1 = TIMx->CCMR1;
;;;1124   
;;;1125     /* Reset the OC1M Bits */
;;;1126     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1M;
000002  f0220270          BIC      r2,r2,#0x70
;;;1127   
;;;1128     /* Configure The Forced output Mode */
;;;1129     tmpccmr1 |= TIM_ForcedAction;
000006  4311              ORRS     r1,r1,r2
;;;1130   
;;;1131     /* Write to TIMx CCMR1 register */
;;;1132     TIMx->CCMR1 = tmpccmr1;
000008  8301              STRH     r1,[r0,#0x18]
;;;1133   }
00000a  4770              BX       lr
;;;1134   
                          ENDP


                          AREA ||i.TIM_ForcedOC2Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC2Config PROC
;;;1144     */
;;;1145   void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1146   {
;;;1147     uint16_t tmpccmr1 = 0;
;;;1148   
;;;1149     /* Check the parameters */
;;;1150     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1151     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1152     tmpccmr1 = TIMx->CCMR1;
;;;1153   
;;;1154     /* Reset the OC2M Bits */
;;;1155     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2M;
;;;1156   
;;;1157     /* Configure The Forced output Mode */
;;;1158     tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f42242e0          BIC      r2,r2,#0x7000         ;1155
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1159   
;;;1160     /* Write to TIMx CCMR1 register */
;;;1161     TIMx->CCMR1 = tmpccmr1;
000010  8301              STRH     r1,[r0,#0x18]
;;;1162   }
000012  4770              BX       lr
;;;1163   
                          ENDP


                          AREA ||i.TIM_ForcedOC3Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC3Config PROC
;;;1172     */
;;;1173   void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1174   {
;;;1175     uint16_t tmpccmr2 = 0;
;;;1176   
;;;1177     /* Check the parameters */
;;;1178     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1179     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1180   
;;;1181     tmpccmr2 = TIMx->CCMR2;
;;;1182   
;;;1183     /* Reset the OC1M Bits */
;;;1184     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3M;
000002  f0220270          BIC      r2,r2,#0x70
;;;1185   
;;;1186     /* Configure The Forced output Mode */
;;;1187     tmpccmr2 |= TIM_ForcedAction;
000006  4311              ORRS     r1,r1,r2
;;;1188   
;;;1189     /* Write to TIMx CCMR2 register */
;;;1190     TIMx->CCMR2 = tmpccmr2;
000008  8381              STRH     r1,[r0,#0x1c]
;;;1191   }
00000a  4770              BX       lr
;;;1192   
                          ENDP


                          AREA ||i.TIM_ForcedOC4Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC4Config PROC
;;;1201     */
;;;1202   void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1203   {
;;;1204     uint16_t tmpccmr2 = 0;
;;;1205   
;;;1206     /* Check the parameters */
;;;1207     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1208     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1209     tmpccmr2 = TIMx->CCMR2;
;;;1210   
;;;1211     /* Reset the OC2M Bits */
;;;1212     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4M;
;;;1213   
;;;1214     /* Configure The Forced output Mode */
;;;1215     tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f42242e0          BIC      r2,r2,#0x7000         ;1212
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1216   
;;;1217     /* Write to TIMx CCMR2 register */
;;;1218     TIMx->CCMR2 = tmpccmr2;
000010  8381              STRH     r1,[r0,#0x1c]
;;;1219   }
000012  4770              BX       lr
;;;1220   
                          ENDP


                          AREA ||i.TIM_GenerateEvent||, CODE, READONLY, ALIGN=1

                  TIM_GenerateEvent PROC
;;;2399     */
;;;2400   void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
000000  8281              STRH     r1,[r0,#0x14]
;;;2401   { 
;;;2402     /* Check the parameters */
;;;2403     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2404     assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
;;;2405    
;;;2406     /* Set the event sources */
;;;2407     TIMx->EGR = TIM_EventSource;
;;;2408   }
000002  4770              BX       lr
;;;2409   
                          ENDP


                          AREA ||i.TIM_GetCapture1||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture1 PROC
;;;2021     */
;;;2022   uint32_t TIM_GetCapture1(TIM_TypeDef* TIMx)
000000  6b40              LDR      r0,[r0,#0x34]
;;;2023   {
;;;2024     /* Check the parameters */
;;;2025     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;2026   
;;;2027     /* Get the Capture 1 Register value */
;;;2028     return TIMx->CCR1;
;;;2029   }
000002  4770              BX       lr
;;;2030   
                          ENDP


                          AREA ||i.TIM_GetCapture2||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture2 PROC
;;;2036     */
;;;2037   uint32_t TIM_GetCapture2(TIM_TypeDef* TIMx)
000000  6b80              LDR      r0,[r0,#0x38]
;;;2038   {
;;;2039     /* Check the parameters */
;;;2040     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2041   
;;;2042     /* Get the Capture 2 Register value */
;;;2043     return TIMx->CCR2;
;;;2044   }
000002  4770              BX       lr
;;;2045   
                          ENDP


                          AREA ||i.TIM_GetCapture3||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture3 PROC
;;;2050     */
;;;2051   uint32_t TIM_GetCapture3(TIM_TypeDef* TIMx)
000000  6bc0              LDR      r0,[r0,#0x3c]
;;;2052   {
;;;2053     /* Check the parameters */
;;;2054     assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;2055   
;;;2056     /* Get the Capture 3 Register value */
;;;2057     return TIMx->CCR3;
;;;2058   }
000002  4770              BX       lr
;;;2059   
                          ENDP


                          AREA ||i.TIM_GetCapture4||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture4 PROC
;;;2064     */
;;;2065   uint32_t TIM_GetCapture4(TIM_TypeDef* TIMx)
000000  6c00              LDR      r0,[r0,#0x40]
;;;2066   {
;;;2067     /* Check the parameters */
;;;2068     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2069   
;;;2070     /* Get the Capture 4 Register value */
;;;2071     return TIMx->CCR4;
;;;2072   }
000002  4770              BX       lr
;;;2073   
                          ENDP


                          AREA ||i.TIM_GetCounter||, CODE, READONLY, ALIGN=1

                  TIM_GetCounter PROC
;;;431      */
;;;432    uint32_t TIM_GetCounter(TIM_TypeDef* TIMx)
000000  6a40              LDR      r0,[r0,#0x24]
;;;433    {
;;;434      /* Check the parameters */
;;;435      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;436    
;;;437      /* Get the Counter Register value */
;;;438      return TIMx->CNT;
;;;439    }
000002  4770              BX       lr
;;;440    
                          ENDP


                          AREA ||i.TIM_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetFlagStatus PROC
;;;2432     */
;;;2433   FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000000  4602              MOV      r2,r0
;;;2434   { 
;;;2435     ITStatus bitstatus = RESET;  
000002  2000              MOVS     r0,#0
;;;2436     /* Check the parameters */
;;;2437     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2438     assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
;;;2439   
;;;2440     
;;;2441     if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
000004  8a12              LDRH     r2,[r2,#0x10]
000006  420a              TST      r2,r1
;;;2442     {
;;;2443       bitstatus = SET;
000008  bf18              IT       NE
00000a  2001              MOVNE    r0,#1
;;;2444     }
;;;2445     else
;;;2446     {
;;;2447       bitstatus = RESET;
;;;2448     }
;;;2449     return bitstatus;
;;;2450   }
00000c  4770              BX       lr
;;;2451   
                          ENDP


                          AREA ||i.TIM_GetITStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetITStatus PROC
;;;2502     */
;;;2503   ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000000  8a03              LDRH     r3,[r0,#0x10]
;;;2504   {
;;;2505     ITStatus bitstatus = RESET;  
000002  2200              MOVS     r2,#0
;;;2506     uint16_t itstatus = 0x0, itenable = 0x0;
;;;2507     /* Check the parameters */
;;;2508     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2509     assert_param(IS_TIM_GET_IT(TIM_IT));
;;;2510      
;;;2511     itstatus = TIMx->SR & TIM_IT;
;;;2512     
;;;2513     itenable = TIMx->DIER & TIM_IT;
000004  8980              LDRH     r0,[r0,#0xc]
000006  420b              TST      r3,r1                 ;2511
000008  ea000001          AND      r0,r0,r1
;;;2514     if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
00000c  bf1c              ITT      NE
00000e  2800              CMPNE    r0,#0
;;;2515     {
;;;2516       bitstatus = SET;
000010  2201              MOVNE    r2,#1
;;;2517     }
;;;2518     else
;;;2519     {
;;;2520       bitstatus = RESET;
;;;2521     }
;;;2522     return bitstatus;
000012  4610              MOV      r0,r2
;;;2523   }
000014  4770              BX       lr
;;;2524   
                          ENDP


                          AREA ||i.TIM_GetPrescaler||, CODE, READONLY, ALIGN=1

                  TIM_GetPrescaler PROC
;;;445      */
;;;446    uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
000000  8d00              LDRH     r0,[r0,#0x28]
;;;447    {
;;;448      /* Check the parameters */
;;;449      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;450    
;;;451      /* Get the Prescaler Register value */
;;;452      return TIMx->PSC;
;;;453    }
000002  4770              BX       lr
;;;454    
                          ENDP


                          AREA ||i.TIM_ICInit||, CODE, READONLY, ALIGN=1

                  TIM_ICInit PROC
;;;1889     */
;;;1890   void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  b470              PUSH     {r4-r6}
;;;1891   {
;;;1892     /* Check the parameters */
;;;1893     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1894     assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
;;;1895     assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
;;;1896     assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
;;;1897     assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
;;;1898     
;;;1899     if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000002  880d              LDRH     r5,[r1,#0]
;;;1900     {
;;;1901       /* TI1 Configuration */
;;;1902       TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000004  884c              LDRH     r4,[r1,#2]
000006  f8b1c004          LDRH     r12,[r1,#4]
00000a  890b              LDRH     r3,[r1,#8]
00000c  f64f72ff          MOV      r2,#0xffff
000010  b355              CBZ      r5,|L36.104|
;;;1903                  TIM_ICInitStruct->TIM_ICSelection,
;;;1904                  TIM_ICInitStruct->TIM_ICFilter);
;;;1905       /* Set the Input Capture Prescaler value */
;;;1906       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;1907     }
;;;1908     else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
000012  2d04              CMP      r5,#4
000014  d044              BEQ      |L36.160|
;;;1909     {
;;;1910       /* TI2 Configuration */
;;;1911       assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1912       TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
;;;1913                  TIM_ICInitStruct->TIM_ICSelection,
;;;1914                  TIM_ICInitStruct->TIM_ICFilter);
;;;1915       /* Set the Input Capture Prescaler value */
;;;1916       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;1917     }
;;;1918     else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
000016  2d08              CMP      r5,#8
000018  8c05              LDRH     r5,[r0,#0x20]
00001a  d067              BEQ      |L36.236|
00001c  f4255580          BIC      r5,r5,#0x1000
000020  8405              STRH     r5,[r0,#0x20]
000022  8b86              LDRH     r6,[r0,#0x1c]
000024  8c05              LDRH     r5,[r0,#0x20]
000026  f4264673          BIC      r6,r6,#0xf300
00002a  ea022c0c          AND      r12,r2,r12,LSL #8
00002e  ea4c0c06          ORR      r12,r12,r6
000032  ea023303          AND      r3,r2,r3,LSL #12
000036  ea43030c          ORR      r3,r3,r12
00003a  ea023404          AND      r4,r2,r4,LSL #12
00003e  f4254c20          BIC      r12,r5,#0xa000
000042  ea4c0c04          ORR      r12,r12,r4
000046  f44c5c80          ORR      r12,r12,#0x1000
00004a  8383              STRH     r3,[r0,#0x1c]
00004c  f8a0c020          STRH     r12,[r0,#0x20]
;;;1919     {
;;;1920       /* TI3 Configuration */
;;;1921       assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1922       TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
;;;1923                  TIM_ICInitStruct->TIM_ICSelection,
;;;1924                  TIM_ICInitStruct->TIM_ICFilter);
;;;1925       /* Set the Input Capture Prescaler value */
;;;1926       TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;1927     }
;;;1928     else
;;;1929     {
;;;1930       /* TI4 Configuration */
;;;1931       assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1932       TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
;;;1933                  TIM_ICInitStruct->TIM_ICSelection,
;;;1934                  TIM_ICInitStruct->TIM_ICFilter);
;;;1935       /* Set the Input Capture Prescaler value */
;;;1936       TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000050  7989              LDRB     r1,[r1,#6]
000052  8b83              LDRH     r3,[r0,#0x1c]
000054  f4236340          BIC      r3,r3,#0xc00
000058  8383              STRH     r3,[r0,#0x1c]
00005a  8b83              LDRH     r3,[r0,#0x1c]
00005c  ea022101          AND      r1,r2,r1,LSL #8
000060  4319              ORRS     r1,r1,r3
                  |L36.98|
000062  8381              STRH     r1,[r0,#0x1c]
;;;1937     }
;;;1938   }
000064  bc70              POP      {r4-r6}
000066  4770              BX       lr
                  |L36.104|
000068  8c05              LDRH     r5,[r0,#0x20]
00006a  f0250501          BIC      r5,r5,#1
00006e  8405              STRH     r5,[r0,#0x20]
000070  8b06              LDRH     r6,[r0,#0x18]
000072  8c05              LDRH     r5,[r0,#0x20]
000074  ea021203          AND      r2,r2,r3,LSL #4
000078  f02606f3          BIC      r6,r6,#0xf3
00007c  ea42020c          ORR      r2,r2,r12
000080  4332              ORRS     r2,r2,r6
000082  f025030a          BIC      r3,r5,#0xa
000086  4323              ORRS     r3,r3,r4
000088  f0430301          ORR      r3,r3,#1
00008c  8302              STRH     r2,[r0,#0x18]
00008e  8403              STRH     r3,[r0,#0x20]
000090  88c9              LDRH     r1,[r1,#6]            ;1906
000092  8b02              LDRH     r2,[r0,#0x18]         ;1906
000094  f022020c          BIC      r2,r2,#0xc            ;1906
000098  8302              STRH     r2,[r0,#0x18]         ;1906
00009a  8b02              LDRH     r2,[r0,#0x18]         ;1906
00009c  4311              ORRS     r1,r1,r2              ;1906
00009e  e022              B        |L36.230|
                  |L36.160|
0000a0  8c05              LDRH     r5,[r0,#0x20]         ;1906
0000a2  f0250510          BIC      r5,r5,#0x10           ;1906
0000a6  8405              STRH     r5,[r0,#0x20]         ;1906
0000a8  8b06              LDRH     r6,[r0,#0x18]         ;1906
0000aa  8c05              LDRH     r5,[r0,#0x20]         ;1906
0000ac  f4264673          BIC      r6,r6,#0xf300         ;1906
0000b0  ea023303          AND      r3,r2,r3,LSL #12      ;1906
0000b4  4333              ORRS     r3,r3,r6              ;1906
0000b6  ea022c0c          AND      r12,r2,r12,LSL #8     ;1906
0000ba  ea4c0303          ORR      r3,r12,r3             ;1906
0000be  ea021404          AND      r4,r2,r4,LSL #4       ;1906
0000c2  f0250ca0          BIC      r12,r5,#0xa0          ;1906
0000c6  ea4c0c04          ORR      r12,r12,r4            ;1906
0000ca  f04c0c10          ORR      r12,r12,#0x10         ;1906
0000ce  8303              STRH     r3,[r0,#0x18]         ;1906
0000d0  f8a0c020          STRH     r12,[r0,#0x20]        ;1906
0000d4  7989              LDRB     r1,[r1,#6]            ;1916
0000d6  8b03              LDRH     r3,[r0,#0x18]         ;1916
0000d8  f4236340          BIC      r3,r3,#0xc00          ;1916
0000dc  8303              STRH     r3,[r0,#0x18]         ;1916
0000de  8b03              LDRH     r3,[r0,#0x18]         ;1916
0000e0  ea022101          AND      r1,r2,r1,LSL #8       ;1916
0000e4  4319              ORRS     r1,r1,r3              ;1916
                  |L36.230|
0000e6  8301              STRH     r1,[r0,#0x18]         ;1916
0000e8  bc70              POP      {r4-r6}
0000ea  4770              BX       lr
                  |L36.236|
0000ec  f4257580          BIC      r5,r5,#0x100
0000f0  8405              STRH     r5,[r0,#0x20]
0000f2  8b86              LDRH     r6,[r0,#0x1c]
0000f4  8c05              LDRH     r5,[r0,#0x20]
0000f6  ea022404          AND      r4,r2,r4,LSL #8
0000fa  ea021203          AND      r2,r2,r3,LSL #4
0000fe  f02606f3          BIC      r6,r6,#0xf3
000102  ea42020c          ORR      r2,r2,r12
000106  4332              ORRS     r2,r2,r6
000108  f4256320          BIC      r3,r5,#0xa00
00010c  4323              ORRS     r3,r3,r4
00010e  f4437380          ORR      r3,r3,#0x100
000112  8382              STRH     r2,[r0,#0x1c]
000114  8403              STRH     r3,[r0,#0x20]
000116  88c9              LDRH     r1,[r1,#6]            ;1926
000118  8b82              LDRH     r2,[r0,#0x1c]         ;1926
00011a  f022020c          BIC      r2,r2,#0xc            ;1926
00011e  8382              STRH     r2,[r0,#0x1c]         ;1926
000120  8b82              LDRH     r2,[r0,#0x1c]         ;1926
000122  4311              ORRS     r1,r1,r2              ;1926
000124  e79d              B        |L36.98|
;;;1939   
                          ENDP


                          AREA ||i.TIM_ICStructInit||, CODE, READONLY, ALIGN=1

                  TIM_ICStructInit PROC
;;;1945     */
;;;1946   void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  2100              MOVS     r1,#0
;;;1947   {
;;;1948     /* Set the default configuration */
;;;1949     TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
000002  8001              STRH     r1,[r0,#0]
;;;1950     TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
000004  8041              STRH     r1,[r0,#2]
;;;1951     TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
000006  2201              MOVS     r2,#1
000008  8082              STRH     r2,[r0,#4]
;;;1952     TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
00000a  80c1              STRH     r1,[r0,#6]
;;;1953     TIM_ICInitStruct->TIM_ICFilter = 0x00;
00000c  8101              STRH     r1,[r0,#8]
;;;1954   }
00000e  4770              BX       lr
;;;1955   
                          ENDP


                          AREA ||i.TIM_ITConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITConfig PROC
;;;2361     */
;;;2362   void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;2363   {  
;;;2364     /* Check the parameters */
;;;2365     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2366     assert_param(IS_TIM_IT(TIM_IT));
;;;2367     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2368     
;;;2369     if (NewState != DISABLE)
;;;2370     {
;;;2371       /* Enable the Interrupt sources */
;;;2372       TIMx->DIER |= TIM_IT;
;;;2373     }
;;;2374     else
;;;2375     {
;;;2376       /* Disable the Interrupt sources */
;;;2377       TIMx->DIER &= (uint16_t)~TIM_IT;
000002  8982              LDRH     r2,[r0,#0xc]
000004  bf14              ITE      NE                    ;2372
000006  4311              ORRNE    r1,r1,r2              ;2372
000008  ea220101          BICEQ    r1,r2,r1
00000c  8181              STRH     r1,[r0,#0xc]          ;2372
;;;2378     }
;;;2379   }
00000e  4770              BX       lr
;;;2380   
                          ENDP


                          AREA ||i.TIM_ITRxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITRxExternalClockConfig PROC
;;;2693     */
;;;2694   void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000000  8902              LDRH     r2,[r0,#8]
000002  f0220270          BIC      r2,r2,#0x70
000006  4311              ORRS     r1,r1,r2
000008  8101              STRH     r1,[r0,#8]
;;;2695   {
;;;2696     /* Check the parameters */
;;;2697     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2698     assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;2699   
;;;2700     /* Select the Internal Trigger */
;;;2701     TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
;;;2702   
;;;2703     /* Select the External clock mode1 */
;;;2704     TIMx->SMCR |= TIM_SlaveMode_External1;
00000a  8901              LDRH     r1,[r0,#8]
00000c  f0410107          ORR      r1,r1,#7
000010  8101              STRH     r1,[r0,#8]
;;;2705   }
000012  4770              BX       lr
;;;2706   
                          ENDP


                          AREA ||i.TIM_InternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_InternalClockConfig PROC
;;;2672     */
;;;2673   void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
000000  8901              LDRH     r1,[r0,#8]
;;;2674   {
;;;2675     /* Check the parameters */
;;;2676     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2677   
;;;2678     /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;2679     TIMx->SMCR &=  (uint16_t)~TIM_SMCR_SMS;
000002  f0210107          BIC      r1,r1,#7
000006  8101              STRH     r1,[r0,#8]
;;;2680   }
000008  4770              BX       lr
;;;2681   
                          ENDP


                          AREA ||i.TIM_OC1FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1FastConfig PROC
;;;1346     */
;;;1347   void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1348   {
;;;1349     uint16_t tmpccmr1 = 0;
;;;1350   
;;;1351     /* Check the parameters */
;;;1352     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1353     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1354   
;;;1355     /* Get the TIMx CCMR1 register value */
;;;1356     tmpccmr1 = TIMx->CCMR1;
;;;1357   
;;;1358     /* Reset the OC1FE Bit */
;;;1359     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1FE;
000002  f0220204          BIC      r2,r2,#4
;;;1360   
;;;1361     /* Enable or Disable the Output Compare Fast Bit */
;;;1362     tmpccmr1 |= TIM_OCFast;
000006  4311              ORRS     r1,r1,r2
;;;1363   
;;;1364     /* Write to TIMx CCMR1 */
;;;1365     TIMx->CCMR1 = tmpccmr1;
000008  8301              STRH     r1,[r0,#0x18]
;;;1366   }
00000a  4770              BX       lr
;;;1367   
                          ENDP


                          AREA ||i.TIM_OC1Init||, CODE, READONLY, ALIGN=1

                  TIM_OC1Init PROC
;;;664      */
;;;665    void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b410              PUSH     {r4}
;;;666    {
;;;667      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;668       
;;;669      /* Check the parameters */
;;;670      assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
;;;671      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;672      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;673      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;674    
;;;675      /* Disable the Channel 1: Reset the CC1E Bit */
;;;676      TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
000002  8c02              LDRH     r2,[r0,#0x20]
000004  f0220201          BIC      r2,r2,#1
000008  8402              STRH     r2,[r0,#0x20]
;;;677      
;;;678      /* Get the TIMx CCER register value */
;;;679      tmpccer = TIMx->CCER;
00000a  8c03              LDRH     r3,[r0,#0x20]
;;;680      /* Get the TIMx CR2 register value */
;;;681      tmpcr2 =  TIMx->CR2;
00000c  8882              LDRH     r2,[r0,#4]
;;;682      
;;;683      /* Get the TIMx CCMR1 register value */
;;;684      tmpccmrx = TIMx->CCMR1;
00000e  f8b0c018          LDRH     r12,[r0,#0x18]
;;;685        
;;;686      /* Reset the Output Compare Mode Bits */
;;;687      tmpccmrx &= (uint16_t)~TIM_CCMR1_OC1M;
;;;688      tmpccmrx &= (uint16_t)~TIM_CCMR1_CC1S;
;;;689      /* Select the Output Compare Mode */
;;;690      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
000012  880c              LDRH     r4,[r1,#0]
000014  f02c0c73          BIC      r12,r12,#0x73         ;688
000018  ea440c0c          ORR      r12,r4,r12
;;;691      
;;;692      /* Reset the Output Polarity level */
;;;693      tmpccer &= (uint16_t)~TIM_CCER_CC1P;
;;;694      /* Set the Output Compare Polarity */
;;;695      tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
00001c  898c              LDRH     r4,[r1,#0xc]
00001e  f0230302          BIC      r3,r3,#2              ;693
000022  4323              ORRS     r3,r3,r4
;;;696      
;;;697      /* Set the Output State */
;;;698      tmpccer |= TIM_OCInitStruct->TIM_OutputState;
000024  884c              LDRH     r4,[r1,#2]
000026  4323              ORRS     r3,r3,r4
;;;699        
;;;700      if((TIMx == TIM1) || (TIMx == TIM8))
000028  f1a04480          SUB      r4,r0,#0x40000000
00002c  f5b43480          SUBS     r4,r4,#0x10000
000030  bf1c              ITT      NE
000032  f1a04480          SUBNE    r4,r0,#0x40000000
000036  f5b43482          SUBSNE   r4,r4,#0x10400
00003a  d10d              BNE      |L42.88|
;;;701      {
;;;702        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;703        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;704        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;705        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;706        
;;;707        /* Reset the Output N Polarity level */
;;;708        tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
;;;709        /* Set the Output N Polarity */
;;;710        tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
00003c  89cc              LDRH     r4,[r1,#0xe]
00003e  f0230308          BIC      r3,r3,#8              ;708
000042  4323              ORRS     r3,r3,r4
;;;711        /* Reset the Output N State */
;;;712        tmpccer &= (uint16_t)~TIM_CCER_CC1NE;
;;;713        
;;;714        /* Set the Output N State */
;;;715        tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
000044  888c              LDRH     r4,[r1,#4]
000046  f0230304          BIC      r3,r3,#4              ;712
00004a  4323              ORRS     r3,r3,r4
;;;716        /* Reset the Output Compare and Output Compare N IDLE State */
;;;717        tmpcr2 &= (uint16_t)~TIM_CR2_OIS1;
;;;718        tmpcr2 &= (uint16_t)~TIM_CR2_OIS1N;
;;;719        /* Set the Output Idle state */
;;;720        tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
00004c  8a0c              LDRH     r4,[r1,#0x10]
00004e  f4227240          BIC      r2,r2,#0x300          ;718
000052  4322              ORRS     r2,r2,r4
;;;721        /* Set the Output N Idle state */
;;;722        tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
000054  8a4c              LDRH     r4,[r1,#0x12]
000056  4322              ORRS     r2,r2,r4
                  |L42.88|
;;;723      }
;;;724      /* Write to TIMx CR2 */
;;;725      TIMx->CR2 = tmpcr2;
000058  8082              STRH     r2,[r0,#4]
;;;726      
;;;727      /* Write to TIMx CCMR1 */
;;;728      TIMx->CCMR1 = tmpccmrx;
00005a  f8a0c018          STRH     r12,[r0,#0x18]
;;;729      
;;;730      /* Set the Capture Compare Register value */
;;;731      TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
00005e  6889              LDR      r1,[r1,#8]
000060  6341              STR      r1,[r0,#0x34]
;;;732      
;;;733      /* Write to TIMx CCER */
;;;734      TIMx->CCER = tmpccer;
000062  8403              STRH     r3,[r0,#0x20]
;;;735    }
000064  bc10              POP      {r4}
000066  4770              BX       lr
;;;736    
                          ENDP


                          AREA ||i.TIM_OC1NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1NPolarityConfig PROC
;;;1611     */
;;;1612   void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1613   {
;;;1614     uint16_t tmpccer = 0;
;;;1615     /* Check the parameters */
;;;1616     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1617     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1618      
;;;1619     tmpccer = TIMx->CCER;
;;;1620   
;;;1621     /* Set or Reset the CC1NP Bit */
;;;1622     tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
000002  f0220208          BIC      r2,r2,#8
;;;1623     tmpccer |= TIM_OCNPolarity;
000006  4311              ORRS     r1,r1,r2
;;;1624   
;;;1625     /* Write to TIMx CCER register */
;;;1626     TIMx->CCER = tmpccer;
000008  8401              STRH     r1,[r0,#0x20]
;;;1627   }
00000a  4770              BX       lr
;;;1628   
                          ENDP


                          AREA ||i.TIM_OC1PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PolarityConfig PROC
;;;1584     */
;;;1585   void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1586   {
;;;1587     uint16_t tmpccer = 0;
;;;1588   
;;;1589     /* Check the parameters */
;;;1590     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1591     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1592   
;;;1593     tmpccer = TIMx->CCER;
;;;1594   
;;;1595     /* Set or Reset the CC1P Bit */
;;;1596     tmpccer &= (uint16_t)(~TIM_CCER_CC1P);
000002  f0220202          BIC      r2,r2,#2
;;;1597     tmpccer |= TIM_OCPolarity;
000006  4311              ORRS     r1,r1,r2
;;;1598   
;;;1599     /* Write to TIMx CCER register */
;;;1600     TIMx->CCER = tmpccer;
000008  8401              STRH     r1,[r0,#0x20]
;;;1601   }
00000a  4770              BX       lr
;;;1602   
                          ENDP


                          AREA ||i.TIM_OC1PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PreloadConfig PROC
;;;1229     */
;;;1230   void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1231   {
;;;1232     uint16_t tmpccmr1 = 0;
;;;1233   
;;;1234     /* Check the parameters */
;;;1235     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1236     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1237   
;;;1238     tmpccmr1 = TIMx->CCMR1;
;;;1239   
;;;1240     /* Reset the OC1PE Bit */
;;;1241     tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC1PE);
000002  f0220208          BIC      r2,r2,#8
;;;1242   
;;;1243     /* Enable or Disable the Output Compare Preload feature */
;;;1244     tmpccmr1 |= TIM_OCPreload;
000006  4311              ORRS     r1,r1,r2
;;;1245   
;;;1246     /* Write to TIMx CCMR1 register */
;;;1247     TIMx->CCMR1 = tmpccmr1;
000008  8301              STRH     r1,[r0,#0x18]
;;;1248   }
00000a  4770              BX       lr
;;;1249   
                          ENDP


                          AREA ||i.TIM_OC2FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2FastConfig PROC
;;;1377     */
;;;1378   void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1379   {
;;;1380     uint16_t tmpccmr1 = 0;
;;;1381   
;;;1382     /* Check the parameters */
;;;1383     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1384     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1385   
;;;1386     /* Get the TIMx CCMR1 register value */
;;;1387     tmpccmr1 = TIMx->CCMR1;
;;;1388   
;;;1389     /* Reset the OC2FE Bit */
;;;1390     tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2FE);
;;;1391   
;;;1392     /* Enable or Disable the Output Compare Fast Bit */
;;;1393     tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f4226280          BIC      r2,r2,#0x400          ;1390
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1394   
;;;1395     /* Write to TIMx CCMR1 */
;;;1396     TIMx->CCMR1 = tmpccmr1;
000010  8301              STRH     r1,[r0,#0x18]
;;;1397   }
000012  4770              BX       lr
;;;1398   
                          ENDP


                          AREA ||i.TIM_OC2Init||, CODE, READONLY, ALIGN=1

                  TIM_OC2Init PROC
;;;745      */
;;;746    void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b430              PUSH     {r4,r5}
;;;747    {
;;;748      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;749       
;;;750      /* Check the parameters */
;;;751      assert_param(IS_TIM_LIST2_PERIPH(TIMx)); 
;;;752      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;753      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;754      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;755    
;;;756      /* Disable the Channel 2: Reset the CC2E Bit */
;;;757      TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
000002  8c02              LDRH     r2,[r0,#0x20]
000004  f0220210          BIC      r2,r2,#0x10
000008  8402              STRH     r2,[r0,#0x20]
;;;758      
;;;759      /* Get the TIMx CCER register value */  
;;;760      tmpccer = TIMx->CCER;
00000a  8c03              LDRH     r3,[r0,#0x20]
;;;761      /* Get the TIMx CR2 register value */
;;;762      tmpcr2 =  TIMx->CR2;
00000c  f8b0c004          LDRH     r12,[r0,#4]
;;;763      
;;;764      /* Get the TIMx CCMR1 register value */
;;;765      tmpccmrx = TIMx->CCMR1;
000010  8b02              LDRH     r2,[r0,#0x18]
;;;766        
;;;767      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;768      tmpccmrx &= (uint16_t)~TIM_CCMR1_OC2M;
;;;769      tmpccmrx &= (uint16_t)~TIM_CCMR1_CC2S;
;;;770      
;;;771      /* Select the Output Compare Mode */
;;;772      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
000012  880d              LDRH     r5,[r1,#0]
000014  f42244e6          BIC      r4,r2,#0x7300         ;769
000018  f64f72ff          MOV      r2,#0xffff
00001c  ea022505          AND      r5,r2,r5,LSL #8
000020  432c              ORRS     r4,r4,r5
;;;773      
;;;774      /* Reset the Output Polarity level */
;;;775      tmpccer &= (uint16_t)~TIM_CCER_CC2P;
;;;776      /* Set the Output Compare Polarity */
;;;777      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
000022  898d              LDRH     r5,[r1,#0xc]
000024  f0230320          BIC      r3,r3,#0x20           ;775
000028  ea021505          AND      r5,r2,r5,LSL #4
00002c  432b              ORRS     r3,r3,r5
;;;778      
;;;779      /* Set the Output State */
;;;780      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
00002e  884d              LDRH     r5,[r1,#2]
000030  ea021505          AND      r5,r2,r5,LSL #4
000034  432b              ORRS     r3,r3,r5
;;;781        
;;;782      if((TIMx == TIM1) || (TIMx == TIM8))
000036  f1a04580          SUB      r5,r0,#0x40000000
00003a  f5b53580          SUBS     r5,r5,#0x10000
00003e  bf1c              ITT      NE
000040  f1a04580          SUBNE    r5,r0,#0x40000000
000044  f5b53582          SUBSNE   r5,r5,#0x10400
000048  d117              BNE      |L47.122|
;;;783      {
;;;784        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;785        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;786        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;787        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;788        
;;;789        /* Reset the Output N Polarity level */
;;;790        tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
;;;791        /* Set the Output N Polarity */
;;;792        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
00004a  89cd              LDRH     r5,[r1,#0xe]
00004c  f0230380          BIC      r3,r3,#0x80           ;790
000050  ea021505          AND      r5,r2,r5,LSL #4
000054  432b              ORRS     r3,r3,r5
;;;793        /* Reset the Output N State */
;;;794        tmpccer &= (uint16_t)~TIM_CCER_CC2NE;
;;;795        
;;;796        /* Set the Output N State */
;;;797        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
000056  888d              LDRH     r5,[r1,#4]
000058  f0230340          BIC      r3,r3,#0x40           ;794
00005c  ea021505          AND      r5,r2,r5,LSL #4
000060  432b              ORRS     r3,r3,r5
;;;798        /* Reset the Output Compare and Output Compare N IDLE State */
;;;799        tmpcr2 &= (uint16_t)~TIM_CR2_OIS2;
;;;800        tmpcr2 &= (uint16_t)~TIM_CR2_OIS2N;
;;;801        /* Set the Output Idle state */
;;;802        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
000062  8a0d              LDRH     r5,[r1,#0x10]
000064  f42c6c40          BIC      r12,r12,#0xc00        ;800
000068  ea020585          AND      r5,r2,r5,LSL #2
00006c  ea450c0c          ORR      r12,r5,r12
;;;803        /* Set the Output N Idle state */
;;;804        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
000070  8a4d              LDRH     r5,[r1,#0x12]
000072  ea020285          AND      r2,r2,r5,LSL #2
000076  ea420c0c          ORR      r12,r2,r12
                  |L47.122|
;;;805      }
;;;806      /* Write to TIMx CR2 */
;;;807      TIMx->CR2 = tmpcr2;
00007a  f8a0c004          STRH     r12,[r0,#4]
;;;808      
;;;809      /* Write to TIMx CCMR1 */
;;;810      TIMx->CCMR1 = tmpccmrx;
00007e  8304              STRH     r4,[r0,#0x18]
;;;811      
;;;812      /* Set the Capture Compare Register value */
;;;813      TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
000080  6889              LDR      r1,[r1,#8]
000082  6381              STR      r1,[r0,#0x38]
;;;814      
;;;815      /* Write to TIMx CCER */
;;;816      TIMx->CCER = tmpccer;
000084  8403              STRH     r3,[r0,#0x20]
;;;817    }
000086  bc30              POP      {r4,r5}
000088  4770              BX       lr
;;;818    
                          ENDP


                          AREA ||i.TIM_OC2NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2NPolarityConfig PROC
;;;1665     */
;;;1666   void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1667   {
;;;1668     uint16_t tmpccer = 0;
;;;1669   
;;;1670     /* Check the parameters */
;;;1671     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1672     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1673     
;;;1674     tmpccer = TIMx->CCER;
;;;1675   
;;;1676     /* Set or Reset the CC2NP Bit */
;;;1677     tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
;;;1678     tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
000002  f64f73ff          MOV      r3,#0xffff
000006  f0220280          BIC      r2,r2,#0x80           ;1677
00000a  ea031101          AND      r1,r3,r1,LSL #4
00000e  4311              ORRS     r1,r1,r2
;;;1679   
;;;1680     /* Write to TIMx CCER register */
;;;1681     TIMx->CCER = tmpccer;
000010  8401              STRH     r1,[r0,#0x20]
;;;1682   }
000012  4770              BX       lr
;;;1683   
                          ENDP


                          AREA ||i.TIM_OC2PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PolarityConfig PROC
;;;1638     */
;;;1639   void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1640   {
;;;1641     uint16_t tmpccer = 0;
;;;1642   
;;;1643     /* Check the parameters */
;;;1644     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1645     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1646   
;;;1647     tmpccer = TIMx->CCER;
;;;1648   
;;;1649     /* Set or Reset the CC2P Bit */
;;;1650     tmpccer &= (uint16_t)(~TIM_CCER_CC2P);
;;;1651     tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
000002  f64f73ff          MOV      r3,#0xffff
000006  f0220220          BIC      r2,r2,#0x20           ;1650
00000a  ea031101          AND      r1,r3,r1,LSL #4
00000e  4311              ORRS     r1,r1,r2
;;;1652   
;;;1653     /* Write to TIMx CCER register */
;;;1654     TIMx->CCER = tmpccer;
000010  8401              STRH     r1,[r0,#0x20]
;;;1655   }
000012  4770              BX       lr
;;;1656   
                          ENDP


                          AREA ||i.TIM_OC2PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PreloadConfig PROC
;;;1259     */
;;;1260   void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1261   {
;;;1262     uint16_t tmpccmr1 = 0;
;;;1263   
;;;1264     /* Check the parameters */
;;;1265     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1266     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1267   
;;;1268     tmpccmr1 = TIMx->CCMR1;
;;;1269   
;;;1270     /* Reset the OC2PE Bit */
;;;1271     tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2PE);
;;;1272   
;;;1273     /* Enable or Disable the Output Compare Preload feature */
;;;1274     tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f4226200          BIC      r2,r2,#0x800          ;1271
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1275   
;;;1276     /* Write to TIMx CCMR1 register */
;;;1277     TIMx->CCMR1 = tmpccmr1;
000010  8301              STRH     r1,[r0,#0x18]
;;;1278   }
000012  4770              BX       lr
;;;1279   
                          ENDP


                          AREA ||i.TIM_OC3FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3FastConfig PROC
;;;1407     */
;;;1408   void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1409   {
;;;1410     uint16_t tmpccmr2 = 0;
;;;1411     
;;;1412     /* Check the parameters */
;;;1413     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1414     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1415   
;;;1416     /* Get the TIMx CCMR2 register value */
;;;1417     tmpccmr2 = TIMx->CCMR2;
;;;1418   
;;;1419     /* Reset the OC3FE Bit */
;;;1420     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3FE;
000002  f0220204          BIC      r2,r2,#4
;;;1421   
;;;1422     /* Enable or Disable the Output Compare Fast Bit */
;;;1423     tmpccmr2 |= TIM_OCFast;
000006  4311              ORRS     r1,r1,r2
;;;1424   
;;;1425     /* Write to TIMx CCMR2 */
;;;1426     TIMx->CCMR2 = tmpccmr2;
000008  8381              STRH     r1,[r0,#0x1c]
;;;1427   }
00000a  4770              BX       lr
;;;1428   
                          ENDP


                          AREA ||i.TIM_OC3Init||, CODE, READONLY, ALIGN=1

                  TIM_OC3Init PROC
;;;826      */
;;;827    void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b430              PUSH     {r4,r5}
;;;828    {
;;;829      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;830       
;;;831      /* Check the parameters */
;;;832      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;833      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;834      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;835      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;836    
;;;837      /* Disable the Channel 3: Reset the CC2E Bit */
;;;838      TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
000002  8c02              LDRH     r2,[r0,#0x20]
000004  f4227280          BIC      r2,r2,#0x100
000008  8402              STRH     r2,[r0,#0x20]
;;;839      
;;;840      /* Get the TIMx CCER register value */
;;;841      tmpccer = TIMx->CCER;
00000a  8c02              LDRH     r2,[r0,#0x20]
;;;842      /* Get the TIMx CR2 register value */
;;;843      tmpcr2 =  TIMx->CR2;
00000c  8883              LDRH     r3,[r0,#4]
;;;844      
;;;845      /* Get the TIMx CCMR2 register value */
;;;846      tmpccmrx = TIMx->CCMR2;
00000e  f8b0c01c          LDRH     r12,[r0,#0x1c]
;;;847        
;;;848      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;849      tmpccmrx &= (uint16_t)~TIM_CCMR2_OC3M;
;;;850      tmpccmrx &= (uint16_t)~TIM_CCMR2_CC3S;  
;;;851      /* Select the Output Compare Mode */
;;;852      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
000012  880c              LDRH     r4,[r1,#0]
000014  f02c0c73          BIC      r12,r12,#0x73         ;850
000018  ea44040c          ORR      r4,r4,r12
;;;853      
;;;854      /* Reset the Output Polarity level */
;;;855      tmpccer &= (uint16_t)~TIM_CCER_CC3P;
00001c  f4227c00          BIC      r12,r2,#0x200
;;;856      /* Set the Output Compare Polarity */
;;;857      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
000020  898d              LDRH     r5,[r1,#0xc]
000022  f64f72ff          MOV      r2,#0xffff
000026  ea022505          AND      r5,r2,r5,LSL #8
00002a  ea450c0c          ORR      r12,r5,r12
;;;858      
;;;859      /* Set the Output State */
;;;860      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
00002e  884d              LDRH     r5,[r1,#2]
000030  ea022505          AND      r5,r2,r5,LSL #8
000034  ea450c0c          ORR      r12,r5,r12
;;;861        
;;;862      if((TIMx == TIM1) || (TIMx == TIM8))
000038  f1a04580          SUB      r5,r0,#0x40000000
00003c  f5b53580          SUBS     r5,r5,#0x10000
000040  bf1c              ITT      NE
000042  f1a04580          SUBNE    r5,r0,#0x40000000
000046  f5b53582          SUBSNE   r5,r5,#0x10400
00004a  d117              BNE      |L52.124|
;;;863      {
;;;864        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;865        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;866        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;867        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;868        
;;;869        /* Reset the Output N Polarity level */
;;;870        tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
;;;871        /* Set the Output N Polarity */
;;;872        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
00004c  89cd              LDRH     r5,[r1,#0xe]
00004e  f42c6c00          BIC      r12,r12,#0x800        ;870
000052  ea022505          AND      r5,r2,r5,LSL #8
000056  ea450c0c          ORR      r12,r5,r12
;;;873        /* Reset the Output N State */
;;;874        tmpccer &= (uint16_t)~TIM_CCER_CC3NE;
;;;875        
;;;876        /* Set the Output N State */
;;;877        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
00005a  888d              LDRH     r5,[r1,#4]
00005c  f42c6c80          BIC      r12,r12,#0x400        ;874
000060  ea022505          AND      r5,r2,r5,LSL #8
000064  ea450c0c          ORR      r12,r5,r12
;;;878        /* Reset the Output Compare and Output Compare N IDLE State */
;;;879        tmpcr2 &= (uint16_t)~TIM_CR2_OIS3;
;;;880        tmpcr2 &= (uint16_t)~TIM_CR2_OIS3N;
;;;881        /* Set the Output Idle state */
;;;882        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
000068  8a0d              LDRH     r5,[r1,#0x10]
00006a  f4235340          BIC      r3,r3,#0x3000         ;880
00006e  ea021505          AND      r5,r2,r5,LSL #4
000072  432b              ORRS     r3,r3,r5
;;;883        /* Set the Output N Idle state */
;;;884        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
000074  8a4d              LDRH     r5,[r1,#0x12]
000076  ea021205          AND      r2,r2,r5,LSL #4
00007a  4313              ORRS     r3,r3,r2
                  |L52.124|
;;;885      }
;;;886      /* Write to TIMx CR2 */
;;;887      TIMx->CR2 = tmpcr2;
00007c  8083              STRH     r3,[r0,#4]
;;;888      
;;;889      /* Write to TIMx CCMR2 */
;;;890      TIMx->CCMR2 = tmpccmrx;
00007e  8384              STRH     r4,[r0,#0x1c]
;;;891      
;;;892      /* Set the Capture Compare Register value */
;;;893      TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
000080  6889              LDR      r1,[r1,#8]
000082  63c1              STR      r1,[r0,#0x3c]
;;;894      
;;;895      /* Write to TIMx CCER */
;;;896      TIMx->CCER = tmpccer;
000084  f8a0c020          STRH     r12,[r0,#0x20]
;;;897    }
000088  bc30              POP      {r4,r5}
00008a  4770              BX       lr
;;;898    
                          ENDP


                          AREA ||i.TIM_OC3NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3NPolarityConfig PROC
;;;1719     */
;;;1720   void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1721   {
;;;1722     uint16_t tmpccer = 0;
;;;1723    
;;;1724     /* Check the parameters */
;;;1725     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1726     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1727       
;;;1728     tmpccer = TIMx->CCER;
;;;1729   
;;;1730     /* Set or Reset the CC3NP Bit */
;;;1731     tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
;;;1732     tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f4226200          BIC      r2,r2,#0x800          ;1731
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1733   
;;;1734     /* Write to TIMx CCER register */
;;;1735     TIMx->CCER = tmpccer;
000010  8401              STRH     r1,[r0,#0x20]
;;;1736   }
000012  4770              BX       lr
;;;1737   
                          ENDP


                          AREA ||i.TIM_OC3PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PolarityConfig PROC
;;;1692     */
;;;1693   void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1694   {
;;;1695     uint16_t tmpccer = 0;
;;;1696   
;;;1697     /* Check the parameters */
;;;1698     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1699     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1700   
;;;1701     tmpccer = TIMx->CCER;
;;;1702   
;;;1703     /* Set or Reset the CC3P Bit */
;;;1704     tmpccer &= (uint16_t)~TIM_CCER_CC3P;
;;;1705     tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f4227200          BIC      r2,r2,#0x200          ;1704
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1706   
;;;1707     /* Write to TIMx CCER register */
;;;1708     TIMx->CCER = tmpccer;
000010  8401              STRH     r1,[r0,#0x20]
;;;1709   }
000012  4770              BX       lr
;;;1710   
                          ENDP


                          AREA ||i.TIM_OC3PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PreloadConfig PROC
;;;1288     */
;;;1289   void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1290   {
;;;1291     uint16_t tmpccmr2 = 0;
;;;1292   
;;;1293     /* Check the parameters */
;;;1294     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1295     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1296   
;;;1297     tmpccmr2 = TIMx->CCMR2;
;;;1298   
;;;1299     /* Reset the OC3PE Bit */
;;;1300     tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC3PE);
000002  f0220208          BIC      r2,r2,#8
;;;1301   
;;;1302     /* Enable or Disable the Output Compare Preload feature */
;;;1303     tmpccmr2 |= TIM_OCPreload;
000006  4311              ORRS     r1,r1,r2
;;;1304   
;;;1305     /* Write to TIMx CCMR2 register */
;;;1306     TIMx->CCMR2 = tmpccmr2;
000008  8381              STRH     r1,[r0,#0x1c]
;;;1307   }
00000a  4770              BX       lr
;;;1308   
                          ENDP


                          AREA ||i.TIM_OC4FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4FastConfig PROC
;;;1437     */
;;;1438   void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1439   {
;;;1440     uint16_t tmpccmr2 = 0;
;;;1441   
;;;1442     /* Check the parameters */
;;;1443     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1444     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1445   
;;;1446     /* Get the TIMx CCMR2 register value */
;;;1447     tmpccmr2 = TIMx->CCMR2;
;;;1448   
;;;1449     /* Reset the OC4FE Bit */
;;;1450     tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4FE);
;;;1451   
;;;1452     /* Enable or Disable the Output Compare Fast Bit */
;;;1453     tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f4226280          BIC      r2,r2,#0x400          ;1450
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1454   
;;;1455     /* Write to TIMx CCMR2 */
;;;1456     TIMx->CCMR2 = tmpccmr2;
000010  8381              STRH     r1,[r0,#0x1c]
;;;1457   }
000012  4770              BX       lr
;;;1458   
                          ENDP


                          AREA ||i.TIM_OC4Init||, CODE, READONLY, ALIGN=1

                  TIM_OC4Init PROC
;;;906      */
;;;907    void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b430              PUSH     {r4,r5}
;;;908    {
;;;909      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;910       
;;;911      /* Check the parameters */
;;;912      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;913      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;914      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;915      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;916    
;;;917      /* Disable the Channel 4: Reset the CC4E Bit */
;;;918      TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
000002  8c02              LDRH     r2,[r0,#0x20]
000004  f4225280          BIC      r2,r2,#0x1000
000008  8402              STRH     r2,[r0,#0x20]
;;;919      
;;;920      /* Get the TIMx CCER register value */
;;;921      tmpccer = TIMx->CCER;
00000a  8c04              LDRH     r4,[r0,#0x20]
;;;922      /* Get the TIMx CR2 register value */
;;;923      tmpcr2 =  TIMx->CR2;
00000c  8882              LDRH     r2,[r0,#4]
;;;924      
;;;925      /* Get the TIMx CCMR2 register value */
;;;926      tmpccmrx = TIMx->CCMR2;
00000e  8b83              LDRH     r3,[r0,#0x1c]
;;;927        
;;;928      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;929      tmpccmrx &= (uint16_t)~TIM_CCMR2_OC4M;
;;;930      tmpccmrx &= (uint16_t)~TIM_CCMR2_CC4S;
;;;931      
;;;932      /* Select the Output Compare Mode */
;;;933      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
000010  880d              LDRH     r5,[r1,#0]
000012  f4234ce6          BIC      r12,r3,#0x7300        ;930
000016  f64f73ff          MOV      r3,#0xffff
00001a  ea032505          AND      r5,r3,r5,LSL #8
00001e  ea450c0c          ORR      r12,r5,r12
;;;934      
;;;935      /* Reset the Output Polarity level */
;;;936      tmpccer &= (uint16_t)~TIM_CCER_CC4P;
;;;937      /* Set the Output Compare Polarity */
;;;938      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
000022  898d              LDRH     r5,[r1,#0xc]
000024  f4245400          BIC      r4,r4,#0x2000         ;936
000028  ea033505          AND      r5,r3,r5,LSL #12
00002c  432c              ORRS     r4,r4,r5
;;;939      
;;;940      /* Set the Output State */
;;;941      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
00002e  884d              LDRH     r5,[r1,#2]
000030  ea033505          AND      r5,r3,r5,LSL #12
000034  432c              ORRS     r4,r4,r5
;;;942      
;;;943      if((TIMx == TIM1) || (TIMx == TIM8))
000036  f1a04580          SUB      r5,r0,#0x40000000
00003a  f5b53580          SUBS     r5,r5,#0x10000
00003e  bf1c              ITT      NE
000040  f1a04580          SUBNE    r5,r0,#0x40000000
000044  f5b53582          SUBSNE   r5,r5,#0x10400
000048  d105              BNE      |L57.86|
;;;944      {
;;;945        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;946        /* Reset the Output Compare IDLE State */
;;;947        tmpcr2 &=(uint16_t) ~TIM_CR2_OIS4;
;;;948        /* Set the Output Idle state */
;;;949        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
00004a  8a0d              LDRH     r5,[r1,#0x10]
00004c  f4224280          BIC      r2,r2,#0x4000         ;947
000050  ea031385          AND      r3,r3,r5,LSL #6
000054  431a              ORRS     r2,r2,r3
                  |L57.86|
;;;950      }
;;;951      /* Write to TIMx CR2 */
;;;952      TIMx->CR2 = tmpcr2;
000056  8082              STRH     r2,[r0,#4]
;;;953      
;;;954      /* Write to TIMx CCMR2 */  
;;;955      TIMx->CCMR2 = tmpccmrx;
000058  f8a0c01c          STRH     r12,[r0,#0x1c]
;;;956        
;;;957      /* Set the Capture Compare Register value */
;;;958      TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
00005c  6889              LDR      r1,[r1,#8]
00005e  6401              STR      r1,[r0,#0x40]
;;;959      
;;;960      /* Write to TIMx CCER */
;;;961      TIMx->CCER = tmpccer;
000060  8404              STRH     r4,[r0,#0x20]
;;;962    }
000062  bc30              POP      {r4,r5}
000064  4770              BX       lr
;;;963    
                          ENDP


                          AREA ||i.TIM_OC4PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PolarityConfig PROC
;;;1746     */
;;;1747   void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1748   {
;;;1749     uint16_t tmpccer = 0;
;;;1750   
;;;1751     /* Check the parameters */
;;;1752     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1753     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1754   
;;;1755     tmpccer = TIMx->CCER;
;;;1756   
;;;1757     /* Set or Reset the CC4P Bit */
;;;1758     tmpccer &= (uint16_t)~TIM_CCER_CC4P;
;;;1759     tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
000002  f64f73ff          MOV      r3,#0xffff
000006  f4225200          BIC      r2,r2,#0x2000         ;1758
00000a  ea033101          AND      r1,r3,r1,LSL #12
00000e  4311              ORRS     r1,r1,r2
;;;1760   
;;;1761     /* Write to TIMx CCER register */
;;;1762     TIMx->CCER = tmpccer;
000010  8401              STRH     r1,[r0,#0x20]
;;;1763   }
000012  4770              BX       lr
;;;1764   
                          ENDP


                          AREA ||i.TIM_OC4PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PreloadConfig PROC
;;;1317     */
;;;1318   void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1319   {
;;;1320     uint16_t tmpccmr2 = 0;
;;;1321   
;;;1322     /* Check the parameters */
;;;1323     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1324     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1325   
;;;1326     tmpccmr2 = TIMx->CCMR2;
;;;1327   
;;;1328     /* Reset the OC4PE Bit */
;;;1329     tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4PE);
;;;1330   
;;;1331     /* Enable or Disable the Output Compare Preload feature */
;;;1332     tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f4226200          BIC      r2,r2,#0x800          ;1329
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1333   
;;;1334     /* Write to TIMx CCMR2 register */
;;;1335     TIMx->CCMR2 = tmpccmr2;
000010  8381              STRH     r1,[r0,#0x1c]
;;;1336   }
000012  4770              BX       lr
;;;1337   
                          ENDP


                          AREA ||i.TIM_OCStructInit||, CODE, READONLY, ALIGN=1

                  TIM_OCStructInit PROC
;;;969      */
;;;970    void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  2100              MOVS     r1,#0
;;;971    {
;;;972      /* Set the default configuration */
;;;973      TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
000002  8001              STRH     r1,[r0,#0]
;;;974      TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;975      TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
000006  8081              STRH     r1,[r0,#4]
;;;976      TIM_OCInitStruct->TIM_Pulse = 0x00000000;
;;;977      TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
000008  6081              STR      r1,[r0,#8]
00000a  8181              STRH     r1,[r0,#0xc]
;;;978      TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
00000c  81c1              STRH     r1,[r0,#0xe]
;;;979      TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
00000e  8201              STRH     r1,[r0,#0x10]
;;;980      TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
000010  8241              STRH     r1,[r0,#0x12]
;;;981    }
000012  4770              BX       lr
;;;982    
                          ENDP


                          AREA ||i.TIM_PWMIConfig||, CODE, READONLY, ALIGN=1

                  TIM_PWMIConfig PROC
;;;1964     */
;;;1965   void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  e92d01f0          PUSH     {r4-r8}
;;;1966   {
;;;1967     uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
;;;1968     uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
;;;1969   
;;;1970     /* Check the parameters */
;;;1971     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1972   
;;;1973     /* Select the Opposite Input Polarity */
;;;1974     if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
000004  884e              LDRH     r6,[r1,#2]
000006  2300              MOVS     r3,#0                 ;1967
000008  2201              MOVS     r2,#1                 ;1968
00000a  2e00              CMP      r6,#0
;;;1975     {
;;;1976       icoppositepolarity = TIM_ICPolarity_Falling;
00000c  bf08              IT       EQ
00000e  2302              MOVEQ    r3,#2
;;;1977     }
;;;1978     else
;;;1979     {
;;;1980       icoppositepolarity = TIM_ICPolarity_Rising;
;;;1981     }
;;;1982     /* Select the Opposite Input */
;;;1983     if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
000010  888d              LDRH     r5,[r1,#4]
000012  2d01              CMP      r5,#1
;;;1984     {
;;;1985       icoppositeselection = TIM_ICSelection_IndirectTI;
000014  bf08              IT       EQ
000016  2202              MOVEQ    r2,#2
;;;1986     }
;;;1987     else
;;;1988     {
;;;1989       icoppositeselection = TIM_ICSelection_DirectTI;
;;;1990     }
;;;1991     if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000018  880f              LDRH     r7,[r1,#0]
;;;1992     {
;;;1993       /* TI1 Configuration */
;;;1994       TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
00001a  890c              LDRH     r4,[r1,#8]
00001c  2f00              CMP      r7,#0                 ;1991
00001e  8c07              LDRH     r7,[r0,#0x20]         ;1991
000020  f64f7cff          MOV      r12,#0xffff           ;1991
000024  d042              BEQ      |L61.172|
000026  f0270710          BIC      r7,r7,#0x10           ;1966
00002a  8407              STRH     r7,[r0,#0x20]         ;1966
00002c  f8b08018          LDRH     r8,[r0,#0x18]         ;1966
000030  8c07              LDRH     r7,[r0,#0x20]         ;1966
000032  f4284873          BIC      r8,r8,#0xf300         ;1966
000036  ea0c3404          AND      r4,r12,r4,LSL #12     ;1966
00003a  ea440408          ORR      r4,r4,r8              ;1966
00003e  ea0c2505          AND      r5,r12,r5,LSL #8      ;1966
000042  432c              ORRS     r4,r4,r5              ;1966
000044  ea0c1606          AND      r6,r12,r6,LSL #4      ;1966
000048  f02705a0          BIC      r5,r7,#0xa0           ;1966
00004c  4335              ORRS     r5,r5,r6              ;1966
00004e  f0450510          ORR      r5,r5,#0x10           ;1966
000052  8304              STRH     r4,[r0,#0x18]         ;1966
000054  8405              STRH     r5,[r0,#0x20]         ;1966
;;;1995                  TIM_ICInitStruct->TIM_ICFilter);
;;;1996       /* Set the Input Capture Prescaler value */
;;;1997       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;1998       /* TI2 Configuration */
;;;1999       TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
;;;2000       /* Set the Input Capture Prescaler value */
;;;2001       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;2002     }
;;;2003     else
;;;2004     { 
;;;2005       /* TI2 Configuration */
;;;2006       TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
;;;2007                  TIM_ICInitStruct->TIM_ICFilter);
;;;2008       /* Set the Input Capture Prescaler value */
;;;2009       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000056  798c              LDRB     r4,[r1,#6]
000058  8b05              LDRH     r5,[r0,#0x18]
00005a  f4256540          BIC      r5,r5,#0xc00
00005e  8305              STRH     r5,[r0,#0x18]
000060  8b05              LDRH     r5,[r0,#0x18]
000062  ea0c2404          AND      r4,r12,r4,LSL #8
000066  432c              ORRS     r4,r4,r5
000068  8304              STRH     r4,[r0,#0x18]
;;;2010       /* TI1 Configuration */
;;;2011       TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
00006a  890c              LDRH     r4,[r1,#8]
00006c  8c05              LDRH     r5,[r0,#0x20]
00006e  f0250501          BIC      r5,r5,#1
000072  8405              STRH     r5,[r0,#0x20]
000074  8b06              LDRH     r6,[r0,#0x18]
000076  8c05              LDRH     r5,[r0,#0x20]
000078  ea0c1c04          AND      r12,r12,r4,LSL #4
00007c  ea4c0202          ORR      r2,r12,r2
000080  f02606f3          BIC      r6,r6,#0xf3
000084  f0250c0a          BIC      r12,r5,#0xa
000088  4332              ORRS     r2,r2,r6
00008a  ea4c0303          ORR      r3,r12,r3
00008e  f0430301          ORR      r3,r3,#1
000092  8302              STRH     r2,[r0,#0x18]
000094  8403              STRH     r3,[r0,#0x20]
;;;2012       /* Set the Input Capture Prescaler value */
;;;2013       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000096  88c9              LDRH     r1,[r1,#6]
000098  8b02              LDRH     r2,[r0,#0x18]
00009a  f022020c          BIC      r2,r2,#0xc
00009e  8302              STRH     r2,[r0,#0x18]
0000a0  8b02              LDRH     r2,[r0,#0x18]
0000a2  4311              ORRS     r1,r1,r2
0000a4  8301              STRH     r1,[r0,#0x18]
;;;2014     }
;;;2015   }
0000a6  e8bd01f0          POP      {r4-r8}
0000aa  4770              BX       lr
                  |L61.172|
0000ac  f0270701          BIC      r7,r7,#1
0000b0  8407              STRH     r7,[r0,#0x20]
0000b2  8b07              LDRH     r7,[r0,#0x18]
0000b4  f8b08020          LDRH     r8,[r0,#0x20]
0000b8  ea0c1404          AND      r4,r12,r4,LSL #4
0000bc  432c              ORRS     r4,r4,r5
0000be  f02707f3          BIC      r7,r7,#0xf3
0000c2  433c              ORRS     r4,r4,r7
0000c4  f028050a          BIC      r5,r8,#0xa
0000c8  4335              ORRS     r5,r5,r6
0000ca  f0450501          ORR      r5,r5,#1
0000ce  8304              STRH     r4,[r0,#0x18]
0000d0  8405              STRH     r5,[r0,#0x20]
0000d2  88cc              LDRH     r4,[r1,#6]            ;1997
0000d4  8b05              LDRH     r5,[r0,#0x18]         ;1997
0000d6  f025050c          BIC      r5,r5,#0xc            ;1997
0000da  8305              STRH     r5,[r0,#0x18]         ;1997
0000dc  8b05              LDRH     r5,[r0,#0x18]         ;1997
0000de  432c              ORRS     r4,r4,r5              ;1997
0000e0  8304              STRH     r4,[r0,#0x18]         ;1997
0000e2  7a0c              LDRB     r4,[r1,#8]            ;1999
0000e4  8c05              LDRH     r5,[r0,#0x20]         ;1999
0000e6  f0250510          BIC      r5,r5,#0x10           ;1999
0000ea  8405              STRH     r5,[r0,#0x20]         ;1999
0000ec  8b05              LDRH     r5,[r0,#0x18]         ;1999
0000ee  8c06              LDRH     r6,[r0,#0x20]         ;1999
0000f0  f4254573          BIC      r5,r5,#0xf300         ;1999
0000f4  ea0c3404          AND      r4,r12,r4,LSL #12     ;1999
0000f8  432c              ORRS     r4,r4,r5              ;1999
0000fa  ea0c2202          AND      r2,r12,r2,LSL #8      ;1999
0000fe  4322              ORRS     r2,r2,r4              ;1999
000100  ea0c1303          AND      r3,r12,r3,LSL #4      ;1999
000104  f02604a0          BIC      r4,r6,#0xa0           ;1999
000108  4323              ORRS     r3,r3,r4              ;1999
00010a  f0430310          ORR      r3,r3,#0x10           ;1999
00010e  8302              STRH     r2,[r0,#0x18]         ;1999
000110  8403              STRH     r3,[r0,#0x20]         ;1999
000112  7989              LDRB     r1,[r1,#6]            ;2001
000114  8b02              LDRH     r2,[r0,#0x18]         ;2001
000116  f4226240          BIC      r2,r2,#0xc00          ;2001
00011a  8302              STRH     r2,[r0,#0x18]         ;2001
00011c  8b02              LDRH     r2,[r0,#0x18]         ;2001
00011e  ea0c2101          AND      r1,r12,r1,LSL #8      ;2001
000122  4311              ORRS     r1,r1,r2              ;2001
000124  8301              STRH     r1,[r0,#0x18]         ;2001
000126  e8bd01f0          POP      {r4-r8}
00012a  4770              BX       lr
;;;2016   
                          ENDP


                          AREA ||i.TIM_PrescalerConfig||, CODE, READONLY, ALIGN=1

                  TIM_PrescalerConfig PROC
;;;353      */
;;;354    void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
000000  8501              STRH     r1,[r0,#0x28]
;;;355    {
;;;356      /* Check the parameters */
;;;357      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;358      assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
;;;359      /* Set the Prescaler value */
;;;360      TIMx->PSC = Prescaler;
;;;361      /* Set or reset the UG Bit */
;;;362      TIMx->EGR = TIM_PSCReloadMode;
000002  8282              STRH     r2,[r0,#0x14]
;;;363    }
000004  4770              BX       lr
;;;364    
                          ENDP


                          AREA ||i.TIM_RemapConfig||, CODE, READONLY, ALIGN=1

                  TIM_RemapConfig PROC
;;;3159     */
;;;3160   void TIM_RemapConfig(TIM_TypeDef* TIMx, uint16_t TIM_Remap)
000000  f8a01050          STRH     r1,[r0,#0x50]
;;;3161   {
;;;3162    /* Check the parameters */
;;;3163     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;3164     assert_param(IS_TIM_REMAP(TIM_Remap));
;;;3165   
;;;3166     /* Set the Timer remapping configuration */
;;;3167     TIMx->OR =  TIM_Remap;
;;;3168   }
000004  4770              BX       lr
;;;3169   /**
                          ENDP


                          AREA ||i.TIM_SelectCCDMA||, CODE, READONLY, ALIGN=1

                  TIM_SelectCCDMA PROC
;;;2633     */
;;;2634   void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;2635   {
;;;2636     /* Check the parameters */
;;;2637     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2638     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2639   
;;;2640     if (NewState != DISABLE)
;;;2641     {
;;;2642       /* Set the CCDS Bit */
;;;2643       TIMx->CR2 |= TIM_CR2_CCDS;
;;;2644     }
;;;2645     else
;;;2646     {
;;;2647       /* Reset the CCDS Bit */
;;;2648       TIMx->CR2 &= (uint16_t)~TIM_CR2_CCDS;
000002  8881              LDRH     r1,[r0,#4]
000004  bf14              ITE      NE                    ;2643
000006  f0410108          ORRNE    r1,r1,#8              ;2643
00000a  f0210108          BICEQ    r1,r1,#8
00000e  8081              STRH     r1,[r0,#4]            ;2643
;;;2649     }
;;;2650   }
000010  4770              BX       lr
;;;2651   /**
                          ENDP


                          AREA ||i.TIM_SelectCOM||, CODE, READONLY, ALIGN=1

                  TIM_SelectCOM PROC
;;;2279     */
;;;2280   void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;2281   {
;;;2282     /* Check the parameters */
;;;2283     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2284     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2285   
;;;2286     if (NewState != DISABLE)
;;;2287     {
;;;2288       /* Set the COM Bit */
;;;2289       TIMx->CR2 |= TIM_CR2_CCUS;
;;;2290     }
;;;2291     else
;;;2292     {
;;;2293       /* Reset the COM Bit */
;;;2294       TIMx->CR2 &= (uint16_t)~TIM_CR2_CCUS;
000002  8881              LDRH     r1,[r0,#4]
000004  bf14              ITE      NE                    ;2289
000006  f0410104          ORRNE    r1,r1,#4              ;2289
00000a  f0210104          BICEQ    r1,r1,#4
00000e  8081              STRH     r1,[r0,#4]            ;2289
;;;2295     }
;;;2296   }
000010  4770              BX       lr
;;;2297   
                          ENDP


                          AREA ||i.TIM_SelectHallSensor||, CODE, READONLY, ALIGN=1

                  TIM_SelectHallSensor PROC
;;;3108     */
;;;3109   void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;3110   {
;;;3111     /* Check the parameters */
;;;3112     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;3113     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;3114   
;;;3115     if (NewState != DISABLE)
;;;3116     {
;;;3117       /* Set the TI1S Bit */
;;;3118       TIMx->CR2 |= TIM_CR2_TI1S;
;;;3119     }
;;;3120     else
;;;3121     {
;;;3122       /* Reset the TI1S Bit */
;;;3123       TIMx->CR2 &= (uint16_t)~TIM_CR2_TI1S;
000002  8881              LDRH     r1,[r0,#4]
000004  bf14              ITE      NE                    ;3118
000006  f0410180          ORRNE    r1,r1,#0x80           ;3118
00000a  f0210180          BICEQ    r1,r1,#0x80
00000e  8081              STRH     r1,[r0,#4]            ;3118
;;;3124     }
;;;3125   }
000010  4770              BX       lr
;;;3126   /**
                          ENDP


                          AREA ||i.TIM_SelectInputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectInputTrigger PROC
;;;2878     */
;;;2879   void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000000  8902              LDRH     r2,[r0,#8]
;;;2880   {
;;;2881     uint16_t tmpsmcr = 0;
;;;2882   
;;;2883     /* Check the parameters */
;;;2884     assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
;;;2885     assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;2886   
;;;2887     /* Get the TIMx SMCR register value */
;;;2888     tmpsmcr = TIMx->SMCR;
;;;2889   
;;;2890     /* Reset the TS Bits */
;;;2891     tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
000002  f0220270          BIC      r2,r2,#0x70
;;;2892   
;;;2893     /* Set the Input Trigger source */
;;;2894     tmpsmcr |= TIM_InputTriggerSource;
000006  4311              ORRS     r1,r1,r2
;;;2895   
;;;2896     /* Write to TIMx SMCR */
;;;2897     TIMx->SMCR = tmpsmcr;
000008  8101              STRH     r1,[r0,#8]
;;;2898   }
00000a  4770              BX       lr
;;;2899   
                          ENDP


                          AREA ||i.TIM_SelectMasterSlaveMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectMasterSlaveMode PROC
;;;2968     */
;;;2969   void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
000000  8902              LDRH     r2,[r0,#8]
;;;2970   {
;;;2971     /* Check the parameters */
;;;2972     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2973     assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
;;;2974   
;;;2975     /* Reset the MSM Bit */
;;;2976     TIMx->SMCR &= (uint16_t)~TIM_SMCR_MSM;
000002  f0220280          BIC      r2,r2,#0x80
000006  8102              STRH     r2,[r0,#8]
;;;2977     
;;;2978     /* Set or Reset the MSM Bit */
;;;2979     TIMx->SMCR |= TIM_MasterSlaveMode;
000008  8902              LDRH     r2,[r0,#8]
00000a  4311              ORRS     r1,r1,r2
00000c  8101              STRH     r1,[r0,#8]
;;;2980   }
00000e  4770              BX       lr
;;;2981   
                          ENDP


                          AREA ||i.TIM_SelectOCxM||, CODE, READONLY, ALIGN=1

                  TIM_SelectOCxM PROC
;;;1005     */
;;;1006   void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
000000  b410              PUSH     {r4}
;;;1007   {
;;;1008     uint32_t tmp = 0;
;;;1009     uint16_t tmp1 = 0;
;;;1010   
;;;1011     /* Check the parameters */
;;;1012     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1013     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;1014     assert_param(IS_TIM_OCM(TIM_OCMode));
;;;1015   
;;;1016     tmp = (uint32_t) TIMx;
;;;1017     tmp += CCMR_OFFSET;
;;;1018   
;;;1019     tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
000002  f04f0c01          MOV      r12,#1
;;;1020   
;;;1021     /* Disable the Channel: Reset the CCxE Bit */
;;;1022     TIMx->CCER &= (uint16_t) ~tmp1;
000006  8c04              LDRH     r4,[r0,#0x20]
000008  f1000318          ADD      r3,r0,#0x18           ;1017
00000c  fa0cfc01          LSL      r12,r12,r1            ;1019
000010  ea240c0c          BIC      r12,r4,r12
000014  f8a0c020          STRH     r12,[r0,#0x20]
;;;1023   
;;;1024     if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
000018  2900              CMP      r1,#0
00001a  bf18              IT       NE
00001c  2908              CMPNE    r1,#8
00001e  d011              BEQ      |L69.68|
;;;1025     {
;;;1026       tmp += (TIM_Channel>>1);
;;;1027   
;;;1028       /* Reset the OCxM bits in the CCMRx register */
;;;1029       *(__IO uint32_t *) tmp &= CCMR_OC13M_MASK;
;;;1030      
;;;1031       /* Configure the OCxM bits in the CCMRx register */
;;;1032       *(__IO uint32_t *) tmp |= TIM_OCMode;
;;;1033     }
;;;1034     else
;;;1035     {
;;;1036       tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
000020  1f08              SUBS     r0,r1,#4
000022  f3c0004e          UBFX     r0,r0,#1,#15
000026  4418              ADD      r0,r0,r3
;;;1037   
;;;1038       /* Reset the OCxM bits in the CCMRx register */
;;;1039       *(__IO uint32_t *) tmp &= CCMR_OC24M_MASK;
000028  6801              LDR      r1,[r0,#0]
00002a  f64873ff          MOV      r3,#0x8fff
00002e  4019              ANDS     r1,r1,r3
000030  6001              STR      r1,[r0,#0]
;;;1040       
;;;1041       /* Configure the OCxM bits in the CCMRx register */
;;;1042       *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
000032  6801              LDR      r1,[r0,#0]
000034  f64f73ff          MOV      r3,#0xffff
000038  ea032202          AND      r2,r3,r2,LSL #8
00003c  4311              ORRS     r1,r1,r2
00003e  6001              STR      r1,[r0,#0]
;;;1043     }
;;;1044   }
000040  bc10              POP      {r4}
000042  4770              BX       lr
                  |L69.68|
000044  eb030051          ADD      r0,r3,r1,LSR #1       ;1026
000048  6801              LDR      r1,[r0,#0]            ;1029
00004a  f64f738f          MOV      r3,#0xff8f            ;1029
00004e  4019              ANDS     r1,r1,r3              ;1029
000050  6001              STR      r1,[r0,#0]            ;1029
000052  6801              LDR      r1,[r0,#0]            ;1032
000054  4311              ORRS     r1,r1,r2              ;1032
000056  6001              STR      r1,[r0,#0]            ;1032
000058  bc10              POP      {r4}
00005a  4770              BX       lr
;;;1045   
                          ENDP


                          AREA ||i.TIM_SelectOnePulseMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectOnePulseMode PROC
;;;542      */
;;;543    void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
000000  8802              LDRH     r2,[r0,#0]
;;;544    {
;;;545      /* Check the parameters */
;;;546      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;547      assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
;;;548    
;;;549      /* Reset the OPM Bit */
;;;550      TIMx->CR1 &= (uint16_t)~TIM_CR1_OPM;
000002  f0220208          BIC      r2,r2,#8
000006  8002              STRH     r2,[r0,#0]
;;;551    
;;;552      /* Configure the OPM Mode */
;;;553      TIMx->CR1 |= TIM_OPMode;
000008  8802              LDRH     r2,[r0,#0]
00000a  4311              ORRS     r1,r1,r2
00000c  8001              STRH     r1,[r0,#0]
;;;554    }
00000e  4770              BX       lr
;;;555    
                          ENDP


                          AREA ||i.TIM_SelectOutputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectOutputTrigger PROC
;;;2921     */
;;;2922   void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
000000  8882              LDRH     r2,[r0,#4]
;;;2923   {
;;;2924     /* Check the parameters */
;;;2925     assert_param(IS_TIM_LIST5_PERIPH(TIMx));
;;;2926     assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
;;;2927   
;;;2928     /* Reset the MMS Bits */
;;;2929     TIMx->CR2 &= (uint16_t)~TIM_CR2_MMS;
000002  f0220270          BIC      r2,r2,#0x70
000006  8082              STRH     r2,[r0,#4]
;;;2930     /* Select the TRGO source */
;;;2931     TIMx->CR2 |=  TIM_TRGOSource;
000008  8882              LDRH     r2,[r0,#4]
00000a  4311              ORRS     r1,r1,r2
00000c  8081              STRH     r1,[r0,#4]
;;;2932   }
00000e  4770              BX       lr
;;;2933   
                          ENDP


                          AREA ||i.TIM_SelectSlaveMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectSlaveMode PROC
;;;2945     */
;;;2946   void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
000000  8902              LDRH     r2,[r0,#8]
;;;2947   {
;;;2948     /* Check the parameters */
;;;2949     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2950     assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
;;;2951   
;;;2952     /* Reset the SMS Bits */
;;;2953     TIMx->SMCR &= (uint16_t)~TIM_SMCR_SMS;
000002  f0220207          BIC      r2,r2,#7
000006  8102              STRH     r2,[r0,#8]
;;;2954   
;;;2955     /* Select the Slave Mode */
;;;2956     TIMx->SMCR |= TIM_SlaveMode;
000008  8902              LDRH     r2,[r0,#8]
00000a  4311              ORRS     r1,r1,r2
00000c  8101              STRH     r1,[r0,#8]
;;;2957   }
00000e  4770              BX       lr
;;;2958   
                          ENDP


                          AREA ||i.TIM_SetAutoreload||, CODE, READONLY, ALIGN=1

                  TIM_SetAutoreload PROC
;;;417      */
;;;418    void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint32_t Autoreload)
000000  62c1              STR      r1,[r0,#0x2c]
;;;419    {
;;;420      /* Check the parameters */
;;;421      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;422      
;;;423      /* Set the Autoreload Register value */
;;;424      TIMx->ARR = Autoreload;
;;;425    }
000002  4770              BX       lr
;;;426    
                          ENDP


                          AREA ||i.TIM_SetClockDivision||, CODE, READONLY, ALIGN=1

                  TIM_SetClockDivision PROC
;;;565      */
;;;566    void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
000000  8802              LDRH     r2,[r0,#0]
;;;567    {
;;;568      /* Check the parameters */
;;;569      assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;570      assert_param(IS_TIM_CKD_DIV(TIM_CKD));
;;;571    
;;;572      /* Reset the CKD Bits */
;;;573      TIMx->CR1 &= (uint16_t)(~TIM_CR1_CKD);
000002  f4227240          BIC      r2,r2,#0x300
000006  8002              STRH     r2,[r0,#0]
;;;574    
;;;575      /* Set the CKD value */
;;;576      TIMx->CR1 |= TIM_CKD;
000008  8802              LDRH     r2,[r0,#0]
00000a  4311              ORRS     r1,r1,r2
00000c  8001              STRH     r1,[r0,#0]
;;;577    }
00000e  4770              BX       lr
;;;578    
                          ENDP


                          AREA ||i.TIM_SetCompare1||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare1 PROC
;;;1051     */
;;;1052   void TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1)
000000  6341              STR      r1,[r0,#0x34]
;;;1053   {
;;;1054     /* Check the parameters */
;;;1055     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1056   
;;;1057     /* Set the Capture Compare1 Register value */
;;;1058     TIMx->CCR1 = Compare1;
;;;1059   }
000002  4770              BX       lr
;;;1060   
                          ENDP


                          AREA ||i.TIM_SetCompare2||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare2 PROC
;;;1067     */
;;;1068   void TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2)
000000  6381              STR      r1,[r0,#0x38]
;;;1069   {
;;;1070     /* Check the parameters */
;;;1071     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1072   
;;;1073     /* Set the Capture Compare2 Register value */
;;;1074     TIMx->CCR2 = Compare2;
;;;1075   }
000002  4770              BX       lr
;;;1076   
                          ENDP


                          AREA ||i.TIM_SetCompare3||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare3 PROC
;;;1082     */
;;;1083   void TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3)
000000  63c1              STR      r1,[r0,#0x3c]
;;;1084   {
;;;1085     /* Check the parameters */
;;;1086     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1087   
;;;1088     /* Set the Capture Compare3 Register value */
;;;1089     TIMx->CCR3 = Compare3;
;;;1090   }
000002  4770              BX       lr
;;;1091   
                          ENDP


                          AREA ||i.TIM_SetCompare4||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare4 PROC
;;;1097     */
;;;1098   void TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4)
000000  6401              STR      r1,[r0,#0x40]
;;;1099   {
;;;1100     /* Check the parameters */
;;;1101     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1102   
;;;1103     /* Set the Capture Compare4 Register value */
;;;1104     TIMx->CCR4 = Compare4;
;;;1105   }
000002  4770              BX       lr
;;;1106   
                          ENDP


                          AREA ||i.TIM_SetCounter||, CODE, READONLY, ALIGN=1

                  TIM_SetCounter PROC
;;;402      */
;;;403    void TIM_SetCounter(TIM_TypeDef* TIMx, uint32_t Counter)
000000  6241              STR      r1,[r0,#0x24]
;;;404    {
;;;405      /* Check the parameters */
;;;406       assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;407    
;;;408      /* Set the Counter Register value */
;;;409      TIMx->CNT = Counter;
;;;410    }
000002  4770              BX       lr
;;;411    
                          ENDP


                          AREA ||i.TIM_SetIC1Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC1Prescaler PROC
;;;2084     */
;;;2085   void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;2086   {
;;;2087     /* Check the parameters */
;;;2088     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;2089     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2090   
;;;2091     /* Reset the IC1PSC Bits */
;;;2092     TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC1PSC;
000002  f022020c          BIC      r2,r2,#0xc
000006  8302              STRH     r2,[r0,#0x18]
;;;2093   
;;;2094     /* Set the IC1PSC value */
;;;2095     TIMx->CCMR1 |= TIM_ICPSC;
000008  8b02              LDRH     r2,[r0,#0x18]
00000a  4311              ORRS     r1,r1,r2
00000c  8301              STRH     r1,[r0,#0x18]
;;;2096   }
00000e  4770              BX       lr
;;;2097   
                          ENDP


                          AREA ||i.TIM_SetIC2Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC2Prescaler PROC
;;;2109     */
;;;2110   void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;2111   {
;;;2112     /* Check the parameters */
;;;2113     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2114     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2115   
;;;2116     /* Reset the IC2PSC Bits */
;;;2117     TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC2PSC;
000002  f4226240          BIC      r2,r2,#0xc00
000006  8302              STRH     r2,[r0,#0x18]
;;;2118   
;;;2119     /* Set the IC2PSC value */
;;;2120     TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
000008  8b02              LDRH     r2,[r0,#0x18]
00000a  f64f73ff          MOV      r3,#0xffff
00000e  ea032101          AND      r1,r3,r1,LSL #8
000012  4311              ORRS     r1,r1,r2
000014  8301              STRH     r1,[r0,#0x18]
;;;2121   }
000016  4770              BX       lr
;;;2122   
                          ENDP


                          AREA ||i.TIM_SetIC3Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC3Prescaler PROC
;;;2133     */
;;;2134   void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;2135   {
;;;2136     /* Check the parameters */
;;;2137     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2138     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2139   
;;;2140     /* Reset the IC3PSC Bits */
;;;2141     TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC3PSC;
000002  f022020c          BIC      r2,r2,#0xc
000006  8382              STRH     r2,[r0,#0x1c]
;;;2142   
;;;2143     /* Set the IC3PSC value */
;;;2144     TIMx->CCMR2 |= TIM_ICPSC;
000008  8b82              LDRH     r2,[r0,#0x1c]
00000a  4311              ORRS     r1,r1,r2
00000c  8381              STRH     r1,[r0,#0x1c]
;;;2145   }
00000e  4770              BX       lr
;;;2146   
                          ENDP


                          AREA ||i.TIM_SetIC4Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC4Prescaler PROC
;;;2157     */
;;;2158   void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;2159   {  
;;;2160     /* Check the parameters */
;;;2161     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2162     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2163   
;;;2164     /* Reset the IC4PSC Bits */
;;;2165     TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC4PSC;
000002  f4226240          BIC      r2,r2,#0xc00
000006  8382              STRH     r2,[r0,#0x1c]
;;;2166   
;;;2167     /* Set the IC4PSC value */
;;;2168     TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
000008  8b82              LDRH     r2,[r0,#0x1c]
00000a  f64f73ff          MOV      r3,#0xffff
00000e  ea032101          AND      r1,r3,r1,LSL #8
000012  4311              ORRS     r1,r1,r2
000014  8381              STRH     r1,[r0,#0x1c]
;;;2169   }
000016  4770              BX       lr
;;;2170   /**
                          ENDP


                          AREA ||i.TIM_TIxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_TIxExternalClockConfig PROC
;;;2723     */
;;;2724   void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
000000  b430              PUSH     {r4,r5}
000002  8c04              LDRH     r4,[r0,#0x20]
000004  f64f7cff          MOV      r12,#0xffff
;;;2725                                   uint16_t TIM_ICPolarity, uint16_t ICFilter)
;;;2726   {
;;;2727     /* Check the parameters */
;;;2728     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;2729     assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
;;;2730     assert_param(IS_TIM_IC_FILTER(ICFilter));
;;;2731   
;;;2732     /* Configure the Timer Input Clock Source */
;;;2733     if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
000008  2960              CMP      r1,#0x60
00000a  d01e              BEQ      |L84.74|
00000c  f0240401          BIC      r4,r4,#1              ;2726
000010  8404              STRH     r4,[r0,#0x20]         ;2726
000012  8b05              LDRH     r5,[r0,#0x18]         ;2726
000014  8c04              LDRH     r4,[r0,#0x20]         ;2726
000016  ea0c1303          AND      r3,r12,r3,LSL #4      ;2726
00001a  f02505f3          BIC      r5,r5,#0xf3           ;2726
00001e  f0430301          ORR      r3,r3,#1              ;2726
000022  f0240c0a          BIC      r12,r4,#0xa           ;2726
000026  432b              ORRS     r3,r3,r5              ;2726
000028  ea4c0202          ORR      r2,r12,r2             ;2726
00002c  f0420201          ORR      r2,r2,#1              ;2726
000030  8303              STRH     r3,[r0,#0x18]         ;2726
000032  8402              STRH     r2,[r0,#0x20]         ;2726
                  |L84.52|
000034  8902              LDRH     r2,[r0,#8]            ;2726
000036  f0220270          BIC      r2,r2,#0x70           ;2726
00003a  4311              ORRS     r1,r1,r2              ;2726
00003c  8101              STRH     r1,[r0,#8]            ;2726
;;;2734     {
;;;2735       TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
;;;2736     }
;;;2737     else
;;;2738     {
;;;2739       TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
;;;2740     }
;;;2741     /* Select the Trigger source */
;;;2742     TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
;;;2743     /* Select the External clock mode1 */
;;;2744     TIMx->SMCR |= TIM_SlaveMode_External1;
00003e  8901              LDRH     r1,[r0,#8]
000040  f0410107          ORR      r1,r1,#7
000044  8101              STRH     r1,[r0,#8]
;;;2745   }
000046  bc30              POP      {r4,r5}
000048  4770              BX       lr
                  |L84.74|
00004a  f0240410          BIC      r4,r4,#0x10
00004e  8404              STRH     r4,[r0,#0x20]
000050  8b05              LDRH     r5,[r0,#0x18]
000052  8c04              LDRH     r4,[r0,#0x20]
000054  ea0c3303          AND      r3,r12,r3,LSL #12
000058  ea0c1202          AND      r2,r12,r2,LSL #4
00005c  f4254573          BIC      r5,r5,#0xf300
000060  432b              ORRS     r3,r3,r5
000062  f0240ca0          BIC      r12,r4,#0xa0
000066  f4437380          ORR      r3,r3,#0x100
00006a  ea4c0202          ORR      r2,r12,r2
00006e  f0420210          ORR      r2,r2,#0x10
000072  8303              STRH     r3,[r0,#0x18]
000074  8402              STRH     r2,[r0,#0x20]
000076  e7dd              B        |L84.52|
;;;2746   
                          ENDP


                          AREA ||i.TIM_TimeBaseInit||, CODE, READONLY, ALIGN=2

                  TIM_TimeBaseInit PROC
;;;281      */
;;;282    void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  b410              PUSH     {r4}
;;;283    {
;;;284      uint16_t tmpcr1 = 0;
;;;285    
;;;286      /* Check the parameters */
;;;287      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;288      assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
;;;289      assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
;;;290    
;;;291      tmpcr1 = TIMx->CR1;  
000002  8802              LDRH     r2,[r0,#0]
;;;292    
;;;293      if((TIMx == TIM1) || (TIMx == TIM8)||
000004  4b1c              LDR      r3,|L85.120|
000006  f8dfc074          LDR      r12,|L85.124|
00000a  4298              CMP      r0,r3
00000c  bf18              IT       NE
00000e  4560              CMPNE    r0,r12
000010  d011              BEQ      |L85.54|
;;;294         (TIMx == TIM2) || (TIMx == TIM3)||
000012  f1b04f80          CMP      r0,#0x40000000
000016  bf1c              ITT      NE
000018  f1a04480          SUBNE    r4,r0,#0x40000000
00001c  f5b46480          SUBSNE   r4,r4,#0x400
000020  d009              BEQ      |L85.54|
;;;295         (TIMx == TIM4) || (TIMx == TIM5)) 
000022  f1a04480          SUB      r4,r0,#0x40000000
000026  f5b46400          SUBS     r4,r4,#0x800
00002a  bf1c              ITT      NE
00002c  f1a04480          SUBNE    r4,r0,#0x40000000
000030  f5b46440          SUBSNE   r4,r4,#0xc00
000034  d103              BNE      |L85.62|
                  |L85.54|
;;;296      {
;;;297        /* Select the Counter Mode */
;;;298        tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
;;;299        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
000036  884c              LDRH     r4,[r1,#2]
000038  f0220270          BIC      r2,r2,#0x70           ;298
00003c  4322              ORRS     r2,r2,r4
                  |L85.62|
;;;300      }
;;;301     
;;;302      if((TIMx != TIM6) && (TIMx != TIM7))
00003e  f1a04480          SUB      r4,r0,#0x40000000
000042  f5b45480          SUBS     r4,r4,#0x1000
000046  bf1c              ITT      NE
000048  f1a04480          SUBNE    r4,r0,#0x40000000
00004c  f5b454a0          SUBSNE   r4,r4,#0x1400
000050  d003              BEQ      |L85.90|
;;;303      {
;;;304        /* Set the clock division */
;;;305        tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
;;;306        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
000052  890c              LDRH     r4,[r1,#8]
000054  f4227240          BIC      r2,r2,#0x300          ;305
000058  4322              ORRS     r2,r2,r4
                  |L85.90|
;;;307      }
;;;308    
;;;309      TIMx->CR1 = tmpcr1;
00005a  8002              STRH     r2,[r0,#0]
;;;310    
;;;311      /* Set the Autoreload value */
;;;312      TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
00005c  684a              LDR      r2,[r1,#4]
00005e  62c2              STR      r2,[r0,#0x2c]
;;;313     
;;;314      /* Set the Prescaler value */
;;;315      TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
000060  880a              LDRH     r2,[r1,#0]
000062  8502              STRH     r2,[r0,#0x28]
;;;316        
;;;317      if ((TIMx == TIM1) || (TIMx == TIM8))  
000064  4298              CMP      r0,r3
000066  bf12              ITEE     NE
000068  4560              CMPNE    r0,r12
;;;318      {
;;;319        /* Set the Repetition Counter value */
;;;320        TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
00006a  7a89              LDRBEQ   r1,[r1,#0xa]
00006c  8601              STRHEQ   r1,[r0,#0x30]
;;;321      }
;;;322    
;;;323      /* Generate an update event to reload the Prescaler 
;;;324         and the repetition counter(only for TIM1 and TIM8) value immediatly */
;;;325      TIMx->EGR = TIM_PSCReloadMode_Immediate;          
00006e  2101              MOVS     r1,#1
000070  8281              STRH     r1,[r0,#0x14]
;;;326    }
000072  bc10              POP      {r4}
000074  4770              BX       lr
;;;327    
                          ENDP

000076  0000              DCW      0x0000
                  |L85.120|
                          DCD      0x40010000
                  |L85.124|
                          DCD      0x40010400

                          AREA ||i.TIM_TimeBaseStructInit||, CODE, READONLY, ALIGN=1

                  TIM_TimeBaseStructInit PROC
;;;333      */
;;;334    void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  f04f31ff          MOV      r1,#0xffffffff
;;;335    {
;;;336      /* Set the default configuration */
;;;337      TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
;;;338      TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
000004  6041              STR      r1,[r0,#4]
000006  2100              MOVS     r1,#0
000008  8001              STRH     r1,[r0,#0]
;;;339      TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
00000a  8101              STRH     r1,[r0,#8]
;;;340      TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
00000c  8041              STRH     r1,[r0,#2]
;;;341      TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
00000e  7281              STRB     r1,[r0,#0xa]
;;;342    }
000010  4770              BX       lr
;;;343    
                          ENDP


                          AREA ||i.TIM_UpdateDisableConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateDisableConfig PROC
;;;461      */
;;;462    void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;463    {
;;;464      /* Check the parameters */
;;;465      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;466      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;467    
;;;468      if (NewState != DISABLE)
;;;469      {
;;;470        /* Set the Update Disable Bit */
;;;471        TIMx->CR1 |= TIM_CR1_UDIS;
;;;472      }
;;;473      else
;;;474      {
;;;475        /* Reset the Update Disable Bit */
;;;476        TIMx->CR1 &= (uint16_t)~TIM_CR1_UDIS;
000002  8801              LDRH     r1,[r0,#0]
000004  bf14              ITE      NE                    ;471
000006  f0410102          ORRNE    r1,r1,#2              ;471
00000a  f0210102          BICEQ    r1,r1,#2
00000e  8001              STRH     r1,[r0,#0]            ;471
;;;477      }
;;;478    }
000010  4770              BX       lr
;;;479    
                          ENDP


                          AREA ||i.TIM_UpdateRequestConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateRequestConfig PROC
;;;490      */
;;;491    void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
000000  2900              CMP      r1,#0
;;;492    {
;;;493      /* Check the parameters */
;;;494      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;495      assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
;;;496    
;;;497      if (TIM_UpdateSource != TIM_UpdateSource_Global)
;;;498      {
;;;499        /* Set the URS Bit */
;;;500        TIMx->CR1 |= TIM_CR1_URS;
;;;501      }
;;;502      else
;;;503      {
;;;504        /* Reset the URS Bit */
;;;505        TIMx->CR1 &= (uint16_t)~TIM_CR1_URS;
000002  8801              LDRH     r1,[r0,#0]
000004  bf14              ITE      NE                    ;500
000006  f0410104          ORRNE    r1,r1,#4              ;500
00000a  f0210104          BICEQ    r1,r1,#4
00000e  8001              STRH     r1,[r0,#0]            ;500
;;;506      }
;;;507    }
000010  4770              BX       lr
;;;508    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_tim.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_tim_c_c458916b____REV16|
#line 114 "..\\..\\..\\M0P0_Library\\STM32F4xx_StdPeriph_Driver\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4xx_tim_c_c458916b____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_tim_c_c458916b____REVSH|
#line 128
|__asm___15_stm32f4xx_tim_c_c458916b____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
