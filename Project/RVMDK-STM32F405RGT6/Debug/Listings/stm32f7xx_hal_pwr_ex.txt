; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f7xx_hal_pwr_ex.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f7xx_hal_pwr_ex.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Core -I..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f7xx_hal_pwr_ex.crf ..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_pwr_ex.c]
                          THUMB

                          AREA ||i.HAL_PWREx_ControlVoltageScaling||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_ControlVoltageScaling PROC
;;;494      */
;;;495    HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
000000  b5f8              PUSH     {r3-r7,lr}
;;;496    {
000002  4606              MOV      r6,r0
;;;497      uint32_t tickstart = 0;
;;;498    
;;;499      assert_param(IS_PWR_REGULATOR_VOLTAGE(VoltageScaling));
;;;500    
;;;501      /* Enable Power ctrl clock */
;;;502      __HAL_RCC_PWR_CLK_ENABLE();
000004  482c              LDR      r0,|L1.184|
000006  6801              LDR      r1,[r0,#0]
000008  f0415180          ORR      r1,r1,#0x10000000
00000c  6001              STR      r1,[r0,#0]
00000e  6800              LDR      r0,[r0,#0]
000010  f0005080          AND      r0,r0,#0x10000000
;;;503    
;;;504      /* Check if the PLL is used as system clock or not */
;;;505      if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
000014  9000              STR      r0,[sp,#0]
000016  4829              LDR      r0,|L1.188|
000018  6800              LDR      r0,[r0,#0]
00001a  f000000c          AND      r0,r0,#0xc
00001e  2808              CMP      r0,#8
;;;506      {
;;;507        /* Disable the main PLL */
;;;508        __HAL_RCC_PLL_DISABLE();
;;;509        
;;;510        /* Get Start Tick */
;;;511        tickstart = HAL_GetTick();    
;;;512        /* Wait till PLL is disabled */  
;;;513        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
;;;514        {
;;;515          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
;;;516          {
;;;517            return HAL_TIMEOUT;
;;;518          }
;;;519        }
;;;520        
;;;521        /* Set Range */
;;;522        __HAL_PWR_VOLTAGESCALING_CONFIG(VoltageScaling);
;;;523        
;;;524        /* Enable the main PLL */
;;;525        __HAL_RCC_PLL_ENABLE();
;;;526        
;;;527        /* Get Start Tick */
;;;528        tickstart = HAL_GetTick();
;;;529        /* Wait till PLL is ready */  
;;;530        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
;;;531        {
;;;532          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
;;;533          {
;;;534            return HAL_TIMEOUT;
;;;535          } 
;;;536        }
;;;537        
;;;538        /* Get Start Tick */
;;;539        tickstart = HAL_GetTick();
;;;540        while((__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY) == RESET))
;;;541        {
;;;542          if((HAL_GetTick() - tickstart ) > PWR_VOSRDY_TIMEOUT_VALUE)
;;;543          {
;;;544            return HAL_TIMEOUT;
;;;545          } 
;;;546        }
;;;547      }
;;;548      else
;;;549      {
;;;550        return HAL_ERROR;
000020  bf04              ITT      EQ
000022  2001              MOVEQ    r0,#1
;;;551      }
;;;552      return HAL_OK;
;;;553    }
000024  bdf8              POPEQ    {r3-r7,pc}
000026  4c26              LDR      r4,|L1.192|
000028  6820              LDR      r0,[r4,#0]            ;508
00002a  f0207080          BIC      r0,r0,#0x1000000      ;508
00002e  6020              STR      r0,[r4,#0]            ;508
000030  f7fffffe          BL       HAL_GetTick
000034  4605              MOV      r5,r0                 ;511
000036  6820              LDR      r0,[r4,#0]            ;513
000038  f0107f00          TST      r0,#0x2000000         ;513
00003c  d009              BEQ      |L1.82|
00003e  bf00              NOP                            ;515
                  |L1.64|
000040  f7fffffe          BL       HAL_GetTick
000044  1b40              SUBS     r0,r0,r5              ;515
000046  2802              CMP      r0,#2                 ;515
000048  d82e              BHI      |L1.168|
00004a  6820              LDR      r0,[r4,#0]            ;517
00004c  f0107f00          TST      r0,#0x2000000         ;517
000050  d1f6              BNE      |L1.64|
                  |L1.82|
000052  4d1c              LDR      r5,|L1.196|
000054  6828              LDR      r0,[r5,#0]            ;522
000056  f4204040          BIC      r0,r0,#0xc000         ;522
00005a  4330              ORRS     r0,r0,r6              ;522
00005c  6028              STR      r0,[r5,#0]            ;522
00005e  6828              LDR      r0,[r5,#0]            ;522
000060  f4004040          AND      r0,r0,#0xc000         ;522
000064  9000              STR      r0,[sp,#0]            ;525
000066  6820              LDR      r0,[r4,#0]            ;525
000068  f0407080          ORR      r0,r0,#0x1000000      ;525
00006c  6020              STR      r0,[r4,#0]            ;525
00006e  f7fffffe          BL       HAL_GetTick
000072  4606              MOV      r6,r0                 ;528
000074  6820              LDR      r0,[r4,#0]            ;530
000076  f0107f00          TST      r0,#0x2000000         ;530
00007a  d108              BNE      |L1.142|
                  |L1.124|
00007c  f7fffffe          BL       HAL_GetTick
000080  1b80              SUBS     r0,r0,r6              ;532
000082  2802              CMP      r0,#2                 ;532
000084  d810              BHI      |L1.168|
000086  6820              LDR      r0,[r4,#0]            ;534
000088  f0107f00          TST      r0,#0x2000000         ;534
00008c  d0f6              BEQ      |L1.124|
                  |L1.142|
00008e  f7fffffe          BL       HAL_GetTick
000092  4604              MOV      r4,r0                 ;539
000094  6868              LDR      r0,[r5,#4]            ;540
000096  f4104f80          TST      r0,#0x4000            ;540
00009a  d10b              BNE      |L1.180|
                  |L1.156|
00009c  f7fffffe          BL       HAL_GetTick
0000a0  1b01              SUBS     r1,r0,r4              ;542
0000a2  f5b17f7a          CMP      r1,#0x3e8             ;542
0000a6  d901              BLS      |L1.172|
                  |L1.168|
0000a8  2003              MOVS     r0,#3                 ;544
0000aa  bdf8              POP      {r3-r7,pc}
                  |L1.172|
0000ac  6868              LDR      r0,[r5,#4]            ;544
0000ae  f4104f80          TST      r0,#0x4000            ;544
0000b2  d0f3              BEQ      |L1.156|
                  |L1.180|
0000b4  2000              MOVS     r0,#0                 ;552
0000b6  bdf8              POP      {r3-r7,pc}
;;;554    
                          ENDP

                  |L1.184|
                          DCD      0x40023840
                  |L1.188|
                          DCD      0x40023808
                  |L1.192|
                          DCD      0x40023800
                  |L1.196|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableBkUpReg||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableBkUpReg PROC
;;;181      */
;;;182    HAL_StatusTypeDef HAL_PWREx_DisableBkUpReg(void)
000000  b570              PUSH     {r4-r6,lr}
;;;183    {
;;;184      uint32_t tickstart = 0;
;;;185      
;;;186      /* Disable Backup regulator */
;;;187      PWR->CSR1 &= (uint32_t)~((uint32_t)PWR_CSR1_BRE);
000002  4d0f              LDR      r5,|L2.64|
000004  6868              LDR      r0,[r5,#4]
000006  f4207000          BIC      r0,r0,#0x200
00000a  6068              STR      r0,[r5,#4]
;;;188      
;;;189      /* Workaround for the following hardware bug: */
;;;190      /* Id 19: PWR : No STANDBY wake-up when Back-up RAM enabled (ref. Errata Sheet p23) */
;;;191      PWR->CSR1 |= PWR_CSR1_EIWUP;
00000c  6868              LDR      r0,[r5,#4]
00000e  f4407080          ORR      r0,r0,#0x100
000012  6068              STR      r0,[r5,#4]
;;;192    
;;;193      /* Get tick */
;;;194      tickstart = HAL_GetTick();
000014  f7fffffe          BL       HAL_GetTick
000018  4604              MOV      r4,r0
;;;195    
;;;196      /* Wait till Backup regulator ready flag is set */  
;;;197      while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) != RESET)
00001a  6868              LDR      r0,[r5,#4]
00001c  f0100f08          TST      r0,#8
000020  d00c              BEQ      |L2.60|
;;;198      {
;;;199        if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)
000022  bf00              NOP      
                  |L2.36|
000024  f7fffffe          BL       HAL_GetTick
000028  1b00              SUBS     r0,r0,r4
00002a  f5b07f7a          CMP      r0,#0x3e8
00002e  d901              BLS      |L2.52|
;;;200        {
;;;201          return HAL_TIMEOUT;
000030  2003              MOVS     r0,#3
;;;202        } 
;;;203      }
;;;204      return HAL_OK;
;;;205    }
000032  bd70              POP      {r4-r6,pc}
                  |L2.52|
000034  6868              LDR      r0,[r5,#4]            ;197
000036  f0100f08          TST      r0,#8                 ;197
00003a  d1f3              BNE      |L2.36|
                  |L2.60|
00003c  2000              MOVS     r0,#0                 ;204
00003e  bd70              POP      {r4-r6,pc}
;;;206    
                          ENDP

                  |L2.64|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableFlashPowerDown||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableFlashPowerDown PROC
;;;220      */
;;;221    void HAL_PWREx_DisableFlashPowerDown(void)
000000  4802              LDR      r0,|L3.12|
;;;222    {
;;;223      /* Disable the Flash Power Down */
;;;224      PWR->CR1 &= (uint32_t)~((uint32_t)PWR_CR1_FPDS);
000002  6801              LDR      r1,[r0,#0]
000004  f4217100          BIC      r1,r1,#0x200
000008  6001              STR      r1,[r0,#0]
;;;225    }
00000a  4770              BX       lr
;;;226    
                          ENDP

                  |L3.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableLowRegulatorLowVoltage||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableLowRegulatorLowVoltage PROC
;;;260      */
;;;261    void HAL_PWREx_DisableLowRegulatorLowVoltage(void)
000000  4802              LDR      r0,|L4.12|
;;;262    {
;;;263      /* Disable low power regulator */
;;;264      PWR->CR1 &= (uint32_t)~((uint32_t)PWR_CR1_LPUDS);
000002  6801              LDR      r1,[r0,#0]
000004  f4216180          BIC      r1,r1,#0x400
000008  6001              STR      r1,[r0,#0]
;;;265    }
00000a  4770              BX       lr
;;;266    
                          ENDP

                  |L4.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableMainRegulatorLowVoltage||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableMainRegulatorLowVoltage PROC
;;;240      */
;;;241    void HAL_PWREx_DisableMainRegulatorLowVoltage(void)
000000  4802              LDR      r0,|L5.12|
;;;242    {  
;;;243      /* Disable Main regulator low voltage */
;;;244      PWR->CR1 &= (uint32_t)~((uint32_t)PWR_CR1_MRUDS);
000002  6801              LDR      r1,[r0,#0]
000004  f4216100          BIC      r1,r1,#0x800
000008  6001              STR      r1,[r0,#0]
;;;245    }
00000a  4770              BX       lr
;;;246    
                          ENDP

                  |L5.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableOverDrive||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableOverDrive PROC
;;;322      */
;;;323    HAL_StatusTypeDef HAL_PWREx_DisableOverDrive(void)
000000  481c              LDR      r0,|L6.116|
;;;324    {
000002  b538              PUSH     {r3-r5,lr}
;;;325      uint32_t tickstart = 0;
;;;326      
;;;327      __HAL_RCC_PWR_CLK_ENABLE();
000004  6801              LDR      r1,[r0,#0]
000006  f0415180          ORR      r1,r1,#0x10000000
00000a  6001              STR      r1,[r0,#0]
00000c  6800              LDR      r0,[r0,#0]
;;;328        
;;;329      /* Disable the Over-drive switch */
;;;330      __HAL_PWR_OVERDRIVESWITCHING_DISABLE();
00000e  4d1a              LDR      r5,|L6.120|
000010  f0005080          AND      r0,r0,#0x10000000     ;327
000014  9000              STR      r0,[sp,#0]
000016  6828              LDR      r0,[r5,#0]
000018  f4203000          BIC      r0,r0,#0x20000
00001c  6028              STR      r0,[r5,#0]
;;;331      
;;;332      /* Get tick */
;;;333      tickstart = HAL_GetTick();
00001e  f7fffffe          BL       HAL_GetTick
000022  4604              MOV      r4,r0
;;;334     
;;;335      while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
000024  6868              LDR      r0,[r5,#4]
000026  f4103f00          TST      r0,#0x20000
00002a  d009              BEQ      |L6.64|
                  |L6.44|
;;;336      {
;;;337        if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
00002c  f7fffffe          BL       HAL_GetTick
000030  1b00              SUBS     r0,r0,r4
000032  f5b07f7a          CMP      r0,#0x3e8
000036  d815              BHI      |L6.100|
;;;338        {
;;;339          return HAL_TIMEOUT;
000038  6868              LDR      r0,[r5,#4]
00003a  f4103f00          TST      r0,#0x20000
00003e  d1f5              BNE      |L6.44|
                  |L6.64|
;;;340        }
;;;341      } 
;;;342      
;;;343      /* Disable the Over-drive */
;;;344      __HAL_PWR_OVERDRIVE_DISABLE();
000040  6828              LDR      r0,[r5,#0]
000042  f4203080          BIC      r0,r0,#0x10000
000046  6028              STR      r0,[r5,#0]
;;;345    
;;;346      /* Get tick */
;;;347      tickstart = HAL_GetTick();
000048  f7fffffe          BL       HAL_GetTick
00004c  4604              MOV      r4,r0
;;;348    
;;;349      while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
00004e  6868              LDR      r0,[r5,#4]
000050  f4103f80          TST      r0,#0x10000
000054  d00c              BEQ      |L6.112|
;;;350      {
;;;351        if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
000056  bf00              NOP      
                  |L6.88|
000058  f7fffffe          BL       HAL_GetTick
00005c  1b00              SUBS     r0,r0,r4
00005e  f5b07f7a          CMP      r0,#0x3e8
000062  d901              BLS      |L6.104|
                  |L6.100|
;;;352        {
;;;353          return HAL_TIMEOUT;
000064  2003              MOVS     r0,#3
;;;354        }
;;;355      }
;;;356      
;;;357      return HAL_OK;
;;;358    }
000066  bd38              POP      {r3-r5,pc}
                  |L6.104|
000068  6868              LDR      r0,[r5,#4]            ;353
00006a  f4103f80          TST      r0,#0x10000           ;353
00006e  d1f3              BNE      |L6.88|
                  |L6.112|
000070  2000              MOVS     r0,#0                 ;357
000072  bd38              POP      {r3-r5,pc}
;;;359    
                          ENDP

                  |L6.116|
                          DCD      0x40023840
                  |L6.120|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableBkUpReg||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableBkUpReg PROC
;;;152      */
;;;153    HAL_StatusTypeDef HAL_PWREx_EnableBkUpReg(void)
000000  b570              PUSH     {r4-r6,lr}
;;;154    {
;;;155      uint32_t tickstart = 0;
;;;156    
;;;157      /* Enable Backup regulator */
;;;158      PWR->CSR1 |= PWR_CSR1_BRE;
000002  4d0f              LDR      r5,|L7.64|
000004  6868              LDR      r0,[r5,#4]
000006  f4407000          ORR      r0,r0,#0x200
00000a  6068              STR      r0,[r5,#4]
;;;159        
;;;160      /* Workaround for the following hardware bug: */
;;;161      /* Id 19: PWR : No STANDBY wake-up when Back-up RAM enabled (ref. Errata Sheet p23) */
;;;162      PWR->CSR1 |= PWR_CSR1_EIWUP;
00000c  6868              LDR      r0,[r5,#4]
00000e  f4407080          ORR      r0,r0,#0x100
000012  6068              STR      r0,[r5,#4]
;;;163    
;;;164      /* Get tick */
;;;165      tickstart = HAL_GetTick();
000014  f7fffffe          BL       HAL_GetTick
000018  4604              MOV      r4,r0
;;;166    
;;;167      /* Wait till Backup regulator ready flag is set */  
;;;168      while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) == RESET)
00001a  6868              LDR      r0,[r5,#4]
00001c  f0100f08          TST      r0,#8
000020  d10c              BNE      |L7.60|
;;;169      {
;;;170        if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)
000022  bf00              NOP      
                  |L7.36|
000024  f7fffffe          BL       HAL_GetTick
000028  1b00              SUBS     r0,r0,r4
00002a  f5b07f7a          CMP      r0,#0x3e8
00002e  d901              BLS      |L7.52|
;;;171        {
;;;172          return HAL_TIMEOUT;
000030  2003              MOVS     r0,#3
;;;173        } 
;;;174      }
;;;175      return HAL_OK;
;;;176    }
000032  bd70              POP      {r4-r6,pc}
                  |L7.52|
000034  6868              LDR      r0,[r5,#4]            ;168
000036  f0100f08          TST      r0,#8                 ;168
00003a  d0f3              BEQ      |L7.36|
                  |L7.60|
00003c  2000              MOVS     r0,#0                 ;175
00003e  bd70              POP      {r4-r6,pc}
;;;177    
                          ENDP

                  |L7.64|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableFlashPowerDown||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableFlashPowerDown PROC
;;;210      */
;;;211    void HAL_PWREx_EnableFlashPowerDown(void)
000000  4802              LDR      r0,|L8.12|
;;;212    {
;;;213      /* Enable the Flash Power Down */
;;;214      PWR->CR1 |= PWR_CR1_FPDS;
000002  6801              LDR      r1,[r0,#0]
000004  f4417100          ORR      r1,r1,#0x200
000008  6001              STR      r1,[r0,#0]
;;;215    }
00000a  4770              BX       lr
;;;216    
                          ENDP

                  |L8.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableLowRegulatorLowVoltage||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableLowRegulatorLowVoltage PROC
;;;250      */
;;;251    void HAL_PWREx_EnableLowRegulatorLowVoltage(void)
000000  4802              LDR      r0,|L9.12|
;;;252    {
;;;253      /* Enable low power regulator */
;;;254      PWR->CR1 |= PWR_CR1_LPUDS;
000002  6801              LDR      r1,[r0,#0]
000004  f4416180          ORR      r1,r1,#0x400
000008  6001              STR      r1,[r0,#0]
;;;255    }
00000a  4770              BX       lr
;;;256    
                          ENDP

                  |L9.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableMainRegulatorLowVoltage||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableMainRegulatorLowVoltage PROC
;;;230      */
;;;231    void HAL_PWREx_EnableMainRegulatorLowVoltage(void)
000000  4802              LDR      r0,|L10.12|
;;;232    {
;;;233      /* Enable Main regulator low voltage */
;;;234      PWR->CR1 |= PWR_CR1_MRUDS;
000002  6801              LDR      r1,[r0,#0]
000004  f4416100          ORR      r1,r1,#0x800
000008  6001              STR      r1,[r0,#0]
;;;235    }
00000a  4770              BX       lr
;;;236    
                          ENDP

                  |L10.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableOverDrive||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableOverDrive PROC
;;;276      */
;;;277    HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
000000  481c              LDR      r0,|L11.116|
;;;278    {
000002  b538              PUSH     {r3-r5,lr}
;;;279      uint32_t tickstart = 0;
;;;280    
;;;281      __HAL_RCC_PWR_CLK_ENABLE();
000004  6801              LDR      r1,[r0,#0]
000006  f0415180          ORR      r1,r1,#0x10000000
00000a  6001              STR      r1,[r0,#0]
00000c  6800              LDR      r0,[r0,#0]
;;;282      
;;;283      /* Enable the Over-drive to extend the clock frequency to 216 MHz */
;;;284      __HAL_PWR_OVERDRIVE_ENABLE();
00000e  4d1a              LDR      r5,|L11.120|
000010  f0005080          AND      r0,r0,#0x10000000     ;281
000014  9000              STR      r0,[sp,#0]
000016  6828              LDR      r0,[r5,#0]
000018  f4403080          ORR      r0,r0,#0x10000
00001c  6028              STR      r0,[r5,#0]
;;;285    
;;;286      /* Get tick */
;;;287      tickstart = HAL_GetTick();
00001e  f7fffffe          BL       HAL_GetTick
000022  4604              MOV      r4,r0
;;;288    
;;;289      while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
000024  6868              LDR      r0,[r5,#4]
000026  f4103f80          TST      r0,#0x10000
00002a  d109              BNE      |L11.64|
                  |L11.44|
;;;290      {
;;;291        if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
00002c  f7fffffe          BL       HAL_GetTick
000030  1b00              SUBS     r0,r0,r4
000032  f5b07f7a          CMP      r0,#0x3e8
000036  d815              BHI      |L11.100|
;;;292        {
;;;293          return HAL_TIMEOUT;
000038  6868              LDR      r0,[r5,#4]
00003a  f4103f80          TST      r0,#0x10000
00003e  d0f5              BEQ      |L11.44|
                  |L11.64|
;;;294        }
;;;295      }
;;;296      
;;;297      /* Enable the Over-drive switch */
;;;298      __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
000040  6828              LDR      r0,[r5,#0]
000042  f4403000          ORR      r0,r0,#0x20000
000046  6028              STR      r0,[r5,#0]
;;;299    
;;;300      /* Get tick */
;;;301      tickstart = HAL_GetTick();
000048  f7fffffe          BL       HAL_GetTick
00004c  4604              MOV      r4,r0
;;;302    
;;;303      while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
00004e  6868              LDR      r0,[r5,#4]
000050  f4103f00          TST      r0,#0x20000
000054  d10c              BNE      |L11.112|
;;;304      {
;;;305        if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
000056  bf00              NOP      
                  |L11.88|
000058  f7fffffe          BL       HAL_GetTick
00005c  1b00              SUBS     r0,r0,r4
00005e  f5b07f7a          CMP      r0,#0x3e8
000062  d901              BLS      |L11.104|
                  |L11.100|
;;;306        {
;;;307          return HAL_TIMEOUT;
000064  2003              MOVS     r0,#3
;;;308        }
;;;309      } 
;;;310      return HAL_OK;
;;;311    }
000066  bd38              POP      {r3-r5,pc}
                  |L11.104|
000068  6868              LDR      r0,[r5,#4]            ;307
00006a  f4103f00          TST      r0,#0x20000           ;307
00006e  d0f3              BEQ      |L11.88|
                  |L11.112|
000070  2000              MOVS     r0,#0                 ;310
000072  bd38              POP      {r3-r5,pc}
;;;312    
                          ENDP

                  |L11.116|
                          DCD      0x40023840
                  |L11.120|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnterUnderDriveSTOPMode||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnterUnderDriveSTOPMode PROC
;;;396      */
;;;397    HAL_StatusTypeDef HAL_PWREx_EnterUnderDriveSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;398    {
000004  4680              MOV      r8,r0
;;;399      uint32_t tempreg = 0;
;;;400      uint32_t tickstart = 0;
;;;401      
;;;402      /* Check the parameters */
;;;403      assert_param(IS_PWR_REGULATOR_UNDERDRIVE(Regulator));
;;;404      assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
;;;405      
;;;406      /* Enable Power ctrl clock */
;;;407      __HAL_RCC_PWR_CLK_ENABLE();
000006  4821              LDR      r0,|L12.140|
000008  460f              MOV      r7,r1                 ;398
00000a  6801              LDR      r1,[r0,#0]
00000c  f0415180          ORR      r1,r1,#0x10000000
000010  6001              STR      r1,[r0,#0]
000012  6800              LDR      r0,[r0,#0]
;;;408      /* Enable the Under-drive Mode ---------------------------------------------*/
;;;409      /* Clear Under-drive flag */
;;;410      __HAL_PWR_CLEAR_ODRUDR_FLAG();
000014  4d1e              LDR      r5,|L12.144|
000016  f0005080          AND      r0,r0,#0x10000000     ;407
00001a  9000              STR      r0,[sp,#0]
00001c  6868              LDR      r0,[r5,#4]
00001e  f4402040          ORR      r0,r0,#0xc0000
000022  6068              STR      r0,[r5,#4]
;;;411      
;;;412      /* Enable the Under-drive */ 
;;;413      __HAL_PWR_UNDERDRIVE_ENABLE();
000024  6828              LDR      r0,[r5,#0]
000026  f4402040          ORR      r0,r0,#0xc0000
00002a  6028              STR      r0,[r5,#0]
;;;414    
;;;415      /* Get tick */
;;;416      tickstart = HAL_GetTick();
00002c  f7fffffe          BL       HAL_GetTick
000030  4604              MOV      r4,r0
;;;417    
;;;418      /* Wait for UnderDrive mode is ready */
;;;419      while(__HAL_PWR_GET_FLAG(PWR_FLAG_UDRDY))
000032  6868              LDR      r0,[r5,#4]
000034  f44f2640          MOV      r6,#0xc0000
000038  ea360000          BICS     r0,r6,r0
00003c  d10d              BNE      |L12.90|
;;;420      {
;;;421        if((HAL_GetTick() - tickstart ) > PWR_UDERDRIVE_TIMEOUT_VALUE)
00003e  bf00              NOP      
                  |L12.64|
000040  f7fffffe          BL       HAL_GetTick
000044  1b00              SUBS     r0,r0,r4
000046  f5b07f7a          CMP      r0,#0x3e8
00004a  d902              BLS      |L12.82|
;;;422        {
;;;423          return HAL_TIMEOUT;
00004c  2003              MOVS     r0,#3
;;;424        }
;;;425      }
;;;426      
;;;427      /* Select the regulator state in STOP mode ---------------------------------*/
;;;428      tempreg = PWR->CR1;
;;;429      /* Clear PDDS, LPDS, MRLUDS and LPLUDS bits */
;;;430      tempreg &= (uint32_t)~(PWR_CR1_PDDS | PWR_CR1_LPDS | PWR_CR1_LPUDS | PWR_CR1_MRUDS);
;;;431      
;;;432      /* Set LPDS, MRLUDS and LPLUDS bits according to PWR_Regulator value */
;;;433      tempreg |= Regulator;
;;;434      
;;;435      /* Store the new value */
;;;436      PWR->CR1 = tempreg;
;;;437      
;;;438      /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;439      SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
;;;440      
;;;441      /* Select STOP mode entry --------------------------------------------------*/
;;;442      if(STOPEntry == PWR_SLEEPENTRY_WFI)
;;;443      {   
;;;444        /* Request Wait For Interrupt */
;;;445        __WFI();
;;;446      }
;;;447      else
;;;448      {
;;;449        /* Request Wait For Event */
;;;450        __WFE();
;;;451      }
;;;452      /* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;453      SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
;;;454    
;;;455      return HAL_OK;  
;;;456    }
00004e  e8bd83f8          POP      {r3-r9,pc}
                  |L12.82|
000052  6868              LDR      r0,[r5,#4]            ;423
000054  ea360000          BICS     r0,r6,r0              ;423
000058  d0f2              BEQ      |L12.64|
                  |L12.90|
00005a  480e              LDR      r0,|L12.148|
00005c  6829              LDR      r1,[r5,#0]            ;428
00005e  2f01              CMP      r7,#1                 ;442
000060  f0210103          BIC      r1,r1,#3              ;430
000064  f4216140          BIC      r1,r1,#0xc00          ;430
000068  ea410108          ORR      r1,r1,r8              ;433
00006c  6029              STR      r1,[r5,#0]            ;436
00006e  6801              LDR      r1,[r0,#0]            ;439
000070  f0410104          ORR      r1,r1,#4              ;439
000074  6001              STR      r1,[r0,#0]            ;439
000076  bf0c              ITE      EQ                    ;445
000078  bf30              WFIEQ                          ;445
00007a  bf20              WFENE                          ;450
00007c  6801              LDR      r1,[r0,#0]            ;453
00007e  f0210104          BIC      r1,r1,#4              ;453
000082  6001              STR      r1,[r0,#0]            ;453
000084  2000              MOVS     r0,#0                 ;455
000086  e8bd83f8          POP      {r3-r9,pc}
;;;457    
                          ENDP

00008a  0000              DCW      0x0000
                  |L12.140|
                          DCD      0x40023840
                  |L12.144|
                          DCD      0x40007000
                  |L12.148|
                          DCD      0xe000ed10

                          AREA ||i.HAL_PWREx_GetVoltageRange||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_GetVoltageRange PROC
;;;462      */  
;;;463    uint32_t HAL_PWREx_GetVoltageRange(void)
000000  4802              LDR      r0,|L13.12|
;;;464    {
;;;465      return  (PWR->CR1 & PWR_CR1_VOS);
000002  6800              LDR      r0,[r0,#0]
000004  f4004040          AND      r0,r0,#0xc000
;;;466    }
000008  4770              BX       lr
;;;467    
                          ENDP

00000a  0000              DCW      0x0000
                  |L13.12|
                          DCD      0x40007000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_pwr_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f7xx_hal_pwr_ex_c_1028ebfa____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32F7xx_HAL_Driver\\Core\\cmsis_armcc.h"
|__asm___22_stm32f7xx_hal_pwr_ex_c_1028ebfa____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f7xx_hal_pwr_ex_c_1028ebfa____REVSH|
#line 402
|__asm___22_stm32f7xx_hal_pwr_ex_c_1028ebfa____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f7xx_hal_pwr_ex_c_1028ebfa____RRX|
#line 587
|__asm___22_stm32f7xx_hal_pwr_ex_c_1028ebfa____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
