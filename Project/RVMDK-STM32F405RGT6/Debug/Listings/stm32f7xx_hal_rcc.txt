; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f7xx_hal_rcc.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f7xx_hal_rcc.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Core -I..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f7xx_hal_rcc.crf ..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_rcc.c]
                          THUMB

                          AREA ||i.HAL_RCC_CSSCallback||, CODE, READONLY, ALIGN=1

                  HAL_RCC_CSSCallback PROC
;;;1076     */
;;;1077   __weak void HAL_RCC_CSSCallback(void)
000000  4770              BX       lr
;;;1078   {
;;;1079     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1080               the HAL_RCC_CSSCallback could be implemented in the user file
;;;1081      */ 
;;;1082   }
;;;1083   
                          ENDP


                          AREA ||i.HAL_RCC_ClockConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_ClockConfig PROC
;;;582      */
;;;583    HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;584    {
;;;585      uint32_t tickstart = 0;
;;;586    
;;;587      /* Check the parameters */
;;;588      assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
;;;589      assert_param(IS_FLASH_LATENCY(FLatency));
;;;590    
;;;591      /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
;;;592      must be correctly programmed according to the frequency of the CPU clock 
;;;593      (HCLK) and the supply voltage of the device. */
;;;594      
;;;595      /* Increasing the CPU frequency */
;;;596      if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
000004  f8df81e4          LDR      r8,|L2.492|
000008  4606              MOV      r6,r0                 ;584
00000a  460f              MOV      r7,r1                 ;584
00000c  f8d80000          LDR      r0,[r8,#0]
000010  f000000f          AND      r0,r0,#0xf
000014  42b8              CMP      r0,r7
000016  d20c              BCS      |L2.50|
;;;597      {    
;;;598        /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
;;;599        __HAL_FLASH_SET_LATENCY(FLatency);
000018  f8d80000          LDR      r0,[r8,#0]
00001c  f020000f          BIC      r0,r0,#0xf
000020  4338              ORRS     r0,r0,r7
000022  f8c80000          STR      r0,[r8,#0]
;;;600        
;;;601        /* Check that the new number of wait states is taken into account to access the Flash
;;;602        memory by reading the FLASH_ACR register */
;;;603        if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
000026  f8d80000          LDR      r0,[r8,#0]
00002a  f000000f          AND      r0,r0,#0xf
00002e  42b8              CMP      r0,r7
000030  d172              BNE      |L2.280|
                  |L2.50|
;;;604        {
;;;605          return HAL_ERROR;
;;;606        }
;;;607      }
;;;608      
;;;609      /*-------------------------- HCLK Configuration --------------------------*/
;;;610      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
000032  7830              LDRB     r0,[r6,#0]
;;;611      {
;;;612        assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
;;;613        MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
000034  4d6e              LDR      r5,|L2.496|
000036  f0100f02          TST      r0,#2                 ;610
00003a  d005              BEQ      |L2.72|
00003c  68b0              LDR      r0,[r6,#8]
00003e  6829              LDR      r1,[r5,#0]
000040  f02101f0          BIC      r1,r1,#0xf0
000044  4308              ORRS     r0,r0,r1
000046  6028              STR      r0,[r5,#0]
                  |L2.72|
;;;614      }
;;;615      
;;;616      /*------------------------- SYSCLK Configuration ---------------------------*/ 
;;;617      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
000048  7830              LDRB     r0,[r6,#0]
00004a  f0100f01          TST      r0,#1
00004e  d050              BEQ      |L2.242|
;;;618      {    
;;;619        assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
;;;620        
;;;621        /* HSE is selected as System Clock Source */
;;;622        if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
000050  6870              LDR      r0,[r6,#4]
;;;623        {
;;;624          /* Check the HSE ready flag */  
;;;625          if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
000052  4968              LDR      r1,|L2.500|
000054  2801              CMP      r0,#1                 ;622
000056  d021              BEQ      |L2.156|
;;;626          {
;;;627            return HAL_ERROR;
;;;628          }
;;;629        }
;;;630        /* PLL is selected as System Clock Source */
;;;631        else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
;;;632        {
;;;633          /* Check the PLL ready flag */  
;;;634          if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
;;;635          {
;;;636            return HAL_ERROR;
;;;637          }
;;;638        }
;;;639        /* HSI is selected as System Clock Source */
;;;640        else
;;;641        {
;;;642          /* Check the HSI ready flag */  
;;;643          if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
000058  6809              LDR      r1,[r1,#0]
00005a  2802              CMP      r0,#2                 ;631
00005c  d023              BEQ      |L2.166|
00005e  f0110f02          TST      r1,#2
000062  d059              BEQ      |L2.280|
                  |L2.100|
;;;644          {
;;;645            return HAL_ERROR;
;;;646          }
;;;647        }
;;;648        
;;;649        __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
000064  6829              LDR      r1,[r5,#0]
000066  f0210103          BIC      r1,r1,#3
00006a  4308              ORRS     r0,r0,r1
00006c  6028              STR      r0,[r5,#0]
;;;650        /* Get Start Tick*/
;;;651        tickstart = HAL_GetTick();
00006e  f7fffffe          BL       HAL_GetTick
000072  4604              MOV      r4,r0
;;;652        
;;;653        if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
000074  6870              LDR      r0,[r6,#4]
;;;654        {
;;;655          while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
;;;656          {
;;;657            if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
000076  f2413988          MOV      r9,#0x1388
00007a  2801              CMP      r0,#1                 ;653
00007c  d017              BEQ      |L2.174|
;;;658            {
;;;659              return HAL_TIMEOUT;
;;;660            }
;;;661          }
;;;662        }
;;;663        else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
00007e  2802              CMP      r0,#2
;;;664        {
;;;665          while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
;;;666          {
;;;667            if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
;;;668            {
;;;669              return HAL_TIMEOUT;
;;;670            }
;;;671          }
;;;672        }
;;;673        else
;;;674        {
;;;675          while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
000080  6828              LDR      r0,[r5,#0]
000082  f000000c          AND      r0,r0,#0xc
000086  d022              BEQ      |L2.206|
000088  b300              CBZ      r0,|L2.204|
;;;676          {
;;;677            if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
00008a  bf00              NOP      
                  |L2.140|
00008c  f7fffffe          BL       HAL_GetTick
000090  1b00              SUBS     r0,r0,r4
000092  4548              CMP      r0,r9
000094  d929              BLS      |L2.234|
                  |L2.150|
;;;678            {
;;;679              return HAL_TIMEOUT;
000096  2003              MOVS     r0,#3
;;;680            }
;;;681          }
;;;682        }
;;;683      }
;;;684      
;;;685      /* Decreasing the number of wait states because of lower CPU frequency */
;;;686      if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
;;;687      {
;;;688        /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
;;;689        __HAL_FLASH_SET_LATENCY(FLatency);
;;;690        
;;;691        /* Check that the new number of wait states is taken into account to access the Flash
;;;692        memory by reading the FLASH_ACR register */
;;;693        if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
;;;694        {
;;;695          return HAL_ERROR;
;;;696        }
;;;697      }
;;;698    
;;;699      /*-------------------------- PCLK1 Configuration ---------------------------*/ 
;;;700      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
;;;701      {
;;;702        assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
;;;703        MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
;;;704      }
;;;705      
;;;706      /*-------------------------- PCLK2 Configuration ---------------------------*/ 
;;;707      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
;;;708      {
;;;709        assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
;;;710        MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
;;;711      }
;;;712    
;;;713      /* Update the SystemCoreClock global variable */
;;;714      SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
;;;715      
;;;716      /* Configure the source of time base considering new system clocks settings*/
;;;717      HAL_InitTick (TICK_INT_PRIORITY);
;;;718      
;;;719      return HAL_OK;
;;;720    }
000098  e8bd87f0          POP      {r4-r10,pc}
                  |L2.156|
00009c  6809              LDR      r1,[r1,#0]            ;625
00009e  f4113f00          TST      r1,#0x20000           ;625
0000a2  d1df              BNE      |L2.100|
0000a4  e038              B        |L2.280|
                  |L2.166|
0000a6  f0117f00          TST      r1,#0x2000000         ;634
0000aa  d1db              BNE      |L2.100|
0000ac  e034              B        |L2.280|
                  |L2.174|
0000ae  6828              LDR      r0,[r5,#0]            ;655
0000b0  f000000c          AND      r0,r0,#0xc            ;655
0000b4  2804              CMP      r0,#4                 ;655
0000b6  d01c              BEQ      |L2.242|
                  |L2.184|
0000b8  f7fffffe          BL       HAL_GetTick
0000bc  1b00              SUBS     r0,r0,r4              ;657
0000be  4548              CMP      r0,r9                 ;657
0000c0  d8e9              BHI      |L2.150|
0000c2  6828              LDR      r0,[r5,#0]            ;655
0000c4  f000000c          AND      r0,r0,#0xc            ;655
0000c8  2804              CMP      r0,#4                 ;655
0000ca  d1f5              BNE      |L2.184|
                  |L2.204|
0000cc  e011              B        |L2.242|
                  |L2.206|
0000ce  2808              CMP      r0,#8                 ;665
0000d0  d00f              BEQ      |L2.242|
0000d2  bf00              NOP                            ;667
                  |L2.212|
0000d4  f7fffffe          BL       HAL_GetTick
0000d8  1b00              SUBS     r0,r0,r4              ;667
0000da  4548              CMP      r0,r9                 ;667
0000dc  d8db              BHI      |L2.150|
0000de  6828              LDR      r0,[r5,#0]            ;665
0000e0  f000000c          AND      r0,r0,#0xc            ;665
0000e4  2808              CMP      r0,#8                 ;665
0000e6  d1f5              BNE      |L2.212|
0000e8  e003              B        |L2.242|
                  |L2.234|
0000ea  6828              LDR      r0,[r5,#0]            ;675
0000ec  f0100f0c          TST      r0,#0xc               ;675
0000f0  d1cc              BNE      |L2.140|
                  |L2.242|
0000f2  f8d80000          LDR      r0,[r8,#0]            ;686
0000f6  f000000f          AND      r0,r0,#0xf            ;686
0000fa  42b8              CMP      r0,r7                 ;686
0000fc  d90f              BLS      |L2.286|
0000fe  f8d80000          LDR      r0,[r8,#0]            ;689
000102  f020000f          BIC      r0,r0,#0xf            ;689
000106  4338              ORRS     r0,r0,r7              ;689
000108  f8c80000          STR      r0,[r8,#0]            ;689
00010c  f8d80000          LDR      r0,[r8,#0]            ;693
000110  f000000f          AND      r0,r0,#0xf            ;693
000114  42b8              CMP      r0,r7                 ;693
000116  d002              BEQ      |L2.286|
                  |L2.280|
000118  2001              MOVS     r0,#1                 ;695
00011a  e8bd87f0          POP      {r4-r10,pc}
                  |L2.286|
00011e  7830              LDRB     r0,[r6,#0]            ;700
000120  f0100f04          TST      r0,#4                 ;700
000124  d005              BEQ      |L2.306|
000126  68f0              LDR      r0,[r6,#0xc]          ;703
000128  6829              LDR      r1,[r5,#0]            ;703
00012a  f42151e0          BIC      r1,r1,#0x1c00         ;703
00012e  4308              ORRS     r0,r0,r1              ;703
000130  6028              STR      r0,[r5,#0]            ;703
                  |L2.306|
000132  7830              LDRB     r0,[r6,#0]            ;707
000134  f0100f08          TST      r0,#8                 ;707
000138  d006              BEQ      |L2.328|
00013a  6930              LDR      r0,[r6,#0x10]         ;710
00013c  6829              LDR      r1,[r5,#0]            ;710
00013e  f4214160          BIC      r1,r1,#0xe000         ;710
000142  ea4100c0          ORR      r0,r1,r0,LSL #3       ;710
000146  6028              STR      r0,[r5,#0]            ;710
                  |L2.328|
000148  482b              LDR      r0,|L2.504|
00014a  6829              LDR      r1,[r5,#0]            ;710
00014c  f011010c          ANDS     r1,r1,#0xc            ;710
000150  d038              BEQ      |L2.452|
000152  4b2a              LDR      r3,|L2.508|
000154  2904              CMP      r1,#4                 ;710
000156  bf08              IT       EQ                    ;710
000158  4618              MOVEQ    r0,r3                 ;710
00015a  d033              BEQ      |L2.452|
00015c  2908              CMP      r1,#8                 ;710
00015e  d131              BNE      |L2.452|
000160  4927              LDR      r1,|L2.512|
000162  f6477cc0          MOV      r12,#0x7fc0           ;710
000166  680a              LDR      r2,[r1,#0]            ;710
000168  680c              LDR      r4,[r1,#0]            ;710
00016a  f002023f          AND      r2,r2,#0x3f           ;710
00016e  f4140f80          TST      r4,#0x400000          ;710
000172  d00c              BEQ      |L2.398|
000174  6808              LDR      r0,[r1,#0]            ;710
000176  fbb3f2f2          UDIV     r2,r3,r2              ;710
00017a  fa9cf3ac          RBIT     r3,r12                ;710
00017e  ea00000c          AND      r0,r0,r12             ;710
000182  fab3f383          CLZ      r3,r3                 ;710
000186  40d8              LSRS     r0,r0,r3              ;710
000188  fb02f200          MUL      r2,r2,r0              ;710
00018c  e00c              B        |L2.424|
                  |L2.398|
00018e  680b              LDR      r3,[r1,#0]            ;710
000190  fbb0f0f2          UDIV     r0,r0,r2              ;710
000194  fa9cf2ac          RBIT     r2,r12                ;710
000198  ea03030c          AND      r3,r3,r12             ;710
00019c  fab2f282          CLZ      r2,r2                 ;710
0001a0  fa23f202          LSR      r2,r3,r2              ;710
0001a4  fb00f202          MUL      r2,r0,r2              ;710
                  |L2.424|
0001a8  6808              LDR      r0,[r1,#0]            ;710
0001aa  f44f3340          MOV      r3,#0x30000           ;710
0001ae  fa93f1a3          RBIT     r1,r3                 ;710
0001b2  f4003040          AND      r0,r0,#0x30000        ;710
0001b6  fab1f181          CLZ      r1,r1                 ;710
0001ba  40c8              LSRS     r0,r0,r1              ;710
0001bc  1c40              ADDS     r0,r0,#1              ;710
0001be  0040              LSLS     r0,r0,#1              ;710
0001c0  fbb2f0f0          UDIV     r0,r2,r0              ;710
                  |L2.452|
0001c4  6829              LDR      r1,[r5,#0]            ;714
0001c6  22f0              MOVS     r2,#0xf0              ;714
0001c8  fa92f2a2          RBIT     r2,r2                 ;714
0001cc  f00101f0          AND      r1,r1,#0xf0           ;714
0001d0  fab2f282          CLZ      r2,r2                 ;714
0001d4  40d1              LSRS     r1,r1,r2              ;714
0001d6  4a0b              LDR      r2,|L2.516|
0001d8  5c51              LDRB     r1,[r2,r1]            ;714
0001da  40c8              LSRS     r0,r0,r1              ;714
0001dc  490a              LDR      r1,|L2.520|
0001de  6008              STR      r0,[r1,#0]            ;717  ; SystemCoreClock
0001e0  200f              MOVS     r0,#0xf               ;717
0001e2  f7fffffe          BL       HAL_InitTick
0001e6  2000              MOVS     r0,#0                 ;719
0001e8  e8bd87f0          POP      {r4-r10,pc}
;;;721    
                          ENDP

                  |L2.492|
                          DCD      0x40023c00
                  |L2.496|
                          DCD      0x40023808
                  |L2.500|
                          DCD      0x40023800
                  |L2.504|
                          DCD      0x00f42400
                  |L2.508|
                          DCD      0x017d7840
                  |L2.512|
                          DCD      0x40023804
                  |L2.516|
                          DCD      AHBPrescTable
                  |L2.520|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_RCC_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_RCC_DeInit PROC
;;;215      */
;;;216    void HAL_RCC_DeInit(void)
000000  4818              LDR      r0,|L3.100|
;;;217    {
;;;218      /* Set HSION bit */
;;;219      SET_BIT(RCC->CR, RCC_CR_HSION | RCC_CR_HSITRIM_4); 
;;;220      
;;;221      /* Reset CFGR register */
;;;222      CLEAR_REG(RCC->CFGR);
000002  2100              MOVS     r1,#0
000004  f84d4d04          PUSH.W   {r4}                  ;217
000008  f8d0c000          LDR      r12,[r0,#0]           ;219
;;;223      
;;;224      /* Reset HSEON, CSSON, PLLON, PLLI2S */
;;;225      CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_CSSON | RCC_CR_PLLON| RCC_CR_PLLI2SON); 
;;;226      
;;;227      /* Reset PLLCFGR register */
;;;228      CLEAR_REG(RCC->PLLCFGR);
00000c  1d02              ADDS     r2,r0,#4
00000e  4b16              LDR      r3,|L3.104|
000010  f04c0c81          ORR      r12,r12,#0x81         ;219
000014  f8c0c000          STR      r12,[r0,#0]           ;219
000018  6019              STR      r1,[r3,#0]            ;222
00001a  6803              LDR      r3,[r0,#0]            ;225
;;;229      SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM_4 | RCC_PLLCFGR_PLLN_6 | RCC_PLLCFGR_PLLN_7 | RCC_PLLCFGR_PLLQ_2 | ((uint32_t)0x20000000U)); 
00001c  f8dfc04c          LDR      r12,|L3.108|
000020  f4232410          BIC      r4,r3,#0x90000        ;225
;;;230      
;;;231      /* Reset PLLI2SCFGR register */
;;;232      CLEAR_REG(RCC->PLLI2SCFGR);
000024  4b12              LDR      r3,|L3.112|
000026  f02464a0          BIC      r4,r4,#0x5000000      ;225
00002a  6004              STR      r4,[r0,#0]            ;225
00002c  6011              STR      r1,[r2,#0]            ;228
00002e  6814              LDR      r4,[r2,#0]            ;229
000030  ea440c0c          ORR      r12,r4,r12            ;229
000034  f8c2c000          STR      r12,[r2,#0]           ;229
000038  6019              STR      r1,[r3,#0]
;;;233      SET_BIT(RCC->PLLI2SCFGR,  RCC_PLLI2SCFGR_PLLI2SN_6 | RCC_PLLI2SCFGR_PLLI2SN_7 | RCC_PLLI2SCFGR_PLLI2SR_1);
00003a  681a              LDR      r2,[r3,#0]
;;;234      
;;;235      /* Reset HSEBYP bit */
;;;236      CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
;;;237      
;;;238      /* Disable all interrupts */
;;;239      CLEAR_REG(RCC->CIR);
00003c  f8dfc034          LDR      r12,|L3.116|
000040  f4425440          ORR      r4,r2,#0x3000         ;233
;;;240      
;;;241      /* Update the SystemCoreClock global variable */
;;;242      SystemCoreClock = HSI_VALUE;
000044  4a0c              LDR      r2,|L3.120|
000046  f0445400          ORR      r4,r4,#0x20000000     ;233
00004a  601c              STR      r4,[r3,#0]            ;233
00004c  6803              LDR      r3,[r0,#0]            ;236
00004e  f4232380          BIC      r3,r3,#0x40000        ;236
000052  6003              STR      r3,[r0,#0]            ;236
000054  f8cc1000          STR      r1,[r12,#0]           ;239
000058  4808              LDR      r0,|L3.124|
00005a  6002              STR      r2,[r0,#0]  ; SystemCoreClock
;;;243    }
00005c  f85d4b04          POP.W    {r4}
000060  4770              BX       lr
;;;244    
                          ENDP

000062  0000              DCW      0x0000
                  |L3.100|
                          DCD      0x40023800
                  |L3.104|
                          DCD      0x40023808
                  |L3.108|
                          DCD      0x24003010
                  |L3.112|
                          DCD      0x40023884
                  |L3.116|
                          DCD      0x4002380c
                  |L3.120|
                          DCD      0x00f42400
                  |L3.124|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_RCC_DisableCSS||, CODE, READONLY, ALIGN=2

                  HAL_RCC_DisableCSS PROC
;;;829      */
;;;830    void HAL_RCC_DisableCSS(void)
000000  4802              LDR      r0,|L4.12|
;;;831    {
;;;832      CLEAR_BIT(RCC->CR, RCC_CR_CSSON);
000002  6801              LDR      r1,[r0,#0]
000004  f4212100          BIC      r1,r1,#0x80000
000008  6001              STR      r1,[r0,#0]
;;;833    }
00000a  4770              BX       lr
;;;834    
                          ENDP

                  |L4.12|
                          DCD      0x40023800

                          AREA ||i.HAL_RCC_EnableCSS||, CODE, READONLY, ALIGN=2

                  HAL_RCC_EnableCSS PROC
;;;820      */
;;;821    void HAL_RCC_EnableCSS(void)
000000  4802              LDR      r0,|L5.12|
;;;822    {
;;;823      SET_BIT(RCC->CR, RCC_CR_CSSON);
000002  6801              LDR      r1,[r0,#0]
000004  f4412100          ORR      r1,r1,#0x80000
000008  6001              STR      r1,[r0,#0]
;;;824    }
00000a  4770              BX       lr
;;;825    
                          ENDP

                  |L5.12|
                          DCD      0x40023800

                          AREA ||i.HAL_RCC_GetClockConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetClockConfig PROC
;;;1033     */
;;;1034   void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
000000  4a0f              LDR      r2,|L6.64|
;;;1035   {
;;;1036     /* Set all possible values for the Clock type parameter --------------------*/
;;;1037     RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
000002  230f              MOVS     r3,#0xf
000004  f84d4d04          PUSH.W   {r4}                  ;1035
;;;1038      
;;;1039     /* Get the SYSCLK configuration --------------------------------------------*/ 
;;;1040     RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
;;;1041     
;;;1042     /* Get the HCLK configuration ----------------------------------------------*/ 
;;;1043     RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE); 
;;;1044     
;;;1045     /* Get the APB1 configuration ----------------------------------------------*/ 
;;;1046     RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);   
;;;1047     
;;;1048     /* Get the APB2 configuration ----------------------------------------------*/ 
;;;1049     RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
;;;1050     
;;;1051     /* Get the Flash Wait State (Latency) configuration ------------------------*/   
;;;1052     *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY); 
000008  6003              STR      r3,[r0,#0]
;;;1053   }
00000a  f44f5ce0          MOV      r12,#0x1c00
00000e  4b0d              LDR      r3,|L6.68|
000010  6814              LDR      r4,[r2,#0]            ;1040
000012  f0040403          AND      r4,r4,#3              ;1040
000016  6044              STR      r4,[r0,#4]            ;1043
000018  6814              LDR      r4,[r2,#0]            ;1043
00001a  f00404f0          AND      r4,r4,#0xf0           ;1043
00001e  6084              STR      r4,[r0,#8]            ;1046
000020  6814              LDR      r4,[r2,#0]            ;1046
000022  f40454e0          AND      r4,r4,#0x1c00         ;1046
000026  60c4              STR      r4,[r0,#0xc]          ;1049
000028  6812              LDR      r2,[r2,#0]            ;1049
00002a  ea0c02d2          AND      r2,r12,r2,LSR #3
00002e  6102              STR      r2,[r0,#0x10]         ;1052
000030  6818              LDR      r0,[r3,#0]            ;1052
000032  f000000f          AND      r0,r0,#0xf            ;1052
000036  6008              STR      r0,[r1,#0]            ;1052
000038  f85d4b04          POP.W    {r4}
00003c  4770              BX       lr
;;;1054   
                          ENDP

00003e  0000              DCW      0x0000
                  |L6.64|
                          DCD      0x40023808
                  |L6.68|
                          DCD      0x40023c00

                          AREA ||i.HAL_RCC_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetHCLKFreq PROC
;;;918      */
;;;919    uint32_t HAL_RCC_GetHCLKFreq(void)
000000  4801              LDR      r0,|L7.8|
;;;920    {
;;;921      return SystemCoreClock;
000002  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;922    }
000004  4770              BX       lr
;;;923    
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_RCC_GetOscConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetOscConfig PROC
;;;954      */
;;;955    void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
000000  493d              LDR      r1,|L8.248|
;;;956    {
;;;957      /* Set all possible values for the Oscillator type parameter ---------------*/
;;;958      RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI;
000002  220f              MOVS     r2,#0xf
000004  b430              PUSH     {r4,r5}               ;956
000006  6002              STR      r2,[r0,#0]
000008  2200              MOVS     r2,#0
;;;959      
;;;960      /* Get the HSE configuration -----------------------------------------------*/
;;;961      if((RCC->CR &RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
00000a  680b              LDR      r3,[r1,#0]
00000c  f4132f80          TST      r3,#0x40000
;;;962      {
;;;963        RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
000010  bf18              IT       NE
000012  f44f23a0          MOVNE    r3,#0x50000
000016  d05d              BEQ      |L8.212|
                  |L8.24|
;;;964      }
;;;965      else if((RCC->CR &RCC_CR_HSEON) == RCC_CR_HSEON)
;;;966      {
;;;967        RCC_OscInitStruct->HSEState = RCC_HSE_ON;
000018  6043              STR      r3,[r0,#4]
                  |L8.26|
;;;968      }
;;;969      else
;;;970      {
;;;971        RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
;;;972      }
;;;973      
;;;974      /* Get the HSI configuration -----------------------------------------------*/
;;;975      if((RCC->CR &RCC_CR_HSION) == RCC_CR_HSION)
;;;976      {
;;;977        RCC_OscInitStruct->HSIState = RCC_HSI_ON;
00001a  2301              MOVS     r3,#1
00001c  f8d1c000          LDR      r12,[r1,#0]           ;975
000020  f01c0f01          TST      r12,#1                ;975
000024  bf14              ITE      NE
000026  60c3              STRNE    r3,[r0,#0xc]
;;;978      }
;;;979      else
;;;980      {
;;;981        RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
000028  60c2              STREQ    r2,[r0,#0xc]
;;;982      }
;;;983      
;;;984      RCC_OscInitStruct->HSICalibrationValue = (uint32_t)((RCC->CR &RCC_CR_HSITRIM) >> POSITION_VAL(RCC_CR_HSITRIM));
00002a  25f8              MOVS     r5,#0xf8
;;;985      
;;;986      /* Get the LSE configuration -----------------------------------------------*/
;;;987      if((RCC->BDCR &RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
00002c  f8dfc0cc          LDR      r12,|L8.252|
000030  680c              LDR      r4,[r1,#0]            ;984
000032  fa95f5a5          RBIT     r5,r5                 ;984
000036  f00404f8          AND      r4,r4,#0xf8           ;984
00003a  fab5f585          CLZ      r5,r5                 ;984
00003e  40ec              LSRS     r4,r4,r5              ;984
000040  6104              STR      r4,[r0,#0x10]
000042  f8dc4000          LDR      r4,[r12,#0]
000046  f0140f04          TST      r4,#4
;;;988      {
;;;989        RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
00004a  bf1c              ITT      NE
00004c  f04f0c05          MOVNE    r12,#5
000050  f8c0c008          STRNE    r12,[r0,#8]
000054  d047              BEQ      |L8.230|
                  |L8.86|
;;;990      }
;;;991      else if((RCC->BDCR &RCC_BDCR_LSEON) == RCC_BDCR_LSEON)
;;;992      {
;;;993        RCC_OscInitStruct->LSEState = RCC_LSE_ON;
;;;994      }
;;;995      else
;;;996      {
;;;997        RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
;;;998      }
;;;999      
;;;1000     /* Get the LSI configuration -----------------------------------------------*/
;;;1001     if((RCC->CSR &RCC_CSR_LSION) == RCC_CSR_LSION)
000056  f8dfc0a8          LDR      r12,|L8.256|
00005a  f8dcc000          LDR      r12,[r12,#0]
00005e  f01c0f01          TST      r12,#1
;;;1002     {
;;;1003       RCC_OscInitStruct->LSIState = RCC_LSI_ON;
000062  bf14              ITE      NE
000064  6143              STRNE    r3,[r0,#0x14]
;;;1004     }
;;;1005     else
;;;1006     {
;;;1007       RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
000066  6142              STREQ    r2,[r0,#0x14]
;;;1008     }
;;;1009     
;;;1010     /* Get the PLL configuration -----------------------------------------------*/
;;;1011     if((RCC->CR &RCC_CR_PLLON) == RCC_CR_PLLON)
000068  6809              LDR      r1,[r1,#0]
00006a  f0117f80          TST      r1,#0x1000000
;;;1012     {
;;;1013       RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
00006e  bf1a              ITTE     NE
000070  2102              MOVNE    r1,#2
000072  6181              STRNE    r1,[r0,#0x18]
;;;1014     }
;;;1015     else
;;;1016     {
;;;1017       RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
000074  6183              STREQ    r3,[r0,#0x18]
;;;1018     }
;;;1019     RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
000076  4923              LDR      r1,|L8.260|
;;;1020     RCC_OscInitStruct->PLL.PLLM = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);
;;;1021     RCC_OscInitStruct->PLL.PLLN = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN));
000078  f64772c0          MOV      r2,#0x7fc0
00007c  680b              LDR      r3,[r1,#0]            ;1019
00007e  fa92f4a2          RBIT     r4,r2
;;;1022     RCC_OscInitStruct->PLL.PLLP = (uint32_t)((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) + RCC_PLLCFGR_PLLP_0) << 1) >> POSITION_VAL(RCC_PLLCFGR_PLLP));
000082  f44f3c40          MOV      r12,#0x30000
000086  f4030380          AND      r3,r3,#0x400000       ;1019
00008a  61c3              STR      r3,[r0,#0x1c]         ;1021
00008c  fab4f384          CLZ      r3,r4                 ;1021
000090  680c              LDR      r4,[r1,#0]            ;1020
;;;1023     RCC_OscInitStruct->PLL.PLLQ = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLQ) >> POSITION_VAL(RCC_PLLCFGR_PLLQ));
000092  f04f6570          MOV      r5,#0xf000000
000096  fa9cfcac          RBIT     r12,r12               ;1022
00009a  fa95f5a5          RBIT     r5,r5
00009e  f004043f          AND      r4,r4,#0x3f           ;1020
0000a2  6204              STR      r4,[r0,#0x20]
0000a4  fab5f485          CLZ      r4,r5
0000a8  680d              LDR      r5,[r1,#0]            ;1021
0000aa  fabcfc8c          CLZ      r12,r12               ;1022
0000ae  402a              ANDS     r2,r2,r5              ;1021
0000b0  40da              LSRS     r2,r2,r3              ;1021
0000b2  6242              STR      r2,[r0,#0x24]         ;1022
0000b4  680a              LDR      r2,[r1,#0]            ;1022
0000b6  f4023240          AND      r2,r2,#0x30000        ;1022
0000ba  f5023280          ADD      r2,r2,#0x10000        ;1022
0000be  0052              LSLS     r2,r2,#1              ;1022
0000c0  fa22f20c          LSR      r2,r2,r12             ;1022
0000c4  6282              STR      r2,[r0,#0x28]
0000c6  6809              LDR      r1,[r1,#0]
0000c8  f0016170          AND      r1,r1,#0xf000000
0000cc  40e1              LSRS     r1,r1,r4
0000ce  62c1              STR      r1,[r0,#0x2c]         ;1001
;;;1024   }
0000d0  bc30              POP      {r4,r5}
0000d2  4770              BX       lr
                  |L8.212|
0000d4  680b              LDR      r3,[r1,#0]            ;965
0000d6  f4133f80          TST      r3,#0x10000           ;965
0000da  bf14              ITE      NE                    ;967
0000dc  f44f3380          MOVNE    r3,#0x10000           ;967
0000e0  6042              STREQ    r2,[r0,#4]            ;971
0000e2  d199              BNE      |L8.24|
0000e4  e799              B        |L8.26|
                  |L8.230|
0000e6  f8dcc000          LDR      r12,[r12,#0]          ;991
0000ea  f01c0f01          TST      r12,#1                ;991
0000ee  bf14              ITE      NE                    ;993
0000f0  6083              STRNE    r3,[r0,#8]            ;993
0000f2  6082              STREQ    r2,[r0,#8]            ;997
0000f4  e7af              B        |L8.86|
;;;1025   
                          ENDP

0000f6  0000              DCW      0x0000
                  |L8.248|
                          DCD      0x40023800
                  |L8.252|
                          DCD      0x40023870
                  |L8.256|
                          DCD      0x40023874
                  |L8.260|
                          DCD      0x40023804

                          AREA ||i.HAL_RCC_GetPCLK1Freq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetPCLK1Freq PROC
;;;929      */
;;;930    uint32_t HAL_RCC_GetPCLK1Freq(void)
000000  4808              LDR      r0,|L9.36|
;;;931    {  
;;;932      /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
;;;933      return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> POSITION_VAL(RCC_CFGR_PPRE1)]);
000002  f44f52e0          MOV      r2,#0x1c00
000006  6801              LDR      r1,[r0,#0]
000008  fa92f2a2          RBIT     r2,r2
00000c  4806              LDR      r0,|L9.40|
00000e  f40151e0          AND      r1,r1,#0x1c00
000012  fab2f282          CLZ      r2,r2
000016  40d1              LSRS     r1,r1,r2
000018  4a04              LDR      r2,|L9.44|
00001a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00001c  5c51              LDRB     r1,[r2,r1]
00001e  40c8              LSRS     r0,r0,r1
;;;934    }
000020  4770              BX       lr
;;;935    
                          ENDP

000022  0000              DCW      0x0000
                  |L9.36|
                          DCD      0x40023808
                  |L9.40|
                          DCD      SystemCoreClock
                  |L9.44|
                          DCD      APBPrescTable

                          AREA ||i.HAL_RCC_GetPCLK2Freq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetPCLK2Freq PROC
;;;941      */
;;;942    uint32_t HAL_RCC_GetPCLK2Freq(void)
000000  4808              LDR      r0,|L10.36|
;;;943    {
;;;944      /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
;;;945      return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> POSITION_VAL(RCC_CFGR_PPRE2)]);
000002  f44f4260          MOV      r2,#0xe000
000006  6801              LDR      r1,[r0,#0]
000008  fa92f2a2          RBIT     r2,r2
00000c  4806              LDR      r0,|L10.40|
00000e  f4014160          AND      r1,r1,#0xe000
000012  fab2f282          CLZ      r2,r2
000016  40d1              LSRS     r1,r1,r2
000018  4a04              LDR      r2,|L10.44|
00001a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00001c  5c51              LDRB     r1,[r2,r1]
00001e  40c8              LSRS     r0,r0,r1
;;;946    } 
000020  4770              BX       lr
;;;947    
                          ENDP

000022  0000              DCW      0x0000
                  |L10.36|
                          DCD      0x40023808
                  |L10.40|
                          DCD      SystemCoreClock
                  |L10.44|
                          DCD      APBPrescTable

                          AREA ||i.HAL_RCC_GetSysClockFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetSysClockFreq PROC
;;;864      */
;;;865    uint32_t HAL_RCC_GetSysClockFreq(void)
000000  4921              LDR      r1,|L11.136|
;;;866    {
;;;867      uint32_t pllm = 0, pllvco = 0, pllp = 0;
;;;868      uint32_t sysclockfreq = 0;
;;;869    
;;;870      /* Get SYSCLK source -------------------------------------------------------*/
;;;871      switch (RCC->CFGR & RCC_CFGR_SWS)
;;;872      {
;;;873        case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
;;;874        {
;;;875          sysclockfreq = HSI_VALUE;
000002  4822              LDR      r0,|L11.140|
000004  6809              LDR      r1,[r1,#0]            ;871
000006  f011010c          ANDS     r1,r1,#0xc            ;871
;;;876           break;
;;;877        }
;;;878        case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */
;;;879        {
;;;880          sysclockfreq = HSE_VALUE;
;;;881          break;
;;;882        }
;;;883        case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock  source */
;;;884        {
;;;885          /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
;;;886          SYSCLK = PLL_VCO / PLLP */
;;;887          pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
;;;888          if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
;;;889          {
;;;890            /* HSE used as PLL clock source */
;;;891            pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
;;;892          }
;;;893          else
;;;894          {
;;;895            /* HSI used as PLL clock source */
;;;896            pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
;;;897          }
;;;898          pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1 ) *2);
;;;899          
;;;900          sysclockfreq = pllvco/pllp;
;;;901          break;
;;;902        }
;;;903        default:
;;;904        {
;;;905          sysclockfreq = HSI_VALUE;
;;;906          break;
;;;907        }
;;;908      }
;;;909      return sysclockfreq;
;;;910    }
00000a  bf08              IT       EQ
00000c  4770              BXEQ     lr
00000e  4b20              LDR      r3,|L11.144|
000010  2904              CMP      r1,#4                 ;871
000012  bf04              ITT      EQ                    ;880
000014  4618              MOVEQ    r0,r3                 ;880
000016  4770              BXEQ     lr
000018  2908              CMP      r1,#8                 ;871
00001a  bf18              IT       NE
00001c  4770              BXNE     lr
00001e  f84d4d04          PUSH.W   {r4}                  ;866
000022  f64771c0          MOV      r1,#0x7fc0            ;891
000026  4a1b              LDR      r2,|L11.148|
000028  f8d2c000          LDR      r12,[r2,#0]           ;887
00002c  6814              LDR      r4,[r2,#0]            ;888
00002e  f00c0c3f          AND      r12,r12,#0x3f         ;887
000032  f4140f80          TST      r4,#0x400000          ;888
000036  d00b              BEQ      |L11.80|
000038  6810              LDR      r0,[r2,#0]            ;891
00003a  fbb3f3fc          UDIV     r3,r3,r12             ;891
00003e  fa91fca1          RBIT     r12,r1                ;891
000042  4008              ANDS     r0,r0,r1              ;891
000044  fabcf18c          CLZ      r1,r12                ;891
000048  40c8              LSRS     r0,r0,r1              ;891
00004a  fb03f000          MUL      r0,r3,r0              ;891
00004e  e00a              B        |L11.102|
                  |L11.80|
000050  6813              LDR      r3,[r2,#0]            ;896
000052  fbb0f0fc          UDIV     r0,r0,r12             ;896
000056  fa91fca1          RBIT     r12,r1                ;896
00005a  4019              ANDS     r1,r1,r3              ;896
00005c  fabcf38c          CLZ      r3,r12                ;896
000060  40d9              LSRS     r1,r1,r3              ;896
000062  fb00f001          MUL      r0,r0,r1              ;896
                  |L11.102|
000066  6811              LDR      r1,[r2,#0]            ;898
000068  f44f3340          MOV      r3,#0x30000           ;898
00006c  f85d4b04          POP.W    {r4}
000070  fa93f2a3          RBIT     r2,r3                 ;898
000074  f4013140          AND      r1,r1,#0x30000        ;898
000078  fab2f282          CLZ      r2,r2                 ;898
00007c  40d1              LSRS     r1,r1,r2              ;898
00007e  1c49              ADDS     r1,r1,#1              ;898
000080  0049              LSLS     r1,r1,#1              ;898
000082  fbb0f0f1          UDIV     r0,r0,r1              ;900
000086  4770              BX       lr
;;;911    
                          ENDP

                  |L11.136|
                          DCD      0x40023808
                  |L11.140|
                          DCD      0x00f42400
                  |L11.144|
                          DCD      0x017d7840
                  |L11.148|
                          DCD      0x40023804

                          AREA ||i.HAL_RCC_MCOConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_MCOConfig PROC
;;;766      */
;;;767    void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
000000  2800              CMP      r0,#0
;;;768    {
;;;769      GPIO_InitTypeDef GPIO_InitStruct;
;;;770      /* Check the parameters */
;;;771      assert_param(IS_RCC_MCO(RCC_MCOx));
;;;772      assert_param(IS_RCC_MCODIV(RCC_MCODiv));
;;;773      /* RCC_MCO1 */
;;;774      if(RCC_MCOx == RCC_MCO1)
;;;775      {
;;;776        assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));
;;;777        
;;;778        /* MCO1 Clock Enable */
;;;779        MCO1_CLK_ENABLE();
000002  4823              LDR      r0,|L12.144|
000004  b570              PUSH     {r4-r6,lr}            ;768
;;;780        
;;;781        /* Configure the MCO1 pin in alternate function mode */    
;;;782        GPIO_InitStruct.Pin = MCO1_PIN;
;;;783        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
;;;784        GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
;;;785        GPIO_InitStruct.Pull = GPIO_NOPULL;
;;;786        GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
;;;787        HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
;;;788        
;;;789        /* Mask MCO1 and MCO1PRE[2:0] bits then Select MCO1 clock source and prescaler */
;;;790        MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), (RCC_MCOSource | RCC_MCODiv));
000006  4c23              LDR      r4,|L12.148|
000008  b086              SUB      sp,sp,#0x18           ;768
;;;791      }
;;;792      else
;;;793      {
;;;794        assert_param(IS_RCC_MCO2SOURCE(RCC_MCOSource));
;;;795        
;;;796        /* MCO2 Clock Enable */
;;;797        MCO2_CLK_ENABLE();
00000a  f8d0c000          LDR      r12,[r0,#0]
00000e  4615              MOV      r5,r2                 ;768
000010  460e              MOV      r6,r1                 ;768
000012  f04f0300          MOV      r3,#0                 ;774
000016  f04f0102          MOV      r1,#2                 ;783
00001a  f04f0203          MOV      r2,#3                 ;784
00001e  d01a              BEQ      |L12.86|
000020  f04c0c04          ORR      r12,r12,#4
000024  f8c0c000          STR      r12,[r0,#0]
000028  6800              LDR      r0,[r0,#0]
00002a  f0000004          AND      r0,r0,#4
;;;798        
;;;799        /* Configure the MCO2 pin in alternate function mode */
;;;800        GPIO_InitStruct.Pin = MCO2_PIN;
00002e  9005              STR      r0,[sp,#0x14]
000030  0208              LSLS     r0,r1,#8
000032  9000              STR      r0,[sp,#0]
000034  e9cd1301          STRD     r1,r3,[sp,#4]
;;;801        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
;;;802        GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
;;;803        GPIO_InitStruct.Pull = GPIO_NOPULL;
;;;804        GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
;;;805        HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);
000038  4817              LDR      r0,|L12.152|
00003a  4669              MOV      r1,sp
00003c  e9cd2303          STRD     r2,r3,[sp,#0xc]
000040  f7fffffe          BL       HAL_GPIO_Init
;;;806        
;;;807        /* Mask MCO2 and MCO2PRE[2:0] bits then Select MCO2 clock source and prescaler */
;;;808        MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 3)));
000044  6821              LDR      r1,[r4,#0]
000046  ea4600c5          ORR      r0,r6,r5,LSL #3
00004a  f0214178          BIC      r1,r1,#0xf8000000
00004e  4308              ORRS     r0,r0,r1
000050  6020              STR      r0,[r4,#0]
;;;809      }
;;;810    }
000052  b006              ADD      sp,sp,#0x18
000054  bd70              POP      {r4-r6,pc}
                  |L12.86|
000056  f04c0c01          ORR      r12,r12,#1            ;779
00005a  f8c0c000          STR      r12,[r0,#0]           ;779
00005e  6800              LDR      r0,[r0,#0]            ;779
000060  f0000001          AND      r0,r0,#1              ;779
000064  9005              STR      r0,[sp,#0x14]         ;782
000066  f44f7080          MOV      r0,#0x100             ;782
00006a  9000              STR      r0,[sp,#0]            ;782
00006c  e9cd1301          STRD     r1,r3,[sp,#4]         ;782
000070  480a              LDR      r0,|L12.156|
000072  4669              MOV      r1,sp                 ;787
000074  e9cd2303          STRD     r2,r3,[sp,#0xc]       ;787
000078  f7fffffe          BL       HAL_GPIO_Init
00007c  6821              LDR      r1,[r4,#0]            ;790
00007e  ea460005          ORR      r0,r6,r5              ;790
000082  f02161ec          BIC      r1,r1,#0x7600000      ;790
000086  4308              ORRS     r0,r0,r1              ;790
000088  6020              STR      r0,[r4,#0]            ;790
00008a  b006              ADD      sp,sp,#0x18
00008c  bd70              POP      {r4-r6,pc}
;;;811    
                          ENDP

00008e  0000              DCW      0x0000
                  |L12.144|
                          DCD      0x40023830
                  |L12.148|
                          DCD      0x40023808
                  |L12.152|
                          DCD      0x40020800
                  |L12.156|
                          DCD      0x40020000

                          AREA ||i.HAL_RCC_NMI_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_RCC_NMI_IRQHandler PROC
;;;1059     */
;;;1060   void HAL_RCC_NMI_IRQHandler(void)
000000  4806              LDR      r0,|L13.28|
;;;1061   {
;;;1062     /* Check RCC CSSF flag  */
;;;1063     if(__HAL_RCC_GET_IT(RCC_IT_CSS))
000002  6800              LDR      r0,[r0,#0]
000004  f0100f80          TST      r0,#0x80
;;;1064     {
;;;1065       /* RCC Clock Security System interrupt user callback */
;;;1066       HAL_RCC_CSSCallback();
;;;1067   
;;;1068       /* Clear RCC CSS pending bit */
;;;1069       __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
;;;1070     }
;;;1071   }
000008  bf08              IT       EQ
00000a  4770              BXEQ     lr
00000c  b510              PUSH     {r4,lr}               ;1061
00000e  f7fffffe          BL       HAL_RCC_CSSCallback
000012  4903              LDR      r1,|L13.32|
000014  2080              MOVS     r0,#0x80              ;1069
000016  7008              STRB     r0,[r1,#0]            ;1069
000018  bd10              POP      {r4,pc}
;;;1072   
                          ENDP

00001a  0000              DCW      0x0000
                  |L13.28|
                          DCD      0x4002380c
                  |L13.32|
                          DCD      0x4002380e

                          AREA ||i.HAL_RCC_OscConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_OscConfig PROC
;;;258      */
;;;259    __weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;260    {
;;;261      uint32_t tickstart = 0;  
;;;262     
;;;263      /* Check the parameters */
;;;264      assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
;;;265      
;;;266      /*------------------------------- HSE Configuration ------------------------*/ 
;;;267      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
;;;268      {
;;;269        /* Check the parameters */
;;;270        assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
;;;271        /* When the HSE is used as system clock or clock source for PLL, It can not be disabled */
;;;272        if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
000004  4ff4              LDR      r7,|L14.984|
000006  4604              MOV      r4,r0                 ;260
000008  7800              LDRB     r0,[r0,#0]            ;267
;;;273           || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
00000a  f1a70804          SUB      r8,r7,#4
00000e  f0100f01          TST      r0,#1                 ;267
;;;274        {
;;;275    	  if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
000012  f1a80504          SUB      r5,r8,#4
000016  d059              BEQ      |L14.204|
000018  6838              LDR      r0,[r7,#0]            ;272
00001a  f000000c          AND      r0,r0,#0xc            ;272
00001e  2804              CMP      r0,#4                 ;272
000020  d009              BEQ      |L14.54|
000022  6838              LDR      r0,[r7,#0]            ;273
000024  f000000c          AND      r0,r0,#0xc            ;273
000028  2808              CMP      r0,#8                 ;273
00002a  d10d              BNE      |L14.72|
00002c  f8d80000          LDR      r0,[r8,#0]            ;273
000030  f4100f80          TST      r0,#0x400000          ;273
000034  d008              BEQ      |L14.72|
                  |L14.54|
000036  6828              LDR      r0,[r5,#0]
000038  f4103f00          TST      r0,#0x20000
00003c  d046              BEQ      |L14.204|
00003e  6860              LDR      r0,[r4,#4]
000040  2800              CMP      r0,#0
000042  f00081c6          BEQ.W    |L14.978|
000046  e041              B        |L14.204|
                  |L14.72|
;;;276          {
;;;277            return HAL_ERROR;
;;;278          }
;;;279        }
;;;280        else
;;;281        {
;;;282          /* Set the new HSE configuration ---------------------------------------*/
;;;283          __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
000048  6860              LDR      r0,[r4,#4]
00004a  f5b03f80          CMP      r0,#0x10000
00004e  bf04              ITT      EQ
000050  6828              LDREQ    r0,[r5,#0]
000052  f4403080          ORREQ    r0,r0,#0x10000
000056  d00a              BEQ      |L14.110|
000058  b110              CBZ      r0,|L14.96|
00005a  f5b02fa0          CMP      r0,#0x50000
00005e  d011              BEQ      |L14.132|
                  |L14.96|
000060  6828              LDR      r0,[r5,#0]
000062  f4203080          BIC      r0,r0,#0x10000
000066  6028              STR      r0,[r5,#0]
000068  6828              LDR      r0,[r5,#0]
00006a  f4202080          BIC      r0,r0,#0x40000
                  |L14.110|
00006e  6028              STR      r0,[r5,#0]
;;;284          
;;;285          /* Check the HSE State */
;;;286          if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
000070  6860              LDR      r0,[r4,#4]
000072  b1d0              CBZ      r0,|L14.170|
;;;287          {
;;;288            /* Get Start Tick*/
;;;289            tickstart = HAL_GetTick();
000074  f7fffffe          BL       HAL_GetTick
000078  4606              MOV      r6,r0
;;;290            
;;;291            /* Wait till HSE is ready */  
;;;292            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
00007a  6828              LDR      r0,[r5,#0]
00007c  f4103f00          TST      r0,#0x20000
000080  d008              BEQ      |L14.148|
000082  e023              B        |L14.204|
                  |L14.132|
000084  6828              LDR      r0,[r5,#0]            ;283
000086  f4402080          ORR      r0,r0,#0x40000        ;283
00008a  6028              STR      r0,[r5,#0]            ;283
00008c  6828              LDR      r0,[r5,#0]            ;283
00008e  f4403080          ORR      r0,r0,#0x10000        ;283
000092  e7ec              B        |L14.110|
                  |L14.148|
;;;293            {
;;;294              if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
000094  f7fffffe          BL       HAL_GetTick
000098  1b80              SUBS     r0,r0,r6
00009a  2864              CMP      r0,#0x64
00009c  f200813f          BHI.W    |L14.798|
0000a0  6828              LDR      r0,[r5,#0]            ;292
0000a2  f4103f00          TST      r0,#0x20000           ;292
0000a6  d0f5              BEQ      |L14.148|
0000a8  e010              B        |L14.204|
                  |L14.170|
;;;295              {
;;;296                return HAL_TIMEOUT;
;;;297              }
;;;298            }
;;;299          }
;;;300          else
;;;301          {
;;;302            /* Get Start Tick*/
;;;303            tickstart = HAL_GetTick();
0000aa  f7fffffe          BL       HAL_GetTick
0000ae  4606              MOV      r6,r0
;;;304            
;;;305            /* Wait till HSE is bypassed or disabled */
;;;306            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
0000b0  6828              LDR      r0,[r5,#0]
0000b2  f4103f00          TST      r0,#0x20000
0000b6  d009              BEQ      |L14.204|
                  |L14.184|
;;;307            {
;;;308               if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
0000b8  f7fffffe          BL       HAL_GetTick
0000bc  1b80              SUBS     r0,r0,r6
0000be  2864              CMP      r0,#0x64
0000c0  f200812d          BHI.W    |L14.798|
0000c4  6828              LDR      r0,[r5,#0]            ;306
0000c6  f4103f00          TST      r0,#0x20000           ;306
0000ca  d1f5              BNE      |L14.184|
                  |L14.204|
;;;309              {
;;;310                return HAL_TIMEOUT;
;;;311              }
;;;312            }
;;;313          }
;;;314        }
;;;315      }
;;;316      /*----------------------------- HSI Configuration --------------------------*/ 
;;;317      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
0000cc  7820              LDRB     r0,[r4,#0]
0000ce  f0100f02          TST      r0,#2
0000d2  d05a              BEQ      |L14.394|
;;;318      {
;;;319        /* Check the parameters */
;;;320        assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
;;;321        assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
;;;322        
;;;323        /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
;;;324        if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
0000d4  6838              LDR      r0,[r7,#0]
;;;325           || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
;;;326        {
;;;327          /* When HSI is used as system clock it will not disabled */
;;;328          if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
;;;329          {
;;;330            return HAL_ERROR;
;;;331          }
;;;332          /* Otherwise, just the calibration is allowed */
;;;333          else
;;;334          {
;;;335            /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
;;;336            __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
0000d6  f04f09f8          MOV      r9,#0xf8
0000da  f0100f0c          TST      r0,#0xc               ;324
0000de  d018              BEQ      |L14.274|
0000e0  6838              LDR      r0,[r7,#0]            ;325
0000e2  f000000c          AND      r0,r0,#0xc            ;325
0000e6  2808              CMP      r0,#8                 ;325
0000e8  bf04              ITT      EQ                    ;325
0000ea  f8d80000          LDREQ    r0,[r8,#0]            ;325
0000ee  f4100f80          TSTEQ    r0,#0x400000          ;325
0000f2  d00e              BEQ      |L14.274|
;;;337          }
;;;338        }
;;;339        else
;;;340        {
;;;341          /* Check the HSI State */
;;;342          if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
0000f4  68e0              LDR      r0,[r4,#0xc]
0000f6  2800              CMP      r0,#0
;;;343          {
;;;344            /* Enable the Internal High Speed oscillator (HSI). */
;;;345            __HAL_RCC_HSI_ENABLE();
;;;346    
;;;347            /* Get Start Tick*/
;;;348            tickstart = HAL_GetTick();
;;;349    
;;;350            /* Wait till HSI is ready */  
;;;351            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
;;;352            {
;;;353              if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
;;;354              {
;;;355                return HAL_TIMEOUT;
;;;356              }
;;;357            }
;;;358                    
;;;359            /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
;;;360            __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
;;;361          }
;;;362          else
;;;363          {
;;;364            /* Disable the Internal High Speed oscillator (HSI). */
;;;365            __HAL_RCC_HSI_DISABLE();
0000f8  6828              LDR      r0,[r5,#0]
0000fa  d032              BEQ      |L14.354|
0000fc  f0400001          ORR      r0,r0,#1              ;345
000100  6028              STR      r0,[r5,#0]            ;345
000102  f7fffffe          BL       HAL_GetTick
000106  4606              MOV      r6,r0                 ;348
000108  6828              LDR      r0,[r5,#0]            ;351
00010a  f0100f02          TST      r0,#2                 ;351
00010e  d013              BEQ      |L14.312|
000110  e01b              B        |L14.330|
                  |L14.274|
000112  6828              LDR      r0,[r5,#0]            ;328
000114  f0100f02          TST      r0,#2                 ;328
000118  bf1c              ITT      NE                    ;328
00011a  68e0              LDRNE    r0,[r4,#0xc]          ;328
00011c  2801              CMPNE    r0,#1                 ;328
00011e  f0408158          BNE.W    |L14.978|
000122  6920              LDR      r0,[r4,#0x10]         ;336
000124  6829              LDR      r1,[r5,#0]            ;336
000126  fa99f2a9          RBIT     r2,r9                 ;336
00012a  fab2f282          CLZ      r2,r2                 ;336
00012e  f02101f8          BIC      r1,r1,#0xf8           ;336
000132  4090              LSLS     r0,r0,r2              ;336
000134  4308              ORRS     r0,r0,r1              ;336
000136  e012              B        |L14.350|
                  |L14.312|
000138  f7fffffe          BL       HAL_GetTick
00013c  1b80              SUBS     r0,r0,r6              ;353
00013e  2802              CMP      r0,#2                 ;353
000140  d87e              BHI      |L14.576|
000142  6828              LDR      r0,[r5,#0]            ;351
000144  f0100f02          TST      r0,#2                 ;351
000148  d0f6              BEQ      |L14.312|
                  |L14.330|
00014a  6921              LDR      r1,[r4,#0x10]         ;360
00014c  6828              LDR      r0,[r5,#0]            ;360
00014e  fa99f2a9          RBIT     r2,r9                 ;360
000152  fab2f282          CLZ      r2,r2                 ;360
000156  f02000f8          BIC      r0,r0,#0xf8           ;360
00015a  4091              LSLS     r1,r1,r2              ;360
00015c  4308              ORRS     r0,r0,r1              ;360
                  |L14.350|
00015e  6028              STR      r0,[r5,#0]            ;360
000160  e013              B        |L14.394|
                  |L14.354|
000162  f0200001          BIC      r0,r0,#1
000166  6028              STR      r0,[r5,#0]
;;;366    
;;;367            /* Get Start Tick*/
;;;368            tickstart = HAL_GetTick();
000168  f7fffffe          BL       HAL_GetTick
00016c  4606              MOV      r6,r0
;;;369          
;;;370            /* Wait till HSI is ready */  
;;;371            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
00016e  6828              LDR      r0,[r5,#0]
000170  f0100f02          TST      r0,#2
000174  d009              BEQ      |L14.394|
;;;372            {
;;;373              if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
000176  bf00              NOP      
                  |L14.376|
000178  f7fffffe          BL       HAL_GetTick
00017c  1b80              SUBS     r0,r0,r6
00017e  2802              CMP      r0,#2
000180  d85e              BHI      |L14.576|
000182  6828              LDR      r0,[r5,#0]            ;371
000184  f0100f02          TST      r0,#2                 ;371
000188  d1f6              BNE      |L14.376|
                  |L14.394|
;;;374              {
;;;375                return HAL_TIMEOUT;
;;;376              } 
;;;377            } 
;;;378          }
;;;379        }
;;;380      }
;;;381      /*------------------------------ LSI Configuration -------------------------*/
;;;382      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
00018a  7820              LDRB     r0,[r4,#0]
00018c  f0100f08          TST      r0,#8
000190  d034              BEQ      |L14.508|
;;;383      {
;;;384        /* Check the parameters */
;;;385        assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
;;;386    
;;;387        /* Check the LSI State */
;;;388        if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
;;;389        {
;;;390          /* Enable the Internal Low Speed oscillator (LSI). */
;;;391          __HAL_RCC_LSI_ENABLE();
000192  f8df9248          LDR      r9,|L14.988|
000196  6960              LDR      r0,[r4,#0x14]         ;388
000198  2800              CMP      r0,#0                 ;388
;;;392          
;;;393          /* Get Start Tick*/
;;;394          tickstart = HAL_GetTick();
;;;395          
;;;396          /* Wait till LSI is ready */
;;;397          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
;;;398          {
;;;399            if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
;;;400            {
;;;401              return HAL_TIMEOUT;
;;;402            }
;;;403          }
;;;404        }
;;;405        else
;;;406        {
;;;407          /* Disable the Internal Low Speed oscillator (LSI). */
;;;408          __HAL_RCC_LSI_DISABLE();
00019a  f8d90000          LDR      r0,[r9,#0]
00019e  d016              BEQ      |L14.462|
0001a0  f0400001          ORR      r0,r0,#1              ;391
0001a4  f8c90000          STR      r0,[r9,#0]            ;391
0001a8  f7fffffe          BL       HAL_GetTick
0001ac  4606              MOV      r6,r0                 ;394
0001ae  f8d90000          LDR      r0,[r9,#0]            ;397
0001b2  f0100f02          TST      r0,#2                 ;397
0001b6  d121              BNE      |L14.508|
                  |L14.440|
0001b8  f7fffffe          BL       HAL_GetTick
0001bc  1b80              SUBS     r0,r0,r6              ;399
0001be  2802              CMP      r0,#2                 ;399
0001c0  d83e              BHI      |L14.576|
0001c2  f8d90000          LDR      r0,[r9,#0]            ;397
0001c6  f0100f02          TST      r0,#2                 ;397
0001ca  d0f5              BEQ      |L14.440|
0001cc  e016              B        |L14.508|
                  |L14.462|
0001ce  f0200001          BIC      r0,r0,#1
0001d2  f8c90000          STR      r0,[r9,#0]
;;;409          
;;;410          /* Get Start Tick*/
;;;411          tickstart = HAL_GetTick();
0001d6  f7fffffe          BL       HAL_GetTick
0001da  4606              MOV      r6,r0
;;;412          
;;;413          /* Wait till LSI is ready */  
;;;414          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
0001dc  f8d90000          LDR      r0,[r9,#0]
0001e0  f0100f02          TST      r0,#2
0001e4  d00a              BEQ      |L14.508|
;;;415          {
;;;416            if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
0001e6  bf00              NOP      
                  |L14.488|
0001e8  f7fffffe          BL       HAL_GetTick
0001ec  1b80              SUBS     r0,r0,r6
0001ee  2802              CMP      r0,#2
0001f0  d826              BHI      |L14.576|
0001f2  f8d90000          LDR      r0,[r9,#0]            ;414
0001f6  f0100f02          TST      r0,#2                 ;414
0001fa  d1f5              BNE      |L14.488|
                  |L14.508|
;;;417            {
;;;418              return HAL_TIMEOUT;
;;;419            }
;;;420          }
;;;421        }
;;;422      }
;;;423      /*------------------------------ LSE Configuration -------------------------*/ 
;;;424      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
0001fc  7820              LDRB     r0,[r4,#0]
0001fe  f0100f04          TST      r0,#4
000202  d073              BEQ      |L14.748|
;;;425      {
;;;426        /* Check the parameters */
;;;427        assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
;;;428        
;;;429        /* Enable Power Clock*/
;;;430        __HAL_RCC_PWR_CLK_ENABLE();
000204  4876              LDR      r0,|L14.992|
000206  6801              LDR      r1,[r0,#0]
000208  f0415180          ORR      r1,r1,#0x10000000
00020c  6001              STR      r1,[r0,#0]
00020e  6800              LDR      r0,[r0,#0]
;;;431        
;;;432        /* Enable write access to Backup domain */
;;;433        PWR->CR1 |= PWR_CR1_DBP;
000210  f8df91d0          LDR      r9,|L14.996|
000214  f0005080          AND      r0,r0,#0x10000000     ;430
000218  9000              STR      r0,[sp,#0]
00021a  f8d90000          LDR      r0,[r9,#0]
00021e  f4407080          ORR      r0,r0,#0x100
000222  f8c90000          STR      r0,[r9,#0]
;;;434        
;;;435        /* Wait for Backup domain Write protection disable */
;;;436        tickstart = HAL_GetTick();
000226  f7fffffe          BL       HAL_GetTick
00022a  4606              MOV      r6,r0
;;;437        
;;;438        while((PWR->CR1 & PWR_CR1_DBP) == RESET)
00022c  f8d90000          LDR      r0,[r9,#0]
000230  f4107f80          TST      r0,#0x100
000234  d10c              BNE      |L14.592|
;;;439        {
;;;440          if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
000236  bf00              NOP      
                  |L14.568|
000238  f7fffffe          BL       HAL_GetTick
00023c  1b80              SUBS     r0,r0,r6
00023e  e000              B        |L14.578|
                  |L14.576|
000240  e06d              B        |L14.798|
                  |L14.578|
000242  2864              CMP      r0,#0x64
000244  d86b              BHI      |L14.798|
000246  f8d90000          LDR      r0,[r9,#0]            ;438
00024a  f4107f80          TST      r0,#0x100             ;438
00024e  d0f3              BEQ      |L14.568|
                  |L14.592|
;;;441          {
;;;442            return HAL_TIMEOUT;
;;;443          }      
;;;444        }
;;;445        
;;;446        /* Set the new LSE configuration -----------------------------------------*/
;;;447        __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
000250  68a0              LDR      r0,[r4,#8]
000252  f8df9194          LDR      r9,|L14.1000|
000256  2801              CMP      r0,#1
000258  bf04              ITT      EQ
00025a  f8d90000          LDREQ    r0,[r9,#0]
00025e  f0400001          ORREQ    r0,r0,#1
000262  d00c              BEQ      |L14.638|
000264  b108              CBZ      r0,|L14.618|
000266  2805              CMP      r0,#5
000268  d018              BEQ      |L14.668|
                  |L14.618|
00026a  f8d90000          LDR      r0,[r9,#0]
00026e  f0200001          BIC      r0,r0,#1
000272  f8c90000          STR      r0,[r9,#0]
000276  f8d90000          LDR      r0,[r9,#0]
00027a  f0200004          BIC      r0,r0,#4
                  |L14.638|
00027e  f8c90000          STR      r0,[r9,#0]
;;;448        /* Check the LSE State */
;;;449        if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
;;;450        {
;;;451          /* Get Start Tick*/
;;;452          tickstart = HAL_GetTick();
;;;453          
;;;454          /* Wait till LSE is ready */  
;;;455          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
;;;456          {
;;;457            if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
000282  68a0              LDR      r0,[r4,#8]
000284  f2413a88          MOV      r10,#0x1388
000288  b1f0              CBZ      r0,|L14.712|
00028a  f7fffffe          BL       HAL_GetTick
00028e  4606              MOV      r6,r0                 ;452
000290  f8d90000          LDR      r0,[r9,#0]            ;455
000294  f0100f02          TST      r0,#2                 ;455
000298  d00b              BEQ      |L14.690|
00029a  e027              B        |L14.748|
                  |L14.668|
00029c  f8d90000          LDR      r0,[r9,#0]            ;447
0002a0  f0400004          ORR      r0,r0,#4              ;447
0002a4  f8c90000          STR      r0,[r9,#0]            ;447
0002a8  f8d90000          LDR      r0,[r9,#0]            ;447
0002ac  f0400001          ORR      r0,r0,#1              ;447
0002b0  e7e5              B        |L14.638|
                  |L14.690|
0002b2  f7fffffe          BL       HAL_GetTick
0002b6  1b80              SUBS     r0,r0,r6
0002b8  4550              CMP      r0,r10
0002ba  d830              BHI      |L14.798|
0002bc  f8d90000          LDR      r0,[r9,#0]            ;455
0002c0  f0100f02          TST      r0,#2                 ;455
0002c4  d0f5              BEQ      |L14.690|
0002c6  e011              B        |L14.748|
                  |L14.712|
;;;458            {
;;;459              return HAL_TIMEOUT;
;;;460            }       
;;;461          }
;;;462        }
;;;463        else
;;;464        {
;;;465          /* Get Start Tick*/
;;;466          tickstart = HAL_GetTick();
0002c8  f7fffffe          BL       HAL_GetTick
0002cc  4606              MOV      r6,r0
;;;467          
;;;468          /* Wait till LSE is ready */  
;;;469          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
0002ce  f8d90000          LDR      r0,[r9,#0]
0002d2  f0100f02          TST      r0,#2
0002d6  d009              BEQ      |L14.748|
                  |L14.728|
;;;470          {
;;;471            if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
0002d8  f7fffffe          BL       HAL_GetTick
0002dc  1b80              SUBS     r0,r0,r6
0002de  4550              CMP      r0,r10
0002e0  d81d              BHI      |L14.798|
0002e2  f8d90000          LDR      r0,[r9,#0]            ;469
0002e6  f0100f02          TST      r0,#2                 ;469
0002ea  d1f5              BNE      |L14.728|
                  |L14.748|
;;;472            {
;;;473              return HAL_TIMEOUT;
;;;474            }       
;;;475          }
;;;476        }
;;;477      }
;;;478      /*-------------------------------- PLL Configuration -----------------------*/
;;;479      /* Check the parameters */
;;;480      assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
;;;481      if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
0002ec  69a0              LDR      r0,[r4,#0x18]
0002ee  b3e8              CBZ      r0,|L14.876|
;;;482      {
;;;483        /* Check if the PLL is used as system clock or not */
;;;484        if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
0002f0  6839              LDR      r1,[r7,#0]
0002f2  f001010c          AND      r1,r1,#0xc
0002f6  2908              CMP      r1,#8
0002f8  d06b              BEQ      |L14.978|
;;;485        { 
;;;486          if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
0002fa  2802              CMP      r0,#2
;;;487          {
;;;488            /* Check the parameters */
;;;489            assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
;;;490            assert_param(IS_RCC_PLLM_VALUE(RCC_OscInitStruct->PLL.PLLM));
;;;491            assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
;;;492            assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
;;;493            assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
;;;494            
;;;495            /* Disable the main PLL. */
;;;496            __HAL_RCC_PLL_DISABLE();
;;;497            
;;;498            /* Get Start Tick*/
;;;499            tickstart = HAL_GetTick();
;;;500            
;;;501            /* Wait till PLL is ready */  
;;;502            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
;;;503            {
;;;504              if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
;;;505              {
;;;506                return HAL_TIMEOUT;
;;;507              }
;;;508            }
;;;509            
;;;510            /* Configure the main PLL clock source, multiplication and division factors. */
;;;511            WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
;;;512                                     RCC_OscInitStruct->PLL.PLLM                                                 | \
;;;513                                     (RCC_OscInitStruct->PLL.PLLN << POSITION_VAL(RCC_PLLCFGR_PLLN))             | \
;;;514                                     (((RCC_OscInitStruct->PLL.PLLP >> 1) -1) << POSITION_VAL(RCC_PLLCFGR_PLLP)) | \
;;;515                                     (RCC_OscInitStruct->PLL.PLLQ << POSITION_VAL(RCC_PLLCFGR_PLLQ))));
;;;516            /* Enable the main PLL. */
;;;517            __HAL_RCC_PLL_ENABLE();
;;;518    
;;;519            /* Get Start Tick*/
;;;520            tickstart = HAL_GetTick();
;;;521            
;;;522            /* Wait till PLL is ready */  
;;;523            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
;;;524            {
;;;525              if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
;;;526              {
;;;527                return HAL_TIMEOUT;
;;;528              } 
;;;529            }
;;;530          }
;;;531          else
;;;532          {
;;;533            /* Disable the main PLL. */
;;;534            __HAL_RCC_PLL_DISABLE();
0002fc  6828              LDR      r0,[r5,#0]
0002fe  f0207080          BIC      r0,r0,#0x1000000
000302  6028              STR      r0,[r5,#0]
000304  d00e              BEQ      |L14.804|
;;;535     
;;;536            /* Get Start Tick*/
;;;537            tickstart = HAL_GetTick();
000306  f7fffffe          BL       HAL_GetTick
00030a  4604              MOV      r4,r0
;;;538            
;;;539            /* Wait till PLL is ready */  
;;;540            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
00030c  6828              LDR      r0,[r5,#0]
00030e  f0107f00          TST      r0,#0x2000000
000312  d05b              BEQ      |L14.972|
                  |L14.788|
;;;541            {
;;;542              if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
000314  f7fffffe          BL       HAL_GetTick
000318  1b00              SUBS     r0,r0,r4
00031a  2802              CMP      r0,#2
00031c  d952              BLS      |L14.964|
                  |L14.798|
;;;543              {
;;;544                return HAL_TIMEOUT;
00031e  2003              MOVS     r0,#3
;;;545              }
;;;546            }
;;;547          }
;;;548        }
;;;549        else
;;;550        {
;;;551          return HAL_ERROR;
;;;552        }
;;;553      }
;;;554      return HAL_OK;
;;;555    }
000320  e8bd8ff8          POP      {r3-r11,pc}
                  |L14.804|
000324  f7fffffe          BL       HAL_GetTick
000328  4606              MOV      r6,r0                 ;499
00032a  6828              LDR      r0,[r5,#0]            ;502
00032c  f0107f00          TST      r0,#0x2000000         ;502
000330  d009              BEQ      |L14.838|
000332  bf00              NOP                            ;504
                  |L14.820|
000334  f7fffffe          BL       HAL_GetTick
000338  1b80              SUBS     r0,r0,r6              ;504
00033a  2802              CMP      r0,#2                 ;504
00033c  d8ef              BHI      |L14.798|
00033e  6828              LDR      r0,[r5,#0]            ;502
000340  f0107f00          TST      r0,#0x2000000         ;502
000344  d1f6              BNE      |L14.820|
                  |L14.838|
000346  e9d4c209          LDRD     r12,r2,[r4,#0x24]     ;511
00034a  f64770c0          MOV      r0,#0x7fc0            ;511
00034e  f44f3640          MOV      r6,#0x30000           ;511
000352  fa90f1a0          RBIT     r1,r0                 ;511
000356  f04f30ff          MOV      r0,#0xffffffff        ;511
00035a  fa96f7a6          RBIT     r7,r6                 ;511
00035e  eb000652          ADD      r6,r0,r2,LSR #1       ;511
000362  f04f6270          MOV      r2,#0xf000000         ;511
000366  fab1f081          CLZ      r0,r1                 ;511
00036a  e000              B        |L14.878|
                  |L14.876|
00036c  e02e              B        |L14.972|
                  |L14.878|
00036e  e9d43107          LDRD     r3,r1,[r4,#0x1c]      ;511
000372  fa0cfc00          LSL      r12,r12,r0            ;511
000376  fab7f787          CLZ      r7,r7                 ;511
00037a  6ae4              LDR      r4,[r4,#0x2c]         ;511
00037c  fa92f2a2          RBIT     r2,r2                 ;511
000380  40be              LSLS     r6,r6,r7              ;511
000382  ea430001          ORR      r0,r3,r1              ;511
000386  ea4c0106          ORR      r1,r12,r6             ;511
00038a  fab2f282          CLZ      r2,r2                 ;511
00038e  4308              ORRS     r0,r0,r1              ;511
000390  fa04f102          LSL      r1,r4,r2              ;511
000394  4308              ORRS     r0,r0,r1              ;511
000396  f8c80000          STR      r0,[r8,#0]            ;511
00039a  6828              LDR      r0,[r5,#0]            ;517
00039c  f0407080          ORR      r0,r0,#0x1000000      ;517
0003a0  6028              STR      r0,[r5,#0]            ;517
0003a2  f7fffffe          BL       HAL_GetTick
0003a6  4604              MOV      r4,r0                 ;520
0003a8  6828              LDR      r0,[r5,#0]            ;523
0003aa  f0107f00          TST      r0,#0x2000000         ;523
0003ae  d10d              BNE      |L14.972|
                  |L14.944|
0003b0  f7fffffe          BL       HAL_GetTick
0003b4  1b00              SUBS     r0,r0,r4              ;525
0003b6  2802              CMP      r0,#2                 ;525
0003b8  d8b1              BHI      |L14.798|
0003ba  6828              LDR      r0,[r5,#0]            ;523
0003bc  f0107f00          TST      r0,#0x2000000         ;523
0003c0  d0f6              BEQ      |L14.944|
0003c2  e003              B        |L14.972|
                  |L14.964|
0003c4  6828              LDR      r0,[r5,#0]            ;540
0003c6  f0107f00          TST      r0,#0x2000000         ;540
0003ca  d1a3              BNE      |L14.788|
                  |L14.972|
0003cc  2000              MOVS     r0,#0                 ;554
0003ce  e8bd8ff8          POP      {r3-r11,pc}
                  |L14.978|
0003d2  2001              MOVS     r0,#1                 ;551
0003d4  e8bd8ff8          POP      {r3-r11,pc}
;;;556     
                          ENDP

                  |L14.984|
                          DCD      0x40023808
                  |L14.988|
                          DCD      0x40023874
                  |L14.992|
                          DCD      0x40023840
                  |L14.996|
                          DCD      0x40007000
                  |L14.1000|
                          DCD      0x40023870

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_rcc_c_b7071a4b____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32F7xx_HAL_Driver\\Core\\cmsis_armcc.h"
|__asm___19_stm32f7xx_hal_rcc_c_b7071a4b____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_rcc_c_b7071a4b____REVSH|
#line 402
|__asm___19_stm32f7xx_hal_rcc_c_b7071a4b____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_rcc_c_b7071a4b____RRX|
#line 587
|__asm___19_stm32f7xx_hal_rcc_c_b7071a4b____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
