; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32l0xx_hal_uart_ex.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32l0xx_hal_uart_ex.d --cpu=Cortex-M0+ --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\STM32L0xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\CMSIS\Device\ST\STM32L0xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\STM32L0xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32L053C8T6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32L0xx_DFP\2.0.0\Drivers\CMSIS\Device\ST\STM32L0xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32L053xx -DSTM32L0xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32l0xx_hal_uart_ex.crf ..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\STM32L0xx_HAL_Driver\Src\stm32l0xx_hal_uart_ex.c]
                          THUMB

                          AREA ||i.HAL_MultiProcessorEx_AddressLength_Set||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessorEx_AddressLength_Set PROC
;;;271      */
;;;272    HAL_StatusTypeDef HAL_MultiProcessorEx_AddressLength_Set(UART_HandleTypeDef *huart, uint32_t AddressLength)
000000  2800              CMP      r0,#0
;;;273    {
;;;274      /* Check the UART handle allocation */
;;;275      if(huart == NULL)
000002  d101              BNE      |L1.8|
;;;276      {
;;;277        return HAL_ERROR;
000004  2001              MOVS     r0,#1
;;;278      }
;;;279    
;;;280      /* Check the address length parameter */
;;;281      assert_param(IS_UART_ADDRESSLENGTH_DETECT(AddressLength));
;;;282    
;;;283      huart->gState = HAL_UART_STATE_BUSY;
;;;284    
;;;285      /* Disable the Peripheral */
;;;286      __HAL_UART_DISABLE(huart);
;;;287    
;;;288      /* Set the address length */
;;;289      MODIFY_REG(huart->Instance->CR2, USART_CR2_ADDM7, AddressLength);
;;;290    
;;;291      /* Enable the Peripheral */
;;;292      __HAL_UART_ENABLE(huart);
;;;293    
;;;294      /* TEACK and/or REACK to check before moving huart->gState and/or huart->RxState to Ready */
;;;295      return (UART_CheckIdleState(huart));
;;;296    }
000006  4770              BX       lr
                  |L1.8|
000008  b510              PUSH     {r4,lr}               ;273
00000a  2224              MOVS     r2,#0x24              ;283
00000c  66c2              STR      r2,[r0,#0x6c]         ;283
00000e  6802              LDR      r2,[r0,#0]            ;286
000010  6813              LDR      r3,[r2,#0]            ;286
000012  085b              LSRS     r3,r3,#1              ;286
000014  005b              LSLS     r3,r3,#1              ;286
000016  6013              STR      r3,[r2,#0]            ;286
000018  6802              LDR      r2,[r0,#0]            ;289
00001a  6853              LDR      r3,[r2,#4]            ;289
00001c  2410              MOVS     r4,#0x10              ;289
00001e  43a3              BICS     r3,r3,r4              ;289
000020  430b              ORRS     r3,r3,r1              ;289
000022  6053              STR      r3,[r2,#4]            ;289
000024  6801              LDR      r1,[r0,#0]            ;292
000026  680a              LDR      r2,[r1,#0]            ;292
000028  2301              MOVS     r3,#1                 ;292
00002a  431a              ORRS     r2,r2,r3              ;292
00002c  600a              STR      r2,[r1,#0]            ;292
00002e  f7fffffe          BL       UART_CheckIdleState
000032  bd10              POP      {r4,pc}
;;;297    
                          ENDP


                          AREA ||i.HAL_RS485Ex_Init||, CODE, READONLY, ALIGN=2

                  HAL_RS485Ex_Init PROC
;;;163      */
;;;164    HAL_StatusTypeDef HAL_RS485Ex_Init(UART_HandleTypeDef *huart, uint32_t Polarity, uint32_t AssertionTime, uint32_t DeassertionTime)
000000  2800              CMP      r0,#0
;;;165    {
;;;166      uint32_t temp = 0x0U;
;;;167    
;;;168      /* Check the UART handle allocation */
;;;169      if(huart == NULL)
000002  d101              BNE      |L2.8|
;;;170      {
;;;171        return HAL_ERROR;
000004  2001              MOVS     r0,#1
;;;172      }
;;;173    
;;;174      /* Check the Driver Enable polarity */
;;;175      assert_param(IS_UART_DE_POLARITY(Polarity));
;;;176    
;;;177      /* Check the Driver Enable assertion time */
;;;178      assert_param(IS_UART_ASSERTIONTIME(AssertionTime));
;;;179    
;;;180      /* Check the Driver Enable deassertion time */
;;;181      assert_param(IS_UART_DEASSERTIONTIME(DeassertionTime));
;;;182    
;;;183      if(huart->gState == HAL_UART_STATE_RESET)
;;;184      {
;;;185        /* Allocate lock resource and initialize it */
;;;186        huart->Lock = HAL_UNLOCKED;
;;;187    
;;;188        /* Init the low level hardware : GPIO, CLOCK, CORTEX */
;;;189        HAL_UART_MspInit(huart);
;;;190      }
;;;191    
;;;192      huart->gState = HAL_UART_STATE_BUSY;
;;;193    
;;;194      /* Disable the Peripheral */
;;;195      __HAL_UART_DISABLE(huart);
;;;196    
;;;197      /* Set the UART Communication parameters */
;;;198      if(huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;199      {
;;;200        UART_AdvFeatureConfig(huart);
;;;201      }
;;;202    
;;;203      if (UART_SetConfig(huart) == HAL_ERROR)
;;;204      {
;;;205        return HAL_ERROR;
;;;206      }
;;;207    
;;;208      /* Enable the Driver Enable mode by setting the DEM bit in the CR3 register */
;;;209      SET_BIT(huart->Instance->CR3, USART_CR3_DEM);
;;;210    
;;;211      /* Set the Driver Enable polarity */
;;;212      MODIFY_REG(huart->Instance->CR3, USART_CR3_DEP, Polarity);
;;;213    
;;;214      /* Set the Driver Enable assertion and deassertion times */
;;;215      temp = (AssertionTime << UART_CR1_DEAT_ADDRESS_LSB_POS);
;;;216      temp |= (DeassertionTime << UART_CR1_DEDT_ADDRESS_LSB_POS);
;;;217      MODIFY_REG(huart->Instance->CR1, (USART_CR1_DEDT|USART_CR1_DEAT), temp);
;;;218    
;;;219      /* Enable the Peripheral */
;;;220      __HAL_UART_ENABLE(huart);
;;;221    
;;;222      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;223      return (UART_CheckIdleState(huart));
;;;224    }
000006  4770              BX       lr
                  |L2.8|
000008  b5f8              PUSH     {r3-r7,lr}            ;165
00000a  4604              MOV      r4,r0                 ;165
00000c  6ec0              LDR      r0,[r0,#0x6c]         ;183
00000e  461d              MOV      r5,r3                 ;165
000010  4616              MOV      r6,r2                 ;165
000012  460f              MOV      r7,r1                 ;165
000014  2800              CMP      r0,#0                 ;183
000016  d103              BNE      |L2.32|
000018  66a0              STR      r0,[r4,#0x68]         ;189
00001a  4620              MOV      r0,r4                 ;189
00001c  f7fffffe          BL       HAL_UART_MspInit
                  |L2.32|
000020  2024              MOVS     r0,#0x24              ;192
000022  66e0              STR      r0,[r4,#0x6c]         ;192
000024  6820              LDR      r0,[r4,#0]            ;195
000026  6801              LDR      r1,[r0,#0]            ;195
000028  0849              LSRS     r1,r1,#1              ;195
00002a  0049              LSLS     r1,r1,#1              ;195
00002c  6001              STR      r1,[r0,#0]            ;195
00002e  6a60              LDR      r0,[r4,#0x24]         ;198
000030  2800              CMP      r0,#0                 ;198
000032  d002              BEQ      |L2.58|
000034  4620              MOV      r0,r4                 ;200
000036  f7fffffe          BL       UART_AdvFeatureConfig
                  |L2.58|
00003a  4620              MOV      r0,r4                 ;203
00003c  f7fffffe          BL       UART_SetConfig
000040  2801              CMP      r0,#1                 ;203
000042  d01c              BEQ      |L2.126|
000044  6820              LDR      r0,[r4,#0]            ;209
000046  6881              LDR      r1,[r0,#8]            ;209
000048  2201              MOVS     r2,#1                 ;209
00004a  0392              LSLS     r2,r2,#14             ;209
00004c  4311              ORRS     r1,r1,r2              ;209
00004e  6081              STR      r1,[r0,#8]            ;209
000050  6821              LDR      r1,[r4,#0]            ;212
000052  6888              LDR      r0,[r1,#8]            ;212
000054  0052              LSLS     r2,r2,#1              ;212
000056  4390              BICS     r0,r0,r2              ;212
000058  4338              ORRS     r0,r0,r7              ;212
00005a  6088              STR      r0,[r1,#8]            ;212
00005c  0571              LSLS     r1,r6,#21             ;215
00005e  0428              LSLS     r0,r5,#16             ;216
000060  6822              LDR      r2,[r4,#0]            ;217
000062  4308              ORRS     r0,r0,r1              ;216
000064  6811              LDR      r1,[r2,#0]            ;217
000066  4b06              LDR      r3,|L2.128|
000068  4019              ANDS     r1,r1,r3              ;217
00006a  4301              ORRS     r1,r1,r0              ;217
00006c  6011              STR      r1,[r2,#0]            ;217
00006e  6820              LDR      r0,[r4,#0]            ;220
000070  6801              LDR      r1,[r0,#0]            ;220
000072  2201              MOVS     r2,#1                 ;220
000074  4311              ORRS     r1,r1,r2              ;220
000076  6001              STR      r1,[r0,#0]            ;220
000078  4620              MOV      r0,r4                 ;223
00007a  f7fffffe          BL       UART_CheckIdleState
                  |L2.126|
00007e  bdf8              POP      {r3-r7,pc}
;;;225    
                          ENDP

                  |L2.128|
                          DCD      0xfc00ffff

                          AREA ||i.HAL_UARTEx_DisableClockStopMode||, CODE, READONLY, ALIGN=1

                  HAL_UARTEx_DisableClockStopMode PROC
;;;434      */
;;;435    HAL_StatusTypeDef HAL_UARTEx_DisableClockStopMode(UART_HandleTypeDef *huart)
000000  6e81              LDR      r1,[r0,#0x68]
;;;436    {
;;;437      /* Process Locked */
;;;438      __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  d00f              BEQ      |L3.38|
000006  2101              MOVS     r1,#1
;;;439    
;;;440      huart->gState = HAL_UART_STATE_BUSY;
000008  6681              STR      r1,[r0,#0x68]
00000a  2124              MOVS     r1,#0x24
00000c  66c1              STR      r1,[r0,#0x6c]
;;;441    
;;;442      /* Clear UCESM bit */
;;;443      CLEAR_BIT(huart->Instance->CR3, USART_CR3_UCESM);
00000e  6801              LDR      r1,[r0,#0]
000010  688a              LDR      r2,[r1,#8]
000012  2301              MOVS     r3,#1
000014  05db              LSLS     r3,r3,#23
000016  439a              BICS     r2,r2,r3
000018  608a              STR      r2,[r1,#8]
;;;444    
;;;445      huart->gState = HAL_UART_STATE_READY;
00001a  2120              MOVS     r1,#0x20
00001c  66c1              STR      r1,[r0,#0x6c]
;;;446    
;;;447      /* Process Unlocked */
;;;448      __HAL_UNLOCK(huart);
00001e  2100              MOVS     r1,#0
;;;449    
;;;450      return HAL_OK;
000020  6681              STR      r1,[r0,#0x68]
000022  4608              MOV      r0,r1
;;;451    }
000024  4770              BX       lr
                  |L3.38|
000026  2002              MOVS     r0,#2                 ;438
000028  4770              BX       lr
;;;452    
                          ENDP


                          AREA ||i.HAL_UARTEx_DisableStopMode||, CODE, READONLY, ALIGN=1

                  HAL_UARTEx_DisableStopMode PROC
;;;387      */
;;;388    HAL_StatusTypeDef HAL_UARTEx_DisableStopMode(UART_HandleTypeDef *huart)
000000  6e81              LDR      r1,[r0,#0x68]
;;;389    {
;;;390      /* Process Locked */
;;;391      __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  d00e              BEQ      |L4.36|
000006  2101              MOVS     r1,#1
;;;392    
;;;393      huart->gState = HAL_UART_STATE_BUSY;
000008  6681              STR      r1,[r0,#0x68]
00000a  2124              MOVS     r1,#0x24
00000c  66c1              STR      r1,[r0,#0x6c]
;;;394    
;;;395      /* Clear UESM bit */
;;;396      CLEAR_BIT(huart->Instance->CR1, USART_CR1_UESM);
00000e  6801              LDR      r1,[r0,#0]
000010  680a              LDR      r2,[r1,#0]
000012  2302              MOVS     r3,#2
000014  439a              BICS     r2,r2,r3
000016  600a              STR      r2,[r1,#0]
;;;397    
;;;398      huart->gState = HAL_UART_STATE_READY;
000018  2120              MOVS     r1,#0x20
00001a  66c1              STR      r1,[r0,#0x6c]
;;;399    
;;;400      /* Process Unlocked */
;;;401      __HAL_UNLOCK(huart);
00001c  2100              MOVS     r1,#0
;;;402    
;;;403      return HAL_OK;
00001e  6681              STR      r1,[r0,#0x68]
000020  4608              MOV      r0,r1
;;;404    }
000022  4770              BX       lr
                  |L4.36|
000024  2002              MOVS     r0,#2                 ;391
000026  4770              BX       lr
;;;405    
                          ENDP


                          AREA ||i.HAL_UARTEx_EnableClockStopMode||, CODE, READONLY, ALIGN=1

                  HAL_UARTEx_EnableClockStopMode PROC
;;;411      */
;;;412    HAL_StatusTypeDef HAL_UARTEx_EnableClockStopMode(UART_HandleTypeDef *huart)
000000  6e81              LDR      r1,[r0,#0x68]
;;;413    {
;;;414      /* Process Locked */
;;;415      __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  d00f              BEQ      |L5.38|
000006  2101              MOVS     r1,#1
;;;416      
;;;417      huart->gState = HAL_UART_STATE_BUSY;
000008  6681              STR      r1,[r0,#0x68]
00000a  2124              MOVS     r1,#0x24
00000c  66c1              STR      r1,[r0,#0x6c]
;;;418      
;;;419      /* Set UCESM bit */
;;;420      SET_BIT(huart->Instance->CR3, USART_CR3_UCESM);
00000e  6801              LDR      r1,[r0,#0]
000010  688a              LDR      r2,[r1,#8]
000012  2301              MOVS     r3,#1
000014  05db              LSLS     r3,r3,#23
000016  431a              ORRS     r2,r2,r3
000018  608a              STR      r2,[r1,#8]
;;;421      
;;;422      huart->gState = HAL_UART_STATE_READY;
00001a  2120              MOVS     r1,#0x20
00001c  66c1              STR      r1,[r0,#0x6c]
;;;423      
;;;424      /* Process Unlocked */
;;;425      __HAL_UNLOCK(huart);
00001e  2100              MOVS     r1,#0
;;;426      
;;;427      return HAL_OK; 
000020  6681              STR      r1,[r0,#0x68]
000022  4608              MOV      r0,r1
;;;428    }
000024  4770              BX       lr
                  |L5.38|
000026  2002              MOVS     r0,#2                 ;415
000028  4770              BX       lr
;;;429    
                          ENDP


                          AREA ||i.HAL_UARTEx_EnableStopMode||, CODE, READONLY, ALIGN=1

                  HAL_UARTEx_EnableStopMode PROC
;;;364      */
;;;365    HAL_StatusTypeDef HAL_UARTEx_EnableStopMode(UART_HandleTypeDef *huart)
000000  6e81              LDR      r1,[r0,#0x68]
;;;366    {
;;;367      /* Process Locked */
;;;368      __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  d00e              BEQ      |L6.36|
000006  2101              MOVS     r1,#1
;;;369    
;;;370      huart->gState = HAL_UART_STATE_BUSY;
000008  6681              STR      r1,[r0,#0x68]
00000a  2124              MOVS     r1,#0x24
00000c  66c1              STR      r1,[r0,#0x6c]
;;;371    
;;;372      /* Set UESM bit */
;;;373      SET_BIT(huart->Instance->CR1, USART_CR1_UESM);
00000e  6801              LDR      r1,[r0,#0]
000010  680a              LDR      r2,[r1,#0]
000012  2302              MOVS     r3,#2
000014  431a              ORRS     r2,r2,r3
000016  600a              STR      r2,[r1,#0]
;;;374    
;;;375      huart->gState = HAL_UART_STATE_READY;
000018  2120              MOVS     r1,#0x20
00001a  66c1              STR      r1,[r0,#0x6c]
;;;376    
;;;377      /* Process Unlocked */
;;;378      __HAL_UNLOCK(huart);
00001c  2100              MOVS     r1,#0
;;;379    
;;;380      return HAL_OK;
00001e  6681              STR      r1,[r0,#0x68]
000020  4608              MOV      r0,r1
;;;381    }
000022  4770              BX       lr
                  |L6.36|
000024  2002              MOVS     r0,#2                 ;368
000026  4770              BX       lr
;;;382    
                          ENDP


                          AREA ||i.HAL_UARTEx_StopModeWakeUpSourceConfig||, CODE, READONLY, ALIGN=2

                  HAL_UARTEx_StopModeWakeUpSourceConfig PROC
;;;308      */
;;;309    HAL_StatusTypeDef HAL_UARTEx_StopModeWakeUpSourceConfig(UART_HandleTypeDef *huart, UART_WakeUpTypeDef WakeUpSelection)
000000  b5f8              PUSH     {r3-r7,lr}
;;;310    {
000002  4604              MOV      r4,r0
;;;311      HAL_StatusTypeDef status = HAL_OK;
;;;312      uint32_t tickstart = 0;
;;;313    
;;;314      /* check the wake-up from stop mode UART instance */
;;;315      assert_param(IS_UART_WAKEUP_FROMSTOP_INSTANCE(huart->Instance));
;;;316      /* check the wake-up selection parameter */
;;;317      assert_param(IS_UART_WAKEUP_SELECTION(WakeUpSelection.WakeUpEvent));
;;;318    
;;;319      /* Process Locked */
;;;320      __HAL_LOCK(huart);
000004  6e80              LDR      r0,[r0,#0x68]
000006  2500              MOVS     r5,#0                 ;311
000008  2801              CMP      r0,#1
00000a  d011              BEQ      |L7.48|
00000c  2001              MOVS     r0,#1
;;;321    
;;;322      huart->gState = HAL_UART_STATE_BUSY;
00000e  2324              MOVS     r3,#0x24
000010  66e3              STR      r3,[r4,#0x6c]
000012  66a0              STR      r0,[r4,#0x68]
;;;323    
;;;324      /* Disable the Peripheral */
;;;325      __HAL_UART_DISABLE(huart);
000014  6823              LDR      r3,[r4,#0]
000016  681e              LDR      r6,[r3,#0]
000018  4386              BICS     r6,r6,r0
00001a  601e              STR      r6,[r3,#0]
;;;326    
;;;327      /* Set the wake-up selection scheme */
;;;328      MODIFY_REG(huart->Instance->CR3, USART_CR3_WUS, WakeUpSelection.WakeUpEvent);
00001c  6826              LDR      r6,[r4,#0]
00001e  68b3              LDR      r3,[r6,#8]
000020  2703              MOVS     r7,#3
000022  053f              LSLS     r7,r7,#20
000024  43bb              BICS     r3,r3,r7
000026  430b              ORRS     r3,r3,r1
000028  60b3              STR      r3,[r6,#8]
;;;329    
;;;330      if (WakeUpSelection.WakeUpEvent == UART_WAKEUP_ON_ADDRESS)
00002a  2900              CMP      r1,#0
00002c  d002              BEQ      |L7.52|
00002e  e011              B        |L7.84|
                  |L7.48|
000030  2002              MOVS     r0,#2                 ;320
;;;331      {
;;;332        UARTEx_Wakeup_AddressConfig(huart, WakeUpSelection);
;;;333      }
;;;334    
;;;335      /* Enable the Peripheral */
;;;336      __HAL_UART_ENABLE(huart);
;;;337    
;;;338      /* Init tickstart for timeout managment*/
;;;339      tickstart = HAL_GetTick();
;;;340    
;;;341      /* Wait until REACK flag is set */
;;;342      if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
;;;343      {
;;;344        status = HAL_TIMEOUT;
;;;345      }
;;;346      else
;;;347      {
;;;348        /* Initialize the UART State */
;;;349        huart->gState = HAL_UART_STATE_READY;
;;;350      }
;;;351    
;;;352      /* Process Unlocked */
;;;353      __HAL_UNLOCK(huart);
;;;354    
;;;355      return status;
;;;356    }
000032  bdf8              POP      {r3-r7,pc}
                  |L7.52|
000034  6826              LDR      r6,[r4,#0]
000036  b293              UXTH     r3,r2
000038  6871              LDR      r1,[r6,#4]
00003a  2710              MOVS     r7,#0x10
00003c  43b9              BICS     r1,r1,r7
00003e  4319              ORRS     r1,r1,r3
000040  6071              STR      r1,[r6,#4]
000042  6821              LDR      r1,[r4,#0]
000044  684b              LDR      r3,[r1,#4]
000046  0212              LSLS     r2,r2,#8
000048  021b              LSLS     r3,r3,#8
00004a  0a1b              LSRS     r3,r3,#8
00004c  0e12              LSRS     r2,r2,#24
00004e  0612              LSLS     r2,r2,#24
000050  4313              ORRS     r3,r3,r2
000052  604b              STR      r3,[r1,#4]
                  |L7.84|
000054  6821              LDR      r1,[r4,#0]            ;336
000056  680a              LDR      r2,[r1,#0]            ;336
000058  4302              ORRS     r2,r2,r0              ;336
00005a  600a              STR      r2,[r1,#0]            ;336
00005c  f7fffffe          BL       HAL_GetTick
000060  4909              LDR      r1,|L7.136|
000062  9100              STR      r1,[sp,#0]            ;342
000064  4603              MOV      r3,r0                 ;342
000066  2101              MOVS     r1,#1                 ;342
000068  2200              MOVS     r2,#0                 ;342
00006a  0589              LSLS     r1,r1,#22             ;342
00006c  4620              MOV      r0,r4                 ;342
00006e  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000072  2800              CMP      r0,#0                 ;342
000074  d001              BEQ      |L7.122|
000076  2503              MOVS     r5,#3                 ;344
000078  e001              B        |L7.126|
                  |L7.122|
00007a  2020              MOVS     r0,#0x20              ;349
00007c  66e0              STR      r0,[r4,#0x6c]         ;349
                  |L7.126|
00007e  2000              MOVS     r0,#0                 ;353
000080  66a0              STR      r0,[r4,#0x68]         ;355
000082  4628              MOV      r0,r5                 ;355
000084  bdf8              POP      {r3-r7,pc}
;;;357    
                          ENDP

000086  0000              DCW      0x0000
                  |L7.136|
                          DCD      0x01ffffff

                          AREA ||i.HAL_UARTEx_WakeupCallback||, CODE, READONLY, ALIGN=1

                  HAL_UARTEx_WakeupCallback PROC
;;;457      */
;;;458    __weak void HAL_UARTEx_WakeupCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;459    {
;;;460      /* Prevent unused argument(s) compilation warning */
;;;461      UNUSED(huart);
;;;462    
;;;463      /* NOTE : This function should not be modified, when the callback is needed,
;;;464                the HAL_UARTEx_WakeupCallback can be implemented in the user file.
;;;465       */
;;;466    }
;;;467    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_L0_V1.10.0\\Drivers\\STM32L0xx_HAL_Driver\\Src\\stm32l0xx_hal_uart_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___23_stm32l0xx_hal_uart_ex_c_83a37df4____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_L0_V1.10.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___23_stm32l0xx_hal_uart_ex_c_83a37df4____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___23_stm32l0xx_hal_uart_ex_c_83a37df4____REVSH|
#line 402
|__asm___23_stm32l0xx_hal_uart_ex_c_83a37df4____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
