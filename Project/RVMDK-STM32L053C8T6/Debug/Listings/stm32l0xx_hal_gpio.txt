; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32l0xx_hal_gpio.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32l0xx_hal_gpio.d --cpu=Cortex-M0+ --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\STM32L0xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\CMSIS\Device\ST\STM32L0xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\STM32L0xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32L053C8T6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32L0xx_DFP\2.0.0\Drivers\CMSIS\Device\ST\STM32L0xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32L053xx -DSTM32L0xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32l0xx_hal_gpio.crf ..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\STM32L0xx_HAL_Driver\Src\stm32l0xx_hal_gpio.c]
                          THUMB

                          AREA ||i.HAL_GPIO_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_DeInit PROC
;;;305      */
;;;306    void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
000000  2300              MOVS     r3,#0
;;;307    { 
;;;308      uint32_t position = 0x00U;
;;;309      uint32_t iocurrent = 0x00U;
;;;310      uint32_t tmp = 0x00U;
;;;311    
;;;312      /* Check the parameters */
;;;313      assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx,GPIO_Pin));
;;;314    
;;;315      /* Configure the port pins */
;;;316      while ((GPIO_Pin >> position) != 0)
000002  2900              CMP      r1,#0
000004  d062              BEQ      |L1.204|
000006  b5f0              PUSH     {r4-r7,lr}            ;307
                  |L1.8|
;;;317      {
;;;318        /* Get the IO position */
;;;319        iocurrent = (GPIO_Pin) & (1U << position);
000008  2401              MOVS     r4,#1
00000a  409c              LSLS     r4,r4,r3
00000c  4622              MOV      r2,r4
00000e  400a              ANDS     r2,r2,r1
;;;320    
;;;321        if(iocurrent)
000010  d057              BEQ      |L1.194|
;;;322        {
;;;323          /*------------------------- GPIO Mode Configuration --------------------*/
;;;324          /* Configure IO Direction in Input Floting Mode */
;;;325          GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
000012  6806              LDR      r6,[r0,#0]
000014  005f              LSLS     r7,r3,#1
000016  2503              MOVS     r5,#3
000018  40bd              LSLS     r5,r5,r7
00001a  432e              ORRS     r6,r6,r5
00001c  46ac              MOV      r12,r5
00001e  6006              STR      r6,[r0,#0]
;;;326               
;;;327          /* Configure the default Alternate Function in current IO */ 
;;;328          GPIOx->AFR[position >> 3U] &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U)) ;
000020  08dd              LSRS     r5,r3,#3
000022  00ad              LSLS     r5,r5,#2
000024  182d              ADDS     r5,r5,r0
000026  6a2e              LDR      r6,[r5,#0x20]
000028  46ae              MOV      lr,r5
00002a  075d              LSLS     r5,r3,#29
00002c  0eef              LSRS     r7,r5,#27
00002e  250f              MOVS     r5,#0xf
000030  40bd              LSLS     r5,r5,r7
000032  43ae              BICS     r6,r6,r5
000034  4675              MOV      r5,lr
000036  622e              STR      r6,[r5,#0x20]
;;;329          
;;;330          /* Configure the default value for IO Speed */
;;;331          GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEED0 << (position * 2U));
000038  6886              LDR      r6,[r0,#8]
00003a  4665              MOV      r5,r12
00003c  43ae              BICS     r6,r6,r5
00003e  6086              STR      r6,[r0,#8]
;;;332          
;;;333          /* Configure the default value IO Output Type */
;;;334          GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;
000040  6845              LDR      r5,[r0,#4]
000042  43a5              BICS     r5,r5,r4
000044  6045              STR      r5,[r0,#4]
;;;335          
;;;336          /* Deactivate the Pull-up oand Pull-down resistor for the current IO */
;;;337          GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
000046  68c4              LDR      r4,[r0,#0xc]
000048  4665              MOV      r5,r12
00004a  43ac              BICS     r4,r4,r5
00004c  60c4              STR      r4,[r0,#0xc]
;;;338          
;;;339          /*------------------------- EXTI Mode Configuration --------------------*/
;;;340          /* Clear the External Interrupt or Event for the current IO */
;;;341          
;;;342          tmp = SYSCFG->EXTICR[position >> 2U];
00004e  089d              LSRS     r5,r3,#2
000050  4c1f              LDR      r4,|L1.208|
000052  00ad              LSLS     r5,r5,#2
000054  192d              ADDS     r5,r5,r4
000056  68af              LDR      r7,[r5,#8]
;;;343          tmp &= (((uint32_t)0x0FU) << (4U * (position & 0x03U)));
000058  079c              LSLS     r4,r3,#30
00005a  0f26              LSRS     r6,r4,#28
00005c  240f              MOVS     r4,#0xf
00005e  40b4              LSLS     r4,r4,r6
000060  46a4              MOV      r12,r4
000062  403c              ANDS     r4,r4,r7
;;;344          if(tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
000064  2705              MOVS     r7,#5
000066  073f              LSLS     r7,r7,#28
000068  42b8              CMP      r0,r7
00006a  d101              BNE      |L1.112|
00006c  2700              MOVS     r7,#0
00006e  e014              B        |L1.154|
                  |L1.112|
000070  4f18              LDR      r7,|L1.212|
000072  42b8              CMP      r0,r7
000074  d101              BNE      |L1.122|
000076  2701              MOVS     r7,#1
000078  e00f              B        |L1.154|
                  |L1.122|
00007a  4f17              LDR      r7,|L1.216|
00007c  42b8              CMP      r0,r7
00007e  d101              BNE      |L1.132|
000080  2702              MOVS     r7,#2
000082  e00a              B        |L1.154|
                  |L1.132|
000084  4f15              LDR      r7,|L1.220|
000086  42b8              CMP      r0,r7
000088  d101              BNE      |L1.142|
00008a  2703              MOVS     r7,#3
00008c  e005              B        |L1.154|
                  |L1.142|
00008e  4f14              LDR      r7,|L1.224|
000090  42b8              CMP      r0,r7
000092  d101              BNE      |L1.152|
000094  2705              MOVS     r7,#5
000096  e000              B        |L1.154|
                  |L1.152|
000098  2706              MOVS     r7,#6
                  |L1.154|
00009a  40b7              LSLS     r7,r7,r6
00009c  42a7              CMP      r7,r4
00009e  d110              BNE      |L1.194|
;;;345          {
;;;346            tmp = ((uint32_t)0x0FU) << (4U * (position & 0x03U));
;;;347            SYSCFG->EXTICR[position >> 2U] &= ~tmp;
0000a0  68ae              LDR      r6,[r5,#8]
0000a2  4664              MOV      r4,r12                ;344
0000a4  43a6              BICS     r6,r6,r4
0000a6  60ae              STR      r6,[r5,#8]
;;;348    
;;;349            /* Clear EXTI line configuration */
;;;350            EXTI->IMR &= ~((uint32_t)iocurrent);
0000a8  4c0e              LDR      r4,|L1.228|
0000aa  6825              LDR      r5,[r4,#0]
0000ac  4395              BICS     r5,r5,r2
0000ae  6025              STR      r5,[r4,#0]
;;;351            EXTI->EMR &= ~((uint32_t)iocurrent);
0000b0  6865              LDR      r5,[r4,#4]
0000b2  4395              BICS     r5,r5,r2
0000b4  6065              STR      r5,[r4,#4]
;;;352    
;;;353            /* Clear Rising Falling edge configuration */
;;;354            EXTI->RTSR &= ~((uint32_t)iocurrent);
0000b6  68a5              LDR      r5,[r4,#8]
0000b8  4395              BICS     r5,r5,r2
0000ba  60a5              STR      r5,[r4,#8]
;;;355            EXTI->FTSR &= ~((uint32_t)iocurrent);
0000bc  68e5              LDR      r5,[r4,#0xc]
0000be  4395              BICS     r5,r5,r2
0000c0  60e5              STR      r5,[r4,#0xc]
                  |L1.194|
0000c2  460a              MOV      r2,r1
0000c4  1c5b              ADDS     r3,r3,#1
0000c6  40da              LSRS     r2,r2,r3              ;316
0000c8  d19e              BNE      |L1.8|
;;;356          }
;;;357        }
;;;358         position++;
;;;359      }
;;;360    }
0000ca  bdf0              POP      {r4-r7,pc}
                  |L1.204|
0000cc  4770              BX       lr
;;;361    
                          ENDP

0000ce  0000              DCW      0x0000
                  |L1.208|
                          DCD      0x40010000
                  |L1.212|
                          DCD      0x50000400
                  |L1.216|
                          DCD      0x50000800
                  |L1.220|
                          DCD      0x50000c00
                  |L1.224|
                          DCD      0x50001c00
                  |L1.228|
                          DCD      0x40010400

                          AREA ||i.HAL_GPIO_EXTI_Callback||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_EXTI_Callback PROC
;;;514      */
;;;515    __weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
000000  4770              BX       lr
;;;516    {
;;;517      /* Prevent unused argument(s) compilation warning */
;;;518      UNUSED(GPIO_Pin);
;;;519    
;;;520      /* NOTE: This function Should not be modified, when the callback is needed,
;;;521               the HAL_GPIO_EXTI_Callback could be implemented in the user file
;;;522       */ 
;;;523    }
;;;524    
                          ENDP


                          AREA ||i.HAL_GPIO_EXTI_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_EXTI_IRQHandler PROC
;;;499      */
;;;500    void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
000000  4904              LDR      r1,|L3.20|
;;;501    {
;;;502      /* EXTI line interrupt detected */
;;;503      if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET) 
000002  694a              LDR      r2,[r1,#0x14]
000004  4202              TST      r2,r0
000006  d004              BEQ      |L3.18|
000008  b510              PUSH     {r4,lr}               ;501
;;;504      { 
;;;505        __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
00000a  6148              STR      r0,[r1,#0x14]
;;;506        HAL_GPIO_EXTI_Callback(GPIO_Pin);
00000c  f7fffffe          BL       HAL_GPIO_EXTI_Callback
;;;507      }
;;;508    }
000010  bd10              POP      {r4,pc}
                  |L3.18|
000012  4770              BX       lr
;;;509    
                          ENDP

                  |L3.20|
                          DCD      0x40010400

                          AREA ||i.HAL_GPIO_Init||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_Init PROC
;;;182      */
;;;183    void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
000000  680b              LDR      r3,[r1,#0]
;;;184    {
;;;185      uint32_t position = 0x00U;
000002  2200              MOVS     r2,#0
;;;186      uint32_t iocurrent = 0x00U;
;;;187      uint32_t temp = 0x00U;
;;;188     
;;;189      /* Check the parameters */
;;;190      assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
;;;191      assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
;;;192      assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx,(GPIO_Init->Pin)));
;;;193    
;;;194      /* Configure the port pins */
;;;195      while (((GPIO_Init->Pin) >> position) != 0)
000004  2b00              CMP      r3,#0
000006  d06f              BEQ      |L4.232|
000008  b5f8              PUSH     {r3-r7,lr}            ;184
                  |L4.10|
;;;196      {
;;;197        /* Get the IO position */
;;;198        iocurrent = (GPIO_Init->Pin) & (1U << position);
00000a  2401              MOVS     r4,#1
00000c  4625              MOV      r5,r4
00000e  680b              LDR      r3,[r1,#0]
000010  4095              LSLS     r5,r5,r2
000012  402b              ANDS     r3,r3,r5
;;;199        
;;;200        if(iocurrent)
000014  d069              BEQ      |L4.234|
;;;201        {
;;;202          /*--------------------- GPIO Mode Configuration ------------------------*/
;;;203          /* In case of Alternate function mode selection */
;;;204          if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD)) 
000016  684e              LDR      r6,[r1,#4]
000018  2e02              CMP      r6,#2
00001a  d001              BEQ      |L4.32|
00001c  2e12              CMP      r6,#0x12
00001e  d114              BNE      |L4.74|
                  |L4.32|
;;;205          {
;;;206            /* Check if the Alternate function is compliant with the GPIO in use */
;;;207            assert_param(IS_GPIO_AF_AVAILABLE(GPIOx,(GPIO_Init->Alternate)));
;;;208            /* Configure Alternate function mapped with the current IO */ 
;;;209            temp = GPIOx->AFR[position >> 3U];
000020  08d6              LSRS     r6,r2,#3
000022  00b6              LSLS     r6,r6,#2
000024  1837              ADDS     r7,r6,r0
000026  9700              STR      r7,[sp,#0]
000028  6a3f              LDR      r7,[r7,#0x20]
;;;210            temp &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U)) ;
00002a  0756              LSLS     r6,r2,#29
00002c  46bc              MOV      r12,r7                ;209
00002e  0ef7              LSRS     r7,r6,#27
000030  260f              MOVS     r6,#0xf
000032  46be              MOV      lr,r7
000034  40be              LSLS     r6,r6,r7
000036  4667              MOV      r7,r12
000038  43b7              BICS     r7,r7,r6
00003a  46bc              MOV      r12,r7
;;;211            temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U)) ;
00003c  690e              LDR      r6,[r1,#0x10]
00003e  4677              MOV      r7,lr
000040  40be              LSLS     r6,r6,r7
000042  4667              MOV      r7,r12
000044  433e              ORRS     r6,r6,r7
;;;212            GPIOx->AFR[position >> 3U] = temp;
000046  9f00              LDR      r7,[sp,#0]
000048  623e              STR      r6,[r7,#0x20]
                  |L4.74|
;;;213          } 
;;;214    
;;;215          /* In case of Output or Alternate function mode selection */
;;;216          if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
00004a  684e              LDR      r6,[r1,#4]
00004c  2e01              CMP      r6,#1
00004e  d005              BEQ      |L4.92|
000050  2e02              CMP      r6,#2
000052  d003              BEQ      |L4.92|
;;;217             (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
000054  2e11              CMP      r6,#0x11
000056  d001              BEQ      |L4.92|
000058  2e12              CMP      r6,#0x12
00005a  d116              BNE      |L4.138|
                  |L4.92|
;;;218          {
;;;219            /* Check the Speed parameter */
;;;220            assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
;;;221            /* Configure the IO Speed */
;;;222            temp = GPIOx->OSPEEDR;
00005c  6886              LDR      r6,[r0,#8]
;;;223            temp &= ~(GPIO_OSPEEDER_OSPEED0 << (position * 2U));
00005e  2703              MOVS     r7,#3
000060  46b4              MOV      r12,r6                ;222
000062  0056              LSLS     r6,r2,#1
000064  46b6              MOV      lr,r6
000066  40b7              LSLS     r7,r7,r6
000068  4666              MOV      r6,r12
00006a  43be              BICS     r6,r6,r7
00006c  46b4              MOV      r12,r6
;;;224            temp |= (GPIO_Init->Speed << (position * 2U));
00006e  68cf              LDR      r7,[r1,#0xc]
000070  4676              MOV      r6,lr
000072  40b7              LSLS     r7,r7,r6
000074  4666              MOV      r6,r12
000076  4337              ORRS     r7,r7,r6
;;;225            GPIOx->OSPEEDR = temp;
000078  6087              STR      r7,[r0,#8]
;;;226    
;;;227            /* Configure the IO Output Type */
;;;228            temp= GPIOx->OTYPER;
00007a  6846              LDR      r6,[r0,#4]
;;;229            temp &= ~(GPIO_OTYPER_OT_0 << position) ;
00007c  43ae              BICS     r6,r6,r5
;;;230            temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
00007e  790d              LDRB     r5,[r1,#4]
000080  06ed              LSLS     r5,r5,#27
000082  0fed              LSRS     r5,r5,#31
000084  4095              LSLS     r5,r5,r2
000086  4335              ORRS     r5,r5,r6
;;;231            GPIOx->OTYPER = temp;
000088  6045              STR      r5,[r0,#4]
                  |L4.138|
;;;232          }
;;;233    
;;;234          /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
;;;235          temp = GPIOx->MODER;
00008a  6807              LDR      r7,[r0,#0]
;;;236          temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
00008c  0056              LSLS     r6,r2,#1
00008e  2503              MOVS     r5,#3
000090  40b5              LSLS     r5,r5,r6
000092  46ac              MOV      r12,r5
000094  43af              BICS     r7,r7,r5
;;;237          temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
000096  790d              LDRB     r5,[r1,#4]
000098  07ad              LSLS     r5,r5,#30
00009a  0fad              LSRS     r5,r5,#30
00009c  40b5              LSLS     r5,r5,r6
00009e  433d              ORRS     r5,r5,r7
;;;238          GPIOx->MODER = temp;
0000a0  6005              STR      r5,[r0,#0]
;;;239    
;;;240          /* Activate the Pull-up or Pull down resistor for the current IO */
;;;241          temp = GPIOx->PUPDR;
0000a2  68c7              LDR      r7,[r0,#0xc]
0000a4  4665              MOV      r5,r12
;;;242          temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
0000a6  43af              BICS     r7,r7,r5
;;;243          temp |= ((GPIO_Init->Pull) << (position * 2U)); 
0000a8  688d              LDR      r5,[r1,#8]
0000aa  40b5              LSLS     r5,r5,r6
0000ac  433d              ORRS     r5,r5,r7
;;;244          GPIOx->PUPDR = temp;
0000ae  60c5              STR      r5,[r0,#0xc]
;;;245    
;;;246          /*--------------------- EXTI Mode Configuration ------------------------*/
;;;247          /* Configure the External Interrupt or event for the current IO */
;;;248          if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
0000b0  684d              LDR      r5,[r1,#4]
0000b2  00ed              LSLS     r5,r5,#3
0000b4  d54a              BPL      |L4.332|
;;;249          {
;;;250            /* Enable SYSCFG Clock */
;;;251            __HAL_RCC_SYSCFG_CLK_ENABLE();
0000b6  4d29              LDR      r5,|L4.348|
0000b8  6b6e              LDR      r6,[r5,#0x34]
0000ba  4326              ORRS     r6,r6,r4
0000bc  636e              STR      r6,[r5,#0x34]
;;;252            
;;;253            temp = SYSCFG->EXTICR[position >> 2U];
0000be  0895              LSRS     r5,r2,#2
0000c0  4c27              LDR      r4,|L4.352|
0000c2  00ad              LSLS     r5,r5,#2
0000c4  192f              ADDS     r7,r5,r4
0000c6  68bc              LDR      r4,[r7,#8]
;;;254            CLEAR_BIT(temp, ((uint32_t)0x0FU) << (4U * (position & 0x03U)));
0000c8  0795              LSLS     r5,r2,#30
0000ca  0f2e              LSRS     r6,r5,#28
0000cc  250f              MOVS     r5,#0xf
0000ce  40b5              LSLS     r5,r5,r6
0000d0  43ac              BICS     r4,r4,r5
;;;255            SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03U)));
0000d2  2505              MOVS     r5,#5
0000d4  072d              LSLS     r5,r5,#28
0000d6  42a8              CMP      r0,r5
0000d8  d101              BNE      |L4.222|
0000da  2500              MOVS     r5,#0
0000dc  e016              B        |L4.268|
                  |L4.222|
0000de  4d21              LDR      r5,|L4.356|
0000e0  42a8              CMP      r0,r5
0000e2  d103              BNE      |L4.236|
0000e4  2501              MOVS     r5,#1
0000e6  e011              B        |L4.268|
                  |L4.232|
0000e8  e036              B        |L4.344|
                  |L4.234|
0000ea  e02f              B        |L4.332|
                  |L4.236|
0000ec  4d1e              LDR      r5,|L4.360|
0000ee  42a8              CMP      r0,r5
0000f0  d101              BNE      |L4.246|
0000f2  2502              MOVS     r5,#2
0000f4  e00a              B        |L4.268|
                  |L4.246|
0000f6  4d1d              LDR      r5,|L4.364|
0000f8  42a8              CMP      r0,r5
0000fa  d101              BNE      |L4.256|
0000fc  2503              MOVS     r5,#3
0000fe  e005              B        |L4.268|
                  |L4.256|
000100  4d1b              LDR      r5,|L4.368|
000102  42a8              CMP      r0,r5
000104  d101              BNE      |L4.266|
000106  2505              MOVS     r5,#5
000108  e000              B        |L4.268|
                  |L4.266|
00010a  2506              MOVS     r5,#6
                  |L4.268|
00010c  40b5              LSLS     r5,r5,r6
00010e  4325              ORRS     r5,r5,r4
;;;256            SYSCFG->EXTICR[position >> 2U] = temp;
000110  60bd              STR      r5,[r7,#8]
;;;257                      
;;;258            /* Clear EXTI line configuration */
;;;259            temp = EXTI->IMR;
000112  4c18              LDR      r4,|L4.372|
000114  6825              LDR      r5,[r4,#0]
;;;260            temp &= ~((uint32_t)iocurrent);
;;;261            if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
000116  684e              LDR      r6,[r1,#4]
000118  439d              BICS     r5,r5,r3              ;260
00011a  03f6              LSLS     r6,r6,#15
00011c  d500              BPL      |L4.288|
;;;262            {
;;;263              temp |= iocurrent;
00011e  431d              ORRS     r5,r5,r3
                  |L4.288|
;;;264            }
;;;265            EXTI->IMR = temp;
000120  6025              STR      r5,[r4,#0]
;;;266    
;;;267            temp = EXTI->EMR;
000122  6865              LDR      r5,[r4,#4]
;;;268            temp &= ~((uint32_t)iocurrent);
;;;269            if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
000124  684e              LDR      r6,[r1,#4]
000126  439d              BICS     r5,r5,r3              ;268
000128  03b6              LSLS     r6,r6,#14
00012a  d500              BPL      |L4.302|
;;;270            {
;;;271              temp |= iocurrent;
00012c  431d              ORRS     r5,r5,r3
                  |L4.302|
;;;272            }
;;;273            EXTI->EMR = temp;
00012e  6065              STR      r5,[r4,#4]
;;;274    
;;;275            /* Clear Rising Falling edge configuration */
;;;276            temp = EXTI->RTSR;
000130  68a5              LDR      r5,[r4,#8]
;;;277            temp &= ~((uint32_t)iocurrent);
;;;278            if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
000132  684e              LDR      r6,[r1,#4]
000134  439d              BICS     r5,r5,r3              ;277
000136  02f6              LSLS     r6,r6,#11
000138  d500              BPL      |L4.316|
;;;279            {
;;;280              temp |= iocurrent;
00013a  431d              ORRS     r5,r5,r3
                  |L4.316|
;;;281            }
;;;282            EXTI->RTSR = temp;
00013c  60a5              STR      r5,[r4,#8]
;;;283    
;;;284            temp = EXTI->FTSR;
00013e  68e5              LDR      r5,[r4,#0xc]
;;;285            temp &= ~((uint32_t)iocurrent);
;;;286            if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
000140  684e              LDR      r6,[r1,#4]
000142  439d              BICS     r5,r5,r3              ;285
000144  02b6              LSLS     r6,r6,#10
000146  d500              BPL      |L4.330|
;;;287            {
;;;288              temp |= iocurrent;
000148  431d              ORRS     r5,r5,r3
                  |L4.330|
;;;289            }
;;;290            EXTI->FTSR = temp;
00014a  60e5              STR      r5,[r4,#0xc]
                  |L4.332|
00014c  680b              LDR      r3,[r1,#0]            ;195
00014e  1c52              ADDS     r2,r2,#1              ;195
000150  40d3              LSRS     r3,r3,r2              ;195
000152  d000              BEQ      |L4.342|
000154  e759              B        |L4.10|
                  |L4.342|
;;;291          }
;;;292        }
;;;293        position++;
;;;294      }
;;;295    }
000156  bdf8              POP      {r3-r7,pc}
                  |L4.344|
000158  4770              BX       lr
;;;296    
                          ENDP

00015a  0000              DCW      0x0000
                  |L4.348|
                          DCD      0x40021000
                  |L4.352|
                          DCD      0x40010000
                  |L4.356|
                          DCD      0x50000400
                  |L4.360|
                          DCD      0x50000800
                  |L4.364|
                          DCD      0x50000c00
                  |L4.368|
                          DCD      0x50001c00
                  |L4.372|
                          DCD      0x40010400

                          AREA ||i.HAL_GPIO_LockPin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_LockPin PROC
;;;467    */
;;;468    HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  2201              MOVS     r2,#1
;;;469    {
;;;470      __IO uint32_t tmp = GPIO_LCKR_LCKK;
000002  0412              LSLS     r2,r2,#16
000004  b081              SUB      sp,sp,#4              ;469
;;;471    
;;;472      /* Check the parameters */
;;;473      assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx,GPIO_Pin));
;;;474    
;;;475      /* Apply lock key write sequence */
;;;476      tmp |= GPIO_Pin;
000006  430a              ORRS     r2,r2,r1
;;;477      /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
;;;478      GPIOx->LCKR = tmp;
000008  9200              STR      r2,[sp,#0]
00000a  61c2              STR      r2,[r0,#0x1c]
;;;479      /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
;;;480      GPIOx->LCKR = GPIO_Pin;
00000c  61c1              STR      r1,[r0,#0x1c]
;;;481      /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
;;;482      GPIOx->LCKR = tmp;
00000e  9900              LDR      r1,[sp,#0]
000010  61c1              STR      r1,[r0,#0x1c]
;;;483      /* Read LCKK bit*/
;;;484      tmp = GPIOx->LCKR;
000012  69c1              LDR      r1,[r0,#0x1c]
;;;485    
;;;486      if((GPIOx->LCKR & GPIO_LCKR_LCKK) != RESET)
000014  9100              STR      r1,[sp,#0]
000016  69c0              LDR      r0,[r0,#0x1c]
000018  03c0              LSLS     r0,r0,#15
00001a  d502              BPL      |L5.34|
;;;487      {
;;;488        return HAL_OK;
00001c  2000              MOVS     r0,#0
;;;489      }
;;;490      else
;;;491      {
;;;492        return HAL_ERROR;
;;;493      }
;;;494    }
00001e  b001              ADD      sp,sp,#4
000020  4770              BX       lr
                  |L5.34|
000022  2001              MOVS     r0,#1                 ;492
000024  b001              ADD      sp,sp,#4
000026  4770              BX       lr
;;;495    /**
                          ENDP


                          AREA ||i.HAL_GPIO_ReadPin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_ReadPin PROC
;;;386      */
;;;387    GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  6900              LDR      r0,[r0,#0x10]
;;;388    {
;;;389      GPIO_PinState bitstatus;
;;;390      
;;;391      /* Check the parameters */
;;;392      assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx,GPIO_Pin));
;;;393      
;;;394      if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
000002  4008              ANDS     r0,r0,r1
000004  d000              BEQ      |L6.8|
;;;395      {
;;;396        bitstatus = GPIO_PIN_SET;
000006  2001              MOVS     r0,#1
                  |L6.8|
;;;397      }
;;;398      else
;;;399      {
;;;400        bitstatus = GPIO_PIN_RESET;
;;;401      }
;;;402      return bitstatus;
;;;403    }
000008  4770              BX       lr
;;;404    
                          ENDP


                          AREA ||i.HAL_GPIO_TogglePin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_TogglePin PROC
;;;446      */
;;;447    void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  6942              LDR      r2,[r0,#0x14]
;;;448    {
;;;449      /* Check the parameters */
;;;450      assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx,GPIO_Pin));
;;;451    
;;;452      GPIOx->ODR ^= GPIO_Pin;
000002  404a              EORS     r2,r2,r1
000004  6142              STR      r2,[r0,#0x14]
;;;453    }
000006  4770              BX       lr
;;;454    
                          ENDP


                          AREA ||i.HAL_GPIO_WritePin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_WritePin PROC
;;;422      */
;;;423    void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
000000  2a00              CMP      r2,#0
;;;424    {
000002  d001              BEQ      |L8.8|
;;;425      /* Check the parameters */
;;;426      assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx,GPIO_Pin));
;;;427      assert_param(IS_GPIO_PIN_ACTION(PinState));
;;;428      
;;;429      if(PinState != GPIO_PIN_RESET)
;;;430      {
;;;431        GPIOx->BSRR = GPIO_Pin;
000004  6181              STR      r1,[r0,#0x18]
;;;432      }
;;;433      else
;;;434      {
;;;435        GPIOx->BRR = GPIO_Pin ;
;;;436      }
;;;437    }
000006  4770              BX       lr
                  |L8.8|
000008  6281              STR      r1,[r0,#0x28]         ;435
00000a  4770              BX       lr
;;;438    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_L0_V1.10.0\\Drivers\\STM32L0xx_HAL_Driver\\Src\\stm32l0xx_hal_gpio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32l0xx_hal_gpio_c_ea787061____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_L0_V1.10.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___20_stm32l0xx_hal_gpio_c_ea787061____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32l0xx_hal_gpio_c_ea787061____REVSH|
#line 402
|__asm___20_stm32l0xx_hal_gpio_c_ea787061____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
