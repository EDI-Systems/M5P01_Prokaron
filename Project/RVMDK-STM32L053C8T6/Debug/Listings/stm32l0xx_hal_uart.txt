; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32l0xx_hal_uart.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32l0xx_hal_uart.d --cpu=Cortex-M0+ --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\STM32L0xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\CMSIS\Device\ST\STM32L0xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\STM32L0xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32L053C8T6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32L0xx_DFP\2.0.0\Drivers\CMSIS\Device\ST\STM32L0xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32L053xx -DSTM32L0xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32l0xx_hal_uart.crf ..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\STM32L0xx_HAL_Driver\Src\stm32l0xx_hal_uart.c]
                          THUMB

                          AREA ||i.HAL_HalfDuplex_EnableReceiver||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableReceiver PROC
;;;1998     */
;;;1999   HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
000000  6e81              LDR      r1,[r0,#0x68]
;;;2000   {
;;;2001     /* Process Locked */
;;;2002     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  d013              BEQ      |L1.46|
000006  2101              MOVS     r1,#1
;;;2003     huart->gState = HAL_UART_STATE_BUSY;
000008  6681              STR      r1,[r0,#0x68]
00000a  2124              MOVS     r1,#0x24
00000c  66c1              STR      r1,[r0,#0x6c]
;;;2004   
;;;2005     /* Clear TE and RE bits */
;;;2006     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));
00000e  6801              LDR      r1,[r0,#0]
000010  680a              LDR      r2,[r1,#0]
000012  230c              MOVS     r3,#0xc
000014  439a              BICS     r2,r2,r3
000016  600a              STR      r2,[r1,#0]
;;;2007     /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
;;;2008     SET_BIT(huart->Instance->CR1, USART_CR1_RE);
000018  6801              LDR      r1,[r0,#0]
00001a  680a              LDR      r2,[r1,#0]
00001c  2304              MOVS     r3,#4
00001e  431a              ORRS     r2,r2,r3
000020  600a              STR      r2,[r1,#0]
;;;2009   
;;;2010     huart->gState = HAL_UART_STATE_READY;
000022  2120              MOVS     r1,#0x20
000024  66c1              STR      r1,[r0,#0x6c]
;;;2011     /* Process Unlocked */
;;;2012     __HAL_UNLOCK(huart);
000026  2100              MOVS     r1,#0
;;;2013   
;;;2014     return HAL_OK;
000028  6681              STR      r1,[r0,#0x68]
00002a  4608              MOV      r0,r1
;;;2015   }
00002c  4770              BX       lr
                  |L1.46|
00002e  2002              MOVS     r0,#2                 ;2002
000030  4770              BX       lr
;;;2016   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_EnableTransmitter||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableTransmitter PROC
;;;1974     */
;;;1975   HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
000000  6e81              LDR      r1,[r0,#0x68]
;;;1976   {
;;;1977     /* Process Locked */
;;;1978     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  d013              BEQ      |L2.46|
000006  2101              MOVS     r1,#1
;;;1979     huart->gState = HAL_UART_STATE_BUSY;
000008  6681              STR      r1,[r0,#0x68]
00000a  2124              MOVS     r1,#0x24
00000c  66c1              STR      r1,[r0,#0x6c]
;;;1980   
;;;1981     /* Clear TE and RE bits */
;;;1982     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));
00000e  6801              LDR      r1,[r0,#0]
000010  680a              LDR      r2,[r1,#0]
000012  230c              MOVS     r3,#0xc
000014  439a              BICS     r2,r2,r3
000016  600a              STR      r2,[r1,#0]
;;;1983     /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
;;;1984     SET_BIT(huart->Instance->CR1, USART_CR1_TE);
000018  6801              LDR      r1,[r0,#0]
00001a  680a              LDR      r2,[r1,#0]
00001c  2308              MOVS     r3,#8
00001e  431a              ORRS     r2,r2,r3
000020  600a              STR      r2,[r1,#0]
;;;1985   
;;;1986     huart->gState = HAL_UART_STATE_READY;
000022  2120              MOVS     r1,#0x20
000024  66c1              STR      r1,[r0,#0x6c]
;;;1987   
;;;1988     /* Process Unlocked */
;;;1989     __HAL_UNLOCK(huart);
000026  2100              MOVS     r1,#0
;;;1990   
;;;1991     return HAL_OK;
000028  6681              STR      r1,[r0,#0x68]
00002a  4608              MOV      r0,r1
;;;1992   }
00002c  4770              BX       lr
                  |L2.46|
00002e  2002              MOVS     r0,#2                 ;1978
000030  4770              BX       lr
;;;1993   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_Init||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_Init PROC
;;;287      */
;;;288    HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
000000  2800              CMP      r0,#0
;;;289    {
;;;290      /* Check the UART handle allocation */
;;;291      if(huart == NULL)
000002  d101              BNE      |L3.8|
;;;292      {
;;;293        return HAL_ERROR;
000004  2001              MOVS     r0,#1
;;;294      }
;;;295    
;;;296      /* Check UART instance */
;;;297      assert_param(IS_UART_HALFDUPLEX_INSTANCE(huart->Instance));
;;;298    
;;;299      if(huart->gState == HAL_UART_STATE_RESET)
;;;300      {
;;;301        /* Allocate lock resource and initialize it */
;;;302        huart->Lock = HAL_UNLOCKED;
;;;303    
;;;304        /* Init the low level hardware : GPIO, CLOCK */
;;;305        HAL_UART_MspInit(huart);
;;;306      }
;;;307    
;;;308      huart->gState = HAL_UART_STATE_BUSY;
;;;309    
;;;310      /* Disable the Peripheral */
;;;311      __HAL_UART_DISABLE(huart);
;;;312    
;;;313      /* Set the UART Communication parameters */
;;;314      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;315      {
;;;316        UART_AdvFeatureConfig(huart);
;;;317      }
;;;318    
;;;319      if (UART_SetConfig(huart) == HAL_ERROR)
;;;320      {
;;;321        return HAL_ERROR;
;;;322      }
;;;323    
;;;324      /* In half-duplex mode, the following bits must be kept cleared:
;;;325      - LINEN and CLKEN bits in the USART_CR2 register,
;;;326      - SCEN and IREN bits in the USART_CR3 register.*/
;;;327      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;328      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
;;;329    
;;;330      /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;331      SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
;;;332    
;;;333      /* Enable the Peripheral */
;;;334      __HAL_UART_ENABLE(huart);
;;;335    
;;;336      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;337      return (UART_CheckIdleState(huart));
;;;338    }
000006  4770              BX       lr
                  |L3.8|
000008  b510              PUSH     {r4,lr}               ;289
00000a  4604              MOV      r4,r0                 ;289
00000c  6ec0              LDR      r0,[r0,#0x6c]         ;299
00000e  2800              CMP      r0,#0                 ;299
000010  d103              BNE      |L3.26|
000012  66a0              STR      r0,[r4,#0x68]         ;305
000014  4620              MOV      r0,r4                 ;305
000016  f7fffffe          BL       HAL_UART_MspInit
                  |L3.26|
00001a  2024              MOVS     r0,#0x24              ;308
00001c  66e0              STR      r0,[r4,#0x6c]         ;308
00001e  6820              LDR      r0,[r4,#0]            ;311
000020  6801              LDR      r1,[r0,#0]            ;311
000022  0849              LSRS     r1,r1,#1              ;311
000024  0049              LSLS     r1,r1,#1              ;311
000026  6001              STR      r1,[r0,#0]            ;311
000028  6a60              LDR      r0,[r4,#0x24]         ;314
00002a  2800              CMP      r0,#0                 ;314
00002c  d002              BEQ      |L3.52|
00002e  4620              MOV      r0,r4                 ;316
000030  f7fffffe          BL       UART_AdvFeatureConfig
                  |L3.52|
000034  4620              MOV      r0,r4                 ;319
000036  f7fffffe          BL       UART_SetConfig
00003a  2801              CMP      r0,#1                 ;319
00003c  d017              BEQ      |L3.110|
00003e  6820              LDR      r0,[r4,#0]            ;327
000040  6841              LDR      r1,[r0,#4]            ;327
000042  2209              MOVS     r2,#9                 ;327
000044  02d2              LSLS     r2,r2,#11             ;327
000046  4391              BICS     r1,r1,r2              ;327
000048  6041              STR      r1,[r0,#4]            ;327
00004a  6820              LDR      r0,[r4,#0]            ;328
00004c  6881              LDR      r1,[r0,#8]            ;328
00004e  2222              MOVS     r2,#0x22              ;328
000050  4391              BICS     r1,r1,r2              ;328
000052  6081              STR      r1,[r0,#8]            ;328
000054  6820              LDR      r0,[r4,#0]            ;331
000056  6881              LDR      r1,[r0,#8]            ;331
000058  2208              MOVS     r2,#8                 ;331
00005a  4311              ORRS     r1,r1,r2              ;331
00005c  6081              STR      r1,[r0,#8]            ;331
00005e  6820              LDR      r0,[r4,#0]            ;334
000060  6801              LDR      r1,[r0,#0]            ;334
000062  2201              MOVS     r2,#1                 ;334
000064  4311              ORRS     r1,r1,r2              ;334
000066  6001              STR      r1,[r0,#0]            ;334
000068  4620              MOV      r0,r4                 ;337
00006a  f7fffffe          BL       UART_CheckIdleState
                  |L3.110|
00006e  bd10              POP      {r4,pc}
;;;339    
                          ENDP


                          AREA ||i.HAL_LIN_Init||, CODE, READONLY, ALIGN=1

                  HAL_LIN_Init PROC
;;;350      */
;;;351    HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
000000  2800              CMP      r0,#0
;;;352    {
;;;353      /* Check the UART handle allocation */
;;;354      if(huart == NULL)
000002  d101              BNE      |L4.8|
;;;355      {
;;;356        return HAL_ERROR;
000004  2001              MOVS     r0,#1
;;;357      }
;;;358    
;;;359      /* Check the LIN UART instance */
;;;360      assert_param(IS_UART_LIN_INSTANCE(huart->Instance));
;;;361      /* Check the Break detection length parameter */
;;;362      assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
;;;363    
;;;364      /* LIN mode limited to 16-bit oversampling only */
;;;365      if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
;;;366      {
;;;367        return HAL_ERROR;
;;;368      }
;;;369      /* LIN mode limited to 8-bit data length */
;;;370      if(huart->Init.WordLength != UART_WORDLENGTH_8B)
;;;371      {
;;;372        return HAL_ERROR;
;;;373      }
;;;374    
;;;375      if(huart->gState == HAL_UART_STATE_RESET)
;;;376      {
;;;377        /* Allocate lock resource and initialize it */
;;;378        huart->Lock = HAL_UNLOCKED;
;;;379    
;;;380        /* Init the low level hardware : GPIO, CLOCK */
;;;381        HAL_UART_MspInit(huart);
;;;382      }
;;;383    
;;;384      huart->gState = HAL_UART_STATE_BUSY;
;;;385    
;;;386      /* Disable the Peripheral */
;;;387      __HAL_UART_DISABLE(huart);
;;;388    
;;;389      /* Set the UART Communication parameters */
;;;390      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;391      {
;;;392        UART_AdvFeatureConfig(huart);
;;;393      }
;;;394    
;;;395      if (UART_SetConfig(huart) == HAL_ERROR)
;;;396      {
;;;397        return HAL_ERROR;
;;;398      }
;;;399    
;;;400      /* In LIN mode, the following bits must be kept cleared:
;;;401      - LINEN and CLKEN bits in the USART_CR2 register,
;;;402      - SCEN and IREN bits in the USART_CR3 register.*/
;;;403      CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
;;;404      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
;;;405    
;;;406      /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;407      SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
;;;408    
;;;409      /* Set the USART LIN Break detection length. */
;;;410      MODIFY_REG(huart->Instance->CR2, USART_CR2_LBDL, BreakDetectLength);
;;;411    
;;;412      /* Enable the Peripheral */
;;;413      __HAL_UART_ENABLE(huart);
;;;414    
;;;415      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;416      return (UART_CheckIdleState(huart));
;;;417    }
000006  4770              BX       lr
                  |L4.8|
000008  b570              PUSH     {r4-r6,lr}            ;352
00000a  460d              MOV      r5,r1                 ;352
00000c  4604              MOV      r4,r0                 ;352
00000e  69c0              LDR      r0,[r0,#0x1c]         ;365
000010  2101              MOVS     r1,#1                 ;365
000012  03c9              LSLS     r1,r1,#15             ;365
000014  4288              CMP      r0,r1                 ;365
000016  d002              BEQ      |L4.30|
000018  68a0              LDR      r0,[r4,#8]            ;370
00001a  2800              CMP      r0,#0                 ;370
00001c  d001              BEQ      |L4.34|
                  |L4.30|
00001e  2001              MOVS     r0,#1                 ;372
                  |L4.32|
000020  bd70              POP      {r4-r6,pc}
                  |L4.34|
000022  6ee0              LDR      r0,[r4,#0x6c]         ;375
000024  2800              CMP      r0,#0                 ;375
000026  d103              BNE      |L4.48|
000028  66a0              STR      r0,[r4,#0x68]         ;381
00002a  4620              MOV      r0,r4                 ;381
00002c  f7fffffe          BL       HAL_UART_MspInit
                  |L4.48|
000030  2024              MOVS     r0,#0x24              ;384
000032  66e0              STR      r0,[r4,#0x6c]         ;384
000034  6820              LDR      r0,[r4,#0]            ;387
000036  6801              LDR      r1,[r0,#0]            ;387
000038  0849              LSRS     r1,r1,#1              ;387
00003a  0049              LSLS     r1,r1,#1              ;387
00003c  6001              STR      r1,[r0,#0]            ;387
00003e  6a60              LDR      r0,[r4,#0x24]         ;390
000040  2800              CMP      r0,#0                 ;390
000042  d002              BEQ      |L4.74|
000044  4620              MOV      r0,r4                 ;392
000046  f7fffffe          BL       UART_AdvFeatureConfig
                  |L4.74|
00004a  4620              MOV      r0,r4                 ;395
00004c  f7fffffe          BL       UART_SetConfig
000050  2801              CMP      r0,#1                 ;395
000052  d0e5              BEQ      |L4.32|
000054  6820              LDR      r0,[r4,#0]            ;403
000056  6841              LDR      r1,[r0,#4]            ;403
000058  2201              MOVS     r2,#1                 ;403
00005a  02d2              LSLS     r2,r2,#11             ;403
00005c  4391              BICS     r1,r1,r2              ;403
00005e  6041              STR      r1,[r0,#4]            ;403
000060  6820              LDR      r0,[r4,#0]            ;404
000062  6881              LDR      r1,[r0,#8]            ;404
000064  222a              MOVS     r2,#0x2a              ;404
000066  4391              BICS     r1,r1,r2              ;404
000068  6081              STR      r1,[r0,#8]            ;404
00006a  6820              LDR      r0,[r4,#0]            ;407
00006c  6841              LDR      r1,[r0,#4]            ;407
00006e  2201              MOVS     r2,#1                 ;407
000070  0392              LSLS     r2,r2,#14             ;407
000072  4311              ORRS     r1,r1,r2              ;407
000074  6041              STR      r1,[r0,#4]            ;407
000076  6821              LDR      r1,[r4,#0]            ;410
000078  6848              LDR      r0,[r1,#4]            ;410
00007a  2220              MOVS     r2,#0x20              ;410
00007c  4390              BICS     r0,r0,r2              ;410
00007e  4328              ORRS     r0,r0,r5              ;410
000080  6048              STR      r0,[r1,#4]            ;410
000082  6820              LDR      r0,[r4,#0]            ;413
000084  6801              LDR      r1,[r0,#0]            ;413
000086  2201              MOVS     r2,#1                 ;413
000088  4311              ORRS     r1,r1,r2              ;413
00008a  6001              STR      r1,[r0,#0]            ;413
00008c  4620              MOV      r0,r4                 ;416
00008e  f7fffffe          BL       UART_CheckIdleState
000092  bd70              POP      {r4-r6,pc}
;;;418    
                          ENDP


                          AREA ||i.HAL_LIN_SendBreak||, CODE, READONLY, ALIGN=1

                  HAL_LIN_SendBreak PROC
;;;2022     */
;;;2023   HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
000000  6e81              LDR      r1,[r0,#0x68]
;;;2024   {
;;;2025     /* Check the parameters */
;;;2026     assert_param(IS_UART_LIN_INSTANCE(huart->Instance));
;;;2027   
;;;2028     /* Process Locked */
;;;2029     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  d00e              BEQ      |L5.36|
000006  2101              MOVS     r1,#1
;;;2030   
;;;2031     huart->gState = HAL_UART_STATE_BUSY;
000008  6681              STR      r1,[r0,#0x68]
00000a  2124              MOVS     r1,#0x24
00000c  66c1              STR      r1,[r0,#0x6c]
;;;2032   
;;;2033     /* Send break characters */
;;;2034     huart->Instance->RQR |= UART_SENDBREAK_REQUEST;
00000e  6801              LDR      r1,[r0,#0]
000010  698a              LDR      r2,[r1,#0x18]
000012  2302              MOVS     r3,#2
000014  431a              ORRS     r2,r2,r3
000016  618a              STR      r2,[r1,#0x18]
;;;2035   
;;;2036     huart->gState = HAL_UART_STATE_READY;
000018  2120              MOVS     r1,#0x20
00001a  66c1              STR      r1,[r0,#0x6c]
;;;2037   
;;;2038     /* Process Unlocked */
;;;2039     __HAL_UNLOCK(huart);
00001c  2100              MOVS     r1,#0
;;;2040   
;;;2041     return HAL_OK;
00001e  6681              STR      r1,[r0,#0x68]
000020  4608              MOV      r0,r1
;;;2042   }
000022  4770              BX       lr
                  |L5.36|
000024  2002              MOVS     r0,#2                 ;2029
000026  4770              BX       lr
;;;2043   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_DisableMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_DisableMuteMode PROC
;;;1943     */
;;;1944   HAL_StatusTypeDef HAL_MultiProcessor_DisableMuteMode(UART_HandleTypeDef *huart)
000000  6e81              LDR      r1,[r0,#0x68]
;;;1945   {
;;;1946     /* Process Locked */
;;;1947     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  d101              BNE      |L6.10|
000006  2002              MOVS     r0,#2
;;;1948   
;;;1949     huart->gState = HAL_UART_STATE_BUSY;
;;;1950   
;;;1951      /* Disable USART mute mode by clearing the MME bit in the CR1 register */
;;;1952     CLEAR_BIT(huart->Instance->CR1, USART_CR1_MME);
;;;1953   
;;;1954     huart->gState = HAL_UART_STATE_READY;
;;;1955   
;;;1956     return (UART_CheckIdleState(huart));
;;;1957   }
000008  4770              BX       lr
                  |L6.10|
00000a  b510              PUSH     {r4,lr}               ;1945
00000c  2101              MOVS     r1,#1                 ;1947
00000e  6681              STR      r1,[r0,#0x68]         ;1949
000010  2124              MOVS     r1,#0x24              ;1949
000012  66c1              STR      r1,[r0,#0x6c]         ;1949
000014  6801              LDR      r1,[r0,#0]            ;1952
000016  680a              LDR      r2,[r1,#0]            ;1952
000018  2301              MOVS     r3,#1                 ;1952
00001a  035b              LSLS     r3,r3,#13             ;1952
00001c  439a              BICS     r2,r2,r3              ;1952
00001e  600a              STR      r2,[r1,#0]            ;1952
000020  2120              MOVS     r1,#0x20              ;1954
000022  66c1              STR      r1,[r0,#0x6c]         ;1954
000024  f7fffffe          BL       UART_CheckIdleState
000028  bd10              POP      {r4,pc}
;;;1958   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnableMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnableMuteMode PROC
;;;1922     */
;;;1923   HAL_StatusTypeDef HAL_MultiProcessor_EnableMuteMode(UART_HandleTypeDef *huart)
000000  6e81              LDR      r1,[r0,#0x68]
;;;1924   {
;;;1925     /* Process Locked */
;;;1926     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  d101              BNE      |L7.10|
000006  2002              MOVS     r0,#2
;;;1927   
;;;1928     huart->gState = HAL_UART_STATE_BUSY;
;;;1929   
;;;1930     /* Enable USART mute mode by setting the MME bit in the CR1 register */
;;;1931     SET_BIT(huart->Instance->CR1, USART_CR1_MME);
;;;1932   
;;;1933     huart->gState = HAL_UART_STATE_READY;
;;;1934   
;;;1935     return (UART_CheckIdleState(huart));
;;;1936   }
000008  4770              BX       lr
                  |L7.10|
00000a  b510              PUSH     {r4,lr}               ;1924
00000c  2101              MOVS     r1,#1                 ;1926
00000e  6681              STR      r1,[r0,#0x68]         ;1928
000010  2124              MOVS     r1,#0x24              ;1928
000012  66c1              STR      r1,[r0,#0x6c]         ;1928
000014  6801              LDR      r1,[r0,#0]            ;1931
000016  680a              LDR      r2,[r1,#0]            ;1931
000018  2301              MOVS     r3,#1                 ;1931
00001a  035b              LSLS     r3,r3,#13             ;1931
00001c  431a              ORRS     r2,r2,r3              ;1931
00001e  600a              STR      r2,[r1,#0]            ;1931
000020  2120              MOVS     r1,#0x20              ;1933
000022  66c1              STR      r1,[r0,#0x6c]         ;1933
000024  f7fffffe          BL       UART_CheckIdleState
000028  bd10              POP      {r4,pc}
;;;1937   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnterMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnterMuteMode PROC
;;;1964     */
;;;1965   void HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
000000  6800              LDR      r0,[r0,#0]
;;;1966   {
;;;1967     __HAL_UART_SEND_REQ(huart, UART_MUTE_MODE_REQUEST);
000002  6981              LDR      r1,[r0,#0x18]
000004  2204              MOVS     r2,#4
000006  4311              ORRS     r1,r1,r2
000008  6181              STR      r1,[r0,#0x18]
;;;1968   }
00000a  4770              BX       lr
;;;1969   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_Init||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_Init PROC
;;;437      */
;;;438    HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
000000  2800              CMP      r0,#0
;;;439    {
;;;440      /* Check the UART handle allocation */
;;;441      if(huart == NULL)
000002  d101              BNE      |L9.8|
;;;442      {
;;;443        return HAL_ERROR;
000004  2001              MOVS     r0,#1
;;;444      }
;;;445    
;;;446      /* Check the wake up method parameter */
;;;447      assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
;;;448    
;;;449      if(huart->gState == HAL_UART_STATE_RESET)
;;;450      {
;;;451        /* Allocate lock resource and initialize it */
;;;452        huart->Lock = HAL_UNLOCKED;
;;;453    
;;;454        /* Init the low level hardware : GPIO, CLOCK */
;;;455        HAL_UART_MspInit(huart);
;;;456      }
;;;457    
;;;458      huart->gState = HAL_UART_STATE_BUSY;
;;;459    
;;;460      /* Disable the Peripheral */
;;;461      __HAL_UART_DISABLE(huart);
;;;462    
;;;463      /* Set the UART Communication parameters */
;;;464      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;465      {
;;;466        UART_AdvFeatureConfig(huart);
;;;467      }
;;;468    
;;;469      if (UART_SetConfig(huart) == HAL_ERROR)
;;;470      {
;;;471        return HAL_ERROR;
;;;472      }
;;;473    
;;;474      /* In multiprocessor mode, the following bits must be kept cleared:
;;;475      - LINEN and CLKEN bits in the USART_CR2 register,
;;;476      - SCEN, HDSEL and IREN  bits in the USART_CR3 register. */
;;;477      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;478      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;479    
;;;480      if (WakeUpMethod == UART_WAKEUPMETHOD_ADDRESSMARK)
;;;481      {
;;;482        /* If address mark wake up method is chosen, set the USART address node */
;;;483        MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, ((uint32_t)Address << UART_CR2_ADDRESS_LSB_POS));
;;;484      }
;;;485    
;;;486      /* Set the wake up method by setting the WAKE bit in the CR1 register */
;;;487      MODIFY_REG(huart->Instance->CR1, USART_CR1_WAKE, WakeUpMethod);
;;;488    
;;;489      /* Enable the Peripheral */
;;;490      __HAL_UART_ENABLE(huart);
;;;491    
;;;492      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;493      return (UART_CheckIdleState(huart));
;;;494    }
000006  4770              BX       lr
                  |L9.8|
000008  b570              PUSH     {r4-r6,lr}            ;439
00000a  4604              MOV      r4,r0                 ;439
00000c  6ec0              LDR      r0,[r0,#0x6c]         ;449
00000e  4615              MOV      r5,r2                 ;439
000010  460e              MOV      r6,r1                 ;439
000012  2800              CMP      r0,#0                 ;449
000014  d103              BNE      |L9.30|
000016  66a0              STR      r0,[r4,#0x68]         ;455
000018  4620              MOV      r0,r4                 ;455
00001a  f7fffffe          BL       HAL_UART_MspInit
                  |L9.30|
00001e  2024              MOVS     r0,#0x24              ;458
000020  66e0              STR      r0,[r4,#0x6c]         ;458
000022  6820              LDR      r0,[r4,#0]            ;461
000024  6801              LDR      r1,[r0,#0]            ;461
000026  0849              LSRS     r1,r1,#1              ;461
000028  0049              LSLS     r1,r1,#1              ;461
00002a  6001              STR      r1,[r0,#0]            ;461
00002c  6a60              LDR      r0,[r4,#0x24]         ;464
00002e  2800              CMP      r0,#0                 ;464
000030  d002              BEQ      |L9.56|
000032  4620              MOV      r0,r4                 ;466
000034  f7fffffe          BL       UART_AdvFeatureConfig
                  |L9.56|
000038  4620              MOV      r0,r4                 ;469
00003a  f7fffffe          BL       UART_SetConfig
00003e  2801              CMP      r0,#1                 ;469
000040  d022              BEQ      |L9.136|
000042  6820              LDR      r0,[r4,#0]            ;477
000044  6841              LDR      r1,[r0,#4]            ;477
000046  2209              MOVS     r2,#9                 ;477
000048  02d2              LSLS     r2,r2,#11             ;477
00004a  4391              BICS     r1,r1,r2              ;477
00004c  6041              STR      r1,[r0,#4]            ;477
00004e  6820              LDR      r0,[r4,#0]            ;478
000050  6881              LDR      r1,[r0,#8]            ;478
000052  222a              MOVS     r2,#0x2a              ;478
000054  4391              BICS     r1,r1,r2              ;478
000056  6081              STR      r1,[r0,#8]            ;478
000058  2001              MOVS     r0,#1                 ;480
00005a  02c0              LSLS     r0,r0,#11             ;480
00005c  4285              CMP      r5,r0                 ;480
00005e  d106              BNE      |L9.110|
000060  6821              LDR      r1,[r4,#0]            ;483
000062  684a              LDR      r2,[r1,#4]            ;483
000064  0212              LSLS     r2,r2,#8              ;483
000066  0a12              LSRS     r2,r2,#8              ;483
000068  0633              LSLS     r3,r6,#24             ;483
00006a  431a              ORRS     r2,r2,r3              ;483
00006c  604a              STR      r2,[r1,#4]            ;483
                  |L9.110|
00006e  6821              LDR      r1,[r4,#0]            ;487
000070  680a              LDR      r2,[r1,#0]            ;487
000072  4382              BICS     r2,r2,r0              ;487
000074  432a              ORRS     r2,r2,r5              ;487
000076  600a              STR      r2,[r1,#0]            ;487
000078  6820              LDR      r0,[r4,#0]            ;490
00007a  6801              LDR      r1,[r0,#0]            ;490
00007c  2201              MOVS     r2,#1                 ;490
00007e  4311              ORRS     r1,r1,r2              ;490
000080  6001              STR      r1,[r0,#0]            ;490
000082  4620              MOV      r0,r4                 ;493
000084  f7fffffe          BL       UART_CheckIdleState
                  |L9.136|
000088  bd70              POP      {r4-r6,pc}
;;;495    
                          ENDP


                          AREA ||i.HAL_UART_Abort||, CODE, READONLY, ALIGN=1

                  HAL_UART_Abort PROC
;;;1213   */
;;;1214   HAL_StatusTypeDef HAL_UART_Abort(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1215   {
000002  4604              MOV      r4,r0
;;;1216     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1217     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6800              LDR      r0,[r0,#0]
000006  6801              LDR      r1,[r0,#0]
000008  22ff              MOVS     r2,#0xff
00000a  32e1              ADDS     r2,r2,#0xe1
00000c  4391              BICS     r1,r1,r2
00000e  6001              STR      r1,[r0,#0]
;;;1218     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000010  6820              LDR      r0,[r4,#0]
000012  6881              LDR      r1,[r0,#8]
000014  0849              LSRS     r1,r1,#1
000016  0049              LSLS     r1,r1,#1
000018  6081              STR      r1,[r0,#8]
;;;1219   
;;;1220     /* Disable the UART DMA Tx request if enabled */
;;;1221     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
00001a  6820              LDR      r0,[r4,#0]
00001c  6881              LDR      r1,[r0,#8]
00001e  2500              MOVS     r5,#0
000020  0609              LSLS     r1,r1,#24
000022  2900              CMP      r1,#0
000024  da0a              BGE      |L10.60|
;;;1222     {
;;;1223       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000026  6881              LDR      r1,[r0,#8]
000028  2280              MOVS     r2,#0x80
00002a  4391              BICS     r1,r1,r2
00002c  6081              STR      r1,[r0,#8]
;;;1224   
;;;1225       /* Abort the UART DMA Tx channel : use blocking DMA Abort API (no callback) */
;;;1226       if(huart->hdmatx != NULL)
00002e  6e20              LDR      r0,[r4,#0x60]
000030  2800              CMP      r0,#0
000032  d003              BEQ      |L10.60|
;;;1227       {
;;;1228         /* Set the UART DMA Abort callback to Null. 
;;;1229            No call back execution at end of DMA abort procedure */
;;;1230         huart->hdmatx->XferAbortCallback = NULL;
;;;1231   
;;;1232         HAL_DMA_Abort(huart->hdmatx);
000034  63c5              STR      r5,[r0,#0x3c]
000036  6e20              LDR      r0,[r4,#0x60]
000038  f7fffffe          BL       HAL_DMA_Abort
                  |L10.60|
;;;1233       }
;;;1234     }
;;;1235   
;;;1236     /* Disable the UART DMA Rx request if enabled */
;;;1237     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
00003c  6820              LDR      r0,[r4,#0]
00003e  6881              LDR      r1,[r0,#8]
000040  0649              LSLS     r1,r1,#25
000042  d50a              BPL      |L10.90|
;;;1238     {
;;;1239       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000044  6881              LDR      r1,[r0,#8]
000046  2240              MOVS     r2,#0x40
000048  4391              BICS     r1,r1,r2
00004a  6081              STR      r1,[r0,#8]
;;;1240   
;;;1241       /* Abort the UART DMA Rx channel : use blocking DMA Abort API (no callback) */
;;;1242       if(huart->hdmarx != NULL)
00004c  6e60              LDR      r0,[r4,#0x64]
00004e  2800              CMP      r0,#0
000050  d003              BEQ      |L10.90|
;;;1243       {
;;;1244         /* Set the UART DMA Abort callback to Null. 
;;;1245            No call back execution at end of DMA abort procedure */
;;;1246         huart->hdmarx->XferAbortCallback = NULL;
;;;1247   
;;;1248         HAL_DMA_Abort(huart->hdmarx);
000052  63c5              STR      r5,[r0,#0x3c]
000054  6e60              LDR      r0,[r4,#0x64]
000056  f7fffffe          BL       HAL_DMA_Abort
                  |L10.90|
;;;1249       }
;;;1250     }
;;;1251   
;;;1252     /* Reset Tx and Rx transfer counters */
;;;1253     huart->TxXferCount = 0; 
00005a  4620              MOV      r0,r4
00005c  3040              ADDS     r0,r0,#0x40
00005e  8245              STRH     r5,[r0,#0x12]
;;;1254     huart->RxXferCount = 0; 
000060  8345              STRH     r5,[r0,#0x1a]
;;;1255   
;;;1256     /* Clear the Error flags in the ICR register */
;;;1257     __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
000062  6821              LDR      r1,[r4,#0]
000064  200f              MOVS     r0,#0xf
000066  6208              STR      r0,[r1,#0x20]
;;;1258   
;;;1259     /* Restore huart->gState and huart->RxState to Ready */
;;;1260     huart->gState  = HAL_UART_STATE_READY;
000068  2020              MOVS     r0,#0x20
00006a  66e0              STR      r0,[r4,#0x6c]
;;;1261     huart->RxState = HAL_UART_STATE_READY;
00006c  6720              STR      r0,[r4,#0x70]
;;;1262   
;;;1263     /* Reset Handle ErrorCode to No Error */
;;;1264     huart->ErrorCode = HAL_UART_ERROR_NONE;
00006e  6765              STR      r5,[r4,#0x74]
;;;1265   
;;;1266     return HAL_OK;
000070  2000              MOVS     r0,#0
;;;1267   }
000072  bd70              POP      {r4-r6,pc}
;;;1268   
                          ENDP


                          AREA ||i.HAL_UART_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortCpltCallback PROC
;;;1850     */
;;;1851   __weak void HAL_UART_AbortCpltCallback (UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1852   {
;;;1853     /* Prevent unused argument(s) compilation warning */
;;;1854     UNUSED(huart);
;;;1855   
;;;1856     /* NOTE : This function should not be modified, when the callback is needed,
;;;1857               the HAL_UART_AbortCpltCallback can be implemented in the user file.
;;;1858      */
;;;1859   }
;;;1860   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceive PROC
;;;1322   */
;;;1323   HAL_StatusTypeDef HAL_UART_AbortReceive(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1324   {
000002  4604              MOV      r4,r0
;;;1325     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1326     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  6800              LDR      r0,[r0,#0]
000006  6801              LDR      r1,[r0,#0]
000008  22ff              MOVS     r2,#0xff
00000a  3221              ADDS     r2,r2,#0x21
00000c  4391              BICS     r1,r1,r2
00000e  6001              STR      r1,[r0,#0]
;;;1327     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000010  6820              LDR      r0,[r4,#0]
000012  6881              LDR      r1,[r0,#8]
000014  0849              LSRS     r1,r1,#1
000016  0049              LSLS     r1,r1,#1
000018  6081              STR      r1,[r0,#8]
;;;1328   
;;;1329     /* Disable the UART DMA Rx request if enabled */
;;;1330     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
00001a  6820              LDR      r0,[r4,#0]
00001c  6881              LDR      r1,[r0,#8]
00001e  2500              MOVS     r5,#0
000020  0649              LSLS     r1,r1,#25
000022  2900              CMP      r1,#0
000024  da0a              BGE      |L12.60|
;;;1331     {
;;;1332       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000026  6881              LDR      r1,[r0,#8]
000028  2240              MOVS     r2,#0x40
00002a  4391              BICS     r1,r1,r2
00002c  6081              STR      r1,[r0,#8]
;;;1333   
;;;1334       /* Abort the UART DMA Rx channel : use blocking DMA Abort API (no callback) */
;;;1335       if(huart->hdmarx != NULL)
00002e  6e60              LDR      r0,[r4,#0x64]
000030  2800              CMP      r0,#0
000032  d003              BEQ      |L12.60|
;;;1336       {
;;;1337         /* Set the UART DMA Abort callback to Null. 
;;;1338            No call back execution at end of DMA abort procedure */
;;;1339         huart->hdmarx->XferAbortCallback = NULL;
;;;1340   
;;;1341         HAL_DMA_Abort(huart->hdmarx);
000034  63c5              STR      r5,[r0,#0x3c]
000036  6e60              LDR      r0,[r4,#0x64]
000038  f7fffffe          BL       HAL_DMA_Abort
                  |L12.60|
;;;1342       }
;;;1343     }
;;;1344   
;;;1345     /* Reset Rx transfer counter */
;;;1346     huart->RxXferCount = 0; 
00003c  205a              MOVS     r0,#0x5a
00003e  5305              STRH     r5,[r0,r4]
;;;1347   
;;;1348     /* Clear the Error flags in the ICR register */
;;;1349     __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
000040  6821              LDR      r1,[r4,#0]
000042  200f              MOVS     r0,#0xf
000044  6208              STR      r0,[r1,#0x20]
;;;1350   
;;;1351     /* Restore huart->RxState to Ready */
;;;1352     huart->RxState = HAL_UART_STATE_READY;
000046  2020              MOVS     r0,#0x20
000048  6720              STR      r0,[r4,#0x70]
;;;1353   
;;;1354     return HAL_OK;
00004a  2000              MOVS     r0,#0
;;;1355   }
00004c  bd70              POP      {r4-r6,pc}
;;;1356   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceiveCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceiveCpltCallback PROC
;;;1880     */
;;;1881   __weak void HAL_UART_AbortReceiveCpltCallback (UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1882   {
;;;1883     /* Prevent unused argument(s) compilation warning */
;;;1884     UNUSED(huart);
;;;1885   
;;;1886     /* NOTE : This function should not be modified, when the callback is needed,
;;;1887               the HAL_UART_AbortReceiveCpltCallback can be implemented in the user file.
;;;1888      */
;;;1889   }
;;;1890   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortReceive_IT PROC
;;;1560   */
;;;1561   HAL_StatusTypeDef HAL_UART_AbortReceive_IT(UART_HandleTypeDef *huart)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1562   {
000002  4604              MOV      r4,r0
;;;1563     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1564     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  6800              LDR      r0,[r0,#0]
000006  6801              LDR      r1,[r0,#0]
000008  22ff              MOVS     r2,#0xff
00000a  3221              ADDS     r2,r2,#0x21
00000c  4391              BICS     r1,r1,r2
00000e  6001              STR      r1,[r0,#0]
;;;1565     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000010  6820              LDR      r0,[r4,#0]
000012  6881              LDR      r1,[r0,#8]
000014  0849              LSRS     r1,r1,#1
000016  0049              LSLS     r1,r1,#1
000018  6081              STR      r1,[r0,#8]
;;;1566   
;;;1567     /* Disable the UART DMA Rx request if enabled */
;;;1568     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
00001a  6821              LDR      r1,[r4,#0]
00001c  6888              LDR      r0,[r1,#8]
00001e  2200              MOVS     r2,#0
000020  0646              LSLS     r6,r0,#25
;;;1569     {
;;;1570       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1571   
;;;1572       /* Abort the UART DMA Rx channel : use non blocking DMA Abort API (callback) */
;;;1573       if(huart->hdmarx != NULL)
;;;1574       {
;;;1575         /* Set the UART DMA Abort callback : 
;;;1576            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1577         huart->hdmarx->XferAbortCallback = UART_DMARxOnlyAbortCallback;
;;;1578   
;;;1579         /* Abort DMA RX */
;;;1580         if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
;;;1581         {
;;;1582           /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
;;;1583           huart->hdmarx->XferAbortCallback(huart->hdmarx);
;;;1584         }
;;;1585       }
;;;1586       else
;;;1587       {
;;;1588         /* Reset Rx transfer counter */
;;;1589         huart->RxXferCount = 0; 
000022  4620              MOV      r0,r4
000024  3040              ADDS     r0,r0,#0x40
;;;1590   
;;;1591         /* Clear the Error flags in the ICR register */
;;;1592         __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
000026  230f              MOVS     r3,#0xf
;;;1593   
;;;1594         /* Restore huart->RxState to Ready */
;;;1595         huart->RxState = HAL_UART_STATE_READY;
000028  2520              MOVS     r5,#0x20
00002a  2e00              CMP      r6,#0                 ;1568
00002c  da19              BGE      |L14.98|
00002e  688e              LDR      r6,[r1,#8]            ;1570
000030  2740              MOVS     r7,#0x40              ;1570
000032  43be              BICS     r6,r6,r7              ;1570
000034  608e              STR      r6,[r1,#8]            ;1570
000036  6e61              LDR      r1,[r4,#0x64]         ;1573
000038  2900              CMP      r1,#0                 ;1573
00003a  d00a              BEQ      |L14.82|
00003c  480d              LDR      r0,|L14.116|
00003e  63c8              STR      r0,[r1,#0x3c]         ;1580
000040  6e60              LDR      r0,[r4,#0x64]         ;1580
000042  f7fffffe          BL       HAL_DMA_Abort_IT
000046  2800              CMP      r0,#0                 ;1580
000048  d011              BEQ      |L14.110|
00004a  6e60              LDR      r0,[r4,#0x64]         ;1583
00004c  6bc1              LDR      r1,[r0,#0x3c]         ;1583
00004e  4788              BLX      r1                    ;1583
000050  e00d              B        |L14.110|
                  |L14.82|
000052  8342              STRH     r2,[r0,#0x1a]         ;1589
000054  6820              LDR      r0,[r4,#0]            ;1592
000056  6203              STR      r3,[r0,#0x20]         ;1592
000058  6725              STR      r5,[r4,#0x70]
;;;1596   
;;;1597         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1598         HAL_UART_AbortReceiveCpltCallback(huart);
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
000060  e005              B        |L14.110|
                  |L14.98|
;;;1599       }
;;;1600     }
;;;1601     else
;;;1602     {
;;;1603       /* Reset Rx transfer counter */
;;;1604       huart->RxXferCount = 0; 
000062  8342              STRH     r2,[r0,#0x1a]
;;;1605   
;;;1606       /* Clear the Error flags in the ICR register */
;;;1607       __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
000064  620b              STR      r3,[r1,#0x20]
;;;1608   
;;;1609       /* Restore huart->RxState to Ready */
;;;1610       huart->RxState = HAL_UART_STATE_READY;
000066  6725              STR      r5,[r4,#0x70]
;;;1611   
;;;1612       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1613       HAL_UART_AbortReceiveCpltCallback(huart);
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
                  |L14.110|
;;;1614     }
;;;1615   
;;;1616     return HAL_OK;
00006e  2000              MOVS     r0,#0
;;;1617   }
000070  bdf8              POP      {r3-r7,pc}
;;;1618   
                          ENDP

000072  0000              DCW      0x0000
                  |L14.116|
                          DCD      UART_DMARxOnlyAbortCallback

                          AREA ||i.HAL_UART_AbortTransmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmit PROC
;;;1280   */
;;;1281   HAL_StatusTypeDef HAL_UART_AbortTransmit(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1282   {
000002  4604              MOV      r4,r0
;;;1283     /* Disable TXEIE and TCIE interrupts */
;;;1284     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6800              LDR      r0,[r0,#0]
000006  6801              LDR      r1,[r0,#0]
000008  22c0              MOVS     r2,#0xc0
00000a  4391              BICS     r1,r1,r2
00000c  6001              STR      r1,[r0,#0]
;;;1285   
;;;1286     /* Disable the UART DMA Tx request if enabled */
;;;1287     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
00000e  6820              LDR      r0,[r4,#0]
000010  6881              LDR      r1,[r0,#8]
000012  2500              MOVS     r5,#0
000014  0609              LSLS     r1,r1,#24
000016  2900              CMP      r1,#0
000018  da0a              BGE      |L15.48|
;;;1288     {
;;;1289       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00001a  6881              LDR      r1,[r0,#8]
00001c  2280              MOVS     r2,#0x80
00001e  4391              BICS     r1,r1,r2
000020  6081              STR      r1,[r0,#8]
;;;1290   
;;;1291       /* Abort the UART DMA Tx channel : use blocking DMA Abort API (no callback) */
;;;1292       if(huart->hdmatx != NULL)
000022  6e20              LDR      r0,[r4,#0x60]
000024  2800              CMP      r0,#0
000026  d003              BEQ      |L15.48|
;;;1293       {
;;;1294         /* Set the UART DMA Abort callback to Null. 
;;;1295            No call back execution at end of DMA abort procedure */
;;;1296         huart->hdmatx->XferAbortCallback = NULL;
;;;1297   
;;;1298         HAL_DMA_Abort(huart->hdmatx);
000028  63c5              STR      r5,[r0,#0x3c]
00002a  6e20              LDR      r0,[r4,#0x60]
00002c  f7fffffe          BL       HAL_DMA_Abort
                  |L15.48|
;;;1299       }
;;;1300     }
;;;1301   
;;;1302     /* Reset Tx transfer counter */
;;;1303     huart->TxXferCount = 0; 
000030  2052              MOVS     r0,#0x52
000032  5305              STRH     r5,[r0,r4]
;;;1304   
;;;1305     /* Restore huart->gState to Ready */
;;;1306     huart->gState = HAL_UART_STATE_READY;
000034  2020              MOVS     r0,#0x20
000036  66e0              STR      r0,[r4,#0x6c]
;;;1307   
;;;1308     return HAL_OK;
000038  2000              MOVS     r0,#0
;;;1309   }
00003a  bd70              POP      {r4-r6,pc}
;;;1310   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmitCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmitCpltCallback PROC
;;;1865     */
;;;1866   __weak void HAL_UART_AbortTransmitCpltCallback (UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1867   {
;;;1868     /* Prevent unused argument(s) compilation warning */
;;;1869     UNUSED(huart);
;;;1870   
;;;1871     /* NOTE : This function should not be modified, when the callback is needed,
;;;1872               the HAL_UART_AbortTransmitCpltCallback can be implemented in the user file.
;;;1873      */
;;;1874   }
;;;1875   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortTransmit_IT PROC
;;;1495   */
;;;1496   HAL_StatusTypeDef HAL_UART_AbortTransmit_IT(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1497   {
000002  4604              MOV      r4,r0
;;;1498     /* Disable TXEIE and TCIE interrupts */
;;;1499     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6800              LDR      r0,[r0,#0]
000006  6801              LDR      r1,[r0,#0]
000008  22c0              MOVS     r2,#0xc0
00000a  4391              BICS     r1,r1,r2
00000c  6001              STR      r1,[r0,#0]
;;;1500   
;;;1501     /* Disable the UART DMA Tx request if enabled */
;;;1502     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
00000e  6821              LDR      r1,[r4,#0]
000010  6888              LDR      r0,[r1,#8]
000012  2200              MOVS     r2,#0
000014  0605              LSLS     r5,r0,#24
;;;1503     {
;;;1504       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1505   
;;;1506       /* Abort the UART DMA Tx channel : use non blocking DMA Abort API (callback) */
;;;1507       if(huart->hdmatx != NULL)
;;;1508       {
;;;1509         /* Set the UART DMA Abort callback : 
;;;1510            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1511         huart->hdmatx->XferAbortCallback = UART_DMATxOnlyAbortCallback;
;;;1512   
;;;1513         /* Abort DMA TX */
;;;1514         if(HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
;;;1515         {
;;;1516           /* Call Directly huart->hdmatx->XferAbortCallback function in case of error */
;;;1517           huart->hdmatx->XferAbortCallback(huart->hdmatx);
;;;1518         }
;;;1519       }
;;;1520       else
;;;1521       {
;;;1522         /* Reset Tx transfer counter */
;;;1523         huart->TxXferCount = 0; 
000016  4620              MOV      r0,r4
000018  3040              ADDS     r0,r0,#0x40
;;;1524   
;;;1525         /* Restore huart->gState to Ready */
;;;1526         huart->gState = HAL_UART_STATE_READY;
00001a  2320              MOVS     r3,#0x20
00001c  2d00              CMP      r5,#0                 ;1502
00001e  da11              BGE      |L17.68|
000020  688d              LDR      r5,[r1,#8]            ;1504
000022  2680              MOVS     r6,#0x80              ;1504
000024  43b5              BICS     r5,r5,r6              ;1504
000026  608d              STR      r5,[r1,#8]            ;1504
000028  6e21              LDR      r1,[r4,#0x60]         ;1507
00002a  2900              CMP      r1,#0                 ;1507
00002c  d00a              BEQ      |L17.68|
00002e  4809              LDR      r0,|L17.84|
000030  63c8              STR      r0,[r1,#0x3c]         ;1514
000032  6e20              LDR      r0,[r4,#0x60]         ;1514
000034  f7fffffe          BL       HAL_DMA_Abort_IT
000038  2800              CMP      r0,#0                 ;1514
00003a  d008              BEQ      |L17.78|
00003c  6e20              LDR      r0,[r4,#0x60]         ;1517
00003e  6bc1              LDR      r1,[r0,#0x3c]         ;1517
000040  4788              BLX      r1                    ;1517
000042  e004              B        |L17.78|
                  |L17.68|
000044  8242              STRH     r2,[r0,#0x12]         ;1523
000046  66e3              STR      r3,[r4,#0x6c]
;;;1527   
;;;1528         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1529         HAL_UART_AbortTransmitCpltCallback(huart);
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
                  |L17.78|
;;;1530       }
;;;1531     }
;;;1532     else
;;;1533     {
;;;1534       /* Reset Tx transfer counter */
;;;1535       huart->TxXferCount = 0; 
;;;1536   
;;;1537       /* Restore huart->gState to Ready */
;;;1538       huart->gState = HAL_UART_STATE_READY;
;;;1539   
;;;1540       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1541       HAL_UART_AbortTransmitCpltCallback(huart);
;;;1542     }
;;;1543   
;;;1544     return HAL_OK;
00004e  2000              MOVS     r0,#0
;;;1545   }
000050  bd70              POP      {r4-r6,pc}
;;;1546   
                          ENDP

000052  0000              DCW      0x0000
                  |L17.84|
                          DCD      UART_DMATxOnlyAbortCallback

                          AREA ||i.HAL_UART_Abort_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_Abort_IT PROC
;;;1370   */
;;;1371   HAL_StatusTypeDef HAL_UART_Abort_IT(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1372   {
000002  4604              MOV      r4,r0
;;;1373     uint32_t abortcplt = 1;
;;;1374     
;;;1375     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1376     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6800              LDR      r0,[r0,#0]
000006  2601              MOVS     r6,#1                 ;1373
000008  6801              LDR      r1,[r0,#0]
00000a  22ff              MOVS     r2,#0xff
00000c  32e1              ADDS     r2,r2,#0xe1
00000e  4391              BICS     r1,r1,r2
000010  6001              STR      r1,[r0,#0]
;;;1377     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000012  6820              LDR      r0,[r4,#0]
000014  6881              LDR      r1,[r0,#8]
000016  43b1              BICS     r1,r1,r6
000018  6081              STR      r1,[r0,#8]
;;;1378   
;;;1379     /* If DMA Tx and/or DMA Rx Handles are associated to UART Handle, DMA Abort complete callbacks should be initialised
;;;1380        before any call to DMA Abort functions */
;;;1381     /* DMA Tx Handle is valid */
;;;1382     if(huart->hdmatx != NULL)
00001a  6e20              LDR      r0,[r4,#0x60]
00001c  2500              MOVS     r5,#0
00001e  2800              CMP      r0,#0
000020  d007              BEQ      |L18.50|
;;;1383     {
;;;1384       /* Set DMA Abort Complete callback if UART DMA Tx request if enabled.
;;;1385          Otherwise, set it to NULL */
;;;1386       if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000022  6821              LDR      r1,[r4,#0]
000024  6889              LDR      r1,[r1,#8]
000026  0609              LSLS     r1,r1,#24
000028  d502              BPL      |L18.48|
;;;1387       {
;;;1388         huart->hdmatx->XferAbortCallback = UART_DMATxAbortCallback;
00002a  4923              LDR      r1,|L18.184|
00002c  63c1              STR      r1,[r0,#0x3c]
00002e  e000              B        |L18.50|
                  |L18.48|
;;;1389       }
;;;1390       else
;;;1391       {
;;;1392         huart->hdmatx->XferAbortCallback = NULL;
000030  63c5              STR      r5,[r0,#0x3c]
                  |L18.50|
;;;1393       }
;;;1394     }
;;;1395     /* DMA Rx Handle is valid */
;;;1396     if(huart->hdmarx != NULL)
000032  6e60              LDR      r0,[r4,#0x64]
000034  2800              CMP      r0,#0
000036  d007              BEQ      |L18.72|
;;;1397     {
;;;1398       /* Set DMA Abort Complete callback if UART DMA Rx request if enabled.
;;;1399          Otherwise, set it to NULL */
;;;1400       if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000038  6821              LDR      r1,[r4,#0]
00003a  6889              LDR      r1,[r1,#8]
00003c  0649              LSLS     r1,r1,#25
00003e  d502              BPL      |L18.70|
;;;1401       {
;;;1402         huart->hdmarx->XferAbortCallback = UART_DMARxAbortCallback;
000040  491e              LDR      r1,|L18.188|
000042  63c1              STR      r1,[r0,#0x3c]
000044  e000              B        |L18.72|
                  |L18.70|
;;;1403       }
;;;1404       else
;;;1405       {
;;;1406         huart->hdmarx->XferAbortCallback = NULL;
000046  63c5              STR      r5,[r0,#0x3c]
                  |L18.72|
;;;1407       }
;;;1408     }
;;;1409     
;;;1410     /* Disable the UART DMA Tx request if enabled */
;;;1411     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000048  6820              LDR      r0,[r4,#0]
00004a  6881              LDR      r1,[r0,#8]
00004c  0609              LSLS     r1,r1,#24
00004e  d50e              BPL      |L18.110|
;;;1412     {
;;;1413       /* Disable DMA Tx at UART level */
;;;1414       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000050  6881              LDR      r1,[r0,#8]
000052  2280              MOVS     r2,#0x80
000054  4391              BICS     r1,r1,r2
000056  6081              STR      r1,[r0,#8]
;;;1415   
;;;1416       /* Abort the UART DMA Tx channel : use non blocking DMA Abort API (callback) */
;;;1417       if(huart->hdmatx != NULL)
000058  6e20              LDR      r0,[r4,#0x60]
00005a  2800              CMP      r0,#0
00005c  d007              BEQ      |L18.110|
;;;1418       {
;;;1419         /* UART Tx DMA Abort callback has already been initialised : 
;;;1420            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1421   
;;;1422         /* Abort DMA TX */
;;;1423         if(HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
00005e  f7fffffe          BL       HAL_DMA_Abort_IT
000062  2800              CMP      r0,#0
000064  d002              BEQ      |L18.108|
;;;1424         {
;;;1425           huart->hdmatx->XferAbortCallback = NULL;
000066  6e20              LDR      r0,[r4,#0x60]
000068  63c5              STR      r5,[r0,#0x3c]
00006a  e000              B        |L18.110|
                  |L18.108|
;;;1426         }
;;;1427         else
;;;1428         {
;;;1429           abortcplt = 0;
00006c  2600              MOVS     r6,#0
                  |L18.110|
;;;1430         }
;;;1431       }
;;;1432     }
;;;1433   
;;;1434     /* Disable the UART DMA Rx request if enabled */
;;;1435     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
00006e  6820              LDR      r0,[r4,#0]
000070  6881              LDR      r1,[r0,#8]
000072  0649              LSLS     r1,r1,#25
000074  d50d              BPL      |L18.146|
;;;1436     {
;;;1437       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000076  6881              LDR      r1,[r0,#8]
000078  2240              MOVS     r2,#0x40
00007a  4391              BICS     r1,r1,r2
00007c  6081              STR      r1,[r0,#8]
;;;1438   
;;;1439       /* Abort the UART DMA Rx channel : use non blocking DMA Abort API (callback) */
;;;1440       if(huart->hdmarx != NULL)
00007e  6e60              LDR      r0,[r4,#0x64]
000080  2800              CMP      r0,#0
000082  d006              BEQ      |L18.146|
;;;1441       {
;;;1442         /* UART Rx DMA Abort callback has already been initialised : 
;;;1443            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1444   
;;;1445         /* Abort DMA RX */
;;;1446         if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
000084  f7fffffe          BL       HAL_DMA_Abort_IT
000088  2800              CMP      r0,#0
00008a  d012              BEQ      |L18.178|
;;;1447         {
;;;1448           huart->hdmarx->XferAbortCallback = NULL;
00008c  6e60              LDR      r0,[r4,#0x64]
;;;1449           abortcplt = 1;
00008e  63c5              STR      r5,[r0,#0x3c]
000090  e001              B        |L18.150|
                  |L18.146|
;;;1450         }
;;;1451         else
;;;1452         {
;;;1453           abortcplt = 0;
;;;1454         }
;;;1455       }
;;;1456     }
;;;1457   
;;;1458     /* if no DMA abort complete callback execution is required => call user Abort Complete callback */
;;;1459     if (abortcplt == 1)
000092  2e00              CMP      r6,#0
000094  d00d              BEQ      |L18.178|
                  |L18.150|
;;;1460     {
;;;1461       /* Reset Tx and Rx transfer counters */
;;;1462       huart->TxXferCount = 0; 
000096  4620              MOV      r0,r4
000098  3040              ADDS     r0,r0,#0x40
00009a  8245              STRH     r5,[r0,#0x12]
;;;1463       huart->RxXferCount = 0;
00009c  8345              STRH     r5,[r0,#0x1a]
;;;1464   
;;;1465       /* Reset errorCode */
;;;1466       huart->ErrorCode = HAL_UART_ERROR_NONE;
00009e  6765              STR      r5,[r4,#0x74]
;;;1467   
;;;1468       /* Clear the Error flags in the ICR register */
;;;1469       __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
0000a0  6821              LDR      r1,[r4,#0]
0000a2  200f              MOVS     r0,#0xf
0000a4  6208              STR      r0,[r1,#0x20]
;;;1470   
;;;1471       /* Restore huart->gState and huart->RxState to Ready */
;;;1472       huart->gState  = HAL_UART_STATE_READY;
0000a6  2020              MOVS     r0,#0x20
0000a8  66e0              STR      r0,[r4,#0x6c]
;;;1473       huart->RxState = HAL_UART_STATE_READY;
0000aa  6720              STR      r0,[r4,#0x70]
;;;1474   
;;;1475       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1476       HAL_UART_AbortCpltCallback(huart);
0000ac  4620              MOV      r0,r4
0000ae  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L18.178|
;;;1477     }
;;;1478   
;;;1479     return HAL_OK;
0000b2  2000              MOVS     r0,#0
;;;1480   }
0000b4  bd70              POP      {r4-r6,pc}
;;;1481   
                          ENDP

0000b6  0000              DCW      0x0000
                  |L18.184|
                          DCD      UART_DMATxAbortCallback
                  |L18.188|
                          DCD      UART_DMARxAbortCallback

                          AREA ||i.HAL_UART_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAPause PROC
;;;1092     */
;;;1093   HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
000000  6e81              LDR      r1,[r0,#0x68]
;;;1094   {
;;;1095     /* Process Locked */
;;;1096     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  d005              BEQ      |L19.18|
000006  2101              MOVS     r1,#1
;;;1097   
;;;1098     if ((huart->gState == HAL_UART_STATE_BUSY_TX) &&
000008  6681              STR      r1,[r0,#0x68]
00000a  6ec1              LDR      r1,[r0,#0x6c]
00000c  2921              CMP      r1,#0x21
00000e  d002              BEQ      |L19.22|
000010  e009              B        |L19.38|
                  |L19.18|
000012  2002              MOVS     r0,#2                 ;1096
;;;1099         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)))
;;;1100     {
;;;1101       /* Disable the UART DMA Tx request */
;;;1102       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1103     }
;;;1104     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) &&
;;;1105         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
;;;1106     {
;;;1107       /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1108       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1109       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1110   
;;;1111       /* Disable the UART DMA Rx request */
;;;1112       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1113     }
;;;1114   
;;;1115     /* Process Unlocked */
;;;1116     __HAL_UNLOCK(huart);
;;;1117   
;;;1118     return HAL_OK;
;;;1119   }
000014  4770              BX       lr
                  |L19.22|
000016  6801              LDR      r1,[r0,#0]            ;1098
000018  688a              LDR      r2,[r1,#8]            ;1098
00001a  0612              LSLS     r2,r2,#24             ;1098
00001c  d503              BPL      |L19.38|
00001e  688a              LDR      r2,[r1,#8]            ;1102
000020  2380              MOVS     r3,#0x80              ;1102
000022  439a              BICS     r2,r2,r3              ;1102
000024  608a              STR      r2,[r1,#8]            ;1102
                  |L19.38|
000026  6f01              LDR      r1,[r0,#0x70]         ;1104
000028  2922              CMP      r1,#0x22              ;1104
00002a  d112              BNE      |L19.82|
00002c  6801              LDR      r1,[r0,#0]            ;1104
00002e  688a              LDR      r2,[r1,#8]            ;1104
000030  0652              LSLS     r2,r2,#25             ;1104
000032  d50e              BPL      |L19.82|
000034  680a              LDR      r2,[r1,#0]            ;1108
000036  23ff              MOVS     r3,#0xff              ;1108
000038  3301              ADDS     r3,#1                 ;1108
00003a  439a              BICS     r2,r2,r3              ;1108
00003c  600a              STR      r2,[r1,#0]            ;1108
00003e  6801              LDR      r1,[r0,#0]            ;1109
000040  688a              LDR      r2,[r1,#8]            ;1109
000042  0852              LSRS     r2,r2,#1              ;1109
000044  0052              LSLS     r2,r2,#1              ;1109
000046  608a              STR      r2,[r1,#8]            ;1109
000048  6801              LDR      r1,[r0,#0]            ;1112
00004a  688a              LDR      r2,[r1,#8]            ;1112
00004c  2340              MOVS     r3,#0x40              ;1112
00004e  439a              BICS     r2,r2,r3              ;1112
000050  608a              STR      r2,[r1,#8]            ;1112
                  |L19.82|
000052  2100              MOVS     r1,#0                 ;1116
000054  6681              STR      r1,[r0,#0x68]         ;1118
000056  4608              MOV      r0,r1                 ;1118
000058  4770              BX       lr
;;;1120   
                          ENDP


                          AREA ||i.HAL_UART_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAResume PROC
;;;1125     */
;;;1126   HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
000000  b410              PUSH     {r4}
;;;1127   {
;;;1128     /* Process Locked */
;;;1129     __HAL_LOCK(huart);
000002  6e81              LDR      r1,[r0,#0x68]
000004  2901              CMP      r1,#1
000006  d005              BEQ      |L20.20|
000008  2101              MOVS     r1,#1
;;;1130   
;;;1131     if(huart->gState == HAL_UART_STATE_BUSY_TX)
00000a  6681              STR      r1,[r0,#0x68]
00000c  6ec2              LDR      r2,[r0,#0x6c]
00000e  2a21              CMP      r2,#0x21
000010  d003              BEQ      |L20.26|
000012  e007              B        |L20.36|
                  |L20.20|
;;;1132     {
;;;1133       /* Enable the UART DMA Tx request */
;;;1134       SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1135     }
;;;1136     if(huart->RxState == HAL_UART_STATE_BUSY_RX)
;;;1137     {
;;;1138       /* Clear the Overrun flag before resuming the Rx transfer */
;;;1139       __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
;;;1140   
;;;1141       /* Reenable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1142       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1143       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1144   
;;;1145       /* Enable the UART DMA Rx request */
;;;1146       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1147     }
;;;1148   
;;;1149     /* Process Unlocked */
;;;1150     __HAL_UNLOCK(huart);
;;;1151   
;;;1152     return HAL_OK;
;;;1153   }
000014  bc10              POP      {r4}
000016  2002              MOVS     r0,#2                 ;1129
000018  4770              BX       lr
                  |L20.26|
00001a  6802              LDR      r2,[r0,#0]            ;1134
00001c  6893              LDR      r3,[r2,#8]            ;1134
00001e  2480              MOVS     r4,#0x80              ;1134
000020  4323              ORRS     r3,r3,r4              ;1134
000022  6093              STR      r3,[r2,#8]            ;1134
                  |L20.36|
000024  6f02              LDR      r2,[r0,#0x70]         ;1136
000026  2a22              CMP      r2,#0x22              ;1136
000028  d111              BNE      |L20.78|
00002a  6803              LDR      r3,[r0,#0]            ;1139
00002c  2208              MOVS     r2,#8                 ;1139
00002e  621a              STR      r2,[r3,#0x20]         ;1139
000030  6802              LDR      r2,[r0,#0]            ;1142
000032  6813              LDR      r3,[r2,#0]            ;1142
000034  24ff              MOVS     r4,#0xff              ;1142
000036  3401              ADDS     r4,#1                 ;1142
000038  4323              ORRS     r3,r3,r4              ;1142
00003a  6013              STR      r3,[r2,#0]            ;1142
00003c  6802              LDR      r2,[r0,#0]            ;1143
00003e  6893              LDR      r3,[r2,#8]            ;1143
000040  430b              ORRS     r3,r3,r1              ;1143
000042  6093              STR      r3,[r2,#8]            ;1143
000044  6801              LDR      r1,[r0,#0]            ;1146
000046  688a              LDR      r2,[r1,#8]            ;1146
000048  2340              MOVS     r3,#0x40              ;1146
00004a  431a              ORRS     r2,r2,r3              ;1146
00004c  608a              STR      r2,[r1,#8]            ;1146
                  |L20.78|
00004e  2100              MOVS     r1,#0                 ;1150
000050  6681              STR      r1,[r0,#0x68]         ;1152
000052  bc10              POP      {r4}
000054  4608              MOV      r0,r1                 ;1152
000056  4770              BX       lr
;;;1154   
                          ENDP


                          AREA ||i.HAL_UART_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAStop PROC
;;;1159     */
;;;1160   HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1161   {
000002  4604              MOV      r4,r0
;;;1162     /* The Lock is not implemented on this API to allow the user application
;;;1163        to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback() /
;;;1164        HAL_UART_TxHalfCpltCallback / HAL_UART_RxHalfCpltCallback: 
;;;1165        indeed, when HAL_DMA_Abort() API is called, the DMA TX/RX Transfer or Half Transfer complete  
;;;1166        interrupt is generated if the DMA transfer interruption occurs at the middle or at the end of 
;;;1167        the stream and the corresponding call back is executed. */
;;;1168   
;;;1169     /* Stop UART DMA Tx request if ongoing */
;;;1170     if ((huart->gState == HAL_UART_STATE_BUSY_TX) &&
000004  6ec0              LDR      r0,[r0,#0x6c]
000006  2520              MOVS     r5,#0x20
000008  2821              CMP      r0,#0x21
00000a  d112              BNE      |L21.50|
;;;1171         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)))
00000c  6820              LDR      r0,[r4,#0]
00000e  6881              LDR      r1,[r0,#8]
000010  0609              LSLS     r1,r1,#24
000012  d50e              BPL      |L21.50|
;;;1172     {
;;;1173       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000014  6881              LDR      r1,[r0,#8]
000016  2280              MOVS     r2,#0x80
000018  4391              BICS     r1,r1,r2
00001a  6081              STR      r1,[r0,#8]
;;;1174   
;;;1175       /* Abort the UART DMA Tx channel */
;;;1176       if(huart->hdmatx != NULL)
00001c  6e20              LDR      r0,[r4,#0x60]
00001e  2800              CMP      r0,#0
000020  d001              BEQ      |L21.38|
;;;1177       {
;;;1178         HAL_DMA_Abort(huart->hdmatx);
000022  f7fffffe          BL       HAL_DMA_Abort
                  |L21.38|
000026  6820              LDR      r0,[r4,#0]
000028  6801              LDR      r1,[r0,#0]
00002a  22c0              MOVS     r2,#0xc0
00002c  4391              BICS     r1,r1,r2
00002e  6001              STR      r1,[r0,#0]
000030  66e5              STR      r5,[r4,#0x6c]
                  |L21.50|
;;;1179       }
;;;1180   
;;;1181       UART_EndTxTransfer(huart);
;;;1182     }
;;;1183   
;;;1184     /* Stop UART DMA Rx request if ongoing */
;;;1185     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) &&
000032  6f20              LDR      r0,[r4,#0x70]
000034  2822              CMP      r0,#0x22
000036  d118              BNE      |L21.106|
;;;1186         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
000038  6820              LDR      r0,[r4,#0]
00003a  6881              LDR      r1,[r0,#8]
00003c  0649              LSLS     r1,r1,#25
00003e  d514              BPL      |L21.106|
;;;1187     {
;;;1188       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000040  6881              LDR      r1,[r0,#8]
000042  2240              MOVS     r2,#0x40
000044  4391              BICS     r1,r1,r2
000046  6081              STR      r1,[r0,#8]
;;;1189   
;;;1190       /* Abort the UART DMA Rx channel */
;;;1191       if(huart->hdmarx != NULL)
000048  6e60              LDR      r0,[r4,#0x64]
00004a  2800              CMP      r0,#0
00004c  d001              BEQ      |L21.82|
;;;1192       {
;;;1193         HAL_DMA_Abort(huart->hdmarx);
00004e  f7fffffe          BL       HAL_DMA_Abort
                  |L21.82|
000052  6820              LDR      r0,[r4,#0]
000054  6801              LDR      r1,[r0,#0]
000056  22ff              MOVS     r2,#0xff
000058  3221              ADDS     r2,r2,#0x21
00005a  4391              BICS     r1,r1,r2
00005c  6001              STR      r1,[r0,#0]
00005e  6820              LDR      r0,[r4,#0]
000060  6881              LDR      r1,[r0,#8]
000062  0849              LSRS     r1,r1,#1
000064  0049              LSLS     r1,r1,#1
000066  6081              STR      r1,[r0,#8]
000068  6725              STR      r5,[r4,#0x70]
                  |L21.106|
;;;1194       }
;;;1195   
;;;1196       UART_EndRxTransfer(huart);
;;;1197     }
;;;1198   
;;;1199     return HAL_OK;
00006a  2000              MOVS     r0,#0
;;;1200   }
00006c  bd70              POP      {r4-r6,pc}
;;;1201   
                          ENDP


                          AREA ||i.HAL_UART_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_DeInit PROC
;;;501      */
;;;502    HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
000000  2800              CMP      r0,#0
;;;503    {
;;;504      /* Check the UART handle allocation */
;;;505      if(huart == NULL)
000002  d101              BNE      |L22.8|
;;;506      {
;;;507        return HAL_ERROR;
000004  2001              MOVS     r0,#1
;;;508      }
;;;509    
;;;510      /* Check the parameters */
;;;511      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;512    
;;;513      huart->gState = HAL_UART_STATE_BUSY;
;;;514    
;;;515      /* Disable the Peripheral */
;;;516      __HAL_UART_DISABLE(huart);
;;;517    
;;;518      huart->Instance->CR1 = 0x0U;
;;;519      huart->Instance->CR2 = 0x0U;
;;;520      huart->Instance->CR3 = 0x0U;
;;;521    
;;;522      /* DeInit the low level hardware */
;;;523      HAL_UART_MspDeInit(huart);
;;;524    
;;;525      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;526      huart->gState    = HAL_UART_STATE_RESET;
;;;527      huart->RxState   = HAL_UART_STATE_RESET;
;;;528    
;;;529      /* Process Unlock */
;;;530      __HAL_UNLOCK(huart);
;;;531    
;;;532      return HAL_OK;
;;;533    }
000006  4770              BX       lr
                  |L22.8|
000008  b570              PUSH     {r4-r6,lr}            ;503
00000a  4604              MOV      r4,r0                 ;503
00000c  2024              MOVS     r0,#0x24              ;513
00000e  66e0              STR      r0,[r4,#0x6c]         ;513
000010  6820              LDR      r0,[r4,#0]            ;516
000012  6801              LDR      r1,[r0,#0]            ;516
000014  0849              LSRS     r1,r1,#1              ;516
000016  0049              LSLS     r1,r1,#1              ;516
000018  6001              STR      r1,[r0,#0]            ;516
00001a  6820              LDR      r0,[r4,#0]            ;518
00001c  2500              MOVS     r5,#0                 ;518
00001e  6005              STR      r5,[r0,#0]            ;518
000020  6820              LDR      r0,[r4,#0]            ;519
000022  6045              STR      r5,[r0,#4]            ;519
000024  6820              LDR      r0,[r4,#0]            ;520
000026  6085              STR      r5,[r0,#8]            ;520
000028  4620              MOV      r0,r4                 ;523
00002a  f7fffffe          BL       HAL_UART_MspDeInit
00002e  6765              STR      r5,[r4,#0x74]         ;525
000030  66e5              STR      r5,[r4,#0x6c]         ;526
000032  6725              STR      r5,[r4,#0x70]         ;527
000034  2000              MOVS     r0,#0                 ;532
000036  66a5              STR      r5,[r4,#0x68]         ;532
000038  bd70              POP      {r4-r6,pc}
;;;534    
                          ENDP


                          AREA ||i.HAL_UART_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_ErrorCallback PROC
;;;1835     */
;;;1836   __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1837   {
;;;1838     /* Prevent unused argument(s) compilation warning */
;;;1839     UNUSED(huart);
;;;1840   
;;;1841     /* NOTE : This function should not be modified, when the callback is needed,
;;;1842               the HAL_UART_ErrorCallback can be implemented in the user file.
;;;1843      */
;;;1844   }
;;;1845   
                          ENDP


                          AREA ||i.HAL_UART_GetError||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetError PROC
;;;2085   */
;;;2086   uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
000000  6f40              LDR      r0,[r0,#0x74]
;;;2087   {
;;;2088     return huart->ErrorCode;
;;;2089   }
000002  4770              BX       lr
;;;2090   /**
                          ENDP


                          AREA ||i.HAL_UART_GetState||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetState PROC
;;;2070     */
;;;2071   HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2072   {
;;;2073     uint32_t temp1= 0x00U, temp2 = 0x00U;
;;;2074     temp1 = huart->gState;
000002  6ec0              LDR      r0,[r0,#0x6c]
;;;2075     temp2 = huart->RxState;
000004  6f09              LDR      r1,[r1,#0x70]
;;;2076   
;;;2077     return (HAL_UART_StateTypeDef)(temp1 | temp2);
000006  4308              ORRS     r0,r0,r1
;;;2078   }
000008  4770              BX       lr
;;;2079   
                          ENDP


                          AREA ||i.HAL_UART_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_UART_IRQHandler PROC
;;;1623     */
;;;1624   void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1625   {
;;;1626     uint32_t isrflags   = READ_REG(huart->Instance->ISR);
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0                 ;1625
000006  69d0              LDR      r0,[r2,#0x1c]
;;;1627     uint32_t cr1its     = READ_REG(huart->Instance->CR1);
000008  6813              LDR      r3,[r2,#0]
;;;1628     uint32_t cr3its;
;;;1629     uint32_t errorflags;
;;;1630   
;;;1631     /* If no error occurs */
;;;1632     errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE));
00000a  0705              LSLS     r5,r0,#28
00000c  27ff              MOVS     r7,#0xff
00000e  4621              MOV      r1,r4
000010  0f2d              LSRS     r5,r5,#28
000012  3721              ADDS     r7,r7,#0x21
000014  3140              ADDS     r1,r1,#0x40
;;;1633     if (errorflags == RESET)
000016  2d00              CMP      r5,#0
000018  d06d              BEQ      |L26.246|
;;;1634     {
;;;1635       /* UART in mode Receiver ---------------------------------------------------*/
;;;1636       if(((isrflags & USART_ISR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
;;;1637       {
;;;1638         UART_Receive_IT(huart);
;;;1639         return;
;;;1640       }
;;;1641     }  
;;;1642   
;;;1643     /* If some errors occur */
;;;1644     cr3its = READ_REG(huart->Instance->CR3);
00001a  6895              LDR      r5,[r2,#8]
;;;1645     if(   (errorflags != RESET)
;;;1646        && (   ((cr3its & USART_CR3_EIE) != RESET)
00001c  401f              ANDS     r7,r7,r3
00001e  07ee              LSLS     r6,r5,#31
000020  0ff6              LSRS     r6,r6,#31
000022  4337              ORRS     r7,r7,r6
000024  d076              BEQ      |L26.276|
;;;1647            || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)) )
;;;1648     {
;;;1649       /* UART parity error interrupt occurred -------------------------------------*/
;;;1650       if(((isrflags & USART_ISR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
000026  07c7              LSLS     r7,r0,#31
000028  d006              BEQ      |L26.56|
00002a  05df              LSLS     r7,r3,#23
00002c  d504              BPL      |L26.56|
;;;1651       {
;;;1652         __HAL_UART_CLEAR_IT(huart, UART_CLEAR_PEF);
00002e  2701              MOVS     r7,#1
000030  6217              STR      r7,[r2,#0x20]
;;;1653   
;;;1654         huart->ErrorCode |= HAL_UART_ERROR_PE;
000032  6f62              LDR      r2,[r4,#0x74]
000034  433a              ORRS     r2,r2,r7
000036  6762              STR      r2,[r4,#0x74]
                  |L26.56|
;;;1655       }
;;;1656   
;;;1657       /* UART frame error interrupt occurred --------------------------------------*/
;;;1658       if(((isrflags & USART_ISR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
000038  0782              LSLS     r2,r0,#30
00003a  d508              BPL      |L26.78|
00003c  07ea              LSLS     r2,r5,#31
00003e  d006              BEQ      |L26.78|
;;;1659       {
;;;1660         __HAL_UART_CLEAR_IT(huart, UART_CLEAR_FEF);
000040  6827              LDR      r7,[r4,#0]
000042  2202              MOVS     r2,#2
000044  623a              STR      r2,[r7,#0x20]
;;;1661   
;;;1662         huart->ErrorCode |= HAL_UART_ERROR_FE;
000046  6f62              LDR      r2,[r4,#0x74]
000048  2704              MOVS     r7,#4
00004a  433a              ORRS     r2,r2,r7
00004c  6762              STR      r2,[r4,#0x74]
                  |L26.78|
;;;1663       }
;;;1664   
;;;1665       /* UART noise error interrupt occurred --------------------------------------*/
;;;1666       if(((isrflags & USART_ISR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
00004e  0742              LSLS     r2,r0,#29
000050  d508              BPL      |L26.100|
000052  07ea              LSLS     r2,r5,#31
000054  d006              BEQ      |L26.100|
;;;1667       {
;;;1668         __HAL_UART_CLEAR_IT(huart, UART_CLEAR_NEF);
000056  6825              LDR      r5,[r4,#0]
000058  2204              MOVS     r2,#4
00005a  622a              STR      r2,[r5,#0x20]
;;;1669   
;;;1670         huart->ErrorCode |= HAL_UART_ERROR_NE;
00005c  6f62              LDR      r2,[r4,#0x74]
00005e  2502              MOVS     r5,#2
000060  432a              ORRS     r2,r2,r5
000062  6762              STR      r2,[r4,#0x74]
                  |L26.100|
;;;1671       }
;;;1672       
;;;1673       /* UART Over-Run interrupt occurred -----------------------------------------*/
;;;1674       if(((isrflags & USART_ISR_ORE) != RESET) &&
000064  0702              LSLS     r2,r0,#28
000066  d50a              BPL      |L26.126|
;;;1675          (((cr1its & USART_CR1_RXNEIE) != RESET) || ((cr3its & USART_CR3_EIE) != RESET)))
000068  461a              MOV      r2,r3
00006a  2520              MOVS     r5,#0x20
00006c  402a              ANDS     r2,r2,r5
00006e  4332              ORRS     r2,r2,r6
000070  d005              BEQ      |L26.126|
;;;1676       {
;;;1677         __HAL_UART_CLEAR_IT(huart, UART_CLEAR_OREF);
000072  6825              LDR      r5,[r4,#0]
000074  2208              MOVS     r2,#8
000076  622a              STR      r2,[r5,#0x20]
;;;1678   
;;;1679         huart->ErrorCode |= HAL_UART_ERROR_ORE;
000078  6f65              LDR      r5,[r4,#0x74]
00007a  4315              ORRS     r5,r5,r2
00007c  6765              STR      r5,[r4,#0x74]
                  |L26.126|
;;;1680       }
;;;1681   
;;;1682       /* Call UART Error Call back function if need be --------------------------*/
;;;1683       if(huart->ErrorCode != HAL_UART_ERROR_NONE)
00007e  6f62              LDR      r2,[r4,#0x74]
000080  2a00              CMP      r2,#0
000082  d037              BEQ      |L26.244|
;;;1684       {
;;;1685         /* UART in mode Receiver ---------------------------------------------------*/
;;;1686         if(((isrflags & USART_ISR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
000084  0680              LSLS     r0,r0,#26
000086  d50c              BPL      |L26.162|
000088  0698              LSLS     r0,r3,#26
00008a  d50a              BPL      |L26.162|
;;;1687         {
;;;1688           UART_Receive_IT(huart);
00008c  460a              MOV      r2,r1
00008e  8b8b              LDRH     r3,[r1,#0x1c]
000090  6f21              LDR      r1,[r4,#0x70]
000092  4620              MOV      r0,r4
000094  2922              CMP      r1,#0x22
000096  d079              BEQ      |L26.396|
000098  6820              LDR      r0,[r4,#0]
00009a  6981              LDR      r1,[r0,#0x18]
00009c  2208              MOVS     r2,#8
00009e  4311              ORRS     r1,r1,r2
0000a0  6181              STR      r1,[r0,#0x18]
                  |L26.162|
;;;1689         }
;;;1690   
;;;1691         /* If Overrun error occurs, or if any error occurs in DMA mode reception,
;;;1692            consider error as blocking */
;;;1693         if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) ||
0000a2  6f60              LDR      r0,[r4,#0x74]
0000a4  0700              LSLS     r0,r0,#28
0000a6  d403              BMI      |L26.176|
;;;1694             (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
0000a8  6820              LDR      r0,[r4,#0]
0000aa  6880              LDR      r0,[r0,#8]
0000ac  0640              LSLS     r0,r0,#25
0000ae  d56c              BPL      |L26.394|
                  |L26.176|
0000b0  6820              LDR      r0,[r4,#0]
0000b2  6802              LDR      r2,[r0,#0]
0000b4  21ff              MOVS     r1,#0xff
0000b6  3121              ADDS     r1,r1,#0x21
0000b8  438a              BICS     r2,r2,r1
0000ba  6002              STR      r2,[r0,#0]
0000bc  6820              LDR      r0,[r4,#0]
0000be  6881              LDR      r1,[r0,#8]
0000c0  0849              LSRS     r1,r1,#1
0000c2  0049              LSLS     r1,r1,#1
0000c4  6081              STR      r1,[r0,#8]
0000c6  2020              MOVS     r0,#0x20
0000c8  6720              STR      r0,[r4,#0x70]
;;;1695         {  
;;;1696           /* Blocking error : transfer is aborted
;;;1697              Set the UART state ready to be able to start again the process,
;;;1698              Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
;;;1699           UART_EndRxTransfer(huart);
;;;1700   
;;;1701           /* Disable the UART DMA Rx request if enabled */
;;;1702           if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
0000ca  6820              LDR      r0,[r4,#0]
0000cc  6881              LDR      r1,[r0,#8]
0000ce  0649              LSLS     r1,r1,#25
0000d0  d573              BPL      |L26.442|
;;;1703           {
;;;1704             CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
0000d2  6882              LDR      r2,[r0,#8]
0000d4  2140              MOVS     r1,#0x40
0000d6  438a              BICS     r2,r2,r1
0000d8  6082              STR      r2,[r0,#8]
;;;1705   
;;;1706             /* Abort the UART DMA Rx channel */
;;;1707             if(huart->hdmarx != NULL)
0000da  6e60              LDR      r0,[r4,#0x64]
0000dc  2800              CMP      r0,#0
0000de  d06c              BEQ      |L26.442|
;;;1708             {
;;;1709               /* Set the UART DMA Abort callback : 
;;;1710                  will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
;;;1711               huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
0000e0  4965              LDR      r1,|L26.632|
;;;1712   
;;;1713               /* Abort DMA RX */
;;;1714               if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
0000e2  63c1              STR      r1,[r0,#0x3c]
0000e4  6e60              LDR      r0,[r4,#0x64]
0000e6  f7fffffe          BL       HAL_DMA_Abort_IT
0000ea  2800              CMP      r0,#0
0000ec  d002              BEQ      |L26.244|
;;;1715               {
;;;1716                 /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
;;;1717                 huart->hdmarx->XferAbortCallback(huart->hdmarx);
0000ee  6e60              LDR      r0,[r4,#0x64]
0000f0  6bc1              LDR      r1,[r0,#0x3c]
0000f2  4788              BLX      r1
                  |L26.244|
;;;1718               }
;;;1719             }
;;;1720             else
;;;1721             {
;;;1722               /* Call user error callback */
;;;1723               HAL_UART_ErrorCallback(huart);
;;;1724             }
;;;1725           }
;;;1726           else
;;;1727           {
;;;1728             /* Call user error callback */
;;;1729             HAL_UART_ErrorCallback(huart);
;;;1730           }
;;;1731         }
;;;1732         else
;;;1733         {
;;;1734           /* Non Blocking error : transfer could go on. 
;;;1735              Error is notified to user through user error callback */
;;;1736           HAL_UART_ErrorCallback(huart);
;;;1737           huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1738         }
;;;1739       }
;;;1740       return;
;;;1741   
;;;1742     } /* End if some error occurs */
;;;1743   
;;;1744     /* UART wakeup from Stop mode interrupt occurred ---------------------------*/
;;;1745     if(((isrflags & USART_ISR_WUF) != RESET) && ((cr3its & USART_CR3_WUFIE) != RESET))
;;;1746     {
;;;1747       __HAL_UART_CLEAR_IT(huart, UART_CLEAR_WUF);
;;;1748       /* Set the UART state ready to be able to start again the process */
;;;1749       huart->gState  = HAL_UART_STATE_READY;
;;;1750       huart->RxState = HAL_UART_STATE_READY;
;;;1751       HAL_UARTEx_WakeupCallback(huart);
;;;1752       return;
;;;1753     }
;;;1754   
;;;1755     /* UART in mode Transmitter ------------------------------------------------*/
;;;1756     if(((isrflags & USART_ISR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
;;;1757     {
;;;1758       UART_Transmit_IT(huart);
;;;1759       return;
;;;1760     }
;;;1761   
;;;1762     /* UART in mode Transmitter (transmission end) -----------------------------*/
;;;1763     if(((isrflags & USART_ISR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
;;;1764     {
;;;1765       UART_EndTransmit_IT(huart);
;;;1766       return;
;;;1767     }
;;;1768   
;;;1769   }
0000f4  bdf8              POP      {r3-r7,pc}
                  |L26.246|
0000f6  0685              LSLS     r5,r0,#26             ;1636
0000f8  d537              BPL      |L26.362|
0000fa  069d              LSLS     r5,r3,#26             ;1636
0000fc  d535              BPL      |L26.362|
0000fe  460b              MOV      r3,r1                 ;1638
000100  8b8d              LDRH     r5,[r1,#0x1c]         ;1638
000102  6f21              LDR      r1,[r4,#0x70]         ;1638
000104  4620              MOV      r0,r4                 ;1638
000106  2922              CMP      r1,#0x22              ;1638
000108  d005              BEQ      |L26.278|
00010a  6990              LDR      r0,[r2,#0x18]         ;1638
00010c  2108              MOVS     r1,#8                 ;1638
00010e  4308              ORRS     r0,r0,r1              ;1638
000110  6190              STR      r0,[r2,#0x18]         ;1638
                  |L26.274|
000112  bdf8              POP      {r3-r7,pc}
                  |L26.276|
000114  e02a              B        |L26.364|
                  |L26.278|
000116  6a51              LDR      r1,[r2,#0x24]
000118  2201              MOVS     r2,#1
00011a  6884              LDR      r4,[r0,#8]
00011c  0312              LSLS     r2,r2,#12
00011e  b289              UXTH     r1,r1
000120  4294              CMP      r4,r2
000122  d102              BNE      |L26.298|
000124  6902              LDR      r2,[r0,#0x10]
000126  2a00              CMP      r2,#0
000128  d018              BEQ      |L26.348|
                  |L26.298|
00012a  6d42              LDR      r2,[r0,#0x54]
00012c  4029              ANDS     r1,r1,r5
00012e  1c54              ADDS     r4,r2,#1
000130  6544              STR      r4,[r0,#0x54]
000132  7011              STRB     r1,[r2,#0]
                  |L26.308|
000134  8b59              LDRH     r1,[r3,#0x1a]
000136  1e49              SUBS     r1,r1,#1
000138  0409              LSLS     r1,r1,#16
00013a  0c09              LSRS     r1,r1,#16
00013c  8359              STRH     r1,[r3,#0x1a]
00013e  d1e8              BNE      |L26.274|
000140  6801              LDR      r1,[r0,#0]
000142  680b              LDR      r3,[r1,#0]
000144  43bb              BICS     r3,r3,r7
000146  600b              STR      r3,[r1,#0]
000148  6801              LDR      r1,[r0,#0]
00014a  688a              LDR      r2,[r1,#8]
00014c  0852              LSRS     r2,r2,#1
00014e  0052              LSLS     r2,r2,#1
000150  608a              STR      r2,[r1,#8]
000152  2120              MOVS     r1,#0x20
000154  6701              STR      r1,[r0,#0x70]
000156  f7fffffe          BL       HAL_UART_RxCpltCallback
00015a  bdf8              POP      {r3-r7,pc}
                  |L26.348|
00015c  6d42              LDR      r2,[r0,#0x54]
00015e  4029              ANDS     r1,r1,r5
000160  8011              STRH     r1,[r2,#0]
000162  6d41              LDR      r1,[r0,#0x54]
000164  1c89              ADDS     r1,r1,#2
000166  6541              STR      r1,[r0,#0x54]
000168  e7e4              B        |L26.308|
                  |L26.362|
00016a  6895              LDR      r5,[r2,#8]            ;1644
                  |L26.364|
00016c  02c6              LSLS     r6,r0,#11             ;1745
00016e  d546              BPL      |L26.510|
000170  026d              LSLS     r5,r5,#9              ;1745
000172  d544              BPL      |L26.510|
000174  2001              MOVS     r0,#1                 ;1747
000176  0500              LSLS     r0,r0,#20             ;1747
000178  6210              STR      r0,[r2,#0x20]         ;1747
00017a  2020              MOVS     r0,#0x20              ;1749
00017c  66e0              STR      r0,[r4,#0x6c]         ;1749
00017e  6720              STR      r0,[r4,#0x70]         ;1750
000180  4620              MOV      r0,r4                 ;1751
000182  f7fffffe          BL       HAL_UARTEx_WakeupCallback
000186  bdf8              POP      {r3-r7,pc}
000188  e000              B        |L26.396|
                  |L26.394|
00018a  e032              B        |L26.498|
                  |L26.396|
00018c  6801              LDR      r1,[r0,#0]
00018e  6a49              LDR      r1,[r1,#0x24]
000190  2501              MOVS     r5,#1
000192  6886              LDR      r6,[r0,#8]
000194  032d              LSLS     r5,r5,#12
000196  b289              UXTH     r1,r1
000198  42ae              CMP      r6,r5
00019a  d102              BNE      |L26.418|
00019c  6905              LDR      r5,[r0,#0x10]
00019e  2d00              CMP      r5,#0
0001a0  d01c              BEQ      |L26.476|
                  |L26.418|
0001a2  4019              ANDS     r1,r1,r3
0001a4  6d43              LDR      r3,[r0,#0x54]
0001a6  1c5d              ADDS     r5,r3,#1
0001a8  6545              STR      r5,[r0,#0x54]
0001aa  7019              STRB     r1,[r3,#0]
                  |L26.428|
0001ac  8b51              LDRH     r1,[r2,#0x1a]
0001ae  1e49              SUBS     r1,r1,#1
0001b0  0409              LSLS     r1,r1,#16
0001b2  0c09              LSRS     r1,r1,#16
0001b4  8351              STRH     r1,[r2,#0x1a]
0001b6  d001              BEQ      |L26.444|
0001b8  e773              B        |L26.162|
                  |L26.442|
0001ba  e016              B        |L26.490|
                  |L26.444|
0001bc  6801              LDR      r1,[r0,#0]
0001be  680a              LDR      r2,[r1,#0]
0001c0  23ff              MOVS     r3,#0xff
0001c2  3321              ADDS     r3,r3,#0x21
0001c4  439a              BICS     r2,r2,r3
0001c6  600a              STR      r2,[r1,#0]
0001c8  6801              LDR      r1,[r0,#0]
0001ca  688a              LDR      r2,[r1,#8]
0001cc  0852              LSRS     r2,r2,#1
0001ce  0052              LSLS     r2,r2,#1
0001d0  608a              STR      r2,[r1,#8]
0001d2  2120              MOVS     r1,#0x20
0001d4  6701              STR      r1,[r0,#0x70]
0001d6  f7fffffe          BL       HAL_UART_RxCpltCallback
0001da  e762              B        |L26.162|
                  |L26.476|
0001dc  6d45              LDR      r5,[r0,#0x54]
0001de  4019              ANDS     r1,r1,r3
0001e0  8029              STRH     r1,[r5,#0]
0001e2  6d41              LDR      r1,[r0,#0x54]
0001e4  1c89              ADDS     r1,r1,#2
0001e6  6541              STR      r1,[r0,#0x54]
0001e8  e7e0              B        |L26.428|
                  |L26.490|
0001ea  4620              MOV      r0,r4                 ;1729
0001ec  f7fffffe          BL       HAL_UART_ErrorCallback
0001f0  bdf8              POP      {r3-r7,pc}
                  |L26.498|
0001f2  4620              MOV      r0,r4                 ;1736
0001f4  f7fffffe          BL       HAL_UART_ErrorCallback
0001f8  2000              MOVS     r0,#0                 ;1737
0001fa  6760              STR      r0,[r4,#0x74]         ;1737
                  |L26.508|
0001fc  bdf8              POP      {r3-r7,pc}
                  |L26.510|
0001fe  0605              LSLS     r5,r0,#24             ;1756
000200  d52c              BPL      |L26.604|
000202  061d              LSLS     r5,r3,#24             ;1756
000204  d52a              BPL      |L26.604|
000206  6ee0              LDR      r0,[r4,#0x6c]         ;1756
000208  2821              CMP      r0,#0x21              ;1756
00020a  d1f7              BNE      |L26.508|
00020c  8a48              LDRH     r0,[r1,#0x12]         ;1756
00020e  2800              CMP      r0,#0                 ;1756
000210  d011              BEQ      |L26.566|
000212  2001              MOVS     r0,#1                 ;1756
000214  68a3              LDR      r3,[r4,#8]            ;1756
000216  0300              LSLS     r0,r0,#12             ;1756
000218  4283              CMP      r3,r0                 ;1756
00021a  d102              BNE      |L26.546|
00021c  6920              LDR      r0,[r4,#0x10]         ;1756
00021e  2800              CMP      r0,#0                 ;1756
000220  d013              BEQ      |L26.586|
                  |L26.546|
000222  6ce0              LDR      r0,[r4,#0x4c]         ;1756
000224  1c42              ADDS     r2,r0,#1              ;1756
000226  64e2              STR      r2,[r4,#0x4c]         ;1756
000228  6822              LDR      r2,[r4,#0]            ;1756
00022a  7800              LDRB     r0,[r0,#0]            ;1756
00022c  6290              STR      r0,[r2,#0x28]         ;1756
                  |L26.558|
00022e  8a48              LDRH     r0,[r1,#0x12]         ;1756
000230  1e40              SUBS     r0,r0,#1              ;1756
000232  8248              STRH     r0,[r1,#0x12]         ;1756
000234  bdf8              POP      {r3-r7,pc}
                  |L26.566|
000236  6810              LDR      r0,[r2,#0]
000238  2180              MOVS     r1,#0x80
00023a  4388              BICS     r0,r0,r1
00023c  6010              STR      r0,[r2,#0]
00023e  6820              LDR      r0,[r4,#0]
000240  6801              LDR      r1,[r0,#0]
000242  2240              MOVS     r2,#0x40
000244  4311              ORRS     r1,r1,r2
000246  6001              STR      r1,[r0,#0]
                  |L26.584|
000248  bdf8              POP      {r3-r7,pc}
                  |L26.586|
00024a  6ce0              LDR      r0,[r4,#0x4c]
00024c  8800              LDRH     r0,[r0,#0]
00024e  05c0              LSLS     r0,r0,#23
000250  0dc0              LSRS     r0,r0,#23
000252  6290              STR      r0,[r2,#0x28]
000254  6ce0              LDR      r0,[r4,#0x4c]
000256  1c80              ADDS     r0,r0,#2
000258  64e0              STR      r0,[r4,#0x4c]
00025a  e7e8              B        |L26.558|
                  |L26.604|
00025c  0640              LSLS     r0,r0,#25             ;1763
00025e  d5f3              BPL      |L26.584|
000260  0658              LSLS     r0,r3,#25             ;1763
000262  d5f1              BPL      |L26.584|
000264  6813              LDR      r3,[r2,#0]            ;1763
000266  4620              MOV      r0,r4                 ;1765
000268  2140              MOVS     r1,#0x40              ;1765
00026a  438b              BICS     r3,r3,r1              ;1765
00026c  6013              STR      r3,[r2,#0]            ;1765
00026e  2120              MOVS     r1,#0x20              ;1765
000270  66e1              STR      r1,[r4,#0x6c]         ;1765
000272  f7fffffe          BL       HAL_UART_TxCpltCallback
000276  bdf8              POP      {r3-r7,pc}
;;;1770   
                          ENDP

                  |L26.632|
                          DCD      UART_DMAAbortOnError

                          AREA ||i.HAL_UART_Init||, CODE, READONLY, ALIGN=1

                  HAL_UART_Init PROC
;;;224      */
;;;225    HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
000000  2800              CMP      r0,#0
;;;226    {
;;;227      /* Check the UART handle allocation */
;;;228      if(huart == NULL)
000002  d101              BNE      |L27.8|
;;;229      {
;;;230        return HAL_ERROR;
000004  2001              MOVS     r0,#1
;;;231      }
;;;232    
;;;233      if(huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
;;;234      {
;;;235        /* Check the parameters */
;;;236        assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
;;;237      }
;;;238      else
;;;239      {
;;;240        /* Check the parameters */
;;;241        assert_param(IS_UART_INSTANCE(huart->Instance));
;;;242      }
;;;243    
;;;244      if(huart->gState == HAL_UART_STATE_RESET)
;;;245      {
;;;246        /* Allocate lock resource and initialize it */
;;;247        huart->Lock = HAL_UNLOCKED;
;;;248    
;;;249        /* Init the low level hardware : GPIO, CLOCK */
;;;250        HAL_UART_MspInit(huart);
;;;251      }
;;;252    
;;;253      huart->gState = HAL_UART_STATE_BUSY;
;;;254    
;;;255      /* Disable the Peripheral */
;;;256      __HAL_UART_DISABLE(huart);
;;;257    
;;;258      /* Set the UART Communication parameters */
;;;259      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;260      {
;;;261        UART_AdvFeatureConfig(huart);
;;;262      }
;;;263    
;;;264      if (UART_SetConfig(huart) == HAL_ERROR)
;;;265      {
;;;266        return HAL_ERROR;
;;;267      }
;;;268    
;;;269      /* In asynchronous mode, the following bits must be kept cleared:
;;;270      - LINEN and CLKEN bits in the USART_CR2 register,
;;;271      - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
;;;272      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;273      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;274    
;;;275      /* Enable the Peripheral */
;;;276      __HAL_UART_ENABLE(huart);
;;;277    
;;;278      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;279      return (UART_CheckIdleState(huart));
;;;280    }
000006  4770              BX       lr
                  |L27.8|
000008  b510              PUSH     {r4,lr}               ;226
00000a  4604              MOV      r4,r0                 ;226
00000c  6ec0              LDR      r0,[r0,#0x6c]         ;244
00000e  2800              CMP      r0,#0                 ;244
000010  d103              BNE      |L27.26|
000012  66a0              STR      r0,[r4,#0x68]         ;250
000014  4620              MOV      r0,r4                 ;250
000016  f7fffffe          BL       HAL_UART_MspInit
                  |L27.26|
00001a  2024              MOVS     r0,#0x24              ;253
00001c  66e0              STR      r0,[r4,#0x6c]         ;253
00001e  6820              LDR      r0,[r4,#0]            ;256
000020  6801              LDR      r1,[r0,#0]            ;256
000022  0849              LSRS     r1,r1,#1              ;256
000024  0049              LSLS     r1,r1,#1              ;256
000026  6001              STR      r1,[r0,#0]            ;256
000028  6a60              LDR      r0,[r4,#0x24]         ;259
00002a  2800              CMP      r0,#0                 ;259
00002c  d002              BEQ      |L27.52|
00002e  4620              MOV      r0,r4                 ;261
000030  f7fffffe          BL       UART_AdvFeatureConfig
                  |L27.52|
000034  4620              MOV      r0,r4                 ;264
000036  f7fffffe          BL       UART_SetConfig
00003a  2801              CMP      r0,#1                 ;264
00003c  d012              BEQ      |L27.100|
00003e  6820              LDR      r0,[r4,#0]            ;272
000040  6841              LDR      r1,[r0,#4]            ;272
000042  2209              MOVS     r2,#9                 ;272
000044  02d2              LSLS     r2,r2,#11             ;272
000046  4391              BICS     r1,r1,r2              ;272
000048  6041              STR      r1,[r0,#4]            ;272
00004a  6820              LDR      r0,[r4,#0]            ;273
00004c  6881              LDR      r1,[r0,#8]            ;273
00004e  222a              MOVS     r2,#0x2a              ;273
000050  4391              BICS     r1,r1,r2              ;273
000052  6081              STR      r1,[r0,#8]            ;273
000054  6820              LDR      r0,[r4,#0]            ;276
000056  6801              LDR      r1,[r0,#0]            ;276
000058  2201              MOVS     r2,#1                 ;276
00005a  4311              ORRS     r1,r1,r2              ;276
00005c  6001              STR      r1,[r0,#0]            ;276
00005e  4620              MOV      r0,r4                 ;279
000060  f7fffffe          BL       UART_CheckIdleState
                  |L27.100|
000064  bd10              POP      {r4,pc}
;;;281    
                          ENDP


                          AREA ||i.HAL_UART_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspDeInit PROC
;;;554      */
;;;555    __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;556    {
;;;557      /* Prevent unused argument(s) compilation warning */
;;;558      UNUSED(huart);
;;;559    
;;;560      /* NOTE : This function should not be modified, when the callback is needed,
;;;561                the HAL_UART_MspDeInit can be implemented in the user file
;;;562       */
;;;563    }
;;;564    
                          ENDP


                          AREA ||i.HAL_UART_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspInit PROC
;;;539      */
;;;540    __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;541    {
;;;542      /* Prevent unused argument(s) compilation warning */
;;;543      UNUSED(huart);
;;;544    
;;;545      /* NOTE : This function should not be modified, when the callback is needed,
;;;546                the HAL_UART_MspInit can be implemented in the user file
;;;547       */
;;;548    }
;;;549    
                          ENDP


                          AREA ||i.HAL_UART_Receive||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive PROC
;;;741      */
;;;742    HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  b5ff              PUSH     {r0-r7,lr}
;;;743    {
000002  4604              MOV      r4,r0
;;;744      uint16_t* tmp;
;;;745      uint16_t uhMask;
;;;746      uint32_t tickstart = 0;
;;;747    
;;;748      /* Check that a Rx process is not already ongoing */
;;;749      if(huart->RxState == HAL_UART_STATE_READY)
000004  6f00              LDR      r0,[r0,#0x70]
000006  b085              SUB      sp,sp,#0x14           ;743
000008  461e              MOV      r6,r3                 ;743
00000a  4617              MOV      r7,r2                 ;743
00000c  2820              CMP      r0,#0x20
00000e  d16e              BNE      |L30.238|
;;;750      {
;;;751        if((pData == NULL ) || (Size == 0U))
000010  9806              LDR      r0,[sp,#0x18]
000012  2800              CMP      r0,#0
000014  d00c              BEQ      |L30.48|
000016  2f00              CMP      r7,#0
000018  d00a              BEQ      |L30.48|
;;;752        {
;;;753          return  HAL_ERROR;
;;;754        }
;;;755    
;;;756        /* In case of 9bits/No Parity transfer, pData buffer provided as input paramter 
;;;757           should be aligned on a u16 frontier, as data to be received from RDR will be 
;;;758           handled through a u16 cast. */
;;;759        if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
00001a  2001              MOVS     r0,#1
00001c  68a1              LDR      r1,[r4,#8]
00001e  0300              LSLS     r0,r0,#12
000020  4281              CMP      r1,r0
000022  d108              BNE      |L30.54|
000024  6920              LDR      r0,[r4,#0x10]
000026  2800              CMP      r0,#0
000028  d105              BNE      |L30.54|
;;;760        {
;;;761          if((((uint32_t)pData)&1) != 0)
00002a  9806              LDR      r0,[sp,#0x18]
00002c  07c0              LSLS     r0,r0,#31
00002e  d002              BEQ      |L30.54|
                  |L30.48|
;;;762          {
;;;763            return  HAL_ERROR;
000030  2001              MOVS     r0,#1
;;;764          }
;;;765        }
;;;766    
;;;767        /* Process Locked */
;;;768        __HAL_LOCK(huart);
;;;769    
;;;770        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;771        huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;772    
;;;773        /* Init tickstart for timeout managment*/
;;;774        tickstart = HAL_GetTick();
;;;775    
;;;776        huart->RxXferSize = Size;
;;;777        huart->RxXferCount = Size;
;;;778    
;;;779        /* Computation of UART mask to apply to RDR register */
;;;780        UART_MASK_COMPUTATION(huart);
;;;781        uhMask = huart->Mask;
;;;782    
;;;783        /* as long as data have to be received */
;;;784        while(huart->RxXferCount > 0U)
;;;785        {
;;;786          huart->RxXferCount--;
;;;787          if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;788          {
;;;789            return HAL_TIMEOUT;
;;;790          }
;;;791          if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;792          {
;;;793            tmp = (uint16_t*) pData ;
;;;794            *tmp = (uint16_t)(huart->Instance->RDR & uhMask);
;;;795            pData +=2U;
;;;796          }
;;;797          else
;;;798          {
;;;799            *pData++ = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
;;;800          }
;;;801        }
;;;802    
;;;803        /* At end of Rx process, restore huart->RxState to Ready */
;;;804        huart->RxState = HAL_UART_STATE_READY;
;;;805    
;;;806        /* Process Unlocked */
;;;807        __HAL_UNLOCK(huart);
;;;808    
;;;809        return HAL_OK;
;;;810      }
;;;811      else
;;;812      {
;;;813        return HAL_BUSY;
;;;814      }
;;;815    }
000032  b009              ADD      sp,sp,#0x24
000034  bdf0              POP      {r4-r7,pc}
                  |L30.54|
000036  6ea0              LDR      r0,[r4,#0x68]         ;768
000038  2801              CMP      r0,#1                 ;768
00003a  d058              BEQ      |L30.238|
00003c  2001              MOVS     r0,#1                 ;768
00003e  66a0              STR      r0,[r4,#0x68]         ;770
000040  2000              MOVS     r0,#0                 ;770
000042  6760              STR      r0,[r4,#0x74]         ;770
000044  2022              MOVS     r0,#0x22              ;771
000046  6720              STR      r0,[r4,#0x70]         ;771
000048  f7fffffe          BL       HAL_GetTick
00004c  4625              MOV      r5,r4                 ;776
00004e  3540              ADDS     r5,r5,#0x40           ;776
000050  9003              STR      r0,[sp,#0xc]          ;776
000052  832f              STRH     r7,[r5,#0x18]         ;776
000054  836f              STRH     r7,[r5,#0x1a]         ;777
000056  2001              MOVS     r0,#1                 ;780
000058  68a1              LDR      r1,[r4,#8]            ;780
00005a  0300              LSLS     r0,r0,#12             ;780
00005c  22ff              MOVS     r2,#0xff              ;780
00005e  4281              CMP      r1,r0                 ;780
000060  d104              BNE      |L30.108|
000062  6921              LDR      r1,[r4,#0x10]         ;780
000064  2900              CMP      r1,#0                 ;780
000066  d143              BNE      |L30.240|
000068  4938              LDR      r1,|L30.332|
00006a  e00a              B        |L30.130|
                  |L30.108|
00006c  237f              MOVS     r3,#0x7f              ;780
00006e  2900              CMP      r1,#0                 ;780
000070  d038              BEQ      |L30.228|
000072  2201              MOVS     r2,#1                 ;780
000074  0712              LSLS     r2,r2,#28             ;780
000076  4291              CMP      r1,r2                 ;780
000078  d104              BNE      |L30.132|
00007a  6921              LDR      r1,[r4,#0x10]         ;780
00007c  2900              CMP      r1,#0                 ;780
00007e  d034              BEQ      |L30.234|
000080  213f              MOVS     r1,#0x3f              ;780
                  |L30.130|
000082  83a9              STRH     r1,[r5,#0x1c]         ;780
                  |L30.132|
000084  8ba9              LDRH     r1,[r5,#0x1c]         ;781
000086  9100              STR      r1,[sp,#0]            ;784
000088  8b69              LDRH     r1,[r5,#0x1a]         ;784
00008a  2900              CMP      r1,#0                 ;784
00008c  d04b              BEQ      |L30.294|
00008e  9800              LDR      r0,[sp,#0]            ;799
000090  b2c0              UXTB     r0,r0                 ;799
000092  9002              STR      r0,[sp,#8]            ;799
                  |L30.148|
000094  8b68              LDRH     r0,[r5,#0x1a]         ;786
000096  1e40              SUBS     r0,r0,#1              ;786
000098  8368              STRH     r0,[r5,#0x1a]         ;786
00009a  9803              LDR      r0,[sp,#0xc]          ;787
00009c  9001              STR      r0,[sp,#4]            ;787
00009e  6820              LDR      r0,[r4,#0]            ;787
0000a0  2720              MOVS     r7,#0x20              ;787
0000a2  69c1              LDR      r1,[r0,#0x1c]         ;787
0000a4  4638              MOV      r0,r7                 ;787
0000a6  4388              BICS     r0,r0,r1              ;787
0000a8  d029              BEQ      |L30.254|
                  |L30.170|
0000aa  1c70              ADDS     r0,r6,#1              ;787
0000ac  d022              BEQ      |L30.244|
0000ae  2e00              CMP      r6,#0                 ;787
0000b0  d005              BEQ      |L30.190|
0000b2  f7fffffe          BL       HAL_GetTick
0000b6  9901              LDR      r1,[sp,#4]            ;787
0000b8  1a41              SUBS     r1,r0,r1              ;787
0000ba  42b1              CMP      r1,r6                 ;787
0000bc  d91a              BLS      |L30.244|
                  |L30.190|
0000be  6820              LDR      r0,[r4,#0]            ;787
0000c0  6801              LDR      r1,[r0,#0]            ;787
0000c2  22ff              MOVS     r2,#0xff              ;787
0000c4  32a1              ADDS     r2,r2,#0xa1           ;787
0000c6  4391              BICS     r1,r1,r2              ;787
0000c8  6001              STR      r1,[r0,#0]            ;787
0000ca  6820              LDR      r0,[r4,#0]            ;787
0000cc  6881              LDR      r1,[r0,#8]            ;787
0000ce  0849              LSRS     r1,r1,#1              ;787
0000d0  0049              LSLS     r1,r1,#1              ;787
0000d2  6081              STR      r1,[r0,#8]            ;787
0000d4  2020              MOVS     r0,#0x20              ;787
0000d6  66e0              STR      r0,[r4,#0x6c]         ;787
0000d8  6720              STR      r0,[r4,#0x70]         ;787
0000da  2000              MOVS     r0,#0                 ;787
0000dc  66a0              STR      r0,[r4,#0x68]         ;789
0000de  2003              MOVS     r0,#3                 ;789
0000e0  b009              ADD      sp,sp,#0x24
0000e2  bdf0              POP      {r4-r7,pc}
                  |L30.228|
0000e4  6921              LDR      r1,[r4,#0x10]         ;780
0000e6  2900              CMP      r1,#0                 ;780
0000e8  d002              BEQ      |L30.240|
                  |L30.234|
0000ea  83ab              STRH     r3,[r5,#0x1c]         ;780
0000ec  e7ca              B        |L30.132|
                  |L30.238|
0000ee  e029              B        |L30.324|
                  |L30.240|
0000f0  83aa              STRH     r2,[r5,#0x1c]         ;780
0000f2  e7c7              B        |L30.132|
                  |L30.244|
0000f4  6820              LDR      r0,[r4,#0]            ;780
0000f6  69c1              LDR      r1,[r0,#0x1c]         ;780
0000f8  4638              MOV      r0,r7                 ;780
0000fa  4388              BICS     r0,r0,r1              ;780
0000fc  d1d5              BNE      |L30.170|
                  |L30.254|
0000fe  2001              MOVS     r0,#1                 ;791
000100  68a1              LDR      r1,[r4,#8]            ;791
000102  0300              LSLS     r0,r0,#12             ;791
000104  4281              CMP      r1,r0                 ;791
000106  d102              BNE      |L30.270|
000108  6920              LDR      r0,[r4,#0x10]         ;791
00010a  2800              CMP      r0,#0                 ;791
00010c  d011              BEQ      |L30.306|
                  |L30.270|
00010e  6820              LDR      r0,[r4,#0]            ;799
000110  6a40              LDR      r0,[r0,#0x24]         ;799
000112  9902              LDR      r1,[sp,#8]            ;799
000114  4008              ANDS     r0,r0,r1              ;799
000116  9906              LDR      r1,[sp,#0x18]         ;799
000118  7008              STRB     r0,[r1,#0]            ;799
00011a  9806              LDR      r0,[sp,#0x18]         ;799
00011c  1c40              ADDS     r0,r0,#1              ;799
                  |L30.286|
00011e  9006              STR      r0,[sp,#0x18]         ;799
000120  8b68              LDRH     r0,[r5,#0x1a]         ;799
000122  2800              CMP      r0,#0                 ;799
000124  d1b6              BNE      |L30.148|
                  |L30.294|
000126  2020              MOVS     r0,#0x20              ;804
000128  6720              STR      r0,[r4,#0x70]         ;804
00012a  2000              MOVS     r0,#0                 ;807
00012c  66a0              STR      r0,[r4,#0x68]         ;809
00012e  b009              ADD      sp,sp,#0x24
000130  bdf0              POP      {r4-r7,pc}
                  |L30.306|
000132  6820              LDR      r0,[r4,#0]            ;794
000134  9a06              LDR      r2,[sp,#0x18]         ;794
000136  6a41              LDR      r1,[r0,#0x24]         ;794
000138  9800              LDR      r0,[sp,#0]            ;794
00013a  4001              ANDS     r1,r1,r0              ;794
00013c  8011              STRH     r1,[r2,#0]            ;794
00013e  9806              LDR      r0,[sp,#0x18]         ;795
000140  1c80              ADDS     r0,r0,#2              ;795
000142  e7ec              B        |L30.286|
                  |L30.324|
000144  2002              MOVS     r0,#2                 ;813
000146  b009              ADD      sp,sp,#0x24
000148  bdf0              POP      {r4-r7,pc}
;;;816    
                          ENDP

00014a  0000              DCW      0x0000
                  |L30.332|
                          DCD      0x000001ff

                          AREA ||i.HAL_UART_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive_DMA PROC
;;;1021     */
;;;1022   HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1023   {
000002  4604              MOV      r4,r0
;;;1024     /* Check that a Rx process is not already ongoing */
;;;1025     if(huart->RxState == HAL_UART_STATE_READY)
000004  6f00              LDR      r0,[r0,#0x70]
000006  2820              CMP      r0,#0x20
000008  d13f              BNE      |L31.138|
;;;1026     {
;;;1027       if((pData == NULL ) || (Size == 0U))
00000a  2900              CMP      r1,#0
00000c  d00b              BEQ      |L31.38|
00000e  2a00              CMP      r2,#0
000010  d009              BEQ      |L31.38|
;;;1028       {
;;;1029         return HAL_ERROR;
;;;1030       }
;;;1031   
;;;1032       /* In case of 9bits/No Parity transfer, pData buffer provided as input paramter 
;;;1033          should be aligned on a u16 frontier, as data copy from RDR will be 
;;;1034          handled by DMA from a u16 frontier. */
;;;1035       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
000012  2301              MOVS     r3,#1
000014  68a0              LDR      r0,[r4,#8]
000016  031b              LSLS     r3,r3,#12
000018  4298              CMP      r0,r3
00001a  d106              BNE      |L31.42|
00001c  6920              LDR      r0,[r4,#0x10]
00001e  2800              CMP      r0,#0
000020  d103              BNE      |L31.42|
;;;1036       {
;;;1037         if((((uint32_t)pData)&1) != 0)
000022  07c8              LSLS     r0,r1,#31
000024  d001              BEQ      |L31.42|
                  |L31.38|
;;;1038         {
;;;1039           return  HAL_ERROR;
000026  2001              MOVS     r0,#1
;;;1040         }
;;;1041       }
;;;1042   
;;;1043       /* Process Locked */
;;;1044       __HAL_LOCK(huart);
;;;1045   
;;;1046       huart->pRxBuffPtr = pData;
;;;1047       huart->RxXferSize = Size;
;;;1048   
;;;1049       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1050       huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;1051   
;;;1052       /* Set the UART DMA transfer complete callback */
;;;1053       huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
;;;1054   
;;;1055       /* Set the UART DMA Half transfer complete callback */
;;;1056       huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
;;;1057   
;;;1058       /* Set the DMA error callback */
;;;1059       huart->hdmarx->XferErrorCallback = UART_DMAError;
;;;1060   
;;;1061       /* Set the DMA abort callback */
;;;1062       huart->hdmarx->XferAbortCallback = NULL;
;;;1063   
;;;1064       /* Enable the DMA channel */
;;;1065       HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->RDR, (uint32_t)huart->pRxBuffPtr, Size);
;;;1066   
;;;1067       /* Process Unlocked */
;;;1068       __HAL_UNLOCK(huart);
;;;1069   
;;;1070       /* Enable the UART Parity Error Interrupt */
;;;1071       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1072   
;;;1073       /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1074       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1075   
;;;1076       /* Enable the DMA transfer for the receiver request by setting the DMAR bit
;;;1077          in the UART CR3 register */
;;;1078       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1079   
;;;1080       return HAL_OK;
;;;1081     }
;;;1082     else
;;;1083     {
;;;1084       return HAL_BUSY;
;;;1085     }
;;;1086   }
000028  bdf8              POP      {r3-r7,pc}
                  |L31.42|
00002a  6ea0              LDR      r0,[r4,#0x68]         ;1044
00002c  2801              CMP      r0,#1                 ;1044
00002e  d02c              BEQ      |L31.138|
000030  2501              MOVS     r5,#1                 ;1044
000032  2058              MOVS     r0,#0x58              ;1047
000034  66a5              STR      r5,[r4,#0x68]         ;1047
000036  6561              STR      r1,[r4,#0x54]         ;1047
000038  5302              STRH     r2,[r0,r4]            ;1047
00003a  2600              MOVS     r6,#0                 ;1049
00003c  6766              STR      r6,[r4,#0x74]         ;1049
00003e  2022              MOVS     r0,#0x22              ;1050
000040  6720              STR      r0,[r4,#0x70]         ;1050
000042  6e61              LDR      r1,[r4,#0x64]         ;1053
000044  4812              LDR      r0,|L31.144|
000046  6308              STR      r0,[r1,#0x30]         ;1056
000048  6e61              LDR      r1,[r4,#0x64]         ;1056
00004a  4812              LDR      r0,|L31.148|
00004c  6348              STR      r0,[r1,#0x34]         ;1059
00004e  6e61              LDR      r1,[r4,#0x64]         ;1059
000050  4811              LDR      r0,|L31.152|
000052  6388              STR      r0,[r1,#0x38]         ;1062
000054  6e60              LDR      r0,[r4,#0x64]         ;1062
000056  4613              MOV      r3,r2                 ;1065
000058  63c6              STR      r6,[r0,#0x3c]         ;1065
00005a  6d67              LDR      r7,[r4,#0x54]         ;1065
00005c  6821              LDR      r1,[r4,#0]            ;1065
00005e  463a              MOV      r2,r7                 ;1065
000060  3124              ADDS     r1,r1,#0x24           ;1065
000062  6e60              LDR      r0,[r4,#0x64]         ;1065
000064  f7fffffe          BL       HAL_DMA_Start_IT
000068  66a6              STR      r6,[r4,#0x68]         ;1071
00006a  6820              LDR      r0,[r4,#0]            ;1071
00006c  6801              LDR      r1,[r0,#0]            ;1071
00006e  022a              LSLS     r2,r5,#8              ;1071
000070  4311              ORRS     r1,r1,r2              ;1071
000072  6001              STR      r1,[r0,#0]            ;1071
000074  6820              LDR      r0,[r4,#0]            ;1074
000076  6881              LDR      r1,[r0,#8]            ;1074
000078  4329              ORRS     r1,r1,r5              ;1074
00007a  6081              STR      r1,[r0,#8]            ;1074
00007c  6820              LDR      r0,[r4,#0]            ;1078
00007e  6881              LDR      r1,[r0,#8]            ;1078
000080  2240              MOVS     r2,#0x40              ;1078
000082  4311              ORRS     r1,r1,r2              ;1078
000084  6081              STR      r1,[r0,#8]            ;1078
000086  2000              MOVS     r0,#0                 ;1080
000088  bdf8              POP      {r3-r7,pc}
                  |L31.138|
00008a  2002              MOVS     r0,#2                 ;1084
00008c  bdf8              POP      {r3-r7,pc}
;;;1087   
                          ENDP

00008e  0000              DCW      0x0000
                  |L31.144|
                          DCD      UART_DMAReceiveCplt
                  |L31.148|
                          DCD      UART_DMARxHalfCplt
                  |L31.152|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive_IT PROC
;;;883      */
;;;884    HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b430              PUSH     {r4,r5}
;;;885    {
;;;886      /* Check that a Rx process is not already ongoing */
;;;887      if(huart->RxState == HAL_UART_STATE_READY)
000002  6f03              LDR      r3,[r0,#0x70]
000004  2b20              CMP      r3,#0x20
000006  d145              BNE      |L32.148|
;;;888      {
;;;889        if((pData == NULL ) || (Size == 0U))
000008  2900              CMP      r1,#0
00000a  d00b              BEQ      |L32.36|
00000c  2a00              CMP      r2,#0
00000e  d009              BEQ      |L32.36|
;;;890        {
;;;891          return HAL_ERROR;
;;;892        }
;;;893    
;;;894        /* In case of 9bits/No Parity transfer, pData buffer provided as input paramter 
;;;895           should be aligned on a u16 frontier, as data to be received from RDR will be 
;;;896           handled through a u16 cast. */
;;;897        if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
000010  2401              MOVS     r4,#1
000012  6883              LDR      r3,[r0,#8]
000014  0324              LSLS     r4,r4,#12
000016  42a3              CMP      r3,r4
000018  d107              BNE      |L32.42|
00001a  6905              LDR      r5,[r0,#0x10]
00001c  2d00              CMP      r5,#0
00001e  d104              BNE      |L32.42|
;;;898        {
;;;899          if((((uint32_t)pData)&1) != 0)
000020  07cd              LSLS     r5,r1,#31
000022  d002              BEQ      |L32.42|
                  |L32.36|
;;;900          {
;;;901            return  HAL_ERROR;
;;;902          }
;;;903        }
;;;904    
;;;905        /* Process Locked */
;;;906        __HAL_LOCK(huart);
;;;907    
;;;908        huart->pRxBuffPtr = pData;
;;;909        huart->RxXferSize = Size;
;;;910        huart->RxXferCount = Size;
;;;911    
;;;912        /* Computation of UART mask to apply to RDR register */
;;;913        UART_MASK_COMPUTATION(huart);
;;;914    
;;;915        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;916        huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;917    
;;;918        /* Process Unlocked */
;;;919        __HAL_UNLOCK(huart);
;;;920    
;;;921        /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;922        SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;923    
;;;924        /* Enable the UART Parity Error and Data Register not empty Interrupts */
;;;925        SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
;;;926    
;;;927        return HAL_OK;
;;;928      }
;;;929      else
;;;930      {
;;;931        return HAL_BUSY;
;;;932      }
;;;933    }
000024  bc30              POP      {r4,r5}
000026  2001              MOVS     r0,#1                 ;901
000028  4770              BX       lr
                  |L32.42|
00002a  6e85              LDR      r5,[r0,#0x68]         ;906
00002c  2d01              CMP      r5,#1                 ;906
00002e  d031              BEQ      |L32.148|
000030  2501              MOVS     r5,#1                 ;906
000032  6685              STR      r5,[r0,#0x68]         ;909
000034  6541              STR      r1,[r0,#0x54]         ;909
000036  4601              MOV      r1,r0                 ;909
000038  3140              ADDS     r1,r1,#0x40           ;909
00003a  830a              STRH     r2,[r1,#0x18]         ;909
00003c  834a              STRH     r2,[r1,#0x1a]         ;910
00003e  22ff              MOVS     r2,#0xff              ;913
000040  42a3              CMP      r3,r4                 ;913
000042  d104              BNE      |L32.78|
000044  6903              LDR      r3,[r0,#0x10]         ;913
000046  2b00              CMP      r3,#0                 ;913
000048  d10c              BNE      |L32.100|
00004a  4a14              LDR      r2,|L32.156|
00004c  e00a              B        |L32.100|
                  |L32.78|
00004e  247f              MOVS     r4,#0x7f              ;913
000050  2b00              CMP      r3,#0                 ;913
000052  d01a              BEQ      |L32.138|
000054  2201              MOVS     r2,#1                 ;913
000056  0712              LSLS     r2,r2,#28             ;913
000058  4293              CMP      r3,r2                 ;913
00005a  d104              BNE      |L32.102|
00005c  6902              LDR      r2,[r0,#0x10]         ;913
00005e  2a00              CMP      r2,#0                 ;913
000060  d016              BEQ      |L32.144|
000062  223f              MOVS     r2,#0x3f              ;913
                  |L32.100|
000064  838a              STRH     r2,[r1,#0x1c]         ;913
                  |L32.102|
000066  2100              MOVS     r1,#0                 ;915
000068  6741              STR      r1,[r0,#0x74]         ;915
00006a  2222              MOVS     r2,#0x22              ;916
00006c  6702              STR      r2,[r0,#0x70]         ;916
00006e  6681              STR      r1,[r0,#0x68]         ;922
000070  6801              LDR      r1,[r0,#0]            ;922
000072  688a              LDR      r2,[r1,#8]            ;922
000074  432a              ORRS     r2,r2,r5              ;922
000076  608a              STR      r2,[r1,#8]            ;922
000078  6800              LDR      r0,[r0,#0]            ;925
00007a  6801              LDR      r1,[r0,#0]            ;925
00007c  22ff              MOVS     r2,#0xff              ;925
00007e  3221              ADDS     r2,r2,#0x21           ;925
000080  4311              ORRS     r1,r1,r2              ;925
000082  6001              STR      r1,[r0,#0]            ;925
000084  bc30              POP      {r4,r5}
000086  2000              MOVS     r0,#0                 ;927
000088  4770              BX       lr
                  |L32.138|
00008a  6903              LDR      r3,[r0,#0x10]         ;913
00008c  2b00              CMP      r3,#0                 ;913
00008e  d0e9              BEQ      |L32.100|
                  |L32.144|
000090  838c              STRH     r4,[r1,#0x1c]         ;913
000092  e7e8              B        |L32.102|
                  |L32.148|
000094  bc30              POP      {r4,r5}
000096  2002              MOVS     r0,#2                 ;931
000098  4770              BX       lr
;;;934    
                          ENDP

00009a  0000              DCW      0x0000
                  |L32.156|
                          DCD      0x000001ff

                          AREA ||i.HAL_UART_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxCpltCallback PROC
;;;1805     */
;;;1806   __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1807   {
;;;1808     /* Prevent unused argument(s) compilation warning */
;;;1809     UNUSED(huart);
;;;1810   
;;;1811     /* NOTE : This function should not be modified, when the callback is needed,
;;;1812               the HAL_UART_RxCpltCallback can be implemented in the user file.
;;;1813      */
;;;1814   }
;;;1815   
                          ENDP


                          AREA ||i.HAL_UART_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxHalfCpltCallback PROC
;;;1820     */
;;;1821   __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1822   {
;;;1823     /* Prevent unused argument(s) compilation warning */
;;;1824     UNUSED(huart);
;;;1825   
;;;1826     /* NOTE: This function should not be modified, when the callback is needed,
;;;1827              the HAL_UART_RxHalfCpltCallback can be implemented in the user file.
;;;1828      */
;;;1829   }
;;;1830   
                          ENDP


                          AREA ||i.HAL_UART_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit PROC
;;;657      */
;;;658    HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  b5ff              PUSH     {r0-r7,lr}
;;;659    {
000002  4604              MOV      r4,r0
;;;660      uint16_t* tmp;
;;;661      uint32_t tickstart = 0;
;;;662    
;;;663      /* Check that a Tx process is not already ongoing */
;;;664      if(huart->gState == HAL_UART_STATE_READY)
000004  6ec0              LDR      r0,[r0,#0x6c]
000006  b083              SUB      sp,sp,#0xc            ;659
000008  461d              MOV      r5,r3                 ;659
00000a  4617              MOV      r7,r2                 ;659
00000c  2820              CMP      r0,#0x20
00000e  d170              BNE      |L35.242|
;;;665      {
;;;666        if((pData == NULL ) || (Size == 0U))
000010  9804              LDR      r0,[sp,#0x10]
000012  2800              CMP      r0,#0
000014  d00c              BEQ      |L35.48|
000016  2f00              CMP      r7,#0
000018  d00a              BEQ      |L35.48|
;;;667        {
;;;668          return  HAL_ERROR;
;;;669        }
;;;670    
;;;671        /* In case of 9bits/No Parity transfer, pData buffer provided as input paramter 
;;;672           should be aligned on a u16 frontier, as data to be filled into TDR will be 
;;;673           handled through a u16 cast. */
;;;674        if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
00001a  2001              MOVS     r0,#1
00001c  68a1              LDR      r1,[r4,#8]
00001e  0300              LSLS     r0,r0,#12
000020  4281              CMP      r1,r0
000022  d108              BNE      |L35.54|
000024  6920              LDR      r0,[r4,#0x10]
000026  2800              CMP      r0,#0
000028  d105              BNE      |L35.54|
;;;675        {
;;;676          if((((uint32_t)pData)&1) != 0)
00002a  9804              LDR      r0,[sp,#0x10]
00002c  07c0              LSLS     r0,r0,#31
00002e  d002              BEQ      |L35.54|
                  |L35.48|
;;;677          {
;;;678            return  HAL_ERROR;
000030  2001              MOVS     r0,#1
;;;679          }
;;;680        }
;;;681    
;;;682        /* Process Locked */
;;;683        __HAL_LOCK(huart);
;;;684    
;;;685        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;686        huart->gState = HAL_UART_STATE_BUSY_TX;
;;;687    
;;;688        /* Init tickstart for timeout managment*/
;;;689        tickstart = HAL_GetTick();
;;;690    
;;;691        huart->TxXferSize = Size;
;;;692        huart->TxXferCount = Size;
;;;693        while(huart->TxXferCount > 0U)
;;;694        {
;;;695          huart->TxXferCount--;
;;;696          if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;697          {
;;;698            return HAL_TIMEOUT;
;;;699          }
;;;700          if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;701          {
;;;702            tmp = (uint16_t*) pData;
;;;703            huart->Instance->TDR = (*tmp & (uint16_t)0x01FFU);
;;;704            pData += 2U;
;;;705          }
;;;706          else
;;;707          {
;;;708            huart->Instance->TDR = (*pData++ & (uint8_t)0xFFU);
;;;709          }
;;;710        }
;;;711        if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;712        {
;;;713          return HAL_TIMEOUT;
;;;714        }
;;;715    
;;;716        /* At end of Tx process, restore huart->gState to Ready */
;;;717        huart->gState = HAL_UART_STATE_READY;
;;;718    
;;;719        /* Process Unlocked */
;;;720        __HAL_UNLOCK(huart);
;;;721    
;;;722        return HAL_OK;
;;;723      }
;;;724      else
;;;725      {
;;;726        return HAL_BUSY;
;;;727      }
;;;728    }
000032  b007              ADD      sp,sp,#0x1c
000034  bdf0              POP      {r4-r7,pc}
                  |L35.54|
000036  6ea0              LDR      r0,[r4,#0x68]         ;683
000038  2801              CMP      r0,#1                 ;683
00003a  d06a              BEQ      |L35.274|
00003c  2001              MOVS     r0,#1                 ;683
00003e  66a0              STR      r0,[r4,#0x68]         ;685
000040  2000              MOVS     r0,#0                 ;685
000042  6760              STR      r0,[r4,#0x74]         ;685
000044  2021              MOVS     r0,#0x21              ;686
000046  66e0              STR      r0,[r4,#0x6c]         ;686
000048  f7fffffe          BL       HAL_GetTick
00004c  4626              MOV      r6,r4                 ;691
00004e  3640              ADDS     r6,r6,#0x40           ;691
000050  9001              STR      r0,[sp,#4]            ;691
000052  8237              STRH     r7,[r6,#0x10]         ;691
000054  8277              STRH     r7,[r6,#0x12]         ;692
000056  8a70              LDRH     r0,[r6,#0x12]         ;693
000058  2800              CMP      r0,#0                 ;693
00005a  d03e              BEQ      |L35.218|
                  |L35.92|
00005c  8a70              LDRH     r0,[r6,#0x12]         ;695
00005e  1e40              SUBS     r0,r0,#1              ;695
000060  8270              STRH     r0,[r6,#0x12]         ;695
000062  9801              LDR      r0,[sp,#4]            ;696
000064  9000              STR      r0,[sp,#0]            ;696
000066  6820              LDR      r0,[r4,#0]            ;696
000068  2780              MOVS     r7,#0x80              ;696
00006a  69c1              LDR      r1,[r0,#0x1c]         ;696
00006c  4638              MOV      r0,r7                 ;696
00006e  4388              BICS     r0,r0,r1              ;696
000070  d021              BEQ      |L35.182|
                  |L35.114|
000072  1c68              ADDS     r0,r5,#1              ;696
000074  d01a              BEQ      |L35.172|
000076  2d00              CMP      r5,#0                 ;696
000078  d005              BEQ      |L35.134|
00007a  f7fffffe          BL       HAL_GetTick
00007e  9900              LDR      r1,[sp,#0]            ;696
000080  1a41              SUBS     r1,r0,r1              ;696
000082  42a9              CMP      r1,r5                 ;696
000084  d912              BLS      |L35.172|
                  |L35.134|
000086  6820              LDR      r0,[r4,#0]            ;696
000088  6801              LDR      r1,[r0,#0]            ;696
00008a  22ff              MOVS     r2,#0xff              ;696
00008c  32a1              ADDS     r2,r2,#0xa1           ;696
00008e  4391              BICS     r1,r1,r2              ;696
000090  6001              STR      r1,[r0,#0]            ;696
000092  6820              LDR      r0,[r4,#0]            ;696
000094  6881              LDR      r1,[r0,#8]            ;696
000096  0849              LSRS     r1,r1,#1              ;696
000098  0049              LSLS     r1,r1,#1              ;696
00009a  6081              STR      r1,[r0,#8]            ;696
00009c  2020              MOVS     r0,#0x20              ;696
00009e  66e0              STR      r0,[r4,#0x6c]         ;696
0000a0  6720              STR      r0,[r4,#0x70]         ;696
0000a2  2000              MOVS     r0,#0                 ;696
0000a4  66a0              STR      r0,[r4,#0x68]         ;698
0000a6  2003              MOVS     r0,#3                 ;698
0000a8  b007              ADD      sp,sp,#0x1c
0000aa  bdf0              POP      {r4-r7,pc}
                  |L35.172|
0000ac  6820              LDR      r0,[r4,#0]
0000ae  69c1              LDR      r1,[r0,#0x1c]
0000b0  4638              MOV      r0,r7
0000b2  4388              BICS     r0,r0,r1
0000b4  d1dd              BNE      |L35.114|
                  |L35.182|
0000b6  2001              MOVS     r0,#1                 ;700
0000b8  68a1              LDR      r1,[r4,#8]            ;700
0000ba  0300              LSLS     r0,r0,#12             ;700
0000bc  4281              CMP      r1,r0                 ;700
0000be  d102              BNE      |L35.198|
0000c0  6920              LDR      r0,[r4,#0x10]         ;700
0000c2  2800              CMP      r0,#0                 ;700
0000c4  d016              BEQ      |L35.244|
                  |L35.198|
0000c6  9804              LDR      r0,[sp,#0x10]         ;708
0000c8  6821              LDR      r1,[r4,#0]            ;708
0000ca  7800              LDRB     r0,[r0,#0]            ;708
0000cc  6288              STR      r0,[r1,#0x28]         ;708
0000ce  9804              LDR      r0,[sp,#0x10]         ;708
0000d0  1c40              ADDS     r0,r0,#1              ;708
                  |L35.210|
0000d2  9004              STR      r0,[sp,#0x10]         ;708
0000d4  8a70              LDRH     r0,[r6,#0x12]         ;708
0000d6  2800              CMP      r0,#0                 ;708
0000d8  d1c0              BNE      |L35.92|
                  |L35.218|
0000da  9500              STR      r5,[sp,#0]            ;711
0000dc  2200              MOVS     r2,#0                 ;711
0000de  2140              MOVS     r1,#0x40              ;711
0000e0  4620              MOV      r0,r4                 ;711
0000e2  9b01              LDR      r3,[sp,#4]            ;711
0000e4  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
0000e8  2800              CMP      r0,#0                 ;711
0000ea  d00c              BEQ      |L35.262|
0000ec  2003              MOVS     r0,#3                 ;713
0000ee  b007              ADD      sp,sp,#0x1c
0000f0  bdf0              POP      {r4-r7,pc}
                  |L35.242|
0000f2  e00e              B        |L35.274|
                  |L35.244|
0000f4  9804              LDR      r0,[sp,#0x10]         ;703
0000f6  6821              LDR      r1,[r4,#0]            ;703
0000f8  8800              LDRH     r0,[r0,#0]            ;703
0000fa  05c0              LSLS     r0,r0,#23             ;703
0000fc  0dc0              LSRS     r0,r0,#23             ;703
0000fe  6288              STR      r0,[r1,#0x28]         ;703
000100  9804              LDR      r0,[sp,#0x10]         ;704
000102  1c80              ADDS     r0,r0,#2              ;704
000104  e7e5              B        |L35.210|
                  |L35.262|
000106  2020              MOVS     r0,#0x20              ;717
000108  66e0              STR      r0,[r4,#0x6c]         ;717
00010a  2000              MOVS     r0,#0                 ;720
00010c  66a0              STR      r0,[r4,#0x68]         ;722
00010e  b007              ADD      sp,sp,#0x1c
000110  bdf0              POP      {r4-r7,pc}
                  |L35.274|
000112  2002              MOVS     r0,#2                 ;726
000114  b007              ADD      sp,sp,#0x1c
000116  bdf0              POP      {r4-r7,pc}
;;;729    
                          ENDP


                          AREA ||i.HAL_UART_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Transmit_DMA PROC
;;;945      */
;;;946    HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;947    {
000002  4604              MOV      r4,r0
;;;948      /* Check that a Tx process is not already ongoing */
;;;949      if(huart->gState == HAL_UART_STATE_READY)
000004  6ec0              LDR      r0,[r0,#0x6c]
000006  2820              CMP      r0,#0x20
000008  d13b              BNE      |L36.130|
;;;950      {
;;;951        if((pData == NULL ) || (Size == 0U))
00000a  2900              CMP      r1,#0
00000c  d00b              BEQ      |L36.38|
00000e  2a00              CMP      r2,#0
000010  d009              BEQ      |L36.38|
;;;952        {
;;;953          return HAL_ERROR;
;;;954        }
;;;955    
;;;956        /* In case of 9bits/No Parity transfer, pData buffer provided as input paramter 
;;;957           should be aligned on a u16 frontier, as data copy into TDR will be 
;;;958           handled by DMA from a u16 frontier. */
;;;959        if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
000012  2301              MOVS     r3,#1
000014  68a0              LDR      r0,[r4,#8]
000016  031b              LSLS     r3,r3,#12
000018  4298              CMP      r0,r3
00001a  d106              BNE      |L36.42|
00001c  6920              LDR      r0,[r4,#0x10]
00001e  2800              CMP      r0,#0
000020  d103              BNE      |L36.42|
;;;960        {
;;;961          if((((uint32_t)pData)&1) != 0)
000022  07c8              LSLS     r0,r1,#31
000024  d001              BEQ      |L36.42|
                  |L36.38|
;;;962          {
;;;963            return  HAL_ERROR;
000026  2001              MOVS     r0,#1
;;;964          }
;;;965        }
;;;966    
;;;967        /* Process Locked */
;;;968        __HAL_LOCK(huart);
;;;969    
;;;970        huart->pTxBuffPtr = pData;
;;;971        huart->TxXferSize = Size;
;;;972        huart->TxXferCount = Size;
;;;973    
;;;974        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;975        huart->gState = HAL_UART_STATE_BUSY_TX;
;;;976    
;;;977        /* Set the UART DMA transfer complete callback */
;;;978        huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
;;;979    
;;;980        /* Set the UART DMA Half transfer complete callback */
;;;981        huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
;;;982    
;;;983        /* Set the DMA error callback */
;;;984        huart->hdmatx->XferErrorCallback = UART_DMAError;
;;;985    
;;;986        /* Set the DMA abort callback */
;;;987        huart->hdmatx->XferAbortCallback = NULL;
;;;988    
;;;989        /* Enable the UART transmit DMA channel */
;;;990        HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size);
;;;991    
;;;992        /* Clear the TC flag in the ICR register */
;;;993        __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_TCF);
;;;994    
;;;995        /* Process Unlocked */
;;;996        __HAL_UNLOCK(huart);
;;;997    
;;;998        /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;999           in the UART CR3 register */
;;;1000       SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1001   
;;;1002       return HAL_OK;
;;;1003     }
;;;1004     else
;;;1005     {
;;;1006       return HAL_BUSY;
;;;1007     }
;;;1008   }
000028  bd70              POP      {r4-r6,pc}
                  |L36.42|
00002a  6ea0              LDR      r0,[r4,#0x68]         ;968
00002c  2801              CMP      r0,#1                 ;968
00002e  d028              BEQ      |L36.130|
000030  2001              MOVS     r0,#1                 ;968
000032  64e1              STR      r1,[r4,#0x4c]         ;971
000034  66a0              STR      r0,[r4,#0x68]         ;971
000036  4620              MOV      r0,r4                 ;971
000038  3040              ADDS     r0,r0,#0x40           ;971
00003a  8202              STRH     r2,[r0,#0x10]         ;971
00003c  8242              STRH     r2,[r0,#0x12]         ;972
00003e  2500              MOVS     r5,#0                 ;974
000040  6765              STR      r5,[r4,#0x74]         ;974
000042  2021              MOVS     r0,#0x21              ;975
000044  66e0              STR      r0,[r4,#0x6c]         ;975
000046  6e21              LDR      r1,[r4,#0x60]         ;978
000048  480f              LDR      r0,|L36.136|
00004a  6308              STR      r0,[r1,#0x30]         ;981
00004c  6e21              LDR      r1,[r4,#0x60]         ;981
00004e  480f              LDR      r0,|L36.140|
000050  6348              STR      r0,[r1,#0x34]         ;984
000052  6e21              LDR      r1,[r4,#0x60]         ;984
000054  480e              LDR      r0,|L36.144|
000056  6388              STR      r0,[r1,#0x38]         ;987
000058  6e20              LDR      r0,[r4,#0x60]         ;987
00005a  4613              MOV      r3,r2                 ;990
00005c  63c5              STR      r5,[r0,#0x3c]         ;990
00005e  6826              LDR      r6,[r4,#0]            ;990
000060  6ce1              LDR      r1,[r4,#0x4c]         ;990
000062  4632              MOV      r2,r6                 ;990
000064  3228              ADDS     r2,r2,#0x28           ;990
000066  6e20              LDR      r0,[r4,#0x60]         ;990
000068  f7fffffe          BL       HAL_DMA_Start_IT
00006c  6821              LDR      r1,[r4,#0]            ;993
00006e  2040              MOVS     r0,#0x40              ;993
000070  6208              STR      r0,[r1,#0x20]         ;993
000072  66a5              STR      r5,[r4,#0x68]         ;1000
000074  6820              LDR      r0,[r4,#0]            ;1000
000076  6881              LDR      r1,[r0,#8]            ;1000
000078  2280              MOVS     r2,#0x80              ;1000
00007a  4311              ORRS     r1,r1,r2              ;1000
00007c  6081              STR      r1,[r0,#8]            ;1000
00007e  2000              MOVS     r0,#0                 ;1002
000080  bd70              POP      {r4-r6,pc}
                  |L36.130|
000082  2002              MOVS     r0,#2                 ;1006
000084  bd70              POP      {r4-r6,pc}
;;;1009   
                          ENDP

000086  0000              DCW      0x0000
                  |L36.136|
                          DCD      UART_DMATransmitCplt
                  |L36.140|
                          DCD      UART_DMATxHalfCplt
                  |L36.144|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit_IT PROC
;;;827      */
;;;828    HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b410              PUSH     {r4}
;;;829    {
;;;830      /* Check that a Tx process is not already ongoing */
;;;831      if(huart->gState == HAL_UART_STATE_READY)
000002  6ec3              LDR      r3,[r0,#0x6c]
000004  2b20              CMP      r3,#0x20
000006  d125              BNE      |L37.84|
;;;832      {
;;;833        if((pData == NULL ) || (Size == 0U))
000008  2900              CMP      r1,#0
00000a  d00b              BEQ      |L37.36|
00000c  2a00              CMP      r2,#0
00000e  d009              BEQ      |L37.36|
;;;834        {
;;;835          return HAL_ERROR;
;;;836        }
;;;837    
;;;838        /* In case of 9bits/No Parity transfer, pData buffer provided as input paramter 
;;;839           should be aligned on a u16 frontier, as data to be filled into TDR will be 
;;;840           handled through a u16 cast. */
;;;841        if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
000010  2401              MOVS     r4,#1
000012  6883              LDR      r3,[r0,#8]
000014  0324              LSLS     r4,r4,#12
000016  42a3              CMP      r3,r4
000018  d107              BNE      |L37.42|
00001a  6903              LDR      r3,[r0,#0x10]
00001c  2b00              CMP      r3,#0
00001e  d104              BNE      |L37.42|
;;;842        {
;;;843          if((((uint32_t)pData)&1) != 0)
000020  07cb              LSLS     r3,r1,#31
000022  d002              BEQ      |L37.42|
                  |L37.36|
;;;844          {
;;;845            return  HAL_ERROR;
;;;846          }
;;;847        }
;;;848    
;;;849        /* Process Locked */
;;;850        __HAL_LOCK(huart);
;;;851    
;;;852        huart->pTxBuffPtr = pData;
;;;853        huart->TxXferSize = Size;
;;;854        huart->TxXferCount = Size;
;;;855    
;;;856        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;857        huart->gState = HAL_UART_STATE_BUSY_TX;
;;;858    
;;;859        /* Process Unlocked */
;;;860        __HAL_UNLOCK(huart);
;;;861    
;;;862        /* Enable the UART Transmit Data Register Empty Interrupt */
;;;863        SET_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
;;;864    
;;;865        return HAL_OK;
;;;866      }
;;;867      else
;;;868      {
;;;869        return HAL_BUSY;
;;;870      }
;;;871    }
000024  bc10              POP      {r4}
000026  2001              MOVS     r0,#1                 ;845
000028  4770              BX       lr
                  |L37.42|
00002a  6e83              LDR      r3,[r0,#0x68]         ;850
00002c  2b01              CMP      r3,#1                 ;850
00002e  d011              BEQ      |L37.84|
000030  64c1              STR      r1,[r0,#0x4c]         ;853
000032  4601              MOV      r1,r0                 ;853
000034  3140              ADDS     r1,r1,#0x40           ;853
000036  820a              STRH     r2,[r1,#0x10]         ;853
000038  824a              STRH     r2,[r1,#0x12]         ;854
00003a  2100              MOVS     r1,#0                 ;856
00003c  6741              STR      r1,[r0,#0x74]         ;856
00003e  2221              MOVS     r2,#0x21              ;857
000040  66c2              STR      r2,[r0,#0x6c]         ;857
000042  6681              STR      r1,[r0,#0x68]         ;863
000044  6800              LDR      r0,[r0,#0]            ;863
000046  6801              LDR      r1,[r0,#0]            ;863
000048  2280              MOVS     r2,#0x80              ;863
00004a  4311              ORRS     r1,r1,r2              ;863
00004c  6001              STR      r1,[r0,#0]            ;863
00004e  bc10              POP      {r4}
000050  2000              MOVS     r0,#0                 ;865
000052  4770              BX       lr
                  |L37.84|
000054  bc10              POP      {r4}
000056  2002              MOVS     r0,#2                 ;869
000058  4770              BX       lr
;;;872    
                          ENDP


                          AREA ||i.HAL_UART_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxCpltCallback PROC
;;;1775     */
;;;1776   __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1777   {
;;;1778     /* Prevent unused argument(s) compilation warning */
;;;1779     UNUSED(huart);
;;;1780   
;;;1781     /* NOTE : This function should not be modified, when the callback is needed,
;;;1782               the HAL_UART_TxCpltCallback can be implemented in the user file.
;;;1783      */
;;;1784   }
;;;1785   
                          ENDP


                          AREA ||i.HAL_UART_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxHalfCpltCallback PROC
;;;1790     */
;;;1791   __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1792   {
;;;1793     /* Prevent unused argument(s) compilation warning */
;;;1794     UNUSED(huart);
;;;1795   
;;;1796     /* NOTE: This function should not be modified, when the callback is needed,
;;;1797              the HAL_UART_TxHalfCpltCallback can be implemented in the user file.
;;;1798      */
;;;1799   }
;;;1800   
                          ENDP


                          AREA ||i.UART_AdvFeatureConfig||, CODE, READONLY, ALIGN=1

                  UART_AdvFeatureConfig PROC
;;;2301     */
;;;2302   void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
000000  b410              PUSH     {r4}
;;;2303   {
;;;2304     /* Check whether the set of advanced features to configure is properly set */
;;;2305     assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
;;;2306   
;;;2307     /* if required, configure TX pin active level inversion */
;;;2308     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
000002  8c81              LDRH     r1,[r0,#0x24]
000004  07c9              LSLS     r1,r1,#31
000006  d007              BEQ      |L40.24|
;;;2309     {
;;;2310       assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
;;;2311       MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
000008  6801              LDR      r1,[r0,#0]
00000a  684a              LDR      r2,[r1,#4]
00000c  2301              MOVS     r3,#1
00000e  045b              LSLS     r3,r3,#17
000010  439a              BICS     r2,r2,r3
000012  6a83              LDR      r3,[r0,#0x28]
000014  431a              ORRS     r2,r2,r3
000016  604a              STR      r2,[r1,#4]
                  |L40.24|
;;;2312     }
;;;2313   
;;;2314     /* if required, configure RX pin active level inversion */
;;;2315     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
000018  8c81              LDRH     r1,[r0,#0x24]
00001a  0789              LSLS     r1,r1,#30
00001c  d507              BPL      |L40.46|
;;;2316     {
;;;2317       assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
;;;2318       MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
00001e  6801              LDR      r1,[r0,#0]
000020  684a              LDR      r2,[r1,#4]
000022  2301              MOVS     r3,#1
000024  041b              LSLS     r3,r3,#16
000026  439a              BICS     r2,r2,r3
000028  6ac3              LDR      r3,[r0,#0x2c]
00002a  431a              ORRS     r2,r2,r3
00002c  604a              STR      r2,[r1,#4]
                  |L40.46|
;;;2319     }
;;;2320   
;;;2321     /* if required, configure data inversion */
;;;2322     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
00002e  8c81              LDRH     r1,[r0,#0x24]
000030  0749              LSLS     r1,r1,#29
000032  d507              BPL      |L40.68|
;;;2323     {
;;;2324       assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
;;;2325       MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
000034  6801              LDR      r1,[r0,#0]
000036  684a              LDR      r2,[r1,#4]
000038  2301              MOVS     r3,#1
00003a  049b              LSLS     r3,r3,#18
00003c  439a              BICS     r2,r2,r3
00003e  6b03              LDR      r3,[r0,#0x30]
000040  431a              ORRS     r2,r2,r3
000042  604a              STR      r2,[r1,#4]
                  |L40.68|
;;;2326     }
;;;2327   
;;;2328     /* if required, configure RX/TX pins swap */
;;;2329     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
000044  8c81              LDRH     r1,[r0,#0x24]
000046  0709              LSLS     r1,r1,#28
000048  d507              BPL      |L40.90|
;;;2330     {
;;;2331       assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
;;;2332       MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
00004a  6801              LDR      r1,[r0,#0]
00004c  684a              LDR      r2,[r1,#4]
00004e  2301              MOVS     r3,#1
000050  03db              LSLS     r3,r3,#15
000052  439a              BICS     r2,r2,r3
000054  6b43              LDR      r3,[r0,#0x34]
000056  431a              ORRS     r2,r2,r3
000058  604a              STR      r2,[r1,#4]
                  |L40.90|
;;;2333     }
;;;2334   
;;;2335     /* if required, configure RX overrun detection disabling */
;;;2336     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
00005a  8c81              LDRH     r1,[r0,#0x24]
00005c  06c9              LSLS     r1,r1,#27
00005e  d507              BPL      |L40.112|
;;;2337     {
;;;2338       assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
;;;2339       MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
000060  6802              LDR      r2,[r0,#0]
000062  6891              LDR      r1,[r2,#8]
000064  2301              MOVS     r3,#1
000066  031b              LSLS     r3,r3,#12
000068  4399              BICS     r1,r1,r3
00006a  6b83              LDR      r3,[r0,#0x38]
00006c  4319              ORRS     r1,r1,r3
00006e  6091              STR      r1,[r2,#8]
                  |L40.112|
;;;2340     }
;;;2341   
;;;2342     /* if required, configure DMA disabling on reception error */
;;;2343     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
000070  8c81              LDRH     r1,[r0,#0x24]
000072  0689              LSLS     r1,r1,#26
000074  d507              BPL      |L40.134|
;;;2344     {
;;;2345       assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
;;;2346       MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
000076  6801              LDR      r1,[r0,#0]
000078  688a              LDR      r2,[r1,#8]
00007a  2301              MOVS     r3,#1
00007c  035b              LSLS     r3,r3,#13
00007e  439a              BICS     r2,r2,r3
000080  6bc3              LDR      r3,[r0,#0x3c]
000082  431a              ORRS     r2,r2,r3
000084  608a              STR      r2,[r1,#8]
                  |L40.134|
;;;2347     }
;;;2348   
;;;2349     /* if required, configure auto Baud rate detection scheme */
;;;2350     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
000086  8c81              LDRH     r1,[r0,#0x24]
000088  0649              LSLS     r1,r1,#25
00008a  d512              BPL      |L40.178|
;;;2351     {
;;;2352       assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
;;;2353       assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
;;;2354       MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
00008c  6803              LDR      r3,[r0,#0]
00008e  685a              LDR      r2,[r3,#4]
000090  2101              MOVS     r1,#1
000092  0509              LSLS     r1,r1,#20
000094  6c04              LDR      r4,[r0,#0x40]
000096  438a              BICS     r2,r2,r1
000098  4322              ORRS     r2,r2,r4
00009a  605a              STR      r2,[r3,#4]
;;;2355       /* set auto Baudrate detection parameters if detection is enabled */
;;;2356       if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
00009c  6c02              LDR      r2,[r0,#0x40]
00009e  428a              CMP      r2,r1
0000a0  d107              BNE      |L40.178|
;;;2357       {
;;;2358         assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
;;;2359         MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
0000a2  6802              LDR      r2,[r0,#0]
0000a4  6851              LDR      r1,[r2,#4]
0000a6  2303              MOVS     r3,#3
0000a8  055b              LSLS     r3,r3,#21
0000aa  4399              BICS     r1,r1,r3
0000ac  6c43              LDR      r3,[r0,#0x44]
0000ae  4319              ORRS     r1,r1,r3
0000b0  6051              STR      r1,[r2,#4]
                  |L40.178|
;;;2360       }
;;;2361     }
;;;2362   
;;;2363     /* if required, configure MSB first on communication line */
;;;2364     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
0000b2  8c81              LDRH     r1,[r0,#0x24]
0000b4  0609              LSLS     r1,r1,#24
0000b6  d507              BPL      |L40.200|
;;;2365     {
;;;2366       assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
;;;2367       MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
0000b8  6801              LDR      r1,[r0,#0]
0000ba  684a              LDR      r2,[r1,#4]
0000bc  2301              MOVS     r3,#1
0000be  04db              LSLS     r3,r3,#19
0000c0  6c80              LDR      r0,[r0,#0x48]
0000c2  439a              BICS     r2,r2,r3
0000c4  4302              ORRS     r2,r2,r0
0000c6  604a              STR      r2,[r1,#4]
                  |L40.200|
;;;2368     }
;;;2369   }
0000c8  bc10              POP      {r4}
0000ca  4770              BX       lr
;;;2370   
                          ENDP


                          AREA ||i.UART_CheckIdleState||, CODE, READONLY, ALIGN=2

                  UART_CheckIdleState PROC
;;;2375     */
;;;2376   HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2377   {
;;;2378     uint32_t tickstart = 0;
;;;2379   
;;;2380     /* Initialize the UART ErrorCode */
;;;2381     huart->ErrorCode = HAL_UART_ERROR_NONE;
000002  2500              MOVS     r5,#0
000004  4604              MOV      r4,r0                 ;2377
000006  6745              STR      r5,[r0,#0x74]
;;;2382   
;;;2383     /* Init tickstart for timeout managment*/
;;;2384     tickstart = HAL_GetTick();
000008  f7fffffe          BL       HAL_GetTick
00000c  4607              MOV      r7,r0
;;;2385   
;;;2386     /* Check if the Transmitter is enabled */
;;;2387     if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
00000e  6820              LDR      r0,[r4,#0]
000010  6800              LDR      r0,[r0,#0]
;;;2388     {
;;;2389       /* Wait until TEACK flag is set */
;;;2390       if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
000012  4e11              LDR      r6,|L41.88|
000014  0700              LSLS     r0,r0,#28             ;2387
000016  d509              BPL      |L41.44|
000018  2101              MOVS     r1,#1
00001a  463b              MOV      r3,r7
00001c  2200              MOVS     r2,#0
00001e  0549              LSLS     r1,r1,#21
000020  4620              MOV      r0,r4
000022  9600              STR      r6,[sp,#0]
000024  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000028  2800              CMP      r0,#0
00002a  d10d              BNE      |L41.72|
                  |L41.44|
;;;2391       {
;;;2392         /* Timeout occurred */
;;;2393         return HAL_TIMEOUT;
;;;2394       }
;;;2395     }
;;;2396     /* Check if the Receiver is enabled */
;;;2397     if((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
00002c  6820              LDR      r0,[r4,#0]
00002e  6800              LDR      r0,[r0,#0]
000030  0740              LSLS     r0,r0,#29
000032  d50b              BPL      |L41.76|
;;;2398     {
;;;2399       /* Wait until REACK flag is set */
;;;2400       if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
000034  2101              MOVS     r1,#1
000036  463b              MOV      r3,r7
000038  2200              MOVS     r2,#0
00003a  0589              LSLS     r1,r1,#22
00003c  4620              MOV      r0,r4
00003e  9600              STR      r6,[sp,#0]
000040  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000044  2800              CMP      r0,#0
000046  d001              BEQ      |L41.76|
                  |L41.72|
;;;2401       {
;;;2402         /* Timeout occurred */
;;;2403         return HAL_TIMEOUT;
000048  2003              MOVS     r0,#3
;;;2404       }
;;;2405     }
;;;2406   
;;;2407     /* Initialize the UART State */
;;;2408     huart->gState  = HAL_UART_STATE_READY;
;;;2409     huart->RxState = HAL_UART_STATE_READY;
;;;2410   
;;;2411     /* Process Unlocked */
;;;2412     __HAL_UNLOCK(huart);
;;;2413   
;;;2414     return HAL_OK;
;;;2415   }
00004a  bdf8              POP      {r3-r7,pc}
                  |L41.76|
00004c  2020              MOVS     r0,#0x20              ;2408
00004e  66e0              STR      r0,[r4,#0x6c]         ;2408
000050  6720              STR      r0,[r4,#0x70]         ;2409
000052  2000              MOVS     r0,#0                 ;2414
000054  66a5              STR      r5,[r4,#0x68]         ;2414
000056  bdf8              POP      {r3-r7,pc}
;;;2416   
                          ENDP

                  |L41.88|
                          DCD      0x01ffffff

                          AREA ||i.UART_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  UART_DMAAbortOnError PROC
;;;2600     */
;;;2601   static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2602   {
;;;2603     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)(hdma->Parent);
000002  6ac0              LDR      r0,[r0,#0x2c]
;;;2604     huart->RxXferCount = 0;
000004  2200              MOVS     r2,#0
000006  4601              MOV      r1,r0
000008  3140              ADDS     r1,r1,#0x40
00000a  834a              STRH     r2,[r1,#0x1a]
;;;2605     huart->TxXferCount = 0;
00000c  824a              STRH     r2,[r1,#0x12]
;;;2606   
;;;2607     HAL_UART_ErrorCallback(huart);
00000e  f7fffffe          BL       HAL_UART_ErrorCallback
;;;2608   }
000012  bd10              POP      {r4,pc}
;;;2609   
                          ENDP


                          AREA ||i.UART_DMAError||, CODE, READONLY, ALIGN=1

                  UART_DMAError PROC
;;;2570     */
;;;2571   static void UART_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2572   {
;;;2573     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)(hdma->Parent);
000002  6ac0              LDR      r0,[r0,#0x2c]
;;;2574   
;;;2575     /* Stop UART DMA Tx request if ongoing */
;;;2576     if (  (huart->gState == HAL_UART_STATE_BUSY_TX)
000004  6ec1              LDR      r1,[r0,#0x6c]
000006  2200              MOVS     r2,#0
000008  2320              MOVS     r3,#0x20
00000a  2921              CMP      r1,#0x21
00000c  d10b              BNE      |L43.38|
;;;2577         &&(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) )
00000e  6801              LDR      r1,[r0,#0]
000010  6889              LDR      r1,[r1,#8]
000012  0609              LSLS     r1,r1,#24
000014  d507              BPL      |L43.38|
;;;2578     {
;;;2579       huart->TxXferCount = 0;
000016  2152              MOVS     r1,#0x52
000018  520a              STRH     r2,[r1,r0]
00001a  6801              LDR      r1,[r0,#0]
00001c  680c              LDR      r4,[r1,#0]
00001e  25c0              MOVS     r5,#0xc0
000020  43ac              BICS     r4,r4,r5
000022  600c              STR      r4,[r1,#0]
000024  66c3              STR      r3,[r0,#0x6c]
                  |L43.38|
;;;2580       UART_EndTxTransfer(huart);
;;;2581     }
;;;2582   
;;;2583     /* Stop UART DMA Rx request if ongoing */
;;;2584     if (  (huart->RxState == HAL_UART_STATE_BUSY_RX)
000026  6f01              LDR      r1,[r0,#0x70]
000028  2922              CMP      r1,#0x22
00002a  d110              BNE      |L43.78|
;;;2585         &&(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) )
00002c  6801              LDR      r1,[r0,#0]
00002e  688c              LDR      r4,[r1,#8]
000030  0664              LSLS     r4,r4,#25
000032  d50c              BPL      |L43.78|
;;;2586     {
;;;2587       huart->RxXferCount = 0;
000034  245a              MOVS     r4,#0x5a
000036  5222              STRH     r2,[r4,r0]
000038  680a              LDR      r2,[r1,#0]
00003a  24ff              MOVS     r4,#0xff
00003c  3421              ADDS     r4,r4,#0x21
00003e  43a2              BICS     r2,r2,r4
000040  600a              STR      r2,[r1,#0]
000042  6801              LDR      r1,[r0,#0]
000044  688a              LDR      r2,[r1,#8]
000046  0852              LSRS     r2,r2,#1
000048  0052              LSLS     r2,r2,#1
00004a  608a              STR      r2,[r1,#8]
00004c  6703              STR      r3,[r0,#0x70]
                  |L43.78|
;;;2588       UART_EndRxTransfer(huart);
;;;2589     }
;;;2590   
;;;2591     huart->ErrorCode |= HAL_UART_ERROR_DMA;
00004e  6f41              LDR      r1,[r0,#0x74]
000050  2210              MOVS     r2,#0x10
000052  4311              ORRS     r1,r1,r2
000054  6741              STR      r1,[r0,#0x74]
;;;2592     HAL_UART_ErrorCallback(huart);
000056  f7fffffe          BL       HAL_UART_ErrorCallback
;;;2593   }
00005a  bd70              POP      {r4-r6,pc}
;;;2594   
                          ENDP


                          AREA ||i.UART_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  UART_DMAReceiveCplt PROC
;;;2529     */
;;;2530   static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2531   {
000002  4601              MOV      r1,r0
;;;2532     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)(hdma->Parent);
;;;2533   
;;;2534     /* DMA Normal mode */
;;;2535     if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
000004  6809              LDR      r1,[r1,#0]
000006  6ac0              LDR      r0,[r0,#0x2c]         ;2532
000008  6809              LDR      r1,[r1,#0]
00000a  0689              LSLS     r1,r1,#26
00000c  d414              BMI      |L44.56|
;;;2536     {
;;;2537       huart->RxXferCount = 0U;
00000e  2200              MOVS     r2,#0
000010  215a              MOVS     r1,#0x5a
000012  520a              STRH     r2,[r1,r0]
;;;2538   
;;;2539       /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2540       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
000014  6801              LDR      r1,[r0,#0]
000016  680a              LDR      r2,[r1,#0]
000018  23ff              MOVS     r3,#0xff
00001a  3301              ADDS     r3,#1
00001c  439a              BICS     r2,r2,r3
00001e  600a              STR      r2,[r1,#0]
;;;2541       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000020  6801              LDR      r1,[r0,#0]
000022  688a              LDR      r2,[r1,#8]
000024  0852              LSRS     r2,r2,#1
000026  0052              LSLS     r2,r2,#1
000028  608a              STR      r2,[r1,#8]
;;;2542   
;;;2543       /* Disable the DMA transfer for the receiver request by resetting the DMAR bit
;;;2544          in the UART CR3 register */
;;;2545       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
00002a  6801              LDR      r1,[r0,#0]
00002c  688a              LDR      r2,[r1,#8]
00002e  2340              MOVS     r3,#0x40
000030  439a              BICS     r2,r2,r3
000032  608a              STR      r2,[r1,#8]
;;;2546   
;;;2547       /* At end of Rx process, restore huart->RxState to Ready */
;;;2548       huart->RxState = HAL_UART_STATE_READY;
000034  2120              MOVS     r1,#0x20
000036  6701              STR      r1,[r0,#0x70]
                  |L44.56|
;;;2549     }
;;;2550   
;;;2551     HAL_UART_RxCpltCallback(huart);
000038  f7fffffe          BL       HAL_UART_RxCpltCallback
;;;2552   }
00003c  bd10              POP      {r4,pc}
;;;2553   
                          ENDP


                          AREA ||i.UART_DMARxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxAbortCallback PROC
;;;2659     */
;;;2660   static void UART_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2661   {
;;;2662     UART_HandleTypeDef* huart = (UART_HandleTypeDef* )(hdma->Parent);
000002  6ac0              LDR      r0,[r0,#0x2c]
;;;2663     
;;;2664     huart->hdmarx->XferAbortCallback = NULL;
000004  2100              MOVS     r1,#0
000006  6e42              LDR      r2,[r0,#0x64]
;;;2665   
;;;2666     /* Check if an Abort process is still ongoing */
;;;2667     if(huart->hdmatx != NULL)
000008  63d1              STR      r1,[r2,#0x3c]
00000a  6e02              LDR      r2,[r0,#0x60]
00000c  2a00              CMP      r2,#0
00000e  d002              BEQ      |L45.22|
;;;2668     {
;;;2669       if(huart->hdmatx->XferAbortCallback != NULL)
000010  6bd2              LDR      r2,[r2,#0x3c]
000012  2a00              CMP      r2,#0
000014  d10c              BNE      |L45.48|
                  |L45.22|
;;;2670       {
;;;2671         return;
;;;2672       }
;;;2673     }
;;;2674     
;;;2675     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;2676     huart->TxXferCount = 0;
000016  4602              MOV      r2,r0
000018  3240              ADDS     r2,r2,#0x40
00001a  8251              STRH     r1,[r2,#0x12]
;;;2677     huart->RxXferCount = 0;
00001c  8351              STRH     r1,[r2,#0x1a]
;;;2678   
;;;2679     /* Reset errorCode */
;;;2680     huart->ErrorCode = HAL_UART_ERROR_NONE;
00001e  6741              STR      r1,[r0,#0x74]
;;;2681   
;;;2682     /* Clear the Error flags in the ICR register */
;;;2683     __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
000020  6802              LDR      r2,[r0,#0]
000022  210f              MOVS     r1,#0xf
000024  6211              STR      r1,[r2,#0x20]
;;;2684   
;;;2685     /* Restore huart->gState and huart->RxState to Ready */
;;;2686     huart->gState  = HAL_UART_STATE_READY;
000026  2120              MOVS     r1,#0x20
000028  66c1              STR      r1,[r0,#0x6c]
;;;2687     huart->RxState = HAL_UART_STATE_READY;
00002a  6701              STR      r1,[r0,#0x70]
;;;2688   
;;;2689     /* Call user Abort complete callback */
;;;2690     HAL_UART_AbortCpltCallback(huart);
00002c  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L45.48|
;;;2691   }
000030  bd10              POP      {r4,pc}
;;;2692   
                          ENDP


                          AREA ||i.UART_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMARxHalfCplt PROC
;;;2558     */
;;;2559   static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2560   {
;;;2561     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)(hdma->Parent);
000002  6ac0              LDR      r0,[r0,#0x2c]
;;;2562   
;;;2563     HAL_UART_RxHalfCpltCallback(huart);
000004  f7fffffe          BL       HAL_UART_RxHalfCpltCallback
;;;2564   }
000008  bd10              POP      {r4,pc}
;;;2565   
                          ENDP


                          AREA ||i.UART_DMARxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxOnlyAbortCallback PROC
;;;2722     */
;;;2723   static void UART_DMARxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2724   {
;;;2725     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6ac0              LDR      r0,[r0,#0x2c]
;;;2726   
;;;2727     huart->RxXferCount = 0;
000004  2200              MOVS     r2,#0
000006  215a              MOVS     r1,#0x5a
000008  520a              STRH     r2,[r1,r0]
;;;2728   
;;;2729     /* Clear the Error flags in the ICR register */
;;;2730     __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
00000a  6802              LDR      r2,[r0,#0]
00000c  210f              MOVS     r1,#0xf
00000e  6211              STR      r1,[r2,#0x20]
;;;2731   
;;;2732     /* Restore huart->RxState to Ready */
;;;2733     huart->RxState = HAL_UART_STATE_READY;
000010  2120              MOVS     r1,#0x20
000012  6701              STR      r1,[r0,#0x70]
;;;2734   
;;;2735     /* Call user Abort complete callback */
;;;2736     HAL_UART_AbortReceiveCpltCallback(huart);
000014  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
;;;2737   }
000018  bd10              POP      {r4,pc}
;;;2738   
                          ENDP


                          AREA ||i.UART_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATransmitCplt PROC
;;;2488     */
;;;2489   static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2490   {
000002  4601              MOV      r1,r0
;;;2491     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)(hdma->Parent);
;;;2492     
;;;2493     /* DMA Normal mode */
;;;2494     if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
000004  6809              LDR      r1,[r1,#0]
000006  6ac0              LDR      r0,[r0,#0x2c]         ;2491
000008  6809              LDR      r1,[r1,#0]
00000a  0689              LSLS     r1,r1,#26
00000c  d40d              BMI      |L48.42|
;;;2495     {
;;;2496       huart->TxXferCount = 0U;
00000e  2200              MOVS     r2,#0
000010  2152              MOVS     r1,#0x52
000012  520a              STRH     r2,[r1,r0]
;;;2497   
;;;2498       /* Disable the DMA transfer for transmit request by resetting the DMAT bit
;;;2499          in the UART CR3 register */
;;;2500       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000014  6801              LDR      r1,[r0,#0]
000016  688a              LDR      r2,[r1,#8]
000018  2380              MOVS     r3,#0x80
00001a  439a              BICS     r2,r2,r3
00001c  608a              STR      r2,[r1,#8]
;;;2501   
;;;2502       /* Enable the UART Transmit Complete Interrupt */
;;;2503       SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
00001e  6800              LDR      r0,[r0,#0]
000020  6801              LDR      r1,[r0,#0]
000022  2240              MOVS     r2,#0x40
000024  4311              ORRS     r1,r1,r2
000026  6001              STR      r1,[r0,#0]
;;;2504     }
;;;2505     /* DMA Circular mode */
;;;2506     else
;;;2507     {
;;;2508       HAL_UART_TxCpltCallback(huart);
;;;2509     }
;;;2510   
;;;2511   }
000028  bd10              POP      {r4,pc}
                  |L48.42|
00002a  f7fffffe          BL       HAL_UART_TxCpltCallback
00002e  bd10              POP      {r4,pc}
;;;2512   
                          ENDP


                          AREA ||i.UART_DMATxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxAbortCallback PROC
;;;2617     */
;;;2618   static void UART_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2619   {
;;;2620     UART_HandleTypeDef* huart = (UART_HandleTypeDef* )(hdma->Parent);
000002  6ac0              LDR      r0,[r0,#0x2c]
;;;2621     
;;;2622     huart->hdmatx->XferAbortCallback = NULL;
000004  2100              MOVS     r1,#0
000006  6e02              LDR      r2,[r0,#0x60]
;;;2623   
;;;2624     /* Check if an Abort process is still ongoing */
;;;2625     if(huart->hdmarx != NULL)
000008  63d1              STR      r1,[r2,#0x3c]
00000a  6e42              LDR      r2,[r0,#0x64]
00000c  2a00              CMP      r2,#0
00000e  d002              BEQ      |L49.22|
;;;2626     {
;;;2627       if(huart->hdmarx->XferAbortCallback != NULL)
000010  6bd2              LDR      r2,[r2,#0x3c]
000012  2a00              CMP      r2,#0
000014  d10c              BNE      |L49.48|
                  |L49.22|
;;;2628       {
;;;2629         return;
;;;2630       }
;;;2631     }
;;;2632     
;;;2633     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;2634     huart->TxXferCount = 0;
000016  4602              MOV      r2,r0
000018  3240              ADDS     r2,r2,#0x40
00001a  8251              STRH     r1,[r2,#0x12]
;;;2635     huart->RxXferCount = 0;
00001c  8351              STRH     r1,[r2,#0x1a]
;;;2636   
;;;2637     /* Reset errorCode */
;;;2638     huart->ErrorCode = HAL_UART_ERROR_NONE;
00001e  6741              STR      r1,[r0,#0x74]
;;;2639   
;;;2640     /* Clear the Error flags in the ICR register */
;;;2641     __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
000020  6802              LDR      r2,[r0,#0]
000022  210f              MOVS     r1,#0xf
000024  6211              STR      r1,[r2,#0x20]
;;;2642   
;;;2643     /* Restore huart->gState and huart->RxState to Ready */
;;;2644     huart->gState  = HAL_UART_STATE_READY;
000026  2120              MOVS     r1,#0x20
000028  66c1              STR      r1,[r0,#0x6c]
;;;2645     huart->RxState = HAL_UART_STATE_READY;
00002a  6701              STR      r1,[r0,#0x70]
;;;2646   
;;;2647     /* Call user Abort complete callback */
;;;2648     HAL_UART_AbortCpltCallback(huart);
00002c  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L49.48|
;;;2649   }
000030  bd10              POP      {r4,pc}
;;;2650   
                          ENDP


                          AREA ||i.UART_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATxHalfCplt PROC
;;;2517     */
;;;2518   static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2519   {
;;;2520     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)(hdma->Parent);
000002  6ac0              LDR      r0,[r0,#0x2c]
;;;2521   
;;;2522     HAL_UART_TxHalfCpltCallback(huart);
000004  f7fffffe          BL       HAL_UART_TxHalfCpltCallback
;;;2523   }
000008  bd10              POP      {r4,pc}
;;;2524   
                          ENDP


                          AREA ||i.UART_DMATxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxOnlyAbortCallback PROC
;;;2701     */
;;;2702   static void UART_DMATxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2703   {
;;;2704     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)(hdma->Parent);
000002  6ac0              LDR      r0,[r0,#0x2c]
;;;2705   
;;;2706     huart->TxXferCount = 0;
000004  2200              MOVS     r2,#0
000006  2152              MOVS     r1,#0x52
000008  520a              STRH     r2,[r1,r0]
;;;2707   
;;;2708     /* Restore huart->gState to Ready */
;;;2709     huart->gState = HAL_UART_STATE_READY;
00000a  2120              MOVS     r1,#0x20
00000c  66c1              STR      r1,[r0,#0x6c]
;;;2710   
;;;2711     /* Call user Abort complete callback */
;;;2712     HAL_UART_AbortTransmitCpltCallback(huart);
00000e  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
;;;2713   }
000012  bd10              POP      {r4,pc}
;;;2714   
                          ENDP


                          AREA ||i.UART_SetConfig||, CODE, READONLY, ALIGN=2

                  UART_SetConfig PROC
;;;2106     */
;;;2107   HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2108   {
000002  4604              MOV      r4,r0
;;;2109     uint32_t tmpreg                     = 0x00000000U;
;;;2110     UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
;;;2111     uint16_t brrtemp                    = 0x0000U;
;;;2112     uint16_t usartdiv                   = 0x0000U;
;;;2113     HAL_StatusTypeDef ret               = HAL_OK;
;;;2114   
;;;2115     /* Check the parameters */
;;;2116     assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
;;;2117     assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;2118     if(UART_INSTANCE_LOWPOWER(huart))
;;;2119     {
;;;2120       assert_param(IS_LPUART_STOPBITS(huart->Init.StopBits));
;;;2121     }
;;;2122     else
;;;2123     {
;;;2124       assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
;;;2125       assert_param(IS_UART_ONE_BIT_SAMPLE(huart->Init.OneBitSampling));
;;;2126     }
;;;2127   
;;;2128     assert_param(IS_UART_PARITY(huart->Init.Parity));
;;;2129     assert_param(IS_UART_MODE(huart->Init.Mode));
;;;2130     assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
;;;2131     assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;2132   
;;;2133   
;;;2134     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;2135     /* Clear M, PCE, PS, TE, RE and OVER8 bits and configure
;;;2136      *  the UART Word Length, Parity, Mode and oversampling:
;;;2137      *  set the M bits according to huart->Init.WordLength value
;;;2138      *  set PCE and PS bits according to huart->Init.Parity value
;;;2139      *  set TE and RE bits according to huart->Init.Mode value
;;;2140      *  set OVER8 bit according to huart->Init.OverSampling value */
;;;2141     tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
000004  6801              LDR      r1,[r0,#0]
000006  6880              LDR      r0,[r0,#8]
000008  6922              LDR      r2,[r4,#0x10]
00000a  69e3              LDR      r3,[r4,#0x1c]
00000c  4310              ORRS     r0,r0,r2
00000e  6962              LDR      r2,[r4,#0x14]
000010  2510              MOVS     r5,#0x10              ;2110
000012  2600              MOVS     r6,#0                 ;2112
000014  431a              ORRS     r2,r2,r3
000016  4310              ORRS     r0,r0,r2
;;;2142     MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
000018  680a              LDR      r2,[r1,#0]
00001a  4637              MOV      r7,r6                 ;2113
00001c  4b94              LDR      r3,|L52.624|
00001e  401a              ANDS     r2,r2,r3
000020  4302              ORRS     r2,r2,r0
000022  600a              STR      r2,[r1,#0]
;;;2143   
;;;2144     /*-------------------------- USART CR2 Configuration -----------------------*/
;;;2145     /* Configure the UART Stop Bits: Set STOP[13:12] bits according
;;;2146      * to huart->Init.StopBits value */
;;;2147     MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
000024  6821              LDR      r1,[r4,#0]
000026  6848              LDR      r0,[r1,#4]
000028  2203              MOVS     r2,#3
00002a  0312              LSLS     r2,r2,#12
00002c  4390              BICS     r0,r0,r2
00002e  68e2              LDR      r2,[r4,#0xc]
000030  4310              ORRS     r0,r0,r2
000032  6048              STR      r0,[r1,#4]
;;;2148   
;;;2149     /*-------------------------- USART CR3 Configuration -----------------------*/
;;;2150     /* Configure
;;;2151      * - UART HardWare Flow Control: set CTSE and RTSE bits according
;;;2152      *   to huart->Init.HwFlowCtl value
;;;2153      * - one-bit sampling method versus three samples' majority rule according
;;;2154      *   to huart->Init.OneBitSampling (not applicable to LPUART) */
;;;2155     tmpreg = (uint32_t)huart->Init.HwFlowCtl;
;;;2156     if (!(UART_INSTANCE_LOWPOWER(huart)))
000034  4a8f              LDR      r2,|L52.628|
000036  6821              LDR      r1,[r4,#0]
000038  69a0              LDR      r0,[r4,#0x18]
00003a  4291              CMP      r1,r2
00003c  d001              BEQ      |L52.66|
;;;2157     {
;;;2158       tmpreg |= huart->Init.OneBitSampling;
00003e  6a22              LDR      r2,[r4,#0x20]
000040  4310              ORRS     r0,r0,r2
                  |L52.66|
;;;2159     }
;;;2160     MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
000042  688a              LDR      r2,[r1,#8]
000044  230b              MOVS     r3,#0xb
000046  021b              LSLS     r3,r3,#8
000048  439a              BICS     r2,r2,r3
00004a  4302              ORRS     r2,r2,r0
00004c  608a              STR      r2,[r1,#8]
;;;2161   
;;;2162     /*-------------------------- USART BRR Configuration -----------------------*/
;;;2163     UART_GETCLOCKSOURCE(huart, clocksource);
00004e  4a8a              LDR      r2,|L52.632|
000050  6821              LDR      r1,[r4,#0]
000052  488a              LDR      r0,|L52.636|
000054  4291              CMP      r1,r2
000056  d10c              BNE      |L52.114|
000058  68c0              LDR      r0,[r0,#0xc]
00005a  0780              LSLS     r0,r0,#30
00005c  0f80              LSRS     r0,r0,#30
00005e  d006              BEQ      |L52.110|
000060  2801              CMP      r0,#1
000062  d03c              BEQ      |L52.222|
000064  2802              CMP      r0,#2
000066  d038              BEQ      |L52.218|
000068  2803              CMP      r0,#3
00006a  d120              BNE      |L52.174|
00006c  e01e              B        |L52.172|
                  |L52.110|
00006e  2501              MOVS     r5,#1
000070  e01d              B        |L52.174|
                  |L52.114|
000072  4a83              LDR      r2,|L52.640|
000074  4291              CMP      r1,r2
000076  d10a              BNE      |L52.142|
000078  68c0              LDR      r0,[r0,#0xc]
00007a  210c              MOVS     r1,#0xc
00007c  4008              ANDS     r0,r0,r1
00007e  d02a              BEQ      |L52.214|
000080  2804              CMP      r0,#4
000082  d02c              BEQ      |L52.222|
000084  2808              CMP      r0,#8
000086  d028              BEQ      |L52.218|
000088  280c              CMP      r0,#0xc
00008a  d110              BNE      |L52.174|
00008c  e00e              B        |L52.172|
                  |L52.142|
00008e  4a79              LDR      r2,|L52.628|
000090  4291              CMP      r1,r2
000092  d10c              BNE      |L52.174|
000094  68c1              LDR      r1,[r0,#0xc]
000096  2003              MOVS     r0,#3
000098  0280              LSLS     r0,r0,#10
00009a  4001              ANDS     r1,r1,r0
00009c  d01b              BEQ      |L52.214|
00009e  1510              ASRS     r0,r2,#20
0000a0  1a09              SUBS     r1,r1,r0
0000a2  d01c              BEQ      |L52.222|
0000a4  1a09              SUBS     r1,r1,r0
0000a6  d018              BEQ      |L52.218|
0000a8  4281              CMP      r1,r0
0000aa  d100              BNE      |L52.174|
                  |L52.172|
0000ac  2508              MOVS     r5,#8
                  |L52.174|
;;;2164     uint32_t frequency = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_USART2);
0000ae  2002              MOVS     r0,#2
0000b0  f7fffffe          BL       HAL_RCCEx_GetPeriphCLKFreq
;;;2165   
;;;2166     /* Check LPUART instance */
;;;2167     if(UART_INSTANCE_LOWPOWER(huart))
0000b4  4b6f              LDR      r3,|L52.628|
0000b6  4684              MOV      r12,r0                ;2164
0000b8  6822              LDR      r2,[r4,#0]
;;;2168     {
;;;2169       /* Retrieve frequency clock */
;;;2170       tmpreg = 0;
;;;2171   
;;;2172       switch (clocksource)
;;;2173       {
;;;2174       case UART_CLOCKSOURCE_PCLK1:
;;;2175         tmpreg = HAL_RCC_GetPCLK1Freq();
;;;2176         break;
;;;2177       case UART_CLOCKSOURCE_HSI:
;;;2178         if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
0000ba  4972              LDR      r1,|L52.644|
;;;2179         {
;;;2180           tmpreg = (uint32_t) (HSI_VALUE >> 2U);
;;;2181         }
;;;2182         else
;;;2183         {
;;;2184           tmpreg = (uint32_t) HSI_VALUE;
;;;2185         }
;;;2186         break;
;;;2187       case UART_CLOCKSOURCE_SYSCLK:
;;;2188         tmpreg = HAL_RCC_GetSysClockFreq();
;;;2189         break;
;;;2190       case UART_CLOCKSOURCE_LSE:
;;;2191         tmpreg = (uint32_t) LSE_VALUE;
0000bc  13d8              ASRS     r0,r3,#15
0000be  9200              STR      r2,[sp,#0]            ;2167
0000c0  429a              CMP      r2,r3                 ;2167
0000c2  d137              BNE      |L52.308|
0000c4  2d00              CMP      r5,#0                 ;2172
0000c6  d00c              BEQ      |L52.226|
0000c8  2d02              CMP      r5,#2                 ;2172
0000ca  d00d              BEQ      |L52.232|
0000cc  2d04              CMP      r5,#4                 ;2172
0000ce  d012              BEQ      |L52.246|
0000d0  2d08              CMP      r5,#8                 ;2172
0000d2  d11c              BNE      |L52.270|
0000d4  e013              B        |L52.254|
                  |L52.214|
0000d6  2500              MOVS     r5,#0                 ;2163
0000d8  e7e9              B        |L52.174|
                  |L52.218|
0000da  2502              MOVS     r5,#2                 ;2163
0000dc  e7e7              B        |L52.174|
                  |L52.222|
0000de  2504              MOVS     r5,#4                 ;2163
0000e0  e7e5              B        |L52.174|
                  |L52.226|
0000e2  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0000e6  e008              B        |L52.250|
                  |L52.232|
0000e8  6808              LDR      r0,[r1,#0]            ;2178
0000ea  06c0              LSLS     r0,r0,#27             ;2178
0000ec  d501              BPL      |L52.242|
0000ee  4866              LDR      r0,|L52.648|
0000f0  e005              B        |L52.254|
                  |L52.242|
0000f2  4866              LDR      r0,|L52.652|
0000f4  e003              B        |L52.254|
                  |L52.246|
0000f6  f7fffffe          BL       HAL_RCC_GetSysClockFreq
                  |L52.250|
;;;2192         break;
;;;2193       case UART_CLOCKSOURCE_UNDEFINED:
;;;2194       default:
;;;2195           ret = HAL_ERROR;
;;;2196         break;
;;;2197       }
;;;2198   
;;;2199       /* if proper clock source reported */
;;;2200       if (tmpreg != 0)
0000fa  2800              CMP      r0,#0
0000fc  d069              BEQ      |L52.466|
                  |L52.254|
;;;2201       {
;;;2202         /* ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
;;;2203         if ( (tmpreg < (3 * huart->Init.BaudRate) ) ||
0000fe  6862              LDR      r2,[r4,#4]
000100  0051              LSLS     r1,r2,#1
000102  1851              ADDS     r1,r2,r1
000104  4281              CMP      r1,r0
000106  d802              BHI      |L52.270|
;;;2204              (tmpreg > (4096 * huart->Init.BaudRate) ))
000108  0311              LSLS     r1,r2,#12
00010a  4281              CMP      r1,r0
00010c  d201              BCS      |L52.274|
                  |L52.270|
00010e  2701              MOVS     r7,#1                 ;2195
000110  e0ac              B        |L52.620|
                  |L52.274|
;;;2205         {
;;;2206           ret = HAL_ERROR;
;;;2207         }
;;;2208         else
;;;2209         {
;;;2210           tmpreg = (uint32_t)(UART_DIV_LPUART(tmpreg, huart->Init.BaudRate));
000112  0e01              LSRS     r1,r0,#24
000114  0205              LSLS     r5,r0,#8
000116  0850              LSRS     r0,r2,#1
000118  2300              MOVS     r3,#0
00011a  1828              ADDS     r0,r5,r0
00011c  4159              ADCS     r1,r1,r3
00011e  f7fffffe          BL       __aeabi_uldivmod
;;;2211      
;;;2212           if ((tmpreg >= UART_LPUART_BRR_MIN) && (tmpreg <= UART_LPUART_BRR_MAX))
000122  2103              MOVS     r1,#3
000124  0209              LSLS     r1,r1,#8
000126  4a5a              LDR      r2,|L52.656|
000128  1a41              SUBS     r1,r0,r1
00012a  4291              CMP      r1,r2
00012c  d8ef              BHI      |L52.270|
;;;2213           {
;;;2214              huart->Instance->BRR = tmpreg;
00012e  6821              LDR      r1,[r4,#0]
000130  60c8              STR      r0,[r1,#0xc]
000132  e09b              B        |L52.620|
                  |L52.308|
;;;2215           }
;;;2216           else
;;;2217           {
;;;2218             ret = HAL_ERROR;
;;;2219           }
;;;2220         }  /*   if ( (tmpreg < (3 * huart->Init.BaudRate) ) || (tmpreg > (4096 * huart->Init.BaudRate) )) */
;;;2221       } /* if (tmpreg != 0) */
;;;2222     }
;;;2223     /* Check UART Over Sampling to set Baud Rate Register */
;;;2224     else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
000134  69e2              LDR      r2,[r4,#0x1c]
000136  4282              CMP      r2,r0
000138  d14c              BNE      |L52.468|
;;;2225     {
;;;2226       switch (clocksource)
00013a  2d09              CMP      r5,#9
00013c  d241              BCS      |L52.450|
00013e  0028              MOVS     r0,r5
000140  4478              ADD      r0,r0,pc
000142  7900              LDRB     r0,[r0,#4]
000144  1800              ADDS     r0,r0,r0
000146  4487              ADD      pc,pc,r0
000148  040d173c          DCB      0x04,0x0d,0x17,0x3c
00014c  293c3c3c          DCB      0x29,0x3c,0x3c,0x3c
000150  3300              DCB      0x33,0x00
;;;2227       {
;;;2228       case UART_CLOCKSOURCE_PCLK1:
;;;2229         usartdiv = (uint16_t)(UART_DIV_SAMPLING8(frequency, huart->Init.BaudRate));
000152  6861              LDR      r1,[r4,#4]
000154  4660              MOV      r0,r12
000156  0040              LSLS     r0,r0,#1
000158  084a              LSRS     r2,r1,#1
00015a  1880              ADDS     r0,r0,r2
00015c  f7fffffe          BL       __aeabi_uidivmod
000160  b286              UXTH     r6,r0
;;;2230         break;
000162  e02f              B        |L52.452|
;;;2231       case UART_CLOCKSOURCE_PCLK2:
;;;2232         usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
000164  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000168  6861              LDR      r1,[r4,#4]
00016a  0040              LSLS     r0,r0,#1
00016c  084a              LSRS     r2,r1,#1
00016e  1880              ADDS     r0,r0,r2
000170  f7fffffe          BL       __aeabi_uidivmod
000174  b286              UXTH     r6,r0
;;;2233         break;
000176  e025              B        |L52.452|
;;;2234       case UART_CLOCKSOURCE_HSI:
;;;2235         if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
000178  6808              LDR      r0,[r1,#0]
00017a  6861              LDR      r1,[r4,#4]
00017c  06c0              LSLS     r0,r0,#27
00017e  d506              BPL      |L52.398|
;;;2236         {
;;;2237           usartdiv = (uint16_t)(UART_DIV_SAMPLING8((HSI_VALUE >> 2U), huart->Init.BaudRate));
000180  4a44              LDR      r2,|L52.660|
000182  0848              LSRS     r0,r1,#1
000184  1880              ADDS     r0,r0,r2
000186  f7fffffe          BL       __aeabi_uidivmod
00018a  b286              UXTH     r6,r0
00018c  e01a              B        |L52.452|
                  |L52.398|
;;;2238         }
;;;2239         else
;;;2240         {
;;;2241           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate)); 
00018e  4a42              LDR      r2,|L52.664|
000190  0848              LSRS     r0,r1,#1
000192  1880              ADDS     r0,r0,r2
000194  f7fffffe          BL       __aeabi_uidivmod
000198  b286              UXTH     r6,r0
00019a  e013              B        |L52.452|
;;;2242         }
;;;2243         break;
;;;2244       case UART_CLOCKSOURCE_SYSCLK:
;;;2245         usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
00019c  f7fffffe          BL       HAL_RCC_GetSysClockFreq
0001a0  6861              LDR      r1,[r4,#4]
0001a2  0040              LSLS     r0,r0,#1
0001a4  084a              LSRS     r2,r1,#1
0001a6  1880              ADDS     r0,r0,r2
0001a8  f7fffffe          BL       __aeabi_uidivmod
0001ac  b286              UXTH     r6,r0
;;;2246         break;
0001ae  e009              B        |L52.452|
;;;2247       case UART_CLOCKSOURCE_LSE:
;;;2248         usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
0001b0  6861              LDR      r1,[r4,#4]
0001b2  2201              MOVS     r2,#1
0001b4  0848              LSRS     r0,r1,#1
0001b6  0412              LSLS     r2,r2,#16
0001b8  1880              ADDS     r0,r0,r2
0001ba  f7fffffe          BL       __aeabi_uidivmod
0001be  b286              UXTH     r6,r0
;;;2249         break;
0001c0  e000              B        |L52.452|
                  |L52.450|
;;;2250       case UART_CLOCKSOURCE_UNDEFINED:
;;;2251       default:
;;;2252           ret = HAL_ERROR;
0001c2  2701              MOVS     r7,#1
                  |L52.452|
;;;2253         break;
;;;2254       }
;;;2255   
;;;2256       brrtemp = usartdiv & 0xFFF0U;
0001c4  0931              LSRS     r1,r6,#4
0001c6  0109              LSLS     r1,r1,#4
;;;2257       brrtemp |= (uint16_t)((uint16_t)(usartdiv & (uint16_t)0x000FU) >> (uint16_t)1U);
0001c8  0730              LSLS     r0,r6,#28
0001ca  0f40              LSRS     r0,r0,#29
0001cc  4308              ORRS     r0,r0,r1
;;;2258       huart->Instance->BRR = brrtemp;
0001ce  6821              LDR      r1,[r4,#0]
0001d0  60c8              STR      r0,[r1,#0xc]
                  |L52.466|
0001d2  e04b              B        |L52.620|
                  |L52.468|
;;;2259     }
;;;2260     else
;;;2261     {
;;;2262       switch (clocksource)
0001d4  2d09              CMP      r5,#9
0001d6  d29a              BCS      |L52.270|
0001d8  002a              MOVS     r2,r5
0001da  447a              ADD      r2,r2,pc
0001dc  7912              LDRB     r2,[r2,#4]
0001de  1892              ADDS     r2,r2,r2
0001e0  4497              ADD      pc,pc,r2
0001e2  0510              DCB      0x05,0x10
0001e4  1b043104          DCB      0x1b,0x04,0x31,0x04
0001e8  04043c00          DCB      0x04,0x04,0x3c,0x00
0001ec  e78f              B        |L52.270|
;;;2263       {
;;;2264       case UART_CLOCKSOURCE_PCLK1:
;;;2265         huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
0001ee  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0001f2  6861              LDR      r1,[r4,#4]
0001f4  084a              LSRS     r2,r1,#1
0001f6  1880              ADDS     r0,r0,r2
0001f8  f7fffffe          BL       __aeabi_uidivmod
0001fc  6821              LDR      r1,[r4,#0]
0001fe  b280              UXTH     r0,r0
000200  60c8              STR      r0,[r1,#0xc]
;;;2266         break;
000202  e033              B        |L52.620|
;;;2267       case UART_CLOCKSOURCE_PCLK2:
;;;2268         huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
000204  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000208  6861              LDR      r1,[r4,#4]
00020a  084a              LSRS     r2,r1,#1
00020c  1880              ADDS     r0,r0,r2
00020e  f7fffffe          BL       __aeabi_uidivmod
000212  6821              LDR      r1,[r4,#0]
000214  b280              UXTH     r0,r0
000216  60c8              STR      r0,[r1,#0xc]
;;;2269         break;
000218  e028              B        |L52.620|
;;;2270       case UART_CLOCKSOURCE_HSI:
;;;2271         if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
00021a  6808              LDR      r0,[r1,#0]
00021c  6861              LDR      r1,[r4,#4]
00021e  06c0              LSLS     r0,r0,#27
000220  d508              BPL      |L52.564|
;;;2272         {
;;;2273           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16((HSI_VALUE >> 2U), huart->Init.BaudRate));
000222  4819              LDR      r0,|L52.648|
000224  084a              LSRS     r2,r1,#1
000226  1810              ADDS     r0,r2,r0
000228  f7fffffe          BL       __aeabi_uidivmod
00022c  b281              UXTH     r1,r0
00022e  9800              LDR      r0,[sp,#0]
000230  60c1              STR      r1,[r0,#0xc]
000232  e01b              B        |L52.620|
                  |L52.564|
;;;2274         }
;;;2275         else
;;;2276         {
;;;2277           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
000234  4815              LDR      r0,|L52.652|
000236  084a              LSRS     r2,r1,#1
000238  1810              ADDS     r0,r2,r0
00023a  f7fffffe          BL       __aeabi_uidivmod
00023e  b281              UXTH     r1,r0
000240  9800              LDR      r0,[sp,#0]
000242  60c1              STR      r1,[r0,#0xc]
000244  e012              B        |L52.620|
;;;2278         }
;;;2279         break;
;;;2280       case UART_CLOCKSOURCE_SYSCLK:
;;;2281         huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
000246  f7fffffe          BL       HAL_RCC_GetSysClockFreq
00024a  6861              LDR      r1,[r4,#4]
00024c  084a              LSRS     r2,r1,#1
00024e  1880              ADDS     r0,r0,r2
000250  f7fffffe          BL       __aeabi_uidivmod
000254  6821              LDR      r1,[r4,#0]
000256  b280              UXTH     r0,r0
000258  60c8              STR      r0,[r1,#0xc]
;;;2282         break;
00025a  e007              B        |L52.620|
;;;2283       case UART_CLOCKSOURCE_LSE:
;;;2284         huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
00025c  6861              LDR      r1,[r4,#4]
00025e  084a              LSRS     r2,r1,#1
000260  1810              ADDS     r0,r2,r0
000262  f7fffffe          BL       __aeabi_uidivmod
000266  b281              UXTH     r1,r0
000268  9800              LDR      r0,[sp,#0]
00026a  60c1              STR      r1,[r0,#0xc]
                  |L52.620|
;;;2285         break;
;;;2286       case UART_CLOCKSOURCE_UNDEFINED:
;;;2287       default:
;;;2288           ret = HAL_ERROR;
;;;2289         break;
;;;2290       }
;;;2291     }
;;;2292   
;;;2293     return ret;
00026c  4638              MOV      r0,r7
;;;2294   
;;;2295   }
00026e  bdf8              POP      {r3-r7,pc}
;;;2296   
                          ENDP

                  |L52.624|
                          DCD      0xefff69f3
                  |L52.628|
                          DCD      0x40004800
                  |L52.632|
                          DCD      0x40013800
                  |L52.636|
                          DCD      0x40021040
                  |L52.640|
                          DCD      0x40004400
                  |L52.644|
                          DCD      0x40021000
                  |L52.648|
                          DCD      0x003d0900
                  |L52.652|
                          DCD      0x00f42400
                  |L52.656|
                          DCD      0x000ffcff
                  |L52.660|
                          DCD      0x007a1200
                  |L52.664|
                          DCD      0x01e84800

                          AREA ||i.UART_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  UART_WaitOnFlagUntilTimeout PROC
;;;2425     */
;;;2426   HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
000000  b5ff              PUSH     {r0-r7,lr}
;;;2427   {
000002  4604              MOV      r4,r0
;;;2428     /* Wait until flag is set */
;;;2429     while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
000004  6800              LDR      r0,[r0,#0]
000006  b081              SUB      sp,sp,#4              ;2427
000008  460d              MOV      r5,r1                 ;2427
00000a  9e0a              LDR      r6,[sp,#0x28]
00000c  69c1              LDR      r1,[r0,#0x1c]
00000e  4617              MOV      r7,r2                 ;2427
000010  4628              MOV      r0,r5
000012  4388              BICS     r0,r0,r1
000014  d01f              BEQ      |L53.86|
000016  2000              MOVS     r0,#0
                  |L53.24|
000018  42b8              CMP      r0,r7
00001a  d126              BNE      |L53.106|
                  |L53.28|
;;;2430     {
;;;2431       /* Check for the Timeout */
;;;2432       if(Timeout != HAL_MAX_DELAY)
00001c  1c70              ADDS     r0,r6,#1
00001e  d01c              BEQ      |L53.90|
;;;2433       {
;;;2434         if((Timeout == 0) || ((HAL_GetTick()-Tickstart) > Timeout))
000020  2e00              CMP      r6,#0
000022  d005              BEQ      |L53.48|
000024  f7fffffe          BL       HAL_GetTick
000028  9904              LDR      r1,[sp,#0x10]
00002a  1a40              SUBS     r0,r0,r1
00002c  42b0              CMP      r0,r6
00002e  d914              BLS      |L53.90|
                  |L53.48|
;;;2435         {
;;;2436           /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;2437           CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
000030  6820              LDR      r0,[r4,#0]
000032  6801              LDR      r1,[r0,#0]
000034  22ff              MOVS     r2,#0xff
000036  32a1              ADDS     r2,r2,#0xa1
000038  4391              BICS     r1,r1,r2
00003a  6001              STR      r1,[r0,#0]
;;;2438           CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00003c  6820              LDR      r0,[r4,#0]
00003e  6881              LDR      r1,[r0,#8]
000040  0849              LSRS     r1,r1,#1
000042  0049              LSLS     r1,r1,#1
000044  6081              STR      r1,[r0,#8]
;;;2439   
;;;2440           huart->gState  = HAL_UART_STATE_READY;
000046  2020              MOVS     r0,#0x20
000048  66e0              STR      r0,[r4,#0x6c]
;;;2441           huart->RxState = HAL_UART_STATE_READY;
00004a  6720              STR      r0,[r4,#0x70]
;;;2442   
;;;2443           /* Process Unlocked */
;;;2444           __HAL_UNLOCK(huart);
00004c  2000              MOVS     r0,#0
;;;2445           return HAL_TIMEOUT;
00004e  66a0              STR      r0,[r4,#0x68]
000050  2003              MOVS     r0,#3
;;;2446         }
;;;2447       }
;;;2448     }
;;;2449     return HAL_OK;
;;;2450   }
000052  b005              ADD      sp,sp,#0x14
000054  bdf0              POP      {r4-r7,pc}
                  |L53.86|
000056  2001              MOVS     r0,#1                 ;2429
000058  e7de              B        |L53.24|
                  |L53.90|
00005a  6820              LDR      r0,[r4,#0]            ;2445
00005c  69c1              LDR      r1,[r0,#0x1c]         ;2445
00005e  4628              MOV      r0,r5                 ;2445
000060  4388              BICS     r0,r0,r1              ;2445
000062  d005              BEQ      |L53.112|
000064  2000              MOVS     r0,#0                 ;2445
                  |L53.102|
000066  42b8              CMP      r0,r7                 ;2445
000068  d0d8              BEQ      |L53.28|
                  |L53.106|
00006a  2000              MOVS     r0,#0                 ;2449
00006c  b005              ADD      sp,sp,#0x14
00006e  bdf0              POP      {r4-r7,pc}
                  |L53.112|
000070  2001              MOVS     r0,#1                 ;2445
000072  e7f8              B        |L53.102|
;;;2451   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_L0_V1.10.0\\Drivers\\STM32L0xx_HAL_Driver\\Src\\stm32l0xx_hal_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32l0xx_hal_uart_c_d497114f____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_L0_V1.10.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___20_stm32l0xx_hal_uart_c_d497114f____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32l0xx_hal_uart_c_d497114f____REVSH|
#line 402
|__asm___20_stm32l0xx_hal_uart_c_d497114f____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
