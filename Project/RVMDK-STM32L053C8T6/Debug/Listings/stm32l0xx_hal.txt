; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32l0xx_hal.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32l0xx_hal.d --cpu=Cortex-M0+ --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\STM32L0xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\CMSIS\Device\ST\STM32L0xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\STM32L0xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32L053C8T6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32L0xx_DFP\2.0.0\Drivers\CMSIS\Device\ST\STM32L0xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32L053xx -DSTM32L0xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32l0xx_hal.crf ..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\STM32L0xx_HAL_Driver\Src\stm32l0xx_hal.c]
                          THUMB

                          AREA ||i.HAL_DBGMCU_DBG_DisableLowPowerConfig||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_DBG_DisableLowPowerConfig PROC
;;;478      */
;;;479    void HAL_DBGMCU_DBG_DisableLowPowerConfig(uint32_t Periph)
000000  4902              LDR      r1,|L1.12|
;;;480    {
;;;481      /* Check the parameters */
;;;482      assert_param(IS_DBGMCU_PERIPH(Periph));
;;;483      {
;;;484        DBGMCU->CR &= ~Periph;
000002  684a              LDR      r2,[r1,#4]
000004  4382              BICS     r2,r2,r0
000006  604a              STR      r2,[r1,#4]
;;;485      }
;;;486    }
000008  4770              BX       lr
;;;487    
                          ENDP

00000a  0000              DCW      0x0000
                  |L1.12|
                          DCD      0x40015800

                          AREA ||i.HAL_DBGMCU_DBG_EnableLowPowerConfig||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_DBG_EnableLowPowerConfig PROC
;;;461      */
;;;462    void HAL_DBGMCU_DBG_EnableLowPowerConfig(uint32_t Periph)
000000  4902              LDR      r1,|L2.12|
;;;463    {
;;;464      /* Check the parameters */
;;;465      assert_param(IS_DBGMCU_PERIPH(Periph));
;;;466      
;;;467      DBGMCU->CR |= Periph;
000002  684a              LDR      r2,[r1,#4]
000004  4302              ORRS     r2,r2,r0
000006  604a              STR      r2,[r1,#4]
;;;468    
;;;469    }
000008  4770              BX       lr
;;;470    /**
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      0x40015800

                          AREA ||i.HAL_DBGMCU_DisableDBGSleepMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_DisableDBGSleepMode PROC
;;;411      */
;;;412    void HAL_DBGMCU_DisableDBGSleepMode(void)
000000  4802              LDR      r0,|L3.12|
;;;413    {
;;;414      CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
000002  6841              LDR      r1,[r0,#4]
000004  0849              LSRS     r1,r1,#1
000006  0049              LSLS     r1,r1,#1
000008  6041              STR      r1,[r0,#4]
;;;415    }
00000a  4770              BX       lr
;;;416    
                          ENDP

                  |L3.12|
                          DCD      0x40015800

                          AREA ||i.HAL_DBGMCU_DisableDBGStandbyMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_DisableDBGStandbyMode PROC
;;;447      */
;;;448    void HAL_DBGMCU_DisableDBGStandbyMode(void)
000000  4802              LDR      r0,|L4.12|
;;;449    {
;;;450      CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
000002  6841              LDR      r1,[r0,#4]
000004  2204              MOVS     r2,#4
000006  4391              BICS     r1,r1,r2
000008  6041              STR      r1,[r0,#4]
;;;451    }
00000a  4770              BX       lr
;;;452    
                          ENDP

                  |L4.12|
                          DCD      0x40015800

                          AREA ||i.HAL_DBGMCU_DisableDBGStopMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_DisableDBGStopMode PROC
;;;429      */
;;;430    void HAL_DBGMCU_DisableDBGStopMode(void)
000000  4802              LDR      r0,|L5.12|
;;;431    {
;;;432      CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
000002  6841              LDR      r1,[r0,#4]
000004  2202              MOVS     r2,#2
000006  4391              BICS     r1,r1,r2
000008  6041              STR      r1,[r0,#4]
;;;433    }
00000a  4770              BX       lr
;;;434    
                          ENDP

                  |L5.12|
                          DCD      0x40015800

                          AREA ||i.HAL_DBGMCU_EnableDBGSleepMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_EnableDBGSleepMode PROC
;;;402      */
;;;403    void HAL_DBGMCU_EnableDBGSleepMode(void)
000000  4802              LDR      r0,|L6.12|
;;;404    {
;;;405      SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
000002  6841              LDR      r1,[r0,#4]
000004  2201              MOVS     r2,#1
000006  4311              ORRS     r1,r1,r2
000008  6041              STR      r1,[r0,#4]
;;;406    }
00000a  4770              BX       lr
;;;407    
                          ENDP

                  |L6.12|
                          DCD      0x40015800

                          AREA ||i.HAL_DBGMCU_EnableDBGStandbyMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_EnableDBGStandbyMode PROC
;;;438      */
;;;439    void HAL_DBGMCU_EnableDBGStandbyMode(void)
000000  4802              LDR      r0,|L7.12|
;;;440    {
;;;441      SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
000002  6841              LDR      r1,[r0,#4]
000004  2204              MOVS     r2,#4
000006  4311              ORRS     r1,r1,r2
000008  6041              STR      r1,[r0,#4]
;;;442    }
00000a  4770              BX       lr
;;;443    
                          ENDP

                  |L7.12|
                          DCD      0x40015800

                          AREA ||i.HAL_DBGMCU_EnableDBGStopMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_EnableDBGStopMode PROC
;;;420      */
;;;421    void HAL_DBGMCU_EnableDBGStopMode(void)
000000  4802              LDR      r0,|L8.12|
;;;422    {
;;;423      SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
000002  6841              LDR      r1,[r0,#4]
000004  2202              MOVS     r2,#2
000006  4311              ORRS     r1,r1,r2
000008  6041              STR      r1,[r0,#4]
;;;424    }
00000a  4770              BX       lr
;;;425    
                          ENDP

                  |L8.12|
                          DCD      0x40015800

                          AREA ||i.HAL_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_DeInit PROC
;;;196      */
;;;197    HAL_StatusTypeDef HAL_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;198    {
;;;199      /* Reset of all peripherals */
;;;200      __HAL_RCC_APB1_FORCE_RESET();
000002  2100              MOVS     r1,#0
000004  4807              LDR      r0,|L9.36|
000006  43c9              MVNS     r1,r1
000008  6281              STR      r1,[r0,#0x28]
;;;201      __HAL_RCC_APB1_RELEASE_RESET();
00000a  2200              MOVS     r2,#0
00000c  6282              STR      r2,[r0,#0x28]
;;;202    
;;;203      __HAL_RCC_APB2_FORCE_RESET();
00000e  6241              STR      r1,[r0,#0x24]
;;;204      __HAL_RCC_APB2_RELEASE_RESET();
000010  6242              STR      r2,[r0,#0x24]
;;;205    
;;;206      __HAL_RCC_AHB_FORCE_RESET();
000012  6201              STR      r1,[r0,#0x20]
;;;207      __HAL_RCC_AHB_RELEASE_RESET();
000014  6202              STR      r2,[r0,#0x20]
;;;208    
;;;209      __HAL_RCC_IOP_FORCE_RESET();
000016  61c1              STR      r1,[r0,#0x1c]
;;;210      __HAL_RCC_IOP_RELEASE_RESET();
000018  61c2              STR      r2,[r0,#0x1c]
;;;211    
;;;212      /* De-Init the low level hardware */
;;;213      HAL_MspDeInit();
00001a  f7fffffe          BL       HAL_MspDeInit
;;;214        
;;;215      /* Return function status */
;;;216      return HAL_OK;
00001e  2000              MOVS     r0,#0
;;;217    }
000020  bd10              POP      {r4,pc}
;;;218    
                          ENDP

000022  0000              DCW      0x0000
                  |L9.36|
                          DCD      0x40021000

                          AREA ||i.HAL_Delay||, CODE, READONLY, ALIGN=1

                  HAL_Delay PROC
;;;330      */
;;;331    __weak void HAL_Delay(__IO uint32_t Delay)
000000  b531              PUSH     {r0,r4,r5,lr}
;;;332    {
;;;333      uint32_t tickstart = 0U;
;;;334      tickstart = HAL_GetTick();
000002  f7fffffe          BL       HAL_GetTick
000006  4604              MOV      r4,r0
                  |L10.8|
;;;335      while((HAL_GetTick() - tickstart) < Delay)
000008  f7fffffe          BL       HAL_GetTick
00000c  9900              LDR      r1,[sp,#0]
00000e  1b00              SUBS     r0,r0,r4
000010  4288              CMP      r0,r1
000012  d3f9              BCC      |L10.8|
;;;336      {
;;;337      }
;;;338    }
000014  bd38              POP      {r3-r5,pc}
;;;339    
                          ENDP


                          AREA ||i.HAL_GetDEVID||, CODE, READONLY, ALIGN=2

                  HAL_GetDEVID PROC
;;;393      */
;;;394    uint32_t HAL_GetDEVID(void)
000000  4802              LDR      r0,|L11.12|
;;;395    {
;;;396       return((DBGMCU->IDCODE) & IDCODE_DEVID_MASK);
000002  6800              LDR      r0,[r0,#0]
000004  0500              LSLS     r0,r0,#20
000006  0d00              LSRS     r0,r0,#20
;;;397    }
000008  4770              BX       lr
;;;398    
                          ENDP

00000a  0000              DCW      0x0000
                  |L11.12|
                          DCD      0x40015800

                          AREA ||i.HAL_GetHalVersion||, CODE, READONLY, ALIGN=2

                  HAL_GetHalVersion PROC
;;;375      */
;;;376    uint32_t HAL_GetHalVersion(void)
000000  4800              LDR      r0,|L12.4|
;;;377    {
;;;378      return __STM32L0xx_HAL_VERSION;
;;;379    }
000002  4770              BX       lr
;;;380    
                          ENDP

                  |L12.4|
                          DCD      0x01080200

                          AREA ||i.HAL_GetREVID||, CODE, READONLY, ALIGN=2

                  HAL_GetREVID PROC
;;;384      */
;;;385    uint32_t HAL_GetREVID(void)
000000  4801              LDR      r0,|L13.8|
;;;386    {
;;;387      return((DBGMCU->IDCODE) >> 16U);
000002  6800              LDR      r0,[r0,#0]
000004  0c00              LSRS     r0,r0,#16
;;;388    }
000006  4770              BX       lr
;;;389    
                          ENDP

                  |L13.8|
                          DCD      0x40015800

                          AREA ||i.HAL_GetTick||, CODE, READONLY, ALIGN=2

                  HAL_GetTick PROC
;;;315      */
;;;316    __weak uint32_t HAL_GetTick(void)
000000  4801              LDR      r0,|L14.8|
;;;317    {
;;;318      return uwTick;
000002  6800              LDR      r0,[r0,#0]  ; uwTick
;;;319    }
000004  4770              BX       lr
;;;320    
                          ENDP

000006  0000              DCW      0x0000
                  |L14.8|
                          DCD      ||.data||

                          AREA ||i.HAL_IncTick||, CODE, READONLY, ALIGN=2

                  HAL_IncTick PROC
;;;304      */
;;;305    __weak void HAL_IncTick(void)
000000  4802              LDR      r0,|L15.12|
;;;306    {
;;;307      uwTick++;
000002  6801              LDR      r1,[r0,#0]  ; uwTick
000004  1c49              ADDS     r1,r1,#1
000006  6001              STR      r1,[r0,#0]  ; uwTick
;;;308    }
000008  4770              BX       lr
;;;309    
                          ENDP

00000a  0000              DCW      0x0000
                  |L15.12|
                          DCD      ||.data||

                          AREA ||i.HAL_Init||, CODE, READONLY, ALIGN=2

                  HAL_Init PROC
;;;164      */
;;;165    HAL_StatusTypeDef HAL_Init(void)
000000  b510              PUSH     {r4,lr}
;;;166    {
;;;167      /* Configure Buffer cache, Flash prefetch,  Flash preread */ 
;;;168    #if (BUFFER_CACHE_DISABLE != 0)
;;;169      __HAL_FLASH_BUFFER_CACHE_DISABLE();
;;;170    #endif /* BUFFER_CACHE_DISABLE */
;;;171    
;;;172    #if (PREREAD_ENABLE != 0)
;;;173      __HAL_FLASH_PREREAD_BUFFER_ENABLE();
000002  4806              LDR      r0,|L16.28|
000004  6801              LDR      r1,[r0,#0]
000006  2240              MOVS     r2,#0x40
000008  4311              ORRS     r1,r1,r2
00000a  6001              STR      r1,[r0,#0]
;;;174    #endif /* PREREAD_ENABLE */
;;;175    
;;;176    #if (PREFETCH_ENABLE != 0)
;;;177      __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
;;;178    #endif /* PREFETCH_ENABLE */
;;;179    
;;;180      /* Use systick as time base source and configure 1ms tick (default clock after Reset is MSI) */
;;;181    
;;;182      HAL_InitTick(TICK_INT_PRIORITY);
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       HAL_InitTick
;;;183    
;;;184      /* Init the low level hardware */
;;;185      HAL_MspInit();
000012  f7fffffe          BL       HAL_MspInit
;;;186    
;;;187      /* Return function status */
;;;188      return HAL_OK;
000016  2000              MOVS     r0,#0
;;;189    }
000018  bd10              POP      {r4,pc}
;;;190    
                          ENDP

00001a  0000              DCW      0x0000
                  |L16.28|
                          DCD      0x40022000

                          AREA ||i.HAL_InitTick||, CODE, READONLY, ALIGN=2

                  HAL_InitTick PROC
;;;257      */
;;;258    __weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
000000  b510              PUSH     {r4,lr}
;;;259    {
000002  4604              MOV      r4,r0
;;;260      /*Configure the SysTick to have interrupt in 1ms time basis*/
;;;261      HAL_SYSTICK_Config(SystemCoreClock/1000U);
000004  4807              LDR      r0,|L17.36|
000006  217d              MOVS     r1,#0x7d
000008  00c9              LSLS     r1,r1,#3
00000a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000c  f7fffffe          BL       __aeabi_uidivmod
000010  f7fffffe          BL       HAL_SYSTICK_Config
;;;262    
;;;263      /*Configure the SysTick IRQ priority */
;;;264      HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0U);
000014  2200              MOVS     r2,#0
000016  4621              MOV      r1,r4
000018  1e50              SUBS     r0,r2,#1
00001a  f7fffffe          BL       HAL_NVIC_SetPriority
;;;265    
;;;266       /* Return function status */
;;;267      return HAL_OK;
00001e  2000              MOVS     r0,#0
;;;268    }
000020  bd10              POP      {r4,pc}
;;;269    
                          ENDP

000022  0000              DCW      0x0000
                  |L17.36|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_MspDeInit PROC
;;;233      */
;;;234    __weak void HAL_MspDeInit(void)
000000  4770              BX       lr
;;;235    {
;;;236      /* NOTE : This function Should not be modified, when the callback is needed,
;;;237                the HAL_MspDeInit could be implemented in the user file
;;;238       */
;;;239    }
;;;240    
                          ENDP


                          AREA ||i.HAL_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_MspInit PROC
;;;222      */
;;;223    __weak void HAL_MspInit(void)
000000  4770              BX       lr
;;;224    {
;;;225      /* NOTE : This function Should not be modified, when the callback is needed,
;;;226                the HAL_MspInit could be implemented in the user file
;;;227       */
;;;228    }
;;;229    
                          ENDP


                          AREA ||i.HAL_ResumeTick||, CODE, READONLY, ALIGN=2

                  HAL_ResumeTick PROC
;;;365      */
;;;366    __weak void HAL_ResumeTick(void)
000000  4802              LDR      r0,|L20.12|
;;;367    {
;;;368      /* Enable SysTick Interrupt */
;;;369      SysTick->CTRL  |= SysTick_CTRL_TICKINT_Msk;
000002  6901              LDR      r1,[r0,#0x10]
000004  2202              MOVS     r2,#2
000006  4311              ORRS     r1,r1,r2
000008  6101              STR      r1,[r0,#0x10]
;;;370    }
00000a  4770              BX       lr
;;;371    
                          ENDP

                  |L20.12|
                          DCD      0xe000e000

                          AREA ||i.HAL_SYSCFG_Disable_Lock_VREFINT||, CODE, READONLY, ALIGN=2

                  HAL_SYSCFG_Disable_Lock_VREFINT PROC
;;;536      */
;;;537    void HAL_SYSCFG_Disable_Lock_VREFINT(void)
000000  4802              LDR      r0,|L21.12|
;;;538    {
;;;539        /* Disable the LOCK by setting REF_LOCK bit in the CFGR3 register */
;;;540        CLEAR_BIT(SYSCFG->CFGR3, SYSCFG_CFGR3_REF_LOCK);
000002  6a01              LDR      r1,[r0,#0x20]
000004  0049              LSLS     r1,r1,#1
000006  0849              LSRS     r1,r1,#1
000008  6201              STR      r1,[r0,#0x20]
;;;541    }
00000a  4770              BX       lr
;;;542    
                          ENDP

                  |L21.12|
                          DCD      0x40010000

                          AREA ||i.HAL_SYSCFG_Enable_Lock_VREFINT||, CODE, READONLY, ALIGN=2

                  HAL_SYSCFG_Enable_Lock_VREFINT PROC
;;;526      */
;;;527    void HAL_SYSCFG_Enable_Lock_VREFINT(void)
000000  4802              LDR      r0,|L22.12|
;;;528    {
;;;529        /* Enable the LOCK by setting REF_LOCK bit in the CFGR3 register */
;;;530        SET_BIT(SYSCFG->CFGR3, SYSCFG_CFGR3_REF_LOCK);
000002  6a01              LDR      r1,[r0,#0x20]
000004  03c2              LSLS     r2,r0,#15
000006  4311              ORRS     r1,r1,r2
000008  6201              STR      r1,[r0,#0x20]
;;;531    }
00000a  4770              BX       lr
;;;532    
                          ENDP

                  |L22.12|
                          DCD      0x40010000

                          AREA ||i.HAL_SYSCFG_GetBootMode||, CODE, READONLY, ALIGN=2

                  HAL_SYSCFG_GetBootMode PROC
;;;495      */
;;;496    uint32_t  HAL_SYSCFG_GetBootMode(void)
000000  4802              LDR      r0,|L23.12|
;;;497    {
;;;498      return (SYSCFG->CFGR1 & SYSCFG_CFGR1_BOOT_MODE);
000002  6800              LDR      r0,[r0,#0]
000004  2103              MOVS     r1,#3
000006  0209              LSLS     r1,r1,#8
000008  4008              ANDS     r0,r0,r1
;;;499    }
00000a  4770              BX       lr
;;;500    
                          ENDP

                  |L23.12|
                          DCD      0x40010000

                          AREA ||i.HAL_SYSCFG_VREFINT_OutputSelect||, CODE, READONLY, ALIGN=2

                  HAL_SYSCFG_VREFINT_OutputSelect PROC
;;;512      */
;;;513    void HAL_SYSCFG_VREFINT_OutputSelect(uint32_t SYSCFG_Vrefint_OUTPUT)
000000  4904              LDR      r1,|L24.20|
;;;514    {
;;;515      /* Check the parameters */
;;;516      assert_param(IS_SYSCFG_VREFINT_OUT_SELECT(SYSCFG_Vrefint_OUTPUT));
;;;517    
;;;518      /* Set the output Vrefint pin */
;;;519      SYSCFG->CFGR3 &= ~(SYSCFG_CFGR3_VREF_OUT);
000002  6a0a              LDR      r2,[r1,#0x20]
000004  2330              MOVS     r3,#0x30
000006  439a              BICS     r2,r2,r3
000008  620a              STR      r2,[r1,#0x20]
;;;520      SYSCFG->CFGR3 |= (uint32_t)(SYSCFG_Vrefint_OUTPUT);
00000a  6a0a              LDR      r2,[r1,#0x20]
00000c  4302              ORRS     r2,r2,r0
00000e  620a              STR      r2,[r1,#0x20]
;;;521    }
000010  4770              BX       lr
;;;522    
                          ENDP

000012  0000              DCW      0x0000
                  |L24.20|
                          DCD      0x40010000

                          AREA ||i.HAL_SuspendTick||, CODE, READONLY, ALIGN=2

                  HAL_SuspendTick PROC
;;;349      */
;;;350    __weak void HAL_SuspendTick(void)
000000  4802              LDR      r0,|L25.12|
;;;351    {
;;;352      /* Disable SysTick Interrupt */
;;;353      SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
000002  6901              LDR      r1,[r0,#0x10]
000004  2202              MOVS     r2,#2
000006  4391              BICS     r1,r1,r2
000008  6101              STR      r1,[r0,#0x10]
;;;354    }
00000a  4770              BX       lr
;;;355    
                          ENDP

                  |L25.12|
                          DCD      0xe000e000

                          AREA ||.data||, DATA, ALIGN=2

                  uwTick
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_L0_V1.10.0\\Drivers\\STM32L0xx_HAL_Driver\\Src\\stm32l0xx_hal.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32l0xx_hal_c_HAL_Init____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_L0_V1.10.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___15_stm32l0xx_hal_c_HAL_Init____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32l0xx_hal_c_HAL_Init____REVSH|
#line 402
|__asm___15_stm32l0xx_hal_c_HAL_Init____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
