; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32l0xx_hal_rcc_ex.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32l0xx_hal_rcc_ex.d --cpu=Cortex-M0+ --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\STM32L0xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\CMSIS\Device\ST\STM32L0xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\STM32L0xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32L053C8T6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32L0xx_DFP\2.0.0\Drivers\CMSIS\Device\ST\STM32L0xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32L053xx -DSTM32L0xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32l0xx_hal_rcc_ex.crf ..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\STM32L0xx_HAL_Driver\Src\stm32l0xx_hal_rcc_ex.c]
                          THUMB

                          AREA ||i.HAL_RCCEx_CRSConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_CRSConfig PROC
;;;861      */
;;;862    void HAL_RCCEx_CRSConfig(RCC_CRSInitTypeDef *pInit)
000000  4910              LDR      r1,|L1.68|
;;;863    {
;;;864      uint32_t value = 0;
;;;865      
;;;866      /* Check the parameters */
;;;867      assert_param(IS_RCC_CRS_SYNC_DIV(pInit->Prescaler));
;;;868      assert_param(IS_RCC_CRS_SYNC_SOURCE(pInit->Source));
;;;869      assert_param(IS_RCC_CRS_SYNC_POLARITY(pInit->Polarity));
;;;870      assert_param(IS_RCC_CRS_RELOADVALUE(pInit->ReloadValue));
;;;871      assert_param(IS_RCC_CRS_ERRORLIMIT(pInit->ErrorLimitValue));
;;;872      assert_param(IS_RCC_CRS_HSI48CALIBRATION(pInit->HSI48CalibrationValue));
;;;873    
;;;874      /* CONFIGURATION */
;;;875    
;;;876      /* Before configuration, reset CRS registers to their default values*/
;;;877      __HAL_RCC_CRS_FORCE_RESET();
000002  6a8b              LDR      r3,[r1,#0x28]
000004  03ca              LSLS     r2,r1,#15
000006  4313              ORRS     r3,r3,r2
000008  628b              STR      r3,[r1,#0x28]
;;;878      __HAL_RCC_CRS_RELEASE_RESET();
00000a  6a8b              LDR      r3,[r1,#0x28]
00000c  4393              BICS     r3,r3,r2
00000e  628b              STR      r3,[r1,#0x28]
;;;879    
;;;880      /* Set the SYNCDIV[2:0] bits according to Prescaler value */
;;;881      /* Set the SYNCSRC[1:0] bits according to Source value */
;;;882      /* Set the SYNCSPOL bit according to Polarity value */
;;;883      value = (pInit->Prescaler | pInit->Source | pInit->Polarity);
000010  6842              LDR      r2,[r0,#4]
000012  6801              LDR      r1,[r0,#0]
000014  4311              ORRS     r1,r1,r2
000016  6882              LDR      r2,[r0,#8]
000018  4311              ORRS     r1,r1,r2
;;;884      /* Set the RELOAD[15:0] bits according to ReloadValue value */
;;;885      value |= pInit->ReloadValue;
00001a  68c2              LDR      r2,[r0,#0xc]
00001c  430a              ORRS     r2,r2,r1
;;;886      /* Set the FELIM[7:0] bits according to ErrorLimitValue value */
;;;887      value |= (pInit->ErrorLimitValue << CRS_CFGR_FELIM_BITNUMBER);
00001e  8a01              LDRH     r1,[r0,#0x10]
000020  040b              LSLS     r3,r1,#16
;;;888      WRITE_REG(CRS->CFGR, value);
000022  4909              LDR      r1,|L1.72|
000024  4313              ORRS     r3,r3,r2              ;887
000026  604b              STR      r3,[r1,#4]
;;;889    
;;;890      /* Adjust HSI48 oscillator smooth trimming */
;;;891      /* Set the TRIM[5:0] bits according to RCC_CRS_HSI48CalibrationValue value */
;;;892      MODIFY_REG(CRS->CR, CRS_CR_TRIM, (pInit->HSI48CalibrationValue << CRS_CR_TRIM_BITNUMBER));
000028  680a              LDR      r2,[r1,#0]
00002a  233f              MOVS     r3,#0x3f
00002c  021b              LSLS     r3,r3,#8
00002e  6940              LDR      r0,[r0,#0x14]
000030  439a              BICS     r2,r2,r3
000032  0200              LSLS     r0,r0,#8
000034  4302              ORRS     r2,r2,r0
000036  600a              STR      r2,[r1,#0]
;;;893      
;;;894      /* START AUTOMATIC SYNCHRONIZATION*/
;;;895      
;;;896      /* Enable Automatic trimming & Frequency error counter */
;;;897      SET_BIT(CRS->CR, CRS_CR_AUTOTRIMEN | CRS_CR_CEN);
000038  6808              LDR      r0,[r1,#0]
00003a  2260              MOVS     r2,#0x60
00003c  4310              ORRS     r0,r0,r2
00003e  6008              STR      r0,[r1,#0]
;;;898    }
000040  4770              BX       lr
;;;899    
                          ENDP

000042  0000              DCW      0x0000
                  |L1.68|
                          DCD      0x40021000
                  |L1.72|
                          DCD      0x40006c00

                          AREA ||i.HAL_RCCEx_CRSGetSynchronizationInfo||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_CRSGetSynchronizationInfo PROC
;;;913      */
;;;914    void HAL_RCCEx_CRSGetSynchronizationInfo(RCC_CRSSynchroInfoTypeDef *pSynchroInfo)
000000  4908              LDR      r1,|L2.36|
;;;915    {
;;;916      /* Check the parameter */
;;;917      assert_param(pSynchroInfo != NULL);
;;;918      
;;;919      /* Get the reload value */
;;;920      pSynchroInfo->ReloadValue = (uint32_t)(READ_BIT(CRS->CFGR, CRS_CFGR_RELOAD));
000002  684a              LDR      r2,[r1,#4]
000004  b292              UXTH     r2,r2
;;;921      
;;;922      /* Get HSI48 oscillator smooth trimming */
;;;923      pSynchroInfo->HSI48CalibrationValue = (uint32_t)(READ_BIT(CRS->CR, CRS_CR_TRIM) >> CRS_CR_TRIM_BITNUMBER);
000006  6002              STR      r2,[r0,#0]
000008  680a              LDR      r2,[r1,#0]
;;;924    
;;;925      /* Get Frequency error capture */
;;;926      pSynchroInfo->FreqErrorCapture = (uint32_t)(READ_BIT(CRS->ISR, CRS_ISR_FECAP) >> CRS_ISR_FECAP_BITNUMBER);
;;;927    
;;;928      /* Get Frequency error direction */
;;;929      pSynchroInfo->FreqErrorDirection = (uint32_t)(READ_BIT(CRS->ISR, CRS_ISR_FEDIR));
;;;930    }
00000a  0492              LSLS     r2,r2,#18
00000c  0e92              LSRS     r2,r2,#26
00000e  6042              STR      r2,[r0,#4]            ;926
000010  688a              LDR      r2,[r1,#8]            ;926
000012  0c12              LSRS     r2,r2,#16             ;926
000014  6082              STR      r2,[r0,#8]            ;929
000016  6889              LDR      r1,[r1,#8]            ;929
000018  2201              MOVS     r2,#1                 ;929
00001a  03d2              LSLS     r2,r2,#15             ;929
00001c  4011              ANDS     r1,r1,r2              ;929
00001e  60c1              STR      r1,[r0,#0xc]          ;929
000020  4770              BX       lr
;;;931    
                          ENDP

000022  0000              DCW      0x0000
                  |L2.36|
                          DCD      0x40006c00

                          AREA ||i.HAL_RCCEx_CRSSoftwareSynchronizationGenerate||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_CRSSoftwareSynchronizationGenerate PROC
;;;903      */
;;;904    void HAL_RCCEx_CRSSoftwareSynchronizationGenerate(void)
000000  4802              LDR      r0,|L3.12|
;;;905    {
;;;906      SET_BIT(CRS->CR, CRS_CR_SWSYNC);
000002  6801              LDR      r1,[r0,#0]
000004  2280              MOVS     r2,#0x80
000006  4311              ORRS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;907    }
00000a  4770              BX       lr
;;;908    
                          ENDP

                  |L3.12|
                          DCD      0x40006c00

                          AREA ||i.HAL_RCCEx_CRSWaitSynchronization||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_CRSWaitSynchronization PROC
;;;946    */
;;;947    uint32_t HAL_RCCEx_CRSWaitSynchronization(uint32_t Timeout)
000000  b5f8              PUSH     {r3-r7,lr}
;;;948    {
000002  4605              MOV      r5,r0
;;;949      uint32_t crsstatus = RCC_CRS_NONE;
000004  2400              MOVS     r4,#0
;;;950      uint32_t tickstart = 0U;
;;;951      
;;;952      /* Get timeout */
;;;953      tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
;;;954      
;;;955      /* Wait for CRS flag or timeout detection */
;;;956      do
;;;957      {
;;;958        if(Timeout != HAL_MAX_DELAY)
;;;959        {
;;;960          if((Timeout == 0U) || ((HAL_GetTick() - tickstart) > Timeout))
;;;961          {
;;;962            crsstatus = RCC_CRS_TIMEOUT;
;;;963          }
;;;964        }
;;;965        /* Check CRS SYNCOK flag  */
;;;966        if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCOK))
;;;967        {
;;;968          /* CRS SYNC event OK */
;;;969          crsstatus |= RCC_CRS_SYNCOK;
00000a  2702              MOVS     r7,#2
;;;970        
;;;971          /* Clear CRS SYNC event OK bit */
;;;972          __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCOK);
;;;973        }
;;;974        
;;;975        /* Check CRS SYNCWARN flag  */
;;;976        if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCWARN))
;;;977        {
;;;978          /* CRS SYNC warning */
;;;979          crsstatus |= RCC_CRS_SYNCWARN;
00000c  2604              MOVS     r6,#4
00000e  9000              STR      r0,[sp,#0]
                  |L4.16|
000010  1c68              ADDS     r0,r5,#1              ;958
000012  d009              BEQ      |L4.40|
000014  2d00              CMP      r5,#0                 ;960
000016  d006              BEQ      |L4.38|
000018  f7fffffe          BL       HAL_GetTick
00001c  4601              MOV      r1,r0                 ;960
00001e  9800              LDR      r0,[sp,#0]            ;960
000020  1a08              SUBS     r0,r1,r0              ;960
000022  42a8              CMP      r0,r5                 ;960
000024  d900              BLS      |L4.40|
                  |L4.38|
000026  2401              MOVS     r4,#1                 ;962
                  |L4.40|
000028  4813              LDR      r0,|L4.120|
00002a  6881              LDR      r1,[r0,#8]            ;966
00002c  07c9              LSLS     r1,r1,#31             ;966
00002e  d002              BEQ      |L4.54|
000030  433c              ORRS     r4,r4,r7              ;969
000032  2101              MOVS     r1,#1                 ;972
000034  60c1              STR      r1,[r0,#0xc]          ;972
                  |L4.54|
000036  6881              LDR      r1,[r0,#8]            ;976
000038  0789              LSLS     r1,r1,#30             ;976
00003a  d501              BPL      |L4.64|
00003c  4334              ORRS     r4,r4,r6
;;;980        
;;;981          /* Clear CRS SYNCWARN bit */
;;;982          __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCWARN);
00003e  60c7              STR      r7,[r0,#0xc]
                  |L4.64|
;;;983        }
;;;984        
;;;985        /* Check CRS TRIM overflow flag  */
;;;986        if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_TRIMOVF))
000040  6881              LDR      r1,[r0,#8]
000042  0549              LSLS     r1,r1,#21
000044  d502              BPL      |L4.76|
;;;987        {
;;;988          /* CRS SYNC Error */
;;;989          crsstatus |= RCC_CRS_TRIMOVF;
000046  2120              MOVS     r1,#0x20
000048  430c              ORRS     r4,r4,r1
;;;990        
;;;991          /* Clear CRS Error bit */
;;;992          __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_TRIMOVF);
00004a  60c6              STR      r6,[r0,#0xc]
                  |L4.76|
;;;993        }
;;;994        
;;;995        /* Check CRS Error flag  */
;;;996        if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCERR))
00004c  6881              LDR      r1,[r0,#8]
00004e  05c9              LSLS     r1,r1,#23
000050  d502              BPL      |L4.88|
;;;997        {
;;;998          /* CRS SYNC Error */
;;;999          crsstatus |= RCC_CRS_SYNCERR;
000052  2108              MOVS     r1,#8
000054  430c              ORRS     r4,r4,r1
;;;1000       
;;;1001         /* Clear CRS Error bit */
;;;1002         __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCERR);
000056  60c6              STR      r6,[r0,#0xc]
                  |L4.88|
;;;1003       }
;;;1004       
;;;1005       /* Check CRS SYNC Missed flag  */
;;;1006       if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCMISS))
000058  6881              LDR      r1,[r0,#8]
00005a  0589              LSLS     r1,r1,#22
00005c  d502              BPL      |L4.100|
;;;1007       {
;;;1008         /* CRS SYNC Missed */
;;;1009         crsstatus |= RCC_CRS_SYNCMISS;
00005e  2110              MOVS     r1,#0x10
000060  430c              ORRS     r4,r4,r1
;;;1010       
;;;1011         /* Clear CRS SYNC Missed bit */
;;;1012         __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCMISS);
000062  60c6              STR      r6,[r0,#0xc]
                  |L4.100|
;;;1013       }
;;;1014       
;;;1015       /* Check CRS Expected SYNC flag  */
;;;1016       if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_ESYNC))
000064  6881              LDR      r1,[r0,#8]
000066  0709              LSLS     r1,r1,#28
000068  d501              BPL      |L4.110|
;;;1017       {
;;;1018         /* frequency error counter reached a zero value */
;;;1019         __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_ESYNC);
00006a  2108              MOVS     r1,#8
00006c  60c1              STR      r1,[r0,#0xc]
                  |L4.110|
00006e  2c00              CMP      r4,#0
000070  d0ce              BEQ      |L4.16|
;;;1020       }
;;;1021     } while(RCC_CRS_NONE == crsstatus);
;;;1022   
;;;1023     return crsstatus;
000072  4620              MOV      r0,r4
;;;1024   }
000074  bdf8              POP      {r3-r7,pc}
;;;1025   
                          ENDP

000076  0000              DCW      0x0000
                  |L4.120|
                          DCD      0x40006c00

                          AREA ||i.HAL_RCCEx_CRS_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_RCCEx_CRS_ErrorCallback PROC
;;;1132     */
;;;1133   __weak void HAL_RCCEx_CRS_ErrorCallback(uint32_t Error)
000000  4770              BX       lr
;;;1134   {
;;;1135     /* Prevent unused argument(s) compilation warning */
;;;1136     UNUSED(Error);
;;;1137   
;;;1138     /* NOTE : This function should not be modified, when the callback is needed,
;;;1139               the @ref HAL_RCCEx_CRS_ErrorCallback should be implemented in the user file
;;;1140      */
;;;1141   }
;;;1142   
                          ENDP


                          AREA ||i.HAL_RCCEx_CRS_ExpectedSyncCallback||, CODE, READONLY, ALIGN=1

                  HAL_RCCEx_CRS_ExpectedSyncCallback PROC
;;;1116     */
;;;1117   __weak void HAL_RCCEx_CRS_ExpectedSyncCallback(void)
000000  4770              BX       lr
;;;1118   {
;;;1119     /* NOTE : This function should not be modified, when the callback is needed,
;;;1120               the @ref HAL_RCCEx_CRS_ExpectedSyncCallback should be implemented in the user file
;;;1121      */
;;;1122   }
;;;1123   
                          ENDP


                          AREA ||i.HAL_RCCEx_CRS_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_CRS_IRQHandler PROC
;;;1029     */
;;;1030   void HAL_RCCEx_CRS_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1031   {
;;;1032     uint32_t crserror = RCC_CRS_NONE;
;;;1033     /* Get current IT flags and IT sources values */
;;;1034     uint32_t itflags = READ_REG(CRS->ISR);
000002  4a1a              LDR      r2,|L7.108|
000004  2000              MOVS     r0,#0                 ;1032
000006  6891              LDR      r1,[r2,#8]
;;;1035     uint32_t itsources = READ_REG(CRS->CR);
000008  6813              LDR      r3,[r2,#0]
00000a  460c              MOV      r4,r1
;;;1036   
;;;1037     /* Check CRS SYNCOK flag  */
;;;1038     if(((itflags & RCC_CRS_FLAG_SYNCOK) != RESET) && ((itsources & RCC_CRS_IT_SYNCOK) != RESET))
00000c  401c              ANDS     r4,r4,r3
00000e  07e4              LSLS     r4,r4,#31
000010  d004              BEQ      |L7.28|
;;;1039     {
;;;1040       /* Clear CRS SYNC event OK flag */
;;;1041       WRITE_REG(CRS->ICR, CRS_ICR_SYNCOKC);
000012  2001              MOVS     r0,#1
000014  60d0              STR      r0,[r2,#0xc]
;;;1042   
;;;1043       /* user callback */
;;;1044       HAL_RCCEx_CRS_SyncOkCallback();
000016  f7fffffe          BL       HAL_RCCEx_CRS_SyncOkCallback
;;;1045     }
;;;1046     /* Check CRS SYNCWARN flag  */
;;;1047     else if(((itflags & RCC_CRS_FLAG_SYNCWARN) != RESET) && ((itsources & RCC_CRS_IT_SYNCWARN) != RESET))
;;;1048     {
;;;1049       /* Clear CRS SYNCWARN flag */
;;;1050       WRITE_REG(CRS->ICR, CRS_ICR_SYNCWARNC);
;;;1051   
;;;1052       /* user callback */
;;;1053       HAL_RCCEx_CRS_SyncWarnCallback();
;;;1054     }
;;;1055     /* Check CRS Expected SYNC flag  */
;;;1056     else if(((itflags & RCC_CRS_FLAG_ESYNC) != RESET) && ((itsources & RCC_CRS_IT_ESYNC) != RESET))
;;;1057     {
;;;1058       /* frequency error counter reached a zero value */
;;;1059       WRITE_REG(CRS->ICR, CRS_ICR_ESYNCC);
;;;1060   
;;;1061       /* user callback */
;;;1062       HAL_RCCEx_CRS_ExpectedSyncCallback();
;;;1063     }
;;;1064     /* Check CRS Error flags  */
;;;1065     else
;;;1066     {
;;;1067       if(((itflags & RCC_CRS_FLAG_ERR) != RESET) && ((itsources & RCC_CRS_IT_ERR) != RESET))
;;;1068       {
;;;1069         if((itflags & RCC_CRS_FLAG_SYNCERR) != RESET)
;;;1070         {
;;;1071           crserror |= RCC_CRS_SYNCERR;
;;;1072         }
;;;1073         if((itflags & RCC_CRS_FLAG_SYNCMISS) != RESET)
;;;1074         {
;;;1075           crserror |= RCC_CRS_SYNCMISS;
;;;1076         }
;;;1077         if((itflags & RCC_CRS_FLAG_TRIMOVF) != RESET)
;;;1078         {
;;;1079           crserror |= RCC_CRS_TRIMOVF;
;;;1080         }
;;;1081   
;;;1082         /* Clear CRS Error flags */
;;;1083         WRITE_REG(CRS->ICR, CRS_ICR_ERRC);
;;;1084       
;;;1085         /* user error callback */
;;;1086         HAL_RCCEx_CRS_ErrorCallback(crserror);
;;;1087       }
;;;1088     }
;;;1089   }
00001a  bd70              POP      {r4-r6,pc}
                  |L7.28|
00001c  078c              LSLS     r4,r1,#30             ;1047
00001e  d506              BPL      |L7.46|
000020  079c              LSLS     r4,r3,#30             ;1047
000022  d504              BPL      |L7.46|
000024  2002              MOVS     r0,#2                 ;1050
000026  60d0              STR      r0,[r2,#0xc]          ;1050
000028  f7fffffe          BL       HAL_RCCEx_CRS_SyncWarnCallback
00002c  bd70              POP      {r4-r6,pc}
                  |L7.46|
00002e  070d              LSLS     r5,r1,#28             ;1056
000030  2408              MOVS     r4,#8                 ;1059
000032  2d00              CMP      r5,#0                 ;1056
000034  da05              BGE      |L7.66|
000036  071d              LSLS     r5,r3,#28             ;1056
000038  d503              BPL      |L7.66|
00003a  60d4              STR      r4,[r2,#0xc]          ;1059
00003c  f7fffffe          BL       HAL_RCCEx_CRS_ExpectedSyncCallback
                  |L7.64|
000040  bd70              POP      {r4-r6,pc}
                  |L7.66|
000042  074c              LSLS     r4,r1,#29             ;1067
000044  d5fc              BPL      |L7.64|
000046  075b              LSLS     r3,r3,#29             ;1067
000048  d5fa              BPL      |L7.64|
00004a  05cb              LSLS     r3,r1,#23             ;1069
00004c  d500              BPL      |L7.80|
00004e  2008              MOVS     r0,#8                 ;1071
                  |L7.80|
000050  058b              LSLS     r3,r1,#22             ;1073
000052  d501              BPL      |L7.88|
000054  2310              MOVS     r3,#0x10              ;1075
000056  4318              ORRS     r0,r0,r3              ;1075
                  |L7.88|
000058  0549              LSLS     r1,r1,#21             ;1077
00005a  d501              BPL      |L7.96|
00005c  2120              MOVS     r1,#0x20              ;1079
00005e  4308              ORRS     r0,r0,r1              ;1079
                  |L7.96|
000060  2104              MOVS     r1,#4                 ;1083
000062  60d1              STR      r1,[r2,#0xc]          ;1083
000064  f7fffffe          BL       HAL_RCCEx_CRS_ErrorCallback
000068  bd70              POP      {r4-r6,pc}
;;;1090   
                          ENDP

00006a  0000              DCW      0x0000
                  |L7.108|
                          DCD      0x40006c00

                          AREA ||i.HAL_RCCEx_CRS_SyncOkCallback||, CODE, READONLY, ALIGN=1

                  HAL_RCCEx_CRS_SyncOkCallback PROC
;;;1094     */
;;;1095   __weak void HAL_RCCEx_CRS_SyncOkCallback(void)
000000  4770              BX       lr
;;;1096   {
;;;1097     /* NOTE : This function should not be modified, when the callback is needed,
;;;1098               the @ref HAL_RCCEx_CRS_SyncOkCallback should be implemented in the user file
;;;1099      */
;;;1100   }
;;;1101   
                          ENDP


                          AREA ||i.HAL_RCCEx_CRS_SyncWarnCallback||, CODE, READONLY, ALIGN=1

                  HAL_RCCEx_CRS_SyncWarnCallback PROC
;;;1105     */
;;;1106   __weak void HAL_RCCEx_CRS_SyncWarnCallback(void)
000000  4770              BX       lr
;;;1107   {
;;;1108     /* NOTE : This function should not be modified, when the callback is needed,
;;;1109               the @ref HAL_RCCEx_CRS_SyncWarnCallback should be implemented in the user file
;;;1110      */
;;;1111   }
;;;1112   
                          ENDP


                          AREA ||i.HAL_RCCEx_DisableHSI48_VREFINT||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_DisableHSI48_VREFINT PROC
;;;778      */
;;;779    void HAL_RCCEx_DisableHSI48_VREFINT(void)
000000  4802              LDR      r0,|L10.12|
;;;780    {
;;;781      /* Disable the Vrefint by resetting SYSCFG_CFGR3_ENREF_HSI48 bit in SYSCFG_CFGR3 register */
;;;782      CLEAR_BIT(SYSCFG->CFGR3, SYSCFG_CFGR3_ENREF_HSI48);
000002  6a01              LDR      r1,[r0,#0x20]
000004  1442              ASRS     r2,r0,#17
000006  4391              BICS     r1,r1,r2
000008  6201              STR      r1,[r0,#0x20]
;;;783    }
00000a  4770              BX       lr
;;;784    
                          ENDP

                  |L10.12|
                          DCD      0x40010000

                          AREA ||i.HAL_RCCEx_DisableLSECSS||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_DisableLSECSS PROC
;;;706      */
;;;707    void HAL_RCCEx_DisableLSECSS(void)
000000  4805              LDR      r0,|L11.24|
;;;708    {
;;;709      /* Disable LSE CSS */
;;;710       CLEAR_BIT(RCC->CSR, RCC_CSR_LSECSSON) ;
000002  6901              LDR      r1,[r0,#0x10]
000004  2201              MOVS     r2,#1
000006  0352              LSLS     r2,r2,#13
000008  4391              BICS     r1,r1,r2
00000a  6101              STR      r1,[r0,#0x10]
;;;711    
;;;712      /* Disable LSE CSS IT */
;;;713      __HAL_RCC_DISABLE_IT(RCC_IT_LSECSS);
00000c  4803              LDR      r0,|L11.28|
00000e  6901              LDR      r1,[r0,#0x10]
000010  2280              MOVS     r2,#0x80
000012  4391              BICS     r1,r1,r2
000014  6101              STR      r1,[r0,#0x10]
;;;714    }
000016  4770              BX       lr
;;;715    
                          ENDP

                  |L11.24|
                          DCD      0x40021040
                  |L11.28|
                          DCD      0x40021000

                          AREA ||i.HAL_RCCEx_EnableHSI48_VREFINT||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_EnableHSI48_VREFINT PROC
;;;767      */
;;;768    void HAL_RCCEx_EnableHSI48_VREFINT(void)
000000  4802              LDR      r0,|L12.12|
;;;769    {
;;;770      /* Enable the Buffer for the ADC by setting SYSCFG_CFGR3_ENREF_HSI48 bit in SYSCFG_CFGR3 register   */
;;;771      SET_BIT (SYSCFG->CFGR3, SYSCFG_CFGR3_ENREF_HSI48);
000002  6a01              LDR      r1,[r0,#0x20]
000004  1442              ASRS     r2,r0,#17
000006  4311              ORRS     r1,r1,r2
000008  6201              STR      r1,[r0,#0x20]
;;;772    }
00000a  4770              BX       lr
;;;773    
                          ENDP

                  |L12.12|
                          DCD      0x40010000

                          AREA ||i.HAL_RCCEx_EnableLSECSS||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_EnableLSECSS PROC
;;;694      */
;;;695    void HAL_RCCEx_EnableLSECSS(void)
000000  4803              LDR      r0,|L13.16|
;;;696    {
;;;697      SET_BIT(RCC->CSR, RCC_CSR_LSECSSON) ;
000002  6901              LDR      r1,[r0,#0x10]
000004  2201              MOVS     r2,#1
000006  0352              LSLS     r2,r2,#13
000008  4311              ORRS     r1,r1,r2
00000a  6101              STR      r1,[r0,#0x10]
;;;698    }
00000c  4770              BX       lr
;;;699    
                          ENDP

00000e  0000              DCW      0x0000
                  |L13.16|
                          DCD      0x40021040

                          AREA ||i.HAL_RCCEx_EnableLSECSS_IT||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_EnableLSECSS_IT PROC
;;;720      */
;;;721    void HAL_RCCEx_EnableLSECSS_IT(void)
000000  480a              LDR      r0,|L14.44|
;;;722    {
;;;723      /* Enable LSE CSS */
;;;724       SET_BIT(RCC->CSR, RCC_CSR_LSECSSON) ;
000002  6901              LDR      r1,[r0,#0x10]
000004  2201              MOVS     r2,#1
000006  0352              LSLS     r2,r2,#13
000008  4311              ORRS     r1,r1,r2
00000a  6101              STR      r1,[r0,#0x10]
;;;725    
;;;726      /* Enable LSE CSS IT */
;;;727      __HAL_RCC_ENABLE_IT(RCC_IT_LSECSS);
00000c  4808              LDR      r0,|L14.48|
00000e  6901              LDR      r1,[r0,#0x10]
000010  2280              MOVS     r2,#0x80
000012  4311              ORRS     r1,r1,r2
000014  6101              STR      r1,[r0,#0x10]
;;;728      
;;;729      /* Enable IT on EXTI Line 19 */
;;;730      __HAL_RCC_LSECSS_EXTI_ENABLE_IT();
000016  4807              LDR      r0,|L14.52|
000018  6802              LDR      r2,[r0,#0]
00001a  2101              MOVS     r1,#1
00001c  04c9              LSLS     r1,r1,#19
00001e  430a              ORRS     r2,r2,r1
000020  6002              STR      r2,[r0,#0]
;;;731      __HAL_RCC_LSECSS_EXTI_ENABLE_RISING_EDGE();
000022  6882              LDR      r2,[r0,#8]
000024  430a              ORRS     r2,r2,r1
000026  6082              STR      r2,[r0,#8]
;;;732    }
000028  4770              BX       lr
;;;733    
                          ENDP

00002a  0000              DCW      0x0000
                  |L14.44|
                          DCD      0x40021040
                  |L14.48|
                          DCD      0x40021000
                  |L14.52|
                          DCD      0x40010400

                          AREA ||i.HAL_RCCEx_GetPeriphCLKConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_GetPeriphCLKConfig PROC
;;;316      */
;;;317    void HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
000000  b430              PUSH     {r4,r5}
;;;318    {
;;;319      uint32_t srcclk = 0;
;;;320      
;;;321       /* Set all possible values for the extended clock type parameter -----------*/
;;;322      /* Common part first */
;;;323      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART2 | RCC_PERIPHCLK_LPUART1 | \
;;;324                                            RCC_PERIPHCLK_I2C1   | RCC_PERIPHCLK_RTC     | \
;;;325                                            RCC_PERIPHCLK_LPTIM1;
;;;326    #if defined(RCC_CCIPR_USART1SEL)
;;;327      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_USART1;
;;;328    #endif /* RCC_CCIPR_USART1SEL */
;;;329    #if  defined(RCC_CCIPR_I2C3SEL)
;;;330      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2C3;
;;;331    #endif /* RCC_CCIPR_I2C3SEL */
;;;332    #if defined(USB)
;;;333      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_USB;
;;;334    #endif /* USB */
;;;335    #if defined(LCD)   
;;;336      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_LCD;
000002  4919              LDR      r1,|L15.104|
;;;337    #endif /* LCD */
;;;338    
;;;339      /* Get the RTC/LCD configuration -----------------------------------------------*/
;;;340      srcclk = __HAL_RCC_GET_RTC_SOURCE();
000004  6001              STR      r1,[r0,#0]
000006  4919              LDR      r1,|L15.108|
000008  690a              LDR      r2,[r1,#0x10]
00000a  2303              MOVS     r3,#3
00000c  041b              LSLS     r3,r3,#16
00000e  401a              ANDS     r2,r2,r3
;;;341      if (srcclk != RCC_RTCCLKSOURCE_HSE_DIV2)
000010  429a              CMP      r2,r3
000012  d001              BEQ      |L15.24|
;;;342      {
;;;343        /* Source clock is LSE or LSI*/
;;;344        PeriphClkInit->RTCClockSelection = srcclk;
000014  6042              STR      r2,[r0,#4]
000016  e007              B        |L15.40|
                  |L15.24|
;;;345      }
;;;346      else
;;;347      {
;;;348        /* Source clock is HSE. Need to get the prescaler value*/
;;;349        PeriphClkInit->RTCClockSelection = srcclk | (READ_BIT(RCC->CR, RCC_CR_RTCPRE));
000018  4c15              LDR      r4,|L15.112|
00001a  6824              LDR      r4,[r4,#0]
00001c  2503              MOVS     r5,#3
00001e  052d              LSLS     r5,r5,#20
000020  402c              ANDS     r4,r4,r5
000022  4314              ORRS     r4,r4,r2
;;;350      }
;;;351    #if defined(LCD)
;;;352      PeriphClkInit->LCDClockSelection = PeriphClkInit->RTCClockSelection;
000024  4622              MOV      r2,r4
000026  6044              STR      r4,[r0,#4]
                  |L15.40|
;;;353    #endif /* LCD */
;;;354    #if defined(RCC_CCIPR_USART1SEL)
;;;355      /* Get the USART1 configuration --------------------------------------------*/
;;;356      PeriphClkInit->Usart1ClockSelection  = __HAL_RCC_GET_USART1_SOURCE();
000028  6082              STR      r2,[r0,#8]
00002a  68ca              LDR      r2,[r1,#0xc]
00002c  0792              LSLS     r2,r2,#30
00002e  0f92              LSRS     r2,r2,#30
;;;357    #endif /* RCC_CCIPR_USART1SEL */
;;;358      /* Get the USART2 clock source ---------------------------------------------*/
;;;359      PeriphClkInit->Usart2ClockSelection  = __HAL_RCC_GET_USART2_SOURCE();
000030  60c2              STR      r2,[r0,#0xc]
000032  68ca              LDR      r2,[r1,#0xc]
000034  240c              MOVS     r4,#0xc
000036  4022              ANDS     r2,r2,r4
;;;360      /* Get the LPUART1 clock source ---------------------------------------------*/
;;;361      PeriphClkInit->Lpuart1ClockSelection = __HAL_RCC_GET_LPUART1_SOURCE();
000038  6102              STR      r2,[r0,#0x10]
00003a  68ca              LDR      r2,[r1,#0xc]
00003c  0224              LSLS     r4,r4,#8
00003e  4022              ANDS     r2,r2,r4
;;;362      /* Get the I2C1 clock source -----------------------------------------------*/
;;;363      PeriphClkInit->I2c1ClockSelection    = __HAL_RCC_GET_I2C1_SOURCE();
000040  6142              STR      r2,[r0,#0x14]
000042  68ca              LDR      r2,[r1,#0xc]
000044  00a4              LSLS     r4,r4,#2
000046  4022              ANDS     r2,r2,r4
;;;364    #if defined(RCC_CCIPR_I2C3SEL)
;;;365    /* Get the I2C3 clock source -----------------------------------------------*/
;;;366      PeriphClkInit->I2c3ClockSelection    = __HAL_RCC_GET_I2C3_SOURCE();
;;;367    #endif /* RCC_CCIPR_I2C3SEL */
;;;368      /* Get the LPTIM1 clock source -----------------------------------------------*/
;;;369      PeriphClkInit->LptimClockSelection   = __HAL_RCC_GET_LPTIM1_SOURCE();
000048  6182              STR      r2,[r0,#0x18]
00004a  68ca              LDR      r2,[r1,#0xc]
00004c  01a4              LSLS     r4,r4,#6
00004e  4022              ANDS     r2,r2,r4
;;;370      /* Get the RTC clock source -----------------------------------------------*/
;;;371      PeriphClkInit->RTCClockSelection     = __HAL_RCC_GET_RTC_SOURCE();
000050  61c2              STR      r2,[r0,#0x1c]
000052  690a              LDR      r2,[r1,#0x10]
000054  401a              ANDS     r2,r2,r3
;;;372    #if defined(USB)
;;;373      /* Get the USB/RNG clock source -----------------------------------------------*/
;;;374      PeriphClkInit->UsbClockSelection     = __HAL_RCC_GET_USB_SOURCE();
000056  6042              STR      r2,[r0,#4]
000058  68c9              LDR      r1,[r1,#0xc]
00005a  2201              MOVS     r2,#1
00005c  0692              LSLS     r2,r2,#26
00005e  4011              ANDS     r1,r1,r2
000060  6201              STR      r1,[r0,#0x20]
;;;375    #endif /* USB */
;;;376    }
000062  bc30              POP      {r4,r5}
000064  4770              BX       lr
;;;377    
                          ENDP

000066  0000              DCW      0x0000
                  |L15.104|
                          DCD      0x000008ef
                  |L15.108|
                          DCD      0x40021040
                  |L15.112|
                          DCD      0x40021000

                          AREA ||i.HAL_RCCEx_GetPeriphCLKFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_GetPeriphCLKFreq PROC
;;;394      */
;;;395    uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
000000  b5f8              PUSH     {r3-r7,lr}
;;;396    {
;;;397      uint32_t temp_reg = 0U, clkprediv = 0U, frequency = 0U;
;;;398      uint32_t srcclk = 0U;
;;;399    #if defined(USB)
;;;400        uint32_t pllmul = 0U, plldiv = 0U, pllvco = 0U;
;;;401    #endif /* USB */
;;;402    
;;;403      /* Check the parameters */
;;;404      assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));
;;;405      
;;;406      switch (PeriphClk)
000002  2601              MOVS     r6,#1
000004  4607              MOV      r7,r0                 ;396
000006  02f6              LSLS     r6,r6,#11
000008  2000              MOVS     r0,#0                 ;397
;;;407      {
;;;408      case RCC_PERIPHCLK_RTC:
;;;409    #if defined(LCD)
;;;410      case RCC_PERIPHCLK_LCD:
;;;411    #endif /* LCD */
;;;412        {
;;;413          /* Get RCC CSR configuration ------------------------------------------------------*/
;;;414          temp_reg = RCC->CSR;
;;;415    
;;;416          /* Get the current RTC source */
;;;417          srcclk = __HAL_RCC_GET_RTC_SOURCE();
;;;418    
;;;419          /* Check if LSE is ready if RTC clock selection is LSE */
;;;420          if ((srcclk == RCC_RTCCLKSOURCE_LSE) && (HAL_IS_BIT_SET(temp_reg, RCC_CSR_LSERDY)))
;;;421          {
;;;422            frequency = LSE_VALUE;
00000a  0135              LSLS     r5,r6,#4
;;;423          }
;;;424          /* Check if LSI is ready if RTC clock selection is LSI */
;;;425          else if ((srcclk == RCC_RTCCLKSOURCE_LSI) && (HAL_IS_BIT_SET(temp_reg, RCC_CSR_LSIRDY)))
;;;426          {
;;;427            frequency = LSI_VALUE;
;;;428          }
;;;429          /* Check if HSE is ready and if RTC clock selection is HSE */
;;;430          else if ((srcclk == RCC_RTCCLKSOURCE_HSE_DIVX) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)))
;;;431          {
;;;432            /* Get the current HSE clock divider */
;;;433            clkprediv = __HAL_RCC_GET_RTC_HSE_PRESCALER();
;;;434    
;;;435            switch (clkprediv)
;;;436            {
;;;437              case RCC_RTC_HSE_DIV_16:  /* HSE DIV16 has been selected */
;;;438              {
;;;439                frequency = HSE_VALUE / 16U;
;;;440                break;
;;;441              }
;;;442              case RCC_RTC_HSE_DIV_8:   /* HSE DIV8 has been selected  */
;;;443              {
;;;444                frequency = HSE_VALUE / 8U;
;;;445                break;
;;;446              }
;;;447              case RCC_RTC_HSE_DIV_4:   /* HSE DIV4 has been selected  */
;;;448              {
;;;449                frequency = HSE_VALUE / 4U;
;;;450                break;
;;;451              }
;;;452              default:                  /* HSE DIV2 has been selected  */
;;;453              {
;;;454                frequency = HSE_VALUE / 2U;
;;;455                break;
;;;456              }
;;;457            }
;;;458          }
;;;459          /* Clock not enabled for RTC */
;;;460          else
;;;461          {
;;;462            frequency = 0U;
;;;463          }
;;;464          break;
;;;465        }
;;;466    #if defined(USB)
;;;467       case RCC_PERIPHCLK_USB:
;;;468        {  
;;;469            /* Get the current USB source */
;;;470            srcclk = __HAL_RCC_GET_USB_SOURCE();
;;;471            
;;;472            if((srcclk == RCC_USBCLKSOURCE_PLL) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLRDY)))
;;;473            {
;;;474                /* Get PLL clock source and multiplication factor ----------------------*/
;;;475                pllmul = RCC->CFGR & RCC_CFGR_PLLMUL;
;;;476                plldiv = RCC->CFGR & RCC_CFGR_PLLDIV;
;;;477                pllmul = PLLMulTable[(pllmul >> RCC_CFGR_PLLMUL_Pos)];
;;;478                plldiv = (plldiv >> RCC_CFGR_PLLDIV_Pos) + 1U;   
;;;479                
;;;480                /* Compute PLL clock input */
;;;481                if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)
;;;482                {
;;;483                    if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
;;;484                    {
;;;485                        pllvco =  (HSI_VALUE >> 2U);
;;;486                    }
;;;487                    else 
;;;488                    {
;;;489                        pllvco =  HSI_VALUE;
00000c  4b63              LDR      r3,|L16.412|
00000e  4a64              LDR      r2,|L16.416|
000010  4964              LDR      r1,|L16.420|
000012  2f10              CMP      r7,#0x10              ;406
000014  d071              BEQ      |L16.250|
000016  dc14              BGT      |L16.66|
000018  2f01              CMP      r7,#1                 ;406
00001a  d073              BEQ      |L16.260|
00001c  2f02              CMP      r7,#2                 ;406
00001e  d06e              BEQ      |L16.254|
000020  2f04              CMP      r7,#4                 ;406
000022  d06d              BEQ      |L16.256|
000024  2f08              CMP      r7,#8                 ;406
000026  d10b              BNE      |L16.64|
;;;490                    }
;;;491                }
;;;492                else /* HSE source */
;;;493                {
;;;494                    pllvco = HSE_VALUE;
;;;495                }
;;;496                /* pllvco * pllmul / plldiv */
;;;497                pllvco = (pllvco * pllmul);
;;;498                frequency = (pllvco/ plldiv);
;;;499                
;;;500            }
;;;501            else if((srcclk == RCC_USBCLKSOURCE_HSI48) && (HAL_IS_BIT_SET(RCC->CRRCR, RCC_CRRCR_HSI48RDY)))
;;;502            {
;;;503                frequency = HSI48_VALUE;
;;;504            }
;;;505            else /* RCC_USBCLKSOURCE_NONE */
;;;506            {
;;;507                frequency = 0U;
;;;508            }
;;;509            break;
;;;510        }
;;;511    #endif /* USB */
;;;512    #if defined(RCC_CCIPR_USART1SEL)
;;;513      case RCC_PERIPHCLK_USART1:
;;;514        {
;;;515          /* Get the current USART1 source */
;;;516          srcclk = __HAL_RCC_GET_USART1_SOURCE();
;;;517    
;;;518          /* Check if USART1 clock selection is PCLK2 */
;;;519          if (srcclk == RCC_USART1CLKSOURCE_PCLK2)
;;;520          {
;;;521            frequency = HAL_RCC_GetPCLK2Freq();
;;;522          }
;;;523          /* Check if HSI is ready and if USART1 clock selection is HSI */
;;;524          else if ((srcclk == RCC_USART1CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
;;;525          {
;;;526            frequency = HSI_VALUE;
;;;527          }
;;;528          /* Check if USART1 clock selection is SYSCLK */
;;;529          else if (srcclk == RCC_USART1CLKSOURCE_SYSCLK)
;;;530          {
;;;531            frequency = HAL_RCC_GetSysClockFreq();
;;;532          }
;;;533          /* Check if LSE is ready  and if USART1 clock selection is LSE */
;;;534          else if ((srcclk == RCC_USART1CLKSOURCE_LSE) && (HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSERDY)))
;;;535          {
;;;536            frequency = LSE_VALUE;
;;;537          }
;;;538          /* Clock not enabled for USART1*/
;;;539          else
;;;540          {
;;;541            frequency = 0U;
;;;542          }
;;;543          break;
;;;544        }
;;;545    #endif /* RCC_CCIPR_USART1SEL */
;;;546      case RCC_PERIPHCLK_USART2:
;;;547        {
;;;548          /* Get the current USART2 source */
;;;549          srcclk = __HAL_RCC_GET_USART2_SOURCE();
;;;550    
;;;551          /* Check if USART2 clock selection is PCLK1 */
;;;552          if (srcclk == RCC_USART2CLKSOURCE_PCLK1)
;;;553          {
;;;554            frequency = HAL_RCC_GetPCLK1Freq();
;;;555          }
;;;556          /* Check if HSI is ready and if USART2 clock selection is HSI */
;;;557          else if ((srcclk == RCC_USART2CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
;;;558          {
;;;559            frequency = HSI_VALUE;
;;;560          }
;;;561          /* Check if USART2 clock selection is SYSCLK */
;;;562          else if (srcclk == RCC_USART2CLKSOURCE_SYSCLK)
;;;563          {
;;;564            frequency = HAL_RCC_GetSysClockFreq();
;;;565          }
;;;566          /* Check if LSE is ready  and if USART2 clock selection is LSE */
;;;567          else if ((srcclk == RCC_USART2CLKSOURCE_LSE) && (HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSERDY)))
;;;568          {
;;;569            frequency = LSE_VALUE;
;;;570          }
;;;571          /* Clock not enabled for USART2*/
;;;572          else
;;;573          {
;;;574            frequency = 0U;
;;;575          }
;;;576          break;
;;;577        }
;;;578      case RCC_PERIPHCLK_LPUART1:
;;;579        {
;;;580          /* Get the current LPUART1 source */
;;;581          srcclk = __HAL_RCC_GET_LPUART1_SOURCE();
;;;582    
;;;583          /* Check if LPUART1 clock selection is PCLK1 */
;;;584          if (srcclk == RCC_LPUART1CLKSOURCE_PCLK1)
;;;585          {
;;;586            frequency = HAL_RCC_GetPCLK1Freq();
;;;587          }
;;;588          /* Check if HSI is ready and if LPUART1 clock selection is HSI */
;;;589          else if ((srcclk == RCC_LPUART1CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
;;;590          {
;;;591            frequency = HSI_VALUE;
;;;592          }
;;;593          /* Check if LPUART1 clock selection is SYSCLK */
;;;594          else if (srcclk == RCC_LPUART1CLKSOURCE_SYSCLK)
;;;595          {
;;;596            frequency = HAL_RCC_GetSysClockFreq();
;;;597          }
;;;598          /* Check if LSE is ready  and if LPUART1 clock selection is LSE */
;;;599          else if ((srcclk == RCC_LPUART1CLKSOURCE_LSE) && (HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSERDY)))
;;;600          {
;;;601            frequency = LSE_VALUE;
;;;602          }
;;;603          /* Clock not enabled for LPUART1*/
;;;604          else
;;;605          {
;;;606            frequency = 0U;
;;;607          }
;;;608          break;
;;;609        }    
;;;610      case RCC_PERIPHCLK_I2C1:
;;;611        {
;;;612          /* Get the current I2C1 source */
;;;613          srcclk = __HAL_RCC_GET_I2C1_SOURCE();
000028  68c9              LDR      r1,[r1,#0xc]
00002a  2403              MOVS     r4,#3
00002c  0324              LSLS     r4,r4,#12
00002e  4021              ANDS     r1,r1,r4
;;;614    
;;;615          /* Check if I2C1 clock selection is PCLK1 */
;;;616          if (srcclk == RCC_I2C1CLKSOURCE_PCLK1)
000030  d067              BEQ      |L16.258|
;;;617          {
;;;618            frequency = HAL_RCC_GetPCLK1Freq();
;;;619          }
;;;620          /* Check if HSI is ready and if I2C1 clock selection is HSI */
;;;621          else if ((srcclk == RCC_I2C1CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
000032  10ad              ASRS     r5,r5,#2
;;;622          {
;;;623            frequency = HSI_VALUE;
;;;624          }
;;;625          /* Check if I2C1 clock selection is SYSCLK */
;;;626          else if (srcclk == RCC_I2C1CLKSOURCE_SYSCLK)
000034  1494              ASRS     r4,r2,#18
000036  42a9              CMP      r1,r5                 ;621
000038  d172              BNE      |L16.288|
00003a  6811              LDR      r1,[r2,#0]            ;621
00003c  0749              LSLS     r1,r1,#29             ;621
00003e  d477              BMI      |L16.304|
                  |L16.64|
;;;627          {
;;;628            frequency = HAL_RCC_GetSysClockFreq();
;;;629          }
;;;630          /* Clock not enabled for I2C1*/
;;;631          else
;;;632          {
;;;633            frequency = 0U;
;;;634          }
;;;635          break;
;;;636        } 
;;;637    #if defined(I2C2)
;;;638      case RCC_PERIPHCLK_I2C2:
;;;639        {
;;;640    
;;;641          /* Check if I2C2 on APB1 clock enabled*/
;;;642          if (READ_BIT(RCC->APB1ENR, (RCC_APB1ENR_I2C2EN))==RCC_APB1ENR_I2C2EN)
;;;643          {
;;;644            frequency = HAL_RCC_GetPCLK1Freq();
;;;645          }
;;;646          else
;;;647          {
;;;648            frequency = 0U;
;;;649          }
;;;650          break;
;;;651        } 
;;;652    #endif /* I2C2 */
;;;653    
;;;654    #if defined(RCC_CCIPR_I2C3SEL)
;;;655      case RCC_PERIPHCLK_I2C3:
;;;656        {
;;;657          /* Get the current I2C1 source */
;;;658          srcclk = __HAL_RCC_GET_I2C3_SOURCE();
;;;659    
;;;660          /* Check if I2C3 clock selection is PCLK1 */
;;;661          if (srcclk == RCC_I2C3CLKSOURCE_PCLK1)
;;;662          {
;;;663            frequency = HAL_RCC_GetPCLK1Freq();
;;;664          }
;;;665          /* Check if HSI is ready and if I2C3 clock selection is HSI */
;;;666          else if ((srcclk == RCC_I2C3CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
;;;667          {
;;;668            frequency = HSI_VALUE;
;;;669          }
;;;670          /* Check if I2C3 clock selection is SYSCLK */
;;;671          else if (srcclk == RCC_I2C3CLKSOURCE_SYSCLK)
;;;672          {
;;;673            frequency = HAL_RCC_GetSysClockFreq();
;;;674          }
;;;675          /* Clock not enabled for I2C3*/
;;;676          else
;;;677          {
;;;678            frequency = 0U;
;;;679          }
;;;680          break;
;;;681        } 
;;;682    #endif /* RCC_CCIPR_I2C3SEL */
;;;683      default: 
;;;684        {
;;;685          break;
;;;686        }
;;;687      }
;;;688      return(frequency);
;;;689    }
000040  bdf8              POP      {r3-r7,pc}
                  |L16.66|
000042  4c59              LDR      r4,|L16.424|
000044  2f20              CMP      r7,#0x20              ;406
000046  d003              BEQ      |L16.80|
000048  2f40              CMP      r7,#0x40              ;406
00004a  d02f              BEQ      |L16.172|
00004c  42b7              CMP      r7,r6                 ;406
00004e  d1f7              BNE      |L16.64|
                  |L16.80|
000050  690b              LDR      r3,[r1,#0x10]         ;414
000052  6909              LDR      r1,[r1,#0x10]         ;417
000054  2603              MOVS     r6,#3                 ;417
000056  0436              LSLS     r6,r6,#16             ;417
000058  2701              MOVS     r7,#1                 ;420
00005a  4031              ANDS     r1,r1,r6              ;417
00005c  043f              LSLS     r7,r7,#16             ;420
00005e  42b9              CMP      r1,r7                 ;420
000060  d103              BNE      |L16.106|
000062  0599              LSLS     r1,r3,#22             ;420
000064  d5ec              BPL      |L16.64|
                  |L16.102|
000066  4628              MOV      r0,r5                 ;422
                  |L16.104|
000068  bdf8              POP      {r3-r7,pc}
                  |L16.106|
00006a  2501              MOVS     r5,#1                 ;425
00006c  046d              LSLS     r5,r5,#17             ;425
00006e  42a9              CMP      r1,r5                 ;425
000070  d103              BNE      |L16.122|
000072  0799              LSLS     r1,r3,#30             ;425
000074  d5f8              BPL      |L16.104|
000076  484d              LDR      r0,|L16.428|
                  |L16.120|
000078  bdf8              POP      {r3-r7,pc}
                  |L16.122|
00007a  42b1              CMP      r1,r6                 ;430
00007c  d1fc              BNE      |L16.120|
00007e  6811              LDR      r1,[r2,#0]            ;430
000080  0389              LSLS     r1,r1,#14             ;430
000082  d5f9              BPL      |L16.120|
000084  6811              LDR      r1,[r2,#0]            ;433
000086  2003              MOVS     r0,#3                 ;433
000088  0500              LSLS     r0,r0,#20             ;433
00008a  4001              ANDS     r1,r1,r0              ;433
00008c  2001              MOVS     r0,#1                 ;435
00008e  0500              LSLS     r0,r0,#20             ;435
000090  1a09              SUBS     r1,r1,r0              ;435
000092  d009              BEQ      |L16.168|
000094  1a09              SUBS     r1,r1,r0              ;435
000096  d005              BEQ      |L16.164|
000098  4281              CMP      r1,r0                 ;435
00009a  d101              BNE      |L16.160|
00009c  4844              LDR      r0,|L16.432|
00009e  bdf8              POP      {r3-r7,pc}
                  |L16.160|
0000a0  4620              MOV      r0,r4                 ;454
0000a2  bdf8              POP      {r3-r7,pc}
                  |L16.164|
0000a4  4843              LDR      r0,|L16.436|
0000a6  bdf8              POP      {r3-r7,pc}
                  |L16.168|
0000a8  4843              LDR      r0,|L16.440|
                  |L16.170|
0000aa  bdf8              POP      {r3-r7,pc}
                  |L16.172|
0000ac  68c9              LDR      r1,[r1,#0xc]          ;470
0000ae  2501              MOVS     r5,#1                 ;470
0000b0  06ad              LSLS     r5,r5,#26             ;470
0000b2  4029              ANDS     r1,r1,r5              ;470
0000b4  d006              BEQ      |L16.196|
0000b6  42a9              CMP      r1,r5                 ;501
0000b8  d1f7              BNE      |L16.170|
0000ba  6891              LDR      r1,[r2,#8]            ;501
0000bc  0789              LSLS     r1,r1,#30             ;501
0000be  d5f4              BPL      |L16.170|
0000c0  483e              LDR      r0,|L16.444|
                  |L16.194|
0000c2  bdf8              POP      {r3-r7,pc}
                  |L16.196|
0000c4  6811              LDR      r1,[r2,#0]            ;472
0000c6  0189              LSLS     r1,r1,#6              ;472
0000c8  d5fb              BPL      |L16.194|
0000ca  68d0              LDR      r0,[r2,#0xc]          ;475
0000cc  68d1              LDR      r1,[r2,#0xc]          ;476
0000ce  0280              LSLS     r0,r0,#10
0000d0  4d3b              LDR      r5,|L16.448|
0000d2  0f00              LSRS     r0,r0,#28
0000d4  5c2d              LDRB     r5,[r5,r0]            ;477
0000d6  0208              LSLS     r0,r1,#8
0000d8  0f81              LSRS     r1,r0,#30
0000da  68d0              LDR      r0,[r2,#0xc]          ;481
0000dc  1c49              ADDS     r1,r1,#1              ;481
0000de  03c0              LSLS     r0,r0,#15             ;481
0000e0  d406              BMI      |L16.240|
0000e2  6810              LDR      r0,[r2,#0]            ;483
0000e4  06c0              LSLS     r0,r0,#27             ;483
0000e6  d501              BPL      |L16.236|
0000e8  4620              MOV      r0,r4                 ;485
0000ea  e002              B        |L16.242|
                  |L16.236|
0000ec  4618              MOV      r0,r3                 ;489
0000ee  e000              B        |L16.242|
                  |L16.240|
0000f0  4834              LDR      r0,|L16.452|
                  |L16.242|
0000f2  4368              MULS     r0,r5,r0              ;497
0000f4  f7fffffe          BL       __aeabi_uidivmod
                  |L16.248|
0000f8  bdf8              POP      {r3-r7,pc}
                  |L16.250|
0000fa  e04b              B        |L16.404|
0000fc  e002              B        |L16.260|
                  |L16.254|
0000fe  e01c              B        |L16.314|
                  |L16.256|
000100  e030              B        |L16.356|
                  |L16.258|
000102  e028              B        |L16.342|
                  |L16.260|
000104  68cc              LDR      r4,[r1,#0xc]          ;516
000106  07a4              LSLS     r4,r4,#30             ;516
000108  0fa4              LSRS     r4,r4,#30             ;516
00010a  d00b              BEQ      |L16.292|
00010c  2c02              CMP      r4,#2                 ;524
00010e  d00c              BEQ      |L16.298|
000110  2c01              CMP      r4,#1                 ;529
000112  d00f              BEQ      |L16.308|
000114  2c03              CMP      r4,#3                 ;534
000116  d1ef              BNE      |L16.248|
000118  6909              LDR      r1,[r1,#0x10]         ;534
00011a  0589              LSLS     r1,r1,#22             ;534
                  |L16.284|
00011c  d4a3              BMI      |L16.102|
00011e  e7eb              B        |L16.248|
                  |L16.288|
000120  e035              B        |L16.398|
000122  e005              B        |L16.304|
                  |L16.292|
000124  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000128  e7e6              B        |L16.248|
                  |L16.298|
00012a  6811              LDR      r1,[r2,#0]            ;524
00012c  0749              LSLS     r1,r1,#29             ;524
00012e  d5e3              BPL      |L16.248|
                  |L16.304|
000130  4618              MOV      r0,r3                 ;526
000132  e7e1              B        |L16.248|
                  |L16.308|
000134  f7fffffe          BL       HAL_RCC_GetSysClockFreq
000138  e7de              B        |L16.248|
                  |L16.314|
00013a  68cc              LDR      r4,[r1,#0xc]          ;549
00013c  260c              MOVS     r6,#0xc               ;549
00013e  4034              ANDS     r4,r4,r6              ;549
000140  d009              BEQ      |L16.342|
000142  2c08              CMP      r4,#8                 ;557
000144  d00a              BEQ      |L16.348|
000146  2c04              CMP      r4,#4                 ;562
000148  d0f4              BEQ      |L16.308|
00014a  2c0c              CMP      r4,#0xc               ;567
00014c  d1d4              BNE      |L16.248|
00014e  6909              LDR      r1,[r1,#0x10]         ;567
000150  0589              LSLS     r1,r1,#22             ;567
000152  d488              BMI      |L16.102|
000154  e7d0              B        |L16.248|
                  |L16.342|
000156  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
00015a  e7cd              B        |L16.248|
                  |L16.348|
00015c  6811              LDR      r1,[r2,#0]            ;557
00015e  0749              LSLS     r1,r1,#29             ;557
000160  d4e6              BMI      |L16.304|
000162  e7c9              B        |L16.248|
                  |L16.356|
000164  68cc              LDR      r4,[r1,#0xc]          ;581
000166  2703              MOVS     r7,#3                 ;581
000168  02bf              LSLS     r7,r7,#10             ;581
00016a  403c              ANDS     r4,r4,r7              ;581
00016c  d0f3              BEQ      |L16.342|
00016e  42b4              CMP      r4,r6                 ;589
000170  d103              BNE      |L16.378|
000172  6811              LDR      r1,[r2,#0]            ;589
000174  0749              LSLS     r1,r1,#29             ;589
000176  d4db              BMI      |L16.304|
000178  e7be              B        |L16.248|
                  |L16.378|
00017a  2201              MOVS     r2,#1                 ;594
00017c  0292              LSLS     r2,r2,#10             ;594
00017e  4294              CMP      r4,r2                 ;594
000180  d0d8              BEQ      |L16.308|
000182  42bc              CMP      r4,r7                 ;599
000184  d1b8              BNE      |L16.248|
000186  6909              LDR      r1,[r1,#0x10]         ;599
000188  0589              LSLS     r1,r1,#22             ;599
00018a  d4c7              BMI      |L16.284|
00018c  e7b4              B        |L16.248|
                  |L16.398|
00018e  42a1              CMP      r1,r4                 ;626
000190  d0d0              BEQ      |L16.308|
000192  e7b1              B        |L16.248|
                  |L16.404|
000194  6b91              LDR      r1,[r2,#0x38]         ;642
000196  0249              LSLS     r1,r1,#9              ;642
000198  d4dd              BMI      |L16.342|
00019a  e7ad              B        |L16.248|
;;;690    
                          ENDP

                  |L16.412|
                          DCD      0x00f42400
                  |L16.416|
                          DCD      0x40021000
                  |L16.420|
                          DCD      0x40021040
                  |L16.424|
                          DCD      0x003d0900
                  |L16.428|
                          DCD      0x00009088
                  |L16.432|
                          DCD      0x0007a120
                  |L16.436|
                          DCD      0x000f4240
                  |L16.440|
                          DCD      0x001e8480
                  |L16.444|
                          DCD      0x02dc6c00
                  |L16.448|
                          DCD      PLLMulTable
                  |L16.452|
                          DCD      0x007a1200

                          AREA ||i.HAL_RCCEx_LSECSS_Callback||, CODE, READONLY, ALIGN=1

                  HAL_RCCEx_LSECSS_Callback PROC
;;;754      */
;;;755    __weak void HAL_RCCEx_LSECSS_Callback(void)
000000  4770              BX       lr
;;;756    {
;;;757      /* NOTE : This function should not be modified, when the callback is needed,
;;;758                the @ref HAL_RCCEx_LSECSS_Callback should be implemented in the user file
;;;759       */
;;;760    }
;;;761      
                          ENDP


                          AREA ||i.HAL_RCCEx_LSECSS_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_LSECSS_IRQHandler PROC
;;;737      */
;;;738    void HAL_RCCEx_LSECSS_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;739    {
;;;740      /* Check RCC LSE CSSF flag  */
;;;741      if(__HAL_RCC_GET_IT(RCC_IT_LSECSS))
000002  4c04              LDR      r4,|L18.20|
000004  6960              LDR      r0,[r4,#0x14]
000006  0600              LSLS     r0,r0,#24
000008  d503              BPL      |L18.18|
;;;742      {
;;;743        /* RCC LSE Clock Security System interrupt user callback */
;;;744        HAL_RCCEx_LSECSS_Callback();
00000a  f7fffffe          BL       HAL_RCCEx_LSECSS_Callback
;;;745    
;;;746        /* Clear RCC LSE CSS pending bit */
;;;747        __HAL_RCC_CLEAR_IT(RCC_IT_LSECSS);
00000e  2080              MOVS     r0,#0x80
000010  61a0              STR      r0,[r4,#0x18]
                  |L18.18|
;;;748      }
;;;749    }                                                                            
000012  bd10              POP      {r4,pc}
;;;750    
                          ENDP

                  |L18.20|
                          DCD      0x40021000

                          AREA ||i.HAL_RCCEx_PeriphCLKConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_PeriphCLKConfig PROC
;;;119      */
;;;120    HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
000000  b5f8              PUSH     {r3-r7,lr}
;;;121    {
000002  4604              MOV      r4,r0
;;;122      uint32_t tickstart = 0U;
;;;123      uint32_t temp_reg = 0U;
;;;124      
;;;125      /* Check the parameters */
;;;126      assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
;;;127      
;;;128      /*------------------------------- RTC/LCD Configuration ------------------------*/ 
;;;129      if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC) 
000004  6800              LDR      r0,[r0,#0]
;;;130    #if defined(LCD)
;;;131       || (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LCD) == RCC_PERIPHCLK_LCD)
;;;132    #endif /* LCD */
;;;133         )
;;;134      {
;;;135        /* check for RTC Parameters used to output RTCCLK */
;;;136        if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
;;;137        {
;;;138          assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
;;;139        }
;;;140    
;;;141    #if defined(LCD)
;;;142        if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LCD) == RCC_PERIPHCLK_LCD)
;;;143        {
;;;144          assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->LCDClockSelection));
;;;145        }
;;;146    #endif /* LCD */
;;;147    
;;;148        FlagStatus       pwrclkchanged = RESET;
;;;149    
;;;150        /* As soon as function is called to change RTC clock source, activation of the 
;;;151           power domain is done. */
;;;152        /* Requires to enable write access to Backup Domain of necessary */
;;;153        if(__HAL_RCC_PWR_IS_CLK_DISABLED())
;;;154        {
;;;155          __HAL_RCC_PWR_CLK_ENABLE();
;;;156          pwrclkchanged = SET;
;;;157        }
;;;158        
;;;159        if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
;;;160        {
;;;161          /* Enable write access to Backup domain */
;;;162          SET_BIT(PWR->CR, PWR_CR_DBP);
;;;163          
;;;164          /* Wait for Backup domain Write protection disable */
;;;165          tickstart = HAL_GetTick();
;;;166    
;;;167          while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
;;;168          {
;;;169            if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
;;;170            {
;;;171              return HAL_TIMEOUT;
;;;172            }
;;;173          }
;;;174        }
;;;175    
;;;176        /* Check if user wants to change HSE RTC prescaler whereas HSE is enabled */ 
;;;177        temp_reg = (RCC->CR & RCC_CR_RTCPRE);
;;;178        if ((temp_reg != (PeriphClkInit->RTCClockSelection & RCC_CR_RTCPRE))
;;;179    #if defined (LCD)
;;;180         || (temp_reg != (PeriphClkInit->LCDClockSelection & RCC_CR_RTCPRE))
;;;181    #endif /* LCD */
;;;182           )
;;;183        { /* Check HSE State */
;;;184          if (((PeriphClkInit->RTCClockSelection & RCC_CSR_RTCSEL) == RCC_CSR_RTCSEL_HSE) && HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
;;;185          {
;;;186            /* To update HSE divider, first switch-OFF HSE clock oscillator*/
;;;187            return HAL_ERROR; 
;;;188          }
;;;189        }
;;;190        
;;;191        /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */ 
;;;192        temp_reg = (RCC->CSR & RCC_CSR_RTCSEL);
000006  4d65              LDR      r5,|L19.412|
000008  0681              LSLS     r1,r0,#26             ;129
00000a  d401              BMI      |L19.16|
00000c  0500              LSLS     r0,r0,#20             ;129
00000e  d57d              BPL      |L19.268|
                  |L19.16|
000010  2000              MOVS     r0,#0                 ;148
000012  9000              STR      r0,[sp,#0]            ;153
000014  4862              LDR      r0,|L19.416|
000016  6b80              LDR      r0,[r0,#0x38]         ;153
000018  00c0              LSLS     r0,r0,#3              ;153
00001a  d406              BMI      |L19.42|
00001c  4a60              LDR      r2,|L19.416|
00001e  6b91              LDR      r1,[r2,#0x38]         ;155
000020  0410              LSLS     r0,r2,#16             ;155
000022  4301              ORRS     r1,r1,r0              ;155
000024  6391              STR      r1,[r2,#0x38]         ;155
000026  2001              MOVS     r0,#1                 ;156
000028  9000              STR      r0,[sp,#0]            ;156
                  |L19.42|
00002a  4f5e              LDR      r7,|L19.420|
00002c  6838              LDR      r0,[r7,#0]            ;159
00002e  05c0              LSLS     r0,r0,#23             ;159
000030  d411              BMI      |L19.86|
000032  6838              LDR      r0,[r7,#0]            ;162
000034  15b9              ASRS     r1,r7,#22             ;162
000036  4308              ORRS     r0,r0,r1              ;162
000038  6038              STR      r0,[r7,#0]            ;162
00003a  f7fffffe          BL       HAL_GetTick
00003e  4606              MOV      r6,r0                 ;165
000040  6838              LDR      r0,[r7,#0]            ;167
000042  05c0              LSLS     r0,r0,#23             ;167
000044  d407              BMI      |L19.86|
                  |L19.70|
000046  f7fffffe          BL       HAL_GetTick
00004a  1b80              SUBS     r0,r0,r6              ;169
00004c  2864              CMP      r0,#0x64              ;169
00004e  d847              BHI      |L19.224|
000050  6838              LDR      r0,[r7,#0]            ;171
000052  05c0              LSLS     r0,r0,#23             ;171
000054  d5f7              BPL      |L19.70|
                  |L19.86|
000056  4852              LDR      r0,|L19.416|
000058  6802              LDR      r2,[r0,#0]            ;177
00005a  2003              MOVS     r0,#3                 ;177
00005c  6861              LDR      r1,[r4,#4]            ;178
00005e  0500              LSLS     r0,r0,#20             ;177
000060  460b              MOV      r3,r1                 ;178
000062  4002              ANDS     r2,r2,r0              ;177
000064  4003              ANDS     r3,r3,r0              ;178
000066  4293              CMP      r3,r2                 ;178
000068  d105              BNE      |L19.118|
00006a  2303              MOVS     r3,#3                 ;178
00006c  68a0              LDR      r0,[r4,#8]            ;178
00006e  051b              LSLS     r3,r3,#20             ;178
000070  4018              ANDS     r0,r0,r3              ;178
000072  4290              CMP      r0,r2                 ;178
000074  d009              BEQ      |L19.138|
                  |L19.118|
000076  0388              LSLS     r0,r1,#14             ;184
000078  0f80              LSRS     r0,r0,#30             ;184
00007a  2803              CMP      r0,#3                 ;184
00007c  d105              BNE      |L19.138|
00007e  4848              LDR      r0,|L19.416|
000080  6800              LDR      r0,[r0,#0]            ;184
000082  0380              LSLS     r0,r0,#14             ;184
000084  d501              BPL      |L19.138|
000086  2001              MOVS     r0,#1                 ;187
;;;193        
;;;194        if((temp_reg != 0x00000000U) && (((temp_reg != (PeriphClkInit->RTCClockSelection & RCC_CSR_RTCSEL)) \
;;;195          && (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC))
;;;196    #if defined(LCD)
;;;197          || ((temp_reg != (PeriphClkInit->LCDClockSelection & RCC_CSR_RTCSEL)) \
;;;198           && (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LCD) == RCC_PERIPHCLK_LCD))
;;;199    #endif /* LCD */
;;;200         ))
;;;201        {
;;;202          /* Store the content of CSR register before the reset of Backup Domain */
;;;203          temp_reg = (RCC->CSR & ~(RCC_CSR_RTCSEL));
;;;204          
;;;205          /* RTC Clock selection can be changed only if the Backup Domain is reset */
;;;206          __HAL_RCC_BACKUPRESET_FORCE();
;;;207          __HAL_RCC_BACKUPRESET_RELEASE();
;;;208          
;;;209          /* Restore the Content of CSR register */
;;;210          RCC->CSR = temp_reg;
;;;211          
;;;212           /* Wait for LSERDY if LSE was enabled */
;;;213          if (HAL_IS_BIT_SET(temp_reg, RCC_CSR_LSEON))
;;;214          {
;;;215            /* Get Start Tick */
;;;216            tickstart = HAL_GetTick();
;;;217            
;;;218            /* Wait till LSE is ready */  
;;;219            while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
;;;220            {
;;;221              if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
;;;222              {
;;;223                return HAL_TIMEOUT;
;;;224              }
;;;225            }
;;;226          }
;;;227        }
;;;228        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
;;;229    
;;;230        /* Require to disable power clock if necessary */
;;;231        if(pwrclkchanged == SET)
;;;232        {
;;;233          __HAL_RCC_PWR_CLK_DISABLE();
;;;234        }
;;;235      }
;;;236      
;;;237    #if defined (RCC_CCIPR_USART1SEL)
;;;238      /*------------------------------- USART1 Configuration ------------------------*/ 
;;;239      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
;;;240      {
;;;241        /* Check the parameters */
;;;242        assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));
;;;243        
;;;244        /* Configure the USART1 clock source */
;;;245        __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
;;;246      }
;;;247    #endif /* RCC_CCIPR_USART1SEL */
;;;248      
;;;249      /*----------------------------- USART2 Configuration --------------------------*/ 
;;;250      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
;;;251      {
;;;252        /* Check the parameters */
;;;253        assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));
;;;254        
;;;255        /* Configure the USART2 clock source */
;;;256        __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
;;;257      }
;;;258      
;;;259      /*------------------------------ LPUART1 Configuration ------------------------*/ 
;;;260      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
;;;261      {
;;;262        /* Check the parameters */
;;;263        assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));
;;;264        
;;;265        /* Configure the LPUAR1 clock source */
;;;266        __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
;;;267      }
;;;268    
;;;269      /*------------------------------ I2C1 Configuration ------------------------*/ 
;;;270      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
;;;271      {
;;;272        /* Check the parameters */
;;;273        assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));
;;;274        
;;;275        /* Configure the I2C1 clock source */
;;;276        __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
;;;277      }
;;;278    
;;;279    #if defined (RCC_CCIPR_I2C3SEL)
;;;280        /*------------------------------ I2C3 Configuration ------------------------*/ 
;;;281      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
;;;282      {
;;;283        /* Check the parameters */
;;;284        assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));
;;;285        
;;;286        /* Configure the I2C3 clock source */
;;;287        __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
;;;288      }  
;;;289    #endif /* RCC_CCIPR_I2C3SEL */
;;;290    
;;;291    #if defined(USB)
;;;292     /*---------------------------- USB and RNG configuration --------------------*/
;;;293      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
;;;294      {
;;;295        assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
;;;296        __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
;;;297      }
;;;298    #endif /* USB */
;;;299      
;;;300      /*---------------------------- LPTIM1 configuration ------------------------*/
;;;301      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
;;;302      {
;;;303        assert_param(IS_RCC_LPTIMCLK(PeriphClkInit->LptimClockSelection));
;;;304        __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->LptimClockSelection);
;;;305      }
;;;306    
;;;307      return HAL_OK;
;;;308    }
000088  bdf8              POP      {r3-r7,pc}
                  |L19.138|
00008a  6928              LDR      r0,[r5,#0x10]         ;192
00008c  2203              MOVS     r2,#3                 ;192
00008e  0412              LSLS     r2,r2,#16             ;192
000090  4010              ANDS     r0,r0,r2              ;192
000092  d02a              BEQ      |L19.234|
000094  4011              ANDS     r1,r1,r2              ;194
000096  4281              CMP      r1,r0                 ;194
000098  d002              BEQ      |L19.160|
00009a  7821              LDRB     r1,[r4,#0]            ;194
00009c  0689              LSLS     r1,r1,#26             ;194
00009e  d406              BMI      |L19.174|
                  |L19.160|
0000a0  68a1              LDR      r1,[r4,#8]            ;194
0000a2  4011              ANDS     r1,r1,r2              ;194
0000a4  4281              CMP      r1,r0                 ;194
0000a6  d020              BEQ      |L19.234|
0000a8  8820              LDRH     r0,[r4,#0]            ;194
0000aa  0500              LSLS     r0,r0,#20             ;194
0000ac  d51d              BPL      |L19.234|
                  |L19.174|
0000ae  6929              LDR      r1,[r5,#0x10]         ;203
0000b0  6928              LDR      r0,[r5,#0x10]         ;206
0000b2  4391              BICS     r1,r1,r2              ;203
0000b4  2201              MOVS     r2,#1                 ;206
0000b6  04d2              LSLS     r2,r2,#19             ;206
0000b8  4310              ORRS     r0,r0,r2              ;206
0000ba  6128              STR      r0,[r5,#0x10]         ;206
0000bc  6928              LDR      r0,[r5,#0x10]         ;207
0000be  4390              BICS     r0,r0,r2              ;207
0000c0  6128              STR      r0,[r5,#0x10]         ;207
0000c2  6129              STR      r1,[r5,#0x10]         ;210
0000c4  05c8              LSLS     r0,r1,#23             ;213
0000c6  d510              BPL      |L19.234|
0000c8  f7fffffe          BL       HAL_GetTick
0000cc  4606              MOV      r6,r0                 ;216
0000ce  6928              LDR      r0,[r5,#0x10]         ;219
0000d0  0580              LSLS     r0,r0,#22             ;219
0000d2  d40a              BMI      |L19.234|
0000d4  4f34              LDR      r7,|L19.424|
                  |L19.214|
0000d6  f7fffffe          BL       HAL_GetTick
0000da  1b80              SUBS     r0,r0,r6              ;221
0000dc  42b8              CMP      r0,r7                 ;221
0000de  d901              BLS      |L19.228|
                  |L19.224|
0000e0  2003              MOVS     r0,#3                 ;223
0000e2  bdf8              POP      {r3-r7,pc}
                  |L19.228|
0000e4  6928              LDR      r0,[r5,#0x10]         ;223
0000e6  0580              LSLS     r0,r0,#22             ;223
0000e8  d5f5              BPL      |L19.214|
                  |L19.234|
0000ea  6862              LDR      r2,[r4,#4]            ;228
0000ec  0390              LSLS     r0,r2,#14             ;228
0000ee  0f80              LSRS     r0,r0,#30             ;228
0000f0  2803              CMP      r0,#3                 ;228
0000f2  d106              BNE      |L19.258|
0000f4  492a              LDR      r1,|L19.416|
0000f6  680b              LDR      r3,[r1,#0]            ;228
0000f8  0500              LSLS     r0,r0,#20             ;228
0000fa  4383              BICS     r3,r3,r0              ;228
0000fc  4002              ANDS     r2,r2,r0              ;228
0000fe  4313              ORRS     r3,r3,r2              ;228
000100  600b              STR      r3,[r1,#0]            ;228
                  |L19.258|
000102  6929              LDR      r1,[r5,#0x10]         ;228
000104  2203              MOVS     r2,#3                 ;228
000106  0412              LSLS     r2,r2,#16             ;228
000108  6860              LDR      r0,[r4,#4]            ;228
00010a  e000              B        |L19.270|
                  |L19.268|
00010c  e00a              B        |L19.292|
                  |L19.270|
00010e  4010              ANDS     r0,r0,r2              ;228
000110  4301              ORRS     r1,r1,r0              ;228
000112  6129              STR      r1,[r5,#0x10]         ;228
000114  9800              LDR      r0,[sp,#0]            ;231
000116  2800              CMP      r0,#0                 ;231
000118  d004              BEQ      |L19.292|
00011a  4921              LDR      r1,|L19.416|
00011c  6b88              LDR      r0,[r1,#0x38]         ;233
00011e  040a              LSLS     r2,r1,#16             ;233
000120  4390              BICS     r0,r0,r2              ;233
000122  6388              STR      r0,[r1,#0x38]         ;233
                  |L19.292|
000124  7820              LDRB     r0,[r4,#0]            ;239
000126  07c0              LSLS     r0,r0,#31             ;239
000128  d005              BEQ      |L19.310|
00012a  68e8              LDR      r0,[r5,#0xc]          ;245
00012c  68e1              LDR      r1,[r4,#0xc]          ;245
00012e  0880              LSRS     r0,r0,#2              ;245
000130  0080              LSLS     r0,r0,#2              ;245
000132  4308              ORRS     r0,r0,r1              ;245
000134  60e8              STR      r0,[r5,#0xc]          ;245
                  |L19.310|
000136  7820              LDRB     r0,[r4,#0]            ;250
000138  0780              LSLS     r0,r0,#30             ;250
00013a  d505              BPL      |L19.328|
00013c  68e8              LDR      r0,[r5,#0xc]          ;256
00013e  210c              MOVS     r1,#0xc               ;256
000140  4388              BICS     r0,r0,r1              ;256
000142  6921              LDR      r1,[r4,#0x10]         ;256
000144  4308              ORRS     r0,r0,r1              ;256
000146  60e8              STR      r0,[r5,#0xc]          ;256
                  |L19.328|
000148  7820              LDRB     r0,[r4,#0]            ;260
00014a  0740              LSLS     r0,r0,#29             ;260
00014c  d506              BPL      |L19.348|
00014e  68e8              LDR      r0,[r5,#0xc]          ;266
000150  2103              MOVS     r1,#3                 ;266
000152  0289              LSLS     r1,r1,#10             ;266
000154  4388              BICS     r0,r0,r1              ;266
000156  6961              LDR      r1,[r4,#0x14]         ;266
000158  4308              ORRS     r0,r0,r1              ;266
00015a  60e8              STR      r0,[r5,#0xc]          ;266
                  |L19.348|
00015c  7820              LDRB     r0,[r4,#0]            ;270
00015e  0700              LSLS     r0,r0,#28             ;270
000160  d506              BPL      |L19.368|
000162  68e8              LDR      r0,[r5,#0xc]          ;276
000164  2103              MOVS     r1,#3                 ;276
000166  0309              LSLS     r1,r1,#12             ;276
000168  4388              BICS     r0,r0,r1              ;276
00016a  69a1              LDR      r1,[r4,#0x18]         ;276
00016c  4308              ORRS     r0,r0,r1              ;276
00016e  60e8              STR      r0,[r5,#0xc]          ;276
                  |L19.368|
000170  7820              LDRB     r0,[r4,#0]            ;293
000172  0640              LSLS     r0,r0,#25             ;293
000174  d506              BPL      |L19.388|
000176  68e8              LDR      r0,[r5,#0xc]          ;296
000178  2101              MOVS     r1,#1                 ;296
00017a  0689              LSLS     r1,r1,#26             ;296
00017c  4388              BICS     r0,r0,r1              ;296
00017e  6a21              LDR      r1,[r4,#0x20]         ;296
000180  4308              ORRS     r0,r0,r1              ;296
000182  60e8              STR      r0,[r5,#0xc]          ;296
                  |L19.388|
000184  7820              LDRB     r0,[r4,#0]            ;301
000186  0600              LSLS     r0,r0,#24             ;301
000188  d506              BPL      |L19.408|
00018a  68e8              LDR      r0,[r5,#0xc]          ;304
00018c  2103              MOVS     r1,#3                 ;304
00018e  0489              LSLS     r1,r1,#18             ;304
000190  4388              BICS     r0,r0,r1              ;304
000192  69e1              LDR      r1,[r4,#0x1c]         ;304
000194  4308              ORRS     r0,r0,r1              ;304
000196  60e8              STR      r0,[r5,#0xc]          ;304
                  |L19.408|
000198  2000              MOVS     r0,#0                 ;307
00019a  bdf8              POP      {r3-r7,pc}
;;;309    
                          ENDP

                  |L19.412|
                          DCD      0x40021040
                  |L19.416|
                          DCD      0x40021000
                  |L19.420|
                          DCD      0x40007000
                  |L19.424|
                          DCD      0x00001388

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_L0_V1.10.0\\Drivers\\STM32L0xx_HAL_Driver\\Src\\stm32l0xx_hal_rcc_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32l0xx_hal_rcc_ex_c_bed13b44____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_L0_V1.10.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___22_stm32l0xx_hal_rcc_ex_c_bed13b44____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32l0xx_hal_rcc_ex_c_bed13b44____REVSH|
#line 402
|__asm___22_stm32l0xx_hal_rcc_ex_c_bed13b44____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
