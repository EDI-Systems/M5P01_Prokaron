; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32l0xx_hal_usart.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32l0xx_hal_usart.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\STM32L0xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\CMSIS\Device\ST\STM32L0xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\STM32L0xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32L053C8T6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32L0xx_DFP\2.0.0\Drivers\CMSIS\Device\ST\STM32L0xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32L053xx -DSTM32L0xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32l0xx_hal_usart.crf ..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\STM32L0xx_HAL_Driver\Src\stm32l0xx_hal_usart.c]
                          THUMB

                          AREA ||i.HAL_USART_Abort||, CODE, READONLY, ALIGN=1

                  HAL_USART_Abort PROC
;;;1282   */
;;;1283   HAL_StatusTypeDef HAL_USART_Abort(USART_HandleTypeDef *husart)
000000  b510              PUSH     {r4,lr}
;;;1284   {
000002  4604              MOV      r4,r0
;;;1285     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1286     CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6820              LDR      r0,[r4,#0]
000006  6800              LDR      r0,[r0,#0]
000008  21ff              MOVS     r1,#0xff
00000a  31e1              ADDS     r1,r1,#0xe1
00000c  4388              BICS     r0,r0,r1
00000e  6821              LDR      r1,[r4,#0]
000010  6008              STR      r0,[r1,#0]
;;;1287     CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
000012  6820              LDR      r0,[r4,#0]
000014  6880              LDR      r0,[r0,#8]
000016  0840              LSRS     r0,r0,#1
000018  0040              LSLS     r0,r0,#1
00001a  6821              LDR      r1,[r4,#0]
00001c  6088              STR      r0,[r1,#8]
;;;1288   
;;;1289     /* Disable the USART DMA Tx request if enabled */
;;;1290     if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT))
00001e  6820              LDR      r0,[r4,#0]
000020  6880              LDR      r0,[r0,#8]
000022  2180              MOVS     r1,#0x80
000024  4008              ANDS     r0,r0,r1
000026  2800              CMP      r0,#0
000028  d00d              BEQ      |L1.70|
;;;1291     {
;;;1292       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
00002a  6820              LDR      r0,[r4,#0]
00002c  6880              LDR      r0,[r0,#8]
00002e  4388              BICS     r0,r0,r1
000030  6821              LDR      r1,[r4,#0]
000032  6088              STR      r0,[r1,#8]
;;;1293   
;;;1294       /* Abort the USART DMA Tx channel : use blocking DMA Abort API (no callback) */
;;;1295       if(husart->hdmatx != NULL)
000034  6ba0              LDR      r0,[r4,#0x38]
000036  2800              CMP      r0,#0
000038  d005              BEQ      |L1.70|
;;;1296       {
;;;1297         /* Set the USART DMA Abort callback to Null. 
;;;1298            No call back execution at end of DMA abort procedure */
;;;1299         husart->hdmatx->XferAbortCallback = NULL;
00003a  2000              MOVS     r0,#0
00003c  6ba1              LDR      r1,[r4,#0x38]
00003e  63c8              STR      r0,[r1,#0x3c]
;;;1300   
;;;1301         HAL_DMA_Abort(husart->hdmatx);
000040  6ba0              LDR      r0,[r4,#0x38]
000042  f7fffffe          BL       HAL_DMA_Abort
                  |L1.70|
;;;1302       }
;;;1303     }
;;;1304   
;;;1305     /* Disable the USART DMA Rx request if enabled */
;;;1306     if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
000046  6820              LDR      r0,[r4,#0]
000048  6880              LDR      r0,[r0,#8]
00004a  2140              MOVS     r1,#0x40
00004c  4008              ANDS     r0,r0,r1
00004e  2800              CMP      r0,#0
000050  d00d              BEQ      |L1.110|
;;;1307     {
;;;1308       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
000052  6820              LDR      r0,[r4,#0]
000054  6880              LDR      r0,[r0,#8]
000056  4388              BICS     r0,r0,r1
000058  6821              LDR      r1,[r4,#0]
00005a  6088              STR      r0,[r1,#8]
;;;1309   
;;;1310       /* Abort the USART DMA Rx channel : use blocking DMA Abort API (no callback) */
;;;1311       if(husart->hdmarx != NULL)
00005c  6be0              LDR      r0,[r4,#0x3c]
00005e  2800              CMP      r0,#0
000060  d005              BEQ      |L1.110|
;;;1312       {
;;;1313         /* Set the USART DMA Abort callback to Null. 
;;;1314            No call back execution at end of DMA abort procedure */
;;;1315         husart->hdmarx->XferAbortCallback = NULL;
000062  2000              MOVS     r0,#0
000064  6be1              LDR      r1,[r4,#0x3c]
000066  63c8              STR      r0,[r1,#0x3c]
;;;1316   
;;;1317         HAL_DMA_Abort(husart->hdmarx);
000068  6be0              LDR      r0,[r4,#0x3c]
00006a  f7fffffe          BL       HAL_DMA_Abort
                  |L1.110|
;;;1318       }
;;;1319     }
;;;1320   
;;;1321     /* Reset Tx and Rx transfer counters */
;;;1322     husart->TxXferCount = 0; 
00006e  2000              MOVS     r0,#0
000070  8560              STRH     r0,[r4,#0x2a]
;;;1323     husart->RxXferCount = 0; 
000072  8660              STRH     r0,[r4,#0x32]
;;;1324   
;;;1325     /* Clear the Error flags in the ICR register */
;;;1326     __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_OREF | USART_CLEAR_NEF | USART_CLEAR_PEF | USART_CLEAR_FEF);
000074  200f              MOVS     r0,#0xf
000076  6821              LDR      r1,[r4,#0]
000078  6208              STR      r0,[r1,#0x20]
;;;1327   
;;;1328     /* Restore husart->State to Ready */
;;;1329     husart->State  = HAL_USART_STATE_READY;
00007a  2001              MOVS     r0,#1
00007c  6460              STR      r0,[r4,#0x44]
;;;1330   
;;;1331     /* Reset Handle ErrorCode to No Error */
;;;1332     husart->ErrorCode = HAL_USART_ERROR_NONE;
00007e  2000              MOVS     r0,#0
000080  64a0              STR      r0,[r4,#0x48]
;;;1333   
;;;1334     return HAL_OK;
;;;1335   }
000082  bd10              POP      {r4,pc}
;;;1336   
                          ENDP


                          AREA ||i.HAL_USART_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_AbortCpltCallback PROC
;;;1729     */
;;;1730   __weak void HAL_USART_AbortCpltCallback (USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1731   {
;;;1732     /* Prevent unused argument(s) compilation warning */
;;;1733     UNUSED(husart);
;;;1734   
;;;1735     /* NOTE : This function should not be modified, when the callback is needed,
;;;1736               the HAL_USART_AbortCpltCallback can be implemented in the user file.
;;;1737      */
;;;1738   }
;;;1739   
                          ENDP


                          AREA ||i.HAL_USART_Abort_IT||, CODE, READONLY, ALIGN=2

                  HAL_USART_Abort_IT PROC
;;;1350   */
;;;1351   HAL_StatusTypeDef HAL_USART_Abort_IT(USART_HandleTypeDef *husart)
000000  b570              PUSH     {r4-r6,lr}
;;;1352   {
000002  4604              MOV      r4,r0
;;;1353     uint32_t abortcplt = 1;
000004  2501              MOVS     r5,#1
;;;1354     
;;;1355     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1356     CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000006  6820              LDR      r0,[r4,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  21ff              MOVS     r1,#0xff
00000c  31e1              ADDS     r1,r1,#0xe1
00000e  4388              BICS     r0,r0,r1
000010  6821              LDR      r1,[r4,#0]
000012  6008              STR      r0,[r1,#0]
;;;1357     CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
000014  6820              LDR      r0,[r4,#0]
000016  6880              LDR      r0,[r0,#8]
000018  43a8              BICS     r0,r0,r5
00001a  6821              LDR      r1,[r4,#0]
00001c  6088              STR      r0,[r1,#8]
;;;1358   
;;;1359     /* If DMA Tx and/or DMA Rx Handles are associated to USART Handle, DMA Abort complete callbacks should be initialised
;;;1360        before any call to DMA Abort functions */
;;;1361     /* DMA Tx Handle is valid */
;;;1362     if(husart->hdmatx != NULL)
00001e  6ba0              LDR      r0,[r4,#0x38]
000020  2800              CMP      r0,#0
000022  d00c              BEQ      |L3.62|
;;;1363     {
;;;1364       /* Set DMA Abort Complete callback if USART DMA Tx request if enabled.
;;;1365          Otherwise, set it to NULL */
;;;1366       if(HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT))
000024  6820              LDR      r0,[r4,#0]
000026  6880              LDR      r0,[r0,#8]
000028  2180              MOVS     r1,#0x80
00002a  4008              ANDS     r0,r0,r1
00002c  2800              CMP      r0,#0
00002e  d003              BEQ      |L3.56|
;;;1367       {
;;;1368         husart->hdmatx->XferAbortCallback = USART_DMATxAbortCallback;
000030  482b              LDR      r0,|L3.224|
000032  6ba1              LDR      r1,[r4,#0x38]
000034  63c8              STR      r0,[r1,#0x3c]
000036  e002              B        |L3.62|
                  |L3.56|
;;;1369       }
;;;1370       else
;;;1371       {
;;;1372         husart->hdmatx->XferAbortCallback = NULL;
000038  2000              MOVS     r0,#0
00003a  6ba1              LDR      r1,[r4,#0x38]
00003c  63c8              STR      r0,[r1,#0x3c]
                  |L3.62|
;;;1373       }
;;;1374     }
;;;1375     /* DMA Rx Handle is valid */
;;;1376     if(husart->hdmarx != NULL)
00003e  6be0              LDR      r0,[r4,#0x3c]
000040  2800              CMP      r0,#0
000042  d00c              BEQ      |L3.94|
;;;1377     {
;;;1378       /* Set DMA Abort Complete callback if USART DMA Rx request if enabled.
;;;1379          Otherwise, set it to NULL */
;;;1380       if(HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
000044  6820              LDR      r0,[r4,#0]
000046  6880              LDR      r0,[r0,#8]
000048  2140              MOVS     r1,#0x40
00004a  4008              ANDS     r0,r0,r1
00004c  2800              CMP      r0,#0
00004e  d003              BEQ      |L3.88|
;;;1381       {
;;;1382         husart->hdmarx->XferAbortCallback = USART_DMARxAbortCallback;
000050  4824              LDR      r0,|L3.228|
000052  6be1              LDR      r1,[r4,#0x3c]
000054  63c8              STR      r0,[r1,#0x3c]
000056  e002              B        |L3.94|
                  |L3.88|
;;;1383       }
;;;1384       else
;;;1385       {
;;;1386         husart->hdmarx->XferAbortCallback = NULL;
000058  2000              MOVS     r0,#0
00005a  6be1              LDR      r1,[r4,#0x3c]
00005c  63c8              STR      r0,[r1,#0x3c]
                  |L3.94|
;;;1387       }
;;;1388     }
;;;1389     
;;;1390     /* Disable the USART DMA Tx request if enabled */
;;;1391     if(HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT))
00005e  6820              LDR      r0,[r4,#0]
000060  6880              LDR      r0,[r0,#8]
000062  2180              MOVS     r1,#0x80
000064  4008              ANDS     r0,r0,r1
000066  2800              CMP      r0,#0
000068  d011              BEQ      |L3.142|
;;;1392     {
;;;1393       /* Disable DMA Tx at USART level */
;;;1394       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
00006a  6820              LDR      r0,[r4,#0]
00006c  6880              LDR      r0,[r0,#8]
00006e  4388              BICS     r0,r0,r1
000070  6821              LDR      r1,[r4,#0]
000072  6088              STR      r0,[r1,#8]
;;;1395   
;;;1396       /* Abort the USART DMA Tx channel : use non blocking DMA Abort API (callback) */
;;;1397       if(husart->hdmatx != NULL)
000074  6ba0              LDR      r0,[r4,#0x38]
000076  2800              CMP      r0,#0
000078  d009              BEQ      |L3.142|
;;;1398       {
;;;1399         /* USART Tx DMA Abort callback has already been initialised : 
;;;1400            will lead to call HAL_USART_AbortCpltCallback() at end of DMA abort procedure */
;;;1401   
;;;1402         /* Abort DMA TX */
;;;1403         if(HAL_DMA_Abort_IT(husart->hdmatx) != HAL_OK)
00007a  6ba0              LDR      r0,[r4,#0x38]
00007c  f7fffffe          BL       HAL_DMA_Abort_IT
000080  2800              CMP      r0,#0
000082  d003              BEQ      |L3.140|
;;;1404         {
;;;1405           husart->hdmatx->XferAbortCallback = NULL;
000084  2000              MOVS     r0,#0
000086  6ba1              LDR      r1,[r4,#0x38]
000088  63c8              STR      r0,[r1,#0x3c]
00008a  e000              B        |L3.142|
                  |L3.140|
;;;1406         }
;;;1407         else
;;;1408         {
;;;1409           abortcplt = 0;
00008c  2500              MOVS     r5,#0
                  |L3.142|
;;;1410         }
;;;1411       }
;;;1412     }
;;;1413   
;;;1414     /* Disable the USART DMA Rx request if enabled */
;;;1415     if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
00008e  6820              LDR      r0,[r4,#0]
000090  6880              LDR      r0,[r0,#8]
000092  2140              MOVS     r1,#0x40
000094  4008              ANDS     r0,r0,r1
000096  2800              CMP      r0,#0
000098  d012              BEQ      |L3.192|
;;;1416     {
;;;1417       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
00009a  6820              LDR      r0,[r4,#0]
00009c  6880              LDR      r0,[r0,#8]
00009e  4388              BICS     r0,r0,r1
0000a0  6821              LDR      r1,[r4,#0]
0000a2  6088              STR      r0,[r1,#8]
;;;1418   
;;;1419       /* Abort the USART DMA Rx channel : use non blocking DMA Abort API (callback) */
;;;1420       if(husart->hdmarx != NULL)
0000a4  6be0              LDR      r0,[r4,#0x3c]
0000a6  2800              CMP      r0,#0
0000a8  d00a              BEQ      |L3.192|
;;;1421       {
;;;1422         /* USART Rx DMA Abort callback has already been initialised : 
;;;1423            will lead to call HAL_USART_AbortCpltCallback() at end of DMA abort procedure */
;;;1424   
;;;1425         /* Abort DMA RX */
;;;1426         if(HAL_DMA_Abort_IT(husart->hdmarx) != HAL_OK)
0000aa  6be0              LDR      r0,[r4,#0x3c]
0000ac  f7fffffe          BL       HAL_DMA_Abort_IT
0000b0  2800              CMP      r0,#0
0000b2  d004              BEQ      |L3.190|
;;;1427         {
;;;1428           husart->hdmarx->XferAbortCallback = NULL;
0000b4  2000              MOVS     r0,#0
0000b6  6be1              LDR      r1,[r4,#0x3c]
0000b8  63c8              STR      r0,[r1,#0x3c]
;;;1429           abortcplt = 1;
0000ba  2501              MOVS     r5,#1
0000bc  e000              B        |L3.192|
                  |L3.190|
;;;1430         }
;;;1431         else
;;;1432         {
;;;1433           abortcplt = 0;
0000be  2500              MOVS     r5,#0
                  |L3.192|
;;;1434         }
;;;1435       }
;;;1436     }
;;;1437   
;;;1438     /* if no DMA abort complete callback execution is required => call user Abort Complete callback */
;;;1439     if (abortcplt == 1)
0000c0  2d01              CMP      r5,#1
0000c2  d10b              BNE      |L3.220|
;;;1440     {
;;;1441       /* Reset Tx and Rx transfer counters */
;;;1442       husart->TxXferCount = 0; 
0000c4  2000              MOVS     r0,#0
0000c6  8560              STRH     r0,[r4,#0x2a]
;;;1443       husart->RxXferCount = 0;
0000c8  8660              STRH     r0,[r4,#0x32]
;;;1444   
;;;1445       /* Reset errorCode */
;;;1446       husart->ErrorCode = HAL_USART_ERROR_NONE;
0000ca  64a0              STR      r0,[r4,#0x48]
;;;1447   
;;;1448       /* Clear the Error flags in the ICR register */
;;;1449       __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_OREF | USART_CLEAR_NEF | USART_CLEAR_PEF | USART_CLEAR_FEF);
0000cc  200f              MOVS     r0,#0xf
0000ce  6821              LDR      r1,[r4,#0]
0000d0  6208              STR      r0,[r1,#0x20]
;;;1450   
;;;1451       /* Restore husart->State to Ready */
;;;1452       husart->State  = HAL_USART_STATE_READY;
0000d2  2001              MOVS     r0,#1
0000d4  6460              STR      r0,[r4,#0x44]
;;;1453   
;;;1454       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1455       HAL_USART_AbortCpltCallback(husart);
0000d6  4620              MOV      r0,r4
0000d8  f7fffffe          BL       HAL_USART_AbortCpltCallback
                  |L3.220|
;;;1456     }
;;;1457   
;;;1458     return HAL_OK;
0000dc  2000              MOVS     r0,#0
;;;1459   }
0000de  bd70              POP      {r4-r6,pc}
;;;1460   
                          ENDP

                  |L3.224|
                          DCD      USART_DMATxAbortCallback
                  |L3.228|
                          DCD      USART_DMARxAbortCallback

                          AREA ||i.HAL_USART_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_USART_DMAPause PROC
;;;1161     */
;;;1162   HAL_StatusTypeDef HAL_USART_DMAPause(USART_HandleTypeDef *husart)
000000  4601              MOV      r1,r0
;;;1163   {
;;;1164     /* Process Locked */
;;;1165     __HAL_LOCK(husart);
000002  bf00              NOP      
000004  6c08              LDR      r0,[r1,#0x40]
000006  2801              CMP      r0,#1
000008  d101              BNE      |L4.14|
00000a  2002              MOVS     r0,#2
                  |L4.12|
;;;1166   
;;;1167     if( (husart->State == HAL_USART_STATE_BUSY_TX) &&
;;;1168         (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT)))
;;;1169     {
;;;1170       /* Disable the USART DMA Tx request */
;;;1171       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1172     }
;;;1173     else if( (husart->State == HAL_USART_STATE_BUSY_RX) ||
;;;1174              (husart->State == HAL_USART_STATE_BUSY_TX_RX) )
;;;1175     {
;;;1176       if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT))
;;;1177       {
;;;1178         /* Disable the USART DMA Tx request */
;;;1179         CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1180       }
;;;1181       if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
;;;1182       {
;;;1183         /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1184         CLEAR_BIT(husart->Instance->CR1, USART_CR1_PEIE);
;;;1185         CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;1186   
;;;1187         /* Disable the USART DMA Rx request */
;;;1188         CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
;;;1189       }
;;;1190     }
;;;1191   
;;;1192     /* Process Unlocked */
;;;1193     __HAL_UNLOCK(husart);
;;;1194   
;;;1195     return HAL_OK;
;;;1196   }
00000c  4770              BX       lr
                  |L4.14|
00000e  2001              MOVS     r0,#1                 ;1165
000010  6408              STR      r0,[r1,#0x40]         ;1165
000012  bf00              NOP                            ;1165
000014  6c48              LDR      r0,[r1,#0x44]         ;1167
000016  2812              CMP      r0,#0x12              ;1167
000018  d10b              BNE      |L4.50|
00001a  6808              LDR      r0,[r1,#0]            ;1168
00001c  6880              LDR      r0,[r0,#8]            ;1168
00001e  2280              MOVS     r2,#0x80              ;1168
000020  4010              ANDS     r0,r0,r2              ;1168
000022  2800              CMP      r0,#0                 ;1168
000024  d005              BEQ      |L4.50|
000026  6808              LDR      r0,[r1,#0]            ;1171
000028  6880              LDR      r0,[r0,#8]            ;1171
00002a  4390              BICS     r0,r0,r2              ;1171
00002c  680a              LDR      r2,[r1,#0]            ;1171
00002e  6090              STR      r0,[r2,#8]            ;1171
000030  e028              B        |L4.132|
                  |L4.50|
000032  6c48              LDR      r0,[r1,#0x44]         ;1173
000034  2822              CMP      r0,#0x22              ;1173
000036  d002              BEQ      |L4.62|
000038  6c48              LDR      r0,[r1,#0x44]         ;1174
00003a  2832              CMP      r0,#0x32              ;1174
00003c  d122              BNE      |L4.132|
                  |L4.62|
00003e  6808              LDR      r0,[r1,#0]            ;1176
000040  6880              LDR      r0,[r0,#8]            ;1176
000042  2280              MOVS     r2,#0x80              ;1176
000044  4010              ANDS     r0,r0,r2              ;1176
000046  2800              CMP      r0,#0                 ;1176
000048  d004              BEQ      |L4.84|
00004a  6808              LDR      r0,[r1,#0]            ;1179
00004c  6880              LDR      r0,[r0,#8]            ;1179
00004e  4390              BICS     r0,r0,r2              ;1179
000050  680a              LDR      r2,[r1,#0]            ;1179
000052  6090              STR      r0,[r2,#8]            ;1179
                  |L4.84|
000054  6808              LDR      r0,[r1,#0]            ;1181
000056  6880              LDR      r0,[r0,#8]            ;1181
000058  2240              MOVS     r2,#0x40              ;1181
00005a  4010              ANDS     r0,r0,r2              ;1181
00005c  2800              CMP      r0,#0                 ;1181
00005e  d011              BEQ      |L4.132|
000060  6808              LDR      r0,[r1,#0]            ;1184
000062  6800              LDR      r0,[r0,#0]            ;1184
000064  0092              LSLS     r2,r2,#2              ;1184
000066  4390              BICS     r0,r0,r2              ;1184
000068  680a              LDR      r2,[r1,#0]            ;1184
00006a  6010              STR      r0,[r2,#0]            ;1184
00006c  6808              LDR      r0,[r1,#0]            ;1185
00006e  6880              LDR      r0,[r0,#8]            ;1185
000070  0840              LSRS     r0,r0,#1              ;1185
000072  0040              LSLS     r0,r0,#1              ;1185
000074  680a              LDR      r2,[r1,#0]            ;1185
000076  6090              STR      r0,[r2,#8]            ;1185
000078  6808              LDR      r0,[r1,#0]            ;1188
00007a  6880              LDR      r0,[r0,#8]            ;1188
00007c  2240              MOVS     r2,#0x40              ;1188
00007e  4390              BICS     r0,r0,r2              ;1188
000080  680a              LDR      r2,[r1,#0]            ;1188
000082  6090              STR      r0,[r2,#8]            ;1188
                  |L4.132|
000084  bf00              NOP                            ;1193
000086  2000              MOVS     r0,#0                 ;1193
000088  6408              STR      r0,[r1,#0x40]         ;1193
00008a  bf00              NOP                            ;1193
00008c  bf00              NOP                            ;1195
00008e  e7bd              B        |L4.12|
;;;1197   
                          ENDP


                          AREA ||i.HAL_USART_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_USART_DMAResume PROC
;;;1202     */
;;;1203   HAL_StatusTypeDef HAL_USART_DMAResume(USART_HandleTypeDef *husart)
000000  4601              MOV      r1,r0
;;;1204   {
;;;1205     /* Process Locked */
;;;1206     __HAL_LOCK(husart);
000002  bf00              NOP      
000004  6c08              LDR      r0,[r1,#0x40]
000006  2801              CMP      r0,#1
000008  d101              BNE      |L5.14|
00000a  2002              MOVS     r0,#2
                  |L5.12|
;;;1207   
;;;1208     if(husart->State == HAL_USART_STATE_BUSY_TX)
;;;1209     {
;;;1210       /* Enable the USART DMA Tx request */
;;;1211       SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1212     }
;;;1213     else if( (husart->State == HAL_USART_STATE_BUSY_RX) ||
;;;1214              (husart->State == HAL_USART_STATE_BUSY_TX_RX) )
;;;1215     {
;;;1216       /* Clear the Overrun flag before resuming the Rx transfer*/
;;;1217       __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_OREF);
;;;1218   
;;;1219       /* Reenable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1220       SET_BIT(husart->Instance->CR1, USART_CR1_PEIE);
;;;1221       SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;1222   
;;;1223       /* Enable the USART DMA Rx request  before the DMA Tx request */
;;;1224       SET_BIT(husart->Instance->CR3, USART_CR3_DMAR);
;;;1225   
;;;1226       /* Enable the USART DMA Tx request */
;;;1227       SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1228     }
;;;1229   
;;;1230     /* Process Unlocked */
;;;1231     __HAL_UNLOCK(husart);
;;;1232   
;;;1233     return HAL_OK;
;;;1234   }
00000c  4770              BX       lr
                  |L5.14|
00000e  2001              MOVS     r0,#1                 ;1206
000010  6408              STR      r0,[r1,#0x40]         ;1206
000012  bf00              NOP                            ;1206
000014  6c48              LDR      r0,[r1,#0x44]         ;1208
000016  2812              CMP      r0,#0x12              ;1208
000018  d106              BNE      |L5.40|
00001a  6808              LDR      r0,[r1,#0]            ;1211
00001c  6880              LDR      r0,[r0,#8]            ;1211
00001e  2280              MOVS     r2,#0x80              ;1211
000020  4310              ORRS     r0,r0,r2              ;1211
000022  680a              LDR      r2,[r1,#0]            ;1211
000024  6090              STR      r0,[r2,#8]            ;1211
000026  e021              B        |L5.108|
                  |L5.40|
000028  6c48              LDR      r0,[r1,#0x44]         ;1213
00002a  2822              CMP      r0,#0x22              ;1213
00002c  d002              BEQ      |L5.52|
00002e  6c48              LDR      r0,[r1,#0x44]         ;1214
000030  2832              CMP      r0,#0x32              ;1214
000032  d11b              BNE      |L5.108|
                  |L5.52|
000034  2008              MOVS     r0,#8                 ;1217
000036  680a              LDR      r2,[r1,#0]            ;1217
000038  6210              STR      r0,[r2,#0x20]         ;1217
00003a  6808              LDR      r0,[r1,#0]            ;1220
00003c  6800              LDR      r0,[r0,#0]            ;1220
00003e  22ff              MOVS     r2,#0xff              ;1220
000040  3201              ADDS     r2,#1                 ;1220
000042  4310              ORRS     r0,r0,r2              ;1220
000044  680a              LDR      r2,[r1,#0]            ;1220
000046  6010              STR      r0,[r2,#0]            ;1220
000048  6808              LDR      r0,[r1,#0]            ;1221
00004a  6880              LDR      r0,[r0,#8]            ;1221
00004c  2201              MOVS     r2,#1                 ;1221
00004e  4310              ORRS     r0,r0,r2              ;1221
000050  680a              LDR      r2,[r1,#0]            ;1221
000052  6090              STR      r0,[r2,#8]            ;1221
000054  6808              LDR      r0,[r1,#0]            ;1224
000056  6880              LDR      r0,[r0,#8]            ;1224
000058  2240              MOVS     r2,#0x40              ;1224
00005a  4310              ORRS     r0,r0,r2              ;1224
00005c  680a              LDR      r2,[r1,#0]            ;1224
00005e  6090              STR      r0,[r2,#8]            ;1224
000060  6808              LDR      r0,[r1,#0]            ;1227
000062  6880              LDR      r0,[r0,#8]            ;1227
000064  2280              MOVS     r2,#0x80              ;1227
000066  4310              ORRS     r0,r0,r2              ;1227
000068  680a              LDR      r2,[r1,#0]            ;1227
00006a  6090              STR      r0,[r2,#8]            ;1227
                  |L5.108|
00006c  bf00              NOP                            ;1231
00006e  2000              MOVS     r0,#0                 ;1231
000070  6408              STR      r0,[r1,#0x40]         ;1231
000072  bf00              NOP                            ;1231
000074  bf00              NOP                            ;1233
000076  e7c9              B        |L5.12|
;;;1235   
                          ENDP


                          AREA ||i.HAL_USART_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_USART_DMAStop PROC
;;;1240     */
;;;1241   HAL_StatusTypeDef HAL_USART_DMAStop(USART_HandleTypeDef *husart)
000000  b510              PUSH     {r4,lr}
;;;1242   {
000002  4604              MOV      r4,r0
;;;1243     /* The Lock is not implemented on this API to allow the user application
;;;1244        to call the HAL USART API under callbacks HAL_USART_TxCpltCallback() / HAL_USART_RxCpltCallback() /
;;;1245        HAL_USART_TxHalfCpltCallback / HAL_USART_RxHalfCpltCallback: 
;;;1246        indeed, when HAL_DMA_Abort() API is called, the DMA TX/RX Transfer or Half Transfer complete  
;;;1247        interrupt is generated if the DMA transfer interruption occurs at the middle or at the end of 
;;;1248        the stream and the corresponding call back is executed. */
;;;1249   
;;;1250     /* Disable the USART Tx/Rx DMA requests */
;;;1251     CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
000004  6820              LDR      r0,[r4,#0]
000006  6880              LDR      r0,[r0,#8]
000008  2180              MOVS     r1,#0x80
00000a  4388              BICS     r0,r0,r1
00000c  6821              LDR      r1,[r4,#0]
00000e  6088              STR      r0,[r1,#8]
;;;1252     CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
000010  6820              LDR      r0,[r4,#0]
000012  6880              LDR      r0,[r0,#8]
000014  2140              MOVS     r1,#0x40
000016  4388              BICS     r0,r0,r1
000018  6821              LDR      r1,[r4,#0]
00001a  6088              STR      r0,[r1,#8]
;;;1253   
;;;1254     /* Abort the USART DMA tx channel */
;;;1255     if(husart->hdmatx != NULL)
00001c  6ba0              LDR      r0,[r4,#0x38]
00001e  2800              CMP      r0,#0
000020  d002              BEQ      |L6.40|
;;;1256     {
;;;1257       HAL_DMA_Abort(husart->hdmatx);
000022  6ba0              LDR      r0,[r4,#0x38]
000024  f7fffffe          BL       HAL_DMA_Abort
                  |L6.40|
;;;1258     }
;;;1259     /* Abort the USART DMA rx channel */
;;;1260     if(husart->hdmarx != NULL)
000028  6be0              LDR      r0,[r4,#0x3c]
00002a  2800              CMP      r0,#0
00002c  d002              BEQ      |L6.52|
;;;1261     {
;;;1262       HAL_DMA_Abort(husart->hdmarx);
00002e  6be0              LDR      r0,[r4,#0x3c]
000030  f7fffffe          BL       HAL_DMA_Abort
                  |L6.52|
;;;1263     }
;;;1264   
;;;1265     USART_EndTransfer(husart);
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       USART_EndTransfer
;;;1266     husart->State = HAL_USART_STATE_READY;
00003a  2001              MOVS     r0,#1
00003c  6460              STR      r0,[r4,#0x44]
;;;1267   
;;;1268     return HAL_OK;
00003e  2000              MOVS     r0,#0
;;;1269   }
000040  bd10              POP      {r4,pc}
;;;1270   
                          ENDP


                          AREA ||i.HAL_USART_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_USART_DeInit PROC
;;;249      */
;;;250    HAL_StatusTypeDef HAL_USART_DeInit(USART_HandleTypeDef *husart)
000000  b510              PUSH     {r4,lr}
;;;251    {
000002  4604              MOV      r4,r0
;;;252      /* Check the USART handle allocation */
;;;253      if(husart == NULL)
000004  2c00              CMP      r4,#0
000006  d101              BNE      |L7.12|
;;;254      {
;;;255        return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L7.10|
;;;256      }
;;;257    
;;;258      /* Check the parameters */
;;;259      assert_param(IS_USART_INSTANCE(husart->Instance));
;;;260    
;;;261      husart->State = HAL_USART_STATE_BUSY;
;;;262    
;;;263      husart->Instance->CR1 = 0x0U;
;;;264      husart->Instance->CR2 = 0x0U;
;;;265      husart->Instance->CR3 = 0x0U;
;;;266    
;;;267      /* DeInit the low level hardware */
;;;268      HAL_USART_MspDeInit(husart);
;;;269    
;;;270      husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;271      husart->State = HAL_USART_STATE_RESET;
;;;272    
;;;273      /* Process Unlock */
;;;274      __HAL_UNLOCK(husart);
;;;275    
;;;276      return HAL_OK;
;;;277    }
00000a  bd10              POP      {r4,pc}
                  |L7.12|
00000c  2002              MOVS     r0,#2                 ;261
00000e  6460              STR      r0,[r4,#0x44]         ;261
000010  2000              MOVS     r0,#0                 ;263
000012  6821              LDR      r1,[r4,#0]            ;263
000014  6008              STR      r0,[r1,#0]            ;263
000016  6821              LDR      r1,[r4,#0]            ;264
000018  6048              STR      r0,[r1,#4]            ;264
00001a  6821              LDR      r1,[r4,#0]            ;265
00001c  6088              STR      r0,[r1,#8]            ;265
00001e  4620              MOV      r0,r4                 ;268
000020  f7fffffe          BL       HAL_USART_MspDeInit
000024  2000              MOVS     r0,#0                 ;270
000026  64a0              STR      r0,[r4,#0x48]         ;270
000028  6460              STR      r0,[r4,#0x44]         ;271
00002a  bf00              NOP                            ;274
00002c  6420              STR      r0,[r4,#0x40]         ;274
00002e  bf00              NOP                            ;274
000030  bf00              NOP                            ;276
000032  e7ea              B        |L7.10|
;;;278    
                          ENDP


                          AREA ||i.HAL_USART_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_ErrorCallback PROC
;;;1714     */
;;;1715   __weak void HAL_USART_ErrorCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1716   {
;;;1717     /* Prevent unused argument(s) compilation warning */
;;;1718     UNUSED(husart);
;;;1719   
;;;1720     /* NOTE : This function should not be modified, when the callback is needed,
;;;1721               the HAL_USART_ErrorCallback can be implemented in the user file.
;;;1722      */
;;;1723   }
;;;1724   
                          ENDP


                          AREA ||i.HAL_USART_GetError||, CODE, READONLY, ALIGN=1

                  HAL_USART_GetError PROC
;;;1777     */
;;;1778   uint32_t HAL_USART_GetError(USART_HandleTypeDef *husart)
000000  4601              MOV      r1,r0
;;;1779   {
;;;1780     return husart->ErrorCode;
000002  6c88              LDR      r0,[r1,#0x48]
;;;1781   }
000004  4770              BX       lr
;;;1782   
                          ENDP


                          AREA ||i.HAL_USART_GetState||, CODE, READONLY, ALIGN=1

                  HAL_USART_GetState PROC
;;;1766     */
;;;1767   HAL_USART_StateTypeDef HAL_USART_GetState(USART_HandleTypeDef *husart)
000000  4601              MOV      r1,r0
;;;1768   {
;;;1769     return husart->State;
000002  6c48              LDR      r0,[r1,#0x44]
;;;1770   }
000004  4770              BX       lr
;;;1771   
                          ENDP


                          AREA ||i.HAL_USART_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_USART_IRQHandler PROC
;;;1465     */
;;;1466   void HAL_USART_IRQHandler(USART_HandleTypeDef *husart)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1467   {
000002  4604              MOV      r4,r0
;;;1468     uint32_t isrflags   = READ_REG(husart->Instance->ISR);
000004  6820              LDR      r0,[r4,#0]
000006  69c5              LDR      r5,[r0,#0x1c]
;;;1469     uint32_t cr1its     = READ_REG(husart->Instance->CR1);
000008  6820              LDR      r0,[r4,#0]
00000a  6806              LDR      r6,[r0,#0]
;;;1470     uint32_t cr3its;
;;;1471     uint32_t errorflags;
;;;1472   
;;;1473     /* If no error occurs */
;;;1474     errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE));
00000c  0728              LSLS     r0,r5,#28
00000e  0f00              LSRS     r0,r0,#28
000010  9000              STR      r0,[sp,#0]
;;;1475     if (errorflags == RESET)
000012  9800              LDR      r0,[sp,#0]
000014  2800              CMP      r0,#0
000016  d112              BNE      |L11.62|
;;;1476     {
;;;1477       /* USART in mode Receiver ---------------------------------------------------*/
;;;1478       if(((isrflags & USART_ISR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
000018  2020              MOVS     r0,#0x20
00001a  4028              ANDS     r0,r0,r5
00001c  2800              CMP      r0,#0
00001e  d00e              BEQ      |L11.62|
000020  2020              MOVS     r0,#0x20
000022  4030              ANDS     r0,r0,r6
000024  2800              CMP      r0,#0
000026  d00a              BEQ      |L11.62|
;;;1479       {
;;;1480         if(husart->State == HAL_USART_STATE_BUSY_RX)
000028  6c60              LDR      r0,[r4,#0x44]
00002a  2822              CMP      r0,#0x22
00002c  d103              BNE      |L11.54|
;;;1481         {
;;;1482           USART_Receive_IT(husart);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       USART_Receive_IT
000034  e002              B        |L11.60|
                  |L11.54|
;;;1483         }
;;;1484         else
;;;1485         {
;;;1486           USART_TransmitReceive_IT(husart);
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       USART_TransmitReceive_IT
                  |L11.60|
;;;1487         }
;;;1488         return;
;;;1489       }
;;;1490     }
;;;1491   
;;;1492     /* If some errors occur */
;;;1493     cr3its = READ_REG(husart->Instance->CR3);
;;;1494     if(   (errorflags != RESET)
;;;1495        && (   ((cr3its & USART_CR3_EIE) != RESET)
;;;1496            || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)) )
;;;1497     {
;;;1498       /* USART parity error interrupt occurred -------------------------------------*/
;;;1499       if(((isrflags & USART_ISR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
;;;1500       {
;;;1501         __HAL_USART_CLEAR_IT(husart, USART_CLEAR_PEF);
;;;1502   
;;;1503         husart->ErrorCode |= HAL_USART_ERROR_PE;
;;;1504       }
;;;1505   
;;;1506       /* USART frame error interrupt occurred --------------------------------------*/
;;;1507       if(((isrflags & USART_ISR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
;;;1508       {
;;;1509         __HAL_USART_CLEAR_IT(husart, USART_CLEAR_FEF);
;;;1510   
;;;1511         husart->ErrorCode |= HAL_USART_ERROR_FE;
;;;1512       }
;;;1513   
;;;1514       /* USART noise error interrupt occurred --------------------------------------*/
;;;1515       if(((isrflags & USART_ISR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
;;;1516       {
;;;1517         __HAL_USART_CLEAR_IT(husart, USART_CLEAR_NEF);
;;;1518   
;;;1519         husart->ErrorCode |= HAL_USART_ERROR_NE;
;;;1520       }
;;;1521   
;;;1522       /* USART Over-Run interrupt occurred -----------------------------------------*/
;;;1523       if(((isrflags & USART_ISR_ORE) != RESET) &&
;;;1524          (((cr1its & USART_CR1_RXNEIE) != RESET) || ((cr3its & USART_CR3_EIE) != RESET)))
;;;1525       {
;;;1526         __HAL_USART_CLEAR_IT(husart, USART_CLEAR_OREF);
;;;1527   
;;;1528         husart->ErrorCode |= HAL_USART_ERROR_ORE;
;;;1529       }
;;;1530   
;;;1531       /* Call USART Error Call back function if need be --------------------------*/
;;;1532       if(husart->ErrorCode != HAL_USART_ERROR_NONE)
;;;1533       {
;;;1534         /* USART in mode Receiver ---------------------------------------------------*/
;;;1535         if(((isrflags & USART_ISR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
;;;1536         {
;;;1537           if(husart->State == HAL_USART_STATE_BUSY_RX)
;;;1538           {
;;;1539             USART_Receive_IT(husart);
;;;1540           }
;;;1541           else
;;;1542           {
;;;1543             USART_TransmitReceive_IT(husart);
;;;1544           }
;;;1545         }
;;;1546   
;;;1547         /* If Overrun error occurs, or if any error occurs in DMA mode reception,
;;;1548            consider error as blocking */
;;;1549         if (((husart->ErrorCode & HAL_USART_ERROR_ORE) != RESET) ||
;;;1550             (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR)))
;;;1551         {  
;;;1552           /* Blocking error : transfer is aborted
;;;1553              Set the USART state ready to be able to start again the process,
;;;1554              Disable Interrupts, and disable DMA requests, if ongoing */
;;;1555           USART_EndTransfer(husart);
;;;1556   
;;;1557           /* Disable the USART DMA Rx request if enabled */
;;;1558           if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
;;;1559           {
;;;1560             CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR | USART_CR3_DMAR);
;;;1561   
;;;1562             /* Abort the USART DMA Tx channel */
;;;1563             if(husart->hdmatx != NULL)
;;;1564             {
;;;1565               /* Set the USART Tx DMA Abort callback to NULL : no callback
;;;1566                  executed at end of DMA abort procedure */
;;;1567               husart->hdmatx->XferAbortCallback = NULL;
;;;1568               
;;;1569               /* Abort DMA TX */
;;;1570               HAL_DMA_Abort_IT(husart->hdmatx);
;;;1571             }
;;;1572   
;;;1573             /* Abort the USART DMA Rx channel */
;;;1574             if(husart->hdmarx != NULL)
;;;1575             {
;;;1576               /* Set the USART Rx DMA Abort callback : 
;;;1577                  will lead to call HAL_USART_ErrorCallback() at end of DMA abort procedure */
;;;1578               husart->hdmarx->XferAbortCallback = USART_DMAAbortOnError;
;;;1579   
;;;1580               /* Abort DMA RX */
;;;1581               if(HAL_DMA_Abort_IT(husart->hdmarx) != HAL_OK)
;;;1582               {
;;;1583                 /* Call Directly husart->hdmarx->XferAbortCallback function in case of error */
;;;1584                 husart->hdmarx->XferAbortCallback(husart->hdmarx);
;;;1585               }
;;;1586             }
;;;1587             else
;;;1588             {
;;;1589               /* Call user error callback */
;;;1590               HAL_USART_ErrorCallback(husart);
;;;1591             }
;;;1592           }
;;;1593           else
;;;1594           {
;;;1595             /* Call user error callback */
;;;1596             HAL_USART_ErrorCallback(husart);
;;;1597           }
;;;1598         }
;;;1599         else
;;;1600         {
;;;1601           /* Non Blocking error : transfer could go on. 
;;;1602              Error is notified to user through user error callback */
;;;1603           HAL_USART_ErrorCallback(husart);
;;;1604           husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;1605         }
;;;1606       }
;;;1607       return;
;;;1608   
;;;1609     } /* End if some error occurs */
;;;1610   
;;;1611   
;;;1612     /* USART in mode Transmitter ------------------------------------------------*/
;;;1613     if(((isrflags & USART_ISR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
;;;1614     {
;;;1615       if(husart->State == HAL_USART_STATE_BUSY_TX)
;;;1616       {
;;;1617         USART_Transmit_IT(husart);
;;;1618       }
;;;1619       else
;;;1620       {
;;;1621         USART_TransmitReceive_IT(husart);
;;;1622       }
;;;1623       return;
;;;1624     }
;;;1625   
;;;1626     /* USART in mode Transmitter (transmission end) -----------------------------*/
;;;1627     if(((isrflags & USART_ISR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
;;;1628     {
;;;1629       USART_EndTransmit_IT(husart);
;;;1630       return;
;;;1631     }
;;;1632   
;;;1633   }
00003c  bdf8              POP      {r3-r7,pc}
                  |L11.62|
00003e  6820              LDR      r0,[r4,#0]            ;1493
000040  6887              LDR      r7,[r0,#8]            ;1493
000042  9800              LDR      r0,[sp,#0]            ;1494
000044  2800              CMP      r0,#0                 ;1494
                  |L11.70|
000046  d07d              BEQ      |L11.324|
000048  07f8              LSLS     r0,r7,#31             ;1495
00004a  0fc0              LSRS     r0,r0,#31             ;1495
00004c  2800              CMP      r0,#0                 ;1495
00004e  d104              BNE      |L11.90|
000050  20ff              MOVS     r0,#0xff              ;1496
000052  3021              ADDS     r0,r0,#0x21           ;1496
000054  4030              ANDS     r0,r0,r6              ;1496
000056  2800              CMP      r0,#0                 ;1496
000058  d0f5              BEQ      |L11.70|
                  |L11.90|
00005a  07e8              LSLS     r0,r5,#31             ;1499
00005c  0fc0              LSRS     r0,r0,#31             ;1499
00005e  2800              CMP      r0,#0                 ;1499
000060  d00b              BEQ      |L11.122|
000062  20ff              MOVS     r0,#0xff              ;1499
000064  3001              ADDS     r0,#1                 ;1499
000066  4030              ANDS     r0,r0,r6              ;1499
000068  2800              CMP      r0,#0                 ;1499
00006a  d006              BEQ      |L11.122|
00006c  2001              MOVS     r0,#1                 ;1501
00006e  6821              LDR      r1,[r4,#0]            ;1501
000070  6208              STR      r0,[r1,#0x20]         ;1501
000072  6ca0              LDR      r0,[r4,#0x48]         ;1503
000074  2101              MOVS     r1,#1                 ;1503
000076  4308              ORRS     r0,r0,r1              ;1503
000078  64a0              STR      r0,[r4,#0x48]         ;1503
                  |L11.122|
00007a  2002              MOVS     r0,#2                 ;1507
00007c  4028              ANDS     r0,r0,r5              ;1507
00007e  2800              CMP      r0,#0                 ;1507
000080  d00a              BEQ      |L11.152|
000082  07f8              LSLS     r0,r7,#31             ;1507
000084  0fc0              LSRS     r0,r0,#31             ;1507
000086  2800              CMP      r0,#0                 ;1507
000088  d006              BEQ      |L11.152|
00008a  2002              MOVS     r0,#2                 ;1509
00008c  6821              LDR      r1,[r4,#0]            ;1509
00008e  6208              STR      r0,[r1,#0x20]         ;1509
000090  6ca0              LDR      r0,[r4,#0x48]         ;1511
000092  2104              MOVS     r1,#4                 ;1511
000094  4308              ORRS     r0,r0,r1              ;1511
000096  64a0              STR      r0,[r4,#0x48]         ;1511
                  |L11.152|
000098  2004              MOVS     r0,#4                 ;1515
00009a  4028              ANDS     r0,r0,r5              ;1515
00009c  2800              CMP      r0,#0                 ;1515
00009e  d00a              BEQ      |L11.182|
0000a0  07f8              LSLS     r0,r7,#31             ;1515
0000a2  0fc0              LSRS     r0,r0,#31             ;1515
0000a4  2800              CMP      r0,#0                 ;1515
0000a6  d006              BEQ      |L11.182|
0000a8  2004              MOVS     r0,#4                 ;1517
0000aa  6821              LDR      r1,[r4,#0]            ;1517
0000ac  6208              STR      r0,[r1,#0x20]         ;1517
0000ae  6ca0              LDR      r0,[r4,#0x48]         ;1519
0000b0  2102              MOVS     r1,#2                 ;1519
0000b2  4308              ORRS     r0,r0,r1              ;1519
0000b4  64a0              STR      r0,[r4,#0x48]         ;1519
                  |L11.182|
0000b6  2008              MOVS     r0,#8                 ;1523
0000b8  4028              ANDS     r0,r0,r5              ;1523
0000ba  2800              CMP      r0,#0                 ;1523
0000bc  d00e              BEQ      |L11.220|
0000be  2020              MOVS     r0,#0x20              ;1524
0000c0  4030              ANDS     r0,r0,r6              ;1524
0000c2  2800              CMP      r0,#0                 ;1524
0000c4  d103              BNE      |L11.206|
0000c6  07f8              LSLS     r0,r7,#31             ;1524
0000c8  0fc0              LSRS     r0,r0,#31             ;1524
0000ca  2800              CMP      r0,#0                 ;1524
0000cc  d006              BEQ      |L11.220|
                  |L11.206|
0000ce  2008              MOVS     r0,#8                 ;1526
0000d0  6821              LDR      r1,[r4,#0]            ;1526
0000d2  6208              STR      r0,[r1,#0x20]         ;1526
0000d4  6ca0              LDR      r0,[r4,#0x48]         ;1528
0000d6  2108              MOVS     r1,#8                 ;1528
0000d8  4308              ORRS     r0,r0,r1              ;1528
0000da  64a0              STR      r0,[r4,#0x48]         ;1528
                  |L11.220|
0000dc  6ca0              LDR      r0,[r4,#0x48]         ;1532
0000de  2800              CMP      r0,#0                 ;1532
0000e0  d051              BEQ      |L11.390|
0000e2  2020              MOVS     r0,#0x20              ;1535
0000e4  4028              ANDS     r0,r0,r5              ;1535
0000e6  2800              CMP      r0,#0                 ;1535
0000e8  d00d              BEQ      |L11.262|
0000ea  2020              MOVS     r0,#0x20              ;1535
0000ec  4030              ANDS     r0,r0,r6              ;1535
0000ee  2800              CMP      r0,#0                 ;1535
0000f0  d009              BEQ      |L11.262|
0000f2  6c60              LDR      r0,[r4,#0x44]         ;1537
0000f4  2822              CMP      r0,#0x22              ;1537
0000f6  d103              BNE      |L11.256|
0000f8  4620              MOV      r0,r4                 ;1539
0000fa  f7fffffe          BL       USART_Receive_IT
0000fe  e002              B        |L11.262|
                  |L11.256|
000100  4620              MOV      r0,r4                 ;1543
000102  f7fffffe          BL       USART_TransmitReceive_IT
                  |L11.262|
000106  6ca0              LDR      r0,[r4,#0x48]         ;1549
000108  2108              MOVS     r1,#8                 ;1549
00010a  4008              ANDS     r0,r0,r1              ;1549
00010c  2800              CMP      r0,#0                 ;1549
00010e  d105              BNE      |L11.284|
000110  6820              LDR      r0,[r4,#0]            ;1550
000112  6880              LDR      r0,[r0,#8]            ;1550
000114  2140              MOVS     r1,#0x40              ;1550
000116  4008              ANDS     r0,r0,r1              ;1550
000118  2800              CMP      r0,#0                 ;1550
00011a  d02f              BEQ      |L11.380|
                  |L11.284|
00011c  4620              MOV      r0,r4                 ;1555
00011e  f7fffffe          BL       USART_EndTransfer
000122  6820              LDR      r0,[r4,#0]            ;1558
000124  6880              LDR      r0,[r0,#8]            ;1558
000126  2140              MOVS     r1,#0x40              ;1558
000128  4008              ANDS     r0,r0,r1              ;1558
00012a  2800              CMP      r0,#0                 ;1558
00012c  d022              BEQ      |L11.372|
00012e  6820              LDR      r0,[r4,#0]            ;1560
000130  6880              LDR      r0,[r0,#8]            ;1560
000132  4388              BICS     r0,r0,r1              ;1560
000134  6821              LDR      r1,[r4,#0]            ;1560
000136  6088              STR      r0,[r1,#8]            ;1560
000138  6ba0              LDR      r0,[r4,#0x38]         ;1563
00013a  2800              CMP      r0,#0                 ;1563
00013c  d007              BEQ      |L11.334|
00013e  2000              MOVS     r0,#0                 ;1567
000140  6ba1              LDR      r1,[r4,#0x38]         ;1567
000142  e000              B        |L11.326|
                  |L11.324|
000144  e020              B        |L11.392|
                  |L11.326|
000146  63c8              STR      r0,[r1,#0x3c]         ;1567
000148  6ba0              LDR      r0,[r4,#0x38]         ;1570
00014a  f7fffffe          BL       HAL_DMA_Abort_IT
                  |L11.334|
00014e  6be0              LDR      r0,[r4,#0x3c]         ;1574
000150  2800              CMP      r0,#0                 ;1574
000152  d00b              BEQ      |L11.364|
000154  481d              LDR      r0,|L11.460|
000156  6be1              LDR      r1,[r4,#0x3c]         ;1578
000158  63c8              STR      r0,[r1,#0x3c]         ;1578
00015a  6be0              LDR      r0,[r4,#0x3c]         ;1581
00015c  f7fffffe          BL       HAL_DMA_Abort_IT
000160  2800              CMP      r0,#0                 ;1581
000162  d010              BEQ      |L11.390|
000164  6be0              LDR      r0,[r4,#0x3c]         ;1584
000166  6bc1              LDR      r1,[r0,#0x3c]         ;1584
000168  4788              BLX      r1                    ;1584
00016a  e00c              B        |L11.390|
                  |L11.364|
00016c  4620              MOV      r0,r4                 ;1590
00016e  f7fffffe          BL       HAL_USART_ErrorCallback
000172  e008              B        |L11.390|
                  |L11.372|
000174  4620              MOV      r0,r4                 ;1596
000176  f7fffffe          BL       HAL_USART_ErrorCallback
00017a  e004              B        |L11.390|
                  |L11.380|
00017c  4620              MOV      r0,r4                 ;1603
00017e  f7fffffe          BL       HAL_USART_ErrorCallback
000182  2000              MOVS     r0,#0                 ;1604
000184  64a0              STR      r0,[r4,#0x48]         ;1604
                  |L11.390|
000186  e759              B        |L11.60|
                  |L11.392|
000188  2080              MOVS     r0,#0x80              ;1613
00018a  4028              ANDS     r0,r0,r5              ;1613
00018c  2800              CMP      r0,#0                 ;1613
00018e  d00e              BEQ      |L11.430|
000190  2080              MOVS     r0,#0x80              ;1613
000192  4030              ANDS     r0,r0,r6              ;1613
000194  2800              CMP      r0,#0                 ;1613
000196  d00a              BEQ      |L11.430|
000198  6c60              LDR      r0,[r4,#0x44]         ;1615
00019a  2812              CMP      r0,#0x12              ;1615
00019c  d103              BNE      |L11.422|
00019e  4620              MOV      r0,r4                 ;1617
0001a0  f7fffffe          BL       USART_Transmit_IT
0001a4  e002              B        |L11.428|
                  |L11.422|
0001a6  4620              MOV      r0,r4                 ;1621
0001a8  f7fffffe          BL       USART_TransmitReceive_IT
                  |L11.428|
0001ac  e746              B        |L11.60|
                  |L11.430|
0001ae  2040              MOVS     r0,#0x40              ;1627
0001b0  4028              ANDS     r0,r0,r5              ;1627
0001b2  2800              CMP      r0,#0                 ;1627
0001b4  d007              BEQ      |L11.454|
0001b6  2040              MOVS     r0,#0x40              ;1627
0001b8  4030              ANDS     r0,r0,r6              ;1627
0001ba  2800              CMP      r0,#0                 ;1627
0001bc  d003              BEQ      |L11.454|
0001be  4620              MOV      r0,r4                 ;1629
0001c0  f7fffffe          BL       USART_EndTransmit_IT
0001c4  e73a              B        |L11.60|
                  |L11.454|
0001c6  bf00              NOP      
0001c8  e738              B        |L11.60|
;;;1634   
                          ENDP

0001ca  0000              DCW      0x0000
                  |L11.460|
                          DCD      USART_DMAAbortOnError

                          AREA ||i.HAL_USART_Init||, CODE, READONLY, ALIGN=1

                  HAL_USART_Init PROC
;;;200      */
;;;201    HAL_StatusTypeDef HAL_USART_Init(USART_HandleTypeDef *husart)
000000  b510              PUSH     {r4,lr}
;;;202    {
000002  4604              MOV      r4,r0
;;;203      /* Check the USART handle allocation */
;;;204      if(husart == NULL)
000004  2c00              CMP      r4,#0
000006  d101              BNE      |L12.12|
;;;205      {
;;;206        return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L12.10|
;;;207      }
;;;208    
;;;209      /* Check the parameters */
;;;210      assert_param(IS_USART_INSTANCE(husart->Instance));
;;;211    
;;;212      if(husart->State == HAL_USART_STATE_RESET)
;;;213      {
;;;214        /* Allocate lock resource and initialize it */
;;;215        husart->Lock = HAL_UNLOCKED;
;;;216    
;;;217        /* Init the low level hardware : GPIO, CLOCK */
;;;218        HAL_USART_MspInit(husart);
;;;219      }
;;;220    
;;;221      husart->State = HAL_USART_STATE_BUSY;
;;;222    
;;;223      /* Disable the Peripheral */
;;;224      __HAL_USART_DISABLE(husart);
;;;225    
;;;226      /* Set the Usart Communication parameters */
;;;227      if (USART_SetConfig(husart) == HAL_ERROR)
;;;228      {
;;;229        return HAL_ERROR;
;;;230      }
;;;231    
;;;232      /* In Synchronous mode, the following bits must be kept cleared:
;;;233      - LINEN bit in the USART_CR2 register
;;;234      - HDSEL, SCEN and IREN bits in the USART_CR3 register.*/
;;;235      husart->Instance->CR2 &= ~USART_CR2_LINEN;
;;;236      husart->Instance->CR3 &= ~(USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN);
;;;237    
;;;238      /* Enable the Peripheral */
;;;239      __HAL_USART_ENABLE(husart);
;;;240    
;;;241      /* TEACK and/or REACK to check before moving husart->State to Ready */
;;;242      return (USART_CheckIdleState(husart));
;;;243    }
00000a  bd10              POP      {r4,pc}
                  |L12.12|
00000c  6c60              LDR      r0,[r4,#0x44]         ;212
00000e  2800              CMP      r0,#0                 ;212
000010  d103              BNE      |L12.26|
000012  6420              STR      r0,[r4,#0x40]         ;215
000014  4620              MOV      r0,r4                 ;218
000016  f7fffffe          BL       HAL_USART_MspInit
                  |L12.26|
00001a  2002              MOVS     r0,#2                 ;221
00001c  6460              STR      r0,[r4,#0x44]         ;221
00001e  6820              LDR      r0,[r4,#0]            ;224
000020  6800              LDR      r0,[r0,#0]            ;224
000022  0840              LSRS     r0,r0,#1              ;224
000024  0040              LSLS     r0,r0,#1              ;224
000026  6821              LDR      r1,[r4,#0]            ;224
000028  6008              STR      r0,[r1,#0]            ;224
00002a  4620              MOV      r0,r4                 ;227
00002c  f7fffffe          BL       USART_SetConfig
000030  2801              CMP      r0,#1                 ;227
000032  d100              BNE      |L12.54|
000034  e7e9              B        |L12.10|
                  |L12.54|
000036  6820              LDR      r0,[r4,#0]            ;235
000038  6840              LDR      r0,[r0,#4]            ;235
00003a  2101              MOVS     r1,#1                 ;235
00003c  0389              LSLS     r1,r1,#14             ;235
00003e  4388              BICS     r0,r0,r1              ;235
000040  6821              LDR      r1,[r4,#0]            ;235
000042  6048              STR      r0,[r1,#4]            ;235
000044  6820              LDR      r0,[r4,#0]            ;236
000046  6880              LDR      r0,[r0,#8]            ;236
000048  212a              MOVS     r1,#0x2a              ;236
00004a  4388              BICS     r0,r0,r1              ;236
00004c  6821              LDR      r1,[r4,#0]            ;236
00004e  6088              STR      r0,[r1,#8]            ;236
000050  6820              LDR      r0,[r4,#0]            ;239
000052  6800              LDR      r0,[r0,#0]            ;239
000054  2101              MOVS     r1,#1                 ;239
000056  4308              ORRS     r0,r0,r1              ;239
000058  6821              LDR      r1,[r4,#0]            ;239
00005a  6008              STR      r0,[r1,#0]            ;239
00005c  4620              MOV      r0,r4                 ;242
00005e  f7fffffe          BL       USART_CheckIdleState
000062  e7d2              B        |L12.10|
;;;244    
                          ENDP


                          AREA ||i.HAL_USART_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_USART_MspDeInit PROC
;;;298      */
;;;299    __weak void HAL_USART_MspDeInit(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;300    {
;;;301      /* Prevent unused argument(s) compilation warning */
;;;302      UNUSED(husart);
;;;303    
;;;304      /* NOTE : This function should not be modified, when the callback is needed,
;;;305                the HAL_USART_MspDeInit can be implemented in the user file
;;;306       */
;;;307    }
;;;308    
                          ENDP


                          AREA ||i.HAL_USART_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_USART_MspInit PROC
;;;283      */
;;;284    __weak void HAL_USART_MspInit(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;285    {
;;;286      /* Prevent unused argument(s) compilation warning */
;;;287      UNUSED(husart);
;;;288    
;;;289      /* NOTE : This function should not be modified, when the callback is needed,
;;;290                the HAL_USART_MspInit can be implemented in the user file
;;;291       */
;;;292    }
;;;293    
                          ENDP


                          AREA ||i.HAL_USART_Receive||, CODE, READONLY, ALIGN=2

                  HAL_USART_Receive PROC
;;;486      */
;;;487    HAL_StatusTypeDef HAL_USART_Receive(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
000000  b5f0              PUSH     {r4-r7,lr}
;;;488    {
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;489      uint16_t* tmp;
;;;490      uint16_t uhMask;
;;;491      uint32_t tickstart = 0;
00000c  2000              MOVS     r0,#0
00000e  9001              STR      r0,[sp,#4]
;;;492    
;;;493      if(husart->State == HAL_USART_STATE_READY)
000010  6c60              LDR      r0,[r4,#0x44]
000012  2801              CMP      r0,#1
000014  d17e              BNE      |L15.276|
;;;494      {
;;;495        if((pRxData == NULL) || (Size == 0U))
000016  2d00              CMP      r5,#0
000018  d001              BEQ      |L15.30|
00001a  2e00              CMP      r6,#0
00001c  d102              BNE      |L15.36|
                  |L15.30|
;;;496        {
;;;497          return  HAL_ERROR;
00001e  2001              MOVS     r0,#1
                  |L15.32|
;;;498        }
;;;499    
;;;500        /* In case of 9bits/No Parity transfer, pTxData buffer provided as input paramter 
;;;501           should be aligned on a u16 frontier, as data to be filled into TDR will be 
;;;502           handled through a u16 cast. */
;;;503        if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;504        {
;;;505          if((((uint32_t)pRxData)&1) != 0)
;;;506          {
;;;507            return  HAL_ERROR;
;;;508          }
;;;509        }
;;;510    
;;;511        /* Process Locked */
;;;512        __HAL_LOCK(husart);
;;;513    
;;;514        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;515        husart->State = HAL_USART_STATE_BUSY_RX;
;;;516    
;;;517        /* Init tickstart for timeout managment*/
;;;518        tickstart = HAL_GetTick();
;;;519    
;;;520        husart->RxXferSize = Size;
;;;521        husart->RxXferCount = Size;
;;;522    
;;;523        /* Computation of USART mask to apply to RDR register */
;;;524        USART_MASK_COMPUTATION(husart);
;;;525        uhMask = husart->Mask;
;;;526    
;;;527        /* as long as data have to be received */
;;;528        while(husart->RxXferCount > 0U)
;;;529        {
;;;530          husart->RxXferCount--;
;;;531    
;;;532          /* Wait until TXE flag is set to send dummy byte in order to generate the
;;;533          * clock for the slave to send data.
;;;534           * Whatever the frame length (7, 8 or 9-bit long), the same dummy value
;;;535           * can be written for all the cases. */
;;;536          if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;537          {
;;;538            return HAL_TIMEOUT;
;;;539          }
;;;540          husart->Instance->TDR = (USART_DUMMY_DATA & (uint16_t)0x0FFU);
;;;541    
;;;542          /* Wait for RXNE Flag */
;;;543          if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;544          {
;;;545            return HAL_TIMEOUT;
;;;546          }
;;;547    
;;;548          if((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;549          {
;;;550            tmp = (uint16_t*) pRxData ;
;;;551            *tmp = (uint16_t)(husart->Instance->RDR & uhMask);
;;;552            pRxData +=2U;
;;;553          }
;;;554          else
;;;555          {
;;;556            *pRxData++ = (uint8_t)(husart->Instance->RDR & (uint8_t)uhMask);
;;;557          }
;;;558        }
;;;559    
;;;560        /* At end of Rx process, restore husart->State to Ready */
;;;561        husart->State = HAL_USART_STATE_READY;
;;;562    
;;;563        /* Process Unlocked */
;;;564        __HAL_UNLOCK(husart);
;;;565    
;;;566        return HAL_OK;
;;;567      }
;;;568      else
;;;569      {
;;;570        return HAL_BUSY;
;;;571      }
;;;572    }
000020  b005              ADD      sp,sp,#0x14
000022  bdf0              POP      {r4-r7,pc}
                  |L15.36|
000024  2101              MOVS     r1,#1                 ;503
000026  0309              LSLS     r1,r1,#12             ;503
000028  68a0              LDR      r0,[r4,#8]            ;503
00002a  4288              CMP      r0,r1                 ;503
00002c  d108              BNE      |L15.64|
00002e  6920              LDR      r0,[r4,#0x10]         ;503
000030  2800              CMP      r0,#0                 ;503
000032  d105              BNE      |L15.64|
000034  07e8              LSLS     r0,r5,#31             ;505
000036  0fc0              LSRS     r0,r0,#31             ;505
000038  2800              CMP      r0,#0                 ;505
00003a  d001              BEQ      |L15.64|
00003c  2001              MOVS     r0,#1                 ;507
00003e  e7ef              B        |L15.32|
                  |L15.64|
000040  bf00              NOP                            ;512
000042  6c20              LDR      r0,[r4,#0x40]         ;512
000044  2801              CMP      r0,#1                 ;512
000046  d101              BNE      |L15.76|
000048  2002              MOVS     r0,#2                 ;512
00004a  e7e9              B        |L15.32|
                  |L15.76|
00004c  2001              MOVS     r0,#1                 ;512
00004e  6420              STR      r0,[r4,#0x40]         ;512
000050  bf00              NOP                            ;512
000052  2000              MOVS     r0,#0                 ;514
000054  64a0              STR      r0,[r4,#0x48]         ;514
000056  2022              MOVS     r0,#0x22              ;515
000058  6460              STR      r0,[r4,#0x44]         ;515
00005a  f7fffffe          BL       HAL_GetTick
00005e  9001              STR      r0,[sp,#4]            ;518
000060  8626              STRH     r6,[r4,#0x30]         ;520
000062  8666              STRH     r6,[r4,#0x32]         ;521
000064  bf00              NOP                            ;524
000066  2101              MOVS     r1,#1                 ;524
000068  0309              LSLS     r1,r1,#12             ;524
00006a  68a0              LDR      r0,[r4,#8]            ;524
00006c  4288              CMP      r0,r1                 ;524
00006e  d108              BNE      |L15.130|
000070  6920              LDR      r0,[r4,#0x10]         ;524
000072  2800              CMP      r0,#0                 ;524
000074  d102              BNE      |L15.124|
000076  4832              LDR      r0,|L15.320|
000078  86a0              STRH     r0,[r4,#0x34]         ;524
00007a  e01b              B        |L15.180|
                  |L15.124|
00007c  20ff              MOVS     r0,#0xff              ;524
00007e  86a0              STRH     r0,[r4,#0x34]         ;524
000080  e018              B        |L15.180|
                  |L15.130|
000082  68a0              LDR      r0,[r4,#8]            ;524
000084  2800              CMP      r0,#0                 ;524
000086  d108              BNE      |L15.154|
000088  6920              LDR      r0,[r4,#0x10]         ;524
00008a  2800              CMP      r0,#0                 ;524
00008c  d102              BNE      |L15.148|
00008e  20ff              MOVS     r0,#0xff              ;524
000090  86a0              STRH     r0,[r4,#0x34]         ;524
000092  e00f              B        |L15.180|
                  |L15.148|
000094  207f              MOVS     r0,#0x7f              ;524
000096  86a0              STRH     r0,[r4,#0x34]         ;524
000098  e00c              B        |L15.180|
                  |L15.154|
00009a  2101              MOVS     r1,#1                 ;524
00009c  0709              LSLS     r1,r1,#28             ;524
00009e  68a0              LDR      r0,[r4,#8]            ;524
0000a0  4288              CMP      r0,r1                 ;524
0000a2  d107              BNE      |L15.180|
0000a4  6920              LDR      r0,[r4,#0x10]         ;524
0000a6  2800              CMP      r0,#0                 ;524
0000a8  d102              BNE      |L15.176|
0000aa  207f              MOVS     r0,#0x7f              ;524
0000ac  86a0              STRH     r0,[r4,#0x34]         ;524
0000ae  e001              B        |L15.180|
                  |L15.176|
0000b0  203f              MOVS     r0,#0x3f              ;524
0000b2  86a0              STRH     r0,[r4,#0x34]         ;524
                  |L15.180|
0000b4  bf00              NOP                            ;524
0000b6  8ea0              LDRH     r0,[r4,#0x34]         ;525
0000b8  9002              STR      r0,[sp,#8]            ;525
0000ba  e035              B        |L15.296|
                  |L15.188|
0000bc  8e60              LDRH     r0,[r4,#0x32]         ;530
0000be  1e40              SUBS     r0,r0,#1              ;530
0000c0  8660              STRH     r0,[r4,#0x32]         ;530
0000c2  9700              STR      r7,[sp,#0]            ;536
0000c4  2200              MOVS     r2,#0                 ;536
0000c6  2180              MOVS     r1,#0x80              ;536
0000c8  4620              MOV      r0,r4                 ;536
0000ca  9b01              LDR      r3,[sp,#4]            ;536
0000cc  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
0000d0  2800              CMP      r0,#0                 ;536
0000d2  d001              BEQ      |L15.216|
0000d4  2003              MOVS     r0,#3                 ;538
0000d6  e7a3              B        |L15.32|
                  |L15.216|
0000d8  20ff              MOVS     r0,#0xff              ;540
0000da  6821              LDR      r1,[r4,#0]            ;540
0000dc  6288              STR      r0,[r1,#0x28]         ;540
0000de  9700              STR      r7,[sp,#0]            ;543
0000e0  2200              MOVS     r2,#0                 ;543
0000e2  2120              MOVS     r1,#0x20              ;543
0000e4  4620              MOV      r0,r4                 ;543
0000e6  9b01              LDR      r3,[sp,#4]            ;543
0000e8  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
0000ec  2800              CMP      r0,#0                 ;543
0000ee  d001              BEQ      |L15.244|
0000f0  2003              MOVS     r0,#3                 ;545
0000f2  e795              B        |L15.32|
                  |L15.244|
0000f4  2101              MOVS     r1,#1                 ;548
0000f6  0309              LSLS     r1,r1,#12             ;548
0000f8  68a0              LDR      r0,[r4,#8]            ;548
0000fa  4288              CMP      r0,r1                 ;548
0000fc  d10d              BNE      |L15.282|
0000fe  6920              LDR      r0,[r4,#0x10]         ;548
000100  2800              CMP      r0,#0                 ;548
000102  d10a              BNE      |L15.282|
000104  9503              STR      r5,[sp,#0xc]          ;550
000106  6820              LDR      r0,[r4,#0]            ;551
000108  6a40              LDR      r0,[r0,#0x24]         ;551
00010a  9902              LDR      r1,[sp,#8]            ;551
00010c  4008              ANDS     r0,r0,r1              ;551
00010e  9d03              LDR      r5,[sp,#0xc]          ;551
000110  8028              STRH     r0,[r5,#0]            ;551
000112  e000              B        |L15.278|
                  |L15.276|
000114  e012              B        |L15.316|
                  |L15.278|
000116  1cad              ADDS     r5,r5,#2              ;552
000118  e006              B        |L15.296|
                  |L15.282|
00011a  6820              LDR      r0,[r4,#0]            ;556
00011c  6a40              LDR      r0,[r0,#0x24]         ;556
00011e  9902              LDR      r1,[sp,#8]            ;556
000120  b2c9              UXTB     r1,r1                 ;556
000122  4008              ANDS     r0,r0,r1              ;556
000124  7028              STRB     r0,[r5,#0]            ;556
000126  1c6d              ADDS     r5,r5,#1              ;556
                  |L15.296|
000128  8e60              LDRH     r0,[r4,#0x32]         ;528
00012a  2800              CMP      r0,#0                 ;528
00012c  d1c6              BNE      |L15.188|
00012e  2001              MOVS     r0,#1                 ;561
000130  6460              STR      r0,[r4,#0x44]         ;561
000132  bf00              NOP                            ;564
000134  2000              MOVS     r0,#0                 ;564
000136  6420              STR      r0,[r4,#0x40]         ;564
000138  bf00              NOP                            ;564
00013a  e771              B        |L15.32|
                  |L15.316|
00013c  2002              MOVS     r0,#2                 ;570
00013e  e76f              B        |L15.32|
;;;573    
                          ENDP

                  |L15.320|
                          DCD      0x000001ff

                          AREA ||i.HAL_USART_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_USART_Receive_DMA PROC
;;;971      */
;;;972    HAL_StatusTypeDef HAL_USART_Receive_DMA(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;973    {
000002  4604              MOV      r4,r0
000004  4615              MOV      r5,r2
;;;974      uint32_t *tmp;
;;;975    
;;;976      /* Check that a Rx process is not already ongoing */
;;;977      if(husart->State == HAL_USART_STATE_READY)
000006  6c60              LDR      r0,[r4,#0x44]
000008  2801              CMP      r0,#1
00000a  d169              BNE      |L16.224|
;;;978      {
;;;979        if((pRxData == NULL ) || (Size == 0U))
00000c  9801              LDR      r0,[sp,#4]
00000e  2800              CMP      r0,#0
000010  d001              BEQ      |L16.22|
000012  2d00              CMP      r5,#0
000014  d101              BNE      |L16.26|
                  |L16.22|
;;;980        {
;;;981          return HAL_ERROR;
000016  2001              MOVS     r0,#1
                  |L16.24|
;;;982        }
;;;983    
;;;984        /* In case of 9bits/No Parity transfer, pTxData buffer provided as input paramter 
;;;985           should be aligned on a u16 frontier, as data to be filled into TDR will be 
;;;986           handled through a u16 cast. */
;;;987        if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;988        {
;;;989          if((((uint32_t)pRxData)&1) != 0)
;;;990          {
;;;991            return  HAL_ERROR;
;;;992          }
;;;993        }
;;;994    
;;;995        /* Process Locked */
;;;996        __HAL_LOCK(husart);
;;;997    
;;;998        husart->pRxBuffPtr = pRxData;
;;;999        husart->RxXferSize = Size;
;;;1000       husart->pTxBuffPtr = pRxData;
;;;1001       husart->TxXferSize = Size;
;;;1002   
;;;1003       husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;1004       husart->State = HAL_USART_STATE_BUSY_RX;
;;;1005   
;;;1006       /* Set the USART DMA Rx transfer complete callback */
;;;1007       husart->hdmarx->XferCpltCallback = USART_DMAReceiveCplt;
;;;1008   
;;;1009       /* Set the USART DMA Half transfer complete callback */
;;;1010       husart->hdmarx->XferHalfCpltCallback = USART_DMARxHalfCplt;
;;;1011   
;;;1012       /* Set the USART DMA Rx transfer error callback */
;;;1013       husart->hdmarx->XferErrorCallback = USART_DMAError;
;;;1014   
;;;1015       /* Enable the USART receive DMA channel */
;;;1016       tmp = (uint32_t*)&pRxData;
;;;1017       HAL_DMA_Start_IT(husart->hdmarx, (uint32_t)&husart->Instance->RDR, *(uint32_t*)tmp, Size);
;;;1018   
;;;1019       /* Enable the USART transmit DMA channel: the transmit channel is used in order
;;;1020          to generate in the non-blocking mode the clock to the slave device,
;;;1021          this mode isn't a simplex receive mode but a full-duplex receive mode */
;;;1022       tmp = (uint32_t*)&pRxData;
;;;1023       /* Set the USART DMA Tx Complete and Error callback to Null */
;;;1024       husart->hdmatx->XferErrorCallback = NULL;
;;;1025       husart->hdmatx->XferHalfCpltCallback = NULL;
;;;1026       husart->hdmatx->XferCpltCallback = NULL;
;;;1027       HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t*)tmp, (uint32_t)&husart->Instance->TDR, Size);
;;;1028   
;;;1029       /* Process Unlocked */
;;;1030       __HAL_UNLOCK(husart);
;;;1031   
;;;1032       /* Enable the USART Parity Error Interrupt */
;;;1033       SET_BIT(husart->Instance->CR1, USART_CR1_PEIE);
;;;1034   
;;;1035       /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1036       SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;1037   
;;;1038       /* Enable the DMA transfer for the receiver request by setting the DMAR bit
;;;1039          in the USART CR3 register */
;;;1040       SET_BIT(husart->Instance->CR3, USART_CR3_DMAR);
;;;1041   
;;;1042       /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;1043          in the USART CR3 register */
;;;1044       SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1045   
;;;1046       return HAL_OK;
;;;1047     }
;;;1048     else
;;;1049     {
;;;1050       return HAL_BUSY;
;;;1051     }
;;;1052   }
000018  bdfe              POP      {r1-r7,pc}
                  |L16.26|
00001a  2101              MOVS     r1,#1                 ;987
00001c  0309              LSLS     r1,r1,#12             ;987
00001e  68a0              LDR      r0,[r4,#8]            ;987
000020  4288              CMP      r0,r1                 ;987
000022  d109              BNE      |L16.56|
000024  6920              LDR      r0,[r4,#0x10]         ;987
000026  2800              CMP      r0,#0                 ;987
000028  d106              BNE      |L16.56|
00002a  9801              LDR      r0,[sp,#4]            ;989
00002c  07c0              LSLS     r0,r0,#31             ;989
00002e  0fc0              LSRS     r0,r0,#31             ;989
000030  2800              CMP      r0,#0                 ;989
000032  d001              BEQ      |L16.56|
000034  2001              MOVS     r0,#1                 ;991
000036  e7ef              B        |L16.24|
                  |L16.56|
000038  bf00              NOP                            ;996
00003a  6c20              LDR      r0,[r4,#0x40]         ;996
00003c  2801              CMP      r0,#1                 ;996
00003e  d101              BNE      |L16.68|
000040  2002              MOVS     r0,#2                 ;996
000042  e7e9              B        |L16.24|
                  |L16.68|
000044  2001              MOVS     r0,#1                 ;996
000046  6420              STR      r0,[r4,#0x40]         ;996
000048  bf00              NOP                            ;996
00004a  9801              LDR      r0,[sp,#4]            ;998
00004c  62e0              STR      r0,[r4,#0x2c]         ;998
00004e  8625              STRH     r5,[r4,#0x30]         ;999
000050  9801              LDR      r0,[sp,#4]            ;1000
000052  6260              STR      r0,[r4,#0x24]         ;1000
000054  8525              STRH     r5,[r4,#0x28]         ;1001
000056  2000              MOVS     r0,#0                 ;1003
000058  64a0              STR      r0,[r4,#0x48]         ;1003
00005a  2022              MOVS     r0,#0x22              ;1004
00005c  6460              STR      r0,[r4,#0x44]         ;1004
00005e  4821              LDR      r0,|L16.228|
000060  6be1              LDR      r1,[r4,#0x3c]         ;1007
000062  6308              STR      r0,[r1,#0x30]         ;1007
000064  4820              LDR      r0,|L16.232|
000066  6be1              LDR      r1,[r4,#0x3c]         ;1010
000068  6348              STR      r0,[r1,#0x34]         ;1010
00006a  4820              LDR      r0,|L16.236|
00006c  6be1              LDR      r1,[r4,#0x3c]         ;1013
00006e  6388              STR      r0,[r1,#0x38]         ;1013
000070  ae01              ADD      r6,sp,#4              ;1016
000072  6832              LDR      r2,[r6,#0]            ;1017
000074  6823              LDR      r3,[r4,#0]            ;1017
000076  4619              MOV      r1,r3                 ;1017
000078  3124              ADDS     r1,r1,#0x24           ;1017
00007a  462b              MOV      r3,r5                 ;1017
00007c  6be0              LDR      r0,[r4,#0x3c]         ;1017
00007e  f7fffffe          BL       HAL_DMA_Start_IT
000082  bf00              NOP                            ;1022
000084  2000              MOVS     r0,#0                 ;1024
000086  6ba1              LDR      r1,[r4,#0x38]         ;1024
000088  6388              STR      r0,[r1,#0x38]         ;1024
00008a  6ba1              LDR      r1,[r4,#0x38]         ;1025
00008c  6348              STR      r0,[r1,#0x34]         ;1025
00008e  6ba1              LDR      r1,[r4,#0x38]         ;1026
000090  6308              STR      r0,[r1,#0x30]         ;1026
000092  6823              LDR      r3,[r4,#0]            ;1027
000094  461a              MOV      r2,r3                 ;1027
000096  3228              ADDS     r2,r2,#0x28           ;1027
000098  6831              LDR      r1,[r6,#0]            ;1027
00009a  462b              MOV      r3,r5                 ;1027
00009c  6ba0              LDR      r0,[r4,#0x38]         ;1027
00009e  f7fffffe          BL       HAL_DMA_Start_IT
0000a2  bf00              NOP                            ;1030
0000a4  2000              MOVS     r0,#0                 ;1030
0000a6  6420              STR      r0,[r4,#0x40]         ;1030
0000a8  bf00              NOP                            ;1030
0000aa  6820              LDR      r0,[r4,#0]            ;1033
0000ac  6800              LDR      r0,[r0,#0]            ;1033
0000ae  21ff              MOVS     r1,#0xff              ;1033
0000b0  3101              ADDS     r1,#1                 ;1033
0000b2  4308              ORRS     r0,r0,r1              ;1033
0000b4  6821              LDR      r1,[r4,#0]            ;1033
0000b6  6008              STR      r0,[r1,#0]            ;1033
0000b8  6820              LDR      r0,[r4,#0]            ;1036
0000ba  6880              LDR      r0,[r0,#8]            ;1036
0000bc  2101              MOVS     r1,#1                 ;1036
0000be  4308              ORRS     r0,r0,r1              ;1036
0000c0  6821              LDR      r1,[r4,#0]            ;1036
0000c2  6088              STR      r0,[r1,#8]            ;1036
0000c4  6820              LDR      r0,[r4,#0]            ;1040
0000c6  6880              LDR      r0,[r0,#8]            ;1040
0000c8  2140              MOVS     r1,#0x40              ;1040
0000ca  4308              ORRS     r0,r0,r1              ;1040
0000cc  6821              LDR      r1,[r4,#0]            ;1040
0000ce  6088              STR      r0,[r1,#8]            ;1040
0000d0  6820              LDR      r0,[r4,#0]            ;1044
0000d2  6880              LDR      r0,[r0,#8]            ;1044
0000d4  2180              MOVS     r1,#0x80              ;1044
0000d6  4308              ORRS     r0,r0,r1              ;1044
0000d8  6821              LDR      r1,[r4,#0]            ;1044
0000da  6088              STR      r0,[r1,#8]            ;1044
0000dc  2000              MOVS     r0,#0                 ;1046
0000de  e79b              B        |L16.24|
                  |L16.224|
0000e0  2002              MOVS     r0,#2                 ;1050
0000e2  e799              B        |L16.24|
;;;1053   
                          ENDP

                  |L16.228|
                          DCD      USART_DMAReceiveCplt
                  |L16.232|
                          DCD      USART_DMARxHalfCplt
                  |L16.236|
                          DCD      USART_DMAError

                          AREA ||i.HAL_USART_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_USART_Receive_IT PROC
;;;755      */
;;;756    HAL_StatusTypeDef HAL_USART_Receive_IT(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;757    {
000002  4603              MOV      r3,r0
;;;758      if(husart->State == HAL_USART_STATE_READY)
000004  6c58              LDR      r0,[r3,#0x44]
000006  2801              CMP      r0,#1
000008  d16b              BNE      |L17.226|
;;;759      {
;;;760        if((pRxData == NULL ) || (Size == 0U))
00000a  2900              CMP      r1,#0
00000c  d001              BEQ      |L17.18|
00000e  2a00              CMP      r2,#0
000010  d101              BNE      |L17.22|
                  |L17.18|
;;;761        {
;;;762          return HAL_ERROR;
000012  2001              MOVS     r0,#1
                  |L17.20|
;;;763        }
;;;764    
;;;765        /* In case of 9bits/No Parity transfer, pTxData buffer provided as input paramter 
;;;766           should be aligned on a u16 frontier, as data to be filled into TDR will be 
;;;767           handled through a u16 cast. */
;;;768        if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;769        {
;;;770          if((((uint32_t)pRxData)&1) != 0)
;;;771          {
;;;772            return  HAL_ERROR;
;;;773          }
;;;774        }
;;;775    
;;;776        /* Process Locked */
;;;777        __HAL_LOCK(husart);
;;;778    
;;;779        husart->pRxBuffPtr = pRxData;
;;;780        husart->RxXferSize = Size;
;;;781        husart->RxXferCount = Size;
;;;782    
;;;783        USART_MASK_COMPUTATION(husart);
;;;784    
;;;785        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;786        husart->State = HAL_USART_STATE_BUSY_RX;
;;;787    
;;;788        /* Process Unlocked */
;;;789        __HAL_UNLOCK(husart);
;;;790    
;;;791        /* Enable the USART Parity Error and Data Register not empty Interrupts */
;;;792        SET_BIT(husart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
;;;793    
;;;794        /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;795        SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;796    
;;;797        /* Send dummy byte in order to generate the clock for the Slave to send the next data */
;;;798        if(husart->Init.WordLength == USART_WORDLENGTH_9B)
;;;799        {
;;;800          husart->Instance->TDR = (USART_DUMMY_DATA & (uint16_t)0x01FFU);
;;;801        }
;;;802        else
;;;803        {
;;;804          husart->Instance->TDR = (USART_DUMMY_DATA & (uint16_t)0x00FFU);
;;;805        }
;;;806    
;;;807        return HAL_OK;
;;;808      }
;;;809      else
;;;810      {
;;;811        return HAL_BUSY;
;;;812      }
;;;813    }
000014  bd10              POP      {r4,pc}
                  |L17.22|
000016  2401              MOVS     r4,#1                 ;768
000018  0324              LSLS     r4,r4,#12             ;768
00001a  6898              LDR      r0,[r3,#8]            ;768
00001c  42a0              CMP      r0,r4                 ;768
00001e  d108              BNE      |L17.50|
000020  6918              LDR      r0,[r3,#0x10]         ;768
000022  2800              CMP      r0,#0                 ;768
000024  d105              BNE      |L17.50|
000026  07c8              LSLS     r0,r1,#31             ;770
000028  0fc0              LSRS     r0,r0,#31             ;770
00002a  2800              CMP      r0,#0                 ;770
00002c  d001              BEQ      |L17.50|
00002e  2001              MOVS     r0,#1                 ;772
000030  e7f0              B        |L17.20|
                  |L17.50|
000032  bf00              NOP                            ;777
000034  6c18              LDR      r0,[r3,#0x40]         ;777
000036  2801              CMP      r0,#1                 ;777
000038  d101              BNE      |L17.62|
00003a  2002              MOVS     r0,#2                 ;777
00003c  e7ea              B        |L17.20|
                  |L17.62|
00003e  2001              MOVS     r0,#1                 ;777
000040  6418              STR      r0,[r3,#0x40]         ;777
000042  bf00              NOP                            ;777
000044  62d9              STR      r1,[r3,#0x2c]         ;779
000046  861a              STRH     r2,[r3,#0x30]         ;780
000048  865a              STRH     r2,[r3,#0x32]         ;781
00004a  bf00              NOP                            ;783
00004c  2401              MOVS     r4,#1                 ;783
00004e  0324              LSLS     r4,r4,#12             ;783
000050  6898              LDR      r0,[r3,#8]            ;783
000052  42a0              CMP      r0,r4                 ;783
000054  d108              BNE      |L17.104|
000056  6918              LDR      r0,[r3,#0x10]         ;783
000058  2800              CMP      r0,#0                 ;783
00005a  d102              BNE      |L17.98|
00005c  4822              LDR      r0,|L17.232|
00005e  8698              STRH     r0,[r3,#0x34]         ;783
000060  e01b              B        |L17.154|
                  |L17.98|
000062  20ff              MOVS     r0,#0xff              ;783
000064  8698              STRH     r0,[r3,#0x34]         ;783
000066  e018              B        |L17.154|
                  |L17.104|
000068  6898              LDR      r0,[r3,#8]            ;783
00006a  2800              CMP      r0,#0                 ;783
00006c  d108              BNE      |L17.128|
00006e  6918              LDR      r0,[r3,#0x10]         ;783
000070  2800              CMP      r0,#0                 ;783
000072  d102              BNE      |L17.122|
000074  20ff              MOVS     r0,#0xff              ;783
000076  8698              STRH     r0,[r3,#0x34]         ;783
000078  e00f              B        |L17.154|
                  |L17.122|
00007a  207f              MOVS     r0,#0x7f              ;783
00007c  8698              STRH     r0,[r3,#0x34]         ;783
00007e  e00c              B        |L17.154|
                  |L17.128|
000080  2401              MOVS     r4,#1                 ;783
000082  0724              LSLS     r4,r4,#28             ;783
000084  6898              LDR      r0,[r3,#8]            ;783
000086  42a0              CMP      r0,r4                 ;783
000088  d107              BNE      |L17.154|
00008a  6918              LDR      r0,[r3,#0x10]         ;783
00008c  2800              CMP      r0,#0                 ;783
00008e  d102              BNE      |L17.150|
000090  207f              MOVS     r0,#0x7f              ;783
000092  8698              STRH     r0,[r3,#0x34]         ;783
000094  e001              B        |L17.154|
                  |L17.150|
000096  203f              MOVS     r0,#0x3f              ;783
000098  8698              STRH     r0,[r3,#0x34]         ;783
                  |L17.154|
00009a  bf00              NOP                            ;783
00009c  2000              MOVS     r0,#0                 ;785
00009e  6498              STR      r0,[r3,#0x48]         ;785
0000a0  2022              MOVS     r0,#0x22              ;786
0000a2  6458              STR      r0,[r3,#0x44]         ;786
0000a4  bf00              NOP                            ;789
0000a6  2000              MOVS     r0,#0                 ;789
0000a8  6418              STR      r0,[r3,#0x40]         ;789
0000aa  bf00              NOP                            ;789
0000ac  6818              LDR      r0,[r3,#0]            ;792
0000ae  6800              LDR      r0,[r0,#0]            ;792
0000b0  24ff              MOVS     r4,#0xff              ;792
0000b2  3421              ADDS     r4,r4,#0x21           ;792
0000b4  4320              ORRS     r0,r0,r4              ;792
0000b6  681c              LDR      r4,[r3,#0]            ;792
0000b8  6020              STR      r0,[r4,#0]            ;792
0000ba  6818              LDR      r0,[r3,#0]            ;795
0000bc  6880              LDR      r0,[r0,#8]            ;795
0000be  2401              MOVS     r4,#1                 ;795
0000c0  4320              ORRS     r0,r0,r4              ;795
0000c2  681c              LDR      r4,[r3,#0]            ;795
0000c4  60a0              STR      r0,[r4,#8]            ;795
0000c6  2401              MOVS     r4,#1                 ;798
0000c8  0324              LSLS     r4,r4,#12             ;798
0000ca  6898              LDR      r0,[r3,#8]            ;798
0000cc  42a0              CMP      r0,r4                 ;798
0000ce  d103              BNE      |L17.216|
0000d0  4805              LDR      r0,|L17.232|
0000d2  681c              LDR      r4,[r3,#0]            ;800
0000d4  62a0              STR      r0,[r4,#0x28]         ;800
0000d6  e002              B        |L17.222|
                  |L17.216|
0000d8  20ff              MOVS     r0,#0xff              ;804
0000da  681c              LDR      r4,[r3,#0]            ;804
0000dc  62a0              STR      r0,[r4,#0x28]         ;804
                  |L17.222|
0000de  2000              MOVS     r0,#0                 ;807
0000e0  e798              B        |L17.20|
                  |L17.226|
0000e2  2002              MOVS     r0,#2                 ;811
0000e4  e796              B        |L17.20|
;;;814    
                          ENDP

0000e6  0000              DCW      0x0000
                  |L17.232|
                          DCD      0x000001ff

                          AREA ||i.HAL_USART_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_RxCpltCallback PROC
;;;1669     */
;;;1670   __weak void HAL_USART_RxCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1671   {
;;;1672     /* Prevent unused argument(s) compilation warning */
;;;1673     UNUSED(husart);
;;;1674   
;;;1675     /* NOTE: This function should not be modified, when the callback is needed,
;;;1676              the HAL_USART_RxCpltCallback can be implemented in the user file.
;;;1677      */
;;;1678   }
;;;1679   
                          ENDP


                          AREA ||i.HAL_USART_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_RxHalfCpltCallback PROC
;;;1684     */
;;;1685   __weak void HAL_USART_RxHalfCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1686   {
;;;1687     /* Prevent unused argument(s) compilation warning */
;;;1688     UNUSED(husart);
;;;1689   
;;;1690     /* NOTE : This function should not be modified, when the callback is needed,
;;;1691               the HAL_USART_RxHalfCpltCallback can be implemented in the user file
;;;1692      */
;;;1693   }
;;;1694   
                          ENDP


                          AREA ||i.HAL_USART_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_USART_Transmit PROC
;;;399      */
;;;400    HAL_StatusTypeDef HAL_USART_Transmit(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size, uint32_t Timeout)
000000  b5fe              PUSH     {r1-r7,lr}
;;;401    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;402      uint16_t* tmp;
;;;403      uint32_t tickstart = 0;
00000a  2000              MOVS     r0,#0
00000c  9001              STR      r0,[sp,#4]
;;;404    
;;;405      if(husart->State == HAL_USART_STATE_READY)
00000e  6c60              LDR      r0,[r4,#0x44]
000010  2801              CMP      r0,#1
000012  d15e              BNE      |L20.210|
;;;406      {
;;;407        if((pTxData == NULL) || (Size == 0U))
000014  2d00              CMP      r5,#0
000016  d001              BEQ      |L20.28|
000018  2e00              CMP      r6,#0
00001a  d101              BNE      |L20.32|
                  |L20.28|
;;;408        {
;;;409          return  HAL_ERROR;
00001c  2001              MOVS     r0,#1
                  |L20.30|
;;;410        }
;;;411    
;;;412        /* In case of 9bits/No Parity transfer, pTxData buffer provided as input paramter 
;;;413           should be aligned on a u16 frontier, as data to be filled into TDR will be 
;;;414           handled through a u16 cast. */
;;;415        if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;416        {
;;;417          if((((uint32_t)pTxData)&1) != 0)
;;;418          {
;;;419            return  HAL_ERROR;
;;;420          }
;;;421        }
;;;422    
;;;423        /* Process Locked */
;;;424        __HAL_LOCK(husart);
;;;425    
;;;426        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;427        husart->State = HAL_USART_STATE_BUSY_TX;
;;;428    
;;;429        /* Init tickstart for timeout managment*/
;;;430        tickstart = HAL_GetTick();
;;;431    
;;;432        husart->TxXferSize = Size;
;;;433        husart->TxXferCount = Size;
;;;434    
;;;435        /* Check the remaining data to be sent */
;;;436        while(husart->TxXferCount > 0U)
;;;437        {
;;;438          husart->TxXferCount--;
;;;439          if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;440          {
;;;441            return HAL_TIMEOUT;
;;;442          }
;;;443          if((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;444          {
;;;445            tmp = (uint16_t*) pTxData;
;;;446            husart->Instance->TDR = (*tmp & (uint16_t)0x01FFU);
;;;447            pTxData += 2U;
;;;448          }
;;;449          else
;;;450          {
;;;451            husart->Instance->TDR = (*pTxData++ & (uint8_t)0xFFU);
;;;452          }
;;;453        }
;;;454    
;;;455        if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;456        {
;;;457          return HAL_TIMEOUT;
;;;458        }
;;;459    
;;;460        /* At end of Tx process, restore husart->State to Ready */
;;;461        husart->State = HAL_USART_STATE_READY;
;;;462    
;;;463        /* Process Unlocked */
;;;464        __HAL_UNLOCK(husart);
;;;465    
;;;466        return HAL_OK;
;;;467      }
;;;468      else
;;;469      {
;;;470        return HAL_BUSY;
;;;471      }
;;;472    }
00001e  bdfe              POP      {r1-r7,pc}
                  |L20.32|
000020  2101              MOVS     r1,#1                 ;415
000022  0309              LSLS     r1,r1,#12             ;415
000024  68a0              LDR      r0,[r4,#8]            ;415
000026  4288              CMP      r0,r1                 ;415
000028  d108              BNE      |L20.60|
00002a  6920              LDR      r0,[r4,#0x10]         ;415
00002c  2800              CMP      r0,#0                 ;415
00002e  d105              BNE      |L20.60|
000030  07e8              LSLS     r0,r5,#31             ;417
000032  0fc0              LSRS     r0,r0,#31             ;417
000034  2800              CMP      r0,#0                 ;417
000036  d001              BEQ      |L20.60|
000038  2001              MOVS     r0,#1                 ;419
00003a  e7f0              B        |L20.30|
                  |L20.60|
00003c  bf00              NOP                            ;424
00003e  6c20              LDR      r0,[r4,#0x40]         ;424
000040  2801              CMP      r0,#1                 ;424
000042  d101              BNE      |L20.72|
000044  2002              MOVS     r0,#2                 ;424
000046  e7ea              B        |L20.30|
                  |L20.72|
000048  2001              MOVS     r0,#1                 ;424
00004a  6420              STR      r0,[r4,#0x40]         ;424
00004c  bf00              NOP                            ;424
00004e  2000              MOVS     r0,#0                 ;426
000050  64a0              STR      r0,[r4,#0x48]         ;426
000052  2012              MOVS     r0,#0x12              ;427
000054  6460              STR      r0,[r4,#0x44]         ;427
000056  f7fffffe          BL       HAL_GetTick
00005a  9001              STR      r0,[sp,#4]            ;430
00005c  8526              STRH     r6,[r4,#0x28]         ;432
00005e  8566              STRH     r6,[r4,#0x2a]         ;433
000060  e022              B        |L20.168|
                  |L20.98|
000062  8d60              LDRH     r0,[r4,#0x2a]         ;438
000064  1e40              SUBS     r0,r0,#1              ;438
000066  8560              STRH     r0,[r4,#0x2a]         ;438
000068  9700              STR      r7,[sp,#0]            ;439
00006a  2200              MOVS     r2,#0                 ;439
00006c  2180              MOVS     r1,#0x80              ;439
00006e  4620              MOV      r0,r4                 ;439
000070  9b01              LDR      r3,[sp,#4]            ;439
000072  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000076  2800              CMP      r0,#0                 ;439
000078  d001              BEQ      |L20.126|
00007a  2003              MOVS     r0,#3                 ;441
00007c  e7cf              B        |L20.30|
                  |L20.126|
00007e  2101              MOVS     r1,#1                 ;443
000080  0309              LSLS     r1,r1,#12             ;443
000082  68a0              LDR      r0,[r4,#8]            ;443
000084  4288              CMP      r0,r1                 ;443
000086  d10b              BNE      |L20.160|
000088  6920              LDR      r0,[r4,#0x10]         ;443
00008a  2800              CMP      r0,#0                 ;443
00008c  d108              BNE      |L20.160|
00008e  9502              STR      r5,[sp,#8]            ;445
000090  9d02              LDR      r5,[sp,#8]            ;446
000092  8828              LDRH     r0,[r5,#0]            ;446
000094  05c0              LSLS     r0,r0,#23             ;446
000096  0dc0              LSRS     r0,r0,#23             ;446
000098  6821              LDR      r1,[r4,#0]            ;446
00009a  6288              STR      r0,[r1,#0x28]         ;446
00009c  1cad              ADDS     r5,r5,#2              ;447
00009e  e003              B        |L20.168|
                  |L20.160|
0000a0  7828              LDRB     r0,[r5,#0]            ;451
0000a2  1c6d              ADDS     r5,r5,#1              ;451
0000a4  6821              LDR      r1,[r4,#0]            ;451
0000a6  6288              STR      r0,[r1,#0x28]         ;451
                  |L20.168|
0000a8  8d60              LDRH     r0,[r4,#0x2a]         ;436
0000aa  2800              CMP      r0,#0                 ;436
0000ac  d1d9              BNE      |L20.98|
0000ae  9700              STR      r7,[sp,#0]            ;455
0000b0  2200              MOVS     r2,#0                 ;455
0000b2  2140              MOVS     r1,#0x40              ;455
0000b4  4620              MOV      r0,r4                 ;455
0000b6  9b01              LDR      r3,[sp,#4]            ;455
0000b8  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
0000bc  2800              CMP      r0,#0                 ;455
0000be  d001              BEQ      |L20.196|
0000c0  2003              MOVS     r0,#3                 ;457
0000c2  e7ac              B        |L20.30|
                  |L20.196|
0000c4  2001              MOVS     r0,#1                 ;461
0000c6  6460              STR      r0,[r4,#0x44]         ;461
0000c8  bf00              NOP                            ;464
0000ca  2000              MOVS     r0,#0                 ;464
0000cc  6420              STR      r0,[r4,#0x40]         ;464
0000ce  bf00              NOP                            ;464
0000d0  e7a5              B        |L20.30|
                  |L20.210|
0000d2  2002              MOVS     r0,#2                 ;470
0000d4  e7a3              B        |L20.30|
;;;473    
                          ENDP


                          AREA ||i.HAL_USART_TransmitReceive||, CODE, READONLY, ALIGN=2

                  HAL_USART_TransmitReceive PROC
;;;586      */
;;;587    HAL_StatusTypeDef HAL_USART_TransmitReceive(USART_HandleTypeDef *husart, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
000000  b5f0              PUSH     {r4-r7,lr}
;;;588    {
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;589      uint16_t* tmp;
;;;590      uint16_t uhMask;
;;;591      uint32_t tickstart = 0;
00000c  2000              MOVS     r0,#0
00000e  9001              STR      r0,[sp,#4]
;;;592    
;;;593      if(husart->State == HAL_USART_STATE_READY)
000010  6c60              LDR      r0,[r4,#0x44]
000012  2801              CMP      r0,#1
000014  d17d              BNE      |L21.274|
;;;594      {
;;;595        if((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
000016  2d00              CMP      r5,#0
000018  d003              BEQ      |L21.34|
00001a  2e00              CMP      r6,#0
00001c  d001              BEQ      |L21.34|
00001e  2f00              CMP      r7,#0
000020  d102              BNE      |L21.40|
                  |L21.34|
;;;596        {
;;;597          return  HAL_ERROR;
000022  2001              MOVS     r0,#1
                  |L21.36|
;;;598        }
;;;599    
;;;600        /* In case of 9bits/No Parity transfer, pTxData and pRxData buffers provided as input paramter 
;;;601           should be aligned on a u16 frontier, as data to be filled into TDR/retrieved from RDR will be 
;;;602           handled through a u16 cast. */
;;;603        if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;604        {
;;;605          if(((((uint32_t)pTxData)&1) != 0) || ((((uint32_t)pRxData)&1) != 0))
;;;606          {
;;;607            return  HAL_ERROR;
;;;608          }
;;;609        }
;;;610    
;;;611        /* Process Locked */
;;;612        __HAL_LOCK(husart);
;;;613    
;;;614        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;615        husart->State = HAL_USART_STATE_BUSY_RX;
;;;616    
;;;617        /* Init tickstart for timeout managment*/
;;;618        tickstart = HAL_GetTick();
;;;619    
;;;620        husart->RxXferSize = Size;
;;;621        husart->TxXferSize = Size;
;;;622        husart->TxXferCount = Size;
;;;623        husart->RxXferCount = Size;
;;;624    
;;;625        /* Computation of USART mask to apply to RDR register */
;;;626        USART_MASK_COMPUTATION(husart);
;;;627        uhMask = husart->Mask;
;;;628    
;;;629        /* Check the remain data to be sent */
;;;630        while(husart->TxXferCount > 0U)
;;;631        {
;;;632          husart->TxXferCount--;
;;;633          husart->RxXferCount--;
;;;634    
;;;635          /* Wait until TXE flag is set to send data */
;;;636          if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;637          {
;;;638            return HAL_TIMEOUT;
;;;639          }
;;;640          if((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;641          {
;;;642            tmp = (uint16_t*) pTxData;
;;;643            husart->Instance->TDR = (*tmp & uhMask);
;;;644            pTxData += 2U;
;;;645          }
;;;646          else
;;;647          {
;;;648            husart->Instance->TDR = (*pTxData++ & (uint8_t)uhMask);
;;;649          }
;;;650    
;;;651          /* Wait for RXNE Flag */
;;;652          if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;653          {
;;;654            return HAL_TIMEOUT;
;;;655          }
;;;656    
;;;657          if((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;658          {
;;;659            tmp = (uint16_t*) pRxData ;
;;;660            *tmp = (uint16_t)(husart->Instance->RDR & uhMask);
;;;661            pRxData +=2U;
;;;662          }
;;;663          else
;;;664          {
;;;665            *pRxData++ = (uint8_t)(husart->Instance->RDR & (uint8_t)uhMask);
;;;666          }
;;;667        }
;;;668    
;;;669        /* At end of TxRx process, restore husart->State to Ready */
;;;670        husart->State = HAL_USART_STATE_READY;
;;;671    
;;;672        /* Process Unlocked */
;;;673        __HAL_UNLOCK(husart);
;;;674    
;;;675        return HAL_OK;
;;;676      }
;;;677      else
;;;678      {
;;;679        return HAL_BUSY;
;;;680      }
;;;681    }
000024  b005              ADD      sp,sp,#0x14
000026  bdf0              POP      {r4-r7,pc}
                  |L21.40|
000028  2101              MOVS     r1,#1                 ;603
00002a  0309              LSLS     r1,r1,#12             ;603
00002c  68a0              LDR      r0,[r4,#8]            ;603
00002e  4288              CMP      r0,r1                 ;603
000030  d10c              BNE      |L21.76|
000032  6920              LDR      r0,[r4,#0x10]         ;603
000034  2800              CMP      r0,#0                 ;603
000036  d109              BNE      |L21.76|
000038  07e8              LSLS     r0,r5,#31             ;605
00003a  0fc0              LSRS     r0,r0,#31             ;605
00003c  2800              CMP      r0,#0                 ;605
00003e  d103              BNE      |L21.72|
000040  07f0              LSLS     r0,r6,#31             ;605
000042  0fc0              LSRS     r0,r0,#31             ;605
000044  2800              CMP      r0,#0                 ;605
000046  d001              BEQ      |L21.76|
                  |L21.72|
000048  2001              MOVS     r0,#1                 ;607
00004a  e7eb              B        |L21.36|
                  |L21.76|
00004c  bf00              NOP                            ;612
00004e  6c20              LDR      r0,[r4,#0x40]         ;612
000050  2801              CMP      r0,#1                 ;612
000052  d101              BNE      |L21.88|
000054  2002              MOVS     r0,#2                 ;612
000056  e7e5              B        |L21.36|
                  |L21.88|
000058  2001              MOVS     r0,#1                 ;612
00005a  6420              STR      r0,[r4,#0x40]         ;612
00005c  bf00              NOP                            ;612
00005e  2000              MOVS     r0,#0                 ;614
000060  64a0              STR      r0,[r4,#0x48]         ;614
000062  2022              MOVS     r0,#0x22              ;615
000064  6460              STR      r0,[r4,#0x44]         ;615
000066  f7fffffe          BL       HAL_GetTick
00006a  9001              STR      r0,[sp,#4]            ;618
00006c  8627              STRH     r7,[r4,#0x30]         ;620
00006e  8527              STRH     r7,[r4,#0x28]         ;621
000070  8567              STRH     r7,[r4,#0x2a]         ;622
000072  8667              STRH     r7,[r4,#0x32]         ;623
000074  bf00              NOP                            ;626
000076  2101              MOVS     r1,#1                 ;626
000078  0309              LSLS     r1,r1,#12             ;626
00007a  68a0              LDR      r0,[r4,#8]            ;626
00007c  4288              CMP      r0,r1                 ;626
00007e  d108              BNE      |L21.146|
000080  6920              LDR      r0,[r4,#0x10]         ;626
000082  2800              CMP      r0,#0                 ;626
000084  d102              BNE      |L21.140|
000086  483e              LDR      r0,|L21.384|
000088  86a0              STRH     r0,[r4,#0x34]         ;626
00008a  e01b              B        |L21.196|
                  |L21.140|
00008c  20ff              MOVS     r0,#0xff              ;626
00008e  86a0              STRH     r0,[r4,#0x34]         ;626
000090  e018              B        |L21.196|
                  |L21.146|
000092  68a0              LDR      r0,[r4,#8]            ;626
000094  2800              CMP      r0,#0                 ;626
000096  d108              BNE      |L21.170|
000098  6920              LDR      r0,[r4,#0x10]         ;626
00009a  2800              CMP      r0,#0                 ;626
00009c  d102              BNE      |L21.164|
00009e  20ff              MOVS     r0,#0xff              ;626
0000a0  86a0              STRH     r0,[r4,#0x34]         ;626
0000a2  e00f              B        |L21.196|
                  |L21.164|
0000a4  207f              MOVS     r0,#0x7f              ;626
0000a6  86a0              STRH     r0,[r4,#0x34]         ;626
0000a8  e00c              B        |L21.196|
                  |L21.170|
0000aa  2101              MOVS     r1,#1                 ;626
0000ac  0709              LSLS     r1,r1,#28             ;626
0000ae  68a0              LDR      r0,[r4,#8]            ;626
0000b0  4288              CMP      r0,r1                 ;626
0000b2  d107              BNE      |L21.196|
0000b4  6920              LDR      r0,[r4,#0x10]         ;626
0000b6  2800              CMP      r0,#0                 ;626
0000b8  d102              BNE      |L21.192|
0000ba  207f              MOVS     r0,#0x7f              ;626
0000bc  86a0              STRH     r0,[r4,#0x34]         ;626
0000be  e001              B        |L21.196|
                  |L21.192|
0000c0  203f              MOVS     r0,#0x3f              ;626
0000c2  86a0              STRH     r0,[r4,#0x34]         ;626
                  |L21.196|
0000c4  bf00              NOP                            ;626
0000c6  8ea0              LDRH     r0,[r4,#0x34]         ;627
0000c8  9002              STR      r0,[sp,#8]            ;627
0000ca  e04d              B        |L21.360|
                  |L21.204|
0000cc  8d60              LDRH     r0,[r4,#0x2a]         ;632
0000ce  1e40              SUBS     r0,r0,#1              ;632
0000d0  8560              STRH     r0,[r4,#0x2a]         ;632
0000d2  8e60              LDRH     r0,[r4,#0x32]         ;633
0000d4  1e40              SUBS     r0,r0,#1              ;633
0000d6  8660              STRH     r0,[r4,#0x32]         ;633
0000d8  980a              LDR      r0,[sp,#0x28]         ;636
0000da  9000              STR      r0,[sp,#0]            ;636
0000dc  2200              MOVS     r2,#0                 ;636
0000de  2180              MOVS     r1,#0x80              ;636
0000e0  4620              MOV      r0,r4                 ;636
0000e2  9b01              LDR      r3,[sp,#4]            ;636
0000e4  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
0000e8  2800              CMP      r0,#0                 ;636
0000ea  d001              BEQ      |L21.240|
0000ec  2003              MOVS     r0,#3                 ;638
0000ee  e799              B        |L21.36|
                  |L21.240|
0000f0  2101              MOVS     r1,#1                 ;640
0000f2  0309              LSLS     r1,r1,#12             ;640
0000f4  68a0              LDR      r0,[r4,#8]            ;640
0000f6  4288              CMP      r0,r1                 ;640
0000f8  d10c              BNE      |L21.276|
0000fa  6920              LDR      r0,[r4,#0x10]         ;640
0000fc  2800              CMP      r0,#0                 ;640
0000fe  d109              BNE      |L21.276|
000100  9503              STR      r5,[sp,#0xc]          ;642
000102  9d03              LDR      r5,[sp,#0xc]          ;643
000104  8828              LDRH     r0,[r5,#0]            ;643
000106  9902              LDR      r1,[sp,#8]            ;643
000108  4008              ANDS     r0,r0,r1              ;643
00010a  6821              LDR      r1,[r4,#0]            ;643
00010c  6288              STR      r0,[r1,#0x28]         ;643
00010e  1cad              ADDS     r5,r5,#2              ;644
000110  e006              B        |L21.288|
                  |L21.274|
000112  e033              B        |L21.380|
                  |L21.276|
000114  7828              LDRB     r0,[r5,#0]            ;648
000116  1c6d              ADDS     r5,r5,#1              ;648
000118  9902              LDR      r1,[sp,#8]            ;648
00011a  4008              ANDS     r0,r0,r1              ;648
00011c  6821              LDR      r1,[r4,#0]            ;648
00011e  6288              STR      r0,[r1,#0x28]         ;648
                  |L21.288|
000120  980a              LDR      r0,[sp,#0x28]         ;652
000122  9000              STR      r0,[sp,#0]            ;652
000124  2200              MOVS     r2,#0                 ;652
000126  2120              MOVS     r1,#0x20              ;652
000128  4620              MOV      r0,r4                 ;652
00012a  9b01              LDR      r3,[sp,#4]            ;652
00012c  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000130  2800              CMP      r0,#0                 ;652
000132  d001              BEQ      |L21.312|
000134  2003              MOVS     r0,#3                 ;654
000136  e775              B        |L21.36|
                  |L21.312|
000138  2101              MOVS     r1,#1                 ;657
00013a  0309              LSLS     r1,r1,#12             ;657
00013c  68a0              LDR      r0,[r4,#8]            ;657
00013e  4288              CMP      r0,r1                 ;657
000140  d10b              BNE      |L21.346|
000142  6920              LDR      r0,[r4,#0x10]         ;657
000144  2800              CMP      r0,#0                 ;657
000146  d108              BNE      |L21.346|
000148  9603              STR      r6,[sp,#0xc]          ;659
00014a  6820              LDR      r0,[r4,#0]            ;660
00014c  6a40              LDR      r0,[r0,#0x24]         ;660
00014e  9902              LDR      r1,[sp,#8]            ;660
000150  4008              ANDS     r0,r0,r1              ;660
000152  9e03              LDR      r6,[sp,#0xc]          ;660
000154  8030              STRH     r0,[r6,#0]            ;660
000156  1cb6              ADDS     r6,r6,#2              ;661
000158  e006              B        |L21.360|
                  |L21.346|
00015a  6820              LDR      r0,[r4,#0]            ;665
00015c  6a40              LDR      r0,[r0,#0x24]         ;665
00015e  9902              LDR      r1,[sp,#8]            ;665
000160  b2c9              UXTB     r1,r1                 ;665
000162  4008              ANDS     r0,r0,r1              ;665
000164  7030              STRB     r0,[r6,#0]            ;665
000166  1c76              ADDS     r6,r6,#1              ;665
                  |L21.360|
000168  8d60              LDRH     r0,[r4,#0x2a]         ;630
00016a  2800              CMP      r0,#0                 ;630
00016c  d1ae              BNE      |L21.204|
00016e  2001              MOVS     r0,#1                 ;670
000170  6460              STR      r0,[r4,#0x44]         ;670
000172  bf00              NOP                            ;673
000174  2000              MOVS     r0,#0                 ;673
000176  6420              STR      r0,[r4,#0x40]         ;673
000178  bf00              NOP                            ;673
00017a  e753              B        |L21.36|
                  |L21.380|
00017c  2002              MOVS     r0,#2                 ;679
00017e  e751              B        |L21.36|
;;;682    
                          ENDP

                  |L21.384|
                          DCD      0x000001ff

                          AREA ||i.HAL_USART_TransmitReceive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_USART_TransmitReceive_DMA PROC
;;;1066     */
;;;1067   HAL_StatusTypeDef HAL_USART_TransmitReceive_DMA(USART_HandleTypeDef *husart, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
000000  b57f              PUSH     {r0-r6,lr}
;;;1068   {
000002  4604              MOV      r4,r0
000004  461d              MOV      r5,r3
;;;1069     uint32_t *tmp;
;;;1070   
;;;1071     if(husart->State == HAL_USART_STATE_READY)
000006  6c60              LDR      r0,[r4,#0x44]
000008  2801              CMP      r0,#1
00000a  d17a              BNE      |L22.258|
;;;1072     {
;;;1073       if((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
00000c  9801              LDR      r0,[sp,#4]
00000e  2800              CMP      r0,#0
000010  d004              BEQ      |L22.28|
000012  9802              LDR      r0,[sp,#8]
000014  2800              CMP      r0,#0
000016  d001              BEQ      |L22.28|
000018  2d00              CMP      r5,#0
00001a  d102              BNE      |L22.34|
                  |L22.28|
;;;1074       {
;;;1075         return HAL_ERROR;
00001c  2001              MOVS     r0,#1
                  |L22.30|
;;;1076       }
;;;1077   
;;;1078       /* In case of 9bits/No Parity transfer, pTxData and pRxData buffers provided as input paramter 
;;;1079          should be aligned on a u16 frontier, as data to be filled into TDR/retrieved from RDR will be 
;;;1080          handled through a u16 cast. */
;;;1081       if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;1082       {
;;;1083         if(((((uint32_t)pTxData)&1) != 0) || ((((uint32_t)pRxData)&1) != 0))
;;;1084         {
;;;1085           return  HAL_ERROR;
;;;1086         }
;;;1087       }
;;;1088   
;;;1089       /* Process Locked */
;;;1090       __HAL_LOCK(husart);
;;;1091   
;;;1092       husart->pRxBuffPtr = pRxData;
;;;1093       husart->RxXferSize = Size;
;;;1094       husart->pTxBuffPtr = pTxData;
;;;1095       husart->TxXferSize = Size;
;;;1096   
;;;1097       husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;1098       husart->State = HAL_USART_STATE_BUSY_TX_RX;
;;;1099   
;;;1100       /* Set the USART DMA Rx transfer complete callback */
;;;1101       husart->hdmarx->XferCpltCallback = USART_DMAReceiveCplt;
;;;1102   
;;;1103       /* Set the USART DMA Half transfer complete callback */
;;;1104       husart->hdmarx->XferHalfCpltCallback = USART_DMARxHalfCplt;
;;;1105   
;;;1106       /* Set the USART DMA Tx transfer complete callback */
;;;1107       husart->hdmatx->XferCpltCallback = USART_DMATransmitCplt;
;;;1108   
;;;1109       /* Set the USART DMA Half transfer complete callback */
;;;1110       husart->hdmatx->XferHalfCpltCallback = USART_DMATxHalfCplt;
;;;1111   
;;;1112       /* Set the USART DMA Tx transfer error callback */
;;;1113       husart->hdmatx->XferErrorCallback = USART_DMAError;
;;;1114   
;;;1115       /* Set the USART DMA Rx transfer error callback */
;;;1116       husart->hdmarx->XferErrorCallback = USART_DMAError;
;;;1117   
;;;1118       /* Enable the USART receive DMA channel */
;;;1119       tmp = (uint32_t*)&pRxData;
;;;1120       HAL_DMA_Start_IT(husart->hdmarx, (uint32_t)&husart->Instance->RDR, *(uint32_t*)tmp, Size);
;;;1121   
;;;1122       /* Enable the USART transmit DMA channel */
;;;1123       tmp = (uint32_t*)&pTxData;
;;;1124       HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t*)tmp, (uint32_t)&husart->Instance->TDR, Size);
;;;1125   
;;;1126       /* Process Unlocked */
;;;1127       __HAL_UNLOCK(husart);
;;;1128   
;;;1129       /* Enable the USART Parity Error Interrupt */
;;;1130       SET_BIT(husart->Instance->CR1, USART_CR1_PEIE);
;;;1131   
;;;1132       /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1133       SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;1134   
;;;1135       /* Clear the Overrun flag: mandatory for the second transfer in circular mode */
;;;1136       __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_OREF);
;;;1137   
;;;1138       /* Clear the TC flag in the ICR register */
;;;1139       __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_TCF);
;;;1140   
;;;1141       /* Enable the DMA transfer for the receiver request by setting the DMAR bit
;;;1142          in the USART CR3 register */
;;;1143       SET_BIT(husart->Instance->CR3, USART_CR3_DMAR);
;;;1144   
;;;1145       /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;1146          in the USART CR3 register */
;;;1147       SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1148   
;;;1149       return HAL_OK;
;;;1150     }
;;;1151     else
;;;1152     {
;;;1153       return HAL_BUSY;
;;;1154     }
;;;1155   }
00001e  b004              ADD      sp,sp,#0x10
000020  bd70              POP      {r4-r6,pc}
                  |L22.34|
000022  2101              MOVS     r1,#1                 ;1081
000024  0309              LSLS     r1,r1,#12             ;1081
000026  68a0              LDR      r0,[r4,#8]            ;1081
000028  4288              CMP      r0,r1                 ;1081
00002a  d10e              BNE      |L22.74|
00002c  6920              LDR      r0,[r4,#0x10]         ;1081
00002e  2800              CMP      r0,#0                 ;1081
000030  d10b              BNE      |L22.74|
000032  9801              LDR      r0,[sp,#4]            ;1083
000034  07c0              LSLS     r0,r0,#31             ;1083
000036  0fc0              LSRS     r0,r0,#31             ;1083
000038  2800              CMP      r0,#0                 ;1083
00003a  d104              BNE      |L22.70|
00003c  9802              LDR      r0,[sp,#8]            ;1083
00003e  07c0              LSLS     r0,r0,#31             ;1083
000040  0fc0              LSRS     r0,r0,#31             ;1083
000042  2800              CMP      r0,#0                 ;1083
000044  d001              BEQ      |L22.74|
                  |L22.70|
000046  2001              MOVS     r0,#1                 ;1085
000048  e7e9              B        |L22.30|
                  |L22.74|
00004a  bf00              NOP                            ;1090
00004c  6c20              LDR      r0,[r4,#0x40]         ;1090
00004e  2801              CMP      r0,#1                 ;1090
000050  d101              BNE      |L22.86|
000052  2002              MOVS     r0,#2                 ;1090
000054  e7e3              B        |L22.30|
                  |L22.86|
000056  2001              MOVS     r0,#1                 ;1090
000058  6420              STR      r0,[r4,#0x40]         ;1090
00005a  bf00              NOP                            ;1090
00005c  9802              LDR      r0,[sp,#8]            ;1092
00005e  62e0              STR      r0,[r4,#0x2c]         ;1092
000060  8625              STRH     r5,[r4,#0x30]         ;1093
000062  9801              LDR      r0,[sp,#4]            ;1094
000064  6260              STR      r0,[r4,#0x24]         ;1094
000066  8525              STRH     r5,[r4,#0x28]         ;1095
000068  2000              MOVS     r0,#0                 ;1097
00006a  64a0              STR      r0,[r4,#0x48]         ;1097
00006c  2032              MOVS     r0,#0x32              ;1098
00006e  6460              STR      r0,[r4,#0x44]         ;1098
000070  4825              LDR      r0,|L22.264|
000072  6be1              LDR      r1,[r4,#0x3c]         ;1101
000074  6308              STR      r0,[r1,#0x30]         ;1101
000076  4825              LDR      r0,|L22.268|
000078  6be1              LDR      r1,[r4,#0x3c]         ;1104
00007a  6348              STR      r0,[r1,#0x34]         ;1104
00007c  4824              LDR      r0,|L22.272|
00007e  6ba1              LDR      r1,[r4,#0x38]         ;1107
000080  6308              STR      r0,[r1,#0x30]         ;1107
000082  4824              LDR      r0,|L22.276|
000084  6ba1              LDR      r1,[r4,#0x38]         ;1110
000086  6348              STR      r0,[r1,#0x34]         ;1110
000088  4823              LDR      r0,|L22.280|
00008a  6ba1              LDR      r1,[r4,#0x38]         ;1113
00008c  6388              STR      r0,[r1,#0x38]         ;1113
00008e  6be1              LDR      r1,[r4,#0x3c]         ;1116
000090  6388              STR      r0,[r1,#0x38]         ;1116
000092  ae02              ADD      r6,sp,#8              ;1119
000094  6832              LDR      r2,[r6,#0]            ;1120
000096  6823              LDR      r3,[r4,#0]            ;1120
000098  4619              MOV      r1,r3                 ;1120
00009a  3124              ADDS     r1,r1,#0x24           ;1120
00009c  462b              MOV      r3,r5                 ;1120
00009e  6be0              LDR      r0,[r4,#0x3c]         ;1120
0000a0  f7fffffe          BL       HAL_DMA_Start_IT
0000a4  ae01              ADD      r6,sp,#4              ;1123
0000a6  6823              LDR      r3,[r4,#0]            ;1124
0000a8  461a              MOV      r2,r3                 ;1124
0000aa  3228              ADDS     r2,r2,#0x28           ;1124
0000ac  6831              LDR      r1,[r6,#0]            ;1124
0000ae  462b              MOV      r3,r5                 ;1124
0000b0  6ba0              LDR      r0,[r4,#0x38]         ;1124
0000b2  f7fffffe          BL       HAL_DMA_Start_IT
0000b6  bf00              NOP                            ;1127
0000b8  2000              MOVS     r0,#0                 ;1127
0000ba  6420              STR      r0,[r4,#0x40]         ;1127
0000bc  bf00              NOP                            ;1127
0000be  6820              LDR      r0,[r4,#0]            ;1130
0000c0  6800              LDR      r0,[r0,#0]            ;1130
0000c2  21ff              MOVS     r1,#0xff              ;1130
0000c4  3101              ADDS     r1,#1                 ;1130
0000c6  4308              ORRS     r0,r0,r1              ;1130
0000c8  6821              LDR      r1,[r4,#0]            ;1130
0000ca  6008              STR      r0,[r1,#0]            ;1130
0000cc  6820              LDR      r0,[r4,#0]            ;1133
0000ce  6880              LDR      r0,[r0,#8]            ;1133
0000d0  2101              MOVS     r1,#1                 ;1133
0000d2  4308              ORRS     r0,r0,r1              ;1133
0000d4  6821              LDR      r1,[r4,#0]            ;1133
0000d6  6088              STR      r0,[r1,#8]            ;1133
0000d8  2008              MOVS     r0,#8                 ;1136
0000da  6821              LDR      r1,[r4,#0]            ;1136
0000dc  6208              STR      r0,[r1,#0x20]         ;1136
0000de  2040              MOVS     r0,#0x40              ;1139
0000e0  6821              LDR      r1,[r4,#0]            ;1139
0000e2  6208              STR      r0,[r1,#0x20]         ;1139
0000e4  6820              LDR      r0,[r4,#0]            ;1143
0000e6  6880              LDR      r0,[r0,#8]            ;1143
0000e8  2140              MOVS     r1,#0x40              ;1143
0000ea  4308              ORRS     r0,r0,r1              ;1143
0000ec  6821              LDR      r1,[r4,#0]            ;1143
0000ee  6088              STR      r0,[r1,#8]            ;1143
0000f0  6820              LDR      r0,[r4,#0]            ;1147
0000f2  6880              LDR      r0,[r0,#8]            ;1147
0000f4  2180              MOVS     r1,#0x80              ;1147
0000f6  4308              ORRS     r0,r0,r1              ;1147
0000f8  6821              LDR      r1,[r4,#0]            ;1147
0000fa  6088              STR      r0,[r1,#8]            ;1147
0000fc  2000              MOVS     r0,#0                 ;1149
0000fe  e78e              B        |L22.30|
000100  e7ff              B        |L22.258|
                  |L22.258|
000102  2002              MOVS     r0,#2                 ;1153
000104  e78b              B        |L22.30|
;;;1156   
                          ENDP

000106  0000              DCW      0x0000
                  |L22.264|
                          DCD      USART_DMAReceiveCplt
                  |L22.268|
                          DCD      USART_DMARxHalfCplt
                  |L22.272|
                          DCD      USART_DMATransmitCplt
                  |L22.276|
                          DCD      USART_DMATxHalfCplt
                  |L22.280|
                          DCD      USART_DMAError

                          AREA ||i.HAL_USART_TransmitReceive_IT||, CODE, READONLY, ALIGN=2

                  HAL_USART_TransmitReceive_IT PROC
;;;826      */
;;;827    HAL_StatusTypeDef HAL_USART_TransmitReceive_IT(USART_HandleTypeDef *husart, uint8_t *pTxData, uint8_t *pRxData,  uint16_t Size)
000000  b530              PUSH     {r4,r5,lr}
;;;828    {
000002  4604              MOV      r4,r0
;;;829    
;;;830      if(husart->State == HAL_USART_STATE_READY)
000004  6c60              LDR      r0,[r4,#0x44]
000006  2801              CMP      r0,#1
000008  d16e              BNE      |L23.232|
;;;831      {
;;;832        if((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
00000a  2900              CMP      r1,#0
00000c  d003              BEQ      |L23.22|
00000e  2a00              CMP      r2,#0
000010  d001              BEQ      |L23.22|
000012  2b00              CMP      r3,#0
000014  d101              BNE      |L23.26|
                  |L23.22|
;;;833        {
;;;834          return HAL_ERROR;
000016  2001              MOVS     r0,#1
                  |L23.24|
;;;835        }
;;;836    
;;;837        /* In case of 9bits/No Parity transfer, pTxData and pRxData buffers provided as input paramter 
;;;838           should be aligned on a u16 frontier, as data to be filled into TDR/retrieved from RDR will be 
;;;839           handled through a u16 cast. */
;;;840        if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;841        {
;;;842          if(((((uint32_t)pTxData)&1) != 0) || ((((uint32_t)pRxData)&1) != 0))
;;;843          {
;;;844            return  HAL_ERROR;
;;;845          }
;;;846        }
;;;847    
;;;848        /* Process Locked */
;;;849        __HAL_LOCK(husart);
;;;850    
;;;851        husart->pRxBuffPtr = pRxData;
;;;852        husart->RxXferSize = Size;
;;;853        husart->RxXferCount = Size;
;;;854        husart->pTxBuffPtr = pTxData;
;;;855        husart->TxXferSize = Size;
;;;856        husart->TxXferCount = Size;
;;;857    
;;;858        /* Computation of USART mask to apply to RDR register */
;;;859        USART_MASK_COMPUTATION(husart);
;;;860    
;;;861        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;862        husart->State = HAL_USART_STATE_BUSY_TX_RX;
;;;863    
;;;864        /* Process Unlocked */
;;;865        __HAL_UNLOCK(husart);
;;;866    
;;;867        /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;868        SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;869    
;;;870        /* Enable the USART Parity Error and USART Data Register not empty Interrupts */
;;;871        SET_BIT(husart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
;;;872    
;;;873        /* Enable the USART Transmit Data Register Empty Interrupt */
;;;874        SET_BIT(husart->Instance->CR1, USART_CR1_TXEIE);
;;;875    
;;;876        return HAL_OK;
;;;877      }
;;;878      else
;;;879      {
;;;880        return HAL_BUSY;
;;;881      }
;;;882    }
000018  bd30              POP      {r4,r5,pc}
                  |L23.26|
00001a  2501              MOVS     r5,#1                 ;840
00001c  032d              LSLS     r5,r5,#12             ;840
00001e  68a0              LDR      r0,[r4,#8]            ;840
000020  42a8              CMP      r0,r5                 ;840
000022  d10c              BNE      |L23.62|
000024  6920              LDR      r0,[r4,#0x10]         ;840
000026  2800              CMP      r0,#0                 ;840
000028  d109              BNE      |L23.62|
00002a  07c8              LSLS     r0,r1,#31             ;842
00002c  0fc0              LSRS     r0,r0,#31             ;842
00002e  2800              CMP      r0,#0                 ;842
000030  d103              BNE      |L23.58|
000032  07d0              LSLS     r0,r2,#31             ;842
000034  0fc0              LSRS     r0,r0,#31             ;842
000036  2800              CMP      r0,#0                 ;842
000038  d001              BEQ      |L23.62|
                  |L23.58|
00003a  2001              MOVS     r0,#1                 ;844
00003c  e7ec              B        |L23.24|
                  |L23.62|
00003e  bf00              NOP                            ;849
000040  6c20              LDR      r0,[r4,#0x40]         ;849
000042  2801              CMP      r0,#1                 ;849
000044  d101              BNE      |L23.74|
000046  2002              MOVS     r0,#2                 ;849
000048  e7e6              B        |L23.24|
                  |L23.74|
00004a  2001              MOVS     r0,#1                 ;849
00004c  6420              STR      r0,[r4,#0x40]         ;849
00004e  bf00              NOP                            ;849
000050  62e2              STR      r2,[r4,#0x2c]         ;851
000052  8623              STRH     r3,[r4,#0x30]         ;852
000054  8663              STRH     r3,[r4,#0x32]         ;853
000056  6261              STR      r1,[r4,#0x24]         ;854
000058  8523              STRH     r3,[r4,#0x28]         ;855
00005a  8563              STRH     r3,[r4,#0x2a]         ;856
00005c  bf00              NOP                            ;859
00005e  2501              MOVS     r5,#1                 ;859
000060  032d              LSLS     r5,r5,#12             ;859
000062  68a0              LDR      r0,[r4,#8]            ;859
000064  42a8              CMP      r0,r5                 ;859
000066  d108              BNE      |L23.122|
000068  6920              LDR      r0,[r4,#0x10]         ;859
00006a  2800              CMP      r0,#0                 ;859
00006c  d102              BNE      |L23.116|
00006e  481f              LDR      r0,|L23.236|
000070  86a0              STRH     r0,[r4,#0x34]         ;859
000072  e01b              B        |L23.172|
                  |L23.116|
000074  20ff              MOVS     r0,#0xff              ;859
000076  86a0              STRH     r0,[r4,#0x34]         ;859
000078  e018              B        |L23.172|
                  |L23.122|
00007a  68a0              LDR      r0,[r4,#8]            ;859
00007c  2800              CMP      r0,#0                 ;859
00007e  d108              BNE      |L23.146|
000080  6920              LDR      r0,[r4,#0x10]         ;859
000082  2800              CMP      r0,#0                 ;859
000084  d102              BNE      |L23.140|
000086  20ff              MOVS     r0,#0xff              ;859
000088  86a0              STRH     r0,[r4,#0x34]         ;859
00008a  e00f              B        |L23.172|
                  |L23.140|
00008c  207f              MOVS     r0,#0x7f              ;859
00008e  86a0              STRH     r0,[r4,#0x34]         ;859
000090  e00c              B        |L23.172|
                  |L23.146|
000092  2501              MOVS     r5,#1                 ;859
000094  072d              LSLS     r5,r5,#28             ;859
000096  68a0              LDR      r0,[r4,#8]            ;859
000098  42a8              CMP      r0,r5                 ;859
00009a  d107              BNE      |L23.172|
00009c  6920              LDR      r0,[r4,#0x10]         ;859
00009e  2800              CMP      r0,#0                 ;859
0000a0  d102              BNE      |L23.168|
0000a2  207f              MOVS     r0,#0x7f              ;859
0000a4  86a0              STRH     r0,[r4,#0x34]         ;859
0000a6  e001              B        |L23.172|
                  |L23.168|
0000a8  203f              MOVS     r0,#0x3f              ;859
0000aa  86a0              STRH     r0,[r4,#0x34]         ;859
                  |L23.172|
0000ac  bf00              NOP                            ;859
0000ae  2000              MOVS     r0,#0                 ;861
0000b0  64a0              STR      r0,[r4,#0x48]         ;861
0000b2  2032              MOVS     r0,#0x32              ;862
0000b4  6460              STR      r0,[r4,#0x44]         ;862
0000b6  bf00              NOP                            ;865
0000b8  2000              MOVS     r0,#0                 ;865
0000ba  6420              STR      r0,[r4,#0x40]         ;865
0000bc  bf00              NOP                            ;865
0000be  6820              LDR      r0,[r4,#0]            ;868
0000c0  6880              LDR      r0,[r0,#8]            ;868
0000c2  2501              MOVS     r5,#1                 ;868
0000c4  4328              ORRS     r0,r0,r5              ;868
0000c6  6825              LDR      r5,[r4,#0]            ;868
0000c8  60a8              STR      r0,[r5,#8]            ;868
0000ca  6820              LDR      r0,[r4,#0]            ;871
0000cc  6800              LDR      r0,[r0,#0]            ;871
0000ce  25ff              MOVS     r5,#0xff              ;871
0000d0  3521              ADDS     r5,r5,#0x21           ;871
0000d2  4328              ORRS     r0,r0,r5              ;871
0000d4  6825              LDR      r5,[r4,#0]            ;871
0000d6  6028              STR      r0,[r5,#0]            ;871
0000d8  6820              LDR      r0,[r4,#0]            ;874
0000da  6800              LDR      r0,[r0,#0]            ;874
0000dc  2580              MOVS     r5,#0x80              ;874
0000de  4328              ORRS     r0,r0,r5              ;874
0000e0  6825              LDR      r5,[r4,#0]            ;874
0000e2  6028              STR      r0,[r5,#0]            ;874
0000e4  2000              MOVS     r0,#0                 ;876
0000e6  e797              B        |L23.24|
                  |L23.232|
0000e8  2002              MOVS     r0,#2                 ;880
0000ea  e795              B        |L23.24|
;;;883    
                          ENDP

                  |L23.236|
                          DCD      0x000001ff

                          AREA ||i.HAL_USART_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_USART_Transmit_DMA PROC
;;;894      */
;;;895    HAL_StatusTypeDef HAL_USART_Transmit_DMA(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;896    {
000002  4604              MOV      r4,r0
000004  4615              MOV      r5,r2
;;;897      uint32_t *tmp;
;;;898    
;;;899      if(husart->State == HAL_USART_STATE_READY)
000006  6c60              LDR      r0,[r4,#0x44]
000008  2801              CMP      r0,#1
00000a  d147              BNE      |L24.156|
;;;900      {
;;;901        if((pTxData == NULL ) || (Size == 0U))
00000c  9801              LDR      r0,[sp,#4]
00000e  2800              CMP      r0,#0
000010  d001              BEQ      |L24.22|
000012  2d00              CMP      r5,#0
000014  d101              BNE      |L24.26|
                  |L24.22|
;;;902        {
;;;903          return HAL_ERROR;
000016  2001              MOVS     r0,#1
                  |L24.24|
;;;904        }
;;;905    
;;;906        /* In case of 9bits/No Parity transfer, pTxData buffer provided as input paramter 
;;;907           should be aligned on a u16 frontier, as data to be filled into TDR will be 
;;;908           handled through a u16 cast. */
;;;909        if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;910        {
;;;911          if((((uint32_t)pTxData)&1) != 0)
;;;912          {
;;;913            return  HAL_ERROR;
;;;914          }
;;;915        }
;;;916    
;;;917        /* Process Locked */
;;;918        __HAL_LOCK(husart);
;;;919    
;;;920        husart->pTxBuffPtr = pTxData;
;;;921        husart->TxXferSize = Size;
;;;922        husart->TxXferCount = Size;
;;;923    
;;;924        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;925        husart->State = HAL_USART_STATE_BUSY_TX;
;;;926    
;;;927        /* Set the USART DMA transfer complete callback */
;;;928        husart->hdmatx->XferCpltCallback = USART_DMATransmitCplt;
;;;929    
;;;930        /* Set the USART DMA Half transfer complete callback */
;;;931        husart->hdmatx->XferHalfCpltCallback = USART_DMATxHalfCplt;
;;;932    
;;;933        /* Set the DMA error callback */
;;;934        husart->hdmatx->XferErrorCallback = USART_DMAError;
;;;935    
;;;936        /* Enable the USART transmit DMA channel */
;;;937        tmp = (uint32_t*)&pTxData;
;;;938        HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t*)tmp, (uint32_t)&husart->Instance->TDR, Size);
;;;939    
;;;940        /* Clear the TC flag in the ICR register */
;;;941        __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_TCF);
;;;942    
;;;943        /* Process Unlocked */
;;;944        __HAL_UNLOCK(husart);
;;;945    
;;;946        /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;947           in the USART CR3 register */
;;;948        SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;949    
;;;950        return HAL_OK;
;;;951      }
;;;952      else
;;;953      {
;;;954        return HAL_BUSY;
;;;955      }
;;;956    }
000018  bdfe              POP      {r1-r7,pc}
                  |L24.26|
00001a  2101              MOVS     r1,#1                 ;909
00001c  0309              LSLS     r1,r1,#12             ;909
00001e  68a0              LDR      r0,[r4,#8]            ;909
000020  4288              CMP      r0,r1                 ;909
000022  d109              BNE      |L24.56|
000024  6920              LDR      r0,[r4,#0x10]         ;909
000026  2800              CMP      r0,#0                 ;909
000028  d106              BNE      |L24.56|
00002a  9801              LDR      r0,[sp,#4]            ;911
00002c  07c0              LSLS     r0,r0,#31             ;911
00002e  0fc0              LSRS     r0,r0,#31             ;911
000030  2800              CMP      r0,#0                 ;911
000032  d001              BEQ      |L24.56|
000034  2001              MOVS     r0,#1                 ;913
000036  e7ef              B        |L24.24|
                  |L24.56|
000038  bf00              NOP                            ;918
00003a  6c20              LDR      r0,[r4,#0x40]         ;918
00003c  2801              CMP      r0,#1                 ;918
00003e  d101              BNE      |L24.68|
000040  2002              MOVS     r0,#2                 ;918
000042  e7e9              B        |L24.24|
                  |L24.68|
000044  2001              MOVS     r0,#1                 ;918
000046  6420              STR      r0,[r4,#0x40]         ;918
000048  bf00              NOP                            ;918
00004a  9801              LDR      r0,[sp,#4]            ;920
00004c  6260              STR      r0,[r4,#0x24]         ;920
00004e  8525              STRH     r5,[r4,#0x28]         ;921
000050  8565              STRH     r5,[r4,#0x2a]         ;922
000052  2000              MOVS     r0,#0                 ;924
000054  64a0              STR      r0,[r4,#0x48]         ;924
000056  2012              MOVS     r0,#0x12              ;925
000058  6460              STR      r0,[r4,#0x44]         ;925
00005a  4811              LDR      r0,|L24.160|
00005c  6ba1              LDR      r1,[r4,#0x38]         ;928
00005e  6308              STR      r0,[r1,#0x30]         ;928
000060  4810              LDR      r0,|L24.164|
000062  6ba1              LDR      r1,[r4,#0x38]         ;931
000064  6348              STR      r0,[r1,#0x34]         ;931
000066  4810              LDR      r0,|L24.168|
000068  6ba1              LDR      r1,[r4,#0x38]         ;934
00006a  6388              STR      r0,[r1,#0x38]         ;934
00006c  ae01              ADD      r6,sp,#4              ;937
00006e  6823              LDR      r3,[r4,#0]            ;938
000070  461a              MOV      r2,r3                 ;938
000072  3228              ADDS     r2,r2,#0x28           ;938
000074  6831              LDR      r1,[r6,#0]            ;938
000076  462b              MOV      r3,r5                 ;938
000078  6ba0              LDR      r0,[r4,#0x38]         ;938
00007a  f7fffffe          BL       HAL_DMA_Start_IT
00007e  2040              MOVS     r0,#0x40              ;941
000080  6821              LDR      r1,[r4,#0]            ;941
000082  6208              STR      r0,[r1,#0x20]         ;941
000084  bf00              NOP                            ;944
000086  2000              MOVS     r0,#0                 ;944
000088  6420              STR      r0,[r4,#0x40]         ;944
00008a  bf00              NOP                            ;944
00008c  6820              LDR      r0,[r4,#0]            ;948
00008e  6880              LDR      r0,[r0,#8]            ;948
000090  2180              MOVS     r1,#0x80              ;948
000092  4308              ORRS     r0,r0,r1              ;948
000094  6821              LDR      r1,[r4,#0]            ;948
000096  6088              STR      r0,[r1,#8]            ;948
000098  2000              MOVS     r0,#0                 ;950
00009a  e7bd              B        |L24.24|
                  |L24.156|
00009c  2002              MOVS     r0,#2                 ;954
00009e  e7bb              B        |L24.24|
;;;957    
                          ENDP

                  |L24.160|
                          DCD      USART_DMATransmitCplt
                  |L24.164|
                          DCD      USART_DMATxHalfCplt
                  |L24.168|
                          DCD      USART_DMAError

                          AREA ||i.HAL_USART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  HAL_USART_Transmit_IT PROC
;;;693      */
;;;694    HAL_StatusTypeDef HAL_USART_Transmit_IT(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;695    {
000002  4603              MOV      r3,r0
;;;696      if(husart->State == HAL_USART_STATE_READY)
000004  6c58              LDR      r0,[r3,#0x44]
000006  2801              CMP      r0,#1
000008  d12f              BNE      |L25.106|
;;;697      {
;;;698        if((pTxData == NULL ) || (Size == 0U))
00000a  2900              CMP      r1,#0
00000c  d001              BEQ      |L25.18|
00000e  2a00              CMP      r2,#0
000010  d101              BNE      |L25.22|
                  |L25.18|
;;;699        {
;;;700          return HAL_ERROR;
000012  2001              MOVS     r0,#1
                  |L25.20|
;;;701        }
;;;702    
;;;703        /* In case of 9bits/No Parity transfer, pTxData buffer provided as input paramter 
;;;704           should be aligned on a u16 frontier, as data to be filled into TDR will be 
;;;705           handled through a u16 cast. */
;;;706        if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;707        {
;;;708          if((((uint32_t)pTxData)&1) != 0)
;;;709          {
;;;710            return  HAL_ERROR;
;;;711          }
;;;712        }
;;;713    
;;;714        /* Process Locked */
;;;715        __HAL_LOCK(husart);
;;;716    
;;;717        husart->pTxBuffPtr = pTxData;
;;;718        husart->TxXferSize = Size;
;;;719        husart->TxXferCount = Size;
;;;720    
;;;721        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;722        husart->State = HAL_USART_STATE_BUSY_TX;
;;;723    
;;;724        /* The USART Error Interrupts: (Frame error, noise error, overrun error)
;;;725        are not managed by the USART Transmit Process to avoid the overrun interrupt
;;;726        when the usart mode is configured for transmit and receive "USART_MODE_TX_RX"
;;;727        to benefit for the frame error and noise interrupts the usart mode should be
;;;728        configured only for transmit "USART_MODE_TX" */
;;;729    
;;;730        /* Process Unlocked */
;;;731        __HAL_UNLOCK(husart);
;;;732    
;;;733        /* Enable the USART Transmit Data Register Empty Interrupt */
;;;734        __HAL_USART_ENABLE_IT(husart, USART_IT_TXE);
;;;735    
;;;736        return HAL_OK;
;;;737      }
;;;738      else
;;;739      {
;;;740        return HAL_BUSY;
;;;741      }
;;;742    }
000014  bd10              POP      {r4,pc}
                  |L25.22|
000016  2401              MOVS     r4,#1                 ;706
000018  0324              LSLS     r4,r4,#12             ;706
00001a  6898              LDR      r0,[r3,#8]            ;706
00001c  42a0              CMP      r0,r4                 ;706
00001e  d108              BNE      |L25.50|
000020  6918              LDR      r0,[r3,#0x10]         ;706
000022  2800              CMP      r0,#0                 ;706
000024  d105              BNE      |L25.50|
000026  07c8              LSLS     r0,r1,#31             ;708
000028  0fc0              LSRS     r0,r0,#31             ;708
00002a  2800              CMP      r0,#0                 ;708
00002c  d001              BEQ      |L25.50|
00002e  2001              MOVS     r0,#1                 ;710
000030  e7f0              B        |L25.20|
                  |L25.50|
000032  bf00              NOP                            ;715
000034  6c18              LDR      r0,[r3,#0x40]         ;715
000036  2801              CMP      r0,#1                 ;715
000038  d101              BNE      |L25.62|
00003a  2002              MOVS     r0,#2                 ;715
00003c  e7ea              B        |L25.20|
                  |L25.62|
00003e  2001              MOVS     r0,#1                 ;715
000040  6418              STR      r0,[r3,#0x40]         ;715
000042  bf00              NOP                            ;715
000044  6259              STR      r1,[r3,#0x24]         ;717
000046  851a              STRH     r2,[r3,#0x28]         ;718
000048  855a              STRH     r2,[r3,#0x2a]         ;719
00004a  2000              MOVS     r0,#0                 ;721
00004c  6498              STR      r0,[r3,#0x48]         ;721
00004e  2012              MOVS     r0,#0x12              ;722
000050  6458              STR      r0,[r3,#0x44]         ;722
000052  bf00              NOP                            ;731
000054  2000              MOVS     r0,#0                 ;731
000056  6418              STR      r0,[r3,#0x40]         ;731
000058  bf00              NOP                            ;731
00005a  6818              LDR      r0,[r3,#0]            ;734
00005c  6800              LDR      r0,[r0,#0]            ;734
00005e  2480              MOVS     r4,#0x80              ;734
000060  4320              ORRS     r0,r0,r4              ;734
000062  681c              LDR      r4,[r3,#0]            ;734
000064  6020              STR      r0,[r4,#0]            ;734
000066  2000              MOVS     r0,#0                 ;736
000068  e7d4              B        |L25.20|
                  |L25.106|
00006a  2002              MOVS     r0,#2                 ;740
00006c  e7d2              B        |L25.20|
;;;743    
                          ENDP


                          AREA ||i.HAL_USART_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_TxCpltCallback PROC
;;;1639     */
;;;1640   __weak void HAL_USART_TxCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1641   {
;;;1642     /* Prevent unused argument(s) compilation warning */
;;;1643     UNUSED(husart);
;;;1644   
;;;1645     /* NOTE : This function should not be modified, when the callback is needed,
;;;1646               the HAL_USART_TxCpltCallback can be implemented in the user file.
;;;1647      */
;;;1648   }
;;;1649   
                          ENDP


                          AREA ||i.HAL_USART_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_TxHalfCpltCallback PROC
;;;1654     */
;;;1655   __weak void HAL_USART_TxHalfCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1656   {
;;;1657     /* Prevent unused argument(s) compilation warning */
;;;1658     UNUSED(husart);
;;;1659   
;;;1660     /* NOTE: This function should not be modified, when the callback is needed,
;;;1661              the HAL_USART_TxHalfCpltCallback can be implemented in the user file.
;;;1662      */
;;;1663   }
;;;1664   
                          ENDP


                          AREA ||i.HAL_USART_TxRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_TxRxCpltCallback PROC
;;;1699     */
;;;1700   __weak void HAL_USART_TxRxCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1701   {
;;;1702     /* Prevent unused argument(s) compilation warning */
;;;1703     UNUSED(husart);
;;;1704   
;;;1705     /* NOTE : This function should not be modified, when the callback is needed,
;;;1706               the HAL_USART_TxRxCpltCallback can be implemented in the user file
;;;1707      */
;;;1708   }
;;;1709   
                          ENDP


                          AREA ||i.USART_CheckIdleState||, CODE, READONLY, ALIGN=1

                  USART_CheckIdleState PROC
;;;2158     */
;;;2159   static HAL_StatusTypeDef USART_CheckIdleState(USART_HandleTypeDef *husart)
000000  b538              PUSH     {r3-r5,lr}
;;;2160   {
000002  4604              MOV      r4,r0
;;;2161     uint32_t tickstart = 0;
000004  2500              MOVS     r5,#0
;;;2162   
;;;2163     /* Initialize the USART ErrorCode */
;;;2164     husart->ErrorCode = HAL_USART_ERROR_NONE;
000006  2000              MOVS     r0,#0
000008  64a0              STR      r0,[r4,#0x48]
;;;2165   
;;;2166     /* Init tickstart for timeout managment*/
;;;2167     tickstart = HAL_GetTick();
00000a  f7fffffe          BL       HAL_GetTick
00000e  4605              MOV      r5,r0
;;;2168   
;;;2169     /* Check if the Transmitter is enabled */
;;;2170     if((husart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
000010  6820              LDR      r0,[r4,#0]
000012  6800              LDR      r0,[r0,#0]
000014  2108              MOVS     r1,#8
000016  4008              ANDS     r0,r0,r1
000018  2808              CMP      r0,#8
00001a  d10c              BNE      |L29.54|
;;;2171     {
;;;2172       /* Wait until TEACK flag is set */
;;;2173       if(USART_WaitOnFlagUntilTimeout(husart, USART_ISR_TEACK, RESET, tickstart, USART_TEACK_REACK_TIMEOUT) != HAL_OK)
00001c  207d              MOVS     r0,#0x7d
00001e  00c0              LSLS     r0,r0,#3
000020  462b              MOV      r3,r5
000022  2200              MOVS     r2,#0
000024  0489              LSLS     r1,r1,#18
000026  9000              STR      r0,[sp,#0]
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
00002e  2800              CMP      r0,#0
000030  d001              BEQ      |L29.54|
;;;2174       {
;;;2175         /* Timeout occurred */
;;;2176         return HAL_TIMEOUT;
000032  2003              MOVS     r0,#3
                  |L29.52|
;;;2177       }
;;;2178     }
;;;2179     /* Check if the Receiver is enabled */
;;;2180     if((husart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
;;;2181     {
;;;2182       /* Wait until REACK flag is set */
;;;2183       if(USART_WaitOnFlagUntilTimeout(husart, USART_ISR_REACK, RESET, tickstart, USART_TEACK_REACK_TIMEOUT) != HAL_OK)
;;;2184       {
;;;2185         /* Timeout occurred */
;;;2186         return HAL_TIMEOUT;
;;;2187       }
;;;2188     }
;;;2189   
;;;2190     /* Initialize the USART state*/
;;;2191     husart->State= HAL_USART_STATE_READY;
;;;2192   
;;;2193     /* Process Unlocked */
;;;2194     __HAL_UNLOCK(husart);
;;;2195   
;;;2196     return HAL_OK;
;;;2197   }
000034  bd38              POP      {r3-r5,pc}
                  |L29.54|
000036  6820              LDR      r0,[r4,#0]            ;2180
000038  6800              LDR      r0,[r0,#0]            ;2180
00003a  2104              MOVS     r1,#4                 ;2180
00003c  4008              ANDS     r0,r0,r1              ;2180
00003e  2804              CMP      r0,#4                 ;2180
000040  d10c              BNE      |L29.92|
000042  207d              MOVS     r0,#0x7d              ;2183
000044  00c0              LSLS     r0,r0,#3              ;2183
000046  462b              MOV      r3,r5                 ;2183
000048  2200              MOVS     r2,#0                 ;2183
00004a  0509              LSLS     r1,r1,#20             ;2183
00004c  9000              STR      r0,[sp,#0]            ;2183
00004e  4620              MOV      r0,r4                 ;2183
000050  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000054  2800              CMP      r0,#0                 ;2183
000056  d001              BEQ      |L29.92|
000058  2003              MOVS     r0,#3                 ;2186
00005a  e7eb              B        |L29.52|
                  |L29.92|
00005c  2001              MOVS     r0,#1                 ;2191
00005e  6460              STR      r0,[r4,#0x44]         ;2191
000060  bf00              NOP                            ;2194
000062  2000              MOVS     r0,#0                 ;2194
000064  6420              STR      r0,[r4,#0x40]         ;2194
000066  bf00              NOP                            ;2194
000068  bf00              NOP                            ;2196
00006a  e7e3              B        |L29.52|
;;;2198   
                          ENDP


                          AREA ||i.USART_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  USART_DMAAbortOnError PROC
;;;1945     */
;;;1946   static void USART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1947   {
000002  4605              MOV      r5,r0
;;;1948     USART_HandleTypeDef* husart = (USART_HandleTypeDef*)(hdma->Parent);
000004  6aec              LDR      r4,[r5,#0x2c]
;;;1949     husart->RxXferCount = 0;
000006  2000              MOVS     r0,#0
000008  8660              STRH     r0,[r4,#0x32]
;;;1950     husart->TxXferCount = 0;
00000a  8560              STRH     r0,[r4,#0x2a]
;;;1951   
;;;1952     HAL_USART_ErrorCallback(husart);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       HAL_USART_ErrorCallback
;;;1953   }
000012  bd70              POP      {r4-r6,pc}
;;;1954   
                          ENDP


                          AREA ||i.USART_DMAError||, CODE, READONLY, ALIGN=1

                  USART_DMAError PROC
;;;1925     */
;;;1926   static void USART_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1927   {
000002  4605              MOV      r5,r0
;;;1928     USART_HandleTypeDef* husart = (USART_HandleTypeDef*)(hdma->Parent);
000004  6aec              LDR      r4,[r5,#0x2c]
;;;1929   
;;;1930     husart->RxXferCount = 0;
000006  2000              MOVS     r0,#0
000008  8660              STRH     r0,[r4,#0x32]
;;;1931     husart->TxXferCount = 0;
00000a  8560              STRH     r0,[r4,#0x2a]
;;;1932     USART_EndTransfer(husart);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       USART_EndTransfer
;;;1933   
;;;1934     husart->ErrorCode |= HAL_USART_ERROR_DMA;
000012  6ca0              LDR      r0,[r4,#0x48]
000014  2110              MOVS     r1,#0x10
000016  4308              ORRS     r0,r0,r1
000018  64a0              STR      r0,[r4,#0x48]
;;;1935     husart->State= HAL_USART_STATE_READY;
00001a  2001              MOVS     r0,#1
00001c  6460              STR      r0,[r4,#0x44]
;;;1936   
;;;1937     HAL_USART_ErrorCallback(husart);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       HAL_USART_ErrorCallback
;;;1938   }
000024  bd70              POP      {r4-r6,pc}
;;;1939   
                          ENDP


                          AREA ||i.USART_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  USART_DMAReceiveCplt PROC
;;;1861     */
;;;1862   static void USART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1863   {
000002  4605              MOV      r5,r0
;;;1864     USART_HandleTypeDef* husart = (USART_HandleTypeDef*)(hdma->Parent);
000004  6aec              LDR      r4,[r5,#0x2c]
;;;1865   
;;;1866     /* DMA Normal mode */
;;;1867     if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
000006  6828              LDR      r0,[r5,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  2120              MOVS     r1,#0x20
00000c  4008              ANDS     r0,r0,r1
00000e  2800              CMP      r0,#0
000010  d125              BNE      |L32.94|
;;;1868     {
;;;1869       husart->RxXferCount = 0;
000012  8660              STRH     r0,[r4,#0x32]
;;;1870   
;;;1871       /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1872       CLEAR_BIT(husart->Instance->CR1, USART_CR1_PEIE);
000014  6820              LDR      r0,[r4,#0]
000016  6800              LDR      r0,[r0,#0]
000018  00c9              LSLS     r1,r1,#3
00001a  4388              BICS     r0,r0,r1
00001c  6821              LDR      r1,[r4,#0]
00001e  6008              STR      r0,[r1,#0]
;;;1873       CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
000020  6820              LDR      r0,[r4,#0]
000022  6880              LDR      r0,[r0,#8]
000024  0840              LSRS     r0,r0,#1
000026  0040              LSLS     r0,r0,#1
000028  6821              LDR      r1,[r4,#0]
00002a  6088              STR      r0,[r1,#8]
;;;1874   
;;;1875       /* Disable the DMA RX transfer for the receiver request by resetting the DMAR bit
;;;1876          in USART CR3 register */
;;;1877       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
00002c  6820              LDR      r0,[r4,#0]
00002e  6880              LDR      r0,[r0,#8]
000030  2140              MOVS     r1,#0x40
000032  4388              BICS     r0,r0,r1
000034  6821              LDR      r1,[r4,#0]
000036  6088              STR      r0,[r1,#8]
;;;1878       /* similarly, disable the DMA TX transfer that was started to provide the
;;;1879          clock to the slave device */
;;;1880       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
000038  6820              LDR      r0,[r4,#0]
00003a  6880              LDR      r0,[r0,#8]
00003c  2180              MOVS     r1,#0x80
00003e  4388              BICS     r0,r0,r1
000040  6821              LDR      r1,[r4,#0]
000042  6088              STR      r0,[r1,#8]
;;;1881   
;;;1882       if(husart->State == HAL_USART_STATE_BUSY_RX)
000044  6c60              LDR      r0,[r4,#0x44]
000046  2822              CMP      r0,#0x22
000048  d103              BNE      |L32.82|
;;;1883       {
;;;1884         HAL_USART_RxCpltCallback(husart);
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       HAL_USART_RxCpltCallback
000050  e002              B        |L32.88|
                  |L32.82|
;;;1885       }
;;;1886       /* The USART state is HAL_USART_STATE_BUSY_TX_RX */
;;;1887       else
;;;1888       {
;;;1889         HAL_USART_TxRxCpltCallback(husart);
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       HAL_USART_TxRxCpltCallback
                  |L32.88|
;;;1890       }
;;;1891       husart->State= HAL_USART_STATE_READY;
000058  2001              MOVS     r0,#1
00005a  6460              STR      r0,[r4,#0x44]
00005c  e009              B        |L32.114|
                  |L32.94|
;;;1892     }
;;;1893     /* DMA circular mode */
;;;1894     else
;;;1895     {
;;;1896       if(husart->State == HAL_USART_STATE_BUSY_RX)
00005e  6c60              LDR      r0,[r4,#0x44]
000060  2822              CMP      r0,#0x22
000062  d103              BNE      |L32.108|
;;;1897       {
;;;1898         HAL_USART_RxCpltCallback(husart);
000064  4620              MOV      r0,r4
000066  f7fffffe          BL       HAL_USART_RxCpltCallback
00006a  e002              B        |L32.114|
                  |L32.108|
;;;1899       }
;;;1900       /* The USART state is HAL_USART_STATE_BUSY_TX_RX */
;;;1901       else
;;;1902       {
;;;1903         HAL_USART_TxRxCpltCallback(husart);
00006c  4620              MOV      r0,r4
00006e  f7fffffe          BL       HAL_USART_TxRxCpltCallback
                  |L32.114|
;;;1904       }
;;;1905     }    
;;;1906   
;;;1907   }
000072  bd70              POP      {r4-r6,pc}
;;;1908   
                          ENDP


                          AREA ||i.USART_DMARxAbortCallback||, CODE, READONLY, ALIGN=1

                  USART_DMARxAbortCallback PROC
;;;2003     */
;;;2004   static void USART_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2005   {
000002  4605              MOV      r5,r0
;;;2006     USART_HandleTypeDef* husart = (USART_HandleTypeDef* )(hdma->Parent);
000004  6aec              LDR      r4,[r5,#0x2c]
;;;2007     
;;;2008     husart->hdmarx->XferAbortCallback = NULL;
000006  2000              MOVS     r0,#0
000008  6be1              LDR      r1,[r4,#0x3c]
00000a  63c8              STR      r0,[r1,#0x3c]
;;;2009   
;;;2010     /* Check if an Abort process is still ongoing */
;;;2011     if(husart->hdmatx != NULL)
00000c  6ba0              LDR      r0,[r4,#0x38]
00000e  2800              CMP      r0,#0
000010  d004              BEQ      |L33.28|
;;;2012     {
;;;2013       if(husart->hdmatx->XferAbortCallback != NULL)
000012  6ba0              LDR      r0,[r4,#0x38]
000014  6bc0              LDR      r0,[r0,#0x3c]
000016  2800              CMP      r0,#0
000018  d000              BEQ      |L33.28|
                  |L33.26|
;;;2014       {
;;;2015         return;
;;;2016       }
;;;2017     }
;;;2018     
;;;2019     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;2020     husart->TxXferCount = 0;
;;;2021     husart->RxXferCount = 0;
;;;2022   
;;;2023     /* Reset errorCode */
;;;2024     husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;2025   
;;;2026     /* Clear the Error flags in the ICR register */
;;;2027     __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_OREF | USART_CLEAR_NEF | USART_CLEAR_PEF | USART_CLEAR_FEF);
;;;2028   
;;;2029     /* Restore husart->State to Ready */
;;;2030     husart->State  = HAL_USART_STATE_READY;
;;;2031   
;;;2032     /* Call user Abort complete callback */
;;;2033     HAL_USART_AbortCpltCallback(husart);
;;;2034   }
00001a  bd70              POP      {r4-r6,pc}
                  |L33.28|
00001c  2000              MOVS     r0,#0                 ;2020
00001e  8560              STRH     r0,[r4,#0x2a]         ;2020
000020  8660              STRH     r0,[r4,#0x32]         ;2021
000022  64a0              STR      r0,[r4,#0x48]         ;2024
000024  200f              MOVS     r0,#0xf               ;2027
000026  6821              LDR      r1,[r4,#0]            ;2027
000028  6208              STR      r0,[r1,#0x20]         ;2027
00002a  2001              MOVS     r0,#1                 ;2030
00002c  6460              STR      r0,[r4,#0x44]         ;2030
00002e  4620              MOV      r0,r4                 ;2033
000030  f7fffffe          BL       HAL_USART_AbortCpltCallback
000034  bf00              NOP      
000036  e7f0              B        |L33.26|
;;;2035   
                          ENDP


                          AREA ||i.USART_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  USART_DMARxHalfCplt PROC
;;;1913     */
;;;1914   static void USART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1915   {
000002  4604              MOV      r4,r0
;;;1916     USART_HandleTypeDef* husart = (USART_HandleTypeDef*)(hdma->Parent);
000004  6ae5              LDR      r5,[r4,#0x2c]
;;;1917   
;;;1918     HAL_USART_RxHalfCpltCallback(husart);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_USART_RxHalfCpltCallback
;;;1919   }
00000c  bd70              POP      {r4-r6,pc}
;;;1920   
                          ENDP


                          AREA ||i.USART_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  USART_DMATransmitCplt PROC
;;;1815     */
;;;1816   static void USART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1817   {
000002  4605              MOV      r5,r0
;;;1818     USART_HandleTypeDef* husart = (USART_HandleTypeDef*)(hdma->Parent);
000004  6aec              LDR      r4,[r5,#0x2c]
;;;1819   
;;;1820     /* DMA Normal mode */
;;;1821     if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
000006  6828              LDR      r0,[r5,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  2120              MOVS     r1,#0x20
00000c  4008              ANDS     r0,r0,r1
00000e  2800              CMP      r0,#0
000010  d110              BNE      |L35.52|
;;;1822     {
;;;1823       husart->TxXferCount = 0U;
000012  8560              STRH     r0,[r4,#0x2a]
;;;1824   
;;;1825       if(husart->State == HAL_USART_STATE_BUSY_TX)
000014  6c60              LDR      r0,[r4,#0x44]
000016  2812              CMP      r0,#0x12
000018  d112              BNE      |L35.64|
;;;1826       {
;;;1827         /* Disable the DMA transfer for transmit request by resetting the DMAT bit
;;;1828            in the USART CR3 register */
;;;1829         CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
00001a  6820              LDR      r0,[r4,#0]
00001c  6880              LDR      r0,[r0,#8]
00001e  2180              MOVS     r1,#0x80
000020  4388              BICS     r0,r0,r1
000022  6821              LDR      r1,[r4,#0]
000024  6088              STR      r0,[r1,#8]
;;;1830   
;;;1831         /* Enable the USART Transmit Complete Interrupt */
;;;1832         __HAL_USART_ENABLE_IT(husart, USART_IT_TC);
000026  6820              LDR      r0,[r4,#0]
000028  6800              LDR      r0,[r0,#0]
00002a  2140              MOVS     r1,#0x40
00002c  4308              ORRS     r0,r0,r1
00002e  6821              LDR      r1,[r4,#0]
000030  6008              STR      r0,[r1,#0]
000032  e005              B        |L35.64|
                  |L35.52|
;;;1833       }
;;;1834     }
;;;1835     /* DMA Circular mode */
;;;1836     else
;;;1837     {
;;;1838       if(husart->State == HAL_USART_STATE_BUSY_TX)
000034  6c60              LDR      r0,[r4,#0x44]
000036  2812              CMP      r0,#0x12
000038  d102              BNE      |L35.64|
;;;1839       {
;;;1840       HAL_USART_TxCpltCallback(husart);
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       HAL_USART_TxCpltCallback
                  |L35.64|
;;;1841      }
;;;1842    }
;;;1843   }
000040  bd70              POP      {r4-r6,pc}
;;;1844   
                          ENDP


                          AREA ||i.USART_DMATxAbortCallback||, CODE, READONLY, ALIGN=1

                  USART_DMATxAbortCallback PROC
;;;1962     */
;;;1963   static void USART_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1964   {
000002  4605              MOV      r5,r0
;;;1965     USART_HandleTypeDef* husart = (USART_HandleTypeDef* )(hdma->Parent);
000004  6aec              LDR      r4,[r5,#0x2c]
;;;1966     
;;;1967     husart->hdmatx->XferAbortCallback = NULL;
000006  2000              MOVS     r0,#0
000008  6ba1              LDR      r1,[r4,#0x38]
00000a  63c8              STR      r0,[r1,#0x3c]
;;;1968   
;;;1969     /* Check if an Abort process is still ongoing */
;;;1970     if(husart->hdmarx != NULL)
00000c  6be0              LDR      r0,[r4,#0x3c]
00000e  2800              CMP      r0,#0
000010  d004              BEQ      |L36.28|
;;;1971     {
;;;1972       if(husart->hdmarx->XferAbortCallback != NULL)
000012  6be0              LDR      r0,[r4,#0x3c]
000014  6bc0              LDR      r0,[r0,#0x3c]
000016  2800              CMP      r0,#0
000018  d000              BEQ      |L36.28|
                  |L36.26|
;;;1973       {
;;;1974         return;
;;;1975       }
;;;1976     }
;;;1977     
;;;1978     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;1979     husart->TxXferCount = 0;
;;;1980     husart->RxXferCount = 0;
;;;1981   
;;;1982     /* Reset errorCode */
;;;1983     husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;1984   
;;;1985     /* Clear the Error flags in the ICR register */
;;;1986     __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_OREF | USART_CLEAR_NEF | USART_CLEAR_PEF | USART_CLEAR_FEF);
;;;1987   
;;;1988     /* Restore husart->State to Ready */
;;;1989     husart->State  = HAL_USART_STATE_READY;
;;;1990   
;;;1991     /* Call user Abort complete callback */
;;;1992     HAL_USART_AbortCpltCallback(husart);
;;;1993   }
00001a  bd70              POP      {r4-r6,pc}
                  |L36.28|
00001c  2000              MOVS     r0,#0                 ;1979
00001e  8560              STRH     r0,[r4,#0x2a]         ;1979
000020  8660              STRH     r0,[r4,#0x32]         ;1980
000022  64a0              STR      r0,[r4,#0x48]         ;1983
000024  200f              MOVS     r0,#0xf               ;1986
000026  6821              LDR      r1,[r4,#0]            ;1986
000028  6208              STR      r0,[r1,#0x20]         ;1986
00002a  2001              MOVS     r0,#1                 ;1989
00002c  6460              STR      r0,[r4,#0x44]         ;1989
00002e  4620              MOV      r0,r4                 ;1992
000030  f7fffffe          BL       HAL_USART_AbortCpltCallback
000034  bf00              NOP      
000036  e7f0              B        |L36.26|
;;;1994   
                          ENDP


                          AREA ||i.USART_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  USART_DMATxHalfCplt PROC
;;;1849     */
;;;1850   static void USART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1851   {
000002  4604              MOV      r4,r0
;;;1852     USART_HandleTypeDef* husart = (USART_HandleTypeDef*)(hdma->Parent);
000004  6ae5              LDR      r5,[r4,#0x2c]
;;;1853   
;;;1854     HAL_USART_TxHalfCpltCallback(husart);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_USART_TxHalfCpltCallback
;;;1855   }
00000c  bd70              POP      {r4-r6,pc}
;;;1856   
                          ENDP


                          AREA ||i.USART_EndTransfer||, CODE, READONLY, ALIGN=1

                  USART_EndTransfer PROC
;;;1799     */
;;;1800   static void USART_EndTransfer(USART_HandleTypeDef *husart)
000000  6801              LDR      r1,[r0,#0]
;;;1801   {
;;;1802     /* Disable TXEIE and TCIE interrupts */
;;;1803     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1804     CLEAR_BIT(husart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE | USART_CR1_RXNEIE | USART_CR1_PEIE));
000002  6809              LDR      r1,[r1,#0]
000004  22ff              MOVS     r2,#0xff
000006  32e1              ADDS     r2,r2,#0xe1
000008  4391              BICS     r1,r1,r2
00000a  6802              LDR      r2,[r0,#0]
00000c  6011              STR      r1,[r2,#0]
;;;1805     CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
00000e  6801              LDR      r1,[r0,#0]
000010  6889              LDR      r1,[r1,#8]
000012  0849              LSRS     r1,r1,#1
000014  0049              LSLS     r1,r1,#1
000016  6802              LDR      r2,[r0,#0]
000018  6091              STR      r1,[r2,#8]
;;;1806   
;;;1807     /* At end of process, restore husart->State to Ready */
;;;1808     husart->State = HAL_USART_STATE_READY;
00001a  2101              MOVS     r1,#1
00001c  6441              STR      r1,[r0,#0x44]
;;;1809   }
00001e  4770              BX       lr
;;;1810   
                          ENDP


                          AREA ||i.USART_EndTransmit_IT||, CODE, READONLY, ALIGN=1

                  USART_EndTransmit_IT PROC
;;;2254     */
;;;2255   static HAL_StatusTypeDef USART_EndTransmit_IT(USART_HandleTypeDef *husart)
000000  b510              PUSH     {r4,lr}
;;;2256   {
000002  4604              MOV      r4,r0
;;;2257     /* Disable the USART Transmit Complete Interrupt */
;;;2258     __HAL_USART_DISABLE_IT(husart, USART_IT_TC);
000004  6820              LDR      r0,[r4,#0]
000006  6800              LDR      r0,[r0,#0]
000008  2140              MOVS     r1,#0x40
00000a  4388              BICS     r0,r0,r1
00000c  6821              LDR      r1,[r4,#0]
00000e  6008              STR      r0,[r1,#0]
;;;2259   
;;;2260     /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;2261     __HAL_USART_DISABLE_IT(husart, USART_IT_ERR);
000010  6820              LDR      r0,[r4,#0]
000012  6880              LDR      r0,[r0,#8]
000014  0840              LSRS     r0,r0,#1
000016  0040              LSLS     r0,r0,#1
000018  6821              LDR      r1,[r4,#0]
00001a  6088              STR      r0,[r1,#8]
;;;2262   
;;;2263     /* Tx process is ended, restore husart->State to Ready */
;;;2264     husart->State = HAL_USART_STATE_READY;
00001c  2001              MOVS     r0,#1
00001e  6460              STR      r0,[r4,#0x44]
;;;2265   
;;;2266     HAL_USART_TxCpltCallback(husart);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       HAL_USART_TxCpltCallback
;;;2267   
;;;2268     return HAL_OK;
000026  2000              MOVS     r0,#0
;;;2269   }
000028  bd10              POP      {r4,pc}
;;;2270   
                          ENDP


                          AREA ||i.USART_Receive_IT||, CODE, READONLY, ALIGN=1

                  USART_Receive_IT PROC
;;;2278     */
;;;2279   static HAL_StatusTypeDef USART_Receive_IT(USART_HandleTypeDef *husart)
000000  b570              PUSH     {r4-r6,lr}
;;;2280   {
000002  4604              MOV      r4,r0
;;;2281     uint16_t* tmp;
;;;2282     uint16_t uhMask = husart->Mask;
000004  8ea6              LDRH     r6,[r4,#0x34]
;;;2283   
;;;2284     if(husart->State == HAL_USART_STATE_BUSY_RX)
000006  6c60              LDR      r0,[r4,#0x44]
000008  2822              CMP      r0,#0x22
00000a  d137              BNE      |L40.124|
;;;2285     {
;;;2286   
;;;2287       if((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
00000c  2101              MOVS     r1,#1
00000e  0309              LSLS     r1,r1,#12
000010  68a0              LDR      r0,[r4,#8]
000012  4288              CMP      r0,r1
000014  d10b              BNE      |L40.46|
000016  6920              LDR      r0,[r4,#0x10]
000018  2800              CMP      r0,#0
00001a  d108              BNE      |L40.46|
;;;2288       {
;;;2289         tmp = (uint16_t*) husart->pRxBuffPtr;
00001c  6ae5              LDR      r5,[r4,#0x2c]
;;;2290         *tmp = (uint16_t)(husart->Instance->RDR & uhMask);
00001e  6820              LDR      r0,[r4,#0]
000020  6a40              LDR      r0,[r0,#0x24]
000022  4030              ANDS     r0,r0,r6
000024  8028              STRH     r0,[r5,#0]
;;;2291         husart->pRxBuffPtr += 2U;
000026  6ae0              LDR      r0,[r4,#0x2c]
000028  1c80              ADDS     r0,r0,#2
00002a  62e0              STR      r0,[r4,#0x2c]
00002c  e007              B        |L40.62|
                  |L40.46|
;;;2292       }
;;;2293       else
;;;2294       {
;;;2295         *husart->pRxBuffPtr++ = (uint8_t)(husart->Instance->RDR & (uint8_t)uhMask);
00002e  6820              LDR      r0,[r4,#0]
000030  6a40              LDR      r0,[r0,#0x24]
000032  b2f1              UXTB     r1,r6
000034  4008              ANDS     r0,r0,r1
000036  6ae2              LDR      r2,[r4,#0x2c]
000038  1c51              ADDS     r1,r2,#1
00003a  62e1              STR      r1,[r4,#0x2c]
00003c  7010              STRB     r0,[r2,#0]
                  |L40.62|
;;;2296       }
;;;2297       /* Send dummy byte in order to generate the clock for the Slave to Send the next data */
;;;2298       husart->Instance->TDR = (USART_DUMMY_DATA & (uint16_t)0x00FFU);
00003e  20ff              MOVS     r0,#0xff
000040  6821              LDR      r1,[r4,#0]
000042  6288              STR      r0,[r1,#0x28]
;;;2299   
;;;2300       if(--husart->RxXferCount == 0U)
000044  8e60              LDRH     r0,[r4,#0x32]
000046  1e40              SUBS     r0,r0,#1
000048  b280              UXTH     r0,r0
00004a  8660              STRH     r0,[r4,#0x32]
00004c  2800              CMP      r0,#0
00004e  d113              BNE      |L40.120|
;;;2301       {
;;;2302         /* Disable the USART Parity Error Interrupt and RXNE interrupt*/
;;;2303         CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000050  6820              LDR      r0,[r4,#0]
000052  6800              LDR      r0,[r0,#0]
000054  21ff              MOVS     r1,#0xff
000056  3121              ADDS     r1,r1,#0x21
000058  4388              BICS     r0,r0,r1
00005a  6821              LDR      r1,[r4,#0]
00005c  6008              STR      r0,[r1,#0]
;;;2304   
;;;2305         /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;2306         CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
00005e  6820              LDR      r0,[r4,#0]
000060  6880              LDR      r0,[r0,#8]
000062  0840              LSRS     r0,r0,#1
000064  0040              LSLS     r0,r0,#1
000066  6821              LDR      r1,[r4,#0]
000068  6088              STR      r0,[r1,#8]
;;;2307   
;;;2308         /* Rx process is completed, restore husart->State to Ready */
;;;2309         husart->State = HAL_USART_STATE_READY;
00006a  2001              MOVS     r0,#1
00006c  6460              STR      r0,[r4,#0x44]
;;;2310   
;;;2311         HAL_USART_RxCpltCallback(husart);
00006e  4620              MOV      r0,r4
000070  f7fffffe          BL       HAL_USART_RxCpltCallback
;;;2312   
;;;2313         return HAL_OK;
000074  2000              MOVS     r0,#0
                  |L40.118|
;;;2314       }
;;;2315   
;;;2316       return HAL_OK;
;;;2317     }
;;;2318     else
;;;2319     {
;;;2320       return HAL_BUSY;
;;;2321     }
;;;2322   }
000076  bd70              POP      {r4-r6,pc}
                  |L40.120|
000078  2000              MOVS     r0,#0                 ;2316
00007a  e7fc              B        |L40.118|
                  |L40.124|
00007c  2002              MOVS     r0,#2                 ;2320
00007e  e7fa              B        |L40.118|
;;;2323   
                          ENDP


                          AREA ||i.USART_SetConfig||, CODE, READONLY, ALIGN=2

                  USART_SetConfig PROC
;;;2076     */
;;;2077   static HAL_StatusTypeDef USART_SetConfig(USART_HandleTypeDef *husart)
000000  b5fe              PUSH     {r1-r7,lr}
;;;2078   {
000002  4604              MOV      r4,r0
;;;2079     uint32_t tmpreg                      = 0x0U;
000004  2500              MOVS     r5,#0
;;;2080     USART_ClockSourceTypeDef clocksource = USART_CLOCKSOURCE_UNDEFINED;
000006  2010              MOVS     r0,#0x10
000008  9002              STR      r0,[sp,#8]
;;;2081     HAL_StatusTypeDef ret                = HAL_OK;
00000a  2000              MOVS     r0,#0
00000c  9001              STR      r0,[sp,#4]
;;;2082     uint16_t brrtemp                     = 0x0000U;
00000e  2600              MOVS     r6,#0
;;;2083     uint16_t usartdiv                    = 0x0000U;
000010  2700              MOVS     r7,#0
;;;2084   
;;;2085     /* Check the parameters */
;;;2086     assert_param(IS_USART_INSTANCE(husart->Instance));
;;;2087     assert_param(IS_USART_POLARITY(husart->Init.CLKPolarity));
;;;2088     assert_param(IS_USART_PHASE(husart->Init.CLKPhase));
;;;2089     assert_param(IS_USART_LASTBIT(husart->Init.CLKLastBit));
;;;2090     assert_param(IS_USART_BAUDRATE(husart->Init.BaudRate));
;;;2091     assert_param(IS_USART_WORD_LENGTH(husart->Init.WordLength));
;;;2092     assert_param(IS_USART_STOPBITS(husart->Init.StopBits));
;;;2093     assert_param(IS_USART_PARITY(husart->Init.Parity));
;;;2094     assert_param(IS_USART_MODE(husart->Init.Mode));
;;;2095   
;;;2096   
;;;2097     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;2098      /* Clear M, PCE, PS, TE and RE bits and configure
;;;2099      *  the USART Word Length, Parity and Mode:
;;;2100      *  set the M bits according to husart->Init.WordLength value
;;;2101      *  set PCE and PS bits according to husart->Init.Parity value
;;;2102      *  set TE and RE bits according to husart->Init.Mode value 
;;;2103      *  force OVER8 to 1 to allow to reach the maximum speed (Fclock/8)  */
;;;2104     tmpreg = (uint32_t)husart->Init.WordLength | husart->Init.Parity | husart->Init.Mode | USART_CR1_OVER8;
000012  6921              LDR      r1,[r4,#0x10]
000014  68a0              LDR      r0,[r4,#8]
000016  4308              ORRS     r0,r0,r1
000018  6961              LDR      r1,[r4,#0x14]
00001a  4308              ORRS     r0,r0,r1
00001c  2101              MOVS     r1,#1
00001e  03c9              LSLS     r1,r1,#15
000020  4308              ORRS     r0,r0,r1
000022  4605              MOV      r5,r0
;;;2105     MODIFY_REG(husart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
000024  6820              LDR      r0,[r4,#0]
000026  6800              LDR      r0,[r0,#0]
000028  4957              LDR      r1,|L41.392|
00002a  4008              ANDS     r0,r0,r1
00002c  4328              ORRS     r0,r0,r5
00002e  6821              LDR      r1,[r4,#0]
000030  6008              STR      r0,[r1,#0]
;;;2106   
;;;2107     /*---------------------------- USART CR2 Configuration ---------------------*/
;;;2108     /* Clear and configure the USART Clock, CPOL, CPHA, LBCL and STOP bits:
;;;2109      * set CPOL bit according to husart->Init.CLKPolarity value
;;;2110      * set CPHA bit according to husart->Init.CLKPhase value
;;;2111      * set LBCL bit according to husart->Init.CLKLastBit value
;;;2112      * set STOP[13:12] bits according to husart->Init.StopBits value */
;;;2113     tmpreg = (uint32_t)(USART_CLOCK_ENABLE);
000032  2501              MOVS     r5,#1
000034  02ed              LSLS     r5,r5,#11
;;;2114     tmpreg |= ((uint32_t)husart->Init.CLKPolarity | (uint32_t)husart->Init.CLKPhase);
000036  69e1              LDR      r1,[r4,#0x1c]
000038  69a0              LDR      r0,[r4,#0x18]
00003a  4308              ORRS     r0,r0,r1
00003c  4305              ORRS     r5,r5,r0
;;;2115     tmpreg |= ((uint32_t)husart->Init.CLKLastBit | (uint32_t)husart->Init.StopBits);
00003e  68e1              LDR      r1,[r4,#0xc]
000040  6a20              LDR      r0,[r4,#0x20]
000042  4308              ORRS     r0,r0,r1
000044  4305              ORRS     r5,r5,r0
;;;2116     MODIFY_REG(husart->Instance->CR2, USART_CR2_FIELDS, tmpreg);
000046  6820              LDR      r0,[r4,#0]
000048  6840              LDR      r0,[r0,#4]
00004a  213f              MOVS     r1,#0x3f
00004c  0209              LSLS     r1,r1,#8
00004e  4388              BICS     r0,r0,r1
000050  4328              ORRS     r0,r0,r5
000052  6821              LDR      r1,[r4,#0]
000054  6048              STR      r0,[r1,#4]
;;;2117   
;;;2118     /*-------------------------- USART CR3 Configuration -----------------------*/
;;;2119     /* no CR3 register configuration                                            */
;;;2120   
;;;2121     /*-------------------------- USART BRR Configuration -----------------------*/
;;;2122     /* BRR is filled-up according to OVER8 bit setting which is forced to 1     */ 
;;;2123     USART_GETCLOCKSOURCE(husart, clocksource);
000056  bf00              NOP      
000058  494c              LDR      r1,|L41.396|
00005a  6820              LDR      r0,[r4,#0]
00005c  4288              CMP      r0,r1
00005e  d11c              BNE      |L41.154|
000060  484b              LDR      r0,|L41.400|
000062  68c0              LDR      r0,[r0,#0xc]
000064  0780              LSLS     r0,r0,#30
000066  0f80              LSRS     r0,r0,#30
000068  2800              CMP      r0,#0
00006a  d006              BEQ      |L41.122|
00006c  2801              CMP      r0,#1
00006e  d00a              BEQ      |L41.134|
000070  2802              CMP      r0,#2
000072  d005              BEQ      |L41.128|
000074  2803              CMP      r0,#3
000076  d10c              BNE      |L41.146|
000078  e008              B        |L41.140|
                  |L41.122|
00007a  2001              MOVS     r0,#1
00007c  9002              STR      r0,[sp,#8]
00007e  e00b              B        |L41.152|
                  |L41.128|
000080  2002              MOVS     r0,#2
000082  9002              STR      r0,[sp,#8]
000084  e008              B        |L41.152|
                  |L41.134|
000086  2004              MOVS     r0,#4
000088  9002              STR      r0,[sp,#8]
00008a  e005              B        |L41.152|
                  |L41.140|
00008c  2008              MOVS     r0,#8
00008e  9002              STR      r0,[sp,#8]
000090  e002              B        |L41.152|
                  |L41.146|
000092  2010              MOVS     r0,#0x10
000094  9002              STR      r0,[sp,#8]
000096  bf00              NOP      
                  |L41.152|
000098  e020              B        |L41.220|
                  |L41.154|
00009a  493e              LDR      r1,|L41.404|
00009c  6820              LDR      r0,[r4,#0]
00009e  4288              CMP      r0,r1
0000a0  d11c              BNE      |L41.220|
0000a2  483b              LDR      r0,|L41.400|
0000a4  68c0              LDR      r0,[r0,#0xc]
0000a6  210c              MOVS     r1,#0xc
0000a8  4008              ANDS     r0,r0,r1
0000aa  2800              CMP      r0,#0
0000ac  d006              BEQ      |L41.188|
0000ae  2804              CMP      r0,#4
0000b0  d00a              BEQ      |L41.200|
0000b2  2808              CMP      r0,#8
0000b4  d005              BEQ      |L41.194|
0000b6  280c              CMP      r0,#0xc
0000b8  d10c              BNE      |L41.212|
0000ba  e008              B        |L41.206|
                  |L41.188|
0000bc  2000              MOVS     r0,#0
0000be  9002              STR      r0,[sp,#8]
0000c0  e00b              B        |L41.218|
                  |L41.194|
0000c2  2002              MOVS     r0,#2
0000c4  9002              STR      r0,[sp,#8]
0000c6  e008              B        |L41.218|
                  |L41.200|
0000c8  2004              MOVS     r0,#4
0000ca  9002              STR      r0,[sp,#8]
0000cc  e005              B        |L41.218|
                  |L41.206|
0000ce  2008              MOVS     r0,#8
0000d0  9002              STR      r0,[sp,#8]
0000d2  e002              B        |L41.218|
                  |L41.212|
0000d4  2010              MOVS     r0,#0x10
0000d6  9002              STR      r0,[sp,#8]
0000d8  bf00              NOP      
                  |L41.218|
0000da  bf00              NOP      
                  |L41.220|
0000dc  bf00              NOP      
;;;2124     switch (clocksource)
0000de  9802              LDR      r0,[sp,#8]
0000e0  2804              CMP      r0,#4
0000e2  d02c              BEQ      |L41.318|
0000e4  dc06              BGT      |L41.244|
0000e6  2800              CMP      r0,#0
0000e8  d009              BEQ      |L41.254|
0000ea  2801              CMP      r0,#1
0000ec  d013              BEQ      |L41.278|
0000ee  2802              CMP      r0,#2
0000f0  d13a              BNE      |L41.360|
0000f2  e01c              B        |L41.302|
                  |L41.244|
0000f4  2808              CMP      r0,#8
0000f6  d02e              BEQ      |L41.342|
0000f8  2810              CMP      r0,#0x10
0000fa  d135              BNE      |L41.360|
0000fc  e035              B        |L41.362|
                  |L41.254|
;;;2125     {
;;;2126       case USART_CLOCKSOURCE_PCLK1:
;;;2127         usartdiv = (uint16_t)(((2U*HAL_RCC_GetPCLK1Freq()) + (husart->Init.BaudRate/2U)) / husart->Init.BaudRate);
0000fe  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000102  0040              LSLS     r0,r0,#1
000104  6861              LDR      r1,[r4,#4]
000106  0849              LSRS     r1,r1,#1
000108  1840              ADDS     r0,r0,r1
00010a  9000              STR      r0,[sp,#0]
00010c  6861              LDR      r1,[r4,#4]
00010e  f7fffffe          BL       __aeabi_uidivmod
000112  b287              UXTH     r7,r0
;;;2128         break;
000114  e02c              B        |L41.368|
                  |L41.278|
;;;2129       case USART_CLOCKSOURCE_PCLK2:
;;;2130         usartdiv = (uint16_t)(((2U*HAL_RCC_GetPCLK2Freq()) + (husart->Init.BaudRate/2U)) / husart->Init.BaudRate);
000116  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00011a  0040              LSLS     r0,r0,#1
00011c  6861              LDR      r1,[r4,#4]
00011e  0849              LSRS     r1,r1,#1
000120  1840              ADDS     r0,r0,r1
000122  9000              STR      r0,[sp,#0]
000124  6861              LDR      r1,[r4,#4]
000126  f7fffffe          BL       __aeabi_uidivmod
00012a  b287              UXTH     r7,r0
;;;2131         break;
00012c  e020              B        |L41.368|
                  |L41.302|
;;;2132       case USART_CLOCKSOURCE_HSI:
;;;2133         usartdiv = (uint16_t)(((2U*HSI_VALUE) + (husart->Init.BaudRate/2U)) / husart->Init.BaudRate);
00012e  6861              LDR      r1,[r4,#4]
000130  084a              LSRS     r2,r1,#1
000132  4b19              LDR      r3,|L41.408|
000134  18d0              ADDS     r0,r2,r3
000136  f7fffffe          BL       __aeabi_uidivmod
00013a  b287              UXTH     r7,r0
;;;2134         break;
00013c  e018              B        |L41.368|
                  |L41.318|
;;;2135       case USART_CLOCKSOURCE_SYSCLK:
;;;2136         usartdiv = (uint16_t)(((2U*HAL_RCC_GetSysClockFreq()) + (husart->Init.BaudRate/2U)) / husart->Init.BaudRate);
00013e  f7fffffe          BL       HAL_RCC_GetSysClockFreq
000142  0040              LSLS     r0,r0,#1
000144  6861              LDR      r1,[r4,#4]
000146  0849              LSRS     r1,r1,#1
000148  1840              ADDS     r0,r0,r1
00014a  9000              STR      r0,[sp,#0]
00014c  6861              LDR      r1,[r4,#4]
00014e  f7fffffe          BL       __aeabi_uidivmod
000152  b287              UXTH     r7,r0
;;;2137         break;
000154  e00c              B        |L41.368|
                  |L41.342|
;;;2138       case USART_CLOCKSOURCE_LSE:
;;;2139         usartdiv = (uint16_t)(((2U*LSE_VALUE) + (husart->Init.BaudRate/2U)) / husart->Init.BaudRate);
000156  6861              LDR      r1,[r4,#4]
000158  084a              LSRS     r2,r1,#1
00015a  2301              MOVS     r3,#1
00015c  041b              LSLS     r3,r3,#16
00015e  18d0              ADDS     r0,r2,r3
000160  f7fffffe          BL       __aeabi_uidivmod
000164  b287              UXTH     r7,r0
;;;2140         break;
000166  e003              B        |L41.368|
                  |L41.360|
;;;2141       case USART_CLOCKSOURCE_UNDEFINED:
000168  bf00              NOP      
                  |L41.362|
;;;2142       default:
;;;2143         ret = HAL_ERROR;
00016a  2001              MOVS     r0,#1
00016c  9001              STR      r0,[sp,#4]
;;;2144         break;
00016e  bf00              NOP      
                  |L41.368|
000170  bf00              NOP                            ;2128
;;;2145     }
;;;2146     
;;;2147     brrtemp = usartdiv & 0xFFF0U;
000172  480a              LDR      r0,|L41.412|
000174  4038              ANDS     r0,r0,r7
000176  4606              MOV      r6,r0
;;;2148     brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
000178  0738              LSLS     r0,r7,#28
00017a  0f40              LSRS     r0,r0,#29
00017c  4306              ORRS     r6,r6,r0
;;;2149     husart->Instance->BRR = brrtemp;
00017e  6820              LDR      r0,[r4,#0]
000180  60c6              STR      r6,[r0,#0xc]
;;;2150   
;;;2151     return ret;
000182  9801              LDR      r0,[sp,#4]
;;;2152   }
000184  bdfe              POP      {r1-r7,pc}
;;;2153   
                          ENDP

000186  0000              DCW      0x0000
                  |L41.392|
                          DCD      0xefff69f3
                  |L41.396|
                          DCD      0x40013800
                  |L41.400|
                          DCD      0x40021040
                  |L41.404|
                          DCD      0x40004400
                  |L41.408|
                          DCD      0x01e84800
                  |L41.412|
                          DCD      0x0000fff0

                          AREA ||i.USART_TransmitReceive_IT||, CODE, READONLY, ALIGN=1

                  USART_TransmitReceive_IT PROC
;;;2330     */
;;;2331   static HAL_StatusTypeDef USART_TransmitReceive_IT(USART_HandleTypeDef *husart)
000000  b570              PUSH     {r4-r6,lr}
;;;2332   {
000002  4604              MOV      r4,r0
;;;2333     uint16_t* tmp;
;;;2334     uint16_t uhMask = husart->Mask;
000004  8ea5              LDRH     r5,[r4,#0x34]
;;;2335   
;;;2336     if(husart->State == HAL_USART_STATE_BUSY_TX_RX)
000006  6c60              LDR      r0,[r4,#0x44]
000008  2832              CMP      r0,#0x32
00000a  d16a              BNE      |L42.226|
;;;2337     {
;;;2338   
;;;2339       if(husart->TxXferCount != 0x00U)
00000c  8d60              LDRH     r0,[r4,#0x2a]
00000e  2800              CMP      r0,#0
000010  d029              BEQ      |L42.102|
;;;2340       {
;;;2341         if(__HAL_USART_GET_FLAG(husart, USART_FLAG_TXE) != RESET)
000012  6820              LDR      r0,[r4,#0]
000014  69c0              LDR      r0,[r0,#0x1c]
000016  2180              MOVS     r1,#0x80
000018  4008              ANDS     r0,r0,r1
00001a  09c0              LSRS     r0,r0,#7
00001c  2800              CMP      r0,#0
00001e  d022              BEQ      |L42.102|
;;;2342         {
;;;2343           if((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
000020  0149              LSLS     r1,r1,#5
000022  68a0              LDR      r0,[r4,#8]
000024  4288              CMP      r0,r1
000026  d10b              BNE      |L42.64|
000028  6920              LDR      r0,[r4,#0x10]
00002a  2800              CMP      r0,#0
00002c  d108              BNE      |L42.64|
;;;2344           {
;;;2345             tmp = (uint16_t*) husart->pTxBuffPtr;
00002e  6a66              LDR      r6,[r4,#0x24]
;;;2346             husart->Instance->TDR = (uint16_t)(*tmp & uhMask);
000030  8830              LDRH     r0,[r6,#0]
000032  4028              ANDS     r0,r0,r5
000034  6821              LDR      r1,[r4,#0]
000036  6288              STR      r0,[r1,#0x28]
;;;2347             husart->pTxBuffPtr += 2U;
000038  6a60              LDR      r0,[r4,#0x24]
00003a  1c80              ADDS     r0,r0,#2
00003c  6260              STR      r0,[r4,#0x24]
00003e  e006              B        |L42.78|
                  |L42.64|
;;;2348           }
;;;2349           else
;;;2350           {
;;;2351             husart->Instance->TDR = (uint8_t)(*husart->pTxBuffPtr++ & (uint8_t)uhMask);
000040  6a61              LDR      r1,[r4,#0x24]
000042  1c48              ADDS     r0,r1,#1
000044  6260              STR      r0,[r4,#0x24]
000046  7808              LDRB     r0,[r1,#0]
000048  4028              ANDS     r0,r0,r5
00004a  6821              LDR      r1,[r4,#0]
00004c  6288              STR      r0,[r1,#0x28]
                  |L42.78|
;;;2352           }
;;;2353           husart->TxXferCount--;
00004e  8d60              LDRH     r0,[r4,#0x2a]
000050  1e40              SUBS     r0,r0,#1
000052  8560              STRH     r0,[r4,#0x2a]
;;;2354   
;;;2355           /* Check the latest data transmitted */
;;;2356           if(husart->TxXferCount == 0U)
000054  8d60              LDRH     r0,[r4,#0x2a]
000056  2800              CMP      r0,#0
000058  d105              BNE      |L42.102|
;;;2357           {
;;;2358              __HAL_USART_DISABLE_IT(husart, USART_IT_TXE);
00005a  6820              LDR      r0,[r4,#0]
00005c  6800              LDR      r0,[r0,#0]
00005e  2180              MOVS     r1,#0x80
000060  4388              BICS     r0,r0,r1
000062  6821              LDR      r1,[r4,#0]
000064  6008              STR      r0,[r1,#0]
                  |L42.102|
;;;2359           }
;;;2360         }
;;;2361       }
;;;2362   
;;;2363       if(husart->RxXferCount != 0x00U)
000066  8e60              LDRH     r0,[r4,#0x32]
000068  2800              CMP      r0,#0
00006a  d021              BEQ      |L42.176|
;;;2364       {
;;;2365         if(__HAL_USART_GET_FLAG(husart, USART_FLAG_RXNE) != RESET)
00006c  6820              LDR      r0,[r4,#0]
00006e  69c0              LDR      r0,[r0,#0x1c]
000070  2120              MOVS     r1,#0x20
000072  4008              ANDS     r0,r0,r1
000074  0940              LSRS     r0,r0,#5
000076  2800              CMP      r0,#0
000078  d01a              BEQ      |L42.176|
;;;2366         {
;;;2367           if((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
00007a  01c9              LSLS     r1,r1,#7
00007c  68a0              LDR      r0,[r4,#8]
00007e  4288              CMP      r0,r1
000080  d10b              BNE      |L42.154|
000082  6920              LDR      r0,[r4,#0x10]
000084  2800              CMP      r0,#0
000086  d108              BNE      |L42.154|
;;;2368           {
;;;2369             tmp = (uint16_t*) husart->pRxBuffPtr;
000088  6ae6              LDR      r6,[r4,#0x2c]
;;;2370             *tmp = (uint16_t)(husart->Instance->RDR & uhMask);
00008a  6820              LDR      r0,[r4,#0]
00008c  6a40              LDR      r0,[r0,#0x24]
00008e  4028              ANDS     r0,r0,r5
000090  8030              STRH     r0,[r6,#0]
;;;2371             husart->pRxBuffPtr += 2U;
000092  6ae0              LDR      r0,[r4,#0x2c]
000094  1c80              ADDS     r0,r0,#2
000096  62e0              STR      r0,[r4,#0x2c]
000098  e007              B        |L42.170|
                  |L42.154|
;;;2372           }
;;;2373           else
;;;2374           {
;;;2375             *husart->pRxBuffPtr++ = (uint8_t)(husart->Instance->RDR & (uint8_t)uhMask);
00009a  6820              LDR      r0,[r4,#0]
00009c  6a40              LDR      r0,[r0,#0x24]
00009e  b2e9              UXTB     r1,r5
0000a0  4008              ANDS     r0,r0,r1
0000a2  6ae2              LDR      r2,[r4,#0x2c]
0000a4  1c51              ADDS     r1,r2,#1
0000a6  62e1              STR      r1,[r4,#0x2c]
0000a8  7010              STRB     r0,[r2,#0]
                  |L42.170|
;;;2376           }
;;;2377           husart->RxXferCount--;
0000aa  8e60              LDRH     r0,[r4,#0x32]
0000ac  1e40              SUBS     r0,r0,#1
0000ae  8660              STRH     r0,[r4,#0x32]
                  |L42.176|
;;;2378         }
;;;2379       }
;;;2380   
;;;2381       /* Check the latest data received */
;;;2382       if(husart->RxXferCount == 0U)
0000b0  8e60              LDRH     r0,[r4,#0x32]
0000b2  2800              CMP      r0,#0
0000b4  d113              BNE      |L42.222|
;;;2383       {
;;;2384         /* Disable the USART Parity Error Interrupt and RXNE interrupt*/
;;;2385         CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
0000b6  6820              LDR      r0,[r4,#0]
0000b8  6800              LDR      r0,[r0,#0]
0000ba  21ff              MOVS     r1,#0xff
0000bc  3121              ADDS     r1,r1,#0x21
0000be  4388              BICS     r0,r0,r1
0000c0  6821              LDR      r1,[r4,#0]
0000c2  6008              STR      r0,[r1,#0]
;;;2386   
;;;2387         /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;2388         CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
0000c4  6820              LDR      r0,[r4,#0]
0000c6  6880              LDR      r0,[r0,#8]
0000c8  0840              LSRS     r0,r0,#1
0000ca  0040              LSLS     r0,r0,#1
0000cc  6821              LDR      r1,[r4,#0]
0000ce  6088              STR      r0,[r1,#8]
;;;2389   
;;;2390         /* Rx process is completed, restore husart->State to Ready */
;;;2391         husart->State = HAL_USART_STATE_READY;
0000d0  2001              MOVS     r0,#1
0000d2  6460              STR      r0,[r4,#0x44]
;;;2392   
;;;2393         HAL_USART_TxRxCpltCallback(husart);
0000d4  4620              MOV      r0,r4
0000d6  f7fffffe          BL       HAL_USART_TxRxCpltCallback
;;;2394   
;;;2395         return HAL_OK;
0000da  2000              MOVS     r0,#0
                  |L42.220|
;;;2396       }
;;;2397   
;;;2398       return HAL_OK;
;;;2399     }
;;;2400     else
;;;2401     {
;;;2402       return HAL_BUSY;
;;;2403     }
;;;2404   }
0000dc  bd70              POP      {r4-r6,pc}
                  |L42.222|
0000de  2000              MOVS     r0,#0                 ;2398
0000e0  e7fc              B        |L42.220|
                  |L42.226|
0000e2  2002              MOVS     r0,#2                 ;2402
0000e4  e7fa              B        |L42.220|
;;;2405   
                          ENDP


                          AREA ||i.USART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  USART_Transmit_IT PROC
;;;2206     */
;;;2207   static HAL_StatusTypeDef USART_Transmit_IT(USART_HandleTypeDef *husart)
000000  4601              MOV      r1,r0
;;;2208   {
;;;2209     uint16_t* tmp = 0U;
000002  2200              MOVS     r2,#0
;;;2210   
;;;2211     /* Check that a Tx process is ongoing */
;;;2212     if(husart->State == HAL_USART_STATE_BUSY_TX)
000004  6c48              LDR      r0,[r1,#0x44]
000006  2812              CMP      r0,#0x12
000008  d12d              BNE      |L43.102|
;;;2213     {
;;;2214       if(husart->TxXferCount == 0U)
00000a  8d48              LDRH     r0,[r1,#0x2a]
00000c  2800              CMP      r0,#0
00000e  d10d              BNE      |L43.44|
;;;2215       {
;;;2216         /* Disable the USART Transmit data register empty interrupt */
;;;2217         __HAL_USART_DISABLE_IT(husart, USART_IT_TXE);
000010  6808              LDR      r0,[r1,#0]
000012  6800              LDR      r0,[r0,#0]
000014  2380              MOVS     r3,#0x80
000016  4398              BICS     r0,r0,r3
000018  680b              LDR      r3,[r1,#0]
00001a  6018              STR      r0,[r3,#0]
;;;2218   
;;;2219         /* Enable the USART Transmit Complete Interrupt */
;;;2220         __HAL_USART_ENABLE_IT(husart, USART_IT_TC);
00001c  6808              LDR      r0,[r1,#0]
00001e  6800              LDR      r0,[r0,#0]
000020  2340              MOVS     r3,#0x40
000022  4318              ORRS     r0,r0,r3
000024  680b              LDR      r3,[r1,#0]
000026  6018              STR      r0,[r3,#0]
;;;2221   
;;;2222         return HAL_OK;
000028  2000              MOVS     r0,#0
                  |L43.42|
;;;2223       }
;;;2224       else
;;;2225       {
;;;2226         if((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;2227         {
;;;2228           tmp = (uint16_t*) husart->pTxBuffPtr;
;;;2229           husart->Instance->TDR = (*tmp & (uint16_t)0x01FFU);
;;;2230           husart->pTxBuffPtr += 2U;
;;;2231         }
;;;2232         else
;;;2233         {
;;;2234           husart->Instance->TDR = (uint8_t)(*husart->pTxBuffPtr++ & (uint8_t)0xFFU);
;;;2235         }
;;;2236   
;;;2237         husart->TxXferCount--;
;;;2238   
;;;2239         return HAL_OK;
;;;2240       }
;;;2241     }
;;;2242     else
;;;2243     {
;;;2244       return HAL_BUSY;
;;;2245     }
;;;2246   }
00002a  4770              BX       lr
                  |L43.44|
00002c  2301              MOVS     r3,#1                 ;2226
00002e  031b              LSLS     r3,r3,#12             ;2226
000030  6888              LDR      r0,[r1,#8]            ;2226
000032  4298              CMP      r0,r3                 ;2226
000034  d10c              BNE      |L43.80|
000036  6908              LDR      r0,[r1,#0x10]         ;2226
000038  2800              CMP      r0,#0                 ;2226
00003a  d109              BNE      |L43.80|
00003c  6a4a              LDR      r2,[r1,#0x24]         ;2228
00003e  8810              LDRH     r0,[r2,#0]            ;2229
000040  05c0              LSLS     r0,r0,#23             ;2229
000042  0dc0              LSRS     r0,r0,#23             ;2229
000044  680b              LDR      r3,[r1,#0]            ;2229
000046  6298              STR      r0,[r3,#0x28]         ;2229
000048  6a48              LDR      r0,[r1,#0x24]         ;2230
00004a  1c80              ADDS     r0,r0,#2              ;2230
00004c  6248              STR      r0,[r1,#0x24]         ;2230
00004e  e005              B        |L43.92|
                  |L43.80|
000050  6a4b              LDR      r3,[r1,#0x24]         ;2234
000052  1c58              ADDS     r0,r3,#1              ;2234
000054  6248              STR      r0,[r1,#0x24]         ;2234
000056  7818              LDRB     r0,[r3,#0]            ;2234
000058  680b              LDR      r3,[r1,#0]            ;2234
00005a  6298              STR      r0,[r3,#0x28]         ;2234
                  |L43.92|
00005c  8d48              LDRH     r0,[r1,#0x2a]         ;2237
00005e  1e40              SUBS     r0,r0,#1              ;2237
000060  8548              STRH     r0,[r1,#0x2a]         ;2237
000062  2000              MOVS     r0,#0                 ;2239
000064  e7e1              B        |L43.42|
                  |L43.102|
000066  2002              MOVS     r0,#2                 ;2244
000068  e7df              B        |L43.42|
;;;2247   
                          ENDP


                          AREA ||i.USART_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  USART_WaitOnFlagUntilTimeout PROC
;;;2045     */
;;;2046   static HAL_StatusTypeDef USART_WaitOnFlagUntilTimeout(USART_HandleTypeDef *husart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
000000  b5ff              PUSH     {r0-r7,lr}
;;;2047   {
000002  b081              SUB      sp,sp,#4
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  9e0a              LDR      r6,[sp,#0x28]
;;;2048     /* Wait until flag is set */
;;;2049     while((__HAL_USART_GET_FLAG(husart, Flag) ? SET : RESET) == Status)
00000c  e020              B        |L44.80|
                  |L44.14|
;;;2050     {
;;;2051       /* Check for the Timeout */
;;;2052       if(Timeout != HAL_MAX_DELAY)
00000e  1c70              ADDS     r0,r6,#1
000010  2800              CMP      r0,#0
000012  d01d              BEQ      |L44.80|
;;;2053       {
;;;2054         if((Timeout == 0) || ((HAL_GetTick()-Tickstart) > Timeout))
000014  2e00              CMP      r6,#0
000016  d005              BEQ      |L44.36|
000018  f7fffffe          BL       HAL_GetTick
00001c  9904              LDR      r1,[sp,#0x10]
00001e  1a40              SUBS     r0,r0,r1
000020  42b0              CMP      r0,r6
000022  d915              BLS      |L44.80|
                  |L44.36|
;;;2055         {
;;;2056           /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;2057           CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
000024  6820              LDR      r0,[r4,#0]
000026  6800              LDR      r0,[r0,#0]
000028  21ff              MOVS     r1,#0xff
00002a  31a1              ADDS     r1,r1,#0xa1
00002c  4388              BICS     r0,r0,r1
00002e  6821              LDR      r1,[r4,#0]
000030  6008              STR      r0,[r1,#0]
;;;2058           CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
000032  6820              LDR      r0,[r4,#0]
000034  6880              LDR      r0,[r0,#8]
000036  0840              LSRS     r0,r0,#1
000038  0040              LSLS     r0,r0,#1
00003a  6821              LDR      r1,[r4,#0]
00003c  6088              STR      r0,[r1,#8]
;;;2059   
;;;2060           husart->State= HAL_USART_STATE_READY;
00003e  2001              MOVS     r0,#1
000040  6460              STR      r0,[r4,#0x44]
;;;2061   
;;;2062           /* Process Unlocked */
;;;2063           __HAL_UNLOCK(husart);
000042  bf00              NOP      
000044  2000              MOVS     r0,#0
000046  6420              STR      r0,[r4,#0x40]
000048  bf00              NOP      
;;;2064   
;;;2065           return HAL_TIMEOUT;
00004a  2003              MOVS     r0,#3
                  |L44.76|
;;;2066         }
;;;2067       }
;;;2068     }
;;;2069     return HAL_OK;
;;;2070   }
00004c  b005              ADD      sp,sp,#0x14
00004e  bdf0              POP      {r4-r7,pc}
                  |L44.80|
000050  6820              LDR      r0,[r4,#0]            ;2049
000052  69c0              LDR      r0,[r0,#0x1c]         ;2049
000054  4028              ANDS     r0,r0,r5              ;2049
000056  42a8              CMP      r0,r5                 ;2049
000058  d101              BNE      |L44.94|
00005a  2001              MOVS     r0,#1                 ;2049
00005c  e000              B        |L44.96|
                  |L44.94|
00005e  2000              MOVS     r0,#0                 ;2049
                  |L44.96|
000060  42b8              CMP      r0,r7                 ;2049
000062  d0d4              BEQ      |L44.14|
000064  2000              MOVS     r0,#0                 ;2069
000066  e7f1              B        |L44.76|
;;;2071   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_L0_V1.10.0\\Drivers\\STM32L0xx_HAL_Driver\\Src\\stm32l0xx_hal_usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32l0xx_hal_usart_c_32ae8742____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_L0_V1.10.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___21_stm32l0xx_hal_usart_c_32ae8742____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32l0xx_hal_usart_c_32ae8742____REVSH|
#line 402
|__asm___21_stm32l0xx_hal_usart_c_32ae8742____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
