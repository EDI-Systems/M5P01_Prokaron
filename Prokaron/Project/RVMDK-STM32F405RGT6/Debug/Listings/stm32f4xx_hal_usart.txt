; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f4xx_hal_usart.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f4xx_hal_usart.d --cpu=Cortex-M4.fp --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F4_V1.21.0\Drivers\STM32F4xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_F4_V1.21.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F4_V1.21.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F4_V1.21.0\Drivers\STM32F4xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F405RGT6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.11.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F405xx -DSTM32F405xx -DUSE_HAL_DRIVER -DHSE_VALUE=8000000 -DPLL_M=8 --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f4xx_hal_usart.crf ..\..\..\M0P0_Library\STM32Cube_FW_F4_V1.21.0\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_usart.c]
                          THUMB

                          AREA ||i.HAL_USART_Abort||, CODE, READONLY, ALIGN=1

                  HAL_USART_Abort PROC
;;;1192   */
;;;1193   HAL_StatusTypeDef HAL_USART_Abort(USART_HandleTypeDef *husart)
000000  b570              PUSH     {r4-r6,lr}
;;;1194   {
000002  4604              MOV      r4,r0
;;;1195     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1196     CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6800              LDR      r0,[r0,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f42171f0          BIC      r1,r1,#0x1e0
00000c  60c1              STR      r1,[r0,#0xc]
;;;1197     CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
000012  f0210101          BIC      r1,r1,#1
000016  6141              STR      r1,[r0,#0x14]
;;;1198   
;;;1199     /* Disable the USART DMA Tx request if enabled */
;;;1200     if(HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT))
000018  6820              LDR      r0,[r4,#0]
00001a  6941              LDR      r1,[r0,#0x14]
00001c  f04f0500          MOV      r5,#0
000020  f0110f80          TST      r1,#0x80
000024  d009              BEQ      |L1.58|
;;;1201     {
;;;1202       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
000026  6941              LDR      r1,[r0,#0x14]
000028  f0210180          BIC      r1,r1,#0x80
00002c  6141              STR      r1,[r0,#0x14]
;;;1203   
;;;1204       /* Abort the USART DMA Tx channel : use blocking DMA Abort API (no callback) */
;;;1205       if(husart->hdmatx != NULL)
00002e  6b60              LDR      r0,[r4,#0x34]
000030  b118              CBZ      r0,|L1.58|
;;;1206       {
;;;1207         /* Set the USART DMA Abort callback to Null. 
;;;1208            No call back execution at end of DMA abort procedure */
;;;1209         husart->hdmatx->XferAbortCallback = NULL;
;;;1210   
;;;1211         HAL_DMA_Abort(husart->hdmatx);
000032  6545              STR      r5,[r0,#0x54]
000034  6b60              LDR      r0,[r4,#0x34]
000036  f7fffffe          BL       HAL_DMA_Abort
                  |L1.58|
;;;1212       }
;;;1213     }
;;;1214   
;;;1215     /* Disable the USART DMA Rx request if enabled */
;;;1216     if(HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
00003a  6820              LDR      r0,[r4,#0]
00003c  6941              LDR      r1,[r0,#0x14]
00003e  f0110f40          TST      r1,#0x40
000042  d009              BEQ      |L1.88|
;;;1217     {
;;;1218       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
000044  6941              LDR      r1,[r0,#0x14]
000046  f0210140          BIC      r1,r1,#0x40
00004a  6141              STR      r1,[r0,#0x14]
;;;1219   
;;;1220       /* Abort the USART DMA Rx channel : use blocking DMA Abort API (no callback) */
;;;1221       if(husart->hdmarx != NULL)
00004c  6ba0              LDR      r0,[r4,#0x38]
00004e  b118              CBZ      r0,|L1.88|
;;;1222       {
;;;1223         /* Set the USART DMA Abort callback to Null. 
;;;1224            No call back execution at end of DMA abort procedure */
;;;1225         husart->hdmarx->XferAbortCallback = NULL;
;;;1226   
;;;1227         HAL_DMA_Abort(husart->hdmarx);
000050  6545              STR      r5,[r0,#0x54]
000052  6ba0              LDR      r0,[r4,#0x38]
000054  f7fffffe          BL       HAL_DMA_Abort
                  |L1.88|
;;;1228       }
;;;1229     }
;;;1230   
;;;1231     /* Reset Tx and Rx transfer counters */
;;;1232     husart->TxXferCount = 0x00U; 
000058  8565              STRH     r5,[r4,#0x2a]
;;;1233     husart->RxXferCount = 0x00U; 
00005a  8665              STRH     r5,[r4,#0x32]
;;;1234   
;;;1235     /* Restore husart->State to Ready */
;;;1236     husart->State  = HAL_USART_STATE_READY;
00005c  2001              MOVS     r0,#1
00005e  6420              STR      r0,[r4,#0x40]
;;;1237   
;;;1238     /* Reset Handle ErrorCode to No Error */
;;;1239     husart->ErrorCode = HAL_USART_ERROR_NONE;
000060  6465              STR      r5,[r4,#0x44]
;;;1240   
;;;1241     return HAL_OK;
000062  2000              MOVS     r0,#0
;;;1242   }
000064  bd70              POP      {r4-r6,pc}
;;;1243   
                          ENDP


                          AREA ||i.HAL_USART_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_AbortCpltCallback PROC
;;;1604     */
;;;1605   __weak void HAL_USART_AbortCpltCallback (USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1606   {
;;;1607     /* Prevent unused argument(s) compilation warning */
;;;1608     UNUSED(husart);
;;;1609   
;;;1610     /* NOTE : This function should not be modified, when the callback is needed,
;;;1611               the HAL_USART_AbortCpltCallback can be implemented in the user file.
;;;1612      */
;;;1613   }
;;;1614   
                          ENDP


                          AREA ||i.HAL_USART_Abort_IT||, CODE, READONLY, ALIGN=2

                  HAL_USART_Abort_IT PROC
;;;1258   */
;;;1259   HAL_StatusTypeDef HAL_USART_Abort_IT(USART_HandleTypeDef *husart)
000000  b570              PUSH     {r4-r6,lr}
;;;1260   {
000002  4604              MOV      r4,r0
;;;1261     uint32_t AbortCplt = 0x01U;
;;;1262     
;;;1263     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1264     CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6800              LDR      r0,[r0,#0]
000006  2601              MOVS     r6,#1                 ;1261
000008  68c1              LDR      r1,[r0,#0xc]
00000a  f42171f0          BIC      r1,r1,#0x1e0
00000e  60c1              STR      r1,[r0,#0xc]
;;;1265     CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
000010  6820              LDR      r0,[r4,#0]
000012  6941              LDR      r1,[r0,#0x14]
000014  f0210101          BIC      r1,r1,#1
000018  6141              STR      r1,[r0,#0x14]
00001a  6b60              LDR      r0,[r4,#0x34]         ;1260
;;;1266   
;;;1267     /* If DMA Tx and/or DMA Rx Handles are associated to USART Handle, DMA Abort complete callbacks should be initialised
;;;1268        before any call to DMA Abort functions */
;;;1269     /* DMA Tx Handle is valid */
;;;1270     if(husart->hdmatx != NULL)
00001c  2500              MOVS     r5,#0
00001e  b138              CBZ      r0,|L3.48|
;;;1271     {
;;;1272       /* Set DMA Abort Complete callback if USART DMA Tx request if enabled.
;;;1273          Otherwise, set it to NULL */
;;;1274       if(HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT))
000020  6821              LDR      r1,[r4,#0]
000022  6949              LDR      r1,[r1,#0x14]
000024  f0110f80          TST      r1,#0x80
;;;1275       {
;;;1276         husart->hdmatx->XferAbortCallback = USART_DMATxAbortCallback;
;;;1277       }
;;;1278       else
;;;1279       {
;;;1280         husart->hdmatx->XferAbortCallback = NULL;
000028  bf0e              ITEE     EQ
00002a  6545              STREQ    r5,[r0,#0x54]
00002c  491d              LDRNE    r1,|L3.164|
00002e  6541              STRNE    r1,[r0,#0x54]         ;1276
                  |L3.48|
;;;1281       }
;;;1282     }
;;;1283     /* DMA Rx Handle is valid */
;;;1284     if(husart->hdmarx != NULL)
000030  6ba0              LDR      r0,[r4,#0x38]
000032  b138              CBZ      r0,|L3.68|
;;;1285     {
;;;1286       /* Set DMA Abort Complete callback if USART DMA Rx request if enabled.
;;;1287          Otherwise, set it to NULL */
;;;1288       if(HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
000034  6821              LDR      r1,[r4,#0]
000036  6949              LDR      r1,[r1,#0x14]
000038  f0110f40          TST      r1,#0x40
;;;1289       {
;;;1290         husart->hdmarx->XferAbortCallback = USART_DMARxAbortCallback;
;;;1291       }
;;;1292       else
;;;1293       {
;;;1294         husart->hdmarx->XferAbortCallback = NULL;
00003c  bf0e              ITEE     EQ
00003e  6545              STREQ    r5,[r0,#0x54]
000040  4919              LDRNE    r1,|L3.168|
000042  6541              STRNE    r1,[r0,#0x54]         ;1290
                  |L3.68|
;;;1295       }
;;;1296     }
;;;1297     
;;;1298     /* Disable the USART DMA Tx request if enabled */
;;;1299     if(HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT))
000044  6820              LDR      r0,[r4,#0]
000046  6941              LDR      r1,[r0,#0x14]
000048  f0110f80          TST      r1,#0x80
00004c  d00c              BEQ      |L3.104|
;;;1300     {
;;;1301       /* Disable DMA Tx at USART level */
;;;1302       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
00004e  6941              LDR      r1,[r0,#0x14]
000050  f0210180          BIC      r1,r1,#0x80
000054  6141              STR      r1,[r0,#0x14]
;;;1303   
;;;1304       /* Abort the USART DMA Tx channel : use non blocking DMA Abort API (callback) */
;;;1305       if(husart->hdmatx != NULL)
000056  6b60              LDR      r0,[r4,#0x34]
000058  b130              CBZ      r0,|L3.104|
;;;1306       {
;;;1307         /* USART Tx DMA Abort callback has already been initialised : 
;;;1308            will lead to call HAL_USART_AbortCpltCallback() at end of DMA abort procedure */
;;;1309   
;;;1310         /* Abort DMA TX */
;;;1311         if(HAL_DMA_Abort_IT(husart->hdmatx) != HAL_OK)
00005a  f7fffffe          BL       HAL_DMA_Abort_IT
00005e  2800              CMP      r0,#0
;;;1312         {
;;;1313           husart->hdmatx->XferAbortCallback = NULL;
;;;1314         }
;;;1315         else
;;;1316         {
;;;1317           AbortCplt = 0x00U;
000060  bf0e              ITEE     EQ
000062  2600              MOVEQ    r6,#0
000064  6b60              LDRNE    r0,[r4,#0x34]         ;1313
000066  6545              STRNE    r5,[r0,#0x54]         ;1313
                  |L3.104|
;;;1318         }
;;;1319       }
;;;1320     }
;;;1321   
;;;1322     /* Disable the USART DMA Rx request if enabled */
;;;1323     if(HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
000068  6820              LDR      r0,[r4,#0]
00006a  6941              LDR      r1,[r0,#0x14]
00006c  f0110f40          TST      r1,#0x40
000070  d00d              BEQ      |L3.142|
;;;1324     {
;;;1325       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
000072  6941              LDR      r1,[r0,#0x14]
000074  f0210140          BIC      r1,r1,#0x40
000078  6141              STR      r1,[r0,#0x14]
;;;1326   
;;;1327       /* Abort the USART DMA Rx channel : use non blocking DMA Abort API (callback) */
;;;1328       if(husart->hdmarx != NULL)
00007a  6ba0              LDR      r0,[r4,#0x38]
00007c  b138              CBZ      r0,|L3.142|
;;;1329       {
;;;1330         /* USART Rx DMA Abort callback has already been initialised : 
;;;1331            will lead to call HAL_USART_AbortCpltCallback() at end of DMA abort procedure */
;;;1332   
;;;1333         /* Abort DMA RX */
;;;1334         if(HAL_DMA_Abort_IT(husart->hdmarx) != HAL_OK)
00007e  f7fffffe          BL       HAL_DMA_Abort_IT
000082  2800              CMP      r0,#0
;;;1335         {
;;;1336           husart->hdmarx->XferAbortCallback = NULL;
000084  bf1c              ITT      NE
000086  6ba0              LDRNE    r0,[r4,#0x38]
000088  6545              STRNE    r5,[r0,#0x54]
00008a  d009              BEQ      |L3.160|
00008c  e000              B        |L3.144|
                  |L3.142|
;;;1337           AbortCplt = 0x01U;
;;;1338         }
;;;1339         else
;;;1340         {
;;;1341           AbortCplt = 0x00U;
;;;1342         }
;;;1343       }
;;;1344     }
;;;1345   
;;;1346     /* if no DMA abort complete callback execution is required => call user Abort Complete callback */
;;;1347     if(AbortCplt  == 0x01U)
00008e  b13e              CBZ      r6,|L3.160|
                  |L3.144|
;;;1348     {
;;;1349       /* Reset Tx and Rx transfer counters */
;;;1350       husart->TxXferCount = 0x00U; 
000090  8565              STRH     r5,[r4,#0x2a]
;;;1351       husart->RxXferCount = 0x00U;
000092  8665              STRH     r5,[r4,#0x32]
;;;1352   
;;;1353       /* Reset errorCode */
;;;1354       husart->ErrorCode = HAL_USART_ERROR_NONE;
000094  6465              STR      r5,[r4,#0x44]
;;;1355   
;;;1356       /* Restore husart->State to Ready */
;;;1357       husart->State  = HAL_USART_STATE_READY;
000096  2001              MOVS     r0,#1
000098  6420              STR      r0,[r4,#0x40]
;;;1358   
;;;1359       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1360       HAL_USART_AbortCpltCallback(husart);
00009a  4620              MOV      r0,r4
00009c  f7fffffe          BL       HAL_USART_AbortCpltCallback
                  |L3.160|
;;;1361     }
;;;1362   
;;;1363     return HAL_OK;
0000a0  2000              MOVS     r0,#0
;;;1364   }
0000a2  bd70              POP      {r4-r6,pc}
;;;1365   
                          ENDP

                  |L3.164|
                          DCD      USART_DMATxAbortCallback
                  |L3.168|
                          DCD      USART_DMARxAbortCallback

                          AREA ||i.HAL_USART_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_USART_DMAPause PROC
;;;1095     */
;;;1096   HAL_StatusTypeDef HAL_USART_DMAPause(USART_HandleTypeDef *husart)
000000  6bc1              LDR      r1,[r0,#0x3c]
;;;1097   {
;;;1098     /* Process Locked */
;;;1099     __HAL_LOCK(husart);
000002  2901              CMP      r1,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;1100   
;;;1101     /* Disable the USART DMA Tx request */
;;;1102     CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1103   
;;;1104     /* Process Unlocked */
;;;1105     __HAL_UNLOCK(husart);
;;;1106   
;;;1107     return HAL_OK;
;;;1108   }
000008  4770              BXEQ     lr
00000a  2101              MOVS     r1,#1                 ;1099
00000c  63c1              STR      r1,[r0,#0x3c]         ;1102
00000e  6801              LDR      r1,[r0,#0]            ;1102
000010  694a              LDR      r2,[r1,#0x14]         ;1102
000012  f0220280          BIC      r2,r2,#0x80           ;1102
000016  614a              STR      r2,[r1,#0x14]         ;1102
000018  2100              MOVS     r1,#0                 ;1105
00001a  63c1              STR      r1,[r0,#0x3c]         ;1107
00001c  4608              MOV      r0,r1                 ;1107
00001e  4770              BX       lr
;;;1109   
                          ENDP


                          AREA ||i.HAL_USART_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_USART_DMAResume PROC
;;;1115     */
;;;1116   HAL_StatusTypeDef HAL_USART_DMAResume(USART_HandleTypeDef *husart)
000000  6bc1              LDR      r1,[r0,#0x3c]
;;;1117   {
;;;1118     /* Process Locked */
;;;1119     __HAL_LOCK(husart);
000002  2901              CMP      r1,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;1120   
;;;1121     /* Enable the USART DMA Tx request */
;;;1122     SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1123   
;;;1124     /* Process Unlocked */
;;;1125     __HAL_UNLOCK(husart);
;;;1126   
;;;1127     return HAL_OK;
;;;1128   }
000008  4770              BXEQ     lr
00000a  2101              MOVS     r1,#1                 ;1119
00000c  63c1              STR      r1,[r0,#0x3c]         ;1122
00000e  6801              LDR      r1,[r0,#0]            ;1122
000010  694a              LDR      r2,[r1,#0x14]         ;1122
000012  f0420280          ORR      r2,r2,#0x80           ;1122
000016  614a              STR      r2,[r1,#0x14]         ;1122
000018  2100              MOVS     r1,#0                 ;1125
00001a  63c1              STR      r1,[r0,#0x3c]         ;1127
00001c  4608              MOV      r0,r1                 ;1127
00001e  4770              BX       lr
;;;1129   
                          ENDP


                          AREA ||i.HAL_USART_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_USART_DMAStop PROC
;;;1135     */
;;;1136   HAL_StatusTypeDef HAL_USART_DMAStop(USART_HandleTypeDef *husart)
000000  b570              PUSH     {r4-r6,lr}
;;;1137   {
000002  4604              MOV      r4,r0
;;;1138     uint32_t dmarequest = 0x00U;
;;;1139     /* The Lock is not implemented on this API to allow the user application
;;;1140        to call the HAL USART API under callbacks HAL_USART_TxCpltCallback() / HAL_USART_RxCpltCallback():
;;;1141        when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
;;;1142        and the correspond call back is executed HAL_USART_TxCpltCallback() / HAL_USART_RxCpltCallback()
;;;1143        */
;;;1144   
;;;1145     /* Stop USART DMA Tx request if ongoing */
;;;1146     dmarequest = HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT);
000004  6800              LDR      r0,[r0,#0]
000006  6941              LDR      r1,[r0,#0x14]
;;;1147     if((husart->State == HAL_USART_STATE_BUSY_TX) && dmarequest)
000008  6c22              LDR      r2,[r4,#0x40]
00000a  f3c111c0          UBFX     r1,r1,#7,#1           ;1146
00000e  2501              MOVS     r5,#1                 ;1146
000010  2a12              CMP      r2,#0x12
000012  d10f              BNE      |L6.52|
000014  b171              CBZ      r1,|L6.52|
000016  68c1              LDR      r1,[r0,#0xc]
000018  f02101c0          BIC      r1,r1,#0xc0
00001c  60c1              STR      r1,[r0,#0xc]
00001e  6425              STR      r5,[r4,#0x40]
;;;1148     {
;;;1149       USART_EndTxTransfer(husart);
;;;1150   
;;;1151       /* Abort the USART DMA Tx channel */
;;;1152       if(husart->hdmatx != NULL)
000020  6b60              LDR      r0,[r4,#0x34]
000022  2800              CMP      r0,#0
;;;1153       {
;;;1154         HAL_DMA_Abort(husart->hdmatx);
000024  bf18              IT       NE
000026  f7fffffe          BLNE     HAL_DMA_Abort
;;;1155       }
;;;1156   
;;;1157       /* Disable the USART Tx DMA request */
;;;1158       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
00002a  6820              LDR      r0,[r4,#0]
00002c  6941              LDR      r1,[r0,#0x14]
00002e  f0210180          BIC      r1,r1,#0x80
000032  6141              STR      r1,[r0,#0x14]
                  |L6.52|
;;;1159     }
;;;1160   
;;;1161     /* Stop USART DMA Rx request if ongoing */
;;;1162     dmarequest = HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR);
000034  6820              LDR      r0,[r4,#0]
000036  6941              LDR      r1,[r0,#0x14]
;;;1163     if((husart->State == HAL_USART_STATE_BUSY_RX) && dmarequest)
000038  6c22              LDR      r2,[r4,#0x40]
00003a  f3c11180          UBFX     r1,r1,#6,#1           ;1162
00003e  2a22              CMP      r2,#0x22
000040  d114              BNE      |L6.108|
000042  b199              CBZ      r1,|L6.108|
000044  68c1              LDR      r1,[r0,#0xc]
000046  f4217190          BIC      r1,r1,#0x120
00004a  60c1              STR      r1,[r0,#0xc]
00004c  6820              LDR      r0,[r4,#0]
00004e  6941              LDR      r1,[r0,#0x14]
000050  f0210101          BIC      r1,r1,#1
000054  6141              STR      r1,[r0,#0x14]
000056  6425              STR      r5,[r4,#0x40]
;;;1164     {
;;;1165       USART_EndRxTransfer(husart);
;;;1166   
;;;1167       /* Abort the USART DMA Rx channel */
;;;1168       if(husart->hdmarx != NULL)
000058  6ba0              LDR      r0,[r4,#0x38]
00005a  2800              CMP      r0,#0
;;;1169       {
;;;1170         HAL_DMA_Abort(husart->hdmarx);
00005c  bf18              IT       NE
00005e  f7fffffe          BLNE     HAL_DMA_Abort
;;;1171       }
;;;1172   
;;;1173       /* Disable the USART Rx DMA request */
;;;1174       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
000062  6820              LDR      r0,[r4,#0]
000064  6941              LDR      r1,[r0,#0x14]
000066  f0210140          BIC      r1,r1,#0x40
00006a  6141              STR      r1,[r0,#0x14]
                  |L6.108|
;;;1175     }
;;;1176   
;;;1177     return HAL_OK;
00006c  2000              MOVS     r0,#0
;;;1178   }
00006e  bd70              POP      {r4-r6,pc}
;;;1179   
                          ENDP


                          AREA ||i.HAL_USART_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_USART_DeInit PROC
;;;271      */
;;;272    HAL_StatusTypeDef HAL_USART_DeInit(USART_HandleTypeDef *husart)
000000  2800              CMP      r0,#0
;;;273    {
;;;274      /* Check the USART handle allocation */
;;;275      if(husart == NULL)
;;;276      {
;;;277        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;278      }
;;;279    
;;;280      /* Check the parameters */
;;;281      assert_param(IS_USART_INSTANCE(husart->Instance));
;;;282    
;;;283      husart->State = HAL_USART_STATE_BUSY;
;;;284    
;;;285      /* Disable the Peripheral */
;;;286      __HAL_USART_DISABLE(husart);
;;;287    
;;;288      /* DeInit the low level hardware */
;;;289      HAL_USART_MspDeInit(husart);
;;;290    
;;;291      husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;292      husart->State = HAL_USART_STATE_RESET;
;;;293    
;;;294      /* Release Lock */
;;;295      __HAL_UNLOCK(husart);
;;;296    
;;;297      return HAL_OK;
;;;298    }
000006  4770              BXEQ     lr
000008  b510              PUSH     {r4,lr}               ;273
00000a  4604              MOV      r4,r0                 ;273
00000c  2002              MOVS     r0,#2                 ;283
00000e  6420              STR      r0,[r4,#0x40]         ;283
000010  6820              LDR      r0,[r4,#0]            ;286
000012  68c1              LDR      r1,[r0,#0xc]          ;286
000014  f4215100          BIC      r1,r1,#0x2000         ;286
000018  60c1              STR      r1,[r0,#0xc]          ;286
00001a  4620              MOV      r0,r4                 ;289
00001c  f7fffffe          BL       HAL_USART_MspDeInit
000020  2000              MOVS     r0,#0                 ;291
000022  6460              STR      r0,[r4,#0x44]         ;291
000024  6420              STR      r0,[r4,#0x40]         ;292
000026  63e0              STR      r0,[r4,#0x3c]         ;295
000028  bd10              POP      {r4,pc}
;;;299    
                          ENDP


                          AREA ||i.HAL_USART_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_ErrorCallback PROC
;;;1590     */
;;;1591    __weak void HAL_USART_ErrorCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1592   {
;;;1593     /* Prevent unused argument(s) compilation warning */
;;;1594     UNUSED(husart);
;;;1595     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1596              the HAL_USART_ErrorCallback could be implemented in the user file
;;;1597      */
;;;1598   }
;;;1599   
                          ENDP


                          AREA ||i.HAL_USART_GetError||, CODE, READONLY, ALIGN=1

                  HAL_USART_GetError PROC
;;;1654     */
;;;1655   uint32_t HAL_USART_GetError(USART_HandleTypeDef *husart)
000000  6c40              LDR      r0,[r0,#0x44]
;;;1656   {
;;;1657     return husart->ErrorCode;
;;;1658   }
000002  4770              BX       lr
;;;1659   
                          ENDP


                          AREA ||i.HAL_USART_GetState||, CODE, READONLY, ALIGN=1

                  HAL_USART_GetState PROC
;;;1643     */
;;;1644   HAL_USART_StateTypeDef HAL_USART_GetState(USART_HandleTypeDef *husart)
000000  6c00              LDR      r0,[r0,#0x40]
;;;1645   {
;;;1646     return husart->State;
;;;1647   }
000002  4770              BX       lr
;;;1648   
                          ENDP


                          AREA ||i.HAL_USART_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_USART_IRQHandler PROC
;;;1371     */
;;;1372   void HAL_USART_IRQHandler(USART_HandleTypeDef *husart)
000000  b570              PUSH     {r4-r6,lr}
;;;1373   {
;;;1374     uint32_t isrflags = READ_REG(husart->Instance->SR);
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0                 ;1373
000006  6810              LDR      r0,[r2,#0]
;;;1375     uint32_t cr1its   = READ_REG(husart->Instance->CR1);
000008  68d1              LDR      r1,[r2,#0xc]
;;;1376     uint32_t cr3its   = READ_REG(husart->Instance->CR3);
00000a  6953              LDR      r3,[r2,#0x14]
;;;1377     uint32_t errorflags = 0x00U;
;;;1378     uint32_t dmarequest = 0x00U;
;;;1379   
;;;1380     /* If no error occurs */
;;;1381     errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
00000c  f0100f0f          TST      r0,#0xf
000010  f04f0501          MOV      r5,#1
000014  d069              BEQ      |L11.234|
;;;1382     if(errorflags == RESET)
;;;1383     {
;;;1384       /* USART in mode Receiver -------------------------------------------------*/
;;;1385       if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
;;;1386       {
;;;1387         if(husart->State == HAL_USART_STATE_BUSY_RX)
;;;1388         {
;;;1389           USART_Receive_IT(husart);
;;;1390         }
;;;1391         else
;;;1392         {
;;;1393           USART_TransmitReceive_IT(husart);
;;;1394         }
;;;1395         return;
;;;1396       }
;;;1397     }
;;;1398     /* If some errors occur */
;;;1399     if((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET) || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
000016  f0030c01          AND      r12,r3,#1
00001a  f4017690          AND      r6,r1,#0x120
00001e  ea5c0c06          ORRS     r12,r12,r6
000022  d07e              BEQ      |L11.290|
;;;1400     {
;;;1401       /* USART parity error interrupt occurred ----------------------------------*/
;;;1402       if(((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
000024  f0100f01          TST      r0,#1
000028  bf18              IT       NE
00002a  f4117f80          TSTNE    r1,#0x100
00002e  d003              BEQ      |L11.56|
;;;1403       {
;;;1404         husart->ErrorCode |= HAL_USART_ERROR_PE;
000030  6c62              LDR      r2,[r4,#0x44]
000032  f0420201          ORR      r2,r2,#1
000036  6462              STR      r2,[r4,#0x44]
                  |L11.56|
;;;1405       }
;;;1406   
;;;1407       /* USART noise error interrupt occurred --------------------------------*/
;;;1408       if(((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
000038  f0100f04          TST      r0,#4
00003c  bf18              IT       NE
00003e  f0130f01          TSTNE    r3,#1
000042  d003              BEQ      |L11.76|
;;;1409       {
;;;1410         husart->ErrorCode |= HAL_USART_ERROR_NE;
000044  6c62              LDR      r2,[r4,#0x44]
000046  f0420202          ORR      r2,r2,#2
00004a  6462              STR      r2,[r4,#0x44]
                  |L11.76|
;;;1411       }
;;;1412   
;;;1413       /* USART frame error interrupt occurred --------------------------------*/
;;;1414       if(((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
00004c  f0100f02          TST      r0,#2
000050  bf18              IT       NE
000052  f0130f01          TSTNE    r3,#1
000056  d003              BEQ      |L11.96|
;;;1415       {
;;;1416         husart->ErrorCode |= HAL_USART_ERROR_FE;
000058  6c62              LDR      r2,[r4,#0x44]
00005a  f0420204          ORR      r2,r2,#4
00005e  6462              STR      r2,[r4,#0x44]
                  |L11.96|
;;;1417       }
;;;1418   
;;;1419       /* USART Over-Run interrupt occurred -----------------------------------*/
;;;1420       if(((isrflags & USART_SR_ORE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
000060  f0100f08          TST      r0,#8
000064  bf18              IT       NE
000066  f0130f01          TSTNE    r3,#1
00006a  d003              BEQ      |L11.116|
;;;1421       {
;;;1422         husart->ErrorCode |= HAL_USART_ERROR_ORE;
00006c  6c62              LDR      r2,[r4,#0x44]
00006e  f0420208          ORR      r2,r2,#8
000072  6462              STR      r2,[r4,#0x44]
                  |L11.116|
;;;1423       }
;;;1424   
;;;1425       if(husart->ErrorCode != HAL_USART_ERROR_NONE)
000074  6c62              LDR      r2,[r4,#0x44]
000076  2a00              CMP      r2,#0
;;;1426       {
;;;1427         /* USART in mode Receiver -----------------------------------------------*/
;;;1428         if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
;;;1429         {
;;;1430           if(husart->State == HAL_USART_STATE_BUSY_RX)
;;;1431           {
;;;1432             USART_Receive_IT(husart);
;;;1433           }
;;;1434           else
;;;1435           {
;;;1436             USART_TransmitReceive_IT(husart);
;;;1437           }
;;;1438         }
;;;1439         /* If Overrun error occurs, or if any error occurs in DMA mode reception,
;;;1440         consider error as blocking */
;;;1441         dmarequest = HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR);
;;;1442         if(((husart->ErrorCode & HAL_USART_ERROR_ORE) != RESET) || dmarequest)
;;;1443         {
;;;1444           /* Set the USART state ready to be able to start again the process,
;;;1445           Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
;;;1446           USART_EndRxTransfer(husart);
;;;1447   
;;;1448           /* Disable the USART DMA Rx request if enabled */
;;;1449           if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
;;;1450           {
;;;1451             CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
;;;1452   
;;;1453             /* Abort the USART DMA Rx channel */
;;;1454             if(husart->hdmarx != NULL)
;;;1455             {
;;;1456               /* Set the USART DMA Abort callback :
;;;1457               will lead to call HAL_USART_ErrorCallback() at end of DMA abort procedure */
;;;1458               husart->hdmarx->XferAbortCallback = USART_DMAAbortOnError;
;;;1459   
;;;1460               if(HAL_DMA_Abort_IT(husart->hdmarx) != HAL_OK)
;;;1461               {
;;;1462                 /* Call Directly XferAbortCallback function in case of error */
;;;1463                 husart->hdmarx->XferAbortCallback(husart->hdmarx);
;;;1464               }
;;;1465             }
;;;1466             else
;;;1467             {
;;;1468               /* Call user error callback */
;;;1469               HAL_USART_ErrorCallback(husart);
;;;1470             }
;;;1471           }
;;;1472           else
;;;1473           {
;;;1474             /* Call user error callback */
;;;1475             HAL_USART_ErrorCallback(husart);
;;;1476           }
;;;1477         }
;;;1478         else
;;;1479         {
;;;1480           /* Call user error callback */
;;;1481           HAL_USART_ErrorCallback(husart);
;;;1482           husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;1483         }
;;;1484       }
;;;1485       return;
;;;1486     }
;;;1487   
;;;1488     /* USART in mode Transmitter -----------------------------------------------*/
;;;1489     if(((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
;;;1490     {
;;;1491       if(husart->State == HAL_USART_STATE_BUSY_TX)
;;;1492       {
;;;1493         USART_Transmit_IT(husart);
;;;1494       }
;;;1495       else
;;;1496       {
;;;1497         USART_TransmitReceive_IT(husart);
;;;1498       }
;;;1499       return;
;;;1500     }
;;;1501   
;;;1502     /* USART in mode Transmitter (transmission end) ----------------------------*/
;;;1503     if(((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
;;;1504     {
;;;1505       USART_EndTransmit_IT(husart);
;;;1506       return;
;;;1507     }
;;;1508   }
000078  bf08              IT       EQ
00007a  bd70              POPEQ    {r4-r6,pc}
00007c  f0100f20          TST      r0,#0x20              ;1428
000080  bf18              IT       NE                    ;1428
000082  f0110f20          TSTNE    r1,#0x20              ;1428
000086  d005              BEQ      |L11.148|
000088  6c20              LDR      r0,[r4,#0x40]         ;1430
00008a  2822              CMP      r0,#0x22              ;1430
00008c  4620              MOV      r0,r4                 ;1436
00008e  d03a              BEQ      |L11.262|
000090  f7fffffe          BL       USART_TransmitReceive_IT
                  |L11.148|
000094  6820              LDR      r0,[r4,#0]            ;1441
000096  6941              LDR      r1,[r0,#0x14]         ;1441
000098  6c62              LDR      r2,[r4,#0x44]         ;1442
00009a  f3c11180          UBFX     r1,r1,#6,#1           ;1441
00009e  f0020208          AND      r2,r2,#8              ;1442
0000a2  4311              ORRS     r1,r1,r2              ;1442
0000a4  d037              BEQ      |L11.278|
0000a6  68c1              LDR      r1,[r0,#0xc]          ;1442
0000a8  f4217190          BIC      r1,r1,#0x120          ;1442
0000ac  60c1              STR      r1,[r0,#0xc]          ;1442
0000ae  6820              LDR      r0,[r4,#0]            ;1442
0000b0  6941              LDR      r1,[r0,#0x14]         ;1442
0000b2  f0210101          BIC      r1,r1,#1              ;1442
0000b6  6141              STR      r1,[r0,#0x14]         ;1442
0000b8  6425              STR      r5,[r4,#0x40]         ;1442
0000ba  6820              LDR      r0,[r4,#0]            ;1449
0000bc  6941              LDR      r1,[r0,#0x14]         ;1449
0000be  f0110f40          TST      r1,#0x40              ;1449
0000c2  d024              BEQ      |L11.270|
0000c4  6941              LDR      r1,[r0,#0x14]         ;1451
0000c6  f0210140          BIC      r1,r1,#0x40           ;1451
0000ca  6141              STR      r1,[r0,#0x14]         ;1451
0000cc  6ba0              LDR      r0,[r4,#0x38]         ;1454
0000ce  b1f0              CBZ      r0,|L11.270|
0000d0  493b              LDR      r1,|L11.448|
0000d2  6541              STR      r1,[r0,#0x54]         ;1460
0000d4  6ba0              LDR      r0,[r4,#0x38]         ;1460
0000d6  f7fffffe          BL       HAL_DMA_Abort_IT
0000da  2800              CMP      r0,#0                 ;1460
0000dc  bf08              IT       EQ
0000de  bd70              POPEQ    {r4-r6,pc}
0000e0  6ba0              LDR      r0,[r4,#0x38]         ;1463
0000e2  6d41              LDR      r1,[r0,#0x54]         ;1463
0000e4  e8bd4070          POP      {r4-r6,lr}            ;1463
0000e8  4708              BX       r1                    ;1463
                  |L11.234|
0000ea  f0100f20          TST      r0,#0x20              ;1385
0000ee  bf18              IT       NE                    ;1385
0000f0  f0110f20          TSTNE    r1,#0x20              ;1385
0000f4  d015              BEQ      |L11.290|
0000f6  6c20              LDR      r0,[r4,#0x40]         ;1387
0000f8  2822              CMP      r0,#0x22              ;1387
0000fa  d11b              BNE      |L11.308|
0000fc  4620              MOV      r0,r4                 ;1389
0000fe  e8bd4070          POP      {r4-r6,lr}            ;1389
000102  f7ffbffe          B.W      USART_Receive_IT
                  |L11.262|
000106  f7fffffe          BL       USART_Receive_IT
00010a  e7c3              B        |L11.148|
00010c  e009              B        |L11.290|
                  |L11.270|
00010e  4620              MOV      r0,r4                 ;1475
000110  f7fffffe          BL       HAL_USART_ErrorCallback
000114  bd70              POP      {r4-r6,pc}
                  |L11.278|
000116  4620              MOV      r0,r4                 ;1481
000118  f7fffffe          BL       HAL_USART_ErrorCallback
00011c  2000              MOVS     r0,#0                 ;1482
00011e  6460              STR      r0,[r4,#0x44]         ;1482
000120  bd70              POP      {r4-r6,pc}
                  |L11.290|
000122  f0100f80          TST      r0,#0x80              ;1489
000126  bf18              IT       NE                    ;1489
000128  f0110f80          TSTNE    r1,#0x80              ;1489
00012c  d033              BEQ      |L11.406|
00012e  6c20              LDR      r0,[r4,#0x40]         ;1491
000130  2812              CMP      r0,#0x12              ;1491
000132  d004              BEQ      |L11.318|
                  |L11.308|
000134  4620              MOV      r0,r4                 ;1497
000136  e8bd4070          POP      {r4-r6,lr}            ;1497
00013a  f7ffbffe          B.W      USART_TransmitReceive_IT
                  |L11.318|
00013e  6c20              LDR      r0,[r4,#0x40]         ;1497
000140  2812              CMP      r0,#0x12              ;1497
000142  bf18              IT       NE
000144  bd70              POPNE    {r4-r6,pc}
000146  68a0              LDR      r0,[r4,#8]
000148  f5b05f80          CMP      r0,#0x1000
00014c  6a60              LDR      r0,[r4,#0x24]
00014e  d016              BEQ      |L11.382|
000150  1c41              ADDS     r1,r0,#1
000152  6261              STR      r1,[r4,#0x24]
000154  6821              LDR      r1,[r4,#0]
000156  7800              LDRB     r0,[r0,#0]
000158  6048              STR      r0,[r1,#4]
                  |L11.346|
00015a  8d60              LDRH     r0,[r4,#0x2a]
00015c  1e40              SUBS     r0,r0,#1
00015e  0400              LSLS     r0,r0,#16
000160  0c00              LSRS     r0,r0,#16
000162  8560              STRH     r0,[r4,#0x2a]
000164  bf18              IT       NE
000166  bd70              POPNE    {r4-r6,pc}
000168  6820              LDR      r0,[r4,#0]
00016a  68c1              LDR      r1,[r0,#0xc]
00016c  f0210180          BIC      r1,r1,#0x80
000170  60c1              STR      r1,[r0,#0xc]
000172  6820              LDR      r0,[r4,#0]
000174  68c1              LDR      r1,[r0,#0xc]
000176  f0410140          ORR      r1,r1,#0x40
00017a  60c1              STR      r1,[r0,#0xc]
00017c  bd70              POP      {r4-r6,pc}
                  |L11.382|
00017e  8800              LDRH     r0,[r0,#0]
000180  f3c00008          UBFX     r0,r0,#0,#9
000184  6050              STR      r0,[r2,#4]
000186  6920              LDR      r0,[r4,#0x10]
000188  2800              CMP      r0,#0
00018a  6a60              LDR      r0,[r4,#0x24]
00018c  bf14              ITE      NE
00018e  1c40              ADDNE    r0,r0,#1
000190  1c80              ADDEQ    r0,r0,#2
000192  6260              STR      r0,[r4,#0x24]
000194  e7e1              B        |L11.346|
                  |L11.406|
000196  f0100f40          TST      r0,#0x40              ;1503
00019a  bf14              ITE      NE                    ;1503
00019c  f0110f40          TSTNE    r1,#0x40              ;1503
0001a0  bd70              POPEQ    {r4-r6,pc}
0001a2  4620              MOV      r0,r4                 ;1505
0001a4  68d1              LDR      r1,[r2,#0xc]          ;1505
0001a6  f0210140          BIC      r1,r1,#0x40           ;1505
0001aa  60d1              STR      r1,[r2,#0xc]          ;1505
0001ac  6821              LDR      r1,[r4,#0]            ;1505
0001ae  694a              LDR      r2,[r1,#0x14]         ;1505
0001b0  f0220201          BIC      r2,r2,#1              ;1505
0001b4  614a              STR      r2,[r1,#0x14]         ;1505
0001b6  6425              STR      r5,[r4,#0x40]         ;1505
0001b8  f7fffffe          BL       HAL_USART_TxCpltCallback
0001bc  bd70              POP      {r4-r6,pc}
;;;1509   
                          ENDP

0001be  0000              DCW      0x0000
                  |L11.448|
                          DCD      USART_DMAAbortOnError

                          AREA ||i.HAL_USART_Init||, CODE, READONLY, ALIGN=2

                  HAL_USART_Init PROC
;;;225      */
;;;226    HAL_StatusTypeDef HAL_USART_Init(USART_HandleTypeDef *husart)
000000  2800              CMP      r0,#0
;;;227    {
;;;228      /* Check the USART handle allocation */
;;;229      if(husart == NULL)
;;;230      {
;;;231        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;232      }
;;;233    
;;;234      /* Check the parameters */
;;;235      assert_param(IS_USART_INSTANCE(husart->Instance));
;;;236    
;;;237      if(husart->State == HAL_USART_STATE_RESET)
;;;238      {
;;;239        /* Allocate lock resource and initialize it */
;;;240        husart->Lock = HAL_UNLOCKED;
;;;241        /* Init the low level hardware */
;;;242        HAL_USART_MspInit(husart);
;;;243      }
;;;244    
;;;245      husart->State = HAL_USART_STATE_BUSY;
;;;246    
;;;247      /* Set the USART Communication parameters */
;;;248      USART_SetConfig(husart);
;;;249    
;;;250      /* In USART mode, the following bits must be kept cleared:
;;;251         - LINEN bit in the USART_CR2 register
;;;252         - HDSEL, SCEN and IREN bits in the USART_CR3 register */
;;;253      CLEAR_BIT(husart->Instance->CR2, USART_CR2_LINEN);
;;;254      CLEAR_BIT(husart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;255    
;;;256      /* Enable the Peripheral */
;;;257      __HAL_USART_ENABLE(husart);
;;;258    
;;;259      /* Initialize the USART state */
;;;260      husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;261      husart->State= HAL_USART_STATE_READY;
;;;262    
;;;263      return HAL_OK;
;;;264    }
000006  4770              BXEQ     lr
000008  e92d47f0          PUSH     {r4-r10,lr}           ;227
00000c  4604              MOV      r4,r0                 ;227
00000e  6c00              LDR      r0,[r0,#0x40]         ;237
000010  2600              MOVS     r6,#0                 ;237
000012  b918              CBNZ     r0,|L12.28|
000014  4620              MOV      r0,r4                 ;242
000016  63e6              STR      r6,[r4,#0x3c]         ;242
000018  f7fffffe          BL       HAL_USART_MspInit
                  |L12.28|
00001c  2002              MOVS     r0,#2                 ;245
00001e  6420              STR      r0,[r4,#0x40]         ;245
000020  6820              LDR      r0,[r4,#0]            ;245
000022  68c1              LDR      r1,[r0,#0xc]          ;245
000024  f021010c          BIC      r1,r1,#0xc            ;245
000028  60c1              STR      r1,[r0,#0xc]          ;245
00002a  6820              LDR      r0,[r4,#0]            ;245
00002c  6901              LDR      r1,[r0,#0x10]         ;245
00002e  e9d42306          LDRD     r2,r3,[r4,#0x18]      ;245
000032  431a              ORRS     r2,r2,r3              ;245
000034  f8d4c00c          LDR      r12,[r4,#0xc]         ;245
000038  6a23              LDR      r3,[r4,#0x20]         ;245
00003a  f421517c          BIC      r1,r1,#0x3f00         ;245
00003e  ea43030c          ORR      r3,r3,r12             ;245
000042  431a              ORRS     r2,r2,r3              ;245
000044  4311              ORRS     r1,r1,r2              ;245
000046  f4416100          ORR      r1,r1,#0x800          ;245
00004a  6101              STR      r1,[r0,#0x10]         ;245
00004c  6820              LDR      r0,[r4,#0]            ;245
00004e  68c1              LDR      r1,[r0,#0xc]          ;245
000050  6923              LDR      r3,[r4,#0x10]         ;245
000052  68a2              LDR      r2,[r4,#8]            ;245
000054  f4217103          BIC      r1,r1,#0x20c          ;245
000058  431a              ORRS     r2,r2,r3              ;245
00005a  6963              LDR      r3,[r4,#0x14]         ;245
00005c  f4214114          BIC      r1,r1,#0x9400         ;245
000060  4319              ORRS     r1,r1,r3              ;245
000062  4311              ORRS     r1,r1,r2              ;245
000064  f4414100          ORR      r1,r1,#0x8000         ;245
000068  60c1              STR      r1,[r0,#0xc]          ;245
00006a  6820              LDR      r0,[r4,#0]            ;245
00006c  6941              LDR      r1,[r0,#0x14]         ;245
00006e  f4217140          BIC      r1,r1,#0x300          ;245
000072  6141              STR      r1,[r0,#0x14]         ;245
000074  6820              LDR      r0,[r4,#0]            ;245
000076  4d44              LDR      r5,|L12.392|
000078  2732              MOVS     r7,#0x32              ;245
00007a  f1a04180          SUB      r1,r0,#0x40000000     ;245
00007e  f5b13188          SUBS     r1,r1,#0x11000        ;245
000082  bf1c              ITT      NE                    ;245
000084  f1a04180          SUBNE    r1,r0,#0x40000000     ;245
000088  f5b1318a          SUBSNE   r1,r1,#0x11400        ;245
00008c  d047              BEQ      |L12.286|
00008e  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000092  eb0001c0          ADD      r1,r0,r0,LSL #3       ;248
000096  eb011000          ADD      r0,r1,r0,LSL #4       ;248
00009a  6861              LDR      r1,[r4,#4]            ;248
00009c  0049              LSLS     r1,r1,#1              ;248
00009e  fbb0f0f1          UDIV     r0,r0,r1              ;248
0000a2  fba51000          UMULL    r1,r0,r5,r0           ;248
0000a6  ea4f1850          LSR      r8,r0,#5              ;248
0000aa  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0000ae  eb0001c0          ADD      r1,r0,r0,LSL #3       ;248
0000b2  eb011000          ADD      r0,r1,r0,LSL #4       ;248
0000b6  6861              LDR      r1,[r4,#4]            ;248
0000b8  0049              LSLS     r1,r1,#1              ;248
0000ba  fbb0f9f1          UDIV     r9,r0,r1              ;248
0000be  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0000c2  eb0001c0          ADD      r1,r0,r0,LSL #3       ;248
0000c6  eb011000          ADD      r0,r1,r0,LSL #4       ;248
0000ca  6861              LDR      r1,[r4,#4]            ;248
0000cc  0049              LSLS     r1,r1,#1              ;248
0000ce  fbb0f0f1          UDIV     r0,r0,r1              ;248
0000d2  fba51000          UMULL    r1,r0,r5,r0           ;248
0000d6  0940              LSRS     r0,r0,#5              ;248
0000d8  f06f0118          MVN      r1,#0x18              ;248
0000dc  4348              MULS     r0,r1,r0              ;248
0000de  eb090080          ADD      r0,r9,r0,LSL #2       ;248
0000e2  eb071000          ADD      r0,r7,r0,LSL #4       ;248
0000e6  fba51000          UMULL    r1,r0,r5,r0           ;248
0000ea  6821              LDR      r1,[r4,#0]            ;248
0000ec  0940              LSRS     r0,r0,#5              ;248
0000ee  f368101f          BFI      r0,r8,#4,#28          ;248
0000f2  6088              STR      r0,[r1,#8]            ;248
                  |L12.244|
0000f4  6820              LDR      r0,[r4,#0]            ;253
0000f6  6901              LDR      r1,[r0,#0x10]         ;253
0000f8  f4214180          BIC      r1,r1,#0x4000         ;253
0000fc  6101              STR      r1,[r0,#0x10]         ;253
0000fe  6820              LDR      r0,[r4,#0]            ;254
000100  6941              LDR      r1,[r0,#0x14]         ;254
000102  f021012a          BIC      r1,r1,#0x2a           ;254
000106  6141              STR      r1,[r0,#0x14]         ;254
000108  6820              LDR      r0,[r4,#0]            ;257
00010a  68c1              LDR      r1,[r0,#0xc]          ;257
00010c  f4415100          ORR      r1,r1,#0x2000         ;257
000110  60c1              STR      r1,[r0,#0xc]          ;257
000112  6466              STR      r6,[r4,#0x44]         ;260
000114  2001              MOVS     r0,#1                 ;261
000116  6420              STR      r0,[r4,#0x40]         ;261
000118  2000              MOVS     r0,#0                 ;263
00011a  e8bd87f0          POP      {r4-r10,pc}
                  |L12.286|
00011e  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000122  eb0001c0          ADD      r1,r0,r0,LSL #3
000126  eb011000          ADD      r0,r1,r0,LSL #4
00012a  6861              LDR      r1,[r4,#4]
00012c  0049              LSLS     r1,r1,#1
00012e  fbb0f0f1          UDIV     r0,r0,r1
000132  fba51000          UMULL    r1,r0,r5,r0
000136  ea4f1850          LSR      r8,r0,#5
00013a  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00013e  eb0001c0          ADD      r1,r0,r0,LSL #3
000142  eb011000          ADD      r0,r1,r0,LSL #4
000146  6861              LDR      r1,[r4,#4]
000148  0049              LSLS     r1,r1,#1
00014a  fbb0f9f1          UDIV     r9,r0,r1
00014e  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000152  eb0001c0          ADD      r1,r0,r0,LSL #3
000156  eb011000          ADD      r0,r1,r0,LSL #4
00015a  6861              LDR      r1,[r4,#4]
00015c  0049              LSLS     r1,r1,#1
00015e  fbb0f0f1          UDIV     r0,r0,r1
000162  fba51000          UMULL    r1,r0,r5,r0
000166  0940              LSRS     r0,r0,#5
000168  f06f0118          MVN      r1,#0x18
00016c  4348              MULS     r0,r1,r0
00016e  eb090080          ADD      r0,r9,r0,LSL #2
000172  eb071000          ADD      r0,r7,r0,LSL #4
000176  fba51000          UMULL    r1,r0,r5,r0
00017a  6821              LDR      r1,[r4,#0]
00017c  0940              LSRS     r0,r0,#5
00017e  f368101f          BFI      r0,r8,#4,#28
000182  6088              STR      r0,[r1,#8]
000184  e7b6              B        |L12.244|
;;;265    
                          ENDP

000186  0000              DCW      0x0000
                  |L12.392|
                          DCD      0x51eb851f

                          AREA ||i.HAL_USART_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_USART_MspDeInit PROC
;;;320      */
;;;321     __weak void HAL_USART_MspDeInit(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;322    {
;;;323      /* Prevent unused argument(s) compilation warning */
;;;324      UNUSED(husart);
;;;325      /* NOTE: This function Should not be modified, when the callback is needed,
;;;326               the HAL_USART_MspDeInit could be implemented in the user file
;;;327       */
;;;328    }
;;;329    
                          ENDP


                          AREA ||i.HAL_USART_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_USART_MspInit PROC
;;;305      */
;;;306     __weak void HAL_USART_MspInit(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;307    {
;;;308      /* Prevent unused argument(s) compilation warning */
;;;309      UNUSED(husart);
;;;310      /* NOTE: This function Should not be modified, when the callback is needed,
;;;311               the HAL_USART_MspInit could be implemented in the user file
;;;312       */
;;;313    }
;;;314    
                          ENDP


                          AREA ||i.HAL_USART_Receive||, CODE, READONLY, ALIGN=1

                  HAL_USART_Receive PROC
;;;484      */
;;;485    HAL_StatusTypeDef HAL_USART_Receive(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;486    {
000004  4604              MOV      r4,r0
;;;487      uint16_t* tmp;
;;;488      uint32_t tickstart = 0U;
;;;489    
;;;490      if(husart->State == HAL_USART_STATE_READY)
000006  6c00              LDR      r0,[r0,#0x40]
000008  461e              MOV      r6,r3                 ;486
00000a  4691              MOV      r9,r2                 ;486
00000c  460d              MOV      r5,r1                 ;486
00000e  2801              CMP      r0,#1
000010  d16e              BNE      |L15.240|
;;;491      {
;;;492        if((pRxData == NULL) || (Size == 0))
000012  2d00              CMP      r5,#0
000014  bf12              ITEE     NE
000016  f1b90f00          CMPNE    r9,#0
;;;493        {
;;;494          return  HAL_ERROR;
00001a  2001              MOVEQ    r0,#1
;;;495        }
;;;496        /* Process Locked */
;;;497        __HAL_LOCK(husart);
;;;498    
;;;499        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;500        husart->State = HAL_USART_STATE_BUSY_RX;
;;;501    
;;;502        /* Init tickstart for timeout managment */
;;;503        tickstart = HAL_GetTick();
;;;504    
;;;505        husart->RxXferSize = Size;
;;;506        husart->RxXferCount = Size;
;;;507        /* Check the remain data to be received */
;;;508        while(husart->RxXferCount > 0U)
;;;509        {
;;;510          husart->RxXferCount--;
;;;511          if(husart->Init.WordLength == USART_WORDLENGTH_9B)
;;;512          {
;;;513            /* Wait until TXE flag is set to send dummy byte in order to generate the clock for the slave to send data */
;;;514            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;515            {
;;;516              return HAL_TIMEOUT;
;;;517            }
;;;518            /* Send dummy byte in order to generate clock */
;;;519            husart->Instance->DR = (DUMMY_DATA & (uint16_t)0x01FF);
;;;520    
;;;521            /* Wait for RXNE Flag */
;;;522            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;523            {
;;;524              return HAL_TIMEOUT;
;;;525            }
;;;526            tmp = (uint16_t*) pRxData ;
;;;527            if(husart->Init.Parity == USART_PARITY_NONE)
;;;528            {
;;;529              *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x01FF);
;;;530              pRxData +=2U;
;;;531            }
;;;532            else
;;;533            {
;;;534              *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x00FF);
;;;535              pRxData +=1U;
;;;536            }
;;;537          }
;;;538          else
;;;539          {
;;;540            /* Wait until TXE flag is set to send dummy byte in order to generate the clock for the slave to send data */
;;;541            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;542            {
;;;543              return HAL_TIMEOUT;
;;;544            }
;;;545    
;;;546            /* Send Dummy Byte in order to generate clock */
;;;547            husart->Instance->DR = (DUMMY_DATA & (uint16_t)0x00FF);
;;;548    
;;;549            /* Wait until RXNE flag is set to receive the byte */
;;;550            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;551            {
;;;552              return HAL_TIMEOUT;
;;;553            }
;;;554            if(husart->Init.Parity == USART_PARITY_NONE)
;;;555            {
;;;556              /* Receive data */
;;;557              *pRxData++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x00FF);
;;;558            }
;;;559            else
;;;560            {
;;;561              /* Receive data */
;;;562              *pRxData++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x007F);
;;;563            }
;;;564    
;;;565          }
;;;566        }
;;;567    
;;;568        husart->State = HAL_USART_STATE_READY;
;;;569    
;;;570        /* Process Unlocked */
;;;571        __HAL_UNLOCK(husart);
;;;572    
;;;573        return HAL_OK;
;;;574      }
;;;575      else
;;;576      {
;;;577        return HAL_BUSY;
;;;578      }
;;;579    }
00001c  e8bd8ff8          POPEQ    {r3-r11,pc}
000020  6be0              LDR      r0,[r4,#0x3c]         ;497
000022  2801              CMP      r0,#1                 ;497
000024  d064              BEQ      |L15.240|
000026  f04f0800          MOV      r8,#0                 ;499
00002a  2701              MOVS     r7,#1                 ;497
00002c  f8c48044          STR      r8,[r4,#0x44]         ;499
000030  63e7              STR      r7,[r4,#0x3c]         ;499
000032  2022              MOVS     r0,#0x22              ;500
000034  6420              STR      r0,[r4,#0x40]         ;500
000036  f7fffffe          BL       HAL_GetTick
00003a  f8a49030          STRH     r9,[r4,#0x30]         ;505
00003e  4683              MOV      r11,r0                ;503
000040  f8a49032          STRH     r9,[r4,#0x32]         ;506
000044  8e60              LDRH     r0,[r4,#0x32]         ;508
000046  2800              CMP      r0,#0                 ;508
000048  bf1c              ITT      NE                    ;519
00004a  f24019ff          MOVNE    r9,#0x1ff             ;519
00004e  f04f0aff          MOVNE    r10,#0xff             ;547
000052  d02f              BEQ      |L15.180|
                  |L15.84|
000054  8e60              LDRH     r0,[r4,#0x32]         ;510
000056  1e40              SUBS     r0,r0,#1              ;510
000058  8660              STRH     r0,[r4,#0x32]         ;510
00005a  68a0              LDR      r0,[r4,#8]            ;511
00005c  465b              MOV      r3,r11                ;541
00005e  f5b05f80          CMP      r0,#0x1000            ;511
000062  f04f0200          MOV      r2,#0                 ;541
000066  f04f0180          MOV      r1,#0x80              ;541
00006a  4620              MOV      r0,r4                 ;541
00006c  9600              STR      r6,[sp,#0]            ;511
00006e  d003              BEQ      |L15.120|
000070  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000074  b320              CBZ      r0,|L15.192|
000076  e02e              B        |L15.214|
                  |L15.120|
000078  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
00007c  bb58              CBNZ     r0,|L15.214|
00007e  6820              LDR      r0,[r4,#0]            ;519
000080  f8c09004          STR      r9,[r0,#4]            ;519
000084  465b              MOV      r3,r11                ;522
000086  2200              MOVS     r2,#0                 ;522
000088  2120              MOVS     r1,#0x20              ;522
00008a  4620              MOV      r0,r4                 ;522
00008c  9600              STR      r6,[sp,#0]            ;522
00008e  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000092  bb00              CBNZ     r0,|L15.214|
000094  6920              LDR      r0,[r4,#0x10]         ;527
000096  2800              CMP      r0,#0                 ;527
000098  6820              LDR      r0,[r4,#0]            ;534
00009a  6840              LDR      r0,[r0,#4]            ;534
00009c  bf14              ITE      NE                    ;534
00009e  b2c1              UXTBNE   r1,r0                 ;534
0000a0  f3c00108          UBFXEQ   r1,r0,#0,#9           ;529
0000a4  4628              MOV      r0,r5                 ;529
0000a6  8029              STRH     r1,[r5,#0]            ;529
0000a8  bf14              ITE      NE                    ;535
0000aa  1c45              ADDNE    r5,r0,#1              ;535
0000ac  1c85              ADDEQ    r5,r0,#2              ;530
                  |L15.174|
0000ae  8e60              LDRH     r0,[r4,#0x32]         ;562
0000b0  2800              CMP      r0,#0                 ;562
0000b2  d1cf              BNE      |L15.84|
                  |L15.180|
0000b4  6427              STR      r7,[r4,#0x40]         ;568
0000b6  2000              MOVS     r0,#0                 ;573
0000b8  f8c4803c          STR      r8,[r4,#0x3c]         ;573
0000bc  e8bd8ff8          POP      {r3-r11,pc}
                  |L15.192|
0000c0  6820              LDR      r0,[r4,#0]            ;547
0000c2  f8c0a004          STR      r10,[r0,#4]           ;547
0000c6  465b              MOV      r3,r11                ;550
0000c8  2200              MOVS     r2,#0                 ;550
0000ca  2120              MOVS     r1,#0x20              ;550
0000cc  4620              MOV      r0,r4                 ;550
0000ce  9600              STR      r6,[sp,#0]            ;550
0000d0  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
0000d4  b110              CBZ      r0,|L15.220|
                  |L15.214|
0000d6  2003              MOVS     r0,#3                 ;552
0000d8  e8bd8ff8          POP      {r3-r11,pc}
                  |L15.220|
0000dc  6920              LDR      r0,[r4,#0x10]         ;554
0000de  2800              CMP      r0,#0                 ;554
0000e0  6820              LDR      r0,[r4,#0]            ;562
0000e2  6840              LDR      r0,[r0,#4]            ;562
0000e4  bf18              IT       NE                    ;562
0000e6  f000007f          ANDNE    r0,r0,#0x7f           ;562
0000ea  f8050b01          STRB     r0,[r5],#1            ;557
0000ee  e7de              B        |L15.174|
                  |L15.240|
0000f0  2002              MOVS     r0,#2                 ;577
0000f2  e8bd8ff8          POP      {r3-r11,pc}
;;;580    
                          ENDP


                          AREA ||i.HAL_USART_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_USART_Receive_DMA PROC
;;;916      */
;;;917    HAL_StatusTypeDef HAL_USART_Receive_DMA(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;918    {
000002  4604              MOV      r4,r0
;;;919      uint32_t *tmp;
;;;920    
;;;921      if(husart->State == HAL_USART_STATE_READY)
000004  6c00              LDR      r0,[r0,#0x40]
000006  4616              MOV      r6,r2                 ;918
000008  460f              MOV      r7,r1                 ;918
00000a  2801              CMP      r0,#1
00000c  d14c              BNE      |L16.168|
;;;922      {
;;;923        if((pRxData == NULL) || (Size == 0))
00000e  2900              CMP      r1,#0
000010  bf12              ITEE     NE
000012  2e00              CMPNE    r6,#0
;;;924        {
;;;925          return HAL_ERROR;
000014  2001              MOVEQ    r0,#1
;;;926        }
;;;927    
;;;928        /* Process Locked */
;;;929        __HAL_LOCK(husart);
;;;930    
;;;931        husart->pRxBuffPtr = pRxData;
;;;932        husart->RxXferSize = Size;
;;;933        husart->pTxBuffPtr = pRxData;
;;;934        husart->TxXferSize = Size;
;;;935    
;;;936        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;937        husart->State = HAL_USART_STATE_BUSY_RX;
;;;938    
;;;939        /* Set the USART DMA Rx transfer complete callback */
;;;940        husart->hdmarx->XferCpltCallback = USART_DMAReceiveCplt;
;;;941    
;;;942        /* Set the USART DMA Half transfer complete callback */
;;;943        husart->hdmarx->XferHalfCpltCallback = USART_DMARxHalfCplt;
;;;944    
;;;945        /* Set the USART DMA Rx transfer error callback */
;;;946        husart->hdmarx->XferErrorCallback = USART_DMAError;
;;;947    
;;;948        /* Set the DMA abort callback */
;;;949        husart->hdmarx->XferAbortCallback = NULL;
;;;950    
;;;951        /* Set the USART Tx DMA transfer complete callback as NULL because the communication closing
;;;952        is performed in DMA reception complete callback  */
;;;953        husart->hdmatx->XferHalfCpltCallback = NULL;
;;;954        husart->hdmatx->XferCpltCallback = NULL;
;;;955    
;;;956        /* Set the DMA error callback */
;;;957        husart->hdmatx->XferErrorCallback = USART_DMAError;
;;;958    
;;;959        /* Set the DMA AbortCpltCallback */
;;;960        husart->hdmatx->XferAbortCallback = NULL;
;;;961    
;;;962        /* Enable the USART receive DMA Stream */
;;;963        tmp = (uint32_t*)&pRxData;
;;;964        HAL_DMA_Start_IT(husart->hdmarx, (uint32_t)&husart->Instance->DR, *(uint32_t*)tmp, Size);
;;;965    
;;;966        /* Enable the USART transmit DMA Stream: the transmit stream is used in order
;;;967           to generate in the non-blocking mode the clock to the slave device,
;;;968           this mode isn't a simplex receive mode but a full-duplex receive one */
;;;969        HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t*)tmp, (uint32_t)&husart->Instance->DR, Size);
;;;970    
;;;971        /* Clear the Overrun flag just before enabling the DMA Rx request: mandatory for the second transfer */
;;;972        __HAL_USART_CLEAR_OREFLAG(husart);
;;;973    
;;;974        /* Process Unlocked */
;;;975        __HAL_UNLOCK(husart);
;;;976    
;;;977        /* Enable the USART Parity Error Interrupt */
;;;978        SET_BIT(husart->Instance->CR1, USART_CR1_PEIE);
;;;979    
;;;980        /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;981        SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;982    
;;;983        /* Enable the DMA transfer for the receiver request by setting the DMAR bit
;;;984           in the USART CR3 register */
;;;985        SET_BIT(husart->Instance->CR3, USART_CR3_DMAR);
;;;986    
;;;987        /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;988           in the USART CR3 register */
;;;989        SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;990    
;;;991        return HAL_OK;
;;;992      }
;;;993      else
;;;994      {
;;;995        return HAL_BUSY;
;;;996      }
;;;997    }
000016  bdf8              POPEQ    {r3-r7,pc}
000018  6be0              LDR      r0,[r4,#0x3c]         ;929
00001a  2801              CMP      r0,#1                 ;929
00001c  d044              BEQ      |L16.168|
00001e  2001              MOVS     r0,#1                 ;929
000020  62e1              STR      r1,[r4,#0x2c]         ;932
000022  63e0              STR      r0,[r4,#0x3c]         ;932
000024  8626              STRH     r6,[r4,#0x30]         ;932
000026  6261              STR      r1,[r4,#0x24]         ;934
000028  8526              STRH     r6,[r4,#0x28]         ;934
00002a  2500              MOVS     r5,#0                 ;936
00002c  6465              STR      r5,[r4,#0x44]         ;936
00002e  2022              MOVS     r0,#0x22              ;937
000030  6420              STR      r0,[r4,#0x40]         ;937
000032  6ba2              LDR      r2,[r4,#0x38]         ;940
000034  481d              LDR      r0,|L16.172|
000036  4633              MOV      r3,r6                 ;964
000038  6410              STR      r0,[r2,#0x40]         ;943
00003a  6ba2              LDR      r2,[r4,#0x38]         ;943
00003c  481c              LDR      r0,|L16.176|
00003e  6450              STR      r0,[r2,#0x44]         ;946
000040  6ba2              LDR      r2,[r4,#0x38]         ;946
000042  481c              LDR      r0,|L16.180|
000044  6510              STR      r0,[r2,#0x50]         ;949
000046  6ba2              LDR      r2,[r4,#0x38]         ;949
000048  6555              STR      r5,[r2,#0x54]         ;953
00004a  6b62              LDR      r2,[r4,#0x34]         ;953
00004c  6455              STR      r5,[r2,#0x44]         ;954
00004e  6b62              LDR      r2,[r4,#0x34]         ;954
000050  6415              STR      r5,[r2,#0x40]         ;957
000052  6b62              LDR      r2,[r4,#0x34]         ;957
000054  6510              STR      r0,[r2,#0x50]         ;960
000056  6b60              LDR      r0,[r4,#0x34]         ;960
000058  460a              MOV      r2,r1                 ;960
00005a  6545              STR      r5,[r0,#0x54]         ;964
00005c  6820              LDR      r0,[r4,#0]            ;964
00005e  1d01              ADDS     r1,r0,#4              ;964
000060  6ba0              LDR      r0,[r4,#0x38]         ;964
000062  f7fffffe          BL       HAL_DMA_Start_IT
000066  6820              LDR      r0,[r4,#0]            ;969
000068  4639              MOV      r1,r7                 ;969
00006a  1d02              ADDS     r2,r0,#4              ;969
00006c  4633              MOV      r3,r6                 ;969
00006e  6b60              LDR      r0,[r4,#0x34]         ;969
000070  f7fffffe          BL       HAL_DMA_Start_IT
000074  6820              LDR      r0,[r4,#0]            ;972
000076  6801              LDR      r1,[r0,#0]            ;972
000078  6841              LDR      r1,[r0,#4]            ;972
00007a  9100              STR      r1,[sp,#0]            ;975
00007c  63e5              STR      r5,[r4,#0x3c]         ;978
00007e  68c1              LDR      r1,[r0,#0xc]          ;978
000080  f4417180          ORR      r1,r1,#0x100          ;978
000084  60c1              STR      r1,[r0,#0xc]          ;978
000086  6820              LDR      r0,[r4,#0]            ;981
000088  6941              LDR      r1,[r0,#0x14]         ;981
00008a  f0410101          ORR      r1,r1,#1              ;981
00008e  6141              STR      r1,[r0,#0x14]         ;981
000090  6820              LDR      r0,[r4,#0]            ;985
000092  6941              LDR      r1,[r0,#0x14]         ;985
000094  f0410140          ORR      r1,r1,#0x40           ;985
000098  6141              STR      r1,[r0,#0x14]         ;985
00009a  6820              LDR      r0,[r4,#0]            ;989
00009c  6941              LDR      r1,[r0,#0x14]         ;989
00009e  f0410180          ORR      r1,r1,#0x80           ;989
0000a2  6141              STR      r1,[r0,#0x14]         ;989
0000a4  2000              MOVS     r0,#0                 ;991
0000a6  bdf8              POP      {r3-r7,pc}
                  |L16.168|
0000a8  2002              MOVS     r0,#2                 ;995
0000aa  bdf8              POP      {r3-r7,pc}
;;;998    
                          ENDP

                  |L16.172|
                          DCD      USART_DMAReceiveCplt
                  |L16.176|
                          DCD      USART_DMARxHalfCplt
                  |L16.180|
                          DCD      USART_DMAError

                          AREA ||i.HAL_USART_Receive_IT||, CODE, READONLY, ALIGN=1

                  HAL_USART_Receive_IT PROC
;;;753      */
;;;754    HAL_StatusTypeDef HAL_USART_Receive_IT(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size)
000000  6c03              LDR      r3,[r0,#0x40]
;;;755    {
;;;756      if(husart->State == HAL_USART_STATE_READY)
000002  2b01              CMP      r3,#1
000004  d11f              BNE      |L17.70|
;;;757      {
;;;758        if((pRxData == NULL) || (Size == 0))
000006  2900              CMP      r1,#0
000008  bf12              ITEE     NE
00000a  2a00              CMPNE    r2,#0
;;;759        {
;;;760          return HAL_ERROR;
00000c  2001              MOVEQ    r0,#1
;;;761        }
;;;762        /* Process Locked */
;;;763        __HAL_LOCK(husart);
;;;764    
;;;765        husart->pRxBuffPtr = pRxData;
;;;766        husart->RxXferSize = Size;
;;;767        husart->RxXferCount = Size;
;;;768    
;;;769        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;770        husart->State = HAL_USART_STATE_BUSY_RX;
;;;771    
;;;772        /* Process Unlocked */
;;;773        __HAL_UNLOCK(husart);
;;;774    
;;;775        /* Enable the USART Parity Error and Data Register not empty Interrupts */
;;;776        SET_BIT(husart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
;;;777    
;;;778        /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;779        SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;780    
;;;781        /* Send dummy byte in order to generate the clock for the slave to send data */
;;;782        husart->Instance->DR = (DUMMY_DATA & (uint16_t)0x01FF);
;;;783    
;;;784        return HAL_OK;
;;;785      }
;;;786      else
;;;787      {
;;;788        return HAL_BUSY;
;;;789      }
;;;790    }
00000e  4770              BXEQ     lr
000010  6bc3              LDR      r3,[r0,#0x3c]         ;763
000012  2b01              CMP      r3,#1                 ;763
000014  d017              BEQ      |L17.70|
000016  62c1              STR      r1,[r0,#0x2c]         ;766
000018  8602              STRH     r2,[r0,#0x30]         ;766
00001a  8642              STRH     r2,[r0,#0x32]         ;767
00001c  2100              MOVS     r1,#0                 ;769
00001e  6441              STR      r1,[r0,#0x44]         ;769
000020  2222              MOVS     r2,#0x22              ;770
000022  6402              STR      r2,[r0,#0x40]         ;770
000024  63c1              STR      r1,[r0,#0x3c]         ;776
000026  6801              LDR      r1,[r0,#0]            ;776
000028  68ca              LDR      r2,[r1,#0xc]          ;776
00002a  f4427290          ORR      r2,r2,#0x120          ;776
00002e  60ca              STR      r2,[r1,#0xc]          ;776
000030  6801              LDR      r1,[r0,#0]            ;779
000032  694a              LDR      r2,[r1,#0x14]         ;779
000034  f0420201          ORR      r2,r2,#1              ;779
000038  614a              STR      r2,[r1,#0x14]         ;779
00003a  6800              LDR      r0,[r0,#0]            ;782
00003c  f24011ff          MOV      r1,#0x1ff             ;782
000040  6041              STR      r1,[r0,#4]            ;782
000042  2000              MOVS     r0,#0                 ;784
000044  4770              BX       lr
                  |L17.70|
000046  2002              MOVS     r0,#2                 ;788
000048  4770              BX       lr
;;;791    
                          ENDP


                          AREA ||i.HAL_USART_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_RxCpltCallback PROC
;;;1545     */
;;;1546   __weak void HAL_USART_RxCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1547   {
;;;1548     /* Prevent unused argument(s) compilation warning */
;;;1549     UNUSED(husart);
;;;1550     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1551              the HAL_USART_TxCpltCallback could be implemented in the user file
;;;1552      */
;;;1553   }
;;;1554   
                          ENDP


                          AREA ||i.HAL_USART_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_RxHalfCpltCallback PROC
;;;1560     */
;;;1561   __weak void HAL_USART_RxHalfCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1562   {
;;;1563     /* Prevent unused argument(s) compilation warning */
;;;1564     UNUSED(husart);
;;;1565     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1566              the HAL_USART_TxCpltCallback could be implemented in the user file
;;;1567      */
;;;1568   }
;;;1569   
                          ENDP


                          AREA ||i.HAL_USART_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_USART_Transmit PROC
;;;403      */
;;;404    HAL_StatusTypeDef HAL_USART_Transmit(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;405    {
000004  4604              MOV      r4,r0
;;;406      uint16_t* tmp;
;;;407      uint32_t tickstart = 0U;
;;;408    
;;;409      if(husart->State == HAL_USART_STATE_READY)
000006  6c00              LDR      r0,[r0,#0x40]
000008  461e              MOV      r6,r3                 ;405
00000a  4692              MOV      r10,r2                ;405
00000c  460d              MOV      r5,r1                 ;405
00000e  2801              CMP      r0,#1
000010  d152              BNE      |L20.184|
;;;410      {
;;;411        if((pTxData == NULL) || (Size == 0))
000012  2d00              CMP      r5,#0
000014  bf12              ITEE     NE
000016  f1ba0f00          CMPNE    r10,#0
;;;412        {
;;;413          return  HAL_ERROR;
00001a  2001              MOVEQ    r0,#1
;;;414        }
;;;415    
;;;416        /* Process Locked */
;;;417        __HAL_LOCK(husart);
;;;418    
;;;419        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;420        husart->State = HAL_USART_STATE_BUSY_TX;
;;;421    
;;;422        /* Init tickstart for timeout managment */
;;;423        tickstart = HAL_GetTick();
;;;424    
;;;425        husart->TxXferSize = Size;
;;;426        husart->TxXferCount = Size;
;;;427        while(husart->TxXferCount > 0U)
;;;428        {
;;;429          husart->TxXferCount--;
;;;430          if(husart->Init.WordLength == USART_WORDLENGTH_9B)
;;;431          {
;;;432            /* Wait for TC flag in order to write data in DR */
;;;433            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;434            {
;;;435              return HAL_TIMEOUT;
;;;436            }
;;;437            tmp = (uint16_t*) pTxData;
;;;438            husart->Instance->DR = (*tmp & (uint16_t)0x01FF);
;;;439            if(husart->Init.Parity == USART_PARITY_NONE)
;;;440            {
;;;441              pTxData += 2U;
;;;442            }
;;;443            else
;;;444            {
;;;445              pTxData += 1U;
;;;446            }
;;;447          }
;;;448          else
;;;449          {
;;;450            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;451            {
;;;452              return HAL_TIMEOUT;
;;;453            }
;;;454            husart->Instance->DR = (*pTxData++ & (uint8_t)0xFF);
;;;455          }
;;;456        }
;;;457    
;;;458        if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;459        {
;;;460          return HAL_TIMEOUT;
;;;461        }
;;;462    
;;;463        husart->State = HAL_USART_STATE_READY;
;;;464    
;;;465        /* Process Unlocked */
;;;466        __HAL_UNLOCK(husart);
;;;467    
;;;468        return HAL_OK;
;;;469      }
;;;470      else
;;;471      {
;;;472        return HAL_BUSY;
;;;473      }
;;;474    }
00001c  e8bd8ff8          POPEQ    {r3-r11,pc}
000020  6be0              LDR      r0,[r4,#0x3c]         ;417
000022  2801              CMP      r0,#1                 ;417
000024  d048              BEQ      |L20.184|
000026  f04f0800          MOV      r8,#0                 ;419
00002a  2701              MOVS     r7,#1                 ;417
00002c  f8c48044          STR      r8,[r4,#0x44]         ;419
000030  63e7              STR      r7,[r4,#0x3c]         ;419
000032  2012              MOVS     r0,#0x12              ;420
000034  6420              STR      r0,[r4,#0x40]         ;420
000036  f7fffffe          BL       HAL_GetTick
00003a  f8a4a028          STRH     r10,[r4,#0x28]        ;425
00003e  4681              MOV      r9,r0                 ;423
000040  f8a4a02a          STRH     r10,[r4,#0x2a]        ;426
000044  8d60              LDRH     r0,[r4,#0x2a]         ;427
000046  b330              CBZ      r0,|L20.150|
                  |L20.72|
000048  8d60              LDRH     r0,[r4,#0x2a]         ;429
00004a  1e40              SUBS     r0,r0,#1              ;429
00004c  8560              STRH     r0,[r4,#0x2a]         ;429
00004e  68a0              LDR      r0,[r4,#8]            ;430
000050  464b              MOV      r3,r9                 ;450
000052  f5b05f80          CMP      r0,#0x1000            ;430
000056  f04f0200          MOV      r2,#0                 ;450
00005a  f04f0180          MOV      r1,#0x80              ;450
00005e  4620              MOV      r0,r4                 ;450
000060  9600              STR      r6,[sp,#0]            ;430
000062  d003              BEQ      |L20.108|
000064  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000068  b170              CBZ      r0,|L20.136|
00006a  e01c              B        |L20.166|
                  |L20.108|
00006c  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000070  b9c8              CBNZ     r0,|L20.166|
000072  8828              LDRH     r0,[r5,#0]            ;438
000074  6821              LDR      r1,[r4,#0]            ;438
000076  f3c00008          UBFX     r0,r0,#0,#9           ;438
00007a  6048              STR      r0,[r1,#4]            ;438
00007c  6920              LDR      r0,[r4,#0x10]         ;439
00007e  2800              CMP      r0,#0                 ;439
000080  bf14              ITE      NE                    ;439
000082  1c6d              ADDNE    r5,r5,#1              ;439
000084  1cad              ADDEQ    r5,r5,#2              ;439
000086  e003              B        |L20.144|
                  |L20.136|
000088  6821              LDR      r1,[r4,#0]            ;454
00008a  f8150b01          LDRB     r0,[r5],#1            ;454
00008e  6048              STR      r0,[r1,#4]            ;454
                  |L20.144|
000090  8d60              LDRH     r0,[r4,#0x2a]         ;454
000092  2800              CMP      r0,#0                 ;454
000094  d1d8              BNE      |L20.72|
                  |L20.150|
000096  464b              MOV      r3,r9                 ;458
000098  2200              MOVS     r2,#0                 ;458
00009a  2140              MOVS     r1,#0x40              ;458
00009c  4620              MOV      r0,r4                 ;458
00009e  9600              STR      r6,[sp,#0]            ;458
0000a0  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
0000a4  b110              CBZ      r0,|L20.172|
                  |L20.166|
0000a6  2003              MOVS     r0,#3                 ;460
0000a8  e8bd8ff8          POP      {r3-r11,pc}
                  |L20.172|
0000ac  6427              STR      r7,[r4,#0x40]         ;463
0000ae  2000              MOVS     r0,#0                 ;468
0000b0  f8c4803c          STR      r8,[r4,#0x3c]         ;468
0000b4  e8bd8ff8          POP      {r3-r11,pc}
                  |L20.184|
0000b8  2002              MOVS     r0,#2                 ;472
0000ba  e8bd8ff8          POP      {r3-r11,pc}
;;;475    
                          ENDP


                          AREA ||i.HAL_USART_TransmitReceive||, CODE, READONLY, ALIGN=1

                  HAL_USART_TransmitReceive PROC
;;;590      */
;;;591    HAL_StatusTypeDef HAL_USART_TransmitReceive(USART_HandleTypeDef *husart, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;592    {
000004  4604              MOV      r4,r0
;;;593      uint16_t* tmp;
;;;594      uint32_t tickstart = 0U;
;;;595    
;;;596      if(husart->State == HAL_USART_STATE_READY)
000006  f8dd8028          LDR      r8,[sp,#0x28]
00000a  6c00              LDR      r0,[r0,#0x40]
00000c  461f              MOV      r7,r3                 ;592
00000e  4615              MOV      r5,r2                 ;592
000010  460e              MOV      r6,r1                 ;592
000012  2801              CMP      r0,#1
000014  d17d              BNE      |L21.274|
;;;597      {
;;;598        if((pTxData == NULL) || (pRxData == NULL) || (Size == 0))
000016  2e00              CMP      r6,#0
000018  bf19              ITTEE    NE
00001a  2d00              CMPNE    r5,#0
00001c  2f00              CMPNE    r7,#0
;;;599        {
;;;600          return  HAL_ERROR;
00001e  2001              MOVEQ    r0,#1
;;;601        }
;;;602        /* Process Locked */
;;;603        __HAL_LOCK(husart);
;;;604    
;;;605        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;606        husart->State = HAL_USART_STATE_BUSY_RX;
;;;607    
;;;608        /* Init tickstart for timeout managment */
;;;609        tickstart = HAL_GetTick();
;;;610    
;;;611        husart->RxXferSize = Size;
;;;612        husart->TxXferSize = Size;
;;;613        husart->TxXferCount = Size;
;;;614        husart->RxXferCount = Size;
;;;615    
;;;616        /* Check the remain data to be received */
;;;617        while(husart->TxXferCount > 0U)
;;;618        {
;;;619          husart->TxXferCount--;
;;;620          husart->RxXferCount--;
;;;621          if(husart->Init.WordLength == USART_WORDLENGTH_9B)
;;;622          {
;;;623            /* Wait for TC flag in order to write data in DR */
;;;624            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;625            {
;;;626              return HAL_TIMEOUT;
;;;627            }
;;;628            tmp = (uint16_t*) pTxData;
;;;629            husart->Instance->DR = (*tmp & (uint16_t)0x01FF);
;;;630            if(husart->Init.Parity == USART_PARITY_NONE)
;;;631            {
;;;632              pTxData += 2U;
;;;633            }
;;;634            else
;;;635            {
;;;636              pTxData += 1U;
;;;637            }
;;;638    
;;;639            /* Wait for RXNE Flag */
;;;640            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;641            {
;;;642              return HAL_TIMEOUT;
;;;643            }
;;;644            tmp = (uint16_t*) pRxData ;
;;;645            if(husart->Init.Parity == USART_PARITY_NONE)
;;;646            {
;;;647              *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x01FF);
;;;648              pRxData += 2U;
;;;649            }
;;;650            else
;;;651            {
;;;652              *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x00FF);
;;;653              pRxData += 1U;
;;;654            }
;;;655          }
;;;656          else
;;;657          {
;;;658            /* Wait for TC flag in order to write data in DR */
;;;659            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;660            {
;;;661              return HAL_TIMEOUT;
;;;662            }
;;;663            husart->Instance->DR = (*pTxData++ & (uint8_t)0x00FF);
;;;664    
;;;665            /* Wait for RXNE Flag */
;;;666            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;667            {
;;;668              return HAL_TIMEOUT;
;;;669            }
;;;670            if(husart->Init.Parity == USART_PARITY_NONE)
;;;671            {
;;;672              /* Receive data */
;;;673              *pRxData++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x00FF);
;;;674            }
;;;675            else
;;;676            {
;;;677              /* Receive data */
;;;678              *pRxData++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x007F);
;;;679            }
;;;680          }
;;;681        }
;;;682    
;;;683        husart->State = HAL_USART_STATE_READY;
;;;684    
;;;685        /* Process Unlocked */
;;;686        __HAL_UNLOCK(husart);
;;;687    
;;;688        return HAL_OK;
;;;689      }
;;;690      else
;;;691      {
;;;692        return HAL_BUSY;
;;;693      }
;;;694    }
000020  e8bd8ff8          POPEQ    {r3-r11,pc}
000024  6be0              LDR      r0,[r4,#0x3c]         ;603
000026  2801              CMP      r0,#1                 ;603
000028  d073              BEQ      |L21.274|
00002a  f04f0a00          MOV      r10,#0                ;605
00002e  f04f0901          MOV      r9,#1                 ;603
000032  f8c4a044          STR      r10,[r4,#0x44]        ;605
000036  f8c4903c          STR      r9,[r4,#0x3c]         ;605
00003a  2022              MOVS     r0,#0x22              ;606
00003c  6420              STR      r0,[r4,#0x40]         ;606
00003e  f7fffffe          BL       HAL_GetTick
000042  8627              STRH     r7,[r4,#0x30]         ;611
000044  8527              STRH     r7,[r4,#0x28]         ;612
000046  4683              MOV      r11,r0                ;609
000048  8567              STRH     r7,[r4,#0x2a]         ;613
00004a  8667              STRH     r7,[r4,#0x32]         ;614
00004c  8d60              LDRH     r0,[r4,#0x2a]         ;617
00004e  2800              CMP      r0,#0                 ;617
000050  d03d              BEQ      |L21.206|
                  |L21.82|
000052  8d60              LDRH     r0,[r4,#0x2a]         ;619
000054  1e40              SUBS     r0,r0,#1              ;619
000056  8560              STRH     r0,[r4,#0x2a]         ;619
000058  8e60              LDRH     r0,[r4,#0x32]         ;620
00005a  1e40              SUBS     r0,r0,#1              ;620
00005c  8660              STRH     r0,[r4,#0x32]         ;620
00005e  68a0              LDR      r0,[r4,#8]            ;621
000060  465b              MOV      r3,r11                ;659
000062  f5b05f80          CMP      r0,#0x1000            ;621
000066  f04f0200          MOV      r2,#0                 ;659
00006a  f04f0180          MOV      r1,#0x80              ;659
00006e  4620              MOV      r0,r4                 ;659
000070  f8cd8000          STR      r8,[sp,#0]            ;621
000074  d004              BEQ      |L21.128|
000076  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
00007a  2800              CMP      r0,#0                 ;659
00007c  d02e              BEQ      |L21.220|
00007e  e03a              B        |L21.246|
                  |L21.128|
000080  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000084  2800              CMP      r0,#0                 ;624
000086  d136              BNE      |L21.246|
000088  8830              LDRH     r0,[r6,#0]            ;629
00008a  6821              LDR      r1,[r4,#0]            ;629
00008c  f3c00008          UBFX     r0,r0,#0,#9           ;629
000090  6048              STR      r0,[r1,#4]            ;629
000092  6920              LDR      r0,[r4,#0x10]         ;630
000094  2800              CMP      r0,#0                 ;630
000096  bf14              ITE      NE                    ;630
000098  1c76              ADDNE    r6,r6,#1              ;630
00009a  1cb6              ADDEQ    r6,r6,#2              ;630
00009c  465b              MOV      r3,r11                ;640
00009e  2200              MOVS     r2,#0                 ;640
0000a0  2120              MOVS     r1,#0x20              ;640
0000a2  4620              MOV      r0,r4                 ;640
0000a4  f8cd8000          STR      r8,[sp,#0]            ;640
0000a8  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
0000ac  bb18              CBNZ     r0,|L21.246|
0000ae  6920              LDR      r0,[r4,#0x10]         ;645
0000b0  2800              CMP      r0,#0                 ;645
0000b2  6820              LDR      r0,[r4,#0]            ;652
0000b4  6840              LDR      r0,[r0,#4]            ;652
0000b6  bf14              ITE      NE                    ;652
0000b8  b2c1              UXTBNE   r1,r0                 ;652
0000ba  f3c00108          UBFXEQ   r1,r0,#0,#9           ;647
0000be  4628              MOV      r0,r5                 ;647
0000c0  8029              STRH     r1,[r5,#0]            ;647
0000c2  bf14              ITE      NE                    ;653
0000c4  1c45              ADDNE    r5,r0,#1              ;653
0000c6  1c85              ADDEQ    r5,r0,#2              ;648
                  |L21.200|
0000c8  8d60              LDRH     r0,[r4,#0x2a]         ;678
0000ca  2800              CMP      r0,#0                 ;678
0000cc  d1c1              BNE      |L21.82|
                  |L21.206|
0000ce  f8c49040          STR      r9,[r4,#0x40]         ;683
0000d2  2000              MOVS     r0,#0                 ;688
0000d4  f8c4a03c          STR      r10,[r4,#0x3c]        ;688
0000d8  e8bd8ff8          POP      {r3-r11,pc}
                  |L21.220|
0000dc  6821              LDR      r1,[r4,#0]            ;663
0000de  f8160b01          LDRB     r0,[r6],#1            ;663
0000e2  6048              STR      r0,[r1,#4]            ;663
0000e4  465b              MOV      r3,r11                ;666
0000e6  2200              MOVS     r2,#0                 ;666
0000e8  2120              MOVS     r1,#0x20              ;666
0000ea  4620              MOV      r0,r4                 ;666
0000ec  f8cd8000          STR      r8,[sp,#0]            ;666
0000f0  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
0000f4  b118              CBZ      r0,|L21.254|
                  |L21.246|
0000f6  2003              MOVS     r0,#3                 ;668
0000f8  e8bd8ff8          POP      {r3-r11,pc}
0000fc  e009              B        |L21.274|
                  |L21.254|
0000fe  6920              LDR      r0,[r4,#0x10]         ;670
000100  2800              CMP      r0,#0                 ;670
000102  6820              LDR      r0,[r4,#0]            ;678
000104  6840              LDR      r0,[r0,#4]            ;678
000106  bf18              IT       NE                    ;678
000108  f000007f          ANDNE    r0,r0,#0x7f           ;678
00010c  f8050b01          STRB     r0,[r5],#1            ;673
000110  e7da              B        |L21.200|
                  |L21.274|
000112  2002              MOVS     r0,#2                 ;692
000114  e8bd8ff8          POP      {r3-r11,pc}
;;;695    
                          ENDP


                          AREA ||i.HAL_USART_TransmitReceive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_USART_TransmitReceive_DMA PROC
;;;1008     */
;;;1009   HAL_StatusTypeDef HAL_USART_TransmitReceive_DMA(USART_HandleTypeDef *husart, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1010   {
000002  4604              MOV      r4,r0
;;;1011     uint32_t *tmp;
;;;1012   
;;;1013     if(husart->State == HAL_USART_STATE_READY)
000004  6c00              LDR      r0,[r0,#0x40]
000006  461e              MOV      r6,r3                 ;1010
000008  460d              MOV      r5,r1                 ;1010
00000a  2801              CMP      r0,#1
00000c  d150              BNE      |L22.176|
;;;1014     {
;;;1015       if((pTxData == NULL) || (pRxData == NULL) || (Size == 0))
00000e  2d00              CMP      r5,#0
000010  bf19              ITTEE    NE
000012  2a00              CMPNE    r2,#0
000014  2e00              CMPNE    r6,#0
;;;1016       {
;;;1017         return HAL_ERROR;
000016  2001              MOVEQ    r0,#1
;;;1018       }
;;;1019       /* Process Locked */
;;;1020       __HAL_LOCK(husart);
;;;1021   
;;;1022       husart->pRxBuffPtr = pRxData;
;;;1023       husart->RxXferSize = Size;
;;;1024       husart->pTxBuffPtr = pTxData;
;;;1025       husart->TxXferSize = Size;
;;;1026   
;;;1027       husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;1028       husart->State = HAL_USART_STATE_BUSY_TX_RX;
;;;1029   
;;;1030       /* Set the USART DMA Rx transfer complete callback */
;;;1031       husart->hdmarx->XferCpltCallback = USART_DMAReceiveCplt;
;;;1032   
;;;1033       /* Set the USART DMA Half transfer complete callback */
;;;1034       husart->hdmarx->XferHalfCpltCallback = USART_DMARxHalfCplt;
;;;1035   
;;;1036       /* Set the USART DMA Tx transfer complete callback */
;;;1037       husart->hdmatx->XferCpltCallback = USART_DMATransmitCplt;
;;;1038   
;;;1039       /* Set the USART DMA Half transfer complete callback */
;;;1040       husart->hdmatx->XferHalfCpltCallback = USART_DMATxHalfCplt;
;;;1041   
;;;1042       /* Set the USART DMA Tx transfer error callback */
;;;1043       husart->hdmatx->XferErrorCallback = USART_DMAError;
;;;1044   
;;;1045       /* Set the USART DMA Rx transfer error callback */
;;;1046       husart->hdmarx->XferErrorCallback = USART_DMAError;
;;;1047   
;;;1048       /* Set the DMA abort callback */
;;;1049       husart->hdmarx->XferAbortCallback = NULL;
;;;1050   
;;;1051       /* Enable the USART receive DMA Stream */
;;;1052       tmp = (uint32_t*)&pRxData;
;;;1053       HAL_DMA_Start_IT(husart->hdmarx, (uint32_t)&husart->Instance->DR, *(uint32_t*)tmp, Size);
;;;1054   
;;;1055       /* Enable the USART transmit DMA Stream */
;;;1056       tmp = (uint32_t*)&pTxData;
;;;1057       HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t*)tmp, (uint32_t)&husart->Instance->DR, Size);
;;;1058   
;;;1059       /* Clear the TC flag in the SR register by writing 0 to it */
;;;1060       __HAL_USART_CLEAR_FLAG(husart, USART_FLAG_TC);
;;;1061   
;;;1062       /* Clear the Overrun flag: mandatory for the second transfer in circular mode */
;;;1063       __HAL_USART_CLEAR_OREFLAG(husart);
;;;1064   
;;;1065       /* Process Unlocked */
;;;1066       __HAL_UNLOCK(husart);
;;;1067   
;;;1068       /* Enable the USART Parity Error Interrupt */
;;;1069       SET_BIT(husart->Instance->CR1, USART_CR1_PEIE);
;;;1070   
;;;1071       /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1072       SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;1073   
;;;1074       /* Enable the DMA transfer for the receiver request by setting the DMAR bit
;;;1075          in the USART CR3 register */
;;;1076       SET_BIT(husart->Instance->CR3, USART_CR3_DMAR);
;;;1077   
;;;1078       /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;1079          in the USART CR3 register */
;;;1080       SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1081   
;;;1082       return HAL_OK;
;;;1083     }
;;;1084     else
;;;1085     {
;;;1086       return HAL_BUSY;
;;;1087     }
;;;1088   }
000018  bdf8              POPEQ    {r3-r7,pc}
00001a  6be0              LDR      r0,[r4,#0x3c]         ;1020
00001c  2801              CMP      r0,#1                 ;1020
00001e  d047              BEQ      |L22.176|
000020  2001              MOVS     r0,#1                 ;1020
000022  62e2              STR      r2,[r4,#0x2c]         ;1023
000024  63e0              STR      r0,[r4,#0x3c]         ;1023
000026  8626              STRH     r6,[r4,#0x30]         ;1023
000028  6265              STR      r5,[r4,#0x24]         ;1025
00002a  8526              STRH     r6,[r4,#0x28]         ;1025
00002c  2700              MOVS     r7,#0                 ;1027
00002e  6467              STR      r7,[r4,#0x44]         ;1027
000030  2032              MOVS     r0,#0x32              ;1028
000032  6420              STR      r0,[r4,#0x40]         ;1028
000034  6ba1              LDR      r1,[r4,#0x38]         ;1031
000036  481f              LDR      r0,|L22.180|
000038  4633              MOV      r3,r6                 ;1053
00003a  6408              STR      r0,[r1,#0x40]         ;1034
00003c  6ba1              LDR      r1,[r4,#0x38]         ;1034
00003e  481e              LDR      r0,|L22.184|
000040  6448              STR      r0,[r1,#0x44]         ;1037
000042  6b61              LDR      r1,[r4,#0x34]         ;1037
000044  481d              LDR      r0,|L22.188|
000046  6408              STR      r0,[r1,#0x40]         ;1040
000048  6b61              LDR      r1,[r4,#0x34]         ;1040
00004a  481d              LDR      r0,|L22.192|
00004c  6448              STR      r0,[r1,#0x44]         ;1043
00004e  6b61              LDR      r1,[r4,#0x34]         ;1043
000050  481c              LDR      r0,|L22.196|
000052  6508              STR      r0,[r1,#0x50]         ;1046
000054  6ba1              LDR      r1,[r4,#0x38]         ;1046
000056  6508              STR      r0,[r1,#0x50]         ;1049
000058  6ba0              LDR      r0,[r4,#0x38]         ;1049
00005a  6547              STR      r7,[r0,#0x54]         ;1053
00005c  6820              LDR      r0,[r4,#0]            ;1053
00005e  1d01              ADDS     r1,r0,#4              ;1053
000060  6ba0              LDR      r0,[r4,#0x38]         ;1053
000062  f7fffffe          BL       HAL_DMA_Start_IT
000066  6820              LDR      r0,[r4,#0]            ;1057
000068  4629              MOV      r1,r5                 ;1057
00006a  1d02              ADDS     r2,r0,#4              ;1057
00006c  4633              MOV      r3,r6                 ;1057
00006e  6b60              LDR      r0,[r4,#0x34]         ;1057
000070  f7fffffe          BL       HAL_DMA_Start_IT
000074  6821              LDR      r1,[r4,#0]            ;1060
000076  f06f0040          MVN      r0,#0x40              ;1060
00007a  6008              STR      r0,[r1,#0]            ;1060
00007c  6820              LDR      r0,[r4,#0]            ;1063
00007e  6801              LDR      r1,[r0,#0]            ;1063
000080  6841              LDR      r1,[r0,#4]            ;1063
000082  9100              STR      r1,[sp,#0]            ;1066
000084  63e7              STR      r7,[r4,#0x3c]         ;1069
000086  68c1              LDR      r1,[r0,#0xc]          ;1069
000088  f4417180          ORR      r1,r1,#0x100          ;1069
00008c  60c1              STR      r1,[r0,#0xc]          ;1069
00008e  6820              LDR      r0,[r4,#0]            ;1072
000090  6941              LDR      r1,[r0,#0x14]         ;1072
000092  f0410101          ORR      r1,r1,#1              ;1072
000096  6141              STR      r1,[r0,#0x14]         ;1072
000098  6820              LDR      r0,[r4,#0]            ;1076
00009a  6941              LDR      r1,[r0,#0x14]         ;1076
00009c  f0410140          ORR      r1,r1,#0x40           ;1076
0000a0  6141              STR      r1,[r0,#0x14]         ;1076
0000a2  6820              LDR      r0,[r4,#0]            ;1080
0000a4  6941              LDR      r1,[r0,#0x14]         ;1080
0000a6  f0410180          ORR      r1,r1,#0x80           ;1080
0000aa  6141              STR      r1,[r0,#0x14]         ;1080
0000ac  2000              MOVS     r0,#0                 ;1082
0000ae  bdf8              POP      {r3-r7,pc}
                  |L22.176|
0000b0  2002              MOVS     r0,#2                 ;1086
0000b2  bdf8              POP      {r3-r7,pc}
;;;1089   
                          ENDP

                  |L22.180|
                          DCD      USART_DMAReceiveCplt
                  |L22.184|
                          DCD      USART_DMARxHalfCplt
                  |L22.188|
                          DCD      USART_DMATransmitCplt
                  |L22.192|
                          DCD      USART_DMATxHalfCplt
                  |L22.196|
                          DCD      USART_DMAError

                          AREA ||i.HAL_USART_TransmitReceive_IT||, CODE, READONLY, ALIGN=1

                  HAL_USART_TransmitReceive_IT PROC
;;;800      */
;;;801    HAL_StatusTypeDef HAL_USART_TransmitReceive_IT(USART_HandleTypeDef *husart, uint8_t *pTxData, uint8_t *pRxData,  uint16_t Size)
000000  f8d0c040          LDR      r12,[r0,#0x40]
;;;802    {
;;;803      if(husart->State == HAL_USART_STATE_READY)
000004  f1bc0f01          CMP      r12,#1
000008  d12b              BNE      |L23.98|
;;;804      {
;;;805        if((pTxData == NULL) || (pRxData == NULL) || (Size == 0))
00000a  2900              CMP      r1,#0
00000c  bf19              ITTEE    NE
00000e  2a00              CMPNE    r2,#0
000010  2b00              CMPNE    r3,#0
;;;806        {
;;;807          return HAL_ERROR;
000012  2001              MOVEQ    r0,#1
;;;808        }
;;;809        /* Process Locked */
;;;810        __HAL_LOCK(husart);
;;;811    
;;;812        husart->pRxBuffPtr = pRxData;
;;;813        husart->RxXferSize = Size;
;;;814        husart->RxXferCount = Size;
;;;815        husart->pTxBuffPtr = pTxData;
;;;816        husart->TxXferSize = Size;
;;;817        husart->TxXferCount = Size;
;;;818    
;;;819        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;820        husart->State = HAL_USART_STATE_BUSY_TX_RX;
;;;821    
;;;822        /* Process Unlocked */
;;;823        __HAL_UNLOCK(husart);
;;;824    
;;;825        /* Enable the USART Data Register not empty Interrupt */
;;;826        SET_BIT(husart->Instance->CR1, USART_CR1_RXNEIE);
;;;827    
;;;828        /* Enable the USART Parity Error Interrupt */
;;;829        SET_BIT(husart->Instance->CR1, USART_CR1_PEIE);
;;;830    
;;;831        /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;832        SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;833    
;;;834        /* Enable the USART Transmit Data Register Empty Interrupt */
;;;835        SET_BIT(husart->Instance->CR1, USART_CR1_TXEIE);
;;;836    
;;;837        return HAL_OK;
;;;838      }
;;;839      else
;;;840      {
;;;841        return HAL_BUSY;
;;;842      }
;;;843    }
000014  4770              BXEQ     lr
000016  f8d0c03c          LDR      r12,[r0,#0x3c]        ;810
00001a  f1bc0f01          CMP      r12,#1                ;810
00001e  d020              BEQ      |L23.98|
000020  62c2              STR      r2,[r0,#0x2c]         ;813
000022  8603              STRH     r3,[r0,#0x30]         ;813
000024  8643              STRH     r3,[r0,#0x32]         ;814
000026  6241              STR      r1,[r0,#0x24]         ;816
000028  8503              STRH     r3,[r0,#0x28]         ;816
00002a  8543              STRH     r3,[r0,#0x2a]         ;817
00002c  2100              MOVS     r1,#0                 ;819
00002e  6441              STR      r1,[r0,#0x44]         ;819
000030  2232              MOVS     r2,#0x32              ;820
000032  6402              STR      r2,[r0,#0x40]         ;820
000034  63c1              STR      r1,[r0,#0x3c]         ;826
000036  6801              LDR      r1,[r0,#0]            ;826
000038  68ca              LDR      r2,[r1,#0xc]          ;826
00003a  f0420220          ORR      r2,r2,#0x20           ;826
00003e  60ca              STR      r2,[r1,#0xc]          ;826
000040  6801              LDR      r1,[r0,#0]            ;829
000042  68ca              LDR      r2,[r1,#0xc]          ;829
000044  f4427280          ORR      r2,r2,#0x100          ;829
000048  60ca              STR      r2,[r1,#0xc]          ;829
00004a  6801              LDR      r1,[r0,#0]            ;832
00004c  694a              LDR      r2,[r1,#0x14]         ;832
00004e  f0420201          ORR      r2,r2,#1              ;832
000052  614a              STR      r2,[r1,#0x14]         ;832
000054  6800              LDR      r0,[r0,#0]            ;835
000056  68c1              LDR      r1,[r0,#0xc]          ;835
000058  f0410180          ORR      r1,r1,#0x80           ;835
00005c  60c1              STR      r1,[r0,#0xc]          ;835
00005e  2000              MOVS     r0,#0                 ;837
000060  4770              BX       lr
                  |L23.98|
000062  2002              MOVS     r0,#2                 ;841
000064  4770              BX       lr
;;;844    
                          ENDP


                          AREA ||i.HAL_USART_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_USART_Transmit_DMA PROC
;;;852      */
;;;853    HAL_StatusTypeDef HAL_USART_Transmit_DMA(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;854    {
000002  4604              MOV      r4,r0
;;;855      uint32_t *tmp;
;;;856    
;;;857      if(husart->State == HAL_USART_STATE_READY)
000004  6c00              LDR      r0,[r0,#0x40]
000006  2801              CMP      r0,#1
000008  d12f              BNE      |L24.106|
;;;858      {
;;;859        if((pTxData == NULL) || (Size == 0))
00000a  2900              CMP      r1,#0
00000c  bf12              ITEE     NE
00000e  2a00              CMPNE    r2,#0
;;;860        {
;;;861          return HAL_ERROR;
000010  2001              MOVEQ    r0,#1
;;;862        }
;;;863        /* Process Locked */
;;;864        __HAL_LOCK(husart);
;;;865    
;;;866        husart->pTxBuffPtr = pTxData;
;;;867        husart->TxXferSize = Size;
;;;868        husart->TxXferCount = Size;
;;;869    
;;;870        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;871        husart->State = HAL_USART_STATE_BUSY_TX;
;;;872    
;;;873        /* Set the USART DMA transfer complete callback */
;;;874        husart->hdmatx->XferCpltCallback = USART_DMATransmitCplt;
;;;875    
;;;876        /* Set the USART DMA Half transfer complete callback */
;;;877        husart->hdmatx->XferHalfCpltCallback = USART_DMATxHalfCplt;
;;;878    
;;;879        /* Set the DMA error callback */
;;;880        husart->hdmatx->XferErrorCallback = USART_DMAError;
;;;881    
;;;882        /* Set the DMA abort callback */
;;;883        husart->hdmatx->XferAbortCallback = NULL;
;;;884    
;;;885        /* Enable the USART transmit DMA Stream */
;;;886        tmp = (uint32_t*)&pTxData;
;;;887        HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t*)tmp, (uint32_t)&husart->Instance->DR, Size);
;;;888    
;;;889        /* Clear the TC flag in the SR register by writing 0 to it */
;;;890        __HAL_USART_CLEAR_FLAG(husart, USART_FLAG_TC);
;;;891    
;;;892        /* Process Unlocked */
;;;893        __HAL_UNLOCK(husart);
;;;894    
;;;895        /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;896        in the USART CR3 register */
;;;897        SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;898    
;;;899        return HAL_OK;
;;;900      }
;;;901      else
;;;902      {
;;;903        return HAL_BUSY;
;;;904      }
;;;905    }
000012  bd70              POPEQ    {r4-r6,pc}
000014  6be0              LDR      r0,[r4,#0x3c]         ;864
000016  2801              CMP      r0,#1                 ;864
000018  d027              BEQ      |L24.106|
00001a  2001              MOVS     r0,#1                 ;864
00001c  6261              STR      r1,[r4,#0x24]         ;867
00001e  63e0              STR      r0,[r4,#0x3c]         ;867
000020  8522              STRH     r2,[r4,#0x28]         ;867
000022  8562              STRH     r2,[r4,#0x2a]         ;868
000024  2500              MOVS     r5,#0                 ;870
000026  6465              STR      r5,[r4,#0x44]         ;870
000028  2012              MOVS     r0,#0x12              ;871
00002a  6420              STR      r0,[r4,#0x40]         ;871
00002c  6b63              LDR      r3,[r4,#0x34]         ;874
00002e  4810              LDR      r0,|L24.112|
000030  6418              STR      r0,[r3,#0x40]         ;877
000032  6b63              LDR      r3,[r4,#0x34]         ;877
000034  480f              LDR      r0,|L24.116|
000036  6458              STR      r0,[r3,#0x44]         ;880
000038  6b63              LDR      r3,[r4,#0x34]         ;880
00003a  480f              LDR      r0,|L24.120|
00003c  6518              STR      r0,[r3,#0x50]         ;883
00003e  6b60              LDR      r0,[r4,#0x34]         ;883
000040  4613              MOV      r3,r2                 ;887
000042  6545              STR      r5,[r0,#0x54]         ;887
000044  6820              LDR      r0,[r4,#0]            ;887
000046  f1000c04          ADD      r12,r0,#4             ;887
00004a  4662              MOV      r2,r12                ;887
00004c  6b60              LDR      r0,[r4,#0x34]         ;887
00004e  f7fffffe          BL       HAL_DMA_Start_IT
000052  6821              LDR      r1,[r4,#0]            ;890
000054  f06f0040          MVN      r0,#0x40              ;890
000058  6008              STR      r0,[r1,#0]            ;890
00005a  63e5              STR      r5,[r4,#0x3c]         ;897
00005c  6820              LDR      r0,[r4,#0]            ;897
00005e  6941              LDR      r1,[r0,#0x14]         ;897
000060  f0410180          ORR      r1,r1,#0x80           ;897
000064  6141              STR      r1,[r0,#0x14]         ;897
000066  2000              MOVS     r0,#0                 ;899
000068  bd70              POP      {r4-r6,pc}
                  |L24.106|
00006a  2002              MOVS     r0,#2                 ;903
00006c  bd70              POP      {r4-r6,pc}
;;;906    
                          ENDP

00006e  0000              DCW      0x0000
                  |L24.112|
                          DCD      USART_DMATransmitCplt
                  |L24.116|
                          DCD      USART_DMATxHalfCplt
                  |L24.120|
                          DCD      USART_DMAError

                          AREA ||i.HAL_USART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  HAL_USART_Transmit_IT PROC
;;;704      */
;;;705    HAL_StatusTypeDef HAL_USART_Transmit_IT(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size)
000000  6c03              LDR      r3,[r0,#0x40]
;;;706    {
;;;707      if(husart->State == HAL_USART_STATE_READY)
000002  2b01              CMP      r3,#1
000004  d116              BNE      |L25.52|
;;;708      {
;;;709        if((pTxData == NULL) || (Size == 0))
000006  2900              CMP      r1,#0
000008  bf12              ITEE     NE
00000a  2a00              CMPNE    r2,#0
;;;710        {
;;;711          return HAL_ERROR;
00000c  2001              MOVEQ    r0,#1
;;;712        }
;;;713    
;;;714        /* Process Locked */
;;;715        __HAL_LOCK(husart);
;;;716    
;;;717        husart->pTxBuffPtr = pTxData;
;;;718        husart->TxXferSize = Size;
;;;719        husart->TxXferCount = Size;
;;;720    
;;;721        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;722        husart->State = HAL_USART_STATE_BUSY_TX;
;;;723    
;;;724        /* The USART Error Interrupts: (Frame error, Noise error, Overrun error)
;;;725           are not managed by the USART transmit process to avoid the overrun interrupt
;;;726           when the USART mode is configured for transmit and receive "USART_MODE_TX_RX"
;;;727           to benefit for the frame error and noise interrupts the USART mode should be
;;;728           configured only for transmit "USART_MODE_TX"
;;;729           The __HAL_USART_ENABLE_IT(husart, USART_IT_ERR) can be used to enable the Frame error,
;;;730           Noise error interrupt */
;;;731    
;;;732        /* Process Unlocked */
;;;733        __HAL_UNLOCK(husart);
;;;734    
;;;735        /* Enable the USART Transmit Data Register Empty Interrupt */
;;;736        SET_BIT(husart->Instance->CR1, USART_CR1_TXEIE);
;;;737    
;;;738        return HAL_OK;
;;;739      }
;;;740      else
;;;741      {
;;;742        return HAL_BUSY;
;;;743      }
;;;744    }
00000e  4770              BXEQ     lr
000010  6bc3              LDR      r3,[r0,#0x3c]         ;715
000012  2b01              CMP      r3,#1                 ;715
000014  d00e              BEQ      |L25.52|
000016  6241              STR      r1,[r0,#0x24]         ;718
000018  8502              STRH     r2,[r0,#0x28]         ;718
00001a  8542              STRH     r2,[r0,#0x2a]         ;719
00001c  2100              MOVS     r1,#0                 ;721
00001e  6441              STR      r1,[r0,#0x44]         ;721
000020  2212              MOVS     r2,#0x12              ;722
000022  6402              STR      r2,[r0,#0x40]         ;722
000024  63c1              STR      r1,[r0,#0x3c]         ;736
000026  6800              LDR      r0,[r0,#0]            ;736
000028  68c1              LDR      r1,[r0,#0xc]          ;736
00002a  f0410180          ORR      r1,r1,#0x80           ;736
00002e  60c1              STR      r1,[r0,#0xc]          ;736
000030  2000              MOVS     r0,#0                 ;738
000032  4770              BX       lr
                  |L25.52|
000034  2002              MOVS     r0,#2                 ;742
000036  4770              BX       lr
;;;745    
                          ENDP


                          AREA ||i.HAL_USART_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_TxCpltCallback PROC
;;;1515     */
;;;1516    __weak void HAL_USART_TxCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1517   {
;;;1518     /* Prevent unused argument(s) compilation warning */
;;;1519     UNUSED(husart);
;;;1520     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1521              the HAL_USART_TxCpltCallback could be implemented in the user file
;;;1522      */
;;;1523   }
;;;1524   
                          ENDP


                          AREA ||i.HAL_USART_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_TxHalfCpltCallback PROC
;;;1530     */
;;;1531    __weak void HAL_USART_TxHalfCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1532   {
;;;1533     /* Prevent unused argument(s) compilation warning */
;;;1534     UNUSED(husart);
;;;1535     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1536              the HAL_USART_TxCpltCallback could be implemented in the user file
;;;1537      */
;;;1538   }
;;;1539   
                          ENDP


                          AREA ||i.HAL_USART_TxRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_TxRxCpltCallback PROC
;;;1575     */
;;;1576   __weak void HAL_USART_TxRxCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1577   {
;;;1578     /* Prevent unused argument(s) compilation warning */
;;;1579     UNUSED(husart);
;;;1580     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1581              the HAL_USART_TxCpltCallback could be implemented in the user file
;;;1582      */
;;;1583   }
;;;1584   
                          ENDP


                          AREA ||i.USART_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  USART_DMAAbortOnError PROC
;;;1882     */
;;;1883   static void USART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1884   {
;;;1885     USART_HandleTypeDef* husart = ( USART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;1886     husart->RxXferCount = 0x00U;
000004  2100              MOVS     r1,#0
000006  8641              STRH     r1,[r0,#0x32]
;;;1887     husart->TxXferCount = 0x00U;
000008  8541              STRH     r1,[r0,#0x2a]
;;;1888   
;;;1889     HAL_USART_ErrorCallback(husart);
00000a  f7fffffe          BL       HAL_USART_ErrorCallback
;;;1890   }
00000e  bd10              POP      {r4,pc}
;;;1891   
                          ENDP


                          AREA ||i.USART_DMAError||, CODE, READONLY, ALIGN=1

                  USART_DMAError PROC
;;;1776     */
;;;1777   static void USART_DMAError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1778   {
;;;1779     uint32_t dmarequest = 0x00U;
;;;1780     USART_HandleTypeDef* husart = ( USART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;1781     husart->RxXferCount = 0x00U;
000004  2100              MOVS     r1,#0
000006  8641              STRH     r1,[r0,#0x32]
;;;1782     husart->TxXferCount = 0x00U;
000008  8541              STRH     r1,[r0,#0x2a]
;;;1783   
;;;1784     /* Stop USART DMA Tx request if ongoing */
;;;1785     dmarequest = HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT);
00000a  6802              LDR      r2,[r0,#0]
00000c  6951              LDR      r1,[r2,#0x14]
;;;1786     if((husart->State == HAL_USART_STATE_BUSY_TX) && dmarequest)
00000e  f8d0c040          LDR      r12,[r0,#0x40]
000012  f3c113c0          UBFX     r3,r1,#7,#1           ;1785
000016  2101              MOVS     r1,#1                 ;1785
000018  f1bc0f12          CMP      r12,#0x12
00001c  d105              BNE      |L30.42|
00001e  b123              CBZ      r3,|L30.42|
000020  68d3              LDR      r3,[r2,#0xc]
000022  f02303c0          BIC      r3,r3,#0xc0
000026  60d3              STR      r3,[r2,#0xc]
000028  6401              STR      r1,[r0,#0x40]
                  |L30.42|
;;;1787     {
;;;1788       USART_EndTxTransfer(husart);
;;;1789     }
;;;1790   
;;;1791     /* Stop USART DMA Rx request if ongoing */
;;;1792     dmarequest = HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR);
00002a  6802              LDR      r2,[r0,#0]
00002c  6953              LDR      r3,[r2,#0x14]
;;;1793     if((husart->State == HAL_USART_STATE_BUSY_RX) && dmarequest)
00002e  f8d0c040          LDR      r12,[r0,#0x40]
000032  f3c31380          UBFX     r3,r3,#6,#1           ;1792
000036  f1bc0f22          CMP      r12,#0x22
00003a  d10a              BNE      |L30.82|
00003c  b14b              CBZ      r3,|L30.82|
00003e  68d3              LDR      r3,[r2,#0xc]
000040  f4237390          BIC      r3,r3,#0x120
000044  60d3              STR      r3,[r2,#0xc]
000046  6802              LDR      r2,[r0,#0]
000048  6953              LDR      r3,[r2,#0x14]
00004a  f0230301          BIC      r3,r3,#1
00004e  6153              STR      r3,[r2,#0x14]
000050  6401              STR      r1,[r0,#0x40]
                  |L30.82|
;;;1794     {
;;;1795       USART_EndRxTransfer(husart);
;;;1796     }
;;;1797   
;;;1798     husart->ErrorCode |= HAL_USART_ERROR_DMA;
000052  6c42              LDR      r2,[r0,#0x44]
000054  f0420210          ORR      r2,r2,#0x10
000058  6442              STR      r2,[r0,#0x44]
;;;1799     husart->State= HAL_USART_STATE_READY;
00005a  6401              STR      r1,[r0,#0x40]
;;;1800   
;;;1801     HAL_USART_ErrorCallback(husart);
00005c  f7fffffe          BL       HAL_USART_ErrorCallback
;;;1802   }
000060  bd10              POP      {r4,pc}
;;;1803   
                          ENDP


                          AREA ||i.USART_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  USART_DMAReceiveCplt PROC
;;;1713     */
;;;1714   static void USART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1715   {
000002  4601              MOV      r1,r0
;;;1716     USART_HandleTypeDef* husart = ( USART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bc0              LDR      r0,[r0,#0x3c]
;;;1717     /* DMA Normal mode */
;;;1718     if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
000006  6809              LDR      r1,[r1,#0]
000008  6809              LDR      r1,[r1,#0]
00000a  f4117f80          TST      r1,#0x100
00000e  d003              BEQ      |L31.24|
;;;1719     {
;;;1720       husart->RxXferCount = 0x00U;
;;;1721   
;;;1722       /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1723       CLEAR_BIT(husart->Instance->CR1, USART_CR1_PEIE);
;;;1724       CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;1725   
;;;1726       /* Disable the DMA transfer for the Transmit/receiver request by clearing the DMAT/DMAR bit
;;;1727          in the USART CR3 register */
;;;1728       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
;;;1729       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1730   
;;;1731       husart->State= HAL_USART_STATE_READY;
;;;1732   
;;;1733       /* The USART state is HAL_USART_STATE_BUSY_RX */
;;;1734       if(husart->State == HAL_USART_STATE_BUSY_RX)
;;;1735       {
;;;1736         HAL_USART_RxCpltCallback(husart);
;;;1737       }
;;;1738       /* The USART state is HAL_USART_STATE_BUSY_TX_RX */
;;;1739       else
;;;1740       {
;;;1741         HAL_USART_TxRxCpltCallback(husart);
;;;1742       }
;;;1743     }
;;;1744     /* DMA circular mode */
;;;1745     else
;;;1746     {
;;;1747       if(husart->State == HAL_USART_STATE_BUSY_RX)
000010  6c01              LDR      r1,[r0,#0x40]
000012  2922              CMP      r1,#0x22
000014  d11b              BNE      |L31.78|
000016  e01d              B        |L31.84|
                  |L31.24|
000018  2100              MOVS     r1,#0                 ;1720
00001a  8641              STRH     r1,[r0,#0x32]         ;1720
00001c  6801              LDR      r1,[r0,#0]            ;1723
00001e  68ca              LDR      r2,[r1,#0xc]          ;1723
000020  f4227280          BIC      r2,r2,#0x100          ;1723
000024  60ca              STR      r2,[r1,#0xc]          ;1723
000026  6801              LDR      r1,[r0,#0]            ;1724
000028  694a              LDR      r2,[r1,#0x14]         ;1724
00002a  f0220201          BIC      r2,r2,#1              ;1724
00002e  614a              STR      r2,[r1,#0x14]         ;1724
000030  6801              LDR      r1,[r0,#0]            ;1728
000032  694a              LDR      r2,[r1,#0x14]         ;1728
000034  f0220240          BIC      r2,r2,#0x40           ;1728
000038  614a              STR      r2,[r1,#0x14]         ;1728
00003a  6801              LDR      r1,[r0,#0]            ;1729
00003c  694a              LDR      r2,[r1,#0x14]         ;1729
00003e  f0220280          BIC      r2,r2,#0x80           ;1729
000042  614a              STR      r2,[r1,#0x14]         ;1729
000044  2101              MOVS     r1,#1                 ;1731
000046  6401              STR      r1,[r0,#0x40]         ;1731
000048  6c01              LDR      r1,[r0,#0x40]         ;1734
00004a  2922              CMP      r1,#0x22              ;1734
00004c  d002              BEQ      |L31.84|
                  |L31.78|
00004e  f7fffffe          BL       HAL_USART_TxRxCpltCallback
;;;1748       {
;;;1749         HAL_USART_RxCpltCallback(husart);
;;;1750       }
;;;1751       /* The USART state is HAL_USART_STATE_BUSY_TX_RX */
;;;1752       else
;;;1753       {
;;;1754         HAL_USART_TxRxCpltCallback(husart);
;;;1755       }
;;;1756     }
;;;1757   }
000052  bd10              POP      {r4,pc}
                  |L31.84|
000054  f7fffffe          BL       HAL_USART_RxCpltCallback
000058  bd10              POP      {r4,pc}
;;;1758   
                          ENDP


                          AREA ||i.USART_DMARxAbortCallback||, CODE, READONLY, ALIGN=1

                  USART_DMARxAbortCallback PROC
;;;1936     */
;;;1937   static void USART_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1938   {
;;;1939     USART_HandleTypeDef* husart = ( USART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;1940     
;;;1941     husart->hdmarx->XferAbortCallback = NULL;
000004  2100              MOVS     r1,#0
000006  6b82              LDR      r2,[r0,#0x38]
;;;1942   
;;;1943     /* Check if an Abort process is still ongoing */
;;;1944     if(husart->hdmatx != NULL)
000008  6551              STR      r1,[r2,#0x54]
00000a  6b42              LDR      r2,[r0,#0x34]
00000c  2a00              CMP      r2,#0
;;;1945     {
;;;1946       if(husart->hdmatx->XferAbortCallback != NULL)
00000e  bf1e              ITTT     NE
000010  6d52              LDRNE    r2,[r2,#0x54]
000012  2a00              CMPNE    r2,#0
;;;1947       {
;;;1948         return;
;;;1949       }
;;;1950     }
;;;1951     
;;;1952     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;1953     husart->TxXferCount = 0x00U;
;;;1954     husart->RxXferCount = 0x00U;
;;;1955   
;;;1956     /* Reset errorCode */
;;;1957     husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;1958   
;;;1959     /* Restore husart->State to Ready */
;;;1960     husart->State  = HAL_USART_STATE_READY;
;;;1961   
;;;1962     /* Call user Abort complete callback */
;;;1963     HAL_USART_AbortCpltCallback(husart);
;;;1964   }
000014  bd10              POPNE    {r4,pc}
000016  8541              STRH     r1,[r0,#0x2a]         ;1953
000018  8641              STRH     r1,[r0,#0x32]         ;1954
00001a  6441              STR      r1,[r0,#0x44]         ;1957
00001c  2101              MOVS     r1,#1                 ;1960
00001e  6401              STR      r1,[r0,#0x40]         ;1960
000020  f7fffffe          BL       HAL_USART_AbortCpltCallback
000024  bd10              POP      {r4,pc}
;;;1965   
                          ENDP


                          AREA ||i.USART_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  USART_DMARxHalfCplt PROC
;;;1764     */
;;;1765   static void USART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1766   {
;;;1767     USART_HandleTypeDef* husart = (USART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;1768   
;;;1769     HAL_USART_RxHalfCpltCallback(husart);
000004  f7fffffe          BL       HAL_USART_RxHalfCpltCallback
;;;1770   }
000008  bd10              POP      {r4,pc}
;;;1771   
                          ENDP


                          AREA ||i.USART_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  USART_DMATransmitCplt PROC
;;;1668     */
;;;1669   static void USART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1670   {
000002  4601              MOV      r1,r0
;;;1671     USART_HandleTypeDef* husart = ( USART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bc0              LDR      r0,[r0,#0x3c]
;;;1672     /* DMA Normal mode */
;;;1673     if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
000006  6809              LDR      r1,[r1,#0]
000008  6809              LDR      r1,[r1,#0]
00000a  f4117f80          TST      r1,#0x100
00000e  d005              BEQ      |L34.28|
;;;1674     {
;;;1675       husart->TxXferCount = 0U;
;;;1676       if(husart->State == HAL_USART_STATE_BUSY_TX)
;;;1677       {
;;;1678         /* Disable the DMA transfer for transmit request by resetting the DMAT bit
;;;1679            in the USART CR3 register */
;;;1680         CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1681   
;;;1682         /* Enable the USART Transmit Complete Interrupt */
;;;1683         SET_BIT(husart->Instance->CR1, USART_CR1_TCIE);
;;;1684       }
;;;1685     }
;;;1686     /* DMA Circular mode */
;;;1687     else
;;;1688     {
;;;1689       if(husart->State == HAL_USART_STATE_BUSY_TX)
000010  6c01              LDR      r1,[r0,#0x40]
000012  2912              CMP      r1,#0x12
;;;1690       {
;;;1691         HAL_USART_TxCpltCallback(husart);
000014  bf08              IT       EQ
000016  f7fffffe          BLEQ     HAL_USART_TxCpltCallback
;;;1692       }
;;;1693     }
;;;1694   }
00001a  bd10              POP      {r4,pc}
                  |L34.28|
00001c  2100              MOVS     r1,#0                 ;1675
00001e  8541              STRH     r1,[r0,#0x2a]         ;1675
000020  6c01              LDR      r1,[r0,#0x40]         ;1676
000022  2912              CMP      r1,#0x12              ;1676
000024  bf18              IT       NE
000026  bd10              POPNE    {r4,pc}
000028  6801              LDR      r1,[r0,#0]            ;1680
00002a  694a              LDR      r2,[r1,#0x14]         ;1680
00002c  f0220280          BIC      r2,r2,#0x80           ;1680
000030  614a              STR      r2,[r1,#0x14]         ;1680
000032  6800              LDR      r0,[r0,#0]            ;1683
000034  68c1              LDR      r1,[r0,#0xc]          ;1683
000036  f0410140          ORR      r1,r1,#0x40           ;1683
00003a  60c1              STR      r1,[r0,#0xc]          ;1683
00003c  bd10              POP      {r4,pc}
;;;1695   
                          ENDP


                          AREA ||i.USART_DMATxAbortCallback||, CODE, READONLY, ALIGN=1

                  USART_DMATxAbortCallback PROC
;;;1899     */
;;;1900   static void USART_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1901   {
;;;1902     USART_HandleTypeDef* husart = ( USART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;1903     
;;;1904     husart->hdmatx->XferAbortCallback = NULL;
000004  2100              MOVS     r1,#0
000006  6b42              LDR      r2,[r0,#0x34]
;;;1905   
;;;1906     /* Check if an Abort process is still ongoing */
;;;1907     if(husart->hdmarx != NULL)
000008  6551              STR      r1,[r2,#0x54]
00000a  6b82              LDR      r2,[r0,#0x38]
00000c  2a00              CMP      r2,#0
;;;1908     {
;;;1909       if(husart->hdmarx->XferAbortCallback != NULL)
00000e  bf1e              ITTT     NE
000010  6d52              LDRNE    r2,[r2,#0x54]
000012  2a00              CMPNE    r2,#0
;;;1910       {
;;;1911         return;
;;;1912       }
;;;1913     }
;;;1914     
;;;1915     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;1916     husart->TxXferCount = 0x00U;
;;;1917     husart->RxXferCount = 0x00U;
;;;1918   
;;;1919     /* Reset errorCode */
;;;1920     husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;1921   
;;;1922     /* Restore husart->State to Ready */
;;;1923     husart->State  = HAL_USART_STATE_READY;
;;;1924   
;;;1925     /* Call user Abort complete callback */
;;;1926     HAL_USART_AbortCpltCallback(husart);
;;;1927   }
000014  bd10              POPNE    {r4,pc}
000016  8541              STRH     r1,[r0,#0x2a]         ;1916
000018  8641              STRH     r1,[r0,#0x32]         ;1917
00001a  6441              STR      r1,[r0,#0x44]         ;1920
00001c  2101              MOVS     r1,#1                 ;1923
00001e  6401              STR      r1,[r0,#0x40]         ;1923
000020  f7fffffe          BL       HAL_USART_AbortCpltCallback
000024  bd10              POP      {r4,pc}
;;;1928   
                          ENDP


                          AREA ||i.USART_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  USART_DMATxHalfCplt PROC
;;;1701     */
;;;1702   static void USART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1703   {
;;;1704     USART_HandleTypeDef* husart = (USART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;1705   
;;;1706     HAL_USART_TxHalfCpltCallback(husart);
000004  f7fffffe          BL       HAL_USART_TxHalfCpltCallback
;;;1707   }
000008  bd10              POP      {r4,pc}
;;;1708   
                          ENDP


                          AREA ||i.USART_Receive_IT||, CODE, READONLY, ALIGN=1

                  USART_Receive_IT PROC
;;;2039     */
;;;2040   static HAL_StatusTypeDef USART_Receive_IT(USART_HandleTypeDef *husart)
000000  b510              PUSH     {r4,lr}
;;;2041   {
;;;2042     uint16_t* tmp;
;;;2043     if(husart->State == HAL_USART_STATE_BUSY_RX)
000002  6c01              LDR      r1,[r0,#0x40]
000004  2922              CMP      r1,#0x22
;;;2044     {
;;;2045       if(husart->Init.WordLength == USART_WORDLENGTH_9B)
;;;2046       {
;;;2047         tmp = (uint16_t*) husart->pRxBuffPtr;
;;;2048         if(husart->Init.Parity == USART_PARITY_NONE)
;;;2049         {
;;;2050           *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x01FF);
;;;2051           husart->pRxBuffPtr += 2U;
;;;2052         }
;;;2053         else
;;;2054         {
;;;2055           *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x00FF);
;;;2056           husart->pRxBuffPtr += 1U;
;;;2057         }
;;;2058         if(--husart->RxXferCount != 0x00U)
;;;2059         {
;;;2060           /* Send dummy byte in order to generate the clock for the slave to send the next data */
;;;2061           husart->Instance->DR = (DUMMY_DATA & (uint16_t)0x01FF);
;;;2062         }
;;;2063       }
;;;2064       else
;;;2065       {
;;;2066         if(husart->Init.Parity == USART_PARITY_NONE)
;;;2067         {
;;;2068           *husart->pRxBuffPtr++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x00FF);
;;;2069         }
;;;2070         else
;;;2071         {
;;;2072           *husart->pRxBuffPtr++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x007F);
;;;2073         }
;;;2074   
;;;2075         if(--husart->RxXferCount != 0x00U)
;;;2076         {
;;;2077           /* Send dummy byte in order to generate the clock for the slave to send the next data */
;;;2078           husart->Instance->DR = (DUMMY_DATA & (uint16_t)0x00FF);
;;;2079         }
;;;2080       }
;;;2081   
;;;2082       if(husart->RxXferCount == 0U)
;;;2083       {
;;;2084         /* Disable the USART RXNE Interrupt */
;;;2085         CLEAR_BIT(husart->Instance->CR1, USART_CR1_RXNEIE);
;;;2086   
;;;2087         /* Disable the USART Parity Error Interrupt */
;;;2088         CLEAR_BIT(husart->Instance->CR1, USART_CR1_PEIE);
;;;2089   
;;;2090         /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;2091         CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;2092   
;;;2093         husart->State = HAL_USART_STATE_READY;
;;;2094         HAL_USART_RxCpltCallback(husart);
;;;2095   
;;;2096         return HAL_OK;
;;;2097       }
;;;2098       return HAL_OK;
;;;2099     }
;;;2100     else
;;;2101     {
;;;2102       return HAL_BUSY;
000006  bf1c              ITT      NE
000008  2002              MOVNE    r0,#2
;;;2103     }
;;;2104   }
00000a  bd10              POPNE    {r4,pc}
00000c  6881              LDR      r1,[r0,#8]            ;2045
00000e  f5b15f80          CMP      r1,#0x1000            ;2045
000012  d02d              BEQ      |L37.112|
000014  6901              LDR      r1,[r0,#0x10]         ;2066
000016  2900              CMP      r1,#0                 ;2066
000018  6801              LDR      r1,[r0,#0]            ;2066
00001a  d043              BEQ      |L37.164|
00001c  6849              LDR      r1,[r1,#4]            ;2072
00001e  f001027f          AND      r2,r1,#0x7f           ;2072
000022  6ac1              LDR      r1,[r0,#0x2c]         ;2072
000024  1c4b              ADDS     r3,r1,#1              ;2072
000026  62c3              STR      r3,[r0,#0x2c]         ;2072
000028  700a              STRB     r2,[r1,#0]            ;2072
                  |L37.42|
00002a  8e41              LDRH     r1,[r0,#0x32]         ;2075
00002c  1e49              SUBS     r1,r1,#1              ;2075
00002e  0409              LSLS     r1,r1,#16             ;2075
000030  0c09              LSRS     r1,r1,#16             ;2075
000032  8641              STRH     r1,[r0,#0x32]         ;2075
000034  d002              BEQ      |L37.60|
000036  6802              LDR      r2,[r0,#0]            ;2078
000038  21ff              MOVS     r1,#0xff              ;2078
00003a  6051              STR      r1,[r2,#4]            ;2078
                  |L37.60|
00003c  8e41              LDRH     r1,[r0,#0x32]         ;2082
00003e  2900              CMP      r1,#0                 ;2082
000040  bf1c              ITT      NE                    ;2098
000042  2000              MOVNE    r0,#0                 ;2098
000044  bd10              POPNE    {r4,pc}
000046  6801              LDR      r1,[r0,#0]            ;2085
000048  68ca              LDR      r2,[r1,#0xc]          ;2085
00004a  f0220220          BIC      r2,r2,#0x20           ;2085
00004e  60ca              STR      r2,[r1,#0xc]          ;2085
000050  6801              LDR      r1,[r0,#0]            ;2088
000052  68ca              LDR      r2,[r1,#0xc]          ;2088
000054  f4227280          BIC      r2,r2,#0x100          ;2088
000058  60ca              STR      r2,[r1,#0xc]          ;2088
00005a  6801              LDR      r1,[r0,#0]            ;2091
00005c  694a              LDR      r2,[r1,#0x14]         ;2091
00005e  f0220201          BIC      r2,r2,#1              ;2091
000062  614a              STR      r2,[r1,#0x14]         ;2091
000064  2101              MOVS     r1,#1                 ;2093
000066  6401              STR      r1,[r0,#0x40]         ;2093
000068  f7fffffe          BL       HAL_USART_RxCpltCallback
00006c  2000              MOVS     r0,#0                 ;2096
00006e  bd10              POP      {r4,pc}
                  |L37.112|
000070  6902              LDR      r2,[r0,#0x10]         ;2048
000072  6ac1              LDR      r1,[r0,#0x2c]         ;2048
000074  2a00              CMP      r2,#0                 ;2048
000076  6802              LDR      r2,[r0,#0]            ;2055
000078  6852              LDR      r2,[r2,#4]            ;2055
00007a  bf14              ITE      NE                    ;2055
00007c  b2d2              UXTBNE   r2,r2                 ;2055
00007e  f3c20208          UBFXEQ   r2,r2,#0,#9           ;2050
000082  800a              STRH     r2,[r1,#0]            ;2050
000084  6ac1              LDR      r1,[r0,#0x2c]         ;2051
000086  bf14              ITE      NE                    ;2051
000088  1c49              ADDNE    r1,r1,#1              ;2051
00008a  1c89              ADDEQ    r1,r1,#2              ;2051
00008c  62c1              STR      r1,[r0,#0x2c]         ;2058
00008e  8e41              LDRH     r1,[r0,#0x32]         ;2058
000090  1e49              SUBS     r1,r1,#1              ;2058
000092  0409              LSLS     r1,r1,#16             ;2058
000094  0c09              LSRS     r1,r1,#16             ;2058
000096  8641              STRH     r1,[r0,#0x32]         ;2058
000098  d0d0              BEQ      |L37.60|
00009a  6802              LDR      r2,[r0,#0]            ;2061
00009c  f24011ff          MOV      r1,#0x1ff             ;2061
0000a0  6051              STR      r1,[r2,#4]            ;2061
0000a2  e7cb              B        |L37.60|
                  |L37.164|
0000a4  684a              LDR      r2,[r1,#4]            ;2068
0000a6  6ac1              LDR      r1,[r0,#0x2c]         ;2068
0000a8  1c4b              ADDS     r3,r1,#1              ;2068
0000aa  62c3              STR      r3,[r0,#0x2c]         ;2068
0000ac  700a              STRB     r2,[r1,#0]            ;2068
0000ae  e7bc              B        |L37.42|
;;;2105   
                          ENDP


                          AREA ||i.USART_TransmitReceive_IT||, CODE, READONLY, ALIGN=1

                  USART_TransmitReceive_IT PROC
;;;2111     */
;;;2112   static HAL_StatusTypeDef USART_TransmitReceive_IT(USART_HandleTypeDef *husart)
000000  b510              PUSH     {r4,lr}
;;;2113   {
;;;2114     uint16_t* tmp;
;;;2115   
;;;2116     if(husart->State == HAL_USART_STATE_BUSY_TX_RX)
000002  6c01              LDR      r1,[r0,#0x40]
000004  2932              CMP      r1,#0x32
;;;2117     {
;;;2118       if(husart->TxXferCount != 0x00U)
;;;2119       {
;;;2120         if(__HAL_USART_GET_FLAG(husart, USART_FLAG_TXE) != RESET)
;;;2121         {
;;;2122           if(husart->Init.WordLength == USART_WORDLENGTH_9B)
;;;2123           {
;;;2124             tmp = (uint16_t*) husart->pTxBuffPtr;
;;;2125             husart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
;;;2126             if(husart->Init.Parity == USART_PARITY_NONE)
;;;2127             {
;;;2128               husart->pTxBuffPtr += 2U;
;;;2129             }
;;;2130             else
;;;2131             {
;;;2132               husart->pTxBuffPtr += 1U;
;;;2133             }
;;;2134           }
;;;2135           else
;;;2136           {
;;;2137             husart->Instance->DR = (uint8_t)(*husart->pTxBuffPtr++ & (uint8_t)0x00FF);
;;;2138           }
;;;2139           husart->TxXferCount--;
;;;2140   
;;;2141           /* Check the latest data transmitted */
;;;2142           if(husart->TxXferCount == 0U)
;;;2143           {
;;;2144             CLEAR_BIT(husart->Instance->CR1, USART_CR1_TXEIE);
;;;2145           }
;;;2146         }
;;;2147       }
;;;2148   
;;;2149       if(husart->RxXferCount != 0x00U)
;;;2150       {
;;;2151         if(__HAL_USART_GET_FLAG(husart, USART_FLAG_RXNE) != RESET)
;;;2152         {
;;;2153           if(husart->Init.WordLength == USART_WORDLENGTH_9B)
;;;2154           {
;;;2155             tmp = (uint16_t*) husart->pRxBuffPtr;
;;;2156             if(husart->Init.Parity == USART_PARITY_NONE)
;;;2157             {
;;;2158               *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x01FF);
;;;2159               husart->pRxBuffPtr += 2U;
;;;2160             }
;;;2161             else
;;;2162             {
;;;2163               *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x00FF);
;;;2164               husart->pRxBuffPtr += 1U;
;;;2165             }
;;;2166           }
;;;2167           else
;;;2168           {
;;;2169             if(husart->Init.Parity == USART_PARITY_NONE)
;;;2170             {
;;;2171               *husart->pRxBuffPtr++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x00FF);
;;;2172             }
;;;2173             else
;;;2174             {
;;;2175               *husart->pRxBuffPtr++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x007F);
;;;2176             }
;;;2177           }
;;;2178           husart->RxXferCount--;
;;;2179         }
;;;2180       }
;;;2181   
;;;2182       /* Check the latest data received */
;;;2183       if(husart->RxXferCount == 0U)
;;;2184       {
;;;2185         /* Disable the USART RXNE Interrupt */
;;;2186         CLEAR_BIT(husart->Instance->CR1, USART_CR1_RXNEIE);
;;;2187   
;;;2188         /* Disable the USART Parity Error Interrupt */
;;;2189         CLEAR_BIT(husart->Instance->CR1, USART_CR1_PEIE);
;;;2190   
;;;2191         /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;2192         CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;2193   
;;;2194         husart->State = HAL_USART_STATE_READY;
;;;2195   
;;;2196         HAL_USART_TxRxCpltCallback(husart);
;;;2197   
;;;2198         return HAL_OK;
;;;2199       }
;;;2200   
;;;2201       return HAL_OK;
;;;2202     }
;;;2203     else
;;;2204     {
;;;2205       return HAL_BUSY;
000006  bf1c              ITT      NE
000008  2002              MOVNE    r0,#2
;;;2206     }
;;;2207   }
00000a  bd10              POPNE    {r4,pc}
00000c  8d41              LDRH     r1,[r0,#0x2a]         ;2118
00000e  b321              CBZ      r1,|L38.90|
000010  6801              LDR      r1,[r0,#0]            ;2120
000012  680a              LDR      r2,[r1,#0]            ;2120
000014  f0120f80          TST      r2,#0x80              ;2120
000018  d01f              BEQ      |L38.90|
00001a  6882              LDR      r2,[r0,#8]            ;2122
00001c  f5b25f80          CMP      r2,#0x1000            ;2122
000020  6a42              LDR      r2,[r0,#0x24]         ;2122
000022  d009              BEQ      |L38.56|
000024  1c53              ADDS     r3,r2,#1              ;2137
000026  6243              STR      r3,[r0,#0x24]         ;2137
000028  7812              LDRB     r2,[r2,#0]            ;2137
00002a  604a              STR      r2,[r1,#4]            ;2137
                  |L38.44|
00002c  8d41              LDRH     r1,[r0,#0x2a]         ;2139
00002e  1e49              SUBS     r1,r1,#1              ;2139
000030  8541              STRH     r1,[r0,#0x2a]         ;2139
000032  8d41              LDRH     r1,[r0,#0x2a]         ;2142
000034  b989              CBNZ     r1,|L38.90|
000036  e00b              B        |L38.80|
                  |L38.56|
000038  8812              LDRH     r2,[r2,#0]            ;2125
00003a  f3c20208          UBFX     r2,r2,#0,#9           ;2125
00003e  604a              STR      r2,[r1,#4]            ;2125
000040  6901              LDR      r1,[r0,#0x10]         ;2126
000042  2900              CMP      r1,#0                 ;2126
000044  6a41              LDR      r1,[r0,#0x24]         ;2132
000046  bf14              ITE      NE                    ;2132
000048  1c49              ADDNE    r1,r1,#1              ;2132
00004a  1c89              ADDEQ    r1,r1,#2              ;2132
00004c  6241              STR      r1,[r0,#0x24]         ;2126
00004e  e7ed              B        |L38.44|
                  |L38.80|
000050  6801              LDR      r1,[r0,#0]            ;2144
000052  68ca              LDR      r2,[r1,#0xc]          ;2144
000054  f0220280          BIC      r2,r2,#0x80           ;2144
000058  60ca              STR      r2,[r1,#0xc]          ;2144
                  |L38.90|
00005a  8e41              LDRH     r1,[r0,#0x32]         ;2149
00005c  b1a9              CBZ      r1,|L38.138|
00005e  6801              LDR      r1,[r0,#0]            ;2151
000060  680a              LDR      r2,[r1,#0]            ;2151
000062  f0120f20          TST      r2,#0x20              ;2151
000066  d010              BEQ      |L38.138|
000068  6882              LDR      r2,[r0,#8]            ;2153
00006a  f5b25f80          CMP      r2,#0x1000            ;2153
00006e  d026              BEQ      |L38.190|
000070  6902              LDR      r2,[r0,#0x10]         ;2169
000072  2a00              CMP      r2,#0                 ;2169
000074  d032              BEQ      |L38.220|
000076  6849              LDR      r1,[r1,#4]            ;2175
000078  f001027f          AND      r2,r1,#0x7f           ;2175
00007c  6ac1              LDR      r1,[r0,#0x2c]         ;2175
00007e  1c4b              ADDS     r3,r1,#1              ;2175
000080  62c3              STR      r3,[r0,#0x2c]         ;2175
000082  700a              STRB     r2,[r1,#0]            ;2175
                  |L38.132|
000084  8e41              LDRH     r1,[r0,#0x32]         ;2178
000086  1e49              SUBS     r1,r1,#1              ;2178
000088  8641              STRH     r1,[r0,#0x32]         ;2178
                  |L38.138|
00008a  8e41              LDRH     r1,[r0,#0x32]         ;2183
00008c  2900              CMP      r1,#0                 ;2183
00008e  bf1c              ITT      NE                    ;2201
000090  2000              MOVNE    r0,#0                 ;2201
000092  bd10              POPNE    {r4,pc}
000094  6801              LDR      r1,[r0,#0]            ;2186
000096  68ca              LDR      r2,[r1,#0xc]          ;2186
000098  f0220220          BIC      r2,r2,#0x20           ;2186
00009c  60ca              STR      r2,[r1,#0xc]          ;2186
00009e  6801              LDR      r1,[r0,#0]            ;2189
0000a0  68ca              LDR      r2,[r1,#0xc]          ;2189
0000a2  f4227280          BIC      r2,r2,#0x100          ;2189
0000a6  60ca              STR      r2,[r1,#0xc]          ;2189
0000a8  6801              LDR      r1,[r0,#0]            ;2192
0000aa  694a              LDR      r2,[r1,#0x14]         ;2192
0000ac  f0220201          BIC      r2,r2,#1              ;2192
0000b0  614a              STR      r2,[r1,#0x14]         ;2192
0000b2  2101              MOVS     r1,#1                 ;2194
0000b4  6401              STR      r1,[r0,#0x40]         ;2194
0000b6  f7fffffe          BL       HAL_USART_TxRxCpltCallback
0000ba  2000              MOVS     r0,#0                 ;2198
0000bc  bd10              POP      {r4,pc}
                  |L38.190|
0000be  6903              LDR      r3,[r0,#0x10]         ;2156
0000c0  6ac2              LDR      r2,[r0,#0x2c]         ;2156
0000c2  6849              LDR      r1,[r1,#4]            ;2163
0000c4  2b00              CMP      r3,#0                 ;2156
0000c6  bf14              ITE      NE                    ;2163
0000c8  b2c9              UXTBNE   r1,r1                 ;2163
0000ca  f3c10108          UBFXEQ   r1,r1,#0,#9           ;2158
0000ce  8011              STRH     r1,[r2,#0]            ;2158
0000d0  6ac1              LDR      r1,[r0,#0x2c]         ;2159
0000d2  bf14              ITE      NE                    ;2159
0000d4  1c49              ADDNE    r1,r1,#1              ;2159
0000d6  1c89              ADDEQ    r1,r1,#2              ;2159
0000d8  62c1              STR      r1,[r0,#0x2c]         ;2156
0000da  e7d3              B        |L38.132|
                  |L38.220|
0000dc  684a              LDR      r2,[r1,#4]            ;2171
0000de  6ac1              LDR      r1,[r0,#0x2c]         ;2171
0000e0  1c4b              ADDS     r3,r1,#1              ;2171
0000e2  62c3              STR      r3,[r0,#0x2c]         ;2171
0000e4  700a              STRB     r2,[r1,#0]            ;2171
0000e6  e7cd              B        |L38.132|
;;;2208   
                          ENDP


                          AREA ||i.USART_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=2

                  USART_WaitOnFlagUntilTimeout PROC
;;;1813     */
;;;1814   static HAL_StatusTypeDef USART_WaitOnFlagUntilTimeout(USART_HandleTypeDef *husart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1815   {
000004  4604              MOV      r4,r0
;;;1816     /* Wait until flag is set */
;;;1817     while((__HAL_USART_GET_FLAG(husart, Flag) ? SET : RESET) == Status)
000006  6800              LDR      r0,[r0,#0]
000008  9e06              LDR      r6,[sp,#0x18]
00000a  461f              MOV      r7,r3                 ;1815
00000c  6800              LDR      r0,[r0,#0]
00000e  460d              MOV      r5,r1                 ;1815
000010  ea310000          BICS     r0,r1,r0
000014  d029              BEQ      |L39.106|
;;;1818     {
;;;1819       /* Check for the Timeout */
;;;1820       if(Timeout != HAL_MAX_DELAY)
000016  bf00              NOP      
                  |L39.24|
000018  f1b63fff          CMP      r6,#0xffffffff
00001c  d020              BEQ      |L39.96|
;;;1821       {
;;;1822         if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
00001e  b126              CBZ      r6,|L39.42|
000020  f7fffffe          BL       HAL_GetTick
000024  1bc0              SUBS     r0,r0,r7
000026  42b0              CMP      r0,r6
000028  d91a              BLS      |L39.96|
                  |L39.42|
;;;1823         {
;;;1824           /* Disable the USART Transmit Complete Interrupt */
;;;1825           CLEAR_BIT(husart->Instance->CR1, USART_CR1_TXEIE);
00002a  6820              LDR      r0,[r4,#0]
00002c  68c1              LDR      r1,[r0,#0xc]
00002e  f0210180          BIC      r1,r1,#0x80
000032  60c1              STR      r1,[r0,#0xc]
;;;1826   
;;;1827           /* Disable the USART RXNE Interrupt */
;;;1828           CLEAR_BIT(husart->Instance->CR1, USART_CR1_RXNEIE);
000034  6820              LDR      r0,[r4,#0]
000036  68c1              LDR      r1,[r0,#0xc]
000038  f0210120          BIC      r1,r1,#0x20
00003c  60c1              STR      r1,[r0,#0xc]
;;;1829   
;;;1830           /* Disable the USART Parity Error Interrupt */
;;;1831           CLEAR_BIT(husart->Instance->CR1, USART_CR1_PEIE);
00003e  6820              LDR      r0,[r4,#0]
000040  68c1              LDR      r1,[r0,#0xc]
000042  f4217180          BIC      r1,r1,#0x100
000046  60c1              STR      r1,[r0,#0xc]
;;;1832   
;;;1833           /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1834           CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
000048  6820              LDR      r0,[r4,#0]
00004a  6941              LDR      r1,[r0,#0x14]
00004c  f0210101          BIC      r1,r1,#1
000050  6141              STR      r1,[r0,#0x14]
;;;1835   
;;;1836           husart->State= HAL_USART_STATE_READY;
000052  2001              MOVS     r0,#1
000054  6420              STR      r0,[r4,#0x40]
;;;1837   
;;;1838           /* Process Unlocked */
;;;1839           __HAL_UNLOCK(husart);
000056  2000              MOVS     r0,#0
;;;1840   
;;;1841           return HAL_TIMEOUT;
000058  63e0              STR      r0,[r4,#0x3c]
00005a  2003              MOVS     r0,#3
;;;1842         }
;;;1843       }
;;;1844     }
;;;1845     return HAL_OK;
;;;1846   }
00005c  e8bd81f0          POP      {r4-r8,pc}
                  |L39.96|
000060  6820              LDR      r0,[r4,#0]            ;1841
000062  6800              LDR      r0,[r0,#0]            ;1841
000064  ea350000          BICS     r0,r5,r0              ;1841
000068  d1d6              BNE      |L39.24|
                  |L39.106|
00006a  2000              MOVS     r0,#0                 ;1845
00006c  e8bd81f0          POP      {r4-r8,pc}
;;;1847   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F4_V1.21.0\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f4xx_hal_usart_c_32ae8742____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F4_V1.21.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___21_stm32f4xx_hal_usart_c_32ae8742____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f4xx_hal_usart_c_32ae8742____REVSH|
#line 402
|__asm___21_stm32f4xx_hal_usart_c_32ae8742____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f4xx_hal_usart_c_32ae8742____RRX|
#line 587
|__asm___21_stm32f4xx_hal_usart_c_32ae8742____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
