; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f4xx_hal_tim_ex.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f4xx_hal_tim_ex.d --cpu=Cortex-M4.fp --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F4_V1.21.0\Drivers\STM32F4xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_F4_V1.21.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F4_V1.21.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F4_V1.21.0\Drivers\STM32F4xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F405RGT6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.11.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F405xx -DSTM32F405xx -DUSE_HAL_DRIVER -DHSE_VALUE=8000000 -DPLL_M=8 --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f4xx_hal_tim_ex.crf ..\..\..\M0P0_Library\STM32Cube_FW_F4_V1.21.0\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_tim_ex.c]
                          THUMB

                          AREA ||i.HAL_TIMEx_BreakCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_BreakCallback PROC
;;;1780     */
;;;1781   __weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1782   {
;;;1783     /* Prevent unused argument(s) compilation warning */
;;;1784     UNUSED(htim);
;;;1785     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1786               the HAL_TIMEx_BreakCallback could be implemented in the user file
;;;1787      */
;;;1788   }
;;;1789   /**
                          ENDP


                          AREA ||i.HAL_TIMEx_CommutationCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_CommutationCallback PROC
;;;1765     */
;;;1766   __weak void HAL_TIMEx_CommutationCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1767   {
;;;1768     /* Prevent unused argument(s) compilation warning */
;;;1769     UNUSED(htim);
;;;1770     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1771               the HAL_TIMEx_CommutationCallback could be implemented in the user file
;;;1772      */
;;;1773   }
;;;1774   
                          ENDP


                          AREA ||i.HAL_TIMEx_ConfigBreakDeadTime||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_ConfigBreakDeadTime PROC
;;;1643     */    
;;;1644   HAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim,
000000  6b82              LDR      r2,[r0,#0x38]
;;;1645                                                   TIM_BreakDeadTimeConfigTypeDef * sBreakDeadTimeConfig)
;;;1646   {
;;;1647     uint32_t tmpbdtr = 0U;
;;;1648     
;;;1649     /* Check the parameters */
;;;1650     assert_param(IS_TIM_BREAK_INSTANCE(htim->Instance));
;;;1651     assert_param(IS_TIM_OSSR_STATE(sBreakDeadTimeConfig->OffStateRunMode));
;;;1652     assert_param(IS_TIM_OSSI_STATE(sBreakDeadTimeConfig->OffStateIDLEMode));
;;;1653     assert_param(IS_TIM_LOCK_LEVEL(sBreakDeadTimeConfig->LockLevel));
;;;1654     assert_param(IS_TIM_DEADTIME(sBreakDeadTimeConfig->DeadTime));
;;;1655     assert_param(IS_TIM_BREAK_STATE(sBreakDeadTimeConfig->BreakState));
;;;1656     assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
;;;1657     assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));
;;;1658     
;;;1659     /* Check input state */
;;;1660     __HAL_LOCK(htim);
000002  2a01              CMP      r2,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;1661     
;;;1662     /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
;;;1663     the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;1664     
;;;1665     /* Set the BDTR bits */
;;;1666     MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);
;;;1667     MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
;;;1668     MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
;;;1669     MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
;;;1670     MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
;;;1671     MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
;;;1672     MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
;;;1673     MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, sBreakDeadTimeConfig->AutomaticOutput);
;;;1674     
;;;1675     /* Set TIMx_BDTR */
;;;1676     htim->Instance->BDTR = tmpbdtr;
;;;1677     
;;;1678     __HAL_UNLOCK(htim);
;;;1679   
;;;1680     return HAL_OK;
;;;1681   }
000008  4770              BXEQ     lr
00000a  2201              MOVS     r2,#1                 ;1660
00000c  6382              STR      r2,[r0,#0x38]         ;1666
00000e  68ca              LDR      r2,[r1,#0xc]          ;1667
000010  688b              LDR      r3,[r1,#8]            ;1667
000012  f4227240          BIC      r2,r2,#0x300          ;1667
000016  431a              ORRS     r2,r2,r3              ;1667
000018  684b              LDR      r3,[r1,#4]            ;1668
00001a  f4226280          BIC      r2,r2,#0x400          ;1668
00001e  431a              ORRS     r2,r2,r3              ;1668
000020  680b              LDR      r3,[r1,#0]            ;1669
000022  f4226200          BIC      r2,r2,#0x800          ;1669
000026  431a              ORRS     r2,r2,r3              ;1669
000028  690b              LDR      r3,[r1,#0x10]         ;1670
00002a  f4225280          BIC      r2,r2,#0x1000         ;1670
00002e  431a              ORRS     r2,r2,r3              ;1670
000030  694b              LDR      r3,[r1,#0x14]         ;1671
000032  f4225200          BIC      r2,r2,#0x2000         ;1671
000036  431a              ORRS     r2,r2,r3              ;1671
000038  6989              LDR      r1,[r1,#0x18]         ;1672
00003a  f4224280          BIC      r2,r2,#0x4000         ;1672
00003e  430a              ORRS     r2,r2,r1              ;1672
000040  f4224200          BIC      r2,r2,#0x8000         ;1673
000044  4311              ORRS     r1,r1,r2              ;1673
000046  6802              LDR      r2,[r0,#0]            ;1676
000048  6451              STR      r1,[r2,#0x44]         ;1676
00004a  2100              MOVS     r1,#0                 ;1678
00004c  6381              STR      r1,[r0,#0x38]         ;1680
00004e  4608              MOV      r0,r1                 ;1680
000050  4770              BX       lr
;;;1682   
                          ENDP


                          AREA ||i.HAL_TIMEx_ConfigCommutationEvent||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_ConfigCommutationEvent PROC
;;;1457     */
;;;1458   HAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
000000  6b83              LDR      r3,[r0,#0x38]
;;;1459   {
;;;1460     /* Check the parameters */
;;;1461     assert_param(IS_TIM_ADVANCED_INSTANCE(htim->Instance));
;;;1462     assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
;;;1463     
;;;1464     __HAL_LOCK(htim);
000002  2b01              CMP      r3,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;1465     
;;;1466     if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
;;;1467         (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
;;;1468     {    
;;;1469       /* Select the Input trigger */
;;;1470       htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;1471       htim->Instance->SMCR |= InputTrigger;
;;;1472     }
;;;1473       
;;;1474     /* Select the Capture Compare preload feature */
;;;1475     htim->Instance->CR2 |= TIM_CR2_CCPC;
;;;1476     /* Select the Commutation event source */
;;;1477     htim->Instance->CR2 &= ~TIM_CR2_CCUS;
;;;1478     htim->Instance->CR2 |= CommutationSource;
;;;1479       
;;;1480     __HAL_UNLOCK(htim);
;;;1481     
;;;1482     return HAL_OK;
;;;1483   }
000008  4770              BXEQ     lr
00000a  2301              MOVS     r3,#1                 ;1464
00000c  6383              STR      r3,[r0,#0x38]         ;1466
00000e  2900              CMP      r1,#0                 ;1466
000010  bf18              IT       NE                    ;1466
000012  2910              CMPNE    r1,#0x10              ;1466
000014  d003              BEQ      |L4.30|
000016  2920              CMP      r1,#0x20              ;1466
000018  bf18              IT       NE                    ;1466
00001a  2930              CMPNE    r1,#0x30              ;1466
00001c  d10c              BNE      |L4.56|
                  |L4.30|
00001e  6803              LDR      r3,[r0,#0]            ;1470
000020  f8d3c008          LDR      r12,[r3,#8]           ;1470
000024  f02c0c70          BIC      r12,r12,#0x70         ;1470
000028  f8c3c008          STR      r12,[r3,#8]           ;1470
00002c  6803              LDR      r3,[r0,#0]            ;1471
00002e  f8d3c008          LDR      r12,[r3,#8]           ;1471
000032  ea4c0101          ORR      r1,r12,r1             ;1471
000036  6099              STR      r1,[r3,#8]            ;1471
                  |L4.56|
000038  6801              LDR      r1,[r0,#0]            ;1475
00003a  684b              LDR      r3,[r1,#4]            ;1475
00003c  f0430301          ORR      r3,r3,#1              ;1475
000040  604b              STR      r3,[r1,#4]            ;1475
000042  6801              LDR      r1,[r0,#0]            ;1477
000044  684b              LDR      r3,[r1,#4]            ;1477
000046  f0230304          BIC      r3,r3,#4              ;1477
00004a  604b              STR      r3,[r1,#4]            ;1477
00004c  6801              LDR      r1,[r0,#0]            ;1478
00004e  684b              LDR      r3,[r1,#4]            ;1478
000050  431a              ORRS     r2,r2,r3              ;1478
000052  604a              STR      r2,[r1,#4]            ;1478
000054  2100              MOVS     r1,#0                 ;1480
000056  6381              STR      r1,[r0,#0x38]         ;1482
000058  4608              MOV      r0,r1                 ;1482
00005a  4770              BX       lr
;;;1484   
                          ENDP


                          AREA ||i.HAL_TIMEx_ConfigCommutationEvent_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_ConfigCommutationEvent_DMA PROC
;;;1561     */
;;;1562   HAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent_DMA(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
000000  6b83              LDR      r3,[r0,#0x38]
;;;1563   {
;;;1564     /* Check the parameters */
;;;1565     assert_param(IS_TIM_ADVANCED_INSTANCE(htim->Instance));
;;;1566     assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
;;;1567     
;;;1568     __HAL_LOCK(htim);
000002  2b01              CMP      r3,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;1569     
;;;1570     if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
;;;1571         (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
;;;1572     {    
;;;1573       /* Select the Input trigger */
;;;1574       htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;1575       htim->Instance->SMCR |= InputTrigger;
;;;1576     }
;;;1577     
;;;1578     /* Select the Capture Compare preload feature */
;;;1579     htim->Instance->CR2 |= TIM_CR2_CCPC;
;;;1580     /* Select the Commutation event source */
;;;1581     htim->Instance->CR2 &= ~TIM_CR2_CCUS;
;;;1582     htim->Instance->CR2 |= CommutationSource;
;;;1583     
;;;1584     /* Enable the Commutation DMA Request */
;;;1585     /* Set the DMA Commutation Callback */
;;;1586     htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = TIMEx_DMACommutationCplt;     
;;;1587     /* Set the DMA error callback */
;;;1588     htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError;
;;;1589     
;;;1590     /* Enable the Commutation DMA Request */
;;;1591     __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_COM);
;;;1592   
;;;1593     __HAL_UNLOCK(htim);
;;;1594     
;;;1595     return HAL_OK;
;;;1596   }
000008  4770              BXEQ     lr
00000a  2301              MOVS     r3,#1                 ;1568
00000c  6383              STR      r3,[r0,#0x38]         ;1570
00000e  2900              CMP      r1,#0                 ;1570
000010  bf18              IT       NE                    ;1570
000012  2910              CMPNE    r1,#0x10              ;1570
000014  d003              BEQ      |L5.30|
000016  2920              CMP      r1,#0x20              ;1570
000018  bf18              IT       NE                    ;1570
00001a  2930              CMPNE    r1,#0x30              ;1570
00001c  d10c              BNE      |L5.56|
                  |L5.30|
00001e  6803              LDR      r3,[r0,#0]            ;1574
000020  f8d3c008          LDR      r12,[r3,#8]           ;1574
000024  f02c0c70          BIC      r12,r12,#0x70         ;1574
000028  f8c3c008          STR      r12,[r3,#8]           ;1574
00002c  6803              LDR      r3,[r0,#0]            ;1575
00002e  f8d3c008          LDR      r12,[r3,#8]           ;1575
000032  ea4c0101          ORR      r1,r12,r1             ;1575
000036  6099              STR      r1,[r3,#8]            ;1575
                  |L5.56|
000038  6801              LDR      r1,[r0,#0]            ;1579
00003a  684b              LDR      r3,[r1,#4]            ;1579
00003c  f0430301          ORR      r3,r3,#1              ;1579
000040  604b              STR      r3,[r1,#4]            ;1579
000042  6801              LDR      r1,[r0,#0]            ;1581
000044  684b              LDR      r3,[r1,#4]            ;1581
000046  f0230304          BIC      r3,r3,#4              ;1581
00004a  604b              STR      r3,[r1,#4]            ;1581
00004c  6801              LDR      r1,[r0,#0]            ;1582
00004e  684b              LDR      r3,[r1,#4]            ;1582
000050  431a              ORRS     r2,r2,r3              ;1582
000052  604a              STR      r2,[r1,#4]            ;1582
000054  6b02              LDR      r2,[r0,#0x30]         ;1586
000056  4907              LDR      r1,|L5.116|
000058  6411              STR      r1,[r2,#0x40]         ;1588
00005a  6b02              LDR      r2,[r0,#0x30]         ;1588
00005c  4906              LDR      r1,|L5.120|
00005e  6511              STR      r1,[r2,#0x50]         ;1591
000060  6801              LDR      r1,[r0,#0]            ;1591
000062  68ca              LDR      r2,[r1,#0xc]          ;1591
000064  f4425200          ORR      r2,r2,#0x2000         ;1591
000068  60ca              STR      r2,[r1,#0xc]          ;1591
00006a  2100              MOVS     r1,#0                 ;1593
00006c  6381              STR      r1,[r0,#0x38]         ;1595
00006e  4608              MOV      r0,r1                 ;1595
000070  4770              BX       lr
;;;1597   
                          ENDP

000072  0000              DCW      0x0000
                  |L5.116|
                          DCD      TIMEx_DMACommutationCplt
                  |L5.120|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIMEx_ConfigCommutationEvent_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_ConfigCommutationEvent_IT PROC
;;;1507     */
;;;1508   HAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent_IT(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
000000  6b83              LDR      r3,[r0,#0x38]
;;;1509   {
;;;1510     /* Check the parameters */
;;;1511     assert_param(IS_TIM_ADVANCED_INSTANCE(htim->Instance));
;;;1512     assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
;;;1513     
;;;1514     __HAL_LOCK(htim);
000002  2b01              CMP      r3,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;1515     
;;;1516     if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
;;;1517         (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
;;;1518     {    
;;;1519       /* Select the Input trigger */
;;;1520       htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;1521       htim->Instance->SMCR |= InputTrigger;
;;;1522     }
;;;1523     
;;;1524     /* Select the Capture Compare preload feature */
;;;1525     htim->Instance->CR2 |= TIM_CR2_CCPC;
;;;1526     /* Select the Commutation event source */
;;;1527     htim->Instance->CR2 &= ~TIM_CR2_CCUS;
;;;1528     htim->Instance->CR2 |= CommutationSource;
;;;1529       
;;;1530     /* Enable the Commutation Interrupt Request */
;;;1531     __HAL_TIM_ENABLE_IT(htim, TIM_IT_COM);
;;;1532   
;;;1533     __HAL_UNLOCK(htim);
;;;1534     
;;;1535     return HAL_OK;
;;;1536   }
000008  4770              BXEQ     lr
00000a  2301              MOVS     r3,#1                 ;1514
00000c  6383              STR      r3,[r0,#0x38]         ;1516
00000e  2900              CMP      r1,#0                 ;1516
000010  bf18              IT       NE                    ;1516
000012  2910              CMPNE    r1,#0x10              ;1516
000014  d003              BEQ      |L6.30|
000016  2920              CMP      r1,#0x20              ;1516
000018  bf18              IT       NE                    ;1516
00001a  2930              CMPNE    r1,#0x30              ;1516
00001c  d10c              BNE      |L6.56|
                  |L6.30|
00001e  6803              LDR      r3,[r0,#0]            ;1520
000020  f8d3c008          LDR      r12,[r3,#8]           ;1520
000024  f02c0c70          BIC      r12,r12,#0x70         ;1520
000028  f8c3c008          STR      r12,[r3,#8]           ;1520
00002c  6803              LDR      r3,[r0,#0]            ;1521
00002e  f8d3c008          LDR      r12,[r3,#8]           ;1521
000032  ea4c0101          ORR      r1,r12,r1             ;1521
000036  6099              STR      r1,[r3,#8]            ;1521
                  |L6.56|
000038  6801              LDR      r1,[r0,#0]            ;1525
00003a  684b              LDR      r3,[r1,#4]            ;1525
00003c  f0430301          ORR      r3,r3,#1              ;1525
000040  604b              STR      r3,[r1,#4]            ;1525
000042  6801              LDR      r1,[r0,#0]            ;1527
000044  684b              LDR      r3,[r1,#4]            ;1527
000046  f0230304          BIC      r3,r3,#4              ;1527
00004a  604b              STR      r3,[r1,#4]            ;1527
00004c  6801              LDR      r1,[r0,#0]            ;1528
00004e  684b              LDR      r3,[r1,#4]            ;1528
000050  431a              ORRS     r2,r2,r3              ;1528
000052  604a              STR      r2,[r1,#4]            ;1528
000054  6801              LDR      r1,[r0,#0]            ;1531
000056  68ca              LDR      r2,[r1,#0xc]          ;1531
000058  f0420220          ORR      r2,r2,#0x20           ;1531
00005c  60ca              STR      r2,[r1,#0xc]          ;1531
00005e  2100              MOVS     r1,#0                 ;1533
000060  6381              STR      r1,[r0,#0x38]         ;1535
000062  4608              MOV      r0,r1                 ;1535
000064  4770              BX       lr
;;;1537   
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_DeInit PROC
;;;229      */
;;;230    HAL_StatusTypeDef HAL_TIMEx_HallSensor_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;231    {
000002  4604              MOV      r4,r0
;;;232      /* Check the parameters */
;;;233      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;234    
;;;235      htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  63e0              STR      r0,[r4,#0x3c]
;;;236      
;;;237      /* Disable the TIM Peripheral Clock */
;;;238      __HAL_TIM_DISABLE(htim);
000008  6820              LDR      r0,[r4,#0]
00000a  6a01              LDR      r1,[r0,#0x20]
00000c  f2411211          MOV      r2,#0x1111
000010  4211              TST      r1,r2
000012  d107              BNE      |L7.36|
000014  6a01              LDR      r1,[r0,#0x20]
000016  1092              ASRS     r2,r2,#2
000018  4211              TST      r1,r2
00001a  d103              BNE      |L7.36|
00001c  6801              LDR      r1,[r0,#0]
00001e  f0210101          BIC      r1,r1,#1
000022  6001              STR      r1,[r0,#0]
                  |L7.36|
;;;239        
;;;240      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;241      HAL_TIMEx_HallSensor_MspDeInit(htim);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       HAL_TIMEx_HallSensor_MspDeInit
;;;242        
;;;243      /* Change TIM state */  
;;;244      htim->State = HAL_TIM_STATE_RESET; 
00002a  2000              MOVS     r0,#0
00002c  63e0              STR      r0,[r4,#0x3c]
;;;245    
;;;246      /* Release Lock */
;;;247      __HAL_UNLOCK(htim);
00002e  63a0              STR      r0,[r4,#0x38]
;;;248    
;;;249      return HAL_OK;
;;;250    }
000030  bd10              POP      {r4,pc}
;;;251    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_GetState PROC
;;;1813     */
;;;1814   HAL_TIM_StateTypeDef HAL_TIMEx_HallSensor_GetState(TIM_HandleTypeDef *htim)
000000  6bc0              LDR      r0,[r0,#0x3c]
;;;1815   {
;;;1816     return htim->State;
;;;1817   }
000002  4770              BX       lr
;;;1818   
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Init PROC
;;;156      */
;;;157    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Init(TIM_HandleTypeDef *htim, TIM_HallSensor_InitTypeDef* sConfig)
000000  2800              CMP      r0,#0
;;;158    {
;;;159      TIM_OC_InitTypeDef OC_Config;
;;;160        
;;;161      /* Check the TIM handle allocation */
;;;162      if(htim == NULL)
;;;163      {
;;;164        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;165      }
;;;166      
;;;167      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;168      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;169      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;170      assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
;;;171      assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
;;;172      assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
;;;173    
;;;174      /* Set the TIM state */
;;;175      htim->State= HAL_TIM_STATE_BUSY;
;;;176      
;;;177      /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;178      HAL_TIMEx_HallSensor_MspInit(htim);
;;;179      
;;;180      /* Configure the Time base in the Encoder Mode */
;;;181      TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;182      
;;;183      /* Configure the Channel 1 as Input Channel to interface with the three Outputs of the  Hall sensor */
;;;184      TIM_TI1_SetConfig(htim->Instance, sConfig->IC1Polarity, TIM_ICSELECTION_TRC, sConfig->IC1Filter);
;;;185      
;;;186      /* Reset the IC1PSC Bits */
;;;187      htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;188      /* Set the IC1PSC value */
;;;189      htim->Instance->CCMR1 |= sConfig->IC1Prescaler;
;;;190      
;;;191      /* Enable the Hall sensor interface (XOR function of the three inputs) */
;;;192      htim->Instance->CR2 |= TIM_CR2_TI1S;
;;;193      
;;;194      /* Select the TIM_TS_TI1F_ED signal as Input trigger for the TIM */
;;;195      htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;196      htim->Instance->SMCR |= TIM_TS_TI1F_ED;
;;;197      
;;;198      /* Use the TIM_TS_TI1F_ED signal to reset the TIM counter each edge detection */  
;;;199      htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;200      htim->Instance->SMCR |= TIM_SLAVEMODE_RESET;
;;;201      
;;;202      /* Program channel 2 in PWM 2 mode with the desired Commutation_Delay*/
;;;203      OC_Config.OCFastMode = TIM_OCFAST_DISABLE;
;;;204      OC_Config.OCIdleState = TIM_OCIDLESTATE_RESET;
;;;205      OC_Config.OCMode = TIM_OCMODE_PWM2;
;;;206      OC_Config.OCNIdleState = TIM_OCNIDLESTATE_RESET;
;;;207      OC_Config.OCNPolarity = TIM_OCNPOLARITY_HIGH;
;;;208      OC_Config.OCPolarity = TIM_OCPOLARITY_HIGH;
;;;209      OC_Config.Pulse = sConfig->Commutation_Delay; 
;;;210        
;;;211      TIM_OC2_SetConfig(htim->Instance, &OC_Config);
;;;212      
;;;213      /* Select OC2REF as trigger output on TRGO: write the MMS bits in the TIMx_CR2
;;;214        register to 101 */
;;;215      htim->Instance->CR2 &= ~TIM_CR2_MMS;
;;;216      htim->Instance->CR2 |= TIM_TRGO_OC2REF; 
;;;217      
;;;218      /* Initialize the TIM state*/
;;;219      htim->State= HAL_TIM_STATE_READY;
;;;220    
;;;221      return HAL_OK;
;;;222    }
000006  4770              BXEQ     lr
000008  b530              PUSH     {r4,r5,lr}            ;158
00000a  4604              MOV      r4,r0                 ;158
00000c  b087              SUB      sp,sp,#0x1c           ;158
00000e  2002              MOVS     r0,#2                 ;175
000010  460d              MOV      r5,r1                 ;158
000012  63e0              STR      r0,[r4,#0x3c]         ;175
000014  4620              MOV      r0,r4                 ;178
000016  f7fffffe          BL       HAL_TIMEx_HallSensor_MspInit
00001a  1d21              ADDS     r1,r4,#4              ;181
00001c  6820              LDR      r0,[r4,#0]            ;181
00001e  f7fffffe          BL       TIM_Base_SetConfig
000022  68ab              LDR      r3,[r5,#8]            ;184
000024  6829              LDR      r1,[r5,#0]            ;184
000026  2203              MOVS     r2,#3                 ;184
000028  6820              LDR      r0,[r4,#0]            ;184
00002a  f7fffffe          BL       TIM_TI1_SetConfig
00002e  6820              LDR      r0,[r4,#0]            ;187
000030  6981              LDR      r1,[r0,#0x18]         ;187
000032  f021010c          BIC      r1,r1,#0xc            ;187
000036  6181              STR      r1,[r0,#0x18]         ;187
000038  6820              LDR      r0,[r4,#0]            ;189
00003a  6981              LDR      r1,[r0,#0x18]         ;189
00003c  686a              LDR      r2,[r5,#4]            ;189
00003e  4311              ORRS     r1,r1,r2              ;189
000040  6181              STR      r1,[r0,#0x18]         ;189
000042  6820              LDR      r0,[r4,#0]            ;192
000044  6841              LDR      r1,[r0,#4]            ;192
000046  f0410180          ORR      r1,r1,#0x80           ;192
00004a  6041              STR      r1,[r0,#4]            ;192
00004c  6820              LDR      r0,[r4,#0]            ;195
00004e  6881              LDR      r1,[r0,#8]            ;195
000050  f0210170          BIC      r1,r1,#0x70           ;195
000054  6081              STR      r1,[r0,#8]            ;195
000056  6820              LDR      r0,[r4,#0]            ;196
000058  6881              LDR      r1,[r0,#8]            ;196
00005a  f0410140          ORR      r1,r1,#0x40           ;196
00005e  6081              STR      r1,[r0,#8]            ;196
000060  6820              LDR      r0,[r4,#0]            ;199
000062  6881              LDR      r1,[r0,#8]            ;199
000064  f0210107          BIC      r1,r1,#7              ;199
000068  6081              STR      r1,[r0,#8]            ;199
00006a  6820              LDR      r0,[r4,#0]            ;200
00006c  6881              LDR      r1,[r0,#8]            ;200
00006e  f0410104          ORR      r1,r1,#4              ;200
000072  6081              STR      r1,[r0,#8]            ;200
000074  2000              MOVS     r0,#0                 ;203
000076  2170              MOVS     r1,#0x70              ;205
000078  9005              STR      r0,[sp,#0x14]         ;206
00007a  9100              STR      r1,[sp,#0]            ;209
00007c  9004              STR      r0,[sp,#0x10]         ;204
00007e  9006              STR      r0,[sp,#0x18]         ;207
000080  9003              STR      r0,[sp,#0xc]          ;208
000082  9002              STR      r0,[sp,#8]            ;209
000084  68e8              LDR      r0,[r5,#0xc]          ;209
000086  9001              STR      r0,[sp,#4]            ;211
000088  4669              MOV      r1,sp                 ;211
00008a  6820              LDR      r0,[r4,#0]            ;211
00008c  f7fffffe          BL       TIM_OC2_SetConfig
000090  6820              LDR      r0,[r4,#0]            ;215
000092  6841              LDR      r1,[r0,#4]            ;215
000094  f0210170          BIC      r1,r1,#0x70           ;215
000098  6041              STR      r1,[r0,#4]            ;215
00009a  6820              LDR      r0,[r4,#0]            ;216
00009c  6841              LDR      r1,[r0,#4]            ;216
00009e  f0410150          ORR      r1,r1,#0x50           ;216
0000a2  6041              STR      r1,[r0,#4]            ;216
0000a4  2001              MOVS     r0,#1                 ;219
0000a6  63e0              STR      r0,[r4,#0x3c]         ;219
0000a8  b007              ADD      sp,sp,#0x1c
0000aa  2000              MOVS     r0,#0                 ;221
0000ac  bd30              POP      {r4,r5,pc}
;;;223    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_MspDeInit PROC
;;;272      */
;;;273    __weak void HAL_TIMEx_HallSensor_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;274    {
;;;275      /* Prevent unused argument(s) compilation warning */
;;;276      UNUSED(htim);
;;;277      /* NOTE : This function Should not be modified, when the callback is needed,
;;;278                the HAL_TIMEx_HallSensor_MspDeInit could be implemented in the user file
;;;279       */
;;;280    }
;;;281    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_MspInit PROC
;;;257      */
;;;258    __weak void HAL_TIMEx_HallSensor_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;259    {
;;;260      /* Prevent unused argument(s) compilation warning */
;;;261      UNUSED(htim);
;;;262      /* NOTE : This function Should not be modified, when the callback is needed,
;;;263                the HAL_TIMEx_HallSensor_MspInit could be implemented in the user file
;;;264       */
;;;265    }
;;;266    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Start PROC
;;;287      */
;;;288    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;289    {
000002  4604              MOV      r4,r0
;;;290      /* Check the parameters */
;;;291      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;292      
;;;293      /* Enable the Input Capture channels 1
;;;294        (in the Hall Sensor Interface the Three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */  
;;;295      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
000004  6800              LDR      r0,[r0,#0]
000006  2201              MOVS     r2,#1
000008  2100              MOVS     r1,#0
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;296      
;;;297      /* Enable the Peripheral */
;;;298      __HAL_TIM_ENABLE(htim);
00000e  6820              LDR      r0,[r4,#0]
000010  6801              LDR      r1,[r0,#0]
000012  f0410101          ORR      r1,r1,#1
000016  6001              STR      r1,[r0,#0]
;;;299      
;;;300      /* Return function status */
;;;301      return HAL_OK;
000018  2000              MOVS     r0,#0
;;;302    }
00001a  bd10              POP      {r4,pc}
;;;303    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_HallSensor_Start_DMA PROC
;;;383      */
;;;384    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;385    {
000002  4604              MOV      r4,r0
;;;386      /* Check the parameters */
;;;387      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;388      
;;;389       if((htim->State == HAL_TIM_STATE_BUSY))
000004  6bc0              LDR      r0,[r0,#0x3c]
000006  4615              MOV      r5,r2                 ;385
000008  460e              MOV      r6,r1                 ;385
00000a  2802              CMP      r0,#2
;;;390      {
;;;391         return HAL_BUSY;
;;;392      }
;;;393      else if((htim->State == HAL_TIM_STATE_READY))
;;;394      {
;;;395        if(((uint32_t)pData == 0U) && (Length > 0)) 
;;;396        {
;;;397          return HAL_ERROR;                                    
;;;398        }
;;;399        else
;;;400        {
;;;401          htim->State = HAL_TIM_STATE_BUSY;
;;;402        }
;;;403      }
;;;404      /* Enable the Input Capture channels 1
;;;405        (in the Hall Sensor Interface the Three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */  
;;;406      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
;;;407      
;;;408      /* Set the DMA Input Capture 1 Callback */
;;;409      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;     
;;;410      /* Set the DMA error callback */
;;;411      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;412      
;;;413      /* Enable the DMA Stream for Capture 1*/
;;;414      HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length);    
;;;415      
;;;416      /* Enable the capture compare 1 Interrupt */
;;;417      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;418     
;;;419      /* Enable the Peripheral */
;;;420      __HAL_TIM_ENABLE(htim);
;;;421      
;;;422      /* Return function status */
;;;423      return HAL_OK;
;;;424    }
00000c  bf08              IT       EQ
00000e  bd70              POPEQ    {r4-r6,pc}
000010  6be0              LDR      r0,[r4,#0x3c]         ;393
000012  2801              CMP      r0,#1                 ;393
000014  d106              BNE      |L13.36|
000016  b91e              CBNZ     r6,|L13.32|
000018  2d00              CMP      r5,#0                 ;395
00001a  bf1c              ITT      NE                    ;397
00001c  2001              MOVNE    r0,#1                 ;397
00001e  bd70              POPNE    {r4-r6,pc}
                  |L13.32|
000020  2002              MOVS     r0,#2                 ;401
000022  63e0              STR      r0,[r4,#0x3c]         ;401
                  |L13.36|
000024  2201              MOVS     r2,#1                 ;406
000026  2100              MOVS     r1,#0                 ;406
000028  6820              LDR      r0,[r4,#0]            ;406
00002a  f7fffffe          BL       TIM_CCxChannelCmd
00002e  6a21              LDR      r1,[r4,#0x20]         ;409
000030  480c              LDR      r0,|L13.100|
000032  462b              MOV      r3,r5                 ;414
000034  6408              STR      r0,[r1,#0x40]         ;411
000036  6a21              LDR      r1,[r4,#0x20]         ;411
000038  480b              LDR      r0,|L13.104|
00003a  4632              MOV      r2,r6                 ;414
00003c  6508              STR      r0,[r1,#0x50]         ;414
00003e  6820              LDR      r0,[r4,#0]            ;414
000040  f1000134          ADD      r1,r0,#0x34           ;414
000044  6a20              LDR      r0,[r4,#0x20]         ;414
000046  f7fffffe          BL       HAL_DMA_Start_IT
00004a  6820              LDR      r0,[r4,#0]            ;417
00004c  68c1              LDR      r1,[r0,#0xc]          ;417
00004e  f4417100          ORR      r1,r1,#0x200          ;417
000052  60c1              STR      r1,[r0,#0xc]          ;417
000054  6820              LDR      r0,[r4,#0]            ;420
000056  6801              LDR      r1,[r0,#0]            ;420
000058  f0410101          ORR      r1,r1,#1              ;420
00005c  6001              STR      r1,[r0,#0]            ;420
00005e  2000              MOVS     r0,#0                 ;423
000060  bd70              POP      {r4-r6,pc}
;;;425    
                          ENDP

000062  0000              DCW      0x0000
                  |L13.100|
                          DCD      TIM_DMACaptureCplt
                  |L13.104|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIMEx_HallSensor_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Start_IT PROC
;;;331      */
;;;332    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_IT(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;333    { 
000002  4604              MOV      r4,r0
;;;334      /* Check the parameters */
;;;335      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;336      
;;;337      /* Enable the capture compare Interrupts 1 event */
;;;338      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000004  6800              LDR      r0,[r0,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f0410102          ORR      r1,r1,#2
00000c  60c1              STR      r1,[r0,#0xc]
;;;339      
;;;340      /* Enable the Input Capture channels 1
;;;341        (in the Hall Sensor Interface the Three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */  
;;;342      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);  
00000e  2201              MOVS     r2,#1
000010  2100              MOVS     r1,#0
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       TIM_CCxChannelCmd
;;;343      
;;;344      /* Enable the Peripheral */
;;;345      __HAL_TIM_ENABLE(htim);
000018  6820              LDR      r0,[r4,#0]
00001a  6801              LDR      r1,[r0,#0]
00001c  f0410101          ORR      r1,r1,#1
000020  6001              STR      r1,[r0,#0]
;;;346      
;;;347      /* Return function status */
;;;348      return HAL_OK;
000022  2000              MOVS     r0,#0
;;;349    }
000024  bd10              POP      {r4,pc}
;;;350    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Stop PROC
;;;309      */
;;;310    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;311    {
000002  4604              MOV      r4,r0
;;;312      /* Check the parameters */
;;;313      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;314      
;;;315      /* Disable the Input Capture channels 1, 2 and 3
;;;316        (in the Hall Sensor Interface the Three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */  
;;;317      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
000004  2200              MOVS     r2,#0
000006  6800              LDR      r0,[r0,#0]
000008  4611              MOV      r1,r2
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;318    
;;;319      /* Disable the Peripheral */
;;;320      __HAL_TIM_DISABLE(htim);
00000e  6820              LDR      r0,[r4,#0]
000010  6a01              LDR      r1,[r0,#0x20]
000012  f2411211          MOV      r2,#0x1111
000016  4211              TST      r1,r2
000018  d107              BNE      |L15.42|
00001a  6a01              LDR      r1,[r0,#0x20]
00001c  1092              ASRS     r2,r2,#2
00001e  4211              TST      r1,r2
000020  d103              BNE      |L15.42|
000022  6801              LDR      r1,[r0,#0]
000024  f0210101          BIC      r1,r1,#1
000028  6001              STR      r1,[r0,#0]
                  |L15.42|
;;;321      
;;;322      /* Return function status */
;;;323      return HAL_OK;
00002a  2000              MOVS     r0,#0
;;;324    }
00002c  bd10              POP      {r4,pc}
;;;325    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Stop_DMA PROC
;;;431      */
;;;432    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_DMA(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;433    {
000002  4604              MOV      r4,r0
;;;434      /* Check the parameters */
;;;435      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;436      
;;;437      /* Disable the Input Capture channels 1
;;;438        (in the Hall Sensor Interface the Three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */  
;;;439      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
000004  2200              MOVS     r2,#0
000006  6800              LDR      r0,[r0,#0]
000008  4611              MOV      r1,r2
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;440     
;;;441      
;;;442      /* Disable the capture compare Interrupts 1 event */
;;;443      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
00000e  6820              LDR      r0,[r4,#0]
000010  68c1              LDR      r1,[r0,#0xc]
000012  f4217100          BIC      r1,r1,#0x200
000016  60c1              STR      r1,[r0,#0xc]
;;;444     
;;;445      /* Disable the Peripheral */
;;;446      __HAL_TIM_DISABLE(htim);
000018  6820              LDR      r0,[r4,#0]
00001a  6a01              LDR      r1,[r0,#0x20]
00001c  f2411211          MOV      r2,#0x1111
000020  4211              TST      r1,r2
000022  d107              BNE      |L16.52|
000024  6a01              LDR      r1,[r0,#0x20]
000026  1092              ASRS     r2,r2,#2
000028  4211              TST      r1,r2
00002a  d103              BNE      |L16.52|
00002c  6801              LDR      r1,[r0,#0]
00002e  f0210101          BIC      r1,r1,#1
000032  6001              STR      r1,[r0,#0]
                  |L16.52|
;;;447      
;;;448      /* Return function status */
;;;449      return HAL_OK;
000034  2000              MOVS     r0,#0
;;;450    }
000036  bd10              POP      {r4,pc}
;;;451    /**
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Stop_IT PROC
;;;356      */
;;;357    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_IT(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;358    {
000002  4604              MOV      r4,r0
;;;359      /* Check the parameters */
;;;360      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;361      
;;;362      /* Disable the Input Capture channels 1
;;;363        (in the Hall Sensor Interface the Three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */  
;;;364      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
000004  2200              MOVS     r2,#0
000006  6800              LDR      r0,[r0,#0]
000008  4611              MOV      r1,r2
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;365      
;;;366      /* Disable the capture compare Interrupts event */
;;;367      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
00000e  6820              LDR      r0,[r4,#0]
000010  68c1              LDR      r1,[r0,#0xc]
000012  f0210102          BIC      r1,r1,#2
000016  60c1              STR      r1,[r0,#0xc]
;;;368      
;;;369      /* Disable the Peripheral */
;;;370      __HAL_TIM_DISABLE(htim);
000018  6820              LDR      r0,[r4,#0]
00001a  6a01              LDR      r1,[r0,#0x20]
00001c  f2411211          MOV      r2,#0x1111
000020  4211              TST      r1,r2
000022  d107              BNE      |L17.52|
000024  6a01              LDR      r1,[r0,#0x20]
000026  1092              ASRS     r2,r2,#2
000028  4211              TST      r1,r2
00002a  d103              BNE      |L17.52|
00002c  6801              LDR      r1,[r0,#0]
00002e  f0210101          BIC      r1,r1,#1
000032  6001              STR      r1,[r0,#0]
                  |L17.52|
;;;371      
;;;372      /* Return function status */
;;;373      return HAL_OK;
000034  2000              MOVS     r0,#0
;;;374    }
000036  bd10              POP      {r4,pc}
;;;375    
                          ENDP


                          AREA ||i.HAL_TIMEx_MasterConfigSynchronization||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_MasterConfigSynchronization PROC
;;;1606     */
;;;1607   HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim, TIM_MasterConfigTypeDef * sMasterConfig)
000000  6b82              LDR      r2,[r0,#0x38]
;;;1608   {
;;;1609     /* Check the parameters */
;;;1610     assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
;;;1611     assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
;;;1612     assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
;;;1613     
;;;1614     __HAL_LOCK(htim);
000002  2a01              CMP      r2,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;1615     
;;;1616     htim->State = HAL_TIM_STATE_BUSY;
;;;1617   
;;;1618     /* Reset the MMS Bits */
;;;1619     htim->Instance->CR2 &= ~TIM_CR2_MMS;
;;;1620     /* Select the TRGO source */
;;;1621     htim->Instance->CR2 |= sMasterConfig->MasterOutputTrigger;
;;;1622   
;;;1623     /* Reset the MSM Bit */
;;;1624     htim->Instance->SMCR &= ~TIM_SMCR_MSM;
;;;1625     /* Set or Reset the MSM Bit */
;;;1626     htim->Instance->SMCR |= sMasterConfig->MasterSlaveMode;
;;;1627     
;;;1628     htim->State = HAL_TIM_STATE_READY;
;;;1629     
;;;1630     __HAL_UNLOCK(htim);
;;;1631     
;;;1632     return HAL_OK;
;;;1633   } 
000008  4770              BXEQ     lr
00000a  b410              PUSH     {r4}                  ;1608
00000c  2201              MOVS     r2,#1                 ;1614
00000e  2302              MOVS     r3,#2                 ;1616
000010  63c3              STR      r3,[r0,#0x3c]         ;1616
000012  6382              STR      r2,[r0,#0x38]         ;1616
000014  6803              LDR      r3,[r0,#0]            ;1619
000016  f8d3c004          LDR      r12,[r3,#4]           ;1619
00001a  f02c0c70          BIC      r12,r12,#0x70         ;1619
00001e  f8c3c004          STR      r12,[r3,#4]           ;1619
000022  6803              LDR      r3,[r0,#0]            ;1621
000024  f8d3c004          LDR      r12,[r3,#4]           ;1621
000028  680c              LDR      r4,[r1,#0]            ;1621
00002a  ea4c0c04          ORR      r12,r12,r4            ;1621
00002e  f8c3c004          STR      r12,[r3,#4]           ;1621
000032  6803              LDR      r3,[r0,#0]            ;1624
000034  f8d3c008          LDR      r12,[r3,#8]           ;1624
000038  f02c0c80          BIC      r12,r12,#0x80         ;1624
00003c  f8c3c008          STR      r12,[r3,#8]           ;1624
000040  6803              LDR      r3,[r0,#0]            ;1626
000042  f8d3c008          LDR      r12,[r3,#8]           ;1626
000046  6849              LDR      r1,[r1,#4]            ;1626
000048  ea4c0101          ORR      r1,r12,r1             ;1626
00004c  6099              STR      r1,[r3,#8]            ;1626
00004e  63c2              STR      r2,[r0,#0x3c]         ;1628
000050  2100              MOVS     r1,#0                 ;1630
000052  6381              STR      r1,[r0,#0x38]         ;1632
000054  bc10              POP      {r4}
000056  4608              MOV      r0,r1                 ;1632
000058  4770              BX       lr
;;;1634                                                        
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Start PROC
;;;486      */
;;;487    HAL_StatusTypeDef HAL_TIMEx_OCN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
000002  2304              MOVS     r3,#4
000004  fa03f101          LSL      r1,r3,r1
000008  6a13              LDR      r3,[r2,#0x20]
00000a  438b              BICS     r3,r3,r1
00000c  6213              STR      r3,[r2,#0x20]
00000e  6a13              LDR      r3,[r2,#0x20]
000010  4319              ORRS     r1,r1,r3
000012  6211              STR      r1,[r2,#0x20]
;;;488    {
;;;489      /* Check the parameters */
;;;490      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;491      
;;;492         /* Enable the Capture compare channel N */
;;;493         TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
;;;494        
;;;495      /* Enable the Main Output */
;;;496        __HAL_TIM_MOE_ENABLE(htim);
000014  6801              LDR      r1,[r0,#0]
000016  6c4a              LDR      r2,[r1,#0x44]
000018  f4424200          ORR      r2,r2,#0x8000
00001c  644a              STR      r2,[r1,#0x44]
;;;497    
;;;498      /* Enable the Peripheral */
;;;499      __HAL_TIM_ENABLE(htim);
00001e  6800              LDR      r0,[r0,#0]
000020  6801              LDR      r1,[r0,#0]
000022  f0410101          ORR      r1,r1,#1
000026  6001              STR      r1,[r0,#0]
;;;500      
;;;501      /* Return function status */
;;;502      return HAL_OK;
000028  2000              MOVS     r0,#0
;;;503    } 
00002a  4770              BX       lr
;;;504    
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_OCN_Start_DMA PROC
;;;685      */
;;;686    HAL_StatusTypeDef HAL_TIMEx_OCN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;687    {
000002  4604              MOV      r4,r0
;;;688      /* Check the parameters */
;;;689      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;690      
;;;691      if((htim->State == HAL_TIM_STATE_BUSY))
000004  6bc0              LDR      r0,[r0,#0x3c]
000006  4694              MOV      r12,r2                ;687
000008  460d              MOV      r5,r1                 ;687
00000a  2802              CMP      r0,#2
;;;692      {
;;;693         return HAL_BUSY;
;;;694      }
;;;695      else if((htim->State == HAL_TIM_STATE_READY))
;;;696      {
;;;697        if(((uint32_t)pData == 0U) && (Length > 0)) 
;;;698        {
;;;699          return HAL_ERROR;                                    
;;;700        }
;;;701        else
;;;702        {
;;;703          htim->State = HAL_TIM_STATE_BUSY;
;;;704        }
;;;705      }    
;;;706      switch (Channel)
;;;707      {
;;;708        case TIM_CHANNEL_1:
;;;709        {      
;;;710          /* Set the DMA Period elapsed callback */
;;;711          htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;712         
;;;713          /* Set the DMA error callback */
;;;714          htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;715          
;;;716          /* Enable the DMA Stream */
;;;717          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;718          
;;;719          /* Enable the TIM Output Compare DMA request */
;;;720          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;721        }
;;;722        break;
;;;723        
;;;724        case TIM_CHANNEL_2:
;;;725        {
;;;726          /* Set the DMA Period elapsed callback */
;;;727          htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;728         
;;;729          /* Set the DMA error callback */
;;;730          htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;731          
;;;732          /* Enable the DMA Stream */
;;;733          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;734          
;;;735          /* Enable the TIM Output Compare DMA request */
;;;736          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;737        }
;;;738        break;
;;;739        
;;;740        case TIM_CHANNEL_3:
;;;741    {
;;;742          /* Set the DMA Period elapsed callback */
;;;743          htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;744         
;;;745          /* Set the DMA error callback */
;;;746          htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;747          
;;;748          /* Enable the DMA Stream */
;;;749          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;750          
;;;751          /* Enable the TIM Output Compare DMA request */
;;;752          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;753        }
;;;754        break;
;;;755        
;;;756        case TIM_CHANNEL_4:
;;;757        {
;;;758         /* Set the DMA Period elapsed callback */
;;;759          htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;760         
;;;761          /* Set the DMA error callback */
;;;762          htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;763          
;;;764          /* Enable the DMA Stream */
;;;765          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;766          
;;;767          /* Enable the TIM Output Compare DMA request */
;;;768          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;769        }
;;;770        break;
;;;771        
;;;772        default:
;;;773        break;
;;;774      }
;;;775    
;;;776      /* Enable the Capture compare channel N */
;;;777      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
;;;778      
;;;779      /* Enable the Main Output */
;;;780      __HAL_TIM_MOE_ENABLE(htim);
;;;781      
;;;782      /* Enable the Peripheral */
;;;783      __HAL_TIM_ENABLE(htim); 
;;;784      
;;;785      /* Return function status */
;;;786      return HAL_OK;
;;;787    }
00000c  bf08              IT       EQ
00000e  bd70              POPEQ    {r4-r6,pc}
000010  6be0              LDR      r0,[r4,#0x3c]         ;695
000012  2801              CMP      r0,#1                 ;695
000014  d108              BNE      |L20.40|
000016  f1bc0f00          CMP      r12,#0                ;697
00001a  d103              BNE      |L20.36|
00001c  2b00              CMP      r3,#0                 ;697
00001e  bf1c              ITT      NE                    ;699
000020  2001              MOVNE    r0,#1                 ;699
000022  bd70              POPNE    {r4-r6,pc}
                  |L20.36|
000024  2002              MOVS     r0,#2                 ;703
000026  63e0              STR      r0,[r4,#0x3c]         ;703
                  |L20.40|
000028  482f              LDR      r0,|L20.232|
00002a  4930              LDR      r1,|L20.236|
00002c  b135              CBZ      r5,|L20.60|
00002e  2d04              CMP      r5,#4                 ;706
000030  d014              BEQ      |L20.92|
000032  2d08              CMP      r5,#8                 ;706
000034  d022              BEQ      |L20.124|
000036  2d0c              CMP      r5,#0xc               ;706
000038  d030              BEQ      |L20.156|
00003a  e03f              B        |L20.188|
                  |L20.60|
00003c  6a22              LDR      r2,[r4,#0x20]         ;711
00003e  6410              STR      r0,[r2,#0x40]         ;714
000040  6a20              LDR      r0,[r4,#0x20]         ;714
000042  6501              STR      r1,[r0,#0x50]         ;717
000044  6820              LDR      r0,[r4,#0]            ;717
000046  4661              MOV      r1,r12                ;717
000048  f1000234          ADD      r2,r0,#0x34           ;717
00004c  6a20              LDR      r0,[r4,#0x20]         ;717
00004e  f7fffffe          BL       HAL_DMA_Start_IT
000052  6820              LDR      r0,[r4,#0]            ;720
000054  68c1              LDR      r1,[r0,#0xc]          ;720
000056  f4417100          ORR      r1,r1,#0x200          ;720
00005a  e02e              B        |L20.186|
                  |L20.92|
00005c  6a62              LDR      r2,[r4,#0x24]         ;727
00005e  6410              STR      r0,[r2,#0x40]         ;730
000060  6a60              LDR      r0,[r4,#0x24]         ;730
000062  6501              STR      r1,[r0,#0x50]         ;733
000064  6820              LDR      r0,[r4,#0]            ;733
000066  4661              MOV      r1,r12                ;733
000068  f1000238          ADD      r2,r0,#0x38           ;733
00006c  6a60              LDR      r0,[r4,#0x24]         ;733
00006e  f7fffffe          BL       HAL_DMA_Start_IT
000072  6820              LDR      r0,[r4,#0]            ;736
000074  68c1              LDR      r1,[r0,#0xc]          ;736
000076  f4416180          ORR      r1,r1,#0x400          ;736
00007a  e01e              B        |L20.186|
                  |L20.124|
00007c  6aa2              LDR      r2,[r4,#0x28]         ;743
00007e  6410              STR      r0,[r2,#0x40]         ;746
000080  6aa0              LDR      r0,[r4,#0x28]         ;746
000082  6501              STR      r1,[r0,#0x50]         ;749
000084  6820              LDR      r0,[r4,#0]            ;749
000086  4661              MOV      r1,r12                ;749
000088  f100023c          ADD      r2,r0,#0x3c           ;749
00008c  6aa0              LDR      r0,[r4,#0x28]         ;749
00008e  f7fffffe          BL       HAL_DMA_Start_IT
000092  6820              LDR      r0,[r4,#0]            ;752
000094  68c1              LDR      r1,[r0,#0xc]          ;752
000096  f4416100          ORR      r1,r1,#0x800          ;752
00009a  e00e              B        |L20.186|
                  |L20.156|
00009c  6ae2              LDR      r2,[r4,#0x2c]         ;759
00009e  6410              STR      r0,[r2,#0x40]         ;762
0000a0  6ae0              LDR      r0,[r4,#0x2c]         ;762
0000a2  6501              STR      r1,[r0,#0x50]         ;765
0000a4  6820              LDR      r0,[r4,#0]            ;765
0000a6  4661              MOV      r1,r12                ;765
0000a8  f1000240          ADD      r2,r0,#0x40           ;765
0000ac  6ae0              LDR      r0,[r4,#0x2c]         ;765
0000ae  f7fffffe          BL       HAL_DMA_Start_IT
0000b2  6820              LDR      r0,[r4,#0]            ;768
0000b4  68c1              LDR      r1,[r0,#0xc]          ;768
0000b6  f4415180          ORR      r1,r1,#0x1000         ;768
                  |L20.186|
0000ba  60c1              STR      r1,[r0,#0xc]          ;752
                  |L20.188|
0000bc  6820              LDR      r0,[r4,#0]            ;752
0000be  2104              MOVS     r1,#4                 ;752
0000c0  40a9              LSLS     r1,r1,r5              ;752
0000c2  6a02              LDR      r2,[r0,#0x20]         ;752
0000c4  438a              BICS     r2,r2,r1              ;752
0000c6  6202              STR      r2,[r0,#0x20]         ;752
0000c8  6a02              LDR      r2,[r0,#0x20]         ;752
0000ca  4311              ORRS     r1,r1,r2              ;752
0000cc  6201              STR      r1,[r0,#0x20]         ;752
0000ce  6820              LDR      r0,[r4,#0]            ;780
0000d0  6c41              LDR      r1,[r0,#0x44]         ;780
0000d2  f4414100          ORR      r1,r1,#0x8000         ;780
0000d6  6441              STR      r1,[r0,#0x44]         ;780
0000d8  6820              LDR      r0,[r4,#0]            ;783
0000da  6801              LDR      r1,[r0,#0]            ;783
0000dc  f0410101          ORR      r1,r1,#1              ;783
0000e0  6001              STR      r1,[r0,#0]            ;783
0000e2  2000              MOVS     r0,#0                 ;786
0000e4  bd70              POP      {r4-r6,pc}
;;;788    
                          ENDP

0000e6  0000              DCW      0x0000
                  |L20.232|
                          DCD      TIM_DMADelayPulseCplt
                  |L20.236|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIMEx_OCN_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Start_IT PROC
;;;546      */
;;;547    HAL_StatusTypeDef HAL_TIMEx_OCN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
;;;548    {
;;;549      /* Check the parameters */
;;;550      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;551      
;;;552      switch (Channel)
000002  2900              CMP      r1,#0
;;;553      {
;;;554        case TIM_CHANNEL_1:
;;;555        {       
;;;556          /* Enable the TIM Output Compare interrupt */
;;;557          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000004  bf04              ITT      EQ
000006  68d3              LDREQ    r3,[r2,#0xc]
000008  f0430302          ORREQ    r3,r3,#2
00000c  d011              BEQ      |L21.50|
00000e  2904              CMP      r1,#4                 ;552
;;;558        }
;;;559        break;
;;;560        
;;;561        case TIM_CHANNEL_2:
;;;562        {
;;;563          /* Enable the TIM Output Compare interrupt */
;;;564          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000010  bf04              ITT      EQ
000012  68d3              LDREQ    r3,[r2,#0xc]
000014  f0430304          ORREQ    r3,r3,#4
000018  d00b              BEQ      |L21.50|
00001a  2908              CMP      r1,#8                 ;552
;;;565        }
;;;566        break;
;;;567        
;;;568        case TIM_CHANNEL_3:
;;;569        {
;;;570          /* Enable the TIM Output Compare interrupt */
;;;571          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
00001c  bf04              ITT      EQ
00001e  68d3              LDREQ    r3,[r2,#0xc]
000020  f0430308          ORREQ    r3,r3,#8
000024  d005              BEQ      |L21.50|
000026  290c              CMP      r1,#0xc               ;552
;;;572        }
;;;573        break;
;;;574        
;;;575        case TIM_CHANNEL_4:
;;;576        {
;;;577          /* Enable the TIM Output Compare interrupt */
;;;578          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000028  bf04              ITT      EQ
00002a  68d3              LDREQ    r3,[r2,#0xc]
00002c  f0430310          ORREQ    r3,r3,#0x10
000030  d100              BNE      |L21.52|
                  |L21.50|
000032  60d3              STR      r3,[r2,#0xc]          ;571
                  |L21.52|
;;;579        }
;;;580        break;
;;;581        
;;;582        default:
;;;583        break;
;;;584      } 
;;;585      
;;;586      /* Enable the TIM Break interrupt */
;;;587      __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
000034  6802              LDR      r2,[r0,#0]
000036  68d3              LDR      r3,[r2,#0xc]
000038  f0430380          ORR      r3,r3,#0x80
00003c  60d3              STR      r3,[r2,#0xc]
00003e  6802              LDR      r2,[r0,#0]
000040  2304              MOVS     r3,#4
000042  fa03f101          LSL      r1,r3,r1
000046  6a13              LDR      r3,[r2,#0x20]
000048  438b              BICS     r3,r3,r1
00004a  6213              STR      r3,[r2,#0x20]
00004c  6a13              LDR      r3,[r2,#0x20]
00004e  4319              ORRS     r1,r1,r3
000050  6211              STR      r1,[r2,#0x20]
;;;588      
;;;589      /* Enable the Capture compare channel N */
;;;590      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
;;;591      
;;;592      /* Enable the Main Output */
;;;593      __HAL_TIM_MOE_ENABLE(htim);
000052  6801              LDR      r1,[r0,#0]
000054  6c4a              LDR      r2,[r1,#0x44]
000056  f4424200          ORR      r2,r2,#0x8000
00005a  644a              STR      r2,[r1,#0x44]
;;;594      
;;;595      /* Enable the Peripheral */
;;;596      __HAL_TIM_ENABLE(htim);
00005c  6800              LDR      r0,[r0,#0]
00005e  6801              LDR      r1,[r0,#0]
000060  f0410101          ORR      r1,r1,#1
000064  6001              STR      r1,[r0,#0]
;;;597      
;;;598      /* Return function status */
;;;599      return HAL_OK;
000066  2000              MOVS     r0,#0
;;;600    } 
000068  4770              BX       lr
;;;601    
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Stop PROC
;;;516      */
;;;517    HAL_StatusTypeDef HAL_TIMEx_OCN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b410              PUSH     {r4}
000002  6802              LDR      r2,[r0,#0]
000004  f04f0c04          MOV      r12,#4
;;;518    { 
;;;519      /* Check the parameters */
;;;520      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;521      
;;;522        /* Disable the Capture compare channel N */
;;;523      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000008  2300              MOVS     r3,#0
00000a  6a14              LDR      r4,[r2,#0x20]
00000c  fa0cfc01          LSL      r12,r12,r1
000010  ea240c0c          BIC      r12,r4,r12
000014  f8c2c020          STR      r12,[r2,#0x20]
000018  f8d2c020          LDR      r12,[r2,#0x20]
00001c  fa03f101          LSL      r1,r3,r1
000020  ea4c0101          ORR      r1,r12,r1
000024  6211              STR      r1,[r2,#0x20]
;;;524        
;;;525      /* Disable the Main Output */
;;;526        __HAL_TIM_MOE_DISABLE(htim);
000026  6801              LDR      r1,[r0,#0]
000028  6a0b              LDR      r3,[r1,#0x20]
00002a  f2411211          MOV      r2,#0x1111
00002e  4213              TST      r3,r2
000030  f2404344          MOV      r3,#0x444
000034  bf04              ITT      EQ
000036  f8d1c020          LDREQ    r12,[r1,#0x20]
00003a  ea1c0f03          TSTEQ    r12,r3
00003e  d105              BNE      |L22.76|
000040  f8d1c044          LDR      r12,[r1,#0x44]
000044  f42c4c00          BIC      r12,r12,#0x8000
000048  f8c1c044          STR      r12,[r1,#0x44]
                  |L22.76|
;;;527    
;;;528      /* Disable the Peripheral */
;;;529      __HAL_TIM_DISABLE(htim);
00004c  6800              LDR      r0,[r0,#0]
00004e  6a01              LDR      r1,[r0,#0x20]
000050  4211              TST      r1,r2
000052  bf04              ITT      EQ
000054  6a01              LDREQ    r1,[r0,#0x20]
000056  4219              TSTEQ    r1,r3
000058  d103              BNE      |L22.98|
00005a  6801              LDR      r1,[r0,#0]
00005c  f0210101          BIC      r1,r1,#1
000060  6001              STR      r1,[r0,#0]
                  |L22.98|
;;;530      
;;;531      /* Return function status */
;;;532      return HAL_OK;
;;;533    } 
000062  bc10              POP      {r4}
000064  2000              MOVS     r0,#0                 ;532
000066  4770              BX       lr
;;;534    
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Stop_DMA PROC
;;;800      */
;;;801    HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b410              PUSH     {r4}
;;;802    {
;;;803      /* Check the parameters */
;;;804      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;805      
;;;806      switch (Channel)
000002  6802              LDR      r2,[r0,#0]
000004  2900              CMP      r1,#0
;;;807      {
;;;808        case TIM_CHANNEL_1:
;;;809        {       
;;;810          /* Disable the TIM Output Compare DMA request */
;;;811          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000006  bf04              ITT      EQ
000008  68d3              LDREQ    r3,[r2,#0xc]
00000a  f4237300          BICEQ    r3,r3,#0x200
00000e  d011              BEQ      |L23.52|
000010  2904              CMP      r1,#4                 ;806
;;;812        }
;;;813        break;
;;;814        
;;;815        case TIM_CHANNEL_2:
;;;816        {
;;;817          /* Disable the TIM Output Compare DMA request */
;;;818          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000012  bf04              ITT      EQ
000014  68d3              LDREQ    r3,[r2,#0xc]
000016  f4236380          BICEQ    r3,r3,#0x400
00001a  d00b              BEQ      |L23.52|
00001c  2908              CMP      r1,#8                 ;806
;;;819        }
;;;820        break;
;;;821        
;;;822        case TIM_CHANNEL_3:
;;;823        {
;;;824          /* Disable the TIM Output Compare DMA request */
;;;825          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
00001e  bf04              ITT      EQ
000020  68d3              LDREQ    r3,[r2,#0xc]
000022  f4236300          BICEQ    r3,r3,#0x800
000026  d005              BEQ      |L23.52|
000028  290c              CMP      r1,#0xc               ;806
;;;826        }
;;;827        break;
;;;828        
;;;829        case TIM_CHANNEL_4:
;;;830        {
;;;831          /* Disable the TIM Output Compare interrupt */
;;;832          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
00002a  bf04              ITT      EQ
00002c  68d3              LDREQ    r3,[r2,#0xc]
00002e  f4235380          BICEQ    r3,r3,#0x1000
000032  d100              BNE      |L23.54|
                  |L23.52|
000034  60d3              STR      r3,[r2,#0xc]          ;825
                  |L23.54|
000036  6802              LDR      r2,[r0,#0]            ;825
000038  f04f0c04          MOV      r12,#4                ;825
;;;833        }
;;;834        break;
;;;835        
;;;836        default:
;;;837        break;
;;;838      } 
;;;839      
;;;840      /* Disable the Capture compare channel N */
;;;841      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
00003c  2300              MOVS     r3,#0
00003e  6a14              LDR      r4,[r2,#0x20]
000040  fa0cfc01          LSL      r12,r12,r1
000044  ea240c0c          BIC      r12,r4,r12
000048  f8c2c020          STR      r12,[r2,#0x20]
00004c  f8d2c020          LDR      r12,[r2,#0x20]
000050  fa03f101          LSL      r1,r3,r1
000054  ea4c0101          ORR      r1,r12,r1
000058  6211              STR      r1,[r2,#0x20]
;;;842      
;;;843      /* Disable the Main Output */
;;;844      __HAL_TIM_MOE_DISABLE(htim);
00005a  6801              LDR      r1,[r0,#0]
00005c  6a0b              LDR      r3,[r1,#0x20]
00005e  f2411211          MOV      r2,#0x1111
000062  4213              TST      r3,r2
000064  f2404344          MOV      r3,#0x444
000068  bf04              ITT      EQ
00006a  f8d1c020          LDREQ    r12,[r1,#0x20]
00006e  ea1c0f03          TSTEQ    r12,r3
000072  d105              BNE      |L23.128|
000074  f8d1c044          LDR      r12,[r1,#0x44]
000078  f42c4c00          BIC      r12,r12,#0x8000
00007c  f8c1c044          STR      r12,[r1,#0x44]
                  |L23.128|
;;;845      
;;;846      /* Disable the Peripheral */
;;;847      __HAL_TIM_DISABLE(htim);
000080  6801              LDR      r1,[r0,#0]
000082  f8d1c020          LDR      r12,[r1,#0x20]
000086  ea1c0f02          TST      r12,r2
00008a  bf04              ITT      EQ
00008c  6a0a              LDREQ    r2,[r1,#0x20]
00008e  421a              TSTEQ    r2,r3
000090  d103              BNE      |L23.154|
000092  680a              LDR      r2,[r1,#0]
000094  f0220201          BIC      r2,r2,#1
000098  600a              STR      r2,[r1,#0]
                  |L23.154|
;;;848      
;;;849      /* Change the htim state */
;;;850      htim->State = HAL_TIM_STATE_READY;
00009a  2101              MOVS     r1,#1
00009c  63c1              STR      r1,[r0,#0x3c]
;;;851      
;;;852      /* Return function status */
;;;853      return HAL_OK;
;;;854    }
00009e  bc10              POP      {r4}
0000a0  2000              MOVS     r0,#0                 ;853
0000a2  4770              BX       lr
;;;855    /**
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Stop_IT PROC
;;;613      */
;;;614    HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b410              PUSH     {r4}
;;;615    {
;;;616      /* Check the parameters */
;;;617      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;618      
;;;619      switch (Channel)
000002  6802              LDR      r2,[r0,#0]
000004  2900              CMP      r1,#0
;;;620      {
;;;621        case TIM_CHANNEL_1:
;;;622        {       
;;;623          /* Disable the TIM Output Compare interrupt */
;;;624          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000006  bf04              ITT      EQ
000008  68d3              LDREQ    r3,[r2,#0xc]
00000a  f0230302          BICEQ    r3,r3,#2
00000e  d011              BEQ      |L24.52|
000010  2904              CMP      r1,#4                 ;619
;;;625        }
;;;626        break;
;;;627        
;;;628        case TIM_CHANNEL_2:
;;;629        {
;;;630          /* Disable the TIM Output Compare interrupt */
;;;631          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000012  bf04              ITT      EQ
000014  68d3              LDREQ    r3,[r2,#0xc]
000016  f0230304          BICEQ    r3,r3,#4
00001a  d00b              BEQ      |L24.52|
00001c  2908              CMP      r1,#8                 ;619
;;;632        }
;;;633        break;
;;;634        
;;;635        case TIM_CHANNEL_3:
;;;636        {
;;;637          /* Disable the TIM Output Compare interrupt */
;;;638          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
00001e  bf04              ITT      EQ
000020  68d3              LDREQ    r3,[r2,#0xc]
000022  f0230308          BICEQ    r3,r3,#8
000026  d005              BEQ      |L24.52|
000028  290c              CMP      r1,#0xc               ;619
;;;639        }
;;;640        break;
;;;641        
;;;642        case TIM_CHANNEL_4:
;;;643        {
;;;644          /* Disable the TIM Output Compare interrupt */
;;;645          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
00002a  bf04              ITT      EQ
00002c  68d3              LDREQ    r3,[r2,#0xc]
00002e  f0230310          BICEQ    r3,r3,#0x10
000032  d100              BNE      |L24.54|
                  |L24.52|
000034  60d3              STR      r3,[r2,#0xc]          ;638
                  |L24.54|
000036  6802              LDR      r2,[r0,#0]            ;638
000038  f04f0c04          MOV      r12,#4                ;638
;;;646        }
;;;647        break;
;;;648        
;;;649        default:
;;;650        break; 
;;;651      }
;;;652      
;;;653      /* Disable the Capture compare channel N */
;;;654      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
00003c  2300              MOVS     r3,#0
00003e  6a14              LDR      r4,[r2,#0x20]
000040  fa0cfc01          LSL      r12,r12,r1
000044  ea240c0c          BIC      r12,r4,r12
000048  f8c2c020          STR      r12,[r2,#0x20]
00004c  f8d2c020          LDR      r12,[r2,#0x20]
000050  fa03f101          LSL      r1,r3,r1
000054  ea4c0101          ORR      r1,r12,r1
000058  6211              STR      r1,[r2,#0x20]
;;;655    
;;;656      /* Disable the TIM Break interrupt (only if no more channel is active) */
;;;657      if((READ_REG(htim->Instance->CCER) & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == RESET)
00005a  6801              LDR      r1,[r0,#0]
00005c  6a0b              LDR      r3,[r1,#0x20]
00005e  f2404244          MOV      r2,#0x444
000062  4213              TST      r3,r2
000064  d103              BNE      |L24.110|
;;;658      {
;;;659        __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
000066  68cb              LDR      r3,[r1,#0xc]
000068  f0230380          BIC      r3,r3,#0x80
00006c  60cb              STR      r3,[r1,#0xc]
                  |L24.110|
;;;660      }
;;;661      
;;;662      /* Disable the Main Output */
;;;663      __HAL_TIM_MOE_DISABLE(htim);
00006e  6801              LDR      r1,[r0,#0]
000070  f8d1c020          LDR      r12,[r1,#0x20]
000074  f2411311          MOV      r3,#0x1111
000078  ea1c0f03          TST      r12,r3
00007c  bf04              ITT      EQ
00007e  f8d1c020          LDREQ    r12,[r1,#0x20]
000082  ea1c0f02          TSTEQ    r12,r2
000086  d105              BNE      |L24.148|
000088  f8d1c044          LDR      r12,[r1,#0x44]
00008c  f42c4c00          BIC      r12,r12,#0x8000
000090  f8c1c044          STR      r12,[r1,#0x44]
                  |L24.148|
;;;664      
;;;665      /* Disable the Peripheral */
;;;666      __HAL_TIM_DISABLE(htim);
000094  6800              LDR      r0,[r0,#0]
000096  6a01              LDR      r1,[r0,#0x20]
000098  4219              TST      r1,r3
00009a  bf04              ITT      EQ
00009c  6a01              LDREQ    r1,[r0,#0x20]
00009e  4211              TSTEQ    r1,r2
0000a0  d103              BNE      |L24.170|
0000a2  6801              LDR      r1,[r0,#0]
0000a4  f0210101          BIC      r1,r1,#1
0000a8  6001              STR      r1,[r0,#0]
                  |L24.170|
;;;667      
;;;668      /* Return function status */
;;;669      return HAL_OK;
;;;670    } 
0000aa  bc10              POP      {r4}
0000ac  2000              MOVS     r0,#0                 ;669
0000ae  4770              BX       lr
;;;671    
                          ENDP


                          AREA ||i.HAL_TIMEx_OnePulseN_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OnePulseN_Start PROC
;;;1300     */
;;;1301   HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  6802              LDR      r2,[r0,#0]
000002  2304              MOVS     r3,#4
000004  fa03f101          LSL      r1,r3,r1
000008  6a13              LDR      r3,[r2,#0x20]
00000a  438b              BICS     r3,r3,r1
00000c  6213              STR      r3,[r2,#0x20]
00000e  6a13              LDR      r3,[r2,#0x20]
000010  4319              ORRS     r1,r1,r3
000012  6211              STR      r1,[r2,#0x20]
;;;1302     {
;;;1303     /* Check the parameters */
;;;1304     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel)); 
;;;1305     
;;;1306     /* Enable the complementary One Pulse output */
;;;1307     TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE); 
;;;1308     
;;;1309     /* Enable the Main Output */
;;;1310     __HAL_TIM_MOE_ENABLE(htim);
000014  6800              LDR      r0,[r0,#0]
000016  6c41              LDR      r1,[r0,#0x44]
000018  f4414100          ORR      r1,r1,#0x8000
00001c  6441              STR      r1,[r0,#0x44]
;;;1311     
;;;1312     /* Return function status */
;;;1313     return HAL_OK;
00001e  2000              MOVS     r0,#0
;;;1314   }
000020  4770              BX       lr
;;;1315   
                          ENDP


                          AREA ||i.HAL_TIMEx_OnePulseN_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OnePulseN_Start_IT PROC
;;;1356     */
;;;1357   HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  6802              LDR      r2,[r0,#0]
;;;1358   {
;;;1359     /* Check the parameters */
;;;1360     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel)); 
;;;1361   
;;;1362     /* Enable the TIM Capture/Compare 1 interrupt */
;;;1363     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000002  68d3              LDR      r3,[r2,#0xc]
000004  f0430302          ORR      r3,r3,#2
000008  60d3              STR      r3,[r2,#0xc]
;;;1364     
;;;1365     /* Enable the TIM Capture/Compare 2 interrupt */
;;;1366     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00000a  6802              LDR      r2,[r0,#0]
00000c  68d3              LDR      r3,[r2,#0xc]
00000e  f0430304          ORR      r3,r3,#4
000012  60d3              STR      r3,[r2,#0xc]
000014  6802              LDR      r2,[r0,#0]
000016  2304              MOVS     r3,#4
000018  fa03f101          LSL      r1,r3,r1
00001c  6a13              LDR      r3,[r2,#0x20]
00001e  438b              BICS     r3,r3,r1
000020  6213              STR      r3,[r2,#0x20]
000022  6a13              LDR      r3,[r2,#0x20]
000024  4319              ORRS     r1,r1,r3
000026  6211              STR      r1,[r2,#0x20]
;;;1367     
;;;1368     /* Enable the complementary One Pulse output */
;;;1369     TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE); 
;;;1370     
;;;1371     /* Enable the Main Output */
;;;1372     __HAL_TIM_MOE_ENABLE(htim);
000028  6800              LDR      r0,[r0,#0]
00002a  6c41              LDR      r1,[r0,#0x44]
00002c  f4414100          ORR      r1,r1,#0x8000
000030  6441              STR      r1,[r0,#0x44]
;;;1373     
;;;1374     /* Return function status */
;;;1375     return HAL_OK;
000032  2000              MOVS     r0,#0
;;;1376     } 
000034  4770              BX       lr
;;;1377     
                          ENDP


                          AREA ||i.HAL_TIMEx_OnePulseN_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OnePulseN_Stop PROC
;;;1326     */
;;;1327   HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b410              PUSH     {r4}
000002  6802              LDR      r2,[r0,#0]
000004  f04f0c04          MOV      r12,#4
;;;1328   {
;;;1329   
;;;1330     /* Check the parameters */
;;;1331     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel)); 
;;;1332   
;;;1333     /* Disable the complementary One Pulse output */
;;;1334       TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
000008  2300              MOVS     r3,#0
00000a  6a14              LDR      r4,[r2,#0x20]
00000c  fa0cfc01          LSL      r12,r12,r1
000010  ea240c0c          BIC      r12,r4,r12
000014  f8c2c020          STR      r12,[r2,#0x20]
000018  f8d2c020          LDR      r12,[r2,#0x20]
00001c  fa03f101          LSL      r1,r3,r1
000020  ea4c0101          ORR      r1,r12,r1
000024  6211              STR      r1,[r2,#0x20]
;;;1335     
;;;1336     /* Disable the Main Output */
;;;1337       __HAL_TIM_MOE_DISABLE(htim);
000026  6801              LDR      r1,[r0,#0]
000028  6a0b              LDR      r3,[r1,#0x20]
00002a  f2411211          MOV      r2,#0x1111
00002e  4213              TST      r3,r2
000030  f2404344          MOV      r3,#0x444
000034  bf04              ITT      EQ
000036  f8d1c020          LDREQ    r12,[r1,#0x20]
00003a  ea1c0f03          TSTEQ    r12,r3
00003e  d105              BNE      |L27.76|
000040  f8d1c044          LDR      r12,[r1,#0x44]
000044  f42c4c00          BIC      r12,r12,#0x8000
000048  f8c1c044          STR      r12,[r1,#0x44]
                  |L27.76|
;;;1338     
;;;1339     /* Disable the Peripheral */
;;;1340     __HAL_TIM_DISABLE(htim); 
00004c  6800              LDR      r0,[r0,#0]
00004e  6a01              LDR      r1,[r0,#0x20]
000050  4211              TST      r1,r2
000052  bf04              ITT      EQ
000054  6a01              LDREQ    r1,[r0,#0x20]
000056  4219              TSTEQ    r1,r3
000058  d103              BNE      |L27.98|
00005a  6801              LDR      r1,[r0,#0]
00005c  f0210101          BIC      r1,r1,#1
000060  6001              STR      r1,[r0,#0]
                  |L27.98|
;;;1341      
;;;1342     /* Return function status */
;;;1343     return HAL_OK;
;;;1344   }
000062  bc10              POP      {r4}
000064  2000              MOVS     r0,#0                 ;1343
000066  4770              BX       lr
;;;1345   
                          ENDP


                          AREA ||i.HAL_TIMEx_OnePulseN_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OnePulseN_Stop_IT PROC
;;;1388     */
;;;1389   HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b410              PUSH     {r4}
;;;1390   {
;;;1391     /* Check the parameters */
;;;1392     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel)); 
;;;1393   
;;;1394     /* Disable the TIM Capture/Compare 1 interrupt */
;;;1395     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000002  6802              LDR      r2,[r0,#0]
000004  68d3              LDR      r3,[r2,#0xc]
000006  f0230302          BIC      r3,r3,#2
00000a  60d3              STR      r3,[r2,#0xc]
;;;1396     
;;;1397     /* Disable the TIM Capture/Compare 2 interrupt */
;;;1398     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00000c  6802              LDR      r2,[r0,#0]
00000e  68d3              LDR      r3,[r2,#0xc]
000010  f0230304          BIC      r3,r3,#4
000014  60d3              STR      r3,[r2,#0xc]
000016  6802              LDR      r2,[r0,#0]
000018  f04f0c04          MOV      r12,#4
;;;1399     
;;;1400     /* Disable the complementary One Pulse output */
;;;1401     TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
00001c  2300              MOVS     r3,#0
00001e  6a14              LDR      r4,[r2,#0x20]
000020  fa0cfc01          LSL      r12,r12,r1
000024  ea240c0c          BIC      r12,r4,r12
000028  f8c2c020          STR      r12,[r2,#0x20]
00002c  f8d2c020          LDR      r12,[r2,#0x20]
000030  fa03f101          LSL      r1,r3,r1
000034  ea4c0101          ORR      r1,r12,r1
000038  6211              STR      r1,[r2,#0x20]
;;;1402     
;;;1403     /* Disable the Main Output */
;;;1404     __HAL_TIM_MOE_DISABLE(htim);
00003a  6801              LDR      r1,[r0,#0]
00003c  6a0b              LDR      r3,[r1,#0x20]
00003e  f2411211          MOV      r2,#0x1111
000042  4213              TST      r3,r2
000044  f2404344          MOV      r3,#0x444
000048  bf04              ITT      EQ
00004a  f8d1c020          LDREQ    r12,[r1,#0x20]
00004e  ea1c0f03          TSTEQ    r12,r3
000052  d105              BNE      |L28.96|
000054  f8d1c044          LDR      r12,[r1,#0x44]
000058  f42c4c00          BIC      r12,r12,#0x8000
00005c  f8c1c044          STR      r12,[r1,#0x44]
                  |L28.96|
;;;1405     
;;;1406     /* Disable the Peripheral */
;;;1407      __HAL_TIM_DISABLE(htim);  
000060  6800              LDR      r0,[r0,#0]
000062  6a01              LDR      r1,[r0,#0x20]
000064  4211              TST      r1,r2
000066  bf04              ITT      EQ
000068  6a01              LDREQ    r1,[r0,#0x20]
00006a  4219              TSTEQ    r1,r3
00006c  d103              BNE      |L28.118|
00006e  6801              LDR      r1,[r0,#0]
000070  f0210101          BIC      r1,r1,#1
000074  6001              STR      r1,[r0,#0]
                  |L28.118|
;;;1408     
;;;1409     /* Return function status */
;;;1410     return HAL_OK;
;;;1411   }
000076  bc10              POP      {r4}
000078  2000              MOVS     r0,#0                 ;1410
00007a  4770              BX       lr
;;;1412   /**
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Start PROC
;;;899      */
;;;900    HAL_StatusTypeDef HAL_TIMEx_PWMN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
000002  2304              MOVS     r3,#4
000004  fa03f101          LSL      r1,r3,r1
000008  6a13              LDR      r3,[r2,#0x20]
00000a  438b              BICS     r3,r3,r1
00000c  6213              STR      r3,[r2,#0x20]
00000e  6a13              LDR      r3,[r2,#0x20]
000010  4319              ORRS     r1,r1,r3
000012  6211              STR      r1,[r2,#0x20]
;;;901    {
;;;902      /* Check the parameters */
;;;903      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;904      
;;;905      /* Enable the complementary PWM output  */
;;;906      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
;;;907      
;;;908      /* Enable the Main Output */
;;;909      __HAL_TIM_MOE_ENABLE(htim);
000014  6801              LDR      r1,[r0,#0]
000016  6c4a              LDR      r2,[r1,#0x44]
000018  f4424200          ORR      r2,r2,#0x8000
00001c  644a              STR      r2,[r1,#0x44]
;;;910      
;;;911      /* Enable the Peripheral */
;;;912      __HAL_TIM_ENABLE(htim);
00001e  6800              LDR      r0,[r0,#0]
000020  6801              LDR      r1,[r0,#0]
000022  f0410101          ORR      r1,r1,#1
000026  6001              STR      r1,[r0,#0]
;;;913      
;;;914      /* Return function status */
;;;915      return HAL_OK;
000028  2000              MOVS     r0,#0
;;;916    } 
00002a  4770              BX       lr
;;;917    
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_PWMN_Start_DMA PROC
;;;1097     */
;;;1098   HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;1099   {
000002  4604              MOV      r4,r0
;;;1100     /* Check the parameters */
;;;1101     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;1102     
;;;1103     if((htim->State == HAL_TIM_STATE_BUSY))
000004  6bc0              LDR      r0,[r0,#0x3c]
000006  4694              MOV      r12,r2                ;1099
000008  460d              MOV      r5,r1                 ;1099
00000a  2802              CMP      r0,#2
;;;1104     {
;;;1105        return HAL_BUSY;
;;;1106     }
;;;1107     else if((htim->State == HAL_TIM_STATE_READY))
;;;1108     {
;;;1109       if(((uint32_t)pData == 0U) && (Length > 0)) 
;;;1110       {
;;;1111         return HAL_ERROR;                                    
;;;1112       }
;;;1113       else
;;;1114       {
;;;1115         htim->State = HAL_TIM_STATE_BUSY;
;;;1116       }
;;;1117     }    
;;;1118     switch (Channel)
;;;1119     {
;;;1120       case TIM_CHANNEL_1:
;;;1121       {      
;;;1122         /* Set the DMA Period elapsed callback */
;;;1123         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1124        
;;;1125         /* Set the DMA error callback */
;;;1126         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;1127         
;;;1128         /* Enable the DMA Stream */
;;;1129         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;1130         
;;;1131         /* Enable the TIM Capture/Compare 1 DMA request */
;;;1132         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1133       }
;;;1134       break;
;;;1135       
;;;1136       case TIM_CHANNEL_2:
;;;1137       {
;;;1138         /* Set the DMA Period elapsed callback */
;;;1139         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1140        
;;;1141         /* Set the DMA error callback */
;;;1142         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;1143         
;;;1144         /* Enable the DMA Stream */
;;;1145         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;1146         
;;;1147         /* Enable the TIM Capture/Compare 2 DMA request */
;;;1148         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1149       }
;;;1150       break;
;;;1151       
;;;1152       case TIM_CHANNEL_3:
;;;1153       {
;;;1154         /* Set the DMA Period elapsed callback */
;;;1155         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1156        
;;;1157         /* Set the DMA error callback */
;;;1158         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;1159         
;;;1160         /* Enable the DMA Stream */
;;;1161         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;1162         
;;;1163         /* Enable the TIM Capture/Compare 3 DMA request */
;;;1164         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1165       }
;;;1166       break;
;;;1167       
;;;1168       case TIM_CHANNEL_4:
;;;1169       {
;;;1170        /* Set the DMA Period elapsed callback */
;;;1171         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1172        
;;;1173         /* Set the DMA error callback */
;;;1174         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;1175         
;;;1176         /* Enable the DMA Stream */
;;;1177         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;1178         
;;;1179         /* Enable the TIM Capture/Compare 4 DMA request */
;;;1180         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1181       }
;;;1182       break;
;;;1183       
;;;1184       default:
;;;1185       break;
;;;1186     }
;;;1187   
;;;1188     /* Enable the complementary PWM output  */
;;;1189        TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
;;;1190       
;;;1191     /* Enable the Main Output */
;;;1192       __HAL_TIM_MOE_ENABLE(htim);
;;;1193     
;;;1194     /* Enable the Peripheral */
;;;1195     __HAL_TIM_ENABLE(htim); 
;;;1196     
;;;1197     /* Return function status */
;;;1198     return HAL_OK;
;;;1199   }
00000c  bf08              IT       EQ
00000e  bd70              POPEQ    {r4-r6,pc}
000010  6be0              LDR      r0,[r4,#0x3c]         ;1107
000012  2801              CMP      r0,#1                 ;1107
000014  d108              BNE      |L30.40|
000016  f1bc0f00          CMP      r12,#0                ;1109
00001a  d103              BNE      |L30.36|
00001c  2b00              CMP      r3,#0                 ;1109
00001e  bf1c              ITT      NE                    ;1111
000020  2001              MOVNE    r0,#1                 ;1111
000022  bd70              POPNE    {r4-r6,pc}
                  |L30.36|
000024  2002              MOVS     r0,#2                 ;1115
000026  63e0              STR      r0,[r4,#0x3c]         ;1115
                  |L30.40|
000028  482f              LDR      r0,|L30.232|
00002a  4930              LDR      r1,|L30.236|
00002c  b135              CBZ      r5,|L30.60|
00002e  2d04              CMP      r5,#4                 ;1118
000030  d014              BEQ      |L30.92|
000032  2d08              CMP      r5,#8                 ;1118
000034  d022              BEQ      |L30.124|
000036  2d0c              CMP      r5,#0xc               ;1118
000038  d030              BEQ      |L30.156|
00003a  e03f              B        |L30.188|
                  |L30.60|
00003c  6a22              LDR      r2,[r4,#0x20]         ;1123
00003e  6410              STR      r0,[r2,#0x40]         ;1126
000040  6a20              LDR      r0,[r4,#0x20]         ;1126
000042  6501              STR      r1,[r0,#0x50]         ;1129
000044  6820              LDR      r0,[r4,#0]            ;1129
000046  4661              MOV      r1,r12                ;1129
000048  f1000234          ADD      r2,r0,#0x34           ;1129
00004c  6a20              LDR      r0,[r4,#0x20]         ;1129
00004e  f7fffffe          BL       HAL_DMA_Start_IT
000052  6820              LDR      r0,[r4,#0]            ;1132
000054  68c1              LDR      r1,[r0,#0xc]          ;1132
000056  f4417100          ORR      r1,r1,#0x200          ;1132
00005a  e02e              B        |L30.186|
                  |L30.92|
00005c  6a62              LDR      r2,[r4,#0x24]         ;1139
00005e  6410              STR      r0,[r2,#0x40]         ;1142
000060  6a60              LDR      r0,[r4,#0x24]         ;1142
000062  6501              STR      r1,[r0,#0x50]         ;1145
000064  6820              LDR      r0,[r4,#0]            ;1145
000066  4661              MOV      r1,r12                ;1145
000068  f1000238          ADD      r2,r0,#0x38           ;1145
00006c  6a60              LDR      r0,[r4,#0x24]         ;1145
00006e  f7fffffe          BL       HAL_DMA_Start_IT
000072  6820              LDR      r0,[r4,#0]            ;1148
000074  68c1              LDR      r1,[r0,#0xc]          ;1148
000076  f4416180          ORR      r1,r1,#0x400          ;1148
00007a  e01e              B        |L30.186|
                  |L30.124|
00007c  6aa2              LDR      r2,[r4,#0x28]         ;1155
00007e  6410              STR      r0,[r2,#0x40]         ;1158
000080  6aa0              LDR      r0,[r4,#0x28]         ;1158
000082  6501              STR      r1,[r0,#0x50]         ;1161
000084  6820              LDR      r0,[r4,#0]            ;1161
000086  4661              MOV      r1,r12                ;1161
000088  f100023c          ADD      r2,r0,#0x3c           ;1161
00008c  6aa0              LDR      r0,[r4,#0x28]         ;1161
00008e  f7fffffe          BL       HAL_DMA_Start_IT
000092  6820              LDR      r0,[r4,#0]            ;1164
000094  68c1              LDR      r1,[r0,#0xc]          ;1164
000096  f4416100          ORR      r1,r1,#0x800          ;1164
00009a  e00e              B        |L30.186|
                  |L30.156|
00009c  6ae2              LDR      r2,[r4,#0x2c]         ;1171
00009e  6410              STR      r0,[r2,#0x40]         ;1174
0000a0  6ae0              LDR      r0,[r4,#0x2c]         ;1174
0000a2  6501              STR      r1,[r0,#0x50]         ;1177
0000a4  6820              LDR      r0,[r4,#0]            ;1177
0000a6  4661              MOV      r1,r12                ;1177
0000a8  f1000240          ADD      r2,r0,#0x40           ;1177
0000ac  6ae0              LDR      r0,[r4,#0x2c]         ;1177
0000ae  f7fffffe          BL       HAL_DMA_Start_IT
0000b2  6820              LDR      r0,[r4,#0]            ;1180
0000b4  68c1              LDR      r1,[r0,#0xc]          ;1180
0000b6  f4415180          ORR      r1,r1,#0x1000         ;1180
                  |L30.186|
0000ba  60c1              STR      r1,[r0,#0xc]          ;1164
                  |L30.188|
0000bc  6820              LDR      r0,[r4,#0]            ;1164
0000be  2104              MOVS     r1,#4                 ;1164
0000c0  40a9              LSLS     r1,r1,r5              ;1164
0000c2  6a02              LDR      r2,[r0,#0x20]         ;1164
0000c4  438a              BICS     r2,r2,r1              ;1164
0000c6  6202              STR      r2,[r0,#0x20]         ;1164
0000c8  6a02              LDR      r2,[r0,#0x20]         ;1164
0000ca  4311              ORRS     r1,r1,r2              ;1164
0000cc  6201              STR      r1,[r0,#0x20]         ;1164
0000ce  6820              LDR      r0,[r4,#0]            ;1192
0000d0  6c41              LDR      r1,[r0,#0x44]         ;1192
0000d2  f4414100          ORR      r1,r1,#0x8000         ;1192
0000d6  6441              STR      r1,[r0,#0x44]         ;1192
0000d8  6820              LDR      r0,[r4,#0]            ;1195
0000da  6801              LDR      r1,[r0,#0]            ;1195
0000dc  f0410101          ORR      r1,r1,#1              ;1195
0000e0  6001              STR      r1,[r0,#0]            ;1195
0000e2  2000              MOVS     r0,#0                 ;1198
0000e4  bd70              POP      {r4-r6,pc}
;;;1200   
                          ENDP

0000e6  0000              DCW      0x0000
                  |L30.232|
                          DCD      TIM_DMADelayPulseCplt
                  |L30.236|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIMEx_PWMN_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Start_IT PROC
;;;958      */
;;;959    HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
;;;960    {
;;;961      /* Check the parameters */
;;;962      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;963      
;;;964      switch (Channel)
000002  2900              CMP      r1,#0
;;;965      {
;;;966        case TIM_CHANNEL_1:
;;;967        {       
;;;968          /* Enable the TIM Capture/Compare 1 interrupt */
;;;969          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000004  bf04              ITT      EQ
000006  68d3              LDREQ    r3,[r2,#0xc]
000008  f0430302          ORREQ    r3,r3,#2
00000c  d011              BEQ      |L31.50|
00000e  2904              CMP      r1,#4                 ;964
;;;970        }
;;;971        break;
;;;972        
;;;973        case TIM_CHANNEL_2:
;;;974        {
;;;975          /* Enable the TIM Capture/Compare 2 interrupt */
;;;976          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000010  bf04              ITT      EQ
000012  68d3              LDREQ    r3,[r2,#0xc]
000014  f0430304          ORREQ    r3,r3,#4
000018  d00b              BEQ      |L31.50|
00001a  2908              CMP      r1,#8                 ;964
;;;977        }
;;;978        break;
;;;979        
;;;980        case TIM_CHANNEL_3:
;;;981        {
;;;982          /* Enable the TIM Capture/Compare 3 interrupt */
;;;983          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
00001c  bf04              ITT      EQ
00001e  68d3              LDREQ    r3,[r2,#0xc]
000020  f0430308          ORREQ    r3,r3,#8
000024  d005              BEQ      |L31.50|
000026  290c              CMP      r1,#0xc               ;964
;;;984        }
;;;985        break;
;;;986        
;;;987        case TIM_CHANNEL_4:
;;;988        {
;;;989          /* Enable the TIM Capture/Compare 4 interrupt */
;;;990          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000028  bf04              ITT      EQ
00002a  68d3              LDREQ    r3,[r2,#0xc]
00002c  f0430310          ORREQ    r3,r3,#0x10
000030  d100              BNE      |L31.52|
                  |L31.50|
000032  60d3              STR      r3,[r2,#0xc]          ;983
                  |L31.52|
;;;991        }
;;;992        break;
;;;993        
;;;994        default:
;;;995        break;
;;;996      } 
;;;997      
;;;998      /* Enable the TIM Break interrupt */
;;;999      __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
000034  6802              LDR      r2,[r0,#0]
000036  68d3              LDR      r3,[r2,#0xc]
000038  f0430380          ORR      r3,r3,#0x80
00003c  60d3              STR      r3,[r2,#0xc]
00003e  6802              LDR      r2,[r0,#0]
000040  2304              MOVS     r3,#4
000042  fa03f101          LSL      r1,r3,r1
000046  6a13              LDR      r3,[r2,#0x20]
000048  438b              BICS     r3,r3,r1
00004a  6213              STR      r3,[r2,#0x20]
00004c  6a13              LDR      r3,[r2,#0x20]
00004e  4319              ORRS     r1,r1,r3
000050  6211              STR      r1,[r2,#0x20]
;;;1000     
;;;1001     /* Enable the complementary PWM output  */
;;;1002     TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
;;;1003     
;;;1004     /* Enable the Main Output */
;;;1005     __HAL_TIM_MOE_ENABLE(htim);
000052  6801              LDR      r1,[r0,#0]
000054  6c4a              LDR      r2,[r1,#0x44]
000056  f4424200          ORR      r2,r2,#0x8000
00005a  644a              STR      r2,[r1,#0x44]
;;;1006     
;;;1007     /* Enable the Peripheral */
;;;1008     __HAL_TIM_ENABLE(htim);
00005c  6800              LDR      r0,[r0,#0]
00005e  6801              LDR      r1,[r0,#0]
000060  f0410101          ORR      r1,r1,#1
000064  6001              STR      r1,[r0,#0]
;;;1009     
;;;1010     /* Return function status */
;;;1011     return HAL_OK;
000066  2000              MOVS     r0,#0
;;;1012   } 
000068  4770              BX       lr
;;;1013   
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Stop PROC
;;;928      */
;;;929    HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b410              PUSH     {r4}
000002  6802              LDR      r2,[r0,#0]
000004  f04f0c04          MOV      r12,#4
;;;930    { 
;;;931      /* Check the parameters */
;;;932      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;933      
;;;934      /* Disable the complementary PWM output  */
;;;935      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);  
000008  2300              MOVS     r3,#0
00000a  6a14              LDR      r4,[r2,#0x20]
00000c  fa0cfc01          LSL      r12,r12,r1
000010  ea240c0c          BIC      r12,r4,r12
000014  f8c2c020          STR      r12,[r2,#0x20]
000018  f8d2c020          LDR      r12,[r2,#0x20]
00001c  fa03f101          LSL      r1,r3,r1
000020  ea4c0101          ORR      r1,r12,r1
000024  6211              STR      r1,[r2,#0x20]
;;;936      
;;;937      /* Disable the Main Output */
;;;938      __HAL_TIM_MOE_DISABLE(htim);
000026  6801              LDR      r1,[r0,#0]
000028  6a0b              LDR      r3,[r1,#0x20]
00002a  f2411211          MOV      r2,#0x1111
00002e  4213              TST      r3,r2
000030  f2404344          MOV      r3,#0x444
000034  bf04              ITT      EQ
000036  f8d1c020          LDREQ    r12,[r1,#0x20]
00003a  ea1c0f03          TSTEQ    r12,r3
00003e  d105              BNE      |L32.76|
000040  f8d1c044          LDR      r12,[r1,#0x44]
000044  f42c4c00          BIC      r12,r12,#0x8000
000048  f8c1c044          STR      r12,[r1,#0x44]
                  |L32.76|
;;;939      
;;;940      /* Disable the Peripheral */
;;;941      __HAL_TIM_DISABLE(htim);
00004c  6800              LDR      r0,[r0,#0]
00004e  6a01              LDR      r1,[r0,#0x20]
000050  4211              TST      r1,r2
000052  bf04              ITT      EQ
000054  6a01              LDREQ    r1,[r0,#0x20]
000056  4219              TSTEQ    r1,r3
000058  d103              BNE      |L32.98|
00005a  6801              LDR      r1,[r0,#0]
00005c  f0210101          BIC      r1,r1,#1
000060  6001              STR      r1,[r0,#0]
                  |L32.98|
;;;942      
;;;943      /* Return function status */
;;;944      return HAL_OK;
;;;945    } 
000062  bc10              POP      {r4}
000064  2000              MOVS     r0,#0                 ;944
000066  4770              BX       lr
;;;946    
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Stop_DMA PROC
;;;1212     */
;;;1213   HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b410              PUSH     {r4}
;;;1214   {
;;;1215     /* Check the parameters */
;;;1216     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;1217     
;;;1218     switch (Channel)
000002  6802              LDR      r2,[r0,#0]
000004  2900              CMP      r1,#0
;;;1219     {
;;;1220       case TIM_CHANNEL_1:
;;;1221       {       
;;;1222         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1223         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000006  bf04              ITT      EQ
000008  68d3              LDREQ    r3,[r2,#0xc]
00000a  f4237300          BICEQ    r3,r3,#0x200
00000e  d011              BEQ      |L33.52|
000010  2904              CMP      r1,#4                 ;1218
;;;1224       }
;;;1225       break;
;;;1226       
;;;1227       case TIM_CHANNEL_2:
;;;1228       {
;;;1229         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1230         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000012  bf04              ITT      EQ
000014  68d3              LDREQ    r3,[r2,#0xc]
000016  f4236380          BICEQ    r3,r3,#0x400
00001a  d00b              BEQ      |L33.52|
00001c  2908              CMP      r1,#8                 ;1218
;;;1231       }
;;;1232       break;
;;;1233       
;;;1234       case TIM_CHANNEL_3:
;;;1235       {
;;;1236         /* Disable the TIM Capture/Compare 3 DMA request */
;;;1237         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
00001e  bf04              ITT      EQ
000020  68d3              LDREQ    r3,[r2,#0xc]
000022  f4236300          BICEQ    r3,r3,#0x800
000026  d005              BEQ      |L33.52|
000028  290c              CMP      r1,#0xc               ;1218
;;;1238       }
;;;1239       break;
;;;1240       
;;;1241       case TIM_CHANNEL_4:
;;;1242       {
;;;1243         /* Disable the TIM Capture/Compare 4 DMA request */
;;;1244         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
00002a  bf04              ITT      EQ
00002c  68d3              LDREQ    r3,[r2,#0xc]
00002e  f4235380          BICEQ    r3,r3,#0x1000
000032  d100              BNE      |L33.54|
                  |L33.52|
000034  60d3              STR      r3,[r2,#0xc]          ;1237
                  |L33.54|
000036  6802              LDR      r2,[r0,#0]            ;1237
000038  f04f0c04          MOV      r12,#4                ;1237
;;;1245       }
;;;1246       break;
;;;1247       
;;;1248       default:
;;;1249       break;
;;;1250     } 
;;;1251     
;;;1252     /* Disable the complementary PWM output */
;;;1253       TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
00003c  2300              MOVS     r3,#0
00003e  6a14              LDR      r4,[r2,#0x20]
000040  fa0cfc01          LSL      r12,r12,r1
000044  ea240c0c          BIC      r12,r4,r12
000048  f8c2c020          STR      r12,[r2,#0x20]
00004c  f8d2c020          LDR      r12,[r2,#0x20]
000050  fa03f101          LSL      r1,r3,r1
000054  ea4c0101          ORR      r1,r12,r1
000058  6211              STR      r1,[r2,#0x20]
;;;1254        
;;;1255     /* Disable the Main Output */
;;;1256       __HAL_TIM_MOE_DISABLE(htim);
00005a  6801              LDR      r1,[r0,#0]
00005c  6a0b              LDR      r3,[r1,#0x20]
00005e  f2411211          MOV      r2,#0x1111
000062  4213              TST      r3,r2
000064  f2404344          MOV      r3,#0x444
000068  bf04              ITT      EQ
00006a  f8d1c020          LDREQ    r12,[r1,#0x20]
00006e  ea1c0f03          TSTEQ    r12,r3
000072  d105              BNE      |L33.128|
000074  f8d1c044          LDR      r12,[r1,#0x44]
000078  f42c4c00          BIC      r12,r12,#0x8000
00007c  f8c1c044          STR      r12,[r1,#0x44]
                  |L33.128|
;;;1257   
;;;1258     /* Disable the Peripheral */
;;;1259     __HAL_TIM_DISABLE(htim);
000080  6801              LDR      r1,[r0,#0]
000082  f8d1c020          LDR      r12,[r1,#0x20]
000086  ea1c0f02          TST      r12,r2
00008a  bf04              ITT      EQ
00008c  6a0a              LDREQ    r2,[r1,#0x20]
00008e  421a              TSTEQ    r2,r3
000090  d103              BNE      |L33.154|
000092  680a              LDR      r2,[r1,#0]
000094  f0220201          BIC      r2,r2,#1
000098  600a              STR      r2,[r1,#0]
                  |L33.154|
;;;1260     
;;;1261     /* Change the htim state */
;;;1262     htim->State = HAL_TIM_STATE_READY;
00009a  2101              MOVS     r1,#1
00009c  63c1              STR      r1,[r0,#0x3c]
;;;1263     
;;;1264     /* Return function status */
;;;1265     return HAL_OK;
;;;1266   }
00009e  bc10              POP      {r4}
0000a0  2000              MOVS     r0,#0                 ;1265
0000a2  4770              BX       lr
;;;1267   
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Stop_IT PROC
;;;1025     */
;;;1026   HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b410              PUSH     {r4}
;;;1027   {
;;;1028     /* Check the parameters */
;;;1029     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;1030   
;;;1031     switch (Channel)
000002  6802              LDR      r2,[r0,#0]
000004  2900              CMP      r1,#0
;;;1032     {
;;;1033       case TIM_CHANNEL_1:
;;;1034       {       
;;;1035         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1036         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000006  bf04              ITT      EQ
000008  68d3              LDREQ    r3,[r2,#0xc]
00000a  f0230302          BICEQ    r3,r3,#2
00000e  d011              BEQ      |L34.52|
000010  2904              CMP      r1,#4                 ;1031
;;;1037       }
;;;1038       break;
;;;1039       
;;;1040       case TIM_CHANNEL_2:
;;;1041       {
;;;1042         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1043         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000012  bf04              ITT      EQ
000014  68d3              LDREQ    r3,[r2,#0xc]
000016  f0230304          BICEQ    r3,r3,#4
00001a  d00b              BEQ      |L34.52|
00001c  2908              CMP      r1,#8                 ;1031
;;;1044       }
;;;1045       break;
;;;1046       
;;;1047       case TIM_CHANNEL_3:
;;;1048       {
;;;1049         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1050         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
00001e  bf04              ITT      EQ
000020  68d3              LDREQ    r3,[r2,#0xc]
000022  f0230308          BICEQ    r3,r3,#8
000026  d005              BEQ      |L34.52|
000028  290c              CMP      r1,#0xc               ;1031
;;;1051       }
;;;1052       break;
;;;1053       
;;;1054       case TIM_CHANNEL_4:
;;;1055       {
;;;1056         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1057         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
00002a  bf04              ITT      EQ
00002c  68d3              LDREQ    r3,[r2,#0xc]
00002e  f0230310          BICEQ    r3,r3,#0x10
000032  d100              BNE      |L34.54|
                  |L34.52|
000034  60d3              STR      r3,[r2,#0xc]          ;1050
                  |L34.54|
000036  6802              LDR      r2,[r0,#0]            ;1050
000038  f04f0c04          MOV      r12,#4                ;1050
;;;1058       }
;;;1059       break;
;;;1060       
;;;1061       default:
;;;1062       break; 
;;;1063     }
;;;1064     
;;;1065     /* Disable the complementary PWM output  */
;;;1066     TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
00003c  2300              MOVS     r3,#0
00003e  6a14              LDR      r4,[r2,#0x20]
000040  fa0cfc01          LSL      r12,r12,r1
000044  ea240c0c          BIC      r12,r4,r12
000048  f8c2c020          STR      r12,[r2,#0x20]
00004c  f8d2c020          LDR      r12,[r2,#0x20]
000050  fa03f101          LSL      r1,r3,r1
000054  ea4c0101          ORR      r1,r12,r1
000058  6211              STR      r1,[r2,#0x20]
;;;1067     
;;;1068     /* Disable the TIM Break interrupt (only if no more channel is active) */
;;;1069     if((READ_REG(htim->Instance->CCER) & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == RESET)
00005a  6801              LDR      r1,[r0,#0]
00005c  6a0b              LDR      r3,[r1,#0x20]
00005e  f2404244          MOV      r2,#0x444
000062  4213              TST      r3,r2
000064  d103              BNE      |L34.110|
;;;1070     {
;;;1071       __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
000066  68cb              LDR      r3,[r1,#0xc]
000068  f0230380          BIC      r3,r3,#0x80
00006c  60cb              STR      r3,[r1,#0xc]
                  |L34.110|
;;;1072     }
;;;1073     
;;;1074     /* Disable the Main Output */
;;;1075     __HAL_TIM_MOE_DISABLE(htim);
00006e  6801              LDR      r1,[r0,#0]
000070  f8d1c020          LDR      r12,[r1,#0x20]
000074  f2411311          MOV      r3,#0x1111
000078  ea1c0f03          TST      r12,r3
00007c  bf04              ITT      EQ
00007e  f8d1c020          LDREQ    r12,[r1,#0x20]
000082  ea1c0f02          TSTEQ    r12,r2
000086  d105              BNE      |L34.148|
000088  f8d1c044          LDR      r12,[r1,#0x44]
00008c  f42c4c00          BIC      r12,r12,#0x8000
000090  f8c1c044          STR      r12,[r1,#0x44]
                  |L34.148|
;;;1076     
;;;1077     /* Disable the Peripheral */
;;;1078     __HAL_TIM_DISABLE(htim);
000094  6800              LDR      r0,[r0,#0]
000096  6a01              LDR      r1,[r0,#0x20]
000098  4219              TST      r1,r3
00009a  bf04              ITT      EQ
00009c  6a01              LDREQ    r1,[r0,#0x20]
00009e  4211              TSTEQ    r1,r2
0000a0  d103              BNE      |L34.170|
0000a2  6801              LDR      r1,[r0,#0]
0000a4  f0210101          BIC      r1,r1,#1
0000a8  6001              STR      r1,[r0,#0]
                  |L34.170|
;;;1079     
;;;1080     /* Return function status */
;;;1081     return HAL_OK;
;;;1082   } 
0000aa  bc10              POP      {r4}
0000ac  2000              MOVS     r0,#0                 ;1081
0000ae  4770              BX       lr
;;;1083   
                          ENDP


                          AREA ||i.HAL_TIMEx_RemapConfig||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_RemapConfig PROC
;;;1707     */
;;;1708   HAL_StatusTypeDef HAL_TIMEx_RemapConfig(TIM_HandleTypeDef *htim, uint32_t Remap)
000000  6b82              LDR      r2,[r0,#0x38]
;;;1709   {
;;;1710     __HAL_LOCK(htim);
000002  2a01              CMP      r2,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;1711       
;;;1712     /* Check parameters */
;;;1713     assert_param(IS_TIM_REMAP_INSTANCE(htim->Instance));
;;;1714     assert_param(IS_TIM_REMAP(Remap));
;;;1715   
;;;1716   #if defined(LPTIM_OR_TIM1_ITR2_RMP)
;;;1717     if ((Remap == TIM_TIM9_TIM3_TRGO)|| (Remap == TIM_TIM9_LPTIM)||(Remap ==TIM_TIM5_TIM3_TRGO)||\
;;;1718        (Remap == TIM_TIM5_LPTIM)||(Remap == TIM_TIM1_TIM3_TRGO)|| (Remap == TIM_TIM1_LPTIM))
;;;1719     {
;;;1720       __HAL_RCC_LPTIM1_CLK_ENABLE();
;;;1721   
;;;1722       LPTIM1->OR = (Remap& 0xEFFFFFFFU);
;;;1723     }
;;;1724     else
;;;1725     {
;;;1726       /* Set the Timer remapping configuration */
;;;1727       htim->Instance->OR = Remap;
;;;1728     }
;;;1729   #else
;;;1730     /* Set the Timer remapping configuration */
;;;1731     htim->Instance->OR = Remap;
;;;1732   #endif
;;;1733     htim->State = HAL_TIM_STATE_READY;
;;;1734     
;;;1735     __HAL_UNLOCK(htim);  
;;;1736     
;;;1737     return HAL_OK;
;;;1738   }
000008  4770              BXEQ     lr
00000a  2201              MOVS     r2,#1                 ;1710
00000c  6803              LDR      r3,[r0,#0]            ;1731
00000e  6519              STR      r1,[r3,#0x50]         ;1731
000010  63c2              STR      r2,[r0,#0x3c]         ;1733
000012  2100              MOVS     r1,#0                 ;1735
000014  6381              STR      r1,[r0,#0x38]         ;1737
000016  4608              MOV      r0,r1                 ;1737
000018  4770              BX       lr
;;;1739   
                          ENDP


                          AREA ||i.TIMEx_DMACommutationCplt||, CODE, READONLY, ALIGN=1

                  TIMEx_DMACommutationCplt PROC
;;;1828     */
;;;1829   void TIMEx_DMACommutationCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1830   {
;;;1831     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;1832     
;;;1833     htim->State= HAL_TIM_STATE_READY;
000004  2101              MOVS     r1,#1
000006  63c1              STR      r1,[r0,#0x3c]
;;;1834       
;;;1835     HAL_TIMEx_CommutationCallback(htim); 
000008  f7fffffe          BL       HAL_TIMEx_CommutationCallback
;;;1836   }
00000c  bd10              POP      {r4,pc}
;;;1837   /**
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F4_V1.21.0\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_tim_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f4xx_hal_tim_ex_c_e8ef3920____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F4_V1.21.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___22_stm32f4xx_hal_tim_ex_c_e8ef3920____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f4xx_hal_tim_ex_c_e8ef3920____REVSH|
#line 402
|__asm___22_stm32f4xx_hal_tim_ex_c_e8ef3920____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f4xx_hal_tim_ex_c_e8ef3920____RRX|
#line 587
|__asm___22_stm32f4xx_hal_tim_ex_c_e8ef3920____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
