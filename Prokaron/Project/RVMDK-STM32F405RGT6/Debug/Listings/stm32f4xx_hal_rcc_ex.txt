; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f4xx_hal_rcc_ex.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f4xx_hal_rcc_ex.d --cpu=Cortex-M4.fp --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F4_V1.21.0\Drivers\STM32F4xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_F4_V1.21.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F4_V1.21.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F4_V1.21.0\Drivers\STM32F4xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F405RGT6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.11.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F405xx -DSTM32F405xx -DUSE_HAL_DRIVER -DHSE_VALUE=8000000 -DPLL_M=8 --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f4xx_hal_rcc_ex.crf ..\..\..\M0P0_Library\STM32Cube_FW_F4_V1.21.0\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_rcc_ex.c]
                          THUMB

                          AREA ||i.HAL_RCCEx_DisablePLLI2S||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_DisablePLLI2S PROC
;;;2891     */
;;;2892   HAL_StatusTypeDef HAL_RCCEx_DisablePLLI2S(void)
000000  b570              PUSH     {r4-r6,lr}
;;;2893   {
;;;2894     uint32_t tickstart;
;;;2895   
;;;2896     /* Disable the PLLI2S */
;;;2897     __HAL_RCC_PLLI2S_DISABLE();
000002  490c              LDR      r1,|L1.52|
000004  2000              MOVS     r0,#0
000006  6688              STR      r0,[r1,#0x68]
;;;2898   
;;;2899     /* Wait till PLLI2S is disabled */
;;;2900     tickstart = HAL_GetTick();
000008  f7fffffe          BL       HAL_GetTick
;;;2901     while(READ_BIT(RCC->CR, RCC_CR_PLLI2SRDY) != RESET)
00000c  4d0a              LDR      r5,|L1.56|
00000e  4604              MOV      r4,r0                 ;2900
000010  6828              LDR      r0,[r5,#0]
000012  f0106f00          TST      r0,#0x8000000
000016  d00a              BEQ      |L1.46|
                  |L1.24|
;;;2902     {
;;;2903       if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
000018  f7fffffe          BL       HAL_GetTick
00001c  1b00              SUBS     r0,r0,r4
00001e  2802              CMP      r0,#2
000020  d901              BLS      |L1.38|
;;;2904       {
;;;2905         /* return in case of Timeout detected */
;;;2906         return HAL_TIMEOUT;
000022  2003              MOVS     r0,#3
;;;2907       }
;;;2908     }
;;;2909   
;;;2910     return HAL_OK;
;;;2911   }
000024  bd70              POP      {r4-r6,pc}
                  |L1.38|
000026  6828              LDR      r0,[r5,#0]            ;2901
000028  f0106f00          TST      r0,#0x8000000         ;2901
00002c  d1f4              BNE      |L1.24|
                  |L1.46|
00002e  2000              MOVS     r0,#0                 ;2910
000030  bd70              POP      {r4-r6,pc}
;;;2912   
                          ENDP

000032  0000              DCW      0x0000
                  |L1.52|
                          DCD      0x42470000
                  |L1.56|
                          DCD      0x40023800

                          AREA ||i.HAL_RCCEx_EnablePLLI2S||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_EnablePLLI2S PROC
;;;2808     */
;;;2809   HAL_StatusTypeDef HAL_RCCEx_EnablePLLI2S(RCC_PLLI2SInitTypeDef  *PLLI2SInit)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2810   {
;;;2811     uint32_t tickstart;
;;;2812   
;;;2813     /* Check for parameters */
;;;2814     assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SInit->PLLI2SN));
;;;2815     assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SInit->PLLI2SR));
;;;2816   #if defined(RCC_PLLI2SCFGR_PLLI2SM)
;;;2817     assert_param(IS_RCC_PLLI2SM_VALUE(PLLI2SInit->PLLI2SM));
;;;2818   #endif /* RCC_PLLI2SCFGR_PLLI2SM */
;;;2819   #if defined(RCC_PLLI2SCFGR_PLLI2SP)
;;;2820     assert_param(IS_RCC_PLLI2SP_VALUE(PLLI2SInit->PLLI2SP));
;;;2821   #endif /* RCC_PLLI2SCFGR_PLLI2SP */
;;;2822   #if defined(RCC_PLLI2SCFGR_PLLI2SQ)
;;;2823     assert_param(IS_RCC_PLLI2SQ_VALUE(PLLI2SInit->PLLI2SQ));
;;;2824   #endif /* RCC_PLLI2SCFGR_PLLI2SQ */
;;;2825   
;;;2826     /* Disable the PLLI2S */
;;;2827     __HAL_RCC_PLLI2S_DISABLE();
000004  4f1a              LDR      r7,|L2.112|
000006  4605              MOV      r5,r0                 ;2810
000008  2000              MOVS     r0,#0
00000a  66b8              STR      r0,[r7,#0x68]
;;;2828   
;;;2829     /* Wait till PLLI2S is disabled */
;;;2830     tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
;;;2831     while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY) != RESET)
000010  4c18              LDR      r4,|L2.116|
000012  4606              MOV      r6,r0                 ;2830
000014  6820              LDR      r0,[r4,#0]
000016  f0106f00          TST      r0,#0x8000000
00001a  d008              BEQ      |L2.46|
                  |L2.28|
;;;2832     {
;;;2833       if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
00001c  f7fffffe          BL       HAL_GetTick
000020  1b80              SUBS     r0,r0,r6
000022  2802              CMP      r0,#2
000024  d819              BHI      |L2.90|
000026  6820              LDR      r0,[r4,#0]            ;2831
000028  f0106f00          TST      r0,#0x8000000         ;2831
00002c  d1f6              BNE      |L2.28|
                  |L2.46|
;;;2834       {
;;;2835         /* return in case of Timeout detected */
;;;2836         return HAL_TIMEOUT;
;;;2837       }
;;;2838     }
;;;2839   
;;;2840     /* Configure the PLLI2S division factors */
;;;2841   #if defined(STM32F446xx)
;;;2842     /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLI2SM) */
;;;2843     /* I2SPCLK = PLLI2S_VCO / PLLI2SP */
;;;2844     /* I2SQCLK = PLLI2S_VCO / PLLI2SQ */
;;;2845     /* I2SRCLK = PLLI2S_VCO / PLLI2SR */
;;;2846     __HAL_RCC_PLLI2S_CONFIG(PLLI2SInit->PLLI2SM, PLLI2SInit->PLLI2SN, \
;;;2847                             PLLI2SInit->PLLI2SP, PLLI2SInit->PLLI2SQ, PLLI2SInit->PLLI2SR);
;;;2848   #elif defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) ||\
;;;2849         defined(STM32F413xx) || defined(STM32F423xx)
;;;2850     /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLI2SM)*/
;;;2851     /* I2SQCLK = PLLI2S_VCO / PLLI2SQ */
;;;2852     /* I2SRCLK = PLLI2S_VCO / PLLI2SR */
;;;2853     __HAL_RCC_PLLI2S_CONFIG(PLLI2SInit->PLLI2SM, PLLI2SInit->PLLI2SN, \
;;;2854                             PLLI2SInit->PLLI2SQ, PLLI2SInit->PLLI2SR);
;;;2855   #elif defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
;;;2856         defined(STM32F469xx) || defined(STM32F479xx)
;;;2857     /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * PLLI2SN */
;;;2858     /* I2SQCLK = PLLI2S_VCO / PLLI2SQ */
;;;2859     /* I2SRCLK = PLLI2S_VCO / PLLI2SR */
;;;2860     __HAL_RCC_PLLI2S_SAICLK_CONFIG(PLLI2SInit->PLLI2SN, PLLI2SInit->PLLI2SQ, PLLI2SInit->PLLI2SR);
;;;2861   #elif defined(STM32F411xE)
;;;2862     /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLI2SM) */
;;;2863     /* I2SRCLK = PLLI2S_VCO / PLLI2SR */
;;;2864     __HAL_RCC_PLLI2S_I2SCLK_CONFIG(PLLI2SInit->PLLI2SM, PLLI2SInit->PLLI2SN, PLLI2SInit->PLLI2SR);
;;;2865   #else
;;;2866     /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x PLLI2SN */
;;;2867     /* I2SRCLK = PLLI2S_VCO / PLLI2SR */
;;;2868     __HAL_RCC_PLLI2S_CONFIG(PLLI2SInit->PLLI2SN, PLLI2SInit->PLLI2SR);
00002e  6828              LDR      r0,[r5,#0]
000030  7929              LDRB     r1,[r5,#4]
000032  0180              LSLS     r0,r0,#6
000034  ea407001          ORR      r0,r0,r1,LSL #28
000038  490f              LDR      r1,|L2.120|
00003a  6008              STR      r0,[r1,#0]
;;;2869   #endif /* STM32F446xx */
;;;2870   
;;;2871     /* Enable the PLLI2S */
;;;2872     __HAL_RCC_PLLI2S_ENABLE();
00003c  2001              MOVS     r0,#1
00003e  66b8              STR      r0,[r7,#0x68]
;;;2873   
;;;2874     /* Wait till PLLI2S is ready */
;;;2875     tickstart = HAL_GetTick();
000040  f7fffffe          BL       HAL_GetTick
000044  4605              MOV      r5,r0
;;;2876     while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY) == RESET)
000046  6820              LDR      r0,[r4,#0]
000048  f0106f00          TST      r0,#0x8000000
00004c  d10c              BNE      |L2.104|
;;;2877     {
;;;2878       if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
00004e  bf00              NOP      
                  |L2.80|
000050  f7fffffe          BL       HAL_GetTick
000054  1b41              SUBS     r1,r0,r5
000056  2902              CMP      r1,#2
000058  d902              BLS      |L2.96|
                  |L2.90|
;;;2879       {
;;;2880         /* return in case of Timeout detected */
;;;2881         return HAL_TIMEOUT;
00005a  2003              MOVS     r0,#3
;;;2882       }
;;;2883     }
;;;2884   
;;;2885    return HAL_OK;
;;;2886   }
00005c  e8bd81f0          POP      {r4-r8,pc}
                  |L2.96|
000060  6820              LDR      r0,[r4,#0]            ;2876
000062  f0106f00          TST      r0,#0x8000000         ;2876
000066  d0f3              BEQ      |L2.80|
                  |L2.104|
000068  2000              MOVS     r0,#0                 ;2885
00006a  e8bd81f0          POP      {r4-r8,pc}
;;;2887   
                          ENDP

00006e  0000              DCW      0x0000
                  |L2.112|
                          DCD      0x42470000
                  |L2.116|
                          DCD      0x40023800
                  |L2.120|
                          DCD      0x40023884

                          AREA ||i.HAL_RCCEx_GetPeriphCLKConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_GetPeriphCLKConfig PROC
;;;2646     */
;;;2647   void HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
000000  2103              MOVS     r1,#3
;;;2648   {
;;;2649     uint32_t tempreg;
;;;2650   
;;;2651     /* Set all possible values for the extended clock type parameter------------*/
;;;2652     PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_I2S | RCC_PERIPHCLK_RTC;
;;;2653   
;;;2654     /* Get the PLLI2S Clock configuration --------------------------------------*/
;;;2655     PeriphClkInit->PLLI2S.PLLI2SN = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> RCC_PLLI2SCFGR_PLLI2SN_Pos);
000002  6001              STR      r1,[r0,#0]
000004  4909              LDR      r1,|L3.44|
000006  680a              LDR      r2,[r1,#0]
000008  f3c21288          UBFX     r2,r2,#6,#9
;;;2656     PeriphClkInit->PLLI2S.PLLI2SR = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
00000c  6042              STR      r2,[r0,#4]
00000e  6809              LDR      r1,[r1,#0]
000010  f3c17102          UBFX     r1,r1,#28,#3
;;;2657   #if defined(STM32F411xE)
;;;2658     PeriphClkInit->PLLI2S.PLLI2SM = (uint32_t)(RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM);
;;;2659   #endif /* STM32F411xE */
;;;2660     /* Get the RTC Clock configuration -----------------------------------------*/
;;;2661     tempreg = (RCC->CFGR & RCC_CFGR_RTCPRE);
000014  6081              STR      r1,[r0,#8]
000016  4906              LDR      r1,|L3.48|
000018  6809              LDR      r1,[r1,#0]
;;;2662     PeriphClkInit->RTCClockSelection = (uint32_t)((tempreg) | (RCC->BDCR & RCC_BDCR_RTCSEL));
00001a  4a06              LDR      r2,|L3.52|
00001c  f40111f8          AND      r1,r1,#0x1f0000       ;2661
000020  6812              LDR      r2,[r2,#0]
000022  f4027240          AND      r2,r2,#0x300
000026  4311              ORRS     r1,r1,r2
000028  60c1              STR      r1,[r0,#0xc]
;;;2663   
;;;2664   #if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE)
;;;2665     /* Get the TIM Prescaler configuration -------------------------------------*/
;;;2666     if ((RCC->DCKCFGR & RCC_DCKCFGR_TIMPRE) == RESET)
;;;2667     {
;;;2668       PeriphClkInit->TIMPresSelection = RCC_TIMPRES_DESACTIVATED;
;;;2669     }
;;;2670     else
;;;2671     {
;;;2672       PeriphClkInit->TIMPresSelection = RCC_TIMPRES_ACTIVATED;
;;;2673     }
;;;2674   #endif /* STM32F401xC || STM32F401xE || STM32F411xE */
;;;2675   }
00002a  4770              BX       lr
;;;2676   
                          ENDP

                  |L3.44|
                          DCD      0x40023884
                  |L3.48|
                          DCD      0x40023808
                  |L3.52|
                          DCD      0x40023870

                          AREA ||i.HAL_RCCEx_GetPeriphCLKFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_GetPeriphCLKFreq PROC
;;;2684     */
;;;2685   uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
000000  4601              MOV      r1,r0
;;;2686   {
;;;2687     /* This variable used to store the I2S clock frequency (value in Hz) */
;;;2688     uint32_t frequency = 0U;
000002  2000              MOVS     r0,#0
;;;2689     /* This variable used to store the VCO Input (value in Hz) */
;;;2690     uint32_t vcoinput = 0U;
;;;2691     uint32_t srcclk = 0U;
;;;2692     /* This variable used to store the VCO Output (value in Hz) */
;;;2693     uint32_t vcooutput = 0U;
;;;2694     switch (PeriphClk)
000004  2901              CMP      r1,#1
;;;2695     {
;;;2696     case RCC_PERIPHCLK_I2S:
;;;2697       {
;;;2698         /* Get the current I2S source */
;;;2699         srcclk = __HAL_RCC_GET_I2S_SOURCE();
;;;2700         switch (srcclk)
;;;2701         {
;;;2702         /* Check if I2S clock selection is External clock mapped on the I2S_CKIN pin used as I2S clock */
;;;2703         case RCC_I2SCLKSOURCE_EXT:
;;;2704           {
;;;2705             /* Set the I2S clock to the external clock  value */
;;;2706             frequency = EXTERNAL_CLOCK_VALUE;
;;;2707             break;
;;;2708           }
;;;2709         /* Check if I2S clock selection is PLLI2S VCO output clock divided by PLLI2SR used as I2S clock */
;;;2710         case RCC_I2SCLKSOURCE_PLLI2S:
;;;2711           {
;;;2712   #if defined(STM32F411xE)
;;;2713             /* Configure the PLLI2S division factor */
;;;2714             /* PLLI2S_VCO Input  = PLL_SOURCE/PLLI2SM */
;;;2715             if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)
;;;2716             {
;;;2717               /* Get the I2S source clock value */
;;;2718               vcoinput = (uint32_t)(HSE_VALUE / (uint32_t)(RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM));
;;;2719             }
;;;2720             else
;;;2721             {
;;;2722               /* Get the I2S source clock value */
;;;2723               vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM));
;;;2724             }
;;;2725   #else
;;;2726             /* Configure the PLLI2S division factor */
;;;2727             /* PLLI2S_VCO Input  = PLL_SOURCE/PLLM */
;;;2728             if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)
;;;2729             {
;;;2730               /* Get the I2S source clock value */
;;;2731               vcoinput = (uint32_t)(HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
;;;2732             }
;;;2733             else
;;;2734             {
;;;2735               /* Get the I2S source clock value */
;;;2736               vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
;;;2737             }
;;;2738   #endif /* STM32F411xE */
;;;2739             /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */
;;;2740             vcooutput = (uint32_t)(vcoinput * (((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6U) & (RCC_PLLI2SCFGR_PLLI2SN >> 6U)));
;;;2741             /* I2S_CLK = PLLI2S_VCO Output/PLLI2SR */
;;;2742             frequency = (uint32_t)(vcooutput /(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28U) & (RCC_PLLI2SCFGR_PLLI2SR >> 28U)));
;;;2743             break;
;;;2744           }
;;;2745           /* Clock not enabled for I2S*/
;;;2746         default:
;;;2747           {
;;;2748             frequency = 0U;
;;;2749             break;
;;;2750           }
;;;2751         }
;;;2752         break;
;;;2753       }
;;;2754     }
;;;2755     return frequency;
;;;2756   }
000006  bf18              IT       NE
000008  4770              BXNE     lr
00000a  4910              LDR      r1,|L4.76|
00000c  6809              LDR      r1,[r1,#0]            ;2699
00000e  f4110100          ANDS     r1,r1,#0x800000       ;2699
000012  d003              BEQ      |L4.28|
000014  2901              CMP      r1,#1                 ;2700
000016  bf08              IT       EQ                    ;2706
000018  480d              LDREQ    r0,|L4.80|
00001a  4770              BX       lr
                  |L4.28|
00001c  480d              LDR      r0,|L4.84|
00001e  6801              LDR      r1,[r0,#0]            ;2728
000020  6800              LDR      r0,[r0,#0]            ;2736
000022  f4110f80          TST      r1,#0x400000          ;2728
000026  f000003f          AND      r0,r0,#0x3f           ;2736
00002a  bf14              ITE      NE                    ;2731
00002c  490a              LDRNE    r1,|L4.88|
00002e  490b              LDREQ    r1,|L4.92|
000030  fbb1f0f0          UDIV     r0,r1,r0              ;2736
000034  490a              LDR      r1,|L4.96|
000036  680a              LDR      r2,[r1,#0]            ;2740
000038  6809              LDR      r1,[r1,#0]            ;2742
00003a  f3c21288          UBFX     r2,r2,#6,#9           ;2740
00003e  4350              MULS     r0,r2,r0              ;2740
000040  f3c17102          UBFX     r1,r1,#28,#3          ;2742
000044  fbb0f0f1          UDIV     r0,r0,r1              ;2742
000048  4770              BX       lr
;;;2757   #endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F401xC || STM32F401xE  || STM32F411xE */
                          ENDP

00004a  0000              DCW      0x0000
                  |L4.76|
                          DCD      0x40023808
                  |L4.80|
                          DCD      0x00bb8000
                  |L4.84|
                          DCD      0x40023804
                  |L4.88|
                          DCD      0x007a1200
                  |L4.92|
                          DCD      0x00f42400
                  |L4.96|
                          DCD      0x40023884

                          AREA ||i.HAL_RCCEx_PeriphCLKConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_PeriphCLKConfig PROC
;;;2518     */
;;;2519   HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;2520   {
000004  4605              MOV      r5,r0
;;;2521     uint32_t tickstart = 0U;
;;;2522     uint32_t tmpreg1 = 0U;
;;;2523   
;;;2524     /* Check the parameters */
;;;2525     assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
;;;2526   
;;;2527     /*---------------------------- I2S configuration ---------------------------*/
;;;2528     if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||
000006  7800              LDRB     r0,[r0,#0]
;;;2529        (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S))
;;;2530     {
;;;2531       /* check for Parameters */
;;;2532       assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));
;;;2533       assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));
;;;2534   #if defined(STM32F411xE)
;;;2535       assert_param(IS_RCC_PLLI2SM_VALUE(PeriphClkInit->PLLI2S.PLLI2SM));
;;;2536   #endif /* STM32F411xE */
;;;2537       /* Disable the PLLI2S */
;;;2538       __HAL_RCC_PLLI2S_DISABLE();
;;;2539       /* Get tick */
;;;2540       tickstart = HAL_GetTick();
;;;2541       /* Wait till PLLI2S is disabled */
;;;2542       while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
;;;2543       {
;;;2544         if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
;;;2545         {
;;;2546           /* return in case of Timeout detected */
;;;2547           return HAL_TIMEOUT;
;;;2548         }
;;;2549       }
;;;2550   
;;;2551   #if defined(STM32F411xE)
;;;2552       /* Configure the PLLI2S division factors */
;;;2553       /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLI2SM) */
;;;2554       /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */
;;;2555       __HAL_RCC_PLLI2S_I2SCLK_CONFIG(PeriphClkInit->PLLI2S.PLLI2SM, PeriphClkInit->PLLI2S.PLLI2SN, PeriphClkInit->PLLI2S.PLLI2SR);
;;;2556   #else
;;;2557       /* Configure the PLLI2S division factors */
;;;2558       /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLM) */
;;;2559       /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */
;;;2560       __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SR);
;;;2561   #endif /* STM32F411xE */
;;;2562   
;;;2563       /* Enable the PLLI2S */
;;;2564       __HAL_RCC_PLLI2S_ENABLE();
000008  f04f0801          MOV      r8,#1
00000c  f0100f05          TST      r0,#5                 ;2528
000010  f04f0700          MOV      r7,#0
000014  d02f              BEQ      |L5.118|
000016  f8df9138          LDR      r9,|L5.336|
00001a  f8c97068          STR      r7,[r9,#0x68]         ;2538
00001e  f7fffffe          BL       HAL_GetTick
000022  4c4c              LDR      r4,|L5.340|
000024  4606              MOV      r6,r0                 ;2540
000026  6820              LDR      r0,[r4,#0]            ;2542
000028  f0106f00          TST      r0,#0x8000000         ;2542
00002c  d009              BEQ      |L5.66|
00002e  bf00              NOP                            ;2544
                  |L5.48|
000030  f7fffffe          BL       HAL_GetTick
000034  1b80              SUBS     r0,r0,r6              ;2544
000036  2802              CMP      r0,#2                 ;2544
000038  d865              BHI      |L5.262|
00003a  6820              LDR      r0,[r4,#0]            ;2547
00003c  f0106f00          TST      r0,#0x8000000         ;2547
000040  d1f6              BNE      |L5.48|
                  |L5.66|
000042  6868              LDR      r0,[r5,#4]            ;2560
000044  7a29              LDRB     r1,[r5,#8]            ;2560
000046  0180              LSLS     r0,r0,#6              ;2560
000048  ea407001          ORR      r0,r0,r1,LSL #28      ;2560
00004c  4942              LDR      r1,|L5.344|
00004e  6008              STR      r0,[r1,#0]            ;2560
000050  f8c98068          STR      r8,[r9,#0x68]
;;;2565       /* Get tick */
;;;2566       tickstart = HAL_GetTick();
000054  f7fffffe          BL       HAL_GetTick
000058  4606              MOV      r6,r0
;;;2567       /* Wait till PLLI2S is ready */
;;;2568       while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
00005a  6820              LDR      r0,[r4,#0]
00005c  f0106f00          TST      r0,#0x8000000
000060  d109              BNE      |L5.118|
;;;2569       {
;;;2570         if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
000062  bf00              NOP      
                  |L5.100|
000064  f7fffffe          BL       HAL_GetTick
000068  1b80              SUBS     r0,r0,r6
00006a  2802              CMP      r0,#2
00006c  d84b              BHI      |L5.262|
;;;2571         {
;;;2572           /* return in case of Timeout detected */
;;;2573           return HAL_TIMEOUT;
00006e  6820              LDR      r0,[r4,#0]
000070  f0106f00          TST      r0,#0x8000000
000074  d0f6              BEQ      |L5.100|
                  |L5.118|
;;;2574         }
;;;2575       }
;;;2576     }
;;;2577   
;;;2578     /*---------------------------- RTC configuration ---------------------------*/
;;;2579     if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
000076  7828              LDRB     r0,[r5,#0]
000078  f0100f02          TST      r0,#2
00007c  d05c              BEQ      |L5.312|
;;;2580     {
;;;2581       /* Check for RTC Parameters used to output RTCCLK */
;;;2582       assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
;;;2583   
;;;2584       /* Enable Power Clock*/
;;;2585       __HAL_RCC_PWR_CLK_ENABLE();
00007e  4837              LDR      r0,|L5.348|
000080  6801              LDR      r1,[r0,#0]
000082  f0415180          ORR      r1,r1,#0x10000000
000086  6001              STR      r1,[r0,#0]
000088  6800              LDR      r0,[r0,#0]
;;;2586   
;;;2587       /* Enable write access to Backup domain */
;;;2588       PWR->CR |= PWR_CR_DBP;
00008a  4c35              LDR      r4,|L5.352|
00008c  f0005080          AND      r0,r0,#0x10000000     ;2585
000090  9000              STR      r0,[sp,#0]
000092  6820              LDR      r0,[r4,#0]
000094  f4407080          ORR      r0,r0,#0x100
000098  6020              STR      r0,[r4,#0]
;;;2589   
;;;2590       /* Get tick */
;;;2591       tickstart = HAL_GetTick();
00009a  f7fffffe          BL       HAL_GetTick
00009e  4606              MOV      r6,r0
;;;2592   
;;;2593       while((PWR->CR & PWR_CR_DBP) == RESET)
0000a0  6820              LDR      r0,[r4,#0]
0000a2  f4107f80          TST      r0,#0x100
0000a6  d108              BNE      |L5.186|
                  |L5.168|
;;;2594       {
;;;2595         if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
0000a8  f7fffffe          BL       HAL_GetTick
0000ac  1b80              SUBS     r0,r0,r6
0000ae  2802              CMP      r0,#2
0000b0  d829              BHI      |L5.262|
;;;2596         {
;;;2597           return HAL_TIMEOUT;
0000b2  6820              LDR      r0,[r4,#0]
0000b4  f4107f80          TST      r0,#0x100
0000b8  d0f6              BEQ      |L5.168|
                  |L5.186|
;;;2598         }
;;;2599       }
;;;2600       /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */
;;;2601       tmpreg1 = (RCC->BDCR & RCC_BDCR_RTCSEL);
0000ba  4c2a              LDR      r4,|L5.356|
0000bc  6820              LDR      r0,[r4,#0]
0000be  f4107040          ANDS     r0,r0,#0x300
;;;2602       if((tmpreg1 != 0x00000000U) && ((tmpreg1) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
0000c2  d027              BEQ      |L5.276|
0000c4  89a9              LDRH     r1,[r5,#0xc]
0000c6  f4017140          AND      r1,r1,#0x300
0000ca  4281              CMP      r1,r0
0000cc  d022              BEQ      |L5.276|
;;;2603       {
;;;2604         /* Store the content of BDCR register before the reset of Backup Domain */
;;;2605         tmpreg1 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
0000ce  6820              LDR      r0,[r4,#0]
0000d0  f4207140          BIC      r1,r0,#0x300
;;;2606         /* RTC Clock selection can be changed only if the Backup Domain is reset */
;;;2607         __HAL_RCC_BACKUPRESET_FORCE();
0000d4  4824              LDR      r0,|L5.360|
0000d6  f8c08000          STR      r8,[r0,#0]
;;;2608         __HAL_RCC_BACKUPRESET_RELEASE();
0000da  6007              STR      r7,[r0,#0]
;;;2609         /* Restore the Content of BDCR register */
;;;2610         RCC->BDCR = tmpreg1;
0000dc  6021              STR      r1,[r4,#0]
;;;2611   
;;;2612         /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
;;;2613         if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
0000de  6820              LDR      r0,[r4,#0]
0000e0  f0100f01          TST      r0,#1
0000e4  d016              BEQ      |L5.276|
;;;2614         {
;;;2615           /* Get tick */
;;;2616           tickstart = HAL_GetTick();
0000e6  f7fffffe          BL       HAL_GetTick
0000ea  4606              MOV      r6,r0
;;;2617   
;;;2618           /* Wait till LSE is ready */
;;;2619           while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
0000ec  6820              LDR      r0,[r4,#0]
0000ee  f0100f02          TST      r0,#2
;;;2620           {
;;;2621             if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
0000f2  bf08              IT       EQ
0000f4  f2413788          MOVEQ    r7,#0x1388
0000f8  d10c              BNE      |L5.276|
0000fa  bf00              NOP      
                  |L5.252|
0000fc  f7fffffe          BL       HAL_GetTick
000100  1b80              SUBS     r0,r0,r6
000102  42b8              CMP      r0,r7
000104  d902              BLS      |L5.268|
                  |L5.262|
;;;2622             {
;;;2623               return HAL_TIMEOUT;
000106  2003              MOVS     r0,#3
;;;2624             }
;;;2625           }
;;;2626         }
;;;2627       }
;;;2628       __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
;;;2629     }
;;;2630   #if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE)
;;;2631     /*---------------------------- TIM configuration ---------------------------*/
;;;2632     if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
;;;2633     {
;;;2634       __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
;;;2635     }
;;;2636   #endif /* STM32F401xC || STM32F401xE || STM32F411xE */
;;;2637     return HAL_OK;
;;;2638   }
000108  e8bd83f8          POP      {r3-r9,pc}
                  |L5.268|
00010c  6820              LDR      r0,[r4,#0]            ;2623
00010e  f0100f02          TST      r0,#2                 ;2623
000112  d0f3              BEQ      |L5.252|
                  |L5.276|
000114  68e9              LDR      r1,[r5,#0xc]          ;2628
000116  f44f7040          MOV      r0,#0x300             ;2628
00011a  ea300201          BICS     r2,r0,r1              ;2628
00011e  4813              LDR      r0,|L5.364|
000120  bf1c              ITT      NE                    ;2628
000122  6801              LDRNE    r1,[r0,#0]            ;2628
000124  f42111f8          BICNE    r1,r1,#0x1f0000       ;2628
000128  d009              BEQ      |L5.318|
                  |L5.298|
00012a  6001              STR      r1,[r0,#0]            ;2628
00012c  6820              LDR      r0,[r4,#0]            ;2628
00012e  89a9              LDRH     r1,[r5,#0xc]          ;2628
000130  f3c1010b          UBFX     r1,r1,#0,#12          ;2628
000134  4308              ORRS     r0,r0,r1              ;2628
000136  6020              STR      r0,[r4,#0]            ;2628
                  |L5.312|
000138  2000              MOVS     r0,#0                 ;2637
00013a  e8bd83f8          POP      {r3-r9,pc}
                  |L5.318|
00013e  6802              LDR      r2,[r0,#0]            ;2628
000140  f4217140          BIC      r1,r1,#0x300          ;2628
000144  f42212f8          BIC      r2,r2,#0x1f0000       ;2628
000148  f0214170          BIC      r1,r1,#0xf0000000     ;2628
00014c  4311              ORRS     r1,r1,r2              ;2628
00014e  e7ec              B        |L5.298|
;;;2639   
                          ENDP

                  |L5.336|
                          DCD      0x42470000
                  |L5.340|
                          DCD      0x40023800
                  |L5.344|
                          DCD      0x40023884
                  |L5.348|
                          DCD      0x40023840
                  |L5.352|
                          DCD      0x40007000
                  |L5.356|
                          DCD      0x40023870
                  |L5.360|
                          DCD      0x42470e40
                  |L5.364|
                          DCD      0x40023808

                          AREA ||i.HAL_RCC_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_RCC_DeInit PROC
;;;3148     */
;;;3149   HAL_StatusTypeDef HAL_RCC_DeInit(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3150   {
;;;3151     uint32_t tickstart;
;;;3152   
;;;3153     /* Get Start Tick */
;;;3154     tickstart = HAL_GetTick();
000004  f7fffffe          BL       HAL_GetTick
;;;3155   
;;;3156     /* Set HSION bit to the reset value */
;;;3157     SET_BIT(RCC->CR, RCC_CR_HSION);
000008  4e4b              LDR      r6,|L6.312|
00000a  4604              MOV      r4,r0                 ;3154
00000c  6830              LDR      r0,[r6,#0]
00000e  f0400001          ORR      r0,r0,#1
000012  6030              STR      r0,[r6,#0]
;;;3158   
;;;3159     /* Wait till HSI is ready */
;;;3160     while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == RESET)
000014  6830              LDR      r0,[r6,#0]
000016  f0100f02          TST      r0,#2
00001a  d108              BNE      |L6.46|
                  |L6.28|
;;;3161     {
;;;3162       if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
00001c  f7fffffe          BL       HAL_GetTick
000020  1b00              SUBS     r0,r0,r4
000022  2802              CMP      r0,#2
000024  d855              BHI      |L6.210|
000026  6830              LDR      r0,[r6,#0]            ;3160
000028  f0100f02          TST      r0,#2                 ;3160
00002c  d0f6              BEQ      |L6.28|
                  |L6.46|
;;;3163       {
;;;3164         return HAL_TIMEOUT;
;;;3165       }
;;;3166     }
;;;3167   
;;;3168     /* Set HSITRIM[4:0] bits to the reset value */
;;;3169     SET_BIT(RCC->CR, RCC_CR_HSITRIM_4);
00002e  6830              LDR      r0,[r6,#0]
000030  f0400080          ORR      r0,r0,#0x80
000034  6030              STR      r0,[r6,#0]
;;;3170   
;;;3171     /* Get Start Tick */
;;;3172     tickstart = HAL_GetTick();
000036  f7fffffe          BL       HAL_GetTick
;;;3173   
;;;3174     /* Reset CFGR register */
;;;3175     CLEAR_REG(RCC->CFGR);
00003a  4f40              LDR      r7,|L6.316|
00003c  4604              MOV      r4,r0                 ;3172
00003e  2000              MOVS     r0,#0
000040  6038              STR      r0,[r7,#0]
;;;3176   
;;;3177     /* Wait till clock switch is ready */
;;;3178     while (READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != RESET)
000042  6838              LDR      r0,[r7,#0]
000044  f0100f0c          TST      r0,#0xc
;;;3179     {
;;;3180       if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
000048  bf18              IT       NE
00004a  f2413588          MOVNE    r5,#0x1388
00004e  d008              BEQ      |L6.98|
                  |L6.80|
000050  f7fffffe          BL       HAL_GetTick
000054  1b00              SUBS     r0,r0,r4
000056  42a8              CMP      r0,r5
000058  d83b              BHI      |L6.210|
00005a  6838              LDR      r0,[r7,#0]            ;3178
00005c  f0100f0c          TST      r0,#0xc               ;3178
000060  d1f6              BNE      |L6.80|
                  |L6.98|
;;;3181       {
;;;3182         return HAL_TIMEOUT;
;;;3183       }
;;;3184     }
;;;3185   
;;;3186     /* Get Start Tick */
;;;3187     tickstart = HAL_GetTick();
000062  f7fffffe          BL       HAL_GetTick
000066  4604              MOV      r4,r0
;;;3188   
;;;3189     /* Clear HSEON, HSEBYP and CSSON bits */
;;;3190     CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSEBYP | RCC_CR_CSSON);
000068  6830              LDR      r0,[r6,#0]
00006a  f4202050          BIC      r0,r0,#0xd0000
00006e  6030              STR      r0,[r6,#0]
;;;3191   
;;;3192     /* Wait till HSE is disabled */
;;;3193     while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != RESET)
000070  6830              LDR      r0,[r6,#0]
000072  f4103f00          TST      r0,#0x20000
000076  d008              BEQ      |L6.138|
                  |L6.120|
;;;3194     {
;;;3195       if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
000078  f7fffffe          BL       HAL_GetTick
00007c  1b00              SUBS     r0,r0,r4
00007e  2864              CMP      r0,#0x64
000080  d827              BHI      |L6.210|
000082  6830              LDR      r0,[r6,#0]            ;3193
000084  f4103f00          TST      r0,#0x20000           ;3193
000088  d1f6              BNE      |L6.120|
                  |L6.138|
;;;3196       {
;;;3197         return HAL_TIMEOUT;
;;;3198       }
;;;3199     }
;;;3200   
;;;3201     /* Get Start Tick */
;;;3202     tickstart = HAL_GetTick();
00008a  f7fffffe          BL       HAL_GetTick
00008e  4604              MOV      r4,r0
;;;3203   
;;;3204     /* Clear PLLON bit */
;;;3205     CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
000090  6830              LDR      r0,[r6,#0]
000092  f0207080          BIC      r0,r0,#0x1000000
000096  6030              STR      r0,[r6,#0]
;;;3206   
;;;3207     /* Wait till PLL is disabled */
;;;3208     while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RESET)
000098  6830              LDR      r0,[r6,#0]
00009a  f0107f00          TST      r0,#0x2000000
00009e  d008              BEQ      |L6.178|
                  |L6.160|
;;;3209     {
;;;3210       if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
0000a0  f7fffffe          BL       HAL_GetTick
0000a4  1b00              SUBS     r0,r0,r4
0000a6  2802              CMP      r0,#2
0000a8  d813              BHI      |L6.210|
0000aa  6830              LDR      r0,[r6,#0]            ;3208
0000ac  f0107f00          TST      r0,#0x2000000         ;3208
0000b0  d1f6              BNE      |L6.160|
                  |L6.178|
;;;3211       {
;;;3212         return HAL_TIMEOUT;
;;;3213       }
;;;3214     }
;;;3215   
;;;3216   #if defined(RCC_PLLI2S_SUPPORT)
;;;3217     /* Get Start Tick */
;;;3218     tickstart = HAL_GetTick();
0000b2  f7fffffe          BL       HAL_GetTick
0000b6  4604              MOV      r4,r0
;;;3219   
;;;3220     /* Reset PLLI2SON bit */
;;;3221     CLEAR_BIT(RCC->CR, RCC_CR_PLLI2SON);
0000b8  6830              LDR      r0,[r6,#0]
0000ba  f0206080          BIC      r0,r0,#0x4000000
0000be  6030              STR      r0,[r6,#0]
;;;3222   
;;;3223     /* Wait till PLLI2S is disabled */
;;;3224     while (READ_BIT(RCC->CR, RCC_CR_PLLI2SRDY) != RESET)
0000c0  6830              LDR      r0,[r6,#0]
0000c2  f0106f00          TST      r0,#0x8000000
0000c6  d00b              BEQ      |L6.224|
                  |L6.200|
;;;3225     {
;;;3226       if ((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
0000c8  f7fffffe          BL       HAL_GetTick
0000cc  1b00              SUBS     r0,r0,r4
0000ce  2802              CMP      r0,#2
0000d0  d902              BLS      |L6.216|
                  |L6.210|
;;;3227       {
;;;3228         return HAL_TIMEOUT;
0000d2  2003              MOVS     r0,#3
;;;3229       }
;;;3230     }
;;;3231   #endif /* RCC_PLLI2S_SUPPORT */
;;;3232   
;;;3233   #if defined(RCC_PLLSAI_SUPPORT)
;;;3234     /* Get Start Tick */
;;;3235     tickstart = HAL_GetTick();
;;;3236   
;;;3237     /* Reset PLLSAI bit */
;;;3238     CLEAR_BIT(RCC->CR, RCC_CR_PLLSAION);
;;;3239   
;;;3240     /* Wait till PLLSAI is disabled */
;;;3241     while (READ_BIT(RCC->CR, RCC_CR_PLLSAIRDY) != RESET)
;;;3242     {
;;;3243       if ((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
;;;3244       {
;;;3245         return HAL_TIMEOUT;
;;;3246       }
;;;3247     }
;;;3248   #endif /* RCC_PLLSAI_SUPPORT */
;;;3249   
;;;3250     /* Once PLL, PLLI2S and PLLSAI are OFF, reset PLLCFGR register to default value */
;;;3251   #if defined(STM32F412Cx) || defined(STM32F412Rx) || defined(STM32F412Vx) || defined(STM32F412Zx) || defined(STM32F413xx) || \
;;;3252       defined(STM32F423xx) || defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)
;;;3253     RCC->PLLCFGR = RCC_PLLCFGR_PLLM_4 | RCC_PLLCFGR_PLLN_6 | RCC_PLLCFGR_PLLN_7 | RCC_PLLCFGR_PLLQ_2 | RCC_PLLCFGR_PLLR_1;
;;;3254   #elif defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
;;;3255     RCC->PLLCFGR = RCC_PLLCFGR_PLLR_0 | RCC_PLLCFGR_PLLR_1 | RCC_PLLCFGR_PLLR_2 | RCC_PLLCFGR_PLLM_4 | RCC_PLLCFGR_PLLN_6 | RCC_PLLCFGR_PLLN_7 | RCC_PLLCFGR_PLLQ_0 | RCC_PLLCFGR_PLLQ_1 | RCC_PLLCFGR_PLLQ_2 | RCC_PLLCFGR_PLLQ_3;
;;;3256   #else
;;;3257     RCC->PLLCFGR = RCC_PLLCFGR_PLLM_4 | RCC_PLLCFGR_PLLN_6 | RCC_PLLCFGR_PLLN_7 | RCC_PLLCFGR_PLLQ_2;
;;;3258   #endif /* STM32F412Cx || STM32F412Rx || STM32F412Vx || STM32F412Zx || STM32F413xx || STM32F423xx || STM32F446xx || STM32F469xx || STM32F479xx */
;;;3259   
;;;3260     /* Reset PLLI2SCFGR register to default value */
;;;3261   #if defined(STM32F412Cx) || defined(STM32F412Rx) || defined(STM32F412Vx) || defined(STM32F412Zx) || defined(STM32F413xx) || \
;;;3262       defined(STM32F423xx) || defined(STM32F446xx)
;;;3263     RCC->PLLI2SCFGR = RCC_PLLI2SCFGR_PLLI2SM_4 | RCC_PLLI2SCFGR_PLLI2SN_6 | RCC_PLLI2SCFGR_PLLI2SN_7 | RCC_PLLI2SCFGR_PLLI2SQ_2 | RCC_PLLI2SCFGR_PLLI2SR_1;
;;;3264   #elif defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx)
;;;3265     RCC->PLLI2SCFGR = RCC_PLLI2SCFGR_PLLI2SN_6 | RCC_PLLI2SCFGR_PLLI2SN_7 | RCC_PLLI2SCFGR_PLLI2SR_1;
;;;3266   #elif defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
;;;3267     RCC->PLLI2SCFGR = RCC_PLLI2SCFGR_PLLI2SN_6 | RCC_PLLI2SCFGR_PLLI2SN_7 | RCC_PLLI2SCFGR_PLLI2SQ_2 | RCC_PLLI2SCFGR_PLLI2SR_1;
;;;3268   #elif defined(STM32F411xE)
;;;3269     RCC->PLLI2SCFGR = RCC_PLLI2SCFGR_PLLI2SM_4 | RCC_PLLI2SCFGR_PLLI2SN_6 | RCC_PLLI2SCFGR_PLLI2SN_7 | RCC_PLLI2SCFGR_PLLI2SR_1;
;;;3270   #endif /* STM32F412Cx || STM32F412Rx || STM32F412Vx || STM32F412Zx || STM32F413xx || STM32F423xx || STM32F446xx */
;;;3271   
;;;3272     /* Reset PLLSAICFGR register */
;;;3273   #if defined(STM32F427xx) || defined(STM32F429xx) || defined(STM32F437xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
;;;3274     RCC->PLLSAICFGR = RCC_PLLSAICFGR_PLLSAIN_6 | RCC_PLLSAICFGR_PLLSAIN_7 | RCC_PLLSAICFGR_PLLSAIQ_2 | RCC_PLLSAICFGR_PLLSAIR_1;
;;;3275   #elif defined(STM32F446xx)
;;;3276     RCC->PLLSAICFGR = RCC_PLLSAICFGR_PLLSAIM_4 | RCC_PLLSAICFGR_PLLSAIN_6 | RCC_PLLSAICFGR_PLLSAIN_7 | RCC_PLLSAICFGR_PLLSAIQ_2;
;;;3277   #endif /* STM32F427xx || STM32F429xx || STM32F437xx || STM32F439xx || STM32F469xx || STM32F479xx */
;;;3278   
;;;3279     /* Disable all interrupts */
;;;3280     CLEAR_BIT(RCC->CIR, RCC_CIR_LSIRDYIE | RCC_CIR_LSERDYIE | RCC_CIR_HSIRDYIE | RCC_CIR_HSERDYIE | RCC_CIR_PLLRDYIE);
;;;3281   
;;;3282   #if defined(RCC_CIR_PLLI2SRDYIE)
;;;3283     CLEAR_BIT(RCC->CIR, RCC_CIR_PLLI2SRDYIE);
;;;3284   #endif /* RCC_CIR_PLLI2SRDYIE */
;;;3285   
;;;3286   #if defined(RCC_CIR_PLLSAIRDYIE)
;;;3287     CLEAR_BIT(RCC->CIR, RCC_CIR_PLLSAIRDYIE);
;;;3288   #endif /* RCC_CIR_PLLSAIRDYIE */
;;;3289   
;;;3290     /* Clear all interrupt flags */
;;;3291     SET_BIT(RCC->CIR, RCC_CIR_LSIRDYC | RCC_CIR_LSERDYC | RCC_CIR_HSIRDYC | RCC_CIR_HSERDYC | RCC_CIR_PLLRDYC | RCC_CIR_CSSC);
;;;3292   
;;;3293   #if defined(RCC_CIR_PLLI2SRDYC)
;;;3294     SET_BIT(RCC->CIR, RCC_CIR_PLLI2SRDYC);
;;;3295   #endif /* RCC_CIR_PLLI2SRDYC */
;;;3296   
;;;3297   #if defined(RCC_CIR_PLLSAIRDYC)
;;;3298     SET_BIT(RCC->CIR, RCC_CIR_PLLSAIRDYC);
;;;3299   #endif /* RCC_CIR_PLLSAIRDYC */
;;;3300   
;;;3301     /* Clear LSION bit */
;;;3302     CLEAR_BIT(RCC->CSR, RCC_CSR_LSION);
;;;3303   
;;;3304     /* Reset all CSR flags */
;;;3305     SET_BIT(RCC->CSR, RCC_CSR_RMVF);
;;;3306   
;;;3307     /* Update the SystemCoreClock global variable */
;;;3308     SystemCoreClock = HSI_VALUE;
;;;3309   
;;;3310     /* Adapt Systick interrupt period */
;;;3311     if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
;;;3312     {
;;;3313       return HAL_ERROR;
;;;3314     }
;;;3315     else
;;;3316     {
;;;3317       return HAL_OK;
;;;3318     }
;;;3319   }
0000d4  e8bd81f0          POP      {r4-r8,pc}
                  |L6.216|
0000d8  6830              LDR      r0,[r6,#0]            ;3224
0000da  f0106f00          TST      r0,#0x8000000         ;3224
0000de  d1f3              BNE      |L6.200|
                  |L6.224|
0000e0  4918              LDR      r1,|L6.324|
0000e2  4817              LDR      r0,|L6.320|
0000e4  6008              STR      r0,[r1,#0]            ;3257
0000e6  4919              LDR      r1,|L6.332|
0000e8  4817              LDR      r0,|L6.328|
0000ea  6008              STR      r0,[r1,#0]            ;3265
0000ec  4818              LDR      r0,|L6.336|
0000ee  6801              LDR      r1,[r0,#0]            ;3280
0000f0  f42151f8          BIC      r1,r1,#0x1f00         ;3280
0000f4  6001              STR      r1,[r0,#0]            ;3280
0000f6  6801              LDR      r1,[r0,#0]            ;3283
0000f8  f4215100          BIC      r1,r1,#0x2000         ;3283
0000fc  6001              STR      r1,[r0,#0]            ;3283
0000fe  6801              LDR      r1,[r0,#0]            ;3291
000100  f441011f          ORR      r1,r1,#0x9f0000       ;3291
000104  6001              STR      r1,[r0,#0]            ;3291
000106  6801              LDR      r1,[r0,#0]            ;3294
000108  f4411100          ORR      r1,r1,#0x200000       ;3294
00010c  6001              STR      r1,[r0,#0]            ;3294
00010e  4811              LDR      r0,|L6.340|
000110  6801              LDR      r1,[r0,#0]            ;3302
000112  f0210101          BIC      r1,r1,#1              ;3302
000116  6001              STR      r1,[r0,#0]            ;3302
000118  6801              LDR      r1,[r0,#0]            ;3305
00011a  f0417180          ORR      r1,r1,#0x1000000      ;3305
00011e  6001              STR      r1,[r0,#0]            ;3305
000120  490e              LDR      r1,|L6.348|
000122  480d              LDR      r0,|L6.344|
000124  6008              STR      r0,[r1,#0]            ;3311  ; SystemCoreClock
000126  200f              MOVS     r0,#0xf               ;3311
000128  f7fffffe          BL       HAL_InitTick
00012c  2800              CMP      r0,#0                 ;3311
00012e  bf18              IT       NE                    ;3313
000130  2001              MOVNE    r0,#1                 ;3313
000132  e8bd81f0          POP      {r4-r8,pc}
;;;3320   
                          ENDP

000136  0000              DCW      0x0000
                  |L6.312|
                          DCD      0x40023800
                  |L6.316|
                          DCD      0x40023808
                  |L6.320|
                          DCD      0x04003010
                  |L6.324|
                          DCD      0x40023804
                  |L6.328|
                          DCD      0x20003000
                  |L6.332|
                          DCD      0x40023884
                  |L6.336|
                          DCD      0x4002380c
                  |L6.340|
                          DCD      0x40023874
                  |L6.344|
                          DCD      0x00f42400
                  |L6.348|
                          DCD      SystemCoreClock

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F4_V1.21.0\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_rcc_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f4xx_hal_rcc_ex_c_bed13b44____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F4_V1.21.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___22_stm32f4xx_hal_rcc_ex_c_bed13b44____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f4xx_hal_rcc_ex_c_bed13b44____REVSH|
#line 402
|__asm___22_stm32f4xx_hal_rcc_ex_c_bed13b44____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f4xx_hal_rcc_ex_c_bed13b44____RRX|
#line 587
|__asm___22_stm32f4xx_hal_rcc_ex_c_bed13b44____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
