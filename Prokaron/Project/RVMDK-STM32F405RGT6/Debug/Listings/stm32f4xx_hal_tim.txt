; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f4xx_hal_tim.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f4xx_hal_tim.d --cpu=Cortex-M4.fp --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F4_V1.21.0\Drivers\STM32F4xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_F4_V1.21.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F4_V1.21.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F4_V1.21.0\Drivers\STM32F4xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F405RGT6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.11.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F405xx -DSTM32F405xx -DUSE_HAL_DRIVER -DHSE_VALUE=8000000 -DPLL_M=8 --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f4xx_hal_tim.crf ..\..\..\M0P0_Library\STM32Cube_FW_F4_V1.21.0\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_tim.c]
                          THUMB

                          AREA ||i.HAL_TIM_Base_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_DeInit PROC
;;;244      */
;;;245    HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;246    {  
000002  4604              MOV      r4,r0
;;;247      /* Check the parameters */
;;;248      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;249    
;;;250      htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  63e0              STR      r0,[r4,#0x3c]
;;;251       
;;;252      /* Disable the TIM Peripheral Clock */
;;;253      __HAL_TIM_DISABLE(htim);
000008  6820              LDR      r0,[r4,#0]
00000a  6a01              LDR      r1,[r0,#0x20]
00000c  f2411211          MOV      r2,#0x1111
000010  4211              TST      r1,r2
000012  d107              BNE      |L1.36|
000014  6a01              LDR      r1,[r0,#0x20]
000016  1092              ASRS     r2,r2,#2
000018  4211              TST      r1,r2
00001a  d103              BNE      |L1.36|
00001c  6801              LDR      r1,[r0,#0]
00001e  f0210101          BIC      r1,r1,#1
000022  6001              STR      r1,[r0,#0]
                  |L1.36|
;;;254        
;;;255      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;256      HAL_TIM_Base_MspDeInit(htim);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       HAL_TIM_Base_MspDeInit
;;;257      
;;;258      /* Change TIM state */  
;;;259      htim->State = HAL_TIM_STATE_RESET; 
00002a  2000              MOVS     r0,#0
00002c  63e0              STR      r0,[r4,#0x3c]
;;;260      
;;;261      /* Release Lock */
;;;262      __HAL_UNLOCK(htim);
00002e  63a0              STR      r0,[r4,#0x38]
;;;263    
;;;264      return HAL_OK;
;;;265    }
000030  bd10              POP      {r4,pc}
;;;266    
                          ENDP


                          AREA ||i.HAL_TIM_Base_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_GetState PROC
;;;4411     */
;;;4412   HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
000000  6bc0              LDR      r0,[r0,#0x3c]
;;;4413   {
;;;4414     return htim->State;
;;;4415   }
000002  4770              BX       lr
;;;4416   
                          ENDP


                          AREA ||i.HAL_TIM_Base_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Init PROC
;;;205      */
;;;206    HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
000000  2800              CMP      r0,#0
;;;207    { 
;;;208      /* Check the TIM handle allocation */
;;;209      if(htim == NULL)
;;;210      {
;;;211        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;212      }
;;;213      
;;;214      /* Check the parameters */
;;;215      assert_param(IS_TIM_INSTANCE(htim->Instance)); 
;;;216      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;217      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;218      
;;;219      if(htim->State == HAL_TIM_STATE_RESET)
;;;220      {  
;;;221        /* Allocate lock resource and initialize it */
;;;222        htim->Lock = HAL_UNLOCKED;
;;;223        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;224        HAL_TIM_Base_MspInit(htim);
;;;225      }
;;;226      
;;;227      /* Set the TIM state */
;;;228      htim->State= HAL_TIM_STATE_BUSY;
;;;229      
;;;230      /* Set the Time Base configuration */
;;;231      TIM_Base_SetConfig(htim->Instance, &htim->Init); 
;;;232      
;;;233      /* Initialize the TIM state*/
;;;234      htim->State= HAL_TIM_STATE_READY;
;;;235      
;;;236      return HAL_OK;
;;;237    }
000006  4770              BXEQ     lr
000008  b510              PUSH     {r4,lr}               ;207
00000a  4604              MOV      r4,r0                 ;207
00000c  6bc0              LDR      r0,[r0,#0x3c]         ;219
00000e  b920              CBNZ     r0,|L3.26|
000010  2000              MOVS     r0,#0                 ;222
000012  63a0              STR      r0,[r4,#0x38]         ;224
000014  4620              MOV      r0,r4                 ;224
000016  f7fffffe          BL       HAL_TIM_Base_MspInit
                  |L3.26|
00001a  2002              MOVS     r0,#2                 ;228
00001c  63e0              STR      r0,[r4,#0x3c]         ;228
00001e  1d21              ADDS     r1,r4,#4              ;231
000020  6820              LDR      r0,[r4,#0]            ;231
000022  f7fffffe          BL       TIM_Base_SetConfig
000026  2001              MOVS     r0,#1                 ;234
000028  63e0              STR      r0,[r4,#0x3c]         ;234
00002a  2000              MOVS     r0,#0                 ;236
00002c  bd10              POP      {r4,pc}
;;;238    
                          ENDP


                          AREA ||i.HAL_TIM_Base_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_MspDeInit PROC
;;;287      */
;;;288    __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;289    {
;;;290      /* Prevent unused argument(s) compilation warning */
;;;291      UNUSED(htim);
;;;292      /* NOTE : This function Should not be modified, when the callback is needed,
;;;293                the HAL_TIM_Base_MspDeInit could be implemented in the user file
;;;294       */
;;;295    }
;;;296    
                          ENDP


                          AREA ||i.HAL_TIM_Base_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_MspInit PROC
;;;272      */
;;;273    __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;274    {
;;;275      /* Prevent unused argument(s) compilation warning */
;;;276      UNUSED(htim);
;;;277      /* NOTE : This function Should not be modified, when the callback is needed,
;;;278                the HAL_TIM_Base_MspInit could be implemented in the user file
;;;279       */
;;;280    }
;;;281    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Start PROC
;;;302      */
;;;303    HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
000000  2102              MOVS     r1,#2
;;;304    {
;;;305      /* Check the parameters */
;;;306      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;307      
;;;308      /* Set the TIM state */
;;;309      htim->State= HAL_TIM_STATE_BUSY;
000002  63c1              STR      r1,[r0,#0x3c]
;;;310      
;;;311      /* Enable the Peripheral */
;;;312      __HAL_TIM_ENABLE(htim);
000004  6801              LDR      r1,[r0,#0]
000006  680a              LDR      r2,[r1,#0]
000008  f0420201          ORR      r2,r2,#1
00000c  600a              STR      r2,[r1,#0]
;;;313      
;;;314      /* Change the TIM state*/
;;;315      htim->State= HAL_TIM_STATE_READY;
00000e  2101              MOVS     r1,#1
000010  63c1              STR      r1,[r0,#0x3c]
;;;316      
;;;317      /* Return function status */
;;;318      return HAL_OK;
000012  2000              MOVS     r0,#0
;;;319    }
000014  4770              BX       lr
;;;320    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Base_Start_DMA PROC
;;;393      */
;;;394    HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
000000  b510              PUSH     {r4,lr}
;;;395    {
000002  4604              MOV      r4,r0
;;;396      /* Check the parameters */
;;;397      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance)); 
;;;398      
;;;399      if((htim->State == HAL_TIM_STATE_BUSY))
000004  6bc0              LDR      r0,[r0,#0x3c]
000006  2802              CMP      r0,#2
;;;400      {
;;;401         return HAL_BUSY;
;;;402      }
;;;403      else if((htim->State == HAL_TIM_STATE_READY))
;;;404      {
;;;405        if((pData == 0U) && (Length > 0)) 
;;;406        {
;;;407          return HAL_ERROR;                                    
;;;408        }
;;;409        else
;;;410        {
;;;411          htim->State = HAL_TIM_STATE_BUSY;
;;;412        }
;;;413      }  
;;;414      /* Set the DMA Period elapsed callback */
;;;415      htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;416         
;;;417      /* Set the DMA error callback */
;;;418      htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;419      
;;;420      /* Enable the DMA Stream */
;;;421      HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length);
;;;422      
;;;423      /* Enable the TIM Update DMA request */
;;;424      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
;;;425    
;;;426      /* Enable the Peripheral */
;;;427      __HAL_TIM_ENABLE(htim);  
;;;428      
;;;429      /* Return function status */
;;;430      return HAL_OK;
;;;431    }
000008  bf08              IT       EQ
00000a  bd10              POPEQ    {r4,pc}
00000c  6be0              LDR      r0,[r4,#0x3c]         ;403
00000e  2801              CMP      r0,#1                 ;403
000010  d106              BNE      |L7.32|
000012  b919              CBNZ     r1,|L7.28|
000014  2a00              CMP      r2,#0                 ;405
000016  bf1c              ITT      NE                    ;407
000018  2001              MOVNE    r0,#1                 ;407
00001a  bd10              POPNE    {r4,pc}
                  |L7.28|
00001c  2002              MOVS     r0,#2                 ;411
00001e  63e0              STR      r0,[r4,#0x3c]         ;411
                  |L7.32|
000020  69e3              LDR      r3,[r4,#0x1c]         ;415
000022  480c              LDR      r0,|L7.84|
000024  6418              STR      r0,[r3,#0x40]         ;418
000026  69e3              LDR      r3,[r4,#0x1c]         ;418
000028  480b              LDR      r0,|L7.88|
00002a  6518              STR      r0,[r3,#0x50]         ;421
00002c  6820              LDR      r0,[r4,#0]            ;421
00002e  4613              MOV      r3,r2                 ;421
000030  f1000c2c          ADD      r12,r0,#0x2c          ;421
000034  4662              MOV      r2,r12                ;421
000036  69e0              LDR      r0,[r4,#0x1c]         ;421
000038  f7fffffe          BL       HAL_DMA_Start_IT
00003c  6820              LDR      r0,[r4,#0]            ;424
00003e  68c1              LDR      r1,[r0,#0xc]          ;424
000040  f4417180          ORR      r1,r1,#0x100          ;424
000044  60c1              STR      r1,[r0,#0xc]          ;424
000046  6820              LDR      r0,[r4,#0]            ;427
000048  6801              LDR      r1,[r0,#0]            ;427
00004a  f0410101          ORR      r1,r1,#1              ;427
00004e  6001              STR      r1,[r0,#0]            ;427
000050  2000              MOVS     r0,#0                 ;430
000052  bd10              POP      {r4,pc}
;;;432    
                          ENDP

                  |L7.84|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L7.88|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_Base_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Start_IT PROC
;;;350      */
;;;351    HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
000000  6801              LDR      r1,[r0,#0]
;;;352    {
;;;353      /* Check the parameters */
;;;354      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;355      
;;;356      /* Enable the TIM Update interrupt */
;;;357      __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
000002  68ca              LDR      r2,[r1,#0xc]
000004  f0420201          ORR      r2,r2,#1
000008  60ca              STR      r2,[r1,#0xc]
;;;358          
;;;359      /* Enable the Peripheral */
;;;360      __HAL_TIM_ENABLE(htim);
00000a  6800              LDR      r0,[r0,#0]
00000c  6801              LDR      r1,[r0,#0]
00000e  f0410101          ORR      r1,r1,#1
000012  6001              STR      r1,[r0,#0]
;;;361          
;;;362      /* Return function status */
;;;363      return HAL_OK;
000014  2000              MOVS     r0,#0
;;;364    }
000016  4770              BX       lr
;;;365    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop PROC
;;;326      */
;;;327    HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
000000  2102              MOVS     r1,#2
;;;328    {
;;;329      /* Check the parameters */
;;;330      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;331      
;;;332      /* Set the TIM state */
;;;333      htim->State= HAL_TIM_STATE_BUSY;
000002  63c1              STR      r1,[r0,#0x3c]
;;;334      
;;;335      /* Disable the Peripheral */
;;;336      __HAL_TIM_DISABLE(htim);
000004  6801              LDR      r1,[r0,#0]
000006  6a0a              LDR      r2,[r1,#0x20]
000008  f2411311          MOV      r3,#0x1111
00000c  421a              TST      r2,r3
00000e  d107              BNE      |L9.32|
000010  6a0a              LDR      r2,[r1,#0x20]
000012  109b              ASRS     r3,r3,#2
000014  421a              TST      r2,r3
000016  d103              BNE      |L9.32|
000018  680a              LDR      r2,[r1,#0]
00001a  f0220201          BIC      r2,r2,#1
00001e  600a              STR      r2,[r1,#0]
                  |L9.32|
;;;337      
;;;338      /* Change the TIM state*/
;;;339      htim->State= HAL_TIM_STATE_READY;
000020  2101              MOVS     r1,#1
000022  63c1              STR      r1,[r0,#0x3c]
;;;340      
;;;341      /* Return function status */
;;;342      return HAL_OK;
000024  2000              MOVS     r0,#0
;;;343    }
000026  4770              BX       lr
;;;344    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop_DMA PROC
;;;438      */
;;;439    HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
000000  6801              LDR      r1,[r0,#0]
;;;440    {
;;;441      /* Check the parameters */
;;;442      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
;;;443      
;;;444      /* Disable the TIM Update DMA request */
;;;445      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
000002  68ca              LDR      r2,[r1,#0xc]
000004  f4227280          BIC      r2,r2,#0x100
000008  60ca              STR      r2,[r1,#0xc]
;;;446          
;;;447      /* Disable the Peripheral */
;;;448      __HAL_TIM_DISABLE(htim);
00000a  6801              LDR      r1,[r0,#0]
00000c  6a0a              LDR      r2,[r1,#0x20]
00000e  f2411311          MOV      r3,#0x1111
000012  421a              TST      r2,r3
000014  d107              BNE      |L10.38|
000016  6a0a              LDR      r2,[r1,#0x20]
000018  109b              ASRS     r3,r3,#2
00001a  421a              TST      r2,r3
00001c  d103              BNE      |L10.38|
00001e  680a              LDR      r2,[r1,#0]
000020  f0220201          BIC      r2,r2,#1
000024  600a              STR      r2,[r1,#0]
                  |L10.38|
;;;449        
;;;450      /* Change the htim state */
;;;451      htim->State = HAL_TIM_STATE_READY;
000026  2101              MOVS     r1,#1
000028  63c1              STR      r1,[r0,#0x3c]
;;;452          
;;;453      /* Return function status */
;;;454      return HAL_OK;
00002a  2000              MOVS     r0,#0
;;;455    }
00002c  4770              BX       lr
;;;456    /**
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop_IT PROC
;;;371      */
;;;372    HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
000000  6801              LDR      r1,[r0,#0]
;;;373    {
;;;374      /* Check the parameters */
;;;375      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;376      /* Disable the TIM Update interrupt */
;;;377      __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
000002  68ca              LDR      r2,[r1,#0xc]
000004  f0220201          BIC      r2,r2,#1
000008  60ca              STR      r2,[r1,#0xc]
;;;378          
;;;379      /* Disable the Peripheral */
;;;380      __HAL_TIM_DISABLE(htim);
00000a  6800              LDR      r0,[r0,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L11.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L11.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L11.38|
;;;381        
;;;382      /* Return function status */
;;;383      return HAL_OK;
000026  2000              MOVS     r0,#0
;;;384    }
000028  4770              BX       lr
;;;385    
                          ENDP


                          AREA ||i.HAL_TIM_ConfigClockSource||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigClockSource PROC
;;;3948     */ 
;;;3949   HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)    
000000  6b82              LDR      r2,[r0,#0x38]
;;;3950   {
;;;3951     uint32_t tmpsmcr = 0U;
;;;3952       
;;;3953     /* Process Locked */
;;;3954     __HAL_LOCK(htim);
000002  2a01              CMP      r2,#1
000004  bf0d              ITEET    EQ
000006  2002              MOVEQ    r0,#2
000008  2301              MOVNE    r3,#1
00000a  6383              STRNE    r3,[r0,#0x38]
;;;3955     
;;;3956     htim->State = HAL_TIM_STATE_BUSY;
;;;3957     
;;;3958     /* Check the parameters */
;;;3959     assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
;;;3960     
;;;3961     /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
;;;3962     tmpsmcr = htim->Instance->SMCR;
;;;3963     tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
;;;3964     tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
;;;3965     htim->Instance->SMCR = tmpsmcr;
;;;3966     
;;;3967     switch (sClockSourceConfig->ClockSource)
;;;3968     {
;;;3969       case TIM_CLOCKSOURCE_INTERNAL:
;;;3970       { 
;;;3971         assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;3972         
;;;3973         /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;3974         htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3975       }
;;;3976       break;
;;;3977       
;;;3978       case TIM_CLOCKSOURCE_ETRMODE1:
;;;3979       {
;;;3980         assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
;;;3981   
;;;3982         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;3983         assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
;;;3984         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;3985   
;;;3986         /* Configure the ETR Clock source */
;;;3987         TIM_ETR_SetConfig(htim->Instance, 
;;;3988                           sClockSourceConfig->ClockPrescaler, 
;;;3989                           sClockSourceConfig->ClockPolarity, 
;;;3990                           sClockSourceConfig->ClockFilter);
;;;3991         /* Get the TIMx SMCR register value */
;;;3992         tmpsmcr = htim->Instance->SMCR;
;;;3993         /* Reset the SMS and TS Bits */
;;;3994         tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
;;;3995         /* Select the External clock mode1 and the ETRF trigger */
;;;3996         tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
;;;3997         /* Write to TIMx SMCR */
;;;3998         htim->Instance->SMCR = tmpsmcr;
;;;3999       }
;;;4000       break;
;;;4001       
;;;4002       case TIM_CLOCKSOURCE_ETRMODE2:
;;;4003       {
;;;4004         assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
;;;4005   
;;;4006         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4007         assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
;;;4008         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4009   
;;;4010         /* Configure the ETR Clock source */
;;;4011         TIM_ETR_SetConfig(htim->Instance, 
;;;4012                           sClockSourceConfig->ClockPrescaler, 
;;;4013                           sClockSourceConfig->ClockPolarity,
;;;4014                           sClockSourceConfig->ClockFilter);
;;;4015         /* Enable the External clock mode2 */
;;;4016         htim->Instance->SMCR |= TIM_SMCR_ECE;
;;;4017       }
;;;4018       break;
;;;4019       
;;;4020       case TIM_CLOCKSOURCE_TI1:
;;;4021       {
;;;4022         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4023   
;;;4024         /* Check TI1 input conditioning related parameters */
;;;4025         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4026         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4027   
;;;4028         TIM_TI1_ConfigInputStage(htim->Instance, 
;;;4029                           sClockSourceConfig->ClockPolarity, 
;;;4030                           sClockSourceConfig->ClockFilter);
;;;4031         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
;;;4032       }
;;;4033       break;
;;;4034       case TIM_CLOCKSOURCE_TI2:
;;;4035       {
;;;4036         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4037   
;;;4038         /* Check TI1 input conditioning related parameters */
;;;4039         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4040         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4041   
;;;4042         TIM_TI2_ConfigInputStage(htim->Instance, 
;;;4043                           sClockSourceConfig->ClockPolarity, 
;;;4044                           sClockSourceConfig->ClockFilter);
;;;4045         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
;;;4046       }
;;;4047       break;
;;;4048       case TIM_CLOCKSOURCE_TI1ED:
;;;4049       {
;;;4050         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4051   
;;;4052         /* Check TI1 input conditioning related parameters */
;;;4053         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4054         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4055   
;;;4056         TIM_TI1_ConfigInputStage(htim->Instance, 
;;;4057                           sClockSourceConfig->ClockPolarity,
;;;4058                           sClockSourceConfig->ClockFilter);
;;;4059         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
;;;4060       }
;;;4061       break;
;;;4062       case TIM_CLOCKSOURCE_ITR0:
;;;4063       {
;;;4064         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4065         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR0);
;;;4066       }
;;;4067       break;
;;;4068       case TIM_CLOCKSOURCE_ITR1:
;;;4069       {
;;;4070         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4071         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR1);
;;;4072       }
;;;4073       break;
;;;4074       case TIM_CLOCKSOURCE_ITR2:
;;;4075       {
;;;4076         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4077         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR2);
;;;4078       }
;;;4079       break;
;;;4080       case TIM_CLOCKSOURCE_ITR3:
;;;4081       {
;;;4082         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4083         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR3);
;;;4084       }
;;;4085       break;
;;;4086       
;;;4087       default:
;;;4088       break;    
;;;4089     }
;;;4090     htim->State = HAL_TIM_STATE_READY;
;;;4091     
;;;4092     __HAL_UNLOCK(htim);
;;;4093     
;;;4094     return HAL_OK;
;;;4095   }
00000c  4770              BXEQ     lr
00000e  b430              PUSH     {r4,r5}               ;3950
000010  2202              MOVS     r2,#2                 ;3956
000012  63c2              STR      r2,[r0,#0x3c]         ;3956
000014  6802              LDR      r2,[r0,#0]            ;3962
000016  f8d2c008          LDR      r12,[r2,#8]           ;3962
00001a  f02c0c77          BIC      r12,r12,#0x77         ;3964
00001e  f42c4c7f          BIC      r12,r12,#0xff00       ;3964
000022  f8c2c008          STR      r12,[r2,#8]           ;3965
000026  680a              LDR      r2,[r1,#0]            ;3967
000028  2a50              CMP      r2,#0x50              ;3967
00002a  d041              BEQ      |L12.176|
00002c  dc0c              BGT      |L12.72|
00002e  2a20              CMP      r2,#0x20              ;3967
000030  d077              BEQ      |L12.290|
000032  dc04              BGT      |L12.62|
000034  2a00              CMP      r2,#0                 ;3967
000036  d075              BEQ      |L12.292|
000038  2a10              CMP      r2,#0x10              ;3967
00003a  d074              BEQ      |L12.294|
00003c  e0b1              B        |L12.418|
                  |L12.62|
00003e  2a30              CMP      r2,#0x30              ;3967
000040  d072              BEQ      |L12.296|
000042  2a40              CMP      r2,#0x40              ;3967
000044  d072              BEQ      |L12.300|
000046  e0ac              B        |L12.418|
                  |L12.72|
000048  2a60              CMP      r2,#0x60              ;3967
00004a  d04e              BEQ      |L12.234|
00004c  2a70              CMP      r2,#0x70              ;3967
00004e  d00b              BEQ      |L12.104|
000050  f5b25f80          CMP      r2,#0x1000            ;3967
000054  d003              BEQ      |L12.94|
000056  f5b25f00          CMP      r2,#0x2000            ;3967
00005a  d017              BEQ      |L12.140|
00005c  e0a1              B        |L12.418|
                  |L12.94|
00005e  6801              LDR      r1,[r0,#0]            ;3974
000060  688a              LDR      r2,[r1,#8]            ;3974
000062  f0220207          BIC      r2,r2,#7              ;3974
000066  e03e              B        |L12.230|
                  |L12.104|
000068  6802              LDR      r2,[r0,#0]            ;3987
00006a  f8d1c004          LDR      r12,[r1,#4]           ;3987
00006e  688c              LDR      r4,[r1,#8]            ;3987
000070  68c9              LDR      r1,[r1,#0xc]          ;3987
000072  6895              LDR      r5,[r2,#8]            ;3987
000074  ea4c2101          ORR      r1,r12,r1,LSL #8      ;3987
000078  f425457f          BIC      r5,r5,#0xff00         ;3987
00007c  4321              ORRS     r1,r1,r4              ;3987
00007e  4329              ORRS     r1,r1,r5              ;3987
000080  6091              STR      r1,[r2,#8]            ;3987
000082  6801              LDR      r1,[r0,#0]            ;3992
000084  688a              LDR      r2,[r1,#8]            ;3992
000086  f0420277          ORR      r2,r2,#0x77           ;3996
00008a  e02c              B        |L12.230|
                  |L12.140|
00008c  6802              LDR      r2,[r0,#0]            ;4011
00008e  f8d1c004          LDR      r12,[r1,#4]           ;4011
000092  688c              LDR      r4,[r1,#8]            ;4011
000094  68c9              LDR      r1,[r1,#0xc]          ;4011
000096  6895              LDR      r5,[r2,#8]            ;4011
000098  ea4c2101          ORR      r1,r12,r1,LSL #8      ;4011
00009c  f425457f          BIC      r5,r5,#0xff00         ;4011
0000a0  4321              ORRS     r1,r1,r4              ;4011
0000a2  4329              ORRS     r1,r1,r5              ;4011
0000a4  6091              STR      r1,[r2,#8]            ;4011
0000a6  6801              LDR      r1,[r0,#0]            ;4016
0000a8  688a              LDR      r2,[r1,#8]            ;4016
0000aa  f4424280          ORR      r2,r2,#0x4000         ;4016
0000ae  e01a              B        |L12.230|
                  |L12.176|
0000b0  6802              LDR      r2,[r0,#0]            ;4028
0000b2  f8d1c004          LDR      r12,[r1,#4]           ;4028
0000b6  68c9              LDR      r1,[r1,#0xc]          ;4028
0000b8  6a14              LDR      r4,[r2,#0x20]         ;4028
0000ba  6a15              LDR      r5,[r2,#0x20]         ;4028
0000bc  f0250501          BIC      r5,r5,#1              ;4028
0000c0  6215              STR      r5,[r2,#0x20]         ;4028
0000c2  6995              LDR      r5,[r2,#0x18]         ;4028
0000c4  f024040a          BIC      r4,r4,#0xa            ;4028
0000c8  f02505f0          BIC      r5,r5,#0xf0           ;4028
0000cc  ea451101          ORR      r1,r5,r1,LSL #4       ;4028
0000d0  ea440c0c          ORR      r12,r4,r12            ;4028
0000d4  6191              STR      r1,[r2,#0x18]         ;4028
0000d6  f8c2c020          STR      r12,[r2,#0x20]        ;4028
0000da  6801              LDR      r1,[r0,#0]            ;4028
0000dc  688a              LDR      r2,[r1,#8]            ;4028
0000de  f0220270          BIC      r2,r2,#0x70           ;4028
0000e2  f0420257          ORR      r2,r2,#0x57           ;4028
                  |L12.230|
0000e6  608a              STR      r2,[r1,#8]            ;4016
0000e8  e05b              B        |L12.418|
                  |L12.234|
0000ea  6802              LDR      r2,[r0,#0]            ;4042
0000ec  f8d1c004          LDR      r12,[r1,#4]           ;4042
0000f0  68cc              LDR      r4,[r1,#0xc]          ;4042
0000f2  6a11              LDR      r1,[r2,#0x20]         ;4042
0000f4  f0210110          BIC      r1,r1,#0x10           ;4042
0000f8  6211              STR      r1,[r2,#0x20]         ;4042
0000fa  6995              LDR      r5,[r2,#0x18]         ;4042
0000fc  6a11              LDR      r1,[r2,#0x20]         ;4042
0000fe  f4254570          BIC      r5,r5,#0xf000         ;4042
000102  ea453404          ORR      r4,r5,r4,LSL #12      ;4042
000106  f02101a0          BIC      r1,r1,#0xa0           ;4042
00010a  ea41110c          ORR      r1,r1,r12,LSL #4      ;4042
00010e  6194              STR      r4,[r2,#0x18]         ;4042
000110  6211              STR      r1,[r2,#0x20]         ;4042
000112  6801              LDR      r1,[r0,#0]            ;4042
000114  688a              LDR      r2,[r1,#8]            ;4042
000116  f0220270          BIC      r2,r2,#0x70           ;4042
00011a  f0420267          ORR      r2,r2,#0x67           ;4042
00011e  608a              STR      r2,[r1,#8]            ;4042
000120  e03f              B        |L12.418|
                  |L12.290|
000122  e02f              B        |L12.388|
                  |L12.292|
000124  e01e              B        |L12.356|
                  |L12.294|
000126  e025              B        |L12.372|
                  |L12.296|
000128  e034              B        |L12.404|
00012a  e7ff              B        |L12.300|
                  |L12.300|
00012c  6802              LDR      r2,[r0,#0]            ;4056
00012e  f8d1c004          LDR      r12,[r1,#4]           ;4056
000132  68cc              LDR      r4,[r1,#0xc]          ;4056
000134  6a11              LDR      r1,[r2,#0x20]         ;4056
000136  6a15              LDR      r5,[r2,#0x20]         ;4056
000138  f0250501          BIC      r5,r5,#1              ;4056
00013c  6215              STR      r5,[r2,#0x20]         ;4056
00013e  6995              LDR      r5,[r2,#0x18]         ;4056
000140  f021010a          BIC      r1,r1,#0xa            ;4056
000144  f02505f0          BIC      r5,r5,#0xf0           ;4056
000148  ea451404          ORR      r4,r5,r4,LSL #4       ;4056
00014c  ea41010c          ORR      r1,r1,r12             ;4056
000150  6194              STR      r4,[r2,#0x18]         ;4056
000152  6211              STR      r1,[r2,#0x20]         ;4056
000154  6801              LDR      r1,[r0,#0]            ;4056
000156  688a              LDR      r2,[r1,#8]            ;4056
000158  f0220270          BIC      r2,r2,#0x70           ;4056
00015c  f0420247          ORR      r2,r2,#0x47           ;4056
000160  608a              STR      r2,[r1,#8]            ;4056
000162  e01e              B        |L12.418|
                  |L12.356|
000164  6801              LDR      r1,[r0,#0]            ;4061
000166  688a              LDR      r2,[r1,#8]            ;4061
000168  f0220270          BIC      r2,r2,#0x70           ;4061
00016c  f0420207          ORR      r2,r2,#7              ;4061
000170  608a              STR      r2,[r1,#8]            ;4061
000172  e016              B        |L12.418|
                  |L12.372|
000174  6801              LDR      r1,[r0,#0]            ;4067
000176  688a              LDR      r2,[r1,#8]            ;4067
000178  f0220270          BIC      r2,r2,#0x70           ;4067
00017c  f0420217          ORR      r2,r2,#0x17           ;4067
000180  608a              STR      r2,[r1,#8]            ;4067
000182  e00e              B        |L12.418|
                  |L12.388|
000184  6801              LDR      r1,[r0,#0]            ;4073
000186  688a              LDR      r2,[r1,#8]            ;4073
000188  f0220270          BIC      r2,r2,#0x70           ;4073
00018c  f0420227          ORR      r2,r2,#0x27           ;4073
000190  608a              STR      r2,[r1,#8]            ;4073
000192  e006              B        |L12.418|
                  |L12.404|
000194  6801              LDR      r1,[r0,#0]            ;4079
000196  688a              LDR      r2,[r1,#8]            ;4079
000198  f0220270          BIC      r2,r2,#0x70           ;4079
00019c  f0420237          ORR      r2,r2,#0x37           ;4079
0001a0  608a              STR      r2,[r1,#8]            ;4079
                  |L12.418|
0001a2  63c3              STR      r3,[r0,#0x3c]         ;4090
0001a4  2100              MOVS     r1,#0                 ;4092
0001a6  6381              STR      r1,[r0,#0x38]         ;4094
0001a8  bc30              POP      {r4,r5}
0001aa  4608              MOV      r0,r1                 ;4094
0001ac  4770              BX       lr
;;;4096   
                          ENDP


                          AREA ||i.HAL_TIM_ConfigOCrefClear||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigOCrefClear PROC
;;;3845     */ 
;;;3846   HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim, TIM_ClearInputConfigTypeDef * sClearInputConfig, uint32_t Channel)
000000  b4f0              PUSH     {r4-r7}
;;;3847   { 
;;;3848     /* Check the parameters */
;;;3849     assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3850     assert_param(IS_TIM_CHANNELS(Channel));
;;;3851     assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
;;;3852     assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
;;;3853     assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
;;;3854     assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
;;;3855      
;;;3856     /* Process Locked */
;;;3857     __HAL_LOCK(htim);
000002  6b83              LDR      r3,[r0,#0x38]
000004  2b01              CMP      r3,#1
000006  bf02              ITTT     EQ
000008  2002              MOVEQ    r0,#2
;;;3858     
;;;3859     htim->State = HAL_TIM_STATE_BUSY;
;;;3860     
;;;3861     if(sClearInputConfig->ClearInputSource == TIM_CLEARINPUTSOURCE_ETR)
;;;3862     {
;;;3863       TIM_ETR_SetConfig(htim->Instance, 
;;;3864                         sClearInputConfig->ClearInputPrescaler,
;;;3865                         sClearInputConfig->ClearInputPolarity,
;;;3866                         sClearInputConfig->ClearInputFilter);
;;;3867     }
;;;3868     
;;;3869     switch (Channel)
;;;3870     {
;;;3871       case TIM_CHANNEL_1:
;;;3872       {        
;;;3873         if(sClearInputConfig->ClearInputState != RESET)  
;;;3874         {
;;;3875           /* Enable the Ocref clear feature for Channel 1 */
;;;3876           htim->Instance->CCMR1 |= TIM_CCMR1_OC1CE;
;;;3877         }
;;;3878         else
;;;3879         {
;;;3880           /* Disable the Ocref clear feature for Channel 1 */
;;;3881           htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1CE;      
;;;3882         }
;;;3883       }    
;;;3884       break;
;;;3885       case TIM_CHANNEL_2:    
;;;3886       { 
;;;3887         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance)); 
;;;3888         if(sClearInputConfig->ClearInputState != RESET)  
;;;3889         {
;;;3890           /* Enable the Ocref clear feature for Channel 2 */
;;;3891           htim->Instance->CCMR1 |= TIM_CCMR1_OC2CE;
;;;3892         }
;;;3893         else
;;;3894         {
;;;3895           /* Disable the Ocref clear feature for Channel 2 */
;;;3896           htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2CE;      
;;;3897         }
;;;3898       } 
;;;3899       break;
;;;3900       case TIM_CHANNEL_3:   
;;;3901       {  
;;;3902         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3903         if(sClearInputConfig->ClearInputState != RESET)  
;;;3904         {
;;;3905           /* Enable the Ocref clear feature for Channel 3 */
;;;3906           htim->Instance->CCMR2 |= TIM_CCMR2_OC3CE;
;;;3907         }
;;;3908         else
;;;3909         {
;;;3910           /* Disable the Ocref clear feature for Channel 3 */
;;;3911           htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3CE;      
;;;3912         }
;;;3913       } 
;;;3914       break;
;;;3915       case TIM_CHANNEL_4:    
;;;3916       {  
;;;3917         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3918         if(sClearInputConfig->ClearInputState != RESET)  
;;;3919         {
;;;3920           /* Enable the Ocref clear feature for Channel 4 */
;;;3921           htim->Instance->CCMR2 |= TIM_CCMR2_OC4CE;
;;;3922         }
;;;3923         else
;;;3924         {
;;;3925           /* Disable the Ocref clear feature for Channel 4 */
;;;3926           htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4CE;      
;;;3927         }
;;;3928       } 
;;;3929       break;
;;;3930       default:  
;;;3931       break;
;;;3932     } 
;;;3933   
;;;3934     htim->State = HAL_TIM_STATE_READY;
;;;3935     
;;;3936     __HAL_UNLOCK(htim);
;;;3937     
;;;3938     return HAL_OK;  
;;;3939   }  
00000a  bcf0              POPEQ    {r4-r7}
00000c  4770              BXEQ     lr
00000e  f04f0c01          MOV      r12,#1                ;3857
000012  2302              MOVS     r3,#2                 ;3859
000014  f8c0c038          STR      r12,[r0,#0x38]        ;3859
000018  63c3              STR      r3,[r0,#0x3c]         ;3859
00001a  684b              LDR      r3,[r1,#4]            ;3861
00001c  2b01              CMP      r3,#1                 ;3861
00001e  d10b              BNE      |L13.56|
000020  6803              LDR      r3,[r0,#0]            ;3863
000022  e9d15403          LDRD     r5,r4,[r1,#0xc]       ;3863
000026  688e              LDR      r6,[r1,#8]            ;3863
000028  689f              LDR      r7,[r3,#8]            ;3863
00002a  ea462404          ORR      r4,r6,r4,LSL #8       ;3863
00002e  f427477f          BIC      r7,r7,#0xff00         ;3863
000032  432c              ORRS     r4,r4,r5              ;3863
000034  433c              ORRS     r4,r4,r7              ;3863
000036  609c              STR      r4,[r3,#8]            ;3863
                  |L13.56|
000038  b132              CBZ      r2,|L13.72|
00003a  2a04              CMP      r2,#4                 ;3869
00003c  d00f              BEQ      |L13.94|
00003e  2a08              CMP      r2,#8                 ;3869
000040  d017              BEQ      |L13.114|
000042  2a0c              CMP      r2,#0xc               ;3869
000044  d026              BEQ      |L13.148|
000046  e01e              B        |L13.134|
                  |L13.72|
000048  6809              LDR      r1,[r1,#0]            ;3873
00004a  2900              CMP      r1,#0                 ;3873
00004c  6801              LDR      r1,[r0,#0]            ;3881
00004e  698a              LDR      r2,[r1,#0x18]         ;3881
000050  bf14              ITE      NE                    ;3876
000052  f0420280          ORRNE    r2,r2,#0x80           ;3876
000056  f0220280          BICEQ    r2,r2,#0x80           ;3881
                  |L13.90|
00005a  618a              STR      r2,[r1,#0x18]         ;3876
00005c  e013              B        |L13.134|
                  |L13.94|
00005e  6809              LDR      r1,[r1,#0]            ;3888
000060  2900              CMP      r1,#0                 ;3888
000062  6801              LDR      r1,[r0,#0]            ;3896
000064  698a              LDR      r2,[r1,#0x18]         ;3896
000066  bf14              ITE      NE                    ;3891
000068  f4424200          ORRNE    r2,r2,#0x8000         ;3891
00006c  f4224200          BICEQ    r2,r2,#0x8000         ;3896
000070  e7f3              B        |L13.90|
                  |L13.114|
000072  6809              LDR      r1,[r1,#0]            ;3903
000074  2900              CMP      r1,#0                 ;3903
000076  6801              LDR      r1,[r0,#0]            ;3911
000078  69ca              LDR      r2,[r1,#0x1c]         ;3911
00007a  bf14              ITE      NE                    ;3906
00007c  f0420280          ORRNE    r2,r2,#0x80           ;3906
000080  f0220280          BICEQ    r2,r2,#0x80           ;3911
                  |L13.132|
000084  61ca              STR      r2,[r1,#0x1c]         ;3906
                  |L13.134|
000086  f8c0c03c          STR      r12,[r0,#0x3c]        ;3934
00008a  2100              MOVS     r1,#0                 ;3936
00008c  6381              STR      r1,[r0,#0x38]         ;3938
00008e  bcf0              POP      {r4-r7}
000090  4608              MOV      r0,r1                 ;3938
000092  4770              BX       lr
                  |L13.148|
000094  6809              LDR      r1,[r1,#0]            ;3918
000096  2900              CMP      r1,#0                 ;3918
000098  6801              LDR      r1,[r0,#0]            ;3926
00009a  69ca              LDR      r2,[r1,#0x1c]         ;3926
00009c  bf14              ITE      NE                    ;3921
00009e  f4424200          ORRNE    r2,r2,#0x8000         ;3921
0000a2  f4224200          BICEQ    r2,r2,#0x8000         ;3926
0000a6  e7ed              B        |L13.132|
;;;3940   
                          ENDP


                          AREA ||i.HAL_TIM_ConfigTI1Input||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigTI1Input PROC
;;;4109     */
;;;4110   HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
000000  6800              LDR      r0,[r0,#0]
;;;4111   {
;;;4112     uint32_t tmpcr2 = 0U;
;;;4113     
;;;4114     /* Check the parameters */
;;;4115     assert_param(IS_TIM_XOR_INSTANCE(htim->Instance)); 
;;;4116     assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
;;;4117   
;;;4118     /* Get the TIMx CR2 register value */
;;;4119     tmpcr2 = htim->Instance->CR2;
000002  6842              LDR      r2,[r0,#4]
;;;4120   
;;;4121     /* Reset the TI1 selection */
;;;4122     tmpcr2 &= ~TIM_CR2_TI1S;
000004  f0220280          BIC      r2,r2,#0x80
;;;4123   
;;;4124     /* Set the TI1 selection */
;;;4125     tmpcr2 |= TI1_Selection;
000008  4311              ORRS     r1,r1,r2
;;;4126     
;;;4127     /* Write to TIMxCR2 */
;;;4128     htim->Instance->CR2 = tmpcr2;
00000a  6041              STR      r1,[r0,#4]
;;;4129   
;;;4130     return HAL_OK;
00000c  2000              MOVS     r0,#0
;;;4131   }
00000e  4770              BX       lr
;;;4132   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_ReadStart||, CODE, READONLY, ALIGN=2

                  HAL_TIM_DMABurst_ReadStart PROC
;;;3601     */
;;;3602   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3603                                                uint32_t  *BurstBuffer, uint32_t  BurstLength)
;;;3604   {
000004  4604              MOV      r4,r0
;;;3605     /* Check the parameters */
;;;3606     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;3607     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;3608     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3609     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;3610     
;;;3611     if((htim->State == HAL_TIM_STATE_BUSY))
000006  9d06              LDR      r5,[sp,#0x18]
000008  6bc0              LDR      r0,[r0,#0x3c]
00000a  469c              MOV      r12,r3                ;3604
00000c  4616              MOV      r6,r2                 ;3604
00000e  4688              MOV      r8,r1                 ;3604
000010  2802              CMP      r0,#2
;;;3612     {
;;;3613        return HAL_BUSY;
;;;3614     }
;;;3615     else if((htim->State == HAL_TIM_STATE_READY))
;;;3616     {
;;;3617       if((BurstBuffer == 0U) && (BurstLength > 0U)) 
;;;3618       {
;;;3619         return HAL_ERROR;                                    
;;;3620       }
;;;3621       else
;;;3622       {
;;;3623         htim->State = HAL_TIM_STATE_BUSY;
;;;3624       }
;;;3625     }  
;;;3626     switch(BurstRequestSrc)
;;;3627     {
;;;3628       case TIM_DMA_UPDATE:
;;;3629       {  
;;;3630         /* Set the DMA Period elapsed callback */
;;;3631         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;3632        
;;;3633         /* Set the DMA error callback */
;;;3634         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;3635     
;;;3636         /* Enable the DMA Stream */
;;;3637          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);     
;;;3638       }
;;;3639       break;
;;;3640       case TIM_DMA_CC1:
;;;3641       {  
;;;3642         /* Set the DMA Period elapsed callback */
;;;3643         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;3644        
;;;3645         /* Set the DMA error callback */
;;;3646         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;3647     
;;;3648         /* Enable the DMA Stream */
;;;3649         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);      
;;;3650       }
;;;3651       break;
;;;3652       case TIM_DMA_CC2:
;;;3653       {  
;;;3654         /* Set the DMA Period elapsed callback */
;;;3655         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;3656        
;;;3657         /* Set the DMA error callback */
;;;3658         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;3659     
;;;3660         /* Enable the DMA Stream */
;;;3661         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);     
;;;3662       }
;;;3663       break;
;;;3664       case TIM_DMA_CC3:
;;;3665       {  
;;;3666         /* Set the DMA Period elapsed callback */
;;;3667         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
;;;3668        
;;;3669         /* Set the DMA error callback */
;;;3670         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;3671     
;;;3672         /* Enable the DMA Stream */
;;;3673         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);      
;;;3674       }
;;;3675       break;
;;;3676       case TIM_DMA_CC4:
;;;3677       {  
;;;3678         /* Set the DMA Period elapsed callback */
;;;3679         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
;;;3680        
;;;3681         /* Set the DMA error callback */
;;;3682         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;3683     
;;;3684         /* Enable the DMA Stream */
;;;3685         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);      
;;;3686       }
;;;3687       break;
;;;3688       case TIM_DMA_COM:
;;;3689       {  
;;;3690         /* Set the DMA Period elapsed callback */
;;;3691         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = TIMEx_DMACommutationCplt;
;;;3692        
;;;3693         /* Set the DMA error callback */
;;;3694         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
;;;3695     
;;;3696         /* Enable the DMA Stream */
;;;3697         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);      
;;;3698       }
;;;3699       break;
;;;3700       case TIM_DMA_TRIGGER:
;;;3701       {  
;;;3702         /* Set the DMA Period elapsed callback */
;;;3703         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;3704        
;;;3705         /* Set the DMA error callback */
;;;3706         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
;;;3707     
;;;3708         /* Enable the DMA Stream */
;;;3709         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1);      
;;;3710       }
;;;3711       break;
;;;3712       default:
;;;3713       break;  
;;;3714     }
;;;3715   
;;;3716     /* configure the DMA Burst Mode */
;;;3717     htim->Instance->DCR = BurstBaseAddress | BurstLength;  
;;;3718     
;;;3719     /* Enable the TIM DMA Request */
;;;3720     __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
;;;3721     
;;;3722     htim->State = HAL_TIM_STATE_READY;
;;;3723     
;;;3724     /* Return function status */
;;;3725     return HAL_OK;
;;;3726   }
000012  bf08              IT       EQ
000014  e8bd81f0          POPEQ    {r4-r8,pc}
000018  6be0              LDR      r0,[r4,#0x3c]         ;3615
00001a  2801              CMP      r0,#1                 ;3615
00001c  d109              BNE      |L15.50|
00001e  f1bc0f00          CMP      r12,#0                ;3617
000022  d104              BNE      |L15.46|
000024  2d00              CMP      r5,#0                 ;3617
000026  bf1c              ITT      NE                    ;3619
000028  2001              MOVNE    r0,#1                 ;3619
00002a  e8bd81f0          POPNE    {r4-r8,pc}
                  |L15.46|
00002e  2002              MOVS     r0,#2                 ;3623
000030  63e0              STR      r0,[r4,#0x3c]         ;3623
                  |L15.50|
000032  2701              MOVS     r7,#1                 ;3619
000034  483e              LDR      r0,|L15.304|
000036  4a3f              LDR      r2,|L15.308|
000038  eb072315          ADD      r3,r7,r5,LSR #8       ;3637
00003c  f5b66f00          CMP      r6,#0x800             ;3626
000040  d039              BEQ      |L15.182|
000042  dc09              BGT      |L15.88|
000044  f5b67f80          CMP      r6,#0x100             ;3626
000048  d010              BEQ      |L15.108|
00004a  f5b67f00          CMP      r6,#0x200             ;3626
00004e  d01a              BEQ      |L15.134|
000050  f5b66f80          CMP      r6,#0x400             ;3626
000054  d023              BEQ      |L15.158|
000056  e05f              B        |L15.280|
                  |L15.88|
000058  f5b65f80          CMP      r6,#0x1000            ;3626
00005c  d037              BEQ      |L15.206|
00005e  f5b65f00          CMP      r6,#0x2000            ;3626
000062  d040              BEQ      |L15.230|
000064  f5b64f80          CMP      r6,#0x4000            ;3626
000068  d04a              BEQ      |L15.256|
00006a  e055              B        |L15.280|
                  |L15.108|
00006c  69e2              LDR      r2,[r4,#0x1c]         ;3631
00006e  4932              LDR      r1,|L15.312|
000070  6411              STR      r1,[r2,#0x40]         ;3634
000072  69e1              LDR      r1,[r4,#0x1c]         ;3634
000074  4662              MOV      r2,r12                ;3637
000076  6508              STR      r0,[r1,#0x50]         ;3637
000078  6820              LDR      r0,[r4,#0]            ;3637
00007a  f100014c          ADD      r1,r0,#0x4c           ;3637
00007e  69e0              LDR      r0,[r4,#0x1c]         ;3637
000080  f7fffffe          BL       HAL_DMA_Start_IT
000084  e048              B        |L15.280|
                  |L15.134|
000086  6a21              LDR      r1,[r4,#0x20]         ;3643
000088  640a              STR      r2,[r1,#0x40]         ;3646
00008a  6a21              LDR      r1,[r4,#0x20]         ;3646
00008c  4662              MOV      r2,r12                ;3649
00008e  6508              STR      r0,[r1,#0x50]         ;3649
000090  6820              LDR      r0,[r4,#0]            ;3649
000092  f100014c          ADD      r1,r0,#0x4c           ;3649
000096  6a20              LDR      r0,[r4,#0x20]         ;3649
000098  f7fffffe          BL       HAL_DMA_Start_IT
00009c  e03c              B        |L15.280|
                  |L15.158|
00009e  6a61              LDR      r1,[r4,#0x24]         ;3655
0000a0  640a              STR      r2,[r1,#0x40]         ;3658
0000a2  6a61              LDR      r1,[r4,#0x24]         ;3658
0000a4  4662              MOV      r2,r12                ;3661
0000a6  6508              STR      r0,[r1,#0x50]         ;3661
0000a8  6820              LDR      r0,[r4,#0]            ;3661
0000aa  f100014c          ADD      r1,r0,#0x4c           ;3661
0000ae  6a60              LDR      r0,[r4,#0x24]         ;3661
0000b0  f7fffffe          BL       HAL_DMA_Start_IT
0000b4  e030              B        |L15.280|
                  |L15.182|
0000b6  6aa1              LDR      r1,[r4,#0x28]         ;3667
0000b8  640a              STR      r2,[r1,#0x40]         ;3670
0000ba  6aa1              LDR      r1,[r4,#0x28]         ;3670
0000bc  4662              MOV      r2,r12                ;3673
0000be  6508              STR      r0,[r1,#0x50]         ;3673
0000c0  6820              LDR      r0,[r4,#0]            ;3673
0000c2  f100014c          ADD      r1,r0,#0x4c           ;3673
0000c6  6aa0              LDR      r0,[r4,#0x28]         ;3673
0000c8  f7fffffe          BL       HAL_DMA_Start_IT
0000cc  e024              B        |L15.280|
                  |L15.206|
0000ce  6ae1              LDR      r1,[r4,#0x2c]         ;3679
0000d0  640a              STR      r2,[r1,#0x40]         ;3682
0000d2  6ae1              LDR      r1,[r4,#0x2c]         ;3682
0000d4  4662              MOV      r2,r12                ;3685
0000d6  6508              STR      r0,[r1,#0x50]         ;3685
0000d8  6820              LDR      r0,[r4,#0]            ;3685
0000da  f100014c          ADD      r1,r0,#0x4c           ;3685
0000de  6ae0              LDR      r0,[r4,#0x2c]         ;3685
0000e0  f7fffffe          BL       HAL_DMA_Start_IT
0000e4  e018              B        |L15.280|
                  |L15.230|
0000e6  6b22              LDR      r2,[r4,#0x30]         ;3691
0000e8  4914              LDR      r1,|L15.316|
0000ea  6411              STR      r1,[r2,#0x40]         ;3694
0000ec  6b21              LDR      r1,[r4,#0x30]         ;3694
0000ee  4662              MOV      r2,r12                ;3697
0000f0  6508              STR      r0,[r1,#0x50]         ;3697
0000f2  6820              LDR      r0,[r4,#0]            ;3697
0000f4  f100014c          ADD      r1,r0,#0x4c           ;3697
0000f8  6b20              LDR      r0,[r4,#0x30]         ;3697
0000fa  f7fffffe          BL       HAL_DMA_Start_IT
0000fe  e00b              B        |L15.280|
                  |L15.256|
000100  6b62              LDR      r2,[r4,#0x34]         ;3703
000102  490f              LDR      r1,|L15.320|
000104  6411              STR      r1,[r2,#0x40]         ;3706
000106  6b61              LDR      r1,[r4,#0x34]         ;3706
000108  4662              MOV      r2,r12                ;3709
00010a  6508              STR      r0,[r1,#0x50]         ;3709
00010c  6820              LDR      r0,[r4,#0]            ;3709
00010e  f100014c          ADD      r1,r0,#0x4c           ;3709
000112  6b60              LDR      r0,[r4,#0x34]         ;3709
000114  f7fffffe          BL       HAL_DMA_Start_IT
                  |L15.280|
000118  6821              LDR      r1,[r4,#0]            ;3717
00011a  ea480005          ORR      r0,r8,r5              ;3717
00011e  6488              STR      r0,[r1,#0x48]         ;3717
000120  6820              LDR      r0,[r4,#0]            ;3720
000122  68c1              LDR      r1,[r0,#0xc]          ;3720
000124  4331              ORRS     r1,r1,r6              ;3720
000126  60c1              STR      r1,[r0,#0xc]          ;3720
000128  63e7              STR      r7,[r4,#0x3c]         ;3722
00012a  2000              MOVS     r0,#0                 ;3725
00012c  e8bd81f0          POP      {r4-r8,pc}
;;;3727   
                          ENDP

                  |L15.304|
                          DCD      TIM_DMAError
                  |L15.308|
                          DCD      TIM_DMACaptureCplt
                  |L15.312|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L15.316|
                          DCD      TIMEx_DMACommutationCplt
                  |L15.320|
                          DCD      TIM_DMATriggerCplt

                          AREA ||i.HAL_TIM_DMABurst_ReadStop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_ReadStop PROC
;;;3734     */
;;;3735   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
000000  b570              PUSH     {r4-r6,lr}
;;;3736   {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;3737     /* Check the parameters */
;;;3738     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3739     
;;;3740     /* Abort the DMA transfer (at least disable the DMA channel) */
;;;3741     switch(BurstRequestSrc)
000006  f5b16f00          CMP      r1,#0x800
;;;3742     {
;;;3743       case TIM_DMA_UPDATE:
;;;3744       {  
;;;3745         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
;;;3746       }
;;;3747       break;
;;;3748       case TIM_DMA_CC1:
;;;3749       {  
;;;3750         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
;;;3751       }
;;;3752       break;
;;;3753       case TIM_DMA_CC2:
;;;3754       {  
;;;3755         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
;;;3756       }
;;;3757       break;
;;;3758       case TIM_DMA_CC3:
;;;3759       {  
;;;3760         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
00000a  bf08              IT       EQ
00000c  6aa0              LDREQ    r0,[r4,#0x28]
00000e  d021              BEQ      |L16.84|
000010  dc0f              BGT      |L16.50|
000012  f5b57f80          CMP      r5,#0x100             ;3741
000016  bf08              IT       EQ                    ;3745
000018  69e0              LDREQ    r0,[r4,#0x1c]         ;3745
00001a  d01b              BEQ      |L16.84|
00001c  f5b57f00          CMP      r5,#0x200             ;3741
000020  bf08              IT       EQ                    ;3750
000022  6a20              LDREQ    r0,[r4,#0x20]         ;3750
000024  d016              BEQ      |L16.84|
000026  f5b56f80          CMP      r5,#0x400             ;3741
00002a  bf08              IT       EQ                    ;3755
00002c  6a60              LDREQ    r0,[r4,#0x24]         ;3755
00002e  d011              BEQ      |L16.84|
000030  e012              B        |L16.88|
                  |L16.50|
000032  f5b55f80          CMP      r5,#0x1000            ;3741
;;;3761       }
;;;3762       break;
;;;3763       case TIM_DMA_CC4:
;;;3764       {  
;;;3765         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
000036  bf08              IT       EQ
000038  6ae0              LDREQ    r0,[r4,#0x2c]
00003a  d00b              BEQ      |L16.84|
00003c  f5b55f00          CMP      r5,#0x2000            ;3741
;;;3766       }
;;;3767       break;
;;;3768       case TIM_DMA_COM:
;;;3769       {  
;;;3770         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
000040  bf08              IT       EQ
000042  6b20              LDREQ    r0,[r4,#0x30]
000044  d006              BEQ      |L16.84|
000046  f5b54f80          CMP      r5,#0x4000            ;3741
;;;3771       }
;;;3772       break;
;;;3773       case TIM_DMA_TRIGGER:
;;;3774       {  
;;;3775         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
00004a  bf04              ITT      EQ
00004c  6b60              LDREQ    r0,[r4,#0x34]
00004e  f7fffffe          BLEQ     HAL_DMA_Abort
000052  e001              B        |L16.88|
                  |L16.84|
000054  f7fffffe          BL       HAL_DMA_Abort
                  |L16.88|
;;;3776       }
;;;3777       break;
;;;3778       default:
;;;3779       break;  
;;;3780     }
;;;3781     
;;;3782     /* Disable the TIM Update DMA request */
;;;3783     __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
000058  6820              LDR      r0,[r4,#0]
00005a  68c1              LDR      r1,[r0,#0xc]
00005c  43a9              BICS     r1,r1,r5
00005e  60c1              STR      r1,[r0,#0xc]
;;;3784         
;;;3785     /* Return function status */
;;;3786     return HAL_OK;  
000060  2000              MOVS     r0,#0
;;;3787   }
000062  bd70              POP      {r4-r6,pc}
;;;3788   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_WriteStart||, CODE, READONLY, ALIGN=2

                  HAL_TIM_DMABurst_WriteStart PROC
;;;3376     */
;;;3377   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3378                                                 uint32_t* BurstBuffer, uint32_t  BurstLength)
;;;3379   {
000004  4604              MOV      r4,r0
;;;3380     /* Check the parameters */
;;;3381     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;3382     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;3383     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3384     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;3385     
;;;3386     if((htim->State == HAL_TIM_STATE_BUSY))
000006  9d06              LDR      r5,[sp,#0x18]
000008  6bc0              LDR      r0,[r0,#0x3c]
00000a  469c              MOV      r12,r3                ;3379
00000c  4616              MOV      r6,r2                 ;3379
00000e  4688              MOV      r8,r1                 ;3379
000010  2802              CMP      r0,#2
;;;3387     {
;;;3388        return HAL_BUSY;
;;;3389     }
;;;3390     else if((htim->State == HAL_TIM_STATE_READY))
;;;3391     {
;;;3392       if((BurstBuffer == 0U) && (BurstLength > 0U)) 
;;;3393       {
;;;3394         return HAL_ERROR;                                    
;;;3395       }
;;;3396       else
;;;3397       {
;;;3398         htim->State = HAL_TIM_STATE_BUSY;
;;;3399       }
;;;3400     }
;;;3401     switch(BurstRequestSrc)
;;;3402     {
;;;3403       case TIM_DMA_UPDATE:
;;;3404       {  
;;;3405         /* Set the DMA Period elapsed callback */
;;;3406         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;3407        
;;;3408         /* Set the DMA error callback */
;;;3409         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;3410     
;;;3411         /* Enable the DMA Stream */
;;;3412         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U); 
;;;3413       }
;;;3414       break;
;;;3415       case TIM_DMA_CC1:
;;;3416       {  
;;;3417         /* Set the DMA Period elapsed callback */
;;;3418         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;3419        
;;;3420         /* Set the DMA error callback */
;;;3421         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;3422     
;;;3423         /* Enable the DMA Stream */
;;;3424         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);     
;;;3425       }
;;;3426       break;
;;;3427       case TIM_DMA_CC2:
;;;3428       {  
;;;3429         /* Set the DMA Period elapsed callback */
;;;3430         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;3431        
;;;3432         /* Set the DMA error callback */
;;;3433         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;3434     
;;;3435         /* Enable the DMA Stream */
;;;3436         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);     
;;;3437       }
;;;3438       break;
;;;3439       case TIM_DMA_CC3:
;;;3440       {  
;;;3441         /* Set the DMA Period elapsed callback */
;;;3442         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;3443        
;;;3444         /* Set the DMA error callback */
;;;3445         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;3446     
;;;3447         /* Enable the DMA Stream */
;;;3448         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);     
;;;3449       }
;;;3450       break;
;;;3451       case TIM_DMA_CC4:
;;;3452       {  
;;;3453         /* Set the DMA Period elapsed callback */
;;;3454         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;3455        
;;;3456         /* Set the DMA error callback */
;;;3457         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;3458     
;;;3459         /* Enable the DMA Stream */
;;;3460         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);     
;;;3461       }
;;;3462       break;
;;;3463       case TIM_DMA_COM:
;;;3464       {  
;;;3465         /* Set the DMA Period elapsed callback */
;;;3466         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = TIMEx_DMACommutationCplt;
;;;3467        
;;;3468         /* Set the DMA error callback */
;;;3469         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
;;;3470     
;;;3471         /* Enable the DMA Stream */
;;;3472         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);     
;;;3473       }
;;;3474       break;
;;;3475       case TIM_DMA_TRIGGER:
;;;3476       {  
;;;3477         /* Set the DMA Period elapsed callback */
;;;3478         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;3479        
;;;3480         /* Set the DMA error callback */
;;;3481         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
;;;3482     
;;;3483         /* Enable the DMA Stream */
;;;3484         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);     
;;;3485       }
;;;3486       break;
;;;3487       default:
;;;3488       break;  
;;;3489     }
;;;3490      /* configure the DMA Burst Mode */
;;;3491      htim->Instance->DCR = BurstBaseAddress | BurstLength;  
;;;3492      
;;;3493      /* Enable the TIM DMA Request */
;;;3494      __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);  
;;;3495      
;;;3496      htim->State = HAL_TIM_STATE_READY;
;;;3497     
;;;3498     /* Return function status */
;;;3499     return HAL_OK;
;;;3500   }
000012  bf08              IT       EQ
000014  e8bd81f0          POPEQ    {r4-r8,pc}
000018  6be0              LDR      r0,[r4,#0x3c]         ;3390
00001a  2801              CMP      r0,#1                 ;3390
00001c  d109              BNE      |L17.50|
00001e  f1bc0f00          CMP      r12,#0                ;3392
000022  d104              BNE      |L17.46|
000024  2d00              CMP      r5,#0                 ;3392
000026  bf1c              ITT      NE                    ;3394
000028  2001              MOVNE    r0,#1                 ;3394
00002a  e8bd81f0          POPNE    {r4-r8,pc}
                  |L17.46|
00002e  2002              MOVS     r0,#2                 ;3398
000030  63e0              STR      r0,[r4,#0x3c]         ;3398
                  |L17.50|
000032  2701              MOVS     r7,#1                 ;3394
000034  483e              LDR      r0,|L17.304|
000036  493f              LDR      r1,|L17.308|
000038  eb072315          ADD      r3,r7,r5,LSR #8       ;3412
00003c  f5b66f00          CMP      r6,#0x800             ;3401
000040  d039              BEQ      |L17.182|
000042  dc09              BGT      |L17.88|
000044  f5b67f80          CMP      r6,#0x100             ;3401
000048  d010              BEQ      |L17.108|
00004a  f5b67f00          CMP      r6,#0x200             ;3401
00004e  d01a              BEQ      |L17.134|
000050  f5b66f80          CMP      r6,#0x400             ;3401
000054  d023              BEQ      |L17.158|
000056  e05f              B        |L17.280|
                  |L17.88|
000058  f5b65f80          CMP      r6,#0x1000            ;3401
00005c  d037              BEQ      |L17.206|
00005e  f5b65f00          CMP      r6,#0x2000            ;3401
000062  d040              BEQ      |L17.230|
000064  f5b64f80          CMP      r6,#0x4000            ;3401
000068  d04a              BEQ      |L17.256|
00006a  e055              B        |L17.280|
                  |L17.108|
00006c  69e2              LDR      r2,[r4,#0x1c]         ;3406
00006e  4932              LDR      r1,|L17.312|
000070  6411              STR      r1,[r2,#0x40]         ;3409
000072  69e1              LDR      r1,[r4,#0x1c]         ;3409
000074  6508              STR      r0,[r1,#0x50]         ;3412
000076  6820              LDR      r0,[r4,#0]            ;3412
000078  4661              MOV      r1,r12                ;3412
00007a  f100024c          ADD      r2,r0,#0x4c           ;3412
00007e  69e0              LDR      r0,[r4,#0x1c]         ;3412
000080  f7fffffe          BL       HAL_DMA_Start_IT
000084  e048              B        |L17.280|
                  |L17.134|
000086  6a22              LDR      r2,[r4,#0x20]         ;3418
000088  6411              STR      r1,[r2,#0x40]         ;3421
00008a  6a21              LDR      r1,[r4,#0x20]         ;3421
00008c  6508              STR      r0,[r1,#0x50]         ;3424
00008e  6820              LDR      r0,[r4,#0]            ;3424
000090  4661              MOV      r1,r12                ;3424
000092  f100024c          ADD      r2,r0,#0x4c           ;3424
000096  6a20              LDR      r0,[r4,#0x20]         ;3424
000098  f7fffffe          BL       HAL_DMA_Start_IT
00009c  e03c              B        |L17.280|
                  |L17.158|
00009e  6a62              LDR      r2,[r4,#0x24]         ;3430
0000a0  6411              STR      r1,[r2,#0x40]         ;3433
0000a2  6a61              LDR      r1,[r4,#0x24]         ;3433
0000a4  6508              STR      r0,[r1,#0x50]         ;3436
0000a6  6820              LDR      r0,[r4,#0]            ;3436
0000a8  4661              MOV      r1,r12                ;3436
0000aa  f100024c          ADD      r2,r0,#0x4c           ;3436
0000ae  6a60              LDR      r0,[r4,#0x24]         ;3436
0000b0  f7fffffe          BL       HAL_DMA_Start_IT
0000b4  e030              B        |L17.280|
                  |L17.182|
0000b6  6aa2              LDR      r2,[r4,#0x28]         ;3442
0000b8  6411              STR      r1,[r2,#0x40]         ;3445
0000ba  6aa1              LDR      r1,[r4,#0x28]         ;3445
0000bc  6508              STR      r0,[r1,#0x50]         ;3448
0000be  6820              LDR      r0,[r4,#0]            ;3448
0000c0  4661              MOV      r1,r12                ;3448
0000c2  f100024c          ADD      r2,r0,#0x4c           ;3448
0000c6  6aa0              LDR      r0,[r4,#0x28]         ;3448
0000c8  f7fffffe          BL       HAL_DMA_Start_IT
0000cc  e024              B        |L17.280|
                  |L17.206|
0000ce  6ae2              LDR      r2,[r4,#0x2c]         ;3454
0000d0  6411              STR      r1,[r2,#0x40]         ;3457
0000d2  6ae1              LDR      r1,[r4,#0x2c]         ;3457
0000d4  6508              STR      r0,[r1,#0x50]         ;3460
0000d6  6820              LDR      r0,[r4,#0]            ;3460
0000d8  4661              MOV      r1,r12                ;3460
0000da  f100024c          ADD      r2,r0,#0x4c           ;3460
0000de  6ae0              LDR      r0,[r4,#0x2c]         ;3460
0000e0  f7fffffe          BL       HAL_DMA_Start_IT
0000e4  e018              B        |L17.280|
                  |L17.230|
0000e6  6b22              LDR      r2,[r4,#0x30]         ;3466
0000e8  4914              LDR      r1,|L17.316|
0000ea  6411              STR      r1,[r2,#0x40]         ;3469
0000ec  6b21              LDR      r1,[r4,#0x30]         ;3469
0000ee  6508              STR      r0,[r1,#0x50]         ;3472
0000f0  6820              LDR      r0,[r4,#0]            ;3472
0000f2  4661              MOV      r1,r12                ;3472
0000f4  f100024c          ADD      r2,r0,#0x4c           ;3472
0000f8  6b20              LDR      r0,[r4,#0x30]         ;3472
0000fa  f7fffffe          BL       HAL_DMA_Start_IT
0000fe  e00b              B        |L17.280|
                  |L17.256|
000100  6b62              LDR      r2,[r4,#0x34]         ;3478
000102  490f              LDR      r1,|L17.320|
000104  6411              STR      r1,[r2,#0x40]         ;3481
000106  6b61              LDR      r1,[r4,#0x34]         ;3481
000108  6508              STR      r0,[r1,#0x50]         ;3484
00010a  6820              LDR      r0,[r4,#0]            ;3484
00010c  4661              MOV      r1,r12                ;3484
00010e  f100024c          ADD      r2,r0,#0x4c           ;3484
000112  6b60              LDR      r0,[r4,#0x34]         ;3484
000114  f7fffffe          BL       HAL_DMA_Start_IT
                  |L17.280|
000118  6821              LDR      r1,[r4,#0]            ;3491
00011a  ea480005          ORR      r0,r8,r5              ;3491
00011e  6488              STR      r0,[r1,#0x48]         ;3491
000120  6820              LDR      r0,[r4,#0]            ;3494
000122  68c1              LDR      r1,[r0,#0xc]          ;3494
000124  4331              ORRS     r1,r1,r6              ;3494
000126  60c1              STR      r1,[r0,#0xc]          ;3494
000128  63e7              STR      r7,[r4,#0x3c]         ;3496
00012a  2000              MOVS     r0,#0                 ;3499
00012c  e8bd81f0          POP      {r4-r8,pc}
;;;3501   
                          ENDP

                  |L17.304|
                          DCD      TIM_DMAError
                  |L17.308|
                          DCD      TIM_DMADelayPulseCplt
                  |L17.312|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L17.316|
                          DCD      TIMEx_DMACommutationCplt
                  |L17.320|
                          DCD      TIM_DMATriggerCplt

                          AREA ||i.HAL_TIM_DMABurst_WriteStop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_WriteStop PROC
;;;3508     */
;;;3509   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
000000  b570              PUSH     {r4-r6,lr}
;;;3510   {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;3511     /* Check the parameters */
;;;3512     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3513     
;;;3514     /* Abort the DMA transfer (at least disable the DMA channel) */
;;;3515     switch(BurstRequestSrc)
000006  f5b16f00          CMP      r1,#0x800
;;;3516     {
;;;3517       case TIM_DMA_UPDATE:
;;;3518       {  
;;;3519         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
;;;3520       }
;;;3521       break;
;;;3522       case TIM_DMA_CC1:
;;;3523       {  
;;;3524         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
;;;3525       }
;;;3526       break;
;;;3527       case TIM_DMA_CC2:
;;;3528       {  
;;;3529         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
;;;3530       }
;;;3531       break;
;;;3532       case TIM_DMA_CC3:
;;;3533       {  
;;;3534         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
00000a  bf08              IT       EQ
00000c  6aa0              LDREQ    r0,[r4,#0x28]
00000e  d021              BEQ      |L18.84|
000010  dc0f              BGT      |L18.50|
000012  f5b57f80          CMP      r5,#0x100             ;3515
000016  bf08              IT       EQ                    ;3519
000018  69e0              LDREQ    r0,[r4,#0x1c]         ;3519
00001a  d01b              BEQ      |L18.84|
00001c  f5b57f00          CMP      r5,#0x200             ;3515
000020  bf08              IT       EQ                    ;3524
000022  6a20              LDREQ    r0,[r4,#0x20]         ;3524
000024  d016              BEQ      |L18.84|
000026  f5b56f80          CMP      r5,#0x400             ;3515
00002a  bf08              IT       EQ                    ;3529
00002c  6a60              LDREQ    r0,[r4,#0x24]         ;3529
00002e  d011              BEQ      |L18.84|
000030  e012              B        |L18.88|
                  |L18.50|
000032  f5b55f80          CMP      r5,#0x1000            ;3515
;;;3535       }
;;;3536       break;
;;;3537       case TIM_DMA_CC4:
;;;3538       {  
;;;3539         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
000036  bf08              IT       EQ
000038  6ae0              LDREQ    r0,[r4,#0x2c]
00003a  d00b              BEQ      |L18.84|
00003c  f5b55f00          CMP      r5,#0x2000            ;3515
;;;3540       }
;;;3541       break;
;;;3542       case TIM_DMA_COM:
;;;3543       {  
;;;3544         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
000040  bf08              IT       EQ
000042  6b20              LDREQ    r0,[r4,#0x30]
000044  d006              BEQ      |L18.84|
000046  f5b54f80          CMP      r5,#0x4000            ;3515
;;;3545       }
;;;3546       break;
;;;3547       case TIM_DMA_TRIGGER:
;;;3548       {  
;;;3549         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
00004a  bf04              ITT      EQ
00004c  6b60              LDREQ    r0,[r4,#0x34]
00004e  f7fffffe          BLEQ     HAL_DMA_Abort
000052  e001              B        |L18.88|
                  |L18.84|
000054  f7fffffe          BL       HAL_DMA_Abort
                  |L18.88|
;;;3550       }
;;;3551       break;
;;;3552       default:
;;;3553       break;
;;;3554     }
;;;3555   
;;;3556     /* Disable the TIM Update DMA request */
;;;3557     __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
000058  6820              LDR      r0,[r4,#0]
00005a  68c1              LDR      r1,[r0,#0xc]
00005c  43a9              BICS     r1,r1,r5
00005e  60c1              STR      r1,[r0,#0xc]
;;;3558         
;;;3559     /* Return function status */
;;;3560     return HAL_OK;  
000060  2000              MOVS     r0,#0
;;;3561   }
000062  bd70              POP      {r4-r6,pc}
;;;3562   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_DeInit PROC
;;;2373     */
;;;2374   HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;2375   {
000002  4604              MOV      r4,r0
;;;2376     /* Check the parameters */
;;;2377     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2378     
;;;2379     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  63e0              STR      r0,[r4,#0x3c]
;;;2380     
;;;2381     /* Disable the TIM Peripheral Clock */
;;;2382     __HAL_TIM_DISABLE(htim);
000008  6820              LDR      r0,[r4,#0]
00000a  6a01              LDR      r1,[r0,#0x20]
00000c  f2411211          MOV      r2,#0x1111
000010  4211              TST      r1,r2
000012  d107              BNE      |L19.36|
000014  6a01              LDR      r1,[r0,#0x20]
000016  1092              ASRS     r2,r2,#2
000018  4211              TST      r1,r2
00001a  d103              BNE      |L19.36|
00001c  6801              LDR      r1,[r0,#0]
00001e  f0210101          BIC      r1,r1,#1
000022  6001              STR      r1,[r0,#0]
                  |L19.36|
;;;2383     
;;;2384     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;2385     HAL_TIM_Encoder_MspDeInit(htim);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       HAL_TIM_Encoder_MspDeInit
;;;2386       
;;;2387     /* Change TIM state */  
;;;2388     htim->State = HAL_TIM_STATE_RESET;
00002a  2000              MOVS     r0,#0
00002c  63e0              STR      r0,[r4,#0x3c]
;;;2389    
;;;2390     /* Release Lock */
;;;2391     __HAL_UNLOCK(htim);
00002e  63a0              STR      r0,[r4,#0x38]
;;;2392   
;;;2393     return HAL_OK;
;;;2394   }
000030  bd10              POP      {r4,pc}
;;;2395   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_GetState PROC
;;;4466     */
;;;4467   HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
000000  6bc0              LDR      r0,[r0,#0x3c]
;;;4468   {
;;;4469     return htim->State;
;;;4470   }
000002  4770              BX       lr
;;;4471   /**
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Init PROC
;;;2284     */
;;;2285   HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef* sConfig)
000000  2800              CMP      r0,#0
;;;2286   {
;;;2287     uint32_t tmpsmcr = 0U;
;;;2288     uint32_t tmpccmr1 = 0U;
;;;2289     uint32_t tmpccer = 0U;
;;;2290     
;;;2291     /* Check the TIM handle allocation */
;;;2292     if(htim == NULL)
;;;2293     {
;;;2294       return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;2295     }
;;;2296      
;;;2297     /* Check the parameters */
;;;2298     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2299     assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
;;;2300     assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
;;;2301     assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
;;;2302     assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
;;;2303     assert_param(IS_TIM_IC_POLARITY(sConfig->IC2Polarity));
;;;2304     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
;;;2305     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
;;;2306     assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
;;;2307     assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
;;;2308   
;;;2309     if(htim->State == HAL_TIM_STATE_RESET)
;;;2310     { 
;;;2311       /* Allocate lock resource and initialize it */
;;;2312       htim->Lock = HAL_UNLOCKED;
;;;2313       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;2314       HAL_TIM_Encoder_MspInit(htim);
;;;2315     }
;;;2316     
;;;2317     /* Set the TIM state */
;;;2318     htim->State= HAL_TIM_STATE_BUSY;   
;;;2319       
;;;2320     /* Reset the SMS bits */
;;;2321     htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;2322     
;;;2323     /* Configure the Time base in the Encoder Mode */
;;;2324     TIM_Base_SetConfig(htim->Instance, &htim->Init);  
;;;2325     
;;;2326     /* Get the TIMx SMCR register value */
;;;2327     tmpsmcr = htim->Instance->SMCR;
;;;2328   
;;;2329     /* Get the TIMx CCMR1 register value */
;;;2330     tmpccmr1 = htim->Instance->CCMR1;
;;;2331   
;;;2332     /* Get the TIMx CCER register value */
;;;2333     tmpccer = htim->Instance->CCER;
;;;2334   
;;;2335     /* Set the encoder Mode */
;;;2336     tmpsmcr |= sConfig->EncoderMode;
;;;2337   
;;;2338     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;2339     tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
;;;2340     tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
;;;2341     
;;;2342     /* Set the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
;;;2343     tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
;;;2344     tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
;;;2345     tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8U);
;;;2346     tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
;;;2347   
;;;2348     /* Set the TI1 and the TI2 Polarities */
;;;2349     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
;;;2350     tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
;;;2351     tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
;;;2352     
;;;2353     /* Write to TIMx SMCR */
;;;2354     htim->Instance->SMCR = tmpsmcr;
;;;2355   
;;;2356     /* Write to TIMx CCMR1 */
;;;2357     htim->Instance->CCMR1 = tmpccmr1;
;;;2358   
;;;2359     /* Write to TIMx CCER */
;;;2360     htim->Instance->CCER = tmpccer;
;;;2361     
;;;2362     /* Initialize the TIM state*/
;;;2363     htim->State= HAL_TIM_STATE_READY;
;;;2364     
;;;2365     return HAL_OK;
;;;2366   }
000006  4770              BXEQ     lr
000008  b570              PUSH     {r4-r6,lr}            ;2286
00000a  4604              MOV      r4,r0                 ;2286
00000c  6bc0              LDR      r0,[r0,#0x3c]         ;2309
00000e  460d              MOV      r5,r1                 ;2286
000010  b920              CBNZ     r0,|L21.28|
000012  2000              MOVS     r0,#0                 ;2312
000014  63a0              STR      r0,[r4,#0x38]         ;2314
000016  4620              MOV      r0,r4                 ;2314
000018  f7fffffe          BL       HAL_TIM_Encoder_MspInit
                  |L21.28|
00001c  2002              MOVS     r0,#2                 ;2318
00001e  63e0              STR      r0,[r4,#0x3c]         ;2318
000020  6820              LDR      r0,[r4,#0]            ;2321
000022  6881              LDR      r1,[r0,#8]            ;2321
000024  f0210107          BIC      r1,r1,#7              ;2321
000028  6081              STR      r1,[r0,#8]            ;2321
00002a  1d21              ADDS     r1,r4,#4              ;2324
00002c  6820              LDR      r0,[r4,#0]            ;2324
00002e  f7fffffe          BL       TIM_Base_SetConfig
000032  6820              LDR      r0,[r4,#0]            ;2327
000034  6883              LDR      r3,[r0,#8]            ;2327
000036  6982              LDR      r2,[r0,#0x18]         ;2330
000038  6a01              LDR      r1,[r0,#0x20]         ;2333
00003a  f8d5c000          LDR      r12,[r5,#0]           ;2336
00003e  f0220203          BIC      r2,r2,#3              ;2339
000042  69ae              LDR      r6,[r5,#0x18]         ;2340
000044  ea4c0303          ORR      r3,r12,r3             ;2336
000048  f4227240          BIC      r2,r2,#0x300          ;2339
00004c  ea422206          ORR      r2,r2,r6,LSL #8       ;2340
000050  f8d5c008          LDR      r12,[r5,#8]           ;2340
000054  69ee              LDR      r6,[r5,#0x1c]         ;2345
000056  ea4c0202          ORR      r2,r12,r2             ;2340
00005a  f02202fc          BIC      r2,r2,#0xfc           ;2344
00005e  f422427c          BIC      r2,r2,#0xfc00         ;2344
000062  f8d5c00c          LDR      r12,[r5,#0xc]         ;2345
000066  ea422206          ORR      r2,r2,r6,LSL #8       ;2345
00006a  ea4c0202          ORR      r2,r12,r2             ;2345
00006e  f8d5c010          LDR      r12,[r5,#0x10]        ;2346
000072  6a2e              LDR      r6,[r5,#0x20]         ;2346
000074  ea4f1c0c          LSL      r12,r12,#4            ;2346
000078  ea4c3c06          ORR      r12,r12,r6,LSL #12    ;2346
00007c  ea4c0202          ORR      r2,r12,r2             ;2346
000080  f8d5c004          LDR      r12,[r5,#4]           ;2351
000084  696d              LDR      r5,[r5,#0x14]         ;2351
000086  f02101aa          BIC      r1,r1,#0xaa           ;2350
00008a  ea411105          ORR      r1,r1,r5,LSL #4       ;2351
00008e  ea4c0101          ORR      r1,r12,r1             ;2351
000092  6083              STR      r3,[r0,#8]            ;2354
000094  6820              LDR      r0,[r4,#0]            ;2357
000096  6182              STR      r2,[r0,#0x18]         ;2357
000098  6820              LDR      r0,[r4,#0]            ;2360
00009a  6201              STR      r1,[r0,#0x20]         ;2360
00009c  2001              MOVS     r0,#1                 ;2363
00009e  63e0              STR      r0,[r4,#0x3c]         ;2363
0000a0  2000              MOVS     r0,#0                 ;2365
0000a2  bd70              POP      {r4-r6,pc}
;;;2367   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_MspDeInit PROC
;;;2416     */
;;;2417   __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2418   {
;;;2419     /* Prevent unused argument(s) compilation warning */
;;;2420     UNUSED(htim);
;;;2421     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2422               the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
;;;2423      */
;;;2424   }
;;;2425   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_MspInit PROC
;;;2401     */
;;;2402   __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2403   {
;;;2404     /* Prevent unused argument(s) compilation warning */
;;;2405     UNUSED(htim);
;;;2406     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2407               the HAL_TIM_Encoder_MspInit could be implemented in the user file
;;;2408      */
;;;2409   }
;;;2410   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Start PROC
;;;2436     */
;;;2437   HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
;;;2438   {
000002  b1c9              CBZ      r1,|L24.56|
;;;2439     /* Check the parameters */
;;;2440     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2441     
;;;2442     /* Enable the encoder interface channels */
;;;2443     switch (Channel)
000004  2904              CMP      r1,#4
000006  6a11              LDR      r1,[r2,#0x20]
000008  d01e              BEQ      |L24.72|
00000a  f0210101          BIC      r1,r1,#1
00000e  6211              STR      r1,[r2,#0x20]
000010  6a11              LDR      r1,[r2,#0x20]
000012  f0410101          ORR      r1,r1,#1
000016  6211              STR      r1,[r2,#0x20]
000018  6801              LDR      r1,[r0,#0]
00001a  6a0a              LDR      r2,[r1,#0x20]
00001c  f0220210          BIC      r2,r2,#0x10
000020  620a              STR      r2,[r1,#0x20]
000022  6a0a              LDR      r2,[r1,#0x20]
000024  f0420210          ORR      r2,r2,#0x10
000028  620a              STR      r2,[r1,#0x20]
                  |L24.42|
;;;2444     {
;;;2445       case TIM_CHANNEL_1:
;;;2446       {
;;;2447         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2448         break; 
;;;2449       }
;;;2450       case TIM_CHANNEL_2:
;;;2451       { 
;;;2452         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
;;;2453         break;
;;;2454       }  
;;;2455       default :
;;;2456       {
;;;2457        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2458        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2459        break; 
;;;2460       }
;;;2461     }  
;;;2462     /* Enable the Peripheral */
;;;2463     __HAL_TIM_ENABLE(htim);
00002a  6800              LDR      r0,[r0,#0]
00002c  6801              LDR      r1,[r0,#0]
00002e  f0410101          ORR      r1,r1,#1
000032  6001              STR      r1,[r0,#0]
;;;2464     
;;;2465     /* Return function status */
;;;2466     return HAL_OK;
000034  2000              MOVS     r0,#0
;;;2467   }
000036  4770              BX       lr
                  |L24.56|
000038  6a11              LDR      r1,[r2,#0x20]
00003a  f0210101          BIC      r1,r1,#1
00003e  6211              STR      r1,[r2,#0x20]
000040  6a11              LDR      r1,[r2,#0x20]
000042  f0410101          ORR      r1,r1,#1
000046  e005              B        |L24.84|
                  |L24.72|
000048  f0210110          BIC      r1,r1,#0x10           ;2448
00004c  6211              STR      r1,[r2,#0x20]         ;2448
00004e  6a11              LDR      r1,[r2,#0x20]         ;2448
000050  f0410110          ORR      r1,r1,#0x10           ;2448
                  |L24.84|
000054  6211              STR      r1,[r2,#0x20]         ;2448
000056  e7e8              B        |L24.42|
;;;2468   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Start_DMA PROC
;;;2627     */
;;;2628   HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1, uint32_t *pData2, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2629   {
000004  4604              MOV      r4,r0
;;;2630     /* Check the parameters */
;;;2631     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2632     
;;;2633     if((htim->State == HAL_TIM_STATE_BUSY))
000006  f8dd8018          LDR      r8,[sp,#0x18]
00000a  6bc0              LDR      r0,[r0,#0x3c]
00000c  461e              MOV      r6,r3                 ;2629
00000e  2802              CMP      r0,#2
;;;2634     {
;;;2635        return HAL_BUSY;
;;;2636     }
;;;2637     else if((htim->State == HAL_TIM_STATE_READY))
;;;2638     {
;;;2639       if((((pData1 == 0U) || (pData2 == 0U) )) && (Length > 0)) 
;;;2640       {
;;;2641         return HAL_ERROR;                                    
;;;2642       }
;;;2643       else
;;;2644       {
;;;2645         htim->State = HAL_TIM_STATE_BUSY;
;;;2646       }
;;;2647     }  
;;;2648      
;;;2649     switch (Channel)
;;;2650     {
;;;2651       case TIM_CHANNEL_1:
;;;2652       {
;;;2653         /* Set the DMA Period elapsed callback */
;;;2654         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2655        
;;;2656         /* Set the DMA error callback */
;;;2657         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;2658         
;;;2659         /* Enable the DMA Stream */
;;;2660         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t )pData1, Length); 
;;;2661         
;;;2662         /* Enable the TIM Input Capture DMA request */      
;;;2663         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;2664               
;;;2665         /* Enable the Peripheral */
;;;2666         __HAL_TIM_ENABLE(htim);
;;;2667         
;;;2668         /* Enable the Capture compare channel */
;;;2669         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2670       }
;;;2671       break;
;;;2672       
;;;2673       case TIM_CHANNEL_2:
;;;2674       {
;;;2675         /* Set the DMA Period elapsed callback */
;;;2676         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2677        
;;;2678         /* Set the DMA error callback */
;;;2679         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError;
;;;2680         /* Enable the DMA Stream */
;;;2681         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
;;;2682         
;;;2683         /* Enable the TIM Input Capture  DMA request */
;;;2684         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;2685        
;;;2686         /* Enable the Peripheral */
;;;2687         __HAL_TIM_ENABLE(htim);
;;;2688         
;;;2689         /* Enable the Capture compare channel */
;;;2690         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2691       }
;;;2692       break;
;;;2693       
;;;2694       case TIM_CHANNEL_ALL:
;;;2695       {
;;;2696         /* Set the DMA Period elapsed callback */
;;;2697         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2698        
;;;2699         /* Set the DMA error callback */
;;;2700         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;2701         
;;;2702         /* Enable the DMA Stream */
;;;2703         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length);
;;;2704         
;;;2705         /* Set the DMA Period elapsed callback */
;;;2706         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2707        
;;;2708         /* Set the DMA error callback */
;;;2709         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;2710         
;;;2711         /* Enable the DMA Stream */
;;;2712         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
;;;2713             
;;;2714        /* Enable the Peripheral */
;;;2715         __HAL_TIM_ENABLE(htim);
;;;2716         
;;;2717         /* Enable the Capture compare channel */
;;;2718         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2719         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2720         
;;;2721         /* Enable the TIM Input Capture  DMA request */
;;;2722         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;2723         /* Enable the TIM Input Capture  DMA request */
;;;2724         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;2725       }
;;;2726       break;
;;;2727       
;;;2728       default:
;;;2729       break;
;;;2730     }  
;;;2731     /* Return function status */
;;;2732     return HAL_OK;
;;;2733   }
000010  bf08              IT       EQ
000012  e8bd81f0          POPEQ    {r4-r8,pc}
000016  6be0              LDR      r0,[r4,#0x3c]         ;2637
000018  2801              CMP      r0,#1                 ;2637
00001a  d10b              BNE      |L25.52|
00001c  2a00              CMP      r2,#0                 ;2639
00001e  bf18              IT       NE                    ;2639
000020  2e00              CMPNE    r6,#0                 ;2639
000022  d105              BNE      |L25.48|
000024  f1b80f00          CMP      r8,#0                 ;2639
000028  bf1c              ITT      NE                    ;2641
00002a  2001              MOVNE    r0,#1                 ;2641
00002c  e8bd81f0          POPNE    {r4-r8,pc}
                  |L25.48|
000030  2002              MOVS     r0,#2                 ;2645
000032  63e0              STR      r0,[r4,#0x3c]         ;2645
                  |L25.52|
000034  4d40              LDR      r5,|L25.312|
000036  4f41              LDR      r7,|L25.316|
000038  b121              CBZ      r1,|L25.68|
00003a  2904              CMP      r1,#4                 ;2649
00003c  d020              BEQ      |L25.128|
00003e  2918              CMP      r1,#0x18              ;2649
000040  d03e              BEQ      |L25.192|
000042  e075              B        |L25.304|
                  |L25.68|
000044  6a20              LDR      r0,[r4,#0x20]         ;2654
000046  4643              MOV      r3,r8                 ;2660
000048  6405              STR      r5,[r0,#0x40]         ;2657
00004a  6a20              LDR      r0,[r4,#0x20]         ;2657
00004c  6507              STR      r7,[r0,#0x50]         ;2660
00004e  6820              LDR      r0,[r4,#0]            ;2660
000050  f1000134          ADD      r1,r0,#0x34           ;2660
000054  6a20              LDR      r0,[r4,#0x20]         ;2660
000056  f7fffffe          BL       HAL_DMA_Start_IT
00005a  6820              LDR      r0,[r4,#0]            ;2663
00005c  68c1              LDR      r1,[r0,#0xc]          ;2663
00005e  f4417100          ORR      r1,r1,#0x200          ;2663
000062  60c1              STR      r1,[r0,#0xc]          ;2663
000064  6820              LDR      r0,[r4,#0]            ;2666
000066  6801              LDR      r1,[r0,#0]            ;2666
000068  f0410101          ORR      r1,r1,#1              ;2666
00006c  6001              STR      r1,[r0,#0]            ;2666
00006e  6820              LDR      r0,[r4,#0]            ;2666
000070  6a01              LDR      r1,[r0,#0x20]         ;2666
000072  f0210101          BIC      r1,r1,#1              ;2666
000076  6201              STR      r1,[r0,#0x20]         ;2666
000078  6a01              LDR      r1,[r0,#0x20]         ;2666
00007a  f0410101          ORR      r1,r1,#1              ;2666
00007e  e01d              B        |L25.188|
                  |L25.128|
000080  6a60              LDR      r0,[r4,#0x24]         ;2676
000082  4643              MOV      r3,r8                 ;2681
000084  4632              MOV      r2,r6                 ;2681
000086  6405              STR      r5,[r0,#0x40]         ;2679
000088  6a60              LDR      r0,[r4,#0x24]         ;2679
00008a  6507              STR      r7,[r0,#0x50]         ;2681
00008c  6820              LDR      r0,[r4,#0]            ;2681
00008e  f1000138          ADD      r1,r0,#0x38           ;2681
000092  6a60              LDR      r0,[r4,#0x24]         ;2681
000094  f7fffffe          BL       HAL_DMA_Start_IT
000098  6820              LDR      r0,[r4,#0]            ;2684
00009a  68c1              LDR      r1,[r0,#0xc]          ;2684
00009c  f4416180          ORR      r1,r1,#0x400          ;2684
0000a0  60c1              STR      r1,[r0,#0xc]          ;2684
0000a2  6820              LDR      r0,[r4,#0]            ;2687
0000a4  6801              LDR      r1,[r0,#0]            ;2687
0000a6  f0410101          ORR      r1,r1,#1              ;2687
0000aa  6001              STR      r1,[r0,#0]            ;2687
0000ac  6820              LDR      r0,[r4,#0]            ;2687
0000ae  6a01              LDR      r1,[r0,#0x20]         ;2687
0000b0  f0210110          BIC      r1,r1,#0x10           ;2687
0000b4  6201              STR      r1,[r0,#0x20]         ;2687
0000b6  6a01              LDR      r1,[r0,#0x20]         ;2687
0000b8  f0410110          ORR      r1,r1,#0x10           ;2687
                  |L25.188|
0000bc  6201              STR      r1,[r0,#0x20]         ;2687
0000be  e037              B        |L25.304|
                  |L25.192|
0000c0  6a20              LDR      r0,[r4,#0x20]         ;2697
0000c2  4643              MOV      r3,r8                 ;2703
0000c4  6405              STR      r5,[r0,#0x40]         ;2700
0000c6  6a20              LDR      r0,[r4,#0x20]         ;2700
0000c8  6507              STR      r7,[r0,#0x50]         ;2703
0000ca  6820              LDR      r0,[r4,#0]            ;2703
0000cc  f1000134          ADD      r1,r0,#0x34           ;2703
0000d0  6a20              LDR      r0,[r4,#0x20]         ;2703
0000d2  f7fffffe          BL       HAL_DMA_Start_IT
0000d6  6a60              LDR      r0,[r4,#0x24]         ;2706
0000d8  4643              MOV      r3,r8                 ;2712
0000da  4632              MOV      r2,r6                 ;2712
0000dc  6405              STR      r5,[r0,#0x40]         ;2709
0000de  6a60              LDR      r0,[r4,#0x24]         ;2709
0000e0  6507              STR      r7,[r0,#0x50]         ;2712
0000e2  6820              LDR      r0,[r4,#0]            ;2712
0000e4  f1000138          ADD      r1,r0,#0x38           ;2712
0000e8  6a60              LDR      r0,[r4,#0x24]         ;2712
0000ea  f7fffffe          BL       HAL_DMA_Start_IT
0000ee  6820              LDR      r0,[r4,#0]            ;2715
0000f0  6801              LDR      r1,[r0,#0]            ;2715
0000f2  f0410101          ORR      r1,r1,#1              ;2715
0000f6  6001              STR      r1,[r0,#0]            ;2715
0000f8  6820              LDR      r0,[r4,#0]            ;2715
0000fa  6a01              LDR      r1,[r0,#0x20]         ;2715
0000fc  f0210101          BIC      r1,r1,#1              ;2715
000100  6201              STR      r1,[r0,#0x20]         ;2715
000102  6a01              LDR      r1,[r0,#0x20]         ;2715
000104  f0410101          ORR      r1,r1,#1              ;2715
000108  6201              STR      r1,[r0,#0x20]         ;2715
00010a  6820              LDR      r0,[r4,#0]            ;2715
00010c  6a01              LDR      r1,[r0,#0x20]         ;2715
00010e  f0210110          BIC      r1,r1,#0x10           ;2715
000112  6201              STR      r1,[r0,#0x20]         ;2715
000114  6a01              LDR      r1,[r0,#0x20]         ;2715
000116  f0410110          ORR      r1,r1,#0x10           ;2715
00011a  6201              STR      r1,[r0,#0x20]         ;2715
00011c  6820              LDR      r0,[r4,#0]            ;2722
00011e  68c1              LDR      r1,[r0,#0xc]          ;2722
000120  f4417100          ORR      r1,r1,#0x200          ;2722
000124  60c1              STR      r1,[r0,#0xc]          ;2722
000126  6820              LDR      r0,[r4,#0]            ;2724
000128  68c1              LDR      r1,[r0,#0xc]          ;2724
00012a  f4416180          ORR      r1,r1,#0x400          ;2724
00012e  60c1              STR      r1,[r0,#0xc]          ;2724
                  |L25.304|
000130  2000              MOVS     r0,#0                 ;2732
000132  e8bd81f0          POP      {r4-r8,pc}
;;;2734   
                          ENDP

000136  0000              DCW      0x0000
                  |L25.312|
                          DCD      TIM_DMACaptureCplt
                  |L25.316|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_Encoder_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Start_IT PROC
;;;2523     */
;;;2524   HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
;;;2525   {
000002  b319              CBZ      r1,|L26.76|
;;;2526     /* Check the parameters */
;;;2527     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2528     
;;;2529     /* Enable the encoder interface channels */
;;;2530     /* Enable the capture compare Interrupts 1 and/or 2 */
;;;2531     switch (Channel)
000004  2904              CMP      r1,#4
000006  6a11              LDR      r1,[r2,#0x20]
000008  d02d              BEQ      |L26.102|
00000a  f0210101          BIC      r1,r1,#1
00000e  6211              STR      r1,[r2,#0x20]
000010  6a11              LDR      r1,[r2,#0x20]
000012  f0410101          ORR      r1,r1,#1
000016  6211              STR      r1,[r2,#0x20]
000018  6801              LDR      r1,[r0,#0]
00001a  6a0a              LDR      r2,[r1,#0x20]
00001c  f0220210          BIC      r2,r2,#0x10
000020  620a              STR      r2,[r1,#0x20]
000022  6a0a              LDR      r2,[r1,#0x20]
000024  f0420210          ORR      r2,r2,#0x10
000028  620a              STR      r2,[r1,#0x20]
;;;2532     {
;;;2533       case TIM_CHANNEL_1:
;;;2534       {
;;;2535         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2536         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
;;;2537         break; 
;;;2538       }
;;;2539       case TIM_CHANNEL_2:
;;;2540       { 
;;;2541         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2542         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2); 
;;;2543         break;
;;;2544       }  
;;;2545       default :
;;;2546       {
;;;2547        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2548        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2549        __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
00002a  6801              LDR      r1,[r0,#0]
00002c  68ca              LDR      r2,[r1,#0xc]
00002e  f0420202          ORR      r2,r2,#2
000032  60ca              STR      r2,[r1,#0xc]
;;;2550        __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000034  6801              LDR      r1,[r0,#0]
000036  68ca              LDR      r2,[r1,#0xc]
000038  f0420204          ORR      r2,r2,#4
00003c  60ca              STR      r2,[r1,#0xc]
                  |L26.62|
;;;2551        break; 
;;;2552       }
;;;2553     }
;;;2554     
;;;2555     /* Enable the Peripheral */
;;;2556     __HAL_TIM_ENABLE(htim);
00003e  6800              LDR      r0,[r0,#0]
000040  6801              LDR      r1,[r0,#0]
000042  f0410101          ORR      r1,r1,#1
000046  6001              STR      r1,[r0,#0]
;;;2557     
;;;2558     /* Return function status */
;;;2559     return HAL_OK;
000048  2000              MOVS     r0,#0
;;;2560   }
00004a  4770              BX       lr
                  |L26.76|
00004c  6a11              LDR      r1,[r2,#0x20]
00004e  f0210101          BIC      r1,r1,#1
000052  6211              STR      r1,[r2,#0x20]
000054  6a11              LDR      r1,[r2,#0x20]
000056  f0410101          ORR      r1,r1,#1
00005a  6211              STR      r1,[r2,#0x20]
00005c  6801              LDR      r1,[r0,#0]            ;2536
00005e  68ca              LDR      r2,[r1,#0xc]          ;2536
000060  f0420202          ORR      r2,r2,#2              ;2536
000064  e00a              B        |L26.124|
                  |L26.102|
000066  f0210110          BIC      r1,r1,#0x10           ;2537
00006a  6211              STR      r1,[r2,#0x20]         ;2537
00006c  6a11              LDR      r1,[r2,#0x20]         ;2537
00006e  f0410110          ORR      r1,r1,#0x10           ;2537
000072  6211              STR      r1,[r2,#0x20]         ;2537
000074  6801              LDR      r1,[r0,#0]            ;2542
000076  68ca              LDR      r2,[r1,#0xc]          ;2542
000078  f0420204          ORR      r2,r2,#4              ;2542
                  |L26.124|
00007c  60ca              STR      r2,[r1,#0xc]          ;2536
00007e  e7de              B        |L26.62|
;;;2561   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Stop PROC
;;;2479     */
;;;2480   HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
;;;2481   {
000002  b1f1              CBZ      r1,|L27.66|
;;;2482     /* Check the parameters */
;;;2483       assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2484       
;;;2485      /* Disable the Input Capture channels 1 and 2
;;;2486       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
;;;2487     switch (Channel)
000004  2904              CMP      r1,#4
000006  6a11              LDR      r1,[r2,#0x20]
000008  d022              BEQ      |L27.80|
00000a  f0210101          BIC      r1,r1,#1
00000e  6211              STR      r1,[r2,#0x20]
000010  6a11              LDR      r1,[r2,#0x20]
000012  6211              STR      r1,[r2,#0x20]
000014  6801              LDR      r1,[r0,#0]
000016  6a0a              LDR      r2,[r1,#0x20]
000018  f0220210          BIC      r2,r2,#0x10
00001c  620a              STR      r2,[r1,#0x20]
00001e  6a0a              LDR      r2,[r1,#0x20]
000020  620a              STR      r2,[r1,#0x20]
                  |L27.34|
;;;2488     {
;;;2489       case TIM_CHANNEL_1:
;;;2490       {
;;;2491         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
;;;2492         break; 
;;;2493       }
;;;2494       case TIM_CHANNEL_2:
;;;2495       { 
;;;2496         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
;;;2497         break;
;;;2498       }  
;;;2499       default :
;;;2500       {
;;;2501        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
;;;2502        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
;;;2503        break; 
;;;2504       }
;;;2505     }  
;;;2506     /* Disable the Peripheral */
;;;2507     __HAL_TIM_DISABLE(htim);
000022  6800              LDR      r0,[r0,#0]
000024  6a01              LDR      r1,[r0,#0x20]
000026  f2411211          MOV      r2,#0x1111
00002a  4211              TST      r1,r2
00002c  d107              BNE      |L27.62|
00002e  6a01              LDR      r1,[r0,#0x20]
000030  1092              ASRS     r2,r2,#2
000032  4211              TST      r1,r2
000034  d103              BNE      |L27.62|
000036  6801              LDR      r1,[r0,#0]
000038  f0210101          BIC      r1,r1,#1
00003c  6001              STR      r1,[r0,#0]
                  |L27.62|
;;;2508     
;;;2509     /* Return function status */
;;;2510     return HAL_OK;
00003e  2000              MOVS     r0,#0
;;;2511   }
000040  4770              BX       lr
                  |L27.66|
000042  6a11              LDR      r1,[r2,#0x20]
000044  f0210101          BIC      r1,r1,#1
000048  6211              STR      r1,[r2,#0x20]
00004a  6a11              LDR      r1,[r2,#0x20]
00004c  6211              STR      r1,[r2,#0x20]
00004e  e7e8              B        |L27.34|
                  |L27.80|
000050  f0210110          BIC      r1,r1,#0x10           ;2492
000054  6211              STR      r1,[r2,#0x20]         ;2492
000056  6a11              LDR      r1,[r2,#0x20]         ;2492
000058  6211              STR      r1,[r2,#0x20]         ;2492
00005a  e7e2              B        |L27.34|
;;;2512   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Stop_DMA PROC
;;;2745     */
;;;2746   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
000002  2301              MOVS     r3,#1
;;;2747   {
000004  b361              CBZ      r1,|L28.96|
;;;2748     /* Check the parameters */
;;;2749     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2750     
;;;2751     /* Disable the Input Capture channels 1 and 2
;;;2752       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
;;;2753     if(Channel == TIM_CHANNEL_1)
;;;2754     {
;;;2755       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
;;;2756       
;;;2757       /* Disable the capture compare DMA Request 1 */
;;;2758       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
;;;2759     }  
;;;2760     else if(Channel == TIM_CHANNEL_2)
000006  2904              CMP      r1,#4
000008  6a11              LDR      r1,[r2,#0x20]
00000a  d034              BEQ      |L28.118|
00000c  f0210101          BIC      r1,r1,#1
000010  6211              STR      r1,[r2,#0x20]
000012  6a11              LDR      r1,[r2,#0x20]
000014  6211              STR      r1,[r2,#0x20]
000016  6801              LDR      r1,[r0,#0]
000018  6a0a              LDR      r2,[r1,#0x20]
00001a  f0220210          BIC      r2,r2,#0x10
00001e  620a              STR      r2,[r1,#0x20]
000020  6a0a              LDR      r2,[r1,#0x20]
000022  620a              STR      r2,[r1,#0x20]
;;;2761     {  
;;;2762       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
;;;2763       
;;;2764       /* Disable the capture compare DMA Request 2 */
;;;2765       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
;;;2766     }  
;;;2767     else
;;;2768     {
;;;2769       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
;;;2770       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
;;;2771       
;;;2772       /* Disable the capture compare DMA Request 1 and 2 */
;;;2773       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000024  6801              LDR      r1,[r0,#0]
000026  68ca              LDR      r2,[r1,#0xc]
000028  f4227200          BIC      r2,r2,#0x200
00002c  60ca              STR      r2,[r1,#0xc]
;;;2774       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00002e  6801              LDR      r1,[r0,#0]
000030  68ca              LDR      r2,[r1,#0xc]
000032  f4226280          BIC      r2,r2,#0x400
000036  60ca              STR      r2,[r1,#0xc]
                  |L28.56|
;;;2775     }
;;;2776     
;;;2777     /* Disable the Peripheral */
;;;2778     __HAL_TIM_DISABLE(htim);
000038  6801              LDR      r1,[r0,#0]
00003a  6a0a              LDR      r2,[r1,#0x20]
00003c  f2411c11          MOV      r12,#0x1111
000040  ea120f0c          TST      r2,r12
000044  d109              BNE      |L28.90|
000046  6a0a              LDR      r2,[r1,#0x20]
000048  f2404c44          MOV      r12,#0x444
00004c  ea120f0c          TST      r2,r12
000050  d103              BNE      |L28.90|
000052  680a              LDR      r2,[r1,#0]
000054  f0220201          BIC      r2,r2,#1
000058  600a              STR      r2,[r1,#0]
                  |L28.90|
;;;2779     
;;;2780     /* Change the htim state */
;;;2781     htim->State = HAL_TIM_STATE_READY;
00005a  63c3              STR      r3,[r0,#0x3c]
;;;2782     
;;;2783     /* Return function status */
;;;2784     return HAL_OK;
00005c  2000              MOVS     r0,#0
;;;2785   }
00005e  4770              BX       lr
                  |L28.96|
000060  6a11              LDR      r1,[r2,#0x20]
000062  f0210101          BIC      r1,r1,#1
000066  6211              STR      r1,[r2,#0x20]
000068  6a11              LDR      r1,[r2,#0x20]
00006a  6211              STR      r1,[r2,#0x20]
00006c  6801              LDR      r1,[r0,#0]            ;2758
00006e  68ca              LDR      r2,[r1,#0xc]          ;2758
000070  f4227200          BIC      r2,r2,#0x200          ;2758
000074  e008              B        |L28.136|
                  |L28.118|
000076  f0210110          BIC      r1,r1,#0x10           ;2758
00007a  6211              STR      r1,[r2,#0x20]         ;2758
00007c  6a11              LDR      r1,[r2,#0x20]         ;2758
00007e  6211              STR      r1,[r2,#0x20]         ;2758
000080  6801              LDR      r1,[r0,#0]            ;2765
000082  68ca              LDR      r2,[r1,#0xc]          ;2765
000084  f4226280          BIC      r2,r2,#0x400          ;2765
                  |L28.136|
000088  60ca              STR      r2,[r1,#0xc]          ;2765
00008a  e7d5              B        |L28.56|
;;;2786   /**
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Stop_IT PROC
;;;2572     */
;;;2573   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
000002  2301              MOVS     r3,#1
;;;2574   {
000004  b361              CBZ      r1,|L29.96|
;;;2575     /* Check the parameters */
;;;2576     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2577       
;;;2578     /* Disable the Input Capture channels 1 and 2
;;;2579       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
;;;2580     if(Channel == TIM_CHANNEL_1)
;;;2581     {
;;;2582       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
;;;2583       
;;;2584       /* Disable the capture compare Interrupts 1 */
;;;2585     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
;;;2586     }  
;;;2587     else if(Channel == TIM_CHANNEL_2)
000006  2904              CMP      r1,#4
000008  6a11              LDR      r1,[r2,#0x20]
00000a  d034              BEQ      |L29.118|
00000c  f0210101          BIC      r1,r1,#1
000010  6211              STR      r1,[r2,#0x20]
000012  6a11              LDR      r1,[r2,#0x20]
000014  6211              STR      r1,[r2,#0x20]
000016  6801              LDR      r1,[r0,#0]
000018  6a0a              LDR      r2,[r1,#0x20]
00001a  f0220210          BIC      r2,r2,#0x10
00001e  620a              STR      r2,[r1,#0x20]
000020  6a0a              LDR      r2,[r1,#0x20]
000022  620a              STR      r2,[r1,#0x20]
;;;2588     {  
;;;2589       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
;;;2590       
;;;2591       /* Disable the capture compare Interrupts 2 */
;;;2592     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
;;;2593     }  
;;;2594     else
;;;2595     {
;;;2596       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
;;;2597       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
;;;2598       
;;;2599       /* Disable the capture compare Interrupts 1 and 2 */
;;;2600       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000024  6801              LDR      r1,[r0,#0]
000026  68ca              LDR      r2,[r1,#0xc]
000028  f0220202          BIC      r2,r2,#2
00002c  60ca              STR      r2,[r1,#0xc]
;;;2601       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00002e  6801              LDR      r1,[r0,#0]
000030  68ca              LDR      r2,[r1,#0xc]
000032  f0220204          BIC      r2,r2,#4
000036  60ca              STR      r2,[r1,#0xc]
                  |L29.56|
;;;2602     }
;;;2603       
;;;2604     /* Disable the Peripheral */
;;;2605     __HAL_TIM_DISABLE(htim);
000038  6801              LDR      r1,[r0,#0]
00003a  6a0a              LDR      r2,[r1,#0x20]
00003c  f2411c11          MOV      r12,#0x1111
000040  ea120f0c          TST      r2,r12
000044  d109              BNE      |L29.90|
000046  6a0a              LDR      r2,[r1,#0x20]
000048  f2404c44          MOV      r12,#0x444
00004c  ea120f0c          TST      r2,r12
000050  d103              BNE      |L29.90|
000052  680a              LDR      r2,[r1,#0]
000054  f0220201          BIC      r2,r2,#1
000058  600a              STR      r2,[r1,#0]
                  |L29.90|
;;;2606     
;;;2607     /* Change the htim state */
;;;2608     htim->State = HAL_TIM_STATE_READY;
00005a  63c3              STR      r3,[r0,#0x3c]
;;;2609     
;;;2610     /* Return function status */
;;;2611     return HAL_OK;
00005c  2000              MOVS     r0,#0
;;;2612   }
00005e  4770              BX       lr
                  |L29.96|
000060  6a11              LDR      r1,[r2,#0x20]
000062  f0210101          BIC      r1,r1,#1
000066  6211              STR      r1,[r2,#0x20]
000068  6a11              LDR      r1,[r2,#0x20]
00006a  6211              STR      r1,[r2,#0x20]
00006c  6801              LDR      r1,[r0,#0]            ;2585
00006e  68ca              LDR      r2,[r1,#0xc]          ;2585
000070  f0220202          BIC      r2,r2,#2              ;2585
000074  e008              B        |L29.136|
                  |L29.118|
000076  f0210110          BIC      r1,r1,#0x10           ;2585
00007a  6211              STR      r1,[r2,#0x20]         ;2585
00007c  6a11              LDR      r1,[r2,#0x20]         ;2585
00007e  6211              STR      r1,[r2,#0x20]         ;2585
000080  6801              LDR      r1,[r0,#0]            ;2592
000082  68ca              LDR      r2,[r1,#0xc]          ;2592
000084  f0220204          BIC      r2,r2,#4              ;2592
                  |L29.136|
000088  60ca              STR      r2,[r1,#0xc]          ;2592
00008a  e7d5              B        |L29.56|
;;;2613   
                          ENDP


                          AREA ||i.HAL_TIM_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ErrorCallback PROC
;;;4378     */
;;;4379   __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4380   {
;;;4381     /* Prevent unused argument(s) compilation warning */
;;;4382     UNUSED(htim);
;;;4383     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4384               the HAL_TIM_ErrorCallback could be implemented in the user file
;;;4385      */
;;;4386   }
;;;4387   /**
                          ENDP


                          AREA ||i.HAL_TIM_GenerateEvent||, CODE, READONLY, ALIGN=1

                  HAL_TIM_GenerateEvent PROC
;;;3807   
;;;3808   HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
000000  6b82              LDR      r2,[r0,#0x38]
;;;3809   {
;;;3810     /* Check the parameters */
;;;3811     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;3812     assert_param(IS_TIM_EVENT_SOURCE(EventSource));
;;;3813     
;;;3814     /* Process Locked */
;;;3815     __HAL_LOCK(htim);
000002  2a01              CMP      r2,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;3816     
;;;3817     /* Change the TIM state */
;;;3818     htim->State = HAL_TIM_STATE_BUSY;
;;;3819     
;;;3820     /* Set the event sources */
;;;3821     htim->Instance->EGR = EventSource;
;;;3822     
;;;3823     /* Change the TIM state */
;;;3824     htim->State = HAL_TIM_STATE_READY;
;;;3825     
;;;3826     __HAL_UNLOCK(htim);
;;;3827     
;;;3828     /* Return function status */
;;;3829     return HAL_OK;  
;;;3830   }
000008  4770              BXEQ     lr
00000a  2201              MOVS     r2,#1                 ;3815
00000c  2302              MOVS     r3,#2                 ;3818
00000e  63c3              STR      r3,[r0,#0x3c]         ;3818
000010  6803              LDR      r3,[r0,#0]            ;3821
000012  6159              STR      r1,[r3,#0x14]         ;3821
000014  63c2              STR      r2,[r0,#0x3c]         ;3824
000016  2100              MOVS     r1,#0                 ;3826
000018  6381              STR      r1,[r0,#0x38]         ;3829
00001a  4608              MOV      r0,r1                 ;3829
00001c  4770              BX       lr
;;;3831   
                          ENDP


                          AREA ||i.HAL_TIM_IC_CaptureCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_CaptureCallback PROC
;;;4333     */
;;;4334   __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4335   {
;;;4336     /* Prevent unused argument(s) compilation warning */
;;;4337     UNUSED(htim);
;;;4338     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4339               the __HAL_TIM_IC_CaptureCallback could be implemented in the user file
;;;4340      */
;;;4341   }
;;;4342   
                          ENDP


                          AREA ||i.HAL_TIM_IC_ConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_TIM_IC_ConfigChannel PROC
;;;3041     */
;;;3042   HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef* sConfig, uint32_t Channel)
000000  6b83              LDR      r3,[r0,#0x38]
;;;3043   {
;;;3044     /* Check the parameters */
;;;3045     assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3046     assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
;;;3047     assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
;;;3048     assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
;;;3049     assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
;;;3050     
;;;3051     __HAL_LOCK(htim);
000002  2b01              CMP      r3,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;3052     
;;;3053     htim->State = HAL_TIM_STATE_BUSY;
;;;3054     
;;;3055     if (Channel == TIM_CHANNEL_1)
;;;3056     {
;;;3057       /* TI1 Configuration */
;;;3058       TIM_TI1_SetConfig(htim->Instance,
;;;3059                  sConfig->ICPolarity,
;;;3060                  sConfig->ICSelection,
;;;3061                  sConfig->ICFilter);
;;;3062                  
;;;3063       /* Reset the IC1PSC Bits */
;;;3064       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;3065   
;;;3066       /* Set the IC1PSC value */
;;;3067       htim->Instance->CCMR1 |= sConfig->ICPrescaler;
;;;3068     }
;;;3069     else if (Channel == TIM_CHANNEL_2)
;;;3070     {
;;;3071       /* TI2 Configuration */
;;;3072       assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3073       
;;;3074       TIM_TI2_SetConfig(htim->Instance, 
;;;3075                         sConfig->ICPolarity,
;;;3076                         sConfig->ICSelection,
;;;3077                         sConfig->ICFilter);
;;;3078                  
;;;3079       /* Reset the IC2PSC Bits */
;;;3080       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;3081   
;;;3082       /* Set the IC2PSC value */
;;;3083       htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8U);
;;;3084     }
;;;3085     else if (Channel == TIM_CHANNEL_3)
;;;3086     {
;;;3087       /* TI3 Configuration */
;;;3088       assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3089       
;;;3090       TIM_TI3_SetConfig(htim->Instance,  
;;;3091                  sConfig->ICPolarity,
;;;3092                  sConfig->ICSelection,
;;;3093                  sConfig->ICFilter);
;;;3094                  
;;;3095       /* Reset the IC3PSC Bits */
;;;3096       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
;;;3097   
;;;3098       /* Set the IC3PSC value */
;;;3099       htim->Instance->CCMR2 |= sConfig->ICPrescaler;
;;;3100     }
;;;3101     else
;;;3102     {
;;;3103       /* TI4 Configuration */
;;;3104       assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3105       
;;;3106       TIM_TI4_SetConfig(htim->Instance, 
;;;3107                  sConfig->ICPolarity,
;;;3108                  sConfig->ICSelection,
;;;3109                  sConfig->ICFilter);
;;;3110                  
;;;3111       /* Reset the IC4PSC Bits */
;;;3112       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
;;;3113   
;;;3114       /* Set the IC4PSC value */
;;;3115       htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);
;;;3116     }
;;;3117     
;;;3118     htim->State = HAL_TIM_STATE_READY;
;;;3119       
;;;3120     __HAL_UNLOCK(htim);
;;;3121     
;;;3122     return HAL_OK; 
;;;3123   }
000008  4770              BXEQ     lr
00000a  e92d03f0          PUSH     {r4-r9}               ;3043
00000e  f04f0c01          MOV      r12,#1                ;3051
000012  2302              MOVS     r3,#2                 ;3053
000014  f8c0c038          STR      r12,[r0,#0x38]        ;3053
000018  63c3              STR      r3,[r0,#0x3c]         ;3053
00001a  24f0              MOVS     r4,#0xf0              ;3053
00001c  2a00              CMP      r2,#0                 ;3055
00001e  d035              BEQ      |L33.140|
000020  0223              LSLS     r3,r4,#8              ;3051
000022  2a04              CMP      r2,#4                 ;3069
000024  d07e              BEQ      |L33.292|
000026  2a08              CMP      r2,#8                 ;3085
000028  6802              LDR      r2,[r0,#0]            ;3085
00002a  d07c              BEQ      |L33.294|
00002c  e9d16500          LDRD     r6,r5,[r1,#0]         ;3106
000030  68cc              LDR      r4,[r1,#0xc]          ;3106
000032  6a17              LDR      r7,[r2,#0x20]         ;3106
000034  f4275780          BIC      r7,r7,#0x1000         ;3106
000038  6217              STR      r7,[r2,#0x20]         ;3106
00003a  69d7              LDR      r7,[r2,#0x1c]         ;3106
00003c  f8d28020          LDR      r8,[r2,#0x20]         ;3106
000040  f4277740          BIC      r7,r7,#0x300          ;3106
000044  ea472505          ORR      r5,r7,r5,LSL #8       ;3106
000048  ea033304          AND      r3,r3,r4,LSL #12      ;3106
00004c  f4254570          BIC      r5,r5,#0xf000         ;3106
000050  432b              ORRS     r3,r3,r5              ;3106
000052  f44f4520          MOV      r5,#0xa000            ;3106
000056  f4284420          BIC      r4,r8,#0xa000         ;3106
00005a  ea053506          AND      r5,r5,r6,LSL #12      ;3106
00005e  432c              ORRS     r4,r4,r5              ;3106
000060  61d3              STR      r3,[r2,#0x1c]         ;3106
000062  6214              STR      r4,[r2,#0x20]         ;3106
000064  6802              LDR      r2,[r0,#0]            ;3112
000066  69d3              LDR      r3,[r2,#0x1c]         ;3112
000068  f4236340          BIC      r3,r3,#0xc00          ;3112
00006c  61d3              STR      r3,[r2,#0x1c]         ;3112
00006e  6802              LDR      r2,[r0,#0]            ;3115
000070  69d3              LDR      r3,[r2,#0x1c]         ;3115
000072  6889              LDR      r1,[r1,#8]            ;3115
000074  ea432101          ORR      r1,r3,r1,LSL #8       ;3115
                  |L33.120|
000078  f8c2101c          STR.W    r1,[r2,#0x1c]         ;3099
                  |L33.124|
00007c  f8c0c03c          STR      r12,[r0,#0x3c]        ;3118
000080  2100              MOVS     r1,#0                 ;3120
000082  6381              STR      r1,[r0,#0x38]         ;3122
000084  e8bd03f0          POP      {r4-r9}
000088  4608              MOV      r0,r1                 ;3122
00008a  4770              BX       lr
                  |L33.140|
00008c  6802              LDR      r2,[r0,#0]            ;3058
00008e  e9d16800          LDRD     r6,r8,[r1,#0]         ;3058
000092  68cd              LDR      r5,[r1,#0xc]          ;3058
000094  6a13              LDR      r3,[r2,#0x20]         ;3058
000096  f0230301          BIC      r3,r3,#1              ;3058
00009a  6213              STR      r3,[r2,#0x20]         ;3058
00009c  6993              LDR      r3,[r2,#0x18]         ;3058
00009e  6a17              LDR      r7,[r2,#0x20]         ;3058
0000a0  f1a24980          SUB      r9,r2,#0x40000000     ;3058
0000a4  f5b93980          SUBS     r9,r9,#0x10000        ;3058
0000a8  bf18              IT       NE                    ;3058
0000aa  f1b24f80          CMPNE    r2,#0x40000000        ;3058
0000ae  d021              BEQ      |L33.244|
0000b0  f1a24980          SUB      r9,r2,#0x40000000     ;3058
0000b4  f5b96980          SUBS     r9,r9,#0x400          ;3058
0000b8  bf1c              ITT      NE                    ;3058
0000ba  f1a24980          SUBNE    r9,r2,#0x40000000     ;3058
0000be  f5b96900          SUBSNE   r9,r9,#0x800          ;3058
0000c2  d017              BEQ      |L33.244|
0000c4  f1a24980          SUB      r9,r2,#0x40000000     ;3058
0000c8  f5b96940          SUBS     r9,r9,#0xc00          ;3058
0000cc  bf1c              ITT      NE                    ;3058
0000ce  f1a24980          SUBNE    r9,r2,#0x40000000     ;3058
0000d2  f5b93982          SUBSNE   r9,r9,#0x10400        ;3058
0000d6  d00d              BEQ      |L33.244|
0000d8  f1a24980          SUB      r9,r2,#0x40000000     ;3058
0000dc  f5b939a0          SUBS     r9,r9,#0x14000        ;3058
0000e0  bf1f              ITTTT    NE                    ;3058
0000e2  f1a24980          SUBNE    r9,r2,#0x40000000     ;3058
0000e6  f5b959c0          SUBSNE   r9,r9,#0x1800         ;3058
0000ea  f0230303          BICNE    r3,r3,#3              ;3058
0000ee  f0430301          ORRNE    r3,r3,#1              ;3058
0000f2  d103              BNE      |L33.252|
                  |L33.244|
0000f4  f0230303          BIC      r3,r3,#3              ;3058
0000f8  ea430308          ORR      r3,r3,r8              ;3058
                  |L33.252|
0000fc  ea041405          AND      r4,r4,r5,LSL #4       ;3058
000100  f02303f0          BIC      r3,r3,#0xf0           ;3058
000104  4323              ORRS     r3,r3,r4              ;3058
000106  f027040a          BIC      r4,r7,#0xa            ;3058
00010a  f006050a          AND      r5,r6,#0xa            ;3058
00010e  432c              ORRS     r4,r4,r5              ;3058
000110  6193              STR      r3,[r2,#0x18]         ;3058
000112  6214              STR      r4,[r2,#0x20]         ;3058
000114  6802              LDR      r2,[r0,#0]            ;3064
000116  6993              LDR      r3,[r2,#0x18]         ;3064
000118  f023030c          BIC      r3,r3,#0xc            ;3064
00011c  6193              STR      r3,[r2,#0x18]         ;3064
00011e  6802              LDR      r2,[r0,#0]            ;3067
000120  6993              LDR      r3,[r2,#0x18]         ;3067
000122  e001              B        |L33.296|
                  |L33.292|
000124  e003              B        |L33.302|
                  |L33.294|
000126  e02a              B        |L33.382|
                  |L33.296|
000128  6889              LDR      r1,[r1,#8]            ;3067
00012a  4319              ORRS     r1,r1,r3              ;3067
00012c  e025              B        |L33.378|
                  |L33.302|
00012e  6802              LDR      r2,[r0,#0]            ;3074
000130  e9d14600          LDRD     r4,r6,[r1,#0]         ;3074
000134  68cd              LDR      r5,[r1,#0xc]          ;3074
000136  6a17              LDR      r7,[r2,#0x20]         ;3074
000138  f0270710          BIC      r7,r7,#0x10           ;3074
00013c  6217              STR      r7,[r2,#0x20]         ;3074
00013e  6997              LDR      r7,[r2,#0x18]         ;3074
000140  f8d28020          LDR      r8,[r2,#0x20]         ;3074
000144  f4277740          BIC      r7,r7,#0x300          ;3074
000148  ea472606          ORR      r6,r7,r6,LSL #8       ;3074
00014c  ea033305          AND      r3,r3,r5,LSL #12      ;3074
000150  f4264670          BIC      r6,r6,#0xf000         ;3074
000154  4333              ORRS     r3,r3,r6              ;3074
000156  26a0              MOVS     r6,#0xa0              ;3074
000158  f02805a0          BIC      r5,r8,#0xa0           ;3074
00015c  ea061404          AND      r4,r6,r4,LSL #4       ;3074
000160  432c              ORRS     r4,r4,r5              ;3074
000162  6193              STR      r3,[r2,#0x18]         ;3074
000164  6214              STR      r4,[r2,#0x20]         ;3074
000166  6802              LDR      r2,[r0,#0]            ;3080
000168  6993              LDR      r3,[r2,#0x18]         ;3080
00016a  f4236340          BIC      r3,r3,#0xc00          ;3080
00016e  6193              STR      r3,[r2,#0x18]         ;3080
000170  6802              LDR      r2,[r0,#0]            ;3083
000172  6993              LDR      r3,[r2,#0x18]         ;3083
000174  6889              LDR      r1,[r1,#8]            ;3083
000176  ea432101          ORR      r1,r3,r1,LSL #8       ;3083
                  |L33.378|
00017a  6191              STR      r1,[r2,#0x18]         ;3083
00017c  e77e              B        |L33.124|
                  |L33.382|
00017e  e9d16300          LDRD     r6,r3,[r1,#0]         ;3090
000182  68cd              LDR      r5,[r1,#0xc]          ;3090
000184  6a17              LDR      r7,[r2,#0x20]         ;3090
000186  f4277780          BIC      r7,r7,#0x100          ;3090
00018a  6217              STR      r7,[r2,#0x20]         ;3090
00018c  69d7              LDR      r7,[r2,#0x1c]         ;3090
00018e  f8d28020          LDR      r8,[r2,#0x20]         ;3090
000192  f0270703          BIC      r7,r7,#3              ;3090
000196  ea041405          AND      r4,r4,r5,LSL #4       ;3090
00019a  433b              ORRS     r3,r3,r7              ;3090
00019c  f02303f0          BIC      r3,r3,#0xf0           ;3090
0001a0  4323              ORRS     r3,r3,r4              ;3090
0001a2  f44f6520          MOV      r5,#0xa00             ;3090
0001a6  f4286420          BIC      r4,r8,#0xa00          ;3090
0001aa  ea052506          AND      r5,r5,r6,LSL #8       ;3090
0001ae  432c              ORRS     r4,r4,r5              ;3090
0001b0  61d3              STR      r3,[r2,#0x1c]         ;3090
0001b2  6214              STR      r4,[r2,#0x20]         ;3090
0001b4  6802              LDR      r2,[r0,#0]            ;3096
0001b6  69d3              LDR      r3,[r2,#0x1c]         ;3096
0001b8  f023030c          BIC      r3,r3,#0xc            ;3096
0001bc  61d3              STR      r3,[r2,#0x1c]         ;3096
0001be  6802              LDR      r2,[r0,#0]            ;3099
0001c0  69d3              LDR      r3,[r2,#0x1c]         ;3099
0001c2  6889              LDR      r1,[r1,#8]            ;3099
0001c4  4319              ORRS     r1,r1,r3              ;3099
0001c6  e757              B        |L33.120|
;;;3124   
                          ENDP


                          AREA ||i.HAL_TIM_IC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_DeInit PROC
;;;1553     */
;;;1554   HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1555   {
000002  4604              MOV      r4,r0
;;;1556     /* Check the parameters */
;;;1557     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1558   
;;;1559     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  63e0              STR      r0,[r4,#0x3c]
;;;1560     
;;;1561     /* Disable the TIM Peripheral Clock */
;;;1562     __HAL_TIM_DISABLE(htim);
000008  6820              LDR      r0,[r4,#0]
00000a  6a01              LDR      r1,[r0,#0x20]
00000c  f2411211          MOV      r2,#0x1111
000010  4211              TST      r1,r2
000012  d107              BNE      |L34.36|
000014  6a01              LDR      r1,[r0,#0x20]
000016  1092              ASRS     r2,r2,#2
000018  4211              TST      r1,r2
00001a  d103              BNE      |L34.36|
00001c  6801              LDR      r1,[r0,#0]
00001e  f0210101          BIC      r1,r1,#1
000022  6001              STR      r1,[r0,#0]
                  |L34.36|
;;;1563       
;;;1564     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;1565     HAL_TIM_IC_MspDeInit(htim);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       HAL_TIM_IC_MspDeInit
;;;1566       
;;;1567     /* Change TIM state */  
;;;1568     htim->State = HAL_TIM_STATE_RESET;
00002a  2000              MOVS     r0,#0
00002c  63e0              STR      r0,[r4,#0x3c]
;;;1569   
;;;1570     /* Release Lock */
;;;1571     __HAL_UNLOCK(htim);
00002e  63a0              STR      r0,[r4,#0x38]
;;;1572   
;;;1573     return HAL_OK;
;;;1574   }
000030  bd10              POP      {r4,pc}
;;;1575   
                          ENDP


                          AREA ||i.HAL_TIM_IC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_GetState PROC
;;;4444     */
;;;4445   HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
000000  6bc0              LDR      r0,[r0,#0x3c]
;;;4446   {
;;;4447     return htim->State;
;;;4448   }
000002  4770              BX       lr
;;;4449   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Init PROC
;;;1514     */
;;;1515   HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
000000  2800              CMP      r0,#0
;;;1516   {
;;;1517     /* Check the TIM handle allocation */
;;;1518     if(htim == NULL)
;;;1519     {
;;;1520       return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;1521     }
;;;1522   
;;;1523     /* Check the parameters */
;;;1524     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1525     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1526     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision)); 
;;;1527   
;;;1528     if(htim->State == HAL_TIM_STATE_RESET)
;;;1529     { 
;;;1530       /* Allocate lock resource and initialize it */
;;;1531       htim->Lock = HAL_UNLOCKED;
;;;1532       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1533       HAL_TIM_IC_MspInit(htim);
;;;1534     }
;;;1535     
;;;1536     /* Set the TIM state */
;;;1537     htim->State= HAL_TIM_STATE_BUSY;   
;;;1538     
;;;1539     /* Init the base time for the input capture */  
;;;1540     TIM_Base_SetConfig(htim->Instance, &htim->Init); 
;;;1541      
;;;1542     /* Initialize the TIM state*/
;;;1543     htim->State= HAL_TIM_STATE_READY;
;;;1544     
;;;1545     return HAL_OK;
;;;1546   }
000006  4770              BXEQ     lr
000008  b510              PUSH     {r4,lr}               ;1516
00000a  4604              MOV      r4,r0                 ;1516
00000c  6bc0              LDR      r0,[r0,#0x3c]         ;1528
00000e  b920              CBNZ     r0,|L36.26|
000010  2000              MOVS     r0,#0                 ;1531
000012  63a0              STR      r0,[r4,#0x38]         ;1533
000014  4620              MOV      r0,r4                 ;1533
000016  f7fffffe          BL       HAL_TIM_IC_MspInit
                  |L36.26|
00001a  2002              MOVS     r0,#2                 ;1537
00001c  63e0              STR      r0,[r4,#0x3c]         ;1537
00001e  1d21              ADDS     r1,r4,#4              ;1540
000020  6820              LDR      r0,[r4,#0]            ;1540
000022  f7fffffe          BL       TIM_Base_SetConfig
000026  2001              MOVS     r0,#1                 ;1543
000028  63e0              STR      r0,[r4,#0x3c]         ;1543
00002a  2000              MOVS     r0,#0                 ;1545
00002c  bd10              POP      {r4,pc}
;;;1547   
                          ENDP


                          AREA ||i.HAL_TIM_IC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_MspDeInit PROC
;;;1596     */
;;;1597   __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1598   {
;;;1599     /* Prevent unused argument(s) compilation warning */
;;;1600     UNUSED(htim);
;;;1601     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1602               the HAL_TIM_IC_MspDeInit could be implemented in the user file
;;;1603      */
;;;1604   }
;;;1605   
                          ENDP


                          AREA ||i.HAL_TIM_IC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_MspInit PROC
;;;1581     */
;;;1582   __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1583   {
;;;1584     /* Prevent unused argument(s) compilation warning */
;;;1585     UNUSED(htim);
;;;1586     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1587               the HAL_TIM_IC_MspInit could be implemented in the user file
;;;1588      */
;;;1589   }
;;;1590   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Start PROC
;;;1617     */
;;;1618   HAL_StatusTypeDef HAL_TIM_IC_Start (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
000002  2301              MOVS     r3,#1
000004  fa03f101          LSL      r1,r3,r1
000008  6a13              LDR      r3,[r2,#0x20]
00000a  438b              BICS     r3,r3,r1
00000c  6213              STR      r3,[r2,#0x20]
00000e  6a13              LDR      r3,[r2,#0x20]
000010  4319              ORRS     r1,r1,r3
000012  6211              STR      r1,[r2,#0x20]
;;;1619   {
;;;1620     /* Check the parameters */
;;;1621     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1622     
;;;1623     /* Enable the Input Capture channel */
;;;1624     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1625       
;;;1626     /* Enable the Peripheral */
;;;1627     __HAL_TIM_ENABLE(htim);  
000014  6800              LDR      r0,[r0,#0]
000016  6801              LDR      r1,[r0,#0]
000018  f0410101          ORR      r1,r1,#1
00001c  6001              STR      r1,[r0,#0]
;;;1628   
;;;1629     /* Return function status */
;;;1630     return HAL_OK;  
00001e  2000              MOVS     r0,#0
;;;1631   } 
000020  4770              BX       lr
;;;1632   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_IC_Start_DMA PROC
;;;1794     */
;;;1795   HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;1796   {
000002  4604              MOV      r4,r0
;;;1797     /* Check the parameters */
;;;1798     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1799     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;1800     
;;;1801     if((htim->State == HAL_TIM_STATE_BUSY))
000004  6bc0              LDR      r0,[r0,#0x3c]
000006  460d              MOV      r5,r1                 ;1796
000008  2802              CMP      r0,#2
;;;1802     {
;;;1803        return HAL_BUSY;
;;;1804     }
;;;1805     else if((htim->State == HAL_TIM_STATE_READY))
;;;1806     {
;;;1807       if((pData == 0U) && (Length > 0)) 
;;;1808       {
;;;1809         return HAL_ERROR;                                    
;;;1810       }
;;;1811       else
;;;1812       {
;;;1813         htim->State = HAL_TIM_STATE_BUSY;
;;;1814       }
;;;1815     }  
;;;1816      
;;;1817     switch (Channel)
;;;1818     {
;;;1819       case TIM_CHANNEL_1:
;;;1820       {
;;;1821         /* Set the DMA Period elapsed callback */
;;;1822         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1823        
;;;1824         /* Set the DMA error callback */
;;;1825         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;1826         
;;;1827         /* Enable the DMA Stream */
;;;1828         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length); 
;;;1829         
;;;1830         /* Enable the TIM Capture/Compare 1 DMA request */      
;;;1831         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1832       }
;;;1833       break;
;;;1834       
;;;1835       case TIM_CHANNEL_2:
;;;1836       {
;;;1837         /* Set the DMA Period elapsed callback */
;;;1838         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1839        
;;;1840         /* Set the DMA error callback */
;;;1841         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;1842         
;;;1843         /* Enable the DMA Stream */
;;;1844         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length);
;;;1845         
;;;1846         /* Enable the TIM Capture/Compare 2  DMA request */
;;;1847         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1848       }
;;;1849       break;
;;;1850       
;;;1851       case TIM_CHANNEL_3:
;;;1852       {
;;;1853         /* Set the DMA Period elapsed callback */
;;;1854         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1855        
;;;1856         /* Set the DMA error callback */
;;;1857         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;1858         
;;;1859         /* Enable the DMA Stream */
;;;1860         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length);
;;;1861         
;;;1862         /* Enable the TIM Capture/Compare 3  DMA request */
;;;1863         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1864       }
;;;1865       break;
;;;1866       
;;;1867       case TIM_CHANNEL_4:
;;;1868       {
;;;1869         /* Set the DMA Period elapsed callback */
;;;1870         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1871        
;;;1872         /* Set the DMA error callback */
;;;1873         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;1874         
;;;1875         /* Enable the DMA Stream */
;;;1876         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length);
;;;1877         
;;;1878         /* Enable the TIM Capture/Compare 4  DMA request */
;;;1879         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1880       }
;;;1881       break;
;;;1882       
;;;1883       default:
;;;1884       break;
;;;1885     }
;;;1886   
;;;1887     /* Enable the Input Capture channel */
;;;1888     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1889      
;;;1890     /* Enable the Peripheral */
;;;1891     __HAL_TIM_ENABLE(htim); 
;;;1892     
;;;1893     /* Return function status */
;;;1894     return HAL_OK;
;;;1895   }
00000a  bf08              IT       EQ
00000c  bd70              POPEQ    {r4-r6,pc}
00000e  6be0              LDR      r0,[r4,#0x3c]         ;1805
000010  2801              CMP      r0,#1                 ;1805
000012  d106              BNE      |L40.34|
000014  b91a              CBNZ     r2,|L40.30|
000016  2b00              CMP      r3,#0                 ;1807
000018  bf1c              ITT      NE                    ;1809
00001a  2001              MOVNE    r0,#1                 ;1809
00001c  bd70              POPNE    {r4-r6,pc}
                  |L40.30|
00001e  2002              MOVS     r0,#2                 ;1813
000020  63e0              STR      r0,[r4,#0x3c]         ;1813
                  |L40.34|
000022  482f              LDR      r0,|L40.224|
000024  492f              LDR      r1,|L40.228|
000026  b135              CBZ      r5,|L40.54|
000028  2d04              CMP      r5,#4                 ;1817
00002a  d015              BEQ      |L40.88|
00002c  2d08              CMP      r5,#8                 ;1817
00002e  d024              BEQ      |L40.122|
000030  2d0c              CMP      r5,#0xc               ;1817
000032  d033              BEQ      |L40.156|
000034  e043              B        |L40.190|
                  |L40.54|
000036  f8d4c020          LDR      r12,[r4,#0x20]        ;1822
00003a  f8cc0040          STR      r0,[r12,#0x40]        ;1825
00003e  6a20              LDR      r0,[r4,#0x20]         ;1825
000040  6501              STR      r1,[r0,#0x50]         ;1828
000042  6820              LDR      r0,[r4,#0]            ;1828
000044  f1000134          ADD      r1,r0,#0x34           ;1828
000048  6a20              LDR      r0,[r4,#0x20]         ;1828
00004a  f7fffffe          BL       HAL_DMA_Start_IT
00004e  6820              LDR      r0,[r4,#0]            ;1831
000050  68c1              LDR      r1,[r0,#0xc]          ;1831
000052  f4417100          ORR      r1,r1,#0x200          ;1831
000056  e031              B        |L40.188|
                  |L40.88|
000058  f8d4c024          LDR      r12,[r4,#0x24]        ;1838
00005c  f8cc0040          STR      r0,[r12,#0x40]        ;1841
000060  6a60              LDR      r0,[r4,#0x24]         ;1841
000062  6501              STR      r1,[r0,#0x50]         ;1844
000064  6820              LDR      r0,[r4,#0]            ;1844
000066  f1000138          ADD      r1,r0,#0x38           ;1844
00006a  6a60              LDR      r0,[r4,#0x24]         ;1844
00006c  f7fffffe          BL       HAL_DMA_Start_IT
000070  6820              LDR      r0,[r4,#0]            ;1847
000072  68c1              LDR      r1,[r0,#0xc]          ;1847
000074  f4416180          ORR      r1,r1,#0x400          ;1847
000078  e020              B        |L40.188|
                  |L40.122|
00007a  f8d4c028          LDR      r12,[r4,#0x28]        ;1854
00007e  f8cc0040          STR      r0,[r12,#0x40]        ;1857
000082  6aa0              LDR      r0,[r4,#0x28]         ;1857
000084  6501              STR      r1,[r0,#0x50]         ;1860
000086  6820              LDR      r0,[r4,#0]            ;1860
000088  f100013c          ADD      r1,r0,#0x3c           ;1860
00008c  6aa0              LDR      r0,[r4,#0x28]         ;1860
00008e  f7fffffe          BL       HAL_DMA_Start_IT
000092  6820              LDR      r0,[r4,#0]            ;1863
000094  68c1              LDR      r1,[r0,#0xc]          ;1863
000096  f4416100          ORR      r1,r1,#0x800          ;1863
00009a  e00f              B        |L40.188|
                  |L40.156|
00009c  f8d4c02c          LDR      r12,[r4,#0x2c]        ;1870
0000a0  f8cc0040          STR      r0,[r12,#0x40]        ;1873
0000a4  6ae0              LDR      r0,[r4,#0x2c]         ;1873
0000a6  6501              STR      r1,[r0,#0x50]         ;1876
0000a8  6820              LDR      r0,[r4,#0]            ;1876
0000aa  f1000140          ADD      r1,r0,#0x40           ;1876
0000ae  6ae0              LDR      r0,[r4,#0x2c]         ;1876
0000b0  f7fffffe          BL       HAL_DMA_Start_IT
0000b4  6820              LDR      r0,[r4,#0]            ;1879
0000b6  68c1              LDR      r1,[r0,#0xc]          ;1879
0000b8  f4415180          ORR      r1,r1,#0x1000         ;1879
                  |L40.188|
0000bc  60c1              STR      r1,[r0,#0xc]          ;1863
                  |L40.190|
0000be  6820              LDR      r0,[r4,#0]            ;1863
0000c0  2101              MOVS     r1,#1                 ;1863
0000c2  40a9              LSLS     r1,r1,r5              ;1863
0000c4  6a02              LDR      r2,[r0,#0x20]         ;1863
0000c6  438a              BICS     r2,r2,r1              ;1863
0000c8  6202              STR      r2,[r0,#0x20]         ;1863
0000ca  6a02              LDR      r2,[r0,#0x20]         ;1863
0000cc  4311              ORRS     r1,r1,r2              ;1863
0000ce  6201              STR      r1,[r0,#0x20]         ;1863
0000d0  6820              LDR      r0,[r4,#0]            ;1891
0000d2  6801              LDR      r1,[r0,#0]            ;1891
0000d4  f0410101          ORR      r1,r1,#1              ;1891
0000d8  6001              STR      r1,[r0,#0]            ;1891
0000da  2000              MOVS     r0,#0                 ;1894
0000dc  bd70              POP      {r4-r6,pc}
;;;1896   
                          ENDP

0000de  0000              DCW      0x0000
                  |L40.224|
                          DCD      TIM_DMACaptureCplt
                  |L40.228|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_IC_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Start_IT PROC
;;;1671     */
;;;1672   HAL_StatusTypeDef HAL_TIM_IC_Start_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
;;;1673   {
;;;1674     /* Check the parameters */
;;;1675     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1676     
;;;1677     switch (Channel)
000002  2900              CMP      r1,#0
;;;1678     {
;;;1679       case TIM_CHANNEL_1:
;;;1680       {       
;;;1681         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1682         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000004  bf04              ITT      EQ
000006  68d3              LDREQ    r3,[r2,#0xc]
000008  f0430302          ORREQ    r3,r3,#2
00000c  d011              BEQ      |L41.50|
00000e  2904              CMP      r1,#4                 ;1677
;;;1683       }
;;;1684       break;
;;;1685       
;;;1686       case TIM_CHANNEL_2:
;;;1687       {
;;;1688         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1689         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000010  bf04              ITT      EQ
000012  68d3              LDREQ    r3,[r2,#0xc]
000014  f0430304          ORREQ    r3,r3,#4
000018  d00b              BEQ      |L41.50|
00001a  2908              CMP      r1,#8                 ;1677
;;;1690       }
;;;1691       break;
;;;1692       
;;;1693       case TIM_CHANNEL_3:
;;;1694       {
;;;1695         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1696         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
00001c  bf04              ITT      EQ
00001e  68d3              LDREQ    r3,[r2,#0xc]
000020  f0430308          ORREQ    r3,r3,#8
000024  d005              BEQ      |L41.50|
000026  290c              CMP      r1,#0xc               ;1677
;;;1697       }
;;;1698       break;
;;;1699       
;;;1700       case TIM_CHANNEL_4:
;;;1701       {
;;;1702         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1703         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000028  bf04              ITT      EQ
00002a  68d3              LDREQ    r3,[r2,#0xc]
00002c  f0430310          ORREQ    r3,r3,#0x10
000030  d100              BNE      |L41.52|
                  |L41.50|
000032  60d3              STR      r3,[r2,#0xc]          ;1696
                  |L41.52|
000034  6802              LDR      r2,[r0,#0]            ;1696
000036  2301              MOVS     r3,#1                 ;1696
000038  fa03f101          LSL      r1,r3,r1              ;1696
00003c  6a13              LDR      r3,[r2,#0x20]         ;1696
00003e  438b              BICS     r3,r3,r1              ;1696
000040  6213              STR      r3,[r2,#0x20]         ;1696
000042  6a13              LDR      r3,[r2,#0x20]         ;1696
000044  4319              ORRS     r1,r1,r3              ;1696
000046  6211              STR      r1,[r2,#0x20]         ;1696
;;;1704       }
;;;1705       break;
;;;1706       
;;;1707       default:
;;;1708       break;
;;;1709     }  
;;;1710     /* Enable the Input Capture channel */
;;;1711     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1712       
;;;1713     /* Enable the Peripheral */
;;;1714     __HAL_TIM_ENABLE(htim);  
000048  6800              LDR      r0,[r0,#0]
00004a  6801              LDR      r1,[r0,#0]
00004c  f0410101          ORR      r1,r1,#1
000050  6001              STR      r1,[r0,#0]
;;;1715   
;;;1716     /* Return function status */
;;;1717     return HAL_OK;  
000052  2000              MOVS     r0,#0
;;;1718   } 
000054  4770              BX       lr
;;;1719   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop PROC
;;;1644     */
;;;1645   HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b410              PUSH     {r4}
000002  6802              LDR      r2,[r0,#0]
000004  f04f0c01          MOV      r12,#1
;;;1646   { 
;;;1647     /* Check the parameters */
;;;1648     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1649     
;;;1650     /* Disable the Input Capture channel */
;;;1651     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000008  2300              MOVS     r3,#0
00000a  6a14              LDR      r4,[r2,#0x20]
00000c  fa0cfc01          LSL      r12,r12,r1
000010  ea240c0c          BIC      r12,r4,r12
000014  f8c2c020          STR      r12,[r2,#0x20]
000018  f8d2c020          LDR      r12,[r2,#0x20]
00001c  fa03f101          LSL      r1,r3,r1
000020  ea4c0101          ORR      r1,r12,r1
000024  6211              STR      r1,[r2,#0x20]
;;;1652     
;;;1653     /* Disable the Peripheral */
;;;1654     __HAL_TIM_DISABLE(htim); 
000026  6800              LDR      r0,[r0,#0]
000028  6a01              LDR      r1,[r0,#0x20]
00002a  f2411211          MOV      r2,#0x1111
00002e  4211              TST      r1,r2
000030  d107              BNE      |L42.66|
000032  6a01              LDR      r1,[r0,#0x20]
000034  1092              ASRS     r2,r2,#2
000036  4211              TST      r1,r2
000038  d103              BNE      |L42.66|
00003a  6801              LDR      r1,[r0,#0]
00003c  f0210101          BIC      r1,r1,#1
000040  6001              STR      r1,[r0,#0]
                  |L42.66|
;;;1655     
;;;1656     /* Return function status */
;;;1657     return HAL_OK;
;;;1658   }
000042  bc10              POP      {r4}
000044  2000              MOVS     r0,#0                 ;1657
000046  4770              BX       lr
;;;1659   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop_DMA PROC
;;;1908     */
;;;1909   HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b430              PUSH     {r4,r5}
;;;1910   {
;;;1911     /* Check the parameters */
;;;1912     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1913     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;1914     
;;;1915     switch (Channel)
000002  6802              LDR      r2,[r0,#0]
000004  2900              CMP      r1,#0
;;;1916     {
;;;1917       case TIM_CHANNEL_1:
;;;1918       {       
;;;1919         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1920         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000006  bf04              ITT      EQ
000008  68d3              LDREQ    r3,[r2,#0xc]
00000a  f4237300          BICEQ    r3,r3,#0x200
00000e  d011              BEQ      |L43.52|
000010  2904              CMP      r1,#4                 ;1915
;;;1921       }
;;;1922       break;
;;;1923       
;;;1924       case TIM_CHANNEL_2:
;;;1925       {
;;;1926         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1927         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000012  bf04              ITT      EQ
000014  68d3              LDREQ    r3,[r2,#0xc]
000016  f4236380          BICEQ    r3,r3,#0x400
00001a  d00b              BEQ      |L43.52|
00001c  2908              CMP      r1,#8                 ;1915
;;;1928       }
;;;1929       break;
;;;1930       
;;;1931       case TIM_CHANNEL_3:
;;;1932       {
;;;1933         /* Disable the TIM Capture/Compare 3  DMA request */
;;;1934         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
00001e  bf04              ITT      EQ
000020  68d3              LDREQ    r3,[r2,#0xc]
000022  f4236300          BICEQ    r3,r3,#0x800
000026  d005              BEQ      |L43.52|
000028  290c              CMP      r1,#0xc               ;1915
;;;1935       }
;;;1936       break;
;;;1937       
;;;1938       case TIM_CHANNEL_4:
;;;1939       {
;;;1940         /* Disable the TIM Capture/Compare 4  DMA request */
;;;1941         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
00002a  bf04              ITT      EQ
00002c  68d3              LDREQ    r3,[r2,#0xc]
00002e  f4235380          BICEQ    r3,r3,#0x1000
000032  d100              BNE      |L43.54|
                  |L43.52|
000034  60d3              STR      r3,[r2,#0xc]          ;1934
                  |L43.54|
000036  6802              LDR      r2,[r0,#0]            ;1934
000038  2301              MOVS     r3,#1                 ;1934
;;;1942       }
;;;1943       break;
;;;1944       
;;;1945       default:
;;;1946       break;
;;;1947     }
;;;1948   
;;;1949     /* Disable the Input Capture channel */
;;;1950     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
00003a  f04f0c00          MOV      r12,#0
00003e  6a15              LDR      r5,[r2,#0x20]
000040  fa03f401          LSL      r4,r3,r1
000044  ea250404          BIC      r4,r5,r4
000048  6214              STR      r4,[r2,#0x20]
00004a  6a14              LDR      r4,[r2,#0x20]
00004c  fa0cf101          LSL      r1,r12,r1
000050  4321              ORRS     r1,r1,r4
000052  6211              STR      r1,[r2,#0x20]
;;;1951     
;;;1952     /* Disable the Peripheral */
;;;1953     __HAL_TIM_DISABLE(htim); 
000054  6801              LDR      r1,[r0,#0]
000056  6a0a              LDR      r2,[r1,#0x20]
000058  f2411c11          MOV      r12,#0x1111
00005c  ea120f0c          TST      r2,r12
000060  d109              BNE      |L43.118|
000062  6a0a              LDR      r2,[r1,#0x20]
000064  f2404c44          MOV      r12,#0x444
000068  ea120f0c          TST      r2,r12
00006c  d103              BNE      |L43.118|
00006e  680a              LDR      r2,[r1,#0]
000070  f0220201          BIC      r2,r2,#1
000074  600a              STR      r2,[r1,#0]
                  |L43.118|
;;;1954     
;;;1955     /* Change the htim state */
;;;1956     htim->State = HAL_TIM_STATE_READY;
000076  63c3              STR      r3,[r0,#0x3c]
;;;1957     
;;;1958     /* Return function status */
;;;1959     return HAL_OK;
;;;1960   }  
000078  bc30              POP      {r4,r5}
00007a  2000              MOVS     r0,#0                 ;1959
00007c  4770              BX       lr
;;;1961   /**
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop_IT PROC
;;;1731     */
;;;1732   HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b410              PUSH     {r4}
;;;1733   {
;;;1734     /* Check the parameters */
;;;1735     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1736     
;;;1737     switch (Channel)
000002  6802              LDR      r2,[r0,#0]
000004  2900              CMP      r1,#0
;;;1738     {
;;;1739       case TIM_CHANNEL_1:
;;;1740       {       
;;;1741         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1742         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000006  bf04              ITT      EQ
000008  68d3              LDREQ    r3,[r2,#0xc]
00000a  f0230302          BICEQ    r3,r3,#2
00000e  d011              BEQ      |L44.52|
000010  2904              CMP      r1,#4                 ;1737
;;;1743       }
;;;1744       break;
;;;1745       
;;;1746       case TIM_CHANNEL_2:
;;;1747       {
;;;1748         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1749         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000012  bf04              ITT      EQ
000014  68d3              LDREQ    r3,[r2,#0xc]
000016  f0230304          BICEQ    r3,r3,#4
00001a  d00b              BEQ      |L44.52|
00001c  2908              CMP      r1,#8                 ;1737
;;;1750       }
;;;1751       break;
;;;1752       
;;;1753       case TIM_CHANNEL_3:
;;;1754       {
;;;1755         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1756         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
00001e  bf04              ITT      EQ
000020  68d3              LDREQ    r3,[r2,#0xc]
000022  f0230308          BICEQ    r3,r3,#8
000026  d005              BEQ      |L44.52|
000028  290c              CMP      r1,#0xc               ;1737
;;;1757       }
;;;1758       break;
;;;1759       
;;;1760       case TIM_CHANNEL_4:
;;;1761       {
;;;1762         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1763         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
00002a  bf04              ITT      EQ
00002c  68d3              LDREQ    r3,[r2,#0xc]
00002e  f0230310          BICEQ    r3,r3,#0x10
000032  d100              BNE      |L44.54|
                  |L44.52|
000034  60d3              STR      r3,[r2,#0xc]          ;1756
                  |L44.54|
000036  6802              LDR      r2,[r0,#0]            ;1756
000038  f04f0c01          MOV      r12,#1                ;1756
;;;1764       }
;;;1765       break;
;;;1766       
;;;1767       default:
;;;1768       break; 
;;;1769     } 
;;;1770     
;;;1771     /* Disable the Input Capture channel */
;;;1772     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE); 
00003c  2300              MOVS     r3,#0
00003e  6a14              LDR      r4,[r2,#0x20]
000040  fa0cfc01          LSL      r12,r12,r1
000044  ea240c0c          BIC      r12,r4,r12
000048  f8c2c020          STR      r12,[r2,#0x20]
00004c  f8d2c020          LDR      r12,[r2,#0x20]
000050  fa03f101          LSL      r1,r3,r1
000054  ea4c0101          ORR      r1,r12,r1
000058  6211              STR      r1,[r2,#0x20]
;;;1773     
;;;1774     /* Disable the Peripheral */
;;;1775     __HAL_TIM_DISABLE(htim); 
00005a  6800              LDR      r0,[r0,#0]
00005c  6a01              LDR      r1,[r0,#0x20]
00005e  f2411211          MOV      r2,#0x1111
000062  4211              TST      r1,r2
000064  d107              BNE      |L44.118|
000066  6a01              LDR      r1,[r0,#0x20]
000068  1092              ASRS     r2,r2,#2
00006a  4211              TST      r1,r2
00006c  d103              BNE      |L44.118|
00006e  6801              LDR      r1,[r0,#0]
000070  f0210101          BIC      r1,r1,#1
000074  6001              STR      r1,[r0,#0]
                  |L44.118|
;;;1776     
;;;1777     /* Return function status */
;;;1778     return HAL_OK;
;;;1779   }
000076  bc10              POP      {r4}
000078  2000              MOVS     r0,#0                 ;1778
00007a  4770              BX       lr
;;;1780   
                          ENDP


                          AREA ||i.HAL_TIM_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IRQHandler PROC
;;;2808     */
;;;2809   void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
000000  b570              PUSH     {r4-r6,lr}
;;;2810   {
000002  4604              MOV      r4,r0
;;;2811     /* Capture compare 1 event */
;;;2812     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
000004  6800              LDR      r0,[r0,#0]
000006  6901              LDR      r1,[r0,#0x10]
000008  f04f0500          MOV      r5,#0
00000c  f0110f02          TST      r1,#2
;;;2813     {
;;;2814       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
000010  bf1c              ITT      NE
000012  68c1              LDRNE    r1,[r0,#0xc]
000014  f0110f02          TSTNE    r1,#2
000018  d013              BEQ      |L45.66|
;;;2815       {
;;;2816         {
;;;2817           __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
00001a  f06f0102          MVN      r1,#2
00001e  6101              STR      r1,[r0,#0x10]
;;;2818           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000020  2001              MOVS     r0,#1
;;;2819           
;;;2820           /* Input capture event */
;;;2821           if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
000022  61a0              STR      r0,[r4,#0x18]
000024  6820              LDR      r0,[r4,#0]
000026  6980              LDR      r0,[r0,#0x18]
000028  f0100f03          TST      r0,#3
;;;2822           {
;;;2823             HAL_TIM_IC_CaptureCallback(htim);
;;;2824           }
;;;2825           /* Output compare event */
;;;2826           else
;;;2827           {
;;;2828             HAL_TIM_OC_DelayElapsedCallback(htim);
00002c  4620              MOV      r0,r4
00002e  d002              BEQ      |L45.54|
000030  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
000034  e004              B        |L45.64|
                  |L45.54|
000036  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2829             HAL_TIM_PWM_PulseFinishedCallback(htim);
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.64|
;;;2830           }
;;;2831           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000040  61a5              STR      r5,[r4,#0x18]
                  |L45.66|
;;;2832         }
;;;2833       }
;;;2834     }
;;;2835     /* Capture compare 2 event */
;;;2836     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
000042  6820              LDR      r0,[r4,#0]
000044  6901              LDR      r1,[r0,#0x10]
000046  f0110f04          TST      r1,#4
;;;2837     {
;;;2838       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
00004a  bf1c              ITT      NE
00004c  68c1              LDRNE    r1,[r0,#0xc]
00004e  f0110f04          TSTNE    r1,#4
000052  d013              BEQ      |L45.124|
;;;2839       {
;;;2840         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
000054  f06f0104          MVN      r1,#4
000058  6101              STR      r1,[r0,#0x10]
;;;2841         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
00005a  2002              MOVS     r0,#2
;;;2842         /* Input capture event */
;;;2843         if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
00005c  61a0              STR      r0,[r4,#0x18]
00005e  6820              LDR      r0,[r4,#0]
000060  6980              LDR      r0,[r0,#0x18]
000062  f4107f40          TST      r0,#0x300
;;;2844         {          
;;;2845           HAL_TIM_IC_CaptureCallback(htim);
;;;2846         }
;;;2847         /* Output compare event */
;;;2848         else
;;;2849         {
;;;2850           HAL_TIM_OC_DelayElapsedCallback(htim);
000066  4620              MOV      r0,r4
000068  d002              BEQ      |L45.112|
00006a  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
00006e  e004              B        |L45.122|
                  |L45.112|
000070  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2851           HAL_TIM_PWM_PulseFinishedCallback(htim);
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.122|
;;;2852         }
;;;2853         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
00007a  61a5              STR      r5,[r4,#0x18]
                  |L45.124|
;;;2854       }
;;;2855     }
;;;2856     /* Capture compare 3 event */
;;;2857     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
00007c  6820              LDR      r0,[r4,#0]
00007e  6901              LDR      r1,[r0,#0x10]
000080  f0110f08          TST      r1,#8
;;;2858     {
;;;2859       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
000084  bf1c              ITT      NE
000086  68c1              LDRNE    r1,[r0,#0xc]
000088  f0110f08          TSTNE    r1,#8
00008c  d013              BEQ      |L45.182|
;;;2860       {
;;;2861         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
00008e  f06f0108          MVN      r1,#8
000092  6101              STR      r1,[r0,#0x10]
;;;2862         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000094  2004              MOVS     r0,#4
;;;2863         /* Input capture event */
;;;2864         if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
000096  61a0              STR      r0,[r4,#0x18]
000098  6820              LDR      r0,[r4,#0]
00009a  69c0              LDR      r0,[r0,#0x1c]
00009c  f0100f03          TST      r0,#3
;;;2865         {          
;;;2866           HAL_TIM_IC_CaptureCallback(htim);
;;;2867         }
;;;2868         /* Output compare event */
;;;2869         else
;;;2870         {
;;;2871           HAL_TIM_OC_DelayElapsedCallback(htim);
0000a0  4620              MOV      r0,r4
0000a2  d002              BEQ      |L45.170|
0000a4  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
0000a8  e004              B        |L45.180|
                  |L45.170|
0000aa  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2872           HAL_TIM_PWM_PulseFinishedCallback(htim); 
0000ae  4620              MOV      r0,r4
0000b0  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.180|
;;;2873         }
;;;2874         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
0000b4  61a5              STR      r5,[r4,#0x18]
                  |L45.182|
;;;2875       }
;;;2876     }
;;;2877     /* Capture compare 4 event */
;;;2878     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
0000b6  6820              LDR      r0,[r4,#0]
0000b8  6901              LDR      r1,[r0,#0x10]
0000ba  f0110f10          TST      r1,#0x10
;;;2879     {
;;;2880       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
0000be  bf1c              ITT      NE
0000c0  68c1              LDRNE    r1,[r0,#0xc]
0000c2  f0110f10          TSTNE    r1,#0x10
0000c6  d013              BEQ      |L45.240|
;;;2881       {
;;;2882         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
0000c8  f06f0110          MVN      r1,#0x10
0000cc  6101              STR      r1,[r0,#0x10]
;;;2883         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
0000ce  2008              MOVS     r0,#8
;;;2884         /* Input capture event */
;;;2885         if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
0000d0  61a0              STR      r0,[r4,#0x18]
0000d2  6820              LDR      r0,[r4,#0]
0000d4  69c0              LDR      r0,[r0,#0x1c]
0000d6  f4107f40          TST      r0,#0x300
;;;2886         {          
;;;2887           HAL_TIM_IC_CaptureCallback(htim);
;;;2888         }
;;;2889         /* Output compare event */
;;;2890         else
;;;2891         {
;;;2892           HAL_TIM_OC_DelayElapsedCallback(htim);
0000da  4620              MOV      r0,r4
0000dc  d002              BEQ      |L45.228|
0000de  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
0000e2  e004              B        |L45.238|
                  |L45.228|
0000e4  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2893           HAL_TIM_PWM_PulseFinishedCallback(htim);
0000e8  4620              MOV      r0,r4
0000ea  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.238|
;;;2894         }
;;;2895         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
0000ee  61a5              STR      r5,[r4,#0x18]
                  |L45.240|
;;;2896       }
;;;2897     }
;;;2898     /* TIM Update event */
;;;2899     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
0000f0  6820              LDR      r0,[r4,#0]
0000f2  6901              LDR      r1,[r0,#0x10]
0000f4  f0110f01          TST      r1,#1
;;;2900     {
;;;2901       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
0000f8  bf1c              ITT      NE
0000fa  68c1              LDRNE    r1,[r0,#0xc]
0000fc  f0110f01          TSTNE    r1,#1
000100  d005              BEQ      |L45.270|
;;;2902       {
;;;2903         __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
000102  f06f0101          MVN      r1,#1
000106  6101              STR      r1,[r0,#0x10]
;;;2904         HAL_TIM_PeriodElapsedCallback(htim);
000108  4620              MOV      r0,r4
00010a  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
                  |L45.270|
;;;2905       }
;;;2906     }
;;;2907     /* TIM Break input event */
;;;2908     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
00010e  6820              LDR      r0,[r4,#0]
000110  6901              LDR      r1,[r0,#0x10]
000112  f0110f80          TST      r1,#0x80
;;;2909     {
;;;2910       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
000116  bf1c              ITT      NE
000118  68c1              LDRNE    r1,[r0,#0xc]
00011a  f0110f80          TSTNE    r1,#0x80
00011e  d005              BEQ      |L45.300|
;;;2911       {
;;;2912         __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
000120  f06f0180          MVN      r1,#0x80
000124  6101              STR      r1,[r0,#0x10]
;;;2913         HAL_TIMEx_BreakCallback(htim);
000126  4620              MOV      r0,r4
000128  f7fffffe          BL       HAL_TIMEx_BreakCallback
                  |L45.300|
;;;2914       }
;;;2915     }
;;;2916     /* TIM Trigger detection event */
;;;2917     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
00012c  6820              LDR      r0,[r4,#0]
00012e  6901              LDR      r1,[r0,#0x10]
000130  f0110f40          TST      r1,#0x40
;;;2918     {
;;;2919       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
000134  bf1c              ITT      NE
000136  68c1              LDRNE    r1,[r0,#0xc]
000138  f0110f40          TSTNE    r1,#0x40
00013c  d005              BEQ      |L45.330|
;;;2920       {
;;;2921         __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
00013e  f06f0140          MVN      r1,#0x40
000142  6101              STR      r1,[r0,#0x10]
;;;2922         HAL_TIM_TriggerCallback(htim);
000144  4620              MOV      r0,r4
000146  f7fffffe          BL       HAL_TIM_TriggerCallback
                  |L45.330|
;;;2923       }
;;;2924     }
;;;2925     /* TIM commutation event */
;;;2926     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
00014a  6820              LDR      r0,[r4,#0]
00014c  6901              LDR      r1,[r0,#0x10]
00014e  f0110f20          TST      r1,#0x20
;;;2927     {
;;;2928       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
000152  bf1a              ITTE     NE
000154  68c1              LDRNE    r1,[r0,#0xc]
000156  f0110f20          TSTNE    r1,#0x20
;;;2929       {
;;;2930         __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
;;;2931         HAL_TIMEx_CommutationCallback(htim);
;;;2932       }
;;;2933     }
;;;2934   }
00015a  bd70              POPEQ    {r4-r6,pc}
00015c  f06f0120          MVN      r1,#0x20              ;2930
000160  6101              STR      r1,[r0,#0x10]         ;2930
000162  4620              MOV      r0,r4                 ;2931
000164  e8bd4070          POP      {r4-r6,lr}            ;2931
000168  f7ffbffe          B.W      HAL_TIMEx_CommutationCallback
;;;2935   /**
                          ENDP


                          AREA ||i.HAL_TIM_OC_ConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_ConfigChannel PROC
;;;2971     */
;;;2972   HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
000000  6b83              LDR      r3,[r0,#0x38]
;;;2973   {
;;;2974     /* Check the parameters */ 
;;;2975     assert_param(IS_TIM_CHANNELS(Channel)); 
;;;2976     assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
;;;2977     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;2978     
;;;2979     /* Check input state */
;;;2980     __HAL_LOCK(htim); 
000002  2b01              CMP      r3,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;2981     
;;;2982     htim->State = HAL_TIM_STATE_BUSY;
;;;2983     
;;;2984     switch (Channel)
;;;2985     {
;;;2986       case TIM_CHANNEL_1:
;;;2987       {
;;;2988         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;2989         /* Configure the TIM Channel 1 in Output Compare */
;;;2990         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;2991       }
;;;2992       break;
;;;2993       
;;;2994       case TIM_CHANNEL_2:
;;;2995       {
;;;2996         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2997         /* Configure the TIM Channel 2 in Output Compare */
;;;2998         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;2999       }
;;;3000       break;
;;;3001       
;;;3002       case TIM_CHANNEL_3:
;;;3003       {
;;;3004          assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3005         /* Configure the TIM Channel 3 in Output Compare */
;;;3006         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;3007       }
;;;3008       break;
;;;3009       
;;;3010       case TIM_CHANNEL_4:
;;;3011       {
;;;3012         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3013         /* Configure the TIM Channel 4 in Output Compare */
;;;3014         TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;3015       }
;;;3016       break;
;;;3017       
;;;3018       default:
;;;3019       break;    
;;;3020     }
;;;3021     htim->State = HAL_TIM_STATE_READY;
;;;3022     
;;;3023     __HAL_UNLOCK(htim); 
;;;3024     
;;;3025     return HAL_OK;
;;;3026   }
000008  4770              BXEQ     lr
00000a  e92d01f0          PUSH     {r4-r8}               ;2973
00000e  2401              MOVS     r4,#1                 ;2980
000010  2302              MOVS     r3,#2                 ;2982
000012  6384              STR      r4,[r0,#0x38]         ;2982
000014  63c3              STR      r3,[r0,#0x3c]         ;2982
000016  4b63              LDR      r3,|L46.420|
000018  f8dfc18c          LDR      r12,|L46.424|
00001c  b132              CBZ      r2,|L46.44|
00001e  2a04              CMP      r2,#4                 ;2984
000020  d033              BEQ      |L46.138|
000022  2a08              CMP      r2,#8                 ;2984
000024  d061              BEQ      |L46.234|
000026  2a0c              CMP      r2,#0xc               ;2984
000028  d07e              BEQ      |L46.296|
00002a  e0b3              B        |L46.404|
                  |L46.44|
00002c  6802              LDR      r2,[r0,#0]            ;2984
00002e  6a15              LDR      r5,[r2,#0x20]         ;2984
000030  f0250501          BIC      r5,r5,#1              ;2984
000034  6215              STR      r5,[r2,#0x20]         ;2984
000036  6a15              LDR      r5,[r2,#0x20]         ;2984
000038  6856              LDR      r6,[r2,#4]            ;2984
00003a  6997              LDR      r7,[r2,#0x18]         ;2984
00003c  f8d18000          LDR      r8,[r1,#0]            ;2984
000040  f0270773          BIC      r7,r7,#0x73           ;2984
000044  ea480707          ORR      r7,r8,r7              ;2984
000048  f8d18008          LDR      r8,[r1,#8]            ;2984
00004c  f0250502          BIC      r5,r5,#2              ;2984
000050  ea480505          ORR      r5,r8,r5              ;2984
000054  429a              CMP      r2,r3                 ;2984
000056  bf18              IT       NE                    ;2984
000058  4562              CMPNE    r2,r12                ;2984
00005a  d111              BNE      |L46.128|
00005c  f8d1c00c          LDR      r12,[r1,#0xc]         ;2990
000060  f0250308          BIC      r3,r5,#8              ;2990
000064  ea4c0303          ORR      r3,r12,r3             ;2990
000068  f0230504          BIC      r5,r3,#4              ;2990
00006c  f8d1c014          LDR      r12,[r1,#0x14]        ;2990
000070  f4267340          BIC      r3,r6,#0x300          ;2990
000074  ea4c0303          ORR      r3,r12,r3             ;2990
000078  f8d1c018          LDR      r12,[r1,#0x18]        ;2990
00007c  ea4c0603          ORR      r6,r12,r3             ;2990
                  |L46.128|
000080  6056              STR      r6,[r2,#4]            ;2990
000082  6197              STR      r7,[r2,#0x18]         ;2990
000084  6849              LDR      r1,[r1,#4]            ;2990
000086  6351              STR      r1,[r2,#0x34]         ;2990
000088  e02d              B        |L46.230|
                  |L46.138|
00008a  6802              LDR      r2,[r0,#0]            ;2992
00008c  6a15              LDR      r5,[r2,#0x20]         ;2992
00008e  f0250510          BIC      r5,r5,#0x10           ;2992
000092  6215              STR      r5,[r2,#0x20]         ;2992
000094  6a15              LDR      r5,[r2,#0x20]         ;2992
000096  6856              LDR      r6,[r2,#4]            ;2992
000098  6997              LDR      r7,[r2,#0x18]         ;2992
00009a  f8d18000          LDR      r8,[r1,#0]            ;2992
00009e  f42747e6          BIC      r7,r7,#0x7300         ;2992
0000a2  ea472708          ORR      r7,r7,r8,LSL #8       ;2992
0000a6  f8d18008          LDR      r8,[r1,#8]            ;2992
0000aa  f0250520          BIC      r5,r5,#0x20           ;2992
0000ae  ea451508          ORR      r5,r5,r8,LSL #4       ;2992
0000b2  429a              CMP      r2,r3                 ;2992
0000b4  bf18              IT       NE                    ;2992
0000b6  4562              CMPNE    r2,r12                ;2992
0000b8  d111              BNE      |L46.222|
0000ba  f8d1c00c          LDR      r12,[r1,#0xc]         ;2998
0000be  f0250380          BIC      r3,r5,#0x80           ;2998
0000c2  ea43130c          ORR      r3,r3,r12,LSL #4      ;2998
0000c6  f0230540          BIC      r5,r3,#0x40           ;2998
0000ca  f8d1c014          LDR      r12,[r1,#0x14]        ;2998
0000ce  f4266340          BIC      r3,r6,#0xc00          ;2998
0000d2  ea43038c          ORR      r3,r3,r12,LSL #2      ;2998
0000d6  f8d1c018          LDR      r12,[r1,#0x18]        ;2998
0000da  ea43068c          ORR      r6,r3,r12,LSL #2      ;2998
                  |L46.222|
0000de  6056              STR      r6,[r2,#4]            ;2998
0000e0  6197              STR      r7,[r2,#0x18]         ;2998
0000e2  6849              LDR      r1,[r1,#4]            ;2998
0000e4  6391              STR      r1,[r2,#0x38]         ;2998
                  |L46.230|
0000e6  6215              STR      r5,[r2,#0x20]         ;2998
0000e8  e054              B        |L46.404|
                  |L46.234|
0000ea  6802              LDR      r2,[r0,#0]            ;2998
0000ec  6a15              LDR      r5,[r2,#0x20]         ;2998
0000ee  f4257580          BIC      r5,r5,#0x100          ;2998
0000f2  6215              STR      r5,[r2,#0x20]         ;2998
0000f4  6a16              LDR      r6,[r2,#0x20]         ;2998
0000f6  6855              LDR      r5,[r2,#4]            ;2998
0000f8  69d7              LDR      r7,[r2,#0x1c]         ;2998
0000fa  f8d18000          LDR      r8,[r1,#0]            ;2998
0000fe  f0270773          BIC      r7,r7,#0x73           ;2998
000102  ea480707          ORR      r7,r8,r7              ;2998
000106  f8d18008          LDR      r8,[r1,#8]            ;2998
00010a  f4267600          BIC      r6,r6,#0x200          ;2998
00010e  ea462608          ORR      r6,r6,r8,LSL #8       ;2998
000112  429a              CMP      r2,r3                 ;2998
000114  bf18              IT       NE                    ;2998
000116  4562              CMPNE    r2,r12                ;2998
000118  d113              BNE      |L46.322|
00011a  f8d1c00c          LDR      r12,[r1,#0xc]         ;3006
00011e  f4266300          BIC      r3,r6,#0x800          ;3006
000122  ea43230c          ORR      r3,r3,r12,LSL #8      ;3006
000126  e000              B        |L46.298|
                  |L46.296|
000128  e011              B        |L46.334|
                  |L46.298|
00012a  f4236680          BIC      r6,r3,#0x400          ;3006
00012e  f8d1c014          LDR      r12,[r1,#0x14]        ;3006
000132  f4255340          BIC      r3,r5,#0x3000         ;3006
000136  ea43130c          ORR      r3,r3,r12,LSL #4      ;3006
00013a  f8d1c018          LDR      r12,[r1,#0x18]        ;3006
00013e  ea43150c          ORR      r5,r3,r12,LSL #4      ;3006
                  |L46.322|
000142  6055              STR      r5,[r2,#4]            ;3006
000144  61d7              STR      r7,[r2,#0x1c]         ;3006
000146  6849              LDR      r1,[r1,#4]            ;3006
000148  63d1              STR      r1,[r2,#0x3c]         ;3006
00014a  6216              STR      r6,[r2,#0x20]         ;3006
00014c  e022              B        |L46.404|
                  |L46.334|
00014e  6802              LDR      r2,[r0,#0]            ;3008
000150  6a15              LDR      r5,[r2,#0x20]         ;3008
000152  f4255580          BIC      r5,r5,#0x1000         ;3008
000156  6215              STR      r5,[r2,#0x20]         ;3008
000158  6a17              LDR      r7,[r2,#0x20]         ;3008
00015a  6855              LDR      r5,[r2,#4]            ;3008
00015c  69d6              LDR      r6,[r2,#0x1c]         ;3008
00015e  f8d18000          LDR      r8,[r1,#0]            ;3008
000162  f42646e6          BIC      r6,r6,#0x7300         ;3008
000166  ea462608          ORR      r6,r6,r8,LSL #8       ;3008
00016a  f8d18008          LDR      r8,[r1,#8]            ;3008
00016e  f4275700          BIC      r7,r7,#0x2000         ;3008
000172  ea473708          ORR      r7,r7,r8,LSL #12      ;3008
000176  429a              CMP      r2,r3                 ;3008
000178  bf18              IT       NE                    ;3008
00017a  4562              CMPNE    r2,r12                ;3008
00017c  d105              BNE      |L46.394|
00017e  f8d1c014          LDR      r12,[r1,#0x14]        ;3014
000182  f4254380          BIC      r3,r5,#0x4000         ;3014
000186  ea43158c          ORR      r5,r3,r12,LSL #6      ;3014
                  |L46.394|
00018a  6055              STR      r5,[r2,#4]            ;3014
00018c  61d6              STR      r6,[r2,#0x1c]         ;3014
00018e  6849              LDR      r1,[r1,#4]            ;3014
000190  6411              STR      r1,[r2,#0x40]         ;3014
000192  6217              STR      r7,[r2,#0x20]         ;3014
                  |L46.404|
000194  63c4              STR      r4,[r0,#0x3c]         ;3021
000196  2100              MOVS     r1,#0                 ;3023
000198  6381              STR      r1,[r0,#0x38]         ;3025
00019a  e8bd01f0          POP      {r4-r8}
00019e  4608              MOV      r0,r1                 ;3025
0001a0  4770              BX       lr
;;;3027   
                          ENDP

0001a2  0000              DCW      0x0000
                  |L46.420|
                          DCD      0x40010000
                  |L46.424|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_DeInit PROC
;;;526      */
;;;527    HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;528    {
000002  4604              MOV      r4,r0
;;;529      /* Check the parameters */
;;;530      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;531      
;;;532       htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  63e0              STR      r0,[r4,#0x3c]
;;;533       
;;;534      /* Disable the TIM Peripheral Clock */
;;;535      __HAL_TIM_DISABLE(htim);
000008  6820              LDR      r0,[r4,#0]
00000a  6a01              LDR      r1,[r0,#0x20]
00000c  f2411211          MOV      r2,#0x1111
000010  4211              TST      r1,r2
000012  d107              BNE      |L47.36|
000014  6a01              LDR      r1,[r0,#0x20]
000016  1092              ASRS     r2,r2,#2
000018  4211              TST      r1,r2
00001a  d103              BNE      |L47.36|
00001c  6801              LDR      r1,[r0,#0]
00001e  f0210101          BIC      r1,r1,#1
000022  6001              STR      r1,[r0,#0]
                  |L47.36|
;;;536      
;;;537      /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;538      HAL_TIM_OC_MspDeInit(htim);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       HAL_TIM_OC_MspDeInit
;;;539        
;;;540      /* Change TIM state */  
;;;541      htim->State = HAL_TIM_STATE_RESET; 
00002a  2000              MOVS     r0,#0
00002c  63e0              STR      r0,[r4,#0x3c]
;;;542    
;;;543      /* Release Lock */
;;;544      __HAL_UNLOCK(htim);
00002e  63a0              STR      r0,[r4,#0x38]
;;;545    
;;;546      return HAL_OK;
;;;547    }
000030  bd10              POP      {r4,pc}
;;;548    
                          ENDP


                          AREA ||i.HAL_TIM_OC_DelayElapsedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_DelayElapsedCallback PROC
;;;4318     */
;;;4319   __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4320   {
;;;4321     /* Prevent unused argument(s) compilation warning */
;;;4322     UNUSED(htim);
;;;4323     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4324               the __HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
;;;4325      */
;;;4326   }
;;;4327   
                          ENDP


                          AREA ||i.HAL_TIM_OC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_GetState PROC
;;;4422     */
;;;4423   HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
000000  6bc0              LDR      r0,[r0,#0x3c]
;;;4424   {
;;;4425     return htim->State;
;;;4426   }
000002  4770              BX       lr
;;;4427   
                          ENDP


                          AREA ||i.HAL_TIM_OC_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_Init PROC
;;;487      */
;;;488    HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef* htim)
000000  2800              CMP      r0,#0
;;;489    {
;;;490      /* Check the TIM handle allocation */
;;;491      if(htim == NULL)
;;;492      {
;;;493        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;494      }
;;;495    
;;;496      /* Check the parameters */
;;;497      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;498      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;499      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;500     
;;;501      if(htim->State == HAL_TIM_STATE_RESET)
;;;502      { 
;;;503        /* Allocate lock resource and initialize it */
;;;504        htim->Lock = HAL_UNLOCKED;
;;;505        /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;506        HAL_TIM_OC_MspInit(htim);
;;;507      }
;;;508      
;;;509      /* Set the TIM state */
;;;510      htim->State= HAL_TIM_STATE_BUSY;
;;;511      
;;;512      /* Init the base time for the Output Compare */  
;;;513      TIM_Base_SetConfig(htim->Instance,  &htim->Init); 
;;;514      
;;;515      /* Initialize the TIM state*/
;;;516      htim->State= HAL_TIM_STATE_READY;
;;;517      
;;;518      return HAL_OK;
;;;519    }
000006  4770              BXEQ     lr
000008  b510              PUSH     {r4,lr}               ;489
00000a  4604              MOV      r4,r0                 ;489
00000c  6bc0              LDR      r0,[r0,#0x3c]         ;501
00000e  b920              CBNZ     r0,|L50.26|
000010  2000              MOVS     r0,#0                 ;504
000012  63a0              STR      r0,[r4,#0x38]         ;506
000014  4620              MOV      r0,r4                 ;506
000016  f7fffffe          BL       HAL_TIM_OC_MspInit
                  |L50.26|
00001a  2002              MOVS     r0,#2                 ;510
00001c  63e0              STR      r0,[r4,#0x3c]         ;510
00001e  1d21              ADDS     r1,r4,#4              ;513
000020  6820              LDR      r0,[r4,#0]            ;513
000022  f7fffffe          BL       TIM_Base_SetConfig
000026  2001              MOVS     r0,#1                 ;516
000028  63e0              STR      r0,[r4,#0x3c]         ;516
00002a  2000              MOVS     r0,#0                 ;518
00002c  bd10              POP      {r4,pc}
;;;520    
                          ENDP


                          AREA ||i.HAL_TIM_OC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_MspDeInit PROC
;;;569      */
;;;570    __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;571    {
;;;572      /* Prevent unused argument(s) compilation warning */
;;;573      UNUSED(htim);
;;;574      /* NOTE : This function Should not be modified, when the callback is needed,
;;;575                the HAL_TIM_OC_MspDeInit could be implemented in the user file
;;;576       */
;;;577    }
;;;578    
                          ENDP


                          AREA ||i.HAL_TIM_OC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_MspInit PROC
;;;554      */
;;;555    __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;556    {
;;;557      /* Prevent unused argument(s) compilation warning */
;;;558      UNUSED(htim);
;;;559      /* NOTE : This function Should not be modified, when the callback is needed,
;;;560                the HAL_TIM_OC_MspInit could be implemented in the user file
;;;561       */
;;;562    }
;;;563    
                          ENDP


                          AREA ||i.HAL_TIM_OC_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_Start PROC
;;;590      */
;;;591    HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
000002  2301              MOVS     r3,#1
000004  fa03f101          LSL      r1,r3,r1
000008  6a13              LDR      r3,[r2,#0x20]
00000a  438b              BICS     r3,r3,r1
00000c  6213              STR      r3,[r2,#0x20]
00000e  6a13              LDR      r3,[r2,#0x20]
000010  4319              ORRS     r1,r1,r3
000012  6211              STR      r1,[r2,#0x20]
;;;592    {
;;;593      /* Check the parameters */
;;;594      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;595      
;;;596      /* Enable the Output compare channel */
;;;597      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;598      
;;;599      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000014  6801              LDR      r1,[r0,#0]
000016  f1a14280          SUB      r2,r1,#0x40000000
00001a  f5b23280          SUBS     r2,r2,#0x10000
00001e  bf1c              ITT      NE
000020  f1a14280          SUBNE    r2,r1,#0x40000000
000024  f5b23282          SUBSNE   r2,r2,#0x10400
000028  d103              BNE      |L53.50|
;;;600      {
;;;601        /* Enable the main output */
;;;602        __HAL_TIM_MOE_ENABLE(htim);
00002a  6c4a              LDR      r2,[r1,#0x44]
00002c  f4424200          ORR      r2,r2,#0x8000
000030  644a              STR      r2,[r1,#0x44]
                  |L53.50|
;;;603      }
;;;604      
;;;605      /* Enable the Peripheral */
;;;606      __HAL_TIM_ENABLE(htim); 
000032  6800              LDR      r0,[r0,#0]
000034  6801              LDR      r1,[r0,#0]
000036  f0410101          ORR      r1,r1,#1
00003a  6001              STR      r1,[r0,#0]
;;;607      
;;;608      /* Return function status */
;;;609      return HAL_OK;
00003c  2000              MOVS     r0,#0
;;;610    }
00003e  4770              BX       lr
;;;611    
                          ENDP


                          AREA ||i.HAL_TIM_OC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start_DMA PROC
;;;792      */
;;;793    HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;794    {
000002  4604              MOV      r4,r0
;;;795      /* Check the parameters */
;;;796      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;797      
;;;798      if((htim->State == HAL_TIM_STATE_BUSY))
000004  6bc0              LDR      r0,[r0,#0x3c]
000006  4694              MOV      r12,r2                ;794
000008  460d              MOV      r5,r1                 ;794
00000a  2802              CMP      r0,#2
;;;799      {
;;;800         return HAL_BUSY;
;;;801      }
;;;802      else if((htim->State == HAL_TIM_STATE_READY))
;;;803      {
;;;804        if(((uint32_t)pData == 0U) && (Length > 0)) 
;;;805        {
;;;806          return HAL_ERROR;                                    
;;;807        }
;;;808        else
;;;809        {
;;;810          htim->State = HAL_TIM_STATE_BUSY;
;;;811        }
;;;812      }    
;;;813      switch (Channel)
;;;814      {
;;;815        case TIM_CHANNEL_1:
;;;816        {      
;;;817          /* Set the DMA Period elapsed callback */
;;;818          htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;819         
;;;820          /* Set the DMA error callback */
;;;821          htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;822          
;;;823          /* Enable the DMA Stream */
;;;824          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;825          
;;;826          /* Enable the TIM Capture/Compare 1 DMA request */
;;;827          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;828        }
;;;829        break;
;;;830        
;;;831        case TIM_CHANNEL_2:
;;;832        {
;;;833          /* Set the DMA Period elapsed callback */
;;;834          htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;835         
;;;836          /* Set the DMA error callback */
;;;837          htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;838          
;;;839          /* Enable the DMA Stream */
;;;840          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;841          
;;;842          /* Enable the TIM Capture/Compare 2 DMA request */
;;;843          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;844        }
;;;845        break;
;;;846        
;;;847        case TIM_CHANNEL_3:
;;;848        {
;;;849          /* Set the DMA Period elapsed callback */
;;;850          htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;851         
;;;852          /* Set the DMA error callback */
;;;853          htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;854          
;;;855          /* Enable the DMA Stream */
;;;856          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;857          
;;;858          /* Enable the TIM Capture/Compare 3 DMA request */
;;;859          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;860        }
;;;861        break;
;;;862        
;;;863        case TIM_CHANNEL_4:
;;;864        {
;;;865         /* Set the DMA Period elapsed callback */
;;;866          htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;867         
;;;868          /* Set the DMA error callback */
;;;869          htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;870          
;;;871          /* Enable the DMA Stream */
;;;872          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;873          
;;;874          /* Enable the TIM Capture/Compare 4 DMA request */
;;;875          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;876        }
;;;877        break;
;;;878        
;;;879        default:
;;;880        break;
;;;881      }
;;;882    
;;;883      /* Enable the Output compare channel */
;;;884      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;885      
;;;886      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
;;;887      {
;;;888        /* Enable the main output */
;;;889        __HAL_TIM_MOE_ENABLE(htim);
;;;890      }  
;;;891      
;;;892      /* Enable the Peripheral */
;;;893      __HAL_TIM_ENABLE(htim); 
;;;894      
;;;895      /* Return function status */
;;;896      return HAL_OK;
;;;897    }
00000c  bf08              IT       EQ
00000e  bd70              POPEQ    {r4-r6,pc}
000010  6be0              LDR      r0,[r4,#0x3c]         ;802
000012  2801              CMP      r0,#1                 ;802
000014  d108              BNE      |L54.40|
000016  f1bc0f00          CMP      r12,#0                ;804
00001a  d103              BNE      |L54.36|
00001c  2b00              CMP      r3,#0                 ;804
00001e  bf1c              ITT      NE                    ;806
000020  2001              MOVNE    r0,#1                 ;806
000022  bd70              POPNE    {r4-r6,pc}
                  |L54.36|
000024  2002              MOVS     r0,#2                 ;810
000026  63e0              STR      r0,[r4,#0x3c]         ;810
                  |L54.40|
000028  4834              LDR      r0,|L54.252|
00002a  4935              LDR      r1,|L54.256|
00002c  b135              CBZ      r5,|L54.60|
00002e  2d04              CMP      r5,#4                 ;813
000030  d014              BEQ      |L54.92|
000032  2d08              CMP      r5,#8                 ;813
000034  d022              BEQ      |L54.124|
000036  2d0c              CMP      r5,#0xc               ;813
000038  d030              BEQ      |L54.156|
00003a  e03f              B        |L54.188|
                  |L54.60|
00003c  6a22              LDR      r2,[r4,#0x20]         ;818
00003e  6410              STR      r0,[r2,#0x40]         ;821
000040  6a20              LDR      r0,[r4,#0x20]         ;821
000042  6501              STR      r1,[r0,#0x50]         ;824
000044  6820              LDR      r0,[r4,#0]            ;824
000046  4661              MOV      r1,r12                ;824
000048  f1000234          ADD      r2,r0,#0x34           ;824
00004c  6a20              LDR      r0,[r4,#0x20]         ;824
00004e  f7fffffe          BL       HAL_DMA_Start_IT
000052  6820              LDR      r0,[r4,#0]            ;827
000054  68c1              LDR      r1,[r0,#0xc]          ;827
000056  f4417100          ORR      r1,r1,#0x200          ;827
00005a  e02e              B        |L54.186|
                  |L54.92|
00005c  6a62              LDR      r2,[r4,#0x24]         ;834
00005e  6410              STR      r0,[r2,#0x40]         ;837
000060  6a60              LDR      r0,[r4,#0x24]         ;837
000062  6501              STR      r1,[r0,#0x50]         ;840
000064  6820              LDR      r0,[r4,#0]            ;840
000066  4661              MOV      r1,r12                ;840
000068  f1000238          ADD      r2,r0,#0x38           ;840
00006c  6a60              LDR      r0,[r4,#0x24]         ;840
00006e  f7fffffe          BL       HAL_DMA_Start_IT
000072  6820              LDR      r0,[r4,#0]            ;843
000074  68c1              LDR      r1,[r0,#0xc]          ;843
000076  f4416180          ORR      r1,r1,#0x400          ;843
00007a  e01e              B        |L54.186|
                  |L54.124|
00007c  6aa2              LDR      r2,[r4,#0x28]         ;850
00007e  6410              STR      r0,[r2,#0x40]         ;853
000080  6aa0              LDR      r0,[r4,#0x28]         ;853
000082  6501              STR      r1,[r0,#0x50]         ;856
000084  6820              LDR      r0,[r4,#0]            ;856
000086  4661              MOV      r1,r12                ;856
000088  f100023c          ADD      r2,r0,#0x3c           ;856
00008c  6aa0              LDR      r0,[r4,#0x28]         ;856
00008e  f7fffffe          BL       HAL_DMA_Start_IT
000092  6820              LDR      r0,[r4,#0]            ;859
000094  68c1              LDR      r1,[r0,#0xc]          ;859
000096  f4416100          ORR      r1,r1,#0x800          ;859
00009a  e00e              B        |L54.186|
                  |L54.156|
00009c  6ae2              LDR      r2,[r4,#0x2c]         ;866
00009e  6410              STR      r0,[r2,#0x40]         ;869
0000a0  6ae0              LDR      r0,[r4,#0x2c]         ;869
0000a2  6501              STR      r1,[r0,#0x50]         ;872
0000a4  6820              LDR      r0,[r4,#0]            ;872
0000a6  4661              MOV      r1,r12                ;872
0000a8  f1000240          ADD      r2,r0,#0x40           ;872
0000ac  6ae0              LDR      r0,[r4,#0x2c]         ;872
0000ae  f7fffffe          BL       HAL_DMA_Start_IT
0000b2  6820              LDR      r0,[r4,#0]            ;875
0000b4  68c1              LDR      r1,[r0,#0xc]          ;875
0000b6  f4415180          ORR      r1,r1,#0x1000         ;875
                  |L54.186|
0000ba  60c1              STR      r1,[r0,#0xc]          ;859
                  |L54.188|
0000bc  6820              LDR      r0,[r4,#0]            ;859
0000be  2101              MOVS     r1,#1                 ;859
0000c0  40a9              LSLS     r1,r1,r5              ;859
0000c2  6a02              LDR      r2,[r0,#0x20]         ;859
0000c4  438a              BICS     r2,r2,r1              ;859
0000c6  6202              STR      r2,[r0,#0x20]         ;859
0000c8  6a02              LDR      r2,[r0,#0x20]         ;859
0000ca  4311              ORRS     r1,r1,r2              ;859
0000cc  6201              STR      r1,[r0,#0x20]         ;859
0000ce  6820              LDR      r0,[r4,#0]            ;886
0000d0  f1a04180          SUB      r1,r0,#0x40000000     ;886
0000d4  f5b13180          SUBS     r1,r1,#0x10000        ;886
0000d8  bf1c              ITT      NE                    ;886
0000da  f1a04180          SUBNE    r1,r0,#0x40000000     ;886
0000de  f5b13182          SUBSNE   r1,r1,#0x10400        ;886
0000e2  d103              BNE      |L54.236|
0000e4  6c41              LDR      r1,[r0,#0x44]         ;889
0000e6  f4414100          ORR      r1,r1,#0x8000         ;889
0000ea  6441              STR      r1,[r0,#0x44]         ;889
                  |L54.236|
0000ec  6820              LDR      r0,[r4,#0]            ;893
0000ee  6801              LDR      r1,[r0,#0]            ;893
0000f0  f0410101          ORR      r1,r1,#1              ;893
0000f4  6001              STR      r1,[r0,#0]            ;893
0000f6  2000              MOVS     r0,#0                 ;896
0000f8  bd70              POP      {r4-r6,pc}
;;;898    
                          ENDP

0000fa  0000              DCW      0x0000
                  |L54.252|
                          DCD      TIM_DMADelayPulseCplt
                  |L54.256|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_OC_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_Start_IT PROC
;;;656      */
;;;657    HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
;;;658    {
;;;659      /* Check the parameters */
;;;660      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;661      
;;;662      switch (Channel)
000002  2900              CMP      r1,#0
;;;663      {
;;;664        case TIM_CHANNEL_1:
;;;665        {       
;;;666          /* Enable the TIM Capture/Compare 1 interrupt */
;;;667          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000004  bf04              ITT      EQ
000006  68d3              LDREQ    r3,[r2,#0xc]
000008  f0430302          ORREQ    r3,r3,#2
00000c  d011              BEQ      |L55.50|
00000e  2904              CMP      r1,#4                 ;662
;;;668        }
;;;669        break;
;;;670        
;;;671        case TIM_CHANNEL_2:
;;;672        {
;;;673          /* Enable the TIM Capture/Compare 2 interrupt */
;;;674          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000010  bf04              ITT      EQ
000012  68d3              LDREQ    r3,[r2,#0xc]
000014  f0430304          ORREQ    r3,r3,#4
000018  d00b              BEQ      |L55.50|
00001a  2908              CMP      r1,#8                 ;662
;;;675        }
;;;676        break;
;;;677        
;;;678        case TIM_CHANNEL_3:
;;;679        {
;;;680          /* Enable the TIM Capture/Compare 3 interrupt */
;;;681          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
00001c  bf04              ITT      EQ
00001e  68d3              LDREQ    r3,[r2,#0xc]
000020  f0430308          ORREQ    r3,r3,#8
000024  d005              BEQ      |L55.50|
000026  290c              CMP      r1,#0xc               ;662
;;;682        }
;;;683        break;
;;;684        
;;;685        case TIM_CHANNEL_4:
;;;686        {
;;;687          /* Enable the TIM Capture/Compare 4 interrupt */
;;;688          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000028  bf04              ITT      EQ
00002a  68d3              LDREQ    r3,[r2,#0xc]
00002c  f0430310          ORREQ    r3,r3,#0x10
000030  d100              BNE      |L55.52|
                  |L55.50|
000032  60d3              STR      r3,[r2,#0xc]          ;681
                  |L55.52|
000034  6802              LDR      r2,[r0,#0]            ;681
000036  2301              MOVS     r3,#1                 ;681
000038  fa03f101          LSL      r1,r3,r1              ;681
00003c  6a13              LDR      r3,[r2,#0x20]         ;681
00003e  438b              BICS     r3,r3,r1              ;681
000040  6213              STR      r3,[r2,#0x20]         ;681
000042  6a13              LDR      r3,[r2,#0x20]         ;681
000044  4319              ORRS     r1,r1,r3              ;681
000046  6211              STR      r1,[r2,#0x20]         ;681
;;;689        }
;;;690        break;
;;;691        
;;;692        default:
;;;693        break;
;;;694      } 
;;;695    
;;;696      /* Enable the Output compare channel */
;;;697      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;698      
;;;699      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000048  6801              LDR      r1,[r0,#0]
00004a  f1a14280          SUB      r2,r1,#0x40000000
00004e  f5b23280          SUBS     r2,r2,#0x10000
000052  bf1c              ITT      NE
000054  f1a14280          SUBNE    r2,r1,#0x40000000
000058  f5b23282          SUBSNE   r2,r2,#0x10400
00005c  d103              BNE      |L55.102|
;;;700      {
;;;701        /* Enable the main output */
;;;702        __HAL_TIM_MOE_ENABLE(htim);
00005e  6c4a              LDR      r2,[r1,#0x44]
000060  f4424200          ORR      r2,r2,#0x8000
000064  644a              STR      r2,[r1,#0x44]
                  |L55.102|
;;;703      }
;;;704    
;;;705      /* Enable the Peripheral */
;;;706      __HAL_TIM_ENABLE(htim);
000066  6800              LDR      r0,[r0,#0]
000068  6801              LDR      r1,[r0,#0]
00006a  f0410101          ORR      r1,r1,#1
00006e  6001              STR      r1,[r0,#0]
;;;707      
;;;708      /* Return function status */
;;;709      return HAL_OK;
000070  2000              MOVS     r0,#0
;;;710    }
000072  4770              BX       lr
;;;711    
                          ENDP


                          AREA ||i.HAL_TIM_OC_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_Stop PROC
;;;623      */
;;;624    HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b410              PUSH     {r4}
000002  6802              LDR      r2,[r0,#0]
000004  f04f0c01          MOV      r12,#1
;;;625    {
;;;626      /* Check the parameters */
;;;627      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;628      
;;;629      /* Disable the Output compare channel */
;;;630      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000008  2300              MOVS     r3,#0
00000a  6a14              LDR      r4,[r2,#0x20]
00000c  fa0cfc01          LSL      r12,r12,r1
000010  ea240c0c          BIC      r12,r4,r12
000014  f8c2c020          STR      r12,[r2,#0x20]
000018  f8d2c020          LDR      r12,[r2,#0x20]
00001c  fa03f101          LSL      r1,r3,r1
000020  ea4c0101          ORR      r1,r12,r1
000024  6211              STR      r1,[r2,#0x20]
;;;631      
;;;632      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000026  6801              LDR      r1,[r0,#0]
;;;633      {
;;;634        /* Disable the Main Output */
;;;635        __HAL_TIM_MOE_DISABLE(htim);
000028  f2411311          MOV      r3,#0x1111
00002c  109a              ASRS     r2,r3,#2
00002e  f1a14c80          SUB      r12,r1,#0x40000000    ;632
000032  f5bc3c80          SUBS     r12,r12,#0x10000      ;632
000036  bf1c              ITT      NE                    ;632
000038  f1a14c80          SUBNE    r12,r1,#0x40000000    ;632
00003c  f5bc3c82          SUBSNE   r12,r12,#0x10400      ;632
000040  d10f              BNE      |L56.98|
000042  f8d1c020          LDR      r12,[r1,#0x20]
000046  ea1c0f03          TST      r12,r3
00004a  bf04              ITT      EQ
00004c  f8d1c020          LDREQ    r12,[r1,#0x20]
000050  ea1c0f02          TSTEQ    r12,r2
000054  d105              BNE      |L56.98|
000056  f8d1c044          LDR      r12,[r1,#0x44]
00005a  f42c4c00          BIC      r12,r12,#0x8000
00005e  f8c1c044          STR      r12,[r1,#0x44]
                  |L56.98|
;;;636      }  
;;;637      
;;;638      /* Disable the Peripheral */
;;;639      __HAL_TIM_DISABLE(htim);  
000062  6800              LDR      r0,[r0,#0]
000064  6a01              LDR      r1,[r0,#0x20]
000066  4219              TST      r1,r3
000068  bf04              ITT      EQ
00006a  6a01              LDREQ    r1,[r0,#0x20]
00006c  4211              TSTEQ    r1,r2
00006e  d103              BNE      |L56.120|
000070  6801              LDR      r1,[r0,#0]
000072  f0210101          BIC      r1,r1,#1
000076  6001              STR      r1,[r0,#0]
                  |L56.120|
;;;640      
;;;641      /* Return function status */
;;;642      return HAL_OK;
;;;643    }  
000078  bc10              POP      {r4}
00007a  2000              MOVS     r0,#0                 ;642
00007c  4770              BX       lr
;;;644    
                          ENDP


                          AREA ||i.HAL_TIM_OC_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_Stop_DMA PROC
;;;910      */
;;;911    HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b430              PUSH     {r4,r5}
;;;912    {
;;;913      /* Check the parameters */
;;;914      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;915      
;;;916      switch (Channel)
000002  6802              LDR      r2,[r0,#0]
000004  2900              CMP      r1,#0
;;;917      {
;;;918        case TIM_CHANNEL_1:
;;;919        {       
;;;920          /* Disable the TIM Capture/Compare 1 DMA request */
;;;921          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000006  bf04              ITT      EQ
000008  68d3              LDREQ    r3,[r2,#0xc]
00000a  f4237300          BICEQ    r3,r3,#0x200
00000e  d011              BEQ      |L57.52|
000010  2904              CMP      r1,#4                 ;916
;;;922        }
;;;923        break;
;;;924        
;;;925        case TIM_CHANNEL_2:
;;;926        {
;;;927          /* Disable the TIM Capture/Compare 2 DMA request */
;;;928          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000012  bf04              ITT      EQ
000014  68d3              LDREQ    r3,[r2,#0xc]
000016  f4236380          BICEQ    r3,r3,#0x400
00001a  d00b              BEQ      |L57.52|
00001c  2908              CMP      r1,#8                 ;916
;;;929        }
;;;930        break;
;;;931        
;;;932        case TIM_CHANNEL_3:
;;;933        {
;;;934          /* Disable the TIM Capture/Compare 3 DMA request */
;;;935          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
00001e  bf04              ITT      EQ
000020  68d3              LDREQ    r3,[r2,#0xc]
000022  f4236300          BICEQ    r3,r3,#0x800
000026  d005              BEQ      |L57.52|
000028  290c              CMP      r1,#0xc               ;916
;;;936        }
;;;937        break;
;;;938        
;;;939        case TIM_CHANNEL_4:
;;;940        {
;;;941          /* Disable the TIM Capture/Compare 4 interrupt */
;;;942          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
00002a  bf04              ITT      EQ
00002c  68d3              LDREQ    r3,[r2,#0xc]
00002e  f4235380          BICEQ    r3,r3,#0x1000
000032  d100              BNE      |L57.54|
                  |L57.52|
000034  60d3              STR      r3,[r2,#0xc]          ;935
                  |L57.54|
000036  6802              LDR      r2,[r0,#0]            ;935
000038  2301              MOVS     r3,#1                 ;935
;;;943        }
;;;944        break;
;;;945        
;;;946        default:
;;;947        break;
;;;948      } 
;;;949      
;;;950      /* Disable the Output compare channel */
;;;951      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
00003a  f04f0c00          MOV      r12,#0
00003e  6a15              LDR      r5,[r2,#0x20]
000040  fa03f401          LSL      r4,r3,r1
000044  ea250404          BIC      r4,r5,r4
000048  6214              STR      r4,[r2,#0x20]
00004a  6a14              LDR      r4,[r2,#0x20]
00004c  fa0cf101          LSL      r1,r12,r1
000050  4321              ORRS     r1,r1,r4
000052  6211              STR      r1,[r2,#0x20]
;;;952      
;;;953      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000054  6801              LDR      r1,[r0,#0]
;;;954      {
;;;955        /* Disable the Main Output */
;;;956        __HAL_TIM_MOE_DISABLE(htim);
000056  f2411c11          MOV      r12,#0x1111
00005a  f1a14480          SUB      r4,r1,#0x40000000     ;953
00005e  f2404244          MOV      r2,#0x444
000062  f5b43480          SUBS     r4,r4,#0x10000        ;953
000066  bf1c              ITT      NE                    ;953
000068  f1a14480          SUBNE    r4,r1,#0x40000000     ;953
00006c  f5b43482          SUBSNE   r4,r4,#0x10400        ;953
000070  d10a              BNE      |L57.136|
000072  6a0c              LDR      r4,[r1,#0x20]
000074  ea140f0c          TST      r4,r12
000078  bf04              ITT      EQ
00007a  6a0c              LDREQ    r4,[r1,#0x20]
00007c  4214              TSTEQ    r4,r2
00007e  d103              BNE      |L57.136|
000080  6c4c              LDR      r4,[r1,#0x44]
000082  f4244400          BIC      r4,r4,#0x8000
000086  644c              STR      r4,[r1,#0x44]
                  |L57.136|
;;;957      }
;;;958      
;;;959      /* Disable the Peripheral */
;;;960      __HAL_TIM_DISABLE(htim);
000088  6801              LDR      r1,[r0,#0]
00008a  6a0c              LDR      r4,[r1,#0x20]
00008c  ea140f0c          TST      r4,r12
000090  bf04              ITT      EQ
000092  f8d1c020          LDREQ    r12,[r1,#0x20]
000096  ea1c0f02          TSTEQ    r12,r2
00009a  d103              BNE      |L57.164|
00009c  680a              LDR      r2,[r1,#0]
00009e  f0220201          BIC      r2,r2,#1
0000a2  600a              STR      r2,[r1,#0]
                  |L57.164|
;;;961      
;;;962      /* Change the htim state */
;;;963      htim->State = HAL_TIM_STATE_READY;
0000a4  63c3              STR      r3,[r0,#0x3c]
;;;964      
;;;965      /* Return function status */
;;;966      return HAL_OK;
;;;967    }
0000a6  bc30              POP      {r4,r5}
0000a8  2000              MOVS     r0,#0                 ;966
0000aa  4770              BX       lr
;;;968    /**
                          ENDP


                          AREA ||i.HAL_TIM_OC_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_Stop_IT PROC
;;;723      */
;;;724    HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b410              PUSH     {r4}
;;;725    {
;;;726      /* Check the parameters */
;;;727      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;728      
;;;729      switch (Channel)
000002  6802              LDR      r2,[r0,#0]
000004  2900              CMP      r1,#0
;;;730      {
;;;731        case TIM_CHANNEL_1:
;;;732        {       
;;;733          /* Disable the TIM Capture/Compare 1 interrupt */
;;;734          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000006  bf04              ITT      EQ
000008  68d3              LDREQ    r3,[r2,#0xc]
00000a  f0230302          BICEQ    r3,r3,#2
00000e  d011              BEQ      |L58.52|
000010  2904              CMP      r1,#4                 ;729
;;;735        }
;;;736        break;
;;;737        
;;;738        case TIM_CHANNEL_2:
;;;739        {
;;;740          /* Disable the TIM Capture/Compare 2 interrupt */
;;;741          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000012  bf04              ITT      EQ
000014  68d3              LDREQ    r3,[r2,#0xc]
000016  f0230304          BICEQ    r3,r3,#4
00001a  d00b              BEQ      |L58.52|
00001c  2908              CMP      r1,#8                 ;729
;;;742        }
;;;743        break;
;;;744        
;;;745        case TIM_CHANNEL_3:
;;;746        {
;;;747          /* Disable the TIM Capture/Compare 3 interrupt */
;;;748          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
00001e  bf04              ITT      EQ
000020  68d3              LDREQ    r3,[r2,#0xc]
000022  f0230308          BICEQ    r3,r3,#8
000026  d005              BEQ      |L58.52|
000028  290c              CMP      r1,#0xc               ;729
;;;749        }
;;;750        break;
;;;751        
;;;752        case TIM_CHANNEL_4:
;;;753        {
;;;754          /* Disable the TIM Capture/Compare 4 interrupt */
;;;755          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
00002a  bf04              ITT      EQ
00002c  68d3              LDREQ    r3,[r2,#0xc]
00002e  f0230310          BICEQ    r3,r3,#0x10
000032  d100              BNE      |L58.54|
                  |L58.52|
000034  60d3              STR      r3,[r2,#0xc]          ;748
                  |L58.54|
000036  6802              LDR      r2,[r0,#0]            ;748
000038  f04f0c01          MOV      r12,#1                ;748
;;;756        }
;;;757        break;
;;;758        
;;;759        default:
;;;760        break; 
;;;761      } 
;;;762      
;;;763      /* Disable the Output compare channel */
;;;764      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE); 
00003c  2300              MOVS     r3,#0
00003e  6a14              LDR      r4,[r2,#0x20]
000040  fa0cfc01          LSL      r12,r12,r1
000044  ea240c0c          BIC      r12,r4,r12
000048  f8c2c020          STR      r12,[r2,#0x20]
00004c  f8d2c020          LDR      r12,[r2,#0x20]
000050  fa03f101          LSL      r1,r3,r1
000054  ea4c0101          ORR      r1,r12,r1
000058  6211              STR      r1,[r2,#0x20]
;;;765      
;;;766      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00005a  6801              LDR      r1,[r0,#0]
;;;767      {
;;;768        /* Disable the Main Output */
;;;769        __HAL_TIM_MOE_DISABLE(htim);
00005c  f2411211          MOV      r2,#0x1111
000060  1093              ASRS     r3,r2,#2
000062  f1a14c80          SUB      r12,r1,#0x40000000    ;766
000066  f5bc3c80          SUBS     r12,r12,#0x10000      ;766
00006a  bf1c              ITT      NE                    ;766
00006c  f1a14c80          SUBNE    r12,r1,#0x40000000    ;766
000070  f5bc3c82          SUBSNE   r12,r12,#0x10400      ;766
000074  d10f              BNE      |L58.150|
000076  f8d1c020          LDR      r12,[r1,#0x20]
00007a  ea1c0f02          TST      r12,r2
00007e  bf04              ITT      EQ
000080  f8d1c020          LDREQ    r12,[r1,#0x20]
000084  ea1c0f03          TSTEQ    r12,r3
000088  d105              BNE      |L58.150|
00008a  f8d1c044          LDR      r12,[r1,#0x44]
00008e  f42c4c00          BIC      r12,r12,#0x8000
000092  f8c1c044          STR      r12,[r1,#0x44]
                  |L58.150|
;;;770      }
;;;771      
;;;772      /* Disable the Peripheral */
;;;773      __HAL_TIM_DISABLE(htim);  
000096  6800              LDR      r0,[r0,#0]
000098  6a01              LDR      r1,[r0,#0x20]
00009a  4211              TST      r1,r2
00009c  bf04              ITT      EQ
00009e  6a01              LDREQ    r1,[r0,#0x20]
0000a0  4219              TSTEQ    r1,r3
0000a2  d103              BNE      |L58.172|
0000a4  6801              LDR      r1,[r0,#0]
0000a6  f0210101          BIC      r1,r1,#1
0000aa  6001              STR      r1,[r0,#0]
                  |L58.172|
;;;774      
;;;775      /* Return function status */
;;;776      return HAL_OK;
;;;777    }
0000ac  bc10              POP      {r4}
0000ae  2000              MOVS     r0,#0                 ;776
0000b0  4770              BX       lr
;;;778    
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_ConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_ConfigChannel PROC
;;;3239     */
;;;3240   HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef* sConfig, uint32_t OutputChannel,  uint32_t InputChannel)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;3241   {
;;;3242     TIM_OC_InitTypeDef temp1;
;;;3243     
;;;3244     /* Check the parameters */
;;;3245     assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
;;;3246     assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
;;;3247   
;;;3248     if(OutputChannel != InputChannel)  
000004  429a              CMP      r2,r3
;;;3249     {
;;;3250       __HAL_LOCK(htim);
;;;3251     
;;;3252       htim->State = HAL_TIM_STATE_BUSY;
;;;3253   
;;;3254       /* Extract the Output compare configuration from sConfig structure */  
;;;3255       temp1.OCMode = sConfig->OCMode;
;;;3256       temp1.Pulse = sConfig->Pulse;
;;;3257       temp1.OCPolarity = sConfig->OCPolarity;
;;;3258       temp1.OCNPolarity = sConfig->OCNPolarity;
;;;3259       temp1.OCIdleState = sConfig->OCIdleState;
;;;3260       temp1.OCNIdleState = sConfig->OCNIdleState; 
;;;3261       
;;;3262       switch (OutputChannel)
;;;3263       {
;;;3264         case TIM_CHANNEL_1:
;;;3265         {
;;;3266           assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3267         
;;;3268           TIM_OC1_SetConfig(htim->Instance, &temp1); 
;;;3269         }
;;;3270         break;
;;;3271         case TIM_CHANNEL_2:
;;;3272         {
;;;3273           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3274         
;;;3275           TIM_OC2_SetConfig(htim->Instance, &temp1);
;;;3276         }
;;;3277         break;
;;;3278         default:
;;;3279         break;  
;;;3280       } 
;;;3281       switch (InputChannel)
;;;3282       {
;;;3283         case TIM_CHANNEL_1:
;;;3284         {
;;;3285           assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3286         
;;;3287           TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;3288                           sConfig->ICSelection, sConfig->ICFilter);
;;;3289                  
;;;3290           /* Reset the IC1PSC Bits */
;;;3291           htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;3292   
;;;3293           /* Select the Trigger source */
;;;3294           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;3295           htim->Instance->SMCR |= TIM_TS_TI1FP1;
;;;3296         
;;;3297           /* Select the Slave Mode */      
;;;3298           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3299           htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;3300         }
;;;3301         break;
;;;3302         case TIM_CHANNEL_2:
;;;3303         {
;;;3304           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3305         
;;;3306           TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;3307                    sConfig->ICSelection, sConfig->ICFilter);
;;;3308                  
;;;3309           /* Reset the IC2PSC Bits */
;;;3310           htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;3311   
;;;3312           /* Select the Trigger source */
;;;3313           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;3314           htim->Instance->SMCR |= TIM_TS_TI2FP2;
;;;3315         
;;;3316           /* Select the Slave Mode */      
;;;3317           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3318           htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;3319         }
;;;3320         break;
;;;3321       
;;;3322         default:
;;;3323         break;  
;;;3324       }
;;;3325     
;;;3326       htim->State = HAL_TIM_STATE_READY;
;;;3327       
;;;3328       __HAL_UNLOCK(htim);
;;;3329     
;;;3330       return HAL_OK;
;;;3331     }
;;;3332     else
;;;3333     {
;;;3334       return HAL_ERROR;
000006  bf04              ITT      EQ
000008  2001              MOVEQ    r0,#1
;;;3335     }
;;;3336   } 
00000a  e8bd8ff0          POPEQ    {r4-r11,pc}
00000e  f8d0c038          LDR      r12,[r0,#0x38]        ;3250
000012  f1bc0f01          CMP      r12,#1                ;3250
000016  bf04              ITT      EQ                    ;3250
000018  2002              MOVEQ    r0,#2                 ;3250
00001a  e8bd8ff0          POPEQ    {r4-r11,pc}
00001e  f04f0c01          MOV      r12,#1                ;3250
000022  f8c0c038          STR      r12,[r0,#0x38]        ;3252
000026  f04f0c02          MOV      r12,#2                ;3252
00002a  f8c0c03c          STR      r12,[r0,#0x3c]        ;3252
00002e  e89103f0          LDM      r1,{r4-r9}            ;3252
000032  f8dfa200          LDR      r10,|L59.564|
000036  b112              CBZ      r2,|L59.62|
000038  2a04              CMP      r2,#4                 ;3262
00003a  d02c              BEQ      |L59.150|
00003c  e058              B        |L59.240|
                  |L59.62|
00003e  6802              LDR      r2,[r0,#0]            ;3262
000040  f8d2c020          LDR      r12,[r2,#0x20]        ;3262
000044  f02c0c01          BIC      r12,r12,#1            ;3262
000048  f8c2c020          STR      r12,[r2,#0x20]        ;3262
00004c  f8d2b020          LDR      r11,[r2,#0x20]        ;3262
000050  f8d2c004          LDR      r12,[r2,#4]           ;3262
000054  f8d2e018          LDR      lr,[r2,#0x18]         ;3262
000058  f02b0b02          BIC      r11,r11,#2            ;3262
00005c  f02e0e73          BIC      lr,lr,#0x73           ;3262
000060  ea44040e          ORR      r4,r4,lr              ;3262
000064  ea46060b          ORR      r6,r6,r11             ;3262
000068  4552              CMP      r2,r10                ;3262
00006a  bf1c              ITT      NE                    ;3262
00006c  f1a24b80          SUBNE    r11,r2,#0x40000000    ;3262
000070  f5bb3b82          SUBSNE   r11,r11,#0x10400      ;3262
000074  d10a              BNE      |L59.140|
000076  f0260608          BIC      r6,r6,#8              ;3268
00007a  f42c7c40          BIC      r12,r12,#0x300        ;3268
00007e  433e              ORRS     r6,r6,r7              ;3268
000080  ea480c0c          ORR      r12,r8,r12            ;3268
000084  f0260604          BIC      r6,r6,#4              ;3268
000088  ea490c0c          ORR      r12,r9,r12            ;3268
                  |L59.140|
00008c  f8c2c004          STR      r12,[r2,#4]           ;3268
000090  6194              STR      r4,[r2,#0x18]         ;3268
000092  6355              STR      r5,[r2,#0x34]         ;3268
000094  e02b              B        |L59.238|
                  |L59.150|
000096  6802              LDR      r2,[r0,#0]            ;3270
000098  f8d2c020          LDR      r12,[r2,#0x20]        ;3270
00009c  f02c0c10          BIC      r12,r12,#0x10         ;3270
0000a0  f8c2c020          STR      r12,[r2,#0x20]        ;3270
0000a4  f8d2b020          LDR      r11,[r2,#0x20]        ;3270
0000a8  f8d2c004          LDR      r12,[r2,#4]           ;3270
0000ac  f8d2e018          LDR      lr,[r2,#0x18]         ;3270
0000b0  f02b0b20          BIC      r11,r11,#0x20         ;3270
0000b4  f42e4ee6          BIC      lr,lr,#0x7300         ;3270
0000b8  ea4e2404          ORR      r4,lr,r4,LSL #8       ;3270
0000bc  ea4b1606          ORR      r6,r11,r6,LSL #4      ;3270
0000c0  4552              CMP      r2,r10                ;3270
0000c2  bf1c              ITT      NE                    ;3270
0000c4  f1a24b80          SUBNE    r11,r2,#0x40000000    ;3270
0000c8  f5bb3b82          SUBSNE   r11,r11,#0x10400      ;3270
0000cc  d10b              BNE      |L59.230|
0000ce  f0260680          BIC      r6,r6,#0x80           ;3275
0000d2  f42c6c40          BIC      r12,r12,#0xc00        ;3275
0000d6  ea461607          ORR      r6,r6,r7,LSL #4       ;3275
0000da  ea4c0c88          ORR      r12,r12,r8,LSL #2     ;3275
0000de  f0260640          BIC      r6,r6,#0x40           ;3275
0000e2  ea4c0c89          ORR      r12,r12,r9,LSL #2     ;3275
                  |L59.230|
0000e6  f8c2c004          STR      r12,[r2,#4]           ;3275
0000ea  6194              STR      r4,[r2,#0x18]         ;3275
0000ec  6395              STR      r5,[r2,#0x38]         ;3275
                  |L59.238|
0000ee  6216              STR      r6,[r2,#0x20]         ;3275
                  |L59.240|
0000f0  b113              CBZ      r3,|L59.248|
0000f2  2b04              CMP      r3,#4                 ;3281
0000f4  d05e              BEQ      |L59.436|
0000f6  e095              B        |L59.548|
                  |L59.248|
0000f8  6802              LDR      r2,[r0,#0]            ;3287
0000fa  e9d13506          LDRD     r3,r5,[r1,#0x18]      ;3287
0000fe  f8d1c020          LDR      r12,[r1,#0x20]        ;3287
000102  6a11              LDR      r1,[r2,#0x20]         ;3287
000104  f0210101          BIC      r1,r1,#1              ;3287
000108  6211              STR      r1,[r2,#0x20]         ;3287
00010a  6991              LDR      r1,[r2,#0x18]         ;3287
00010c  6a14              LDR      r4,[r2,#0x20]         ;3287
00010e  4552              CMP      r2,r10                ;3287
000110  bf18              IT       NE                    ;3287
000112  f1b24f80          CMPNE    r2,#0x40000000        ;3287
000116  d021              BEQ      |L59.348|
000118  f1a24680          SUB      r6,r2,#0x40000000     ;3287
00011c  f5b66680          SUBS     r6,r6,#0x400          ;3287
000120  bf1c              ITT      NE                    ;3287
000122  f1a24680          SUBNE    r6,r2,#0x40000000     ;3287
000126  f5b66600          SUBSNE   r6,r6,#0x800          ;3287
00012a  d017              BEQ      |L59.348|
00012c  f1a24680          SUB      r6,r2,#0x40000000     ;3287
000130  f5b66640          SUBS     r6,r6,#0xc00          ;3287
000134  bf1c              ITT      NE                    ;3287
000136  f1a24680          SUBNE    r6,r2,#0x40000000     ;3287
00013a  f5b63682          SUBSNE   r6,r6,#0x10400        ;3287
00013e  d00d              BEQ      |L59.348|
000140  f1a24680          SUB      r6,r2,#0x40000000     ;3287
000144  f5b636a0          SUBS     r6,r6,#0x14000        ;3287
000148  bf1f              ITTTT    NE                    ;3287
00014a  f1a24680          SUBNE    r6,r2,#0x40000000     ;3287
00014e  f5b656c0          SUBSNE   r6,r6,#0x1800         ;3287
000152  f0210103          BICNE    r1,r1,#3              ;3287
000156  f0410101          ORRNE    r1,r1,#1              ;3287
00015a  d102              BNE      |L59.354|
                  |L59.348|
00015c  f0210103          BIC      r1,r1,#3              ;3287
000160  4329              ORRS     r1,r1,r5              ;3287
                  |L59.354|
000162  25f0              MOVS     r5,#0xf0              ;3287
000164  f02101f0          BIC      r1,r1,#0xf0           ;3287
000168  ea051c0c          AND      r12,r5,r12,LSL #4     ;3287
00016c  ea4c0101          ORR      r1,r12,r1             ;3287
000170  f0240c0a          BIC      r12,r4,#0xa           ;3287
000174  f003030a          AND      r3,r3,#0xa            ;3287
000178  ea43030c          ORR      r3,r3,r12             ;3287
00017c  6191              STR      r1,[r2,#0x18]         ;3287
00017e  6213              STR      r3,[r2,#0x20]         ;3287
000180  6801              LDR      r1,[r0,#0]            ;3291
000182  698a              LDR      r2,[r1,#0x18]         ;3291
000184  f022020c          BIC      r2,r2,#0xc            ;3291
000188  618a              STR      r2,[r1,#0x18]         ;3291
00018a  6801              LDR      r1,[r0,#0]            ;3294
00018c  688a              LDR      r2,[r1,#8]            ;3294
00018e  f0220270          BIC      r2,r2,#0x70           ;3294
000192  608a              STR      r2,[r1,#8]            ;3294
000194  6801              LDR      r1,[r0,#0]            ;3295
000196  688a              LDR      r2,[r1,#8]            ;3295
000198  f0420250          ORR      r2,r2,#0x50           ;3295
00019c  608a              STR      r2,[r1,#8]            ;3295
00019e  6801              LDR      r1,[r0,#0]            ;3298
0001a0  688a              LDR      r2,[r1,#8]            ;3298
0001a2  f0220207          BIC      r2,r2,#7              ;3298
0001a6  608a              STR      r2,[r1,#8]            ;3298
0001a8  6801              LDR      r1,[r0,#0]            ;3299
0001aa  688a              LDR      r2,[r1,#8]            ;3299
0001ac  f0420206          ORR      r2,r2,#6              ;3299
0001b0  608a              STR      r2,[r1,#8]            ;3299
0001b2  e037              B        |L59.548|
                  |L59.436|
0001b4  6802              LDR      r2,[r0,#0]            ;3306
0001b6  e9d13407          LDRD     r3,r4,[r1,#0x1c]      ;3306
0001ba  f8d1c018          LDR      r12,[r1,#0x18]        ;3306
0001be  6a11              LDR      r1,[r2,#0x20]         ;3306
0001c0  f0210110          BIC      r1,r1,#0x10           ;3306
0001c4  6211              STR      r1,[r2,#0x20]         ;3306
0001c6  6995              LDR      r5,[r2,#0x18]         ;3306
0001c8  6a11              LDR      r1,[r2,#0x20]         ;3306
0001ca  f4257540          BIC      r5,r5,#0x300          ;3306
0001ce  ea452303          ORR      r3,r5,r3,LSL #8       ;3306
0001d2  f44f4570          MOV      r5,#0xf000            ;3306
0001d6  f4234370          BIC      r3,r3,#0xf000         ;3306
0001da  ea053404          AND      r4,r5,r4,LSL #12      ;3306
0001de  4323              ORRS     r3,r3,r4              ;3306
0001e0  24a0              MOVS     r4,#0xa0              ;3306
0001e2  f02101a0          BIC      r1,r1,#0xa0           ;3306
0001e6  ea041c0c          AND      r12,r4,r12,LSL #4     ;3306
0001ea  ea4c0101          ORR      r1,r12,r1             ;3306
0001ee  6193              STR      r3,[r2,#0x18]         ;3306
0001f0  6211              STR      r1,[r2,#0x20]         ;3306
0001f2  6801              LDR      r1,[r0,#0]            ;3310
0001f4  698a              LDR      r2,[r1,#0x18]         ;3310
0001f6  f4226240          BIC      r2,r2,#0xc00          ;3310
0001fa  618a              STR      r2,[r1,#0x18]         ;3310
0001fc  6801              LDR      r1,[r0,#0]            ;3313
0001fe  688a              LDR      r2,[r1,#8]            ;3313
000200  f0220270          BIC      r2,r2,#0x70           ;3313
000204  608a              STR      r2,[r1,#8]            ;3313
000206  6801              LDR      r1,[r0,#0]            ;3314
000208  688a              LDR      r2,[r1,#8]            ;3314
00020a  f0420260          ORR      r2,r2,#0x60           ;3314
00020e  608a              STR      r2,[r1,#8]            ;3314
000210  6801              LDR      r1,[r0,#0]            ;3317
000212  688a              LDR      r2,[r1,#8]            ;3317
000214  f0220207          BIC      r2,r2,#7              ;3317
000218  608a              STR      r2,[r1,#8]            ;3317
00021a  6801              LDR      r1,[r0,#0]            ;3318
00021c  688a              LDR      r2,[r1,#8]            ;3318
00021e  f0420206          ORR      r2,r2,#6              ;3318
000222  608a              STR      r2,[r1,#8]            ;3318
                  |L59.548|
000224  2101              MOVS     r1,#1                 ;3326
000226  63c1              STR      r1,[r0,#0x3c]         ;3326
000228  2100              MOVS     r1,#0                 ;3328
00022a  6381              STR      r1,[r0,#0x38]         ;3330
00022c  4608              MOV      r0,r1                 ;3330
00022e  e8bd8ff0          POP      {r4-r11,pc}
;;;3337   
                          ENDP

000232  0000              DCW      0x0000
                  |L59.564|
                          DCD      0x40010000

                          AREA ||i.HAL_TIM_OnePulse_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_DeInit PROC
;;;2042     */
;;;2043   HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;2044   {
000002  4604              MOV      r4,r0
;;;2045     /* Check the parameters */
;;;2046     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2047     
;;;2048     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  63e0              STR      r0,[r4,#0x3c]
;;;2049     
;;;2050     /* Disable the TIM Peripheral Clock */
;;;2051     __HAL_TIM_DISABLE(htim);
000008  6820              LDR      r0,[r4,#0]
00000a  6a01              LDR      r1,[r0,#0x20]
00000c  f2411211          MOV      r2,#0x1111
000010  4211              TST      r1,r2
000012  d107              BNE      |L60.36|
000014  6a01              LDR      r1,[r0,#0x20]
000016  1092              ASRS     r2,r2,#2
000018  4211              TST      r1,r2
00001a  d103              BNE      |L60.36|
00001c  6801              LDR      r1,[r0,#0]
00001e  f0210101          BIC      r1,r1,#1
000022  6001              STR      r1,[r0,#0]
                  |L60.36|
;;;2052     
;;;2053     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;2054     HAL_TIM_OnePulse_MspDeInit(htim);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       HAL_TIM_OnePulse_MspDeInit
;;;2055       
;;;2056     /* Change TIM state */  
;;;2057     htim->State = HAL_TIM_STATE_RESET;
00002a  2000              MOVS     r0,#0
00002c  63e0              STR      r0,[r4,#0x3c]
;;;2058   
;;;2059     /* Release Lock */
;;;2060     __HAL_UNLOCK(htim);
00002e  63a0              STR      r0,[r4,#0x38]
;;;2061   
;;;2062     return HAL_OK;
;;;2063   }
000030  bd10              POP      {r4,pc}
;;;2064   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_GetState PROC
;;;4455     */
;;;4456   HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
000000  6bc0              LDR      r0,[r0,#0x3c]
;;;4457   {
;;;4458     return htim->State;
;;;4459   }
000002  4770              BX       lr
;;;4460   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_Init PROC
;;;1996     */
;;;1997   HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
000000  2800              CMP      r0,#0
;;;1998   {
;;;1999     /* Check the TIM handle allocation */
;;;2000     if(htim == NULL)
;;;2001     {
;;;2002       return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;2003     }
;;;2004   
;;;2005     /* Check the parameters */
;;;2006     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2007     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;2008     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;2009     assert_param(IS_TIM_OPM_MODE(OnePulseMode));
;;;2010     
;;;2011     if(htim->State == HAL_TIM_STATE_RESET)
;;;2012     { 
;;;2013       /* Allocate lock resource and initialize it */
;;;2014       htim->Lock = HAL_UNLOCKED;
;;;2015       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;2016       HAL_TIM_OnePulse_MspInit(htim);
;;;2017     }
;;;2018     
;;;2019     /* Set the TIM state */
;;;2020     htim->State= HAL_TIM_STATE_BUSY;  
;;;2021     
;;;2022     /* Configure the Time base in the One Pulse Mode */
;;;2023     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;2024     
;;;2025     /* Reset the OPM Bit */
;;;2026     htim->Instance->CR1 &= ~TIM_CR1_OPM;
;;;2027   
;;;2028     /* Configure the OPM Mode */
;;;2029     htim->Instance->CR1 |= OnePulseMode;
;;;2030      
;;;2031     /* Initialize the TIM state*/
;;;2032     htim->State= HAL_TIM_STATE_READY;
;;;2033     
;;;2034     return HAL_OK;
;;;2035   }
000006  4770              BXEQ     lr
000008  b570              PUSH     {r4-r6,lr}            ;1998
00000a  4604              MOV      r4,r0                 ;1998
00000c  6bc0              LDR      r0,[r0,#0x3c]         ;2011
00000e  460d              MOV      r5,r1                 ;1998
000010  b920              CBNZ     r0,|L62.28|
000012  2000              MOVS     r0,#0                 ;2014
000014  63a0              STR      r0,[r4,#0x38]         ;2016
000016  4620              MOV      r0,r4                 ;2016
000018  f7fffffe          BL       HAL_TIM_OnePulse_MspInit
                  |L62.28|
00001c  2002              MOVS     r0,#2                 ;2020
00001e  63e0              STR      r0,[r4,#0x3c]         ;2020
000020  1d21              ADDS     r1,r4,#4              ;2023
000022  6820              LDR      r0,[r4,#0]            ;2023
000024  f7fffffe          BL       TIM_Base_SetConfig
000028  6820              LDR      r0,[r4,#0]            ;2026
00002a  6801              LDR      r1,[r0,#0]            ;2026
00002c  f0210108          BIC      r1,r1,#8              ;2026
000030  6001              STR      r1,[r0,#0]            ;2026
000032  6820              LDR      r0,[r4,#0]            ;2029
000034  6801              LDR      r1,[r0,#0]            ;2029
000036  4329              ORRS     r1,r1,r5              ;2029
000038  6001              STR      r1,[r0,#0]            ;2029
00003a  2001              MOVS     r0,#1                 ;2032
00003c  63e0              STR      r0,[r4,#0x3c]         ;2032
00003e  2000              MOVS     r0,#0                 ;2034
000040  bd70              POP      {r4-r6,pc}
;;;2036   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_MspDeInit PROC
;;;2085     */
;;;2086   __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2087   {
;;;2088     /* Prevent unused argument(s) compilation warning */
;;;2089     UNUSED(htim);
;;;2090     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2091               the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
;;;2092      */
;;;2093   }
;;;2094   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_MspInit PROC
;;;2070     */
;;;2071   __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2072   {
;;;2073     /* Prevent unused argument(s) compilation warning */
;;;2074     UNUSED(htim);
;;;2075     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2076               the HAL_TIM_OnePulse_MspInit could be implemented in the user file
;;;2077      */
;;;2078   }
;;;2079   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_Start PROC
;;;2104     */
;;;2105   HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  6801              LDR      r1,[r0,#0]
000002  6a0a              LDR      r2,[r1,#0x20]
000004  f0220201          BIC      r2,r2,#1
000008  620a              STR      r2,[r1,#0x20]
00000a  6a0a              LDR      r2,[r1,#0x20]
00000c  f0420201          ORR      r2,r2,#1
000010  620a              STR      r2,[r1,#0x20]
000012  6801              LDR      r1,[r0,#0]
000014  6a0a              LDR      r2,[r1,#0x20]
000016  f0220210          BIC      r2,r2,#0x10
00001a  620a              STR      r2,[r1,#0x20]
00001c  6a0a              LDR      r2,[r1,#0x20]
00001e  f0420210          ORR      r2,r2,#0x10
000022  620a              STR      r2,[r1,#0x20]
;;;2106   {
;;;2107     /* Prevent unused argument(s) compilation warning */
;;;2108     UNUSED(OutputChannel);
;;;2109   
;;;2110     /* Enable the Capture compare and the Input Capture channels 
;;;2111       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2112       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2113       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2114       in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
;;;2115       
;;;2116       No need to enable the counter, it's enabled automatically by hardware 
;;;2117       (the counter starts in response to a stimulus and generate a pulse */
;;;2118     
;;;2119     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
;;;2120     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
;;;2121     
;;;2122     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000024  6800              LDR      r0,[r0,#0]
000026  f1a04180          SUB      r1,r0,#0x40000000
00002a  f5b13180          SUBS     r1,r1,#0x10000
00002e  bf1c              ITT      NE
000030  f1a04180          SUBNE    r1,r0,#0x40000000
000034  f5b13182          SUBSNE   r1,r1,#0x10400
000038  d103              BNE      |L65.66|
;;;2123     {
;;;2124       /* Enable the main output */
;;;2125       __HAL_TIM_MOE_ENABLE(htim);
00003a  6c41              LDR      r1,[r0,#0x44]
00003c  f4414100          ORR      r1,r1,#0x8000
000040  6441              STR      r1,[r0,#0x44]
                  |L65.66|
;;;2126     }
;;;2127     
;;;2128     /* Return function status */
;;;2129     return HAL_OK;
000042  2000              MOVS     r0,#0
;;;2130   }
000044  4770              BX       lr
;;;2131   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_Start_IT PROC
;;;2178     */
;;;2179   HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  6801              LDR      r1,[r0,#0]
;;;2180   {
;;;2181     /* Enable the Capture compare and the Input Capture channels 
;;;2182       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2183       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2184       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2185       in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
;;;2186       
;;;2187       No need to enable the counter, it's enabled automatically by hardware 
;;;2188       (the counter starts in response to a stimulus and generate a pulse */
;;;2189   
;;;2190     /* Prevent unused argument(s) compilation warning */
;;;2191     UNUSED(OutputChannel);
;;;2192   
;;;2193     /* Enable the TIM Capture/Compare 1 interrupt */
;;;2194     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000002  68ca              LDR      r2,[r1,#0xc]
000004  f0420202          ORR      r2,r2,#2
000008  60ca              STR      r2,[r1,#0xc]
;;;2195     
;;;2196     /* Enable the TIM Capture/Compare 2 interrupt */
;;;2197     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00000a  6801              LDR      r1,[r0,#0]
00000c  68ca              LDR      r2,[r1,#0xc]
00000e  f0420204          ORR      r2,r2,#4
000012  60ca              STR      r2,[r1,#0xc]
000014  6801              LDR      r1,[r0,#0]
000016  6a0a              LDR      r2,[r1,#0x20]
000018  f0220201          BIC      r2,r2,#1
00001c  620a              STR      r2,[r1,#0x20]
00001e  6a0a              LDR      r2,[r1,#0x20]
000020  f0420201          ORR      r2,r2,#1
000024  620a              STR      r2,[r1,#0x20]
000026  6801              LDR      r1,[r0,#0]
000028  6a0a              LDR      r2,[r1,#0x20]
00002a  f0220210          BIC      r2,r2,#0x10
00002e  620a              STR      r2,[r1,#0x20]
000030  6a0a              LDR      r2,[r1,#0x20]
000032  f0420210          ORR      r2,r2,#0x10
000036  620a              STR      r2,[r1,#0x20]
;;;2198     
;;;2199     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
;;;2200     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
;;;2201     
;;;2202     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000038  6800              LDR      r0,[r0,#0]
00003a  f1a04180          SUB      r1,r0,#0x40000000
00003e  f5b13180          SUBS     r1,r1,#0x10000
000042  bf1c              ITT      NE
000044  f1a04180          SUBNE    r1,r0,#0x40000000
000048  f5b13182          SUBSNE   r1,r1,#0x10400
00004c  d103              BNE      |L66.86|
;;;2203     {
;;;2204       /* Enable the main output */
;;;2205       __HAL_TIM_MOE_ENABLE(htim);
00004e  6c41              LDR      r1,[r0,#0x44]
000050  f4414100          ORR      r1,r1,#0x8000
000054  6441              STR      r1,[r0,#0x44]
                  |L66.86|
;;;2206     }
;;;2207     
;;;2208     /* Return function status */
;;;2209     return HAL_OK;
000056  2000              MOVS     r0,#0
;;;2210   }
000058  4770              BX       lr
;;;2211   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_Stop PROC
;;;2141     */
;;;2142   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  6801              LDR      r1,[r0,#0]
000002  6a0a              LDR      r2,[r1,#0x20]
000004  f0220201          BIC      r2,r2,#1
000008  620a              STR      r2,[r1,#0x20]
00000a  6a0a              LDR      r2,[r1,#0x20]
00000c  620a              STR      r2,[r1,#0x20]
00000e  6801              LDR      r1,[r0,#0]
000010  6a0a              LDR      r2,[r1,#0x20]
000012  f0220210          BIC      r2,r2,#0x10
000016  620a              STR      r2,[r1,#0x20]
000018  6a0a              LDR      r2,[r1,#0x20]
00001a  620a              STR      r2,[r1,#0x20]
;;;2143   {
;;;2144     /* Prevent unused argument(s) compilation warning */
;;;2145     UNUSED(OutputChannel);
;;;2146   
;;;2147     /* Disable the Capture compare and the Input Capture channels 
;;;2148     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2149     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2150     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2151     in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
;;;2152     
;;;2153     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
;;;2154     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
;;;2155       
;;;2156     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00001c  6801              LDR      r1,[r0,#0]
;;;2157     {
;;;2158       /* Disable the Main Output */
;;;2159       __HAL_TIM_MOE_DISABLE(htim);
00001e  f2411211          MOV      r2,#0x1111
000022  1093              ASRS     r3,r2,#2
000024  f1a14c80          SUB      r12,r1,#0x40000000    ;2156
000028  f5bc3c80          SUBS     r12,r12,#0x10000      ;2156
00002c  bf1c              ITT      NE                    ;2156
00002e  f1a14c80          SUBNE    r12,r1,#0x40000000    ;2156
000032  f5bc3c82          SUBSNE   r12,r12,#0x10400      ;2156
000036  d10f              BNE      |L67.88|
000038  f8d1c020          LDR      r12,[r1,#0x20]
00003c  ea1c0f02          TST      r12,r2
000040  bf04              ITT      EQ
000042  f8d1c020          LDREQ    r12,[r1,#0x20]
000046  ea1c0f03          TSTEQ    r12,r3
00004a  d105              BNE      |L67.88|
00004c  f8d1c044          LDR      r12,[r1,#0x44]
000050  f42c4c00          BIC      r12,r12,#0x8000
000054  f8c1c044          STR      r12,[r1,#0x44]
                  |L67.88|
;;;2160     }
;;;2161       
;;;2162     /* Disable the Peripheral */
;;;2163     __HAL_TIM_DISABLE(htim); 
000058  6800              LDR      r0,[r0,#0]
00005a  6a01              LDR      r1,[r0,#0x20]
00005c  4211              TST      r1,r2
00005e  bf04              ITT      EQ
000060  6a01              LDREQ    r1,[r0,#0x20]
000062  4219              TSTEQ    r1,r3
000064  d103              BNE      |L67.110|
000066  6801              LDR      r1,[r0,#0]
000068  f0210101          BIC      r1,r1,#1
00006c  6001              STR      r1,[r0,#0]
                  |L67.110|
;;;2164     
;;;2165     /* Return function status */
;;;2166     return HAL_OK;
00006e  2000              MOVS     r0,#0
;;;2167   }
000070  4770              BX       lr
;;;2168   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_Stop_IT PROC
;;;2221     */
;;;2222   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  6801              LDR      r1,[r0,#0]
;;;2223   {
;;;2224     /* Prevent unused argument(s) compilation warning */
;;;2225     UNUSED(OutputChannel);
;;;2226   
;;;2227     /* Disable the TIM Capture/Compare 1 interrupt */
;;;2228     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);  
000002  68ca              LDR      r2,[r1,#0xc]
000004  f0220202          BIC      r2,r2,#2
000008  60ca              STR      r2,[r1,#0xc]
;;;2229     
;;;2230     /* Disable the TIM Capture/Compare 2 interrupt */
;;;2231     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00000a  6801              LDR      r1,[r0,#0]
00000c  68ca              LDR      r2,[r1,#0xc]
00000e  f0220204          BIC      r2,r2,#4
000012  60ca              STR      r2,[r1,#0xc]
000014  6801              LDR      r1,[r0,#0]
000016  6a0a              LDR      r2,[r1,#0x20]
000018  f0220201          BIC      r2,r2,#1
00001c  620a              STR      r2,[r1,#0x20]
00001e  6a0a              LDR      r2,[r1,#0x20]
000020  620a              STR      r2,[r1,#0x20]
000022  6801              LDR      r1,[r0,#0]
000024  6a0a              LDR      r2,[r1,#0x20]
000026  f0220210          BIC      r2,r2,#0x10
00002a  620a              STR      r2,[r1,#0x20]
00002c  6a0a              LDR      r2,[r1,#0x20]
00002e  620a              STR      r2,[r1,#0x20]
;;;2232     
;;;2233     /* Disable the Capture compare and the Input Capture channels 
;;;2234     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2235     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2236     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2237     in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */  
;;;2238     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
;;;2239     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
;;;2240       
;;;2241     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000030  6801              LDR      r1,[r0,#0]
;;;2242     {
;;;2243       /* Disable the Main Output */
;;;2244       __HAL_TIM_MOE_DISABLE(htim);
000032  f2411211          MOV      r2,#0x1111
000036  1093              ASRS     r3,r2,#2
000038  f1a14c80          SUB      r12,r1,#0x40000000    ;2241
00003c  f5bc3c80          SUBS     r12,r12,#0x10000      ;2241
000040  bf1c              ITT      NE                    ;2241
000042  f1a14c80          SUBNE    r12,r1,#0x40000000    ;2241
000046  f5bc3c82          SUBSNE   r12,r12,#0x10400      ;2241
00004a  d10f              BNE      |L68.108|
00004c  f8d1c020          LDR      r12,[r1,#0x20]
000050  ea1c0f02          TST      r12,r2
000054  bf04              ITT      EQ
000056  f8d1c020          LDREQ    r12,[r1,#0x20]
00005a  ea1c0f03          TSTEQ    r12,r3
00005e  d105              BNE      |L68.108|
000060  f8d1c044          LDR      r12,[r1,#0x44]
000064  f42c4c00          BIC      r12,r12,#0x8000
000068  f8c1c044          STR      r12,[r1,#0x44]
                  |L68.108|
;;;2245     }
;;;2246       
;;;2247     /* Disable the Peripheral */
;;;2248      __HAL_TIM_DISABLE(htim);  
00006c  6800              LDR      r0,[r0,#0]
00006e  6a01              LDR      r1,[r0,#0x20]
000070  4211              TST      r1,r2
000072  bf04              ITT      EQ
000074  6a01              LDREQ    r1,[r0,#0x20]
000076  4219              TSTEQ    r1,r3
000078  d103              BNE      |L68.130|
00007a  6801              LDR      r1,[r0,#0]
00007c  f0210101          BIC      r1,r1,#1
000080  6001              STR      r1,[r0,#0]
                  |L68.130|
;;;2249     
;;;2250     /* Return function status */
;;;2251     return HAL_OK;
000082  2000              MOVS     r0,#0
;;;2252   }
000084  4770              BX       lr
;;;2253   /**
                          ENDP


                          AREA ||i.HAL_TIM_PWM_ConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_ConfigChannel PROC
;;;3138     */
;;;3139   HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
000000  6b83              LDR      r3,[r0,#0x38]
;;;3140   {
;;;3141     __HAL_LOCK(htim);
000002  2b01              CMP      r3,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;3142     
;;;3143     /* Check the parameters */ 
;;;3144     assert_param(IS_TIM_CHANNELS(Channel)); 
;;;3145     assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
;;;3146     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;3147     assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
;;;3148   
;;;3149     htim->State = HAL_TIM_STATE_BUSY;
;;;3150       
;;;3151     switch (Channel)
;;;3152     {
;;;3153       case TIM_CHANNEL_1:
;;;3154       {
;;;3155         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3156         /* Configure the Channel 1 in PWM mode */
;;;3157         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;3158         
;;;3159         /* Set the Preload enable bit for channel1 */
;;;3160         htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
;;;3161         
;;;3162         /* Configure the Output Fast mode */
;;;3163         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
;;;3164         htim->Instance->CCMR1 |= sConfig->OCFastMode;
;;;3165       }
;;;3166       break;
;;;3167       
;;;3168       case TIM_CHANNEL_2:
;;;3169       {
;;;3170         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3171         /* Configure the Channel 2 in PWM mode */
;;;3172         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;3173         
;;;3174         /* Set the Preload enable bit for channel2 */
;;;3175         htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
;;;3176         
;;;3177         /* Configure the Output Fast mode */
;;;3178         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
;;;3179         htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
;;;3180       }
;;;3181       break;
;;;3182       
;;;3183       case TIM_CHANNEL_3:
;;;3184       {
;;;3185         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3186         /* Configure the Channel 3 in PWM mode */
;;;3187         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;3188         
;;;3189         /* Set the Preload enable bit for channel3 */
;;;3190         htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
;;;3191         
;;;3192        /* Configure the Output Fast mode */
;;;3193         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
;;;3194         htim->Instance->CCMR2 |= sConfig->OCFastMode;  
;;;3195       }
;;;3196       break;
;;;3197       
;;;3198       case TIM_CHANNEL_4:
;;;3199       {
;;;3200         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3201         /* Configure the Channel 4 in PWM mode */
;;;3202         TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;3203         
;;;3204         /* Set the Preload enable bit for channel4 */
;;;3205         htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
;;;3206         
;;;3207        /* Configure the Output Fast mode */
;;;3208         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
;;;3209         htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;  
;;;3210       }
;;;3211       break;
;;;3212       
;;;3213       default:
;;;3214       break;    
;;;3215     }
;;;3216     
;;;3217     htim->State = HAL_TIM_STATE_READY;
;;;3218       
;;;3219     __HAL_UNLOCK(htim);
;;;3220     
;;;3221     return HAL_OK;
;;;3222   }
000008  4770              BXEQ     lr
00000a  e92d01f0          PUSH     {r4-r8}               ;3140
00000e  2401              MOVS     r4,#1                 ;3141
000010  2302              MOVS     r3,#2                 ;3149
000012  6384              STR      r4,[r0,#0x38]         ;3149
000014  63c3              STR      r3,[r0,#0x3c]         ;3149
000016  4b82              LDR      r3,|L69.544|
000018  f8dfc208          LDR      r12,|L69.548|
00001c  b142              CBZ      r2,|L69.48|
00001e  2a04              CMP      r2,#4                 ;3151
000020  d044              BEQ      |L69.172|
000022  2a08              CMP      r2,#8                 ;3151
000024  d07e              BEQ      |L69.292|
000026  2a0c              CMP      r2,#0xc               ;3151
000028  f00080c0          BEQ.W    |L69.428|
00002c  f000b8f1          B.W      |L69.530|
                  |L69.48|
000030  6802              LDR      r2,[r0,#0]            ;3151
000032  6a15              LDR      r5,[r2,#0x20]         ;3151
000034  f0250501          BIC      r5,r5,#1              ;3151
000038  6215              STR      r5,[r2,#0x20]         ;3151
00003a  6a15              LDR      r5,[r2,#0x20]         ;3151
00003c  6856              LDR      r6,[r2,#4]            ;3151
00003e  6997              LDR      r7,[r2,#0x18]         ;3151
000040  f8d18000          LDR      r8,[r1,#0]            ;3151
000044  f0270773          BIC      r7,r7,#0x73           ;3151
000048  ea480707          ORR      r7,r8,r7              ;3151
00004c  f8d18008          LDR      r8,[r1,#8]            ;3151
000050  f0250502          BIC      r5,r5,#2              ;3151
000054  ea480505          ORR      r5,r8,r5              ;3151
000058  429a              CMP      r2,r3                 ;3151
00005a  bf18              IT       NE                    ;3151
00005c  4562              CMPNE    r2,r12                ;3151
00005e  d111              BNE      |L69.132|
000060  f8d1c00c          LDR      r12,[r1,#0xc]         ;3157
000064  f0250308          BIC      r3,r5,#8              ;3157
000068  ea4c0303          ORR      r3,r12,r3             ;3157
00006c  f0230504          BIC      r5,r3,#4              ;3157
000070  f8d1c014          LDR      r12,[r1,#0x14]        ;3157
000074  f4267340          BIC      r3,r6,#0x300          ;3157
000078  ea4c0303          ORR      r3,r12,r3             ;3157
00007c  f8d1c018          LDR      r12,[r1,#0x18]        ;3157
000080  ea4c0603          ORR      r6,r12,r3             ;3157
                  |L69.132|
000084  6056              STR      r6,[r2,#4]            ;3157
000086  6197              STR      r7,[r2,#0x18]         ;3157
000088  684b              LDR      r3,[r1,#4]            ;3157
00008a  6353              STR      r3,[r2,#0x34]         ;3157
00008c  6215              STR      r5,[r2,#0x20]         ;3157
00008e  6802              LDR      r2,[r0,#0]            ;3160
000090  6993              LDR      r3,[r2,#0x18]         ;3160
000092  f0430308          ORR      r3,r3,#8              ;3160
000096  6193              STR      r3,[r2,#0x18]         ;3160
000098  6802              LDR      r2,[r0,#0]            ;3163
00009a  6993              LDR      r3,[r2,#0x18]         ;3163
00009c  f0230304          BIC      r3,r3,#4              ;3163
0000a0  6193              STR      r3,[r2,#0x18]         ;3163
0000a2  6802              LDR      r2,[r0,#0]            ;3164
0000a4  6993              LDR      r3,[r2,#0x18]         ;3164
0000a6  6909              LDR      r1,[r1,#0x10]         ;3164
0000a8  4319              ORRS     r1,r1,r3              ;3164
0000aa  e03f              B        |L69.300|
                  |L69.172|
0000ac  6802              LDR      r2,[r0,#0]            ;3166
0000ae  6a15              LDR      r5,[r2,#0x20]         ;3166
0000b0  f0250510          BIC      r5,r5,#0x10           ;3166
0000b4  6215              STR      r5,[r2,#0x20]         ;3166
0000b6  6a15              LDR      r5,[r2,#0x20]         ;3166
0000b8  6856              LDR      r6,[r2,#4]            ;3166
0000ba  6997              LDR      r7,[r2,#0x18]         ;3166
0000bc  f8d18000          LDR      r8,[r1,#0]            ;3166
0000c0  f42747e6          BIC      r7,r7,#0x7300         ;3166
0000c4  ea472708          ORR      r7,r7,r8,LSL #8       ;3166
0000c8  f8d18008          LDR      r8,[r1,#8]            ;3166
0000cc  f0250520          BIC      r5,r5,#0x20           ;3166
0000d0  ea451508          ORR      r5,r5,r8,LSL #4       ;3166
0000d4  429a              CMP      r2,r3                 ;3166
0000d6  bf18              IT       NE                    ;3166
0000d8  4562              CMPNE    r2,r12                ;3166
0000da  d111              BNE      |L69.256|
0000dc  f8d1c00c          LDR      r12,[r1,#0xc]         ;3172
0000e0  f0250380          BIC      r3,r5,#0x80           ;3172
0000e4  ea43130c          ORR      r3,r3,r12,LSL #4      ;3172
0000e8  f0230540          BIC      r5,r3,#0x40           ;3172
0000ec  f8d1c014          LDR      r12,[r1,#0x14]        ;3172
0000f0  f4266340          BIC      r3,r6,#0xc00          ;3172
0000f4  ea43038c          ORR      r3,r3,r12,LSL #2      ;3172
0000f8  f8d1c018          LDR      r12,[r1,#0x18]        ;3172
0000fc  ea43068c          ORR      r6,r3,r12,LSL #2      ;3172
                  |L69.256|
000100  6056              STR      r6,[r2,#4]            ;3172
000102  6197              STR      r7,[r2,#0x18]         ;3172
000104  684b              LDR      r3,[r1,#4]            ;3172
000106  6393              STR      r3,[r2,#0x38]         ;3172
000108  6215              STR      r5,[r2,#0x20]         ;3172
00010a  6802              LDR      r2,[r0,#0]            ;3175
00010c  6993              LDR      r3,[r2,#0x18]         ;3175
00010e  f4436300          ORR      r3,r3,#0x800          ;3175
000112  6193              STR      r3,[r2,#0x18]         ;3175
000114  6802              LDR      r2,[r0,#0]            ;3178
000116  6993              LDR      r3,[r2,#0x18]         ;3178
000118  f4236380          BIC      r3,r3,#0x400          ;3178
00011c  6193              STR      r3,[r2,#0x18]         ;3178
00011e  6802              LDR      r2,[r0,#0]            ;3179
000120  6993              LDR      r3,[r2,#0x18]         ;3179
000122  e000              B        |L69.294|
                  |L69.292|
000124  e004              B        |L69.304|
                  |L69.294|
000126  6909              LDR      r1,[r1,#0x10]         ;3179
000128  ea432101          ORR      r1,r3,r1,LSL #8       ;3179
                  |L69.300|
00012c  6191              STR      r1,[r2,#0x18]         ;3164
00012e  e070              B        |L69.530|
                  |L69.304|
000130  6802              LDR      r2,[r0,#0]            ;3164
000132  6a15              LDR      r5,[r2,#0x20]         ;3164
000134  f4257580          BIC      r5,r5,#0x100          ;3164
000138  6215              STR      r5,[r2,#0x20]         ;3164
00013a  6a16              LDR      r6,[r2,#0x20]         ;3164
00013c  6855              LDR      r5,[r2,#4]            ;3164
00013e  69d7              LDR      r7,[r2,#0x1c]         ;3164
000140  f8d18000          LDR      r8,[r1,#0]            ;3164
000144  f0270773          BIC      r7,r7,#0x73           ;3164
000148  ea480707          ORR      r7,r8,r7              ;3164
00014c  f8d18008          LDR      r8,[r1,#8]            ;3164
000150  f4267600          BIC      r6,r6,#0x200          ;3164
000154  ea462608          ORR      r6,r6,r8,LSL #8       ;3164
000158  429a              CMP      r2,r3                 ;3164
00015a  bf18              IT       NE                    ;3164
00015c  4562              CMPNE    r2,r12                ;3164
00015e  d111              BNE      |L69.388|
000160  f8d1c00c          LDR      r12,[r1,#0xc]         ;3187
000164  f4266300          BIC      r3,r6,#0x800          ;3187
000168  ea43230c          ORR      r3,r3,r12,LSL #8      ;3187
00016c  f4236680          BIC      r6,r3,#0x400          ;3187
000170  f8d1c014          LDR      r12,[r1,#0x14]        ;3187
000174  f4255340          BIC      r3,r5,#0x3000         ;3187
000178  ea43130c          ORR      r3,r3,r12,LSL #4      ;3187
00017c  f8d1c018          LDR      r12,[r1,#0x18]        ;3187
000180  ea43150c          ORR      r5,r3,r12,LSL #4      ;3187
                  |L69.388|
000184  6055              STR      r5,[r2,#4]            ;3187
000186  61d7              STR      r7,[r2,#0x1c]         ;3187
000188  684b              LDR      r3,[r1,#4]            ;3187
00018a  63d3              STR      r3,[r2,#0x3c]         ;3187
00018c  6216              STR      r6,[r2,#0x20]         ;3187
00018e  6802              LDR      r2,[r0,#0]            ;3190
000190  69d3              LDR      r3,[r2,#0x1c]         ;3190
000192  f0430308          ORR      r3,r3,#8              ;3190
000196  61d3              STR      r3,[r2,#0x1c]         ;3190
000198  6802              LDR      r2,[r0,#0]            ;3193
00019a  69d3              LDR      r3,[r2,#0x1c]         ;3193
00019c  f0230304          BIC      r3,r3,#4              ;3193
0001a0  61d3              STR      r3,[r2,#0x1c]         ;3193
0001a2  6802              LDR      r2,[r0,#0]            ;3194
0001a4  69d3              LDR      r3,[r2,#0x1c]         ;3194
0001a6  6909              LDR      r1,[r1,#0x10]         ;3194
0001a8  4319              ORRS     r1,r1,r3              ;3194
0001aa  e031              B        |L69.528|
                  |L69.428|
0001ac  6802              LDR      r2,[r0,#0]            ;3196
0001ae  6a15              LDR      r5,[r2,#0x20]         ;3196
0001b0  f4255580          BIC      r5,r5,#0x1000         ;3196
0001b4  6215              STR      r5,[r2,#0x20]         ;3196
0001b6  6a17              LDR      r7,[r2,#0x20]         ;3196
0001b8  6855              LDR      r5,[r2,#4]            ;3196
0001ba  69d6              LDR      r6,[r2,#0x1c]         ;3196
0001bc  f8d18000          LDR      r8,[r1,#0]            ;3196
0001c0  f42646e6          BIC      r6,r6,#0x7300         ;3196
0001c4  ea462608          ORR      r6,r6,r8,LSL #8       ;3196
0001c8  f8d18008          LDR      r8,[r1,#8]            ;3196
0001cc  f4275700          BIC      r7,r7,#0x2000         ;3196
0001d0  ea473708          ORR      r7,r7,r8,LSL #12      ;3196
0001d4  429a              CMP      r2,r3                 ;3196
0001d6  bf18              IT       NE                    ;3196
0001d8  4562              CMPNE    r2,r12                ;3196
0001da  d105              BNE      |L69.488|
0001dc  f8d1c014          LDR      r12,[r1,#0x14]        ;3202
0001e0  f4254380          BIC      r3,r5,#0x4000         ;3202
0001e4  ea43158c          ORR      r5,r3,r12,LSL #6      ;3202
                  |L69.488|
0001e8  6055              STR      r5,[r2,#4]            ;3202
0001ea  61d6              STR      r6,[r2,#0x1c]         ;3202
0001ec  684b              LDR      r3,[r1,#4]            ;3202
0001ee  6413              STR      r3,[r2,#0x40]         ;3202
0001f0  6217              STR      r7,[r2,#0x20]         ;3202
0001f2  6802              LDR      r2,[r0,#0]            ;3205
0001f4  69d3              LDR      r3,[r2,#0x1c]         ;3205
0001f6  f4436300          ORR      r3,r3,#0x800          ;3205
0001fa  61d3              STR      r3,[r2,#0x1c]         ;3205
0001fc  6802              LDR      r2,[r0,#0]            ;3208
0001fe  69d3              LDR      r3,[r2,#0x1c]         ;3208
000200  f4236380          BIC      r3,r3,#0x400          ;3208
000204  61d3              STR      r3,[r2,#0x1c]         ;3208
000206  6802              LDR      r2,[r0,#0]            ;3209
000208  69d3              LDR      r3,[r2,#0x1c]         ;3209
00020a  6909              LDR      r1,[r1,#0x10]         ;3209
00020c  ea432101          ORR      r1,r3,r1,LSL #8       ;3209
                  |L69.528|
000210  61d1              STR      r1,[r2,#0x1c]         ;3194
                  |L69.530|
000212  63c4              STR      r4,[r0,#0x3c]         ;3217
000214  2100              MOVS     r1,#0                 ;3219
000216  6381              STR      r1,[r0,#0x38]         ;3221
000218  e8bd01f0          POP      {r4-r8}
00021c  4608              MOV      r0,r1                 ;3221
00021e  4770              BX       lr
;;;3223   
                          ENDP

                  |L69.544|
                          DCD      0x40010000
                  |L69.548|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PWM_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_DeInit PROC
;;;1038     */
;;;1039   HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1040   {
000002  4604              MOV      r4,r0
;;;1041     /* Check the parameters */
;;;1042     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1043     
;;;1044     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  63e0              STR      r0,[r4,#0x3c]
;;;1045     
;;;1046     /* Disable the TIM Peripheral Clock */
;;;1047     __HAL_TIM_DISABLE(htim);
000008  6820              LDR      r0,[r4,#0]
00000a  6a01              LDR      r1,[r0,#0x20]
00000c  f2411211          MOV      r2,#0x1111
000010  4211              TST      r1,r2
000012  d107              BNE      |L70.36|
000014  6a01              LDR      r1,[r0,#0x20]
000016  1092              ASRS     r2,r2,#2
000018  4211              TST      r1,r2
00001a  d103              BNE      |L70.36|
00001c  6801              LDR      r1,[r0,#0]
00001e  f0210101          BIC      r1,r1,#1
000022  6001              STR      r1,[r0,#0]
                  |L70.36|
;;;1048       
;;;1049     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;1050     HAL_TIM_PWM_MspDeInit(htim);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       HAL_TIM_PWM_MspDeInit
;;;1051       
;;;1052     /* Change TIM state */  
;;;1053     htim->State = HAL_TIM_STATE_RESET; 
00002a  2000              MOVS     r0,#0
00002c  63e0              STR      r0,[r4,#0x3c]
;;;1054   
;;;1055     /* Release Lock */
;;;1056     __HAL_UNLOCK(htim);
00002e  63a0              STR      r0,[r4,#0x38]
;;;1057   
;;;1058     return HAL_OK;
;;;1059   }
000030  bd10              POP      {r4,pc}
;;;1060   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_GetState PROC
;;;4433     */
;;;4434   HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
000000  6bc0              LDR      r0,[r0,#0x3c]
;;;4435   {
;;;4436     return htim->State;
;;;4437   }
000002  4770              BX       lr
;;;4438   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_Init PROC
;;;999      */
;;;1000   HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
000000  2800              CMP      r0,#0
;;;1001   {
;;;1002     /* Check the TIM handle allocation */
;;;1003     if(htim == NULL)
;;;1004     {
;;;1005       return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;1006     }
;;;1007   
;;;1008     /* Check the parameters */
;;;1009     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1010     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1011     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;1012   
;;;1013     if(htim->State == HAL_TIM_STATE_RESET)
;;;1014     {
;;;1015       /* Allocate lock resource and initialize it */
;;;1016       htim->Lock = HAL_UNLOCKED;
;;;1017       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1018       HAL_TIM_PWM_MspInit(htim);
;;;1019     }
;;;1020   
;;;1021     /* Set the TIM state */
;;;1022     htim->State= HAL_TIM_STATE_BUSY;  
;;;1023     
;;;1024     /* Init the base time for the PWM */  
;;;1025     TIM_Base_SetConfig(htim->Instance, &htim->Init); 
;;;1026      
;;;1027     /* Initialize the TIM state*/
;;;1028     htim->State= HAL_TIM_STATE_READY;
;;;1029     
;;;1030     return HAL_OK;
;;;1031   }  
000006  4770              BXEQ     lr
000008  b510              PUSH     {r4,lr}               ;1001
00000a  4604              MOV      r4,r0                 ;1001
00000c  6bc0              LDR      r0,[r0,#0x3c]         ;1013
00000e  b920              CBNZ     r0,|L72.26|
000010  2000              MOVS     r0,#0                 ;1016
000012  63a0              STR      r0,[r4,#0x38]         ;1018
000014  4620              MOV      r0,r4                 ;1018
000016  f7fffffe          BL       HAL_TIM_PWM_MspInit
                  |L72.26|
00001a  2002              MOVS     r0,#2                 ;1022
00001c  63e0              STR      r0,[r4,#0x3c]         ;1022
00001e  1d21              ADDS     r1,r4,#4              ;1025
000020  6820              LDR      r0,[r4,#0]            ;1025
000022  f7fffffe          BL       TIM_Base_SetConfig
000026  2001              MOVS     r0,#1                 ;1028
000028  63e0              STR      r0,[r4,#0x3c]         ;1028
00002a  2000              MOVS     r0,#0                 ;1030
00002c  bd10              POP      {r4,pc}
;;;1032   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_MspDeInit PROC
;;;1081     */
;;;1082   __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1083   {
;;;1084     /* Prevent unused argument(s) compilation warning */
;;;1085     UNUSED(htim);
;;;1086     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1087               the HAL_TIM_PWM_MspDeInit could be implemented in the user file
;;;1088      */
;;;1089   }
;;;1090   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_MspInit PROC
;;;1066     */
;;;1067   __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1068   {
;;;1069     /* Prevent unused argument(s) compilation warning */
;;;1070     UNUSED(htim);
;;;1071     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1072               the HAL_TIM_PWM_MspInit could be implemented in the user file
;;;1073      */
;;;1074   }
;;;1075   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_PulseFinishedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_PulseFinishedCallback PROC
;;;4348     */
;;;4349   __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4350   {
;;;4351     /* Prevent unused argument(s) compilation warning */
;;;4352     UNUSED(htim);
;;;4353     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4354               the __HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
;;;4355      */
;;;4356   }
;;;4357   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_Start PROC
;;;1102     */
;;;1103   HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
000002  2301              MOVS     r3,#1
000004  fa03f101          LSL      r1,r3,r1
000008  6a13              LDR      r3,[r2,#0x20]
00000a  438b              BICS     r3,r3,r1
00000c  6213              STR      r3,[r2,#0x20]
00000e  6a13              LDR      r3,[r2,#0x20]
000010  4319              ORRS     r1,r1,r3
000012  6211              STR      r1,[r2,#0x20]
;;;1104   {
;;;1105     /* Check the parameters */
;;;1106     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1107   
;;;1108     /* Enable the Capture compare channel */
;;;1109     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1110     
;;;1111     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000014  6801              LDR      r1,[r0,#0]
000016  f1a14280          SUB      r2,r1,#0x40000000
00001a  f5b23280          SUBS     r2,r2,#0x10000
00001e  bf1c              ITT      NE
000020  f1a14280          SUBNE    r2,r1,#0x40000000
000024  f5b23282          SUBSNE   r2,r2,#0x10400
000028  d103              BNE      |L76.50|
;;;1112     {
;;;1113       /* Enable the main output */
;;;1114       __HAL_TIM_MOE_ENABLE(htim);
00002a  6c4a              LDR      r2,[r1,#0x44]
00002c  f4424200          ORR      r2,r2,#0x8000
000030  644a              STR      r2,[r1,#0x44]
                  |L76.50|
;;;1115     }
;;;1116       
;;;1117     /* Enable the Peripheral */
;;;1118     __HAL_TIM_ENABLE(htim);
000032  6800              LDR      r0,[r0,#0]
000034  6801              LDR      r1,[r0,#0]
000036  f0410101          ORR      r1,r1,#1
00003a  6001              STR      r1,[r0,#0]
;;;1119     
;;;1120     /* Return function status */
;;;1121     return HAL_OK;
00003c  2000              MOVS     r0,#0
;;;1122   } 
00003e  4770              BX       lr
;;;1123   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start_DMA PROC
;;;1307     */
;;;1308   HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;1309   {
000002  4604              MOV      r4,r0
;;;1310     /* Check the parameters */
;;;1311     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1312     
;;;1313     if((htim->State == HAL_TIM_STATE_BUSY))
000004  6bc0              LDR      r0,[r0,#0x3c]
000006  4694              MOV      r12,r2                ;1309
000008  460d              MOV      r5,r1                 ;1309
00000a  2802              CMP      r0,#2
;;;1314     {
;;;1315        return HAL_BUSY;
;;;1316     }
;;;1317     else if((htim->State == HAL_TIM_STATE_READY))
;;;1318     {
;;;1319       if(((uint32_t)pData == 0U) && (Length > 0)) 
;;;1320       {
;;;1321         return HAL_ERROR;                                    
;;;1322       }
;;;1323       else
;;;1324       {
;;;1325         htim->State = HAL_TIM_STATE_BUSY;
;;;1326       }
;;;1327     }    
;;;1328     switch (Channel)
;;;1329     {
;;;1330       case TIM_CHANNEL_1:
;;;1331       {      
;;;1332         /* Set the DMA Period elapsed callback */
;;;1333         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1334        
;;;1335         /* Set the DMA error callback */
;;;1336         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;1337         
;;;1338         /* Enable the DMA Stream */
;;;1339         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;1340         
;;;1341         /* Enable the TIM Capture/Compare 1 DMA request */
;;;1342         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1343       }
;;;1344       break;
;;;1345       
;;;1346       case TIM_CHANNEL_2:
;;;1347       {
;;;1348         /* Set the DMA Period elapsed callback */
;;;1349         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1350        
;;;1351         /* Set the DMA error callback */
;;;1352         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;1353         
;;;1354         /* Enable the DMA Stream */
;;;1355         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;1356         
;;;1357         /* Enable the TIM Capture/Compare 2 DMA request */
;;;1358         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1359       }
;;;1360       break;
;;;1361       
;;;1362       case TIM_CHANNEL_3:
;;;1363       {
;;;1364         /* Set the DMA Period elapsed callback */
;;;1365         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1366        
;;;1367         /* Set the DMA error callback */
;;;1368         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;1369         
;;;1370         /* Enable the DMA Stream */
;;;1371         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;1372         
;;;1373         /* Enable the TIM Output Capture/Compare 3 request */
;;;1374         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1375       }
;;;1376       break;
;;;1377       
;;;1378       case TIM_CHANNEL_4:
;;;1379       {
;;;1380        /* Set the DMA Period elapsed callback */
;;;1381         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1382        
;;;1383         /* Set the DMA error callback */
;;;1384         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;1385         
;;;1386         /* Enable the DMA Stream */
;;;1387         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;1388         
;;;1389         /* Enable the TIM Capture/Compare 4 DMA request */
;;;1390         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1391       }
;;;1392       break;
;;;1393       
;;;1394       default:
;;;1395       break;
;;;1396     }
;;;1397   
;;;1398     /* Enable the Capture compare channel */
;;;1399     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1400       
;;;1401     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
;;;1402     {
;;;1403       /* Enable the main output */
;;;1404       __HAL_TIM_MOE_ENABLE(htim);
;;;1405     }
;;;1406     
;;;1407     /* Enable the Peripheral */
;;;1408     __HAL_TIM_ENABLE(htim); 
;;;1409     
;;;1410     /* Return function status */
;;;1411     return HAL_OK;
;;;1412   }
00000c  bf08              IT       EQ
00000e  bd70              POPEQ    {r4-r6,pc}
000010  6be0              LDR      r0,[r4,#0x3c]         ;1317
000012  2801              CMP      r0,#1                 ;1317
000014  d108              BNE      |L77.40|
000016  f1bc0f00          CMP      r12,#0                ;1319
00001a  d103              BNE      |L77.36|
00001c  2b00              CMP      r3,#0                 ;1319
00001e  bf1c              ITT      NE                    ;1321
000020  2001              MOVNE    r0,#1                 ;1321
000022  bd70              POPNE    {r4-r6,pc}
                  |L77.36|
000024  2002              MOVS     r0,#2                 ;1325
000026  63e0              STR      r0,[r4,#0x3c]         ;1325
                  |L77.40|
000028  4834              LDR      r0,|L77.252|
00002a  4935              LDR      r1,|L77.256|
00002c  b135              CBZ      r5,|L77.60|
00002e  2d04              CMP      r5,#4                 ;1328
000030  d014              BEQ      |L77.92|
000032  2d08              CMP      r5,#8                 ;1328
000034  d022              BEQ      |L77.124|
000036  2d0c              CMP      r5,#0xc               ;1328
000038  d030              BEQ      |L77.156|
00003a  e03f              B        |L77.188|
                  |L77.60|
00003c  6a22              LDR      r2,[r4,#0x20]         ;1333
00003e  6410              STR      r0,[r2,#0x40]         ;1336
000040  6a20              LDR      r0,[r4,#0x20]         ;1336
000042  6501              STR      r1,[r0,#0x50]         ;1339
000044  6820              LDR      r0,[r4,#0]            ;1339
000046  4661              MOV      r1,r12                ;1339
000048  f1000234          ADD      r2,r0,#0x34           ;1339
00004c  6a20              LDR      r0,[r4,#0x20]         ;1339
00004e  f7fffffe          BL       HAL_DMA_Start_IT
000052  6820              LDR      r0,[r4,#0]            ;1342
000054  68c1              LDR      r1,[r0,#0xc]          ;1342
000056  f4417100          ORR      r1,r1,#0x200          ;1342
00005a  e02e              B        |L77.186|
                  |L77.92|
00005c  6a62              LDR      r2,[r4,#0x24]         ;1349
00005e  6410              STR      r0,[r2,#0x40]         ;1352
000060  6a60              LDR      r0,[r4,#0x24]         ;1352
000062  6501              STR      r1,[r0,#0x50]         ;1355
000064  6820              LDR      r0,[r4,#0]            ;1355
000066  4661              MOV      r1,r12                ;1355
000068  f1000238          ADD      r2,r0,#0x38           ;1355
00006c  6a60              LDR      r0,[r4,#0x24]         ;1355
00006e  f7fffffe          BL       HAL_DMA_Start_IT
000072  6820              LDR      r0,[r4,#0]            ;1358
000074  68c1              LDR      r1,[r0,#0xc]          ;1358
000076  f4416180          ORR      r1,r1,#0x400          ;1358
00007a  e01e              B        |L77.186|
                  |L77.124|
00007c  6aa2              LDR      r2,[r4,#0x28]         ;1365
00007e  6410              STR      r0,[r2,#0x40]         ;1368
000080  6aa0              LDR      r0,[r4,#0x28]         ;1368
000082  6501              STR      r1,[r0,#0x50]         ;1371
000084  6820              LDR      r0,[r4,#0]            ;1371
000086  4661              MOV      r1,r12                ;1371
000088  f100023c          ADD      r2,r0,#0x3c           ;1371
00008c  6aa0              LDR      r0,[r4,#0x28]         ;1371
00008e  f7fffffe          BL       HAL_DMA_Start_IT
000092  6820              LDR      r0,[r4,#0]            ;1374
000094  68c1              LDR      r1,[r0,#0xc]          ;1374
000096  f4416100          ORR      r1,r1,#0x800          ;1374
00009a  e00e              B        |L77.186|
                  |L77.156|
00009c  6ae2              LDR      r2,[r4,#0x2c]         ;1381
00009e  6410              STR      r0,[r2,#0x40]         ;1384
0000a0  6ae0              LDR      r0,[r4,#0x2c]         ;1384
0000a2  6501              STR      r1,[r0,#0x50]         ;1387
0000a4  6820              LDR      r0,[r4,#0]            ;1387
0000a6  4661              MOV      r1,r12                ;1387
0000a8  f1000240          ADD      r2,r0,#0x40           ;1387
0000ac  6ae0              LDR      r0,[r4,#0x2c]         ;1387
0000ae  f7fffffe          BL       HAL_DMA_Start_IT
0000b2  6820              LDR      r0,[r4,#0]            ;1390
0000b4  68c1              LDR      r1,[r0,#0xc]          ;1390
0000b6  f4415180          ORR      r1,r1,#0x1000         ;1390
                  |L77.186|
0000ba  60c1              STR      r1,[r0,#0xc]          ;1374
                  |L77.188|
0000bc  6820              LDR      r0,[r4,#0]            ;1374
0000be  2101              MOVS     r1,#1                 ;1374
0000c0  40a9              LSLS     r1,r1,r5              ;1374
0000c2  6a02              LDR      r2,[r0,#0x20]         ;1374
0000c4  438a              BICS     r2,r2,r1              ;1374
0000c6  6202              STR      r2,[r0,#0x20]         ;1374
0000c8  6a02              LDR      r2,[r0,#0x20]         ;1374
0000ca  4311              ORRS     r1,r1,r2              ;1374
0000cc  6201              STR      r1,[r0,#0x20]         ;1374
0000ce  6820              LDR      r0,[r4,#0]            ;1401
0000d0  f1a04180          SUB      r1,r0,#0x40000000     ;1401
0000d4  f5b13180          SUBS     r1,r1,#0x10000        ;1401
0000d8  bf1c              ITT      NE                    ;1401
0000da  f1a04180          SUBNE    r1,r0,#0x40000000     ;1401
0000de  f5b13182          SUBSNE   r1,r1,#0x10400        ;1401
0000e2  d103              BNE      |L77.236|
0000e4  6c41              LDR      r1,[r0,#0x44]         ;1404
0000e6  f4414100          ORR      r1,r1,#0x8000         ;1404
0000ea  6441              STR      r1,[r0,#0x44]         ;1404
                  |L77.236|
0000ec  6820              LDR      r0,[r4,#0]            ;1408
0000ee  6801              LDR      r1,[r0,#0]            ;1408
0000f0  f0410101          ORR      r1,r1,#1              ;1408
0000f4  6001              STR      r1,[r0,#0]            ;1408
0000f6  2000              MOVS     r0,#0                 ;1411
0000f8  bd70              POP      {r4-r6,pc}
;;;1413   
                          ENDP

0000fa  0000              DCW      0x0000
                  |L77.252|
                          DCD      TIM_DMADelayPulseCplt
                  |L77.256|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_PWM_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_Start_IT PROC
;;;1171     */
;;;1172   HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
;;;1173   {
;;;1174     /* Check the parameters */
;;;1175     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1176     
;;;1177     switch (Channel)
000002  2900              CMP      r1,#0
;;;1178     {
;;;1179       case TIM_CHANNEL_1:
;;;1180       {       
;;;1181         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1182         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000004  bf04              ITT      EQ
000006  68d3              LDREQ    r3,[r2,#0xc]
000008  f0430302          ORREQ    r3,r3,#2
00000c  d011              BEQ      |L78.50|
00000e  2904              CMP      r1,#4                 ;1177
;;;1183       }
;;;1184       break;
;;;1185       
;;;1186       case TIM_CHANNEL_2:
;;;1187       {
;;;1188         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1189         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000010  bf04              ITT      EQ
000012  68d3              LDREQ    r3,[r2,#0xc]
000014  f0430304          ORREQ    r3,r3,#4
000018  d00b              BEQ      |L78.50|
00001a  2908              CMP      r1,#8                 ;1177
;;;1190       }
;;;1191       break;
;;;1192       
;;;1193       case TIM_CHANNEL_3:
;;;1194       {
;;;1195         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1196         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
00001c  bf04              ITT      EQ
00001e  68d3              LDREQ    r3,[r2,#0xc]
000020  f0430308          ORREQ    r3,r3,#8
000024  d005              BEQ      |L78.50|
000026  290c              CMP      r1,#0xc               ;1177
;;;1197       }
;;;1198       break;
;;;1199       
;;;1200       case TIM_CHANNEL_4:
;;;1201       {
;;;1202         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1203         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000028  bf04              ITT      EQ
00002a  68d3              LDREQ    r3,[r2,#0xc]
00002c  f0430310          ORREQ    r3,r3,#0x10
000030  d100              BNE      |L78.52|
                  |L78.50|
000032  60d3              STR      r3,[r2,#0xc]          ;1196
                  |L78.52|
000034  6802              LDR      r2,[r0,#0]            ;1196
000036  2301              MOVS     r3,#1                 ;1196
000038  fa03f101          LSL      r1,r3,r1              ;1196
00003c  6a13              LDR      r3,[r2,#0x20]         ;1196
00003e  438b              BICS     r3,r3,r1              ;1196
000040  6213              STR      r3,[r2,#0x20]         ;1196
000042  6a13              LDR      r3,[r2,#0x20]         ;1196
000044  4319              ORRS     r1,r1,r3              ;1196
000046  6211              STR      r1,[r2,#0x20]         ;1196
;;;1204       }
;;;1205       break;
;;;1206       
;;;1207       default:
;;;1208       break;
;;;1209     } 
;;;1210     
;;;1211     /* Enable the Capture compare channel */
;;;1212     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1213     
;;;1214     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000048  6801              LDR      r1,[r0,#0]
00004a  f1a14280          SUB      r2,r1,#0x40000000
00004e  f5b23280          SUBS     r2,r2,#0x10000
000052  bf1c              ITT      NE
000054  f1a14280          SUBNE    r2,r1,#0x40000000
000058  f5b23282          SUBSNE   r2,r2,#0x10400
00005c  d103              BNE      |L78.102|
;;;1215     {
;;;1216       /* Enable the main output */
;;;1217       __HAL_TIM_MOE_ENABLE(htim);
00005e  6c4a              LDR      r2,[r1,#0x44]
000060  f4424200          ORR      r2,r2,#0x8000
000064  644a              STR      r2,[r1,#0x44]
                  |L78.102|
;;;1218     }
;;;1219   
;;;1220     /* Enable the Peripheral */
;;;1221     __HAL_TIM_ENABLE(htim);
000066  6800              LDR      r0,[r0,#0]
000068  6801              LDR      r1,[r0,#0]
00006a  f0410101          ORR      r1,r1,#1
00006e  6001              STR      r1,[r0,#0]
;;;1222     
;;;1223     /* Return function status */
;;;1224     return HAL_OK;
000070  2000              MOVS     r0,#0
;;;1225   } 
000072  4770              BX       lr
;;;1226   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_Stop PROC
;;;1135     */
;;;1136   HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b430              PUSH     {r4,r5}
000002  6802              LDR      r2,[r0,#0]
000004  2301              MOVS     r3,#1
;;;1137   { 
;;;1138     /* Check the parameters */
;;;1139     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1140       
;;;1141     /* Disable the Capture compare channel */
;;;1142     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000006  f04f0c00          MOV      r12,#0
00000a  6a15              LDR      r5,[r2,#0x20]
00000c  fa03f401          LSL      r4,r3,r1
000010  ea250404          BIC      r4,r5,r4
000014  6214              STR      r4,[r2,#0x20]
000016  6a14              LDR      r4,[r2,#0x20]
000018  fa0cf101          LSL      r1,r12,r1
00001c  4321              ORRS     r1,r1,r4
00001e  6211              STR      r1,[r2,#0x20]
;;;1143     
;;;1144     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000020  6801              LDR      r1,[r0,#0]
;;;1145     {
;;;1146       /* Disable the Main Output */
;;;1147       __HAL_TIM_MOE_DISABLE(htim);
000022  f2411211          MOV      r2,#0x1111
000026  f1a14480          SUB      r4,r1,#0x40000000     ;1144
00002a  f2404c44          MOV      r12,#0x444
00002e  f5b43480          SUBS     r4,r4,#0x10000        ;1144
000032  bf1c              ITT      NE                    ;1144
000034  f1a14480          SUBNE    r4,r1,#0x40000000     ;1144
000038  f5b43482          SUBSNE   r4,r4,#0x10400        ;1144
00003c  d10a              BNE      |L79.84|
00003e  6a0c              LDR      r4,[r1,#0x20]
000040  4214              TST      r4,r2
000042  bf04              ITT      EQ
000044  6a0c              LDREQ    r4,[r1,#0x20]
000046  ea140f0c          TSTEQ    r4,r12
00004a  d103              BNE      |L79.84|
00004c  6c4c              LDR      r4,[r1,#0x44]
00004e  f4244400          BIC      r4,r4,#0x8000
000052  644c              STR      r4,[r1,#0x44]
                  |L79.84|
;;;1148     }
;;;1149     
;;;1150     /* Disable the Peripheral */
;;;1151     __HAL_TIM_DISABLE(htim);
000054  6801              LDR      r1,[r0,#0]
000056  6a0c              LDR      r4,[r1,#0x20]
000058  4214              TST      r4,r2
00005a  bf04              ITT      EQ
00005c  6a0a              LDREQ    r2,[r1,#0x20]
00005e  ea120f0c          TSTEQ    r2,r12
000062  d103              BNE      |L79.108|
000064  680a              LDR      r2,[r1,#0]
000066  f0220201          BIC      r2,r2,#1
00006a  600a              STR      r2,[r1,#0]
                  |L79.108|
;;;1152     
;;;1153     /* Change the htim state */
;;;1154     htim->State = HAL_TIM_STATE_READY;
00006c  63c3              STR      r3,[r0,#0x3c]
;;;1155     
;;;1156     /* Return function status */
;;;1157     return HAL_OK;
;;;1158   } 
00006e  bc30              POP      {r4,r5}
000070  2000              MOVS     r0,#0                 ;1157
000072  4770              BX       lr
;;;1159   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_Stop_DMA PROC
;;;1425     */
;;;1426   HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b430              PUSH     {r4,r5}
;;;1427   {
;;;1428     /* Check the parameters */
;;;1429     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1430     
;;;1431     switch (Channel)
000002  6802              LDR      r2,[r0,#0]
000004  2900              CMP      r1,#0
;;;1432     {
;;;1433       case TIM_CHANNEL_1:
;;;1434       {       
;;;1435         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1436         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000006  bf04              ITT      EQ
000008  68d3              LDREQ    r3,[r2,#0xc]
00000a  f4237300          BICEQ    r3,r3,#0x200
00000e  d011              BEQ      |L80.52|
000010  2904              CMP      r1,#4                 ;1431
;;;1437       }
;;;1438       break;
;;;1439       
;;;1440       case TIM_CHANNEL_2:
;;;1441       {
;;;1442         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1443         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000012  bf04              ITT      EQ
000014  68d3              LDREQ    r3,[r2,#0xc]
000016  f4236380          BICEQ    r3,r3,#0x400
00001a  d00b              BEQ      |L80.52|
00001c  2908              CMP      r1,#8                 ;1431
;;;1444       }
;;;1445       break;
;;;1446       
;;;1447       case TIM_CHANNEL_3:
;;;1448       {
;;;1449         /* Disable the TIM Capture/Compare 3 DMA request */
;;;1450         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
00001e  bf04              ITT      EQ
000020  68d3              LDREQ    r3,[r2,#0xc]
000022  f4236300          BICEQ    r3,r3,#0x800
000026  d005              BEQ      |L80.52|
000028  290c              CMP      r1,#0xc               ;1431
;;;1451       }
;;;1452       break;
;;;1453       
;;;1454       case TIM_CHANNEL_4:
;;;1455       {
;;;1456         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1457         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
00002a  bf04              ITT      EQ
00002c  68d3              LDREQ    r3,[r2,#0xc]
00002e  f4235380          BICEQ    r3,r3,#0x1000
000032  d100              BNE      |L80.54|
                  |L80.52|
000034  60d3              STR      r3,[r2,#0xc]          ;1450
                  |L80.54|
000036  6802              LDR      r2,[r0,#0]            ;1450
000038  2301              MOVS     r3,#1                 ;1450
;;;1458       }
;;;1459       break;
;;;1460       
;;;1461       default:
;;;1462       break;
;;;1463     } 
;;;1464     
;;;1465     /* Disable the Capture compare channel */
;;;1466     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
00003a  f04f0c00          MOV      r12,#0
00003e  6a15              LDR      r5,[r2,#0x20]
000040  fa03f401          LSL      r4,r3,r1
000044  ea250404          BIC      r4,r5,r4
000048  6214              STR      r4,[r2,#0x20]
00004a  6a14              LDR      r4,[r2,#0x20]
00004c  fa0cf101          LSL      r1,r12,r1
000050  4321              ORRS     r1,r1,r4
000052  6211              STR      r1,[r2,#0x20]
;;;1467     
;;;1468     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000054  6801              LDR      r1,[r0,#0]
;;;1469     {
;;;1470       /* Disable the Main Output */
;;;1471       __HAL_TIM_MOE_DISABLE(htim);
000056  f2411c11          MOV      r12,#0x1111
00005a  f1a14480          SUB      r4,r1,#0x40000000     ;1468
00005e  f2404244          MOV      r2,#0x444
000062  f5b43480          SUBS     r4,r4,#0x10000        ;1468
000066  bf1c              ITT      NE                    ;1468
000068  f1a14480          SUBNE    r4,r1,#0x40000000     ;1468
00006c  f5b43482          SUBSNE   r4,r4,#0x10400        ;1468
000070  d10a              BNE      |L80.136|
000072  6a0c              LDR      r4,[r1,#0x20]
000074  ea140f0c          TST      r4,r12
000078  bf04              ITT      EQ
00007a  6a0c              LDREQ    r4,[r1,#0x20]
00007c  4214              TSTEQ    r4,r2
00007e  d103              BNE      |L80.136|
000080  6c4c              LDR      r4,[r1,#0x44]
000082  f4244400          BIC      r4,r4,#0x8000
000086  644c              STR      r4,[r1,#0x44]
                  |L80.136|
;;;1472     }
;;;1473     
;;;1474     /* Disable the Peripheral */
;;;1475     __HAL_TIM_DISABLE(htim);
000088  6801              LDR      r1,[r0,#0]
00008a  6a0c              LDR      r4,[r1,#0x20]
00008c  ea140f0c          TST      r4,r12
000090  bf04              ITT      EQ
000092  f8d1c020          LDREQ    r12,[r1,#0x20]
000096  ea1c0f02          TSTEQ    r12,r2
00009a  d103              BNE      |L80.164|
00009c  680a              LDR      r2,[r1,#0]
00009e  f0220201          BIC      r2,r2,#1
0000a2  600a              STR      r2,[r1,#0]
                  |L80.164|
;;;1476     
;;;1477     /* Change the htim state */
;;;1478     htim->State = HAL_TIM_STATE_READY;
0000a4  63c3              STR      r3,[r0,#0x3c]
;;;1479     
;;;1480     /* Return function status */
;;;1481     return HAL_OK;
;;;1482   }
0000a6  bc30              POP      {r4,r5}
0000a8  2000              MOVS     r0,#0                 ;1481
0000aa  4770              BX       lr
;;;1483   /**
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_Stop_IT PROC
;;;1238     */
;;;1239   HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b410              PUSH     {r4}
;;;1240   {
;;;1241     /* Check the parameters */
;;;1242     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1243     
;;;1244     switch (Channel)
000002  6802              LDR      r2,[r0,#0]
000004  2900              CMP      r1,#0
;;;1245     {
;;;1246       case TIM_CHANNEL_1:
;;;1247       {       
;;;1248         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1249         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000006  bf04              ITT      EQ
000008  68d3              LDREQ    r3,[r2,#0xc]
00000a  f0230302          BICEQ    r3,r3,#2
00000e  d011              BEQ      |L81.52|
000010  2904              CMP      r1,#4                 ;1244
;;;1250       }
;;;1251       break;
;;;1252       
;;;1253       case TIM_CHANNEL_2:
;;;1254       {
;;;1255         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1256         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000012  bf04              ITT      EQ
000014  68d3              LDREQ    r3,[r2,#0xc]
000016  f0230304          BICEQ    r3,r3,#4
00001a  d00b              BEQ      |L81.52|
00001c  2908              CMP      r1,#8                 ;1244
;;;1257       }
;;;1258       break;
;;;1259       
;;;1260       case TIM_CHANNEL_3:
;;;1261       {
;;;1262         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1263         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
00001e  bf04              ITT      EQ
000020  68d3              LDREQ    r3,[r2,#0xc]
000022  f0230308          BICEQ    r3,r3,#8
000026  d005              BEQ      |L81.52|
000028  290c              CMP      r1,#0xc               ;1244
;;;1264       }
;;;1265       break;
;;;1266       
;;;1267       case TIM_CHANNEL_4:
;;;1268       {
;;;1269         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1270         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
00002a  bf04              ITT      EQ
00002c  68d3              LDREQ    r3,[r2,#0xc]
00002e  f0230310          BICEQ    r3,r3,#0x10
000032  d100              BNE      |L81.54|
                  |L81.52|
000034  60d3              STR      r3,[r2,#0xc]          ;1263
                  |L81.54|
000036  6802              LDR      r2,[r0,#0]            ;1263
000038  f04f0c01          MOV      r12,#1                ;1263
;;;1271       }
;;;1272       break;
;;;1273       
;;;1274       default:
;;;1275       break; 
;;;1276     }
;;;1277     
;;;1278     /* Disable the Capture compare channel */
;;;1279     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
00003c  2300              MOVS     r3,#0
00003e  6a14              LDR      r4,[r2,#0x20]
000040  fa0cfc01          LSL      r12,r12,r1
000044  ea240c0c          BIC      r12,r4,r12
000048  f8c2c020          STR      r12,[r2,#0x20]
00004c  f8d2c020          LDR      r12,[r2,#0x20]
000050  fa03f101          LSL      r1,r3,r1
000054  ea4c0101          ORR      r1,r12,r1
000058  6211              STR      r1,[r2,#0x20]
;;;1280     
;;;1281     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00005a  6801              LDR      r1,[r0,#0]
;;;1282     {
;;;1283       /* Disable the Main Output */
;;;1284       __HAL_TIM_MOE_DISABLE(htim);
00005c  f2411211          MOV      r2,#0x1111
000060  1093              ASRS     r3,r2,#2
000062  f1a14c80          SUB      r12,r1,#0x40000000    ;1281
000066  f5bc3c80          SUBS     r12,r12,#0x10000      ;1281
00006a  bf1c              ITT      NE                    ;1281
00006c  f1a14c80          SUBNE    r12,r1,#0x40000000    ;1281
000070  f5bc3c82          SUBSNE   r12,r12,#0x10400      ;1281
000074  d10f              BNE      |L81.150|
000076  f8d1c020          LDR      r12,[r1,#0x20]
00007a  ea1c0f02          TST      r12,r2
00007e  bf04              ITT      EQ
000080  f8d1c020          LDREQ    r12,[r1,#0x20]
000084  ea1c0f03          TSTEQ    r12,r3
000088  d105              BNE      |L81.150|
00008a  f8d1c044          LDR      r12,[r1,#0x44]
00008e  f42c4c00          BIC      r12,r12,#0x8000
000092  f8c1c044          STR      r12,[r1,#0x44]
                  |L81.150|
;;;1285     }
;;;1286     
;;;1287     /* Disable the Peripheral */
;;;1288     __HAL_TIM_DISABLE(htim);
000096  6800              LDR      r0,[r0,#0]
000098  6a01              LDR      r1,[r0,#0x20]
00009a  4211              TST      r1,r2
00009c  bf04              ITT      EQ
00009e  6a01              LDREQ    r1,[r0,#0x20]
0000a0  4219              TSTEQ    r1,r3
0000a2  d103              BNE      |L81.172|
0000a4  6801              LDR      r1,[r0,#0]
0000a6  f0210101          BIC      r1,r1,#1
0000aa  6001              STR      r1,[r0,#0]
                  |L81.172|
;;;1289     
;;;1290     /* Return function status */
;;;1291     return HAL_OK;
;;;1292   } 
0000ac  bc10              POP      {r4}
0000ae  2000              MOVS     r0,#0                 ;1291
0000b0  4770              BX       lr
;;;1293   
                          ENDP


                          AREA ||i.HAL_TIM_PeriodElapsedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PeriodElapsedCallback PROC
;;;4303     */
;;;4304   __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4305   {
;;;4306     /* Prevent unused argument(s) compilation warning */
;;;4307     UNUSED(htim);
;;;4308     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4309               the __HAL_TIM_PeriodElapsedCallback could be implemented in the user file
;;;4310      */
;;;4311   }
;;;4312   
                          ENDP


                          AREA ||i.HAL_TIM_ReadCapturedValue||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ReadCapturedValue PROC
;;;4216     */
;;;4217   uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6b83              LDR      r3,[r0,#0x38]
;;;4218   {
;;;4219     uint32_t tmpreg = 0U;
000002  2200              MOVS     r2,#0
;;;4220     
;;;4221     __HAL_LOCK(htim);
000004  2b01              CMP      r3,#1
000006  bf04              ITT      EQ
000008  2002              MOVEQ    r0,#2
;;;4222     
;;;4223     switch (Channel)
;;;4224     {
;;;4225       case TIM_CHANNEL_1:
;;;4226       {
;;;4227         /* Check the parameters */
;;;4228         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4229         
;;;4230         /* Return the capture 1 value */
;;;4231         tmpreg = htim->Instance->CCR1;
;;;4232         
;;;4233         break;
;;;4234       }
;;;4235       case TIM_CHANNEL_2:
;;;4236       {
;;;4237         /* Check the parameters */
;;;4238         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4239         
;;;4240         /* Return the capture 2 value */
;;;4241         tmpreg = htim->Instance->CCR2;
;;;4242         
;;;4243         break;
;;;4244       }
;;;4245       
;;;4246       case TIM_CHANNEL_3:
;;;4247       {
;;;4248         /* Check the parameters */
;;;4249         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;4250         
;;;4251         /* Return the capture 3 value */
;;;4252         tmpreg = htim->Instance->CCR3;
;;;4253         
;;;4254         break;
;;;4255       }
;;;4256       
;;;4257       case TIM_CHANNEL_4:
;;;4258       {
;;;4259         /* Check the parameters */
;;;4260         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;4261         
;;;4262         /* Return the capture 4 value */
;;;4263         tmpreg = htim->Instance->CCR4;
;;;4264         
;;;4265         break;
;;;4266       }
;;;4267       
;;;4268       default:
;;;4269       break;  
;;;4270     }
;;;4271        
;;;4272     __HAL_UNLOCK(htim);  
;;;4273     return tmpreg;
;;;4274   }
00000a  4770              BXEQ     lr
00000c  2301              MOVS     r3,#1                 ;4221
00000e  6383              STR      r3,[r0,#0x38]         ;4223
000010  2900              CMP      r1,#0                 ;4223
000012  bf04              ITT      EQ                    ;4231
000014  6801              LDREQ    r1,[r0,#0]            ;4231
000016  6b4a              LDREQ    r2,[r1,#0x34]         ;4231
000018  d00d              BEQ      |L83.54|
00001a  2904              CMP      r1,#4                 ;4223
00001c  bf04              ITT      EQ                    ;4241
00001e  6801              LDREQ    r1,[r0,#0]            ;4241
000020  6b8a              LDREQ    r2,[r1,#0x38]         ;4241
000022  d008              BEQ      |L83.54|
000024  2908              CMP      r1,#8                 ;4223
000026  bf04              ITT      EQ                    ;4252
000028  6801              LDREQ    r1,[r0,#0]            ;4252
00002a  6bca              LDREQ    r2,[r1,#0x3c]         ;4252
00002c  d003              BEQ      |L83.54|
00002e  290c              CMP      r1,#0xc               ;4223
000030  bf04              ITT      EQ                    ;4263
000032  6801              LDREQ    r1,[r0,#0]            ;4263
000034  6c0a              LDREQ    r2,[r1,#0x40]         ;4263
                  |L83.54|
000036  2100              MOVS     r1,#0                 ;4272
000038  6381              STR      r1,[r0,#0x38]         ;4273
00003a  4610              MOV      r0,r2                 ;4273
00003c  4770              BX       lr
;;;4275   /**
                          ENDP


                          AREA ||i.HAL_TIM_SlaveConfigSynchronization||, CODE, READONLY, ALIGN=1

                  HAL_TIM_SlaveConfigSynchronization PROC
;;;4142     */
;;;4143   HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef * sSlaveConfig)
000000  b570              PUSH     {r4-r6,lr}
;;;4144   {
000002  4604              MOV      r4,r0
;;;4145     /* Check the parameters */
;;;4146     assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
;;;4147     assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
;;;4148     assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
;;;4149      
;;;4150     __HAL_LOCK(htim);
000004  6b80              LDR      r0,[r0,#0x38]
000006  2801              CMP      r0,#1
000008  bf04              ITT      EQ
00000a  2002              MOVEQ    r0,#2
;;;4151     
;;;4152     htim->State = HAL_TIM_STATE_BUSY;
;;;4153   
;;;4154     TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
;;;4155     
;;;4156     /* Disable Trigger Interrupt */
;;;4157     __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);
;;;4158     
;;;4159     /* Disable Trigger DMA request */
;;;4160     __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
;;;4161     
;;;4162     htim->State = HAL_TIM_STATE_READY;
;;;4163        
;;;4164     __HAL_UNLOCK(htim);  
;;;4165     
;;;4166     return HAL_OK;
;;;4167   } 
00000c  bd70              POPEQ    {r4-r6,pc}
00000e  2501              MOVS     r5,#1                 ;4150
000010  2002              MOVS     r0,#2                 ;4152
000012  63a5              STR      r5,[r4,#0x38]         ;4152
000014  63e0              STR      r0,[r4,#0x3c]         ;4152
000016  4620              MOV      r0,r4                 ;4154
000018  f7fffffe          BL       TIM_SlaveTimer_SetConfig
00001c  6820              LDR      r0,[r4,#0]            ;4157
00001e  68c1              LDR      r1,[r0,#0xc]          ;4157
000020  f0210140          BIC      r1,r1,#0x40           ;4157
000024  60c1              STR      r1,[r0,#0xc]          ;4157
000026  6820              LDR      r0,[r4,#0]            ;4160
000028  68c1              LDR      r1,[r0,#0xc]          ;4160
00002a  f4214180          BIC      r1,r1,#0x4000         ;4160
00002e  60c1              STR      r1,[r0,#0xc]          ;4160
000030  63e5              STR      r5,[r4,#0x3c]         ;4162
000032  2000              MOVS     r0,#0                 ;4164
000034  63a0              STR      r0,[r4,#0x38]         ;4164
000036  bd70              POP      {r4-r6,pc}
;;;4168   
                          ENDP


                          AREA ||i.HAL_TIM_SlaveConfigSynchronization_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_SlaveConfigSynchronization_IT PROC
;;;4177     */
;;;4178   HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization_IT(TIM_HandleTypeDef *htim, 
000000  b570              PUSH     {r4-r6,lr}
;;;4179                                                           TIM_SlaveConfigTypeDef * sSlaveConfig)
;;;4180   {
000002  4604              MOV      r4,r0
;;;4181     /* Check the parameters */
;;;4182     assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
;;;4183     assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
;;;4184     assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
;;;4185     
;;;4186     __HAL_LOCK(htim);
000004  6b80              LDR      r0,[r0,#0x38]
000006  2801              CMP      r0,#1
000008  bf04              ITT      EQ
00000a  2002              MOVEQ    r0,#2
;;;4187   
;;;4188     htim->State = HAL_TIM_STATE_BUSY;
;;;4189     
;;;4190     TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
;;;4191     
;;;4192     /* Enable Trigger Interrupt */
;;;4193     __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
;;;4194     
;;;4195     /* Disable Trigger DMA request */
;;;4196     __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
;;;4197     
;;;4198     htim->State = HAL_TIM_STATE_READY;
;;;4199        
;;;4200     __HAL_UNLOCK(htim);  
;;;4201     
;;;4202     return HAL_OK;
;;;4203   }
00000c  bd70              POPEQ    {r4-r6,pc}
00000e  2501              MOVS     r5,#1                 ;4186
000010  2002              MOVS     r0,#2                 ;4188
000012  63a5              STR      r5,[r4,#0x38]         ;4188
000014  63e0              STR      r0,[r4,#0x3c]         ;4188
000016  4620              MOV      r0,r4                 ;4190
000018  f7fffffe          BL       TIM_SlaveTimer_SetConfig
00001c  6820              LDR      r0,[r4,#0]            ;4193
00001e  68c1              LDR      r1,[r0,#0xc]          ;4193
000020  f0410140          ORR      r1,r1,#0x40           ;4193
000024  60c1              STR      r1,[r0,#0xc]          ;4193
000026  6820              LDR      r0,[r4,#0]            ;4196
000028  68c1              LDR      r1,[r0,#0xc]          ;4196
00002a  f4214180          BIC      r1,r1,#0x4000         ;4196
00002e  60c1              STR      r1,[r0,#0xc]          ;4196
000030  63e5              STR      r5,[r4,#0x3c]         ;4198
000032  2000              MOVS     r0,#0                 ;4200
000034  63a0              STR      r0,[r4,#0x38]         ;4200
000036  bd70              POP      {r4-r6,pc}
;;;4204   
                          ENDP


                          AREA ||i.HAL_TIM_TriggerCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_TriggerCallback PROC
;;;4363     */
;;;4364   __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4365   {
;;;4366     /* Prevent unused argument(s) compilation warning */
;;;4367     UNUSED(htim);
;;;4368     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4369               the HAL_TIM_TriggerCallback could be implemented in the user file
;;;4370      */
;;;4371   }
;;;4372   
                          ENDP


                          AREA ||i.TIM_Base_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_Base_SetConfig PROC
;;;4480     */
;;;4481   void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
000000  b4f0              PUSH     {r4-r7}
;;;4482   {
;;;4483     uint32_t tmpcr1 = 0U;
;;;4484     tmpcr1 = TIMx->CR1;
000002  6802              LDR      r2,[r0,#0]
;;;4485     
;;;4486     /* Set TIM Time Base Unit parameters ---------------------------------------*/
;;;4487     if(IS_TIM_CC3_INSTANCE(TIMx) != RESET)   
000004  4b29              LDR      r3,|L87.172|
000006  4c2a              LDR      r4,|L87.176|
000008  4d2a              LDR      r5,|L87.180|
00000a  4e2b              LDR      r6,|L87.184|
00000c  f8dfc0ac          LDR      r12,|L87.188|
000010  4298              CMP      r0,r3
000012  bf18              IT       NE
000014  f1b04f80          CMPNE    r0,#0x40000000
000018  d007              BEQ      |L87.42|
00001a  42a0              CMP      r0,r4
00001c  bf18              IT       NE
00001e  42a8              CMPNE    r0,r5
000020  d003              BEQ      |L87.42|
000022  42b0              CMP      r0,r6
000024  bf18              IT       NE
000026  4560              CMPNE    r0,r12
000028  d103              BNE      |L87.50|
                  |L87.42|
;;;4488     {
;;;4489       /* Select the Counter Mode */
;;;4490       tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
;;;4491       tmpcr1 |= Structure->CounterMode;
00002a  684f              LDR      r7,[r1,#4]
00002c  f0220270          BIC      r2,r2,#0x70           ;4490
000030  433a              ORRS     r2,r2,r7
                  |L87.50|
;;;4492     }
;;;4493    
;;;4494     if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)  
000032  4298              CMP      r0,r3
000034  bf18              IT       NE
000036  f1b04f80          CMPNE    r0,#0x40000000
00003a  d025              BEQ      |L87.136|
00003c  42a0              CMP      r0,r4
00003e  bf18              IT       NE
000040  42a8              CMPNE    r0,r5
000042  d021              BEQ      |L87.136|
000044  42b0              CMP      r0,r6
000046  bf18              IT       NE
000048  4560              CMPNE    r0,r12
00004a  d01d              BEQ      |L87.136|
00004c  f1a04480          SUB      r4,r0,#0x40000000
000050  f5b434a0          SUBS     r4,r4,#0x14000
000054  bf1c              ITT      NE
000056  f1a04480          SUBNE    r4,r0,#0x40000000
00005a  f5b434a2          SUBSNE   r4,r4,#0x14400
00005e  d013              BEQ      |L87.136|
000060  f1a04480          SUB      r4,r0,#0x40000000
000064  f5b434a4          SUBS     r4,r4,#0x14800
000068  bf1c              ITT      NE
00006a  f1a04480          SUBNE    r4,r0,#0x40000000
00006e  f5b454c0          SUBSNE   r4,r4,#0x1800
000072  d009              BEQ      |L87.136|
000074  f1a04480          SUB      r4,r0,#0x40000000
000078  f5b454e0          SUBS     r4,r4,#0x1c00
00007c  bf1c              ITT      NE
00007e  f1a04480          SUBNE    r4,r0,#0x40000000
000082  f5b45400          SUBSNE   r4,r4,#0x2000
000086  d103              BNE      |L87.144|
                  |L87.136|
;;;4495     {
;;;4496       /* Set the clock division */
;;;4497       tmpcr1 &= ~TIM_CR1_CKD;
;;;4498       tmpcr1 |= (uint32_t)Structure->ClockDivision;
000088  68cc              LDR      r4,[r1,#0xc]
00008a  f4227240          BIC      r2,r2,#0x300          ;4497
00008e  4322              ORRS     r2,r2,r4
                  |L87.144|
;;;4499     }
;;;4500   
;;;4501     TIMx->CR1 = tmpcr1;
000090  6002              STR      r2,[r0,#0]
;;;4502   
;;;4503     /* Set the Auto-reload value */
;;;4504     TIMx->ARR = (uint32_t)Structure->Period ;
000092  688a              LDR      r2,[r1,#8]
000094  62c2              STR      r2,[r0,#0x2c]
;;;4505    
;;;4506     /* Set the Prescaler value */
;;;4507     TIMx->PSC = (uint32_t)Structure->Prescaler;
000096  680a              LDR      r2,[r1,#0]
000098  6282              STR      r2,[r0,#0x28]
;;;4508       
;;;4509     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)  
00009a  4298              CMP      r0,r3
00009c  bf12              ITEE     NE
00009e  4560              CMPNE    r0,r12
;;;4510     {
;;;4511       /* Set the Repetition Counter value */
;;;4512       TIMx->RCR = Structure->RepetitionCounter;
0000a0  6909              LDREQ    r1,[r1,#0x10]
0000a2  6301              STREQ    r1,[r0,#0x30]
;;;4513     }
;;;4514   
;;;4515     /* Generate an update event to reload the Prescaler 
;;;4516        and the repetition counter(only for TIM1 and TIM8) value immediately */
;;;4517     TIMx->EGR = TIM_EGR_UG;
0000a4  2101              MOVS     r1,#1
0000a6  6141              STR      r1,[r0,#0x14]
;;;4518   }
0000a8  bcf0              POP      {r4-r7}
0000aa  4770              BX       lr
;;;4519   
                          ENDP

                  |L87.172|
                          DCD      0x40010000
                  |L87.176|
                          DCD      0x40000400
                  |L87.180|
                          DCD      0x40000800
                  |L87.184|
                          DCD      0x40000c00
                  |L87.188|
                          DCD      0x40010400

                          AREA ||i.TIM_CCxChannelCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxChannelCmd PROC
;;;4738     */
;;;4739   void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
000000  2301              MOVS     r3,#1
;;;4740   {
;;;4741     uint32_t tmp = 0U;
;;;4742   
;;;4743     /* Check the parameters */
;;;4744     assert_param(IS_TIM_CC1_INSTANCE(TIMx)); 
;;;4745     assert_param(IS_TIM_CHANNELS(Channel));
;;;4746   
;;;4747     tmp = TIM_CCER_CC1E << Channel;
;;;4748   
;;;4749     /* Reset the CCxE Bit */
;;;4750     TIMx->CCER &= ~tmp;
000002  f8d0c020          LDR      r12,[r0,#0x20]
000006  408b              LSLS     r3,r3,r1              ;4747
000008  ea2c0303          BIC      r3,r12,r3
00000c  6203              STR      r3,[r0,#0x20]
;;;4751   
;;;4752     /* Set or reset the CCxE Bit */ 
;;;4753     TIMx->CCER |= (uint32_t)(ChannelState << Channel);
00000e  6a03              LDR      r3,[r0,#0x20]
000010  fa02f101          LSL      r1,r2,r1
000014  4319              ORRS     r1,r1,r3
000016  6201              STR      r1,[r0,#0x20]
;;;4754   }
000018  4770              BX       lr
;;;4755   
                          ENDP


                          AREA ||i.TIM_DMACaptureCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMACaptureCplt PROC
;;;4697     */
;;;4698   void TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4699   {
;;;4700     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
;;;4701     
;;;4702     htim->State= HAL_TIM_STATE_READY;
000002  6bc4              LDR      r4,[r0,#0x3c]
000004  2101              MOVS     r1,#1
000006  63e1              STR      r1,[r4,#0x3c]
;;;4703     
;;;4704     if(hdma == htim->hdma[TIM_DMA_ID_CC1])
000008  6a22              LDR      r2,[r4,#0x20]
00000a  4282              CMP      r2,r0
;;;4705     {
;;;4706       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
00000c  bf08              IT       EQ
00000e  61a1              STREQ    r1,[r4,#0x18]
000010  d010              BEQ      |L89.52|
;;;4707     }
;;;4708     else if(hdma == htim->hdma[TIM_DMA_ID_CC2])
000012  6a61              LDR      r1,[r4,#0x24]
000014  4281              CMP      r1,r0
;;;4709     {
;;;4710       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
000016  bf04              ITT      EQ
000018  2002              MOVEQ    r0,#2
00001a  61a0              STREQ    r0,[r4,#0x18]
00001c  d00a              BEQ      |L89.52|
;;;4711     }
;;;4712     else if(hdma == htim->hdma[TIM_DMA_ID_CC3])
00001e  6aa1              LDR      r1,[r4,#0x28]
000020  4281              CMP      r1,r0
;;;4713     {
;;;4714       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000022  bf08              IT       EQ
000024  2004              MOVEQ    r0,#4
000026  d004              BEQ      |L89.50|
;;;4715     }
;;;4716     else if(hdma == htim->hdma[TIM_DMA_ID_CC4])
000028  6ae1              LDR      r1,[r4,#0x2c]
00002a  4281              CMP      r1,r0
;;;4717     {
;;;4718       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
00002c  bf08              IT       EQ
00002e  2008              MOVEQ    r0,#8
000030  d100              BNE      |L89.52|
                  |L89.50|
000032  61a0              STR      r0,[r4,#0x18]
                  |L89.52|
;;;4719     }
;;;4720     
;;;4721     HAL_TIM_IC_CaptureCallback(htim); 
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
;;;4722     
;;;4723     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
00003a  2000              MOVS     r0,#0
00003c  61a0              STR      r0,[r4,#0x18]
;;;4724   }
00003e  bd10              POP      {r4,pc}
;;;4725   
                          ENDP


                          AREA ||i.TIM_DMADelayPulseCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMADelayPulseCplt PROC
;;;4648     */
;;;4649   void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4650   {
;;;4651     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
;;;4652     
;;;4653     htim->State= HAL_TIM_STATE_READY; 
000002  6bc4              LDR      r4,[r0,#0x3c]
000004  2101              MOVS     r1,#1
000006  63e1              STR      r1,[r4,#0x3c]
;;;4654     
;;;4655     if(hdma == htim->hdma[TIM_DMA_ID_CC1])
000008  6a22              LDR      r2,[r4,#0x20]
00000a  4282              CMP      r2,r0
;;;4656     {
;;;4657       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
00000c  bf08              IT       EQ
00000e  61a1              STREQ    r1,[r4,#0x18]
000010  d010              BEQ      |L90.52|
;;;4658     }
;;;4659     else if(hdma == htim->hdma[TIM_DMA_ID_CC2])
000012  6a61              LDR      r1,[r4,#0x24]
000014  4281              CMP      r1,r0
;;;4660     {
;;;4661       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
000016  bf04              ITT      EQ
000018  2002              MOVEQ    r0,#2
00001a  61a0              STREQ    r0,[r4,#0x18]
00001c  d00a              BEQ      |L90.52|
;;;4662     }
;;;4663     else if(hdma == htim->hdma[TIM_DMA_ID_CC3])
00001e  6aa1              LDR      r1,[r4,#0x28]
000020  4281              CMP      r1,r0
;;;4664     {
;;;4665       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000022  bf08              IT       EQ
000024  2004              MOVEQ    r0,#4
000026  d004              BEQ      |L90.50|
;;;4666     }
;;;4667     else if(hdma == htim->hdma[TIM_DMA_ID_CC4])
000028  6ae1              LDR      r1,[r4,#0x2c]
00002a  4281              CMP      r1,r0
;;;4668     {
;;;4669       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
00002c  bf08              IT       EQ
00002e  2008              MOVEQ    r0,#8
000030  d100              BNE      |L90.52|
                  |L90.50|
000032  61a0              STR      r0,[r4,#0x18]
                  |L90.52|
;;;4670     }
;;;4671   
;;;4672     HAL_TIM_PWM_PulseFinishedCallback(htim);
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
;;;4673   
;;;4674     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;  
00003a  2000              MOVS     r0,#0
00003c  61a0              STR      r0,[r4,#0x18]
;;;4675   }
00003e  bd10              POP      {r4,pc}
;;;4676   
                          ENDP


                          AREA ||i.TIM_DMAError||, CODE, READONLY, ALIGN=1

                  TIM_DMAError PROC
;;;4682     */
;;;4683   void TIM_DMAError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4684   {
;;;4685     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;4686     
;;;4687     htim->State= HAL_TIM_STATE_READY;
000004  2101              MOVS     r1,#1
000006  63c1              STR      r1,[r0,#0x3c]
;;;4688      
;;;4689     HAL_TIM_ErrorCallback(htim);
000008  f7fffffe          BL       HAL_TIM_ErrorCallback
;;;4690   }
00000c  bd10              POP      {r4,pc}
;;;4691   
                          ENDP


                          AREA ||i.TIM_DMAPeriodElapsedCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMAPeriodElapsedCplt PROC
;;;4761     */
;;;4762   static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4763   {
;;;4764     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;4765     
;;;4766     htim->State= HAL_TIM_STATE_READY;
000004  2101              MOVS     r1,#1
000006  63c1              STR      r1,[r0,#0x3c]
;;;4767     
;;;4768     HAL_TIM_PeriodElapsedCallback(htim);
000008  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
;;;4769   }
00000c  bd10              POP      {r4,pc}
;;;4770   
                          ENDP


                          AREA ||i.TIM_DMATriggerCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMATriggerCplt PROC
;;;4776     */
;;;4777   static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4778   {
;;;4779     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;  
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;4780     
;;;4781     htim->State= HAL_TIM_STATE_READY; 
000004  2101              MOVS     r1,#1
000006  63c1              STR      r1,[r0,#0x3c]
;;;4782     
;;;4783     HAL_TIM_TriggerCallback(htim);
000008  f7fffffe          BL       HAL_TIM_TriggerCallback
;;;4784   }
00000c  bd10              POP      {r4,pc}
;;;4785   
                          ENDP


                          AREA ||i.TIM_OC2_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2_SetConfig PROC
;;;4581     */
;;;4582   void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b410              PUSH     {r4}
;;;4583   {
;;;4584     uint32_t tmpccmrx = 0U;
;;;4585     uint32_t tmpccer = 0U;
;;;4586     uint32_t tmpcr2 = 0U;
;;;4587      
;;;4588     /* Disable the Channel 2: Reset the CC2E Bit */
;;;4589     TIMx->CCER &= ~TIM_CCER_CC2E;
000002  6a02              LDR      r2,[r0,#0x20]
000004  f0220210          BIC      r2,r2,#0x10
000008  6202              STR      r2,[r0,#0x20]
;;;4590     
;;;4591     /* Get the TIMx CCER register value */  
;;;4592     tmpccer = TIMx->CCER;
00000a  6a02              LDR      r2,[r0,#0x20]
;;;4593     /* Get the TIMx CR2 register value */
;;;4594     tmpcr2 = TIMx->CR2;
00000c  6843              LDR      r3,[r0,#4]
;;;4595     
;;;4596     /* Get the TIMx CCMR1 register value */
;;;4597     tmpccmrx = TIMx->CCMR1;
00000e  f8d0c018          LDR      r12,[r0,#0x18]
;;;4598       
;;;4599     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;4600     tmpccmrx &= ~TIM_CCMR1_OC2M;
;;;4601     tmpccmrx &= ~TIM_CCMR1_CC2S;
;;;4602     
;;;4603     /* Select the Output Compare Mode */
;;;4604     tmpccmrx |= (OC_Config->OCMode << 8U);
000012  680c              LDR      r4,[r1,#0]
000014  f42c4ce6          BIC      r12,r12,#0x7300       ;4601
000018  ea4c2c04          ORR      r12,r12,r4,LSL #8
;;;4605     
;;;4606     /* Reset the Output Polarity level */
;;;4607     tmpccer &= ~TIM_CCER_CC2P;
;;;4608     /* Set the Output Compare Polarity */
;;;4609     tmpccer |= (OC_Config->OCPolarity << 4U);
00001c  688c              LDR      r4,[r1,#8]
00001e  f0220220          BIC      r2,r2,#0x20           ;4607
000022  ea421204          ORR      r2,r2,r4,LSL #4
;;;4610       
;;;4611     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
000026  f1a04480          SUB      r4,r0,#0x40000000
00002a  f5b43480          SUBS     r4,r4,#0x10000
00002e  bf1c              ITT      NE
000030  f1a04480          SUBNE    r4,r0,#0x40000000
000034  f5b43482          SUBSNE   r4,r4,#0x10400
000038  d10e              BNE      |L94.88|
;;;4612     {
;;;4613       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;4614       
;;;4615       /* Reset the Output N Polarity level */
;;;4616       tmpccer &= ~TIM_CCER_CC2NP;
;;;4617       /* Set the Output N Polarity */
;;;4618       tmpccer |= (OC_Config->OCNPolarity << 4U);
00003a  68cc              LDR      r4,[r1,#0xc]
00003c  f0220280          BIC      r2,r2,#0x80           ;4616
000040  ea421204          ORR      r2,r2,r4,LSL #4
;;;4619       /* Reset the Output N State */
;;;4620       tmpccer &= ~TIM_CCER_CC2NE;
;;;4621       
;;;4622       /* Reset the Output Compare and Output Compare N IDLE State */
;;;4623       tmpcr2 &= ~TIM_CR2_OIS2;
;;;4624       tmpcr2 &= ~TIM_CR2_OIS2N;
;;;4625       /* Set the Output Idle state */
;;;4626       tmpcr2 |= (OC_Config->OCIdleState << 2U);
000044  694c              LDR      r4,[r1,#0x14]
000046  f4236340          BIC      r3,r3,#0xc00          ;4624
00004a  ea430384          ORR      r3,r3,r4,LSL #2
;;;4627       /* Set the Output N Idle state */
;;;4628       tmpcr2 |= (OC_Config->OCNIdleState << 2U);
00004e  698c              LDR      r4,[r1,#0x18]
000050  f0220240          BIC      r2,r2,#0x40           ;4620
000054  ea430384          ORR      r3,r3,r4,LSL #2
                  |L94.88|
;;;4629     }
;;;4630     /* Write to TIMx CR2 */
;;;4631     TIMx->CR2 = tmpcr2;
000058  6043              STR      r3,[r0,#4]
;;;4632     
;;;4633     /* Write to TIMx CCMR1 */
;;;4634     TIMx->CCMR1 = tmpccmrx;
00005a  f8c0c018          STR      r12,[r0,#0x18]
;;;4635     
;;;4636     /* Set the Capture Compare Register value */
;;;4637     TIMx->CCR2 = OC_Config->Pulse;
00005e  6849              LDR      r1,[r1,#4]
000060  6381              STR      r1,[r0,#0x38]
;;;4638     
;;;4639     /* Write to TIMx CCER */
;;;4640     TIMx->CCER = tmpccer;
000062  6202              STR      r2,[r0,#0x20]
;;;4641   }
000064  bc10              POP      {r4}
000066  4770              BX       lr
;;;4642   
                          ENDP


                          AREA ||i.TIM_SlaveTimer_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_SlaveTimer_SetConfig PROC
;;;4982     */
;;;4983   static void TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
000000  6803              LDR      r3,[r0,#0]
;;;4984                                 TIM_SlaveConfigTypeDef * sSlaveConfig)
;;;4985   {
;;;4986     uint32_t tmpsmcr = 0U;
;;;4987     uint32_t tmpccmr1 = 0U;
;;;4988     uint32_t tmpccer = 0U;
;;;4989   
;;;4990    /* Get the TIMx SMCR register value */
;;;4991     tmpsmcr = htim->Instance->SMCR;
000002  689a              LDR      r2,[r3,#8]
;;;4992   
;;;4993     /* Reset the Trigger Selection Bits */
;;;4994     tmpsmcr &= ~TIM_SMCR_TS;
;;;4995     /* Set the Input Trigger source */
;;;4996     tmpsmcr |= sSlaveConfig->InputTrigger;
000004  f8d1c004          LDR      r12,[r1,#4]
000008  f0220270          BIC      r2,r2,#0x70           ;4994
00000c  ea4c0202          ORR      r2,r12,r2
;;;4997   
;;;4998     /* Reset the slave mode Bits */
;;;4999     tmpsmcr &= ~TIM_SMCR_SMS;
;;;5000     /* Set the slave mode */
;;;5001     tmpsmcr |= sSlaveConfig->SlaveMode;
000010  f8d1c000          LDR      r12,[r1,#0]
000014  f0220207          BIC      r2,r2,#7              ;4999
000018  ea4c0202          ORR      r2,r12,r2
;;;5002   
;;;5003     /* Write to TIMx SMCR */
;;;5004     htim->Instance->SMCR = tmpsmcr;
00001c  609a              STR      r2,[r3,#8]
;;;5005     
;;;5006     /* Configure the trigger prescaler, filter, and polarity */
;;;5007     switch (sSlaveConfig->InputTrigger)
00001e  684a              LDR      r2,[r1,#4]
000020  f0120f0f          TST      r2,#0xf
;;;5008     {
;;;5009     case TIM_TS_ETRF:
;;;5010       {
;;;5011         /* Check the parameters */
;;;5012         assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
;;;5013         assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
;;;5014         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;5015         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;5016         /* Configure the ETR Trigger source */
;;;5017         TIM_ETR_SetConfig(htim->Instance, 
;;;5018                           sSlaveConfig->TriggerPrescaler, 
;;;5019                           sSlaveConfig->TriggerPolarity, 
;;;5020                           sSlaveConfig->TriggerFilter);
;;;5021       }
;;;5022       break;
;;;5023       
;;;5024     case TIM_TS_TI1F_ED:
;;;5025       {
;;;5026         /* Check the parameters */
;;;5027         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;5028         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;5029         
;;;5030         /* Disable the Channel 1: Reset the CC1E Bit */
;;;5031         tmpccer = htim->Instance->CCER;
;;;5032         htim->Instance->CCER &= ~TIM_CCER_CC1E;
;;;5033         tmpccmr1 = htim->Instance->CCMR1;    
;;;5034         
;;;5035         /* Set the filter */
;;;5036         tmpccmr1 &= ~TIM_CCMR1_IC1F;
;;;5037         tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4U);
;;;5038         
;;;5039         /* Write to TIMx CCMR1 and CCER registers */
;;;5040         htim->Instance->CCMR1 = tmpccmr1;
;;;5041         htim->Instance->CCER = tmpccer;                               
;;;5042                                  
;;;5043       }
;;;5044       break;
;;;5045       
;;;5046     case TIM_TS_TI1FP1:
;;;5047       {
;;;5048         /* Check the parameters */
;;;5049         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;5050         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;5051         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;5052   
;;;5053         /* Configure TI1 Filter and Polarity */
;;;5054         TIM_TI1_ConfigInputStage(htim->Instance,
;;;5055                                  sSlaveConfig->TriggerPolarity,
;;;5056                                  sSlaveConfig->TriggerFilter);
;;;5057       }
;;;5058       break;
;;;5059       
;;;5060     case TIM_TS_TI2FP2:
;;;5061       {
;;;5062         /* Check the parameters */
;;;5063         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5064         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;5065         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;5066         
;;;5067         /* Configure TI2 Filter and Polarity */
;;;5068         TIM_TI2_ConfigInputStage(htim->Instance,
;;;5069                                   sSlaveConfig->TriggerPolarity,
;;;5070                                   sSlaveConfig->TriggerFilter);
;;;5071       }
;;;5072       break;
;;;5073       
;;;5074     case TIM_TS_ITR0:
;;;5075       {
;;;5076         /* Check the parameter */
;;;5077         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5078       }
;;;5079       break;
;;;5080       
;;;5081     case TIM_TS_ITR1:
;;;5082       {
;;;5083         /* Check the parameter */
;;;5084         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5085       }
;;;5086       break;
;;;5087       
;;;5088     case TIM_TS_ITR2:
;;;5089       {
;;;5090         /* Check the parameter */
;;;5091         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5092       }
;;;5093       break;
;;;5094       
;;;5095     case TIM_TS_ITR3:
;;;5096       {
;;;5097         /* Check the parameter */
;;;5098         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5099       }
;;;5100       break;
;;;5101          
;;;5102     default:
;;;5103       break;
;;;5104     }
;;;5105   }
000024  bf18              IT       NE
000026  4770              BXNE     lr
000028  1112              ASRS     r2,r2,#4              ;5007
00002a  2a08              CMP      r2,#8                 ;5007
00002c  bf28              IT       CS
00002e  4770              BXCS     lr
000030  e8dff002          TBB      [pc,r2]
000034  12121212          DCB      0x12,0x12,0x12,0x12
000038  13273d04          DCB      0x13,0x27,0x3d,0x04
00003c  6800              LDR      r0,[r0,#0]            ;5017
00003e  e9d12302          LDRD     r2,r3,[r1,#8]         ;5017
000042  6909              LDR      r1,[r1,#0x10]         ;5017
000044  f8d0c008          LDR      r12,[r0,#8]           ;5017
000048  ea422101          ORR      r1,r2,r1,LSL #8       ;5017
00004c  f42c4c7f          BIC      r12,r12,#0xff00       ;5017
000050  4319              ORRS     r1,r1,r3              ;5017
000052  ea41010c          ORR      r1,r1,r12             ;5017
000056  6081              STR      r1,[r0,#8]            ;5017
000058  4770              BX       lr
00005a  6802              LDR      r2,[r0,#0]            ;5031
00005c  6a13              LDR      r3,[r2,#0x20]         ;5031
00005e  f8d2c020          LDR      r12,[r2,#0x20]        ;5032
000062  f02c0c01          BIC      r12,r12,#1            ;5032
000066  f8c2c020          STR      r12,[r2,#0x20]        ;5032
00006a  6802              LDR      r2,[r0,#0]            ;5033
00006c  f8d2c018          LDR      r12,[r2,#0x18]        ;5033
000070  6909              LDR      r1,[r1,#0x10]         ;5037
000072  f02c0cf0          BIC      r12,r12,#0xf0         ;5036
000076  ea4c1101          ORR      r1,r12,r1,LSL #4      ;5037
00007a  6191              STR      r1,[r2,#0x18]         ;5040
00007c  6800              LDR      r0,[r0,#0]            ;5041
00007e  6203              STR      r3,[r0,#0x20]         ;5041
000080  4770              BX       lr
000082  6800              LDR      r0,[r0,#0]            ;5054
000084  690b              LDR      r3,[r1,#0x10]         ;5054
000086  688a              LDR      r2,[r1,#8]            ;5054
000088  6a01              LDR      r1,[r0,#0x20]         ;5054
00008a  f8d0c020          LDR      r12,[r0,#0x20]        ;5054
00008e  f02c0c01          BIC      r12,r12,#1            ;5054
000092  f8c0c020          STR      r12,[r0,#0x20]        ;5054
000096  f8d0c018          LDR      r12,[r0,#0x18]        ;5054
00009a  f021010a          BIC      r1,r1,#0xa            ;5054
00009e  f02c0cf0          BIC      r12,r12,#0xf0         ;5054
0000a2  ea4c1303          ORR      r3,r12,r3,LSL #4      ;5054
0000a6  4311              ORRS     r1,r1,r2              ;5054
0000a8  6183              STR      r3,[r0,#0x18]         ;5054
0000aa  6201              STR      r1,[r0,#0x20]         ;5054
0000ac  4770              BX       lr
0000ae  6800              LDR      r0,[r0,#0]            ;5068
0000b0  688a              LDR      r2,[r1,#8]            ;5068
0000b2  6909              LDR      r1,[r1,#0x10]         ;5068
0000b4  6a03              LDR      r3,[r0,#0x20]         ;5068
0000b6  f0230310          BIC      r3,r3,#0x10           ;5068
0000ba  6203              STR      r3,[r0,#0x20]         ;5068
0000bc  6983              LDR      r3,[r0,#0x18]         ;5068
0000be  f8d0c020          LDR      r12,[r0,#0x20]        ;5068
0000c2  f4234370          BIC      r3,r3,#0xf000         ;5068
0000c6  ea433101          ORR      r1,r3,r1,LSL #12      ;5068
0000ca  f02c03a0          BIC      r3,r12,#0xa0          ;5068
0000ce  ea431202          ORR      r2,r3,r2,LSL #4       ;5068
0000d2  6181              STR      r1,[r0,#0x18]         ;5068
0000d4  6202              STR      r2,[r0,#0x20]         ;5068
0000d6  4770              BX       lr
;;;5106   
                          ENDP


                          AREA ||i.TIM_TI1_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_TI1_SetConfig PROC
;;;4539     */
;;;4540   void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b430              PUSH     {r4,r5}
;;;4541                          uint32_t TIM_ICFilter)
;;;4542   {
;;;4543     uint32_t tmpccmr1 = 0U;
;;;4544     uint32_t tmpccer = 0U;
;;;4545     
;;;4546     /* Disable the Channel 1: Reset the CC1E Bit */
;;;4547     TIMx->CCER &= ~TIM_CCER_CC1E;
000002  f8d0c020          LDR      r12,[r0,#0x20]
000006  f02c0c01          BIC      r12,r12,#1
00000a  f8c0c020          STR      r12,[r0,#0x20]
;;;4548     tmpccmr1 = TIMx->CCMR1;
00000e  f8d0c018          LDR      r12,[r0,#0x18]
;;;4549     tmpccer = TIMx->CCER;
000012  6a04              LDR      r4,[r0,#0x20]
;;;4550   
;;;4551     /* Select the Input */
;;;4552     if(IS_TIM_CC2_INSTANCE(TIMx) != RESET)
000014  f1a04580          SUB      r5,r0,#0x40000000
000018  f5b53580          SUBS     r5,r5,#0x10000
00001c  bf18              IT       NE
00001e  f1b04f80          CMPNE    r0,#0x40000000
000022  d021              BEQ      |L96.104|
000024  f1a04580          SUB      r5,r0,#0x40000000
000028  f5b56580          SUBS     r5,r5,#0x400
00002c  bf1c              ITT      NE
00002e  f1a04580          SUBNE    r5,r0,#0x40000000
000032  f5b56500          SUBSNE   r5,r5,#0x800
000036  d017              BEQ      |L96.104|
000038  f1a04580          SUB      r5,r0,#0x40000000
00003c  f5b56540          SUBS     r5,r5,#0xc00
000040  bf1c              ITT      NE
000042  f1a04580          SUBNE    r5,r0,#0x40000000
000046  f5b53582          SUBSNE   r5,r5,#0x10400
00004a  d00d              BEQ      |L96.104|
00004c  f1a04580          SUB      r5,r0,#0x40000000
000050  f5b535a0          SUBS     r5,r5,#0x14000
000054  bf1f              ITTTT    NE
000056  f1a04580          SUBNE    r5,r0,#0x40000000
00005a  f5b555c0          SUBSNE   r5,r5,#0x1800
;;;4553     {
;;;4554       tmpccmr1 &= ~TIM_CCMR1_CC1S;
;;;4555       tmpccmr1 |= TIM_ICSelection;
;;;4556     } 
;;;4557     else
;;;4558     {
;;;4559       tmpccmr1 &= ~TIM_CCMR1_CC1S;
00005e  f02c0203          BICNE    r2,r12,#3
;;;4560       tmpccmr1 |= TIM_CCMR1_CC1S_0;
000062  f0420201          ORRNE    r2,r2,#1
000066  d103              BNE      |L96.112|
                  |L96.104|
000068  f02c0c03          BIC      r12,r12,#3            ;4554
00006c  ea4c0202          ORR      r2,r12,r2             ;4555
                  |L96.112|
;;;4561     }
;;;4562   
;;;4563     /* Set the filter */
;;;4564     tmpccmr1 &= ~TIM_CCMR1_IC1F;
;;;4565     tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);
000070  f04f0cf0          MOV      r12,#0xf0
000074  f02202f0          BIC      r2,r2,#0xf0           ;4564
000078  ea0c1303          AND      r3,r12,r3,LSL #4
00007c  431a              ORRS     r2,r2,r3
;;;4566   
;;;4567     /* Select the Polarity and set the CC1E Bit */
;;;4568     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
00007e  f024030a          BIC      r3,r4,#0xa
;;;4569     tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
000082  f001010a          AND      r1,r1,#0xa
000086  4319              ORRS     r1,r1,r3
;;;4570   
;;;4571     /* Write to TIMx CCMR1 and CCER registers */
;;;4572     TIMx->CCMR1 = tmpccmr1;
000088  6182              STR      r2,[r0,#0x18]
;;;4573     TIMx->CCER = tmpccer;
00008a  6201              STR      r1,[r0,#0x20]
;;;4574   }
00008c  bc30              POP      {r4,r5}
00008e  4770              BX       lr
;;;4575   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F4_V1.21.0\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_tim.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_tim_c_a9d95b52____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F4_V1.21.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f4xx_hal_tim_c_a9d95b52____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_tim_c_a9d95b52____REVSH|
#line 402
|__asm___19_stm32f4xx_hal_tim_c_a9d95b52____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_tim_c_a9d95b52____RRX|
#line 587
|__asm___19_stm32f4xx_hal_tim_c_a9d95b52____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
