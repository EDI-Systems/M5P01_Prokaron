; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f0xx_hal_uart.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f0xx_hal_uart.d --cpu=Cortex-M0 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F0_V1.9.0\Drivers\STM32F0xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_F0_V1.9.0\Drivers\CMSIS\Device\ST\STM32L0xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F0_V1.9.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F0_V1.9.0\Drivers\STM32F0xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F030F4P6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F0xx_DFP\2.0.0\Drivers\CMSIS\Device\ST\STM32F0xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F030x6 -DSTM32F030x6 -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f0xx_hal_uart.crf ..\..\..\M0P0_Library\STM32Cube_FW_F0_V1.9.0\Drivers\STM32F0xx_HAL_Driver\Src\stm32f0xx_hal_uart.c]
                          THUMB

                          AREA ||i.HAL_HalfDuplex_EnableReceiver||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableReceiver PROC
;;;2028     */
;;;2029   HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
000000  6e81              LDR      r1,[r0,#0x68]
;;;2030   {
;;;2031     /* Process Locked */
;;;2032     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  d013              BEQ      |L1.46|
000006  2101              MOVS     r1,#1
;;;2033     huart->gState = HAL_UART_STATE_BUSY;
000008  6681              STR      r1,[r0,#0x68]
00000a  2124              MOVS     r1,#0x24
00000c  66c1              STR      r1,[r0,#0x6c]
;;;2034   
;;;2035     /* Clear TE and RE bits */
;;;2036     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));
00000e  6801              LDR      r1,[r0,#0]
000010  680a              LDR      r2,[r1,#0]
000012  230c              MOVS     r3,#0xc
000014  439a              BICS     r2,r2,r3
000016  600a              STR      r2,[r1,#0]
;;;2037     /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
;;;2038     SET_BIT(huart->Instance->CR1, USART_CR1_RE);
000018  6801              LDR      r1,[r0,#0]
00001a  680a              LDR      r2,[r1,#0]
00001c  2304              MOVS     r3,#4
00001e  431a              ORRS     r2,r2,r3
000020  600a              STR      r2,[r1,#0]
;;;2039   
;;;2040     huart->gState = HAL_UART_STATE_READY;
000022  2120              MOVS     r1,#0x20
000024  66c1              STR      r1,[r0,#0x6c]
;;;2041     /* Process Unlocked */
;;;2042     __HAL_UNLOCK(huart);
000026  2100              MOVS     r1,#0
;;;2043   
;;;2044     return HAL_OK;
000028  6681              STR      r1,[r0,#0x68]
00002a  4608              MOV      r0,r1
;;;2045   }
00002c  4770              BX       lr
                  |L1.46|
00002e  2002              MOVS     r0,#2                 ;2032
000030  4770              BX       lr
;;;2046   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_EnableTransmitter||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableTransmitter PROC
;;;2004     */
;;;2005   HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
000000  6e81              LDR      r1,[r0,#0x68]
;;;2006   {
;;;2007     /* Process Locked */
;;;2008     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  d013              BEQ      |L2.46|
000006  2101              MOVS     r1,#1
;;;2009     huart->gState = HAL_UART_STATE_BUSY;
000008  6681              STR      r1,[r0,#0x68]
00000a  2124              MOVS     r1,#0x24
00000c  66c1              STR      r1,[r0,#0x6c]
;;;2010   
;;;2011     /* Clear TE and RE bits */
;;;2012     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));
00000e  6801              LDR      r1,[r0,#0]
000010  680a              LDR      r2,[r1,#0]
000012  230c              MOVS     r3,#0xc
000014  439a              BICS     r2,r2,r3
000016  600a              STR      r2,[r1,#0]
;;;2013     /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
;;;2014     SET_BIT(huart->Instance->CR1, USART_CR1_TE);
000018  6801              LDR      r1,[r0,#0]
00001a  680a              LDR      r2,[r1,#0]
00001c  2308              MOVS     r3,#8
00001e  431a              ORRS     r2,r2,r3
000020  600a              STR      r2,[r1,#0]
;;;2015   
;;;2016     huart->gState = HAL_UART_STATE_READY;
000022  2120              MOVS     r1,#0x20
000024  66c1              STR      r1,[r0,#0x6c]
;;;2017   
;;;2018     /* Process Unlocked */
;;;2019     __HAL_UNLOCK(huart);
000026  2100              MOVS     r1,#0
;;;2020   
;;;2021     return HAL_OK;
000028  6681              STR      r1,[r0,#0x68]
00002a  4608              MOV      r0,r1
;;;2022   }
00002c  4770              BX       lr
                  |L2.46|
00002e  2002              MOVS     r0,#2                 ;2008
000030  4770              BX       lr
;;;2023   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_Init||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_Init PROC
;;;369      */
;;;370    HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
000000  2800              CMP      r0,#0
;;;371    {
;;;372      /* Check the UART handle allocation */
;;;373      if(huart == NULL)
000002  d101              BNE      |L3.8|
;;;374      {
;;;375        return HAL_ERROR;
000004  2001              MOVS     r0,#1
;;;376      }
;;;377    
;;;378      /* Check UART instance */
;;;379      assert_param(IS_UART_HALFDUPLEX_INSTANCE(huart->Instance));
;;;380    
;;;381      if(huart->gState == HAL_UART_STATE_RESET)
;;;382      {
;;;383        /* Allocate lock resource and initialize it */
;;;384        huart->Lock = HAL_UNLOCKED;
;;;385    
;;;386        /* Init the low level hardware : GPIO, CLOCK */
;;;387        HAL_UART_MspInit(huart);
;;;388      }
;;;389    
;;;390      huart->gState = HAL_UART_STATE_BUSY;
;;;391    
;;;392      /* Disable the Peripheral */
;;;393      __HAL_UART_DISABLE(huart);
;;;394    
;;;395      /* Set the UART Communication parameters */
;;;396      if (UART_SetConfig(huart) == HAL_ERROR)
;;;397      {
;;;398        return HAL_ERROR;
;;;399      }
;;;400    
;;;401      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;402      {
;;;403        UART_AdvFeatureConfig(huart);
;;;404      }
;;;405    
;;;406      /* In half-duplex mode, the following bits must be kept cleared:
;;;407      - LINEN (if LIN is supported) and CLKEN bits in the USART_CR2 register,
;;;408      - SCEN (if Smartcard is supported), and IREN (if IrDA is supported)  bits in the USART_CR3 register. */
;;;409    #if defined (USART_CR2_LINEN)
;;;410      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;411    #else
;;;412      CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
;;;413    #endif
;;;414    #if defined (USART_CR3_SCEN)
;;;415    #if defined (USART_CR3_IREN)
;;;416      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
;;;417    #else
;;;418      CLEAR_BIT(huart->Instance->CR3, USART_CR3_SCEN);
;;;419    #endif
;;;420    #else
;;;421    #if defined (USART_CR3_IREN)
;;;422      CLEAR_BIT(huart->Instance->CR3, USART_CR3_IREN);
;;;423    #endif
;;;424    #endif
;;;425    
;;;426      /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;427      SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
;;;428    
;;;429      /* Enable the Peripheral */
;;;430      __HAL_UART_ENABLE(huart);
;;;431    
;;;432      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;433      return (UART_CheckIdleState(huart));
;;;434    }
000006  4770              BX       lr
                  |L3.8|
000008  b570              PUSH     {r4-r6,lr}            ;371
00000a  4604              MOV      r4,r0                 ;371
00000c  6ec0              LDR      r0,[r0,#0x6c]         ;381
00000e  2500              MOVS     r5,#0                 ;381
000010  2800              CMP      r0,#0                 ;381
000012  d103              BNE      |L3.28|
000014  4620              MOV      r0,r4                 ;387
000016  66a5              STR      r5,[r4,#0x68]         ;387
000018  f7fffffe          BL       HAL_UART_MspInit
                  |L3.28|
00001c  2024              MOVS     r0,#0x24              ;390
00001e  66e0              STR      r0,[r4,#0x6c]         ;390
000020  6820              LDR      r0,[r4,#0]            ;393
000022  6801              LDR      r1,[r0,#0]            ;393
000024  0849              LSRS     r1,r1,#1              ;393
000026  0049              LSLS     r1,r1,#1              ;393
000028  6001              STR      r1,[r0,#0]            ;393
00002a  4620              MOV      r0,r4                 ;396
00002c  f7fffffe          BL       UART_SetConfig
000030  2801              CMP      r0,#1                 ;396
000032  d01b              BEQ      |L3.108|
000034  6a60              LDR      r0,[r4,#0x24]         ;401
000036  2800              CMP      r0,#0                 ;401
000038  d002              BEQ      |L3.64|
00003a  4620              MOV      r0,r4                 ;403
00003c  f7fffffe          BL       UART_AdvFeatureConfig
                  |L3.64|
000040  6820              LDR      r0,[r4,#0]            ;412
000042  6841              LDR      r1,[r0,#4]            ;412
000044  2201              MOVS     r2,#1                 ;412
000046  02d2              LSLS     r2,r2,#11             ;412
000048  4391              BICS     r1,r1,r2              ;412
00004a  6041              STR      r1,[r0,#4]            ;412
00004c  6820              LDR      r0,[r4,#0]            ;427
00004e  6881              LDR      r1,[r0,#8]            ;427
000050  2208              MOVS     r2,#8                 ;427
000052  4311              ORRS     r1,r1,r2              ;427
000054  6081              STR      r1,[r0,#8]            ;427
000056  6820              LDR      r0,[r4,#0]            ;430
000058  6801              LDR      r1,[r0,#0]            ;430
00005a  2201              MOVS     r2,#1                 ;430
00005c  4311              ORRS     r1,r1,r2              ;430
00005e  6001              STR      r1,[r0,#0]            ;430
000060  4628              MOV      r0,r5                 ;430
000062  6765              STR      r5,[r4,#0x74]         ;430
000064  2120              MOVS     r1,#0x20              ;430
000066  66e1              STR      r1,[r4,#0x6c]         ;430
000068  6721              STR      r1,[r4,#0x70]         ;430
00006a  66a5              STR      r5,[r4,#0x68]         ;430
                  |L3.108|
00006c  bd70              POP      {r4-r6,pc}
;;;435    
                          ENDP


                          AREA ||i.HAL_MultiProcessor_DisableMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_DisableMuteMode PROC
;;;1973     */
;;;1974   HAL_StatusTypeDef HAL_MultiProcessor_DisableMuteMode(UART_HandleTypeDef *huart)
000000  6e81              LDR      r1,[r0,#0x68]
;;;1975   {
;;;1976     /* Process Locked */
;;;1977     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  d012              BEQ      |L4.44|
000006  2101              MOVS     r1,#1
;;;1978   
;;;1979     huart->gState = HAL_UART_STATE_BUSY;
000008  6681              STR      r1,[r0,#0x68]
00000a  2124              MOVS     r1,#0x24
00000c  66c1              STR      r1,[r0,#0x6c]
;;;1980   
;;;1981      /* Disable USART mute mode by clearing the MME bit in the CR1 register */
;;;1982     CLEAR_BIT(huart->Instance->CR1, USART_CR1_MME);
00000e  6801              LDR      r1,[r0,#0]
000010  680a              LDR      r2,[r1,#0]
000012  2301              MOVS     r3,#1
000014  035b              LSLS     r3,r3,#13
000016  439a              BICS     r2,r2,r3
000018  600a              STR      r2,[r1,#0]
;;;1983   
;;;1984     huart->gState = HAL_UART_STATE_READY;
00001a  2220              MOVS     r2,#0x20
00001c  66c2              STR      r2,[r0,#0x6c]
00001e  2100              MOVS     r1,#0
000020  6741              STR      r1,[r0,#0x74]
000022  66c2              STR      r2,[r0,#0x6c]
000024  6702              STR      r2,[r0,#0x70]
000026  6681              STR      r1,[r0,#0x68]
000028  4608              MOV      r0,r1
;;;1985   
;;;1986     return (UART_CheckIdleState(huart));
;;;1987   }
00002a  4770              BX       lr
                  |L4.44|
00002c  2002              MOVS     r0,#2                 ;1977
00002e  4770              BX       lr
;;;1988   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnableMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnableMuteMode PROC
;;;1952     */
;;;1953   HAL_StatusTypeDef HAL_MultiProcessor_EnableMuteMode(UART_HandleTypeDef *huart)
000000  6e81              LDR      r1,[r0,#0x68]
;;;1954   {
;;;1955     /* Process Locked */
;;;1956     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  d012              BEQ      |L5.44|
000006  2101              MOVS     r1,#1
;;;1957   
;;;1958     huart->gState = HAL_UART_STATE_BUSY;
000008  6681              STR      r1,[r0,#0x68]
00000a  2124              MOVS     r1,#0x24
00000c  66c1              STR      r1,[r0,#0x6c]
;;;1959   
;;;1960     /* Enable USART mute mode by setting the MME bit in the CR1 register */
;;;1961     SET_BIT(huart->Instance->CR1, USART_CR1_MME);
00000e  6801              LDR      r1,[r0,#0]
000010  680a              LDR      r2,[r1,#0]
000012  2301              MOVS     r3,#1
000014  035b              LSLS     r3,r3,#13
000016  431a              ORRS     r2,r2,r3
000018  600a              STR      r2,[r1,#0]
;;;1962   
;;;1963     huart->gState = HAL_UART_STATE_READY;
00001a  2220              MOVS     r2,#0x20
00001c  66c2              STR      r2,[r0,#0x6c]
00001e  2100              MOVS     r1,#0
000020  6741              STR      r1,[r0,#0x74]
000022  66c2              STR      r2,[r0,#0x6c]
000024  6702              STR      r2,[r0,#0x70]
000026  6681              STR      r1,[r0,#0x68]
000028  4608              MOV      r0,r1
;;;1964   
;;;1965     return (UART_CheckIdleState(huart));
;;;1966   }
00002a  4770              BX       lr
                  |L5.44|
00002c  2002              MOVS     r0,#2                 ;1956
00002e  4770              BX       lr
;;;1967   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnterMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnterMuteMode PROC
;;;1994     */
;;;1995   void HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
000000  6800              LDR      r0,[r0,#0]
;;;1996   {
;;;1997     __HAL_UART_SEND_REQ(huart, UART_MUTE_MODE_REQUEST);
000002  6981              LDR      r1,[r0,#0x18]
000004  2204              MOVS     r2,#4
000006  4311              ORRS     r1,r1,r2
000008  6181              STR      r1,[r0,#0x18]
;;;1998   }
00000a  4770              BX       lr
;;;1999   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_Init||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_Init PROC
;;;454      */
;;;455    HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
000000  2800              CMP      r0,#0
;;;456    {
;;;457      /* Check the UART handle allocation */
;;;458      if(huart == NULL)
000002  d101              BNE      |L7.8|
;;;459      {
;;;460        return HAL_ERROR;
000004  2001              MOVS     r0,#1
;;;461      }
;;;462    
;;;463      /* Check the wake up method parameter */
;;;464      assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
;;;465    
;;;466      if(huart->gState == HAL_UART_STATE_RESET)
;;;467      {
;;;468        /* Allocate lock resource and initialize it */
;;;469        huart->Lock = HAL_UNLOCKED;
;;;470    
;;;471        /* Init the low level hardware : GPIO, CLOCK */
;;;472        HAL_UART_MspInit(huart);
;;;473      }
;;;474    
;;;475      huart->gState = HAL_UART_STATE_BUSY;
;;;476    
;;;477      /* Disable the Peripheral */
;;;478      __HAL_UART_DISABLE(huart);
;;;479    
;;;480      /* Set the UART Communication parameters */
;;;481      if (UART_SetConfig(huart) == HAL_ERROR)
;;;482      {
;;;483        return HAL_ERROR;
;;;484      }
;;;485    
;;;486      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;487      {
;;;488        UART_AdvFeatureConfig(huart);
;;;489      }
;;;490    
;;;491      /* In multiprocessor mode, the following bits must be kept cleared:
;;;492      - LINEN (if LIN is supported) and CLKEN bits in the USART_CR2 register,
;;;493      - SCEN (if Smartcard is supported), HDSEL and IREN (if IrDA is supported) bits in the USART_CR3 register. */
;;;494    #if defined (USART_CR2_LINEN)
;;;495      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;496    #else
;;;497      CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
;;;498    #endif
;;;499    #if defined (USART_CR3_SCEN)
;;;500    #if defined (USART_CR3_IREN)
;;;501      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;502    #else
;;;503      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL));
;;;504    #endif
;;;505    #else
;;;506    #if defined (USART_CR3_IREN)
;;;507      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN));
;;;508    #else
;;;509      CLEAR_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
;;;510    #endif
;;;511    #endif
;;;512    
;;;513      if (WakeUpMethod == UART_WAKEUPMETHOD_ADDRESSMARK)
;;;514      {
;;;515        /* If address mark wake up method is chosen, set the USART address node */
;;;516        MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, ((uint32_t)Address << UART_CR2_ADDRESS_LSB_POS));
;;;517      }
;;;518    
;;;519      /* Set the wake up method by setting the WAKE bit in the CR1 register */
;;;520      MODIFY_REG(huart->Instance->CR1, USART_CR1_WAKE, WakeUpMethod);
;;;521    
;;;522      /* Enable the Peripheral */
;;;523      __HAL_UART_ENABLE(huart);
;;;524    
;;;525      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;526      return (UART_CheckIdleState(huart));
;;;527    }
000006  4770              BX       lr
                  |L7.8|
000008  b5f8              PUSH     {r3-r7,lr}            ;456
00000a  4604              MOV      r4,r0                 ;456
00000c  6ec0              LDR      r0,[r0,#0x6c]         ;466
00000e  4615              MOV      r5,r2                 ;456
000010  460f              MOV      r7,r1                 ;456
000012  2600              MOVS     r6,#0                 ;466
000014  2800              CMP      r0,#0                 ;466
000016  d103              BNE      |L7.32|
000018  4620              MOV      r0,r4                 ;472
00001a  66a6              STR      r6,[r4,#0x68]         ;472
00001c  f7fffffe          BL       HAL_UART_MspInit
                  |L7.32|
000020  2024              MOVS     r0,#0x24              ;475
000022  66e0              STR      r0,[r4,#0x6c]         ;475
000024  6820              LDR      r0,[r4,#0]            ;478
000026  6801              LDR      r1,[r0,#0]            ;478
000028  0849              LSRS     r1,r1,#1              ;478
00002a  0049              LSLS     r1,r1,#1              ;478
00002c  6001              STR      r1,[r0,#0]            ;478
00002e  4620              MOV      r0,r4                 ;481
000030  f7fffffe          BL       UART_SetConfig
000034  2801              CMP      r0,#1                 ;481
000036  d029              BEQ      |L7.140|
000038  6a60              LDR      r0,[r4,#0x24]         ;486
00003a  2800              CMP      r0,#0                 ;486
00003c  d002              BEQ      |L7.68|
00003e  4620              MOV      r0,r4                 ;488
000040  f7fffffe          BL       UART_AdvFeatureConfig
                  |L7.68|
000044  6821              LDR      r1,[r4,#0]            ;497
000046  684a              LDR      r2,[r1,#4]            ;497
000048  2001              MOVS     r0,#1                 ;497
00004a  02c0              LSLS     r0,r0,#11             ;497
00004c  4382              BICS     r2,r2,r0              ;497
00004e  604a              STR      r2,[r1,#4]            ;497
000050  6821              LDR      r1,[r4,#0]            ;509
000052  688a              LDR      r2,[r1,#8]            ;509
000054  2308              MOVS     r3,#8                 ;509
000056  439a              BICS     r2,r2,r3              ;509
000058  608a              STR      r2,[r1,#8]            ;509
00005a  4285              CMP      r5,r0                 ;513
00005c  d106              BNE      |L7.108|
00005e  6821              LDR      r1,[r4,#0]            ;516
000060  684a              LDR      r2,[r1,#4]            ;516
000062  0212              LSLS     r2,r2,#8              ;516
000064  0a12              LSRS     r2,r2,#8              ;516
000066  063b              LSLS     r3,r7,#24             ;516
000068  431a              ORRS     r2,r2,r3              ;516
00006a  604a              STR      r2,[r1,#4]            ;516
                  |L7.108|
00006c  6822              LDR      r2,[r4,#0]            ;520
00006e  6811              LDR      r1,[r2,#0]            ;520
000070  4381              BICS     r1,r1,r0              ;520
000072  4329              ORRS     r1,r1,r5              ;520
000074  6011              STR      r1,[r2,#0]            ;520
000076  6820              LDR      r0,[r4,#0]            ;523
000078  6801              LDR      r1,[r0,#0]            ;523
00007a  2201              MOVS     r2,#1                 ;523
00007c  4311              ORRS     r1,r1,r2              ;523
00007e  6001              STR      r1,[r0,#0]            ;523
000080  4630              MOV      r0,r6                 ;523
000082  6766              STR      r6,[r4,#0x74]         ;523
000084  2120              MOVS     r1,#0x20              ;523
000086  66e1              STR      r1,[r4,#0x6c]         ;523
000088  6721              STR      r1,[r4,#0x70]         ;523
00008a  66a6              STR      r6,[r4,#0x68]         ;523
                  |L7.140|
00008c  bdf8              POP      {r3-r7,pc}
;;;528    
                          ENDP


                          AREA ||i.HAL_UART_Abort||, CODE, READONLY, ALIGN=1

                  HAL_UART_Abort PROC
;;;1245   */
;;;1246   HAL_StatusTypeDef HAL_UART_Abort(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1247   {
000002  4604              MOV      r4,r0
;;;1248     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1249     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6800              LDR      r0,[r0,#0]
000006  6801              LDR      r1,[r0,#0]
000008  22ff              MOVS     r2,#0xff
00000a  32e1              ADDS     r2,r2,#0xe1
00000c  4391              BICS     r1,r1,r2
00000e  6001              STR      r1,[r0,#0]
;;;1250     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000010  6820              LDR      r0,[r4,#0]
000012  6881              LDR      r1,[r0,#8]
000014  0849              LSRS     r1,r1,#1
000016  0049              LSLS     r1,r1,#1
000018  6081              STR      r1,[r0,#8]
;;;1251   
;;;1252     /* Disable the UART DMA Tx request if enabled */
;;;1253     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
00001a  6820              LDR      r0,[r4,#0]
00001c  6881              LDR      r1,[r0,#8]
00001e  2500              MOVS     r5,#0
000020  0609              LSLS     r1,r1,#24
000022  2900              CMP      r1,#0
000024  da0a              BGE      |L8.60|
;;;1254     {
;;;1255       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000026  6881              LDR      r1,[r0,#8]
000028  2280              MOVS     r2,#0x80
00002a  4391              BICS     r1,r1,r2
00002c  6081              STR      r1,[r0,#8]
;;;1256   
;;;1257       /* Abort the UART DMA Tx channel : use blocking DMA Abort API (no callback) */
;;;1258       if(huart->hdmatx != NULL)
00002e  6e20              LDR      r0,[r4,#0x60]
000030  2800              CMP      r0,#0
000032  d003              BEQ      |L8.60|
;;;1259       {
;;;1260         /* Set the UART DMA Abort callback to Null. 
;;;1261            No call back execution at end of DMA abort procedure */
;;;1262         huart->hdmatx->XferAbortCallback = NULL;
;;;1263   
;;;1264         HAL_DMA_Abort(huart->hdmatx);
000034  6385              STR      r5,[r0,#0x38]
000036  6e20              LDR      r0,[r4,#0x60]
000038  f7fffffe          BL       HAL_DMA_Abort
                  |L8.60|
;;;1265       }
;;;1266     }
;;;1267   
;;;1268     /* Disable the UART DMA Rx request if enabled */
;;;1269     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
00003c  6820              LDR      r0,[r4,#0]
00003e  6881              LDR      r1,[r0,#8]
000040  0649              LSLS     r1,r1,#25
000042  d50a              BPL      |L8.90|
;;;1270     {
;;;1271       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000044  6881              LDR      r1,[r0,#8]
000046  2240              MOVS     r2,#0x40
000048  4391              BICS     r1,r1,r2
00004a  6081              STR      r1,[r0,#8]
;;;1272   
;;;1273       /* Abort the UART DMA Rx channel : use blocking DMA Abort API (no callback) */
;;;1274       if(huart->hdmarx != NULL)
00004c  6e60              LDR      r0,[r4,#0x64]
00004e  2800              CMP      r0,#0
000050  d003              BEQ      |L8.90|
;;;1275       {
;;;1276         /* Set the UART DMA Abort callback to Null. 
;;;1277            No call back execution at end of DMA abort procedure */
;;;1278         huart->hdmarx->XferAbortCallback = NULL;
;;;1279   
;;;1280         HAL_DMA_Abort(huart->hdmarx);
000052  6385              STR      r5,[r0,#0x38]
000054  6e60              LDR      r0,[r4,#0x64]
000056  f7fffffe          BL       HAL_DMA_Abort
                  |L8.90|
;;;1281       }
;;;1282     }
;;;1283   
;;;1284     /* Reset Tx and Rx transfer counters */
;;;1285     huart->TxXferCount = 0U; 
00005a  4620              MOV      r0,r4
00005c  3040              ADDS     r0,r0,#0x40
00005e  8245              STRH     r5,[r0,#0x12]
;;;1286     huart->RxXferCount = 0U; 
000060  8345              STRH     r5,[r0,#0x1a]
;;;1287   
;;;1288     /* Clear the Error flags in the ICR register */
;;;1289     __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
000062  6821              LDR      r1,[r4,#0]
000064  200f              MOVS     r0,#0xf
000066  6208              STR      r0,[r1,#0x20]
;;;1290   
;;;1291     /* Restore huart->gState and huart->RxState to Ready */
;;;1292     huart->gState  = HAL_UART_STATE_READY;
000068  2020              MOVS     r0,#0x20
00006a  66e0              STR      r0,[r4,#0x6c]
;;;1293     huart->RxState = HAL_UART_STATE_READY;
00006c  6720              STR      r0,[r4,#0x70]
;;;1294   
;;;1295     /* Reset Handle ErrorCode to No Error */
;;;1296     huart->ErrorCode = HAL_UART_ERROR_NONE;
00006e  6765              STR      r5,[r4,#0x74]
;;;1297   
;;;1298     return HAL_OK;
000070  2000              MOVS     r0,#0
;;;1299   }
000072  bd70              POP      {r4-r6,pc}
;;;1300   
                          ENDP


                          AREA ||i.HAL_UART_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortCpltCallback PROC
;;;1884     */
;;;1885   __weak void HAL_UART_AbortCpltCallback (UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1886   {
;;;1887     /* Prevent unused argument(s) compilation warning */
;;;1888     UNUSED(huart);
;;;1889   
;;;1890     /* NOTE : This function should not be modified, when the callback is needed,
;;;1891               the HAL_UART_AbortCpltCallback can be implemented in the user file.
;;;1892      */
;;;1893   }
;;;1894   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceive PROC
;;;1354   */
;;;1355   HAL_StatusTypeDef HAL_UART_AbortReceive(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1356   {
000002  4604              MOV      r4,r0
;;;1357     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1358     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  6800              LDR      r0,[r0,#0]
000006  6801              LDR      r1,[r0,#0]
000008  22ff              MOVS     r2,#0xff
00000a  3221              ADDS     r2,r2,#0x21
00000c  4391              BICS     r1,r1,r2
00000e  6001              STR      r1,[r0,#0]
;;;1359     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000010  6820              LDR      r0,[r4,#0]
000012  6881              LDR      r1,[r0,#8]
000014  0849              LSRS     r1,r1,#1
000016  0049              LSLS     r1,r1,#1
000018  6081              STR      r1,[r0,#8]
;;;1360   
;;;1361     /* Disable the UART DMA Rx request if enabled */
;;;1362     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
00001a  6820              LDR      r0,[r4,#0]
00001c  6881              LDR      r1,[r0,#8]
00001e  2500              MOVS     r5,#0
000020  0649              LSLS     r1,r1,#25
000022  2900              CMP      r1,#0
000024  da0a              BGE      |L10.60|
;;;1363     {
;;;1364       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000026  6881              LDR      r1,[r0,#8]
000028  2240              MOVS     r2,#0x40
00002a  4391              BICS     r1,r1,r2
00002c  6081              STR      r1,[r0,#8]
;;;1365   
;;;1366       /* Abort the UART DMA Rx channel : use blocking DMA Abort API (no callback) */
;;;1367       if(huart->hdmarx != NULL)
00002e  6e60              LDR      r0,[r4,#0x64]
000030  2800              CMP      r0,#0
000032  d003              BEQ      |L10.60|
;;;1368       {
;;;1369         /* Set the UART DMA Abort callback to Null. 
;;;1370            No call back execution at end of DMA abort procedure */
;;;1371         huart->hdmarx->XferAbortCallback = NULL;
;;;1372   
;;;1373         HAL_DMA_Abort(huart->hdmarx);
000034  6385              STR      r5,[r0,#0x38]
000036  6e60              LDR      r0,[r4,#0x64]
000038  f7fffffe          BL       HAL_DMA_Abort
                  |L10.60|
;;;1374       }
;;;1375     }
;;;1376   
;;;1377     /* Reset Rx transfer counter */
;;;1378     huart->RxXferCount = 0U; 
00003c  205a              MOVS     r0,#0x5a
00003e  5305              STRH     r5,[r0,r4]
;;;1379   
;;;1380     /* Clear the Error flags in the ICR register */
;;;1381     __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
000040  6821              LDR      r1,[r4,#0]
000042  200f              MOVS     r0,#0xf
000044  6208              STR      r0,[r1,#0x20]
;;;1382   
;;;1383     /* Restore huart->RxState to Ready */
;;;1384     huart->RxState = HAL_UART_STATE_READY;
000046  2020              MOVS     r0,#0x20
000048  6720              STR      r0,[r4,#0x70]
;;;1385   
;;;1386     return HAL_OK;
00004a  2000              MOVS     r0,#0
;;;1387   }
00004c  bd70              POP      {r4-r6,pc}
;;;1388   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceiveCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceiveCpltCallback PROC
;;;1914     */
;;;1915   __weak void HAL_UART_AbortReceiveCpltCallback (UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1916   {
;;;1917     /* Prevent unused argument(s) compilation warning */
;;;1918     UNUSED(huart);
;;;1919   
;;;1920     /* NOTE : This function should not be modified, when the callback is needed,
;;;1921               the HAL_UART_AbortReceiveCpltCallback can be implemented in the user file.
;;;1922      */
;;;1923   }
;;;1924   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortReceive_IT PROC
;;;1592   */
;;;1593   HAL_StatusTypeDef HAL_UART_AbortReceive_IT(UART_HandleTypeDef *huart)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1594   {
000002  4604              MOV      r4,r0
;;;1595     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1596     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  6800              LDR      r0,[r0,#0]
000006  6801              LDR      r1,[r0,#0]
000008  22ff              MOVS     r2,#0xff
00000a  3221              ADDS     r2,r2,#0x21
00000c  4391              BICS     r1,r1,r2
00000e  6001              STR      r1,[r0,#0]
;;;1597     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000010  6820              LDR      r0,[r4,#0]
000012  6881              LDR      r1,[r0,#8]
000014  0849              LSRS     r1,r1,#1
000016  0049              LSLS     r1,r1,#1
000018  6081              STR      r1,[r0,#8]
;;;1598   
;;;1599     /* Disable the UART DMA Rx request if enabled */
;;;1600     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
00001a  6821              LDR      r1,[r4,#0]
00001c  6888              LDR      r0,[r1,#8]
00001e  2200              MOVS     r2,#0
000020  0646              LSLS     r6,r0,#25
;;;1601     {
;;;1602       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1603   
;;;1604       /* Abort the UART DMA Rx channel : use non blocking DMA Abort API (callback) */
;;;1605       if(huart->hdmarx != NULL)
;;;1606       {
;;;1607         /* Set the UART DMA Abort callback : 
;;;1608            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1609         huart->hdmarx->XferAbortCallback = UART_DMARxOnlyAbortCallback;
;;;1610   
;;;1611         /* Abort DMA RX */
;;;1612         if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
;;;1613         {
;;;1614           /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
;;;1615           huart->hdmarx->XferAbortCallback(huart->hdmarx);
;;;1616         }
;;;1617       }
;;;1618       else
;;;1619       {
;;;1620         /* Reset Rx transfer counter */
;;;1621         huart->RxXferCount = 0U; 
000022  4620              MOV      r0,r4
000024  3040              ADDS     r0,r0,#0x40
;;;1622   
;;;1623         /* Clear the Error flags in the ICR register */
;;;1624         __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
000026  230f              MOVS     r3,#0xf
;;;1625   
;;;1626         /* Restore huart->RxState to Ready */
;;;1627         huart->RxState = HAL_UART_STATE_READY;
000028  2520              MOVS     r5,#0x20
00002a  2e00              CMP      r6,#0                 ;1600
00002c  da19              BGE      |L12.98|
00002e  688e              LDR      r6,[r1,#8]            ;1602
000030  2740              MOVS     r7,#0x40              ;1602
000032  43be              BICS     r6,r6,r7              ;1602
000034  608e              STR      r6,[r1,#8]            ;1602
000036  6e61              LDR      r1,[r4,#0x64]         ;1605
000038  2900              CMP      r1,#0                 ;1605
00003a  d00a              BEQ      |L12.82|
00003c  480d              LDR      r0,|L12.116|
00003e  6388              STR      r0,[r1,#0x38]         ;1612
000040  6e60              LDR      r0,[r4,#0x64]         ;1612
000042  f7fffffe          BL       HAL_DMA_Abort_IT
000046  2800              CMP      r0,#0                 ;1612
000048  d011              BEQ      |L12.110|
00004a  6e60              LDR      r0,[r4,#0x64]         ;1615
00004c  6b81              LDR      r1,[r0,#0x38]         ;1615
00004e  4788              BLX      r1                    ;1615
000050  e00d              B        |L12.110|
                  |L12.82|
000052  8342              STRH     r2,[r0,#0x1a]         ;1621
000054  6820              LDR      r0,[r4,#0]            ;1624
000056  6203              STR      r3,[r0,#0x20]         ;1624
000058  6725              STR      r5,[r4,#0x70]
;;;1628   
;;;1629         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1630         HAL_UART_AbortReceiveCpltCallback(huart);
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
000060  e005              B        |L12.110|
                  |L12.98|
;;;1631       }
;;;1632     }
;;;1633     else
;;;1634     {
;;;1635       /* Reset Rx transfer counter */
;;;1636       huart->RxXferCount = 0U; 
000062  8342              STRH     r2,[r0,#0x1a]
;;;1637   
;;;1638       /* Clear the Error flags in the ICR register */
;;;1639       __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
000064  620b              STR      r3,[r1,#0x20]
;;;1640   
;;;1641       /* Restore huart->RxState to Ready */
;;;1642       huart->RxState = HAL_UART_STATE_READY;
000066  6725              STR      r5,[r4,#0x70]
;;;1643   
;;;1644       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1645       HAL_UART_AbortReceiveCpltCallback(huart);
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
                  |L12.110|
;;;1646     }
;;;1647   
;;;1648     return HAL_OK;
00006e  2000              MOVS     r0,#0
;;;1649   }
000070  bdf8              POP      {r3-r7,pc}
;;;1650   
                          ENDP

000072  0000              DCW      0x0000
                  |L12.116|
                          DCD      UART_DMARxOnlyAbortCallback

                          AREA ||i.HAL_UART_AbortTransmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmit PROC
;;;1312   */
;;;1313   HAL_StatusTypeDef HAL_UART_AbortTransmit(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1314   {
000002  4604              MOV      r4,r0
;;;1315     /* Disable TXEIE and TCIE interrupts */
;;;1316     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6800              LDR      r0,[r0,#0]
000006  6801              LDR      r1,[r0,#0]
000008  22c0              MOVS     r2,#0xc0
00000a  4391              BICS     r1,r1,r2
00000c  6001              STR      r1,[r0,#0]
;;;1317   
;;;1318     /* Disable the UART DMA Tx request if enabled */
;;;1319     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
00000e  6820              LDR      r0,[r4,#0]
000010  6881              LDR      r1,[r0,#8]
000012  2500              MOVS     r5,#0
000014  0609              LSLS     r1,r1,#24
000016  2900              CMP      r1,#0
000018  da0a              BGE      |L13.48|
;;;1320     {
;;;1321       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00001a  6881              LDR      r1,[r0,#8]
00001c  2280              MOVS     r2,#0x80
00001e  4391              BICS     r1,r1,r2
000020  6081              STR      r1,[r0,#8]
;;;1322   
;;;1323       /* Abort the UART DMA Tx channel : use blocking DMA Abort API (no callback) */
;;;1324       if(huart->hdmatx != NULL)
000022  6e20              LDR      r0,[r4,#0x60]
000024  2800              CMP      r0,#0
000026  d003              BEQ      |L13.48|
;;;1325       {
;;;1326         /* Set the UART DMA Abort callback to Null. 
;;;1327            No call back execution at end of DMA abort procedure */
;;;1328         huart->hdmatx->XferAbortCallback = NULL;
;;;1329   
;;;1330         HAL_DMA_Abort(huart->hdmatx);
000028  6385              STR      r5,[r0,#0x38]
00002a  6e20              LDR      r0,[r4,#0x60]
00002c  f7fffffe          BL       HAL_DMA_Abort
                  |L13.48|
;;;1331       }
;;;1332     }
;;;1333   
;;;1334     /* Reset Tx transfer counter */
;;;1335     huart->TxXferCount = 0U; 
000030  2052              MOVS     r0,#0x52
000032  5305              STRH     r5,[r0,r4]
;;;1336   
;;;1337     /* Restore huart->gState to Ready */
;;;1338     huart->gState = HAL_UART_STATE_READY;
000034  2020              MOVS     r0,#0x20
000036  66e0              STR      r0,[r4,#0x6c]
;;;1339   
;;;1340     return HAL_OK;
000038  2000              MOVS     r0,#0
;;;1341   }
00003a  bd70              POP      {r4-r6,pc}
;;;1342   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmitCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmitCpltCallback PROC
;;;1899     */
;;;1900   __weak void HAL_UART_AbortTransmitCpltCallback (UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1901   {
;;;1902     /* Prevent unused argument(s) compilation warning */
;;;1903     UNUSED(huart);
;;;1904   
;;;1905     /* NOTE : This function should not be modified, when the callback is needed,
;;;1906               the HAL_UART_AbortTransmitCpltCallback can be implemented in the user file.
;;;1907      */
;;;1908   }
;;;1909   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortTransmit_IT PROC
;;;1527   */
;;;1528   HAL_StatusTypeDef HAL_UART_AbortTransmit_IT(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1529   {
000002  4604              MOV      r4,r0
;;;1530     /* Disable TXEIE and TCIE interrupts */
;;;1531     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6800              LDR      r0,[r0,#0]
000006  6801              LDR      r1,[r0,#0]
000008  22c0              MOVS     r2,#0xc0
00000a  4391              BICS     r1,r1,r2
00000c  6001              STR      r1,[r0,#0]
;;;1532   
;;;1533     /* Disable the UART DMA Tx request if enabled */
;;;1534     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
00000e  6821              LDR      r1,[r4,#0]
000010  6888              LDR      r0,[r1,#8]
000012  2200              MOVS     r2,#0
000014  0605              LSLS     r5,r0,#24
;;;1535     {
;;;1536       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1537   
;;;1538       /* Abort the UART DMA Tx channel : use non blocking DMA Abort API (callback) */
;;;1539       if(huart->hdmatx != NULL)
;;;1540       {
;;;1541         /* Set the UART DMA Abort callback : 
;;;1542            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1543         huart->hdmatx->XferAbortCallback = UART_DMATxOnlyAbortCallback;
;;;1544   
;;;1545         /* Abort DMA TX */
;;;1546         if(HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
;;;1547         {
;;;1548           /* Call Directly huart->hdmatx->XferAbortCallback function in case of error */
;;;1549           huart->hdmatx->XferAbortCallback(huart->hdmatx);
;;;1550         }
;;;1551       }
;;;1552       else
;;;1553       {
;;;1554         /* Reset Tx transfer counter */
;;;1555         huart->TxXferCount = 0U; 
000016  4620              MOV      r0,r4
000018  3040              ADDS     r0,r0,#0x40
;;;1556   
;;;1557         /* Restore huart->gState to Ready */
;;;1558         huart->gState = HAL_UART_STATE_READY;
00001a  2320              MOVS     r3,#0x20
00001c  2d00              CMP      r5,#0                 ;1534
00001e  da11              BGE      |L15.68|
000020  688d              LDR      r5,[r1,#8]            ;1536
000022  2680              MOVS     r6,#0x80              ;1536
000024  43b5              BICS     r5,r5,r6              ;1536
000026  608d              STR      r5,[r1,#8]            ;1536
000028  6e21              LDR      r1,[r4,#0x60]         ;1539
00002a  2900              CMP      r1,#0                 ;1539
00002c  d00a              BEQ      |L15.68|
00002e  4809              LDR      r0,|L15.84|
000030  6388              STR      r0,[r1,#0x38]         ;1546
000032  6e20              LDR      r0,[r4,#0x60]         ;1546
000034  f7fffffe          BL       HAL_DMA_Abort_IT
000038  2800              CMP      r0,#0                 ;1546
00003a  d008              BEQ      |L15.78|
00003c  6e20              LDR      r0,[r4,#0x60]         ;1549
00003e  6b81              LDR      r1,[r0,#0x38]         ;1549
000040  4788              BLX      r1                    ;1549
000042  e004              B        |L15.78|
                  |L15.68|
000044  8242              STRH     r2,[r0,#0x12]         ;1555
000046  66e3              STR      r3,[r4,#0x6c]
;;;1559   
;;;1560         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1561         HAL_UART_AbortTransmitCpltCallback(huart);
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
                  |L15.78|
;;;1562       }
;;;1563     }
;;;1564     else
;;;1565     {
;;;1566       /* Reset Tx transfer counter */
;;;1567       huart->TxXferCount = 0U; 
;;;1568   
;;;1569       /* Restore huart->gState to Ready */
;;;1570       huart->gState = HAL_UART_STATE_READY;
;;;1571   
;;;1572       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1573       HAL_UART_AbortTransmitCpltCallback(huart);
;;;1574     }
;;;1575   
;;;1576     return HAL_OK;
00004e  2000              MOVS     r0,#0
;;;1577   }
000050  bd70              POP      {r4-r6,pc}
;;;1578   
                          ENDP

000052  0000              DCW      0x0000
                  |L15.84|
                          DCD      UART_DMATxOnlyAbortCallback

                          AREA ||i.HAL_UART_Abort_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_Abort_IT PROC
;;;1402   */
;;;1403   HAL_StatusTypeDef HAL_UART_Abort_IT(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1404   {
000002  4604              MOV      r4,r0
;;;1405     uint32_t abortcplt = 1U;
;;;1406     
;;;1407     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1408     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6800              LDR      r0,[r0,#0]
000006  2601              MOVS     r6,#1                 ;1405
000008  6801              LDR      r1,[r0,#0]
00000a  22ff              MOVS     r2,#0xff
00000c  32e1              ADDS     r2,r2,#0xe1
00000e  4391              BICS     r1,r1,r2
000010  6001              STR      r1,[r0,#0]
;;;1409     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000012  6820              LDR      r0,[r4,#0]
000014  6881              LDR      r1,[r0,#8]
000016  43b1              BICS     r1,r1,r6
000018  6081              STR      r1,[r0,#8]
;;;1410   
;;;1411     /* If DMA Tx and/or DMA Rx Handles are associated to UART Handle, DMA Abort complete callbacks should be initialised
;;;1412        before any call to DMA Abort functions */
;;;1413     /* DMA Tx Handle is valid */
;;;1414     if(huart->hdmatx != NULL)
00001a  6e20              LDR      r0,[r4,#0x60]
00001c  2500              MOVS     r5,#0
00001e  2800              CMP      r0,#0
000020  d007              BEQ      |L16.50|
;;;1415     {
;;;1416       /* Set DMA Abort Complete callback if UART DMA Tx request if enabled.
;;;1417          Otherwise, set it to NULL */
;;;1418       if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000022  6821              LDR      r1,[r4,#0]
000024  6889              LDR      r1,[r1,#8]
000026  0609              LSLS     r1,r1,#24
000028  d502              BPL      |L16.48|
;;;1419       {
;;;1420         huart->hdmatx->XferAbortCallback = UART_DMATxAbortCallback;
00002a  4923              LDR      r1,|L16.184|
00002c  6381              STR      r1,[r0,#0x38]
00002e  e000              B        |L16.50|
                  |L16.48|
;;;1421       }
;;;1422       else
;;;1423       {
;;;1424         huart->hdmatx->XferAbortCallback = NULL;
000030  6385              STR      r5,[r0,#0x38]
                  |L16.50|
;;;1425       }
;;;1426     }
;;;1427     /* DMA Rx Handle is valid */
;;;1428     if(huart->hdmarx != NULL)
000032  6e60              LDR      r0,[r4,#0x64]
000034  2800              CMP      r0,#0
000036  d007              BEQ      |L16.72|
;;;1429     {
;;;1430       /* Set DMA Abort Complete callback if UART DMA Rx request if enabled.
;;;1431          Otherwise, set it to NULL */
;;;1432       if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000038  6821              LDR      r1,[r4,#0]
00003a  6889              LDR      r1,[r1,#8]
00003c  0649              LSLS     r1,r1,#25
00003e  d502              BPL      |L16.70|
;;;1433       {
;;;1434         huart->hdmarx->XferAbortCallback = UART_DMARxAbortCallback;
000040  491e              LDR      r1,|L16.188|
000042  6381              STR      r1,[r0,#0x38]
000044  e000              B        |L16.72|
                  |L16.70|
;;;1435       }
;;;1436       else
;;;1437       {
;;;1438         huart->hdmarx->XferAbortCallback = NULL;
000046  6385              STR      r5,[r0,#0x38]
                  |L16.72|
;;;1439       }
;;;1440     }
;;;1441     
;;;1442     /* Disable the UART DMA Tx request if enabled */
;;;1443     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000048  6820              LDR      r0,[r4,#0]
00004a  6881              LDR      r1,[r0,#8]
00004c  0609              LSLS     r1,r1,#24
00004e  d50e              BPL      |L16.110|
;;;1444     {
;;;1445       /* Disable DMA Tx at UART level */
;;;1446       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000050  6881              LDR      r1,[r0,#8]
000052  2280              MOVS     r2,#0x80
000054  4391              BICS     r1,r1,r2
000056  6081              STR      r1,[r0,#8]
;;;1447   
;;;1448       /* Abort the UART DMA Tx channel : use non blocking DMA Abort API (callback) */
;;;1449       if(huart->hdmatx != NULL)
000058  6e20              LDR      r0,[r4,#0x60]
00005a  2800              CMP      r0,#0
00005c  d007              BEQ      |L16.110|
;;;1450       {
;;;1451         /* UART Tx DMA Abort callback has already been initialised : 
;;;1452            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1453   
;;;1454         /* Abort DMA TX */
;;;1455         if(HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
00005e  f7fffffe          BL       HAL_DMA_Abort_IT
000062  2800              CMP      r0,#0
000064  d002              BEQ      |L16.108|
;;;1456         {
;;;1457           huart->hdmatx->XferAbortCallback = NULL;
000066  6e20              LDR      r0,[r4,#0x60]
000068  6385              STR      r5,[r0,#0x38]
00006a  e000              B        |L16.110|
                  |L16.108|
;;;1458         }
;;;1459         else
;;;1460         {
;;;1461           abortcplt = 0U;
00006c  2600              MOVS     r6,#0
                  |L16.110|
;;;1462         }
;;;1463       }
;;;1464     }
;;;1465   
;;;1466     /* Disable the UART DMA Rx request if enabled */
;;;1467     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
00006e  6820              LDR      r0,[r4,#0]
000070  6881              LDR      r1,[r0,#8]
000072  0649              LSLS     r1,r1,#25
000074  d50d              BPL      |L16.146|
;;;1468     {
;;;1469       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000076  6881              LDR      r1,[r0,#8]
000078  2240              MOVS     r2,#0x40
00007a  4391              BICS     r1,r1,r2
00007c  6081              STR      r1,[r0,#8]
;;;1470   
;;;1471       /* Abort the UART DMA Rx channel : use non blocking DMA Abort API (callback) */
;;;1472       if(huart->hdmarx != NULL)
00007e  6e60              LDR      r0,[r4,#0x64]
000080  2800              CMP      r0,#0
000082  d006              BEQ      |L16.146|
;;;1473       {
;;;1474         /* UART Rx DMA Abort callback has already been initialised : 
;;;1475            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1476   
;;;1477         /* Abort DMA RX */
;;;1478         if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
000084  f7fffffe          BL       HAL_DMA_Abort_IT
000088  2800              CMP      r0,#0
00008a  d012              BEQ      |L16.178|
;;;1479         {
;;;1480           huart->hdmarx->XferAbortCallback = NULL;
00008c  6e60              LDR      r0,[r4,#0x64]
;;;1481           abortcplt = 1U;
00008e  6385              STR      r5,[r0,#0x38]
000090  e001              B        |L16.150|
                  |L16.146|
;;;1482         }
;;;1483         else
;;;1484         {
;;;1485           abortcplt = 0U;
;;;1486         }
;;;1487       }
;;;1488     }
;;;1489   
;;;1490     /* if no DMA abort complete callback execution is required => call user Abort Complete callback */
;;;1491     if (abortcplt == 1U)
000092  2e00              CMP      r6,#0
000094  d00d              BEQ      |L16.178|
                  |L16.150|
;;;1492     {
;;;1493       /* Reset Tx and Rx transfer counters */
;;;1494       huart->TxXferCount = 0U; 
000096  4620              MOV      r0,r4
000098  3040              ADDS     r0,r0,#0x40
00009a  8245              STRH     r5,[r0,#0x12]
;;;1495       huart->RxXferCount = 0U;
00009c  8345              STRH     r5,[r0,#0x1a]
;;;1496   
;;;1497       /* Reset errorCode */
;;;1498       huart->ErrorCode = HAL_UART_ERROR_NONE;
00009e  6765              STR      r5,[r4,#0x74]
;;;1499   
;;;1500       /* Clear the Error flags in the ICR register */
;;;1501       __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
0000a0  6821              LDR      r1,[r4,#0]
0000a2  200f              MOVS     r0,#0xf
0000a4  6208              STR      r0,[r1,#0x20]
;;;1502   
;;;1503       /* Restore huart->gState and huart->RxState to Ready */
;;;1504       huart->gState  = HAL_UART_STATE_READY;
0000a6  2020              MOVS     r0,#0x20
0000a8  66e0              STR      r0,[r4,#0x6c]
;;;1505       huart->RxState = HAL_UART_STATE_READY;
0000aa  6720              STR      r0,[r4,#0x70]
;;;1506   
;;;1507       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1508       HAL_UART_AbortCpltCallback(huart);
0000ac  4620              MOV      r0,r4
0000ae  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L16.178|
;;;1509     }
;;;1510   
;;;1511     return HAL_OK;
0000b2  2000              MOVS     r0,#0
;;;1512   }
0000b4  bd70              POP      {r4-r6,pc}
;;;1513   
                          ENDP

0000b6  0000              DCW      0x0000
                  |L16.184|
                          DCD      UART_DMATxAbortCallback
                  |L16.188|
                          DCD      UART_DMARxAbortCallback

                          AREA ||i.HAL_UART_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAPause PROC
;;;1124     */
;;;1125   HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
000000  6e81              LDR      r1,[r0,#0x68]
;;;1126   {
;;;1127     /* Process Locked */
;;;1128     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  d005              BEQ      |L17.18|
000006  2101              MOVS     r1,#1
;;;1129   
;;;1130     if ((huart->gState == HAL_UART_STATE_BUSY_TX) &&
000008  6681              STR      r1,[r0,#0x68]
00000a  6ec1              LDR      r1,[r0,#0x6c]
00000c  2921              CMP      r1,#0x21
00000e  d002              BEQ      |L17.22|
000010  e009              B        |L17.38|
                  |L17.18|
000012  2002              MOVS     r0,#2                 ;1128
;;;1131         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)))
;;;1132     {
;;;1133       /* Disable the UART DMA Tx request */
;;;1134       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1135     }
;;;1136     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) &&
;;;1137         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
;;;1138     {
;;;1139       /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1140       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1141       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1142   
;;;1143       /* Disable the UART DMA Rx request */
;;;1144       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1145     }
;;;1146   
;;;1147     /* Process Unlocked */
;;;1148     __HAL_UNLOCK(huart);
;;;1149   
;;;1150     return HAL_OK;
;;;1151   }
000014  4770              BX       lr
                  |L17.22|
000016  6801              LDR      r1,[r0,#0]            ;1130
000018  688a              LDR      r2,[r1,#8]            ;1130
00001a  0612              LSLS     r2,r2,#24             ;1130
00001c  d503              BPL      |L17.38|
00001e  688a              LDR      r2,[r1,#8]            ;1134
000020  2380              MOVS     r3,#0x80              ;1134
000022  439a              BICS     r2,r2,r3              ;1134
000024  608a              STR      r2,[r1,#8]            ;1134
                  |L17.38|
000026  6f01              LDR      r1,[r0,#0x70]         ;1136
000028  2922              CMP      r1,#0x22              ;1136
00002a  d112              BNE      |L17.82|
00002c  6801              LDR      r1,[r0,#0]            ;1136
00002e  688a              LDR      r2,[r1,#8]            ;1136
000030  0652              LSLS     r2,r2,#25             ;1136
000032  d50e              BPL      |L17.82|
000034  680a              LDR      r2,[r1,#0]            ;1140
000036  23ff              MOVS     r3,#0xff              ;1140
000038  3301              ADDS     r3,#1                 ;1140
00003a  439a              BICS     r2,r2,r3              ;1140
00003c  600a              STR      r2,[r1,#0]            ;1140
00003e  6801              LDR      r1,[r0,#0]            ;1141
000040  688a              LDR      r2,[r1,#8]            ;1141
000042  0852              LSRS     r2,r2,#1              ;1141
000044  0052              LSLS     r2,r2,#1              ;1141
000046  608a              STR      r2,[r1,#8]            ;1141
000048  6801              LDR      r1,[r0,#0]            ;1144
00004a  688a              LDR      r2,[r1,#8]            ;1144
00004c  2340              MOVS     r3,#0x40              ;1144
00004e  439a              BICS     r2,r2,r3              ;1144
000050  608a              STR      r2,[r1,#8]            ;1144
                  |L17.82|
000052  2100              MOVS     r1,#0                 ;1148
000054  6681              STR      r1,[r0,#0x68]         ;1150
000056  4608              MOV      r0,r1                 ;1150
000058  4770              BX       lr
;;;1152   
                          ENDP


                          AREA ||i.HAL_UART_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAResume PROC
;;;1157     */
;;;1158   HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
000000  b410              PUSH     {r4}
;;;1159   {
;;;1160     /* Process Locked */
;;;1161     __HAL_LOCK(huart);
000002  6e81              LDR      r1,[r0,#0x68]
000004  2901              CMP      r1,#1
000006  d005              BEQ      |L18.20|
000008  2101              MOVS     r1,#1
;;;1162   
;;;1163     if(huart->gState == HAL_UART_STATE_BUSY_TX)
00000a  6681              STR      r1,[r0,#0x68]
00000c  6ec2              LDR      r2,[r0,#0x6c]
00000e  2a21              CMP      r2,#0x21
000010  d003              BEQ      |L18.26|
000012  e007              B        |L18.36|
                  |L18.20|
;;;1164     {
;;;1165       /* Enable the UART DMA Tx request */
;;;1166       SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1167     }
;;;1168     if(huart->RxState == HAL_UART_STATE_BUSY_RX)
;;;1169     {
;;;1170       /* Clear the Overrun flag before resuming the Rx transfer */
;;;1171       __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
;;;1172   
;;;1173       /* Reenable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1174       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1175       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1176   
;;;1177       /* Enable the UART DMA Rx request */
;;;1178       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1179     }
;;;1180   
;;;1181     /* Process Unlocked */
;;;1182     __HAL_UNLOCK(huart);
;;;1183   
;;;1184     return HAL_OK;
;;;1185   }
000014  bc10              POP      {r4}
000016  2002              MOVS     r0,#2                 ;1161
000018  4770              BX       lr
                  |L18.26|
00001a  6802              LDR      r2,[r0,#0]            ;1166
00001c  6893              LDR      r3,[r2,#8]            ;1166
00001e  2480              MOVS     r4,#0x80              ;1166
000020  4323              ORRS     r3,r3,r4              ;1166
000022  6093              STR      r3,[r2,#8]            ;1166
                  |L18.36|
000024  6f02              LDR      r2,[r0,#0x70]         ;1168
000026  2a22              CMP      r2,#0x22              ;1168
000028  d111              BNE      |L18.78|
00002a  6803              LDR      r3,[r0,#0]            ;1171
00002c  2208              MOVS     r2,#8                 ;1171
00002e  621a              STR      r2,[r3,#0x20]         ;1171
000030  6802              LDR      r2,[r0,#0]            ;1174
000032  6813              LDR      r3,[r2,#0]            ;1174
000034  24ff              MOVS     r4,#0xff              ;1174
000036  3401              ADDS     r4,#1                 ;1174
000038  4323              ORRS     r3,r3,r4              ;1174
00003a  6013              STR      r3,[r2,#0]            ;1174
00003c  6802              LDR      r2,[r0,#0]            ;1175
00003e  6893              LDR      r3,[r2,#8]            ;1175
000040  430b              ORRS     r3,r3,r1              ;1175
000042  6093              STR      r3,[r2,#8]            ;1175
000044  6801              LDR      r1,[r0,#0]            ;1178
000046  688a              LDR      r2,[r1,#8]            ;1178
000048  2340              MOVS     r3,#0x40              ;1178
00004a  431a              ORRS     r2,r2,r3              ;1178
00004c  608a              STR      r2,[r1,#8]            ;1178
                  |L18.78|
00004e  2100              MOVS     r1,#0                 ;1182
000050  6681              STR      r1,[r0,#0x68]         ;1184
000052  bc10              POP      {r4}
000054  4608              MOV      r0,r1                 ;1184
000056  4770              BX       lr
;;;1186   
                          ENDP


                          AREA ||i.HAL_UART_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAStop PROC
;;;1191     */
;;;1192   HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1193   {
000002  4604              MOV      r4,r0
;;;1194     /* The Lock is not implemented on this API to allow the user application
;;;1195        to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback() /
;;;1196        HAL_UART_TxHalfCpltCallback / HAL_UART_RxHalfCpltCallback: 
;;;1197        indeed, when HAL_DMA_Abort() API is called, the DMA TX/RX Transfer or Half Transfer complete  
;;;1198        interrupt is generated if the DMA transfer interruption occurs at the middle or at the end of 
;;;1199        the stream and the corresponding call back is executed. */
;;;1200   
;;;1201     /* Stop UART DMA Tx request if ongoing */
;;;1202     if ((huart->gState == HAL_UART_STATE_BUSY_TX) &&
000004  6ec0              LDR      r0,[r0,#0x6c]
000006  2520              MOVS     r5,#0x20
000008  2821              CMP      r0,#0x21
00000a  d112              BNE      |L19.50|
;;;1203         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)))
00000c  6820              LDR      r0,[r4,#0]
00000e  6881              LDR      r1,[r0,#8]
000010  0609              LSLS     r1,r1,#24
000012  d50e              BPL      |L19.50|
;;;1204     {
;;;1205       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000014  6881              LDR      r1,[r0,#8]
000016  2280              MOVS     r2,#0x80
000018  4391              BICS     r1,r1,r2
00001a  6081              STR      r1,[r0,#8]
;;;1206   
;;;1207       /* Abort the UART DMA Tx channel */
;;;1208       if(huart->hdmatx != NULL)
00001c  6e20              LDR      r0,[r4,#0x60]
00001e  2800              CMP      r0,#0
000020  d001              BEQ      |L19.38|
;;;1209       {
;;;1210         HAL_DMA_Abort(huart->hdmatx);
000022  f7fffffe          BL       HAL_DMA_Abort
                  |L19.38|
000026  6820              LDR      r0,[r4,#0]
000028  6801              LDR      r1,[r0,#0]
00002a  22c0              MOVS     r2,#0xc0
00002c  4391              BICS     r1,r1,r2
00002e  6001              STR      r1,[r0,#0]
000030  66e5              STR      r5,[r4,#0x6c]
                  |L19.50|
;;;1211       }
;;;1212   
;;;1213       UART_EndTxTransfer(huart);
;;;1214     }
;;;1215   
;;;1216     /* Stop UART DMA Rx request if ongoing */
;;;1217     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) &&
000032  6f20              LDR      r0,[r4,#0x70]
000034  2822              CMP      r0,#0x22
000036  d118              BNE      |L19.106|
;;;1218         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
000038  6820              LDR      r0,[r4,#0]
00003a  6881              LDR      r1,[r0,#8]
00003c  0649              LSLS     r1,r1,#25
00003e  d514              BPL      |L19.106|
;;;1219     {
;;;1220       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000040  6881              LDR      r1,[r0,#8]
000042  2240              MOVS     r2,#0x40
000044  4391              BICS     r1,r1,r2
000046  6081              STR      r1,[r0,#8]
;;;1221   
;;;1222       /* Abort the UART DMA Rx channel */
;;;1223       if(huart->hdmarx != NULL)
000048  6e60              LDR      r0,[r4,#0x64]
00004a  2800              CMP      r0,#0
00004c  d001              BEQ      |L19.82|
;;;1224       {
;;;1225         HAL_DMA_Abort(huart->hdmarx);
00004e  f7fffffe          BL       HAL_DMA_Abort
                  |L19.82|
000052  6820              LDR      r0,[r4,#0]
000054  6801              LDR      r1,[r0,#0]
000056  22ff              MOVS     r2,#0xff
000058  3221              ADDS     r2,r2,#0x21
00005a  4391              BICS     r1,r1,r2
00005c  6001              STR      r1,[r0,#0]
00005e  6820              LDR      r0,[r4,#0]
000060  6881              LDR      r1,[r0,#8]
000062  0849              LSRS     r1,r1,#1
000064  0049              LSLS     r1,r1,#1
000066  6081              STR      r1,[r0,#8]
000068  6725              STR      r5,[r4,#0x70]
                  |L19.106|
;;;1226       }
;;;1227   
;;;1228       UART_EndRxTransfer(huart);
;;;1229     }
;;;1230   
;;;1231     return HAL_OK;
00006a  2000              MOVS     r0,#0
;;;1232   }
00006c  bd70              POP      {r4-r6,pc}
;;;1233   
                          ENDP


                          AREA ||i.HAL_UART_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_DeInit PROC
;;;534      */
;;;535    HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
000000  2800              CMP      r0,#0
;;;536    {
;;;537      /* Check the UART handle allocation */
;;;538      if(huart == NULL)
000002  d101              BNE      |L20.8|
;;;539      {
;;;540        return HAL_ERROR;
000004  2001              MOVS     r0,#1
;;;541      }
;;;542    
;;;543      /* Check the parameters */
;;;544      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;545    
;;;546      huart->gState = HAL_UART_STATE_BUSY;
;;;547    
;;;548      /* Disable the Peripheral */
;;;549      __HAL_UART_DISABLE(huart);
;;;550    
;;;551      huart->Instance->CR1 = 0x0U;
;;;552      huart->Instance->CR2 = 0x0U;
;;;553      huart->Instance->CR3 = 0x0U;
;;;554    
;;;555      /* DeInit the low level hardware */
;;;556      HAL_UART_MspDeInit(huart);
;;;557    
;;;558      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;559      huart->gState    = HAL_UART_STATE_RESET;
;;;560      huart->RxState   = HAL_UART_STATE_RESET;
;;;561    
;;;562      /* Process Unlock */
;;;563      __HAL_UNLOCK(huart);
;;;564    
;;;565      return HAL_OK;
;;;566    }
000006  4770              BX       lr
                  |L20.8|
000008  b570              PUSH     {r4-r6,lr}            ;536
00000a  4604              MOV      r4,r0                 ;536
00000c  2024              MOVS     r0,#0x24              ;546
00000e  66e0              STR      r0,[r4,#0x6c]         ;546
000010  6820              LDR      r0,[r4,#0]            ;549
000012  6801              LDR      r1,[r0,#0]            ;549
000014  0849              LSRS     r1,r1,#1              ;549
000016  0049              LSLS     r1,r1,#1              ;549
000018  6001              STR      r1,[r0,#0]            ;549
00001a  6820              LDR      r0,[r4,#0]            ;551
00001c  2500              MOVS     r5,#0                 ;551
00001e  6005              STR      r5,[r0,#0]            ;551
000020  6820              LDR      r0,[r4,#0]            ;552
000022  6045              STR      r5,[r0,#4]            ;552
000024  6820              LDR      r0,[r4,#0]            ;553
000026  6085              STR      r5,[r0,#8]            ;553
000028  4620              MOV      r0,r4                 ;556
00002a  f7fffffe          BL       HAL_UART_MspDeInit
00002e  6765              STR      r5,[r4,#0x74]         ;558
000030  66e5              STR      r5,[r4,#0x6c]         ;559
000032  6725              STR      r5,[r4,#0x70]         ;560
000034  2000              MOVS     r0,#0                 ;565
000036  66a5              STR      r5,[r4,#0x68]         ;565
000038  bd70              POP      {r4-r6,pc}
;;;567    
                          ENDP


                          AREA ||i.HAL_UART_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_ErrorCallback PROC
;;;1869     */
;;;1870   __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1871   {
;;;1872     /* Prevent unused argument(s) compilation warning */
;;;1873     UNUSED(huart);
;;;1874   
;;;1875     /* NOTE : This function should not be modified, when the callback is needed,
;;;1876               the HAL_UART_ErrorCallback can be implemented in the user file.
;;;1877      */
;;;1878   }
;;;1879   
                          ENDP


                          AREA ||i.HAL_UART_GetError||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetError PROC
;;;2087     */
;;;2088   uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
000000  6f40              LDR      r0,[r0,#0x74]
;;;2089   {
;;;2090     return huart->ErrorCode;
;;;2091   }
000002  4770              BX       lr
;;;2092   /**
                          ENDP


                          AREA ||i.HAL_UART_GetState||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetState PROC
;;;2072     */
;;;2073   HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2074   {
;;;2075     uint32_t temp1= 0x00U, temp2 = 0x00U;
;;;2076     temp1 = huart->gState;
000002  6ec0              LDR      r0,[r0,#0x6c]
;;;2077     temp2 = huart->RxState;
000004  6f09              LDR      r1,[r1,#0x70]
;;;2078   
;;;2079     return (HAL_UART_StateTypeDef)(temp1 | temp2);
000006  4308              ORRS     r0,r0,r1
;;;2080   }
000008  4770              BX       lr
;;;2081   
                          ENDP


                          AREA ||i.HAL_UART_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_UART_IRQHandler PROC
;;;1655     */
;;;1656   void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1657   {
;;;1658     uint32_t isrflags   = READ_REG(huart->Instance->ISR);
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0                 ;1657
000006  69d1              LDR      r1,[r2,#0x1c]
;;;1659     uint32_t cr1its     = READ_REG(huart->Instance->CR1);
000008  6810              LDR      r0,[r2,#0]
;;;1660     uint32_t cr3its;
;;;1661     uint32_t errorflags;
;;;1662   
;;;1663     /* If no error occurs */
;;;1664     errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE));
00000a  070b              LSLS     r3,r1,#28
00000c  0f1b              LSRS     r3,r3,#28
00000e  d066              BEQ      |L24.222|
;;;1665     if (errorflags == RESET)
;;;1666     {
;;;1667       /* UART in mode Receiver ---------------------------------------------------*/
;;;1668       if(((isrflags & USART_ISR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
;;;1669       {
;;;1670         UART_Receive_IT(huart);
;;;1671         return;
;;;1672       }
;;;1673     }  
;;;1674   
;;;1675     /* If some errors occur */
;;;1676     cr3its = READ_REG(huart->Instance->CR3);
000010  6893              LDR      r3,[r2,#8]
;;;1677     if(   (errorflags != RESET)
;;;1678        && (   ((cr3its & USART_CR3_EIE) != RESET)
000012  26ff              MOVS     r6,#0xff
000014  07dd              LSLS     r5,r3,#31
000016  0fed              LSRS     r5,r5,#31
000018  3621              ADDS     r6,r6,#0x21
00001a  4006              ANDS     r6,r6,r0
00001c  432e              ORRS     r6,r6,r5
00001e  d067              BEQ      |L24.240|
;;;1679            || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)) )
;;;1680     {
;;;1681       /* UART parity error interrupt occurred -------------------------------------*/
;;;1682       if(((isrflags & USART_ISR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
000020  07ce              LSLS     r6,r1,#31
000022  d006              BEQ      |L24.50|
000024  05c6              LSLS     r6,r0,#23
000026  d504              BPL      |L24.50|
;;;1683       {
;;;1684         __HAL_UART_CLEAR_IT(huart, UART_CLEAR_PEF);
000028  2601              MOVS     r6,#1
00002a  6216              STR      r6,[r2,#0x20]
;;;1685   
;;;1686         huart->ErrorCode |= HAL_UART_ERROR_PE;
00002c  6f62              LDR      r2,[r4,#0x74]
00002e  4332              ORRS     r2,r2,r6
000030  6762              STR      r2,[r4,#0x74]
                  |L24.50|
;;;1687       }
;;;1688   
;;;1689       /* UART frame error interrupt occurred --------------------------------------*/
;;;1690       if(((isrflags & USART_ISR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
000032  078e              LSLS     r6,r1,#30
;;;1691       {
;;;1692         __HAL_UART_CLEAR_IT(huart, UART_CLEAR_FEF);
;;;1693   
;;;1694         huart->ErrorCode |= HAL_UART_ERROR_FE;
000034  2204              MOVS     r2,#4
000036  2e00              CMP      r6,#0                 ;1690
000038  da07              BGE      |L24.74|
00003a  07de              LSLS     r6,r3,#31             ;1690
00003c  d005              BEQ      |L24.74|
00003e  6827              LDR      r7,[r4,#0]            ;1692
000040  2602              MOVS     r6,#2                 ;1692
000042  623e              STR      r6,[r7,#0x20]         ;1692
000044  6f66              LDR      r6,[r4,#0x74]
000046  4316              ORRS     r6,r6,r2
000048  6766              STR      r6,[r4,#0x74]
                  |L24.74|
;;;1695       }
;;;1696   
;;;1697       /* UART noise error interrupt occurred --------------------------------------*/
;;;1698       if(((isrflags & USART_ISR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
00004a  074e              LSLS     r6,r1,#29
00004c  d507              BPL      |L24.94|
00004e  07db              LSLS     r3,r3,#31
000050  d005              BEQ      |L24.94|
;;;1699       {
;;;1700         __HAL_UART_CLEAR_IT(huart, UART_CLEAR_NEF);
000052  6823              LDR      r3,[r4,#0]
000054  621a              STR      r2,[r3,#0x20]
;;;1701   
;;;1702         huart->ErrorCode |= HAL_UART_ERROR_NE;
000056  6f62              LDR      r2,[r4,#0x74]
000058  2302              MOVS     r3,#2
00005a  431a              ORRS     r2,r2,r3
00005c  6762              STR      r2,[r4,#0x74]
                  |L24.94|
;;;1703       }
;;;1704       
;;;1705       /* UART Over-Run interrupt occurred -----------------------------------------*/
;;;1706       if(((isrflags & USART_ISR_ORE) != RESET) &&
00005e  070a              LSLS     r2,r1,#28
000060  d509              BPL      |L24.118|
;;;1707          (((cr1its & USART_CR1_RXNEIE) != RESET) || ((cr3its & USART_CR3_EIE) != RESET)))
000062  2220              MOVS     r2,#0x20
000064  4002              ANDS     r2,r2,r0
000066  432a              ORRS     r2,r2,r5
000068  d005              BEQ      |L24.118|
;;;1708       {
;;;1709         __HAL_UART_CLEAR_IT(huart, UART_CLEAR_OREF);
00006a  6823              LDR      r3,[r4,#0]
00006c  2208              MOVS     r2,#8
00006e  621a              STR      r2,[r3,#0x20]
;;;1710   
;;;1711         huart->ErrorCode |= HAL_UART_ERROR_ORE;
000070  6f63              LDR      r3,[r4,#0x74]
000072  4313              ORRS     r3,r3,r2
000074  6763              STR      r3,[r4,#0x74]
                  |L24.118|
;;;1712       }
;;;1713   
;;;1714       /* Call UART Error Call back function if need be --------------------------*/
;;;1715       if(huart->ErrorCode != HAL_UART_ERROR_NONE)
000076  6f62              LDR      r2,[r4,#0x74]
000078  2a00              CMP      r2,#0
00007a  d02f              BEQ      |L24.220|
;;;1716       {
;;;1717         /* UART in mode Receiver ---------------------------------------------------*/
;;;1718         if(((isrflags & USART_ISR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
00007c  0689              LSLS     r1,r1,#26
00007e  d504              BPL      |L24.138|
000080  0680              LSLS     r0,r0,#26
000082  d502              BPL      |L24.138|
;;;1719         {
;;;1720           UART_Receive_IT(huart);
000084  4620              MOV      r0,r4
000086  f7fffffe          BL       UART_Receive_IT
                  |L24.138|
;;;1721         }
;;;1722   
;;;1723         /* If Overrun error occurs, or if any error occurs in DMA mode reception,
;;;1724            consider error as blocking */
;;;1725         if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) ||
00008a  6f60              LDR      r0,[r4,#0x74]
00008c  0700              LSLS     r0,r0,#28
00008e  d403              BMI      |L24.152|
;;;1726             (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
000090  6820              LDR      r0,[r4,#0]
000092  6880              LDR      r0,[r0,#8]
000094  0640              LSLS     r0,r0,#25
000096  d54d              BPL      |L24.308|
                  |L24.152|
000098  6820              LDR      r0,[r4,#0]
00009a  6802              LDR      r2,[r0,#0]
00009c  21ff              MOVS     r1,#0xff
00009e  3121              ADDS     r1,r1,#0x21
0000a0  438a              BICS     r2,r2,r1
0000a2  6002              STR      r2,[r0,#0]
0000a4  6820              LDR      r0,[r4,#0]
0000a6  6881              LDR      r1,[r0,#8]
0000a8  0849              LSRS     r1,r1,#1
0000aa  0049              LSLS     r1,r1,#1
0000ac  6081              STR      r1,[r0,#8]
0000ae  2020              MOVS     r0,#0x20
0000b0  6720              STR      r0,[r4,#0x70]
;;;1727         {  
;;;1728           /* Blocking error : transfer is aborted
;;;1729              Set the UART state ready to be able to start again the process,
;;;1730              Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
;;;1731           UART_EndRxTransfer(huart);
;;;1732   
;;;1733           /* Disable the UART DMA Rx request if enabled */
;;;1734           if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
0000b2  6820              LDR      r0,[r4,#0]
0000b4  6881              LDR      r1,[r0,#8]
0000b6  0649              LSLS     r1,r1,#25
0000b8  d538              BPL      |L24.300|
;;;1735           {
;;;1736             CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
0000ba  6882              LDR      r2,[r0,#8]
0000bc  2140              MOVS     r1,#0x40
0000be  438a              BICS     r2,r2,r1
0000c0  6082              STR      r2,[r0,#8]
;;;1737   
;;;1738             /* Abort the UART DMA Rx channel */
;;;1739             if(huart->hdmarx != NULL)
0000c2  6e60              LDR      r0,[r4,#0x64]
0000c4  2800              CMP      r0,#0
0000c6  d031              BEQ      |L24.300|
;;;1740             {
;;;1741               /* Set the UART DMA Abort callback : 
;;;1742                  will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
;;;1743               huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
0000c8  492e              LDR      r1,|L24.388|
;;;1744   
;;;1745               /* Abort DMA RX */
;;;1746               if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
0000ca  6381              STR      r1,[r0,#0x38]
0000cc  6e60              LDR      r0,[r4,#0x64]
0000ce  f7fffffe          BL       HAL_DMA_Abort_IT
0000d2  2800              CMP      r0,#0
0000d4  d002              BEQ      |L24.220|
;;;1747               {
;;;1748                 /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
;;;1749                 huart->hdmarx->XferAbortCallback(huart->hdmarx);
0000d6  6e60              LDR      r0,[r4,#0x64]
0000d8  6b81              LDR      r1,[r0,#0x38]
0000da  4788              BLX      r1
                  |L24.220|
;;;1750               }
;;;1751             }
;;;1752             else
;;;1753             {
;;;1754               /* Call user error callback */
;;;1755               HAL_UART_ErrorCallback(huart);
;;;1756             }
;;;1757           }
;;;1758           else
;;;1759           {
;;;1760             /* Call user error callback */
;;;1761             HAL_UART_ErrorCallback(huart);
;;;1762           }
;;;1763         }
;;;1764         else
;;;1765         {
;;;1766           /* Non Blocking error : transfer could go on. 
;;;1767              Error is notified to user through user error callback */
;;;1768           HAL_UART_ErrorCallback(huart);
;;;1769           huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1770         }
;;;1771       }
;;;1772       return;
;;;1773   
;;;1774     } /* End if some error occurs */
;;;1775   
;;;1776   #if !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F070x6)&& !defined(STM32F030xC)
;;;1777     /* UART wakeup from Stop mode interrupt occurred ---------------------------*/
;;;1778     if(((isrflags & USART_ISR_WUF) != RESET) && ((cr3its & USART_CR3_WUFIE) != RESET))
;;;1779     {
;;;1780       __HAL_UART_CLEAR_IT(huart, UART_CLEAR_WUF);
;;;1781       /* Set the UART state ready to be able to start again the process */
;;;1782       huart->gState  = HAL_UART_STATE_READY;
;;;1783       huart->RxState = HAL_UART_STATE_READY;
;;;1784       HAL_UARTEx_WakeupCallback(huart);
;;;1785       return;
;;;1786     }
;;;1787   #endif /* !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F070x6)&& !defined(STM32F030xC) */
;;;1788   
;;;1789     /* UART in mode Transmitter ------------------------------------------------*/
;;;1790     if(((isrflags & USART_ISR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
;;;1791     {
;;;1792       UART_Transmit_IT(huart);
;;;1793       return;
;;;1794     }
;;;1795   
;;;1796     /* UART in mode Transmitter (transmission end) -----------------------------*/
;;;1797     if(((isrflags & USART_ISR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
;;;1798     {
;;;1799       UART_EndTransmit_IT(huart);
;;;1800       return;
;;;1801     }
;;;1802   
;;;1803   }
0000dc  bdf8              POP      {r3-r7,pc}
                  |L24.222|
0000de  068b              LSLS     r3,r1,#26             ;1668
0000e0  d505              BPL      |L24.238|
0000e2  0683              LSLS     r3,r0,#26             ;1668
0000e4  d503              BPL      |L24.238|
0000e6  4620              MOV      r0,r4                 ;1670
0000e8  f7fffffe          BL       UART_Receive_IT
                  |L24.236|
0000ec  bdf8              POP      {r3-r7,pc}
                  |L24.238|
0000ee  6893              LDR      r3,[r2,#8]            ;1676
                  |L24.240|
0000f0  060b              LSLS     r3,r1,#24             ;1790
0000f2  d538              BPL      |L24.358|
0000f4  0603              LSLS     r3,r0,#24             ;1790
0000f6  d536              BPL      |L24.358|
0000f8  6ee0              LDR      r0,[r4,#0x6c]         ;1790
0000fa  2821              CMP      r0,#0x21              ;1790
0000fc  d1f6              BNE      |L24.236|
0000fe  4620              MOV      r0,r4                 ;1790
000100  3040              ADDS     r0,r0,#0x40           ;1790
000102  8a41              LDRH     r1,[r0,#0x12]         ;1790
000104  2900              CMP      r1,#0                 ;1790
000106  d01b              BEQ      |L24.320|
000108  2301              MOVS     r3,#1                 ;1790
00010a  68a1              LDR      r1,[r4,#8]            ;1790
00010c  031b              LSLS     r3,r3,#12             ;1790
00010e  4299              CMP      r1,r3                 ;1790
000110  d102              BNE      |L24.280|
000112  6921              LDR      r1,[r4,#0x10]         ;1790
000114  2900              CMP      r1,#0                 ;1790
000116  d01d              BEQ      |L24.340|
                  |L24.280|
000118  6ce1              LDR      r1,[r4,#0x4c]         ;1790
00011a  1c4a              ADDS     r2,r1,#1              ;1790
00011c  64e2              STR      r2,[r4,#0x4c]         ;1790
00011e  6822              LDR      r2,[r4,#0]            ;1790
000120  7809              LDRB     r1,[r1,#0]            ;1790
000122  8511              STRH     r1,[r2,#0x28]         ;1790
                  |L24.292|
000124  8a41              LDRH     r1,[r0,#0x12]         ;1790
000126  1e49              SUBS     r1,r1,#1              ;1790
000128  8241              STRH     r1,[r0,#0x12]         ;1790
00012a  bdf8              POP      {r3-r7,pc}
                  |L24.300|
00012c  4620              MOV      r0,r4                 ;1761
00012e  f7fffffe          BL       HAL_UART_ErrorCallback
000132  bdf8              POP      {r3-r7,pc}
                  |L24.308|
000134  4620              MOV      r0,r4                 ;1768
000136  f7fffffe          BL       HAL_UART_ErrorCallback
00013a  2000              MOVS     r0,#0                 ;1769
00013c  6760              STR      r0,[r4,#0x74]         ;1769
00013e  bdf8              POP      {r3-r7,pc}
                  |L24.320|
000140  6810              LDR      r0,[r2,#0]
000142  2180              MOVS     r1,#0x80
000144  4388              BICS     r0,r0,r1
000146  6010              STR      r0,[r2,#0]
000148  6820              LDR      r0,[r4,#0]
00014a  6801              LDR      r1,[r0,#0]
00014c  2240              MOVS     r2,#0x40
00014e  4311              ORRS     r1,r1,r2
000150  6001              STR      r1,[r0,#0]
                  |L24.338|
000152  bdf8              POP      {r3-r7,pc}
                  |L24.340|
000154  6ce1              LDR      r1,[r4,#0x4c]
000156  8809              LDRH     r1,[r1,#0]
000158  05c9              LSLS     r1,r1,#23
00015a  0dc9              LSRS     r1,r1,#23
00015c  8511              STRH     r1,[r2,#0x28]
00015e  6ce1              LDR      r1,[r4,#0x4c]
000160  1c89              ADDS     r1,r1,#2
000162  64e1              STR      r1,[r4,#0x4c]
000164  e7de              B        |L24.292|
                  |L24.358|
000166  0649              LSLS     r1,r1,#25             ;1797
000168  d5f3              BPL      |L24.338|
00016a  0640              LSLS     r0,r0,#25             ;1797
00016c  d5f1              BPL      |L24.338|
00016e  6813              LDR      r3,[r2,#0]            ;1797
000170  4620              MOV      r0,r4                 ;1799
000172  2140              MOVS     r1,#0x40              ;1799
000174  438b              BICS     r3,r3,r1              ;1799
000176  6013              STR      r3,[r2,#0]            ;1799
000178  2120              MOVS     r1,#0x20              ;1799
00017a  66e1              STR      r1,[r4,#0x6c]         ;1799
00017c  f7fffffe          BL       HAL_UART_TxCpltCallback
000180  bdf8              POP      {r3-r7,pc}
;;;1804   
                          ENDP

000182  0000              DCW      0x0000
                  |L24.388|
                          DCD      UART_DMAAbortOnError

                          AREA ||i.HAL_UART_Init||, CODE, READONLY, ALIGN=1

                  HAL_UART_Init PROC
;;;290      */
;;;291    HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
000000  2800              CMP      r0,#0
;;;292    {
;;;293      /* Check the UART handle allocation */
;;;294      if(huart == NULL)
000002  d101              BNE      |L25.8|
;;;295      {
;;;296        return HAL_ERROR;
000004  2001              MOVS     r0,#1
;;;297      }
;;;298    
;;;299      if(huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
;;;300      {
;;;301        /* Check the parameters */
;;;302        assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
;;;303      }
;;;304      else
;;;305      {
;;;306        /* Check the parameters */
;;;307        assert_param(IS_UART_INSTANCE(huart->Instance));
;;;308      }
;;;309    
;;;310      if(huart->gState == HAL_UART_STATE_RESET)
;;;311      {
;;;312        /* Allocate lock resource and initialize it */
;;;313        huart->Lock = HAL_UNLOCKED;
;;;314    
;;;315        /* Init the low level hardware : GPIO, CLOCK */
;;;316        HAL_UART_MspInit(huart);
;;;317      }
;;;318    
;;;319      huart->gState = HAL_UART_STATE_BUSY;
;;;320    
;;;321      /* Disable the Peripheral */
;;;322      __HAL_UART_DISABLE(huart);
;;;323    
;;;324      /* Set the UART Communication parameters */
;;;325      if (UART_SetConfig(huart) == HAL_ERROR)
;;;326      {
;;;327        return HAL_ERROR;
;;;328      }
;;;329    
;;;330      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;331      {
;;;332        UART_AdvFeatureConfig(huart);
;;;333      }
;;;334    
;;;335      /* In asynchronous mode, the following bits must be kept cleared:
;;;336      - LINEN (if LIN is supported) and CLKEN bits in the USART_CR2 register,
;;;337      - SCEN (if Smartcard is supported), HDSEL and IREN (if IrDA is supported)  bits in the USART_CR3 register. */
;;;338    #if defined (USART_CR2_LINEN)
;;;339      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;340    #else
;;;341      CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
;;;342    #endif
;;;343    #if defined (USART_CR3_SCEN)
;;;344    #if defined (USART_CR3_IREN)
;;;345      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;346    #else
;;;347      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL));
;;;348    #endif
;;;349    #else
;;;350    #if defined (USART_CR3_IREN)
;;;351      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN));
;;;352    #else
;;;353      CLEAR_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
;;;354    #endif
;;;355    #endif
;;;356    
;;;357      /* Enable the Peripheral */
;;;358      __HAL_UART_ENABLE(huart);
;;;359    
;;;360      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;361      return (UART_CheckIdleState(huart));
;;;362    }
000006  4770              BX       lr
                  |L25.8|
000008  b570              PUSH     {r4-r6,lr}            ;292
00000a  4604              MOV      r4,r0                 ;292
00000c  6ec0              LDR      r0,[r0,#0x6c]         ;310
00000e  2500              MOVS     r5,#0                 ;310
000010  2800              CMP      r0,#0                 ;310
000012  d103              BNE      |L25.28|
000014  4620              MOV      r0,r4                 ;316
000016  66a5              STR      r5,[r4,#0x68]         ;316
000018  f7fffffe          BL       HAL_UART_MspInit
                  |L25.28|
00001c  2024              MOVS     r0,#0x24              ;319
00001e  66e0              STR      r0,[r4,#0x6c]         ;319
000020  6820              LDR      r0,[r4,#0]            ;322
000022  6801              LDR      r1,[r0,#0]            ;322
000024  0849              LSRS     r1,r1,#1              ;322
000026  0049              LSLS     r1,r1,#1              ;322
000028  6001              STR      r1,[r0,#0]            ;322
00002a  4620              MOV      r0,r4                 ;325
00002c  f7fffffe          BL       UART_SetConfig
000030  2801              CMP      r0,#1                 ;325
000032  d01b              BEQ      |L25.108|
000034  6a60              LDR      r0,[r4,#0x24]         ;330
000036  2800              CMP      r0,#0                 ;330
000038  d002              BEQ      |L25.64|
00003a  4620              MOV      r0,r4                 ;332
00003c  f7fffffe          BL       UART_AdvFeatureConfig
                  |L25.64|
000040  6820              LDR      r0,[r4,#0]            ;341
000042  6841              LDR      r1,[r0,#4]            ;341
000044  2201              MOVS     r2,#1                 ;341
000046  02d2              LSLS     r2,r2,#11             ;341
000048  4391              BICS     r1,r1,r2              ;341
00004a  6041              STR      r1,[r0,#4]            ;341
00004c  6820              LDR      r0,[r4,#0]            ;353
00004e  6881              LDR      r1,[r0,#8]            ;353
000050  2208              MOVS     r2,#8                 ;353
000052  4391              BICS     r1,r1,r2              ;353
000054  6081              STR      r1,[r0,#8]            ;353
000056  6820              LDR      r0,[r4,#0]            ;358
000058  6801              LDR      r1,[r0,#0]            ;358
00005a  2201              MOVS     r2,#1                 ;358
00005c  4311              ORRS     r1,r1,r2              ;358
00005e  6001              STR      r1,[r0,#0]            ;358
000060  4628              MOV      r0,r5                 ;358
000062  6765              STR      r5,[r4,#0x74]         ;358
000064  2120              MOVS     r1,#0x20              ;358
000066  66e1              STR      r1,[r4,#0x6c]         ;358
000068  6721              STR      r1,[r4,#0x70]         ;358
00006a  66a5              STR      r5,[r4,#0x68]         ;358
                  |L25.108|
00006c  bd70              POP      {r4-r6,pc}
;;;363    
                          ENDP


                          AREA ||i.HAL_UART_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspDeInit PROC
;;;587      */
;;;588    __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;589    {
;;;590      /* Prevent unused argument(s) compilation warning */
;;;591      UNUSED(huart);
;;;592    
;;;593      /* NOTE : This function should not be modified, when the callback is needed,
;;;594                the HAL_UART_MspDeInit can be implemented in the user file
;;;595       */
;;;596    }
;;;597    
                          ENDP


                          AREA ||i.HAL_UART_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspInit PROC
;;;572      */
;;;573    __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;574    {
;;;575      /* Prevent unused argument(s) compilation warning */
;;;576      UNUSED(huart);
;;;577    
;;;578      /* NOTE : This function should not be modified, when the callback is needed,
;;;579                the HAL_UART_MspInit can be implemented in the user file
;;;580       */
;;;581    }
;;;582    
                          ENDP


                          AREA ||i.HAL_UART_Receive||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive PROC
;;;774      */
;;;775    HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  b5ff              PUSH     {r0-r7,lr}
;;;776    {
000002  4604              MOV      r4,r0
;;;777      uint16_t* tmp;
;;;778      uint16_t uhMask;
;;;779      uint32_t tickstart = 0;
;;;780    
;;;781      /* Check that a Rx process is not already ongoing */
;;;782      if(huart->RxState == HAL_UART_STATE_READY)
000004  6f00              LDR      r0,[r0,#0x70]
000006  b085              SUB      sp,sp,#0x14           ;776
000008  461e              MOV      r6,r3                 ;776
00000a  4617              MOV      r7,r2                 ;776
00000c  2820              CMP      r0,#0x20
00000e  d17d              BNE      |L28.268|
;;;783      {
;;;784        if((pData == NULL ) || (Size == 0U))
000010  9806              LDR      r0,[sp,#0x18]
000012  2800              CMP      r0,#0
000014  d00c              BEQ      |L28.48|
000016  2f00              CMP      r7,#0
000018  d00a              BEQ      |L28.48|
;;;785        {
;;;786          return  HAL_ERROR;
;;;787        }
;;;788    
;;;789        /* In case of 9bits/No Parity transfer, pData buffer provided as input paramter 
;;;790           should be aligned on a u16 frontier, as data to be received from RDR will be 
;;;791           handled through a u16 cast. */
;;;792        if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
00001a  2001              MOVS     r0,#1
00001c  68a1              LDR      r1,[r4,#8]
00001e  0300              LSLS     r0,r0,#12
000020  4281              CMP      r1,r0
000022  d108              BNE      |L28.54|
000024  6920              LDR      r0,[r4,#0x10]
000026  2800              CMP      r0,#0
000028  d105              BNE      |L28.54|
;;;793        {
;;;794          if((((uint32_t)pData)&1U) != 0U)
00002a  9806              LDR      r0,[sp,#0x18]
00002c  07c0              LSLS     r0,r0,#31
00002e  d002              BEQ      |L28.54|
                  |L28.48|
;;;795          {
;;;796            return  HAL_ERROR;
000030  2001              MOVS     r0,#1
;;;797          }
;;;798        }
;;;799    
;;;800        /* Process Locked */
;;;801        __HAL_LOCK(huart);
;;;802    
;;;803        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;804        huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;805    
;;;806        /* Init tickstart for timeout managment*/
;;;807        tickstart = HAL_GetTick();
;;;808    
;;;809        huart->RxXferSize = Size;
;;;810        huart->RxXferCount = Size;
;;;811    
;;;812        /* Computation of UART mask to apply to RDR register */
;;;813        UART_MASK_COMPUTATION(huart);
;;;814        uhMask = huart->Mask;
;;;815    
;;;816        /* as long as data have to be received */
;;;817        while(huart->RxXferCount > 0U)
;;;818        {
;;;819          huart->RxXferCount--;
;;;820          if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;821          {
;;;822            return HAL_TIMEOUT;
;;;823          }
;;;824          if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;825          {
;;;826            tmp = (uint16_t*) pData ;
;;;827            *tmp = (uint16_t)(huart->Instance->RDR & uhMask);
;;;828            pData +=2U;
;;;829          }
;;;830          else
;;;831          {
;;;832            *pData++ = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
;;;833          }
;;;834        }
;;;835    
;;;836        /* At end of Rx process, restore huart->RxState to Ready */
;;;837        huart->RxState = HAL_UART_STATE_READY;
;;;838    
;;;839        /* Process Unlocked */
;;;840        __HAL_UNLOCK(huart);
;;;841    
;;;842        return HAL_OK;
;;;843      }
;;;844      else
;;;845      {
;;;846        return HAL_BUSY;
;;;847      }
;;;848    }
000032  b009              ADD      sp,sp,#0x24
000034  bdf0              POP      {r4-r7,pc}
                  |L28.54|
000036  6ea0              LDR      r0,[r4,#0x68]         ;801
000038  2801              CMP      r0,#1                 ;801
00003a  d078              BEQ      |L28.302|
00003c  2001              MOVS     r0,#1                 ;801
00003e  66a0              STR      r0,[r4,#0x68]         ;803
000040  2000              MOVS     r0,#0                 ;803
000042  6760              STR      r0,[r4,#0x74]         ;803
000044  2022              MOVS     r0,#0x22              ;804
000046  6720              STR      r0,[r4,#0x70]         ;804
000048  f7fffffe          BL       HAL_GetTick
00004c  4625              MOV      r5,r4                 ;809
00004e  3540              ADDS     r5,r5,#0x40           ;809
000050  9003              STR      r0,[sp,#0xc]          ;809
000052  832f              STRH     r7,[r5,#0x18]         ;809
000054  836f              STRH     r7,[r5,#0x1a]         ;810
000056  2001              MOVS     r0,#1                 ;813
000058  68a2              LDR      r2,[r4,#8]            ;813
00005a  0300              LSLS     r0,r0,#12             ;813
00005c  21ff              MOVS     r1,#0xff              ;813
00005e  4282              CMP      r2,r0                 ;813
000060  d104              BNE      |L28.108|
000062  6922              LDR      r2,[r4,#0x10]         ;813
000064  2a00              CMP      r2,#0                 ;813
000066  d107              BNE      |L28.120|
000068  4932              LDR      r1,|L28.308|
00006a  e005              B        |L28.120|
                  |L28.108|
00006c  2a00              CMP      r2,#0                 ;813
00006e  d104              BNE      |L28.122|
000070  6922              LDR      r2,[r4,#0x10]         ;813
000072  2a00              CMP      r2,#0                 ;813
000074  d000              BEQ      |L28.120|
000076  217f              MOVS     r1,#0x7f              ;813
                  |L28.120|
000078  83a9              STRH     r1,[r5,#0x1c]         ;813
                  |L28.122|
00007a  8ba9              LDRH     r1,[r5,#0x1c]         ;814
00007c  9100              STR      r1,[sp,#0]            ;817
00007e  8b69              LDRH     r1,[r5,#0x1a]         ;817
000080  2900              CMP      r1,#0                 ;817
000082  d045              BEQ      |L28.272|
000084  9800              LDR      r0,[sp,#0]            ;832
000086  b2c0              UXTB     r0,r0                 ;832
000088  9002              STR      r0,[sp,#8]            ;832
                  |L28.138|
00008a  8b68              LDRH     r0,[r5,#0x1a]         ;819
00008c  1e40              SUBS     r0,r0,#1              ;819
00008e  8368              STRH     r0,[r5,#0x1a]         ;819
000090  9803              LDR      r0,[sp,#0xc]          ;820
000092  9001              STR      r0,[sp,#4]            ;820
000094  6820              LDR      r0,[r4,#0]            ;820
000096  2720              MOVS     r7,#0x20              ;820
000098  69c1              LDR      r1,[r0,#0x1c]         ;820
00009a  4638              MOV      r0,r7                 ;820
00009c  4388              BICS     r0,r0,r1              ;820
00009e  d021              BEQ      |L28.228|
                  |L28.160|
0000a0  1c70              ADDS     r0,r6,#1              ;820
0000a2  d01a              BEQ      |L28.218|
0000a4  2e00              CMP      r6,#0                 ;820
0000a6  d005              BEQ      |L28.180|
0000a8  f7fffffe          BL       HAL_GetTick
0000ac  9901              LDR      r1,[sp,#4]            ;820
0000ae  1a41              SUBS     r1,r0,r1              ;820
0000b0  42b1              CMP      r1,r6                 ;820
0000b2  d912              BLS      |L28.218|
                  |L28.180|
0000b4  6820              LDR      r0,[r4,#0]            ;820
0000b6  6801              LDR      r1,[r0,#0]            ;820
0000b8  22ff              MOVS     r2,#0xff              ;820
0000ba  32a1              ADDS     r2,r2,#0xa1           ;820
0000bc  4391              BICS     r1,r1,r2              ;820
0000be  6001              STR      r1,[r0,#0]            ;820
0000c0  6820              LDR      r0,[r4,#0]            ;820
0000c2  6881              LDR      r1,[r0,#8]            ;820
0000c4  0849              LSRS     r1,r1,#1              ;820
0000c6  0049              LSLS     r1,r1,#1              ;820
0000c8  6081              STR      r1,[r0,#8]            ;820
0000ca  2020              MOVS     r0,#0x20              ;820
0000cc  66e0              STR      r0,[r4,#0x6c]         ;820
0000ce  6720              STR      r0,[r4,#0x70]         ;820
0000d0  2000              MOVS     r0,#0                 ;820
0000d2  66a0              STR      r0,[r4,#0x68]         ;822
0000d4  2003              MOVS     r0,#3                 ;822
0000d6  b009              ADD      sp,sp,#0x24
0000d8  bdf0              POP      {r4-r7,pc}
                  |L28.218|
0000da  6820              LDR      r0,[r4,#0]
0000dc  69c1              LDR      r1,[r0,#0x1c]
0000de  4638              MOV      r0,r7
0000e0  4388              BICS     r0,r0,r1
0000e2  d1dd              BNE      |L28.160|
                  |L28.228|
0000e4  2001              MOVS     r0,#1                 ;824
0000e6  68a1              LDR      r1,[r4,#8]            ;824
0000e8  0300              LSLS     r0,r0,#12             ;824
0000ea  4281              CMP      r1,r0                 ;824
0000ec  d102              BNE      |L28.244|
0000ee  6920              LDR      r0,[r4,#0x10]         ;824
0000f0  2800              CMP      r0,#0                 ;824
0000f2  d013              BEQ      |L28.284|
                  |L28.244|
0000f4  6820              LDR      r0,[r4,#0]            ;832
0000f6  8c80              LDRH     r0,[r0,#0x24]         ;832
0000f8  9902              LDR      r1,[sp,#8]            ;832
0000fa  4008              ANDS     r0,r0,r1              ;832
0000fc  9906              LDR      r1,[sp,#0x18]         ;832
0000fe  7008              STRB     r0,[r1,#0]            ;832
000100  9806              LDR      r0,[sp,#0x18]         ;832
000102  1c40              ADDS     r0,r0,#1              ;832
                  |L28.260|
000104  9006              STR      r0,[sp,#0x18]         ;832
000106  8b68              LDRH     r0,[r5,#0x1a]         ;832
000108  2800              CMP      r0,#0                 ;832
00010a  e000              B        |L28.270|
                  |L28.268|
00010c  e00f              B        |L28.302|
                  |L28.270|
00010e  d1bc              BNE      |L28.138|
                  |L28.272|
000110  2020              MOVS     r0,#0x20              ;837
000112  6720              STR      r0,[r4,#0x70]         ;837
000114  2000              MOVS     r0,#0                 ;840
000116  66a0              STR      r0,[r4,#0x68]         ;842
000118  b009              ADD      sp,sp,#0x24
00011a  bdf0              POP      {r4-r7,pc}
                  |L28.284|
00011c  6821              LDR      r1,[r4,#0]            ;827
00011e  9806              LDR      r0,[sp,#0x18]         ;827
000120  8c89              LDRH     r1,[r1,#0x24]         ;827
000122  9a00              LDR      r2,[sp,#0]            ;827
000124  4011              ANDS     r1,r1,r2              ;827
000126  8001              STRH     r1,[r0,#0]            ;827
000128  9806              LDR      r0,[sp,#0x18]         ;828
00012a  1c80              ADDS     r0,r0,#2              ;828
00012c  e7ea              B        |L28.260|
                  |L28.302|
00012e  2002              MOVS     r0,#2                 ;846
000130  b009              ADD      sp,sp,#0x24
000132  bdf0              POP      {r4-r7,pc}
;;;849    
                          ENDP

                  |L28.308|
                          DCD      0x000001ff

                          AREA ||i.HAL_UART_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive_DMA PROC
;;;1053     */
;;;1054   HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1055   {
000002  4604              MOV      r4,r0
;;;1056     /* Check that a Rx process is not already ongoing */
;;;1057     if(huart->RxState == HAL_UART_STATE_READY)
000004  6f00              LDR      r0,[r0,#0x70]
000006  2820              CMP      r0,#0x20
000008  d13f              BNE      |L29.138|
;;;1058     {
;;;1059       if((pData == NULL ) || (Size == 0U))
00000a  2900              CMP      r1,#0
00000c  d00b              BEQ      |L29.38|
00000e  2a00              CMP      r2,#0
000010  d009              BEQ      |L29.38|
;;;1060       {
;;;1061         return HAL_ERROR;
;;;1062       }
;;;1063   
;;;1064       /* In case of 9bits/No Parity transfer, pData buffer provided as input paramter 
;;;1065          should be aligned on a u16 frontier, as data copy from RDR will be 
;;;1066          handled by DMA from a u16 frontier. */
;;;1067       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
000012  2301              MOVS     r3,#1
000014  68a0              LDR      r0,[r4,#8]
000016  031b              LSLS     r3,r3,#12
000018  4298              CMP      r0,r3
00001a  d106              BNE      |L29.42|
00001c  6920              LDR      r0,[r4,#0x10]
00001e  2800              CMP      r0,#0
000020  d103              BNE      |L29.42|
;;;1068       {
;;;1069         if((((uint32_t)pData)&1U) != 0U)
000022  07c8              LSLS     r0,r1,#31
000024  d001              BEQ      |L29.42|
                  |L29.38|
;;;1070         {
;;;1071           return  HAL_ERROR;
000026  2001              MOVS     r0,#1
;;;1072         }
;;;1073       }
;;;1074   
;;;1075       /* Process Locked */
;;;1076       __HAL_LOCK(huart);
;;;1077   
;;;1078       huart->pRxBuffPtr = pData;
;;;1079       huart->RxXferSize = Size;
;;;1080   
;;;1081       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1082       huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;1083   
;;;1084       /* Set the UART DMA transfer complete callback */
;;;1085       huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
;;;1086   
;;;1087       /* Set the UART DMA Half transfer complete callback */
;;;1088       huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
;;;1089   
;;;1090       /* Set the DMA error callback */
;;;1091       huart->hdmarx->XferErrorCallback = UART_DMAError;
;;;1092   
;;;1093       /* Set the DMA abort callback */
;;;1094       huart->hdmarx->XferAbortCallback = NULL;
;;;1095   
;;;1096       /* Enable the DMA channel */
;;;1097       HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->RDR, (uint32_t)huart->pRxBuffPtr, Size);
;;;1098   
;;;1099       /* Process Unlocked */
;;;1100       __HAL_UNLOCK(huart);
;;;1101   
;;;1102       /* Enable the UART Parity Error Interrupt */
;;;1103       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1104   
;;;1105       /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1106       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1107   
;;;1108       /* Enable the DMA transfer for the receiver request by setting the DMAR bit
;;;1109          in the UART CR3 register */
;;;1110       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1111   
;;;1112       return HAL_OK;
;;;1113     }
;;;1114     else
;;;1115     {
;;;1116       return HAL_BUSY;
;;;1117     }
;;;1118   }
000028  bdf8              POP      {r3-r7,pc}
                  |L29.42|
00002a  6ea0              LDR      r0,[r4,#0x68]         ;1076
00002c  2801              CMP      r0,#1                 ;1076
00002e  d02c              BEQ      |L29.138|
000030  2501              MOVS     r5,#1                 ;1076
000032  2058              MOVS     r0,#0x58              ;1079
000034  66a5              STR      r5,[r4,#0x68]         ;1079
000036  6561              STR      r1,[r4,#0x54]         ;1079
000038  5302              STRH     r2,[r0,r4]            ;1079
00003a  2600              MOVS     r6,#0                 ;1081
00003c  6766              STR      r6,[r4,#0x74]         ;1081
00003e  2022              MOVS     r0,#0x22              ;1082
000040  6720              STR      r0,[r4,#0x70]         ;1082
000042  6e61              LDR      r1,[r4,#0x64]         ;1085
000044  4812              LDR      r0,|L29.144|
000046  62c8              STR      r0,[r1,#0x2c]         ;1088
000048  6e61              LDR      r1,[r4,#0x64]         ;1088
00004a  4812              LDR      r0,|L29.148|
00004c  6308              STR      r0,[r1,#0x30]         ;1091
00004e  6e61              LDR      r1,[r4,#0x64]         ;1091
000050  4811              LDR      r0,|L29.152|
000052  6348              STR      r0,[r1,#0x34]         ;1094
000054  6e60              LDR      r0,[r4,#0x64]         ;1094
000056  4613              MOV      r3,r2                 ;1097
000058  6386              STR      r6,[r0,#0x38]         ;1097
00005a  6d67              LDR      r7,[r4,#0x54]         ;1097
00005c  6821              LDR      r1,[r4,#0]            ;1097
00005e  463a              MOV      r2,r7                 ;1097
000060  3124              ADDS     r1,r1,#0x24           ;1097
000062  6e60              LDR      r0,[r4,#0x64]         ;1097
000064  f7fffffe          BL       HAL_DMA_Start_IT
000068  66a6              STR      r6,[r4,#0x68]         ;1103
00006a  6820              LDR      r0,[r4,#0]            ;1103
00006c  6801              LDR      r1,[r0,#0]            ;1103
00006e  022a              LSLS     r2,r5,#8              ;1103
000070  4311              ORRS     r1,r1,r2              ;1103
000072  6001              STR      r1,[r0,#0]            ;1103
000074  6820              LDR      r0,[r4,#0]            ;1106
000076  6881              LDR      r1,[r0,#8]            ;1106
000078  4329              ORRS     r1,r1,r5              ;1106
00007a  6081              STR      r1,[r0,#8]            ;1106
00007c  6820              LDR      r0,[r4,#0]            ;1110
00007e  6881              LDR      r1,[r0,#8]            ;1110
000080  2240              MOVS     r2,#0x40              ;1110
000082  4311              ORRS     r1,r1,r2              ;1110
000084  6081              STR      r1,[r0,#8]            ;1110
000086  2000              MOVS     r0,#0                 ;1112
000088  bdf8              POP      {r3-r7,pc}
                  |L29.138|
00008a  2002              MOVS     r0,#2                 ;1116
00008c  bdf8              POP      {r3-r7,pc}
;;;1119   
                          ENDP

00008e  0000              DCW      0x0000
                  |L29.144|
                          DCD      UART_DMAReceiveCplt
                  |L29.148|
                          DCD      UART_DMARxHalfCplt
                  |L29.152|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive_IT PROC
;;;916      */
;;;917    HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b430              PUSH     {r4,r5}
;;;918    {
;;;919      /* Check that a Rx process is not already ongoing */
;;;920      if(huart->RxState == HAL_UART_STATE_READY)
000002  6f03              LDR      r3,[r0,#0x70]
000004  2b20              CMP      r3,#0x20
000006  d13b              BNE      |L30.128|
;;;921      {
;;;922        if((pData == NULL ) || (Size == 0U))
000008  2900              CMP      r1,#0
00000a  d00b              BEQ      |L30.36|
00000c  2a00              CMP      r2,#0
00000e  d009              BEQ      |L30.36|
;;;923        {
;;;924          return HAL_ERROR;
;;;925        }
;;;926    
;;;927        /* In case of 9bits/No Parity transfer, pData buffer provided as input paramter 
;;;928           should be aligned on a u16 frontier, as data to be received from RDR will be 
;;;929           handled through a u16 cast. */
;;;930        if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
000010  2401              MOVS     r4,#1
000012  6883              LDR      r3,[r0,#8]
000014  0324              LSLS     r4,r4,#12
000016  42a3              CMP      r3,r4
000018  d107              BNE      |L30.42|
00001a  6905              LDR      r5,[r0,#0x10]
00001c  2d00              CMP      r5,#0
00001e  d104              BNE      |L30.42|
;;;931        {
;;;932          if((((uint32_t)pData)&1U) != 0U)
000020  07cd              LSLS     r5,r1,#31
000022  d002              BEQ      |L30.42|
                  |L30.36|
;;;933          {
;;;934            return  HAL_ERROR;
;;;935          }
;;;936        }
;;;937    
;;;938        /* Process Locked */
;;;939        __HAL_LOCK(huart);
;;;940    
;;;941        huart->pRxBuffPtr = pData;
;;;942        huart->RxXferSize = Size;
;;;943        huart->RxXferCount = Size;
;;;944    
;;;945        /* Computation of UART mask to apply to RDR register */
;;;946        UART_MASK_COMPUTATION(huart);
;;;947    
;;;948        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;949        huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;950    
;;;951        /* Process Unlocked */
;;;952        __HAL_UNLOCK(huart);
;;;953    
;;;954        /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;955        SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;956    
;;;957        /* Enable the UART Parity Error and Data Register not empty Interrupts */
;;;958        SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
;;;959    
;;;960        return HAL_OK;
;;;961      }
;;;962      else
;;;963      {
;;;964        return HAL_BUSY;
;;;965      }
;;;966    }
000024  bc30              POP      {r4,r5}
000026  2001              MOVS     r0,#1                 ;934
000028  4770              BX       lr
                  |L30.42|
00002a  6e85              LDR      r5,[r0,#0x68]         ;939
00002c  2d01              CMP      r5,#1                 ;939
00002e  d027              BEQ      |L30.128|
000030  2501              MOVS     r5,#1                 ;939
000032  6685              STR      r5,[r0,#0x68]         ;942
000034  6541              STR      r1,[r0,#0x54]         ;942
000036  4601              MOV      r1,r0                 ;942
000038  3140              ADDS     r1,r1,#0x40           ;942
00003a  830a              STRH     r2,[r1,#0x18]         ;942
00003c  834a              STRH     r2,[r1,#0x1a]         ;943
00003e  22ff              MOVS     r2,#0xff              ;946
000040  42a3              CMP      r3,r4                 ;946
000042  d104              BNE      |L30.78|
000044  6903              LDR      r3,[r0,#0x10]         ;946
000046  2b00              CMP      r3,#0                 ;946
000048  d107              BNE      |L30.90|
00004a  4a0f              LDR      r2,|L30.136|
00004c  e005              B        |L30.90|
                  |L30.78|
00004e  2b00              CMP      r3,#0                 ;946
000050  d104              BNE      |L30.92|
000052  6903              LDR      r3,[r0,#0x10]         ;946
000054  2b00              CMP      r3,#0                 ;946
000056  d000              BEQ      |L30.90|
000058  227f              MOVS     r2,#0x7f              ;946
                  |L30.90|
00005a  838a              STRH     r2,[r1,#0x1c]         ;946
                  |L30.92|
00005c  2100              MOVS     r1,#0                 ;948
00005e  6741              STR      r1,[r0,#0x74]         ;948
000060  2222              MOVS     r2,#0x22              ;949
000062  6702              STR      r2,[r0,#0x70]         ;949
000064  6681              STR      r1,[r0,#0x68]         ;955
000066  6801              LDR      r1,[r0,#0]            ;955
000068  688a              LDR      r2,[r1,#8]            ;955
00006a  432a              ORRS     r2,r2,r5              ;955
00006c  608a              STR      r2,[r1,#8]            ;955
00006e  6800              LDR      r0,[r0,#0]            ;958
000070  6801              LDR      r1,[r0,#0]            ;958
000072  22ff              MOVS     r2,#0xff              ;958
000074  3221              ADDS     r2,r2,#0x21           ;958
000076  4311              ORRS     r1,r1,r2              ;958
000078  6001              STR      r1,[r0,#0]            ;958
00007a  bc30              POP      {r4,r5}
00007c  2000              MOVS     r0,#0                 ;960
00007e  4770              BX       lr
                  |L30.128|
000080  bc30              POP      {r4,r5}
000082  2002              MOVS     r0,#2                 ;964
000084  4770              BX       lr
;;;967    
                          ENDP

000086  0000              DCW      0x0000
                  |L30.136|
                          DCD      0x000001ff

                          AREA ||i.HAL_UART_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxCpltCallback PROC
;;;1839     */
;;;1840   __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1841   {
;;;1842     /* Prevent unused argument(s) compilation warning */
;;;1843     UNUSED(huart);
;;;1844   
;;;1845     /* NOTE : This function should not be modified, when the callback is needed,
;;;1846               the HAL_UART_RxCpltCallback can be implemented in the user file.
;;;1847      */
;;;1848   }
;;;1849   
                          ENDP


                          AREA ||i.HAL_UART_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxHalfCpltCallback PROC
;;;1854     */
;;;1855   __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1856   {
;;;1857     /* Prevent unused argument(s) compilation warning */
;;;1858     UNUSED(huart);
;;;1859   
;;;1860     /* NOTE: This function should not be modified, when the callback is needed,
;;;1861              the HAL_UART_RxHalfCpltCallback can be implemented in the user file.
;;;1862      */
;;;1863   }
;;;1864   
                          ENDP


                          AREA ||i.HAL_UART_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit PROC
;;;690      */
;;;691    HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  b5ff              PUSH     {r0-r7,lr}
;;;692    {
000002  4604              MOV      r4,r0
;;;693      uint16_t* tmp;
;;;694      uint32_t tickstart = 0U;
;;;695    
;;;696      /* Check that a Tx process is not already ongoing */
;;;697      if(huart->gState == HAL_UART_STATE_READY)
000004  6ec0              LDR      r0,[r0,#0x6c]
000006  b083              SUB      sp,sp,#0xc            ;692
000008  461d              MOV      r5,r3                 ;692
00000a  4617              MOV      r7,r2                 ;692
00000c  2820              CMP      r0,#0x20
00000e  d170              BNE      |L33.242|
;;;698      {
;;;699        if((pData == NULL ) || (Size == 0U))
000010  9804              LDR      r0,[sp,#0x10]
000012  2800              CMP      r0,#0
000014  d00c              BEQ      |L33.48|
000016  2f00              CMP      r7,#0
000018  d00a              BEQ      |L33.48|
;;;700        {
;;;701          return  HAL_ERROR;
;;;702        }
;;;703    
;;;704        /* In case of 9bits/No Parity transfer, pData buffer provided as input paramter 
;;;705           should be aligned on a u16 frontier, as data to be filled into TDR will be 
;;;706           handled through a u16 cast. */
;;;707        if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
00001a  2001              MOVS     r0,#1
00001c  68a1              LDR      r1,[r4,#8]
00001e  0300              LSLS     r0,r0,#12
000020  4281              CMP      r1,r0
000022  d108              BNE      |L33.54|
000024  6920              LDR      r0,[r4,#0x10]
000026  2800              CMP      r0,#0
000028  d105              BNE      |L33.54|
;;;708        {
;;;709          if((((uint32_t)pData)&1U) != 0U)
00002a  9804              LDR      r0,[sp,#0x10]
00002c  07c0              LSLS     r0,r0,#31
00002e  d002              BEQ      |L33.54|
                  |L33.48|
;;;710          {
;;;711            return  HAL_ERROR;
000030  2001              MOVS     r0,#1
;;;712          }
;;;713        }
;;;714    
;;;715        /* Process Locked */
;;;716        __HAL_LOCK(huart);
;;;717    
;;;718        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;719        huart->gState = HAL_UART_STATE_BUSY_TX;
;;;720    
;;;721        /* Init tickstart for timeout managment*/
;;;722        tickstart = HAL_GetTick();
;;;723    
;;;724        huart->TxXferSize = Size;
;;;725        huart->TxXferCount = Size;
;;;726        while(huart->TxXferCount > 0)
;;;727        {
;;;728          huart->TxXferCount--;
;;;729          if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;730          {
;;;731            return HAL_TIMEOUT;
;;;732          }
;;;733          if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;734          {
;;;735            tmp = (uint16_t*) pData;
;;;736            huart->Instance->TDR = (*tmp & (uint16_t)0x01FFU);
;;;737            pData += 2;
;;;738          }
;;;739          else
;;;740          {
;;;741            huart->Instance->TDR = (*pData++ & (uint8_t)0xFFU);
;;;742          }
;;;743        }
;;;744        if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;745        {
;;;746          return HAL_TIMEOUT;
;;;747        }
;;;748    
;;;749        /* At end of Tx process, restore huart->gState to Ready */
;;;750        huart->gState = HAL_UART_STATE_READY;
;;;751    
;;;752        /* Process Unlocked */
;;;753        __HAL_UNLOCK(huart);
;;;754    
;;;755        return HAL_OK;
;;;756      }
;;;757      else
;;;758      {
;;;759        return HAL_BUSY;
;;;760      }
;;;761    }
000032  b007              ADD      sp,sp,#0x1c
000034  bdf0              POP      {r4-r7,pc}
                  |L33.54|
000036  6ea0              LDR      r0,[r4,#0x68]         ;716
000038  2801              CMP      r0,#1                 ;716
00003a  d06a              BEQ      |L33.274|
00003c  2001              MOVS     r0,#1                 ;716
00003e  66a0              STR      r0,[r4,#0x68]         ;718
000040  2000              MOVS     r0,#0                 ;718
000042  6760              STR      r0,[r4,#0x74]         ;718
000044  2021              MOVS     r0,#0x21              ;719
000046  66e0              STR      r0,[r4,#0x6c]         ;719
000048  f7fffffe          BL       HAL_GetTick
00004c  4626              MOV      r6,r4                 ;724
00004e  3640              ADDS     r6,r6,#0x40           ;724
000050  9001              STR      r0,[sp,#4]            ;724
000052  8237              STRH     r7,[r6,#0x10]         ;724
000054  8277              STRH     r7,[r6,#0x12]         ;725
000056  8a70              LDRH     r0,[r6,#0x12]         ;726
000058  2800              CMP      r0,#0                 ;726
00005a  d03e              BEQ      |L33.218|
                  |L33.92|
00005c  8a70              LDRH     r0,[r6,#0x12]         ;728
00005e  1e40              SUBS     r0,r0,#1              ;728
000060  8270              STRH     r0,[r6,#0x12]         ;728
000062  9801              LDR      r0,[sp,#4]            ;729
000064  9000              STR      r0,[sp,#0]            ;729
000066  6820              LDR      r0,[r4,#0]            ;729
000068  2780              MOVS     r7,#0x80              ;729
00006a  69c1              LDR      r1,[r0,#0x1c]         ;729
00006c  4638              MOV      r0,r7                 ;729
00006e  4388              BICS     r0,r0,r1              ;729
000070  d021              BEQ      |L33.182|
                  |L33.114|
000072  1c68              ADDS     r0,r5,#1              ;729
000074  d01a              BEQ      |L33.172|
000076  2d00              CMP      r5,#0                 ;729
000078  d005              BEQ      |L33.134|
00007a  f7fffffe          BL       HAL_GetTick
00007e  9900              LDR      r1,[sp,#0]            ;729
000080  1a41              SUBS     r1,r0,r1              ;729
000082  42a9              CMP      r1,r5                 ;729
000084  d912              BLS      |L33.172|
                  |L33.134|
000086  6820              LDR      r0,[r4,#0]            ;729
000088  6801              LDR      r1,[r0,#0]            ;729
00008a  22ff              MOVS     r2,#0xff              ;729
00008c  32a1              ADDS     r2,r2,#0xa1           ;729
00008e  4391              BICS     r1,r1,r2              ;729
000090  6001              STR      r1,[r0,#0]            ;729
000092  6820              LDR      r0,[r4,#0]            ;729
000094  6881              LDR      r1,[r0,#8]            ;729
000096  0849              LSRS     r1,r1,#1              ;729
000098  0049              LSLS     r1,r1,#1              ;729
00009a  6081              STR      r1,[r0,#8]            ;729
00009c  2020              MOVS     r0,#0x20              ;729
00009e  66e0              STR      r0,[r4,#0x6c]         ;729
0000a0  6720              STR      r0,[r4,#0x70]         ;729
0000a2  2000              MOVS     r0,#0                 ;729
0000a4  66a0              STR      r0,[r4,#0x68]         ;731
0000a6  2003              MOVS     r0,#3                 ;731
0000a8  b007              ADD      sp,sp,#0x1c
0000aa  bdf0              POP      {r4-r7,pc}
                  |L33.172|
0000ac  6820              LDR      r0,[r4,#0]
0000ae  69c1              LDR      r1,[r0,#0x1c]
0000b0  4638              MOV      r0,r7
0000b2  4388              BICS     r0,r0,r1
0000b4  d1dd              BNE      |L33.114|
                  |L33.182|
0000b6  2001              MOVS     r0,#1                 ;733
0000b8  68a1              LDR      r1,[r4,#8]            ;733
0000ba  0300              LSLS     r0,r0,#12             ;733
0000bc  4281              CMP      r1,r0                 ;733
0000be  d102              BNE      |L33.198|
0000c0  6920              LDR      r0,[r4,#0x10]         ;733
0000c2  2800              CMP      r0,#0                 ;733
0000c4  d016              BEQ      |L33.244|
                  |L33.198|
0000c6  9804              LDR      r0,[sp,#0x10]         ;741
0000c8  6821              LDR      r1,[r4,#0]            ;741
0000ca  7800              LDRB     r0,[r0,#0]            ;741
0000cc  8508              STRH     r0,[r1,#0x28]         ;741
0000ce  9804              LDR      r0,[sp,#0x10]         ;741
0000d0  1c40              ADDS     r0,r0,#1              ;741
                  |L33.210|
0000d2  9004              STR      r0,[sp,#0x10]         ;741
0000d4  8a70              LDRH     r0,[r6,#0x12]         ;741
0000d6  2800              CMP      r0,#0                 ;741
0000d8  d1c0              BNE      |L33.92|
                  |L33.218|
0000da  9500              STR      r5,[sp,#0]            ;744
0000dc  2200              MOVS     r2,#0                 ;744
0000de  2140              MOVS     r1,#0x40              ;744
0000e0  4620              MOV      r0,r4                 ;744
0000e2  9b01              LDR      r3,[sp,#4]            ;744
0000e4  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
0000e8  2800              CMP      r0,#0                 ;744
0000ea  d00c              BEQ      |L33.262|
0000ec  2003              MOVS     r0,#3                 ;746
0000ee  b007              ADD      sp,sp,#0x1c
0000f0  bdf0              POP      {r4-r7,pc}
                  |L33.242|
0000f2  e00e              B        |L33.274|
                  |L33.244|
0000f4  9804              LDR      r0,[sp,#0x10]         ;736
0000f6  6821              LDR      r1,[r4,#0]            ;736
0000f8  8800              LDRH     r0,[r0,#0]            ;736
0000fa  05c0              LSLS     r0,r0,#23             ;736
0000fc  0dc0              LSRS     r0,r0,#23             ;736
0000fe  8508              STRH     r0,[r1,#0x28]         ;736
000100  9804              LDR      r0,[sp,#0x10]         ;737
000102  1c80              ADDS     r0,r0,#2              ;737
000104  e7e5              B        |L33.210|
                  |L33.262|
000106  2020              MOVS     r0,#0x20              ;750
000108  66e0              STR      r0,[r4,#0x6c]         ;750
00010a  2000              MOVS     r0,#0                 ;753
00010c  66a0              STR      r0,[r4,#0x68]         ;755
00010e  b007              ADD      sp,sp,#0x1c
000110  bdf0              POP      {r4-r7,pc}
                  |L33.274|
000112  2002              MOVS     r0,#2                 ;759
000114  b007              ADD      sp,sp,#0x1c
000116  bdf0              POP      {r4-r7,pc}
;;;762    
                          ENDP


                          AREA ||i.HAL_UART_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Transmit_DMA PROC
;;;978      */
;;;979    HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;980    {
000002  4604              MOV      r4,r0
;;;981      /* Check that a Tx process is not already ongoing */
;;;982      if(huart->gState == HAL_UART_STATE_READY)
000004  6ec0              LDR      r0,[r0,#0x6c]
000006  2820              CMP      r0,#0x20
000008  d13b              BNE      |L34.130|
;;;983      {
;;;984        if((pData == NULL ) || (Size == 0U))
00000a  2900              CMP      r1,#0
00000c  d00b              BEQ      |L34.38|
00000e  2a00              CMP      r2,#0
000010  d009              BEQ      |L34.38|
;;;985        {
;;;986          return HAL_ERROR;
;;;987        }
;;;988    
;;;989        /* In case of 9bits/No Parity transfer, pData buffer provided as input paramter 
;;;990           should be aligned on a u16 frontier, as data copy into TDR will be 
;;;991           handled by DMA from a u16 frontier. */
;;;992        if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
000012  2301              MOVS     r3,#1
000014  68a0              LDR      r0,[r4,#8]
000016  031b              LSLS     r3,r3,#12
000018  4298              CMP      r0,r3
00001a  d106              BNE      |L34.42|
00001c  6920              LDR      r0,[r4,#0x10]
00001e  2800              CMP      r0,#0
000020  d103              BNE      |L34.42|
;;;993        {
;;;994          if((((uint32_t)pData)&1U) != 0U)
000022  07c8              LSLS     r0,r1,#31
000024  d001              BEQ      |L34.42|
                  |L34.38|
;;;995          {
;;;996            return  HAL_ERROR;
000026  2001              MOVS     r0,#1
;;;997          }
;;;998        }
;;;999    
;;;1000       /* Process Locked */
;;;1001       __HAL_LOCK(huart);
;;;1002   
;;;1003       huart->pTxBuffPtr = pData;
;;;1004       huart->TxXferSize = Size;
;;;1005       huart->TxXferCount = Size;
;;;1006   
;;;1007       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1008       huart->gState = HAL_UART_STATE_BUSY_TX;
;;;1009   
;;;1010       /* Set the UART DMA transfer complete callback */
;;;1011       huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
;;;1012   
;;;1013       /* Set the UART DMA Half transfer complete callback */
;;;1014       huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
;;;1015   
;;;1016       /* Set the DMA error callback */
;;;1017       huart->hdmatx->XferErrorCallback = UART_DMAError;
;;;1018   
;;;1019       /* Set the DMA abort callback */
;;;1020       huart->hdmatx->XferAbortCallback = NULL;
;;;1021   
;;;1022       /* Enable the UART transmit DMA channel */
;;;1023       HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size);
;;;1024   
;;;1025       /* Clear the TC flag in the ICR register */
;;;1026       __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_TCF);
;;;1027   
;;;1028       /* Process Unlocked */
;;;1029       __HAL_UNLOCK(huart);
;;;1030   
;;;1031       /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;1032          in the UART CR3 register */
;;;1033       SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1034   
;;;1035       return HAL_OK;
;;;1036     }
;;;1037     else
;;;1038     {
;;;1039       return HAL_BUSY;
;;;1040     }
;;;1041   }
000028  bd70              POP      {r4-r6,pc}
                  |L34.42|
00002a  6ea0              LDR      r0,[r4,#0x68]         ;1001
00002c  2801              CMP      r0,#1                 ;1001
00002e  d028              BEQ      |L34.130|
000030  2001              MOVS     r0,#1                 ;1001
000032  64e1              STR      r1,[r4,#0x4c]         ;1004
000034  66a0              STR      r0,[r4,#0x68]         ;1004
000036  4620              MOV      r0,r4                 ;1004
000038  3040              ADDS     r0,r0,#0x40           ;1004
00003a  8202              STRH     r2,[r0,#0x10]         ;1004
00003c  8242              STRH     r2,[r0,#0x12]         ;1005
00003e  2500              MOVS     r5,#0                 ;1007
000040  6765              STR      r5,[r4,#0x74]         ;1007
000042  2021              MOVS     r0,#0x21              ;1008
000044  66e0              STR      r0,[r4,#0x6c]         ;1008
000046  6e21              LDR      r1,[r4,#0x60]         ;1011
000048  480f              LDR      r0,|L34.136|
00004a  62c8              STR      r0,[r1,#0x2c]         ;1014
00004c  6e21              LDR      r1,[r4,#0x60]         ;1014
00004e  480f              LDR      r0,|L34.140|
000050  6308              STR      r0,[r1,#0x30]         ;1017
000052  6e21              LDR      r1,[r4,#0x60]         ;1017
000054  480e              LDR      r0,|L34.144|
000056  6348              STR      r0,[r1,#0x34]         ;1020
000058  6e20              LDR      r0,[r4,#0x60]         ;1020
00005a  4613              MOV      r3,r2                 ;1023
00005c  6385              STR      r5,[r0,#0x38]         ;1023
00005e  6826              LDR      r6,[r4,#0]            ;1023
000060  6ce1              LDR      r1,[r4,#0x4c]         ;1023
000062  4632              MOV      r2,r6                 ;1023
000064  3228              ADDS     r2,r2,#0x28           ;1023
000066  6e20              LDR      r0,[r4,#0x60]         ;1023
000068  f7fffffe          BL       HAL_DMA_Start_IT
00006c  6821              LDR      r1,[r4,#0]            ;1026
00006e  2040              MOVS     r0,#0x40              ;1026
000070  6208              STR      r0,[r1,#0x20]         ;1026
000072  66a5              STR      r5,[r4,#0x68]         ;1033
000074  6820              LDR      r0,[r4,#0]            ;1033
000076  6881              LDR      r1,[r0,#8]            ;1033
000078  2280              MOVS     r2,#0x80              ;1033
00007a  4311              ORRS     r1,r1,r2              ;1033
00007c  6081              STR      r1,[r0,#8]            ;1033
00007e  2000              MOVS     r0,#0                 ;1035
000080  bd70              POP      {r4-r6,pc}
                  |L34.130|
000082  2002              MOVS     r0,#2                 ;1039
000084  bd70              POP      {r4-r6,pc}
;;;1042   
                          ENDP

000086  0000              DCW      0x0000
                  |L34.136|
                          DCD      UART_DMATransmitCplt
                  |L34.140|
                          DCD      UART_DMATxHalfCplt
                  |L34.144|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit_IT PROC
;;;860      */
;;;861    HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b410              PUSH     {r4}
;;;862    {
;;;863      /* Check that a Tx process is not already ongoing */
;;;864      if(huart->gState == HAL_UART_STATE_READY)
000002  6ec3              LDR      r3,[r0,#0x6c]
000004  2b20              CMP      r3,#0x20
000006  d125              BNE      |L35.84|
;;;865      {
;;;866        if((pData == NULL ) || (Size == 0U))
000008  2900              CMP      r1,#0
00000a  d00b              BEQ      |L35.36|
00000c  2a00              CMP      r2,#0
00000e  d009              BEQ      |L35.36|
;;;867        {
;;;868          return HAL_ERROR;
;;;869        }
;;;870    
;;;871        /* In case of 9bits/No Parity transfer, pData buffer provided as input paramter 
;;;872           should be aligned on a u16 frontier, as data to be filled into TDR will be 
;;;873           handled through a u16 cast. */
;;;874        if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
000010  2401              MOVS     r4,#1
000012  6883              LDR      r3,[r0,#8]
000014  0324              LSLS     r4,r4,#12
000016  42a3              CMP      r3,r4
000018  d107              BNE      |L35.42|
00001a  6903              LDR      r3,[r0,#0x10]
00001c  2b00              CMP      r3,#0
00001e  d104              BNE      |L35.42|
;;;875        {
;;;876          if((((uint32_t)pData)&1U) != 0U)
000020  07cb              LSLS     r3,r1,#31
000022  d002              BEQ      |L35.42|
                  |L35.36|
;;;877          {
;;;878            return  HAL_ERROR;
;;;879          }
;;;880        }
;;;881    
;;;882        /* Process Locked */
;;;883        __HAL_LOCK(huart);
;;;884    
;;;885        huart->pTxBuffPtr = pData;
;;;886        huart->TxXferSize = Size;
;;;887        huart->TxXferCount = Size;
;;;888    
;;;889        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;890        huart->gState = HAL_UART_STATE_BUSY_TX;
;;;891    
;;;892        /* Process Unlocked */
;;;893        __HAL_UNLOCK(huart);
;;;894    
;;;895        /* Enable the UART Transmit Data Register Empty Interrupt */
;;;896        SET_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
;;;897    
;;;898        return HAL_OK;
;;;899      }
;;;900      else
;;;901      {
;;;902        return HAL_BUSY;
;;;903      }
;;;904    }
000024  bc10              POP      {r4}
000026  2001              MOVS     r0,#1                 ;878
000028  4770              BX       lr
                  |L35.42|
00002a  6e83              LDR      r3,[r0,#0x68]         ;883
00002c  2b01              CMP      r3,#1                 ;883
00002e  d011              BEQ      |L35.84|
000030  64c1              STR      r1,[r0,#0x4c]         ;886
000032  4601              MOV      r1,r0                 ;886
000034  3140              ADDS     r1,r1,#0x40           ;886
000036  820a              STRH     r2,[r1,#0x10]         ;886
000038  824a              STRH     r2,[r1,#0x12]         ;887
00003a  2100              MOVS     r1,#0                 ;889
00003c  6741              STR      r1,[r0,#0x74]         ;889
00003e  2221              MOVS     r2,#0x21              ;890
000040  66c2              STR      r2,[r0,#0x6c]         ;890
000042  6681              STR      r1,[r0,#0x68]         ;896
000044  6800              LDR      r0,[r0,#0]            ;896
000046  6801              LDR      r1,[r0,#0]            ;896
000048  2280              MOVS     r2,#0x80              ;896
00004a  4311              ORRS     r1,r1,r2              ;896
00004c  6001              STR      r1,[r0,#0]            ;896
00004e  bc10              POP      {r4}
000050  2000              MOVS     r0,#0                 ;898
000052  4770              BX       lr
                  |L35.84|
000054  bc10              POP      {r4}
000056  2002              MOVS     r0,#2                 ;902
000058  4770              BX       lr
;;;905    
                          ENDP


                          AREA ||i.HAL_UART_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxCpltCallback PROC
;;;1809     */
;;;1810   __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1811   {
;;;1812     /* Prevent unused argument(s) compilation warning */
;;;1813     UNUSED(huart);
;;;1814   
;;;1815     /* NOTE : This function should not be modified, when the callback is needed,
;;;1816               the HAL_UART_TxCpltCallback can be implemented in the user file.
;;;1817      */
;;;1818   }
;;;1819   
                          ENDP


                          AREA ||i.HAL_UART_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxHalfCpltCallback PROC
;;;1824     */
;;;1825   __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1826   {
;;;1827     /* Prevent unused argument(s) compilation warning */
;;;1828     UNUSED(huart);
;;;1829   
;;;1830     /* NOTE: This function should not be modified, when the callback is needed,
;;;1831              the HAL_UART_TxHalfCpltCallback can be implemented in the user file.
;;;1832      */
;;;1833   }
;;;1834   
                          ENDP


                          AREA ||i.UART_AdvFeatureConfig||, CODE, READONLY, ALIGN=1

                  UART_AdvFeatureConfig PROC
;;;2213     */
;;;2214   void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
000000  b410              PUSH     {r4}
;;;2215   {
;;;2216     /* Check whether the set of advanced features to configure is properly set */
;;;2217     assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
;;;2218   
;;;2219     /* if required, configure TX pin active level inversion */
;;;2220     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
000002  8c81              LDRH     r1,[r0,#0x24]
000004  07c9              LSLS     r1,r1,#31
000006  d007              BEQ      |L38.24|
;;;2221     {
;;;2222       assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
;;;2223       MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
000008  6801              LDR      r1,[r0,#0]
00000a  684a              LDR      r2,[r1,#4]
00000c  2301              MOVS     r3,#1
00000e  045b              LSLS     r3,r3,#17
000010  439a              BICS     r2,r2,r3
000012  6a83              LDR      r3,[r0,#0x28]
000014  431a              ORRS     r2,r2,r3
000016  604a              STR      r2,[r1,#4]
                  |L38.24|
;;;2224     }
;;;2225   
;;;2226     /* if required, configure RX pin active level inversion */
;;;2227     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
000018  8c81              LDRH     r1,[r0,#0x24]
00001a  0789              LSLS     r1,r1,#30
00001c  d507              BPL      |L38.46|
;;;2228     {
;;;2229       assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
;;;2230       MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
00001e  6801              LDR      r1,[r0,#0]
000020  684a              LDR      r2,[r1,#4]
000022  2301              MOVS     r3,#1
000024  041b              LSLS     r3,r3,#16
000026  439a              BICS     r2,r2,r3
000028  6ac3              LDR      r3,[r0,#0x2c]
00002a  431a              ORRS     r2,r2,r3
00002c  604a              STR      r2,[r1,#4]
                  |L38.46|
;;;2231     }
;;;2232   
;;;2233     /* if required, configure data inversion */
;;;2234     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
00002e  8c81              LDRH     r1,[r0,#0x24]
000030  0749              LSLS     r1,r1,#29
000032  d507              BPL      |L38.68|
;;;2235     {
;;;2236       assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
;;;2237       MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
000034  6801              LDR      r1,[r0,#0]
000036  684a              LDR      r2,[r1,#4]
000038  2301              MOVS     r3,#1
00003a  049b              LSLS     r3,r3,#18
00003c  439a              BICS     r2,r2,r3
00003e  6b03              LDR      r3,[r0,#0x30]
000040  431a              ORRS     r2,r2,r3
000042  604a              STR      r2,[r1,#4]
                  |L38.68|
;;;2238     }
;;;2239   
;;;2240     /* if required, configure RX/TX pins swap */
;;;2241     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
000044  8c81              LDRH     r1,[r0,#0x24]
000046  0709              LSLS     r1,r1,#28
000048  d507              BPL      |L38.90|
;;;2242     {
;;;2243       assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
;;;2244       MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
00004a  6801              LDR      r1,[r0,#0]
00004c  684a              LDR      r2,[r1,#4]
00004e  2301              MOVS     r3,#1
000050  03db              LSLS     r3,r3,#15
000052  439a              BICS     r2,r2,r3
000054  6b43              LDR      r3,[r0,#0x34]
000056  431a              ORRS     r2,r2,r3
000058  604a              STR      r2,[r1,#4]
                  |L38.90|
;;;2245     }
;;;2246   
;;;2247     /* if required, configure RX overrun detection disabling */
;;;2248     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
00005a  8c81              LDRH     r1,[r0,#0x24]
00005c  06c9              LSLS     r1,r1,#27
00005e  d507              BPL      |L38.112|
;;;2249     {
;;;2250       assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
;;;2251       MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
000060  6802              LDR      r2,[r0,#0]
000062  6891              LDR      r1,[r2,#8]
000064  2301              MOVS     r3,#1
000066  031b              LSLS     r3,r3,#12
000068  4399              BICS     r1,r1,r3
00006a  6b83              LDR      r3,[r0,#0x38]
00006c  4319              ORRS     r1,r1,r3
00006e  6091              STR      r1,[r2,#8]
                  |L38.112|
;;;2252     }
;;;2253   
;;;2254     /* if required, configure DMA disabling on reception error */
;;;2255     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
000070  8c81              LDRH     r1,[r0,#0x24]
000072  0689              LSLS     r1,r1,#26
000074  d507              BPL      |L38.134|
;;;2256     {
;;;2257       assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
;;;2258       MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
000076  6801              LDR      r1,[r0,#0]
000078  688a              LDR      r2,[r1,#8]
00007a  2301              MOVS     r3,#1
00007c  035b              LSLS     r3,r3,#13
00007e  439a              BICS     r2,r2,r3
000080  6bc3              LDR      r3,[r0,#0x3c]
000082  431a              ORRS     r2,r2,r3
000084  608a              STR      r2,[r1,#8]
                  |L38.134|
;;;2259     }
;;;2260   
;;;2261     /* if required, configure auto Baud rate detection scheme */
;;;2262     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
000086  8c81              LDRH     r1,[r0,#0x24]
000088  0649              LSLS     r1,r1,#25
00008a  d512              BPL      |L38.178|
;;;2263     {
;;;2264       assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
;;;2265       assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
;;;2266       MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
00008c  6803              LDR      r3,[r0,#0]
00008e  685a              LDR      r2,[r3,#4]
000090  2101              MOVS     r1,#1
000092  0509              LSLS     r1,r1,#20
000094  6c04              LDR      r4,[r0,#0x40]
000096  438a              BICS     r2,r2,r1
000098  4322              ORRS     r2,r2,r4
00009a  605a              STR      r2,[r3,#4]
;;;2267       /* set auto Baudrate detection parameters if detection is enabled */
;;;2268       if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
00009c  6c02              LDR      r2,[r0,#0x40]
00009e  428a              CMP      r2,r1
0000a0  d107              BNE      |L38.178|
;;;2269       {
;;;2270         assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
;;;2271         MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
0000a2  6802              LDR      r2,[r0,#0]
0000a4  6851              LDR      r1,[r2,#4]
0000a6  2303              MOVS     r3,#3
0000a8  055b              LSLS     r3,r3,#21
0000aa  4399              BICS     r1,r1,r3
0000ac  6c43              LDR      r3,[r0,#0x44]
0000ae  4319              ORRS     r1,r1,r3
0000b0  6051              STR      r1,[r2,#4]
                  |L38.178|
;;;2272       }
;;;2273     }
;;;2274   
;;;2275     /* if required, configure MSB first on communication line */
;;;2276     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
0000b2  8c81              LDRH     r1,[r0,#0x24]
0000b4  0609              LSLS     r1,r1,#24
0000b6  d507              BPL      |L38.200|
;;;2277     {
;;;2278       assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
;;;2279       MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
0000b8  6801              LDR      r1,[r0,#0]
0000ba  684a              LDR      r2,[r1,#4]
0000bc  2301              MOVS     r3,#1
0000be  04db              LSLS     r3,r3,#19
0000c0  6c80              LDR      r0,[r0,#0x48]
0000c2  439a              BICS     r2,r2,r3
0000c4  4302              ORRS     r2,r2,r0
0000c6  604a              STR      r2,[r1,#4]
                  |L38.200|
;;;2280     }
;;;2281   }
0000c8  bc10              POP      {r4}
0000ca  4770              BX       lr
;;;2282   
                          ENDP


                          AREA ||i.UART_CheckIdleState||, CODE, READONLY, ALIGN=1

                  UART_CheckIdleState PROC
;;;2287     */
;;;2288   HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
000000  2100              MOVS     r1,#0
;;;2289   {
;;;2290   #if !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F070x6)&& !defined(STM32F030xC)
;;;2291     uint32_t tickstart = 0U;
;;;2292   #endif /* !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F070x6)&& !defined(STM32F030xC) */
;;;2293   
;;;2294     /* Initialize the UART ErrorCode */
;;;2295     huart->ErrorCode = HAL_UART_ERROR_NONE;
000002  6741              STR      r1,[r0,#0x74]
;;;2296   
;;;2297   #if !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F070x6)&& !defined(STM32F030xC)
;;;2298     /* Init tickstart for timeout managment*/
;;;2299     tickstart = HAL_GetTick();
;;;2300   
;;;2301     /* TEACK and REACK bits in ISR are checked only when available (not available on all F0 devices).
;;;2302        Bits are defined for some specific devices, and are available only for UART instances supporting WakeUp from Stop Mode feature. 
;;;2303     */
;;;2304     if (IS_UART_WAKEUP_FROMSTOP_INSTANCE(huart->Instance))
;;;2305     {
;;;2306       /* Check if the Transmitter is enabled */
;;;2307       if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
;;;2308       {
;;;2309         /* Wait until TEACK flag is set */
;;;2310         if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
;;;2311         {
;;;2312           /* Timeout occurred */
;;;2313           return HAL_TIMEOUT;
;;;2314         }
;;;2315       }
;;;2316   
;;;2317       /* Check if the Receiver is enabled */
;;;2318       if((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
;;;2319       {
;;;2320         /* Wait until REACK flag is set */
;;;2321         if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
;;;2322         {
;;;2323           /* Timeout occurred */
;;;2324           return HAL_TIMEOUT;
;;;2325         }
;;;2326       }
;;;2327     }
;;;2328   #endif /* !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F070x6)&& !defined(STM32F030xC) */
;;;2329   
;;;2330     /* Initialize the UART State */
;;;2331     huart->gState  = HAL_UART_STATE_READY;
000004  2220              MOVS     r2,#0x20
000006  66c2              STR      r2,[r0,#0x6c]
;;;2332     huart->RxState = HAL_UART_STATE_READY;
000008  6702              STR      r2,[r0,#0x70]
;;;2333   
;;;2334     /* Process Unlocked */
;;;2335     __HAL_UNLOCK(huart);
;;;2336   
;;;2337     return HAL_OK;
00000a  6681              STR      r1,[r0,#0x68]
00000c  4608              MOV      r0,r1
;;;2338   }
00000e  4770              BX       lr
;;;2339   
                          ENDP


                          AREA ||i.UART_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  UART_DMAAbortOnError PROC
;;;2523     */
;;;2524   static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2525   {
;;;2526     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)(hdma->Parent);
000002  6a80              LDR      r0,[r0,#0x28]
;;;2527     huart->RxXferCount = 0U;
000004  2200              MOVS     r2,#0
000006  4601              MOV      r1,r0
000008  3140              ADDS     r1,r1,#0x40
00000a  834a              STRH     r2,[r1,#0x1a]
;;;2528     huart->TxXferCount = 0U;
00000c  824a              STRH     r2,[r1,#0x12]
;;;2529   
;;;2530     HAL_UART_ErrorCallback(huart);
00000e  f7fffffe          BL       HAL_UART_ErrorCallback
;;;2531   }
000012  bd10              POP      {r4,pc}
;;;2532   
                          ENDP


                          AREA ||i.UART_DMAError||, CODE, READONLY, ALIGN=1

                  UART_DMAError PROC
;;;2493     */
;;;2494   static void UART_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2495   {
;;;2496     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)(hdma->Parent);
000002  6a80              LDR      r0,[r0,#0x28]
;;;2497   
;;;2498     /* Stop UART DMA Tx request if ongoing */
;;;2499     if (  (huart->gState == HAL_UART_STATE_BUSY_TX)
000004  6ec1              LDR      r1,[r0,#0x6c]
000006  2200              MOVS     r2,#0
000008  2320              MOVS     r3,#0x20
00000a  2921              CMP      r1,#0x21
00000c  d10b              BNE      |L41.38|
;;;2500         &&(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) )
00000e  6801              LDR      r1,[r0,#0]
000010  6889              LDR      r1,[r1,#8]
000012  0609              LSLS     r1,r1,#24
000014  d507              BPL      |L41.38|
;;;2501     {
;;;2502       huart->TxXferCount = 0U;
000016  2152              MOVS     r1,#0x52
000018  520a              STRH     r2,[r1,r0]
00001a  6801              LDR      r1,[r0,#0]
00001c  680c              LDR      r4,[r1,#0]
00001e  25c0              MOVS     r5,#0xc0
000020  43ac              BICS     r4,r4,r5
000022  600c              STR      r4,[r1,#0]
000024  66c3              STR      r3,[r0,#0x6c]
                  |L41.38|
;;;2503       UART_EndTxTransfer(huart);
;;;2504     }
;;;2505   
;;;2506     /* Stop UART DMA Rx request if ongoing */
;;;2507     if (  (huart->RxState == HAL_UART_STATE_BUSY_RX)
000026  6f01              LDR      r1,[r0,#0x70]
000028  2922              CMP      r1,#0x22
00002a  d110              BNE      |L41.78|
;;;2508         &&(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) )
00002c  6801              LDR      r1,[r0,#0]
00002e  688c              LDR      r4,[r1,#8]
000030  0664              LSLS     r4,r4,#25
000032  d50c              BPL      |L41.78|
;;;2509     {
;;;2510       huart->RxXferCount = 0U;
000034  245a              MOVS     r4,#0x5a
000036  5222              STRH     r2,[r4,r0]
000038  680a              LDR      r2,[r1,#0]
00003a  24ff              MOVS     r4,#0xff
00003c  3421              ADDS     r4,r4,#0x21
00003e  43a2              BICS     r2,r2,r4
000040  600a              STR      r2,[r1,#0]
000042  6801              LDR      r1,[r0,#0]
000044  688a              LDR      r2,[r1,#8]
000046  0852              LSRS     r2,r2,#1
000048  0052              LSLS     r2,r2,#1
00004a  608a              STR      r2,[r1,#8]
00004c  6703              STR      r3,[r0,#0x70]
                  |L41.78|
;;;2511       UART_EndRxTransfer(huart);
;;;2512     }
;;;2513   
;;;2514     huart->ErrorCode |= HAL_UART_ERROR_DMA;
00004e  6f41              LDR      r1,[r0,#0x74]
000050  2210              MOVS     r2,#0x10
000052  4311              ORRS     r1,r1,r2
000054  6741              STR      r1,[r0,#0x74]
;;;2515     HAL_UART_ErrorCallback(huart);
000056  f7fffffe          BL       HAL_UART_ErrorCallback
;;;2516   }
00005a  bd70              POP      {r4-r6,pc}
;;;2517   
                          ENDP


                          AREA ||i.UART_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  UART_DMAReceiveCplt PROC
;;;2452     */
;;;2453   static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2454   {
000002  4601              MOV      r1,r0
;;;2455     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)(hdma->Parent);
;;;2456   
;;;2457     /* DMA Normal mode */
;;;2458     if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
000004  6809              LDR      r1,[r1,#0]
000006  6a80              LDR      r0,[r0,#0x28]         ;2455
000008  6809              LDR      r1,[r1,#0]
00000a  0689              LSLS     r1,r1,#26
00000c  d414              BMI      |L42.56|
;;;2459     {
;;;2460       huart->RxXferCount = 0U;
00000e  2200              MOVS     r2,#0
000010  215a              MOVS     r1,#0x5a
000012  520a              STRH     r2,[r1,r0]
;;;2461   
;;;2462       /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2463       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
000014  6801              LDR      r1,[r0,#0]
000016  680a              LDR      r2,[r1,#0]
000018  23ff              MOVS     r3,#0xff
00001a  3301              ADDS     r3,#1
00001c  439a              BICS     r2,r2,r3
00001e  600a              STR      r2,[r1,#0]
;;;2464       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000020  6801              LDR      r1,[r0,#0]
000022  688a              LDR      r2,[r1,#8]
000024  0852              LSRS     r2,r2,#1
000026  0052              LSLS     r2,r2,#1
000028  608a              STR      r2,[r1,#8]
;;;2465   
;;;2466       /* Disable the DMA transfer for the receiver request by resetting the DMAR bit
;;;2467          in the UART CR3 register */
;;;2468       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
00002a  6801              LDR      r1,[r0,#0]
00002c  688a              LDR      r2,[r1,#8]
00002e  2340              MOVS     r3,#0x40
000030  439a              BICS     r2,r2,r3
000032  608a              STR      r2,[r1,#8]
;;;2469   
;;;2470       /* At end of Rx process, restore huart->RxState to Ready */
;;;2471       huart->RxState = HAL_UART_STATE_READY;
000034  2120              MOVS     r1,#0x20
000036  6701              STR      r1,[r0,#0x70]
                  |L42.56|
;;;2472     }
;;;2473   
;;;2474     HAL_UART_RxCpltCallback(huart);
000038  f7fffffe          BL       HAL_UART_RxCpltCallback
;;;2475   }
00003c  bd10              POP      {r4,pc}
;;;2476   
                          ENDP


                          AREA ||i.UART_DMARxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxAbortCallback PROC
;;;2582     */
;;;2583   static void UART_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2584   {
;;;2585     UART_HandleTypeDef* huart = (UART_HandleTypeDef* )(hdma->Parent);
000002  6a80              LDR      r0,[r0,#0x28]
;;;2586     
;;;2587     huart->hdmarx->XferAbortCallback = NULL;
000004  2100              MOVS     r1,#0
000006  6e42              LDR      r2,[r0,#0x64]
;;;2588   
;;;2589     /* Check if an Abort process is still ongoing */
;;;2590     if(huart->hdmatx != NULL)
000008  6391              STR      r1,[r2,#0x38]
00000a  6e02              LDR      r2,[r0,#0x60]
00000c  2a00              CMP      r2,#0
00000e  d002              BEQ      |L43.22|
;;;2591     {
;;;2592       if(huart->hdmatx->XferAbortCallback != NULL)
000010  6b92              LDR      r2,[r2,#0x38]
000012  2a00              CMP      r2,#0
000014  d10c              BNE      |L43.48|
                  |L43.22|
;;;2593       {
;;;2594         return;
;;;2595       }
;;;2596     }
;;;2597     
;;;2598     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;2599     huart->TxXferCount = 0U;
000016  4602              MOV      r2,r0
000018  3240              ADDS     r2,r2,#0x40
00001a  8251              STRH     r1,[r2,#0x12]
;;;2600     huart->RxXferCount = 0U;
00001c  8351              STRH     r1,[r2,#0x1a]
;;;2601   
;;;2602     /* Reset errorCode */
;;;2603     huart->ErrorCode = HAL_UART_ERROR_NONE;
00001e  6741              STR      r1,[r0,#0x74]
;;;2604   
;;;2605     /* Clear the Error flags in the ICR register */
;;;2606     __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
000020  6802              LDR      r2,[r0,#0]
000022  210f              MOVS     r1,#0xf
000024  6211              STR      r1,[r2,#0x20]
;;;2607   
;;;2608     /* Restore huart->gState and huart->RxState to Ready */
;;;2609     huart->gState  = HAL_UART_STATE_READY;
000026  2120              MOVS     r1,#0x20
000028  66c1              STR      r1,[r0,#0x6c]
;;;2610     huart->RxState = HAL_UART_STATE_READY;
00002a  6701              STR      r1,[r0,#0x70]
;;;2611   
;;;2612     /* Call user Abort complete callback */
;;;2613     HAL_UART_AbortCpltCallback(huart);
00002c  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L43.48|
;;;2614   }
000030  bd10              POP      {r4,pc}
;;;2615   
                          ENDP


                          AREA ||i.UART_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMARxHalfCplt PROC
;;;2481     */
;;;2482   static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2483   {
;;;2484     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)(hdma->Parent);
000002  6a80              LDR      r0,[r0,#0x28]
;;;2485   
;;;2486     HAL_UART_RxHalfCpltCallback(huart);
000004  f7fffffe          BL       HAL_UART_RxHalfCpltCallback
;;;2487   }
000008  bd10              POP      {r4,pc}
;;;2488   
                          ENDP


                          AREA ||i.UART_DMARxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxOnlyAbortCallback PROC
;;;2645     */
;;;2646   static void UART_DMARxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2647   {
;;;2648     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a80              LDR      r0,[r0,#0x28]
;;;2649   
;;;2650     huart->RxXferCount = 0U;
000004  2200              MOVS     r2,#0
000006  215a              MOVS     r1,#0x5a
000008  520a              STRH     r2,[r1,r0]
;;;2651   
;;;2652     /* Clear the Error flags in the ICR register */
;;;2653     __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
00000a  6802              LDR      r2,[r0,#0]
00000c  210f              MOVS     r1,#0xf
00000e  6211              STR      r1,[r2,#0x20]
;;;2654   
;;;2655     /* Restore huart->RxState to Ready */
;;;2656     huart->RxState = HAL_UART_STATE_READY;
000010  2120              MOVS     r1,#0x20
000012  6701              STR      r1,[r0,#0x70]
;;;2657   
;;;2658     /* Call user Abort complete callback */
;;;2659     HAL_UART_AbortReceiveCpltCallback(huart);
000014  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
;;;2660   }
000018  bd10              POP      {r4,pc}
;;;2661   
                          ENDP


                          AREA ||i.UART_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATransmitCplt PROC
;;;2411     */
;;;2412   static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2413   {
000002  4601              MOV      r1,r0
;;;2414     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)(hdma->Parent);
;;;2415     
;;;2416     /* DMA Normal mode */
;;;2417     if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
000004  6809              LDR      r1,[r1,#0]
000006  6a80              LDR      r0,[r0,#0x28]         ;2414
000008  6809              LDR      r1,[r1,#0]
00000a  0689              LSLS     r1,r1,#26
00000c  d40d              BMI      |L46.42|
;;;2418     {
;;;2419       huart->TxXferCount = 0;
00000e  2200              MOVS     r2,#0
000010  2152              MOVS     r1,#0x52
000012  520a              STRH     r2,[r1,r0]
;;;2420   
;;;2421       /* Disable the DMA transfer for transmit request by resetting the DMAT bit
;;;2422          in the UART CR3 register */
;;;2423       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000014  6801              LDR      r1,[r0,#0]
000016  688a              LDR      r2,[r1,#8]
000018  2380              MOVS     r3,#0x80
00001a  439a              BICS     r2,r2,r3
00001c  608a              STR      r2,[r1,#8]
;;;2424   
;;;2425       /* Enable the UART Transmit Complete Interrupt */
;;;2426       SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
00001e  6800              LDR      r0,[r0,#0]
000020  6801              LDR      r1,[r0,#0]
000022  2240              MOVS     r2,#0x40
000024  4311              ORRS     r1,r1,r2
000026  6001              STR      r1,[r0,#0]
;;;2427     }
;;;2428     /* DMA Circular mode */
;;;2429     else
;;;2430     {
;;;2431       HAL_UART_TxCpltCallback(huart);
;;;2432     }
;;;2433   
;;;2434   }
000028  bd10              POP      {r4,pc}
                  |L46.42|
00002a  f7fffffe          BL       HAL_UART_TxCpltCallback
00002e  bd10              POP      {r4,pc}
;;;2435   
                          ENDP


                          AREA ||i.UART_DMATxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxAbortCallback PROC
;;;2540     */
;;;2541   static void UART_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2542   {
;;;2543     UART_HandleTypeDef* huart = (UART_HandleTypeDef* )(hdma->Parent);
000002  6a80              LDR      r0,[r0,#0x28]
;;;2544     
;;;2545     huart->hdmatx->XferAbortCallback = NULL;
000004  2100              MOVS     r1,#0
000006  6e02              LDR      r2,[r0,#0x60]
;;;2546   
;;;2547     /* Check if an Abort process is still ongoing */
;;;2548     if(huart->hdmarx != NULL)
000008  6391              STR      r1,[r2,#0x38]
00000a  6e42              LDR      r2,[r0,#0x64]
00000c  2a00              CMP      r2,#0
00000e  d002              BEQ      |L47.22|
;;;2549     {
;;;2550       if(huart->hdmarx->XferAbortCallback != NULL)
000010  6b92              LDR      r2,[r2,#0x38]
000012  2a00              CMP      r2,#0
000014  d10c              BNE      |L47.48|
                  |L47.22|
;;;2551       {
;;;2552         return;
;;;2553       }
;;;2554     }
;;;2555     
;;;2556     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;2557     huart->TxXferCount = 0U;
000016  4602              MOV      r2,r0
000018  3240              ADDS     r2,r2,#0x40
00001a  8251              STRH     r1,[r2,#0x12]
;;;2558     huart->RxXferCount = 0U;
00001c  8351              STRH     r1,[r2,#0x1a]
;;;2559   
;;;2560     /* Reset errorCode */
;;;2561     huart->ErrorCode = HAL_UART_ERROR_NONE;
00001e  6741              STR      r1,[r0,#0x74]
;;;2562   
;;;2563     /* Clear the Error flags in the ICR register */
;;;2564     __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
000020  6802              LDR      r2,[r0,#0]
000022  210f              MOVS     r1,#0xf
000024  6211              STR      r1,[r2,#0x20]
;;;2565   
;;;2566     /* Restore huart->gState and huart->RxState to Ready */
;;;2567     huart->gState  = HAL_UART_STATE_READY;
000026  2120              MOVS     r1,#0x20
000028  66c1              STR      r1,[r0,#0x6c]
;;;2568     huart->RxState = HAL_UART_STATE_READY;
00002a  6701              STR      r1,[r0,#0x70]
;;;2569   
;;;2570     /* Call user Abort complete callback */
;;;2571     HAL_UART_AbortCpltCallback(huart);
00002c  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L47.48|
;;;2572   }
000030  bd10              POP      {r4,pc}
;;;2573   
                          ENDP


                          AREA ||i.UART_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATxHalfCplt PROC
;;;2440     */
;;;2441   static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2442   {
;;;2443     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)(hdma->Parent);
000002  6a80              LDR      r0,[r0,#0x28]
;;;2444   
;;;2445     HAL_UART_TxHalfCpltCallback(huart);
000004  f7fffffe          BL       HAL_UART_TxHalfCpltCallback
;;;2446   }
000008  bd10              POP      {r4,pc}
;;;2447   
                          ENDP


                          AREA ||i.UART_DMATxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxOnlyAbortCallback PROC
;;;2624     */
;;;2625   static void UART_DMATxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2626   {
;;;2627     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)(hdma->Parent);
000002  6a80              LDR      r0,[r0,#0x28]
;;;2628   
;;;2629     huart->TxXferCount = 0U;
000004  2200              MOVS     r2,#0
000006  2152              MOVS     r1,#0x52
000008  520a              STRH     r2,[r1,r0]
;;;2630   
;;;2631     /* Restore huart->gState to Ready */
;;;2632     huart->gState = HAL_UART_STATE_READY;
00000a  2120              MOVS     r1,#0x20
00000c  66c1              STR      r1,[r0,#0x6c]
;;;2633   
;;;2634     /* Call user Abort complete callback */
;;;2635     HAL_UART_AbortTransmitCpltCallback(huart);
00000e  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
;;;2636   }
000012  bd10              POP      {r4,pc}
;;;2637   
                          ENDP


                          AREA ||i.UART_EndTransmit_IT||, CODE, READONLY, ALIGN=1

                  UART_EndTransmit_IT PROC
;;;2714     */
;;;2715   HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;2716   {
;;;2717     /* Disable the UART Transmit Complete Interrupt */
;;;2718     CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
000002  6801              LDR      r1,[r0,#0]
000004  680a              LDR      r2,[r1,#0]
000006  2340              MOVS     r3,#0x40
000008  439a              BICS     r2,r2,r3
00000a  600a              STR      r2,[r1,#0]
;;;2719   
;;;2720     /* Tx process is ended, restore huart->gState to Ready */
;;;2721     huart->gState = HAL_UART_STATE_READY;
00000c  2120              MOVS     r1,#0x20
00000e  66c1              STR      r1,[r0,#0x6c]
;;;2722   
;;;2723     HAL_UART_TxCpltCallback(huart);
000010  f7fffffe          BL       HAL_UART_TxCpltCallback
;;;2724   
;;;2725     return HAL_OK;
000014  2000              MOVS     r0,#0
;;;2726   }
000016  bd10              POP      {r4,pc}
;;;2727   
                          ENDP


                          AREA ||i.UART_Receive_IT||, CODE, READONLY, ALIGN=1

                  UART_Receive_IT PROC
;;;2734     */
;;;2735   HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;2736   {
;;;2737     uint16_t* tmp;
;;;2738     uint16_t  uhMask = huart->Mask;
000002  4602              MOV      r2,r0
000004  3240              ADDS     r2,r2,#0x40
000006  8b93              LDRH     r3,[r2,#0x1c]
;;;2739     uint16_t  uhdata;
;;;2740   
;;;2741     /* Check that a Rx process is ongoing */
;;;2742     if(huart->RxState == HAL_UART_STATE_BUSY_RX)
000008  6f04              LDR      r4,[r0,#0x70]
00000a  6801              LDR      r1,[r0,#0]
00000c  2c22              CMP      r4,#0x22
00000e  d005              BEQ      |L51.28|
;;;2743     {
;;;2744       uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
;;;2745       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;2746       {
;;;2747         tmp = (uint16_t*) huart->pRxBuffPtr ;
;;;2748         *tmp = (uint16_t)(uhdata & uhMask);
;;;2749         huart->pRxBuffPtr +=2U;
;;;2750       }
;;;2751       else
;;;2752       {
;;;2753         *huart->pRxBuffPtr++ = (uint8_t)(uhdata & (uint8_t)uhMask);
;;;2754       }
;;;2755   
;;;2756       if(--huart->RxXferCount == 0U)
;;;2757       {
;;;2758         /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
;;;2759         CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
;;;2760   
;;;2761         /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;2762         CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;2763   
;;;2764         /* Rx process is completed, restore huart->RxState to Ready */
;;;2765         huart->RxState = HAL_UART_STATE_READY;
;;;2766   
;;;2767         HAL_UART_RxCpltCallback(huart);
;;;2768   
;;;2769         return HAL_OK;
;;;2770       }
;;;2771   
;;;2772       return HAL_OK;
;;;2773     }
;;;2774     else
;;;2775     {
;;;2776       /* Clear RXNE interrupt flag */
;;;2777       __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
000010  6988              LDR      r0,[r1,#0x18]
000012  2208              MOVS     r2,#8
000014  4310              ORRS     r0,r0,r2
000016  6188              STR      r0,[r1,#0x18]
;;;2778   
;;;2779       return HAL_BUSY;
000018  2002              MOVS     r0,#2
;;;2780     }
;;;2781   }
00001a  bd70              POP      {r4-r6,pc}
                  |L51.28|
00001c  8c89              LDRH     r1,[r1,#0x24]         ;2744
00001e  2501              MOVS     r5,#1                 ;2745
000020  6884              LDR      r4,[r0,#8]            ;2745
000022  032d              LSLS     r5,r5,#12             ;2745
000024  42ac              CMP      r4,r5                 ;2745
000026  d102              BNE      |L51.46|
000028  6904              LDR      r4,[r0,#0x10]         ;2745
00002a  2c00              CMP      r4,#0                 ;2745
00002c  d00c              BEQ      |L51.72|
                  |L51.46|
00002e  4019              ANDS     r1,r1,r3              ;2753
000030  6d43              LDR      r3,[r0,#0x54]         ;2753
000032  1c5c              ADDS     r4,r3,#1              ;2753
000034  6544              STR      r4,[r0,#0x54]         ;2753
000036  7019              STRB     r1,[r3,#0]            ;2753
                  |L51.56|
000038  8b51              LDRH     r1,[r2,#0x1a]         ;2756
00003a  1e49              SUBS     r1,r1,#1              ;2756
00003c  0409              LSLS     r1,r1,#16             ;2756
00003e  0c09              LSRS     r1,r1,#16             ;2756
000040  8351              STRH     r1,[r2,#0x1a]         ;2756
000042  d008              BEQ      |L51.86|
000044  2000              MOVS     r0,#0                 ;2772
000046  bd70              POP      {r4-r6,pc}
                  |L51.72|
000048  6d44              LDR      r4,[r0,#0x54]         ;2748
00004a  4019              ANDS     r1,r1,r3              ;2748
00004c  8021              STRH     r1,[r4,#0]            ;2748
00004e  6d41              LDR      r1,[r0,#0x54]         ;2749
000050  1c89              ADDS     r1,r1,#2              ;2749
000052  6541              STR      r1,[r0,#0x54]         ;2749
000054  e7f0              B        |L51.56|
                  |L51.86|
000056  6801              LDR      r1,[r0,#0]            ;2759
000058  680a              LDR      r2,[r1,#0]            ;2759
00005a  23ff              MOVS     r3,#0xff              ;2759
00005c  3321              ADDS     r3,r3,#0x21           ;2759
00005e  439a              BICS     r2,r2,r3              ;2759
000060  600a              STR      r2,[r1,#0]            ;2759
000062  6801              LDR      r1,[r0,#0]            ;2762
000064  688a              LDR      r2,[r1,#8]            ;2762
000066  0852              LSRS     r2,r2,#1              ;2762
000068  0052              LSLS     r2,r2,#1              ;2762
00006a  608a              STR      r2,[r1,#8]            ;2762
00006c  2120              MOVS     r1,#0x20              ;2765
00006e  6701              STR      r1,[r0,#0x70]         ;2765
000070  f7fffffe          BL       HAL_UART_RxCpltCallback
000074  2000              MOVS     r0,#0                 ;2769
000076  bd70              POP      {r4-r6,pc}
;;;2782   
                          ENDP


                          AREA ||i.UART_SetConfig||, CODE, READONLY, ALIGN=2

                  UART_SetConfig PROC
;;;2108     */
;;;2109   HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2110   {
000002  4604              MOV      r4,r0
;;;2111     uint32_t tmpreg                     = 0x00000000U;
;;;2112     UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
;;;2113     uint16_t brrtemp                    = 0x0000U;
;;;2114     uint16_t usartdiv                   = 0x0000U;
;;;2115     HAL_StatusTypeDef ret               = HAL_OK;
;;;2116   
;;;2117     /* Check the parameters */
;;;2118     assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
;;;2119     assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;2120     assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
;;;2121     assert_param(IS_UART_PARITY(huart->Init.Parity));
;;;2122     assert_param(IS_UART_MODE(huart->Init.Mode));
;;;2123     assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
;;;2124     assert_param(IS_UART_ONE_BIT_SAMPLE(huart->Init.OneBitSampling));
;;;2125     assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;2126   
;;;2127   
;;;2128     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;2129     /* Clear M, PCE, PS, TE, RE and OVER8 bits and configure
;;;2130      *  the UART Word Length, Parity, Mode and oversampling:
;;;2131      *  set the M bits according to huart->Init.WordLength value
;;;2132      *  set PCE and PS bits according to huart->Init.Parity value
;;;2133      *  set TE and RE bits according to huart->Init.Mode value
;;;2134      *  set OVER8 bit according to huart->Init.OverSampling value */
;;;2135     tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
000004  6923              LDR      r3,[r4,#0x10]
000006  68a2              LDR      r2,[r4,#8]
000008  69e6              LDR      r6,[r4,#0x1c]
00000a  431a              ORRS     r2,r2,r3
00000c  6963              LDR      r3,[r4,#0x14]
00000e  2110              MOVS     r1,#0x10              ;2112
000010  4333              ORRS     r3,r3,r6
000012  2000              MOVS     r0,#0                 ;2114
;;;2136     MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
000014  6826              LDR      r6,[r4,#0]
000016  431a              ORRS     r2,r2,r3              ;2135
000018  6833              LDR      r3,[r6,#0]
00001a  4605              MOV      r5,r0                 ;2115
00001c  4f4b              LDR      r7,|L52.332|
00001e  403b              ANDS     r3,r3,r7
000020  4313              ORRS     r3,r3,r2
000022  6033              STR      r3,[r6,#0]
;;;2137   
;;;2138     /*-------------------------- USART CR2 Configuration -----------------------*/
;;;2139     /* Configure the UART Stop Bits: Set STOP[13:12] bits according
;;;2140      * to huart->Init.StopBits value */
;;;2141     MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
000024  6823              LDR      r3,[r4,#0]
000026  685a              LDR      r2,[r3,#4]
000028  2603              MOVS     r6,#3
00002a  0336              LSLS     r6,r6,#12
00002c  43b2              BICS     r2,r2,r6
00002e  68e6              LDR      r6,[r4,#0xc]
000030  4332              ORRS     r2,r2,r6
000032  605a              STR      r2,[r3,#4]
;;;2142   
;;;2143     /*-------------------------- USART CR3 Configuration -----------------------*/
;;;2144     /* Configure
;;;2145      * - UART HardWare Flow Control: set CTSE and RTSE bits according
;;;2146      *   to huart->Init.HwFlowCtl value
;;;2147      * - one-bit sampling method versus three samples' majority rule according
;;;2148      *   to huart->Init.OneBitSampling */
;;;2149     tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
000034  6a23              LDR      r3,[r4,#0x20]
000036  69a2              LDR      r2,[r4,#0x18]
;;;2150     MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
000038  6826              LDR      r6,[r4,#0]
00003a  431a              ORRS     r2,r2,r3              ;2149
00003c  68b3              LDR      r3,[r6,#8]
00003e  270b              MOVS     r7,#0xb
000040  023f              LSLS     r7,r7,#8
000042  43bb              BICS     r3,r3,r7
000044  4313              ORRS     r3,r3,r2
000046  60b3              STR      r3,[r6,#8]
;;;2151   
;;;2152     /*-------------------------- USART BRR Configuration -----------------------*/
;;;2153     UART_GETCLOCKSOURCE(huart, clocksource);
000048  4a41              LDR      r2,|L52.336|
00004a  6b12              LDR      r2,[r2,#0x30]
00004c  0792              LSLS     r2,r2,#30
00004e  0f92              LSRS     r2,r2,#30
000050  d006              BEQ      |L52.96|
000052  2a01              CMP      r2,#1
000054  d008              BEQ      |L52.104|
000056  2a02              CMP      r2,#2
000058  d008              BEQ      |L52.108|
00005a  2a03              CMP      r2,#3
00005c  d107              BNE      |L52.110|
00005e  e001              B        |L52.100|
                  |L52.96|
000060  2100              MOVS     r1,#0
000062  e004              B        |L52.110|
                  |L52.100|
000064  2102              MOVS     r1,#2
000066  e002              B        |L52.110|
                  |L52.104|
000068  2104              MOVS     r1,#4
00006a  e000              B        |L52.110|
                  |L52.108|
00006c  2108              MOVS     r1,#8
                  |L52.110|
;;;2154     
;;;2155     /* Check UART Over Sampling to set Baud Rate Register */
;;;2156     if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
00006e  2201              MOVS     r2,#1
000070  69e3              LDR      r3,[r4,#0x1c]
000072  03d2              LSLS     r2,r2,#15
000074  4293              CMP      r3,r2
000076  d135              BNE      |L52.228|
;;;2157     {
;;;2158       switch (clocksource)
000078  2900              CMP      r1,#0
00007a  d00e              BEQ      |L52.154|
00007c  2902              CMP      r1,#2
00007e  d016              BEQ      |L52.174|
000080  2904              CMP      r1,#4
000082  d01c              BEQ      |L52.190|
000084  2908              CMP      r1,#8
000086  d024              BEQ      |L52.210|
;;;2159       {
;;;2160         case UART_CLOCKSOURCE_PCLK1:
;;;2161           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
;;;2162           break;
;;;2163         case UART_CLOCKSOURCE_HSI:
;;;2164           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
;;;2165           break;
;;;2166         case UART_CLOCKSOURCE_SYSCLK:
;;;2167           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
;;;2168           break;
;;;2169         case UART_CLOCKSOURCE_LSE:
;;;2170           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
;;;2171           break;
;;;2172         case UART_CLOCKSOURCE_UNDEFINED:
;;;2173         default:
;;;2174           ret = HAL_ERROR;
000088  2501              MOVS     r5,#1
                  |L52.138|
;;;2175           break;
;;;2176       }
;;;2177   
;;;2178       brrtemp = usartdiv & 0xFFF0U;
00008a  0901              LSRS     r1,r0,#4
00008c  0109              LSLS     r1,r1,#4
;;;2179       brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
00008e  0700              LSLS     r0,r0,#28
000090  0f40              LSRS     r0,r0,#29
000092  4308              ORRS     r0,r0,r1
;;;2180       huart->Instance->BRR = brrtemp;
000094  6821              LDR      r1,[r4,#0]
000096  60c8              STR      r0,[r1,#0xc]
000098  e02d              B        |L52.246|
                  |L52.154|
00009a  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
00009e  6861              LDR      r1,[r4,#4]            ;2161
0000a0  0040              LSLS     r0,r0,#1              ;2161
0000a2  084a              LSRS     r2,r1,#1              ;2161
0000a4  1880              ADDS     r0,r0,r2              ;2161
0000a6  f7fffffe          BL       __aeabi_uidivmod
0000aa  b280              UXTH     r0,r0                 ;2161
0000ac  e7ed              B        |L52.138|
                  |L52.174|
0000ae  6861              LDR      r1,[r4,#4]            ;2164
0000b0  4a28              LDR      r2,|L52.340|
0000b2  0848              LSRS     r0,r1,#1              ;2164
0000b4  1880              ADDS     r0,r0,r2              ;2164
0000b6  f7fffffe          BL       __aeabi_uidivmod
0000ba  b280              UXTH     r0,r0                 ;2164
0000bc  e7e5              B        |L52.138|
                  |L52.190|
0000be  f7fffffe          BL       HAL_RCC_GetSysClockFreq
0000c2  6861              LDR      r1,[r4,#4]            ;2167
0000c4  0040              LSLS     r0,r0,#1              ;2167
0000c6  084a              LSRS     r2,r1,#1              ;2167
0000c8  1880              ADDS     r0,r0,r2              ;2167
0000ca  f7fffffe          BL       __aeabi_uidivmod
0000ce  b280              UXTH     r0,r0                 ;2167
0000d0  e7db              B        |L52.138|
                  |L52.210|
0000d2  6861              LDR      r1,[r4,#4]            ;2170
0000d4  2201              MOVS     r2,#1                 ;2170
0000d6  0848              LSRS     r0,r1,#1              ;2170
0000d8  0412              LSLS     r2,r2,#16             ;2170
0000da  1880              ADDS     r0,r0,r2              ;2170
0000dc  f7fffffe          BL       __aeabi_uidivmod
0000e0  b280              UXTH     r0,r0                 ;2170
0000e2  e7d2              B        |L52.138|
                  |L52.228|
;;;2181     }
;;;2182     else
;;;2183     {
;;;2184       switch (clocksource)
0000e4  2900              CMP      r1,#0
0000e6  d008              BEQ      |L52.250|
0000e8  2902              CMP      r1,#2
0000ea  d011              BEQ      |L52.272|
0000ec  2904              CMP      r1,#4
0000ee  d019              BEQ      |L52.292|
0000f0  2908              CMP      r1,#8
0000f2  d022              BEQ      |L52.314|
;;;2185       {
;;;2186         case UART_CLOCKSOURCE_PCLK1:
;;;2187           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
;;;2188           break;
;;;2189         case UART_CLOCKSOURCE_HSI:
;;;2190           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
;;;2191           break;
;;;2192         case UART_CLOCKSOURCE_SYSCLK:
;;;2193           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
;;;2194           break;
;;;2195         case UART_CLOCKSOURCE_LSE:
;;;2196           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
;;;2197           break;
;;;2198         case UART_CLOCKSOURCE_UNDEFINED:
;;;2199         default:
;;;2200           ret = HAL_ERROR;
0000f4  2501              MOVS     r5,#1
                  |L52.246|
;;;2201           break;
;;;2202       }
;;;2203     }
;;;2204   
;;;2205     return ret;
0000f6  4628              MOV      r0,r5
;;;2206   
;;;2207   }
0000f8  bdf8              POP      {r3-r7,pc}
                  |L52.250|
0000fa  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0000fe  6861              LDR      r1,[r4,#4]            ;2187
000100  084a              LSRS     r2,r1,#1              ;2187
000102  1880              ADDS     r0,r0,r2              ;2187
000104  f7fffffe          BL       __aeabi_uidivmod
000108  6821              LDR      r1,[r4,#0]            ;2187
00010a  b280              UXTH     r0,r0                 ;2187
00010c  60c8              STR      r0,[r1,#0xc]          ;2187
00010e  e7f2              B        |L52.246|
                  |L52.272|
000110  6861              LDR      r1,[r4,#4]            ;2190
000112  4a11              LDR      r2,|L52.344|
000114  0848              LSRS     r0,r1,#1              ;2190
000116  1880              ADDS     r0,r0,r2              ;2190
000118  f7fffffe          BL       __aeabi_uidivmod
00011c  6821              LDR      r1,[r4,#0]            ;2190
00011e  b280              UXTH     r0,r0                 ;2190
000120  60c8              STR      r0,[r1,#0xc]          ;2190
000122  e7e8              B        |L52.246|
                  |L52.292|
000124  f7fffffe          BL       HAL_RCC_GetSysClockFreq
000128  6861              LDR      r1,[r4,#4]            ;2193
00012a  084a              LSRS     r2,r1,#1              ;2193
00012c  1880              ADDS     r0,r0,r2              ;2193
00012e  f7fffffe          BL       __aeabi_uidivmod
000132  6821              LDR      r1,[r4,#0]            ;2193
000134  b280              UXTH     r0,r0                 ;2193
000136  60c8              STR      r0,[r1,#0xc]          ;2193
000138  e7dd              B        |L52.246|
                  |L52.314|
00013a  6861              LDR      r1,[r4,#4]            ;2196
00013c  0848              LSRS     r0,r1,#1              ;2196
00013e  1880              ADDS     r0,r0,r2              ;2196
000140  f7fffffe          BL       __aeabi_uidivmod
000144  6821              LDR      r1,[r4,#0]            ;2196
000146  b280              UXTH     r0,r0                 ;2196
000148  60c8              STR      r0,[r1,#0xc]          ;2196
00014a  e7d4              B        |L52.246|
;;;2208   
                          ENDP

                  |L52.332|
                          DCD      0xffff69f3
                  |L52.336|
                          DCD      0x40021000
                  |L52.340|
                          DCD      0x00f42400
                  |L52.344|
                          DCD      0x007a1200

                          AREA ||i.UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  UART_Transmit_IT PROC
;;;2668     */
;;;2669   HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
000000  6ec1              LDR      r1,[r0,#0x6c]
;;;2670   {
;;;2671     uint16_t* tmp;
;;;2672   
;;;2673     /* Check that a Tx process is ongoing */
;;;2674     if (huart->gState == HAL_UART_STATE_BUSY_TX)
000002  2921              CMP      r1,#0x21
000004  d001              BEQ      |L53.10|
;;;2675     {
;;;2676       if(huart->TxXferCount == 0U)
;;;2677       {
;;;2678         /* Disable the UART Transmit Data Register Empty Interrupt */
;;;2679         CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
;;;2680   
;;;2681         /* Enable the UART Transmit Complete Interrupt */
;;;2682         SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
;;;2683   
;;;2684         return HAL_OK;
;;;2685       }
;;;2686       else
;;;2687       {
;;;2688         if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;2689         {
;;;2690           tmp = (uint16_t*) huart->pTxBuffPtr;
;;;2691           huart->Instance->TDR = (*tmp & (uint16_t)0x01FFU);
;;;2692           huart->pTxBuffPtr += 2U;
;;;2693         }
;;;2694         else
;;;2695         {
;;;2696           huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0xFFU);
;;;2697         }
;;;2698         huart->TxXferCount--;
;;;2699   
;;;2700         return HAL_OK;
;;;2701       }
;;;2702     }
;;;2703     else
;;;2704     {
;;;2705       return HAL_BUSY;
000006  2002              MOVS     r0,#2
;;;2706     }
;;;2707   }
000008  4770              BX       lr
                  |L53.10|
00000a  4602              MOV      r2,r0                 ;2676
00000c  3240              ADDS     r2,r2,#0x40           ;2676
00000e  8a51              LDRH     r1,[r2,#0x12]         ;2676
000010  2900              CMP      r1,#0                 ;2676
000012  d012              BEQ      |L53.58|
000014  2301              MOVS     r3,#1                 ;2688
000016  6881              LDR      r1,[r0,#8]            ;2688
000018  031b              LSLS     r3,r3,#12             ;2688
00001a  4299              CMP      r1,r3                 ;2688
00001c  d102              BNE      |L53.36|
00001e  6901              LDR      r1,[r0,#0x10]         ;2688
000020  2900              CMP      r1,#0                 ;2688
000022  d015              BEQ      |L53.80|
                  |L53.36|
000024  6cc1              LDR      r1,[r0,#0x4c]         ;2696
000026  1c4b              ADDS     r3,r1,#1              ;2696
000028  64c3              STR      r3,[r0,#0x4c]         ;2696
00002a  6800              LDR      r0,[r0,#0]            ;2696
00002c  7809              LDRB     r1,[r1,#0]            ;2696
00002e  8501              STRH     r1,[r0,#0x28]         ;2696
                  |L53.48|
000030  8a50              LDRH     r0,[r2,#0x12]         ;2698
000032  1e40              SUBS     r0,r0,#1              ;2698
000034  8250              STRH     r0,[r2,#0x12]         ;2698
                  |L53.54|
000036  2000              MOVS     r0,#0                 ;2700
000038  4770              BX       lr
                  |L53.58|
00003a  6801              LDR      r1,[r0,#0]            ;2679
00003c  680a              LDR      r2,[r1,#0]            ;2679
00003e  2380              MOVS     r3,#0x80              ;2679
000040  439a              BICS     r2,r2,r3              ;2679
000042  600a              STR      r2,[r1,#0]            ;2679
000044  6800              LDR      r0,[r0,#0]            ;2682
000046  6801              LDR      r1,[r0,#0]            ;2682
000048  2240              MOVS     r2,#0x40              ;2682
00004a  4311              ORRS     r1,r1,r2              ;2682
00004c  6001              STR      r1,[r0,#0]            ;2682
00004e  e7f2              B        |L53.54|
                  |L53.80|
000050  6cc1              LDR      r1,[r0,#0x4c]         ;2691
000052  6803              LDR      r3,[r0,#0]            ;2691
000054  8809              LDRH     r1,[r1,#0]            ;2691
000056  05c9              LSLS     r1,r1,#23             ;2691
000058  0dc9              LSRS     r1,r1,#23             ;2691
00005a  8519              STRH     r1,[r3,#0x28]         ;2691
00005c  6cc1              LDR      r1,[r0,#0x4c]         ;2692
00005e  1c89              ADDS     r1,r1,#2              ;2692
000060  64c1              STR      r1,[r0,#0x4c]         ;2692
000062  e7e5              B        |L53.48|
;;;2708   
                          ENDP


                          AREA ||i.UART_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  UART_WaitOnFlagUntilTimeout PROC
;;;2348     */
;;;2349   HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
000000  b5ff              PUSH     {r0-r7,lr}
;;;2350   {
000002  4604              MOV      r4,r0
;;;2351     /* Wait until flag is set */
;;;2352     while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
000004  6800              LDR      r0,[r0,#0]
000006  b081              SUB      sp,sp,#4              ;2350
000008  460d              MOV      r5,r1                 ;2350
00000a  9e0a              LDR      r6,[sp,#0x28]
00000c  69c1              LDR      r1,[r0,#0x1c]
00000e  4617              MOV      r7,r2                 ;2350
000010  4628              MOV      r0,r5
000012  4388              BICS     r0,r0,r1
000014  d01f              BEQ      |L54.86|
000016  2000              MOVS     r0,#0
                  |L54.24|
000018  42b8              CMP      r0,r7
00001a  d126              BNE      |L54.106|
                  |L54.28|
;;;2353     {
;;;2354       /* Check for the Timeout */
;;;2355       if(Timeout != HAL_MAX_DELAY)
00001c  1c70              ADDS     r0,r6,#1
00001e  d01c              BEQ      |L54.90|
;;;2356       {
;;;2357         if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
000020  2e00              CMP      r6,#0
000022  d005              BEQ      |L54.48|
000024  f7fffffe          BL       HAL_GetTick
000028  9904              LDR      r1,[sp,#0x10]
00002a  1a40              SUBS     r0,r0,r1
00002c  42b0              CMP      r0,r6
00002e  d914              BLS      |L54.90|
                  |L54.48|
;;;2358         {
;;;2359           /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;2360           CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
000030  6820              LDR      r0,[r4,#0]
000032  6801              LDR      r1,[r0,#0]
000034  22ff              MOVS     r2,#0xff
000036  32a1              ADDS     r2,r2,#0xa1
000038  4391              BICS     r1,r1,r2
00003a  6001              STR      r1,[r0,#0]
;;;2361           CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00003c  6820              LDR      r0,[r4,#0]
00003e  6881              LDR      r1,[r0,#8]
000040  0849              LSRS     r1,r1,#1
000042  0049              LSLS     r1,r1,#1
000044  6081              STR      r1,[r0,#8]
;;;2362   
;;;2363           huart->gState  = HAL_UART_STATE_READY;
000046  2020              MOVS     r0,#0x20
000048  66e0              STR      r0,[r4,#0x6c]
;;;2364           huart->RxState = HAL_UART_STATE_READY;
00004a  6720              STR      r0,[r4,#0x70]
;;;2365   
;;;2366           /* Process Unlocked */
;;;2367           __HAL_UNLOCK(huart);
00004c  2000              MOVS     r0,#0
;;;2368           return HAL_TIMEOUT;
00004e  66a0              STR      r0,[r4,#0x68]
000050  2003              MOVS     r0,#3
;;;2369         }
;;;2370       }
;;;2371     }
;;;2372     return HAL_OK;
;;;2373   }
000052  b005              ADD      sp,sp,#0x14
000054  bdf0              POP      {r4-r7,pc}
                  |L54.86|
000056  2001              MOVS     r0,#1                 ;2352
000058  e7de              B        |L54.24|
                  |L54.90|
00005a  6820              LDR      r0,[r4,#0]            ;2368
00005c  69c1              LDR      r1,[r0,#0x1c]         ;2368
00005e  4628              MOV      r0,r5                 ;2368
000060  4388              BICS     r0,r0,r1              ;2368
000062  d005              BEQ      |L54.112|
000064  2000              MOVS     r0,#0                 ;2368
                  |L54.102|
000066  42b8              CMP      r0,r7                 ;2368
000068  d0d8              BEQ      |L54.28|
                  |L54.106|
00006a  2000              MOVS     r0,#0                 ;2372
00006c  b005              ADD      sp,sp,#0x14
00006e  bdf0              POP      {r4-r7,pc}
                  |L54.112|
000070  2001              MOVS     r0,#1                 ;2368
000072  e7f8              B        |L54.102|
;;;2374   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F0_V1.9.0\\Drivers\\STM32F0xx_HAL_Driver\\Src\\stm32f0xx_hal_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f0xx_hal_uart_c_d497114f____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F0_V1.9.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___20_stm32f0xx_hal_uart_c_d497114f____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f0xx_hal_uart_c_d497114f____REVSH|
#line 402
|__asm___20_stm32f0xx_hal_uart_c_d497114f____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
