; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\kernel.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\kernel.d --cpu=Cortex-M0 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F0_V1.9.0\Drivers\STM32F0xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_F0_V1.9.0\Drivers\CMSIS\Device\ST\STM32L0xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F0_V1.9.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F0_V1.9.0\Drivers\STM32F0xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F030F4P6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F0xx_DFP\2.0.0\Drivers\CMSIS\Device\ST\STM32F0xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F030x6 -DSTM32F030x6 -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\kernel.crf ..\..\MProkaron\Kernel\kernel.c]
                          THUMB

                          AREA ||i.RMP_Clear||, CODE, READONLY, ALIGN=1

                  RMP_Clear PROC
;;;37     ******************************************************************************/
;;;38     void RMP_Clear(volatile void* Addr, ptr_t Size)
000000  b430              PUSH     {r4,r5}
;;;39     {
;;;40         ptr_t* Word_Inc;
;;;41         u8* Byte_Inc;
;;;42         ptr_t Words;
;;;43         ptr_t Bytes;
;;;44         
;;;45         /* On processors not that fast, copy by word is really important */
;;;46         Word_Inc=(ptr_t*)Addr;
;;;47         for(Words=Size/sizeof(ptr_t);Words>0;Words--)
000002  088d              LSRS     r5,r1,#2
000004  2400              MOVS     r4,#0
000006  2903              CMP      r1,#3
000008  d90d              BLS      |L1.38|
00000a  1f02              SUBS     r2,r0,#4
;;;48         {
;;;49             *Word_Inc=0;
;;;50             Word_Inc++;
;;;51         }
;;;52         
;;;53         /* Get the final bytes */
;;;54         Byte_Inc=(u8*)Word_Inc;
;;;55         for(Bytes=Size%sizeof(ptr_t);Bytes>0;Bytes--)
;;;56         {
;;;57             *Byte_Inc=0;
;;;58             Byte_Inc++;
;;;59         }
;;;60     }
00000c  07eb              LSLS     r3,r5,#31
00000e  d001              BEQ      |L1.20|
000010  6054              STR      r4,[r2,#4]            ;49
000012  1d12              ADDS     r2,r2,#4              ;49
                  |L1.20|
000014  106b              ASRS     r3,r5,#1              ;47
000016  d004              BEQ      |L1.34|
                  |L1.24|
000018  6054              STR      r4,[r2,#4]            ;49
00001a  6094              STR      r4,[r2,#8]            ;49
00001c  3208              ADDS     r2,r2,#8              ;49
00001e  1e5b              SUBS     r3,r3,#1              ;49
000020  d1fa              BNE      |L1.24|
                  |L1.34|
000022  00aa              LSLS     r2,r5,#2              ;49
000024  1810              ADDS     r0,r2,r0              ;51
                  |L1.38|
000026  078a              LSLS     r2,r1,#30             ;55
000028  0f92              LSRS     r2,r2,#30             ;55
00002a  0789              LSLS     r1,r1,#30             ;55
00002c  d00b              BEQ      |L1.70|
00002e  1e40              SUBS     r0,r0,#1              ;55
000030  07d1              LSLS     r1,r2,#31
000032  d001              BEQ      |L1.56|
000034  7044              STRB     r4,[r0,#1]            ;57
000036  1c40              ADDS     r0,r0,#1              ;57
                  |L1.56|
000038  0851              LSRS     r1,r2,#1              ;55
00003a  d004              BEQ      |L1.70|
                  |L1.60|
00003c  7044              STRB     r4,[r0,#1]            ;57
00003e  7084              STRB     r4,[r0,#2]            ;57
000040  1c80              ADDS     r0,r0,#2              ;57
000042  1e49              SUBS     r1,r1,#1              ;57
000044  d1fa              BNE      |L1.60|
                  |L1.70|
000046  bc30              POP      {r4,r5}
000048  4770              BX       lr
;;;61     /* End Function:RMP_Clear ****************************************************/
                          ENDP


                          AREA ||i.RMP_Free||, CODE, READONLY, ALIGN=1

                  RMP_Free PROC
;;;1996   ******************************************************************************/
;;;1997   void RMP_Free(volatile void* Pool, void* Mem_Ptr)
000000  4281              CMP      r1,r0
;;;1998   {
;;;1999       volatile struct RMP_Mem* Mem; 
;;;2000       volatile struct RMP_Mem_Head* Mem_Head;
;;;2001       volatile struct RMP_Mem_Head* Left_Head;
;;;2002       volatile struct RMP_Mem_Head* Right_Head;
;;;2003       cnt_t Merge_Left;
;;;2004   
;;;2005       /* See if the address is within the allocatable address range. If not, abort directly. */
;;;2006       Mem=(volatile struct RMP_Mem*)Pool;
;;;2007       if((((ptr_t)Mem_Ptr)<=((ptr_t)Mem))||(((ptr_t)Mem_Ptr)>=(((ptr_t)Mem)+Mem->Size)))
000002  d97d              BLS      |L2.256|
000004  b5f8              PUSH     {r3-r7,lr}            ;1998
000006  6902              LDR      r2,[r0,#0x10]
000008  4605              MOV      r5,r0                 ;1998
00000a  1950              ADDS     r0,r2,r5
00000c  4288              CMP      r0,r1
00000e  d94e              BLS      |L2.174|
;;;2008           return;
;;;2009   
;;;2010       Mem_Head=(struct RMP_Mem_Head*)(((ptr_t)Mem_Ptr)-sizeof(struct RMP_Mem_Head));
000010  460c              MOV      r4,r1
000012  3c10              SUBS     r4,r4,#0x10
;;;2011       /* See if the block can really be freed by this PID. If cannot, return directly */
;;;2012       if(Mem_Head->State==RMP_MEM_FREE)
000014  68a0              LDR      r0,[r4,#8]
000016  2800              CMP      r0,#0
000018  d049              BEQ      |L2.174|
;;;2013           return;
;;;2014   
;;;2015       /* Now we are sure that it can be freed. Delete it from the allocated list now */
;;;2016       RMP_List_Del(Mem_Head->Head.Prev,Mem_Head->Head.Next);
00001a  6821              LDR      r1,[r4,#0]
00001c  6860              LDR      r0,[r4,#4]
00001e  6001              STR      r1,[r0,#0]
000020  6048              STR      r0,[r1,#4]
;;;2017       Mem_Head->State=RMP_MEM_FREE;
000022  2000              MOVS     r0,#0
000024  60a0              STR      r0,[r4,#8]
;;;2018       
;;;2019       /* Now check if we can merge it with the higher blocks */
;;;2020       Right_Head=(struct RMP_Mem_Head*)(((ptr_t)(Mem_Head->Tail))+sizeof(struct RMP_Mem_Tail));
000026  68e6              LDR      r6,[r4,#0xc]
;;;2021       if(((ptr_t)Right_Head)!=(((ptr_t)Mem)+Mem->Size))
000028  6929              LDR      r1,[r5,#0x10]
00002a  1d36              ADDS     r6,r6,#4
00002c  1948              ADDS     r0,r1,r5
00002e  42b0              CMP      r0,r6
000030  d030              BEQ      |L2.148|
;;;2022       {
;;;2023           /* If this one is unoccupied */
;;;2024           if((Right_Head->State)==RMP_MEM_FREE)
000032  68b0              LDR      r0,[r6,#8]
000034  2800              CMP      r0,#0
000036  d12d              BNE      |L2.148|
000038  9500              STR      r5,[sp,#0]
00003a  68f0              LDR      r0,[r6,#0xc]
00003c  1b87              SUBS     r7,r0,r6
00003e  3f10              SUBS     r7,r7,#0x10
000040  4638              MOV      r0,r7
000042  f7fffffe          BL       RMP_MSB_Get
000046  1ec1              SUBS     r1,r0,#3
000048  40cf              LSRS     r7,r7,r1
00004a  0779              LSLS     r1,r7,#29
00004c  1f80              SUBS     r0,r0,#6
00004e  0f49              LSRS     r1,r1,#29
000050  00c0              LSLS     r0,r0,#3
000052  1840              ADDS     r0,r0,r1
000054  9900              LDR      r1,[sp,#0]
000056  00c2              LSLS     r2,r0,#3
000058  1853              ADDS     r3,r2,r1
00005a  6832              LDR      r2,[r6,#0]
00005c  6871              LDR      r1,[r6,#4]
00005e  600a              STR      r2,[r1,#0]
000060  6051              STR      r1,[r2,#4]
000062  6ad9              LDR      r1,[r3,#0x2c]
000064  3328              ADDS     r3,r3,#0x28
000066  4299              CMP      r1,r3
000068  d10a              BNE      |L2.128|
00006a  0941              LSRS     r1,r0,#5
00006c  008a              LSLS     r2,r1,#2
00006e  9900              LDR      r1,[sp,#0]
000070  1851              ADDS     r1,r2,r1
000072  694a              LDR      r2,[r1,#0x14]
000074  0703              LSLS     r3,r0,#28
000076  0f1b              LSRS     r3,r3,#28
000078  2001              MOVS     r0,#1
00007a  4098              LSLS     r0,r0,r3
00007c  4382              BICS     r2,r2,r0
00007e  614a              STR      r2,[r1,#0x14]
                  |L2.128|
;;;2025           {
;;;2026               /* Delete, merge */
;;;2027               _RMP_Mem_Del(Pool,Right_Head);
;;;2028               _RMP_Mem_Block(Mem_Head,
000080  68f0              LDR      r0,[r6,#0xc]
000082  1b00              SUBS     r0,r0,r4
000084  2100              MOVS     r1,#0
000086  60a1              STR      r1,[r4,#8]
000088  1d00              ADDS     r0,r0,#4
00008a  1820              ADDS     r0,r4,r0
00008c  1f00              SUBS     r0,r0,#4
00008e  60e0              STR      r0,[r4,#0xc]
000090  68e0              LDR      r0,[r4,#0xc]
000092  6004              STR      r4,[r0,#0]
                  |L2.148|
;;;2029                              ((ptr_t)(Right_Head->Tail))+sizeof(struct RMP_Mem_Tail)-(ptr_t)Mem_Head);
;;;2030           }
;;;2031       }
;;;2032   
;;;2033       /* Now check if we can merge it with the lower blocks */
;;;2034       Merge_Left=0;
;;;2035       if((ptr_t)Mem_Head!=Mem->Start)
000094  68e8              LDR      r0,[r5,#0xc]
000096  42a0              CMP      r0,r4
000098  d005              BEQ      |L2.166|
;;;2036       {
;;;2037           Left_Head=((struct RMP_Mem_Tail*)(((ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Tail)))->Head;
00009a  4620              MOV      r0,r4
00009c  3880              SUBS     r0,r0,#0x80
;;;2038   
;;;2039           /* If this one is unoccupied */
;;;2040           if(Left_Head->State==RMP_MEM_FREE)
00009e  6fc6              LDR      r6,[r0,#0x7c]
0000a0  68b0              LDR      r0,[r6,#8]
0000a2  2800              CMP      r0,#0
0000a4  d004              BEQ      |L2.176|
                  |L2.166|
;;;2041           {
;;;2042               /* Delete, merge */
;;;2043               _RMP_Mem_Del(Pool, Left_Head);
;;;2044               _RMP_Mem_Block(Left_Head,
;;;2045                              (ptr_t)((ptr_t)(Mem_Head->Tail)+sizeof(struct RMP_Mem_Tail)-(ptr_t)Left_Head));
;;;2046   
;;;2047               /* We have completed the merge here and the original block has destroyed.
;;;2048                * Thus there's no need to insert it into the list again */
;;;2049               Merge_Left=1;
;;;2050           }
;;;2051       }
;;;2052   
;;;2053       /* If we did not merge it with the left-side blocks, insert the original pointer's block 
;;;2054        * into the TLSF table(Merging with the right-side one won't disturb this) */
;;;2055       if(Merge_Left==0)
;;;2056           _RMP_Mem_Ins(Pool, Mem_Head);
0000a6  4621              MOV      r1,r4
0000a8  4628              MOV      r0,r5
0000aa  f7fffffe          BL       _RMP_Mem_Ins
                  |L2.174|
;;;2057       else
;;;2058           _RMP_Mem_Ins(Pool, Left_Head);
;;;2059   }
0000ae  bdf8              POP      {r3-r7,pc}
                  |L2.176|
0000b0  68f0              LDR      r0,[r6,#0xc]
0000b2  1b87              SUBS     r7,r0,r6
0000b4  3f10              SUBS     r7,r7,#0x10
0000b6  4638              MOV      r0,r7
0000b8  f7fffffe          BL       RMP_MSB_Get
0000bc  1ec1              SUBS     r1,r0,#3
0000be  40cf              LSRS     r7,r7,r1
0000c0  0779              LSLS     r1,r7,#29
0000c2  1f80              SUBS     r0,r0,#6
0000c4  0f49              LSRS     r1,r1,#29
0000c6  00c0              LSLS     r0,r0,#3
0000c8  1840              ADDS     r0,r0,r1
0000ca  00c1              LSLS     r1,r0,#3
0000cc  6832              LDR      r2,[r6,#0]
0000ce  1949              ADDS     r1,r1,r5
0000d0  6873              LDR      r3,[r6,#4]
0000d2  601a              STR      r2,[r3,#0]
0000d4  6053              STR      r3,[r2,#4]
0000d6  6aca              LDR      r2,[r1,#0x2c]
0000d8  3128              ADDS     r1,r1,#0x28
0000da  428a              CMP      r2,r1
0000dc  d109              BNE      |L2.242|
0000de  0941              LSRS     r1,r0,#5
0000e0  008a              LSLS     r2,r1,#2
0000e2  1951              ADDS     r1,r2,r5
0000e4  694a              LDR      r2,[r1,#0x14]
0000e6  0703              LSLS     r3,r0,#28
0000e8  0f1b              LSRS     r3,r3,#28
0000ea  2001              MOVS     r0,#1
0000ec  4098              LSLS     r0,r0,r3
0000ee  4382              BICS     r2,r2,r0
0000f0  614a              STR      r2,[r1,#0x14]
                  |L2.242|
0000f2  68e0              LDR      r0,[r4,#0xc]          ;2044
0000f4  1b80              SUBS     r0,r0,r6              ;2044
0000f6  2100              MOVS     r1,#0                 ;2044
0000f8  60b1              STR      r1,[r6,#8]            ;2044
0000fa  1d00              ADDS     r0,r0,#4              ;2044
0000fc  1830              ADDS     r0,r6,r0              ;2044
0000fe  e000              B        |L2.258|
                  |L2.256|
000100  e008              B        |L2.276|
                  |L2.258|
000102  1f00              SUBS     r0,r0,#4              ;2044
000104  60f0              STR      r0,[r6,#0xc]          ;2044
000106  68f0              LDR      r0,[r6,#0xc]          ;2044
000108  6006              STR      r6,[r0,#0]            ;2044
00010a  4631              MOV      r1,r6                 ;2058
00010c  4628              MOV      r0,r5                 ;2058
00010e  f7fffffe          BL       _RMP_Mem_Ins
000112  bdf8              POP      {r3-r7,pc}
                  |L2.276|
000114  4770              BX       lr
;;;2060   /* End Function:RMP_Free *****************************************************/
                          ENDP


                          AREA ||i.RMP_Init||, CODE, READONLY, ALIGN=2

                  RMP_Init PROC
;;;1508   ******************************************************************************/
;;;1509   void RMP_Init(void)
000000  f7fffffe          BL       RMP_Disable_Int
000004  4807              LDR      r0,|L3.36|
000006  2101              MOVS     r1,#1
000008  60c1              STR      r1,[r0,#0xc]  ; RMP_Sched_Locked
00000a  6881              LDR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
00000c  1c49              ADDS     r1,r1,#1
00000e  6081              STR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
;;;1510   {
;;;1511       RMP_Lock_Sched();
;;;1512       
;;;1513       /* Platform will use this hook to do something */
;;;1514       _RMP_Plat_Hook();
000010  f7fffffe          BL       _RMP_Plat_Hook
;;;1515       /* Start the second thread here */
;;;1516       RMP_Init_Hook();
000014  f7fffffe          BL       RMP_Init_Hook
;;;1517       
;;;1518       RMP_Unlock_Sched();
000018  f7fffffe          BL       RMP_Unlock_Sched
                  |L3.28|
;;;1519       
;;;1520       while(1)
;;;1521       {
;;;1522           RMP_Init_Idle();
00001c  f7fffffe          BL       RMP_Init_Idle
000020  e7fc              B        |L3.28|
;;;1523       };
;;;1524   }
;;;1525   /* End Function:RMP_Init *****************************************************/
                          ENDP

000022  0000              DCW      0x0000
                  |L3.36|
                          DCD      ||.data||

                          AREA ||i.RMP_LSB_Get||, CODE, READONLY, ALIGN=2

                  RMP_LSB_Get PROC
;;;1649   ******************************************************************************/
;;;1650   ptr_t RMP_LSB_Get(ptr_t Val)
000000  b510              PUSH     {r4,lr}
000002  4a11              LDR      r2,|L4.72|
;;;1651   {
000004  0e03              LSRS     r3,r0,#24
000006  5cd3              LDRB     r3,[r2,r3]
000008  0a09              LSRS     r1,r1,#8
00000a  0209              LSLS     r1,r1,#8
00000c  4319              ORRS     r1,r1,r3
00000e  0203              LSLS     r3,r0,#8
000010  0e1b              LSRS     r3,r3,#24
000012  5cd3              LDRB     r3,[r2,r3]
000014  24ff              MOVS     r4,#0xff
000016  0224              LSLS     r4,r4,#8
000018  021b              LSLS     r3,r3,#8
00001a  43a1              BICS     r1,r1,r4
00001c  4023              ANDS     r3,r3,r4
00001e  4319              ORRS     r1,r1,r3
000020  0403              LSLS     r3,r0,#16
000022  0e1b              LSRS     r3,r3,#24
000024  5cd3              LDRB     r3,[r2,r3]
000026  0224              LSLS     r4,r4,#8
000028  041b              LSLS     r3,r3,#16
00002a  43a1              BICS     r1,r1,r4
00002c  4023              ANDS     r3,r3,r4
00002e  b2c0              UXTB     r0,r0
000030  4319              ORRS     r1,r1,r3
000032  5c12              LDRB     r2,[r2,r0]
000034  0208              LSLS     r0,r1,#8
000036  0a00              LSRS     r0,r0,#8
000038  0611              LSLS     r1,r2,#24
00003a  4308              ORRS     r0,r0,r1
;;;1652   #if(RMP_WORD_ORDER==4)
;;;1653       return 15-RMP_MSB_Get(RMP_RBIT_Get(Val));
;;;1654   #elif(RMP_WORD_ORDER==5)
;;;1655       return 31-RMP_MSB_Get(RMP_RBIT_Get(Val));
00003c  f7fffffe          BL       RMP_MSB_Get
000040  211f              MOVS     r1,#0x1f
000042  1a08              SUBS     r0,r1,r0
;;;1656   #else
;;;1657       return 63-RMP_MSB_Get(RMP_RBIT_Get(Val));
;;;1658   #endif 
;;;1659   }
000044  bd10              POP      {r4,pc}
;;;1660   /* End Function:RMP_LSB_Get **************************************************/
                          ENDP

000046  0000              DCW      0x0000
                  |L4.72|
                          DCD      ||.constdata||

                          AREA ||i.RMP_List_Crt||, CODE, READONLY, ALIGN=1

                  RMP_List_Crt PROC
;;;215    ******************************************************************************/
;;;216    void RMP_List_Crt(volatile struct RMP_List* Head)
000000  6000              STR      r0,[r0,#0]
;;;217    {
;;;218        Head->Prev=(struct RMP_List*)Head;
;;;219        Head->Next=(struct RMP_List*)Head;
000002  6040              STR      r0,[r0,#4]
;;;220    }
000004  4770              BX       lr
;;;221    /* End Function:RMP_List_Crt *************************************************/
                          ENDP


                          AREA ||i.RMP_List_Del||, CODE, READONLY, ALIGN=1

                  RMP_List_Del PROC
;;;229    ******************************************************************************/
;;;230    void RMP_List_Del(volatile struct RMP_List* Prev,volatile struct RMP_List* Next)
000000  6008              STR      r0,[r1,#0]
;;;231    {
;;;232        Next->Prev=(struct RMP_List*)Prev;
;;;233        Prev->Next=(struct RMP_List*)Next;
000002  6041              STR      r1,[r0,#4]
;;;234    }
000004  4770              BX       lr
;;;235    /* End Function:RMP_List_Del *************************************************/
                          ENDP


                          AREA ||i.RMP_List_Ins||, CODE, READONLY, ALIGN=1

                  RMP_List_Ins PROC
;;;244    ******************************************************************************/
;;;245    void RMP_List_Ins(volatile struct RMP_List* New,
000000  6010              STR      r0,[r2,#0]
;;;246                      volatile struct RMP_List* Prev,
;;;247                      volatile struct RMP_List* Next)
;;;248    {
;;;249        Next->Prev=(struct RMP_List*)New;
;;;250        New->Next=(struct RMP_List*)Next;
000002  6042              STR      r2,[r0,#4]
;;;251        New->Prev=(struct RMP_List*)Prev;
000004  6001              STR      r1,[r0,#0]
;;;252        Prev->Next=(struct RMP_List*)New;
000006  6048              STR      r0,[r1,#4]
;;;253    }
000008  4770              BX       lr
;;;254    /* End Function:RMP_List_Ins *************************************************/
                          ENDP


                          AREA ||i.RMP_Load_Ctx||, CODE, READONLY, ALIGN=1

                  RMP_Load_Ctx PROC
;;;1476   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1477   void RMP_Load_Ctx(void)
000000  4770              BX       lr
;;;1478   {
;;;1479       return;
;;;1480   }
;;;1481   #endif
                          ENDP


                          AREA ||i.RMP_Lock_Sched||, CODE, READONLY, ALIGN=2

                  RMP_Lock_Sched PROC
;;;261    ******************************************************************************/
;;;262    void RMP_Lock_Sched(void)
000000  b510              PUSH     {r4,lr}
;;;263    {
;;;264        RMP_MASK_INT();
000002  f7fffffe          BL       RMP_Disable_Int
;;;265        RMP_Sched_Locked=1;
000006  4803              LDR      r0,|L9.20|
000008  2101              MOVS     r1,#1
00000a  60c1              STR      r1,[r0,#0xc]  ; RMP_Sched_Locked
;;;266        RMP_Sched_Lock_Cnt++;
00000c  6881              LDR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
00000e  1c49              ADDS     r1,r1,#1
000010  6081              STR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
;;;267    }
000012  bd10              POP      {r4,pc}
;;;268    /* End Function:RMP_Lock_Sched ***********************************************/
                          ENDP

                  |L9.20|
                          DCD      ||.data||

                          AREA ||i.RMP_Malloc||, CODE, READONLY, ALIGN=2

                  RMP_Malloc PROC
;;;1934   ******************************************************************************/
;;;1935   void* RMP_Malloc(volatile void* Pool, ptr_t Size)									                   
000000  2900              CMP      r1,#0
;;;1936   {	
;;;1937       cnt_t FLI_Level;
;;;1938       cnt_t SLI_Level;
;;;1939       volatile struct RMP_Mem* Mem;
;;;1940       ptr_t Old_Size;
;;;1941       volatile struct RMP_Mem_Head* Mem_Head;
;;;1942       ptr_t Rounded_Size;
;;;1943       volatile struct RMP_Mem_Head* New_Mem;
;;;1944       ptr_t New_Size;
;;;1945       
;;;1946       if(Size==0)
000002  d101              BNE      |L10.8|
;;;1947           return (void*)(0);
000004  2000              MOVS     r0,#0
;;;1948       
;;;1949       /* Round up the size:a multiple of 8 and bigger than 64B. In fact, we will add
;;;1950        * extra 8 bytes at the end if the size is a multiple of 8 for safety. */
;;;1951       Rounded_Size=(((Size-1)>>3)+1)<<3;
;;;1952       /* See if it is smaller than the smallest block */
;;;1953       Rounded_Size=(Rounded_Size>64)?Rounded_Size:64;
;;;1954   
;;;1955       /* See if such block exists, if not, abort */
;;;1956       if(_RMP_Mem_Search(Pool,Rounded_Size,&FLI_Level,&SLI_Level)!=0)
;;;1957           return (void*)(0);
;;;1958       
;;;1959       Mem=(volatile struct RMP_Mem*)Pool;
;;;1960       
;;;1961       /* There is such block. Get it and delete it from the TLSF list. */
;;;1962       Mem_Head=(struct RMP_Mem_Head*)(Mem->Table[RMP_MEM_POS(FLI_Level,SLI_Level)].Next);
;;;1963       _RMP_Mem_Del(Pool, Mem_Head);
;;;1964   
;;;1965       /* Allocate and calculate if the space left could be big enough to be a new 
;;;1966        * block. If so, we will put the block back into the TLSF table */
;;;1967       New_Size=(ptr_t)(Mem_Head->Tail)-((ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Head)-Rounded_Size;
;;;1968       if(New_Size>=sizeof(struct RMP_Mem_Head)+64+sizeof(struct RMP_Mem_Tail))
;;;1969       {
;;;1970           Old_Size=sizeof(struct RMP_Mem_Head)+Rounded_Size+sizeof(struct RMP_Mem_Tail);
;;;1971           New_Mem=(volatile struct RMP_Mem_Head*)(((ptr_t)Mem_Head)+Old_Size);
;;;1972   
;;;1973           _RMP_Mem_Block(Mem_Head, Old_Size);
;;;1974           _RMP_Mem_Block(New_Mem, New_Size);
;;;1975   
;;;1976           /* Put the extra block back */
;;;1977           _RMP_Mem_Ins(Pool, New_Mem);
;;;1978       }
;;;1979   
;;;1980       /* Insert the allocated block into the lists */
;;;1981       RMP_List_Ins(&(Mem_Head->Head),&(Mem->Alloc),Mem->Alloc.Next);
;;;1982       Mem_Head->State=RMP_MEM_USED;
;;;1983   
;;;1984       /* Finally, return the start address */
;;;1985       return (void*)(((ptr_t)Mem_Head)+sizeof(struct RMP_Mem_Head));
;;;1986   }
000006  4770              BX       lr
                  |L10.8|
000008  b5f0              PUSH     {r4-r7,lr}            ;1936
00000a  4606              MOV      r6,r0                 ;1936
00000c  1e49              SUBS     r1,r1,#1              ;1936
00000e  08c8              LSRS     r0,r1,#3              ;1951
000010  00c5              LSLS     r5,r0,#3              ;1951
000012  3508              ADDS     r5,r5,#8              ;1951
000014  b083              SUB      sp,sp,#0xc            ;1936
000016  2d40              CMP      r5,#0x40              ;1953
000018  d800              BHI      |L10.28|
00001a  2540              MOVS     r5,#0x40              ;1953
                  |L10.28|
00001c  4634              MOV      r4,r6                 ;1956
00001e  4628              MOV      r0,r5                 ;1956
000020  f7fffffe          BL       RMP_MSB_Get
000024  2140              MOVS     r1,#0x40              ;1956
000026  1f80              SUBS     r0,r0,#6              ;1956
000028  4081              LSLS     r1,r1,r0              ;1956
00002a  42a9              CMP      r1,r5                 ;1956
00002c  4629              MOV      r1,r5                 ;1956
00002e  d104              BNE      |L10.58|
000030  1cc2              ADDS     r2,r0,#3              ;1956
000032  40d1              LSRS     r1,r1,r2              ;1956
000034  0749              LSLS     r1,r1,#29             ;1956
000036  0f49              LSRS     r1,r1,#29             ;1956
000038  e008              B        |L10.76|
                  |L10.58|
00003a  1cc2              ADDS     r2,r0,#3              ;1956
00003c  40d1              LSRS     r1,r1,r2              ;1956
00003e  0749              LSLS     r1,r1,#29             ;1956
000040  0f49              LSRS     r1,r1,#29             ;1956
000042  1c49              ADDS     r1,r1,#1              ;1956
000044  2908              CMP      r1,#8                 ;1956
000046  d101              BNE      |L10.76|
000048  2100              MOVS     r1,#0                 ;1956
00004a  1c40              ADDS     r0,r0,#1              ;1956
                  |L10.76|
00004c  68a2              LDR      r2,[r4,#8]            ;1956
00004e  4282              CMP      r2,r0                 ;1956
000050  d97e              BLS      |L10.336|
000052  00c0              LSLS     r0,r0,#3              ;1956
000054  1847              ADDS     r7,r0,r1              ;1956
000056  1178              ASRS     r0,r7,#5              ;1956
000058  9001              STR      r0,[sp,#4]            ;1956
00005a  0080              LSLS     r0,r0,#2              ;1956
00005c  1900              ADDS     r0,r0,r4              ;1956
00005e  6941              LDR      r1,[r0,#0x14]         ;1956
000060  0738              LSLS     r0,r7,#28             ;1956
000062  0f00              LSRS     r0,r0,#28             ;1956
000064  40c1              LSRS     r1,r1,r0              ;1956
000066  4a59              LDR      r2,|L10.460|
000068  9000              STR      r0,[sp,#0]            ;1956
00006a  0e0b              LSRS     r3,r1,#24             ;1956
00006c  5cd2              LDRB     r2,[r2,r3]            ;1956
00006e  0a00              LSRS     r0,r0,#8              ;1956
000070  0200              LSLS     r0,r0,#8              ;1956
000072  4310              ORRS     r0,r0,r2              ;1956
000074  020a              LSLS     r2,r1,#8              ;1956
000076  0e13              LSRS     r3,r2,#24             ;1956
000078  4a54              LDR      r2,|L10.460|
00007a  5cd2              LDRB     r2,[r2,r3]            ;1956
00007c  23ff              MOVS     r3,#0xff              ;1956
00007e  021b              LSLS     r3,r3,#8              ;1956
000080  0212              LSLS     r2,r2,#8              ;1956
000082  4398              BICS     r0,r0,r3              ;1956
000084  401a              ANDS     r2,r2,r3              ;1956
000086  4310              ORRS     r0,r0,r2              ;1956
000088  040a              LSLS     r2,r1,#16             ;1956
00008a  0e13              LSRS     r3,r2,#24             ;1956
00008c  4a4f              LDR      r2,|L10.460|
00008e  5cd2              LDRB     r2,[r2,r3]            ;1956
000090  23ff              MOVS     r3,#0xff              ;1956
000092  041b              LSLS     r3,r3,#16             ;1956
000094  0412              LSLS     r2,r2,#16             ;1956
000096  4398              BICS     r0,r0,r3              ;1956
000098  401a              ANDS     r2,r2,r3              ;1956
00009a  4310              ORRS     r0,r0,r2              ;1956
00009c  b2ca              UXTB     r2,r1                 ;1956
00009e  494b              LDR      r1,|L10.460|
0000a0  0200              LSLS     r0,r0,#8              ;1956
0000a2  5c89              LDRB     r1,[r1,r2]            ;1956
0000a4  0a00              LSRS     r0,r0,#8              ;1956
0000a6  0609              LSLS     r1,r1,#24             ;1956
0000a8  4308              ORRS     r0,r0,r1              ;1956
0000aa  f7fffffe          BL       RMP_MSB_Get
0000ae  4601              MOV      r1,r0                 ;1956
0000b0  201f              MOVS     r0,#0x1f              ;1956
0000b2  1a40              SUBS     r0,r0,r1              ;1956
0000b4  2820              CMP      r0,#0x20              ;1956
0000b6  d205              BCS      |L10.196|
0000b8  9900              LDR      r1,[sp,#0]            ;1956
0000ba  1808              ADDS     r0,r1,r0              ;1956
0000bc  3810              SUBS     r0,r0,#0x10           ;1956
0000be  4038              ANDS     r0,r0,r7              ;1956
0000c0  10c1              ASRS     r1,r0,#3              ;1956
0000c2  e02f              B        |L10.292|
                  |L10.196|
0000c4  9f01              LDR      r7,[sp,#4]            ;1956
0000c6  1c7f              ADDS     r7,r7,#1              ;1956
0000c8  2f05              CMP      r7,#5                 ;1956
0000ca  da7b              BGE      |L10.452|
                  |L10.204|
0000cc  00b8              LSLS     r0,r7,#2              ;1956
0000ce  1900              ADDS     r0,r0,r4              ;1956
0000d0  6940              LDR      r0,[r0,#0x14]         ;1956
0000d2  2800              CMP      r0,#0                 ;1956
0000d4  d073              BEQ      |L10.446|
0000d6  00b8              LSLS     r0,r7,#2              ;1956
0000d8  1900              ADDS     r0,r0,r4              ;1956
0000da  6941              LDR      r1,[r0,#0x14]         ;1956
0000dc  4a3b              LDR      r2,|L10.460|
0000de  0e0b              LSRS     r3,r1,#24             ;1956
0000e0  5cd3              LDRB     r3,[r2,r3]            ;1956
0000e2  0a00              LSRS     r0,r0,#8              ;1956
0000e4  0200              LSLS     r0,r0,#8              ;1956
0000e6  4318              ORRS     r0,r0,r3              ;1956
0000e8  020b              LSLS     r3,r1,#8              ;1956
0000ea  0e1b              LSRS     r3,r3,#24             ;1956
0000ec  5cd3              LDRB     r3,[r2,r3]            ;1956
0000ee  24ff              MOVS     r4,#0xff              ;1956
0000f0  0224              LSLS     r4,r4,#8              ;1956
0000f2  021b              LSLS     r3,r3,#8              ;1956
0000f4  43a0              BICS     r0,r0,r4              ;1956
0000f6  4023              ANDS     r3,r3,r4              ;1956
0000f8  4318              ORRS     r0,r0,r3              ;1956
0000fa  040b              LSLS     r3,r1,#16             ;1956
0000fc  0e1b              LSRS     r3,r3,#24             ;1956
0000fe  5cd3              LDRB     r3,[r2,r3]            ;1956
000100  0224              LSLS     r4,r4,#8              ;1956
000102  041b              LSLS     r3,r3,#16             ;1956
000104  43a0              BICS     r0,r0,r4              ;1956
000106  4023              ANDS     r3,r3,r4              ;1956
000108  b2c9              UXTB     r1,r1                 ;1956
00010a  4318              ORRS     r0,r0,r3              ;1956
00010c  5c51              LDRB     r1,[r2,r1]            ;1956
00010e  0200              LSLS     r0,r0,#8              ;1956
000110  0a00              LSRS     r0,r0,#8              ;1956
000112  0609              LSLS     r1,r1,#24             ;1956
000114  4308              ORRS     r0,r0,r1              ;1956
000116  f7fffffe          BL       RMP_MSB_Get
00011a  211f              MOVS     r1,#0x1f              ;1956
00011c  1a08              SUBS     r0,r1,r0              ;1956
00011e  0179              LSLS     r1,r7,#5              ;1956
000120  1809              ADDS     r1,r1,r0              ;1956
000122  08c9              LSRS     r1,r1,#3              ;1956
                  |L10.292|
000124  0740              LSLS     r0,r0,#29             ;1956
000126  0f40              LSRS     r0,r0,#29             ;1956
000128  00c9              LSLS     r1,r1,#3              ;1962
00012a  1808              ADDS     r0,r1,r0              ;1962
00012c  00c0              LSLS     r0,r0,#3              ;1962
00012e  1980              ADDS     r0,r0,r6              ;1962
000130  6ac4              LDR      r4,[r0,#0x2c]         ;1962
000132  68e0              LDR      r0,[r4,#0xc]          ;1962
000134  1b07              SUBS     r7,r0,r4              ;1962
000136  3f10              SUBS     r7,r7,#0x10           ;1962
000138  4638              MOV      r0,r7                 ;1962
00013a  f7fffffe          BL       RMP_MSB_Get
00013e  1f81              SUBS     r1,r0,#6              ;1962
000140  1ec0              SUBS     r0,r0,#3              ;1962
000142  40c7              LSRS     r7,r7,r0              ;1962
000144  077a              LSLS     r2,r7,#29             ;1962
000146  0f52              LSRS     r2,r2,#29             ;1962
000148  00c8              LSLS     r0,r1,#3              ;1962
00014a  1880              ADDS     r0,r0,r2              ;1962
00014c  00c1              LSLS     r1,r0,#3              ;1962
00014e  e000              B        |L10.338|
                  |L10.336|
000150  e038              B        |L10.452|
                  |L10.338|
000152  198b              ADDS     r3,r1,r6              ;1962
000154  6821              LDR      r1,[r4,#0]            ;1962
000156  6862              LDR      r2,[r4,#4]            ;1962
000158  6011              STR      r1,[r2,#0]            ;1962
00015a  604a              STR      r2,[r1,#4]            ;1962
00015c  6ad9              LDR      r1,[r3,#0x2c]         ;1962
00015e  3328              ADDS     r3,r3,#0x28           ;1962
000160  4299              CMP      r1,r3                 ;1962
000162  d109              BNE      |L10.376|
000164  0941              LSRS     r1,r0,#5              ;1962
000166  008a              LSLS     r2,r1,#2              ;1962
000168  1991              ADDS     r1,r2,r6              ;1962
00016a  694a              LDR      r2,[r1,#0x14]         ;1962
00016c  0703              LSLS     r3,r0,#28             ;1962
00016e  0f1b              LSRS     r3,r3,#28             ;1962
000170  2001              MOVS     r0,#1                 ;1962
000172  4098              LSLS     r0,r0,r3              ;1962
000174  4382              BICS     r2,r2,r0              ;1962
000176  614a              STR      r2,[r1,#0x14]         ;1962
                  |L10.376|
000178  68e0              LDR      r0,[r4,#0xc]          ;1967
00017a  1b00              SUBS     r0,r0,r4              ;1967
00017c  1b42              SUBS     r2,r0,r5              ;1967
00017e  3a10              SUBS     r2,r2,#0x10           ;1967
000180  2a54              CMP      r2,#0x54              ;1968
000182  d310              BCC      |L10.422|
000184  3514              ADDS     r5,r5,#0x14           ;1968
000186  1961              ADDS     r1,r4,r5              ;1971
000188  2300              MOVS     r3,#0                 ;1971
00018a  60a3              STR      r3,[r4,#8]            ;1971
00018c  1f08              SUBS     r0,r1,#4              ;1971
00018e  60e0              STR      r0,[r4,#0xc]          ;1971
000190  68e0              LDR      r0,[r4,#0xc]          ;1971
000192  6004              STR      r4,[r0,#0]            ;1971
000194  608b              STR      r3,[r1,#8]            ;1971
000196  188a              ADDS     r2,r1,r2              ;1971
000198  1f12              SUBS     r2,r2,#4              ;1971
00019a  60ca              STR      r2,[r1,#0xc]          ;1971
00019c  68ca              LDR      r2,[r1,#0xc]          ;1971
00019e  6011              STR      r1,[r2,#0]            ;1971
0001a0  4630              MOV      r0,r6                 ;1977
0001a2  f7fffffe          BL       _RMP_Mem_Ins
                  |L10.422|
0001a6  6870              LDR      r0,[r6,#4]            ;1981
0001a8  6004              STR      r4,[r0,#0]            ;1981
0001aa  6060              STR      r0,[r4,#4]            ;1981
0001ac  6026              STR      r6,[r4,#0]            ;1981
0001ae  6074              STR      r4,[r6,#4]            ;1981
0001b0  2001              MOVS     r0,#1                 ;1982
0001b2  60a0              STR      r0,[r4,#8]            ;1982
0001b4  4620              MOV      r0,r4                 ;1985
0001b6  3010              ADDS     r0,r0,#0x10           ;1985
0001b8  b003              ADD      sp,sp,#0xc
0001ba  bdf0              POP      {r4-r7,pc}
0001bc  e7ff              B        |L10.446|
                  |L10.446|
0001be  1c7f              ADDS     r7,r7,#1
0001c0  2f05              CMP      r7,#5
0001c2  db83              BLT      |L10.204|
                  |L10.452|
0001c4  2000              MOVS     r0,#0                 ;1957
0001c6  b003              ADD      sp,sp,#0xc
0001c8  bdf0              POP      {r4-r7,pc}
;;;1987   /* End Function:RMP_Malloc ***************************************************/
                          ENDP

0001ca  0000              DCW      0x0000
                  |L10.460|
                          DCD      ||.constdata||

                          AREA ||i.RMP_Mem_Init||, CODE, READONLY, ALIGN=1

                  RMP_Mem_Init PROC
;;;1695   ******************************************************************************/
;;;1696   ret_t RMP_Mem_Init(volatile void* Pool, ptr_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;1697   {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;1698       cnt_t FLI_Cnt;
;;;1699       ptr_t Usable_Size;
;;;1700       volatile struct RMP_Mem* Mem;
;;;1701       volatile struct RMP_Mem_Head* Mem_Head;
;;;1702       
;;;1703       /* See if the memory pool is large enough to enable dynamic allocation - at least 4096 words */
;;;1704       if(Size<(4096*sizeof(ptr_t)))
000006  2101              MOVS     r1,#1
;;;1705           return RMP_ERR_MEM;
000008  2006              MOVS     r0,#6
00000a  0389              LSLS     r1,r1,#14             ;1704
00000c  43c0              MVNS     r0,r0
00000e  428d              CMP      r5,r1                 ;1704
000010  d346              BCC      |L11.160|
000012  4621              MOV      r1,r4                 ;1697
;;;1706       
;;;1707       /* See if the address and size is word-aligned */
;;;1708       if((((ptr_t)Pool&(RMP_WORD_MASK>>2))!=0)||((Size&(RMP_WORD_MASK>>2))!=0))
000014  4329              ORRS     r1,r1,r5
000016  0789              LSLS     r1,r1,#30
000018  d142              BNE      |L11.160|
;;;1709           return RMP_ERR_MEM;
;;;1710           
;;;1711       Mem=(volatile struct RMP_Mem*)Pool;
;;;1712       Mem->Size=Size;
00001a  6125              STR      r5,[r4,#0x10]
00001c  6024              STR      r4,[r4,#0]
00001e  6064              STR      r4,[r4,#4]
;;;1713       /* Initialize the allocated block list */
;;;1714       RMP_List_Crt(&(Mem->Alloc));
;;;1715       /* Calculate the FLI value needed for this - we always align to 64 byte */
;;;1716       Mem->FLI_Num=RMP_MSB_Get(Size-sizeof(struct RMP_Mem))-6+1;
000020  2045              MOVS     r0,#0x45
000022  00c0              LSLS     r0,r0,#3
000024  1a28              SUBS     r0,r5,r0
000026  f7fffffe          BL       RMP_MSB_Get
00002a  1f40              SUBS     r0,r0,#5
00002c  60a0              STR      r0,[r4,#8]
;;;1717       /* Initialize the TLSF allocation table first */
;;;1718       for(FLI_Cnt=0;FLI_Cnt<Mem->FLI_Num;FLI_Cnt++)
00002e  68a1              LDR      r1,[r4,#8]
000030  2000              MOVS     r0,#0
000032  4281              CMP      r1,r0
000034  d91e              BLS      |L11.116|
                  |L11.54|
;;;1719       {
;;;1720           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,0)]));
000036  0182              LSLS     r2,r0,#6
000038  1912              ADDS     r2,r2,r4
00003a  4611              MOV      r1,r2
00003c  3128              ADDS     r1,r1,#0x28
00003e  6291              STR      r1,[r2,#0x28]
000040  62d1              STR      r1,[r2,#0x2c]
;;;1721           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,1)]));
000042  3108              ADDS     r1,r1,#8
000044  6311              STR      r1,[r2,#0x30]
000046  6351              STR      r1,[r2,#0x34]
;;;1722           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,2)]));
000048  3108              ADDS     r1,r1,#8
00004a  6391              STR      r1,[r2,#0x38]
00004c  63d1              STR      r1,[r2,#0x3c]
;;;1723           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,3)]));
00004e  3108              ADDS     r1,r1,#8
000050  6411              STR      r1,[r2,#0x40]
000052  6451              STR      r1,[r2,#0x44]
;;;1724           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,4)]));
000054  3108              ADDS     r1,r1,#8
000056  6491              STR      r1,[r2,#0x48]
000058  64d1              STR      r1,[r2,#0x4c]
;;;1725           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,5)]));
00005a  3108              ADDS     r1,r1,#8
00005c  6511              STR      r1,[r2,#0x50]
00005e  6551              STR      r1,[r2,#0x54]
;;;1726           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,6)]));
000060  3108              ADDS     r1,r1,#8
000062  6591              STR      r1,[r2,#0x58]
000064  65d1              STR      r1,[r2,#0x5c]
000066  3260              ADDS     r2,r2,#0x60
000068  6012              STR      r2,[r2,#0]
00006a  6052              STR      r2,[r2,#4]
;;;1727           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,7)]));
00006c  68a1              LDR      r1,[r4,#8]
00006e  1c40              ADDS     r0,r0,#1
000070  4281              CMP      r1,r0
000072  d8e0              BHI      |L11.54|
                  |L11.116|
;;;1728       }
;;;1729       for(FLI_Cnt=0;FLI_Cnt<5;FLI_Cnt++)
;;;1730           Mem->Bitmap[FLI_Cnt]=0;
000074  2000              MOVS     r0,#0
000076  6160              STR      r0,[r4,#0x14]
000078  61a0              STR      r0,[r4,#0x18]
00007a  61e0              STR      r0,[r4,#0x1c]
00007c  6220              STR      r0,[r4,#0x20]
00007e  6260              STR      r0,[r4,#0x24]
;;;1731       
;;;1732       /* Get the big memory block's size and position */
;;;1733       Usable_Size=sizeof(struct RMP_Mem)+(sizeof(struct RMP_List)<<3)*(Mem->FLI_Num-8);
000080  68a1              LDR      r1,[r4,#8]
000082  018a              LSLS     r2,r1,#6
000084  3228              ADDS     r2,r2,#0x28
;;;1734       Mem_Head=(struct RMP_Mem_Head*)(((ptr_t)Pool)+Usable_Size);
000086  18a1              ADDS     r1,r4,r2
;;;1735       Mem->Start=(ptr_t)Mem_Head;
000088  60e1              STR      r1,[r4,#0xc]
;;;1736       Usable_Size=Size-Usable_Size;
00008a  1aaa              SUBS     r2,r5,r2
00008c  6088              STR      r0,[r1,#8]
00008e  1888              ADDS     r0,r1,r2
000090  1f00              SUBS     r0,r0,#4
000092  60c8              STR      r0,[r1,#0xc]
000094  68c8              LDR      r0,[r1,#0xc]
000096  6001              STR      r1,[r0,#0]
;;;1737       
;;;1738       /* Initialize the big block */
;;;1739       _RMP_Mem_Block(Mem_Head,Usable_Size);
;;;1740       
;;;1741       /* Insert the memory into the corresponding level */
;;;1742       _RMP_Mem_Ins(Pool, Mem_Head);
000098  4620              MOV      r0,r4
00009a  f7fffffe          BL       _RMP_Mem_Ins
;;;1743       return 0;
00009e  2000              MOVS     r0,#0
                  |L11.160|
;;;1744   }
0000a0  bd70              POP      {r4-r6,pc}
;;;1745   /* End Function:RMP_Mem_Init *************************************************/
                          ENDP


                          AREA ||i.RMP_Print_Int||, CODE, READONLY, ALIGN=1

                  RMP_Print_Int PROC
;;;69     ******************************************************************************/
;;;70     cnt_t RMP_Print_Int(cnt_t Int)
000000  b5f8              PUSH     {r3-r7,lr}
;;;71     {
000002  0006              MOVS     r6,r0
000004  d02b              BEQ      |L12.94|
;;;72         ptr_t Iter;
;;;73         cnt_t Count;
;;;74         cnt_t Num;
;;;75         ptr_t Div;
;;;76         
;;;77         /* how many digits are there? */
;;;78         if(Int==0)
;;;79         {
;;;80             RMP_Putchar('0');
;;;81             return 1;
;;;82         }
;;;83         else if(Int<0)
000006  2e00              CMP      r6,#0
000008  da2e              BGE      |L12.104|
;;;84         {
;;;85             /* How many digits are there? */
;;;86             Count=0;
00000a  2400              MOVS     r4,#0
;;;87             Div=1;
00000c  2501              MOVS     r5,#1
;;;88             Iter=-Int;
00000e  4240              RSBS     r0,r0,#0
000010  4606              MOV      r6,r0
;;;89             while(Iter!=0)
000012  d007              BEQ      |L12.36|
                  |L12.20|
;;;90             {
;;;91                 Iter/=10;
000014  210a              MOVS     r1,#0xa
000016  f7fffffe          BL       __aeabi_uidivmod
;;;92                 Count++;
;;;93                 Div*=10;
00001a  210a              MOVS     r1,#0xa
00001c  434d              MULS     r5,r1,r5
00001e  1c64              ADDS     r4,r4,#1
000020  2800              CMP      r0,#0                 ;89
000022  d1f7              BNE      |L12.20|
                  |L12.36|
;;;94             }
;;;95             Div/=10;
000024  210a              MOVS     r1,#0xa
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       __aeabi_uidivmod
00002c  4605              MOV      r5,r0
;;;96             
;;;97             RMP_Putchar('-');
00002e  202d              MOVS     r0,#0x2d
000030  f7fffffe          BL       RMP_Putchar
;;;98             Iter=-Int;
;;;99             Num=Count+1;
000034  1c67              ADDS     r7,r4,#1
;;;100            
;;;101            while(Count>0)
000036  2c00              CMP      r4,#0
000038  dd37              BLE      |L12.170|
                  |L12.58|
;;;102            {
;;;103                Count--;
;;;104                RMP_Putchar(Iter/Div+'0');
00003a  4629              MOV      r1,r5
00003c  4630              MOV      r0,r6
00003e  1e64              SUBS     r4,r4,#1
000040  f7fffffe          BL       __aeabi_uidivmod
000044  3030              ADDS     r0,r0,#0x30
000046  460e              MOV      r6,r1
000048  b240              SXTB     r0,r0
00004a  f7fffffe          BL       RMP_Putchar
;;;105                Iter=Iter%Div;
;;;106                Div/=10;
00004e  210a              MOVS     r1,#0xa
000050  4628              MOV      r0,r5
000052  f7fffffe          BL       __aeabi_uidivmod
000056  4605              MOV      r5,r0
000058  2c00              CMP      r4,#0                 ;101
00005a  dcee              BGT      |L12.58|
00005c  e025              B        |L12.170|
                  |L12.94|
00005e  2030              MOVS     r0,#0x30              ;80
000060  f7fffffe          BL       RMP_Putchar
000064  2001              MOVS     r0,#1                 ;81
;;;107            }
;;;108        }
;;;109        else
;;;110        {
;;;111            /* How many digits are there? */
;;;112            Count=0;
;;;113            Div=1;
;;;114            Iter=Int;
;;;115            while(Iter!=0)
;;;116            {
;;;117                Iter/=10;
;;;118                Count++;
;;;119                Div*=10;
;;;120            }
;;;121            Div/=10;
;;;122            
;;;123            Iter=Int;
;;;124            Num=Count;
;;;125            
;;;126            while(Count>0)
;;;127            {
;;;128                Count--;
;;;129                RMP_Putchar(Iter/Div+'0');
;;;130                Iter=Iter%Div;
;;;131                Div/=10;
;;;132            }
;;;133        }
;;;134        
;;;135        return Num;
;;;136    }
000066  bdf8              POP      {r3-r7,pc}
                  |L12.104|
000068  2500              MOVS     r5,#0                 ;112
00006a  2401              MOVS     r4,#1                 ;113
                  |L12.108|
00006c  210a              MOVS     r1,#0xa               ;117
00006e  f7fffffe          BL       __aeabi_uidivmod
000072  210a              MOVS     r1,#0xa               ;119
000074  434c              MULS     r4,r1,r4              ;119
000076  1c6d              ADDS     r5,r5,#1              ;119
000078  2800              CMP      r0,#0                 ;115
00007a  d1f7              BNE      |L12.108|
00007c  4620              MOV      r0,r4                 ;121
00007e  f7fffffe          BL       __aeabi_uidivmod
000082  4604              MOV      r4,r0                 ;121
000084  1e2f              SUBS     r7,r5,#0              ;124
000086  dd10              BLE      |L12.170|
                  |L12.136|
000088  4601              MOV      r1,r0                 ;129
00008a  4630              MOV      r0,r6                 ;129
00008c  1e6d              SUBS     r5,r5,#1              ;129
00008e  f7fffffe          BL       __aeabi_uidivmod
000092  3030              ADDS     r0,r0,#0x30           ;129
000094  460e              MOV      r6,r1                 ;129
000096  b240              SXTB     r0,r0                 ;129
000098  f7fffffe          BL       RMP_Putchar
00009c  210a              MOVS     r1,#0xa               ;131
00009e  4620              MOV      r0,r4                 ;131
0000a0  f7fffffe          BL       __aeabi_uidivmod
0000a4  4604              MOV      r4,r0                 ;131
0000a6  2d00              CMP      r5,#0                 ;126
0000a8  dcee              BGT      |L12.136|
                  |L12.170|
0000aa  4638              MOV      r0,r7                 ;135
0000ac  bdf8              POP      {r3-r7,pc}
;;;137    /* End Function:RMP_Print_Int ************************************************/
                          ENDP


                          AREA ||i.RMP_Print_String||, CODE, READONLY, ALIGN=1

                  RMP_Print_String PROC
;;;192    ******************************************************************************/
;;;193    cnt_t RMP_Print_String(s8* String)
000000  b570              PUSH     {r4-r6,lr}
;;;194    {
000002  4605              MOV      r5,r0
;;;195        cnt_t Count;
;;;196        
;;;197        Count=0;
000004  2400              MOVS     r4,#0
                  |L13.6|
;;;198        while(Count<RMP_KERNEL_DEBUG_MAX_STR)
;;;199        {
;;;200            if(String[Count]=='\0')
000006  5728              LDRSB    r0,[r5,r4]
000008  2800              CMP      r0,#0
00000a  d004              BEQ      |L13.22|
00000c  1c64              ADDS     r4,r4,#1
;;;201                break;
;;;202            
;;;203            RMP_Putchar(String[Count++]);
00000e  f7fffffe          BL       RMP_Putchar
000012  2cff              CMP      r4,#0xff              ;198
000014  dbf7              BLT      |L13.6|
                  |L13.22|
;;;204        }
;;;205        
;;;206        return Count;
000016  4620              MOV      r0,r4
;;;207    }
000018  bd70              POP      {r4-r6,pc}
;;;208    /* End Function:RMP_Print_String *********************************************/
                          ENDP


                          AREA ||i.RMP_Print_Uint||, CODE, READONLY, ALIGN=1

                  RMP_Print_Uint PROC
;;;145    ******************************************************************************/
;;;146    cnt_t RMP_Print_Uint(ptr_t Uint)
000000  b570              PUSH     {r4-r6,lr}
;;;147    {
000002  0004              MOVS     r4,r0
000004  d003              BEQ      |L14.14|
;;;148        ptr_t Iter;
;;;149        cnt_t Count;
;;;150        cnt_t Num;
;;;151        
;;;152        /* how many digits are there? */
;;;153        if(Uint==0)
;;;154        {
;;;155            RMP_Putchar('0');
;;;156            return 1;
;;;157        }
;;;158        else
;;;159        {
;;;160            /* Filter out all the zeroes */
;;;161            Count=0;
000006  2100              MOVS     r1,#0
;;;162            Iter=Uint;
;;;163            while((Iter>>((sizeof(ptr_t)*8)-4))==0)
000008  0f02              LSRS     r2,r0,#28
00000a  d005              BEQ      |L14.24|
00000c  e008              B        |L14.32|
                  |L14.14|
00000e  2030              MOVS     r0,#0x30              ;155
000010  f7fffffe          BL       RMP_Putchar
000014  2001              MOVS     r0,#1                 ;156
;;;164            {
;;;165                Iter<<=4;
;;;166                Count++;
;;;167            }
;;;168            /* Count is the number of pts to print */
;;;169            Count=sizeof(ptr_t)*2-Count;
;;;170            Num=Count;
;;;171            while(Count>0)
;;;172            {
;;;173                Count--;
;;;174                Iter=(Uint>>(Count*4))&0x0F;
;;;175                if(Iter<10)
;;;176                    RMP_Putchar('0'+Iter);
;;;177                else
;;;178                    RMP_Putchar('A'+Iter-10);
;;;179            }
;;;180        }
;;;181        
;;;182        return Num;
;;;183    }
000016  bd70              POP      {r4-r6,pc}
                  |L14.24|
000018  0100              LSLS     r0,r0,#4              ;165
00001a  1c49              ADDS     r1,r1,#1              ;165
00001c  0f02              LSRS     r2,r0,#28             ;163
00001e  d0fb              BEQ      |L14.24|
                  |L14.32|
000020  2008              MOVS     r0,#8                 ;169
000022  1a45              SUBS     r5,r0,r1              ;169
000024  1e2e              SUBS     r6,r5,#0              ;170
000026  dd10              BLE      |L14.74|
                  |L14.40|
000028  4628              MOV      r0,r5                 ;173
00002a  1e6d              SUBS     r5,r5,#1              ;173
00002c  0080              LSLS     r0,r0,#2
00002e  4621              MOV      r1,r4
000030  1f00              SUBS     r0,r0,#4
000032  40c1              LSRS     r1,r1,r0              ;174
000034  0708              LSLS     r0,r1,#28             ;174
000036  0f00              LSRS     r0,r0,#28             ;174
000038  280a              CMP      r0,#0xa               ;175
00003a  d201              BCS      |L14.64|
00003c  3030              ADDS     r0,r0,#0x30           ;175
00003e  e000              B        |L14.66|
                  |L14.64|
000040  3037              ADDS     r0,r0,#0x37           ;176
                  |L14.66|
000042  f7fffffe          BL       RMP_Putchar
000046  2d00              CMP      r5,#0                 ;171
000048  dcee              BGT      |L14.40|
                  |L14.74|
00004a  4630              MOV      r0,r6                 ;182
00004c  bd70              POP      {r4-r6,pc}
;;;184    /* End Function:RMP_Print_Uint ***********************************************/
                          ENDP


                          AREA ||i.RMP_RBIT_Get||, CODE, READONLY, ALIGN=2

                  RMP_RBIT_Get PROC
;;;1610   
;;;1611   ptr_t RMP_RBIT_Get(ptr_t Val)
000000  b410              PUSH     {r4}
;;;1612   {
;;;1613       ptr_t Ret;
;;;1614       u8* To;
;;;1615       u8* From;
;;;1616       
;;;1617       To=(u8*)(&Ret);
;;;1618       From=(u8*)(&Val);
;;;1619       
;;;1620   #if(RMP_WORD_ORDER==4)
;;;1621       To[0]=RMP_RBIT_Table[From[1]];
;;;1622       To[1]=RMP_RBIT_Table[From[0]];
;;;1623   #elif(RMP_WORD_ORDER==5)
;;;1624       To[0]=RMP_RBIT_Table[From[3]];
000002  4a0f              LDR      r2,|L15.64|
000004  0e03              LSRS     r3,r0,#24             ;1612
000006  5cd3              LDRB     r3,[r2,r3]
000008  0a09              LSRS     r1,r1,#8
00000a  0209              LSLS     r1,r1,#8
00000c  4319              ORRS     r1,r1,r3
00000e  0203              LSLS     r3,r0,#8
000010  0e1b              LSRS     r3,r3,#24
;;;1625       To[1]=RMP_RBIT_Table[From[2]];
000012  5cd3              LDRB     r3,[r2,r3]
000014  24ff              MOVS     r4,#0xff
000016  0224              LSLS     r4,r4,#8
000018  021b              LSLS     r3,r3,#8
00001a  43a1              BICS     r1,r1,r4
00001c  4023              ANDS     r3,r3,r4
00001e  4319              ORRS     r1,r1,r3
000020  0403              LSLS     r3,r0,#16
000022  0e1b              LSRS     r3,r3,#24
;;;1626       To[2]=RMP_RBIT_Table[From[1]];
000024  5cd3              LDRB     r3,[r2,r3]
000026  0224              LSLS     r4,r4,#8
000028  041b              LSLS     r3,r3,#16
00002a  43a1              BICS     r1,r1,r4
00002c  4023              ANDS     r3,r3,r4
00002e  b2c0              UXTB     r0,r0
;;;1627       To[3]=RMP_RBIT_Table[From[0]];
000030  5c12              LDRB     r2,[r2,r0]
000032  4319              ORRS     r1,r1,r3              ;1626
000034  0208              LSLS     r0,r1,#8
000036  0a00              LSRS     r0,r0,#8
000038  0611              LSLS     r1,r2,#24
;;;1628   #else
;;;1629       To[0]=RMP_RBIT_Table[From[7]];
;;;1630       To[1]=RMP_RBIT_Table[From[6]];
;;;1631       To[2]=RMP_RBIT_Table[From[5]];
;;;1632       To[3]=RMP_RBIT_Table[From[4]];
;;;1633       To[4]=RMP_RBIT_Table[From[3]];
;;;1634       To[5]=RMP_RBIT_Table[From[2]];
;;;1635       To[6]=RMP_RBIT_Table[From[1]];
;;;1636       To[7]=RMP_RBIT_Table[From[0]];
;;;1637   #endif
;;;1638   
;;;1639       return Ret;
;;;1640   }
00003a  bc10              POP      {r4}
00003c  4308              ORRS     r0,r0,r1              ;1627
00003e  4770              BX       lr
;;;1641   /* End Function:RMP_RBIT_Get *************************************************/
                          ENDP

                  |L15.64|
                          DCD      ||.constdata||

                          AREA ||i.RMP_Save_Ctx||, CODE, READONLY, ALIGN=1

                  RMP_Save_Ctx PROC
;;;1462   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1463   void RMP_Save_Ctx(void)
000000  4770              BX       lr
;;;1464   {
;;;1465       return;
;;;1466   }
;;;1467   #endif
                          ENDP


                          AREA ||i.RMP_Sem_Abort||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Abort PROC
;;;1290   ******************************************************************************/
;;;1291   ret_t RMP_Sem_Abort(volatile struct RMP_Thd* Thread)
000000  b570              PUSH     {r4-r6,lr}
;;;1292   {
;;;1293       /* Check if this thread structure could possibly be in use */
;;;1294       if(Thread==0)
;;;1295           return RMP_ERR_THD;
000002  4d1f              LDR      r5,|L17.128|
000004  0004              MOVS     r4,r0                 ;1292
000006  d017              BEQ      |L17.56|
000008  f7fffffe          BL       RMP_Disable_Int
00000c  481d              LDR      r0,|L17.132|
00000e  2101              MOVS     r1,#1                 ;1292
000010  60c1              STR      r1,[r0,#0xc]          ;1292  ; RMP_Sched_Locked
000012  6881              LDR      r1,[r0,#8]            ;1292  ; RMP_Sched_Lock_Cnt
000014  1c49              ADDS     r1,r1,#1              ;1292
000016  6081              STR      r1,[r0,#8]            ;1292  ; RMP_Sched_Lock_Cnt
;;;1296   
;;;1297       RMP_Lock_Sched();
;;;1298       
;;;1299       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
000018  69a0              LDR      r0,[r4,#0x18]
00001a  0600              LSLS     r0,r0,#24
00001c  0e00              LSRS     r0,r0,#24
00001e  d00d              BEQ      |L17.60|
;;;1300       {
;;;1301           RMP_Unlock_Sched();
;;;1302           return RMP_ERR_THD;
;;;1303       }
;;;1304       
;;;1305       /* Is it waiting on a semaphore? If no, we abort and return an error code */
;;;1306       if((RMP_THD_STATE(Thread->State)!=RMP_THD_SEMBLK)&&
000020  69a0              LDR      r0,[r4,#0x18]
000022  b2c0              UXTB     r0,r0
000024  2807              CMP      r0,#7
000026  d00d              BEQ      |L17.68|
;;;1307          (RMP_THD_STATE(Thread->State)!=RMP_THD_SEMDLY))
000028  69a0              LDR      r0,[r4,#0x18]
00002a  b2c0              UXTB     r0,r0
00002c  2808              CMP      r0,#8
00002e  d009              BEQ      |L17.68|
;;;1308       {
;;;1309           RMP_Unlock_Sched();
000030  f7fffffe          BL       RMP_Unlock_Sched
;;;1310           return RMP_ERR_STATE;
000034  00a8              LSLS     r0,r5,#2
;;;1311       }
;;;1312   
;;;1313       /* Waiting for a semaphore. We abort it and return */
;;;1314       RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1315       if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1316           RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1317       
;;;1318       RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1319   
;;;1320       /* Only when when this thread is not suspended do we change it back */
;;;1321       if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1322           _RMP_Set_Rdy(Thread);
;;;1323       
;;;1324       Thread->Retval=RMP_ERR_OPER;
;;;1325       
;;;1326       RMP_Unlock_Sched();
;;;1327   
;;;1328       return 0;
;;;1329   }
000036  bd70              POP      {r4-r6,pc}
                  |L17.56|
000038  4628              MOV      r0,r5                 ;1295
00003a  bd70              POP      {r4-r6,pc}
                  |L17.60|
00003c  f7fffffe          BL       RMP_Unlock_Sched
000040  4628              MOV      r0,r5                 ;1302
000042  bd70              POP      {r4-r6,pc}
                  |L17.68|
000044  6821              LDR      r1,[r4,#0]            ;1314
000046  6860              LDR      r0,[r4,#4]            ;1314
000048  6001              STR      r1,[r0,#0]            ;1314
00004a  6048              STR      r0,[r1,#4]            ;1314
00004c  69a0              LDR      r0,[r4,#0x18]         ;1315
00004e  b2c0              UXTB     r0,r0                 ;1315
000050  2808              CMP      r0,#8                 ;1315
000052  d103              BNE      |L17.92|
000054  68a1              LDR      r1,[r4,#8]            ;1316
000056  68e0              LDR      r0,[r4,#0xc]          ;1316
000058  6001              STR      r1,[r0,#0]            ;1316
00005a  6048              STR      r0,[r1,#4]            ;1316
                  |L17.92|
00005c  69a0              LDR      r0,[r4,#0x18]         ;1318
00005e  0a00              LSRS     r0,r0,#8              ;1318
000060  0200              LSLS     r0,r0,#8              ;1318
000062  1c40              ADDS     r0,r0,#1              ;1318
000064  61a0              STR      r0,[r4,#0x18]         ;1318
000066  69a0              LDR      r0,[r4,#0x18]         ;1321
000068  05c0              LSLS     r0,r0,#23             ;1321
00006a  d402              BMI      |L17.114|
00006c  4620              MOV      r0,r4                 ;1322
00006e  f7fffffe          BL       _RMP_Set_Rdy
                  |L17.114|
000072  2004              MOVS     r0,#4                 ;1324
000074  43c0              MVNS     r0,r0                 ;1324
000076  63a0              STR      r0,[r4,#0x38]         ;1324
000078  f7fffffe          BL       RMP_Unlock_Sched
00007c  2000              MOVS     r0,#0                 ;1328
00007e  bd70              POP      {r4-r6,pc}
;;;1330   /* End Function:RMP_Sem_Abort ************************************************/
                          ENDP

                  |L17.128|
                          DCD      0xffffffff
                  |L17.132|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Crt||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Crt PROC
;;;1148   ******************************************************************************/
;;;1149   ret_t RMP_Sem_Crt(volatile struct RMP_Sem* Semaphore, ptr_t Number)
000000  b570              PUSH     {r4-r6,lr}
;;;1150   {
;;;1151       /* Check if this semaphore structure could possibly be in use */
;;;1152       if(Semaphore==0)
;;;1153           return RMP_ERR_SEM;
000002  4e13              LDR      r6,|L18.80|
000004  460d              MOV      r5,r1                 ;1150
000006  0004              MOVS     r4,r0                 ;1150
000008  d00e              BEQ      |L18.40|
00000a  f7fffffe          BL       RMP_Disable_Int
00000e  4811              LDR      r0,|L18.84|
000010  2101              MOVS     r1,#1                 ;1150
000012  60c1              STR      r1,[r0,#0xc]          ;1150  ; RMP_Sched_Locked
000014  6882              LDR      r2,[r0,#8]            ;1150  ; RMP_Sched_Lock_Cnt
000016  1c52              ADDS     r2,r2,#1              ;1150
000018  6082              STR      r2,[r0,#8]            ;1150  ; RMP_Sched_Lock_Cnt
;;;1154       
;;;1155       RMP_Lock_Sched();
;;;1156       
;;;1157       if(Semaphore->State!=RMP_SEM_FREE)
00001a  68a0              LDR      r0,[r4,#8]
00001c  2800              CMP      r0,#0
00001e  d005              BEQ      |L18.44|
;;;1158       {
;;;1159           RMP_Unlock_Sched();
000020  f7fffffe          BL       RMP_Unlock_Sched
;;;1160           return RMP_ERR_SEM;
000024  4630              MOV      r0,r6
;;;1161       }
;;;1162       
;;;1163       /* Is the number too great to initialize? */
;;;1164       if(Number>=RMP_SEM_MAX_NUM)
;;;1165       {
;;;1166           RMP_Unlock_Sched();
;;;1167           return RMP_ERR_OPER;
;;;1168       }
;;;1169   
;;;1170       /* Initialize contents */
;;;1171       Semaphore->Cur_Num=Number;
;;;1172       Semaphore->State=RMP_SEM_USED;
;;;1173       RMP_List_Crt(&(Semaphore->Wait_List));
;;;1174       
;;;1175       RMP_Unlock_Sched();
;;;1176       
;;;1177       return 0;
;;;1178   }
000026  bd70              POP      {r4-r6,pc}
                  |L18.40|
000028  4630              MOV      r0,r6                 ;1153
00002a  bd70              POP      {r4-r6,pc}
                  |L18.44|
00002c  207d              MOVS     r0,#0x7d              ;1164
00002e  00c0              LSLS     r0,r0,#3              ;1164
000030  4285              CMP      r5,r0                 ;1164
000032  d304              BCC      |L18.62|
000034  f7fffffe          BL       RMP_Unlock_Sched
000038  2004              MOVS     r0,#4                 ;1167
00003a  43c0              MVNS     r0,r0                 ;1167
00003c  bd70              POP      {r4-r6,pc}
                  |L18.62|
00003e  60e5              STR      r5,[r4,#0xc]          ;1171
000040  60a1              STR      r1,[r4,#8]            ;1172
000042  6024              STR      r4,[r4,#0]            ;1172
000044  6064              STR      r4,[r4,#4]            ;1172
000046  f7fffffe          BL       RMP_Unlock_Sched
00004a  2000              MOVS     r0,#0                 ;1177
00004c  bd70              POP      {r4-r6,pc}
;;;1179   /* End Function:RMP_Sem_Crt **************************************************/
                          ENDP

00004e  0000              DCW      0x0000
                  |L18.80|
                          DCD      0xfffffffa
                  |L18.84|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Del||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Del PROC
;;;1186   ******************************************************************************/
;;;1187   ret_t RMP_Sem_Del(volatile struct RMP_Sem* Semaphore)
000000  b570              PUSH     {r4-r6,lr}
;;;1188   {
;;;1189       struct RMP_Thd* Thread;
;;;1190       
;;;1191       /* Check if this semaphore structure could possibly be in use */
;;;1192       if(Semaphore==0)
;;;1193           return RMP_ERR_SEM;
000002  4c1c              LDR      r4,|L19.116|
000004  0005              MOVS     r5,r0                 ;1188
000006  d00e              BEQ      |L19.38|
000008  f7fffffe          BL       RMP_Disable_Int
00000c  481a              LDR      r0,|L19.120|
00000e  2101              MOVS     r1,#1                 ;1188
000010  60c1              STR      r1,[r0,#0xc]          ;1188  ; RMP_Sched_Locked
000012  6881              LDR      r1,[r0,#8]            ;1188  ; RMP_Sched_Lock_Cnt
000014  1c49              ADDS     r1,r1,#1              ;1188
000016  6081              STR      r1,[r0,#8]            ;1188  ; RMP_Sched_Lock_Cnt
;;;1194       
;;;1195       RMP_Lock_Sched();
;;;1196       
;;;1197       if(Semaphore->State!=RMP_SEM_USED)
000018  68a8              LDR      r0,[r5,#8]
00001a  2801              CMP      r0,#1
00001c  d005              BEQ      |L19.42|
;;;1198       {
;;;1199           RMP_Unlock_Sched();
00001e  f7fffffe          BL       RMP_Unlock_Sched
;;;1200           return RMP_ERR_SEM;
000022  4620              MOV      r0,r4
;;;1201       }
;;;1202   
;;;1203       /* Get rid of all guys waiting on it */
;;;1204       while(&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)
;;;1205       {
;;;1206           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1207           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1208           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1209               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1210   
;;;1211           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1212   
;;;1213           /* Is it suspended? If yes, we can't directly send it running */
;;;1214           if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1215              _RMP_Set_Rdy(Thread);
;;;1216           
;;;1217           Thread->Retval=RMP_ERR_OPER;
;;;1218       }
;;;1219       Semaphore->State=RMP_SEM_FREE;
;;;1220       
;;;1221       RMP_Unlock_Sched();
;;;1222   
;;;1223       return 0;
;;;1224   }
000024  bd70              POP      {r4-r6,pc}
                  |L19.38|
000026  4620              MOV      r0,r4                 ;1193
000028  bd70              POP      {r4-r6,pc}
                  |L19.42|
00002a  6868              LDR      r0,[r5,#4]            ;1204
00002c  42a8              CMP      r0,r5                 ;1204
00002e  d01b              BEQ      |L19.104|
000030  2604              MOVS     r6,#4                 ;1217
000032  43f6              MVNS     r6,r6                 ;1217
                  |L19.52|
000034  686c              LDR      r4,[r5,#4]            ;1206
000036  6861              LDR      r1,[r4,#4]            ;1206
000038  6820              LDR      r0,[r4,#0]            ;1206
00003a  6008              STR      r0,[r1,#0]            ;1206
00003c  6041              STR      r1,[r0,#4]            ;1206
00003e  7e20              LDRB     r0,[r4,#0x18]         ;1208
000040  2808              CMP      r0,#8                 ;1208
000042  d103              BNE      |L19.76|
000044  68e1              LDR      r1,[r4,#0xc]          ;1208
000046  68a0              LDR      r0,[r4,#8]            ;1208
000048  6008              STR      r0,[r1,#0]            ;1208
00004a  6041              STR      r1,[r0,#4]            ;1208
                  |L19.76|
00004c  69a0              LDR      r0,[r4,#0x18]         ;1211
00004e  0a00              LSRS     r0,r0,#8              ;1211
000050  0200              LSLS     r0,r0,#8              ;1211
000052  1c40              ADDS     r0,r0,#1              ;1211
000054  61a0              STR      r0,[r4,#0x18]         ;1214
000056  05c0              LSLS     r0,r0,#23             ;1214
000058  d402              BMI      |L19.96|
00005a  4620              MOV      r0,r4                 ;1215
00005c  f7fffffe          BL       _RMP_Set_Rdy
                  |L19.96|
000060  63a6              STR      r6,[r4,#0x38]         ;1204
000062  6868              LDR      r0,[r5,#4]            ;1204
000064  42a8              CMP      r0,r5                 ;1204
000066  d1e5              BNE      |L19.52|
                  |L19.104|
000068  2000              MOVS     r0,#0                 ;1219
00006a  60a8              STR      r0,[r5,#8]            ;1219
00006c  f7fffffe          BL       RMP_Unlock_Sched
000070  2000              MOVS     r0,#0                 ;1223
000072  bd70              POP      {r4-r6,pc}
;;;1225   /* End Function:RMP_Sem_Del **************************************************/
                          ENDP

                  |L19.116|
                          DCD      0xfffffffa
                  |L19.120|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Pend||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Pend PROC
;;;1233   ******************************************************************************/
;;;1234   ret_t RMP_Sem_Pend(volatile struct RMP_Sem* Semaphore, ptr_t Slices)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1235   {
;;;1236       /* Check if this semaphore structure could possibly be in use */
;;;1237       if(Semaphore==0)
;;;1238           return RMP_ERR_SEM;
000002  4f2e              LDR      r7,|L20.188|
000004  460c              MOV      r4,r1                 ;1235
000006  0006              MOVS     r6,r0                 ;1235
000008  d00e              BEQ      |L20.40|
00000a  f7fffffe          BL       RMP_Disable_Int
00000e  4d2c              LDR      r5,|L20.192|
000010  2001              MOVS     r0,#1                 ;1235
000012  60e8              STR      r0,[r5,#0xc]          ;1235  ; RMP_Sched_Locked
000014  68a8              LDR      r0,[r5,#8]            ;1235  ; RMP_Sched_Lock_Cnt
000016  1c40              ADDS     r0,r0,#1              ;1235
000018  60a8              STR      r0,[r5,#8]            ;1235  ; RMP_Sched_Lock_Cnt
;;;1239       
;;;1240       RMP_Lock_Sched();
;;;1241       
;;;1242       if(Semaphore->State!=RMP_SEM_USED)
00001a  68b0              LDR      r0,[r6,#8]
00001c  2801              CMP      r0,#1
00001e  d005              BEQ      |L20.44|
;;;1243       {
;;;1244           RMP_Unlock_Sched();
000020  f7fffffe          BL       RMP_Unlock_Sched
;;;1245           return RMP_ERR_SEM;
000024  4638              MOV      r0,r7
;;;1246       }
;;;1247       
;;;1248       /* Check if we can get one immediately */
;;;1249       if(Semaphore->Cur_Num!=0)
;;;1250       {
;;;1251           Semaphore->Cur_Num--;
;;;1252           RMP_Unlock_Sched();
;;;1253           return Semaphore->Cur_Num;
;;;1254       }
;;;1255       else
;;;1256       {
;;;1257           /* Cannot get one, we need to block */
;;;1258           if(Slices==0)
;;;1259           {
;;;1260               RMP_Unlock_Sched();
;;;1261               return RMP_ERR_OPER;
;;;1262           }
;;;1263   
;;;1264           /* We must be running - place into waitlist now */
;;;1265           _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1266           RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Semaphore->Wait_List.Prev,&(Semaphore->Wait_List));
;;;1267           
;;;1268           if(Slices<RMP_MAX_SLICES)
;;;1269           {
;;;1270               _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1271               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMDLY);
;;;1272           }
;;;1273           else
;;;1274               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMBLK);
;;;1275           
;;;1276           RMP_Cur_Thd->Retval=0;
;;;1277       }
;;;1278       
;;;1279       RMP_Unlock_Sched();
;;;1280   
;;;1281       return RMP_Cur_Thd->Retval;
;;;1282   }
000026  bdf8              POP      {r3-r7,pc}
                  |L20.40|
000028  4638              MOV      r0,r7                 ;1238
00002a  bdf8              POP      {r3-r7,pc}
                  |L20.44|
00002c  68f0              LDR      r0,[r6,#0xc]          ;1249
00002e  2800              CMP      r0,#0                 ;1249
000030  d006              BEQ      |L20.64|
000032  68f0              LDR      r0,[r6,#0xc]          ;1251
000034  1e40              SUBS     r0,r0,#1              ;1251
000036  60f0              STR      r0,[r6,#0xc]          ;1251
000038  f7fffffe          BL       RMP_Unlock_Sched
00003c  68f0              LDR      r0,[r6,#0xc]          ;1253
00003e  bdf8              POP      {r3-r7,pc}
                  |L20.64|
000040  2c00              CMP      r4,#0                 ;1258
000042  d02f              BEQ      |L20.164|
000044  69a8              LDR      r0,[r5,#0x18]         ;1265  ; RMP_Cur_Thd
000046  f7fffffe          BL       _RMP_Clr_Rdy
00004a  69a8              LDR      r0,[r5,#0x18]         ;1266  ; RMP_Cur_Thd
00004c  6831              LDR      r1,[r6,#0]            ;1266
00004e  6030              STR      r0,[r6,#0]            ;1266
000050  6046              STR      r6,[r0,#4]            ;1266
000052  6001              STR      r1,[r0,#0]            ;1266
000054  6048              STR      r0,[r1,#4]            ;1266
000056  481b              LDR      r0,|L20.196|
000058  4284              CMP      r4,r0                 ;1268
00005a  d228              BCS      |L20.174|
00005c  69aa              LDR      r2,[r5,#0x18]         ;1270  ; RMP_Cur_Thd
00005e  4b1a              LDR      r3,|L20.200|
000060  6858              LDR      r0,[r3,#4]            ;1270  ; RMP_Delay
000062  4298              CMP      r0,r3                 ;1270
000064  d006              BEQ      |L20.116|
000066  6a06              LDR      r6,[r0,#0x20]         ;1270
                  |L20.104|
000068  6869              LDR      r1,[r5,#4]            ;1270  ; RMP_Tick
00006a  1a71              SUBS     r1,r6,r1              ;1270
00006c  42a1              CMP      r1,r4                 ;1270
00006e  d801              BHI      |L20.116|
000070  4298              CMP      r0,r3                 ;1270
000072  d1f9              BNE      |L20.104|
                  |L20.116|
000074  6869              LDR      r1,[r5,#4]            ;1270  ; RMP_Tick
000076  1909              ADDS     r1,r1,r4              ;1270
000078  6291              STR      r1,[r2,#0x28]         ;1270
00007a  3208              ADDS     r2,r2,#8              ;1270
00007c  6801              LDR      r1,[r0,#0]            ;1270
00007e  6002              STR      r2,[r0,#0]            ;1270
000080  6050              STR      r0,[r2,#4]            ;1270
000082  6011              STR      r1,[r2,#0]            ;1270
000084  604a              STR      r2,[r1,#4]            ;1270
000086  69a8              LDR      r0,[r5,#0x18]         ;1271  ; RMP_Cur_Thd
000088  69a9              LDR      r1,[r5,#0x18]         ;1271  ; RMP_Cur_Thd
00008a  6980              LDR      r0,[r0,#0x18]         ;1271
00008c  0a00              LSRS     r0,r0,#8              ;1271
00008e  0200              LSLS     r0,r0,#8              ;1271
000090  3008              ADDS     r0,r0,#8              ;1271
                  |L20.146|
000092  6188              STR      r0,[r1,#0x18]         ;1276
000094  69a9              LDR      r1,[r5,#0x18]         ;1276  ; RMP_Cur_Thd
000096  2000              MOVS     r0,#0                 ;1276
000098  6388              STR      r0,[r1,#0x38]         ;1279
00009a  f7fffffe          BL       RMP_Unlock_Sched
00009e  69a8              LDR      r0,[r5,#0x18]         ;1281  ; RMP_Cur_Thd
0000a0  6b80              LDR      r0,[r0,#0x38]         ;1281
0000a2  bdf8              POP      {r3-r7,pc}
                  |L20.164|
0000a4  f7fffffe          BL       RMP_Unlock_Sched
0000a8  2004              MOVS     r0,#4                 ;1261
0000aa  43c0              MVNS     r0,r0                 ;1261
0000ac  bdf8              POP      {r3-r7,pc}
                  |L20.174|
0000ae  69a8              LDR      r0,[r5,#0x18]         ;1274  ; RMP_Cur_Thd
0000b0  69a9              LDR      r1,[r5,#0x18]         ;1274  ; RMP_Cur_Thd
0000b2  6980              LDR      r0,[r0,#0x18]         ;1274
0000b4  0a00              LSRS     r0,r0,#8              ;1274
0000b6  0200              LSLS     r0,r0,#8              ;1274
0000b8  1dc0              ADDS     r0,r0,#7              ;1274
0000ba  e7ea              B        |L20.146|
;;;1283   /* End Function:RMP_Sem_Pend *************************************************/
                          ENDP

                  |L20.188|
                          DCD      0xfffffffa
                  |L20.192|
                          DCD      ||.data||
                  |L20.196|
                          DCD      0x000186a0
                  |L20.200|
                          DCD      ||.data||+0x20

                          AREA ||i.RMP_Sem_Post||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Post PROC
;;;1340   ******************************************************************************/
;;;1341   ret_t RMP_Sem_Post(volatile struct RMP_Sem* Semaphore, ptr_t Number)
000000  b570              PUSH     {r4-r6,lr}
;;;1342   {
;;;1343       struct RMP_Thd* Thread;
;;;1344       
;;;1345       /* Check if this semaphore structure could possibly be in use */
;;;1346       if((Semaphore==0)||(Number==0))
;;;1347           return RMP_ERR_SEM;
000002  4e25              LDR      r6,|L21.152|
000004  460d              MOV      r5,r1                 ;1342
000006  0004              MOVS     r4,r0                 ;1342
000008  d010              BEQ      |L21.44|
00000a  2d00              CMP      r5,#0                 ;1346
00000c  d00e              BEQ      |L21.44|
00000e  f7fffffe          BL       RMP_Disable_Int
000012  4822              LDR      r0,|L21.156|
000014  2101              MOVS     r1,#1                 ;1346
000016  60c1              STR      r1,[r0,#0xc]          ;1346  ; RMP_Sched_Locked
000018  6881              LDR      r1,[r0,#8]            ;1346  ; RMP_Sched_Lock_Cnt
00001a  1c49              ADDS     r1,r1,#1              ;1346
00001c  6081              STR      r1,[r0,#8]            ;1346  ; RMP_Sched_Lock_Cnt
;;;1348       
;;;1349       RMP_Lock_Sched();
;;;1350       
;;;1351       if(Semaphore->State!=RMP_SEM_USED)
00001e  68a0              LDR      r0,[r4,#8]
000020  2801              CMP      r0,#1
000022  d005              BEQ      |L21.48|
;;;1352       {
;;;1353           RMP_Unlock_Sched();
000024  f7fffffe          BL       RMP_Unlock_Sched
;;;1354           return RMP_ERR_SEM;
000028  4630              MOV      r0,r6
;;;1355       }
;;;1356       
;;;1357       /* Would the maximum value be exceeded if this is posted? */
;;;1358       if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
;;;1359       {
;;;1360           RMP_Unlock_Sched();
;;;1361           return RMP_ERR_OPER;
;;;1362       }
;;;1363       
;;;1364       Semaphore->Cur_Num+=Number;
;;;1365       /* Is there any thread waiting on it? If there are, clean them up*/
;;;1366       while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
;;;1367       {
;;;1368           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1369           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1370           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1371               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1372           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1373   
;;;1374           /* Only when when this thread is not suspended do we change it back */
;;;1375           if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1376               _RMP_Set_Rdy(Thread);
;;;1377   
;;;1378           /* Finally, return success */
;;;1379           Thread->Retval=0;
;;;1380           Semaphore->Cur_Num--;
;;;1381       }
;;;1382   
;;;1383       RMP_Unlock_Sched();
;;;1384   
;;;1385       return 0;
;;;1386   }
00002a  bd70              POP      {r4-r6,pc}
                  |L21.44|
00002c  4630              MOV      r0,r6                 ;1347
00002e  bd70              POP      {r4-r6,pc}
                  |L21.48|
000030  68e0              LDR      r0,[r4,#0xc]          ;1358
000032  217d              MOVS     r1,#0x7d              ;1358
000034  1940              ADDS     r0,r0,r5              ;1358
000036  00c9              LSLS     r1,r1,#3              ;1358
000038  4288              CMP      r0,r1                 ;1358
00003a  d304              BCC      |L21.70|
00003c  f7fffffe          BL       RMP_Unlock_Sched
000040  2004              MOVS     r0,#4                 ;1361
000042  43c0              MVNS     r0,r0                 ;1361
000044  bd70              POP      {r4-r6,pc}
                  |L21.70|
000046  68e0              LDR      r0,[r4,#0xc]          ;1364
000048  1940              ADDS     r0,r0,r5              ;1364
00004a  60e0              STR      r0,[r4,#0xc]          ;1364
00004c  2600              MOVS     r6,#0                 ;1364
00004e  e019              B        |L21.132|
                  |L21.80|
000050  6865              LDR      r5,[r4,#4]            ;1368
000052  6869              LDR      r1,[r5,#4]            ;1368
000054  6828              LDR      r0,[r5,#0]            ;1368
000056  6008              STR      r0,[r1,#0]            ;1368
000058  6041              STR      r1,[r0,#4]            ;1368
00005a  7e28              LDRB     r0,[r5,#0x18]         ;1370
00005c  2808              CMP      r0,#8                 ;1370
00005e  d103              BNE      |L21.104|
000060  68e9              LDR      r1,[r5,#0xc]          ;1370
000062  68a8              LDR      r0,[r5,#8]            ;1370
000064  6008              STR      r0,[r1,#0]            ;1370
000066  6041              STR      r1,[r0,#4]            ;1370
                  |L21.104|
000068  69a8              LDR      r0,[r5,#0x18]         ;1372
00006a  0a00              LSRS     r0,r0,#8              ;1372
00006c  0200              LSLS     r0,r0,#8              ;1372
00006e  1c40              ADDS     r0,r0,#1              ;1372
000070  61a8              STR      r0,[r5,#0x18]         ;1375
000072  05c0              LSLS     r0,r0,#23             ;1375
000074  d402              BMI      |L21.124|
000076  4628              MOV      r0,r5                 ;1376
000078  f7fffffe          BL       _RMP_Set_Rdy
                  |L21.124|
00007c  63ae              STR      r6,[r5,#0x38]         ;1380
00007e  68e0              LDR      r0,[r4,#0xc]          ;1380
000080  1e40              SUBS     r0,r0,#1              ;1380
000082  60e0              STR      r0,[r4,#0xc]          ;1380
                  |L21.132|
000084  6860              LDR      r0,[r4,#4]            ;1366
000086  42a0              CMP      r0,r4                 ;1366
000088  d002              BEQ      |L21.144|
00008a  68e0              LDR      r0,[r4,#0xc]          ;1366
00008c  2800              CMP      r0,#0                 ;1366
00008e  d1df              BNE      |L21.80|
                  |L21.144|
000090  f7fffffe          BL       RMP_Unlock_Sched
000094  2000              MOVS     r0,#0                 ;1385
000096  bd70              POP      {r4-r6,pc}
;;;1387   /* End Function:RMP_Sem_Post *************************************************/
                          ENDP

                  |L21.152|
                          DCD      0xfffffffa
                  |L21.156|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Post_ISR||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Post_ISR PROC
;;;1395   ******************************************************************************/
;;;1396   ret_t RMP_Sem_Post_ISR(volatile struct RMP_Sem* Semaphore, ptr_t Number)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1397   {
000002  0004              MOVS     r4,r0
;;;1398       struct RMP_Thd* Thread;
;;;1399       /* Check if this semaphore structure could possibly be in use */
;;;1400       if((Semaphore==0)||(Number==0))
;;;1401           return RMP_ERR_SEM;
000004  481f              LDR      r0,|L22.132|
000006  d03c              BEQ      |L22.130|
000008  2900              CMP      r1,#0                 ;1400
00000a  d03a              BEQ      |L22.130|
;;;1402       
;;;1403       if(Semaphore->State!=RMP_SEM_USED)
00000c  68a2              LDR      r2,[r4,#8]
00000e  2a01              CMP      r2,#1
000010  d137              BNE      |L22.130|
;;;1404           return RMP_ERR_SEM;
;;;1405   
;;;1406       if(RMP_Sched_Locked!=0)
000012  4e1d              LDR      r6,|L22.136|
000014  68f2              LDR      r2,[r6,#0xc]  ; RMP_Sched_Locked
;;;1407           return RMP_ERR_OPER;
000016  1c40              ADDS     r0,r0,#1
000018  2a00              CMP      r2,#0                 ;1406
00001a  d132              BNE      |L22.130|
;;;1408   
;;;1409       /* Would the maximum value be exceeded if this is posted? */
;;;1410       if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
00001c  68e2              LDR      r2,[r4,#0xc]
00001e  237d              MOVS     r3,#0x7d
000020  1852              ADDS     r2,r2,r1
000022  00db              LSLS     r3,r3,#3
000024  429a              CMP      r2,r3
000026  d22c              BCS      |L22.130|
;;;1411           return RMP_ERR_OPER;
;;;1412       
;;;1413       Semaphore->Cur_Num+=Number;
000028  68e0              LDR      r0,[r4,#0xc]
00002a  1840              ADDS     r0,r0,r1
00002c  60e0              STR      r0,[r4,#0xc]
00002e  2700              MOVS     r7,#0
;;;1414       /* Is there any thread waiting on it? If there are, clean them up*/
;;;1415       while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
000030  e020              B        |L22.116|
                  |L22.50|
;;;1416       {
;;;1417           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
000032  6865              LDR      r5,[r4,#4]
000034  6869              LDR      r1,[r5,#4]
000036  6828              LDR      r0,[r5,#0]
000038  6008              STR      r0,[r1,#0]
00003a  6041              STR      r1,[r0,#4]
;;;1418           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1419           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
00003c  7e28              LDRB     r0,[r5,#0x18]
00003e  2808              CMP      r0,#8
000040  d103              BNE      |L22.74|
000042  68e9              LDR      r1,[r5,#0xc]
000044  68a8              LDR      r0,[r5,#8]
000046  6008              STR      r0,[r1,#0]
000048  6041              STR      r1,[r0,#4]
                  |L22.74|
;;;1420               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1421           
;;;1422           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
00004a  69a8              LDR      r0,[r5,#0x18]
00004c  0a00              LSRS     r0,r0,#8
00004e  0200              LSLS     r0,r0,#8
000050  1c40              ADDS     r0,r0,#1
;;;1423   
;;;1424           /* Only when when this thread is not suspended do we change it back */
;;;1425           if((Thread->State&RMP_THD_SUSPENDED)==0)
000052  61a8              STR      r0,[r5,#0x18]
000054  05c0              LSLS     r0,r0,#23
000056  d409              BMI      |L22.108|
;;;1426           {
;;;1427               _RMP_Set_Rdy(Thread);
000058  4628              MOV      r0,r5
00005a  f7fffffe          BL       _RMP_Set_Rdy
;;;1428               if(Thread->Prio>RMP_Cur_Thd->Prio)
00005e  6a68              LDR      r0,[r5,#0x24]
000060  69b1              LDR      r1,[r6,#0x18]  ; RMP_Cur_Thd
000062  6a49              LDR      r1,[r1,#0x24]
000064  4288              CMP      r0,r1
000066  d901              BLS      |L22.108|
;;;1429                   _RMP_Yield();
000068  f7fffffe          BL       _RMP_Yield
                  |L22.108|
;;;1430           }
;;;1431   
;;;1432           /* Finally, return success */
;;;1433           Thread->Retval=0;
;;;1434           Semaphore->Cur_Num--;
00006c  63af              STR      r7,[r5,#0x38]
00006e  68e0              LDR      r0,[r4,#0xc]
000070  1e40              SUBS     r0,r0,#1
000072  60e0              STR      r0,[r4,#0xc]
                  |L22.116|
000074  6860              LDR      r0,[r4,#4]            ;1415
000076  42a0              CMP      r0,r4                 ;1415
000078  d002              BEQ      |L22.128|
00007a  68e0              LDR      r0,[r4,#0xc]          ;1415
00007c  2800              CMP      r0,#0                 ;1415
00007e  d1d8              BNE      |L22.50|
                  |L22.128|
;;;1435       }
;;;1436   
;;;1437       return 0;
000080  2000              MOVS     r0,#0
                  |L22.130|
;;;1438   }
000082  bdf8              POP      {r3-r7,pc}
;;;1439   /* End Function:RMP_Sem_Post_ISR *********************************************/
                          ENDP

                  |L22.132|
                          DCD      0xfffffffa
                  |L22.136|
                          DCD      ||.data||

                          AREA ||i.RMP_Start_Hook||, CODE, READONLY, ALIGN=1

                  RMP_Start_Hook PROC
;;;1448   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1449   void RMP_Start_Hook(void)
000000  4770              BX       lr
;;;1450   {
;;;1451       return;
;;;1452   }
;;;1453   #endif
                          ENDP


                          AREA ||i.RMP_Thd_Cancel||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Cancel PROC
;;;1110   ******************************************************************************/
;;;1111   ret_t RMP_Thd_Cancel(volatile struct RMP_Thd* Thread)
000000  2800              CMP      r0,#0
;;;1112   {
;;;1113       /* Check if this thread structure could possibly be in use */
;;;1114       if(Thread==0)
000002  d101              BNE      |L24.8|
;;;1115           return RMP_ERR_THD;
000004  1e40              SUBS     r0,r0,#1
;;;1116       
;;;1117       RMP_Lock_Sched();
;;;1118       
;;;1119       /* Is it delayed? */
;;;1120       if(RMP_THD_STATE(Thread->State)!=RMP_THD_DELAYED)
;;;1121       {
;;;1122           RMP_Unlock_Sched();
;;;1123           return RMP_ERR_STATE;
;;;1124       }
;;;1125   
;;;1126       /* Delete it from the delay list */
;;;1127       RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1128       RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1129       
;;;1130       /* Only when when this thread is not suspended do we change it back */
;;;1131       if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1132           _RMP_Set_Rdy(Thread);
;;;1133       
;;;1134       Thread->Retval=RMP_ERR_OPER;
;;;1135       
;;;1136       RMP_Unlock_Sched();
;;;1137   
;;;1138       return 0;
;;;1139   }
000006  4770              BX       lr
                  |L24.8|
000008  b510              PUSH     {r4,lr}               ;1112
00000a  4604              MOV      r4,r0                 ;1112
00000c  f7fffffe          BL       RMP_Disable_Int
000010  4812              LDR      r0,|L24.92|
000012  2101              MOVS     r1,#1                 ;1112
000014  60c1              STR      r1,[r0,#0xc]          ;1112  ; RMP_Sched_Locked
000016  6881              LDR      r1,[r0,#8]            ;1112  ; RMP_Sched_Lock_Cnt
000018  1c49              ADDS     r1,r1,#1              ;1112
00001a  6081              STR      r1,[r0,#8]            ;1112  ; RMP_Sched_Lock_Cnt
00001c  69a0              LDR      r0,[r4,#0x18]         ;1120
00001e  b2c0              UXTB     r0,r0                 ;1120
000020  2806              CMP      r0,#6                 ;1120
000022  d004              BEQ      |L24.46|
000024  f7fffffe          BL       RMP_Unlock_Sched
000028  2003              MOVS     r0,#3                 ;1123
00002a  43c0              MVNS     r0,r0                 ;1123
00002c  bd10              POP      {r4,pc}
                  |L24.46|
00002e  68a1              LDR      r1,[r4,#8]            ;1127
000030  68e0              LDR      r0,[r4,#0xc]          ;1127
000032  6001              STR      r1,[r0,#0]            ;1127
000034  6048              STR      r0,[r1,#4]            ;1127
000036  69a0              LDR      r0,[r4,#0x18]         ;1128
000038  0a00              LSRS     r0,r0,#8              ;1128
00003a  0200              LSLS     r0,r0,#8              ;1128
00003c  1c40              ADDS     r0,r0,#1              ;1128
00003e  61a0              STR      r0,[r4,#0x18]         ;1128
000040  69a0              LDR      r0,[r4,#0x18]         ;1131
000042  05c0              LSLS     r0,r0,#23             ;1131
000044  d402              BMI      |L24.76|
000046  4620              MOV      r0,r4                 ;1132
000048  f7fffffe          BL       _RMP_Set_Rdy
                  |L24.76|
00004c  2004              MOVS     r0,#4                 ;1134
00004e  43c0              MVNS     r0,r0                 ;1134
000050  63a0              STR      r0,[r4,#0x38]         ;1134
000052  f7fffffe          BL       RMP_Unlock_Sched
000056  2000              MOVS     r0,#0                 ;1138
000058  bd10              POP      {r4,pc}
;;;1140   /* End Function:RMP_Thd_Cancel ***********************************************/
                          ENDP

00005a  0000              DCW      0x0000
                  |L24.92|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Crt||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Crt PROC
;;;590    ******************************************************************************/
;;;591    ret_t RMP_Thd_Crt(volatile struct RMP_Thd* Thread, void* Entry, void* Stack, void* Arg, ptr_t Prio, ptr_t Slices)
000000  b5ff              PUSH     {r0-r7,lr}
;;;592    {
000002  b081              SUB      sp,sp,#4
;;;593        /* Check if the priority and timeslice range is correct */
;;;594        if(Prio>=RMP_MAX_PREEMPT_PRIO)
000004  9f0a              LDR      r7,[sp,#0x28]
000006  9e0b              LDR      r6,[sp,#0x2c]
000008  4604              MOV      r4,r0                 ;592
00000a  2f20              CMP      r7,#0x20
00000c  d303              BCC      |L25.22|
;;;595            return RMP_ERR_PRIO;
00000e  2001              MOVS     r0,#1
000010  43c0              MVNS     r0,r0
;;;596        if((Slices==0)||(Slices>=RMP_MAX_SLICES))
;;;597            return RMP_ERR_SLICE;
;;;598        
;;;599        /* Check if this thread structure could possibly be in use */
;;;600        if(Thread==0)
;;;601            return RMP_ERR_THD;
;;;602        
;;;603        RMP_Lock_Sched();
;;;604        
;;;605        if(RMP_THD_STATE(Thread->State)!=RMP_THD_FREE)
;;;606        {
;;;607            RMP_Unlock_Sched();
;;;608            return RMP_ERR_THD;
;;;609        }
;;;610        
;;;611        /* Create the thread and insert it into the list */
;;;612        Thread->Prio=Prio;
;;;613        Thread->Slices=Slices;
;;;614        Thread->Slices_Left=Slices;
;;;615        Thread->Stack=(ptr_t)Stack;
;;;616        
;;;617        /* Initialize its stack and sending list */
;;;618        _RMP_Stack_Init((ptr_t)Entry, (ptr_t)Stack, (ptr_t)Arg);
;;;619        RMP_List_Crt(&(Thread->Snd_List));
;;;620        
;;;621        /* Notify the scheduler that we have created something new, also check locks */
;;;622        Thread->State=RMP_THD_RUNNING;
;;;623        _RMP_Set_Rdy(Thread);
;;;624        
;;;625        RMP_Unlock_Sched();
;;;626    
;;;627        return 0;
;;;628    }
000012  b005              ADD      sp,sp,#0x14
000014  bdf0              POP      {r4-r7,pc}
                  |L25.22|
000016  2e00              CMP      r6,#0                 ;596
000018  d002              BEQ      |L25.32|
00001a  481a              LDR      r0,|L25.132|
00001c  4286              CMP      r6,r0                 ;596
00001e  d303              BCC      |L25.40|
                  |L25.32|
000020  2002              MOVS     r0,#2                 ;597
000022  43c0              MVNS     r0,r0                 ;597
000024  b005              ADD      sp,sp,#0x14
000026  bdf0              POP      {r4-r7,pc}
                  |L25.40|
000028  2c00              CMP      r4,#0                 ;600
00002a  d010              BEQ      |L25.78|
00002c  f7fffffe          BL       RMP_Disable_Int
000030  4815              LDR      r0,|L25.136|
000032  2501              MOVS     r5,#1                 ;600
000034  60c5              STR      r5,[r0,#0xc]          ;600  ; RMP_Sched_Locked
000036  6881              LDR      r1,[r0,#8]            ;600  ; RMP_Sched_Lock_Cnt
000038  1c49              ADDS     r1,r1,#1              ;600
00003a  6081              STR      r1,[r0,#8]            ;600  ; RMP_Sched_Lock_Cnt
00003c  69a0              LDR      r0,[r4,#0x18]         ;605
00003e  0600              LSLS     r0,r0,#24             ;605
000040  0e00              LSRS     r0,r0,#24             ;605
000042  d008              BEQ      |L25.86|
000044  f7fffffe          BL       RMP_Unlock_Sched
000048  1ea8              SUBS     r0,r5,#2              ;608
00004a  b005              ADD      sp,sp,#0x14
00004c  bdf0              POP      {r4-r7,pc}
                  |L25.78|
00004e  2000              MOVS     r0,#0                 ;601
000050  43c0              MVNS     r0,r0                 ;601
000052  b005              ADD      sp,sp,#0x14
000054  bdf0              POP      {r4-r7,pc}
                  |L25.86|
000056  6267              STR      r7,[r4,#0x24]         ;612
000058  61e6              STR      r6,[r4,#0x1c]         ;613
00005a  6226              STR      r6,[r4,#0x20]         ;614
00005c  9803              LDR      r0,[sp,#0xc]          ;615
00005e  6360              STR      r0,[r4,#0x34]         ;615
000060  9a04              LDR      r2,[sp,#0x10]         ;618
000062  9903              LDR      r1,[sp,#0xc]          ;618
000064  9802              LDR      r0,[sp,#8]            ;618
000066  f7fffffe          BL       _RMP_Stack_Init
00006a  4620              MOV      r0,r4                 ;619
00006c  3010              ADDS     r0,r0,#0x10           ;619
00006e  6120              STR      r0,[r4,#0x10]         ;619
000070  6160              STR      r0,[r4,#0x14]         ;619
000072  61a5              STR      r5,[r4,#0x18]         ;622
000074  4620              MOV      r0,r4                 ;623
000076  f7fffffe          BL       _RMP_Set_Rdy
00007a  f7fffffe          BL       RMP_Unlock_Sched
00007e  2000              MOVS     r0,#0                 ;627
000080  b005              ADD      sp,sp,#0x14
000082  bdf0              POP      {r4-r7,pc}
;;;629    /* End Function:RMP_Thd_Crt **************************************************/
                          ENDP

                  |L25.132|
                          DCD      0x000186a0
                  |L25.136|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Del||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Del PROC
;;;636    ******************************************************************************/
;;;637    ret_t RMP_Thd_Del(volatile struct RMP_Thd* Thread)
000000  b5f8              PUSH     {r3-r7,lr}
;;;638    {
;;;639        struct RMP_Thd* Release;
;;;640        ptr_t Self_Del;
;;;641        
;;;642        /* Check if this thread structure could possibly be in use */
;;;643        if(Thread==0)
;;;644            return RMP_ERR_THD;
000002  4d38              LDR      r5,|L26.228|
000004  0004              MOVS     r4,r0                 ;638
000006  d01a              BEQ      |L26.62|
000008  f7fffffe          BL       RMP_Disable_Int
00000c  4836              LDR      r0,|L26.232|
00000e  2101              MOVS     r1,#1                 ;638
000010  60c1              STR      r1,[r0,#0xc]          ;638  ; RMP_Sched_Locked
000012  6881              LDR      r1,[r0,#8]            ;638  ; RMP_Sched_Lock_Cnt
000014  1c49              ADDS     r1,r1,#1              ;638
000016  6081              STR      r1,[r0,#8]            ;638  ; RMP_Sched_Lock_Cnt
;;;645        
;;;646        RMP_Lock_Sched();
;;;647        
;;;648        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
000018  69a0              LDR      r0,[r4,#0x18]
00001a  0600              LSLS     r0,r0,#24
00001c  0e00              LSRS     r0,r0,#24
00001e  d010              BEQ      |L26.66|
;;;649        {
;;;650            RMP_Unlock_Sched();
;;;651            return RMP_ERR_THD;
;;;652        }
;;;653        
;;;654        /* See if anyone waiting to send to this thread. If there is, release all these threads */
;;;655        while(&(Thread->Snd_List)!=Thread->Snd_List.Next)
000020  6960              LDR      r0,[r4,#0x14]
000022  4627              MOV      r7,r4
000024  3710              ADDS     r7,r7,#0x10
;;;656        {
;;;657            Release=(struct RMP_Thd*)(Thread->Snd_List.Next);
;;;658            RMP_List_Del(Release->Run_Head.Prev,Release->Run_Head.Next);
;;;659            if(RMP_THD_STATE(Release->State)==RMP_THD_SNDDLY)
;;;660                RMP_List_Del(Release->Dly_Head.Prev,Release->Dly_Head.Next);
;;;661    
;;;662            RMP_THD_STATE_SET(Release->State,RMP_THD_RUNNING);
;;;663    
;;;664            /* Is it suspended? If yes, we can't directly send it running */
;;;665            if((Release->State&RMP_THD_SUSPENDED)==0)
;;;666               _RMP_Set_Rdy(Release);
;;;667            
;;;668            Release->Retval=RMP_ERR_OPER;
000026  1f2e              SUBS     r6,r5,#4
000028  42b8              CMP      r0,r7                 ;655
00002a  d020              BEQ      |L26.110|
                  |L26.44|
00002c  6965              LDR      r5,[r4,#0x14]         ;657
00002e  6869              LDR      r1,[r5,#4]            ;657
000030  6828              LDR      r0,[r5,#0]            ;657
000032  6008              STR      r0,[r1,#0]            ;657
000034  6041              STR      r1,[r0,#4]            ;657
000036  7e28              LDRB     r0,[r5,#0x18]         ;659
000038  2803              CMP      r0,#3                 ;659
00003a  d006              BEQ      |L26.74|
00003c  e009              B        |L26.82|
                  |L26.62|
00003e  4628              MOV      r0,r5                 ;644
;;;669        }
;;;670        
;;;671        /* See what is it state */
;;;672        Self_Del=0;
;;;673        if(RMP_Cur_Thd==Thread)
;;;674            Self_Del=1;
;;;675        
;;;676        switch(RMP_THD_STATE(Thread->State))
;;;677        {
;;;678            case RMP_THD_RUNNING:
;;;679            {
;;;680                if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;681                    _RMP_Clr_Rdy(Thread);
;;;682                break;
;;;683            }
;;;684            
;;;685            case RMP_THD_SNDDLY:
;;;686            case RMP_THD_SEMDLY:
;;;687            {
;;;688                if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;689                    RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;690                RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;691                Thread->Retval=RMP_ERR_OPER;
;;;692                break;
;;;693            }
;;;694                
;;;695            case RMP_THD_RCVDLY:
;;;696            {
;;;697                RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;698                Thread->Retval=RMP_ERR_OPER;
;;;699                break;
;;;700            }
;;;701                
;;;702            case RMP_THD_DELAYED:
;;;703            {
;;;704                RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;705                Thread->Retval=RMP_ERR_OPER;
;;;706                break;
;;;707            }
;;;708            /* Should not get here */
;;;709            default:break;
;;;710        }
;;;711        Thread->State=RMP_THD_FREE;
;;;712        
;;;713        RMP_Unlock_Sched();
;;;714        
;;;715        /* If we are deleting ourself, just stop the execution here */
;;;716        if(Self_Del!=0)
;;;717            while(1);
;;;718    
;;;719        return 0;
;;;720    }
000040  bdf8              POP      {r3-r7,pc}
                  |L26.66|
000042  f7fffffe          BL       RMP_Unlock_Sched
000046  4628              MOV      r0,r5                 ;651
000048  bdf8              POP      {r3-r7,pc}
                  |L26.74|
00004a  68e9              LDR      r1,[r5,#0xc]
00004c  68a8              LDR      r0,[r5,#8]
00004e  6008              STR      r0,[r1,#0]
000050  6041              STR      r1,[r0,#4]
                  |L26.82|
000052  69a8              LDR      r0,[r5,#0x18]         ;662
000054  0a00              LSRS     r0,r0,#8              ;662
000056  0200              LSLS     r0,r0,#8              ;662
000058  1c40              ADDS     r0,r0,#1              ;662
00005a  61a8              STR      r0,[r5,#0x18]         ;665
00005c  05c0              LSLS     r0,r0,#23             ;665
00005e  d402              BMI      |L26.102|
000060  4628              MOV      r0,r5                 ;666
000062  f7fffffe          BL       _RMP_Set_Rdy
                  |L26.102|
000066  63ae              STR      r6,[r5,#0x38]         ;655
000068  6960              LDR      r0,[r4,#0x14]         ;655
00006a  42b8              CMP      r0,r7                 ;655
00006c  d1de              BNE      |L26.44|
                  |L26.110|
00006e  481e              LDR      r0,|L26.232|
000070  2500              MOVS     r5,#0                 ;672
000072  6980              LDR      r0,[r0,#0x18]         ;673  ; RMP_Cur_Thd
000074  42a0              CMP      r0,r4                 ;673
000076  d100              BNE      |L26.122|
000078  2501              MOVS     r5,#1                 ;674
                  |L26.122|
00007a  69a0              LDR      r0,[r4,#0x18]         ;676
00007c  b2c0              UXTB     r0,r0                 ;676
00007e  2809              CMP      r0,#9                 ;676
000080  d227              BCS      |L26.210|
000082  0001              MOVS     r1,r0                 ;676
000084  4479              ADD      r1,r1,pc              ;676
000086  7909              LDRB     r1,[r1,#4]            ;676
000088  1849              ADDS     r1,r1,r1              ;676
00008a  448f              ADD      pc,pc,r1              ;676
00008c  2204220b          DCB      0x22,0x04,0x22,0x0b
000090  22181d22          DCB      0x22,0x18,0x1d,0x22
000094  0b00              DCB      0x0b,0x00
000096  69a0              LDR      r0,[r4,#0x18]         ;680
000098  05c0              LSLS     r0,r0,#23             ;680
00009a  d41a              BMI      |L26.210|
00009c  4620              MOV      r0,r4                 ;681
00009e  f7fffffe          BL       _RMP_Clr_Rdy
0000a2  e016              B        |L26.210|
0000a4  69a0              LDR      r0,[r4,#0x18]         ;688
0000a6  05c0              LSLS     r0,r0,#23             ;688
0000a8  d403              BMI      |L26.178|
0000aa  6821              LDR      r1,[r4,#0]            ;689
0000ac  6860              LDR      r0,[r4,#4]            ;689
0000ae  6001              STR      r1,[r0,#0]            ;689
0000b0  6048              STR      r0,[r1,#4]            ;689
                  |L26.178|
0000b2  68a0              LDR      r0,[r4,#8]            ;690
0000b4  68e1              LDR      r1,[r4,#0xc]          ;690
0000b6  6008              STR      r0,[r1,#0]            ;690
0000b8  6041              STR      r1,[r0,#4]            ;690
                  |L26.186|
0000ba  63a6              STR      r6,[r4,#0x38]         ;691
0000bc  e009              B        |L26.210|
0000be  68a1              LDR      r1,[r4,#8]            ;697
0000c0  68e0              LDR      r0,[r4,#0xc]          ;697
0000c2  6001              STR      r1,[r0,#0]            ;697
0000c4  6048              STR      r0,[r1,#4]            ;697
0000c6  e7f8              B        |L26.186|
0000c8  68a1              LDR      r1,[r4,#8]            ;704
0000ca  68e0              LDR      r0,[r4,#0xc]          ;704
0000cc  6001              STR      r1,[r0,#0]            ;704
0000ce  6048              STR      r0,[r1,#4]            ;704
0000d0  63a6              STR      r6,[r4,#0x38]         ;705
                  |L26.210|
0000d2  2000              MOVS     r0,#0                 ;711
0000d4  61a0              STR      r0,[r4,#0x18]         ;711
0000d6  f7fffffe          BL       RMP_Unlock_Sched
0000da  2d00              CMP      r5,#0                 ;716
0000dc  d000              BEQ      |L26.224|
                  |L26.222|
0000de  e7fe              B        |L26.222|
                  |L26.224|
0000e0  2000              MOVS     r0,#0                 ;719
0000e2  bdf8              POP      {r3-r7,pc}
;;;721    /* End Function:RMP_Thd_Del **************************************************/
                          ENDP

                  |L26.228|
                          DCD      0xffffffff
                  |L26.232|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Delay||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Delay PROC
;;;1083   ******************************************************************************/
;;;1084   ret_t RMP_Thd_Delay(ptr_t Slices)
000000  b570              PUSH     {r4-r6,lr}
;;;1085   {
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L27.12|
;;;1086       if((Slices==0)||(Slices>=RMP_MAX_SLICES))
000006  481a              LDR      r0,|L27.112|
000008  4284              CMP      r4,r0
00000a  d302              BCC      |L27.18|
                  |L27.12|
;;;1087           return RMP_ERR_SLICE;
00000c  2002              MOVS     r0,#2
00000e  43c0              MVNS     r0,r0
;;;1088       
;;;1089       RMP_Lock_Sched();
;;;1090   
;;;1091       /* We must be running */
;;;1092       _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1093       RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_DELAYED);
;;;1094       _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1095   
;;;1096       RMP_Cur_Thd->Retval=0;
;;;1097       
;;;1098       RMP_Unlock_Sched();
;;;1099       
;;;1100       /* Need to return if successful or not */
;;;1101       return RMP_Cur_Thd->Retval;
;;;1102   }
000010  bd70              POP      {r4-r6,pc}
                  |L27.18|
000012  f7fffffe          BL       RMP_Disable_Int
000016  4d17              LDR      r5,|L27.116|
000018  2001              MOVS     r0,#1
00001a  60e8              STR      r0,[r5,#0xc]  ; RMP_Sched_Locked
00001c  68a8              LDR      r0,[r5,#8]  ; RMP_Sched_Lock_Cnt
00001e  1c40              ADDS     r0,r0,#1
000020  60a8              STR      r0,[r5,#8]  ; RMP_Sched_Lock_Cnt
000022  69a8              LDR      r0,[r5,#0x18]         ;1092  ; RMP_Cur_Thd
000024  f7fffffe          BL       _RMP_Clr_Rdy
000028  69a8              LDR      r0,[r5,#0x18]         ;1093  ; RMP_Cur_Thd
00002a  69a9              LDR      r1,[r5,#0x18]         ;1093  ; RMP_Cur_Thd
00002c  6980              LDR      r0,[r0,#0x18]         ;1093
00002e  0a00              LSRS     r0,r0,#8              ;1093
000030  0200              LSLS     r0,r0,#8              ;1093
000032  1d80              ADDS     r0,r0,#6              ;1093
000034  6188              STR      r0,[r1,#0x18]         ;1094
000036  69aa              LDR      r2,[r5,#0x18]         ;1094  ; RMP_Cur_Thd
000038  480f              LDR      r0,|L27.120|
00003a  6841              LDR      r1,[r0,#4]            ;1094  ; RMP_Delay
00003c  4281              CMP      r1,r0                 ;1094
00003e  d006              BEQ      |L27.78|
000040  6a0b              LDR      r3,[r1,#0x20]         ;1094
                  |L27.66|
000042  686e              LDR      r6,[r5,#4]            ;1094  ; RMP_Tick
000044  1b9e              SUBS     r6,r3,r6              ;1094
000046  42a6              CMP      r6,r4                 ;1094
000048  d801              BHI      |L27.78|
00004a  4281              CMP      r1,r0                 ;1094
00004c  d1f9              BNE      |L27.66|
                  |L27.78|
00004e  6868              LDR      r0,[r5,#4]            ;1094  ; RMP_Tick
000050  1900              ADDS     r0,r0,r4              ;1094
000052  6290              STR      r0,[r2,#0x28]         ;1094
000054  3208              ADDS     r2,r2,#8              ;1094
000056  6808              LDR      r0,[r1,#0]            ;1094
000058  600a              STR      r2,[r1,#0]            ;1094
00005a  6051              STR      r1,[r2,#4]            ;1094
00005c  6010              STR      r0,[r2,#0]            ;1094
00005e  6042              STR      r2,[r0,#4]            ;1094
000060  69a9              LDR      r1,[r5,#0x18]         ;1096  ; RMP_Cur_Thd
000062  2000              MOVS     r0,#0                 ;1096
000064  6388              STR      r0,[r1,#0x38]         ;1098
000066  f7fffffe          BL       RMP_Unlock_Sched
00006a  69a8              LDR      r0,[r5,#0x18]         ;1101  ; RMP_Cur_Thd
00006c  6b80              LDR      r0,[r0,#0x38]         ;1101
00006e  bd70              POP      {r4-r6,pc}
;;;1103   /* End Function:RMP_Thd_Delay ************************************************/
                          ENDP

                  |L27.112|
                          DCD      0x000186a0
                  |L27.116|
                          DCD      ||.data||
                  |L27.120|
                          DCD      ||.data||+0x20

                          AREA ||i.RMP_Thd_Rcv||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Rcv PROC
;;;1004   ******************************************************************************/
;;;1005   ret_t RMP_Thd_Rcv(ptr_t* Data, ptr_t Slices)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1006   {
000002  460d              MOV      r5,r1
000004  4606              MOV      r6,r0
000006  f7fffffe          BL       RMP_Disable_Int
00000a  4c40              LDR      r4,|L28.268|
00000c  2001              MOVS     r0,#1
00000e  60e0              STR      r0,[r4,#0xc]  ; RMP_Sched_Locked
000010  68a0              LDR      r0,[r4,#8]  ; RMP_Sched_Lock_Cnt
000012  1c40              ADDS     r0,r0,#1
000014  60a0              STR      r0,[r4,#8]  ; RMP_Sched_Lock_Cnt
;;;1007       struct RMP_Thd* Sender;
;;;1008       
;;;1009       RMP_Lock_Sched();
;;;1010   
;;;1011       /* Check if there is a value in our mailbox. If yes, we return with that value */
;;;1012       if((RMP_Cur_Thd->State&RMP_THD_MBOXFUL)!=0)
000016  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
000018  8b00              LDRH     r0,[r0,#0x18]
00001a  0580              LSLS     r0,r0,#22
;;;1013       {
;;;1014           /* Get the value from mailbox */
;;;1015           *Data=RMP_Cur_Thd->Mailbox;
;;;1016           RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
;;;1017           RMP_Unlock_Sched();
;;;1018           return 0;
;;;1019       }
;;;1020       else
;;;1021       {
;;;1022           /* Is there any other guy waiting on us? If there is, unblock it and set it running */
;;;1023           if(&(RMP_Cur_Thd->Snd_List)!=RMP_Cur_Thd->Snd_List.Next)
00001c  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
00001e  d50b              BPL      |L28.56|
000020  6ac0              LDR      r0,[r0,#0x2c]         ;1015
000022  6030              STR      r0,[r6,#0]            ;1016
000024  69a0              LDR      r0,[r4,#0x18]         ;1016  ; RMP_Cur_Thd
000026  2101              MOVS     r1,#1                 ;1016
000028  6982              LDR      r2,[r0,#0x18]         ;1016
00002a  0249              LSLS     r1,r1,#9              ;1016
00002c  438a              BICS     r2,r2,r1              ;1016
00002e  6182              STR      r2,[r0,#0x18]         ;1017
000030  f7fffffe          BL       RMP_Unlock_Sched
000034  2000              MOVS     r0,#0                 ;1018
;;;1024           {
;;;1025               /* Read the data */
;;;1026               Sender=(struct RMP_Thd*)(RMP_Cur_Thd->Snd_List.Next);
;;;1027               RMP_List_Del(Sender->Run_Head.Prev,Sender->Run_Head.Next);
;;;1028               *Data=Sender->Data;
;;;1029               /* Now we unblock it - what state is it in? */
;;;1030               if((RMP_THD_STATE(Sender->State)==RMP_THD_SNDDLY))
;;;1031                   RMP_List_Del(Sender->Dly_Head.Prev,Sender->Dly_Head.Next);
;;;1032               
;;;1033               RMP_THD_STATE_SET(Sender->State,RMP_THD_RUNNING);
;;;1034   
;;;1035               /* Is it suspended? If yes, we can't directly send it running */
;;;1036               if((Sender->State&RMP_THD_SUSPENDED)==0)
;;;1037                   _RMP_Set_Rdy(Sender);
;;;1038               
;;;1039               RMP_Unlock_Sched();
;;;1040           }
;;;1041           /* No sender waiting on us, we need to block */
;;;1042           else
;;;1043           {
;;;1044               /* No such value in our mailbox, we need to block */
;;;1045               if(Slices==0)
;;;1046               {
;;;1047                   RMP_Unlock_Sched();
;;;1048                   return RMP_ERR_OPER;
;;;1049               }
;;;1050   
;;;1051               /* We must be running */
;;;1052               _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1053   
;;;1054               if(Slices<RMP_MAX_SLICES)
;;;1055               {
;;;1056                   _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1057                   RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVDLY);
;;;1058               }
;;;1059               else
;;;1060                   RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVBLK);
;;;1061               
;;;1062               RMP_Unlock_Sched();
;;;1063               /* Dummy read - to separate the lock & unlock. If the compiler optimizes these two
;;;1064                * functions(inline them) on some architectures sometimes we never block. */
;;;1065               *Data=RMP_Cur_Thd->Mailbox;
;;;1066               /* We've been unblocked. There must be something in our mbox, or we should have failed */
;;;1067               RMP_Lock_Sched();
;;;1068               *Data=RMP_Cur_Thd->Mailbox;
;;;1069               RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
;;;1070               RMP_Unlock_Sched();
;;;1071           }
;;;1072       }
;;;1073       
;;;1074       return RMP_Cur_Thd->Retval;
;;;1075   }
000036  bdf8              POP      {r3-r7,pc}
                  |L28.56|
000038  6941              LDR      r1,[r0,#0x14]         ;1023
00003a  69a0              LDR      r0,[r4,#0x18]         ;1023  ; RMP_Cur_Thd
00003c  3010              ADDS     r0,r0,#0x10           ;1023
00003e  4281              CMP      r1,r0                 ;1023
000040  d01a              BEQ      |L28.120|
000042  69a0              LDR      r0,[r4,#0x18]         ;1026  ; RMP_Cur_Thd
000044  6940              LDR      r0,[r0,#0x14]         ;1026
000046  6842              LDR      r2,[r0,#4]            ;1026
000048  6801              LDR      r1,[r0,#0]            ;1026
00004a  6011              STR      r1,[r2,#0]            ;1026
00004c  604a              STR      r2,[r1,#4]            ;1026
00004e  6b01              LDR      r1,[r0,#0x30]         ;1028
000050  6031              STR      r1,[r6,#0]            ;1030
000052  7e01              LDRB     r1,[r0,#0x18]         ;1030
000054  2903              CMP      r1,#3                 ;1030
000056  d103              BNE      |L28.96|
000058  68c2              LDR      r2,[r0,#0xc]          ;1030
00005a  6881              LDR      r1,[r0,#8]            ;1030
00005c  6011              STR      r1,[r2,#0]            ;1030
00005e  604a              STR      r2,[r1,#4]            ;1030
                  |L28.96|
000060  6981              LDR      r1,[r0,#0x18]         ;1033
000062  0a09              LSRS     r1,r1,#8              ;1033
000064  0209              LSLS     r1,r1,#8              ;1033
000066  1c49              ADDS     r1,r1,#1              ;1033
000068  6181              STR      r1,[r0,#0x18]         ;1036
00006a  05c9              LSLS     r1,r1,#23             ;1036
00006c  d401              BMI      |L28.114|
00006e  f7fffffe          BL       _RMP_Set_Rdy
                  |L28.114|
000072  f7fffffe          BL       RMP_Unlock_Sched
000076  e03a              B        |L28.238|
                  |L28.120|
000078  2d00              CMP      r5,#0                 ;1045
00007a  d03b              BEQ      |L28.244|
00007c  69a0              LDR      r0,[r4,#0x18]         ;1052  ; RMP_Cur_Thd
00007e  f7fffffe          BL       _RMP_Clr_Rdy
000082  4823              LDR      r0,|L28.272|
000084  4285              CMP      r5,r0                 ;1054
000086  d23a              BCS      |L28.254|
000088  69a2              LDR      r2,[r4,#0x18]         ;1056  ; RMP_Cur_Thd
00008a  4922              LDR      r1,|L28.276|
00008c  6848              LDR      r0,[r1,#4]            ;1056  ; RMP_Delay
00008e  4288              CMP      r0,r1                 ;1056
000090  d006              BEQ      |L28.160|
000092  6a03              LDR      r3,[r0,#0x20]         ;1056
                  |L28.148|
000094  6867              LDR      r7,[r4,#4]            ;1056  ; RMP_Tick
000096  1bdf              SUBS     r7,r3,r7              ;1056
000098  42af              CMP      r7,r5                 ;1056
00009a  d801              BHI      |L28.160|
00009c  4288              CMP      r0,r1                 ;1056
00009e  d1f9              BNE      |L28.148|
                  |L28.160|
0000a0  6861              LDR      r1,[r4,#4]            ;1056  ; RMP_Tick
0000a2  1949              ADDS     r1,r1,r5              ;1056
0000a4  6291              STR      r1,[r2,#0x28]         ;1056
0000a6  3208              ADDS     r2,r2,#8              ;1056
0000a8  6801              LDR      r1,[r0,#0]            ;1056
0000aa  6002              STR      r2,[r0,#0]            ;1056
0000ac  6050              STR      r0,[r2,#4]            ;1056
0000ae  6011              STR      r1,[r2,#0]            ;1056
0000b0  604a              STR      r2,[r1,#4]            ;1056
0000b2  69a0              LDR      r0,[r4,#0x18]         ;1057  ; RMP_Cur_Thd
0000b4  69a1              LDR      r1,[r4,#0x18]         ;1057  ; RMP_Cur_Thd
0000b6  6980              LDR      r0,[r0,#0x18]         ;1057
0000b8  0a00              LSRS     r0,r0,#8              ;1057
0000ba  0200              LSLS     r0,r0,#8              ;1057
0000bc  1d40              ADDS     r0,r0,#5              ;1057
                  |L28.190|
0000be  6188              STR      r0,[r1,#0x18]         ;1062
0000c0  f7fffffe          BL       RMP_Unlock_Sched
0000c4  69a0              LDR      r0,[r4,#0x18]         ;1065  ; RMP_Cur_Thd
0000c6  6ac0              LDR      r0,[r0,#0x2c]         ;1065
0000c8  6030              STR      r0,[r6,#0]            ;1065
0000ca  f7fffffe          BL       RMP_Disable_Int
0000ce  2001              MOVS     r0,#1                 ;1065
0000d0  60e0              STR      r0,[r4,#0xc]          ;1065  ; RMP_Sched_Locked
0000d2  68a0              LDR      r0,[r4,#8]            ;1065  ; RMP_Sched_Lock_Cnt
0000d4  1c40              ADDS     r0,r0,#1              ;1065
0000d6  60a0              STR      r0,[r4,#8]            ;1065  ; RMP_Sched_Lock_Cnt
0000d8  69a0              LDR      r0,[r4,#0x18]         ;1068  ; RMP_Cur_Thd
0000da  6ac0              LDR      r0,[r0,#0x2c]         ;1068
0000dc  6030              STR      r0,[r6,#0]            ;1069
0000de  69a0              LDR      r0,[r4,#0x18]         ;1069  ; RMP_Cur_Thd
0000e0  2201              MOVS     r2,#1                 ;1069
0000e2  6981              LDR      r1,[r0,#0x18]         ;1069
0000e4  0252              LSLS     r2,r2,#9              ;1069
0000e6  4391              BICS     r1,r1,r2              ;1069
0000e8  6181              STR      r1,[r0,#0x18]         ;1070
0000ea  f7fffffe          BL       RMP_Unlock_Sched
                  |L28.238|
0000ee  69a0              LDR      r0,[r4,#0x18]         ;1074  ; RMP_Cur_Thd
0000f0  6b80              LDR      r0,[r0,#0x38]         ;1074
0000f2  bdf8              POP      {r3-r7,pc}
                  |L28.244|
0000f4  f7fffffe          BL       RMP_Unlock_Sched
0000f8  2004              MOVS     r0,#4                 ;1048
0000fa  43c0              MVNS     r0,r0                 ;1048
0000fc  bdf8              POP      {r3-r7,pc}
                  |L28.254|
0000fe  69a0              LDR      r0,[r4,#0x18]         ;1060  ; RMP_Cur_Thd
000100  69a1              LDR      r1,[r4,#0x18]         ;1060  ; RMP_Cur_Thd
000102  6980              LDR      r0,[r0,#0x18]         ;1060
000104  0a00              LSRS     r0,r0,#8              ;1060
000106  0200              LSLS     r0,r0,#8              ;1060
000108  1d00              ADDS     r0,r0,#4              ;1060
00010a  e7d8              B        |L28.190|
;;;1076   /* End Function:RMP_Thd_Rcv **************************************************/
                          ENDP

                  |L28.268|
                          DCD      ||.data||
                  |L28.272|
                          DCD      0x000186a0
                  |L28.276|
                          DCD      ||.data||+0x20

                          AREA ||i.RMP_Thd_Resume||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Resume PROC
;;;826    ******************************************************************************/
;;;827    ret_t RMP_Thd_Resume(volatile struct RMP_Thd* Thread)
000000  b570              PUSH     {r4-r6,lr}
;;;828    {
;;;829        ret_t Retval;
;;;830        
;;;831        /* Check if this thread structure could possibly be in use */
;;;832        if(Thread==0)
;;;833            return RMP_ERR_THD;
000002  4d16              LDR      r5,|L29.92|
000004  0004              MOVS     r4,r0                 ;828
000006  d018              BEQ      |L29.58|
000008  f7fffffe          BL       RMP_Disable_Int
00000c  4814              LDR      r0,|L29.96|
00000e  2101              MOVS     r1,#1                 ;828
000010  60c1              STR      r1,[r0,#0xc]          ;828  ; RMP_Sched_Locked
000012  6881              LDR      r1,[r0,#8]            ;828  ; RMP_Sched_Lock_Cnt
000014  1c49              ADDS     r1,r1,#1              ;828
000016  6081              STR      r1,[r0,#8]            ;828  ; RMP_Sched_Lock_Cnt
;;;834    
;;;835        RMP_Lock_Sched();
;;;836        
;;;837        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
000018  69a0              LDR      r0,[r4,#0x18]
00001a  0600              LSLS     r0,r0,#24
00001c  0e00              LSRS     r0,r0,#24
00001e  d00e              BEQ      |L29.62|
;;;838        {
;;;839            RMP_Unlock_Sched();
;;;840            return RMP_ERR_THD;
;;;841        }
;;;842        
;;;843        /* Check if the thread is suspended, if not, then throw an error */
;;;844        if((Thread->State&RMP_THD_SUSPENDED)!=0)
000020  69a0              LDR      r0,[r4,#0x18]
000022  05c0              LSLS     r0,r0,#23
000024  d514              BPL      |L29.80|
;;;845        {
;;;846            /* Suspended */
;;;847            Thread->State&=~RMP_THD_SUSPENDED;
000026  69a0              LDR      r0,[r4,#0x18]
000028  21ff              MOVS     r1,#0xff
00002a  3101              ADDS     r1,#1
00002c  4388              BICS     r0,r0,r1
00002e  61a0              STR      r0,[r4,#0x18]
;;;848            if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
000030  69a0              LDR      r0,[r4,#0x18]
000032  b2c0              UXTB     r0,r0
000034  2801              CMP      r0,#1
000036  d006              BEQ      |L29.70|
000038  e008              B        |L29.76|
                  |L29.58|
00003a  4628              MOV      r0,r5                 ;833
;;;849                _RMP_Set_Rdy(Thread);
;;;850            Retval=0;
;;;851        }
;;;852        else
;;;853            Retval=RMP_ERR_STATE;
;;;854        
;;;855        RMP_Unlock_Sched();
;;;856    
;;;857        return Retval;
;;;858    }
00003c  bd70              POP      {r4-r6,pc}
                  |L29.62|
00003e  f7fffffe          BL       RMP_Unlock_Sched
000042  4628              MOV      r0,r5                 ;840
000044  bd70              POP      {r4-r6,pc}
                  |L29.70|
000046  4620              MOV      r0,r4                 ;849
000048  f7fffffe          BL       _RMP_Set_Rdy
                  |L29.76|
00004c  2400              MOVS     r4,#0                 ;850
00004e  e001              B        |L29.84|
                  |L29.80|
000050  2403              MOVS     r4,#3                 ;853
000052  43e4              MVNS     r4,r4                 ;853
                  |L29.84|
000054  f7fffffe          BL       RMP_Unlock_Sched
000058  4620              MOV      r0,r4                 ;857
00005a  bd70              POP      {r4-r6,pc}
;;;859    /* End Function:RMP_Thd_Resume ***********************************************/
                          ENDP

                  |L29.92|
                          DCD      0xffffffff
                  |L29.96|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Set||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Set PROC
;;;732    ******************************************************************************/
;;;733    ret_t RMP_Thd_Set(volatile struct RMP_Thd* Thread, ptr_t Prio, ptr_t Slices)
000000  2a00              CMP      r2,#0
;;;734    {
;;;735        /* Check if the priority and timeslice range is correct */
;;;736        if(Slices==0)
000002  d101              BNE      |L30.8|
;;;737            return RMP_ERR_SLICE;
000004  1ed0              SUBS     r0,r2,#3
;;;738        
;;;739        /* Check if this thread structure could possibly be in use */
;;;740        if(Thread==0)
;;;741            return RMP_ERR_THD;
;;;742        
;;;743        RMP_Lock_Sched();
;;;744        
;;;745        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;746        {
;;;747            RMP_Unlock_Sched();
;;;748            return RMP_ERR_THD;
;;;749        }
;;;750        
;;;751        /* See if the thread is in running state */
;;;752        if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;753        {
;;;754            /* See if we are gonna change one of it or both */
;;;755            if(Prio<RMP_MAX_PREEMPT_PRIO)
;;;756            {
;;;757                if(Thread->Prio!=Prio)
;;;758                {
;;;759                    _RMP_Clr_Rdy(Thread);
;;;760                    Thread->Prio=Prio;
;;;761                    _RMP_Set_Rdy(Thread);
;;;762                }
;;;763            }
;;;764            
;;;765            if(Slices<RMP_MAX_SLICES)
;;;766                Thread->Slices=Slices;
;;;767        }
;;;768        else
;;;769        {
;;;770            if(Prio<RMP_MAX_PREEMPT_PRIO)
;;;771                Thread->Prio=Prio;
;;;772            
;;;773            if(Slices<RMP_MAX_SLICES)
;;;774                Thread->Slices=Slices;
;;;775        }
;;;776        
;;;777        RMP_Unlock_Sched();
;;;778        
;;;779        return 0;
;;;780    }
000006  4770              BX       lr
                  |L30.8|
000008  b5f8              PUSH     {r3-r7,lr}            ;734
00000a  4f1a              LDR      r7,|L30.116|
00000c  4615              MOV      r5,r2                 ;734
00000e  460e              MOV      r6,r1                 ;734
000010  0004              MOVS     r4,r0                 ;734
000012  d01a              BEQ      |L30.74|
000014  f7fffffe          BL       RMP_Disable_Int
000018  4817              LDR      r0,|L30.120|
00001a  2101              MOVS     r1,#1                 ;737
00001c  60c1              STR      r1,[r0,#0xc]          ;737  ; RMP_Sched_Locked
00001e  6881              LDR      r1,[r0,#8]            ;737  ; RMP_Sched_Lock_Cnt
000020  1c49              ADDS     r1,r1,#1              ;737
000022  6081              STR      r1,[r0,#8]            ;737  ; RMP_Sched_Lock_Cnt
000024  69a0              LDR      r0,[r4,#0x18]         ;745
000026  0600              LSLS     r0,r0,#24             ;745
000028  0e00              LSRS     r0,r0,#24             ;745
00002a  d010              BEQ      |L30.78|
00002c  69a0              LDR      r0,[r4,#0x18]         ;752
00002e  4f13              LDR      r7,|L30.124|
000030  b2c0              UXTB     r0,r0                 ;752
000032  2801              CMP      r0,#1                 ;752
000034  d00f              BEQ      |L30.86|
000036  2e20              CMP      r6,#0x20              ;770
000038  d200              BCS      |L30.60|
00003a  6266              STR      r6,[r4,#0x24]         ;771
                  |L30.60|
00003c  42bd              CMP      r5,r7                 ;773
00003e  d200              BCS      |L30.66|
                  |L30.64|
000040  61e5              STR      r5,[r4,#0x1c]         ;774
                  |L30.66|
000042  f7fffffe          BL       RMP_Unlock_Sched
000046  2000              MOVS     r0,#0                 ;779
000048  bdf8              POP      {r3-r7,pc}
                  |L30.74|
00004a  4638              MOV      r0,r7                 ;741
00004c  bdf8              POP      {r3-r7,pc}
                  |L30.78|
00004e  f7fffffe          BL       RMP_Unlock_Sched
000052  4638              MOV      r0,r7                 ;748
000054  bdf8              POP      {r3-r7,pc}
                  |L30.86|
000056  2e20              CMP      r6,#0x20              ;755
000058  d209              BCS      |L30.110|
00005a  6a60              LDR      r0,[r4,#0x24]         ;757
00005c  42b0              CMP      r0,r6                 ;757
00005e  d006              BEQ      |L30.110|
000060  4620              MOV      r0,r4                 ;759
000062  f7fffffe          BL       _RMP_Clr_Rdy
000066  6266              STR      r6,[r4,#0x24]         ;760
000068  4620              MOV      r0,r4                 ;761
00006a  f7fffffe          BL       _RMP_Set_Rdy
                  |L30.110|
00006e  42bd              CMP      r5,r7                 ;765
000070  d3e6              BCC      |L30.64|
000072  e7e6              B        |L30.66|
;;;781    /* End Function:RMP_Thd_Set **************************************************/
                          ENDP

                  |L30.116|
                          DCD      0xffffffff
                  |L30.120|
                          DCD      ||.data||
                  |L30.124|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Snd||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Snd PROC
;;;869    ******************************************************************************/
;;;870    ret_t RMP_Thd_Snd(volatile struct RMP_Thd* Thread, ptr_t Data, ptr_t Slices)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;871    {
;;;872        /* Check if this thread structure could possibly be in use */
;;;873        if(Thread==0)
;;;874            return RMP_ERR_THD;
000002  4f40              LDR      r7,|L31.260|
000004  4614              MOV      r4,r2                 ;871
000006  0006              MOVS     r6,r0                 ;871
000008  d044              BEQ      |L31.148|
00000a  f7fffffe          BL       RMP_Disable_Int
00000e  4d3e              LDR      r5,|L31.264|
000010  2001              MOVS     r0,#1                 ;871
000012  60e8              STR      r0,[r5,#0xc]          ;871  ; RMP_Sched_Locked
000014  68a8              LDR      r0,[r5,#8]            ;871  ; RMP_Sched_Lock_Cnt
000016  1c40              ADDS     r0,r0,#1              ;871
000018  60a8              STR      r0,[r5,#8]            ;871  ; RMP_Sched_Lock_Cnt
;;;875        
;;;876        RMP_Lock_Sched();
;;;877        
;;;878        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
00001a  69b0              LDR      r0,[r6,#0x18]
00001c  0600              LSLS     r0,r0,#24
00001e  0e00              LSRS     r0,r0,#24
000020  d03b              BEQ      |L31.154|
;;;879        {
;;;880            RMP_Unlock_Sched();
;;;881            return RMP_ERR_THD;
;;;882        }
;;;883        
;;;884        /* Are we sending to ourself? This is not allowed */
;;;885        if(RMP_Cur_Thd==Thread)
000022  69a8              LDR      r0,[r5,#0x18]  ; RMP_Cur_Thd
;;;886        {
;;;887            RMP_Unlock_Sched();
;;;888            return RMP_ERR_OPER;
000024  1f3f              SUBS     r7,r7,#4
000026  42b0              CMP      r0,r6                 ;885
000028  d037              BEQ      |L31.154|
;;;889        }
;;;890        
;;;891        RMP_Cur_Thd->Retval=0;
00002a  69a9              LDR      r1,[r5,#0x18]  ; RMP_Cur_Thd
00002c  2000              MOVS     r0,#0
;;;892    
;;;893        /* See if there are already a value in the mailbox, if there is, we block */
;;;894        if((Thread->State&RMP_THD_MBOXFUL)!=0)
00002e  6388              STR      r0,[r1,#0x38]
000030  69b0              LDR      r0,[r6,#0x18]
000032  0580              LSLS     r0,r0,#22
000034  d53d              BPL      |L31.178|
;;;895        {
;;;896            /* Mailbox full, we block, and put ourself into the queue */
;;;897            if(Slices==0)
000036  2c00              CMP      r4,#0
000038  d02f              BEQ      |L31.154|
;;;898            {
;;;899                RMP_Unlock_Sched();
;;;900                return RMP_ERR_OPER;
;;;901            }
;;;902    
;;;903            /* We must be running */
;;;904            _RMP_Clr_Rdy(RMP_Cur_Thd);
00003a  69a8              LDR      r0,[r5,#0x18]  ; RMP_Cur_Thd
00003c  f7fffffe          BL       _RMP_Clr_Rdy
;;;905            RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Thread->Snd_List.Prev,&(Thread->Snd_List));
000040  69a8              LDR      r0,[r5,#0x18]  ; RMP_Cur_Thd
000042  6931              LDR      r1,[r6,#0x10]
000044  6130              STR      r0,[r6,#0x10]
000046  3610              ADDS     r6,r6,#0x10
000048  6046              STR      r6,[r0,#4]
00004a  6001              STR      r1,[r0,#0]
00004c  6048              STR      r0,[r1,#4]
;;;906    
;;;907            if(Slices<RMP_MAX_SLICES)
00004e  482f              LDR      r0,|L31.268|
000050  4284              CMP      r4,r0
000052  d227              BCS      |L31.164|
;;;908            {
;;;909                _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
000054  69ab              LDR      r3,[r5,#0x18]  ; RMP_Cur_Thd
000056  4a2e              LDR      r2,|L31.272|
000058  6850              LDR      r0,[r2,#4]  ; RMP_Delay
00005a  4290              CMP      r0,r2
00005c  d006              BEQ      |L31.108|
00005e  6a06              LDR      r6,[r0,#0x20]
                  |L31.96|
000060  6869              LDR      r1,[r5,#4]  ; RMP_Tick
000062  1a71              SUBS     r1,r6,r1
000064  42a1              CMP      r1,r4
000066  d801              BHI      |L31.108|
000068  4290              CMP      r0,r2
00006a  d1f9              BNE      |L31.96|
                  |L31.108|
00006c  6869              LDR      r1,[r5,#4]  ; RMP_Tick
00006e  1909              ADDS     r1,r1,r4
000070  6299              STR      r1,[r3,#0x28]
000072  3308              ADDS     r3,r3,#8
000074  6801              LDR      r1,[r0,#0]
000076  6003              STR      r3,[r0,#0]
000078  6058              STR      r0,[r3,#4]
00007a  6019              STR      r1,[r3,#0]
00007c  604b              STR      r3,[r1,#4]
;;;910                RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDDLY);
00007e  69a8              LDR      r0,[r5,#0x18]  ; RMP_Cur_Thd
000080  69a9              LDR      r1,[r5,#0x18]  ; RMP_Cur_Thd
000082  6980              LDR      r0,[r0,#0x18]
000084  0a00              LSRS     r0,r0,#8
000086  0200              LSLS     r0,r0,#8
000088  1cc0              ADDS     r0,r0,#3
                  |L31.138|
;;;911            }
;;;912            else
;;;913                RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDBLK);
;;;914    
;;;915            RMP_Cur_Thd->Data=Data;
00008a  6188              STR      r0,[r1,#0x18]
00008c  9801              LDR      r0,[sp,#4]
00008e  69a9              LDR      r1,[r5,#0x18]  ; RMP_Cur_Thd
000090  6308              STR      r0,[r1,#0x30]
000092  e030              B        |L31.246|
                  |L31.148|
000094  4638              MOV      r0,r7                 ;874
;;;916        }
;;;917        else
;;;918        {
;;;919            /* Mailbox not full. We need to check if the receiver is waiting for us */
;;;920            if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
;;;921               (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
;;;922            {
;;;923                /* The receiver is blocked, wake it up and return the value */
;;;924                if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
;;;925                    RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;926                
;;;927                RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;928    
;;;929                /* Is it suspended? If yes, we can't directly send it running */
;;;930                if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;931                    _RMP_Set_Rdy(Thread);
;;;932            }
;;;933            
;;;934            /* Set the mailbox */
;;;935            Thread->Mailbox=Data;
;;;936            Thread->State|=RMP_THD_MBOXFUL;
;;;937        }
;;;938        
;;;939        RMP_Unlock_Sched();
;;;940    
;;;941        return RMP_Cur_Thd->Retval;
;;;942    }
000096  b003              ADD      sp,sp,#0xc
000098  bdf0              POP      {r4-r7,pc}
                  |L31.154|
00009a  f7fffffe          BL       RMP_Unlock_Sched
00009e  4638              MOV      r0,r7                 ;900
0000a0  b003              ADD      sp,sp,#0xc
0000a2  bdf0              POP      {r4-r7,pc}
                  |L31.164|
0000a4  69a8              LDR      r0,[r5,#0x18]         ;913  ; RMP_Cur_Thd
0000a6  69a9              LDR      r1,[r5,#0x18]         ;913  ; RMP_Cur_Thd
0000a8  6980              LDR      r0,[r0,#0x18]         ;913
0000aa  0a00              LSRS     r0,r0,#8              ;913
0000ac  0200              LSLS     r0,r0,#8              ;913
0000ae  1c80              ADDS     r0,r0,#2              ;913
0000b0  e7eb              B        |L31.138|
                  |L31.178|
0000b2  69b0              LDR      r0,[r6,#0x18]         ;920
0000b4  b2c0              UXTB     r0,r0                 ;920
0000b6  2804              CMP      r0,#4                 ;920
0000b8  d003              BEQ      |L31.194|
0000ba  69b0              LDR      r0,[r6,#0x18]         ;921
0000bc  b2c0              UXTB     r0,r0                 ;921
0000be  2805              CMP      r0,#5                 ;921
0000c0  d112              BNE      |L31.232|
                  |L31.194|
0000c2  69b0              LDR      r0,[r6,#0x18]         ;924
0000c4  b2c0              UXTB     r0,r0                 ;924
0000c6  2805              CMP      r0,#5                 ;924
0000c8  d103              BNE      |L31.210|
0000ca  68b1              LDR      r1,[r6,#8]            ;925
0000cc  68f0              LDR      r0,[r6,#0xc]          ;925
0000ce  6001              STR      r1,[r0,#0]            ;925
0000d0  6048              STR      r0,[r1,#4]            ;925
                  |L31.210|
0000d2  69b0              LDR      r0,[r6,#0x18]         ;927
0000d4  0a00              LSRS     r0,r0,#8              ;927
0000d6  0200              LSLS     r0,r0,#8              ;927
0000d8  1c40              ADDS     r0,r0,#1              ;927
0000da  61b0              STR      r0,[r6,#0x18]         ;927
0000dc  69b0              LDR      r0,[r6,#0x18]         ;930
0000de  05c0              LSLS     r0,r0,#23             ;930
0000e0  d402              BMI      |L31.232|
0000e2  4630              MOV      r0,r6                 ;931
0000e4  f7fffffe          BL       _RMP_Set_Rdy
                  |L31.232|
0000e8  9801              LDR      r0,[sp,#4]            ;935
0000ea  62f0              STR      r0,[r6,#0x2c]         ;935
0000ec  69b0              LDR      r0,[r6,#0x18]         ;936
0000ee  2101              MOVS     r1,#1                 ;936
0000f0  0249              LSLS     r1,r1,#9              ;936
0000f2  4308              ORRS     r0,r0,r1              ;936
0000f4  61b0              STR      r0,[r6,#0x18]         ;936
                  |L31.246|
0000f6  f7fffffe          BL       RMP_Unlock_Sched
0000fa  69a8              LDR      r0,[r5,#0x18]         ;941  ; RMP_Cur_Thd
0000fc  6b80              LDR      r0,[r0,#0x38]         ;941
0000fe  b003              ADD      sp,sp,#0xc
000100  bdf0              POP      {r4-r7,pc}
;;;943    /* End Function:RMP_Thd_Snd **************************************************/
                          ENDP

000102  0000              DCW      0x0000
                  |L31.260|
                          DCD      0xffffffff
                  |L31.264|
                          DCD      ||.data||
                  |L31.268|
                          DCD      0x000186a0
                  |L31.272|
                          DCD      ||.data||+0x20

                          AREA ||i.RMP_Thd_Snd_ISR||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Snd_ISR PROC
;;;953    ******************************************************************************/
;;;954    ret_t RMP_Thd_Snd_ISR(volatile struct RMP_Thd* Thread, ptr_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;955    {
000002  0004              MOVS     r4,r0
;;;956        /* Check if this thread structure could possibly be in use */
;;;957        if(Thread==0)
;;;958            return RMP_ERR_THD;
000004  481c              LDR      r0,|L32.120|
000006  460e              MOV      r6,r1                 ;955
000008  d034              BEQ      |L32.116|
;;;959        
;;;960        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
00000a  69a1              LDR      r1,[r4,#0x18]
00000c  0609              LSLS     r1,r1,#24
00000e  0e09              LSRS     r1,r1,#24
000010  d030              BEQ      |L32.116|
;;;961            return RMP_ERR_THD;
;;;962        
;;;963        if(RMP_Sched_Locked!=0)
000012  4d1a              LDR      r5,|L32.124|
000014  68e9              LDR      r1,[r5,#0xc]  ; RMP_Sched_Locked
;;;964            return RMP_ERR_OPER;
000016  1f00              SUBS     r0,r0,#4
000018  2900              CMP      r1,#0                 ;963
00001a  d12b              BNE      |L32.116|
;;;965    
;;;966        /* See if there are already a value in the mailbox, if there is, we abort */
;;;967        if((Thread->State&RMP_THD_MBOXFUL)!=0)
00001c  69a1              LDR      r1,[r4,#0x18]
00001e  0589              LSLS     r1,r1,#22
000020  d428              BMI      |L32.116|
;;;968            return RMP_ERR_OPER;
;;;969        else
;;;970        {
;;;971            /* Mailbox not full. We need to check if the receiver is waiting for us */
;;;972            if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
000022  69a0              LDR      r0,[r4,#0x18]
000024  b2c0              UXTB     r0,r0
000026  2804              CMP      r0,#4
000028  d003              BEQ      |L32.50|
;;;973               (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
00002a  69a0              LDR      r0,[r4,#0x18]
00002c  b2c0              UXTB     r0,r0
00002e  2805              CMP      r0,#5
000030  d119              BNE      |L32.102|
                  |L32.50|
;;;974            {
;;;975                /* The receiver is blocked, wake it up and return the value */
;;;976                if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
000032  69a0              LDR      r0,[r4,#0x18]
000034  b2c0              UXTB     r0,r0
000036  2805              CMP      r0,#5
000038  d103              BNE      |L32.66|
;;;977                    RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
00003a  68a0              LDR      r0,[r4,#8]
00003c  68e1              LDR      r1,[r4,#0xc]
00003e  6008              STR      r0,[r1,#0]
000040  6041              STR      r1,[r0,#4]
                  |L32.66|
;;;978                
;;;979                RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
000042  69a0              LDR      r0,[r4,#0x18]
000044  0a00              LSRS     r0,r0,#8
000046  0200              LSLS     r0,r0,#8
000048  1c40              ADDS     r0,r0,#1
00004a  61a0              STR      r0,[r4,#0x18]
;;;980    
;;;981                /* Is it suspended? If yes, we can't directly send it running */
;;;982                if((Thread->State&RMP_THD_SUSPENDED)==0)
00004c  69a0              LDR      r0,[r4,#0x18]
00004e  05c0              LSLS     r0,r0,#23
000050  d409              BMI      |L32.102|
;;;983                {
;;;984                    _RMP_Set_Rdy(Thread);
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       _RMP_Set_Rdy
;;;985                    if(Thread->Prio>RMP_Cur_Thd->Prio)
000058  6a60              LDR      r0,[r4,#0x24]
00005a  69a9              LDR      r1,[r5,#0x18]  ; RMP_Cur_Thd
00005c  6a49              LDR      r1,[r1,#0x24]
00005e  4288              CMP      r0,r1
000060  d901              BLS      |L32.102|
;;;986                        _RMP_Yield();
000062  f7fffffe          BL       _RMP_Yield
                  |L32.102|
;;;987                }
;;;988            }
;;;989            
;;;990            /* Set the mailbox */
;;;991            Thread->Mailbox=Data;
000066  62e6              STR      r6,[r4,#0x2c]
;;;992            Thread->State|=RMP_THD_MBOXFUL;
000068  69a0              LDR      r0,[r4,#0x18]
00006a  2101              MOVS     r1,#1
00006c  0249              LSLS     r1,r1,#9
00006e  4308              ORRS     r0,r0,r1
000070  61a0              STR      r0,[r4,#0x18]
;;;993        }
;;;994    
;;;995        return 0;
000072  2000              MOVS     r0,#0
                  |L32.116|
;;;996    }
000074  bd70              POP      {r4-r6,pc}
;;;997    /* End Function:RMP_Thd_Snd_ISR **********************************************/
                          ENDP

000076  0000              DCW      0x0000
                  |L32.120|
                          DCD      0xffffffff
                  |L32.124|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Suspend||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Suspend PROC
;;;788    ******************************************************************************/
;;;789    ret_t RMP_Thd_Suspend(volatile struct RMP_Thd* Thread)
000000  b570              PUSH     {r4-r6,lr}
;;;790    {
;;;791        /* Check if this thread structure could possibly be in use */
;;;792        if(Thread==0)
;;;793            return RMP_ERR_THD;
000002  4d16              LDR      r5,|L33.92|
000004  0004              MOVS     r4,r0                 ;790
000006  d012              BEQ      |L33.46|
000008  f7fffffe          BL       RMP_Disable_Int
00000c  4814              LDR      r0,|L33.96|
00000e  2101              MOVS     r1,#1                 ;790
000010  60c1              STR      r1,[r0,#0xc]          ;790  ; RMP_Sched_Locked
000012  6881              LDR      r1,[r0,#8]            ;790  ; RMP_Sched_Lock_Cnt
000014  1c49              ADDS     r1,r1,#1              ;790
000016  6081              STR      r1,[r0,#8]            ;790  ; RMP_Sched_Lock_Cnt
;;;794        
;;;795        RMP_Lock_Sched();
;;;796        
;;;797        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
000018  69a0              LDR      r0,[r4,#0x18]
00001a  0600              LSLS     r0,r0,#24
00001c  0e00              LSRS     r0,r0,#24
00001e  d008              BEQ      |L33.50|
;;;798        {
;;;799            RMP_Unlock_Sched();
;;;800            return RMP_ERR_THD;
;;;801        }
;;;802        
;;;803        /* Suspend it */
;;;804        if((Thread->State&RMP_THD_SUSPENDED)!=0)
000020  69a0              LDR      r0,[r4,#0x18]
000022  05c0              LSLS     r0,r0,#23
000024  d509              BPL      |L33.58|
;;;805        {
;;;806            RMP_Unlock_Sched();
000026  f7fffffe          BL       RMP_Unlock_Sched
;;;807            return RMP_ERR_STATE;
00002a  00a8              LSLS     r0,r5,#2
;;;808        }
;;;809        /* Mark this as suspended */
;;;810        Thread->State|=RMP_THD_SUSPENDED;
;;;811        /* Only when it is running do we clear this */
;;;812        if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;813            _RMP_Clr_Rdy(Thread);
;;;814        
;;;815        RMP_Unlock_Sched();
;;;816    
;;;817        return 0;
;;;818    }
00002c  bd70              POP      {r4-r6,pc}
                  |L33.46|
00002e  4628              MOV      r0,r5                 ;793
000030  bd70              POP      {r4-r6,pc}
                  |L33.50|
000032  f7fffffe          BL       RMP_Unlock_Sched
000036  4628              MOV      r0,r5                 ;800
000038  bd70              POP      {r4-r6,pc}
                  |L33.58|
00003a  69a0              LDR      r0,[r4,#0x18]         ;810
00003c  21ff              MOVS     r1,#0xff              ;810
00003e  3101              ADDS     r1,#1                 ;810
000040  4308              ORRS     r0,r0,r1              ;810
000042  61a0              STR      r0,[r4,#0x18]         ;810
000044  69a0              LDR      r0,[r4,#0x18]         ;812
000046  b2c0              UXTB     r0,r0                 ;812
000048  2801              CMP      r0,#1                 ;812
00004a  d102              BNE      |L33.82|
00004c  4620              MOV      r0,r4                 ;813
00004e  f7fffffe          BL       _RMP_Clr_Rdy
                  |L33.82|
000052  f7fffffe          BL       RMP_Unlock_Sched
000056  2000              MOVS     r0,#0                 ;817
000058  bd70              POP      {r4-r6,pc}
;;;819    /* End Function:RMP_Thd_Suspend **********************************************/
                          ENDP

00005a  0000              DCW      0x0000
                  |L33.92|
                          DCD      0xffffffff
                  |L33.96|
                          DCD      ||.data||

                          AREA ||i.RMP_Tick_Hook||, CODE, READONLY, ALIGN=1

                  RMP_Tick_Hook PROC
;;;1492   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1493   void RMP_Tick_Hook(ptr_t Ticks)
000000  4770              BX       lr
;;;1494   {
;;;1495       Ticks=Ticks;
;;;1496       return;
;;;1497   }
;;;1498   #endif
                          ENDP


                          AREA ||i.RMP_Unlock_Sched||, CODE, READONLY, ALIGN=2

                  RMP_Unlock_Sched PROC
;;;275    ******************************************************************************/
;;;276    void RMP_Unlock_Sched(void)
000000  b510              PUSH     {r4,lr}
;;;277    {
;;;278        if(RMP_Sched_Lock_Cnt==1)
000002  480c              LDR      r0,|L35.52|
000004  6881              LDR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
000006  2901              CMP      r1,#1
000008  d006              BEQ      |L35.24|
;;;279        {
;;;280            /* Clear the count before enabling */
;;;281            RMP_Sched_Lock_Cnt=0;
;;;282            RMP_Sched_Locked=0;
;;;283            /* Now see if the scheduler scheduling action is pended in the lock-unlock 
;;;284             * period. If yes, perform a schedule now */
;;;285            if(RMP_Sched_Pend!=0)
;;;286            {
;;;287                /* Reset the count and trigger the context switch */
;;;288                RMP_Sched_Pend=0;
;;;289                _RMP_Yield();
;;;290            }
;;;291            RMP_UNMASK_INT();
;;;292        }
;;;293        else if(RMP_Sched_Lock_Cnt>1)
00000a  6881              LDR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
00000c  2901              CMP      r1,#1
00000e  d90f              BLS      |L35.48|
;;;294            RMP_Sched_Lock_Cnt--;
000010  6881              LDR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
000012  1e49              SUBS     r1,r1,#1
000014  6081              STR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
;;;295        /* Trying to unlock a scheduler that is not locked */
;;;296        else
;;;297            while(1);
;;;298    }
000016  bd10              POP      {r4,pc}
                  |L35.24|
000018  2100              MOVS     r1,#0                 ;281
00001a  6081              STR      r1,[r0,#8]            ;281  ; RMP_Sched_Lock_Cnt
00001c  60c1              STR      r1,[r0,#0xc]          ;282  ; RMP_Sched_Locked
00001e  6902              LDR      r2,[r0,#0x10]         ;285  ; RMP_Sched_Pend
000020  2a00              CMP      r2,#0                 ;285
000022  d002              BEQ      |L35.42|
000024  6101              STR      r1,[r0,#0x10]         ;288  ; RMP_Sched_Pend
000026  f7fffffe          BL       _RMP_Yield
                  |L35.42|
00002a  f7fffffe          BL       RMP_Enable_Int
00002e  bd10              POP      {r4,pc}
                  |L35.48|
000030  e7fe              B        |L35.48|
;;;299    /* End Function:RMP_Unlock_Sched *********************************************/
                          ENDP

000032  0000              DCW      0x0000
                  |L35.52|
                          DCD      ||.data||

                          AREA ||i.RMP_Yield||, CODE, READONLY, ALIGN=2

                  RMP_Yield PROC
;;;306    ******************************************************************************/
;;;307    void RMP_Yield(void)
000000  b510              PUSH     {r4,lr}
;;;308    {
;;;309        if(RMP_Sched_Locked==0)
000002  4805              LDR      r0,|L36.24|
000004  68c1              LDR      r1,[r0,#0xc]  ; RMP_Sched_Locked
000006  2900              CMP      r1,#0
000008  d002              BEQ      |L36.16|
;;;310        {
;;;311            /* Now see if the scheduler scheduling action is pended in the lock-unlock 
;;;312             * period. If yes, perform a schedule now */
;;;313            _RMP_Yield();
;;;314        }
;;;315        else
;;;316            RMP_Sched_Pend=1;
00000a  2101              MOVS     r1,#1
00000c  6101              STR      r1,[r0,#0x10]  ; RMP_Sched_Pend
;;;317    }
00000e  bd10              POP      {r4,pc}
                  |L36.16|
000010  f7fffffe          BL       _RMP_Yield
000014  bd10              POP      {r4,pc}
;;;318    /* End Function:RMP_Yield ****************************************************/
                          ENDP

000016  0000              DCW      0x0000
                  |L36.24|
                          DCD      ||.data||

                          AREA ||i._RMP_Clr_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Clr_Rdy PROC
;;;535    ******************************************************************************/
;;;536    void _RMP_Clr_Rdy(volatile struct RMP_Thd* Thread)
000000  b430              PUSH     {r4,r5}
;;;537    {
;;;538        /* See if it is the last thread on the priority level */
;;;539        if(Thread->Run_Head.Prev==Thread->Run_Head.Next)
000002  6801              LDR      r1,[r0,#0]
000004  6843              LDR      r3,[r0,#4]
;;;540            RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]&=~(((ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK));
000006  2201              MOVS     r2,#1
000008  4299              CMP      r1,r3                 ;539
00000a  d10c              BNE      |L37.38|
00000c  6a41              LDR      r1,[r0,#0x24]
00000e  4b0b              LDR      r3,|L37.60|
000010  0949              LSRS     r1,r1,#5
000012  0089              LSLS     r1,r1,#2
000014  18c9              ADDS     r1,r1,r3
000016  680b              LDR      r3,[r1,#0]
000018  6a44              LDR      r4,[r0,#0x24]
00001a  0725              LSLS     r5,r4,#28
00001c  0f2d              LSRS     r5,r5,#28
00001e  4614              MOV      r4,r2
000020  40ac              LSLS     r4,r4,r5
000022  43a3              BICS     r3,r3,r4
000024  600b              STR      r3,[r1,#0]
                  |L37.38|
;;;541        
;;;542        /* Insert this into the corresponding runqueue */
;;;543        RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
000026  6803              LDR      r3,[r0,#0]
000028  6841              LDR      r1,[r0,#4]
00002a  600b              STR      r3,[r1,#0]
00002c  6059              STR      r1,[r3,#4]
;;;544        
;;;545        /* If it is the current thread, request a context switch */
;;;546        if(Thread==RMP_Cur_Thd)
00002e  4903              LDR      r1,|L37.60|
000030  698b              LDR      r3,[r1,#0x18]  ; RMP_Cur_Thd
000032  4298              CMP      r0,r3
000034  d100              BNE      |L37.56|
;;;547            RMP_Sched_Pend=1;
000036  610a              STR      r2,[r1,#0x10]  ; RMP_Sched_Pend
                  |L37.56|
;;;548    }
000038  bc30              POP      {r4,r5}
00003a  4770              BX       lr
;;;549    /* End Function:_RMP_Clr_Rdy *************************************************/
                          ENDP

                  |L37.60|
                          DCD      ||.data||

                          AREA ||i._RMP_Get_High_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Get_High_Rdy PROC
;;;384    ******************************************************************************/
;;;385    void _RMP_Get_High_Rdy(void)
000000  b570              PUSH     {r4-r6,lr}
;;;386    {
;;;387        cnt_t Count;
;;;388        
;;;389        /* Write the SP value to thread structure */
;;;390        RMP_Cur_Thd->Stack=RMP_Cur_SP;
000002  4c1d              LDR      r4,|L38.120|
000004  69e0              LDR      r0,[r4,#0x1c]  ; RMP_Cur_SP
000006  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
;;;391        
;;;392        /* Is the scheduler locked on other threads? If yes, we return without doing anything */
;;;393        if(RMP_Sched_Locked!=0)
000008  6348              STR      r0,[r1,#0x34]
00000a  68e0              LDR      r0,[r4,#0xc]  ; RMP_Sched_Locked
00000c  2800              CMP      r0,#0
00000e  d131              BNE      |L38.116|
;;;394            return;
;;;395        
;;;396        if(RMP_Timer_Pend==1)
000010  6960              LDR      r0,[r4,#0x14]  ; RMP_Timer_Pend
000012  2500              MOVS     r5,#0
000014  2801              CMP      r0,#1
000016  d102              BNE      |L38.30|
;;;397        {
;;;398            RMP_Timer_Pend=0;
000018  6165              STR      r5,[r4,#0x14]  ; RMP_Timer_Pend
;;;399            _RMP_Timer_Proc();
00001a  f7fffffe          BL       _RMP_Timer_Proc
                  |L38.30|
;;;400        }
;;;401        
;;;402        RMP_Sched_Pend=0;
00001e  6125              STR      r5,[r4,#0x10]  ; RMP_Sched_Pend
;;;403        /* See which one is ready, and pick it */
;;;404        for(Count=RMP_BITMAP_SIZE-1;Count>=0;Count--)
;;;405        {
;;;406            if(RMP_Bitmap[Count]==0)
000020  4815              LDR      r0,|L38.120|
000022  6801              LDR      r1,[r0,#0]
000024  2900              CMP      r1,#0
000026  d022              BEQ      |L38.110|
;;;407                continue;
;;;408            
;;;409            Count=RMP_MSB_Get(RMP_Bitmap[Count])+(Count<<RMP_WORD_ORDER);
000028  6800              LDR      r0,[r0,#0]
00002a  f7fffffe          BL       RMP_MSB_Get
;;;410            
;;;411            /* See if the current thread and the next thread are the same. If yes, place the current at the end of the queue */
;;;412            if(RMP_Cur_Thd==(struct RMP_Thd*)(RMP_Run[Count].Next))
00002e  4913              LDR      r1,|L38.124|
000030  00c0              LSLS     r0,r0,#3
000032  1843              ADDS     r3,r0,r1
000034  6858              LDR      r0,[r3,#4]
000036  69a2              LDR      r2,[r4,#0x18]  ; RMP_Cur_Thd
000038  4290              CMP      r0,r2
00003a  d112              BNE      |L38.98|
;;;413            {
;;;414                RMP_List_Del(RMP_Cur_Thd->Run_Head.Prev, RMP_Cur_Thd->Run_Head.Next);
00003c  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
00003e  6802              LDR      r2,[r0,#0]
000040  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
000042  6840              LDR      r0,[r0,#4]
000044  6002              STR      r2,[r0,#0]
000046  6050              STR      r0,[r2,#4]
;;;415                RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),
000048  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
00004a  69a2              LDR      r2,[r4,#0x18]  ; RMP_Cur_Thd
00004c  6a52              LDR      r2,[r2,#0x24]
00004e  00d2              LSLS     r2,r2,#3
000050  588a              LDR      r2,[r1,r2]
000052  69a5              LDR      r5,[r4,#0x18]  ; RMP_Cur_Thd
000054  6a6d              LDR      r5,[r5,#0x24]
000056  00ed              LSLS     r5,r5,#3
000058  1869              ADDS     r1,r5,r1
00005a  6008              STR      r0,[r1,#0]
00005c  6041              STR      r1,[r0,#4]
00005e  6002              STR      r2,[r0,#0]
000060  6050              STR      r0,[r2,#4]
                  |L38.98|
;;;416                             RMP_Run[RMP_Cur_Thd->Prio].Prev,
;;;417                             &(RMP_Run[RMP_Cur_Thd->Prio]));
;;;418            }
;;;419            
;;;420            /* Replenish timeslices */
;;;421            RMP_Cur_Thd->Slices_Left=RMP_Cur_Thd->Slices;
000062  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
000064  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
000066  69c0              LDR      r0,[r0,#0x1c]
;;;422            RMP_Cur_Thd=(struct RMP_Thd*)(RMP_Run[Count].Next);
000068  6208              STR      r0,[r1,#0x20]
00006a  6858              LDR      r0,[r3,#4]
00006c  61a0              STR      r0,[r4,#0x18]  ; RMP_Cur_Thd
                  |L38.110|
;;;423            break;
;;;424        }
;;;425        
;;;426        /* Load the SP value from thread structure */
;;;427        RMP_Cur_SP=RMP_Cur_Thd->Stack;
00006e  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
000070  6b40              LDR      r0,[r0,#0x34]
000072  61e0              STR      r0,[r4,#0x1c]  ; RMP_Cur_SP
                  |L38.116|
;;;428    }
000074  bd70              POP      {r4-r6,pc}
;;;429    /* End Function:_RMP_Get_High_Rdy ********************************************/
                          ENDP

000076  0000              DCW      0x0000
                  |L38.120|
                          DCD      ||.data||
                  |L38.124|
                          DCD      ||.bss||

                          AREA ||i._RMP_Get_Near_Ticks||, CODE, READONLY, ALIGN=2

                  _RMP_Get_Near_Ticks PROC
;;;480    ******************************************************************************/
;;;481    ptr_t _RMP_Get_Near_Ticks(void)
000000  b410              PUSH     {r4}
;;;482    {
;;;483        ptr_t Value;
;;;484        struct RMP_Thd* Thread;
;;;485        
;;;486        /* What is the current thread's timeout value? */
;;;487        Value=RMP_Cur_Thd->Slices_Left;
000002  4a0b              LDR      r2,|L39.48|
000004  6990              LDR      r0,[r2,#0x18]  ; RMP_Cur_Thd
;;;488        
;;;489        /* What is the nearest timer timeout value? */
;;;490        if((&RMP_Delay)!=RMP_Delay.Next)
000006  490b              LDR      r1,|L39.52|
000008  6a00              LDR      r0,[r0,#0x20]         ;487
00000a  684b              LDR      r3,[r1,#4]  ; RMP_Delay
00000c  428b              CMP      r3,r1
00000e  d006              BEQ      |L39.30|
;;;491        {
;;;492            Thread=RMP_DLY2THD(RMP_Delay.Next);
000010  6849              LDR      r1,[r1,#4]  ; RMP_Delay
;;;493            /* See if it is nearer - don't worry about the situation that the timer
;;;494             * have overflown, because if that is to happen, it would have been 
;;;495             * already processed by the timeout processing routine just called above. */
;;;496            if((Thread->Timeout-RMP_Tick)<Value)
;;;497                Value=Thread->Timeout-RMP_Tick;
000012  6854              LDR      r4,[r2,#4]  ; RMP_Tick
000014  6a0b              LDR      r3,[r1,#0x20]
000016  3908              SUBS     r1,r1,#8
000018  1b1b              SUBS     r3,r3,r4
00001a  4283              CMP      r3,r0
00001c  d304              BCC      |L39.40|
                  |L39.30|
;;;498        }
;;;499        
;;;500        /* The timer setting is at least 1 tick */
;;;501        if(Value==0)
00001e  2800              CMP      r0,#0
000020  d100              BNE      |L39.36|
;;;502            Value=1;
000022  2001              MOVS     r0,#1
                  |L39.36|
;;;503        
;;;504        return Value;
;;;505    }
000024  bc10              POP      {r4}
000026  4770              BX       lr
                  |L39.40|
000028  6a88              LDR      r0,[r1,#0x28]         ;497
00002a  6851              LDR      r1,[r2,#4]            ;497  ; RMP_Tick
00002c  1a40              SUBS     r0,r0,r1              ;497
00002e  e7f6              B        |L39.30|
;;;506    /* End Function:_RMP_Get_Near_Ticks ******************************************/
                          ENDP

                  |L39.48|
                          DCD      ||.data||
                  |L39.52|
                          DCD      ||.data||+0x20

                          AREA ||i._RMP_Mem_Ins||, CODE, READONLY, ALIGN=1

                  _RMP_Mem_Ins PROC
;;;1777   ******************************************************************************/
;;;1778   void _RMP_Mem_Ins(volatile void* Pool, volatile struct RMP_Mem_Head* Mem_Head)
000000  b570              PUSH     {r4-r6,lr}
;;;1779   {
;;;1780       cnt_t FLI_Level;
;;;1781       cnt_t SLI_Level;
;;;1782       ptr_t Level;
;;;1783       ptr_t Size;
;;;1784       volatile struct RMP_Mem* Mem;
;;;1785       volatile struct RMP_List* Slot;
;;;1786       
;;;1787       /* Get the memory pool and block size */
;;;1788       Mem=(volatile struct RMP_Mem*)Pool;
000002  4605              MOV      r5,r0
;;;1789       Size=(ptr_t)(Mem_Head->Tail)-((ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Head);
000004  68c8              LDR      r0,[r1,#0xc]
000006  460c              MOV      r4,r1                 ;1779
000008  1b06              SUBS     r6,r0,r4
00000a  3e10              SUBS     r6,r6,#0x10
;;;1790   
;;;1791       /* Guarantee the Mem_Size is bigger than 64 or a failure will surely occur here */
;;;1792       FLI_Level=RMP_MSB_Get(Size)-6;
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       RMP_MSB_Get
;;;1793       /* Decide the SLI level directly from the FLI level */
;;;1794       SLI_Level=(Size>>(FLI_Level+3))&0x07;
000012  1ec1              SUBS     r1,r0,#3
000014  40ce              LSRS     r6,r6,r1
000016  0771              LSLS     r1,r6,#29
000018  1f80              SUBS     r0,r0,#6
00001a  0f49              LSRS     r1,r1,#29
;;;1795       Level=(FLI_Level<<3)+SLI_Level;
00001c  00c0              LSLS     r0,r0,#3
00001e  1841              ADDS     r1,r0,r1
000020  00c8              LSLS     r0,r1,#3
;;;1796       /* Get the slot */
;;;1797       Slot=&(Mem->Table[RMP_MEM_POS(FLI_Level,SLI_Level)]);
000022  1940              ADDS     r0,r0,r5
;;;1798   
;;;1799       /* See if there are any blocks in the level, equal means no. So what we inserted is the first block */
;;;1800       if(Slot==Slot->Next)
000024  6ac2              LDR      r2,[r0,#0x2c]
000026  3028              ADDS     r0,r0,#0x28
000028  4282              CMP      r2,r0
00002a  d109              BNE      |L40.64|
;;;1801       {
;;;1802           /* Set the corresponding bit in the TLSF bitmap */
;;;1803           Mem->Bitmap[Level>>RMP_WORD_ORDER]|=1<<(Level&RMP_WORD_MASK);
00002c  094a              LSRS     r2,r1,#5
00002e  0092              LSLS     r2,r2,#2
000030  1952              ADDS     r2,r2,r5
000032  6953              LDR      r3,[r2,#0x14]
000034  070d              LSLS     r5,r1,#28
000036  0f2d              LSRS     r5,r5,#28
000038  2101              MOVS     r1,#1
00003a  40a9              LSLS     r1,r1,r5
00003c  430b              ORRS     r3,r3,r1
00003e  6153              STR      r3,[r2,#0x14]
                  |L40.64|
;;;1804       }
;;;1805   
;;;1806       /* Insert the node now */
;;;1807       RMP_List_Ins(&(Mem_Head->Head), Slot, Slot->Next);
000040  6841              LDR      r1,[r0,#4]
000042  600c              STR      r4,[r1,#0]
000044  6061              STR      r1,[r4,#4]
000046  6020              STR      r0,[r4,#0]
000048  6044              STR      r4,[r0,#4]
;;;1808   }
00004a  bd70              POP      {r4-r6,pc}
;;;1809   /* End Function:_RMP_Mem_Ins *************************************************/
                          ENDP


                          AREA ||i._RMP_Set_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Set_Rdy PROC
;;;515    ******************************************************************************/
;;;516    void _RMP_Set_Rdy(volatile struct RMP_Thd* Thread)
000000  b430              PUSH     {r4,r5}
;;;517    {
;;;518        /* Insert this into the corresponding runqueue */
;;;519        RMP_List_Ins(&(Thread->Run_Head),RMP_Run[Thread->Prio].Prev,&(RMP_Run[Thread->Prio]));
000002  6a41              LDR      r1,[r0,#0x24]
000004  4a10              LDR      r2,|L41.72|
000006  00c9              LSLS     r1,r1,#3
000008  5851              LDR      r1,[r2,r1]
00000a  6a43              LDR      r3,[r0,#0x24]
00000c  00db              LSLS     r3,r3,#3
00000e  189a              ADDS     r2,r3,r2
000010  6010              STR      r0,[r2,#0]
000012  6042              STR      r2,[r0,#4]
000014  6001              STR      r1,[r0,#0]
000016  6048              STR      r0,[r1,#4]
;;;520        /* Set this runlevel as active */
;;;521        RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]|=((ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK);
000018  6a41              LDR      r1,[r0,#0x24]
00001a  4a0c              LDR      r2,|L41.76|
00001c  0949              LSRS     r1,r1,#5
00001e  0089              LSLS     r1,r1,#2
000020  1889              ADDS     r1,r1,r2
000022  680b              LDR      r3,[r1,#0]
000024  6a42              LDR      r2,[r0,#0x24]
000026  0715              LSLS     r5,r2,#28
000028  2201              MOVS     r2,#1
00002a  0f2d              LSRS     r5,r5,#28
00002c  4614              MOV      r4,r2
00002e  40ac              LSLS     r4,r4,r5
000030  4323              ORRS     r3,r3,r4
000032  600b              STR      r3,[r1,#0]
;;;522        
;;;523        /* Compare this with the current one to see if we need a context switch */
;;;524        if(Thread->Prio>RMP_Cur_Thd->Prio)
000034  6a41              LDR      r1,[r0,#0x24]
000036  4805              LDR      r0,|L41.76|
000038  6983              LDR      r3,[r0,#0x18]  ; RMP_Cur_Thd
00003a  6a5b              LDR      r3,[r3,#0x24]
00003c  4299              CMP      r1,r3
00003e  d900              BLS      |L41.66|
;;;525            RMP_Sched_Pend=1;
000040  6102              STR      r2,[r0,#0x10]  ; RMP_Sched_Pend
                  |L41.66|
;;;526    }
000042  bc30              POP      {r4,r5}
000044  4770              BX       lr
;;;527    /* End Function:_RMP_Set_Rdy *************************************************/
                          ENDP

000046  0000              DCW      0x0000
                  |L41.72|
                          DCD      ||.bss||
                  |L41.76|
                          DCD      ||.data||

                          AREA ||i._RMP_Tick_Handler||, CODE, READONLY, ALIGN=2

                  _RMP_Tick_Handler PROC
;;;436    ******************************************************************************/
;;;437    void _RMP_Tick_Handler(ptr_t Ticks)
000000  b510              PUSH     {r4,lr}
;;;438    {
;;;439        struct RMP_Thd* Thread;
;;;440        /* Increase the timestamp as always */
;;;441        RMP_Tick+=Ticks;
000002  4c16              LDR      r4,|L42.92|
000004  6861              LDR      r1,[r4,#4]  ; RMP_Tick
000006  1809              ADDS     r1,r1,r0
000008  6061              STR      r1,[r4,#4]  ; RMP_Tick
;;;442    #if(RMP_USE_HOOKS==RMP_TRUE)
;;;443        RMP_Tick_Hook(Ticks);
;;;444    #endif
;;;445        /* See if the current thread expired. If yes, trigger a scheduler event */
;;;446        if(Ticks>=RMP_Cur_Thd->Slices_Left)
00000a  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
;;;447            RMP_Sched_Pend=1;
00000c  2201              MOVS     r2,#1
00000e  6a09              LDR      r1,[r1,#0x20]         ;446
000010  4281              CMP      r1,r0                 ;446
000012  d801              BHI      |L42.24|
000014  6122              STR      r2,[r4,#0x10]  ; RMP_Sched_Pend
000016  e003              B        |L42.32|
                  |L42.24|
;;;448        else
;;;449            RMP_Cur_Thd->Slices_Left-=Ticks;
000018  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
00001a  6a0b              LDR      r3,[r1,#0x20]
00001c  1a18              SUBS     r0,r3,r0
00001e  6208              STR      r0,[r1,#0x20]
                  |L42.32|
;;;450        
;;;451        /* Is the scheduler locked? If yes, we cannot process timer events here and will have to pend them */
;;;452        if((&RMP_Delay)!=RMP_Delay.Next)
000020  480f              LDR      r0,|L42.96|
000022  6841              LDR      r1,[r0,#4]  ; RMP_Delay
000024  4281              CMP      r1,r0
000026  d00d              BEQ      |L42.68|
;;;453        {
;;;454            Thread=RMP_DLY2THD(RMP_Delay.Next);
000028  6840              LDR      r0,[r0,#4]  ; RMP_Delay
;;;455            /* If the value is less than this, then it means that the time have
;;;456             * already passed and we have to process this */
;;;457            if((RMP_Tick-Thread->Timeout)<=(RMP_ALLBITS>>1))
00002a  6861              LDR      r1,[r4,#4]  ; RMP_Tick
00002c  6a00              LDR      r0,[r0,#0x20]
00002e  1a08              SUBS     r0,r1,r0
000030  490c              LDR      r1,|L42.100|
000032  4288              CMP      r0,r1
000034  d806              BHI      |L42.68|
;;;458            {
;;;459                /* If scheduler locked, we pend the processing until it is unlocked */
;;;460                if(RMP_Sched_Locked!=0)
000036  68e0              LDR      r0,[r4,#0xc]  ; RMP_Sched_Locked
000038  2800              CMP      r0,#0
00003a  d001              BEQ      |L42.64|
;;;461                    RMP_Timer_Pend=1;
00003c  6162              STR      r2,[r4,#0x14]  ; RMP_Timer_Pend
00003e  e001              B        |L42.68|
                  |L42.64|
;;;462                else
;;;463                    _RMP_Timer_Proc();
000040  f7fffffe          BL       _RMP_Timer_Proc
                  |L42.68|
;;;464            }
;;;465        }
;;;466        
;;;467        if((RMP_Sched_Locked==0)&&(RMP_Sched_Pend!=0))
000044  68e0              LDR      r0,[r4,#0xc]  ; RMP_Sched_Locked
000046  2800              CMP      r0,#0
000048  d106              BNE      |L42.88|
00004a  6920              LDR      r0,[r4,#0x10]  ; RMP_Sched_Pend
00004c  2800              CMP      r0,#0
00004e  d003              BEQ      |L42.88|
;;;468        {
;;;469            RMP_Sched_Pend=0;
000050  2000              MOVS     r0,#0
000052  6120              STR      r0,[r4,#0x10]  ; RMP_Sched_Pend
;;;470            _RMP_Yield();
000054  f7fffffe          BL       _RMP_Yield
                  |L42.88|
;;;471        }
;;;472    }
000058  bd10              POP      {r4,pc}
;;;473    /* End Function:_RMP_Tick_Handler ********************************************/
                          ENDP

00005a  0000              DCW      0x0000
                  |L42.92|
                          DCD      ||.data||
                  |L42.96|
                          DCD      ||.data||+0x20
                  |L42.100|
                          DCD      0x7fffffff

                          AREA ||i._RMP_Timer_Proc||, CODE, READONLY, ALIGN=2

                  _RMP_Timer_Proc PROC
;;;325    ******************************************************************************/
;;;326    void _RMP_Timer_Proc(void)
000000  4a26              LDR      r2,|L43.156|
;;;327    {
;;;328        struct RMP_Thd* Thread;
;;;329        
;;;330        /* Process the timer events, if there are any of them */
;;;331        while((&RMP_Delay)!=RMP_Delay.Next)
000002  6850              LDR      r0,[r2,#4]  ; RMP_Delay
000004  4290              CMP      r0,r2
000006  d048              BEQ      |L43.154|
000008  b4f0              PUSH     {r4-r7}               ;327
;;;332        {
;;;333            Thread=RMP_DLY2THD(RMP_Delay.Next);
;;;334            /* If the value is more than this, then it means that the time have
;;;335             * already passed and we have to process this */
;;;336            if((RMP_Tick-Thread->Timeout)>(RMP_ALLBITS>>1))
;;;337                break;
;;;338            
;;;339            /* This thread should be processed */
;;;340            RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;341            switch(RMP_THD_STATE(Thread->State))
;;;342            {
;;;343                case RMP_THD_SNDDLY:
;;;344                case RMP_THD_SEMDLY:
;;;345                {
;;;346                    RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;347                    Thread->Retval=RMP_ERR_OPER;
;;;348                    break;
;;;349                }
;;;350                
;;;351                case RMP_THD_RCVDLY:
;;;352                {
;;;353                    Thread->Retval=RMP_ERR_OPER;
;;;354                    break;
;;;355                }
;;;356                
;;;357                case RMP_THD_DELAYED:break;
;;;358                /* Should not get here */
;;;359                default:break;
;;;360            }
;;;361    
;;;362            RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;363            /* Is it suspended? If yes, we can't directly set it running */
;;;364            if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;365            {
;;;366                /* Insert this into the corresponding runqueue */
;;;367                RMP_List_Ins(&(Thread->Run_Head),RMP_Run[Thread->Prio].Prev,&(RMP_Run[Thread->Prio]));
;;;368                /* Set this runlevel as active */
;;;369                RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]|=1<<(Thread->Prio&RMP_WORD_MASK);
00000a  4f25              LDR      r7,|L43.160|
00000c  4639              MOV      r1,r7                 ;336
                  |L43.14|
00000e  6850              LDR      r0,[r2,#4]            ;333  ; RMP_Delay
000010  684c              LDR      r4,[r1,#4]            ;336  ; RMP_Tick
000012  6a03              LDR      r3,[r0,#0x20]         ;336
000014  3808              SUBS     r0,r0,#8              ;336
000016  1ae3              SUBS     r3,r4,r3              ;336
000018  4c22              LDR      r4,|L43.164|
00001a  42a3              CMP      r3,r4                 ;336
00001c  d83b              BHI      |L43.150|
00001e  68c4              LDR      r4,[r0,#0xc]          ;336
000020  6883              LDR      r3,[r0,#8]            ;336
000022  6023              STR      r3,[r4,#0]            ;336
000024  605c              STR      r4,[r3,#4]            ;336
000026  7e03              LDRB     r3,[r0,#0x18]         ;341
000028  2b03              CMP      r3,#3                 ;341
00002a  d005              BEQ      |L43.56|
00002c  2b05              CMP      r3,#5                 ;341
00002e  d00b              BEQ      |L43.72|
000030  2b06              CMP      r3,#6                 ;341
000032  d00c              BEQ      |L43.78|
000034  2b08              CMP      r3,#8                 ;341
000036  d10a              BNE      |L43.78|
                  |L43.56|
000038  6844              LDR      r4,[r0,#4]            ;341
00003a  6803              LDR      r3,[r0,#0]            ;341
00003c  6023              STR      r3,[r4,#0]            ;341
00003e  605c              STR      r4,[r3,#4]            ;341
000040  2304              MOVS     r3,#4                 ;347
000042  43db              MVNS     r3,r3                 ;347
000044  6383              STR      r3,[r0,#0x38]         ;348
000046  e002              B        |L43.78|
                  |L43.72|
000048  2304              MOVS     r3,#4                 ;353
00004a  43db              MVNS     r3,r3                 ;353
00004c  6383              STR      r3,[r0,#0x38]         ;353
                  |L43.78|
00004e  6983              LDR      r3,[r0,#0x18]         ;362
000050  0a1b              LSRS     r3,r3,#8              ;362
000052  021b              LSLS     r3,r3,#8              ;362
000054  1c5b              ADDS     r3,r3,#1              ;362
000056  6183              STR      r3,[r0,#0x18]         ;364
000058  05db              LSLS     r3,r3,#23             ;364
00005a  d419              BMI      |L43.144|
00005c  6a43              LDR      r3,[r0,#0x24]         ;367
00005e  00dd              LSLS     r5,r3,#3              ;367
000060  4b11              LDR      r3,|L43.168|
000062  595c              LDR      r4,[r3,r5]            ;367
000064  18eb              ADDS     r3,r5,r3              ;367
000066  6018              STR      r0,[r3,#0]            ;367
000068  6043              STR      r3,[r0,#4]            ;367
00006a  6004              STR      r4,[r0,#0]            ;367
00006c  6060              STR      r0,[r4,#4]            ;367
00006e  6a43              LDR      r3,[r0,#0x24]
000070  095c              LSRS     r4,r3,#5
000072  00a4              LSLS     r4,r4,#2
000074  593d              LDR      r5,[r7,r4]
000076  071e              LSLS     r6,r3,#28
000078  0f36              LSRS     r6,r6,#28
00007a  2301              MOVS     r3,#1
00007c  40b3              LSLS     r3,r3,r6
00007e  431d              ORRS     r5,r5,r3
000080  513d              STR      r5,[r7,r4]
;;;370                /* See if we need to pend a scheduling event */
;;;371                if(Thread->Prio>RMP_Cur_Thd->Prio)
000082  6a40              LDR      r0,[r0,#0x24]
000084  698b              LDR      r3,[r1,#0x18]  ; RMP_Cur_Thd
000086  6a5b              LDR      r3,[r3,#0x24]
000088  4298              CMP      r0,r3
00008a  d901              BLS      |L43.144|
;;;372                    RMP_Sched_Pend=1;
00008c  2001              MOVS     r0,#1
00008e  6108              STR      r0,[r1,#0x10]  ; RMP_Sched_Pend
                  |L43.144|
000090  6850              LDR      r0,[r2,#4]            ;331  ; RMP_Delay
000092  4290              CMP      r0,r2                 ;331
000094  d1bb              BNE      |L43.14|
                  |L43.150|
;;;373            }
;;;374        }
;;;375    }
000096  bcf0              POP      {r4-r7}
000098  4770              BX       lr
                  |L43.154|
00009a  4770              BX       lr
;;;376    /* Begin Function:_RMP_Timer_Proc ********************************************/
                          ENDP

                  |L43.156|
                          DCD      ||.data||+0x20
                  |L43.160|
                          DCD      ||.data||
                  |L43.164|
                          DCD      0x7fffffff
                  |L43.168|
                          DCD      ||.bss||

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;1533   ******************************************************************************/
;;;1534   int main(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1535   {
;;;1536       ptr_t Count;
;;;1537       /* Initialize the kernel data structures first */
;;;1538       _RMP_Low_Level_Init();
000002  f7fffffe          BL       _RMP_Low_Level_Init
;;;1539       
;;;1540   #if(RMP_USE_HOOKS==RMP_TRUE)
;;;1541       RMP_Start_Hook();
;;;1542   #endif
;;;1543       
;;;1544       RMP_Tick=0;
000006  4929              LDR      r1,|L44.172|
000008  2000              MOVS     r0,#0
00000a  6048              STR      r0,[r1,#4]  ; RMP_Tick
;;;1545       /* Now initialize the kernel data structures */
;;;1546       RMP_Sched_Lock_Cnt=0;
00000c  6088              STR      r0,[r1,#8]  ; RMP_Sched_Lock_Cnt
;;;1547       RMP_Sched_Locked=0;
00000e  60c8              STR      r0,[r1,#0xc]  ; RMP_Sched_Locked
;;;1548       RMP_Sched_Pend=0;
000010  6108              STR      r0,[r1,#0x10]  ; RMP_Sched_Pend
;;;1549       RMP_Timer_Pend=0;
000012  6148              STR      r0,[r1,#0x14]  ; RMP_Timer_Pend
;;;1550       
;;;1551       /* Linked lists */
;;;1552       RMP_List_Crt(&RMP_Delay);
000014  4926              LDR      r1,|L44.176|
000016  6009              STR      r1,[r1,#0]
000018  6049              STR      r1,[r1,#4]
;;;1553       for(Count=0;Count<RMP_MAX_PREEMPT_PRIO;Count++)
;;;1554           RMP_List_Crt(&RMP_Run[Count]);
00001a  4d26              LDR      r5,|L44.180|
00001c  4601              MOV      r1,r0                 ;1553
                  |L44.30|
00001e  00ca              LSLS     r2,r1,#3
000020  1952              ADDS     r2,r2,r5
000022  6012              STR      r2,[r2,#0]
000024  6052              STR      r2,[r2,#4]
000026  1c49              ADDS     r1,r1,#1
000028  2920              CMP      r1,#0x20
00002a  d3f8              BCC      |L44.30|
;;;1555       for(Count=0;Count<RMP_BITMAP_SIZE;Count++)
;;;1556           RMP_Bitmap[Count]=0;
00002c  4f1f              LDR      r7,|L44.172|
00002e  6038              STR      r0,[r7,#0]  ; RMP_Bitmap
;;;1557           
;;;1558       /* Now boot into the first thread */
;;;1559       RMP_Clear(&RMP_Init_Thd,sizeof(struct RMP_Thd));
000030  4b21              LDR      r3,|L44.184|
000032  243c              MOVS     r4,#0x3c
000034  260f              MOVS     r6,#0xf
000036  4619              MOV      r1,r3
000038  2207              MOVS     r2,#7
00003a  6018              STR      r0,[r3,#0]
                  |L44.60|
00003c  6048              STR      r0,[r1,#4]
00003e  6088              STR      r0,[r1,#8]
000040  3108              ADDS     r1,r1,#8
000042  1e52              SUBS     r2,r2,#1
000044  d1fa              BNE      |L44.60|
000046  00b1              LSLS     r1,r6,#2
000048  07a2              LSLS     r2,r4,#30
00004a  18c9              ADDS     r1,r1,r3
00004c  0f92              LSRS     r2,r2,#30
00004e  07a3              LSLS     r3,r4,#30
000050  d00b              BEQ      |L44.106|
000052  1e49              SUBS     r1,r1,#1
000054  07d3              LSLS     r3,r2,#31
000056  d001              BEQ      |L44.92|
000058  7048              STRB     r0,[r1,#1]
00005a  1c49              ADDS     r1,r1,#1
                  |L44.92|
00005c  0852              LSRS     r2,r2,#1
00005e  d004              BEQ      |L44.106|
                  |L44.96|
000060  7048              STRB     r0,[r1,#1]
000062  7088              STRB     r0,[r1,#2]
000064  1c89              ADDS     r1,r1,#2
000066  1e52              SUBS     r2,r2,#1
000068  d1fa              BNE      |L44.96|
                  |L44.106|
;;;1560       RMP_Init_Thd.Prio=0;
00006a  4913              LDR      r1,|L44.184|
00006c  6248              STR      r0,[r1,#0x24]  ; RMP_Init_Thd
;;;1561       RMP_Init_Thd.Slices=10;
00006e  200a              MOVS     r0,#0xa
000070  61c8              STR      r0,[r1,#0x1c]  ; RMP_Init_Thd
;;;1562       RMP_Init_Thd.Slices_Left=10;
000072  6208              STR      r0,[r1,#0x20]  ; RMP_Init_Thd
;;;1563       RMP_Init_Thd.State=RMP_THD_RUNNING;
000074  2201              MOVS     r2,#1
000076  618a              STR      r2,[r1,#0x18]  ; RMP_Init_Thd
;;;1564       RMP_Init_Thd.Stack=RMP_INIT_STACK;
000078  4810              LDR      r0,|L44.188|
00007a  6348              STR      r0,[r1,#0x34]  ; RMP_Init_Thd
;;;1565       
;;;1566       /* Initialize sending list */
;;;1567       RMP_List_Crt(&(RMP_Init_Thd.Snd_List));
00007c  4810              LDR      r0,|L44.192|
00007e  6000              STR      r0,[r0,#0]
000080  6040              STR      r0,[r0,#4]
;;;1568       
;;;1569       /* Insert this into the corresponding runqueue */
;;;1570       RMP_List_Ins(&(RMP_Init_Thd.Run_Head),RMP_Run[0].Prev,&(RMP_Run[0]));
000082  682b              LDR      r3,[r5,#0]  ; RMP_Run
000084  3810              SUBS     r0,r0,#0x10
000086  4c0b              LDR      r4,|L44.180|
000088  6020              STR      r0,[r4,#0]
00008a  6044              STR      r4,[r0,#4]
00008c  6003              STR      r3,[r0,#0]
00008e  6058              STR      r0,[r3,#4]
;;;1571       /* Set this runlevel as active - in fact it is always active */
;;;1572       RMP_Bitmap[0]|=1;
000090  6838              LDR      r0,[r7,#0]  ; RMP_Bitmap
000092  4310              ORRS     r0,r0,r2
000094  6038              STR      r0,[r7,#0]  ; RMP_Bitmap
;;;1573       
;;;1574       /* Set current thread and stack */
;;;1575       RMP_Cur_Thd=(struct RMP_Thd*)(&RMP_Init_Thd);
000096  4805              LDR      r0,|L44.172|
000098  6181              STR      r1,[r0,#0x18]  ; RMP_Cur_Thd
;;;1576       RMP_Cur_SP=RMP_Init_Thd.Stack;
00009a  6b4a              LDR      r2,[r1,#0x34]  ; RMP_Init_Thd
00009c  61c2              STR      r2,[r0,#0x1c]  ; RMP_Cur_SP
;;;1577       
;;;1578       /* Now jump to the user function and will never return. Initialization of stack is not needed */
;;;1579       _RMP_Start((ptr_t)RMP_Init, (ptr_t)RMP_Init_Thd.Stack);
00009e  6b49              LDR      r1,[r1,#0x34]  ; RMP_Init_Thd
0000a0  4808              LDR      r0,|L44.196|
0000a2  f7fffffe          BL       _RMP_Start
;;;1580       
;;;1581       return 0;
0000a6  2000              MOVS     r0,#0
;;;1582   }
0000a8  bdf8              POP      {r3-r7,pc}
;;;1583   /* End Function:main *********************************************************/
                          ENDP

0000aa  0000              DCW      0x0000
                  |L44.172|
                          DCD      ||.data||
                  |L44.176|
                          DCD      ||.data||+0x20
                  |L44.180|
                          DCD      ||.bss||
                  |L44.184|
                          DCD      ||.bss||+0x200
                  |L44.188|
                          DCD      ||.bss||+0x1bc
                  |L44.192|
                          DCD      ||.bss||+0x210
                  |L44.196|
                          DCD      RMP_Init

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  RMP_Run
                          %        256
                  RMP_Init_Stack
                          %        256
                  RMP_Init_Thd
                          %        60

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  RMP_RBIT_Table
000000  008040c0          DCB      0x00,0x80,0x40,0xc0
000004  20a060e0          DCB      0x20,0xa0,0x60,0xe0
000008  109050d0          DCB      0x10,0x90,0x50,0xd0
00000c  30b070f0          DCB      0x30,0xb0,0x70,0xf0
000010  088848c8          DCB      0x08,0x88,0x48,0xc8
000014  28a868e8          DCB      0x28,0xa8,0x68,0xe8
000018  189858d8          DCB      0x18,0x98,0x58,0xd8
00001c  38b878f8          DCB      0x38,0xb8,0x78,0xf8
000020  048444c4          DCB      0x04,0x84,0x44,0xc4
000024  24a464e4          DCB      0x24,0xa4,0x64,0xe4
000028  149454d4          DCB      0x14,0x94,0x54,0xd4
00002c  34b474f4          DCB      0x34,0xb4,0x74,0xf4
000030  0c8c4ccc          DCB      0x0c,0x8c,0x4c,0xcc
000034  2cac6cec          DCB      0x2c,0xac,0x6c,0xec
000038  1c9c5cdc          DCB      0x1c,0x9c,0x5c,0xdc
00003c  3cbc7cfc          DCB      0x3c,0xbc,0x7c,0xfc
000040  028242c2          DCB      0x02,0x82,0x42,0xc2
000044  22a262e2          DCB      0x22,0xa2,0x62,0xe2
000048  129252d2          DCB      0x12,0x92,0x52,0xd2
00004c  32b272f2          DCB      0x32,0xb2,0x72,0xf2
000050  0a8a4aca          DCB      0x0a,0x8a,0x4a,0xca
000054  2aaa6aea          DCB      0x2a,0xaa,0x6a,0xea
000058  1a9a5ada          DCB      0x1a,0x9a,0x5a,0xda
00005c  3aba7afa          DCB      0x3a,0xba,0x7a,0xfa
000060  068646c6          DCB      0x06,0x86,0x46,0xc6
000064  26a666e6          DCB      0x26,0xa6,0x66,0xe6
000068  169656d6          DCB      0x16,0x96,0x56,0xd6
00006c  36b676f6          DCB      0x36,0xb6,0x76,0xf6
000070  0e8e4ece          DCB      0x0e,0x8e,0x4e,0xce
000074  2eae6eee          DCB      0x2e,0xae,0x6e,0xee
000078  1e9e5ede          DCB      0x1e,0x9e,0x5e,0xde
00007c  3ebe7efe          DCB      0x3e,0xbe,0x7e,0xfe
000080  018141c1          DCB      0x01,0x81,0x41,0xc1
000084  21a161e1          DCB      0x21,0xa1,0x61,0xe1
000088  119151d1          DCB      0x11,0x91,0x51,0xd1
00008c  31b171f1          DCB      0x31,0xb1,0x71,0xf1
000090  098949c9          DCB      0x09,0x89,0x49,0xc9
000094  29a969e9          DCB      0x29,0xa9,0x69,0xe9
000098  199959d9          DCB      0x19,0x99,0x59,0xd9
00009c  39b979f9          DCB      0x39,0xb9,0x79,0xf9
0000a0  058545c5          DCB      0x05,0x85,0x45,0xc5
0000a4  25a565e5          DCB      0x25,0xa5,0x65,0xe5
0000a8  159555d5          DCB      0x15,0x95,0x55,0xd5
0000ac  35b575f5          DCB      0x35,0xb5,0x75,0xf5
0000b0  0d8d4dcd          DCB      0x0d,0x8d,0x4d,0xcd
0000b4  2dad6ded          DCB      0x2d,0xad,0x6d,0xed
0000b8  1d9d5ddd          DCB      0x1d,0x9d,0x5d,0xdd
0000bc  3dbd7dfd          DCB      0x3d,0xbd,0x7d,0xfd
0000c0  038343c3          DCB      0x03,0x83,0x43,0xc3
0000c4  23a363e3          DCB      0x23,0xa3,0x63,0xe3
0000c8  139353d3          DCB      0x13,0x93,0x53,0xd3
0000cc  33b373f3          DCB      0x33,0xb3,0x73,0xf3
0000d0  0b8b4bcb          DCB      0x0b,0x8b,0x4b,0xcb
0000d4  2bab6beb          DCB      0x2b,0xab,0x6b,0xeb
0000d8  1b9b5bdb          DCB      0x1b,0x9b,0x5b,0xdb
0000dc  3bbb7bfb          DCB      0x3b,0xbb,0x7b,0xfb
0000e0  078747c7          DCB      0x07,0x87,0x47,0xc7
0000e4  27a767e7          DCB      0x27,0xa7,0x67,0xe7
0000e8  179757d7          DCB      0x17,0x97,0x57,0xd7
0000ec  37b777f7          DCB      0x37,0xb7,0x77,0xf7
0000f0  0f8f4fcf          DCB      0x0f,0x8f,0x4f,0xcf
0000f4  2faf6fef          DCB      0x2f,0xaf,0x6f,0xef
0000f8  1f9f5fdf          DCB      0x1f,0x9f,0x5f,0xdf
0000fc  3fbf7fff          DCB      0x3f,0xbf,0x7f,0xff

                          AREA ||.data||, DATA, ALIGN=2

                  RMP_Bitmap
                          DCD      0x00000000
                  RMP_Tick
                          DCD      0x00000000
                  RMP_Sched_Lock_Cnt
                          DCD      0x00000000
                  RMP_Sched_Locked
                          DCD      0x00000000
                  RMP_Sched_Pend
                          DCD      0x00000000
                  RMP_Timer_Pend
                          DCD      0x00000000
                  RMP_Cur_Thd
                          DCD      0x00000000
                  RMP_Cur_SP
                          DCD      0x00000000
                  RMP_Delay
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\..\\MProkaron\\Kernel\\kernel.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_kernel_c_346ad0e8____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F0_V1.9.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___8_kernel_c_346ad0e8____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_kernel_c_346ad0e8____REVSH|
#line 402
|__asm___8_kernel_c_346ad0e8____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
