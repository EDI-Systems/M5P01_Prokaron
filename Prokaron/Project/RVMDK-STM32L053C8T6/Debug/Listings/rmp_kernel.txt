; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\rmp_kernel.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\rmp_kernel.d --cpu=Cortex-M0+ --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\STM32L0xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\CMSIS\Device\ST\STM32L0xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_L0_V1.10.0\Drivers\STM32L0xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32L053C8T6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32L0xx_DFP\2.0.0\Drivers\CMSIS\Device\ST\STM32L0xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32L053xx -DSTM32L0xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\rmp_kernel.crf ..\..\MProkaron\Kernel\rmp_kernel.c]
                          THUMB

                          AREA ||i.RMP_CRC16||, CODE, READONLY, ALIGN=2

                  RMP_CRC16 PROC
;;;280    #ifdef __RMP_U16_T__
;;;281    rmp_ptr_t RMP_CRC16(const rmp_u8_t* Data, rmp_ptr_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;282    {
000002  b0c0              SUB      sp,sp,#0x100
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;283        rmp_ptr_t Data_Cnt;
;;;284        rmp_u8_t Index;
;;;285        rmp_u8_t Temp_High;
;;;286        rmp_u8_t Temp_Low;
;;;287        
;;;288        /* CRC16 constants with X^16+X^15+X^2+1 */
;;;289        static const rmp_u8_t CRC16_High[256]=
;;;290        {
;;;291            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;292            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;293            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;294            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;295            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;296            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;297            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;298            0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;299            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;300            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;301            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;302            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;303            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;304            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;305            0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;306            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;307            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;308            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;309            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;310            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;311            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;312            0x00, 0xC1, 0x81, 0x40
;;;313        };
;;;314    
;;;315        const rmp_u8_t CRC16_Low[256]=
000008  22ff              MOVS     r2,#0xff
00000a  3201              ADDS     r2,#1
00000c  490a              LDR      r1,|L1.56|
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       __aeabi_memcpy4
;;;316        {
;;;317            0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,
;;;318            0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,
;;;319            0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9,
;;;320            0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,
;;;321            0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
;;;322            0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,
;;;323            0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,
;;;324            0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38,
;;;325            0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,
;;;326            0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
;;;327            0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,
;;;328            0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,
;;;329            0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB,
;;;330            0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,
;;;331            0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
;;;332            0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,
;;;333            0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,
;;;334            0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,
;;;335            0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89,
;;;336            0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
;;;337            0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83,
;;;338            0x41, 0x81, 0x80, 0x40
;;;339        };
;;;340    
;;;341        Temp_High=0xFF;
000014  23ff              MOVS     r3,#0xff
;;;342        Temp_Low=0xFF;
000016  461a              MOV      r2,r3
;;;343        for(Data_Cnt=0;Data_Cnt<Length;Data_Cnt++)
000018  2d00              CMP      r5,#0
00001a  d009              BEQ      |L1.48|
;;;344        {
;;;345            Index=Temp_Low^Data[Data_Cnt];
;;;346            Temp_Low=(rmp_u8_t)(Temp_High^CRC16_High[Index]);
00001c  4e07              LDR      r6,|L1.60|
00001e  4669              MOV      r1,sp                 ;315
                  |L1.32|
000020  7820              LDRB     r0,[r4,#0]            ;345
;;;347            Temp_High=CRC16_Low[Index];
000022  1c64              ADDS     r4,r4,#1
000024  4050              EORS     r0,r0,r2              ;345
000026  5c32              LDRB     r2,[r6,r0]            ;346
000028  405a              EORS     r2,r2,r3              ;346
00002a  5c0b              LDRB     r3,[r1,r0]
00002c  1e6d              SUBS     r5,r5,#1
00002e  d1f7              BNE      |L1.32|
                  |L1.48|
;;;348        }
;;;349    
;;;350        return (rmp_u16_t)(((rmp_u16_t)Temp_High)<<8|Temp_Low);
000030  0218              LSLS     r0,r3,#8
000032  4310              ORRS     r0,r0,r2
;;;351    }
000034  b040              ADD      sp,sp,#0x100
000036  bd70              POP      {r4-r6,pc}
;;;352    #endif
                          ENDP

                  |L1.56|
                          DCD      ||.constdata||+0x200
                  |L1.60|
                          DCD      ||.constdata||+0x100

                          AREA ||i.RMP_Clear||, CODE, READONLY, ALIGN=1

                  RMP_Clear PROC
;;;67     ******************************************************************************/
;;;68     void RMP_Clear(volatile void* Addr, rmp_ptr_t Size)
000000  2900              CMP      r1,#0
;;;69     {
000002  d00d              BEQ      |L2.32|
;;;70         rmp_u8_t* Ptr;
;;;71         rmp_cnt_t Count;
;;;72        
;;;73         Ptr=(rmp_u8_t*)Addr;
;;;74         for(Count=0;Count<Size;Count++)
;;;75             Ptr[Count]=0;
;;;76     }
000004  07cb              LSLS     r3,r1,#31
000006  2200              MOVS     r2,#0
000008  1e40              SUBS     r0,r0,#1
00000a  2b00              CMP      r3,#0
00000c  d001              BEQ      |L2.18|
00000e  7042              STRB     r2,[r0,#1]            ;75
000010  1c40              ADDS     r0,r0,#1              ;75
                  |L2.18|
000012  0849              LSRS     r1,r1,#1              ;74
000014  d004              BEQ      |L2.32|
                  |L2.22|
000016  7042              STRB     r2,[r0,#1]            ;75
000018  7082              STRB     r2,[r0,#2]            ;75
00001a  1c80              ADDS     r0,r0,#2              ;75
00001c  1e49              SUBS     r1,r1,#1              ;75
00001e  d1fa              BNE      |L2.22|
                  |L2.32|
000020  4770              BX       lr
;;;77     /* End Function:RMP_Clear ****************************************************/
                          ENDP


                          AREA ||i.RMP_Free||, CODE, READONLY, ALIGN=1

                  RMP_Free PROC
;;;2505   ******************************************************************************/
;;;2506   void RMP_Free(volatile void* Pool, void* Mem_Ptr)
000000  2800              CMP      r0,#0
;;;2507   {
;;;2508       volatile struct RMP_Mem* Mem; 
;;;2509       volatile struct RMP_Mem_Head* Mem_Head;
;;;2510       volatile struct RMP_Mem_Head* Left_Head;
;;;2511       volatile struct RMP_Mem_Head* Right_Head;
;;;2512       rmp_cnt_t Merge_Left;
;;;2513   
;;;2514       /* Check if pointer is null */
;;;2515       if((Pool==0)||(Mem_Ptr==0))
000002  d07d              BEQ      |L3.256|
000004  2900              CMP      r1,#0
000006  d07b              BEQ      |L3.256|
;;;2516       {
;;;2517           RMP_COVERAGE_MARKER();
;;;2518           return;
;;;2519       }
;;;2520       else
;;;2521           RMP_COVERAGE_MARKER();
;;;2522       
;;;2523       /* See if the address is within the allocatable address range. If not, abort directly. */
;;;2524       Mem=(volatile struct RMP_Mem*)Pool;
;;;2525       if((((rmp_ptr_t)Mem_Ptr)<=((rmp_ptr_t)Mem))||(((rmp_ptr_t)Mem_Ptr)>=(((rmp_ptr_t)Mem)+Mem->Size)))
000008  4281              CMP      r1,r0
00000a  d979              BLS      |L3.256|
00000c  b5f8              PUSH     {r3-r7,lr}            ;2507
00000e  6902              LDR      r2,[r0,#0x10]
000010  4605              MOV      r5,r0                 ;2507
000012  1950              ADDS     r0,r2,r5
000014  4288              CMP      r0,r1
000016  d94e              BLS      |L3.182|
;;;2526       {
;;;2527           RMP_COVERAGE_MARKER();
;;;2528           return;
;;;2529       }
;;;2530       else
;;;2531           RMP_COVERAGE_MARKER();
;;;2532   
;;;2533       Mem_Head=(struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Ptr)-sizeof(struct RMP_Mem_Head));
000018  460c              MOV      r4,r1
00001a  3c10              SUBS     r4,r4,#0x10
;;;2534       /* See if the block can really be freed */
;;;2535       if(Mem_Head->State==RMP_MEM_FREE)
00001c  68a0              LDR      r0,[r4,#8]
00001e  2800              CMP      r0,#0
000020  d049              BEQ      |L3.182|
;;;2536       {
;;;2537           RMP_COVERAGE_MARKER();
;;;2538           return;
;;;2539       }
;;;2540       else
;;;2541           RMP_COVERAGE_MARKER();
;;;2542   
;;;2543       /* Now we are sure that it can be freed. Delete it from the allocated list now */
;;;2544       RMP_List_Del(Mem_Head->Head.Prev,Mem_Head->Head.Next);
000022  6820              LDR      r0,[r4,#0]
000024  6861              LDR      r1,[r4,#4]
000026  6008              STR      r0,[r1,#0]
000028  6041              STR      r1,[r0,#4]
;;;2545       Mem_Head->State=RMP_MEM_FREE;
00002a  2000              MOVS     r0,#0
00002c  60a0              STR      r0,[r4,#8]
;;;2546       
;;;2547       /* Now check if we can merge it with the higher blocks */
;;;2548       Right_Head=(struct RMP_Mem_Head*)(((rmp_ptr_t)(Mem_Head->Tail))+sizeof(struct RMP_Mem_Tail));
00002e  68e6              LDR      r6,[r4,#0xc]
;;;2549       if(((rmp_ptr_t)Right_Head)!=(((rmp_ptr_t)Mem)+Mem->Size))
000030  6929              LDR      r1,[r5,#0x10]
000032  1d36              ADDS     r6,r6,#4
000034  1948              ADDS     r0,r1,r5
000036  42b0              CMP      r0,r6
000038  d030              BEQ      |L3.156|
;;;2550       {
;;;2551           RMP_COVERAGE_MARKER();
;;;2552           /* If this one is unoccupied */
;;;2553           if((Right_Head->State)==RMP_MEM_FREE)
00003a  68b0              LDR      r0,[r6,#8]
00003c  2800              CMP      r0,#0
00003e  d12d              BNE      |L3.156|
000040  9500              STR      r5,[sp,#0]
000042  68f0              LDR      r0,[r6,#0xc]
000044  1b87              SUBS     r7,r0,r6
000046  3f10              SUBS     r7,r7,#0x10
000048  4638              MOV      r0,r7
00004a  f7fffffe          BL       RMP_MSB_Get
00004e  1ec1              SUBS     r1,r0,#3
000050  40cf              LSRS     r7,r7,r1
000052  0779              LSLS     r1,r7,#29
000054  1f80              SUBS     r0,r0,#6
000056  0f49              LSRS     r1,r1,#29
000058  00c0              LSLS     r0,r0,#3
00005a  1840              ADDS     r0,r0,r1
00005c  9900              LDR      r1,[sp,#0]
00005e  00c2              LSLS     r2,r0,#3
000060  1853              ADDS     r3,r2,r1
000062  6832              LDR      r2,[r6,#0]
000064  6871              LDR      r1,[r6,#4]
000066  600a              STR      r2,[r1,#0]
000068  6051              STR      r1,[r2,#4]
00006a  6ad9              LDR      r1,[r3,#0x2c]
00006c  3328              ADDS     r3,r3,#0x28
00006e  4299              CMP      r1,r3
000070  d10a              BNE      |L3.136|
000072  0941              LSRS     r1,r0,#5
000074  008a              LSLS     r2,r1,#2
000076  9900              LDR      r1,[sp,#0]
000078  1851              ADDS     r1,r2,r1
00007a  694a              LDR      r2,[r1,#0x14]
00007c  06c3              LSLS     r3,r0,#27
00007e  0edb              LSRS     r3,r3,#27
000080  2001              MOVS     r0,#1
000082  4098              LSLS     r0,r0,r3
000084  4382              BICS     r2,r2,r0
000086  614a              STR      r2,[r1,#0x14]
                  |L3.136|
;;;2554           {
;;;2555               RMP_COVERAGE_MARKER();
;;;2556               /* Delete, merge */
;;;2557               _RMP_Mem_Del(Pool,Right_Head);
;;;2558               _RMP_Mem_Block(Mem_Head,
000088  68f0              LDR      r0,[r6,#0xc]
00008a  1b00              SUBS     r0,r0,r4
00008c  2100              MOVS     r1,#0
00008e  60a1              STR      r1,[r4,#8]
000090  1d00              ADDS     r0,r0,#4
000092  1820              ADDS     r0,r4,r0
000094  1f00              SUBS     r0,r0,#4
000096  60e0              STR      r0,[r4,#0xc]
000098  68e0              LDR      r0,[r4,#0xc]
00009a  6004              STR      r4,[r0,#0]
                  |L3.156|
;;;2559                              ((rmp_ptr_t)(Right_Head->Tail))+sizeof(struct RMP_Mem_Tail)-(rmp_ptr_t)Mem_Head);
;;;2560           }
;;;2561           else
;;;2562               RMP_COVERAGE_MARKER();
;;;2563       }
;;;2564       else
;;;2565           RMP_COVERAGE_MARKER();
;;;2566   
;;;2567       /* Now check if we can merge it with the lower blocks */
;;;2568       Merge_Left=0;
;;;2569       if((rmp_ptr_t)Mem_Head!=Mem->Start)
00009c  68e8              LDR      r0,[r5,#0xc]
00009e  42a0              CMP      r0,r4
0000a0  d005              BEQ      |L3.174|
;;;2570       {
;;;2571           RMP_COVERAGE_MARKER();
;;;2572           Left_Head=((struct RMP_Mem_Tail*)(((rmp_ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Tail)))->Head;
0000a2  4620              MOV      r0,r4
0000a4  3880              SUBS     r0,r0,#0x80
;;;2573   
;;;2574           /* If this one is unoccupied */
;;;2575           if(Left_Head->State==RMP_MEM_FREE)
0000a6  6fc6              LDR      r6,[r0,#0x7c]
0000a8  68b0              LDR      r0,[r6,#8]
0000aa  2800              CMP      r0,#0
0000ac  d004              BEQ      |L3.184|
                  |L3.174|
;;;2576           {
;;;2577               RMP_COVERAGE_MARKER();
;;;2578               /* Delete, merge */
;;;2579               _RMP_Mem_Del(Pool, Left_Head);
;;;2580               _RMP_Mem_Block(Left_Head,
;;;2581                              (rmp_ptr_t)((rmp_ptr_t)(Mem_Head->Tail)+sizeof(struct RMP_Mem_Tail)-(rmp_ptr_t)Left_Head));
;;;2582   
;;;2583               /* We have completed the merge here and the original block has destroyed.
;;;2584                * Thus there's no need to insert it into the list again */
;;;2585               Merge_Left=1;
;;;2586           }
;;;2587           else
;;;2588               RMP_COVERAGE_MARKER();
;;;2589       }
;;;2590       else
;;;2591           RMP_COVERAGE_MARKER();
;;;2592   
;;;2593       /* If we did not merge it with the left-side blocks, insert the original pointer's block 
;;;2594        * into the TLSF table(Merging with the right-side one won't disturb this) */
;;;2595       if(Merge_Left==0)
;;;2596       {
;;;2597           RMP_COVERAGE_MARKER();
;;;2598           _RMP_Mem_Ins(Pool, Mem_Head);
0000ae  4621              MOV      r1,r4
0000b0  4628              MOV      r0,r5
0000b2  f7fffffe          BL       _RMP_Mem_Ins
                  |L3.182|
;;;2599       }
;;;2600       else
;;;2601       {
;;;2602           RMP_COVERAGE_MARKER();
;;;2603           _RMP_Mem_Ins(Pool, Left_Head);
;;;2604       }
;;;2605   }
0000b6  bdf8              POP      {r3-r7,pc}
                  |L3.184|
0000b8  68f0              LDR      r0,[r6,#0xc]
0000ba  1b87              SUBS     r7,r0,r6
0000bc  3f10              SUBS     r7,r7,#0x10
0000be  4638              MOV      r0,r7
0000c0  f7fffffe          BL       RMP_MSB_Get
0000c4  1ec1              SUBS     r1,r0,#3
0000c6  40cf              LSRS     r7,r7,r1
0000c8  0779              LSLS     r1,r7,#29
0000ca  1f80              SUBS     r0,r0,#6
0000cc  0f49              LSRS     r1,r1,#29
0000ce  00c0              LSLS     r0,r0,#3
0000d0  1840              ADDS     r0,r0,r1
0000d2  00c1              LSLS     r1,r0,#3
0000d4  6832              LDR      r2,[r6,#0]
0000d6  1949              ADDS     r1,r1,r5
0000d8  6873              LDR      r3,[r6,#4]
0000da  601a              STR      r2,[r3,#0]
0000dc  6053              STR      r3,[r2,#4]
0000de  6aca              LDR      r2,[r1,#0x2c]
0000e0  3128              ADDS     r1,r1,#0x28
0000e2  428a              CMP      r2,r1
0000e4  d109              BNE      |L3.250|
0000e6  0941              LSRS     r1,r0,#5
0000e8  008a              LSLS     r2,r1,#2
0000ea  1951              ADDS     r1,r2,r5
0000ec  694a              LDR      r2,[r1,#0x14]
0000ee  06c3              LSLS     r3,r0,#27
0000f0  0edb              LSRS     r3,r3,#27
0000f2  2001              MOVS     r0,#1
0000f4  4098              LSLS     r0,r0,r3
0000f6  4382              BICS     r2,r2,r0
0000f8  614a              STR      r2,[r1,#0x14]
                  |L3.250|
0000fa  68e0              LDR      r0,[r4,#0xc]          ;2580
0000fc  1b80              SUBS     r0,r0,r6              ;2580
0000fe  e000              B        |L3.258|
                  |L3.256|
000100  e00c              B        |L3.284|
                  |L3.258|
000102  2100              MOVS     r1,#0                 ;2580
000104  60b1              STR      r1,[r6,#8]            ;2580
000106  1d00              ADDS     r0,r0,#4              ;2580
000108  1830              ADDS     r0,r6,r0              ;2580
00010a  1f00              SUBS     r0,r0,#4              ;2580
00010c  60f0              STR      r0,[r6,#0xc]          ;2580
00010e  68f0              LDR      r0,[r6,#0xc]          ;2580
000110  6006              STR      r6,[r0,#0]            ;2580
000112  4631              MOV      r1,r6                 ;2603
000114  4628              MOV      r0,r5                 ;2603
000116  f7fffffe          BL       _RMP_Mem_Ins
00011a  bdf8              POP      {r3-r7,pc}
                  |L3.284|
00011c  4770              BX       lr
;;;2606   /* End Function:RMP_Free *****************************************************/
                          ENDP


                          AREA ||i.RMP_Init||, CODE, READONLY, ALIGN=2

                  RMP_Init PROC
;;;1971   ******************************************************************************/
;;;1972   void RMP_Init(void)
000000  f7fffffe          BL       RMP_Disable_Int
000004  4807              LDR      r0,|L4.36|
000006  2101              MOVS     r1,#1
000008  6081              STR      r1,[r0,#8]  ; RMP_Sched_Locked
00000a  6841              LDR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
00000c  1c49              ADDS     r1,r1,#1
00000e  6041              STR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
;;;1973   {
;;;1974       RMP_Lock_Sched();
;;;1975       
;;;1976       /* Platform will use this hook to do something */
;;;1977       _RMP_Plat_Hook();
000010  f7fffffe          BL       _RMP_Plat_Hook
;;;1978       /* Start the second thread here */
;;;1979       RMP_Init_Hook();
000014  f7fffffe          BL       RMP_Init_Hook
;;;1980       
;;;1981       RMP_Unlock_Sched();
000018  f7fffffe          BL       RMP_Unlock_Sched
                  |L4.28|
;;;1982       
;;;1983       while(1)
;;;1984           RMP_Init_Idle();
00001c  f7fffffe          BL       RMP_Init_Idle
000020  e7fc              B        |L4.28|
;;;1985   }
;;;1986   /* End Function:RMP_Init *****************************************************/
                          ENDP

000022  0000              DCW      0x0000
                  |L4.36|
                          DCD      ||.data||

                          AREA ||i.RMP_LSB_Get||, CODE, READONLY, ALIGN=2

                  RMP_LSB_Get PROC
;;;2119   ******************************************************************************/
;;;2120   rmp_ptr_t RMP_LSB_Get(rmp_ptr_t Val)
000000  b510              PUSH     {r4,lr}
000002  4a11              LDR      r2,|L5.72|
;;;2121   {
000004  0e03              LSRS     r3,r0,#24
000006  5cd3              LDRB     r3,[r2,r3]
000008  0a09              LSRS     r1,r1,#8
00000a  0209              LSLS     r1,r1,#8
00000c  4319              ORRS     r1,r1,r3
00000e  0203              LSLS     r3,r0,#8
000010  0e1b              LSRS     r3,r3,#24
000012  5cd3              LDRB     r3,[r2,r3]
000014  24ff              MOVS     r4,#0xff
000016  0224              LSLS     r4,r4,#8
000018  021b              LSLS     r3,r3,#8
00001a  43a1              BICS     r1,r1,r4
00001c  4023              ANDS     r3,r3,r4
00001e  4319              ORRS     r1,r1,r3
000020  0403              LSLS     r3,r0,#16
000022  0e1b              LSRS     r3,r3,#24
000024  5cd3              LDRB     r3,[r2,r3]
000026  0224              LSLS     r4,r4,#8
000028  041b              LSLS     r3,r3,#16
00002a  43a1              BICS     r1,r1,r4
00002c  4023              ANDS     r3,r3,r4
00002e  b2c0              UXTB     r0,r0
000030  4319              ORRS     r1,r1,r3
000032  5c12              LDRB     r2,[r2,r0]
000034  0208              LSLS     r0,r1,#8
000036  0a00              LSRS     r0,r0,#8
000038  0611              LSLS     r1,r2,#24
00003a  4308              ORRS     r0,r0,r1
;;;2122       return RMP_WORD_SIZE-1-RMP_MSB_Get(RMP_RBIT_Get(Val));
00003c  f7fffffe          BL       RMP_MSB_Get
000040  211f              MOVS     r1,#0x1f
000042  1a08              SUBS     r0,r1,r0
;;;2123   }
000044  bd10              POP      {r4,pc}
;;;2124   /* End Function:RMP_LSB_Get **************************************************/
                          ENDP

000046  0000              DCW      0x0000
                  |L5.72|
                          DCD      ||.constdata||

                          AREA ||i.RMP_List_Crt||, CODE, READONLY, ALIGN=1

                  RMP_List_Crt PROC
;;;231    ******************************************************************************/
;;;232    void RMP_List_Crt(volatile struct RMP_List* Head)
000000  6000              STR      r0,[r0,#0]
;;;233    {
;;;234        Head->Prev=(struct RMP_List*)Head;
;;;235        Head->Next=(struct RMP_List*)Head;
000002  6040              STR      r0,[r0,#4]
;;;236    }
000004  4770              BX       lr
;;;237    /* End Function:RMP_List_Crt *************************************************/
                          ENDP


                          AREA ||i.RMP_List_Del||, CODE, READONLY, ALIGN=1

                  RMP_List_Del PROC
;;;245    ******************************************************************************/
;;;246    void RMP_List_Del(volatile struct RMP_List* Prev,volatile struct RMP_List* Next)
000000  6008              STR      r0,[r1,#0]
;;;247    {
;;;248        Next->Prev=(struct RMP_List*)Prev;
;;;249        Prev->Next=(struct RMP_List*)Next;
000002  6041              STR      r1,[r0,#4]
;;;250    }
000004  4770              BX       lr
;;;251    /* End Function:RMP_List_Del *************************************************/
                          ENDP


                          AREA ||i.RMP_List_Ins||, CODE, READONLY, ALIGN=1

                  RMP_List_Ins PROC
;;;260    ******************************************************************************/
;;;261    void RMP_List_Ins(volatile struct RMP_List* New,
000000  6010              STR      r0,[r2,#0]
;;;262                      volatile struct RMP_List* Prev,
;;;263                      volatile struct RMP_List* Next)
;;;264    {
;;;265        Next->Prev=(struct RMP_List*)New;
;;;266        New->Next=(struct RMP_List*)Next;
000002  6042              STR      r2,[r0,#4]
;;;267        New->Prev=(struct RMP_List*)Prev;
000004  6001              STR      r1,[r0,#0]
;;;268        Prev->Next=(struct RMP_List*)New;
000006  6048              STR      r0,[r1,#4]
;;;269    }
000008  4770              BX       lr
;;;270    /* End Function:RMP_List_Ins *************************************************/
                          ENDP


                          AREA ||i.RMP_Load_Ctx||, CODE, READONLY, ALIGN=1

                  RMP_Load_Ctx PROC
;;;1956   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1957   void RMP_Load_Ctx(void)
000000  4770              BX       lr
;;;1958   {
;;;1959       return;
;;;1960   }
;;;1961   #endif
                          ENDP


                          AREA ||i.RMP_Lock_Sched||, CODE, READONLY, ALIGN=2

                  RMP_Lock_Sched PROC
;;;361    ******************************************************************************/
;;;362    void RMP_Lock_Sched(void)
000000  b510              PUSH     {r4,lr}
;;;363    {
;;;364        RMP_MASK_INT();
000002  f7fffffe          BL       RMP_Disable_Int
;;;365        RMP_Sched_Locked=1;
000006  4803              LDR      r0,|L10.20|
000008  2101              MOVS     r1,#1
00000a  6081              STR      r1,[r0,#8]  ; RMP_Sched_Locked
;;;366        RMP_Sched_Lock_Cnt++;
00000c  6841              LDR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
00000e  1c49              ADDS     r1,r1,#1
000010  6041              STR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
;;;367    }
000012  bd10              POP      {r4,pc}
;;;368    /* End Function:RMP_Lock_Sched ***********************************************/
                          ENDP

                  |L10.20|
                          DCD      ||.data||

                          AREA ||i.RMP_Malloc||, CODE, READONLY, ALIGN=2

                  RMP_Malloc PROC
;;;2431   ******************************************************************************/
;;;2432   void* RMP_Malloc(volatile void* Pool, rmp_ptr_t Size)                                                       
000000  2800              CMP      r0,#0
;;;2433   {    
;;;2434       rmp_cnt_t FLI_Level;
;;;2435       rmp_cnt_t SLI_Level;
;;;2436       volatile struct RMP_Mem* Mem;
;;;2437       rmp_ptr_t Old_Size;
;;;2438       volatile struct RMP_Mem_Head* Mem_Head;
;;;2439       rmp_ptr_t Rounded_Size;
;;;2440       volatile struct RMP_Mem_Head* New_Mem;
;;;2441       rmp_ptr_t New_Size;
;;;2442       
;;;2443       if((Pool==0)||(Size==0))
000002  d001              BEQ      |L11.8|
000004  2900              CMP      r1,#0
000006  d101              BNE      |L11.12|
                  |L11.8|
;;;2444       {
;;;2445           RMP_COVERAGE_MARKER();
;;;2446           return (void*)(0);
000008  2000              MOVS     r0,#0
;;;2447       }
;;;2448       else
;;;2449           RMP_COVERAGE_MARKER();
;;;2450       
;;;2451       /* Round up the size:a multiple of 8 and bigger than 64B */
;;;2452       Rounded_Size=(((Size-1)>>3)+1)<<3;
;;;2453       /* See if it is smaller than the smallest block */
;;;2454       Rounded_Size=(Rounded_Size>64)?Rounded_Size:64;
;;;2455   
;;;2456       /* See if such block exists, if not, abort */
;;;2457       if(_RMP_Mem_Search(Pool,Rounded_Size,&FLI_Level,&SLI_Level)!=0)
;;;2458       {
;;;2459           RMP_COVERAGE_MARKER();
;;;2460           return (void*)(0);
;;;2461       }
;;;2462       else
;;;2463           RMP_COVERAGE_MARKER();
;;;2464       
;;;2465       Mem=(volatile struct RMP_Mem*)Pool;
;;;2466       
;;;2467       /* There is such block. Get it and delete it from the TLSF list. */
;;;2468       Mem_Head=(struct RMP_Mem_Head*)(Mem->Table[RMP_MEM_POS(FLI_Level,SLI_Level)].Next);
;;;2469       _RMP_Mem_Del(Pool, Mem_Head);
;;;2470   
;;;2471       /* Allocate and calculate if the space left could be big enough to be a new 
;;;2472        * block. If so, we will put the block back into the TLSF table */
;;;2473       New_Size=((rmp_ptr_t)(Mem_Head->Tail))-((rmp_ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Head)-Rounded_Size;
;;;2474       if(New_Size>=(sizeof(struct RMP_Mem_Head)+64+sizeof(struct RMP_Mem_Tail)))
;;;2475       {
;;;2476           RMP_COVERAGE_MARKER();
;;;2477           Old_Size=sizeof(struct RMP_Mem_Head)+Rounded_Size+sizeof(struct RMP_Mem_Tail);
;;;2478           New_Mem=(volatile struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Head)+Old_Size);
;;;2479   
;;;2480           _RMP_Mem_Block(Mem_Head, Old_Size);
;;;2481           _RMP_Mem_Block(New_Mem, New_Size);
;;;2482   
;;;2483           /* Put the extra block back */
;;;2484           _RMP_Mem_Ins(Pool, New_Mem);
;;;2485       }
;;;2486       else
;;;2487           RMP_COVERAGE_MARKER();
;;;2488   
;;;2489       /* Insert the allocated block into the lists */
;;;2490       RMP_List_Ins(&(Mem_Head->Head),&(Mem->Alloc),Mem->Alloc.Next);
;;;2491       Mem_Head->State=RMP_MEM_USED;
;;;2492   
;;;2493       /* Finally, return the start address */
;;;2494       return (void*)(((rmp_ptr_t)Mem_Head)+sizeof(struct RMP_Mem_Head));
;;;2495   }
00000a  4770              BX       lr
                  |L11.12|
00000c  b5f0              PUSH     {r4-r7,lr}            ;2433
00000e  4605              MOV      r5,r0                 ;2433
000010  1e49              SUBS     r1,r1,#1              ;2433
000012  08c8              LSRS     r0,r1,#3              ;2452
000014  00c6              LSLS     r6,r0,#3              ;2452
000016  3608              ADDS     r6,r6,#8              ;2452
000018  b083              SUB      sp,sp,#0xc            ;2433
00001a  2e40              CMP      r6,#0x40              ;2454
00001c  d800              BHI      |L11.32|
00001e  2640              MOVS     r6,#0x40              ;2454
                  |L11.32|
000020  462c              MOV      r4,r5                 ;2457
000022  4630              MOV      r0,r6                 ;2457
000024  f7fffffe          BL       RMP_MSB_Get
000028  1f82              SUBS     r2,r0,#6              ;2457
00002a  1ec3              SUBS     r3,r0,#3              ;2457
00002c  4631              MOV      r1,r6                 ;2457
00002e  40d9              LSRS     r1,r1,r3              ;2457
000030  0749              LSLS     r1,r1,#29             ;2457
000032  0f49              LSRS     r1,r1,#29             ;2457
000034  4608              MOV      r0,r1                 ;2457
000036  3008              ADDS     r0,r0,#8              ;2457
000038  4098              LSLS     r0,r0,r3              ;2457
00003a  42b0              CMP      r0,r6                 ;2457
00003c  d004              BEQ      |L11.72|
00003e  1c49              ADDS     r1,r1,#1              ;2457
000040  2908              CMP      r1,#8                 ;2457
000042  d101              BNE      |L11.72|
000044  2100              MOVS     r1,#0                 ;2457
000046  1c52              ADDS     r2,r2,#1              ;2457
                  |L11.72|
000048  68a0              LDR      r0,[r4,#8]            ;2457
00004a  4290              CMP      r0,r2                 ;2457
00004c  d97e              BLS      |L11.332|
00004e  00d0              LSLS     r0,r2,#3              ;2457
000050  1847              ADDS     r7,r0,r1              ;2457
000052  1178              ASRS     r0,r7,#5              ;2457
000054  9001              STR      r0,[sp,#4]            ;2457
000056  0080              LSLS     r0,r0,#2              ;2457
000058  1900              ADDS     r0,r0,r4              ;2457
00005a  6940              LDR      r0,[r0,#0x14]         ;2457
00005c  06f9              LSLS     r1,r7,#27             ;2457
00005e  0ec9              LSRS     r1,r1,#27             ;2457
000060  40c8              LSRS     r0,r0,r1              ;2457
000062  4a59              LDR      r2,|L11.456|
000064  9100              STR      r1,[sp,#0]            ;2457
000066  0e03              LSRS     r3,r0,#24             ;2457
000068  5cd2              LDRB     r2,[r2,r3]            ;2457
00006a  0a09              LSRS     r1,r1,#8              ;2457
00006c  0209              LSLS     r1,r1,#8              ;2457
00006e  4311              ORRS     r1,r1,r2              ;2457
000070  0202              LSLS     r2,r0,#8              ;2457
000072  0e13              LSRS     r3,r2,#24             ;2457
000074  4a54              LDR      r2,|L11.456|
000076  5cd2              LDRB     r2,[r2,r3]            ;2457
000078  23ff              MOVS     r3,#0xff              ;2457
00007a  021b              LSLS     r3,r3,#8              ;2457
00007c  0212              LSLS     r2,r2,#8              ;2457
00007e  4399              BICS     r1,r1,r3              ;2457
000080  401a              ANDS     r2,r2,r3              ;2457
000082  4311              ORRS     r1,r1,r2              ;2457
000084  0402              LSLS     r2,r0,#16             ;2457
000086  0e13              LSRS     r3,r2,#24             ;2457
000088  4a4f              LDR      r2,|L11.456|
00008a  5cd2              LDRB     r2,[r2,r3]            ;2457
00008c  23ff              MOVS     r3,#0xff              ;2457
00008e  041b              LSLS     r3,r3,#16             ;2457
000090  0412              LSLS     r2,r2,#16             ;2457
000092  4399              BICS     r1,r1,r3              ;2457
000094  401a              ANDS     r2,r2,r3              ;2457
000096  4311              ORRS     r1,r1,r2              ;2457
000098  b2c2              UXTB     r2,r0                 ;2457
00009a  484b              LDR      r0,|L11.456|
00009c  5c82              LDRB     r2,[r0,r2]            ;2457
00009e  0208              LSLS     r0,r1,#8              ;2457
0000a0  0a00              LSRS     r0,r0,#8              ;2457
0000a2  0611              LSLS     r1,r2,#24             ;2457
0000a4  4308              ORRS     r0,r0,r1              ;2457
0000a6  f7fffffe          BL       RMP_MSB_Get
0000aa  211f              MOVS     r1,#0x1f              ;2457
0000ac  1a08              SUBS     r0,r1,r0              ;2457
0000ae  2820              CMP      r0,#0x20              ;2457
0000b0  d206              BCS      |L11.192|
0000b2  0979              LSRS     r1,r7,#5              ;2457
0000b4  0149              LSLS     r1,r1,#5              ;2457
0000b6  1809              ADDS     r1,r1,r0              ;2457
0000b8  9800              LDR      r0,[sp,#0]            ;2457
0000ba  1808              ADDS     r0,r1,r0              ;2457
0000bc  10c1              ASRS     r1,r0,#3              ;2457
0000be  e02f              B        |L11.288|
                  |L11.192|
0000c0  9f01              LDR      r7,[sp,#4]            ;2457
0000c2  1c7f              ADDS     r7,r7,#1              ;2457
0000c4  2f05              CMP      r7,#5                 ;2457
0000c6  da7b              BGE      |L11.448|
                  |L11.200|
0000c8  00b8              LSLS     r0,r7,#2              ;2457
0000ca  1900              ADDS     r0,r0,r4              ;2457
0000cc  6940              LDR      r0,[r0,#0x14]         ;2457
0000ce  2800              CMP      r0,#0                 ;2457
0000d0  d073              BEQ      |L11.442|
0000d2  00b8              LSLS     r0,r7,#2              ;2457
0000d4  1900              ADDS     r0,r0,r4              ;2457
0000d6  6941              LDR      r1,[r0,#0x14]         ;2457
0000d8  4a3b              LDR      r2,|L11.456|
0000da  0e0b              LSRS     r3,r1,#24             ;2457
0000dc  5cd3              LDRB     r3,[r2,r3]            ;2457
0000de  0a00              LSRS     r0,r0,#8              ;2457
0000e0  0200              LSLS     r0,r0,#8              ;2457
0000e2  4318              ORRS     r0,r0,r3              ;2457
0000e4  020b              LSLS     r3,r1,#8              ;2457
0000e6  0e1b              LSRS     r3,r3,#24             ;2457
0000e8  5cd3              LDRB     r3,[r2,r3]            ;2457
0000ea  24ff              MOVS     r4,#0xff              ;2457
0000ec  0224              LSLS     r4,r4,#8              ;2457
0000ee  021b              LSLS     r3,r3,#8              ;2457
0000f0  43a0              BICS     r0,r0,r4              ;2457
0000f2  4023              ANDS     r3,r3,r4              ;2457
0000f4  4318              ORRS     r0,r0,r3              ;2457
0000f6  040b              LSLS     r3,r1,#16             ;2457
0000f8  0e1b              LSRS     r3,r3,#24             ;2457
0000fa  5cd3              LDRB     r3,[r2,r3]            ;2457
0000fc  0224              LSLS     r4,r4,#8              ;2457
0000fe  041b              LSLS     r3,r3,#16             ;2457
000100  43a0              BICS     r0,r0,r4              ;2457
000102  4023              ANDS     r3,r3,r4              ;2457
000104  b2c9              UXTB     r1,r1                 ;2457
000106  4318              ORRS     r0,r0,r3              ;2457
000108  5c51              LDRB     r1,[r2,r1]            ;2457
00010a  0200              LSLS     r0,r0,#8              ;2457
00010c  0a00              LSRS     r0,r0,#8              ;2457
00010e  0609              LSLS     r1,r1,#24             ;2457
000110  4308              ORRS     r0,r0,r1              ;2457
000112  f7fffffe          BL       RMP_MSB_Get
000116  211f              MOVS     r1,#0x1f              ;2457
000118  1a08              SUBS     r0,r1,r0              ;2457
00011a  0179              LSLS     r1,r7,#5              ;2457
00011c  1809              ADDS     r1,r1,r0              ;2457
00011e  08c9              LSRS     r1,r1,#3              ;2457
                  |L11.288|
000120  0740              LSLS     r0,r0,#29             ;2457
000122  0f40              LSRS     r0,r0,#29             ;2457
000124  00c9              LSLS     r1,r1,#3              ;2468
000126  1808              ADDS     r0,r1,r0              ;2468
000128  00c0              LSLS     r0,r0,#3              ;2468
00012a  1940              ADDS     r0,r0,r5              ;2468
00012c  6ac4              LDR      r4,[r0,#0x2c]         ;2468
00012e  68e0              LDR      r0,[r4,#0xc]          ;2468
000130  1b07              SUBS     r7,r0,r4              ;2468
000132  3f10              SUBS     r7,r7,#0x10           ;2468
000134  4638              MOV      r0,r7                 ;2468
000136  f7fffffe          BL       RMP_MSB_Get
00013a  1f81              SUBS     r1,r0,#6              ;2468
00013c  1ec0              SUBS     r0,r0,#3              ;2468
00013e  40c7              LSRS     r7,r7,r0              ;2468
000140  077a              LSLS     r2,r7,#29             ;2468
000142  0f52              LSRS     r2,r2,#29             ;2468
000144  00c8              LSLS     r0,r1,#3              ;2468
000146  1880              ADDS     r0,r0,r2              ;2468
000148  00c1              LSLS     r1,r0,#3              ;2468
00014a  e000              B        |L11.334|
                  |L11.332|
00014c  e038              B        |L11.448|
                  |L11.334|
00014e  194b              ADDS     r3,r1,r5              ;2468
000150  6821              LDR      r1,[r4,#0]            ;2468
000152  6862              LDR      r2,[r4,#4]            ;2468
000154  6011              STR      r1,[r2,#0]            ;2468
000156  604a              STR      r2,[r1,#4]            ;2468
000158  6ad9              LDR      r1,[r3,#0x2c]         ;2468
00015a  3328              ADDS     r3,r3,#0x28           ;2468
00015c  4299              CMP      r1,r3                 ;2468
00015e  d109              BNE      |L11.372|
000160  0941              LSRS     r1,r0,#5              ;2468
000162  008a              LSLS     r2,r1,#2              ;2468
000164  1951              ADDS     r1,r2,r5              ;2468
000166  694a              LDR      r2,[r1,#0x14]         ;2468
000168  06c3              LSLS     r3,r0,#27             ;2468
00016a  0edb              LSRS     r3,r3,#27             ;2468
00016c  2001              MOVS     r0,#1                 ;2468
00016e  4098              LSLS     r0,r0,r3              ;2468
000170  4382              BICS     r2,r2,r0              ;2468
000172  614a              STR      r2,[r1,#0x14]         ;2468
                  |L11.372|
000174  68e0              LDR      r0,[r4,#0xc]          ;2473
000176  1b00              SUBS     r0,r0,r4              ;2473
000178  1b82              SUBS     r2,r0,r6              ;2473
00017a  3a10              SUBS     r2,r2,#0x10           ;2473
00017c  2a54              CMP      r2,#0x54              ;2474
00017e  d310              BCC      |L11.418|
000180  3614              ADDS     r6,r6,#0x14           ;2474
000182  19a1              ADDS     r1,r4,r6              ;2478
000184  2300              MOVS     r3,#0                 ;2478
000186  60a3              STR      r3,[r4,#8]            ;2478
000188  1f08              SUBS     r0,r1,#4              ;2478
00018a  60e0              STR      r0,[r4,#0xc]          ;2478
00018c  68e0              LDR      r0,[r4,#0xc]          ;2478
00018e  6004              STR      r4,[r0,#0]            ;2478
000190  608b              STR      r3,[r1,#8]            ;2478
000192  1888              ADDS     r0,r1,r2              ;2478
000194  1f00              SUBS     r0,r0,#4              ;2478
000196  60c8              STR      r0,[r1,#0xc]          ;2478
000198  68c8              LDR      r0,[r1,#0xc]          ;2478
00019a  6001              STR      r1,[r0,#0]            ;2478
00019c  4628              MOV      r0,r5                 ;2484
00019e  f7fffffe          BL       _RMP_Mem_Ins
                  |L11.418|
0001a2  6868              LDR      r0,[r5,#4]            ;2490
0001a4  6004              STR      r4,[r0,#0]            ;2490
0001a6  6060              STR      r0,[r4,#4]            ;2490
0001a8  6025              STR      r5,[r4,#0]            ;2490
0001aa  606c              STR      r4,[r5,#4]            ;2490
0001ac  2001              MOVS     r0,#1                 ;2491
0001ae  60a0              STR      r0,[r4,#8]            ;2491
0001b0  4620              MOV      r0,r4                 ;2494
0001b2  3010              ADDS     r0,r0,#0x10           ;2494
0001b4  b003              ADD      sp,sp,#0xc
0001b6  bdf0              POP      {r4-r7,pc}
0001b8  e7ff              B        |L11.442|
                  |L11.442|
0001ba  1c7f              ADDS     r7,r7,#1
0001bc  2f05              CMP      r7,#5
0001be  db83              BLT      |L11.200|
                  |L11.448|
0001c0  2000              MOVS     r0,#0                 ;2460
0001c2  b003              ADD      sp,sp,#0xc
0001c4  bdf0              POP      {r4-r7,pc}
;;;2496   /* End Function:RMP_Malloc ***************************************************/
                          ENDP

0001c6  0000              DCW      0x0000
                  |L11.456|
                          DCD      ||.constdata||

                          AREA ||i.RMP_Mem_Init||, CODE, READONLY, ALIGN=2

                  RMP_Mem_Init PROC
;;;2160   ******************************************************************************/
;;;2161   rmp_ret_t RMP_Mem_Init(volatile void* Pool, rmp_ptr_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;2162   {
000002  0004              MOVS     r4,r0
;;;2163       rmp_cnt_t FLI_Cnt;
;;;2164       rmp_ptr_t Usable_Size;
;;;2165       volatile struct RMP_Mem* Mem;
;;;2166       volatile struct RMP_Mem_Head* Mem_Head;
;;;2167       
;;;2168       /* See if the memory pool is large enough to enable dynamic allocation - at
;;;2169        * least 4096 words and no more than 128MB */
;;;2170       if((Pool==0)||(Size<(4096*sizeof(rmp_ptr_t)))||(((Size>>15)>>12)>0))
;;;2171       {
;;;2172           RMP_COVERAGE_MARKER();
;;;2173           return RMP_ERR_MEM;
000004  4828              LDR      r0,|L12.168|
000006  460d              MOV      r5,r1                 ;2162
000008  d04c              BEQ      |L12.164|
00000a  2101              MOVS     r1,#1                 ;2170
00000c  0389              LSLS     r1,r1,#14             ;2170
00000e  428d              CMP      r5,r1                 ;2170
000010  d348              BCC      |L12.164|
000012  0ee9              LSRS     r1,r5,#27             ;2170
000014  d146              BNE      |L12.164|
000016  4621              MOV      r1,r4                 ;2170
;;;2174       }
;;;2175       else
;;;2176           RMP_COVERAGE_MARKER();
;;;2177       
;;;2178       /* See if the address and size is word-aligned */
;;;2179       if((((rmp_ptr_t)Pool&(RMP_WORD_MASK>>3))!=0)||((Size&(RMP_WORD_MASK>>3))!=0))
000018  4329              ORRS     r1,r1,r5
00001a  0789              LSLS     r1,r1,#30
00001c  d142              BNE      |L12.164|
;;;2180       {
;;;2181           RMP_COVERAGE_MARKER();
;;;2182           return RMP_ERR_MEM;
;;;2183       }
;;;2184       else
;;;2185           RMP_COVERAGE_MARKER();
;;;2186           
;;;2187       Mem=(volatile struct RMP_Mem*)Pool;
;;;2188       Mem->Size=Size;
00001e  6125              STR      r5,[r4,#0x10]
000020  6024              STR      r4,[r4,#0]
000022  6064              STR      r4,[r4,#4]
;;;2189       /* Initialize the allocated block list */
;;;2190       RMP_List_Crt(&(Mem->Alloc));
;;;2191       /* Calculate the FLI value needed for this - we always align to 64 byte */
;;;2192       Mem->FLI_Num=RMP_MSB_Get(Size-sizeof(struct RMP_Mem))-6+1;
000024  2045              MOVS     r0,#0x45
000026  00c0              LSLS     r0,r0,#3
000028  1a28              SUBS     r0,r5,r0
00002a  f7fffffe          BL       RMP_MSB_Get
00002e  1f40              SUBS     r0,r0,#5
000030  60a0              STR      r0,[r4,#8]
;;;2193       /* Initialize the TLSF allocation table first */
;;;2194       for(FLI_Cnt=0;FLI_Cnt<(rmp_cnt_t)(Mem->FLI_Num);FLI_Cnt++)
000032  68a0              LDR      r0,[r4,#8]
000034  2100              MOVS     r1,#0
000036  4288              CMP      r0,r1
000038  dd1e              BLE      |L12.120|
                  |L12.58|
;;;2195       {
;;;2196           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,0)]));
00003a  018a              LSLS     r2,r1,#6
00003c  1912              ADDS     r2,r2,r4
00003e  4610              MOV      r0,r2
000040  3028              ADDS     r0,r0,#0x28
000042  6290              STR      r0,[r2,#0x28]
000044  62d0              STR      r0,[r2,#0x2c]
;;;2197           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,1)]));
000046  3008              ADDS     r0,r0,#8
000048  6310              STR      r0,[r2,#0x30]
00004a  6350              STR      r0,[r2,#0x34]
;;;2198           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,2)]));
00004c  3008              ADDS     r0,r0,#8
00004e  6390              STR      r0,[r2,#0x38]
000050  63d0              STR      r0,[r2,#0x3c]
;;;2199           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,3)]));
000052  3008              ADDS     r0,r0,#8
000054  6410              STR      r0,[r2,#0x40]
000056  6450              STR      r0,[r2,#0x44]
;;;2200           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,4)]));
000058  3008              ADDS     r0,r0,#8
00005a  6490              STR      r0,[r2,#0x48]
00005c  64d0              STR      r0,[r2,#0x4c]
;;;2201           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,5)]));
00005e  3008              ADDS     r0,r0,#8
000060  6510              STR      r0,[r2,#0x50]
000062  6550              STR      r0,[r2,#0x54]
;;;2202           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,6)]));
000064  3008              ADDS     r0,r0,#8
000066  6590              STR      r0,[r2,#0x58]
000068  65d0              STR      r0,[r2,#0x5c]
00006a  3260              ADDS     r2,r2,#0x60
00006c  6012              STR      r2,[r2,#0]
00006e  6052              STR      r2,[r2,#4]
;;;2203           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,7)]));
000070  68a0              LDR      r0,[r4,#8]
000072  1c49              ADDS     r1,r1,#1
000074  4288              CMP      r0,r1
000076  dce0              BGT      |L12.58|
                  |L12.120|
;;;2204       }
;;;2205       for(FLI_Cnt=0;FLI_Cnt<5;FLI_Cnt++)
;;;2206           Mem->Bitmap[FLI_Cnt]=0;
000078  2000              MOVS     r0,#0
00007a  6160              STR      r0,[r4,#0x14]
00007c  61a0              STR      r0,[r4,#0x18]
00007e  61e0              STR      r0,[r4,#0x1c]
000080  6220              STR      r0,[r4,#0x20]
000082  6260              STR      r0,[r4,#0x24]
;;;2207       
;;;2208       /* Get the big memory block's size and position */
;;;2209       Usable_Size=sizeof(struct RMP_Mem)+(sizeof(struct RMP_List)<<3)*(Mem->FLI_Num-8);
000084  68a1              LDR      r1,[r4,#8]
000086  018a              LSLS     r2,r1,#6
000088  3228              ADDS     r2,r2,#0x28
;;;2210       Mem_Head=(struct RMP_Mem_Head*)(((rmp_ptr_t)Pool)+Usable_Size);
00008a  18a1              ADDS     r1,r4,r2
;;;2211       Mem->Start=(rmp_ptr_t)Mem_Head;
00008c  60e1              STR      r1,[r4,#0xc]
;;;2212       Usable_Size=Size-Usable_Size;
00008e  1aaa              SUBS     r2,r5,r2
000090  6088              STR      r0,[r1,#8]
000092  1888              ADDS     r0,r1,r2
000094  1f00              SUBS     r0,r0,#4
000096  60c8              STR      r0,[r1,#0xc]
000098  68c8              LDR      r0,[r1,#0xc]
00009a  6001              STR      r1,[r0,#0]
;;;2213       
;;;2214       /* Initialize the big block */
;;;2215       _RMP_Mem_Block(Mem_Head,Usable_Size);
;;;2216       
;;;2217       /* Insert the memory into the corresponding level */
;;;2218       _RMP_Mem_Ins(Pool, Mem_Head);
00009c  4620              MOV      r0,r4
00009e  f7fffffe          BL       _RMP_Mem_Ins
;;;2219       return 0;
0000a2  2000              MOVS     r0,#0
                  |L12.164|
;;;2220   }
0000a4  bd70              POP      {r4-r6,pc}
;;;2221   /* End Function:RMP_Mem_Init *************************************************/
                          ENDP

0000a6  0000              DCW      0x0000
                  |L12.168|
                          DCD      0xfffffff9

                          AREA ||i.RMP_Print_Int||, CODE, READONLY, ALIGN=1

                  RMP_Print_Int PROC
;;;85     ******************************************************************************/
;;;86     rmp_cnt_t RMP_Print_Int(rmp_cnt_t Int)
000000  b5f8              PUSH     {r3-r7,lr}
;;;87     {
000002  0006              MOVS     r6,r0
000004  d02b              BEQ      |L13.94|
;;;88         rmp_ptr_t Iter;
;;;89         rmp_cnt_t Count;
;;;90         rmp_cnt_t Num;
;;;91         rmp_ptr_t Div;
;;;92         
;;;93         /* how many digits are there? */
;;;94         if(Int==0)
;;;95         {
;;;96             RMP_Putchar('0');
;;;97             return 1;
;;;98         }
;;;99         else if(Int<0)
000006  2e00              CMP      r6,#0
000008  da2e              BGE      |L13.104|
;;;100        {
;;;101            /* How many digits are there? */
;;;102            Count=0;
00000a  2400              MOVS     r4,#0
;;;103            Div=1;
00000c  2501              MOVS     r5,#1
;;;104            Iter=(rmp_ptr_t)(-Int);
00000e  4240              RSBS     r0,r0,#0
000010  4606              MOV      r6,r0
;;;105            while(Iter!=0)
000012  d007              BEQ      |L13.36|
                  |L13.20|
;;;106            {
;;;107                Iter/=10;
000014  210a              MOVS     r1,#0xa
000016  f7fffffe          BL       __aeabi_uidivmod
;;;108                Count++;
;;;109                Div*=10;
00001a  210a              MOVS     r1,#0xa
00001c  434d              MULS     r5,r1,r5
00001e  1c64              ADDS     r4,r4,#1
000020  2800              CMP      r0,#0                 ;105
000022  d1f7              BNE      |L13.20|
                  |L13.36|
;;;110            }
;;;111            Div/=10;
000024  210a              MOVS     r1,#0xa
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       __aeabi_uidivmod
00002c  4605              MOV      r5,r0
;;;112            
;;;113            RMP_Putchar('-');
00002e  202d              MOVS     r0,#0x2d
000030  f7fffffe          BL       RMP_Putchar
;;;114            Iter=-Int;
;;;115            Num=Count+1;
000034  1c67              ADDS     r7,r4,#1
;;;116            
;;;117            while(Count>0)
000036  2c00              CMP      r4,#0
000038  dd37              BLE      |L13.170|
                  |L13.58|
;;;118            {
;;;119                Count--;
;;;120                RMP_Putchar(Iter/Div+'0');
00003a  4629              MOV      r1,r5
00003c  4630              MOV      r0,r6
00003e  1e64              SUBS     r4,r4,#1
000040  f7fffffe          BL       __aeabi_uidivmod
000044  3030              ADDS     r0,r0,#0x30
000046  460e              MOV      r6,r1
000048  b240              SXTB     r0,r0
00004a  f7fffffe          BL       RMP_Putchar
;;;121                Iter=Iter%Div;
;;;122                Div/=10;
00004e  210a              MOVS     r1,#0xa
000050  4628              MOV      r0,r5
000052  f7fffffe          BL       __aeabi_uidivmod
000056  4605              MOV      r5,r0
000058  2c00              CMP      r4,#0                 ;117
00005a  dcee              BGT      |L13.58|
00005c  e025              B        |L13.170|
                  |L13.94|
00005e  2030              MOVS     r0,#0x30              ;96
000060  f7fffffe          BL       RMP_Putchar
000064  2001              MOVS     r0,#1                 ;97
;;;123            }
;;;124        }
;;;125        else
;;;126        {
;;;127            /* How many digits are there? */
;;;128            Count=0;
;;;129            Div=1;
;;;130            Iter=Int;
;;;131            while(Iter!=0)
;;;132            {
;;;133                Iter/=10;
;;;134                Count++;
;;;135                Div*=10;
;;;136            }
;;;137            Div/=10;
;;;138            
;;;139            Iter=Int;
;;;140            Num=Count;
;;;141            
;;;142            while(Count>0)
;;;143            {
;;;144                Count--;
;;;145                RMP_Putchar(Iter/Div+'0');
;;;146                Iter=Iter%Div;
;;;147                Div/=10;
;;;148            }
;;;149        }
;;;150        
;;;151        return Num;
;;;152    }
000066  bdf8              POP      {r3-r7,pc}
                  |L13.104|
000068  2500              MOVS     r5,#0                 ;128
00006a  2401              MOVS     r4,#1                 ;129
                  |L13.108|
00006c  210a              MOVS     r1,#0xa               ;133
00006e  f7fffffe          BL       __aeabi_uidivmod
000072  210a              MOVS     r1,#0xa               ;135
000074  434c              MULS     r4,r1,r4              ;135
000076  1c6d              ADDS     r5,r5,#1              ;135
000078  2800              CMP      r0,#0                 ;131
00007a  d1f7              BNE      |L13.108|
00007c  4620              MOV      r0,r4                 ;137
00007e  f7fffffe          BL       __aeabi_uidivmod
000082  4604              MOV      r4,r0                 ;137
000084  1e2f              SUBS     r7,r5,#0              ;140
000086  dd10              BLE      |L13.170|
                  |L13.136|
000088  4601              MOV      r1,r0                 ;145
00008a  4630              MOV      r0,r6                 ;145
00008c  1e6d              SUBS     r5,r5,#1              ;145
00008e  f7fffffe          BL       __aeabi_uidivmod
000092  3030              ADDS     r0,r0,#0x30           ;145
000094  460e              MOV      r6,r1                 ;145
000096  b240              SXTB     r0,r0                 ;145
000098  f7fffffe          BL       RMP_Putchar
00009c  210a              MOVS     r1,#0xa               ;147
00009e  4620              MOV      r0,r4                 ;147
0000a0  f7fffffe          BL       __aeabi_uidivmod
0000a4  4604              MOV      r4,r0                 ;147
0000a6  2d00              CMP      r5,#0                 ;142
0000a8  dcee              BGT      |L13.136|
                  |L13.170|
0000aa  4638              MOV      r0,r7                 ;151
0000ac  bdf8              POP      {r3-r7,pc}
;;;153    /* End Function:RMP_Print_Int ************************************************/
                          ENDP


                          AREA ||i.RMP_Print_String||, CODE, READONLY, ALIGN=1

                  RMP_Print_String PROC
;;;208    ******************************************************************************/
;;;209    rmp_cnt_t RMP_Print_String(rmp_s8_t* String)
000000  b570              PUSH     {r4-r6,lr}
;;;210    {
000002  4605              MOV      r5,r0
;;;211        rmp_cnt_t Count;
;;;212        
;;;213        Count=0;
000004  2400              MOVS     r4,#0
                  |L14.6|
;;;214        while(Count<RMP_KERNEL_DEBUG_MAX_STR)
;;;215        {
;;;216            if(String[Count]=='\0')
000006  5728              LDRSB    r0,[r5,r4]
000008  2800              CMP      r0,#0
00000a  d004              BEQ      |L14.22|
00000c  1c64              ADDS     r4,r4,#1
;;;217                break;
;;;218            
;;;219            RMP_Putchar(String[Count++]);
00000e  f7fffffe          BL       RMP_Putchar
000012  2cff              CMP      r4,#0xff              ;214
000014  dbf7              BLT      |L14.6|
                  |L14.22|
;;;220        }
;;;221        
;;;222        return Count;
000016  4620              MOV      r0,r4
;;;223    }
000018  bd70              POP      {r4-r6,pc}
;;;224    /* End Function:RMP_Print_String *********************************************/
                          ENDP


                          AREA ||i.RMP_Print_Uint||, CODE, READONLY, ALIGN=1

                  RMP_Print_Uint PROC
;;;161    ******************************************************************************/
;;;162    rmp_cnt_t RMP_Print_Uint(rmp_ptr_t Uint)
000000  b570              PUSH     {r4-r6,lr}
;;;163    {
000002  0004              MOVS     r4,r0
000004  d003              BEQ      |L15.14|
;;;164        rmp_ptr_t Iter;
;;;165        rmp_cnt_t Count;
;;;166        rmp_cnt_t Num;
;;;167        
;;;168        /* how many digits are there? */
;;;169        if(Uint==0)
;;;170        {
;;;171            RMP_Putchar('0');
;;;172            return 1;
;;;173        }
;;;174        else
;;;175        {
;;;176            /* Filter out all the zeroes */
;;;177            Count=0;
000006  2100              MOVS     r1,#0
;;;178            Iter=Uint;
;;;179            while((Iter>>((sizeof(rmp_ptr_t)*8)-4))==0)
000008  0f02              LSRS     r2,r0,#28
00000a  d005              BEQ      |L15.24|
00000c  e008              B        |L15.32|
                  |L15.14|
00000e  2030              MOVS     r0,#0x30              ;171
000010  f7fffffe          BL       RMP_Putchar
000014  2001              MOVS     r0,#1                 ;172
;;;180            {
;;;181                Iter<<=4;
;;;182                Count++;
;;;183            }
;;;184            /* Count is the number of pts to print */
;;;185            Count=sizeof(rmp_ptr_t)*2-Count;
;;;186            Num=Count;
;;;187            while(Count>0)
;;;188            {
;;;189                Count--;
;;;190                Iter=(Uint>>(Count*4))&0x0F;
;;;191                if(Iter<10)
;;;192                    RMP_Putchar('0'+Iter);
;;;193                else
;;;194                    RMP_Putchar('A'+Iter-10);
;;;195            }
;;;196        }
;;;197        
;;;198        return Num;
;;;199    }
000016  bd70              POP      {r4-r6,pc}
                  |L15.24|
000018  0100              LSLS     r0,r0,#4              ;181
00001a  1c49              ADDS     r1,r1,#1              ;181
00001c  0f02              LSRS     r2,r0,#28             ;179
00001e  d0fb              BEQ      |L15.24|
                  |L15.32|
000020  2008              MOVS     r0,#8                 ;185
000022  1a45              SUBS     r5,r0,r1              ;185
000024  1e2e              SUBS     r6,r5,#0              ;186
000026  dd10              BLE      |L15.74|
                  |L15.40|
000028  4628              MOV      r0,r5                 ;189
00002a  1e6d              SUBS     r5,r5,#1              ;189
00002c  0080              LSLS     r0,r0,#2
00002e  4621              MOV      r1,r4
000030  1f00              SUBS     r0,r0,#4
000032  40c1              LSRS     r1,r1,r0              ;190
000034  0708              LSLS     r0,r1,#28             ;190
000036  0f00              LSRS     r0,r0,#28             ;190
000038  280a              CMP      r0,#0xa               ;191
00003a  d201              BCS      |L15.64|
00003c  3030              ADDS     r0,r0,#0x30           ;191
00003e  e000              B        |L15.66|
                  |L15.64|
000040  3037              ADDS     r0,r0,#0x37           ;192
                  |L15.66|
000042  f7fffffe          BL       RMP_Putchar
000046  2d00              CMP      r5,#0                 ;187
000048  dcee              BGT      |L15.40|
                  |L15.74|
00004a  4630              MOV      r0,r6                 ;198
00004c  bd70              POP      {r4-r6,pc}
;;;200    /* End Function:RMP_Print_Uint ***********************************************/
                          ENDP


                          AREA ||i.RMP_RBIT_Get||, CODE, READONLY, ALIGN=2

                  RMP_RBIT_Get PROC
;;;2078   
;;;2079   rmp_ptr_t RMP_RBIT_Get(rmp_ptr_t Val)
000000  b410              PUSH     {r4}
;;;2080   {
;;;2081       rmp_ptr_t Ret;
;;;2082       rmp_ptr_t Src;
;;;2083       rmp_u8_t* To;
;;;2084       rmp_u8_t* From;
;;;2085       
;;;2086       Src=Val;
;;;2087       To=(rmp_u8_t*)(&Ret);
;;;2088       From=(rmp_u8_t*)(&Src);
;;;2089       
;;;2090   #if(RMP_WORD_ORDER==4)
;;;2091       To[0]=RMP_RBIT_Table[From[1]];
;;;2092       To[1]=RMP_RBIT_Table[From[0]];
;;;2093   #elif(RMP_WORD_ORDER==5)
;;;2094       To[0]=RMP_RBIT_Table[From[3]];
000002  4a0f              LDR      r2,|L16.64|
000004  0e03              LSRS     r3,r0,#24             ;2080
000006  5cd3              LDRB     r3,[r2,r3]
000008  0a09              LSRS     r1,r1,#8
00000a  0209              LSLS     r1,r1,#8
00000c  4319              ORRS     r1,r1,r3
00000e  0203              LSLS     r3,r0,#8
000010  0e1b              LSRS     r3,r3,#24
;;;2095       To[1]=RMP_RBIT_Table[From[2]];
000012  5cd3              LDRB     r3,[r2,r3]
000014  24ff              MOVS     r4,#0xff
000016  0224              LSLS     r4,r4,#8
000018  021b              LSLS     r3,r3,#8
00001a  43a1              BICS     r1,r1,r4
00001c  4023              ANDS     r3,r3,r4
00001e  4319              ORRS     r1,r1,r3
000020  0403              LSLS     r3,r0,#16
000022  0e1b              LSRS     r3,r3,#24
;;;2096       To[2]=RMP_RBIT_Table[From[1]];
000024  5cd3              LDRB     r3,[r2,r3]
000026  0224              LSLS     r4,r4,#8
000028  041b              LSLS     r3,r3,#16
00002a  43a1              BICS     r1,r1,r4
00002c  4023              ANDS     r3,r3,r4
00002e  b2c0              UXTB     r0,r0
;;;2097       To[3]=RMP_RBIT_Table[From[0]];
000030  5c12              LDRB     r2,[r2,r0]
000032  4319              ORRS     r1,r1,r3              ;2096
000034  0208              LSLS     r0,r1,#8
000036  0a00              LSRS     r0,r0,#8
000038  0611              LSLS     r1,r2,#24
;;;2098   #else
;;;2099       To[0]=RMP_RBIT_Table[From[7]];
;;;2100       To[1]=RMP_RBIT_Table[From[6]];
;;;2101       To[2]=RMP_RBIT_Table[From[5]];
;;;2102       To[3]=RMP_RBIT_Table[From[4]];
;;;2103       To[4]=RMP_RBIT_Table[From[3]];
;;;2104       To[5]=RMP_RBIT_Table[From[2]];
;;;2105       To[6]=RMP_RBIT_Table[From[1]];
;;;2106       To[7]=RMP_RBIT_Table[From[0]];
;;;2107   #endif
;;;2108   
;;;2109       return Ret;
;;;2110   }
00003a  bc10              POP      {r4}
00003c  4308              ORRS     r0,r0,r1              ;2097
00003e  4770              BX       lr
;;;2111   /* End Function:RMP_RBIT_Get *************************************************/
                          ENDP

                  |L16.64|
                          DCD      ||.constdata||

                          AREA ||i.RMP_Save_Ctx||, CODE, READONLY, ALIGN=1

                  RMP_Save_Ctx PROC
;;;1942   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1943   void RMP_Save_Ctx(void)
000000  4770              BX       lr
;;;1944   {
;;;1945       return;
;;;1946   }
;;;1947   #endif
                          ENDP


                          AREA ||i.RMP_Sem_Abort||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Abort PROC
;;;1737   ******************************************************************************/
;;;1738   rmp_ret_t RMP_Sem_Abort(volatile struct RMP_Thd* Thread)
000000  b570              PUSH     {r4-r6,lr}
;;;1739   {
;;;1740       /* Check if this thread structure could possibly be in use */
;;;1741       if(Thread==0)
;;;1742       {
;;;1743           RMP_COVERAGE_MARKER();
;;;1744           return RMP_ERR_THD;
000002  4d1e              LDR      r5,|L18.124|
000004  0004              MOVS     r4,r0                 ;1739
000006  d017              BEQ      |L18.56|
000008  f7fffffe          BL       RMP_Disable_Int
00000c  481c              LDR      r0,|L18.128|
00000e  2101              MOVS     r1,#1                 ;1739
000010  6081              STR      r1,[r0,#8]            ;1739  ; RMP_Sched_Locked
000012  6841              LDR      r1,[r0,#4]            ;1739  ; RMP_Sched_Lock_Cnt
000014  1c49              ADDS     r1,r1,#1              ;1739
000016  6041              STR      r1,[r0,#4]            ;1739  ; RMP_Sched_Lock_Cnt
;;;1745       }
;;;1746       else
;;;1747           RMP_COVERAGE_MARKER();
;;;1748   
;;;1749       RMP_Lock_Sched();
;;;1750       
;;;1751       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
000018  69a0              LDR      r0,[r4,#0x18]
00001a  0600              LSLS     r0,r0,#24
00001c  0e00              LSRS     r0,r0,#24
00001e  d00d              BEQ      |L18.60|
;;;1752       {
;;;1753           RMP_COVERAGE_MARKER();
;;;1754           RMP_Unlock_Sched();
;;;1755           return RMP_ERR_THD;
;;;1756       }
;;;1757       else
;;;1758           RMP_COVERAGE_MARKER();
;;;1759       
;;;1760       /* Is it waiting on a semaphore? If no, we abort and return an error code */
;;;1761       if((RMP_THD_STATE(Thread->State)!=RMP_THD_SEMBLK)&&
000020  69a0              LDR      r0,[r4,#0x18]
000022  b2c0              UXTB     r0,r0
000024  2807              CMP      r0,#7
000026  d00d              BEQ      |L18.68|
000028  69a0              LDR      r0,[r4,#0x18]
00002a  b2c0              UXTB     r0,r0
00002c  2808              CMP      r0,#8
00002e  d009              BEQ      |L18.68|
;;;1762          (RMP_THD_STATE(Thread->State)!=RMP_THD_SEMDLY))
;;;1763       {
;;;1764           RMP_COVERAGE_MARKER();
;;;1765           RMP_Unlock_Sched();
000030  f7fffffe          BL       RMP_Unlock_Sched
;;;1766           return RMP_ERR_STATE;
000034  00a8              LSLS     r0,r5,#2
;;;1767       }
;;;1768       else
;;;1769           RMP_COVERAGE_MARKER();
;;;1770   
;;;1771       /* Waiting for a semaphore. We abort it and return */
;;;1772       RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1773       if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1774       {
;;;1775           RMP_COVERAGE_MARKER();
;;;1776           RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1777       }
;;;1778       else
;;;1779           RMP_COVERAGE_MARKER();
;;;1780       
;;;1781       RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1782       /* Set to running if not suspended */
;;;1783       _RMP_Set_Rdy(Thread);
;;;1784       
;;;1785       Thread->Retval=RMP_ERR_OPER;
;;;1786       RMP_Unlock_Sched();
;;;1787       return 0;
;;;1788   }
000036  bd70              POP      {r4-r6,pc}
                  |L18.56|
000038  4628              MOV      r0,r5                 ;1744
00003a  bd70              POP      {r4-r6,pc}
                  |L18.60|
00003c  f7fffffe          BL       RMP_Unlock_Sched
000040  4628              MOV      r0,r5                 ;1755
000042  bd70              POP      {r4-r6,pc}
                  |L18.68|
000044  6820              LDR      r0,[r4,#0]            ;1772
000046  6861              LDR      r1,[r4,#4]            ;1772
000048  6008              STR      r0,[r1,#0]            ;1772
00004a  6041              STR      r1,[r0,#4]            ;1772
00004c  69a0              LDR      r0,[r4,#0x18]         ;1773
00004e  b2c0              UXTB     r0,r0                 ;1773
000050  2808              CMP      r0,#8                 ;1773
000052  d103              BNE      |L18.92|
000054  68a1              LDR      r1,[r4,#8]            ;1776
000056  68e0              LDR      r0,[r4,#0xc]          ;1776
000058  6001              STR      r1,[r0,#0]            ;1776
00005a  6048              STR      r0,[r1,#4]            ;1776
                  |L18.92|
00005c  69a0              LDR      r0,[r4,#0x18]         ;1781
00005e  0a00              LSRS     r0,r0,#8              ;1781
000060  0200              LSLS     r0,r0,#8              ;1781
000062  1c40              ADDS     r0,r0,#1              ;1781
000064  61a0              STR      r0,[r4,#0x18]         ;1781
000066  4620              MOV      r0,r4                 ;1783
000068  f7fffffe          BL       _RMP_Set_Rdy
00006c  2004              MOVS     r0,#4                 ;1785
00006e  43c0              MVNS     r0,r0                 ;1785
000070  63a0              STR      r0,[r4,#0x38]         ;1785
000072  f7fffffe          BL       RMP_Unlock_Sched
000076  2000              MOVS     r0,#0                 ;1787
000078  bd70              POP      {r4-r6,pc}
;;;1789   /* End Function:RMP_Sem_Abort ************************************************/
                          ENDP

00007a  0000              DCW      0x0000
                  |L18.124|
                          DCD      0xffffffff
                  |L18.128|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Crt||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Crt PROC
;;;1556   ******************************************************************************/
;;;1557   rmp_ret_t RMP_Sem_Crt(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number)
000000  b570              PUSH     {r4-r6,lr}
;;;1558   {
;;;1559       /* Check if this semaphore structure could possibly be in use */
;;;1560       if(Semaphore==0)
;;;1561       {
;;;1562           RMP_COVERAGE_MARKER();
;;;1563           return RMP_ERR_SEM;
000002  4e13              LDR      r6,|L19.80|
000004  460d              MOV      r5,r1                 ;1558
000006  0004              MOVS     r4,r0                 ;1558
000008  d00e              BEQ      |L19.40|
00000a  f7fffffe          BL       RMP_Disable_Int
00000e  4811              LDR      r0,|L19.84|
000010  2101              MOVS     r1,#1                 ;1558
000012  6081              STR      r1,[r0,#8]            ;1558  ; RMP_Sched_Locked
000014  6842              LDR      r2,[r0,#4]            ;1558  ; RMP_Sched_Lock_Cnt
000016  1c52              ADDS     r2,r2,#1              ;1558
000018  6042              STR      r2,[r0,#4]            ;1558  ; RMP_Sched_Lock_Cnt
;;;1564       }
;;;1565       else
;;;1566           RMP_COVERAGE_MARKER();
;;;1567       
;;;1568       RMP_Lock_Sched();
;;;1569       
;;;1570       if(Semaphore->State!=RMP_SEM_FREE)
00001a  68a0              LDR      r0,[r4,#8]
00001c  2800              CMP      r0,#0
00001e  d005              BEQ      |L19.44|
;;;1571       {
;;;1572           RMP_COVERAGE_MARKER();
;;;1573           RMP_Unlock_Sched();
000020  f7fffffe          BL       RMP_Unlock_Sched
;;;1574           return RMP_ERR_SEM;
000024  4630              MOV      r0,r6
;;;1575       }
;;;1576       else
;;;1577           RMP_COVERAGE_MARKER();
;;;1578       
;;;1579       /* Is the number too great to initialize? */
;;;1580       if(Number>=RMP_SEM_MAX_NUM)
;;;1581       {
;;;1582           RMP_COVERAGE_MARKER();
;;;1583           RMP_Unlock_Sched();
;;;1584           return RMP_ERR_OPER;
;;;1585       }
;;;1586       else
;;;1587           RMP_COVERAGE_MARKER();
;;;1588   
;;;1589       /* Initialize contents */
;;;1590       Semaphore->Cur_Num=Number;
;;;1591       Semaphore->State=RMP_SEM_USED;
;;;1592       RMP_List_Crt(&(Semaphore->Wait_List));
;;;1593       
;;;1594       RMP_Unlock_Sched();
;;;1595       
;;;1596       return 0;
;;;1597   }
000026  bd70              POP      {r4-r6,pc}
                  |L19.40|
000028  4630              MOV      r0,r6                 ;1563
00002a  bd70              POP      {r4-r6,pc}
                  |L19.44|
00002c  207d              MOVS     r0,#0x7d              ;1580
00002e  00c0              LSLS     r0,r0,#3              ;1580
000030  4285              CMP      r5,r0                 ;1580
000032  d304              BCC      |L19.62|
000034  f7fffffe          BL       RMP_Unlock_Sched
000038  2004              MOVS     r0,#4                 ;1584
00003a  43c0              MVNS     r0,r0                 ;1584
00003c  bd70              POP      {r4-r6,pc}
                  |L19.62|
00003e  60e5              STR      r5,[r4,#0xc]          ;1590
000040  60a1              STR      r1,[r4,#8]            ;1591
000042  6024              STR      r4,[r4,#0]            ;1591
000044  6064              STR      r4,[r4,#4]            ;1591
000046  f7fffffe          BL       RMP_Unlock_Sched
00004a  2000              MOVS     r0,#0                 ;1596
00004c  bd70              POP      {r4-r6,pc}
;;;1598   /* End Function:RMP_Sem_Crt **************************************************/
                          ENDP

00004e  0000              DCW      0x0000
                  |L19.80|
                          DCD      0xfffffffa
                  |L19.84|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Del||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Del PROC
;;;1605   ******************************************************************************/
;;;1606   rmp_ret_t RMP_Sem_Del(volatile struct RMP_Sem* Semaphore)
000000  b570              PUSH     {r4-r6,lr}
;;;1607   {
;;;1608       struct RMP_Thd* Thread;
;;;1609       
;;;1610       /* Check if this semaphore structure could possibly be in use */
;;;1611       if(Semaphore==0)
;;;1612       {
;;;1613           RMP_COVERAGE_MARKER();
;;;1614           return RMP_ERR_SEM;
000002  4c1b              LDR      r4,|L20.112|
000004  0005              MOVS     r5,r0                 ;1607
000006  d00e              BEQ      |L20.38|
000008  f7fffffe          BL       RMP_Disable_Int
00000c  4819              LDR      r0,|L20.116|
00000e  2101              MOVS     r1,#1                 ;1607
000010  6081              STR      r1,[r0,#8]            ;1607  ; RMP_Sched_Locked
000012  6841              LDR      r1,[r0,#4]            ;1607  ; RMP_Sched_Lock_Cnt
000014  1c49              ADDS     r1,r1,#1              ;1607
000016  6041              STR      r1,[r0,#4]            ;1607  ; RMP_Sched_Lock_Cnt
;;;1615       }
;;;1616       else
;;;1617           RMP_COVERAGE_MARKER();
;;;1618       
;;;1619       RMP_Lock_Sched();
;;;1620       
;;;1621       if(Semaphore->State!=RMP_SEM_USED)
000018  68a8              LDR      r0,[r5,#8]
00001a  2801              CMP      r0,#1
00001c  d005              BEQ      |L20.42|
;;;1622       {
;;;1623           RMP_COVERAGE_MARKER();
;;;1624           RMP_Unlock_Sched();
00001e  f7fffffe          BL       RMP_Unlock_Sched
;;;1625           return RMP_ERR_SEM;
000022  4620              MOV      r0,r4
;;;1626       }
;;;1627       else
;;;1628           RMP_COVERAGE_MARKER();
;;;1629   
;;;1630       /* Get rid of all guys waiting on it */
;;;1631       while(&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)
;;;1632       {
;;;1633           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1634           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1635           
;;;1636           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1637           {
;;;1638               RMP_COVERAGE_MARKER();
;;;1639               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1640           }
;;;1641           else
;;;1642               RMP_COVERAGE_MARKER();
;;;1643   
;;;1644           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1645           /* Set to running if not suspended */
;;;1646           _RMP_Set_Rdy(Thread);
;;;1647           Thread->Retval=RMP_ERR_OPER;
;;;1648       }
;;;1649       Semaphore->State=RMP_SEM_FREE;
;;;1650       
;;;1651       RMP_Unlock_Sched();
;;;1652   
;;;1653       return 0;
;;;1654   }
000024  bd70              POP      {r4-r6,pc}
                  |L20.38|
000026  4620              MOV      r0,r4                 ;1614
000028  bd70              POP      {r4-r6,pc}
                  |L20.42|
00002a  6868              LDR      r0,[r5,#4]            ;1631
00002c  42a8              CMP      r0,r5                 ;1631
00002e  d019              BEQ      |L20.100|
000030  2604              MOVS     r6,#4                 ;1647
000032  43f6              MVNS     r6,r6                 ;1647
                  |L20.52|
000034  686c              LDR      r4,[r5,#4]            ;1633
000036  6861              LDR      r1,[r4,#4]            ;1633
000038  6820              LDR      r0,[r4,#0]            ;1633
00003a  6008              STR      r0,[r1,#0]            ;1633
00003c  6041              STR      r1,[r0,#4]            ;1633
00003e  7e20              LDRB     r0,[r4,#0x18]         ;1636
000040  2808              CMP      r0,#8                 ;1636
000042  d103              BNE      |L20.76|
000044  68e1              LDR      r1,[r4,#0xc]          ;1636
000046  68a0              LDR      r0,[r4,#8]            ;1636
000048  6008              STR      r0,[r1,#0]            ;1636
00004a  6041              STR      r1,[r0,#4]            ;1636
                  |L20.76|
00004c  69a0              LDR      r0,[r4,#0x18]         ;1644
00004e  0a00              LSRS     r0,r0,#8              ;1644
000050  0200              LSLS     r0,r0,#8              ;1644
000052  1c40              ADDS     r0,r0,#1              ;1644
000054  61a0              STR      r0,[r4,#0x18]         ;1646
000056  4620              MOV      r0,r4                 ;1646
000058  f7fffffe          BL       _RMP_Set_Rdy
00005c  63a6              STR      r6,[r4,#0x38]         ;1647
00005e  6868              LDR      r0,[r5,#4]            ;1647
000060  42a8              CMP      r0,r5                 ;1647
000062  d1e7              BNE      |L20.52|
                  |L20.100|
000064  2000              MOVS     r0,#0                 ;1649
000066  60a8              STR      r0,[r5,#8]            ;1649
000068  f7fffffe          BL       RMP_Unlock_Sched
00006c  2000              MOVS     r0,#0                 ;1653
00006e  bd70              POP      {r4-r6,pc}
;;;1655   /* End Function:RMP_Sem_Del **************************************************/
                          ENDP

                  |L20.112|
                          DCD      0xfffffffa
                  |L20.116|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Pend||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Pend PROC
;;;1663   ******************************************************************************/
;;;1664   rmp_ret_t RMP_Sem_Pend(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Slices)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1665   {
;;;1666       /* Check if this semaphore structure could possibly be in use */
;;;1667       if(Semaphore==0)
;;;1668       {
;;;1669           RMP_COVERAGE_MARKER();
;;;1670           return RMP_ERR_SEM;
000002  4f2f              LDR      r7,|L21.192|
000004  460e              MOV      r6,r1                 ;1665
000006  0005              MOVS     r5,r0                 ;1665
000008  d00e              BEQ      |L21.40|
00000a  f7fffffe          BL       RMP_Disable_Int
00000e  4c2d              LDR      r4,|L21.196|
000010  2001              MOVS     r0,#1                 ;1665
000012  60a0              STR      r0,[r4,#8]            ;1665  ; RMP_Sched_Locked
000014  6860              LDR      r0,[r4,#4]            ;1665  ; RMP_Sched_Lock_Cnt
000016  1c40              ADDS     r0,r0,#1              ;1665
000018  6060              STR      r0,[r4,#4]            ;1665  ; RMP_Sched_Lock_Cnt
;;;1671       }
;;;1672       else
;;;1673           RMP_COVERAGE_MARKER();
;;;1674       
;;;1675       RMP_Lock_Sched();
;;;1676       
;;;1677       if(Semaphore->State!=RMP_SEM_USED)
00001a  68a8              LDR      r0,[r5,#8]
00001c  2801              CMP      r0,#1
00001e  d005              BEQ      |L21.44|
;;;1678       {
;;;1679           RMP_COVERAGE_MARKER();
;;;1680           RMP_Unlock_Sched();
000020  f7fffffe          BL       RMP_Unlock_Sched
;;;1681           return RMP_ERR_SEM;
000024  4638              MOV      r0,r7
;;;1682       }
;;;1683       else
;;;1684           RMP_COVERAGE_MARKER();
;;;1685       
;;;1686       /* Check if we can get one immediately */
;;;1687       if(Semaphore->Cur_Num!=0)
;;;1688       {
;;;1689           RMP_COVERAGE_MARKER();
;;;1690           Semaphore->Cur_Num--;
;;;1691           RMP_Unlock_Sched();
;;;1692           return Semaphore->Cur_Num;
;;;1693       }
;;;1694       else
;;;1695       {
;;;1696           RMP_COVERAGE_MARKER();
;;;1697           /* Cannot get one, we need to block */
;;;1698           if(Slices==0)
;;;1699           {
;;;1700               RMP_COVERAGE_MARKER();
;;;1701               RMP_Unlock_Sched();
;;;1702               return RMP_ERR_OPER;
;;;1703           }
;;;1704           else
;;;1705               RMP_COVERAGE_MARKER();
;;;1706   
;;;1707           /* We must be running - place into waitlist now */
;;;1708           _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1709           RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Semaphore->Wait_List.Prev,&(Semaphore->Wait_List));
;;;1710           
;;;1711           if(Slices<RMP_MAX_SLICES)
;;;1712           {
;;;1713               RMP_COVERAGE_MARKER();
;;;1714               _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1715               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMDLY);
;;;1716           }
;;;1717           else
;;;1718           {
;;;1719               RMP_COVERAGE_MARKER();
;;;1720               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMBLK);
;;;1721           }
;;;1722           
;;;1723           RMP_Cur_Thd->Retval=0;
;;;1724       }
;;;1725       
;;;1726       RMP_Unlock_Sched();
;;;1727   
;;;1728       return RMP_Cur_Thd->Retval;
;;;1729   }
000026  bdf8              POP      {r3-r7,pc}
                  |L21.40|
000028  4638              MOV      r0,r7                 ;1670
00002a  bdf8              POP      {r3-r7,pc}
                  |L21.44|
00002c  68e8              LDR      r0,[r5,#0xc]          ;1687
00002e  2800              CMP      r0,#0                 ;1687
000030  d006              BEQ      |L21.64|
000032  68e8              LDR      r0,[r5,#0xc]          ;1690
000034  1e40              SUBS     r0,r0,#1              ;1690
000036  60e8              STR      r0,[r5,#0xc]          ;1690
000038  f7fffffe          BL       RMP_Unlock_Sched
00003c  68e8              LDR      r0,[r5,#0xc]          ;1692
00003e  bdf8              POP      {r3-r7,pc}
                  |L21.64|
000040  2e00              CMP      r6,#0                 ;1698
000042  d030              BEQ      |L21.166|
000044  69a0              LDR      r0,[r4,#0x18]         ;1708  ; RMP_Cur_Thd
000046  f7fffffe          BL       _RMP_Clr_Rdy
00004a  69a0              LDR      r0,[r4,#0x18]         ;1709  ; RMP_Cur_Thd
00004c  6829              LDR      r1,[r5,#0]            ;1709
00004e  6028              STR      r0,[r5,#0]            ;1709
000050  6045              STR      r5,[r0,#4]            ;1709
000052  6001              STR      r1,[r0,#0]            ;1709
000054  6048              STR      r0,[r1,#4]            ;1709
000056  481c              LDR      r0,|L21.200|
000058  4286              CMP      r6,r0                 ;1711
00005a  d229              BCS      |L21.176|
00005c  69a1              LDR      r1,[r4,#0x18]         ;1714  ; RMP_Cur_Thd
00005e  4b1b              LDR      r3,|L21.204|
000060  6858              LDR      r0,[r3,#4]            ;1714  ; RMP_Delay
000062  4298              CMP      r0,r3                 ;1714
000064  d007              BEQ      |L21.118|
                  |L21.102|
000066  6a02              LDR      r2,[r0,#0x20]         ;1714
000068  6965              LDR      r5,[r4,#0x14]         ;1714  ; RMP_Tick
00006a  1b52              SUBS     r2,r2,r5              ;1714
00006c  42b2              CMP      r2,r6                 ;1714
00006e  d802              BHI      |L21.118|
000070  6840              LDR      r0,[r0,#4]            ;1714
000072  4298              CMP      r0,r3                 ;1714
000074  d1f7              BNE      |L21.102|
                  |L21.118|
000076  6962              LDR      r2,[r4,#0x14]         ;1714  ; RMP_Tick
000078  1992              ADDS     r2,r2,r6              ;1714
00007a  628a              STR      r2,[r1,#0x28]         ;1714
00007c  3108              ADDS     r1,r1,#8              ;1714
00007e  6802              LDR      r2,[r0,#0]            ;1714
000080  6001              STR      r1,[r0,#0]            ;1714
000082  6048              STR      r0,[r1,#4]            ;1714
000084  600a              STR      r2,[r1,#0]            ;1714
000086  6051              STR      r1,[r2,#4]            ;1714
000088  69a0              LDR      r0,[r4,#0x18]         ;1715  ; RMP_Cur_Thd
00008a  69a1              LDR      r1,[r4,#0x18]         ;1715  ; RMP_Cur_Thd
00008c  6980              LDR      r0,[r0,#0x18]         ;1715
00008e  0a00              LSRS     r0,r0,#8              ;1715
000090  0200              LSLS     r0,r0,#8              ;1715
000092  3008              ADDS     r0,r0,#8              ;1715
                  |L21.148|
000094  6188              STR      r0,[r1,#0x18]         ;1723
000096  69a1              LDR      r1,[r4,#0x18]         ;1723  ; RMP_Cur_Thd
000098  2000              MOVS     r0,#0                 ;1723
00009a  6388              STR      r0,[r1,#0x38]         ;1726
00009c  f7fffffe          BL       RMP_Unlock_Sched
0000a0  69a0              LDR      r0,[r4,#0x18]         ;1728  ; RMP_Cur_Thd
0000a2  6b80              LDR      r0,[r0,#0x38]         ;1728
0000a4  bdf8              POP      {r3-r7,pc}
                  |L21.166|
0000a6  f7fffffe          BL       RMP_Unlock_Sched
0000aa  2004              MOVS     r0,#4                 ;1702
0000ac  43c0              MVNS     r0,r0                 ;1702
0000ae  bdf8              POP      {r3-r7,pc}
                  |L21.176|
0000b0  69a0              LDR      r0,[r4,#0x18]         ;1720  ; RMP_Cur_Thd
0000b2  69a1              LDR      r1,[r4,#0x18]         ;1720  ; RMP_Cur_Thd
0000b4  6980              LDR      r0,[r0,#0x18]         ;1720
0000b6  0a00              LSRS     r0,r0,#8              ;1720
0000b8  0200              LSLS     r0,r0,#8              ;1720
0000ba  1dc0              ADDS     r0,r0,#7              ;1720
0000bc  e7ea              B        |L21.148|
;;;1730   /* End Function:RMP_Sem_Pend *************************************************/
                          ENDP

0000be  0000              DCW      0x0000
                  |L21.192|
                          DCD      0xfffffffa
                  |L21.196|
                          DCD      ||.data||
                  |L21.200|
                          DCD      0x000186a0
                  |L21.204|
                          DCD      ||.data||+0x20

                          AREA ||i.RMP_Sem_Post||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Post PROC
;;;1797   ******************************************************************************/
;;;1798   rmp_ret_t RMP_Sem_Post(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number)
000000  b570              PUSH     {r4-r6,lr}
;;;1799   {
;;;1800       struct RMP_Thd* Thread;
;;;1801       
;;;1802       /* Check if this semaphore structure could possibly be in use */
;;;1803       if((Semaphore==0)||(Number==0))
;;;1804       {
;;;1805           RMP_COVERAGE_MARKER();
;;;1806           return RMP_ERR_SEM;
000002  4e24              LDR      r6,|L22.148|
000004  460d              MOV      r5,r1                 ;1799
000006  0004              MOVS     r4,r0                 ;1799
000008  d010              BEQ      |L22.44|
00000a  2d00              CMP      r5,#0                 ;1803
00000c  d00e              BEQ      |L22.44|
00000e  f7fffffe          BL       RMP_Disable_Int
000012  4821              LDR      r0,|L22.152|
000014  2101              MOVS     r1,#1                 ;1803
000016  6081              STR      r1,[r0,#8]            ;1803  ; RMP_Sched_Locked
000018  6841              LDR      r1,[r0,#4]            ;1803  ; RMP_Sched_Lock_Cnt
00001a  1c49              ADDS     r1,r1,#1              ;1803
00001c  6041              STR      r1,[r0,#4]            ;1803  ; RMP_Sched_Lock_Cnt
;;;1807       }
;;;1808       else
;;;1809           RMP_COVERAGE_MARKER();
;;;1810       
;;;1811       RMP_Lock_Sched();
;;;1812       
;;;1813       if(Semaphore->State!=RMP_SEM_USED)
00001e  68a0              LDR      r0,[r4,#8]
000020  2801              CMP      r0,#1
000022  d005              BEQ      |L22.48|
;;;1814       {
;;;1815           RMP_COVERAGE_MARKER();
;;;1816           RMP_Unlock_Sched();
000024  f7fffffe          BL       RMP_Unlock_Sched
;;;1817           return RMP_ERR_SEM;
000028  4630              MOV      r0,r6
;;;1818       }
;;;1819       else
;;;1820           RMP_COVERAGE_MARKER();
;;;1821       
;;;1822       /* Would the maximum value be exceeded if this is posted? */
;;;1823       if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
;;;1824       {
;;;1825           RMP_COVERAGE_MARKER();
;;;1826           RMP_Unlock_Sched();
;;;1827           return RMP_ERR_OPER;
;;;1828       }
;;;1829       else
;;;1830           RMP_COVERAGE_MARKER();
;;;1831       
;;;1832       Semaphore->Cur_Num+=Number;
;;;1833       /* Is there any thread waiting on it? If there are, clean them up*/
;;;1834       while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
;;;1835       {
;;;1836           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1837           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1838           
;;;1839           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1840           {
;;;1841               RMP_COVERAGE_MARKER();
;;;1842               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1843           }
;;;1844           else
;;;1845               RMP_COVERAGE_MARKER();
;;;1846           
;;;1847           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1848           /* Set to running if not suspended */
;;;1849           _RMP_Set_Rdy(Thread);
;;;1850   
;;;1851           /* Finally, return success */
;;;1852           Thread->Retval=0;
;;;1853           Semaphore->Cur_Num--;
;;;1854       }
;;;1855   
;;;1856       RMP_Unlock_Sched();
;;;1857       return 0;
;;;1858   }
00002a  bd70              POP      {r4-r6,pc}
                  |L22.44|
00002c  4630              MOV      r0,r6                 ;1806
00002e  bd70              POP      {r4-r6,pc}
                  |L22.48|
000030  68e0              LDR      r0,[r4,#0xc]          ;1823
000032  217d              MOVS     r1,#0x7d              ;1823
000034  1940              ADDS     r0,r0,r5              ;1823
000036  00c9              LSLS     r1,r1,#3              ;1823
000038  4288              CMP      r0,r1                 ;1823
00003a  d304              BCC      |L22.70|
00003c  f7fffffe          BL       RMP_Unlock_Sched
000040  2004              MOVS     r0,#4                 ;1827
000042  43c0              MVNS     r0,r0                 ;1827
000044  bd70              POP      {r4-r6,pc}
                  |L22.70|
000046  68e0              LDR      r0,[r4,#0xc]          ;1832
000048  1940              ADDS     r0,r0,r5              ;1832
00004a  60e0              STR      r0,[r4,#0xc]          ;1832
00004c  2600              MOVS     r6,#0                 ;1832
00004e  e017              B        |L22.128|
                  |L22.80|
000050  6865              LDR      r5,[r4,#4]            ;1836
000052  6869              LDR      r1,[r5,#4]            ;1836
000054  6828              LDR      r0,[r5,#0]            ;1836
000056  6008              STR      r0,[r1,#0]            ;1836
000058  6041              STR      r1,[r0,#4]            ;1836
00005a  7e28              LDRB     r0,[r5,#0x18]         ;1839
00005c  2808              CMP      r0,#8                 ;1839
00005e  d103              BNE      |L22.104|
000060  68e9              LDR      r1,[r5,#0xc]          ;1839
000062  68a8              LDR      r0,[r5,#8]            ;1839
000064  6008              STR      r0,[r1,#0]            ;1839
000066  6041              STR      r1,[r0,#4]            ;1839
                  |L22.104|
000068  69a8              LDR      r0,[r5,#0x18]         ;1847
00006a  0a00              LSRS     r0,r0,#8              ;1847
00006c  0200              LSLS     r0,r0,#8              ;1847
00006e  1c40              ADDS     r0,r0,#1              ;1847
000070  61a8              STR      r0,[r5,#0x18]         ;1849
000072  4628              MOV      r0,r5                 ;1849
000074  f7fffffe          BL       _RMP_Set_Rdy
000078  63ae              STR      r6,[r5,#0x38]         ;1853
00007a  68e0              LDR      r0,[r4,#0xc]          ;1853
00007c  1e40              SUBS     r0,r0,#1              ;1853
00007e  60e0              STR      r0,[r4,#0xc]          ;1853
                  |L22.128|
000080  6860              LDR      r0,[r4,#4]            ;1853
000082  42a0              CMP      r0,r4                 ;1853
000084  d002              BEQ      |L22.140|
000086  68e0              LDR      r0,[r4,#0xc]          ;1853
000088  2800              CMP      r0,#0                 ;1853
00008a  d1e1              BNE      |L22.80|
                  |L22.140|
00008c  f7fffffe          BL       RMP_Unlock_Sched
000090  2000              MOVS     r0,#0                 ;1857
000092  bd70              POP      {r4-r6,pc}
;;;1859   /* End Function:RMP_Sem_Post *************************************************/
                          ENDP

                  |L22.148|
                          DCD      0xfffffffa
                  |L22.152|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Post_ISR||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Post_ISR PROC
;;;1869   ******************************************************************************/
;;;1870   rmp_ret_t RMP_Sem_Post_ISR(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1871   {
000002  0004              MOVS     r4,r0
;;;1872       struct RMP_Thd* Thread;
;;;1873       /* Check if this semaphore structure could possibly be in use */
;;;1874       if((Semaphore==0)||(Number==0))
;;;1875       {
;;;1876           RMP_COVERAGE_MARKER();
;;;1877           return RMP_ERR_SEM;
000004  481d              LDR      r0,|L23.124|
000006  d00c              BEQ      |L23.34|
000008  2900              CMP      r1,#0                 ;1874
00000a  d00a              BEQ      |L23.34|
;;;1878       }
;;;1879       else
;;;1880           RMP_COVERAGE_MARKER();
;;;1881       
;;;1882       if(Semaphore->State!=RMP_SEM_USED)
00000c  68a2              LDR      r2,[r4,#8]
00000e  2a01              CMP      r2,#1
000010  d107              BNE      |L23.34|
;;;1883       {
;;;1884           RMP_COVERAGE_MARKER();
;;;1885           return RMP_ERR_SEM;
;;;1886       }
;;;1887       else
;;;1888           RMP_COVERAGE_MARKER();
;;;1889   
;;;1890       /* Would the maximum value be exceeded if this is posted? */
;;;1891       if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
000012  68e0              LDR      r0,[r4,#0xc]
000014  227d              MOVS     r2,#0x7d
000016  1840              ADDS     r0,r0,r1
000018  00d2              LSLS     r2,r2,#3
00001a  4290              CMP      r0,r2
00001c  d302              BCC      |L23.36|
;;;1892       {
;;;1893           RMP_COVERAGE_MARKER();
;;;1894           return RMP_ERR_OPER;
00001e  2004              MOVS     r0,#4
000020  43c0              MVNS     r0,r0
                  |L23.34|
;;;1895       }
;;;1896       else
;;;1897           RMP_COVERAGE_MARKER();
;;;1898       
;;;1899       Semaphore->Cur_Num+=Number;
;;;1900       /* Is there any thread waiting on it? If there are, clean them up*/
;;;1901       while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
;;;1902       {
;;;1903           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1904           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1905           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1906           {
;;;1907               RMP_COVERAGE_MARKER();
;;;1908               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1909           }
;;;1910           else
;;;1911               RMP_COVERAGE_MARKER();
;;;1912           
;;;1913           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1914           /* Set to running if not suspended */
;;;1915           _RMP_Set_Rdy(Thread);
;;;1916           
;;;1917           /* If schedule pending, trigger it now because we are in ISR */
;;;1918           if(RMP_Sched_Pend!=0)
;;;1919           {
;;;1920               RMP_COVERAGE_MARKER();
;;;1921               RMP_Sched_Pend=0;
;;;1922               _RMP_Yield();   
;;;1923           }
;;;1924           else
;;;1925               RMP_COVERAGE_MARKER();
;;;1926   
;;;1927           /* Finally, return success */
;;;1928           Thread->Retval=0;
;;;1929           Semaphore->Cur_Num--;
;;;1930       }
;;;1931   
;;;1932       return 0;
;;;1933   }
000022  bdf8              POP      {r3-r7,pc}
                  |L23.36|
000024  68e0              LDR      r0,[r4,#0xc]          ;1899
000026  1840              ADDS     r0,r0,r1              ;1899
000028  60e0              STR      r0,[r4,#0xc]          ;1899
00002a  4e15              LDR      r6,|L23.128|
00002c  2700              MOVS     r7,#0                 ;1918
00002e  e01d              B        |L23.108|
                  |L23.48|
000030  6865              LDR      r5,[r4,#4]            ;1903
000032  6869              LDR      r1,[r5,#4]            ;1903
000034  6828              LDR      r0,[r5,#0]            ;1903
000036  6008              STR      r0,[r1,#0]            ;1903
000038  6041              STR      r1,[r0,#4]            ;1903
00003a  7e28              LDRB     r0,[r5,#0x18]         ;1905
00003c  2808              CMP      r0,#8                 ;1905
00003e  d103              BNE      |L23.72|
000040  68e9              LDR      r1,[r5,#0xc]          ;1905
000042  68a8              LDR      r0,[r5,#8]            ;1905
000044  6008              STR      r0,[r1,#0]            ;1905
000046  6041              STR      r1,[r0,#4]            ;1905
                  |L23.72|
000048  69a8              LDR      r0,[r5,#0x18]         ;1913
00004a  0a00              LSRS     r0,r0,#8              ;1913
00004c  0200              LSLS     r0,r0,#8              ;1913
00004e  1c40              ADDS     r0,r0,#1              ;1913
000050  61a8              STR      r0,[r5,#0x18]         ;1915
000052  4628              MOV      r0,r5                 ;1915
000054  f7fffffe          BL       _RMP_Set_Rdy
000058  68f0              LDR      r0,[r6,#0xc]          ;1918  ; RMP_Sched_Pend
00005a  2800              CMP      r0,#0                 ;1918
00005c  d002              BEQ      |L23.100|
00005e  60f7              STR      r7,[r6,#0xc]          ;1921  ; RMP_Sched_Pend
000060  f7fffffe          BL       _RMP_Yield
                  |L23.100|
000064  63af              STR      r7,[r5,#0x38]         ;1929
000066  68e0              LDR      r0,[r4,#0xc]          ;1929
000068  1e40              SUBS     r0,r0,#1              ;1929
00006a  60e0              STR      r0,[r4,#0xc]          ;1929
                  |L23.108|
00006c  6860              LDR      r0,[r4,#4]            ;1929
00006e  42a0              CMP      r0,r4                 ;1929
000070  d002              BEQ      |L23.120|
000072  68e0              LDR      r0,[r4,#0xc]          ;1929
000074  2800              CMP      r0,#0                 ;1929
000076  d1db              BNE      |L23.48|
                  |L23.120|
000078  2000              MOVS     r0,#0                 ;1932
00007a  bdf8              POP      {r3-r7,pc}
;;;1934   /* End Function:RMP_Sem_Post_ISR *********************************************/
                          ENDP

                  |L23.124|
                          DCD      0xfffffffa
                  |L23.128|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Cancel||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Cancel PROC
;;;1514   ******************************************************************************/
;;;1515   rmp_ret_t RMP_Thd_Cancel(volatile struct RMP_Thd* Thread)
000000  2800              CMP      r0,#0
;;;1516   {
;;;1517       /* Check if this thread structure could possibly be in use */
;;;1518       if(Thread==0)
000002  d101              BNE      |L24.8|
;;;1519       {
;;;1520           RMP_COVERAGE_MARKER();
;;;1521           return RMP_ERR_THD;
000004  1e40              SUBS     r0,r0,#1
;;;1522       }
;;;1523       else
;;;1524           RMP_COVERAGE_MARKER();
;;;1525       
;;;1526       RMP_Lock_Sched();
;;;1527       
;;;1528       /* Is it delayed? */
;;;1529       if(RMP_THD_STATE(Thread->State)!=RMP_THD_DELAYED)
;;;1530       {
;;;1531           RMP_COVERAGE_MARKER();
;;;1532           RMP_Unlock_Sched();
;;;1533           return RMP_ERR_STATE;
;;;1534       }
;;;1535       else
;;;1536           RMP_COVERAGE_MARKER();
;;;1537   
;;;1538       /* Delete it from the delay list */
;;;1539       RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1540       RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1541       /* Set to running if not suspended */
;;;1542       _RMP_Set_Rdy(Thread);
;;;1543       
;;;1544       Thread->Retval=RMP_ERR_OPER;
;;;1545       RMP_Unlock_Sched();
;;;1546       return 0;
;;;1547   }
000006  4770              BX       lr
                  |L24.8|
000008  b510              PUSH     {r4,lr}               ;1516
00000a  4604              MOV      r4,r0                 ;1516
00000c  f7fffffe          BL       RMP_Disable_Int
000010  4810              LDR      r0,|L24.84|
000012  2101              MOVS     r1,#1                 ;1516
000014  6081              STR      r1,[r0,#8]            ;1516  ; RMP_Sched_Locked
000016  6841              LDR      r1,[r0,#4]            ;1516  ; RMP_Sched_Lock_Cnt
000018  1c49              ADDS     r1,r1,#1              ;1516
00001a  6041              STR      r1,[r0,#4]            ;1516  ; RMP_Sched_Lock_Cnt
00001c  69a0              LDR      r0,[r4,#0x18]         ;1529
00001e  b2c0              UXTB     r0,r0                 ;1529
000020  2806              CMP      r0,#6                 ;1529
000022  d004              BEQ      |L24.46|
000024  f7fffffe          BL       RMP_Unlock_Sched
000028  2003              MOVS     r0,#3                 ;1533
00002a  43c0              MVNS     r0,r0                 ;1533
00002c  bd10              POP      {r4,pc}
                  |L24.46|
00002e  68a1              LDR      r1,[r4,#8]            ;1539
000030  68e0              LDR      r0,[r4,#0xc]          ;1539
000032  6001              STR      r1,[r0,#0]            ;1539
000034  6048              STR      r0,[r1,#4]            ;1539
000036  69a0              LDR      r0,[r4,#0x18]         ;1540
000038  0a00              LSRS     r0,r0,#8              ;1540
00003a  0200              LSLS     r0,r0,#8              ;1540
00003c  1c40              ADDS     r0,r0,#1              ;1540
00003e  61a0              STR      r0,[r4,#0x18]         ;1540
000040  4620              MOV      r0,r4                 ;1542
000042  f7fffffe          BL       _RMP_Set_Rdy
000046  2004              MOVS     r0,#4                 ;1544
000048  43c0              MVNS     r0,r0                 ;1544
00004a  63a0              STR      r0,[r4,#0x38]         ;1544
00004c  f7fffffe          BL       RMP_Unlock_Sched
000050  2000              MOVS     r0,#0                 ;1546
000052  bd10              POP      {r4,pc}
;;;1548   /* End Function:RMP_Thd_Cancel ***********************************************/
                          ENDP

                  |L24.84|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Crt||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Crt PROC
;;;766    ******************************************************************************/
;;;767    rmp_ret_t RMP_Thd_Crt(volatile struct RMP_Thd* Thread, void* Entry, void* Stack, void* Arg, rmp_ptr_t Prio, rmp_ptr_t Slices)
000000  b5ff              PUSH     {r0-r7,lr}
;;;768    {
000002  b081              SUB      sp,sp,#4
;;;769        /* Check if the priority and timeslice range is correct */
;;;770        if(Prio>=RMP_MAX_PREEMPT_PRIO)
000004  9f0a              LDR      r7,[sp,#0x28]
000006  9e0b              LDR      r6,[sp,#0x2c]
000008  4604              MOV      r4,r0                 ;768
00000a  2f20              CMP      r7,#0x20
00000c  d303              BCC      |L25.22|
;;;771        {
;;;772            RMP_COVERAGE_MARKER();
;;;773            return RMP_ERR_PRIO;
00000e  2001              MOVS     r0,#1
000010  43c0              MVNS     r0,r0
;;;774        }
;;;775        else
;;;776            RMP_COVERAGE_MARKER();
;;;777        
;;;778        if((Slices==0)||(Slices>=RMP_MAX_SLICES))
;;;779        {
;;;780            RMP_COVERAGE_MARKER();
;;;781            return RMP_ERR_SLICE;
;;;782        }
;;;783        else
;;;784            RMP_COVERAGE_MARKER();
;;;785        
;;;786        /* Check if this thread structure could possibly be in use */
;;;787        if(Thread==0)
;;;788        {
;;;789            RMP_COVERAGE_MARKER();
;;;790            return RMP_ERR_THD;
;;;791        }
;;;792        else
;;;793            RMP_COVERAGE_MARKER();
;;;794        
;;;795        RMP_Lock_Sched();
;;;796        
;;;797        if(RMP_THD_STATE(Thread->State)!=RMP_THD_FREE)
;;;798        {
;;;799            RMP_COVERAGE_MARKER();
;;;800            RMP_Unlock_Sched();
;;;801            return RMP_ERR_THD;
;;;802        }
;;;803        else
;;;804            RMP_COVERAGE_MARKER();
;;;805        
;;;806        /* Create the thread and insert it into the list */
;;;807        Thread->Prio=Prio;
;;;808        Thread->Slices=Slices;
;;;809        Thread->Slices_Left=Slices;
;;;810        Thread->Stack=(rmp_ptr_t)Stack;
;;;811        
;;;812        /* Initialize its stack and sending list */
;;;813        _RMP_Stack_Init((rmp_ptr_t)Entry, (rmp_ptr_t)Stack, (rmp_ptr_t)Arg);
;;;814        RMP_List_Crt(&(Thread->Snd_List));
;;;815        
;;;816        /* Notify the scheduler that we have created something new, also check locks */
;;;817        Thread->State=RMP_THD_RUNNING;
;;;818        _RMP_Set_Rdy(Thread);
;;;819        
;;;820        RMP_Unlock_Sched();
;;;821    
;;;822        return 0;
;;;823    }
000012  b005              ADD      sp,sp,#0x14
000014  bdf0              POP      {r4-r7,pc}
                  |L25.22|
000016  2e00              CMP      r6,#0                 ;778
000018  d002              BEQ      |L25.32|
00001a  481a              LDR      r0,|L25.132|
00001c  4286              CMP      r6,r0                 ;778
00001e  d303              BCC      |L25.40|
                  |L25.32|
000020  2002              MOVS     r0,#2                 ;781
000022  43c0              MVNS     r0,r0                 ;781
000024  b005              ADD      sp,sp,#0x14
000026  bdf0              POP      {r4-r7,pc}
                  |L25.40|
000028  2c00              CMP      r4,#0                 ;787
00002a  d010              BEQ      |L25.78|
00002c  f7fffffe          BL       RMP_Disable_Int
000030  4815              LDR      r0,|L25.136|
000032  2501              MOVS     r5,#1                 ;787
000034  6085              STR      r5,[r0,#8]            ;787  ; RMP_Sched_Locked
000036  6841              LDR      r1,[r0,#4]            ;787  ; RMP_Sched_Lock_Cnt
000038  1c49              ADDS     r1,r1,#1              ;787
00003a  6041              STR      r1,[r0,#4]            ;787  ; RMP_Sched_Lock_Cnt
00003c  69a0              LDR      r0,[r4,#0x18]         ;797
00003e  0600              LSLS     r0,r0,#24             ;797
000040  0e00              LSRS     r0,r0,#24             ;797
000042  d008              BEQ      |L25.86|
000044  f7fffffe          BL       RMP_Unlock_Sched
000048  1ea8              SUBS     r0,r5,#2              ;801
00004a  b005              ADD      sp,sp,#0x14
00004c  bdf0              POP      {r4-r7,pc}
                  |L25.78|
00004e  2000              MOVS     r0,#0                 ;790
000050  43c0              MVNS     r0,r0                 ;790
000052  b005              ADD      sp,sp,#0x14
000054  bdf0              POP      {r4-r7,pc}
                  |L25.86|
000056  6267              STR      r7,[r4,#0x24]         ;807
000058  61e6              STR      r6,[r4,#0x1c]         ;808
00005a  6226              STR      r6,[r4,#0x20]         ;809
00005c  9803              LDR      r0,[sp,#0xc]          ;810
00005e  6360              STR      r0,[r4,#0x34]         ;810
000060  9a04              LDR      r2,[sp,#0x10]         ;813
000062  9903              LDR      r1,[sp,#0xc]          ;813
000064  9802              LDR      r0,[sp,#8]            ;813
000066  f7fffffe          BL       _RMP_Stack_Init
00006a  4620              MOV      r0,r4                 ;814
00006c  3010              ADDS     r0,r0,#0x10           ;814
00006e  6120              STR      r0,[r4,#0x10]         ;814
000070  6160              STR      r0,[r4,#0x14]         ;814
000072  61a5              STR      r5,[r4,#0x18]         ;817
000074  4620              MOV      r0,r4                 ;818
000076  f7fffffe          BL       _RMP_Set_Rdy
00007a  f7fffffe          BL       RMP_Unlock_Sched
00007e  2000              MOVS     r0,#0                 ;822
000080  b005              ADD      sp,sp,#0x14
000082  bdf0              POP      {r4-r7,pc}
;;;824    /* End Function:RMP_Thd_Crt **************************************************/
                          ENDP

                  |L25.132|
                          DCD      0x000186a0
                  |L25.136|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Del||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Del PROC
;;;831    ******************************************************************************/
;;;832    rmp_ret_t RMP_Thd_Del(volatile struct RMP_Thd* Thread)
000000  b5f8              PUSH     {r3-r7,lr}
;;;833    {
;;;834        struct RMP_Thd* Release;
;;;835        
;;;836        /* Check if this thread structure could possibly be in use */
;;;837        if(Thread==0)
;;;838        {
;;;839            RMP_COVERAGE_MARKER();
;;;840            return RMP_ERR_THD;
000002  4d32              LDR      r5,|L26.204|
000004  0004              MOVS     r4,r0                 ;833
000006  d01a              BEQ      |L26.62|
000008  f7fffffe          BL       RMP_Disable_Int
00000c  4830              LDR      r0,|L26.208|
00000e  2101              MOVS     r1,#1                 ;833
000010  6081              STR      r1,[r0,#8]            ;833  ; RMP_Sched_Locked
000012  6841              LDR      r1,[r0,#4]            ;833  ; RMP_Sched_Lock_Cnt
000014  1c49              ADDS     r1,r1,#1              ;833
000016  6041              STR      r1,[r0,#4]            ;833  ; RMP_Sched_Lock_Cnt
;;;841        }
;;;842        else
;;;843            RMP_COVERAGE_MARKER();
;;;844        
;;;845        RMP_Lock_Sched();
;;;846        
;;;847        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
000018  69a0              LDR      r0,[r4,#0x18]
00001a  0600              LSLS     r0,r0,#24
00001c  0e00              LSRS     r0,r0,#24
00001e  d010              BEQ      |L26.66|
;;;848        {
;;;849            RMP_COVERAGE_MARKER();
;;;850            RMP_Unlock_Sched();
;;;851            return RMP_ERR_THD;
;;;852        }
;;;853        else
;;;854            RMP_COVERAGE_MARKER();
;;;855        
;;;856        /* See if anyone waiting to send to this thread. If there is, release all these threads */
;;;857        while(&(Thread->Snd_List)!=Thread->Snd_List.Next)
000020  6960              LDR      r0,[r4,#0x14]
000022  4626              MOV      r6,r4
000024  3610              ADDS     r6,r6,#0x10
;;;858        {
;;;859            Release=(struct RMP_Thd*)(Thread->Snd_List.Next);
;;;860            RMP_List_Del(Release->Run_Head.Prev,Release->Run_Head.Next);
;;;861            if(RMP_THD_STATE(Release->State)==RMP_THD_SNDDLY)
;;;862            {
;;;863                RMP_COVERAGE_MARKER();
;;;864                RMP_List_Del(Release->Dly_Head.Prev,Release->Dly_Head.Next);
;;;865            }
;;;866            else
;;;867                RMP_COVERAGE_MARKER();
;;;868            
;;;869            RMP_THD_STATE_SET(Release->State,RMP_THD_RUNNING);
;;;870            /* Set ready if not suspended */
;;;871            _RMP_Set_Rdy(Release);
;;;872            Release->Retval=RMP_ERR_OPER;
000026  1f2f              SUBS     r7,r5,#4
000028  42b0              CMP      r0,r6                 ;857
00002a  d01e              BEQ      |L26.106|
                  |L26.44|
00002c  6965              LDR      r5,[r4,#0x14]         ;859
00002e  6869              LDR      r1,[r5,#4]            ;859
000030  6828              LDR      r0,[r5,#0]            ;859
000032  6008              STR      r0,[r1,#0]            ;859
000034  6041              STR      r1,[r0,#4]            ;859
000036  7e28              LDRB     r0,[r5,#0x18]         ;861
000038  2803              CMP      r0,#3                 ;861
00003a  d006              BEQ      |L26.74|
00003c  e009              B        |L26.82|
                  |L26.62|
00003e  4628              MOV      r0,r5                 ;840
;;;873        }
;;;874        
;;;875        /* See what is its state */
;;;876        switch(RMP_THD_STATE(Thread->State))
;;;877        {
;;;878            case RMP_THD_RUNNING:
;;;879            {
;;;880                RMP_COVERAGE_MARKER();
;;;881                /* Clear ready if not suspended */
;;;882                _RMP_Clr_Rdy(Thread);
;;;883                break;
;;;884            }
;;;885            
;;;886            /* Do nothing if it is blocked on receive */
;;;887            case RMP_THD_RCVBLK:
;;;888            {
;;;889                RMP_COVERAGE_MARKER();
;;;890                break;
;;;891            }
;;;892            
;;;893            case RMP_THD_SNDBLK:RMP_COVERAGE_MARKER();
;;;894            case RMP_THD_SEMBLK:
;;;895            {
;;;896                RMP_COVERAGE_MARKER();
;;;897                RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;898                break;
;;;899            }
;;;900            
;;;901            case RMP_THD_SNDDLY:RMP_COVERAGE_MARKER();
;;;902            case RMP_THD_SEMDLY:
;;;903            {
;;;904                RMP_COVERAGE_MARKER();
;;;905                RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;906                /* Fall-through case */
;;;907            }
;;;908            case RMP_THD_RCVDLY:RMP_COVERAGE_MARKER();
;;;909            case RMP_THD_DELAYED:
;;;910            {
;;;911                RMP_COVERAGE_MARKER();
;;;912                RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;913                break;
;;;914            }
;;;915            /* Should not get here */
;;;916            default:while(1);
;;;917        }
;;;918        /* Set return value to failure anyway */
;;;919        Thread->Retval=RMP_ERR_OPER;
;;;920        Thread->State=RMP_THD_FREE;
;;;921        /* If we are deleting ourself, pend a yield */
;;;922        if(Thread==RMP_Cur_Thd)
;;;923        {
;;;924            RMP_COVERAGE_MARKER();
;;;925            RMP_Sched_Pend=1;
;;;926        }
;;;927        else
;;;928            RMP_COVERAGE_MARKER();
;;;929        
;;;930        RMP_Unlock_Sched();
;;;931        
;;;932        /* If we are deleting ourself, just stop the execution here */
;;;933        if(Thread==RMP_Cur_Thd)
;;;934            while(1);
;;;935        else
;;;936            RMP_COVERAGE_MARKER();
;;;937    
;;;938        return 0;
;;;939    }
000040  bdf8              POP      {r3-r7,pc}
                  |L26.66|
000042  f7fffffe          BL       RMP_Unlock_Sched
000046  4628              MOV      r0,r5                 ;851
000048  bdf8              POP      {r3-r7,pc}
                  |L26.74|
00004a  68e9              LDR      r1,[r5,#0xc]
00004c  68a8              LDR      r0,[r5,#8]
00004e  6008              STR      r0,[r1,#0]
000050  6041              STR      r1,[r0,#4]
                  |L26.82|
000052  69a8              LDR      r0,[r5,#0x18]         ;869
000054  0a00              LSRS     r0,r0,#8              ;869
000056  0200              LSLS     r0,r0,#8              ;869
000058  1c40              ADDS     r0,r0,#1              ;869
00005a  61a8              STR      r0,[r5,#0x18]         ;871
00005c  4628              MOV      r0,r5                 ;871
00005e  f7fffffe          BL       _RMP_Set_Rdy
000062  63af              STR      r7,[r5,#0x38]         ;872
000064  6960              LDR      r0,[r4,#0x14]         ;872
000066  42b0              CMP      r0,r6                 ;872
000068  d1e0              BNE      |L26.44|
                  |L26.106|
00006a  69a0              LDR      r0,[r4,#0x18]         ;876
00006c  b2c0              UXTB     r0,r0                 ;876
00006e  2809              CMP      r0,#9                 ;876
000070  d229              BCS      |L26.198|
000072  0001              MOVS     r1,r0                 ;876
000074  4479              ADD      r1,r1,pc              ;876
000076  7909              LDRB     r1,[r1,#4]            ;876
000078  1849              ADDS     r1,r1,r1              ;876
00007a  448f              ADD      pc,pc,r1              ;876
00007c  2404080d          DCB      0x24,0x04,0x08,0x0d
000080  15111108          DCB      0x15,0x11,0x11,0x08
000084  0d00              DCB      0x0d,0x00
000086  4620              MOV      r0,r4                 ;882
000088  f7fffffe          BL       _RMP_Clr_Rdy
00008c  e00c              B        |L26.168|
00008e  6820              LDR      r0,[r4,#0]            ;897
000090  6861              LDR      r1,[r4,#4]            ;897
000092  6008              STR      r0,[r1,#0]            ;897
000094  6041              STR      r1,[r0,#4]            ;897
000096  e007              B        |L26.168|
000098  6820              LDR      r0,[r4,#0]            ;905
00009a  6861              LDR      r1,[r4,#4]            ;905
00009c  6008              STR      r0,[r1,#0]            ;905
00009e  6041              STR      r1,[r0,#4]            ;905
0000a0  68a1              LDR      r1,[r4,#8]            ;912
0000a2  68e0              LDR      r0,[r4,#0xc]          ;912
0000a4  6001              STR      r1,[r0,#0]            ;912
0000a6  6048              STR      r0,[r1,#4]            ;912
                  |L26.168|
0000a8  63a7              STR      r7,[r4,#0x38]         ;919
0000aa  2000              MOVS     r0,#0                 ;920
0000ac  61a0              STR      r0,[r4,#0x18]         ;920
0000ae  4d08              LDR      r5,|L26.208|
0000b0  69a8              LDR      r0,[r5,#0x18]         ;922  ; RMP_Cur_Thd
0000b2  4284              CMP      r4,r0                 ;922
0000b4  d101              BNE      |L26.186|
0000b6  2001              MOVS     r0,#1                 ;925
0000b8  60e8              STR      r0,[r5,#0xc]          ;925  ; RMP_Sched_Pend
                  |L26.186|
0000ba  f7fffffe          BL       RMP_Unlock_Sched
0000be  69a8              LDR      r0,[r5,#0x18]         ;933  ; RMP_Cur_Thd
0000c0  4284              CMP      r4,r0                 ;933
0000c2  d101              BNE      |L26.200|
                  |L26.196|
0000c4  e7fe              B        |L26.196|
                  |L26.198|
0000c6  e7fe              B        |L26.198|
                  |L26.200|
0000c8  2000              MOVS     r0,#0                 ;938
0000ca  bdf8              POP      {r3-r7,pc}
;;;940    /* End Function:RMP_Thd_Del **************************************************/
                          ENDP

                  |L26.204|
                          DCD      0xffffffff
                  |L26.208|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Delay||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Delay PROC
;;;1484   ******************************************************************************/
;;;1485   rmp_ret_t RMP_Thd_Delay(rmp_ptr_t Slices)
000000  b570              PUSH     {r4-r6,lr}
;;;1486   {
000002  0005              MOVS     r5,r0
000004  d002              BEQ      |L27.12|
;;;1487       if((Slices==0)||(Slices>=RMP_MAX_SLICES))
000006  481b              LDR      r0,|L27.116|
000008  4285              CMP      r5,r0
00000a  d302              BCC      |L27.18|
                  |L27.12|
;;;1488       {
;;;1489           RMP_COVERAGE_MARKER();
;;;1490           return RMP_ERR_SLICE;
00000c  2002              MOVS     r0,#2
00000e  43c0              MVNS     r0,r0
;;;1491       }
;;;1492       else
;;;1493           RMP_COVERAGE_MARKER();
;;;1494       
;;;1495       RMP_Lock_Sched();
;;;1496   
;;;1497       /* We must be running and not suspended so we will be out of running queue */
;;;1498       _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1499       RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_DELAYED);
;;;1500       _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1501   
;;;1502       RMP_Cur_Thd->Retval=0;
;;;1503       RMP_Unlock_Sched();
;;;1504       /* Need to return if successful or not */
;;;1505       return RMP_Cur_Thd->Retval;
;;;1506   }
000010  bd70              POP      {r4-r6,pc}
                  |L27.18|
000012  f7fffffe          BL       RMP_Disable_Int
000016  4c18              LDR      r4,|L27.120|
000018  2001              MOVS     r0,#1
00001a  60a0              STR      r0,[r4,#8]  ; RMP_Sched_Locked
00001c  6860              LDR      r0,[r4,#4]  ; RMP_Sched_Lock_Cnt
00001e  1c40              ADDS     r0,r0,#1
000020  6060              STR      r0,[r4,#4]  ; RMP_Sched_Lock_Cnt
000022  69a0              LDR      r0,[r4,#0x18]         ;1498  ; RMP_Cur_Thd
000024  f7fffffe          BL       _RMP_Clr_Rdy
000028  69a0              LDR      r0,[r4,#0x18]         ;1499  ; RMP_Cur_Thd
00002a  69a1              LDR      r1,[r4,#0x18]         ;1499  ; RMP_Cur_Thd
00002c  6980              LDR      r0,[r0,#0x18]         ;1499
00002e  0a00              LSRS     r0,r0,#8              ;1499
000030  0200              LSLS     r0,r0,#8              ;1499
000032  1d80              ADDS     r0,r0,#6              ;1499
000034  6188              STR      r0,[r1,#0x18]         ;1500
000036  69a2              LDR      r2,[r4,#0x18]         ;1500  ; RMP_Cur_Thd
000038  4b10              LDR      r3,|L27.124|
00003a  6859              LDR      r1,[r3,#4]            ;1500  ; RMP_Delay
00003c  4299              CMP      r1,r3                 ;1500
00003e  d007              BEQ      |L27.80|
                  |L27.64|
000040  6a08              LDR      r0,[r1,#0x20]         ;1500
000042  6966              LDR      r6,[r4,#0x14]         ;1500  ; RMP_Tick
000044  1b80              SUBS     r0,r0,r6              ;1500
000046  42a8              CMP      r0,r5                 ;1500
000048  d802              BHI      |L27.80|
00004a  6849              LDR      r1,[r1,#4]            ;1500
00004c  4299              CMP      r1,r3                 ;1500
00004e  d1f7              BNE      |L27.64|
                  |L27.80|
000050  6960              LDR      r0,[r4,#0x14]         ;1500  ; RMP_Tick
000052  1940              ADDS     r0,r0,r5              ;1500
000054  6290              STR      r0,[r2,#0x28]         ;1500
000056  3208              ADDS     r2,r2,#8              ;1500
000058  6808              LDR      r0,[r1,#0]            ;1500
00005a  600a              STR      r2,[r1,#0]            ;1500
00005c  6051              STR      r1,[r2,#4]            ;1500
00005e  6010              STR      r0,[r2,#0]            ;1500
000060  6042              STR      r2,[r0,#4]            ;1500
000062  69a1              LDR      r1,[r4,#0x18]         ;1502  ; RMP_Cur_Thd
000064  2000              MOVS     r0,#0                 ;1502
000066  6388              STR      r0,[r1,#0x38]         ;1503
000068  f7fffffe          BL       RMP_Unlock_Sched
00006c  69a0              LDR      r0,[r4,#0x18]         ;1505  ; RMP_Cur_Thd
00006e  6b80              LDR      r0,[r0,#0x38]         ;1505
000070  bd70              POP      {r4-r6,pc}
;;;1507   /* End Function:RMP_Thd_Delay ************************************************/
                          ENDP

000072  0000              DCW      0x0000
                  |L27.116|
                          DCD      0x000186a0
                  |L27.120|
                          DCD      ||.data||
                  |L27.124|
                          DCD      ||.data||+0x20

                          AREA ||i.RMP_Thd_Rcv||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Rcv PROC
;;;1367   ******************************************************************************/
;;;1368   rmp_ret_t RMP_Thd_Rcv(rmp_ptr_t* Data, rmp_ptr_t Slices)
000000  2800              CMP      r0,#0
;;;1369   {
;;;1370       struct RMP_Thd* Sender;
;;;1371       
;;;1372       if(Data==0)
000002  d101              BNE      |L28.8|
;;;1373       {
;;;1374           RMP_COVERAGE_MARKER();
;;;1375           return RMP_ERR_OPER;
000004  1f40              SUBS     r0,r0,#5
;;;1376       }
;;;1377       else
;;;1378           RMP_COVERAGE_MARKER();
;;;1379       
;;;1380       RMP_Lock_Sched();
;;;1381       
;;;1382       /* Is there any other guy waiting on us? If there is, unblock it and set it running */
;;;1383       Sender=0;
;;;1384       if(&(RMP_Cur_Thd->Snd_List)!=RMP_Cur_Thd->Snd_List.Next)
;;;1385       {
;;;1386           RMP_COVERAGE_MARKER();
;;;1387           /* Read the data */
;;;1388           Sender=(struct RMP_Thd*)(RMP_Cur_Thd->Snd_List.Next);
;;;1389           RMP_List_Del(Sender->Run_Head.Prev,Sender->Run_Head.Next);
;;;1390           *Data=Sender->Data;
;;;1391           /* Now we unblock it - what state is it in? */
;;;1392           if((RMP_THD_STATE(Sender->State)==RMP_THD_SNDDLY))
;;;1393           {
;;;1394               RMP_COVERAGE_MARKER();
;;;1395               RMP_List_Del(Sender->Dly_Head.Prev,Sender->Dly_Head.Next);
;;;1396           }
;;;1397           else
;;;1398               RMP_COVERAGE_MARKER();
;;;1399           
;;;1400           RMP_THD_STATE_SET(Sender->State,RMP_THD_RUNNING);
;;;1401           /* Set to running if not suspended */
;;;1402           _RMP_Set_Rdy(Sender);
;;;1403       }
;;;1404   
;;;1405       /* Check if there is a value in our mailbox. If yes, we return with that value */
;;;1406       if((RMP_Cur_Thd->State&RMP_THD_MBOXFUL)!=0)
;;;1407       {
;;;1408           RMP_COVERAGE_MARKER();
;;;1409           /* Get the value from mailbox */
;;;1410           *Data=RMP_Cur_Thd->Mailbox;
;;;1411           /* See if we unblocked a sender. If yes, we place the new value into 
;;;1412            * our mailbox and it is still full */
;;;1413           if(Sender!=0)
;;;1414               RMP_Cur_Thd->Mailbox=Sender->Data;
;;;1415           else
;;;1416               RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
;;;1417           
;;;1418           RMP_Unlock_Sched();
;;;1419           return 0;
;;;1420       }
;;;1421       else
;;;1422       {
;;;1423           RMP_COVERAGE_MARKER();
;;;1424           
;;;1425           /* Box empty. Do we have somebody waiting? */
;;;1426           if(Sender!=0)
;;;1427           {
;;;1428               RMP_COVERAGE_MARKER();
;;;1429               RMP_Cur_Thd->Mailbox=Sender->Data;
;;;1430               RMP_Unlock_Sched();
;;;1431               return 0;
;;;1432           }
;;;1433           /* No sender waiting on us and box empty, we need to block */
;;;1434           else
;;;1435           {
;;;1436               RMP_COVERAGE_MARKER();
;;;1437               
;;;1438               if(Slices==0)
;;;1439               {
;;;1440                   RMP_COVERAGE_MARKER();
;;;1441                   RMP_Unlock_Sched();
;;;1442                   return RMP_ERR_OPER;
;;;1443               }
;;;1444               else
;;;1445                   RMP_COVERAGE_MARKER();
;;;1446   
;;;1447               /* We must be running and not suspended so we will surely be deleted from queue */
;;;1448               _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1449   
;;;1450               if(Slices<RMP_MAX_SLICES)
;;;1451               {
;;;1452                   RMP_COVERAGE_MARKER();
;;;1453                   _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1454                   RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVDLY);
;;;1455               }
;;;1456               else
;;;1457               {
;;;1458                   RMP_COVERAGE_MARKER();
;;;1459                   RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVBLK);
;;;1460               }
;;;1461               RMP_Unlock_Sched();
;;;1462               
;;;1463               /* Dummy read - to separate the lock & unlock. If the compiler optimizes these two
;;;1464                * functions(inline them) on some architectures sometimes we never block. */
;;;1465               *Data=RMP_Cur_Thd->Mailbox;
;;;1466               
;;;1467               /* We've been unblocked. There must be something in our mbox, or we should have failed */
;;;1468               RMP_Lock_Sched();
;;;1469               *Data=RMP_Cur_Thd->Mailbox;
;;;1470               RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
;;;1471           }
;;;1472       }
;;;1473       
;;;1474       RMP_Unlock_Sched();
;;;1475       return RMP_Cur_Thd->Retval;
;;;1476   }
000006  4770              BX       lr
                  |L28.8|
000008  b5f8              PUSH     {r3-r7,lr}            ;1369
00000a  460c              MOV      r4,r1                 ;1369
00000c  4606              MOV      r6,r0                 ;1369
00000e  f7fffffe          BL       RMP_Disable_Int
000012  4d47              LDR      r5,|L28.304|
000014  2001              MOVS     r0,#1                 ;1369
000016  60a8              STR      r0,[r5,#8]            ;1369  ; RMP_Sched_Locked
000018  6868              LDR      r0,[r5,#4]            ;1369  ; RMP_Sched_Lock_Cnt
00001a  1c40              ADDS     r0,r0,#1              ;1369
00001c  6068              STR      r0,[r5,#4]            ;1369  ; RMP_Sched_Lock_Cnt
00001e  69a8              LDR      r0,[r5,#0x18]         ;1384  ; RMP_Cur_Thd
000020  2700              MOVS     r7,#0                 ;1383
000022  6941              LDR      r1,[r0,#0x14]         ;1384
000024  69a8              LDR      r0,[r5,#0x18]         ;1384  ; RMP_Cur_Thd
000026  3010              ADDS     r0,r0,#0x10           ;1384
000028  4281              CMP      r1,r0                 ;1384
00002a  d016              BEQ      |L28.90|
00002c  69a8              LDR      r0,[r5,#0x18]         ;1388  ; RMP_Cur_Thd
00002e  6947              LDR      r7,[r0,#0x14]         ;1389
000030  6879              LDR      r1,[r7,#4]            ;1389
000032  6838              LDR      r0,[r7,#0]            ;1389
000034  6008              STR      r0,[r1,#0]            ;1389
000036  6041              STR      r1,[r0,#4]            ;1389
000038  6b38              LDR      r0,[r7,#0x30]         ;1390
00003a  6030              STR      r0,[r6,#0]            ;1392
00003c  7e38              LDRB     r0,[r7,#0x18]         ;1392
00003e  2803              CMP      r0,#3                 ;1392
000040  d103              BNE      |L28.74|
000042  68f9              LDR      r1,[r7,#0xc]          ;1392
000044  68b8              LDR      r0,[r7,#8]            ;1392
000046  6008              STR      r0,[r1,#0]            ;1392
000048  6041              STR      r1,[r0,#4]            ;1392
                  |L28.74|
00004a  69b8              LDR      r0,[r7,#0x18]         ;1400
00004c  0a00              LSRS     r0,r0,#8              ;1400
00004e  0200              LSLS     r0,r0,#8              ;1400
000050  1c40              ADDS     r0,r0,#1              ;1400
000052  61b8              STR      r0,[r7,#0x18]         ;1402
000054  4638              MOV      r0,r7                 ;1402
000056  f7fffffe          BL       _RMP_Set_Rdy
                  |L28.90|
00005a  69a8              LDR      r0,[r5,#0x18]         ;1406  ; RMP_Cur_Thd
00005c  8b00              LDRH     r0,[r0,#0x18]         ;1406
00005e  0580              LSLS     r0,r0,#22             ;1406
000060  d512              BPL      |L28.136|
000062  69a8              LDR      r0,[r5,#0x18]         ;1410  ; RMP_Cur_Thd
000064  2f00              CMP      r7,#0                 ;1413
000066  6ac0              LDR      r0,[r0,#0x2c]         ;1410
000068  6030              STR      r0,[r6,#0]            ;1413
00006a  d003              BEQ      |L28.116|
00006c  6b38              LDR      r0,[r7,#0x30]         ;1414
00006e  69a9              LDR      r1,[r5,#0x18]         ;1414  ; RMP_Cur_Thd
000070  62c8              STR      r0,[r1,#0x2c]         ;1414
000072  e005              B        |L28.128|
                  |L28.116|
000074  69a8              LDR      r0,[r5,#0x18]         ;1416  ; RMP_Cur_Thd
000076  2201              MOVS     r2,#1                 ;1416
000078  6981              LDR      r1,[r0,#0x18]         ;1416
00007a  0252              LSLS     r2,r2,#9              ;1416
00007c  4391              BICS     r1,r1,r2              ;1416
00007e  6181              STR      r1,[r0,#0x18]         ;1416
                  |L28.128|
000080  f7fffffe          BL       RMP_Unlock_Sched
000084  2000              MOVS     r0,#0                 ;1419
000086  bdf8              POP      {r3-r7,pc}
                  |L28.136|
000088  2f00              CMP      r7,#0                 ;1426
00008a  d006              BEQ      |L28.154|
00008c  6b38              LDR      r0,[r7,#0x30]         ;1429
00008e  69a9              LDR      r1,[r5,#0x18]         ;1429  ; RMP_Cur_Thd
000090  62c8              STR      r0,[r1,#0x2c]         ;1430
000092  f7fffffe          BL       RMP_Unlock_Sched
000096  2000              MOVS     r0,#0                 ;1431
000098  bdf8              POP      {r3-r7,pc}
                  |L28.154|
00009a  2c00              CMP      r4,#0                 ;1438
00009c  d03c              BEQ      |L28.280|
00009e  69a8              LDR      r0,[r5,#0x18]         ;1448  ; RMP_Cur_Thd
0000a0  f7fffffe          BL       _RMP_Clr_Rdy
0000a4  4823              LDR      r0,|L28.308|
0000a6  4284              CMP      r4,r0                 ;1450
0000a8  d23b              BCS      |L28.290|
0000aa  69ab              LDR      r3,[r5,#0x18]         ;1453  ; RMP_Cur_Thd
0000ac  4f22              LDR      r7,|L28.312|
0000ae  687a              LDR      r2,[r7,#4]            ;1453  ; RMP_Delay
0000b0  42ba              CMP      r2,r7                 ;1453
0000b2  d007              BEQ      |L28.196|
                  |L28.180|
0000b4  6a10              LDR      r0,[r2,#0x20]         ;1453
0000b6  6969              LDR      r1,[r5,#0x14]         ;1453  ; RMP_Tick
0000b8  1a40              SUBS     r0,r0,r1              ;1453
0000ba  42a0              CMP      r0,r4                 ;1453
0000bc  d802              BHI      |L28.196|
0000be  6852              LDR      r2,[r2,#4]            ;1453
0000c0  42ba              CMP      r2,r7                 ;1453
0000c2  d1f7              BNE      |L28.180|
                  |L28.196|
0000c4  6968              LDR      r0,[r5,#0x14]         ;1453  ; RMP_Tick
0000c6  1900              ADDS     r0,r0,r4              ;1453
0000c8  6298              STR      r0,[r3,#0x28]         ;1453
0000ca  3308              ADDS     r3,r3,#8              ;1453
0000cc  6810              LDR      r0,[r2,#0]            ;1453
0000ce  6013              STR      r3,[r2,#0]            ;1453
0000d0  605a              STR      r2,[r3,#4]            ;1453
0000d2  6018              STR      r0,[r3,#0]            ;1453
0000d4  6043              STR      r3,[r0,#4]            ;1453
0000d6  69a8              LDR      r0,[r5,#0x18]         ;1454  ; RMP_Cur_Thd
0000d8  69a9              LDR      r1,[r5,#0x18]         ;1454  ; RMP_Cur_Thd
0000da  6980              LDR      r0,[r0,#0x18]         ;1454
0000dc  0a00              LSRS     r0,r0,#8              ;1454
0000de  0200              LSLS     r0,r0,#8              ;1454
0000e0  1d40              ADDS     r0,r0,#5              ;1454
                  |L28.226|
0000e2  6188              STR      r0,[r1,#0x18]         ;1461
0000e4  f7fffffe          BL       RMP_Unlock_Sched
0000e8  69a8              LDR      r0,[r5,#0x18]         ;1465  ; RMP_Cur_Thd
0000ea  6ac0              LDR      r0,[r0,#0x2c]         ;1465
0000ec  6030              STR      r0,[r6,#0]            ;1465
0000ee  f7fffffe          BL       RMP_Disable_Int
0000f2  2001              MOVS     r0,#1                 ;1465
0000f4  60a8              STR      r0,[r5,#8]            ;1465  ; RMP_Sched_Locked
0000f6  6868              LDR      r0,[r5,#4]            ;1465  ; RMP_Sched_Lock_Cnt
0000f8  1c40              ADDS     r0,r0,#1              ;1465
0000fa  6068              STR      r0,[r5,#4]            ;1465  ; RMP_Sched_Lock_Cnt
0000fc  69a8              LDR      r0,[r5,#0x18]         ;1469  ; RMP_Cur_Thd
0000fe  6ac0              LDR      r0,[r0,#0x2c]         ;1469
000100  6030              STR      r0,[r6,#0]            ;1470
000102  69a8              LDR      r0,[r5,#0x18]         ;1470  ; RMP_Cur_Thd
000104  2101              MOVS     r1,#1                 ;1470
000106  6982              LDR      r2,[r0,#0x18]         ;1470
000108  0249              LSLS     r1,r1,#9              ;1470
00010a  438a              BICS     r2,r2,r1              ;1470
00010c  6182              STR      r2,[r0,#0x18]         ;1474
00010e  f7fffffe          BL       RMP_Unlock_Sched
000112  69a8              LDR      r0,[r5,#0x18]         ;1475  ; RMP_Cur_Thd
000114  6b80              LDR      r0,[r0,#0x38]         ;1475
000116  bdf8              POP      {r3-r7,pc}
                  |L28.280|
000118  f7fffffe          BL       RMP_Unlock_Sched
00011c  2004              MOVS     r0,#4                 ;1442
00011e  43c0              MVNS     r0,r0                 ;1442
000120  bdf8              POP      {r3-r7,pc}
                  |L28.290|
000122  69a8              LDR      r0,[r5,#0x18]         ;1459  ; RMP_Cur_Thd
000124  69a9              LDR      r1,[r5,#0x18]         ;1459  ; RMP_Cur_Thd
000126  6980              LDR      r0,[r0,#0x18]         ;1459
000128  0a00              LSRS     r0,r0,#8              ;1459
00012a  0200              LSLS     r0,r0,#8              ;1459
00012c  1d00              ADDS     r0,r0,#4              ;1459
00012e  e7d8              B        |L28.226|
;;;1477   /* End Function:RMP_Thd_Rcv **************************************************/
                          ENDP

                  |L28.304|
                          DCD      ||.data||
                  |L28.308|
                          DCD      0x000186a0
                  |L28.312|
                          DCD      ||.data||+0x20

                          AREA ||i.RMP_Thd_Resume||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Resume PROC
;;;1111   ******************************************************************************/
;;;1112   rmp_ret_t RMP_Thd_Resume(volatile struct RMP_Thd* Thread)
000000  b570              PUSH     {r4-r6,lr}
;;;1113   {
;;;1114       rmp_ret_t Retval;
;;;1115       
;;;1116       /* Check if this thread structure could possibly be in use */
;;;1117       if(Thread==0)
;;;1118       {
;;;1119           RMP_COVERAGE_MARKER();
;;;1120           return RMP_ERR_THD;
000002  4d16              LDR      r5,|L29.92|
000004  0004              MOVS     r4,r0                 ;1113
000006  d018              BEQ      |L29.58|
000008  f7fffffe          BL       RMP_Disable_Int
00000c  4814              LDR      r0,|L29.96|
00000e  2101              MOVS     r1,#1                 ;1113
000010  6081              STR      r1,[r0,#8]            ;1113  ; RMP_Sched_Locked
000012  6841              LDR      r1,[r0,#4]            ;1113  ; RMP_Sched_Lock_Cnt
000014  1c49              ADDS     r1,r1,#1              ;1113
000016  6041              STR      r1,[r0,#4]            ;1113  ; RMP_Sched_Lock_Cnt
;;;1121       }
;;;1122       else
;;;1123           RMP_COVERAGE_MARKER();
;;;1124   
;;;1125       RMP_Lock_Sched();
;;;1126       
;;;1127       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
000018  69a0              LDR      r0,[r4,#0x18]
00001a  0600              LSLS     r0,r0,#24
00001c  0e00              LSRS     r0,r0,#24
00001e  d00e              BEQ      |L29.62|
;;;1128       {
;;;1129           RMP_COVERAGE_MARKER();
;;;1130           RMP_Unlock_Sched();
;;;1131           return RMP_ERR_THD;
;;;1132       }
;;;1133       else
;;;1134           RMP_COVERAGE_MARKER();
;;;1135       
;;;1136       /* Check if the thread is suspended, if not, then throw an error */
;;;1137       if((Thread->State&RMP_THD_SUSPENDED)!=0)
000020  69a0              LDR      r0,[r4,#0x18]
000022  05c0              LSLS     r0,r0,#23
000024  d514              BPL      |L29.80|
;;;1138       {
;;;1139           RMP_COVERAGE_MARKER();
;;;1140           
;;;1141           /* Suspended */
;;;1142           Thread->State&=~RMP_THD_SUSPENDED;
000026  69a0              LDR      r0,[r4,#0x18]
000028  21ff              MOVS     r1,#0xff
00002a  3101              ADDS     r1,#1
00002c  4388              BICS     r0,r0,r1
00002e  61a0              STR      r0,[r4,#0x18]
;;;1143           /* Only when it is running will we put it back. It can't be suspended here, 
;;;1144            * so the set ready operation will surely put it back */
;;;1145           if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
000030  69a0              LDR      r0,[r4,#0x18]
000032  b2c0              UXTB     r0,r0
000034  2801              CMP      r0,#1
000036  d006              BEQ      |L29.70|
000038  e008              B        |L29.76|
                  |L29.58|
00003a  4628              MOV      r0,r5                 ;1120
;;;1146           {
;;;1147               RMP_COVERAGE_MARKER();
;;;1148               _RMP_Set_Rdy(Thread);
;;;1149           }
;;;1150           else
;;;1151               RMP_COVERAGE_MARKER();
;;;1152           
;;;1153           Retval=0;
;;;1154       }
;;;1155       else
;;;1156       {
;;;1157           RMP_COVERAGE_MARKER();
;;;1158           Retval=RMP_ERR_STATE;
;;;1159       }
;;;1160       
;;;1161       RMP_Unlock_Sched();
;;;1162   
;;;1163       return Retval;
;;;1164   }
00003c  bd70              POP      {r4-r6,pc}
                  |L29.62|
00003e  f7fffffe          BL       RMP_Unlock_Sched
000042  4628              MOV      r0,r5                 ;1131
000044  bd70              POP      {r4-r6,pc}
                  |L29.70|
000046  4620              MOV      r0,r4                 ;1148
000048  f7fffffe          BL       _RMP_Set_Rdy
                  |L29.76|
00004c  2400              MOVS     r4,#0                 ;1153
00004e  e001              B        |L29.84|
                  |L29.80|
000050  2403              MOVS     r4,#3                 ;1158
000052  43e4              MVNS     r4,r4                 ;1158
                  |L29.84|
000054  f7fffffe          BL       RMP_Unlock_Sched
000058  4620              MOV      r0,r4                 ;1163
00005a  bd70              POP      {r4-r6,pc}
;;;1165   /* End Function:RMP_Thd_Resume ***********************************************/
                          ENDP

                  |L29.92|
                          DCD      0xffffffff
                  |L29.96|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Set||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Set PROC
;;;951    ******************************************************************************/
;;;952    rmp_ret_t RMP_Thd_Set(volatile struct RMP_Thd* Thread, rmp_ptr_t Prio, rmp_ptr_t Slices)
000000  2a00              CMP      r2,#0
;;;953    {
;;;954        /* Check if the priority and timeslice range is correct */
;;;955        if(Slices==0)
000002  d101              BNE      |L30.8|
;;;956        {
;;;957            RMP_COVERAGE_MARKER();
;;;958            return RMP_ERR_SLICE;
000004  1ed0              SUBS     r0,r2,#3
;;;959        }
;;;960        else
;;;961            RMP_COVERAGE_MARKER();
;;;962        
;;;963        /* Check if this thread structure could possibly be in use */
;;;964        if(Thread==0)
;;;965        {
;;;966            RMP_COVERAGE_MARKER();
;;;967            return RMP_ERR_THD;
;;;968        }
;;;969        else
;;;970            RMP_COVERAGE_MARKER();
;;;971        
;;;972        RMP_Lock_Sched();
;;;973        
;;;974        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;975        {
;;;976            RMP_COVERAGE_MARKER();
;;;977            RMP_Unlock_Sched();
;;;978            return RMP_ERR_THD;
;;;979        }
;;;980        else
;;;981            RMP_COVERAGE_MARKER();
;;;982        
;;;983        /* See if the thread is in running state */
;;;984        if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;985        {
;;;986            RMP_COVERAGE_MARKER();
;;;987            
;;;988            /* See if we are gonna change one of it or both */
;;;989            if(Prio<RMP_MAX_PREEMPT_PRIO)
;;;990            {
;;;991                RMP_COVERAGE_MARKER();
;;;992                if(Thread->Prio!=Prio)
;;;993                {
;;;994                    RMP_COVERAGE_MARKER();
;;;995                    /* It doesn't matter whether this is suspended or not. 
;;;996                     * If suspended, the operations will not be conducted. */
;;;997                    _RMP_Clr_Rdy(Thread);
;;;998                    Thread->Prio=Prio;
;;;999                    _RMP_Set_Rdy(Thread);
;;;1000               }
;;;1001               else
;;;1002                   RMP_COVERAGE_MARKER();
;;;1003           }
;;;1004           else
;;;1005               RMP_COVERAGE_MARKER();
;;;1006           
;;;1007           if(Slices<RMP_MAX_SLICES)
;;;1008           {
;;;1009               RMP_COVERAGE_MARKER();
;;;1010               Thread->Slices=Slices;
;;;1011           }
;;;1012           else
;;;1013               RMP_COVERAGE_MARKER();
;;;1014       }
;;;1015       else
;;;1016       {
;;;1017           RMP_COVERAGE_MARKER();
;;;1018           
;;;1019           if(Prio<RMP_MAX_PREEMPT_PRIO)
;;;1020           {
;;;1021               RMP_COVERAGE_MARKER();
;;;1022               Thread->Prio=Prio;
;;;1023           }
;;;1024           else
;;;1025               RMP_COVERAGE_MARKER();
;;;1026           
;;;1027           if(Slices<RMP_MAX_SLICES)
;;;1028           {
;;;1029               RMP_COVERAGE_MARKER();
;;;1030               Thread->Slices=Slices;
;;;1031           }
;;;1032           else
;;;1033               RMP_COVERAGE_MARKER();
;;;1034       }
;;;1035       
;;;1036       RMP_Unlock_Sched();
;;;1037       return 0;
;;;1038   }
000006  4770              BX       lr
                  |L30.8|
000008  b5f8              PUSH     {r3-r7,lr}            ;953
00000a  4f1a              LDR      r7,|L30.116|
00000c  4615              MOV      r5,r2                 ;953
00000e  460e              MOV      r6,r1                 ;953
000010  0004              MOVS     r4,r0                 ;953
000012  d01a              BEQ      |L30.74|
000014  f7fffffe          BL       RMP_Disable_Int
000018  4817              LDR      r0,|L30.120|
00001a  2101              MOVS     r1,#1                 ;958
00001c  6081              STR      r1,[r0,#8]            ;958  ; RMP_Sched_Locked
00001e  6841              LDR      r1,[r0,#4]            ;958  ; RMP_Sched_Lock_Cnt
000020  1c49              ADDS     r1,r1,#1              ;958
000022  6041              STR      r1,[r0,#4]            ;958  ; RMP_Sched_Lock_Cnt
000024  69a0              LDR      r0,[r4,#0x18]         ;974
000026  0600              LSLS     r0,r0,#24             ;974
000028  0e00              LSRS     r0,r0,#24             ;974
00002a  d010              BEQ      |L30.78|
00002c  69a0              LDR      r0,[r4,#0x18]         ;984
00002e  4f13              LDR      r7,|L30.124|
000030  b2c0              UXTB     r0,r0                 ;984
000032  2801              CMP      r0,#1                 ;984
000034  d00f              BEQ      |L30.86|
000036  2e20              CMP      r6,#0x20              ;1019
000038  d200              BCS      |L30.60|
00003a  6266              STR      r6,[r4,#0x24]         ;1022
                  |L30.60|
00003c  42bd              CMP      r5,r7                 ;1027
00003e  d200              BCS      |L30.66|
                  |L30.64|
000040  61e5              STR      r5,[r4,#0x1c]         ;1030
                  |L30.66|
000042  f7fffffe          BL       RMP_Unlock_Sched
000046  2000              MOVS     r0,#0                 ;1037
000048  bdf8              POP      {r3-r7,pc}
                  |L30.74|
00004a  4638              MOV      r0,r7                 ;967
00004c  bdf8              POP      {r3-r7,pc}
                  |L30.78|
00004e  f7fffffe          BL       RMP_Unlock_Sched
000052  4638              MOV      r0,r7                 ;978
000054  bdf8              POP      {r3-r7,pc}
                  |L30.86|
000056  2e20              CMP      r6,#0x20              ;989
000058  d209              BCS      |L30.110|
00005a  6a60              LDR      r0,[r4,#0x24]         ;992
00005c  42b0              CMP      r0,r6                 ;992
00005e  d006              BEQ      |L30.110|
000060  4620              MOV      r0,r4                 ;997
000062  f7fffffe          BL       _RMP_Clr_Rdy
000066  6266              STR      r6,[r4,#0x24]         ;998
000068  4620              MOV      r0,r4                 ;999
00006a  f7fffffe          BL       _RMP_Set_Rdy
                  |L30.110|
00006e  42bd              CMP      r5,r7                 ;1007
000070  d3e6              BCC      |L30.64|
000072  e7e6              B        |L30.66|
;;;1039   /* End Function:RMP_Thd_Set **************************************************/
                          ENDP

                  |L30.116|
                          DCD      0xffffffff
                  |L30.120|
                          DCD      ||.data||
                  |L30.124|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Snd||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Snd PROC
;;;1175   ******************************************************************************/
;;;1176   rmp_ret_t RMP_Thd_Snd(volatile struct RMP_Thd* Thread, rmp_ptr_t Data, rmp_ptr_t Slices)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1177   {
;;;1178       /* Check if this thread structure could possibly be in use */
;;;1179       if(Thread==0)
;;;1180       {
;;;1181           RMP_COVERAGE_MARKER();
;;;1182           return RMP_ERR_THD;
000002  4d3f              LDR      r5,|L31.256|
000004  4614              MOV      r4,r2                 ;1177
000006  460e              MOV      r6,r1                 ;1177
000008  0007              MOVS     r7,r0                 ;1177
00000a  d044              BEQ      |L31.150|
00000c  f7fffffe          BL       RMP_Disable_Int
000010  483c              LDR      r0,|L31.260|
000012  2101              MOVS     r1,#1                 ;1177
000014  6081              STR      r1,[r0,#8]            ;1177  ; RMP_Sched_Locked
000016  6841              LDR      r1,[r0,#4]            ;1177  ; RMP_Sched_Lock_Cnt
000018  1c49              ADDS     r1,r1,#1              ;1177
00001a  6041              STR      r1,[r0,#4]            ;1177  ; RMP_Sched_Lock_Cnt
;;;1183       }
;;;1184       else
;;;1185           RMP_COVERAGE_MARKER();
;;;1186       
;;;1187       RMP_Lock_Sched();
;;;1188       
;;;1189       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
00001c  69b9              LDR      r1,[r7,#0x18]
00001e  0609              LSLS     r1,r1,#24
000020  0e09              LSRS     r1,r1,#24
000022  d03a              BEQ      |L31.154|
;;;1190       {
;;;1191           RMP_COVERAGE_MARKER();
;;;1192           RMP_Unlock_Sched();
;;;1193           return RMP_ERR_THD;
;;;1194       }
;;;1195       else
;;;1196           RMP_COVERAGE_MARKER();
;;;1197       
;;;1198       /* Are we sending to ourself? This is not allowed */
;;;1199       if(RMP_Cur_Thd==Thread)
000024  6981              LDR      r1,[r0,#0x18]  ; RMP_Cur_Thd
000026  42b9              CMP      r1,r7
000028  d03b              BEQ      |L31.162|
;;;1200       {
;;;1201           RMP_COVERAGE_MARKER();
;;;1202           RMP_Unlock_Sched();
;;;1203           return RMP_ERR_OPER;
;;;1204       }
;;;1205       else
;;;1206           RMP_COVERAGE_MARKER();
;;;1207       
;;;1208       RMP_Cur_Thd->Retval=0;
00002a  4605              MOV      r5,r0
00002c  6980              LDR      r0,[r0,#0x18]  ; RMP_Cur_Thd
00002e  2100              MOVS     r1,#0
;;;1209   
;;;1210       /* See if there is already a value in the mailbox, if yes, we block */
;;;1211       if((Thread->State&RMP_THD_MBOXFUL)!=0)
000030  6381              STR      r1,[r0,#0x38]
000032  69b8              LDR      r0,[r7,#0x18]
000034  0580              LSLS     r0,r0,#22
000036  d540              BPL      |L31.186|
;;;1212       {
;;;1213           RMP_COVERAGE_MARKER();
;;;1214           
;;;1215           /* Mailbox full, we block, and put ourself into the queue */
;;;1216           if(Slices==0)
000038  2c00              CMP      r4,#0
00003a  d032              BEQ      |L31.162|
;;;1217           {
;;;1218               RMP_COVERAGE_MARKER();
;;;1219               RMP_Unlock_Sched();
;;;1220               return RMP_ERR_OPER;
;;;1221           }
;;;1222           else
;;;1223               RMP_COVERAGE_MARKER();
;;;1224   
;;;1225           /* We must be running */
;;;1226           _RMP_Clr_Rdy(RMP_Cur_Thd);
00003c  69a8              LDR      r0,[r5,#0x18]  ; RMP_Cur_Thd
00003e  f7fffffe          BL       _RMP_Clr_Rdy
;;;1227           RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Thread->Snd_List.Prev,&(Thread->Snd_List));
000042  69a8              LDR      r0,[r5,#0x18]  ; RMP_Cur_Thd
000044  6939              LDR      r1,[r7,#0x10]
000046  6138              STR      r0,[r7,#0x10]
000048  3710              ADDS     r7,r7,#0x10
00004a  6047              STR      r7,[r0,#4]
00004c  6001              STR      r1,[r0,#0]
00004e  6048              STR      r0,[r1,#4]
;;;1228   
;;;1229           if(Slices<RMP_MAX_SLICES)
000050  482d              LDR      r0,|L31.264|
000052  4284              CMP      r4,r0
000054  d22a              BCS      |L31.172|
;;;1230           {
;;;1231               RMP_COVERAGE_MARKER();
;;;1232               _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
000056  69ab              LDR      r3,[r5,#0x18]  ; RMP_Cur_Thd
000058  4f2c              LDR      r7,|L31.268|
00005a  6878              LDR      r0,[r7,#4]  ; RMP_Delay
00005c  42b8              CMP      r0,r7
00005e  d007              BEQ      |L31.112|
                  |L31.96|
000060  6a01              LDR      r1,[r0,#0x20]
000062  696a              LDR      r2,[r5,#0x14]  ; RMP_Tick
000064  1a89              SUBS     r1,r1,r2
000066  42a1              CMP      r1,r4
000068  d802              BHI      |L31.112|
00006a  6840              LDR      r0,[r0,#4]
00006c  42b8              CMP      r0,r7
00006e  d1f7              BNE      |L31.96|
                  |L31.112|
000070  6969              LDR      r1,[r5,#0x14]  ; RMP_Tick
000072  1909              ADDS     r1,r1,r4
000074  6299              STR      r1,[r3,#0x28]
000076  3308              ADDS     r3,r3,#8
000078  6801              LDR      r1,[r0,#0]
00007a  6003              STR      r3,[r0,#0]
00007c  6058              STR      r0,[r3,#4]
00007e  6019              STR      r1,[r3,#0]
000080  604b              STR      r3,[r1,#4]
;;;1233               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDDLY);
000082  69a8              LDR      r0,[r5,#0x18]  ; RMP_Cur_Thd
000084  69a9              LDR      r1,[r5,#0x18]  ; RMP_Cur_Thd
000086  6980              LDR      r0,[r0,#0x18]
000088  0a00              LSRS     r0,r0,#8
00008a  0200              LSLS     r0,r0,#8
00008c  1cc0              ADDS     r0,r0,#3
                  |L31.142|
;;;1234           }
;;;1235           else
;;;1236           {
;;;1237               RMP_COVERAGE_MARKER();
;;;1238               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDBLK);
;;;1239           }
;;;1240   
;;;1241           RMP_Cur_Thd->Data=Data;
00008e  6188              STR      r0,[r1,#0x18]
000090  69a8              LDR      r0,[r5,#0x18]  ; RMP_Cur_Thd
000092  6306              STR      r6,[r0,#0x30]
000094  e02f              B        |L31.246|
                  |L31.150|
000096  4628              MOV      r0,r5                 ;1182
;;;1242       }
;;;1243       else
;;;1244       {
;;;1245           RMP_COVERAGE_MARKER();
;;;1246           
;;;1247           /* Mailbox not full. We need to check if the receiver is waiting for us */
;;;1248           if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
;;;1249              (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
;;;1250           {
;;;1251               RMP_COVERAGE_MARKER();
;;;1252               
;;;1253               /* The receiver is blocked, wake it up and return the value */
;;;1254               if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
;;;1255               {
;;;1256                   RMP_COVERAGE_MARKER();
;;;1257                   RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1258               }
;;;1259               else
;;;1260                   RMP_COVERAGE_MARKER();
;;;1261               
;;;1262               RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1263               /* Set to running if not suspended */
;;;1264               _RMP_Set_Rdy(Thread);
;;;1265           }
;;;1266           else
;;;1267               RMP_COVERAGE_MARKER();
;;;1268           
;;;1269           /* Set the mailbox */
;;;1270           Thread->Mailbox=Data;
;;;1271           Thread->State|=RMP_THD_MBOXFUL;
;;;1272       }
;;;1273       
;;;1274       RMP_Unlock_Sched();
;;;1275   
;;;1276       return RMP_Cur_Thd->Retval;
;;;1277   }
000098  bdf8              POP      {r3-r7,pc}
                  |L31.154|
00009a  f7fffffe          BL       RMP_Unlock_Sched
00009e  4628              MOV      r0,r5                 ;1193
0000a0  bdf8              POP      {r3-r7,pc}
                  |L31.162|
0000a2  f7fffffe          BL       RMP_Unlock_Sched
0000a6  2004              MOVS     r0,#4                 ;1220
0000a8  43c0              MVNS     r0,r0                 ;1220
0000aa  bdf8              POP      {r3-r7,pc}
                  |L31.172|
0000ac  69a8              LDR      r0,[r5,#0x18]         ;1238  ; RMP_Cur_Thd
0000ae  69a9              LDR      r1,[r5,#0x18]         ;1238  ; RMP_Cur_Thd
0000b0  6980              LDR      r0,[r0,#0x18]         ;1238
0000b2  0a00              LSRS     r0,r0,#8              ;1238
0000b4  0200              LSLS     r0,r0,#8              ;1238
0000b6  1c80              ADDS     r0,r0,#2              ;1238
0000b8  e7e9              B        |L31.142|
                  |L31.186|
0000ba  69b8              LDR      r0,[r7,#0x18]         ;1248
0000bc  b2c0              UXTB     r0,r0                 ;1248
0000be  2804              CMP      r0,#4                 ;1248
0000c0  d003              BEQ      |L31.202|
0000c2  69b8              LDR      r0,[r7,#0x18]         ;1248
0000c4  b2c0              UXTB     r0,r0                 ;1248
0000c6  2805              CMP      r0,#5                 ;1248
0000c8  d10f              BNE      |L31.234|
                  |L31.202|
0000ca  69b8              LDR      r0,[r7,#0x18]         ;1254
0000cc  b2c0              UXTB     r0,r0                 ;1254
0000ce  2805              CMP      r0,#5                 ;1254
0000d0  d103              BNE      |L31.218|
0000d2  68b9              LDR      r1,[r7,#8]            ;1257
0000d4  68f8              LDR      r0,[r7,#0xc]          ;1257
0000d6  6001              STR      r1,[r0,#0]            ;1257
0000d8  6048              STR      r0,[r1,#4]            ;1257
                  |L31.218|
0000da  69b8              LDR      r0,[r7,#0x18]         ;1262
0000dc  0a00              LSRS     r0,r0,#8              ;1262
0000de  0200              LSLS     r0,r0,#8              ;1262
0000e0  1c40              ADDS     r0,r0,#1              ;1262
0000e2  61b8              STR      r0,[r7,#0x18]         ;1262
0000e4  4638              MOV      r0,r7                 ;1264
0000e6  f7fffffe          BL       _RMP_Set_Rdy
                  |L31.234|
0000ea  62fe              STR      r6,[r7,#0x2c]         ;1270
0000ec  69b8              LDR      r0,[r7,#0x18]         ;1271
0000ee  2101              MOVS     r1,#1                 ;1271
0000f0  0249              LSLS     r1,r1,#9              ;1271
0000f2  4308              ORRS     r0,r0,r1              ;1271
0000f4  61b8              STR      r0,[r7,#0x18]         ;1271
                  |L31.246|
0000f6  f7fffffe          BL       RMP_Unlock_Sched
0000fa  69a8              LDR      r0,[r5,#0x18]         ;1276  ; RMP_Cur_Thd
0000fc  6b80              LDR      r0,[r0,#0x38]         ;1276
0000fe  bdf8              POP      {r3-r7,pc}
;;;1278   /* End Function:RMP_Thd_Snd **************************************************/
                          ENDP

                  |L31.256|
                          DCD      0xffffffff
                  |L31.260|
                          DCD      ||.data||
                  |L31.264|
                          DCD      0x000186a0
                  |L31.268|
                          DCD      ||.data||+0x20

                          AREA ||i.RMP_Thd_Snd_ISR||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Snd_ISR PROC
;;;1290   ******************************************************************************/
;;;1291   rmp_ret_t RMP_Thd_Snd_ISR(volatile struct RMP_Thd* Thread, rmp_ptr_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;1292   {
000002  0004              MOVS     r4,r0
;;;1293       /* Check if this thread structure could possibly be in use */
;;;1294       if(Thread==0)
;;;1295       {
;;;1296           RMP_COVERAGE_MARKER();
;;;1297           return RMP_ERR_THD;
000004  481a              LDR      r0,|L32.112|
000006  460d              MOV      r5,r1                 ;1292
000008  d008              BEQ      |L32.28|
;;;1298       }
;;;1299       else
;;;1300           RMP_COVERAGE_MARKER();
;;;1301       
;;;1302       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
00000a  69a1              LDR      r1,[r4,#0x18]
00000c  0609              LSLS     r1,r1,#24
00000e  0e09              LSRS     r1,r1,#24
000010  d004              BEQ      |L32.28|
;;;1303       {
;;;1304           RMP_COVERAGE_MARKER();
;;;1305           return RMP_ERR_THD;
;;;1306       }
;;;1307       else
;;;1308           RMP_COVERAGE_MARKER();
;;;1309   
;;;1310       /* See if there is already a value in the mailbox, if yes, we abort */
;;;1311       if((Thread->State&RMP_THD_MBOXFUL)!=0)
000012  69a0              LDR      r0,[r4,#0x18]
000014  0580              LSLS     r0,r0,#22
000016  d502              BPL      |L32.30|
;;;1312       {
;;;1313           RMP_COVERAGE_MARKER();
;;;1314           return RMP_ERR_OPER;
000018  2004              MOVS     r0,#4
00001a  43c0              MVNS     r0,r0
                  |L32.28|
;;;1315       }
;;;1316       else
;;;1317       {
;;;1318           RMP_COVERAGE_MARKER();
;;;1319           
;;;1320           /* Mailbox not full. We need to check if the receiver is waiting for us */
;;;1321           if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
;;;1322              (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
;;;1323           {
;;;1324               RMP_COVERAGE_MARKER();
;;;1325   
;;;1326               /* The receiver is blocked, wake it up and return the value */
;;;1327               if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
;;;1328               {
;;;1329                   RMP_COVERAGE_MARKER();
;;;1330                   RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1331               }
;;;1332               else
;;;1333                   RMP_COVERAGE_MARKER();
;;;1334               
;;;1335               RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1336   
;;;1337               /* Set to running if not suspended */
;;;1338               _RMP_Set_Rdy(Thread);
;;;1339   
;;;1340               /* If schedule pending, trigger it now because we are in ISR */
;;;1341               if(RMP_Sched_Pend!=0)
;;;1342               {
;;;1343                   RMP_COVERAGE_MARKER();
;;;1344                   RMP_Sched_Pend=0;
;;;1345                   _RMP_Yield();
;;;1346               }
;;;1347               else
;;;1348                   RMP_COVERAGE_MARKER();
;;;1349           }
;;;1350           else
;;;1351               RMP_COVERAGE_MARKER();
;;;1352           
;;;1353           /* Set the mailbox */
;;;1354           Thread->Mailbox=Data;
;;;1355           Thread->State|=RMP_THD_MBOXFUL;
;;;1356       }
;;;1357   
;;;1358       return 0;
;;;1359   }
00001c  bd70              POP      {r4-r6,pc}
                  |L32.30|
00001e  69a0              LDR      r0,[r4,#0x18]         ;1321
000020  b2c0              UXTB     r0,r0                 ;1321
000022  2804              CMP      r0,#4                 ;1321
000024  d003              BEQ      |L32.46|
000026  69a0              LDR      r0,[r4,#0x18]         ;1321
000028  b2c0              UXTB     r0,r0                 ;1321
00002a  2805              CMP      r0,#5                 ;1321
00002c  d117              BNE      |L32.94|
                  |L32.46|
00002e  69a0              LDR      r0,[r4,#0x18]         ;1327
000030  b2c0              UXTB     r0,r0                 ;1327
000032  2805              CMP      r0,#5                 ;1327
000034  d103              BNE      |L32.62|
000036  68a2              LDR      r2,[r4,#8]            ;1330
000038  68e0              LDR      r0,[r4,#0xc]          ;1330
00003a  6002              STR      r2,[r0,#0]            ;1330
00003c  6050              STR      r0,[r2,#4]            ;1330
                  |L32.62|
00003e  69a0              LDR      r0,[r4,#0x18]         ;1335
000040  0a00              LSRS     r0,r0,#8              ;1335
000042  0200              LSLS     r0,r0,#8              ;1335
000044  1c40              ADDS     r0,r0,#1              ;1335
000046  61a0              STR      r0,[r4,#0x18]         ;1335
000048  4620              MOV      r0,r4                 ;1338
00004a  f7fffffe          BL       _RMP_Set_Rdy
00004e  4809              LDR      r0,|L32.116|
000050  68c1              LDR      r1,[r0,#0xc]          ;1341  ; RMP_Sched_Pend
000052  2900              CMP      r1,#0                 ;1341
000054  d003              BEQ      |L32.94|
000056  2100              MOVS     r1,#0                 ;1344
000058  60c1              STR      r1,[r0,#0xc]          ;1344  ; RMP_Sched_Pend
00005a  f7fffffe          BL       _RMP_Yield
                  |L32.94|
00005e  62e5              STR      r5,[r4,#0x2c]         ;1354
000060  69a0              LDR      r0,[r4,#0x18]         ;1355
000062  2101              MOVS     r1,#1                 ;1355
000064  0249              LSLS     r1,r1,#9              ;1355
000066  4308              ORRS     r0,r0,r1              ;1355
000068  61a0              STR      r0,[r4,#0x18]         ;1355
00006a  2000              MOVS     r0,#0                 ;1358
00006c  bd70              POP      {r4-r6,pc}
;;;1360   /* End Function:RMP_Thd_Snd_ISR **********************************************/
                          ENDP

00006e  0000              DCW      0x0000
                  |L32.112|
                          DCD      0xffffffff
                  |L32.116|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Suspend||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Suspend PROC
;;;1046   ******************************************************************************/
;;;1047   rmp_ret_t RMP_Thd_Suspend(volatile struct RMP_Thd* Thread)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1048   {
;;;1049       /* Check if this thread structure could possibly be in use */
;;;1050       if(Thread==0)
;;;1051       {
;;;1052           RMP_COVERAGE_MARKER();
;;;1053           return RMP_ERR_THD;
000002  4f18              LDR      r7,|L33.100|
000004  0004              MOVS     r4,r0                 ;1048
000006  d012              BEQ      |L33.46|
000008  f7fffffe          BL       RMP_Disable_Int
00000c  4d16              LDR      r5,|L33.104|
00000e  2601              MOVS     r6,#1                 ;1048
000010  60ae              STR      r6,[r5,#8]            ;1048  ; RMP_Sched_Locked
000012  6868              LDR      r0,[r5,#4]            ;1048  ; RMP_Sched_Lock_Cnt
000014  1c40              ADDS     r0,r0,#1              ;1048
000016  6068              STR      r0,[r5,#4]            ;1048  ; RMP_Sched_Lock_Cnt
;;;1054       }
;;;1055       else
;;;1056           RMP_COVERAGE_MARKER();
;;;1057       
;;;1058       RMP_Lock_Sched();
;;;1059       
;;;1060       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
000018  69a0              LDR      r0,[r4,#0x18]
00001a  0600              LSLS     r0,r0,#24
00001c  0e00              LSRS     r0,r0,#24
00001e  d008              BEQ      |L33.50|
;;;1061       {
;;;1062           RMP_COVERAGE_MARKER();
;;;1063           RMP_Unlock_Sched();
;;;1064           return RMP_ERR_THD;
;;;1065       }
;;;1066       else
;;;1067           RMP_COVERAGE_MARKER();
;;;1068       
;;;1069       /* Suspend it */
;;;1070       if((Thread->State&RMP_THD_SUSPENDED)!=0)
000020  69a0              LDR      r0,[r4,#0x18]
000022  05c0              LSLS     r0,r0,#23
000024  d509              BPL      |L33.58|
;;;1071       {
;;;1072           RMP_COVERAGE_MARKER();
;;;1073           RMP_Unlock_Sched();
000026  f7fffffe          BL       RMP_Unlock_Sched
;;;1074           return RMP_ERR_STATE;
00002a  1f70              SUBS     r0,r6,#5
;;;1075       }
;;;1076       else
;;;1077           RMP_COVERAGE_MARKER();
;;;1078       
;;;1079       /* Only when it is running do we clear this. If we are clearing this, it is not
;;;1080        * suspended, so trhe running queue removal is guaranteed to succceed */
;;;1081       if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;1082       {
;;;1083           RMP_COVERAGE_MARKER();
;;;1084           _RMP_Clr_Rdy(Thread);
;;;1085       }
;;;1086       else
;;;1087           RMP_COVERAGE_MARKER();
;;;1088       
;;;1089       /* Mark this as suspended */
;;;1090       Thread->State|=RMP_THD_SUSPENDED;
;;;1091       
;;;1092       /* If we are suspending ourself, pend a yield */
;;;1093       if(Thread==RMP_Cur_Thd)
;;;1094       {
;;;1095           RMP_COVERAGE_MARKER();
;;;1096           RMP_Sched_Pend=1;
;;;1097       }
;;;1098       else
;;;1099           RMP_COVERAGE_MARKER();
;;;1100       
;;;1101       RMP_Unlock_Sched();
;;;1102       return 0;
;;;1103   }
00002c  bdf8              POP      {r3-r7,pc}
                  |L33.46|
00002e  4638              MOV      r0,r7                 ;1053
000030  bdf8              POP      {r3-r7,pc}
                  |L33.50|
000032  f7fffffe          BL       RMP_Unlock_Sched
000036  4638              MOV      r0,r7                 ;1064
000038  bdf8              POP      {r3-r7,pc}
                  |L33.58|
00003a  69a0              LDR      r0,[r4,#0x18]         ;1081
00003c  b2c0              UXTB     r0,r0                 ;1081
00003e  2801              CMP      r0,#1                 ;1081
000040  d102              BNE      |L33.72|
000042  4620              MOV      r0,r4                 ;1084
000044  f7fffffe          BL       _RMP_Clr_Rdy
                  |L33.72|
000048  69a0              LDR      r0,[r4,#0x18]         ;1090
00004a  21ff              MOVS     r1,#0xff              ;1090
00004c  3101              ADDS     r1,#1                 ;1090
00004e  4308              ORRS     r0,r0,r1              ;1090
000050  61a0              STR      r0,[r4,#0x18]         ;1090
000052  69a8              LDR      r0,[r5,#0x18]         ;1093  ; RMP_Cur_Thd
000054  4284              CMP      r4,r0                 ;1093
000056  d100              BNE      |L33.90|
000058  60ee              STR      r6,[r5,#0xc]          ;1096  ; RMP_Sched_Pend
                  |L33.90|
00005a  f7fffffe          BL       RMP_Unlock_Sched
00005e  2000              MOVS     r0,#0                 ;1102
000060  bdf8              POP      {r3-r7,pc}
;;;1104   /* End Function:RMP_Thd_Suspend **********************************************/
                          ENDP

000062  0000              DCW      0x0000
                  |L33.100|
                          DCD      0xffffffff
                  |L33.104|
                          DCD      ||.data||

                          AREA ||i.RMP_Unlock_Sched||, CODE, READONLY, ALIGN=2

                  RMP_Unlock_Sched PROC
;;;375    ******************************************************************************/
;;;376    void RMP_Unlock_Sched(void)
000000  b510              PUSH     {r4,lr}
;;;377    {
;;;378        if(RMP_Sched_Lock_Cnt==1)
000002  480c              LDR      r0,|L34.52|
000004  6841              LDR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
000006  2901              CMP      r1,#1
000008  d006              BEQ      |L34.24|
;;;379        {
;;;380            RMP_COVERAGE_MARKER();
;;;381            /* Clear the count before enabling */
;;;382            RMP_Sched_Lock_Cnt=0;
;;;383            RMP_Sched_Locked=0;
;;;384            /* Now see if the scheduler scheduling action is pended in the lock-unlock 
;;;385             * period. If yes, perform a schedule now */
;;;386            if(RMP_Sched_Pend!=0)
;;;387            {
;;;388                RMP_COVERAGE_MARKER();
;;;389                /* Reset the count and trigger the context switch */
;;;390                RMP_Sched_Pend=0;
;;;391                _RMP_Yield();
;;;392            }
;;;393            else
;;;394                RMP_COVERAGE_MARKER();
;;;395            
;;;396            RMP_UNMASK_INT();
;;;397        }
;;;398        else if(RMP_Sched_Lock_Cnt>1)
00000a  6841              LDR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
00000c  2901              CMP      r1,#1
00000e  d90f              BLS      |L34.48|
;;;399        {
;;;400            RMP_COVERAGE_MARKER();
;;;401            RMP_Sched_Lock_Cnt--;
000010  6841              LDR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
000012  1e49              SUBS     r1,r1,#1
000014  6041              STR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
;;;402        }
;;;403        /* Trying to unlock a scheduler that is not locked - should never happen */
;;;404        else
;;;405            while(1);
;;;406    }
000016  bd10              POP      {r4,pc}
                  |L34.24|
000018  2100              MOVS     r1,#0                 ;382
00001a  6041              STR      r1,[r0,#4]            ;382  ; RMP_Sched_Lock_Cnt
00001c  6081              STR      r1,[r0,#8]            ;383  ; RMP_Sched_Locked
00001e  68c2              LDR      r2,[r0,#0xc]          ;386  ; RMP_Sched_Pend
000020  2a00              CMP      r2,#0                 ;386
000022  d002              BEQ      |L34.42|
000024  60c1              STR      r1,[r0,#0xc]          ;390  ; RMP_Sched_Pend
000026  f7fffffe          BL       _RMP_Yield
                  |L34.42|
00002a  f7fffffe          BL       RMP_Enable_Int
00002e  bd10              POP      {r4,pc}
                  |L34.48|
000030  e7fe              B        |L34.48|
;;;407    /* End Function:RMP_Unlock_Sched *********************************************/
                          ENDP

000032  0000              DCW      0x0000
                  |L34.52|
                          DCD      ||.data||

                          AREA ||i.RMP_Yield||, CODE, READONLY, ALIGN=2

                  RMP_Yield PROC
;;;414    ******************************************************************************/
;;;415    void RMP_Yield(void)
000000  b510              PUSH     {r4,lr}
;;;416    {
;;;417        if(RMP_Sched_Locked==0)
000002  4805              LDR      r0,|L35.24|
000004  6881              LDR      r1,[r0,#8]  ; RMP_Sched_Locked
000006  2900              CMP      r1,#0
000008  d002              BEQ      |L35.16|
;;;418        {
;;;419            RMP_COVERAGE_MARKER();
;;;420            /* Now see if the scheduler scheduling action is pended in the lock-unlock 
;;;421             * period. If yes, perform a schedule now */
;;;422            _RMP_Yield();
;;;423        }
;;;424        else
;;;425        {
;;;426            RMP_COVERAGE_MARKER();
;;;427            RMP_Sched_Pend=1;
00000a  2101              MOVS     r1,#1
00000c  60c1              STR      r1,[r0,#0xc]  ; RMP_Sched_Pend
;;;428        }
;;;429    }
00000e  bd10              POP      {r4,pc}
                  |L35.16|
000010  f7fffffe          BL       _RMP_Yield
000014  bd10              POP      {r4,pc}
;;;430    /* End Function:RMP_Yield ****************************************************/
                          ENDP

000016  0000              DCW      0x0000
                  |L35.24|
                          DCD      ||.data||

                          AREA ||i._RMP_Clr_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Clr_Rdy PROC
;;;686    ******************************************************************************/
;;;687    void _RMP_Clr_Rdy(volatile struct RMP_Thd* Thread)
000000  b430              PUSH     {r4,r5}
;;;688    {
;;;689        /* Is it suspended? If yes, no need to delete again */
;;;690        if((Thread->State&RMP_THD_SUSPENDED)==0)
000002  6981              LDR      r1,[r0,#0x18]
000004  05c9              LSLS     r1,r1,#23
000006  d41a              BMI      |L36.62|
;;;691        {
;;;692            RMP_COVERAGE_MARKER();
;;;693            /* See if it is the last thread on the priority level */
;;;694            if(Thread->Run_Head.Prev==Thread->Run_Head.Next)
000008  6801              LDR      r1,[r0,#0]
00000a  6843              LDR      r3,[r0,#4]
;;;695            {
;;;696                RMP_COVERAGE_MARKER();
;;;697                RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]&=~(((rmp_ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK));
00000c  2201              MOVS     r2,#1
00000e  4299              CMP      r1,r3                 ;694
000010  d10c              BNE      |L36.44|
000012  6a41              LDR      r1,[r0,#0x24]
000014  4b0b              LDR      r3,|L36.68|
000016  0949              LSRS     r1,r1,#5
000018  0089              LSLS     r1,r1,#2
00001a  18c9              ADDS     r1,r1,r3
00001c  680b              LDR      r3,[r1,#0]
00001e  6a44              LDR      r4,[r0,#0x24]
000020  06e5              LSLS     r5,r4,#27
000022  0eed              LSRS     r5,r5,#27
000024  4614              MOV      r4,r2
000026  40ac              LSLS     r4,r4,r5
000028  43a3              BICS     r3,r3,r4
00002a  600b              STR      r3,[r1,#0]
                  |L36.44|
;;;698            }
;;;699            else
;;;700                RMP_COVERAGE_MARKER();
;;;701            
;;;702            /* Delete this from the corresponding runqueue */
;;;703            RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
00002c  6803              LDR      r3,[r0,#0]
00002e  6841              LDR      r1,[r0,#4]
000030  600b              STR      r3,[r1,#0]
000032  6059              STR      r1,[r3,#4]
;;;704            
;;;705            /* If it is the current thread, request a context switch */
;;;706            if(Thread==RMP_Cur_Thd)
000034  4903              LDR      r1,|L36.68|
000036  698b              LDR      r3,[r1,#0x18]  ; RMP_Cur_Thd
000038  4298              CMP      r0,r3
00003a  d100              BNE      |L36.62|
;;;707            {
;;;708                RMP_COVERAGE_MARKER();
;;;709                RMP_Sched_Pend=1;
00003c  60ca              STR      r2,[r1,#0xc]  ; RMP_Sched_Pend
                  |L36.62|
;;;710            }
;;;711            else
;;;712                RMP_COVERAGE_MARKER();
;;;713        }
;;;714        else
;;;715            RMP_COVERAGE_MARKER();
;;;716    }
00003e  bc30              POP      {r4,r5}
000040  4770              BX       lr
;;;717    /* End Function:_RMP_Clr_Rdy *************************************************/
                          ENDP

000042  0000              DCW      0x0000
                  |L36.68|
                          DCD      ||.data||

                          AREA ||i._RMP_Get_High_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Get_High_Rdy PROC
;;;494    ******************************************************************************/
;;;495    void _RMP_Get_High_Rdy(void)
000000  b570              PUSH     {r4-r6,lr}
;;;496    {
;;;497        rmp_cnt_t Count;
;;;498        
;;;499        /* Write the SP value to thread structure */
;;;500        RMP_Cur_Thd->Stack=RMP_Cur_SP;
000002  4c18              LDR      r4,|L37.100|
000004  69e0              LDR      r0,[r4,#0x1c]  ; RMP_Cur_SP
000006  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
;;;501        
;;;502        /* No need to detect scheduler locks - if this interrupt can be entered, the scheduler is not locked */
;;;503        RMP_Sched_Pend=0;
000008  6348              STR      r0,[r1,#0x34]
00000a  2000              MOVS     r0,#0
00000c  60e0              STR      r0,[r4,#0xc]  ; RMP_Sched_Pend
;;;504        /* See which one is ready, and pick it */
;;;505        for(Count=RMP_BITMAP_SIZE-1;Count>=0;Count--)
;;;506        {
;;;507            if(RMP_Bitmap[Count]==0)
00000e  4620              MOV      r0,r4
000010  6801              LDR      r1,[r0,#0]
000012  2900              CMP      r1,#0
000014  d022              BEQ      |L37.92|
;;;508            {
;;;509                RMP_COVERAGE_MARKER();
;;;510                continue;
;;;511            }
;;;512            else
;;;513                RMP_COVERAGE_MARKER();
;;;514            
;;;515            Count=RMP_MSB_Get(RMP_Bitmap[Count])+(Count<<RMP_WORD_ORDER);
000016  6800              LDR      r0,[r0,#0]
000018  f7fffffe          BL       RMP_MSB_Get
;;;516            
;;;517            /* See if the current thread and the next thread are the same. If yes, place the current at the end of the queue */
;;;518            if(RMP_Cur_Thd==(struct RMP_Thd*)(RMP_Run[Count].Next))
00001c  4912              LDR      r1,|L37.104|
00001e  00c0              LSLS     r0,r0,#3
000020  1842              ADDS     r2,r0,r1
000022  6850              LDR      r0,[r2,#4]
000024  69a3              LDR      r3,[r4,#0x18]  ; RMP_Cur_Thd
000026  4298              CMP      r0,r3
000028  d112              BNE      |L37.80|
;;;519            {
;;;520                RMP_COVERAGE_MARKER();
;;;521                RMP_List_Del(RMP_Cur_Thd->Run_Head.Prev, RMP_Cur_Thd->Run_Head.Next);
00002a  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
00002c  6803              LDR      r3,[r0,#0]
00002e  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
000030  6840              LDR      r0,[r0,#4]
000032  6003              STR      r3,[r0,#0]
000034  6058              STR      r0,[r3,#4]
;;;522                RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),
000036  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
000038  69a3              LDR      r3,[r4,#0x18]  ; RMP_Cur_Thd
00003a  6a5b              LDR      r3,[r3,#0x24]
00003c  00db              LSLS     r3,r3,#3
00003e  58cb              LDR      r3,[r1,r3]
000040  69a5              LDR      r5,[r4,#0x18]  ; RMP_Cur_Thd
000042  6a6d              LDR      r5,[r5,#0x24]
000044  00ed              LSLS     r5,r5,#3
000046  1869              ADDS     r1,r5,r1
000048  6008              STR      r0,[r1,#0]
00004a  6041              STR      r1,[r0,#4]
00004c  6003              STR      r3,[r0,#0]
00004e  6058              STR      r0,[r3,#4]
                  |L37.80|
;;;523                             RMP_Run[RMP_Cur_Thd->Prio].Prev,
;;;524                             &(RMP_Run[RMP_Cur_Thd->Prio]));
;;;525            }
;;;526            else
;;;527                RMP_COVERAGE_MARKER();
;;;528            
;;;529            /* Replenish timeslices */
;;;530            RMP_Cur_Thd->Slices_Left=RMP_Cur_Thd->Slices;
000050  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
000052  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
000054  69c0              LDR      r0,[r0,#0x1c]
;;;531            RMP_Cur_Thd=(struct RMP_Thd*)(RMP_Run[Count].Next);
000056  6208              STR      r0,[r1,#0x20]
000058  6850              LDR      r0,[r2,#4]
00005a  61a0              STR      r0,[r4,#0x18]  ; RMP_Cur_Thd
                  |L37.92|
;;;532            break;
;;;533        }
;;;534        
;;;535        /* Load the SP value from thread structure */
;;;536        RMP_Cur_SP=RMP_Cur_Thd->Stack;
00005c  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
00005e  6b40              LDR      r0,[r0,#0x34]
000060  61e0              STR      r0,[r4,#0x1c]  ; RMP_Cur_SP
;;;537        
;;;538    #if(RMP_USE_HOOKS==RMP_TRUE)
;;;539        RMP_Sched_Hook();
;;;540    #endif
;;;541    }
000062  bd70              POP      {r4-r6,pc}
;;;542    /* End Function:_RMP_Get_High_Rdy ********************************************/
                          ENDP

                  |L37.100|
                          DCD      ||.data||
                  |L37.104|
                          DCD      ||.bss||

                          AREA ||i._RMP_Get_Near_Ticks||, CODE, READONLY, ALIGN=2

                  _RMP_Get_Near_Ticks PROC
;;;612    ******************************************************************************/
;;;613    rmp_ptr_t _RMP_Get_Near_Ticks(void)
000000  4a07              LDR      r2,|L38.32|
;;;614    {
;;;615        rmp_ptr_t Value;
;;;616        struct RMP_Thd* Thread;
;;;617        
;;;618        /* What is the current thread's timeout value? */
;;;619        Value=RMP_Cur_Thd->Slices_Left;
000002  6990              LDR      r0,[r2,#0x18]  ; RMP_Cur_Thd
;;;620        
;;;621        /* What is the nearest timer timeout value? */
;;;622        if((&RMP_Delay)!=RMP_Delay.Next)
000004  4907              LDR      r1,|L38.36|
000006  6a00              LDR      r0,[r0,#0x20]         ;619
000008  684b              LDR      r3,[r1,#4]  ; RMP_Delay
00000a  428b              CMP      r3,r1
00000c  d007              BEQ      |L38.30|
;;;623        {
;;;624            RMP_COVERAGE_MARKER();
;;;625            Thread=RMP_DLY2THD(RMP_Delay.Next);
00000e  6849              LDR      r1,[r1,#4]  ; RMP_Delay
;;;626            /* See if it is nearer - don't worry about the situation that the timer
;;;627             * have overflown, because if that is to happen, it would have been 
;;;628             * already processed by the timeout processing routine just before. */
;;;629            if((Thread->Timeout-RMP_Tick)<Value)
000010  6953              LDR      r3,[r2,#0x14]  ; RMP_Tick
000012  6a09              LDR      r1,[r1,#0x20]
000014  1acb              SUBS     r3,r1,r3
000016  4283              CMP      r3,r0
000018  d201              BCS      |L38.30|
;;;630            {
;;;631                RMP_COVERAGE_MARKER();
;;;632                Value=Thread->Timeout-RMP_Tick;
00001a  6950              LDR      r0,[r2,#0x14]  ; RMP_Tick
00001c  1a08              SUBS     r0,r1,r0
                  |L38.30|
;;;633            }
;;;634            else
;;;635                RMP_COVERAGE_MARKER();
;;;636        }
;;;637        else
;;;638            RMP_COVERAGE_MARKER();
;;;639        
;;;640        return Value;
;;;641    }
00001e  4770              BX       lr
;;;642    /* End Function:_RMP_Get_Near_Ticks ******************************************/
                          ENDP

                  |L38.32|
                          DCD      ||.data||
                  |L38.36|
                          DCD      ||.data||+0x20

                          AREA ||i._RMP_Mem_Ins||, CODE, READONLY, ALIGN=1

                  _RMP_Mem_Ins PROC
;;;2253   ******************************************************************************/
;;;2254   void _RMP_Mem_Ins(volatile void* Pool, volatile struct RMP_Mem_Head* Mem_Head)
000000  b570              PUSH     {r4-r6,lr}
;;;2255   {
;;;2256       rmp_cnt_t FLI_Level;
;;;2257       rmp_cnt_t SLI_Level;
;;;2258       rmp_ptr_t Level;
;;;2259       rmp_ptr_t Size;
;;;2260       volatile struct RMP_Mem* Mem;
;;;2261       volatile struct RMP_List* Slot;
;;;2262       
;;;2263       /* Get the memory pool and block size */
;;;2264       Mem=(volatile struct RMP_Mem*)Pool;
000002  4605              MOV      r5,r0
;;;2265       Size=(rmp_ptr_t)(Mem_Head->Tail)-((rmp_ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Head);
000004  68c8              LDR      r0,[r1,#0xc]
000006  460c              MOV      r4,r1                 ;2255
000008  1b06              SUBS     r6,r0,r4
00000a  3e10              SUBS     r6,r6,#0x10
;;;2266   
;;;2267       /* Guarantee the Mem_Size is bigger than 64 or a failure will surely occur here */
;;;2268       FLI_Level=RMP_MSB_Get(Size)-6;
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       RMP_MSB_Get
;;;2269       /* Decide the SLI level directly from the FLI level */
;;;2270       SLI_Level=(Size>>(FLI_Level+3))&0x07;
000012  1ec1              SUBS     r1,r0,#3
000014  40ce              LSRS     r6,r6,r1
000016  0771              LSLS     r1,r6,#29
000018  1f80              SUBS     r0,r0,#6
00001a  0f49              LSRS     r1,r1,#29
;;;2271       Level=(FLI_Level<<3)+SLI_Level;
00001c  00c0              LSLS     r0,r0,#3
00001e  1841              ADDS     r1,r0,r1
000020  00c8              LSLS     r0,r1,#3
;;;2272       /* Get the slot */
;;;2273       Slot=&(Mem->Table[RMP_MEM_POS(FLI_Level,SLI_Level)]);
000022  1940              ADDS     r0,r0,r5
;;;2274   
;;;2275       /* See if there are any blocks in the level, equal means no. So what we inserted is the first block */
;;;2276       if(Slot==Slot->Next)
000024  6ac2              LDR      r2,[r0,#0x2c]
000026  3028              ADDS     r0,r0,#0x28
000028  4282              CMP      r2,r0
00002a  d109              BNE      |L39.64|
;;;2277       {
;;;2278           RMP_COVERAGE_MARKER();
;;;2279           /* Set the corresponding bit in the TLSF bitmap */
;;;2280           Mem->Bitmap[Level>>RMP_WORD_ORDER]|=1<<(Level&RMP_WORD_MASK);
00002c  094a              LSRS     r2,r1,#5
00002e  0092              LSLS     r2,r2,#2
000030  1952              ADDS     r2,r2,r5
000032  6953              LDR      r3,[r2,#0x14]
000034  06cd              LSLS     r5,r1,#27
000036  0eed              LSRS     r5,r5,#27
000038  2101              MOVS     r1,#1
00003a  40a9              LSLS     r1,r1,r5
00003c  430b              ORRS     r3,r3,r1
00003e  6153              STR      r3,[r2,#0x14]
                  |L39.64|
;;;2281       }
;;;2282       else
;;;2283           RMP_COVERAGE_MARKER();
;;;2284   
;;;2285       /* Insert the node now */
;;;2286       RMP_List_Ins(&(Mem_Head->Head), Slot, Slot->Next);
000040  6841              LDR      r1,[r0,#4]
000042  600c              STR      r4,[r1,#0]
000044  6061              STR      r1,[r4,#4]
000046  6020              STR      r0,[r4,#0]
000048  6044              STR      r4,[r0,#4]
;;;2287   }
00004a  bd70              POP      {r4-r6,pc}
;;;2288   /* End Function:_RMP_Mem_Ins *************************************************/
                          ENDP


                          AREA ||i._RMP_Set_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Set_Rdy PROC
;;;653    ******************************************************************************/
;;;654    void _RMP_Set_Rdy(volatile struct RMP_Thd* Thread)
000000  6981              LDR      r1,[r0,#0x18]
;;;655    {        
;;;656        /* Is it suspended? If yes, we can't directly set it running */
;;;657        if((Thread->State&RMP_THD_SUSPENDED)==0)
000002  05c9              LSLS     r1,r1,#23
000004  d422              BMI      |L40.76|
000006  b430              PUSH     {r4,r5}               ;655
;;;658        {
;;;659            RMP_COVERAGE_MARKER();
;;;660            /* Insert this into the corresponding runqueue */
;;;661            RMP_List_Ins(&(Thread->Run_Head),RMP_Run[Thread->Prio].Prev,&(RMP_Run[Thread->Prio]));
000008  6a41              LDR      r1,[r0,#0x24]
00000a  4a11              LDR      r2,|L40.80|
00000c  00c9              LSLS     r1,r1,#3
00000e  5851              LDR      r1,[r2,r1]
000010  6a43              LDR      r3,[r0,#0x24]
000012  00db              LSLS     r3,r3,#3
000014  189a              ADDS     r2,r3,r2
000016  6010              STR      r0,[r2,#0]
000018  6042              STR      r2,[r0,#4]
00001a  6001              STR      r1,[r0,#0]
00001c  6048              STR      r0,[r1,#4]
;;;662            /* Set this runlevel as active */
;;;663            RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]|=((rmp_ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK);
00001e  6a41              LDR      r1,[r0,#0x24]
000020  4a0c              LDR      r2,|L40.84|
000022  0949              LSRS     r1,r1,#5
000024  0089              LSLS     r1,r1,#2
000026  188a              ADDS     r2,r1,r2
000028  6813              LDR      r3,[r2,#0]
00002a  6a41              LDR      r1,[r0,#0x24]
00002c  06cd              LSLS     r5,r1,#27
00002e  2101              MOVS     r1,#1
000030  0eed              LSRS     r5,r5,#27
000032  460c              MOV      r4,r1
000034  40ac              LSLS     r4,r4,r5
000036  4323              ORRS     r3,r3,r4
000038  6013              STR      r3,[r2,#0]
;;;664            
;;;665            /* Compare this with the current one to see if we need a context switch */
;;;666            if(Thread->Prio>RMP_Cur_Thd->Prio)
00003a  6a42              LDR      r2,[r0,#0x24]
00003c  4805              LDR      r0,|L40.84|
00003e  6983              LDR      r3,[r0,#0x18]  ; RMP_Cur_Thd
000040  6a5b              LDR      r3,[r3,#0x24]
000042  429a              CMP      r2,r3
000044  d900              BLS      |L40.72|
;;;667            {
;;;668                RMP_COVERAGE_MARKER();
;;;669                RMP_Sched_Pend=1;
000046  60c1              STR      r1,[r0,#0xc]  ; RMP_Sched_Pend
                  |L40.72|
;;;670            }
;;;671            else
;;;672                RMP_COVERAGE_MARKER();
;;;673        }
;;;674        else
;;;675            RMP_COVERAGE_MARKER();
;;;676    }
000048  bc30              POP      {r4,r5}
00004a  4770              BX       lr
                  |L40.76|
00004c  4770              BX       lr
;;;677    /* End Function:_RMP_Set_Rdy *************************************************/
                          ENDP

00004e  0000              DCW      0x0000
                  |L40.80|
                          DCD      ||.bss||
                  |L40.84|
                          DCD      ||.data||

                          AREA ||i._RMP_Tick_Handler||, CODE, READONLY, ALIGN=2

                  _RMP_Tick_Handler PROC
;;;549    ******************************************************************************/
;;;550    void _RMP_Tick_Handler(rmp_ptr_t Ticks)
000000  b5f8              PUSH     {r3-r7,lr}
;;;551    {
;;;552        struct RMP_Thd* Thread;
;;;553        /* Increase the timestamp as always */
;;;554        RMP_Tick+=Ticks;
000002  4d26              LDR      r5,|L41.156|
000004  6969              LDR      r1,[r5,#0x14]  ; RMP_Tick
000006  1809              ADDS     r1,r1,r0
000008  6169              STR      r1,[r5,#0x14]  ; RMP_Tick
;;;555        
;;;556        /* See if the current thread expired. If yes, trigger a scheduler event */
;;;557        if(Ticks>RMP_Cur_Thd->Slices_Left)
00000a  69a9              LDR      r1,[r5,#0x18]  ; RMP_Cur_Thd
00000c  6a09              LDR      r1,[r1,#0x20]
00000e  4281              CMP      r1,r0
000010  d202              BCS      |L41.24|
;;;558        {
;;;559            RMP_COVERAGE_MARKER();
;;;560            RMP_Sched_Pend=1;
000012  2001              MOVS     r0,#1
000014  60e8              STR      r0,[r5,#0xc]  ; RMP_Sched_Pend
000016  e003              B        |L41.32|
                  |L41.24|
;;;561        }
;;;562        else
;;;563        {
;;;564            RMP_COVERAGE_MARKER();
;;;565            RMP_Cur_Thd->Slices_Left-=Ticks;
000018  69a9              LDR      r1,[r5,#0x18]  ; RMP_Cur_Thd
00001a  6a0a              LDR      r2,[r1,#0x20]
00001c  1a10              SUBS     r0,r2,r0
00001e  6208              STR      r0,[r1,#0x20]
                  |L41.32|
;;;566        }
;;;567        
;;;568        /* Check if there are any timer events */
;;;569        if((&RMP_Delay)!=RMP_Delay.Next)
000020  4c1f              LDR      r4,|L41.160|
000022  6860              LDR      r0,[r4,#4]  ; RMP_Delay
000024  42a0              CMP      r0,r4
000026  d031              BEQ      |L41.140|
;;;570        {
;;;571            RMP_COVERAGE_MARKER();
;;;572            Thread=RMP_DLY2THD(RMP_Delay.Next);
000028  6860              LDR      r0,[r4,#4]  ; RMP_Delay
;;;573            /* If the value is less than this, then it means that the time have
;;;574             * already passed and we have to process this */
;;;575            if((RMP_Tick-Thread->Timeout)<=(RMP_ALLBITS>>1))
00002a  6969              LDR      r1,[r5,#0x14]  ; RMP_Tick
00002c  6a00              LDR      r0,[r0,#0x20]
00002e  4e1d              LDR      r6,|L41.164|
000030  1a08              SUBS     r0,r1,r0
000032  42b0              CMP      r0,r6
000034  d82a              BHI      |L41.140|
000036  6860              LDR      r0,[r4,#4]  ; RMP_Delay
000038  42a0              CMP      r0,r4
00003a  d027              BEQ      |L41.140|
00003c  2704              MOVS     r7,#4
00003e  43ff              MVNS     r7,r7
                  |L41.64|
000040  6860              LDR      r0,[r4,#4]  ; RMP_Delay
000042  696a              LDR      r2,[r5,#0x14]  ; RMP_Tick
000044  6a01              LDR      r1,[r0,#0x20]
000046  3808              SUBS     r0,r0,#8
000048  1a51              SUBS     r1,r2,r1
00004a  42b1              CMP      r1,r6
00004c  d81e              BHI      |L41.140|
00004e  68c2              LDR      r2,[r0,#0xc]
000050  6881              LDR      r1,[r0,#8]
000052  6011              STR      r1,[r2,#0]
000054  604a              STR      r2,[r1,#4]
000056  7e01              LDRB     r1,[r0,#0x18]
000058  2903              CMP      r1,#3
00005a  d006              BEQ      |L41.106|
00005c  2905              CMP      r1,#5
00005e  d00a              BEQ      |L41.118|
000060  2906              CMP      r1,#6
000062  d009              BEQ      |L41.120|
000064  2908              CMP      r1,#8
000066  d000              BEQ      |L41.106|
                  |L41.104|
000068  e7fe              B        |L41.104|
                  |L41.106|
00006a  6842              LDR      r2,[r0,#4]
00006c  6801              LDR      r1,[r0,#0]
00006e  6011              STR      r1,[r2,#0]
000070  604a              STR      r2,[r1,#4]
000072  6387              STR      r7,[r0,#0x38]
000074  e000              B        |L41.120|
                  |L41.118|
000076  6387              STR      r7,[r0,#0x38]
                  |L41.120|
000078  6981              LDR      r1,[r0,#0x18]
00007a  0a09              LSRS     r1,r1,#8
00007c  0209              LSLS     r1,r1,#8
00007e  1c49              ADDS     r1,r1,#1
000080  6181              STR      r1,[r0,#0x18]
000082  f7fffffe          BL       _RMP_Set_Rdy
000086  6860              LDR      r0,[r4,#4]  ; RMP_Delay
000088  42a0              CMP      r0,r4
00008a  d1d9              BNE      |L41.64|
                  |L41.140|
;;;576            {
;;;577                RMP_COVERAGE_MARKER();
;;;578                /* No need to care about scheduler locks if this interrupt can be entered
;;;579                 * - we have disabled timer and scheduler interrupts in scheduler lock */
;;;580                _RMP_Timer_Proc();
;;;581            }
;;;582            else
;;;583                RMP_COVERAGE_MARKER();
;;;584        }
;;;585        else
;;;586            RMP_COVERAGE_MARKER();
;;;587        
;;;588        if(RMP_Sched_Pend!=0)
00008c  68e8              LDR      r0,[r5,#0xc]  ; RMP_Sched_Pend
00008e  2800              CMP      r0,#0
000090  d003              BEQ      |L41.154|
;;;589        {
;;;590            RMP_COVERAGE_MARKER();
;;;591            RMP_Sched_Pend=0;
000092  2000              MOVS     r0,#0
000094  60e8              STR      r0,[r5,#0xc]  ; RMP_Sched_Pend
;;;592            _RMP_Yield();
000096  f7fffffe          BL       _RMP_Yield
                  |L41.154|
;;;593        }
;;;594        else
;;;595            RMP_COVERAGE_MARKER();
;;;596        
;;;597    #if(RMP_USE_HOOKS==RMP_TRUE)
;;;598        RMP_Tick_Hook(Ticks);
;;;599    #endif
;;;600    }
00009a  bdf8              POP      {r3-r7,pc}
;;;601    /* End Function:_RMP_Tick_Handler ********************************************/
                          ENDP

                  |L41.156|
                          DCD      ||.data||
                  |L41.160|
                          DCD      ||.data||+0x20
                  |L41.164|
                          DCD      0x7fffffff

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;1994   ******************************************************************************/
;;;1995   int main(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1996   {
;;;1997       rmp_ptr_t Count;
;;;1998       
;;;1999   #ifdef RMP_COVERAGE
;;;2000       /* Initialize coverage markers if coverage enabled */
;;;2001       for(Count=0;Count<RMP_COVERAGE_LINES;Count++)
;;;2002           RMP_Coverage[Count]=0;
;;;2003   #endif
;;;2004       
;;;2005       /* Initialize the kernel data structures first */
;;;2006       _RMP_Low_Level_Init();
000002  f7fffffe          BL       _RMP_Low_Level_Init
;;;2007       
;;;2008   #if(RMP_USE_HOOKS==RMP_TRUE)
;;;2009       RMP_Start_Hook();
;;;2010   #endif
;;;2011       
;;;2012       RMP_Tick=0;
000006  4b1d              LDR      r3,|L42.124|
000008  2000              MOVS     r0,#0
00000a  6158              STR      r0,[r3,#0x14]  ; RMP_Tick
;;;2013       /* Now initialize the kernel data structures */
;;;2014       RMP_Sched_Lock_Cnt=0;
00000c  6058              STR      r0,[r3,#4]  ; RMP_Sched_Lock_Cnt
;;;2015       RMP_Sched_Locked=0;
00000e  6098              STR      r0,[r3,#8]  ; RMP_Sched_Locked
;;;2016       RMP_Sched_Pend=0;
000010  60d8              STR      r0,[r3,#0xc]  ; RMP_Sched_Pend
;;;2017       RMP_Timer_Pend=0;
000012  6118              STR      r0,[r3,#0x10]  ; RMP_Timer_Pend
;;;2018       
;;;2019       /* Linked lists */
;;;2020       RMP_List_Crt(&RMP_Delay);
000014  491a              LDR      r1,|L42.128|
000016  6009              STR      r1,[r1,#0]
000018  6049              STR      r1,[r1,#4]
;;;2021       for(Count=0;Count<RMP_MAX_PREEMPT_PRIO;Count++)
;;;2022           RMP_List_Crt(&RMP_Run[Count]);
00001a  4c1a              LDR      r4,|L42.132|
00001c  4601              MOV      r1,r0                 ;2021
                  |L42.30|
00001e  00ca              LSLS     r2,r1,#3
000020  1912              ADDS     r2,r2,r4
000022  6012              STR      r2,[r2,#0]
000024  6052              STR      r2,[r2,#4]
000026  1c49              ADDS     r1,r1,#1
000028  2920              CMP      r1,#0x20
00002a  d3f8              BCC      |L42.30|
;;;2023       for(Count=0;Count<RMP_BITMAP_SIZE;Count++)
;;;2024           RMP_Bitmap[Count]=0;
00002c  4d13              LDR      r5,|L42.124|
00002e  6028              STR      r0,[r5,#0]  ; RMP_Bitmap
;;;2025           
;;;2026       /* Now boot into the first thread */
;;;2027       RMP_Clear(&RMP_Init_Thd,sizeof(struct RMP_Thd));
000030  4915              LDR      r1,|L42.136|
000032  221e              MOVS     r2,#0x1e
                  |L42.52|
000034  7048              STRB     r0,[r1,#1]
000036  7088              STRB     r0,[r1,#2]
000038  1c89              ADDS     r1,r1,#2
00003a  1e52              SUBS     r2,r2,#1
00003c  d1fa              BNE      |L42.52|
;;;2028       RMP_Init_Thd.Prio=0;
00003e  4913              LDR      r1,|L42.140|
000040  6248              STR      r0,[r1,#0x24]  ; RMP_Init_Thd
;;;2029       RMP_Init_Thd.Slices=10;
000042  200a              MOVS     r0,#0xa
000044  61c8              STR      r0,[r1,#0x1c]  ; RMP_Init_Thd
;;;2030       RMP_Init_Thd.Slices_Left=10;
000046  6208              STR      r0,[r1,#0x20]  ; RMP_Init_Thd
;;;2031       RMP_Init_Thd.State=RMP_THD_RUNNING;
000048  2201              MOVS     r2,#1
00004a  618a              STR      r2,[r1,#0x18]  ; RMP_Init_Thd
;;;2032       RMP_Init_Thd.Stack=RMP_INIT_STACK;
00004c  4810              LDR      r0,|L42.144|
00004e  6348              STR      r0,[r1,#0x34]  ; RMP_Init_Thd
;;;2033       
;;;2034       /* Initialize sending list */
;;;2035       RMP_List_Crt(&(RMP_Init_Thd.Snd_List));
000050  4810              LDR      r0,|L42.148|
000052  6000              STR      r0,[r0,#0]
000054  6040              STR      r0,[r0,#4]
;;;2036       
;;;2037       /* Insert this into the corresponding runqueue */
;;;2038       RMP_List_Ins(&(RMP_Init_Thd.Run_Head),RMP_Run[0].Prev,&(RMP_Run[0]));
000056  6826              LDR      r6,[r4,#0]  ; RMP_Run
000058  3810              SUBS     r0,r0,#0x10
00005a  4c0a              LDR      r4,|L42.132|
00005c  6020              STR      r0,[r4,#0]
00005e  6044              STR      r4,[r0,#4]
000060  6006              STR      r6,[r0,#0]
000062  6070              STR      r0,[r6,#4]
;;;2039       /* Set this runlevel as active - in fact it is always active */
;;;2040       RMP_Bitmap[0]|=1;
000064  6828              LDR      r0,[r5,#0]  ; RMP_Bitmap
000066  4310              ORRS     r0,r0,r2
000068  6028              STR      r0,[r5,#0]  ; RMP_Bitmap
;;;2041       
;;;2042       /* Set current thread and stack */
;;;2043       RMP_Cur_Thd=(struct RMP_Thd*)(&RMP_Init_Thd);
00006a  6199              STR      r1,[r3,#0x18]  ; RMP_Cur_Thd
;;;2044       RMP_Cur_SP=RMP_Init_Thd.Stack;
00006c  6b48              LDR      r0,[r1,#0x34]  ; RMP_Init_Thd
00006e  61d8              STR      r0,[r3,#0x1c]  ; RMP_Cur_SP
;;;2045       
;;;2046       /* Now jump to the user function and will never return. Initialization of stack is not needed */
;;;2047       _RMP_Start((rmp_ptr_t)RMP_Init, (rmp_ptr_t)RMP_Init_Thd.Stack);
000070  6b49              LDR      r1,[r1,#0x34]  ; RMP_Init_Thd
000072  4809              LDR      r0,|L42.152|
000074  f7fffffe          BL       _RMP_Start
;;;2048       
;;;2049       return 0;
000078  2000              MOVS     r0,#0
;;;2050   }
00007a  bd70              POP      {r4-r6,pc}
;;;2051   /* End Function:main *********************************************************/
                          ENDP

                  |L42.124|
                          DCD      ||.data||
                  |L42.128|
                          DCD      ||.data||+0x20
                  |L42.132|
                          DCD      ||.bss||
                  |L42.136|
                          DCD      ||.bss||+0x1ff
                  |L42.140|
                          DCD      ||.bss||+0x200
                  |L42.144|
                          DCD      ||.bss||+0x1bc
                  |L42.148|
                          DCD      ||.bss||+0x210
                  |L42.152|
                          DCD      RMP_Init

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  RMP_Run
                          %        256
                  RMP_Init_Stack
                          %        256
                  RMP_Init_Thd
                          %        60

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  RMP_RBIT_Table
000000  008040c0          DCB      0x00,0x80,0x40,0xc0
000004  20a060e0          DCB      0x20,0xa0,0x60,0xe0
000008  109050d0          DCB      0x10,0x90,0x50,0xd0
00000c  30b070f0          DCB      0x30,0xb0,0x70,0xf0
000010  088848c8          DCB      0x08,0x88,0x48,0xc8
000014  28a868e8          DCB      0x28,0xa8,0x68,0xe8
000018  189858d8          DCB      0x18,0x98,0x58,0xd8
00001c  38b878f8          DCB      0x38,0xb8,0x78,0xf8
000020  048444c4          DCB      0x04,0x84,0x44,0xc4
000024  24a464e4          DCB      0x24,0xa4,0x64,0xe4
000028  149454d4          DCB      0x14,0x94,0x54,0xd4
00002c  34b474f4          DCB      0x34,0xb4,0x74,0xf4
000030  0c8c4ccc          DCB      0x0c,0x8c,0x4c,0xcc
000034  2cac6cec          DCB      0x2c,0xac,0x6c,0xec
000038  1c9c5cdc          DCB      0x1c,0x9c,0x5c,0xdc
00003c  3cbc7cfc          DCB      0x3c,0xbc,0x7c,0xfc
000040  028242c2          DCB      0x02,0x82,0x42,0xc2
000044  22a262e2          DCB      0x22,0xa2,0x62,0xe2
000048  129252d2          DCB      0x12,0x92,0x52,0xd2
00004c  32b272f2          DCB      0x32,0xb2,0x72,0xf2
000050  0a8a4aca          DCB      0x0a,0x8a,0x4a,0xca
000054  2aaa6aea          DCB      0x2a,0xaa,0x6a,0xea
000058  1a9a5ada          DCB      0x1a,0x9a,0x5a,0xda
00005c  3aba7afa          DCB      0x3a,0xba,0x7a,0xfa
000060  068646c6          DCB      0x06,0x86,0x46,0xc6
000064  26a666e6          DCB      0x26,0xa6,0x66,0xe6
000068  169656d6          DCB      0x16,0x96,0x56,0xd6
00006c  36b676f6          DCB      0x36,0xb6,0x76,0xf6
000070  0e8e4ece          DCB      0x0e,0x8e,0x4e,0xce
000074  2eae6eee          DCB      0x2e,0xae,0x6e,0xee
000078  1e9e5ede          DCB      0x1e,0x9e,0x5e,0xde
00007c  3ebe7efe          DCB      0x3e,0xbe,0x7e,0xfe
000080  018141c1          DCB      0x01,0x81,0x41,0xc1
000084  21a161e1          DCB      0x21,0xa1,0x61,0xe1
000088  119151d1          DCB      0x11,0x91,0x51,0xd1
00008c  31b171f1          DCB      0x31,0xb1,0x71,0xf1
000090  098949c9          DCB      0x09,0x89,0x49,0xc9
000094  29a969e9          DCB      0x29,0xa9,0x69,0xe9
000098  199959d9          DCB      0x19,0x99,0x59,0xd9
00009c  39b979f9          DCB      0x39,0xb9,0x79,0xf9
0000a0  058545c5          DCB      0x05,0x85,0x45,0xc5
0000a4  25a565e5          DCB      0x25,0xa5,0x65,0xe5
0000a8  159555d5          DCB      0x15,0x95,0x55,0xd5
0000ac  35b575f5          DCB      0x35,0xb5,0x75,0xf5
0000b0  0d8d4dcd          DCB      0x0d,0x8d,0x4d,0xcd
0000b4  2dad6ded          DCB      0x2d,0xad,0x6d,0xed
0000b8  1d9d5ddd          DCB      0x1d,0x9d,0x5d,0xdd
0000bc  3dbd7dfd          DCB      0x3d,0xbd,0x7d,0xfd
0000c0  038343c3          DCB      0x03,0x83,0x43,0xc3
0000c4  23a363e3          DCB      0x23,0xa3,0x63,0xe3
0000c8  139353d3          DCB      0x13,0x93,0x53,0xd3
0000cc  33b373f3          DCB      0x33,0xb3,0x73,0xf3
0000d0  0b8b4bcb          DCB      0x0b,0x8b,0x4b,0xcb
0000d4  2bab6beb          DCB      0x2b,0xab,0x6b,0xeb
0000d8  1b9b5bdb          DCB      0x1b,0x9b,0x5b,0xdb
0000dc  3bbb7bfb          DCB      0x3b,0xbb,0x7b,0xfb
0000e0  078747c7          DCB      0x07,0x87,0x47,0xc7
0000e4  27a767e7          DCB      0x27,0xa7,0x67,0xe7
0000e8  179757d7          DCB      0x17,0x97,0x57,0xd7
0000ec  37b777f7          DCB      0x37,0xb7,0x77,0xf7
0000f0  0f8f4fcf          DCB      0x0f,0x8f,0x4f,0xcf
0000f4  2faf6fef          DCB      0x2f,0xaf,0x6f,0xef
0000f8  1f9f5fdf          DCB      0x1f,0x9f,0x5f,0xdf
0000fc  3fbf7fff          DCB      0x3f,0xbf,0x7f,0xff
                  CRC16_High
000100  00c18140          DCB      0x00,0xc1,0x81,0x40
000104  01c08041          DCB      0x01,0xc0,0x80,0x41
000108  01c08041          DCB      0x01,0xc0,0x80,0x41
00010c  00c18140          DCB      0x00,0xc1,0x81,0x40
000110  01c08041          DCB      0x01,0xc0,0x80,0x41
000114  00c18140          DCB      0x00,0xc1,0x81,0x40
000118  00c18140          DCB      0x00,0xc1,0x81,0x40
00011c  01c08041          DCB      0x01,0xc0,0x80,0x41
000120  01c08041          DCB      0x01,0xc0,0x80,0x41
000124  00c18140          DCB      0x00,0xc1,0x81,0x40
000128  00c18140          DCB      0x00,0xc1,0x81,0x40
00012c  01c08041          DCB      0x01,0xc0,0x80,0x41
000130  00c18140          DCB      0x00,0xc1,0x81,0x40
000134  01c08041          DCB      0x01,0xc0,0x80,0x41
000138  01c08041          DCB      0x01,0xc0,0x80,0x41
00013c  00c18140          DCB      0x00,0xc1,0x81,0x40
000140  01c08041          DCB      0x01,0xc0,0x80,0x41
000144  00c18140          DCB      0x00,0xc1,0x81,0x40
000148  00c18140          DCB      0x00,0xc1,0x81,0x40
00014c  01c08041          DCB      0x01,0xc0,0x80,0x41
000150  00c18140          DCB      0x00,0xc1,0x81,0x40
000154  01c08041          DCB      0x01,0xc0,0x80,0x41
000158  01c08041          DCB      0x01,0xc0,0x80,0x41
00015c  00c18140          DCB      0x00,0xc1,0x81,0x40
000160  00c18140          DCB      0x00,0xc1,0x81,0x40
000164  01c08041          DCB      0x01,0xc0,0x80,0x41
000168  01c08041          DCB      0x01,0xc0,0x80,0x41
00016c  00c18140          DCB      0x00,0xc1,0x81,0x40
000170  01c08041          DCB      0x01,0xc0,0x80,0x41
000174  00c18140          DCB      0x00,0xc1,0x81,0x40
000178  00c18140          DCB      0x00,0xc1,0x81,0x40
00017c  01c08041          DCB      0x01,0xc0,0x80,0x41
000180  01c08041          DCB      0x01,0xc0,0x80,0x41
000184  00c18140          DCB      0x00,0xc1,0x81,0x40
000188  00c18140          DCB      0x00,0xc1,0x81,0x40
00018c  01c08041          DCB      0x01,0xc0,0x80,0x41
000190  00c18140          DCB      0x00,0xc1,0x81,0x40
000194  01c08041          DCB      0x01,0xc0,0x80,0x41
000198  01c08041          DCB      0x01,0xc0,0x80,0x41
00019c  00c18140          DCB      0x00,0xc1,0x81,0x40
0001a0  00c18140          DCB      0x00,0xc1,0x81,0x40
0001a4  01c08041          DCB      0x01,0xc0,0x80,0x41
0001a8  01c08041          DCB      0x01,0xc0,0x80,0x41
0001ac  00c18140          DCB      0x00,0xc1,0x81,0x40
0001b0  01c08041          DCB      0x01,0xc0,0x80,0x41
0001b4  00c18140          DCB      0x00,0xc1,0x81,0x40
0001b8  00c18140          DCB      0x00,0xc1,0x81,0x40
0001bc  01c08041          DCB      0x01,0xc0,0x80,0x41
0001c0  00c18140          DCB      0x00,0xc1,0x81,0x40
0001c4  01c08041          DCB      0x01,0xc0,0x80,0x41
0001c8  01c08041          DCB      0x01,0xc0,0x80,0x41
0001cc  00c18140          DCB      0x00,0xc1,0x81,0x40
0001d0  01c08041          DCB      0x01,0xc0,0x80,0x41
0001d4  00c18140          DCB      0x00,0xc1,0x81,0x40
0001d8  00c18140          DCB      0x00,0xc1,0x81,0x40
0001dc  01c08041          DCB      0x01,0xc0,0x80,0x41
0001e0  01c08041          DCB      0x01,0xc0,0x80,0x41
0001e4  00c18140          DCB      0x00,0xc1,0x81,0x40
0001e8  00c18140          DCB      0x00,0xc1,0x81,0x40
0001ec  01c08041          DCB      0x01,0xc0,0x80,0x41
0001f0  00c18140          DCB      0x00,0xc1,0x81,0x40
0001f4  01c08041          DCB      0x01,0xc0,0x80,0x41
0001f8  01c08041          DCB      0x01,0xc0,0x80,0x41
0001fc  00c18140          DCB      0x00,0xc1,0x81,0x40
000200  00c0c101          DCB      0x00,0xc0,0xc1,0x01
000204  c30302c2          DCB      0xc3,0x03,0x02,0xc2
000208  c60607c7          DCB      0xc6,0x06,0x07,0xc7
00020c  05c5c404          DCB      0x05,0xc5,0xc4,0x04
000210  cc0c0dcd          DCB      0xcc,0x0c,0x0d,0xcd
000214  0fcfce0e          DCB      0x0f,0xcf,0xce,0x0e
000218  0acacb0b          DCB      0x0a,0xca,0xcb,0x0b
00021c  c90908c8          DCB      0xc9,0x09,0x08,0xc8
000220  d81819d9          DCB      0xd8,0x18,0x19,0xd9
000224  1bdbda1a          DCB      0x1b,0xdb,0xda,0x1a
000228  1ededf1f          DCB      0x1e,0xde,0xdf,0x1f
00022c  dd1d1cdc          DCB      0xdd,0x1d,0x1c,0xdc
000230  14d4d515          DCB      0x14,0xd4,0xd5,0x15
000234  d71716d6          DCB      0xd7,0x17,0x16,0xd6
000238  d21213d3          DCB      0xd2,0x12,0x13,0xd3
00023c  11d1d010          DCB      0x11,0xd1,0xd0,0x10
000240  f03031f1          DCB      0xf0,0x30,0x31,0xf1
000244  33f3f232          DCB      0x33,0xf3,0xf2,0x32
000248  36f6f737          DCB      0x36,0xf6,0xf7,0x37
00024c  f53534f4          DCB      0xf5,0x35,0x34,0xf4
000250  3cfcfd3d          DCB      0x3c,0xfc,0xfd,0x3d
000254  ff3f3efe          DCB      0xff,0x3f,0x3e,0xfe
000258  fa3a3bfb          DCB      0xfa,0x3a,0x3b,0xfb
00025c  39f9f838          DCB      0x39,0xf9,0xf8,0x38
000260  28e8e929          DCB      0x28,0xe8,0xe9,0x29
000264  eb2b2aea          DCB      0xeb,0x2b,0x2a,0xea
000268  ee2e2fef          DCB      0xee,0x2e,0x2f,0xef
00026c  2dedec2c          DCB      0x2d,0xed,0xec,0x2c
000270  e42425e5          DCB      0xe4,0x24,0x25,0xe5
000274  27e7e626          DCB      0x27,0xe7,0xe6,0x26
000278  22e2e323          DCB      0x22,0xe2,0xe3,0x23
00027c  e12120e0          DCB      0xe1,0x21,0x20,0xe0
000280  a06061a1          DCB      0xa0,0x60,0x61,0xa1
000284  63a3a262          DCB      0x63,0xa3,0xa2,0x62
000288  66a6a767          DCB      0x66,0xa6,0xa7,0x67
00028c  a56564a4          DCB      0xa5,0x65,0x64,0xa4
000290  6cacad6d          DCB      0x6c,0xac,0xad,0x6d
000294  af6f6eae          DCB      0xaf,0x6f,0x6e,0xae
000298  aa6a6bab          DCB      0xaa,0x6a,0x6b,0xab
00029c  69a9a868          DCB      0x69,0xa9,0xa8,0x68
0002a0  78b8b979          DCB      0x78,0xb8,0xb9,0x79
0002a4  bb7b7aba          DCB      0xbb,0x7b,0x7a,0xba
0002a8  be7e7fbf          DCB      0xbe,0x7e,0x7f,0xbf
0002ac  7dbdbc7c          DCB      0x7d,0xbd,0xbc,0x7c
0002b0  b47475b5          DCB      0xb4,0x74,0x75,0xb5
0002b4  77b7b676          DCB      0x77,0xb7,0xb6,0x76
0002b8  72b2b373          DCB      0x72,0xb2,0xb3,0x73
0002bc  b17170b0          DCB      0xb1,0x71,0x70,0xb0
0002c0  50909151          DCB      0x50,0x90,0x91,0x51
0002c4  93535292          DCB      0x93,0x53,0x52,0x92
0002c8  96565797          DCB      0x96,0x56,0x57,0x97
0002cc  55959454          DCB      0x55,0x95,0x94,0x54
0002d0  9c5c5d9d          DCB      0x9c,0x5c,0x5d,0x9d
0002d4  5f9f9e5e          DCB      0x5f,0x9f,0x9e,0x5e
0002d8  5a9a9b5b          DCB      0x5a,0x9a,0x9b,0x5b
0002dc  99595898          DCB      0x99,0x59,0x58,0x98
0002e0  88484989          DCB      0x88,0x48,0x49,0x89
0002e4  4b8b8a4a          DCB      0x4b,0x8b,0x8a,0x4a
0002e8  4e8e8f4f          DCB      0x4e,0x8e,0x8f,0x4f
0002ec  8d4d4c8c          DCB      0x8d,0x4d,0x4c,0x8c
0002f0  44848545          DCB      0x44,0x84,0x85,0x45
0002f4  87474686          DCB      0x87,0x47,0x46,0x86
0002f8  82424383          DCB      0x82,0x42,0x43,0x83
0002fc  41818040          DCB      0x41,0x81,0x80,0x40

                          AREA ||.data||, DATA, ALIGN=2

                  RMP_Bitmap
                          DCD      0x00000000
                  RMP_Sched_Lock_Cnt
                          DCD      0x00000000
                  RMP_Sched_Locked
                          DCD      0x00000000
                  RMP_Sched_Pend
                          DCD      0x00000000
                  RMP_Timer_Pend
                          DCD      0x00000000
                  RMP_Tick
                          DCD      0x00000000
                  RMP_Cur_Thd
                          DCD      0x00000000
                  RMP_Cur_SP
                          DCD      0x00000000
                  RMP_Delay
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\..\\MProkaron\\Kernel\\rmp_kernel.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_rmp_kernel_c_346ad0e8____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_L0_V1.10.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___12_rmp_kernel_c_346ad0e8____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_rmp_kernel_c_346ad0e8____REVSH|
#line 402
|__asm___12_rmp_kernel_c_346ad0e8____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
