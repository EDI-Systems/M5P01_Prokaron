; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f7xx_hal_rcc.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f7xx_hal_rcc.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc\Conf -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f7xx_hal_rcc.crf ..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_rcc.c]
                          THUMB

                          AREA ||i.HAL_RCC_CSSCallback||, CODE, READONLY, ALIGN=1

                  HAL_RCC_CSSCallback PROC
;;;1212     */
;;;1213   __weak void HAL_RCC_CSSCallback(void)
000000  4770              BX       lr
;;;1214   {
;;;1215     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1216               the HAL_RCC_CSSCallback could be implemented in the user file
;;;1217      */
;;;1218   }
;;;1219   
                          ENDP


                          AREA ||i.HAL_RCC_ClockConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_ClockConfig PROC
;;;718      */
;;;719    HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
000000  2800              CMP      r0,#0
;;;720    {
;;;721      uint32_t tickstart = 0;
;;;722    
;;;723      /* Check Null pointer */
;;;724      if(RCC_ClkInitStruct == NULL)
;;;725      {
;;;726        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;727      }
;;;728    
;;;729      /* Check the parameters */
;;;730      assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
;;;731      assert_param(IS_FLASH_LATENCY(FLatency));
;;;732    
;;;733      /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
;;;734         must be correctly programmed according to the frequency of the CPU clock
;;;735         (HCLK) and the supply voltage of the device. */
;;;736    
;;;737      /* Increasing the CPU frequency */
;;;738      if(FLatency > __HAL_FLASH_GET_LATENCY())
;;;739      {
;;;740        /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
;;;741        __HAL_FLASH_SET_LATENCY(FLatency);
;;;742    
;;;743        /* Check that the new number of wait states is taken into account to access the Flash
;;;744        memory by reading the FLASH_ACR register */
;;;745        if(__HAL_FLASH_GET_LATENCY() != FLatency)
;;;746        {
;;;747          return HAL_ERROR;
;;;748        }
;;;749      }
;;;750    
;;;751      /*-------------------------- HCLK Configuration --------------------------*/
;;;752      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
;;;753      {
;;;754        /* Set the highest APBx dividers in order to ensure that we do not go through
;;;755           a non-spec phase whatever we decrease or increase HCLK. */
;;;756        if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
;;;757        {
;;;758          MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
;;;759        }
;;;760    
;;;761        if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
;;;762        {
;;;763          MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
;;;764        }
;;;765    
;;;766        /* Set the new HCLK clock divider */
;;;767        assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
;;;768        MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
;;;769      }
;;;770    
;;;771      /*------------------------- SYSCLK Configuration ---------------------------*/
;;;772      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
;;;773      {
;;;774        assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
;;;775    
;;;776        /* HSE is selected as System Clock Source */
;;;777        if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
;;;778        {
;;;779          /* Check the HSE ready flag */
;;;780          if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
;;;781          {
;;;782            return HAL_ERROR;
;;;783          }
;;;784        }
;;;785        /* PLL is selected as System Clock Source */
;;;786        else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
;;;787        {
;;;788          /* Check the PLL ready flag */
;;;789          if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
;;;790          {
;;;791            return HAL_ERROR;
;;;792          }
;;;793        }
;;;794        /* HSI is selected as System Clock Source */
;;;795        else
;;;796        {
;;;797          /* Check the HSI ready flag */
;;;798          if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
;;;799          {
;;;800            return HAL_ERROR;
;;;801          }
;;;802        }
;;;803    
;;;804        __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
;;;805    
;;;806        /* Get Start Tick*/
;;;807        tickstart = HAL_GetTick();
;;;808    
;;;809        while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
;;;810        {
;;;811          if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
;;;812          {
;;;813            return HAL_TIMEOUT;
;;;814          }
;;;815        }
;;;816      }
;;;817    
;;;818      /* Decreasing the number of wait states because of lower CPU frequency */
;;;819      if(FLatency < __HAL_FLASH_GET_LATENCY())
;;;820      {
;;;821        /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
;;;822        __HAL_FLASH_SET_LATENCY(FLatency);
;;;823    
;;;824        /* Check that the new number of wait states is taken into account to access the Flash
;;;825        memory by reading the FLASH_ACR register */
;;;826        if(__HAL_FLASH_GET_LATENCY() != FLatency)
;;;827        {
;;;828          return HAL_ERROR;
;;;829        }
;;;830      }
;;;831    
;;;832      /*-------------------------- PCLK1 Configuration ---------------------------*/
;;;833      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
;;;834      {
;;;835        assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
;;;836        MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
;;;837      }
;;;838    
;;;839      /*-------------------------- PCLK2 Configuration ---------------------------*/
;;;840      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
;;;841      {
;;;842        assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
;;;843        MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
;;;844      }
;;;845    
;;;846      /* Update the SystemCoreClock global variable */
;;;847      SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
;;;848    
;;;849      /* Configure the source of time base considering new system clocks settings*/
;;;850      HAL_InitTick (TICK_INT_PRIORITY);
;;;851    
;;;852      return HAL_OK;
;;;853    }
000006  4770              BXEQ     lr
000008  e92d47f0          PUSH     {r4-r10,lr}           ;720
00000c  f8df819c          LDR      r8,|L2.428|
000010  4604              MOV      r4,r0                 ;720
000012  460e              MOV      r6,r1                 ;720
000014  f8d80000          LDR      r0,[r8,#0]            ;738
000018  f000000f          AND      r0,r0,#0xf            ;738
00001c  42b0              CMP      r0,r6                 ;738
00001e  d20c              BCS      |L2.58|
000020  f8d80000          LDR      r0,[r8,#0]            ;741
000024  f020000f          BIC      r0,r0,#0xf            ;741
000028  4330              ORRS     r0,r0,r6              ;741
00002a  f8c80000          STR      r0,[r8,#0]            ;741
00002e  f8d80000          LDR      r0,[r8,#0]            ;745
000032  f000000f          AND      r0,r0,#0xf            ;745
000036  42b0              CMP      r0,r6                 ;745
000038  d165              BNE      |L2.262|
                  |L2.58|
00003a  6820              LDR      r0,[r4,#0]            ;752
00003c  4d5c              LDR      r5,|L2.432|
00003e  f0100f02          TST      r0,#2                 ;752
000042  d014              BEQ      |L2.110|
000044  f0100f04          TST      r0,#4                 ;756
000048  d003              BEQ      |L2.82|
00004a  6828              LDR      r0,[r5,#0]            ;758
00004c  f44050e0          ORR      r0,r0,#0x1c00         ;758
000050  6028              STR      r0,[r5,#0]            ;758
                  |L2.82|
000052  7820              LDRB     r0,[r4,#0]            ;761
000054  f0100f08          TST      r0,#8                 ;761
000058  d003              BEQ      |L2.98|
00005a  6828              LDR      r0,[r5,#0]            ;763
00005c  f4404060          ORR      r0,r0,#0xe000         ;763
000060  6028              STR      r0,[r5,#0]            ;763
                  |L2.98|
000062  68a0              LDR      r0,[r4,#8]            ;768
000064  6829              LDR      r1,[r5,#0]            ;768
000066  f02101f0          BIC      r1,r1,#0xf0           ;768
00006a  4308              ORRS     r0,r0,r1              ;768
00006c  6028              STR      r0,[r5,#0]            ;768
                  |L2.110|
00006e  7820              LDRB     r0,[r4,#0]            ;772
000070  f0100f01          TST      r0,#1                 ;772
000074  d034              BEQ      |L2.224|
000076  6860              LDR      r0,[r4,#4]            ;777
000078  494e              LDR      r1,|L2.436|
00007a  2801              CMP      r0,#1                 ;777
00007c  d020              BEQ      |L2.192|
00007e  6809              LDR      r1,[r1,#0]            ;798
000080  2802              CMP      r0,#2                 ;786
000082  d022              BEQ      |L2.202|
000084  f0110f02          TST      r1,#2                 ;798
000088  d03d              BEQ      |L2.262|
                  |L2.138|
00008a  6829              LDR      r1,[r5,#0]            ;804
00008c  f0210103          BIC      r1,r1,#3              ;804
000090  4308              ORRS     r0,r0,r1              ;804
000092  6028              STR      r0,[r5,#0]            ;804
000094  f7fffffe          BL       HAL_GetTick
000098  6829              LDR      r1,[r5,#0]            ;809
00009a  4607              MOV      r7,r0                 ;807
00009c  6860              LDR      r0,[r4,#4]            ;809
00009e  f001010c          AND      r1,r1,#0xc            ;809
0000a2  ebb10f80          CMP      r1,r0,LSL #2          ;809
0000a6  bf18              IT       NE                    ;811
0000a8  f2413988          MOVNE    r9,#0x1388            ;811
0000ac  d018              BEQ      |L2.224|
0000ae  bf00              NOP                            ;811
                  |L2.176|
0000b0  f7fffffe          BL       HAL_GetTick
0000b4  1bc0              SUBS     r0,r0,r7              ;811
0000b6  4548              CMP      r0,r9                 ;811
0000b8  d90b              BLS      |L2.210|
0000ba  2003              MOVS     r0,#3                 ;813
0000bc  e8bd87f0          POP      {r4-r10,pc}
                  |L2.192|
0000c0  6809              LDR      r1,[r1,#0]            ;780
0000c2  f4113f00          TST      r1,#0x20000           ;780
0000c6  d1e0              BNE      |L2.138|
0000c8  e01d              B        |L2.262|
                  |L2.202|
0000ca  f0117f00          TST      r1,#0x2000000         ;789
0000ce  d1dc              BNE      |L2.138|
0000d0  e019              B        |L2.262|
                  |L2.210|
0000d2  6861              LDR      r1,[r4,#4]            ;809
0000d4  6828              LDR      r0,[r5,#0]            ;809
0000d6  f000000c          AND      r0,r0,#0xc            ;809
0000da  ebb00f81          CMP      r0,r1,LSL #2          ;809
0000de  d1e7              BNE      |L2.176|
                  |L2.224|
0000e0  f8d80000          LDR      r0,[r8,#0]            ;819
0000e4  f000000f          AND      r0,r0,#0xf            ;819
0000e8  42b0              CMP      r0,r6                 ;819
0000ea  d90f              BLS      |L2.268|
0000ec  f8d80000          LDR      r0,[r8,#0]            ;822
0000f0  f020000f          BIC      r0,r0,#0xf            ;822
0000f4  4330              ORRS     r0,r0,r6              ;822
0000f6  f8c80000          STR      r0,[r8,#0]            ;822
0000fa  f8d80000          LDR      r0,[r8,#0]            ;826
0000fe  f000000f          AND      r0,r0,#0xf            ;826
000102  42b0              CMP      r0,r6                 ;826
000104  d002              BEQ      |L2.268|
                  |L2.262|
000106  2001              MOVS     r0,#1                 ;828
000108  e8bd87f0          POP      {r4-r10,pc}
                  |L2.268|
00010c  7820              LDRB     r0,[r4,#0]            ;833
00010e  f0100f04          TST      r0,#4                 ;833
000112  d005              BEQ      |L2.288|
000114  68e0              LDR      r0,[r4,#0xc]          ;836
000116  6829              LDR      r1,[r5,#0]            ;836
000118  f42151e0          BIC      r1,r1,#0x1c00         ;836
00011c  4308              ORRS     r0,r0,r1              ;836
00011e  6028              STR      r0,[r5,#0]            ;836
                  |L2.288|
000120  7820              LDRB     r0,[r4,#0]            ;840
000122  f0100f08          TST      r0,#8                 ;840
000126  d006              BEQ      |L2.310|
000128  6920              LDR      r0,[r4,#0x10]         ;843
00012a  6829              LDR      r1,[r5,#0]            ;843
00012c  f4214160          BIC      r1,r1,#0xe000         ;843
000130  ea4100c0          ORR      r0,r1,r0,LSL #3       ;843
000134  6028              STR      r0,[r5,#0]            ;843
                  |L2.310|
000136  4820              LDR      r0,|L2.440|
000138  6829              LDR      r1,[r5,#0]            ;843
00013a  f011020c          ANDS     r2,r1,#0xc            ;843
00013e  d026              BEQ      |L2.398|
000140  491e              LDR      r1,|L2.444|
000142  2a04              CMP      r2,#4                 ;843
000144  bf08              IT       EQ                    ;843
000146  4608              MOVEQ    r0,r1                 ;843
000148  d021              BEQ      |L2.398|
00014a  2a08              CMP      r2,#8                 ;843
00014c  d11f              BNE      |L2.398|
00014e  4c1c              LDR      r4,|L2.448|
000150  6822              LDR      r2,[r4,#0]            ;843
000152  6823              LDR      r3,[r4,#0]            ;843
000154  f002023f          AND      r2,r2,#0x3f           ;843
000158  f4130f80          TST      r3,#0x400000          ;843
00015c  d008              BEQ      |L2.368|
00015e  6820              LDR      r0,[r4,#0]            ;843
000160  2300              MOVS     r3,#0                 ;843
000162  f3c01088          UBFX     r0,r0,#6,#9           ;843
000166  fba00101          UMULL    r0,r1,r0,r1           ;843
00016a  f7fffffe          BL       __aeabi_uldivmod
00016e  e007              B        |L2.384|
                  |L2.368|
000170  6821              LDR      r1,[r4,#0]            ;843
000172  2300              MOVS     r3,#0                 ;843
000174  f3c11188          UBFX     r1,r1,#6,#9           ;843
000178  fba10100          UMULL    r0,r1,r1,r0           ;843
00017c  f7fffffe          BL       __aeabi_uldivmod
                  |L2.384|
000180  6821              LDR      r1,[r4,#0]            ;843
000182  f3c14101          UBFX     r1,r1,#16,#2          ;843
000186  1c49              ADDS     r1,r1,#1              ;843
000188  0049              LSLS     r1,r1,#1              ;843
00018a  fbb0f0f1          UDIV     r0,r0,r1              ;843
                  |L2.398|
00018e  6829              LDR      r1,[r5,#0]            ;847
000190  4a0c              LDR      r2,|L2.452|
000192  f3c11103          UBFX     r1,r1,#4,#4           ;847
000196  5c51              LDRB     r1,[r2,r1]            ;847
000198  40c8              LSRS     r0,r0,r1              ;847
00019a  490b              LDR      r1,|L2.456|
00019c  6008              STR      r0,[r1,#0]            ;850  ; SystemCoreClock
00019e  200f              MOVS     r0,#0xf               ;850
0001a0  f7fffffe          BL       HAL_InitTick
0001a4  2000              MOVS     r0,#0                 ;852
0001a6  e8bd87f0          POP      {r4-r10,pc}
;;;854    
                          ENDP

0001aa  0000              DCW      0x0000
                  |L2.428|
                          DCD      0x40023c00
                  |L2.432|
                          DCD      0x40023808
                  |L2.436|
                          DCD      0x40023800
                  |L2.440|
                          DCD      0x00f42400
                  |L2.444|
                          DCD      0x017d7840
                  |L2.448|
                          DCD      0x40023804
                  |L2.452|
                          DCD      AHBPrescTable
                  |L2.456|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_RCC_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_RCC_DeInit PROC
;;;213      */
;;;214    HAL_StatusTypeDef HAL_RCC_DeInit(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;215    {
;;;216      uint32_t tickstart;
;;;217    
;;;218      /* Get Start Tick */
;;;219      tickstart = HAL_GetTick();
000004  f7fffffe          BL       HAL_GetTick
;;;220    
;;;221      /* Set HSION bit to the reset value */
;;;222      SET_BIT(RCC->CR, RCC_CR_HSION);
000008  4c53              LDR      r4,|L3.344|
00000a  4605              MOV      r5,r0                 ;219
00000c  6820              LDR      r0,[r4,#0]
00000e  f0400001          ORR      r0,r0,#1
000012  6020              STR      r0,[r4,#0]
;;;223    
;;;224      /* Wait till HSI is ready */
;;;225      while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == RESET)
000014  6820              LDR      r0,[r4,#0]
000016  f0100f02          TST      r0,#2
00001a  d108              BNE      |L3.46|
                  |L3.28|
;;;226      {
;;;227        if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
00001c  f7fffffe          BL       HAL_GetTick
000020  1b40              SUBS     r0,r0,r5
000022  2802              CMP      r0,#2
000024  d869              BHI      |L3.250|
000026  6820              LDR      r0,[r4,#0]            ;225
000028  f0100f02          TST      r0,#2                 ;225
00002c  d0f6              BEQ      |L3.28|
                  |L3.46|
;;;228        {
;;;229          return HAL_TIMEOUT;
;;;230        }
;;;231      }
;;;232    
;;;233      /* Set HSITRIM[4:0] bits to the reset value */
;;;234      SET_BIT(RCC->CR, RCC_CR_HSITRIM_4);
00002e  6820              LDR      r0,[r4,#0]
000030  f0400080          ORR      r0,r0,#0x80
000034  6020              STR      r0,[r4,#0]
;;;235    
;;;236      /* Get Start Tick */
;;;237      tickstart = HAL_GetTick();
000036  f7fffffe          BL       HAL_GetTick
;;;238    
;;;239      /* Reset CFGR register */
;;;240      CLEAR_REG(RCC->CFGR);
00003a  4e48              LDR      r6,|L3.348|
00003c  4605              MOV      r5,r0                 ;237
00003e  2000              MOVS     r0,#0
000040  6030              STR      r0,[r6,#0]
;;;241    
;;;242      /* Wait till clock switch is ready */
;;;243      while (READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != RESET)
000042  6830              LDR      r0,[r6,#0]
000044  f0100f0c          TST      r0,#0xc
;;;244      {
;;;245        if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
000048  bf18              IT       NE
00004a  f2413788          MOVNE    r7,#0x1388
00004e  d008              BEQ      |L3.98|
                  |L3.80|
000050  f7fffffe          BL       HAL_GetTick
000054  1b40              SUBS     r0,r0,r5
000056  42b8              CMP      r0,r7
000058  d84f              BHI      |L3.250|
00005a  6830              LDR      r0,[r6,#0]            ;243
00005c  f0100f0c          TST      r0,#0xc               ;243
000060  d1f6              BNE      |L3.80|
                  |L3.98|
;;;246        {
;;;247          return HAL_TIMEOUT;
;;;248        }
;;;249      }
;;;250    
;;;251      /* Get Start Tick */
;;;252      tickstart = HAL_GetTick();
000062  f7fffffe          BL       HAL_GetTick
000066  4605              MOV      r5,r0
;;;253    
;;;254      /* Clear HSEON, HSEBYP and CSSON bits */
;;;255      CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSEBYP | RCC_CR_CSSON);
000068  6820              LDR      r0,[r4,#0]
00006a  f4202050          BIC      r0,r0,#0xd0000
00006e  6020              STR      r0,[r4,#0]
;;;256    
;;;257      /* Wait till HSE is disabled */
;;;258      while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != RESET)
000070  6820              LDR      r0,[r4,#0]
000072  f4103f00          TST      r0,#0x20000
000076  d008              BEQ      |L3.138|
                  |L3.120|
;;;259      {
;;;260        if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
000078  f7fffffe          BL       HAL_GetTick
00007c  1b40              SUBS     r0,r0,r5
00007e  2864              CMP      r0,#0x64
000080  d83b              BHI      |L3.250|
000082  6820              LDR      r0,[r4,#0]            ;258
000084  f4103f00          TST      r0,#0x20000           ;258
000088  d1f6              BNE      |L3.120|
                  |L3.138|
;;;261        {
;;;262          return HAL_TIMEOUT;
;;;263        }
;;;264      }
;;;265    
;;;266      /* Get Start Tick */
;;;267      tickstart = HAL_GetTick();
00008a  f7fffffe          BL       HAL_GetTick
00008e  4605              MOV      r5,r0
;;;268    
;;;269      /* Clear PLLON bit */
;;;270      CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
000090  6820              LDR      r0,[r4,#0]
000092  f0207080          BIC      r0,r0,#0x1000000
000096  6020              STR      r0,[r4,#0]
;;;271    
;;;272      /* Wait till PLL is disabled */
;;;273      while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RESET)
000098  6820              LDR      r0,[r4,#0]
00009a  f0107f00          TST      r0,#0x2000000
00009e  d008              BEQ      |L3.178|
                  |L3.160|
;;;274      {
;;;275        if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
0000a0  f7fffffe          BL       HAL_GetTick
0000a4  1b40              SUBS     r0,r0,r5
0000a6  2802              CMP      r0,#2
0000a8  d827              BHI      |L3.250|
0000aa  6820              LDR      r0,[r4,#0]            ;273
0000ac  f0107f00          TST      r0,#0x2000000         ;273
0000b0  d1f6              BNE      |L3.160|
                  |L3.178|
;;;276        {
;;;277          return HAL_TIMEOUT;
;;;278        }
;;;279      }
;;;280    
;;;281      /* Get Start Tick */
;;;282      tickstart = HAL_GetTick();
0000b2  f7fffffe          BL       HAL_GetTick
0000b6  4605              MOV      r5,r0
;;;283    
;;;284      /* Reset PLLI2SON bit */
;;;285      CLEAR_BIT(RCC->CR, RCC_CR_PLLI2SON);
0000b8  6820              LDR      r0,[r4,#0]
0000ba  f0206080          BIC      r0,r0,#0x4000000
0000be  6020              STR      r0,[r4,#0]
;;;286    
;;;287      /* Wait till PLLI2S is disabled */
;;;288      while (READ_BIT(RCC->CR, RCC_CR_PLLI2SRDY) != RESET)
0000c0  6820              LDR      r0,[r4,#0]
0000c2  f0106f00          TST      r0,#0x8000000
0000c6  d008              BEQ      |L3.218|
                  |L3.200|
;;;289      {
;;;290        if ((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
0000c8  f7fffffe          BL       HAL_GetTick
0000cc  1b41              SUBS     r1,r0,r5
0000ce  2964              CMP      r1,#0x64
0000d0  d813              BHI      |L3.250|
0000d2  6820              LDR      r0,[r4,#0]            ;288
0000d4  f0106f00          TST      r0,#0x8000000         ;288
0000d8  d1f6              BNE      |L3.200|
                  |L3.218|
;;;291        {
;;;292          return HAL_TIMEOUT;
;;;293        }
;;;294      }
;;;295    
;;;296      /* Get Start Tick */
;;;297      tickstart = HAL_GetTick();
0000da  f7fffffe          BL       HAL_GetTick
0000de  4605              MOV      r5,r0
;;;298    
;;;299      /* Reset PLLSAI bit */
;;;300      CLEAR_BIT(RCC->CR, RCC_CR_PLLSAION);
0000e0  6820              LDR      r0,[r4,#0]
0000e2  f0205080          BIC      r0,r0,#0x10000000
0000e6  6020              STR      r0,[r4,#0]
;;;301    
;;;302      /* Wait till PLLSAI is disabled */
;;;303      while (READ_BIT(RCC->CR, RCC_CR_PLLSAIRDY) != RESET)
0000e8  6820              LDR      r0,[r4,#0]
0000ea  f0105f00          TST      r0,#0x20000000
0000ee  d00b              BEQ      |L3.264|
                  |L3.240|
;;;304      {
;;;305        if ((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
0000f0  f7fffffe          BL       HAL_GetTick
0000f4  1b40              SUBS     r0,r0,r5
0000f6  2864              CMP      r0,#0x64
0000f8  d902              BLS      |L3.256|
                  |L3.250|
;;;306        {
;;;307          return HAL_TIMEOUT;
0000fa  2003              MOVS     r0,#3
;;;308        }
;;;309      }
;;;310    
;;;311      /* Once PLL, PLLI2S and PLLSAI are OFF, reset PLLCFGR register to default value */
;;;312      RCC->PLLCFGR = RCC_PLLCFGR_PLLM_4 | RCC_PLLCFGR_PLLN_6 | RCC_PLLCFGR_PLLN_7 | RCC_PLLCFGR_PLLQ_2 | 0x20000000U;
;;;313    
;;;314      /* Reset PLLI2SCFGR register to default value */
;;;315      RCC->PLLI2SCFGR = RCC_PLLI2SCFGR_PLLI2SN_6 | RCC_PLLI2SCFGR_PLLI2SN_7 | RCC_PLLI2SCFGR_PLLI2SQ_2 | RCC_PLLI2SCFGR_PLLI2SR_1;
;;;316    
;;;317      /* Reset PLLSAICFGR register to default value */
;;;318      RCC->PLLSAICFGR = RCC_PLLSAICFGR_PLLSAIN_6 | RCC_PLLSAICFGR_PLLSAIN_7 | RCC_PLLSAICFGR_PLLSAIQ_2 | 0x20000000U;
;;;319    
;;;320      /* Disable all interrupts */
;;;321      CLEAR_BIT(RCC->CIR, RCC_CIR_LSIRDYIE | RCC_CIR_LSERDYIE | RCC_CIR_HSIRDYIE | RCC_CIR_HSERDYIE | RCC_CIR_PLLRDYIE | RCC_CIR_PLLI2SRDYIE | RCC_CIR_PLLSAIRDYIE);
;;;322    
;;;323      /* Clear all interrupt flags */
;;;324      SET_BIT(RCC->CIR, RCC_CIR_LSIRDYC | RCC_CIR_LSERDYC | RCC_CIR_HSIRDYC | RCC_CIR_HSERDYC | RCC_CIR_PLLRDYC | RCC_CIR_PLLI2SRDYC | RCC_CIR_PLLSAIRDYC | RCC_CIR_CSSC);
;;;325    
;;;326      /* Clear LSION bit */
;;;327      CLEAR_BIT(RCC->CSR, RCC_CSR_LSION);
;;;328    
;;;329      /* Reset all CSR flags */
;;;330      SET_BIT(RCC->CSR, RCC_CSR_RMVF);
;;;331    
;;;332      /* Update the SystemCoreClock global variable */
;;;333      SystemCoreClock = HSI_VALUE;
;;;334    
;;;335      /* Adapt Systick interrupt period */
;;;336      if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
;;;337      {
;;;338        return HAL_ERROR;
;;;339      }
;;;340      else
;;;341      {
;;;342        return HAL_OK;
;;;343      }
;;;344    }
0000fc  e8bd81f0          POP      {r4-r8,pc}
                  |L3.256|
000100  6820              LDR      r0,[r4,#0]            ;303
000102  f0105f00          TST      r0,#0x20000000        ;303
000106  d1f3              BNE      |L3.240|
                  |L3.264|
000108  4b18              LDR      r3,|L3.364|
00010a  f8dfc064          LDR      r12,|L3.368|
00010e  4814              LDR      r0,|L3.352|
000110  4914              LDR      r1,|L3.356|
000112  f10c0404          ADD      r4,r12,#4             ;318
000116  4a14              LDR      r2,|L3.360|
000118  601a              STR      r2,[r3,#0]            ;312
00011a  f8cc0000          STR      r0,[r12,#0]           ;315
00011e  6020              STR      r0,[r4,#0]            ;318
000120  680a              LDR      r2,[r1,#0]            ;321
000122  4814              LDR      r0,|L3.372|
000124  f42242fe          BIC      r2,r2,#0x7f00         ;321
000128  600a              STR      r2,[r1,#0]            ;321
00012a  680b              LDR      r3,[r1,#0]            ;324
00012c  4a12              LDR      r2,|L3.376|
00012e  f443037f          ORR      r3,r3,#0xff0000       ;324
000132  600b              STR      r3,[r1,#0]            ;324
000134  6801              LDR      r1,[r0,#0]            ;327
000136  f0210101          BIC      r1,r1,#1              ;327
00013a  6001              STR      r1,[r0,#0]            ;327
00013c  6801              LDR      r1,[r0,#0]            ;330
00013e  f0417180          ORR      r1,r1,#0x1000000      ;330
000142  6001              STR      r1,[r0,#0]            ;330
000144  480d              LDR      r0,|L3.380|
000146  6002              STR      r2,[r0,#0]            ;336  ; SystemCoreClock
000148  200f              MOVS     r0,#0xf               ;336
00014a  f7fffffe          BL       HAL_InitTick
00014e  2800              CMP      r0,#0                 ;336
000150  bf18              IT       NE                    ;338
000152  2001              MOVNE    r0,#1                 ;338
000154  e8bd81f0          POP      {r4-r8,pc}
;;;345    
                          ENDP

                  |L3.344|
                          DCD      0x40023800
                  |L3.348|
                          DCD      0x40023808
                  |L3.352|
                          DCD      0x24003000
                  |L3.356|
                          DCD      0x4002380c
                  |L3.360|
                          DCD      0x24003010
                  |L3.364|
                          DCD      0x40023804
                  |L3.368|
                          DCD      0x40023884
                  |L3.372|
                          DCD      0x40023874
                  |L3.376|
                          DCD      0x00f42400
                  |L3.380|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_RCC_DisableCSS||, CODE, READONLY, ALIGN=2

                  HAL_RCC_DisableCSS PROC
;;;962      */
;;;963    void HAL_RCC_DisableCSS(void)
000000  4802              LDR      r0,|L4.12|
;;;964    {
;;;965      CLEAR_BIT(RCC->CR, RCC_CR_CSSON);
000002  6801              LDR      r1,[r0,#0]
000004  f4212100          BIC      r1,r1,#0x80000
000008  6001              STR      r1,[r0,#0]
;;;966    }
00000a  4770              BX       lr
;;;967    
                          ENDP

                  |L4.12|
                          DCD      0x40023800

                          AREA ||i.HAL_RCC_EnableCSS||, CODE, READONLY, ALIGN=2

                  HAL_RCC_EnableCSS PROC
;;;953      */
;;;954    void HAL_RCC_EnableCSS(void)
000000  4802              LDR      r0,|L5.12|
;;;955    {
;;;956      SET_BIT(RCC->CR, RCC_CR_CSSON);
000002  6801              LDR      r1,[r0,#0]
000004  f4412100          ORR      r1,r1,#0x80000
000008  6001              STR      r1,[r0,#0]
;;;957    }
00000a  4770              BX       lr
;;;958    
                          ENDP

                  |L5.12|
                          DCD      0x40023800

                          AREA ||i.HAL_RCC_GetClockConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetClockConfig PROC
;;;1169     */
;;;1170   void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
000000  4a0f              LDR      r2,|L6.64|
;;;1171   {
;;;1172     /* Set all possible values for the Clock type parameter --------------------*/
;;;1173     RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
000002  230f              MOVS     r3,#0xf
000004  f84d4d04          PUSH.W   {r4}                  ;1171
;;;1174   
;;;1175     /* Get the SYSCLK configuration --------------------------------------------*/
;;;1176     RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
;;;1177   
;;;1178     /* Get the HCLK configuration ----------------------------------------------*/
;;;1179     RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);
;;;1180   
;;;1181     /* Get the APB1 configuration ----------------------------------------------*/
;;;1182     RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);
;;;1183   
;;;1184     /* Get the APB2 configuration ----------------------------------------------*/
;;;1185     RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
;;;1186   
;;;1187     /* Get the Flash Wait State (Latency) configuration ------------------------*/
;;;1188     *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
000008  6003              STR      r3,[r0,#0]
;;;1189   }
00000a  f44f5ce0          MOV      r12,#0x1c00
00000e  4b0d              LDR      r3,|L6.68|
000010  6814              LDR      r4,[r2,#0]            ;1176
000012  f0040403          AND      r4,r4,#3              ;1176
000016  6044              STR      r4,[r0,#4]            ;1179
000018  6814              LDR      r4,[r2,#0]            ;1179
00001a  f00404f0          AND      r4,r4,#0xf0           ;1179
00001e  6084              STR      r4,[r0,#8]            ;1182
000020  6814              LDR      r4,[r2,#0]            ;1182
000022  f40454e0          AND      r4,r4,#0x1c00         ;1182
000026  60c4              STR      r4,[r0,#0xc]          ;1185
000028  6812              LDR      r2,[r2,#0]            ;1185
00002a  ea0c02d2          AND      r2,r12,r2,LSR #3
00002e  6102              STR      r2,[r0,#0x10]         ;1188
000030  6818              LDR      r0,[r3,#0]            ;1188
000032  f000000f          AND      r0,r0,#0xf            ;1188
000036  6008              STR      r0,[r1,#0]            ;1188
000038  f85d4b04          POP.W    {r4}
00003c  4770              BX       lr
;;;1190   
                          ENDP

00003e  0000              DCW      0x0000
                  |L6.64|
                          DCD      0x40023808
                  |L6.68|
                          DCD      0x40023c00

                          AREA ||i.HAL_RCC_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetHCLKFreq PROC
;;;1051     */
;;;1052   uint32_t HAL_RCC_GetHCLKFreq(void)
000000  4801              LDR      r0,|L7.8|
;;;1053   {
;;;1054     return SystemCoreClock;
000002  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;1055   }
000004  4770              BX       lr
;;;1056   
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_RCC_GetOscConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetOscConfig PROC
;;;1087     */
;;;1088   void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
000000  4b36              LDR      r3,|L8.220|
;;;1089   {
;;;1090     /* Set all possible values for the Oscillator type parameter ---------------*/
;;;1091     RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI;
000002  210f              MOVS     r1,#0xf
000004  f84d4d04          PUSH.W   {r4}                  ;1089
000008  6001              STR      r1,[r0,#0]
00000a  2100              MOVS     r1,#0
;;;1092   
;;;1093     /* Get the HSE configuration -----------------------------------------------*/
;;;1094     if((RCC->CR &RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
00000c  681a              LDR      r2,[r3,#0]
00000e  f4122f80          TST      r2,#0x40000
;;;1095     {
;;;1096       RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
000012  bf18              IT       NE
000014  f44f22a0          MOVNE    r2,#0x50000
000018  d04e              BEQ      |L8.184|
                  |L8.26|
;;;1097     }
;;;1098     else if((RCC->CR &RCC_CR_HSEON) == RCC_CR_HSEON)
;;;1099     {
;;;1100       RCC_OscInitStruct->HSEState = RCC_HSE_ON;
00001a  6042              STR      r2,[r0,#4]
                  |L8.28|
;;;1101     }
;;;1102     else
;;;1103     {
;;;1104       RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
;;;1105     }
;;;1106   
;;;1107     /* Get the HSI configuration -----------------------------------------------*/
;;;1108     if((RCC->CR &RCC_CR_HSION) == RCC_CR_HSION)
;;;1109     {
;;;1110       RCC_OscInitStruct->HSIState = RCC_HSI_ON;
00001c  2201              MOVS     r2,#1
00001e  f8d3c000          LDR      r12,[r3,#0]           ;1108
000022  f01c0f01          TST      r12,#1                ;1108
000026  bf14              ITE      NE
000028  60c2              STRNE    r2,[r0,#0xc]
;;;1111     }
;;;1112     else
;;;1113     {
;;;1114       RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
00002a  60c1              STREQ    r1,[r0,#0xc]
;;;1115     }
;;;1116   
;;;1117     RCC_OscInitStruct->HSICalibrationValue = (uint32_t)((RCC->CR &RCC_CR_HSITRIM) >> RCC_CR_HSITRIM_Pos);
;;;1118   
;;;1119     /* Get the LSE configuration -----------------------------------------------*/
;;;1120     if((RCC->BDCR &RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
00002c  f8dfc0b0          LDR      r12,|L8.224|
000030  681c              LDR      r4,[r3,#0]            ;1117
000032  f3c404c4          UBFX     r4,r4,#3,#5           ;1117
000036  6104              STR      r4,[r0,#0x10]
000038  f8dc4000          LDR      r4,[r12,#0]
00003c  f0140f04          TST      r4,#4
;;;1121     {
;;;1122       RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
000040  bf1c              ITT      NE
000042  f04f0c05          MOVNE    r12,#5
000046  f8c0c008          STRNE    r12,[r0,#8]
00004a  d03e              BEQ      |L8.202|
                  |L8.76|
;;;1123     }
;;;1124     else if((RCC->BDCR &RCC_BDCR_LSEON) == RCC_BDCR_LSEON)
;;;1125     {
;;;1126       RCC_OscInitStruct->LSEState = RCC_LSE_ON;
;;;1127     }
;;;1128     else
;;;1129     {
;;;1130       RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
;;;1131     }
;;;1132   
;;;1133     /* Get the LSI configuration -----------------------------------------------*/
;;;1134     if((RCC->CSR &RCC_CSR_LSION) == RCC_CSR_LSION)
00004c  f8dfc094          LDR      r12,|L8.228|
000050  f8dcc000          LDR      r12,[r12,#0]
000054  f01c0f01          TST      r12,#1
;;;1135     {
;;;1136       RCC_OscInitStruct->LSIState = RCC_LSI_ON;
000058  bf14              ITE      NE
00005a  6142              STRNE    r2,[r0,#0x14]
;;;1137     }
;;;1138     else
;;;1139     {
;;;1140       RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
00005c  6141              STREQ    r1,[r0,#0x14]
;;;1141     }
;;;1142   
;;;1143     /* Get the PLL configuration -----------------------------------------------*/
;;;1144     if((RCC->CR &RCC_CR_PLLON) == RCC_CR_PLLON)
00005e  6819              LDR      r1,[r3,#0]
000060  f0117f80          TST      r1,#0x1000000
;;;1145     {
;;;1146       RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
000064  bf1a              ITTE     NE
000066  2102              MOVNE    r1,#2
000068  6181              STRNE    r1,[r0,#0x18]
;;;1147     }
;;;1148     else
;;;1149     {
;;;1150       RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
00006a  6182              STREQ    r2,[r0,#0x18]
;;;1151     }
;;;1152     RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
00006c  491e              LDR      r1,|L8.232|
;;;1153     RCC_OscInitStruct->PLL.PLLM = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);
;;;1154     RCC_OscInitStruct->PLL.PLLN = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
;;;1155     RCC_OscInitStruct->PLL.PLLP = (uint32_t)((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) + RCC_PLLCFGR_PLLP_0) << 1) >> RCC_PLLCFGR_PLLP_Pos);
;;;1156     RCC_OscInitStruct->PLL.PLLQ = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLQ) >> RCC_PLLCFGR_PLLQ_Pos);
;;;1157   #if defined (RCC_PLLCFGR_PLLR)
;;;1158     RCC_OscInitStruct->PLL.PLLR = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> POSITION_VAL(RCC_PLLCFGR_PLLR));
00006e  f04f42e0          MOV      r2,#0x70000000
000072  680b              LDR      r3,[r1,#0]            ;1152
000074  fa92f2a2          RBIT     r2,r2
000078  f4030380          AND      r3,r3,#0x400000       ;1152
00007c  61c3              STR      r3,[r0,#0x1c]         ;1153
00007e  680b              LDR      r3,[r1,#0]            ;1153
000080  fab2f282          CLZ      r2,r2
000084  f003033f          AND      r3,r3,#0x3f           ;1153
000088  6203              STR      r3,[r0,#0x20]         ;1154
00008a  680b              LDR      r3,[r1,#0]            ;1154
00008c  f3c31388          UBFX     r3,r3,#6,#9           ;1154
000090  6243              STR      r3,[r0,#0x24]         ;1155
000092  680b              LDR      r3,[r1,#0]            ;1155
000094  f4033340          AND      r3,r3,#0x30000        ;1155
000098  f5033380          ADD      r3,r3,#0x10000        ;1155
00009c  0bdb              LSRS     r3,r3,#15             ;1155
00009e  6283              STR      r3,[r0,#0x28]         ;1156
0000a0  680b              LDR      r3,[r1,#0]            ;1156
0000a2  f3c36303          UBFX     r3,r3,#24,#4          ;1156
0000a6  62c3              STR      r3,[r0,#0x2c]
0000a8  6809              LDR      r1,[r1,#0]
0000aa  f00141e0          AND      r1,r1,#0x70000000
0000ae  40d1              LSRS     r1,r1,r2
0000b0  6301              STR      r1,[r0,#0x30]         ;1134
;;;1159   #endif
;;;1160   }
0000b2  f85d4b04          POP.W    {r4}
0000b6  4770              BX       lr
                  |L8.184|
0000b8  681a              LDR      r2,[r3,#0]            ;1098
0000ba  f4123f80          TST      r2,#0x10000           ;1098
0000be  bf14              ITE      NE                    ;1100
0000c0  f44f3280          MOVNE    r2,#0x10000           ;1100
0000c4  6041              STREQ    r1,[r0,#4]            ;1104
0000c6  d1a8              BNE      |L8.26|
0000c8  e7a8              B        |L8.28|
                  |L8.202|
0000ca  f8dcc000          LDR      r12,[r12,#0]          ;1124
0000ce  f01c0f01          TST      r12,#1                ;1124
0000d2  bf14              ITE      NE                    ;1126
0000d4  6082              STRNE    r2,[r0,#8]            ;1126
0000d6  6081              STREQ    r1,[r0,#8]            ;1130
0000d8  e7b8              B        |L8.76|
;;;1161   
                          ENDP

0000da  0000              DCW      0x0000
                  |L8.220|
                          DCD      0x40023800
                  |L8.224|
                          DCD      0x40023870
                  |L8.228|
                          DCD      0x40023874
                  |L8.232|
                          DCD      0x40023804

                          AREA ||i.HAL_RCC_GetPCLK1Freq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetPCLK1Freq PROC
;;;1062     */
;;;1063   uint32_t HAL_RCC_GetPCLK1Freq(void)
000000  4904              LDR      r1,|L9.20|
000002  4805              LDR      r0,|L9.24|
;;;1064   {
;;;1065     /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
;;;1066     return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
000004  6809              LDR      r1,[r1,#0]
000006  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000008  4a04              LDR      r2,|L9.28|
00000a  f3c12182          UBFX     r1,r1,#10,#3
00000e  5c51              LDRB     r1,[r2,r1]
000010  40c8              LSRS     r0,r0,r1
;;;1067   }
000012  4770              BX       lr
;;;1068   
                          ENDP

                  |L9.20|
                          DCD      0x40023808
                  |L9.24|
                          DCD      SystemCoreClock
                  |L9.28|
                          DCD      APBPrescTable

                          AREA ||i.HAL_RCC_GetPCLK2Freq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetPCLK2Freq PROC
;;;1074     */
;;;1075   uint32_t HAL_RCC_GetPCLK2Freq(void)
000000  4904              LDR      r1,|L10.20|
000002  4805              LDR      r0,|L10.24|
;;;1076   {
;;;1077     /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
;;;1078     return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
000004  6809              LDR      r1,[r1,#0]
000006  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000008  4a04              LDR      r2,|L10.28|
00000a  f3c13142          UBFX     r1,r1,#13,#3
00000e  5c51              LDRB     r1,[r2,r1]
000010  40c8              LSRS     r0,r0,r1
;;;1079   }
000012  4770              BX       lr
;;;1080   
                          ENDP

                  |L10.20|
                          DCD      0x40023808
                  |L10.24|
                          DCD      SystemCoreClock
                  |L10.28|
                          DCD      APBPrescTable

                          AREA ||i.HAL_RCC_GetSysClockFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetSysClockFreq PROC
;;;997      */
;;;998    uint32_t HAL_RCC_GetSysClockFreq(void)
000000  4918              LDR      r1,|L11.100|
;;;999    {
;;;1000     uint32_t pllm = 0, pllvco = 0, pllp = 0;
;;;1001     uint32_t sysclockfreq = 0;
;;;1002   
;;;1003     /* Get SYSCLK source -------------------------------------------------------*/
;;;1004     switch (RCC->CFGR & RCC_CFGR_SWS)
;;;1005     {
;;;1006       case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
;;;1007       {
;;;1008         sysclockfreq = HSI_VALUE;
000002  4819              LDR      r0,|L11.104|
000004  6809              LDR      r1,[r1,#0]            ;1004
000006  f011020c          ANDS     r2,r1,#0xc            ;1004
;;;1009          break;
;;;1010       }
;;;1011       case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */
;;;1012       {
;;;1013         sysclockfreq = HSE_VALUE;
;;;1014         break;
;;;1015       }
;;;1016       case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock  source */
;;;1017       {
;;;1018         /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
;;;1019         SYSCLK = PLL_VCO / PLLP */
;;;1020         pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
;;;1021         if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
;;;1022         {
;;;1023           /* HSE used as PLL clock source */
;;;1024           pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
;;;1025         }
;;;1026         else
;;;1027         {
;;;1028           /* HSI used as PLL clock source */
;;;1029           pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
;;;1030         }
;;;1031         pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1 ) *2);
;;;1032   
;;;1033         sysclockfreq = pllvco/pllp;
;;;1034         break;
;;;1035       }
;;;1036       default:
;;;1037       {
;;;1038         sysclockfreq = HSI_VALUE;
;;;1039         break;
;;;1040       }
;;;1041     }
;;;1042     return sysclockfreq;
;;;1043   }
00000a  bf08              IT       EQ
00000c  4770              BXEQ     lr
00000e  4917              LDR      r1,|L11.108|
000010  2a04              CMP      r2,#4                 ;1004
000012  bf04              ITT      EQ                    ;1013
000014  4608              MOVEQ    r0,r1                 ;1013
000016  4770              BXEQ     lr
000018  2a08              CMP      r2,#8                 ;1004
00001a  bf18              IT       NE
00001c  4770              BXNE     lr
00001e  b510              PUSH     {r4,lr}               ;999
000020  4c13              LDR      r4,|L11.112|
000022  6822              LDR      r2,[r4,#0]            ;1020
000024  6823              LDR      r3,[r4,#0]            ;1021
000026  f002023f          AND      r2,r2,#0x3f           ;1020
00002a  f4130f80          TST      r3,#0x400000          ;1021
00002e  d008              BEQ      |L11.66|
000030  6820              LDR      r0,[r4,#0]            ;1024
000032  2300              MOVS     r3,#0                 ;1024
000034  f3c01088          UBFX     r0,r0,#6,#9           ;1024
000038  fba00101          UMULL    r0,r1,r0,r1           ;1024
00003c  f7fffffe          BL       __aeabi_uldivmod
000040  e007              B        |L11.82|
                  |L11.66|
000042  6821              LDR      r1,[r4,#0]            ;1029
000044  2300              MOVS     r3,#0                 ;1029
000046  f3c11188          UBFX     r1,r1,#6,#9           ;1029
00004a  fba10100          UMULL    r0,r1,r1,r0           ;1029
00004e  f7fffffe          BL       __aeabi_uldivmod
                  |L11.82|
000052  6821              LDR      r1,[r4,#0]            ;1031
000054  f3c14101          UBFX     r1,r1,#16,#2          ;1031
000058  1c49              ADDS     r1,r1,#1              ;1031
00005a  0049              LSLS     r1,r1,#1              ;1031
00005c  fbb0f0f1          UDIV     r0,r0,r1              ;1033
000060  bd10              POP      {r4,pc}
;;;1044   
                          ENDP

000062  0000              DCW      0x0000
                  |L11.100|
                          DCD      0x40023808
                  |L11.104|
                          DCD      0x00f42400
                  |L11.108|
                          DCD      0x017d7840
                  |L11.112|
                          DCD      0x40023804

                          AREA ||i.HAL_RCC_MCOConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_MCOConfig PROC
;;;899      */
;;;900    void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
000000  2800              CMP      r0,#0
;;;901    {
;;;902      GPIO_InitTypeDef GPIO_InitStruct;
;;;903      /* Check the parameters */
;;;904      assert_param(IS_RCC_MCO(RCC_MCOx));
;;;905      assert_param(IS_RCC_MCODIV(RCC_MCODiv));
;;;906      /* RCC_MCO1 */
;;;907      if(RCC_MCOx == RCC_MCO1)
;;;908      {
;;;909        assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));
;;;910    
;;;911        /* MCO1 Clock Enable */
;;;912        MCO1_CLK_ENABLE();
000002  4823              LDR      r0,|L12.144|
000004  b570              PUSH     {r4-r6,lr}            ;901
;;;913    
;;;914        /* Configure the MCO1 pin in alternate function mode */
;;;915        GPIO_InitStruct.Pin = MCO1_PIN;
;;;916        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
;;;917        GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
;;;918        GPIO_InitStruct.Pull = GPIO_NOPULL;
;;;919        GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
;;;920        HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
;;;921    
;;;922        /* Mask MCO1 and MCO1PRE[2:0] bits then Select MCO1 clock source and prescaler */
;;;923        MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), (RCC_MCOSource | RCC_MCODiv));
000006  4c23              LDR      r4,|L12.148|
000008  b086              SUB      sp,sp,#0x18           ;901
;;;924      }
;;;925      else
;;;926      {
;;;927        assert_param(IS_RCC_MCO2SOURCE(RCC_MCOSource));
;;;928    
;;;929        /* MCO2 Clock Enable */
;;;930        MCO2_CLK_ENABLE();
00000a  f8d0c000          LDR      r12,[r0,#0]
00000e  4615              MOV      r5,r2                 ;901
000010  460e              MOV      r6,r1                 ;901
000012  f04f0300          MOV      r3,#0                 ;907
000016  f04f0102          MOV      r1,#2                 ;916
00001a  f04f0203          MOV      r2,#3                 ;917
00001e  d01a              BEQ      |L12.86|
000020  f04c0c04          ORR      r12,r12,#4
000024  f8c0c000          STR      r12,[r0,#0]
000028  6800              LDR      r0,[r0,#0]
00002a  f0000004          AND      r0,r0,#4
;;;931    
;;;932        /* Configure the MCO2 pin in alternate function mode */
;;;933        GPIO_InitStruct.Pin = MCO2_PIN;
00002e  9005              STR      r0,[sp,#0x14]
000030  0208              LSLS     r0,r1,#8
000032  9000              STR      r0,[sp,#0]
000034  e9cd1301          STRD     r1,r3,[sp,#4]
;;;934        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
;;;935        GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
;;;936        GPIO_InitStruct.Pull = GPIO_NOPULL;
;;;937        GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
;;;938        HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);
000038  4817              LDR      r0,|L12.152|
00003a  4669              MOV      r1,sp
00003c  e9cd2303          STRD     r2,r3,[sp,#0xc]
000040  f7fffffe          BL       HAL_GPIO_Init
;;;939    
;;;940        /* Mask MCO2 and MCO2PRE[2:0] bits then Select MCO2 clock source and prescaler */
;;;941        MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 3)));
000044  6821              LDR      r1,[r4,#0]
000046  ea4600c5          ORR      r0,r6,r5,LSL #3
00004a  f0214178          BIC      r1,r1,#0xf8000000
00004e  4308              ORRS     r0,r0,r1
000050  6020              STR      r0,[r4,#0]
;;;942      }
;;;943    }
000052  b006              ADD      sp,sp,#0x18
000054  bd70              POP      {r4-r6,pc}
                  |L12.86|
000056  f04c0c01          ORR      r12,r12,#1            ;912
00005a  f8c0c000          STR      r12,[r0,#0]           ;912
00005e  6800              LDR      r0,[r0,#0]            ;912
000060  f0000001          AND      r0,r0,#1              ;912
000064  9005              STR      r0,[sp,#0x14]         ;915
000066  f44f7080          MOV      r0,#0x100             ;915
00006a  9000              STR      r0,[sp,#0]            ;915
00006c  e9cd1301          STRD     r1,r3,[sp,#4]         ;915
000070  480a              LDR      r0,|L12.156|
000072  4669              MOV      r1,sp                 ;920
000074  e9cd2303          STRD     r2,r3,[sp,#0xc]       ;920
000078  f7fffffe          BL       HAL_GPIO_Init
00007c  6821              LDR      r1,[r4,#0]            ;923
00007e  ea460005          ORR      r0,r6,r5              ;923
000082  f02161ec          BIC      r1,r1,#0x7600000      ;923
000086  4308              ORRS     r0,r0,r1              ;923
000088  6020              STR      r0,[r4,#0]            ;923
00008a  b006              ADD      sp,sp,#0x18
00008c  bd70              POP      {r4-r6,pc}
;;;944    
                          ENDP

00008e  0000              DCW      0x0000
                  |L12.144|
                          DCD      0x40023830
                  |L12.148|
                          DCD      0x40023808
                  |L12.152|
                          DCD      0x40020800
                  |L12.156|
                          DCD      0x40020000

                          AREA ||i.HAL_RCC_NMI_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_RCC_NMI_IRQHandler PROC
;;;1195     */
;;;1196   void HAL_RCC_NMI_IRQHandler(void)
000000  4806              LDR      r0,|L13.28|
;;;1197   {
;;;1198     /* Check RCC CSSF flag  */
;;;1199     if(__HAL_RCC_GET_IT(RCC_IT_CSS))
000002  6800              LDR      r0,[r0,#0]
000004  f0100f80          TST      r0,#0x80
;;;1200     {
;;;1201       /* RCC Clock Security System interrupt user callback */
;;;1202       HAL_RCC_CSSCallback();
;;;1203   
;;;1204       /* Clear RCC CSS pending bit */
;;;1205       __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
;;;1206     }
;;;1207   }
000008  bf08              IT       EQ
00000a  4770              BXEQ     lr
00000c  b510              PUSH     {r4,lr}               ;1197
00000e  f7fffffe          BL       HAL_RCC_CSSCallback
000012  4903              LDR      r1,|L13.32|
000014  2080              MOVS     r0,#0x80              ;1205
000016  7008              STRB     r0,[r1,#0]            ;1205
000018  bd10              POP      {r4,pc}
;;;1208   
                          ENDP

00001a  0000              DCW      0x0000
                  |L13.28|
                          DCD      0x4002380c
                  |L13.32|
                          DCD      0x4002380e

                          AREA ||i.HAL_RCC_OscConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_OscConfig PROC
;;;359      */
;;;360    HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;361    {
000004  0004              MOVS     r4,r0
;;;362      uint32_t tickstart;
;;;363      FlagStatus pwrclkchanged = RESET;
000006  f04f0b00          MOV      r11,#0
00000a  f00081c6          BEQ.W    |L14.922|
;;;364    
;;;365      /* Check Null pointer */
;;;366      if(RCC_OscInitStruct == NULL)
;;;367      {
;;;368        return HAL_ERROR;
;;;369      }
;;;370    
;;;371      /* Check the parameters */
;;;372      assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
;;;373    
;;;374      /*------------------------------- HSE Configuration ------------------------*/
;;;375      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
00000e  7820              LDRB     r0,[r4,#0]
;;;376      {
;;;377        /* Check the parameters */
;;;378        assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
;;;379        /* When the HSE is used as system clock or clock source for PLL, It can not be disabled */
;;;380        if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)
000010  f8df938c          LDR      r9,|L14.928|
;;;381           || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
;;;382        {
;;;383          if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
000014  4de3              LDR      r5,|L14.932|
000016  f0100f01          TST      r0,#1                 ;375
00001a  d05b              BEQ      |L14.212|
00001c  f8d90000          LDR      r0,[r9,#0]            ;380
000020  f000000c          AND      r0,r0,#0xc            ;380
000024  2804              CMP      r0,#4                 ;380
000026  d00a              BEQ      |L14.62|
000028  f8d90000          LDR      r0,[r9,#0]            ;380
00002c  f000000c          AND      r0,r0,#0xc            ;380
000030  2808              CMP      r0,#8                 ;380
000032  d10d              BNE      |L14.80|
000034  1d28              ADDS     r0,r5,#4              ;380
000036  6800              LDR      r0,[r0,#0]            ;380
000038  f4100f80          TST      r0,#0x400000          ;380
00003c  d008              BEQ      |L14.80|
                  |L14.62|
00003e  6828              LDR      r0,[r5,#0]
000040  f4103f00          TST      r0,#0x20000
000044  d046              BEQ      |L14.212|
000046  6860              LDR      r0,[r4,#4]
000048  2800              CMP      r0,#0
00004a  f00081a6          BEQ.W    |L14.922|
00004e  e041              B        |L14.212|
                  |L14.80|
;;;384          {
;;;385            return HAL_ERROR;
;;;386          }
;;;387        }
;;;388        else
;;;389        {
;;;390          /* Set the new HSE configuration ---------------------------------------*/
;;;391          __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
000050  6860              LDR      r0,[r4,#4]
000052  f5b03f80          CMP      r0,#0x10000
000056  bf04              ITT      EQ
000058  6828              LDREQ    r0,[r5,#0]
00005a  f4403080          ORREQ    r0,r0,#0x10000
00005e  d00a              BEQ      |L14.118|
000060  b110              CBZ      r0,|L14.104|
000062  f5b02fa0          CMP      r0,#0x50000
000066  d011              BEQ      |L14.140|
                  |L14.104|
000068  6828              LDR      r0,[r5,#0]
00006a  f4203080          BIC      r0,r0,#0x10000
00006e  6028              STR      r0,[r5,#0]
000070  6828              LDR      r0,[r5,#0]
000072  f4202080          BIC      r0,r0,#0x40000
                  |L14.118|
000076  6028              STR      r0,[r5,#0]
;;;392    
;;;393          /* Check the HSE State */
;;;394          if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
000078  6860              LDR      r0,[r4,#4]
00007a  b1d0              CBZ      r0,|L14.178|
;;;395          {
;;;396            /* Get Start Tick*/
;;;397            tickstart = HAL_GetTick();
00007c  f7fffffe          BL       HAL_GetTick
000080  4606              MOV      r6,r0
;;;398    
;;;399            /* Wait till HSE is ready */
;;;400            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
000082  6828              LDR      r0,[r5,#0]
000084  f4103f00          TST      r0,#0x20000
000088  d008              BEQ      |L14.156|
00008a  e023              B        |L14.212|
                  |L14.140|
00008c  6828              LDR      r0,[r5,#0]            ;391
00008e  f4402080          ORR      r0,r0,#0x40000        ;391
000092  6028              STR      r0,[r5,#0]            ;391
000094  6828              LDR      r0,[r5,#0]            ;391
000096  f4403080          ORR      r0,r0,#0x10000        ;391
00009a  e7ec              B        |L14.118|
                  |L14.156|
;;;401            {
;;;402              if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
00009c  f7fffffe          BL       HAL_GetTick
0000a0  1b80              SUBS     r0,r0,r6
0000a2  2864              CMP      r0,#0x64
0000a4  f2008131          BHI.W    |L14.778|
;;;403              {
;;;404                return HAL_TIMEOUT;
0000a8  6828              LDR      r0,[r5,#0]
0000aa  f4103f00          TST      r0,#0x20000
0000ae  d0f5              BEQ      |L14.156|
0000b0  e010              B        |L14.212|
                  |L14.178|
;;;405              }
;;;406            }
;;;407          }
;;;408          else
;;;409          {
;;;410            /* Get Start Tick*/
;;;411            tickstart = HAL_GetTick();
0000b2  f7fffffe          BL       HAL_GetTick
0000b6  4606              MOV      r6,r0
;;;412    
;;;413            /* Wait till HSE is bypassed or disabled */
;;;414            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
0000b8  6828              LDR      r0,[r5,#0]
0000ba  f4103f00          TST      r0,#0x20000
0000be  d009              BEQ      |L14.212|
                  |L14.192|
;;;415            {
;;;416               if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
0000c0  f7fffffe          BL       HAL_GetTick
0000c4  1b80              SUBS     r0,r0,r6
0000c6  2864              CMP      r0,#0x64
0000c8  f200811f          BHI.W    |L14.778|
;;;417              {
;;;418                return HAL_TIMEOUT;
0000cc  6828              LDR      r0,[r5,#0]
0000ce  f4103f00          TST      r0,#0x20000
0000d2  d1f5              BNE      |L14.192|
                  |L14.212|
;;;419              }
;;;420            }
;;;421          }
;;;422        }
;;;423      }
;;;424      /*----------------------------- HSI Configuration --------------------------*/
;;;425      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
0000d4  7820              LDRB     r0,[r4,#0]
0000d6  f0100f02          TST      r0,#2
0000da  d04c              BEQ      |L14.374|
;;;426      {
;;;427        /* Check the parameters */
;;;428        assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
;;;429        assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
;;;430    
;;;431        /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
;;;432        if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
0000dc  f8d90000          LDR      r0,[r9,#0]
0000e0  f0100f0c          TST      r0,#0xc
0000e4  d019              BEQ      |L14.282|
0000e6  f8d90000          LDR      r0,[r9,#0]
0000ea  f000000c          AND      r0,r0,#0xc
0000ee  2808              CMP      r0,#8
0000f0  d104              BNE      |L14.252|
0000f2  48ad              LDR      r0,|L14.936|
0000f4  6800              LDR      r0,[r0,#0]
0000f6  f4100f80          TST      r0,#0x400000
0000fa  d00e              BEQ      |L14.282|
                  |L14.252|
;;;433           || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
;;;434        {
;;;435          /* When HSI is used as system clock it will not disabled */
;;;436          if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
;;;437          {
;;;438            return HAL_ERROR;
;;;439          }
;;;440          /* Otherwise, just the calibration is allowed */
;;;441          else
;;;442          {
;;;443            /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
;;;444            __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
;;;445          }
;;;446        }
;;;447        else
;;;448        {
;;;449          /* Check the HSI State */
;;;450          if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
0000fc  68e0              LDR      r0,[r4,#0xc]
0000fe  2800              CMP      r0,#0
;;;451          {
;;;452            /* Enable the Internal High Speed oscillator (HSI). */
;;;453            __HAL_RCC_HSI_ENABLE();
;;;454    
;;;455            /* Get Start Tick*/
;;;456            tickstart = HAL_GetTick();
;;;457    
;;;458            /* Wait till HSI is ready */
;;;459            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
;;;460            {
;;;461              if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
;;;462              {
;;;463                return HAL_TIMEOUT;
;;;464              }
;;;465            }
;;;466    
;;;467            /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
;;;468            __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
;;;469          }
;;;470          else
;;;471          {
;;;472            /* Disable the Internal High Speed oscillator (HSI). */
;;;473            __HAL_RCC_HSI_DISABLE();
000100  6828              LDR      r0,[r5,#0]
000102  d024              BEQ      |L14.334|
000104  f0400001          ORR      r0,r0,#1              ;453
000108  6028              STR      r0,[r5,#0]            ;453
00010a  f7fffffe          BL       HAL_GetTick
00010e  4606              MOV      r6,r0                 ;456
000110  6828              LDR      r0,[r5,#0]            ;459
000112  f0100f02          TST      r0,#2                 ;459
000116  d009              BEQ      |L14.300|
000118  e011              B        |L14.318|
                  |L14.282|
00011a  6828              LDR      r0,[r5,#0]            ;436
00011c  f0100f02          TST      r0,#2                 ;436
000120  bf1c              ITT      NE                    ;436
000122  68e0              LDRNE    r0,[r4,#0xc]          ;436
000124  2801              CMPNE    r0,#1                 ;436
000126  d00a              BEQ      |L14.318|
000128  f000b937          B.W      |L14.922|
                  |L14.300|
00012c  f7fffffe          BL       HAL_GetTick
000130  1b80              SUBS     r0,r0,r6              ;461
000132  2802              CMP      r0,#2                 ;461
000134  d87e              BHI      |L14.564|
000136  6828              LDR      r0,[r5,#0]            ;463
000138  f0100f02          TST      r0,#2                 ;463
00013c  d0f6              BEQ      |L14.300|
                  |L14.318|
00013e  6920              LDR      r0,[r4,#0x10]         ;468
000140  6829              LDR      r1,[r5,#0]            ;468
000142  f02101f8          BIC      r1,r1,#0xf8           ;468
000146  ea4100c0          ORR      r0,r1,r0,LSL #3       ;468
00014a  6028              STR      r0,[r5,#0]            ;468
00014c  e013              B        |L14.374|
                  |L14.334|
00014e  f0200001          BIC      r0,r0,#1
000152  6028              STR      r0,[r5,#0]
;;;474    
;;;475            /* Get Start Tick*/
;;;476            tickstart = HAL_GetTick();
000154  f7fffffe          BL       HAL_GetTick
000158  4606              MOV      r6,r0
;;;477    
;;;478            /* Wait till HSI is ready */
;;;479            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
00015a  6828              LDR      r0,[r5,#0]
00015c  f0100f02          TST      r0,#2
000160  d009              BEQ      |L14.374|
;;;480            {
;;;481              if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
000162  bf00              NOP      
                  |L14.356|
000164  f7fffffe          BL       HAL_GetTick
000168  1b80              SUBS     r0,r0,r6
00016a  2802              CMP      r0,#2
00016c  d862              BHI      |L14.564|
;;;482              {
;;;483                return HAL_TIMEOUT;
00016e  6828              LDR      r0,[r5,#0]
000170  f0100f02          TST      r0,#2
000174  d1f6              BNE      |L14.356|
                  |L14.374|
;;;484              }
;;;485            }
;;;486          }
;;;487        }
;;;488      }
;;;489      /*------------------------------ LSI Configuration -------------------------*/
;;;490      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
000176  7820              LDRB     r0,[r4,#0]
000178  f0100f08          TST      r0,#8
00017c  d02b              BEQ      |L14.470|
;;;491      {
;;;492        /* Check the parameters */
;;;493        assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
;;;494    
;;;495        /* Check the LSI State */
;;;496        if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
;;;497        {
;;;498          /* Enable the Internal Low Speed oscillator (LSI). */
;;;499          __HAL_RCC_LSI_ENABLE();
00017e  4f8b              LDR      r7,|L14.940|
000180  6960              LDR      r0,[r4,#0x14]         ;496
000182  2800              CMP      r0,#0                 ;496
;;;500    
;;;501          /* Get Start Tick*/
;;;502          tickstart = HAL_GetTick();
;;;503    
;;;504          /* Wait till LSI is ready */
;;;505          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
;;;506          {
;;;507            if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
;;;508            {
;;;509              return HAL_TIMEOUT;
;;;510            }
;;;511          }
;;;512        }
;;;513        else
;;;514        {
;;;515          /* Disable the Internal Low Speed oscillator (LSI). */
;;;516          __HAL_RCC_LSI_DISABLE();
000184  6838              LDR      r0,[r7,#0]
000186  d013              BEQ      |L14.432|
000188  f0400001          ORR      r0,r0,#1              ;499
00018c  6038              STR      r0,[r7,#0]            ;499
00018e  f7fffffe          BL       HAL_GetTick
000192  4606              MOV      r6,r0                 ;502
000194  6838              LDR      r0,[r7,#0]            ;505
000196  f0100f02          TST      r0,#2                 ;505
00019a  d11c              BNE      |L14.470|
                  |L14.412|
00019c  f7fffffe          BL       HAL_GetTick
0001a0  1b80              SUBS     r0,r0,r6              ;507
0001a2  2802              CMP      r0,#2                 ;507
0001a4  d846              BHI      |L14.564|
0001a6  6838              LDR      r0,[r7,#0]            ;509
0001a8  f0100f02          TST      r0,#2                 ;509
0001ac  d0f6              BEQ      |L14.412|
0001ae  e012              B        |L14.470|
                  |L14.432|
0001b0  f0200001          BIC      r0,r0,#1
0001b4  6038              STR      r0,[r7,#0]
;;;517    
;;;518          /* Get Start Tick*/
;;;519          tickstart = HAL_GetTick();
0001b6  f7fffffe          BL       HAL_GetTick
0001ba  4606              MOV      r6,r0
;;;520    
;;;521          /* Wait till LSI is ready */
;;;522          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
0001bc  6838              LDR      r0,[r7,#0]
0001be  f0100f02          TST      r0,#2
0001c2  d008              BEQ      |L14.470|
                  |L14.452|
;;;523          {
;;;524            if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
0001c4  f7fffffe          BL       HAL_GetTick
0001c8  1b80              SUBS     r0,r0,r6
0001ca  2802              CMP      r0,#2
0001cc  d832              BHI      |L14.564|
;;;525            {
;;;526              return HAL_TIMEOUT;
0001ce  6838              LDR      r0,[r7,#0]
0001d0  f0100f02          TST      r0,#2
0001d4  d1f6              BNE      |L14.452|
                  |L14.470|
;;;527            }
;;;528          }
;;;529        }
;;;530      }
;;;531      /*------------------------------ LSE Configuration -------------------------*/
;;;532      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
0001d6  7820              LDRB     r0,[r4,#0]
0001d8  f0100f04          TST      r0,#4
0001dc  d07a              BEQ      |L14.724|
;;;533      {
;;;534        /* Check the parameters */
;;;535        assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
;;;536    
;;;537        /* Update LSE configuration in Backup Domain control register    */
;;;538        /* Requires to enable write access to Backup Domain of necessary */
;;;539        if(__HAL_RCC_PWR_IS_CLK_DISABLED())
0001de  f8df81d0          LDR      r8,|L14.944|
0001e2  f8d80000          LDR      r0,[r8,#0]
0001e6  f0105f80          TST      r0,#0x10000000
0001ea  d10c              BNE      |L14.518|
;;;540        {
;;;541          /* Enable Power Clock*/
;;;542          __HAL_RCC_PWR_CLK_ENABLE();
0001ec  f8d80000          LDR      r0,[r8,#0]
0001f0  f0405080          ORR      r0,r0,#0x10000000
0001f4  f8c80000          STR      r0,[r8,#0]
0001f8  f8d80000          LDR      r0,[r8,#0]
;;;543          pwrclkchanged = SET;
0001fc  f04f0b01          MOV      r11,#1
000200  f0005080          AND      r0,r0,#0x10000000     ;542
000204  9000              STR      r0,[sp,#0]
                  |L14.518|
;;;544        }
;;;545    
;;;546        if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
000206  4f6b              LDR      r7,|L14.948|
000208  6838              LDR      r0,[r7,#0]
00020a  f4107f80          TST      r0,#0x100
00020e  d116              BNE      |L14.574|
;;;547        {
;;;548          /* Enable write access to Backup domain */
;;;549          PWR->CR1 |= PWR_CR1_DBP;
000210  6838              LDR      r0,[r7,#0]
000212  f4407080          ORR      r0,r0,#0x100
000216  6038              STR      r0,[r7,#0]
;;;550    
;;;551          /* Wait for Backup domain Write protection disable */
;;;552          tickstart = HAL_GetTick();
000218  f7fffffe          BL       HAL_GetTick
00021c  4606              MOV      r6,r0
;;;553    
;;;554          while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
00021e  6838              LDR      r0,[r7,#0]
000220  f4107f80          TST      r0,#0x100
000224  d10b              BNE      |L14.574|
;;;555          {
;;;556            if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
000226  bf00              NOP      
                  |L14.552|
000228  f7fffffe          BL       HAL_GetTick
00022c  1b80              SUBS     r0,r0,r6
00022e  2864              CMP      r0,#0x64
000230  d86b              BHI      |L14.778|
;;;557            {
;;;558              return HAL_TIMEOUT;
000232  e000              B        |L14.566|
                  |L14.564|
000234  e069              B        |L14.778|
                  |L14.566|
000236  6838              LDR      r0,[r7,#0]
000238  f4107f80          TST      r0,#0x100
00023c  d0f4              BEQ      |L14.552|
                  |L14.574|
;;;559            }
;;;560          }
;;;561        }
;;;562    
;;;563        /* Set the new LSE configuration -----------------------------------------*/
;;;564        __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
00023e  68a0              LDR      r0,[r4,#8]
000240  4e5d              LDR      r6,|L14.952|
000242  2801              CMP      r0,#1
000244  bf04              ITT      EQ
000246  6830              LDREQ    r0,[r6,#0]
000248  f0400001          ORREQ    r0,r0,#1
00024c  d009              BEQ      |L14.610|
00024e  b108              CBZ      r0,|L14.596|
000250  2805              CMP      r0,#5
000252  d013              BEQ      |L14.636|
                  |L14.596|
000254  6830              LDR      r0,[r6,#0]
000256  f0200001          BIC      r0,r0,#1
00025a  6030              STR      r0,[r6,#0]
00025c  6830              LDR      r0,[r6,#0]
00025e  f0200004          BIC      r0,r0,#4
                  |L14.610|
000262  6030              STR      r0,[r6,#0]
;;;565        /* Check the LSE State */
;;;566        if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
;;;567        {
;;;568          /* Get Start Tick*/
;;;569          tickstart = HAL_GetTick();
;;;570    
;;;571          /* Wait till LSE is ready */
;;;572          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
;;;573          {
;;;574            if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
000264  68a0              LDR      r0,[r4,#8]
000266  f2413a88          MOV      r10,#0x1388
00026a  b1c8              CBZ      r0,|L14.672|
00026c  f7fffffe          BL       HAL_GetTick
000270  4607              MOV      r7,r0                 ;569
000272  6830              LDR      r0,[r6,#0]            ;572
000274  f0100f02          TST      r0,#2                 ;572
000278  d008              BEQ      |L14.652|
00027a  e022              B        |L14.706|
                  |L14.636|
00027c  6830              LDR      r0,[r6,#0]            ;564
00027e  f0400004          ORR      r0,r0,#4              ;564
000282  6030              STR      r0,[r6,#0]            ;564
000284  6830              LDR      r0,[r6,#0]            ;564
000286  f0400001          ORR      r0,r0,#1              ;564
00028a  e7ea              B        |L14.610|
                  |L14.652|
00028c  f7fffffe          BL       HAL_GetTick
000290  1bc0              SUBS     r0,r0,r7
000292  4550              CMP      r0,r10
000294  d839              BHI      |L14.778|
;;;575            {
;;;576              return HAL_TIMEOUT;
000296  6830              LDR      r0,[r6,#0]
000298  f0100f02          TST      r0,#2
00029c  d0f6              BEQ      |L14.652|
00029e  e010              B        |L14.706|
                  |L14.672|
;;;577            }
;;;578          }
;;;579        }
;;;580        else
;;;581        {
;;;582          /* Get Start Tick*/
;;;583          tickstart = HAL_GetTick();
0002a0  f7fffffe          BL       HAL_GetTick
0002a4  4607              MOV      r7,r0
;;;584    
;;;585          /* Wait till LSE is ready */
;;;586          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
0002a6  6830              LDR      r0,[r6,#0]
0002a8  f0100f02          TST      r0,#2
0002ac  d009              BEQ      |L14.706|
;;;587          {
;;;588            if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
0002ae  bf00              NOP      
                  |L14.688|
0002b0  f7fffffe          BL       HAL_GetTick
0002b4  1bc0              SUBS     r0,r0,r7
0002b6  4550              CMP      r0,r10
0002b8  d827              BHI      |L14.778|
;;;589            {
;;;590              return HAL_TIMEOUT;
0002ba  6830              LDR      r0,[r6,#0]
0002bc  f0100f02          TST      r0,#2
0002c0  d1f6              BNE      |L14.688|
                  |L14.706|
;;;591            }
;;;592          }
;;;593        }
;;;594    
;;;595        /* Restore clock configuration if changed */
;;;596        if(pwrclkchanged == SET)
0002c2  f1bb0f00          CMP      r11,#0
0002c6  d005              BEQ      |L14.724|
;;;597        {
;;;598          __HAL_RCC_PWR_CLK_DISABLE();
0002c8  f8d80000          LDR      r0,[r8,#0]
0002cc  f0205080          BIC      r0,r0,#0x10000000
0002d0  f8c80000          STR      r0,[r8,#0]
                  |L14.724|
;;;599        }
;;;600      }
;;;601      /*-------------------------------- PLL Configuration -----------------------*/
;;;602      /* Check the parameters */
;;;603      assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
;;;604      if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
0002d4  69a0              LDR      r0,[r4,#0x18]
0002d6  b3e8              CBZ      r0,|L14.852|
;;;605      {
;;;606        /* Check if the PLL is used as system clock or not */
;;;607        if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
0002d8  f8d91000          LDR      r1,[r9,#0]
0002dc  f001010c          AND      r1,r1,#0xc
0002e0  2908              CMP      r1,#8
0002e2  d05a              BEQ      |L14.922|
;;;608        {
;;;609          if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
0002e4  2802              CMP      r0,#2
;;;610          {
;;;611            /* Check the parameters */
;;;612            assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
;;;613            assert_param(IS_RCC_PLLM_VALUE(RCC_OscInitStruct->PLL.PLLM));
;;;614            assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
;;;615            assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
;;;616            assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
;;;617    #if defined (RCC_PLLCFGR_PLLR)
;;;618            assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
;;;619    #endif
;;;620    
;;;621            /* Disable the main PLL. */
;;;622            __HAL_RCC_PLL_DISABLE();
;;;623    
;;;624            /* Get Start Tick*/
;;;625            tickstart = HAL_GetTick();
;;;626    
;;;627            /* Wait till PLL is ready */
;;;628            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
;;;629            {
;;;630              if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
;;;631              {
;;;632                return HAL_TIMEOUT;
;;;633              }
;;;634            }
;;;635    
;;;636            /* Configure the main PLL clock source, multiplication and division factors. */
;;;637    #if defined (RCC_PLLCFGR_PLLR)
;;;638            __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
;;;639                                 RCC_OscInitStruct->PLL.PLLM,
;;;640                                 RCC_OscInitStruct->PLL.PLLN,
;;;641                                 RCC_OscInitStruct->PLL.PLLP,
;;;642                                 RCC_OscInitStruct->PLL.PLLQ,
;;;643                                 RCC_OscInitStruct->PLL.PLLR);
;;;644    #else
;;;645            __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
;;;646                                 RCC_OscInitStruct->PLL.PLLM,
;;;647                                 RCC_OscInitStruct->PLL.PLLN,
;;;648                                 RCC_OscInitStruct->PLL.PLLP,
;;;649                                 RCC_OscInitStruct->PLL.PLLQ);
;;;650    #endif
;;;651    
;;;652            /* Enable the main PLL. */
;;;653            __HAL_RCC_PLL_ENABLE();
;;;654    
;;;655            /* Get Start Tick*/
;;;656            tickstart = HAL_GetTick();
;;;657    
;;;658            /* Wait till PLL is ready */
;;;659            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
;;;660            {
;;;661              if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
;;;662              {
;;;663                return HAL_TIMEOUT;
;;;664              }
;;;665            }
;;;666          }
;;;667          else
;;;668          {
;;;669            /* Disable the main PLL. */
;;;670            __HAL_RCC_PLL_DISABLE();
0002e6  6828              LDR      r0,[r5,#0]
0002e8  f0207080          BIC      r0,r0,#0x1000000
0002ec  6028              STR      r0,[r5,#0]
0002ee  d00f              BEQ      |L14.784|
;;;671    
;;;672            /* Get Start Tick*/
;;;673            tickstart = HAL_GetTick();
0002f0  f7fffffe          BL       HAL_GetTick
0002f4  4604              MOV      r4,r0
;;;674    
;;;675            /* Wait till PLL is ready */
;;;676            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
0002f6  6828              LDR      r0,[r5,#0]
0002f8  f0107f00          TST      r0,#0x2000000
0002fc  d04a              BEQ      |L14.916|
;;;677            {
;;;678              if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
0002fe  bf00              NOP      
                  |L14.768|
000300  f7fffffe          BL       HAL_GetTick
000304  1b00              SUBS     r0,r0,r4
000306  2802              CMP      r0,#2
000308  d940              BLS      |L14.908|
                  |L14.778|
;;;679              {
;;;680                return HAL_TIMEOUT;
00030a  2003              MOVS     r0,#3
;;;681              }
;;;682            }
;;;683          }
;;;684        }
;;;685        else
;;;686        {
;;;687          return HAL_ERROR;
;;;688        }
;;;689      }
;;;690      return HAL_OK;
;;;691    }
00030c  e8bd8ff8          POP      {r3-r11,pc}
                  |L14.784|
000310  f7fffffe          BL       HAL_GetTick
000314  4606              MOV      r6,r0                 ;625
000316  6828              LDR      r0,[r5,#0]            ;628
000318  f0107f00          TST      r0,#0x2000000         ;628
00031c  d009              BEQ      |L14.818|
00031e  bf00              NOP                            ;630
                  |L14.800|
000320  f7fffffe          BL       HAL_GetTick
000324  1b80              SUBS     r0,r0,r6              ;630
000326  2802              CMP      r0,#2                 ;630
000328  d8ef              BHI      |L14.778|
00032a  6828              LDR      r0,[r5,#0]            ;632
00032c  f0107f00          TST      r0,#0x2000000         ;632
000330  d1f6              BNE      |L14.800|
                  |L14.818|
000332  e9d4c309          LDRD     r12,r3,[r4,#0x24]     ;638
000336  e9d40107          LDRD     r0,r1,[r4,#0x1c]      ;638
00033a  4a20              LDR      r2,|L14.956|
00033c  085e              LSRS     r6,r3,#1              ;638
00033e  f894302c          LDRB     r3,[r4,#0x2c]         ;638
000342  4308              ORRS     r0,r0,r1              ;638
000344  f8944030          LDRB     r4,[r4,#0x30]         ;638
000348  eb024206          ADD      r2,r2,r6,LSL #16      ;638
00034c  ea42118c          ORR      r1,r2,r12,LSL #6      ;638
000350  4301              ORRS     r1,r1,r0              ;638
000352  e000              B        |L14.854|
                  |L14.852|
000354  e01e              B        |L14.916|
                  |L14.854|
000356  4814              LDR      r0,|L14.936|
000358  ea416103          ORR      r1,r1,r3,LSL #24      ;638
00035c  ea417104          ORR      r1,r1,r4,LSL #28      ;638
000360  6001              STR      r1,[r0,#0]            ;638
000362  6828              LDR      r0,[r5,#0]            ;653
000364  f0407080          ORR      r0,r0,#0x1000000      ;653
000368  6028              STR      r0,[r5,#0]            ;653
00036a  f7fffffe          BL       HAL_GetTick
00036e  4604              MOV      r4,r0                 ;656
000370  6828              LDR      r0,[r5,#0]            ;659
000372  f0107f00          TST      r0,#0x2000000         ;659
000376  d10d              BNE      |L14.916|
                  |L14.888|
000378  f7fffffe          BL       HAL_GetTick
00037c  1b00              SUBS     r0,r0,r4              ;661
00037e  2802              CMP      r0,#2                 ;661
000380  d8c3              BHI      |L14.778|
000382  6828              LDR      r0,[r5,#0]            ;663
000384  f0107f00          TST      r0,#0x2000000         ;663
000388  d0f6              BEQ      |L14.888|
00038a  e003              B        |L14.916|
                  |L14.908|
00038c  6828              LDR      r0,[r5,#0]            ;680
00038e  f0107f00          TST      r0,#0x2000000         ;680
000392  d1b5              BNE      |L14.768|
                  |L14.916|
000394  2000              MOVS     r0,#0                 ;690
000396  e8bd8ff8          POP      {r3-r11,pc}
                  |L14.922|
00039a  2001              MOVS     r0,#1                 ;687
00039c  e8bd8ff8          POP      {r3-r11,pc}
;;;692    
                          ENDP

                  |L14.928|
                          DCD      0x40023808
                  |L14.932|
                          DCD      0x40023800
                  |L14.936|
                          DCD      0x40023804
                  |L14.940|
                          DCD      0x40023874
                  |L14.944|
                          DCD      0x40023840
                  |L14.948|
                          DCD      0x40007000
                  |L14.952|
                          DCD      0x40023870
                  |L14.956|
                          DCD      0xffff0000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F7_V1.11.0\\Drivers\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_rcc_c_b7071a4b____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F7_V1.11.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f7xx_hal_rcc_c_b7071a4b____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_rcc_c_b7071a4b____REVSH|
#line 402
|__asm___19_stm32f7xx_hal_rcc_c_b7071a4b____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_rcc_c_b7071a4b____RRX|
#line 587
|__asm___19_stm32f7xx_hal_rcc_c_b7071a4b____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
