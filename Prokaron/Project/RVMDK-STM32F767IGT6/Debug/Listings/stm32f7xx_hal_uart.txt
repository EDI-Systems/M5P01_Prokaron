; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f7xx_hal_uart.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f7xx_hal_uart.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc\Conf -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f7xx_hal_uart.crf ..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_uart.c]
                          THUMB

                          AREA ||i.HAL_HalfDuplex_EnableReceiver||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableReceiver PROC
;;;2070     */
;;;2071   HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
000000  6e81              LDR      r1,[r0,#0x68]
;;;2072   {
;;;2073     /* Process Locked */
;;;2074     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;2075     huart->gState = HAL_UART_STATE_BUSY;
;;;2076   
;;;2077     /* Clear TE and RE bits */
;;;2078     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));
;;;2079     /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
;;;2080     SET_BIT(huart->Instance->CR1, USART_CR1_RE);
;;;2081   
;;;2082     huart->gState = HAL_UART_STATE_READY;
;;;2083     /* Process Unlocked */
;;;2084     __HAL_UNLOCK(huart);
;;;2085   
;;;2086     return HAL_OK;
;;;2087   }
000008  4770              BXEQ     lr
00000a  2201              MOVS     r2,#1                 ;2074
00000c  2124              MOVS     r1,#0x24              ;2075
00000e  6682              STR      r2,[r0,#0x68]         ;2084
000010  2320              MOVS     r3,#0x20              ;2082
000012  66c1              STR      r1,[r0,#0x6c]         ;2075
000014  2200              MOVS     r2,#0                 ;2084
000016  6801              LDR      r1,[r0,#0]            ;2078
000018  f8d1c000          LDR      r12,[r1,#0]           ;2078
00001c  f02c0c0c          BIC      r12,r12,#0xc          ;2078
000020  f8c1c000          STR      r12,[r1,#0]           ;2078
000024  6801              LDR      r1,[r0,#0]            ;2080
000026  f8d1c000          LDR      r12,[r1,#0]           ;2080
00002a  f04c0c04          ORR      r12,r12,#4            ;2080
00002e  f8c1c000          STR      r12,[r1,#0]           ;2080
000032  66c3              STR      r3,[r0,#0x6c]         ;2082
000034  6682              STR      r2,[r0,#0x68]         ;2086
000036  4610              MOV      r0,r2                 ;2086
000038  4770              BX       lr
;;;2088   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_EnableTransmitter||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableTransmitter PROC
;;;2047     */
;;;2048   HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
000000  6e81              LDR      r1,[r0,#0x68]
;;;2049   {
;;;2050     /* Process Locked */
;;;2051     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;2052     huart->gState = HAL_UART_STATE_BUSY;
;;;2053   
;;;2054     /* Clear TE and RE bits */
;;;2055     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));
;;;2056     /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
;;;2057     SET_BIT(huart->Instance->CR1, USART_CR1_TE);
;;;2058   
;;;2059     huart->gState= HAL_UART_STATE_READY;
;;;2060     /* Process Unlocked */
;;;2061     __HAL_UNLOCK(huart);
;;;2062   
;;;2063     return HAL_OK;
;;;2064   }
000008  4770              BXEQ     lr
00000a  2201              MOVS     r2,#1                 ;2051
00000c  2124              MOVS     r1,#0x24              ;2052
00000e  6682              STR      r2,[r0,#0x68]         ;2061
000010  2320              MOVS     r3,#0x20              ;2059
000012  66c1              STR      r1,[r0,#0x6c]         ;2052
000014  2200              MOVS     r2,#0                 ;2061
000016  6801              LDR      r1,[r0,#0]            ;2055
000018  f8d1c000          LDR      r12,[r1,#0]           ;2055
00001c  f02c0c0c          BIC      r12,r12,#0xc          ;2055
000020  f8c1c000          STR      r12,[r1,#0]           ;2055
000024  6801              LDR      r1,[r0,#0]            ;2057
000026  f8d1c000          LDR      r12,[r1,#0]           ;2057
00002a  f04c0c08          ORR      r12,r12,#8            ;2057
00002e  f8c1c000          STR      r12,[r1,#0]           ;2057
000032  66c3              STR      r3,[r0,#0x6c]         ;2059
000034  6682              STR      r2,[r0,#0x68]         ;2063
000036  4610              MOV      r0,r2                 ;2063
000038  4770              BX       lr
;;;2065   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_Init||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_Init PROC
;;;303      */
;;;304    HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
000000  2800              CMP      r0,#0
;;;305    {
;;;306      /* Check the UART handle allocation */
;;;307      if(huart == NULL)
;;;308      {
;;;309        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;310      }
;;;311    
;;;312      if(huart->gState == HAL_UART_STATE_RESET)
;;;313      {
;;;314        /* Allocate lock resource and initialize it */
;;;315        huart->Lock = HAL_UNLOCKED;
;;;316    
;;;317        /* Init the low level hardware : GPIO, CLOCK */
;;;318        HAL_UART_MspInit(huart);
;;;319      }
;;;320    
;;;321      huart->gState = HAL_UART_STATE_BUSY;
;;;322    
;;;323      /* Disable the Peripheral */
;;;324      __HAL_UART_DISABLE(huart);
;;;325    
;;;326      /* Set the UART Communication parameters */
;;;327      if (UART_SetConfig(huart) == HAL_ERROR)
;;;328      {
;;;329        return HAL_ERROR;
;;;330      }
;;;331    
;;;332      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;333      {
;;;334        UART_AdvFeatureConfig(huart);
;;;335      }
;;;336    
;;;337      /* In half-duplex mode, the following bits must be kept cleared:
;;;338      - LINEN and CLKEN bits in the USART_CR2 register,
;;;339      - SCEN and IREN bits in the USART_CR3 register.*/
;;;340      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;341      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
;;;342    
;;;343      /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;344      SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
;;;345    
;;;346      /* Enable the Peripheral */
;;;347      __HAL_UART_ENABLE(huart);
;;;348    
;;;349      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;350      return (UART_CheckIdleState(huart));
;;;351    }
000006  4770              BXEQ     lr
000008  b510              PUSH     {r4,lr}               ;305
00000a  4604              MOV      r4,r0                 ;305
00000c  6ec0              LDR      r0,[r0,#0x6c]         ;312
00000e  b920              CBNZ     r0,|L3.26|
000010  2000              MOVS     r0,#0                 ;315
000012  66a0              STR      r0,[r4,#0x68]         ;318
000014  4620              MOV      r0,r4                 ;318
000016  f7fffffe          BL       HAL_UART_MspInit
                  |L3.26|
00001a  2024              MOVS     r0,#0x24              ;321
00001c  66e0              STR      r0,[r4,#0x6c]         ;321
00001e  6820              LDR      r0,[r4,#0]            ;324
000020  6801              LDR      r1,[r0,#0]            ;324
000022  f0210101          BIC      r1,r1,#1              ;324
000026  6001              STR      r1,[r0,#0]            ;324
000028  4620              MOV      r0,r4                 ;327
00002a  f7fffffe          BL       UART_SetConfig
00002e  2801              CMP      r0,#1                 ;327
000030  bf08              IT       EQ
000032  bd10              POPEQ    {r4,pc}
000034  6a60              LDR      r0,[r4,#0x24]         ;332
000036  2800              CMP      r0,#0                 ;332
000038  bf1c              ITT      NE                    ;334
00003a  4620              MOVNE    r0,r4                 ;334
00003c  f7fffffe          BLNE     UART_AdvFeatureConfig
000040  6820              LDR      r0,[r4,#0]            ;340
000042  6841              LDR      r1,[r0,#4]            ;340
000044  f4214190          BIC      r1,r1,#0x4800         ;340
000048  6041              STR      r1,[r0,#4]            ;340
00004a  6820              LDR      r0,[r4,#0]            ;341
00004c  6881              LDR      r1,[r0,#8]            ;341
00004e  f0210122          BIC      r1,r1,#0x22           ;341
000052  6081              STR      r1,[r0,#8]            ;341
000054  6820              LDR      r0,[r4,#0]            ;344
000056  6881              LDR      r1,[r0,#8]            ;344
000058  f0410108          ORR      r1,r1,#8              ;344
00005c  6081              STR      r1,[r0,#8]            ;344
00005e  6820              LDR      r0,[r4,#0]            ;347
000060  6801              LDR      r1,[r0,#0]            ;347
000062  f0410101          ORR      r1,r1,#1              ;347
000066  6001              STR      r1,[r0,#0]            ;347
000068  4620              MOV      r0,r4                 ;350
00006a  e8bd4010          POP      {r4,lr}               ;350
00006e  f7ffbffe          B.W      UART_CheckIdleState
;;;352    
                          ENDP


                          AREA ||i.HAL_LIN_Init||, CODE, READONLY, ALIGN=1

                  HAL_LIN_Init PROC
;;;363      */
;;;364    HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
000000  2800              CMP      r0,#0
;;;365    {
;;;366      /* Check the UART handle allocation */
;;;367      if(huart == NULL)
;;;368      {
;;;369        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;370      }
;;;371    
;;;372      /* Check the parameters */
;;;373      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;374      assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
;;;375      assert_param(IS_LIN_WORD_LENGTH(huart->Init.WordLength));
;;;376    
;;;377      if(huart->gState == HAL_UART_STATE_RESET)
;;;378      {
;;;379        /* Allocate lock resource and initialize it */
;;;380        huart->Lock = HAL_UNLOCKED;
;;;381    
;;;382        /* Init the low level hardware : GPIO, CLOCK */
;;;383        HAL_UART_MspInit(huart);
;;;384      }
;;;385    
;;;386      huart->gState = HAL_UART_STATE_BUSY;
;;;387    
;;;388      /* Disable the Peripheral */
;;;389      __HAL_UART_DISABLE(huart);
;;;390    
;;;391      /* Set the UART Communication parameters */
;;;392      if (UART_SetConfig(huart) == HAL_ERROR)
;;;393      {
;;;394        return HAL_ERROR;
;;;395      }
;;;396    
;;;397      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;398      {
;;;399        UART_AdvFeatureConfig(huart);
;;;400      }
;;;401    
;;;402      /* In LIN mode, the following bits must be kept cleared:
;;;403      - LINEN and CLKEN bits in the USART_CR2 register,
;;;404      - SCEN and IREN bits in the USART_CR3 register.*/
;;;405      CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
;;;406      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
;;;407    
;;;408      /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;409      SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
;;;410    
;;;411      /* Set the USART LIN Break detection length. */
;;;412      MODIFY_REG(huart->Instance->CR2, USART_CR2_LBDL, BreakDetectLength);
;;;413    
;;;414      /* Enable the Peripheral */
;;;415      __HAL_UART_ENABLE(huart);
;;;416    
;;;417      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;418      return (UART_CheckIdleState(huart));
;;;419    }
000006  4770              BXEQ     lr
000008  b570              PUSH     {r4-r6,lr}            ;365
00000a  4604              MOV      r4,r0                 ;365
00000c  6ec0              LDR      r0,[r0,#0x6c]         ;377
00000e  460d              MOV      r5,r1                 ;365
000010  b920              CBNZ     r0,|L4.28|
000012  2000              MOVS     r0,#0                 ;380
000014  66a0              STR      r0,[r4,#0x68]         ;383
000016  4620              MOV      r0,r4                 ;383
000018  f7fffffe          BL       HAL_UART_MspInit
                  |L4.28|
00001c  2024              MOVS     r0,#0x24              ;386
00001e  66e0              STR      r0,[r4,#0x6c]         ;386
000020  6820              LDR      r0,[r4,#0]            ;389
000022  6801              LDR      r1,[r0,#0]            ;389
000024  f0210101          BIC      r1,r1,#1              ;389
000028  6001              STR      r1,[r0,#0]            ;389
00002a  4620              MOV      r0,r4                 ;392
00002c  f7fffffe          BL       UART_SetConfig
000030  2801              CMP      r0,#1                 ;392
000032  bf08              IT       EQ
000034  bd70              POPEQ    {r4-r6,pc}
000036  6a60              LDR      r0,[r4,#0x24]         ;397
000038  2800              CMP      r0,#0                 ;397
00003a  bf1c              ITT      NE                    ;399
00003c  4620              MOVNE    r0,r4                 ;399
00003e  f7fffffe          BLNE     UART_AdvFeatureConfig
000042  6820              LDR      r0,[r4,#0]            ;405
000044  6841              LDR      r1,[r0,#4]            ;405
000046  f4216100          BIC      r1,r1,#0x800          ;405
00004a  6041              STR      r1,[r0,#4]            ;405
00004c  6820              LDR      r0,[r4,#0]            ;406
00004e  6881              LDR      r1,[r0,#8]            ;406
000050  f021012a          BIC      r1,r1,#0x2a           ;406
000054  6081              STR      r1,[r0,#8]            ;406
000056  6820              LDR      r0,[r4,#0]            ;409
000058  6841              LDR      r1,[r0,#4]            ;409
00005a  f4414180          ORR      r1,r1,#0x4000         ;409
00005e  6041              STR      r1,[r0,#4]            ;409
000060  6820              LDR      r0,[r4,#0]            ;412
000062  6841              LDR      r1,[r0,#4]            ;412
000064  f0210120          BIC      r1,r1,#0x20           ;412
000068  4329              ORRS     r1,r1,r5              ;412
00006a  6041              STR      r1,[r0,#4]            ;412
00006c  6820              LDR      r0,[r4,#0]            ;415
00006e  6801              LDR      r1,[r0,#0]            ;415
000070  f0410101          ORR      r1,r1,#1              ;415
000074  6001              STR      r1,[r0,#0]            ;415
000076  4620              MOV      r0,r4                 ;418
000078  e8bd4070          POP      {r4-r6,lr}            ;418
00007c  f7ffbffe          B.W      UART_CheckIdleState
;;;420    
                          ENDP


                          AREA ||i.HAL_LIN_SendBreak||, CODE, READONLY, ALIGN=1

                  HAL_LIN_SendBreak PROC
;;;2094     */
;;;2095   HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
000000  6e81              LDR      r1,[r0,#0x68]
;;;2096   {
;;;2097     /* Check the parameters */
;;;2098     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;2099   
;;;2100     /* Process Locked */
;;;2101     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;2102   
;;;2103     huart->gState = HAL_UART_STATE_BUSY;
;;;2104   
;;;2105     /* Send break characters */
;;;2106     SET_BIT(huart->Instance->RQR, UART_SENDBREAK_REQUEST);
;;;2107   
;;;2108     huart->gState = HAL_UART_STATE_READY;
;;;2109   
;;;2110     /* Process Unlocked */
;;;2111     __HAL_UNLOCK(huart);
;;;2112   
;;;2113     return HAL_OK;
;;;2114   }
000008  4770              BXEQ     lr
00000a  2201              MOVS     r2,#1                 ;2101
00000c  2124              MOVS     r1,#0x24              ;2103
00000e  6682              STR      r2,[r0,#0x68]         ;2111
000010  2320              MOVS     r3,#0x20              ;2108
000012  66c1              STR      r1,[r0,#0x6c]         ;2103
000014  2200              MOVS     r2,#0                 ;2111
000016  6801              LDR      r1,[r0,#0]            ;2106
000018  f8d1c018          LDR      r12,[r1,#0x18]        ;2106
00001c  f04c0c02          ORR      r12,r12,#2            ;2106
000020  f8c1c018          STR      r12,[r1,#0x18]        ;2106
000024  66c3              STR      r3,[r0,#0x6c]         ;2108
000026  6682              STR      r2,[r0,#0x68]         ;2113
000028  4610              MOV      r0,r2                 ;2113
00002a  4770              BX       lr
;;;2115   
                          ENDP


                          AREA ||i.HAL_MultiProcessorEx_AddressLength_Set||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessorEx_AddressLength_Set PROC
;;;2128     */
;;;2129   HAL_StatusTypeDef HAL_MultiProcessorEx_AddressLength_Set(UART_HandleTypeDef *huart, uint32_t AddressLength)
000000  2800              CMP      r0,#0
;;;2130   {
;;;2131     /* Check the UART handle allocation */
;;;2132     if(huart == NULL)
;;;2133     {
;;;2134       return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;2135     }
;;;2136   
;;;2137     /* Check the address length parameter */
;;;2138     assert_param(IS_UART_ADDRESSLENGTH_DETECT(AddressLength));
;;;2139   
;;;2140     huart->gState = HAL_UART_STATE_BUSY;
;;;2141   
;;;2142     /* Disable the Peripheral */
;;;2143     __HAL_UART_DISABLE(huart);
;;;2144   
;;;2145     /* Set the address length */
;;;2146     MODIFY_REG(huart->Instance->CR2, USART_CR2_ADDM7, AddressLength);
;;;2147   
;;;2148     /* Enable the Peripheral */
;;;2149     __HAL_UART_ENABLE(huart);
;;;2150   
;;;2151     /* TEACK and/or REACK to check before moving huart->gState to Ready */
;;;2152     return (UART_CheckIdleState(huart));
;;;2153   }
000006  4770              BXEQ     lr
000008  2224              MOVS     r2,#0x24              ;2140
00000a  66c2              STR      r2,[r0,#0x6c]         ;2140
00000c  6802              LDR      r2,[r0,#0]            ;2143
00000e  6813              LDR      r3,[r2,#0]            ;2143
000010  f0230301          BIC      r3,r3,#1              ;2143
000014  6013              STR      r3,[r2,#0]            ;2143
000016  6802              LDR      r2,[r0,#0]            ;2146
000018  6853              LDR      r3,[r2,#4]            ;2146
00001a  f0230310          BIC      r3,r3,#0x10           ;2146
00001e  4319              ORRS     r1,r1,r3              ;2146
000020  6051              STR      r1,[r2,#4]            ;2146
000022  6801              LDR      r1,[r0,#0]            ;2149
000024  680a              LDR      r2,[r1,#0]            ;2149
000026  f0420201          ORR      r2,r2,#1              ;2149
00002a  600a              STR      r2,[r1,#0]            ;2149
00002c  f7ffbffe          B.W      UART_CheckIdleState
;;;2154   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_DisableMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_DisableMuteMode PROC
;;;1766     */
;;;1767   HAL_StatusTypeDef HAL_MultiProcessor_DisableMuteMode(UART_HandleTypeDef *huart)
000000  6e81              LDR      r1,[r0,#0x68]
;;;1768   {
;;;1769     /* Process Locked */
;;;1770     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;1771   
;;;1772     huart->gState = HAL_UART_STATE_BUSY;
;;;1773   
;;;1774      /* Disable USART mute mode by clearing the MME bit in the CR1 register */
;;;1775     CLEAR_BIT(huart->Instance->CR1, USART_CR1_MME);
;;;1776   
;;;1777     huart->gState = HAL_UART_STATE_READY;
;;;1778   
;;;1779     return (UART_CheckIdleState(huart));
;;;1780   }
000008  4770              BXEQ     lr
00000a  2201              MOVS     r2,#1                 ;1770
00000c  2124              MOVS     r1,#0x24              ;1772
00000e  6682              STR      r2,[r0,#0x68]         ;1777
000010  2220              MOVS     r2,#0x20              ;1777
000012  66c1              STR      r1,[r0,#0x6c]         ;1772
000014  6801              LDR      r1,[r0,#0]            ;1775
000016  680b              LDR      r3,[r1,#0]            ;1775
000018  f4235300          BIC      r3,r3,#0x2000         ;1775
00001c  600b              STR      r3,[r1,#0]            ;1775
00001e  66c2              STR      r2,[r0,#0x6c]         ;1777
000020  f7ffbffe          B.W      UART_CheckIdleState
;;;1781   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnableMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnableMuteMode PROC
;;;1745     */
;;;1746   HAL_StatusTypeDef HAL_MultiProcessor_EnableMuteMode(UART_HandleTypeDef *huart)
000000  6e81              LDR      r1,[r0,#0x68]
;;;1747   {
;;;1748     /* Process Locked */
;;;1749     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;1750   
;;;1751     huart->gState = HAL_UART_STATE_BUSY;
;;;1752   
;;;1753     /* Enable USART mute mode by setting the MME bit in the CR1 register */
;;;1754     SET_BIT(huart->Instance->CR1, USART_CR1_MME);
;;;1755   
;;;1756     huart->gState = HAL_UART_STATE_READY;
;;;1757   
;;;1758     return (UART_CheckIdleState(huart));
;;;1759   }
000008  4770              BXEQ     lr
00000a  2201              MOVS     r2,#1                 ;1749
00000c  2124              MOVS     r1,#0x24              ;1751
00000e  6682              STR      r2,[r0,#0x68]         ;1756
000010  2220              MOVS     r2,#0x20              ;1756
000012  66c1              STR      r1,[r0,#0x6c]         ;1751
000014  6801              LDR      r1,[r0,#0]            ;1754
000016  680b              LDR      r3,[r1,#0]            ;1754
000018  f4435300          ORR      r3,r3,#0x2000         ;1754
00001c  600b              STR      r3,[r1,#0]            ;1754
00001e  66c2              STR      r2,[r0,#0x6c]         ;1756
000020  f7ffbffe          B.W      UART_CheckIdleState
;;;1760   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnterMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnterMuteMode PROC
;;;1787     */
;;;1788   void HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
000000  6800              LDR      r0,[r0,#0]
;;;1789   {
;;;1790     __HAL_UART_SEND_REQ(huart, UART_MUTE_MODE_REQUEST);
000002  6981              LDR      r1,[r0,#0x18]
000004  f0410104          ORR      r1,r1,#4
000008  6181              STR      r1,[r0,#0x18]
;;;1791   }
00000a  4770              BX       lr
;;;1792   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_Init||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_Init PROC
;;;437      */
;;;438    HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
000000  2800              CMP      r0,#0
;;;439    {
;;;440      /* Check the UART handle allocation */
;;;441      if(huart == NULL)
;;;442      {
;;;443        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;444      }
;;;445    
;;;446      /* Check the wake up method parameter */
;;;447      assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
;;;448    
;;;449      if(huart->gState == HAL_UART_STATE_RESET)
;;;450      {
;;;451        /* Allocate lock resource and initialize it */
;;;452        huart->Lock = HAL_UNLOCKED;
;;;453    
;;;454        /* Init the low level hardware : GPIO, CLOCK */
;;;455        HAL_UART_MspInit(huart);
;;;456      }
;;;457    
;;;458      huart->gState = HAL_UART_STATE_BUSY;
;;;459    
;;;460      /* Disable the Peripheral */
;;;461      __HAL_UART_DISABLE(huart);
;;;462    
;;;463      /* Set the UART Communication parameters */
;;;464      if (UART_SetConfig(huart) == HAL_ERROR)
;;;465      {
;;;466        return HAL_ERROR;
;;;467      }
;;;468    
;;;469      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;470      {
;;;471        UART_AdvFeatureConfig(huart);
;;;472      }
;;;473    
;;;474      /* In multiprocessor mode, the following bits must be kept cleared:
;;;475      - LINEN and CLKEN bits in the USART_CR2 register,
;;;476      - SCEN, HDSEL and IREN  bits in the USART_CR3 register. */
;;;477      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;478      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;479    
;;;480      if (WakeUpMethod == UART_WAKEUPMETHOD_ADDRESSMARK)
;;;481      {
;;;482        /* If address mark wake up method is chosen, set the USART address node */
;;;483        MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, ((uint32_t)Address << UART_CR2_ADDRESS_LSB_POS));
;;;484      }
;;;485    
;;;486      /* Set the wake up method by setting the WAKE bit in the CR1 register */
;;;487      MODIFY_REG(huart->Instance->CR1, USART_CR1_WAKE, WakeUpMethod);
;;;488    
;;;489      /* Enable the Peripheral */
;;;490      __HAL_UART_ENABLE(huart);
;;;491    
;;;492      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;493      return (UART_CheckIdleState(huart));
;;;494    }
000006  4770              BXEQ     lr
000008  b570              PUSH     {r4-r6,lr}            ;439
00000a  4604              MOV      r4,r0                 ;439
00000c  6ec0              LDR      r0,[r0,#0x6c]         ;449
00000e  4615              MOV      r5,r2                 ;439
000010  460e              MOV      r6,r1                 ;439
000012  b920              CBNZ     r0,|L10.30|
000014  2000              MOVS     r0,#0                 ;452
000016  66a0              STR      r0,[r4,#0x68]         ;455
000018  4620              MOV      r0,r4                 ;455
00001a  f7fffffe          BL       HAL_UART_MspInit
                  |L10.30|
00001e  2024              MOVS     r0,#0x24              ;458
000020  66e0              STR      r0,[r4,#0x6c]         ;458
000022  6820              LDR      r0,[r4,#0]            ;461
000024  6801              LDR      r1,[r0,#0]            ;461
000026  f0210101          BIC      r1,r1,#1              ;461
00002a  6001              STR      r1,[r0,#0]            ;461
00002c  4620              MOV      r0,r4                 ;464
00002e  f7fffffe          BL       UART_SetConfig
000032  2801              CMP      r0,#1                 ;464
000034  bf08              IT       EQ
000036  bd70              POPEQ    {r4-r6,pc}
000038  6a60              LDR      r0,[r4,#0x24]         ;469
00003a  2800              CMP      r0,#0                 ;469
00003c  bf1c              ITT      NE                    ;471
00003e  4620              MOVNE    r0,r4                 ;471
000040  f7fffffe          BLNE     UART_AdvFeatureConfig
000044  6820              LDR      r0,[r4,#0]            ;480
000046  f5b56f00          CMP      r5,#0x800             ;480
00004a  6841              LDR      r1,[r0,#4]            ;477
00004c  f4214190          BIC      r1,r1,#0x4800         ;477
000050  6041              STR      r1,[r0,#4]            ;477
000052  6820              LDR      r0,[r4,#0]            ;478
000054  6881              LDR      r1,[r0,#8]            ;478
000056  f021012a          BIC      r1,r1,#0x2a           ;478
00005a  6081              STR      r1,[r0,#8]            ;478
00005c  d104              BNE      |L10.104|
00005e  6820              LDR      r0,[r4,#0]            ;483
000060  6841              LDR      r1,[r0,#4]            ;483
000062  f366611f          BFI      r1,r6,#24,#8          ;483
000066  6041              STR      r1,[r0,#4]            ;483
                  |L10.104|
000068  6820              LDR      r0,[r4,#0]            ;487
00006a  6801              LDR      r1,[r0,#0]            ;487
00006c  f4216100          BIC      r1,r1,#0x800          ;487
000070  4329              ORRS     r1,r1,r5              ;487
000072  6001              STR      r1,[r0,#0]            ;487
000074  6820              LDR      r0,[r4,#0]            ;490
000076  6801              LDR      r1,[r0,#0]            ;490
000078  f0410101          ORR      r1,r1,#1              ;490
00007c  6001              STR      r1,[r0,#0]            ;490
00007e  4620              MOV      r0,r4                 ;493
000080  e8bd4070          POP      {r4-r6,lr}            ;493
000084  f7ffbffe          B.W      UART_CheckIdleState
;;;495    
                          ENDP


                          AREA ||i.HAL_RS485Ex_Init||, CODE, READONLY, ALIGN=1

                  HAL_RS485Ex_Init PROC
;;;515      */
;;;516    HAL_StatusTypeDef HAL_RS485Ex_Init(UART_HandleTypeDef *huart, uint32_t Polarity, uint32_t AssertionTime, uint32_t DeassertionTime)
000000  2800              CMP      r0,#0
;;;517    {
;;;518      uint32_t temp = 0x0;
;;;519    
;;;520      /* Check the UART handle allocation */
;;;521      if(huart == NULL)
;;;522      {
;;;523        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;524      }
;;;525      /* Check the Driver Enable UART instance */
;;;526      assert_param(IS_UART_DRIVER_ENABLE_INSTANCE(huart->Instance));
;;;527    
;;;528      /* Check the Driver Enable polarity */
;;;529      assert_param(IS_UART_DE_POLARITY(Polarity));
;;;530    
;;;531      /* Check the Driver Enable assertion time */
;;;532      assert_param(IS_UART_ASSERTIONTIME(AssertionTime));
;;;533    
;;;534      /* Check the Driver Enable deassertion time */
;;;535      assert_param(IS_UART_DEASSERTIONTIME(DeassertionTime));
;;;536    
;;;537      if(huart->gState == HAL_UART_STATE_RESET)
;;;538      {
;;;539        /* Allocate lock resource and initialize it */
;;;540        huart->Lock = HAL_UNLOCKED;
;;;541    
;;;542        /* Init the low level hardware : GPIO, CLOCK, CORTEX */
;;;543        HAL_UART_MspInit(huart);
;;;544      }
;;;545    
;;;546      huart->gState = HAL_UART_STATE_BUSY;
;;;547    
;;;548      /* Disable the Peripheral */
;;;549      __HAL_UART_DISABLE(huart);
;;;550    
;;;551      /* Set the UART Communication parameters */
;;;552      if (UART_SetConfig(huart) == HAL_ERROR)
;;;553      {
;;;554        return HAL_ERROR;
;;;555      }
;;;556    
;;;557      if(huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;558      {
;;;559        UART_AdvFeatureConfig(huart);
;;;560      }
;;;561    
;;;562      /* Enable the Driver Enable mode by setting the DEM bit in the CR3 register */
;;;563      SET_BIT(huart->Instance->CR3, USART_CR3_DEM);
;;;564    
;;;565      /* Set the Driver Enable polarity */
;;;566      MODIFY_REG(huart->Instance->CR3, USART_CR3_DEP, Polarity);
;;;567    
;;;568      /* Set the Driver Enable assertion and deassertion times */
;;;569      temp = (AssertionTime << UART_CR1_DEAT_ADDRESS_LSB_POS);
;;;570      temp |= (DeassertionTime << UART_CR1_DEDT_ADDRESS_LSB_POS);
;;;571      MODIFY_REG(huart->Instance->CR1, (USART_CR1_DEDT|USART_CR1_DEAT), temp);
;;;572    
;;;573      /* Enable the Peripheral */
;;;574      __HAL_UART_ENABLE(huart);
;;;575    
;;;576      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;577      return (UART_CheckIdleState(huart));
;;;578    }
000006  4770              BXEQ     lr
000008  e92d41f0          PUSH     {r4-r8,lr}            ;517
00000c  4604              MOV      r4,r0                 ;517
00000e  6ec0              LDR      r0,[r0,#0x6c]         ;537
000010  461d              MOV      r5,r3                 ;517
000012  4616              MOV      r6,r2                 ;517
000014  460f              MOV      r7,r1                 ;517
000016  b920              CBNZ     r0,|L11.34|
000018  2000              MOVS     r0,#0                 ;540
00001a  66a0              STR      r0,[r4,#0x68]         ;543
00001c  4620              MOV      r0,r4                 ;543
00001e  f7fffffe          BL       HAL_UART_MspInit
                  |L11.34|
000022  2024              MOVS     r0,#0x24              ;546
000024  66e0              STR      r0,[r4,#0x6c]         ;546
000026  6820              LDR      r0,[r4,#0]            ;549
000028  6801              LDR      r1,[r0,#0]            ;549
00002a  f0210101          BIC      r1,r1,#1              ;549
00002e  6001              STR      r1,[r0,#0]            ;549
000030  4620              MOV      r0,r4                 ;552
000032  f7fffffe          BL       UART_SetConfig
000036  2801              CMP      r0,#1                 ;552
000038  bf08              IT       EQ
00003a  e8bd81f0          POPEQ    {r4-r8,pc}
00003e  6a60              LDR      r0,[r4,#0x24]         ;557
000040  2800              CMP      r0,#0                 ;557
000042  bf1c              ITT      NE                    ;559
000044  4620              MOVNE    r0,r4                 ;559
000046  f7fffffe          BLNE     UART_AdvFeatureConfig
00004a  0571              LSLS     r1,r6,#21             ;569
00004c  6820              LDR      r0,[r4,#0]            ;563
00004e  6882              LDR      r2,[r0,#8]            ;563
000050  ea414105          ORR      r1,r1,r5,LSL #16      ;570
000054  f4424280          ORR      r2,r2,#0x4000         ;563
000058  6082              STR      r2,[r0,#8]            ;563
00005a  6820              LDR      r0,[r4,#0]            ;566
00005c  6882              LDR      r2,[r0,#8]            ;566
00005e  f4224200          BIC      r2,r2,#0x8000         ;566
000062  433a              ORRS     r2,r2,r7              ;566
000064  6082              STR      r2,[r0,#8]            ;566
000066  6820              LDR      r0,[r4,#0]            ;571
000068  6802              LDR      r2,[r0,#0]            ;571
00006a  f36f4219          BFC      r2,#16,#10            ;571
00006e  4311              ORRS     r1,r1,r2              ;571
000070  6001              STR      r1,[r0,#0]            ;571
000072  6820              LDR      r0,[r4,#0]            ;574
000074  6801              LDR      r1,[r0,#0]            ;574
000076  f0410101          ORR      r1,r1,#1              ;574
00007a  6001              STR      r1,[r0,#0]            ;574
00007c  4620              MOV      r0,r4                 ;577
00007e  e8bd41f0          POP      {r4-r8,lr}            ;577
000082  f7ffbffe          B.W      UART_CheckIdleState
;;;579    
                          ENDP


                          AREA ||i.HAL_UART_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAPause PROC
;;;1071     */
;;;1072   HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
000000  6e81              LDR      r1,[r0,#0x68]
;;;1073   {
;;;1074     /* Process Locked */
;;;1075     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;1076   
;;;1077     if ((huart->gState == HAL_UART_STATE_BUSY_TX) &&
;;;1078         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)))
;;;1079     {
;;;1080       /* Disable the UART DMA Tx request */
;;;1081       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1082     }
;;;1083     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) &&
;;;1084         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
;;;1085     {
;;;1086       /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1087       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1088       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1089   
;;;1090       /* Disable the UART DMA Rx request */
;;;1091       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1092     }
;;;1093   
;;;1094     /* Process Unlocked */
;;;1095     __HAL_UNLOCK(huart);
;;;1096   
;;;1097     return HAL_OK;
;;;1098   }
000008  4770              BXEQ     lr
00000a  6ec2              LDR      r2,[r0,#0x6c]         ;1077
00000c  2101              MOVS     r1,#1                 ;1075
00000e  6681              STR      r1,[r0,#0x68]         ;1077
000010  2a21              CMP      r2,#0x21              ;1077
000012  d108              BNE      |L12.38|
000014  6801              LDR      r1,[r0,#0]            ;1077
000016  688a              LDR      r2,[r1,#8]            ;1077
000018  f0120f80          TST      r2,#0x80              ;1077
00001c  d003              BEQ      |L12.38|
00001e  688a              LDR      r2,[r1,#8]            ;1081
000020  f0220280          BIC      r2,r2,#0x80           ;1081
000024  608a              STR      r2,[r1,#8]            ;1081
                  |L12.38|
000026  6f01              LDR      r1,[r0,#0x70]         ;1083
000028  2922              CMP      r1,#0x22              ;1083
00002a  d112              BNE      |L12.82|
00002c  6801              LDR      r1,[r0,#0]            ;1083
00002e  688a              LDR      r2,[r1,#8]            ;1083
000030  f0120f40          TST      r2,#0x40              ;1083
000034  d00d              BEQ      |L12.82|
000036  680a              LDR      r2,[r1,#0]            ;1087
000038  f4227280          BIC      r2,r2,#0x100          ;1087
00003c  600a              STR      r2,[r1,#0]            ;1087
00003e  6801              LDR      r1,[r0,#0]            ;1088
000040  688a              LDR      r2,[r1,#8]            ;1088
000042  f0220201          BIC      r2,r2,#1              ;1088
000046  608a              STR      r2,[r1,#8]            ;1088
000048  6801              LDR      r1,[r0,#0]            ;1091
00004a  688a              LDR      r2,[r1,#8]            ;1091
00004c  f0220240          BIC      r2,r2,#0x40           ;1091
000050  608a              STR      r2,[r1,#8]            ;1091
                  |L12.82|
000052  2100              MOVS     r1,#0                 ;1095
000054  6681              STR      r1,[r0,#0x68]         ;1097
000056  4608              MOV      r0,r1                 ;1097
000058  4770              BX       lr
;;;1099   
                          ENDP


                          AREA ||i.HAL_UART_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAResume PROC
;;;1104     */
;;;1105   HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
000000  6e81              LDR      r1,[r0,#0x68]
;;;1106   {
;;;1107     /* Process Locked */
;;;1108     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;1109   
;;;1110     if(huart->gState == HAL_UART_STATE_BUSY_TX)
;;;1111     {
;;;1112       /* Enable the UART DMA Tx request */
;;;1113       SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1114     }
;;;1115     if(huart->RxState == HAL_UART_STATE_BUSY_RX)
;;;1116     {
;;;1117       /* Clear the Overrun flag before resuming the Rx transfer*/
;;;1118       __HAL_UART_CLEAR_IT(huart, UART_CLEAR_OREF);
;;;1119   
;;;1120       /* Reenable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1121       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1122       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1123   
;;;1124       /* Enable the UART DMA Rx request */
;;;1125       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1126     }
;;;1127   
;;;1128     /* If the UART peripheral is still not enabled, enable it */
;;;1129     if ((huart->Instance->CR1 & USART_CR1_UE) == 0U)
;;;1130     {
;;;1131       /* Enable UART peripheral */
;;;1132       __HAL_UART_ENABLE(huart);
;;;1133     }
;;;1134   
;;;1135     return HAL_OK;
;;;1136   }
000008  4770              BXEQ     lr
00000a  6ec2              LDR      r2,[r0,#0x6c]         ;1110
00000c  2101              MOVS     r1,#1                 ;1108
00000e  6681              STR      r1,[r0,#0x68]         ;1110
000010  2a21              CMP      r2,#0x21              ;1110
000012  d104              BNE      |L13.30|
000014  6801              LDR      r1,[r0,#0]            ;1113
000016  688a              LDR      r2,[r1,#8]            ;1113
000018  f0420280          ORR      r2,r2,#0x80           ;1113
00001c  608a              STR      r2,[r1,#8]            ;1113
                  |L13.30|
00001e  6f01              LDR      r1,[r0,#0x70]         ;1115
000020  2922              CMP      r1,#0x22              ;1115
000022  d111              BNE      |L13.72|
000024  6802              LDR      r2,[r0,#0]            ;1118
000026  2108              MOVS     r1,#8                 ;1118
000028  6211              STR      r1,[r2,#0x20]         ;1118
00002a  6801              LDR      r1,[r0,#0]            ;1121
00002c  680a              LDR      r2,[r1,#0]            ;1121
00002e  f4427280          ORR      r2,r2,#0x100          ;1121
000032  600a              STR      r2,[r1,#0]            ;1121
000034  6801              LDR      r1,[r0,#0]            ;1122
000036  688a              LDR      r2,[r1,#8]            ;1122
000038  f0420201          ORR      r2,r2,#1              ;1122
00003c  608a              STR      r2,[r1,#8]            ;1122
00003e  6801              LDR      r1,[r0,#0]            ;1125
000040  688a              LDR      r2,[r1,#8]            ;1125
000042  f0420240          ORR      r2,r2,#0x40           ;1125
000046  608a              STR      r2,[r1,#8]            ;1125
                  |L13.72|
000048  6800              LDR      r0,[r0,#0]            ;1129
00004a  6801              LDR      r1,[r0,#0]            ;1129
00004c  f0110f01          TST      r1,#1                 ;1129
000050  d103              BNE      |L13.90|
000052  6801              LDR      r1,[r0,#0]            ;1132
000054  f0410101          ORR      r1,r1,#1              ;1132
000058  6001              STR      r1,[r0,#0]            ;1132
                  |L13.90|
00005a  2000              MOVS     r0,#0                 ;1135
00005c  4770              BX       lr
;;;1137   
                          ENDP


                          AREA ||i.HAL_UART_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAStop PROC
;;;1142     */
;;;1143   HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1144   {
000002  4604              MOV      r4,r0
;;;1145     /* The Lock is not implemented on this API to allow the user application
;;;1146        to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback() /
;;;1147        HAL_UART_TxHalfCpltCallback / HAL_UART_RxHalfCpltCallback:
;;;1148        indeed, when HAL_DMA_Abort() API is called, the DMA TX/RX Transfer or Half Transfer complete
;;;1149        interrupt is generated if the DMA transfer interruption occurs at the middle or at the end of
;;;1150        the stream and the corresponding call back is executed. */
;;;1151   
;;;1152     /* Stop UART DMA Tx request if ongoing */
;;;1153     if ((huart->gState == HAL_UART_STATE_BUSY_TX) &&
000004  6ec0              LDR      r0,[r0,#0x6c]
000006  2520              MOVS     r5,#0x20
000008  2821              CMP      r0,#0x21
00000a  d113              BNE      |L14.52|
;;;1154         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)))
00000c  6820              LDR      r0,[r4,#0]
00000e  6881              LDR      r1,[r0,#8]
000010  f0110f80          TST      r1,#0x80
000014  d00e              BEQ      |L14.52|
;;;1155     {
;;;1156       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000016  6881              LDR      r1,[r0,#8]
000018  f0210180          BIC      r1,r1,#0x80
00001c  6081              STR      r1,[r0,#8]
;;;1157   
;;;1158       /* Abort the UART DMA Tx channel */
;;;1159       if(huart->hdmatx != NULL)
00001e  6e20              LDR      r0,[r4,#0x60]
000020  2800              CMP      r0,#0
;;;1160       {
;;;1161         HAL_DMA_Abort(huart->hdmatx);
000022  bf18              IT       NE
000024  f7fffffe          BLNE     HAL_DMA_Abort
000028  6820              LDR      r0,[r4,#0]
00002a  6801              LDR      r1,[r0,#0]
00002c  f02101c0          BIC      r1,r1,#0xc0
000030  6001              STR      r1,[r0,#0]
000032  66e5              STR      r5,[r4,#0x6c]
                  |L14.52|
;;;1162       }
;;;1163   
;;;1164       UART_EndTxTransfer(huart);
;;;1165     }
;;;1166   
;;;1167     /* Stop UART DMA Rx request if ongoing */
;;;1168     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) &&
000034  6f20              LDR      r0,[r4,#0x70]
000036  2822              CMP      r0,#0x22
000038  d118              BNE      |L14.108|
;;;1169         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
00003a  6820              LDR      r0,[r4,#0]
00003c  6881              LDR      r1,[r0,#8]
00003e  f0110f40          TST      r1,#0x40
000042  d013              BEQ      |L14.108|
;;;1170     {
;;;1171       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000044  6881              LDR      r1,[r0,#8]
000046  f0210140          BIC      r1,r1,#0x40
00004a  6081              STR      r1,[r0,#8]
;;;1172   
;;;1173       /* Abort the UART DMA Rx channel */
;;;1174       if(huart->hdmarx != NULL)
00004c  6e60              LDR      r0,[r4,#0x64]
00004e  2800              CMP      r0,#0
;;;1175       {
;;;1176         HAL_DMA_Abort(huart->hdmarx);
000050  bf18              IT       NE
000052  f7fffffe          BLNE     HAL_DMA_Abort
000056  6820              LDR      r0,[r4,#0]
000058  6801              LDR      r1,[r0,#0]
00005a  f4217190          BIC      r1,r1,#0x120
00005e  6001              STR      r1,[r0,#0]
000060  6820              LDR      r0,[r4,#0]
000062  6881              LDR      r1,[r0,#8]
000064  f0210101          BIC      r1,r1,#1
000068  6081              STR      r1,[r0,#8]
00006a  6725              STR      r5,[r4,#0x70]
                  |L14.108|
;;;1177       }
;;;1178   
;;;1179       UART_EndRxTransfer(huart);
;;;1180     }
;;;1181   
;;;1182     return HAL_OK;
00006c  2000              MOVS     r0,#0
;;;1183   }
00006e  bd70              POP      {r4-r6,pc}
;;;1184   
                          ENDP


                          AREA ||i.HAL_UART_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_DeInit PROC
;;;584      */
;;;585    HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
000000  2800              CMP      r0,#0
;;;586    {
;;;587      /* Check the UART handle allocation */
;;;588      if(huart == NULL)
;;;589      {
;;;590        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;591      }
;;;592    
;;;593      /* Check the parameters */
;;;594      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;595    
;;;596      huart->gState = HAL_UART_STATE_BUSY;
;;;597    
;;;598      /* Disable the Peripheral */
;;;599      __HAL_UART_DISABLE(huart);
;;;600    
;;;601      huart->Instance->CR1 = 0x0U;
;;;602      huart->Instance->CR2 = 0x0U;
;;;603      huart->Instance->CR3 = 0x0U;
;;;604    
;;;605      /* DeInit the low level hardware */
;;;606      HAL_UART_MspDeInit(huart);
;;;607    
;;;608      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;609      huart->gState    = HAL_UART_STATE_RESET;
;;;610      huart->RxState   = HAL_UART_STATE_RESET;
;;;611    
;;;612      /* Process Unlock */
;;;613      __HAL_UNLOCK(huart);
;;;614    
;;;615      return HAL_OK;
;;;616    }
000006  4770              BXEQ     lr
000008  b570              PUSH     {r4-r6,lr}            ;586
00000a  4604              MOV      r4,r0                 ;586
00000c  2024              MOVS     r0,#0x24              ;596
00000e  2500              MOVS     r5,#0                 ;601
000010  66e0              STR      r0,[r4,#0x6c]         ;596
000012  6820              LDR      r0,[r4,#0]            ;599
000014  6801              LDR      r1,[r0,#0]            ;599
000016  f0210101          BIC      r1,r1,#1              ;599
00001a  6001              STR      r1,[r0,#0]            ;599
00001c  6820              LDR      r0,[r4,#0]            ;601
00001e  6005              STR      r5,[r0,#0]            ;601
000020  6820              LDR      r0,[r4,#0]            ;602
000022  6045              STR      r5,[r0,#4]            ;602
000024  6820              LDR      r0,[r4,#0]            ;603
000026  6085              STR      r5,[r0,#8]            ;603
000028  4620              MOV      r0,r4                 ;606
00002a  f7fffffe          BL       HAL_UART_MspDeInit
00002e  6765              STR      r5,[r4,#0x74]         ;608
000030  66e5              STR      r5,[r4,#0x6c]         ;609
000032  6725              STR      r5,[r4,#0x70]         ;610
000034  2000              MOVS     r0,#0                 ;615
000036  66a5              STR      r5,[r4,#0x68]         ;615
000038  bd70              POP      {r4-r6,pc}
;;;617    
                          ENDP


                          AREA ||i.HAL_UART_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_ErrorCallback PROC
;;;1547     */
;;;1548    __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1549   {
;;;1550     /* Prevent unused argument(s) compilation warning */
;;;1551     UNUSED(huart);
;;;1552   
;;;1553     /* NOTE : This function should not be modified, when the callback is needed,
;;;1554               the HAL_UART_ErrorCallback can be implemented in the user file
;;;1555      */
;;;1556   }
;;;1557   
                          ENDP


                          AREA ||i.HAL_UART_GetError||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetError PROC
;;;1814   */
;;;1815   uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
000000  6f40              LDR      r0,[r0,#0x74]
;;;1816   {
;;;1817     return huart->ErrorCode;
;;;1818   }
000002  4770              BX       lr
;;;1819   
                          ENDP


                          AREA ||i.HAL_UART_GetState||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetState PROC
;;;1799     */
;;;1800   HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
000000  6ec1              LDR      r1,[r0,#0x6c]
;;;1801   {
;;;1802     uint32_t temp1= 0x00U, temp2 = 0x00U;
;;;1803     temp1 = huart->gState;
;;;1804     temp2 = huart->RxState;
000002  6f00              LDR      r0,[r0,#0x70]
;;;1805   
;;;1806     return (HAL_UART_StateTypeDef)(temp1 | temp2);
000004  4308              ORRS     r0,r0,r1
;;;1807   }
000006  4770              BX       lr
;;;1808   
                          ENDP


                          AREA ||i.HAL_UART_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_UART_IRQHandler PROC
;;;1189     */
;;;1190   void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1191   {
;;;1192     uint32_t isrflags   = READ_REG(huart->Instance->ISR);
000002  6801              LDR      r1,[r0,#0]
000004  4604              MOV      r4,r0                 ;1191
000006  2520              MOVS     r5,#0x20              ;1191
000008  69c8              LDR      r0,[r1,#0x1c]
;;;1193     uint32_t cr1its     = READ_REG(huart->Instance->CR1);
00000a  680a              LDR      r2,[r1,#0]
;;;1194     uint32_t cr3its     = READ_REG(huart->Instance->CR3);
00000c  688b              LDR      r3,[r1,#8]
;;;1195     uint32_t errorflags;
;;;1196   
;;;1197     /* If no error occurs */
;;;1198     errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE));
00000e  f0100f0f          TST      r0,#0xf
000012  d056              BEQ      |L19.194|
;;;1199     if (errorflags == RESET)
;;;1200     {
;;;1201       /* UART in mode Receiver ---------------------------------------------------*/
;;;1202       if(((isrflags & USART_ISR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
;;;1203       {
;;;1204         UART_Receive_IT(huart);
;;;1205         return;
;;;1206       }
;;;1207     }
;;;1208   
;;;1209     /* If some errors occur */
;;;1210     if(   (errorflags != RESET)
;;;1211        && (   ((cr3its & USART_CR3_EIE) != RESET)
000014  f0030c01          AND      r12,r3,#1
000018  f4027690          AND      r6,r2,#0x120
00001c  ea5c0606          ORRS     r6,r12,r6
000020  f00080ea          BEQ.W    |L19.504|
;;;1212            || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)) )
;;;1213     {
;;;1214   
;;;1215       /* UART parity error interrupt occurred -------------------------------------*/
;;;1216       if(((isrflags & USART_ISR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
000024  f0100f01          TST      r0,#1
000028  bf18              IT       NE
00002a  f4127f80          TSTNE    r2,#0x100
00002e  d005              BEQ      |L19.60|
;;;1217       {
;;;1218         __HAL_UART_CLEAR_IT(huart, UART_CLEAR_PEF);
000030  2601              MOVS     r6,#1
000032  620e              STR      r6,[r1,#0x20]
;;;1219   
;;;1220         huart->ErrorCode |= HAL_UART_ERROR_PE;
000034  6f61              LDR      r1,[r4,#0x74]
000036  f0410101          ORR      r1,r1,#1
00003a  6761              STR      r1,[r4,#0x74]
                  |L19.60|
;;;1221       }
;;;1222   
;;;1223       /* UART frame error interrupt occurred --------------------------------------*/
;;;1224       if(((isrflags & USART_ISR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
00003c  f0100f02          TST      r0,#2
000040  bf18              IT       NE
000042  f0130f01          TSTNE    r3,#1
000046  d006              BEQ      |L19.86|
;;;1225       {
;;;1226         __HAL_UART_CLEAR_IT(huart, UART_CLEAR_FEF);
000048  6826              LDR      r6,[r4,#0]
00004a  2102              MOVS     r1,#2
00004c  6231              STR      r1,[r6,#0x20]
;;;1227   
;;;1228         huart->ErrorCode |= HAL_UART_ERROR_FE;
00004e  6f61              LDR      r1,[r4,#0x74]
000050  f0410104          ORR      r1,r1,#4
000054  6761              STR      r1,[r4,#0x74]
                  |L19.86|
;;;1229       }
;;;1230   
;;;1231       /* UART noise error interrupt occurred --------------------------------------*/
;;;1232       if(((isrflags & USART_ISR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
000056  f0100f04          TST      r0,#4
00005a  bf18              IT       NE
00005c  f0130f01          TSTNE    r3,#1
000060  d006              BEQ      |L19.112|
;;;1233       {
;;;1234         __HAL_UART_CLEAR_IT(huart, UART_CLEAR_NEF);
000062  6823              LDR      r3,[r4,#0]
000064  2104              MOVS     r1,#4
000066  6219              STR      r1,[r3,#0x20]
;;;1235   
;;;1236         huart->ErrorCode |= HAL_UART_ERROR_NE;
000068  6f61              LDR      r1,[r4,#0x74]
00006a  f0410102          ORR      r1,r1,#2
00006e  6761              STR      r1,[r4,#0x74]
                  |L19.112|
;;;1237       }
;;;1238       
;;;1239       /* UART Over-Run interrupt occurred -----------------------------------------*/
;;;1240       if(((isrflags & USART_ISR_ORE) != RESET) &&
000070  f0100f08          TST      r0,#8
;;;1241          (((cr1its & USART_CR1_RXNEIE) != RESET) || ((cr3its & USART_CR3_EIE) != RESET)))
000074  bf1c              ITT      NE
000076  f0020120          ANDNE    r1,r2,#0x20
00007a  ea51010c          ORRSNE   r1,r1,r12
00007e  d006              BEQ      |L19.142|
;;;1242       {
;;;1243         __HAL_UART_CLEAR_IT(huart, UART_CLEAR_OREF);
000080  6823              LDR      r3,[r4,#0]
000082  2108              MOVS     r1,#8
000084  6219              STR      r1,[r3,#0x20]
;;;1244   
;;;1245         huart->ErrorCode |= HAL_UART_ERROR_ORE;
000086  6f61              LDR      r1,[r4,#0x74]
000088  f0410108          ORR      r1,r1,#8
00008c  6761              STR      r1,[r4,#0x74]
                  |L19.142|
;;;1246       }
;;;1247   
;;;1248       /* Call UART Error Call back function if need be --------------------------*/
;;;1249       if(huart->ErrorCode != HAL_UART_ERROR_NONE)
00008e  6f61              LDR      r1,[r4,#0x74]
000090  2900              CMP      r1,#0
;;;1250       {
;;;1251         /* UART in mode Receiver ---------------------------------------------------*/
;;;1252         if(((isrflags & USART_ISR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
;;;1253         {
;;;1254           UART_Receive_IT(huart);
;;;1255         }
;;;1256   
;;;1257         /* If Overrun error occurs, or if any error occurs in DMA mode reception,
;;;1258            consider error as blocking */
;;;1259         if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) ||
;;;1260             (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
;;;1261         {
;;;1262           /* Blocking error : transfer is aborted
;;;1263              Set the UART state ready to be able to start again the process,
;;;1264              Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
;;;1265           UART_EndRxTransfer(huart);
;;;1266   
;;;1267           /* Disable the UART DMA Rx request if enabled */
;;;1268           if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
;;;1269           {
;;;1270             CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1271   
;;;1272             /* Abort the UART DMA Rx channel */
;;;1273             if(huart->hdmarx != NULL)
;;;1274             {
;;;1275               /* Set the UART DMA Abort callback :
;;;1276               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
;;;1277               huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
;;;1278   
;;;1279               /* Abort DMA RX */
;;;1280               if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
;;;1281               {
;;;1282                 /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
;;;1283                 huart->hdmarx->XferAbortCallback(huart->hdmarx);
;;;1284               }
;;;1285             }
;;;1286             else
;;;1287             {
;;;1288               /* Call user error callback */
;;;1289               HAL_UART_ErrorCallback(huart);
;;;1290             }
;;;1291           }
;;;1292           else
;;;1293           {
;;;1294             /* Call user error callback */
;;;1295             HAL_UART_ErrorCallback(huart);
;;;1296           }
;;;1297         }
;;;1298         else
;;;1299         {
;;;1300           /* Non Blocking error : transfer could go on.
;;;1301              Error is notified to user through user error callback */
;;;1302           HAL_UART_ErrorCallback(huart);
;;;1303           huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1304         }
;;;1305       }
;;;1306       return;
;;;1307   
;;;1308     } /* End if some error occurs */
;;;1309   
;;;1310     /* UART in mode Transmitter ------------------------------------------------*/
;;;1311     if(((isrflags & USART_ISR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
;;;1312     {
;;;1313       UART_Transmit_IT(huart);
;;;1314       return;
;;;1315     }
;;;1316   
;;;1317     /* UART in mode Transmitter (transmission end) -----------------------------*/
;;;1318     if(((isrflags & USART_ISR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
;;;1319     {
;;;1320       UART_EndTransmit_IT(huart);
;;;1321       return;
;;;1322     }
;;;1323   
;;;1324   }
000092  bf08              IT       EQ
000094  bd70              POPEQ    {r4-r6,pc}
000096  f0100f20          TST      r0,#0x20              ;1252
00009a  bf18              IT       NE                    ;1252
00009c  f0120f20          TSTNE    r2,#0x20              ;1252
0000a0  d00a              BEQ      |L19.184|
0000a2  6f22              LDR      r2,[r4,#0x70]         ;1252
0000a4  4620              MOV      r0,r4                 ;1254
0000a6  f8b4105c          LDRH     r1,[r4,#0x5c]         ;1254
0000aa  2a22              CMP      r2,#0x22              ;1254
0000ac  d044              BEQ      |L19.312|
0000ae  6820              LDR      r0,[r4,#0]            ;1254
0000b0  6981              LDR      r1,[r0,#0x18]         ;1254
0000b2  f0410108          ORR      r1,r1,#8              ;1254
0000b6  6181              STR      r1,[r0,#0x18]         ;1254
                  |L19.184|
0000b8  6f60              LDR      r0,[r4,#0x74]         ;1259
0000ba  f0100f08          TST      r0,#8                 ;1259
0000be  d16c              BNE      |L19.410|
0000c0  e066              B        |L19.400|
                  |L19.194|
0000c2  f0100f20          TST      r0,#0x20              ;1202
0000c6  bf18              IT       NE                    ;1202
0000c8  f0120f20          TSTNE    r2,#0x20              ;1202
0000cc  d07e              BEQ      |L19.460|
0000ce  6f23              LDR      r3,[r4,#0x70]         ;1202
0000d0  4620              MOV      r0,r4                 ;1204
0000d2  f8b4205c          LDRH     r2,[r4,#0x5c]         ;1204
0000d6  2b22              CMP      r3,#0x22              ;1204
0000d8  d004              BEQ      |L19.228|
0000da  6988              LDR      r0,[r1,#0x18]         ;1204
0000dc  f0400008          ORR      r0,r0,#8              ;1204
0000e0  6188              STR      r0,[r1,#0x18]         ;1204
0000e2  bd70              POP      {r4-r6,pc}
                  |L19.228|
0000e4  6883              LDR      r3,[r0,#8]
0000e6  f5b35f80          CMP      r3,#0x1000
0000ea  bf04              ITT      EQ
0000ec  6903              LDREQ    r3,[r0,#0x10]
0000ee  2b00              CMPEQ    r3,#0
0000f0  6a4b              LDR      r3,[r1,#0x24]
0000f2  6d41              LDR      r1,[r0,#0x54]
0000f4  ea030202          AND      r2,r3,r2
0000f8  d019              BEQ      |L19.302|
0000fa  1c4b              ADDS     r3,r1,#1
0000fc  6543              STR      r3,[r0,#0x54]
0000fe  700a              STRB     r2,[r1,#0]
                  |L19.256|
000100  f8b0105a          LDRH     r1,[r0,#0x5a]
000104  1e49              SUBS     r1,r1,#1
000106  0409              LSLS     r1,r1,#16
000108  0c09              LSRS     r1,r1,#16
00010a  f8a0105a          STRH     r1,[r0,#0x5a]
00010e  bf18              IT       NE
000110  bd70              POPNE    {r4-r6,pc}
000112  6801              LDR      r1,[r0,#0]
000114  680a              LDR      r2,[r1,#0]
000116  f4227290          BIC      r2,r2,#0x120
00011a  600a              STR      r2,[r1,#0]
00011c  6801              LDR      r1,[r0,#0]
00011e  688a              LDR      r2,[r1,#8]
000120  f0220201          BIC      r2,r2,#1
000124  608a              STR      r2,[r1,#8]
000126  6705              STR      r5,[r0,#0x70]
000128  f7fffffe          BL       HAL_UART_RxCpltCallback
00012c  bd70              POP      {r4-r6,pc}
                  |L19.302|
00012e  800a              STRH     r2,[r1,#0]
000130  6d41              LDR      r1,[r0,#0x54]
000132  1c89              ADDS     r1,r1,#2
000134  6541              STR      r1,[r0,#0x54]
000136  e7e3              B        |L19.256|
                  |L19.312|
000138  6882              LDR      r2,[r0,#8]
00013a  f5b25f80          CMP      r2,#0x1000
00013e  bf04              ITT      EQ
000140  6902              LDREQ    r2,[r0,#0x10]
000142  2a00              CMPEQ    r2,#0
000144  6803              LDR      r3,[r0,#0]
000146  6d42              LDR      r2,[r0,#0x54]
000148  6a5b              LDR      r3,[r3,#0x24]
00014a  d01b              BEQ      |L19.388|
00014c  f1020c01          ADD      r12,r2,#1
000150  f8c0c054          STR      r12,[r0,#0x54]
000154  4019              ANDS     r1,r1,r3
000156  7011              STRB     r1,[r2,#0]
                  |L19.344|
000158  f8b0105a          LDRH     r1,[r0,#0x5a]
00015c  1e49              SUBS     r1,r1,#1
00015e  0409              LSLS     r1,r1,#16
000160  0c09              LSRS     r1,r1,#16
000162  f8a0105a          STRH     r1,[r0,#0x5a]
000166  d1a7              BNE      |L19.184|
000168  6801              LDR      r1,[r0,#0]
00016a  680a              LDR      r2,[r1,#0]
00016c  f4227290          BIC      r2,r2,#0x120
000170  600a              STR      r2,[r1,#0]
000172  6801              LDR      r1,[r0,#0]
000174  688a              LDR      r2,[r1,#8]
000176  f0220201          BIC      r2,r2,#1
00017a  608a              STR      r2,[r1,#8]
00017c  6705              STR      r5,[r0,#0x70]
00017e  f7fffffe          BL       HAL_UART_RxCpltCallback
000182  e799              B        |L19.184|
                  |L19.388|
000184  4019              ANDS     r1,r1,r3
000186  8011              STRH     r1,[r2,#0]
000188  6d41              LDR      r1,[r0,#0x54]
00018a  1c89              ADDS     r1,r1,#2
00018c  6541              STR      r1,[r0,#0x54]
00018e  e7e3              B        |L19.344|
                  |L19.400|
000190  6820              LDR      r0,[r4,#0]            ;1260
000192  6880              LDR      r0,[r0,#8]            ;1260
000194  f0100f40          TST      r0,#0x40              ;1260
000198  d028              BEQ      |L19.492|
                  |L19.410|
00019a  6820              LDR      r0,[r4,#0]            ;1260
00019c  6801              LDR      r1,[r0,#0]            ;1260
00019e  f4217190          BIC      r1,r1,#0x120          ;1260
0001a2  6001              STR      r1,[r0,#0]            ;1260
0001a4  6820              LDR      r0,[r4,#0]            ;1260
0001a6  6881              LDR      r1,[r0,#8]            ;1260
0001a8  f0210101          BIC      r1,r1,#1              ;1260
0001ac  6081              STR      r1,[r0,#8]            ;1260
0001ae  6725              STR      r5,[r4,#0x70]         ;1260
0001b0  6820              LDR      r0,[r4,#0]            ;1268
0001b2  6881              LDR      r1,[r0,#8]            ;1268
0001b4  f0110f40          TST      r1,#0x40              ;1268
0001b8  d014              BEQ      |L19.484|
0001ba  6881              LDR      r1,[r0,#8]            ;1270
0001bc  f0210140          BIC      r1,r1,#0x40           ;1270
0001c0  6081              STR      r1,[r0,#8]            ;1270
0001c2  6e60              LDR      r0,[r4,#0x64]         ;1273
0001c4  b170              CBZ      r0,|L19.484|
0001c6  492d              LDR      r1,|L19.636|
0001c8  6541              STR      r1,[r0,#0x54]         ;1280
0001ca  e000              B        |L19.462|
                  |L19.460|
0001cc  e014              B        |L19.504|
                  |L19.462|
0001ce  6e60              LDR      r0,[r4,#0x64]         ;1280
0001d0  f7fffffe          BL       HAL_DMA_Abort_IT
0001d4  2800              CMP      r0,#0                 ;1280
0001d6  bf08              IT       EQ
0001d8  bd70              POPEQ    {r4-r6,pc}
0001da  6e60              LDR      r0,[r4,#0x64]         ;1283
0001dc  6d41              LDR      r1,[r0,#0x54]         ;1283
0001de  e8bd4070          POP      {r4-r6,lr}            ;1283
0001e2  4708              BX       r1                    ;1283
                  |L19.484|
0001e4  4620              MOV      r0,r4                 ;1295
0001e6  f7fffffe          BL       HAL_UART_ErrorCallback
0001ea  bd70              POP      {r4-r6,pc}
                  |L19.492|
0001ec  4620              MOV      r0,r4                 ;1302
0001ee  f7fffffe          BL       HAL_UART_ErrorCallback
0001f2  2000              MOVS     r0,#0                 ;1303
0001f4  6760              STR      r0,[r4,#0x74]         ;1303
0001f6  bd70              POP      {r4-r6,pc}
                  |L19.504|
0001f8  f0100f80          TST      r0,#0x80              ;1311
0001fc  bf18              IT       NE                    ;1311
0001fe  f0120f80          TSTNE    r2,#0x80              ;1311
000202  d02b              BEQ      |L19.604|
000204  6ee0              LDR      r0,[r4,#0x6c]         ;1311
000206  2821              CMP      r0,#0x21              ;1311
000208  bf18              IT       NE
00020a  bd70              POPNE    {r4-r6,pc}
00020c  f8b40052          LDRH     r0,[r4,#0x52]
000210  b190              CBZ      r0,|L19.568|
000212  68a0              LDR      r0,[r4,#8]
000214  f5b05f80          CMP      r0,#0x1000
000218  bf04              ITT      EQ
00021a  6920              LDREQ    r0,[r4,#0x10]
00021c  2800              CMPEQ    r0,#0
00021e  6ce0              LDR      r0,[r4,#0x4c]
000220  d014              BEQ      |L19.588|
000222  1c41              ADDS     r1,r0,#1
000224  64e1              STR      r1,[r4,#0x4c]
000226  6821              LDR      r1,[r4,#0]
000228  7800              LDRB     r0,[r0,#0]
00022a  6288              STR      r0,[r1,#0x28]
                  |L19.556|
00022c  f8b40052          LDRH     r0,[r4,#0x52]
000230  1e40              SUBS     r0,r0,#1
000232  f8a40052          STRH     r0,[r4,#0x52]
000236  bd70              POP      {r4-r6,pc}
                  |L19.568|
000238  6808              LDR      r0,[r1,#0]
00023a  f0200080          BIC      r0,r0,#0x80
00023e  6008              STR      r0,[r1,#0]
000240  6820              LDR      r0,[r4,#0]
000242  6801              LDR      r1,[r0,#0]
000244  f0410140          ORR      r1,r1,#0x40
000248  6001              STR      r1,[r0,#0]
00024a  bd70              POP      {r4-r6,pc}
                  |L19.588|
00024c  8800              LDRH     r0,[r0,#0]
00024e  f3c00008          UBFX     r0,r0,#0,#9
000252  6288              STR      r0,[r1,#0x28]
000254  6ce0              LDR      r0,[r4,#0x4c]
000256  1c80              ADDS     r0,r0,#2
000258  64e0              STR      r0,[r4,#0x4c]
00025a  e7e7              B        |L19.556|
                  |L19.604|
00025c  f0100f40          TST      r0,#0x40              ;1318
000260  bf14              ITE      NE                    ;1318
000262  f0120f40          TSTNE    r2,#0x40              ;1318
000266  bd70              POPEQ    {r4-r6,pc}
000268  680a              LDR      r2,[r1,#0]
00026a  4620              MOV      r0,r4                 ;1320
00026c  f0220240          BIC      r2,r2,#0x40           ;1320
000270  600a              STR      r2,[r1,#0]            ;1320
000272  66e5              STR      r5,[r4,#0x6c]         ;1320
000274  f7fffffe          BL       HAL_UART_TxCpltCallback
000278  bd70              POP      {r4-r6,pc}
;;;1325   
                          ENDP

00027a  0000              DCW      0x0000
                  |L19.636|
                          DCD      UART_DMAAbortOnError

                          AREA ||i.HAL_UART_Init||, CODE, READONLY, ALIGN=1

                  HAL_UART_Init PROC
;;;240      */
;;;241    HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
000000  2800              CMP      r0,#0
;;;242    {
;;;243      /* Check the UART handle allocation */
;;;244      if(huart == NULL)
;;;245      {
;;;246        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;247      }
;;;248    
;;;249      if(huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
;;;250      {
;;;251        /* Check the parameters */
;;;252        assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
;;;253      }
;;;254      else
;;;255      {
;;;256        /* Check the parameters */
;;;257        assert_param(IS_UART_INSTANCE(huart->Instance));
;;;258      }
;;;259    
;;;260      if(huart->gState == HAL_UART_STATE_RESET)
;;;261      {
;;;262        /* Allocate lock resource and initialize it */
;;;263        huart->Lock = HAL_UNLOCKED;
;;;264    
;;;265        /* Init the low level hardware : GPIO, CLOCK */
;;;266        HAL_UART_MspInit(huart);
;;;267      }
;;;268    
;;;269      huart->gState = HAL_UART_STATE_BUSY;
;;;270    
;;;271      /* Disable the Peripheral */
;;;272      __HAL_UART_DISABLE(huart);
;;;273    
;;;274      /* Set the UART Communication parameters */
;;;275      if (UART_SetConfig(huart) == HAL_ERROR)
;;;276      {
;;;277        return HAL_ERROR;
;;;278      }
;;;279    
;;;280      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;281      {
;;;282        UART_AdvFeatureConfig(huart);
;;;283      }
;;;284    
;;;285      /* In asynchronous mode, the following bits must be kept cleared:
;;;286      - LINEN and CLKEN bits in the USART_CR2 register,
;;;287      - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
;;;288      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;289      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;290    
;;;291      /* Enable the Peripheral */
;;;292      __HAL_UART_ENABLE(huart);
;;;293    
;;;294      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;295      return (UART_CheckIdleState(huart));
;;;296    }
000006  4770              BXEQ     lr
000008  b510              PUSH     {r4,lr}               ;242
00000a  4604              MOV      r4,r0                 ;242
00000c  6ec0              LDR      r0,[r0,#0x6c]         ;260
00000e  b920              CBNZ     r0,|L20.26|
000010  2000              MOVS     r0,#0                 ;263
000012  66a0              STR      r0,[r4,#0x68]         ;266
000014  4620              MOV      r0,r4                 ;266
000016  f7fffffe          BL       HAL_UART_MspInit
                  |L20.26|
00001a  2024              MOVS     r0,#0x24              ;269
00001c  66e0              STR      r0,[r4,#0x6c]         ;269
00001e  6820              LDR      r0,[r4,#0]            ;272
000020  6801              LDR      r1,[r0,#0]            ;272
000022  f0210101          BIC      r1,r1,#1              ;272
000026  6001              STR      r1,[r0,#0]            ;272
000028  4620              MOV      r0,r4                 ;275
00002a  f7fffffe          BL       UART_SetConfig
00002e  2801              CMP      r0,#1                 ;275
000030  bf08              IT       EQ
000032  bd10              POPEQ    {r4,pc}
000034  6a60              LDR      r0,[r4,#0x24]         ;280
000036  2800              CMP      r0,#0                 ;280
000038  bf1c              ITT      NE                    ;282
00003a  4620              MOVNE    r0,r4                 ;282
00003c  f7fffffe          BLNE     UART_AdvFeatureConfig
000040  6820              LDR      r0,[r4,#0]            ;288
000042  6841              LDR      r1,[r0,#4]            ;288
000044  f4214190          BIC      r1,r1,#0x4800         ;288
000048  6041              STR      r1,[r0,#4]            ;288
00004a  6820              LDR      r0,[r4,#0]            ;289
00004c  6881              LDR      r1,[r0,#8]            ;289
00004e  f021012a          BIC      r1,r1,#0x2a           ;289
000052  6081              STR      r1,[r0,#8]            ;289
000054  6820              LDR      r0,[r4,#0]            ;292
000056  6801              LDR      r1,[r0,#0]            ;292
000058  f0410101          ORR      r1,r1,#1              ;292
00005c  6001              STR      r1,[r0,#0]            ;292
00005e  4620              MOV      r0,r4                 ;295
000060  e8bd4010          POP      {r4,lr}               ;295
000064  f7ffbffe          B.W      UART_CheckIdleState
;;;297    
                          ENDP


                          AREA ||i.HAL_UART_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspDeInit PROC
;;;637      */
;;;638    __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;639    {
;;;640      /* Prevent unused argument(s) compilation warning */
;;;641      UNUSED(huart);
;;;642    
;;;643      /* NOTE : This function should not be modified, when the callback is needed,
;;;644                the HAL_UART_MspDeInit can be implemented in the user file
;;;645       */
;;;646    }
;;;647    
                          ENDP


                          AREA ||i.HAL_UART_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspInit PROC
;;;622      */
;;;623    __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;624    {
;;;625      /* Prevent unused argument(s) compilation warning */
;;;626      UNUSED(huart);
;;;627    
;;;628      /* NOTE : This function should not be modified, when the callback is needed,
;;;629                the HAL_UART_MspInit can be implemented in the user file
;;;630       */
;;;631    }
;;;632    
                          ENDP


                          AREA ||i.HAL_UART_Receive||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive PROC
;;;784      */
;;;785    HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;786    {
000004  4604              MOV      r4,r0
;;;787      uint16_t* tmp;
;;;788      uint16_t uhMask;
;;;789      uint32_t tickstart = 0U;
;;;790    
;;;791      /* Check that a Rx process is not already ongoing */
;;;792      if(huart->RxState == HAL_UART_STATE_READY)
000006  6f00              LDR      r0,[r0,#0x70]
000008  461d              MOV      r5,r3                 ;786
00000a  4617              MOV      r7,r2                 ;786
00000c  460e              MOV      r6,r1                 ;786
00000e  2820              CMP      r0,#0x20
000010  d169              BNE      |L23.230|
;;;793      {
;;;794        if((pData == NULL ) || (Size == 0U))
000012  2e00              CMP      r6,#0
000014  bf12              ITEE     NE
000016  2f00              CMPNE    r7,#0
;;;795        {
;;;796          return  HAL_ERROR;
000018  2001              MOVEQ    r0,#1
;;;797        }
;;;798    
;;;799        /* Process Locked */
;;;800        __HAL_LOCK(huart);
;;;801    
;;;802        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;803        huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;804    
;;;805        /* Init tickstart for timeout managment*/
;;;806        tickstart = HAL_GetTick();
;;;807    
;;;808        huart->RxXferSize = Size;
;;;809        huart->RxXferCount = Size;
;;;810    
;;;811        /* Computation of UART mask to apply to RDR register */
;;;812        UART_MASK_COMPUTATION(huart);
;;;813        uhMask = huart->Mask;
;;;814    
;;;815        /* as long as data have to be received */
;;;816        while(huart->RxXferCount > 0U)
;;;817        {
;;;818          huart->RxXferCount--;
;;;819          if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;820          {
;;;821            return HAL_TIMEOUT;
;;;822          }
;;;823          if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;824          {
;;;825            tmp = (uint16_t*) pData ;
;;;826            *tmp = (uint16_t)(huart->Instance->RDR & uhMask);
;;;827            pData +=2U;
;;;828          }
;;;829          else
;;;830          {
;;;831            *pData++ = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
;;;832          }
;;;833        }
;;;834    
;;;835        /* At end of Rx process, restore huart->RxState to Ready */
;;;836        huart->RxState = HAL_UART_STATE_READY;
;;;837    
;;;838        /* Process Unlocked */
;;;839        __HAL_UNLOCK(huart);
;;;840    
;;;841        return HAL_OK;
;;;842      }
;;;843      else
;;;844      {
;;;845        return HAL_BUSY;
;;;846      }
;;;847    }
00001a  e8bd9ff0          POPEQ    {r4-r12,pc}
00001e  6ea0              LDR      r0,[r4,#0x68]         ;800
000020  2801              CMP      r0,#1                 ;800
000022  d060              BEQ      |L23.230|
000024  2001              MOVS     r0,#1                 ;800
000026  f04f0b00          MOV      r11,#0                ;802
00002a  f8c4b074          STR      r11,[r4,#0x74]        ;802
00002e  2122              MOVS     r1,#0x22              ;803
000030  66a0              STR      r0,[r4,#0x68]         ;802
000032  6721              STR      r1,[r4,#0x70]         ;803
000034  f7fffffe          BL       HAL_GetTick
000038  4680              MOV      r8,r0                 ;806
00003a  68a0              LDR      r0,[r4,#8]            ;808
00003c  f8a47058          STRH     r7,[r4,#0x58]         ;808
000040  f8a4705a          STRH     r7,[r4,#0x5a]         ;809
000044  21ff              MOVS     r1,#0xff              ;812
000046  f5b05f80          CMP      r0,#0x1000            ;812
00004a  d006              BEQ      |L23.90|
00004c  f04f027f          MOV      r2,#0x7f              ;812
000050  b150              CBZ      r0,|L23.104|
000052  f1b05f80          CMP      r0,#0x10000000        ;812
000056  d00c              BEQ      |L23.114|
000058  e012              B        |L23.128|
                  |L23.90|
00005a  6920              LDR      r0,[r4,#0x10]         ;812
00005c  2800              CMP      r0,#0                 ;812
00005e  bf08              IT       EQ                    ;812
000060  f24010ff          MOVEQ    r0,#0x1ff             ;812
000064  d102              BNE      |L23.108|
000066  e009              B        |L23.124|
                  |L23.104|
000068  6920              LDR      r0,[r4,#0x10]         ;812
00006a  bbd8              CBNZ     r0,|L23.228|
                  |L23.108|
00006c  f8a4105c          STRH     r1,[r4,#0x5c]         ;812
000070  e006              B        |L23.128|
                  |L23.114|
000072  6920              LDR      r0,[r4,#0x10]         ;812
000074  2800              CMP      r0,#0                 ;812
000076  bf18              IT       NE                    ;812
000078  203f              MOVNE    r0,#0x3f              ;812
00007a  d035              BEQ      |L23.232|
                  |L23.124|
00007c  f8a4005c          STRH     r0,[r4,#0x5c]         ;812
                  |L23.128|
000080  f8b4005a          LDRH     r0,[r4,#0x5a]         ;816
000084  f8b4905c          LDRH     r9,[r4,#0x5c]         ;813
000088  2800              CMP      r0,#0                 ;816
00008a  bf18              IT       NE                    ;831
00008c  f0090aff          ANDNE    r10,r9,#0xff          ;831
000090  d044              BEQ      |L23.284|
000092  bf00              NOP                            ;818
                  |L23.148|
000094  f8b4005a          LDRH     r0,[r4,#0x5a]         ;818
000098  1e40              SUBS     r0,r0,#1              ;818
00009a  f8a4005a          STRH     r0,[r4,#0x5a]         ;818
00009e  6820              LDR      r0,[r4,#0]            ;818
0000a0  2720              MOVS     r7,#0x20              ;819
0000a2  69c0              LDR      r0,[r0,#0x1c]         ;819
0000a4  ea370000          BICS     r0,r7,r0              ;819
0000a8  d026              BEQ      |L23.248|
0000aa  bf00              NOP                            ;819
                  |L23.172|
0000ac  f1b53fff          CMP      r5,#0xffffffff        ;819
0000b0  d01d              BEQ      |L23.238|
0000b2  b12d              CBZ      r5,|L23.192|
0000b4  f7fffffe          BL       HAL_GetTick
0000b8  eba00108          SUB      r1,r0,r8              ;819
0000bc  42a9              CMP      r1,r5                 ;819
0000be  d316              BCC      |L23.238|
                  |L23.192|
0000c0  6821              LDR      r1,[r4,#0]            ;819
0000c2  2020              MOVS     r0,#0x20              ;819
0000c4  680a              LDR      r2,[r1,#0]            ;819
0000c6  f42272d0          BIC      r2,r2,#0x1a0          ;819
0000ca  600a              STR      r2,[r1,#0]            ;819
0000cc  6821              LDR      r1,[r4,#0]            ;819
0000ce  688a              LDR      r2,[r1,#8]            ;819
0000d0  f0220201          BIC      r2,r2,#1              ;819
0000d4  608a              STR      r2,[r1,#8]            ;819
0000d6  66e0              STR      r0,[r4,#0x6c]         ;819
0000d8  6720              STR      r0,[r4,#0x70]         ;819
0000da  2003              MOVS     r0,#3                 ;821
0000dc  f8c4b068          STR      r11,[r4,#0x68]        ;821
0000e0  e8bd9ff0          POP      {r4-r12,pc}
                  |L23.228|
0000e4  e000              B        |L23.232|
                  |L23.230|
0000e6  e028              B        |L23.314|
                  |L23.232|
0000e8  f8a4205c          STRH     r2,[r4,#0x5c]         ;812
0000ec  e7c8              B        |L23.128|
                  |L23.238|
0000ee  6820              LDR      r0,[r4,#0]            ;812
0000f0  69c0              LDR      r0,[r0,#0x1c]         ;812
0000f2  ea370000          BICS     r0,r7,r0              ;812
0000f6  d1d9              BNE      |L23.172|
                  |L23.248|
0000f8  68a0              LDR      r0,[r4,#8]            ;823
0000fa  f5b05f80          CMP      r0,#0x1000            ;823
0000fe  bf04              ITT      EQ                    ;823
000100  6920              LDREQ    r0,[r4,#0x10]         ;823
000102  2800              CMPEQ    r0,#0                 ;823
000104  d011              BEQ      |L23.298|
000106  6820              LDR      r0,[r4,#0]            ;831
000108  6a40              LDR      r0,[r0,#0x24]         ;831
00010a  ea00000a          AND      r0,r0,r10             ;831
00010e  f8060b01          STRB     r0,[r6],#1            ;831
000112  bf00              NOP                            ;831
                  |L23.276|
000114  f8b4005a          LDRH     r0,[r4,#0x5a]         ;831
000118  2800              CMP      r0,#0                 ;831
00011a  d1bb              BNE      |L23.148|
                  |L23.284|
00011c  2020              MOVS     r0,#0x20              ;836
00011e  6720              STR      r0,[r4,#0x70]         ;836
000120  2000              MOVS     r0,#0                 ;841
000122  f8c4b068          STR      r11,[r4,#0x68]        ;841
000126  e8bd9ff0          POP      {r4-r12,pc}
                  |L23.298|
00012a  6821              LDR      r1,[r4,#0]            ;826
00012c  4630              MOV      r0,r6                 ;825
00012e  1cb6              ADDS     r6,r6,#2              ;827
000130  6a49              LDR      r1,[r1,#0x24]         ;826
000132  ea010109          AND      r1,r1,r9              ;826
000136  8001              STRH     r1,[r0,#0]            ;826
000138  e7ec              B        |L23.276|
                  |L23.314|
00013a  2002              MOVS     r0,#2                 ;845
00013c  e8bd9ff0          POP      {r4-r12,pc}
;;;848    
                          ENDP


                          AREA ||i.HAL_UART_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive_DMA PROC
;;;1008     */
;;;1009   HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;1010   {
000002  4604              MOV      r4,r0
;;;1011     uint32_t *tmp;
;;;1012   
;;;1013     /* Check that a Rx process is not already ongoing */
;;;1014     if(huart->RxState == HAL_UART_STATE_READY)
000004  6f00              LDR      r0,[r0,#0x70]
000006  2820              CMP      r0,#0x20
000008  d137              BNE      |L24.122|
;;;1015     {
;;;1016       if((pData == NULL ) || (Size == 0U))
00000a  2900              CMP      r1,#0
00000c  bf12              ITEE     NE
00000e  2a00              CMPNE    r2,#0
;;;1017       {
;;;1018         return HAL_ERROR;
000010  2001              MOVEQ    r0,#1
;;;1019       }
;;;1020   
;;;1021       /* Process Locked */
;;;1022       __HAL_LOCK(huart);
;;;1023   
;;;1024       huart->pRxBuffPtr = pData;
;;;1025       huart->RxXferSize = Size;
;;;1026   
;;;1027       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1028       huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;1029   
;;;1030       /* Set the UART DMA transfer complete callback */
;;;1031       huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
;;;1032   
;;;1033       /* Set the UART DMA Half transfer complete callback */
;;;1034       huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
;;;1035   
;;;1036       /* Set the DMA error callback */
;;;1037       huart->hdmarx->XferErrorCallback = UART_DMAError;
;;;1038   
;;;1039       /* Set the DMA abort callback */
;;;1040       huart->hdmarx->XferAbortCallback = NULL;
;;;1041   
;;;1042       /* Enable the DMA channel */
;;;1043       tmp = (uint32_t*)&pData;
;;;1044       HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->RDR, *(uint32_t*)tmp, Size);
;;;1045   
;;;1046       /* Process Unlocked */
;;;1047       __HAL_UNLOCK(huart);
;;;1048   
;;;1049       /* Enable the UART Parity Error Interrupt */
;;;1050       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1051   
;;;1052       /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1053       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1054   
;;;1055       /* Enable the DMA transfer for the receiver request by setting the DMAR bit
;;;1056       in the UART CR3 register */
;;;1057       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1058   
;;;1059       return HAL_OK;
;;;1060     }
;;;1061     else
;;;1062     {
;;;1063       return HAL_BUSY;
;;;1064     }
;;;1065   }
000012  bd70              POPEQ    {r4-r6,pc}
000014  6ea0              LDR      r0,[r4,#0x68]         ;1022
000016  2801              CMP      r0,#1                 ;1022
000018  d02f              BEQ      |L24.122|
00001a  2301              MOVS     r3,#1                 ;1022
00001c  66a3              STR      r3,[r4,#0x68]         ;1025
00001e  6561              STR      r1,[r4,#0x54]         ;1025
000020  2500              MOVS     r5,#0                 ;1027
000022  f8a42058          STRH     r2,[r4,#0x58]         ;1025
000026  2022              MOVS     r0,#0x22              ;1028
000028  6765              STR      r5,[r4,#0x74]         ;1027
00002a  6720              STR      r0,[r4,#0x70]         ;1028
00002c  6e63              LDR      r3,[r4,#0x64]         ;1031
00002e  4814              LDR      r0,|L24.128|
000030  6418              STR      r0,[r3,#0x40]         ;1034
000032  6e63              LDR      r3,[r4,#0x64]         ;1034
000034  4813              LDR      r0,|L24.132|
000036  6458              STR      r0,[r3,#0x44]         ;1037
000038  6e63              LDR      r3,[r4,#0x64]         ;1037
00003a  4813              LDR      r0,|L24.136|
00003c  6518              STR      r0,[r3,#0x50]         ;1040
00003e  4613              MOV      r3,r2                 ;1044
000040  6e60              LDR      r0,[r4,#0x64]         ;1040
000042  6545              STR      r5,[r0,#0x54]         ;1040
000044  4608              MOV      r0,r1                 ;1040
000046  f8d4c064          LDR      r12,[r4,#0x64]        ;1044
00004a  4602              MOV      r2,r0                 ;1044
00004c  6821              LDR      r1,[r4,#0]            ;1044
00004e  4660              MOV      r0,r12                ;1044
000050  3124              ADDS     r1,r1,#0x24           ;1044
000052  f7fffffe          BL       HAL_DMA_Start_IT
000056  66a5              STR      r5,[r4,#0x68]         ;1050
000058  6820              LDR      r0,[r4,#0]            ;1050
00005a  6801              LDR      r1,[r0,#0]            ;1050
00005c  f4417180          ORR      r1,r1,#0x100          ;1050
000060  6001              STR      r1,[r0,#0]            ;1050
000062  6820              LDR      r0,[r4,#0]            ;1053
000064  6881              LDR      r1,[r0,#8]            ;1053
000066  f0410101          ORR      r1,r1,#1              ;1053
00006a  6081              STR      r1,[r0,#8]            ;1053
00006c  6820              LDR      r0,[r4,#0]            ;1057
00006e  6881              LDR      r1,[r0,#8]            ;1057
000070  f0410140          ORR      r1,r1,#0x40           ;1057
000074  6081              STR      r1,[r0,#8]            ;1057
000076  2000              MOVS     r0,#0                 ;1059
000078  bd70              POP      {r4-r6,pc}
                  |L24.122|
00007a  2002              MOVS     r0,#2                 ;1063
00007c  bd70              POP      {r4-r6,pc}
;;;1066   
                          ENDP

00007e  0000              DCW      0x0000
                  |L24.128|
                          DCD      UART_DMAReceiveCplt
                  |L24.132|
                          DCD      UART_DMARxHalfCplt
                  |L24.136|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Receive_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive_IT PROC
;;;896      */
;;;897    HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  6f03              LDR      r3,[r0,#0x70]
;;;898    {
;;;899      /* Check that a Rx process is not already ongoing */
;;;900      if(huart->RxState == HAL_UART_STATE_READY)
000002  2b20              CMP      r3,#0x20
000004  d141              BNE      |L25.138|
;;;901      {
;;;902        if((pData == NULL ) || (Size == 0U))
000006  2900              CMP      r1,#0
000008  bf12              ITEE     NE
00000a  2a00              CMPNE    r2,#0
;;;903        {
;;;904          return HAL_ERROR;
00000c  2001              MOVEQ    r0,#1
;;;905        }
;;;906    
;;;907        /* Process Locked */
;;;908        __HAL_LOCK(huart);
;;;909    
;;;910        huart->pRxBuffPtr = pData;
;;;911        huart->RxXferSize = Size;
;;;912        huart->RxXferCount = Size;
;;;913    
;;;914        /* Computation of UART mask to apply to RDR register */
;;;915        UART_MASK_COMPUTATION(huart);
;;;916    
;;;917        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;918        huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;919    
;;;920        /* Process Unlocked */
;;;921        __HAL_UNLOCK(huart);
;;;922    
;;;923        /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;924        SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;925    
;;;926        /* Enable the UART Parity Error and Data Register not empty Interrupts */
;;;927        SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
;;;928    
;;;929        return HAL_OK;
;;;930      }
;;;931      else
;;;932      {
;;;933        return HAL_BUSY;
;;;934      }
;;;935    }
00000e  4770              BXEQ     lr
000010  6e83              LDR      r3,[r0,#0x68]         ;908
000012  2b01              CMP      r3,#1                 ;908
000014  d039              BEQ      |L25.138|
000016  6883              LDR      r3,[r0,#8]            ;910
000018  f04f0c01          MOV      r12,#1                ;908
00001c  f8c0c068          STR      r12,[r0,#0x68]        ;911
000020  6541              STR      r1,[r0,#0x54]         ;911
000022  f8a02058          STRH     r2,[r0,#0x58]         ;911
000026  f8a0205a          STRH     r2,[r0,#0x5a]         ;912
00002a  f5b35f80          CMP      r3,#0x1000            ;915
00002e  f04f01ff          MOV      r1,#0xff              ;915
000032  d006              BEQ      |L25.66|
000034  f04f027f          MOV      r2,#0x7f              ;915
000038  b14b              CBZ      r3,|L25.78|
00003a  f1b35f80          CMP      r3,#0x10000000        ;915
00003e  d009              BEQ      |L25.84|
000040  e00f              B        |L25.98|
                  |L25.66|
000042  6902              LDR      r2,[r0,#0x10]         ;915
000044  2a00              CMP      r2,#0                 ;915
000046  bf08              IT       EQ                    ;915
000048  f24011ff          MOVEQ    r1,#0x1ff             ;915
00004c  e007              B        |L25.94|
                  |L25.78|
00004e  6903              LDR      r3,[r0,#0x10]         ;915
000050  b9c3              CBNZ     r3,|L25.132|
000052  e004              B        |L25.94|
                  |L25.84|
000054  6901              LDR      r1,[r0,#0x10]         ;915
000056  2900              CMP      r1,#0                 ;915
000058  bf18              IT       NE                    ;915
00005a  213f              MOVNE    r1,#0x3f              ;915
00005c  d012              BEQ      |L25.132|
                  |L25.94|
00005e  f8a0105c          STRH     r1,[r0,#0x5c]         ;915
                  |L25.98|
000062  2100              MOVS     r1,#0                 ;917
000064  2222              MOVS     r2,#0x22              ;918
000066  6741              STR      r1,[r0,#0x74]         ;917
000068  6702              STR      r2,[r0,#0x70]         ;918
00006a  6681              STR      r1,[r0,#0x68]         ;924
00006c  6801              LDR      r1,[r0,#0]            ;924
00006e  688a              LDR      r2,[r1,#8]            ;924
000070  f0420201          ORR      r2,r2,#1              ;924
000074  608a              STR      r2,[r1,#8]            ;924
000076  6800              LDR      r0,[r0,#0]            ;927
000078  6801              LDR      r1,[r0,#0]            ;927
00007a  f4417190          ORR      r1,r1,#0x120          ;927
00007e  6001              STR      r1,[r0,#0]            ;927
000080  2000              MOVS     r0,#0                 ;929
000082  4770              BX       lr
                  |L25.132|
000084  f8a0205c          STRH     r2,[r0,#0x5c]         ;915
000088  e7eb              B        |L25.98|
                  |L25.138|
00008a  2002              MOVS     r0,#2                 ;933
00008c  4770              BX       lr
;;;936    
                          ENDP


                          AREA ||i.HAL_UART_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxCpltCallback PROC
;;;1517     */
;;;1518   __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1519   {
;;;1520     /* Prevent unused argument(s) compilation warning */
;;;1521     UNUSED(huart);
;;;1522   
;;;1523     /* NOTE : This function should not be modified, when the callback is needed,
;;;1524               the HAL_UART_RxCpltCallback can be implemented in the user file
;;;1525      */
;;;1526   }
;;;1527   
                          ENDP


                          AREA ||i.HAL_UART_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxHalfCpltCallback PROC
;;;1532     */
;;;1533   __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1534   {
;;;1535     /* Prevent unused argument(s) compilation warning */
;;;1536     UNUSED(huart);
;;;1537   
;;;1538     /* NOTE: This function should not be modified, when the callback is needed,
;;;1539              the HAL_UART_RxHalfCpltCallback can be implemented in the user file
;;;1540      */
;;;1541   }
;;;1542   
                          ENDP


                          AREA ||i.HAL_UART_Transmit||, CODE, READONLY, ALIGN=2

                  HAL_UART_Transmit PROC
;;;715      */
;;;716    HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;717    {
000004  4604              MOV      r4,r0
;;;718      uint16_t* tmp;
;;;719      uint32_t tickstart = 0U;
;;;720    
;;;721      /* Check that a Tx process is not already ongoing */
;;;722      if(huart->gState == HAL_UART_STATE_READY)
000006  6ec0              LDR      r0,[r0,#0x6c]
000008  461d              MOV      r5,r3                 ;717
00000a  4617              MOV      r7,r2                 ;717
00000c  460e              MOV      r6,r1                 ;717
00000e  2820              CMP      r0,#0x20
000010  d175              BNE      |L28.254|
;;;723      {
;;;724        if((pData == NULL ) || (Size == 0U))
000012  2e00              CMP      r6,#0
000014  bf12              ITEE     NE
000016  2f00              CMPNE    r7,#0
;;;725        {
;;;726          return  HAL_ERROR;
000018  2001              MOVEQ    r0,#1
;;;727        }
;;;728    
;;;729        /* Process Locked */
;;;730        __HAL_LOCK(huart);
;;;731    
;;;732        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;733        huart->gState = HAL_UART_STATE_BUSY_TX;
;;;734    
;;;735        /* Init tickstart for timeout managment*/
;;;736        tickstart = HAL_GetTick();
;;;737    
;;;738        huart->TxXferSize = Size;
;;;739        huart->TxXferCount = Size;
;;;740        while(huart->TxXferCount > 0U)
;;;741        {
;;;742          huart->TxXferCount--;
;;;743          if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;744          {
;;;745            return HAL_TIMEOUT;
;;;746          }
;;;747          if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;748          {
;;;749            tmp = (uint16_t*) pData;
;;;750            huart->Instance->TDR = (*tmp & (uint16_t)0x01FFU);
;;;751            pData += 2;
;;;752          }
;;;753          else
;;;754          {
;;;755            huart->Instance->TDR = (*pData++ & (uint8_t)0xFFU);
;;;756          }
;;;757        }
;;;758        if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;759        {
;;;760          return HAL_TIMEOUT;
;;;761        }
;;;762    
;;;763        /* At end of Tx process, restore huart->gState to Ready */
;;;764        huart->gState = HAL_UART_STATE_READY;
;;;765    
;;;766        /* Process Unlocked */
;;;767        __HAL_UNLOCK(huart);
;;;768    
;;;769        return HAL_OK;
;;;770      }
;;;771      else
;;;772      {
;;;773        return HAL_BUSY;
;;;774      }
;;;775    }
00001a  e8bd8ff8          POPEQ    {r3-r11,pc}
00001e  6ea0              LDR      r0,[r4,#0x68]         ;730
000020  2801              CMP      r0,#1                 ;730
000022  d06c              BEQ      |L28.254|
000024  2001              MOVS     r0,#1                 ;730
000026  f04f0900          MOV      r9,#0                 ;732
00002a  f8c49074          STR      r9,[r4,#0x74]         ;732
00002e  2121              MOVS     r1,#0x21              ;733
000030  66a0              STR      r0,[r4,#0x68]         ;732
000032  66e1              STR      r1,[r4,#0x6c]         ;733
000034  f7fffffe          BL       HAL_GetTick
000038  4680              MOV      r8,r0                 ;736
00003a  f8a47052          STRH     r7,[r4,#0x52]         ;739
00003e  f8b40052          LDRH     r0,[r4,#0x52]         ;740
000042  f04f0a20          MOV      r10,#0x20             ;740
000046  f8a47050          STRH     r7,[r4,#0x50]         ;738
00004a  2800              CMP      r0,#0                 ;740
00004c  d03e              BEQ      |L28.204|
00004e  bf00              NOP                            ;742
                  |L28.80|
000050  f8b40052          LDRH     r0,[r4,#0x52]         ;742
000054  1e40              SUBS     r0,r0,#1              ;742
000056  f8a40052          STRH     r0,[r4,#0x52]         ;742
00005a  6820              LDR      r0,[r4,#0]            ;742
00005c  2780              MOVS     r7,#0x80              ;743
00005e  69c0              LDR      r0,[r0,#0x1c]         ;743
000060  ea370000          BICS     r0,r7,r0              ;743
000064  d022              BEQ      |L28.172|
000066  bf00              NOP                            ;743
                  |L28.104|
000068  f1b53fff          CMP      r5,#0xffffffff        ;743
00006c  d019              BEQ      |L28.162|
00006e  b12d              CBZ      r5,|L28.124|
000070  f7fffffe          BL       HAL_GetTick
000074  eba00108          SUB      r1,r0,r8              ;743
000078  42a9              CMP      r1,r5                 ;743
00007a  d312              BCC      |L28.162|
                  |L28.124|
00007c  6820              LDR      r0,[r4,#0]            ;743
00007e  6801              LDR      r1,[r0,#0]            ;743
000080  f42171d0          BIC      r1,r1,#0x1a0          ;743
000084  6001              STR      r1,[r0,#0]            ;743
000086  6820              LDR      r0,[r4,#0]            ;743
000088  6881              LDR      r1,[r0,#8]            ;743
00008a  f0210101          BIC      r1,r1,#1              ;743
00008e  6081              STR      r1,[r0,#8]            ;743
000090  f8c4a06c          STR      r10,[r4,#0x6c]        ;743
000094  f8c4a070          STR      r10,[r4,#0x70]        ;743
000098  2003              MOVS     r0,#3                 ;745
00009a  f8c49068          STR      r9,[r4,#0x68]         ;745
00009e  e8bd8ff8          POP      {r3-r11,pc}
                  |L28.162|
0000a2  6820              LDR      r0,[r4,#0]
0000a4  69c0              LDR      r0,[r0,#0x1c]
0000a6  ea370000          BICS     r0,r7,r0
0000aa  d1dd              BNE      |L28.104|
                  |L28.172|
0000ac  68a0              LDR      r0,[r4,#8]            ;747
0000ae  f5b05f80          CMP      r0,#0x1000            ;747
0000b2  bf04              ITT      EQ                    ;747
0000b4  6920              LDREQ    r0,[r4,#0x10]         ;747
0000b6  2800              CMPEQ    r0,#0                 ;747
0000b8  d019              BEQ      |L28.238|
0000ba  6820              LDR      r0,[r4,#0]            ;755
0000bc  f8161b01          LDRB     r1,[r6],#1            ;755
0000c0  f8c01028          STR.W    r1,[r0,#0x28]         ;755
                  |L28.196|
0000c4  f8b40052          LDRH     r0,[r4,#0x52]         ;755
0000c8  2800              CMP      r0,#0                 ;755
0000ca  d1c1              BNE      |L28.80|
                  |L28.204|
0000cc  2200              MOVS     r2,#0                 ;758
0000ce  4643              MOV      r3,r8                 ;758
0000d0  2140              MOVS     r1,#0x40              ;758
0000d2  4620              MOV      r0,r4                 ;758
0000d4  9500              STR      r5,[sp,#0]            ;758
0000d6  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
0000da  2800              CMP      r0,#0                 ;758
0000dc  bf11              ITEEE    NE                    ;760
0000de  2003              MOVNE    r0,#3                 ;760
0000e0  f8c4a06c          STREQ    r10,[r4,#0x6c]        ;764
0000e4  2000              MOVEQ    r0,#0                 ;769
0000e6  f8c49068          STREQ    r9,[r4,#0x68]         ;769
0000ea  e8bd8ff8          POP      {r3-r11,pc}
                  |L28.238|
0000ee  6821              LDR      r1,[r4,#0]            ;750
0000f0  f8360b02          LDRH     r0,[r6],#2            ;750
0000f4  f3c00008          UBFX     r0,r0,#0,#9           ;750
0000f8  6288              STR      r0,[r1,#0x28]         ;750
0000fa  e7e3              B        |L28.196|
0000fc  e7ff              B        |L28.254|
                  |L28.254|
0000fe  2002              MOVS     r0,#2                 ;773
000100  e8bd8ff8          POP      {r3-r11,pc}
;;;776    
                          ENDP


                          AREA ||i.HAL_UART_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Transmit_DMA PROC
;;;943      */
;;;944    HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;945    {
000002  4604              MOV      r4,r0
;;;946      uint32_t *tmp;
;;;947    
;;;948      /* Check that a Tx process is not already ongoing */
;;;949      if(huart->gState == HAL_UART_STATE_READY)
000004  6ec0              LDR      r0,[r0,#0x6c]
000006  2820              CMP      r0,#0x20
000008  d130              BNE      |L29.108|
;;;950      {
;;;951        if((pData == NULL ) || (Size == 0U))
00000a  2900              CMP      r1,#0
00000c  bf12              ITEE     NE
00000e  2a00              CMPNE    r2,#0
;;;952        {
;;;953          return HAL_ERROR;
000010  2001              MOVEQ    r0,#1
;;;954        }
;;;955    
;;;956        /* Process Locked */
;;;957        __HAL_LOCK(huart);
;;;958    
;;;959        huart->pTxBuffPtr = pData;
;;;960        huart->TxXferSize = Size;
;;;961        huart->TxXferCount = Size;
;;;962    
;;;963        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;964        huart->gState = HAL_UART_STATE_BUSY_TX;
;;;965    
;;;966        /* Set the UART DMA transfer complete callback */
;;;967        huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
;;;968    
;;;969        /* Set the UART DMA Half transfer complete callback */
;;;970        huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
;;;971    
;;;972        /* Set the DMA error callback */
;;;973        huart->hdmatx->XferErrorCallback = UART_DMAError;
;;;974    
;;;975        /* Set the DMA abort callback */
;;;976        huart->hdmatx->XferAbortCallback = NULL;
;;;977    
;;;978        /* Enable the UART transmit DMA channel */
;;;979        tmp = (uint32_t*)&pData;
;;;980        HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t*)tmp, (uint32_t)&huart->Instance->TDR, Size);
;;;981    
;;;982        /* Clear the TC flag in the SR register by writing 0 to it */
;;;983        __HAL_UART_CLEAR_IT(huart, UART_FLAG_TC);
;;;984    
;;;985        /* Process Unlocked */
;;;986        __HAL_UNLOCK(huart);
;;;987    
;;;988        /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;989           in the UART CR3 register */
;;;990        SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;991    
;;;992        return HAL_OK;
;;;993      }
;;;994      else
;;;995      {
;;;996        return HAL_BUSY;
;;;997      }
;;;998    }
000012  bd70              POPEQ    {r4-r6,pc}
000014  6ea0              LDR      r0,[r4,#0x68]         ;957
000016  2801              CMP      r0,#1                 ;957
000018  d028              BEQ      |L29.108|
00001a  2301              MOVS     r3,#1                 ;957
00001c  66a3              STR      r3,[r4,#0x68]         ;960
00001e  64e1              STR      r1,[r4,#0x4c]         ;960
000020  2500              MOVS     r5,#0                 ;963
000022  f8a42050          STRH     r2,[r4,#0x50]         ;960
000026  2021              MOVS     r0,#0x21              ;964
000028  f8a42052          STRH     r2,[r4,#0x52]         ;961
00002c  6765              STR      r5,[r4,#0x74]         ;963
00002e  66e0              STR      r0,[r4,#0x6c]         ;964
000030  6e23              LDR      r3,[r4,#0x60]         ;967
000032  480f              LDR      r0,|L29.112|
000034  6418              STR      r0,[r3,#0x40]         ;970
000036  6e23              LDR      r3,[r4,#0x60]         ;970
000038  480e              LDR      r0,|L29.116|
00003a  6458              STR      r0,[r3,#0x44]         ;973
00003c  6e23              LDR      r3,[r4,#0x60]         ;973
00003e  480e              LDR      r0,|L29.120|
000040  6518              STR      r0,[r3,#0x50]         ;976
000042  6e20              LDR      r0,[r4,#0x60]         ;976
000044  6545              STR      r5,[r0,#0x54]         ;980
000046  6823              LDR      r3,[r4,#0]            ;980
000048  6e20              LDR      r0,[r4,#0x60]         ;980
00004a  f1030c28          ADD      r12,r3,#0x28          ;980
00004e  4613              MOV      r3,r2                 ;980
000050  4662              MOV      r2,r12                ;980
000052  f7fffffe          BL       HAL_DMA_Start_IT
000056  6821              LDR      r1,[r4,#0]            ;983
000058  2040              MOVS     r0,#0x40              ;983
00005a  6208              STR      r0,[r1,#0x20]         ;983
00005c  66a5              STR      r5,[r4,#0x68]         ;990
00005e  6820              LDR      r0,[r4,#0]            ;990
000060  6881              LDR      r1,[r0,#8]            ;990
000062  f0410180          ORR      r1,r1,#0x80           ;990
000066  6081              STR      r1,[r0,#8]            ;990
000068  2000              MOVS     r0,#0                 ;992
00006a  bd70              POP      {r4-r6,pc}
                  |L29.108|
00006c  2002              MOVS     r0,#2                 ;996
00006e  bd70              POP      {r4-r6,pc}
;;;999    
                          ENDP

                  |L29.112|
                          DCD      UART_DMATransmitCplt
                  |L29.116|
                          DCD      UART_DMATxHalfCplt
                  |L29.120|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit_IT PROC
;;;855      */
;;;856    HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  6ec3              LDR      r3,[r0,#0x6c]
;;;857    {
;;;858      /* Check that a Tx process is not already ongoing */
;;;859      if(huart->gState == HAL_UART_STATE_READY)
000002  2b20              CMP      r3,#0x20
000004  d118              BNE      |L30.56|
;;;860      {
;;;861        if((pData == NULL ) || (Size == 0U))
000006  2900              CMP      r1,#0
000008  bf12              ITEE     NE
00000a  2a00              CMPNE    r2,#0
;;;862        {
;;;863          return HAL_ERROR;
00000c  2001              MOVEQ    r0,#1
;;;864        }
;;;865    
;;;866        /* Process Locked */
;;;867        __HAL_LOCK(huart);
;;;868    
;;;869        huart->pTxBuffPtr = pData;
;;;870        huart->TxXferSize = Size;
;;;871        huart->TxXferCount = Size;
;;;872    
;;;873        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;874        huart->gState = HAL_UART_STATE_BUSY_TX;
;;;875    
;;;876        /* Process Unlocked */
;;;877        __HAL_UNLOCK(huart);
;;;878    
;;;879        /* Enable the UART Transmit Data Register Empty Interrupt */
;;;880        SET_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
;;;881    
;;;882        return HAL_OK;
;;;883      }
;;;884      else
;;;885      {
;;;886        return HAL_BUSY;
;;;887      }
;;;888    }
00000e  4770              BXEQ     lr
000010  6e83              LDR      r3,[r0,#0x68]         ;867
000012  2b01              CMP      r3,#1                 ;867
000014  d010              BEQ      |L30.56|
000016  64c1              STR      r1,[r0,#0x4c]         ;870
000018  2100              MOVS     r1,#0                 ;873
00001a  f8a02050          STRH     r2,[r0,#0x50]         ;870
00001e  2321              MOVS     r3,#0x21              ;874
000020  f8a02052          STRH     r2,[r0,#0x52]         ;871
000024  6741              STR      r1,[r0,#0x74]         ;873
000026  66c3              STR      r3,[r0,#0x6c]         ;874
000028  6681              STR      r1,[r0,#0x68]         ;880
00002a  6800              LDR      r0,[r0,#0]            ;880
00002c  6801              LDR      r1,[r0,#0]            ;880
00002e  f0410180          ORR      r1,r1,#0x80           ;880
000032  6001              STR      r1,[r0,#0]            ;880
000034  2000              MOVS     r0,#0                 ;882
000036  4770              BX       lr
                  |L30.56|
000038  2002              MOVS     r0,#2                 ;886
00003a  4770              BX       lr
;;;889    
                          ENDP


                          AREA ||i.HAL_UART_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxCpltCallback PROC
;;;1487     */
;;;1488    __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1489   {
;;;1490     /* Prevent unused argument(s) compilation warning */
;;;1491     UNUSED(huart);
;;;1492   
;;;1493     /* NOTE : This function should not be modified, when the callback is needed,
;;;1494               the HAL_UART_TxCpltCallback can be implemented in the user file
;;;1495      */
;;;1496   }
;;;1497   
                          ENDP


                          AREA ||i.HAL_UART_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxHalfCpltCallback PROC
;;;1502     */
;;;1503    __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1504   {
;;;1505     /* Prevent unused argument(s) compilation warning */
;;;1506     UNUSED(huart);
;;;1507   
;;;1508     /* NOTE: This function should not be modified, when the callback is needed,
;;;1509              the HAL_UART_TxHalfCpltCallback can be implemented in the user file
;;;1510      */
;;;1511   }
;;;1512   
                          ENDP


                          AREA ||i.UART_AdvFeatureConfig||, CODE, READONLY, ALIGN=1

                  UART_AdvFeatureConfig PROC
;;;1935     */
;;;1936   void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
000000  f8901024          LDRB     r1,[r0,#0x24]
;;;1937   {
;;;1938     /* Check whether the set of advanced features to configure is properly set */
;;;1939     assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
;;;1940   
;;;1941     /* if required, configure TX pin active level inversion */
;;;1942     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
000004  f0110f01          TST      r1,#1
000008  d006              BEQ      |L33.24|
;;;1943     {
;;;1944       assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
;;;1945       MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
00000a  6801              LDR      r1,[r0,#0]
00000c  6a82              LDR      r2,[r0,#0x28]
00000e  684b              LDR      r3,[r1,#4]
000010  f4233300          BIC      r3,r3,#0x20000
000014  431a              ORRS     r2,r2,r3
000016  604a              STR      r2,[r1,#4]
                  |L33.24|
;;;1946     }
;;;1947   
;;;1948     /* if required, configure RX pin active level inversion */
;;;1949     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
000018  f8901024          LDRB     r1,[r0,#0x24]
00001c  f0110f02          TST      r1,#2
000020  d006              BEQ      |L33.48|
;;;1950     {
;;;1951       assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
;;;1952       MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
000022  6801              LDR      r1,[r0,#0]
000024  6ac2              LDR      r2,[r0,#0x2c]
000026  684b              LDR      r3,[r1,#4]
000028  f4233380          BIC      r3,r3,#0x10000
00002c  431a              ORRS     r2,r2,r3
00002e  604a              STR      r2,[r1,#4]
                  |L33.48|
;;;1953     }
;;;1954   
;;;1955     /* if required, configure data inversion */
;;;1956     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
000030  f8901024          LDRB     r1,[r0,#0x24]
000034  f0110f04          TST      r1,#4
000038  d006              BEQ      |L33.72|
;;;1957     {
;;;1958       assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
;;;1959       MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
00003a  6801              LDR      r1,[r0,#0]
00003c  6b02              LDR      r2,[r0,#0x30]
00003e  684b              LDR      r3,[r1,#4]
000040  f4232380          BIC      r3,r3,#0x40000
000044  431a              ORRS     r2,r2,r3
000046  604a              STR      r2,[r1,#4]
                  |L33.72|
;;;1960     }
;;;1961   
;;;1962     /* if required, configure RX/TX pins swap */
;;;1963     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
000048  f8901024          LDRB     r1,[r0,#0x24]
00004c  f0110f08          TST      r1,#8
000050  d006              BEQ      |L33.96|
;;;1964     {
;;;1965       assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
;;;1966       MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
000052  6801              LDR      r1,[r0,#0]
000054  6b42              LDR      r2,[r0,#0x34]
000056  684b              LDR      r3,[r1,#4]
000058  f4234300          BIC      r3,r3,#0x8000
00005c  431a              ORRS     r2,r2,r3
00005e  604a              STR      r2,[r1,#4]
                  |L33.96|
;;;1967     }
;;;1968   
;;;1969     /* if required, configure RX overrun detection disabling */
;;;1970     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
000060  f8901024          LDRB     r1,[r0,#0x24]
000064  f0110f10          TST      r1,#0x10
000068  d006              BEQ      |L33.120|
;;;1971     {
;;;1972       assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
;;;1973       MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
00006a  6801              LDR      r1,[r0,#0]
00006c  6b82              LDR      r2,[r0,#0x38]
00006e  688b              LDR      r3,[r1,#8]
000070  f4235380          BIC      r3,r3,#0x1000
000074  431a              ORRS     r2,r2,r3
000076  608a              STR      r2,[r1,#8]
                  |L33.120|
;;;1974     }
;;;1975   
;;;1976     /* if required, configure DMA disabling on reception error */
;;;1977     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
000078  f8901024          LDRB     r1,[r0,#0x24]
00007c  f0110f20          TST      r1,#0x20
000080  d006              BEQ      |L33.144|
;;;1978     {
;;;1979       assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
;;;1980       MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
000082  6801              LDR      r1,[r0,#0]
000084  6bc2              LDR      r2,[r0,#0x3c]
000086  688b              LDR      r3,[r1,#8]
000088  f4235300          BIC      r3,r3,#0x2000
00008c  431a              ORRS     r2,r2,r3
00008e  608a              STR      r2,[r1,#8]
                  |L33.144|
;;;1981     }
;;;1982   
;;;1983     /* if required, configure auto Baud rate detection scheme */
;;;1984     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
000090  f8901024          LDRB     r1,[r0,#0x24]
000094  f0110f40          TST      r1,#0x40
000098  d011              BEQ      |L33.190|
;;;1985     {
;;;1986       assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
;;;1987       MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
00009a  6801              LDR      r1,[r0,#0]
00009c  6c02              LDR      r2,[r0,#0x40]
00009e  684b              LDR      r3,[r1,#4]
0000a0  f4231380          BIC      r3,r3,#0x100000
0000a4  431a              ORRS     r2,r2,r3
0000a6  604a              STR      r2,[r1,#4]
;;;1988       /* set auto Baudrate detection parameters if detection is enabled */
;;;1989       if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
0000a8  6c01              LDR      r1,[r0,#0x40]
0000aa  f5b11f80          CMP      r1,#0x100000
0000ae  d106              BNE      |L33.190|
;;;1990       {
;;;1991         assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
;;;1992         MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
0000b0  6801              LDR      r1,[r0,#0]
0000b2  6c42              LDR      r2,[r0,#0x44]
0000b4  684b              LDR      r3,[r1,#4]
0000b6  f42303c0          BIC      r3,r3,#0x600000
0000ba  431a              ORRS     r2,r2,r3
0000bc  604a              STR      r2,[r1,#4]
                  |L33.190|
;;;1993       }
;;;1994     }
;;;1995   
;;;1996     /* if required, configure MSB first on communication line */
;;;1997     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
0000be  f8901024          LDRB     r1,[r0,#0x24]
0000c2  f0110f80          TST      r1,#0x80
;;;1998     {
;;;1999       assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
;;;2000       MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
;;;2001     }
;;;2002   }
0000c6  bf08              IT       EQ
0000c8  4770              BXEQ     lr
0000ca  6801              LDR      r1,[r0,#0]            ;2000
0000cc  6c80              LDR      r0,[r0,#0x48]         ;2000
0000ce  684a              LDR      r2,[r1,#4]            ;2000
0000d0  f4222200          BIC      r2,r2,#0x80000        ;2000
0000d4  4310              ORRS     r0,r0,r2              ;2000
0000d6  6048              STR      r0,[r1,#4]            ;2000
0000d8  4770              BX       lr
;;;2003   
                          ENDP


                          AREA ||i.UART_CheckIdleState||, CODE, READONLY, ALIGN=1

                  UART_CheckIdleState PROC
;;;2010     */
;;;2011   HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
000000  b538              PUSH     {r3-r5,lr}
;;;2012   {
;;;2013     uint32_t tickstart = 0U;
;;;2014   
;;;2015     /* Initialize the UART ErrorCode */
;;;2016     huart->ErrorCode = HAL_UART_ERROR_NONE;
000002  2500              MOVS     r5,#0
000004  4604              MOV      r4,r0                 ;2012
000006  6745              STR      r5,[r0,#0x74]
;;;2017   
;;;2018     /* Init tickstart for timeout managment*/
;;;2019     tickstart = HAL_GetTick();
000008  f7fffffe          BL       HAL_GetTick
;;;2020   
;;;2021     /* Check if the Transmitter is enabled */
;;;2022     if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
00000c  6821              LDR      r1,[r4,#0]
00000e  6809              LDR      r1,[r1,#0]
000010  f0110f08          TST      r1,#8
000014  d00d              BEQ      |L34.50|
;;;2023     {
;;;2024       /* Wait until TEACK flag is set */
;;;2025       if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
000016  f06f417e          MVN      r1,#0xfe000000
00001a  4603              MOV      r3,r0
00001c  2200              MOVS     r2,#0
00001e  4620              MOV      r0,r4
000020  9100              STR      r1,[sp,#0]
000022  f44f1100          MOV      r1,#0x200000
000026  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
00002a  2800              CMP      r0,#0
;;;2026       {
;;;2027         /* Timeout Occurred */
;;;2028         return HAL_TIMEOUT;
00002c  bf1c              ITT      NE
00002e  2003              MOVNE    r0,#3
;;;2029       }
;;;2030     }
;;;2031   
;;;2032     /* Initialize the UART State */
;;;2033     huart->gState= HAL_UART_STATE_READY;
;;;2034     huart->RxState= HAL_UART_STATE_READY;
;;;2035   
;;;2036     /* Process Unlocked */
;;;2037     __HAL_UNLOCK(huart);
;;;2038   
;;;2039     return HAL_OK;
;;;2040   }
000030  bd38              POPNE    {r3-r5,pc}
                  |L34.50|
000032  2020              MOVS     r0,#0x20              ;2033
000034  66e0              STR      r0,[r4,#0x6c]         ;2033
000036  66a5              STR      r5,[r4,#0x68]         ;2034
000038  6720              STR      r0,[r4,#0x70]         ;2034
00003a  2000              MOVS     r0,#0                 ;2039
00003c  bd38              POP      {r3-r5,pc}
;;;2041   
                          ENDP


                          AREA ||i.UART_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  UART_DMAAbortOnError PROC
;;;1473     */
;;;1474   static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1475   {
;;;1476     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)(hdma->Parent);
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;1477     huart->RxXferCount = 0U;
000004  2100              MOVS     r1,#0
000006  f8a0105a          STRH     r1,[r0,#0x5a]
;;;1478     huart->TxXferCount = 0U;
00000a  f8a01052          STRH     r1,[r0,#0x52]
;;;1479   
;;;1480     HAL_UART_ErrorCallback(huart);
00000e  f7fffffe          BL       HAL_UART_ErrorCallback
;;;1481   }
000012  bd10              POP      {r4,pc}
;;;1482   
                          ENDP


                          AREA ||i.UART_DMAError||, CODE, READONLY, ALIGN=1

                  UART_DMAError PROC
;;;1445     */
;;;1446   static void UART_DMAError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1447   {
;;;1448     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;1449     huart->RxXferCount = 0U;
000004  2100              MOVS     r1,#0
000006  2220              MOVS     r2,#0x20
000008  f8a0105a          STRH     r1,[r0,#0x5a]
;;;1450     huart->TxXferCount = 0U;
00000c  f8a01052          STRH     r1,[r0,#0x52]
;;;1451     /* Stop UART DMA Tx request if ongoing */
;;;1452     if (  (huart->gState == HAL_UART_STATE_BUSY_TX)
000010  6ec1              LDR      r1,[r0,#0x6c]
000012  2921              CMP      r1,#0x21
000014  d109              BNE      |L36.42|
;;;1453         &&(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) )
000016  6801              LDR      r1,[r0,#0]
000018  688b              LDR      r3,[r1,#8]
00001a  f0130f80          TST      r3,#0x80
00001e  d004              BEQ      |L36.42|
000020  680b              LDR      r3,[r1,#0]
000022  f02303c0          BIC      r3,r3,#0xc0
000026  600b              STR      r3,[r1,#0]
000028  66c2              STR      r2,[r0,#0x6c]
                  |L36.42|
;;;1454     {
;;;1455       UART_EndTxTransfer(huart);
;;;1456     }
;;;1457   
;;;1458     /* Stop UART DMA Rx request if ongoing */
;;;1459     if (  (huart->RxState == HAL_UART_STATE_BUSY_RX)
00002a  6f01              LDR      r1,[r0,#0x70]
00002c  2922              CMP      r1,#0x22
00002e  d10e              BNE      |L36.78|
;;;1460         &&(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) )
000030  6801              LDR      r1,[r0,#0]
000032  688b              LDR      r3,[r1,#8]
000034  f0130f40          TST      r3,#0x40
000038  d009              BEQ      |L36.78|
00003a  680b              LDR      r3,[r1,#0]
00003c  f4237390          BIC      r3,r3,#0x120
000040  600b              STR      r3,[r1,#0]
000042  6801              LDR      r1,[r0,#0]
000044  688b              LDR      r3,[r1,#8]
000046  f0230301          BIC      r3,r3,#1
00004a  608b              STR      r3,[r1,#8]
00004c  6702              STR      r2,[r0,#0x70]
                  |L36.78|
;;;1461     {
;;;1462       UART_EndRxTransfer(huart);
;;;1463     }
;;;1464     SET_BIT(huart->ErrorCode, HAL_UART_ERROR_DMA);
00004e  6f41              LDR      r1,[r0,#0x74]
000050  f0410110          ORR      r1,r1,#0x10
000054  6741              STR      r1,[r0,#0x74]
;;;1465     HAL_UART_ErrorCallback(huart);
000056  f7fffffe          BL       HAL_UART_ErrorCallback
;;;1466   }
00005a  bd10              POP      {r4,pc}
;;;1467   
                          ENDP


                          AREA ||i.UART_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  UART_DMAReceiveCplt PROC
;;;1405     */
;;;1406   static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1407   {
;;;1408     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
;;;1409   
;;;1410     /* DMA Normal mode */
;;;1411     if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
000002  6801              LDR      r1,[r0,#0]
000004  6809              LDR      r1,[r1,#0]
000006  6bc0              LDR      r0,[r0,#0x3c]         ;1408
000008  f4117f80          TST      r1,#0x100
00000c  d113              BNE      |L37.54|
;;;1412     {
;;;1413       huart->RxXferCount = 0U;
00000e  2100              MOVS     r1,#0
000010  f8a0105a          STRH     r1,[r0,#0x5a]
;;;1414   
;;;1415       /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1416       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1417       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1418   
;;;1419       /* Disable the DMA transfer for the receiver request by setting the DMAR bit
;;;1420       in the UART CR3 register */
;;;1421       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1422   
;;;1423   	/* At end of Rx process, restore huart->RxState to Ready */
;;;1424       huart->RxState = HAL_UART_STATE_READY;
000014  2220              MOVS     r2,#0x20
000016  6801              LDR      r1,[r0,#0]            ;1416
000018  680b              LDR      r3,[r1,#0]            ;1416
00001a  f4237380          BIC      r3,r3,#0x100          ;1416
00001e  600b              STR      r3,[r1,#0]            ;1416
000020  6801              LDR      r1,[r0,#0]            ;1417
000022  688b              LDR      r3,[r1,#8]            ;1417
000024  f0230301          BIC      r3,r3,#1              ;1417
000028  608b              STR      r3,[r1,#8]            ;1417
00002a  6801              LDR      r1,[r0,#0]            ;1421
00002c  688b              LDR      r3,[r1,#8]            ;1421
00002e  f0230340          BIC      r3,r3,#0x40           ;1421
000032  608b              STR      r3,[r1,#8]            ;1421
000034  6702              STR      r2,[r0,#0x70]
                  |L37.54|
;;;1425     }
;;;1426     HAL_UART_RxCpltCallback(huart);
000036  f7fffffe          BL       HAL_UART_RxCpltCallback
;;;1427   }
00003a  bd10              POP      {r4,pc}
;;;1428   
                          ENDP


                          AREA ||i.UART_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMARxHalfCplt PROC
;;;1433     */
;;;1434   static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1435   {
;;;1436     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;1437   
;;;1438     HAL_UART_RxHalfCpltCallback(huart);
000004  f7fffffe          BL       HAL_UART_RxHalfCpltCallback
;;;1439   }
000008  bd10              POP      {r4,pc}
;;;1440   
                          ENDP


                          AREA ||i.UART_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATransmitCplt PROC
;;;1365     */
;;;1366   static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1367   {
;;;1368     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
;;;1369   
;;;1370     /* DMA Normal mode*/
;;;1371     if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
000002  6801              LDR      r1,[r0,#0]
000004  6809              LDR      r1,[r1,#0]
000006  6bc0              LDR      r0,[r0,#0x3c]         ;1368
000008  f4117f80          TST      r1,#0x100
00000c  d002              BEQ      |L39.20|
;;;1372     {
;;;1373       huart->TxXferCount = 0U;
;;;1374   
;;;1375       /* Disable the DMA transfer for transmit request by setting the DMAT bit
;;;1376          in the UART CR3 register */
;;;1377       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1378   
;;;1379       /* Enable the UART Transmit Complete Interrupt */
;;;1380       SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
;;;1381     }
;;;1382     /* DMA Circular mode */
;;;1383     else
;;;1384     {
;;;1385       HAL_UART_TxCpltCallback(huart);
00000e  f7fffffe          BL       HAL_UART_TxCpltCallback
;;;1386     }
;;;1387   }
000012  bd10              POP      {r4,pc}
                  |L39.20|
000014  2100              MOVS     r1,#0                 ;1373
000016  f8a01052          STRH     r1,[r0,#0x52]         ;1373
00001a  6801              LDR      r1,[r0,#0]            ;1377
00001c  688a              LDR      r2,[r1,#8]            ;1377
00001e  f0220280          BIC      r2,r2,#0x80           ;1377
000022  608a              STR      r2,[r1,#8]            ;1377
000024  6800              LDR      r0,[r0,#0]            ;1380
000026  6801              LDR      r1,[r0,#0]            ;1380
000028  f0410140          ORR      r1,r1,#0x40           ;1380
00002c  6001              STR      r1,[r0,#0]            ;1380
00002e  bd10              POP      {r4,pc}
;;;1388   
                          ENDP


                          AREA ||i.UART_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATxHalfCplt PROC
;;;1393     */
;;;1394   static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1395   {
;;;1396     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;1397   
;;;1398     HAL_UART_TxHalfCpltCallback(huart);
000004  f7fffffe          BL       HAL_UART_TxHalfCpltCallback
;;;1399   }
000008  bd10              POP      {r4,pc}
;;;1400   
                          ENDP


                          AREA ||i.UART_SetConfig||, CODE, READONLY, ALIGN=2

                  UART_SetConfig PROC
;;;1824     */
;;;1825   HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1826   {
;;;1827     uint32_t tmpreg                     = 0x00000000U;
;;;1828     UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
;;;1829     uint16_t brrtemp                    = 0x0000U;
;;;1830     uint16_t usartdiv                   = 0x0000U;
;;;1831     HAL_StatusTypeDef ret               = HAL_OK;
;;;1832   
;;;1833     /* Check the parameters */
;;;1834     assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
;;;1835     assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;1836     assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
;;;1837     assert_param(IS_UART_PARITY(huart->Init.Parity));
;;;1838     assert_param(IS_UART_MODE(huart->Init.Mode));
;;;1839     assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
;;;1840     assert_param(IS_UART_ONE_BIT_SAMPLE(huart->Init.OneBitSampling));
;;;1841   
;;;1842   
;;;1843     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;1844     /* Clear M, PCE, PS, TE, RE and OVER8 bits and configure
;;;1845      *  the UART Word Length, Parity, Mode and oversampling:
;;;1846      *  set the M bits according to huart->Init.WordLength value
;;;1847      *  set PCE and PS bits according to huart->Init.Parity value
;;;1848      *  set TE and RE bits according to huart->Init.Mode value
;;;1849      *  set OVER8 bit according to huart->Init.OverSampling value */
;;;1850     tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
;;;1851     MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
000004  f8d0c01c          LDR      r12,[r0,#0x1c]
000008  4604              MOV      r4,r0                 ;1826
00000a  6881              LDR      r1,[r0,#8]
00000c  6800              LDR      r0,[r0,#0]
00000e  e9d45204          LDRD     r5,r2,[r4,#0x10]
000012  4b9f              LDR      r3,|L41.656|
000014  430d              ORRS     r5,r5,r1              ;1850
000016  6807              LDR      r7,[r0,#0]
000018  2110              MOVS     r1,#0x10              ;1828
00001a  ea420c0c          ORR      r12,r2,r12            ;1850
00001e  2200              MOVS     r2,#0                 ;1830
000020  ea450c0c          ORR      r12,r5,r12            ;1850
000024  4615              MOV      r5,r2                 ;1831
000026  401f              ANDS     r7,r7,r3
;;;1852   
;;;1853     /*-------------------------- USART CR2 Configuration -----------------------*/
;;;1854     /* Configure the UART Stop Bits: Set STOP[13:12] bits according
;;;1855      * to huart->Init.StopBits value */
;;;1856     MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
;;;1857   
;;;1858     /*-------------------------- USART CR3 Configuration -----------------------*/
;;;1859     /* Configure
;;;1860      * - UART HardWare Flow Control: set CTSE and RTSE bits according
;;;1861      *   to huart->Init.HwFlowCtl value
;;;1862      * - one-bit sampling method versus three samples' majority rule according
;;;1863      *   to huart->Init.OneBitSampling */
;;;1864     tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
;;;1865     MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
;;;1866   
;;;1867     /*-------------------------- USART BRR Configuration -----------------------*/
;;;1868     UART_GETCLOCKSOURCE(huart, clocksource);
000028  4b9a              LDR      r3,|L41.660|
00002a  ea470c0c          ORR      r12,r7,r12            ;1851
00002e  f8c0c000          STR      r12,[r0,#0]           ;1851
000032  6820              LDR      r0,[r4,#0]            ;1856
000034  f8d4c00c          LDR      r12,[r4,#0xc]         ;1856
000038  6847              LDR      r7,[r0,#4]            ;1856
00003a  f4275740          BIC      r7,r7,#0x3000         ;1856
00003e  ea470c0c          ORR      r12,r7,r12            ;1856
000042  f8c0c004          STR      r12,[r0,#4]           ;1856
000046  6820              LDR      r0,[r4,#0]            ;1865
000048  f8d4c018          LDR      r12,[r4,#0x18]        ;1864
00004c  f8d48020          LDR      r8,[r4,#0x20]         ;1865
000050  6887              LDR      r7,[r0,#8]            ;1865
000052  ea4c0c08          ORR      r12,r12,r8            ;1864
000056  f4276730          BIC      r7,r7,#0xb00          ;1865
00005a  ea470c0c          ORR      r12,r7,r12            ;1865
00005e  f8c0c008          STR      r12,[r0,#8]           ;1865
000062  6820              LDR      r0,[r4,#0]
000064  f1a04680          SUB      r6,r0,#0x40000000
000068  f5b63688          SUBS     r6,r6,#0x11000
00006c  d015              BEQ      |L41.154|
00006e  f5164c4c          ADDS     r12,r6,#0xcc00
000072  d01d              BEQ      |L41.176|
000074  f5164c48          ADDS     r12,r6,#0xc800
000078  d025              BEQ      |L41.198|
00007a  f5164c44          ADDS     r12,r6,#0xc400
00007e  d02d              BEQ      |L41.220|
000080  f5164c40          ADDS     r12,r6,#0xc000
000084  d035              BEQ      |L41.242|
000086  f5b66c80          SUBS     r12,r6,#0x400
00008a  d040              BEQ      |L41.270|
00008c  f5164c18          ADDS     r12,r6,#0x9800
000090  d04d              BEQ      |L41.302|
000092  f5164c14          ADDS     r12,r6,#0x9400
000096  d058              BEQ      |L41.330|
000098  e06c              B        |L41.372|
                  |L41.154|
00009a  681b              LDR      r3,[r3,#0]
00009c  f0130303          ANDS     r3,r3,#3
0000a0  d043              BEQ      |L41.298|
0000a2  2b01              CMP      r3,#1
0000a4  d063              BEQ      |L41.366|
0000a6  2b02              CMP      r3,#2
0000a8  d05f              BEQ      |L41.362|
0000aa  2b03              CMP      r3,#3
0000ac  d061              BEQ      |L41.370|
0000ae  e061              B        |L41.372|
                  |L41.176|
0000b0  681b              LDR      r3,[r3,#0]
0000b2  f013030c          ANDS     r3,r3,#0xc
0000b6  d056              BEQ      |L41.358|
0000b8  2b04              CMP      r3,#4
0000ba  d058              BEQ      |L41.366|
0000bc  2b08              CMP      r3,#8
0000be  d054              BEQ      |L41.362|
0000c0  2b0c              CMP      r3,#0xc
0000c2  d056              BEQ      |L41.370|
0000c4  e056              B        |L41.372|
                  |L41.198|
0000c6  681b              LDR      r3,[r3,#0]
0000c8  f0130330          ANDS     r3,r3,#0x30
0000cc  d04b              BEQ      |L41.358|
0000ce  2b10              CMP      r3,#0x10
0000d0  d04d              BEQ      |L41.366|
0000d2  2b20              CMP      r3,#0x20
0000d4  d049              BEQ      |L41.362|
0000d6  2b30              CMP      r3,#0x30
0000d8  d04b              BEQ      |L41.370|
0000da  e04b              B        |L41.372|
                  |L41.220|
0000dc  681b              LDR      r3,[r3,#0]
0000de  f01303c0          ANDS     r3,r3,#0xc0
0000e2  d040              BEQ      |L41.358|
0000e4  2b40              CMP      r3,#0x40
0000e6  d042              BEQ      |L41.366|
0000e8  2b80              CMP      r3,#0x80
0000ea  d03e              BEQ      |L41.362|
0000ec  2bc0              CMP      r3,#0xc0
0000ee  d040              BEQ      |L41.370|
0000f0  e040              B        |L41.372|
                  |L41.242|
0000f2  681b              LDR      r3,[r3,#0]
0000f4  f4137340          ANDS     r3,r3,#0x300
0000f8  d035              BEQ      |L41.358|
0000fa  f5b37f80          CMP      r3,#0x100
0000fe  d036              BEQ      |L41.366|
000100  f5b37f00          CMP      r3,#0x200
000104  d031              BEQ      |L41.362|
000106  f5b37f40          CMP      r3,#0x300
00010a  d032              BEQ      |L41.370|
00010c  e032              B        |L41.372|
                  |L41.270|
00010e  681b              LDR      r3,[r3,#0]
000110  f4136340          ANDS     r3,r3,#0xc00
000114  d009              BEQ      |L41.298|
000116  f5b36f80          CMP      r3,#0x400
00011a  d028              BEQ      |L41.366|
00011c  f5b36f00          CMP      r3,#0x800
000120  d023              BEQ      |L41.362|
000122  f5b36f40          CMP      r3,#0xc00
000126  d024              BEQ      |L41.370|
000128  e024              B        |L41.372|
                  |L41.298|
00012a  2101              MOVS     r1,#1
00012c  e022              B        |L41.372|
                  |L41.302|
00012e  681b              LDR      r3,[r3,#0]
000130  f4135340          ANDS     r3,r3,#0x3000
000134  d017              BEQ      |L41.358|
000136  f5b35f80          CMP      r3,#0x1000
00013a  d018              BEQ      |L41.366|
00013c  f5b35f00          CMP      r3,#0x2000
000140  d013              BEQ      |L41.362|
000142  f5b35f40          CMP      r3,#0x3000
000146  d014              BEQ      |L41.370|
000148  e014              B        |L41.372|
                  |L41.330|
00014a  681b              LDR      r3,[r3,#0]
00014c  f4134340          ANDS     r3,r3,#0xc000
000150  d009              BEQ      |L41.358|
000152  f5b34f80          CMP      r3,#0x4000
000156  d00a              BEQ      |L41.366|
000158  f5b34f00          CMP      r3,#0x8000
00015c  d005              BEQ      |L41.362|
00015e  f5b34f40          CMP      r3,#0xc000
000162  d006              BEQ      |L41.370|
000164  e006              B        |L41.372|
                  |L41.358|
000166  2100              MOVS     r1,#0
000168  e004              B        |L41.372|
                  |L41.362|
00016a  2102              MOVS     r1,#2
00016c  e002              B        |L41.372|
                  |L41.366|
00016e  2104              MOVS     r1,#4
000170  e000              B        |L41.372|
                  |L41.370|
000172  2108              MOVS     r1,#8
                  |L41.372|
;;;1869   
;;;1870     /* Check UART Over Sampling to set Baud Rate Register */
;;;1871     if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
000174  69e3              LDR      r3,[r4,#0x1c]
000176  f5b34f00          CMP      r3,#0x8000
00017a  d008              BEQ      |L41.398|
;;;1872     {
;;;1873       switch (clocksource)
;;;1874       {
;;;1875       case UART_CLOCKSOURCE_PCLK1:
;;;1876           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
;;;1877         break;
;;;1878       case UART_CLOCKSOURCE_PCLK2:
;;;1879           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
;;;1880         break;
;;;1881       case UART_CLOCKSOURCE_HSI:
;;;1882           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
;;;1883         break;
;;;1884       case UART_CLOCKSOURCE_SYSCLK:
;;;1885           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
;;;1886         break;
;;;1887       case UART_CLOCKSOURCE_LSE:
;;;1888           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
;;;1889         break;
;;;1890         case UART_CLOCKSOURCE_UNDEFINED:
;;;1891       default:
;;;1892           ret = HAL_ERROR;
;;;1893         break;
;;;1894       }
;;;1895   
;;;1896       brrtemp = usartdiv & 0xFFF0U;
;;;1897       brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
;;;1898       huart->Instance->BRR = brrtemp;
;;;1899     }
;;;1900     else
;;;1901     {
;;;1902       switch (clocksource)
00017c  2909              CMP      r1,#9
00017e  d277              BCS      |L41.624|
000180  e8dff001          TBB      [pc,r1]
000184  49556181          DCB      0x49,0x55,0x61,0x81
000188  6a818181          DCB      0x6a,0x81,0x81,0x81
00018c  7700              DCB      0x77,0x00
                  |L41.398|
00018e  2909              CMP      r1,#9                 ;1873
000190  d238              BCS      |L41.516|
000192  e8dff001          TBB      [pc,r1]               ;1873
000196  0510              DCB      0x05,0x10
000198  1b372337          DCB      0x1b,0x37,0x23,0x37
00019c  37372e00          DCB      0x37,0x37,0x2e,0x00
0001a0  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0001a4  4601              MOV      r1,r0                 ;1876
0001a6  6860              LDR      r0,[r4,#4]            ;1876
0001a8  0049              LSLS     r1,r1,#1              ;1876
0001aa  eb010150          ADD      r1,r1,r0,LSR #1       ;1876
0001ae  fbb1f0f0          UDIV     r0,r1,r0              ;1876
0001b2  b282              UXTH     r2,r0                 ;1876
0001b4  e027              B        |L41.518|
0001b6  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
0001ba  4601              MOV      r1,r0                 ;1879
0001bc  6860              LDR      r0,[r4,#4]            ;1879
0001be  0049              LSLS     r1,r1,#1              ;1879
0001c0  eb010150          ADD      r1,r1,r0,LSR #1       ;1879
0001c4  fbb1f0f0          UDIV     r0,r1,r0              ;1879
0001c8  b282              UXTH     r2,r0                 ;1879
0001ca  e01c              B        |L41.518|
0001cc  6860              LDR      r0,[r4,#4]            ;1882
0001ce  4932              LDR      r1,|L41.664|
0001d0  eb010150          ADD      r1,r1,r0,LSR #1       ;1882
0001d4  fbb1f0f0          UDIV     r0,r1,r0              ;1882
0001d8  b282              UXTH     r2,r0                 ;1882
0001da  e014              B        |L41.518|
0001dc  f7fffffe          BL       HAL_RCC_GetSysClockFreq
0001e0  4601              MOV      r1,r0                 ;1885
0001e2  6860              LDR      r0,[r4,#4]            ;1885
0001e4  0049              LSLS     r1,r1,#1              ;1885
0001e6  eb010150          ADD      r1,r1,r0,LSR #1       ;1885
0001ea  fbb1f0f0          UDIV     r0,r1,r0              ;1885
0001ee  b282              UXTH     r2,r0                 ;1885
0001f0  e009              B        |L41.518|
0001f2  6860              LDR      r0,[r4,#4]            ;1888
0001f4  f44f3180          MOV      r1,#0x10000           ;1888
0001f8  eb010150          ADD      r1,r1,r0,LSR #1       ;1888
0001fc  fbb1f0f0          UDIV     r0,r1,r0              ;1888
000200  b282              UXTH     r2,r0                 ;1888
000202  e000              B        |L41.518|
                  |L41.516|
000204  2501              MOVS     r5,#1                 ;1892
                  |L41.518|
000206  6821              LDR      r1,[r4,#0]            ;1898
000208  f022000f          BIC      r0,r2,#0xf            ;1896
00020c  f3c20242          UBFX     r2,r2,#1,#3           ;1897
000210  4310              ORRS     r0,r0,r2              ;1897
000212  60c8              STR      r0,[r1,#0xc]          ;1898
000214  e038              B        |L41.648|
;;;1903       {
;;;1904       case UART_CLOCKSOURCE_PCLK1:
;;;1905           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
000216  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
00021a  4601              MOV      r1,r0
00021c  e9d42000          LDRD     r2,r0,[r4,#0]
000220  eb010150          ADD      r1,r1,r0,LSR #1
000224  fbb1f0f0          UDIV     r0,r1,r0
000228  b280              UXTH     r0,r0
00022a  60d0              STR      r0,[r2,#0xc]
;;;1906         break;
00022c  e02c              B        |L41.648|
;;;1907       case UART_CLOCKSOURCE_PCLK2:
;;;1908           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
00022e  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000232  4601              MOV      r1,r0
000234  e9d42000          LDRD     r2,r0,[r4,#0]
000238  eb010150          ADD      r1,r1,r0,LSR #1
00023c  fbb1f0f0          UDIV     r0,r1,r0
000240  b280              UXTH     r0,r0
000242  60d0              STR      r0,[r2,#0xc]
;;;1909         break;
000244  e020              B        |L41.648|
;;;1910       case UART_CLOCKSOURCE_HSI:
;;;1911           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
000246  6861              LDR      r1,[r4,#4]
000248  4a14              LDR      r2,|L41.668|
00024a  eb020251          ADD      r2,r2,r1,LSR #1
00024e  fbb2f1f1          UDIV     r1,r2,r1
000252  b289              UXTH     r1,r1
000254  60c1              STR      r1,[r0,#0xc]
;;;1912         break;
000256  e017              B        |L41.648|
;;;1913       case UART_CLOCKSOURCE_SYSCLK:
;;;1914           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
000258  f7fffffe          BL       HAL_RCC_GetSysClockFreq
00025c  4601              MOV      r1,r0
00025e  e9d42000          LDRD     r2,r0,[r4,#0]
000262  eb010150          ADD      r1,r1,r0,LSR #1
000266  fbb1f0f0          UDIV     r0,r1,r0
00026a  b280              UXTH     r0,r0
00026c  60d0              STR      r0,[r2,#0xc]
;;;1915         break;
00026e  e00b              B        |L41.648|
                  |L41.624|
000270  e009              B        |L41.646|
;;;1916       case UART_CLOCKSOURCE_LSE:
;;;1917           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
000272  6861              LDR      r1,[r4,#4]
000274  f44f4200          MOV      r2,#0x8000
000278  eb020251          ADD      r2,r2,r1,LSR #1
00027c  fbb2f1f1          UDIV     r1,r2,r1
000280  b289              UXTH     r1,r1
000282  60c1              STR      r1,[r0,#0xc]
;;;1918         break;
000284  e000              B        |L41.648|
                  |L41.646|
;;;1919         case UART_CLOCKSOURCE_UNDEFINED:
;;;1920       default:
;;;1921           ret = HAL_ERROR;
000286  2501              MOVS     r5,#1
                  |L41.648|
;;;1922         break;
;;;1923       }
;;;1924     }
;;;1925   
;;;1926     return ret;
000288  4628              MOV      r0,r5
;;;1927   
;;;1928   }
00028a  e8bd81f0          POP      {r4-r8,pc}
;;;1929   
                          ENDP

00028e  0000              DCW      0x0000
                  |L41.656|
                          DCD      0xefff69f3
                  |L41.660|
                          DCD      0x40023890
                  |L41.664|
                          DCD      0x01e84800
                  |L41.668|
                          DCD      0x00f42400

                          AREA ||i.UART_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  UART_WaitOnFlagUntilTimeout PROC
;;;1334     */
;;;1335   HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1336   {
000004  4604              MOV      r4,r0
;;;1337     /* Wait until flag is set */
;;;1338     while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
000006  6800              LDR      r0,[r0,#0]
000008  4698              MOV      r8,r3                 ;1336
00000a  4615              MOV      r5,r2                 ;1336
00000c  9f06              LDR      r7,[sp,#0x18]
00000e  460e              MOV      r6,r1                 ;1336
000010  69c0              LDR      r0,[r0,#0x1c]
000012  ea310000          BICS     r0,r1,r0
000016  bf0c              ITE      EQ
000018  2001              MOVEQ    r0,#1
00001a  2000              MOVNE    r0,#0
00001c  42a8              CMP      r0,r5
00001e  d124              BNE      |L42.106|
                  |L42.32|
;;;1339     {
;;;1340       /* Check for the Timeout */
;;;1341       if(Timeout != HAL_MAX_DELAY)
000020  f1b73fff          CMP      r7,#0xffffffff
000024  d018              BEQ      |L42.88|
;;;1342       {
;;;1343         if((Timeout == 0U)||((HAL_GetTick()-Tickstart) >=  Timeout))
000026  b12f              CBZ      r7,|L42.52|
000028  f7fffffe          BL       HAL_GetTick
00002c  eba00008          SUB      r0,r0,r8
000030  42b8              CMP      r0,r7
000032  d311              BCC      |L42.88|
                  |L42.52|
;;;1344         {
;;;1345           /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;1346           CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
000034  6820              LDR      r0,[r4,#0]
;;;1347           CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1348   
;;;1349           huart->gState = HAL_UART_STATE_READY;
000036  2120              MOVS     r1,#0x20
;;;1350           huart->RxState = HAL_UART_STATE_READY;
;;;1351   
;;;1352           /* Process Unlocked */
;;;1353           __HAL_UNLOCK(huart);
000038  2200              MOVS     r2,#0
00003a  6803              LDR      r3,[r0,#0]            ;1346
00003c  f42373d0          BIC      r3,r3,#0x1a0          ;1346
000040  6003              STR      r3,[r0,#0]            ;1346
000042  6820              LDR      r0,[r4,#0]            ;1347
000044  6883              LDR      r3,[r0,#8]            ;1347
000046  f0230301          BIC      r3,r3,#1              ;1347
00004a  6083              STR      r3,[r0,#8]            ;1347
00004c  66e1              STR      r1,[r4,#0x6c]         ;1349
00004e  6721              STR      r1,[r4,#0x70]         ;1350
;;;1354           return HAL_TIMEOUT;
000050  2003              MOVS     r0,#3
000052  66a2              STR      r2,[r4,#0x68]
;;;1355         }
;;;1356       }
;;;1357     }
;;;1358     return HAL_OK;
;;;1359   }
000054  e8bd81f0          POP      {r4-r8,pc}
                  |L42.88|
000058  6820              LDR      r0,[r4,#0]            ;1354
00005a  69c0              LDR      r0,[r0,#0x1c]         ;1354
00005c  ea360000          BICS     r0,r6,r0              ;1354
000060  bf0c              ITE      EQ                    ;1354
000062  2001              MOVEQ    r0,#1                 ;1354
000064  2000              MOVNE    r0,#0                 ;1354
000066  42a8              CMP      r0,r5                 ;1354
000068  d0da              BEQ      |L42.32|
                  |L42.106|
00006a  2000              MOVS     r0,#0                 ;1358
00006c  e8bd81f0          POP      {r4-r8,pc}
;;;1360   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F7_V1.11.0\\Drivers\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f7xx_hal_uart_c_d497114f____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F7_V1.11.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___20_stm32f7xx_hal_uart_c_d497114f____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f7xx_hal_uart_c_d497114f____REVSH|
#line 402
|__asm___20_stm32f7xx_hal_uart_c_d497114f____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f7xx_hal_uart_c_d497114f____RRX|
#line 587
|__asm___20_stm32f7xx_hal_uart_c_d497114f____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
