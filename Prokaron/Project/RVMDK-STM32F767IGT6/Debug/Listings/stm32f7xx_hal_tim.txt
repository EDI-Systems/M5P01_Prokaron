; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f7xx_hal_tim.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f7xx_hal_tim.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc\Conf -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f7xx_hal_tim.crf ..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_tim.c]
                          THUMB

                          AREA ||i.HAL_TIM_Base_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_DeInit PROC
;;;308      */
;;;309    HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;310    {  
000002  4604              MOV      r4,r0
;;;311      /* Check the parameters */
;;;312      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;313    
;;;314      htim->State = HAL_TIM_STATE_BUSY;
;;;315       
;;;316      /* Disable the TIM Peripheral Clock */
;;;317      __HAL_TIM_DISABLE(htim);
000004  f2411111          MOV      r1,#0x1111
000008  2002              MOVS     r0,#2                 ;314
00000a  6420              STR      r0,[r4,#0x40]         ;314
00000c  6820              LDR      r0,[r4,#0]
00000e  6a02              LDR      r2,[r0,#0x20]
000010  420a              TST      r2,r1
000012  d108              BNE      |L1.38|
000014  6a01              LDR      r1,[r0,#0x20]
000016  f2404244          MOV      r2,#0x444
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L1.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L1.38|
;;;318    
;;;319    #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;320      if(htim->Base_MspDeInitCallback == NULL)
;;;321      {
;;;322        htim->Base_MspDeInitCallback = HAL_TIM_Base_MspDeInit;
;;;323      }
;;;324      /* DeInit the low level hardware */
;;;325      htim->Base_MspDeInitCallback(htim);
;;;326    #else
;;;327      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;328      HAL_TIM_Base_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_Base_MspDeInit
;;;329    #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;330      
;;;331      /* Change TIM state */  
;;;332      htim->State = HAL_TIM_STATE_RESET; 
00002c  2000              MOVS     r0,#0
00002e  6420              STR      r0,[r4,#0x40]
;;;333      
;;;334      /* Release Lock */
;;;335      __HAL_UNLOCK(htim);
000030  63e0              STR      r0,[r4,#0x3c]
;;;336    
;;;337      return HAL_OK;
;;;338    }
000032  bd10              POP      {r4,pc}
;;;339    
                          ENDP


                          AREA ||i.HAL_TIM_Base_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_GetState PROC
;;;5234     */
;;;5235   HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
000000  6c00              LDR      r0,[r0,#0x40]
;;;5236   {
;;;5237     return htim->State;
;;;5238   }
000002  4770              BX       lr
;;;5239   
                          ENDP


                          AREA ||i.HAL_TIM_Base_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Init PROC
;;;256      */
;;;257    HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
000000  2800              CMP      r0,#0
;;;258    { 
;;;259      /* Check the TIM handle allocation */
;;;260      if(htim == NULL)
;;;261      {
;;;262        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;263      }
;;;264    
;;;265      /* Check the parameters */
;;;266      assert_param(IS_TIM_INSTANCE(htim->Instance)); 
;;;267      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;268      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;269      assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;270    
;;;271      if(htim->State == HAL_TIM_STATE_RESET)
;;;272      {
;;;273        /* Allocate lock resource and initialize it */
;;;274        htim->Lock = HAL_UNLOCKED;
;;;275    
;;;276    #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;277        /* Reset interrupt callbacks to legacy week callbacks */
;;;278        TIM_ResetCallback(htim);
;;;279    
;;;280        if(htim->Base_MspInitCallback == NULL)
;;;281        {
;;;282          htim->Base_MspInitCallback = HAL_TIM_Base_MspInit;
;;;283        }
;;;284        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;285        htim->Base_MspInitCallback(htim);
;;;286    #else
;;;287        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;288        HAL_TIM_Base_MspInit(htim);
;;;289    #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;290      }
;;;291      /* Set the TIM state */
;;;292      htim->State= HAL_TIM_STATE_BUSY;
;;;293      
;;;294      /* Set the Time Base configuration */
;;;295      TIM_Base_SetConfig(htim->Instance, &htim->Init); 
;;;296      
;;;297      /* Initialize the TIM state*/
;;;298      htim->State= HAL_TIM_STATE_READY;
;;;299      
;;;300      return HAL_OK;
;;;301    }
000006  4770              BXEQ     lr
000008  b510              PUSH     {r4,lr}               ;258
00000a  4604              MOV      r4,r0                 ;258
00000c  6c00              LDR      r0,[r0,#0x40]         ;271
00000e  b920              CBNZ     r0,|L3.26|
000010  2000              MOVS     r0,#0                 ;274
000012  63e0              STR      r0,[r4,#0x3c]         ;288
000014  4620              MOV      r0,r4                 ;288
000016  f7fffffe          BL       HAL_TIM_Base_MspInit
                  |L3.26|
00001a  2002              MOVS     r0,#2                 ;292
00001c  6420              STR      r0,[r4,#0x40]         ;292
00001e  6820              LDR      r0,[r4,#0]            ;295
000020  1d21              ADDS     r1,r4,#4              ;295
000022  f7fffffe          BL       TIM_Base_SetConfig
000026  2001              MOVS     r0,#1                 ;298
000028  6420              STR      r0,[r4,#0x40]         ;298
00002a  2000              MOVS     r0,#0                 ;300
00002c  bd10              POP      {r4,pc}
;;;302    
                          ENDP


                          AREA ||i.HAL_TIM_Base_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_MspDeInit PROC
;;;361      */
;;;362    __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;363    {
;;;364      /* Prevent unused argument(s) compilation warning */
;;;365      UNUSED(htim);
;;;366     
;;;367      /* NOTE : This function Should not be modified, when the callback is needed,
;;;368                the HAL_TIM_Base_MspDeInit could be implemented in the user file
;;;369       */
;;;370    }
;;;371    
                          ENDP


                          AREA ||i.HAL_TIM_Base_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_MspInit PROC
;;;345      */
;;;346    __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;347    {
;;;348      /* Prevent unused argument(s) compilation warning */
;;;349      UNUSED(htim);
;;;350     
;;;351      /* NOTE : This function Should not be modified, when the callback is needed,
;;;352                the HAL_TIM_Base_MspInit could be implemented in the user file
;;;353       */
;;;354    }
;;;355    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Start PROC
;;;377      */
;;;378    HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
000000  2102              MOVS     r1,#2
;;;379    {
;;;380      /* Check the parameters */
;;;381      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;382      
;;;383      /* Set the TIM state */
;;;384      htim->State= HAL_TIM_STATE_BUSY;
000002  6401              STR      r1,[r0,#0x40]
;;;385      
;;;386      /* Enable the Peripheral */
;;;387      __HAL_TIM_ENABLE(htim);
;;;388      
;;;389      /* Change the TIM state*/
;;;390      htim->State= HAL_TIM_STATE_READY;
000004  2201              MOVS     r2,#1
000006  6801              LDR      r1,[r0,#0]            ;387
000008  680b              LDR      r3,[r1,#0]            ;387
00000a  f0430301          ORR      r3,r3,#1              ;387
00000e  600b              STR      r3,[r1,#0]            ;387
000010  6402              STR      r2,[r0,#0x40]
;;;391      
;;;392      /* Return function status */
;;;393      return HAL_OK;
000012  2000              MOVS     r0,#0
;;;394    }
000014  4770              BX       lr
;;;395    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Base_Start_DMA PROC
;;;468      */
;;;469    HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
000000  b510              PUSH     {r4,lr}
;;;470    {
000002  4604              MOV      r4,r0
;;;471      /* Check the parameters */
;;;472      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance)); 
;;;473      
;;;474      if((htim->State == HAL_TIM_STATE_BUSY))
000004  6c00              LDR      r0,[r0,#0x40]
000006  2802              CMP      r0,#2
;;;475      {
;;;476         return HAL_BUSY;
;;;477      }
;;;478      else if((htim->State == HAL_TIM_STATE_READY))
;;;479      {
;;;480        if((pData == 0 ) && (Length > 0)) 
;;;481        {
;;;482          return HAL_ERROR;                                    
;;;483        }
;;;484        else
;;;485        {
;;;486          htim->State = HAL_TIM_STATE_BUSY;
;;;487        }
;;;488      }  
;;;489      /* Set the DMA Period elapsed callback */
;;;490      htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;491         
;;;492      /* Set the DMA error callback */
;;;493      htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = HAL_TIM_DMAError ;
;;;494      
;;;495      /* Enable the DMA Stream */
;;;496      HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length);
;;;497      
;;;498      /* Enable the TIM Update DMA request */
;;;499      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
;;;500    
;;;501      /* Enable the Peripheral */
;;;502      __HAL_TIM_ENABLE(htim);  
;;;503      
;;;504      /* Return function status */
;;;505      return HAL_OK;
;;;506    }
000008  bf08              IT       EQ
00000a  bd10              POPEQ    {r4,pc}
00000c  6c20              LDR      r0,[r4,#0x40]         ;478
00000e  2801              CMP      r0,#1                 ;478
000010  d106              BNE      |L7.32|
000012  b919              CBNZ     r1,|L7.28|
000014  2a00              CMP      r2,#0                 ;480
000016  bf1c              ITT      NE                    ;482
000018  2001              MOVNE    r0,#1                 ;482
00001a  bd10              POPNE    {r4,pc}
                  |L7.28|
00001c  2002              MOVS     r0,#2                 ;486
00001e  6420              STR      r0,[r4,#0x40]         ;486
                  |L7.32|
000020  6a23              LDR      r3,[r4,#0x20]         ;490
000022  480c              LDR      r0,|L7.84|
000024  6418              STR      r0,[r3,#0x40]         ;493
000026  6a23              LDR      r3,[r4,#0x20]         ;493
000028  480b              LDR      r0,|L7.88|
00002a  6518              STR      r0,[r3,#0x50]         ;496
00002c  6823              LDR      r3,[r4,#0]            ;496
00002e  6a20              LDR      r0,[r4,#0x20]         ;496
000030  f1030c2c          ADD      r12,r3,#0x2c          ;496
000034  4613              MOV      r3,r2                 ;496
000036  4662              MOV      r2,r12                ;496
000038  f7fffffe          BL       HAL_DMA_Start_IT
00003c  6820              LDR      r0,[r4,#0]            ;499
00003e  68c1              LDR      r1,[r0,#0xc]          ;499
000040  f4417180          ORR      r1,r1,#0x100          ;499
000044  60c1              STR      r1,[r0,#0xc]          ;499
000046  6820              LDR      r0,[r4,#0]            ;502
000048  6801              LDR      r1,[r0,#0]            ;502
00004a  f0410101          ORR      r1,r1,#1              ;502
00004e  6001              STR      r1,[r0,#0]            ;502
000050  2000              MOVS     r0,#0                 ;505
000052  bd10              POP      {r4,pc}
;;;507    
                          ENDP

                  |L7.84|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L7.88|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_Base_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Start_IT PROC
;;;425      */
;;;426    HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
000000  6801              LDR      r1,[r0,#0]
;;;427    {
;;;428      /* Check the parameters */
;;;429      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;430      
;;;431      /* Enable the TIM Update interrupt */
;;;432      __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
000002  68ca              LDR      r2,[r1,#0xc]
000004  f0420201          ORR      r2,r2,#1
000008  60ca              STR      r2,[r1,#0xc]
;;;433          
;;;434      /* Enable the Peripheral */
;;;435      __HAL_TIM_ENABLE(htim);
00000a  6800              LDR      r0,[r0,#0]
00000c  6801              LDR      r1,[r0,#0]
00000e  f0410101          ORR      r1,r1,#1
000012  6001              STR      r1,[r0,#0]
;;;436          
;;;437      /* Return function status */
;;;438      return HAL_OK;
000014  2000              MOVS     r0,#0
;;;439    }
000016  4770              BX       lr
;;;440    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop PROC
;;;401      */
;;;402    HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
000000  2102              MOVS     r1,#2
;;;403    {
;;;404      /* Check the parameters */
;;;405      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;406      
;;;407      /* Set the TIM state */
;;;408      htim->State= HAL_TIM_STATE_BUSY;
;;;409      
;;;410      /* Disable the Peripheral */
;;;411      __HAL_TIM_DISABLE(htim);
000002  f2411211          MOV      r2,#0x1111
000006  6401              STR      r1,[r0,#0x40]         ;408
000008  6801              LDR      r1,[r0,#0]
00000a  6a0b              LDR      r3,[r1,#0x20]
00000c  4213              TST      r3,r2
00000e  d108              BNE      |L9.34|
000010  6a0a              LDR      r2,[r1,#0x20]
000012  f2404344          MOV      r3,#0x444
000016  421a              TST      r2,r3
000018  d103              BNE      |L9.34|
00001a  680a              LDR      r2,[r1,#0]
00001c  f0220201          BIC      r2,r2,#1
000020  600a              STR      r2,[r1,#0]
                  |L9.34|
;;;412      
;;;413      /* Change the TIM state*/
;;;414      htim->State= HAL_TIM_STATE_READY;
000022  2101              MOVS     r1,#1
000024  6401              STR      r1,[r0,#0x40]
;;;415      
;;;416      /* Return function status */
;;;417      return HAL_OK;
000026  2000              MOVS     r0,#0
;;;418    }
000028  4770              BX       lr
;;;419    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop_DMA PROC
;;;513      */
;;;514    HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
000000  6801              LDR      r1,[r0,#0]
;;;515    {
;;;516      /* Check the parameters */
;;;517      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
;;;518      
;;;519      /* Disable the TIM Update DMA request */
;;;520      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
;;;521          
;;;522      /* Disable the Peripheral */
;;;523      __HAL_TIM_DISABLE(htim);
000002  f2411211          MOV      r2,#0x1111
000006  68cb              LDR      r3,[r1,#0xc]          ;520
000008  f4237380          BIC      r3,r3,#0x100          ;520
00000c  60cb              STR      r3,[r1,#0xc]          ;520
00000e  6801              LDR      r1,[r0,#0]
000010  6a0b              LDR      r3,[r1,#0x20]
000012  4213              TST      r3,r2
000014  d108              BNE      |L10.40|
000016  6a0a              LDR      r2,[r1,#0x20]
000018  f2404344          MOV      r3,#0x444
00001c  421a              TST      r2,r3
00001e  d103              BNE      |L10.40|
000020  680a              LDR      r2,[r1,#0]
000022  f0220201          BIC      r2,r2,#1
000026  600a              STR      r2,[r1,#0]
                  |L10.40|
;;;524        
;;;525      /* Change the htim state */
;;;526      htim->State = HAL_TIM_STATE_READY;
000028  2101              MOVS     r1,#1
00002a  6401              STR      r1,[r0,#0x40]
;;;527          
;;;528      /* Return function status */
;;;529      return HAL_OK;
00002c  2000              MOVS     r0,#0
;;;530    }
00002e  4770              BX       lr
;;;531    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop_IT PROC
;;;446      */
;;;447    HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
000000  6801              LDR      r1,[r0,#0]
;;;448    {
;;;449      /* Check the parameters */
;;;450      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;451      /* Disable the TIM Update interrupt */
;;;452      __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
;;;453          
;;;454      /* Disable the Peripheral */
;;;455      __HAL_TIM_DISABLE(htim);
000002  f2411211          MOV      r2,#0x1111
000006  68cb              LDR      r3,[r1,#0xc]          ;452
000008  f0230301          BIC      r3,r3,#1              ;452
00000c  60cb              STR      r3,[r1,#0xc]          ;452
00000e  6800              LDR      r0,[r0,#0]
000010  6a01              LDR      r1,[r0,#0x20]
000012  4211              TST      r1,r2
000014  d107              BNE      |L11.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L11.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L11.38|
;;;456        
;;;457      /* Return function status */
;;;458      return HAL_OK;
000026  2000              MOVS     r0,#0
;;;459    }
000028  4770              BX       lr
;;;460    
                          ENDP


                          AREA ||i.HAL_TIM_ConfigClockSource||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigClockSource PROC
;;;4223     */ 
;;;4224   HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)    
000000  6bc2              LDR      r2,[r0,#0x3c]
;;;4225   {
;;;4226     uint32_t tmpsmcr = 0;
;;;4227       
;;;4228     /* Process Locked */
;;;4229     __HAL_LOCK(htim);
000002  2a01              CMP      r2,#1
000004  bf0d              ITEET    EQ
000006  2002              MOVEQ    r0,#2
000008  2301              MOVNE    r3,#1
00000a  63c3              STRNE    r3,[r0,#0x3c]
;;;4230     
;;;4231     htim->State = HAL_TIM_STATE_BUSY;
;;;4232     
;;;4233     /* Check the parameters */
;;;4234     assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
;;;4235     
;;;4236     /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
;;;4237     tmpsmcr = htim->Instance->SMCR;
;;;4238     tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
;;;4239     tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
;;;4240     htim->Instance->SMCR = tmpsmcr;
;;;4241     
;;;4242     switch (sClockSourceConfig->ClockSource)
;;;4243     {
;;;4244       case TIM_CLOCKSOURCE_INTERNAL:
;;;4245       { 
;;;4246         assert_param(IS_TIM_INSTANCE(htim->Instance));      
;;;4247         /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;4248         htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;4249       }
;;;4250       break;
;;;4251       
;;;4252       case TIM_CLOCKSOURCE_ETRMODE1:
;;;4253       {
;;;4254         assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
;;;4255         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4256         assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
;;;4257         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4258         /* Configure the ETR Clock source */
;;;4259         TIM_ETR_SetConfig(htim->Instance, 
;;;4260                           sClockSourceConfig->ClockPrescaler, 
;;;4261                           sClockSourceConfig->ClockPolarity, 
;;;4262                           sClockSourceConfig->ClockFilter);
;;;4263         /* Get the TIMx SMCR register value */
;;;4264         tmpsmcr = htim->Instance->SMCR;
;;;4265         /* Reset the SMS and TS Bits */
;;;4266         tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
;;;4267         /* Select the External clock mode1 and the ETRF trigger */
;;;4268         tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
;;;4269         /* Write to TIMx SMCR */
;;;4270         htim->Instance->SMCR = tmpsmcr;
;;;4271       }
;;;4272       break;
;;;4273       
;;;4274       case TIM_CLOCKSOURCE_ETRMODE2:
;;;4275       {
;;;4276         assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
;;;4277         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4278         assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
;;;4279         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4280         
;;;4281         /* Configure the ETR Clock source */
;;;4282         TIM_ETR_SetConfig(htim->Instance, 
;;;4283                           sClockSourceConfig->ClockPrescaler, 
;;;4284                           sClockSourceConfig->ClockPolarity,
;;;4285                           sClockSourceConfig->ClockFilter);
;;;4286         /* Enable the External clock mode2 */
;;;4287         htim->Instance->SMCR |= TIM_SMCR_ECE;
;;;4288       }
;;;4289       break;
;;;4290       
;;;4291       case TIM_CLOCKSOURCE_TI1:
;;;4292       {
;;;4293         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;4294     
;;;4295         /* Check TI1 input conditioning related parameters */
;;;4296         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4297         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4298   
;;;4299         TIM_TI1_ConfigInputStage(htim->Instance, 
;;;4300                           sClockSourceConfig->ClockPolarity, 
;;;4301                           sClockSourceConfig->ClockFilter);
;;;4302         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
;;;4303       }
;;;4304       break;
;;;4305       case TIM_CLOCKSOURCE_TI2:
;;;4306       {
;;;4307         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;4308         
;;;4309         /* Check TI1 input conditioning related parameters */
;;;4310         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4311         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4312   
;;;4313         TIM_TI2_ConfigInputStage(htim->Instance, 
;;;4314                           sClockSourceConfig->ClockPolarity, 
;;;4315                           sClockSourceConfig->ClockFilter);
;;;4316         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
;;;4317       }
;;;4318       break;
;;;4319       case TIM_CLOCKSOURCE_TI1ED:
;;;4320       {
;;;4321         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;4322         /* Check TI1 input conditioning related parameters */
;;;4323         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4324         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4325     
;;;4326         TIM_TI1_ConfigInputStage(htim->Instance, 
;;;4327                           sClockSourceConfig->ClockPolarity,
;;;4328                           sClockSourceConfig->ClockFilter);
;;;4329         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
;;;4330       }
;;;4331       break;
;;;4332       case TIM_CLOCKSOURCE_ITR0:
;;;4333       {
;;;4334         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4335         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR0);
;;;4336       }
;;;4337       break;
;;;4338       case TIM_CLOCKSOURCE_ITR1:
;;;4339       {
;;;4340         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4341         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR1);
;;;4342       }
;;;4343       break;
;;;4344       case TIM_CLOCKSOURCE_ITR2:
;;;4345       {
;;;4346         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4347         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR2);
;;;4348       }
;;;4349       break;
;;;4350       case TIM_CLOCKSOURCE_ITR3:
;;;4351       {
;;;4352         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4353         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR3);
;;;4354       }
;;;4355       break;
;;;4356       
;;;4357       default:
;;;4358       break;    
;;;4359     }
;;;4360     htim->State = HAL_TIM_STATE_READY;
;;;4361     
;;;4362     __HAL_UNLOCK(htim);
;;;4363     
;;;4364     return HAL_OK;
;;;4365   }
00000c  4770              BXEQ     lr
00000e  b470              PUSH     {r4-r6}               ;4225
000010  2202              MOVS     r2,#2                 ;4231
000012  6402              STR      r2,[r0,#0x40]         ;4231
000014  f8d0c000          LDR      r12,[r0,#0]           ;4237
000018  f8dc2008          LDR      r2,[r12,#8]           ;4237
00001c  f0220277          BIC      r2,r2,#0x77           ;4238
000020  f4223280          BIC      r2,r2,#0x10000        ;4238
000024  f422427f          BIC      r2,r2,#0xff00         ;4239
000028  f8cc2008          STR      r2,[r12,#8]           ;4240
00002c  680a              LDR      r2,[r1,#0]            ;4242
00002e  2a50              CMP      r2,#0x50              ;4242
000030  d049              BEQ      |L12.198|
000032  dc0c              BGT      |L12.78|
000034  2a20              CMP      r2,#0x20              ;4242
000036  d07d              BEQ      |L12.308|
000038  dc04              BGT      |L12.68|
00003a  2a00              CMP      r2,#0                 ;4242
00003c  d07b              BEQ      |L12.310|
00003e  2a10              CMP      r2,#0x10              ;4242
000040  d07a              BEQ      |L12.312|
000042  e0bc              B        |L12.446|
                  |L12.68|
000044  2a30              CMP      r2,#0x30              ;4242
000046  d078              BEQ      |L12.314|
000048  2a40              CMP      r2,#0x40              ;4242
00004a  d07c              BEQ      |L12.326|
00004c  e0b7              B        |L12.446|
                  |L12.78|
00004e  2a60              CMP      r2,#0x60              ;4242
000050  d056              BEQ      |L12.256|
000052  2a70              CMP      r2,#0x70              ;4242
000054  d00d              BEQ      |L12.114|
000056  f5b25f80          CMP      r2,#0x1000            ;4242
00005a  d003              BEQ      |L12.100|
00005c  f5b25f00          CMP      r2,#0x2000            ;4242
000060  d01e              BEQ      |L12.160|
000062  e0ac              B        |L12.446|
                  |L12.100|
000064  6801              LDR      r1,[r0,#0]            ;4248
000066  688a              LDR      r2,[r1,#8]            ;4248
000068  f0220207          BIC      r2,r2,#7              ;4248
00006c  f4223280          BIC      r2,r2,#0x10000        ;4248
000070  e044              B        |L12.252|
                  |L12.114|
000072  6802              LDR      r2,[r0,#0]            ;4259
000074  e9d14c01          LDRD     r4,r12,[r1,#4]        ;4259
000078  68c9              LDR      r1,[r1,#0xc]          ;4259
00007a  6895              LDR      r5,[r2,#8]            ;4259
00007c  ea442101          ORR      r1,r4,r1,LSL #8       ;4259
000080  ea410c0c          ORR      r12,r1,r12            ;4259
000084  f425417f          BIC      r1,r5,#0xff00         ;4259
000088  ea4c0101          ORR      r1,r12,r1             ;4259
00008c  6091              STR      r1,[r2,#8]            ;4259
00008e  6801              LDR      r1,[r0,#0]            ;4264
000090  688a              LDR      r2,[r1,#8]            ;4264
000092  f0220277          BIC      r2,r2,#0x77           ;4266
000096  f4223280          BIC      r2,r2,#0x10000        ;4266
00009a  f0420277          ORR      r2,r2,#0x77           ;4268
00009e  e02d              B        |L12.252|
                  |L12.160|
0000a0  6802              LDR      r2,[r0,#0]            ;4282
0000a2  e9d14c01          LDRD     r4,r12,[r1,#4]        ;4282
0000a6  68c9              LDR      r1,[r1,#0xc]          ;4282
0000a8  6895              LDR      r5,[r2,#8]            ;4282
0000aa  ea442101          ORR      r1,r4,r1,LSL #8       ;4282
0000ae  ea410c0c          ORR      r12,r1,r12            ;4282
0000b2  f425417f          BIC      r1,r5,#0xff00         ;4282
0000b6  ea4c0101          ORR      r1,r12,r1             ;4282
0000ba  6091              STR      r1,[r2,#8]            ;4282
0000bc  6801              LDR      r1,[r0,#0]            ;4287
0000be  688a              LDR      r2,[r1,#8]            ;4287
0000c0  f4424280          ORR      r2,r2,#0x4000         ;4287
0000c4  e01a              B        |L12.252|
                  |L12.198|
0000c6  6802              LDR      r2,[r0,#0]            ;4299
0000c8  f8d1c004          LDR      r12,[r1,#4]           ;4299
0000cc  68c9              LDR      r1,[r1,#0xc]          ;4299
0000ce  6a14              LDR      r4,[r2,#0x20]         ;4299
0000d0  6a15              LDR      r5,[r2,#0x20]         ;4299
0000d2  f0250601          BIC      r6,r5,#1              ;4299
0000d6  6216              STR      r6,[r2,#0x20]         ;4299
0000d8  f024050a          BIC      r5,r4,#0xa            ;4299
0000dc  6994              LDR      r4,[r2,#0x18]         ;4299
0000de  ea450c0c          ORR      r12,r5,r12            ;4299
0000e2  f02404f0          BIC      r4,r4,#0xf0           ;4299
0000e6  ea441101          ORR      r1,r4,r1,LSL #4       ;4299
0000ea  6191              STR      r1,[r2,#0x18]         ;4299
0000ec  f8c2c020          STR      r12,[r2,#0x20]        ;4299
0000f0  6801              LDR      r1,[r0,#0]            ;4299
0000f2  688a              LDR      r2,[r1,#8]            ;4299
0000f4  f0220270          BIC      r2,r2,#0x70           ;4299
0000f8  f0420257          ORR      r2,r2,#0x57           ;4299
                  |L12.252|
0000fc  608a              STR      r2,[r1,#8]            ;4287
0000fe  e05e              B        |L12.446|
                  |L12.256|
000100  6802              LDR      r2,[r0,#0]            ;4313
000102  f8d1c004          LDR      r12,[r1,#4]           ;4313
000106  68c9              LDR      r1,[r1,#0xc]          ;4313
000108  6a14              LDR      r4,[r2,#0x20]         ;4313
00010a  f0240410          BIC      r4,r4,#0x10           ;4313
00010e  6214              STR      r4,[r2,#0x20]         ;4313
000110  6994              LDR      r4,[r2,#0x18]         ;4313
000112  6a16              LDR      r6,[r2,#0x20]         ;4313
000114  f4244570          BIC      r5,r4,#0xf000         ;4313
000118  f02604a0          BIC      r4,r6,#0xa0           ;4313
00011c  ea453101          ORR      r1,r5,r1,LSL #12      ;4313
000120  6191              STR      r1,[r2,#0x18]         ;4313
000122  ea441c0c          ORR      r12,r4,r12,LSL #4     ;4313
000126  f8c2c020          STR      r12,[r2,#0x20]        ;4313
00012a  6801              LDR      r1,[r0,#0]            ;4313
00012c  688a              LDR      r2,[r1,#8]            ;4313
00012e  f0220270          BIC      r2,r2,#0x70           ;4313
000132  e004              B        |L12.318|
                  |L12.308|
000134  e034              B        |L12.416|
                  |L12.310|
000136  e023              B        |L12.384|
                  |L12.312|
000138  e02a              B        |L12.400|
                  |L12.314|
00013a  e039              B        |L12.432|
00013c  e003              B        |L12.326|
                  |L12.318|
00013e  f0420267          ORR      r2,r2,#0x67           ;4313
000142  608a              STR      r2,[r1,#8]            ;4313
000144  e03b              B        |L12.446|
                  |L12.326|
000146  6802              LDR      r2,[r0,#0]            ;4326
000148  f8d1c004          LDR      r12,[r1,#4]           ;4326
00014c  68c9              LDR      r1,[r1,#0xc]          ;4326
00014e  6a14              LDR      r4,[r2,#0x20]         ;4326
000150  6a15              LDR      r5,[r2,#0x20]         ;4326
000152  f0250601          BIC      r6,r5,#1              ;4326
000156  6216              STR      r6,[r2,#0x20]         ;4326
000158  f024050a          BIC      r5,r4,#0xa            ;4326
00015c  6994              LDR      r4,[r2,#0x18]         ;4326
00015e  ea450c0c          ORR      r12,r5,r12            ;4326
000162  f02404f0          BIC      r4,r4,#0xf0           ;4326
000166  ea441101          ORR      r1,r4,r1,LSL #4       ;4326
00016a  6191              STR      r1,[r2,#0x18]         ;4326
00016c  f8c2c020          STR      r12,[r2,#0x20]        ;4326
000170  6801              LDR      r1,[r0,#0]            ;4326
000172  688a              LDR      r2,[r1,#8]            ;4326
000174  f0220270          BIC      r2,r2,#0x70           ;4326
000178  f0420247          ORR      r2,r2,#0x47           ;4326
00017c  608a              STR      r2,[r1,#8]            ;4326
00017e  e01e              B        |L12.446|
                  |L12.384|
000180  6801              LDR      r1,[r0,#0]            ;4331
000182  688a              LDR      r2,[r1,#8]            ;4331
000184  f0220270          BIC      r2,r2,#0x70           ;4331
000188  f0420207          ORR      r2,r2,#7              ;4331
00018c  608a              STR      r2,[r1,#8]            ;4331
00018e  e016              B        |L12.446|
                  |L12.400|
000190  6801              LDR      r1,[r0,#0]            ;4337
000192  688a              LDR      r2,[r1,#8]            ;4337
000194  f0220270          BIC      r2,r2,#0x70           ;4337
000198  f0420217          ORR      r2,r2,#0x17           ;4337
00019c  608a              STR      r2,[r1,#8]            ;4337
00019e  e00e              B        |L12.446|
                  |L12.416|
0001a0  6801              LDR      r1,[r0,#0]            ;4343
0001a2  688a              LDR      r2,[r1,#8]            ;4343
0001a4  f0220270          BIC      r2,r2,#0x70           ;4343
0001a8  f0420227          ORR      r2,r2,#0x27           ;4343
0001ac  608a              STR      r2,[r1,#8]            ;4343
0001ae  e006              B        |L12.446|
                  |L12.432|
0001b0  6801              LDR      r1,[r0,#0]            ;4349
0001b2  688a              LDR      r2,[r1,#8]            ;4349
0001b4  f0220270          BIC      r2,r2,#0x70           ;4349
0001b8  f0420237          ORR      r2,r2,#0x37           ;4349
0001bc  608a              STR      r2,[r1,#8]            ;4349
                  |L12.446|
0001be  2100              MOVS     r1,#0                 ;4362
0001c0  6403              STR      r3,[r0,#0x40]         ;4360
0001c2  63c1              STR      r1,[r0,#0x3c]         ;4364
0001c4  4608              MOV      r0,r1                 ;4364
0001c6  bc70              POP      {r4-r6}
0001c8  4770              BX       lr
;;;4366   
                          ENDP


                          AREA ||i.HAL_TIM_ConfigOCrefClear||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigOCrefClear PROC
;;;4119     */ 
;;;4120   __weak HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim, TIM_ClearInputConfigTypeDef * sClearInputConfig, uint32_t Channel)
000000  b4f0              PUSH     {r4-r7}
;;;4121   { 
;;;4122     /* Check the parameters */
;;;4123     assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4124     assert_param(IS_TIM_CHANNELS(Channel));
;;;4125     assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
;;;4126      
;;;4127     /* Process Locked */
;;;4128     __HAL_LOCK(htim);
000002  6bc3              LDR      r3,[r0,#0x3c]
000004  2b01              CMP      r3,#1
000006  bf02              ITTT     EQ
000008  2002              MOVEQ    r0,#2
;;;4129     
;;;4130     htim->State = HAL_TIM_STATE_BUSY;
;;;4131     
;;;4132     if(sClearInputConfig->ClearInputSource == TIM_CLEARINPUTSOURCE_ETR)
;;;4133     {
;;;4134       assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
;;;4135       assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
;;;4136       assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
;;;4137     
;;;4138       TIM_ETR_SetConfig(htim->Instance, 
;;;4139                         sClearInputConfig->ClearInputPrescaler,
;;;4140                         sClearInputConfig->ClearInputPolarity,
;;;4141                         sClearInputConfig->ClearInputFilter);
;;;4142     }
;;;4143     
;;;4144     switch (Channel)
;;;4145     {
;;;4146       case TIM_CHANNEL_1:
;;;4147       {        
;;;4148         if(sClearInputConfig->ClearInputState != RESET)  
;;;4149         {
;;;4150           /* Enable the Ocref clear feature for Channel 1 */
;;;4151           htim->Instance->CCMR1 |= TIM_CCMR1_OC1CE;
;;;4152         }
;;;4153         else
;;;4154         {
;;;4155           /* Disable the Ocref clear feature for Channel 1 */
;;;4156           htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1CE;      
;;;4157         }
;;;4158       }    
;;;4159       break;
;;;4160       case TIM_CHANNEL_2:    
;;;4161       { 
;;;4162         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance)); 
;;;4163         if(sClearInputConfig->ClearInputState != RESET)  
;;;4164         {
;;;4165           /* Enable the Ocref clear feature for Channel 2 */
;;;4166           htim->Instance->CCMR1 |= TIM_CCMR1_OC2CE;
;;;4167         }
;;;4168         else
;;;4169         {
;;;4170           /* Disable the Ocref clear feature for Channel 2 */
;;;4171           htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2CE;      
;;;4172         }
;;;4173       } 
;;;4174       break;
;;;4175       case TIM_CHANNEL_3:   
;;;4176       {  
;;;4177         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;4178         if(sClearInputConfig->ClearInputState != RESET)  
;;;4179         {
;;;4180           /* Enable the Ocref clear feature for Channel 3 */
;;;4181           htim->Instance->CCMR2 |= TIM_CCMR2_OC3CE;
;;;4182         }
;;;4183         else
;;;4184         {
;;;4185           /* Disable the Ocref clear feature for Channel 3 */
;;;4186           htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3CE;      
;;;4187         }
;;;4188       } 
;;;4189       break;
;;;4190       case TIM_CHANNEL_4:    
;;;4191       {  
;;;4192         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;4193         if(sClearInputConfig->ClearInputState != RESET)  
;;;4194         {
;;;4195           /* Enable the Ocref clear feature for Channel 4 */
;;;4196           htim->Instance->CCMR2 |= TIM_CCMR2_OC4CE;
;;;4197         }
;;;4198         else
;;;4199         {
;;;4200           /* Disable the Ocref clear feature for Channel 4 */
;;;4201           htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4CE;      
;;;4202         }
;;;4203       } 
;;;4204       break;
;;;4205       default:  
;;;4206       break;
;;;4207     } 
;;;4208   
;;;4209     htim->State = HAL_TIM_STATE_READY;
;;;4210     
;;;4211     __HAL_UNLOCK(htim);
;;;4212     
;;;4213     return HAL_OK;  
;;;4214   }  
00000a  bcf0              POPEQ    {r4-r7}
00000c  4770              BXEQ     lr
00000e  f04f0c01          MOV      r12,#1                ;4128
000012  f8c0c03c          STR      r12,[r0,#0x3c]        ;4130
000016  2302              MOVS     r3,#2                 ;4130
000018  6403              STR      r3,[r0,#0x40]         ;4130
00001a  684b              LDR      r3,[r1,#4]            ;4132
00001c  2b01              CMP      r3,#1                 ;4132
00001e  d10c              BNE      |L13.58|
000020  6803              LDR      r3,[r0,#0]            ;4138
000022  e9d14702          LDRD     r4,r7,[r1,#8]         ;4138
000026  690e              LDR      r6,[r1,#0x10]         ;4138
000028  689d              LDR      r5,[r3,#8]            ;4138
00002a  ea442406          ORR      r4,r4,r6,LSL #8       ;4138
00002e  ea440607          ORR      r6,r4,r7              ;4138
000032  f425447f          BIC      r4,r5,#0xff00         ;4138
000036  4334              ORRS     r4,r4,r6              ;4138
000038  609c              STR      r4,[r3,#8]            ;4138
                  |L13.58|
00003a  b132              CBZ      r2,|L13.74|
00003c  2a04              CMP      r2,#4                 ;4144
00003e  d00f              BEQ      |L13.96|
000040  2a08              CMP      r2,#8                 ;4144
000042  d017              BEQ      |L13.116|
000044  2a0c              CMP      r2,#0xc               ;4144
000046  d026              BEQ      |L13.150|
000048  e01e              B        |L13.136|
                  |L13.74|
00004a  6809              LDR      r1,[r1,#0]            ;4148
00004c  2900              CMP      r1,#0                 ;4148
00004e  6801              LDR      r1,[r0,#0]            ;4156
000050  698a              LDR      r2,[r1,#0x18]         ;4156
000052  bf14              ITE      NE                    ;4151
000054  f0420280          ORRNE    r2,r2,#0x80           ;4151
000058  f0220280          BICEQ    r2,r2,#0x80           ;4156
                  |L13.92|
00005c  618a              STR      r2,[r1,#0x18]         ;4151
00005e  e013              B        |L13.136|
                  |L13.96|
000060  6809              LDR      r1,[r1,#0]            ;4163
000062  2900              CMP      r1,#0                 ;4163
000064  6801              LDR      r1,[r0,#0]            ;4171
000066  698a              LDR      r2,[r1,#0x18]         ;4171
000068  bf14              ITE      NE                    ;4166
00006a  f4424200          ORRNE    r2,r2,#0x8000         ;4166
00006e  f4224200          BICEQ    r2,r2,#0x8000         ;4171
000072  e7f3              B        |L13.92|
                  |L13.116|
000074  6809              LDR      r1,[r1,#0]            ;4178
000076  2900              CMP      r1,#0                 ;4178
000078  6801              LDR      r1,[r0,#0]            ;4186
00007a  69ca              LDR      r2,[r1,#0x1c]         ;4186
00007c  bf14              ITE      NE                    ;4181
00007e  f0420280          ORRNE    r2,r2,#0x80           ;4181
000082  f0220280          BICEQ    r2,r2,#0x80           ;4186
                  |L13.134|
000086  61ca              STR      r2,[r1,#0x1c]         ;4181
                  |L13.136|
000088  2100              MOVS     r1,#0                 ;4211
00008a  f8c0c040          STR      r12,[r0,#0x40]        ;4209
00008e  63c1              STR      r1,[r0,#0x3c]         ;4213
000090  4608              MOV      r0,r1                 ;4213
000092  bcf0              POP      {r4-r7}
000094  4770              BX       lr
                  |L13.150|
000096  6809              LDR      r1,[r1,#0]            ;4193
000098  2900              CMP      r1,#0                 ;4193
00009a  6801              LDR      r1,[r0,#0]            ;4201
00009c  69ca              LDR      r2,[r1,#0x1c]         ;4201
00009e  bf14              ITE      NE                    ;4196
0000a0  f4424200          ORRNE    r2,r2,#0x8000         ;4196
0000a4  f4224200          BICEQ    r2,r2,#0x8000         ;4201
0000a8  e7ed              B        |L13.134|
;;;4215   
                          ENDP


                          AREA ||i.HAL_TIM_ConfigTI1Input||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigTI1Input PROC
;;;4379     */
;;;4380   HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
000000  6800              LDR      r0,[r0,#0]
;;;4381   {
;;;4382     uint32_t tmpcr2 = 0;
;;;4383     
;;;4384     /* Check the parameters */
;;;4385     assert_param(IS_TIM_XOR_INSTANCE(htim->Instance)); 
;;;4386     assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
;;;4387   
;;;4388     /* Get the TIMx CR2 register value */
;;;4389     tmpcr2 = htim->Instance->CR2;
000002  6842              LDR      r2,[r0,#4]
;;;4390   
;;;4391     /* Reset the TI1 selection */
;;;4392     tmpcr2 &= ~TIM_CR2_TI1S;
000004  f0220280          BIC      r2,r2,#0x80
;;;4393   
;;;4394     /* Set the TI1 selection */
;;;4395     tmpcr2 |= TI1_Selection;
000008  4311              ORRS     r1,r1,r2
;;;4396     
;;;4397     /* Write to TIMxCR2 */
;;;4398     htim->Instance->CR2 = tmpcr2;
00000a  6041              STR      r1,[r0,#4]
;;;4399   
;;;4400     return HAL_OK;
00000c  2000              MOVS     r0,#0
;;;4401   }
00000e  4770              BX       lr
;;;4402   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_ReadStart||, CODE, READONLY, ALIGN=2

                  HAL_TIM_DMABurst_ReadStart PROC
;;;3874     */
;;;3875   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3876                                                uint32_t  *BurstBuffer, uint32_t  BurstLength)
;;;3877   {
000004  4604              MOV      r4,r0
;;;3878     /* Check the parameters */
;;;3879     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;3880     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;3881     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3882     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;3883     
;;;3884     if((htim->State == HAL_TIM_STATE_BUSY))
000006  6c00              LDR      r0,[r0,#0x40]
000008  469c              MOV      r12,r3                ;3877
00000a  4616              MOV      r6,r2                 ;3877
00000c  9d06              LDR      r5,[sp,#0x18]
00000e  4688              MOV      r8,r1                 ;3877
000010  2802              CMP      r0,#2
;;;3885     {
;;;3886        return HAL_BUSY;
;;;3887     }
;;;3888     else if((htim->State == HAL_TIM_STATE_READY))
;;;3889     {
;;;3890       if((BurstBuffer == 0 ) && (BurstLength > 0)) 
;;;3891       {
;;;3892         return HAL_ERROR;                                    
;;;3893       }
;;;3894       else
;;;3895       {
;;;3896         htim->State = HAL_TIM_STATE_BUSY;
;;;3897       }
;;;3898     }  
;;;3899     switch(BurstRequestSrc)
;;;3900     {
;;;3901       case TIM_DMA_UPDATE:
;;;3902       {  
;;;3903         /* Set the DMA Period elapsed callback */
;;;3904         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;3905        
;;;3906         /* Set the DMA error callback */
;;;3907         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3908     
;;;3909         /* Enable the DMA Stream */
;;;3910          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);     
;;;3911       }
;;;3912       break;
;;;3913       case TIM_DMA_CC1:
;;;3914       {  
;;;3915         /* Set the DMA Period elapsed callback */
;;;3916         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;3917        
;;;3918         /* Set the DMA error callback */
;;;3919         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3920     
;;;3921         /* Enable the DMA Stream */
;;;3922         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3923       }
;;;3924       break;
;;;3925       case TIM_DMA_CC2:
;;;3926       {  
;;;3927         /* Set the DMA Period elapsed callback */
;;;3928         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;3929        
;;;3930         /* Set the DMA error callback */
;;;3931         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3932     
;;;3933         /* Enable the DMA Stream */
;;;3934         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);     
;;;3935       }
;;;3936       break;
;;;3937       case TIM_DMA_CC3:
;;;3938       {  
;;;3939         /* Set the DMA Period elapsed callback */
;;;3940         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;3941        
;;;3942         /* Set the DMA error callback */
;;;3943         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3944     
;;;3945         /* Enable the DMA Stream */
;;;3946         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3947       }
;;;3948       break;
;;;3949       case TIM_DMA_CC4:
;;;3950       {  
;;;3951         /* Set the DMA Period elapsed callback */
;;;3952         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;3953        
;;;3954         /* Set the DMA error callback */
;;;3955         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3956     
;;;3957         /* Enable the DMA Stream */
;;;3958         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3959       }
;;;3960       break;
;;;3961       case TIM_DMA_COM:
;;;3962       {  
;;;3963         /* Set the DMA Period elapsed callback */
;;;3964         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = HAL_TIMEx_DMACommutationCplt;
;;;3965        
;;;3966         /* Set the DMA error callback */
;;;3967         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3968     
;;;3969         /* Enable the DMA Stream */
;;;3970         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3971       }
;;;3972       break;
;;;3973       case TIM_DMA_TRIGGER:
;;;3974       {  
;;;3975         /* Set the DMA Period elapsed callback */
;;;3976         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;3977        
;;;3978         /* Set the DMA error callback */
;;;3979         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3980     
;;;3981         /* Enable the DMA Stream */
;;;3982         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3983       }
;;;3984       break;
;;;3985       default:
;;;3986       break;  
;;;3987     }
;;;3988   
;;;3989     /* configure the DMA Burst Mode */
;;;3990     htim->Instance->DCR = BurstBaseAddress | BurstLength;  
;;;3991     
;;;3992     /* Enable the TIM DMA Request */
;;;3993     __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
;;;3994     
;;;3995     htim->State = HAL_TIM_STATE_READY;
;;;3996     
;;;3997     /* Return function status */
;;;3998     return HAL_OK;
;;;3999   }
000012  bf08              IT       EQ
000014  e8bd81f0          POPEQ    {r4-r8,pc}
000018  6c20              LDR      r0,[r4,#0x40]         ;3888
00001a  2801              CMP      r0,#1                 ;3888
00001c  d109              BNE      |L15.50|
00001e  f1bc0f00          CMP      r12,#0                ;3890
000022  d104              BNE      |L15.46|
000024  2d00              CMP      r5,#0                 ;3890
000026  bf1c              ITT      NE                    ;3892
000028  2001              MOVNE    r0,#1                 ;3892
00002a  e8bd81f0          POPNE    {r4-r8,pc}
                  |L15.46|
00002e  2002              MOVS     r0,#2                 ;3896
000030  6420              STR      r0,[r4,#0x40]         ;3896
                  |L15.50|
000032  2701              MOVS     r7,#1                 ;3892
000034  483b              LDR      r0,|L15.292|
000036  f5b66f00          CMP      r6,#0x800             ;3899
00003a  4a3b              LDR      r2,|L15.296|
00003c  eb072315          ADD      r3,r7,r5,LSR #8       ;3910
000040  d036              BEQ      |L15.176|
000042  dc09              BGT      |L15.88|
000044  f5b67f80          CMP      r6,#0x100             ;3899
000048  d010              BEQ      |L15.108|
00004a  f5b67f00          CMP      r6,#0x200             ;3899
00004e  d019              BEQ      |L15.132|
000050  f5b66f80          CMP      r6,#0x400             ;3899
000054  d021              BEQ      |L15.154|
000056  e058              B        |L15.266|
                  |L15.88|
000058  f5b65f80          CMP      r6,#0x1000            ;3899
00005c  d033              BEQ      |L15.198|
00005e  f5b65f00          CMP      r6,#0x2000            ;3899
000062  d03b              BEQ      |L15.220|
000064  f5b64f80          CMP      r6,#0x4000            ;3899
000068  d044              BEQ      |L15.244|
00006a  e04e              B        |L15.266|
                  |L15.108|
00006c  6a22              LDR      r2,[r4,#0x20]         ;3904
00006e  492f              LDR      r1,|L15.300|
000070  6411              STR      r1,[r2,#0x40]         ;3907
000072  4662              MOV      r2,r12                ;3910
000074  6a21              LDR      r1,[r4,#0x20]         ;3907
000076  6508              STR      r0,[r1,#0x50]         ;3910
000078  6821              LDR      r1,[r4,#0]            ;3910
00007a  6a20              LDR      r0,[r4,#0x20]         ;3910
00007c  314c              ADDS     r1,r1,#0x4c           ;3910
00007e  f7fffffe          BL       HAL_DMA_Start_IT
000082  e042              B        |L15.266|
                  |L15.132|
000084  6a61              LDR      r1,[r4,#0x24]         ;3916
000086  640a              STR      r2,[r1,#0x40]         ;3919
000088  4662              MOV      r2,r12                ;3922
00008a  6a61              LDR      r1,[r4,#0x24]         ;3919
00008c  6508              STR      r0,[r1,#0x50]         ;3922
00008e  6821              LDR      r1,[r4,#0]            ;3922
000090  6a60              LDR      r0,[r4,#0x24]         ;3922
000092  314c              ADDS     r1,r1,#0x4c           ;3922
000094  f7fffffe          BL       HAL_DMA_Start_IT
000098  e037              B        |L15.266|
                  |L15.154|
00009a  6aa1              LDR      r1,[r4,#0x28]         ;3928
00009c  640a              STR      r2,[r1,#0x40]         ;3931
00009e  4662              MOV      r2,r12                ;3934
0000a0  6aa1              LDR      r1,[r4,#0x28]         ;3931
0000a2  6508              STR      r0,[r1,#0x50]         ;3934
0000a4  6821              LDR      r1,[r4,#0]            ;3934
0000a6  6aa0              LDR      r0,[r4,#0x28]         ;3934
0000a8  314c              ADDS     r1,r1,#0x4c           ;3934
0000aa  f7fffffe          BL       HAL_DMA_Start_IT
0000ae  e02c              B        |L15.266|
                  |L15.176|
0000b0  6ae1              LDR      r1,[r4,#0x2c]         ;3940
0000b2  640a              STR      r2,[r1,#0x40]         ;3943
0000b4  4662              MOV      r2,r12                ;3946
0000b6  6ae1              LDR      r1,[r4,#0x2c]         ;3943
0000b8  6508              STR      r0,[r1,#0x50]         ;3946
0000ba  6821              LDR      r1,[r4,#0]            ;3946
0000bc  6ae0              LDR      r0,[r4,#0x2c]         ;3946
0000be  314c              ADDS     r1,r1,#0x4c           ;3946
0000c0  f7fffffe          BL       HAL_DMA_Start_IT
0000c4  e021              B        |L15.266|
                  |L15.198|
0000c6  6b21              LDR      r1,[r4,#0x30]         ;3952
0000c8  640a              STR      r2,[r1,#0x40]         ;3955
0000ca  4662              MOV      r2,r12                ;3958
0000cc  6b21              LDR      r1,[r4,#0x30]         ;3955
0000ce  6508              STR      r0,[r1,#0x50]         ;3958
0000d0  6821              LDR      r1,[r4,#0]            ;3958
0000d2  6b20              LDR      r0,[r4,#0x30]         ;3958
0000d4  314c              ADDS     r1,r1,#0x4c           ;3958
0000d6  f7fffffe          BL       HAL_DMA_Start_IT
0000da  e016              B        |L15.266|
                  |L15.220|
0000dc  6b62              LDR      r2,[r4,#0x34]         ;3964
0000de  4914              LDR      r1,|L15.304|
0000e0  6411              STR      r1,[r2,#0x40]         ;3967
0000e2  4662              MOV      r2,r12                ;3970
0000e4  6b61              LDR      r1,[r4,#0x34]         ;3967
0000e6  6508              STR      r0,[r1,#0x50]         ;3970
0000e8  6821              LDR      r1,[r4,#0]            ;3970
0000ea  6b60              LDR      r0,[r4,#0x34]         ;3970
0000ec  314c              ADDS     r1,r1,#0x4c           ;3970
0000ee  f7fffffe          BL       HAL_DMA_Start_IT
0000f2  e00a              B        |L15.266|
                  |L15.244|
0000f4  6ba2              LDR      r2,[r4,#0x38]         ;3976
0000f6  490f              LDR      r1,|L15.308|
0000f8  6411              STR      r1,[r2,#0x40]         ;3979
0000fa  4662              MOV      r2,r12                ;3982
0000fc  6ba1              LDR      r1,[r4,#0x38]         ;3979
0000fe  6508              STR      r0,[r1,#0x50]         ;3982
000100  6821              LDR      r1,[r4,#0]            ;3982
000102  6ba0              LDR      r0,[r4,#0x38]         ;3982
000104  314c              ADDS     r1,r1,#0x4c           ;3982
000106  f7fffffe          BL       HAL_DMA_Start_IT
                  |L15.266|
00010a  6820              LDR      r0,[r4,#0]            ;3990
00010c  ea480105          ORR      r1,r8,r5              ;3990
000110  6481              STR      r1,[r0,#0x48]         ;3990
000112  6820              LDR      r0,[r4,#0]            ;3993
000114  68c1              LDR      r1,[r0,#0xc]          ;3993
000116  4331              ORRS     r1,r1,r6              ;3993
000118  60c1              STR      r1,[r0,#0xc]          ;3993
00011a  6427              STR      r7,[r4,#0x40]         ;3995
00011c  2000              MOVS     r0,#0                 ;3998
00011e  e8bd81f0          POP      {r4-r8,pc}
;;;4000   
                          ENDP

000122  0000              DCW      0x0000
                  |L15.292|
                          DCD      TIM_DMAError
                  |L15.296|
                          DCD      TIM_DMACaptureCplt
                  |L15.300|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L15.304|
                          DCD      TIMEx_DMACommutationCplt
                  |L15.308|
                          DCD      TIM_DMATriggerCplt

                          AREA ||i.HAL_TIM_DMABurst_ReadStop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_ReadStop PROC
;;;4007     */
;;;4008   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
000000  b570              PUSH     {r4-r6,lr}
;;;4009   {
;;;4010     /* Check the parameters */
;;;4011     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;4012     
;;;4013     /* Abort the DMA transfer (at least disable the DMA channel) */
;;;4014     switch(BurstRequestSrc)
000002  f5b16f00          CMP      r1,#0x800
000006  460d              MOV      r5,r1                 ;4009
000008  4604              MOV      r4,r0                 ;4009
;;;4015     {
;;;4016       case TIM_DMA_UPDATE:
;;;4017       {  
;;;4018         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
;;;4019       }
;;;4020       break;
;;;4021       case TIM_DMA_CC1:
;;;4022       {  
;;;4023         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
;;;4024       }
;;;4025       break;
;;;4026       case TIM_DMA_CC2:
;;;4027       {  
;;;4028         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
;;;4029       }
;;;4030       break;
;;;4031       case TIM_DMA_CC3:
;;;4032       {  
;;;4033         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
00000a  bf08              IT       EQ
00000c  6ae0              LDREQ    r0,[r4,#0x2c]
00000e  d021              BEQ      |L16.84|
000010  dc0f              BGT      |L16.50|
000012  f5b57f80          CMP      r5,#0x100             ;4014
000016  bf08              IT       EQ                    ;4018
000018  6a20              LDREQ    r0,[r4,#0x20]         ;4018
00001a  d01b              BEQ      |L16.84|
00001c  f5b57f00          CMP      r5,#0x200             ;4014
000020  bf08              IT       EQ                    ;4023
000022  6a60              LDREQ    r0,[r4,#0x24]         ;4023
000024  d016              BEQ      |L16.84|
000026  f5b56f80          CMP      r5,#0x400             ;4014
00002a  bf08              IT       EQ                    ;4028
00002c  6aa0              LDREQ    r0,[r4,#0x28]         ;4028
00002e  d011              BEQ      |L16.84|
000030  e012              B        |L16.88|
                  |L16.50|
000032  f5b55f80          CMP      r5,#0x1000            ;4014
;;;4034       }
;;;4035       break;
;;;4036       case TIM_DMA_CC4:
;;;4037       {  
;;;4038         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
000036  bf08              IT       EQ
000038  6b20              LDREQ    r0,[r4,#0x30]
00003a  d00b              BEQ      |L16.84|
00003c  f5b55f00          CMP      r5,#0x2000            ;4014
;;;4039       }
;;;4040       break;
;;;4041       case TIM_DMA_COM:
;;;4042       {  
;;;4043         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
000040  bf08              IT       EQ
000042  6b60              LDREQ    r0,[r4,#0x34]
000044  d006              BEQ      |L16.84|
000046  f5b54f80          CMP      r5,#0x4000            ;4014
;;;4044       }
;;;4045       break;
;;;4046       case TIM_DMA_TRIGGER:
;;;4047       {  
;;;4048         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
00004a  bf04              ITT      EQ
00004c  6ba0              LDREQ    r0,[r4,#0x38]
00004e  f7fffffe          BLEQ     HAL_DMA_Abort
000052  e001              B        |L16.88|
                  |L16.84|
000054  f7fffffe          BL       HAL_DMA_Abort
                  |L16.88|
;;;4049       }
;;;4050       break;
;;;4051       default:
;;;4052       break;  
;;;4053     }
;;;4054     
;;;4055     /* Disable the TIM Update DMA request */
;;;4056     __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
000058  6820              LDR      r0,[r4,#0]
00005a  68c1              LDR      r1,[r0,#0xc]
00005c  43a9              BICS     r1,r1,r5
00005e  60c1              STR      r1,[r0,#0xc]
;;;4057         
;;;4058     /* Return function status */
;;;4059     return HAL_OK;  
000060  2000              MOVS     r0,#0
;;;4060   }
000062  bd70              POP      {r4-r6,pc}
;;;4061   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_WriteStart||, CODE, READONLY, ALIGN=2

                  HAL_TIM_DMABurst_WriteStart PROC
;;;3649     */
;;;3650   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3651                                                 uint32_t* BurstBuffer, uint32_t  BurstLength)
;;;3652   {
000004  4604              MOV      r4,r0
;;;3653     /* Check the parameters */
;;;3654     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;3655     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;3656     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3657     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;3658     
;;;3659     if((htim->State == HAL_TIM_STATE_BUSY))
000006  6c00              LDR      r0,[r0,#0x40]
000008  469c              MOV      r12,r3                ;3652
00000a  4616              MOV      r6,r2                 ;3652
00000c  9d06              LDR      r5,[sp,#0x18]
00000e  4688              MOV      r8,r1                 ;3652
000010  2802              CMP      r0,#2
;;;3660     {
;;;3661        return HAL_BUSY;
;;;3662     }
;;;3663     else if((htim->State == HAL_TIM_STATE_READY))
;;;3664     {
;;;3665       if((BurstBuffer == 0 ) && (BurstLength > 0)) 
;;;3666       {
;;;3667         return HAL_ERROR;                                    
;;;3668       }
;;;3669       else
;;;3670       {
;;;3671         htim->State = HAL_TIM_STATE_BUSY;
;;;3672       }
;;;3673     }
;;;3674     switch(BurstRequestSrc)
;;;3675     {
;;;3676       case TIM_DMA_UPDATE:
;;;3677       {  
;;;3678         /* Set the DMA Period elapsed callback */
;;;3679         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;3680        
;;;3681         /* Set the DMA error callback */
;;;3682         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3683     
;;;3684         /* Enable the DMA Stream */
;;;3685         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1); 
;;;3686       }
;;;3687       break;
;;;3688       case TIM_DMA_CC1:
;;;3689       {  
;;;3690         /* Set the DMA Period elapsed callback */
;;;3691         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;3692        
;;;3693         /* Set the DMA error callback */
;;;3694         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3695     
;;;3696         /* Enable the DMA Stream */
;;;3697         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3698       }
;;;3699       break;
;;;3700       case TIM_DMA_CC2:
;;;3701       {  
;;;3702         /* Set the DMA Period elapsed callback */
;;;3703         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;3704        
;;;3705         /* Set the DMA error callback */
;;;3706         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3707     
;;;3708         /* Enable the DMA Stream */
;;;3709         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3710       }
;;;3711       break;
;;;3712       case TIM_DMA_CC3:
;;;3713       {  
;;;3714         /* Set the DMA Period elapsed callback */
;;;3715         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;3716        
;;;3717         /* Set the DMA error callback */
;;;3718         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3719     
;;;3720         /* Enable the DMA Stream */
;;;3721         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3722       }
;;;3723       break;
;;;3724       case TIM_DMA_CC4:
;;;3725       {  
;;;3726         /* Set the DMA Period elapsed callback */
;;;3727         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;3728        
;;;3729         /* Set the DMA error callback */
;;;3730         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3731     
;;;3732         /* Enable the DMA Stream */
;;;3733         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3734       }
;;;3735       break;
;;;3736       case TIM_DMA_COM:
;;;3737       {  
;;;3738         /* Set the DMA Period elapsed callback */
;;;3739         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = HAL_TIMEx_DMACommutationCplt;
;;;3740        
;;;3741         /* Set the DMA error callback */
;;;3742         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3743     
;;;3744         /* Enable the DMA Stream */
;;;3745         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3746       }
;;;3747       break;
;;;3748       case TIM_DMA_TRIGGER:
;;;3749       {  
;;;3750         /* Set the DMA Period elapsed callback */
;;;3751         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;3752        
;;;3753         /* Set the DMA error callback */
;;;3754         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3755     
;;;3756         /* Enable the DMA Stream */
;;;3757         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3758       }
;;;3759       break;
;;;3760       default:
;;;3761       break;  
;;;3762     }
;;;3763      /* configure the DMA Burst Mode */
;;;3764      htim->Instance->DCR = BurstBaseAddress | BurstLength;  
;;;3765      
;;;3766      /* Enable the TIM DMA Request */
;;;3767      __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);  
;;;3768      
;;;3769      htim->State = HAL_TIM_STATE_READY;
;;;3770     
;;;3771     /* Return function status */
;;;3772     return HAL_OK;
;;;3773   }
000012  bf08              IT       EQ
000014  e8bd81f0          POPEQ    {r4-r8,pc}
000018  6c20              LDR      r0,[r4,#0x40]         ;3663
00001a  2801              CMP      r0,#1                 ;3663
00001c  d109              BNE      |L17.50|
00001e  f1bc0f00          CMP      r12,#0                ;3665
000022  d104              BNE      |L17.46|
000024  2d00              CMP      r5,#0                 ;3665
000026  bf1c              ITT      NE                    ;3667
000028  2001              MOVNE    r0,#1                 ;3667
00002a  e8bd81f0          POPNE    {r4-r8,pc}
                  |L17.46|
00002e  2002              MOVS     r0,#2                 ;3671
000030  6420              STR      r0,[r4,#0x40]         ;3671
                  |L17.50|
000032  2701              MOVS     r7,#1                 ;3667
000034  483e              LDR      r0,|L17.304|
000036  f5b66f00          CMP      r6,#0x800             ;3674
00003a  493e              LDR      r1,|L17.308|
00003c  eb072315          ADD      r3,r7,r5,LSR #8       ;3685
000040  d039              BEQ      |L17.182|
000042  dc09              BGT      |L17.88|
000044  f5b67f80          CMP      r6,#0x100             ;3674
000048  d010              BEQ      |L17.108|
00004a  f5b67f00          CMP      r6,#0x200             ;3674
00004e  d01a              BEQ      |L17.134|
000050  f5b66f80          CMP      r6,#0x400             ;3674
000054  d023              BEQ      |L17.158|
000056  e05f              B        |L17.280|
                  |L17.88|
000058  f5b65f80          CMP      r6,#0x1000            ;3674
00005c  d037              BEQ      |L17.206|
00005e  f5b65f00          CMP      r6,#0x2000            ;3674
000062  d040              BEQ      |L17.230|
000064  f5b64f80          CMP      r6,#0x4000            ;3674
000068  d04a              BEQ      |L17.256|
00006a  e055              B        |L17.280|
                  |L17.108|
00006c  6a22              LDR      r2,[r4,#0x20]         ;3679
00006e  4932              LDR      r1,|L17.312|
000070  6411              STR      r1,[r2,#0x40]         ;3682
000072  6a21              LDR      r1,[r4,#0x20]         ;3682
000074  6508              STR      r0,[r1,#0x50]         ;3685
000076  6821              LDR      r1,[r4,#0]            ;3685
000078  6a20              LDR      r0,[r4,#0x20]         ;3685
00007a  f101024c          ADD      r2,r1,#0x4c           ;3685
00007e  4661              MOV      r1,r12                ;3685
000080  f7fffffe          BL       HAL_DMA_Start_IT
000084  e048              B        |L17.280|
                  |L17.134|
000086  6a62              LDR      r2,[r4,#0x24]         ;3691
000088  6411              STR      r1,[r2,#0x40]         ;3694
00008a  6a61              LDR      r1,[r4,#0x24]         ;3694
00008c  6508              STR      r0,[r1,#0x50]         ;3697
00008e  6821              LDR      r1,[r4,#0]            ;3697
000090  6a60              LDR      r0,[r4,#0x24]         ;3697
000092  f101024c          ADD      r2,r1,#0x4c           ;3697
000096  4661              MOV      r1,r12                ;3697
000098  f7fffffe          BL       HAL_DMA_Start_IT
00009c  e03c              B        |L17.280|
                  |L17.158|
00009e  6aa2              LDR      r2,[r4,#0x28]         ;3703
0000a0  6411              STR      r1,[r2,#0x40]         ;3706
0000a2  6aa1              LDR      r1,[r4,#0x28]         ;3706
0000a4  6508              STR      r0,[r1,#0x50]         ;3709
0000a6  6821              LDR      r1,[r4,#0]            ;3709
0000a8  6aa0              LDR      r0,[r4,#0x28]         ;3709
0000aa  f101024c          ADD      r2,r1,#0x4c           ;3709
0000ae  4661              MOV      r1,r12                ;3709
0000b0  f7fffffe          BL       HAL_DMA_Start_IT
0000b4  e030              B        |L17.280|
                  |L17.182|
0000b6  6ae2              LDR      r2,[r4,#0x2c]         ;3715
0000b8  6411              STR      r1,[r2,#0x40]         ;3718
0000ba  6ae1              LDR      r1,[r4,#0x2c]         ;3718
0000bc  6508              STR      r0,[r1,#0x50]         ;3721
0000be  6821              LDR      r1,[r4,#0]            ;3721
0000c0  6ae0              LDR      r0,[r4,#0x2c]         ;3721
0000c2  f101024c          ADD      r2,r1,#0x4c           ;3721
0000c6  4661              MOV      r1,r12                ;3721
0000c8  f7fffffe          BL       HAL_DMA_Start_IT
0000cc  e024              B        |L17.280|
                  |L17.206|
0000ce  6b22              LDR      r2,[r4,#0x30]         ;3727
0000d0  6411              STR      r1,[r2,#0x40]         ;3730
0000d2  6b21              LDR      r1,[r4,#0x30]         ;3730
0000d4  6508              STR      r0,[r1,#0x50]         ;3733
0000d6  6821              LDR      r1,[r4,#0]            ;3733
0000d8  6b20              LDR      r0,[r4,#0x30]         ;3733
0000da  f101024c          ADD      r2,r1,#0x4c           ;3733
0000de  4661              MOV      r1,r12                ;3733
0000e0  f7fffffe          BL       HAL_DMA_Start_IT
0000e4  e018              B        |L17.280|
                  |L17.230|
0000e6  6b62              LDR      r2,[r4,#0x34]         ;3739
0000e8  4914              LDR      r1,|L17.316|
0000ea  6411              STR      r1,[r2,#0x40]         ;3742
0000ec  6b61              LDR      r1,[r4,#0x34]         ;3742
0000ee  6508              STR      r0,[r1,#0x50]         ;3745
0000f0  6821              LDR      r1,[r4,#0]            ;3745
0000f2  6b60              LDR      r0,[r4,#0x34]         ;3745
0000f4  f101024c          ADD      r2,r1,#0x4c           ;3745
0000f8  4661              MOV      r1,r12                ;3745
0000fa  f7fffffe          BL       HAL_DMA_Start_IT
0000fe  e00b              B        |L17.280|
                  |L17.256|
000100  6ba2              LDR      r2,[r4,#0x38]         ;3751
000102  490f              LDR      r1,|L17.320|
000104  6411              STR      r1,[r2,#0x40]         ;3754
000106  6ba1              LDR      r1,[r4,#0x38]         ;3754
000108  6508              STR      r0,[r1,#0x50]         ;3757
00010a  6821              LDR      r1,[r4,#0]            ;3757
00010c  6ba0              LDR      r0,[r4,#0x38]         ;3757
00010e  f101024c          ADD      r2,r1,#0x4c           ;3757
000112  4661              MOV      r1,r12                ;3757
000114  f7fffffe          BL       HAL_DMA_Start_IT
                  |L17.280|
000118  6820              LDR      r0,[r4,#0]            ;3764
00011a  ea480105          ORR      r1,r8,r5              ;3764
00011e  6481              STR      r1,[r0,#0x48]         ;3764
000120  6820              LDR      r0,[r4,#0]            ;3767
000122  68c1              LDR      r1,[r0,#0xc]          ;3767
000124  4331              ORRS     r1,r1,r6              ;3767
000126  60c1              STR      r1,[r0,#0xc]          ;3767
000128  6427              STR      r7,[r4,#0x40]         ;3769
00012a  2000              MOVS     r0,#0                 ;3772
00012c  e8bd81f0          POP      {r4-r8,pc}
;;;3774   
                          ENDP

                  |L17.304|
                          DCD      TIM_DMAError
                  |L17.308|
                          DCD      TIM_DMADelayPulseCplt
                  |L17.312|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L17.316|
                          DCD      TIMEx_DMACommutationCplt
                  |L17.320|
                          DCD      TIM_DMATriggerCplt

                          AREA ||i.HAL_TIM_DMABurst_WriteStop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_WriteStop PROC
;;;3781     */
;;;3782   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
000000  b570              PUSH     {r4-r6,lr}
;;;3783   {
;;;3784     /* Check the parameters */
;;;3785     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3786     
;;;3787     /* Abort the DMA transfer (at least disable the DMA channel) */
;;;3788     switch(BurstRequestSrc)
000002  f5b16f00          CMP      r1,#0x800
000006  460d              MOV      r5,r1                 ;3783
000008  4604              MOV      r4,r0                 ;3783
;;;3789     {
;;;3790       case TIM_DMA_UPDATE:
;;;3791       {  
;;;3792         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
;;;3793       }
;;;3794       break;
;;;3795       case TIM_DMA_CC1:
;;;3796       {  
;;;3797         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
;;;3798       }
;;;3799       break;
;;;3800       case TIM_DMA_CC2:
;;;3801       {  
;;;3802         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
;;;3803       }
;;;3804       break;
;;;3805       case TIM_DMA_CC3:
;;;3806       {  
;;;3807         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
00000a  bf08              IT       EQ
00000c  6ae0              LDREQ    r0,[r4,#0x2c]
00000e  d021              BEQ      |L18.84|
000010  dc0f              BGT      |L18.50|
000012  f5b57f80          CMP      r5,#0x100             ;3788
000016  bf08              IT       EQ                    ;3792
000018  6a20              LDREQ    r0,[r4,#0x20]         ;3792
00001a  d01b              BEQ      |L18.84|
00001c  f5b57f00          CMP      r5,#0x200             ;3788
000020  bf08              IT       EQ                    ;3797
000022  6a60              LDREQ    r0,[r4,#0x24]         ;3797
000024  d016              BEQ      |L18.84|
000026  f5b56f80          CMP      r5,#0x400             ;3788
00002a  bf08              IT       EQ                    ;3802
00002c  6aa0              LDREQ    r0,[r4,#0x28]         ;3802
00002e  d011              BEQ      |L18.84|
000030  e012              B        |L18.88|
                  |L18.50|
000032  f5b55f80          CMP      r5,#0x1000            ;3788
;;;3808       }
;;;3809       break;
;;;3810       case TIM_DMA_CC4:
;;;3811       {  
;;;3812         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
000036  bf08              IT       EQ
000038  6b20              LDREQ    r0,[r4,#0x30]
00003a  d00b              BEQ      |L18.84|
00003c  f5b55f00          CMP      r5,#0x2000            ;3788
;;;3813       }
;;;3814       break;
;;;3815       case TIM_DMA_COM:
;;;3816       {  
;;;3817         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
000040  bf08              IT       EQ
000042  6b60              LDREQ    r0,[r4,#0x34]
000044  d006              BEQ      |L18.84|
000046  f5b54f80          CMP      r5,#0x4000            ;3788
;;;3818       }
;;;3819       break;
;;;3820       case TIM_DMA_TRIGGER:
;;;3821       {  
;;;3822         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
00004a  bf04              ITT      EQ
00004c  6ba0              LDREQ    r0,[r4,#0x38]
00004e  f7fffffe          BLEQ     HAL_DMA_Abort
000052  e001              B        |L18.88|
                  |L18.84|
000054  f7fffffe          BL       HAL_DMA_Abort
                  |L18.88|
;;;3823       }
;;;3824       break;
;;;3825       default:
;;;3826       break;
;;;3827     }
;;;3828   
;;;3829     /* Disable the TIM Update DMA request */
;;;3830     __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
000058  6820              LDR      r0,[r4,#0]
00005a  68c1              LDR      r1,[r0,#0xc]
00005c  43a9              BICS     r1,r1,r5
00005e  60c1              STR      r1,[r0,#0xc]
;;;3831         
;;;3832     /* Return function status */
;;;3833     return HAL_OK;  
000060  2000              MOVS     r0,#0
;;;3834   }
000062  bd70              POP      {r4-r6,pc}
;;;3835   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_DeInit PROC
;;;2566     */
;;;2567   HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;2568   {
000002  4604              MOV      r4,r0
;;;2569     /* Check the parameters */
;;;2570     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2571     
;;;2572     htim->State = HAL_TIM_STATE_BUSY;
;;;2573     
;;;2574     /* Disable the TIM Peripheral Clock */
;;;2575     __HAL_TIM_DISABLE(htim);
000004  f2411111          MOV      r1,#0x1111
000008  2002              MOVS     r0,#2                 ;2572
00000a  6420              STR      r0,[r4,#0x40]         ;2572
00000c  6820              LDR      r0,[r4,#0]
00000e  6a02              LDR      r2,[r0,#0x20]
000010  420a              TST      r2,r1
000012  d108              BNE      |L19.38|
000014  6a01              LDR      r1,[r0,#0x20]
000016  f2404244          MOV      r2,#0x444
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L19.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L19.38|
;;;2576   
;;;2577   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;2578     if(htim->Encoder_MspDeInitCallback == NULL)
;;;2579     {
;;;2580       htim->Encoder_MspDeInitCallback = HAL_TIM_Encoder_MspDeInit;
;;;2581     }
;;;2582     /* DeInit the low level hardware */
;;;2583     htim->Encoder_MspDeInitCallback(htim);
;;;2584   #else
;;;2585     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;2586     HAL_TIM_Encoder_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_Encoder_MspDeInit
;;;2587   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;2588   
;;;2589     /* Change TIM state */  
;;;2590     htim->State = HAL_TIM_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  6420              STR      r0,[r4,#0x40]
;;;2591    
;;;2592     /* Release Lock */
;;;2593     __HAL_UNLOCK(htim);
000030  63e0              STR      r0,[r4,#0x3c]
;;;2594   
;;;2595     return HAL_OK;
;;;2596   }
000032  bd10              POP      {r4,pc}
;;;2597   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_GetState PROC
;;;5289     */
;;;5290   HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
000000  6c00              LDR      r0,[r0,#0x40]
;;;5291   {
;;;5292     return htim->State;
;;;5293   }
000002  4770              BX       lr
;;;5294   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Init PROC
;;;2461     */
;;;2462   HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef* sConfig)
000000  2800              CMP      r0,#0
;;;2463   {
;;;2464     uint32_t tmpsmcr = 0;
;;;2465     uint32_t tmpccmr1 = 0;
;;;2466     uint32_t tmpccer = 0;
;;;2467     
;;;2468     /* Check the TIM handle allocation */
;;;2469     if(htim == NULL)
;;;2470     {
;;;2471       return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;2472     }
;;;2473      
;;;2474     /* Check the parameters */
;;;2475     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2476     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;2477     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;2478     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;2479     assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
;;;2480     assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
;;;2481     assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
;;;2482     assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
;;;2483     assert_param(IS_TIM_IC_POLARITY(sConfig->IC2Polarity));
;;;2484     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
;;;2485     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
;;;2486     assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
;;;2487     assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
;;;2488   
;;;2489     if(htim->State == HAL_TIM_STATE_RESET)
;;;2490     {
;;;2491       /* Allocate lock resource and initialize it */
;;;2492       htim->Lock = HAL_UNLOCKED;
;;;2493   
;;;2494   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;2495       /* Reset interrupt callbacks to legacy week callbacks */
;;;2496       TIM_ResetCallback(htim);
;;;2497   
;;;2498       if(htim->Encoder_MspInitCallback == NULL)
;;;2499       {
;;;2500         htim->Encoder_MspInitCallback = HAL_TIM_Encoder_MspInit;
;;;2501       }
;;;2502       /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;2503       htim->Encoder_MspInitCallback(htim);
;;;2504   #else
;;;2505       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;2506       HAL_TIM_Encoder_MspInit(htim);
;;;2507   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;2508     }
;;;2509   
;;;2510     /* Set the TIM state */
;;;2511     htim->State= HAL_TIM_STATE_BUSY;   
;;;2512       
;;;2513     /* Reset the SMS bits */
;;;2514     htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;2515     
;;;2516     /* Configure the Time base in the Encoder Mode */
;;;2517     TIM_Base_SetConfig(htim->Instance, &htim->Init);  
;;;2518     
;;;2519     /* Get the TIMx SMCR register value */
;;;2520     tmpsmcr = htim->Instance->SMCR;
;;;2521   
;;;2522     /* Get the TIMx CCMR1 register value */
;;;2523     tmpccmr1 = htim->Instance->CCMR1;
;;;2524   
;;;2525     /* Get the TIMx CCER register value */
;;;2526     tmpccer = htim->Instance->CCER;
;;;2527   
;;;2528     /* Set the encoder Mode */
;;;2529     tmpsmcr |= sConfig->EncoderMode;
;;;2530   
;;;2531     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;2532     tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
;;;2533     tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8));
;;;2534     
;;;2535     /* Set the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
;;;2536     tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
;;;2537     tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
;;;2538     tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8);
;;;2539     tmpccmr1 |= (sConfig->IC1Filter << 4) | (sConfig->IC2Filter << 12);
;;;2540   
;;;2541     /* Set the TI1 and the TI2 Polarities */
;;;2542     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
;;;2543     tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
;;;2544     tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4);
;;;2545     
;;;2546     /* Write to TIMx SMCR */
;;;2547     htim->Instance->SMCR = tmpsmcr;
;;;2548   
;;;2549     /* Write to TIMx CCMR1 */
;;;2550     htim->Instance->CCMR1 = tmpccmr1;
;;;2551   
;;;2552     /* Write to TIMx CCER */
;;;2553     htim->Instance->CCER = tmpccer;
;;;2554     
;;;2555     /* Initialize the TIM state*/
;;;2556     htim->State= HAL_TIM_STATE_READY;
;;;2557     
;;;2558     return HAL_OK;
;;;2559   }
000006  4770              BXEQ     lr
000008  e92d41f0          PUSH     {r4-r8,lr}            ;2463
00000c  4604              MOV      r4,r0                 ;2463
00000e  6c00              LDR      r0,[r0,#0x40]         ;2489
000010  460d              MOV      r5,r1                 ;2463
000012  b920              CBNZ     r0,|L21.30|
000014  2000              MOVS     r0,#0                 ;2492
000016  63e0              STR      r0,[r4,#0x3c]         ;2506
000018  4620              MOV      r0,r4                 ;2506
00001a  f7fffffe          BL       HAL_TIM_Encoder_MspInit
                  |L21.30|
00001e  2002              MOVS     r0,#2                 ;2511
000020  6420              STR      r0,[r4,#0x40]         ;2511
000022  6820              LDR      r0,[r4,#0]            ;2514
000024  6881              LDR      r1,[r0,#8]            ;2514
000026  f0210107          BIC      r1,r1,#7              ;2514
00002a  f4213180          BIC      r1,r1,#0x10000        ;2514
00002e  6081              STR      r1,[r0,#8]            ;2514
000030  6820              LDR      r0,[r4,#0]            ;2517
000032  1d21              ADDS     r1,r4,#4              ;2517
000034  f7fffffe          BL       TIM_Base_SetConfig
000038  6820              LDR      r0,[r4,#0]            ;2533
00003a  e9d57c06          LDRD     r7,r12,[r5,#0x18]     ;2529
00003e  682e              LDR      r6,[r5,#0]            ;2520
000040  68ab              LDR      r3,[r5,#8]            ;2520
000042  6881              LDR      r1,[r0,#8]            ;2520
000044  6982              LDR      r2,[r0,#0x18]         ;2523
000046  4331              ORRS     r1,r1,r6              ;2529
000048  f0220203          BIC      r2,r2,#3              ;2532
00004c  e9d56803          LDRD     r6,r8,[r5,#0xc]       ;2539
000050  f4227240          BIC      r2,r2,#0x300          ;2532
000054  ea422207          ORR      r2,r2,r7,LSL #8       ;2533
000058  6a2f              LDR      r7,[r5,#0x20]         ;2526
00005a  431a              ORRS     r2,r2,r3              ;2533
00005c  f022030c          BIC      r3,r2,#0xc            ;2536
000060  6a02              LDR      r2,[r0,#0x20]         ;2526
000062  ea4f1808          LSL      r8,r8,#4              ;2539
000066  f4236340          BIC      r3,r3,#0xc00          ;2536
00006a  f02303f0          BIC      r3,r3,#0xf0           ;2537
00006e  f4234370          BIC      r3,r3,#0xf000         ;2537
000072  ea483707          ORR      r7,r8,r7,LSL #12      ;2539
000076  f8d58004          LDR      r8,[r5,#4]            ;2547
00007a  ea43230c          ORR      r3,r3,r12,LSL #8      ;2538
00007e  f8d5c014          LDR      r12,[r5,#0x14]        ;2547
000082  4333              ORRS     r3,r3,r6              ;2538
000084  6081              STR      r1,[r0,#8]            ;2547
000086  ea470003          ORR      r0,r7,r3              ;2539
00008a  6823              LDR      r3,[r4,#0]            ;2550
00008c  f0220122          BIC      r1,r2,#0x22           ;2542
000090  2201              MOVS     r2,#1                 ;2556
000092  6198              STR      r0,[r3,#0x18]         ;2550
000094  f0210088          BIC      r0,r1,#0x88           ;2543
000098  6821              LDR      r1,[r4,#0]            ;2553
00009a  ea40100c          ORR      r0,r0,r12,LSL #4      ;2544
00009e  ea480000          ORR      r0,r8,r0              ;2544
0000a2  6208              STR      r0,[r1,#0x20]         ;2553
0000a4  6422              STR      r2,[r4,#0x40]         ;2556
0000a6  2000              MOVS     r0,#0                 ;2558
0000a8  e8bd81f0          POP      {r4-r8,pc}
;;;2560   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_MspDeInit PROC
;;;2619     */
;;;2620   __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2621   {
;;;2622     /* Prevent unused argument(s) compilation warning */
;;;2623     UNUSED(htim);
;;;2624    
;;;2625     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2626               the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
;;;2627      */
;;;2628   }
;;;2629   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_MspInit PROC
;;;2603     */
;;;2604   __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2605   {
;;;2606     /* Prevent unused argument(s) compilation warning */
;;;2607     UNUSED(htim);
;;;2608    
;;;2609     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2610               the HAL_TIM_Encoder_MspInit could be implemented in the user file
;;;2611      */
;;;2612   }
;;;2613   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Start PROC
;;;2640     */
;;;2641   HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
;;;2642   {
000002  b1c9              CBZ      r1,|L24.56|
;;;2643     /* Check the parameters */
;;;2644     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2645     
;;;2646     /* Enable the encoder interface channels */
;;;2647     switch (Channel)
000004  2904              CMP      r1,#4
000006  6a11              LDR      r1,[r2,#0x20]
000008  d01e              BEQ      |L24.72|
00000a  f0210101          BIC      r1,r1,#1
00000e  6211              STR      r1,[r2,#0x20]
000010  6a11              LDR      r1,[r2,#0x20]
000012  f0410101          ORR      r1,r1,#1
000016  6211              STR      r1,[r2,#0x20]
000018  6801              LDR      r1,[r0,#0]
00001a  6a0a              LDR      r2,[r1,#0x20]
00001c  f0220210          BIC      r2,r2,#0x10
000020  620a              STR      r2,[r1,#0x20]
000022  6a0a              LDR      r2,[r1,#0x20]
000024  f0420210          ORR      r2,r2,#0x10
000028  620a              STR      r2,[r1,#0x20]
                  |L24.42|
;;;2648     {
;;;2649       case TIM_CHANNEL_1:
;;;2650       {
;;;2651         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2652         break; 
;;;2653       }
;;;2654       case TIM_CHANNEL_2:
;;;2655       { 
;;;2656         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
;;;2657         break;
;;;2658       }  
;;;2659       default :
;;;2660       {
;;;2661        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2662        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2663        break; 
;;;2664       }
;;;2665     }  
;;;2666     /* Enable the Peripheral */
;;;2667     __HAL_TIM_ENABLE(htim);
00002a  6800              LDR      r0,[r0,#0]
00002c  6801              LDR      r1,[r0,#0]
00002e  f0410101          ORR      r1,r1,#1
000032  6001              STR      r1,[r0,#0]
;;;2668     
;;;2669     /* Return function status */
;;;2670     return HAL_OK;
000034  2000              MOVS     r0,#0
;;;2671   }
000036  4770              BX       lr
                  |L24.56|
000038  6a11              LDR      r1,[r2,#0x20]
00003a  f0210101          BIC      r1,r1,#1
00003e  6211              STR      r1,[r2,#0x20]
000040  6a11              LDR      r1,[r2,#0x20]
000042  f0410101          ORR      r1,r1,#1
000046  e005              B        |L24.84|
                  |L24.72|
000048  f0210110          BIC      r1,r1,#0x10           ;2652
00004c  6211              STR      r1,[r2,#0x20]         ;2652
00004e  6a11              LDR      r1,[r2,#0x20]         ;2652
000050  f0410110          ORR      r1,r1,#0x10           ;2652
                  |L24.84|
000054  6211              STR      r1,[r2,#0x20]         ;2652
000056  e7e8              B        |L24.42|
;;;2672   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Start_DMA PROC
;;;2831     */
;;;2832   HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1, uint32_t *pData2, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2833   {
000004  4604              MOV      r4,r0
;;;2834     /* Check the parameters */
;;;2835     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2836     
;;;2837     if((htim->State == HAL_TIM_STATE_BUSY))
000006  6c00              LDR      r0,[r0,#0x40]
000008  461e              MOV      r6,r3                 ;2833
00000a  f8dd8018          LDR      r8,[sp,#0x18]
00000e  2802              CMP      r0,#2
;;;2838     {
;;;2839        return HAL_BUSY;
;;;2840     }
;;;2841     else if((htim->State == HAL_TIM_STATE_READY))
;;;2842     {
;;;2843       if((((pData1 == 0) || (pData2 == 0) )) && (Length > 0)) 
;;;2844       {
;;;2845         return HAL_ERROR;                                    
;;;2846       }
;;;2847       else
;;;2848       {
;;;2849         htim->State = HAL_TIM_STATE_BUSY;
;;;2850       }
;;;2851     }  
;;;2852      
;;;2853     switch (Channel)
;;;2854     {
;;;2855       case TIM_CHANNEL_1:
;;;2856       {
;;;2857         /* Set the DMA Period elapsed callback */
;;;2858         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;2859        
;;;2860         /* Set the DMA error callback */
;;;2861         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;2862         
;;;2863         /* Enable the DMA Stream */
;;;2864         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t )pData1, Length); 
;;;2865         
;;;2866         /* Enable the TIM Input Capture DMA request */      
;;;2867         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;2868               
;;;2869         /* Enable the Peripheral */
;;;2870         __HAL_TIM_ENABLE(htim);
;;;2871         
;;;2872         /* Enable the Capture compare channel */
;;;2873         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2874       }
;;;2875       break;
;;;2876       
;;;2877       case TIM_CHANNEL_2:
;;;2878       {
;;;2879         /* Set the DMA Period elapsed callback */
;;;2880         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;2881        
;;;2882         /* Set the DMA error callback */
;;;2883         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError;
;;;2884         /* Enable the DMA Stream */
;;;2885         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
;;;2886         
;;;2887         /* Enable the TIM Input Capture  DMA request */
;;;2888         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;2889        
;;;2890         /* Enable the Peripheral */
;;;2891         __HAL_TIM_ENABLE(htim);
;;;2892         
;;;2893         /* Enable the Capture compare channel */
;;;2894         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2895       }
;;;2896       break;
;;;2897       
;;;2898       case TIM_CHANNEL_ALL:
;;;2899       {
;;;2900         /* Set the DMA Period elapsed callback */
;;;2901         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;2902        
;;;2903         /* Set the DMA error callback */
;;;2904         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;2905         
;;;2906         /* Enable the DMA Stream */
;;;2907         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length);
;;;2908         
;;;2909         /* Set the DMA Period elapsed callback */
;;;2910         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;2911        
;;;2912         /* Set the DMA error callback */
;;;2913         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;2914         
;;;2915         /* Enable the DMA Stream */
;;;2916         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
;;;2917             
;;;2918        /* Enable the Peripheral */
;;;2919         __HAL_TIM_ENABLE(htim);
;;;2920         
;;;2921         /* Enable the Capture compare channel */
;;;2922         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2923         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2924         
;;;2925         /* Enable the TIM Input Capture  DMA request */
;;;2926         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;2927         /* Enable the TIM Input Capture  DMA request */
;;;2928         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;2929       }
;;;2930       break;
;;;2931       
;;;2932       default:
;;;2933       break;
;;;2934     }  
;;;2935     /* Return function status */
;;;2936     return HAL_OK;
;;;2937   }
000010  bf08              IT       EQ
000012  e8bd81f0          POPEQ    {r4-r8,pc}
000016  6c20              LDR      r0,[r4,#0x40]         ;2841
000018  2801              CMP      r0,#1                 ;2841
00001a  d10b              BNE      |L25.52|
00001c  2a00              CMP      r2,#0                 ;2843
00001e  bf18              IT       NE                    ;2843
000020  2e00              CMPNE    r6,#0                 ;2843
000022  d105              BNE      |L25.48|
000024  f1b80f00          CMP      r8,#0                 ;2843
000028  bf1c              ITT      NE                    ;2845
00002a  2001              MOVNE    r0,#1                 ;2845
00002c  e8bd81f0          POPNE    {r4-r8,pc}
                  |L25.48|
000030  2002              MOVS     r0,#2                 ;2849
000032  6420              STR      r0,[r4,#0x40]         ;2849
                  |L25.52|
000034  4d3e              LDR      r5,|L25.304|
000036  4f3f              LDR      r7,|L25.308|
000038  b121              CBZ      r1,|L25.68|
00003a  2904              CMP      r1,#4                 ;2853
00003c  d01f              BEQ      |L25.126|
00003e  293c              CMP      r1,#0x3c              ;2853
000040  d03c              BEQ      |L25.188|
000042  e071              B        |L25.296|
                  |L25.68|
000044  6a60              LDR      r0,[r4,#0x24]         ;2858
000046  4643              MOV      r3,r8                 ;2864
000048  6405              STR      r5,[r0,#0x40]         ;2861
00004a  6a60              LDR      r0,[r4,#0x24]         ;2861
00004c  6507              STR      r7,[r0,#0x50]         ;2864
00004e  6821              LDR      r1,[r4,#0]            ;2864
000050  6a60              LDR      r0,[r4,#0x24]         ;2864
000052  3134              ADDS     r1,r1,#0x34           ;2864
000054  f7fffffe          BL       HAL_DMA_Start_IT
000058  6820              LDR      r0,[r4,#0]            ;2867
00005a  68c1              LDR      r1,[r0,#0xc]          ;2867
00005c  f4417100          ORR      r1,r1,#0x200          ;2867
000060  60c1              STR      r1,[r0,#0xc]          ;2867
000062  6820              LDR      r0,[r4,#0]            ;2870
000064  6801              LDR      r1,[r0,#0]            ;2870
000066  f0410101          ORR      r1,r1,#1              ;2870
00006a  6001              STR      r1,[r0,#0]            ;2870
00006c  6820              LDR      r0,[r4,#0]            ;2870
00006e  6a01              LDR      r1,[r0,#0x20]         ;2870
000070  f0210101          BIC      r1,r1,#1              ;2870
000074  6201              STR      r1,[r0,#0x20]         ;2870
000076  6a01              LDR      r1,[r0,#0x20]         ;2870
000078  f0410101          ORR      r1,r1,#1              ;2870
00007c  e01c              B        |L25.184|
                  |L25.126|
00007e  6aa0              LDR      r0,[r4,#0x28]         ;2880
000080  4643              MOV      r3,r8                 ;2885
000082  4632              MOV      r2,r6                 ;2885
000084  6405              STR      r5,[r0,#0x40]         ;2883
000086  6aa0              LDR      r0,[r4,#0x28]         ;2883
000088  6507              STR      r7,[r0,#0x50]         ;2885
00008a  6821              LDR      r1,[r4,#0]            ;2885
00008c  6aa0              LDR      r0,[r4,#0x28]         ;2885
00008e  3138              ADDS     r1,r1,#0x38           ;2885
000090  f7fffffe          BL       HAL_DMA_Start_IT
000094  6820              LDR      r0,[r4,#0]            ;2888
000096  68c1              LDR      r1,[r0,#0xc]          ;2888
000098  f4416180          ORR      r1,r1,#0x400          ;2888
00009c  60c1              STR      r1,[r0,#0xc]          ;2888
00009e  6820              LDR      r0,[r4,#0]            ;2891
0000a0  6801              LDR      r1,[r0,#0]            ;2891
0000a2  f0410101          ORR      r1,r1,#1              ;2891
0000a6  6001              STR      r1,[r0,#0]            ;2891
0000a8  6820              LDR      r0,[r4,#0]            ;2891
0000aa  6a01              LDR      r1,[r0,#0x20]         ;2891
0000ac  f0210110          BIC      r1,r1,#0x10           ;2891
0000b0  6201              STR      r1,[r0,#0x20]         ;2891
0000b2  6a01              LDR      r1,[r0,#0x20]         ;2891
0000b4  f0410110          ORR      r1,r1,#0x10           ;2891
                  |L25.184|
0000b8  6201              STR      r1,[r0,#0x20]         ;2891
0000ba  e035              B        |L25.296|
                  |L25.188|
0000bc  6a60              LDR      r0,[r4,#0x24]         ;2901
0000be  4643              MOV      r3,r8                 ;2907
0000c0  6405              STR      r5,[r0,#0x40]         ;2904
0000c2  6a60              LDR      r0,[r4,#0x24]         ;2904
0000c4  6507              STR      r7,[r0,#0x50]         ;2907
0000c6  6821              LDR      r1,[r4,#0]            ;2907
0000c8  6a60              LDR      r0,[r4,#0x24]         ;2907
0000ca  3134              ADDS     r1,r1,#0x34           ;2907
0000cc  f7fffffe          BL       HAL_DMA_Start_IT
0000d0  6aa0              LDR      r0,[r4,#0x28]         ;2910
0000d2  4643              MOV      r3,r8                 ;2916
0000d4  4632              MOV      r2,r6                 ;2916
0000d6  6405              STR      r5,[r0,#0x40]         ;2913
0000d8  6aa0              LDR      r0,[r4,#0x28]         ;2913
0000da  6507              STR      r7,[r0,#0x50]         ;2916
0000dc  6821              LDR      r1,[r4,#0]            ;2916
0000de  6aa0              LDR      r0,[r4,#0x28]         ;2916
0000e0  3138              ADDS     r1,r1,#0x38           ;2916
0000e2  f7fffffe          BL       HAL_DMA_Start_IT
0000e6  6820              LDR      r0,[r4,#0]            ;2919
0000e8  6801              LDR      r1,[r0,#0]            ;2919
0000ea  f0410101          ORR      r1,r1,#1              ;2919
0000ee  6001              STR      r1,[r0,#0]            ;2919
0000f0  6820              LDR      r0,[r4,#0]            ;2919
0000f2  6a01              LDR      r1,[r0,#0x20]         ;2919
0000f4  f0210101          BIC      r1,r1,#1              ;2919
0000f8  6201              STR      r1,[r0,#0x20]         ;2919
0000fa  6a01              LDR      r1,[r0,#0x20]         ;2919
0000fc  f0410101          ORR      r1,r1,#1              ;2919
000100  6201              STR      r1,[r0,#0x20]         ;2919
000102  6820              LDR      r0,[r4,#0]            ;2919
000104  6a01              LDR      r1,[r0,#0x20]         ;2919
000106  f0210110          BIC      r1,r1,#0x10           ;2919
00010a  6201              STR      r1,[r0,#0x20]         ;2919
00010c  6a01              LDR      r1,[r0,#0x20]         ;2919
00010e  f0410110          ORR      r1,r1,#0x10           ;2919
000112  6201              STR      r1,[r0,#0x20]         ;2919
000114  6820              LDR      r0,[r4,#0]            ;2926
000116  68c1              LDR      r1,[r0,#0xc]          ;2926
000118  f4417100          ORR      r1,r1,#0x200          ;2926
00011c  60c1              STR      r1,[r0,#0xc]          ;2926
00011e  6820              LDR      r0,[r4,#0]            ;2928
000120  68c1              LDR      r1,[r0,#0xc]          ;2928
000122  f4416180          ORR      r1,r1,#0x400          ;2928
000126  60c1              STR      r1,[r0,#0xc]          ;2928
                  |L25.296|
000128  2000              MOVS     r0,#0                 ;2936
00012a  e8bd81f0          POP      {r4-r8,pc}
;;;2938   
                          ENDP

00012e  0000              DCW      0x0000
                  |L25.304|
                          DCD      TIM_DMACaptureCplt
                  |L25.308|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_Encoder_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Start_IT PROC
;;;2727     */
;;;2728   HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
;;;2729   {
000002  b319              CBZ      r1,|L26.76|
;;;2730     /* Check the parameters */
;;;2731     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2732     
;;;2733     /* Enable the encoder interface channels */
;;;2734     /* Enable the capture compare Interrupts 1 and/or 2 */
;;;2735     switch (Channel)
000004  2904              CMP      r1,#4
000006  6a11              LDR      r1,[r2,#0x20]
000008  d02d              BEQ      |L26.102|
00000a  f0210101          BIC      r1,r1,#1
00000e  6211              STR      r1,[r2,#0x20]
000010  6a11              LDR      r1,[r2,#0x20]
000012  f0410101          ORR      r1,r1,#1
000016  6211              STR      r1,[r2,#0x20]
000018  6801              LDR      r1,[r0,#0]
00001a  6a0a              LDR      r2,[r1,#0x20]
00001c  f0220210          BIC      r2,r2,#0x10
000020  620a              STR      r2,[r1,#0x20]
000022  6a0a              LDR      r2,[r1,#0x20]
000024  f0420210          ORR      r2,r2,#0x10
000028  620a              STR      r2,[r1,#0x20]
;;;2736     {
;;;2737       case TIM_CHANNEL_1:
;;;2738       {
;;;2739         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2740         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
;;;2741         break; 
;;;2742       }
;;;2743       case TIM_CHANNEL_2:
;;;2744       { 
;;;2745         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2746         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2); 
;;;2747         break;
;;;2748       }  
;;;2749       default :
;;;2750       {
;;;2751        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2752        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2753        __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
00002a  6801              LDR      r1,[r0,#0]
00002c  68ca              LDR      r2,[r1,#0xc]
00002e  f0420202          ORR      r2,r2,#2
000032  60ca              STR      r2,[r1,#0xc]
;;;2754        __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000034  6801              LDR      r1,[r0,#0]
000036  68ca              LDR      r2,[r1,#0xc]
000038  f0420204          ORR      r2,r2,#4
00003c  60ca              STR      r2,[r1,#0xc]
                  |L26.62|
;;;2755        break; 
;;;2756       }
;;;2757     }
;;;2758     
;;;2759     /* Enable the Peripheral */
;;;2760     __HAL_TIM_ENABLE(htim);
00003e  6800              LDR      r0,[r0,#0]
000040  6801              LDR      r1,[r0,#0]
000042  f0410101          ORR      r1,r1,#1
000046  6001              STR      r1,[r0,#0]
;;;2761     
;;;2762     /* Return function status */
;;;2763     return HAL_OK;
000048  2000              MOVS     r0,#0
;;;2764   }
00004a  4770              BX       lr
                  |L26.76|
00004c  6a11              LDR      r1,[r2,#0x20]
00004e  f0210101          BIC      r1,r1,#1
000052  6211              STR      r1,[r2,#0x20]
000054  6a11              LDR      r1,[r2,#0x20]
000056  f0410101          ORR      r1,r1,#1
00005a  6211              STR      r1,[r2,#0x20]
00005c  6801              LDR      r1,[r0,#0]            ;2740
00005e  68ca              LDR      r2,[r1,#0xc]          ;2740
000060  f0420202          ORR      r2,r2,#2              ;2740
000064  e00a              B        |L26.124|
                  |L26.102|
000066  f0210110          BIC      r1,r1,#0x10           ;2741
00006a  6211              STR      r1,[r2,#0x20]         ;2741
00006c  6a11              LDR      r1,[r2,#0x20]         ;2741
00006e  f0410110          ORR      r1,r1,#0x10           ;2741
000072  6211              STR      r1,[r2,#0x20]         ;2741
000074  6801              LDR      r1,[r0,#0]            ;2746
000076  68ca              LDR      r2,[r1,#0xc]          ;2746
000078  f0420204          ORR      r2,r2,#4              ;2746
                  |L26.124|
00007c  60ca              STR      r2,[r1,#0xc]          ;2740
00007e  e7de              B        |L26.62|
;;;2765   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Stop PROC
;;;2683     */
;;;2684   HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
;;;2685   {
000002  b1f9              CBZ      r1,|L27.68|
;;;2686     /* Check the parameters */
;;;2687       assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2688       
;;;2689      /* Disable the Input Capture channels 1 and 2
;;;2690       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
;;;2691     switch (Channel)
000004  2904              CMP      r1,#4
000006  6a11              LDR      r1,[r2,#0x20]
000008  d023              BEQ      |L27.82|
00000a  f0210101          BIC      r1,r1,#1
00000e  6211              STR      r1,[r2,#0x20]
000010  6a11              LDR      r1,[r2,#0x20]
000012  6211              STR      r1,[r2,#0x20]
000014  6801              LDR      r1,[r0,#0]
000016  6a0a              LDR      r2,[r1,#0x20]
000018  f0220210          BIC      r2,r2,#0x10
00001c  620a              STR      r2,[r1,#0x20]
00001e  6a0a              LDR      r2,[r1,#0x20]
000020  620a              STR      r2,[r1,#0x20]
                  |L27.34|
;;;2692     {
;;;2693       case TIM_CHANNEL_1:
;;;2694       {
;;;2695         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
;;;2696         break; 
;;;2697       }
;;;2698       case TIM_CHANNEL_2:
;;;2699       { 
;;;2700         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
;;;2701         break;
;;;2702       }  
;;;2703       default :
;;;2704       {
;;;2705        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
;;;2706        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
;;;2707        break; 
;;;2708       }
;;;2709     }  
;;;2710     /* Disable the Peripheral */
;;;2711     __HAL_TIM_DISABLE(htim);
000022  f2411111          MOV      r1,#0x1111
000026  6800              LDR      r0,[r0,#0]
000028  6a02              LDR      r2,[r0,#0x20]
00002a  420a              TST      r2,r1
00002c  d108              BNE      |L27.64|
00002e  6a01              LDR      r1,[r0,#0x20]
000030  f2404244          MOV      r2,#0x444
000034  4211              TST      r1,r2
000036  d103              BNE      |L27.64|
000038  6801              LDR      r1,[r0,#0]
00003a  f0210101          BIC      r1,r1,#1
00003e  6001              STR      r1,[r0,#0]
                  |L27.64|
;;;2712     
;;;2713     /* Return function status */
;;;2714     return HAL_OK;
000040  2000              MOVS     r0,#0
;;;2715   }
000042  4770              BX       lr
                  |L27.68|
000044  6a11              LDR      r1,[r2,#0x20]
000046  f0210101          BIC      r1,r1,#1
00004a  6211              STR      r1,[r2,#0x20]
00004c  6a11              LDR      r1,[r2,#0x20]
00004e  6211              STR      r1,[r2,#0x20]
000050  e7e7              B        |L27.34|
                  |L27.82|
000052  f0210110          BIC      r1,r1,#0x10           ;2696
000056  6211              STR      r1,[r2,#0x20]         ;2696
000058  6a11              LDR      r1,[r2,#0x20]         ;2696
00005a  6211              STR      r1,[r2,#0x20]         ;2696
00005c  e7e1              B        |L27.34|
;;;2716   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Stop_DMA PROC
;;;2949     */
;;;2950   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
000002  f04f0301          MOV      r3,#1
;;;2951   {
000006  b371              CBZ      r1,|L28.102|
;;;2952     /* Check the parameters */
;;;2953     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2954     
;;;2955     /* Disable the Input Capture channels 1 and 2
;;;2956       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
;;;2957     if(Channel == TIM_CHANNEL_1)
;;;2958     {
;;;2959       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
;;;2960       
;;;2961       /* Disable the capture compare DMA Request 1 */
;;;2962       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
;;;2963     }  
;;;2964     else if(Channel == TIM_CHANNEL_2)
000008  2904              CMP      r1,#4
00000a  6a11              LDR      r1,[r2,#0x20]
00000c  d037              BEQ      |L28.126|
00000e  f0210101          BIC      r1,r1,#1
000012  6211              STR      r1,[r2,#0x20]
000014  6a11              LDR      r1,[r2,#0x20]
000016  6211              STR      r1,[r2,#0x20]
000018  6801              LDR      r1,[r0,#0]
00001a  6a0a              LDR      r2,[r1,#0x20]
00001c  f0220210          BIC      r2,r2,#0x10
000020  620a              STR      r2,[r1,#0x20]
000022  6a0a              LDR      r2,[r1,#0x20]
000024  620a              STR      r2,[r1,#0x20]
;;;2965     {  
;;;2966       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
;;;2967       
;;;2968       /* Disable the capture compare DMA Request 2 */
;;;2969       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
;;;2970     }  
;;;2971     else
;;;2972     {
;;;2973       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
;;;2974       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
;;;2975       
;;;2976       /* Disable the capture compare DMA Request 1 and 2 */
;;;2977       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000026  6801              LDR      r1,[r0,#0]
000028  68ca              LDR      r2,[r1,#0xc]
00002a  f4227200          BIC      r2,r2,#0x200
00002e  60ca              STR      r2,[r1,#0xc]
;;;2978       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000030  6801              LDR      r1,[r0,#0]
000032  68ca              LDR      r2,[r1,#0xc]
000034  f4226280          BIC      r2,r2,#0x400
000038  f8c1200c          STR.W    r2,[r1,#0xc]
                  |L28.60|
;;;2979     }
;;;2980     
;;;2981     /* Disable the Peripheral */
;;;2982     __HAL_TIM_DISABLE(htim);
00003c  6801              LDR      r1,[r0,#0]
00003e  f2411211          MOV      r2,#0x1111
000042  f8d1c020          LDR      r12,[r1,#0x20]
000046  ea1c0f02          TST      r12,r2
00004a  d109              BNE      |L28.96|
00004c  6a0a              LDR      r2,[r1,#0x20]
00004e  f2404c44          MOV      r12,#0x444
000052  ea120f0c          TST      r2,r12
000056  d103              BNE      |L28.96|
000058  680a              LDR      r2,[r1,#0]
00005a  f0220201          BIC      r2,r2,#1
00005e  600a              STR      r2,[r1,#0]
                  |L28.96|
;;;2983     
;;;2984     /* Change the htim state */
;;;2985     htim->State = HAL_TIM_STATE_READY;
000060  6403              STR      r3,[r0,#0x40]
;;;2986     
;;;2987     /* Return function status */
;;;2988     return HAL_OK;
000062  2000              MOVS     r0,#0
;;;2989   }
000064  4770              BX       lr
                  |L28.102|
000066  e7ff              B        |L28.104|
                  |L28.104|
000068  6a11              LDR      r1,[r2,#0x20]
00006a  f0210101          BIC      r1,r1,#1
00006e  6211              STR      r1,[r2,#0x20]
000070  6a11              LDR      r1,[r2,#0x20]
000072  6211              STR      r1,[r2,#0x20]
000074  6801              LDR      r1,[r0,#0]            ;2962
000076  68ca              LDR      r2,[r1,#0xc]          ;2962
000078  f4227200          BIC      r2,r2,#0x200          ;2962
00007c  e008              B        |L28.144|
                  |L28.126|
00007e  f0210110          BIC      r1,r1,#0x10           ;2962
000082  6211              STR      r1,[r2,#0x20]         ;2962
000084  6a11              LDR      r1,[r2,#0x20]         ;2962
000086  6211              STR      r1,[r2,#0x20]         ;2962
000088  6801              LDR      r1,[r0,#0]            ;2969
00008a  68ca              LDR      r2,[r1,#0xc]          ;2969
00008c  f4226280          BIC      r2,r2,#0x400          ;2969
                  |L28.144|
000090  60ca              STR      r2,[r1,#0xc]          ;2969
000092  e7d3              B        |L28.60|
;;;2990   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Stop_IT PROC
;;;2776     */
;;;2777   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
000002  f04f0301          MOV      r3,#1
;;;2778   {
000006  b371              CBZ      r1,|L29.102|
;;;2779     /* Check the parameters */
;;;2780     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2781       
;;;2782     /* Disable the Input Capture channels 1 and 2
;;;2783       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
;;;2784     if(Channel == TIM_CHANNEL_1)
;;;2785     {
;;;2786       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
;;;2787       
;;;2788       /* Disable the capture compare Interrupts 1 */
;;;2789     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
;;;2790     }  
;;;2791     else if(Channel == TIM_CHANNEL_2)
000008  2904              CMP      r1,#4
00000a  6a11              LDR      r1,[r2,#0x20]
00000c  d037              BEQ      |L29.126|
00000e  f0210101          BIC      r1,r1,#1
000012  6211              STR      r1,[r2,#0x20]
000014  6a11              LDR      r1,[r2,#0x20]
000016  6211              STR      r1,[r2,#0x20]
000018  6801              LDR      r1,[r0,#0]
00001a  6a0a              LDR      r2,[r1,#0x20]
00001c  f0220210          BIC      r2,r2,#0x10
000020  620a              STR      r2,[r1,#0x20]
000022  6a0a              LDR      r2,[r1,#0x20]
000024  620a              STR      r2,[r1,#0x20]
;;;2792     {  
;;;2793       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
;;;2794       
;;;2795       /* Disable the capture compare Interrupts 2 */
;;;2796     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
;;;2797     }  
;;;2798     else
;;;2799     {
;;;2800       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
;;;2801       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
;;;2802       
;;;2803       /* Disable the capture compare Interrupts 1 and 2 */
;;;2804       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000026  6801              LDR      r1,[r0,#0]
000028  68ca              LDR      r2,[r1,#0xc]
00002a  f0220202          BIC      r2,r2,#2
00002e  60ca              STR      r2,[r1,#0xc]
;;;2805       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000030  6801              LDR      r1,[r0,#0]
000032  68ca              LDR      r2,[r1,#0xc]
000034  f0220204          BIC      r2,r2,#4
000038  f8c1200c          STR.W    r2,[r1,#0xc]
                  |L29.60|
;;;2806     }
;;;2807       
;;;2808     /* Disable the Peripheral */
;;;2809     __HAL_TIM_DISABLE(htim);
00003c  6801              LDR      r1,[r0,#0]
00003e  f2411211          MOV      r2,#0x1111
000042  f8d1c020          LDR      r12,[r1,#0x20]
000046  ea1c0f02          TST      r12,r2
00004a  d109              BNE      |L29.96|
00004c  6a0a              LDR      r2,[r1,#0x20]
00004e  f2404c44          MOV      r12,#0x444
000052  ea120f0c          TST      r2,r12
000056  d103              BNE      |L29.96|
000058  680a              LDR      r2,[r1,#0]
00005a  f0220201          BIC      r2,r2,#1
00005e  600a              STR      r2,[r1,#0]
                  |L29.96|
;;;2810     
;;;2811     /* Change the htim state */
;;;2812     htim->State = HAL_TIM_STATE_READY;
000060  6403              STR      r3,[r0,#0x40]
;;;2813     
;;;2814     /* Return function status */
;;;2815     return HAL_OK;
000062  2000              MOVS     r0,#0
;;;2816   }
000064  4770              BX       lr
                  |L29.102|
000066  e7ff              B        |L29.104|
                  |L29.104|
000068  6a11              LDR      r1,[r2,#0x20]
00006a  f0210101          BIC      r1,r1,#1
00006e  6211              STR      r1,[r2,#0x20]
000070  6a11              LDR      r1,[r2,#0x20]
000072  6211              STR      r1,[r2,#0x20]
000074  6801              LDR      r1,[r0,#0]            ;2789
000076  68ca              LDR      r2,[r1,#0xc]          ;2789
000078  f0220202          BIC      r2,r2,#2              ;2789
00007c  e008              B        |L29.144|
                  |L29.126|
00007e  f0210110          BIC      r1,r1,#0x10           ;2789
000082  6211              STR      r1,[r2,#0x20]         ;2789
000084  6a11              LDR      r1,[r2,#0x20]         ;2789
000086  6211              STR      r1,[r2,#0x20]         ;2789
000088  6801              LDR      r1,[r0,#0]            ;2796
00008a  68ca              LDR      r2,[r1,#0xc]          ;2796
00008c  f0220204          BIC      r2,r2,#4              ;2796
                  |L29.144|
000090  60ca              STR      r2,[r1,#0xc]          ;2796
000092  e7d3              B        |L29.60|
;;;2817   
                          ENDP


                          AREA ||i.HAL_TIM_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ErrorCallback PROC
;;;4767     */
;;;4768   __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4769   {
;;;4770     /* Prevent unused argument(s) compilation warning */
;;;4771     UNUSED(htim);
;;;4772    
;;;4773     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4774               the HAL_TIM_ErrorCallback could be implemented in the user file
;;;4775      */
;;;4776   }
;;;4777   
                          ENDP


                          AREA ||i.HAL_TIM_GenerateEvent||, CODE, READONLY, ALIGN=1

                  HAL_TIM_GenerateEvent PROC
;;;4081   
;;;4082   HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
000000  6bc2              LDR      r2,[r0,#0x3c]
;;;4083   {
;;;4084     /* Check the parameters */
;;;4085     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;4086     assert_param(IS_TIM_EVENT_SOURCE(EventSource));
;;;4087     
;;;4088     /* Process Locked */
;;;4089     __HAL_LOCK(htim);
000002  2a01              CMP      r2,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;4090     
;;;4091     /* Change the TIM state */
;;;4092     htim->State = HAL_TIM_STATE_BUSY;
;;;4093     
;;;4094     /* Set the event sources */
;;;4095     htim->Instance->EGR = EventSource;
;;;4096     
;;;4097     /* Change the TIM state */
;;;4098     htim->State = HAL_TIM_STATE_READY;
;;;4099     
;;;4100     __HAL_UNLOCK(htim);
;;;4101     
;;;4102     /* Return function status */
;;;4103     return HAL_OK;  
;;;4104   }
000008  4770              BXEQ     lr
00000a  2201              MOVS     r2,#1                 ;4089
00000c  2302              MOVS     r3,#2                 ;4092
00000e  6403              STR      r3,[r0,#0x40]         ;4092
000010  f8d0c000          LDR      r12,[r0,#0]           ;4095
000014  2300              MOVS     r3,#0                 ;4100
000016  f8cc1014          STR      r1,[r12,#0x14]        ;4095
00001a  6402              STR      r2,[r0,#0x40]         ;4098
00001c  63c3              STR      r3,[r0,#0x3c]         ;4103
00001e  4618              MOV      r0,r3                 ;4103
000020  4770              BX       lr
;;;4105   
                          ENDP


                          AREA ||i.HAL_TIM_IC_CaptureCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_CaptureCallback PROC
;;;4719     */
;;;4720   __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4721   {
;;;4722     /* Prevent unused argument(s) compilation warning */
;;;4723     UNUSED(htim);
;;;4724    
;;;4725     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4726               the __HAL_TIM_IC_CaptureCallback could be implemented in the user file
;;;4727      */
;;;4728   }
;;;4729   
                          ENDP


                          AREA ||i.HAL_TIM_IC_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_ConfigChannel PROC
;;;3314     */
;;;3315   HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef* sConfig, uint32_t Channel)
000000  6bc3              LDR      r3,[r0,#0x3c]
;;;3316   {
;;;3317     /* Check the parameters */
;;;3318     assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3319     assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
;;;3320     assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
;;;3321     assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
;;;3322     assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
;;;3323     
;;;3324     __HAL_LOCK(htim);
000002  2b01              CMP      r3,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;3325     
;;;3326     htim->State = HAL_TIM_STATE_BUSY;
;;;3327     
;;;3328     if (Channel == TIM_CHANNEL_1)
;;;3329     {
;;;3330       /* TI1 Configuration */
;;;3331       TIM_TI1_SetConfig(htim->Instance,
;;;3332                  sConfig->ICPolarity,
;;;3333                  sConfig->ICSelection,
;;;3334                  sConfig->ICFilter);
;;;3335                  
;;;3336       /* Reset the IC1PSC Bits */
;;;3337       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;3338   
;;;3339       /* Set the IC1PSC value */
;;;3340       htim->Instance->CCMR1 |= sConfig->ICPrescaler;
;;;3341     }
;;;3342     else if (Channel == TIM_CHANNEL_2)
;;;3343     {
;;;3344       /* TI2 Configuration */
;;;3345       assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3346       
;;;3347       TIM_TI2_SetConfig(htim->Instance, 
;;;3348                         sConfig->ICPolarity,
;;;3349                         sConfig->ICSelection,
;;;3350                         sConfig->ICFilter);
;;;3351                  
;;;3352       /* Reset the IC2PSC Bits */
;;;3353       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;3354   
;;;3355       /* Set the IC2PSC value */
;;;3356       htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8);
;;;3357     }
;;;3358     else if (Channel == TIM_CHANNEL_3)
;;;3359     {
;;;3360       /* TI3 Configuration */
;;;3361       assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3362       
;;;3363       TIM_TI3_SetConfig(htim->Instance,  
;;;3364                  sConfig->ICPolarity,
;;;3365                  sConfig->ICSelection,
;;;3366                  sConfig->ICFilter);
;;;3367                  
;;;3368       /* Reset the IC3PSC Bits */
;;;3369       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
;;;3370   
;;;3371       /* Set the IC3PSC value */
;;;3372       htim->Instance->CCMR2 |= sConfig->ICPrescaler;
;;;3373     }
;;;3374     else
;;;3375     {
;;;3376       /* TI4 Configuration */
;;;3377       assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3378       
;;;3379       TIM_TI4_SetConfig(htim->Instance, 
;;;3380                  sConfig->ICPolarity,
;;;3381                  sConfig->ICSelection,
;;;3382                  sConfig->ICFilter);
;;;3383                  
;;;3384       /* Reset the IC4PSC Bits */
;;;3385       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
;;;3386   
;;;3387       /* Set the IC4PSC value */
;;;3388       htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8);
;;;3389     }
;;;3390     
;;;3391     htim->State = HAL_TIM_STATE_READY;
;;;3392       
;;;3393     __HAL_UNLOCK(htim);
;;;3394     
;;;3395     return HAL_OK; 
;;;3396   }
000008  4770              BXEQ     lr
00000a  e92d03f0          PUSH     {r4-r9}               ;3316
00000e  2302              MOVS     r3,#2                 ;3326
000010  f04f0c01          MOV      r12,#1                ;3324
000014  f8c0c03c          STR      r12,[r0,#0x3c]        ;3326
000018  2a00              CMP      r2,#0                 ;3328
00001a  6403              STR      r3,[r0,#0x40]         ;3326
00001c  f04f04f0          MOV      r4,#0xf0              ;3326
000020  d036              BEQ      |L33.144|
000022  2a04              CMP      r2,#4                 ;3342
000024  f44f4370          MOV      r3,#0xf000            ;3342
000028  d07e              BEQ      |L33.296|
00002a  68ce              LDR      r6,[r1,#0xc]          ;3358
00002c  2a08              CMP      r2,#8                 ;3358
00002e  6802              LDR      r2,[r0,#0]            ;3379
000030  d07b              BEQ      |L33.298|
000032  e9d15400          LDRD     r5,r4,[r1,#0]         ;3358
000036  6a17              LDR      r7,[r2,#0x20]         ;3358
000038  f44f4820          MOV      r8,#0xa000            ;3358
00003c  f4275980          BIC      r9,r7,#0x1000         ;3358
000040  f8c29020          STR      r9,[r2,#0x20]         ;3358
000044  ea033706          AND      r7,r3,r6,LSL #12      ;3358
000048  69d6              LDR      r6,[r2,#0x1c]         ;3358
00004a  6a13              LDR      r3,[r2,#0x20]         ;3358
00004c  ea083805          AND      r8,r8,r5,LSL #12      ;3358
000050  f4267540          BIC      r5,r6,#0x300          ;3358
000054  ea452404          ORR      r4,r5,r4,LSL #8       ;3358
000058  f4234320          BIC      r3,r3,#0xa000         ;3358
00005c  f4244470          BIC      r4,r4,#0xf000         ;3358
000060  433c              ORRS     r4,r4,r7              ;3358
000062  61d4              STR      r4,[r2,#0x1c]         ;3358
000064  ea480303          ORR      r3,r8,r3              ;3358
000068  6213              STR      r3,[r2,#0x20]         ;3358
00006a  6802              LDR      r2,[r0,#0]            ;3385
00006c  69d3              LDR      r3,[r2,#0x1c]         ;3385
00006e  f4236340          BIC      r3,r3,#0xc00          ;3385
000072  61d3              STR      r3,[r2,#0x1c]         ;3385
000074  6802              LDR      r2,[r0,#0]            ;3388
000076  6889              LDR      r1,[r1,#8]            ;3388
000078  69d3              LDR      r3,[r2,#0x1c]         ;3388
00007a  ea432101          ORR      r1,r3,r1,LSL #8       ;3388
                  |L33.126|
00007e  61d1              STR      r1,[r2,#0x1c]         ;3372
                  |L33.128|
000080  2100              MOVS     r1,#0                 ;3393
000082  f8c0c040          STR      r12,[r0,#0x40]        ;3391
000086  63c1              STR      r1,[r0,#0x3c]         ;3395
000088  4608              MOV      r0,r1                 ;3395
00008a  e8bd03f0          POP      {r4-r9}
00008e  4770              BX       lr
                  |L33.144|
000090  6802              LDR      r2,[r0,#0]            ;3331
000092  e9d16800          LDRD     r6,r8,[r1,#0]         ;3331
000096  68cd              LDR      r5,[r1,#0xc]          ;3331
000098  6a13              LDR      r3,[r2,#0x20]         ;3331
00009a  f1a24780          SUB      r7,r2,#0x40000000     ;3331
00009e  f5b73780          SUBS     r7,r7,#0x10000        ;3331
0000a2  f0230301          BIC      r3,r3,#1              ;3331
0000a6  6213              STR      r3,[r2,#0x20]         ;3331
0000a8  6993              LDR      r3,[r2,#0x18]         ;3331
0000aa  6a17              LDR      r7,[r2,#0x20]         ;3331
0000ac  bf18              IT       NE                    ;3331
0000ae  f1b24f80          CMPNE    r2,#0x40000000        ;3331
0000b2  d01f              BEQ      |L33.244|
0000b4  f1a24980          SUB      r9,r2,#0x40000000     ;3331
0000b8  f5b96980          SUBS     r9,r9,#0x400          ;3331
0000bc  bf1c              ITT      NE                    ;3331
0000be  f1a24980          SUBNE    r9,r2,#0x40000000     ;3331
0000c2  f5b96900          SUBSNE   r9,r9,#0x800          ;3331
0000c6  d015              BEQ      |L33.244|
0000c8  f1a24980          SUB      r9,r2,#0x40000000     ;3331
0000cc  f5b96940          SUBS     r9,r9,#0xc00          ;3331
0000d0  bf1c              ITT      NE                    ;3331
0000d2  f1a24980          SUBNE    r9,r2,#0x40000000     ;3331
0000d6  f5b93982          SUBSNE   r9,r9,#0x10400        ;3331
0000da  d00b              BEQ      |L33.244|
0000dc  f1a24980          SUB      r9,r2,#0x40000000     ;3331
0000e0  f5b939a0          SUBS     r9,r9,#0x14000        ;3331
0000e4  bf1e              ITTT     NE                    ;3331
0000e6  f1a24980          SUBNE    r9,r2,#0x40000000     ;3331
0000ea  f5b959c0          SUBSNE   r9,r9,#0x1800         ;3331
0000ee  f0430301          ORRNE    r3,r3,#1              ;3331
0000f2  d103              BNE      |L33.252|
                  |L33.244|
0000f4  f0230303          BIC      r3,r3,#3              ;3331
0000f8  ea430308          ORR      r3,r3,r8              ;3331
                  |L33.252|
0000fc  ea041505          AND      r5,r4,r5,LSL #4       ;3331
000100  f02303f0          BIC      r3,r3,#0xf0           ;3331
000104  432b              ORRS     r3,r3,r5              ;3331
000106  6193              STR      r3,[r2,#0x18]         ;3331
000108  f027040a          BIC      r4,r7,#0xa            ;3331
00010c  f006060a          AND      r6,r6,#0xa            ;3331
000110  4334              ORRS     r4,r4,r6              ;3331
000112  6214              STR      r4,[r2,#0x20]         ;3331
000114  6802              LDR      r2,[r0,#0]            ;3337
000116  6993              LDR      r3,[r2,#0x18]         ;3337
000118  f023030c          BIC      r3,r3,#0xc            ;3337
00011c  6193              STR      r3,[r2,#0x18]         ;3337
00011e  6802              LDR      r2,[r0,#0]            ;3340
000120  6889              LDR      r1,[r1,#8]            ;3340
000122  6993              LDR      r3,[r2,#0x18]         ;3340
000124  4319              ORRS     r1,r1,r3              ;3340
000126  e029              B        |L33.380|
                  |L33.296|
000128  e000              B        |L33.300|
                  |L33.298|
00012a  e029              B        |L33.384|
                  |L33.300|
00012c  6802              LDR      r2,[r0,#0]            ;3347
00012e  e9d15400          LDRD     r5,r4,[r1,#0]         ;3347
000132  68ce              LDR      r6,[r1,#0xc]          ;3347
000134  6a17              LDR      r7,[r2,#0x20]         ;3347
000136  f04f08a0          MOV      r8,#0xa0              ;3347
00013a  f0270910          BIC      r9,r7,#0x10           ;3347
00013e  f8c29020          STR      r9,[r2,#0x20]         ;3347
000142  ea033706          AND      r7,r3,r6,LSL #12      ;3347
000146  6993              LDR      r3,[r2,#0x18]         ;3347
000148  6a16              LDR      r6,[r2,#0x20]         ;3347
00014a  ea081805          AND      r8,r8,r5,LSL #4       ;3347
00014e  f4237540          BIC      r5,r3,#0x300          ;3347
000152  ea452404          ORR      r4,r5,r4,LSL #8       ;3347
000156  f02603a0          BIC      r3,r6,#0xa0           ;3347
00015a  f4244470          BIC      r4,r4,#0xf000         ;3347
00015e  433c              ORRS     r4,r4,r7              ;3347
000160  6194              STR      r4,[r2,#0x18]         ;3347
000162  ea480303          ORR      r3,r8,r3              ;3347
000166  6213              STR      r3,[r2,#0x20]         ;3347
000168  6802              LDR      r2,[r0,#0]            ;3353
00016a  6993              LDR      r3,[r2,#0x18]         ;3353
00016c  f4236340          BIC      r3,r3,#0xc00          ;3353
000170  6193              STR      r3,[r2,#0x18]         ;3353
000172  6802              LDR      r2,[r0,#0]            ;3356
000174  6889              LDR      r1,[r1,#8]            ;3356
000176  6993              LDR      r3,[r2,#0x18]         ;3356
000178  ea432101          ORR      r1,r3,r1,LSL #8       ;3356
                  |L33.380|
00017c  6191              STR      r1,[r2,#0x18]         ;3356
00017e  e77f              B        |L33.128|
                  |L33.384|
000180  e9d15300          LDRD     r5,r3,[r1,#0]         ;3356
000184  6a17              LDR      r7,[r2,#0x20]         ;3356
000186  f44f6820          MOV      r8,#0xa00             ;3356
00018a  f4277980          BIC      r9,r7,#0x100          ;3356
00018e  f8c29020          STR      r9,[r2,#0x20]         ;3356
000192  ea041706          AND      r7,r4,r6,LSL #4       ;3356
000196  69d4              LDR      r4,[r2,#0x1c]         ;3356
000198  6a16              LDR      r6,[r2,#0x20]         ;3356
00019a  ea082805          AND      r8,r8,r5,LSL #8       ;3356
00019e  f0240403          BIC      r4,r4,#3              ;3356
0001a2  4323              ORRS     r3,r3,r4              ;3356
0001a4  f4266520          BIC      r5,r6,#0xa00          ;3356
0001a8  f02303f0          BIC      r3,r3,#0xf0           ;3356
0001ac  433b              ORRS     r3,r3,r7              ;3356
0001ae  61d3              STR      r3,[r2,#0x1c]         ;3356
0001b0  ea480405          ORR      r4,r8,r5              ;3356
0001b4  6214              STR      r4,[r2,#0x20]         ;3356
0001b6  6802              LDR      r2,[r0,#0]            ;3369
0001b8  69d3              LDR      r3,[r2,#0x1c]         ;3369
0001ba  f023030c          BIC      r3,r3,#0xc            ;3369
0001be  61d3              STR      r3,[r2,#0x1c]         ;3369
0001c0  6802              LDR      r2,[r0,#0]            ;3372
0001c2  6889              LDR      r1,[r1,#8]            ;3372
0001c4  69d3              LDR      r3,[r2,#0x1c]         ;3372
0001c6  4319              ORRS     r1,r1,r3              ;3372
0001c8  e759              B        |L33.126|
;;;3397   
                          ENDP


                          AREA ||i.HAL_TIM_IC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_DeInit PROC
;;;1693     */
;;;1694   HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1695   {
000002  4604              MOV      r4,r0
;;;1696     /* Check the parameters */
;;;1697     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1698   
;;;1699     htim->State = HAL_TIM_STATE_BUSY;
;;;1700     
;;;1701     /* Disable the TIM Peripheral Clock */
;;;1702     __HAL_TIM_DISABLE(htim);
000004  f2411111          MOV      r1,#0x1111
000008  2002              MOVS     r0,#2                 ;1699
00000a  6420              STR      r0,[r4,#0x40]         ;1699
00000c  6820              LDR      r0,[r4,#0]
00000e  6a02              LDR      r2,[r0,#0x20]
000010  420a              TST      r2,r1
000012  d108              BNE      |L34.38|
000014  6a01              LDR      r1,[r0,#0x20]
000016  f2404244          MOV      r2,#0x444
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L34.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L34.38|
;;;1703   
;;;1704   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;1705     if(htim->IC_MspDeInitCallback == NULL)
;;;1706     {
;;;1707       htim->IC_MspDeInitCallback = HAL_TIM_IC_MspDeInit;
;;;1708     }
;;;1709     /* DeInit the low level hardware */
;;;1710     htim->IC_MspDeInitCallback(htim);
;;;1711   #else
;;;1712     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;1713     HAL_TIM_IC_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_IC_MspDeInit
;;;1714   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;1715   
;;;1716     /* Change TIM state */  
;;;1717     htim->State = HAL_TIM_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  6420              STR      r0,[r4,#0x40]
;;;1718   
;;;1719     /* Release Lock */
;;;1720     __HAL_UNLOCK(htim);
000030  63e0              STR      r0,[r4,#0x3c]
;;;1721   
;;;1722     return HAL_OK;
;;;1723   }
000032  bd10              POP      {r4,pc}
;;;1724   
                          ENDP


                          AREA ||i.HAL_TIM_IC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_GetState PROC
;;;5267     */
;;;5268   HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
000000  6c00              LDR      r0,[r0,#0x40]
;;;5269   {
;;;5270     return htim->State;
;;;5271   }
000002  4770              BX       lr
;;;5272   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Init PROC
;;;1640     */
;;;1641   HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
000000  2800              CMP      r0,#0
;;;1642   {
;;;1643     /* Check the TIM handle allocation */
;;;1644     if(htim == NULL)
;;;1645     {
;;;1646       return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;1647     }
;;;1648   
;;;1649     /* Check the parameters */
;;;1650     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1651     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1652     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision)); 
;;;1653     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;1654   
;;;1655     if(htim->State == HAL_TIM_STATE_RESET)
;;;1656     {
;;;1657       /* Allocate lock resource and initialize it */
;;;1658       htim->Lock = HAL_UNLOCKED;
;;;1659   
;;;1660   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;1661       /* Reset interrupt callbacks to legacy week callbacks */
;;;1662       TIM_ResetCallback(htim);
;;;1663   
;;;1664       if(htim->IC_MspInitCallback == NULL)
;;;1665       {
;;;1666         htim->IC_MspInitCallback = HAL_TIM_IC_MspInit;
;;;1667       }
;;;1668       /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;1669       htim->IC_MspInitCallback(htim);
;;;1670   #else
;;;1671       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1672       HAL_TIM_IC_MspInit(htim);
;;;1673   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;1674     }
;;;1675   
;;;1676     /* Set the TIM state */
;;;1677     htim->State= HAL_TIM_STATE_BUSY;   
;;;1678     
;;;1679     /* Init the base time for the input capture */  
;;;1680     TIM_Base_SetConfig(htim->Instance, &htim->Init); 
;;;1681      
;;;1682     /* Initialize the TIM state*/
;;;1683     htim->State= HAL_TIM_STATE_READY;
;;;1684     
;;;1685     return HAL_OK;
;;;1686   }
000006  4770              BXEQ     lr
000008  b510              PUSH     {r4,lr}               ;1642
00000a  4604              MOV      r4,r0                 ;1642
00000c  6c00              LDR      r0,[r0,#0x40]         ;1655
00000e  b920              CBNZ     r0,|L36.26|
000010  2000              MOVS     r0,#0                 ;1658
000012  63e0              STR      r0,[r4,#0x3c]         ;1672
000014  4620              MOV      r0,r4                 ;1672
000016  f7fffffe          BL       HAL_TIM_IC_MspInit
                  |L36.26|
00001a  2002              MOVS     r0,#2                 ;1677
00001c  6420              STR      r0,[r4,#0x40]         ;1677
00001e  6820              LDR      r0,[r4,#0]            ;1680
000020  1d21              ADDS     r1,r4,#4              ;1680
000022  f7fffffe          BL       TIM_Base_SetConfig
000026  2001              MOVS     r0,#1                 ;1683
000028  6420              STR      r0,[r4,#0x40]         ;1683
00002a  2000              MOVS     r0,#0                 ;1685
00002c  bd10              POP      {r4,pc}
;;;1687   
                          ENDP


                          AREA ||i.HAL_TIM_IC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_MspDeInit PROC
;;;1746     */
;;;1747   __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1748   {
;;;1749     /* Prevent unused argument(s) compilation warning */
;;;1750     UNUSED(htim);
;;;1751      
;;;1752     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1753               the HAL_TIM_IC_MspDeInit could be implemented in the user file
;;;1754      */
;;;1755   }
;;;1756   
                          ENDP


                          AREA ||i.HAL_TIM_IC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_MspInit PROC
;;;1730     */
;;;1731   __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1732   {
;;;1733     /* Prevent unused argument(s) compilation warning */
;;;1734     UNUSED(htim);
;;;1735    
;;;1736     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1737               the HAL_TIM_IC_MspInit could be implemented in the user file
;;;1738      */
;;;1739   }
;;;1740   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Start PROC
;;;1768     */
;;;1769   HAL_StatusTypeDef HAL_TIM_IC_Start (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
000002  2301              MOVS     r3,#1
000004  fa03f101          LSL      r1,r3,r1
000008  6a13              LDR      r3,[r2,#0x20]
00000a  438b              BICS     r3,r3,r1
00000c  6213              STR      r3,[r2,#0x20]
00000e  6a13              LDR      r3,[r2,#0x20]
000010  4319              ORRS     r1,r1,r3
000012  6211              STR      r1,[r2,#0x20]
;;;1770   {
;;;1771     /* Check the parameters */
;;;1772     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1773     
;;;1774     /* Enable the Input Capture channel */
;;;1775     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1776       
;;;1777     /* Enable the Peripheral */
;;;1778     __HAL_TIM_ENABLE(htim);  
000014  6800              LDR      r0,[r0,#0]
000016  6801              LDR      r1,[r0,#0]
000018  f0410101          ORR      r1,r1,#1
00001c  6001              STR      r1,[r0,#0]
;;;1779   
;;;1780     /* Return function status */
;;;1781     return HAL_OK;  
00001e  2000              MOVS     r0,#0
;;;1782   } 
000020  4770              BX       lr
;;;1783   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_IC_Start_DMA PROC
;;;1945     */
;;;1946   HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;1947   {
000002  4604              MOV      r4,r0
;;;1948     /* Check the parameters */
;;;1949     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1950     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;1951     
;;;1952     if((htim->State == HAL_TIM_STATE_BUSY))
000004  6c00              LDR      r0,[r0,#0x40]
000006  460d              MOV      r5,r1                 ;1947
000008  2802              CMP      r0,#2
;;;1953     {
;;;1954        return HAL_BUSY;
;;;1955     }
;;;1956     else if((htim->State == HAL_TIM_STATE_READY))
;;;1957     {
;;;1958       if((pData == 0 ) && (Length > 0)) 
;;;1959       {
;;;1960         return HAL_ERROR;                                    
;;;1961       }
;;;1962       else
;;;1963       {
;;;1964         htim->State = HAL_TIM_STATE_BUSY;
;;;1965       }
;;;1966     }  
;;;1967      
;;;1968     switch (Channel)
;;;1969     {
;;;1970       case TIM_CHANNEL_1:
;;;1971       {
;;;1972         /* Set the DMA Period elapsed callback */
;;;1973         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;1974        
;;;1975         /* Set the DMA error callback */
;;;1976         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1977         
;;;1978         /* Enable the DMA Stream */
;;;1979         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length); 
;;;1980         
;;;1981         /* Enable the TIM Capture/Compare 1 DMA request */      
;;;1982         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1983       }
;;;1984       break;
;;;1985       
;;;1986       case TIM_CHANNEL_2:
;;;1987       {
;;;1988         /* Set the DMA Period elapsed callback */
;;;1989         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;1990        
;;;1991         /* Set the DMA error callback */
;;;1992         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1993         
;;;1994         /* Enable the DMA Stream */
;;;1995         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length);
;;;1996         
;;;1997         /* Enable the TIM Capture/Compare 2  DMA request */
;;;1998         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1999       }
;;;2000       break;
;;;2001       
;;;2002       case TIM_CHANNEL_3:
;;;2003       {
;;;2004         /* Set the DMA Period elapsed callback */
;;;2005         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;2006        
;;;2007         /* Set the DMA error callback */
;;;2008         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
;;;2009         
;;;2010         /* Enable the DMA Stream */
;;;2011         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length);
;;;2012         
;;;2013         /* Enable the TIM Capture/Compare 3  DMA request */
;;;2014         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;2015       }
;;;2016       break;
;;;2017       
;;;2018       case TIM_CHANNEL_4:
;;;2019       {
;;;2020         /* Set the DMA Period elapsed callback */
;;;2021         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;2022        
;;;2023         /* Set the DMA error callback */
;;;2024         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
;;;2025         
;;;2026         /* Enable the DMA Stream */
;;;2027         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length);
;;;2028         
;;;2029         /* Enable the TIM Capture/Compare 4  DMA request */
;;;2030         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;2031       }
;;;2032       break;
;;;2033       
;;;2034       default:
;;;2035       break;
;;;2036     }
;;;2037   
;;;2038     /* Enable the Input Capture channel */
;;;2039     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;2040      
;;;2041     /* Enable the Peripheral */
;;;2042     __HAL_TIM_ENABLE(htim); 
;;;2043     
;;;2044     /* Return function status */
;;;2045     return HAL_OK;
;;;2046   }
00000a  bf08              IT       EQ
00000c  bd70              POPEQ    {r4-r6,pc}
00000e  6c20              LDR      r0,[r4,#0x40]         ;1956
000010  2801              CMP      r0,#1                 ;1956
000012  d106              BNE      |L40.34|
000014  b91a              CBNZ     r2,|L40.30|
000016  2b00              CMP      r3,#0                 ;1958
000018  bf1c              ITT      NE                    ;1960
00001a  2001              MOVNE    r0,#1                 ;1960
00001c  bd70              POPNE    {r4-r6,pc}
                  |L40.30|
00001e  2002              MOVS     r0,#2                 ;1964
000020  6420              STR      r0,[r4,#0x40]         ;1964
                  |L40.34|
000022  482d              LDR      r0,|L40.216|
000024  492d              LDR      r1,|L40.220|
000026  b135              CBZ      r5,|L40.54|
000028  2d04              CMP      r5,#4                 ;1968
00002a  d014              BEQ      |L40.86|
00002c  2d08              CMP      r5,#8                 ;1968
00002e  d022              BEQ      |L40.118|
000030  2d0c              CMP      r5,#0xc               ;1968
000032  d030              BEQ      |L40.150|
000034  e03f              B        |L40.182|
                  |L40.54|
000036  f8d4c024          LDR      r12,[r4,#0x24]        ;1973
00003a  f8cc0040          STR      r0,[r12,#0x40]        ;1976
00003e  6a60              LDR      r0,[r4,#0x24]         ;1976
000040  6501              STR      r1,[r0,#0x50]         ;1979
000042  6821              LDR      r1,[r4,#0]            ;1979
000044  6a60              LDR      r0,[r4,#0x24]         ;1979
000046  3134              ADDS     r1,r1,#0x34           ;1979
000048  f7fffffe          BL       HAL_DMA_Start_IT
00004c  6820              LDR      r0,[r4,#0]            ;1982
00004e  68c1              LDR      r1,[r0,#0xc]          ;1982
000050  f4417100          ORR      r1,r1,#0x200          ;1982
000054  e02e              B        |L40.180|
                  |L40.86|
000056  f8d4c028          LDR      r12,[r4,#0x28]        ;1989
00005a  f8cc0040          STR      r0,[r12,#0x40]        ;1992
00005e  6aa0              LDR      r0,[r4,#0x28]         ;1992
000060  6501              STR      r1,[r0,#0x50]         ;1995
000062  6821              LDR      r1,[r4,#0]            ;1995
000064  6aa0              LDR      r0,[r4,#0x28]         ;1995
000066  3138              ADDS     r1,r1,#0x38           ;1995
000068  f7fffffe          BL       HAL_DMA_Start_IT
00006c  6820              LDR      r0,[r4,#0]            ;1998
00006e  68c1              LDR      r1,[r0,#0xc]          ;1998
000070  f4416180          ORR      r1,r1,#0x400          ;1998
000074  e01e              B        |L40.180|
                  |L40.118|
000076  f8d4c02c          LDR      r12,[r4,#0x2c]        ;2005
00007a  f8cc0040          STR      r0,[r12,#0x40]        ;2008
00007e  6ae0              LDR      r0,[r4,#0x2c]         ;2008
000080  6501              STR      r1,[r0,#0x50]         ;2011
000082  6821              LDR      r1,[r4,#0]            ;2011
000084  6ae0              LDR      r0,[r4,#0x2c]         ;2011
000086  313c              ADDS     r1,r1,#0x3c           ;2011
000088  f7fffffe          BL       HAL_DMA_Start_IT
00008c  6820              LDR      r0,[r4,#0]            ;2014
00008e  68c1              LDR      r1,[r0,#0xc]          ;2014
000090  f4416100          ORR      r1,r1,#0x800          ;2014
000094  e00e              B        |L40.180|
                  |L40.150|
000096  f8d4c030          LDR      r12,[r4,#0x30]        ;2021
00009a  f8cc0040          STR      r0,[r12,#0x40]        ;2024
00009e  6b20              LDR      r0,[r4,#0x30]         ;2024
0000a0  6501              STR      r1,[r0,#0x50]         ;2027
0000a2  6821              LDR      r1,[r4,#0]            ;2027
0000a4  6b20              LDR      r0,[r4,#0x30]         ;2027
0000a6  3140              ADDS     r1,r1,#0x40           ;2027
0000a8  f7fffffe          BL       HAL_DMA_Start_IT
0000ac  6820              LDR      r0,[r4,#0]            ;2030
0000ae  68c1              LDR      r1,[r0,#0xc]          ;2030
0000b0  f4415180          ORR      r1,r1,#0x1000         ;2030
                  |L40.180|
0000b4  60c1              STR      r1,[r0,#0xc]          ;2014
                  |L40.182|
0000b6  6820              LDR      r0,[r4,#0]            ;2014
0000b8  2101              MOVS     r1,#1                 ;2014
0000ba  40a9              LSLS     r1,r1,r5              ;2014
0000bc  6a02              LDR      r2,[r0,#0x20]         ;2014
0000be  438a              BICS     r2,r2,r1              ;2014
0000c0  6202              STR      r2,[r0,#0x20]         ;2014
0000c2  6a02              LDR      r2,[r0,#0x20]         ;2014
0000c4  4311              ORRS     r1,r1,r2              ;2014
0000c6  6201              STR      r1,[r0,#0x20]         ;2014
0000c8  6820              LDR      r0,[r4,#0]            ;2042
0000ca  6801              LDR      r1,[r0,#0]            ;2042
0000cc  f0410101          ORR      r1,r1,#1              ;2042
0000d0  6001              STR      r1,[r0,#0]            ;2042
0000d2  2000              MOVS     r0,#0                 ;2045
0000d4  bd70              POP      {r4-r6,pc}
;;;2047   
                          ENDP

0000d6  0000              DCW      0x0000
                  |L40.216|
                          DCD      TIM_DMACaptureCplt
                  |L40.220|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_IC_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Start_IT PROC
;;;1822     */
;;;1823   HAL_StatusTypeDef HAL_TIM_IC_Start_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
;;;1824   {
;;;1825     /* Check the parameters */
;;;1826     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1827     
;;;1828     switch (Channel)
000002  2900              CMP      r1,#0
;;;1829     {
;;;1830       case TIM_CHANNEL_1:
;;;1831       {       
;;;1832         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1833         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000004  bf04              ITT      EQ
000006  68d3              LDREQ    r3,[r2,#0xc]
000008  f0430302          ORREQ    r3,r3,#2
00000c  d011              BEQ      |L41.50|
00000e  2904              CMP      r1,#4                 ;1828
;;;1834       }
;;;1835       break;
;;;1836       
;;;1837       case TIM_CHANNEL_2:
;;;1838       {
;;;1839         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1840         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000010  bf04              ITT      EQ
000012  68d3              LDREQ    r3,[r2,#0xc]
000014  f0430304          ORREQ    r3,r3,#4
000018  d00b              BEQ      |L41.50|
00001a  2908              CMP      r1,#8                 ;1828
;;;1841       }
;;;1842       break;
;;;1843       
;;;1844       case TIM_CHANNEL_3:
;;;1845       {
;;;1846         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1847         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
00001c  bf04              ITT      EQ
00001e  68d3              LDREQ    r3,[r2,#0xc]
000020  f0430308          ORREQ    r3,r3,#8
000024  d005              BEQ      |L41.50|
000026  290c              CMP      r1,#0xc               ;1828
;;;1848       }
;;;1849       break;
;;;1850       
;;;1851       case TIM_CHANNEL_4:
;;;1852       {
;;;1853         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1854         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000028  bf04              ITT      EQ
00002a  68d3              LDREQ    r3,[r2,#0xc]
00002c  f0430310          ORREQ    r3,r3,#0x10
000030  d100              BNE      |L41.52|
                  |L41.50|
000032  60d3              STR      r3,[r2,#0xc]          ;1847
                  |L41.52|
000034  2301              MOVS     r3,#1                 ;1847
000036  6802              LDR      r2,[r0,#0]            ;1847
000038  fa03f101          LSL      r1,r3,r1              ;1847
00003c  6a13              LDR      r3,[r2,#0x20]         ;1847
00003e  438b              BICS     r3,r3,r1              ;1847
000040  6213              STR      r3,[r2,#0x20]         ;1847
000042  6a13              LDR      r3,[r2,#0x20]         ;1847
000044  4319              ORRS     r1,r1,r3              ;1847
000046  6211              STR      r1,[r2,#0x20]         ;1847
;;;1855       }
;;;1856       break;
;;;1857       
;;;1858       default:
;;;1859       break;
;;;1860     }  
;;;1861     /* Enable the Input Capture channel */
;;;1862     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1863       
;;;1864     /* Enable the Peripheral */
;;;1865     __HAL_TIM_ENABLE(htim);  
000048  6800              LDR      r0,[r0,#0]
00004a  6801              LDR      r1,[r0,#0]
00004c  f0410101          ORR      r1,r1,#1
000050  6001              STR      r1,[r0,#0]
;;;1866   
;;;1867     /* Return function status */
;;;1868     return HAL_OK;  
000052  2000              MOVS     r0,#0
;;;1869   } 
000054  4770              BX       lr
;;;1870   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop PROC
;;;1795     */
;;;1796   HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  f84d4d04          PUSH.W   {r4}
;;;1797   { 
000004  6802              LDR      r2,[r0,#0]
000006  f04f0c01          MOV      r12,#1
;;;1798     /* Check the parameters */
;;;1799     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1800     
;;;1801     /* Disable the Input Capture channel */
;;;1802     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
00000a  2300              MOVS     r3,#0
00000c  fa0cfc01          LSL      r12,r12,r1
000010  6a14              LDR      r4,[r2,#0x20]
000012  fa03f101          LSL      r1,r3,r1
000016  ea240c0c          BIC      r12,r4,r12
00001a  f8c2c020          STR      r12,[r2,#0x20]
00001e  6a13              LDR      r3,[r2,#0x20]
000020  4319              ORRS     r1,r1,r3
000022  6211              STR      r1,[r2,#0x20]
;;;1803     
;;;1804     /* Disable the Peripheral */
;;;1805     __HAL_TIM_DISABLE(htim); 
000024  6800              LDR      r0,[r0,#0]
000026  f2411111          MOV      r1,#0x1111
00002a  6a02              LDR      r2,[r0,#0x20]
00002c  420a              TST      r2,r1
00002e  d108              BNE      |L42.66|
000030  6a01              LDR      r1,[r0,#0x20]
000032  f2404244          MOV      r2,#0x444
000036  4211              TST      r1,r2
000038  d103              BNE      |L42.66|
00003a  6801              LDR      r1,[r0,#0]
00003c  f0210101          BIC      r1,r1,#1
000040  6001              STR      r1,[r0,#0]
                  |L42.66|
;;;1806     
;;;1807     /* Return function status */
;;;1808     return HAL_OK;
;;;1809   }
000042  f85d4b04          POP.W    {r4}
000046  2000              MOVS     r0,#0                 ;1808
000048  4770              BX       lr
;;;1810   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop_DMA PROC
;;;2059     */
;;;2060   HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b430              PUSH     {r4,r5}
;;;2061   {
;;;2062     /* Check the parameters */
;;;2063     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;2064     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2065     
;;;2066     switch (Channel)
000002  6802              LDR      r2,[r0,#0]
000004  2900              CMP      r1,#0
;;;2067     {
;;;2068       case TIM_CHANNEL_1:
;;;2069       {       
;;;2070         /* Disable the TIM Capture/Compare 1 DMA request */
;;;2071         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000006  bf04              ITT      EQ
000008  68d3              LDREQ    r3,[r2,#0xc]
00000a  f4237300          BICEQ    r3,r3,#0x200
00000e  d011              BEQ      |L43.52|
000010  2904              CMP      r1,#4                 ;2066
;;;2072       }
;;;2073       break;
;;;2074       
;;;2075       case TIM_CHANNEL_2:
;;;2076       {
;;;2077         /* Disable the TIM Capture/Compare 2 DMA request */
;;;2078         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000012  bf04              ITT      EQ
000014  68d3              LDREQ    r3,[r2,#0xc]
000016  f4236380          BICEQ    r3,r3,#0x400
00001a  d00b              BEQ      |L43.52|
00001c  2908              CMP      r1,#8                 ;2066
;;;2079       }
;;;2080       break;
;;;2081       
;;;2082       case TIM_CHANNEL_3:
;;;2083       {
;;;2084         /* Disable the TIM Capture/Compare 3  DMA request */
;;;2085         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
00001e  bf04              ITT      EQ
000020  68d3              LDREQ    r3,[r2,#0xc]
000022  f4236300          BICEQ    r3,r3,#0x800
000026  d005              BEQ      |L43.52|
000028  290c              CMP      r1,#0xc               ;2066
;;;2086       }
;;;2087       break;
;;;2088       
;;;2089       case TIM_CHANNEL_4:
;;;2090       {
;;;2091         /* Disable the TIM Capture/Compare 4  DMA request */
;;;2092         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
00002a  bf04              ITT      EQ
00002c  68d3              LDREQ    r3,[r2,#0xc]
00002e  f4235380          BICEQ    r3,r3,#0x1000
000032  d100              BNE      |L43.54|
                  |L43.52|
000034  60d3              STR      r3,[r2,#0xc]          ;2085
                  |L43.54|
000036  2301              MOVS     r3,#1                 ;2085
000038  6802              LDR      r2,[r0,#0]            ;2085
;;;2093       }
;;;2094       break;
;;;2095       
;;;2096       default:
;;;2097       break;
;;;2098     }
;;;2099   
;;;2100     /* Disable the Input Capture channel */
;;;2101     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
00003a  f04f0c00          MOV      r12,#0
00003e  fa03f401          LSL      r4,r3,r1
000042  6a15              LDR      r5,[r2,#0x20]
000044  fa0cf101          LSL      r1,r12,r1
000048  ea250404          BIC      r4,r5,r4
00004c  6214              STR      r4,[r2,#0x20]
00004e  f8d2c020          LDR      r12,[r2,#0x20]
000052  ea4c0101          ORR      r1,r12,r1
000056  6211              STR      r1,[r2,#0x20]
;;;2102     
;;;2103     /* Disable the Peripheral */
;;;2104     __HAL_TIM_DISABLE(htim); 
000058  6801              LDR      r1,[r0,#0]
00005a  f2411211          MOV      r2,#0x1111
00005e  f8d1c020          LDR      r12,[r1,#0x20]
000062  ea1c0f02          TST      r12,r2
000066  d109              BNE      |L43.124|
000068  6a0a              LDR      r2,[r1,#0x20]
00006a  f2404c44          MOV      r12,#0x444
00006e  ea120f0c          TST      r2,r12
000072  d103              BNE      |L43.124|
000074  680a              LDR      r2,[r1,#0]
000076  f0220201          BIC      r2,r2,#1
00007a  600a              STR      r2,[r1,#0]
                  |L43.124|
;;;2105     
;;;2106     /* Change the htim state */
;;;2107     htim->State = HAL_TIM_STATE_READY;
00007c  6403              STR      r3,[r0,#0x40]
;;;2108     
;;;2109     /* Return function status */
;;;2110     return HAL_OK;
00007e  2000              MOVS     r0,#0
;;;2111   }  
000080  bc30              POP      {r4,r5}
000082  4770              BX       lr
;;;2112   /**
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop_IT PROC
;;;1882     */
;;;1883   HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  f84d4d04          PUSH.W   {r4}
;;;1884   {
;;;1885     /* Check the parameters */
;;;1886     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1887     
;;;1888     switch (Channel)
000004  6802              LDR      r2,[r0,#0]
000006  2900              CMP      r1,#0
;;;1889     {
;;;1890       case TIM_CHANNEL_1:
;;;1891       {       
;;;1892         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1893         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000008  bf04              ITT      EQ
00000a  68d3              LDREQ    r3,[r2,#0xc]
00000c  f0230302          BICEQ    r3,r3,#2
000010  d011              BEQ      |L44.54|
000012  2904              CMP      r1,#4                 ;1888
;;;1894       }
;;;1895       break;
;;;1896       
;;;1897       case TIM_CHANNEL_2:
;;;1898       {
;;;1899         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1900         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000014  bf04              ITT      EQ
000016  68d3              LDREQ    r3,[r2,#0xc]
000018  f0230304          BICEQ    r3,r3,#4
00001c  d00b              BEQ      |L44.54|
00001e  2908              CMP      r1,#8                 ;1888
;;;1901       }
;;;1902       break;
;;;1903       
;;;1904       case TIM_CHANNEL_3:
;;;1905       {
;;;1906         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1907         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
000020  bf04              ITT      EQ
000022  68d3              LDREQ    r3,[r2,#0xc]
000024  f0230308          BICEQ    r3,r3,#8
000028  d005              BEQ      |L44.54|
00002a  290c              CMP      r1,#0xc               ;1888
;;;1908       }
;;;1909       break;
;;;1910       
;;;1911       case TIM_CHANNEL_4:
;;;1912       {
;;;1913         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1914         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
00002c  bf04              ITT      EQ
00002e  68d3              LDREQ    r3,[r2,#0xc]
000030  f0230310          BICEQ    r3,r3,#0x10
000034  d100              BNE      |L44.56|
                  |L44.54|
000036  60d3              STR      r3,[r2,#0xc]          ;1907
                  |L44.56|
000038  f04f0c01          MOV      r12,#1                ;1907
00003c  6802              LDR      r2,[r0,#0]            ;1907
;;;1915       }
;;;1916       break;
;;;1917       
;;;1918       default:
;;;1919       break; 
;;;1920     } 
;;;1921     
;;;1922     /* Disable the Input Capture channel */
;;;1923     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE); 
00003e  2300              MOVS     r3,#0
000040  fa0cfc01          LSL      r12,r12,r1
000044  6a14              LDR      r4,[r2,#0x20]
000046  fa03f101          LSL      r1,r3,r1
00004a  ea240c0c          BIC      r12,r4,r12
00004e  f8c2c020          STR      r12,[r2,#0x20]
000052  6a13              LDR      r3,[r2,#0x20]
000054  4319              ORRS     r1,r1,r3
000056  6211              STR      r1,[r2,#0x20]
;;;1924     
;;;1925     /* Disable the Peripheral */
;;;1926     __HAL_TIM_DISABLE(htim); 
000058  6800              LDR      r0,[r0,#0]
00005a  f2411111          MOV      r1,#0x1111
00005e  6a02              LDR      r2,[r0,#0x20]
000060  420a              TST      r2,r1
000062  d108              BNE      |L44.118|
000064  6a01              LDR      r1,[r0,#0x20]
000066  f2404244          MOV      r2,#0x444
00006a  4211              TST      r1,r2
00006c  d103              BNE      |L44.118|
00006e  6801              LDR      r1,[r0,#0]
000070  f0210101          BIC      r1,r1,#1
000074  6001              STR      r1,[r0,#0]
                  |L44.118|
;;;1927     
;;;1928     /* Return function status */
;;;1929     return HAL_OK;
;;;1930   }
000076  f85d4b04          POP.W    {r4}
00007a  2000              MOVS     r0,#0                 ;1929
00007c  4770              BX       lr
;;;1931   
                          ENDP


                          AREA ||i.HAL_TIM_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IRQHandler PROC
;;;3012     */
;;;3013   void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
000000  b570              PUSH     {r4-r6,lr}
;;;3014   {
000002  4604              MOV      r4,r0
;;;3015     /* Capture compare 1 event */
;;;3016     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
000004  6800              LDR      r0,[r0,#0]
000006  2500              MOVS     r5,#0
000008  6901              LDR      r1,[r0,#0x10]
00000a  f0110f02          TST      r1,#2
;;;3017     {
;;;3018       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
00000e  bf1c              ITT      NE
000010  68c1              LDRNE    r1,[r0,#0xc]
000012  f0110f02          TSTNE    r1,#2
000016  d013              BEQ      |L45.64|
;;;3019       {
;;;3020         {
;;;3021           __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
;;;3022           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000018  2101              MOVS     r1,#1
00001a  f06f0202          MVN      r2,#2                 ;3021
00001e  6102              STR      r2,[r0,#0x10]         ;3021
;;;3023           
;;;3024           /* Input capture event */
;;;3025           if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00)
000020  61e1              STR      r1,[r4,#0x1c]
000022  6820              LDR      r0,[r4,#0]
000024  6980              LDR      r0,[r0,#0x18]
000026  f0100f03          TST      r0,#3
;;;3026           {
;;;3027   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3028             htim->IC_CaptureCallback(htim);
;;;3029   #else
;;;3030             HAL_TIM_IC_CaptureCallback(htim);
;;;3031   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3032           }
;;;3033           /* Output compare event */
;;;3034           else
;;;3035           {
;;;3036   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3037             htim->OC_DelayElapsedCallback(htim);
;;;3038             htim->PWM_PulseFinishedCallback(htim);
;;;3039   #else
;;;3040             HAL_TIM_OC_DelayElapsedCallback(htim);
00002a  4620              MOV      r0,r4
00002c  d002              BEQ      |L45.52|
00002e  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
000032  e004              B        |L45.62|
                  |L45.52|
000034  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;3041             HAL_TIM_PWM_PulseFinishedCallback(htim);
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.62|
;;;3042   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3043           }
;;;3044           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
00003e  61e5              STR      r5,[r4,#0x1c]
                  |L45.64|
;;;3045         }
;;;3046       }
;;;3047     }
;;;3048     /* Capture compare 2 event */
;;;3049     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
000040  6820              LDR      r0,[r4,#0]
000042  6901              LDR      r1,[r0,#0x10]
000044  f0110f04          TST      r1,#4
;;;3050     {
;;;3051       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
000048  bf1c              ITT      NE
00004a  68c1              LDRNE    r1,[r0,#0xc]
00004c  f0110f04          TSTNE    r1,#4
000050  d013              BEQ      |L45.122|
;;;3052       {
;;;3053         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
;;;3054         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
000052  2102              MOVS     r1,#2
000054  f06f0204          MVN      r2,#4                 ;3053
000058  6102              STR      r2,[r0,#0x10]         ;3053
;;;3055         /* Input capture event */
;;;3056         if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
00005a  61e1              STR      r1,[r4,#0x1c]
00005c  6820              LDR      r0,[r4,#0]
00005e  6980              LDR      r0,[r0,#0x18]
000060  f4107f40          TST      r0,#0x300
;;;3057         {
;;;3058   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3059           htim->IC_CaptureCallback(htim);
;;;3060   #else
;;;3061           HAL_TIM_IC_CaptureCallback(htim);
;;;3062   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3063         }
;;;3064         /* Output compare event */
;;;3065         else
;;;3066         {
;;;3067   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3068           htim->OC_DelayElapsedCallback(htim);
;;;3069           htim->PWM_PulseFinishedCallback(htim);
;;;3070   #else
;;;3071           HAL_TIM_OC_DelayElapsedCallback(htim);
000064  4620              MOV      r0,r4
000066  d002              BEQ      |L45.110|
000068  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
00006c  e004              B        |L45.120|
                  |L45.110|
00006e  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;3072           HAL_TIM_PWM_PulseFinishedCallback(htim);
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.120|
;;;3073   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3074         }
;;;3075         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000078  61e5              STR      r5,[r4,#0x1c]
                  |L45.122|
;;;3076       }
;;;3077     }
;;;3078     /* Capture compare 3 event */
;;;3079     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
00007a  6820              LDR      r0,[r4,#0]
00007c  6901              LDR      r1,[r0,#0x10]
00007e  f0110f08          TST      r1,#8
;;;3080     {
;;;3081       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
000082  bf1c              ITT      NE
000084  68c1              LDRNE    r1,[r0,#0xc]
000086  f0110f08          TSTNE    r1,#8
00008a  d013              BEQ      |L45.180|
;;;3082       {
;;;3083         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
;;;3084         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
00008c  2104              MOVS     r1,#4
00008e  f06f0208          MVN      r2,#8                 ;3083
000092  6102              STR      r2,[r0,#0x10]         ;3083
;;;3085         /* Input capture event */
;;;3086         if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
000094  61e1              STR      r1,[r4,#0x1c]
000096  6820              LDR      r0,[r4,#0]
000098  69c0              LDR      r0,[r0,#0x1c]
00009a  f0100f03          TST      r0,#3
;;;3087         {          
;;;3088   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3089           htim->IC_CaptureCallback(htim);
;;;3090   #else
;;;3091           HAL_TIM_IC_CaptureCallback(htim);
;;;3092   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3093         }
;;;3094         /* Output compare event */
;;;3095         else
;;;3096         {
;;;3097   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3098           htim->OC_DelayElapsedCallback(htim);
;;;3099           htim->PWM_PulseFinishedCallback(htim);
;;;3100   #else
;;;3101           HAL_TIM_OC_DelayElapsedCallback(htim);
00009e  4620              MOV      r0,r4
0000a0  d002              BEQ      |L45.168|
0000a2  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
0000a6  e004              B        |L45.178|
                  |L45.168|
0000a8  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;3102           HAL_TIM_PWM_PulseFinishedCallback(htim);
0000ac  4620              MOV      r0,r4
0000ae  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.178|
;;;3103   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3104         }
;;;3105         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
0000b2  61e5              STR      r5,[r4,#0x1c]
                  |L45.180|
;;;3106       }
;;;3107     }
;;;3108     /* Capture compare 4 event */
;;;3109     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
0000b4  6820              LDR      r0,[r4,#0]
0000b6  6901              LDR      r1,[r0,#0x10]
0000b8  f0110f10          TST      r1,#0x10
;;;3110     {
;;;3111       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
0000bc  bf1c              ITT      NE
0000be  68c1              LDRNE    r1,[r0,#0xc]
0000c0  f0110f10          TSTNE    r1,#0x10
0000c4  d013              BEQ      |L45.238|
;;;3112       {
;;;3113         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
;;;3114         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
0000c6  2108              MOVS     r1,#8
0000c8  f06f0210          MVN      r2,#0x10              ;3113
0000cc  6102              STR      r2,[r0,#0x10]         ;3113
;;;3115         /* Input capture event */
;;;3116         if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
0000ce  61e1              STR      r1,[r4,#0x1c]
0000d0  6820              LDR      r0,[r4,#0]
0000d2  69c0              LDR      r0,[r0,#0x1c]
0000d4  f4107f40          TST      r0,#0x300
;;;3117         {          
;;;3118   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3119           htim->IC_CaptureCallback(htim);
;;;3120   #else
;;;3121           HAL_TIM_IC_CaptureCallback(htim);
;;;3122   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3123         }
;;;3124         /* Output compare event */
;;;3125         else
;;;3126         {
;;;3127   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3128           htim->OC_DelayElapsedCallback(htim);
;;;3129           htim->PWM_PulseFinishedCallback(htim);
;;;3130   #else
;;;3131           HAL_TIM_OC_DelayElapsedCallback(htim);
0000d8  4620              MOV      r0,r4
0000da  d002              BEQ      |L45.226|
0000dc  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
0000e0  e004              B        |L45.236|
                  |L45.226|
0000e2  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;3132           HAL_TIM_PWM_PulseFinishedCallback(htim);
0000e6  4620              MOV      r0,r4
0000e8  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.236|
;;;3133   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3134         }
;;;3135         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
0000ec  61e5              STR      r5,[r4,#0x1c]
                  |L45.238|
;;;3136       }
;;;3137     }
;;;3138     /* TIM Update event */
;;;3139     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
0000ee  6820              LDR      r0,[r4,#0]
0000f0  6901              LDR      r1,[r0,#0x10]
0000f2  f0110f01          TST      r1,#1
;;;3140     {
;;;3141       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
0000f6  bf1c              ITT      NE
0000f8  68c1              LDRNE    r1,[r0,#0xc]
0000fa  f0110f01          TSTNE    r1,#1
0000fe  d005              BEQ      |L45.268|
;;;3142       {
;;;3143         __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
000100  f06f0101          MVN      r1,#1
000104  6101              STR      r1,[r0,#0x10]
;;;3144   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3145         htim->PeriodElapsedCallback(htim);
;;;3146   #else
;;;3147         HAL_TIM_PeriodElapsedCallback(htim);
000106  4620              MOV      r0,r4
000108  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
                  |L45.268|
;;;3148   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3149       }
;;;3150     }
;;;3151     /* TIM Break input event */
;;;3152     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
00010c  6820              LDR      r0,[r4,#0]
;;;3153     {
;;;3154       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
;;;3155       {
;;;3156         __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
00010e  f06f0580          MVN      r5,#0x80
000112  6901              LDR      r1,[r0,#0x10]         ;3152
000114  f0110f80          TST      r1,#0x80              ;3152
000118  bf1c              ITT      NE                    ;3154
00011a  68c1              LDRNE    r1,[r0,#0xc]          ;3154
00011c  f0110f80          TSTNE    r1,#0x80              ;3154
000120  d003              BEQ      |L45.298|
000122  6105              STR      r5,[r0,#0x10]
;;;3157   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3158         htim->BreakCallback(htim);
;;;3159   #else
;;;3160         HAL_TIMEx_BreakCallback(htim);
000124  4620              MOV      r0,r4
000126  f7fffffe          BL       HAL_TIMEx_BreakCallback
                  |L45.298|
;;;3161   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3162   
;;;3163       }
;;;3164     }
;;;3165     
;;;3166       /* TIM Break input event */
;;;3167     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
00012a  6820              LDR      r0,[r4,#0]
00012c  6901              LDR      r1,[r0,#0x10]
00012e  f4117f80          TST      r1,#0x100
;;;3168     {
;;;3169       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
000132  bf1c              ITT      NE
000134  68c1              LDRNE    r1,[r0,#0xc]
000136  f0110f80          TSTNE    r1,#0x80
00013a  d003              BEQ      |L45.324|
;;;3170       {
;;;3171         __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
00013c  6105              STR      r5,[r0,#0x10]
;;;3172   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3173         htim->BreakCallback(htim);
;;;3174   #else
;;;3175         HAL_TIMEx_BreakCallback(htim);
00013e  4620              MOV      r0,r4
000140  f7fffffe          BL       HAL_TIMEx_BreakCallback
                  |L45.324|
;;;3176   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3177       }
;;;3178     }
;;;3179   
;;;3180     /* TIM Trigger detection event */
;;;3181     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
000144  6820              LDR      r0,[r4,#0]
000146  6901              LDR      r1,[r0,#0x10]
000148  f0110f40          TST      r1,#0x40
;;;3182     {
;;;3183       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
00014c  bf1c              ITT      NE
00014e  68c1              LDRNE    r1,[r0,#0xc]
000150  f0110f40          TSTNE    r1,#0x40
000154  d005              BEQ      |L45.354|
;;;3184       {
;;;3185         __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
000156  f06f0140          MVN      r1,#0x40
00015a  6101              STR      r1,[r0,#0x10]
;;;3186   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3187         htim->TriggerCallback(htim);
;;;3188   #else
;;;3189         HAL_TIM_TriggerCallback(htim);
00015c  4620              MOV      r0,r4
00015e  f7fffffe          BL       HAL_TIM_TriggerCallback
                  |L45.354|
;;;3190   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3191       }
;;;3192     }
;;;3193     /* TIM commutation event */
;;;3194     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
000162  6820              LDR      r0,[r4,#0]
000164  6901              LDR      r1,[r0,#0x10]
000166  f0110f20          TST      r1,#0x20
;;;3195     {
;;;3196       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
00016a  bf1a              ITTE     NE
00016c  68c1              LDRNE    r1,[r0,#0xc]
00016e  f0110f20          TSTNE    r1,#0x20
;;;3197       {
;;;3198         __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
;;;3199   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3200         htim->CommutationCallback(htim);
;;;3201   #else
;;;3202         HAL_TIMEx_CommutationCallback(htim);
;;;3203   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3204       }
;;;3205     }
;;;3206   }
000172  bd70              POPEQ    {r4-r6,pc}
000174  f06f0120          MVN      r1,#0x20              ;3198
000178  6101              STR      r1,[r0,#0x10]         ;3198
00017a  4620              MOV      r0,r4                 ;3202
00017c  e8bd4070          POP      {r4-r6,lr}            ;3202
000180  f7ffbffe          B.W      HAL_TIMEx_CommutationCallback
;;;3207   
                          ENDP


                          AREA ||i.HAL_TIM_OC_ConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_ConfigChannel PROC
;;;3244     */
;;;3245   __weak HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
000000  6bc3              LDR      r3,[r0,#0x3c]
;;;3246   {
;;;3247     /* Check the parameters */ 
;;;3248     assert_param(IS_TIM_CHANNELS(Channel)); 
;;;3249     assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
;;;3250     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;3251     
;;;3252     /* Check input state */
;;;3253     __HAL_LOCK(htim); 
000002  2b01              CMP      r3,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;3254     
;;;3255     htim->State = HAL_TIM_STATE_BUSY;
;;;3256     
;;;3257     switch (Channel)
;;;3258     {
;;;3259       case TIM_CHANNEL_1:
;;;3260       {
;;;3261         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3262         /* Configure the TIM Channel 1 in Output Compare */
;;;3263         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;3264       }
;;;3265       break;
;;;3266       
;;;3267       case TIM_CHANNEL_2:
;;;3268       {
;;;3269         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3270         /* Configure the TIM Channel 2 in Output Compare */
;;;3271         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;3272       }
;;;3273       break;
;;;3274       
;;;3275       case TIM_CHANNEL_3:
;;;3276       {
;;;3277          assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3278         /* Configure the TIM Channel 3 in Output Compare */
;;;3279         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;3280       }
;;;3281       break;
;;;3282       
;;;3283       case TIM_CHANNEL_4:
;;;3284       {
;;;3285         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3286         /* Configure the TIM Channel 4 in Output Compare */
;;;3287         TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;3288       }
;;;3289       break;
;;;3290       
;;;3291       default:
;;;3292       break;    
;;;3293     }
;;;3294     htim->State = HAL_TIM_STATE_READY;
;;;3295     
;;;3296     __HAL_UNLOCK(htim); 
;;;3297     
;;;3298     return HAL_OK;
;;;3299   }
000008  4770              BXEQ     lr
00000a  e92d03f0          PUSH     {r4-r9}               ;3246
00000e  2401              MOVS     r4,#1                 ;3253
000010  63c4              STR      r4,[r0,#0x3c]         ;3255
000012  2302              MOVS     r3,#2                 ;3255
000014  6403              STR      r3,[r0,#0x40]         ;3255
000016  4b61              LDR      r3,|L46.412|
000018  f8dfc184          LDR      r12,|L46.416|
00001c  b132              CBZ      r2,|L46.44|
00001e  2a04              CMP      r2,#4                 ;3257
000020  d031              BEQ      |L46.134|
000022  2a08              CMP      r2,#8                 ;3257
000024  d05f              BEQ      |L46.230|
000026  2a0c              CMP      r2,#0xc               ;3257
000028  d07d              BEQ      |L46.294|
00002a  e0b0              B        |L46.398|
                  |L46.44|
00002c  6802              LDR      r2,[r0,#0]            ;3257
00002e  6a15              LDR      r5,[r2,#0x20]         ;3257
000030  429a              CMP      r2,r3                 ;3257
000032  f0250301          BIC      r3,r5,#1              ;3257
000036  6213              STR      r3,[r2,#0x20]         ;3257
000038  6a15              LDR      r5,[r2,#0x20]         ;3257
00003a  6853              LDR      r3,[r2,#4]            ;3257
00003c  6996              LDR      r6,[r2,#0x18]         ;3257
00003e  f0250502          BIC      r5,r5,#2              ;3257
000042  f8d18008          LDR      r8,[r1,#8]            ;3257
000046  680f              LDR      r7,[r1,#0]            ;3257
000048  f0260673          BIC      r6,r6,#0x73           ;3257
00004c  f4263680          BIC      r6,r6,#0x10000        ;3257
000050  ea480505          ORR      r5,r8,r5              ;3257
000054  ea470606          ORR      r6,r7,r6              ;3257
000058  bf18              IT       NE                    ;3257
00005a  4562              CMPNE    r2,r12                ;3257
00005c  d10e              BNE      |L46.124|
00005e  f8d1900c          LDR      r9,[r1,#0xc]          ;3263
000062  f0250c08          BIC      r12,r5,#8             ;3263
000066  e9d17805          LDRD     r7,r8,[r1,#0x14]      ;3263
00006a  f4237340          BIC      r3,r3,#0x300          ;3263
00006e  433b              ORRS     r3,r3,r7              ;3263
000070  ea490c0c          ORR      r12,r9,r12            ;3263
000074  f02c0504          BIC      r5,r12,#4             ;3263
000078  ea480303          ORR      r3,r8,r3              ;3263
                  |L46.124|
00007c  6053              STR      r3,[r2,#4]            ;3263
00007e  6196              STR      r6,[r2,#0x18]         ;3263
000080  6849              LDR      r1,[r1,#4]            ;3263
000082  6351              STR      r1,[r2,#0x34]         ;3263
000084  e082              B        |L46.396|
                  |L46.134|
000086  6802              LDR      r2,[r0,#0]            ;3265
000088  6a15              LDR      r5,[r2,#0x20]         ;3265
00008a  429a              CMP      r2,r3                 ;3265
00008c  f0250310          BIC      r3,r5,#0x10           ;3265
000090  6213              STR      r3,[r2,#0x20]         ;3265
000092  6a15              LDR      r5,[r2,#0x20]         ;3265
000094  6853              LDR      r3,[r2,#4]            ;3265
000096  6996              LDR      r6,[r2,#0x18]         ;3265
000098  f0250520          BIC      r5,r5,#0x20           ;3265
00009c  f8d18008          LDR      r8,[r1,#8]            ;3265
0000a0  680f              LDR      r7,[r1,#0]            ;3265
0000a2  f42646e6          BIC      r6,r6,#0x7300         ;3265
0000a6  f0267680          BIC      r6,r6,#0x1000000      ;3265
0000aa  ea451508          ORR      r5,r5,r8,LSL #4       ;3265
0000ae  ea462607          ORR      r6,r6,r7,LSL #8       ;3265
0000b2  bf18              IT       NE                    ;3265
0000b4  4562              CMPNE    r2,r12                ;3265
0000b6  d111              BNE      |L46.220|
0000b8  f4236c80          BIC      r12,r3,#0x400         ;3271
0000bc  f8d1800c          LDR      r8,[r1,#0xc]          ;3271
0000c0  e9d17905          LDRD     r7,r9,[r1,#0x14]      ;3271
0000c4  f0250380          BIC      r3,r5,#0x80           ;3271
0000c8  f42c6c00          BIC      r12,r12,#0x800        ;3271
0000cc  ea431308          ORR      r3,r3,r8,LSL #4       ;3271
0000d0  ea4c0c87          ORR      r12,r12,r7,LSL #2     ;3271
0000d4  f0230540          BIC      r5,r3,#0x40           ;3271
0000d8  ea4c0389          ORR      r3,r12,r9,LSL #2      ;3271
                  |L46.220|
0000dc  6053              STR      r3,[r2,#4]            ;3271
0000de  6196              STR      r6,[r2,#0x18]         ;3271
0000e0  6849              LDR      r1,[r1,#4]            ;3271
0000e2  6391              STR      r1,[r2,#0x38]         ;3271
0000e4  e052              B        |L46.396|
                  |L46.230|
0000e6  6802              LDR      r2,[r0,#0]            ;3273
0000e8  6a15              LDR      r5,[r2,#0x20]         ;3273
0000ea  429a              CMP      r2,r3                 ;3273
0000ec  f4257380          BIC      r3,r5,#0x100          ;3273
0000f0  6213              STR      r3,[r2,#0x20]         ;3273
0000f2  6a15              LDR      r5,[r2,#0x20]         ;3273
0000f4  6853              LDR      r3,[r2,#4]            ;3273
0000f6  69d6              LDR      r6,[r2,#0x1c]         ;3273
0000f8  f4257500          BIC      r5,r5,#0x200          ;3273
0000fc  f8d18008          LDR      r8,[r1,#8]            ;3273
000100  680f              LDR      r7,[r1,#0]            ;3273
000102  f0260673          BIC      r6,r6,#0x73           ;3273
000106  f4263680          BIC      r6,r6,#0x10000        ;3273
00010a  ea452508          ORR      r5,r5,r8,LSL #8       ;3273
00010e  ea470606          ORR      r6,r7,r6              ;3273
000112  bf18              IT       NE                    ;3273
000114  4562              CMPNE    r2,r12                ;3273
000116  d111              BNE      |L46.316|
000118  f8d1900c          LDR      r9,[r1,#0xc]          ;3279
00011c  f4256c00          BIC      r12,r5,#0x800         ;3279
000120  f4235340          BIC      r3,r3,#0x3000         ;3279
000124  e000              B        |L46.296|
                  |L46.294|
000126  e00e              B        |L46.326|
                  |L46.296|
000128  e9d17805          LDRD     r7,r8,[r1,#0x14]      ;3279
00012c  ea4c2c09          ORR      r12,r12,r9,LSL #8     ;3279
000130  f42c6580          BIC      r5,r12,#0x400         ;3279
000134  ea431307          ORR      r3,r3,r7,LSL #4       ;3279
000138  ea431308          ORR      r3,r3,r8,LSL #4       ;3279
                  |L46.316|
00013c  6053              STR      r3,[r2,#4]            ;3279
00013e  61d6              STR      r6,[r2,#0x1c]         ;3279
000140  6849              LDR      r1,[r1,#4]            ;3279
000142  63d1              STR      r1,[r2,#0x3c]         ;3279
000144  e022              B        |L46.396|
                  |L46.326|
000146  6802              LDR      r2,[r0,#0]            ;3281
000148  6a15              LDR      r5,[r2,#0x20]         ;3281
00014a  429a              CMP      r2,r3                 ;3281
00014c  f4255380          BIC      r3,r5,#0x1000         ;3281
000150  6213              STR      r3,[r2,#0x20]         ;3281
000152  6a15              LDR      r5,[r2,#0x20]         ;3281
000154  6853              LDR      r3,[r2,#4]            ;3281
000156  69d6              LDR      r6,[r2,#0x1c]         ;3281
000158  f4255500          BIC      r5,r5,#0x2000         ;3281
00015c  f8d18008          LDR      r8,[r1,#8]            ;3281
000160  680f              LDR      r7,[r1,#0]            ;3281
000162  f42646e6          BIC      r6,r6,#0x7300         ;3281
000166  f0267680          BIC      r6,r6,#0x1000000      ;3281
00016a  ea453508          ORR      r5,r5,r8,LSL #12      ;3281
00016e  ea462607          ORR      r6,r6,r7,LSL #8       ;3281
000172  bf18              IT       NE                    ;3281
000174  4562              CMPNE    r2,r12                ;3281
000176  d105              BNE      |L46.388|
000178  f8d1c014          LDR      r12,[r1,#0x14]        ;3287
00017c  f4234380          BIC      r3,r3,#0x4000         ;3287
000180  ea43138c          ORR      r3,r3,r12,LSL #6      ;3287
                  |L46.388|
000184  6053              STR      r3,[r2,#4]            ;3287
000186  61d6              STR      r6,[r2,#0x1c]         ;3287
000188  6849              LDR      r1,[r1,#4]            ;3287
00018a  6411              STR      r1,[r2,#0x40]         ;3287
                  |L46.396|
00018c  6215              STR      r5,[r2,#0x20]         ;3287
                  |L46.398|
00018e  2100              MOVS     r1,#0                 ;3296
000190  6404              STR      r4,[r0,#0x40]         ;3294
000192  63c1              STR      r1,[r0,#0x3c]         ;3298
000194  4608              MOV      r0,r1                 ;3298
000196  e8bd03f0          POP      {r4-r9}
00019a  4770              BX       lr
;;;3300   
                          ENDP

                  |L46.412|
                          DCD      0x40010000
                  |L46.416|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_DeInit PROC
;;;615      */
;;;616    HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;617    {
000002  4604              MOV      r4,r0
;;;618      /* Check the parameters */
;;;619      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;620      
;;;621       htim->State = HAL_TIM_STATE_BUSY;
;;;622       
;;;623      /* Disable the TIM Peripheral Clock */
;;;624      __HAL_TIM_DISABLE(htim);
000004  f2411111          MOV      r1,#0x1111
000008  2002              MOVS     r0,#2                 ;621
00000a  6420              STR      r0,[r4,#0x40]         ;621
00000c  6820              LDR      r0,[r4,#0]
00000e  6a02              LDR      r2,[r0,#0x20]
000010  420a              TST      r2,r1
000012  d108              BNE      |L47.38|
000014  6a01              LDR      r1,[r0,#0x20]
000016  f2404244          MOV      r2,#0x444
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L47.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L47.38|
;;;625    
;;;626    #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;627      if(htim->OC_MspDeInitCallback == NULL)
;;;628      {
;;;629        htim->OC_MspDeInitCallback = HAL_TIM_OC_MspDeInit;
;;;630      }
;;;631      /* DeInit the low level hardware */
;;;632      htim->OC_MspDeInitCallback(htim);
;;;633    #else
;;;634      /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;635      HAL_TIM_OC_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_OC_MspDeInit
;;;636    #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;637    
;;;638      /* Change TIM state */  
;;;639      htim->State = HAL_TIM_STATE_RESET; 
00002c  2000              MOVS     r0,#0
00002e  6420              STR      r0,[r4,#0x40]
;;;640    
;;;641      /* Release Lock */
;;;642      __HAL_UNLOCK(htim);
000030  63e0              STR      r0,[r4,#0x3c]
;;;643    
;;;644      return HAL_OK;
;;;645    }
000032  bd10              POP      {r4,pc}
;;;646    
                          ENDP


                          AREA ||i.HAL_TIM_OC_DelayElapsedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_DelayElapsedCallback PROC
;;;4704     */
;;;4705   __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4706   {
;;;4707     /* Prevent unused argument(s) compilation warning */
;;;4708     UNUSED(htim);
;;;4709    
;;;4710     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4711               the __HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
;;;4712      */
;;;4713   }
;;;4714   /**
                          ENDP


                          AREA ||i.HAL_TIM_OC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_GetState PROC
;;;5245     */
;;;5246   HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
000000  6c00              LDR      r0,[r0,#0x40]
;;;5247   {
;;;5248     return htim->State;
;;;5249   }
000002  4770              BX       lr
;;;5250   
                          ENDP


                          AREA ||i.HAL_TIM_OC_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_Init PROC
;;;563      */
;;;564    HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef* htim)
000000  2800              CMP      r0,#0
;;;565    {
;;;566      /* Check the TIM handle allocation */
;;;567      if(htim == NULL)
;;;568      {
;;;569        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;570      }
;;;571    
;;;572      /* Check the parameters */
;;;573      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;574      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;575      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;576      assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;577    
;;;578      if(htim->State == HAL_TIM_STATE_RESET)
;;;579      {
;;;580        /* Allocate lock resource and initialize it */
;;;581        htim->Lock = HAL_UNLOCKED;
;;;582    
;;;583    #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;584        /* Reset interrupt callbacks to legacy week callbacks */
;;;585        TIM_ResetCallback(htim);
;;;586    
;;;587        if(htim->OC_MspInitCallback == NULL)
;;;588        {
;;;589          htim->OC_MspInitCallback = HAL_TIM_OC_MspDeInit;
;;;590        }
;;;591        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;592        htim->OC_MspInitCallback(htim);
;;;593    #else
;;;594        /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;595        HAL_TIM_OC_MspInit(htim);
;;;596    #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;597      }
;;;598      /* Set the TIM state */
;;;599      htim->State= HAL_TIM_STATE_BUSY;
;;;600      
;;;601      /* Init the base time for the Output Compare */  
;;;602      TIM_Base_SetConfig(htim->Instance,  &htim->Init); 
;;;603      
;;;604      /* Initialize the TIM state*/
;;;605      htim->State= HAL_TIM_STATE_READY;
;;;606      
;;;607      return HAL_OK;
;;;608    }
000006  4770              BXEQ     lr
000008  b510              PUSH     {r4,lr}               ;565
00000a  4604              MOV      r4,r0                 ;565
00000c  6c00              LDR      r0,[r0,#0x40]         ;578
00000e  b920              CBNZ     r0,|L50.26|
000010  2000              MOVS     r0,#0                 ;581
000012  63e0              STR      r0,[r4,#0x3c]         ;595
000014  4620              MOV      r0,r4                 ;595
000016  f7fffffe          BL       HAL_TIM_OC_MspInit
                  |L50.26|
00001a  2002              MOVS     r0,#2                 ;599
00001c  6420              STR      r0,[r4,#0x40]         ;599
00001e  6820              LDR      r0,[r4,#0]            ;602
000020  1d21              ADDS     r1,r4,#4              ;602
000022  f7fffffe          BL       TIM_Base_SetConfig
000026  2001              MOVS     r0,#1                 ;605
000028  6420              STR      r0,[r4,#0x40]         ;605
00002a  2000              MOVS     r0,#0                 ;607
00002c  bd10              POP      {r4,pc}
;;;609    
                          ENDP


                          AREA ||i.HAL_TIM_OC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_MspDeInit PROC
;;;668      */
;;;669    __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;670    {
;;;671      /* Prevent unused argument(s) compilation warning */
;;;672      UNUSED(htim);
;;;673     
;;;674      /* NOTE : This function Should not be modified, when the callback is needed,
;;;675                the HAL_TIM_OC_MspDeInit could be implemented in the user file
;;;676       */
;;;677    }
;;;678    
                          ENDP


                          AREA ||i.HAL_TIM_OC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_MspInit PROC
;;;652      */
;;;653    __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;654    {
;;;655      /* Prevent unused argument(s) compilation warning */
;;;656      UNUSED(htim);
;;;657     
;;;658      /* NOTE : This function Should not be modified, when the callback is needed,
;;;659                the HAL_TIM_OC_MspInit could be implemented in the user file
;;;660       */
;;;661    }
;;;662    
                          ENDP


                          AREA ||i.HAL_TIM_OC_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_Start PROC
;;;690      */
;;;691    HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
000002  2301              MOVS     r3,#1
000004  fa03f101          LSL      r1,r3,r1
000008  6a13              LDR      r3,[r2,#0x20]
00000a  438b              BICS     r3,r3,r1
00000c  6213              STR      r3,[r2,#0x20]
00000e  6a13              LDR      r3,[r2,#0x20]
000010  4319              ORRS     r1,r1,r3
000012  6211              STR      r1,[r2,#0x20]
;;;692    {
;;;693      /* Check the parameters */
;;;694      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;695      
;;;696      /* Enable the Output compare channel */
;;;697      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;698      
;;;699      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000014  6801              LDR      r1,[r0,#0]
000016  f1a14280          SUB      r2,r1,#0x40000000
00001a  f5b23280          SUBS     r2,r2,#0x10000
00001e  bf1c              ITT      NE
000020  f1a14280          SUBNE    r2,r1,#0x40000000
000024  f5b23282          SUBSNE   r2,r2,#0x10400
000028  d103              BNE      |L53.50|
;;;700      {
;;;701        /* Enable the main output */
;;;702        __HAL_TIM_MOE_ENABLE(htim);
00002a  6c4a              LDR      r2,[r1,#0x44]
00002c  f4424200          ORR      r2,r2,#0x8000
000030  644a              STR      r2,[r1,#0x44]
                  |L53.50|
;;;703      }
;;;704      
;;;705      /* Enable the Peripheral */
;;;706      __HAL_TIM_ENABLE(htim); 
000032  6800              LDR      r0,[r0,#0]
000034  6801              LDR      r1,[r0,#0]
000036  f0410101          ORR      r1,r1,#1
00003a  6001              STR      r1,[r0,#0]
;;;707      
;;;708      /* Return function status */
;;;709      return HAL_OK;
00003c  2000              MOVS     r0,#0
;;;710    }
00003e  4770              BX       lr
;;;711    
                          ENDP


                          AREA ||i.HAL_TIM_OC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start_DMA PROC
;;;892      */
;;;893    HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;894    {
000002  4604              MOV      r4,r0
;;;895      /* Check the parameters */
;;;896      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;897      
;;;898      if((htim->State == HAL_TIM_STATE_BUSY))
000004  6c00              LDR      r0,[r0,#0x40]
000006  4694              MOV      r12,r2                ;894
000008  460d              MOV      r5,r1                 ;894
00000a  2802              CMP      r0,#2
;;;899      {
;;;900         return HAL_BUSY;
;;;901      }
;;;902      else if((htim->State == HAL_TIM_STATE_READY))
;;;903      {
;;;904        if(((uint32_t)pData == 0 ) && (Length > 0)) 
;;;905        {
;;;906          return HAL_ERROR;                                    
;;;907        }
;;;908        else
;;;909        {
;;;910          htim->State = HAL_TIM_STATE_BUSY;
;;;911        }
;;;912      }    
;;;913      switch (Channel)
;;;914      {
;;;915        case TIM_CHANNEL_1:
;;;916        {      
;;;917          /* Set the DMA Period elapsed callback */
;;;918          htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;919         
;;;920          /* Set the DMA error callback */
;;;921          htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;922          
;;;923          /* Enable the DMA Stream */
;;;924          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;925          
;;;926          /* Enable the TIM Capture/Compare 1 DMA request */
;;;927          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;928        }
;;;929        break;
;;;930        
;;;931        case TIM_CHANNEL_2:
;;;932        {
;;;933          /* Set the DMA Period elapsed callback */
;;;934          htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;935         
;;;936          /* Set the DMA error callback */
;;;937          htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;938          
;;;939          /* Enable the DMA Stream */
;;;940          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;941          
;;;942          /* Enable the TIM Capture/Compare 2 DMA request */
;;;943          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;944        }
;;;945        break;
;;;946        
;;;947        case TIM_CHANNEL_3:
;;;948        {
;;;949          /* Set the DMA Period elapsed callback */
;;;950          htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;951         
;;;952          /* Set the DMA error callback */
;;;953          htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
;;;954          
;;;955          /* Enable the DMA Stream */
;;;956          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;957          
;;;958          /* Enable the TIM Capture/Compare 3 DMA request */
;;;959          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;960        }
;;;961        break;
;;;962        
;;;963        case TIM_CHANNEL_4:
;;;964        {
;;;965         /* Set the DMA Period elapsed callback */
;;;966          htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;967         
;;;968          /* Set the DMA error callback */
;;;969          htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
;;;970          
;;;971          /* Enable the DMA Stream */
;;;972          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;973          
;;;974          /* Enable the TIM Capture/Compare 4 DMA request */
;;;975          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;976        }
;;;977        break;
;;;978        
;;;979        default:
;;;980        break;
;;;981      }
;;;982    
;;;983      /* Enable the Output compare channel */
;;;984      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;985      
;;;986      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
;;;987      {
;;;988        /* Enable the main output */
;;;989        __HAL_TIM_MOE_ENABLE(htim);
;;;990      }  
;;;991      
;;;992      /* Enable the Peripheral */
;;;993      __HAL_TIM_ENABLE(htim); 
;;;994      
;;;995      /* Return function status */
;;;996      return HAL_OK;
;;;997    }
00000c  bf08              IT       EQ
00000e  bd70              POPEQ    {r4-r6,pc}
000010  6c20              LDR      r0,[r4,#0x40]         ;902
000012  2801              CMP      r0,#1                 ;902
000014  d108              BNE      |L54.40|
000016  f1bc0f00          CMP      r12,#0                ;904
00001a  d103              BNE      |L54.36|
00001c  2b00              CMP      r3,#0                 ;904
00001e  bf1c              ITT      NE                    ;906
000020  2001              MOVNE    r0,#1                 ;906
000022  bd70              POPNE    {r4-r6,pc}
                  |L54.36|
000024  2002              MOVS     r0,#2                 ;910
000026  6420              STR      r0,[r4,#0x40]         ;910
                  |L54.40|
000028  4834              LDR      r0,|L54.252|
00002a  4935              LDR      r1,|L54.256|
00002c  b135              CBZ      r5,|L54.60|
00002e  2d04              CMP      r5,#4                 ;913
000030  d014              BEQ      |L54.92|
000032  2d08              CMP      r5,#8                 ;913
000034  d022              BEQ      |L54.124|
000036  2d0c              CMP      r5,#0xc               ;913
000038  d030              BEQ      |L54.156|
00003a  e03f              B        |L54.188|
                  |L54.60|
00003c  6a62              LDR      r2,[r4,#0x24]         ;918
00003e  6410              STR      r0,[r2,#0x40]         ;921
000040  6a60              LDR      r0,[r4,#0x24]         ;921
000042  6501              STR      r1,[r0,#0x50]         ;924
000044  6821              LDR      r1,[r4,#0]            ;924
000046  6a60              LDR      r0,[r4,#0x24]         ;924
000048  f1010234          ADD      r2,r1,#0x34           ;924
00004c  4661              MOV      r1,r12                ;924
00004e  f7fffffe          BL       HAL_DMA_Start_IT
000052  6820              LDR      r0,[r4,#0]            ;927
000054  68c1              LDR      r1,[r0,#0xc]          ;927
000056  f4417100          ORR      r1,r1,#0x200          ;927
00005a  e02e              B        |L54.186|
                  |L54.92|
00005c  6aa2              LDR      r2,[r4,#0x28]         ;934
00005e  6410              STR      r0,[r2,#0x40]         ;937
000060  6aa0              LDR      r0,[r4,#0x28]         ;937
000062  6501              STR      r1,[r0,#0x50]         ;940
000064  6821              LDR      r1,[r4,#0]            ;940
000066  6aa0              LDR      r0,[r4,#0x28]         ;940
000068  f1010238          ADD      r2,r1,#0x38           ;940
00006c  4661              MOV      r1,r12                ;940
00006e  f7fffffe          BL       HAL_DMA_Start_IT
000072  6820              LDR      r0,[r4,#0]            ;943
000074  68c1              LDR      r1,[r0,#0xc]          ;943
000076  f4416180          ORR      r1,r1,#0x400          ;943
00007a  e01e              B        |L54.186|
                  |L54.124|
00007c  6ae2              LDR      r2,[r4,#0x2c]         ;950
00007e  6410              STR      r0,[r2,#0x40]         ;953
000080  6ae0              LDR      r0,[r4,#0x2c]         ;953
000082  6501              STR      r1,[r0,#0x50]         ;956
000084  6821              LDR      r1,[r4,#0]            ;956
000086  6ae0              LDR      r0,[r4,#0x2c]         ;956
000088  f101023c          ADD      r2,r1,#0x3c           ;956
00008c  4661              MOV      r1,r12                ;956
00008e  f7fffffe          BL       HAL_DMA_Start_IT
000092  6820              LDR      r0,[r4,#0]            ;959
000094  68c1              LDR      r1,[r0,#0xc]          ;959
000096  f4416100          ORR      r1,r1,#0x800          ;959
00009a  e00e              B        |L54.186|
                  |L54.156|
00009c  6b22              LDR      r2,[r4,#0x30]         ;966
00009e  6410              STR      r0,[r2,#0x40]         ;969
0000a0  6b20              LDR      r0,[r4,#0x30]         ;969
0000a2  6501              STR      r1,[r0,#0x50]         ;972
0000a4  6821              LDR      r1,[r4,#0]            ;972
0000a6  6b20              LDR      r0,[r4,#0x30]         ;972
0000a8  f1010240          ADD      r2,r1,#0x40           ;972
0000ac  4661              MOV      r1,r12                ;972
0000ae  f7fffffe          BL       HAL_DMA_Start_IT
0000b2  6820              LDR      r0,[r4,#0]            ;975
0000b4  68c1              LDR      r1,[r0,#0xc]          ;975
0000b6  f4415180          ORR      r1,r1,#0x1000         ;975
                  |L54.186|
0000ba  60c1              STR      r1,[r0,#0xc]          ;959
                  |L54.188|
0000bc  6820              LDR      r0,[r4,#0]            ;959
0000be  2101              MOVS     r1,#1                 ;959
0000c0  40a9              LSLS     r1,r1,r5              ;959
0000c2  6a02              LDR      r2,[r0,#0x20]         ;959
0000c4  438a              BICS     r2,r2,r1              ;959
0000c6  6202              STR      r2,[r0,#0x20]         ;959
0000c8  6a02              LDR      r2,[r0,#0x20]         ;959
0000ca  4311              ORRS     r1,r1,r2              ;959
0000cc  6201              STR      r1,[r0,#0x20]         ;959
0000ce  6820              LDR      r0,[r4,#0]            ;986
0000d0  f1a04180          SUB      r1,r0,#0x40000000     ;986
0000d4  f5b13180          SUBS     r1,r1,#0x10000        ;986
0000d8  bf1c              ITT      NE                    ;986
0000da  f1a04180          SUBNE    r1,r0,#0x40000000     ;986
0000de  f5b13182          SUBSNE   r1,r1,#0x10400        ;986
0000e2  d103              BNE      |L54.236|
0000e4  6c41              LDR      r1,[r0,#0x44]         ;989
0000e6  f4414100          ORR      r1,r1,#0x8000         ;989
0000ea  6441              STR      r1,[r0,#0x44]         ;989
                  |L54.236|
0000ec  6820              LDR      r0,[r4,#0]            ;993
0000ee  6801              LDR      r1,[r0,#0]            ;993
0000f0  f0410101          ORR      r1,r1,#1              ;993
0000f4  6001              STR      r1,[r0,#0]            ;993
0000f6  2000              MOVS     r0,#0                 ;996
0000f8  bd70              POP      {r4-r6,pc}
;;;998    
                          ENDP

0000fa  0000              DCW      0x0000
                  |L54.252|
                          DCD      TIM_DMADelayPulseCplt
                  |L54.256|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_OC_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_Start_IT PROC
;;;756      */
;;;757    HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
;;;758    {
;;;759      /* Check the parameters */
;;;760      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;761      
;;;762      switch (Channel)
000002  2900              CMP      r1,#0
;;;763      {
;;;764        case TIM_CHANNEL_1:
;;;765        {       
;;;766          /* Enable the TIM Capture/Compare 1 interrupt */
;;;767          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000004  bf04              ITT      EQ
000006  68d3              LDREQ    r3,[r2,#0xc]
000008  f0430302          ORREQ    r3,r3,#2
00000c  d011              BEQ      |L55.50|
00000e  2904              CMP      r1,#4                 ;762
;;;768        }
;;;769        break;
;;;770        
;;;771        case TIM_CHANNEL_2:
;;;772        {
;;;773          /* Enable the TIM Capture/Compare 2 interrupt */
;;;774          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000010  bf04              ITT      EQ
000012  68d3              LDREQ    r3,[r2,#0xc]
000014  f0430304          ORREQ    r3,r3,#4
000018  d00b              BEQ      |L55.50|
00001a  2908              CMP      r1,#8                 ;762
;;;775        }
;;;776        break;
;;;777        
;;;778        case TIM_CHANNEL_3:
;;;779        {
;;;780          /* Enable the TIM Capture/Compare 3 interrupt */
;;;781          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
00001c  bf04              ITT      EQ
00001e  68d3              LDREQ    r3,[r2,#0xc]
000020  f0430308          ORREQ    r3,r3,#8
000024  d005              BEQ      |L55.50|
000026  290c              CMP      r1,#0xc               ;762
;;;782        }
;;;783        break;
;;;784        
;;;785        case TIM_CHANNEL_4:
;;;786        {
;;;787          /* Enable the TIM Capture/Compare 4 interrupt */
;;;788          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000028  bf04              ITT      EQ
00002a  68d3              LDREQ    r3,[r2,#0xc]
00002c  f0430310          ORREQ    r3,r3,#0x10
000030  d100              BNE      |L55.52|
                  |L55.50|
000032  60d3              STR      r3,[r2,#0xc]          ;781
                  |L55.52|
000034  2301              MOVS     r3,#1                 ;781
000036  6802              LDR      r2,[r0,#0]            ;781
000038  fa03f101          LSL      r1,r3,r1              ;781
00003c  6a13              LDR      r3,[r2,#0x20]         ;781
00003e  438b              BICS     r3,r3,r1              ;781
000040  6213              STR      r3,[r2,#0x20]         ;781
000042  6a13              LDR      r3,[r2,#0x20]         ;781
000044  4319              ORRS     r1,r1,r3              ;781
000046  6211              STR      r1,[r2,#0x20]         ;781
;;;789        }
;;;790        break;
;;;791        
;;;792        default:
;;;793        break;
;;;794      } 
;;;795    
;;;796      /* Enable the Output compare channel */
;;;797      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;798      
;;;799      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000048  6801              LDR      r1,[r0,#0]
00004a  f1a14280          SUB      r2,r1,#0x40000000
00004e  f5b23280          SUBS     r2,r2,#0x10000
000052  bf1c              ITT      NE
000054  f1a14280          SUBNE    r2,r1,#0x40000000
000058  f5b23282          SUBSNE   r2,r2,#0x10400
00005c  d103              BNE      |L55.102|
;;;800      {
;;;801        /* Enable the main output */
;;;802        __HAL_TIM_MOE_ENABLE(htim);
00005e  6c4a              LDR      r2,[r1,#0x44]
000060  f4424200          ORR      r2,r2,#0x8000
000064  644a              STR      r2,[r1,#0x44]
                  |L55.102|
;;;803      }
;;;804    
;;;805      /* Enable the Peripheral */
;;;806      __HAL_TIM_ENABLE(htim);
000066  6800              LDR      r0,[r0,#0]
000068  6801              LDR      r1,[r0,#0]
00006a  f0410101          ORR      r1,r1,#1
00006e  6001              STR      r1,[r0,#0]
;;;807      
;;;808      /* Return function status */
;;;809      return HAL_OK;
000070  2000              MOVS     r0,#0
;;;810    }
000072  4770              BX       lr
;;;811    
                          ENDP


                          AREA ||i.HAL_TIM_OC_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_Stop PROC
;;;723      */
;;;724    HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  f84d4d04          PUSH.W   {r4}
;;;725    {
000004  6802              LDR      r2,[r0,#0]
;;;726      /* Check the parameters */
;;;727      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;728      
;;;729      /* Disable the Output compare channel */
;;;730      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000006  2300              MOVS     r3,#0
000008  f04f0c01          MOV      r12,#1
00000c  408b              LSLS     r3,r3,r1
00000e  6a14              LDR      r4,[r2,#0x20]
000010  fa0cf101          LSL      r1,r12,r1
000014  ea240101          BIC      r1,r4,r1
000018  6211              STR      r1,[r2,#0x20]
00001a  6a11              LDR      r1,[r2,#0x20]
00001c  4319              ORRS     r1,r1,r3
00001e  6211              STR      r1,[r2,#0x20]
;;;731      
;;;732      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000020  6801              LDR      r1,[r0,#0]
;;;733      {
;;;734        /* Disable the Main Output */
;;;735        __HAL_TIM_MOE_DISABLE(htim);
000022  f2411211          MOV      r2,#0x1111
000026  1093              ASRS     r3,r2,#2
000028  f1a14c80          SUB      r12,r1,#0x40000000    ;732
00002c  f5bc3c80          SUBS     r12,r12,#0x10000      ;732
000030  bf1c              ITT      NE                    ;732
000032  f1a14c80          SUBNE    r12,r1,#0x40000000    ;732
000036  f5bc3c82          SUBSNE   r12,r12,#0x10400      ;732
00003a  d10f              BNE      |L56.92|
00003c  f8d1c020          LDR      r12,[r1,#0x20]
000040  ea1c0f02          TST      r12,r2
000044  bf04              ITT      EQ
000046  f8d1c020          LDREQ    r12,[r1,#0x20]
00004a  ea1c0f03          TSTEQ    r12,r3
00004e  d105              BNE      |L56.92|
000050  f8d1c044          LDR      r12,[r1,#0x44]
000054  f42c4c00          BIC      r12,r12,#0x8000
000058  f8c1c044          STR      r12,[r1,#0x44]
                  |L56.92|
;;;736      }  
;;;737      
;;;738      /* Disable the Peripheral */
;;;739      __HAL_TIM_DISABLE(htim);  
00005c  6800              LDR      r0,[r0,#0]
00005e  6a01              LDR      r1,[r0,#0x20]
000060  4211              TST      r1,r2
000062  bf04              ITT      EQ
000064  6a01              LDREQ    r1,[r0,#0x20]
000066  4219              TSTEQ    r1,r3
000068  d103              BNE      |L56.114|
00006a  6801              LDR      r1,[r0,#0]
00006c  f0210101          BIC      r1,r1,#1
000070  6001              STR      r1,[r0,#0]
                  |L56.114|
;;;740      
;;;741      /* Return function status */
;;;742      return HAL_OK;
;;;743    }  
000072  f85d4b04          POP.W    {r4}
000076  2000              MOVS     r0,#0                 ;742
000078  4770              BX       lr
;;;744    
                          ENDP


                          AREA ||i.HAL_TIM_OC_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_Stop_DMA PROC
;;;1010     */
;;;1011   HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  f84d4d04          PUSH.W   {r4}
;;;1012   {
;;;1013     /* Check the parameters */
;;;1014     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1015     
;;;1016     switch (Channel)
000004  6802              LDR      r2,[r0,#0]
000006  2900              CMP      r1,#0
;;;1017     {
;;;1018       case TIM_CHANNEL_1:
;;;1019       {       
;;;1020         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1021         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000008  bf04              ITT      EQ
00000a  68d3              LDREQ    r3,[r2,#0xc]
00000c  f4237300          BICEQ    r3,r3,#0x200
000010  d011              BEQ      |L57.54|
000012  2904              CMP      r1,#4                 ;1016
;;;1022       }
;;;1023       break;
;;;1024       
;;;1025       case TIM_CHANNEL_2:
;;;1026       {
;;;1027         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1028         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000014  bf04              ITT      EQ
000016  68d3              LDREQ    r3,[r2,#0xc]
000018  f4236380          BICEQ    r3,r3,#0x400
00001c  d00b              BEQ      |L57.54|
00001e  2908              CMP      r1,#8                 ;1016
;;;1029       }
;;;1030       break;
;;;1031       
;;;1032       case TIM_CHANNEL_3:
;;;1033       {
;;;1034         /* Disable the TIM Capture/Compare 3 DMA request */
;;;1035         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
000020  bf04              ITT      EQ
000022  68d3              LDREQ    r3,[r2,#0xc]
000024  f4236300          BICEQ    r3,r3,#0x800
000028  d005              BEQ      |L57.54|
00002a  290c              CMP      r1,#0xc               ;1016
;;;1036       }
;;;1037       break;
;;;1038       
;;;1039       case TIM_CHANNEL_4:
;;;1040       {
;;;1041         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1042         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
00002c  bf04              ITT      EQ
00002e  68d3              LDREQ    r3,[r2,#0xc]
000030  f4235380          BICEQ    r3,r3,#0x1000
000034  d100              BNE      |L57.56|
                  |L57.54|
000036  60d3              STR      r3,[r2,#0xc]          ;1035
                  |L57.56|
;;;1043       }
;;;1044       break;
;;;1045       
;;;1046       default:
;;;1047       break;
;;;1048     } 
;;;1049     
;;;1050     /* Disable the Output compare channel */
;;;1051     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000038  f04f0c00          MOV      r12,#0
00003c  6802              LDR      r2,[r0,#0]
00003e  2301              MOVS     r3,#1
000040  fa0cfc01          LSL      r12,r12,r1
000044  6a14              LDR      r4,[r2,#0x20]
000046  fa03f101          LSL      r1,r3,r1
00004a  ea240101          BIC      r1,r4,r1
00004e  6211              STR      r1,[r2,#0x20]
000050  6a11              LDR      r1,[r2,#0x20]
000052  ea41010c          ORR      r1,r1,r12
000056  6211              STR      r1,[r2,#0x20]
;;;1052     
;;;1053     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000058  6801              LDR      r1,[r0,#0]
;;;1054     {
;;;1055       /* Disable the Main Output */
;;;1056       __HAL_TIM_MOE_DISABLE(htim);
00005a  f2411211          MOV      r2,#0x1111
00005e  f2404c44          MOV      r12,#0x444
000062  f1a14480          SUB      r4,r1,#0x40000000     ;1053
000066  f5b43480          SUBS     r4,r4,#0x10000        ;1053
00006a  bf1c              ITT      NE                    ;1053
00006c  f1a14480          SUBNE    r4,r1,#0x40000000     ;1053
000070  f5b43482          SUBSNE   r4,r4,#0x10400        ;1053
000074  d10a              BNE      |L57.140|
000076  6a0c              LDR      r4,[r1,#0x20]
000078  4214              TST      r4,r2
00007a  bf04              ITT      EQ
00007c  6a0c              LDREQ    r4,[r1,#0x20]
00007e  ea140f0c          TSTEQ    r4,r12
000082  d103              BNE      |L57.140|
000084  6c4c              LDR      r4,[r1,#0x44]
000086  f4244400          BIC      r4,r4,#0x8000
00008a  644c              STR      r4,[r1,#0x44]
                  |L57.140|
;;;1057     }
;;;1058     
;;;1059     /* Disable the Peripheral */
;;;1060     __HAL_TIM_DISABLE(htim);
00008c  6801              LDR      r1,[r0,#0]
00008e  6a0c              LDR      r4,[r1,#0x20]
000090  4214              TST      r4,r2
000092  bf04              ITT      EQ
000094  6a0a              LDREQ    r2,[r1,#0x20]
000096  ea120f0c          TSTEQ    r2,r12
00009a  d103              BNE      |L57.164|
00009c  680a              LDR      r2,[r1,#0]
00009e  f0220201          BIC      r2,r2,#1
0000a2  600a              STR      r2,[r1,#0]
                  |L57.164|
;;;1061     
;;;1062     /* Change the htim state */
;;;1063     htim->State = HAL_TIM_STATE_READY;
0000a4  6403              STR      r3,[r0,#0x40]
;;;1064     
;;;1065     /* Return function status */
;;;1066     return HAL_OK;
0000a6  2000              MOVS     r0,#0
;;;1067   }
0000a8  f85d4b04          POP.W    {r4}
0000ac  4770              BX       lr
;;;1068   
                          ENDP


                          AREA ||i.HAL_TIM_OC_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_Stop_IT PROC
;;;823      */
;;;824    HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  f84d4d04          PUSH.W   {r4}
;;;825    {
;;;826      /* Check the parameters */
;;;827      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;828      
;;;829      switch (Channel)
000004  6802              LDR      r2,[r0,#0]
000006  2900              CMP      r1,#0
;;;830      {
;;;831        case TIM_CHANNEL_1:
;;;832        {       
;;;833          /* Disable the TIM Capture/Compare 1 interrupt */
;;;834          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000008  bf04              ITT      EQ
00000a  68d3              LDREQ    r3,[r2,#0xc]
00000c  f0230302          BICEQ    r3,r3,#2
000010  d011              BEQ      |L58.54|
000012  2904              CMP      r1,#4                 ;829
;;;835        }
;;;836        break;
;;;837        
;;;838        case TIM_CHANNEL_2:
;;;839        {
;;;840          /* Disable the TIM Capture/Compare 2 interrupt */
;;;841          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000014  bf04              ITT      EQ
000016  68d3              LDREQ    r3,[r2,#0xc]
000018  f0230304          BICEQ    r3,r3,#4
00001c  d00b              BEQ      |L58.54|
00001e  2908              CMP      r1,#8                 ;829
;;;842        }
;;;843        break;
;;;844        
;;;845        case TIM_CHANNEL_3:
;;;846        {
;;;847          /* Disable the TIM Capture/Compare 3 interrupt */
;;;848          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
000020  bf04              ITT      EQ
000022  68d3              LDREQ    r3,[r2,#0xc]
000024  f0230308          BICEQ    r3,r3,#8
000028  d005              BEQ      |L58.54|
00002a  290c              CMP      r1,#0xc               ;829
;;;849        }
;;;850        break;
;;;851        
;;;852        case TIM_CHANNEL_4:
;;;853        {
;;;854          /* Disable the TIM Capture/Compare 4 interrupt */
;;;855          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
00002c  bf04              ITT      EQ
00002e  68d3              LDREQ    r3,[r2,#0xc]
000030  f0230310          BICEQ    r3,r3,#0x10
000034  d100              BNE      |L58.56|
                  |L58.54|
000036  60d3              STR      r3,[r2,#0xc]          ;848
                  |L58.56|
;;;856        }
;;;857        break;
;;;858        
;;;859        default:
;;;860        break; 
;;;861      } 
;;;862      
;;;863      /* Disable the Output compare channel */
;;;864      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE); 
000038  2300              MOVS     r3,#0
00003a  6802              LDR      r2,[r0,#0]
00003c  f04f0c01          MOV      r12,#1
000040  408b              LSLS     r3,r3,r1
000042  6a14              LDR      r4,[r2,#0x20]
000044  fa0cf101          LSL      r1,r12,r1
000048  ea240101          BIC      r1,r4,r1
00004c  6211              STR      r1,[r2,#0x20]
00004e  6a11              LDR      r1,[r2,#0x20]
000050  4319              ORRS     r1,r1,r3
000052  6211              STR      r1,[r2,#0x20]
;;;865      
;;;866      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000054  6801              LDR      r1,[r0,#0]
;;;867      {
;;;868        /* Disable the Main Output */
;;;869        __HAL_TIM_MOE_DISABLE(htim);
000056  f2411211          MOV      r2,#0x1111
00005a  1093              ASRS     r3,r2,#2
00005c  f1a14c80          SUB      r12,r1,#0x40000000    ;866
000060  f5bc3c80          SUBS     r12,r12,#0x10000      ;866
000064  bf1c              ITT      NE                    ;866
000066  f1a14c80          SUBNE    r12,r1,#0x40000000    ;866
00006a  f5bc3c82          SUBSNE   r12,r12,#0x10400      ;866
00006e  d10f              BNE      |L58.144|
000070  f8d1c020          LDR      r12,[r1,#0x20]
000074  ea1c0f02          TST      r12,r2
000078  bf04              ITT      EQ
00007a  f8d1c020          LDREQ    r12,[r1,#0x20]
00007e  ea1c0f03          TSTEQ    r12,r3
000082  d105              BNE      |L58.144|
000084  f8d1c044          LDR      r12,[r1,#0x44]
000088  f42c4c00          BIC      r12,r12,#0x8000
00008c  f8c1c044          STR      r12,[r1,#0x44]
                  |L58.144|
;;;870      }
;;;871      
;;;872      /* Disable the Peripheral */
;;;873      __HAL_TIM_DISABLE(htim);  
000090  6800              LDR      r0,[r0,#0]
000092  6a01              LDR      r1,[r0,#0x20]
000094  4211              TST      r1,r2
000096  bf04              ITT      EQ
000098  6a01              LDREQ    r1,[r0,#0x20]
00009a  4219              TSTEQ    r1,r3
00009c  d103              BNE      |L58.166|
00009e  6801              LDR      r1,[r0,#0]
0000a0  f0210101          BIC      r1,r1,#1
0000a4  6001              STR      r1,[r0,#0]
                  |L58.166|
;;;874      
;;;875      /* Return function status */
;;;876      return HAL_OK;
;;;877    }
0000a6  f85d4b04          POP.W    {r4}
0000aa  2000              MOVS     r0,#0                 ;876
0000ac  4770              BX       lr
;;;878    
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_ConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_ConfigChannel PROC
;;;3512     */
;;;3513   HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef* sConfig, uint32_t OutputChannel,  uint32_t InputChannel)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;3514   {
;;;3515     TIM_OC_InitTypeDef temp1;
;;;3516     
;;;3517     /* Check the parameters */
;;;3518     assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
;;;3519     assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
;;;3520   
;;;3521     if(OutputChannel != InputChannel)  
000004  429a              CMP      r2,r3
;;;3522     {
;;;3523       __HAL_LOCK(htim);
;;;3524     
;;;3525       htim->State = HAL_TIM_STATE_BUSY;
;;;3526   
;;;3527       /* Extract the Output compare configuration from sConfig structure */  
;;;3528       temp1.OCMode = sConfig->OCMode;
;;;3529       temp1.Pulse = sConfig->Pulse;
;;;3530       temp1.OCPolarity = sConfig->OCPolarity;
;;;3531       temp1.OCNPolarity = sConfig->OCNPolarity;
;;;3532       temp1.OCIdleState = sConfig->OCIdleState;
;;;3533       temp1.OCNIdleState = sConfig->OCNIdleState; 
;;;3534       
;;;3535       switch (OutputChannel)
;;;3536       {
;;;3537         case TIM_CHANNEL_1:
;;;3538         {
;;;3539           assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3540         
;;;3541           TIM_OC1_SetConfig(htim->Instance, &temp1); 
;;;3542         }
;;;3543         break;
;;;3544         case TIM_CHANNEL_2:
;;;3545         {
;;;3546           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3547         
;;;3548           TIM_OC2_SetConfig(htim->Instance, &temp1);
;;;3549         }
;;;3550         break;
;;;3551         default:
;;;3552         break;  
;;;3553       } 
;;;3554       switch (InputChannel)
;;;3555       {
;;;3556         case TIM_CHANNEL_1:
;;;3557         {
;;;3558           assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3559         
;;;3560           TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;3561                           sConfig->ICSelection, sConfig->ICFilter);
;;;3562                  
;;;3563           /* Reset the IC1PSC Bits */
;;;3564           htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;3565   
;;;3566           /* Select the Trigger source */
;;;3567           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;3568           htim->Instance->SMCR |= TIM_TS_TI1FP1;
;;;3569         
;;;3570           /* Select the Slave Mode */      
;;;3571           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3572           htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;3573         }
;;;3574         break;
;;;3575         case TIM_CHANNEL_2:
;;;3576         {
;;;3577           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3578         
;;;3579           TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;3580                    sConfig->ICSelection, sConfig->ICFilter);
;;;3581                  
;;;3582           /* Reset the IC2PSC Bits */
;;;3583           htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;3584   
;;;3585           /* Select the Trigger source */
;;;3586           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;3587           htim->Instance->SMCR |= TIM_TS_TI2FP2;
;;;3588         
;;;3589           /* Select the Slave Mode */      
;;;3590           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3591           htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;3592         }
;;;3593         break;
;;;3594       
;;;3595         default:
;;;3596         break;  
;;;3597       }
;;;3598     
;;;3599       htim->State = HAL_TIM_STATE_READY;
;;;3600       
;;;3601       __HAL_UNLOCK(htim);
;;;3602     
;;;3603       return HAL_OK;
;;;3604     }
;;;3605     else
;;;3606     {
;;;3607       return HAL_ERROR;
000006  bf04              ITT      EQ
000008  2001              MOVEQ    r0,#1
;;;3608     }
;;;3609   } 
00000a  e8bd8ff0          POPEQ    {r4-r11,pc}
00000e  f8d0c03c          LDR      r12,[r0,#0x3c]        ;3523
000012  f1bc0f01          CMP      r12,#1                ;3523
000016  bf04              ITT      EQ                    ;3523
000018  2002              MOVEQ    r0,#2                 ;3523
00001a  e8bd8ff0          POPEQ    {r4-r11,pc}
00001e  2402              MOVS     r4,#2                 ;3525
000020  f04f0c01          MOV      r12,#1                ;3523
000024  f8c0c03c          STR      r12,[r0,#0x3c]        ;3525
000028  6404              STR      r4,[r0,#0x40]         ;3525
00002a  e9d14500          LDRD     r4,r5,[r1,#0]         ;3525
00002e  e9d16702          LDRD     r6,r7,[r1,#8]         ;3525
000032  e9d18904          LDRD     r8,r9,[r1,#0x10]      ;3525
000036  f8dfa204          LDR      r10,|L59.572|
00003a  b112              CBZ      r2,|L59.66|
00003c  2a04              CMP      r2,#4                 ;3535
00003e  d02e              BEQ      |L59.158|
000040  e05c              B        |L59.252|
                  |L59.66|
000042  6802              LDR      r2,[r0,#0]            ;3535
000044  f8d2c020          LDR      r12,[r2,#0x20]        ;3535
000048  4552              CMP      r2,r10                ;3535
00004a  f02c0c01          BIC      r12,r12,#1            ;3535
00004e  f8c2c020          STR      r12,[r2,#0x20]        ;3535
000052  f8d2b020          LDR      r11,[r2,#0x20]        ;3535
000056  f8d2c004          LDR      r12,[r2,#4]           ;3535
00005a  f8d2e018          LDR      lr,[r2,#0x18]         ;3535
00005e  f02b0b02          BIC      r11,r11,#2            ;3535
000062  ea46060b          ORR      r6,r6,r11             ;3535
000066  f02e0e73          BIC      lr,lr,#0x73           ;3535
00006a  f42e3e80          BIC      lr,lr,#0x10000        ;3535
00006e  ea44040e          ORR      r4,r4,lr              ;3535
000072  bf1c              ITT      NE                    ;3535
000074  f1a24b80          SUBNE    r11,r2,#0x40000000    ;3535
000078  f5bb3b82          SUBSNE   r11,r11,#0x10400      ;3535
00007c  d10a              BNE      |L59.148|
00007e  f0260608          BIC      r6,r6,#8              ;3541
000082  f42c7c40          BIC      r12,r12,#0x300        ;3541
000086  433e              ORRS     r6,r6,r7              ;3541
000088  ea480c0c          ORR      r12,r8,r12            ;3541
00008c  ea490c0c          ORR      r12,r9,r12            ;3541
000090  f0260604          BIC      r6,r6,#4              ;3541
                  |L59.148|
000094  f8c2c004          STR      r12,[r2,#4]           ;3541
000098  6194              STR      r4,[r2,#0x18]         ;3541
00009a  6355              STR      r5,[r2,#0x34]         ;3541
00009c  e02d              B        |L59.250|
                  |L59.158|
00009e  6802              LDR      r2,[r0,#0]            ;3543
0000a0  f8d2c020          LDR      r12,[r2,#0x20]        ;3543
0000a4  4552              CMP      r2,r10                ;3543
0000a6  f02c0c10          BIC      r12,r12,#0x10         ;3543
0000aa  f8c2c020          STR      r12,[r2,#0x20]        ;3543
0000ae  f8d2b020          LDR      r11,[r2,#0x20]        ;3543
0000b2  f8d2c004          LDR      r12,[r2,#4]           ;3543
0000b6  f8d2e018          LDR      lr,[r2,#0x18]         ;3543
0000ba  f02b0b20          BIC      r11,r11,#0x20         ;3543
0000be  ea4b1606          ORR      r6,r11,r6,LSL #4      ;3543
0000c2  f42e4ee6          BIC      lr,lr,#0x7300         ;3543
0000c6  f02e7e80          BIC      lr,lr,#0x1000000      ;3543
0000ca  ea4e2404          ORR      r4,lr,r4,LSL #8       ;3543
0000ce  bf1c              ITT      NE                    ;3543
0000d0  f1a24b80          SUBNE    r11,r2,#0x40000000    ;3543
0000d4  f5bb3b82          SUBSNE   r11,r11,#0x10400      ;3543
0000d8  d10b              BNE      |L59.242|
0000da  f0260680          BIC      r6,r6,#0x80           ;3548
0000de  f42c6c40          BIC      r12,r12,#0xc00        ;3548
0000e2  ea461607          ORR      r6,r6,r7,LSL #4       ;3548
0000e6  ea4c0c88          ORR      r12,r12,r8,LSL #2     ;3548
0000ea  ea4c0c89          ORR      r12,r12,r9,LSL #2     ;3548
0000ee  f0260640          BIC      r6,r6,#0x40           ;3548
                  |L59.242|
0000f2  f8c2c004          STR      r12,[r2,#4]           ;3548
0000f6  6194              STR      r4,[r2,#0x18]         ;3548
0000f8  6395              STR      r5,[r2,#0x38]         ;3548
                  |L59.250|
0000fa  6216              STR      r6,[r2,#0x20]         ;3548
                  |L59.252|
0000fc  b113              CBZ      r3,|L59.260|
0000fe  2b04              CMP      r3,#4                 ;3554
000100  d05d              BEQ      |L59.446|
000102  e094              B        |L59.558|
                  |L59.260|
000104  6802              LDR      r2,[r0,#0]            ;3560
000106  698c              LDR      r4,[r1,#0x18]         ;3560
000108  e9d15307          LDRD     r5,r3,[r1,#0x1c]      ;3560
00010c  6a11              LDR      r1,[r2,#0x20]         ;3560
00010e  4552              CMP      r2,r10                ;3560
000110  f0210101          BIC      r1,r1,#1              ;3560
000114  6211              STR      r1,[r2,#0x20]         ;3560
000116  6991              LDR      r1,[r2,#0x18]         ;3560
000118  f8d2c020          LDR      r12,[r2,#0x20]        ;3560
00011c  bf18              IT       NE                    ;3560
00011e  f1b24f80          CMPNE    r2,#0x40000000        ;3560
000122  d01f              BEQ      |L59.356|
000124  f1a24680          SUB      r6,r2,#0x40000000     ;3560
000128  f5b66680          SUBS     r6,r6,#0x400          ;3560
00012c  bf1c              ITT      NE                    ;3560
00012e  f1a24680          SUBNE    r6,r2,#0x40000000     ;3560
000132  f5b66600          SUBSNE   r6,r6,#0x800          ;3560
000136  d015              BEQ      |L59.356|
000138  f1a24680          SUB      r6,r2,#0x40000000     ;3560
00013c  f5b66640          SUBS     r6,r6,#0xc00          ;3560
000140  bf1c              ITT      NE                    ;3560
000142  f1a24680          SUBNE    r6,r2,#0x40000000     ;3560
000146  f5b63682          SUBSNE   r6,r6,#0x10400        ;3560
00014a  d00b              BEQ      |L59.356|
00014c  f1a24680          SUB      r6,r2,#0x40000000     ;3560
000150  f5b636a0          SUBS     r6,r6,#0x14000        ;3560
000154  bf1e              ITTT     NE                    ;3560
000156  f1a24680          SUBNE    r6,r2,#0x40000000     ;3560
00015a  f5b656c0          SUBSNE   r6,r6,#0x1800         ;3560
00015e  f0410101          ORRNE    r1,r1,#1              ;3560
000162  d102              BNE      |L59.362|
                  |L59.356|
000164  f0210103          BIC      r1,r1,#3              ;3560
000168  4329              ORRS     r1,r1,r5              ;3560
                  |L59.362|
00016a  25f0              MOVS     r5,#0xf0              ;3560
00016c  ea051503          AND      r5,r5,r3,LSL #4       ;3560
000170  f02c030a          BIC      r3,r12,#0xa           ;3560
000174  f02101f0          BIC      r1,r1,#0xf0           ;3560
000178  f0040c0a          AND      r12,r4,#0xa           ;3560
00017c  4329              ORRS     r1,r1,r5              ;3560
00017e  6191              STR      r1,[r2,#0x18]         ;3560
000180  ea4c0303          ORR      r3,r12,r3             ;3560
000184  6213              STR      r3,[r2,#0x20]         ;3560
000186  6801              LDR      r1,[r0,#0]            ;3564
000188  698a              LDR      r2,[r1,#0x18]         ;3564
00018a  f022020c          BIC      r2,r2,#0xc            ;3564
00018e  618a              STR      r2,[r1,#0x18]         ;3564
000190  6801              LDR      r1,[r0,#0]            ;3567
000192  688a              LDR      r2,[r1,#8]            ;3567
000194  f0220270          BIC      r2,r2,#0x70           ;3567
000198  608a              STR      r2,[r1,#8]            ;3567
00019a  6801              LDR      r1,[r0,#0]            ;3568
00019c  688a              LDR      r2,[r1,#8]            ;3568
00019e  f0420250          ORR      r2,r2,#0x50           ;3568
0001a2  608a              STR      r2,[r1,#8]            ;3568
0001a4  6801              LDR      r1,[r0,#0]            ;3571
0001a6  688a              LDR      r2,[r1,#8]            ;3571
0001a8  f0220207          BIC      r2,r2,#7              ;3571
0001ac  f4223280          BIC      r2,r2,#0x10000        ;3571
0001b0  608a              STR      r2,[r1,#8]            ;3571
0001b2  6801              LDR      r1,[r0,#0]            ;3572
0001b4  688a              LDR      r2,[r1,#8]            ;3572
0001b6  f0420206          ORR      r2,r2,#6              ;3572
0001ba  608a              STR      r2,[r1,#8]            ;3572
0001bc  e037              B        |L59.558|
                  |L59.446|
0001be  6802              LDR      r2,[r0,#0]            ;3579
0001c0  e9d13c06          LDRD     r3,r12,[r1,#0x18]     ;3579
0001c4  6a09              LDR      r1,[r1,#0x20]         ;3579
0001c6  6a14              LDR      r4,[r2,#0x20]         ;3579
0001c8  f44f4570          MOV      r5,#0xf000            ;3579
0001cc  26a0              MOVS     r6,#0xa0              ;3579
0001ce  f0240410          BIC      r4,r4,#0x10           ;3579
0001d2  6214              STR      r4,[r2,#0x20]         ;3579
0001d4  ea053501          AND      r5,r5,r1,LSL #12      ;3579
0001d8  6991              LDR      r1,[r2,#0x18]         ;3579
0001da  6a14              LDR      r4,[r2,#0x20]         ;3579
0001dc  ea061603          AND      r6,r6,r3,LSL #4       ;3579
0001e0  f4217340          BIC      r3,r1,#0x300          ;3579
0001e4  f02401a0          BIC      r1,r4,#0xa0           ;3579
0001e8  ea43230c          ORR      r3,r3,r12,LSL #8      ;3579
0001ec  4331              ORRS     r1,r1,r6              ;3579
0001ee  f4234370          BIC      r3,r3,#0xf000         ;3579
0001f2  432b              ORRS     r3,r3,r5              ;3579
0001f4  6193              STR      r3,[r2,#0x18]         ;3579
0001f6  6211              STR      r1,[r2,#0x20]         ;3579
0001f8  6801              LDR      r1,[r0,#0]            ;3583
0001fa  698a              LDR      r2,[r1,#0x18]         ;3583
0001fc  f4226240          BIC      r2,r2,#0xc00          ;3583
000200  618a              STR      r2,[r1,#0x18]         ;3583
000202  6801              LDR      r1,[r0,#0]            ;3586
000204  688a              LDR      r2,[r1,#8]            ;3586
000206  f0220270          BIC      r2,r2,#0x70           ;3586
00020a  608a              STR      r2,[r1,#8]            ;3586
00020c  6801              LDR      r1,[r0,#0]            ;3587
00020e  688a              LDR      r2,[r1,#8]            ;3587
000210  f0420260          ORR      r2,r2,#0x60           ;3587
000214  608a              STR      r2,[r1,#8]            ;3587
000216  6801              LDR      r1,[r0,#0]            ;3590
000218  688a              LDR      r2,[r1,#8]            ;3590
00021a  f0220207          BIC      r2,r2,#7              ;3590
00021e  f4223280          BIC      r2,r2,#0x10000        ;3590
000222  608a              STR      r2,[r1,#8]            ;3590
000224  6801              LDR      r1,[r0,#0]            ;3591
000226  688a              LDR      r2,[r1,#8]            ;3591
000228  f0420206          ORR      r2,r2,#6              ;3591
00022c  608a              STR      r2,[r1,#8]            ;3591
                  |L59.558|
00022e  2101              MOVS     r1,#1                 ;3599
000230  6401              STR      r1,[r0,#0x40]         ;3599
000232  2200              MOVS     r2,#0                 ;3601
000234  63c2              STR      r2,[r0,#0x3c]         ;3603
000236  4610              MOV      r0,r2                 ;3603
000238  e8bd8ff0          POP      {r4-r11,pc}
;;;3610   
                          ENDP

                  |L59.572|
                          DCD      0x40010000

                          AREA ||i.HAL_TIM_OnePulse_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_DeInit PROC
;;;2207     */
;;;2208   HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;2209   {
000002  4604              MOV      r4,r0
;;;2210     /* Check the parameters */
;;;2211     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2212     
;;;2213     htim->State = HAL_TIM_STATE_BUSY;
;;;2214     
;;;2215     /* Disable the TIM Peripheral Clock */
;;;2216     __HAL_TIM_DISABLE(htim);
000004  f2411111          MOV      r1,#0x1111
000008  2002              MOVS     r0,#2                 ;2213
00000a  6420              STR      r0,[r4,#0x40]         ;2213
00000c  6820              LDR      r0,[r4,#0]
00000e  6a02              LDR      r2,[r0,#0x20]
000010  420a              TST      r2,r1
000012  d108              BNE      |L60.38|
000014  6a01              LDR      r1,[r0,#0x20]
000016  f2404244          MOV      r2,#0x444
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L60.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L60.38|
;;;2217   
;;;2218   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;2219     if(htim->OnePulse_MspDeInitCallback == NULL)
;;;2220     {
;;;2221       htim->OnePulse_MspDeInitCallback = HAL_TIM_OnePulse_MspDeInit;
;;;2222     }
;;;2223     /* DeInit the low level hardware */
;;;2224     htim->OnePulse_MspDeInitCallback(htim);
;;;2225   #else
;;;2226     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;2227     HAL_TIM_OnePulse_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_OnePulse_MspDeInit
;;;2228   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;2229   
;;;2230     /* Change TIM state */  
;;;2231     htim->State = HAL_TIM_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  6420              STR      r0,[r4,#0x40]
;;;2232   
;;;2233     /* Release Lock */
;;;2234     __HAL_UNLOCK(htim);
000030  63e0              STR      r0,[r4,#0x3c]
;;;2235   
;;;2236     return HAL_OK;
;;;2237   }
000032  bd10              POP      {r4,pc}
;;;2238   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_GetState PROC
;;;5278     */
;;;5279   HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
000000  6c00              LDR      r0,[r0,#0x40]
;;;5280   {
;;;5281     return htim->State;
;;;5282   }
000002  4770              BX       lr
;;;5283   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_Init PROC
;;;2147     */
;;;2148   HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
000000  2800              CMP      r0,#0
;;;2149   {
;;;2150     /* Check the TIM handle allocation */
;;;2151     if(htim == NULL)
;;;2152     {
;;;2153       return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;2154     }
;;;2155   
;;;2156     /* Check the parameters */
;;;2157     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2158     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;2159     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;2160     assert_param(IS_TIM_OPM_MODE(OnePulseMode));
;;;2161     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;2162   
;;;2163     if(htim->State == HAL_TIM_STATE_RESET)
;;;2164     {
;;;2165       /* Allocate lock resource and initialize it */
;;;2166       htim->Lock = HAL_UNLOCKED;
;;;2167   
;;;2168   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;2169       /* Reset interrupt callbacks to legacy week callbacks */
;;;2170       TIM_ResetCallback(htim);
;;;2171   
;;;2172       if(htim->OnePulse_MspDeInitCallback == NULL)
;;;2173       {
;;;2174         htim->OnePulse_MspDeInitCallback = HAL_TIM_OnePulse_MspInit;
;;;2175       }
;;;2176       /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;2177       htim->OnePulse_MspDeInitCallback(htim);
;;;2178   #else
;;;2179       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;2180       HAL_TIM_OnePulse_MspInit(htim);
;;;2181   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;2182     }
;;;2183   
;;;2184     /* Set the TIM state */
;;;2185     htim->State= HAL_TIM_STATE_BUSY;  
;;;2186     
;;;2187     /* Configure the Time base in the One Pulse Mode */
;;;2188     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;2189     
;;;2190     /* Reset the OPM Bit */
;;;2191     htim->Instance->CR1 &= ~TIM_CR1_OPM;
;;;2192   
;;;2193     /* Configure the OPM Mode */
;;;2194     htim->Instance->CR1 |= OnePulseMode;
;;;2195      
;;;2196     /* Initialize the TIM state*/
;;;2197     htim->State= HAL_TIM_STATE_READY;
;;;2198     
;;;2199     return HAL_OK;
;;;2200   }
000006  4770              BXEQ     lr
000008  b570              PUSH     {r4-r6,lr}            ;2149
00000a  4604              MOV      r4,r0                 ;2149
00000c  6c00              LDR      r0,[r0,#0x40]         ;2163
00000e  460d              MOV      r5,r1                 ;2149
000010  b920              CBNZ     r0,|L62.28|
000012  2000              MOVS     r0,#0                 ;2166
000014  63e0              STR      r0,[r4,#0x3c]         ;2180
000016  4620              MOV      r0,r4                 ;2180
000018  f7fffffe          BL       HAL_TIM_OnePulse_MspInit
                  |L62.28|
00001c  2002              MOVS     r0,#2                 ;2185
00001e  6420              STR      r0,[r4,#0x40]         ;2185
000020  6820              LDR      r0,[r4,#0]            ;2188
000022  1d21              ADDS     r1,r4,#4              ;2188
000024  f7fffffe          BL       TIM_Base_SetConfig
000028  6820              LDR      r0,[r4,#0]            ;2191
00002a  2101              MOVS     r1,#1                 ;2197
00002c  6802              LDR      r2,[r0,#0]            ;2191
00002e  f0220208          BIC      r2,r2,#8              ;2191
000032  6002              STR      r2,[r0,#0]            ;2191
000034  6820              LDR      r0,[r4,#0]            ;2194
000036  6802              LDR      r2,[r0,#0]            ;2194
000038  432a              ORRS     r2,r2,r5              ;2194
00003a  6002              STR      r2,[r0,#0]            ;2194
00003c  6421              STR      r1,[r4,#0x40]         ;2197
00003e  2000              MOVS     r0,#0                 ;2199
000040  bd70              POP      {r4-r6,pc}
;;;2201   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_MspDeInit PROC
;;;2260     */
;;;2261   __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2262   {
;;;2263     /* Prevent unused argument(s) compilation warning */
;;;2264     UNUSED(htim);
;;;2265    
;;;2266     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2267               the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
;;;2268      */
;;;2269   }
;;;2270   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_MspInit PROC
;;;2244     */
;;;2245   __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2246   {
;;;2247     /* Prevent unused argument(s) compilation warning */
;;;2248     UNUSED(htim);
;;;2249    
;;;2250     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2251               the HAL_TIM_OnePulse_MspInit could be implemented in the user file
;;;2252      */
;;;2253   }
;;;2254   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_Start PROC
;;;2280     */
;;;2281   HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  6801              LDR      r1,[r0,#0]
000002  6a0a              LDR      r2,[r1,#0x20]
000004  f0220201          BIC      r2,r2,#1
000008  620a              STR      r2,[r1,#0x20]
00000a  6a0a              LDR      r2,[r1,#0x20]
00000c  f0420201          ORR      r2,r2,#1
000010  620a              STR      r2,[r1,#0x20]
000012  6801              LDR      r1,[r0,#0]
000014  6a0a              LDR      r2,[r1,#0x20]
000016  f0220210          BIC      r2,r2,#0x10
00001a  620a              STR      r2,[r1,#0x20]
00001c  6a0a              LDR      r2,[r1,#0x20]
00001e  f0420210          ORR      r2,r2,#0x10
000022  620a              STR      r2,[r1,#0x20]
;;;2282   {
;;;2283     /* Prevent unused argument(s) compilation warning */
;;;2284     UNUSED(OutputChannel);
;;;2285   
;;;2286     /* Enable the Capture compare and the Input Capture channels 
;;;2287       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2288       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2289       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2290       in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
;;;2291       
;;;2292       No need to enable the counter, it's enabled automatically by hardware 
;;;2293       (the counter starts in response to a stimulus and generate a pulse */
;;;2294     
;;;2295     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
;;;2296     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
;;;2297     
;;;2298     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000024  6800              LDR      r0,[r0,#0]
000026  f1a04180          SUB      r1,r0,#0x40000000
00002a  f5b13180          SUBS     r1,r1,#0x10000
00002e  bf1c              ITT      NE
000030  f1a04180          SUBNE    r1,r0,#0x40000000
000034  f5b13182          SUBSNE   r1,r1,#0x10400
000038  d103              BNE      |L65.66|
;;;2299     {
;;;2300       /* Enable the main output */
;;;2301       __HAL_TIM_MOE_ENABLE(htim);
00003a  6c41              LDR      r1,[r0,#0x44]
00003c  f4414100          ORR      r1,r1,#0x8000
000040  6441              STR      r1,[r0,#0x44]
                  |L65.66|
;;;2302     }
;;;2303     
;;;2304     /* Return function status */
;;;2305     return HAL_OK;
000042  2000              MOVS     r0,#0
;;;2306   }
000044  4770              BX       lr
;;;2307   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_Start_IT PROC
;;;2354     */
;;;2355   HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  6801              LDR      r1,[r0,#0]
;;;2356   {
;;;2357     /* Enable the Capture compare and the Input Capture channels 
;;;2358       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2359       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2360       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2361       in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
;;;2362       
;;;2363       No need to enable the counter, it's enabled automatically by hardware 
;;;2364       (the counter starts in response to a stimulus and generate a pulse */
;;;2365   
;;;2366     /* Prevent unused argument(s) compilation warning */
;;;2367     UNUSED(OutputChannel);
;;;2368   
;;;2369     /* Enable the TIM Capture/Compare 1 interrupt */
;;;2370     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000002  68ca              LDR      r2,[r1,#0xc]
000004  f0420202          ORR      r2,r2,#2
000008  60ca              STR      r2,[r1,#0xc]
;;;2371     
;;;2372     /* Enable the TIM Capture/Compare 2 interrupt */
;;;2373     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00000a  6801              LDR      r1,[r0,#0]
00000c  68ca              LDR      r2,[r1,#0xc]
00000e  f0420204          ORR      r2,r2,#4
000012  60ca              STR      r2,[r1,#0xc]
000014  6801              LDR      r1,[r0,#0]
000016  6a0a              LDR      r2,[r1,#0x20]
000018  f0220201          BIC      r2,r2,#1
00001c  620a              STR      r2,[r1,#0x20]
00001e  6a0a              LDR      r2,[r1,#0x20]
000020  f0420201          ORR      r2,r2,#1
000024  620a              STR      r2,[r1,#0x20]
000026  6801              LDR      r1,[r0,#0]
000028  6a0a              LDR      r2,[r1,#0x20]
00002a  f0220210          BIC      r2,r2,#0x10
00002e  620a              STR      r2,[r1,#0x20]
000030  6a0a              LDR      r2,[r1,#0x20]
000032  f0420210          ORR      r2,r2,#0x10
000036  620a              STR      r2,[r1,#0x20]
;;;2374     
;;;2375     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
;;;2376     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
;;;2377     
;;;2378     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000038  6800              LDR      r0,[r0,#0]
00003a  f1a04180          SUB      r1,r0,#0x40000000
00003e  f5b13180          SUBS     r1,r1,#0x10000
000042  bf1c              ITT      NE
000044  f1a04180          SUBNE    r1,r0,#0x40000000
000048  f5b13182          SUBSNE   r1,r1,#0x10400
00004c  d103              BNE      |L66.86|
;;;2379     {
;;;2380       /* Enable the main output */
;;;2381       __HAL_TIM_MOE_ENABLE(htim);
00004e  6c41              LDR      r1,[r0,#0x44]
000050  f4414100          ORR      r1,r1,#0x8000
000054  6441              STR      r1,[r0,#0x44]
                  |L66.86|
;;;2382     }
;;;2383     
;;;2384     /* Return function status */
;;;2385     return HAL_OK;
000056  2000              MOVS     r0,#0
;;;2386   }
000058  4770              BX       lr
;;;2387   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_Stop PROC
;;;2317     */
;;;2318   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  6801              LDR      r1,[r0,#0]
000002  6a0a              LDR      r2,[r1,#0x20]
000004  f0220201          BIC      r2,r2,#1
000008  620a              STR      r2,[r1,#0x20]
00000a  6a0a              LDR      r2,[r1,#0x20]
00000c  620a              STR      r2,[r1,#0x20]
00000e  6801              LDR      r1,[r0,#0]
000010  6a0a              LDR      r2,[r1,#0x20]
000012  f0220210          BIC      r2,r2,#0x10
000016  620a              STR      r2,[r1,#0x20]
000018  6a0a              LDR      r2,[r1,#0x20]
00001a  620a              STR      r2,[r1,#0x20]
;;;2319   {
;;;2320     /* Prevent unused argument(s) compilation warning */
;;;2321     UNUSED(OutputChannel);
;;;2322   
;;;2323     /* Disable the Capture compare and the Input Capture channels 
;;;2324     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2325     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2326     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2327     in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
;;;2328     
;;;2329     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
;;;2330     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
;;;2331       
;;;2332     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
;;;2333     {
;;;2334       /* Disable the Main Output */
;;;2335       __HAL_TIM_MOE_DISABLE(htim);
00001c  f2411211          MOV      r2,#0x1111
000020  6801              LDR      r1,[r0,#0]            ;2332
000022  1093              ASRS     r3,r2,#2
000024  f1a14c80          SUB      r12,r1,#0x40000000    ;2332
000028  f5bc3c80          SUBS     r12,r12,#0x10000      ;2332
00002c  bf1c              ITT      NE                    ;2332
00002e  f1a14c80          SUBNE    r12,r1,#0x40000000    ;2332
000032  f5bc3c82          SUBSNE   r12,r12,#0x10400      ;2332
000036  d10f              BNE      |L67.88|
000038  f8d1c020          LDR      r12,[r1,#0x20]
00003c  ea1c0f02          TST      r12,r2
000040  bf04              ITT      EQ
000042  f8d1c020          LDREQ    r12,[r1,#0x20]
000046  ea1c0f03          TSTEQ    r12,r3
00004a  d105              BNE      |L67.88|
00004c  f8d1c044          LDR      r12,[r1,#0x44]
000050  f42c4c00          BIC      r12,r12,#0x8000
000054  f8c1c044          STR      r12,[r1,#0x44]
                  |L67.88|
;;;2336     }
;;;2337       
;;;2338     /* Disable the Peripheral */
;;;2339     __HAL_TIM_DISABLE(htim); 
000058  6800              LDR      r0,[r0,#0]
00005a  6a01              LDR      r1,[r0,#0x20]
00005c  4211              TST      r1,r2
00005e  bf04              ITT      EQ
000060  6a01              LDREQ    r1,[r0,#0x20]
000062  4219              TSTEQ    r1,r3
000064  d103              BNE      |L67.110|
000066  6801              LDR      r1,[r0,#0]
000068  f0210101          BIC      r1,r1,#1
00006c  6001              STR      r1,[r0,#0]
                  |L67.110|
;;;2340     
;;;2341     /* Return function status */
;;;2342     return HAL_OK;
00006e  2000              MOVS     r0,#0
;;;2343   }
000070  4770              BX       lr
;;;2344   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_Stop_IT PROC
;;;2397     */
;;;2398   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  6801              LDR      r1,[r0,#0]
;;;2399   {
;;;2400     /* Prevent unused argument(s) compilation warning */
;;;2401     UNUSED(OutputChannel);
;;;2402     
;;;2403     /* Disable the TIM Capture/Compare 1 interrupt */
;;;2404     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);  
000002  68ca              LDR      r2,[r1,#0xc]
000004  f0220202          BIC      r2,r2,#2
000008  60ca              STR      r2,[r1,#0xc]
;;;2405     
;;;2406     /* Disable the TIM Capture/Compare 2 interrupt */
;;;2407     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00000a  6801              LDR      r1,[r0,#0]
00000c  68ca              LDR      r2,[r1,#0xc]
00000e  f0220204          BIC      r2,r2,#4
000012  60ca              STR      r2,[r1,#0xc]
000014  6801              LDR      r1,[r0,#0]
000016  6a0a              LDR      r2,[r1,#0x20]
000018  f0220201          BIC      r2,r2,#1
00001c  620a              STR      r2,[r1,#0x20]
00001e  6a0a              LDR      r2,[r1,#0x20]
000020  620a              STR      r2,[r1,#0x20]
000022  6801              LDR      r1,[r0,#0]
000024  6a0a              LDR      r2,[r1,#0x20]
000026  f0220210          BIC      r2,r2,#0x10
00002a  620a              STR      r2,[r1,#0x20]
00002c  6a0a              LDR      r2,[r1,#0x20]
00002e  620a              STR      r2,[r1,#0x20]
;;;2408     
;;;2409     /* Disable the Capture compare and the Input Capture channels 
;;;2410     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2411     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2412     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2413     in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */  
;;;2414     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
;;;2415     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
;;;2416       
;;;2417     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
;;;2418     {
;;;2419       /* Disable the Main Output */
;;;2420       __HAL_TIM_MOE_DISABLE(htim);
000030  f2411211          MOV      r2,#0x1111
000034  6801              LDR      r1,[r0,#0]            ;2417
000036  1093              ASRS     r3,r2,#2
000038  f1a14c80          SUB      r12,r1,#0x40000000    ;2417
00003c  f5bc3c80          SUBS     r12,r12,#0x10000      ;2417
000040  bf1c              ITT      NE                    ;2417
000042  f1a14c80          SUBNE    r12,r1,#0x40000000    ;2417
000046  f5bc3c82          SUBSNE   r12,r12,#0x10400      ;2417
00004a  d10f              BNE      |L68.108|
00004c  f8d1c020          LDR      r12,[r1,#0x20]
000050  ea1c0f02          TST      r12,r2
000054  bf04              ITT      EQ
000056  f8d1c020          LDREQ    r12,[r1,#0x20]
00005a  ea1c0f03          TSTEQ    r12,r3
00005e  d105              BNE      |L68.108|
000060  f8d1c044          LDR      r12,[r1,#0x44]
000064  f42c4c00          BIC      r12,r12,#0x8000
000068  f8c1c044          STR      r12,[r1,#0x44]
                  |L68.108|
;;;2421     }
;;;2422       
;;;2423     /* Disable the Peripheral */
;;;2424      __HAL_TIM_DISABLE(htim);  
00006c  6800              LDR      r0,[r0,#0]
00006e  6a01              LDR      r1,[r0,#0x20]
000070  4211              TST      r1,r2
000072  bf04              ITT      EQ
000074  6a01              LDREQ    r1,[r0,#0x20]
000076  4219              TSTEQ    r1,r3
000078  d103              BNE      |L68.130|
00007a  6801              LDR      r1,[r0,#0]
00007c  f0210101          BIC      r1,r1,#1
000080  6001              STR      r1,[r0,#0]
                  |L68.130|
;;;2425     
;;;2426     /* Return function status */
;;;2427     return HAL_OK;
000082  2000              MOVS     r0,#0
;;;2428   }
000084  4770              BX       lr
;;;2429   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_ConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_ConfigChannel PROC
;;;3411     */
;;;3412   __weak HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
000000  6bc3              LDR      r3,[r0,#0x3c]
;;;3413   {
;;;3414     __HAL_LOCK(htim);
000002  2b01              CMP      r3,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;3415     
;;;3416     /* Check the parameters */ 
;;;3417     assert_param(IS_TIM_CHANNELS(Channel)); 
;;;3418     assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
;;;3419     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;3420     assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode)); 
;;;3421     
;;;3422     htim->State = HAL_TIM_STATE_BUSY;
;;;3423       
;;;3424     switch (Channel)
;;;3425     {
;;;3426       case TIM_CHANNEL_1:
;;;3427       {
;;;3428         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3429         /* Configure the Channel 1 in PWM mode */
;;;3430         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;3431         
;;;3432         /* Set the Preload enable bit for channel1 */
;;;3433         htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
;;;3434         
;;;3435         /* Configure the Output Fast mode */
;;;3436         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
;;;3437         htim->Instance->CCMR1 |= sConfig->OCFastMode;
;;;3438       }
;;;3439       break;
;;;3440       
;;;3441       case TIM_CHANNEL_2:
;;;3442       {
;;;3443         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3444         /* Configure the Channel 2 in PWM mode */
;;;3445         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;3446         
;;;3447         /* Set the Preload enable bit for channel2 */
;;;3448         htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
;;;3449         
;;;3450         /* Configure the Output Fast mode */
;;;3451         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
;;;3452         htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
;;;3453       }
;;;3454       break;
;;;3455       
;;;3456       case TIM_CHANNEL_3:
;;;3457       {
;;;3458         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3459         /* Configure the Channel 3 in PWM mode */
;;;3460         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;3461         
;;;3462         /* Set the Preload enable bit for channel3 */
;;;3463         htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
;;;3464         
;;;3465        /* Configure the Output Fast mode */
;;;3466         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
;;;3467         htim->Instance->CCMR2 |= sConfig->OCFastMode;  
;;;3468       }
;;;3469       break;
;;;3470       
;;;3471       case TIM_CHANNEL_4:
;;;3472       {
;;;3473         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3474         /* Configure the Channel 4 in PWM mode */
;;;3475         TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;3476         
;;;3477         /* Set the Preload enable bit for channel4 */
;;;3478         htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
;;;3479         
;;;3480        /* Configure the Output Fast mode */
;;;3481         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
;;;3482         htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;  
;;;3483       }
;;;3484       break;
;;;3485       
;;;3486       default:
;;;3487       break;    
;;;3488     }
;;;3489     
;;;3490     htim->State = HAL_TIM_STATE_READY;
;;;3491       
;;;3492     __HAL_UNLOCK(htim);
;;;3493     
;;;3494     return HAL_OK;
;;;3495   }
000008  4770              BXEQ     lr
00000a  e92d03f0          PUSH     {r4-r9}               ;3413
00000e  2401              MOVS     r4,#1                 ;3414
000010  63c4              STR      r4,[r0,#0x3c]         ;3422
000012  2302              MOVS     r3,#2                 ;3422
000014  6403              STR      r3,[r0,#0x40]         ;3422
000016  4b82              LDR      r3,|L69.544|
000018  f8dfc208          LDR      r12,|L69.548|
00001c  b13a              CBZ      r2,|L69.46|
00001e  2a04              CMP      r2,#4                 ;3424
000020  d044              BEQ      |L69.172|
000022  2a08              CMP      r2,#8                 ;3424
000024  d07e              BEQ      |L69.292|
000026  2a0c              CMP      r2,#0xc               ;3424
000028  d07d              BEQ      |L69.294|
00002a  f000b8f2          B.W      |L69.530|
                  |L69.46|
00002e  6802              LDR      r2,[r0,#0]            ;3424
000030  6a15              LDR      r5,[r2,#0x20]         ;3424
000032  429a              CMP      r2,r3                 ;3424
000034  f0250301          BIC      r3,r5,#1              ;3424
000038  6213              STR      r3,[r2,#0x20]         ;3424
00003a  6a15              LDR      r5,[r2,#0x20]         ;3424
00003c  6853              LDR      r3,[r2,#4]            ;3424
00003e  6996              LDR      r6,[r2,#0x18]         ;3424
000040  f0250502          BIC      r5,r5,#2              ;3424
000044  f8d18008          LDR      r8,[r1,#8]            ;3424
000048  680f              LDR      r7,[r1,#0]            ;3424
00004a  f0260673          BIC      r6,r6,#0x73           ;3424
00004e  f4263680          BIC      r6,r6,#0x10000        ;3424
000052  ea480505          ORR      r5,r8,r5              ;3424
000056  ea470606          ORR      r6,r7,r6              ;3424
00005a  bf18              IT       NE                    ;3424
00005c  4562              CMPNE    r2,r12                ;3424
00005e  d111              BNE      |L69.132|
000060  f4237c80          BIC      r12,r3,#0x100         ;3430
000064  f8d1900c          LDR      r9,[r1,#0xc]          ;3430
000068  f0250308          BIC      r3,r5,#8              ;3430
00006c  e9d17805          LDRD     r7,r8,[r1,#0x14]      ;3430
000070  f42c7500          BIC      r5,r12,#0x200         ;3430
000074  ea490c03          ORR      r12,r9,r3             ;3430
000078  ea470305          ORR      r3,r7,r5              ;3430
00007c  f02c0504          BIC      r5,r12,#4             ;3430
000080  ea480303          ORR      r3,r8,r3              ;3430
                  |L69.132|
000084  6053              STR      r3,[r2,#4]            ;3430
000086  6196              STR      r6,[r2,#0x18]         ;3430
000088  684b              LDR      r3,[r1,#4]            ;3430
00008a  6353              STR      r3,[r2,#0x34]         ;3430
00008c  6215              STR      r5,[r2,#0x20]         ;3430
00008e  6802              LDR      r2,[r0,#0]            ;3433
000090  6993              LDR      r3,[r2,#0x18]         ;3433
000092  f0430308          ORR      r3,r3,#8              ;3433
000096  6193              STR      r3,[r2,#0x18]         ;3433
000098  6802              LDR      r2,[r0,#0]            ;3436
00009a  6993              LDR      r3,[r2,#0x18]         ;3436
00009c  f0230304          BIC      r3,r3,#4              ;3436
0000a0  6193              STR      r3,[r2,#0x18]         ;3436
0000a2  6802              LDR      r2,[r0,#0]            ;3437
0000a4  6909              LDR      r1,[r1,#0x10]         ;3437
0000a6  6993              LDR      r3,[r2,#0x18]         ;3437
0000a8  4319              ORRS     r1,r1,r3              ;3437
0000aa  e03f              B        |L69.300|
                  |L69.172|
0000ac  6802              LDR      r2,[r0,#0]            ;3439
0000ae  6a15              LDR      r5,[r2,#0x20]         ;3439
0000b0  429a              CMP      r2,r3                 ;3439
0000b2  f0250310          BIC      r3,r5,#0x10           ;3439
0000b6  6213              STR      r3,[r2,#0x20]         ;3439
0000b8  6a15              LDR      r5,[r2,#0x20]         ;3439
0000ba  6853              LDR      r3,[r2,#4]            ;3439
0000bc  6996              LDR      r6,[r2,#0x18]         ;3439
0000be  f0250520          BIC      r5,r5,#0x20           ;3439
0000c2  f8d18008          LDR      r8,[r1,#8]            ;3439
0000c6  680f              LDR      r7,[r1,#0]            ;3439
0000c8  f42646e6          BIC      r6,r6,#0x7300         ;3439
0000cc  f0267680          BIC      r6,r6,#0x1000000      ;3439
0000d0  ea451508          ORR      r5,r5,r8,LSL #4       ;3439
0000d4  ea462607          ORR      r6,r6,r7,LSL #8       ;3439
0000d8  bf18              IT       NE                    ;3439
0000da  4562              CMPNE    r2,r12                ;3439
0000dc  d10f              BNE      |L69.254|
0000de  f8d1900c          LDR      r9,[r1,#0xc]          ;3445
0000e2  f0250c80          BIC      r12,r5,#0x80          ;3445
0000e6  e9d17805          LDRD     r7,r8,[r1,#0x14]      ;3445
0000ea  f4236540          BIC      r5,r3,#0xc00          ;3445
0000ee  ea4c1309          ORR      r3,r12,r9,LSL #4      ;3445
0000f2  ea450c87          ORR      r12,r5,r7,LSL #2      ;3445
0000f6  f0230540          BIC      r5,r3,#0x40           ;3445
0000fa  ea4c0388          ORR      r3,r12,r8,LSL #2      ;3445
                  |L69.254|
0000fe  6053              STR      r3,[r2,#4]            ;3445
000100  6196              STR      r6,[r2,#0x18]         ;3445
000102  684b              LDR      r3,[r1,#4]            ;3445
000104  6393              STR      r3,[r2,#0x38]         ;3445
000106  6215              STR      r5,[r2,#0x20]         ;3445
000108  6802              LDR      r2,[r0,#0]            ;3448
00010a  6993              LDR      r3,[r2,#0x18]         ;3448
00010c  f4436300          ORR      r3,r3,#0x800          ;3448
000110  6193              STR      r3,[r2,#0x18]         ;3448
000112  6802              LDR      r2,[r0,#0]            ;3451
000114  6993              LDR      r3,[r2,#0x18]         ;3451
000116  f4236380          BIC      r3,r3,#0x400          ;3451
00011a  6193              STR      r3,[r2,#0x18]         ;3451
00011c  6802              LDR      r2,[r0,#0]            ;3452
00011e  6909              LDR      r1,[r1,#0x10]         ;3452
000120  6993              LDR      r3,[r2,#0x18]         ;3452
000122  e001              B        |L69.296|
                  |L69.292|
000124  e004              B        |L69.304|
                  |L69.294|
000126  e040              B        |L69.426|
                  |L69.296|
000128  ea432101          ORR      r1,r3,r1,LSL #8       ;3452
                  |L69.300|
00012c  6191              STR      r1,[r2,#0x18]         ;3437
00012e  e070              B        |L69.530|
                  |L69.304|
000130  6802              LDR      r2,[r0,#0]            ;3437
000132  6a15              LDR      r5,[r2,#0x20]         ;3437
000134  429a              CMP      r2,r3                 ;3437
000136  f4257380          BIC      r3,r5,#0x100          ;3437
00013a  6213              STR      r3,[r2,#0x20]         ;3437
00013c  6a15              LDR      r5,[r2,#0x20]         ;3437
00013e  6853              LDR      r3,[r2,#4]            ;3437
000140  69d6              LDR      r6,[r2,#0x1c]         ;3437
000142  f4257500          BIC      r5,r5,#0x200          ;3437
000146  f8d18008          LDR      r8,[r1,#8]            ;3437
00014a  680f              LDR      r7,[r1,#0]            ;3437
00014c  f0260673          BIC      r6,r6,#0x73           ;3437
000150  f4263680          BIC      r6,r6,#0x10000        ;3437
000154  ea452508          ORR      r5,r5,r8,LSL #8       ;3437
000158  ea470606          ORR      r6,r7,r6              ;3437
00015c  bf18              IT       NE                    ;3437
00015e  4562              CMPNE    r2,r12                ;3437
000160  d10f              BNE      |L69.386|
000162  f8d1900c          LDR      r9,[r1,#0xc]          ;3460
000166  f4256c00          BIC      r12,r5,#0x800         ;3460
00016a  e9d17805          LDRD     r7,r8,[r1,#0x14]      ;3460
00016e  f4235340          BIC      r3,r3,#0x3000         ;3460
000172  ea4c2c09          ORR      r12,r12,r9,LSL #8     ;3460
000176  ea431307          ORR      r3,r3,r7,LSL #4       ;3460
00017a  f42c6580          BIC      r5,r12,#0x400         ;3460
00017e  ea431308          ORR      r3,r3,r8,LSL #4       ;3460
                  |L69.386|
000182  6053              STR      r3,[r2,#4]            ;3460
000184  61d6              STR      r6,[r2,#0x1c]         ;3460
000186  684b              LDR      r3,[r1,#4]            ;3460
000188  63d3              STR      r3,[r2,#0x3c]         ;3460
00018a  6215              STR      r5,[r2,#0x20]         ;3460
00018c  6802              LDR      r2,[r0,#0]            ;3463
00018e  69d3              LDR      r3,[r2,#0x1c]         ;3463
000190  f0430308          ORR      r3,r3,#8              ;3463
000194  61d3              STR      r3,[r2,#0x1c]         ;3463
000196  6802              LDR      r2,[r0,#0]            ;3466
000198  69d3              LDR      r3,[r2,#0x1c]         ;3466
00019a  f0230304          BIC      r3,r3,#4              ;3466
00019e  61d3              STR      r3,[r2,#0x1c]         ;3466
0001a0  6802              LDR      r2,[r0,#0]            ;3467
0001a2  6909              LDR      r1,[r1,#0x10]         ;3467
0001a4  69d3              LDR      r3,[r2,#0x1c]         ;3467
0001a6  4319              ORRS     r1,r1,r3              ;3467
0001a8  e032              B        |L69.528|
                  |L69.426|
0001aa  6802              LDR      r2,[r0,#0]            ;3469
0001ac  6a15              LDR      r5,[r2,#0x20]         ;3469
0001ae  429a              CMP      r2,r3                 ;3469
0001b0  f4255380          BIC      r3,r5,#0x1000         ;3469
0001b4  6213              STR      r3,[r2,#0x20]         ;3469
0001b6  6a15              LDR      r5,[r2,#0x20]         ;3469
0001b8  6853              LDR      r3,[r2,#4]            ;3469
0001ba  69d6              LDR      r6,[r2,#0x1c]         ;3469
0001bc  f4255500          BIC      r5,r5,#0x2000         ;3469
0001c0  f8d18008          LDR      r8,[r1,#8]            ;3469
0001c4  680f              LDR      r7,[r1,#0]            ;3469
0001c6  f42646e6          BIC      r6,r6,#0x7300         ;3469
0001ca  f0267680          BIC      r6,r6,#0x1000000      ;3469
0001ce  ea453508          ORR      r5,r5,r8,LSL #12      ;3469
0001d2  ea462607          ORR      r6,r6,r7,LSL #8       ;3469
0001d6  bf18              IT       NE                    ;3469
0001d8  4562              CMPNE    r2,r12                ;3469
0001da  d105              BNE      |L69.488|
0001dc  f8d1c014          LDR      r12,[r1,#0x14]        ;3475
0001e0  f4234380          BIC      r3,r3,#0x4000         ;3475
0001e4  ea43138c          ORR      r3,r3,r12,LSL #6      ;3475
                  |L69.488|
0001e8  6053              STR      r3,[r2,#4]            ;3475
0001ea  61d6              STR      r6,[r2,#0x1c]         ;3475
0001ec  684b              LDR      r3,[r1,#4]            ;3475
0001ee  6413              STR      r3,[r2,#0x40]         ;3475
0001f0  6215              STR      r5,[r2,#0x20]         ;3475
0001f2  6802              LDR      r2,[r0,#0]            ;3478
0001f4  69d3              LDR      r3,[r2,#0x1c]         ;3478
0001f6  f4436300          ORR      r3,r3,#0x800          ;3478
0001fa  61d3              STR      r3,[r2,#0x1c]         ;3478
0001fc  6802              LDR      r2,[r0,#0]            ;3481
0001fe  69d3              LDR      r3,[r2,#0x1c]         ;3481
000200  f4236380          BIC      r3,r3,#0x400          ;3481
000204  61d3              STR      r3,[r2,#0x1c]         ;3481
000206  6802              LDR      r2,[r0,#0]            ;3482
000208  6909              LDR      r1,[r1,#0x10]         ;3482
00020a  69d3              LDR      r3,[r2,#0x1c]         ;3482
00020c  ea432101          ORR      r1,r3,r1,LSL #8       ;3482
                  |L69.528|
000210  61d1              STR      r1,[r2,#0x1c]         ;3467
                  |L69.530|
000212  2100              MOVS     r1,#0                 ;3492
000214  6404              STR      r4,[r0,#0x40]         ;3490
000216  63c1              STR      r1,[r0,#0x3c]         ;3494
000218  4608              MOV      r0,r1                 ;3494
00021a  e8bd03f0          POP      {r4-r9}
00021e  4770              BX       lr
;;;3496   
                          ENDP

                  |L69.544|
                          DCD      0x40010000
                  |L69.548|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PWM_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_DeInit PROC
;;;1152     */
;;;1153   HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1154   {
000002  4604              MOV      r4,r0
;;;1155     /* Check the parameters */
;;;1156     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1157     
;;;1158     htim->State = HAL_TIM_STATE_BUSY;
;;;1159     
;;;1160     /* Disable the TIM Peripheral Clock */
;;;1161     __HAL_TIM_DISABLE(htim);
000004  f2411111          MOV      r1,#0x1111
000008  2002              MOVS     r0,#2                 ;1158
00000a  6420              STR      r0,[r4,#0x40]         ;1158
00000c  6820              LDR      r0,[r4,#0]
00000e  6a02              LDR      r2,[r0,#0x20]
000010  420a              TST      r2,r1
000012  d108              BNE      |L70.38|
000014  6a01              LDR      r1,[r0,#0x20]
000016  f2404244          MOV      r2,#0x444
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L70.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L70.38|
;;;1162   
;;;1163   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;1164     if(htim->PWM_MspDeInitCallback == NULL)
;;;1165     {
;;;1166       htim->PWM_MspDeInitCallback = HAL_TIM_PWM_MspDeInit;
;;;1167     }
;;;1168     /* DeInit the low level hardware */
;;;1169     htim->PWM_MspDeInitCallback(htim);
;;;1170   #else
;;;1171     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;1172     HAL_TIM_PWM_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_PWM_MspDeInit
;;;1173   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;1174   
;;;1175     /* Change TIM state */  
;;;1176     htim->State = HAL_TIM_STATE_RESET; 
00002c  2000              MOVS     r0,#0
00002e  6420              STR      r0,[r4,#0x40]
;;;1177   
;;;1178     /* Release Lock */
;;;1179     __HAL_UNLOCK(htim);
000030  63e0              STR      r0,[r4,#0x3c]
;;;1180   
;;;1181     return HAL_OK;
;;;1182   }
000032  bd10              POP      {r4,pc}
;;;1183   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_GetState PROC
;;;5256     */
;;;5257   HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
000000  6c00              LDR      r0,[r0,#0x40]
;;;5258   {
;;;5259     return htim->State;
;;;5260   }
000002  4770              BX       lr
;;;5261   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_Init PROC
;;;1100     */
;;;1101   HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
000000  2800              CMP      r0,#0
;;;1102   {
;;;1103     /* Check the TIM handle allocation */
;;;1104     if(htim == NULL)
;;;1105     {
;;;1106       return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;1107     }
;;;1108   
;;;1109     /* Check the parameters */
;;;1110     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1111     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1112     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;1113     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;1114   
;;;1115     if(htim->State == HAL_TIM_STATE_RESET)
;;;1116     {
;;;1117       /* Allocate lock resource and initialize it */
;;;1118       htim->Lock = HAL_UNLOCKED;
;;;1119   
;;;1120   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;1121       /* Reset interrupt callbacks to legacy week callbacks */
;;;1122       TIM_ResetCallback(htim);
;;;1123   
;;;1124       if(htim->PWM_MspInitCallback == NULL)
;;;1125       {
;;;1126         htim->PWM_MspInitCallback = HAL_TIM_PWM_MspInit;
;;;1127       }
;;;1128       /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;1129       htim->PWM_MspInitCallback(htim);
;;;1130   #else
;;;1131       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1132       HAL_TIM_PWM_MspInit(htim);
;;;1133   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;1134     }
;;;1135     /* Set the TIM state */
;;;1136     htim->State= HAL_TIM_STATE_BUSY;  
;;;1137     
;;;1138     /* Init the base time for the PWM */  
;;;1139     TIM_Base_SetConfig(htim->Instance, &htim->Init); 
;;;1140      
;;;1141     /* Initialize the TIM state*/
;;;1142     htim->State= HAL_TIM_STATE_READY;
;;;1143     
;;;1144     return HAL_OK;
;;;1145   }  
000006  4770              BXEQ     lr
000008  b510              PUSH     {r4,lr}               ;1102
00000a  4604              MOV      r4,r0                 ;1102
00000c  6c00              LDR      r0,[r0,#0x40]         ;1115
00000e  b920              CBNZ     r0,|L72.26|
000010  2000              MOVS     r0,#0                 ;1118
000012  63e0              STR      r0,[r4,#0x3c]         ;1132
000014  4620              MOV      r0,r4                 ;1132
000016  f7fffffe          BL       HAL_TIM_PWM_MspInit
                  |L72.26|
00001a  2002              MOVS     r0,#2                 ;1136
00001c  6420              STR      r0,[r4,#0x40]         ;1136
00001e  6820              LDR      r0,[r4,#0]            ;1139
000020  1d21              ADDS     r1,r4,#4              ;1139
000022  f7fffffe          BL       TIM_Base_SetConfig
000026  2001              MOVS     r0,#1                 ;1142
000028  6420              STR      r0,[r4,#0x40]         ;1142
00002a  2000              MOVS     r0,#0                 ;1144
00002c  bd10              POP      {r4,pc}
;;;1146   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_MspDeInit PROC
;;;1205     */
;;;1206   __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1207   {
;;;1208     /* Prevent unused argument(s) compilation warning */
;;;1209     UNUSED(htim);
;;;1210    
;;;1211     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1212               the HAL_TIM_PWM_MspDeInit could be implemented in the user file
;;;1213      */
;;;1214   }
;;;1215   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_MspInit PROC
;;;1189     */
;;;1190   __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1191   {
;;;1192     /* Prevent unused argument(s) compilation warning */
;;;1193     UNUSED(htim);
;;;1194    
;;;1195     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1196               the HAL_TIM_PWM_MspInit could be implemented in the user file
;;;1197      */
;;;1198   }
;;;1199   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_PulseFinishedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_PulseFinishedCallback PROC
;;;4735     */
;;;4736   __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4737   {
;;;4738     /* Prevent unused argument(s) compilation warning */
;;;4739     UNUSED(htim);
;;;4740    
;;;4741     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4742               the __HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
;;;4743      */
;;;4744   }
;;;4745   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_Start PROC
;;;1227     */
;;;1228   HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
000002  2301              MOVS     r3,#1
000004  fa03f101          LSL      r1,r3,r1
000008  6a13              LDR      r3,[r2,#0x20]
00000a  438b              BICS     r3,r3,r1
00000c  6213              STR      r3,[r2,#0x20]
00000e  6a13              LDR      r3,[r2,#0x20]
000010  4319              ORRS     r1,r1,r3
000012  6211              STR      r1,[r2,#0x20]
;;;1229   {
;;;1230     /* Check the parameters */
;;;1231     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1232   
;;;1233     /* Enable the Capture compare channel */
;;;1234     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1235     
;;;1236     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000014  6801              LDR      r1,[r0,#0]
000016  f1a14280          SUB      r2,r1,#0x40000000
00001a  f5b23280          SUBS     r2,r2,#0x10000
00001e  bf1c              ITT      NE
000020  f1a14280          SUBNE    r2,r1,#0x40000000
000024  f5b23282          SUBSNE   r2,r2,#0x10400
000028  d103              BNE      |L76.50|
;;;1237     {
;;;1238       /* Enable the main output */
;;;1239       __HAL_TIM_MOE_ENABLE(htim);
00002a  6c4a              LDR      r2,[r1,#0x44]
00002c  f4424200          ORR      r2,r2,#0x8000
000030  644a              STR      r2,[r1,#0x44]
                  |L76.50|
;;;1240     }
;;;1241       
;;;1242     /* Enable the Peripheral */
;;;1243     __HAL_TIM_ENABLE(htim);
000032  6800              LDR      r0,[r0,#0]
000034  6801              LDR      r1,[r0,#0]
000036  f0410101          ORR      r1,r1,#1
00003a  6001              STR      r1,[r0,#0]
;;;1244     
;;;1245     /* Return function status */
;;;1246     return HAL_OK;
00003c  2000              MOVS     r0,#0
;;;1247   } 
00003e  4770              BX       lr
;;;1248   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start_DMA PROC
;;;1432     */
;;;1433   HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;1434   {
000002  4604              MOV      r4,r0
;;;1435     /* Check the parameters */
;;;1436     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1437     
;;;1438     if((htim->State == HAL_TIM_STATE_BUSY))
000004  6c00              LDR      r0,[r0,#0x40]
000006  4694              MOV      r12,r2                ;1434
000008  460d              MOV      r5,r1                 ;1434
00000a  2802              CMP      r0,#2
;;;1439     {
;;;1440        return HAL_BUSY;
;;;1441     }
;;;1442     else if((htim->State == HAL_TIM_STATE_READY))
;;;1443     {
;;;1444       if(((uint32_t)pData == 0 ) && (Length > 0)) 
;;;1445       {
;;;1446         return HAL_ERROR;                                    
;;;1447       }
;;;1448       else
;;;1449       {
;;;1450         htim->State = HAL_TIM_STATE_BUSY;
;;;1451       }
;;;1452     }    
;;;1453     switch (Channel)
;;;1454     {
;;;1455       case TIM_CHANNEL_1:
;;;1456       {      
;;;1457         /* Set the DMA Period elapsed callback */
;;;1458         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;1459        
;;;1460         /* Set the DMA error callback */
;;;1461         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1462         
;;;1463         /* Enable the DMA Stream */
;;;1464         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;1465         
;;;1466         /* Enable the TIM Capture/Compare 1 DMA request */
;;;1467         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1468       }
;;;1469       break;
;;;1470       
;;;1471       case TIM_CHANNEL_2:
;;;1472       {
;;;1473         /* Set the DMA Period elapsed callback */
;;;1474         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;1475        
;;;1476         /* Set the DMA error callback */
;;;1477         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1478         
;;;1479         /* Enable the DMA Stream */
;;;1480         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;1481         
;;;1482         /* Enable the TIM Capture/Compare 2 DMA request */
;;;1483         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1484       }
;;;1485       break;
;;;1486       
;;;1487       case TIM_CHANNEL_3:
;;;1488       {
;;;1489         /* Set the DMA Period elapsed callback */
;;;1490         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;1491        
;;;1492         /* Set the DMA error callback */
;;;1493         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1494         
;;;1495         /* Enable the DMA Stream */
;;;1496         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;1497         
;;;1498         /* Enable the TIM Output Capture/Compare 3 request */
;;;1499         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1500       }
;;;1501       break;
;;;1502       
;;;1503       case TIM_CHANNEL_4:
;;;1504       {
;;;1505        /* Set the DMA Period elapsed callback */
;;;1506         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;1507        
;;;1508         /* Set the DMA error callback */
;;;1509         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1510         
;;;1511         /* Enable the DMA Stream */
;;;1512         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;1513         
;;;1514         /* Enable the TIM Capture/Compare 4 DMA request */
;;;1515         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1516       }
;;;1517       break;
;;;1518       
;;;1519       default:
;;;1520       break;
;;;1521     }
;;;1522   
;;;1523     /* Enable the Capture compare channel */
;;;1524     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1525       
;;;1526     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
;;;1527     {
;;;1528       /* Enable the main output */
;;;1529       __HAL_TIM_MOE_ENABLE(htim);
;;;1530     }
;;;1531     
;;;1532     /* Enable the Peripheral */
;;;1533     __HAL_TIM_ENABLE(htim); 
;;;1534     
;;;1535     /* Return function status */
;;;1536     return HAL_OK;
;;;1537   }
00000c  bf08              IT       EQ
00000e  bd70              POPEQ    {r4-r6,pc}
000010  6c20              LDR      r0,[r4,#0x40]         ;1442
000012  2801              CMP      r0,#1                 ;1442
000014  d108              BNE      |L77.40|
000016  f1bc0f00          CMP      r12,#0                ;1444
00001a  d103              BNE      |L77.36|
00001c  2b00              CMP      r3,#0                 ;1444
00001e  bf1c              ITT      NE                    ;1446
000020  2001              MOVNE    r0,#1                 ;1446
000022  bd70              POPNE    {r4-r6,pc}
                  |L77.36|
000024  2002              MOVS     r0,#2                 ;1450
000026  6420              STR      r0,[r4,#0x40]         ;1450
                  |L77.40|
000028  4834              LDR      r0,|L77.252|
00002a  4935              LDR      r1,|L77.256|
00002c  b135              CBZ      r5,|L77.60|
00002e  2d04              CMP      r5,#4                 ;1453
000030  d014              BEQ      |L77.92|
000032  2d08              CMP      r5,#8                 ;1453
000034  d022              BEQ      |L77.124|
000036  2d0c              CMP      r5,#0xc               ;1453
000038  d030              BEQ      |L77.156|
00003a  e03f              B        |L77.188|
                  |L77.60|
00003c  6a62              LDR      r2,[r4,#0x24]         ;1458
00003e  6410              STR      r0,[r2,#0x40]         ;1461
000040  6a60              LDR      r0,[r4,#0x24]         ;1461
000042  6501              STR      r1,[r0,#0x50]         ;1464
000044  6821              LDR      r1,[r4,#0]            ;1464
000046  6a60              LDR      r0,[r4,#0x24]         ;1464
000048  f1010234          ADD      r2,r1,#0x34           ;1464
00004c  4661              MOV      r1,r12                ;1464
00004e  f7fffffe          BL       HAL_DMA_Start_IT
000052  6820              LDR      r0,[r4,#0]            ;1467
000054  68c1              LDR      r1,[r0,#0xc]          ;1467
000056  f4417100          ORR      r1,r1,#0x200          ;1467
00005a  e02e              B        |L77.186|
                  |L77.92|
00005c  6aa2              LDR      r2,[r4,#0x28]         ;1474
00005e  6410              STR      r0,[r2,#0x40]         ;1477
000060  6aa0              LDR      r0,[r4,#0x28]         ;1477
000062  6501              STR      r1,[r0,#0x50]         ;1480
000064  6821              LDR      r1,[r4,#0]            ;1480
000066  6aa0              LDR      r0,[r4,#0x28]         ;1480
000068  f1010238          ADD      r2,r1,#0x38           ;1480
00006c  4661              MOV      r1,r12                ;1480
00006e  f7fffffe          BL       HAL_DMA_Start_IT
000072  6820              LDR      r0,[r4,#0]            ;1483
000074  68c1              LDR      r1,[r0,#0xc]          ;1483
000076  f4416180          ORR      r1,r1,#0x400          ;1483
00007a  e01e              B        |L77.186|
                  |L77.124|
00007c  6ae2              LDR      r2,[r4,#0x2c]         ;1490
00007e  6410              STR      r0,[r2,#0x40]         ;1493
000080  6ae0              LDR      r0,[r4,#0x2c]         ;1493
000082  6501              STR      r1,[r0,#0x50]         ;1496
000084  6821              LDR      r1,[r4,#0]            ;1496
000086  6ae0              LDR      r0,[r4,#0x2c]         ;1496
000088  f101023c          ADD      r2,r1,#0x3c           ;1496
00008c  4661              MOV      r1,r12                ;1496
00008e  f7fffffe          BL       HAL_DMA_Start_IT
000092  6820              LDR      r0,[r4,#0]            ;1499
000094  68c1              LDR      r1,[r0,#0xc]          ;1499
000096  f4416100          ORR      r1,r1,#0x800          ;1499
00009a  e00e              B        |L77.186|
                  |L77.156|
00009c  6b22              LDR      r2,[r4,#0x30]         ;1506
00009e  6410              STR      r0,[r2,#0x40]         ;1509
0000a0  6b20              LDR      r0,[r4,#0x30]         ;1509
0000a2  6501              STR      r1,[r0,#0x50]         ;1512
0000a4  6821              LDR      r1,[r4,#0]            ;1512
0000a6  6b20              LDR      r0,[r4,#0x30]         ;1512
0000a8  f1010240          ADD      r2,r1,#0x40           ;1512
0000ac  4661              MOV      r1,r12                ;1512
0000ae  f7fffffe          BL       HAL_DMA_Start_IT
0000b2  6820              LDR      r0,[r4,#0]            ;1515
0000b4  68c1              LDR      r1,[r0,#0xc]          ;1515
0000b6  f4415180          ORR      r1,r1,#0x1000         ;1515
                  |L77.186|
0000ba  60c1              STR      r1,[r0,#0xc]          ;1499
                  |L77.188|
0000bc  6820              LDR      r0,[r4,#0]            ;1499
0000be  2101              MOVS     r1,#1                 ;1499
0000c0  40a9              LSLS     r1,r1,r5              ;1499
0000c2  6a02              LDR      r2,[r0,#0x20]         ;1499
0000c4  438a              BICS     r2,r2,r1              ;1499
0000c6  6202              STR      r2,[r0,#0x20]         ;1499
0000c8  6a02              LDR      r2,[r0,#0x20]         ;1499
0000ca  4311              ORRS     r1,r1,r2              ;1499
0000cc  6201              STR      r1,[r0,#0x20]         ;1499
0000ce  6820              LDR      r0,[r4,#0]            ;1526
0000d0  f1a04180          SUB      r1,r0,#0x40000000     ;1526
0000d4  f5b13180          SUBS     r1,r1,#0x10000        ;1526
0000d8  bf1c              ITT      NE                    ;1526
0000da  f1a04180          SUBNE    r1,r0,#0x40000000     ;1526
0000de  f5b13182          SUBSNE   r1,r1,#0x10400        ;1526
0000e2  d103              BNE      |L77.236|
0000e4  6c41              LDR      r1,[r0,#0x44]         ;1529
0000e6  f4414100          ORR      r1,r1,#0x8000         ;1529
0000ea  6441              STR      r1,[r0,#0x44]         ;1529
                  |L77.236|
0000ec  6820              LDR      r0,[r4,#0]            ;1533
0000ee  6801              LDR      r1,[r0,#0]            ;1533
0000f0  f0410101          ORR      r1,r1,#1              ;1533
0000f4  6001              STR      r1,[r0,#0]            ;1533
0000f6  2000              MOVS     r0,#0                 ;1536
0000f8  bd70              POP      {r4-r6,pc}
;;;1538   
                          ENDP

0000fa  0000              DCW      0x0000
                  |L77.252|
                          DCD      TIM_DMADelayPulseCplt
                  |L77.256|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_PWM_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_Start_IT PROC
;;;1296     */
;;;1297   HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
;;;1298   {
;;;1299     /* Check the parameters */
;;;1300     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1301     
;;;1302     switch (Channel)
000002  2900              CMP      r1,#0
;;;1303     {
;;;1304       case TIM_CHANNEL_1:
;;;1305       {       
;;;1306         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1307         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000004  bf04              ITT      EQ
000006  68d3              LDREQ    r3,[r2,#0xc]
000008  f0430302          ORREQ    r3,r3,#2
00000c  d011              BEQ      |L78.50|
00000e  2904              CMP      r1,#4                 ;1302
;;;1308       }
;;;1309       break;
;;;1310       
;;;1311       case TIM_CHANNEL_2:
;;;1312       {
;;;1313         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1314         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000010  bf04              ITT      EQ
000012  68d3              LDREQ    r3,[r2,#0xc]
000014  f0430304          ORREQ    r3,r3,#4
000018  d00b              BEQ      |L78.50|
00001a  2908              CMP      r1,#8                 ;1302
;;;1315       }
;;;1316       break;
;;;1317       
;;;1318       case TIM_CHANNEL_3:
;;;1319       {
;;;1320         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1321         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
00001c  bf04              ITT      EQ
00001e  68d3              LDREQ    r3,[r2,#0xc]
000020  f0430308          ORREQ    r3,r3,#8
000024  d005              BEQ      |L78.50|
000026  290c              CMP      r1,#0xc               ;1302
;;;1322       }
;;;1323       break;
;;;1324       
;;;1325       case TIM_CHANNEL_4:
;;;1326       {
;;;1327         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1328         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000028  bf04              ITT      EQ
00002a  68d3              LDREQ    r3,[r2,#0xc]
00002c  f0430310          ORREQ    r3,r3,#0x10
000030  d100              BNE      |L78.52|
                  |L78.50|
000032  60d3              STR      r3,[r2,#0xc]          ;1321
                  |L78.52|
000034  2301              MOVS     r3,#1                 ;1321
000036  6802              LDR      r2,[r0,#0]            ;1321
000038  fa03f101          LSL      r1,r3,r1              ;1321
00003c  6a13              LDR      r3,[r2,#0x20]         ;1321
00003e  438b              BICS     r3,r3,r1              ;1321
000040  6213              STR      r3,[r2,#0x20]         ;1321
000042  6a13              LDR      r3,[r2,#0x20]         ;1321
000044  4319              ORRS     r1,r1,r3              ;1321
000046  6211              STR      r1,[r2,#0x20]         ;1321
;;;1329       }
;;;1330       break;
;;;1331       
;;;1332       default:
;;;1333       break;
;;;1334     } 
;;;1335     
;;;1336     /* Enable the Capture compare channel */
;;;1337     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1338     
;;;1339     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000048  6801              LDR      r1,[r0,#0]
00004a  f1a14280          SUB      r2,r1,#0x40000000
00004e  f5b23280          SUBS     r2,r2,#0x10000
000052  bf1c              ITT      NE
000054  f1a14280          SUBNE    r2,r1,#0x40000000
000058  f5b23282          SUBSNE   r2,r2,#0x10400
00005c  d103              BNE      |L78.102|
;;;1340     {
;;;1341       /* Enable the main output */
;;;1342       __HAL_TIM_MOE_ENABLE(htim);
00005e  6c4a              LDR      r2,[r1,#0x44]
000060  f4424200          ORR      r2,r2,#0x8000
000064  644a              STR      r2,[r1,#0x44]
                  |L78.102|
;;;1343     }
;;;1344   
;;;1345     /* Enable the Peripheral */
;;;1346     __HAL_TIM_ENABLE(htim);
000066  6800              LDR      r0,[r0,#0]
000068  6801              LDR      r1,[r0,#0]
00006a  f0410101          ORR      r1,r1,#1
00006e  6001              STR      r1,[r0,#0]
;;;1347     
;;;1348     /* Return function status */
;;;1349     return HAL_OK;
000070  2000              MOVS     r0,#0
;;;1350   } 
000072  4770              BX       lr
;;;1351   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_Stop PROC
;;;1260     */
;;;1261   HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  f84d4d04          PUSH.W   {r4}
;;;1262   { 
000004  6802              LDR      r2,[r0,#0]
;;;1263     /* Check the parameters */
;;;1264     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1265       
;;;1266     /* Disable the Capture compare channel */
;;;1267     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000006  f04f0c00          MOV      r12,#0
00000a  2301              MOVS     r3,#1
00000c  fa0cfc01          LSL      r12,r12,r1
000010  6a14              LDR      r4,[r2,#0x20]
000012  fa03f101          LSL      r1,r3,r1
000016  ea240101          BIC      r1,r4,r1
00001a  6211              STR      r1,[r2,#0x20]
00001c  6a11              LDR      r1,[r2,#0x20]
00001e  ea41010c          ORR      r1,r1,r12
000022  6211              STR      r1,[r2,#0x20]
;;;1268     
;;;1269     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000024  6801              LDR      r1,[r0,#0]
;;;1270     {
;;;1271       /* Disable the Main Output */
;;;1272       __HAL_TIM_MOE_DISABLE(htim);
000026  f2411211          MOV      r2,#0x1111
00002a  f2404c44          MOV      r12,#0x444
00002e  f1a14480          SUB      r4,r1,#0x40000000     ;1269
000032  f5b43480          SUBS     r4,r4,#0x10000        ;1269
000036  bf1c              ITT      NE                    ;1269
000038  f1a14480          SUBNE    r4,r1,#0x40000000     ;1269
00003c  f5b43482          SUBSNE   r4,r4,#0x10400        ;1269
000040  d10a              BNE      |L79.88|
000042  6a0c              LDR      r4,[r1,#0x20]
000044  4214              TST      r4,r2
000046  bf04              ITT      EQ
000048  6a0c              LDREQ    r4,[r1,#0x20]
00004a  ea140f0c          TSTEQ    r4,r12
00004e  d103              BNE      |L79.88|
000050  6c4c              LDR      r4,[r1,#0x44]
000052  f4244400          BIC      r4,r4,#0x8000
000056  644c              STR      r4,[r1,#0x44]
                  |L79.88|
;;;1273     }
;;;1274     
;;;1275     /* Disable the Peripheral */
;;;1276     __HAL_TIM_DISABLE(htim);
000058  6801              LDR      r1,[r0,#0]
00005a  6a0c              LDR      r4,[r1,#0x20]
00005c  4214              TST      r4,r2
00005e  bf04              ITT      EQ
000060  6a0a              LDREQ    r2,[r1,#0x20]
000062  ea120f0c          TSTEQ    r2,r12
000066  d103              BNE      |L79.112|
000068  680a              LDR      r2,[r1,#0]
00006a  f0220201          BIC      r2,r2,#1
00006e  600a              STR      r2,[r1,#0]
                  |L79.112|
;;;1277     
;;;1278     /* Change the htim state */
;;;1279     htim->State = HAL_TIM_STATE_READY;
000070  6403              STR      r3,[r0,#0x40]
;;;1280     
;;;1281     /* Return function status */
;;;1282     return HAL_OK;
000072  2000              MOVS     r0,#0
;;;1283   } 
000074  f85d4b04          POP.W    {r4}
000078  4770              BX       lr
;;;1284   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_Stop_DMA PROC
;;;1550     */
;;;1551   HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  f84d4d04          PUSH.W   {r4}
;;;1552   {
;;;1553     /* Check the parameters */
;;;1554     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1555     
;;;1556     switch (Channel)
000004  6802              LDR      r2,[r0,#0]
000006  2900              CMP      r1,#0
;;;1557     {
;;;1558       case TIM_CHANNEL_1:
;;;1559       {       
;;;1560         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1561         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000008  bf04              ITT      EQ
00000a  68d3              LDREQ    r3,[r2,#0xc]
00000c  f4237300          BICEQ    r3,r3,#0x200
000010  d011              BEQ      |L80.54|
000012  2904              CMP      r1,#4                 ;1556
;;;1562       }
;;;1563       break;
;;;1564       
;;;1565       case TIM_CHANNEL_2:
;;;1566       {
;;;1567         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1568         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000014  bf04              ITT      EQ
000016  68d3              LDREQ    r3,[r2,#0xc]
000018  f4236380          BICEQ    r3,r3,#0x400
00001c  d00b              BEQ      |L80.54|
00001e  2908              CMP      r1,#8                 ;1556
;;;1569       }
;;;1570       break;
;;;1571       
;;;1572       case TIM_CHANNEL_3:
;;;1573       {
;;;1574         /* Disable the TIM Capture/Compare 3 DMA request */
;;;1575         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
000020  bf04              ITT      EQ
000022  68d3              LDREQ    r3,[r2,#0xc]
000024  f4236300          BICEQ    r3,r3,#0x800
000028  d005              BEQ      |L80.54|
00002a  290c              CMP      r1,#0xc               ;1556
;;;1576       }
;;;1577       break;
;;;1578       
;;;1579       case TIM_CHANNEL_4:
;;;1580       {
;;;1581         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1582         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
00002c  bf04              ITT      EQ
00002e  68d3              LDREQ    r3,[r2,#0xc]
000030  f4235380          BICEQ    r3,r3,#0x1000
000034  d100              BNE      |L80.56|
                  |L80.54|
000036  60d3              STR      r3,[r2,#0xc]          ;1575
                  |L80.56|
;;;1583       }
;;;1584       break;
;;;1585       
;;;1586       default:
;;;1587       break;
;;;1588     } 
;;;1589     
;;;1590     /* Disable the Capture compare channel */
;;;1591     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000038  f04f0c00          MOV      r12,#0
00003c  6802              LDR      r2,[r0,#0]
00003e  2301              MOVS     r3,#1
000040  fa0cfc01          LSL      r12,r12,r1
000044  6a14              LDR      r4,[r2,#0x20]
000046  fa03f101          LSL      r1,r3,r1
00004a  ea240101          BIC      r1,r4,r1
00004e  6211              STR      r1,[r2,#0x20]
000050  6a11              LDR      r1,[r2,#0x20]
000052  ea41010c          ORR      r1,r1,r12
000056  6211              STR      r1,[r2,#0x20]
;;;1592     
;;;1593     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000058  6801              LDR      r1,[r0,#0]
;;;1594     {
;;;1595       /* Disable the Main Output */
;;;1596       __HAL_TIM_MOE_DISABLE(htim);
00005a  f2411211          MOV      r2,#0x1111
00005e  f2404c44          MOV      r12,#0x444
000062  f1a14480          SUB      r4,r1,#0x40000000     ;1593
000066  f5b43480          SUBS     r4,r4,#0x10000        ;1593
00006a  bf1c              ITT      NE                    ;1593
00006c  f1a14480          SUBNE    r4,r1,#0x40000000     ;1593
000070  f5b43482          SUBSNE   r4,r4,#0x10400        ;1593
000074  d10a              BNE      |L80.140|
000076  6a0c              LDR      r4,[r1,#0x20]
000078  4214              TST      r4,r2
00007a  bf04              ITT      EQ
00007c  6a0c              LDREQ    r4,[r1,#0x20]
00007e  ea140f0c          TSTEQ    r4,r12
000082  d103              BNE      |L80.140|
000084  6c4c              LDR      r4,[r1,#0x44]
000086  f4244400          BIC      r4,r4,#0x8000
00008a  644c              STR      r4,[r1,#0x44]
                  |L80.140|
;;;1597     }
;;;1598     
;;;1599     /* Disable the Peripheral */
;;;1600     __HAL_TIM_DISABLE(htim);
00008c  6801              LDR      r1,[r0,#0]
00008e  6a0c              LDR      r4,[r1,#0x20]
000090  4214              TST      r4,r2
000092  bf04              ITT      EQ
000094  6a0a              LDREQ    r2,[r1,#0x20]
000096  ea120f0c          TSTEQ    r2,r12
00009a  d103              BNE      |L80.164|
00009c  680a              LDR      r2,[r1,#0]
00009e  f0220201          BIC      r2,r2,#1
0000a2  600a              STR      r2,[r1,#0]
                  |L80.164|
;;;1601     
;;;1602     /* Change the htim state */
;;;1603     htim->State = HAL_TIM_STATE_READY;
0000a4  6403              STR      r3,[r0,#0x40]
;;;1604     
;;;1605     /* Return function status */
;;;1606     return HAL_OK;
0000a6  2000              MOVS     r0,#0
;;;1607   }
0000a8  f85d4b04          POP.W    {r4}
0000ac  4770              BX       lr
;;;1608   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_Stop_IT PROC
;;;1363     */
;;;1364   HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  f84d4d04          PUSH.W   {r4}
;;;1365   {
;;;1366     /* Check the parameters */
;;;1367     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1368     
;;;1369     switch (Channel)
000004  6802              LDR      r2,[r0,#0]
000006  2900              CMP      r1,#0
;;;1370     {
;;;1371       case TIM_CHANNEL_1:
;;;1372       {       
;;;1373         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1374         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000008  bf04              ITT      EQ
00000a  68d3              LDREQ    r3,[r2,#0xc]
00000c  f0230302          BICEQ    r3,r3,#2
000010  d011              BEQ      |L81.54|
000012  2904              CMP      r1,#4                 ;1369
;;;1375       }
;;;1376       break;
;;;1377       
;;;1378       case TIM_CHANNEL_2:
;;;1379       {
;;;1380         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1381         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000014  bf04              ITT      EQ
000016  68d3              LDREQ    r3,[r2,#0xc]
000018  f0230304          BICEQ    r3,r3,#4
00001c  d00b              BEQ      |L81.54|
00001e  2908              CMP      r1,#8                 ;1369
;;;1382       }
;;;1383       break;
;;;1384       
;;;1385       case TIM_CHANNEL_3:
;;;1386       {
;;;1387         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1388         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
000020  bf04              ITT      EQ
000022  68d3              LDREQ    r3,[r2,#0xc]
000024  f0230308          BICEQ    r3,r3,#8
000028  d005              BEQ      |L81.54|
00002a  290c              CMP      r1,#0xc               ;1369
;;;1389       }
;;;1390       break;
;;;1391       
;;;1392       case TIM_CHANNEL_4:
;;;1393       {
;;;1394         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1395         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
00002c  bf04              ITT      EQ
00002e  68d3              LDREQ    r3,[r2,#0xc]
000030  f0230310          BICEQ    r3,r3,#0x10
000034  d100              BNE      |L81.56|
                  |L81.54|
000036  60d3              STR      r3,[r2,#0xc]          ;1388
                  |L81.56|
;;;1396       }
;;;1397       break;
;;;1398       
;;;1399       default:
;;;1400       break; 
;;;1401     }
;;;1402     
;;;1403     /* Disable the Capture compare channel */
;;;1404     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000038  2300              MOVS     r3,#0
00003a  6802              LDR      r2,[r0,#0]
00003c  f04f0c01          MOV      r12,#1
000040  408b              LSLS     r3,r3,r1
000042  6a14              LDR      r4,[r2,#0x20]
000044  fa0cf101          LSL      r1,r12,r1
000048  ea240101          BIC      r1,r4,r1
00004c  6211              STR      r1,[r2,#0x20]
00004e  6a11              LDR      r1,[r2,#0x20]
000050  4319              ORRS     r1,r1,r3
000052  6211              STR      r1,[r2,#0x20]
;;;1405     
;;;1406     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000054  6801              LDR      r1,[r0,#0]
;;;1407     {
;;;1408       /* Disable the Main Output */
;;;1409       __HAL_TIM_MOE_DISABLE(htim);
000056  f2411211          MOV      r2,#0x1111
00005a  1093              ASRS     r3,r2,#2
00005c  f1a14c80          SUB      r12,r1,#0x40000000    ;1406
000060  f5bc3c80          SUBS     r12,r12,#0x10000      ;1406
000064  bf1c              ITT      NE                    ;1406
000066  f1a14c80          SUBNE    r12,r1,#0x40000000    ;1406
00006a  f5bc3c82          SUBSNE   r12,r12,#0x10400      ;1406
00006e  d10f              BNE      |L81.144|
000070  f8d1c020          LDR      r12,[r1,#0x20]
000074  ea1c0f02          TST      r12,r2
000078  bf04              ITT      EQ
00007a  f8d1c020          LDREQ    r12,[r1,#0x20]
00007e  ea1c0f03          TSTEQ    r12,r3
000082  d105              BNE      |L81.144|
000084  f8d1c044          LDR      r12,[r1,#0x44]
000088  f42c4c00          BIC      r12,r12,#0x8000
00008c  f8c1c044          STR      r12,[r1,#0x44]
                  |L81.144|
;;;1410     }
;;;1411     
;;;1412     /* Disable the Peripheral */
;;;1413     __HAL_TIM_DISABLE(htim);
000090  6800              LDR      r0,[r0,#0]
000092  6a01              LDR      r1,[r0,#0x20]
000094  4211              TST      r1,r2
000096  bf04              ITT      EQ
000098  6a01              LDREQ    r1,[r0,#0x20]
00009a  4219              TSTEQ    r1,r3
00009c  d103              BNE      |L81.166|
00009e  6801              LDR      r1,[r0,#0]
0000a0  f0210101          BIC      r1,r1,#1
0000a4  6001              STR      r1,[r0,#0]
                  |L81.166|
;;;1414     
;;;1415     /* Return function status */
;;;1416     return HAL_OK;
;;;1417   } 
0000a6  f85d4b04          POP.W    {r4}
0000aa  2000              MOVS     r0,#0                 ;1416
0000ac  4770              BX       lr
;;;1418   
                          ENDP


                          AREA ||i.HAL_TIM_PeriodElapsedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PeriodElapsedCallback PROC
;;;4688     */
;;;4689   __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4690   {
;;;4691     /* Prevent unused argument(s) compilation warning */
;;;4692     UNUSED(htim);
;;;4693    
;;;4694     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4695               the __HAL_TIM_PeriodElapsedCallback could be implemented in the user file
;;;4696      */
;;;4697     
;;;4698   }
;;;4699   /**
                          ENDP


                          AREA ||i.HAL_TIM_ReadCapturedValue||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ReadCapturedValue PROC
;;;4598     */
;;;4599   uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6bc3              LDR      r3,[r0,#0x3c]
;;;4600   {
;;;4601     uint32_t tmpreg = 0;
000002  2200              MOVS     r2,#0
;;;4602     
;;;4603     __HAL_LOCK(htim);
000004  2b01              CMP      r3,#1
000006  bf04              ITT      EQ
000008  2002              MOVEQ    r0,#2
;;;4604     
;;;4605     switch (Channel)
;;;4606     {
;;;4607       case TIM_CHANNEL_1:
;;;4608       {
;;;4609         /* Check the parameters */
;;;4610         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4611         
;;;4612         /* Return the capture 1 value */
;;;4613         tmpreg = htim->Instance->CCR1;
;;;4614         
;;;4615         break;
;;;4616       }
;;;4617       case TIM_CHANNEL_2:
;;;4618       {
;;;4619         /* Check the parameters */
;;;4620         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4621         
;;;4622         /* Return the capture 2 value */
;;;4623         tmpreg = htim->Instance->CCR2;
;;;4624         
;;;4625         break;
;;;4626       }
;;;4627       
;;;4628       case TIM_CHANNEL_3:
;;;4629       {
;;;4630         /* Check the parameters */
;;;4631         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;4632         
;;;4633         /* Return the capture 3 value */
;;;4634         tmpreg = htim->Instance->CCR3;
;;;4635         
;;;4636         break;
;;;4637       }
;;;4638       
;;;4639       case TIM_CHANNEL_4:
;;;4640       {
;;;4641         /* Check the parameters */
;;;4642         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;4643         
;;;4644         /* Return the capture 4 value */
;;;4645         tmpreg = htim->Instance->CCR4;
;;;4646         
;;;4647         break;
;;;4648       }
;;;4649       
;;;4650       default:
;;;4651       break;  
;;;4652     }
;;;4653        
;;;4654     __HAL_UNLOCK(htim);  
;;;4655     return tmpreg;
;;;4656   }
00000a  4770              BXEQ     lr
00000c  2301              MOVS     r3,#1                 ;4603
00000e  2900              CMP      r1,#0                 ;4605
000010  63c3              STR      r3,[r0,#0x3c]         ;4603
000012  bf04              ITT      EQ                    ;4613
000014  6801              LDREQ    r1,[r0,#0]            ;4613
000016  6b4a              LDREQ    r2,[r1,#0x34]         ;4613
000018  d00d              BEQ      |L83.54|
00001a  2904              CMP      r1,#4                 ;4605
00001c  bf04              ITT      EQ                    ;4623
00001e  6801              LDREQ    r1,[r0,#0]            ;4623
000020  6b8a              LDREQ    r2,[r1,#0x38]         ;4623
000022  d008              BEQ      |L83.54|
000024  2908              CMP      r1,#8                 ;4605
000026  bf04              ITT      EQ                    ;4634
000028  6801              LDREQ    r1,[r0,#0]            ;4634
00002a  6bca              LDREQ    r2,[r1,#0x3c]         ;4634
00002c  d003              BEQ      |L83.54|
00002e  290c              CMP      r1,#0xc               ;4605
000030  bf04              ITT      EQ                    ;4645
000032  6801              LDREQ    r1,[r0,#0]            ;4645
000034  6c0a              LDREQ    r2,[r1,#0x40]         ;4645
                  |L83.54|
000036  2100              MOVS     r1,#0                 ;4654
000038  63c1              STR      r1,[r0,#0x3c]         ;4655
00003a  4610              MOV      r0,r2                 ;4655
00003c  4770              BX       lr
;;;4657   
                          ENDP


                          AREA ||i.HAL_TIM_SlaveConfigSynchronization||, CODE, READONLY, ALIGN=1

                  HAL_TIM_SlaveConfigSynchronization PROC
;;;4412     */
;;;4413   HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef * sSlaveConfig)
000000  6bc2              LDR      r2,[r0,#0x3c]
;;;4414   {
;;;4415     uint32_t tmpsmcr  = 0;
;;;4416     uint32_t tmpccmr1 = 0;
;;;4417     uint32_t tmpccer = 0;
;;;4418   
;;;4419     /* Check the parameters */
;;;4420     assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
;;;4421     assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
;;;4422     assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
;;;4423      
;;;4424     __HAL_LOCK(htim);
000002  2a01              CMP      r2,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;4425     
;;;4426     htim->State = HAL_TIM_STATE_BUSY;
;;;4427   
;;;4428     /* Get the TIMx SMCR register value */
;;;4429     tmpsmcr = htim->Instance->SMCR;
;;;4430   
;;;4431     /* Reset the Trigger Selection Bits */
;;;4432     tmpsmcr &= ~TIM_SMCR_TS;
;;;4433     /* Set the Input Trigger source */
;;;4434     tmpsmcr |= sSlaveConfig->InputTrigger;
;;;4435   
;;;4436     /* Reset the slave mode Bits */
;;;4437     tmpsmcr &= ~TIM_SMCR_SMS;
;;;4438     /* Set the slave mode */
;;;4439     tmpsmcr |= sSlaveConfig->SlaveMode;
;;;4440   
;;;4441     /* Write to TIMx SMCR */
;;;4442     htim->Instance->SMCR = tmpsmcr;
;;;4443     
;;;4444     /* Configure the trigger prescaler, filter, and polarity */
;;;4445     switch (sSlaveConfig->InputTrigger)
;;;4446     {
;;;4447     case TIM_TS_ETRF:
;;;4448       {
;;;4449         /* Check the parameters */
;;;4450         assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
;;;4451         assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
;;;4452         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;4453         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4454         /* Configure the ETR Trigger source */
;;;4455         TIM_ETR_SetConfig(htim->Instance, 
;;;4456                           sSlaveConfig->TriggerPrescaler, 
;;;4457                           sSlaveConfig->TriggerPolarity, 
;;;4458                           sSlaveConfig->TriggerFilter);
;;;4459       }
;;;4460       break;
;;;4461       
;;;4462     case TIM_TS_TI1F_ED:
;;;4463       {
;;;4464         /* Check the parameters */
;;;4465         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4466         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4467         
;;;4468         /* Disable the Channel 1: Reset the CC1E Bit */
;;;4469         tmpccer = htim->Instance->CCER;
;;;4470         htim->Instance->CCER &= ~TIM_CCER_CC1E;
;;;4471         tmpccmr1 = htim->Instance->CCMR1;    
;;;4472         
;;;4473         /* Set the filter */
;;;4474         tmpccmr1 &= ~TIM_CCMR1_IC1F;
;;;4475         tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4);
;;;4476         
;;;4477         /* Write to TIMx CCMR1 and CCER registers */
;;;4478         htim->Instance->CCMR1 = tmpccmr1;
;;;4479         htim->Instance->CCER = tmpccer;                               
;;;4480                                  
;;;4481       }
;;;4482       break;
;;;4483       
;;;4484     case TIM_TS_TI1FP1:
;;;4485       {
;;;4486         /* Check the parameters */
;;;4487         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4488         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;4489         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4490   
;;;4491         /* Configure TI1 Filter and Polarity */
;;;4492         TIM_TI1_ConfigInputStage(htim->Instance,
;;;4493                                  sSlaveConfig->TriggerPolarity,
;;;4494                                  sSlaveConfig->TriggerFilter);
;;;4495       }
;;;4496       break;
;;;4497       
;;;4498     case TIM_TS_TI2FP2:
;;;4499       {
;;;4500         /* Check the parameters */
;;;4501         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4502         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;4503         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4504         
;;;4505         /* Configure TI2 Filter and Polarity */
;;;4506         TIM_TI2_ConfigInputStage(htim->Instance,
;;;4507                                   sSlaveConfig->TriggerPolarity,
;;;4508                                   sSlaveConfig->TriggerFilter);
;;;4509       }
;;;4510       break;
;;;4511       
;;;4512     case TIM_TS_ITR0:
;;;4513       {
;;;4514         /* Check the parameter */
;;;4515         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4516       }
;;;4517       break;
;;;4518       
;;;4519     case TIM_TS_ITR1:
;;;4520       {
;;;4521         /* Check the parameter */
;;;4522         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4523       }
;;;4524       break;
;;;4525       
;;;4526     case TIM_TS_ITR2:
;;;4527       {
;;;4528         /* Check the parameter */
;;;4529         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4530       }
;;;4531       break;
;;;4532       
;;;4533     case TIM_TS_ITR3:
;;;4534       {
;;;4535         /* Check the parameter */
;;;4536         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4537       }
;;;4538       break;
;;;4539          
;;;4540     default:
;;;4541       break;
;;;4542     }
;;;4543     
;;;4544     htim->State = HAL_TIM_STATE_READY;
;;;4545        
;;;4546     __HAL_UNLOCK(htim);  
;;;4547     
;;;4548     return HAL_OK;
;;;4549   } 
000008  4770              BXEQ     lr
00000a  b430              PUSH     {r4,r5}               ;4414
00000c  2301              MOVS     r3,#1                 ;4424
00000e  63c3              STR      r3,[r0,#0x3c]         ;4426
000010  2202              MOVS     r2,#2                 ;4426
000012  6402              STR      r2,[r0,#0x40]         ;4426
000014  6802              LDR      r2,[r0,#0]            ;4434
000016  684c              LDR      r4,[r1,#4]            ;4429
000018  f8d2c008          LDR      r12,[r2,#8]           ;4429
00001c  680d              LDR      r5,[r1,#0]            ;4439
00001e  f02c0c70          BIC      r12,r12,#0x70         ;4432
000022  ea440c0c          ORR      r12,r4,r12            ;4434
000026  f02c0c07          BIC      r12,r12,#7            ;4437
00002a  f42c3c80          BIC      r12,r12,#0x10000      ;4437
00002e  ea450c0c          ORR      r12,r5,r12            ;4439
000032  f8c2c008          STR      r12,[r2,#8]           ;4442
000036  684a              LDR      r2,[r1,#4]            ;4445
000038  f0120f0f          TST      r2,#0xf               ;4445
00003c  d156              BNE      |L84.236|
00003e  1112              ASRS     r2,r2,#4              ;4445
000040  2a08              CMP      r2,#8                 ;4445
000042  d253              BCS      |L84.236|
000044  e8dff002          TBB      [pc,r2]               ;4445
000048  52525252          DCB      0x52,0x52,0x52,0x52
00004c  14273d04          DCB      0x14,0x27,0x3d,0x04
000050  6802              LDR      r2,[r0,#0]            ;4455
000052  e9d14503          LDRD     r4,r5,[r1,#0xc]       ;4455
000056  f8d1c008          LDR      r12,[r1,#8]           ;4455
00005a  6891              LDR      r1,[r2,#8]            ;4455
00005c  ea4c2c05          ORR      r12,r12,r5,LSL #8     ;4455
000060  ea4c0c04          ORR      r12,r12,r4            ;4455
000064  f421417f          BIC      r1,r1,#0xff00         ;4455
000068  ea4c0101          ORR      r1,r12,r1             ;4455
00006c  6091              STR      r1,[r2,#8]            ;4455
00006e  e03d              B        |L84.236|
000070  6802              LDR      r2,[r0,#0]            ;4469
000072  f8d2c020          LDR      r12,[r2,#0x20]        ;4469
000076  6a14              LDR      r4,[r2,#0x20]         ;4470
000078  f0240401          BIC      r4,r4,#1              ;4470
00007c  6214              STR      r4,[r2,#0x20]         ;4470
00007e  6802              LDR      r2,[r0,#0]            ;4475
000080  690c              LDR      r4,[r1,#0x10]         ;4471
000082  6991              LDR      r1,[r2,#0x18]         ;4471
000084  f02101f0          BIC      r1,r1,#0xf0           ;4474
000088  ea411104          ORR      r1,r1,r4,LSL #4       ;4475
00008c  6191              STR      r1,[r2,#0x18]         ;4478
00008e  6801              LDR      r1,[r0,#0]            ;4479
000090  f8c1c020          STR      r12,[r1,#0x20]        ;4479
000094  e02a              B        |L84.236|
000096  6802              LDR      r2,[r0,#0]            ;4492
000098  f8d1c008          LDR      r12,[r1,#8]           ;4492
00009c  6909              LDR      r1,[r1,#0x10]         ;4492
00009e  6a14              LDR      r4,[r2,#0x20]         ;4492
0000a0  6a15              LDR      r5,[r2,#0x20]         ;4492
0000a2  f024040a          BIC      r4,r4,#0xa            ;4492
0000a6  f0250501          BIC      r5,r5,#1              ;4492
0000aa  6215              STR      r5,[r2,#0x20]         ;4492
0000ac  6995              LDR      r5,[r2,#0x18]         ;4492
0000ae  ea440c0c          ORR      r12,r4,r12            ;4492
0000b2  f02504f0          BIC      r4,r5,#0xf0           ;4492
0000b6  ea441101          ORR      r1,r4,r1,LSL #4       ;4492
0000ba  6191              STR      r1,[r2,#0x18]         ;4492
0000bc  f8c2c020          STR      r12,[r2,#0x20]        ;4492
0000c0  e014              B        |L84.236|
0000c2  6802              LDR      r2,[r0,#0]            ;4506
0000c4  f8d1c008          LDR      r12,[r1,#8]           ;4506
0000c8  6909              LDR      r1,[r1,#0x10]         ;4506
0000ca  6a14              LDR      r4,[r2,#0x20]         ;4506
0000cc  f0240410          BIC      r4,r4,#0x10           ;4506
0000d0  6214              STR      r4,[r2,#0x20]         ;4506
0000d2  6994              LDR      r4,[r2,#0x18]         ;4506
0000d4  6a15              LDR      r5,[r2,#0x20]         ;4506
0000d6  f4244470          BIC      r4,r4,#0xf000         ;4506
0000da  ea443101          ORR      r1,r4,r1,LSL #12      ;4506
0000de  6191              STR      r1,[r2,#0x18]         ;4506
0000e0  f02504a0          BIC      r4,r5,#0xa0           ;4506
0000e4  ea441c0c          ORR      r12,r4,r12,LSL #4     ;4506
0000e8  f8c2c020          STR      r12,[r2,#0x20]        ;4506
                  |L84.236|
0000ec  2100              MOVS     r1,#0                 ;4546
0000ee  6403              STR      r3,[r0,#0x40]         ;4544
0000f0  63c1              STR      r1,[r0,#0x3c]         ;4548
0000f2  4608              MOV      r0,r1                 ;4548
0000f4  bc30              POP      {r4,r5}
0000f6  4770              BX       lr
;;;4550   
                          ENDP


                          AREA ||i.HAL_TIM_SlaveConfigSynchronization_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_SlaveConfigSynchronization_IT PROC
;;;4559     */
;;;4560   HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization_IT(TIM_HandleTypeDef *htim, 
000000  6bc2              LDR      r2,[r0,#0x3c]
;;;4561                                                           TIM_SlaveConfigTypeDef * sSlaveConfig)
;;;4562   {
;;;4563     /* Check the parameters */
;;;4564     assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
;;;4565     assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
;;;4566     assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
;;;4567     
;;;4568     __HAL_LOCK(htim);
000002  2a01              CMP      r2,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;4569   
;;;4570     htim->State = HAL_TIM_STATE_BUSY;
;;;4571     
;;;4572     TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
;;;4573     
;;;4574     /* Enable Trigger Interrupt */
;;;4575     __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
;;;4576     
;;;4577     /* Disable Trigger DMA request */
;;;4578     __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
;;;4579     
;;;4580     htim->State = HAL_TIM_STATE_READY;
;;;4581        
;;;4582     __HAL_UNLOCK(htim);  
;;;4583     
;;;4584     return HAL_OK;
;;;4585   }
000008  4770              BXEQ     lr
00000a  b470              PUSH     {r4-r6}               ;4562
00000c  2301              MOVS     r3,#1                 ;4568
00000e  63c3              STR      r3,[r0,#0x3c]         ;4570
000010  2202              MOVS     r2,#2                 ;4570
000012  6402              STR      r2,[r0,#0x40]         ;4570
000014  e9d14500          LDRD     r4,r5,[r1,#0]         ;4570
000018  f8d0c000          LDR      r12,[r0,#0]           ;4570
00001c  f8dc2008          LDR      r2,[r12,#8]           ;4570
000020  f0220270          BIC      r2,r2,#0x70           ;4570
000024  432a              ORRS     r2,r2,r5              ;4570
000026  f0220207          BIC      r2,r2,#7              ;4570
00002a  f4223280          BIC      r2,r2,#0x10000        ;4570
00002e  4322              ORRS     r2,r2,r4              ;4570
000030  f8cc2008          STR      r2,[r12,#8]           ;4570
000034  684a              LDR      r2,[r1,#4]            ;4570
000036  f0120f0f          TST      r2,#0xf               ;4570
00003a  d155              BNE      |L85.232|
00003c  1112              ASRS     r2,r2,#4              ;4568
00003e  2a08              CMP      r2,#8                 ;4568
000040  d252              BCS      |L85.232|
000042  e8dff002          TBB      [pc,r2]               ;4568
000046  5151              DCB      0x51,0x51
000048  51511427          DCB      0x51,0x51,0x14,0x27
00004c  3d04              DCB      0x3d,0x04
00004e  6802              LDR      r2,[r0,#0]            ;4568
000050  e9d14503          LDRD     r4,r5,[r1,#0xc]       ;4568
000054  f8d1c008          LDR      r12,[r1,#8]           ;4568
000058  6891              LDR      r1,[r2,#8]            ;4568
00005a  ea4c2c05          ORR      r12,r12,r5,LSL #8     ;4568
00005e  ea4c0c04          ORR      r12,r12,r4            ;4568
000062  f421417f          BIC      r1,r1,#0xff00         ;4568
000066  ea4c0101          ORR      r1,r12,r1             ;4568
00006a  6091              STR      r1,[r2,#8]            ;4568
00006c  e03c              B        |L85.232|
00006e  6802              LDR      r2,[r0,#0]            ;4568
000070  f8d2c020          LDR      r12,[r2,#0x20]        ;4568
000074  6a14              LDR      r4,[r2,#0x20]         ;4568
000076  f0240401          BIC      r4,r4,#1              ;4568
00007a  6214              STR      r4,[r2,#0x20]         ;4568
00007c  6802              LDR      r2,[r0,#0]            ;4568
00007e  690c              LDR      r4,[r1,#0x10]         ;4568
000080  6991              LDR      r1,[r2,#0x18]         ;4568
000082  f02101f0          BIC      r1,r1,#0xf0           ;4568
000086  ea411104          ORR      r1,r1,r4,LSL #4       ;4568
00008a  6191              STR      r1,[r2,#0x18]         ;4568
00008c  6801              LDR      r1,[r0,#0]            ;4568
00008e  f8c1c020          STR      r12,[r1,#0x20]        ;4568
000092  e029              B        |L85.232|
000094  6802              LDR      r2,[r0,#0]            ;4568
000096  f8d1c008          LDR      r12,[r1,#8]           ;4568
00009a  6909              LDR      r1,[r1,#0x10]         ;4568
00009c  6a14              LDR      r4,[r2,#0x20]         ;4568
00009e  6a15              LDR      r5,[r2,#0x20]         ;4568
0000a0  f0250601          BIC      r6,r5,#1              ;4568
0000a4  6216              STR      r6,[r2,#0x20]         ;4568
0000a6  f024050a          BIC      r5,r4,#0xa            ;4568
0000aa  6994              LDR      r4,[r2,#0x18]         ;4568
0000ac  ea450c0c          ORR      r12,r5,r12            ;4568
0000b0  f02404f0          BIC      r4,r4,#0xf0           ;4568
0000b4  ea441101          ORR      r1,r4,r1,LSL #4       ;4568
0000b8  6191              STR      r1,[r2,#0x18]         ;4568
0000ba  f8c2c020          STR      r12,[r2,#0x20]        ;4568
0000be  e013              B        |L85.232|
0000c0  6802              LDR      r2,[r0,#0]            ;4568
0000c2  f8d1c008          LDR      r12,[r1,#8]           ;4568
0000c6  690c              LDR      r4,[r1,#0x10]         ;4568
0000c8  6a11              LDR      r1,[r2,#0x20]         ;4568
0000ca  f0210110          BIC      r1,r1,#0x10           ;4568
0000ce  6211              STR      r1,[r2,#0x20]         ;4568
0000d0  6995              LDR      r5,[r2,#0x18]         ;4568
0000d2  6a11              LDR      r1,[r2,#0x20]         ;4568
0000d4  f4254570          BIC      r5,r5,#0xf000         ;4568
0000d8  f02101a0          BIC      r1,r1,#0xa0           ;4568
0000dc  ea453404          ORR      r4,r5,r4,LSL #12      ;4568
0000e0  6194              STR      r4,[r2,#0x18]         ;4568
0000e2  ea41110c          ORR      r1,r1,r12,LSL #4      ;4568
0000e6  6211              STR      r1,[r2,#0x20]         ;4568
                  |L85.232|
0000e8  6801              LDR      r1,[r0,#0]            ;4575
0000ea  2200              MOVS     r2,#0                 ;4582
0000ec  f8d1c00c          LDR      r12,[r1,#0xc]         ;4575
0000f0  f04c0c40          ORR      r12,r12,#0x40         ;4575
0000f4  f8c1c00c          STR      r12,[r1,#0xc]         ;4575
0000f8  6801              LDR      r1,[r0,#0]            ;4578
0000fa  f8d1c00c          LDR      r12,[r1,#0xc]         ;4578
0000fe  f42c4c80          BIC      r12,r12,#0x4000       ;4578
000102  f8c1c00c          STR      r12,[r1,#0xc]         ;4578
000106  6403              STR      r3,[r0,#0x40]         ;4580
000108  63c2              STR      r2,[r0,#0x3c]         ;4584
00010a  4610              MOV      r0,r2                 ;4584
00010c  bc70              POP      {r4-r6}
00010e  4770              BX       lr
;;;4586   
                          ENDP


                          AREA ||i.HAL_TIM_TriggerCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_TriggerCallback PROC
;;;4751     */
;;;4752   __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4753   {
;;;4754     /* Prevent unused argument(s) compilation warning */
;;;4755     UNUSED(htim);
;;;4756    
;;;4757     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4758               the HAL_TIM_TriggerCallback could be implemented in the user file
;;;4759      */
;;;4760   }
;;;4761   
                          ENDP


                          AREA ||i.TIM_Base_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_Base_SetConfig PROC
;;;5431     */
;;;5432   void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
000000  b4f0              PUSH     {r4-r7}
;;;5433   {
;;;5434     uint32_t tmpcr1 = 0;
;;;5435     tmpcr1 = TIMx->CR1;
;;;5436     
;;;5437     /* Set TIM Time Base Unit parameters ---------------------------------------*/
;;;5438     if(IS_TIM_CC3_INSTANCE(TIMx) != RESET)   
000002  4b2c              LDR      r3,|L87.180|
000004  4c2c              LDR      r4,|L87.184|
000006  4d2d              LDR      r5,|L87.188|
000008  4298              CMP      r0,r3
00000a  6802              LDR      r2,[r0,#0]            ;5435
00000c  4e2c              LDR      r6,|L87.192|
00000e  f8dfc0b4          LDR      r12,|L87.196|
000012  bf18              IT       NE
000014  f1b04f80          CMPNE    r0,#0x40000000
000018  d007              BEQ      |L87.42|
00001a  42a0              CMP      r0,r4
00001c  bf18              IT       NE
00001e  42a8              CMPNE    r0,r5
000020  d003              BEQ      |L87.42|
000022  42b0              CMP      r0,r6
000024  bf18              IT       NE
000026  4560              CMPNE    r0,r12
000028  d103              BNE      |L87.50|
                  |L87.42|
;;;5439     {
;;;5440       /* Select the Counter Mode */
;;;5441       tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
;;;5442       tmpcr1 |= Structure->CounterMode;
00002a  684f              LDR      r7,[r1,#4]
00002c  f0220270          BIC      r2,r2,#0x70           ;5441
000030  433a              ORRS     r2,r2,r7
                  |L87.50|
;;;5443     }
;;;5444    
;;;5445     if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)  
000032  4298              CMP      r0,r3
000034  bf18              IT       NE
000036  f1b04f80          CMPNE    r0,#0x40000000
00003a  d025              BEQ      |L87.136|
00003c  42a0              CMP      r0,r4
00003e  bf18              IT       NE
000040  42a8              CMPNE    r0,r5
000042  d021              BEQ      |L87.136|
000044  42b0              CMP      r0,r6
000046  bf18              IT       NE
000048  4560              CMPNE    r0,r12
00004a  d01d              BEQ      |L87.136|
00004c  f1a04480          SUB      r4,r0,#0x40000000
000050  f5b434a0          SUBS     r4,r4,#0x14000
000054  bf1c              ITT      NE
000056  f1a04480          SUBNE    r4,r0,#0x40000000
00005a  f5b434a2          SUBSNE   r4,r4,#0x14400
00005e  d013              BEQ      |L87.136|
000060  f1a04480          SUB      r4,r0,#0x40000000
000064  f5b434a4          SUBS     r4,r4,#0x14800
000068  bf1c              ITT      NE
00006a  f1a04480          SUBNE    r4,r0,#0x40000000
00006e  f5b454c0          SUBSNE   r4,r4,#0x1800
000072  d009              BEQ      |L87.136|
000074  f1a04480          SUB      r4,r0,#0x40000000
000078  f5b454e0          SUBS     r4,r4,#0x1c00
00007c  bf1c              ITT      NE
00007e  f1a04480          SUBNE    r4,r0,#0x40000000
000082  f5b45400          SUBSNE   r4,r4,#0x2000
000086  d103              BNE      |L87.144|
                  |L87.136|
;;;5446     {
;;;5447       /* Set the clock division */
;;;5448       tmpcr1 &= ~TIM_CR1_CKD;
;;;5449       tmpcr1 |= (uint32_t)Structure->ClockDivision;
000088  68cc              LDR      r4,[r1,#0xc]
00008a  f4227240          BIC      r2,r2,#0x300          ;5448
00008e  4322              ORRS     r2,r2,r4
                  |L87.144|
;;;5450     }
;;;5451   
;;;5452     /* Set the auto-reload preload */
;;;5453     MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
000090  694c              LDR      r4,[r1,#0x14]
000092  f0220280          BIC      r2,r2,#0x80
000096  4322              ORRS     r2,r2,r4
;;;5454   
;;;5455     TIMx->CR1 = tmpcr1;
000098  6002              STR      r2,[r0,#0]
;;;5456   
;;;5457     /* Set the Auto-reload value */
;;;5458     TIMx->ARR = (uint32_t)Structure->Period ;
;;;5459    
;;;5460     /* Set the Prescaler value */
;;;5461     TIMx->PSC = (uint32_t)Structure->Prescaler;
;;;5462       
;;;5463     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)  
00009a  4298              CMP      r0,r3
00009c  688a              LDR      r2,[r1,#8]            ;5458
00009e  62c2              STR      r2,[r0,#0x2c]         ;5458
0000a0  680a              LDR      r2,[r1,#0]            ;5461
0000a2  6282              STR      r2,[r0,#0x28]         ;5461
0000a4  bf12              ITEE     NE
0000a6  4560              CMPNE    r0,r12
;;;5464     {
;;;5465       /* Set the Repetition Counter value */
;;;5466       TIMx->RCR = Structure->RepetitionCounter;
0000a8  6909              LDREQ    r1,[r1,#0x10]
0000aa  6301              STREQ    r1,[r0,#0x30]
;;;5467     }
;;;5468   
;;;5469     /* Generate an update event to reload the Prescaler 
;;;5470        and the repetition counter(only for TIM1 and TIM8) value immediately */
;;;5471     TIMx->EGR = TIM_EGR_UG;
0000ac  2101              MOVS     r1,#1
0000ae  6141              STR      r1,[r0,#0x14]
;;;5472   }
0000b0  bcf0              POP      {r4-r7}
0000b2  4770              BX       lr
;;;5473   
                          ENDP

                  |L87.180|
                          DCD      0x40010000
                  |L87.184|
                          DCD      0x40000400
                  |L87.188|
                          DCD      0x40000800
                  |L87.192|
                          DCD      0x40000c00
                  |L87.196|
                          DCD      0x40010400

                          AREA ||i.TIM_CCxChannelCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxChannelCmd PROC
;;;6205     */
;;;6206   void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
000000  6a03              LDR      r3,[r0,#0x20]
;;;6207   {
;;;6208     uint32_t tmp = 0;
;;;6209   
;;;6210     /* Check the parameters */
;;;6211     assert_param(IS_TIM_CC1_INSTANCE(TIMx)); 
;;;6212     assert_param(IS_TIM_CHANNELS(Channel));
;;;6213   
;;;6214     tmp = TIM_CCER_CC1E << Channel;
000002  f04f0c01          MOV      r12,#1
;;;6215   
;;;6216     /* Reset the CCxE Bit */
;;;6217     TIMx->CCER &= ~tmp;
;;;6218   
;;;6219     /* Set or reset the CCxE Bit */ 
;;;6220     TIMx->CCER |= (uint32_t)(ChannelState << Channel);
000006  408a              LSLS     r2,r2,r1
000008  fa0cf101          LSL      r1,r12,r1             ;6214
00000c  ea230101          BIC      r1,r3,r1              ;6217
000010  6201              STR      r1,[r0,#0x20]         ;6217
000012  6a01              LDR      r1,[r0,#0x20]
000014  4311              ORRS     r1,r1,r2
000016  6201              STR      r1,[r0,#0x20]
;;;6221   }
000018  4770              BX       lr
;;;6222   
                          ENDP


                          AREA ||i.TIM_DMACaptureCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMACaptureCplt PROC
;;;5358     */
;;;5359   void HAL_TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;5360   {
;;;5361     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
;;;5362       
;;;5363      htim->State= HAL_TIM_STATE_READY; 
000002  6bc4              LDR      r4,[r0,#0x3c]
000004  2101              MOVS     r1,#1
000006  6421              STR      r1,[r4,#0x40]
;;;5364       
;;;5365     if (hdma == htim->hdma[TIM_DMA_ID_CC1])
000008  6a62              LDR      r2,[r4,#0x24]
00000a  4282              CMP      r2,r0
;;;5366     {
;;;5367       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
00000c  bf08              IT       EQ
00000e  61e1              STREQ    r1,[r4,#0x1c]
000010  d010              BEQ      |L89.52|
;;;5368     }
;;;5369     else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
000012  6aa1              LDR      r1,[r4,#0x28]
000014  4281              CMP      r1,r0
;;;5370     {
;;;5371       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
000016  bf04              ITT      EQ
000018  2002              MOVEQ    r0,#2
00001a  61e0              STREQ    r0,[r4,#0x1c]
00001c  d00a              BEQ      |L89.52|
;;;5372     }
;;;5373     else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
00001e  6ae1              LDR      r1,[r4,#0x2c]
000020  4281              CMP      r1,r0
;;;5374     {
;;;5375       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000022  bf08              IT       EQ
000024  2004              MOVEQ    r0,#4
000026  d004              BEQ      |L89.50|
;;;5376     }
;;;5377     else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
000028  6b21              LDR      r1,[r4,#0x30]
00002a  4281              CMP      r1,r0
;;;5378     {
;;;5379       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
00002c  bf08              IT       EQ
00002e  2008              MOVEQ    r0,#8
000030  d100              BNE      |L89.52|
                  |L89.50|
000032  61e0              STR      r0,[r4,#0x1c]
                  |L89.52|
;;;5380     }
;;;5381   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;5382     htim->IC_CaptureCallback(htim);
;;;5383   #else
;;;5384     HAL_TIM_IC_CaptureCallback(htim);
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
;;;5385   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;5386     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
00003a  2000              MOVS     r0,#0
00003c  61e0              STR      r0,[r4,#0x1c]
;;;5387   
;;;5388   }
00003e  bd10              POP      {r4,pc}
;;;5389   
                          ENDP


                          AREA ||i.TIM_DMADelayPulseCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMADelayPulseCplt PROC
;;;5322     */
;;;5323   void HAL_TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;5324   {
;;;5325     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
;;;5326     
;;;5327     htim->State= HAL_TIM_STATE_READY; 
000002  6bc4              LDR      r4,[r0,#0x3c]
000004  2101              MOVS     r1,#1
000006  6421              STR      r1,[r4,#0x40]
;;;5328     
;;;5329     if (hdma == htim->hdma[TIM_DMA_ID_CC1])
000008  6a62              LDR      r2,[r4,#0x24]
00000a  4282              CMP      r2,r0
;;;5330     {
;;;5331       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
00000c  bf08              IT       EQ
00000e  61e1              STREQ    r1,[r4,#0x1c]
000010  d010              BEQ      |L90.52|
;;;5332     }
;;;5333     else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
000012  6aa1              LDR      r1,[r4,#0x28]
000014  4281              CMP      r1,r0
;;;5334     {
;;;5335       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
000016  bf04              ITT      EQ
000018  2002              MOVEQ    r0,#2
00001a  61e0              STREQ    r0,[r4,#0x1c]
00001c  d00a              BEQ      |L90.52|
;;;5336     }
;;;5337     else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
00001e  6ae1              LDR      r1,[r4,#0x2c]
000020  4281              CMP      r1,r0
;;;5338     {
;;;5339       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000022  bf08              IT       EQ
000024  2004              MOVEQ    r0,#4
000026  d004              BEQ      |L90.50|
;;;5340     }
;;;5341     else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
000028  6b21              LDR      r1,[r4,#0x30]
00002a  4281              CMP      r1,r0
;;;5342     {
;;;5343       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
00002c  bf08              IT       EQ
00002e  2008              MOVEQ    r0,#8
000030  d100              BNE      |L90.52|
                  |L90.50|
000032  61e0              STR      r0,[r4,#0x1c]
                  |L90.52|
;;;5344     }
;;;5345   
;;;5346   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;5347     htim->PWM_PulseFinishedCallback(htim);
;;;5348   #else
;;;5349     HAL_TIM_PWM_PulseFinishedCallback(htim);
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
;;;5350   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;5351     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
00003a  2000              MOVS     r0,#0
00003c  61e0              STR      r0,[r4,#0x1c]
;;;5352   }
00003e  bd10              POP      {r4,pc}
;;;5353   /**
                          ENDP


                          AREA ||i.TIM_DMAError||, CODE, READONLY, ALIGN=1

                  TIM_DMAError PROC
;;;5304     */
;;;5305   void HAL_TIM_DMAError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;5306   {
;;;5307     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;5308     
;;;5309     htim->State= HAL_TIM_STATE_READY;
000004  2101              MOVS     r1,#1
000006  6401              STR      r1,[r0,#0x40]
;;;5310   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;5311      htim->ErrorCallback(htim);
;;;5312   #else
;;;5313     HAL_TIM_ErrorCallback(htim);
000008  f7fffffe          BL       HAL_TIM_ErrorCallback
;;;5314   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;5315   }
00000c  bd10              POP      {r4,pc}
;;;5316   
                          ENDP


                          AREA ||i.TIM_DMAPeriodElapsedCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMAPeriodElapsedCplt PROC
;;;5395     */
;;;5396   static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;5397   {
;;;5398     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;5399   
;;;5400     htim->State= HAL_TIM_STATE_READY;
000004  2101              MOVS     r1,#1
000006  6401              STR      r1,[r0,#0x40]
;;;5401   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;5402     htim->PeriodElapsedCallback(htim);
;;;5403   #else
;;;5404     HAL_TIM_PeriodElapsedCallback(htim);
000008  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
;;;5405   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;5406   }
00000c  bd10              POP      {r4,pc}
;;;5407   
                          ENDP


                          AREA ||i.TIM_DMATriggerCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMATriggerCplt PROC
;;;5413     */
;;;5414   static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;5415   {
;;;5416     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;  
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;5417     
;;;5418     htim->State= HAL_TIM_STATE_READY; 
000004  2101              MOVS     r1,#1
000006  6401              STR      r1,[r0,#0x40]
;;;5419   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;5420     htim->TriggerCallback(htim);
;;;5421   #else
;;;5422     HAL_TIM_TriggerCallback(htim);
000008  f7fffffe          BL       HAL_TIM_TriggerCallback
;;;5423    #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;5424   }
00000c  bd10              POP      {r4,pc}
;;;5425   
                          ENDP


                          AREA ||i.TIM_ETR_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_ETR_SetConfig PROC
;;;6175     */
;;;6176   void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
000000  ea422303          ORR      r3,r2,r3,LSL #8
;;;6177                          uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
;;;6178   {
;;;6179     uint32_t tmpsmcr = 0;
;;;6180   
;;;6181     tmpsmcr = TIMx->SMCR;
000004  6882              LDR      r2,[r0,#8]
;;;6182   
;;;6183     /* Reset the ETR Bits */
;;;6184     tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
;;;6185   
;;;6186     /* Set the Prescaler, the Filter value and the Polarity */
;;;6187     tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8)));
000006  430b              ORRS     r3,r3,r1
000008  f422417f          BIC      r1,r2,#0xff00         ;6184
00000c  4319              ORRS     r1,r1,r3
;;;6188   
;;;6189     /* Write to TIMx SMCR */
;;;6190     TIMx->SMCR = tmpsmcr;
00000e  6081              STR      r1,[r0,#8]
;;;6191   } 
000010  4770              BX       lr
;;;6192   
                          ENDP


                          AREA ||i.TIM_OC1_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1_SetConfig PROC
;;;5479     */
;;;5480   void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b470              PUSH     {r4-r6}
;;;5481   {
;;;5482     uint32_t tmpccmrx = 0;
;;;5483     uint32_t tmpccer = 0;
;;;5484     uint32_t tmpcr2 = 0;  
;;;5485   
;;;5486     /* Disable the Channel 1: Reset the CC1E Bit */
;;;5487     TIMx->CCER &= ~TIM_CCER_CC1E;
000002  6a02              LDR      r2,[r0,#0x20]
;;;5488     
;;;5489     /* Get the TIMx CCER register value */
;;;5490     tmpccer = TIMx->CCER;
;;;5491     /* Get the TIMx CR2 register value */
;;;5492     tmpcr2 = TIMx->CR2;
;;;5493     
;;;5494     /* Get the TIMx CCMR1 register value */
;;;5495     tmpccmrx = TIMx->CCMR1;
;;;5496       
;;;5497     /* Reset the Output Compare Mode Bits */
;;;5498     tmpccmrx &= ~TIM_CCMR1_OC1M;
;;;5499     tmpccmrx &= ~TIM_CCMR1_CC1S;
;;;5500     /* Select the Output Compare Mode */
;;;5501     tmpccmrx |= OC_Config->OCMode;
;;;5502     
;;;5503     /* Reset the Output Polarity level */
;;;5504     tmpccer &= ~TIM_CCER_CC1P;
;;;5505     /* Set the Output Compare Polarity */
;;;5506     tmpccer |= OC_Config->OCPolarity;
;;;5507   
;;;5508       
;;;5509     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
000004  f1a04380          SUB      r3,r0,#0x40000000
000008  f5b33380          SUBS     r3,r3,#0x10000
00000c  f0220201          BIC      r2,r2,#1              ;5487
000010  6202              STR      r2,[r0,#0x20]         ;5487
000012  6a03              LDR      r3,[r0,#0x20]         ;5490
000014  6842              LDR      r2,[r0,#4]            ;5492
000016  f8d0c018          LDR      r12,[r0,#0x18]        ;5495
00001a  f0230302          BIC      r3,r3,#2              ;5504
00001e  688d              LDR      r5,[r1,#8]            ;5506
000020  680c              LDR      r4,[r1,#0]            ;5501
000022  f02c0c73          BIC      r12,r12,#0x73         ;5499
000026  f42c3c80          BIC      r12,r12,#0x10000      ;5499
00002a  ea450303          ORR      r3,r5,r3              ;5506
00002e  ea440c0c          ORR      r12,r4,r12            ;5501
000032  bf1c              ITT      NE
000034  f1a04480          SUBNE    r4,r0,#0x40000000
000038  f5b43482          SUBSNE   r4,r4,#0x10400
00003c  d10b              BNE      |L95.86|
;;;5510     {   
;;;5511       /* Reset the Output N Polarity level */
;;;5512       tmpccer &= ~TIM_CCER_CC1NP;
;;;5513       /* Set the Output N Polarity */
;;;5514       tmpccer |= OC_Config->OCNPolarity;
00003e  68ce              LDR      r6,[r1,#0xc]
000040  f0230308          BIC      r3,r3,#8              ;5512
000044  e9d14505          LDRD     r4,r5,[r1,#0x14]
000048  4333              ORRS     r3,r3,r6
;;;5515       /* Reset the Output N State */
;;;5516       tmpccer &= ~TIM_CCER_CC1NE;
;;;5517       
;;;5518       /* Reset the Output Compare and Output Compare N IDLE State */
;;;5519       tmpcr2 &= ~TIM_CR2_OIS1;
;;;5520       tmpcr2 &= ~TIM_CR2_OIS1N;
00004a  f4227240          BIC      r2,r2,#0x300
;;;5521       /* Set the Output Idle state */
;;;5522       tmpcr2 |= OC_Config->OCIdleState;
00004e  4322              ORRS     r2,r2,r4
;;;5523       /* Set the Output N Idle state */
;;;5524       tmpcr2 |= OC_Config->OCNIdleState;
000050  432a              ORRS     r2,r2,r5
000052  f0230304          BIC      r3,r3,#4              ;5516
                  |L95.86|
;;;5525     }
;;;5526     /* Write to TIMx CR2 */
;;;5527     TIMx->CR2 = tmpcr2;
000056  6042              STR      r2,[r0,#4]
;;;5528     
;;;5529     /* Write to TIMx CCMR1 */
;;;5530     TIMx->CCMR1 = tmpccmrx;
000058  f8c0c018          STR      r12,[r0,#0x18]
;;;5531     
;;;5532     /* Set the Capture Compare Register value */
;;;5533     TIMx->CCR1 = OC_Config->Pulse;
00005c  6849              LDR      r1,[r1,#4]
00005e  6341              STR      r1,[r0,#0x34]
;;;5534     
;;;5535     /* Write to TIMx CCER */
;;;5536     TIMx->CCER = tmpccer;  
000060  6203              STR      r3,[r0,#0x20]
;;;5537   } 
000062  bc70              POP      {r4-r6}
000064  4770              BX       lr
;;;5538   
                          ENDP


                          AREA ||i.TIM_OC2_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2_SetConfig PROC
;;;5544     */
;;;5545   void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b470              PUSH     {r4-r6}
;;;5546   {
;;;5547     uint32_t tmpccmrx = 0;
;;;5548     uint32_t tmpccer = 0;
;;;5549     uint32_t tmpcr2 = 0;
;;;5550      
;;;5551     /* Disable the Channel 2: Reset the CC2E Bit */
;;;5552     TIMx->CCER &= ~TIM_CCER_CC2E;
000002  6a02              LDR      r2,[r0,#0x20]
;;;5553     
;;;5554     /* Get the TIMx CCER register value */  
;;;5555     tmpccer = TIMx->CCER;
;;;5556     /* Get the TIMx CR2 register value */
;;;5557     tmpcr2 = TIMx->CR2;
;;;5558     
;;;5559     /* Get the TIMx CCMR1 register value */
;;;5560     tmpccmrx = TIMx->CCMR1;
;;;5561       
;;;5562     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;5563     tmpccmrx &= ~TIM_CCMR1_OC2M;
;;;5564     tmpccmrx &= ~TIM_CCMR1_CC2S;
;;;5565     
;;;5566     /* Select the Output Compare Mode */
;;;5567     tmpccmrx |= (OC_Config->OCMode << 8);
;;;5568     
;;;5569     /* Reset the Output Polarity level */
;;;5570     tmpccer &= ~TIM_CCER_CC2P;
;;;5571     /* Set the Output Compare Polarity */
;;;5572     tmpccer |= (OC_Config->OCPolarity << 4);
;;;5573       
;;;5574     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
000004  f1a04380          SUB      r3,r0,#0x40000000
000008  f5b33380          SUBS     r3,r3,#0x10000
00000c  f0220210          BIC      r2,r2,#0x10           ;5552
000010  6202              STR      r2,[r0,#0x20]         ;5552
000012  6a03              LDR      r3,[r0,#0x20]         ;5555
000014  6842              LDR      r2,[r0,#4]            ;5557
000016  f8d0c018          LDR      r12,[r0,#0x18]        ;5560
00001a  f0230320          BIC      r3,r3,#0x20           ;5570
00001e  688d              LDR      r5,[r1,#8]            ;5572
000020  680c              LDR      r4,[r1,#0]            ;5567
000022  f42c4ce6          BIC      r12,r12,#0x7300       ;5564
000026  f02c7c80          BIC      r12,r12,#0x1000000    ;5564
00002a  ea431305          ORR      r3,r3,r5,LSL #4       ;5572
00002e  ea4c2c04          ORR      r12,r12,r4,LSL #8     ;5567
000032  bf1c              ITT      NE
000034  f1a04480          SUBNE    r4,r0,#0x40000000
000038  f5b43482          SUBSNE   r4,r4,#0x10400
00003c  d10e              BNE      |L96.92|
;;;5575     {
;;;5576       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;5577       
;;;5578       /* Reset the Output N Polarity level */
;;;5579       tmpccer &= ~TIM_CCER_CC2NP;
;;;5580       /* Set the Output N Polarity */
;;;5581       tmpccer |= (OC_Config->OCNPolarity << 4);
00003e  68ce              LDR      r6,[r1,#0xc]
000040  f0230380          BIC      r3,r3,#0x80           ;5579
000044  e9d14505          LDRD     r4,r5,[r1,#0x14]
;;;5582       /* Reset the Output N State */
;;;5583       tmpccer &= ~TIM_CCER_CC2NE;
;;;5584       
;;;5585       /* Reset the Output Compare and Output Compare N IDLE State */
;;;5586       tmpcr2 &= ~TIM_CR2_OIS2;
;;;5587       tmpcr2 &= ~TIM_CR2_OIS2N;
000048  f4226240          BIC      r2,r2,#0xc00
00004c  ea431306          ORR      r3,r3,r6,LSL #4       ;5581
;;;5588       /* Set the Output Idle state */
;;;5589       tmpcr2 |= (OC_Config->OCIdleState << 2);
000050  ea420284          ORR      r2,r2,r4,LSL #2
000054  f0230340          BIC      r3,r3,#0x40           ;5583
;;;5590       /* Set the Output N Idle state */
;;;5591       tmpcr2 |= (OC_Config->OCNIdleState << 2);
000058  ea420285          ORR      r2,r2,r5,LSL #2
                  |L96.92|
;;;5592     }
;;;5593     /* Write to TIMx CR2 */
;;;5594     TIMx->CR2 = tmpcr2;
00005c  6042              STR      r2,[r0,#4]
;;;5595     
;;;5596     /* Write to TIMx CCMR1 */
;;;5597     TIMx->CCMR1 = tmpccmrx;
00005e  f8c0c018          STR      r12,[r0,#0x18]
;;;5598     
;;;5599     /* Set the Capture Compare Register value */
;;;5600     TIMx->CCR2 = OC_Config->Pulse;
000062  6849              LDR      r1,[r1,#4]
000064  6381              STR      r1,[r0,#0x38]
;;;5601     
;;;5602     /* Write to TIMx CCER */
;;;5603     TIMx->CCER = tmpccer;
000066  6203              STR      r3,[r0,#0x20]
;;;5604   }
000068  bc70              POP      {r4-r6}
00006a  4770              BX       lr
;;;5605   
                          ENDP


                          AREA ||i.TIM_OC3_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3_SetConfig PROC
;;;5611     */
;;;5612   void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b470              PUSH     {r4-r6}
;;;5613   {
;;;5614     uint32_t tmpccmrx = 0;
;;;5615     uint32_t tmpccer = 0;
;;;5616     uint32_t tmpcr2 = 0;   
;;;5617   
;;;5618     /* Disable the Channel 3: Reset the CC2E Bit */
;;;5619     TIMx->CCER &= ~TIM_CCER_CC3E;
000002  6a02              LDR      r2,[r0,#0x20]
;;;5620     
;;;5621     /* Get the TIMx CCER register value */
;;;5622     tmpccer = TIMx->CCER;
;;;5623     /* Get the TIMx CR2 register value */
;;;5624     tmpcr2 = TIMx->CR2;
;;;5625     
;;;5626     /* Get the TIMx CCMR2 register value */
;;;5627     tmpccmrx = TIMx->CCMR2;
;;;5628       
;;;5629     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;5630     tmpccmrx &= ~TIM_CCMR2_OC3M;
;;;5631     tmpccmrx &= ~TIM_CCMR2_CC3S;  
;;;5632     /* Select the Output Compare Mode */
;;;5633     tmpccmrx |= OC_Config->OCMode;
;;;5634     
;;;5635     /* Reset the Output Polarity level */
;;;5636     tmpccer &= ~TIM_CCER_CC3P;
;;;5637     /* Set the Output Compare Polarity */
;;;5638     tmpccer |= (OC_Config->OCPolarity << 8);
;;;5639       
;;;5640     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
000004  f1a04380          SUB      r3,r0,#0x40000000
000008  f5b33380          SUBS     r3,r3,#0x10000
00000c  f4227280          BIC      r2,r2,#0x100          ;5619
000010  6202              STR      r2,[r0,#0x20]         ;5619
000012  6a03              LDR      r3,[r0,#0x20]         ;5622
000014  6842              LDR      r2,[r0,#4]            ;5624
000016  f8d0c01c          LDR      r12,[r0,#0x1c]        ;5627
00001a  f4237300          BIC      r3,r3,#0x200          ;5636
00001e  688d              LDR      r5,[r1,#8]            ;5638
000020  680c              LDR      r4,[r1,#0]            ;5633
000022  f02c0c73          BIC      r12,r12,#0x73         ;5631
000026  f42c3c80          BIC      r12,r12,#0x10000      ;5631
00002a  ea432305          ORR      r3,r3,r5,LSL #8       ;5638
00002e  ea440c0c          ORR      r12,r4,r12            ;5633
000032  bf1c              ITT      NE
000034  f1a04480          SUBNE    r4,r0,#0x40000000
000038  f5b43482          SUBSNE   r4,r4,#0x10400
00003c  d10e              BNE      |L97.92|
;;;5641     {
;;;5642       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;5643       
;;;5644       /* Reset the Output N Polarity level */
;;;5645       tmpccer &= ~TIM_CCER_CC3NP;
;;;5646       /* Set the Output N Polarity */
;;;5647       tmpccer |= (OC_Config->OCNPolarity << 8);
00003e  68ce              LDR      r6,[r1,#0xc]
000040  f4236300          BIC      r3,r3,#0x800          ;5645
000044  e9d14505          LDRD     r4,r5,[r1,#0x14]
;;;5648       /* Reset the Output N State */
;;;5649       tmpccer &= ~TIM_CCER_CC3NE;
;;;5650       
;;;5651       /* Reset the Output Compare and Output Compare N IDLE State */
;;;5652       tmpcr2 &= ~TIM_CR2_OIS3;
;;;5653       tmpcr2 &= ~TIM_CR2_OIS3N;
000048  f4225240          BIC      r2,r2,#0x3000
00004c  ea432306          ORR      r3,r3,r6,LSL #8       ;5647
;;;5654       /* Set the Output Idle state */
;;;5655       tmpcr2 |= (OC_Config->OCIdleState << 4);
000050  ea421204          ORR      r2,r2,r4,LSL #4
000054  f4236380          BIC      r3,r3,#0x400          ;5649
;;;5656       /* Set the Output N Idle state */
;;;5657       tmpcr2 |= (OC_Config->OCNIdleState << 4);
000058  ea421205          ORR      r2,r2,r5,LSL #4
                  |L97.92|
;;;5658     }
;;;5659     /* Write to TIMx CR2 */
;;;5660     TIMx->CR2 = tmpcr2;
00005c  6042              STR      r2,[r0,#4]
;;;5661     
;;;5662     /* Write to TIMx CCMR2 */
;;;5663     TIMx->CCMR2 = tmpccmrx;
00005e  f8c0c01c          STR      r12,[r0,#0x1c]
;;;5664     
;;;5665     /* Set the Capture Compare Register value */
;;;5666     TIMx->CCR3 = OC_Config->Pulse;
000062  6849              LDR      r1,[r1,#4]
000064  63c1              STR      r1,[r0,#0x3c]
;;;5667     
;;;5668     /* Write to TIMx CCER */
;;;5669     TIMx->CCER = tmpccer;
000066  6203              STR      r3,[r0,#0x20]
;;;5670   }
000068  bc70              POP      {r4-r6}
00006a  4770              BX       lr
;;;5671   
                          ENDP


                          AREA ||i.TIM_OC4_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4_SetConfig PROC
;;;5677     */
;;;5678   void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b430              PUSH     {r4,r5}
;;;5679   {
;;;5680     uint32_t tmpccmrx = 0;
;;;5681     uint32_t tmpccer = 0;
;;;5682     uint32_t tmpcr2 = 0;
;;;5683   
;;;5684     /* Disable the Channel 4: Reset the CC4E Bit */
;;;5685     TIMx->CCER &= ~TIM_CCER_CC4E;
000002  6a02              LDR      r2,[r0,#0x20]
;;;5686     
;;;5687     /* Get the TIMx CCER register value */
;;;5688     tmpccer = TIMx->CCER;
;;;5689     /* Get the TIMx CR2 register value */
;;;5690     tmpcr2 = TIMx->CR2;
;;;5691     
;;;5692     /* Get the TIMx CCMR2 register value */
;;;5693     tmpccmrx = TIMx->CCMR2;
;;;5694       
;;;5695     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;5696     tmpccmrx &= ~TIM_CCMR2_OC4M;
;;;5697     tmpccmrx &= ~TIM_CCMR2_CC4S;
;;;5698     
;;;5699     /* Select the Output Compare Mode */
;;;5700     tmpccmrx |= (OC_Config->OCMode << 8);
;;;5701     
;;;5702     /* Reset the Output Polarity level */
;;;5703     tmpccer &= ~TIM_CCER_CC4P;
;;;5704     /* Set the Output Compare Polarity */
;;;5705     tmpccer |= (OC_Config->OCPolarity << 12);
;;;5706      
;;;5707     /*if((TIMx == TIM1) || (TIMx == TIM8))*/
;;;5708     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
000004  f1a04380          SUB      r3,r0,#0x40000000
000008  f5b33380          SUBS     r3,r3,#0x10000
00000c  f4225280          BIC      r2,r2,#0x1000         ;5685
000010  6202              STR      r2,[r0,#0x20]         ;5685
000012  6a03              LDR      r3,[r0,#0x20]         ;5688
000014  6842              LDR      r2,[r0,#4]            ;5690
000016  f8d0c01c          LDR      r12,[r0,#0x1c]        ;5693
00001a  f4235300          BIC      r3,r3,#0x2000         ;5703
00001e  688d              LDR      r5,[r1,#8]            ;5705
000020  680c              LDR      r4,[r1,#0]            ;5700
000022  f42c4ce6          BIC      r12,r12,#0x7300       ;5697
000026  f02c7c80          BIC      r12,r12,#0x1000000    ;5697
00002a  ea433305          ORR      r3,r3,r5,LSL #12      ;5705
00002e  ea4c2c04          ORR      r12,r12,r4,LSL #8     ;5700
000032  bf1c              ITT      NE
000034  f1a04480          SUBNE    r4,r0,#0x40000000
000038  f5b43482          SUBSNE   r4,r4,#0x10400
00003c  d104              BNE      |L98.72|
;;;5709     {
;;;5710       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;5711       /* Reset the Output Compare IDLE State */
;;;5712       tmpcr2 &= ~TIM_CR2_OIS4;
;;;5713       /* Set the Output Idle state */
;;;5714       tmpcr2 |= (OC_Config->OCIdleState << 6);
00003e  694c              LDR      r4,[r1,#0x14]
000040  f4224280          BIC      r2,r2,#0x4000         ;5712
000044  ea421284          ORR      r2,r2,r4,LSL #6
                  |L98.72|
;;;5715     }
;;;5716     /* Write to TIMx CR2 */
;;;5717     TIMx->CR2 = tmpcr2;
000048  6042              STR      r2,[r0,#4]
;;;5718     
;;;5719     /* Write to TIMx CCMR2 */  
;;;5720     TIMx->CCMR2 = tmpccmrx;
00004a  f8c0c01c          STR      r12,[r0,#0x1c]
;;;5721       
;;;5722     /* Set the Capture Compare Register value */
;;;5723     TIMx->CCR4 = OC_Config->Pulse;
00004e  6849              LDR      r1,[r1,#4]
000050  6401              STR      r1,[r0,#0x40]
;;;5724     
;;;5725     /* Write to TIMx CCER */
;;;5726     TIMx->CCER = tmpccer;
000052  6203              STR      r3,[r0,#0x20]
;;;5727   }
000054  bc30              POP      {r4,r5}
000056  4770              BX       lr
;;;5728   
                          ENDP


                          AREA ||i.TIM_TI1_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_TI1_SetConfig PROC
;;;5880     */
;;;5881   void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b430              PUSH     {r4,r5}
;;;5882                          uint32_t TIM_ICFilter)
;;;5883   {
;;;5884     uint32_t tmpccmr1 = 0;
;;;5885     uint32_t tmpccer = 0;
;;;5886   
;;;5887     /* Disable the Channel 1: Reset the CC1E Bit */
;;;5888     TIMx->CCER &= ~TIM_CCER_CC1E;
000002  f8d0c020          LDR      r12,[r0,#0x20]
;;;5889     tmpccmr1 = TIMx->CCMR1;
;;;5890     tmpccer = TIMx->CCER;
;;;5891   
;;;5892     /* Select the Input */
;;;5893     if(IS_TIM_CC2_INSTANCE(TIMx) != RESET)
000006  f1a04480          SUB      r4,r0,#0x40000000
00000a  f5b43480          SUBS     r4,r4,#0x10000
00000e  f02c0c01          BIC      r12,r12,#1            ;5888
000012  f8c0c020          STR      r12,[r0,#0x20]        ;5888
000016  f8d0c018          LDR      r12,[r0,#0x18]        ;5889
00001a  6a04              LDR      r4,[r0,#0x20]         ;5890
00001c  bf18              IT       NE
00001e  f1b04f80          CMPNE    r0,#0x40000000
000022  d01f              BEQ      |L99.100|
000024  f1a04580          SUB      r5,r0,#0x40000000
000028  f5b56580          SUBS     r5,r5,#0x400
00002c  bf1c              ITT      NE
00002e  f1a04580          SUBNE    r5,r0,#0x40000000
000032  f5b56500          SUBSNE   r5,r5,#0x800
000036  d015              BEQ      |L99.100|
000038  f1a04580          SUB      r5,r0,#0x40000000
00003c  f5b56540          SUBS     r5,r5,#0xc00
000040  bf1c              ITT      NE
000042  f1a04580          SUBNE    r5,r0,#0x40000000
000046  f5b53582          SUBSNE   r5,r5,#0x10400
00004a  d00b              BEQ      |L99.100|
00004c  f1a04580          SUB      r5,r0,#0x40000000
000050  f5b535a0          SUBS     r5,r5,#0x14000
000054  bf1e              ITTT     NE
000056  f1a04580          SUBNE    r5,r0,#0x40000000
00005a  f5b555c0          SUBSNE   r5,r5,#0x1800
;;;5894     {
;;;5895       tmpccmr1 &= ~TIM_CCMR1_CC1S;
;;;5896       tmpccmr1 |= TIM_ICSelection;
;;;5897     } 
;;;5898     else
;;;5899     {
;;;5900       tmpccmr1 |= TIM_CCMR1_CC1S_0;
00005e  f04c0201          ORRNE    r2,r12,#1
000062  d103              BNE      |L99.108|
                  |L99.100|
000064  f02c0c03          BIC      r12,r12,#3            ;5895
000068  ea4c0202          ORR      r2,r12,r2             ;5896
                  |L99.108|
;;;5901     }
;;;5902     
;;;5903     /* Set the filter */
;;;5904     tmpccmr1 &= ~TIM_CCMR1_IC1F;
;;;5905     tmpccmr1 |= ((TIM_ICFilter << 4) & TIM_CCMR1_IC1F);
00006c  f04f0cf0          MOV      r12,#0xf0
000070  ea0c1c03          AND      r12,r12,r3,LSL #4
;;;5906   
;;;5907     /* Select the Polarity and set the CC1E Bit */
;;;5908     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
000074  f024030a          BIC      r3,r4,#0xa
000078  f02202f0          BIC      r2,r2,#0xf0           ;5904
;;;5909     tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
00007c  f001040a          AND      r4,r1,#0xa
000080  ea4c0102          ORR      r1,r12,r2             ;5905
;;;5910   
;;;5911     /* Write to TIMx CCMR1 and CCER registers */
;;;5912     TIMx->CCMR1 = tmpccmr1;
000084  6181              STR      r1,[r0,#0x18]
000086  ea440203          ORR      r2,r4,r3              ;5909
;;;5913     TIMx->CCER = tmpccer;
00008a  6202              STR      r2,[r0,#0x20]
;;;5914   }
00008c  bc30              POP      {r4,r5}
00008e  4770              BX       lr
;;;5915   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F7_V1.11.0\\Drivers\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_tim.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_tim_c_a9d95b52____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F7_V1.11.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f7xx_hal_tim_c_a9d95b52____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_tim_c_a9d95b52____REVSH|
#line 402
|__asm___19_stm32f7xx_hal_tim_c_a9d95b52____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_tim_c_a9d95b52____RRX|
#line 587
|__asm___19_stm32f7xx_hal_tim_c_a9d95b52____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
