; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f7xx_hal_dma.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f7xx_hal_dma.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc\Conf -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f7xx_hal_dma.crf ..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_dma.c]
                          THUMB

                          AREA ||i.HAL_DMA_Abort||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Abort PROC
;;;531      */
;;;532    HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;533    {
;;;534      /* calculate DMA base and stream number */
;;;535      DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
;;;536      
;;;537      uint32_t tickstart = HAL_GetTick();
000004  6dc7              LDR      r7,[r0,#0x5c]
000006  4604              MOV      r4,r0                 ;533
000008  f7fffffe          BL       HAL_GetTick
00000c  4605              MOV      r5,r0
;;;538      
;;;539      if(hdma->State != HAL_DMA_STATE_BUSY)
00000e  6ba0              LDR      r0,[r4,#0x38]
000010  2600              MOVS     r6,#0
000012  2802              CMP      r0,#2
000014  d005              BEQ      |L1.34|
;;;540      {
;;;541        hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
000016  2080              MOVS     r0,#0x80
000018  65a0              STR      r0,[r4,#0x58]
;;;542        
;;;543        /* Process Unlocked */
;;;544        __HAL_UNLOCK(hdma);
;;;545        
;;;546        return HAL_ERROR;
00001a  2001              MOVS     r0,#1
00001c  6366              STR      r6,[r4,#0x34]
;;;547      }
;;;548      else
;;;549      {
;;;550        /* Disable all the transfer interrupts */
;;;551        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
;;;552        hdma->Instance->FCR &= ~(DMA_IT_FE);
;;;553        
;;;554        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
;;;555        {
;;;556          hdma->Instance->CR  &= ~(DMA_IT_HT);
;;;557        }
;;;558        
;;;559        /* Disable the stream */
;;;560        __HAL_DMA_DISABLE(hdma);
;;;561        
;;;562        /* Check if the DMA Stream is effectively disabled */
;;;563        while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
;;;564        {
;;;565          /* Check for the Timeout */
;;;566          if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
;;;567          {
;;;568            /* Update error code */
;;;569            hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
;;;570            
;;;571            /* Process Unlocked */
;;;572            __HAL_UNLOCK(hdma);
;;;573            
;;;574            /* Change the DMA state */
;;;575            hdma->State = HAL_DMA_STATE_TIMEOUT;
;;;576            
;;;577            return HAL_TIMEOUT;
;;;578          }
;;;579        }
;;;580        
;;;581        /* Clear all interrupt flags at correct offset within the register */
;;;582        regs->IFCR = 0x3FU << hdma->StreamIndex;
;;;583        
;;;584        /* Process Unlocked */
;;;585        __HAL_UNLOCK(hdma);
;;;586        
;;;587        /* Change the DMA state*/
;;;588        hdma->State = HAL_DMA_STATE_READY;
;;;589      }
;;;590      return HAL_OK;
;;;591    }
00001e  e8bd81f0          POP      {r4-r8,pc}
                  |L1.34|
000022  6820              LDR      r0,[r4,#0]            ;551
000024  6801              LDR      r1,[r0,#0]            ;551
000026  f0210116          BIC      r1,r1,#0x16           ;551
00002a  6001              STR      r1,[r0,#0]            ;551
00002c  6820              LDR      r0,[r4,#0]            ;552
00002e  6941              LDR      r1,[r0,#0x14]         ;552
000030  f0210180          BIC      r1,r1,#0x80           ;552
000034  6141              STR      r1,[r0,#0x14]         ;552
000036  6c60              LDR      r0,[r4,#0x44]         ;554
000038  2800              CMP      r0,#0                 ;554
00003a  bf04              ITT      EQ                    ;554
00003c  6ce0              LDREQ    r0,[r4,#0x4c]         ;554
00003e  2800              CMPEQ    r0,#0                 ;554
000040  d004              BEQ      |L1.76|
000042  6820              LDR      r0,[r4,#0]            ;556
000044  6801              LDR      r1,[r0,#0]            ;556
000046  f0210108          BIC      r1,r1,#8              ;556
00004a  6001              STR      r1,[r0,#0]            ;556
                  |L1.76|
00004c  6820              LDR      r0,[r4,#0]            ;560
00004e  6801              LDR      r1,[r0,#0]            ;560
000050  f0210101          BIC      r1,r1,#1              ;560
000054  6001              STR      r1,[r0,#0]            ;560
000056  6820              LDR      r0,[r4,#0]            ;563
000058  6800              LDR      r0,[r0,#0]            ;563
00005a  f0100f01          TST      r0,#1                 ;563
00005e  d010              BEQ      |L1.130|
                  |L1.96|
000060  f7fffffe          BL       HAL_GetTick
000064  1b40              SUBS     r0,r0,r5              ;566
000066  2805              CMP      r0,#5                 ;566
000068  d906              BLS      |L1.120|
00006a  2120              MOVS     r1,#0x20              ;569
00006c  65a1              STR      r1,[r4,#0x58]         ;569
00006e  2003              MOVS     r0,#3                 ;575
000070  6366              STR      r6,[r4,#0x34]         ;575
000072  63a0              STR      r0,[r4,#0x38]         ;575
000074  e8bd81f0          POP      {r4-r8,pc}
                  |L1.120|
000078  6820              LDR      r0,[r4,#0]            ;577
00007a  6800              LDR      r0,[r0,#0]            ;577
00007c  f0100f01          TST      r0,#1                 ;577
000080  d1ee              BNE      |L1.96|
                  |L1.130|
000082  f8941060          LDRB     r1,[r4,#0x60]         ;582
000086  223f              MOVS     r2,#0x3f              ;582
000088  2001              MOVS     r0,#1                 ;588
00008a  fa02f101          LSL      r1,r2,r1              ;582
00008e  60b9              STR      r1,[r7,#8]            ;582
000090  6366              STR      r6,[r4,#0x34]         ;588
000092  63a0              STR      r0,[r4,#0x38]         ;588
000094  2000              MOVS     r0,#0                 ;590
000096  e8bd81f0          POP      {r4-r8,pc}
;;;592    
                          ENDP


                          AREA ||i.HAL_DMA_Abort_IT||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Abort_IT PROC
;;;598      */
;;;599    HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
000000  6b81              LDR      r1,[r0,#0x38]
;;;600    {
;;;601      if(hdma->State != HAL_DMA_STATE_BUSY)
000002  2902              CMP      r1,#2
000004  d003              BEQ      |L2.14|
;;;602      {
;;;603        hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
000006  2180              MOVS     r1,#0x80
000008  6581              STR      r1,[r0,#0x58]
;;;604        return HAL_ERROR;
00000a  2001              MOVS     r0,#1
;;;605      }
;;;606      else
;;;607      {
;;;608        /* Set Abort State  */
;;;609        hdma->State = HAL_DMA_STATE_ABORT;
;;;610        
;;;611        /* Disable the stream */
;;;612        __HAL_DMA_DISABLE(hdma);
;;;613      }
;;;614    
;;;615      return HAL_OK;
;;;616    }
00000c  4770              BX       lr
                  |L2.14|
00000e  2105              MOVS     r1,#5                 ;609
000010  6381              STR      r1,[r0,#0x38]         ;609
000012  6800              LDR      r0,[r0,#0]            ;612
000014  6801              LDR      r1,[r0,#0]            ;612
000016  f0210101          BIC      r1,r1,#1              ;612
00001a  6001              STR      r1,[r0,#0]            ;612
00001c  2000              MOVS     r0,#0                 ;615
00001e  4770              BX       lr
;;;617    
                          ENDP


                          AREA ||i.HAL_DMA_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_DMA_DeInit PROC
;;;326      */
;;;327    HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
000000  2800              CMP      r0,#0
;;;328    {
;;;329      DMA_Base_Registers *regs;
;;;330    
;;;331      /* Check the DMA peripheral state */
;;;332      if(hdma == NULL)
;;;333      {
;;;334        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;335      }
;;;336      
;;;337      /* Check the DMA peripheral state */
;;;338      if(hdma->State == HAL_DMA_STATE_BUSY)
;;;339      {
;;;340        /* Return error status */
;;;341        return HAL_BUSY;
;;;342      }
;;;343    
;;;344      /* Check the parameters */
;;;345      assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance));
;;;346    
;;;347      /* Disable the selected DMA Streamx */
;;;348      __HAL_DMA_DISABLE(hdma);
;;;349    
;;;350      /* Reset DMA Streamx control register */
;;;351      hdma->Instance->CR   = 0U;
;;;352    
;;;353      /* Reset DMA Streamx number of data to transfer register */
;;;354      hdma->Instance->NDTR = 0U;
;;;355    
;;;356      /* Reset DMA Streamx peripheral address register */
;;;357      hdma->Instance->PAR  = 0U;
;;;358    
;;;359      /* Reset DMA Streamx memory 0 address register */
;;;360      hdma->Instance->M0AR = 0U;
;;;361      
;;;362      /* Reset DMA Streamx memory 1 address register */
;;;363      hdma->Instance->M1AR = 0U;
;;;364      
;;;365      /* Reset DMA Streamx FIFO control register */
;;;366      hdma->Instance->FCR  = (uint32_t)0x00000021U;
;;;367      
;;;368      /* Get DMA steam Base Address */  
;;;369      regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
;;;370      
;;;371      /* Clear all interrupt flags at correct offset within the register */
;;;372      regs->IFCR = 0x3FU << hdma->StreamIndex;
;;;373      
;;;374      /* Clean all callbacks */
;;;375      hdma->XferCpltCallback = NULL;
;;;376      hdma->XferHalfCpltCallback = NULL;
;;;377      hdma->XferM1CpltCallback = NULL;
;;;378      hdma->XferM1HalfCpltCallback = NULL;
;;;379      hdma->XferErrorCallback = NULL;
;;;380      hdma->XferAbortCallback = NULL;  
;;;381    
;;;382      /* Reset the error code */
;;;383      hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;384    
;;;385      /* Reset the DMA state */
;;;386      hdma->State = HAL_DMA_STATE_RESET;
;;;387    
;;;388      /* Release Lock */
;;;389      __HAL_UNLOCK(hdma);
;;;390    
;;;391      return HAL_OK;
;;;392    }
000006  4770              BXEQ     lr
000008  6b81              LDR      r1,[r0,#0x38]         ;338
00000a  2902              CMP      r1,#2                 ;338
00000c  bf04              ITT      EQ                    ;341
00000e  2002              MOVEQ    r0,#2                 ;341
000010  4770              BXEQ     lr
000012  2100              MOVS     r1,#0                 ;351
000014  6802              LDR      r2,[r0,#0]            ;348
000016  2321              MOVS     r3,#0x21              ;366
000018  f8d2c000          LDR      r12,[r2,#0]           ;348
00001c  f02c0c01          BIC      r12,r12,#1            ;348
000020  f8c2c000          STR      r12,[r2,#0]           ;348
000024  6802              LDR      r2,[r0,#0]            ;351
000026  6011              STR      r1,[r2,#0]            ;351
000028  6802              LDR      r2,[r0,#0]            ;354
00002a  6051              STR      r1,[r2,#4]            ;354
00002c  6802              LDR      r2,[r0,#0]            ;357
00002e  6091              STR      r1,[r2,#8]            ;357
000030  6802              LDR      r2,[r0,#0]            ;360
000032  60d1              STR      r1,[r2,#0xc]          ;360
000034  6802              LDR      r2,[r0,#0]            ;363
000036  6111              STR      r1,[r2,#0x10]         ;363
000038  6802              LDR      r2,[r0,#0]            ;366
00003a  6153              STR      r3,[r2,#0x14]         ;366
00003c  6802              LDR      r2,[r0,#0]            ;366
00003e  4b11              LDR      r3,|L3.132|
000040  f0020cff          AND      r12,r2,#0xff          ;366
000044  f1ac0c10          SUB      r12,r12,#0x10         ;366
000048  f36f0209          BFC      r2,#0,#10             ;366
00004c  fba3c30c          UMULL    r12,r3,r3,r12         ;366
000050  f8dfc034          LDR      r12,|L3.136|
000054  091b              LSRS     r3,r3,#4              ;366
000056  2b03              CMP      r3,#3                 ;366
000058  f81cc003          LDRB     r12,[r12,r3]          ;366
00005c  f8c0c060          STR      r12,[r0,#0x60]        ;366
000060  bf88              IT       HI                    ;366
000062  1d12              ADDHI    r2,r2,#4              ;366
000064  233f              MOVS     r3,#0x3f              ;372
000066  65c2              STR      r2,[r0,#0x5c]         ;372
000068  fa03f30c          LSL      r3,r3,r12             ;372
00006c  6093              STR      r3,[r2,#8]            ;372
00006e  6401              STR      r1,[r0,#0x40]         ;376
000070  6441              STR      r1,[r0,#0x44]         ;377
000072  6481              STR      r1,[r0,#0x48]         ;378
000074  64c1              STR      r1,[r0,#0x4c]         ;379
000076  6501              STR      r1,[r0,#0x50]         ;380
000078  6541              STR      r1,[r0,#0x54]         ;383
00007a  6581              STR      r1,[r0,#0x58]         ;383
00007c  6381              STR      r1,[r0,#0x38]         ;386
00007e  6341              STR      r1,[r0,#0x34]         ;391
000080  2000              MOVS     r0,#0                 ;391
000082  4770              BX       lr
;;;393    
                          ENDP

                  |L3.132|
                          DCD      0xaaaaaaab
                  |L3.136|
                          DCD      ||.constdata||

                          AREA ||i.HAL_DMA_GetError||, CODE, READONLY, ALIGN=1

                  HAL_DMA_GetError PROC
;;;1141     */
;;;1142   uint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)
000000  6d80              LDR      r0,[r0,#0x58]
;;;1143   {
;;;1144     return hdma->ErrorCode;
;;;1145   }
000002  4770              BX       lr
;;;1146   
                          ENDP


                          AREA ||i.HAL_DMA_GetState||, CODE, READONLY, ALIGN=1

                  HAL_DMA_GetState PROC
;;;1130     */
;;;1131   HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)
000000  6b80              LDR      r0,[r0,#0x38]
;;;1132   {
;;;1133     return hdma->State;
;;;1134   }
000002  4770              BX       lr
;;;1135   
                          ENDP


                          AREA ||i.HAL_DMA_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_DMA_IRQHandler PROC
;;;764      */
;;;765    void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;766    {
000004  4604              MOV      r4,r0
;;;767      uint32_t tmpisr;
;;;768      __IO uint32_t count = 0;
000006  f04f0900          MOV      r9,#0
;;;769      uint32_t timeout = SystemCoreClock / 9600;
00000a  4a6f              LDR      r2,|L6.456|
;;;770    
;;;771      /* calculate DMA base and stream number */
;;;772      DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
;;;773    
;;;774      tmpisr = regs->ISR;
;;;775    
;;;776      /* Transfer Error Interrupt management ***************************************/
;;;777      if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
00000c  2108              MOVS     r1,#8
00000e  f8cd9000          STR      r9,[sp,#0]            ;772
000012  f44f5016          MOV      r0,#0x2580            ;769
000016  6de5              LDR      r5,[r4,#0x5c]         ;769
000018  f8943060          LDRB     r3,[r4,#0x60]
00001c  6812              LDR      r2,[r2,#0]            ;769  ; SystemCoreClock
00001e  682e              LDR      r6,[r5,#0]            ;774
000020  fbb2f8f0          UDIV     r8,r2,r0              ;769
000024  fa01f303          LSL      r3,r1,r3
000028  4233              TST      r3,r6
00002a  d011              BEQ      |L6.80|
;;;778      {
;;;779        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
00002c  6820              LDR      r0,[r4,#0]
00002e  6802              LDR      r2,[r0,#0]
000030  f0120f04          TST      r2,#4
000034  d00c              BEQ      |L6.80|
;;;780        {
;;;781          /* Disable the transfer error interrupt */
;;;782          hdma->Instance->CR  &= ~(DMA_IT_TE);
000036  6802              LDR      r2,[r0,#0]
000038  f0220204          BIC      r2,r2,#4
00003c  6002              STR      r2,[r0,#0]
;;;783          
;;;784          /* Clear the transfer error flag */
;;;785          regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
00003e  f8940060          LDRB     r0,[r4,#0x60]
000042  fa01f000          LSL      r0,r1,r0
000046  60a8              STR      r0,[r5,#8]
;;;786          
;;;787          /* Update error code */
;;;788          hdma->ErrorCode |= HAL_DMA_ERROR_TE;
000048  6da0              LDR      r0,[r4,#0x58]
00004a  f0400001          ORR      r0,r0,#1
00004e  65a0              STR      r0,[r4,#0x58]
                  |L6.80|
;;;789        }
;;;790      }
;;;791      /* FIFO Error Interrupt management ******************************************/
;;;792      if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
000050  f8940060          LDRB     r0,[r4,#0x60]
000054  2701              MOVS     r7,#1
000056  fa07f000          LSL      r0,r7,r0
00005a  4230              TST      r0,r6
00005c  d009              BEQ      |L6.114|
;;;793      {
;;;794        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
00005e  6821              LDR      r1,[r4,#0]
000060  6949              LDR      r1,[r1,#0x14]
000062  f0110f80          TST      r1,#0x80
000066  d004              BEQ      |L6.114|
;;;795        {
;;;796          /* Clear the FIFO error flag */
;;;797          regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
000068  60a8              STR      r0,[r5,#8]
;;;798    
;;;799          /* Update error code */
;;;800          hdma->ErrorCode |= HAL_DMA_ERROR_FE;
00006a  6da0              LDR      r0,[r4,#0x58]
00006c  f0400002          ORR      r0,r0,#2
000070  65a0              STR      r0,[r4,#0x58]
                  |L6.114|
;;;801        }
;;;802      }
;;;803      /* Direct Mode Error Interrupt management ***********************************/
;;;804      if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
000072  f8941060          LDRB     r1,[r4,#0x60]
000076  2004              MOVS     r0,#4
000078  4088              LSLS     r0,r0,r1
00007a  4230              TST      r0,r6
00007c  d009              BEQ      |L6.146|
;;;805      {
;;;806        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
00007e  6821              LDR      r1,[r4,#0]
000080  6809              LDR      r1,[r1,#0]
000082  f0110f02          TST      r1,#2
000086  d004              BEQ      |L6.146|
;;;807        {
;;;808          /* Clear the direct mode error flag */
;;;809          regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
000088  60a8              STR      r0,[r5,#8]
;;;810    
;;;811          /* Update error code */
;;;812          hdma->ErrorCode |= HAL_DMA_ERROR_DME;
00008a  6da0              LDR      r0,[r4,#0x58]
00008c  f0400004          ORR      r0,r0,#4
000090  65a0              STR      r0,[r4,#0x58]
                  |L6.146|
;;;813        }
;;;814      }
;;;815      /* Half Transfer Complete Interrupt management ******************************/
;;;816      if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
000092  f8941060          LDRB     r1,[r4,#0x60]
000096  2010              MOVS     r0,#0x10
000098  4088              LSLS     r0,r0,r1
00009a  4230              TST      r0,r6
00009c  d020              BEQ      |L6.224|
;;;817      {
;;;818        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
00009e  6821              LDR      r1,[r4,#0]
0000a0  6809              LDR      r1,[r1,#0]
0000a2  f0110f08          TST      r1,#8
0000a6  d01b              BEQ      |L6.224|
;;;819        {
;;;820          /* Clear the half transfer complete flag */
;;;821          regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
0000a8  60a8              STR      r0,[r5,#8]
;;;822          
;;;823          /* Multi_Buffering mode enabled */
;;;824          if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
0000aa  6820              LDR      r0,[r4,#0]
0000ac  6801              LDR      r1,[r0,#0]
0000ae  f4112f80          TST      r1,#0x40000
0000b2  d009              BEQ      |L6.200|
;;;825          {
;;;826            /* Current memory buffer used is Memory 0 */
;;;827            if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
0000b4  6800              LDR      r0,[r0,#0]
0000b6  f4102f00          TST      r0,#0x80000
0000ba  d002              BEQ      |L6.194|
;;;828            {
;;;829              if(hdma->XferHalfCpltCallback != NULL)
;;;830              {
;;;831                /* Half transfer callback */
;;;832                hdma->XferHalfCpltCallback(hdma);
;;;833              }
;;;834            }
;;;835            /* Current memory buffer used is Memory 1 */
;;;836            else
;;;837            {
;;;838              if(hdma->XferM1HalfCpltCallback != NULL)
0000bc  6ce1              LDR      r1,[r4,#0x4c]
0000be  b179              CBZ      r1,|L6.224|
0000c0  e00c              B        |L6.220|
                  |L6.194|
0000c2  6c61              LDR      r1,[r4,#0x44]         ;829
0000c4  b951              CBNZ     r1,|L6.220|
0000c6  e00b              B        |L6.224|
                  |L6.200|
;;;839              {
;;;840                /* Half transfer callback */
;;;841                hdma->XferM1HalfCpltCallback(hdma);
;;;842              }
;;;843            }
;;;844          }
;;;845          else
;;;846          {
;;;847            /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
;;;848            if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
0000c8  6801              LDR      r1,[r0,#0]
0000ca  f4117f80          TST      r1,#0x100
0000ce  d103              BNE      |L6.216|
;;;849            {
;;;850              /* Disable the half transfer interrupt */
;;;851              hdma->Instance->CR  &= ~(DMA_IT_HT);
0000d0  6801              LDR      r1,[r0,#0]
0000d2  f0210108          BIC      r1,r1,#8
0000d6  6001              STR      r1,[r0,#0]
                  |L6.216|
;;;852            }
;;;853            
;;;854            if(hdma->XferHalfCpltCallback != NULL)
0000d8  6c61              LDR      r1,[r4,#0x44]
0000da  b109              CBZ      r1,|L6.224|
                  |L6.220|
;;;855            {
;;;856              /* Half transfer callback */
;;;857              hdma->XferHalfCpltCallback(hdma);
0000dc  4620              MOV      r0,r4
0000de  4788              BLX      r1
                  |L6.224|
;;;858            }
;;;859          }
;;;860        }
;;;861      }
;;;862      /* Transfer Complete Interrupt management ***********************************/
;;;863      if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
0000e0  f8941060          LDRB     r1,[r4,#0x60]
0000e4  2020              MOVS     r0,#0x20
0000e6  4088              LSLS     r0,r0,r1
0000e8  4230              TST      r0,r6
0000ea  d046              BEQ      |L6.378|
;;;864      {
;;;865        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
0000ec  6821              LDR      r1,[r4,#0]
0000ee  6809              LDR      r1,[r1,#0]
0000f0  f0110f10          TST      r1,#0x10
0000f4  d041              BEQ      |L6.378|
;;;866        {
;;;867          /* Clear the transfer complete flag */
;;;868          regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
0000f6  60a8              STR      r0,[r5,#8]
;;;869          
;;;870          if(HAL_DMA_STATE_ABORT == hdma->State)
0000f8  6ba0              LDR      r0,[r4,#0x38]
0000fa  2805              CMP      r0,#5
;;;871          {
;;;872            /* Disable all the transfer interrupts */
;;;873            hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
;;;874            hdma->Instance->FCR &= ~(DMA_IT_FE);
;;;875            
;;;876            if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
;;;877            {
;;;878              hdma->Instance->CR  &= ~(DMA_IT_HT);
;;;879            }
;;;880    
;;;881            /* Clear all interrupt flags at correct offset within the register */
;;;882            regs->IFCR = 0x3FU << hdma->StreamIndex;
;;;883    
;;;884            /* Process Unlocked */
;;;885            __HAL_UNLOCK(hdma);
;;;886    
;;;887            /* Change the DMA state */
;;;888            hdma->State = HAL_DMA_STATE_READY;
;;;889    
;;;890            if(hdma->XferAbortCallback != NULL)
;;;891            {
;;;892              hdma->XferAbortCallback(hdma);
;;;893            }
;;;894            return;
;;;895          }
;;;896    
;;;897          if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
0000fc  6820              LDR      r0,[r4,#0]
0000fe  6801              LDR      r1,[r0,#0]
000100  d009              BEQ      |L6.278|
000102  f4112f80          TST      r1,#0x40000
000106  d029              BEQ      |L6.348|
;;;898          {
;;;899            /* Current memory buffer used is Memory 0 */
;;;900            if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
000108  6800              LDR      r0,[r0,#0]
00010a  f4102f00          TST      r0,#0x80000
00010e  d022              BEQ      |L6.342|
;;;901            {
;;;902              if(hdma->XferM1CpltCallback != NULL)
;;;903              {
;;;904                /* Transfer complete Callback for memory1 */
;;;905                hdma->XferM1CpltCallback(hdma);
;;;906              }
;;;907            }
;;;908            /* Current memory buffer used is Memory 1 */
;;;909            else
;;;910            {
;;;911              if(hdma->XferCpltCallback != NULL)
000110  6c21              LDR      r1,[r4,#0x40]
000112  b311              CBZ      r1,|L6.346|
000114  e02f              B        |L6.374|
                  |L6.278|
000116  f0210116          BIC      r1,r1,#0x16           ;873
00011a  6001              STR      r1,[r0,#0]            ;873
00011c  6820              LDR      r0,[r4,#0]            ;874
00011e  6941              LDR      r1,[r0,#0x14]         ;874
000120  f0210180          BIC      r1,r1,#0x80           ;874
000124  6141              STR      r1,[r0,#0x14]         ;874
000126  6c60              LDR      r0,[r4,#0x44]         ;876
000128  2800              CMP      r0,#0                 ;876
00012a  bf04              ITT      EQ                    ;876
00012c  6ce0              LDREQ    r0,[r4,#0x4c]         ;876
00012e  2800              CMPEQ    r0,#0                 ;876
000130  d004              BEQ      |L6.316|
000132  6820              LDR      r0,[r4,#0]            ;878
000134  6801              LDR      r1,[r0,#0]            ;878
000136  f0210108          BIC      r1,r1,#8              ;878
00013a  6001              STR      r1,[r0,#0]            ;878
                  |L6.316|
00013c  f8940060          LDRB     r0,[r4,#0x60]         ;882
000140  213f              MOVS     r1,#0x3f              ;882
000142  fa01f000          LSL      r0,r1,r0              ;882
000146  60a8              STR      r0,[r5,#8]            ;882
000148  f8c49034          STR      r9,[r4,#0x34]         ;888
00014c  63a7              STR      r7,[r4,#0x38]         ;888
00014e  6d61              LDR      r1,[r4,#0x54]         ;890
000150  bba9              CBNZ     r1,|L6.446|
;;;912              {
;;;913                /* Transfer complete Callback for memory0 */
;;;914                hdma->XferCpltCallback(hdma);
;;;915              }
;;;916            }
;;;917          }
;;;918          /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
;;;919          else
;;;920          {
;;;921            if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
;;;922            {
;;;923              /* Disable the transfer complete interrupt */
;;;924              hdma->Instance->CR  &= ~(DMA_IT_TC);
;;;925    
;;;926              /* Process Unlocked */
;;;927              __HAL_UNLOCK(hdma);
;;;928    
;;;929              /* Change the DMA state */
;;;930              hdma->State = HAL_DMA_STATE_READY;
;;;931            }
;;;932    
;;;933            if(hdma->XferCpltCallback != NULL)
;;;934            {
;;;935              /* Transfer complete callback */
;;;936              hdma->XferCpltCallback(hdma);
;;;937            }
;;;938          }
;;;939        }
;;;940      }
;;;941      
;;;942      /* manage error case */
;;;943      if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
;;;944      {
;;;945        if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
;;;946        {
;;;947          hdma->State = HAL_DMA_STATE_ABORT;
;;;948    
;;;949          /* Disable the stream */
;;;950          __HAL_DMA_DISABLE(hdma);
;;;951    
;;;952          do
;;;953          {
;;;954            if (++count > timeout)
;;;955            {
;;;956              break;
;;;957            }
;;;958          }
;;;959          while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
;;;960    
;;;961          /* Process Unlocked */
;;;962          __HAL_UNLOCK(hdma);
;;;963    
;;;964          /* Change the DMA state */
;;;965          hdma->State = HAL_DMA_STATE_READY;
;;;966        }
;;;967    
;;;968        if(hdma->XferErrorCallback != NULL)
;;;969        {
;;;970          /* Transfer error callback */
;;;971          hdma->XferErrorCallback(hdma);
;;;972        }
;;;973      }
;;;974    }
000152  e8bd83f8          POP      {r3-r9,pc}
                  |L6.342|
000156  6ca1              LDR      r1,[r4,#0x48]         ;902
000158  b969              CBNZ     r1,|L6.374|
                  |L6.346|
00015a  e00e              B        |L6.378|
                  |L6.348|
00015c  6801              LDR      r1,[r0,#0]            ;921
00015e  f4117f80          TST      r1,#0x100             ;921
000162  d106              BNE      |L6.370|
000164  6801              LDR      r1,[r0,#0]            ;924
000166  f0210110          BIC      r1,r1,#0x10           ;924
00016a  6001              STR      r1,[r0,#0]            ;924
00016c  f8c49034          STR      r9,[r4,#0x34]         ;930
000170  63a7              STR      r7,[r4,#0x38]         ;930
                  |L6.370|
000172  6c21              LDR      r1,[r4,#0x40]         ;933
000174  b109              CBZ      r1,|L6.378|
                  |L6.374|
000176  4620              MOV      r0,r4                 ;936
000178  4788              BLX      r1                    ;936
                  |L6.378|
00017a  6da0              LDR      r0,[r4,#0x58]         ;943
00017c  2800              CMP      r0,#0                 ;943
00017e  bf08              IT       EQ
000180  e8bd83f8          POPEQ    {r3-r9,pc}
000184  6da0              LDR      r0,[r4,#0x58]         ;945
000186  f0100f01          TST      r0,#1                 ;945
00018a  d013              BEQ      |L6.436|
00018c  2005              MOVS     r0,#5                 ;947
00018e  63a0              STR      r0,[r4,#0x38]         ;947
000190  6820              LDR      r0,[r4,#0]            ;950
000192  6801              LDR      r1,[r0,#0]            ;950
000194  f0210101          BIC      r1,r1,#1              ;950
000198  6001              STR      r1,[r0,#0]            ;950
                  |L6.410|
00019a  9800              LDR      r0,[sp,#0]            ;954
00019c  1c40              ADDS     r0,r0,#1              ;954
00019e  9000              STR      r0,[sp,#0]            ;954
0001a0  4540              CMP      r0,r8                 ;954
0001a2  d804              BHI      |L6.430|
0001a4  6820              LDR      r0,[r4,#0]            ;956
0001a6  6800              LDR      r0,[r0,#0]            ;956
0001a8  f0100f01          TST      r0,#1                 ;956
0001ac  d1f5              BNE      |L6.410|
                  |L6.430|
0001ae  f8c49034          STR      r9,[r4,#0x34]         ;965
0001b2  63a7              STR      r7,[r4,#0x38]         ;965
                  |L6.436|
0001b4  6d21              LDR      r1,[r4,#0x50]         ;968
0001b6  2900              CMP      r1,#0                 ;968
0001b8  bf08              IT       EQ
0001ba  e8bd83f8          POPEQ    {r3-r9,pc}
                  |L6.446|
0001be  4620              MOV      r0,r4                 ;971
0001c0  b001              ADD      sp,sp,#4              ;971
0001c2  e8bd43f0          POP      {r4-r9,lr}            ;971
0001c6  4708              BX       r1                    ;971
;;;975    
                          ENDP

                  |L6.456|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_DMA_Init||, CODE, READONLY, ALIGN=2

                  HAL_DMA_Init PROC
;;;187      */
;;;188    HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;189    {
000004  4604              MOV      r4,r0
;;;190      uint32_t tmp = 0U;
;;;191      uint32_t tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
;;;192      DMA_Base_Registers *regs;
;;;193    
;;;194      /* Check the DMA peripheral state */
;;;195      if(hdma == NULL)
00000a  2c00              CMP      r4,#0
00000c  4605              MOV      r5,r0                 ;191
;;;196      {
;;;197        return HAL_ERROR;
00000e  bf04              ITT      EQ
000010  2001              MOVEQ    r0,#1
;;;198      }
;;;199    
;;;200      /* Check the parameters */
;;;201      assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance));
;;;202      assert_param(IS_DMA_CHANNEL(hdma->Init.Channel));
;;;203      assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
;;;204      assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
;;;205      assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
;;;206      assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
;;;207      assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
;;;208      assert_param(IS_DMA_MODE(hdma->Init.Mode));
;;;209      assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
;;;210      assert_param(IS_DMA_FIFO_MODE_STATE(hdma->Init.FIFOMode));
;;;211      /* Check the memory burst, peripheral burst and FIFO threshold parameters only
;;;212         when FIFO mode is enabled */
;;;213      if(hdma->Init.FIFOMode != DMA_FIFOMODE_DISABLE)
;;;214      {
;;;215        assert_param(IS_DMA_FIFO_THRESHOLD(hdma->Init.FIFOThreshold));
;;;216        assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
;;;217        assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
;;;218      }
;;;219      
;;;220      /* Allocate lock resource */
;;;221      __HAL_UNLOCK(hdma);
;;;222    
;;;223      /* Change DMA peripheral state */
;;;224      hdma->State = HAL_DMA_STATE_BUSY;
;;;225      
;;;226      /* Disable the peripheral */
;;;227      __HAL_DMA_DISABLE(hdma);
;;;228      
;;;229      /* Check if the DMA Stream is effectively disabled */
;;;230      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
;;;231      {
;;;232        /* Check for the Timeout */
;;;233        if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
;;;234        {
;;;235          /* Update error code */
;;;236          hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
;;;237          
;;;238          /* Change the DMA state */
;;;239          hdma->State = HAL_DMA_STATE_TIMEOUT;
;;;240          
;;;241          return HAL_TIMEOUT;
;;;242        }
;;;243      }
;;;244      
;;;245      /* Get the CR register value */
;;;246      tmp = hdma->Instance->CR;
;;;247    
;;;248      /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
;;;249      tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
;;;250                          DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
;;;251                          DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
;;;252                          DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));
;;;253    
;;;254      /* Prepare the DMA Stream configuration */
;;;255      tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
;;;256              hdma->Init.PeriphInc           | hdma->Init.MemInc           |
;;;257              hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
;;;258              hdma->Init.Mode                | hdma->Init.Priority;
;;;259    
;;;260      /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
;;;261      if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
;;;262      {
;;;263        /* Get memory burst and peripheral burst */
;;;264        tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
;;;265      }
;;;266      
;;;267      /* Write to DMA Stream CR register */
;;;268      hdma->Instance->CR = tmp;  
;;;269    
;;;270      /* Get the FCR register value */
;;;271      tmp = hdma->Instance->FCR;
;;;272    
;;;273      /* Clear Direct mode and FIFO threshold bits */
;;;274      tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
;;;275    
;;;276      /* Prepare the DMA Stream FIFO configuration */
;;;277      tmp |= hdma->Init.FIFOMode;
;;;278    
;;;279      /* The FIFO threshold is not used when the FIFO mode is disabled */
;;;280      if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
;;;281      {
;;;282        /* Get the FIFO threshold */
;;;283        tmp |= hdma->Init.FIFOThreshold;
;;;284        
;;;285        /* Check compatibility between FIFO threshold level and size of the memory burst */
;;;286        /* for INCR4, INCR8, INCR16 bursts */
;;;287        if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
;;;288        {
;;;289          if (DMA_CheckFifoParam(hdma) != HAL_OK)
;;;290          {
;;;291            /* Update error code */
;;;292            hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
;;;293            
;;;294            /* Change the DMA state */
;;;295            hdma->State = HAL_DMA_STATE_READY;
;;;296            
;;;297            return HAL_ERROR; 
;;;298          }
;;;299        }
;;;300      }
;;;301      
;;;302      /* Write to DMA Stream FCR */
;;;303      hdma->Instance->FCR = tmp;
;;;304    
;;;305      /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
;;;306         DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
;;;307      regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
;;;308      
;;;309      /* Clear all interrupt flags */
;;;310      regs->IFCR = 0x3FU << hdma->StreamIndex;
;;;311    
;;;312      /* Initialize the error code */
;;;313      hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;314                                                                                         
;;;315      /* Initialize the DMA state */
;;;316      hdma->State = HAL_DMA_STATE_READY;
;;;317    
;;;318      return HAL_OK;
;;;319    }
000012  e8bd87f0          POPEQ    {r4-r10,pc}
000016  2600              MOVS     r6,#0                 ;221
000018  2002              MOVS     r0,#2                 ;224
00001a  6366              STR      r6,[r4,#0x34]         ;224
00001c  63a0              STR      r0,[r4,#0x38]         ;224
00001e  6820              LDR      r0,[r4,#0]            ;227
000020  6801              LDR      r1,[r0,#0]            ;227
000022  f0210101          BIC      r1,r1,#1              ;227
000026  6001              STR      r1,[r0,#0]            ;227
000028  6820              LDR      r0,[r4,#0]            ;230
00002a  6800              LDR      r0,[r0,#0]            ;230
00002c  f0100f01          TST      r0,#1                 ;230
000030  d010              BEQ      |L7.84|
000032  bf00              NOP                            ;233
                  |L7.52|
000034  f7fffffe          BL       HAL_GetTick
000038  1b40              SUBS     r0,r0,r5              ;233
00003a  2805              CMP      r0,#5                 ;233
00003c  d905              BLS      |L7.74|
00003e  2120              MOVS     r1,#0x20              ;236
000040  65a1              STR      r1,[r4,#0x58]         ;236
000042  2003              MOVS     r0,#3                 ;239
000044  63a0              STR      r0,[r4,#0x38]         ;239
000046  e8bd87f0          POP      {r4-r10,pc}
                  |L7.74|
00004a  6820              LDR      r0,[r4,#0]            ;241
00004c  6800              LDR      r0,[r0,#0]            ;241
00004e  f0100f01          TST      r0,#1                 ;241
000052  d1ef              BNE      |L7.52|
                  |L7.84|
000054  e9d43c02          LDRD     r3,r12,[r4,#8]        ;241
000058  e9d41000          LDRD     r1,r0,[r4,#0]         ;241
00005c  e9d47204          LDRD     r7,r2,[r4,#0x10]      ;255
000060  4318              ORRS     r0,r0,r3              ;255
000062  ea4c0807          ORR      r8,r12,r7             ;255
000066  e9d45306          LDRD     r5,r3,[r4,#0x18]      ;255
00006a  e9d4c708          LDRD     r12,r7,[r4,#0x20]     ;255
00006e  ea400908          ORR      r9,r0,r8              ;255
000072  6808              LDR      r0,[r1,#0]            ;246
000074  ea490202          ORR      r2,r9,r2              ;255
000078  f8df80d8          LDR      r8,|L7.340|
00007c  432a              ORRS     r2,r2,r5              ;255
00007e  ea420203          ORR      r2,r2,r3              ;255
000082  ea000008          AND      r0,r0,r8              ;249
000086  ea42020c          ORR      r2,r2,r12             ;255
00008a  2f04              CMP      r7,#4                 ;261
00008c  ea420000          ORR      r0,r2,r0              ;255
000090  d103              BNE      |L7.154|
000092  e9d4230b          LDRD     r2,r3,[r4,#0x2c]      ;261
000096  431a              ORRS     r2,r2,r3              ;264
000098  4310              ORRS     r0,r0,r2              ;264
                  |L7.154|
00009a  6008              STR      r0,[r1,#0]            ;268
00009c  f8d4c000          LDR      r12,[r4,#0]           ;277
0000a0  2301              MOVS     r3,#1                 ;197
0000a2  6a60              LDR      r0,[r4,#0x24]         ;271
0000a4  f8dc1014          LDR      r1,[r12,#0x14]        ;271
0000a8  2804              CMP      r0,#4                 ;280
0000aa  f0210107          BIC      r1,r1,#7              ;274
0000ae  ea400201          ORR      r2,r0,r1              ;277
0000b2  d135              BNE      |L7.288|
0000b4  e9d4100a          LDRD     r1,r0,[r4,#0x28]      ;280
0000b8  430a              ORRS     r2,r2,r1              ;283
0000ba  b318              CBZ      r0,|L7.260|
0000bc  69a5              LDR      r5,[r4,#0x18]         ;287
0000be  b155              CBZ      r5,|L7.214|
0000c0  f5b55f00          CMP      r5,#0x2000            ;287
0000c4  d014              BEQ      |L7.240|
0000c6  2900              CMP      r1,#0                 ;287
0000c8  bf1c              ITT      NE                    ;287
0000ca  2901              CMPNE    r1,#1                 ;287
0000cc  2902              CMPNE    r1,#2                 ;287
0000ce  d021              BEQ      |L7.276|
0000d0  2903              CMP      r1,#3                 ;287
0000d2  d01c              BEQ      |L7.270|
0000d4  e024              B        |L7.288|
                  |L7.214|
0000d6  b119              CBZ      r1,|L7.224|
0000d8  2901              CMP      r1,#1                 ;287
0000da  d005              BEQ      |L7.232|
0000dc  2902              CMP      r1,#2                 ;287
0000de  d11f              BNE      |L7.288|
                  |L7.224|
0000e0  f0107f80          TST      r0,#0x1000000         ;287
0000e4  d01c              BEQ      |L7.288|
0000e6  e015              B        |L7.276|
                  |L7.232|
0000e8  f1b07fc0          CMP      r0,#0x1800000         ;287
0000ec  d118              BNE      |L7.288|
0000ee  e011              B        |L7.276|
                  |L7.240|
0000f0  b181              CBZ      r1,|L7.276|
0000f2  2901              CMP      r1,#1                 ;287
0000f4  d007              BEQ      |L7.262|
0000f6  2902              CMP      r1,#2                 ;287
0000f8  d00c              BEQ      |L7.276|
0000fa  2903              CMP      r1,#3                 ;287
0000fc  bf08              IT       EQ                    ;287
0000fe  f1b07fc0          CMPEQ    r0,#0x1800000         ;287
000102  d007              BEQ      |L7.276|
                  |L7.260|
000104  e00c              B        |L7.288|
                  |L7.262|
000106  f0107f80          TST      r0,#0x1000000         ;287
00010a  d103              BNE      |L7.276|
00010c  e008              B        |L7.288|
                  |L7.270|
00010e  f0107f80          TST      r0,#0x1000000         ;287
000112  d005              BEQ      |L7.288|
                  |L7.276|
000114  2040              MOVS     r0,#0x40              ;292
000116  65a0              STR      r0,[r4,#0x58]         ;292
000118  63a3              STR      r3,[r4,#0x38]         ;295
00011a  2001              MOVS     r0,#1                 ;297
00011c  e8bd87f0          POP      {r4-r10,pc}
                  |L7.288|
000120  f8cc2014          STR      r2,[r12,#0x14]        ;303
000124  6820              LDR      r0,[r4,#0]            ;303
000126  490c              LDR      r1,|L7.344|
000128  b2c2              UXTB     r2,r0                 ;303
00012a  3a10              SUBS     r2,r2,#0x10           ;303
00012c  f36f0009          BFC      r0,#0,#10             ;303
000130  fba12102          UMULL    r2,r1,r1,r2           ;303
000134  4a09              LDR      r2,|L7.348|
000136  0909              LSRS     r1,r1,#4              ;303
000138  2903              CMP      r1,#3                 ;303
00013a  5c52              LDRB     r2,[r2,r1]            ;303
00013c  6622              STR      r2,[r4,#0x60]         ;303
00013e  bf88              IT       HI                    ;303
000140  1d00              ADDHI    r0,r0,#4              ;303
000142  213f              MOVS     r1,#0x3f              ;310
000144  65e0              STR      r0,[r4,#0x5c]         ;310
000146  4091              LSLS     r1,r1,r2              ;310
000148  6081              STR      r1,[r0,#8]            ;310
00014a  65a6              STR      r6,[r4,#0x58]         ;313
00014c  63a3              STR      r3,[r4,#0x38]         ;316
00014e  2000              MOVS     r0,#0                 ;318
000150  e8bd87f0          POP      {r4-r10,pc}
;;;320    
                          ENDP

                  |L7.340|
                          DCD      0xe010803f
                  |L7.344|
                          DCD      0xaaaaaaab
                  |L7.348|
                          DCD      ||.constdata||

                          AREA ||i.HAL_DMA_PollForTransfer||, CODE, READONLY, ALIGN=2

                  HAL_DMA_PollForTransfer PROC
;;;628      */
;;;629    HAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, HAL_DMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;630    {
000004  b083              SUB      sp,sp,#0xc
000006  4604              MOV      r4,r0
;;;631      HAL_StatusTypeDef status = HAL_OK; 
000008  2000              MOVS     r0,#0
00000a  4690              MOV      r8,r2                 ;630
00000c  468a              MOV      r10,r1                ;630
;;;632      uint32_t mask_cpltlevel;
;;;633      uint32_t tickstart = HAL_GetTick(); 
00000e  9001              STR      r0,[sp,#4]
000010  f7fffffe          BL       HAL_GetTick
;;;634      uint32_t tmpisr;
;;;635      
;;;636      /* calculate DMA base and stream number */
;;;637      DMA_Base_Registers *regs;
;;;638    
;;;639      if(HAL_DMA_STATE_BUSY != hdma->State)
000014  9000              STR      r0,[sp,#0]
000016  6ba0              LDR      r0,[r4,#0x38]
000018  2600              MOVS     r6,#0
00001a  2802              CMP      r0,#2
00001c  d006              BEQ      |L8.44|
;;;640      {
;;;641        /* No transfer ongoing */
;;;642        hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
00001e  2080              MOVS     r0,#0x80
000020  65a0              STR      r0,[r4,#0x58]
;;;643        __HAL_UNLOCK(hdma);
;;;644        return HAL_ERROR;
000022  6366              STR      r6,[r4,#0x34]
;;;645      }
;;;646    
;;;647      /* Polling mode not supported in circular mode and double buffering mode */
;;;648      if ((hdma->Instance->CR & DMA_SxCR_CIRC) != RESET)
;;;649      {
;;;650        hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
;;;651        return HAL_ERROR;
;;;652      }
;;;653      
;;;654      /* Get the level transfer complete flag */
;;;655      if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
;;;656      {
;;;657        /* Transfer Complete flag */
;;;658        mask_cpltlevel = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
;;;659      }
;;;660      else
;;;661      {
;;;662        /* Half Transfer Complete flag */
;;;663        mask_cpltlevel = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
;;;664      }
;;;665      
;;;666      regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
;;;667      tmpisr = regs->ISR;
;;;668      
;;;669      while(((tmpisr & mask_cpltlevel) == RESET) && ((hdma->ErrorCode & HAL_DMA_ERROR_TE) == RESET))
;;;670      {
;;;671        /* Check for the Timeout (Not applicable in circular mode)*/
;;;672        if(Timeout != HAL_MAX_DELAY)
;;;673        {
;;;674          if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
;;;675          {
;;;676            /* Update error code */
;;;677            hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
;;;678    
;;;679            /* Process Unlocked */
;;;680            __HAL_UNLOCK(hdma);
;;;681            
;;;682            /* Change the DMA state */
;;;683            hdma->State = HAL_DMA_STATE_READY;
;;;684            
;;;685            return HAL_TIMEOUT;
;;;686          }
;;;687        }
;;;688    
;;;689        /* Get the ISR register value */
;;;690        tmpisr = regs->ISR;
;;;691    
;;;692        if((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
;;;693        {
;;;694          /* Update error code */
;;;695          hdma->ErrorCode |= HAL_DMA_ERROR_TE;
;;;696          
;;;697          /* Clear the transfer error flag */
;;;698          regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
;;;699        }
;;;700        
;;;701        if((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
;;;702        {
;;;703          /* Update error code */
;;;704          hdma->ErrorCode |= HAL_DMA_ERROR_FE;
;;;705          
;;;706          /* Clear the FIFO error flag */
;;;707          regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
;;;708        }
;;;709        
;;;710        if((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
;;;711        {
;;;712          /* Update error code */
;;;713          hdma->ErrorCode |= HAL_DMA_ERROR_DME;
;;;714          
;;;715          /* Clear the Direct Mode error flag */
;;;716          regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
;;;717        }
;;;718      }
;;;719      
;;;720      if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
;;;721      {
;;;722        if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
;;;723        {
;;;724          HAL_DMA_Abort(hdma);
;;;725        
;;;726          /* Clear the half transfer and transfer complete flags */
;;;727          regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;
;;;728        
;;;729          /* Process Unlocked */
;;;730          __HAL_UNLOCK(hdma);
;;;731    
;;;732          /* Change the DMA state */
;;;733          hdma->State= HAL_DMA_STATE_READY;
;;;734    
;;;735          return HAL_ERROR;
;;;736       }
;;;737      }
;;;738      
;;;739      /* Get the level transfer complete flag */
;;;740      if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
;;;741      {
;;;742        /* Clear the half transfer and transfer complete flags */
;;;743        regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;
;;;744        
;;;745        /* Process Unlocked */
;;;746        __HAL_UNLOCK(hdma);
;;;747    
;;;748        hdma->State = HAL_DMA_STATE_READY;
;;;749      }
;;;750      else
;;;751      {
;;;752        /* Clear the half transfer flag */
;;;753        regs->IFCR = (DMA_FLAG_HTIF0_4) << hdma->StreamIndex;
;;;754      }
;;;755      
;;;756      return status;
;;;757    }
000024  b003              ADD      sp,sp,#0xc
000026  2001              MOVS     r0,#1                 ;644
000028  e8bd8ff0          POP      {r4-r11,pc}
                  |L8.44|
00002c  6820              LDR      r0,[r4,#0]            ;648
00002e  6800              LDR      r0,[r0,#0]            ;648
000030  f4107f80          TST      r0,#0x100             ;648
000034  bf1c              ITT      NE                    ;650
000036  f44f7080          MOVNE    r0,#0x100             ;650
00003a  65a0              STRNE    r0,[r4,#0x58]         ;650
00003c  d17e              BNE      |L8.316|
00003e  f1ba0f00          CMP      r10,#0                ;655
000042  f04f0b20          MOV      r11,#0x20             ;658
000046  bf07              ITTEE    EQ                    ;658
000048  f8940060          LDRBEQ   r0,[r4,#0x60]         ;658
00004c  fa0bf900          LSLEQ    r9,r11,r0             ;658
000050  f8941060          LDRBNE   r1,[r4,#0x60]         ;663
000054  2010              MOVNE    r0,#0x10              ;663
000056  bf18              IT       NE                    ;663
000058  fa00f901          LSLNE    r9,r0,r1              ;663
00005c  2701              MOVS     r7,#1                 ;644
00005e  6de5              LDR      r5,[r4,#0x5c]         ;667
000060  6828              LDR      r0,[r5,#0]            ;667
000062  e035              B        |L8.208|
                  |L8.100|
000064  f1b83fff          CMP      r8,#0xffffffff        ;672
000068  d010              BEQ      |L8.140|
00006a  f1b80f00          CMP      r8,#0                 ;674
00006e  d005              BEQ      |L8.124|
000070  f7fffffe          BL       HAL_GetTick
000074  9900              LDR      r1,[sp,#0]            ;674
000076  1a40              SUBS     r0,r0,r1              ;674
000078  4540              CMP      r0,r8                 ;674
00007a  d907              BLS      |L8.140|
                  |L8.124|
00007c  f8c4b058          STR      r11,[r4,#0x58]        ;677
000080  63a7              STR      r7,[r4,#0x38]         ;683
000082  6366              STR      r6,[r4,#0x34]         ;683
000084  b003              ADD      sp,sp,#0xc
000086  2003              MOVS     r0,#3                 ;685
000088  e8bd8ff0          POP      {r4-r11,pc}
                  |L8.140|
00008c  f8942060          LDRB     r2,[r4,#0x60]         ;692
000090  2108              MOVS     r1,#8                 ;692
000092  6828              LDR      r0,[r5,#0]            ;690
000094  4091              LSLS     r1,r1,r2              ;692
000096  4201              TST      r1,r0                 ;692
000098  d004              BEQ      |L8.164|
00009a  6da2              LDR      r2,[r4,#0x58]         ;695
00009c  f0420201          ORR      r2,r2,#1              ;695
0000a0  65a2              STR      r2,[r4,#0x58]         ;695
0000a2  60a9              STR      r1,[r5,#8]            ;698
                  |L8.164|
0000a4  f8941060          LDRB     r1,[r4,#0x60]         ;701
0000a8  fa07f101          LSL      r1,r7,r1              ;701
0000ac  4201              TST      r1,r0                 ;701
0000ae  d004              BEQ      |L8.186|
0000b0  6da2              LDR      r2,[r4,#0x58]         ;704
0000b2  f0420202          ORR      r2,r2,#2              ;704
0000b6  65a2              STR      r2,[r4,#0x58]         ;704
0000b8  60a9              STR      r1,[r5,#8]            ;707
                  |L8.186|
0000ba  2104              MOVS     r1,#4                 ;710
0000bc  f8942060          LDRB     r2,[r4,#0x60]         ;710
0000c0  4091              LSLS     r1,r1,r2              ;710
0000c2  4201              TST      r1,r0                 ;710
0000c4  d004              BEQ      |L8.208|
0000c6  6da2              LDR      r2,[r4,#0x58]         ;713
0000c8  f0420204          ORR      r2,r2,#4              ;713
0000cc  65a2              STR      r2,[r4,#0x58]         ;713
0000ce  60a9              STR      r1,[r5,#8]            ;716
                  |L8.208|
0000d0  ea100f09          TST      r0,r9                 ;716
0000d4  bf04              ITT      EQ                    ;716
0000d6  6da0              LDREQ    r0,[r4,#0x58]         ;716
0000d8  f0100f01          TSTEQ    r0,#1                 ;716
0000dc  d0c2              BEQ      |L8.100|
0000de  6da0              LDR      r0,[r4,#0x58]         ;720
0000e0  f04f0930          MOV      r9,#0x30              ;727
0000e4  2800              CMP      r0,#0                 ;720
0000e6  bf1c              ITT      NE                    ;722
0000e8  6da0              LDRNE    r0,[r4,#0x58]         ;722
0000ea  f0100f01          TSTNE    r0,#1                 ;722
0000ee  d052              BEQ      |L8.406|
0000f0  f8d4a05c          LDR      r10,[r4,#0x5c]        ;720
0000f4  f7fffffe          BL       HAL_GetTick
0000f8  4680              MOV      r8,r0                 ;720
0000fa  6ba0              LDR      r0,[r4,#0x38]         ;720
0000fc  2802              CMP      r0,#2                 ;720
0000fe  d003              BEQ      |L8.264|
000100  2080              MOVS     r0,#0x80              ;720
000102  65a0              STR      r0,[r4,#0x58]         ;720
000104  6366              STR      r6,[r4,#0x34]         ;720
000106  e03b              B        |L8.384|
                  |L8.264|
000108  6820              LDR      r0,[r4,#0]            ;720
00010a  6801              LDR      r1,[r0,#0]            ;720
00010c  f0210116          BIC      r1,r1,#0x16           ;720
000110  6001              STR      r1,[r0,#0]            ;720
000112  6820              LDR      r0,[r4,#0]            ;720
000114  6941              LDR      r1,[r0,#0x14]         ;720
000116  f0210180          BIC      r1,r1,#0x80           ;720
00011a  6141              STR      r1,[r0,#0x14]         ;720
00011c  6c60              LDR      r0,[r4,#0x44]         ;720
00011e  2800              CMP      r0,#0                 ;720
000120  bf04              ITT      EQ                    ;720
000122  6ce0              LDREQ    r0,[r4,#0x4c]         ;720
000124  2800              CMPEQ    r0,#0                 ;720
000126  d004              BEQ      |L8.306|
000128  6820              LDR      r0,[r4,#0]            ;720
00012a  6801              LDR      r1,[r0,#0]            ;720
00012c  f0210108          BIC      r1,r1,#8              ;720
000130  6001              STR      r1,[r0,#0]            ;720
                  |L8.306|
000132  6820              LDR      r0,[r4,#0]            ;720
000134  6801              LDR      r1,[r0,#0]            ;720
000136  f0210101          BIC      r1,r1,#1              ;720
00013a  e000              B        |L8.318|
                  |L8.316|
00013c  e027              B        |L8.398|
                  |L8.318|
00013e  6001              STR      r1,[r0,#0]            ;720
000140  6820              LDR      r0,[r4,#0]            ;720
000142  6800              LDR      r0,[r0,#0]            ;720
000144  f0100f01          TST      r0,#1                 ;720
000148  d011              BEQ      |L8.366|
00014a  bf00              NOP                            ;720
                  |L8.332|
00014c  f7fffffe          BL       HAL_GetTick
000150  eba00008          SUB      r0,r0,r8              ;720
000154  2805              CMP      r0,#5                 ;720
000156  d905              BLS      |L8.356|
000158  2003              MOVS     r0,#3                 ;720
00015a  f8c4b058          STR      r11,[r4,#0x58]        ;720
00015e  6366              STR      r6,[r4,#0x34]         ;720
000160  63a0              STR      r0,[r4,#0x38]         ;720
000162  e00d              B        |L8.384|
                  |L8.356|
000164  6820              LDR      r0,[r4,#0]            ;720
000166  6800              LDR      r0,[r0,#0]            ;720
000168  f0100f01          TST      r0,#1                 ;720
00016c  d1ee              BNE      |L8.332|
                  |L8.366|
00016e  f8940060          LDRB     r0,[r4,#0x60]         ;720
000172  213f              MOVS     r1,#0x3f              ;720
000174  fa01f000          LSL      r0,r1,r0              ;720
000178  f8ca0008          STR      r0,[r10,#8]           ;720
00017c  63a7              STR      r7,[r4,#0x38]         ;720
00017e  6366              STR      r6,[r4,#0x34]         ;720
                  |L8.384|
000180  f8940060          LDRB     r0,[r4,#0x60]         ;727
000184  fa09f000          LSL      r0,r9,r0              ;727
000188  60a8              STR      r0,[r5,#8]            ;727
00018a  63a7              STR      r7,[r4,#0x38]         ;733
00018c  6366              STR      r6,[r4,#0x34]         ;733
                  |L8.398|
00018e  b003              ADD      sp,sp,#0xc
000190  2001              MOVS     r0,#1                 ;735
000192  e8bd8ff0          POP      {r4-r11,pc}
                  |L8.406|
000196  f1ba0f00          CMP      r10,#0                ;740
00019a  d008              BEQ      |L8.430|
00019c  f8941060          LDRB     r1,[r4,#0x60]         ;753
0001a0  2010              MOVS     r0,#0x10              ;753
0001a2  4088              LSLS     r0,r0,r1              ;753
0001a4  60a8              STR      r0,[r5,#8]            ;753
                  |L8.422|
0001a6  9801              LDR      r0,[sp,#4]            ;756
0001a8  b003              ADD      sp,sp,#0xc
0001aa  e8bd8ff0          POP      {r4-r11,pc}
                  |L8.430|
0001ae  f8940060          LDRB     r0,[r4,#0x60]         ;743
0001b2  fa09f000          LSL      r0,r9,r0              ;743
0001b6  60a8              STR      r0,[r5,#8]            ;743
0001b8  63a7              STR      r7,[r4,#0x38]         ;748
0001ba  6366              STR      r6,[r4,#0x34]         ;748
0001bc  e7f3              B        |L8.422|
;;;758    
                          ENDP


                          AREA ||i.HAL_DMA_RegisterCallback||, CODE, READONLY, ALIGN=1

                  HAL_DMA_RegisterCallback PROC
;;;985      */                      
;;;986    HAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)(DMA_HandleTypeDef *_hdma))
000000  f8d0c034          LDR      r12,[r0,#0x34]
;;;987    {
;;;988    
;;;989      HAL_StatusTypeDef status = HAL_OK;
000004  2300              MOVS     r3,#0
;;;990    
;;;991      /* Process locked */
;;;992      __HAL_LOCK(hdma);
000006  f1bc0f01          CMP      r12,#1
00000a  bf04              ITT      EQ
00000c  2002              MOVEQ    r0,#2
;;;993    
;;;994      if(HAL_DMA_STATE_READY == hdma->State)
;;;995      {
;;;996        switch (CallbackID)
;;;997        {
;;;998        case  HAL_DMA_XFER_CPLT_CB_ID:
;;;999          hdma->XferCpltCallback = pCallback;
;;;1000         break;
;;;1001   
;;;1002       case  HAL_DMA_XFER_HALFCPLT_CB_ID:
;;;1003         hdma->XferHalfCpltCallback = pCallback;
;;;1004         break;
;;;1005   
;;;1006       case  HAL_DMA_XFER_M1CPLT_CB_ID:
;;;1007         hdma->XferM1CpltCallback = pCallback;
;;;1008         break;
;;;1009   
;;;1010       case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
;;;1011         hdma->XferM1HalfCpltCallback = pCallback;
;;;1012         break;
;;;1013   
;;;1014       case  HAL_DMA_XFER_ERROR_CB_ID:
;;;1015         hdma->XferErrorCallback = pCallback;
;;;1016         break;
;;;1017   
;;;1018       case  HAL_DMA_XFER_ABORT_CB_ID:
;;;1019         hdma->XferAbortCallback = pCallback;
;;;1020         break;
;;;1021   
;;;1022       default:
;;;1023         break;
;;;1024       }
;;;1025     }
;;;1026     else
;;;1027     {
;;;1028       /* Return error status */
;;;1029       status =  HAL_ERROR;
;;;1030     }
;;;1031   
;;;1032     /* Release Lock */
;;;1033     __HAL_UNLOCK(hdma);
;;;1034     
;;;1035     return status;
;;;1036   }
00000e  4770              BXEQ     lr
000010  f84d4d04          PUSH.W   {r4}                  ;987
000014  6b84              LDR      r4,[r0,#0x38]         ;994
000016  f04f0c01          MOV      r12,#1                ;992
00001a  f8c0c034          STR      r12,[r0,#0x34]        ;994
00001e  2c01              CMP      r4,#1                 ;994
000020  bf18              IT       NE                    ;1029
000022  2301              MOVNE    r3,#1                 ;1029
000024  d005              BEQ      |L9.50|
                  |L9.38|
000026  2100              MOVS     r1,#0                 ;1033
000028  6341              STR      r1,[r0,#0x34]         ;1035
00002a  f85d4b04          POP.W    {r4}
00002e  4618              MOV      r0,r3                 ;1035
000030  4770              BX       lr
                  |L9.50|
000032  2906              CMP      r1,#6                 ;996
000034  d2f7              BCS      |L9.38|
000036  e8dff001          TBB      [pc,r1]               ;996
00003a  0305              DCB      0x03,0x05
00003c  07090b0d          DCB      0x07,0x09,0x0b,0x0d
000040  6402              STR      r2,[r0,#0x40]         ;1000
000042  e7f0              B        |L9.38|
000044  6442              STR      r2,[r0,#0x44]         ;1004
000046  e7ee              B        |L9.38|
000048  6482              STR      r2,[r0,#0x48]         ;1008
00004a  e7ec              B        |L9.38|
00004c  64c2              STR      r2,[r0,#0x4c]         ;1012
00004e  e7ea              B        |L9.38|
000050  6502              STR      r2,[r0,#0x50]         ;1016
000052  e7e8              B        |L9.38|
000054  6542              STR      r2,[r0,#0x54]         ;1020
000056  e7e6              B        |L9.38|
;;;1037   
                          ENDP


                          AREA ||i.HAL_DMA_Start||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Start PROC
;;;424      */
;;;425    HAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  b470              PUSH     {r4-r6}
;;;426    {
;;;427      HAL_StatusTypeDef status = HAL_OK;
;;;428      
;;;429      /* Check the parameters */
;;;430      assert_param(IS_DMA_BUFFER_SIZE(DataLength));
;;;431    
;;;432      /* Process locked */
;;;433      __HAL_LOCK(hdma);
000002  6b44              LDR      r4,[r0,#0x34]
000004  f04f0c00          MOV      r12,#0                ;427
000008  2c01              CMP      r4,#1
00000a  bf02              ITTT     EQ
00000c  2002              MOVEQ    r0,#2
;;;434    
;;;435      if(HAL_DMA_STATE_READY == hdma->State)
;;;436      {
;;;437        /* Change DMA peripheral state */
;;;438        hdma->State = HAL_DMA_STATE_BUSY;
;;;439        
;;;440        /* Initialize the error code */
;;;441        hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;442        
;;;443        /* Configure the source, destination address and the data length */
;;;444        DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
;;;445    
;;;446        /* Enable the Peripheral */
;;;447        __HAL_DMA_ENABLE(hdma);
;;;448      }
;;;449      else
;;;450      {
;;;451        /* Process unlocked */
;;;452        __HAL_UNLOCK(hdma);
;;;453        
;;;454        /* Return error status */
;;;455        status = HAL_BUSY;
;;;456      } 
;;;457      return status; 
;;;458    }
00000e  bc70              POPEQ    {r4-r6}
000010  4770              BXEQ     lr
000012  6b86              LDR      r6,[r0,#0x38]         ;435
000014  2501              MOVS     r5,#1                 ;433
000016  6345              STR      r5,[r0,#0x34]         ;435
000018  2400              MOVS     r4,#0                 ;433
00001a  2e01              CMP      r6,#1                 ;435
00001c  bf1c              ITT      NE                    ;455
00001e  f04f0c02          MOVNE    r12,#2                ;455
000022  6344              STRNE    r4,[r0,#0x34]         ;452
000024  d002              BEQ      |L10.44|
                  |L10.38|
000026  bc70              POP      {r4-r6}
000028  4660              MOV      r0,r12                ;457
00002a  4770              BX       lr
                  |L10.44|
00002c  2502              MOVS     r5,#2                 ;438
00002e  6385              STR      r5,[r0,#0x38]         ;438
000030  6584              STR      r4,[r0,#0x58]         ;441
000032  6804              LDR      r4,[r0,#0]            ;441
000034  6825              LDR      r5,[r4,#0]            ;441
000036  f4252580          BIC      r5,r5,#0x40000        ;441
00003a  6025              STR      r5,[r4,#0]            ;441
00003c  6804              LDR      r4,[r0,#0]            ;441
00003e  6063              STR      r3,[r4,#4]            ;441
000040  6883              LDR      r3,[r0,#8]            ;441
000042  2b40              CMP      r3,#0x40              ;441
000044  6803              LDR      r3,[r0,#0]            ;441
000046  bf03              ITTTE    EQ                    ;441
000048  609a              STREQ    r2,[r3,#8]            ;441
00004a  6802              LDREQ    r2,[r0,#0]            ;441
00004c  60d1              STREQ    r1,[r2,#0xc]          ;441
00004e  6099              STRNE    r1,[r3,#8]            ;441
000050  bf1c              ITT      NE                    ;441
000052  6801              LDRNE    r1,[r0,#0]            ;441
000054  60ca              STRNE    r2,[r1,#0xc]          ;441
000056  6800              LDR      r0,[r0,#0]            ;447
000058  6801              LDR      r1,[r0,#0]            ;447
00005a  f0410101          ORR      r1,r1,#1              ;447
00005e  6001              STR      r1,[r0,#0]            ;447
000060  e7e1              B        |L10.38|
;;;459    
                          ENDP


                          AREA ||i.HAL_DMA_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Start_IT PROC
;;;468      */
;;;469    HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  b4f0              PUSH     {r4-r7}
;;;470    {
;;;471      HAL_StatusTypeDef status = HAL_OK;
;;;472    
;;;473      /* calculate DMA base and stream number */
;;;474      DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
;;;475      
;;;476      /* Check the parameters */
;;;477      assert_param(IS_DMA_BUFFER_SIZE(DataLength));
;;;478     
;;;479      /* Process locked */
;;;480      __HAL_LOCK(hdma);
000002  6b44              LDR      r4,[r0,#0x34]
000004  f04f0c00          MOV      r12,#0                ;471
000008  2c01              CMP      r4,#1
00000a  6dc4              LDR      r4,[r0,#0x5c]         ;474
00000c  bf02              ITTT     EQ
00000e  2002              MOVEQ    r0,#2
;;;481      
;;;482      if(HAL_DMA_STATE_READY == hdma->State)
;;;483      {
;;;484        /* Change DMA peripheral state */
;;;485        hdma->State = HAL_DMA_STATE_BUSY;
;;;486        
;;;487        /* Initialize the error code */
;;;488        hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;489        
;;;490        /* Configure the source, destination address and the data length */
;;;491        DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
;;;492        
;;;493        /* Clear all interrupt flags at correct offset within the register */
;;;494        regs->IFCR = 0x3FU << hdma->StreamIndex;
;;;495        
;;;496        /* Enable Common interrupts*/
;;;497        hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
;;;498        hdma->Instance->FCR |= DMA_IT_FE;
;;;499        
;;;500        if(hdma->XferHalfCpltCallback != NULL)
;;;501        {
;;;502          hdma->Instance->CR  |= DMA_IT_HT;
;;;503        }
;;;504        
;;;505        /* Enable the Peripheral */
;;;506        __HAL_DMA_ENABLE(hdma);
;;;507      }
;;;508      else
;;;509      {
;;;510        /* Process unlocked */
;;;511        __HAL_UNLOCK(hdma);	  
;;;512        
;;;513        /* Return error status */
;;;514        status = HAL_BUSY;
;;;515      }
;;;516      
;;;517      return status;
;;;518    }
000010  bcf0              POPEQ    {r4-r7}
000012  4770              BXEQ     lr
000014  6b87              LDR      r7,[r0,#0x38]         ;482
000016  2601              MOVS     r6,#1                 ;480
000018  6346              STR      r6,[r0,#0x34]         ;482
00001a  2500              MOVS     r5,#0                 ;480
00001c  2f01              CMP      r7,#1                 ;482
00001e  bf1c              ITT      NE                    ;514
000020  f04f0c02          MOVNE    r12,#2                ;514
000024  6345              STRNE    r5,[r0,#0x34]         ;511
000026  d002              BEQ      |L11.46|
                  |L11.40|
000028  bcf0              POP      {r4-r7}
00002a  4660              MOV      r0,r12                ;517
00002c  4770              BX       lr
                  |L11.46|
00002e  2602              MOVS     r6,#2                 ;485
000030  6386              STR      r6,[r0,#0x38]         ;485
000032  6585              STR      r5,[r0,#0x58]         ;488
000034  6805              LDR      r5,[r0,#0]            ;488
000036  682e              LDR      r6,[r5,#0]            ;488
000038  f4262680          BIC      r6,r6,#0x40000        ;488
00003c  602e              STR      r6,[r5,#0]            ;488
00003e  6805              LDR      r5,[r0,#0]            ;488
000040  606b              STR      r3,[r5,#4]            ;488
000042  6883              LDR      r3,[r0,#8]            ;488
000044  2b40              CMP      r3,#0x40              ;488
000046  6803              LDR      r3,[r0,#0]            ;488
000048  bf03              ITTTE    EQ                    ;488
00004a  609a              STREQ    r2,[r3,#8]            ;488
00004c  6802              LDREQ    r2,[r0,#0]            ;488
00004e  60d1              STREQ    r1,[r2,#0xc]          ;488
000050  6099              STRNE    r1,[r3,#8]            ;488
000052  bf1c              ITT      NE                    ;488
000054  6801              LDRNE    r1,[r0,#0]            ;488
000056  60ca              STRNE    r2,[r1,#0xc]          ;488
000058  f8901060          LDRB     r1,[r0,#0x60]         ;494
00005c  223f              MOVS     r2,#0x3f              ;494
00005e  fa02f101          LSL      r1,r2,r1              ;494
000062  60a1              STR      r1,[r4,#8]            ;494
000064  6801              LDR      r1,[r0,#0]            ;497
000066  680a              LDR      r2,[r1,#0]            ;497
000068  f0420216          ORR      r2,r2,#0x16           ;497
00006c  600a              STR      r2,[r1,#0]            ;497
00006e  6801              LDR      r1,[r0,#0]            ;498
000070  694a              LDR      r2,[r1,#0x14]         ;498
000072  f0420280          ORR      r2,r2,#0x80           ;498
000076  614a              STR      r2,[r1,#0x14]         ;498
000078  6c41              LDR      r1,[r0,#0x44]         ;498
00007a  b121              CBZ      r1,|L11.134|
00007c  6801              LDR      r1,[r0,#0]            ;502
00007e  680a              LDR      r2,[r1,#0]            ;502
000080  f0420208          ORR      r2,r2,#8              ;502
000084  600a              STR      r2,[r1,#0]            ;502
                  |L11.134|
000086  6800              LDR      r0,[r0,#0]            ;506
000088  6801              LDR      r1,[r0,#0]            ;506
00008a  f0410101          ORR      r1,r1,#1              ;506
00008e  6001              STR      r1,[r0,#0]            ;506
000090  e7ca              B        |L11.40|
;;;519    
                          ENDP


                          AREA ||i.HAL_DMA_UnRegisterCallback||, CODE, READONLY, ALIGN=1

                  HAL_DMA_UnRegisterCallback PROC
;;;1045     */              
;;;1046   HAL_StatusTypeDef HAL_DMA_UnRegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID)
000000  6b42              LDR      r2,[r0,#0x34]
;;;1047   {
;;;1048     HAL_StatusTypeDef status = HAL_OK;
000002  2300              MOVS     r3,#0
;;;1049     
;;;1050     /* Process locked */
;;;1051     __HAL_LOCK(hdma);
000004  2a01              CMP      r2,#1
000006  bf04              ITT      EQ
000008  2002              MOVEQ    r0,#2
;;;1052     
;;;1053     if(HAL_DMA_STATE_READY == hdma->State)
;;;1054     {
;;;1055       switch (CallbackID)
;;;1056       {
;;;1057       case  HAL_DMA_XFER_CPLT_CB_ID:
;;;1058         hdma->XferCpltCallback = NULL;
;;;1059         break;
;;;1060         
;;;1061       case  HAL_DMA_XFER_HALFCPLT_CB_ID:
;;;1062         hdma->XferHalfCpltCallback = NULL;
;;;1063         break;
;;;1064         
;;;1065       case  HAL_DMA_XFER_M1CPLT_CB_ID:
;;;1066         hdma->XferM1CpltCallback = NULL;
;;;1067         break;
;;;1068         
;;;1069       case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
;;;1070         hdma->XferM1HalfCpltCallback = NULL;
;;;1071         break;
;;;1072         
;;;1073       case  HAL_DMA_XFER_ERROR_CB_ID:
;;;1074         hdma->XferErrorCallback = NULL;
;;;1075         break;
;;;1076         
;;;1077       case  HAL_DMA_XFER_ABORT_CB_ID:
;;;1078         hdma->XferAbortCallback = NULL;
;;;1079         break; 
;;;1080         
;;;1081       case   HAL_DMA_XFER_ALL_CB_ID:
;;;1082         hdma->XferCpltCallback = NULL;
;;;1083         hdma->XferHalfCpltCallback = NULL;
;;;1084         hdma->XferM1CpltCallback = NULL;
;;;1085         hdma->XferM1HalfCpltCallback = NULL;
;;;1086         hdma->XferErrorCallback = NULL;
;;;1087         hdma->XferAbortCallback = NULL;
;;;1088         break; 
;;;1089         
;;;1090       default:
;;;1091         status = HAL_ERROR;
;;;1092         break;
;;;1093       }
;;;1094     }
;;;1095     else
;;;1096     {
;;;1097       status = HAL_ERROR;
;;;1098     }
;;;1099     
;;;1100     /* Release Lock */
;;;1101     __HAL_UNLOCK(hdma);
;;;1102     
;;;1103     return status;
;;;1104   }
00000a  4770              BXEQ     lr
00000c  f84d4d04          PUSH.W   {r4}                  ;1047
000010  6b84              LDR      r4,[r0,#0x38]         ;1053
000012  2200              MOVS     r2,#0                 ;1051
000014  f04f0c01          MOV      r12,#1                ;1051
000018  f8c0c034          STR      r12,[r0,#0x34]        ;1053
00001c  2c01              CMP      r4,#1                 ;1053
00001e  d11a              BNE      |L12.86|
000020  2907              CMP      r1,#7                 ;1055
000022  d218              BCS      |L12.86|
000024  e8dff001          TBB      [pc,r1]               ;1055
000028  0406080a          DCB      0x04,0x06,0x08,0x0a
00002c  0c0e1000          DCB      0x0c,0x0e,0x10,0x00
000030  6402              STR      r2,[r0,#0x40]         ;1059
000032  e011              B        |L12.88|
000034  6442              STR      r2,[r0,#0x44]         ;1063
000036  e00f              B        |L12.88|
000038  6482              STR      r2,[r0,#0x48]         ;1067
00003a  e00d              B        |L12.88|
00003c  64c2              STR      r2,[r0,#0x4c]         ;1071
00003e  e00b              B        |L12.88|
000040  6502              STR      r2,[r0,#0x50]         ;1075
000042  e009              B        |L12.88|
000044  6542              STR      r2,[r0,#0x54]         ;1079
000046  e007              B        |L12.88|
000048  6402              STR      r2,[r0,#0x40]         ;1083
00004a  6442              STR      r2,[r0,#0x44]         ;1084
00004c  6482              STR      r2,[r0,#0x48]         ;1085
00004e  64c2              STR      r2,[r0,#0x4c]         ;1086
000050  6502              STR      r2,[r0,#0x50]         ;1087
000052  6542              STR      r2,[r0,#0x54]         ;1088
000054  e000              B        |L12.88|
                  |L12.86|
000056  2301              MOVS     r3,#1                 ;1091
                  |L12.88|
000058  6342              STR      r2,[r0,#0x34]         ;1103
00005a  f85d4b04          POP.W    {r4}
00005e  4618              MOV      r0,r3                 ;1103
000060  4770              BX       lr
;;;1105   
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  flagBitshiftOffset
000000  00061016          DCB      0x00,0x06,0x10,0x16
000004  00061016          DCB      0x00,0x06,0x10,0x16

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F7_V1.11.0\\Drivers\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_dma.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_dma_c_c25f65ec____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F7_V1.11.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f7xx_hal_dma_c_c25f65ec____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_dma_c_c25f65ec____REVSH|
#line 402
|__asm___19_stm32f7xx_hal_dma_c_c25f65ec____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_dma_c_c25f65ec____RRX|
#line 587
|__asm___19_stm32f7xx_hal_dma_c_c25f65ec____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
