; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f7xx_hal_pwr_ex.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f7xx_hal_pwr_ex.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc\Conf -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f7xx_hal_pwr_ex.crf ..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_pwr_ex.c]
                          THUMB

                          AREA ||i.HAL_PWREx_ControlVoltageScaling||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_ControlVoltageScaling PROC
;;;492      */
;;;493    HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
000000  b5f8              PUSH     {r3-r7,lr}
;;;494    {
000002  4606              MOV      r6,r0
;;;495      uint32_t tickstart = 0;
;;;496    
;;;497      assert_param(IS_PWR_REGULATOR_VOLTAGE(VoltageScaling));
;;;498    
;;;499      /* Enable Power ctrl clock */
;;;500      __HAL_RCC_PWR_CLK_ENABLE();
000004  482c              LDR      r0,|L1.184|
000006  6801              LDR      r1,[r0,#0]
000008  f0415180          ORR      r1,r1,#0x10000000
00000c  6001              STR      r1,[r0,#0]
00000e  6800              LDR      r0,[r0,#0]
000010  f0005080          AND      r0,r0,#0x10000000
;;;501    
;;;502      /* Check if the PLL is used as system clock or not */
;;;503      if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
000014  9000              STR      r0,[sp,#0]
000016  4829              LDR      r0,|L1.188|
000018  6800              LDR      r0,[r0,#0]
00001a  f000000c          AND      r0,r0,#0xc
00001e  2808              CMP      r0,#8
;;;504      {
;;;505        /* Disable the main PLL */
;;;506        __HAL_RCC_PLL_DISABLE();
;;;507        
;;;508        /* Get Start Tick */
;;;509        tickstart = HAL_GetTick();    
;;;510        /* Wait till PLL is disabled */  
;;;511        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
;;;512        {
;;;513          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
;;;514          {
;;;515            return HAL_TIMEOUT;
;;;516          }
;;;517        }
;;;518        
;;;519        /* Set Range */
;;;520        __HAL_PWR_VOLTAGESCALING_CONFIG(VoltageScaling);
;;;521        
;;;522        /* Enable the main PLL */
;;;523        __HAL_RCC_PLL_ENABLE();
;;;524        
;;;525        /* Get Start Tick */
;;;526        tickstart = HAL_GetTick();
;;;527        /* Wait till PLL is ready */  
;;;528        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
;;;529        {
;;;530          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
;;;531          {
;;;532            return HAL_TIMEOUT;
;;;533          } 
;;;534        }
;;;535        
;;;536        /* Get Start Tick */
;;;537        tickstart = HAL_GetTick();
;;;538        while((__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY) == RESET))
;;;539        {
;;;540          if((HAL_GetTick() - tickstart ) > PWR_VOSRDY_TIMEOUT_VALUE)
;;;541          {
;;;542            return HAL_TIMEOUT;
;;;543          } 
;;;544        }
;;;545      }
;;;546      else
;;;547      {
;;;548        return HAL_ERROR;
000020  bf04              ITT      EQ
000022  2001              MOVEQ    r0,#1
;;;549      }
;;;550      return HAL_OK;
;;;551    }
000024  bdf8              POPEQ    {r3-r7,pc}
000026  4c26              LDR      r4,|L1.192|
000028  6820              LDR      r0,[r4,#0]            ;506
00002a  f0207080          BIC      r0,r0,#0x1000000      ;506
00002e  6020              STR      r0,[r4,#0]            ;506
000030  f7fffffe          BL       HAL_GetTick
000034  4605              MOV      r5,r0                 ;509
000036  6820              LDR      r0,[r4,#0]            ;511
000038  f0107f00          TST      r0,#0x2000000         ;511
00003c  d009              BEQ      |L1.82|
00003e  bf00              NOP                            ;513
                  |L1.64|
000040  f7fffffe          BL       HAL_GetTick
000044  1b40              SUBS     r0,r0,r5              ;513
000046  2802              CMP      r0,#2                 ;513
000048  d82e              BHI      |L1.168|
00004a  6820              LDR      r0,[r4,#0]            ;515
00004c  f0107f00          TST      r0,#0x2000000         ;515
000050  d1f6              BNE      |L1.64|
                  |L1.82|
000052  4d1c              LDR      r5,|L1.196|
000054  6828              LDR      r0,[r5,#0]            ;520
000056  f4204040          BIC      r0,r0,#0xc000         ;520
00005a  4330              ORRS     r0,r0,r6              ;520
00005c  6028              STR      r0,[r5,#0]            ;520
00005e  6828              LDR      r0,[r5,#0]            ;520
000060  f4004040          AND      r0,r0,#0xc000         ;520
000064  9000              STR      r0,[sp,#0]            ;523
000066  6820              LDR      r0,[r4,#0]            ;523
000068  f0407080          ORR      r0,r0,#0x1000000      ;523
00006c  6020              STR      r0,[r4,#0]            ;523
00006e  f7fffffe          BL       HAL_GetTick
000072  4606              MOV      r6,r0                 ;526
000074  6820              LDR      r0,[r4,#0]            ;528
000076  f0107f00          TST      r0,#0x2000000         ;528
00007a  d108              BNE      |L1.142|
                  |L1.124|
00007c  f7fffffe          BL       HAL_GetTick
000080  1b80              SUBS     r0,r0,r6              ;530
000082  2802              CMP      r0,#2                 ;530
000084  d810              BHI      |L1.168|
000086  6820              LDR      r0,[r4,#0]            ;532
000088  f0107f00          TST      r0,#0x2000000         ;532
00008c  d0f6              BEQ      |L1.124|
                  |L1.142|
00008e  f7fffffe          BL       HAL_GetTick
000092  4604              MOV      r4,r0                 ;537
000094  6868              LDR      r0,[r5,#4]            ;538
000096  f4104f80          TST      r0,#0x4000            ;538
00009a  d10b              BNE      |L1.180|
                  |L1.156|
00009c  f7fffffe          BL       HAL_GetTick
0000a0  1b01              SUBS     r1,r0,r4              ;540
0000a2  f5b17f7a          CMP      r1,#0x3e8             ;540
0000a6  d901              BLS      |L1.172|
                  |L1.168|
0000a8  2003              MOVS     r0,#3                 ;542
0000aa  bdf8              POP      {r3-r7,pc}
                  |L1.172|
0000ac  6868              LDR      r0,[r5,#4]            ;542
0000ae  f4104f80          TST      r0,#0x4000            ;542
0000b2  d0f3              BEQ      |L1.156|
                  |L1.180|
0000b4  2000              MOVS     r0,#0                 ;550
0000b6  bdf8              POP      {r3-r7,pc}
;;;552    
                          ENDP

                  |L1.184|
                          DCD      0x40023840
                  |L1.188|
                          DCD      0x40023808
                  |L1.192|
                          DCD      0x40023800
                  |L1.196|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableBkUpReg||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableBkUpReg PROC
;;;179      */
;;;180    HAL_StatusTypeDef HAL_PWREx_DisableBkUpReg(void)
000000  b570              PUSH     {r4-r6,lr}
;;;181    {
;;;182      uint32_t tickstart = 0;
;;;183      
;;;184      /* Disable Backup regulator */
;;;185      PWR->CSR1 &= (uint32_t)~((uint32_t)PWR_CSR1_BRE);
000002  4d0f              LDR      r5,|L2.64|
000004  6868              LDR      r0,[r5,#4]
000006  f4207000          BIC      r0,r0,#0x200
00000a  6068              STR      r0,[r5,#4]
;;;186      
;;;187      /* Workaround for the following hardware bug: */
;;;188      /* Id 19: PWR : No STANDBY wake-up when Back-up RAM enabled (ref. Errata Sheet p23) */
;;;189      PWR->CSR1 |= PWR_CSR1_EIWUP;
00000c  6868              LDR      r0,[r5,#4]
00000e  f4407080          ORR      r0,r0,#0x100
000012  6068              STR      r0,[r5,#4]
;;;190    
;;;191      /* Get tick */
;;;192      tickstart = HAL_GetTick();
000014  f7fffffe          BL       HAL_GetTick
000018  4604              MOV      r4,r0
;;;193    
;;;194      /* Wait till Backup regulator ready flag is set */  
;;;195      while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) != RESET)
00001a  6868              LDR      r0,[r5,#4]
00001c  f0100f08          TST      r0,#8
000020  d00c              BEQ      |L2.60|
;;;196      {
;;;197        if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)
000022  bf00              NOP      
                  |L2.36|
000024  f7fffffe          BL       HAL_GetTick
000028  1b00              SUBS     r0,r0,r4
00002a  f5b07f7a          CMP      r0,#0x3e8
00002e  d901              BLS      |L2.52|
;;;198        {
;;;199          return HAL_TIMEOUT;
000030  2003              MOVS     r0,#3
;;;200        } 
;;;201      }
;;;202      return HAL_OK;
;;;203    }
000032  bd70              POP      {r4-r6,pc}
                  |L2.52|
000034  6868              LDR      r0,[r5,#4]            ;195
000036  f0100f08          TST      r0,#8                 ;195
00003a  d1f3              BNE      |L2.36|
                  |L2.60|
00003c  2000              MOVS     r0,#0                 ;202
00003e  bd70              POP      {r4-r6,pc}
;;;204    
                          ENDP

                  |L2.64|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableFlashPowerDown||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableFlashPowerDown PROC
;;;218      */
;;;219    void HAL_PWREx_DisableFlashPowerDown(void)
000000  4802              LDR      r0,|L3.12|
;;;220    {
;;;221      /* Disable the Flash Power Down */
;;;222      PWR->CR1 &= (uint32_t)~((uint32_t)PWR_CR1_FPDS);
000002  6801              LDR      r1,[r0,#0]
000004  f4217100          BIC      r1,r1,#0x200
000008  6001              STR      r1,[r0,#0]
;;;223    }
00000a  4770              BX       lr
;;;224    
                          ENDP

                  |L3.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableLowRegulatorLowVoltage||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableLowRegulatorLowVoltage PROC
;;;258      */
;;;259    void HAL_PWREx_DisableLowRegulatorLowVoltage(void)
000000  4802              LDR      r0,|L4.12|
;;;260    {
;;;261      /* Disable low power regulator */
;;;262      PWR->CR1 &= (uint32_t)~((uint32_t)PWR_CR1_LPUDS);
000002  6801              LDR      r1,[r0,#0]
000004  f4216180          BIC      r1,r1,#0x400
000008  6001              STR      r1,[r0,#0]
;;;263    }
00000a  4770              BX       lr
;;;264    
                          ENDP

                  |L4.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableMainRegulatorLowVoltage||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableMainRegulatorLowVoltage PROC
;;;238      */
;;;239    void HAL_PWREx_DisableMainRegulatorLowVoltage(void)
000000  4802              LDR      r0,|L5.12|
;;;240    {  
;;;241      /* Disable Main regulator low voltage */
;;;242      PWR->CR1 &= (uint32_t)~((uint32_t)PWR_CR1_MRUDS);
000002  6801              LDR      r1,[r0,#0]
000004  f4216100          BIC      r1,r1,#0x800
000008  6001              STR      r1,[r0,#0]
;;;243    }
00000a  4770              BX       lr
;;;244    
                          ENDP

                  |L5.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableOverDrive||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableOverDrive PROC
;;;320      */
;;;321    HAL_StatusTypeDef HAL_PWREx_DisableOverDrive(void)
000000  481c              LDR      r0,|L6.116|
;;;322    {
000002  b538              PUSH     {r3-r5,lr}
;;;323      uint32_t tickstart = 0;
;;;324      
;;;325      __HAL_RCC_PWR_CLK_ENABLE();
000004  6801              LDR      r1,[r0,#0]
000006  f0415180          ORR      r1,r1,#0x10000000
00000a  6001              STR      r1,[r0,#0]
00000c  6800              LDR      r0,[r0,#0]
;;;326        
;;;327      /* Disable the Over-drive switch */
;;;328      __HAL_PWR_OVERDRIVESWITCHING_DISABLE();
00000e  4d1a              LDR      r5,|L6.120|
000010  f0005080          AND      r0,r0,#0x10000000     ;325
000014  9000              STR      r0,[sp,#0]
000016  6828              LDR      r0,[r5,#0]
000018  f4203000          BIC      r0,r0,#0x20000
00001c  6028              STR      r0,[r5,#0]
;;;329      
;;;330      /* Get tick */
;;;331      tickstart = HAL_GetTick();
00001e  f7fffffe          BL       HAL_GetTick
000022  4604              MOV      r4,r0
;;;332     
;;;333      while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
000024  6868              LDR      r0,[r5,#4]
000026  f4103f00          TST      r0,#0x20000
00002a  d009              BEQ      |L6.64|
                  |L6.44|
;;;334      {
;;;335        if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
00002c  f7fffffe          BL       HAL_GetTick
000030  1b00              SUBS     r0,r0,r4
000032  f5b07f7a          CMP      r0,#0x3e8
000036  d815              BHI      |L6.100|
;;;336        {
;;;337          return HAL_TIMEOUT;
000038  6868              LDR      r0,[r5,#4]
00003a  f4103f00          TST      r0,#0x20000
00003e  d1f5              BNE      |L6.44|
                  |L6.64|
;;;338        }
;;;339      } 
;;;340      
;;;341      /* Disable the Over-drive */
;;;342      __HAL_PWR_OVERDRIVE_DISABLE();
000040  6828              LDR      r0,[r5,#0]
000042  f4203080          BIC      r0,r0,#0x10000
000046  6028              STR      r0,[r5,#0]
;;;343    
;;;344      /* Get tick */
;;;345      tickstart = HAL_GetTick();
000048  f7fffffe          BL       HAL_GetTick
00004c  4604              MOV      r4,r0
;;;346    
;;;347      while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
00004e  6868              LDR      r0,[r5,#4]
000050  f4103f80          TST      r0,#0x10000
000054  d00c              BEQ      |L6.112|
;;;348      {
;;;349        if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
000056  bf00              NOP      
                  |L6.88|
000058  f7fffffe          BL       HAL_GetTick
00005c  1b00              SUBS     r0,r0,r4
00005e  f5b07f7a          CMP      r0,#0x3e8
000062  d901              BLS      |L6.104|
                  |L6.100|
;;;350        {
;;;351          return HAL_TIMEOUT;
000064  2003              MOVS     r0,#3
;;;352        }
;;;353      }
;;;354      
;;;355      return HAL_OK;
;;;356    }
000066  bd38              POP      {r3-r5,pc}
                  |L6.104|
000068  6868              LDR      r0,[r5,#4]            ;351
00006a  f4103f80          TST      r0,#0x10000           ;351
00006e  d1f3              BNE      |L6.88|
                  |L6.112|
000070  2000              MOVS     r0,#0                 ;355
000072  bd38              POP      {r3-r5,pc}
;;;357    
                          ENDP

                  |L6.116|
                          DCD      0x40023840
                  |L6.120|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableBkUpReg||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableBkUpReg PROC
;;;150      */
;;;151    HAL_StatusTypeDef HAL_PWREx_EnableBkUpReg(void)
000000  b570              PUSH     {r4-r6,lr}
;;;152    {
;;;153      uint32_t tickstart = 0;
;;;154    
;;;155      /* Enable Backup regulator */
;;;156      PWR->CSR1 |= PWR_CSR1_BRE;
000002  4d0f              LDR      r5,|L7.64|
000004  6868              LDR      r0,[r5,#4]
000006  f4407000          ORR      r0,r0,#0x200
00000a  6068              STR      r0,[r5,#4]
;;;157        
;;;158      /* Workaround for the following hardware bug: */
;;;159      /* Id 19: PWR : No STANDBY wake-up when Back-up RAM enabled (ref. Errata Sheet p23) */
;;;160      PWR->CSR1 |= PWR_CSR1_EIWUP;
00000c  6868              LDR      r0,[r5,#4]
00000e  f4407080          ORR      r0,r0,#0x100
000012  6068              STR      r0,[r5,#4]
;;;161    
;;;162      /* Get tick */
;;;163      tickstart = HAL_GetTick();
000014  f7fffffe          BL       HAL_GetTick
000018  4604              MOV      r4,r0
;;;164    
;;;165      /* Wait till Backup regulator ready flag is set */  
;;;166      while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) == RESET)
00001a  6868              LDR      r0,[r5,#4]
00001c  f0100f08          TST      r0,#8
000020  d10c              BNE      |L7.60|
;;;167      {
;;;168        if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)
000022  bf00              NOP      
                  |L7.36|
000024  f7fffffe          BL       HAL_GetTick
000028  1b00              SUBS     r0,r0,r4
00002a  f5b07f7a          CMP      r0,#0x3e8
00002e  d901              BLS      |L7.52|
;;;169        {
;;;170          return HAL_TIMEOUT;
000030  2003              MOVS     r0,#3
;;;171        } 
;;;172      }
;;;173      return HAL_OK;
;;;174    }
000032  bd70              POP      {r4-r6,pc}
                  |L7.52|
000034  6868              LDR      r0,[r5,#4]            ;166
000036  f0100f08          TST      r0,#8                 ;166
00003a  d0f3              BEQ      |L7.36|
                  |L7.60|
00003c  2000              MOVS     r0,#0                 ;173
00003e  bd70              POP      {r4-r6,pc}
;;;175    
                          ENDP

                  |L7.64|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableFlashPowerDown||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableFlashPowerDown PROC
;;;208      */
;;;209    void HAL_PWREx_EnableFlashPowerDown(void)
000000  4802              LDR      r0,|L8.12|
;;;210    {
;;;211      /* Enable the Flash Power Down */
;;;212      PWR->CR1 |= PWR_CR1_FPDS;
000002  6801              LDR      r1,[r0,#0]
000004  f4417100          ORR      r1,r1,#0x200
000008  6001              STR      r1,[r0,#0]
;;;213    }
00000a  4770              BX       lr
;;;214    
                          ENDP

                  |L8.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableLowRegulatorLowVoltage||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableLowRegulatorLowVoltage PROC
;;;248      */
;;;249    void HAL_PWREx_EnableLowRegulatorLowVoltage(void)
000000  4802              LDR      r0,|L9.12|
;;;250    {
;;;251      /* Enable low power regulator */
;;;252      PWR->CR1 |= PWR_CR1_LPUDS;
000002  6801              LDR      r1,[r0,#0]
000004  f4416180          ORR      r1,r1,#0x400
000008  6001              STR      r1,[r0,#0]
;;;253    }
00000a  4770              BX       lr
;;;254    
                          ENDP

                  |L9.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableMainRegulatorLowVoltage||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableMainRegulatorLowVoltage PROC
;;;228      */
;;;229    void HAL_PWREx_EnableMainRegulatorLowVoltage(void)
000000  4802              LDR      r0,|L10.12|
;;;230    {
;;;231      /* Enable Main regulator low voltage */
;;;232      PWR->CR1 |= PWR_CR1_MRUDS;
000002  6801              LDR      r1,[r0,#0]
000004  f4416100          ORR      r1,r1,#0x800
000008  6001              STR      r1,[r0,#0]
;;;233    }
00000a  4770              BX       lr
;;;234    
                          ENDP

                  |L10.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableOverDrive||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableOverDrive PROC
;;;274      */
;;;275    HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
000000  481c              LDR      r0,|L11.116|
;;;276    {
000002  b538              PUSH     {r3-r5,lr}
;;;277      uint32_t tickstart = 0;
;;;278    
;;;279      __HAL_RCC_PWR_CLK_ENABLE();
000004  6801              LDR      r1,[r0,#0]
000006  f0415180          ORR      r1,r1,#0x10000000
00000a  6001              STR      r1,[r0,#0]
00000c  6800              LDR      r0,[r0,#0]
;;;280      
;;;281      /* Enable the Over-drive to extend the clock frequency to 216 MHz */
;;;282      __HAL_PWR_OVERDRIVE_ENABLE();
00000e  4d1a              LDR      r5,|L11.120|
000010  f0005080          AND      r0,r0,#0x10000000     ;279
000014  9000              STR      r0,[sp,#0]
000016  6828              LDR      r0,[r5,#0]
000018  f4403080          ORR      r0,r0,#0x10000
00001c  6028              STR      r0,[r5,#0]
;;;283    
;;;284      /* Get tick */
;;;285      tickstart = HAL_GetTick();
00001e  f7fffffe          BL       HAL_GetTick
000022  4604              MOV      r4,r0
;;;286    
;;;287      while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
000024  6868              LDR      r0,[r5,#4]
000026  f4103f80          TST      r0,#0x10000
00002a  d109              BNE      |L11.64|
                  |L11.44|
;;;288      {
;;;289        if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
00002c  f7fffffe          BL       HAL_GetTick
000030  1b00              SUBS     r0,r0,r4
000032  f5b07f7a          CMP      r0,#0x3e8
000036  d815              BHI      |L11.100|
;;;290        {
;;;291          return HAL_TIMEOUT;
000038  6868              LDR      r0,[r5,#4]
00003a  f4103f80          TST      r0,#0x10000
00003e  d0f5              BEQ      |L11.44|
                  |L11.64|
;;;292        }
;;;293      }
;;;294      
;;;295      /* Enable the Over-drive switch */
;;;296      __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
000040  6828              LDR      r0,[r5,#0]
000042  f4403000          ORR      r0,r0,#0x20000
000046  6028              STR      r0,[r5,#0]
;;;297    
;;;298      /* Get tick */
;;;299      tickstart = HAL_GetTick();
000048  f7fffffe          BL       HAL_GetTick
00004c  4604              MOV      r4,r0
;;;300    
;;;301      while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
00004e  6868              LDR      r0,[r5,#4]
000050  f4103f00          TST      r0,#0x20000
000054  d10c              BNE      |L11.112|
;;;302      {
;;;303        if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
000056  bf00              NOP      
                  |L11.88|
000058  f7fffffe          BL       HAL_GetTick
00005c  1b00              SUBS     r0,r0,r4
00005e  f5b07f7a          CMP      r0,#0x3e8
000062  d901              BLS      |L11.104|
                  |L11.100|
;;;304        {
;;;305          return HAL_TIMEOUT;
000064  2003              MOVS     r0,#3
;;;306        }
;;;307      } 
;;;308      return HAL_OK;
;;;309    }
000066  bd38              POP      {r3-r5,pc}
                  |L11.104|
000068  6868              LDR      r0,[r5,#4]            ;305
00006a  f4103f00          TST      r0,#0x20000           ;305
00006e  d0f3              BEQ      |L11.88|
                  |L11.112|
000070  2000              MOVS     r0,#0                 ;308
000072  bd38              POP      {r3-r5,pc}
;;;310    
                          ENDP

                  |L11.116|
                          DCD      0x40023840
                  |L11.120|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnterUnderDriveSTOPMode||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnterUnderDriveSTOPMode PROC
;;;394      */
;;;395    HAL_StatusTypeDef HAL_PWREx_EnterUnderDriveSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;396    {
000004  4680              MOV      r8,r0
;;;397      uint32_t tempreg = 0;
;;;398      uint32_t tickstart = 0;
;;;399      
;;;400      /* Check the parameters */
;;;401      assert_param(IS_PWR_REGULATOR_UNDERDRIVE(Regulator));
;;;402      assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
;;;403      
;;;404      /* Enable Power ctrl clock */
;;;405      __HAL_RCC_PWR_CLK_ENABLE();
000006  4821              LDR      r0,|L12.140|
000008  460f              MOV      r7,r1                 ;396
00000a  6801              LDR      r1,[r0,#0]
00000c  f0415180          ORR      r1,r1,#0x10000000
000010  6001              STR      r1,[r0,#0]
000012  6800              LDR      r0,[r0,#0]
;;;406      /* Enable the Under-drive Mode ---------------------------------------------*/
;;;407      /* Clear Under-drive flag */
;;;408      __HAL_PWR_CLEAR_ODRUDR_FLAG();
000014  4d1e              LDR      r5,|L12.144|
000016  f0005080          AND      r0,r0,#0x10000000     ;405
00001a  9000              STR      r0,[sp,#0]
00001c  6868              LDR      r0,[r5,#4]
00001e  f4402040          ORR      r0,r0,#0xc0000
000022  6068              STR      r0,[r5,#4]
;;;409      
;;;410      /* Enable the Under-drive */ 
;;;411      __HAL_PWR_UNDERDRIVE_ENABLE();
000024  6828              LDR      r0,[r5,#0]
000026  f4402040          ORR      r0,r0,#0xc0000
00002a  6028              STR      r0,[r5,#0]
;;;412    
;;;413      /* Get tick */
;;;414      tickstart = HAL_GetTick();
00002c  f7fffffe          BL       HAL_GetTick
000030  4604              MOV      r4,r0
;;;415    
;;;416      /* Wait for UnderDrive mode is ready */
;;;417      while(__HAL_PWR_GET_FLAG(PWR_FLAG_UDRDY))
000032  6868              LDR      r0,[r5,#4]
000034  f44f2640          MOV      r6,#0xc0000
000038  ea360000          BICS     r0,r6,r0
00003c  d10d              BNE      |L12.90|
;;;418      {
;;;419        if((HAL_GetTick() - tickstart ) > PWR_UDERDRIVE_TIMEOUT_VALUE)
00003e  bf00              NOP      
                  |L12.64|
000040  f7fffffe          BL       HAL_GetTick
000044  1b00              SUBS     r0,r0,r4
000046  f5b07f7a          CMP      r0,#0x3e8
00004a  d902              BLS      |L12.82|
;;;420        {
;;;421          return HAL_TIMEOUT;
00004c  2003              MOVS     r0,#3
;;;422        }
;;;423      }
;;;424      
;;;425      /* Select the regulator state in STOP mode ---------------------------------*/
;;;426      tempreg = PWR->CR1;
;;;427      /* Clear PDDS, LPDS, MRLUDS and LPLUDS bits */
;;;428      tempreg &= (uint32_t)~(PWR_CR1_PDDS | PWR_CR1_LPDS | PWR_CR1_LPUDS | PWR_CR1_MRUDS);
;;;429      
;;;430      /* Set LPDS, MRLUDS and LPLUDS bits according to PWR_Regulator value */
;;;431      tempreg |= Regulator;
;;;432      
;;;433      /* Store the new value */
;;;434      PWR->CR1 = tempreg;
;;;435      
;;;436      /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;437      SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
;;;438      
;;;439      /* Select STOP mode entry --------------------------------------------------*/
;;;440      if(STOPEntry == PWR_SLEEPENTRY_WFI)
;;;441      {   
;;;442        /* Request Wait For Interrupt */
;;;443        __WFI();
;;;444      }
;;;445      else
;;;446      {
;;;447        /* Request Wait For Event */
;;;448        __WFE();
;;;449      }
;;;450      /* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;451      SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
;;;452    
;;;453      return HAL_OK;  
;;;454    }
00004e  e8bd83f8          POP      {r3-r9,pc}
                  |L12.82|
000052  6868              LDR      r0,[r5,#4]            ;421
000054  ea360000          BICS     r0,r6,r0              ;421
000058  d0f2              BEQ      |L12.64|
                  |L12.90|
00005a  480e              LDR      r0,|L12.148|
00005c  6829              LDR      r1,[r5,#0]            ;426
00005e  2f01              CMP      r7,#1                 ;440
000060  f0210103          BIC      r1,r1,#3              ;428
000064  f4216140          BIC      r1,r1,#0xc00          ;428
000068  ea410108          ORR      r1,r1,r8              ;431
00006c  6029              STR      r1,[r5,#0]            ;434
00006e  6801              LDR      r1,[r0,#0]            ;437
000070  f0410104          ORR      r1,r1,#4              ;437
000074  6001              STR      r1,[r0,#0]            ;437
000076  bf0c              ITE      EQ                    ;443
000078  bf30              WFIEQ                          ;443
00007a  bf20              WFENE                          ;448
00007c  6801              LDR      r1,[r0,#0]            ;451
00007e  f0210104          BIC      r1,r1,#4              ;451
000082  6001              STR      r1,[r0,#0]            ;451
000084  2000              MOVS     r0,#0                 ;453
000086  e8bd83f8          POP      {r3-r9,pc}
;;;455    
                          ENDP

00008a  0000              DCW      0x0000
                  |L12.140|
                          DCD      0x40023840
                  |L12.144|
                          DCD      0x40007000
                  |L12.148|
                          DCD      0xe000ed10

                          AREA ||i.HAL_PWREx_GetVoltageRange||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_GetVoltageRange PROC
;;;460      */  
;;;461    uint32_t HAL_PWREx_GetVoltageRange(void)
000000  4802              LDR      r0,|L13.12|
;;;462    {
;;;463      return  (PWR->CR1 & PWR_CR1_VOS);
000002  6800              LDR      r0,[r0,#0]
000004  f4004040          AND      r0,r0,#0xc000
;;;464    }
000008  4770              BX       lr
;;;465    
                          ENDP

00000a  0000              DCW      0x0000
                  |L13.12|
                          DCD      0x40007000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F7_V1.11.0\\Drivers\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_pwr_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f7xx_hal_pwr_ex_c_1028ebfa____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F7_V1.11.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___22_stm32f7xx_hal_pwr_ex_c_1028ebfa____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f7xx_hal_pwr_ex_c_1028ebfa____REVSH|
#line 402
|__asm___22_stm32f7xx_hal_pwr_ex_c_1028ebfa____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f7xx_hal_pwr_ex_c_1028ebfa____RRX|
#line 587
|__asm___22_stm32f7xx_hal_pwr_ex_c_1028ebfa____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
