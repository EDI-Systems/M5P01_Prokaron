; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\kernel.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\kernel.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc\Conf -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\kernel.crf ..\..\MProkaron\Kernel\kernel.c]
                          THUMB

                          AREA ||i.RMP_CRC16||, CODE, READONLY, ALIGN=2

                  RMP_CRC16 PROC
;;;280    #ifdef __RMP_U16_T__
;;;281    rmp_ptr_t RMP_CRC16(const rmp_u8_t* Data, rmp_ptr_t Length)
000000  b530              PUSH     {r4,r5,lr}
;;;282    {
000002  b0c1              SUB      sp,sp,#0x104
000004  460d              MOV      r5,r1
;;;283        rmp_ptr_t Data_Cnt;
;;;284        rmp_u8_t Index;
;;;285        rmp_u8_t Temp_High;
;;;286        rmp_u8_t Temp_Low;
;;;287        
;;;288        /* CRC16 constants with X^16+X^15+X^2+1 */
;;;289        static const rmp_u8_t CRC16_High[256]=
;;;290        {
;;;291            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;292            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;293            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;294            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;295            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;296            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;297            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;298            0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;299            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;300            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;301            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;302            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;303            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;304            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;305            0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;306            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;307            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;308            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;309            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;310            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;311            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;312            0x00, 0xC1, 0x81, 0x40
;;;313        };
;;;314    
;;;315        const rmp_u8_t CRC16_Low[256]=
000006  490e              LDR      r1,|L1.64|
000008  f44f7280          MOV      r2,#0x100
00000c  4604              MOV      r4,r0                 ;282
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       __aeabi_memcpy4
;;;316        {
;;;317            0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,
;;;318            0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,
;;;319            0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9,
;;;320            0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,
;;;321            0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
;;;322            0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,
;;;323            0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,
;;;324            0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38,
;;;325            0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,
;;;326            0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
;;;327            0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,
;;;328            0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,
;;;329            0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB,
;;;330            0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,
;;;331            0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
;;;332            0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,
;;;333            0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,
;;;334            0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,
;;;335            0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89,
;;;336            0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
;;;337            0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83,
;;;338            0x41, 0x81, 0x80, 0x40
;;;339        };
;;;340    
;;;341        Temp_High=0xFF;
000014  f04f03ff          MOV      r3,#0xff
;;;342        Temp_Low=0xFF;
;;;343        for(Data_Cnt=0;Data_Cnt<Length;Data_Cnt++)
000018  2d00              CMP      r5,#0
00001a  461a              MOV      r2,r3                 ;342
00001c  bf1c              ITT      NE                    ;315
00001e  46ec              MOVNE    r12,sp                ;315
;;;344        {
;;;345            Index=Temp_Low^Data[Data_Cnt];
;;;346            Temp_Low=(rmp_u8_t)(Temp_High^CRC16_High[Index]);
000020  4908              LDRNE    r1,|L1.68|
000022  d009              BEQ      |L1.56|
                  |L1.36|
000024  f8140b01          LDRB     r0,[r4],#1            ;345
000028  4050              EORS     r0,r0,r2              ;345
00002a  1e6d              SUBS     r5,r5,#1
00002c  5c0a              LDRB     r2,[r1,r0]
00002e  ea820203          EOR      r2,r2,r3
;;;347            Temp_High=CRC16_Low[Index];
000032  f81c3000          LDRB     r3,[r12,r0]
000036  d1f5              BNE      |L1.36|
                  |L1.56|
;;;348        }
;;;349    
;;;350        return (rmp_u16_t)(((rmp_u16_t)Temp_High)<<8|Temp_Low);
;;;351    }
000038  b041              ADD      sp,sp,#0x104
00003a  ea422003          ORR      r0,r2,r3,LSL #8       ;350
00003e  bd30              POP      {r4,r5,pc}
;;;352    #endif
                          ENDP

                  |L1.64|
                          DCD      ||.constdata||+0x200
                  |L1.68|
                          DCD      ||.constdata||+0x100

                          AREA ||i.RMP_Clear||, CODE, READONLY, ALIGN=1

                  RMP_Clear PROC
;;;67     ******************************************************************************/
;;;68     void RMP_Clear(volatile void* Addr, rmp_ptr_t Size)
000000  2900              CMP      r1,#0
;;;69     {
;;;70         rmp_u8_t* Ptr;
;;;71         rmp_cnt_t Count;
;;;72        
;;;73         Ptr=(rmp_u8_t*)Addr;
;;;74         for(Count=0;Count<Size;Count++)
;;;75             Ptr[Count]=0;
;;;76     }
000002  bf08              IT       EQ
000004  4770              BXEQ     lr
000006  f0110f01          TST      r1,#1
00000a  f04f0200          MOV      r2,#0
00000e  f1a00001          SUB      r0,r0,#1
000012  bf18              IT       NE                    ;75
000014  f8002f01          STRBNE   r2,[r0,#1]!           ;75
000018  0849              LSRS     r1,r1,#1              ;74
00001a  bf08              IT       EQ
00001c  4770              BXEQ     lr
                  |L2.30|
00001e  7042              STRB     r2,[r0,#1]            ;75
000020  1e49              SUBS     r1,r1,#1              ;75
000022  f8002f02          STRB     r2,[r0,#2]!           ;75
000026  d1fa              BNE      |L2.30|
000028  4770              BX       lr
;;;77     /* End Function:RMP_Clear ****************************************************/
                          ENDP


                          AREA ||i.RMP_Free||, CODE, READONLY, ALIGN=1

                  RMP_Free PROC
;;;2505   ******************************************************************************/
;;;2506   void RMP_Free(volatile void* Pool, void* Mem_Ptr)
000000  2800              CMP      r0,#0
;;;2507   {
;;;2508       volatile struct RMP_Mem* Mem; 
;;;2509       volatile struct RMP_Mem_Head* Mem_Head;
;;;2510       volatile struct RMP_Mem_Head* Left_Head;
;;;2511       volatile struct RMP_Mem_Head* Right_Head;
;;;2512       rmp_cnt_t Merge_Left;
;;;2513   
;;;2514       /* Check if pointer is null */
;;;2515       if((Pool==0)||(Mem_Ptr==0))
000002  bf1c              ITT      NE
000004  2900              CMPNE    r1,#0
;;;2516       {
;;;2517           RMP_COVERAGE_MARKER();
;;;2518           return;
;;;2519       }
;;;2520       else
;;;2521           RMP_COVERAGE_MARKER();
;;;2522       
;;;2523       /* See if the address is within the allocatable address range. If not, abort directly. */
;;;2524       Mem=(volatile struct RMP_Mem*)Pool;
;;;2525       if((((rmp_ptr_t)Mem_Ptr)<=((rmp_ptr_t)Mem))||(((rmp_ptr_t)Mem_Ptr)>=(((rmp_ptr_t)Mem)+Mem->Size)))
000006  4281              CMPNE    r1,r0
;;;2526       {
;;;2527           RMP_COVERAGE_MARKER();
;;;2528           return;
;;;2529       }
;;;2530       else
;;;2531           RMP_COVERAGE_MARKER();
;;;2532   
;;;2533       Mem_Head=(struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Ptr)-sizeof(struct RMP_Mem_Head));
;;;2534       /* See if the block can really be freed */
;;;2535       if(Mem_Head->State==RMP_MEM_FREE)
;;;2536       {
;;;2537           RMP_COVERAGE_MARKER();
;;;2538           return;
;;;2539       }
;;;2540       else
;;;2541           RMP_COVERAGE_MARKER();
;;;2542   
;;;2543       /* Now we are sure that it can be freed. Delete it from the allocated list now */
;;;2544       RMP_List_Del(Mem_Head->Head.Prev,Mem_Head->Head.Next);
;;;2545       Mem_Head->State=RMP_MEM_FREE;
;;;2546       
;;;2547       /* Now check if we can merge it with the higher blocks */
;;;2548       Right_Head=(struct RMP_Mem_Head*)(((rmp_ptr_t)(Mem_Head->Tail))+sizeof(struct RMP_Mem_Tail));
;;;2549       if(((rmp_ptr_t)Right_Head)!=(((rmp_ptr_t)Mem)+Mem->Size))
;;;2550       {
;;;2551           RMP_COVERAGE_MARKER();
;;;2552           /* If this one is unoccupied */
;;;2553           if((Right_Head->State)==RMP_MEM_FREE)
;;;2554           {
;;;2555               RMP_COVERAGE_MARKER();
;;;2556               /* Delete, merge */
;;;2557               _RMP_Mem_Del(Pool,Right_Head);
;;;2558               _RMP_Mem_Block(Mem_Head,
;;;2559                              ((rmp_ptr_t)(Right_Head->Tail))+sizeof(struct RMP_Mem_Tail)-(rmp_ptr_t)Mem_Head);
;;;2560           }
;;;2561           else
;;;2562               RMP_COVERAGE_MARKER();
;;;2563       }
;;;2564       else
;;;2565           RMP_COVERAGE_MARKER();
;;;2566   
;;;2567       /* Now check if we can merge it with the lower blocks */
;;;2568       Merge_Left=0;
;;;2569       if((rmp_ptr_t)Mem_Head!=Mem->Start)
;;;2570       {
;;;2571           RMP_COVERAGE_MARKER();
;;;2572           Left_Head=((struct RMP_Mem_Tail*)(((rmp_ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Tail)))->Head;
;;;2573   
;;;2574           /* If this one is unoccupied */
;;;2575           if(Left_Head->State==RMP_MEM_FREE)
;;;2576           {
;;;2577               RMP_COVERAGE_MARKER();
;;;2578               /* Delete, merge */
;;;2579               _RMP_Mem_Del(Pool, Left_Head);
;;;2580               _RMP_Mem_Block(Left_Head,
;;;2581                              (rmp_ptr_t)((rmp_ptr_t)(Mem_Head->Tail)+sizeof(struct RMP_Mem_Tail)-(rmp_ptr_t)Left_Head));
;;;2582   
;;;2583               /* We have completed the merge here and the original block has destroyed.
;;;2584                * Thus there's no need to insert it into the list again */
;;;2585               Merge_Left=1;
;;;2586           }
;;;2587           else
;;;2588               RMP_COVERAGE_MARKER();
;;;2589       }
;;;2590       else
;;;2591           RMP_COVERAGE_MARKER();
;;;2592   
;;;2593       /* If we did not merge it with the left-side blocks, insert the original pointer's block 
;;;2594        * into the TLSF table(Merging with the right-side one won't disturb this) */
;;;2595       if(Merge_Left==0)
;;;2596       {
;;;2597           RMP_COVERAGE_MARKER();
;;;2598           _RMP_Mem_Ins(Pool, Mem_Head);
;;;2599       }
;;;2600       else
;;;2601       {
;;;2602           RMP_COVERAGE_MARKER();
;;;2603           _RMP_Mem_Ins(Pool, Left_Head);
;;;2604       }
;;;2605   }
000008  bf98              IT       LS
00000a  4770              BXLS     lr
00000c  e92d47f0          PUSH     {r4-r10,lr}           ;2507
000010  6902              LDR      r2,[r0,#0x10]         ;2525
000012  4604              MOV      r4,r0                 ;2507
000014  1910              ADDS     r0,r2,r4              ;2525
000016  4288              CMP      r0,r1                 ;2525
000018  bf98              IT       LS
00001a  e8bd87f0          POPLS    {r4-r10,pc}
00001e  f1a10510          SUB      r5,r1,#0x10           ;2533
000022  f8510c08          LDR      r0,[r1,#-8]           ;2535
000026  2800              CMP      r0,#0                 ;2535
000028  bf08              IT       EQ
00002a  e8bd87f0          POPEQ    {r4-r10,pc}
00002e  6828              LDR      r0,[r5,#0]            ;2544
000030  6869              LDR      r1,[r5,#4]            ;2544
000032  6008              STR      r0,[r1,#0]            ;2544
000034  6041              STR      r1,[r0,#4]            ;2544
000036  f04f0800          MOV      r8,#0                 ;2545
00003a  f8c58008          STR      r8,[r5,#8]            ;2545
00003e  68ea              LDR      r2,[r5,#0xc]          ;2548
000040  6921              LDR      r1,[r4,#0x10]         ;2549
000042  2701              MOVS     r7,#1                 ;2549
000044  1d16              ADDS     r6,r2,#4              ;2548
000046  1908              ADDS     r0,r1,r4              ;2549
000048  42b0              CMP      r0,r6                 ;2549
00004a  d030              BEQ      |L3.174|
00004c  68b0              LDR      r0,[r6,#8]            ;2553
00004e  bb70              CBNZ     r0,|L3.174|
000050  68f0              LDR      r0,[r6,#0xc]          ;2553
000052  46a2              MOV      r10,r4                ;2557
000054  1b80              SUBS     r0,r0,r6              ;2557
000056  f1a00910          SUB      r9,r0,#0x10           ;2557
00005a  4648              MOV      r0,r9                 ;2557
00005c  f7fffffe          BL       RMP_MSB_Get
000060  1ec1              SUBS     r1,r0,#3              ;2557
000062  6832              LDR      r2,[r6,#0]            ;2557
000064  fa29f101          LSR      r1,r9,r1              ;2557
000068  1f80              SUBS     r0,r0,#6              ;2557
00006a  f0010107          AND      r1,r1,#7              ;2557
00006e  eb0100c0          ADD      r0,r1,r0,LSL #3       ;2557
000072  eb0a01c0          ADD      r1,r10,r0,LSL #3      ;2557
000076  6873              LDR      r3,[r6,#4]            ;2557
000078  601a              STR      r2,[r3,#0]            ;2557
00007a  6053              STR      r3,[r2,#4]            ;2557
00007c  6aca              LDR      r2,[r1,#0x2c]         ;2557
00007e  3128              ADDS     r1,r1,#0x28           ;2557
000080  428a              CMP      r2,r1                 ;2557
000082  d10a              BNE      |L3.154|
000084  0942              LSRS     r2,r0,#5              ;2557
000086  f000011f          AND      r1,r0,#0x1f           ;2557
00008a  eb0a0082          ADD      r0,r10,r2,LSL #2      ;2557
00008e  6942              LDR      r2,[r0,#0x14]         ;2557
000090  fa07f101          LSL      r1,r7,r1              ;2557
000094  ea220101          BIC      r1,r2,r1              ;2557
000098  6141              STR      r1,[r0,#0x14]         ;2557
                  |L3.154|
00009a  68f0              LDR      r0,[r6,#0xc]          ;2558
00009c  f8c58008          STR      r8,[r5,#8]            ;2558
0000a0  1b40              SUBS     r0,r0,r5              ;2558
0000a2  1d00              ADDS     r0,r0,#4              ;2558
0000a4  4428              ADD      r0,r0,r5              ;2558
0000a6  1f00              SUBS     r0,r0,#4              ;2558
0000a8  60e8              STR      r0,[r5,#0xc]          ;2558
0000aa  68e8              LDR      r0,[r5,#0xc]          ;2558
0000ac  6005              STR      r5,[r0,#0]            ;2558
                  |L3.174|
0000ae  68e0              LDR      r0,[r4,#0xc]          ;2569
0000b0  42a8              CMP      r0,r5                 ;2569
0000b2  d003              BEQ      |L3.188|
0000b4  f8556c04          LDR      r6,[r5,#-4]           ;2572
0000b8  68b0              LDR      r0,[r6,#8]            ;2575
0000ba  b328              CBZ      r0,|L3.264|
                  |L3.188|
0000bc  68e8              LDR      r0,[r5,#0xc]          ;2575
0000be  1b40              SUBS     r0,r0,r5              ;2575
0000c0  f1a00610          SUB      r6,r0,#0x10           ;2575
0000c4  4630              MOV      r0,r6                 ;2575
0000c6  f7fffffe          BL       RMP_MSB_Get
0000ca  1ec1              SUBS     r1,r0,#3              ;2575
0000cc  fa26f101          LSR      r1,r6,r1              ;2575
0000d0  1f80              SUBS     r0,r0,#6              ;2575
0000d2  f0010107          AND      r1,r1,#7              ;2575
0000d6  eb0101c0          ADD      r1,r1,r0,LSL #3       ;2575
0000da  eb0400c1          ADD      r0,r4,r1,LSL #3       ;2575
0000de  6ac2              LDR      r2,[r0,#0x2c]         ;2575
0000e0  3028              ADDS     r0,r0,#0x28           ;2575
0000e2  4282              CMP      r2,r0                 ;2575
0000e4  d109              BNE      |L3.250|
0000e6  094b              LSRS     r3,r1,#5              ;2575
0000e8  f001021f          AND      r2,r1,#0x1f           ;2575
0000ec  eb040183          ADD      r1,r4,r3,LSL #2       ;2575
0000f0  694b              LDR      r3,[r1,#0x14]         ;2575
0000f2  fa07f202          LSL      r2,r7,r2              ;2575
0000f6  431a              ORRS     r2,r2,r3              ;2575
0000f8  614a              STR      r2,[r1,#0x14]         ;2575
                  |L3.250|
0000fa  6841              LDR      r1,[r0,#4]            ;2575
0000fc  600d              STR      r5,[r1,#0]            ;2575
0000fe  6069              STR      r1,[r5,#4]            ;2575
000100  6028              STR      r0,[r5,#0]            ;2575
000102  6045              STR      r5,[r0,#4]            ;2575
000104  e8bd87f0          POP      {r4-r10,pc}
                  |L3.264|
000108  68f0              LDR      r0,[r6,#0xc]
00010a  1b80              SUBS     r0,r0,r6
00010c  f1a00910          SUB      r9,r0,#0x10
000110  4648              MOV      r0,r9
000112  f7fffffe          BL       RMP_MSB_Get
000116  1ec1              SUBS     r1,r0,#3
000118  fa29f101          LSR      r1,r9,r1
00011c  1f80              SUBS     r0,r0,#6
00011e  f0010107          AND      r1,r1,#7
000122  eb0100c0          ADD      r0,r1,r0,LSL #3
000126  eb0401c0          ADD      r1,r4,r0,LSL #3
00012a  f1010228          ADD      r2,r1,#0x28
00012e  6831              LDR      r1,[r6,#0]
000130  6873              LDR      r3,[r6,#4]
000132  6019              STR      r1,[r3,#0]
000134  604b              STR      r3,[r1,#4]
000136  6851              LDR      r1,[r2,#4]
000138  4291              CMP      r1,r2
00013a  d10a              BNE      |L3.338|
00013c  0942              LSRS     r2,r0,#5
00013e  f000011f          AND      r1,r0,#0x1f
000142  eb040082          ADD      r0,r4,r2,LSL #2
000146  6942              LDR      r2,[r0,#0x14]
000148  fa07f101          LSL      r1,r7,r1
00014c  ea220101          BIC      r1,r2,r1
000150  6141              STR      r1,[r0,#0x14]
                  |L3.338|
000152  68e8              LDR      r0,[r5,#0xc]          ;2580
000154  f8c68008          STR      r8,[r6,#8]            ;2580
000158  1b80              SUBS     r0,r0,r6              ;2580
00015a  1d00              ADDS     r0,r0,#4              ;2580
00015c  4430              ADD      r0,r0,r6              ;2580
00015e  1f00              SUBS     r0,r0,#4              ;2580
000160  60f0              STR      r0,[r6,#0xc]          ;2580
000162  68f0              LDR      r0,[r6,#0xc]          ;2580
000164  6006              STR      r6,[r0,#0]            ;2580
000166  68f0              LDR      r0,[r6,#0xc]          ;2580
000168  1b80              SUBS     r0,r0,r6              ;2580
00016a  f1a00510          SUB      r5,r0,#0x10           ;2580
00016e  4628              MOV      r0,r5                 ;2580
000170  f7fffffe          BL       RMP_MSB_Get
000174  1ec1              SUBS     r1,r0,#3              ;2580
000176  fa25f101          LSR      r1,r5,r1              ;2580
00017a  1f80              SUBS     r0,r0,#6              ;2580
00017c  f0010107          AND      r1,r1,#7              ;2580
000180  eb0101c0          ADD      r1,r1,r0,LSL #3       ;2580
000184  eb0400c1          ADD      r0,r4,r1,LSL #3       ;2580
000188  6ac2              LDR      r2,[r0,#0x2c]         ;2580
00018a  3028              ADDS     r0,r0,#0x28           ;2580
00018c  4282              CMP      r2,r0                 ;2580
00018e  d109              BNE      |L3.420|
000190  094b              LSRS     r3,r1,#5              ;2585
000192  f001021f          AND      r2,r1,#0x1f           ;2585
000196  eb040183          ADD      r1,r4,r3,LSL #2       ;2585
00019a  694b              LDR      r3,[r1,#0x14]         ;2585
00019c  fa07f202          LSL      r2,r7,r2              ;2585
0001a0  431a              ORRS     r2,r2,r3              ;2585
0001a2  614a              STR      r2,[r1,#0x14]         ;2585
                  |L3.420|
0001a4  6841              LDR      r1,[r0,#4]            ;2585
0001a6  600e              STR      r6,[r1,#0]            ;2585
0001a8  6071              STR      r1,[r6,#4]            ;2585
0001aa  6030              STR      r0,[r6,#0]            ;2585
0001ac  6046              STR      r6,[r0,#4]            ;2585
0001ae  e8bd87f0          POP      {r4-r10,pc}
;;;2606   /* End Function:RMP_Free *****************************************************/
                          ENDP


                          AREA ||i.RMP_Init||, CODE, READONLY, ALIGN=2

                  RMP_Init PROC
;;;1971   ******************************************************************************/
;;;1972   void RMP_Init(void)
000000  20ff              MOVS     r0,#0xff
000002  f7fffffe          BL       RMP_Mask_Int
000006  4808              LDR      r0,|L4.40|
000008  2101              MOVS     r1,#1
00000a  6041              STR      r1,[r0,#4]  ; RMP_Sched_Locked
00000c  6801              LDR      r1,[r0,#0]  ; RMP_Sched_Lock_Cnt
00000e  1c49              ADDS     r1,r1,#1
000010  6001              STR      r1,[r0,#0]  ; RMP_Sched_Lock_Cnt
;;;1973   {
;;;1974       RMP_Lock_Sched();
;;;1975       
;;;1976       /* Platform will use this hook to do something */
;;;1977       _RMP_Plat_Hook();
000012  f7fffffe          BL       _RMP_Plat_Hook
;;;1978       /* Start the second thread here */
;;;1979       RMP_Init_Hook();
000016  f7fffffe          BL       RMP_Init_Hook
;;;1980       
;;;1981       RMP_Unlock_Sched();
00001a  f7fffffe          BL       RMP_Unlock_Sched
;;;1982       
;;;1983       while(1)
;;;1984           RMP_Init_Idle();
00001e  bf00              NOP      
                  |L4.32|
000020  f7fffffe          BL       RMP_Init_Idle
000024  e7fc              B        |L4.32|
;;;1985   }
;;;1986   /* End Function:RMP_Init *****************************************************/
                          ENDP

000026  0000              DCW      0x0000
                  |L4.40|
                          DCD      ||.data||

                          AREA ||i.RMP_LSB_Get||, CODE, READONLY, ALIGN=2

                  RMP_LSB_Get PROC
;;;2119   ******************************************************************************/
;;;2120   rmp_ptr_t RMP_LSB_Get(rmp_ptr_t Val)
000000  b570              PUSH     {r4-r6,lr}
000002  4a0d              LDR      r2,|L5.56|
;;;2121   {
000004  0e05              LSRS     r5,r0,#24
000006  f3c04c07          UBFX     r12,r0,#16,#8
00000a  f3c02307          UBFX     r3,r0,#8,#8
00000e  b2c4              UXTB     r4,r0
000010  5d50              LDRB     r0,[r2,r5]
000012  f812c00c          LDRB     r12,[r2,r12]
000016  5cd3              LDRB     r3,[r2,r3]
000018  f3600107          BFI      r1,r0,#0,#8
00001c  5d12              LDRB     r2,[r2,r4]
00001e  4608              MOV      r0,r1
000020  f36c200f          BFI      r0,r12,#8,#8
000024  f3634017          BFI      r0,r3,#16,#8
000028  f362601f          BFI      r0,r2,#24,#8
;;;2122       return RMP_WORD_SIZE-1-RMP_MSB_Get(RMP_RBIT_Get(Val));
00002c  f7fffffe          BL       RMP_MSB_Get
000030  f1c0001f          RSB      r0,r0,#0x1f
;;;2123   }
000034  bd70              POP      {r4-r6,pc}
;;;2124   /* End Function:RMP_LSB_Get **************************************************/
                          ENDP

000036  0000              DCW      0x0000
                  |L5.56|
                          DCD      ||.constdata||

                          AREA ||i.RMP_List_Crt||, CODE, READONLY, ALIGN=1

                  RMP_List_Crt PROC
;;;231    ******************************************************************************/
;;;232    void RMP_List_Crt(volatile struct RMP_List* Head)
000000  6000              STR      r0,[r0,#0]
;;;233    {
;;;234        Head->Prev=(struct RMP_List*)Head;
;;;235        Head->Next=(struct RMP_List*)Head;
000002  6040              STR      r0,[r0,#4]
;;;236    }
000004  4770              BX       lr
;;;237    /* End Function:RMP_List_Crt *************************************************/
                          ENDP


                          AREA ||i.RMP_List_Del||, CODE, READONLY, ALIGN=1

                  RMP_List_Del PROC
;;;245    ******************************************************************************/
;;;246    void RMP_List_Del(volatile struct RMP_List* Prev,volatile struct RMP_List* Next)
000000  6008              STR      r0,[r1,#0]
;;;247    {
;;;248        Next->Prev=(struct RMP_List*)Prev;
;;;249        Prev->Next=(struct RMP_List*)Next;
000002  6041              STR      r1,[r0,#4]
;;;250    }
000004  4770              BX       lr
;;;251    /* End Function:RMP_List_Del *************************************************/
                          ENDP


                          AREA ||i.RMP_List_Ins||, CODE, READONLY, ALIGN=1

                  RMP_List_Ins PROC
;;;260    ******************************************************************************/
;;;261    void RMP_List_Ins(volatile struct RMP_List* New,
000000  6010              STR      r0,[r2,#0]
;;;262                      volatile struct RMP_List* Prev,
;;;263                      volatile struct RMP_List* Next)
;;;264    {
;;;265        Next->Prev=(struct RMP_List*)New;
;;;266        New->Next=(struct RMP_List*)Next;
000002  6042              STR      r2,[r0,#4]
;;;267        New->Prev=(struct RMP_List*)Prev;
000004  6001              STR      r1,[r0,#0]
;;;268        Prev->Next=(struct RMP_List*)New;
000006  6048              STR      r0,[r1,#4]
;;;269    }
000008  4770              BX       lr
;;;270    /* End Function:RMP_List_Ins *************************************************/
                          ENDP


                          AREA ||i.RMP_Load_Ctx||, CODE, READONLY, ALIGN=1

                  RMP_Load_Ctx PROC
;;;1956   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1957   void RMP_Load_Ctx(void)
000000  4770              BX       lr
;;;1958   {
;;;1959       return;
;;;1960   }
;;;1961   #endif
                          ENDP


                          AREA ||i.RMP_Lock_Sched||, CODE, READONLY, ALIGN=2

                  RMP_Lock_Sched PROC
;;;361    ******************************************************************************/
;;;362    void RMP_Lock_Sched(void)
000000  20ff              MOVS     r0,#0xff
;;;363    {
000002  b510              PUSH     {r4,lr}
;;;364        RMP_MASK_INT();
000004  f7fffffe          BL       RMP_Mask_Int
;;;365        RMP_Sched_Locked=1;
000008  4803              LDR      r0,|L10.24|
00000a  2101              MOVS     r1,#1
00000c  6041              STR      r1,[r0,#4]  ; RMP_Sched_Locked
;;;366        RMP_Sched_Lock_Cnt++;
00000e  6801              LDR      r1,[r0,#0]  ; RMP_Sched_Lock_Cnt
000010  1c49              ADDS     r1,r1,#1
000012  6001              STR      r1,[r0,#0]  ; RMP_Sched_Lock_Cnt
;;;367    }
000014  bd10              POP      {r4,pc}
;;;368    /* End Function:RMP_Lock_Sched ***********************************************/
                          ENDP

000016  0000              DCW      0x0000
                  |L10.24|
                          DCD      ||.data||

                          AREA ||i.RMP_Malloc||, CODE, READONLY, ALIGN=2

                  RMP_Malloc PROC
;;;2431   ******************************************************************************/
;;;2432   void* RMP_Malloc(volatile void* Pool, rmp_ptr_t Size)                                                       
000000  2800              CMP      r0,#0
;;;2433   {    
;;;2434       rmp_cnt_t FLI_Level;
;;;2435       rmp_cnt_t SLI_Level;
;;;2436       volatile struct RMP_Mem* Mem;
;;;2437       rmp_ptr_t Old_Size;
;;;2438       volatile struct RMP_Mem_Head* Mem_Head;
;;;2439       rmp_ptr_t Rounded_Size;
;;;2440       volatile struct RMP_Mem_Head* New_Mem;
;;;2441       rmp_ptr_t New_Size;
;;;2442       
;;;2443       if((Pool==0)||(Size==0))
000002  bf12              ITEE     NE
000004  2900              CMPNE    r1,#0
;;;2444       {
;;;2445           RMP_COVERAGE_MARKER();
;;;2446           return (void*)(0);
000006  2000              MOVEQ    r0,#0
;;;2447       }
;;;2448       else
;;;2449           RMP_COVERAGE_MARKER();
;;;2450       
;;;2451       /* Round up the size:a multiple of 8 and bigger than 64B */
;;;2452       Rounded_Size=(((Size-1)>>3)+1)<<3;
;;;2453       /* See if it is smaller than the smallest block */
;;;2454       Rounded_Size=(Rounded_Size>64)?Rounded_Size:64;
;;;2455   
;;;2456       /* See if such block exists, if not, abort */
;;;2457       if(_RMP_Mem_Search(Pool,Rounded_Size,&FLI_Level,&SLI_Level)!=0)
;;;2458       {
;;;2459           RMP_COVERAGE_MARKER();
;;;2460           return (void*)(0);
;;;2461       }
;;;2462       else
;;;2463           RMP_COVERAGE_MARKER();
;;;2464       
;;;2465       Mem=(volatile struct RMP_Mem*)Pool;
;;;2466       
;;;2467       /* There is such block. Get it and delete it from the TLSF list. */
;;;2468       Mem_Head=(struct RMP_Mem_Head*)(Mem->Table[RMP_MEM_POS(FLI_Level,SLI_Level)].Next);
;;;2469       _RMP_Mem_Del(Pool, Mem_Head);
;;;2470   
;;;2471       /* Allocate and calculate if the space left could be big enough to be a new 
;;;2472        * block. If so, we will put the block back into the TLSF table */
;;;2473       New_Size=((rmp_ptr_t)(Mem_Head->Tail))-((rmp_ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Head)-Rounded_Size;
;;;2474       if(New_Size>=(sizeof(struct RMP_Mem_Head)+64+sizeof(struct RMP_Mem_Tail)))
;;;2475       {
;;;2476           RMP_COVERAGE_MARKER();
;;;2477           Old_Size=sizeof(struct RMP_Mem_Head)+Rounded_Size+sizeof(struct RMP_Mem_Tail);
;;;2478           New_Mem=(volatile struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Head)+Old_Size);
;;;2479   
;;;2480           _RMP_Mem_Block(Mem_Head, Old_Size);
;;;2481           _RMP_Mem_Block(New_Mem, New_Size);
;;;2482   
;;;2483           /* Put the extra block back */
;;;2484           _RMP_Mem_Ins(Pool, New_Mem);
;;;2485       }
;;;2486       else
;;;2487           RMP_COVERAGE_MARKER();
;;;2488   
;;;2489       /* Insert the allocated block into the lists */
;;;2490       RMP_List_Ins(&(Mem_Head->Head),&(Mem->Alloc),Mem->Alloc.Next);
;;;2491       Mem_Head->State=RMP_MEM_USED;
;;;2492   
;;;2493       /* Finally, return the start address */
;;;2494       return (void*)(((rmp_ptr_t)Mem_Head)+sizeof(struct RMP_Mem_Head));
;;;2495   }
000008  4770              BXEQ     lr
00000a  e92d5ff0          PUSH     {r4-r12,lr}           ;2433
00000e  4605              MOV      r5,r0                 ;2433
000010  1e48              SUBS     r0,r1,#1              ;2452
000012  2701              MOVS     r7,#1                 ;2452
000014  08c0              LSRS     r0,r0,#3              ;2452
000016  00c0              LSLS     r0,r0,#3              ;2452
000018  f1000608          ADD      r6,r0,#8              ;2452
00001c  2e40              CMP      r6,#0x40              ;2454
00001e  bf98              IT       LS                    ;2454
000020  2640              MOVLS    r6,#0x40              ;2454
000022  4630              MOV      r0,r6                 ;2454
000024  f7fffffe          BL       RMP_MSB_Get
000028  1f81              SUBS     r1,r0,#6              ;2454
00002a  1ec2              SUBS     r2,r0,#3              ;2454
00002c  fa26f002          LSR      r0,r6,r2              ;2454
000030  f0000007          AND      r0,r0,#7              ;2454
000034  f1000308          ADD      r3,r0,#8              ;2454
000038  fa03f202          LSL      r2,r3,r2              ;2454
00003c  42b2              CMP      r2,r6                 ;2454
00003e  d004              BEQ      |L11.74|
000040  1c40              ADDS     r0,r0,#1              ;2454
000042  2808              CMP      r0,#8                 ;2454
000044  bf04              ITT      EQ                    ;2454
000046  2000              MOVEQ    r0,#0                 ;2454
000048  1c49              ADDEQ    r1,r1,#1              ;2454
                  |L11.74|
00004a  46a9              MOV      r9,r5                 ;2454
00004c  68aa              LDR      r2,[r5,#8]            ;2454
00004e  4291              CMP      r1,r2                 ;2454
000050  f08080d6          BCS.W    |L11.512|
000054  eb0004c1          ADD      r4,r0,r1,LSL #3       ;2454
000058  f0040b1f          AND      r11,r4,#0x1f          ;2454
00005c  1160              ASRS     r0,r4,#5              ;2454
00005e  eb090080          ADD      r0,r9,r0,LSL #2       ;2454
000062  6940              LDR      r0,[r0,#0x14]         ;2454
000064  f8dfa1a0          LDR      r10,|L11.520|
000068  fa20f10b          LSR      r1,r0,r11             ;2454
00006c  0e0a              LSRS     r2,r1,#24             ;2454
00006e  f3c14307          UBFX     r3,r1,#16,#8          ;2454
000072  f3c12c07          UBFX     r12,r1,#8,#8          ;2454
000076  f81a2002          LDRB     r2,[r10,r2]           ;2454
00007a  b2c9              UXTB     r1,r1                 ;2454
00007c  f81a3003          LDRB     r3,[r10,r3]           ;2454
000080  f81ac00c          LDRB     r12,[r10,r12]         ;2454
000084  f3620007          BFI      r0,r2,#0,#8           ;2454
000088  f81a1001          LDRB     r1,[r10,r1]           ;2454
00008c  f363200f          BFI      r0,r3,#8,#8           ;2454
000090  f36c4017          BFI      r0,r12,#16,#8         ;2454
000094  f361601f          BFI      r0,r1,#24,#8          ;2454
000098  f7fffffe          BL       RMP_MSB_Get
00009c  f1c0001f          RSB      r0,r0,#0x1f           ;2454
0000a0  f04f0800          MOV      r8,#0                 ;2454
0000a4  2820              CMP      r0,#0x20              ;2454
0000a6  d208              BCS      |L11.186|
0000a8  f024011f          BIC      r1,r4,#0x1f           ;2454
0000ac  4408              ADD      r0,r0,r1              ;2454
0000ae  eb00010b          ADD      r1,r0,r11             ;2454
0000b2  10c8              ASRS     r0,r1,#3              ;2454
0000b4  f0010107          AND      r1,r1,#7              ;2454
0000b8  e02d              B        |L11.278|
                  |L11.186|
0000ba  eb071464          ADD      r4,r7,r4,ASR #5       ;2454
0000be  2c05              CMP      r4,#5                 ;2454
0000c0  da7e              BGE      |L11.448|
0000c2  bf00              NOP                            ;2454
                  |L11.196|
0000c4  eb090084          ADD      r0,r9,r4,LSL #2       ;2454
0000c8  6940              LDR      r0,[r0,#0x14]         ;2454
0000ca  2800              CMP      r0,#0                 ;2454
0000cc  d079              BEQ      |L11.450|
0000ce  eb090084          ADD      r0,r9,r4,LSL #2       ;2454
0000d2  6940              LDR      r0,[r0,#0x14]         ;2454
0000d4  f0000bff          AND      r11,r0,#0xff          ;2454
0000d8  0e02              LSRS     r2,r0,#24             ;2454
0000da  f3c04307          UBFX     r3,r0,#16,#8          ;2454
0000de  f3c02907          UBFX     r9,r0,#8,#8           ;2454
0000e2  f81ac002          LDRB     r12,[r10,r2]          ;2454
0000e6  f81a3003          LDRB     r3,[r10,r3]           ;2454
0000ea  f81a0009          LDRB     r0,[r10,r9]           ;2454
0000ee  f36c0107          BFI      r1,r12,#0,#8          ;2454
0000f2  f81a200b          LDRB     r2,[r10,r11]          ;2454
0000f6  f363210f          BFI      r1,r3,#8,#8           ;2454
0000fa  f3604117          BFI      r1,r0,#16,#8          ;2454
0000fe  4608              MOV      r0,r1                 ;2454
000100  f362601f          BFI      r0,r2,#24,#8          ;2454
000104  f7fffffe          BL       RMP_MSB_Get
000108  f1c0001f          RSB      r0,r0,#0x1f           ;2454
00010c  eb001244          ADD      r2,r0,r4,LSL #5       ;2454
000110  f0000107          AND      r1,r0,#7              ;2454
000114  08d0              LSRS     r0,r2,#3              ;2454
                  |L11.278|
000116  eb0100c0          ADD      r0,r1,r0,LSL #3       ;2468
00011a  eb0500c0          ADD      r0,r5,r0,LSL #3       ;2468
00011e  6ac4              LDR      r4,[r0,#0x2c]         ;2468
000120  68e0              LDR      r0,[r4,#0xc]          ;2468
000122  1b00              SUBS     r0,r0,r4              ;2468
000124  f1a00910          SUB      r9,r0,#0x10           ;2468
000128  4648              MOV      r0,r9                 ;2468
00012a  f7fffffe          BL       RMP_MSB_Get
00012e  1ec1              SUBS     r1,r0,#3              ;2468
000130  6822              LDR      r2,[r4,#0]            ;2468
000132  fa29f101          LSR      r1,r9,r1              ;2468
000136  1f80              SUBS     r0,r0,#6              ;2468
000138  f0010107          AND      r1,r1,#7              ;2468
00013c  eb0100c0          ADD      r0,r1,r0,LSL #3       ;2468
000140  eb0501c0          ADD      r1,r5,r0,LSL #3       ;2468
000144  6863              LDR      r3,[r4,#4]            ;2468
000146  601a              STR      r2,[r3,#0]            ;2468
000148  6053              STR      r3,[r2,#4]            ;2468
00014a  6aca              LDR      r2,[r1,#0x2c]         ;2468
00014c  3128              ADDS     r1,r1,#0x28           ;2468
00014e  428a              CMP      r2,r1                 ;2468
000150  d10a              BNE      |L11.360|
000152  0942              LSRS     r2,r0,#5              ;2468
000154  f000011f          AND      r1,r0,#0x1f           ;2468
000158  eb050082          ADD      r0,r5,r2,LSL #2       ;2468
00015c  6942              LDR      r2,[r0,#0x14]         ;2468
00015e  fa07f101          LSL      r1,r7,r1              ;2468
000162  ea220101          BIC      r1,r2,r1              ;2468
000166  6141              STR      r1,[r0,#0x14]         ;2468
                  |L11.360|
000168  68e0              LDR      r0,[r4,#0xc]          ;2473
00016a  1b00              SUBS     r0,r0,r4              ;2473
00016c  1b80              SUBS     r0,r0,r6              ;2473
00016e  3810              SUBS     r0,r0,#0x10           ;2473
000170  2854              CMP      r0,#0x54              ;2474
000172  d337              BCC      |L11.484|
000174  f1060114          ADD      r1,r6,#0x14           ;2477
000178  f8c48008          STR      r8,[r4,#8]            ;2477
00017c  1866              ADDS     r6,r4,r1              ;2478
00017e  1f31              SUBS     r1,r6,#4              ;2478
000180  60e1              STR      r1,[r4,#0xc]          ;2478
000182  68e1              LDR      r1,[r4,#0xc]          ;2478
000184  600c              STR      r4,[r1,#0]            ;2478
000186  4430              ADD      r0,r0,r6              ;2478
000188  f8c68008          STR      r8,[r6,#8]            ;2478
00018c  1f00              SUBS     r0,r0,#4              ;2478
00018e  60f0              STR      r0,[r6,#0xc]          ;2478
000190  68f0              LDR      r0,[r6,#0xc]          ;2478
000192  6006              STR      r6,[r0,#0]            ;2478
000194  46a8              MOV      r8,r5                 ;2484
000196  68f0              LDR      r0,[r6,#0xc]          ;2484
000198  1b80              SUBS     r0,r0,r6              ;2484
00019a  f1a00910          SUB      r9,r0,#0x10           ;2484
00019e  4648              MOV      r0,r9                 ;2484
0001a0  f7fffffe          BL       RMP_MSB_Get
0001a4  1ec1              SUBS     r1,r0,#3              ;2484
0001a6  fa29f101          LSR      r1,r9,r1              ;2484
0001aa  1f80              SUBS     r0,r0,#6              ;2484
0001ac  f0010107          AND      r1,r1,#7              ;2484
0001b0  eb0101c0          ADD      r1,r1,r0,LSL #3       ;2484
0001b4  eb0800c1          ADD      r0,r8,r1,LSL #3       ;2484
0001b8  6ac2              LDR      r2,[r0,#0x2c]         ;2484
0001ba  3028              ADDS     r0,r0,#0x28           ;2484
0001bc  4282              CMP      r2,r0                 ;2484
0001be  e001              B        |L11.452|
                  |L11.448|
0001c0  e01e              B        |L11.512|
                  |L11.450|
0001c2  e019              B        |L11.504|
                  |L11.452|
0001c4  d109              BNE      |L11.474|
0001c6  094b              LSRS     r3,r1,#5              ;2484
0001c8  f001021f          AND      r2,r1,#0x1f           ;2484
0001cc  eb080183          ADD      r1,r8,r3,LSL #2       ;2484
0001d0  694b              LDR      r3,[r1,#0x14]         ;2484
0001d2  fa07f202          LSL      r2,r7,r2              ;2484
0001d6  431a              ORRS     r2,r2,r3              ;2484
0001d8  614a              STR      r2,[r1,#0x14]         ;2484
                  |L11.474|
0001da  6841              LDR      r1,[r0,#4]            ;2484
0001dc  600e              STR      r6,[r1,#0]            ;2484
0001de  6071              STR      r1,[r6,#4]            ;2484
0001e0  6030              STR      r0,[r6,#0]            ;2484
0001e2  6046              STR      r6,[r0,#4]            ;2484
                  |L11.484|
0001e4  6868              LDR      r0,[r5,#4]            ;2490
0001e6  6004              STR      r4,[r0,#0]            ;2490
0001e8  6060              STR      r0,[r4,#4]            ;2490
0001ea  6025              STR      r5,[r4,#0]            ;2490
0001ec  606c              STR      r4,[r5,#4]            ;2490
0001ee  60a7              STR      r7,[r4,#8]            ;2491
0001f0  f1040010          ADD      r0,r4,#0x10           ;2494
0001f4  e8bd9ff0          POP      {r4-r12,pc}
                  |L11.504|
0001f8  1c64              ADDS     r4,r4,#1
0001fa  2c05              CMP      r4,#5
0001fc  f6ffaf62          BLT      |L11.196|
                  |L11.512|
000200  2000              MOVS     r0,#0                 ;2460
000202  e8bd9ff0          POP      {r4-r12,pc}
;;;2496   /* End Function:RMP_Malloc ***************************************************/
                          ENDP

000206  0000              DCW      0x0000
                  |L11.520|
                          DCD      ||.constdata||

                          AREA ||i.RMP_Mem_Init||, CODE, READONLY, ALIGN=2

                  RMP_Mem_Init PROC
;;;2160   ******************************************************************************/
;;;2161   rmp_ret_t RMP_Mem_Init(volatile void* Pool, rmp_ptr_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;2162   {
000002  0004              MOVS     r4,r0
000004  460d              MOV      r5,r1
000006  d00a              BEQ      |L12.30|
;;;2163       rmp_cnt_t FLI_Cnt;
;;;2164       rmp_ptr_t Usable_Size;
;;;2165       volatile struct RMP_Mem* Mem;
;;;2166       volatile struct RMP_Mem_Head* Mem_Head;
;;;2167       
;;;2168       /* See if the memory pool is large enough to enable dynamic allocation - at
;;;2169        * least 4096 words and no more than 128MB */
;;;2170       if((Pool==0)||(Size<(4096*sizeof(rmp_ptr_t)))||(((Size>>15)>>12)>0))
000008  f5b54f80          CMP      r5,#0x4000
00000c  bf28              IT       CS
00000e  ea5f60d5          LSRSCS   r0,r5,#27
;;;2171       {
;;;2172           RMP_COVERAGE_MARKER();
;;;2173           return RMP_ERR_MEM;
;;;2174       }
;;;2175       else
;;;2176           RMP_COVERAGE_MARKER();
;;;2177       
;;;2178       /* See if the address and size is word-aligned */
;;;2179       if((((rmp_ptr_t)Pool&(RMP_WORD_MASK>>3))!=0)||((Size&(RMP_WORD_MASK>>3))!=0))
000012  bf04              ITT      EQ
000014  ea440005          ORREQ    r0,r4,r5
000018  f0100f03          TSTEQ    r0,#3
00001c  d002              BEQ      |L12.36|
                  |L12.30|
;;;2180       {
;;;2181           RMP_COVERAGE_MARKER();
;;;2182           return RMP_ERR_MEM;
00001e  f06f0006          MVN      r0,#6
;;;2183       }
;;;2184       else
;;;2185           RMP_COVERAGE_MARKER();
;;;2186           
;;;2187       Mem=(volatile struct RMP_Mem*)Pool;
;;;2188       Mem->Size=Size;
;;;2189       /* Initialize the allocated block list */
;;;2190       RMP_List_Crt(&(Mem->Alloc));
;;;2191       /* Calculate the FLI value needed for this - we always align to 64 byte */
;;;2192       Mem->FLI_Num=RMP_MSB_Get(Size-sizeof(struct RMP_Mem))-6+1;
;;;2193       /* Initialize the TLSF allocation table first */
;;;2194       for(FLI_Cnt=0;FLI_Cnt<(rmp_cnt_t)(Mem->FLI_Num);FLI_Cnt++)
;;;2195       {
;;;2196           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,0)]));
;;;2197           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,1)]));
;;;2198           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,2)]));
;;;2199           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,3)]));
;;;2200           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,4)]));
;;;2201           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,5)]));
;;;2202           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,6)]));
;;;2203           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,7)]));
;;;2204       }
;;;2205       for(FLI_Cnt=0;FLI_Cnt<5;FLI_Cnt++)
;;;2206           Mem->Bitmap[FLI_Cnt]=0;
;;;2207       
;;;2208       /* Get the big memory block's size and position */
;;;2209       Usable_Size=sizeof(struct RMP_Mem)+(sizeof(struct RMP_List)<<3)*(Mem->FLI_Num-8);
;;;2210       Mem_Head=(struct RMP_Mem_Head*)(((rmp_ptr_t)Pool)+Usable_Size);
;;;2211       Mem->Start=(rmp_ptr_t)Mem_Head;
;;;2212       Usable_Size=Size-Usable_Size;
;;;2213       
;;;2214       /* Initialize the big block */
;;;2215       _RMP_Mem_Block(Mem_Head,Usable_Size);
;;;2216       
;;;2217       /* Insert the memory into the corresponding level */
;;;2218       _RMP_Mem_Ins(Pool, Mem_Head);
;;;2219       return 0;
;;;2220   }
000022  bd70              POP      {r4-r6,pc}
                  |L12.36|
000024  6125              STR      r5,[r4,#0x10]         ;2188
000026  6024              STR      r4,[r4,#0]            ;2188
000028  6064              STR      r4,[r4,#4]            ;2188
00002a  f5a5700a          SUB      r0,r5,#0x228          ;2192
00002e  f7fffffe          BL       RMP_MSB_Get
000032  2300              MOVS     r3,#0                 ;2194
000034  1f40              SUBS     r0,r0,#5              ;2194
000036  60a0              STR      r0,[r4,#8]            ;2192
000038  68a0              LDR      r0,[r4,#8]            ;2194
00003a  4298              CMP      r0,r3                 ;2194
00003c  dd28              BLE      |L12.144|
00003e  bf00              NOP                            ;2196
                  |L12.64|
000040  eb041283          ADD      r2,r4,r3,LSL #6       ;2196
000044  f1020028          ADD      r0,r2,#0x28           ;2196
000048  6290              STR      r0,[r2,#0x28]         ;2196
00004a  62d0              STR      r0,[r2,#0x2c]         ;2196
00004c  3008              ADDS     r0,r0,#8              ;2197
00004e  6310              STR      r0,[r2,#0x30]         ;2197
000050  6350              STR      r0,[r2,#0x34]         ;2197
000052  3008              ADDS     r0,r0,#8              ;2198
000054  6390              STR      r0,[r2,#0x38]         ;2198
000056  63d0              STR      r0,[r2,#0x3c]         ;2198
000058  3008              ADDS     r0,r0,#8              ;2199
00005a  6410              STR      r0,[r2,#0x40]         ;2199
00005c  6450              STR      r0,[r2,#0x44]         ;2199
00005e  f1020c48          ADD      r12,r2,#0x48          ;2200
000062  f8c2c048          STR      r12,[r2,#0x48]        ;2200
000066  f8c2c04c          STR      r12,[r2,#0x4c]        ;2200
00006a  f1020c50          ADD      r12,r2,#0x50          ;2201
00006e  f8c2c050          STR      r12,[r2,#0x50]        ;2201
000072  f8c2c054          STR      r12,[r2,#0x54]        ;2201
000076  f1020c58          ADD      r12,r2,#0x58          ;2202
00007a  f8c2c058          STR      r12,[r2,#0x58]        ;2202
00007e  f8c2c05c          STR      r12,[r2,#0x5c]        ;2202
000082  3020              ADDS     r0,r0,#0x20           ;2203
000084  6610              STR      r0,[r2,#0x60]         ;2203
000086  6650              STR      r0,[r2,#0x64]         ;2203
000088  68a0              LDR      r0,[r4,#8]            ;2203
00008a  1c5b              ADDS     r3,r3,#1              ;2203
00008c  4298              CMP      r0,r3                 ;2203
00008e  dcd7              BGT      |L12.64|
                  |L12.144|
000090  2000              MOVS     r0,#0                 ;2206
000092  6160              STR      r0,[r4,#0x14]         ;2206
000094  2228              MOVS     r2,#0x28              ;2209
000096  61a0              STR      r0,[r4,#0x18]         ;2206
000098  61e0              STR      r0,[r4,#0x1c]         ;2206
00009a  6220              STR      r0,[r4,#0x20]         ;2206
00009c  6260              STR      r0,[r4,#0x24]         ;2206
00009e  68a1              LDR      r1,[r4,#8]            ;2209
0000a0  eb021181          ADD      r1,r2,r1,LSL #6       ;2209
0000a4  1866              ADDS     r6,r4,r1              ;2210
0000a6  60e6              STR      r6,[r4,#0xc]          ;2211
0000a8  1a69              SUBS     r1,r5,r1              ;2212
0000aa  4431              ADD      r1,r1,r6              ;2212
0000ac  60b0              STR      r0,[r6,#8]            ;2212
0000ae  1f09              SUBS     r1,r1,#4              ;2212
0000b0  60f1              STR      r1,[r6,#0xc]          ;2212
0000b2  68f0              LDR      r0,[r6,#0xc]          ;2212
0000b4  6006              STR      r6,[r0,#0]            ;2212
0000b6  68f0              LDR      r0,[r6,#0xc]          ;2212
0000b8  1b80              SUBS     r0,r0,r6              ;2212
0000ba  f1a00510          SUB      r5,r0,#0x10           ;2212
0000be  4628              MOV      r0,r5                 ;2212
0000c0  f7fffffe          BL       RMP_MSB_Get
0000c4  1ec1              SUBS     r1,r0,#3              ;2212
0000c6  fa25f101          LSR      r1,r5,r1              ;2212
0000ca  1f80              SUBS     r0,r0,#6              ;2212
0000cc  f0010107          AND      r1,r1,#7              ;2212
0000d0  eb0101c0          ADD      r1,r1,r0,LSL #3       ;2212
0000d4  eb0400c1          ADD      r0,r4,r1,LSL #3       ;2212
0000d8  6ac2              LDR      r2,[r0,#0x2c]         ;2212
0000da  3028              ADDS     r0,r0,#0x28           ;2212
0000dc  4282              CMP      r2,r0                 ;2212
0000de  d10b              BNE      |L12.248|
0000e0  094b              LSRS     r3,r1,#5              ;2212
0000e2  f04f0c01          MOV      r12,#1                ;2212
0000e6  f001021f          AND      r2,r1,#0x1f           ;2212
0000ea  eb040183          ADD      r1,r4,r3,LSL #2       ;2212
0000ee  694b              LDR      r3,[r1,#0x14]         ;2212
0000f0  fa0cf202          LSL      r2,r12,r2             ;2212
0000f4  431a              ORRS     r2,r2,r3              ;2212
0000f6  614a              STR      r2,[r1,#0x14]         ;2212
                  |L12.248|
0000f8  6841              LDR      r1,[r0,#4]            ;2212
0000fa  600e              STR      r6,[r1,#0]            ;2212
0000fc  6071              STR      r1,[r6,#4]            ;2212
0000fe  6030              STR      r0,[r6,#0]            ;2212
000100  6046              STR      r6,[r0,#4]            ;2212
000102  2000              MOVS     r0,#0                 ;2219
000104  bd70              POP      {r4-r6,pc}
;;;2221   /* End Function:RMP_Mem_Init *************************************************/
                          ENDP


                          AREA ||i.RMP_Print_Int||, CODE, READONLY, ALIGN=2

                  RMP_Print_Int PROC
;;;85     ******************************************************************************/
;;;86     rmp_cnt_t RMP_Print_Int(rmp_cnt_t Int)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;87     {
;;;88         rmp_ptr_t Iter;
;;;89         rmp_cnt_t Count;
;;;90         rmp_cnt_t Num;
;;;91         rmp_ptr_t Div;
;;;92         
;;;93         /* how many digits are there? */
;;;94         if(Int==0)
;;;95         {
;;;96             RMP_Putchar('0');
;;;97             return 1;
;;;98         }
;;;99         else if(Int<0)
;;;100        {
;;;101            /* How many digits are there? */
;;;102            Count=0;
;;;103            Div=1;
;;;104            Iter=(rmp_ptr_t)(-Int);
;;;105            while(Iter!=0)
;;;106            {
;;;107                Iter/=10;
000004  4c2f              LDR      r4,|L13.196|
000006  2800              CMP      r0,#0                 ;94
000008  d02e              BEQ      |L13.104|
00000a  da33              BGE      |L13.116|
00000c  4245              RSBS     r5,r0,#0              ;104
00000e  f04f0600          MOV      r6,#0                 ;102
000012  462f              MOV      r7,r5                 ;104
000014  f04f0001          MOV      r0,#1                 ;103
000018  d008              BEQ      |L13.44|
;;;108                Count++;
;;;109                Div*=10;
00001a  bf00              NOP      
                  |L13.28|
00001c  fba42105          UMULL    r2,r1,r4,r5           ;107
000020  eb000080          ADD      r0,r0,r0,LSL #2
000024  1c76              ADDS     r6,r6,#1
000026  0040              LSLS     r0,r0,#1
000028  08cd              LSRS     r5,r1,#3              ;107
00002a  d1f7              BNE      |L13.28|
                  |L13.44|
;;;110            }
;;;111            Div/=10;
00002c  fba41000          UMULL    r1,r0,r4,r0
000030  ea4f08d0          LSR      r8,r0,#3
;;;112            
;;;113            RMP_Putchar('-');
000034  202d              MOVS     r0,#0x2d
000036  f7fffffe          BL       RMP_Putchar
;;;114            Iter=-Int;
;;;115            Num=Count+1;
;;;116            
;;;117            while(Count>0)
00003a  2e00              CMP      r6,#0
00003c  f1060901          ADD      r9,r6,#1              ;115
000040  dd3d              BLE      |L13.190|
;;;118            {
;;;119                Count--;
;;;120                RMP_Putchar(Iter/Div+'0');
000042  bf00              NOP      
                  |L13.68|
000044  fbb7f0f8          UDIV     r0,r7,r8
000048  1e76              SUBS     r6,r6,#1
00004a  3030              ADDS     r0,r0,#0x30
00004c  b240              SXTB     r0,r0
00004e  f7fffffe          BL       RMP_Putchar
;;;121                Iter=Iter%Div;
000052  fbb7f1f8          UDIV     r1,r7,r8
;;;122                Div/=10;
000056  fba42008          UMULL    r2,r0,r4,r8
00005a  2e00              CMP      r6,#0                 ;117
00005c  fb087711          MLS      r7,r8,r1,r7           ;121
000060  ea4f08d0          LSR      r8,r0,#3
000064  dcee              BGT      |L13.68|
000066  e02a              B        |L13.190|
                  |L13.104|
000068  2030              MOVS     r0,#0x30              ;96
00006a  f7fffffe          BL       RMP_Putchar
00006e  2001              MOVS     r0,#1                 ;97
;;;123            }
;;;124        }
;;;125        else
;;;126        {
;;;127            /* How many digits are there? */
;;;128            Count=0;
;;;129            Div=1;
;;;130            Iter=Int;
;;;131            while(Iter!=0)
;;;132            {
;;;133                Iter/=10;
;;;134                Count++;
;;;135                Div*=10;
;;;136            }
;;;137            Div/=10;
;;;138            
;;;139            Iter=Int;
;;;140            Num=Count;
;;;141            
;;;142            while(Count>0)
;;;143            {
;;;144                Count--;
;;;145                RMP_Putchar(Iter/Div+'0');
;;;146                Iter=Iter%Div;
;;;147                Div/=10;
;;;148            }
;;;149        }
;;;150        
;;;151        return Num;
;;;152    }
000070  e8bd87f0          POP      {r4-r10,pc}
                  |L13.116|
000074  2500              MOVS     r5,#0                 ;128
000076  ea4f0100          MOV.W    r1,r0                 ;130
00007a  2201              MOVS     r2,#1                 ;129
                  |L13.124|
00007c  fba43101          UMULL    r3,r1,r4,r1           ;133
000080  eb020282          ADD      r2,r2,r2,LSL #2       ;135
000084  1c6d              ADDS     r5,r5,#1              ;135
000086  0052              LSLS     r2,r2,#1              ;135
000088  08c9              LSRS     r1,r1,#3              ;133
00008a  d1f7              BNE      |L13.124|
00008c  4606              MOV      r6,r0                 ;139
00008e  46a9              MOV      r9,r5                 ;140
000090  fba41002          UMULL    r1,r0,r4,r2           ;137
000094  2d00              CMP      r5,#0                 ;142
000096  ea4f07d0          LSR      r7,r0,#3              ;137
00009a  dd10              BLE      |L13.190|
                  |L13.156|
00009c  fbb6f0f7          UDIV     r0,r6,r7              ;145
0000a0  1e6d              SUBS     r5,r5,#1              ;145
0000a2  3030              ADDS     r0,r0,#0x30           ;145
0000a4  b240              SXTB     r0,r0                 ;145
0000a6  f7fffffe          BL       RMP_Putchar
0000aa  fbb6f1f7          UDIV     r1,r6,r7              ;146
0000ae  fba42007          UMULL    r2,r0,r4,r7           ;147
0000b2  2d00              CMP      r5,#0                 ;142
0000b4  fb076611          MLS      r6,r7,r1,r6           ;146
0000b8  ea4f07d0          LSR      r7,r0,#3              ;147
0000bc  dcee              BGT      |L13.156|
                  |L13.190|
0000be  4648              MOV      r0,r9                 ;151
0000c0  e8bd87f0          POP      {r4-r10,pc}
;;;153    /* End Function:RMP_Print_Int ************************************************/
                          ENDP

                  |L13.196|
                          DCD      0xcccccccd

                          AREA ||i.RMP_Print_String||, CODE, READONLY, ALIGN=1

                  RMP_Print_String PROC
;;;208    ******************************************************************************/
;;;209    rmp_cnt_t RMP_Print_String(rmp_s8_t* String)
000000  b570              PUSH     {r4-r6,lr}
;;;210    {
;;;211        rmp_cnt_t Count;
;;;212        
;;;213        Count=0;
000002  2400              MOVS     r4,#0
000004  4605              MOV      r5,r0                 ;210
                  |L14.6|
;;;214        while(Count<RMP_KERNEL_DEBUG_MAX_STR)
;;;215        {
;;;216            if(String[Count]=='\0')
000006  5728              LDRSB    r0,[r5,r4]
000008  b120              CBZ      r0,|L14.20|
00000a  1c64              ADDS     r4,r4,#1
;;;217                break;
;;;218            
;;;219            RMP_Putchar(String[Count++]);
00000c  f7fffffe          BL       RMP_Putchar
000010  2cff              CMP      r4,#0xff              ;214
000012  dbf8              BLT      |L14.6|
                  |L14.20|
;;;220        }
;;;221        
;;;222        return Count;
000014  4620              MOV      r0,r4
;;;223    }
000016  bd70              POP      {r4-r6,pc}
;;;224    /* End Function:RMP_Print_String *********************************************/
                          ENDP


                          AREA ||i.RMP_Print_Uint||, CODE, READONLY, ALIGN=1

                  RMP_Print_Uint PROC
;;;161    ******************************************************************************/
;;;162    rmp_cnt_t RMP_Print_Uint(rmp_ptr_t Uint)
000000  b570              PUSH     {r4-r6,lr}
;;;163    {
000002  0005              MOVS     r5,r0
000004  d004              BEQ      |L15.16|
;;;164        rmp_ptr_t Iter;
;;;165        rmp_cnt_t Count;
;;;166        rmp_cnt_t Num;
;;;167        
;;;168        /* how many digits are there? */
;;;169        if(Uint==0)
;;;170        {
;;;171            RMP_Putchar('0');
;;;172            return 1;
;;;173        }
;;;174        else
;;;175        {
;;;176            /* Filter out all the zeroes */
;;;177            Count=0;
;;;178            Iter=Uint;
;;;179            while((Iter>>((sizeof(rmp_ptr_t)*8)-4))==0)
000006  0f02              LSRS     r2,r0,#28
000008  f04f0100          MOV      r1,#0                 ;177
00000c  d005              BEQ      |L15.26|
00000e  e008              B        |L15.34|
                  |L15.16|
000010  2030              MOVS     r0,#0x30              ;171
000012  f7fffffe          BL       RMP_Putchar
000016  2001              MOVS     r0,#1                 ;172
;;;180            {
;;;181                Iter<<=4;
;;;182                Count++;
;;;183            }
;;;184            /* Count is the number of pts to print */
;;;185            Count=sizeof(rmp_ptr_t)*2-Count;
;;;186            Num=Count;
;;;187            while(Count>0)
;;;188            {
;;;189                Count--;
;;;190                Iter=(Uint>>(Count*4))&0x0F;
;;;191                if(Iter<10)
;;;192                    RMP_Putchar('0'+Iter);
;;;193                else
;;;194                    RMP_Putchar('A'+Iter-10);
;;;195            }
;;;196        }
;;;197        
;;;198        return Num;
;;;199    }
000018  bd70              POP      {r4-r6,pc}
                  |L15.26|
00001a  0100              LSLS     r0,r0,#4              ;181
00001c  1c49              ADDS     r1,r1,#1              ;181
00001e  0f02              LSRS     r2,r0,#28             ;179
000020  d0fb              BEQ      |L15.26|
                  |L15.34|
000022  f1c10408          RSB      r4,r1,#8              ;185
000026  2c00              CMP      r4,#0                 ;187
000028  4626              MOV      r6,r4                 ;186
00002a  dd0f              BLE      |L15.76|
                  |L15.44|
00002c  4620              MOV      r0,r4                 ;189
00002e  1e64              SUBS     r4,r4,#1              ;189
000030  0080              LSLS     r0,r0,#2
000032  1f00              SUBS     r0,r0,#4
000034  fa25f000          LSR      r0,r5,r0              ;190
000038  f000000f          AND      r0,r0,#0xf            ;190
00003c  280a              CMP      r0,#0xa               ;191
00003e  bf34              ITE      CC                    ;191
000040  3030              ADDCC    r0,r0,#0x30           ;191
000042  3037              ADDCS    r0,r0,#0x37           ;191
000044  f7fffffe          BL       RMP_Putchar
000048  2c00              CMP      r4,#0                 ;187
00004a  dcef              BGT      |L15.44|
                  |L15.76|
00004c  4630              MOV      r0,r6                 ;198
00004e  bd70              POP      {r4-r6,pc}
;;;200    /* End Function:RMP_Print_Uint ***********************************************/
                          ENDP


                          AREA ||i.RMP_RBIT_Get||, CODE, READONLY, ALIGN=2

                  RMP_RBIT_Get PROC
;;;2078   
;;;2079   rmp_ptr_t RMP_RBIT_Get(rmp_ptr_t Val)
000000  4a0c              LDR      r2,|L16.52|
;;;2080   {
;;;2081       rmp_ptr_t Ret;
;;;2082       rmp_ptr_t Src;
;;;2083       rmp_u8_t* To;
;;;2084       rmp_u8_t* From;
;;;2085       
;;;2086       Src=Val;
;;;2087       To=(rmp_u8_t*)(&Ret);
;;;2088       From=(rmp_u8_t*)(&Src);
;;;2089       
;;;2090   #if(RMP_WORD_ORDER==4)
;;;2091       To[0]=RMP_RBIT_Table[From[1]];
;;;2092       To[1]=RMP_RBIT_Table[From[0]];
;;;2093   #elif(RMP_WORD_ORDER==5)
;;;2094       To[0]=RMP_RBIT_Table[From[3]];
000002  f3c04c07          UBFX     r12,r0,#16,#8
000006  f84d4d04          PUSH.W   {r4}                  ;2080
00000a  0e04              LSRS     r4,r0,#24             ;2080
00000c  f3c02307          UBFX     r3,r0,#8,#8
;;;2095       To[1]=RMP_RBIT_Table[From[2]];
000010  f812c00c          LDRB     r12,[r2,r12]
000014  b2c1              UXTB     r1,r0                 ;2094
000016  5d14              LDRB     r4,[r2,r4]            ;2094
;;;2096       To[2]=RMP_RBIT_Table[From[1]];
000018  5cd3              LDRB     r3,[r2,r3]
;;;2097       To[3]=RMP_RBIT_Table[From[0]];
00001a  5c51              LDRB     r1,[r2,r1]
00001c  f3640007          BFI      r0,r4,#0,#8
;;;2098   #else
;;;2099       To[0]=RMP_RBIT_Table[From[7]];
;;;2100       To[1]=RMP_RBIT_Table[From[6]];
;;;2101       To[2]=RMP_RBIT_Table[From[5]];
;;;2102       To[3]=RMP_RBIT_Table[From[4]];
;;;2103       To[4]=RMP_RBIT_Table[From[3]];
;;;2104       To[5]=RMP_RBIT_Table[From[2]];
;;;2105       To[6]=RMP_RBIT_Table[From[1]];
;;;2106       To[7]=RMP_RBIT_Table[From[0]];
;;;2107   #endif
;;;2108   
;;;2109       return Ret;
;;;2110   }
000020  f85d4b04          POP.W    {r4}
000024  f36c200f          BFI      r0,r12,#8,#8          ;2097
000028  f3634017          BFI      r0,r3,#16,#8          ;2097
00002c  f361601f          BFI      r0,r1,#24,#8          ;2097
000030  4770              BX       lr
;;;2111   /* End Function:RMP_RBIT_Get *************************************************/
                          ENDP

000032  0000              DCW      0x0000
                  |L16.52|
                          DCD      ||.constdata||

                          AREA ||i.RMP_Save_Ctx||, CODE, READONLY, ALIGN=1

                  RMP_Save_Ctx PROC
;;;1942   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1943   void RMP_Save_Ctx(void)
000000  4770              BX       lr
;;;1944   {
;;;1945       return;
;;;1946   }
;;;1947   #endif
                          ENDP


                          AREA ||i.RMP_Sem_Abort||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Abort PROC
;;;1737   ******************************************************************************/
;;;1738   rmp_ret_t RMP_Sem_Abort(volatile struct RMP_Thd* Thread)
000000  2800              CMP      r0,#0
;;;1739   {
;;;1740       /* Check if this thread structure could possibly be in use */
;;;1741       if(Thread==0)
;;;1742       {
;;;1743           RMP_COVERAGE_MARKER();
;;;1744           return RMP_ERR_THD;
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;1745       }
;;;1746       else
;;;1747           RMP_COVERAGE_MARKER();
;;;1748   
;;;1749       RMP_Lock_Sched();
;;;1750       
;;;1751       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;1752       {
;;;1753           RMP_COVERAGE_MARKER();
;;;1754           RMP_Unlock_Sched();
;;;1755           return RMP_ERR_THD;
;;;1756       }
;;;1757       else
;;;1758           RMP_COVERAGE_MARKER();
;;;1759       
;;;1760       /* Is it waiting on a semaphore? If no, we abort and return an error code */
;;;1761       if((RMP_THD_STATE(Thread->State)!=RMP_THD_SEMBLK)&&
;;;1762          (RMP_THD_STATE(Thread->State)!=RMP_THD_SEMDLY))
;;;1763       {
;;;1764           RMP_COVERAGE_MARKER();
;;;1765           RMP_Unlock_Sched();
;;;1766           return RMP_ERR_STATE;
;;;1767       }
;;;1768       else
;;;1769           RMP_COVERAGE_MARKER();
;;;1770   
;;;1771       /* Waiting for a semaphore. We abort it and return */
;;;1772       RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1773       if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1774       {
;;;1775           RMP_COVERAGE_MARKER();
;;;1776           RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1777       }
;;;1778       else
;;;1779           RMP_COVERAGE_MARKER();
;;;1780       
;;;1781       RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1782       /* Set to running if not suspended */
;;;1783       _RMP_Set_Rdy(Thread);
;;;1784       
;;;1785       Thread->Retval=RMP_ERR_OPER;
;;;1786       RMP_Unlock_Sched();
;;;1787       return 0;
;;;1788   }
000008  4770              BXEQ     lr
00000a  b510              PUSH     {r4,lr}               ;1739
00000c  4604              MOV      r4,r0                 ;1739
00000e  20ff              MOVS     r0,#0xff              ;1739
000010  f7fffffe          BL       RMP_Mask_Int
000014  481b              LDR      r0,|L18.132|
000016  2101              MOVS     r1,#1                 ;1739
000018  6041              STR      r1,[r0,#4]            ;1739  ; RMP_Sched_Locked
00001a  6801              LDR      r1,[r0,#0]            ;1739  ; RMP_Sched_Lock_Cnt
00001c  1c49              ADDS     r1,r1,#1              ;1739
00001e  6001              STR      r1,[r0,#0]            ;1739  ; RMP_Sched_Lock_Cnt
000020  69a0              LDR      r0,[r4,#0x18]         ;1751
000022  f0100fff          TST      r0,#0xff              ;1751
000026  d00c              BEQ      |L18.66|
000028  69a0              LDR      r0,[r4,#0x18]         ;1761
00002a  b2c0              UXTB     r0,r0                 ;1761
00002c  2807              CMP      r0,#7                 ;1761
00002e  d00d              BEQ      |L18.76|
000030  69a0              LDR      r0,[r4,#0x18]         ;1761
000032  b2c0              UXTB     r0,r0                 ;1761
000034  2808              CMP      r0,#8                 ;1761
000036  d009              BEQ      |L18.76|
000038  f7fffffe          BL       RMP_Unlock_Sched
00003c  f06f0003          MVN      r0,#3                 ;1766
000040  bd10              POP      {r4,pc}
                  |L18.66|
000042  f7fffffe          BL       RMP_Unlock_Sched
000046  f04f30ff          MOV      r0,#0xffffffff        ;1755
00004a  bd10              POP      {r4,pc}
                  |L18.76|
00004c  6820              LDR      r0,[r4,#0]            ;1772
00004e  6861              LDR      r1,[r4,#4]            ;1772
000050  6008              STR      r0,[r1,#0]            ;1772
000052  6041              STR      r1,[r0,#4]            ;1772
000054  69a0              LDR      r0,[r4,#0x18]         ;1773
000056  b2c0              UXTB     r0,r0                 ;1773
000058  2808              CMP      r0,#8                 ;1773
00005a  d103              BNE      |L18.100|
00005c  68a1              LDR      r1,[r4,#8]            ;1776
00005e  68e0              LDR      r0,[r4,#0xc]          ;1776
000060  6001              STR      r1,[r0,#0]            ;1776
000062  6048              STR      r0,[r1,#4]            ;1776
                  |L18.100|
000064  69a0              LDR      r0,[r4,#0x18]         ;1781
000066  f02000ff          BIC      r0,r0,#0xff           ;1781
00006a  f0400001          ORR      r0,r0,#1              ;1781
00006e  61a0              STR      r0,[r4,#0x18]         ;1781
000070  4620              MOV      r0,r4                 ;1783
000072  f7fffffe          BL       _RMP_Set_Rdy
000076  f06f0004          MVN      r0,#4                 ;1785
00007a  63a0              STR      r0,[r4,#0x38]         ;1785
00007c  f7fffffe          BL       RMP_Unlock_Sched
000080  2000              MOVS     r0,#0                 ;1787
000082  bd10              POP      {r4,pc}
;;;1789   /* End Function:RMP_Sem_Abort ************************************************/
                          ENDP

                  |L18.132|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Crt||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Crt PROC
;;;1556   ******************************************************************************/
;;;1557   rmp_ret_t RMP_Sem_Crt(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number)
000000  2800              CMP      r0,#0
;;;1558   {
;;;1559       /* Check if this semaphore structure could possibly be in use */
;;;1560       if(Semaphore==0)
;;;1561       {
;;;1562           RMP_COVERAGE_MARKER();
;;;1563           return RMP_ERR_SEM;
000002  bf04              ITT      EQ
000004  f06f0005          MVNEQ    r0,#5
;;;1564       }
;;;1565       else
;;;1566           RMP_COVERAGE_MARKER();
;;;1567       
;;;1568       RMP_Lock_Sched();
;;;1569       
;;;1570       if(Semaphore->State!=RMP_SEM_FREE)
;;;1571       {
;;;1572           RMP_COVERAGE_MARKER();
;;;1573           RMP_Unlock_Sched();
;;;1574           return RMP_ERR_SEM;
;;;1575       }
;;;1576       else
;;;1577           RMP_COVERAGE_MARKER();
;;;1578       
;;;1579       /* Is the number too great to initialize? */
;;;1580       if(Number>=RMP_SEM_MAX_NUM)
;;;1581       {
;;;1582           RMP_COVERAGE_MARKER();
;;;1583           RMP_Unlock_Sched();
;;;1584           return RMP_ERR_OPER;
;;;1585       }
;;;1586       else
;;;1587           RMP_COVERAGE_MARKER();
;;;1588   
;;;1589       /* Initialize contents */
;;;1590       Semaphore->Cur_Num=Number;
;;;1591       Semaphore->State=RMP_SEM_USED;
;;;1592       RMP_List_Crt(&(Semaphore->Wait_List));
;;;1593       
;;;1594       RMP_Unlock_Sched();
;;;1595       
;;;1596       return 0;
;;;1597   }
000008  4770              BXEQ     lr
00000a  b570              PUSH     {r4-r6,lr}            ;1558
00000c  460d              MOV      r5,r1                 ;1558
00000e  4604              MOV      r4,r0                 ;1558
000010  20ff              MOVS     r0,#0xff              ;1558
000012  f7fffffe          BL       RMP_Mask_Int
000016  480e              LDR      r0,|L19.80|
000018  2101              MOVS     r1,#1                 ;1558
00001a  6041              STR      r1,[r0,#4]            ;1558  ; RMP_Sched_Locked
00001c  6802              LDR      r2,[r0,#0]            ;1558  ; RMP_Sched_Lock_Cnt
00001e  1c52              ADDS     r2,r2,#1              ;1558
000020  6002              STR      r2,[r0,#0]            ;1558  ; RMP_Sched_Lock_Cnt
000022  68a0              LDR      r0,[r4,#8]            ;1570
000024  b120              CBZ      r0,|L19.48|
000026  f7fffffe          BL       RMP_Unlock_Sched
00002a  f06f0005          MVN      r0,#5                 ;1574
00002e  bd70              POP      {r4-r6,pc}
                  |L19.48|
000030  f5b57f7a          CMP      r5,#0x3e8             ;1580
000034  d304              BCC      |L19.64|
000036  f7fffffe          BL       RMP_Unlock_Sched
00003a  f06f0004          MVN      r0,#4                 ;1584
00003e  bd70              POP      {r4-r6,pc}
                  |L19.64|
000040  60e5              STR      r5,[r4,#0xc]          ;1590
000042  60a1              STR      r1,[r4,#8]            ;1591
000044  6024              STR      r4,[r4,#0]            ;1591
000046  6064              STR      r4,[r4,#4]            ;1591
000048  f7fffffe          BL       RMP_Unlock_Sched
00004c  2000              MOVS     r0,#0                 ;1596
00004e  bd70              POP      {r4-r6,pc}
;;;1598   /* End Function:RMP_Sem_Crt **************************************************/
                          ENDP

                  |L19.80|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Del||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Del PROC
;;;1605   ******************************************************************************/
;;;1606   rmp_ret_t RMP_Sem_Del(volatile struct RMP_Sem* Semaphore)
000000  2800              CMP      r0,#0
;;;1607   {
;;;1608       struct RMP_Thd* Thread;
;;;1609       
;;;1610       /* Check if this semaphore structure could possibly be in use */
;;;1611       if(Semaphore==0)
;;;1612       {
;;;1613           RMP_COVERAGE_MARKER();
;;;1614           return RMP_ERR_SEM;
000002  bf04              ITT      EQ
000004  f06f0005          MVNEQ    r0,#5
;;;1615       }
;;;1616       else
;;;1617           RMP_COVERAGE_MARKER();
;;;1618       
;;;1619       RMP_Lock_Sched();
;;;1620       
;;;1621       if(Semaphore->State!=RMP_SEM_USED)
;;;1622       {
;;;1623           RMP_COVERAGE_MARKER();
;;;1624           RMP_Unlock_Sched();
;;;1625           return RMP_ERR_SEM;
;;;1626       }
;;;1627       else
;;;1628           RMP_COVERAGE_MARKER();
;;;1629   
;;;1630       /* Get rid of all guys waiting on it */
;;;1631       while(&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)
;;;1632       {
;;;1633           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1634           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1635           
;;;1636           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1637           {
;;;1638               RMP_COVERAGE_MARKER();
;;;1639               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1640           }
;;;1641           else
;;;1642               RMP_COVERAGE_MARKER();
;;;1643   
;;;1644           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1645           /* Set to running if not suspended */
;;;1646           _RMP_Set_Rdy(Thread);
;;;1647           Thread->Retval=RMP_ERR_OPER;
;;;1648       }
;;;1649       Semaphore->State=RMP_SEM_FREE;
;;;1650       
;;;1651       RMP_Unlock_Sched();
;;;1652   
;;;1653       return 0;
;;;1654   }
000008  4770              BXEQ     lr
00000a  b570              PUSH     {r4-r6,lr}            ;1607
00000c  4605              MOV      r5,r0                 ;1607
00000e  20ff              MOVS     r0,#0xff              ;1607
000010  f7fffffe          BL       RMP_Mask_Int
000014  4819              LDR      r0,|L20.124|
000016  2101              MOVS     r1,#1                 ;1607
000018  6041              STR      r1,[r0,#4]            ;1607  ; RMP_Sched_Locked
00001a  6801              LDR      r1,[r0,#0]            ;1607  ; RMP_Sched_Lock_Cnt
00001c  1c49              ADDS     r1,r1,#1              ;1607
00001e  6001              STR      r1,[r0,#0]            ;1607  ; RMP_Sched_Lock_Cnt
000020  68a8              LDR      r0,[r5,#8]            ;1621
000022  2801              CMP      r0,#1                 ;1621
000024  d004              BEQ      |L20.48|
000026  f7fffffe          BL       RMP_Unlock_Sched
00002a  f06f0005          MVN      r0,#5                 ;1625
00002e  bd70              POP      {r4-r6,pc}
                  |L20.48|
000030  6868              LDR      r0,[r5,#4]            ;1631
000032  42a8              CMP      r0,r5                 ;1631
000034  bf18              IT       NE                    ;1647
000036  f06f0604          MVNNE    r6,#4                 ;1647
00003a  d018              BEQ      |L20.110|
                  |L20.60|
00003c  686c              LDR      r4,[r5,#4]            ;1633
00003e  e9d40100          LDRD     r0,r1,[r4,#0]         ;1633
000042  6008              STR      r0,[r1,#0]            ;1633
000044  6041              STR      r1,[r0,#4]            ;1633
000046  7e20              LDRB     r0,[r4,#0x18]         ;1636
000048  2808              CMP      r0,#8                 ;1636
00004a  d103              BNE      |L20.84|
00004c  e9d40102          LDRD     r0,r1,[r4,#8]         ;1636
000050  6008              STR      r0,[r1,#0]            ;1636
000052  6041              STR      r1,[r0,#4]            ;1636
                  |L20.84|
000054  69a0              LDR      r0,[r4,#0x18]         ;1644
000056  f02000ff          BIC      r0,r0,#0xff           ;1644
00005a  f0400001          ORR      r0,r0,#1              ;1644
00005e  61a0              STR      r0,[r4,#0x18]         ;1646
000060  4620              MOV      r0,r4                 ;1646
000062  f7fffffe          BL       _RMP_Set_Rdy
000066  63a6              STR      r6,[r4,#0x38]         ;1647
000068  6868              LDR      r0,[r5,#4]            ;1647
00006a  42a8              CMP      r0,r5                 ;1647
00006c  d1e6              BNE      |L20.60|
                  |L20.110|
00006e  2000              MOVS     r0,#0                 ;1649
000070  60a8              STR      r0,[r5,#8]            ;1649
000072  f7fffffe          BL       RMP_Unlock_Sched
000076  2000              MOVS     r0,#0                 ;1653
000078  bd70              POP      {r4-r6,pc}
;;;1655   /* End Function:RMP_Sem_Del **************************************************/
                          ENDP

00007a  0000              DCW      0x0000
                  |L20.124|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Pend||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Pend PROC
;;;1663   ******************************************************************************/
;;;1664   rmp_ret_t RMP_Sem_Pend(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Slices)
000000  2800              CMP      r0,#0
;;;1665   {
;;;1666       /* Check if this semaphore structure could possibly be in use */
;;;1667       if(Semaphore==0)
;;;1668       {
;;;1669           RMP_COVERAGE_MARKER();
;;;1670           return RMP_ERR_SEM;
000002  bf04              ITT      EQ
000004  f06f0005          MVNEQ    r0,#5
;;;1671       }
;;;1672       else
;;;1673           RMP_COVERAGE_MARKER();
;;;1674       
;;;1675       RMP_Lock_Sched();
;;;1676       
;;;1677       if(Semaphore->State!=RMP_SEM_USED)
;;;1678       {
;;;1679           RMP_COVERAGE_MARKER();
;;;1680           RMP_Unlock_Sched();
;;;1681           return RMP_ERR_SEM;
;;;1682       }
;;;1683       else
;;;1684           RMP_COVERAGE_MARKER();
;;;1685       
;;;1686       /* Check if we can get one immediately */
;;;1687       if(Semaphore->Cur_Num!=0)
;;;1688       {
;;;1689           RMP_COVERAGE_MARKER();
;;;1690           Semaphore->Cur_Num--;
;;;1691           RMP_Unlock_Sched();
;;;1692           return Semaphore->Cur_Num;
;;;1693       }
;;;1694       else
;;;1695       {
;;;1696           RMP_COVERAGE_MARKER();
;;;1697           /* Cannot get one, we need to block */
;;;1698           if(Slices==0)
;;;1699           {
;;;1700               RMP_COVERAGE_MARKER();
;;;1701               RMP_Unlock_Sched();
;;;1702               return RMP_ERR_OPER;
;;;1703           }
;;;1704           else
;;;1705               RMP_COVERAGE_MARKER();
;;;1706   
;;;1707           /* We must be running - place into waitlist now */
;;;1708           _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1709           RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Semaphore->Wait_List.Prev,&(Semaphore->Wait_List));
;;;1710           
;;;1711           if(Slices<RMP_MAX_SLICES)
;;;1712           {
;;;1713               RMP_COVERAGE_MARKER();
;;;1714               _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1715               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMDLY);
;;;1716           }
;;;1717           else
;;;1718           {
;;;1719               RMP_COVERAGE_MARKER();
;;;1720               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMBLK);
;;;1721           }
;;;1722           
;;;1723           RMP_Cur_Thd->Retval=0;
;;;1724       }
;;;1725       
;;;1726       RMP_Unlock_Sched();
;;;1727   
;;;1728       return RMP_Cur_Thd->Retval;
;;;1729   }
000008  4770              BXEQ     lr
00000a  b570              PUSH     {r4-r6,lr}            ;1665
00000c  460d              MOV      r5,r1                 ;1665
00000e  4604              MOV      r4,r0                 ;1665
000010  20ff              MOVS     r0,#0xff              ;1665
000012  f7fffffe          BL       RMP_Mask_Int
000016  4e2e              LDR      r6,|L21.208|
000018  2001              MOVS     r0,#1                 ;1665
00001a  6070              STR      r0,[r6,#4]            ;1665  ; RMP_Sched_Locked
00001c  6830              LDR      r0,[r6,#0]            ;1665  ; RMP_Sched_Lock_Cnt
00001e  1c40              ADDS     r0,r0,#1              ;1665
000020  6030              STR      r0,[r6,#0]            ;1665  ; RMP_Sched_Lock_Cnt
000022  68a0              LDR      r0,[r4,#8]            ;1677
000024  2801              CMP      r0,#1                 ;1677
000026  d004              BEQ      |L21.50|
000028  f7fffffe          BL       RMP_Unlock_Sched
00002c  f06f0005          MVN      r0,#5                 ;1681
000030  bd70              POP      {r4-r6,pc}
                  |L21.50|
000032  68e0              LDR      r0,[r4,#0xc]          ;1687
000034  b130              CBZ      r0,|L21.68|
000036  68e0              LDR      r0,[r4,#0xc]          ;1690
000038  1e40              SUBS     r0,r0,#1              ;1690
00003a  60e0              STR      r0,[r4,#0xc]          ;1690
00003c  f7fffffe          BL       RMP_Unlock_Sched
000040  68e0              LDR      r0,[r4,#0xc]          ;1692
000042  bd70              POP      {r4-r6,pc}
                  |L21.68|
000044  2d00              CMP      r5,#0                 ;1698
000046  d035              BEQ      |L21.180|
000048  6970              LDR      r0,[r6,#0x14]         ;1708  ; RMP_Cur_Thd
00004a  f7fffffe          BL       _RMP_Clr_Rdy
00004e  6970              LDR      r0,[r6,#0x14]         ;1709  ; RMP_Cur_Thd
000050  6821              LDR      r1,[r4,#0]            ;1709
000052  6020              STR      r0,[r4,#0]            ;1709
000054  6044              STR      r4,[r0,#4]            ;1709
000056  6001              STR      r1,[r0,#0]            ;1709
000058  6048              STR      r0,[r1,#4]            ;1709
00005a  481e              LDR      r0,|L21.212|
00005c  4285              CMP      r5,r0                 ;1711
00005e  d22e              BCS      |L21.190|
000060  6973              LDR      r3,[r6,#0x14]         ;1714  ; RMP_Cur_Thd
000062  4a1d              LDR      r2,|L21.216|
000064  6850              LDR      r0,[r2,#4]            ;1714  ; RMP_Delay
000066  4290              CMP      r0,r2                 ;1714
000068  d00a              BEQ      |L21.128|
00006a  bf00              NOP                            ;1714
                  |L21.108|
00006c  f8d6c010          LDR      r12,[r6,#0x10]        ;1714  ; RMP_Tick
000070  6a01              LDR      r1,[r0,#0x20]         ;1714
000072  eba1010c          SUB      r1,r1,r12             ;1714
000076  42a9              CMP      r1,r5                 ;1714
000078  d802              BHI      |L21.128|
00007a  6840              LDR      r0,[r0,#4]            ;1714
00007c  4290              CMP      r0,r2                 ;1714
00007e  d1f5              BNE      |L21.108|
                  |L21.128|
000080  6931              LDR      r1,[r6,#0x10]         ;1714  ; RMP_Tick
000082  4429              ADD      r1,r1,r5              ;1714
000084  6299              STR      r1,[r3,#0x28]         ;1714
000086  6802              LDR      r2,[r0,#0]            ;1714
000088  f1030108          ADD      r1,r3,#8              ;1714
00008c  6001              STR      r1,[r0,#0]            ;1714
00008e  60d8              STR      r0,[r3,#0xc]          ;1714
000090  609a              STR      r2,[r3,#8]            ;1714
000092  6051              STR      r1,[r2,#4]            ;1714
000094  6970              LDR      r0,[r6,#0x14]         ;1715  ; RMP_Cur_Thd
000096  6971              LDR      r1,[r6,#0x14]         ;1715  ; RMP_Cur_Thd
000098  6980              LDR      r0,[r0,#0x18]         ;1715
00009a  f02000ff          BIC      r0,r0,#0xff           ;1715
00009e  f0400008          ORR      r0,r0,#8              ;1715
                  |L21.162|
0000a2  6188              STR      r0,[r1,#0x18]         ;1723
0000a4  6971              LDR      r1,[r6,#0x14]         ;1723  ; RMP_Cur_Thd
0000a6  2000              MOVS     r0,#0                 ;1723
0000a8  6388              STR      r0,[r1,#0x38]         ;1726
0000aa  f7fffffe          BL       RMP_Unlock_Sched
0000ae  6970              LDR      r0,[r6,#0x14]         ;1728  ; RMP_Cur_Thd
0000b0  6b80              LDR      r0,[r0,#0x38]         ;1728
0000b2  bd70              POP      {r4-r6,pc}
                  |L21.180|
0000b4  f7fffffe          BL       RMP_Unlock_Sched
0000b8  f06f0004          MVN      r0,#4                 ;1702
0000bc  bd70              POP      {r4-r6,pc}
                  |L21.190|
0000be  6970              LDR      r0,[r6,#0x14]         ;1720  ; RMP_Cur_Thd
0000c0  6971              LDR      r1,[r6,#0x14]         ;1720  ; RMP_Cur_Thd
0000c2  6980              LDR      r0,[r0,#0x18]         ;1720
0000c4  f02000ff          BIC      r0,r0,#0xff           ;1720
0000c8  f0400007          ORR      r0,r0,#7              ;1720
0000cc  e7e9              B        |L21.162|
;;;1730   /* End Function:RMP_Sem_Pend *************************************************/
                          ENDP

0000ce  0000              DCW      0x0000
                  |L21.208|
                          DCD      ||.data||
                  |L21.212|
                          DCD      0x000186a0
                  |L21.216|
                          DCD      ||.data||+0x24

                          AREA ||i.RMP_Sem_Post||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Post PROC
;;;1797   ******************************************************************************/
;;;1798   rmp_ret_t RMP_Sem_Post(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number)
000000  2800              CMP      r0,#0
;;;1799   {
;;;1800       struct RMP_Thd* Thread;
;;;1801       
;;;1802       /* Check if this semaphore structure could possibly be in use */
;;;1803       if((Semaphore==0)||(Number==0))
000002  bf12              ITEE     NE
000004  2900              CMPNE    r1,#0
;;;1804       {
;;;1805           RMP_COVERAGE_MARKER();
;;;1806           return RMP_ERR_SEM;
000006  f06f0005          MVNEQ    r0,#5
;;;1807       }
;;;1808       else
;;;1809           RMP_COVERAGE_MARKER();
;;;1810       
;;;1811       RMP_Lock_Sched();
;;;1812       
;;;1813       if(Semaphore->State!=RMP_SEM_USED)
;;;1814       {
;;;1815           RMP_COVERAGE_MARKER();
;;;1816           RMP_Unlock_Sched();
;;;1817           return RMP_ERR_SEM;
;;;1818       }
;;;1819       else
;;;1820           RMP_COVERAGE_MARKER();
;;;1821       
;;;1822       /* Would the maximum value be exceeded if this is posted? */
;;;1823       if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
;;;1824       {
;;;1825           RMP_COVERAGE_MARKER();
;;;1826           RMP_Unlock_Sched();
;;;1827           return RMP_ERR_OPER;
;;;1828       }
;;;1829       else
;;;1830           RMP_COVERAGE_MARKER();
;;;1831       
;;;1832       Semaphore->Cur_Num+=Number;
;;;1833       /* Is there any thread waiting on it? If there are, clean them up*/
;;;1834       while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
;;;1835       {
;;;1836           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1837           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1838           
;;;1839           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1840           {
;;;1841               RMP_COVERAGE_MARKER();
;;;1842               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1843           }
;;;1844           else
;;;1845               RMP_COVERAGE_MARKER();
;;;1846           
;;;1847           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1848           /* Set to running if not suspended */
;;;1849           _RMP_Set_Rdy(Thread);
;;;1850   
;;;1851           /* Finally, return success */
;;;1852           Thread->Retval=0;
;;;1853           Semaphore->Cur_Num--;
;;;1854       }
;;;1855   
;;;1856       RMP_Unlock_Sched();
;;;1857       return 0;
;;;1858   }
00000a  4770              BXEQ     lr
00000c  b570              PUSH     {r4-r6,lr}            ;1799
00000e  460d              MOV      r5,r1                 ;1799
000010  4604              MOV      r4,r0                 ;1799
000012  20ff              MOVS     r0,#0xff              ;1799
000014  f7fffffe          BL       RMP_Mask_Int
000018  481f              LDR      r0,|L22.152|
00001a  2101              MOVS     r1,#1                 ;1799
00001c  6041              STR      r1,[r0,#4]            ;1799  ; RMP_Sched_Locked
00001e  6801              LDR      r1,[r0,#0]            ;1799  ; RMP_Sched_Lock_Cnt
000020  1c49              ADDS     r1,r1,#1              ;1799
000022  6001              STR      r1,[r0,#0]            ;1799  ; RMP_Sched_Lock_Cnt
000024  68a0              LDR      r0,[r4,#8]            ;1813
000026  2801              CMP      r0,#1                 ;1813
000028  d004              BEQ      |L22.52|
00002a  f7fffffe          BL       RMP_Unlock_Sched
00002e  f06f0005          MVN      r0,#5                 ;1817
000032  bd70              POP      {r4-r6,pc}
                  |L22.52|
000034  68e0              LDR      r0,[r4,#0xc]          ;1823
000036  4428              ADD      r0,r0,r5              ;1823
000038  f5b07f7a          CMP      r0,#0x3e8             ;1823
00003c  d304              BCC      |L22.72|
00003e  f7fffffe          BL       RMP_Unlock_Sched
000042  f06f0004          MVN      r0,#4                 ;1827
000046  bd70              POP      {r4-r6,pc}
                  |L22.72|
000048  68e0              LDR      r0,[r4,#0xc]          ;1832
00004a  2600              MOVS     r6,#0                 ;1832
00004c  4428              ADD      r0,r0,r5              ;1832
00004e  e017              B        |L22.128|
                  |L22.80|
000050  6865              LDR      r5,[r4,#4]            ;1836
000052  e9d50100          LDRD     r0,r1,[r5,#0]         ;1836
000056  6008              STR      r0,[r1,#0]            ;1836
000058  6041              STR      r1,[r0,#4]            ;1836
00005a  7e28              LDRB     r0,[r5,#0x18]         ;1839
00005c  2808              CMP      r0,#8                 ;1839
00005e  d103              BNE      |L22.104|
000060  e9d50102          LDRD     r0,r1,[r5,#8]         ;1839
000064  6008              STR      r0,[r1,#0]            ;1839
000066  6041              STR      r1,[r0,#4]            ;1839
                  |L22.104|
000068  69a8              LDR      r0,[r5,#0x18]         ;1847
00006a  f02000ff          BIC      r0,r0,#0xff           ;1847
00006e  f0400001          ORR      r0,r0,#1              ;1847
000072  61a8              STR      r0,[r5,#0x18]         ;1849
000074  4628              MOV      r0,r5                 ;1849
000076  f7fffffe          BL       _RMP_Set_Rdy
00007a  63ae              STR      r6,[r5,#0x38]         ;1853
00007c  68e0              LDR      r0,[r4,#0xc]          ;1853
00007e  1e40              SUBS     r0,r0,#1              ;1853
                  |L22.128|
000080  60e0              STR      r0,[r4,#0xc]          ;1832
000082  6860              LDR      r0,[r4,#4]            ;1853
000084  42a0              CMP      r0,r4                 ;1853
000086  bf1c              ITT      NE                    ;1853
000088  68e0              LDRNE    r0,[r4,#0xc]          ;1853
00008a  2800              CMPNE    r0,#0                 ;1853
00008c  d1e0              BNE      |L22.80|
00008e  f7fffffe          BL       RMP_Unlock_Sched
000092  2000              MOVS     r0,#0                 ;1857
000094  bd70              POP      {r4-r6,pc}
;;;1859   /* End Function:RMP_Sem_Post *************************************************/
                          ENDP

000096  0000              DCW      0x0000
                  |L22.152|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Post_ISR||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Post_ISR PROC
;;;1869   ******************************************************************************/
;;;1870   rmp_ret_t RMP_Sem_Post_ISR(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number)
000000  2800              CMP      r0,#0
;;;1871   {
;;;1872       struct RMP_Thd* Thread;
;;;1873       /* Check if this semaphore structure could possibly be in use */
;;;1874       if((Semaphore==0)||(Number==0))
000002  bf12              ITEE     NE
000004  2900              CMPNE    r1,#0
;;;1875       {
;;;1876           RMP_COVERAGE_MARKER();
;;;1877           return RMP_ERR_SEM;
000006  f06f0005          MVNEQ    r0,#5
;;;1878       }
;;;1879       else
;;;1880           RMP_COVERAGE_MARKER();
;;;1881       
;;;1882       if(Semaphore->State!=RMP_SEM_USED)
;;;1883       {
;;;1884           RMP_COVERAGE_MARKER();
;;;1885           return RMP_ERR_SEM;
;;;1886       }
;;;1887       else
;;;1888           RMP_COVERAGE_MARKER();
;;;1889   
;;;1890       /* Would the maximum value be exceeded if this is posted? */
;;;1891       if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
;;;1892       {
;;;1893           RMP_COVERAGE_MARKER();
;;;1894           return RMP_ERR_OPER;
;;;1895       }
;;;1896       else
;;;1897           RMP_COVERAGE_MARKER();
;;;1898       
;;;1899       Semaphore->Cur_Num+=Number;
;;;1900       /* Is there any thread waiting on it? If there are, clean them up*/
;;;1901       while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
;;;1902       {
;;;1903           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1904           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1905           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1906           {
;;;1907               RMP_COVERAGE_MARKER();
;;;1908               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1909           }
;;;1910           else
;;;1911               RMP_COVERAGE_MARKER();
;;;1912           
;;;1913           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1914           /* Set to running if not suspended */
;;;1915           _RMP_Set_Rdy(Thread);
;;;1916           
;;;1917           /* If schedule pending, trigger it now because we are in ISR */
;;;1918           if(RMP_Sched_Pend!=0)
;;;1919           {
;;;1920               RMP_COVERAGE_MARKER();
;;;1921               RMP_Sched_Pend=0;
;;;1922               _RMP_Yield();   
;;;1923           }
;;;1924           else
;;;1925               RMP_COVERAGE_MARKER();
;;;1926   
;;;1927           /* Finally, return success */
;;;1928           Thread->Retval=0;
;;;1929           Semaphore->Cur_Num--;
;;;1930       }
;;;1931   
;;;1932       return 0;
;;;1933   }
00000a  4770              BXEQ     lr
00000c  e92d41f0          PUSH     {r4-r8,lr}            ;1871
000010  4604              MOV      r4,r0                 ;1871
000012  6880              LDR      r0,[r0,#8]            ;1882
000014  2801              CMP      r0,#1                 ;1882
000016  bf1c              ITT      NE                    ;1885
000018  f06f0005          MVNNE    r0,#5                 ;1885
00001c  e8bd81f0          POPNE    {r4-r8,pc}
000020  68e0              LDR      r0,[r4,#0xc]          ;1891
000022  4408              ADD      r0,r0,r1              ;1891
000024  f5b07f7a          CMP      r0,#0x3e8             ;1891
000028  bf24              ITT      CS                    ;1894
00002a  f06f0004          MVNCS    r0,#4                 ;1894
00002e  e8bd81f0          POPCS    {r4-r8,pc}
000032  68e0              LDR      r0,[r4,#0xc]          ;1899
000034  2700              MOVS     r7,#0                 ;1918
000036  4e15              LDR      r6,|L23.140|
000038  4408              ADD      r0,r0,r1              ;1899
00003a  e01d              B        |L23.120|
                  |L23.60|
00003c  6865              LDR      r5,[r4,#4]            ;1903
00003e  e9d50100          LDRD     r0,r1,[r5,#0]         ;1903
000042  6008              STR      r0,[r1,#0]            ;1903
000044  6041              STR      r1,[r0,#4]            ;1903
000046  7e28              LDRB     r0,[r5,#0x18]         ;1905
000048  2808              CMP      r0,#8                 ;1905
00004a  d103              BNE      |L23.84|
00004c  e9d50102          LDRD     r0,r1,[r5,#8]         ;1905
000050  6008              STR      r0,[r1,#0]            ;1905
000052  6041              STR      r1,[r0,#4]            ;1905
                  |L23.84|
000054  69a8              LDR      r0,[r5,#0x18]         ;1913
000056  f02000ff          BIC      r0,r0,#0xff           ;1913
00005a  f0400001          ORR      r0,r0,#1              ;1913
00005e  61a8              STR      r0,[r5,#0x18]         ;1915
000060  4628              MOV      r0,r5                 ;1915
000062  f7fffffe          BL       _RMP_Set_Rdy
000066  68b0              LDR      r0,[r6,#8]            ;1918  ; RMP_Sched_Pend
000068  2800              CMP      r0,#0                 ;1918
00006a  bf1c              ITT      NE                    ;1921
00006c  60b7              STRNE    r7,[r6,#8]            ;1921  ; RMP_Sched_Pend
00006e  f7fffffe          BLNE     _RMP_Yield
000072  63af              STR      r7,[r5,#0x38]         ;1929
000074  68e0              LDR      r0,[r4,#0xc]          ;1929
000076  1e40              SUBS     r0,r0,#1              ;1929
                  |L23.120|
000078  60e0              STR      r0,[r4,#0xc]          ;1899
00007a  6860              LDR      r0,[r4,#4]            ;1929
00007c  42a0              CMP      r0,r4                 ;1929
00007e  bf1a              ITTE     NE                    ;1929
000080  68e0              LDRNE    r0,[r4,#0xc]          ;1929
000082  2800              CMPNE    r0,#0                 ;1929
000084  2000              MOVEQ    r0,#0                 ;1932
000086  d1d9              BNE      |L23.60|
000088  e8bd81f0          POP      {r4-r8,pc}
;;;1934   /* End Function:RMP_Sem_Post_ISR *********************************************/
                          ENDP

                  |L23.140|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Cancel||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Cancel PROC
;;;1514   ******************************************************************************/
;;;1515   rmp_ret_t RMP_Thd_Cancel(volatile struct RMP_Thd* Thread)
000000  2800              CMP      r0,#0
;;;1516   {
;;;1517       /* Check if this thread structure could possibly be in use */
;;;1518       if(Thread==0)
;;;1519       {
;;;1520           RMP_COVERAGE_MARKER();
;;;1521           return RMP_ERR_THD;
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;1522       }
;;;1523       else
;;;1524           RMP_COVERAGE_MARKER();
;;;1525       
;;;1526       RMP_Lock_Sched();
;;;1527       
;;;1528       /* Is it delayed? */
;;;1529       if(RMP_THD_STATE(Thread->State)!=RMP_THD_DELAYED)
;;;1530       {
;;;1531           RMP_COVERAGE_MARKER();
;;;1532           RMP_Unlock_Sched();
;;;1533           return RMP_ERR_STATE;
;;;1534       }
;;;1535       else
;;;1536           RMP_COVERAGE_MARKER();
;;;1537   
;;;1538       /* Delete it from the delay list */
;;;1539       RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1540       RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1541       /* Set to running if not suspended */
;;;1542       _RMP_Set_Rdy(Thread);
;;;1543       
;;;1544       Thread->Retval=RMP_ERR_OPER;
;;;1545       RMP_Unlock_Sched();
;;;1546       return 0;
;;;1547   }
000008  4770              BXEQ     lr
00000a  b510              PUSH     {r4,lr}               ;1516
00000c  4604              MOV      r4,r0                 ;1516
00000e  20ff              MOVS     r0,#0xff              ;1516
000010  f7fffffe          BL       RMP_Mask_Int
000014  4811              LDR      r0,|L24.92|
000016  2101              MOVS     r1,#1                 ;1516
000018  6041              STR      r1,[r0,#4]            ;1516  ; RMP_Sched_Locked
00001a  6801              LDR      r1,[r0,#0]            ;1516  ; RMP_Sched_Lock_Cnt
00001c  1c49              ADDS     r1,r1,#1              ;1516
00001e  6001              STR      r1,[r0,#0]            ;1516  ; RMP_Sched_Lock_Cnt
000020  69a0              LDR      r0,[r4,#0x18]         ;1529
000022  b2c0              UXTB     r0,r0                 ;1529
000024  2806              CMP      r0,#6                 ;1529
000026  d004              BEQ      |L24.50|
000028  f7fffffe          BL       RMP_Unlock_Sched
00002c  f06f0003          MVN      r0,#3                 ;1533
000030  bd10              POP      {r4,pc}
                  |L24.50|
000032  68a0              LDR      r0,[r4,#8]            ;1539
000034  68e1              LDR      r1,[r4,#0xc]          ;1539
000036  6008              STR      r0,[r1,#0]            ;1539
000038  6041              STR      r1,[r0,#4]            ;1539
00003a  69a0              LDR      r0,[r4,#0x18]         ;1540
00003c  f02000ff          BIC      r0,r0,#0xff           ;1540
000040  f0400001          ORR      r0,r0,#1              ;1540
000044  61a0              STR      r0,[r4,#0x18]         ;1540
000046  4620              MOV      r0,r4                 ;1542
000048  f7fffffe          BL       _RMP_Set_Rdy
00004c  f06f0004          MVN      r0,#4                 ;1544
000050  63a0              STR      r0,[r4,#0x38]         ;1544
000052  f7fffffe          BL       RMP_Unlock_Sched
000056  2000              MOVS     r0,#0                 ;1546
000058  bd10              POP      {r4,pc}
;;;1548   /* End Function:RMP_Thd_Cancel ***********************************************/
                          ENDP

00005a  0000              DCW      0x0000
                  |L24.92|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Crt||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Crt PROC
;;;766    ******************************************************************************/
;;;767    rmp_ret_t RMP_Thd_Crt(volatile struct RMP_Thd* Thread, void* Entry, void* Stack, void* Arg, rmp_ptr_t Prio, rmp_ptr_t Slices)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;768    {
000004  4699              MOV      r9,r3
000006  4616              MOV      r6,r2
000008  468a              MOV      r10,r1
00000a  4604              MOV      r4,r0
00000c  e9dd8508          LDRD     r8,r5,[sp,#0x20]
;;;769        /* Check if the priority and timeslice range is correct */
;;;770        if(Prio>=RMP_MAX_PREEMPT_PRIO)
000010  f1b80f40          CMP      r8,#0x40
;;;771        {
;;;772            RMP_COVERAGE_MARKER();
;;;773            return RMP_ERR_PRIO;
000014  bf24              ITT      CS
000016  f06f0001          MVNCS    r0,#1
;;;774        }
;;;775        else
;;;776            RMP_COVERAGE_MARKER();
;;;777        
;;;778        if((Slices==0)||(Slices>=RMP_MAX_SLICES))
;;;779        {
;;;780            RMP_COVERAGE_MARKER();
;;;781            return RMP_ERR_SLICE;
;;;782        }
;;;783        else
;;;784            RMP_COVERAGE_MARKER();
;;;785        
;;;786        /* Check if this thread structure could possibly be in use */
;;;787        if(Thread==0)
;;;788        {
;;;789            RMP_COVERAGE_MARKER();
;;;790            return RMP_ERR_THD;
;;;791        }
;;;792        else
;;;793            RMP_COVERAGE_MARKER();
;;;794        
;;;795        RMP_Lock_Sched();
;;;796        
;;;797        if(RMP_THD_STATE(Thread->State)!=RMP_THD_FREE)
;;;798        {
;;;799            RMP_COVERAGE_MARKER();
;;;800            RMP_Unlock_Sched();
;;;801            return RMP_ERR_THD;
;;;802        }
;;;803        else
;;;804            RMP_COVERAGE_MARKER();
;;;805        
;;;806        /* Create the thread and insert it into the list */
;;;807        Thread->Prio=Prio;
;;;808        Thread->Slices=Slices;
;;;809        Thread->Slices_Left=Slices;
;;;810        Thread->Stack=(rmp_ptr_t)Stack;
;;;811        
;;;812        /* Initialize its stack and sending list */
;;;813        _RMP_Stack_Init((rmp_ptr_t)Entry, (rmp_ptr_t)Stack, (rmp_ptr_t)Arg);
;;;814        RMP_List_Crt(&(Thread->Snd_List));
;;;815        
;;;816        /* Notify the scheduler that we have created something new, also check locks */
;;;817        Thread->State=RMP_THD_RUNNING;
;;;818        _RMP_Set_Rdy(Thread);
;;;819        
;;;820        RMP_Unlock_Sched();
;;;821    
;;;822        return 0;
;;;823    }
00001a  e8bd87f0          POPCS    {r4-r10,pc}
00001e  2d00              CMP      r5,#0                 ;778
000020  bf1c              ITT      NE                    ;778
000022  481b              LDRNE    r0,|L25.144|
000024  4285              CMPNE    r5,r0                 ;778
000026  bf24              ITT      CS                    ;781
000028  f06f0002          MVNCS    r0,#2                 ;781
00002c  e8bd87f0          POPCS    {r4-r10,pc}
000030  2c00              CMP      r4,#0                 ;787
000032  bf04              ITT      EQ                    ;790
000034  f04f30ff          MOVEQ    r0,#0xffffffff        ;790
000038  e8bd87f0          POPEQ    {r4-r10,pc}
00003c  20ff              MOVS     r0,#0xff
00003e  f7fffffe          BL       RMP_Mask_Int
000042  4814              LDR      r0,|L25.148|
000044  2701              MOVS     r7,#1
000046  6047              STR      r7,[r0,#4]  ; RMP_Sched_Locked
000048  6801              LDR      r1,[r0,#0]  ; RMP_Sched_Lock_Cnt
00004a  1c49              ADDS     r1,r1,#1
00004c  6001              STR      r1,[r0,#0]  ; RMP_Sched_Lock_Cnt
00004e  69a0              LDR      r0,[r4,#0x18]         ;797
000050  f0100fff          TST      r0,#0xff              ;797
000054  d004              BEQ      |L25.96|
000056  f7fffffe          BL       RMP_Unlock_Sched
00005a  1eb8              SUBS     r0,r7,#2              ;801
00005c  e8bd87f0          POP      {r4-r10,pc}
                  |L25.96|
000060  f8c48024          STR      r8,[r4,#0x24]         ;807
000064  61e5              STR      r5,[r4,#0x1c]         ;808
000066  6225              STR      r5,[r4,#0x20]         ;809
000068  6366              STR      r6,[r4,#0x34]         ;810
00006a  464a              MOV      r2,r9                 ;813
00006c  4631              MOV      r1,r6                 ;813
00006e  4650              MOV      r0,r10                ;813
000070  f7fffffe          BL       _RMP_Stack_Init
000074  f1040010          ADD      r0,r4,#0x10           ;814
000078  6120              STR      r0,[r4,#0x10]         ;814
00007a  6160              STR      r0,[r4,#0x14]         ;814
00007c  61a7              STR      r7,[r4,#0x18]         ;817
00007e  4620              MOV      r0,r4                 ;818
000080  f7fffffe          BL       _RMP_Set_Rdy
000084  f7fffffe          BL       RMP_Unlock_Sched
000088  2000              MOVS     r0,#0                 ;822
00008a  e8bd87f0          POP      {r4-r10,pc}
;;;824    /* End Function:RMP_Thd_Crt **************************************************/
                          ENDP

00008e  0000              DCW      0x0000
                  |L25.144|
                          DCD      0x000186a0
                  |L25.148|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Del||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Del PROC
;;;831    ******************************************************************************/
;;;832    rmp_ret_t RMP_Thd_Del(volatile struct RMP_Thd* Thread)
000000  2800              CMP      r0,#0
;;;833    {
;;;834        struct RMP_Thd* Release;
;;;835        
;;;836        /* Check if this thread structure could possibly be in use */
;;;837        if(Thread==0)
;;;838        {
;;;839            RMP_COVERAGE_MARKER();
;;;840            return RMP_ERR_THD;
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;841        }
;;;842        else
;;;843            RMP_COVERAGE_MARKER();
;;;844        
;;;845        RMP_Lock_Sched();
;;;846        
;;;847        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;848        {
;;;849            RMP_COVERAGE_MARKER();
;;;850            RMP_Unlock_Sched();
;;;851            return RMP_ERR_THD;
;;;852        }
;;;853        else
;;;854            RMP_COVERAGE_MARKER();
;;;855        
;;;856        /* See if anyone waiting to send to this thread. If there is, release all these threads */
;;;857        while(&(Thread->Snd_List)!=Thread->Snd_List.Next)
;;;858        {
;;;859            Release=(struct RMP_Thd*)(Thread->Snd_List.Next);
;;;860            RMP_List_Del(Release->Run_Head.Prev,Release->Run_Head.Next);
;;;861            if(RMP_THD_STATE(Release->State)==RMP_THD_SNDDLY)
;;;862            {
;;;863                RMP_COVERAGE_MARKER();
;;;864                RMP_List_Del(Release->Dly_Head.Prev,Release->Dly_Head.Next);
;;;865            }
;;;866            else
;;;867                RMP_COVERAGE_MARKER();
;;;868            
;;;869            RMP_THD_STATE_SET(Release->State,RMP_THD_RUNNING);
;;;870            /* Set ready if not suspended */
;;;871            _RMP_Set_Rdy(Release);
;;;872            Release->Retval=RMP_ERR_OPER;
;;;873        }
;;;874        
;;;875        /* See what is its state */
;;;876        switch(RMP_THD_STATE(Thread->State))
;;;877        {
;;;878            case RMP_THD_RUNNING:
;;;879            {
;;;880                RMP_COVERAGE_MARKER();
;;;881                /* Clear ready if not suspended */
;;;882                _RMP_Clr_Rdy(Thread);
;;;883                break;
;;;884            }
;;;885            
;;;886            /* Do nothing if it is blocked on receive */
;;;887            case RMP_THD_RCVBLK:
;;;888            {
;;;889                RMP_COVERAGE_MARKER();
;;;890                break;
;;;891            }
;;;892            
;;;893            case RMP_THD_SNDBLK:RMP_COVERAGE_MARKER();
;;;894            case RMP_THD_SEMBLK:
;;;895            {
;;;896                RMP_COVERAGE_MARKER();
;;;897                RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;898                break;
;;;899            }
;;;900            
;;;901            case RMP_THD_SNDDLY:RMP_COVERAGE_MARKER();
;;;902            case RMP_THD_SEMDLY:
;;;903            {
;;;904                RMP_COVERAGE_MARKER();
;;;905                RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;906                /* Fall-through case */
;;;907            }
;;;908            case RMP_THD_RCVDLY:RMP_COVERAGE_MARKER();
;;;909            case RMP_THD_DELAYED:
;;;910            {
;;;911                RMP_COVERAGE_MARKER();
;;;912                RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;913                break;
;;;914            }
;;;915            /* Should not get here */
;;;916            default:while(1);
;;;917        }
;;;918        /* Set return value to failure anyway */
;;;919        Thread->Retval=RMP_ERR_OPER;
;;;920        Thread->State=RMP_THD_FREE;
;;;921        /* If we are deleting ourself, pend a yield */
;;;922        if(Thread==RMP_Cur_Thd)
;;;923        {
;;;924            RMP_COVERAGE_MARKER();
;;;925            RMP_Sched_Pend=1;
;;;926        }
;;;927        else
;;;928            RMP_COVERAGE_MARKER();
;;;929        
;;;930        RMP_Unlock_Sched();
;;;931        
;;;932        /* If we are deleting ourself, just stop the execution here */
;;;933        if(Thread==RMP_Cur_Thd)
;;;934            while(1);
;;;935        else
;;;936            RMP_COVERAGE_MARKER();
;;;937    
;;;938        return 0;
;;;939    }
000008  4770              BXEQ     lr
00000a  e92d47f0          PUSH     {r4-r10,lr}           ;833
00000e  4604              MOV      r4,r0                 ;833
000010  20ff              MOVS     r0,#0xff              ;833
000012  f7fffffe          BL       RMP_Mask_Int
000016  4e30              LDR      r6,|L26.216|
000018  f04f0901          MOV      r9,#1                 ;833
00001c  f8c69004          STR      r9,[r6,#4]            ;833  ; RMP_Sched_Locked
000020  6830              LDR      r0,[r6,#0]            ;833  ; RMP_Sched_Lock_Cnt
000022  1c40              ADDS     r0,r0,#1              ;833
000024  6030              STR      r0,[r6,#0]            ;833  ; RMP_Sched_Lock_Cnt
000026  69a0              LDR      r0,[r4,#0x18]         ;847
000028  f0100fff          TST      r0,#0xff              ;847
00002c  d00f              BEQ      |L26.78|
00002e  6960              LDR      r0,[r4,#0x14]         ;857
000030  f1040810          ADD      r8,r4,#0x10           ;857
000034  f06f0704          MVN      r7,#4                 ;872
000038  4540              CMP      r0,r8                 ;857
00003a  d01f              BEQ      |L26.124|
                  |L26.60|
00003c  6965              LDR      r5,[r4,#0x14]         ;859
00003e  e9d50100          LDRD     r0,r1,[r5,#0]         ;859
000042  6008              STR      r0,[r1,#0]            ;859
000044  6041              STR      r1,[r0,#4]            ;859
000046  7e28              LDRB     r0,[r5,#0x18]         ;861
000048  2803              CMP      r0,#3                 ;861
00004a  d10a              BNE      |L26.98|
00004c  e005              B        |L26.90|
                  |L26.78|
00004e  f7fffffe          BL       RMP_Unlock_Sched
000052  f04f30ff          MOV      r0,#0xffffffff        ;851
000056  e8bd87f0          POP      {r4-r10,pc}
                  |L26.90|
00005a  e9d50102          LDRD     r0,r1,[r5,#8]
00005e  6008              STR      r0,[r1,#0]
000060  6041              STR      r1,[r0,#4]
                  |L26.98|
000062  69a8              LDR      r0,[r5,#0x18]         ;869
000064  f02000ff          BIC      r0,r0,#0xff           ;869
000068  f0400001          ORR      r0,r0,#1              ;869
00006c  61a8              STR      r0,[r5,#0x18]         ;871
00006e  4628              MOV      r0,r5                 ;871
000070  f7fffffe          BL       _RMP_Set_Rdy
000074  63af              STR      r7,[r5,#0x38]         ;872
000076  6960              LDR      r0,[r4,#0x14]         ;872
000078  4540              CMP      r0,r8                 ;872
00007a  d1df              BNE      |L26.60|
                  |L26.124|
00007c  69a0              LDR      r0,[r4,#0x18]         ;876
00007e  b2c0              UXTB     r0,r0                 ;876
000080  2809              CMP      r0,#9                 ;876
000082  d228              BCS      |L26.214|
000084  e8dff000          TBB      [pc,r0]               ;876
000088  2705090e          DCB      0x27,0x05,0x09,0x0e
00008c  16121209          DCB      0x16,0x12,0x12,0x09
000090  0e00              DCB      0x0e,0x00
000092  4620              MOV      r0,r4                 ;882
000094  f7fffffe          BL       _RMP_Clr_Rdy
000098  e00c              B        |L26.180|
00009a  6820              LDR      r0,[r4,#0]            ;897
00009c  6861              LDR      r1,[r4,#4]            ;897
00009e  6008              STR      r0,[r1,#0]            ;897
0000a0  6041              STR      r1,[r0,#4]            ;897
0000a2  e007              B        |L26.180|
0000a4  6821              LDR      r1,[r4,#0]            ;905
0000a6  6860              LDR      r0,[r4,#4]            ;905
0000a8  6001              STR      r1,[r0,#0]            ;905
0000aa  6048              STR      r0,[r1,#4]            ;905
0000ac  68a1              LDR      r1,[r4,#8]            ;912
0000ae  68e0              LDR      r0,[r4,#0xc]          ;912
0000b0  6001              STR      r1,[r0,#0]            ;912
0000b2  6048              STR      r0,[r1,#4]            ;912
                  |L26.180|
0000b4  2000              MOVS     r0,#0                 ;920
0000b6  63a7              STR      r7,[r4,#0x38]         ;919
0000b8  61a0              STR      r0,[r4,#0x18]         ;920
0000ba  6970              LDR      r0,[r6,#0x14]         ;922  ; RMP_Cur_Thd
0000bc  4284              CMP      r4,r0                 ;922
0000be  bf08              IT       EQ                    ;925
0000c0  f8c69008          STREQ    r9,[r6,#8]            ;925  ; RMP_Sched_Pend
0000c4  f7fffffe          BL       RMP_Unlock_Sched
0000c8  6970              LDR      r0,[r6,#0x14]         ;933  ; RMP_Cur_Thd
0000ca  4284              CMP      r4,r0                 ;933
0000cc  bf1c              ITT      NE                    ;938
0000ce  2000              MOVNE    r0,#0                 ;938
0000d0  e8bd87f0          POPNE    {r4-r10,pc}
                  |L26.212|
0000d4  e7fe              B        |L26.212|
                  |L26.214|
0000d6  e7fe              B        |L26.214|
;;;940    /* End Function:RMP_Thd_Del **************************************************/
                          ENDP

                  |L26.216|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Delay||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Delay PROC
;;;1484   ******************************************************************************/
;;;1485   rmp_ret_t RMP_Thd_Delay(rmp_ptr_t Slices)
000000  b570              PUSH     {r4-r6,lr}
;;;1486   {
000002  0005              MOVS     r5,r0
;;;1487       if((Slices==0)||(Slices>=RMP_MAX_SLICES))
000004  bf1c              ITT      NE
000006  481d              LDRNE    r0,|L27.124|
000008  42a8              CMPNE    r0,r5
;;;1488       {
;;;1489           RMP_COVERAGE_MARKER();
;;;1490           return RMP_ERR_SLICE;
00000a  bf9c              ITT      LS
00000c  f06f0002          MVNLS    r0,#2
;;;1491       }
;;;1492       else
;;;1493           RMP_COVERAGE_MARKER();
;;;1494       
;;;1495       RMP_Lock_Sched();
;;;1496   
;;;1497       /* We must be running and not suspended so we will be out of running queue */
;;;1498       _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1499       RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_DELAYED);
;;;1500       _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1501   
;;;1502       RMP_Cur_Thd->Retval=0;
;;;1503       RMP_Unlock_Sched();
;;;1504       /* Need to return if successful or not */
;;;1505       return RMP_Cur_Thd->Retval;
;;;1506   }
000010  bd70              POPLS    {r4-r6,pc}
000012  20ff              MOVS     r0,#0xff
000014  f7fffffe          BL       RMP_Mask_Int
000018  4c19              LDR      r4,|L27.128|
00001a  2001              MOVS     r0,#1
00001c  6060              STR      r0,[r4,#4]  ; RMP_Sched_Locked
00001e  6820              LDR      r0,[r4,#0]  ; RMP_Sched_Lock_Cnt
000020  1c40              ADDS     r0,r0,#1
000022  6020              STR      r0,[r4,#0]  ; RMP_Sched_Lock_Cnt
000024  6960              LDR      r0,[r4,#0x14]         ;1498  ; RMP_Cur_Thd
000026  f7fffffe          BL       _RMP_Clr_Rdy
00002a  6960              LDR      r0,[r4,#0x14]         ;1499  ; RMP_Cur_Thd
00002c  6961              LDR      r1,[r4,#0x14]         ;1499  ; RMP_Cur_Thd
00002e  6980              LDR      r0,[r0,#0x18]         ;1499
000030  f02000ff          BIC      r0,r0,#0xff           ;1499
000034  f0400006          ORR      r0,r0,#6              ;1499
000038  6188              STR      r0,[r1,#0x18]         ;1500
00003a  6963              LDR      r3,[r4,#0x14]         ;1500  ; RMP_Cur_Thd
00003c  f1040c24          ADD      r12,r4,#0x24          ;1500
000040  f8dc1004          LDR      r1,[r12,#4]           ;1500  ; RMP_Delay
000044  4561              CMP      r1,r12                ;1500
000046  d007              BEQ      |L27.88|
                  |L27.72|
000048  6926              LDR      r6,[r4,#0x10]         ;1500  ; RMP_Tick
00004a  6a08              LDR      r0,[r1,#0x20]         ;1500
00004c  1b80              SUBS     r0,r0,r6              ;1500
00004e  42a8              CMP      r0,r5                 ;1500
000050  d802              BHI      |L27.88|
000052  6849              LDR      r1,[r1,#4]            ;1500
000054  4561              CMP      r1,r12                ;1500
000056  d1f7              BNE      |L27.72|
                  |L27.88|
000058  6920              LDR      r0,[r4,#0x10]         ;1500  ; RMP_Tick
00005a  4428              ADD      r0,r0,r5              ;1500
00005c  6298              STR      r0,[r3,#0x28]         ;1500
00005e  680a              LDR      r2,[r1,#0]            ;1500
000060  f1030008          ADD      r0,r3,#8              ;1500
000064  6008              STR      r0,[r1,#0]            ;1500
000066  60d9              STR      r1,[r3,#0xc]          ;1500
000068  609a              STR      r2,[r3,#8]            ;1500
00006a  6050              STR      r0,[r2,#4]            ;1500
00006c  2000              MOVS     r0,#0                 ;1502
00006e  6961              LDR      r1,[r4,#0x14]         ;1502  ; RMP_Cur_Thd
000070  6388              STR      r0,[r1,#0x38]         ;1503
000072  f7fffffe          BL       RMP_Unlock_Sched
000076  6960              LDR      r0,[r4,#0x14]         ;1505  ; RMP_Cur_Thd
000078  6b80              LDR      r0,[r0,#0x38]         ;1505
00007a  bd70              POP      {r4-r6,pc}
;;;1507   /* End Function:RMP_Thd_Delay ************************************************/
                          ENDP

                  |L27.124|
                          DCD      0x000186a0
                  |L27.128|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Rcv||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Rcv PROC
;;;1367   ******************************************************************************/
;;;1368   rmp_ret_t RMP_Thd_Rcv(rmp_ptr_t* Data, rmp_ptr_t Slices)
000000  2800              CMP      r0,#0
;;;1369   {
;;;1370       struct RMP_Thd* Sender;
;;;1371       
;;;1372       if(Data==0)
;;;1373       {
;;;1374           RMP_COVERAGE_MARKER();
;;;1375           return RMP_ERR_OPER;
000002  bf04              ITT      EQ
000004  f06f0004          MVNEQ    r0,#4
;;;1376       }
;;;1377       else
;;;1378           RMP_COVERAGE_MARKER();
;;;1379       
;;;1380       RMP_Lock_Sched();
;;;1381       
;;;1382       /* Is there any other guy waiting on us? If there is, unblock it and set it running */
;;;1383       Sender=0;
;;;1384       if(&(RMP_Cur_Thd->Snd_List)!=RMP_Cur_Thd->Snd_List.Next)
;;;1385       {
;;;1386           RMP_COVERAGE_MARKER();
;;;1387           /* Read the data */
;;;1388           Sender=(struct RMP_Thd*)(RMP_Cur_Thd->Snd_List.Next);
;;;1389           RMP_List_Del(Sender->Run_Head.Prev,Sender->Run_Head.Next);
;;;1390           *Data=Sender->Data;
;;;1391           /* Now we unblock it - what state is it in? */
;;;1392           if((RMP_THD_STATE(Sender->State)==RMP_THD_SNDDLY))
;;;1393           {
;;;1394               RMP_COVERAGE_MARKER();
;;;1395               RMP_List_Del(Sender->Dly_Head.Prev,Sender->Dly_Head.Next);
;;;1396           }
;;;1397           else
;;;1398               RMP_COVERAGE_MARKER();
;;;1399           
;;;1400           RMP_THD_STATE_SET(Sender->State,RMP_THD_RUNNING);
;;;1401           /* Set to running if not suspended */
;;;1402           _RMP_Set_Rdy(Sender);
;;;1403       }
;;;1404   
;;;1405       /* Check if there is a value in our mailbox. If yes, we return with that value */
;;;1406       if((RMP_Cur_Thd->State&RMP_THD_MBOXFUL)!=0)
;;;1407       {
;;;1408           RMP_COVERAGE_MARKER();
;;;1409           /* Get the value from mailbox */
;;;1410           *Data=RMP_Cur_Thd->Mailbox;
;;;1411           /* See if we unblocked a sender. If yes, we place the new value into 
;;;1412            * our mailbox and it is still full */
;;;1413           if(Sender!=0)
;;;1414               RMP_Cur_Thd->Mailbox=Sender->Data;
;;;1415           else
;;;1416               RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
;;;1417           
;;;1418           RMP_Unlock_Sched();
;;;1419           return 0;
;;;1420       }
;;;1421       else
;;;1422       {
;;;1423           RMP_COVERAGE_MARKER();
;;;1424           
;;;1425           /* Box empty. Do we have somebody waiting? */
;;;1426           if(Sender!=0)
;;;1427           {
;;;1428               RMP_COVERAGE_MARKER();
;;;1429               RMP_Cur_Thd->Mailbox=Sender->Data;
;;;1430               RMP_Unlock_Sched();
;;;1431               return 0;
;;;1432           }
;;;1433           /* No sender waiting on us and box empty, we need to block */
;;;1434           else
;;;1435           {
;;;1436               RMP_COVERAGE_MARKER();
;;;1437               
;;;1438               if(Slices==0)
;;;1439               {
;;;1440                   RMP_COVERAGE_MARKER();
;;;1441                   RMP_Unlock_Sched();
;;;1442                   return RMP_ERR_OPER;
;;;1443               }
;;;1444               else
;;;1445                   RMP_COVERAGE_MARKER();
;;;1446   
;;;1447               /* We must be running and not suspended so we will surely be deleted from queue */
;;;1448               _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1449   
;;;1450               if(Slices<RMP_MAX_SLICES)
;;;1451               {
;;;1452                   RMP_COVERAGE_MARKER();
;;;1453                   _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1454                   RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVDLY);
;;;1455               }
;;;1456               else
;;;1457               {
;;;1458                   RMP_COVERAGE_MARKER();
;;;1459                   RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVBLK);
;;;1460               }
;;;1461               RMP_Unlock_Sched();
;;;1462               
;;;1463               /* Dummy read - to separate the lock & unlock. If the compiler optimizes these two
;;;1464                * functions(inline them) on some architectures sometimes we never block. */
;;;1465               *Data=RMP_Cur_Thd->Mailbox;
;;;1466               
;;;1467               /* We've been unblocked. There must be something in our mbox, or we should have failed */
;;;1468               RMP_Lock_Sched();
;;;1469               *Data=RMP_Cur_Thd->Mailbox;
;;;1470               RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
;;;1471           }
;;;1472       }
;;;1473       
;;;1474       RMP_Unlock_Sched();
;;;1475       return RMP_Cur_Thd->Retval;
;;;1476   }
000008  4770              BXEQ     lr
00000a  e92d41f0          PUSH     {r4-r8,lr}            ;1369
00000e  460e              MOV      r6,r1                 ;1369
000010  4607              MOV      r7,r0                 ;1369
000012  20ff              MOVS     r0,#0xff              ;1369
000014  f7fffffe          BL       RMP_Mask_Int
000018  4c4c              LDR      r4,|L28.332|
00001a  2500              MOVS     r5,#0                 ;1383
00001c  f04f0801          MOV      r8,#1                 ;1383
000020  f8c48004          STR      r8,[r4,#4]            ;1383  ; RMP_Sched_Locked
000024  6820              LDR      r0,[r4,#0]            ;1383  ; RMP_Sched_Lock_Cnt
000026  1c40              ADDS     r0,r0,#1              ;1383
000028  6020              STR      r0,[r4,#0]            ;1383  ; RMP_Sched_Lock_Cnt
00002a  6960              LDR      r0,[r4,#0x14]         ;1384  ; RMP_Cur_Thd
00002c  6961              LDR      r1,[r4,#0x14]         ;1384  ; RMP_Cur_Thd
00002e  3110              ADDS     r1,r1,#0x10           ;1384
000030  6940              LDR      r0,[r0,#0x14]         ;1384
000032  4288              CMP      r0,r1                 ;1384
000034  d017              BEQ      |L28.102|
000036  6960              LDR      r0,[r4,#0x14]         ;1388  ; RMP_Cur_Thd
000038  6945              LDR      r5,[r0,#0x14]         ;1388
00003a  e9d50100          LDRD     r0,r1,[r5,#0]         ;1388
00003e  6008              STR      r0,[r1,#0]            ;1388
000040  6041              STR      r1,[r0,#4]            ;1388
000042  6b28              LDR      r0,[r5,#0x30]         ;1390
000044  6038              STR      r0,[r7,#0]            ;1392
000046  7e28              LDRB     r0,[r5,#0x18]         ;1392
000048  2803              CMP      r0,#3                 ;1392
00004a  d103              BNE      |L28.84|
00004c  e9d50102          LDRD     r0,r1,[r5,#8]         ;1392
000050  6008              STR      r0,[r1,#0]            ;1392
000052  6041              STR      r1,[r0,#4]            ;1392
                  |L28.84|
000054  69a8              LDR      r0,[r5,#0x18]         ;1400
000056  f02000ff          BIC      r0,r0,#0xff           ;1400
00005a  f0400001          ORR      r0,r0,#1              ;1400
00005e  61a8              STR      r0,[r5,#0x18]         ;1402
000060  4628              MOV      r0,r5                 ;1402
000062  f7fffffe          BL       _RMP_Set_Rdy
                  |L28.102|
000066  6960              LDR      r0,[r4,#0x14]         ;1406  ; RMP_Cur_Thd
000068  8b00              LDRH     r0,[r0,#0x18]         ;1406
00006a  f4107f00          TST      r0,#0x200             ;1406
00006e  d011              BEQ      |L28.148|
000070  6960              LDR      r0,[r4,#0x14]         ;1410  ; RMP_Cur_Thd
000072  2d00              CMP      r5,#0                 ;1413
000074  6ac0              LDR      r0,[r0,#0x2c]         ;1410
000076  6038              STR      r0,[r7,#0]            ;1416
000078  6960              LDR      r0,[r4,#0x14]         ;1416  ; RMP_Cur_Thd
00007a  bf03              ITTTE    EQ                    ;1416
00007c  6981              LDREQ    r1,[r0,#0x18]         ;1416
00007e  f4217100          BICEQ    r1,r1,#0x200          ;1416
000082  6181              STREQ    r1,[r0,#0x18]         ;1416
000084  6b29              LDRNE    r1,[r5,#0x30]         ;1414
000086  bf18              IT       NE                    ;1414
000088  62c1              STRNE    r1,[r0,#0x2c]         ;1414
00008a  f7fffffe          BL       RMP_Unlock_Sched
00008e  2000              MOVS     r0,#0                 ;1419
000090  e8bd81f0          POP      {r4-r8,pc}
                  |L28.148|
000094  b13d              CBZ      r5,|L28.166|
000096  6960              LDR      r0,[r4,#0x14]         ;1429  ; RMP_Cur_Thd
000098  6b29              LDR      r1,[r5,#0x30]         ;1429
00009a  62c1              STR      r1,[r0,#0x2c]         ;1430
00009c  f7fffffe          BL       RMP_Unlock_Sched
0000a0  2000              MOVS     r0,#0                 ;1431
0000a2  e8bd81f0          POP      {r4-r8,pc}
                  |L28.166|
0000a6  b346              CBZ      r6,|L28.250|
0000a8  6960              LDR      r0,[r4,#0x14]         ;1448  ; RMP_Cur_Thd
0000aa  f7fffffe          BL       _RMP_Clr_Rdy
0000ae  4828              LDR      r0,|L28.336|
0000b0  4286              CMP      r6,r0                 ;1450
0000b2  d228              BCS      |L28.262|
0000b4  6963              LDR      r3,[r4,#0x14]         ;1453  ; RMP_Cur_Thd
0000b6  4a27              LDR      r2,|L28.340|
0000b8  6850              LDR      r0,[r2,#4]            ;1453  ; RMP_Delay
0000ba  4290              CMP      r0,r2                 ;1453
0000bc  d00a              BEQ      |L28.212|
0000be  bf00              NOP                            ;1453
                  |L28.192|
0000c0  f8d4c010          LDR      r12,[r4,#0x10]        ;1453  ; RMP_Tick
0000c4  6a01              LDR      r1,[r0,#0x20]         ;1453
0000c6  eba1010c          SUB      r1,r1,r12             ;1453
0000ca  42b1              CMP      r1,r6                 ;1453
0000cc  d802              BHI      |L28.212|
0000ce  6840              LDR      r0,[r0,#4]            ;1453
0000d0  4290              CMP      r0,r2                 ;1453
0000d2  d1f5              BNE      |L28.192|
                  |L28.212|
0000d4  6921              LDR      r1,[r4,#0x10]         ;1453  ; RMP_Tick
0000d6  4431              ADD      r1,r1,r6              ;1453
0000d8  6299              STR      r1,[r3,#0x28]         ;1453
0000da  6802              LDR      r2,[r0,#0]            ;1453
0000dc  f1030108          ADD      r1,r3,#8              ;1453
0000e0  6001              STR      r1,[r0,#0]            ;1453
0000e2  60d8              STR      r0,[r3,#0xc]          ;1453
0000e4  609a              STR      r2,[r3,#8]            ;1453
0000e6  6051              STR      r1,[r2,#4]            ;1453
0000e8  6960              LDR      r0,[r4,#0x14]         ;1454  ; RMP_Cur_Thd
0000ea  6961              LDR      r1,[r4,#0x14]         ;1454  ; RMP_Cur_Thd
0000ec  6980              LDR      r0,[r0,#0x18]         ;1454
0000ee  f02000ff          BIC      r0,r0,#0xff           ;1454
0000f2  f0400005          ORR      r0,r0,#5              ;1454
0000f6  6188              STR      r0,[r1,#0x18]         ;1454
0000f8  e00d              B        |L28.278|
                  |L28.250|
0000fa  f7fffffe          BL       RMP_Unlock_Sched
0000fe  f06f0004          MVN      r0,#4                 ;1442
000102  e8bd81f0          POP      {r4-r8,pc}
                  |L28.262|
000106  6961              LDR      r1,[r4,#0x14]         ;1459  ; RMP_Cur_Thd
000108  6960              LDR      r0,[r4,#0x14]         ;1459  ; RMP_Cur_Thd
00010a  6989              LDR      r1,[r1,#0x18]         ;1459
00010c  f02101ff          BIC      r1,r1,#0xff           ;1459
000110  f0410104          ORR      r1,r1,#4              ;1459
000114  6181              STR      r1,[r0,#0x18]         ;1459
                  |L28.278|
000116  f7fffffe          BL       RMP_Unlock_Sched
00011a  6960              LDR      r0,[r4,#0x14]         ;1465  ; RMP_Cur_Thd
00011c  6ac0              LDR      r0,[r0,#0x2c]         ;1465
00011e  6038              STR      r0,[r7,#0]            ;1465
000120  20ff              MOVS     r0,#0xff              ;1465
000122  f7fffffe          BL       RMP_Mask_Int
000126  f8c48004          STR      r8,[r4,#4]            ;1465  ; RMP_Sched_Locked
00012a  6820              LDR      r0,[r4,#0]            ;1465  ; RMP_Sched_Lock_Cnt
00012c  1c40              ADDS     r0,r0,#1              ;1465
00012e  6020              STR      r0,[r4,#0]            ;1465  ; RMP_Sched_Lock_Cnt
000130  6960              LDR      r0,[r4,#0x14]         ;1469  ; RMP_Cur_Thd
000132  6ac0              LDR      r0,[r0,#0x2c]         ;1469
000134  6038              STR      r0,[r7,#0]            ;1470
000136  6960              LDR      r0,[r4,#0x14]         ;1470  ; RMP_Cur_Thd
000138  6981              LDR      r1,[r0,#0x18]         ;1470
00013a  f4217100          BIC      r1,r1,#0x200          ;1470
00013e  6181              STR      r1,[r0,#0x18]         ;1474
000140  f7fffffe          BL       RMP_Unlock_Sched
000144  6960              LDR      r0,[r4,#0x14]         ;1475  ; RMP_Cur_Thd
000146  6b80              LDR      r0,[r0,#0x38]         ;1475
000148  e8bd81f0          POP      {r4-r8,pc}
;;;1477   /* End Function:RMP_Thd_Rcv **************************************************/
                          ENDP

                  |L28.332|
                          DCD      ||.data||
                  |L28.336|
                          DCD      0x000186a0
                  |L28.340|
                          DCD      ||.data||+0x24

                          AREA ||i.RMP_Thd_Resume||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Resume PROC
;;;1111   ******************************************************************************/
;;;1112   rmp_ret_t RMP_Thd_Resume(volatile struct RMP_Thd* Thread)
000000  2800              CMP      r0,#0
;;;1113   {
;;;1114       rmp_ret_t Retval;
;;;1115       
;;;1116       /* Check if this thread structure could possibly be in use */
;;;1117       if(Thread==0)
;;;1118       {
;;;1119           RMP_COVERAGE_MARKER();
;;;1120           return RMP_ERR_THD;
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;1121       }
;;;1122       else
;;;1123           RMP_COVERAGE_MARKER();
;;;1124   
;;;1125       RMP_Lock_Sched();
;;;1126       
;;;1127       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;1128       {
;;;1129           RMP_COVERAGE_MARKER();
;;;1130           RMP_Unlock_Sched();
;;;1131           return RMP_ERR_THD;
;;;1132       }
;;;1133       else
;;;1134           RMP_COVERAGE_MARKER();
;;;1135       
;;;1136       /* Check if the thread is suspended, if not, then throw an error */
;;;1137       if((Thread->State&RMP_THD_SUSPENDED)!=0)
;;;1138       {
;;;1139           RMP_COVERAGE_MARKER();
;;;1140           
;;;1141           /* Suspended */
;;;1142           Thread->State&=~RMP_THD_SUSPENDED;
;;;1143           /* Only when it is running will we put it back. It can't be suspended here, 
;;;1144            * so the set ready operation will surely put it back */
;;;1145           if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;1146           {
;;;1147               RMP_COVERAGE_MARKER();
;;;1148               _RMP_Set_Rdy(Thread);
;;;1149           }
;;;1150           else
;;;1151               RMP_COVERAGE_MARKER();
;;;1152           
;;;1153           Retval=0;
;;;1154       }
;;;1155       else
;;;1156       {
;;;1157           RMP_COVERAGE_MARKER();
;;;1158           Retval=RMP_ERR_STATE;
;;;1159       }
;;;1160       
;;;1161       RMP_Unlock_Sched();
;;;1162   
;;;1163       return Retval;
;;;1164   }
000008  4770              BXEQ     lr
00000a  b510              PUSH     {r4,lr}               ;1113
00000c  4604              MOV      r4,r0                 ;1113
00000e  20ff              MOVS     r0,#0xff              ;1113
000010  f7fffffe          BL       RMP_Mask_Int
000014  4812              LDR      r0,|L29.96|
000016  2101              MOVS     r1,#1                 ;1113
000018  6041              STR      r1,[r0,#4]            ;1113  ; RMP_Sched_Locked
00001a  6801              LDR      r1,[r0,#0]            ;1113  ; RMP_Sched_Lock_Cnt
00001c  1c49              ADDS     r1,r1,#1              ;1113
00001e  6001              STR      r1,[r0,#0]            ;1113  ; RMP_Sched_Lock_Cnt
000020  69a0              LDR      r0,[r4,#0x18]         ;1127
000022  f0100fff          TST      r0,#0xff              ;1127
000026  d016              BEQ      |L29.86|
000028  69a0              LDR      r0,[r4,#0x18]         ;1137
00002a  f4107f80          TST      r0,#0x100             ;1137
00002e  bf08              IT       EQ                    ;1158
000030  f06f0403          MVNEQ    r4,#3                 ;1158
000034  d00b              BEQ      |L29.78|
000036  69a0              LDR      r0,[r4,#0x18]         ;1142
000038  f4207080          BIC      r0,r0,#0x100          ;1142
00003c  61a0              STR      r0,[r4,#0x18]         ;1142
00003e  69a0              LDR      r0,[r4,#0x18]         ;1145
000040  b2c0              UXTB     r0,r0                 ;1145
000042  2801              CMP      r0,#1                 ;1145
000044  bf04              ITT      EQ                    ;1148
000046  4620              MOVEQ    r0,r4                 ;1148
000048  f7fffffe          BLEQ     _RMP_Set_Rdy
00004c  2400              MOVS     r4,#0                 ;1153
                  |L29.78|
00004e  f7fffffe          BL       RMP_Unlock_Sched
000052  4620              MOV      r0,r4                 ;1163
000054  bd10              POP      {r4,pc}
                  |L29.86|
000056  f7fffffe          BL       RMP_Unlock_Sched
00005a  f04f30ff          MOV      r0,#0xffffffff        ;1131
00005e  bd10              POP      {r4,pc}
;;;1165   /* End Function:RMP_Thd_Resume ***********************************************/
                          ENDP

                  |L29.96|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Set||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Set PROC
;;;951    ******************************************************************************/
;;;952    rmp_ret_t RMP_Thd_Set(volatile struct RMP_Thd* Thread, rmp_ptr_t Prio, rmp_ptr_t Slices)
000000  2a00              CMP      r2,#0
;;;953    {
;;;954        /* Check if the priority and timeslice range is correct */
;;;955        if(Slices==0)
;;;956        {
;;;957            RMP_COVERAGE_MARKER();
;;;958            return RMP_ERR_SLICE;
000002  bf04              ITT      EQ
000004  f06f0002          MVNEQ    r0,#2
;;;959        }
;;;960        else
;;;961            RMP_COVERAGE_MARKER();
;;;962        
;;;963        /* Check if this thread structure could possibly be in use */
;;;964        if(Thread==0)
;;;965        {
;;;966            RMP_COVERAGE_MARKER();
;;;967            return RMP_ERR_THD;
;;;968        }
;;;969        else
;;;970            RMP_COVERAGE_MARKER();
;;;971        
;;;972        RMP_Lock_Sched();
;;;973        
;;;974        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;975        {
;;;976            RMP_COVERAGE_MARKER();
;;;977            RMP_Unlock_Sched();
;;;978            return RMP_ERR_THD;
;;;979        }
;;;980        else
;;;981            RMP_COVERAGE_MARKER();
;;;982        
;;;983        /* See if the thread is in running state */
;;;984        if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;985        {
;;;986            RMP_COVERAGE_MARKER();
;;;987            
;;;988            /* See if we are gonna change one of it or both */
;;;989            if(Prio<RMP_MAX_PREEMPT_PRIO)
;;;990            {
;;;991                RMP_COVERAGE_MARKER();
;;;992                if(Thread->Prio!=Prio)
;;;993                {
;;;994                    RMP_COVERAGE_MARKER();
;;;995                    /* It doesn't matter whether this is suspended or not. 
;;;996                     * If suspended, the operations will not be conducted. */
;;;997                    _RMP_Clr_Rdy(Thread);
;;;998                    Thread->Prio=Prio;
;;;999                    _RMP_Set_Rdy(Thread);
;;;1000               }
;;;1001               else
;;;1002                   RMP_COVERAGE_MARKER();
;;;1003           }
;;;1004           else
;;;1005               RMP_COVERAGE_MARKER();
;;;1006           
;;;1007           if(Slices<RMP_MAX_SLICES)
;;;1008           {
;;;1009               RMP_COVERAGE_MARKER();
;;;1010               Thread->Slices=Slices;
;;;1011           }
;;;1012           else
;;;1013               RMP_COVERAGE_MARKER();
;;;1014       }
;;;1015       else
;;;1016       {
;;;1017           RMP_COVERAGE_MARKER();
;;;1018           
;;;1019           if(Prio<RMP_MAX_PREEMPT_PRIO)
;;;1020           {
;;;1021               RMP_COVERAGE_MARKER();
;;;1022               Thread->Prio=Prio;
;;;1023           }
;;;1024           else
;;;1025               RMP_COVERAGE_MARKER();
;;;1026           
;;;1027           if(Slices<RMP_MAX_SLICES)
;;;1028           {
;;;1029               RMP_COVERAGE_MARKER();
;;;1030               Thread->Slices=Slices;
;;;1031           }
;;;1032           else
;;;1033               RMP_COVERAGE_MARKER();
;;;1034       }
;;;1035       
;;;1036       RMP_Unlock_Sched();
;;;1037       return 0;
;;;1038   }
000008  4770              BXEQ     lr
00000a  2800              CMP      r0,#0                 ;964
00000c  bf04              ITT      EQ                    ;967
00000e  f04f30ff          MOVEQ    r0,#0xffffffff        ;967
000012  4770              BXEQ     lr
000014  e92d41f0          PUSH     {r4-r8,lr}            ;953
000018  4615              MOV      r5,r2                 ;953
00001a  460e              MOV      r6,r1                 ;953
00001c  4604              MOV      r4,r0                 ;953
00001e  20ff              MOVS     r0,#0xff              ;953
000020  f7fffffe          BL       RMP_Mask_Int
000024  4817              LDR      r0,|L30.132|
000026  2101              MOVS     r1,#1                 ;953
000028  6041              STR      r1,[r0,#4]            ;953  ; RMP_Sched_Locked
00002a  6801              LDR      r1,[r0,#0]            ;953  ; RMP_Sched_Lock_Cnt
00002c  1c49              ADDS     r1,r1,#1              ;953
00002e  6001              STR      r1,[r0,#0]            ;953  ; RMP_Sched_Lock_Cnt
000030  69a0              LDR      r0,[r4,#0x18]         ;974
000032  f0100fff          TST      r0,#0xff              ;974
000036  d00f              BEQ      |L30.88|
000038  69a0              LDR      r0,[r4,#0x18]         ;984
00003a  4f13              LDR      r7,|L30.136|
00003c  b2c0              UXTB     r0,r0                 ;984
00003e  2801              CMP      r0,#1                 ;984
000040  d010              BEQ      |L30.100|
000042  2e40              CMP      r6,#0x40              ;1019
000044  bf38              IT       CC                    ;1022
000046  6266              STRCC    r6,[r4,#0x24]         ;1022
000048  42bd              CMP      r5,r7                 ;1027
00004a  d200              BCS      |L30.78|
                  |L30.76|
00004c  61e5              STR      r5,[r4,#0x1c]         ;1030
                  |L30.78|
00004e  f7fffffe          BL       RMP_Unlock_Sched
000052  2000              MOVS     r0,#0                 ;1037
000054  e8bd81f0          POP      {r4-r8,pc}
                  |L30.88|
000058  f7fffffe          BL       RMP_Unlock_Sched
00005c  f04f30ff          MOV      r0,#0xffffffff        ;978
000060  e8bd81f0          POP      {r4-r8,pc}
                  |L30.100|
000064  2e40              CMP      r6,#0x40              ;989
000066  d209              BCS      |L30.124|
000068  6a60              LDR      r0,[r4,#0x24]         ;992
00006a  42b0              CMP      r0,r6                 ;992
00006c  d006              BEQ      |L30.124|
00006e  4620              MOV      r0,r4                 ;997
000070  f7fffffe          BL       _RMP_Clr_Rdy
000074  6266              STR      r6,[r4,#0x24]         ;998
000076  4620              MOV      r0,r4                 ;999
000078  f7fffffe          BL       _RMP_Set_Rdy
                  |L30.124|
00007c  42bd              CMP      r5,r7                 ;1007
00007e  d2e6              BCS      |L30.78|
000080  e7e4              B        |L30.76|
;;;1039   /* End Function:RMP_Thd_Set **************************************************/
                          ENDP

000082  0000              DCW      0x0000
                  |L30.132|
                          DCD      ||.data||
                  |L30.136|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Snd||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Snd PROC
;;;1175   ******************************************************************************/
;;;1176   rmp_ret_t RMP_Thd_Snd(volatile struct RMP_Thd* Thread, rmp_ptr_t Data, rmp_ptr_t Slices)
000000  2800              CMP      r0,#0
;;;1177   {
;;;1178       /* Check if this thread structure could possibly be in use */
;;;1179       if(Thread==0)
;;;1180       {
;;;1181           RMP_COVERAGE_MARKER();
;;;1182           return RMP_ERR_THD;
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;1183       }
;;;1184       else
;;;1185           RMP_COVERAGE_MARKER();
;;;1186       
;;;1187       RMP_Lock_Sched();
;;;1188       
;;;1189       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;1190       {
;;;1191           RMP_COVERAGE_MARKER();
;;;1192           RMP_Unlock_Sched();
;;;1193           return RMP_ERR_THD;
;;;1194       }
;;;1195       else
;;;1196           RMP_COVERAGE_MARKER();
;;;1197       
;;;1198       /* Are we sending to ourself? This is not allowed */
;;;1199       if(RMP_Cur_Thd==Thread)
;;;1200       {
;;;1201           RMP_COVERAGE_MARKER();
;;;1202           RMP_Unlock_Sched();
;;;1203           return RMP_ERR_OPER;
;;;1204       }
;;;1205       else
;;;1206           RMP_COVERAGE_MARKER();
;;;1207       
;;;1208       RMP_Cur_Thd->Retval=0;
;;;1209   
;;;1210       /* See if there is already a value in the mailbox, if yes, we block */
;;;1211       if((Thread->State&RMP_THD_MBOXFUL)!=0)
;;;1212       {
;;;1213           RMP_COVERAGE_MARKER();
;;;1214           
;;;1215           /* Mailbox full, we block, and put ourself into the queue */
;;;1216           if(Slices==0)
;;;1217           {
;;;1218               RMP_COVERAGE_MARKER();
;;;1219               RMP_Unlock_Sched();
;;;1220               return RMP_ERR_OPER;
;;;1221           }
;;;1222           else
;;;1223               RMP_COVERAGE_MARKER();
;;;1224   
;;;1225           /* We must be running */
;;;1226           _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1227           RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Thread->Snd_List.Prev,&(Thread->Snd_List));
;;;1228   
;;;1229           if(Slices<RMP_MAX_SLICES)
;;;1230           {
;;;1231               RMP_COVERAGE_MARKER();
;;;1232               _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1233               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDDLY);
;;;1234           }
;;;1235           else
;;;1236           {
;;;1237               RMP_COVERAGE_MARKER();
;;;1238               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDBLK);
;;;1239           }
;;;1240   
;;;1241           RMP_Cur_Thd->Data=Data;
;;;1242       }
;;;1243       else
;;;1244       {
;;;1245           RMP_COVERAGE_MARKER();
;;;1246           
;;;1247           /* Mailbox not full. We need to check if the receiver is waiting for us */
;;;1248           if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
;;;1249              (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
;;;1250           {
;;;1251               RMP_COVERAGE_MARKER();
;;;1252               
;;;1253               /* The receiver is blocked, wake it up and return the value */
;;;1254               if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
;;;1255               {
;;;1256                   RMP_COVERAGE_MARKER();
;;;1257                   RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1258               }
;;;1259               else
;;;1260                   RMP_COVERAGE_MARKER();
;;;1261               
;;;1262               RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1263               /* Set to running if not suspended */
;;;1264               _RMP_Set_Rdy(Thread);
;;;1265           }
;;;1266           else
;;;1267               RMP_COVERAGE_MARKER();
;;;1268           
;;;1269           /* Set the mailbox */
;;;1270           Thread->Mailbox=Data;
;;;1271           Thread->State|=RMP_THD_MBOXFUL;
;;;1272       }
;;;1273       
;;;1274       RMP_Unlock_Sched();
;;;1275   
;;;1276       return RMP_Cur_Thd->Retval;
;;;1277   }
000008  4770              BXEQ     lr
00000a  e92d41f0          PUSH     {r4-r8,lr}            ;1177
00000e  4616              MOV      r6,r2                 ;1177
000010  460f              MOV      r7,r1                 ;1177
000012  4605              MOV      r5,r0                 ;1177
000014  20ff              MOVS     r0,#0xff              ;1177
000016  f7fffffe          BL       RMP_Mask_Int
00001a  4c41              LDR      r4,|L31.288|
00001c  2001              MOVS     r0,#1                 ;1177
00001e  6060              STR      r0,[r4,#4]            ;1177  ; RMP_Sched_Locked
000020  6820              LDR      r0,[r4,#0]            ;1177  ; RMP_Sched_Lock_Cnt
000022  1c40              ADDS     r0,r0,#1              ;1177
000024  6020              STR      r0,[r4,#0]            ;1177  ; RMP_Sched_Lock_Cnt
000026  69a8              LDR      r0,[r5,#0x18]         ;1189
000028  f0100fff          TST      r0,#0xff              ;1189
00002c  d040              BEQ      |L31.176|
00002e  6960              LDR      r0,[r4,#0x14]         ;1199  ; RMP_Cur_Thd
000030  42a8              CMP      r0,r5                 ;1199
000032  d043              BEQ      |L31.188|
000034  6961              LDR      r1,[r4,#0x14]         ;1208  ; RMP_Cur_Thd
000036  2000              MOVS     r0,#0                 ;1208
000038  6388              STR      r0,[r1,#0x38]         ;1211
00003a  69a8              LDR      r0,[r5,#0x18]         ;1211
00003c  f4107f00          TST      r0,#0x200             ;1211
000040  d04a              BEQ      |L31.216|
000042  2e00              CMP      r6,#0                 ;1216
000044  d03a              BEQ      |L31.188|
000046  6960              LDR      r0,[r4,#0x14]         ;1226  ; RMP_Cur_Thd
000048  f7fffffe          BL       _RMP_Clr_Rdy
00004c  6960              LDR      r0,[r4,#0x14]         ;1227  ; RMP_Cur_Thd
00004e  6929              LDR      r1,[r5,#0x10]         ;1227
000050  f1050210          ADD      r2,r5,#0x10           ;1227
000054  6128              STR      r0,[r5,#0x10]         ;1227
000056  6042              STR      r2,[r0,#4]            ;1227
000058  6001              STR      r1,[r0,#0]            ;1227
00005a  6048              STR      r0,[r1,#4]            ;1227
00005c  4831              LDR      r0,|L31.292|
00005e  4286              CMP      r6,r0                 ;1229
000060  d232              BCS      |L31.200|
000062  f8d4c014          LDR      r12,[r4,#0x14]        ;1232  ; RMP_Cur_Thd
000066  f1040224          ADD      r2,r4,#0x24           ;1232
00006a  6850              LDR      r0,[r2,#4]            ;1232  ; RMP_Delay
00006c  4290              CMP      r0,r2                 ;1232
00006e  d007              BEQ      |L31.128|
                  |L31.112|
000070  6921              LDR      r1,[r4,#0x10]         ;1232  ; RMP_Tick
000072  6a03              LDR      r3,[r0,#0x20]         ;1232
000074  1a59              SUBS     r1,r3,r1              ;1232
000076  42b1              CMP      r1,r6                 ;1232
000078  d802              BHI      |L31.128|
00007a  6840              LDR      r0,[r0,#4]            ;1232
00007c  4290              CMP      r0,r2                 ;1232
00007e  d1f7              BNE      |L31.112|
                  |L31.128|
000080  6921              LDR      r1,[r4,#0x10]         ;1232  ; RMP_Tick
000082  4431              ADD      r1,r1,r6              ;1232
000084  f8cc1028          STR      r1,[r12,#0x28]        ;1232
000088  6802              LDR      r2,[r0,#0]            ;1232
00008a  f10c0108          ADD      r1,r12,#8             ;1232
00008e  6001              STR      r1,[r0,#0]            ;1232
000090  f8cc000c          STR      r0,[r12,#0xc]         ;1232
000094  f8cc2008          STR      r2,[r12,#8]           ;1232
000098  6051              STR      r1,[r2,#4]            ;1232
00009a  6960              LDR      r0,[r4,#0x14]         ;1233  ; RMP_Cur_Thd
00009c  6961              LDR      r1,[r4,#0x14]         ;1233  ; RMP_Cur_Thd
00009e  6980              LDR      r0,[r0,#0x18]         ;1233
0000a0  f02000ff          BIC      r0,r0,#0xff           ;1233
0000a4  f0400003          ORR      r0,r0,#3              ;1233
                  |L31.168|
0000a8  6188              STR      r0,[r1,#0x18]         ;1241
0000aa  6960              LDR      r0,[r4,#0x14]         ;1241  ; RMP_Cur_Thd
0000ac  6307              STR      r7,[r0,#0x30]         ;1241
0000ae  e031              B        |L31.276|
                  |L31.176|
0000b0  f7fffffe          BL       RMP_Unlock_Sched
0000b4  f04f30ff          MOV      r0,#0xffffffff        ;1193
0000b8  e8bd81f0          POP      {r4-r8,pc}
                  |L31.188|
0000bc  f7fffffe          BL       RMP_Unlock_Sched
0000c0  f06f0004          MVN      r0,#4                 ;1220
0000c4  e8bd81f0          POP      {r4-r8,pc}
                  |L31.200|
0000c8  6960              LDR      r0,[r4,#0x14]         ;1238  ; RMP_Cur_Thd
0000ca  6961              LDR      r1,[r4,#0x14]         ;1238  ; RMP_Cur_Thd
0000cc  6980              LDR      r0,[r0,#0x18]         ;1238
0000ce  f02000ff          BIC      r0,r0,#0xff           ;1238
0000d2  f0400002          ORR      r0,r0,#2              ;1238
0000d6  e7e7              B        |L31.168|
                  |L31.216|
0000d8  69a8              LDR      r0,[r5,#0x18]         ;1248
0000da  b2c0              UXTB     r0,r0                 ;1248
0000dc  2804              CMP      r0,#4                 ;1248
0000de  d003              BEQ      |L31.232|
0000e0  69a8              LDR      r0,[r5,#0x18]         ;1248
0000e2  b2c0              UXTB     r0,r0                 ;1248
0000e4  2805              CMP      r0,#5                 ;1248
0000e6  d110              BNE      |L31.266|
                  |L31.232|
0000e8  69a8              LDR      r0,[r5,#0x18]         ;1254
0000ea  b2c0              UXTB     r0,r0                 ;1254
0000ec  2805              CMP      r0,#5                 ;1254
0000ee  d103              BNE      |L31.248|
0000f0  68a9              LDR      r1,[r5,#8]            ;1257
0000f2  68e8              LDR      r0,[r5,#0xc]          ;1257
0000f4  6001              STR      r1,[r0,#0]            ;1257
0000f6  6048              STR      r0,[r1,#4]            ;1257
                  |L31.248|
0000f8  69a8              LDR      r0,[r5,#0x18]         ;1262
0000fa  f02000ff          BIC      r0,r0,#0xff           ;1262
0000fe  f0400001          ORR      r0,r0,#1              ;1262
000102  61a8              STR      r0,[r5,#0x18]         ;1262
000104  4628              MOV      r0,r5                 ;1264
000106  f7fffffe          BL       _RMP_Set_Rdy
                  |L31.266|
00010a  62ef              STR      r7,[r5,#0x2c]         ;1270
00010c  69a8              LDR      r0,[r5,#0x18]         ;1271
00010e  f4407000          ORR      r0,r0,#0x200          ;1271
000112  61a8              STR      r0,[r5,#0x18]         ;1271
                  |L31.276|
000114  f7fffffe          BL       RMP_Unlock_Sched
000118  6960              LDR      r0,[r4,#0x14]         ;1276  ; RMP_Cur_Thd
00011a  6b80              LDR      r0,[r0,#0x38]         ;1276
00011c  e8bd81f0          POP      {r4-r8,pc}
;;;1278   /* End Function:RMP_Thd_Snd **************************************************/
                          ENDP

                  |L31.288|
                          DCD      ||.data||
                  |L31.292|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Snd_ISR||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Snd_ISR PROC
;;;1290   ******************************************************************************/
;;;1291   rmp_ret_t RMP_Thd_Snd_ISR(volatile struct RMP_Thd* Thread, rmp_ptr_t Data)
000000  2800              CMP      r0,#0
;;;1292   {
;;;1293       /* Check if this thread structure could possibly be in use */
;;;1294       if(Thread==0)
;;;1295       {
;;;1296           RMP_COVERAGE_MARKER();
;;;1297           return RMP_ERR_THD;
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;1298       }
;;;1299       else
;;;1300           RMP_COVERAGE_MARKER();
;;;1301       
;;;1302       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;1303       {
;;;1304           RMP_COVERAGE_MARKER();
;;;1305           return RMP_ERR_THD;
;;;1306       }
;;;1307       else
;;;1308           RMP_COVERAGE_MARKER();
;;;1309   
;;;1310       /* See if there is already a value in the mailbox, if yes, we abort */
;;;1311       if((Thread->State&RMP_THD_MBOXFUL)!=0)
;;;1312       {
;;;1313           RMP_COVERAGE_MARKER();
;;;1314           return RMP_ERR_OPER;
;;;1315       }
;;;1316       else
;;;1317       {
;;;1318           RMP_COVERAGE_MARKER();
;;;1319           
;;;1320           /* Mailbox not full. We need to check if the receiver is waiting for us */
;;;1321           if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
;;;1322              (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
;;;1323           {
;;;1324               RMP_COVERAGE_MARKER();
;;;1325   
;;;1326               /* The receiver is blocked, wake it up and return the value */
;;;1327               if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
;;;1328               {
;;;1329                   RMP_COVERAGE_MARKER();
;;;1330                   RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1331               }
;;;1332               else
;;;1333                   RMP_COVERAGE_MARKER();
;;;1334               
;;;1335               RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1336   
;;;1337               /* Set to running if not suspended */
;;;1338               _RMP_Set_Rdy(Thread);
;;;1339   
;;;1340               /* If schedule pending, trigger it now because we are in ISR */
;;;1341               if(RMP_Sched_Pend!=0)
;;;1342               {
;;;1343                   RMP_COVERAGE_MARKER();
;;;1344                   RMP_Sched_Pend=0;
;;;1345                   _RMP_Yield();
;;;1346               }
;;;1347               else
;;;1348                   RMP_COVERAGE_MARKER();
;;;1349           }
;;;1350           else
;;;1351               RMP_COVERAGE_MARKER();
;;;1352           
;;;1353           /* Set the mailbox */
;;;1354           Thread->Mailbox=Data;
;;;1355           Thread->State|=RMP_THD_MBOXFUL;
;;;1356       }
;;;1357   
;;;1358       return 0;
;;;1359   }
000008  4770              BXEQ     lr
00000a  b570              PUSH     {r4-r6,lr}            ;1292
00000c  4604              MOV      r4,r0                 ;1292
00000e  6980              LDR      r0,[r0,#0x18]         ;1302
000010  460d              MOV      r5,r1                 ;1292
000012  f0100fff          TST      r0,#0xff              ;1302
000016  bf04              ITT      EQ                    ;1305
000018  f04f30ff          MOVEQ    r0,#0xffffffff        ;1305
00001c  bd70              POPEQ    {r4-r6,pc}
00001e  69a0              LDR      r0,[r4,#0x18]         ;1311
000020  f4107f00          TST      r0,#0x200             ;1311
000024  bf1c              ITT      NE                    ;1314
000026  f06f0004          MVNNE    r0,#4                 ;1314
00002a  bd70              POPNE    {r4-r6,pc}
00002c  69a0              LDR      r0,[r4,#0x18]         ;1321
00002e  b2c0              UXTB     r0,r0                 ;1321
000030  2804              CMP      r0,#4                 ;1321
000032  d003              BEQ      |L32.60|
000034  69a0              LDR      r0,[r4,#0x18]         ;1321
000036  b2c0              UXTB     r0,r0                 ;1321
000038  2805              CMP      r0,#5                 ;1321
00003a  d117              BNE      |L32.108|
                  |L32.60|
00003c  69a0              LDR      r0,[r4,#0x18]         ;1327
00003e  b2c0              UXTB     r0,r0                 ;1327
000040  2805              CMP      r0,#5                 ;1327
000042  d103              BNE      |L32.76|
000044  68a0              LDR      r0,[r4,#8]            ;1330
000046  68e2              LDR      r2,[r4,#0xc]          ;1330
000048  6010              STR      r0,[r2,#0]            ;1330
00004a  6042              STR      r2,[r0,#4]            ;1330
                  |L32.76|
00004c  69a0              LDR      r0,[r4,#0x18]         ;1335
00004e  f02000ff          BIC      r0,r0,#0xff           ;1335
000052  f0400001          ORR      r0,r0,#1              ;1335
000056  61a0              STR      r0,[r4,#0x18]         ;1335
000058  4620              MOV      r0,r4                 ;1338
00005a  f7fffffe          BL       _RMP_Set_Rdy
00005e  4807              LDR      r0,|L32.124|
000060  6881              LDR      r1,[r0,#8]            ;1341  ; RMP_Sched_Pend
000062  b119              CBZ      r1,|L32.108|
000064  2100              MOVS     r1,#0                 ;1344
000066  6081              STR      r1,[r0,#8]            ;1344  ; RMP_Sched_Pend
000068  f7fffffe          BL       _RMP_Yield
                  |L32.108|
00006c  62e5              STR      r5,[r4,#0x2c]         ;1354
00006e  69a0              LDR      r0,[r4,#0x18]         ;1355
000070  f4407000          ORR      r0,r0,#0x200          ;1355
000074  61a0              STR      r0,[r4,#0x18]         ;1355
000076  2000              MOVS     r0,#0                 ;1358
000078  bd70              POP      {r4-r6,pc}
;;;1360   /* End Function:RMP_Thd_Snd_ISR **********************************************/
                          ENDP

00007a  0000              DCW      0x0000
                  |L32.124|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Suspend||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Suspend PROC
;;;1046   ******************************************************************************/
;;;1047   rmp_ret_t RMP_Thd_Suspend(volatile struct RMP_Thd* Thread)
000000  2800              CMP      r0,#0
;;;1048   {
;;;1049       /* Check if this thread structure could possibly be in use */
;;;1050       if(Thread==0)
;;;1051       {
;;;1052           RMP_COVERAGE_MARKER();
;;;1053           return RMP_ERR_THD;
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;1054       }
;;;1055       else
;;;1056           RMP_COVERAGE_MARKER();
;;;1057       
;;;1058       RMP_Lock_Sched();
;;;1059       
;;;1060       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;1061       {
;;;1062           RMP_COVERAGE_MARKER();
;;;1063           RMP_Unlock_Sched();
;;;1064           return RMP_ERR_THD;
;;;1065       }
;;;1066       else
;;;1067           RMP_COVERAGE_MARKER();
;;;1068       
;;;1069       /* Suspend it */
;;;1070       if((Thread->State&RMP_THD_SUSPENDED)!=0)
;;;1071       {
;;;1072           RMP_COVERAGE_MARKER();
;;;1073           RMP_Unlock_Sched();
;;;1074           return RMP_ERR_STATE;
;;;1075       }
;;;1076       else
;;;1077           RMP_COVERAGE_MARKER();
;;;1078       
;;;1079       /* Only when it is running do we clear this. If we are clearing this, it is not
;;;1080        * suspended, so trhe running queue removal is guaranteed to succceed */
;;;1081       if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;1082       {
;;;1083           RMP_COVERAGE_MARKER();
;;;1084           _RMP_Clr_Rdy(Thread);
;;;1085       }
;;;1086       else
;;;1087           RMP_COVERAGE_MARKER();
;;;1088       
;;;1089       /* Mark this as suspended */
;;;1090       Thread->State|=RMP_THD_SUSPENDED;
;;;1091       
;;;1092       /* If we are suspending ourself, pend a yield */
;;;1093       if(Thread==RMP_Cur_Thd)
;;;1094       {
;;;1095           RMP_COVERAGE_MARKER();
;;;1096           RMP_Sched_Pend=1;
;;;1097       }
;;;1098       else
;;;1099           RMP_COVERAGE_MARKER();
;;;1100       
;;;1101       RMP_Unlock_Sched();
;;;1102       return 0;
;;;1103   }
000008  4770              BXEQ     lr
00000a  b570              PUSH     {r4-r6,lr}            ;1048
00000c  4604              MOV      r4,r0                 ;1048
00000e  20ff              MOVS     r0,#0xff              ;1048
000010  f7fffffe          BL       RMP_Mask_Int
000014  4d14              LDR      r5,|L33.104|
000016  2601              MOVS     r6,#1                 ;1048
000018  606e              STR      r6,[r5,#4]            ;1048  ; RMP_Sched_Locked
00001a  6828              LDR      r0,[r5,#0]            ;1048  ; RMP_Sched_Lock_Cnt
00001c  1c40              ADDS     r0,r0,#1              ;1048
00001e  6028              STR      r0,[r5,#0]            ;1048  ; RMP_Sched_Lock_Cnt
000020  69a0              LDR      r0,[r4,#0x18]         ;1060
000022  f0100fff          TST      r0,#0xff              ;1060
000026  d007              BEQ      |L33.56|
000028  69a0              LDR      r0,[r4,#0x18]         ;1070
00002a  f4107f80          TST      r0,#0x100             ;1070
00002e  d008              BEQ      |L33.66|
000030  f7fffffe          BL       RMP_Unlock_Sched
000034  1f70              SUBS     r0,r6,#5              ;1074
000036  bd70              POP      {r4-r6,pc}
                  |L33.56|
000038  f7fffffe          BL       RMP_Unlock_Sched
00003c  f04f30ff          MOV      r0,#0xffffffff        ;1064
000040  bd70              POP      {r4-r6,pc}
                  |L33.66|
000042  69a0              LDR      r0,[r4,#0x18]         ;1081
000044  b2c0              UXTB     r0,r0                 ;1081
000046  2801              CMP      r0,#1                 ;1081
000048  bf04              ITT      EQ                    ;1084
00004a  4620              MOVEQ    r0,r4                 ;1084
00004c  f7fffffe          BLEQ     _RMP_Clr_Rdy
000050  69a0              LDR      r0,[r4,#0x18]         ;1090
000052  f4407080          ORR      r0,r0,#0x100          ;1090
000056  61a0              STR      r0,[r4,#0x18]         ;1090
000058  6968              LDR      r0,[r5,#0x14]         ;1093  ; RMP_Cur_Thd
00005a  4284              CMP      r4,r0                 ;1093
00005c  bf08              IT       EQ                    ;1096
00005e  60ae              STREQ    r6,[r5,#8]            ;1096  ; RMP_Sched_Pend
000060  f7fffffe          BL       RMP_Unlock_Sched
000064  2000              MOVS     r0,#0                 ;1102
000066  bd70              POP      {r4-r6,pc}
;;;1104   /* End Function:RMP_Thd_Suspend **********************************************/
                          ENDP

                  |L33.104|
                          DCD      ||.data||

                          AREA ||i.RMP_Unlock_Sched||, CODE, READONLY, ALIGN=2

                  RMP_Unlock_Sched PROC
;;;375    ******************************************************************************/
;;;376    void RMP_Unlock_Sched(void)
000000  490d              LDR      r1,|L34.56|
;;;377    {
000002  b510              PUSH     {r4,lr}
;;;378        if(RMP_Sched_Lock_Cnt==1)
000004  6808              LDR      r0,[r1,#0]  ; RMP_Sched_Lock_Cnt
000006  2801              CMP      r0,#1
000008  d006              BEQ      |L34.24|
;;;379        {
;;;380            RMP_COVERAGE_MARKER();
;;;381            /* Clear the count before enabling */
;;;382            RMP_Sched_Lock_Cnt=0;
;;;383            RMP_Sched_Locked=0;
;;;384            /* Now see if the scheduler scheduling action is pended in the lock-unlock 
;;;385             * period. If yes, perform a schedule now */
;;;386            if(RMP_Sched_Pend!=0)
;;;387            {
;;;388                RMP_COVERAGE_MARKER();
;;;389                /* Reset the count and trigger the context switch */
;;;390                RMP_Sched_Pend=0;
;;;391                _RMP_Yield();
;;;392            }
;;;393            else
;;;394                RMP_COVERAGE_MARKER();
;;;395            
;;;396            RMP_UNMASK_INT();
;;;397        }
;;;398        else if(RMP_Sched_Lock_Cnt>1)
00000a  6808              LDR      r0,[r1,#0]  ; RMP_Sched_Lock_Cnt
00000c  2801              CMP      r0,#1
00000e  d911              BLS      |L34.52|
;;;399        {
;;;400            RMP_COVERAGE_MARKER();
;;;401            RMP_Sched_Lock_Cnt--;
000010  6808              LDR      r0,[r1,#0]  ; RMP_Sched_Lock_Cnt
000012  1e40              SUBS     r0,r0,#1
000014  6008              STR      r0,[r1,#0]  ; RMP_Sched_Lock_Cnt
;;;402        }
;;;403        /* Trying to unlock a scheduler that is not locked - should never happen */
;;;404        else
;;;405            while(1);
;;;406    }
000016  bd10              POP      {r4,pc}
                  |L34.24|
000018  2000              MOVS     r0,#0                 ;382
00001a  6008              STR      r0,[r1,#0]            ;382  ; RMP_Sched_Lock_Cnt
00001c  6048              STR      r0,[r1,#4]            ;383  ; RMP_Sched_Locked
00001e  688a              LDR      r2,[r1,#8]            ;386  ; RMP_Sched_Pend
000020  2a00              CMP      r2,#0                 ;386
000022  bf1c              ITT      NE                    ;390
000024  6088              STRNE    r0,[r1,#8]            ;390  ; RMP_Sched_Pend
000026  f7fffffe          BLNE     _RMP_Yield
00002a  2000              MOVS     r0,#0                 ;396
00002c  e8bd4010          POP      {r4,lr}               ;396
000030  f7ffbffe          B.W      RMP_Mask_Int
                  |L34.52|
000034  e7fe              B        |L34.52|
;;;407    /* End Function:RMP_Unlock_Sched *********************************************/
                          ENDP

000036  0000              DCW      0x0000
                  |L34.56|
                          DCD      ||.data||

                          AREA ||i.RMP_Yield||, CODE, READONLY, ALIGN=2

                  RMP_Yield PROC
;;;414    ******************************************************************************/
;;;415    void RMP_Yield(void)
000000  4804              LDR      r0,|L35.20|
;;;416    {
;;;417        if(RMP_Sched_Locked==0)
000002  6841              LDR      r1,[r0,#4]  ; RMP_Sched_Locked
000004  2900              CMP      r1,#0
;;;418        {
;;;419            RMP_COVERAGE_MARKER();
;;;420            /* Now see if the scheduler scheduling action is pended in the lock-unlock 
;;;421             * period. If yes, perform a schedule now */
;;;422            _RMP_Yield();
;;;423        }
;;;424        else
;;;425        {
;;;426            RMP_COVERAGE_MARKER();
;;;427            RMP_Sched_Pend=1;
000006  bf1e              ITTT     NE
000008  2101              MOVNE    r1,#1
00000a  6081              STRNE    r1,[r0,#8]  ; RMP_Sched_Pend
;;;428        }
;;;429    }
00000c  4770              BXNE     lr
00000e  f7ffbffe          B.W      _RMP_Yield
;;;430    /* End Function:RMP_Yield ****************************************************/
                          ENDP

000012  0000              DCW      0x0000
                  |L35.20|
                          DCD      ||.data||

                          AREA ||i._RMP_Clr_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Clr_Rdy PROC
;;;686    ******************************************************************************/
;;;687    void _RMP_Clr_Rdy(volatile struct RMP_Thd* Thread)
000000  6981              LDR      r1,[r0,#0x18]
;;;688    {
;;;689        /* Is it suspended? If yes, no need to delete again */
;;;690        if((Thread->State&RMP_THD_SUSPENDED)==0)
000002  f4117f80          TST      r1,#0x100
;;;691        {
;;;692            RMP_COVERAGE_MARKER();
;;;693            /* See if it is the last thread on the priority level */
;;;694            if(Thread->Run_Head.Prev==Thread->Run_Head.Next)
;;;695            {
;;;696                RMP_COVERAGE_MARKER();
;;;697                RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]&=~(((rmp_ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK));
;;;698            }
;;;699            else
;;;700                RMP_COVERAGE_MARKER();
;;;701            
;;;702            /* Delete this from the corresponding runqueue */
;;;703            RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;704            
;;;705            /* If it is the current thread, request a context switch */
;;;706            if(Thread==RMP_Cur_Thd)
;;;707            {
;;;708                RMP_COVERAGE_MARKER();
;;;709                RMP_Sched_Pend=1;
;;;710            }
;;;711            else
;;;712                RMP_COVERAGE_MARKER();
;;;713        }
;;;714        else
;;;715            RMP_COVERAGE_MARKER();
;;;716    }
000006  bf18              IT       NE
000008  4770              BXNE     lr
00000a  6801              LDR      r1,[r0,#0]            ;694
00000c  6842              LDR      r2,[r0,#4]            ;694
00000e  2301              MOVS     r3,#1                 ;697
000010  4291              CMP      r1,r2                 ;694
000012  d10e              BNE      |L36.50|
000014  6a41              LDR      r1,[r0,#0x24]         ;697
000016  4a0c              LDR      r2,|L36.72|
000018  0949              LSRS     r1,r1,#5              ;697
00001a  eb020181          ADD      r1,r2,r1,LSL #2       ;697
00001e  680a              LDR      r2,[r1,#0]            ;697
000020  f8d0c024          LDR      r12,[r0,#0x24]        ;697
000024  f00c0c1f          AND      r12,r12,#0x1f         ;697
000028  fa03fc0c          LSL      r12,r3,r12            ;697
00002c  ea22020c          BIC      r2,r2,r12             ;697
000030  600a              STR      r2,[r1,#0]            ;697
                  |L36.50|
000032  6801              LDR      r1,[r0,#0]            ;703
000034  6842              LDR      r2,[r0,#4]            ;703
000036  6011              STR      r1,[r2,#0]            ;703
000038  604a              STR      r2,[r1,#4]            ;703
00003a  4904              LDR      r1,|L36.76|
00003c  694a              LDR      r2,[r1,#0x14]         ;706  ; RMP_Cur_Thd
00003e  4290              CMP      r0,r2                 ;706
000040  bf08              IT       EQ                    ;709
000042  608b              STREQ    r3,[r1,#8]            ;709  ; RMP_Sched_Pend
000044  4770              BX       lr
;;;717    /* End Function:_RMP_Clr_Rdy *************************************************/
                          ENDP

000046  0000              DCW      0x0000
                  |L36.72|
                          DCD      ||.data||+0x1c
                  |L36.76|
                          DCD      ||.data||

                          AREA ||i._RMP_Get_High_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Get_High_Rdy PROC
;;;494    ******************************************************************************/
;;;495    void _RMP_Get_High_Rdy(void)
000000  b570              PUSH     {r4-r6,lr}
;;;496    {
;;;497        rmp_cnt_t Count;
;;;498        
;;;499        /* Write the SP value to thread structure */
;;;500        RMP_Cur_Thd->Stack=RMP_Cur_SP;
000002  4d1d              LDR      r5,|L37.120|
;;;501        
;;;502        /* No need to detect scheduler locks - if this interrupt can be entered, the scheduler is not locked */
;;;503        RMP_Sched_Pend=0;
000004  2100              MOVS     r1,#0
;;;504        /* See which one is ready, and pick it */
;;;505        for(Count=RMP_BITMAP_SIZE-1;Count>=0;Count--)
000006  2401              MOVS     r4,#1
;;;506        {
;;;507            if(RMP_Bitmap[Count]==0)
000008  f105001c          ADD      r0,r5,#0x1c
00000c  69aa              LDR      r2,[r5,#0x18]         ;500  ; RMP_Cur_SP
00000e  696b              LDR      r3,[r5,#0x14]         ;500  ; RMP_Cur_Thd
000010  635a              STR      r2,[r3,#0x34]         ;503
000012  60a9              STR      r1,[r5,#8]            ;503  ; RMP_Sched_Pend
                  |L37.20|
000014  f8501024          LDR      r1,[r0,r4,LSL #2]
000018  b341              CBZ      r1,|L37.108|
;;;508            {
;;;509                RMP_COVERAGE_MARKER();
;;;510                continue;
;;;511            }
;;;512            else
;;;513                RMP_COVERAGE_MARKER();
;;;514            
;;;515            Count=RMP_MSB_Get(RMP_Bitmap[Count])+(Count<<RMP_WORD_ORDER);
00001a  f8500024          LDR      r0,[r0,r4,LSL #2]
00001e  f7fffffe          BL       RMP_MSB_Get
;;;516            
;;;517            /* See if the current thread and the next thread are the same. If yes, place the current at the end of the queue */
;;;518            if(RMP_Cur_Thd==(struct RMP_Thd*)(RMP_Run[Count].Next))
000022  4916              LDR      r1,|L37.124|
000024  eb001044          ADD      r0,r0,r4,LSL #5       ;515
000028  eb0103c0          ADD      r3,r1,r0,LSL #3
00002c  6858              LDR      r0,[r3,#4]
00002e  696a              LDR      r2,[r5,#0x14]  ; RMP_Cur_Thd
000030  4290              CMP      r0,r2
000032  d114              BNE      |L37.94|
;;;519            {
;;;520                RMP_COVERAGE_MARKER();
;;;521                RMP_List_Del(RMP_Cur_Thd->Run_Head.Prev, RMP_Cur_Thd->Run_Head.Next);
000034  6968              LDR      r0,[r5,#0x14]  ; RMP_Cur_Thd
000036  696a              LDR      r2,[r5,#0x14]  ; RMP_Cur_Thd
000038  6800              LDR      r0,[r0,#0]
00003a  6852              LDR      r2,[r2,#4]
00003c  6010              STR      r0,[r2,#0]
00003e  6042              STR      r2,[r0,#4]
;;;522                RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),
000040  6968              LDR      r0,[r5,#0x14]  ; RMP_Cur_Thd
000042  696a              LDR      r2,[r5,#0x14]  ; RMP_Cur_Thd
000044  6a52              LDR      r2,[r2,#0x24]
000046  f8512032          LDR      r2,[r1,r2,LSL #3]
00004a  f8d5c014          LDR      r12,[r5,#0x14]  ; RMP_Cur_Thd
00004e  f8dcc024          LDR      r12,[r12,#0x24]
000052  eb0101cc          ADD      r1,r1,r12,LSL #3
000056  6008              STR      r0,[r1,#0]
000058  6041              STR      r1,[r0,#4]
00005a  6002              STR      r2,[r0,#0]
00005c  6050              STR      r0,[r2,#4]
                  |L37.94|
;;;523                             RMP_Run[RMP_Cur_Thd->Prio].Prev,
;;;524                             &(RMP_Run[RMP_Cur_Thd->Prio]));
;;;525            }
;;;526            else
;;;527                RMP_COVERAGE_MARKER();
;;;528            
;;;529            /* Replenish timeslices */
;;;530            RMP_Cur_Thd->Slices_Left=RMP_Cur_Thd->Slices;
00005e  6968              LDR      r0,[r5,#0x14]  ; RMP_Cur_Thd
000060  6969              LDR      r1,[r5,#0x14]  ; RMP_Cur_Thd
000062  69c0              LDR      r0,[r0,#0x1c]
;;;531            RMP_Cur_Thd=(struct RMP_Thd*)(RMP_Run[Count].Next);
000064  6208              STR      r0,[r1,#0x20]
000066  6858              LDR      r0,[r3,#4]
000068  6168              STR      r0,[r5,#0x14]  ; RMP_Cur_Thd
;;;532            break;
00006a  e001              B        |L37.112|
                  |L37.108|
00006c  1e64              SUBS     r4,r4,#1
00006e  d5d1              BPL      |L37.20|
                  |L37.112|
;;;533        }
;;;534        
;;;535        /* Load the SP value from thread structure */
;;;536        RMP_Cur_SP=RMP_Cur_Thd->Stack;
000070  6968              LDR      r0,[r5,#0x14]  ; RMP_Cur_Thd
000072  6b40              LDR      r0,[r0,#0x34]
000074  61a8              STR      r0,[r5,#0x18]  ; RMP_Cur_SP
;;;537        
;;;538    #if(RMP_USE_HOOKS==RMP_TRUE)
;;;539        RMP_Sched_Hook();
;;;540    #endif
;;;541    }
000076  bd70              POP      {r4-r6,pc}
;;;542    /* End Function:_RMP_Get_High_Rdy ********************************************/
                          ENDP

                  |L37.120|
                          DCD      ||.data||
                  |L37.124|
                          DCD      ||.bss||

                          AREA ||i._RMP_Get_Near_Ticks||, CODE, READONLY, ALIGN=2

                  _RMP_Get_Near_Ticks PROC
;;;612    ******************************************************************************/
;;;613    rmp_ptr_t _RMP_Get_Near_Ticks(void)
000000  4a08              LDR      r2,|L38.36|
;;;614    {
;;;615        rmp_ptr_t Value;
;;;616        struct RMP_Thd* Thread;
;;;617        
;;;618        /* What is the current thread's timeout value? */
;;;619        Value=RMP_Cur_Thd->Slices_Left;
000002  f1a20124          SUB      r1,r2,#0x24
000006  6948              LDR      r0,[r1,#0x14]  ; RMP_Cur_Thd
;;;620        
;;;621        /* What is the nearest timer timeout value? */
;;;622        if((&RMP_Delay)!=RMP_Delay.Next)
000008  6853              LDR      r3,[r2,#4]  ; RMP_Delay
00000a  4293              CMP      r3,r2
00000c  6a00              LDR      r0,[r0,#0x20]         ;619
;;;623        {
;;;624            RMP_COVERAGE_MARKER();
;;;625            Thread=RMP_DLY2THD(RMP_Delay.Next);
;;;626            /* See if it is nearer - don't worry about the situation that the timer
;;;627             * have overflown, because if that is to happen, it would have been 
;;;628             * already processed by the timeout processing routine just before. */
;;;629            if((Thread->Timeout-RMP_Tick)<Value)
;;;630            {
;;;631                RMP_COVERAGE_MARKER();
;;;632                Value=Thread->Timeout-RMP_Tick;
;;;633            }
;;;634            else
;;;635                RMP_COVERAGE_MARKER();
;;;636        }
;;;637        else
;;;638            RMP_COVERAGE_MARKER();
;;;639        
;;;640        return Value;
;;;641    }
00000e  bf08              IT       EQ
000010  4770              BXEQ     lr
000012  6852              LDR      r2,[r2,#4]            ;625  ; RMP_Delay
000014  690b              LDR      r3,[r1,#0x10]         ;629  ; RMP_Tick
000016  6a12              LDR      r2,[r2,#0x20]         ;629
000018  1ad3              SUBS     r3,r2,r3              ;629
00001a  4283              CMP      r3,r0                 ;629
00001c  bf3c              ITT      CC                    ;632
00001e  6908              LDRCC    r0,[r1,#0x10]         ;632  ; RMP_Tick
000020  1a10              SUBCC    r0,r2,r0              ;632
000022  4770              BX       lr
;;;642    /* End Function:_RMP_Get_Near_Ticks ******************************************/
                          ENDP

                  |L38.36|
                          DCD      ||.data||+0x24

                          AREA ||i._RMP_Set_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Set_Rdy PROC
;;;653    ******************************************************************************/
;;;654    void _RMP_Set_Rdy(volatile struct RMP_Thd* Thread)
000000  6981              LDR      r1,[r0,#0x18]
;;;655    {        
;;;656        /* Is it suspended? If yes, we can't directly set it running */
;;;657        if((Thread->State&RMP_THD_SUSPENDED)==0)
000002  f4117f80          TST      r1,#0x100
;;;658        {
;;;659            RMP_COVERAGE_MARKER();
;;;660            /* Insert this into the corresponding runqueue */
;;;661            RMP_List_Ins(&(Thread->Run_Head),RMP_Run[Thread->Prio].Prev,&(RMP_Run[Thread->Prio]));
;;;662            /* Set this runlevel as active */
;;;663            RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]|=((rmp_ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK);
;;;664            
;;;665            /* Compare this with the current one to see if we need a context switch */
;;;666            if(Thread->Prio>RMP_Cur_Thd->Prio)
;;;667            {
;;;668                RMP_COVERAGE_MARKER();
;;;669                RMP_Sched_Pend=1;
;;;670            }
;;;671            else
;;;672                RMP_COVERAGE_MARKER();
;;;673        }
;;;674        else
;;;675            RMP_COVERAGE_MARKER();
;;;676    }
000006  bf18              IT       NE
000008  4770              BXNE     lr
00000a  6a42              LDR      r2,[r0,#0x24]         ;661
00000c  4910              LDR      r1,|L39.80|
00000e  f8512032          LDR      r2,[r1,r2,LSL #3]     ;661
000012  6a43              LDR      r3,[r0,#0x24]         ;661
000014  eb0101c3          ADD      r1,r1,r3,LSL #3       ;661
000018  6008              STR      r0,[r1,#0]            ;661
00001a  6041              STR      r1,[r0,#4]            ;661
00001c  6002              STR      r2,[r0,#0]            ;661
00001e  6050              STR      r0,[r2,#4]            ;661
000020  6a41              LDR      r1,[r0,#0x24]         ;663
000022  2201              MOVS     r2,#1                 ;663
000024  4b0b              LDR      r3,|L39.84|
000026  0949              LSRS     r1,r1,#5              ;663
000028  eb030181          ADD      r1,r3,r1,LSL #2       ;663
00002c  680b              LDR      r3,[r1,#0]            ;663
00002e  f8d0c024          LDR      r12,[r0,#0x24]        ;663
000032  f00c0c1f          AND      r12,r12,#0x1f         ;663
000036  fa02fc0c          LSL      r12,r2,r12            ;663
00003a  ea43030c          ORR      r3,r3,r12             ;663
00003e  600b              STR      r3,[r1,#0]            ;663
000040  4905              LDR      r1,|L39.88|
000042  6a40              LDR      r0,[r0,#0x24]         ;666
000044  694b              LDR      r3,[r1,#0x14]         ;666  ; RMP_Cur_Thd
000046  6a5b              LDR      r3,[r3,#0x24]         ;666
000048  4298              CMP      r0,r3                 ;666
00004a  bf88              IT       HI                    ;669
00004c  608a              STRHI    r2,[r1,#8]            ;669  ; RMP_Sched_Pend
00004e  4770              BX       lr
;;;677    /* End Function:_RMP_Set_Rdy *************************************************/
                          ENDP

                  |L39.80|
                          DCD      ||.bss||
                  |L39.84|
                          DCD      ||.data||+0x1c
                  |L39.88|
                          DCD      ||.data||

                          AREA ||i._RMP_Tick_Handler||, CODE, READONLY, ALIGN=2

                  _RMP_Tick_Handler PROC
;;;549    ******************************************************************************/
;;;550    void _RMP_Tick_Handler(rmp_ptr_t Ticks)
000000  b570              PUSH     {r4-r6,lr}
;;;551    {
;;;552        struct RMP_Thd* Thread;
;;;553        /* Increase the timestamp as always */
;;;554        RMP_Tick+=Ticks;
000002  4c28              LDR      r4,|L40.164|
000004  6921              LDR      r1,[r4,#0x10]  ; RMP_Tick
000006  4401              ADD      r1,r1,r0
000008  6121              STR      r1,[r4,#0x10]  ; RMP_Tick
;;;555        
;;;556        /* See if the current thread expired. If yes, trigger a scheduler event */
;;;557        if(Ticks>RMP_Cur_Thd->Slices_Left)
00000a  6961              LDR      r1,[r4,#0x14]  ; RMP_Cur_Thd
00000c  6a09              LDR      r1,[r1,#0x20]
00000e  4281              CMP      r1,r0
;;;558        {
;;;559            RMP_COVERAGE_MARKER();
;;;560            RMP_Sched_Pend=1;
000010  bf3c              ITT      CC
000012  2001              MOVCC    r0,#1
000014  60a0              STRCC    r0,[r4,#8]  ; RMP_Sched_Pend
000016  d303              BCC      |L40.32|
;;;561        }
;;;562        else
;;;563        {
;;;564            RMP_COVERAGE_MARKER();
;;;565            RMP_Cur_Thd->Slices_Left-=Ticks;
000018  6961              LDR      r1,[r4,#0x14]  ; RMP_Cur_Thd
00001a  6a0a              LDR      r2,[r1,#0x20]
00001c  1a10              SUBS     r0,r2,r0
00001e  6208              STR      r0,[r1,#0x20]
                  |L40.32|
;;;566        }
;;;567        
;;;568        /* Check if there are any timer events */
;;;569        if((&RMP_Delay)!=RMP_Delay.Next)
000020  4d21              LDR      r5,|L40.168|
000022  6868              LDR      r0,[r5,#4]  ; RMP_Delay
000024  42a8              CMP      r0,r5
000026  d033              BEQ      |L40.144|
;;;570        {
;;;571            RMP_COVERAGE_MARKER();
;;;572            Thread=RMP_DLY2THD(RMP_Delay.Next);
000028  6868              LDR      r0,[r5,#4]  ; RMP_Delay
;;;573            /* If the value is less than this, then it means that the time have
;;;574             * already passed and we have to process this */
;;;575            if((RMP_Tick-Thread->Timeout)<=(RMP_ALLBITS>>1))
00002a  6921              LDR      r1,[r4,#0x10]  ; RMP_Tick
00002c  6a00              LDR      r0,[r0,#0x20]
00002e  1a08              SUBS     r0,r1,r0
000030  f1b04f00          CMP      r0,#0x80000000
000034  d22c              BCS      |L40.144|
000036  6868              LDR      r0,[r5,#4]  ; RMP_Delay
000038  42a8              CMP      r0,r5
00003a  bf18              IT       NE
00003c  f06f0604          MVNNE    r6,#4
000040  d026              BEQ      |L40.144|
                  |L40.66|
000042  6868              LDR      r0,[r5,#4]  ; RMP_Delay
000044  6922              LDR      r2,[r4,#0x10]  ; RMP_Tick
000046  6a01              LDR      r1,[r0,#0x20]
000048  3808              SUBS     r0,r0,#8
00004a  1a51              SUBS     r1,r2,r1
00004c  f1b14f00          CMP      r1,#0x80000000
000050  d21e              BCS      |L40.144|
000052  e9d01202          LDRD     r1,r2,[r0,#8]
000056  6011              STR      r1,[r2,#0]
000058  604a              STR      r2,[r1,#4]
00005a  7e01              LDRB     r1,[r0,#0x18]
00005c  2903              CMP      r1,#3
00005e  d007              BEQ      |L40.112|
000060  2905              CMP      r1,#5
000062  bf0c              ITE      EQ
000064  6386              STREQ    r6,[r0,#0x38]
000066  2906              CMPNE    r1,#6
000068  d007              BEQ      |L40.122|
00006a  2908              CMP      r1,#8
00006c  d000              BEQ      |L40.112|
                  |L40.110|
00006e  e7fe              B        |L40.110|
                  |L40.112|
000070  e9d01200          LDRD     r1,r2,[r0,#0]
000074  6011              STR      r1,[r2,#0]
000076  604a              STR      r2,[r1,#4]
000078  6386              STR      r6,[r0,#0x38]
                  |L40.122|
00007a  6981              LDR      r1,[r0,#0x18]
00007c  f02101ff          BIC      r1,r1,#0xff
000080  f0410101          ORR      r1,r1,#1
000084  6181              STR      r1,[r0,#0x18]
000086  f7fffffe          BL       _RMP_Set_Rdy
00008a  6868              LDR      r0,[r5,#4]  ; RMP_Delay
00008c  42a8              CMP      r0,r5
00008e  d1d8              BNE      |L40.66|
                  |L40.144|
;;;576            {
;;;577                RMP_COVERAGE_MARKER();
;;;578                /* No need to care about scheduler locks if this interrupt can be entered
;;;579                 * - we have disabled timer and scheduler interrupts in scheduler lock */
;;;580                _RMP_Timer_Proc();
;;;581            }
;;;582            else
;;;583                RMP_COVERAGE_MARKER();
;;;584        }
;;;585        else
;;;586            RMP_COVERAGE_MARKER();
;;;587        
;;;588        if(RMP_Sched_Pend!=0)
000090  68a0              LDR      r0,[r4,#8]  ; RMP_Sched_Pend
000092  2800              CMP      r0,#0
;;;589        {
;;;590            RMP_COVERAGE_MARKER();
;;;591            RMP_Sched_Pend=0;
;;;592            _RMP_Yield();
;;;593        }
;;;594        else
;;;595            RMP_COVERAGE_MARKER();
;;;596        
;;;597    #if(RMP_USE_HOOKS==RMP_TRUE)
;;;598        RMP_Tick_Hook(Ticks);
;;;599    #endif
;;;600    }
000094  bf08              IT       EQ
000096  bd70              POPEQ    {r4-r6,pc}
000098  2000              MOVS     r0,#0                 ;591
00009a  60a0              STR      r0,[r4,#8]            ;591  ; RMP_Sched_Pend
00009c  e8bd4070          POP      {r4-r6,lr}            ;592
0000a0  f7ffbffe          B.W      _RMP_Yield
;;;601    /* End Function:_RMP_Tick_Handler ********************************************/
                          ENDP

                  |L40.164|
                          DCD      ||.data||
                  |L40.168|
                          DCD      ||.data||+0x24

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;1994   ******************************************************************************/
;;;1995   int main(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1996   {
;;;1997       rmp_ptr_t Count;
;;;1998       
;;;1999   #ifdef RMP_COVERAGE
;;;2000       /* Initialize coverage markers if coverage enabled */
;;;2001       for(Count=0;Count<RMP_COVERAGE_LINES;Count++)
;;;2002           RMP_Coverage[Count]=0;
;;;2003   #endif
;;;2004       
;;;2005       /* Initialize the kernel data structures first */
;;;2006       _RMP_Low_Level_Init();
000002  f7fffffe          BL       _RMP_Low_Level_Init
;;;2007       
;;;2008   #if(RMP_USE_HOOKS==RMP_TRUE)
;;;2009       RMP_Start_Hook();
;;;2010   #endif
;;;2011       
;;;2012       RMP_Tick=0;
000006  4b23              LDR      r3,|L41.148|
000008  2000              MOVS     r0,#0
00000a  6118              STR      r0,[r3,#0x10]  ; RMP_Tick
;;;2013       /* Now initialize the kernel data structures */
;;;2014       RMP_Sched_Lock_Cnt=0;
00000c  6018              STR      r0,[r3,#0]  ; RMP_Sched_Lock_Cnt
;;;2015       RMP_Sched_Locked=0;
00000e  6058              STR      r0,[r3,#4]  ; RMP_Sched_Locked
;;;2016       RMP_Sched_Pend=0;
000010  6098              STR      r0,[r3,#8]  ; RMP_Sched_Pend
;;;2017       RMP_Timer_Pend=0;
000012  60d8              STR      r0,[r3,#0xc]  ; RMP_Timer_Pend
;;;2018       
;;;2019       /* Linked lists */
;;;2020       RMP_List_Crt(&RMP_Delay);
000014  f1030124          ADD      r1,r3,#0x24
000018  6009              STR      r1,[r1,#0]
00001a  6049              STR      r1,[r1,#4]
;;;2021       for(Count=0;Count<RMP_MAX_PREEMPT_PRIO;Count++)
00001c  ea4f0100          MOV.W    r1,r0
;;;2022           RMP_List_Crt(&RMP_Run[Count]);
000020  f8dfc074          LDR      r12,|L41.152|
                  |L41.36|
000024  eb0c02c1          ADD      r2,r12,r1,LSL #3
000028  6012              STR      r2,[r2,#0]
00002a  6052              STR      r2,[r2,#4]
00002c  1c49              ADDS     r1,r1,#1
00002e  2940              CMP      r1,#0x40
000030  d3f8              BCC      |L41.36|
;;;2023       for(Count=0;Count<RMP_BITMAP_SIZE;Count++)
;;;2024           RMP_Bitmap[Count]=0;
000032  4c1a              LDR      r4,|L41.156|
000034  6020              STR      r0,[r4,#0]  ; RMP_Bitmap
000036  6060              STR      r0,[r4,#4]  ; RMP_Bitmap
000038  211e              MOVS     r1,#0x1e
;;;2025           
;;;2026       /* Now boot into the first thread */
;;;2027       RMP_Clear(&RMP_Init_Thd,sizeof(struct RMP_Thd));
00003a  4a19              LDR      r2,|L41.160|
                  |L41.60|
00003c  1e49              SUBS     r1,r1,#1
00003e  7050              STRB     r0,[r2,#1]
000040  f8020f02          STRB     r0,[r2,#2]!
000044  d1fa              BNE      |L41.60|
;;;2028       RMP_Init_Thd.Prio=0;
000046  4917              LDR      r1,|L41.164|
;;;2029       RMP_Init_Thd.Slices=10;
000048  220a              MOVS     r2,#0xa
;;;2030       RMP_Init_Thd.Slices_Left=10;
;;;2031       RMP_Init_Thd.State=RMP_THD_RUNNING;
00004a  2501              MOVS     r5,#1
;;;2032       RMP_Init_Thd.Stack=RMP_INIT_STACK;
00004c  f1a10644          SUB      r6,r1,#0x44
000050  6248              STR      r0,[r1,#0x24]         ;2028  ; RMP_Init_Thd
000052  61ca              STR      r2,[r1,#0x1c]         ;2029  ; RMP_Init_Thd
000054  620a              STR      r2,[r1,#0x20]         ;2030  ; RMP_Init_Thd
000056  618d              STR      r5,[r1,#0x18]         ;2031  ; RMP_Init_Thd
000058  634e              STR      r6,[r1,#0x34]  ; RMP_Init_Thd
;;;2033       
;;;2034       /* Initialize sending list */
;;;2035       RMP_List_Crt(&(RMP_Init_Thd.Snd_List));
00005a  f1010010          ADD      r0,r1,#0x10
00005e  6108              STR      r0,[r1,#0x10]
000060  6148              STR      r0,[r1,#0x14]
;;;2036       
;;;2037       /* Insert this into the corresponding runqueue */
;;;2038       RMP_List_Ins(&(RMP_Init_Thd.Run_Head),RMP_Run[0].Prev,&(RMP_Run[0]));
000062  4608              MOV      r0,r1
000064  f8dcc000          LDR      r12,[r12,#0]  ; RMP_Run
000068  f5a07240          SUB      r2,r0,#0x300
00006c  6010              STR      r0,[r2,#0]
00006e  6042              STR      r2,[r0,#4]
000070  f8c0c000          STR      r12,[r0,#0]
000074  f8cc0004          STR      r0,[r12,#4]
;;;2039       /* Set this runlevel as active - in fact it is always active */
;;;2040       RMP_Bitmap[0]|=1;
000078  6820              LDR      r0,[r4,#0]  ; RMP_Bitmap
00007a  f0400001          ORR      r0,r0,#1
00007e  6020              STR      r0,[r4,#0]  ; RMP_Bitmap
;;;2041       
;;;2042       /* Set current thread and stack */
;;;2043       RMP_Cur_Thd=(struct RMP_Thd*)(&RMP_Init_Thd);
000080  6159              STR      r1,[r3,#0x14]  ; RMP_Cur_Thd
;;;2044       RMP_Cur_SP=RMP_Init_Thd.Stack;
000082  6b48              LDR      r0,[r1,#0x34]  ; RMP_Init_Thd
000084  6198              STR      r0,[r3,#0x18]  ; RMP_Cur_SP
;;;2045       
;;;2046       /* Now jump to the user function and will never return. Initialization of stack is not needed */
;;;2047       _RMP_Start((rmp_ptr_t)RMP_Init, (rmp_ptr_t)RMP_Init_Thd.Stack);
000086  6b49              LDR      r1,[r1,#0x34]  ; RMP_Init_Thd
000088  4807              LDR      r0,|L41.168|
00008a  f7fffffe          BL       _RMP_Start
;;;2048       
;;;2049       return 0;
00008e  2000              MOVS     r0,#0
;;;2050   }
000090  bd70              POP      {r4-r6,pc}
;;;2051   /* End Function:main *********************************************************/
                          ENDP

000092  0000              DCW      0x0000
                  |L41.148|
                          DCD      ||.data||
                  |L41.152|
                          DCD      ||.bss||
                  |L41.156|
                          DCD      ||.data||+0x1c
                  |L41.160|
                          DCD      ||.bss||+0x2ff
                  |L41.164|
                          DCD      ||.bss||+0x300
                  |L41.168|
                          DCD      RMP_Init

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  RMP_Run
                          %        512
                  RMP_Init_Stack
                          %        256
                  RMP_Init_Thd
                          %        60

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  RMP_RBIT_Table
000000  008040c0          DCB      0x00,0x80,0x40,0xc0
000004  20a060e0          DCB      0x20,0xa0,0x60,0xe0
000008  109050d0          DCB      0x10,0x90,0x50,0xd0
00000c  30b070f0          DCB      0x30,0xb0,0x70,0xf0
000010  088848c8          DCB      0x08,0x88,0x48,0xc8
000014  28a868e8          DCB      0x28,0xa8,0x68,0xe8
000018  189858d8          DCB      0x18,0x98,0x58,0xd8
00001c  38b878f8          DCB      0x38,0xb8,0x78,0xf8
000020  048444c4          DCB      0x04,0x84,0x44,0xc4
000024  24a464e4          DCB      0x24,0xa4,0x64,0xe4
000028  149454d4          DCB      0x14,0x94,0x54,0xd4
00002c  34b474f4          DCB      0x34,0xb4,0x74,0xf4
000030  0c8c4ccc          DCB      0x0c,0x8c,0x4c,0xcc
000034  2cac6cec          DCB      0x2c,0xac,0x6c,0xec
000038  1c9c5cdc          DCB      0x1c,0x9c,0x5c,0xdc
00003c  3cbc7cfc          DCB      0x3c,0xbc,0x7c,0xfc
000040  028242c2          DCB      0x02,0x82,0x42,0xc2
000044  22a262e2          DCB      0x22,0xa2,0x62,0xe2
000048  129252d2          DCB      0x12,0x92,0x52,0xd2
00004c  32b272f2          DCB      0x32,0xb2,0x72,0xf2
000050  0a8a4aca          DCB      0x0a,0x8a,0x4a,0xca
000054  2aaa6aea          DCB      0x2a,0xaa,0x6a,0xea
000058  1a9a5ada          DCB      0x1a,0x9a,0x5a,0xda
00005c  3aba7afa          DCB      0x3a,0xba,0x7a,0xfa
000060  068646c6          DCB      0x06,0x86,0x46,0xc6
000064  26a666e6          DCB      0x26,0xa6,0x66,0xe6
000068  169656d6          DCB      0x16,0x96,0x56,0xd6
00006c  36b676f6          DCB      0x36,0xb6,0x76,0xf6
000070  0e8e4ece          DCB      0x0e,0x8e,0x4e,0xce
000074  2eae6eee          DCB      0x2e,0xae,0x6e,0xee
000078  1e9e5ede          DCB      0x1e,0x9e,0x5e,0xde
00007c  3ebe7efe          DCB      0x3e,0xbe,0x7e,0xfe
000080  018141c1          DCB      0x01,0x81,0x41,0xc1
000084  21a161e1          DCB      0x21,0xa1,0x61,0xe1
000088  119151d1          DCB      0x11,0x91,0x51,0xd1
00008c  31b171f1          DCB      0x31,0xb1,0x71,0xf1
000090  098949c9          DCB      0x09,0x89,0x49,0xc9
000094  29a969e9          DCB      0x29,0xa9,0x69,0xe9
000098  199959d9          DCB      0x19,0x99,0x59,0xd9
00009c  39b979f9          DCB      0x39,0xb9,0x79,0xf9
0000a0  058545c5          DCB      0x05,0x85,0x45,0xc5
0000a4  25a565e5          DCB      0x25,0xa5,0x65,0xe5
0000a8  159555d5          DCB      0x15,0x95,0x55,0xd5
0000ac  35b575f5          DCB      0x35,0xb5,0x75,0xf5
0000b0  0d8d4dcd          DCB      0x0d,0x8d,0x4d,0xcd
0000b4  2dad6ded          DCB      0x2d,0xad,0x6d,0xed
0000b8  1d9d5ddd          DCB      0x1d,0x9d,0x5d,0xdd
0000bc  3dbd7dfd          DCB      0x3d,0xbd,0x7d,0xfd
0000c0  038343c3          DCB      0x03,0x83,0x43,0xc3
0000c4  23a363e3          DCB      0x23,0xa3,0x63,0xe3
0000c8  139353d3          DCB      0x13,0x93,0x53,0xd3
0000cc  33b373f3          DCB      0x33,0xb3,0x73,0xf3
0000d0  0b8b4bcb          DCB      0x0b,0x8b,0x4b,0xcb
0000d4  2bab6beb          DCB      0x2b,0xab,0x6b,0xeb
0000d8  1b9b5bdb          DCB      0x1b,0x9b,0x5b,0xdb
0000dc  3bbb7bfb          DCB      0x3b,0xbb,0x7b,0xfb
0000e0  078747c7          DCB      0x07,0x87,0x47,0xc7
0000e4  27a767e7          DCB      0x27,0xa7,0x67,0xe7
0000e8  179757d7          DCB      0x17,0x97,0x57,0xd7
0000ec  37b777f7          DCB      0x37,0xb7,0x77,0xf7
0000f0  0f8f4fcf          DCB      0x0f,0x8f,0x4f,0xcf
0000f4  2faf6fef          DCB      0x2f,0xaf,0x6f,0xef
0000f8  1f9f5fdf          DCB      0x1f,0x9f,0x5f,0xdf
0000fc  3fbf7fff          DCB      0x3f,0xbf,0x7f,0xff
                  CRC16_High
000100  00c18140          DCB      0x00,0xc1,0x81,0x40
000104  01c08041          DCB      0x01,0xc0,0x80,0x41
000108  01c08041          DCB      0x01,0xc0,0x80,0x41
00010c  00c18140          DCB      0x00,0xc1,0x81,0x40
000110  01c08041          DCB      0x01,0xc0,0x80,0x41
000114  00c18140          DCB      0x00,0xc1,0x81,0x40
000118  00c18140          DCB      0x00,0xc1,0x81,0x40
00011c  01c08041          DCB      0x01,0xc0,0x80,0x41
000120  01c08041          DCB      0x01,0xc0,0x80,0x41
000124  00c18140          DCB      0x00,0xc1,0x81,0x40
000128  00c18140          DCB      0x00,0xc1,0x81,0x40
00012c  01c08041          DCB      0x01,0xc0,0x80,0x41
000130  00c18140          DCB      0x00,0xc1,0x81,0x40
000134  01c08041          DCB      0x01,0xc0,0x80,0x41
000138  01c08041          DCB      0x01,0xc0,0x80,0x41
00013c  00c18140          DCB      0x00,0xc1,0x81,0x40
000140  01c08041          DCB      0x01,0xc0,0x80,0x41
000144  00c18140          DCB      0x00,0xc1,0x81,0x40
000148  00c18140          DCB      0x00,0xc1,0x81,0x40
00014c  01c08041          DCB      0x01,0xc0,0x80,0x41
000150  00c18140          DCB      0x00,0xc1,0x81,0x40
000154  01c08041          DCB      0x01,0xc0,0x80,0x41
000158  01c08041          DCB      0x01,0xc0,0x80,0x41
00015c  00c18140          DCB      0x00,0xc1,0x81,0x40
000160  00c18140          DCB      0x00,0xc1,0x81,0x40
000164  01c08041          DCB      0x01,0xc0,0x80,0x41
000168  01c08041          DCB      0x01,0xc0,0x80,0x41
00016c  00c18140          DCB      0x00,0xc1,0x81,0x40
000170  01c08041          DCB      0x01,0xc0,0x80,0x41
000174  00c18140          DCB      0x00,0xc1,0x81,0x40
000178  00c18140          DCB      0x00,0xc1,0x81,0x40
00017c  01c08041          DCB      0x01,0xc0,0x80,0x41
000180  01c08041          DCB      0x01,0xc0,0x80,0x41
000184  00c18140          DCB      0x00,0xc1,0x81,0x40
000188  00c18140          DCB      0x00,0xc1,0x81,0x40
00018c  01c08041          DCB      0x01,0xc0,0x80,0x41
000190  00c18140          DCB      0x00,0xc1,0x81,0x40
000194  01c08041          DCB      0x01,0xc0,0x80,0x41
000198  01c08041          DCB      0x01,0xc0,0x80,0x41
00019c  00c18140          DCB      0x00,0xc1,0x81,0x40
0001a0  00c18140          DCB      0x00,0xc1,0x81,0x40
0001a4  01c08041          DCB      0x01,0xc0,0x80,0x41
0001a8  01c08041          DCB      0x01,0xc0,0x80,0x41
0001ac  00c18140          DCB      0x00,0xc1,0x81,0x40
0001b0  01c08041          DCB      0x01,0xc0,0x80,0x41
0001b4  00c18140          DCB      0x00,0xc1,0x81,0x40
0001b8  00c18140          DCB      0x00,0xc1,0x81,0x40
0001bc  01c08041          DCB      0x01,0xc0,0x80,0x41
0001c0  00c18140          DCB      0x00,0xc1,0x81,0x40
0001c4  01c08041          DCB      0x01,0xc0,0x80,0x41
0001c8  01c08041          DCB      0x01,0xc0,0x80,0x41
0001cc  00c18140          DCB      0x00,0xc1,0x81,0x40
0001d0  01c08041          DCB      0x01,0xc0,0x80,0x41
0001d4  00c18140          DCB      0x00,0xc1,0x81,0x40
0001d8  00c18140          DCB      0x00,0xc1,0x81,0x40
0001dc  01c08041          DCB      0x01,0xc0,0x80,0x41
0001e0  01c08041          DCB      0x01,0xc0,0x80,0x41
0001e4  00c18140          DCB      0x00,0xc1,0x81,0x40
0001e8  00c18140          DCB      0x00,0xc1,0x81,0x40
0001ec  01c08041          DCB      0x01,0xc0,0x80,0x41
0001f0  00c18140          DCB      0x00,0xc1,0x81,0x40
0001f4  01c08041          DCB      0x01,0xc0,0x80,0x41
0001f8  01c08041          DCB      0x01,0xc0,0x80,0x41
0001fc  00c18140          DCB      0x00,0xc1,0x81,0x40
000200  00c0c101          DCB      0x00,0xc0,0xc1,0x01
000204  c30302c2          DCB      0xc3,0x03,0x02,0xc2
000208  c60607c7          DCB      0xc6,0x06,0x07,0xc7
00020c  05c5c404          DCB      0x05,0xc5,0xc4,0x04
000210  cc0c0dcd          DCB      0xcc,0x0c,0x0d,0xcd
000214  0fcfce0e          DCB      0x0f,0xcf,0xce,0x0e
000218  0acacb0b          DCB      0x0a,0xca,0xcb,0x0b
00021c  c90908c8          DCB      0xc9,0x09,0x08,0xc8
000220  d81819d9          DCB      0xd8,0x18,0x19,0xd9
000224  1bdbda1a          DCB      0x1b,0xdb,0xda,0x1a
000228  1ededf1f          DCB      0x1e,0xde,0xdf,0x1f
00022c  dd1d1cdc          DCB      0xdd,0x1d,0x1c,0xdc
000230  14d4d515          DCB      0x14,0xd4,0xd5,0x15
000234  d71716d6          DCB      0xd7,0x17,0x16,0xd6
000238  d21213d3          DCB      0xd2,0x12,0x13,0xd3
00023c  11d1d010          DCB      0x11,0xd1,0xd0,0x10
000240  f03031f1          DCB      0xf0,0x30,0x31,0xf1
000244  33f3f232          DCB      0x33,0xf3,0xf2,0x32
000248  36f6f737          DCB      0x36,0xf6,0xf7,0x37
00024c  f53534f4          DCB      0xf5,0x35,0x34,0xf4
000250  3cfcfd3d          DCB      0x3c,0xfc,0xfd,0x3d
000254  ff3f3efe          DCB      0xff,0x3f,0x3e,0xfe
000258  fa3a3bfb          DCB      0xfa,0x3a,0x3b,0xfb
00025c  39f9f838          DCB      0x39,0xf9,0xf8,0x38
000260  28e8e929          DCB      0x28,0xe8,0xe9,0x29
000264  eb2b2aea          DCB      0xeb,0x2b,0x2a,0xea
000268  ee2e2fef          DCB      0xee,0x2e,0x2f,0xef
00026c  2dedec2c          DCB      0x2d,0xed,0xec,0x2c
000270  e42425e5          DCB      0xe4,0x24,0x25,0xe5
000274  27e7e626          DCB      0x27,0xe7,0xe6,0x26
000278  22e2e323          DCB      0x22,0xe2,0xe3,0x23
00027c  e12120e0          DCB      0xe1,0x21,0x20,0xe0
000280  a06061a1          DCB      0xa0,0x60,0x61,0xa1
000284  63a3a262          DCB      0x63,0xa3,0xa2,0x62
000288  66a6a767          DCB      0x66,0xa6,0xa7,0x67
00028c  a56564a4          DCB      0xa5,0x65,0x64,0xa4
000290  6cacad6d          DCB      0x6c,0xac,0xad,0x6d
000294  af6f6eae          DCB      0xaf,0x6f,0x6e,0xae
000298  aa6a6bab          DCB      0xaa,0x6a,0x6b,0xab
00029c  69a9a868          DCB      0x69,0xa9,0xa8,0x68
0002a0  78b8b979          DCB      0x78,0xb8,0xb9,0x79
0002a4  bb7b7aba          DCB      0xbb,0x7b,0x7a,0xba
0002a8  be7e7fbf          DCB      0xbe,0x7e,0x7f,0xbf
0002ac  7dbdbc7c          DCB      0x7d,0xbd,0xbc,0x7c
0002b0  b47475b5          DCB      0xb4,0x74,0x75,0xb5
0002b4  77b7b676          DCB      0x77,0xb7,0xb6,0x76
0002b8  72b2b373          DCB      0x72,0xb2,0xb3,0x73
0002bc  b17170b0          DCB      0xb1,0x71,0x70,0xb0
0002c0  50909151          DCB      0x50,0x90,0x91,0x51
0002c4  93535292          DCB      0x93,0x53,0x52,0x92
0002c8  96565797          DCB      0x96,0x56,0x57,0x97
0002cc  55959454          DCB      0x55,0x95,0x94,0x54
0002d0  9c5c5d9d          DCB      0x9c,0x5c,0x5d,0x9d
0002d4  5f9f9e5e          DCB      0x5f,0x9f,0x9e,0x5e
0002d8  5a9a9b5b          DCB      0x5a,0x9a,0x9b,0x5b
0002dc  99595898          DCB      0x99,0x59,0x58,0x98
0002e0  88484989          DCB      0x88,0x48,0x49,0x89
0002e4  4b8b8a4a          DCB      0x4b,0x8b,0x8a,0x4a
0002e8  4e8e8f4f          DCB      0x4e,0x8e,0x8f,0x4f
0002ec  8d4d4c8c          DCB      0x8d,0x4d,0x4c,0x8c
0002f0  44848545          DCB      0x44,0x84,0x85,0x45
0002f4  87474686          DCB      0x87,0x47,0x46,0x86
0002f8  82424383          DCB      0x82,0x42,0x43,0x83
0002fc  41818040          DCB      0x41,0x81,0x80,0x40

                          AREA ||.data||, DATA, ALIGN=2

                  RMP_Sched_Lock_Cnt
                          DCD      0x00000000
                  RMP_Sched_Locked
                          DCD      0x00000000
                  RMP_Sched_Pend
                          DCD      0x00000000
                  RMP_Timer_Pend
                          DCD      0x00000000
                  RMP_Tick
                          DCD      0x00000000
                  RMP_Cur_Thd
                          DCD      0x00000000
                  RMP_Cur_SP
                          DCD      0x00000000
                  RMP_Bitmap
                          %        8
                  RMP_Delay
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\..\\MProkaron\\Kernel\\kernel.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_kernel_c_346ad0e8____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F7_V1.11.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___8_kernel_c_346ad0e8____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_kernel_c_346ad0e8____REVSH|
#line 402
|__asm___8_kernel_c_346ad0e8____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___8_kernel_c_346ad0e8____RRX|
#line 587
|__asm___8_kernel_c_346ad0e8____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
