; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f1xx_hal.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f1xx_hal.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\STM32F1xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\STM32F1xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F103RET6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F10X_HD -DUSE_HAL_DRIVER -DSTM32F103xE -W --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f1xx_hal.crf ..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal.c]
                          THUMB

                          AREA ||i.HAL_DBGMCU_DisableDBGSleepMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_DisableDBGSleepMode PROC
;;;433      */
;;;434    void HAL_DBGMCU_DisableDBGSleepMode(void)
000000  4802              LDR      r0,|L1.12|
;;;435    {
;;;436      CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
000002  6841              LDR      r1,[r0,#4]
000004  f0210101          BIC      r1,r1,#1
000008  6041              STR      r1,[r0,#4]
;;;437    }
00000a  4770              BX       lr
;;;438    
                          ENDP

                  |L1.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_DisableDBGStandbyMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_DisableDBGStandbyMode PROC
;;;511      */
;;;512    void HAL_DBGMCU_DisableDBGStandbyMode(void)
000000  4802              LDR      r0,|L2.12|
;;;513    {
;;;514      CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
000002  6841              LDR      r1,[r0,#4]
000004  f0210104          BIC      r1,r1,#4
000008  6041              STR      r1,[r0,#4]
;;;515    }
00000a  4770              BX       lr
;;;516    
                          ENDP

                  |L2.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_DisableDBGStopMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_DisableDBGStopMode PROC
;;;479      */
;;;480    void HAL_DBGMCU_DisableDBGStopMode(void)
000000  4802              LDR      r0,|L3.12|
;;;481    {
;;;482      CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
000002  6841              LDR      r1,[r0,#4]
000004  f0210102          BIC      r1,r1,#2
000008  6041              STR      r1,[r0,#4]
;;;483    }
00000a  4770              BX       lr
;;;484    
                          ENDP

                  |L3.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_EnableDBGSleepMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_EnableDBGSleepMode PROC
;;;417      */
;;;418    void HAL_DBGMCU_EnableDBGSleepMode(void)
000000  4802              LDR      r0,|L4.12|
;;;419    {
;;;420      SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
000002  6841              LDR      r1,[r0,#4]
000004  f0410101          ORR      r1,r1,#1
000008  6041              STR      r1,[r0,#4]
;;;421    }
00000a  4770              BX       lr
;;;422    
                          ENDP

                  |L4.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_EnableDBGStandbyMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_EnableDBGStandbyMode PROC
;;;495      */
;;;496    void HAL_DBGMCU_EnableDBGStandbyMode(void)
000000  4802              LDR      r0,|L5.12|
;;;497    {
;;;498      SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
000002  6841              LDR      r1,[r0,#4]
000004  f0410104          ORR      r1,r1,#4
000008  6041              STR      r1,[r0,#4]
;;;499    }
00000a  4770              BX       lr
;;;500    
                          ENDP

                  |L5.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_EnableDBGStopMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_EnableDBGStopMode PROC
;;;463      */
;;;464    void HAL_DBGMCU_EnableDBGStopMode(void)
000000  4802              LDR      r0,|L6.12|
;;;465    {
;;;466      SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
000002  6841              LDR      r1,[r0,#4]
000004  f0410102          ORR      r1,r1,#2
000008  6041              STR      r1,[r0,#4]
;;;467    }
00000a  4770              BX       lr
;;;468    
                          ENDP

                  |L6.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_DeInit PROC
;;;190      */
;;;191    HAL_StatusTypeDef HAL_DeInit(void)
000000  4806              LDR      r0,|L7.28|
;;;192    {
000002  b510              PUSH     {r4,lr}
;;;193      /* Reset of all peripherals */
;;;194      __HAL_RCC_APB1_FORCE_RESET();
000004  f04f31ff          MOV      r1,#0xffffffff
000008  60c1              STR      r1,[r0,#0xc]
;;;195      __HAL_RCC_APB1_RELEASE_RESET();
00000a  2200              MOVS     r2,#0
00000c  6102              STR      r2,[r0,#0x10]
;;;196    
;;;197      __HAL_RCC_APB2_FORCE_RESET();
00000e  60c1              STR      r1,[r0,#0xc]
;;;198      __HAL_RCC_APB2_RELEASE_RESET();
000010  60c2              STR      r2,[r0,#0xc]
;;;199    
;;;200    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;201      __HAL_RCC_AHB_FORCE_RESET();
;;;202      __HAL_RCC_AHB_RELEASE_RESET();
;;;203    #endif
;;;204      
;;;205      /* De-Init the low level hardware */
;;;206      HAL_MspDeInit();
000012  f7fffffe          BL       HAL_MspDeInit
;;;207        
;;;208      /* Return function status */
;;;209      return HAL_OK;
000016  2000              MOVS     r0,#0
;;;210    }
000018  bd10              POP      {r4,pc}
;;;211    
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      0x40021000

                          AREA ||i.HAL_Delay||, CODE, READONLY, ALIGN=1

                  HAL_Delay PROC
;;;324      */
;;;325    __weak void HAL_Delay(__IO uint32_t Delay)
000000  b531              PUSH     {r0,r4,r5,lr}
;;;326    {
;;;327      uint32_t tickstart = HAL_GetTick();
000002  f7fffffe          BL       HAL_GetTick
;;;328      uint32_t wait = Delay;
;;;329      
;;;330      /* Add a period to guarantee minimum wait */
;;;331      if (wait < HAL_MAX_DELAY)
000006  9c00              LDR      r4,[sp,#0]
000008  4605              MOV      r5,r0                 ;327
00000a  f1b43fff          CMP      r4,#0xffffffff
00000e  bf18              IT       NE
000010  1c64              ADDNE    r4,r4,#1
                  |L8.18|
;;;332      {
;;;333         wait++;
;;;334      }
;;;335      
;;;336      while((HAL_GetTick() - tickstart) < wait)
000012  f7fffffe          BL       HAL_GetTick
000016  1b40              SUBS     r0,r0,r5
000018  42a0              CMP      r0,r4
00001a  d3fa              BCC      |L8.18|
;;;337      {
;;;338      }
;;;339    }
00001c  bd38              POP      {r3-r5,pc}
;;;340    
                          ENDP


                          AREA ||i.HAL_GetDEVID||, CODE, READONLY, ALIGN=2

                  HAL_GetDEVID PROC
;;;408      */
;;;409    uint32_t HAL_GetDEVID(void)
000000  4802              LDR      r0,|L9.12|
;;;410    {
;;;411       return((DBGMCU->IDCODE) & IDCODE_DEVID_MASK);
000002  6800              LDR      r0,[r0,#0]
000004  f3c0000b          UBFX     r0,r0,#0,#12
;;;412    }
000008  4770              BX       lr
;;;413    
                          ENDP

00000a  0000              DCW      0x0000
                  |L9.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_GetHalVersion||, CODE, READONLY, ALIGN=2

                  HAL_GetHalVersion PROC
;;;376      */
;;;377    uint32_t HAL_GetHalVersion(void)
000000  4800              LDR      r0,|L10.4|
;;;378    {
;;;379     return __STM32F1xx_HAL_VERSION;
;;;380    }
000002  4770              BX       lr
;;;381    
                          ENDP

                  |L10.4|
                          DCD      0x01010100

                          AREA ||i.HAL_GetREVID||, CODE, READONLY, ALIGN=2

                  HAL_GetREVID PROC
;;;392      */
;;;393    uint32_t HAL_GetREVID(void)
000000  4801              LDR      r0,|L11.8|
;;;394    {
;;;395      return((DBGMCU->IDCODE) >> DBGMCU_IDCODE_REV_ID_Pos);
000002  6800              LDR      r0,[r0,#0]
000004  0c00              LSRS     r0,r0,#16
;;;396    }
000006  4770              BX       lr
;;;397    
                          ENDP

                  |L11.8|
                          DCD      0xe0042000

                          AREA ||i.HAL_GetTick||, CODE, READONLY, ALIGN=2

                  HAL_GetTick PROC
;;;308      */
;;;309    __weak uint32_t HAL_GetTick(void)
000000  4801              LDR      r0,|L12.8|
;;;310    {
;;;311      return uwTick;
000002  6800              LDR      r0,[r0,#0]  ; uwTick
;;;312    }
000004  4770              BX       lr
;;;313    
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      ||.data||

                          AREA ||i.HAL_GetUID||, CODE, READONLY, ALIGN=2

                  HAL_GetUID PROC
;;;521      */
;;;522    void HAL_GetUID(uint32_t *UID)
000000  4904              LDR      r1,|L13.20|
;;;523    {
;;;524      UID[0] = (uint32_t)(READ_REG(*((uint32_t *)UID_BASE)));
000002  6809              LDR      r1,[r1,#0]
;;;525      UID[1] = (uint32_t)(READ_REG(*((uint32_t *)(UID_BASE + 4U))));
000004  6001              STR      r1,[r0,#0]
000006  4904              LDR      r1,|L13.24|
000008  6809              LDR      r1,[r1,#0]
;;;526      UID[2] = (uint32_t)(READ_REG(*((uint32_t *)(UID_BASE + 8U))));
00000a  6041              STR      r1,[r0,#4]
00000c  4903              LDR      r1,|L13.28|
00000e  6809              LDR      r1,[r1,#0]
000010  6081              STR      r1,[r0,#8]
;;;527    }
000012  4770              BX       lr
;;;528    
                          ENDP

                  |L13.20|
                          DCD      0x1ffff7e8
                  |L13.24|
                          DCD      0x1ffff7ec
                  |L13.28|
                          DCD      0x1ffff7f0

                          AREA ||i.HAL_IncTick||, CODE, READONLY, ALIGN=2

                  HAL_IncTick PROC
;;;297      */
;;;298    __weak void HAL_IncTick(void)
000000  4802              LDR      r0,|L14.12|
;;;299    {
;;;300      uwTick++;
000002  6801              LDR      r1,[r0,#0]  ; uwTick
000004  1c49              ADDS     r1,r1,#1
000006  6001              STR      r1,[r0,#0]  ; uwTick
;;;301    }
000008  4770              BX       lr
;;;302    
                          ENDP

00000a  0000              DCW      0x0000
                  |L14.12|
                          DCD      ||.data||

                          AREA ||i.HAL_Init||, CODE, READONLY, ALIGN=2

                  HAL_Init PROC
;;;157      */
;;;158    HAL_StatusTypeDef HAL_Init(void)
000000  4807              LDR      r0,|L15.32|
;;;159    {
000002  b510              PUSH     {r4,lr}
;;;160      /* Configure Flash prefetch */
;;;161    #if (PREFETCH_ENABLE != 0)
;;;162    #if defined(STM32F101x6) || defined(STM32F101xB) || defined(STM32F101xE) || defined(STM32F101xG) || \
;;;163        defined(STM32F102x6) || defined(STM32F102xB) || \
;;;164        defined(STM32F103x6) || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG) || \
;;;165        defined(STM32F105xC) || defined(STM32F107xC)
;;;166    
;;;167      /* Prefetch buffer is not available on value line devices */
;;;168      __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
000004  6801              LDR      r1,[r0,#0]
000006  f0410110          ORR      r1,r1,#0x10
00000a  6001              STR      r1,[r0,#0]
;;;169    #endif
;;;170    #endif /* PREFETCH_ENABLE */
;;;171    
;;;172      /* Set Interrupt Group Priority */
;;;173      HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
00000c  2003              MOVS     r0,#3
00000e  f7fffffe          BL       HAL_NVIC_SetPriorityGrouping
;;;174    
;;;175      /* Use systick as time base source and configure 1ms tick (default clock after Reset is MSI) */
;;;176      HAL_InitTick(TICK_INT_PRIORITY);
000012  200f              MOVS     r0,#0xf
000014  f7fffffe          BL       HAL_InitTick
;;;177    
;;;178      /* Init the low level hardware */
;;;179      HAL_MspInit();
000018  f7fffffe          BL       HAL_MspInit
;;;180    
;;;181      /* Return function status */
;;;182      return HAL_OK;
00001c  2000              MOVS     r0,#0
;;;183    }
00001e  bd10              POP      {r4,pc}
;;;184    
                          ENDP

                  |L15.32|
                          DCD      0x40022000

                          AREA ||i.HAL_InitTick||, CODE, READONLY, ALIGN=2

                  HAL_InitTick PROC
;;;249      */
;;;250    __weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
000000  b510              PUSH     {r4,lr}
;;;251    {
000002  4604              MOV      r4,r0
;;;252      /*Configure the SysTick to have interrupt in 1ms time basis*/
;;;253      HAL_SYSTICK_Config(SystemCoreClock/1000U);
000004  4807              LDR      r0,|L16.36|
000006  f44f727a          MOV      r2,#0x3e8
00000a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000c  fbb0f0f2          UDIV     r0,r0,r2
000010  f7fffffe          BL       HAL_SYSTICK_Config
;;;254    
;;;255      /*Configure the SysTick IRQ priority */
;;;256      HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0U);
000014  2200              MOVS     r2,#0
000016  4621              MOV      r1,r4
000018  1e50              SUBS     r0,r2,#1
00001a  f7fffffe          BL       HAL_NVIC_SetPriority
;;;257    
;;;258      /* Return function status */
;;;259      return HAL_OK;
00001e  2000              MOVS     r0,#0
;;;260    }
000020  bd10              POP      {r4,pc}
;;;261    
                          ENDP

000022  0000              DCW      0x0000
                  |L16.36|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_MspDeInit PROC
;;;226      */
;;;227    __weak void HAL_MspDeInit(void)
000000  4770              BX       lr
;;;228    {
;;;229      /* NOTE : This function Should not be modified, when the callback is needed,
;;;230                the HAL_MspDeInit could be implemented in the user file
;;;231       */
;;;232    }
;;;233    
                          ENDP


                          AREA ||i.HAL_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_MspInit PROC
;;;215      */
;;;216    __weak void HAL_MspInit(void)
000000  4770              BX       lr
;;;217    {
;;;218      /* NOTE : This function Should not be modified, when the callback is needed,
;;;219                the HAL_MspInit could be implemented in the user file
;;;220       */
;;;221    }
;;;222    
                          ENDP


                          AREA ||i.HAL_ResumeTick||, CODE, READONLY, ALIGN=1

                  HAL_ResumeTick PROC
;;;366      */
;;;367    __weak void HAL_ResumeTick(void)
000000  f04f20e0          MOV      r0,#0xe000e000
;;;368    {
;;;369      /* Enable SysTick Interrupt */
;;;370      SET_BIT(SysTick->CTRL,SysTick_CTRL_TICKINT_Msk);
000004  6901              LDR      r1,[r0,#0x10]
000006  f0410102          ORR      r1,r1,#2
00000a  6101              STR      r1,[r0,#0x10]
;;;371    }
00000c  4770              BX       lr
;;;372    
                          ENDP


                          AREA ||i.HAL_SuspendTick||, CODE, READONLY, ALIGN=1

                  HAL_SuspendTick PROC
;;;350      */
;;;351    __weak void HAL_SuspendTick(void)
000000  f04f20e0          MOV      r0,#0xe000e000
;;;352    {
;;;353      /* Disable SysTick Interrupt */
;;;354      CLEAR_BIT(SysTick->CTRL,SysTick_CTRL_TICKINT_Msk);
000004  6901              LDR      r1,[r0,#0x10]
000006  f0210102          BIC      r1,r1,#2
00000a  6101              STR      r1,[r0,#0x10]
;;;355    }
00000c  4770              BX       lr
;;;356    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  uwTick
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F1_V1.6.0\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f1xx_hal_c_HAL_Init____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F1_V1.6.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___15_stm32f1xx_hal_c_HAL_Init____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f1xx_hal_c_HAL_Init____REVSH|
#line 402
|__asm___15_stm32f1xx_hal_c_HAL_Init____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f1xx_hal_c_HAL_Init____RRX|
#line 587
|__asm___15_stm32f1xx_hal_c_HAL_Init____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
