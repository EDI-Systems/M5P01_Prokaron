; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f1xx_hal_gpio.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f1xx_hal_gpio.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\STM32F1xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\STM32F1xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F103RET6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F10X_HD -DUSE_HAL_DRIVER -DSTM32F103xE -W --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f1xx_hal_gpio.crf ..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_gpio.c]
                          THUMB

                          AREA ||i.HAL_GPIO_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_DeInit PROC
;;;366      */
;;;367    void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
000000  2200              MOVS     r2,#0
;;;368    { 
;;;369      uint32_t position = 0x00U;
;;;370      uint32_t iocurrent = 0x00U;
;;;371      uint32_t tmp = 0x00U;
;;;372      __IO uint32_t *configregister; /* Store the address of CRL or CRH register based on pin number */
;;;373      uint32_t registeroffset = 0U;
;;;374     
;;;375      /* Check the parameters */
;;;376      assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
;;;377      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;378    
;;;379      /* Configure the port pins */
;;;380      while ((GPIO_Pin >> position) != 0U)
000002  2900              CMP      r1,#0
;;;381      {
;;;382        /* Get current io position */
;;;383        iocurrent = (GPIO_Pin) & (1U << position);
;;;384    
;;;385        if (iocurrent)
;;;386        {
;;;387          /*------------------------- GPIO Mode Configuration --------------------*/
;;;388          /* Check if the current bit belongs to first half or last half of the pin count number
;;;389           in order to address CRH or CRL register */
;;;390          configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
;;;391          registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2U) : ((position - 8U) << 2U);
;;;392          
;;;393          /* CRL/CRH default value is floating input(0x04) shifted to correct position */
;;;394          MODIFY_REG(*configregister, ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset ), GPIO_CRL_CNF0_0 << registeroffset);
;;;395          
;;;396          /* ODR default value is 0 */
;;;397          CLEAR_BIT(GPIOx->ODR, iocurrent);
;;;398          
;;;399          /*------------------------- EXTI Mode Configuration --------------------*/
;;;400          /* Clear the External Interrupt or Event for the current IO */
;;;401          
;;;402          tmp = AFIO->EXTICR[position >> 2U];
;;;403          tmp &= 0x0FU << (4U * (position & 0x03U));
;;;404          if(tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
;;;405          {
;;;406            tmp = 0x0FU << (4U * (position & 0x03U));
;;;407            CLEAR_BIT(AFIO->EXTICR[position >> 2U], tmp);
;;;408              
;;;409            /* Clear EXTI line configuration */
;;;410            CLEAR_BIT(EXTI->IMR, (uint32_t)iocurrent);
;;;411            CLEAR_BIT(EXTI->EMR, (uint32_t)iocurrent);
;;;412            
;;;413            /* Clear Rising Falling edge configuration */
;;;414            CLEAR_BIT(EXTI->RTSR, (uint32_t)iocurrent);
;;;415            CLEAR_BIT(EXTI->FTSR, (uint32_t)iocurrent);
;;;416          }
;;;417        }
;;;418        
;;;419        position++;
;;;420      }
;;;421    }
000004  bf08              IT       EQ
000006  4770              BXEQ     lr
000008  e92d4ff0          PUSH     {r4-r11,lr}           ;368
00000c  2701              MOVS     r7,#1                 ;383
00000e  f8df9128          LDR      r9,|L1.312|
000012  4e4a              LDR      r6,|L1.316|
000014  f04f0804          MOV      r8,#4                 ;394
000018  240f              MOVS     r4,#0xf               ;394
00001a  bf00              NOP                            ;383
                  |L1.28|
00001c  fa07f302          LSL      r3,r7,r2              ;383
000020  400b              ANDS     r3,r3,r1              ;383
000022  d07c              BEQ      |L1.286|
000024  f5b37f80          CMP      r3,#0x100             ;390
000028  bf34              ITE      CC                    ;390
00002a  4605              MOVCC    r5,r0                 ;390
00002c  1d05              ADDCS    r5,r0,#4              ;390
00002e  ea4f0c82          LSL      r12,r2,#2             ;390
000032  bf28              IT       CS                    ;390
000034  f1ac0c20          SUBCS    r12,r12,#0x20         ;390
000038  f8d5a000          LDR      r10,[r5,#0]           ;394
00003c  fa04fb0c          LSL      r11,r4,r12            ;394
000040  ea2a0a0b          BIC      r10,r10,r11           ;394
000044  fa08fc0c          LSL      r12,r8,r12            ;394
000048  ea4a0c0c          ORR      r12,r10,r12           ;394
00004c  f8c5c000          STR      r12,[r5,#0]           ;394
000050  f8d0c00c          LDR      r12,[r0,#0xc]         ;397
000054  ea2c0c03          BIC      r12,r12,r3            ;397
000058  f8c0c00c          STR      r12,[r0,#0xc]         ;397
00005c  f0220c03          BIC      r12,r2,#3             ;402
000060  f10c4580          ADD      r5,r12,#0x40000000    ;402
000064  f5053580          ADD      r5,r5,#0x10000        ;402
000068  f8d5b008          LDR      r11,[r5,#8]           ;402
00006c  ea4f7c82          LSL      r12,r2,#30            ;403
000070  ea4f7a1c          LSR      r10,r12,#28           ;403
000074  fa04fc0a          LSL      r12,r4,r10            ;403
000078  ea0c0b0b          AND      r11,r12,r11           ;403
00007c  4548              CMP      r0,r9                 ;404
00007e  bf08              IT       EQ                    ;404
000080  f04f0e00          MOVEQ    lr,#0                 ;404
000084  d028              BEQ      |L1.216|
000086  f1a04e80          SUB      lr,r0,#0x40000000     ;404
00008a  f5be3e86          SUBS     lr,lr,#0x10c00        ;404
00008e  bf08              IT       EQ                    ;404
000090  f04f0e01          MOVEQ    lr,#1                 ;404
000094  d020              BEQ      |L1.216|
000096  f1a04e80          SUB      lr,r0,#0x40000000     ;404
00009a  f5be3e88          SUBS     lr,lr,#0x11000        ;404
00009e  bf08              IT       EQ                    ;404
0000a0  f04f0e02          MOVEQ    lr,#2                 ;404
0000a4  d018              BEQ      |L1.216|
0000a6  f1a04e80          SUB      lr,r0,#0x40000000     ;404
0000aa  f5be3e8a          SUBS     lr,lr,#0x11400        ;404
0000ae  bf08              IT       EQ                    ;404
0000b0  f04f0e03          MOVEQ    lr,#3                 ;404
0000b4  d010              BEQ      |L1.216|
0000b6  f1a04e80          SUB      lr,r0,#0x40000000     ;404
0000ba  f5be3e8c          SUBS     lr,lr,#0x11800        ;404
0000be  bf08              IT       EQ                    ;404
0000c0  f04f0e04          MOVEQ    lr,#4                 ;404
0000c4  d008              BEQ      |L1.216|
0000c6  f1a04e80          SUB      lr,r0,#0x40000000     ;404
0000ca  f5be3e8e          SUBS     lr,lr,#0x11c00        ;404
0000ce  bf0c              ITE      EQ                    ;404
0000d0  f04f0e05          MOVEQ    lr,#5                 ;404
0000d4  f04f0e06          MOVNE    lr,#6                 ;404
                  |L1.216|
0000d8  fa0efa0a          LSL      r10,lr,r10            ;404
0000dc  45da              CMP      r10,r11               ;404
0000de  d123              BNE      |L1.296|
0000e0  f8d5a008          LDR      r10,[r5,#8]           ;407
0000e4  ea2a0c0c          BIC      r12,r10,r12           ;407
0000e8  f8c5c008          STR      r12,[r5,#8]           ;407
0000ec  f8d6c000          LDR      r12,[r6,#0]           ;410
0000f0  ea2c0c03          BIC      r12,r12,r3            ;410
0000f4  f8c6c000          STR      r12,[r6,#0]           ;410
0000f8  f8dfc044          LDR      r12,|L1.320|
0000fc  f8dc5000          LDR      r5,[r12,#0]           ;411
000100  439d              BICS     r5,r5,r3              ;411
000102  f8cc5000          STR      r5,[r12,#0]           ;411
000106  f10c0c04          ADD      r12,r12,#4            ;414
00010a  f8dc5000          LDR      r5,[r12,#0]           ;414
00010e  439d              BICS     r5,r5,r3              ;414
000110  f8cc5000          STR      r5,[r12,#0]           ;414
000114  f10c0c04          ADD      r12,r12,#4            ;415
000118  f8dc5000          LDR      r5,[r12,#0]           ;415
00011c  e000              B        |L1.288|
                  |L1.286|
00011e  e003              B        |L1.296|
                  |L1.288|
000120  ea250303          BIC      r3,r5,r3              ;415
000124  f8cc3000          STR      r3,[r12,#0]           ;415
                  |L1.296|
000128  1c52              ADDS     r2,r2,#1              ;415
00012a  fa31f302          LSRS     r3,r1,r2              ;380
00012e  f47faf75          BNE      |L1.28|
000132  e8bd8ff0          POP      {r4-r11,pc}
;;;422    
                          ENDP

000136  0000              DCW      0x0000
                  |L1.312|
                          DCD      0x40010800
                  |L1.316|
                          DCD      0x40010400
                  |L1.320|
                          DCD      0x40010404

                          AREA ||i.HAL_GPIO_EXTI_Callback||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_EXTI_Callback PROC
;;;570      */
;;;571    __weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
000000  4770              BX       lr
;;;572    {
;;;573      /* Prevent unused argument(s) compilation warning */
;;;574      UNUSED(GPIO_Pin);
;;;575      /* NOTE: This function Should not be modified, when the callback is needed,
;;;576               the HAL_GPIO_EXTI_Callback could be implemented in the user file
;;;577       */
;;;578    }
;;;579    
                          ENDP


                          AREA ||i.HAL_GPIO_EXTI_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_EXTI_IRQHandler PROC
;;;555      */
;;;556    void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
000000  4904              LDR      r1,|L3.20|
;;;557    {
;;;558      /* EXTI line interrupt detected */
;;;559      if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
000002  680a              LDR      r2,[r1,#0]
000004  4202              TST      r2,r0
;;;560      {
;;;561        __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
;;;562        HAL_GPIO_EXTI_Callback(GPIO_Pin);
;;;563      }
;;;564    }
000006  bf08              IT       EQ
000008  4770              BXEQ     lr
00000a  b510              PUSH     {r4,lr}               ;557
00000c  6008              STR      r0,[r1,#0]            ;561
00000e  f7fffffe          BL       HAL_GPIO_EXTI_Callback
000012  bd10              POP      {r4,pc}
;;;565    
                          ENDP

                  |L3.20|
                          DCD      0x40010414

                          AREA ||i.HAL_GPIO_Init||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_Init PROC
;;;195      */
;;;196    void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;197    {
;;;198      uint32_t position;
;;;199      uint32_t ioposition = 0x00U;
;;;200      uint32_t iocurrent = 0x00U;
;;;201      uint32_t temp = 0x00U;
;;;202      uint32_t config = 0x00U;
;;;203      __IO uint32_t *configregister; /* Store the address of CRL or CRH register based on pin number */
;;;204      uint32_t registeroffset = 0U; /* offset used during computation of CNF and MODE bits placement inside CRL or CRH register */
;;;205      
;;;206      /* Check the parameters */
;;;207      assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
;;;208      assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
;;;209      assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
;;;210    
;;;211      /* Configure the port pins */
;;;212      for (position = 0U; position < GPIO_NUMBER; position++)
;;;213      {
;;;214        /* Get the IO position */
;;;215        ioposition = (0x01U << position);
;;;216        
;;;217        /* Get the current IO position */
;;;218        iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
;;;219    
;;;220        if (iocurrent == ioposition)
;;;221        {
;;;222          /* Check the Alternate function parameters */
;;;223          assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
;;;224    
;;;225          /* Based on the required mode, filling config variable with MODEy[1:0] and CNFy[3:2] corresponding bits */
;;;226          switch (GPIO_Init->Mode)
;;;227          {
;;;228            /* If we are configuring the pin in OUTPUT push-pull mode */
;;;229            case GPIO_MODE_OUTPUT_PP:
;;;230              /* Check the GPIO speed parameter */
;;;231              assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
;;;232              config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_PP;
;;;233              break;
;;;234              
;;;235            /* If we are configuring the pin in OUTPUT open-drain mode */
;;;236            case GPIO_MODE_OUTPUT_OD:
;;;237              /* Check the GPIO speed parameter */
;;;238              assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
;;;239              config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_OD;
;;;240              break;
;;;241              
;;;242            /* If we are configuring the pin in ALTERNATE FUNCTION push-pull mode */
;;;243            case GPIO_MODE_AF_PP:
;;;244              /* Check the GPIO speed parameter */
;;;245              assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
;;;246              config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_PP;
;;;247              break;
;;;248              
;;;249            /* If we are configuring the pin in ALTERNATE FUNCTION open-drain mode */
;;;250            case GPIO_MODE_AF_OD:
;;;251              /* Check the GPIO speed parameter */
;;;252              assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
;;;253              config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_OD;
;;;254              break;
;;;255              
;;;256            /* If we are configuring the pin in INPUT (also applicable to EVENT and IT mode) */
;;;257            case GPIO_MODE_INPUT:
;;;258            case GPIO_MODE_IT_RISING:
;;;259            case GPIO_MODE_IT_FALLING:
;;;260            case GPIO_MODE_IT_RISING_FALLING:
;;;261            case GPIO_MODE_EVT_RISING:
;;;262            case GPIO_MODE_EVT_FALLING:
;;;263            case GPIO_MODE_EVT_RISING_FALLING:
;;;264              /* Check the GPIO pull parameter */
;;;265              assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
;;;266              if(GPIO_Init->Pull == GPIO_NOPULL)
;;;267              {  
;;;268                config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_FLOATING;
;;;269              }
;;;270              else if(GPIO_Init->Pull == GPIO_PULLUP)
;;;271              {
;;;272                config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
;;;273                
;;;274                /* Set the corresponding ODR bit */
;;;275                GPIOx->BSRR = ioposition;
;;;276              }
;;;277              else /* GPIO_PULLDOWN */
;;;278              {
;;;279                config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
;;;280                
;;;281                /* Reset the corresponding ODR bit */
;;;282                GPIOx->BRR = ioposition;
;;;283              }
;;;284              break; 
;;;285              
;;;286            /* If we are configuring the pin in INPUT analog mode */
;;;287            case GPIO_MODE_ANALOG:
;;;288                config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_ANALOG;
;;;289              break;
;;;290            
;;;291            /* Parameters are checked with assert_param */
;;;292            default:
;;;293              break;
;;;294          }
;;;295          
;;;296          /* Check if the current bit belongs to first half or last half of the pin count number
;;;297           in order to address CRH or CRL register*/
;;;298          configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
;;;299          registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2U) : ((position - 8U) << 2U);
;;;300          
;;;301          /* Apply the new configuration of the pin to the register */
;;;302          MODIFY_REG((*configregister), ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset ), (config << registeroffset));
;;;303          
;;;304          /*--------------------- EXTI Mode Configuration ------------------------*/
;;;305          /* Configure the External Interrupt or event for the current IO */
;;;306          if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
;;;307          {
;;;308            /* Enable AFIO Clock */
;;;309            __HAL_RCC_AFIO_CLK_ENABLE();
;;;310            temp = AFIO->EXTICR[position >> 2U];
;;;311            CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
;;;312            SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
;;;313            AFIO->EXTICR[position >> 2U] = temp;
;;;314            
;;;315    
;;;316            /* Configure the interrupt mask */
;;;317            if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
;;;318            {
;;;319              SET_BIT(EXTI->IMR, iocurrent); 
000004  4e7a              LDR      r6,|L4.496|
000006  f04f0c00          MOV      r12,#0                ;202
00000a  f8df91e0          LDR      r9,|L4.492|
00000e  4663              MOV      r3,r12                ;212
000010  f04f0801          MOV      r8,#1                 ;215
000014  270f              MOVS     r7,#0xf               ;302
;;;320            } 
;;;321            else
;;;322            {
;;;323              CLEAR_BIT(EXTI->IMR, iocurrent); 
;;;324            } 
;;;325            
;;;326            /* Configure the event mask */
;;;327            if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
;;;328            {
;;;329              SET_BIT(EXTI->EMR, iocurrent); 
000016  f1060e04          ADD      lr,r6,#4
00001a  bf00              NOP                            ;215
                  |L4.28|
00001c  680a              LDR      r2,[r1,#0]            ;218
00001e  fa08f403          LSL      r4,r8,r3              ;215
000022  4022              ANDS     r2,r2,r4              ;218
000024  42a2              CMP      r2,r4                 ;220
000026  d17c              BNE      |L4.290|
000028  684d              LDR      r5,[r1,#4]            ;226
00002a  f1a55a80          SUB      r10,r5,#0x10000000    ;226
00002e  f5aa1a88          SUB      r10,r10,#0x110000     ;226
000032  454d              CMP      r5,r9                 ;226
000034  f00080c8          BEQ.W    |L4.456|
000038  dc74              BGT      |L4.292|
00003a  2d03              CMP      r5,#3                 ;226
00003c  bf08              IT       EQ                    ;288
00003e  f04f0c00          MOVEQ    r12,#0                ;288
000042  d01b              BEQ      |L4.124|
000044  dc0d              BGT      |L4.98|
000046  2d00              CMP      r5,#0                 ;226
000048  d06d              BEQ      |L4.294|
00004a  2d01              CMP      r5,#1                 ;226
00004c  bf08              IT       EQ                    ;232
00004e  f8d1c00c          LDREQ    r12,[r1,#0xc]         ;232
000052  d013              BEQ      |L4.124|
000054  2d02              CMP      r5,#2                 ;226
000056  bf04              ITT      EQ                    ;246
000058  f8d1c00c          LDREQ    r12,[r1,#0xc]         ;246
00005c  f10c0c08          ADDEQ    r12,r12,#8            ;246
000060  e00c              B        |L4.124|
                  |L4.98|
000062  2d11              CMP      r5,#0x11              ;226
000064  bf04              ITT      EQ                    ;239
000066  f8d1c00c          LDREQ    r12,[r1,#0xc]         ;239
00006a  f10c0c04          ADDEQ    r12,r12,#4            ;239
00006e  d005              BEQ      |L4.124|
000070  2d12              CMP      r5,#0x12              ;226
000072  bf04              ITT      EQ                    ;253
000074  f8d1c00c          LDREQ    r12,[r1,#0xc]         ;253
000078  f10c0c0c          ADDEQ    r12,r12,#0xc          ;253
                  |L4.124|
00007c  f5b27f80          CMP      r2,#0x100             ;298
000080  bf34              ITE      CC                    ;298
000082  4605              MOVCC    r5,r0                 ;298
000084  1d05              ADDCS    r5,r0,#4              ;298
000086  ea4f0483          LSL      r4,r3,#2              ;298
00008a  bf28              IT       CS                    ;298
00008c  3c20              SUBCS    r4,r4,#0x20           ;298
00008e  f8d5a000          LDR      r10,[r5,#0]           ;302
000092  fa07fb04          LSL      r11,r7,r4             ;302
000096  ea2a0a0b          BIC      r10,r10,r11           ;302
00009a  fa0cf404          LSL      r4,r12,r4             ;302
00009e  ea4a0404          ORR      r4,r10,r4             ;302
0000a2  602c              STR      r4,[r5,#0]            ;302
0000a4  684c              LDR      r4,[r1,#4]            ;306
0000a6  f0145f80          TST      r4,#0x10000000        ;306
0000aa  d074              BEQ      |L4.406|
0000ac  4c51              LDR      r4,|L4.500|
0000ae  69a5              LDR      r5,[r4,#0x18]         ;309
0000b0  f0450501          ORR      r5,r5,#1              ;309
0000b4  61a5              STR      r5,[r4,#0x18]         ;309
0000b6  69a4              LDR      r4,[r4,#0x18]         ;309
0000b8  f0040401          AND      r4,r4,#1              ;309
0000bc  9400              STR      r4,[sp,#0]            ;310
0000be  f0230403          BIC      r4,r3,#3              ;310
0000c2  f1044580          ADD      r5,r4,#0x40000000     ;310
0000c6  f5053580          ADD      r5,r5,#0x10000        ;310
0000ca  f8d5a008          LDR      r10,[r5,#8]           ;310
0000ce  ea4f7483          LSL      r4,r3,#30             ;311
0000d2  ea4f7414          LSR      r4,r4,#28             ;311
0000d6  fa07fb04          LSL      r11,r7,r4             ;311
0000da  ea2a0a0b          BIC      r10,r10,r11           ;311
0000de  f1a04b80          SUB      r11,r0,#0x40000000    ;312
0000e2  f5bb3b84          SUBS     r11,r11,#0x10800      ;312
0000e6  d02c              BEQ      |L4.322|
0000e8  f1a04b80          SUB      r11,r0,#0x40000000    ;312
0000ec  f5bb3b86          SUBS     r11,r11,#0x10c00      ;312
0000f0  bf08              IT       EQ                    ;312
0000f2  f04f0b01          MOVEQ    r11,#1                ;312
0000f6  d024              BEQ      |L4.322|
0000f8  f1a04b80          SUB      r11,r0,#0x40000000    ;312
0000fc  f5bb3b88          SUBS     r11,r11,#0x11000      ;312
000100  bf08              IT       EQ                    ;312
000102  f04f0b02          MOVEQ    r11,#2                ;312
000106  d01c              BEQ      |L4.322|
000108  f1a04b80          SUB      r11,r0,#0x40000000    ;312
00010c  f5bb3b8a          SUBS     r11,r11,#0x11400      ;312
000110  bf08              IT       EQ                    ;312
000112  f04f0b03          MOVEQ    r11,#3                ;312
000116  d014              BEQ      |L4.322|
000118  f1a04b80          SUB      r11,r0,#0x40000000    ;312
00011c  f5bb3b8c          SUBS     r11,r11,#0x11800      ;312
000120  e002              B        |L4.296|
                  |L4.290|
000122  e038              B        |L4.406|
                  |L4.292|
000124  e03d              B        |L4.418|
                  |L4.294|
000126  e04f              B        |L4.456|
                  |L4.296|
000128  bf08              IT       EQ                    ;312
00012a  f04f0b04          MOVEQ    r11,#4                ;312
00012e  d008              BEQ      |L4.322|
000130  f1a04b80          SUB      r11,r0,#0x40000000    ;312
000134  f5bb3b8e          SUBS     r11,r11,#0x11c00      ;312
000138  bf0c              ITE      EQ                    ;312
00013a  f04f0b05          MOVEQ    r11,#5                ;312
00013e  f04f0b06          MOVNE    r11,#6                ;312
                  |L4.322|
000142  fa0bf404          LSL      r4,r11,r4             ;312
000146  ea44040a          ORR      r4,r4,r10             ;312
00014a  60ac              STR      r4,[r5,#8]            ;313
00014c  684c              LDR      r4,[r1,#4]            ;317
00014e  f4143f80          TST      r4,#0x10000           ;317
000152  6834              LDR      r4,[r6,#0]            ;323
000154  bf14              ITE      NE                    ;319
000156  4314              ORRNE    r4,r4,r2              ;319
000158  4394              BICEQ    r4,r4,r2              ;323
00015a  6034              STR      r4,[r6,#0]            ;323
00015c  684c              LDR      r4,[r1,#4]            ;327
00015e  f4143f00          TST      r4,#0x20000           ;327
;;;330            } 
;;;331            else
;;;332            {
;;;333              CLEAR_BIT(EXTI->EMR, iocurrent); 
000162  f8de4000          LDR      r4,[lr,#0]
000166  bf14              ITE      NE                    ;329
000168  4314              ORRNE    r4,r4,r2              ;329
00016a  4394              BICEQ    r4,r4,r2
00016c  f8ce4000          STR      r4,[lr,#0]
;;;334            }
;;;335            
;;;336            /* Enable or disable the rising trigger */
;;;337            if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
000170  684c              LDR      r4,[r1,#4]
000172  f4141f80          TST      r4,#0x100000
;;;338            {
;;;339              SET_BIT(EXTI->RTSR, iocurrent); 
;;;340            } 
;;;341            else
;;;342            {
;;;343              CLEAR_BIT(EXTI->RTSR, iocurrent); 
000176  4c20              LDR      r4,|L4.504|
000178  6825              LDR      r5,[r4,#0]
00017a  bf14              ITE      NE                    ;339
00017c  4315              ORRNE    r5,r5,r2              ;339
00017e  4395              BICEQ    r5,r5,r2
000180  6025              STR      r5,[r4,#0]
;;;344            }
;;;345            
;;;346            /* Enable or disable the falling trigger */
;;;347            if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
000182  684c              LDR      r4,[r1,#4]
000184  f4141f00          TST      r4,#0x200000
;;;348            {
;;;349              SET_BIT(EXTI->FTSR, iocurrent); 
;;;350            } 
;;;351            else
;;;352            {
;;;353              CLEAR_BIT(EXTI->FTSR, iocurrent); 
000188  4c1c              LDR      r4,|L4.508|
00018a  6825              LDR      r5,[r4,#0]
00018c  bf14              ITE      NE                    ;349
00018e  432a              ORRNE    r2,r2,r5              ;349
000190  ea250202          BICEQ    r2,r5,r2
000194  6022              STR      r2,[r4,#0]            ;349
                  |L4.406|
000196  1c5b              ADDS     r3,r3,#1              ;349
000198  2b10              CMP      r3,#0x10
00019a  f4ffaf3f          BCC      |L4.28|
;;;354            }
;;;355          }
;;;356        }
;;;357      }
;;;358    }
00019e  e8bd8ff8          POP      {r3-r11,pc}
                  |L4.418|
0001a2  f5ba1f88          CMP      r10,#0x110000         ;226
0001a6  d00f              BEQ      |L4.456|
0001a8  dc07              BGT      |L4.442|
0001aa  f5ba3f80          CMP      r10,#0x10000          ;226
0001ae  bf18              IT       NE                    ;226
0001b0  f5ba1f80          CMPNE    r10,#0x100000         ;226
0001b4  f47faf62          BNE      |L4.124|
0001b8  e006              B        |L4.456|
                  |L4.442|
0001ba  f5ba1f00          CMP      r10,#0x200000         ;226
0001be  bf18              IT       NE                    ;226
0001c0  f5ba1f04          CMPNE    r10,#0x210000         ;226
0001c4  f47faf5a          BNE      |L4.124|
                  |L4.456|
0001c8  f8d1c008          LDR      r12,[r1,#8]           ;266
0001cc  f1bc0f00          CMP      r12,#0                ;266
0001d0  bf08              IT       EQ                    ;268
0001d2  f04f0c04          MOVEQ    r12,#4                ;268
0001d6  f43faf51          BEQ      |L4.124|
0001da  f1bc0f01          CMP      r12,#1                ;270
0001de  f04f0c08          MOV      r12,#8                ;279
0001e2  bf0c              ITE      EQ                    ;275
0001e4  6104              STREQ    r4,[r0,#0x10]         ;275
0001e6  6144              STRNE    r4,[r0,#0x14]         ;282
0001e8  e748              B        |L4.124|
;;;359    
                          ENDP

0001ea  0000              DCW      0x0000
                  |L4.492|
                          DCD      0x10110000
                  |L4.496|
                          DCD      0x40010400
                  |L4.500|
                          DCD      0x40021000
                  |L4.504|
                          DCD      0x40010408
                  |L4.508|
                          DCD      0x4001040c

                          AREA ||i.HAL_GPIO_LockPin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_LockPin PROC
;;;521    */
;;;522    HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  b081              SUB      sp,sp,#4
;;;523    {
;;;524      __IO uint32_t tmp = GPIO_LCKR_LCKK;
;;;525    
;;;526      /* Check the parameters */
;;;527      assert_param(IS_GPIO_LOCK_INSTANCE(GPIOx));
;;;528      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;529    
;;;530      /* Apply lock key write sequence */
;;;531      SET_BIT(tmp, GPIO_Pin);
000002  f4413280          ORR      r2,r1,#0x10000
;;;532      /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
;;;533      GPIOx->LCKR = tmp;
000006  9200              STR      r2,[sp,#0]
000008  6182              STR      r2,[r0,#0x18]
;;;534      /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
;;;535      GPIOx->LCKR = GPIO_Pin;
00000a  6181              STR      r1,[r0,#0x18]
;;;536      /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
;;;537      GPIOx->LCKR = tmp;
00000c  9900              LDR      r1,[sp,#0]
00000e  6181              STR      r1,[r0,#0x18]
;;;538      /* Read LCKK bit*/
;;;539      tmp = GPIOx->LCKR;
000010  6981              LDR      r1,[r0,#0x18]
;;;540    
;;;541      if((uint32_t)(GPIOx->LCKR & GPIO_LCKR_LCKK))
000012  9100              STR      r1,[sp,#0]
000014  6980              LDR      r0,[r0,#0x18]
000016  f4103f80          TST      r0,#0x10000
;;;542      {
;;;543        return HAL_OK;
00001a  bf14              ITE      NE
00001c  2000              MOVNE    r0,#0
;;;544      }
;;;545      else
;;;546      {
;;;547        return HAL_ERROR;
00001e  2001              MOVEQ    r0,#1
;;;548      }
;;;549    }
000020  b001              ADD      sp,sp,#4
000022  4770              BX       lr
;;;550    
                          ENDP


                          AREA ||i.HAL_GPIO_ReadPin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_ReadPin PROC
;;;447      */
;;;448    GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  6880              LDR      r0,[r0,#8]
;;;449    {
;;;450      GPIO_PinState bitstatus;
;;;451    
;;;452      /* Check the parameters */
;;;453      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;454    
;;;455      if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
000002  4008              ANDS     r0,r0,r1
;;;456      {
;;;457        bitstatus = GPIO_PIN_SET;
000004  bf18              IT       NE
000006  2001              MOVNE    r0,#1
;;;458      }
;;;459      else
;;;460      {
;;;461        bitstatus = GPIO_PIN_RESET;
;;;462      }
;;;463      return bitstatus;
;;;464    }
000008  4770              BX       lr
;;;465    
                          ENDP


                          AREA ||i.HAL_GPIO_TogglePin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_TogglePin PROC
;;;503      */
;;;504    void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  68c2              LDR      r2,[r0,#0xc]
;;;505    {
;;;506      /* Check the parameters */
;;;507      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;508    
;;;509      GPIOx->ODR ^= GPIO_Pin;
000002  4051              EORS     r1,r1,r2
000004  60c1              STR      r1,[r0,#0xc]
;;;510    }
000006  4770              BX       lr
;;;511    
                          ENDP


                          AREA ||i.HAL_GPIO_WritePin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_WritePin PROC
;;;481      */
;;;482    void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
000000  2a00              CMP      r2,#0
;;;483    {
;;;484      /* Check the parameters */
;;;485      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;486      assert_param(IS_GPIO_PIN_ACTION(PinState));
;;;487    
;;;488      if(PinState != GPIO_PIN_RESET)
;;;489      {
;;;490        GPIOx->BSRR = GPIO_Pin;
;;;491      }
;;;492      else
;;;493      {
;;;494        GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
000002  bf08              IT       EQ
000004  0409              LSLEQ    r1,r1,#16
000006  6101              STR      r1,[r0,#0x10]
;;;495      }
;;;496    }
000008  4770              BX       lr
;;;497    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F1_V1.6.0\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_gpio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_gpio_c_ea787061____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F1_V1.6.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___20_stm32f1xx_hal_gpio_c_ea787061____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_gpio_c_ea787061____REVSH|
#line 402
|__asm___20_stm32f1xx_hal_gpio_c_ea787061____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_gpio_c_ea787061____RRX|
#line 587
|__asm___20_stm32f1xx_hal_gpio_c_ea787061____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
