; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\kernel.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\kernel.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\STM32F1xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\STM32F1xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F103RET6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F10X_HD -DUSE_HAL_DRIVER -DSTM32F103xE -W --enum_is_int --signed_chars --omf_browse=.\debug\output\kernel.crf ..\..\MProkaron\Kernel\kernel.c]
                          THUMB

                          AREA ||i.RMP_CRC16||, CODE, READONLY, ALIGN=2

                  RMP_CRC16 PROC
;;;264    #ifdef __U16__
;;;265    ptr_t RMP_CRC16(const u8* Data, ptr_t Length)
000000  b530              PUSH     {r4,r5,lr}
;;;266    {
000002  b0c1              SUB      sp,sp,#0x104
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;267        ptr_t Data_Cnt;
;;;268        u8 Index;
;;;269        u8 Temp_High;
;;;270        u8 Temp_Low;
;;;271        
;;;272        /* CRC16 constants with X^16+X^15+X^2+1 */
;;;273        static const u8 CRC16_High[256]=
;;;274        {
;;;275            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;276            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;277            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;278            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;279            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;280            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;281            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;282            0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;283            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;284            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;285            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;286            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;287            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;288            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;289            0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;290            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;291            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;292            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;293            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;294            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;295            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;296            0x00, 0xC1, 0x81, 0x40
;;;297        };
;;;298    
;;;299        const u8 CRC16_Low[256]=
000008  f44f7280          MOV      r2,#0x100
00000c  490c              LDR      r1,|L1.64|
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       __aeabi_memcpy4
;;;300        {
;;;301            0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,
;;;302            0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,
;;;303            0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9,
;;;304            0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,
;;;305            0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
;;;306            0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,
;;;307            0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,
;;;308            0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38,
;;;309            0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,
;;;310            0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
;;;311            0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,
;;;312            0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,
;;;313            0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB,
;;;314            0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,
;;;315            0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
;;;316            0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,
;;;317            0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,
;;;318            0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,
;;;319            0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89,
;;;320            0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
;;;321            0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83,
;;;322            0x41, 0x81, 0x80, 0x40
;;;323        };
;;;324    
;;;325        Temp_High=0xFF;
000014  23ff              MOVS     r3,#0xff
;;;326        Temp_Low=0xFF;
000016  461a              MOV      r2,r3
;;;327        for(Data_Cnt=0;Data_Cnt<Length;Data_Cnt++)
000018  2d00              CMP      r5,#0
00001a  bf1c              ITT      NE                    ;299
00001c  46ec              MOVNE    r12,sp                ;299
;;;328        {
;;;329            Index=Temp_Low^Data[Data_Cnt];
;;;330            Temp_Low=(u8)(Temp_High^CRC16_High[Index]);
00001e  4909              LDRNE    r1,|L1.68|
000020  d009              BEQ      |L1.54|
000022  bf00              NOP                            ;329
                  |L1.36|
000024  f8140b01          LDRB     r0,[r4],#1            ;329
000028  4050              EORS     r0,r0,r2              ;329
00002a  5c0a              LDRB     r2,[r1,r0]
00002c  405a              EORS     r2,r2,r3
;;;331            Temp_High=CRC16_Low[Index];
00002e  f81c3000          LDRB     r3,[r12,r0]
000032  1e6d              SUBS     r5,r5,#1
000034  d1f6              BNE      |L1.36|
                  |L1.54|
;;;332        }
;;;333    
;;;334        return (u16)(((u16)Temp_High)<<8|Temp_Low);
;;;335    }
000036  b041              ADD      sp,sp,#0x104
000038  ea422003          ORR      r0,r2,r3,LSL #8       ;334
00003c  bd30              POP      {r4,r5,pc}
;;;336    #endif
                          ENDP

00003e  0000              DCW      0x0000
                  |L1.64|
                          DCD      ||.constdata||+0x200
                  |L1.68|
                          DCD      ||.constdata||+0x100

                          AREA ||i.RMP_Clear||, CODE, READONLY, ALIGN=1

                  RMP_Clear PROC
;;;37     ******************************************************************************/
;;;38     void RMP_Clear(volatile void* Addr, ptr_t Size)
000000  b410              PUSH     {r4}
;;;39     {
;;;40         ptr_t* Word_Inc;
;;;41         u8* Byte_Inc;
;;;42         ptr_t Words;
;;;43         ptr_t Bytes;
;;;44         
;;;45         /* On processors not that fast, copy by word is really important */
;;;46         Word_Inc=(ptr_t*)Addr;
;;;47         for(Words=Size/sizeof(ptr_t);Words>0;Words--)
000002  088c              LSRS     r4,r1,#2
000004  2200              MOVS     r2,#0
000006  2903              CMP      r1,#3
000008  d910              BLS      |L2.44|
00000a  1f03              SUBS     r3,r0,#4
;;;48         {
;;;49             *Word_Inc=0;
;;;50             Word_Inc++;
;;;51         }
;;;52         
;;;53         /* Get the final bytes */
;;;54         Byte_Inc=(u8*)Word_Inc;
;;;55         for(Bytes=Size%sizeof(ptr_t);Bytes>0;Bytes--)
;;;56         {
;;;57             *Byte_Inc=0;
;;;58             Byte_Inc++;
;;;59         }
;;;60     }
00000c  f0140f01          TST      r4,#1
000010  bf18              IT       NE                    ;49
000012  f8432f04          STRNE    r2,[r3,#4]!           ;49
000016  ea5f0c64          ASRS     r12,r4,#1             ;47
00001a  d005              BEQ      |L2.40|
                  |L2.28|
00001c  605a              STR      r2,[r3,#4]            ;49
00001e  f8432f08          STR      r2,[r3,#8]!           ;49
000022  f1bc0c01          SUBS     r12,r12,#1            ;49
000026  d1f9              BNE      |L2.28|
                  |L2.40|
000028  eb000084          ADD      r0,r0,r4,LSL #2       ;51
                  |L2.44|
00002c  f0010303          AND      r3,r1,#3              ;55
000030  f0110f03          TST      r1,#3                 ;55
000034  bf04              ITT      EQ
000036  bc10              POPEQ    {r4}
000038  4770              BXEQ     lr
00003a  1e40              SUBS     r0,r0,#1
00003c  f0130f01          TST      r3,#1
000040  bf18              IT       NE                    ;57
000042  f8002f01          STRBNE   r2,[r0,#1]!           ;57
000046  0859              LSRS     r1,r3,#1              ;55
000048  bf04              ITT      EQ
00004a  bc10              POPEQ    {r4}
00004c  4770              BXEQ     lr
                  |L2.78|
00004e  7042              STRB     r2,[r0,#1]            ;57
000050  f8002f02          STRB     r2,[r0,#2]!           ;57
000054  1e49              SUBS     r1,r1,#1              ;57
000056  d1fa              BNE      |L2.78|
000058  bc10              POP      {r4}
00005a  4770              BX       lr
;;;61     /* End Function:RMP_Clear ****************************************************/
                          ENDP


                          AREA ||i.RMP_Free||, CODE, READONLY, ALIGN=1

                  RMP_Free PROC
;;;2080   ******************************************************************************/
;;;2081   void RMP_Free(volatile void* Pool, void* Mem_Ptr)
000000  4281              CMP      r1,r0
;;;2082   {
;;;2083       volatile struct RMP_Mem* Mem; 
;;;2084       volatile struct RMP_Mem_Head* Mem_Head;
;;;2085       volatile struct RMP_Mem_Head* Left_Head;
;;;2086       volatile struct RMP_Mem_Head* Right_Head;
;;;2087       cnt_t Merge_Left;
;;;2088   
;;;2089       /* See if the address is within the allocatable address range. If not, abort directly. */
;;;2090       Mem=(volatile struct RMP_Mem*)Pool;
;;;2091       if((((ptr_t)Mem_Ptr)<=((ptr_t)Mem))||(((ptr_t)Mem_Ptr)>=(((ptr_t)Mem)+Mem->Size)))
;;;2092           return;
;;;2093   
;;;2094       Mem_Head=(struct RMP_Mem_Head*)(((ptr_t)Mem_Ptr)-sizeof(struct RMP_Mem_Head));
;;;2095       /* See if the block can really be freed by this PID. If cannot, return directly */
;;;2096       if(Mem_Head->State==RMP_MEM_FREE)
;;;2097           return;
;;;2098   
;;;2099       /* Now we are sure that it can be freed. Delete it from the allocated list now */
;;;2100       RMP_List_Del(Mem_Head->Head.Prev,Mem_Head->Head.Next);
;;;2101       Mem_Head->State=RMP_MEM_FREE;
;;;2102       
;;;2103       /* Now check if we can merge it with the higher blocks */
;;;2104       Right_Head=(struct RMP_Mem_Head*)(((ptr_t)(Mem_Head->Tail))+sizeof(struct RMP_Mem_Tail));
;;;2105       if(((ptr_t)Right_Head)!=(((ptr_t)Mem)+Mem->Size))
;;;2106       {
;;;2107           /* If this one is unoccupied */
;;;2108           if((Right_Head->State)==RMP_MEM_FREE)
;;;2109           {
;;;2110               /* Delete, merge */
;;;2111               _RMP_Mem_Del(Pool,Right_Head);
;;;2112               _RMP_Mem_Block(Mem_Head,
;;;2113                              ((ptr_t)(Right_Head->Tail))+sizeof(struct RMP_Mem_Tail)-(ptr_t)Mem_Head);
;;;2114           }
;;;2115       }
;;;2116   
;;;2117       /* Now check if we can merge it with the lower blocks */
;;;2118       Merge_Left=0;
;;;2119       if((ptr_t)Mem_Head!=Mem->Start)
;;;2120       {
;;;2121           Left_Head=((struct RMP_Mem_Tail*)(((ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Tail)))->Head;
;;;2122   
;;;2123           /* If this one is unoccupied */
;;;2124           if(Left_Head->State==RMP_MEM_FREE)
;;;2125           {
;;;2126               /* Delete, merge */
;;;2127               _RMP_Mem_Del(Pool, Left_Head);
;;;2128               _RMP_Mem_Block(Left_Head,
;;;2129                              (ptr_t)((ptr_t)(Mem_Head->Tail)+sizeof(struct RMP_Mem_Tail)-(ptr_t)Left_Head));
;;;2130   
;;;2131               /* We have completed the merge here and the original block has destroyed.
;;;2132                * Thus there's no need to insert it into the list again */
;;;2133               Merge_Left=1;
;;;2134           }
;;;2135       }
;;;2136   
;;;2137       /* If we did not merge it with the left-side blocks, insert the original pointer's block 
;;;2138        * into the TLSF table(Merging with the right-side one won't disturb this) */
;;;2139       if(Merge_Left==0)
;;;2140           _RMP_Mem_Ins(Pool, Mem_Head);
;;;2141       else
;;;2142           _RMP_Mem_Ins(Pool, Left_Head);
;;;2143   }
000002  bf98              IT       LS
000004  4770              BXLS     lr
000006  e92d47f0          PUSH     {r4-r10,lr}           ;2082
00000a  6902              LDR      r2,[r0,#0x10]         ;2091
00000c  4604              MOV      r4,r0                 ;2082
00000e  1910              ADDS     r0,r2,r4              ;2091
000010  4288              CMP      r0,r1                 ;2091
000012  bf98              IT       LS
000014  e8bd87f0          POPLS    {r4-r10,pc}
000018  f1a10510          SUB      r5,r1,#0x10           ;2094
00001c  f8510c08          LDR      r0,[r1,#-8]           ;2096
000020  2800              CMP      r0,#0                 ;2096
000022  bf08              IT       EQ
000024  e8bd87f0          POPEQ    {r4-r10,pc}
000028  6828              LDR      r0,[r5,#0]            ;2100
00002a  6869              LDR      r1,[r5,#4]            ;2100
00002c  6008              STR      r0,[r1,#0]            ;2100
00002e  6041              STR      r1,[r0,#4]            ;2100
000030  f04f0800          MOV      r8,#0                 ;2101
000034  f8c58008          STR      r8,[r5,#8]            ;2101
000038  68e8              LDR      r0,[r5,#0xc]          ;2104
00003a  6921              LDR      r1,[r4,#0x10]         ;2105
00003c  1d06              ADDS     r6,r0,#4              ;2104
00003e  1908              ADDS     r0,r1,r4              ;2105
000040  2701              MOVS     r7,#1                 ;2105
000042  42b0              CMP      r0,r6                 ;2105
000044  d030              BEQ      |L3.168|
000046  68b0              LDR      r0,[r6,#8]            ;2108
000048  bb70              CBNZ     r0,|L3.168|
00004a  68f0              LDR      r0,[r6,#0xc]          ;2108
00004c  46a2              MOV      r10,r4                ;2111
00004e  1b80              SUBS     r0,r0,r6              ;2111
000050  f1a00910          SUB      r9,r0,#0x10           ;2111
000054  4648              MOV      r0,r9                 ;2111
000056  f7fffffe          BL       RMP_MSB_Get
00005a  1ec1              SUBS     r1,r0,#3              ;2111
00005c  fa29f101          LSR      r1,r9,r1              ;2111
000060  f0010107          AND      r1,r1,#7              ;2111
000064  1f80              SUBS     r0,r0,#6              ;2111
000066  eb0100c0          ADD      r0,r1,r0,LSL #3       ;2111
00006a  6832              LDR      r2,[r6,#0]            ;2111
00006c  eb0a01c0          ADD      r1,r10,r0,LSL #3      ;2111
000070  6873              LDR      r3,[r6,#4]            ;2111
000072  601a              STR      r2,[r3,#0]            ;2111
000074  6053              STR      r3,[r2,#4]            ;2111
000076  6aca              LDR      r2,[r1,#0x2c]         ;2111
000078  3128              ADDS     r1,r1,#0x28           ;2111
00007a  428a              CMP      r2,r1                 ;2111
00007c  d10a              BNE      |L3.148|
00007e  0941              LSRS     r1,r0,#5              ;2111
000080  eb0a0181          ADD      r1,r10,r1,LSL #2      ;2111
000084  694a              LDR      r2,[r1,#0x14]         ;2111
000086  f000000f          AND      r0,r0,#0xf            ;2111
00008a  fa07f000          LSL      r0,r7,r0              ;2111
00008e  ea220000          BIC      r0,r2,r0              ;2111
000092  6148              STR      r0,[r1,#0x14]         ;2111
                  |L3.148|
000094  68f0              LDR      r0,[r6,#0xc]          ;2112
000096  f8c58008          STR      r8,[r5,#8]            ;2112
00009a  1b40              SUBS     r0,r0,r5              ;2112
00009c  1d00              ADDS     r0,r0,#4              ;2112
00009e  4428              ADD      r0,r0,r5              ;2112
0000a0  1f00              SUBS     r0,r0,#4              ;2112
0000a2  60e8              STR      r0,[r5,#0xc]          ;2112
0000a4  68e8              LDR      r0,[r5,#0xc]          ;2112
0000a6  6005              STR      r5,[r0,#0]            ;2112
                  |L3.168|
0000a8  68e0              LDR      r0,[r4,#0xc]          ;2119
0000aa  42a8              CMP      r0,r5                 ;2119
0000ac  d003              BEQ      |L3.182|
0000ae  f8556c04          LDR      r6,[r5,#-4]           ;2121
0000b2  68b0              LDR      r0,[r6,#8]            ;2124
0000b4  b328              CBZ      r0,|L3.258|
                  |L3.182|
0000b6  68e8              LDR      r0,[r5,#0xc]          ;2124
0000b8  1b40              SUBS     r0,r0,r5              ;2124
0000ba  f1a00610          SUB      r6,r0,#0x10           ;2124
0000be  4630              MOV      r0,r6                 ;2124
0000c0  f7fffffe          BL       RMP_MSB_Get
0000c4  1ec1              SUBS     r1,r0,#3              ;2124
0000c6  fa26f101          LSR      r1,r6,r1              ;2124
0000ca  f0010107          AND      r1,r1,#7              ;2124
0000ce  1f80              SUBS     r0,r0,#6              ;2124
0000d0  eb0101c0          ADD      r1,r1,r0,LSL #3       ;2124
0000d4  eb0400c1          ADD      r0,r4,r1,LSL #3       ;2124
0000d8  6ac2              LDR      r2,[r0,#0x2c]         ;2124
0000da  3028              ADDS     r0,r0,#0x28           ;2124
0000dc  4282              CMP      r2,r0                 ;2124
0000de  d109              BNE      |L3.244|
0000e0  094a              LSRS     r2,r1,#5              ;2124
0000e2  eb040282          ADD      r2,r4,r2,LSL #2       ;2124
0000e6  6953              LDR      r3,[r2,#0x14]         ;2124
0000e8  f001010f          AND      r1,r1,#0xf            ;2124
0000ec  fa07f101          LSL      r1,r7,r1              ;2124
0000f0  4319              ORRS     r1,r1,r3              ;2124
0000f2  6151              STR      r1,[r2,#0x14]         ;2124
                  |L3.244|
0000f4  6841              LDR      r1,[r0,#4]            ;2124
0000f6  600d              STR      r5,[r1,#0]            ;2124
0000f8  6069              STR      r1,[r5,#4]            ;2124
0000fa  6028              STR      r0,[r5,#0]            ;2124
0000fc  6045              STR      r5,[r0,#4]            ;2124
0000fe  e8bd87f0          POP      {r4-r10,pc}
                  |L3.258|
000102  68f0              LDR      r0,[r6,#0xc]
000104  1b80              SUBS     r0,r0,r6
000106  f1a00910          SUB      r9,r0,#0x10
00010a  4648              MOV      r0,r9
00010c  f7fffffe          BL       RMP_MSB_Get
000110  1ec1              SUBS     r1,r0,#3
000112  fa29f101          LSR      r1,r9,r1
000116  f0010107          AND      r1,r1,#7
00011a  1f80              SUBS     r0,r0,#6
00011c  eb0100c0          ADD      r0,r1,r0,LSL #3
000120  6832              LDR      r2,[r6,#0]
000122  eb0401c0          ADD      r1,r4,r0,LSL #3
000126  6873              LDR      r3,[r6,#4]
000128  601a              STR      r2,[r3,#0]
00012a  6053              STR      r3,[r2,#4]
00012c  6aca              LDR      r2,[r1,#0x2c]
00012e  3128              ADDS     r1,r1,#0x28
000130  428a              CMP      r2,r1
000132  d10a              BNE      |L3.330|
000134  0942              LSRS     r2,r0,#5
000136  eb040182          ADD      r1,r4,r2,LSL #2
00013a  694a              LDR      r2,[r1,#0x14]
00013c  f000000f          AND      r0,r0,#0xf
000140  fa07f000          LSL      r0,r7,r0
000144  ea220000          BIC      r0,r2,r0
000148  6148              STR      r0,[r1,#0x14]
                  |L3.330|
00014a  68e8              LDR      r0,[r5,#0xc]          ;2128
00014c  f8c68008          STR      r8,[r6,#8]            ;2128
000150  1b80              SUBS     r0,r0,r6              ;2128
000152  1d00              ADDS     r0,r0,#4              ;2128
000154  4430              ADD      r0,r0,r6              ;2128
000156  1f00              SUBS     r0,r0,#4              ;2128
000158  60f0              STR      r0,[r6,#0xc]          ;2128
00015a  68f0              LDR      r0,[r6,#0xc]          ;2128
00015c  6006              STR      r6,[r0,#0]            ;2128
00015e  68f0              LDR      r0,[r6,#0xc]          ;2128
000160  1b80              SUBS     r0,r0,r6              ;2128
000162  f1a00510          SUB      r5,r0,#0x10           ;2128
000166  4628              MOV      r0,r5                 ;2128
000168  f7fffffe          BL       RMP_MSB_Get
00016c  1ec1              SUBS     r1,r0,#3              ;2128
00016e  fa25f101          LSR      r1,r5,r1              ;2128
000172  f0010107          AND      r1,r1,#7              ;2128
000176  1f80              SUBS     r0,r0,#6              ;2128
000178  eb0101c0          ADD      r1,r1,r0,LSL #3       ;2128
00017c  eb0400c1          ADD      r0,r4,r1,LSL #3       ;2128
000180  6ac2              LDR      r2,[r0,#0x2c]         ;2128
000182  3028              ADDS     r0,r0,#0x28           ;2128
000184  4282              CMP      r2,r0                 ;2128
000186  d109              BNE      |L3.412|
000188  094a              LSRS     r2,r1,#5              ;2133
00018a  eb040282          ADD      r2,r4,r2,LSL #2       ;2133
00018e  6953              LDR      r3,[r2,#0x14]         ;2133
000190  f001010f          AND      r1,r1,#0xf            ;2133
000194  fa07f101          LSL      r1,r7,r1              ;2133
000198  4319              ORRS     r1,r1,r3              ;2133
00019a  6151              STR      r1,[r2,#0x14]         ;2133
                  |L3.412|
00019c  6841              LDR      r1,[r0,#4]            ;2133
00019e  600e              STR      r6,[r1,#0]            ;2133
0001a0  6071              STR      r1,[r6,#4]            ;2133
0001a2  6030              STR      r0,[r6,#0]            ;2133
0001a4  6046              STR      r6,[r0,#4]            ;2133
0001a6  e8bd87f0          POP      {r4-r10,pc}
;;;2144   /* End Function:RMP_Free *****************************************************/
                          ENDP


                          AREA ||i.RMP_Init||, CODE, READONLY, ALIGN=2

                  RMP_Init PROC
;;;1592   ******************************************************************************/
;;;1593   void RMP_Init(void)
000000  20ff              MOVS     r0,#0xff
000002  f7fffffe          BL       RMP_Mask_Int
000006  4808              LDR      r0,|L4.40|
000008  2101              MOVS     r1,#1
00000a  60c1              STR      r1,[r0,#0xc]  ; RMP_Sched_Locked
00000c  6881              LDR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
00000e  1c49              ADDS     r1,r1,#1
000010  6081              STR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
;;;1594   {
;;;1595       RMP_Lock_Sched();
;;;1596       
;;;1597       /* Platform will use this hook to do something */
;;;1598       _RMP_Plat_Hook();
000012  f7fffffe          BL       _RMP_Plat_Hook
;;;1599       /* Start the second thread here */
;;;1600       RMP_Init_Hook();
000016  f7fffffe          BL       RMP_Init_Hook
;;;1601       
;;;1602       RMP_Unlock_Sched();
00001a  f7fffffe          BL       RMP_Unlock_Sched
;;;1603       
;;;1604       while(1)
;;;1605       {
;;;1606           RMP_Init_Idle();
00001e  bf00              NOP      
                  |L4.32|
000020  f7fffffe          BL       RMP_Init_Idle
000024  e7fc              B        |L4.32|
;;;1607       };
;;;1608   }
;;;1609   /* End Function:RMP_Init *****************************************************/
                          ENDP

000026  0000              DCW      0x0000
                  |L4.40|
                          DCD      ||.data||

                          AREA ||i.RMP_LSB_Get||, CODE, READONLY, ALIGN=2

                  RMP_LSB_Get PROC
;;;1733   ******************************************************************************/
;;;1734   ptr_t RMP_LSB_Get(ptr_t Val)
000000  4a0c              LDR      r2,|L5.52|
;;;1735   {
000002  b510              PUSH     {r4,lr}
000004  0e03              LSRS     r3,r0,#24
000006  4601              MOV      r1,r0
000008  5cd3              LDRB     r3,[r2,r3]
00000a  f3630007          BFI      r0,r3,#0,#8
00000e  f3c14307          UBFX     r3,r1,#16,#8
000012  5cd3              LDRB     r3,[r2,r3]
000014  f363200f          BFI      r0,r3,#8,#8
000018  f3c12307          UBFX     r3,r1,#8,#8
00001c  b2c9              UXTB     r1,r1
00001e  5cd3              LDRB     r3,[r2,r3]
000020  5c51              LDRB     r1,[r2,r1]
000022  f3634017          BFI      r0,r3,#16,#8
000026  f361601f          BFI      r0,r1,#24,#8
;;;1736   #if(RMP_WORD_ORDER==4)
;;;1737       return 15-RMP_MSB_Get(RMP_RBIT_Get(Val));
;;;1738   #elif(RMP_WORD_ORDER==5)
;;;1739       return 31-RMP_MSB_Get(RMP_RBIT_Get(Val));
00002a  f7fffffe          BL       RMP_MSB_Get
00002e  f1c0001f          RSB      r0,r0,#0x1f
;;;1740   #else
;;;1741       return 63-RMP_MSB_Get(RMP_RBIT_Get(Val));
;;;1742   #endif 
;;;1743   }
000032  bd10              POP      {r4,pc}
;;;1744   /* End Function:RMP_LSB_Get **************************************************/
                          ENDP

                  |L5.52|
                          DCD      ||.constdata||

                          AREA ||i.RMP_List_Crt||, CODE, READONLY, ALIGN=1

                  RMP_List_Crt PROC
;;;215    ******************************************************************************/
;;;216    void RMP_List_Crt(volatile struct RMP_List* Head)
000000  6000              STR      r0,[r0,#0]
;;;217    {
;;;218        Head->Prev=(struct RMP_List*)Head;
;;;219        Head->Next=(struct RMP_List*)Head;
000002  6040              STR      r0,[r0,#4]
;;;220    }
000004  4770              BX       lr
;;;221    /* End Function:RMP_List_Crt *************************************************/
                          ENDP


                          AREA ||i.RMP_List_Del||, CODE, READONLY, ALIGN=1

                  RMP_List_Del PROC
;;;229    ******************************************************************************/
;;;230    void RMP_List_Del(volatile struct RMP_List* Prev,volatile struct RMP_List* Next)
000000  6008              STR      r0,[r1,#0]
;;;231    {
;;;232        Next->Prev=(struct RMP_List*)Prev;
;;;233        Prev->Next=(struct RMP_List*)Next;
000002  6041              STR      r1,[r0,#4]
;;;234    }
000004  4770              BX       lr
;;;235    /* End Function:RMP_List_Del *************************************************/
                          ENDP


                          AREA ||i.RMP_List_Ins||, CODE, READONLY, ALIGN=1

                  RMP_List_Ins PROC
;;;244    ******************************************************************************/
;;;245    void RMP_List_Ins(volatile struct RMP_List* New,
000000  6010              STR      r0,[r2,#0]
;;;246                      volatile struct RMP_List* Prev,
;;;247                      volatile struct RMP_List* Next)
;;;248    {
;;;249        Next->Prev=(struct RMP_List*)New;
;;;250        New->Next=(struct RMP_List*)Next;
000002  6042              STR      r2,[r0,#4]
;;;251        New->Prev=(struct RMP_List*)Prev;
000004  6001              STR      r1,[r0,#0]
;;;252        Prev->Next=(struct RMP_List*)New;
000006  6048              STR      r0,[r1,#4]
;;;253    }
000008  4770              BX       lr
;;;254    /* End Function:RMP_List_Ins *************************************************/
                          ENDP


                          AREA ||i.RMP_Load_Ctx||, CODE, READONLY, ALIGN=1

                  RMP_Load_Ctx PROC
;;;1560   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1561   void RMP_Load_Ctx(void)
000000  4770              BX       lr
;;;1562   {
;;;1563       return;
;;;1564   }
;;;1565   #endif
                          ENDP


                          AREA ||i.RMP_Lock_Sched||, CODE, READONLY, ALIGN=2

                  RMP_Lock_Sched PROC
;;;345    ******************************************************************************/
;;;346    void RMP_Lock_Sched(void)
000000  b510              PUSH     {r4,lr}
;;;347    {
;;;348        RMP_MASK_INT();
000002  20ff              MOVS     r0,#0xff
000004  f7fffffe          BL       RMP_Mask_Int
;;;349        RMP_Sched_Locked=1;
000008  4803              LDR      r0,|L10.24|
00000a  2101              MOVS     r1,#1
00000c  60c1              STR      r1,[r0,#0xc]  ; RMP_Sched_Locked
;;;350        RMP_Sched_Lock_Cnt++;
00000e  6881              LDR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
000010  1c49              ADDS     r1,r1,#1
000012  6081              STR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
;;;351    }
000014  bd10              POP      {r4,pc}
;;;352    /* End Function:RMP_Lock_Sched ***********************************************/
                          ENDP

000016  0000              DCW      0x0000
                  |L10.24|
                          DCD      ||.data||

                          AREA ||i.RMP_Malloc||, CODE, READONLY, ALIGN=2

                  RMP_Malloc PROC
;;;2018   ******************************************************************************/
;;;2019   void* RMP_Malloc(volatile void* Pool, ptr_t Size)                                                       
000000  2900              CMP      r1,#0
;;;2020   {    
;;;2021       cnt_t FLI_Level;
;;;2022       cnt_t SLI_Level;
;;;2023       volatile struct RMP_Mem* Mem;
;;;2024       ptr_t Old_Size;
;;;2025       volatile struct RMP_Mem_Head* Mem_Head;
;;;2026       ptr_t Rounded_Size;
;;;2027       volatile struct RMP_Mem_Head* New_Mem;
;;;2028       ptr_t New_Size;
;;;2029       
;;;2030       if(Size==0)
;;;2031           return (void*)(0);
000002  bf04              ITT      EQ
000004  2000              MOVEQ    r0,#0
;;;2032       
;;;2033       /* Round up the size:a multiple of 8 and bigger than 64B. In fact, we will add
;;;2034        * extra 8 bytes at the end if the size is a multiple of 8 for safety. */
;;;2035       Rounded_Size=(((Size-1)>>3)+1)<<3;
;;;2036       /* See if it is smaller than the smallest block */
;;;2037       Rounded_Size=(Rounded_Size>64)?Rounded_Size:64;
;;;2038   
;;;2039       /* See if such block exists, if not, abort */
;;;2040       if(_RMP_Mem_Search(Pool,Rounded_Size,&FLI_Level,&SLI_Level)!=0)
;;;2041           return (void*)(0);
;;;2042       
;;;2043       Mem=(volatile struct RMP_Mem*)Pool;
;;;2044       
;;;2045       /* There is such block. Get it and delete it from the TLSF list. */
;;;2046       Mem_Head=(struct RMP_Mem_Head*)(Mem->Table[RMP_MEM_POS(FLI_Level,SLI_Level)].Next);
;;;2047       _RMP_Mem_Del(Pool, Mem_Head);
;;;2048   
;;;2049       /* Allocate and calculate if the space left could be big enough to be a new 
;;;2050        * block. If so, we will put the block back into the TLSF table */
;;;2051       New_Size=(ptr_t)(Mem_Head->Tail)-((ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Head)-Rounded_Size;
;;;2052       if(New_Size>=sizeof(struct RMP_Mem_Head)+64+sizeof(struct RMP_Mem_Tail))
;;;2053       {
;;;2054           Old_Size=sizeof(struct RMP_Mem_Head)+Rounded_Size+sizeof(struct RMP_Mem_Tail);
;;;2055           New_Mem=(volatile struct RMP_Mem_Head*)(((ptr_t)Mem_Head)+Old_Size);
;;;2056   
;;;2057           _RMP_Mem_Block(Mem_Head, Old_Size);
;;;2058           _RMP_Mem_Block(New_Mem, New_Size);
;;;2059   
;;;2060           /* Put the extra block back */
;;;2061           _RMP_Mem_Ins(Pool, New_Mem);
;;;2062       }
;;;2063   
;;;2064       /* Insert the allocated block into the lists */
;;;2065       RMP_List_Ins(&(Mem_Head->Head),&(Mem->Alloc),Mem->Alloc.Next);
;;;2066       Mem_Head->State=RMP_MEM_USED;
;;;2067   
;;;2068       /* Finally, return the start address */
;;;2069       return (void*)(((ptr_t)Mem_Head)+sizeof(struct RMP_Mem_Head));
;;;2070   }
000006  4770              BXEQ     lr
000008  e92d5ff0          PUSH     {r4-r12,lr}           ;2020
00000c  4605              MOV      r5,r0                 ;2020
00000e  1e48              SUBS     r0,r1,#1              ;2035
000010  08c0              LSRS     r0,r0,#3              ;2035
000012  00c0              LSLS     r0,r0,#3              ;2035
000014  2701              MOVS     r7,#1                 ;2035
000016  f1000608          ADD      r6,r0,#8              ;2035
00001a  2e40              CMP      r6,#0x40              ;2037
00001c  bf98              IT       LS                    ;2037
00001e  2640              MOVLS    r6,#0x40              ;2037
000020  4630              MOV      r0,r6                 ;2037
000022  f7fffffe          BL       RMP_MSB_Get
000026  1f80              SUBS     r0,r0,#6              ;2037
000028  2140              MOVS     r1,#0x40              ;2037
00002a  4081              LSLS     r1,r1,r0              ;2037
00002c  42b1              CMP      r1,r6                 ;2037
00002e  f1000203          ADD      r2,r0,#3              ;2037
000032  fa26f102          LSR      r1,r6,r2              ;2037
000036  f0010107          AND      r1,r1,#7              ;2037
00003a  d004              BEQ      |L11.70|
00003c  1c49              ADDS     r1,r1,#1              ;2037
00003e  2908              CMP      r1,#8                 ;2037
000040  bf04              ITT      EQ                    ;2037
000042  2100              MOVEQ    r1,#0                 ;2037
000044  1c40              ADDEQ    r0,r0,#1              ;2037
                  |L11.70|
000046  46a9              MOV      r9,r5                 ;2037
000048  68aa              LDR      r2,[r5,#8]            ;2037
00004a  4290              CMP      r0,r2                 ;2037
00004c  f08080d1          BCS.W    |L11.498|
000050  eb0104c0          ADD      r4,r1,r0,LSL #3       ;2037
000054  1160              ASRS     r0,r4,#5              ;2037
000056  eb090080          ADD      r0,r9,r0,LSL #2       ;2037
00005a  6940              LDR      r0,[r0,#0x14]         ;2037
00005c  f0040b0f          AND      r11,r4,#0xf           ;2037
000060  fa20f10b          LSR      r1,r0,r11             ;2037
000064  f8dfa190          LDR      r10,|L11.504|
000068  0e0a              LSRS     r2,r1,#24             ;2037
00006a  f81a2002          LDRB     r2,[r10,r2]           ;2037
00006e  f3620007          BFI      r0,r2,#0,#8           ;2037
000072  f3c14207          UBFX     r2,r1,#16,#8          ;2037
000076  f81a2002          LDRB     r2,[r10,r2]           ;2037
00007a  f362200f          BFI      r0,r2,#8,#8           ;2037
00007e  f3c12207          UBFX     r2,r1,#8,#8           ;2037
000082  b2c9              UXTB     r1,r1                 ;2037
000084  f81a2002          LDRB     r2,[r10,r2]           ;2037
000088  f81a1001          LDRB     r1,[r10,r1]           ;2037
00008c  f3624017          BFI      r0,r2,#16,#8          ;2037
000090  f361601f          BFI      r0,r1,#24,#8          ;2037
000094  f7fffffe          BL       RMP_MSB_Get
000098  f1c0001f          RSB      r0,r0,#0x1f           ;2037
00009c  f04f0800          MOV      r8,#0                 ;2037
0000a0  2820              CMP      r0,#0x20              ;2037
0000a2  d205              BCS      |L11.176|
0000a4  f024010f          BIC      r1,r4,#0xf            ;2037
0000a8  4408              ADD      r0,r0,r1              ;2037
0000aa  4458              ADD      r0,r0,r11             ;2037
0000ac  10c1              ASRS     r1,r0,#3              ;2037
0000ae  e028              B        |L11.258|
                  |L11.176|
0000b0  eb071464          ADD      r4,r7,r4,ASR #5       ;2037
0000b4  2c05              CMP      r4,#5                 ;2037
0000b6  da7d              BGE      |L11.436|
                  |L11.184|
0000b8  eb090084          ADD      r0,r9,r4,LSL #2       ;2037
0000bc  6940              LDR      r0,[r0,#0x14]         ;2037
0000be  2800              CMP      r0,#0                 ;2037
0000c0  d079              BEQ      |L11.438|
0000c2  eb090084          ADD      r0,r9,r4,LSL #2       ;2037
0000c6  6941              LDR      r1,[r0,#0x14]         ;2037
0000c8  0e0a              LSRS     r2,r1,#24             ;2037
0000ca  f81a2002          LDRB     r2,[r10,r2]           ;2037
0000ce  f3620007          BFI      r0,r2,#0,#8           ;2037
0000d2  f3c14207          UBFX     r2,r1,#16,#8          ;2037
0000d6  f81a2002          LDRB     r2,[r10,r2]           ;2037
0000da  f362200f          BFI      r0,r2,#8,#8           ;2037
0000de  f3c12207          UBFX     r2,r1,#8,#8           ;2037
0000e2  b2c9              UXTB     r1,r1                 ;2037
0000e4  f81a2002          LDRB     r2,[r10,r2]           ;2037
0000e8  f81a1001          LDRB     r1,[r10,r1]           ;2037
0000ec  f3624017          BFI      r0,r2,#16,#8          ;2037
0000f0  f361601f          BFI      r0,r1,#24,#8          ;2037
0000f4  f7fffffe          BL       RMP_MSB_Get
0000f8  f1c0001f          RSB      r0,r0,#0x1f           ;2037
0000fc  eb001144          ADD      r1,r0,r4,LSL #5       ;2037
000100  08c9              LSRS     r1,r1,#3              ;2037
                  |L11.258|
000102  f0000007          AND      r0,r0,#7              ;2037
000106  eb0000c1          ADD      r0,r0,r1,LSL #3       ;2046
00010a  eb0500c0          ADD      r0,r5,r0,LSL #3       ;2046
00010e  6ac4              LDR      r4,[r0,#0x2c]         ;2046
000110  68e0              LDR      r0,[r4,#0xc]          ;2046
000112  1b00              SUBS     r0,r0,r4              ;2046
000114  f1a00910          SUB      r9,r0,#0x10           ;2046
000118  4648              MOV      r0,r9                 ;2046
00011a  f7fffffe          BL       RMP_MSB_Get
00011e  1ec1              SUBS     r1,r0,#3              ;2046
000120  fa29f101          LSR      r1,r9,r1              ;2046
000124  f0010107          AND      r1,r1,#7              ;2046
000128  1f80              SUBS     r0,r0,#6              ;2046
00012a  eb0100c0          ADD      r0,r1,r0,LSL #3       ;2046
00012e  eb0501c0          ADD      r1,r5,r0,LSL #3       ;2046
000132  f1010328          ADD      r3,r1,#0x28           ;2046
000136  6821              LDR      r1,[r4,#0]            ;2046
000138  6862              LDR      r2,[r4,#4]            ;2046
00013a  6011              STR      r1,[r2,#0]            ;2046
00013c  604a              STR      r2,[r1,#4]            ;2046
00013e  6859              LDR      r1,[r3,#4]            ;2046
000140  4299              CMP      r1,r3                 ;2046
000142  d10a              BNE      |L11.346|
000144  0942              LSRS     r2,r0,#5              ;2046
000146  eb050182          ADD      r1,r5,r2,LSL #2       ;2046
00014a  694a              LDR      r2,[r1,#0x14]         ;2046
00014c  f000000f          AND      r0,r0,#0xf            ;2046
000150  fa07f000          LSL      r0,r7,r0              ;2046
000154  ea220000          BIC      r0,r2,r0              ;2046
000158  6148              STR      r0,[r1,#0x14]         ;2046
                  |L11.346|
00015a  68e0              LDR      r0,[r4,#0xc]          ;2051
00015c  1b00              SUBS     r0,r0,r4              ;2051
00015e  1b80              SUBS     r0,r0,r6              ;2051
000160  3810              SUBS     r0,r0,#0x10           ;2051
000162  2854              CMP      r0,#0x54              ;2052
000164  d337              BCC      |L11.470|
000166  f1060114          ADD      r1,r6,#0x14           ;2054
00016a  1866              ADDS     r6,r4,r1              ;2055
00016c  f8c48008          STR      r8,[r4,#8]            ;2055
000170  1f31              SUBS     r1,r6,#4              ;2055
000172  60e1              STR      r1,[r4,#0xc]          ;2055
000174  68e1              LDR      r1,[r4,#0xc]          ;2055
000176  600c              STR      r4,[r1,#0]            ;2055
000178  f8c68008          STR      r8,[r6,#8]            ;2055
00017c  4430              ADD      r0,r0,r6              ;2055
00017e  1f00              SUBS     r0,r0,#4              ;2055
000180  60f0              STR      r0,[r6,#0xc]          ;2055
000182  68f0              LDR      r0,[r6,#0xc]          ;2055
000184  6006              STR      r6,[r0,#0]            ;2055
000186  68f0              LDR      r0,[r6,#0xc]          ;2055
000188  46a8              MOV      r8,r5                 ;2061
00018a  1b80              SUBS     r0,r0,r6              ;2061
00018c  f1a00910          SUB      r9,r0,#0x10           ;2061
000190  4648              MOV      r0,r9                 ;2061
000192  f7fffffe          BL       RMP_MSB_Get
000196  1ec1              SUBS     r1,r0,#3              ;2061
000198  fa29f101          LSR      r1,r9,r1              ;2061
00019c  f0010107          AND      r1,r1,#7              ;2061
0001a0  1f80              SUBS     r0,r0,#6              ;2061
0001a2  eb0101c0          ADD      r1,r1,r0,LSL #3       ;2061
0001a6  eb0800c1          ADD      r0,r8,r1,LSL #3       ;2061
0001aa  6ac2              LDR      r2,[r0,#0x2c]         ;2061
0001ac  3028              ADDS     r0,r0,#0x28           ;2061
0001ae  4282              CMP      r2,r0                 ;2061
0001b0  d10c              BNE      |L11.460|
0001b2  e001              B        |L11.440|
                  |L11.436|
0001b4  e01d              B        |L11.498|
                  |L11.438|
0001b6  e018              B        |L11.490|
                  |L11.440|
0001b8  094a              LSRS     r2,r1,#5              ;2061
0001ba  eb080282          ADD      r2,r8,r2,LSL #2       ;2061
0001be  6953              LDR      r3,[r2,#0x14]         ;2061
0001c0  f001010f          AND      r1,r1,#0xf            ;2061
0001c4  fa07f101          LSL      r1,r7,r1              ;2061
0001c8  4319              ORRS     r1,r1,r3              ;2061
0001ca  6151              STR      r1,[r2,#0x14]         ;2061
                  |L11.460|
0001cc  6841              LDR      r1,[r0,#4]            ;2061
0001ce  600e              STR      r6,[r1,#0]            ;2061
0001d0  6071              STR      r1,[r6,#4]            ;2061
0001d2  6030              STR      r0,[r6,#0]            ;2061
0001d4  6046              STR      r6,[r0,#4]            ;2061
                  |L11.470|
0001d6  6868              LDR      r0,[r5,#4]            ;2065
0001d8  6004              STR      r4,[r0,#0]            ;2065
0001da  6060              STR      r0,[r4,#4]            ;2065
0001dc  6025              STR      r5,[r4,#0]            ;2065
0001de  606c              STR      r4,[r5,#4]            ;2065
0001e0  60a7              STR      r7,[r4,#8]            ;2066
0001e2  f1040010          ADD      r0,r4,#0x10           ;2069
0001e6  e8bd9ff0          POP      {r4-r12,pc}
                  |L11.490|
0001ea  1c64              ADDS     r4,r4,#1
0001ec  2c05              CMP      r4,#5
0001ee  f6ffaf63          BLT      |L11.184|
                  |L11.498|
0001f2  2000              MOVS     r0,#0                 ;2041
0001f4  e8bd9ff0          POP      {r4-r12,pc}
;;;2071   /* End Function:RMP_Malloc ***************************************************/
                          ENDP

                  |L11.504|
                          DCD      ||.constdata||

                          AREA ||i.RMP_Mem_Init||, CODE, READONLY, ALIGN=2

                  RMP_Mem_Init PROC
;;;1779   ******************************************************************************/
;;;1780   ret_t RMP_Mem_Init(volatile void* Pool, ptr_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;1781   {
000002  460e              MOV      r6,r1
000004  0004              MOVS     r4,r0
000006  d00a              BEQ      |L12.30|
;;;1782       cnt_t FLI_Cnt;
;;;1783       ptr_t Usable_Size;
;;;1784       volatile struct RMP_Mem* Mem;
;;;1785       volatile struct RMP_Mem_Head* Mem_Head;
;;;1786       
;;;1787       /* See if the memory pool is large enough to enable dynamic allocation - at least 4096 words */
;;;1788       if((Pool==0)||(Size<(4096*sizeof(ptr_t)))||((Size>>27)>0))
000008  f5b64f80          CMP      r6,#0x4000
00000c  bf28              IT       CS
00000e  ea5f60d6          LSRSCS   r0,r6,#27
;;;1789           return RMP_ERR_MEM;
;;;1790       
;;;1791       /* See if the address and size is word-aligned */
;;;1792       if((((ptr_t)Pool&(RMP_WORD_MASK>>2))!=0)||((Size&(RMP_WORD_MASK>>2))!=0))
000012  bf04              ITT      EQ
000014  ea440006          ORREQ    r0,r4,r6
000018  f0100f03          TSTEQ    r0,#3
00001c  d002              BEQ      |L12.36|
                  |L12.30|
;;;1793           return RMP_ERR_MEM;
00001e  f06f0006          MVN      r0,#6
;;;1794           
;;;1795       Mem=(volatile struct RMP_Mem*)Pool;
;;;1796       Mem->Size=Size;
;;;1797       /* Initialize the allocated block list */
;;;1798       RMP_List_Crt(&(Mem->Alloc));
;;;1799       /* Calculate the FLI value needed for this - we always align to 64 byte */
;;;1800       Mem->FLI_Num=RMP_MSB_Get(Size-sizeof(struct RMP_Mem))-6+1;
;;;1801       /* Initialize the TLSF allocation table first */
;;;1802       for(FLI_Cnt=0;FLI_Cnt<(cnt_t)(Mem->FLI_Num);FLI_Cnt++)
;;;1803       {
;;;1804           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,0)]));
;;;1805           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,1)]));
;;;1806           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,2)]));
;;;1807           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,3)]));
;;;1808           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,4)]));
;;;1809           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,5)]));
;;;1810           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,6)]));
;;;1811           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,7)]));
;;;1812       }
;;;1813       for(FLI_Cnt=0;FLI_Cnt<5;FLI_Cnt++)
;;;1814           Mem->Bitmap[FLI_Cnt]=0;
;;;1815       
;;;1816       /* Get the big memory block's size and position */
;;;1817       Usable_Size=sizeof(struct RMP_Mem)+(sizeof(struct RMP_List)<<3)*(Mem->FLI_Num-8);
;;;1818       Mem_Head=(struct RMP_Mem_Head*)(((ptr_t)Pool)+Usable_Size);
;;;1819       Mem->Start=(ptr_t)Mem_Head;
;;;1820       Usable_Size=Size-Usable_Size;
;;;1821       
;;;1822       /* Initialize the big block */
;;;1823       _RMP_Mem_Block(Mem_Head,Usable_Size);
;;;1824       
;;;1825       /* Insert the memory into the corresponding level */
;;;1826       _RMP_Mem_Ins(Pool, Mem_Head);
;;;1827       return 0;
;;;1828   }
000022  bd70              POP      {r4-r6,pc}
                  |L12.36|
000024  6126              STR      r6,[r4,#0x10]         ;1796
000026  6024              STR      r4,[r4,#0]            ;1796
000028  6064              STR      r4,[r4,#4]            ;1796
00002a  f5a6700a          SUB      r0,r6,#0x228          ;1800
00002e  f7fffffe          BL       RMP_MSB_Get
000032  1f40              SUBS     r0,r0,#5              ;1800
000034  60a0              STR      r0,[r4,#8]            ;1800
000036  68a0              LDR      r0,[r4,#8]            ;1802
000038  2100              MOVS     r1,#0                 ;1802
00003a  4288              CMP      r0,r1                 ;1802
00003c  dd1f              BLE      |L12.126|
00003e  bf00              NOP                            ;1804
                  |L12.64|
000040  eb041281          ADD      r2,r4,r1,LSL #6       ;1804
000044  f1020028          ADD      r0,r2,#0x28           ;1804
000048  6290              STR      r0,[r2,#0x28]         ;1804
00004a  62d0              STR      r0,[r2,#0x2c]         ;1804
00004c  3008              ADDS     r0,r0,#8              ;1805
00004e  6310              STR      r0,[r2,#0x30]         ;1805
000050  6350              STR      r0,[r2,#0x34]         ;1805
000052  3008              ADDS     r0,r0,#8              ;1806
000054  6390              STR      r0,[r2,#0x38]         ;1806
000056  63d0              STR      r0,[r2,#0x3c]         ;1806
000058  3008              ADDS     r0,r0,#8              ;1807
00005a  6410              STR      r0,[r2,#0x40]         ;1807
00005c  6450              STR      r0,[r2,#0x44]         ;1807
00005e  3008              ADDS     r0,r0,#8              ;1808
000060  6490              STR      r0,[r2,#0x48]         ;1808
000062  64d0              STR      r0,[r2,#0x4c]         ;1808
000064  3008              ADDS     r0,r0,#8              ;1809
000066  6510              STR      r0,[r2,#0x50]         ;1809
000068  6550              STR      r0,[r2,#0x54]         ;1809
00006a  3008              ADDS     r0,r0,#8              ;1810
00006c  6590              STR      r0,[r2,#0x58]         ;1810
00006e  65d0              STR      r0,[r2,#0x5c]         ;1810
000070  3260              ADDS     r2,r2,#0x60           ;1810
000072  6012              STR      r2,[r2,#0]            ;1810
000074  6052              STR      r2,[r2,#4]            ;1810
000076  68a0              LDR      r0,[r4,#8]            ;1811
000078  1c49              ADDS     r1,r1,#1              ;1811
00007a  4288              CMP      r0,r1                 ;1811
00007c  dce0              BGT      |L12.64|
                  |L12.126|
00007e  2000              MOVS     r0,#0                 ;1814
000080  6160              STR      r0,[r4,#0x14]         ;1814
000082  61a0              STR      r0,[r4,#0x18]         ;1814
000084  61e0              STR      r0,[r4,#0x1c]         ;1814
000086  6220              STR      r0,[r4,#0x20]         ;1814
000088  6260              STR      r0,[r4,#0x24]         ;1814
00008a  68a1              LDR      r1,[r4,#8]            ;1817
00008c  2228              MOVS     r2,#0x28              ;1817
00008e  eb021181          ADD      r1,r2,r1,LSL #6       ;1817
000092  1865              ADDS     r5,r4,r1              ;1818
000094  60e5              STR      r5,[r4,#0xc]          ;1819
000096  1a71              SUBS     r1,r6,r1              ;1820
000098  60a8              STR      r0,[r5,#8]            ;1820
00009a  1868              ADDS     r0,r5,r1              ;1820
00009c  1f00              SUBS     r0,r0,#4              ;1820
00009e  60e8              STR      r0,[r5,#0xc]          ;1820
0000a0  68e8              LDR      r0,[r5,#0xc]          ;1820
0000a2  6005              STR      r5,[r0,#0]            ;1820
0000a4  68e8              LDR      r0,[r5,#0xc]          ;1820
0000a6  1b40              SUBS     r0,r0,r5              ;1820
0000a8  f1a00610          SUB      r6,r0,#0x10           ;1820
0000ac  4630              MOV      r0,r6                 ;1820
0000ae  f7fffffe          BL       RMP_MSB_Get
0000b2  1ec1              SUBS     r1,r0,#3              ;1820
0000b4  fa26f101          LSR      r1,r6,r1              ;1820
0000b8  f0010107          AND      r1,r1,#7              ;1820
0000bc  1f80              SUBS     r0,r0,#6              ;1820
0000be  eb0101c0          ADD      r1,r1,r0,LSL #3       ;1820
0000c2  eb0400c1          ADD      r0,r4,r1,LSL #3       ;1820
0000c6  6ac2              LDR      r2,[r0,#0x2c]         ;1820
0000c8  3028              ADDS     r0,r0,#0x28           ;1820
0000ca  4282              CMP      r2,r0                 ;1820
0000cc  d10b              BNE      |L12.230|
0000ce  094a              LSRS     r2,r1,#5              ;1820
0000d0  eb040282          ADD      r2,r4,r2,LSL #2       ;1820
0000d4  6953              LDR      r3,[r2,#0x14]         ;1820
0000d6  f001010f          AND      r1,r1,#0xf            ;1820
0000da  f04f0c01          MOV      r12,#1                ;1820
0000de  fa0cf101          LSL      r1,r12,r1             ;1820
0000e2  4319              ORRS     r1,r1,r3              ;1820
0000e4  6151              STR      r1,[r2,#0x14]         ;1820
                  |L12.230|
0000e6  6841              LDR      r1,[r0,#4]            ;1820
0000e8  600d              STR      r5,[r1,#0]            ;1820
0000ea  6069              STR      r1,[r5,#4]            ;1820
0000ec  6028              STR      r0,[r5,#0]            ;1820
0000ee  6045              STR      r5,[r0,#4]            ;1820
0000f0  2000              MOVS     r0,#0                 ;1827
0000f2  bd70              POP      {r4-r6,pc}
;;;1829   /* End Function:RMP_Mem_Init *************************************************/
                          ENDP


                          AREA ||i.RMP_Print_Int||, CODE, READONLY, ALIGN=2

                  RMP_Print_Int PROC
;;;69     ******************************************************************************/
;;;70     cnt_t RMP_Print_Int(cnt_t Int)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;71     {
;;;72         ptr_t Iter;
;;;73         cnt_t Count;
;;;74         cnt_t Num;
;;;75         ptr_t Div;
;;;76         
;;;77         /* how many digits are there? */
;;;78         if(Int==0)
;;;79         {
;;;80             RMP_Putchar('0');
;;;81             return 1;
;;;82         }
;;;83         else if(Int<0)
;;;84         {
;;;85             /* How many digits are there? */
;;;86             Count=0;
;;;87             Div=1;
;;;88             Iter=-Int;
;;;89             while(Iter!=0)
;;;90             {
;;;91                 Iter/=10;
000004  f8df80b8          LDR      r8,|L13.192|
000008  1e05              SUBS     r5,r0,#0              ;71
;;;92                 Count++;
;;;93                 Div*=10;
;;;94             }
;;;95             Div/=10;
;;;96             
;;;97             RMP_Putchar('-');
;;;98             Iter=-Int;
;;;99             Num=Count+1;
;;;100            
;;;101            while(Count>0)
;;;102            {
;;;103                Count--;
;;;104                RMP_Putchar(Iter/Div+'0');
;;;105                Iter=Iter%Div;
;;;106                Div/=10;
;;;107            }
;;;108        }
;;;109        else
;;;110        {
;;;111            /* How many digits are there? */
;;;112            Count=0;
00000a  bfc4              ITT      GT
00000c  2400              MOVGT    r4,#0
;;;113            Div=1;
00000e  2101              MOVGT    r1,#1
000010  d02b              BEQ      |L13.106|
000012  da30              BGE      |L13.118|
000014  2600              MOVS     r6,#0                 ;86
000016  2101              MOVS     r1,#1                 ;87
000018  4244              RSBS     r4,r0,#0              ;88
00001a  4625              MOV      r5,r4                 ;88
00001c  d00a              BEQ      |L13.52|
00001e  bf00              NOP                            ;91
                  |L13.32|
000020  fba82004          UMULL    r2,r0,r8,r4           ;91
000024  08c4              LSRS     r4,r0,#3              ;91
000026  eb010081          ADD      r0,r1,r1,LSL #2       ;93
00002a  ea4f0140          LSL      r1,r0,#1              ;93
00002e  f1060601          ADD      r6,r6,#1              ;93
000032  d1f5              BNE      |L13.32|
                  |L13.52|
000034  fba81001          UMULL    r1,r0,r8,r1           ;95
000038  08c7              LSRS     r7,r0,#3              ;95
00003a  202d              MOVS     r0,#0x2d              ;97
00003c  f7fffffe          BL       RMP_Putchar
000040  f1060901          ADD      r9,r6,#1              ;99
000044  2e00              CMP      r6,#0                 ;101
000046  dd37              BLE      |L13.184|
                  |L13.72|
000048  fbb5f0f7          UDIV     r0,r5,r7              ;104
00004c  3030              ADDS     r0,r0,#0x30           ;104
00004e  b240              SXTB     r0,r0                 ;104
000050  1e76              SUBS     r6,r6,#1              ;104
000052  f7fffffe          BL       RMP_Putchar
000056  fbb5f0f7          UDIV     r0,r5,r7              ;105
00005a  fb075510          MLS      r5,r7,r0,r5           ;105
00005e  fba81007          UMULL    r1,r0,r8,r7           ;106
000062  08c7              LSRS     r7,r0,#3              ;106
000064  2e00              CMP      r6,#0                 ;101
000066  dcef              BGT      |L13.72|
000068  e026              B        |L13.184|
                  |L13.106|
00006a  2030              MOVS     r0,#0x30              ;80
00006c  f7fffffe          BL       RMP_Putchar
000070  2001              MOVS     r0,#1                 ;81
;;;114            Iter=Int;
;;;115            while(Iter!=0)
;;;116            {
;;;117                Iter/=10;
;;;118                Count++;
;;;119                Div*=10;
;;;120            }
;;;121            Div/=10;
;;;122            
;;;123            Iter=Int;
;;;124            Num=Count;
;;;125            
;;;126            while(Count>0)
;;;127            {
;;;128                Count--;
;;;129                RMP_Putchar(Iter/Div+'0');
;;;130                Iter=Iter%Div;
;;;131                Div/=10;
;;;132            }
;;;133        }
;;;134        
;;;135        return Num;
;;;136    }
000072  e8bd87f0          POP      {r4-r10,pc}
                  |L13.118|
000076  fba82000          UMULL    r2,r0,r8,r0           ;117
00007a  eb010181          ADD      r1,r1,r1,LSL #2       ;119
00007e  08c0              LSRS     r0,r0,#3              ;117
000080  ea4f0141          LSL      r1,r1,#1              ;119
000084  f1040401          ADD      r4,r4,#1              ;119
000088  d1f5              BNE      |L13.118|
00008a  fba81001          UMULL    r1,r0,r8,r1           ;121
00008e  08c6              LSRS     r6,r0,#3              ;121
000090  f1b40900          SUBS     r9,r4,#0              ;124
000094  dd10              BLE      |L13.184|
000096  bf00              NOP                            ;129
                  |L13.152|
000098  fbb5f0f6          UDIV     r0,r5,r6              ;129
00009c  3030              ADDS     r0,r0,#0x30           ;129
00009e  b240              SXTB     r0,r0                 ;129
0000a0  1e64              SUBS     r4,r4,#1              ;129
0000a2  f7fffffe          BL       RMP_Putchar
0000a6  fbb5f0f6          UDIV     r0,r5,r6              ;130
0000aa  fb065510          MLS      r5,r6,r0,r5           ;130
0000ae  fba81006          UMULL    r1,r0,r8,r6           ;131
0000b2  08c6              LSRS     r6,r0,#3              ;131
0000b4  2c00              CMP      r4,#0                 ;126
0000b6  dcef              BGT      |L13.152|
                  |L13.184|
0000b8  4648              MOV      r0,r9                 ;135
0000ba  e8bd87f0          POP      {r4-r10,pc}
;;;137    /* End Function:RMP_Print_Int ************************************************/
                          ENDP

0000be  0000              DCW      0x0000
                  |L13.192|
                          DCD      0xcccccccd

                          AREA ||i.RMP_Print_String||, CODE, READONLY, ALIGN=1

                  RMP_Print_String PROC
;;;192    ******************************************************************************/
;;;193    cnt_t RMP_Print_String(s8* String)
000000  b570              PUSH     {r4-r6,lr}
;;;194    {
000002  4605              MOV      r5,r0
;;;195        cnt_t Count;
;;;196        
;;;197        Count=0;
000004  2400              MOVS     r4,#0
                  |L14.6|
;;;198        while(Count<RMP_KERNEL_DEBUG_MAX_STR)
;;;199        {
;;;200            if(String[Count]=='\0')
000006  5728              LDRSB    r0,[r5,r4]
000008  b120              CBZ      r0,|L14.20|
00000a  1c64              ADDS     r4,r4,#1
;;;201                break;
;;;202            
;;;203            RMP_Putchar(String[Count++]);
00000c  f7fffffe          BL       RMP_Putchar
000010  2cff              CMP      r4,#0xff              ;198
000012  dbf8              BLT      |L14.6|
                  |L14.20|
;;;204        }
;;;205        
;;;206        return Count;
000014  4620              MOV      r0,r4
;;;207    }
000016  bd70              POP      {r4-r6,pc}
;;;208    /* End Function:RMP_Print_String *********************************************/
                          ENDP


                          AREA ||i.RMP_Print_Uint||, CODE, READONLY, ALIGN=1

                  RMP_Print_Uint PROC
;;;145    ******************************************************************************/
;;;146    cnt_t RMP_Print_Uint(ptr_t Uint)
000000  b570              PUSH     {r4-r6,lr}
;;;147    {
000002  0005              MOVS     r5,r0
000004  d003              BEQ      |L15.14|
;;;148        ptr_t Iter;
;;;149        cnt_t Count;
;;;150        cnt_t Num;
;;;151        
;;;152        /* how many digits are there? */
;;;153        if(Uint==0)
;;;154        {
;;;155            RMP_Putchar('0');
;;;156            return 1;
;;;157        }
;;;158        else
;;;159        {
;;;160            /* Filter out all the zeroes */
;;;161            Count=0;
000006  2100              MOVS     r1,#0
;;;162            Iter=Uint;
;;;163            while((Iter>>((sizeof(ptr_t)*8)-4))==0)
000008  0f02              LSRS     r2,r0,#28
00000a  d005              BEQ      |L15.24|
00000c  e008              B        |L15.32|
                  |L15.14|
00000e  2030              MOVS     r0,#0x30              ;155
000010  f7fffffe          BL       RMP_Putchar
000014  2001              MOVS     r0,#1                 ;156
;;;164            {
;;;165                Iter<<=4;
;;;166                Count++;
;;;167            }
;;;168            /* Count is the number of pts to print */
;;;169            Count=sizeof(ptr_t)*2-Count;
;;;170            Num=Count;
;;;171            while(Count>0)
;;;172            {
;;;173                Count--;
;;;174                Iter=(Uint>>(Count*4))&0x0F;
;;;175                if(Iter<10)
;;;176                    RMP_Putchar('0'+Iter);
;;;177                else
;;;178                    RMP_Putchar('A'+Iter-10);
;;;179            }
;;;180        }
;;;181        
;;;182        return Num;
;;;183    }
000016  bd70              POP      {r4-r6,pc}
                  |L15.24|
000018  0100              LSLS     r0,r0,#4              ;165
00001a  1c49              ADDS     r1,r1,#1              ;165
00001c  0f02              LSRS     r2,r0,#28             ;163
00001e  d0fb              BEQ      |L15.24|
                  |L15.32|
000020  f1c10408          RSB      r4,r1,#8              ;169
000024  1e26              SUBS     r6,r4,#0              ;170
000026  dd0f              BLE      |L15.72|
                  |L15.40|
000028  4620              MOV      r0,r4                 ;173
00002a  1e64              SUBS     r4,r4,#1              ;173
00002c  0080              LSLS     r0,r0,#2
00002e  1f00              SUBS     r0,r0,#4
000030  fa25f000          LSR      r0,r5,r0              ;174
000034  f000000f          AND      r0,r0,#0xf            ;174
000038  280a              CMP      r0,#0xa               ;175
00003a  bf34              ITE      CC                    ;175
00003c  3030              ADDCC    r0,r0,#0x30           ;175
00003e  3037              ADDCS    r0,r0,#0x37           ;175
000040  f7fffffe          BL       RMP_Putchar
000044  2c00              CMP      r4,#0                 ;171
000046  dcef              BGT      |L15.40|
                  |L15.72|
000048  4630              MOV      r0,r6                 ;182
00004a  bd70              POP      {r4-r6,pc}
;;;184    /* End Function:RMP_Print_Uint ***********************************************/
                          ENDP


                          AREA ||i.RMP_RBIT_Get||, CODE, READONLY, ALIGN=2

                  RMP_RBIT_Get PROC
;;;1694   
;;;1695   ptr_t RMP_RBIT_Get(ptr_t Val)
000000  490a              LDR      r1,|L16.44|
;;;1696   {
000002  0e03              LSRS     r3,r0,#24
;;;1697       ptr_t Ret;
;;;1698       u8* To;
;;;1699       u8* From;
;;;1700       
;;;1701       To=(u8*)(&Ret);
;;;1702       From=(u8*)(&Val);
;;;1703       
;;;1704   #if(RMP_WORD_ORDER==4)
;;;1705       To[0]=RMP_RBIT_Table[From[1]];
;;;1706       To[1]=RMP_RBIT_Table[From[0]];
;;;1707   #elif(RMP_WORD_ORDER==5)
;;;1708       To[0]=RMP_RBIT_Table[From[3]];
000004  5ccb              LDRB     r3,[r1,r3]
000006  f3630207          BFI      r2,r3,#0,#8
00000a  f3c04307          UBFX     r3,r0,#16,#8
;;;1709       To[1]=RMP_RBIT_Table[From[2]];
00000e  5ccb              LDRB     r3,[r1,r3]
000010  f363220f          BFI      r2,r3,#8,#8
000014  f3c02307          UBFX     r3,r0,#8,#8
;;;1710       To[2]=RMP_RBIT_Table[From[1]];
000018  b2c0              UXTB     r0,r0
00001a  5ccb              LDRB     r3,[r1,r3]
;;;1711       To[3]=RMP_RBIT_Table[From[0]];
00001c  5c08              LDRB     r0,[r1,r0]
00001e  f3634217          BFI      r2,r3,#16,#8          ;1710
000022  f360621f          BFI      r2,r0,#24,#8
000026  4610              MOV      r0,r2
;;;1712   #else
;;;1713       To[0]=RMP_RBIT_Table[From[7]];
;;;1714       To[1]=RMP_RBIT_Table[From[6]];
;;;1715       To[2]=RMP_RBIT_Table[From[5]];
;;;1716       To[3]=RMP_RBIT_Table[From[4]];
;;;1717       To[4]=RMP_RBIT_Table[From[3]];
;;;1718       To[5]=RMP_RBIT_Table[From[2]];
;;;1719       To[6]=RMP_RBIT_Table[From[1]];
;;;1720       To[7]=RMP_RBIT_Table[From[0]];
;;;1721   #endif
;;;1722   
;;;1723       return Ret;
;;;1724   }
000028  4770              BX       lr
;;;1725   /* End Function:RMP_RBIT_Get *************************************************/
                          ENDP

00002a  0000              DCW      0x0000
                  |L16.44|
                          DCD      ||.constdata||

                          AREA ||i.RMP_Save_Ctx||, CODE, READONLY, ALIGN=1

                  RMP_Save_Ctx PROC
;;;1546   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1547   void RMP_Save_Ctx(void)
000000  4770              BX       lr
;;;1548   {
;;;1549       return;
;;;1550   }
;;;1551   #endif
                          ENDP


                          AREA ||i.RMP_Sem_Abort||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Abort PROC
;;;1374   ******************************************************************************/
;;;1375   ret_t RMP_Sem_Abort(volatile struct RMP_Thd* Thread)
000000  2800              CMP      r0,#0
;;;1376   {
;;;1377       /* Check if this thread structure could possibly be in use */
;;;1378       if(Thread==0)
;;;1379           return RMP_ERR_THD;
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;1380   
;;;1381       RMP_Lock_Sched();
;;;1382       
;;;1383       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;1384       {
;;;1385           RMP_Unlock_Sched();
;;;1386           return RMP_ERR_THD;
;;;1387       }
;;;1388       
;;;1389       /* Is it waiting on a semaphore? If no, we abort and return an error code */
;;;1390       if((RMP_THD_STATE(Thread->State)!=RMP_THD_SEMBLK)&&
;;;1391          (RMP_THD_STATE(Thread->State)!=RMP_THD_SEMDLY))
;;;1392       {
;;;1393           RMP_Unlock_Sched();
;;;1394           return RMP_ERR_STATE;
;;;1395       }
;;;1396   
;;;1397       /* Waiting for a semaphore. We abort it and return */
;;;1398       RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1399       if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1400           RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1401       
;;;1402       RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1403   
;;;1404       /* Only when when this thread is not suspended do we change it back */
;;;1405       if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1406           _RMP_Set_Rdy(Thread);
;;;1407       
;;;1408       Thread->Retval=RMP_ERR_OPER;
;;;1409       
;;;1410       RMP_Unlock_Sched();
;;;1411   
;;;1412       return 0;
;;;1413   }
000008  4770              BXEQ     lr
00000a  b510              PUSH     {r4,lr}               ;1376
00000c  4604              MOV      r4,r0                 ;1376
00000e  20ff              MOVS     r0,#0xff              ;1376
000010  f7fffffe          BL       RMP_Mask_Int
000014  481d              LDR      r0,|L18.140|
000016  2101              MOVS     r1,#1                 ;1376
000018  60c1              STR      r1,[r0,#0xc]          ;1376  ; RMP_Sched_Locked
00001a  6881              LDR      r1,[r0,#8]            ;1376  ; RMP_Sched_Lock_Cnt
00001c  1c49              ADDS     r1,r1,#1              ;1376
00001e  6081              STR      r1,[r0,#8]            ;1376  ; RMP_Sched_Lock_Cnt
000020  69a0              LDR      r0,[r4,#0x18]         ;1383
000022  f0100fff          TST      r0,#0xff              ;1383
000026  d00c              BEQ      |L18.66|
000028  69a0              LDR      r0,[r4,#0x18]         ;1390
00002a  b2c0              UXTB     r0,r0                 ;1390
00002c  2807              CMP      r0,#7                 ;1390
00002e  d00d              BEQ      |L18.76|
000030  69a0              LDR      r0,[r4,#0x18]         ;1391
000032  b2c0              UXTB     r0,r0                 ;1391
000034  2808              CMP      r0,#8                 ;1391
000036  d009              BEQ      |L18.76|
000038  f7fffffe          BL       RMP_Unlock_Sched
00003c  f06f0003          MVN      r0,#3                 ;1394
000040  bd10              POP      {r4,pc}
                  |L18.66|
000042  f7fffffe          BL       RMP_Unlock_Sched
000046  f04f30ff          MOV      r0,#0xffffffff        ;1386
00004a  bd10              POP      {r4,pc}
                  |L18.76|
00004c  6820              LDR      r0,[r4,#0]            ;1398
00004e  6861              LDR      r1,[r4,#4]            ;1398
000050  6008              STR      r0,[r1,#0]            ;1398
000052  6041              STR      r1,[r0,#4]            ;1398
000054  69a0              LDR      r0,[r4,#0x18]         ;1399
000056  b2c0              UXTB     r0,r0                 ;1399
000058  2808              CMP      r0,#8                 ;1399
00005a  d103              BNE      |L18.100|
00005c  68a1              LDR      r1,[r4,#8]            ;1400
00005e  68e0              LDR      r0,[r4,#0xc]          ;1400
000060  6001              STR      r1,[r0,#0]            ;1400
000062  6048              STR      r0,[r1,#4]            ;1400
                  |L18.100|
000064  69a0              LDR      r0,[r4,#0x18]         ;1402
000066  f02000ff          BIC      r0,r0,#0xff           ;1402
00006a  f0400001          ORR      r0,r0,#1              ;1402
00006e  61a0              STR      r0,[r4,#0x18]         ;1402
000070  69a0              LDR      r0,[r4,#0x18]         ;1405
000072  f4107f80          TST      r0,#0x100             ;1405
000076  bf04              ITT      EQ                    ;1406
000078  4620              MOVEQ    r0,r4                 ;1406
00007a  f7fffffe          BLEQ     _RMP_Set_Rdy
00007e  f06f0004          MVN      r0,#4                 ;1408
000082  63a0              STR      r0,[r4,#0x38]         ;1408
000084  f7fffffe          BL       RMP_Unlock_Sched
000088  2000              MOVS     r0,#0                 ;1412
00008a  bd10              POP      {r4,pc}
;;;1414   /* End Function:RMP_Sem_Abort ************************************************/
                          ENDP

                  |L18.140|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Crt||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Crt PROC
;;;1232   ******************************************************************************/
;;;1233   ret_t RMP_Sem_Crt(volatile struct RMP_Sem* Semaphore, ptr_t Number)
000000  2800              CMP      r0,#0
;;;1234   {
;;;1235       /* Check if this semaphore structure could possibly be in use */
;;;1236       if(Semaphore==0)
;;;1237           return RMP_ERR_SEM;
000002  bf04              ITT      EQ
000004  f06f0005          MVNEQ    r0,#5
;;;1238       
;;;1239       RMP_Lock_Sched();
;;;1240       
;;;1241       if(Semaphore->State!=RMP_SEM_FREE)
;;;1242       {
;;;1243           RMP_Unlock_Sched();
;;;1244           return RMP_ERR_SEM;
;;;1245       }
;;;1246       
;;;1247       /* Is the number too great to initialize? */
;;;1248       if(Number>=RMP_SEM_MAX_NUM)
;;;1249       {
;;;1250           RMP_Unlock_Sched();
;;;1251           return RMP_ERR_OPER;
;;;1252       }
;;;1253   
;;;1254       /* Initialize contents */
;;;1255       Semaphore->Cur_Num=Number;
;;;1256       Semaphore->State=RMP_SEM_USED;
;;;1257       RMP_List_Crt(&(Semaphore->Wait_List));
;;;1258       
;;;1259       RMP_Unlock_Sched();
;;;1260       
;;;1261       return 0;
;;;1262   }
000008  4770              BXEQ     lr
00000a  b570              PUSH     {r4-r6,lr}            ;1234
00000c  4604              MOV      r4,r0                 ;1234
00000e  460d              MOV      r5,r1                 ;1234
000010  20ff              MOVS     r0,#0xff              ;1234
000012  f7fffffe          BL       RMP_Mask_Int
000016  480e              LDR      r0,|L19.80|
000018  2101              MOVS     r1,#1                 ;1234
00001a  60c1              STR      r1,[r0,#0xc]          ;1234  ; RMP_Sched_Locked
00001c  6882              LDR      r2,[r0,#8]            ;1234  ; RMP_Sched_Lock_Cnt
00001e  1c52              ADDS     r2,r2,#1              ;1234
000020  6082              STR      r2,[r0,#8]            ;1234  ; RMP_Sched_Lock_Cnt
000022  68a0              LDR      r0,[r4,#8]            ;1241
000024  b120              CBZ      r0,|L19.48|
000026  f7fffffe          BL       RMP_Unlock_Sched
00002a  f06f0005          MVN      r0,#5                 ;1244
00002e  bd70              POP      {r4-r6,pc}
                  |L19.48|
000030  f5b57f7a          CMP      r5,#0x3e8             ;1248
000034  d304              BCC      |L19.64|
000036  f7fffffe          BL       RMP_Unlock_Sched
00003a  f06f0004          MVN      r0,#4                 ;1251
00003e  bd70              POP      {r4-r6,pc}
                  |L19.64|
000040  60e5              STR      r5,[r4,#0xc]          ;1255
000042  60a1              STR      r1,[r4,#8]            ;1256
000044  6024              STR      r4,[r4,#0]            ;1256
000046  6064              STR      r4,[r4,#4]            ;1256
000048  f7fffffe          BL       RMP_Unlock_Sched
00004c  2000              MOVS     r0,#0                 ;1261
00004e  bd70              POP      {r4-r6,pc}
;;;1263   /* End Function:RMP_Sem_Crt **************************************************/
                          ENDP

                  |L19.80|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Del||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Del PROC
;;;1270   ******************************************************************************/
;;;1271   ret_t RMP_Sem_Del(volatile struct RMP_Sem* Semaphore)
000000  2800              CMP      r0,#0
;;;1272   {
;;;1273       struct RMP_Thd* Thread;
;;;1274       
;;;1275       /* Check if this semaphore structure could possibly be in use */
;;;1276       if(Semaphore==0)
;;;1277           return RMP_ERR_SEM;
000002  bf04              ITT      EQ
000004  f06f0005          MVNEQ    r0,#5
;;;1278       
;;;1279       RMP_Lock_Sched();
;;;1280       
;;;1281       if(Semaphore->State!=RMP_SEM_USED)
;;;1282       {
;;;1283           RMP_Unlock_Sched();
;;;1284           return RMP_ERR_SEM;
;;;1285       }
;;;1286   
;;;1287       /* Get rid of all guys waiting on it */
;;;1288       while(&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)
;;;1289       {
;;;1290           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1291           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1292           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1293               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1294   
;;;1295           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1296   
;;;1297           /* Is it suspended? If yes, we can't directly send it running */
;;;1298           if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1299              _RMP_Set_Rdy(Thread);
;;;1300           
;;;1301           Thread->Retval=RMP_ERR_OPER;
;;;1302       }
;;;1303       Semaphore->State=RMP_SEM_FREE;
;;;1304       
;;;1305       RMP_Unlock_Sched();
;;;1306   
;;;1307       return 0;
;;;1308   }
000008  4770              BXEQ     lr
00000a  b570              PUSH     {r4-r6,lr}            ;1272
00000c  4605              MOV      r5,r0                 ;1272
00000e  20ff              MOVS     r0,#0xff              ;1272
000010  f7fffffe          BL       RMP_Mask_Int
000014  481a              LDR      r0,|L20.128|
000016  2101              MOVS     r1,#1                 ;1272
000018  60c1              STR      r1,[r0,#0xc]          ;1272  ; RMP_Sched_Locked
00001a  6881              LDR      r1,[r0,#8]            ;1272  ; RMP_Sched_Lock_Cnt
00001c  1c49              ADDS     r1,r1,#1              ;1272
00001e  6081              STR      r1,[r0,#8]            ;1272  ; RMP_Sched_Lock_Cnt
000020  68a8              LDR      r0,[r5,#8]            ;1281
000022  2801              CMP      r0,#1                 ;1281
000024  d004              BEQ      |L20.48|
000026  f7fffffe          BL       RMP_Unlock_Sched
00002a  f06f0005          MVN      r0,#5                 ;1284
00002e  bd70              POP      {r4-r6,pc}
                  |L20.48|
000030  6868              LDR      r0,[r5,#4]            ;1288
000032  42a8              CMP      r0,r5                 ;1288
000034  bf18              IT       NE                    ;1301
000036  f06f0604          MVNNE    r6,#4                 ;1301
00003a  d01b              BEQ      |L20.116|
                  |L20.60|
00003c  686c              LDR      r4,[r5,#4]            ;1290
00003e  e9d40100          LDRD     r0,r1,[r4,#0]         ;1290
000042  6008              STR      r0,[r1,#0]            ;1290
000044  6041              STR      r1,[r0,#4]            ;1290
000046  7e20              LDRB     r0,[r4,#0x18]         ;1292
000048  2808              CMP      r0,#8                 ;1292
00004a  d103              BNE      |L20.84|
00004c  e9d40102          LDRD     r0,r1,[r4,#8]         ;1292
000050  6008              STR      r0,[r1,#0]            ;1292
000052  6041              STR      r1,[r0,#4]            ;1292
                  |L20.84|
000054  69a0              LDR      r0,[r4,#0x18]         ;1295
000056  f02000ff          BIC      r0,r0,#0xff           ;1295
00005a  f0400001          ORR      r0,r0,#1              ;1295
00005e  f4107f80          TST      r0,#0x100             ;1298
000062  61a0              STR      r0,[r4,#0x18]         ;1298
000064  bf04              ITT      EQ                    ;1299
000066  4620              MOVEQ    r0,r4                 ;1299
000068  f7fffffe          BLEQ     _RMP_Set_Rdy
00006c  63a6              STR      r6,[r4,#0x38]         ;1288
00006e  6868              LDR      r0,[r5,#4]            ;1288
000070  42a8              CMP      r0,r5                 ;1288
000072  d1e3              BNE      |L20.60|
                  |L20.116|
000074  2000              MOVS     r0,#0                 ;1303
000076  60a8              STR      r0,[r5,#8]            ;1303
000078  f7fffffe          BL       RMP_Unlock_Sched
00007c  2000              MOVS     r0,#0                 ;1307
00007e  bd70              POP      {r4-r6,pc}
;;;1309   /* End Function:RMP_Sem_Del **************************************************/
                          ENDP

                  |L20.128|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Pend||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Pend PROC
;;;1317   ******************************************************************************/
;;;1318   ret_t RMP_Sem_Pend(volatile struct RMP_Sem* Semaphore, ptr_t Slices)
000000  2800              CMP      r0,#0
;;;1319   {
;;;1320       /* Check if this semaphore structure could possibly be in use */
;;;1321       if(Semaphore==0)
;;;1322           return RMP_ERR_SEM;
000002  bf04              ITT      EQ
000004  f06f0005          MVNEQ    r0,#5
;;;1323       
;;;1324       RMP_Lock_Sched();
;;;1325       
;;;1326       if(Semaphore->State!=RMP_SEM_USED)
;;;1327       {
;;;1328           RMP_Unlock_Sched();
;;;1329           return RMP_ERR_SEM;
;;;1330       }
;;;1331       
;;;1332       /* Check if we can get one immediately */
;;;1333       if(Semaphore->Cur_Num!=0)
;;;1334       {
;;;1335           Semaphore->Cur_Num--;
;;;1336           RMP_Unlock_Sched();
;;;1337           return Semaphore->Cur_Num;
;;;1338       }
;;;1339       else
;;;1340       {
;;;1341           /* Cannot get one, we need to block */
;;;1342           if(Slices==0)
;;;1343           {
;;;1344               RMP_Unlock_Sched();
;;;1345               return RMP_ERR_OPER;
;;;1346           }
;;;1347   
;;;1348           /* We must be running - place into waitlist now */
;;;1349           _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1350           RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Semaphore->Wait_List.Prev,&(Semaphore->Wait_List));
;;;1351           
;;;1352           if(Slices<RMP_MAX_SLICES)
;;;1353           {
;;;1354               _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1355               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMDLY);
;;;1356           }
;;;1357           else
;;;1358               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMBLK);
;;;1359           
;;;1360           RMP_Cur_Thd->Retval=0;
;;;1361       }
;;;1362       
;;;1363       RMP_Unlock_Sched();
;;;1364   
;;;1365       return RMP_Cur_Thd->Retval;
;;;1366   }
000008  4770              BXEQ     lr
00000a  b570              PUSH     {r4-r6,lr}            ;1319
00000c  4605              MOV      r5,r0                 ;1319
00000e  460e              MOV      r6,r1                 ;1319
000010  20ff              MOVS     r0,#0xff              ;1319
000012  f7fffffe          BL       RMP_Mask_Int
000016  4c30              LDR      r4,|L21.216|
000018  2001              MOVS     r0,#1                 ;1319
00001a  60e0              STR      r0,[r4,#0xc]          ;1319  ; RMP_Sched_Locked
00001c  68a0              LDR      r0,[r4,#8]            ;1319  ; RMP_Sched_Lock_Cnt
00001e  1c40              ADDS     r0,r0,#1              ;1319
000020  60a0              STR      r0,[r4,#8]            ;1319  ; RMP_Sched_Lock_Cnt
000022  68a8              LDR      r0,[r5,#8]            ;1326
000024  2801              CMP      r0,#1                 ;1326
000026  d004              BEQ      |L21.50|
000028  f7fffffe          BL       RMP_Unlock_Sched
00002c  f06f0005          MVN      r0,#5                 ;1329
000030  bd70              POP      {r4-r6,pc}
                  |L21.50|
000032  68e8              LDR      r0,[r5,#0xc]          ;1333
000034  b130              CBZ      r0,|L21.68|
000036  68e8              LDR      r0,[r5,#0xc]          ;1335
000038  1e40              SUBS     r0,r0,#1              ;1335
00003a  60e8              STR      r0,[r5,#0xc]          ;1335
00003c  f7fffffe          BL       RMP_Unlock_Sched
000040  68e8              LDR      r0,[r5,#0xc]          ;1337
000042  bd70              POP      {r4-r6,pc}
                  |L21.68|
000044  b38e              CBZ      r6,|L21.170|
000046  69a0              LDR      r0,[r4,#0x18]         ;1349  ; RMP_Cur_Thd
000048  f7fffffe          BL       _RMP_Clr_Rdy
00004c  69a0              LDR      r0,[r4,#0x18]         ;1350  ; RMP_Cur_Thd
00004e  6829              LDR      r1,[r5,#0]            ;1350
000050  6028              STR      r0,[r5,#0]            ;1350
000052  6045              STR      r5,[r0,#4]            ;1350
000054  6001              STR      r1,[r0,#0]            ;1350
000056  6048              STR      r0,[r1,#4]            ;1350
000058  4820              LDR      r0,|L21.220|
00005a  4286              CMP      r6,r0                 ;1352
00005c  d22b              BCS      |L21.182|
00005e  f8d4c018          LDR      r12,[r4,#0x18]        ;1354  ; RMP_Cur_Thd
000062  491f              LDR      r1,|L21.224|
000064  6848              LDR      r0,[r1,#4]            ;1354  ; RMP_Delay
000066  4288              CMP      r0,r1                 ;1354
000068  bf1c              ITT      NE                    ;1354
00006a  f1a00208          SUBNE    r2,r0,#8              ;1354
00006e  6a03              LDRNE    r3,[r0,#0x20]         ;1354
000070  d005              BEQ      |L21.126|
                  |L21.114|
000072  6862              LDR      r2,[r4,#4]            ;1354  ; RMP_Tick
000074  1a9a              SUBS     r2,r3,r2              ;1354
000076  42b2              CMP      r2,r6                 ;1354
000078  d801              BHI      |L21.126|
00007a  4288              CMP      r0,r1                 ;1354
00007c  d1f9              BNE      |L21.114|
                  |L21.126|
00007e  6861              LDR      r1,[r4,#4]            ;1354  ; RMP_Tick
000080  4431              ADD      r1,r1,r6              ;1354
000082  f8cc1028          STR      r1,[r12,#0x28]        ;1354
000086  f10c0108          ADD      r1,r12,#8             ;1354
00008a  6802              LDR      r2,[r0,#0]            ;1354
00008c  6001              STR      r1,[r0,#0]            ;1354
00008e  f8cc000c          STR      r0,[r12,#0xc]         ;1354
000092  f8cc2008          STR      r2,[r12,#8]           ;1354
000096  6051              STR      r1,[r2,#4]            ;1354
000098  69a0              LDR      r0,[r4,#0x18]         ;1355  ; RMP_Cur_Thd
00009a  69a1              LDR      r1,[r4,#0x18]         ;1355  ; RMP_Cur_Thd
00009c  6980              LDR      r0,[r0,#0x18]         ;1355
00009e  f02000ff          BIC      r0,r0,#0xff           ;1355
0000a2  f0400008          ORR      r0,r0,#8              ;1355
0000a6  6188              STR      r0,[r1,#0x18]         ;1355
0000a8  e00d              B        |L21.198|
                  |L21.170|
0000aa  e7ff              B        |L21.172|
                  |L21.172|
0000ac  f7fffffe          BL       RMP_Unlock_Sched
0000b0  f06f0004          MVN      r0,#4                 ;1345
0000b4  bd70              POP      {r4-r6,pc}
                  |L21.182|
0000b6  69a0              LDR      r0,[r4,#0x18]         ;1358  ; RMP_Cur_Thd
0000b8  69a1              LDR      r1,[r4,#0x18]         ;1358  ; RMP_Cur_Thd
0000ba  6980              LDR      r0,[r0,#0x18]         ;1358
0000bc  f02000ff          BIC      r0,r0,#0xff           ;1358
0000c0  f0400007          ORR      r0,r0,#7              ;1358
0000c4  6188              STR      r0,[r1,#0x18]         ;1358
                  |L21.198|
0000c6  69a1              LDR      r1,[r4,#0x18]         ;1360  ; RMP_Cur_Thd
0000c8  2000              MOVS     r0,#0                 ;1360
0000ca  6388              STR      r0,[r1,#0x38]         ;1363
0000cc  f7fffffe          BL       RMP_Unlock_Sched
0000d0  69a0              LDR      r0,[r4,#0x18]         ;1365  ; RMP_Cur_Thd
0000d2  6b80              LDR      r0,[r0,#0x38]         ;1365
0000d4  bd70              POP      {r4-r6,pc}
;;;1367   /* End Function:RMP_Sem_Pend *************************************************/
                          ENDP

0000d6  0000              DCW      0x0000
                  |L21.216|
                          DCD      ||.data||
                  |L21.220|
                          DCD      0x000186a0
                  |L21.224|
                          DCD      ||.data||+0x20

                          AREA ||i.RMP_Sem_Post||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Post PROC
;;;1424   ******************************************************************************/
;;;1425   ret_t RMP_Sem_Post(volatile struct RMP_Sem* Semaphore, ptr_t Number)
000000  2800              CMP      r0,#0
;;;1426   {
;;;1427       struct RMP_Thd* Thread;
;;;1428       
;;;1429       /* Check if this semaphore structure could possibly be in use */
;;;1430       if((Semaphore==0)||(Number==0))
000002  bf12              ITEE     NE
000004  2900              CMPNE    r1,#0
;;;1431           return RMP_ERR_SEM;
000006  f06f0005          MVNEQ    r0,#5
;;;1432       
;;;1433       RMP_Lock_Sched();
;;;1434       
;;;1435       if(Semaphore->State!=RMP_SEM_USED)
;;;1436       {
;;;1437           RMP_Unlock_Sched();
;;;1438           return RMP_ERR_SEM;
;;;1439       }
;;;1440       
;;;1441       /* Would the maximum value be exceeded if this is posted? */
;;;1442       if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
;;;1443       {
;;;1444           RMP_Unlock_Sched();
;;;1445           return RMP_ERR_OPER;
;;;1446       }
;;;1447       
;;;1448       Semaphore->Cur_Num+=Number;
;;;1449       /* Is there any thread waiting on it? If there are, clean them up*/
;;;1450       while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
;;;1451       {
;;;1452           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1453           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1454           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1455               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1456           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1457   
;;;1458           /* Only when when this thread is not suspended do we change it back */
;;;1459           if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1460               _RMP_Set_Rdy(Thread);
;;;1461   
;;;1462           /* Finally, return success */
;;;1463           Thread->Retval=0;
;;;1464           Semaphore->Cur_Num--;
;;;1465       }
;;;1466   
;;;1467       RMP_Unlock_Sched();
;;;1468   
;;;1469       return 0;
;;;1470   }
00000a  4770              BXEQ     lr
00000c  b570              PUSH     {r4-r6,lr}            ;1426
00000e  4604              MOV      r4,r0                 ;1426
000010  460d              MOV      r5,r1                 ;1426
000012  20ff              MOVS     r0,#0xff              ;1426
000014  f7fffffe          BL       RMP_Mask_Int
000018  4821              LDR      r0,|L22.160|
00001a  2101              MOVS     r1,#1                 ;1426
00001c  60c1              STR      r1,[r0,#0xc]          ;1426  ; RMP_Sched_Locked
00001e  6881              LDR      r1,[r0,#8]            ;1426  ; RMP_Sched_Lock_Cnt
000020  1c49              ADDS     r1,r1,#1              ;1426
000022  6081              STR      r1,[r0,#8]            ;1426  ; RMP_Sched_Lock_Cnt
000024  68a0              LDR      r0,[r4,#8]            ;1435
000026  2801              CMP      r0,#1                 ;1435
000028  d004              BEQ      |L22.52|
00002a  f7fffffe          BL       RMP_Unlock_Sched
00002e  f06f0005          MVN      r0,#5                 ;1438
000032  bd70              POP      {r4-r6,pc}
                  |L22.52|
000034  68e0              LDR      r0,[r4,#0xc]          ;1442
000036  4428              ADD      r0,r0,r5              ;1442
000038  f5b07f7a          CMP      r0,#0x3e8             ;1442
00003c  d304              BCC      |L22.72|
00003e  f7fffffe          BL       RMP_Unlock_Sched
000042  f06f0004          MVN      r0,#4                 ;1445
000046  bd70              POP      {r4-r6,pc}
                  |L22.72|
000048  68e0              LDR      r0,[r4,#0xc]          ;1448
00004a  4428              ADD      r0,r0,r5              ;1448
00004c  60e0              STR      r0,[r4,#0xc]          ;1448
00004e  2600              MOVS     r6,#0                 ;1448
                  |L22.80|
000050  6860              LDR      r0,[r4,#4]            ;1450
000052  42a0              CMP      r0,r4                 ;1450
000054  bf1c              ITT      NE                    ;1450
000056  68e0              LDRNE    r0,[r4,#0xc]          ;1450
000058  2800              CMPNE    r0,#0                 ;1450
00005a  d01c              BEQ      |L22.150|
00005c  6865              LDR      r5,[r4,#4]            ;1452
00005e  e9d50100          LDRD     r0,r1,[r5,#0]         ;1452
000062  6008              STR      r0,[r1,#0]            ;1452
000064  6041              STR      r1,[r0,#4]            ;1452
000066  7e28              LDRB     r0,[r5,#0x18]         ;1454
000068  2808              CMP      r0,#8                 ;1454
00006a  d103              BNE      |L22.116|
00006c  e9d50102          LDRD     r0,r1,[r5,#8]         ;1454
000070  6008              STR      r0,[r1,#0]            ;1454
000072  6041              STR      r1,[r0,#4]            ;1454
                  |L22.116|
000074  69a8              LDR      r0,[r5,#0x18]         ;1456
000076  f02000ff          BIC      r0,r0,#0xff           ;1456
00007a  f0400001          ORR      r0,r0,#1              ;1456
00007e  f4107f80          TST      r0,#0x100             ;1459
000082  61a8              STR      r0,[r5,#0x18]         ;1459
000084  bf04              ITT      EQ                    ;1460
000086  4628              MOVEQ    r0,r5                 ;1460
000088  f7fffffe          BLEQ     _RMP_Set_Rdy
00008c  63ae              STR      r6,[r5,#0x38]         ;1464
00008e  68e0              LDR      r0,[r4,#0xc]          ;1464
000090  1e40              SUBS     r0,r0,#1              ;1464
000092  60e0              STR      r0,[r4,#0xc]          ;1464
000094  e7dc              B        |L22.80|
                  |L22.150|
000096  f7fffffe          BL       RMP_Unlock_Sched
00009a  2000              MOVS     r0,#0                 ;1469
00009c  bd70              POP      {r4-r6,pc}
;;;1471   /* End Function:RMP_Sem_Post *************************************************/
                          ENDP

00009e  0000              DCW      0x0000
                  |L22.160|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Post_ISR||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Post_ISR PROC
;;;1479   ******************************************************************************/
;;;1480   ret_t RMP_Sem_Post_ISR(volatile struct RMP_Sem* Semaphore, ptr_t Number)
000000  2800              CMP      r0,#0
;;;1481   {
;;;1482       struct RMP_Thd* Thread;
;;;1483       /* Check if this semaphore structure could possibly be in use */
;;;1484       if((Semaphore==0)||(Number==0))
000002  bf12              ITEE     NE
000004  2900              CMPNE    r1,#0
;;;1485           return RMP_ERR_SEM;
000006  f06f0005          MVNEQ    r0,#5
;;;1486       
;;;1487       if(Semaphore->State!=RMP_SEM_USED)
;;;1488           return RMP_ERR_SEM;
;;;1489   
;;;1490       if(RMP_Sched_Locked!=0)
;;;1491           return RMP_ERR_OPER;
;;;1492   
;;;1493       /* Would the maximum value be exceeded if this is posted? */
;;;1494       if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
;;;1495           return RMP_ERR_OPER;
;;;1496       
;;;1497       Semaphore->Cur_Num+=Number;
;;;1498       /* Is there any thread waiting on it? If there are, clean them up*/
;;;1499       while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
;;;1500       {
;;;1501           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1502           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1503           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1504               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1505           
;;;1506           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1507   
;;;1508           /* Only when when this thread is not suspended do we change it back */
;;;1509           if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1510           {
;;;1511               _RMP_Set_Rdy(Thread);
;;;1512               if(Thread->Prio>RMP_Cur_Thd->Prio)
;;;1513                   _RMP_Yield();
;;;1514           }
;;;1515   
;;;1516           /* Finally, return success */
;;;1517           Thread->Retval=0;
;;;1518           Semaphore->Cur_Num--;
;;;1519       }
;;;1520   
;;;1521       return 0;
;;;1522   }
00000a  4770              BXEQ     lr
00000c  e92d41f0          PUSH     {r4-r8,lr}            ;1481
000010  4604              MOV      r4,r0                 ;1481
000012  6880              LDR      r0,[r0,#8]            ;1487
000014  2801              CMP      r0,#1                 ;1487
000016  bf1c              ITT      NE                    ;1488
000018  f06f0005          MVNNE    r0,#5                 ;1488
00001c  e8bd81f0          POPNE    {r4-r8,pc}
000020  4e1e              LDR      r6,|L23.156|
000022  68f0              LDR      r0,[r6,#0xc]          ;1490  ; RMP_Sched_Locked
000024  b920              CBNZ     r0,|L23.48|
000026  68e0              LDR      r0,[r4,#0xc]          ;1494
000028  4408              ADD      r0,r0,r1              ;1494
00002a  f5b07f7a          CMP      r0,#0x3e8             ;1494
00002e  d303              BCC      |L23.56|
                  |L23.48|
000030  f06f0004          MVN      r0,#4                 ;1495
000034  e8bd81f0          POP      {r4-r8,pc}
                  |L23.56|
000038  68e0              LDR      r0,[r4,#0xc]          ;1497
00003a  4408              ADD      r0,r0,r1              ;1497
00003c  60e0              STR      r0,[r4,#0xc]          ;1497
00003e  2700              MOVS     r7,#0                 ;1497
000040  e022              B        |L23.136|
                  |L23.66|
000042  6865              LDR      r5,[r4,#4]            ;1501
000044  e9d50100          LDRD     r0,r1,[r5,#0]         ;1501
000048  6008              STR      r0,[r1,#0]            ;1501
00004a  6041              STR      r1,[r0,#4]            ;1501
00004c  7e28              LDRB     r0,[r5,#0x18]         ;1503
00004e  2808              CMP      r0,#8                 ;1503
000050  d103              BNE      |L23.90|
000052  e9d50102          LDRD     r0,r1,[r5,#8]         ;1503
000056  6008              STR      r0,[r1,#0]            ;1503
000058  6041              STR      r1,[r0,#4]            ;1503
                  |L23.90|
00005a  69a8              LDR      r0,[r5,#0x18]         ;1506
00005c  f02000ff          BIC      r0,r0,#0xff           ;1506
000060  f0400001          ORR      r0,r0,#1              ;1506
000064  f4107f80          TST      r0,#0x100             ;1509
000068  61a8              STR      r0,[r5,#0x18]         ;1509
00006a  d109              BNE      |L23.128|
00006c  4628              MOV      r0,r5                 ;1511
00006e  f7fffffe          BL       _RMP_Set_Rdy
000072  6a68              LDR      r0,[r5,#0x24]         ;1512
000074  69b1              LDR      r1,[r6,#0x18]         ;1512  ; RMP_Cur_Thd
000076  6a49              LDR      r1,[r1,#0x24]         ;1512
000078  4288              CMP      r0,r1                 ;1512
00007a  bf88              IT       HI                    ;1513
00007c  f7fffffe          BLHI     _RMP_Yield
                  |L23.128|
000080  63af              STR      r7,[r5,#0x38]         ;1518
000082  68e0              LDR      r0,[r4,#0xc]          ;1518
000084  1e40              SUBS     r0,r0,#1              ;1518
000086  60e0              STR      r0,[r4,#0xc]          ;1518
                  |L23.136|
000088  6860              LDR      r0,[r4,#4]            ;1499
00008a  42a0              CMP      r0,r4                 ;1499
00008c  bf1c              ITT      NE                    ;1499
00008e  68e0              LDRNE    r0,[r4,#0xc]          ;1499
000090  2800              CMPNE    r0,#0                 ;1499
000092  d1d6              BNE      |L23.66|
000094  2000              MOVS     r0,#0                 ;1521
000096  e8bd81f0          POP      {r4-r8,pc}
;;;1523   /* End Function:RMP_Sem_Post_ISR *********************************************/
                          ENDP

00009a  0000              DCW      0x0000
                  |L23.156|
                          DCD      ||.data||

                          AREA ||i.RMP_Start_Hook||, CODE, READONLY, ALIGN=1

                  RMP_Start_Hook PROC
;;;1532   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1533   void RMP_Start_Hook(void)
000000  4770              BX       lr
;;;1534   {
;;;1535       return;
;;;1536   }
;;;1537   #endif
                          ENDP


                          AREA ||i.RMP_Thd_Cancel||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Cancel PROC
;;;1194   ******************************************************************************/
;;;1195   ret_t RMP_Thd_Cancel(volatile struct RMP_Thd* Thread)
000000  2800              CMP      r0,#0
;;;1196   {
;;;1197       /* Check if this thread structure could possibly be in use */
;;;1198       if(Thread==0)
;;;1199           return RMP_ERR_THD;
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;1200       
;;;1201       RMP_Lock_Sched();
;;;1202       
;;;1203       /* Is it delayed? */
;;;1204       if(RMP_THD_STATE(Thread->State)!=RMP_THD_DELAYED)
;;;1205       {
;;;1206           RMP_Unlock_Sched();
;;;1207           return RMP_ERR_STATE;
;;;1208       }
;;;1209   
;;;1210       /* Delete it from the delay list */
;;;1211       RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1212       RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1213       
;;;1214       /* Only when when this thread is not suspended do we change it back */
;;;1215       if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1216           _RMP_Set_Rdy(Thread);
;;;1217       
;;;1218       Thread->Retval=RMP_ERR_OPER;
;;;1219       
;;;1220       RMP_Unlock_Sched();
;;;1221   
;;;1222       return 0;
;;;1223   }
000008  4770              BXEQ     lr
00000a  b510              PUSH     {r4,lr}               ;1196
00000c  4604              MOV      r4,r0                 ;1196
00000e  20ff              MOVS     r0,#0xff              ;1196
000010  f7fffffe          BL       RMP_Mask_Int
000014  4813              LDR      r0,|L25.100|
000016  2101              MOVS     r1,#1                 ;1196
000018  60c1              STR      r1,[r0,#0xc]          ;1196  ; RMP_Sched_Locked
00001a  6881              LDR      r1,[r0,#8]            ;1196  ; RMP_Sched_Lock_Cnt
00001c  1c49              ADDS     r1,r1,#1              ;1196
00001e  6081              STR      r1,[r0,#8]            ;1196  ; RMP_Sched_Lock_Cnt
000020  69a0              LDR      r0,[r4,#0x18]         ;1204
000022  b2c0              UXTB     r0,r0                 ;1204
000024  2806              CMP      r0,#6                 ;1204
000026  d004              BEQ      |L25.50|
000028  f7fffffe          BL       RMP_Unlock_Sched
00002c  f06f0003          MVN      r0,#3                 ;1207
000030  bd10              POP      {r4,pc}
                  |L25.50|
000032  68a0              LDR      r0,[r4,#8]            ;1211
000034  68e1              LDR      r1,[r4,#0xc]          ;1211
000036  6008              STR      r0,[r1,#0]            ;1211
000038  6041              STR      r1,[r0,#4]            ;1211
00003a  69a0              LDR      r0,[r4,#0x18]         ;1212
00003c  f02000ff          BIC      r0,r0,#0xff           ;1212
000040  f0400001          ORR      r0,r0,#1              ;1212
000044  61a0              STR      r0,[r4,#0x18]         ;1212
000046  69a0              LDR      r0,[r4,#0x18]         ;1215
000048  f4107f80          TST      r0,#0x100             ;1215
00004c  bf04              ITT      EQ                    ;1216
00004e  4620              MOVEQ    r0,r4                 ;1216
000050  f7fffffe          BLEQ     _RMP_Set_Rdy
000054  f06f0004          MVN      r0,#4                 ;1218
000058  63a0              STR      r0,[r4,#0x38]         ;1218
00005a  f7fffffe          BL       RMP_Unlock_Sched
00005e  2000              MOVS     r0,#0                 ;1222
000060  bd10              POP      {r4,pc}
;;;1224   /* End Function:RMP_Thd_Cancel ***********************************************/
                          ENDP

000062  0000              DCW      0x0000
                  |L25.100|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Crt||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Crt PROC
;;;674    ******************************************************************************/
;;;675    ret_t RMP_Thd_Crt(volatile struct RMP_Thd* Thread, void* Entry, void* Stack, void* Arg, ptr_t Prio, ptr_t Slices)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;676    {
000004  4699              MOV      r9,r3
000006  e9dd8508          LDRD     r8,r5,[sp,#0x20]
00000a  4616              MOV      r6,r2
00000c  468a              MOV      r10,r1
00000e  4604              MOV      r4,r0
;;;677        /* Check if the priority and timeslice range is correct */
;;;678        if(Prio>=RMP_MAX_PREEMPT_PRIO)
000010  f1b80f20          CMP      r8,#0x20
;;;679            return RMP_ERR_PRIO;
000014  bf24              ITT      CS
000016  f06f0001          MVNCS    r0,#1
;;;680        if((Slices==0)||(Slices>=RMP_MAX_SLICES))
;;;681            return RMP_ERR_SLICE;
;;;682        
;;;683        /* Check if this thread structure could possibly be in use */
;;;684        if(Thread==0)
;;;685            return RMP_ERR_THD;
;;;686        
;;;687        RMP_Lock_Sched();
;;;688        
;;;689        if(RMP_THD_STATE(Thread->State)!=RMP_THD_FREE)
;;;690        {
;;;691            RMP_Unlock_Sched();
;;;692            return RMP_ERR_THD;
;;;693        }
;;;694        
;;;695        /* Create the thread and insert it into the list */
;;;696        Thread->Prio=Prio;
;;;697        Thread->Slices=Slices;
;;;698        Thread->Slices_Left=Slices;
;;;699        Thread->Stack=(ptr_t)Stack;
;;;700        
;;;701        /* Initialize its stack and sending list */
;;;702        _RMP_Stack_Init((ptr_t)Entry, (ptr_t)Stack, (ptr_t)Arg);
;;;703        RMP_List_Crt(&(Thread->Snd_List));
;;;704        
;;;705        /* Notify the scheduler that we have created something new, also check locks */
;;;706        Thread->State=RMP_THD_RUNNING;
;;;707        _RMP_Set_Rdy(Thread);
;;;708        
;;;709        RMP_Unlock_Sched();
;;;710    
;;;711        return 0;
;;;712    }
00001a  e8bd87f0          POPCS    {r4-r10,pc}
00001e  2d00              CMP      r5,#0                 ;680
000020  bf1c              ITT      NE                    ;680
000022  481b              LDRNE    r0,|L26.144|
000024  4285              CMPNE    r5,r0                 ;680
000026  bf24              ITT      CS                    ;681
000028  f06f0002          MVNCS    r0,#2                 ;681
00002c  e8bd87f0          POPCS    {r4-r10,pc}
000030  2c00              CMP      r4,#0                 ;684
000032  bf04              ITT      EQ                    ;685
000034  f04f30ff          MOVEQ    r0,#0xffffffff        ;685
000038  e8bd87f0          POPEQ    {r4-r10,pc}
00003c  20ff              MOVS     r0,#0xff
00003e  f7fffffe          BL       RMP_Mask_Int
000042  4814              LDR      r0,|L26.148|
000044  2701              MOVS     r7,#1
000046  60c7              STR      r7,[r0,#0xc]  ; RMP_Sched_Locked
000048  6881              LDR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
00004a  1c49              ADDS     r1,r1,#1
00004c  6081              STR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
00004e  69a0              LDR      r0,[r4,#0x18]         ;689
000050  f0100fff          TST      r0,#0xff              ;689
000054  d004              BEQ      |L26.96|
000056  f7fffffe          BL       RMP_Unlock_Sched
00005a  1eb8              SUBS     r0,r7,#2              ;692
00005c  e8bd87f0          POP      {r4-r10,pc}
                  |L26.96|
000060  f8c48024          STR      r8,[r4,#0x24]         ;696
000064  61e5              STR      r5,[r4,#0x1c]         ;697
000066  6225              STR      r5,[r4,#0x20]         ;698
000068  6366              STR      r6,[r4,#0x34]         ;699
00006a  464a              MOV      r2,r9                 ;702
00006c  4631              MOV      r1,r6                 ;702
00006e  4650              MOV      r0,r10                ;702
000070  f7fffffe          BL       _RMP_Stack_Init
000074  f1040010          ADD      r0,r4,#0x10           ;703
000078  6120              STR      r0,[r4,#0x10]         ;703
00007a  6160              STR      r0,[r4,#0x14]         ;703
00007c  61a7              STR      r7,[r4,#0x18]         ;706
00007e  4620              MOV      r0,r4                 ;707
000080  f7fffffe          BL       _RMP_Set_Rdy
000084  f7fffffe          BL       RMP_Unlock_Sched
000088  2000              MOVS     r0,#0                 ;711
00008a  e8bd87f0          POP      {r4-r10,pc}
;;;713    /* End Function:RMP_Thd_Crt **************************************************/
                          ENDP

00008e  0000              DCW      0x0000
                  |L26.144|
                          DCD      0x000186a0
                  |L26.148|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Del||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Del PROC
;;;720    ******************************************************************************/
;;;721    ret_t RMP_Thd_Del(volatile struct RMP_Thd* Thread)
000000  2800              CMP      r0,#0
;;;722    {
;;;723        struct RMP_Thd* Release;
;;;724        ptr_t Self_Del;
;;;725        
;;;726        /* Check if this thread structure could possibly be in use */
;;;727        if(Thread==0)
;;;728            return RMP_ERR_THD;
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;729        
;;;730        RMP_Lock_Sched();
;;;731        
;;;732        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;733        {
;;;734            RMP_Unlock_Sched();
;;;735            return RMP_ERR_THD;
;;;736        }
;;;737        
;;;738        /* See if anyone waiting to send to this thread. If there is, release all these threads */
;;;739        while(&(Thread->Snd_List)!=Thread->Snd_List.Next)
;;;740        {
;;;741            Release=(struct RMP_Thd*)(Thread->Snd_List.Next);
;;;742            RMP_List_Del(Release->Run_Head.Prev,Release->Run_Head.Next);
;;;743            if(RMP_THD_STATE(Release->State)==RMP_THD_SNDDLY)
;;;744                RMP_List_Del(Release->Dly_Head.Prev,Release->Dly_Head.Next);
;;;745    
;;;746            RMP_THD_STATE_SET(Release->State,RMP_THD_RUNNING);
;;;747    
;;;748            /* Is it suspended? If yes, we can't directly send it running */
;;;749            if((Release->State&RMP_THD_SUSPENDED)==0)
;;;750               _RMP_Set_Rdy(Release);
;;;751            
;;;752            Release->Retval=RMP_ERR_OPER;
;;;753        }
;;;754        
;;;755        /* See what is it state */
;;;756        Self_Del=0;
;;;757        if(RMP_Cur_Thd==Thread)
;;;758            Self_Del=1;
;;;759        
;;;760        switch(RMP_THD_STATE(Thread->State))
;;;761        {
;;;762            case RMP_THD_RUNNING:
;;;763            {
;;;764                if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;765                    _RMP_Clr_Rdy(Thread);
;;;766                break;
;;;767            }
;;;768            
;;;769            case RMP_THD_SNDDLY:
;;;770            case RMP_THD_SEMDLY:
;;;771            {
;;;772                if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;773                    RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;774                RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;775                Thread->Retval=RMP_ERR_OPER;
;;;776                break;
;;;777            }
;;;778                
;;;779            case RMP_THD_RCVDLY:
;;;780            {
;;;781                RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;782                Thread->Retval=RMP_ERR_OPER;
;;;783                break;
;;;784            }
;;;785                
;;;786            case RMP_THD_DELAYED:
;;;787            {
;;;788                RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;789                Thread->Retval=RMP_ERR_OPER;
;;;790                break;
;;;791            }
;;;792            /* Should not get here */
;;;793            default:break;
;;;794        }
;;;795        Thread->State=RMP_THD_FREE;
;;;796        
;;;797        RMP_Unlock_Sched();
;;;798        
;;;799        /* If we are deleting ourself, just stop the execution here */
;;;800        if(Self_Del!=0)
;;;801            while(1);
;;;802    
;;;803        return 0;
;;;804    }
000008  4770              BXEQ     lr
00000a  e92d41f0          PUSH     {r4-r8,lr}            ;722
00000e  4604              MOV      r4,r0                 ;722
000010  20ff              MOVS     r0,#0xff              ;722
000012  f7fffffe          BL       RMP_Mask_Int
000016  f8df80e4          LDR      r8,|L27.252|
00001a  2001              MOVS     r0,#1                 ;722
00001c  f8c8000c          STR      r0,[r8,#0xc]          ;722  ; RMP_Sched_Locked
000020  f8d80008          LDR      r0,[r8,#8]            ;722  ; RMP_Sched_Lock_Cnt
000024  1c40              ADDS     r0,r0,#1              ;722
000026  f8c80008          STR      r0,[r8,#8]            ;722  ; RMP_Sched_Lock_Cnt
00002a  69a0              LDR      r0,[r4,#0x18]         ;732
00002c  f0100fff          TST      r0,#0xff              ;732
000030  d00f              BEQ      |L27.82|
000032  6960              LDR      r0,[r4,#0x14]         ;739
000034  f1040710          ADD      r7,r4,#0x10           ;739
000038  f06f0604          MVN      r6,#4                 ;752
00003c  42b8              CMP      r0,r7                 ;739
00003e  d022              BEQ      |L27.134|
                  |L27.64|
000040  6965              LDR      r5,[r4,#0x14]         ;741
000042  e9d50100          LDRD     r0,r1,[r5,#0]         ;741
000046  6008              STR      r0,[r1,#0]            ;741
000048  6041              STR      r1,[r0,#4]            ;741
00004a  7e28              LDRB     r0,[r5,#0x18]         ;743
00004c  2803              CMP      r0,#3                 ;743
00004e  d10a              BNE      |L27.102|
000050  e005              B        |L27.94|
                  |L27.82|
000052  f7fffffe          BL       RMP_Unlock_Sched
000056  f04f30ff          MOV      r0,#0xffffffff        ;735
00005a  e8bd81f0          POP      {r4-r8,pc}
                  |L27.94|
00005e  e9d50102          LDRD     r0,r1,[r5,#8]
000062  6008              STR      r0,[r1,#0]
000064  6041              STR      r1,[r0,#4]
                  |L27.102|
000066  69a8              LDR      r0,[r5,#0x18]         ;746
000068  f02000ff          BIC      r0,r0,#0xff           ;746
00006c  f0400001          ORR      r0,r0,#1              ;746
000070  f4107f80          TST      r0,#0x100             ;749
000074  61a8              STR      r0,[r5,#0x18]         ;749
000076  bf04              ITT      EQ                    ;750
000078  4628              MOVEQ    r0,r5                 ;750
00007a  f7fffffe          BLEQ     _RMP_Set_Rdy
00007e  63ae              STR      r6,[r5,#0x38]         ;739
000080  6960              LDR      r0,[r4,#0x14]         ;739
000082  42b8              CMP      r0,r7                 ;739
000084  d1dc              BNE      |L27.64|
                  |L27.134|
000086  f8d80018          LDR      r0,[r8,#0x18]         ;757  ; RMP_Cur_Thd
00008a  2500              MOVS     r5,#0                 ;756
00008c  42a0              CMP      r0,r4                 ;757
00008e  bf08              IT       EQ                    ;758
000090  2501              MOVEQ    r5,#1                 ;758
000092  69a0              LDR      r0,[r4,#0x18]         ;760
000094  b2c0              UXTB     r0,r0                 ;760
000096  2809              CMP      r0,#9                 ;760
000098  d226              BCS      |L27.232|
00009a  e8dff000          TBB      [pc,r0]               ;760
00009e  2505              DCB      0x25,0x05
0000a0  250d251b          DCB      0x25,0x0d,0x25,0x1b
0000a4  20250d00          DCB      0x20,0x25,0x0d,0x00
0000a8  69a0              LDR      r0,[r4,#0x18]         ;764
0000aa  f4107f80          TST      r0,#0x100             ;764
0000ae  bf04              ITT      EQ                    ;765
0000b0  4620              MOVEQ    r0,r4                 ;765
0000b2  f7fffffe          BLEQ     _RMP_Clr_Rdy
0000b6  e017              B        |L27.232|
0000b8  69a0              LDR      r0,[r4,#0x18]         ;772
0000ba  f4107f80          TST      r0,#0x100             ;772
0000be  d103              BNE      |L27.200|
0000c0  6820              LDR      r0,[r4,#0]            ;773
0000c2  6861              LDR      r1,[r4,#4]            ;773
0000c4  6008              STR      r0,[r1,#0]            ;773
0000c6  6041              STR      r1,[r0,#4]            ;773
                  |L27.200|
0000c8  68a0              LDR      r0,[r4,#8]            ;774
0000ca  68e1              LDR      r1,[r4,#0xc]          ;774
0000cc  6008              STR      r0,[r1,#0]            ;774
0000ce  6041              STR      r1,[r0,#4]            ;774
                  |L27.208|
0000d0  63a6              STR      r6,[r4,#0x38]         ;775
0000d2  e009              B        |L27.232|
0000d4  68a1              LDR      r1,[r4,#8]            ;781
0000d6  68e0              LDR      r0,[r4,#0xc]          ;781
0000d8  6001              STR      r1,[r0,#0]            ;781
0000da  6048              STR      r0,[r1,#4]            ;781
0000dc  e7f8              B        |L27.208|
0000de  68a1              LDR      r1,[r4,#8]            ;788
0000e0  68e0              LDR      r0,[r4,#0xc]          ;788
0000e2  6001              STR      r1,[r0,#0]            ;788
0000e4  6048              STR      r0,[r1,#4]            ;788
0000e6  63a6              STR      r6,[r4,#0x38]         ;789
                  |L27.232|
0000e8  2000              MOVS     r0,#0                 ;795
0000ea  61a0              STR      r0,[r4,#0x18]         ;795
0000ec  f7fffffe          BL       RMP_Unlock_Sched
0000f0  2d00              CMP      r5,#0                 ;800
0000f2  bf04              ITT      EQ                    ;803
0000f4  2000              MOVEQ    r0,#0                 ;803
0000f6  e8bd81f0          POPEQ    {r4-r8,pc}
                  |L27.250|
0000fa  e7fe              B        |L27.250|
;;;805    /* End Function:RMP_Thd_Del **************************************************/
                          ENDP

                  |L27.252|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Delay||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Delay PROC
;;;1167   ******************************************************************************/
;;;1168   ret_t RMP_Thd_Delay(ptr_t Slices)
000000  b570              PUSH     {r4-r6,lr}
;;;1169   {
000002  0005              MOVS     r5,r0
;;;1170       if((Slices==0)||(Slices>=RMP_MAX_SLICES))
000004  bf1c              ITT      NE
000006  4820              LDRNE    r0,|L28.136|
000008  42a8              CMPNE    r0,r5
;;;1171           return RMP_ERR_SLICE;
00000a  bf9c              ITT      LS
00000c  f06f0002          MVNLS    r0,#2
;;;1172       
;;;1173       RMP_Lock_Sched();
;;;1174   
;;;1175       /* We must be running */
;;;1176       _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1177       RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_DELAYED);
;;;1178       _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1179   
;;;1180       RMP_Cur_Thd->Retval=0;
;;;1181       
;;;1182       RMP_Unlock_Sched();
;;;1183       
;;;1184       /* Need to return if successful or not */
;;;1185       return RMP_Cur_Thd->Retval;
;;;1186   }
000010  bd70              POPLS    {r4-r6,pc}
000012  20ff              MOVS     r0,#0xff
000014  f7fffffe          BL       RMP_Mask_Int
000018  4c1c              LDR      r4,|L28.140|
00001a  2001              MOVS     r0,#1
00001c  60e0              STR      r0,[r4,#0xc]  ; RMP_Sched_Locked
00001e  68a0              LDR      r0,[r4,#8]  ; RMP_Sched_Lock_Cnt
000020  1c40              ADDS     r0,r0,#1
000022  60a0              STR      r0,[r4,#8]  ; RMP_Sched_Lock_Cnt
000024  69a0              LDR      r0,[r4,#0x18]         ;1176  ; RMP_Cur_Thd
000026  f7fffffe          BL       _RMP_Clr_Rdy
00002a  69a0              LDR      r0,[r4,#0x18]         ;1177  ; RMP_Cur_Thd
00002c  69a1              LDR      r1,[r4,#0x18]         ;1177  ; RMP_Cur_Thd
00002e  6980              LDR      r0,[r0,#0x18]         ;1177
000030  f02000ff          BIC      r0,r0,#0xff           ;1177
000034  f0400006          ORR      r0,r0,#6              ;1177
000038  6188              STR      r0,[r1,#0x18]         ;1178
00003a  f8d4c018          LDR      r12,[r4,#0x18]        ;1178  ; RMP_Cur_Thd
00003e  f1040020          ADD      r0,r4,#0x20           ;1178
000042  6841              LDR      r1,[r0,#4]            ;1178  ; RMP_Delay
000044  4281              CMP      r1,r0                 ;1178
000046  bf1c              ITT      NE                    ;1178
000048  f1a10208          SUBNE    r2,r1,#8              ;1178
00004c  6a0a              LDRNE    r2,[r1,#0x20]         ;1178
00004e  d005              BEQ      |L28.92|
                  |L28.80|
000050  6863              LDR      r3,[r4,#4]            ;1178  ; RMP_Tick
000052  1ad3              SUBS     r3,r2,r3              ;1178
000054  42ab              CMP      r3,r5                 ;1178
000056  d801              BHI      |L28.92|
000058  4281              CMP      r1,r0                 ;1178
00005a  d1f9              BNE      |L28.80|
                  |L28.92|
00005c  6860              LDR      r0,[r4,#4]            ;1178  ; RMP_Tick
00005e  4428              ADD      r0,r0,r5              ;1178
000060  f8cc0028          STR      r0,[r12,#0x28]        ;1178
000064  f10c0008          ADD      r0,r12,#8             ;1178
000068  680a              LDR      r2,[r1,#0]            ;1178
00006a  6008              STR      r0,[r1,#0]            ;1178
00006c  f8cc100c          STR      r1,[r12,#0xc]         ;1178
000070  f8cc2008          STR      r2,[r12,#8]           ;1178
000074  6050              STR      r0,[r2,#4]            ;1178
000076  69a1              LDR      r1,[r4,#0x18]         ;1180  ; RMP_Cur_Thd
000078  2000              MOVS     r0,#0                 ;1180
00007a  6388              STR      r0,[r1,#0x38]         ;1182
00007c  f7fffffe          BL       RMP_Unlock_Sched
000080  69a0              LDR      r0,[r4,#0x18]         ;1185  ; RMP_Cur_Thd
000082  6b80              LDR      r0,[r0,#0x38]         ;1185
000084  bd70              POP      {r4-r6,pc}
;;;1187   /* End Function:RMP_Thd_Delay ************************************************/
                          ENDP

000086  0000              DCW      0x0000
                  |L28.136|
                          DCD      0x000186a0
                  |L28.140|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Rcv||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Rcv PROC
;;;1088   ******************************************************************************/
;;;1089   ret_t RMP_Thd_Rcv(ptr_t* Data, ptr_t Slices)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1090   {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  20ff              MOVS     r0,#0xff
00000a  f7fffffe          BL       RMP_Mask_Int
00000e  4c46              LDR      r4,|L29.296|
000010  2701              MOVS     r7,#1
000012  60e7              STR      r7,[r4,#0xc]  ; RMP_Sched_Locked
000014  68a0              LDR      r0,[r4,#8]  ; RMP_Sched_Lock_Cnt
000016  1c40              ADDS     r0,r0,#1
000018  60a0              STR      r0,[r4,#8]  ; RMP_Sched_Lock_Cnt
;;;1091       struct RMP_Thd* Sender;
;;;1092       
;;;1093       RMP_Lock_Sched();
;;;1094   
;;;1095       /* Check if there is a value in our mailbox. If yes, we return with that value */
;;;1096       if((RMP_Cur_Thd->State&RMP_THD_MBOXFUL)!=0)
00001a  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
00001c  8b00              LDRH     r0,[r0,#0x18]
00001e  f4107f00          TST      r0,#0x200
;;;1097       {
;;;1098           /* Get the value from mailbox */
;;;1099           *Data=RMP_Cur_Thd->Mailbox;
;;;1100           RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
;;;1101           RMP_Unlock_Sched();
;;;1102           return 0;
;;;1103       }
;;;1104       else
;;;1105       {
;;;1106           /* Is there any other guy waiting on us? If there is, unblock it and set it running */
;;;1107           if(&(RMP_Cur_Thd->Snd_List)!=RMP_Cur_Thd->Snd_List.Next)
000022  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
000024  d00b              BEQ      |L29.62|
000026  6ac0              LDR      r0,[r0,#0x2c]         ;1099
000028  6030              STR      r0,[r6,#0]            ;1100
00002a  69a0              LDR      r0,[r4,#0x18]         ;1100  ; RMP_Cur_Thd
00002c  6981              LDR      r1,[r0,#0x18]         ;1100
00002e  f4217100          BIC      r1,r1,#0x200          ;1100
000032  6181              STR      r1,[r0,#0x18]         ;1101
000034  f7fffffe          BL       RMP_Unlock_Sched
000038  2000              MOVS     r0,#0                 ;1102
;;;1108           {
;;;1109               /* Read the data */
;;;1110               Sender=(struct RMP_Thd*)(RMP_Cur_Thd->Snd_List.Next);
;;;1111               RMP_List_Del(Sender->Run_Head.Prev,Sender->Run_Head.Next);
;;;1112               *Data=Sender->Data;
;;;1113               /* Now we unblock it - what state is it in? */
;;;1114               if((RMP_THD_STATE(Sender->State)==RMP_THD_SNDDLY))
;;;1115                   RMP_List_Del(Sender->Dly_Head.Prev,Sender->Dly_Head.Next);
;;;1116               
;;;1117               RMP_THD_STATE_SET(Sender->State,RMP_THD_RUNNING);
;;;1118   
;;;1119               /* Is it suspended? If yes, we can't directly send it running */
;;;1120               if((Sender->State&RMP_THD_SUSPENDED)==0)
;;;1121                   _RMP_Set_Rdy(Sender);
;;;1122               
;;;1123               RMP_Unlock_Sched();
;;;1124           }
;;;1125           /* No sender waiting on us, we need to block */
;;;1126           else
;;;1127           {
;;;1128               /* No such value in our mailbox, we need to block */
;;;1129               if(Slices==0)
;;;1130               {
;;;1131                   RMP_Unlock_Sched();
;;;1132                   return RMP_ERR_OPER;
;;;1133               }
;;;1134   
;;;1135               /* We must be running */
;;;1136               _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1137   
;;;1138               if(Slices<RMP_MAX_SLICES)
;;;1139               {
;;;1140                   _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1141                   RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVDLY);
;;;1142               }
;;;1143               else
;;;1144                   RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVBLK);
;;;1145               
;;;1146               RMP_Unlock_Sched();
;;;1147               /* Dummy read - to separate the lock & unlock. If the compiler optimizes these two
;;;1148                * functions(inline them) on some architectures sometimes we never block. */
;;;1149               *Data=RMP_Cur_Thd->Mailbox;
;;;1150               /* We've been unblocked. There must be something in our mbox, or we should have failed */
;;;1151               RMP_Lock_Sched();
;;;1152               *Data=RMP_Cur_Thd->Mailbox;
;;;1153               RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
;;;1154               RMP_Unlock_Sched();
;;;1155           }
;;;1156       }
;;;1157       
;;;1158       return RMP_Cur_Thd->Retval;
;;;1159   }
00003a  e8bd81f0          POP      {r4-r8,pc}
                  |L29.62|
00003e  6940              LDR      r0,[r0,#0x14]         ;1107
000040  69a1              LDR      r1,[r4,#0x18]         ;1107  ; RMP_Cur_Thd
000042  3110              ADDS     r1,r1,#0x10           ;1107
000044  4288              CMP      r0,r1                 ;1107
000046  d01c              BEQ      |L29.130|
000048  69a0              LDR      r0,[r4,#0x18]         ;1110  ; RMP_Cur_Thd
00004a  6940              LDR      r0,[r0,#0x14]         ;1110
00004c  e9d01200          LDRD     r1,r2,[r0,#0]         ;1110
000050  6011              STR      r1,[r2,#0]            ;1110
000052  604a              STR      r2,[r1,#4]            ;1110
000054  6b01              LDR      r1,[r0,#0x30]         ;1112
000056  6031              STR      r1,[r6,#0]            ;1114
000058  7e01              LDRB     r1,[r0,#0x18]         ;1114
00005a  2903              CMP      r1,#3                 ;1114
00005c  d103              BNE      |L29.102|
00005e  e9d01202          LDRD     r1,r2,[r0,#8]         ;1114
000062  6011              STR      r1,[r2,#0]            ;1114
000064  604a              STR      r2,[r1,#4]            ;1114
                  |L29.102|
000066  6981              LDR      r1,[r0,#0x18]         ;1117
000068  f02101ff          BIC      r1,r1,#0xff           ;1117
00006c  f0410101          ORR      r1,r1,#1              ;1117
000070  f4117f80          TST      r1,#0x100             ;1120
000074  6181              STR      r1,[r0,#0x18]         ;1120
000076  bf08              IT       EQ                    ;1121
000078  f7fffffe          BLEQ     _RMP_Set_Rdy
00007c  f7fffffe          BL       RMP_Unlock_Sched
000080  e04e              B        |L29.288|
                  |L29.130|
000082  b34d              CBZ      r5,|L29.216|
000084  69a0              LDR      r0,[r4,#0x18]         ;1136  ; RMP_Cur_Thd
000086  f7fffffe          BL       _RMP_Clr_Rdy
00008a  4828              LDR      r0,|L29.300|
00008c  4285              CMP      r5,r0                 ;1138
00008e  d229              BCS      |L29.228|
000090  69a3              LDR      r3,[r4,#0x18]         ;1140  ; RMP_Cur_Thd
000092  f8dfc09c          LDR      r12,|L29.304|
000096  f8dc0004          LDR      r0,[r12,#4]           ;1140  ; RMP_Delay
00009a  4560              CMP      r0,r12                ;1140
00009c  bf1c              ITT      NE                    ;1140
00009e  f1a00108          SUBNE    r1,r0,#8              ;1140
0000a2  6a01              LDRNE    r1,[r0,#0x20]         ;1140
0000a4  d005              BEQ      |L29.178|
                  |L29.166|
0000a6  6862              LDR      r2,[r4,#4]            ;1140  ; RMP_Tick
0000a8  1a8a              SUBS     r2,r1,r2              ;1140
0000aa  42aa              CMP      r2,r5                 ;1140
0000ac  d801              BHI      |L29.178|
0000ae  4560              CMP      r0,r12                ;1140
0000b0  d1f9              BNE      |L29.166|
                  |L29.178|
0000b2  6861              LDR      r1,[r4,#4]            ;1140  ; RMP_Tick
0000b4  4429              ADD      r1,r1,r5              ;1140
0000b6  6299              STR      r1,[r3,#0x28]         ;1140
0000b8  f1030108          ADD      r1,r3,#8              ;1140
0000bc  6802              LDR      r2,[r0,#0]            ;1140
0000be  6001              STR      r1,[r0,#0]            ;1140
0000c0  60d8              STR      r0,[r3,#0xc]          ;1140
0000c2  609a              STR      r2,[r3,#8]            ;1140
0000c4  6051              STR      r1,[r2,#4]            ;1140
0000c6  69a0              LDR      r0,[r4,#0x18]         ;1141  ; RMP_Cur_Thd
0000c8  69a1              LDR      r1,[r4,#0x18]         ;1141  ; RMP_Cur_Thd
0000ca  6980              LDR      r0,[r0,#0x18]         ;1141
0000cc  f02000ff          BIC      r0,r0,#0xff           ;1141
0000d0  f0400005          ORR      r0,r0,#5              ;1141
0000d4  6188              STR      r0,[r1,#0x18]         ;1141
0000d6  e00d              B        |L29.244|
                  |L29.216|
0000d8  f7fffffe          BL       RMP_Unlock_Sched
0000dc  f06f0004          MVN      r0,#4                 ;1132
0000e0  e8bd81f0          POP      {r4-r8,pc}
                  |L29.228|
0000e4  69a0              LDR      r0,[r4,#0x18]         ;1144  ; RMP_Cur_Thd
0000e6  69a1              LDR      r1,[r4,#0x18]         ;1144  ; RMP_Cur_Thd
0000e8  6980              LDR      r0,[r0,#0x18]         ;1144
0000ea  f02000ff          BIC      r0,r0,#0xff           ;1144
0000ee  f0400004          ORR      r0,r0,#4              ;1144
0000f2  6188              STR      r0,[r1,#0x18]         ;1144
                  |L29.244|
0000f4  f7fffffe          BL       RMP_Unlock_Sched
0000f8  69a0              LDR      r0,[r4,#0x18]         ;1149  ; RMP_Cur_Thd
0000fa  6ac0              LDR      r0,[r0,#0x2c]         ;1149
0000fc  6030              STR      r0,[r6,#0]            ;1149
0000fe  20ff              MOVS     r0,#0xff              ;1149
000100  f7fffffe          BL       RMP_Mask_Int
000104  60e7              STR      r7,[r4,#0xc]          ;1149  ; RMP_Sched_Locked
000106  68a0              LDR      r0,[r4,#8]            ;1149  ; RMP_Sched_Lock_Cnt
000108  1c40              ADDS     r0,r0,#1              ;1149
00010a  60a0              STR      r0,[r4,#8]            ;1149  ; RMP_Sched_Lock_Cnt
00010c  69a0              LDR      r0,[r4,#0x18]         ;1152  ; RMP_Cur_Thd
00010e  6ac0              LDR      r0,[r0,#0x2c]         ;1152
000110  6030              STR      r0,[r6,#0]            ;1153
000112  69a0              LDR      r0,[r4,#0x18]         ;1153  ; RMP_Cur_Thd
000114  6981              LDR      r1,[r0,#0x18]         ;1153
000116  f4217100          BIC      r1,r1,#0x200          ;1153
00011a  6181              STR      r1,[r0,#0x18]         ;1154
00011c  f7fffffe          BL       RMP_Unlock_Sched
                  |L29.288|
000120  69a0              LDR      r0,[r4,#0x18]         ;1158  ; RMP_Cur_Thd
000122  6b80              LDR      r0,[r0,#0x38]         ;1158
000124  e8bd81f0          POP      {r4-r8,pc}
;;;1160   /* End Function:RMP_Thd_Rcv **************************************************/
                          ENDP

                  |L29.296|
                          DCD      ||.data||
                  |L29.300|
                          DCD      0x000186a0
                  |L29.304|
                          DCD      ||.data||+0x20

                          AREA ||i.RMP_Thd_Resume||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Resume PROC
;;;910    ******************************************************************************/
;;;911    ret_t RMP_Thd_Resume(volatile struct RMP_Thd* Thread)
000000  2800              CMP      r0,#0
;;;912    {
;;;913        ret_t Retval;
;;;914        
;;;915        /* Check if this thread structure could possibly be in use */
;;;916        if(Thread==0)
;;;917            return RMP_ERR_THD;
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;918    
;;;919        RMP_Lock_Sched();
;;;920        
;;;921        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;922        {
;;;923            RMP_Unlock_Sched();
;;;924            return RMP_ERR_THD;
;;;925        }
;;;926        
;;;927        /* Check if the thread is suspended, if not, then throw an error */
;;;928        if((Thread->State&RMP_THD_SUSPENDED)!=0)
;;;929        {
;;;930            /* Suspended */
;;;931            Thread->State&=~RMP_THD_SUSPENDED;
;;;932            if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;933                _RMP_Set_Rdy(Thread);
;;;934            Retval=0;
;;;935        }
;;;936        else
;;;937            Retval=RMP_ERR_STATE;
;;;938        
;;;939        RMP_Unlock_Sched();
;;;940    
;;;941        return Retval;
;;;942    }
000008  4770              BXEQ     lr
00000a  b510              PUSH     {r4,lr}               ;912
00000c  4604              MOV      r4,r0                 ;912
00000e  20ff              MOVS     r0,#0xff              ;912
000010  f7fffffe          BL       RMP_Mask_Int
000014  4812              LDR      r0,|L30.96|
000016  2101              MOVS     r1,#1                 ;912
000018  60c1              STR      r1,[r0,#0xc]          ;912  ; RMP_Sched_Locked
00001a  6881              LDR      r1,[r0,#8]            ;912  ; RMP_Sched_Lock_Cnt
00001c  1c49              ADDS     r1,r1,#1              ;912
00001e  6081              STR      r1,[r0,#8]            ;912  ; RMP_Sched_Lock_Cnt
000020  69a0              LDR      r0,[r4,#0x18]         ;921
000022  f0100fff          TST      r0,#0xff              ;921
000026  d016              BEQ      |L30.86|
000028  69a0              LDR      r0,[r4,#0x18]         ;928
00002a  f4107f80          TST      r0,#0x100             ;928
00002e  bf08              IT       EQ                    ;937
000030  f06f0403          MVNEQ    r4,#3                 ;937
000034  d00b              BEQ      |L30.78|
000036  69a0              LDR      r0,[r4,#0x18]         ;931
000038  f4207080          BIC      r0,r0,#0x100          ;931
00003c  61a0              STR      r0,[r4,#0x18]         ;931
00003e  69a0              LDR      r0,[r4,#0x18]         ;932
000040  b2c0              UXTB     r0,r0                 ;932
000042  2801              CMP      r0,#1                 ;932
000044  bf04              ITT      EQ                    ;933
000046  4620              MOVEQ    r0,r4                 ;933
000048  f7fffffe          BLEQ     _RMP_Set_Rdy
00004c  2400              MOVS     r4,#0                 ;934
                  |L30.78|
00004e  f7fffffe          BL       RMP_Unlock_Sched
000052  4620              MOV      r0,r4                 ;941
000054  bd10              POP      {r4,pc}
                  |L30.86|
000056  f7fffffe          BL       RMP_Unlock_Sched
00005a  f04f30ff          MOV      r0,#0xffffffff        ;924
00005e  bd10              POP      {r4,pc}
;;;943    /* End Function:RMP_Thd_Resume ***********************************************/
                          ENDP

                  |L30.96|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Set||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Set PROC
;;;816    ******************************************************************************/
;;;817    ret_t RMP_Thd_Set(volatile struct RMP_Thd* Thread, ptr_t Prio, ptr_t Slices)
000000  2a00              CMP      r2,#0
;;;818    {
;;;819        /* Check if the priority and timeslice range is correct */
;;;820        if(Slices==0)
;;;821            return RMP_ERR_SLICE;
000002  bf04              ITT      EQ
000004  f06f0002          MVNEQ    r0,#2
;;;822        
;;;823        /* Check if this thread structure could possibly be in use */
;;;824        if(Thread==0)
;;;825            return RMP_ERR_THD;
;;;826        
;;;827        RMP_Lock_Sched();
;;;828        
;;;829        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;830        {
;;;831            RMP_Unlock_Sched();
;;;832            return RMP_ERR_THD;
;;;833        }
;;;834        
;;;835        /* See if the thread is in running state */
;;;836        if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;837        {
;;;838            /* See if we are gonna change one of it or both */
;;;839            if(Prio<RMP_MAX_PREEMPT_PRIO)
;;;840            {
;;;841                if(Thread->Prio!=Prio)
;;;842                {
;;;843                    _RMP_Clr_Rdy(Thread);
;;;844                    Thread->Prio=Prio;
;;;845                    _RMP_Set_Rdy(Thread);
;;;846                }
;;;847            }
;;;848            
;;;849            if(Slices<RMP_MAX_SLICES)
;;;850                Thread->Slices=Slices;
;;;851        }
;;;852        else
;;;853        {
;;;854            if(Prio<RMP_MAX_PREEMPT_PRIO)
;;;855                Thread->Prio=Prio;
;;;856            
;;;857            if(Slices<RMP_MAX_SLICES)
;;;858                Thread->Slices=Slices;
;;;859        }
;;;860        
;;;861        RMP_Unlock_Sched();
;;;862        
;;;863        return 0;
;;;864    }
000008  4770              BXEQ     lr
00000a  2800              CMP      r0,#0                 ;824
00000c  bf04              ITT      EQ                    ;825
00000e  f04f30ff          MOVEQ    r0,#0xffffffff        ;825
000012  4770              BXEQ     lr
000014  e92d41f0          PUSH     {r4-r8,lr}            ;818
000018  4604              MOV      r4,r0                 ;818
00001a  4615              MOV      r5,r2                 ;818
00001c  460e              MOV      r6,r1                 ;818
00001e  20ff              MOVS     r0,#0xff              ;818
000020  f7fffffe          BL       RMP_Mask_Int
000024  4817              LDR      r0,|L31.132|
000026  2101              MOVS     r1,#1                 ;818
000028  60c1              STR      r1,[r0,#0xc]          ;818  ; RMP_Sched_Locked
00002a  6881              LDR      r1,[r0,#8]            ;818  ; RMP_Sched_Lock_Cnt
00002c  1c49              ADDS     r1,r1,#1              ;818
00002e  6081              STR      r1,[r0,#8]            ;818  ; RMP_Sched_Lock_Cnt
000030  69a0              LDR      r0,[r4,#0x18]         ;829
000032  f0100fff          TST      r0,#0xff              ;829
000036  d00f              BEQ      |L31.88|
000038  69a0              LDR      r0,[r4,#0x18]         ;836
00003a  4f13              LDR      r7,|L31.136|
00003c  b2c0              UXTB     r0,r0                 ;836
00003e  2801              CMP      r0,#1                 ;836
000040  d010              BEQ      |L31.100|
000042  2e20              CMP      r6,#0x20              ;854
000044  bf38              IT       CC                    ;855
000046  6266              STRCC    r6,[r4,#0x24]         ;855
000048  42bd              CMP      r5,r7                 ;857
00004a  d200              BCS      |L31.78|
                  |L31.76|
00004c  61e5              STR      r5,[r4,#0x1c]         ;858
                  |L31.78|
00004e  f7fffffe          BL       RMP_Unlock_Sched
000052  2000              MOVS     r0,#0                 ;863
000054  e8bd81f0          POP      {r4-r8,pc}
                  |L31.88|
000058  f7fffffe          BL       RMP_Unlock_Sched
00005c  f04f30ff          MOV      r0,#0xffffffff        ;832
000060  e8bd81f0          POP      {r4-r8,pc}
                  |L31.100|
000064  2e20              CMP      r6,#0x20              ;839
000066  d209              BCS      |L31.124|
000068  6a60              LDR      r0,[r4,#0x24]         ;841
00006a  42b0              CMP      r0,r6                 ;841
00006c  d006              BEQ      |L31.124|
00006e  4620              MOV      r0,r4                 ;843
000070  f7fffffe          BL       _RMP_Clr_Rdy
000074  6266              STR      r6,[r4,#0x24]         ;844
000076  4620              MOV      r0,r4                 ;845
000078  f7fffffe          BL       _RMP_Set_Rdy
                  |L31.124|
00007c  42bd              CMP      r5,r7                 ;849
00007e  d2e6              BCS      |L31.78|
000080  e7e4              B        |L31.76|
;;;865    /* End Function:RMP_Thd_Set **************************************************/
                          ENDP

000082  0000              DCW      0x0000
                  |L31.132|
                          DCD      ||.data||
                  |L31.136|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Snd||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Snd PROC
;;;953    ******************************************************************************/
;;;954    ret_t RMP_Thd_Snd(volatile struct RMP_Thd* Thread, ptr_t Data, ptr_t Slices)
000000  2800              CMP      r0,#0
;;;955    {
;;;956        /* Check if this thread structure could possibly be in use */
;;;957        if(Thread==0)
;;;958            return RMP_ERR_THD;
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;959        
;;;960        RMP_Lock_Sched();
;;;961        
;;;962        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;963        {
;;;964            RMP_Unlock_Sched();
;;;965            return RMP_ERR_THD;
;;;966        }
;;;967        
;;;968        /* Are we sending to ourself? This is not allowed */
;;;969        if(RMP_Cur_Thd==Thread)
;;;970        {
;;;971            RMP_Unlock_Sched();
;;;972            return RMP_ERR_OPER;
;;;973        }
;;;974        
;;;975        RMP_Cur_Thd->Retval=0;
;;;976    
;;;977        /* See if there are already a value in the mailbox, if there is, we block */
;;;978        if((Thread->State&RMP_THD_MBOXFUL)!=0)
;;;979        {
;;;980            /* Mailbox full, we block, and put ourself into the queue */
;;;981            if(Slices==0)
;;;982            {
;;;983                RMP_Unlock_Sched();
;;;984                return RMP_ERR_OPER;
;;;985            }
;;;986    
;;;987            /* We must be running */
;;;988            _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;989            RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Thread->Snd_List.Prev,&(Thread->Snd_List));
;;;990    
;;;991            if(Slices<RMP_MAX_SLICES)
;;;992            {
;;;993                _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;994                RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDDLY);
;;;995            }
;;;996            else
;;;997                RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDBLK);
;;;998    
;;;999            RMP_Cur_Thd->Data=Data;
;;;1000       }
;;;1001       else
;;;1002       {
;;;1003           /* Mailbox not full. We need to check if the receiver is waiting for us */
;;;1004           if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
;;;1005              (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
;;;1006           {
;;;1007               /* The receiver is blocked, wake it up and return the value */
;;;1008               if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
;;;1009                   RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1010               
;;;1011               RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1012   
;;;1013               /* Is it suspended? If yes, we can't directly send it running */
;;;1014               if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1015                   _RMP_Set_Rdy(Thread);
;;;1016           }
;;;1017           
;;;1018           /* Set the mailbox */
;;;1019           Thread->Mailbox=Data;
;;;1020           Thread->State|=RMP_THD_MBOXFUL;
;;;1021       }
;;;1022       
;;;1023       RMP_Unlock_Sched();
;;;1024   
;;;1025       return RMP_Cur_Thd->Retval;
;;;1026   }
000008  4770              BXEQ     lr
00000a  e92d41f0          PUSH     {r4-r8,lr}            ;955
00000e  4604              MOV      r4,r0                 ;955
000010  4615              MOV      r5,r2                 ;955
000012  460f              MOV      r7,r1                 ;955
000014  20ff              MOVS     r0,#0xff              ;955
000016  f7fffffe          BL       RMP_Mask_Int
00001a  4e44              LDR      r6,|L32.300|
00001c  2001              MOVS     r0,#1                 ;955
00001e  60f0              STR      r0,[r6,#0xc]          ;955  ; RMP_Sched_Locked
000020  68b0              LDR      r0,[r6,#8]            ;955  ; RMP_Sched_Lock_Cnt
000022  1c40              ADDS     r0,r0,#1              ;955
000024  60b0              STR      r0,[r6,#8]            ;955  ; RMP_Sched_Lock_Cnt
000026  69a0              LDR      r0,[r4,#0x18]         ;962
000028  f0100fff          TST      r0,#0xff              ;962
00002c  d03f              BEQ      |L32.174|
00002e  69b0              LDR      r0,[r6,#0x18]         ;969  ; RMP_Cur_Thd
000030  42a0              CMP      r0,r4                 ;969
000032  d042              BEQ      |L32.186|
000034  69b1              LDR      r1,[r6,#0x18]         ;975  ; RMP_Cur_Thd
000036  2000              MOVS     r0,#0                 ;975
000038  6388              STR      r0,[r1,#0x38]         ;978
00003a  69a0              LDR      r0,[r4,#0x18]         ;978
00003c  f4107f00          TST      r0,#0x200             ;978
000040  d04c              BEQ      |L32.220|
000042  2d00              CMP      r5,#0                 ;981
000044  d039              BEQ      |L32.186|
000046  69b0              LDR      r0,[r6,#0x18]         ;988  ; RMP_Cur_Thd
000048  f7fffffe          BL       _RMP_Clr_Rdy
00004c  69b0              LDR      r0,[r6,#0x18]         ;989  ; RMP_Cur_Thd
00004e  f8541f10          LDR      r1,[r4,#0x10]!        ;989
000052  6020              STR      r0,[r4,#0]            ;989
000054  6044              STR      r4,[r0,#4]            ;989
000056  6001              STR      r1,[r0,#0]            ;989
000058  6048              STR      r0,[r1,#4]            ;989
00005a  4835              LDR      r0,|L32.304|
00005c  4285              CMP      r5,r0                 ;991
00005e  d232              BCS      |L32.198|
000060  f8d6c018          LDR      r12,[r6,#0x18]        ;993  ; RMP_Cur_Thd
000064  f1060320          ADD      r3,r6,#0x20           ;993
000068  6858              LDR      r0,[r3,#4]            ;993  ; RMP_Delay
00006a  4298              CMP      r0,r3                 ;993
00006c  bf1c              ITT      NE                    ;993
00006e  f1a00108          SUBNE    r1,r0,#8              ;993
000072  6a02              LDRNE    r2,[r0,#0x20]         ;993
000074  d005              BEQ      |L32.130|
                  |L32.118|
000076  6871              LDR      r1,[r6,#4]            ;993  ; RMP_Tick
000078  1a51              SUBS     r1,r2,r1              ;993
00007a  42a9              CMP      r1,r5                 ;993
00007c  d801              BHI      |L32.130|
00007e  4298              CMP      r0,r3                 ;993
000080  d1f9              BNE      |L32.118|
                  |L32.130|
000082  6871              LDR      r1,[r6,#4]            ;993  ; RMP_Tick
000084  4429              ADD      r1,r1,r5              ;993
000086  f8cc1028          STR      r1,[r12,#0x28]        ;993
00008a  f10c0108          ADD      r1,r12,#8             ;993
00008e  6802              LDR      r2,[r0,#0]            ;993
000090  6001              STR      r1,[r0,#0]            ;993
000092  f8cc000c          STR      r0,[r12,#0xc]         ;993
000096  f8cc2008          STR      r2,[r12,#8]           ;993
00009a  6051              STR      r1,[r2,#4]            ;993
00009c  69b0              LDR      r0,[r6,#0x18]         ;994  ; RMP_Cur_Thd
00009e  69b1              LDR      r1,[r6,#0x18]         ;994  ; RMP_Cur_Thd
0000a0  6980              LDR      r0,[r0,#0x18]         ;994
0000a2  f02000ff          BIC      r0,r0,#0xff           ;994
0000a6  f0400003          ORR      r0,r0,#3              ;994
0000aa  6188              STR      r0,[r1,#0x18]         ;994
0000ac  e013              B        |L32.214|
                  |L32.174|
0000ae  f7fffffe          BL       RMP_Unlock_Sched
0000b2  f04f30ff          MOV      r0,#0xffffffff        ;965
0000b6  e8bd81f0          POP      {r4-r8,pc}
                  |L32.186|
0000ba  f7fffffe          BL       RMP_Unlock_Sched
0000be  f06f0004          MVN      r0,#4                 ;984
0000c2  e8bd81f0          POP      {r4-r8,pc}
                  |L32.198|
0000c6  69b0              LDR      r0,[r6,#0x18]         ;997  ; RMP_Cur_Thd
0000c8  69b1              LDR      r1,[r6,#0x18]         ;997  ; RMP_Cur_Thd
0000ca  6980              LDR      r0,[r0,#0x18]         ;997
0000cc  f02000ff          BIC      r0,r0,#0xff           ;997
0000d0  f0400002          ORR      r0,r0,#2              ;997
0000d4  6188              STR      r0,[r1,#0x18]         ;997
                  |L32.214|
0000d6  69b0              LDR      r0,[r6,#0x18]         ;999  ; RMP_Cur_Thd
0000d8  6307              STR      r7,[r0,#0x30]         ;999
0000da  e021              B        |L32.288|
                  |L32.220|
0000dc  69a0              LDR      r0,[r4,#0x18]         ;1004
0000de  b2c0              UXTB     r0,r0                 ;1004
0000e0  2804              CMP      r0,#4                 ;1004
0000e2  d003              BEQ      |L32.236|
0000e4  69a0              LDR      r0,[r4,#0x18]         ;1005
0000e6  b2c0              UXTB     r0,r0                 ;1005
0000e8  2805              CMP      r0,#5                 ;1005
0000ea  d114              BNE      |L32.278|
                  |L32.236|
0000ec  69a0              LDR      r0,[r4,#0x18]         ;1008
0000ee  b2c0              UXTB     r0,r0                 ;1008
0000f0  2805              CMP      r0,#5                 ;1008
0000f2  d103              BNE      |L32.252|
0000f4  68a0              LDR      r0,[r4,#8]            ;1009
0000f6  68e1              LDR      r1,[r4,#0xc]          ;1009
0000f8  6008              STR      r0,[r1,#0]            ;1009
0000fa  6041              STR      r1,[r0,#4]            ;1009
                  |L32.252|
0000fc  69a0              LDR      r0,[r4,#0x18]         ;1011
0000fe  f02000ff          BIC      r0,r0,#0xff           ;1011
000102  f0400001          ORR      r0,r0,#1              ;1011
000106  61a0              STR      r0,[r4,#0x18]         ;1011
000108  69a0              LDR      r0,[r4,#0x18]         ;1014
00010a  f4107f80          TST      r0,#0x100             ;1014
00010e  bf04              ITT      EQ                    ;1015
000110  4620              MOVEQ    r0,r4                 ;1015
000112  f7fffffe          BLEQ     _RMP_Set_Rdy
                  |L32.278|
000116  62e7              STR      r7,[r4,#0x2c]         ;1019
000118  69a0              LDR      r0,[r4,#0x18]         ;1020
00011a  f4407000          ORR      r0,r0,#0x200          ;1020
00011e  61a0              STR      r0,[r4,#0x18]         ;1020
                  |L32.288|
000120  f7fffffe          BL       RMP_Unlock_Sched
000124  69b0              LDR      r0,[r6,#0x18]         ;1025  ; RMP_Cur_Thd
000126  6b80              LDR      r0,[r0,#0x38]         ;1025
000128  e8bd81f0          POP      {r4-r8,pc}
;;;1027   /* End Function:RMP_Thd_Snd **************************************************/
                          ENDP

                  |L32.300|
                          DCD      ||.data||
                  |L32.304|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Snd_ISR||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Snd_ISR PROC
;;;1037   ******************************************************************************/
;;;1038   ret_t RMP_Thd_Snd_ISR(volatile struct RMP_Thd* Thread, ptr_t Data)
000000  2800              CMP      r0,#0
;;;1039   {
;;;1040       /* Check if this thread structure could possibly be in use */
;;;1041       if(Thread==0)
;;;1042           return RMP_ERR_THD;
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;1043       
;;;1044       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;1045           return RMP_ERR_THD;
;;;1046       
;;;1047       if(RMP_Sched_Locked!=0)
;;;1048           return RMP_ERR_OPER;
;;;1049   
;;;1050       /* See if there are already a value in the mailbox, if there is, we abort */
;;;1051       if((Thread->State&RMP_THD_MBOXFUL)!=0)
;;;1052           return RMP_ERR_OPER;
;;;1053       else
;;;1054       {
;;;1055           /* Mailbox not full. We need to check if the receiver is waiting for us */
;;;1056           if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
;;;1057              (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
;;;1058           {
;;;1059               /* The receiver is blocked, wake it up and return the value */
;;;1060               if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
;;;1061                   RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1062               
;;;1063               RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1064   
;;;1065               /* Is it suspended? If yes, we can't directly send it running */
;;;1066               if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1067               {
;;;1068                   _RMP_Set_Rdy(Thread);
;;;1069                   if(Thread->Prio>RMP_Cur_Thd->Prio)
;;;1070                       _RMP_Yield();
;;;1071               }
;;;1072           }
;;;1073           
;;;1074           /* Set the mailbox */
;;;1075           Thread->Mailbox=Data;
;;;1076           Thread->State|=RMP_THD_MBOXFUL;
;;;1077       }
;;;1078   
;;;1079       return 0;
;;;1080   }
000008  4770              BXEQ     lr
00000a  b570              PUSH     {r4-r6,lr}            ;1039
00000c  4604              MOV      r4,r0                 ;1039
00000e  6980              LDR      r0,[r0,#0x18]         ;1044
000010  460e              MOV      r6,r1                 ;1039
000012  f0100fff          TST      r0,#0xff              ;1044
000016  bf04              ITT      EQ                    ;1045
000018  f04f30ff          MOVEQ    r0,#0xffffffff        ;1045
00001c  bd70              POPEQ    {r4-r6,pc}
00001e  4d1a              LDR      r5,|L33.136|
000020  68e8              LDR      r0,[r5,#0xc]          ;1047  ; RMP_Sched_Locked
000022  2800              CMP      r0,#0                 ;1047
000024  bf07              ITTEE    EQ                    ;1051
000026  69a0              LDREQ    r0,[r4,#0x18]         ;1051
000028  f4107f00          TSTEQ    r0,#0x200             ;1051
00002c  f06f0004          MVNNE    r0,#4                 ;1052
000030  bd70              POPNE    {r4-r6,pc}
000032  69a0              LDR      r0,[r4,#0x18]         ;1056
000034  b2c0              UXTB     r0,r0                 ;1056
000036  2804              CMP      r0,#4                 ;1056
000038  d003              BEQ      |L33.66|
00003a  69a0              LDR      r0,[r4,#0x18]         ;1057
00003c  b2c0              UXTB     r0,r0                 ;1057
00003e  2805              CMP      r0,#5                 ;1057
000040  d11b              BNE      |L33.122|
                  |L33.66|
000042  69a0              LDR      r0,[r4,#0x18]         ;1060
000044  b2c0              UXTB     r0,r0                 ;1060
000046  2805              CMP      r0,#5                 ;1060
000048  d103              BNE      |L33.82|
00004a  68a0              LDR      r0,[r4,#8]            ;1061
00004c  68e2              LDR      r2,[r4,#0xc]          ;1061
00004e  6010              STR      r0,[r2,#0]            ;1061
000050  6042              STR      r2,[r0,#4]            ;1061
                  |L33.82|
000052  69a0              LDR      r0,[r4,#0x18]         ;1063
000054  f02000ff          BIC      r0,r0,#0xff           ;1063
000058  f0400001          ORR      r0,r0,#1              ;1063
00005c  61a0              STR      r0,[r4,#0x18]         ;1063
00005e  69a0              LDR      r0,[r4,#0x18]         ;1066
000060  f4107f80          TST      r0,#0x100             ;1066
000064  d109              BNE      |L33.122|
000066  4620              MOV      r0,r4                 ;1068
000068  f7fffffe          BL       _RMP_Set_Rdy
00006c  6a60              LDR      r0,[r4,#0x24]         ;1069
00006e  69a9              LDR      r1,[r5,#0x18]         ;1069  ; RMP_Cur_Thd
000070  6a49              LDR      r1,[r1,#0x24]         ;1069
000072  4288              CMP      r0,r1                 ;1069
000074  bf88              IT       HI                    ;1070
000076  f7fffffe          BLHI     _RMP_Yield
                  |L33.122|
00007a  62e6              STR      r6,[r4,#0x2c]         ;1075
00007c  69a0              LDR      r0,[r4,#0x18]         ;1076
00007e  f4407000          ORR      r0,r0,#0x200          ;1076
000082  61a0              STR      r0,[r4,#0x18]         ;1076
000084  2000              MOVS     r0,#0                 ;1079
000086  bd70              POP      {r4-r6,pc}
;;;1081   /* End Function:RMP_Thd_Snd_ISR **********************************************/
                          ENDP

                  |L33.136|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Suspend||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Suspend PROC
;;;872    ******************************************************************************/
;;;873    ret_t RMP_Thd_Suspend(volatile struct RMP_Thd* Thread)
000000  2800              CMP      r0,#0
;;;874    {
;;;875        /* Check if this thread structure could possibly be in use */
;;;876        if(Thread==0)
;;;877            return RMP_ERR_THD;
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;878        
;;;879        RMP_Lock_Sched();
;;;880        
;;;881        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;882        {
;;;883            RMP_Unlock_Sched();
;;;884            return RMP_ERR_THD;
;;;885        }
;;;886        
;;;887        /* Suspend it */
;;;888        if((Thread->State&RMP_THD_SUSPENDED)!=0)
;;;889        {
;;;890            RMP_Unlock_Sched();
;;;891            return RMP_ERR_STATE;
;;;892        }
;;;893        /* Mark this as suspended */
;;;894        Thread->State|=RMP_THD_SUSPENDED;
;;;895        /* Only when it is running do we clear this */
;;;896        if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;897            _RMP_Clr_Rdy(Thread);
;;;898        
;;;899        RMP_Unlock_Sched();
;;;900    
;;;901        return 0;
;;;902    }
000008  4770              BXEQ     lr
00000a  b510              PUSH     {r4,lr}               ;874
00000c  4604              MOV      r4,r0                 ;874
00000e  20ff              MOVS     r0,#0xff              ;874
000010  f7fffffe          BL       RMP_Mask_Int
000014  4813              LDR      r0,|L34.100|
000016  2101              MOVS     r1,#1                 ;874
000018  60c1              STR      r1,[r0,#0xc]          ;874  ; RMP_Sched_Locked
00001a  6881              LDR      r1,[r0,#8]            ;874  ; RMP_Sched_Lock_Cnt
00001c  1c49              ADDS     r1,r1,#1              ;874
00001e  6081              STR      r1,[r0,#8]            ;874  ; RMP_Sched_Lock_Cnt
000020  69a0              LDR      r0,[r4,#0x18]         ;881
000022  f0100fff          TST      r0,#0xff              ;881
000026  d008              BEQ      |L34.58|
000028  69a0              LDR      r0,[r4,#0x18]         ;888
00002a  f4107f80          TST      r0,#0x100             ;888
00002e  d009              BEQ      |L34.68|
000030  f7fffffe          BL       RMP_Unlock_Sched
000034  f06f0003          MVN      r0,#3                 ;891
000038  bd10              POP      {r4,pc}
                  |L34.58|
00003a  f7fffffe          BL       RMP_Unlock_Sched
00003e  f04f30ff          MOV      r0,#0xffffffff        ;884
000042  bd10              POP      {r4,pc}
                  |L34.68|
000044  69a0              LDR      r0,[r4,#0x18]         ;894
000046  f4407080          ORR      r0,r0,#0x100          ;894
00004a  61a0              STR      r0,[r4,#0x18]         ;894
00004c  69a0              LDR      r0,[r4,#0x18]         ;896
00004e  b2c0              UXTB     r0,r0                 ;896
000050  2801              CMP      r0,#1                 ;896
000052  bf04              ITT      EQ                    ;897
000054  4620              MOVEQ    r0,r4                 ;897
000056  f7fffffe          BLEQ     _RMP_Clr_Rdy
00005a  f7fffffe          BL       RMP_Unlock_Sched
00005e  2000              MOVS     r0,#0                 ;901
000060  bd10              POP      {r4,pc}
;;;903    /* End Function:RMP_Thd_Suspend **********************************************/
                          ENDP

000062  0000              DCW      0x0000
                  |L34.100|
                          DCD      ||.data||

                          AREA ||i.RMP_Tick_Hook||, CODE, READONLY, ALIGN=1

                  RMP_Tick_Hook PROC
;;;1576   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1577   void RMP_Tick_Hook(ptr_t Ticks)
000000  4770              BX       lr
;;;1578   {
;;;1579       Ticks=Ticks;
;;;1580       return;
;;;1581   }
;;;1582   #endif
                          ENDP


                          AREA ||i.RMP_Unlock_Sched||, CODE, READONLY, ALIGN=2

                  RMP_Unlock_Sched PROC
;;;359    ******************************************************************************/
;;;360    void RMP_Unlock_Sched(void)
000000  480d              LDR      r0,|L36.56|
;;;361    {
000002  b510              PUSH     {r4,lr}
;;;362        if(RMP_Sched_Lock_Cnt==1)
000004  6881              LDR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
000006  2901              CMP      r1,#1
000008  d006              BEQ      |L36.24|
;;;363        {
;;;364            /* Clear the count before enabling */
;;;365            RMP_Sched_Lock_Cnt=0;
;;;366            RMP_Sched_Locked=0;
;;;367            /* Now see if the scheduler scheduling action is pended in the lock-unlock 
;;;368             * period. If yes, perform a schedule now */
;;;369            if(RMP_Sched_Pend!=0)
;;;370            {
;;;371                /* Reset the count and trigger the context switch */
;;;372                RMP_Sched_Pend=0;
;;;373                _RMP_Yield();
;;;374            }
;;;375            RMP_UNMASK_INT();
;;;376        }
;;;377        else if(RMP_Sched_Lock_Cnt>1)
00000a  6881              LDR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
00000c  2901              CMP      r1,#1
00000e  d911              BLS      |L36.52|
;;;378            RMP_Sched_Lock_Cnt--;
000010  6881              LDR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
000012  1e49              SUBS     r1,r1,#1
000014  6081              STR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
;;;379        /* Trying to unlock a scheduler that is not locked */
;;;380        else
;;;381            while(1);
;;;382    }
000016  bd10              POP      {r4,pc}
                  |L36.24|
000018  2100              MOVS     r1,#0                 ;365
00001a  6081              STR      r1,[r0,#8]            ;365  ; RMP_Sched_Lock_Cnt
00001c  60c1              STR      r1,[r0,#0xc]          ;366  ; RMP_Sched_Locked
00001e  6902              LDR      r2,[r0,#0x10]         ;369  ; RMP_Sched_Pend
000020  2a00              CMP      r2,#0                 ;369
000022  bf1c              ITT      NE                    ;372
000024  6101              STRNE    r1,[r0,#0x10]         ;372  ; RMP_Sched_Pend
000026  f7fffffe          BLNE     _RMP_Yield
00002a  2000              MOVS     r0,#0                 ;375
00002c  e8bd4010          POP      {r4,lr}               ;375
000030  f7ffbffe          B.W      RMP_Mask_Int
                  |L36.52|
000034  e7fe              B        |L36.52|
;;;383    /* End Function:RMP_Unlock_Sched *********************************************/
                          ENDP

000036  0000              DCW      0x0000
                  |L36.56|
                          DCD      ||.data||

                          AREA ||i.RMP_Yield||, CODE, READONLY, ALIGN=2

                  RMP_Yield PROC
;;;390    ******************************************************************************/
;;;391    void RMP_Yield(void)
000000  4804              LDR      r0,|L37.20|
;;;392    {
;;;393        if(RMP_Sched_Locked==0)
000002  68c1              LDR      r1,[r0,#0xc]  ; RMP_Sched_Locked
000004  2900              CMP      r1,#0
;;;394        {
;;;395            /* Now see if the scheduler scheduling action is pended in the lock-unlock 
;;;396             * period. If yes, perform a schedule now */
;;;397            _RMP_Yield();
;;;398        }
;;;399        else
;;;400            RMP_Sched_Pend=1;
000006  bf1e              ITTT     NE
000008  2101              MOVNE    r1,#1
00000a  6101              STRNE    r1,[r0,#0x10]  ; RMP_Sched_Pend
;;;401    }
00000c  4770              BXNE     lr
00000e  f7ffbffe          B.W      _RMP_Yield
;;;402    /* End Function:RMP_Yield ****************************************************/
                          ENDP

000012  0000              DCW      0x0000
                  |L37.20|
                          DCD      ||.data||

                          AREA ||i._RMP_Clr_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Clr_Rdy PROC
;;;619    ******************************************************************************/
;;;620    void _RMP_Clr_Rdy(volatile struct RMP_Thd* Thread)
000000  6801              LDR      r1,[r0,#0]
;;;621    {
;;;622        /* See if it is the last thread on the priority level */
;;;623        if(Thread->Run_Head.Prev==Thread->Run_Head.Next)
000002  6842              LDR      r2,[r0,#4]
;;;624            RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]&=~(((ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK));
000004  2301              MOVS     r3,#1
000006  4291              CMP      r1,r2                 ;623
000008  d10e              BNE      |L38.40|
00000a  6a41              LDR      r1,[r0,#0x24]
00000c  4a0b              LDR      r2,|L38.60|
00000e  0949              LSRS     r1,r1,#5
000010  eb020181          ADD      r1,r2,r1,LSL #2
000014  680a              LDR      r2,[r1,#0]
000016  f8d0c024          LDR      r12,[r0,#0x24]
00001a  f00c0c0f          AND      r12,r12,#0xf
00001e  fa03fc0c          LSL      r12,r3,r12
000022  ea22020c          BIC      r2,r2,r12
000026  600a              STR      r2,[r1,#0]
                  |L38.40|
;;;625        
;;;626        /* Insert this into the corresponding runqueue */
;;;627        RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
000028  6801              LDR      r1,[r0,#0]
00002a  6842              LDR      r2,[r0,#4]
00002c  6011              STR      r1,[r2,#0]
00002e  604a              STR      r2,[r1,#4]
;;;628        
;;;629        /* If it is the current thread, request a context switch */
;;;630        if(Thread==RMP_Cur_Thd)
000030  4902              LDR      r1,|L38.60|
000032  698a              LDR      r2,[r1,#0x18]  ; RMP_Cur_Thd
000034  4290              CMP      r0,r2
;;;631            RMP_Sched_Pend=1;
000036  bf08              IT       EQ
000038  610b              STREQ    r3,[r1,#0x10]  ; RMP_Sched_Pend
;;;632    }
00003a  4770              BX       lr
;;;633    /* End Function:_RMP_Clr_Rdy *************************************************/
                          ENDP

                  |L38.60|
                          DCD      ||.data||

                          AREA ||i._RMP_Get_High_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Get_High_Rdy PROC
;;;468    ******************************************************************************/
;;;469    void _RMP_Get_High_Rdy(void)
000000  b570              PUSH     {r4-r6,lr}
;;;470    {
;;;471        cnt_t Count;
;;;472        
;;;473        /* Write the SP value to thread structure */
;;;474        RMP_Cur_Thd->Stack=RMP_Cur_SP;
000002  4c1e              LDR      r4,|L39.124|
000004  69e0              LDR      r0,[r4,#0x1c]  ; RMP_Cur_SP
000006  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
;;;475        
;;;476        /* Is the scheduler locked on other threads? If yes, we return without doing anything */
;;;477        if(RMP_Sched_Locked!=0)
000008  6348              STR      r0,[r1,#0x34]
00000a  68e0              LDR      r0,[r4,#0xc]  ; RMP_Sched_Locked
00000c  2800              CMP      r0,#0                 ;470
;;;478            return;
;;;479        
;;;480        if(RMP_Timer_Pend==1)
;;;481        {
;;;482            RMP_Timer_Pend=0;
;;;483            _RMP_Timer_Proc();
;;;484        }
;;;485        
;;;486        RMP_Sched_Pend=0;
;;;487        /* See which one is ready, and pick it */
;;;488        for(Count=RMP_BITMAP_SIZE-1;Count>=0;Count--)
;;;489        {
;;;490            if(RMP_Bitmap[Count]==0)
;;;491                continue;
;;;492            
;;;493            Count=RMP_MSB_Get(RMP_Bitmap[Count])+(Count<<RMP_WORD_ORDER);
;;;494            
;;;495            /* See if the current thread and the next thread are the same. If yes, place the current at the end of the queue */
;;;496            if(RMP_Cur_Thd==(struct RMP_Thd*)(RMP_Run[Count].Next))
;;;497            {
;;;498                RMP_List_Del(RMP_Cur_Thd->Run_Head.Prev, RMP_Cur_Thd->Run_Head.Next);
;;;499                RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),
;;;500                             RMP_Run[RMP_Cur_Thd->Prio].Prev,
;;;501                             &(RMP_Run[RMP_Cur_Thd->Prio]));
;;;502            }
;;;503            
;;;504            /* Replenish timeslices */
;;;505            RMP_Cur_Thd->Slices_Left=RMP_Cur_Thd->Slices;
;;;506            RMP_Cur_Thd=(struct RMP_Thd*)(RMP_Run[Count].Next);
;;;507            break;
;;;508        }
;;;509        
;;;510        /* Load the SP value from thread structure */
;;;511        RMP_Cur_SP=RMP_Cur_Thd->Stack;
;;;512    }
00000e  bf18              IT       NE
000010  bd70              POPNE    {r4-r6,pc}
000012  6960              LDR      r0,[r4,#0x14]         ;480  ; RMP_Timer_Pend
000014  2500              MOVS     r5,#0                 ;480
000016  2801              CMP      r0,#1                 ;480
000018  bf04              ITT      EQ                    ;482
00001a  6165              STREQ    r5,[r4,#0x14]         ;482  ; RMP_Timer_Pend
00001c  f7fffffe          BLEQ     _RMP_Timer_Proc
000020  6125              STR      r5,[r4,#0x10]         ;486  ; RMP_Sched_Pend
000022  4816              LDR      r0,|L39.124|
000024  6801              LDR      r1,[r0,#0]            ;490
000026  b321              CBZ      r1,|L39.114|
000028  6800              LDR      r0,[r0,#0]            ;493
00002a  f7fffffe          BL       RMP_MSB_Get
00002e  4914              LDR      r1,|L39.128|
000030  eb0103c0          ADD      r3,r1,r0,LSL #3       ;496
000034  6858              LDR      r0,[r3,#4]            ;496
000036  69a2              LDR      r2,[r4,#0x18]         ;496  ; RMP_Cur_Thd
000038  4290              CMP      r0,r2                 ;496
00003a  d114              BNE      |L39.102|
00003c  69a0              LDR      r0,[r4,#0x18]         ;498  ; RMP_Cur_Thd
00003e  69a2              LDR      r2,[r4,#0x18]         ;498  ; RMP_Cur_Thd
000040  6800              LDR      r0,[r0,#0]            ;498
000042  6852              LDR      r2,[r2,#4]            ;498
000044  6010              STR      r0,[r2,#0]            ;498
000046  6042              STR      r2,[r0,#4]            ;498
000048  69a0              LDR      r0,[r4,#0x18]         ;499  ; RMP_Cur_Thd
00004a  69a2              LDR      r2,[r4,#0x18]         ;499  ; RMP_Cur_Thd
00004c  6a52              LDR      r2,[r2,#0x24]         ;499
00004e  f8512032          LDR      r2,[r1,r2,LSL #3]     ;499
000052  f8d4c018          LDR      r12,[r4,#0x18]        ;499  ; RMP_Cur_Thd
000056  f8dcc024          LDR      r12,[r12,#0x24]       ;499
00005a  eb0101cc          ADD      r1,r1,r12,LSL #3      ;499
00005e  6008              STR      r0,[r1,#0]            ;499
000060  6041              STR      r1,[r0,#4]            ;499
000062  6002              STR      r2,[r0,#0]            ;499
000064  6050              STR      r0,[r2,#4]            ;499
                  |L39.102|
000066  69a0              LDR      r0,[r4,#0x18]         ;505  ; RMP_Cur_Thd
000068  69a1              LDR      r1,[r4,#0x18]         ;505  ; RMP_Cur_Thd
00006a  69c0              LDR      r0,[r0,#0x1c]         ;505
00006c  6208              STR      r0,[r1,#0x20]         ;506
00006e  6858              LDR      r0,[r3,#4]            ;506
000070  61a0              STR      r0,[r4,#0x18]         ;506  ; RMP_Cur_Thd
                  |L39.114|
000072  69a0              LDR      r0,[r4,#0x18]         ;511  ; RMP_Cur_Thd
000074  6b40              LDR      r0,[r0,#0x34]         ;511
000076  61e0              STR      r0,[r4,#0x1c]         ;511  ; RMP_Cur_SP
000078  bd70              POP      {r4-r6,pc}
;;;513    /* End Function:_RMP_Get_High_Rdy ********************************************/
                          ENDP

00007a  0000              DCW      0x0000
                  |L39.124|
                          DCD      ||.data||
                  |L39.128|
                          DCD      ||.bss||

                          AREA ||i._RMP_Get_Near_Ticks||, CODE, READONLY, ALIGN=2

                  _RMP_Get_Near_Ticks PROC
;;;564    ******************************************************************************/
;;;565    ptr_t _RMP_Get_Near_Ticks(void)
000000  4a0c              LDR      r2,|L40.52|
;;;566    {
;;;567        ptr_t Value;
;;;568        struct RMP_Thd* Thread;
;;;569        
;;;570        /* What is the current thread's timeout value? */
;;;571        Value=RMP_Cur_Thd->Slices_Left;
000002  6990              LDR      r0,[r2,#0x18]  ; RMP_Cur_Thd
;;;572        
;;;573        /* What is the nearest timer timeout value? */
;;;574        if((&RMP_Delay)!=RMP_Delay.Next)
000004  f1020120          ADD      r1,r2,#0x20
000008  6a00              LDR      r0,[r0,#0x20]         ;571
00000a  684b              LDR      r3,[r1,#4]  ; RMP_Delay
00000c  428b              CMP      r3,r1
00000e  d008              BEQ      |L40.34|
;;;575        {
;;;576            Thread=RMP_DLY2THD(RMP_Delay.Next);
000010  6849              LDR      r1,[r1,#4]  ; RMP_Delay
;;;577            /* See if it is nearer - don't worry about the situation that the timer
;;;578             * have overflown, because if that is to happen, it would have been 
;;;579             * already processed by the timeout processing routine just called above. */
;;;580            if((Thread->Timeout-RMP_Tick)<Value)
;;;581                Value=Thread->Timeout-RMP_Tick;
000012  f8d2c004          LDR      r12,[r2,#4]  ; RMP_Tick
000016  6a0b              LDR      r3,[r1,#0x20]
000018  3908              SUBS     r1,r1,#8
00001a  eba3030c          SUB      r3,r3,r12
00001e  4283              CMP      r3,r0
000020  d303              BCC      |L40.42|
                  |L40.34|
;;;582        }
;;;583        
;;;584        /* The timer setting is at least 1 tick */
;;;585        if(Value==0)
000022  2800              CMP      r0,#0
;;;586            Value=1;
000024  bf08              IT       EQ
000026  2001              MOVEQ    r0,#1
;;;587        
;;;588        return Value;
;;;589    }
000028  4770              BX       lr
                  |L40.42|
00002a  6a88              LDR      r0,[r1,#0x28]         ;581
00002c  6851              LDR      r1,[r2,#4]            ;581  ; RMP_Tick
00002e  1a40              SUBS     r0,r0,r1              ;581
000030  e7f7              B        |L40.34|
;;;590    /* End Function:_RMP_Get_Near_Ticks ******************************************/
                          ENDP

000032  0000              DCW      0x0000
                  |L40.52|
                          DCD      ||.data||

                          AREA ||i._RMP_Set_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Set_Rdy PROC
;;;599    ******************************************************************************/
;;;600    void _RMP_Set_Rdy(volatile struct RMP_Thd* Thread)
000000  6a41              LDR      r1,[r0,#0x24]
;;;601    {
;;;602        /* Insert this into the corresponding runqueue */
;;;603        RMP_List_Ins(&(Thread->Run_Head),RMP_Run[Thread->Prio].Prev,&(RMP_Run[Thread->Prio]));
000002  4a10              LDR      r2,|L41.68|
000004  f8521031          LDR      r1,[r2,r1,LSL #3]
000008  6a43              LDR      r3,[r0,#0x24]
00000a  eb0202c3          ADD      r2,r2,r3,LSL #3
00000e  6010              STR      r0,[r2,#0]
000010  6042              STR      r2,[r0,#4]
000012  6001              STR      r1,[r0,#0]
000014  6048              STR      r0,[r1,#4]
;;;604        /* Set this runlevel as active */
;;;605        RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]|=((ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK);
000016  6a41              LDR      r1,[r0,#0x24]
000018  4a0b              LDR      r2,|L41.72|
00001a  0949              LSRS     r1,r1,#5
00001c  eb020181          ADD      r1,r2,r1,LSL #2
000020  680b              LDR      r3,[r1,#0]
000022  6a42              LDR      r2,[r0,#0x24]
000024  f0020c0f          AND      r12,r2,#0xf
000028  2201              MOVS     r2,#1
00002a  fa02fc0c          LSL      r12,r2,r12
00002e  ea43030c          ORR      r3,r3,r12
000032  600b              STR      r3,[r1,#0]
;;;606        
;;;607        /* Compare this with the current one to see if we need a context switch */
;;;608        if(Thread->Prio>RMP_Cur_Thd->Prio)
000034  6a41              LDR      r1,[r0,#0x24]
000036  4804              LDR      r0,|L41.72|
000038  6983              LDR      r3,[r0,#0x18]  ; RMP_Cur_Thd
00003a  6a5b              LDR      r3,[r3,#0x24]
00003c  4299              CMP      r1,r3
;;;609            RMP_Sched_Pend=1;
00003e  bf88              IT       HI
000040  6102              STRHI    r2,[r0,#0x10]  ; RMP_Sched_Pend
;;;610    }
000042  4770              BX       lr
;;;611    /* End Function:_RMP_Set_Rdy *************************************************/
                          ENDP

                  |L41.68|
                          DCD      ||.bss||
                  |L41.72|
                          DCD      ||.data||

                          AREA ||i._RMP_Tick_Handler||, CODE, READONLY, ALIGN=2

                  _RMP_Tick_Handler PROC
;;;520    ******************************************************************************/
;;;521    void _RMP_Tick_Handler(ptr_t Ticks)
000000  b510              PUSH     {r4,lr}
;;;522    {
;;;523        struct RMP_Thd* Thread;
;;;524        /* Increase the timestamp as always */
;;;525        RMP_Tick+=Ticks;
000002  4c17              LDR      r4,|L42.96|
000004  6861              LDR      r1,[r4,#4]  ; RMP_Tick
000006  4401              ADD      r1,r1,r0
000008  6061              STR      r1,[r4,#4]  ; RMP_Tick
;;;526    #if(RMP_USE_HOOKS==RMP_TRUE)
;;;527        RMP_Tick_Hook(Ticks);
;;;528    #endif
;;;529        /* See if the current thread expired. If yes, trigger a scheduler event */
;;;530        if(Ticks>=RMP_Cur_Thd->Slices_Left)
00000a  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
;;;531            RMP_Sched_Pend=1;
00000c  2201              MOVS     r2,#1
00000e  6a09              LDR      r1,[r1,#0x20]         ;530
000010  4281              CMP      r1,r0                 ;530
000012  bf98              IT       LS
000014  6122              STRLS    r2,[r4,#0x10]  ; RMP_Sched_Pend
000016  d903              BLS      |L42.32|
;;;532        else
;;;533            RMP_Cur_Thd->Slices_Left-=Ticks;
000018  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
00001a  6a0b              LDR      r3,[r1,#0x20]
00001c  1a18              SUBS     r0,r3,r0
00001e  6208              STR      r0,[r1,#0x20]
                  |L42.32|
;;;534        
;;;535        /* Is the scheduler locked? If yes, we cannot process timer events here and will have to pend them */
;;;536        if((&RMP_Delay)!=RMP_Delay.Next)
000020  4810              LDR      r0,|L42.100|
000022  6841              LDR      r1,[r0,#4]  ; RMP_Delay
000024  4281              CMP      r1,r0
000026  d00c              BEQ      |L42.66|
;;;537        {
;;;538            Thread=RMP_DLY2THD(RMP_Delay.Next);
000028  6840              LDR      r0,[r0,#4]  ; RMP_Delay
;;;539            /* If the value is less than this, then it means that the time have
;;;540             * already passed and we have to process this */
;;;541            if((RMP_Tick-Thread->Timeout)<=(RMP_ALLBITS>>1))
00002a  6861              LDR      r1,[r4,#4]  ; RMP_Tick
00002c  6a00              LDR      r0,[r0,#0x20]
00002e  1a08              SUBS     r0,r1,r0
000030  f1b04f00          CMP      r0,#0x80000000
000034  d205              BCS      |L42.66|
;;;542            {
;;;543                /* If scheduler locked, we pend the processing until it is unlocked */
;;;544                if(RMP_Sched_Locked!=0)
000036  68e0              LDR      r0,[r4,#0xc]  ; RMP_Sched_Locked
000038  2800              CMP      r0,#0
;;;545                    RMP_Timer_Pend=1;
00003a  bf14              ITE      NE
00003c  6162              STRNE    r2,[r4,#0x14]  ; RMP_Timer_Pend
;;;546                else
;;;547                    _RMP_Timer_Proc();
00003e  f7fffffe          BLEQ     _RMP_Timer_Proc
                  |L42.66|
;;;548            }
;;;549        }
;;;550        
;;;551        if((RMP_Sched_Locked==0)&&(RMP_Sched_Pend!=0))
000042  68e0              LDR      r0,[r4,#0xc]  ; RMP_Sched_Locked
000044  2800              CMP      r0,#0
;;;552        {
;;;553            RMP_Sched_Pend=0;
;;;554            _RMP_Yield();
;;;555        }
;;;556    }
000046  bf18              IT       NE
000048  bd10              POPNE    {r4,pc}
00004a  6920              LDR      r0,[r4,#0x10]         ;551  ; RMP_Sched_Pend
00004c  2800              CMP      r0,#0                 ;551
00004e  bf08              IT       EQ
000050  bd10              POPEQ    {r4,pc}
000052  2000              MOVS     r0,#0                 ;553
000054  6120              STR      r0,[r4,#0x10]         ;553  ; RMP_Sched_Pend
000056  e8bd4010          POP      {r4,lr}               ;554
00005a  f7ffbffe          B.W      _RMP_Yield
;;;557    /* End Function:_RMP_Tick_Handler ********************************************/
                          ENDP

00005e  0000              DCW      0x0000
                  |L42.96|
                          DCD      ||.data||
                  |L42.100|
                          DCD      ||.data||+0x20

                          AREA ||i._RMP_Timer_Proc||, CODE, READONLY, ALIGN=2

                  _RMP_Timer_Proc PROC
;;;409    ******************************************************************************/
;;;410    void _RMP_Timer_Proc(void)
000000  4a2a              LDR      r2,|L43.172|
;;;411    {
;;;412        struct RMP_Thd* Thread;
;;;413        
;;;414        /* Process the timer events, if there are any of them */
;;;415        while((&RMP_Delay)!=RMP_Delay.Next)
000002  6850              LDR      r0,[r2,#4]  ; RMP_Delay
000004  4290              CMP      r0,r2
;;;416        {
;;;417            Thread=RMP_DLY2THD(RMP_Delay.Next);
;;;418            /* If the value is more than this, then it means that the time have
;;;419             * already passed and we have to process this */
;;;420            if((RMP_Tick-Thread->Timeout)>(RMP_ALLBITS>>1))
;;;421                break;
;;;422            
;;;423            /* This thread should be processed */
;;;424            RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;425            switch(RMP_THD_STATE(Thread->State))
;;;426            {
;;;427                case RMP_THD_SNDDLY:
;;;428                case RMP_THD_SEMDLY:
;;;429                {
;;;430                    RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;431                    Thread->Retval=RMP_ERR_OPER;
;;;432                    break;
;;;433                }
;;;434                
;;;435                case RMP_THD_RCVDLY:
;;;436                {
;;;437                    Thread->Retval=RMP_ERR_OPER;
;;;438                    break;
;;;439                }
;;;440                
;;;441                case RMP_THD_DELAYED:break;
;;;442                /* Should not get here */
;;;443                default:break;
;;;444            }
;;;445    
;;;446            RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;447            /* Is it suspended? If yes, we can't directly set it running */
;;;448            if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;449            {
;;;450                /* Insert this into the corresponding runqueue */
;;;451                RMP_List_Ins(&(Thread->Run_Head),RMP_Run[Thread->Prio].Prev,&(RMP_Run[Thread->Prio]));
;;;452                /* Set this runlevel as active */
;;;453                RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]|=1<<(Thread->Prio&RMP_WORD_MASK);
;;;454                /* See if we need to pend a scheduling event */
;;;455                if(Thread->Prio>RMP_Cur_Thd->Prio)
;;;456                    RMP_Sched_Pend=1;
;;;457            }
;;;458        }
;;;459    }
000006  bf08              IT       EQ
000008  4770              BXEQ     lr
00000a  e92d01f0          PUSH     {r4-r8}               ;411
00000e  f8dfc0a4          LDR      r12,|L43.180|
000012  4b27              LDR      r3,|L43.176|
000014  f06f0704          MVN      r7,#4                 ;431
000018  4661              MOV      r1,r12                ;420
00001a  2401              MOVS     r4,#1                 ;453
                  |L43.28|
00001c  6850              LDR      r0,[r2,#4]            ;417  ; RMP_Delay
00001e  684e              LDR      r6,[r1,#4]            ;420  ; RMP_Tick
000020  6a05              LDR      r5,[r0,#0x20]         ;420
000022  3808              SUBS     r0,r0,#8              ;420
000024  1b75              SUBS     r5,r6,r5              ;420
000026  f1b54f00          CMP      r5,#0x80000000        ;420
00002a  bf24              ITT      CS
00002c  e8bd01f0          POPCS    {r4-r8}
000030  4770              BXCS     lr
000032  e9d05602          LDRD     r5,r6,[r0,#8]
000036  6035              STR      r5,[r6,#0]
000038  606e              STR      r6,[r5,#4]
00003a  7e05              LDRB     r5,[r0,#0x18]         ;425
00003c  2d03              CMP      r5,#3                 ;425
00003e  d006              BEQ      |L43.78|
000040  2d05              CMP      r5,#5                 ;425
000042  bf0c              ITE      EQ                    ;437
000044  6387              STREQ    r7,[r0,#0x38]         ;437
000046  2d06              CMPNE    r5,#6                 ;425
000048  d006              BEQ      |L43.88|
00004a  2d08              CMP      r5,#8                 ;425
00004c  d104              BNE      |L43.88|
                  |L43.78|
00004e  e9d05600          LDRD     r5,r6,[r0,#0]         ;425
000052  6035              STR      r5,[r6,#0]            ;425
000054  606e              STR      r6,[r5,#4]            ;425
000056  6387              STR      r7,[r0,#0x38]         ;431
                  |L43.88|
000058  6985              LDR      r5,[r0,#0x18]         ;446
00005a  f02505ff          BIC      r5,r5,#0xff           ;446
00005e  f0450501          ORR      r5,r5,#1              ;446
000062  f4157f80          TST      r5,#0x100             ;448
000066  6185              STR      r5,[r0,#0x18]         ;448
000068  d11a              BNE      |L43.160|
00006a  6a45              LDR      r5,[r0,#0x24]         ;451
00006c  f8536035          LDR      r6,[r3,r5,LSL #3]     ;451
000070  eb0305c5          ADD      r5,r3,r5,LSL #3       ;451
000074  6028              STR      r0,[r5,#0]            ;451
000076  6045              STR      r5,[r0,#4]            ;451
000078  6006              STR      r6,[r0,#0]            ;451
00007a  6070              STR      r0,[r6,#4]            ;451
00007c  6a45              LDR      r5,[r0,#0x24]         ;453
00007e  096e              LSRS     r6,r5,#5              ;453
000080  f85c8026          LDR      r8,[r12,r6,LSL #2]    ;453
000084  f005050f          AND      r5,r5,#0xf            ;453
000088  fa04f505          LSL      r5,r4,r5              ;453
00008c  ea480505          ORR      r5,r8,r5              ;453
000090  f84c5026          STR      r5,[r12,r6,LSL #2]    ;453
000094  6a40              LDR      r0,[r0,#0x24]         ;455
000096  698d              LDR      r5,[r1,#0x18]         ;455  ; RMP_Cur_Thd
000098  6a6d              LDR      r5,[r5,#0x24]         ;455
00009a  42a8              CMP      r0,r5                 ;455
00009c  bf88              IT       HI                    ;456
00009e  610c              STRHI    r4,[r1,#0x10]         ;456  ; RMP_Sched_Pend
                  |L43.160|
0000a0  6850              LDR      r0,[r2,#4]            ;415  ; RMP_Delay
0000a2  4290              CMP      r0,r2                 ;415
0000a4  d1ba              BNE      |L43.28|
0000a6  e8bd01f0          POP      {r4-r8}
0000aa  4770              BX       lr
;;;460    /* Begin Function:_RMP_Timer_Proc ********************************************/
                          ENDP

                  |L43.172|
                          DCD      ||.data||+0x20
                  |L43.176|
                          DCD      ||.bss||
                  |L43.180|
                          DCD      ||.data||

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;1617   ******************************************************************************/
;;;1618   int main(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1619   {
;;;1620       ptr_t Count;
;;;1621       /* Initialize the kernel data structures first */
;;;1622       _RMP_Low_Level_Init();
000004  f7fffffe          BL       _RMP_Low_Level_Init
;;;1623       
;;;1624   #if(RMP_USE_HOOKS==RMP_TRUE)
;;;1625       RMP_Start_Hook();
;;;1626   #endif
;;;1627       
;;;1628       RMP_Tick=0;
000008  4b2f              LDR      r3,|L44.200|
00000a  2000              MOVS     r0,#0
00000c  6058              STR      r0,[r3,#4]  ; RMP_Tick
;;;1629       /* Now initialize the kernel data structures */
;;;1630       RMP_Sched_Lock_Cnt=0;
00000e  6098              STR      r0,[r3,#8]  ; RMP_Sched_Lock_Cnt
;;;1631       RMP_Sched_Locked=0;
000010  60d8              STR      r0,[r3,#0xc]  ; RMP_Sched_Locked
;;;1632       RMP_Sched_Pend=0;
000012  6118              STR      r0,[r3,#0x10]  ; RMP_Sched_Pend
;;;1633       RMP_Timer_Pend=0;
000014  6158              STR      r0,[r3,#0x14]  ; RMP_Timer_Pend
;;;1634       
;;;1635       /* Linked lists */
;;;1636       RMP_List_Crt(&RMP_Delay);
000016  f1030120          ADD      r1,r3,#0x20
00001a  6009              STR      r1,[r1,#0]
00001c  6049              STR      r1,[r1,#4]
;;;1637       for(Count=0;Count<RMP_MAX_PREEMPT_PRIO;Count++)
;;;1638           RMP_List_Crt(&RMP_Run[Count]);
00001e  4c2b              LDR      r4,|L44.204|
000020  4601              MOV      r1,r0                 ;1637
000022  bf00              NOP      
                  |L44.36|
000024  eb0402c1          ADD      r2,r4,r1,LSL #3
000028  6012              STR      r2,[r2,#0]
00002a  6052              STR      r2,[r2,#4]
00002c  1c49              ADDS     r1,r1,#1
00002e  2920              CMP      r1,#0x20
000030  d3f8              BCC      |L44.36|
;;;1639       for(Count=0;Count<RMP_BITMAP_SIZE;Count++)
;;;1640           RMP_Bitmap[Count]=0;
000032  4d25              LDR      r5,|L44.200|
000034  6028              STR      r0,[r5,#0]  ; RMP_Bitmap
;;;1641           
;;;1642       /* Now boot into the first thread */
;;;1643       RMP_Clear(&RMP_Init_Thd,sizeof(struct RMP_Thd));
000036  f8dfc098          LDR      r12,|L44.208|
00003a  273c              MOVS     r7,#0x3c
00003c  2601              MOVS     r6,#1
00003e  f04f080f          MOV      r8,#0xf
000042  4661              MOV      r1,r12
000044  2207              MOVS     r2,#7
000046  f8cc0000          STR      r0,[r12,#0]
                  |L44.74|
00004a  6048              STR      r0,[r1,#4]
00004c  f8410f08          STR      r0,[r1,#8]!
000050  1e52              SUBS     r2,r2,#1
000052  d1fa              BNE      |L44.74|
000054  eb0c0188          ADD      r1,r12,r8,LSL #2
000058  f0070203          AND      r2,r7,#3
00005c  f0170f03          TST      r7,#3
000060  d00c              BEQ      |L44.124|
000062  1e49              SUBS     r1,r1,#1
000064  f0120f01          TST      r2,#1
000068  bf18              IT       NE
00006a  f8010f01          STRBNE   r0,[r1,#1]!
00006e  0852              LSRS     r2,r2,#1
000070  d004              BEQ      |L44.124|
                  |L44.114|
000072  7048              STRB     r0,[r1,#1]
000074  f8010f02          STRB     r0,[r1,#2]!
000078  1e52              SUBS     r2,r2,#1
00007a  d1fa              BNE      |L44.114|
                  |L44.124|
;;;1644       RMP_Init_Thd.Prio=0;
00007c  4a14              LDR      r2,|L44.208|
00007e  6250              STR      r0,[r2,#0x24]  ; RMP_Init_Thd
;;;1645       RMP_Init_Thd.Slices=10;
000080  200a              MOVS     r0,#0xa
000082  61d0              STR      r0,[r2,#0x1c]  ; RMP_Init_Thd
;;;1646       RMP_Init_Thd.Slices_Left=10;
000084  6210              STR      r0,[r2,#0x20]  ; RMP_Init_Thd
;;;1647       RMP_Init_Thd.State=RMP_THD_RUNNING;
000086  6196              STR      r6,[r2,#0x18]  ; RMP_Init_Thd
;;;1648       RMP_Init_Thd.Stack=RMP_INIT_STACK;
000088  f1a20044          SUB      r0,r2,#0x44
00008c  6350              STR      r0,[r2,#0x34]  ; RMP_Init_Thd
;;;1649       
;;;1650       /* Initialize sending list */
;;;1651       RMP_List_Crt(&(RMP_Init_Thd.Snd_List));
00008e  f1020110          ADD      r1,r2,#0x10
000092  6111              STR      r1,[r2,#0x10]
000094  6151              STR      r1,[r2,#0x14]
;;;1652       
;;;1653       /* Insert this into the corresponding runqueue */
;;;1654       RMP_List_Ins(&(RMP_Init_Thd.Run_Head),RMP_Run[0].Prev,&(RMP_Run[0]));
000096  6821              LDR      r1,[r4,#0]  ; RMP_Run
000098  3044              ADDS     r0,r0,#0x44
00009a  f5a07c00          SUB      r12,r0,#0x200
00009e  f8cc0000          STR      r0,[r12,#0]
0000a2  f8c0c004          STR      r12,[r0,#4]
0000a6  6001              STR      r1,[r0,#0]
0000a8  6048              STR      r0,[r1,#4]
;;;1655       /* Set this runlevel as active - in fact it is always active */
;;;1656       RMP_Bitmap[0]|=1;
0000aa  6828              LDR      r0,[r5,#0]  ; RMP_Bitmap
0000ac  f0400001          ORR      r0,r0,#1
0000b0  6028              STR      r0,[r5,#0]  ; RMP_Bitmap
;;;1657       
;;;1658       /* Set current thread and stack */
;;;1659       RMP_Cur_Thd=(struct RMP_Thd*)(&RMP_Init_Thd);
0000b2  619a              STR      r2,[r3,#0x18]  ; RMP_Cur_Thd
;;;1660       RMP_Cur_SP=RMP_Init_Thd.Stack;
0000b4  6b50              LDR      r0,[r2,#0x34]  ; RMP_Init_Thd
0000b6  61d8              STR      r0,[r3,#0x1c]  ; RMP_Cur_SP
;;;1661       
;;;1662       /* Now jump to the user function and will never return. Initialization of stack is not needed */
;;;1663       _RMP_Start((ptr_t)RMP_Init, (ptr_t)RMP_Init_Thd.Stack);
0000b8  6b51              LDR      r1,[r2,#0x34]  ; RMP_Init_Thd
0000ba  4806              LDR      r0,|L44.212|
0000bc  f7fffffe          BL       _RMP_Start
;;;1664       
;;;1665       return 0;
0000c0  2000              MOVS     r0,#0
;;;1666   }
0000c2  e8bd81f0          POP      {r4-r8,pc}
;;;1667   /* End Function:main *********************************************************/
                          ENDP

0000c6  0000              DCW      0x0000
                  |L44.200|
                          DCD      ||.data||
                  |L44.204|
                          DCD      ||.bss||
                  |L44.208|
                          DCD      ||.bss||+0x200
                  |L44.212|
                          DCD      RMP_Init

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  RMP_Run
                          %        256
                  RMP_Init_Stack
                          %        256
                  RMP_Init_Thd
                          %        60

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  RMP_RBIT_Table
000000  008040c0          DCB      0x00,0x80,0x40,0xc0
000004  20a060e0          DCB      0x20,0xa0,0x60,0xe0
000008  109050d0          DCB      0x10,0x90,0x50,0xd0
00000c  30b070f0          DCB      0x30,0xb0,0x70,0xf0
000010  088848c8          DCB      0x08,0x88,0x48,0xc8
000014  28a868e8          DCB      0x28,0xa8,0x68,0xe8
000018  189858d8          DCB      0x18,0x98,0x58,0xd8
00001c  38b878f8          DCB      0x38,0xb8,0x78,0xf8
000020  048444c4          DCB      0x04,0x84,0x44,0xc4
000024  24a464e4          DCB      0x24,0xa4,0x64,0xe4
000028  149454d4          DCB      0x14,0x94,0x54,0xd4
00002c  34b474f4          DCB      0x34,0xb4,0x74,0xf4
000030  0c8c4ccc          DCB      0x0c,0x8c,0x4c,0xcc
000034  2cac6cec          DCB      0x2c,0xac,0x6c,0xec
000038  1c9c5cdc          DCB      0x1c,0x9c,0x5c,0xdc
00003c  3cbc7cfc          DCB      0x3c,0xbc,0x7c,0xfc
000040  028242c2          DCB      0x02,0x82,0x42,0xc2
000044  22a262e2          DCB      0x22,0xa2,0x62,0xe2
000048  129252d2          DCB      0x12,0x92,0x52,0xd2
00004c  32b272f2          DCB      0x32,0xb2,0x72,0xf2
000050  0a8a4aca          DCB      0x0a,0x8a,0x4a,0xca
000054  2aaa6aea          DCB      0x2a,0xaa,0x6a,0xea
000058  1a9a5ada          DCB      0x1a,0x9a,0x5a,0xda
00005c  3aba7afa          DCB      0x3a,0xba,0x7a,0xfa
000060  068646c6          DCB      0x06,0x86,0x46,0xc6
000064  26a666e6          DCB      0x26,0xa6,0x66,0xe6
000068  169656d6          DCB      0x16,0x96,0x56,0xd6
00006c  36b676f6          DCB      0x36,0xb6,0x76,0xf6
000070  0e8e4ece          DCB      0x0e,0x8e,0x4e,0xce
000074  2eae6eee          DCB      0x2e,0xae,0x6e,0xee
000078  1e9e5ede          DCB      0x1e,0x9e,0x5e,0xde
00007c  3ebe7efe          DCB      0x3e,0xbe,0x7e,0xfe
000080  018141c1          DCB      0x01,0x81,0x41,0xc1
000084  21a161e1          DCB      0x21,0xa1,0x61,0xe1
000088  119151d1          DCB      0x11,0x91,0x51,0xd1
00008c  31b171f1          DCB      0x31,0xb1,0x71,0xf1
000090  098949c9          DCB      0x09,0x89,0x49,0xc9
000094  29a969e9          DCB      0x29,0xa9,0x69,0xe9
000098  199959d9          DCB      0x19,0x99,0x59,0xd9
00009c  39b979f9          DCB      0x39,0xb9,0x79,0xf9
0000a0  058545c5          DCB      0x05,0x85,0x45,0xc5
0000a4  25a565e5          DCB      0x25,0xa5,0x65,0xe5
0000a8  159555d5          DCB      0x15,0x95,0x55,0xd5
0000ac  35b575f5          DCB      0x35,0xb5,0x75,0xf5
0000b0  0d8d4dcd          DCB      0x0d,0x8d,0x4d,0xcd
0000b4  2dad6ded          DCB      0x2d,0xad,0x6d,0xed
0000b8  1d9d5ddd          DCB      0x1d,0x9d,0x5d,0xdd
0000bc  3dbd7dfd          DCB      0x3d,0xbd,0x7d,0xfd
0000c0  038343c3          DCB      0x03,0x83,0x43,0xc3
0000c4  23a363e3          DCB      0x23,0xa3,0x63,0xe3
0000c8  139353d3          DCB      0x13,0x93,0x53,0xd3
0000cc  33b373f3          DCB      0x33,0xb3,0x73,0xf3
0000d0  0b8b4bcb          DCB      0x0b,0x8b,0x4b,0xcb
0000d4  2bab6beb          DCB      0x2b,0xab,0x6b,0xeb
0000d8  1b9b5bdb          DCB      0x1b,0x9b,0x5b,0xdb
0000dc  3bbb7bfb          DCB      0x3b,0xbb,0x7b,0xfb
0000e0  078747c7          DCB      0x07,0x87,0x47,0xc7
0000e4  27a767e7          DCB      0x27,0xa7,0x67,0xe7
0000e8  179757d7          DCB      0x17,0x97,0x57,0xd7
0000ec  37b777f7          DCB      0x37,0xb7,0x77,0xf7
0000f0  0f8f4fcf          DCB      0x0f,0x8f,0x4f,0xcf
0000f4  2faf6fef          DCB      0x2f,0xaf,0x6f,0xef
0000f8  1f9f5fdf          DCB      0x1f,0x9f,0x5f,0xdf
0000fc  3fbf7fff          DCB      0x3f,0xbf,0x7f,0xff
                  CRC16_High
000100  00c18140          DCB      0x00,0xc1,0x81,0x40
000104  01c08041          DCB      0x01,0xc0,0x80,0x41
000108  01c08041          DCB      0x01,0xc0,0x80,0x41
00010c  00c18140          DCB      0x00,0xc1,0x81,0x40
000110  01c08041          DCB      0x01,0xc0,0x80,0x41
000114  00c18140          DCB      0x00,0xc1,0x81,0x40
000118  00c18140          DCB      0x00,0xc1,0x81,0x40
00011c  01c08041          DCB      0x01,0xc0,0x80,0x41
000120  01c08041          DCB      0x01,0xc0,0x80,0x41
000124  00c18140          DCB      0x00,0xc1,0x81,0x40
000128  00c18140          DCB      0x00,0xc1,0x81,0x40
00012c  01c08041          DCB      0x01,0xc0,0x80,0x41
000130  00c18140          DCB      0x00,0xc1,0x81,0x40
000134  01c08041          DCB      0x01,0xc0,0x80,0x41
000138  01c08041          DCB      0x01,0xc0,0x80,0x41
00013c  00c18140          DCB      0x00,0xc1,0x81,0x40
000140  01c08041          DCB      0x01,0xc0,0x80,0x41
000144  00c18140          DCB      0x00,0xc1,0x81,0x40
000148  00c18140          DCB      0x00,0xc1,0x81,0x40
00014c  01c08041          DCB      0x01,0xc0,0x80,0x41
000150  00c18140          DCB      0x00,0xc1,0x81,0x40
000154  01c08041          DCB      0x01,0xc0,0x80,0x41
000158  01c08041          DCB      0x01,0xc0,0x80,0x41
00015c  00c18140          DCB      0x00,0xc1,0x81,0x40
000160  00c18140          DCB      0x00,0xc1,0x81,0x40
000164  01c08041          DCB      0x01,0xc0,0x80,0x41
000168  01c08041          DCB      0x01,0xc0,0x80,0x41
00016c  00c18140          DCB      0x00,0xc1,0x81,0x40
000170  01c08041          DCB      0x01,0xc0,0x80,0x41
000174  00c18140          DCB      0x00,0xc1,0x81,0x40
000178  00c18140          DCB      0x00,0xc1,0x81,0x40
00017c  01c08041          DCB      0x01,0xc0,0x80,0x41
000180  01c08041          DCB      0x01,0xc0,0x80,0x41
000184  00c18140          DCB      0x00,0xc1,0x81,0x40
000188  00c18140          DCB      0x00,0xc1,0x81,0x40
00018c  01c08041          DCB      0x01,0xc0,0x80,0x41
000190  00c18140          DCB      0x00,0xc1,0x81,0x40
000194  01c08041          DCB      0x01,0xc0,0x80,0x41
000198  01c08041          DCB      0x01,0xc0,0x80,0x41
00019c  00c18140          DCB      0x00,0xc1,0x81,0x40
0001a0  00c18140          DCB      0x00,0xc1,0x81,0x40
0001a4  01c08041          DCB      0x01,0xc0,0x80,0x41
0001a8  01c08041          DCB      0x01,0xc0,0x80,0x41
0001ac  00c18140          DCB      0x00,0xc1,0x81,0x40
0001b0  01c08041          DCB      0x01,0xc0,0x80,0x41
0001b4  00c18140          DCB      0x00,0xc1,0x81,0x40
0001b8  00c18140          DCB      0x00,0xc1,0x81,0x40
0001bc  01c08041          DCB      0x01,0xc0,0x80,0x41
0001c0  00c18140          DCB      0x00,0xc1,0x81,0x40
0001c4  01c08041          DCB      0x01,0xc0,0x80,0x41
0001c8  01c08041          DCB      0x01,0xc0,0x80,0x41
0001cc  00c18140          DCB      0x00,0xc1,0x81,0x40
0001d0  01c08041          DCB      0x01,0xc0,0x80,0x41
0001d4  00c18140          DCB      0x00,0xc1,0x81,0x40
0001d8  00c18140          DCB      0x00,0xc1,0x81,0x40
0001dc  01c08041          DCB      0x01,0xc0,0x80,0x41
0001e0  01c08041          DCB      0x01,0xc0,0x80,0x41
0001e4  00c18140          DCB      0x00,0xc1,0x81,0x40
0001e8  00c18140          DCB      0x00,0xc1,0x81,0x40
0001ec  01c08041          DCB      0x01,0xc0,0x80,0x41
0001f0  00c18140          DCB      0x00,0xc1,0x81,0x40
0001f4  01c08041          DCB      0x01,0xc0,0x80,0x41
0001f8  01c08041          DCB      0x01,0xc0,0x80,0x41
0001fc  00c18140          DCB      0x00,0xc1,0x81,0x40
000200  00c0c101          DCB      0x00,0xc0,0xc1,0x01
000204  c30302c2          DCB      0xc3,0x03,0x02,0xc2
000208  c60607c7          DCB      0xc6,0x06,0x07,0xc7
00020c  05c5c404          DCB      0x05,0xc5,0xc4,0x04
000210  cc0c0dcd          DCB      0xcc,0x0c,0x0d,0xcd
000214  0fcfce0e          DCB      0x0f,0xcf,0xce,0x0e
000218  0acacb0b          DCB      0x0a,0xca,0xcb,0x0b
00021c  c90908c8          DCB      0xc9,0x09,0x08,0xc8
000220  d81819d9          DCB      0xd8,0x18,0x19,0xd9
000224  1bdbda1a          DCB      0x1b,0xdb,0xda,0x1a
000228  1ededf1f          DCB      0x1e,0xde,0xdf,0x1f
00022c  dd1d1cdc          DCB      0xdd,0x1d,0x1c,0xdc
000230  14d4d515          DCB      0x14,0xd4,0xd5,0x15
000234  d71716d6          DCB      0xd7,0x17,0x16,0xd6
000238  d21213d3          DCB      0xd2,0x12,0x13,0xd3
00023c  11d1d010          DCB      0x11,0xd1,0xd0,0x10
000240  f03031f1          DCB      0xf0,0x30,0x31,0xf1
000244  33f3f232          DCB      0x33,0xf3,0xf2,0x32
000248  36f6f737          DCB      0x36,0xf6,0xf7,0x37
00024c  f53534f4          DCB      0xf5,0x35,0x34,0xf4
000250  3cfcfd3d          DCB      0x3c,0xfc,0xfd,0x3d
000254  ff3f3efe          DCB      0xff,0x3f,0x3e,0xfe
000258  fa3a3bfb          DCB      0xfa,0x3a,0x3b,0xfb
00025c  39f9f838          DCB      0x39,0xf9,0xf8,0x38
000260  28e8e929          DCB      0x28,0xe8,0xe9,0x29
000264  eb2b2aea          DCB      0xeb,0x2b,0x2a,0xea
000268  ee2e2fef          DCB      0xee,0x2e,0x2f,0xef
00026c  2dedec2c          DCB      0x2d,0xed,0xec,0x2c
000270  e42425e5          DCB      0xe4,0x24,0x25,0xe5
000274  27e7e626          DCB      0x27,0xe7,0xe6,0x26
000278  22e2e323          DCB      0x22,0xe2,0xe3,0x23
00027c  e12120e0          DCB      0xe1,0x21,0x20,0xe0
000280  a06061a1          DCB      0xa0,0x60,0x61,0xa1
000284  63a3a262          DCB      0x63,0xa3,0xa2,0x62
000288  66a6a767          DCB      0x66,0xa6,0xa7,0x67
00028c  a56564a4          DCB      0xa5,0x65,0x64,0xa4
000290  6cacad6d          DCB      0x6c,0xac,0xad,0x6d
000294  af6f6eae          DCB      0xaf,0x6f,0x6e,0xae
000298  aa6a6bab          DCB      0xaa,0x6a,0x6b,0xab
00029c  69a9a868          DCB      0x69,0xa9,0xa8,0x68
0002a0  78b8b979          DCB      0x78,0xb8,0xb9,0x79
0002a4  bb7b7aba          DCB      0xbb,0x7b,0x7a,0xba
0002a8  be7e7fbf          DCB      0xbe,0x7e,0x7f,0xbf
0002ac  7dbdbc7c          DCB      0x7d,0xbd,0xbc,0x7c
0002b0  b47475b5          DCB      0xb4,0x74,0x75,0xb5
0002b4  77b7b676          DCB      0x77,0xb7,0xb6,0x76
0002b8  72b2b373          DCB      0x72,0xb2,0xb3,0x73
0002bc  b17170b0          DCB      0xb1,0x71,0x70,0xb0
0002c0  50909151          DCB      0x50,0x90,0x91,0x51
0002c4  93535292          DCB      0x93,0x53,0x52,0x92
0002c8  96565797          DCB      0x96,0x56,0x57,0x97
0002cc  55959454          DCB      0x55,0x95,0x94,0x54
0002d0  9c5c5d9d          DCB      0x9c,0x5c,0x5d,0x9d
0002d4  5f9f9e5e          DCB      0x5f,0x9f,0x9e,0x5e
0002d8  5a9a9b5b          DCB      0x5a,0x9a,0x9b,0x5b
0002dc  99595898          DCB      0x99,0x59,0x58,0x98
0002e0  88484989          DCB      0x88,0x48,0x49,0x89
0002e4  4b8b8a4a          DCB      0x4b,0x8b,0x8a,0x4a
0002e8  4e8e8f4f          DCB      0x4e,0x8e,0x8f,0x4f
0002ec  8d4d4c8c          DCB      0x8d,0x4d,0x4c,0x8c
0002f0  44848545          DCB      0x44,0x84,0x85,0x45
0002f4  87474686          DCB      0x87,0x47,0x46,0x86
0002f8  82424383          DCB      0x82,0x42,0x43,0x83
0002fc  41818040          DCB      0x41,0x81,0x80,0x40

                          AREA ||.data||, DATA, ALIGN=2

                  RMP_Bitmap
                          DCD      0x00000000
                  RMP_Tick
                          DCD      0x00000000
                  RMP_Sched_Lock_Cnt
                          DCD      0x00000000
                  RMP_Sched_Locked
                          DCD      0x00000000
                  RMP_Sched_Pend
                          DCD      0x00000000
                  RMP_Timer_Pend
                          DCD      0x00000000
                  RMP_Cur_Thd
                          DCD      0x00000000
                  RMP_Cur_SP
                          DCD      0x00000000
                  RMP_Delay
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\..\\MProkaron\\Kernel\\kernel.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_kernel_c_346ad0e8____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F1_V1.6.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___8_kernel_c_346ad0e8____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_kernel_c_346ad0e8____REVSH|
#line 402
|__asm___8_kernel_c_346ad0e8____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___8_kernel_c_346ad0e8____RRX|
#line 587
|__asm___8_kernel_c_346ad0e8____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
