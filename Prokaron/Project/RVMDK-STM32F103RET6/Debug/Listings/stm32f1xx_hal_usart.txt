; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f1xx_hal_usart.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f1xx_hal_usart.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\STM32F1xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\STM32F1xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F103RET6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F10X_HD -DUSE_HAL_DRIVER -DSTM32F103xE --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f1xx_hal_usart.crf ..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_usart.c]
                          THUMB

                          AREA ||i.HAL_USART_Abort||, CODE, READONLY, ALIGN=1

                  HAL_USART_Abort PROC
;;;1217   */
;;;1218   HAL_StatusTypeDef HAL_USART_Abort(USART_HandleTypeDef *husart)
000000  b570              PUSH     {r4-r6,lr}
;;;1219   {
000002  4604              MOV      r4,r0
;;;1220     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1221     CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6800              LDR      r0,[r0,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f42171f0          BIC      r1,r1,#0x1e0
00000c  60c1              STR      r1,[r0,#0xc]
;;;1222     CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
000012  f0210101          BIC      r1,r1,#1
000016  6141              STR      r1,[r0,#0x14]
;;;1223   
;;;1224     /* Disable the USART DMA Tx request if enabled */
;;;1225     if(HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT))
000018  6820              LDR      r0,[r4,#0]
00001a  6941              LDR      r1,[r0,#0x14]
00001c  f04f0500          MOV      r5,#0
000020  f0110f80          TST      r1,#0x80
000024  d009              BEQ      |L1.58|
;;;1226     {
;;;1227       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
000026  6941              LDR      r1,[r0,#0x14]
000028  f0210180          BIC      r1,r1,#0x80
00002c  6141              STR      r1,[r0,#0x14]
;;;1228   
;;;1229       /* Abort the USART DMA Tx channel : use blocking DMA Abort API (no callback) */
;;;1230       if(husart->hdmatx != NULL)
00002e  6b60              LDR      r0,[r4,#0x34]
000030  b118              CBZ      r0,|L1.58|
;;;1231       {
;;;1232         /* Set the USART DMA Abort callback to Null. 
;;;1233            No call back execution at end of DMA abort procedure */
;;;1234         husart->hdmatx->XferAbortCallback = NULL;
;;;1235   
;;;1236         HAL_DMA_Abort(husart->hdmatx);
000032  6385              STR      r5,[r0,#0x38]
000034  6b60              LDR      r0,[r4,#0x34]
000036  f7fffffe          BL       HAL_DMA_Abort
                  |L1.58|
;;;1237       }
;;;1238     }
;;;1239   
;;;1240     /* Disable the USART DMA Rx request if enabled */
;;;1241     if(HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
00003a  6820              LDR      r0,[r4,#0]
00003c  6941              LDR      r1,[r0,#0x14]
00003e  f0110f40          TST      r1,#0x40
000042  d009              BEQ      |L1.88|
;;;1242     {
;;;1243       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
000044  6941              LDR      r1,[r0,#0x14]
000046  f0210140          BIC      r1,r1,#0x40
00004a  6141              STR      r1,[r0,#0x14]
;;;1244   
;;;1245       /* Abort the USART DMA Rx channel : use blocking DMA Abort API (no callback) */
;;;1246       if(husart->hdmarx != NULL)
00004c  6ba0              LDR      r0,[r4,#0x38]
00004e  b118              CBZ      r0,|L1.88|
;;;1247       {
;;;1248         /* Set the USART DMA Abort callback to Null. 
;;;1249            No call back execution at end of DMA abort procedure */
;;;1250         husart->hdmarx->XferAbortCallback = NULL;
;;;1251   
;;;1252         HAL_DMA_Abort(husart->hdmarx);
000050  6385              STR      r5,[r0,#0x38]
000052  6ba0              LDR      r0,[r4,#0x38]
000054  f7fffffe          BL       HAL_DMA_Abort
                  |L1.88|
;;;1253       }
;;;1254     }
;;;1255   
;;;1256     /* Reset Tx and Rx transfer counters */
;;;1257     husart->TxXferCount = 0x00U; 
000058  8565              STRH     r5,[r4,#0x2a]
;;;1258     husart->RxXferCount = 0x00U; 
00005a  8665              STRH     r5,[r4,#0x32]
;;;1259   
;;;1260     /* Restore husart->State to Ready */
;;;1261     husart->State  = HAL_USART_STATE_READY;
00005c  2001              MOVS     r0,#1
00005e  6420              STR      r0,[r4,#0x40]
;;;1262   
;;;1263     /* Reset Handle ErrorCode to No Error */
;;;1264     husart->ErrorCode = HAL_USART_ERROR_NONE;
000060  6465              STR      r5,[r4,#0x44]
;;;1265   
;;;1266     return HAL_OK;
000062  2000              MOVS     r0,#0
;;;1267   }
000064  bd70              POP      {r4-r6,pc}
;;;1268   
                          ENDP


                          AREA ||i.HAL_USART_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_AbortCpltCallback PROC
;;;1629     */
;;;1630   __weak void HAL_USART_AbortCpltCallback (USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1631   {
;;;1632     /* Prevent unused argument(s) compilation warning */
;;;1633     UNUSED(husart);
;;;1634   
;;;1635     /* NOTE : This function should not be modified, when the callback is needed,
;;;1636               the HAL_USART_AbortCpltCallback can be implemented in the user file.
;;;1637      */
;;;1638   }
;;;1639   
                          ENDP


                          AREA ||i.HAL_USART_Abort_IT||, CODE, READONLY, ALIGN=2

                  HAL_USART_Abort_IT PROC
;;;1283   */
;;;1284   HAL_StatusTypeDef HAL_USART_Abort_IT(USART_HandleTypeDef *husart)
000000  b570              PUSH     {r4-r6,lr}
;;;1285   {
000002  4604              MOV      r4,r0
;;;1286     uint32_t AbortCplt = 0x01U;
;;;1287     
;;;1288     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1289     CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6800              LDR      r0,[r0,#0]
000006  2601              MOVS     r6,#1                 ;1286
000008  68c1              LDR      r1,[r0,#0xc]
00000a  f42171f0          BIC      r1,r1,#0x1e0
00000e  60c1              STR      r1,[r0,#0xc]
;;;1290     CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
000010  6820              LDR      r0,[r4,#0]
000012  6941              LDR      r1,[r0,#0x14]
000014  f0210101          BIC      r1,r1,#1
000018  6141              STR      r1,[r0,#0x14]
00001a  6b60              LDR      r0,[r4,#0x34]         ;1285
;;;1291   
;;;1292     /* If DMA Tx and/or DMA Rx Handles are associated to USART Handle, DMA Abort complete callbacks should be initialised
;;;1293        before any call to DMA Abort functions */
;;;1294     /* DMA Tx Handle is valid */
;;;1295     if(husart->hdmatx != NULL)
00001c  2500              MOVS     r5,#0
00001e  b138              CBZ      r0,|L3.48|
;;;1296     {
;;;1297       /* Set DMA Abort Complete callback if USART DMA Tx request if enabled.
;;;1298          Otherwise, set it to NULL */
;;;1299       if(HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT))
000020  6821              LDR      r1,[r4,#0]
000022  6949              LDR      r1,[r1,#0x14]
000024  f0110f80          TST      r1,#0x80
;;;1300       {
;;;1301         husart->hdmatx->XferAbortCallback = USART_DMATxAbortCallback;
;;;1302       }
;;;1303       else
;;;1304       {
;;;1305         husart->hdmatx->XferAbortCallback = NULL;
000028  bf0e              ITEE     EQ
00002a  6385              STREQ    r5,[r0,#0x38]
00002c  491d              LDRNE    r1,|L3.164|
00002e  6381              STRNE    r1,[r0,#0x38]         ;1301
                  |L3.48|
;;;1306       }
;;;1307     }
;;;1308     /* DMA Rx Handle is valid */
;;;1309     if(husart->hdmarx != NULL)
000030  6ba0              LDR      r0,[r4,#0x38]
000032  b138              CBZ      r0,|L3.68|
;;;1310     {
;;;1311       /* Set DMA Abort Complete callback if USART DMA Rx request if enabled.
;;;1312          Otherwise, set it to NULL */
;;;1313       if(HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
000034  6821              LDR      r1,[r4,#0]
000036  6949              LDR      r1,[r1,#0x14]
000038  f0110f40          TST      r1,#0x40
;;;1314       {
;;;1315         husart->hdmarx->XferAbortCallback = USART_DMARxAbortCallback;
;;;1316       }
;;;1317       else
;;;1318       {
;;;1319         husart->hdmarx->XferAbortCallback = NULL;
00003c  bf0e              ITEE     EQ
00003e  6385              STREQ    r5,[r0,#0x38]
000040  4919              LDRNE    r1,|L3.168|
000042  6381              STRNE    r1,[r0,#0x38]         ;1315
                  |L3.68|
;;;1320       }
;;;1321     }
;;;1322     
;;;1323     /* Disable the USART DMA Tx request if enabled */
;;;1324     if(HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT))
000044  6820              LDR      r0,[r4,#0]
000046  6941              LDR      r1,[r0,#0x14]
000048  f0110f80          TST      r1,#0x80
00004c  d00c              BEQ      |L3.104|
;;;1325     {
;;;1326       /* Disable DMA Tx at USART level */
;;;1327       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
00004e  6941              LDR      r1,[r0,#0x14]
000050  f0210180          BIC      r1,r1,#0x80
000054  6141              STR      r1,[r0,#0x14]
;;;1328   
;;;1329       /* Abort the USART DMA Tx channel : use non blocking DMA Abort API (callback) */
;;;1330       if(husart->hdmatx != NULL)
000056  6b60              LDR      r0,[r4,#0x34]
000058  b130              CBZ      r0,|L3.104|
;;;1331       {
;;;1332         /* USART Tx DMA Abort callback has already been initialised : 
;;;1333            will lead to call HAL_USART_AbortCpltCallback() at end of DMA abort procedure */
;;;1334   
;;;1335         /* Abort DMA TX */
;;;1336         if(HAL_DMA_Abort_IT(husart->hdmatx) != HAL_OK)
00005a  f7fffffe          BL       HAL_DMA_Abort_IT
00005e  2800              CMP      r0,#0
;;;1337         {
;;;1338           husart->hdmatx->XferAbortCallback = NULL;
;;;1339         }
;;;1340         else
;;;1341         {
;;;1342           AbortCplt = 0x00U;
000060  bf0e              ITEE     EQ
000062  2600              MOVEQ    r6,#0
000064  6b60              LDRNE    r0,[r4,#0x34]         ;1338
000066  6385              STRNE    r5,[r0,#0x38]         ;1338
                  |L3.104|
;;;1343         }
;;;1344       }
;;;1345     }
;;;1346   
;;;1347     /* Disable the USART DMA Rx request if enabled */
;;;1348     if(HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
000068  6820              LDR      r0,[r4,#0]
00006a  6941              LDR      r1,[r0,#0x14]
00006c  f0110f40          TST      r1,#0x40
000070  d00d              BEQ      |L3.142|
;;;1349     {
;;;1350       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
000072  6941              LDR      r1,[r0,#0x14]
000074  f0210140          BIC      r1,r1,#0x40
000078  6141              STR      r1,[r0,#0x14]
;;;1351   
;;;1352       /* Abort the USART DMA Rx channel : use non blocking DMA Abort API (callback) */
;;;1353       if(husart->hdmarx != NULL)
00007a  6ba0              LDR      r0,[r4,#0x38]
00007c  b138              CBZ      r0,|L3.142|
;;;1354       {
;;;1355         /* USART Rx DMA Abort callback has already been initialised : 
;;;1356            will lead to call HAL_USART_AbortCpltCallback() at end of DMA abort procedure */
;;;1357   
;;;1358         /* Abort DMA RX */
;;;1359         if(HAL_DMA_Abort_IT(husart->hdmarx) != HAL_OK)
00007e  f7fffffe          BL       HAL_DMA_Abort_IT
000082  2800              CMP      r0,#0
;;;1360         {
;;;1361           husart->hdmarx->XferAbortCallback = NULL;
000084  bf1c              ITT      NE
000086  6ba0              LDRNE    r0,[r4,#0x38]
000088  6385              STRNE    r5,[r0,#0x38]
00008a  d009              BEQ      |L3.160|
00008c  e000              B        |L3.144|
                  |L3.142|
;;;1362           AbortCplt = 0x01U;
;;;1363         }
;;;1364         else
;;;1365         {
;;;1366           AbortCplt = 0x00U;
;;;1367         }
;;;1368       }
;;;1369     }
;;;1370   
;;;1371     /* if no DMA abort complete callback execution is required => call user Abort Complete callback */
;;;1372     if(AbortCplt  == 0x01U)
00008e  b13e              CBZ      r6,|L3.160|
                  |L3.144|
;;;1373     {
;;;1374       /* Reset Tx and Rx transfer counters */
;;;1375       husart->TxXferCount = 0x00U; 
000090  8565              STRH     r5,[r4,#0x2a]
;;;1376       husart->RxXferCount = 0x00U;
000092  8665              STRH     r5,[r4,#0x32]
;;;1377   
;;;1378       /* Reset errorCode */
;;;1379       husart->ErrorCode = HAL_USART_ERROR_NONE;
000094  6465              STR      r5,[r4,#0x44]
;;;1380   
;;;1381       /* Restore husart->State to Ready */
;;;1382       husart->State  = HAL_USART_STATE_READY;
000096  2001              MOVS     r0,#1
000098  6420              STR      r0,[r4,#0x40]
;;;1383   
;;;1384       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1385       HAL_USART_AbortCpltCallback(husart);
00009a  4620              MOV      r0,r4
00009c  f7fffffe          BL       HAL_USART_AbortCpltCallback
                  |L3.160|
;;;1386     }
;;;1387   
;;;1388     return HAL_OK;
0000a0  2000              MOVS     r0,#0
;;;1389   }
0000a2  bd70              POP      {r4-r6,pc}
;;;1390   
                          ENDP

                  |L3.164|
                          DCD      USART_DMATxAbortCallback
                  |L3.168|
                          DCD      USART_DMARxAbortCallback

                          AREA ||i.HAL_USART_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_USART_DMAPause PROC
;;;1120     */
;;;1121   HAL_StatusTypeDef HAL_USART_DMAPause(USART_HandleTypeDef *husart)
000000  6bc1              LDR      r1,[r0,#0x3c]
;;;1122   {
;;;1123     /* Process Locked */
;;;1124     __HAL_LOCK(husart);
000002  2901              CMP      r1,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;1125   
;;;1126     /* Disable the USART DMA Tx request */
;;;1127     CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1128   
;;;1129     /* Process Unlocked */
;;;1130     __HAL_UNLOCK(husart);
;;;1131   
;;;1132     return HAL_OK;
;;;1133   }
000008  4770              BXEQ     lr
00000a  2101              MOVS     r1,#1                 ;1124
00000c  63c1              STR      r1,[r0,#0x3c]         ;1127
00000e  6801              LDR      r1,[r0,#0]            ;1127
000010  694a              LDR      r2,[r1,#0x14]         ;1127
000012  f0220280          BIC      r2,r2,#0x80           ;1127
000016  614a              STR      r2,[r1,#0x14]         ;1127
000018  2100              MOVS     r1,#0                 ;1130
00001a  63c1              STR      r1,[r0,#0x3c]         ;1132
00001c  4608              MOV      r0,r1                 ;1132
00001e  4770              BX       lr
;;;1134   
                          ENDP


                          AREA ||i.HAL_USART_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_USART_DMAResume PROC
;;;1140     */
;;;1141   HAL_StatusTypeDef HAL_USART_DMAResume(USART_HandleTypeDef *husart)
000000  6bc1              LDR      r1,[r0,#0x3c]
;;;1142   {
;;;1143     /* Process Locked */
;;;1144     __HAL_LOCK(husart);
000002  2901              CMP      r1,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;1145   
;;;1146     /* Enable the USART DMA Tx request */
;;;1147     SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1148   
;;;1149     /* Process Unlocked */
;;;1150     __HAL_UNLOCK(husart);
;;;1151   
;;;1152     return HAL_OK;
;;;1153   }
000008  4770              BXEQ     lr
00000a  2101              MOVS     r1,#1                 ;1144
00000c  63c1              STR      r1,[r0,#0x3c]         ;1147
00000e  6801              LDR      r1,[r0,#0]            ;1147
000010  694a              LDR      r2,[r1,#0x14]         ;1147
000012  f0420280          ORR      r2,r2,#0x80           ;1147
000016  614a              STR      r2,[r1,#0x14]         ;1147
000018  2100              MOVS     r1,#0                 ;1150
00001a  63c1              STR      r1,[r0,#0x3c]         ;1152
00001c  4608              MOV      r0,r1                 ;1152
00001e  4770              BX       lr
;;;1154   
                          ENDP


                          AREA ||i.HAL_USART_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_USART_DMAStop PROC
;;;1160     */
;;;1161   HAL_StatusTypeDef HAL_USART_DMAStop(USART_HandleTypeDef *husart)
000000  b570              PUSH     {r4-r6,lr}
;;;1162   {
000002  4604              MOV      r4,r0
;;;1163     uint32_t dmarequest = 0x00U;
;;;1164     /* The Lock is not implemented on this API to allow the user application
;;;1165        to call the HAL USART API under callbacks HAL_USART_TxCpltCallback() / HAL_USART_RxCpltCallback():
;;;1166        when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
;;;1167        and the correspond call back is executed HAL_USART_TxCpltCallback() / HAL_USART_RxCpltCallback()
;;;1168        */
;;;1169   
;;;1170     /* Stop USART DMA Tx request if ongoing */
;;;1171     dmarequest = HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT);
000004  6800              LDR      r0,[r0,#0]
000006  6941              LDR      r1,[r0,#0x14]
;;;1172     if((husart->State == HAL_USART_STATE_BUSY_TX) && dmarequest)
000008  6c22              LDR      r2,[r4,#0x40]
00000a  f3c111c0          UBFX     r1,r1,#7,#1           ;1171
00000e  2501              MOVS     r5,#1                 ;1171
000010  2a12              CMP      r2,#0x12
000012  d10f              BNE      |L6.52|
000014  b171              CBZ      r1,|L6.52|
000016  68c1              LDR      r1,[r0,#0xc]
000018  f02101c0          BIC      r1,r1,#0xc0
00001c  60c1              STR      r1,[r0,#0xc]
00001e  6425              STR      r5,[r4,#0x40]
;;;1173     {
;;;1174       USART_EndTxTransfer(husart);
;;;1175   
;;;1176       /* Abort the USART DMA Tx channel */
;;;1177       if(husart->hdmatx != NULL)
000020  6b60              LDR      r0,[r4,#0x34]
000022  2800              CMP      r0,#0
;;;1178       {
;;;1179         HAL_DMA_Abort(husart->hdmatx);
000024  bf18              IT       NE
000026  f7fffffe          BLNE     HAL_DMA_Abort
;;;1180       }
;;;1181   
;;;1182       /* Disable the USART Tx DMA request */
;;;1183       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
00002a  6820              LDR      r0,[r4,#0]
00002c  6941              LDR      r1,[r0,#0x14]
00002e  f0210180          BIC      r1,r1,#0x80
000032  6141              STR      r1,[r0,#0x14]
                  |L6.52|
;;;1184     }
;;;1185   
;;;1186     /* Stop USART DMA Rx request if ongoing */
;;;1187     dmarequest = HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR);
000034  6820              LDR      r0,[r4,#0]
000036  6941              LDR      r1,[r0,#0x14]
;;;1188     if((husart->State == HAL_USART_STATE_BUSY_RX) && dmarequest)
000038  6c22              LDR      r2,[r4,#0x40]
00003a  f3c11180          UBFX     r1,r1,#6,#1           ;1187
00003e  2a22              CMP      r2,#0x22
000040  d114              BNE      |L6.108|
000042  b199              CBZ      r1,|L6.108|
000044  68c1              LDR      r1,[r0,#0xc]
000046  f4217190          BIC      r1,r1,#0x120
00004a  60c1              STR      r1,[r0,#0xc]
00004c  6820              LDR      r0,[r4,#0]
00004e  6941              LDR      r1,[r0,#0x14]
000050  f0210101          BIC      r1,r1,#1
000054  6141              STR      r1,[r0,#0x14]
000056  6425              STR      r5,[r4,#0x40]
;;;1189     {
;;;1190       USART_EndRxTransfer(husart);
;;;1191   
;;;1192       /* Abort the USART DMA Rx channel */
;;;1193       if(husart->hdmarx != NULL)
000058  6ba0              LDR      r0,[r4,#0x38]
00005a  2800              CMP      r0,#0
;;;1194       {
;;;1195         HAL_DMA_Abort(husart->hdmarx);
00005c  bf18              IT       NE
00005e  f7fffffe          BLNE     HAL_DMA_Abort
;;;1196       }
;;;1197   
;;;1198       /* Disable the USART Rx DMA request */
;;;1199       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
000062  6820              LDR      r0,[r4,#0]
000064  6941              LDR      r1,[r0,#0x14]
000066  f0210140          BIC      r1,r1,#0x40
00006a  6141              STR      r1,[r0,#0x14]
                  |L6.108|
;;;1200     }
;;;1201   
;;;1202     return HAL_OK;
00006c  2000              MOVS     r0,#0
;;;1203   }
00006e  bd70              POP      {r4-r6,pc}
;;;1204   
                          ENDP


                          AREA ||i.HAL_USART_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_USART_DeInit PROC
;;;296      */
;;;297    HAL_StatusTypeDef HAL_USART_DeInit(USART_HandleTypeDef *husart)
000000  2800              CMP      r0,#0
;;;298    {
;;;299      /* Check the USART handle allocation */
;;;300      if(husart == NULL)
;;;301      {
;;;302        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;303      }
;;;304    
;;;305      /* Check the parameters */
;;;306      assert_param(IS_USART_INSTANCE(husart->Instance));
;;;307    
;;;308      husart->State = HAL_USART_STATE_BUSY;
;;;309    
;;;310      /* DeInit the low level hardware */
;;;311      HAL_USART_MspDeInit(husart);
;;;312    
;;;313      husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;314      husart->State = HAL_USART_STATE_RESET;
;;;315    
;;;316      /* Release Lock */
;;;317      __HAL_UNLOCK(husart);
;;;318    
;;;319      return HAL_OK;
;;;320    }
000006  4770              BXEQ     lr
000008  b510              PUSH     {r4,lr}               ;298
00000a  4604              MOV      r4,r0                 ;298
00000c  2002              MOVS     r0,#2                 ;308
00000e  6420              STR      r0,[r4,#0x40]         ;308
000010  4620              MOV      r0,r4                 ;311
000012  f7fffffe          BL       HAL_USART_MspDeInit
000016  2000              MOVS     r0,#0                 ;313
000018  6460              STR      r0,[r4,#0x44]         ;313
00001a  6420              STR      r0,[r4,#0x40]         ;314
00001c  63e0              STR      r0,[r4,#0x3c]         ;317
00001e  bd10              POP      {r4,pc}
;;;321    
                          ENDP


                          AREA ||i.HAL_USART_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_ErrorCallback PROC
;;;1615     */
;;;1616   __weak void HAL_USART_ErrorCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1617   {
;;;1618     /* Prevent unused argument(s) compilation warning */
;;;1619     UNUSED(husart);
;;;1620     /* NOTE: This function should not be modified, when the callback is needed,
;;;1621              the HAL_USART_ErrorCallback could be implemented in the user file
;;;1622      */
;;;1623   }
;;;1624   
                          ENDP


                          AREA ||i.HAL_USART_GetError||, CODE, READONLY, ALIGN=1

                  HAL_USART_GetError PROC
;;;1679     */
;;;1680   uint32_t HAL_USART_GetError(USART_HandleTypeDef *husart)
000000  6c40              LDR      r0,[r0,#0x44]
;;;1681   {
;;;1682     return husart->ErrorCode;
;;;1683   }
000002  4770              BX       lr
;;;1684   
                          ENDP


                          AREA ||i.HAL_USART_GetState||, CODE, READONLY, ALIGN=1

                  HAL_USART_GetState PROC
;;;1668     */
;;;1669   HAL_USART_StateTypeDef HAL_USART_GetState(USART_HandleTypeDef *husart)
000000  6c00              LDR      r0,[r0,#0x40]
;;;1670   {
;;;1671     return husart->State;
;;;1672   }
000002  4770              BX       lr
;;;1673   
                          ENDP


                          AREA ||i.HAL_USART_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_USART_IRQHandler PROC
;;;1396     */
;;;1397   void HAL_USART_IRQHandler(USART_HandleTypeDef *husart)
000000  b570              PUSH     {r4-r6,lr}
;;;1398   {
;;;1399     uint32_t isrflags = READ_REG(husart->Instance->SR);
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0                 ;1398
000006  6810              LDR      r0,[r2,#0]
;;;1400     uint32_t cr1its   = READ_REG(husart->Instance->CR1);
000008  68d1              LDR      r1,[r2,#0xc]
;;;1401     uint32_t cr3its   = READ_REG(husart->Instance->CR3);
00000a  6953              LDR      r3,[r2,#0x14]
;;;1402     uint32_t errorflags = 0x00U;
;;;1403     uint32_t dmarequest = 0x00U;
;;;1404   
;;;1405     /* If no error occurs */
;;;1406     errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
00000c  f0100f0f          TST      r0,#0xf
000010  f04f0501          MOV      r5,#1
000014  d069              BEQ      |L11.234|
;;;1407     if(errorflags == RESET)
;;;1408     {
;;;1409       /* USART in mode Receiver -------------------------------------------------*/
;;;1410       if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
;;;1411       {
;;;1412         if(husart->State == HAL_USART_STATE_BUSY_RX)
;;;1413         {
;;;1414           USART_Receive_IT(husart);
;;;1415         }
;;;1416         else
;;;1417         {
;;;1418           USART_TransmitReceive_IT(husart);
;;;1419         }
;;;1420         return;
;;;1421       }
;;;1422     }
;;;1423     /* If some errors occur */
;;;1424     if((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET) || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
000016  f0030c01          AND      r12,r3,#1
00001a  f4017690          AND      r6,r1,#0x120
00001e  ea5c0c06          ORRS     r12,r12,r6
000022  d07e              BEQ      |L11.290|
;;;1425     {
;;;1426       /* USART parity error interrupt occurred ----------------------------------*/
;;;1427       if(((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
000024  f0100f01          TST      r0,#1
000028  bf18              IT       NE
00002a  f4117f80          TSTNE    r1,#0x100
00002e  d003              BEQ      |L11.56|
;;;1428       {
;;;1429         husart->ErrorCode |= HAL_USART_ERROR_PE;
000030  6c62              LDR      r2,[r4,#0x44]
000032  f0420201          ORR      r2,r2,#1
000036  6462              STR      r2,[r4,#0x44]
                  |L11.56|
;;;1430       }
;;;1431   
;;;1432       /* USART noise error interrupt occurred --------------------------------*/
;;;1433       if(((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
000038  f0100f04          TST      r0,#4
00003c  bf18              IT       NE
00003e  f0130f01          TSTNE    r3,#1
000042  d003              BEQ      |L11.76|
;;;1434       {
;;;1435         husart->ErrorCode |= HAL_USART_ERROR_NE;
000044  6c62              LDR      r2,[r4,#0x44]
000046  f0420202          ORR      r2,r2,#2
00004a  6462              STR      r2,[r4,#0x44]
                  |L11.76|
;;;1436       }
;;;1437   
;;;1438       /* USART frame error interrupt occurred --------------------------------*/
;;;1439       if(((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
00004c  f0100f02          TST      r0,#2
000050  bf18              IT       NE
000052  f0130f01          TSTNE    r3,#1
000056  d003              BEQ      |L11.96|
;;;1440       {
;;;1441         husart->ErrorCode |= HAL_USART_ERROR_FE;
000058  6c62              LDR      r2,[r4,#0x44]
00005a  f0420204          ORR      r2,r2,#4
00005e  6462              STR      r2,[r4,#0x44]
                  |L11.96|
;;;1442       }
;;;1443   
;;;1444       /* USART Over-Run interrupt occurred -----------------------------------*/
;;;1445       if(((isrflags & USART_SR_ORE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
000060  f0100f08          TST      r0,#8
000064  bf18              IT       NE
000066  f0130f01          TSTNE    r3,#1
00006a  d003              BEQ      |L11.116|
;;;1446       {
;;;1447         husart->ErrorCode |= HAL_USART_ERROR_ORE;
00006c  6c62              LDR      r2,[r4,#0x44]
00006e  f0420208          ORR      r2,r2,#8
000072  6462              STR      r2,[r4,#0x44]
                  |L11.116|
;;;1448       }
;;;1449   
;;;1450       if(husart->ErrorCode != HAL_USART_ERROR_NONE)
000074  6c62              LDR      r2,[r4,#0x44]
000076  2a00              CMP      r2,#0
;;;1451       {
;;;1452         /* USART in mode Receiver -----------------------------------------------*/
;;;1453         if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
;;;1454         {
;;;1455           if(husart->State == HAL_USART_STATE_BUSY_RX)
;;;1456           {
;;;1457             USART_Receive_IT(husart);
;;;1458           }
;;;1459           else
;;;1460           {
;;;1461             USART_TransmitReceive_IT(husart);
;;;1462           }
;;;1463         }
;;;1464         /* If Overrun error occurs, or if any error occurs in DMA mode reception,
;;;1465         consider error as blocking */
;;;1466         dmarequest = HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR);
;;;1467         if(((husart->ErrorCode & HAL_USART_ERROR_ORE) != RESET) || dmarequest)
;;;1468         {
;;;1469           /* Set the USART state ready to be able to start again the process,
;;;1470           Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
;;;1471           USART_EndRxTransfer(husart);
;;;1472   
;;;1473           /* Disable the USART DMA Rx request if enabled */
;;;1474           if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
;;;1475           {
;;;1476             CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
;;;1477   
;;;1478             /* Abort the USART DMA Rx channel */
;;;1479             if(husart->hdmarx != NULL)
;;;1480             {
;;;1481               /* Set the USART DMA Abort callback :
;;;1482               will lead to call HAL_USART_ErrorCallback() at end of DMA abort procedure */
;;;1483               husart->hdmarx->XferAbortCallback = USART_DMAAbortOnError;
;;;1484   
;;;1485               if(HAL_DMA_Abort_IT(husart->hdmarx) != HAL_OK)
;;;1486               {
;;;1487                 /* Call Directly XferAbortCallback function in case of error */
;;;1488                 husart->hdmarx->XferAbortCallback(husart->hdmarx);
;;;1489               }
;;;1490             }
;;;1491             else
;;;1492             {
;;;1493               /* Call user error callback */
;;;1494               HAL_USART_ErrorCallback(husart);
;;;1495             }
;;;1496           }
;;;1497           else
;;;1498           {
;;;1499             /* Call user error callback */
;;;1500             HAL_USART_ErrorCallback(husart);
;;;1501           }
;;;1502         }
;;;1503         else
;;;1504         {
;;;1505           /* Call user error callback */
;;;1506           HAL_USART_ErrorCallback(husart);
;;;1507           husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;1508         }
;;;1509       }
;;;1510       return;
;;;1511     }
;;;1512   
;;;1513     /* USART in mode Transmitter -----------------------------------------------*/
;;;1514     if(((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
;;;1515     {
;;;1516       if(husart->State == HAL_USART_STATE_BUSY_TX)
;;;1517       {
;;;1518         USART_Transmit_IT(husart);
;;;1519       }
;;;1520       else
;;;1521       {
;;;1522         USART_TransmitReceive_IT(husart);
;;;1523       }
;;;1524       return;
;;;1525     }
;;;1526   
;;;1527     /* USART in mode Transmitter (transmission end) ----------------------------*/
;;;1528     if(((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
;;;1529     {
;;;1530       USART_EndTransmit_IT(husart);
;;;1531       return;
;;;1532     }
;;;1533   }
000078  bf08              IT       EQ
00007a  bd70              POPEQ    {r4-r6,pc}
00007c  f0100f20          TST      r0,#0x20              ;1453
000080  bf18              IT       NE                    ;1453
000082  f0110f20          TSTNE    r1,#0x20              ;1453
000086  d005              BEQ      |L11.148|
000088  6c20              LDR      r0,[r4,#0x40]         ;1455
00008a  2822              CMP      r0,#0x22              ;1455
00008c  4620              MOV      r0,r4                 ;1461
00008e  d03a              BEQ      |L11.262|
000090  f7fffffe          BL       USART_TransmitReceive_IT
                  |L11.148|
000094  6820              LDR      r0,[r4,#0]            ;1466
000096  6941              LDR      r1,[r0,#0x14]         ;1466
000098  6c62              LDR      r2,[r4,#0x44]         ;1467
00009a  f3c11180          UBFX     r1,r1,#6,#1           ;1466
00009e  f0020208          AND      r2,r2,#8              ;1467
0000a2  4311              ORRS     r1,r1,r2              ;1467
0000a4  d037              BEQ      |L11.278|
0000a6  68c1              LDR      r1,[r0,#0xc]          ;1467
0000a8  f4217190          BIC      r1,r1,#0x120          ;1467
0000ac  60c1              STR      r1,[r0,#0xc]          ;1467
0000ae  6820              LDR      r0,[r4,#0]            ;1467
0000b0  6941              LDR      r1,[r0,#0x14]         ;1467
0000b2  f0210101          BIC      r1,r1,#1              ;1467
0000b6  6141              STR      r1,[r0,#0x14]         ;1467
0000b8  6425              STR      r5,[r4,#0x40]         ;1467
0000ba  6820              LDR      r0,[r4,#0]            ;1474
0000bc  6941              LDR      r1,[r0,#0x14]         ;1474
0000be  f0110f40          TST      r1,#0x40              ;1474
0000c2  d024              BEQ      |L11.270|
0000c4  6941              LDR      r1,[r0,#0x14]         ;1476
0000c6  f0210140          BIC      r1,r1,#0x40           ;1476
0000ca  6141              STR      r1,[r0,#0x14]         ;1476
0000cc  6ba0              LDR      r0,[r4,#0x38]         ;1479
0000ce  b1f0              CBZ      r0,|L11.270|
0000d0  493b              LDR      r1,|L11.448|
0000d2  6381              STR      r1,[r0,#0x38]         ;1485
0000d4  6ba0              LDR      r0,[r4,#0x38]         ;1485
0000d6  f7fffffe          BL       HAL_DMA_Abort_IT
0000da  2800              CMP      r0,#0                 ;1485
0000dc  bf08              IT       EQ
0000de  bd70              POPEQ    {r4-r6,pc}
0000e0  6ba0              LDR      r0,[r4,#0x38]         ;1488
0000e2  6b81              LDR      r1,[r0,#0x38]         ;1488
0000e4  e8bd4070          POP      {r4-r6,lr}            ;1488
0000e8  4708              BX       r1                    ;1488
                  |L11.234|
0000ea  f0100f20          TST      r0,#0x20              ;1410
0000ee  bf18              IT       NE                    ;1410
0000f0  f0110f20          TSTNE    r1,#0x20              ;1410
0000f4  d015              BEQ      |L11.290|
0000f6  6c20              LDR      r0,[r4,#0x40]         ;1412
0000f8  2822              CMP      r0,#0x22              ;1412
0000fa  d11b              BNE      |L11.308|
0000fc  4620              MOV      r0,r4                 ;1414
0000fe  e8bd4070          POP      {r4-r6,lr}            ;1414
000102  f7ffbffe          B.W      USART_Receive_IT
                  |L11.262|
000106  f7fffffe          BL       USART_Receive_IT
00010a  e7c3              B        |L11.148|
00010c  e009              B        |L11.290|
                  |L11.270|
00010e  4620              MOV      r0,r4                 ;1500
000110  f7fffffe          BL       HAL_USART_ErrorCallback
000114  bd70              POP      {r4-r6,pc}
                  |L11.278|
000116  4620              MOV      r0,r4                 ;1506
000118  f7fffffe          BL       HAL_USART_ErrorCallback
00011c  2000              MOVS     r0,#0                 ;1507
00011e  6460              STR      r0,[r4,#0x44]         ;1507
000120  bd70              POP      {r4-r6,pc}
                  |L11.290|
000122  f0100f80          TST      r0,#0x80              ;1514
000126  bf18              IT       NE                    ;1514
000128  f0110f80          TSTNE    r1,#0x80              ;1514
00012c  d033              BEQ      |L11.406|
00012e  6c20              LDR      r0,[r4,#0x40]         ;1516
000130  2812              CMP      r0,#0x12              ;1516
000132  d004              BEQ      |L11.318|
                  |L11.308|
000134  4620              MOV      r0,r4                 ;1522
000136  e8bd4070          POP      {r4-r6,lr}            ;1522
00013a  f7ffbffe          B.W      USART_TransmitReceive_IT
                  |L11.318|
00013e  6c20              LDR      r0,[r4,#0x40]         ;1522
000140  2812              CMP      r0,#0x12              ;1522
000142  bf18              IT       NE
000144  bd70              POPNE    {r4-r6,pc}
000146  68a0              LDR      r0,[r4,#8]
000148  f5b05f80          CMP      r0,#0x1000
00014c  6a60              LDR      r0,[r4,#0x24]
00014e  d016              BEQ      |L11.382|
000150  1c41              ADDS     r1,r0,#1
000152  6261              STR      r1,[r4,#0x24]
000154  6821              LDR      r1,[r4,#0]
000156  7800              LDRB     r0,[r0,#0]
000158  6048              STR      r0,[r1,#4]
                  |L11.346|
00015a  8d60              LDRH     r0,[r4,#0x2a]
00015c  1e40              SUBS     r0,r0,#1
00015e  0400              LSLS     r0,r0,#16
000160  0c00              LSRS     r0,r0,#16
000162  8560              STRH     r0,[r4,#0x2a]
000164  bf18              IT       NE
000166  bd70              POPNE    {r4-r6,pc}
000168  6820              LDR      r0,[r4,#0]
00016a  68c1              LDR      r1,[r0,#0xc]
00016c  f0210180          BIC      r1,r1,#0x80
000170  60c1              STR      r1,[r0,#0xc]
000172  6820              LDR      r0,[r4,#0]
000174  68c1              LDR      r1,[r0,#0xc]
000176  f0410140          ORR      r1,r1,#0x40
00017a  60c1              STR      r1,[r0,#0xc]
00017c  bd70              POP      {r4-r6,pc}
                  |L11.382|
00017e  8800              LDRH     r0,[r0,#0]
000180  f3c00008          UBFX     r0,r0,#0,#9
000184  6050              STR      r0,[r2,#4]
000186  6920              LDR      r0,[r4,#0x10]
000188  2800              CMP      r0,#0
00018a  6a60              LDR      r0,[r4,#0x24]
00018c  bf14              ITE      NE
00018e  1c40              ADDNE    r0,r0,#1
000190  1c80              ADDEQ    r0,r0,#2
000192  6260              STR      r0,[r4,#0x24]
000194  e7e1              B        |L11.346|
                  |L11.406|
000196  f0100f40          TST      r0,#0x40              ;1528
00019a  bf14              ITE      NE                    ;1528
00019c  f0110f40          TSTNE    r1,#0x40              ;1528
0001a0  bd70              POPEQ    {r4-r6,pc}
0001a2  4620              MOV      r0,r4                 ;1530
0001a4  68d1              LDR      r1,[r2,#0xc]          ;1530
0001a6  f0210140          BIC      r1,r1,#0x40           ;1530
0001aa  60d1              STR      r1,[r2,#0xc]          ;1530
0001ac  6821              LDR      r1,[r4,#0]            ;1530
0001ae  694a              LDR      r2,[r1,#0x14]         ;1530
0001b0  f0220201          BIC      r2,r2,#1              ;1530
0001b4  614a              STR      r2,[r1,#0x14]         ;1530
0001b6  6425              STR      r5,[r4,#0x40]         ;1530
0001b8  f7fffffe          BL       HAL_USART_TxCpltCallback
0001bc  bd70              POP      {r4-r6,pc}
;;;1534   
                          ENDP

0001be  0000              DCW      0x0000
                  |L11.448|
                          DCD      USART_DMAAbortOnError

                          AREA ||i.HAL_USART_Init||, CODE, READONLY, ALIGN=2

                  HAL_USART_Init PROC
;;;249      */
;;;250    HAL_StatusTypeDef HAL_USART_Init(USART_HandleTypeDef *husart)
000000  2800              CMP      r0,#0
;;;251    {
;;;252      /* Check the USART handle allocation */
;;;253      if(husart == NULL)
;;;254      {
;;;255        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;256      }
;;;257    
;;;258      /* Check the parameters */
;;;259      assert_param(IS_USART_INSTANCE(husart->Instance));
;;;260    
;;;261      if(husart->State == HAL_USART_STATE_RESET)
;;;262      {
;;;263        /* Allocate lock resource and initialize it */
;;;264        husart->Lock = HAL_UNLOCKED;
;;;265    
;;;266        /* Init the low level hardware */
;;;267        HAL_USART_MspInit(husart);
;;;268      }
;;;269      
;;;270      husart->State = HAL_USART_STATE_BUSY;
;;;271    
;;;272      /* Set the USART Communication parameters */
;;;273      USART_SetConfig(husart);
;;;274    
;;;275      /* In USART mode, the following bits must be kept cleared:
;;;276         - LINEN bit in the USART_CR2 register
;;;277         - HDSEL, SCEN and IREN bits in the USART_CR3 register */
;;;278      CLEAR_BIT(husart->Instance->CR2, USART_CR2_LINEN);
;;;279      CLEAR_BIT(husart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;280    
;;;281      /* Enable the Peripheral */
;;;282      __HAL_USART_ENABLE(husart);
;;;283    
;;;284      /* Initialize the USART state */
;;;285      husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;286      husart->State= HAL_USART_STATE_READY;
;;;287    
;;;288      return HAL_OK;
;;;289    }
000006  4770              BXEQ     lr
000008  e92d47f0          PUSH     {r4-r10,lr}           ;251
00000c  4604              MOV      r4,r0                 ;251
00000e  6c00              LDR      r0,[r0,#0x40]         ;261
000010  2600              MOVS     r6,#0                 ;261
000012  b918              CBNZ     r0,|L12.28|
000014  4620              MOV      r0,r4                 ;267
000016  63e6              STR      r6,[r4,#0x3c]         ;267
000018  f7fffffe          BL       HAL_USART_MspInit
                  |L12.28|
00001c  2002              MOVS     r0,#2                 ;270
00001e  6420              STR      r0,[r4,#0x40]         ;270
000020  6820              LDR      r0,[r4,#0]            ;270
000022  68c1              LDR      r1,[r0,#0xc]          ;270
000024  f021010c          BIC      r1,r1,#0xc            ;270
000028  60c1              STR      r1,[r0,#0xc]          ;270
00002a  e9d40106          LDRD     r0,r1,[r4,#0x18]      ;270
00002e  4308              ORRS     r0,r0,r1              ;270
000030  68e2              LDR      r2,[r4,#0xc]          ;270
000032  6a21              LDR      r1,[r4,#0x20]         ;270
000034  4311              ORRS     r1,r1,r2              ;270
000036  4301              ORRS     r1,r1,r0              ;270
000038  6820              LDR      r0,[r4,#0]            ;270
00003a  6902              LDR      r2,[r0,#0x10]         ;270
00003c  f422527c          BIC      r2,r2,#0x3f00         ;270
000040  4311              ORRS     r1,r1,r2              ;270
000042  f4416100          ORR      r1,r1,#0x800          ;270
000046  6101              STR      r1,[r0,#0x10]         ;270
000048  6921              LDR      r1,[r4,#0x10]         ;270
00004a  68a0              LDR      r0,[r4,#8]            ;270
00004c  6962              LDR      r2,[r4,#0x14]         ;270
00004e  4301              ORRS     r1,r1,r0              ;270
000050  6820              LDR      r0,[r4,#0]            ;270
000052  68c3              LDR      r3,[r0,#0xc]          ;270
000054  f4237303          BIC      r3,r3,#0x20c          ;270
000058  f42353a0          BIC      r3,r3,#0x1400         ;270
00005c  431a              ORRS     r2,r2,r3              ;270
00005e  4311              ORRS     r1,r1,r2              ;270
000060  60c1              STR      r1,[r0,#0xc]          ;270
000062  6820              LDR      r0,[r4,#0]            ;270
000064  6941              LDR      r1,[r0,#0x14]         ;270
000066  f4217140          BIC      r1,r1,#0x300          ;270
00006a  6141              STR      r1,[r0,#0x14]         ;270
00006c  6820              LDR      r0,[r4,#0]            ;270
00006e  4d41              LDR      r5,|L12.372|
000070  2732              MOVS     r7,#0x32              ;270
000072  f1a04180          SUB      r1,r0,#0x40000000     ;270
000076  f5b1319c          SUBS     r1,r1,#0x13800        ;270
00007a  d047              BEQ      |L12.268|
00007c  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000080  eb0001c0          ADD      r1,r0,r0,LSL #3       ;270
000084  eb011000          ADD      r0,r1,r0,LSL #4       ;270
000088  6861              LDR      r1,[r4,#4]            ;270
00008a  0049              LSLS     r1,r1,#1              ;270
00008c  fbb0f0f1          UDIV     r0,r0,r1              ;270
000090  fba51000          UMULL    r1,r0,r5,r0           ;270
000094  ea4f1850          LSR      r8,r0,#5              ;270
000098  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
00009c  eb0001c0          ADD      r1,r0,r0,LSL #3       ;270
0000a0  eb011000          ADD      r0,r1,r0,LSL #4       ;270
0000a4  6861              LDR      r1,[r4,#4]            ;270
0000a6  0049              LSLS     r1,r1,#1              ;270
0000a8  fbb0f9f1          UDIV     r9,r0,r1              ;270
0000ac  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0000b0  eb0001c0          ADD      r1,r0,r0,LSL #3       ;270
0000b4  eb011000          ADD      r0,r1,r0,LSL #4       ;270
0000b8  6861              LDR      r1,[r4,#4]            ;270
0000ba  0049              LSLS     r1,r1,#1              ;270
0000bc  fbb0f0f1          UDIV     r0,r0,r1              ;270
0000c0  fba51000          UMULL    r1,r0,r5,r0           ;270
0000c4  0940              LSRS     r0,r0,#5              ;270
0000c6  f06f0118          MVN      r1,#0x18              ;270
0000ca  4348              MULS     r0,r1,r0              ;270
0000cc  eb090080          ADD      r0,r9,r0,LSL #2       ;270
0000d0  eb071000          ADD      r0,r7,r0,LSL #4       ;270
0000d4  fba51000          UMULL    r1,r0,r5,r0           ;270
0000d8  6821              LDR      r1,[r4,#0]            ;270
0000da  0940              LSRS     r0,r0,#5              ;270
0000dc  f368101f          BFI      r0,r8,#4,#28          ;270
0000e0  6088              STR      r0,[r1,#8]            ;270
                  |L12.226|
0000e2  6820              LDR      r0,[r4,#0]            ;278
0000e4  6901              LDR      r1,[r0,#0x10]         ;278
0000e6  f4214180          BIC      r1,r1,#0x4000         ;278
0000ea  6101              STR      r1,[r0,#0x10]         ;278
0000ec  6820              LDR      r0,[r4,#0]            ;279
0000ee  6941              LDR      r1,[r0,#0x14]         ;279
0000f0  f021012a          BIC      r1,r1,#0x2a           ;279
0000f4  6141              STR      r1,[r0,#0x14]         ;279
0000f6  6820              LDR      r0,[r4,#0]            ;282
0000f8  68c1              LDR      r1,[r0,#0xc]          ;282
0000fa  f4415100          ORR      r1,r1,#0x2000         ;282
0000fe  60c1              STR      r1,[r0,#0xc]          ;282
000100  6466              STR      r6,[r4,#0x44]         ;285
000102  2001              MOVS     r0,#1                 ;286
000104  6420              STR      r0,[r4,#0x40]         ;286
000106  2000              MOVS     r0,#0                 ;288
000108  e8bd87f0          POP      {r4-r10,pc}
                  |L12.268|
00010c  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000110  eb0001c0          ADD      r1,r0,r0,LSL #3
000114  eb011000          ADD      r0,r1,r0,LSL #4
000118  6861              LDR      r1,[r4,#4]
00011a  0049              LSLS     r1,r1,#1
00011c  fbb0f0f1          UDIV     r0,r0,r1
000120  fba51000          UMULL    r1,r0,r5,r0
000124  ea4f1850          LSR      r8,r0,#5
000128  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00012c  eb0001c0          ADD      r1,r0,r0,LSL #3
000130  eb011000          ADD      r0,r1,r0,LSL #4
000134  6861              LDR      r1,[r4,#4]
000136  0049              LSLS     r1,r1,#1
000138  fbb0f9f1          UDIV     r9,r0,r1
00013c  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000140  eb0001c0          ADD      r1,r0,r0,LSL #3
000144  eb011000          ADD      r0,r1,r0,LSL #4
000148  6861              LDR      r1,[r4,#4]
00014a  0049              LSLS     r1,r1,#1
00014c  fbb0f0f1          UDIV     r0,r0,r1
000150  fba51000          UMULL    r1,r0,r5,r0
000154  0940              LSRS     r0,r0,#5
000156  f06f0118          MVN      r1,#0x18
00015a  4348              MULS     r0,r1,r0
00015c  eb090080          ADD      r0,r9,r0,LSL #2
000160  eb071000          ADD      r0,r7,r0,LSL #4
000164  fba51000          UMULL    r1,r0,r5,r0
000168  6821              LDR      r1,[r4,#0]
00016a  0940              LSRS     r0,r0,#5
00016c  f368101f          BFI      r0,r8,#4,#28
000170  6088              STR      r0,[r1,#8]
000172  e7b6              B        |L12.226|
;;;290    
                          ENDP

                  |L12.372|
                          DCD      0x51eb851f

                          AREA ||i.HAL_USART_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_USART_MspDeInit PROC
;;;342      */
;;;343    __weak void HAL_USART_MspDeInit(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;344    {
;;;345      /* Prevent unused argument(s) compilation warning */
;;;346      UNUSED(husart);
;;;347      /* NOTE: This function should not be modified, when the callback is needed,
;;;348               the HAL_USART_MspDeInit could be implemented in the user file
;;;349       */
;;;350    }
;;;351    
                          ENDP


                          AREA ||i.HAL_USART_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_USART_MspInit PROC
;;;327      */
;;;328    __weak void HAL_USART_MspInit(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;329    {
;;;330      /* Prevent unused argument(s) compilation warning */
;;;331      UNUSED(husart);
;;;332      /* NOTE: This function should not be modified, when the callback is needed,
;;;333               the HAL_USART_MspInit could be implemented in the user file
;;;334       */
;;;335    }
;;;336    
                          ENDP


                          AREA ||i.HAL_USART_Receive||, CODE, READONLY, ALIGN=1

                  HAL_USART_Receive PROC
;;;506      */
;;;507    HAL_StatusTypeDef HAL_USART_Receive(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;508    {
000004  4604              MOV      r4,r0
;;;509      uint16_t* tmp;
;;;510      uint32_t tickstart = 0U;
;;;511    
;;;512      if(husart->State == HAL_USART_STATE_READY)
000006  6c00              LDR      r0,[r0,#0x40]
000008  461e              MOV      r6,r3                 ;508
00000a  4691              MOV      r9,r2                 ;508
00000c  460d              MOV      r5,r1                 ;508
00000e  2801              CMP      r0,#1
000010  d16e              BNE      |L15.240|
;;;513      {
;;;514        if((pRxData == NULL) || (Size == 0U))
000012  2d00              CMP      r5,#0
000014  bf12              ITEE     NE
000016  f1b90f00          CMPNE    r9,#0
;;;515        {
;;;516          return  HAL_ERROR;
00001a  2001              MOVEQ    r0,#1
;;;517        }
;;;518        /* Process Locked */
;;;519        __HAL_LOCK(husart);
;;;520    
;;;521        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;522        husart->State = HAL_USART_STATE_BUSY_RX;
;;;523    
;;;524        /* Init tickstart for timeout managment */
;;;525        tickstart = HAL_GetTick();
;;;526    
;;;527        husart->RxXferSize = Size;
;;;528        husart->RxXferCount = Size;
;;;529        /* Check the remain data to be received */
;;;530        while(husart->RxXferCount > 0U)
;;;531        {
;;;532          husart->RxXferCount--;
;;;533          if(husart->Init.WordLength == USART_WORDLENGTH_9B)
;;;534          {
;;;535            /* Wait until TXE flag is set to send dummy byte in order to generate the clock for the slave to send data */
;;;536            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;537            {
;;;538              return HAL_TIMEOUT;
;;;539            }
;;;540            /* Send dummy byte in order to generate clock */
;;;541            WRITE_REG(husart->Instance->DR, (DUMMY_DATA & (uint16_t)0x01FF));
;;;542    
;;;543            /* Wait for RXNE Flag */
;;;544            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;545            {
;;;546              return HAL_TIMEOUT;
;;;547            }
;;;548            tmp = (uint16_t*) pRxData ;
;;;549            if(husart->Init.Parity == USART_PARITY_NONE)
;;;550            {
;;;551              *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x01FF);
;;;552              pRxData +=2U;
;;;553            }
;;;554            else
;;;555            {
;;;556              *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x00FF);
;;;557              pRxData +=1U;
;;;558            }
;;;559          }
;;;560          else
;;;561          {
;;;562            /* Wait until TXE flag is set to send dummy byte in order to generate the clock for the slave to send data */
;;;563            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;564            {
;;;565              return HAL_TIMEOUT;
;;;566            }
;;;567    
;;;568            /* Send Dummy Byte in order to generate clock */
;;;569            WRITE_REG(husart->Instance->DR, (DUMMY_DATA & (uint16_t)0x00FF));
;;;570    
;;;571            /* Wait until RXNE flag is set to receive the byte */
;;;572            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;573            {
;;;574              return HAL_TIMEOUT;
;;;575            }
;;;576            if(husart->Init.Parity == USART_PARITY_NONE)
;;;577            {
;;;578              /* Receive data */
;;;579              *pRxData++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x00FF);
;;;580            }
;;;581            else
;;;582            {
;;;583              /* Receive data */
;;;584              *pRxData++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x007F);
;;;585            }
;;;586            
;;;587          }
;;;588        }
;;;589    
;;;590        husart->State = HAL_USART_STATE_READY;
;;;591    
;;;592        /* Process Unlocked */
;;;593        __HAL_UNLOCK(husart);
;;;594    
;;;595        return HAL_OK;
;;;596      }
;;;597      else
;;;598      {
;;;599        return HAL_BUSY;
;;;600      }
;;;601    }
00001c  e8bd8ff8          POPEQ    {r3-r11,pc}
000020  6be0              LDR      r0,[r4,#0x3c]         ;519
000022  2801              CMP      r0,#1                 ;519
000024  d064              BEQ      |L15.240|
000026  f04f0800          MOV      r8,#0                 ;521
00002a  2701              MOVS     r7,#1                 ;519
00002c  f8c48044          STR      r8,[r4,#0x44]         ;521
000030  63e7              STR      r7,[r4,#0x3c]         ;521
000032  2022              MOVS     r0,#0x22              ;522
000034  6420              STR      r0,[r4,#0x40]         ;522
000036  f7fffffe          BL       HAL_GetTick
00003a  f8a49030          STRH     r9,[r4,#0x30]         ;527
00003e  4683              MOV      r11,r0                ;525
000040  f8a49032          STRH     r9,[r4,#0x32]         ;528
000044  8e60              LDRH     r0,[r4,#0x32]         ;530
000046  2800              CMP      r0,#0                 ;530
000048  bf1c              ITT      NE                    ;541
00004a  f24019ff          MOVNE    r9,#0x1ff             ;541
00004e  f04f0aff          MOVNE    r10,#0xff             ;569
000052  d02f              BEQ      |L15.180|
                  |L15.84|
000054  8e60              LDRH     r0,[r4,#0x32]         ;532
000056  1e40              SUBS     r0,r0,#1              ;532
000058  8660              STRH     r0,[r4,#0x32]         ;532
00005a  68a0              LDR      r0,[r4,#8]            ;533
00005c  465b              MOV      r3,r11                ;563
00005e  f5b05f80          CMP      r0,#0x1000            ;533
000062  f04f0200          MOV      r2,#0                 ;563
000066  f04f0180          MOV      r1,#0x80              ;563
00006a  4620              MOV      r0,r4                 ;563
00006c  9600              STR      r6,[sp,#0]            ;533
00006e  d003              BEQ      |L15.120|
000070  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000074  b320              CBZ      r0,|L15.192|
000076  e02e              B        |L15.214|
                  |L15.120|
000078  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
00007c  bb58              CBNZ     r0,|L15.214|
00007e  6820              LDR      r0,[r4,#0]            ;541
000080  f8c09004          STR      r9,[r0,#4]            ;541
000084  465b              MOV      r3,r11                ;544
000086  2200              MOVS     r2,#0                 ;544
000088  2120              MOVS     r1,#0x20              ;544
00008a  4620              MOV      r0,r4                 ;544
00008c  9600              STR      r6,[sp,#0]            ;544
00008e  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000092  bb00              CBNZ     r0,|L15.214|
000094  6920              LDR      r0,[r4,#0x10]         ;549
000096  2800              CMP      r0,#0                 ;549
000098  6820              LDR      r0,[r4,#0]            ;556
00009a  6840              LDR      r0,[r0,#4]            ;556
00009c  bf14              ITE      NE                    ;556
00009e  b2c1              UXTBNE   r1,r0                 ;556
0000a0  f3c00108          UBFXEQ   r1,r0,#0,#9           ;551
0000a4  4628              MOV      r0,r5                 ;551
0000a6  8029              STRH     r1,[r5,#0]            ;551
0000a8  bf14              ITE      NE                    ;557
0000aa  1c45              ADDNE    r5,r0,#1              ;557
0000ac  1c85              ADDEQ    r5,r0,#2              ;552
                  |L15.174|
0000ae  8e60              LDRH     r0,[r4,#0x32]         ;584
0000b0  2800              CMP      r0,#0                 ;584
0000b2  d1cf              BNE      |L15.84|
                  |L15.180|
0000b4  6427              STR      r7,[r4,#0x40]         ;590
0000b6  2000              MOVS     r0,#0                 ;595
0000b8  f8c4803c          STR      r8,[r4,#0x3c]         ;595
0000bc  e8bd8ff8          POP      {r3-r11,pc}
                  |L15.192|
0000c0  6820              LDR      r0,[r4,#0]            ;569
0000c2  f8c0a004          STR      r10,[r0,#4]           ;569
0000c6  465b              MOV      r3,r11                ;572
0000c8  2200              MOVS     r2,#0                 ;572
0000ca  2120              MOVS     r1,#0x20              ;572
0000cc  4620              MOV      r0,r4                 ;572
0000ce  9600              STR      r6,[sp,#0]            ;572
0000d0  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
0000d4  b110              CBZ      r0,|L15.220|
                  |L15.214|
0000d6  2003              MOVS     r0,#3                 ;574
0000d8  e8bd8ff8          POP      {r3-r11,pc}
                  |L15.220|
0000dc  6920              LDR      r0,[r4,#0x10]         ;576
0000de  2800              CMP      r0,#0                 ;576
0000e0  6820              LDR      r0,[r4,#0]            ;584
0000e2  6840              LDR      r0,[r0,#4]            ;584
0000e4  bf18              IT       NE                    ;584
0000e6  f000007f          ANDNE    r0,r0,#0x7f           ;584
0000ea  f8050b01          STRB     r0,[r5],#1            ;579
0000ee  e7de              B        |L15.174|
                  |L15.240|
0000f0  2002              MOVS     r0,#2                 ;599
0000f2  e8bd8ff8          POP      {r3-r11,pc}
;;;602    
                          ENDP


                          AREA ||i.HAL_USART_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_USART_Receive_DMA PROC
;;;941      */
;;;942    HAL_StatusTypeDef HAL_USART_Receive_DMA(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;943    {
000002  4604              MOV      r4,r0
;;;944      uint32_t *tmp;
;;;945    
;;;946      if(husart->State == HAL_USART_STATE_READY)
000004  6c00              LDR      r0,[r0,#0x40]
000006  4616              MOV      r6,r2                 ;943
000008  460f              MOV      r7,r1                 ;943
00000a  2801              CMP      r0,#1
00000c  d14c              BNE      |L16.168|
;;;947      {
;;;948        if((pRxData == NULL) || (Size == 0U))
00000e  2900              CMP      r1,#0
000010  bf12              ITEE     NE
000012  2e00              CMPNE    r6,#0
;;;949        {
;;;950          return HAL_ERROR;
000014  2001              MOVEQ    r0,#1
;;;951        }
;;;952    
;;;953        /* Process Locked */
;;;954        __HAL_LOCK(husart);
;;;955    
;;;956        husart->pRxBuffPtr = pRxData;
;;;957        husart->RxXferSize = Size;
;;;958        husart->pTxBuffPtr = pRxData;
;;;959        husart->TxXferSize = Size;
;;;960    
;;;961        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;962        husart->State = HAL_USART_STATE_BUSY_RX;
;;;963    
;;;964        /* Set the USART DMA Rx transfer complete callback */
;;;965        husart->hdmarx->XferCpltCallback = USART_DMAReceiveCplt;
;;;966    
;;;967        /* Set the USART DMA Half transfer complete callback */
;;;968        husart->hdmarx->XferHalfCpltCallback = USART_DMARxHalfCplt;
;;;969    
;;;970        /* Set the USART DMA Rx transfer error callback */
;;;971        husart->hdmarx->XferErrorCallback = USART_DMAError;
;;;972    
;;;973        /* Set the DMA abort callback */
;;;974        husart->hdmarx->XferAbortCallback = NULL;
;;;975    
;;;976        /* Set the USART Tx DMA transfer complete callback as NULL because the communication closing
;;;977        is performed in DMA reception complete callback  */
;;;978        husart->hdmatx->XferHalfCpltCallback = NULL;
;;;979        husart->hdmatx->XferCpltCallback = NULL;
;;;980    
;;;981        /* Set the DMA error callback */
;;;982        husart->hdmatx->XferErrorCallback = USART_DMAError;
;;;983    
;;;984        /* Set the DMA AbortCpltCallback */
;;;985        husart->hdmatx->XferAbortCallback = NULL;
;;;986    
;;;987        /* Enable the USART receive DMA channel */
;;;988        tmp = (uint32_t*)&pRxData;
;;;989        HAL_DMA_Start_IT(husart->hdmarx, (uint32_t)&husart->Instance->DR, *(uint32_t*)tmp, Size);
;;;990    
;;;991        /* Enable the USART transmit DMA channel: the transmit channel is used in order
;;;992           to generate in the non-blocking mode the clock to the slave device,
;;;993           this mode isn't a simplex receive mode but a full-duplex receive one */
;;;994        HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t*)tmp, (uint32_t)&husart->Instance->DR, Size);
;;;995    
;;;996        /* Clear the Overrun flag just before enabling the DMA Rx request: mandatory for the second transfer */
;;;997        __HAL_USART_CLEAR_OREFLAG(husart);
;;;998    
;;;999        /* Process Unlocked */
;;;1000       __HAL_UNLOCK(husart);
;;;1001   
;;;1002       /* Enable the USART Parity Error Interrupt */
;;;1003       SET_BIT(husart->Instance->CR1, USART_CR1_PEIE);
;;;1004   
;;;1005       /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1006       SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;1007   
;;;1008       /* Enable the DMA transfer for the receiver request by setting the DMAR bit
;;;1009          in the USART CR3 register */
;;;1010       SET_BIT(husart->Instance->CR3, USART_CR3_DMAR);
;;;1011   
;;;1012       /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;1013          in the USART CR3 register */
;;;1014       SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1015   
;;;1016       return HAL_OK;
;;;1017     }
;;;1018     else
;;;1019     {
;;;1020       return HAL_BUSY;
;;;1021     }
;;;1022   }
000016  bdf8              POPEQ    {r3-r7,pc}
000018  6be0              LDR      r0,[r4,#0x3c]         ;954
00001a  2801              CMP      r0,#1                 ;954
00001c  d044              BEQ      |L16.168|
00001e  2001              MOVS     r0,#1                 ;954
000020  62e1              STR      r1,[r4,#0x2c]         ;957
000022  63e0              STR      r0,[r4,#0x3c]         ;957
000024  8626              STRH     r6,[r4,#0x30]         ;957
000026  6261              STR      r1,[r4,#0x24]         ;959
000028  8526              STRH     r6,[r4,#0x28]         ;959
00002a  2500              MOVS     r5,#0                 ;961
00002c  6465              STR      r5,[r4,#0x44]         ;961
00002e  2022              MOVS     r0,#0x22              ;962
000030  6420              STR      r0,[r4,#0x40]         ;962
000032  6ba2              LDR      r2,[r4,#0x38]         ;965
000034  481d              LDR      r0,|L16.172|
000036  4633              MOV      r3,r6                 ;989
000038  62d0              STR      r0,[r2,#0x2c]         ;968
00003a  6ba2              LDR      r2,[r4,#0x38]         ;968
00003c  481c              LDR      r0,|L16.176|
00003e  6310              STR      r0,[r2,#0x30]         ;971
000040  6ba2              LDR      r2,[r4,#0x38]         ;971
000042  481c              LDR      r0,|L16.180|
000044  6350              STR      r0,[r2,#0x34]         ;974
000046  6ba2              LDR      r2,[r4,#0x38]         ;974
000048  6395              STR      r5,[r2,#0x38]         ;978
00004a  6b62              LDR      r2,[r4,#0x34]         ;978
00004c  6315              STR      r5,[r2,#0x30]         ;979
00004e  6b62              LDR      r2,[r4,#0x34]         ;979
000050  62d5              STR      r5,[r2,#0x2c]         ;982
000052  6b62              LDR      r2,[r4,#0x34]         ;982
000054  6350              STR      r0,[r2,#0x34]         ;985
000056  6b60              LDR      r0,[r4,#0x34]         ;985
000058  460a              MOV      r2,r1                 ;985
00005a  6385              STR      r5,[r0,#0x38]         ;989
00005c  6820              LDR      r0,[r4,#0]            ;989
00005e  1d01              ADDS     r1,r0,#4              ;989
000060  6ba0              LDR      r0,[r4,#0x38]         ;989
000062  f7fffffe          BL       HAL_DMA_Start_IT
000066  6820              LDR      r0,[r4,#0]            ;994
000068  4639              MOV      r1,r7                 ;994
00006a  1d02              ADDS     r2,r0,#4              ;994
00006c  4633              MOV      r3,r6                 ;994
00006e  6b60              LDR      r0,[r4,#0x34]         ;994
000070  f7fffffe          BL       HAL_DMA_Start_IT
000074  6820              LDR      r0,[r4,#0]            ;997
000076  6801              LDR      r1,[r0,#0]            ;997
000078  6841              LDR      r1,[r0,#4]            ;997
00007a  9100              STR      r1,[sp,#0]            ;1000
00007c  63e5              STR      r5,[r4,#0x3c]         ;1003
00007e  68c1              LDR      r1,[r0,#0xc]          ;1003
000080  f4417180          ORR      r1,r1,#0x100          ;1003
000084  60c1              STR      r1,[r0,#0xc]          ;1003
000086  6820              LDR      r0,[r4,#0]            ;1006
000088  6941              LDR      r1,[r0,#0x14]         ;1006
00008a  f0410101          ORR      r1,r1,#1              ;1006
00008e  6141              STR      r1,[r0,#0x14]         ;1006
000090  6820              LDR      r0,[r4,#0]            ;1010
000092  6941              LDR      r1,[r0,#0x14]         ;1010
000094  f0410140          ORR      r1,r1,#0x40           ;1010
000098  6141              STR      r1,[r0,#0x14]         ;1010
00009a  6820              LDR      r0,[r4,#0]            ;1014
00009c  6941              LDR      r1,[r0,#0x14]         ;1014
00009e  f0410180          ORR      r1,r1,#0x80           ;1014
0000a2  6141              STR      r1,[r0,#0x14]         ;1014
0000a4  2000              MOVS     r0,#0                 ;1016
0000a6  bdf8              POP      {r3-r7,pc}
                  |L16.168|
0000a8  2002              MOVS     r0,#2                 ;1020
0000aa  bdf8              POP      {r3-r7,pc}
;;;1023   
                          ENDP

                  |L16.172|
                          DCD      USART_DMAReceiveCplt
                  |L16.176|
                          DCD      USART_DMARxHalfCplt
                  |L16.180|
                          DCD      USART_DMAError

                          AREA ||i.HAL_USART_Receive_IT||, CODE, READONLY, ALIGN=1

                  HAL_USART_Receive_IT PROC
;;;775      */
;;;776    HAL_StatusTypeDef HAL_USART_Receive_IT(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size)
000000  6c03              LDR      r3,[r0,#0x40]
;;;777    {
;;;778      if(husart->State == HAL_USART_STATE_READY)
000002  2b01              CMP      r3,#1
000004  d124              BNE      |L17.80|
;;;779      {
;;;780        if((pRxData == NULL) || (Size == 0U))
000006  2900              CMP      r1,#0
000008  bf12              ITEE     NE
00000a  2a00              CMPNE    r2,#0
;;;781        {
;;;782          return HAL_ERROR;
00000c  2001              MOVEQ    r0,#1
;;;783        }
;;;784        /* Process Locked */
;;;785        __HAL_LOCK(husart);
;;;786    
;;;787        husart->pRxBuffPtr = pRxData;
;;;788        husart->RxXferSize = Size;
;;;789        husart->RxXferCount = Size;
;;;790    
;;;791        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;792        husart->State = HAL_USART_STATE_BUSY_RX;
;;;793    
;;;794        /* Process Unlocked */
;;;795        __HAL_UNLOCK(husart);
;;;796    
;;;797        /* Enable the USART Data Register not empty Interrupt */
;;;798        __HAL_USART_ENABLE_IT(husart, USART_IT_RXNE); 
;;;799    
;;;800        /* Enable the USART Parity Error Interrupt */
;;;801        __HAL_USART_ENABLE_IT(husart, USART_IT_PE);
;;;802    
;;;803        /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;804        __HAL_USART_ENABLE_IT(husart, USART_IT_ERR);
;;;805    
;;;806        /* Send dummy byte in order to generate the clock for the slave to send data */
;;;807        WRITE_REG(husart->Instance->DR, (DUMMY_DATA & (uint16_t)0x01FF));    
;;;808    
;;;809        return HAL_OK;
;;;810      }
;;;811      else
;;;812      {
;;;813        return HAL_BUSY;
;;;814      }
;;;815    }
00000e  4770              BXEQ     lr
000010  6bc3              LDR      r3,[r0,#0x3c]         ;785
000012  2b01              CMP      r3,#1                 ;785
000014  d01c              BEQ      |L17.80|
000016  62c1              STR      r1,[r0,#0x2c]         ;788
000018  8602              STRH     r2,[r0,#0x30]         ;788
00001a  8642              STRH     r2,[r0,#0x32]         ;789
00001c  2100              MOVS     r1,#0                 ;791
00001e  6441              STR      r1,[r0,#0x44]         ;791
000020  2222              MOVS     r2,#0x22              ;792
000022  6402              STR      r2,[r0,#0x40]         ;792
000024  63c1              STR      r1,[r0,#0x3c]         ;798
000026  6801              LDR      r1,[r0,#0]            ;798
000028  68ca              LDR      r2,[r1,#0xc]          ;798
00002a  f0420220          ORR      r2,r2,#0x20           ;798
00002e  60ca              STR      r2,[r1,#0xc]          ;798
000030  6801              LDR      r1,[r0,#0]            ;801
000032  68ca              LDR      r2,[r1,#0xc]          ;801
000034  f4427280          ORR      r2,r2,#0x100          ;801
000038  60ca              STR      r2,[r1,#0xc]          ;801
00003a  6801              LDR      r1,[r0,#0]            ;804
00003c  694a              LDR      r2,[r1,#0x14]         ;804
00003e  f0420201          ORR      r2,r2,#1              ;804
000042  614a              STR      r2,[r1,#0x14]         ;804
000044  6800              LDR      r0,[r0,#0]            ;807
000046  f24011ff          MOV      r1,#0x1ff             ;807
00004a  6041              STR      r1,[r0,#4]            ;807
00004c  2000              MOVS     r0,#0                 ;809
00004e  4770              BX       lr
                  |L17.80|
000050  2002              MOVS     r0,#2                 ;813
000052  4770              BX       lr
;;;816    
                          ENDP


                          AREA ||i.HAL_USART_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_RxCpltCallback PROC
;;;1570     */
;;;1571   __weak void HAL_USART_RxCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1572   {
;;;1573     /* Prevent unused argument(s) compilation warning */
;;;1574     UNUSED(husart);
;;;1575     /* NOTE: This function should not be modified, when the callback is needed,
;;;1576              the HAL_USART_RxCpltCallback could be implemented in the user file
;;;1577      */
;;;1578   }
;;;1579   
                          ENDP


                          AREA ||i.HAL_USART_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_RxHalfCpltCallback PROC
;;;1585     */
;;;1586   __weak void HAL_USART_RxHalfCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1587   {
;;;1588     /* Prevent unused argument(s) compilation warning */
;;;1589     UNUSED(husart);
;;;1590     /* NOTE: This function should not be modified, when the callback is needed,
;;;1591              the HAL_USART_RxHalfCpltCallback could be implemented in the user file
;;;1592      */
;;;1593   }
;;;1594   
                          ENDP


                          AREA ||i.HAL_USART_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_USART_Transmit PROC
;;;425      */
;;;426    HAL_StatusTypeDef HAL_USART_Transmit(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;427    {
000004  4604              MOV      r4,r0
;;;428      uint16_t* tmp;
;;;429      uint32_t tickstart = 0U;
;;;430    
;;;431      if(husart->State == HAL_USART_STATE_READY)
000006  6c00              LDR      r0,[r0,#0x40]
000008  461e              MOV      r6,r3                 ;427
00000a  4692              MOV      r10,r2                ;427
00000c  460d              MOV      r5,r1                 ;427
00000e  2801              CMP      r0,#1
000010  d152              BNE      |L20.184|
;;;432      {
;;;433        if((pTxData == NULL) || (Size == 0U))
000012  2d00              CMP      r5,#0
000014  bf12              ITEE     NE
000016  f1ba0f00          CMPNE    r10,#0
;;;434        {
;;;435          return  HAL_ERROR;
00001a  2001              MOVEQ    r0,#1
;;;436        }
;;;437    
;;;438        /* Process Locked */
;;;439        __HAL_LOCK(husart);
;;;440    
;;;441        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;442        husart->State = HAL_USART_STATE_BUSY_TX;
;;;443    
;;;444        /* Init tickstart for timeout managment */
;;;445        tickstart = HAL_GetTick();
;;;446    
;;;447        husart->TxXferSize = Size;
;;;448        husart->TxXferCount = Size;
;;;449        while(husart->TxXferCount > 0U)
;;;450        {
;;;451          husart->TxXferCount--;
;;;452          if(husart->Init.WordLength == USART_WORDLENGTH_9B)
;;;453          {
;;;454            /* Wait for TC flag in order to write data in DR */
;;;455            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;456            {
;;;457              return HAL_TIMEOUT;
;;;458            }
;;;459            tmp = (uint16_t*) pTxData;
;;;460            WRITE_REG(husart->Instance->DR, (*tmp & (uint16_t)0x01FF));
;;;461            if(husart->Init.Parity == USART_PARITY_NONE)
;;;462            {
;;;463              pTxData += 2U;
;;;464            }
;;;465            else
;;;466            {
;;;467              pTxData += 1U;
;;;468            }
;;;469          }
;;;470          else
;;;471          {
;;;472            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;473            {
;;;474              return HAL_TIMEOUT;
;;;475            }
;;;476            WRITE_REG(husart->Instance->DR, (*pTxData++ & (uint8_t)0xFF));
;;;477          }
;;;478        }
;;;479    
;;;480        if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;481        {
;;;482          return HAL_TIMEOUT;
;;;483        }
;;;484    
;;;485        husart->State = HAL_USART_STATE_READY;
;;;486    
;;;487        /* Process Unlocked */
;;;488        __HAL_UNLOCK(husart);
;;;489    
;;;490        return HAL_OK;
;;;491      }
;;;492      else
;;;493      {
;;;494        return HAL_BUSY;
;;;495      }
;;;496    }
00001c  e8bd8ff8          POPEQ    {r3-r11,pc}
000020  6be0              LDR      r0,[r4,#0x3c]         ;439
000022  2801              CMP      r0,#1                 ;439
000024  d048              BEQ      |L20.184|
000026  f04f0800          MOV      r8,#0                 ;441
00002a  2701              MOVS     r7,#1                 ;439
00002c  f8c48044          STR      r8,[r4,#0x44]         ;441
000030  63e7              STR      r7,[r4,#0x3c]         ;441
000032  2012              MOVS     r0,#0x12              ;442
000034  6420              STR      r0,[r4,#0x40]         ;442
000036  f7fffffe          BL       HAL_GetTick
00003a  f8a4a028          STRH     r10,[r4,#0x28]        ;447
00003e  4681              MOV      r9,r0                 ;445
000040  f8a4a02a          STRH     r10,[r4,#0x2a]        ;448
000044  8d60              LDRH     r0,[r4,#0x2a]         ;449
000046  b330              CBZ      r0,|L20.150|
                  |L20.72|
000048  8d60              LDRH     r0,[r4,#0x2a]         ;451
00004a  1e40              SUBS     r0,r0,#1              ;451
00004c  8560              STRH     r0,[r4,#0x2a]         ;451
00004e  68a0              LDR      r0,[r4,#8]            ;452
000050  464b              MOV      r3,r9                 ;472
000052  f5b05f80          CMP      r0,#0x1000            ;452
000056  f04f0200          MOV      r2,#0                 ;472
00005a  f04f0180          MOV      r1,#0x80              ;472
00005e  4620              MOV      r0,r4                 ;472
000060  9600              STR      r6,[sp,#0]            ;452
000062  d003              BEQ      |L20.108|
000064  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000068  b170              CBZ      r0,|L20.136|
00006a  e01c              B        |L20.166|
                  |L20.108|
00006c  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000070  b9c8              CBNZ     r0,|L20.166|
000072  8828              LDRH     r0,[r5,#0]            ;460
000074  6821              LDR      r1,[r4,#0]            ;460
000076  f3c00008          UBFX     r0,r0,#0,#9           ;460
00007a  6048              STR      r0,[r1,#4]            ;460
00007c  6920              LDR      r0,[r4,#0x10]         ;461
00007e  2800              CMP      r0,#0                 ;461
000080  bf14              ITE      NE                    ;461
000082  1c6d              ADDNE    r5,r5,#1              ;461
000084  1cad              ADDEQ    r5,r5,#2              ;461
000086  e003              B        |L20.144|
                  |L20.136|
000088  6821              LDR      r1,[r4,#0]            ;476
00008a  f8150b01          LDRB     r0,[r5],#1            ;476
00008e  6048              STR      r0,[r1,#4]            ;476
                  |L20.144|
000090  8d60              LDRH     r0,[r4,#0x2a]         ;476
000092  2800              CMP      r0,#0                 ;476
000094  d1d8              BNE      |L20.72|
                  |L20.150|
000096  464b              MOV      r3,r9                 ;480
000098  2200              MOVS     r2,#0                 ;480
00009a  2140              MOVS     r1,#0x40              ;480
00009c  4620              MOV      r0,r4                 ;480
00009e  9600              STR      r6,[sp,#0]            ;480
0000a0  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
0000a4  b110              CBZ      r0,|L20.172|
                  |L20.166|
0000a6  2003              MOVS     r0,#3                 ;482
0000a8  e8bd8ff8          POP      {r3-r11,pc}
                  |L20.172|
0000ac  6427              STR      r7,[r4,#0x40]         ;485
0000ae  2000              MOVS     r0,#0                 ;490
0000b0  f8c4803c          STR      r8,[r4,#0x3c]         ;490
0000b4  e8bd8ff8          POP      {r3-r11,pc}
                  |L20.184|
0000b8  2002              MOVS     r0,#2                 ;494
0000ba  e8bd8ff8          POP      {r3-r11,pc}
;;;497    
                          ENDP


                          AREA ||i.HAL_USART_TransmitReceive||, CODE, READONLY, ALIGN=1

                  HAL_USART_TransmitReceive PROC
;;;612      */
;;;613    HAL_StatusTypeDef HAL_USART_TransmitReceive(USART_HandleTypeDef *husart, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;614    {
000004  4604              MOV      r4,r0
;;;615      uint16_t* tmp;
;;;616      uint32_t tickstart = 0U;
;;;617    
;;;618      if(husart->State == HAL_USART_STATE_READY)
000006  f8dd8028          LDR      r8,[sp,#0x28]
00000a  6c00              LDR      r0,[r0,#0x40]
00000c  461f              MOV      r7,r3                 ;614
00000e  4615              MOV      r5,r2                 ;614
000010  460e              MOV      r6,r1                 ;614
000012  2801              CMP      r0,#1
000014  d17d              BNE      |L21.274|
;;;619      {
;;;620        if((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
000016  2e00              CMP      r6,#0
000018  bf19              ITTEE    NE
00001a  2d00              CMPNE    r5,#0
00001c  2f00              CMPNE    r7,#0
;;;621        {
;;;622          return  HAL_ERROR;
00001e  2001              MOVEQ    r0,#1
;;;623        }
;;;624        /* Process Locked */
;;;625        __HAL_LOCK(husart);
;;;626    
;;;627        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;628        husart->State = HAL_USART_STATE_BUSY_RX;
;;;629    
;;;630        /* Init tickstart for timeout managment */
;;;631        tickstart = HAL_GetTick();
;;;632    
;;;633        husart->RxXferSize = Size;
;;;634        husart->TxXferSize = Size;
;;;635        husart->TxXferCount = Size;
;;;636        husart->RxXferCount = Size;
;;;637    
;;;638        /* Check the remain data to be received */
;;;639        while(husart->TxXferCount > 0U)
;;;640        {
;;;641          husart->TxXferCount--;
;;;642          husart->RxXferCount--;
;;;643          if(husart->Init.WordLength == USART_WORDLENGTH_9B)
;;;644          {
;;;645            /* Wait for TC flag in order to write data in DR */
;;;646            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;647            {
;;;648              return HAL_TIMEOUT;
;;;649            }
;;;650            tmp = (uint16_t*) pTxData;
;;;651            WRITE_REG(husart->Instance->DR, (*tmp & (uint16_t)0x01FF));
;;;652            if(husart->Init.Parity == USART_PARITY_NONE)
;;;653            {
;;;654              pTxData += 2U;
;;;655            }
;;;656            else
;;;657            {
;;;658              pTxData += 1U;
;;;659            }
;;;660    
;;;661            /* Wait for RXNE Flag */
;;;662            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;663            {
;;;664              return HAL_TIMEOUT;
;;;665            }
;;;666            tmp = (uint16_t*) pRxData ;
;;;667            if(husart->Init.Parity == USART_PARITY_NONE)
;;;668            {
;;;669              *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x01FF);
;;;670              pRxData += 2U;
;;;671            }
;;;672            else
;;;673            {
;;;674              *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x00FF);
;;;675              pRxData += 1U;
;;;676            }
;;;677          }
;;;678          else
;;;679          {
;;;680            /* Wait for TC flag in order to write data in DR */
;;;681            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;682            {
;;;683              return HAL_TIMEOUT;
;;;684            }
;;;685            WRITE_REG(husart->Instance->DR, (*pTxData++ & (uint8_t)0x00FF));
;;;686    
;;;687            /* Wait for RXNE Flag */
;;;688            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;689            {
;;;690              return HAL_TIMEOUT;
;;;691            }
;;;692            if(husart->Init.Parity == USART_PARITY_NONE)
;;;693            {
;;;694              /* Receive data */
;;;695              *pRxData++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x00FF);
;;;696            }
;;;697            else
;;;698            {
;;;699              /* Receive data */
;;;700              *pRxData++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x007F);
;;;701            }
;;;702          }
;;;703        }
;;;704    
;;;705        husart->State = HAL_USART_STATE_READY;
;;;706    
;;;707        /* Process Unlocked */
;;;708        __HAL_UNLOCK(husart);
;;;709    
;;;710        return HAL_OK;
;;;711      }
;;;712      else
;;;713      {
;;;714        return HAL_BUSY;
;;;715      }
;;;716    }
000020  e8bd8ff8          POPEQ    {r3-r11,pc}
000024  6be0              LDR      r0,[r4,#0x3c]         ;625
000026  2801              CMP      r0,#1                 ;625
000028  d073              BEQ      |L21.274|
00002a  f04f0a00          MOV      r10,#0                ;627
00002e  f04f0901          MOV      r9,#1                 ;625
000032  f8c4a044          STR      r10,[r4,#0x44]        ;627
000036  f8c4903c          STR      r9,[r4,#0x3c]         ;627
00003a  2022              MOVS     r0,#0x22              ;628
00003c  6420              STR      r0,[r4,#0x40]         ;628
00003e  f7fffffe          BL       HAL_GetTick
000042  8627              STRH     r7,[r4,#0x30]         ;633
000044  8527              STRH     r7,[r4,#0x28]         ;634
000046  4683              MOV      r11,r0                ;631
000048  8567              STRH     r7,[r4,#0x2a]         ;635
00004a  8667              STRH     r7,[r4,#0x32]         ;636
00004c  8d60              LDRH     r0,[r4,#0x2a]         ;639
00004e  2800              CMP      r0,#0                 ;639
000050  d03d              BEQ      |L21.206|
                  |L21.82|
000052  8d60              LDRH     r0,[r4,#0x2a]         ;641
000054  1e40              SUBS     r0,r0,#1              ;641
000056  8560              STRH     r0,[r4,#0x2a]         ;641
000058  8e60              LDRH     r0,[r4,#0x32]         ;642
00005a  1e40              SUBS     r0,r0,#1              ;642
00005c  8660              STRH     r0,[r4,#0x32]         ;642
00005e  68a0              LDR      r0,[r4,#8]            ;643
000060  465b              MOV      r3,r11                ;681
000062  f5b05f80          CMP      r0,#0x1000            ;643
000066  f04f0200          MOV      r2,#0                 ;681
00006a  f04f0180          MOV      r1,#0x80              ;681
00006e  4620              MOV      r0,r4                 ;681
000070  f8cd8000          STR      r8,[sp,#0]            ;643
000074  d004              BEQ      |L21.128|
000076  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
00007a  2800              CMP      r0,#0                 ;681
00007c  d02e              BEQ      |L21.220|
00007e  e03a              B        |L21.246|
                  |L21.128|
000080  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000084  2800              CMP      r0,#0                 ;646
000086  d136              BNE      |L21.246|
000088  8830              LDRH     r0,[r6,#0]            ;651
00008a  6821              LDR      r1,[r4,#0]            ;651
00008c  f3c00008          UBFX     r0,r0,#0,#9           ;651
000090  6048              STR      r0,[r1,#4]            ;651
000092  6920              LDR      r0,[r4,#0x10]         ;652
000094  2800              CMP      r0,#0                 ;652
000096  bf14              ITE      NE                    ;652
000098  1c76              ADDNE    r6,r6,#1              ;652
00009a  1cb6              ADDEQ    r6,r6,#2              ;652
00009c  465b              MOV      r3,r11                ;662
00009e  2200              MOVS     r2,#0                 ;662
0000a0  2120              MOVS     r1,#0x20              ;662
0000a2  4620              MOV      r0,r4                 ;662
0000a4  f8cd8000          STR      r8,[sp,#0]            ;662
0000a8  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
0000ac  bb18              CBNZ     r0,|L21.246|
0000ae  6920              LDR      r0,[r4,#0x10]         ;667
0000b0  2800              CMP      r0,#0                 ;667
0000b2  6820              LDR      r0,[r4,#0]            ;674
0000b4  6840              LDR      r0,[r0,#4]            ;674
0000b6  bf14              ITE      NE                    ;674
0000b8  b2c1              UXTBNE   r1,r0                 ;674
0000ba  f3c00108          UBFXEQ   r1,r0,#0,#9           ;669
0000be  4628              MOV      r0,r5                 ;669
0000c0  8029              STRH     r1,[r5,#0]            ;669
0000c2  bf14              ITE      NE                    ;675
0000c4  1c45              ADDNE    r5,r0,#1              ;675
0000c6  1c85              ADDEQ    r5,r0,#2              ;670
                  |L21.200|
0000c8  8d60              LDRH     r0,[r4,#0x2a]         ;700
0000ca  2800              CMP      r0,#0                 ;700
0000cc  d1c1              BNE      |L21.82|
                  |L21.206|
0000ce  f8c49040          STR      r9,[r4,#0x40]         ;705
0000d2  2000              MOVS     r0,#0                 ;710
0000d4  f8c4a03c          STR      r10,[r4,#0x3c]        ;710
0000d8  e8bd8ff8          POP      {r3-r11,pc}
                  |L21.220|
0000dc  6821              LDR      r1,[r4,#0]            ;685
0000de  f8160b01          LDRB     r0,[r6],#1            ;685
0000e2  6048              STR      r0,[r1,#4]            ;685
0000e4  465b              MOV      r3,r11                ;688
0000e6  2200              MOVS     r2,#0                 ;688
0000e8  2120              MOVS     r1,#0x20              ;688
0000ea  4620              MOV      r0,r4                 ;688
0000ec  f8cd8000          STR      r8,[sp,#0]            ;688
0000f0  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
0000f4  b118              CBZ      r0,|L21.254|
                  |L21.246|
0000f6  2003              MOVS     r0,#3                 ;690
0000f8  e8bd8ff8          POP      {r3-r11,pc}
0000fc  e009              B        |L21.274|
                  |L21.254|
0000fe  6920              LDR      r0,[r4,#0x10]         ;692
000100  2800              CMP      r0,#0                 ;692
000102  6820              LDR      r0,[r4,#0]            ;700
000104  6840              LDR      r0,[r0,#4]            ;700
000106  bf18              IT       NE                    ;700
000108  f000007f          ANDNE    r0,r0,#0x7f           ;700
00010c  f8050b01          STRB     r0,[r5],#1            ;695
000110  e7da              B        |L21.200|
                  |L21.274|
000112  2002              MOVS     r0,#2                 ;714
000114  e8bd8ff8          POP      {r3-r11,pc}
;;;717    
                          ENDP


                          AREA ||i.HAL_USART_TransmitReceive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_USART_TransmitReceive_DMA PROC
;;;1033     */
;;;1034   HAL_StatusTypeDef HAL_USART_TransmitReceive_DMA(USART_HandleTypeDef *husart, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1035   {
000002  4604              MOV      r4,r0
;;;1036     uint32_t *tmp;
;;;1037     
;;;1038     if(husart->State == HAL_USART_STATE_READY)
000004  6c00              LDR      r0,[r0,#0x40]
000006  461e              MOV      r6,r3                 ;1035
000008  460d              MOV      r5,r1                 ;1035
00000a  2801              CMP      r0,#1
00000c  d150              BNE      |L22.176|
;;;1039     {
;;;1040       if((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
00000e  2d00              CMP      r5,#0
000010  bf19              ITTEE    NE
000012  2a00              CMPNE    r2,#0
000014  2e00              CMPNE    r6,#0
;;;1041       {
;;;1042         return HAL_ERROR;
000016  2001              MOVEQ    r0,#1
;;;1043       }
;;;1044       /* Process Locked */
;;;1045       __HAL_LOCK(husart);
;;;1046   
;;;1047       husart->pRxBuffPtr = pRxData;
;;;1048       husart->RxXferSize = Size;
;;;1049       husart->pTxBuffPtr = pTxData;
;;;1050       husart->TxXferSize = Size;
;;;1051   
;;;1052       husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;1053       husart->State = HAL_USART_STATE_BUSY_TX_RX;
;;;1054   
;;;1055       /* Set the USART DMA Rx transfer complete callback */
;;;1056       husart->hdmarx->XferCpltCallback = USART_DMAReceiveCplt;
;;;1057   
;;;1058       /* Set the USART DMA Half transfer complete callback */
;;;1059       husart->hdmarx->XferHalfCpltCallback = USART_DMARxHalfCplt;
;;;1060   
;;;1061       /* Set the USART DMA Tx transfer complete callback */
;;;1062       husart->hdmatx->XferCpltCallback = USART_DMATransmitCplt;
;;;1063   
;;;1064       /* Set the USART DMA Half transfer complete callback */
;;;1065       husart->hdmatx->XferHalfCpltCallback = USART_DMATxHalfCplt;
;;;1066   
;;;1067       /* Set the USART DMA Tx transfer error callback */
;;;1068       husart->hdmatx->XferErrorCallback = USART_DMAError;
;;;1069   
;;;1070       /* Set the USART DMA Rx transfer error callback */
;;;1071       husart->hdmarx->XferErrorCallback = USART_DMAError;
;;;1072   
;;;1073       /* Set the DMA abort callback */
;;;1074       husart->hdmarx->XferAbortCallback = NULL;
;;;1075   
;;;1076       /* Enable the USART receive DMA channel */
;;;1077       tmp = (uint32_t*)&pRxData;
;;;1078       HAL_DMA_Start_IT(husart->hdmarx, (uint32_t)&husart->Instance->DR, *(uint32_t*)tmp, Size);
;;;1079   
;;;1080       /* Enable the USART transmit DMA channel */
;;;1081       tmp = (uint32_t*)&pTxData;
;;;1082       HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t*)tmp, (uint32_t)&husart->Instance->DR, Size);
;;;1083   
;;;1084       /* Clear the TC flag in the SR register by writing 0 to it */
;;;1085       __HAL_USART_CLEAR_FLAG(husart, USART_FLAG_TC);
;;;1086   
;;;1087       /* Clear the Overrun flag: mandatory for the second transfer in circular mode */
;;;1088       __HAL_USART_CLEAR_OREFLAG(husart);
;;;1089   
;;;1090       /* Process Unlocked */
;;;1091       __HAL_UNLOCK(husart);
;;;1092   
;;;1093       /* Enable the USART Parity Error Interrupt */
;;;1094       SET_BIT(husart->Instance->CR1, USART_CR1_PEIE);
;;;1095   
;;;1096       /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1097       SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;1098   
;;;1099       /* Enable the DMA transfer for the receiver request by setting the DMAR bit
;;;1100          in the USART CR3 register */
;;;1101       SET_BIT(husart->Instance->CR3, USART_CR3_DMAR);
;;;1102   
;;;1103       /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;1104          in the USART CR3 register */
;;;1105       SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1106   
;;;1107       return HAL_OK;
;;;1108     }
;;;1109     else
;;;1110     {
;;;1111       return HAL_BUSY;
;;;1112     }
;;;1113   }
000018  bdf8              POPEQ    {r3-r7,pc}
00001a  6be0              LDR      r0,[r4,#0x3c]         ;1045
00001c  2801              CMP      r0,#1                 ;1045
00001e  d047              BEQ      |L22.176|
000020  2001              MOVS     r0,#1                 ;1045
000022  62e2              STR      r2,[r4,#0x2c]         ;1048
000024  63e0              STR      r0,[r4,#0x3c]         ;1048
000026  8626              STRH     r6,[r4,#0x30]         ;1048
000028  6265              STR      r5,[r4,#0x24]         ;1050
00002a  8526              STRH     r6,[r4,#0x28]         ;1050
00002c  2700              MOVS     r7,#0                 ;1052
00002e  6467              STR      r7,[r4,#0x44]         ;1052
000030  2032              MOVS     r0,#0x32              ;1053
000032  6420              STR      r0,[r4,#0x40]         ;1053
000034  6ba1              LDR      r1,[r4,#0x38]         ;1056
000036  481f              LDR      r0,|L22.180|
000038  4633              MOV      r3,r6                 ;1078
00003a  62c8              STR      r0,[r1,#0x2c]         ;1059
00003c  6ba1              LDR      r1,[r4,#0x38]         ;1059
00003e  481e              LDR      r0,|L22.184|
000040  6308              STR      r0,[r1,#0x30]         ;1062
000042  6b61              LDR      r1,[r4,#0x34]         ;1062
000044  481d              LDR      r0,|L22.188|
000046  62c8              STR      r0,[r1,#0x2c]         ;1065
000048  6b61              LDR      r1,[r4,#0x34]         ;1065
00004a  481d              LDR      r0,|L22.192|
00004c  6308              STR      r0,[r1,#0x30]         ;1068
00004e  6b61              LDR      r1,[r4,#0x34]         ;1068
000050  481c              LDR      r0,|L22.196|
000052  6348              STR      r0,[r1,#0x34]         ;1071
000054  6ba1              LDR      r1,[r4,#0x38]         ;1071
000056  6348              STR      r0,[r1,#0x34]         ;1074
000058  6ba0              LDR      r0,[r4,#0x38]         ;1074
00005a  6387              STR      r7,[r0,#0x38]         ;1078
00005c  6820              LDR      r0,[r4,#0]            ;1078
00005e  1d01              ADDS     r1,r0,#4              ;1078
000060  6ba0              LDR      r0,[r4,#0x38]         ;1078
000062  f7fffffe          BL       HAL_DMA_Start_IT
000066  6820              LDR      r0,[r4,#0]            ;1082
000068  4629              MOV      r1,r5                 ;1082
00006a  1d02              ADDS     r2,r0,#4              ;1082
00006c  4633              MOV      r3,r6                 ;1082
00006e  6b60              LDR      r0,[r4,#0x34]         ;1082
000070  f7fffffe          BL       HAL_DMA_Start_IT
000074  6821              LDR      r1,[r4,#0]            ;1085
000076  f06f0040          MVN      r0,#0x40              ;1085
00007a  6008              STR      r0,[r1,#0]            ;1085
00007c  6820              LDR      r0,[r4,#0]            ;1088
00007e  6801              LDR      r1,[r0,#0]            ;1088
000080  6841              LDR      r1,[r0,#4]            ;1088
000082  9100              STR      r1,[sp,#0]            ;1091
000084  63e7              STR      r7,[r4,#0x3c]         ;1094
000086  68c1              LDR      r1,[r0,#0xc]          ;1094
000088  f4417180          ORR      r1,r1,#0x100          ;1094
00008c  60c1              STR      r1,[r0,#0xc]          ;1094
00008e  6820              LDR      r0,[r4,#0]            ;1097
000090  6941              LDR      r1,[r0,#0x14]         ;1097
000092  f0410101          ORR      r1,r1,#1              ;1097
000096  6141              STR      r1,[r0,#0x14]         ;1097
000098  6820              LDR      r0,[r4,#0]            ;1101
00009a  6941              LDR      r1,[r0,#0x14]         ;1101
00009c  f0410140          ORR      r1,r1,#0x40           ;1101
0000a0  6141              STR      r1,[r0,#0x14]         ;1101
0000a2  6820              LDR      r0,[r4,#0]            ;1105
0000a4  6941              LDR      r1,[r0,#0x14]         ;1105
0000a6  f0410180          ORR      r1,r1,#0x80           ;1105
0000aa  6141              STR      r1,[r0,#0x14]         ;1105
0000ac  2000              MOVS     r0,#0                 ;1107
0000ae  bdf8              POP      {r3-r7,pc}
                  |L22.176|
0000b0  2002              MOVS     r0,#2                 ;1111
0000b2  bdf8              POP      {r3-r7,pc}
;;;1114   
                          ENDP

                  |L22.180|
                          DCD      USART_DMAReceiveCplt
                  |L22.184|
                          DCD      USART_DMARxHalfCplt
                  |L22.188|
                          DCD      USART_DMATransmitCplt
                  |L22.192|
                          DCD      USART_DMATxHalfCplt
                  |L22.196|
                          DCD      USART_DMAError

                          AREA ||i.HAL_USART_TransmitReceive_IT||, CODE, READONLY, ALIGN=1

                  HAL_USART_TransmitReceive_IT PROC
;;;825      */
;;;826    HAL_StatusTypeDef HAL_USART_TransmitReceive_IT(USART_HandleTypeDef *husart, uint8_t *pTxData, uint8_t *pRxData,  uint16_t Size)
000000  f8d0c040          LDR      r12,[r0,#0x40]
;;;827    {
;;;828      if(husart->State == HAL_USART_STATE_READY)
000004  f1bc0f01          CMP      r12,#1
000008  d12b              BNE      |L23.98|
;;;829      {
;;;830        if((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
00000a  2900              CMP      r1,#0
00000c  bf19              ITTEE    NE
00000e  2a00              CMPNE    r2,#0
000010  2b00              CMPNE    r3,#0
;;;831        {
;;;832          return HAL_ERROR;
000012  2001              MOVEQ    r0,#1
;;;833        }
;;;834        /* Process Locked */
;;;835        __HAL_LOCK(husart);
;;;836    
;;;837        husart->pRxBuffPtr = pRxData;
;;;838        husart->RxXferSize = Size;
;;;839        husart->RxXferCount = Size;
;;;840        husart->pTxBuffPtr = pTxData;
;;;841        husart->TxXferSize = Size;
;;;842        husart->TxXferCount = Size;
;;;843    
;;;844        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;845        husart->State = HAL_USART_STATE_BUSY_TX_RX;
;;;846    
;;;847        /* Process Unlocked */
;;;848        __HAL_UNLOCK(husart);
;;;849    
;;;850        /* Enable the USART Data Register not empty Interrupt */
;;;851        __HAL_USART_ENABLE_IT(husart, USART_IT_RXNE); 
;;;852    
;;;853        /* Enable the USART Parity Error Interrupt */
;;;854        __HAL_USART_ENABLE_IT(husart, USART_IT_PE);
;;;855    
;;;856        /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;857        __HAL_USART_ENABLE_IT(husart, USART_IT_ERR);
;;;858    
;;;859        /* Enable the USART Transmit Data Register Empty Interrupt */
;;;860        __HAL_USART_ENABLE_IT(husart, USART_IT_TXE);
;;;861    
;;;862        return HAL_OK;
;;;863      }
;;;864      else
;;;865      {
;;;866        return HAL_BUSY;
;;;867      }
;;;868    }
000014  4770              BXEQ     lr
000016  f8d0c03c          LDR      r12,[r0,#0x3c]        ;835
00001a  f1bc0f01          CMP      r12,#1                ;835
00001e  d020              BEQ      |L23.98|
000020  62c2              STR      r2,[r0,#0x2c]         ;838
000022  8603              STRH     r3,[r0,#0x30]         ;838
000024  8643              STRH     r3,[r0,#0x32]         ;839
000026  6241              STR      r1,[r0,#0x24]         ;841
000028  8503              STRH     r3,[r0,#0x28]         ;841
00002a  8543              STRH     r3,[r0,#0x2a]         ;842
00002c  2100              MOVS     r1,#0                 ;844
00002e  6441              STR      r1,[r0,#0x44]         ;844
000030  2232              MOVS     r2,#0x32              ;845
000032  6402              STR      r2,[r0,#0x40]         ;845
000034  63c1              STR      r1,[r0,#0x3c]         ;851
000036  6801              LDR      r1,[r0,#0]            ;851
000038  68ca              LDR      r2,[r1,#0xc]          ;851
00003a  f0420220          ORR      r2,r2,#0x20           ;851
00003e  60ca              STR      r2,[r1,#0xc]          ;851
000040  6801              LDR      r1,[r0,#0]            ;854
000042  68ca              LDR      r2,[r1,#0xc]          ;854
000044  f4427280          ORR      r2,r2,#0x100          ;854
000048  60ca              STR      r2,[r1,#0xc]          ;854
00004a  6801              LDR      r1,[r0,#0]            ;857
00004c  694a              LDR      r2,[r1,#0x14]         ;857
00004e  f0420201          ORR      r2,r2,#1              ;857
000052  614a              STR      r2,[r1,#0x14]         ;857
000054  6800              LDR      r0,[r0,#0]            ;860
000056  68c1              LDR      r1,[r0,#0xc]          ;860
000058  f0410180          ORR      r1,r1,#0x80           ;860
00005c  60c1              STR      r1,[r0,#0xc]          ;860
00005e  2000              MOVS     r0,#0                 ;862
000060  4770              BX       lr
                  |L23.98|
000062  2002              MOVS     r0,#2                 ;866
000064  4770              BX       lr
;;;869    
                          ENDP


                          AREA ||i.HAL_USART_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_USART_Transmit_DMA PROC
;;;877      */
;;;878    HAL_StatusTypeDef HAL_USART_Transmit_DMA(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;879    {
000002  4604              MOV      r4,r0
;;;880      uint32_t *tmp;
;;;881      
;;;882      if(husart->State == HAL_USART_STATE_READY)
000004  6c00              LDR      r0,[r0,#0x40]
000006  2801              CMP      r0,#1
000008  d12f              BNE      |L24.106|
;;;883      {
;;;884        if((pTxData == NULL) || (Size == 0U))
00000a  2900              CMP      r1,#0
00000c  bf12              ITEE     NE
00000e  2a00              CMPNE    r2,#0
;;;885        {
;;;886          return HAL_ERROR;
000010  2001              MOVEQ    r0,#1
;;;887        }
;;;888        /* Process Locked */
;;;889        __HAL_LOCK(husart);
;;;890    
;;;891        husart->pTxBuffPtr = pTxData;
;;;892        husart->TxXferSize = Size;
;;;893        husart->TxXferCount = Size;
;;;894    
;;;895        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;896        husart->State = HAL_USART_STATE_BUSY_TX;
;;;897    
;;;898        /* Set the USART DMA transfer complete callback */
;;;899        husart->hdmatx->XferCpltCallback = USART_DMATransmitCplt;
;;;900    
;;;901        /* Set the USART DMA Half transfer complete callback */
;;;902        husart->hdmatx->XferHalfCpltCallback = USART_DMATxHalfCplt;
;;;903    
;;;904        /* Set the DMA error callback */
;;;905        husart->hdmatx->XferErrorCallback = USART_DMAError;
;;;906    
;;;907        /* Set the DMA abort callback */
;;;908        husart->hdmatx->XferAbortCallback = NULL;
;;;909    
;;;910        /* Enable the USART transmit DMA channel */
;;;911        tmp = (uint32_t*)&pTxData;
;;;912        HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t*)tmp, (uint32_t)&husart->Instance->DR, Size);
;;;913    
;;;914        /* Clear the TC flag in the SR register by writing 0 to it */
;;;915        __HAL_USART_CLEAR_FLAG(husart, USART_FLAG_TC);
;;;916    
;;;917        /* Process Unlocked */
;;;918        __HAL_UNLOCK(husart);
;;;919    
;;;920        /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;921        in the USART CR3 register */
;;;922        SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;923    
;;;924        return HAL_OK;
;;;925      }
;;;926      else
;;;927      {
;;;928        return HAL_BUSY;
;;;929      }
;;;930    }
000012  bd70              POPEQ    {r4-r6,pc}
000014  6be0              LDR      r0,[r4,#0x3c]         ;889
000016  2801              CMP      r0,#1                 ;889
000018  d027              BEQ      |L24.106|
00001a  2001              MOVS     r0,#1                 ;889
00001c  6261              STR      r1,[r4,#0x24]         ;892
00001e  63e0              STR      r0,[r4,#0x3c]         ;892
000020  8522              STRH     r2,[r4,#0x28]         ;892
000022  8562              STRH     r2,[r4,#0x2a]         ;893
000024  2500              MOVS     r5,#0                 ;895
000026  6465              STR      r5,[r4,#0x44]         ;895
000028  2012              MOVS     r0,#0x12              ;896
00002a  6420              STR      r0,[r4,#0x40]         ;896
00002c  6b63              LDR      r3,[r4,#0x34]         ;899
00002e  4810              LDR      r0,|L24.112|
000030  62d8              STR      r0,[r3,#0x2c]         ;902
000032  6b63              LDR      r3,[r4,#0x34]         ;902
000034  480f              LDR      r0,|L24.116|
000036  6318              STR      r0,[r3,#0x30]         ;905
000038  6b63              LDR      r3,[r4,#0x34]         ;905
00003a  480f              LDR      r0,|L24.120|
00003c  6358              STR      r0,[r3,#0x34]         ;908
00003e  6b60              LDR      r0,[r4,#0x34]         ;908
000040  4613              MOV      r3,r2                 ;912
000042  6385              STR      r5,[r0,#0x38]         ;912
000044  6820              LDR      r0,[r4,#0]            ;912
000046  f1000c04          ADD      r12,r0,#4             ;912
00004a  4662              MOV      r2,r12                ;912
00004c  6b60              LDR      r0,[r4,#0x34]         ;912
00004e  f7fffffe          BL       HAL_DMA_Start_IT
000052  6821              LDR      r1,[r4,#0]            ;915
000054  f06f0040          MVN      r0,#0x40              ;915
000058  6008              STR      r0,[r1,#0]            ;915
00005a  63e5              STR      r5,[r4,#0x3c]         ;922
00005c  6820              LDR      r0,[r4,#0]            ;922
00005e  6941              LDR      r1,[r0,#0x14]         ;922
000060  f0410180          ORR      r1,r1,#0x80           ;922
000064  6141              STR      r1,[r0,#0x14]         ;922
000066  2000              MOVS     r0,#0                 ;924
000068  bd70              POP      {r4-r6,pc}
                  |L24.106|
00006a  2002              MOVS     r0,#2                 ;928
00006c  bd70              POP      {r4-r6,pc}
;;;931    
                          ENDP

00006e  0000              DCW      0x0000
                  |L24.112|
                          DCD      USART_DMATransmitCplt
                  |L24.116|
                          DCD      USART_DMATxHalfCplt
                  |L24.120|
                          DCD      USART_DMAError

                          AREA ||i.HAL_USART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  HAL_USART_Transmit_IT PROC
;;;726      */
;;;727    HAL_StatusTypeDef HAL_USART_Transmit_IT(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size)
000000  6c03              LDR      r3,[r0,#0x40]
;;;728    {
;;;729      /* Check that a Tx process is not already ongoing */
;;;730      if(husart->State == HAL_USART_STATE_READY)
000002  2b01              CMP      r3,#1
000004  d116              BNE      |L25.52|
;;;731      {
;;;732        if((pTxData == NULL) || (Size == 0U))
000006  2900              CMP      r1,#0
000008  bf12              ITEE     NE
00000a  2a00              CMPNE    r2,#0
;;;733        {
;;;734          return HAL_ERROR;
00000c  2001              MOVEQ    r0,#1
;;;735        }
;;;736        /* Process Locked */
;;;737        __HAL_LOCK(husart);
;;;738    
;;;739        husart->pTxBuffPtr = pTxData;
;;;740        husart->TxXferSize = Size;
;;;741        husart->TxXferCount = Size;
;;;742    
;;;743        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;744        husart->State = HAL_USART_STATE_BUSY_TX;
;;;745    
;;;746        /* The USART Error Interrupts: (Frame error, Noise error, Overrun error)
;;;747           are not managed by the USART transmit process to avoid the overrun interrupt
;;;748           when the USART mode is configured for transmit and receive "USART_MODE_TX_RX"
;;;749           to benefit for the frame error and noise interrupts the USART mode should be
;;;750           configured only for transmit "USART_MODE_TX"
;;;751           The __HAL_USART_ENABLE_IT(husart, USART_IT_ERR) can be used to enable the Frame error,
;;;752           Noise error interrupt */
;;;753    
;;;754        /* Process Unlocked */
;;;755        __HAL_UNLOCK(husart);
;;;756    
;;;757        /* Enable the USART Transmit Data Register Empty Interrupt */
;;;758        __HAL_USART_ENABLE_IT(husart, USART_IT_TXE);
;;;759    
;;;760        return HAL_OK;
;;;761      }
;;;762      else
;;;763      {
;;;764        return HAL_BUSY;
;;;765      }
;;;766    }
00000e  4770              BXEQ     lr
000010  6bc3              LDR      r3,[r0,#0x3c]         ;737
000012  2b01              CMP      r3,#1                 ;737
000014  d00e              BEQ      |L25.52|
000016  6241              STR      r1,[r0,#0x24]         ;740
000018  8502              STRH     r2,[r0,#0x28]         ;740
00001a  8542              STRH     r2,[r0,#0x2a]         ;741
00001c  2100              MOVS     r1,#0                 ;743
00001e  6441              STR      r1,[r0,#0x44]         ;743
000020  2212              MOVS     r2,#0x12              ;744
000022  6402              STR      r2,[r0,#0x40]         ;744
000024  63c1              STR      r1,[r0,#0x3c]         ;758
000026  6800              LDR      r0,[r0,#0]            ;758
000028  68c1              LDR      r1,[r0,#0xc]          ;758
00002a  f0410180          ORR      r1,r1,#0x80           ;758
00002e  60c1              STR      r1,[r0,#0xc]          ;758
000030  2000              MOVS     r0,#0                 ;760
000032  4770              BX       lr
                  |L25.52|
000034  2002              MOVS     r0,#2                 ;764
000036  4770              BX       lr
;;;767    
                          ENDP


                          AREA ||i.HAL_USART_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_TxCpltCallback PROC
;;;1540     */
;;;1541   __weak void HAL_USART_TxCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1542   {
;;;1543     /* Prevent unused argument(s) compilation warning */
;;;1544     UNUSED(husart);
;;;1545     /* NOTE: This function should not be modified, when the callback is needed,
;;;1546              the HAL_USART_TxCpltCallback could be implemented in the user file
;;;1547      */
;;;1548   }
;;;1549   
                          ENDP


                          AREA ||i.HAL_USART_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_TxHalfCpltCallback PROC
;;;1555     */
;;;1556   __weak void HAL_USART_TxHalfCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1557   {
;;;1558     /* Prevent unused argument(s) compilation warning */
;;;1559     UNUSED(husart);
;;;1560     /* NOTE: This function should not be modified, when the callback is needed,
;;;1561              the HAL_USART_TxHalfCpltCallback could be implemented in the user file
;;;1562      */
;;;1563   }
;;;1564   
                          ENDP


                          AREA ||i.HAL_USART_TxRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_TxRxCpltCallback PROC
;;;1600     */
;;;1601   __weak void HAL_USART_TxRxCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1602   {
;;;1603     /* Prevent unused argument(s) compilation warning */
;;;1604     UNUSED(husart);
;;;1605     /* NOTE: This function should not be modified, when the callback is needed,
;;;1606              the HAL_USART_TxRxCpltCallback could be implemented in the user file
;;;1607      */
;;;1608   }
;;;1609   
                          ENDP


                          AREA ||i.USART_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  USART_DMAAbortOnError PROC
;;;1913     */
;;;1914   static void USART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1915   {
;;;1916     USART_HandleTypeDef* husart = ( USART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a80              LDR      r0,[r0,#0x28]
;;;1917     husart->RxXferCount = 0x00U;
000004  2100              MOVS     r1,#0
000006  8641              STRH     r1,[r0,#0x32]
;;;1918     husart->TxXferCount = 0x00U;
000008  8541              STRH     r1,[r0,#0x2a]
;;;1919   
;;;1920     HAL_USART_ErrorCallback(husart);
00000a  f7fffffe          BL       HAL_USART_ErrorCallback
;;;1921   }
00000e  bd10              POP      {r4,pc}
;;;1922   
                          ENDP


                          AREA ||i.USART_DMAError||, CODE, READONLY, ALIGN=1

                  USART_DMAError PROC
;;;1813     */
;;;1814   static void USART_DMAError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1815   {
;;;1816     uint32_t dmarequest = 0x00U;
;;;1817     USART_HandleTypeDef* husart = ( USART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a80              LDR      r0,[r0,#0x28]
;;;1818     husart->RxXferCount = 0x00U;
000004  2100              MOVS     r1,#0
000006  8641              STRH     r1,[r0,#0x32]
;;;1819     husart->TxXferCount = 0x00U;
000008  8541              STRH     r1,[r0,#0x2a]
;;;1820   
;;;1821     /* Stop USART DMA Tx request if ongoing */
;;;1822     dmarequest = HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT);
00000a  6802              LDR      r2,[r0,#0]
00000c  6951              LDR      r1,[r2,#0x14]
;;;1823     if((husart->State == HAL_USART_STATE_BUSY_TX) && dmarequest)
00000e  f8d0c040          LDR      r12,[r0,#0x40]
000012  f3c113c0          UBFX     r3,r1,#7,#1           ;1822
000016  2101              MOVS     r1,#1                 ;1822
000018  f1bc0f12          CMP      r12,#0x12
00001c  d105              BNE      |L30.42|
00001e  b123              CBZ      r3,|L30.42|
000020  68d3              LDR      r3,[r2,#0xc]
000022  f02303c0          BIC      r3,r3,#0xc0
000026  60d3              STR      r3,[r2,#0xc]
000028  6401              STR      r1,[r0,#0x40]
                  |L30.42|
;;;1824     {
;;;1825       USART_EndTxTransfer(husart);
;;;1826     }
;;;1827   
;;;1828     /* Stop USART DMA Rx request if ongoing */
;;;1829     dmarequest = HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR);
00002a  6802              LDR      r2,[r0,#0]
00002c  6953              LDR      r3,[r2,#0x14]
;;;1830     if((husart->State == HAL_USART_STATE_BUSY_RX) && dmarequest)
00002e  f8d0c040          LDR      r12,[r0,#0x40]
000032  f3c31380          UBFX     r3,r3,#6,#1           ;1829
000036  f1bc0f22          CMP      r12,#0x22
00003a  d10a              BNE      |L30.82|
00003c  b14b              CBZ      r3,|L30.82|
00003e  68d3              LDR      r3,[r2,#0xc]
000040  f4237390          BIC      r3,r3,#0x120
000044  60d3              STR      r3,[r2,#0xc]
000046  6802              LDR      r2,[r0,#0]
000048  6953              LDR      r3,[r2,#0x14]
00004a  f0230301          BIC      r3,r3,#1
00004e  6153              STR      r3,[r2,#0x14]
000050  6401              STR      r1,[r0,#0x40]
                  |L30.82|
;;;1831     {
;;;1832       USART_EndRxTransfer(husart);
;;;1833     }
;;;1834   
;;;1835     husart->ErrorCode |= HAL_USART_ERROR_DMA;
000052  6c42              LDR      r2,[r0,#0x44]
000054  f0420210          ORR      r2,r2,#0x10
000058  6442              STR      r2,[r0,#0x44]
;;;1836     husart->State= HAL_USART_STATE_READY;
00005a  6401              STR      r1,[r0,#0x40]
;;;1837   
;;;1838     HAL_USART_ErrorCallback(husart);
00005c  f7fffffe          BL       HAL_USART_ErrorCallback
;;;1839   }
000060  bd10              POP      {r4,pc}
;;;1840   
                          ENDP


                          AREA ||i.USART_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  USART_DMAReceiveCplt PROC
;;;1748     */
;;;1749   static void USART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1750   {
000002  4601              MOV      r1,r0
;;;1751     USART_HandleTypeDef* husart = ( USART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6a80              LDR      r0,[r0,#0x28]
;;;1752     /* DMA Normal mode */
;;;1753     if(HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC))
000006  6809              LDR      r1,[r1,#0]
000008  6809              LDR      r1,[r1,#0]
00000a  f0110f20          TST      r1,#0x20
00000e  d005              BEQ      |L31.28|
;;;1754     {
;;;1755       husart->RxXferCount = 0x00U;
;;;1756   
;;;1757       /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1758       CLEAR_BIT(husart->Instance->CR1, USART_CR1_PEIE);
;;;1759       CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;1760       
;;;1761       if(husart->State == HAL_USART_STATE_BUSY_RX)
;;;1762       {
;;;1763         /* Disable the DMA transfer for the Transmit/Receiver requests by setting the DMAT/DMAR bit
;;;1764            in the USART CR3 register */
;;;1765         CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
;;;1766   
;;;1767         husart->State= HAL_USART_STATE_READY;
;;;1768         HAL_USART_RxCpltCallback(husart);
;;;1769       }
;;;1770       /* The USART state is HAL_USART_STATE_BUSY_TX_RX */
;;;1771       else
;;;1772       {
;;;1773         /* Disable the DMA transfer for the Transmit/receiver requests by setting the DMAT/DMAR bit
;;;1774            in the USART CR3 register */
;;;1775         CLEAR_BIT(husart->Instance->CR3, (USART_CR3_DMAT | USART_CR3_DMAR));
;;;1776   
;;;1777         husart->State= HAL_USART_STATE_READY;
;;;1778         HAL_USART_TxRxCpltCallback(husart);
;;;1779       }
;;;1780     }
;;;1781     /* DMA circular mode */
;;;1782     else
;;;1783     {
;;;1784       if(husart->State == HAL_USART_STATE_BUSY_RX)
000010  6c01              LDR      r1,[r0,#0x40]
000012  2922              CMP      r1,#0x22
000014  d022              BEQ      |L31.92|
;;;1785       {
;;;1786         HAL_USART_RxCpltCallback(husart);
;;;1787       }
;;;1788       /* The USART state is HAL_USART_STATE_BUSY_TX_RX */
;;;1789       else
;;;1790       {
;;;1791         HAL_USART_TxRxCpltCallback(husart);
000016  f7fffffe          BL       HAL_USART_TxRxCpltCallback
;;;1792       }
;;;1793     }
;;;1794   }
00001a  bd10              POP      {r4,pc}
                  |L31.28|
00001c  2100              MOVS     r1,#0                 ;1755
00001e  8641              STRH     r1,[r0,#0x32]         ;1755
000020  6801              LDR      r1,[r0,#0]            ;1758
000022  68ca              LDR      r2,[r1,#0xc]          ;1758
000024  f4227280          BIC      r2,r2,#0x100          ;1758
000028  60ca              STR      r2,[r1,#0xc]          ;1758
00002a  6801              LDR      r1,[r0,#0]            ;1759
00002c  694a              LDR      r2,[r1,#0x14]         ;1759
00002e  f0220201          BIC      r2,r2,#1              ;1759
000032  614a              STR      r2,[r1,#0x14]         ;1759
000034  6c02              LDR      r2,[r0,#0x40]         ;1761
000036  2101              MOVS     r1,#1                 ;1767
000038  2a22              CMP      r2,#0x22              ;1761
00003a  6802              LDR      r2,[r0,#0]            ;1775
00003c  6953              LDR      r3,[r2,#0x14]         ;1775
00003e  d006              BEQ      |L31.78|
000040  f02303c0          BIC      r3,r3,#0xc0           ;1775
000044  6153              STR      r3,[r2,#0x14]         ;1775
000046  6401              STR      r1,[r0,#0x40]         ;1777
000048  f7fffffe          BL       HAL_USART_TxRxCpltCallback
00004c  bd10              POP      {r4,pc}
                  |L31.78|
00004e  f0230340          BIC      r3,r3,#0x40           ;1765
000052  6153              STR      r3,[r2,#0x14]         ;1765
000054  6401              STR      r1,[r0,#0x40]         ;1767
000056  f7fffffe          BL       HAL_USART_RxCpltCallback
00005a  bd10              POP      {r4,pc}
                  |L31.92|
00005c  f7fffffe          BL       HAL_USART_RxCpltCallback
000060  bd10              POP      {r4,pc}
;;;1795   
                          ENDP


                          AREA ||i.USART_DMARxAbortCallback||, CODE, READONLY, ALIGN=1

                  USART_DMARxAbortCallback PROC
;;;1967     */
;;;1968   static void USART_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1969   {
;;;1970     USART_HandleTypeDef* husart = ( USART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a80              LDR      r0,[r0,#0x28]
;;;1971     
;;;1972     husart->hdmarx->XferAbortCallback = NULL;
000004  2100              MOVS     r1,#0
000006  6b82              LDR      r2,[r0,#0x38]
;;;1973   
;;;1974     /* Check if an Abort process is still ongoing */
;;;1975     if(husart->hdmatx != NULL)
000008  6391              STR      r1,[r2,#0x38]
00000a  6b42              LDR      r2,[r0,#0x34]
00000c  2a00              CMP      r2,#0
;;;1976     {
;;;1977       if(husart->hdmatx->XferAbortCallback != NULL)
00000e  bf1e              ITTT     NE
000010  6b92              LDRNE    r2,[r2,#0x38]
000012  2a00              CMPNE    r2,#0
;;;1978       {
;;;1979         return;
;;;1980       }
;;;1981     }
;;;1982     
;;;1983     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;1984     husart->TxXferCount = 0x00U;
;;;1985     husart->RxXferCount = 0x00U;
;;;1986   
;;;1987     /* Reset errorCode */
;;;1988     husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;1989   
;;;1990     /* Restore husart->State to Ready */
;;;1991     husart->State  = HAL_USART_STATE_READY;
;;;1992   
;;;1993     /* Call user Abort complete callback */
;;;1994     HAL_USART_AbortCpltCallback(husart);
;;;1995   }
000014  bd10              POPNE    {r4,pc}
000016  8541              STRH     r1,[r0,#0x2a]         ;1984
000018  8641              STRH     r1,[r0,#0x32]         ;1985
00001a  6441              STR      r1,[r0,#0x44]         ;1988
00001c  2101              MOVS     r1,#1                 ;1991
00001e  6401              STR      r1,[r0,#0x40]         ;1991
000020  f7fffffe          BL       HAL_USART_AbortCpltCallback
000024  bd10              POP      {r4,pc}
;;;1996   
                          ENDP


                          AREA ||i.USART_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  USART_DMARxHalfCplt PROC
;;;1801     */
;;;1802   static void USART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1803   {
;;;1804     USART_HandleTypeDef* husart = (USART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000002  6a80              LDR      r0,[r0,#0x28]
;;;1805   
;;;1806     HAL_USART_RxHalfCpltCallback(husart);
000004  f7fffffe          BL       HAL_USART_RxHalfCpltCallback
;;;1807   }
000008  bd10              POP      {r4,pc}
;;;1808   
                          ENDP


                          AREA ||i.USART_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  USART_DMATransmitCplt PROC
;;;1703     */
;;;1704   static void USART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1705   {
000002  4601              MOV      r1,r0
;;;1706     USART_HandleTypeDef* husart = ( USART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6a80              LDR      r0,[r0,#0x28]
;;;1707     /* DMA Normal mode */
;;;1708     if(HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC))
000006  6809              LDR      r1,[r1,#0]
000008  6809              LDR      r1,[r1,#0]
00000a  f0110f20          TST      r1,#0x20
00000e  d005              BEQ      |L34.28|
;;;1709     {
;;;1710       husart->TxXferCount = 0U;
;;;1711       if(husart->State == HAL_USART_STATE_BUSY_TX)
;;;1712       {
;;;1713         /* Disable the DMA transfer for transmit request by resetting the DMAT bit
;;;1714            in the USART CR3 register */
;;;1715         CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1716         
;;;1717         /* Enable the USART Transmit Complete Interrupt */
;;;1718         __HAL_USART_ENABLE_IT(husart, USART_IT_TC);
;;;1719       }
;;;1720     }
;;;1721     /* DMA Circular mode */
;;;1722     else
;;;1723     {
;;;1724       if(husart->State == HAL_USART_STATE_BUSY_TX)
000010  6c01              LDR      r1,[r0,#0x40]
000012  2912              CMP      r1,#0x12
;;;1725       {
;;;1726         HAL_USART_TxCpltCallback(husart);
000014  bf08              IT       EQ
000016  f7fffffe          BLEQ     HAL_USART_TxCpltCallback
;;;1727       }
;;;1728     }
;;;1729   }
00001a  bd10              POP      {r4,pc}
                  |L34.28|
00001c  2100              MOVS     r1,#0                 ;1710
00001e  8541              STRH     r1,[r0,#0x2a]         ;1710
000020  6c01              LDR      r1,[r0,#0x40]         ;1711
000022  2912              CMP      r1,#0x12              ;1711
000024  bf18              IT       NE
000026  bd10              POPNE    {r4,pc}
000028  6801              LDR      r1,[r0,#0]            ;1715
00002a  694a              LDR      r2,[r1,#0x14]         ;1715
00002c  f0220280          BIC      r2,r2,#0x80           ;1715
000030  614a              STR      r2,[r1,#0x14]         ;1715
000032  6800              LDR      r0,[r0,#0]            ;1718
000034  68c1              LDR      r1,[r0,#0xc]          ;1718
000036  f0410140          ORR      r1,r1,#0x40           ;1718
00003a  60c1              STR      r1,[r0,#0xc]          ;1718
00003c  bd10              POP      {r4,pc}
;;;1730   
                          ENDP


                          AREA ||i.USART_DMATxAbortCallback||, CODE, READONLY, ALIGN=1

                  USART_DMATxAbortCallback PROC
;;;1930     */
;;;1931   static void USART_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1932   {
;;;1933     USART_HandleTypeDef* husart = ( USART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a80              LDR      r0,[r0,#0x28]
;;;1934     
;;;1935     husart->hdmatx->XferAbortCallback = NULL;
000004  2100              MOVS     r1,#0
000006  6b42              LDR      r2,[r0,#0x34]
;;;1936   
;;;1937     /* Check if an Abort process is still ongoing */
;;;1938     if(husart->hdmarx != NULL)
000008  6391              STR      r1,[r2,#0x38]
00000a  6b82              LDR      r2,[r0,#0x38]
00000c  2a00              CMP      r2,#0
;;;1939     {
;;;1940       if(husart->hdmarx->XferAbortCallback != NULL)
00000e  bf1e              ITTT     NE
000010  6b92              LDRNE    r2,[r2,#0x38]
000012  2a00              CMPNE    r2,#0
;;;1941       {
;;;1942         return;
;;;1943       }
;;;1944     }
;;;1945     
;;;1946     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;1947     husart->TxXferCount = 0x00U;
;;;1948     husart->RxXferCount = 0x00U;
;;;1949   
;;;1950     /* Reset errorCode */
;;;1951     husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;1952   
;;;1953     /* Restore husart->State to Ready */
;;;1954     husart->State  = HAL_USART_STATE_READY;
;;;1955   
;;;1956     /* Call user Abort complete callback */
;;;1957     HAL_USART_AbortCpltCallback(husart);
;;;1958   }
000014  bd10              POPNE    {r4,pc}
000016  8541              STRH     r1,[r0,#0x2a]         ;1947
000018  8641              STRH     r1,[r0,#0x32]         ;1948
00001a  6441              STR      r1,[r0,#0x44]         ;1951
00001c  2101              MOVS     r1,#1                 ;1954
00001e  6401              STR      r1,[r0,#0x40]         ;1954
000020  f7fffffe          BL       HAL_USART_AbortCpltCallback
000024  bd10              POP      {r4,pc}
;;;1959   
                          ENDP


                          AREA ||i.USART_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  USART_DMATxHalfCplt PROC
;;;1736     */
;;;1737   static void USART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1738   {
;;;1739     USART_HandleTypeDef* husart = (USART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000002  6a80              LDR      r0,[r0,#0x28]
;;;1740   
;;;1741     HAL_USART_TxHalfCpltCallback(husart);
000004  f7fffffe          BL       HAL_USART_TxHalfCpltCallback
;;;1742   }
000008  bd10              POP      {r4,pc}
;;;1743   
                          ENDP


                          AREA ||i.USART_Receive_IT||, CODE, READONLY, ALIGN=1

                  USART_Receive_IT PROC
;;;2070     */
;;;2071   static HAL_StatusTypeDef USART_Receive_IT(USART_HandleTypeDef *husart)
000000  b510              PUSH     {r4,lr}
;;;2072   {
;;;2073     uint16_t* tmp;
;;;2074     if(husart->State == HAL_USART_STATE_BUSY_RX)
000002  6c01              LDR      r1,[r0,#0x40]
000004  2922              CMP      r1,#0x22
;;;2075     {
;;;2076       if(husart->Init.WordLength == USART_WORDLENGTH_9B)
;;;2077       {
;;;2078         tmp = (uint16_t*) husart->pRxBuffPtr;
;;;2079         if(husart->Init.Parity == USART_PARITY_NONE)
;;;2080         {
;;;2081           *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x01FF);
;;;2082           husart->pRxBuffPtr += 2U;
;;;2083         }
;;;2084         else
;;;2085         {
;;;2086           *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x00FF);
;;;2087           husart->pRxBuffPtr += 1U;
;;;2088         }
;;;2089         if(--husart->RxXferCount != 0x00U)
;;;2090         {
;;;2091           /* Send dummy byte in order to generate the clock for the slave to send the next data */
;;;2092           WRITE_REG(husart->Instance->DR, (DUMMY_DATA & (uint16_t)0x01FF)); 
;;;2093         }
;;;2094       }
;;;2095       else
;;;2096       {
;;;2097         if(husart->Init.Parity == USART_PARITY_NONE)
;;;2098         {
;;;2099           *husart->pRxBuffPtr++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x00FF);
;;;2100         }
;;;2101         else
;;;2102         {
;;;2103           *husart->pRxBuffPtr++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x007F);
;;;2104         }
;;;2105   
;;;2106         if(--husart->RxXferCount != 0x00U)
;;;2107         {
;;;2108           /* Send dummy byte in order to generate the clock for the slave to send the next data */
;;;2109           WRITE_REG(husart->Instance->DR, (DUMMY_DATA & (uint16_t)0x00FF));  
;;;2110         }
;;;2111       }
;;;2112   
;;;2113       if(husart->RxXferCount == 0U)
;;;2114       {
;;;2115         /* Disable the USART RXNE Interrupt */
;;;2116         CLEAR_BIT(husart->Instance->CR1, USART_CR1_RXNEIE);
;;;2117   
;;;2118         /* Disable the USART Parity Error Interrupt */
;;;2119         CLEAR_BIT(husart->Instance->CR1, USART_CR1_PEIE);
;;;2120   
;;;2121         /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;2122         CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;2123   
;;;2124         husart->State = HAL_USART_STATE_READY;
;;;2125         HAL_USART_RxCpltCallback(husart);
;;;2126   
;;;2127         return HAL_OK;
;;;2128       }
;;;2129       return HAL_OK;
;;;2130     }
;;;2131     else
;;;2132     {
;;;2133       return HAL_BUSY;
000006  bf1c              ITT      NE
000008  2002              MOVNE    r0,#2
;;;2134     }
;;;2135   }
00000a  bd10              POPNE    {r4,pc}
00000c  6881              LDR      r1,[r0,#8]            ;2076
00000e  f5b15f80          CMP      r1,#0x1000            ;2076
000012  d02d              BEQ      |L37.112|
000014  6901              LDR      r1,[r0,#0x10]         ;2097
000016  2900              CMP      r1,#0                 ;2097
000018  6801              LDR      r1,[r0,#0]            ;2097
00001a  d043              BEQ      |L37.164|
00001c  6849              LDR      r1,[r1,#4]            ;2103
00001e  f001027f          AND      r2,r1,#0x7f           ;2103
000022  6ac1              LDR      r1,[r0,#0x2c]         ;2103
000024  1c4b              ADDS     r3,r1,#1              ;2103
000026  62c3              STR      r3,[r0,#0x2c]         ;2103
000028  700a              STRB     r2,[r1,#0]            ;2103
                  |L37.42|
00002a  8e41              LDRH     r1,[r0,#0x32]         ;2106
00002c  1e49              SUBS     r1,r1,#1              ;2106
00002e  0409              LSLS     r1,r1,#16             ;2106
000030  0c09              LSRS     r1,r1,#16             ;2106
000032  8641              STRH     r1,[r0,#0x32]         ;2106
000034  d002              BEQ      |L37.60|
000036  6802              LDR      r2,[r0,#0]            ;2109
000038  21ff              MOVS     r1,#0xff              ;2109
00003a  6051              STR      r1,[r2,#4]            ;2109
                  |L37.60|
00003c  8e41              LDRH     r1,[r0,#0x32]         ;2113
00003e  2900              CMP      r1,#0                 ;2113
000040  bf1c              ITT      NE                    ;2129
000042  2000              MOVNE    r0,#0                 ;2129
000044  bd10              POPNE    {r4,pc}
000046  6801              LDR      r1,[r0,#0]            ;2116
000048  68ca              LDR      r2,[r1,#0xc]          ;2116
00004a  f0220220          BIC      r2,r2,#0x20           ;2116
00004e  60ca              STR      r2,[r1,#0xc]          ;2116
000050  6801              LDR      r1,[r0,#0]            ;2119
000052  68ca              LDR      r2,[r1,#0xc]          ;2119
000054  f4227280          BIC      r2,r2,#0x100          ;2119
000058  60ca              STR      r2,[r1,#0xc]          ;2119
00005a  6801              LDR      r1,[r0,#0]            ;2122
00005c  694a              LDR      r2,[r1,#0x14]         ;2122
00005e  f0220201          BIC      r2,r2,#1              ;2122
000062  614a              STR      r2,[r1,#0x14]         ;2122
000064  2101              MOVS     r1,#1                 ;2124
000066  6401              STR      r1,[r0,#0x40]         ;2124
000068  f7fffffe          BL       HAL_USART_RxCpltCallback
00006c  2000              MOVS     r0,#0                 ;2127
00006e  bd10              POP      {r4,pc}
                  |L37.112|
000070  6902              LDR      r2,[r0,#0x10]         ;2079
000072  6ac1              LDR      r1,[r0,#0x2c]         ;2079
000074  2a00              CMP      r2,#0                 ;2079
000076  6802              LDR      r2,[r0,#0]            ;2086
000078  6852              LDR      r2,[r2,#4]            ;2086
00007a  bf14              ITE      NE                    ;2086
00007c  b2d2              UXTBNE   r2,r2                 ;2086
00007e  f3c20208          UBFXEQ   r2,r2,#0,#9           ;2081
000082  800a              STRH     r2,[r1,#0]            ;2081
000084  6ac1              LDR      r1,[r0,#0x2c]         ;2082
000086  bf14              ITE      NE                    ;2082
000088  1c49              ADDNE    r1,r1,#1              ;2082
00008a  1c89              ADDEQ    r1,r1,#2              ;2082
00008c  62c1              STR      r1,[r0,#0x2c]         ;2089
00008e  8e41              LDRH     r1,[r0,#0x32]         ;2089
000090  1e49              SUBS     r1,r1,#1              ;2089
000092  0409              LSLS     r1,r1,#16             ;2089
000094  0c09              LSRS     r1,r1,#16             ;2089
000096  8641              STRH     r1,[r0,#0x32]         ;2089
000098  d0d0              BEQ      |L37.60|
00009a  6802              LDR      r2,[r0,#0]            ;2092
00009c  f24011ff          MOV      r1,#0x1ff             ;2092
0000a0  6051              STR      r1,[r2,#4]            ;2092
0000a2  e7cb              B        |L37.60|
                  |L37.164|
0000a4  684a              LDR      r2,[r1,#4]            ;2099
0000a6  6ac1              LDR      r1,[r0,#0x2c]         ;2099
0000a8  1c4b              ADDS     r3,r1,#1              ;2099
0000aa  62c3              STR      r3,[r0,#0x2c]         ;2099
0000ac  700a              STRB     r2,[r1,#0]            ;2099
0000ae  e7bc              B        |L37.42|
;;;2136   
                          ENDP


                          AREA ||i.USART_TransmitReceive_IT||, CODE, READONLY, ALIGN=1

                  USART_TransmitReceive_IT PROC
;;;2142     */
;;;2143   static HAL_StatusTypeDef USART_TransmitReceive_IT(USART_HandleTypeDef *husart)
000000  b510              PUSH     {r4,lr}
;;;2144   {
;;;2145     uint16_t* tmp;
;;;2146   
;;;2147     if(husart->State == HAL_USART_STATE_BUSY_TX_RX)
000002  6c01              LDR      r1,[r0,#0x40]
000004  2932              CMP      r1,#0x32
;;;2148     {
;;;2149       if(husart->TxXferCount != 0x00U)
;;;2150       {
;;;2151         if(__HAL_USART_GET_FLAG(husart, USART_FLAG_TXE) != RESET)
;;;2152         {
;;;2153           if(husart->Init.WordLength == USART_WORDLENGTH_9B)
;;;2154           {
;;;2155             tmp = (uint16_t*) husart->pTxBuffPtr;
;;;2156             WRITE_REG(husart->Instance->DR, (uint16_t)(*tmp & (uint16_t)0x01FF));
;;;2157             if(husart->Init.Parity == USART_PARITY_NONE)
;;;2158             {
;;;2159               husart->pTxBuffPtr += 2U;
;;;2160             }
;;;2161             else
;;;2162             {
;;;2163               husart->pTxBuffPtr += 1U;
;;;2164             }
;;;2165           }
;;;2166           else
;;;2167           {
;;;2168             WRITE_REG(husart->Instance->DR, (uint8_t)(*husart->pTxBuffPtr++ & (uint8_t)0x00FF));
;;;2169           }
;;;2170           husart->TxXferCount--;
;;;2171   
;;;2172           /* Check the latest data transmitted */
;;;2173           if(husart->TxXferCount == 0U)
;;;2174           {
;;;2175             CLEAR_BIT(husart->Instance->CR1, USART_CR1_TXEIE);
;;;2176           }
;;;2177         }
;;;2178       }
;;;2179   
;;;2180       if(husart->RxXferCount != 0x00U)
;;;2181       {
;;;2182         if(__HAL_USART_GET_FLAG(husart, USART_FLAG_RXNE) != RESET)
;;;2183         {
;;;2184           if(husart->Init.WordLength == USART_WORDLENGTH_9B)
;;;2185           {
;;;2186             tmp = (uint16_t*) husart->pRxBuffPtr;
;;;2187             if(husart->Init.Parity == USART_PARITY_NONE)
;;;2188             {
;;;2189               *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x01FF);
;;;2190               husart->pRxBuffPtr += 2U;
;;;2191             }
;;;2192             else
;;;2193             {
;;;2194               *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x00FF);
;;;2195               husart->pRxBuffPtr += 1U;
;;;2196             }
;;;2197           }
;;;2198           else
;;;2199           {
;;;2200             if(husart->Init.Parity == USART_PARITY_NONE)
;;;2201             {
;;;2202               *husart->pRxBuffPtr++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x00FF);
;;;2203             }
;;;2204             else
;;;2205             {
;;;2206               *husart->pRxBuffPtr++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x007F);
;;;2207             }
;;;2208           }
;;;2209           husart->RxXferCount--;
;;;2210         }
;;;2211       }
;;;2212   
;;;2213       /* Check the latest data received */
;;;2214       if(husart->RxXferCount == 0U)
;;;2215       {
;;;2216         /* Disable the USART RXNE Interrupt */
;;;2217         CLEAR_BIT(husart->Instance->CR1, USART_CR1_RXNEIE);
;;;2218   
;;;2219         /* Disable the USART Parity Error Interrupt */
;;;2220         CLEAR_BIT(husart->Instance->CR1, USART_CR1_PEIE);
;;;2221   
;;;2222         /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;2223         CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;2224   
;;;2225         husart->State = HAL_USART_STATE_READY;
;;;2226   
;;;2227         HAL_USART_TxRxCpltCallback(husart);
;;;2228   
;;;2229         return HAL_OK;
;;;2230       }
;;;2231   
;;;2232       return HAL_OK;
;;;2233     }
;;;2234     else
;;;2235     {
;;;2236       return HAL_BUSY;
000006  bf1c              ITT      NE
000008  2002              MOVNE    r0,#2
;;;2237     }
;;;2238   }
00000a  bd10              POPNE    {r4,pc}
00000c  8d41              LDRH     r1,[r0,#0x2a]         ;2149
00000e  b321              CBZ      r1,|L38.90|
000010  6801              LDR      r1,[r0,#0]            ;2151
000012  680a              LDR      r2,[r1,#0]            ;2151
000014  f0120f80          TST      r2,#0x80              ;2151
000018  d01f              BEQ      |L38.90|
00001a  6882              LDR      r2,[r0,#8]            ;2153
00001c  f5b25f80          CMP      r2,#0x1000            ;2153
000020  6a42              LDR      r2,[r0,#0x24]         ;2153
000022  d009              BEQ      |L38.56|
000024  1c53              ADDS     r3,r2,#1              ;2168
000026  6243              STR      r3,[r0,#0x24]         ;2168
000028  7812              LDRB     r2,[r2,#0]            ;2168
00002a  604a              STR      r2,[r1,#4]            ;2168
                  |L38.44|
00002c  8d41              LDRH     r1,[r0,#0x2a]         ;2170
00002e  1e49              SUBS     r1,r1,#1              ;2170
000030  8541              STRH     r1,[r0,#0x2a]         ;2170
000032  8d41              LDRH     r1,[r0,#0x2a]         ;2173
000034  b989              CBNZ     r1,|L38.90|
000036  e00b              B        |L38.80|
                  |L38.56|
000038  8812              LDRH     r2,[r2,#0]            ;2156
00003a  f3c20208          UBFX     r2,r2,#0,#9           ;2156
00003e  604a              STR      r2,[r1,#4]            ;2156
000040  6901              LDR      r1,[r0,#0x10]         ;2157
000042  2900              CMP      r1,#0                 ;2157
000044  6a41              LDR      r1,[r0,#0x24]         ;2163
000046  bf14              ITE      NE                    ;2163
000048  1c49              ADDNE    r1,r1,#1              ;2163
00004a  1c89              ADDEQ    r1,r1,#2              ;2163
00004c  6241              STR      r1,[r0,#0x24]         ;2157
00004e  e7ed              B        |L38.44|
                  |L38.80|
000050  6801              LDR      r1,[r0,#0]            ;2175
000052  68ca              LDR      r2,[r1,#0xc]          ;2175
000054  f0220280          BIC      r2,r2,#0x80           ;2175
000058  60ca              STR      r2,[r1,#0xc]          ;2175
                  |L38.90|
00005a  8e41              LDRH     r1,[r0,#0x32]         ;2180
00005c  b1a9              CBZ      r1,|L38.138|
00005e  6801              LDR      r1,[r0,#0]            ;2182
000060  680a              LDR      r2,[r1,#0]            ;2182
000062  f0120f20          TST      r2,#0x20              ;2182
000066  d010              BEQ      |L38.138|
000068  6882              LDR      r2,[r0,#8]            ;2184
00006a  f5b25f80          CMP      r2,#0x1000            ;2184
00006e  d026              BEQ      |L38.190|
000070  6902              LDR      r2,[r0,#0x10]         ;2200
000072  2a00              CMP      r2,#0                 ;2200
000074  d032              BEQ      |L38.220|
000076  6849              LDR      r1,[r1,#4]            ;2206
000078  f001027f          AND      r2,r1,#0x7f           ;2206
00007c  6ac1              LDR      r1,[r0,#0x2c]         ;2206
00007e  1c4b              ADDS     r3,r1,#1              ;2206
000080  62c3              STR      r3,[r0,#0x2c]         ;2206
000082  700a              STRB     r2,[r1,#0]            ;2206
                  |L38.132|
000084  8e41              LDRH     r1,[r0,#0x32]         ;2209
000086  1e49              SUBS     r1,r1,#1              ;2209
000088  8641              STRH     r1,[r0,#0x32]         ;2209
                  |L38.138|
00008a  8e41              LDRH     r1,[r0,#0x32]         ;2214
00008c  2900              CMP      r1,#0                 ;2214
00008e  bf1c              ITT      NE                    ;2232
000090  2000              MOVNE    r0,#0                 ;2232
000092  bd10              POPNE    {r4,pc}
000094  6801              LDR      r1,[r0,#0]            ;2217
000096  68ca              LDR      r2,[r1,#0xc]          ;2217
000098  f0220220          BIC      r2,r2,#0x20           ;2217
00009c  60ca              STR      r2,[r1,#0xc]          ;2217
00009e  6801              LDR      r1,[r0,#0]            ;2220
0000a0  68ca              LDR      r2,[r1,#0xc]          ;2220
0000a2  f4227280          BIC      r2,r2,#0x100          ;2220
0000a6  60ca              STR      r2,[r1,#0xc]          ;2220
0000a8  6801              LDR      r1,[r0,#0]            ;2223
0000aa  694a              LDR      r2,[r1,#0x14]         ;2223
0000ac  f0220201          BIC      r2,r2,#1              ;2223
0000b0  614a              STR      r2,[r1,#0x14]         ;2223
0000b2  2101              MOVS     r1,#1                 ;2225
0000b4  6401              STR      r1,[r0,#0x40]         ;2225
0000b6  f7fffffe          BL       HAL_USART_TxRxCpltCallback
0000ba  2000              MOVS     r0,#0                 ;2229
0000bc  bd10              POP      {r4,pc}
                  |L38.190|
0000be  6903              LDR      r3,[r0,#0x10]         ;2187
0000c0  6ac2              LDR      r2,[r0,#0x2c]         ;2187
0000c2  6849              LDR      r1,[r1,#4]            ;2194
0000c4  2b00              CMP      r3,#0                 ;2187
0000c6  bf14              ITE      NE                    ;2194
0000c8  b2c9              UXTBNE   r1,r1                 ;2194
0000ca  f3c10108          UBFXEQ   r1,r1,#0,#9           ;2189
0000ce  8011              STRH     r1,[r2,#0]            ;2189
0000d0  6ac1              LDR      r1,[r0,#0x2c]         ;2190
0000d2  bf14              ITE      NE                    ;2190
0000d4  1c49              ADDNE    r1,r1,#1              ;2190
0000d6  1c89              ADDEQ    r1,r1,#2              ;2190
0000d8  62c1              STR      r1,[r0,#0x2c]         ;2187
0000da  e7d3              B        |L38.132|
                  |L38.220|
0000dc  684a              LDR      r2,[r1,#4]            ;2202
0000de  6ac1              LDR      r1,[r0,#0x2c]         ;2202
0000e0  1c4b              ADDS     r3,r1,#1              ;2202
0000e2  62c3              STR      r3,[r0,#0x2c]         ;2202
0000e4  700a              STRB     r2,[r1,#0]            ;2202
0000e6  e7cd              B        |L38.132|
;;;2239   
                          ENDP


                          AREA ||i.USART_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=2

                  USART_WaitOnFlagUntilTimeout PROC
;;;1850     */
;;;1851   static HAL_StatusTypeDef USART_WaitOnFlagUntilTimeout(USART_HandleTypeDef *husart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1852   {
000004  4604              MOV      r4,r0
;;;1853     /* Wait until flag is set */
;;;1854     while((__HAL_USART_GET_FLAG(husart, Flag) ? SET : RESET) == Status)
000006  6800              LDR      r0,[r0,#0]
000008  9e06              LDR      r6,[sp,#0x18]
00000a  461f              MOV      r7,r3                 ;1852
00000c  6800              LDR      r0,[r0,#0]
00000e  460d              MOV      r5,r1                 ;1852
000010  ea310000          BICS     r0,r1,r0
000014  d029              BEQ      |L39.106|
;;;1855     {
;;;1856       /* Check for the Timeout */
;;;1857       if(Timeout != HAL_MAX_DELAY)
000016  bf00              NOP      
                  |L39.24|
000018  f1b63fff          CMP      r6,#0xffffffff
00001c  d020              BEQ      |L39.96|
;;;1858       {
;;;1859         if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
00001e  b126              CBZ      r6,|L39.42|
000020  f7fffffe          BL       HAL_GetTick
000024  1bc0              SUBS     r0,r0,r7
000026  42b0              CMP      r0,r6
000028  d91a              BLS      |L39.96|
                  |L39.42|
;;;1860         {
;;;1861             /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;1862             __HAL_USART_DISABLE_IT(husart, USART_IT_TXE);
00002a  6820              LDR      r0,[r4,#0]
00002c  68c1              LDR      r1,[r0,#0xc]
00002e  f0210180          BIC      r1,r1,#0x80
000032  60c1              STR      r1,[r0,#0xc]
;;;1863             __HAL_USART_DISABLE_IT(husart, USART_IT_RXNE);
000034  6820              LDR      r0,[r4,#0]
000036  68c1              LDR      r1,[r0,#0xc]
000038  f0210120          BIC      r1,r1,#0x20
00003c  60c1              STR      r1,[r0,#0xc]
;;;1864             __HAL_USART_DISABLE_IT(husart, USART_IT_PE);
00003e  6820              LDR      r0,[r4,#0]
000040  68c1              LDR      r1,[r0,#0xc]
000042  f4217180          BIC      r1,r1,#0x100
000046  60c1              STR      r1,[r0,#0xc]
;;;1865             __HAL_USART_DISABLE_IT(husart, USART_IT_ERR);
000048  6820              LDR      r0,[r4,#0]
00004a  6941              LDR      r1,[r0,#0x14]
00004c  f0210101          BIC      r1,r1,#1
000050  6141              STR      r1,[r0,#0x14]
;;;1866   
;;;1867           husart->State= HAL_USART_STATE_READY;
000052  2001              MOVS     r0,#1
000054  6420              STR      r0,[r4,#0x40]
;;;1868   
;;;1869           /* Process Unlocked */
;;;1870           __HAL_UNLOCK(husart);
000056  2000              MOVS     r0,#0
;;;1871   
;;;1872           return HAL_TIMEOUT;
000058  63e0              STR      r0,[r4,#0x3c]
00005a  2003              MOVS     r0,#3
;;;1873         }
;;;1874       }
;;;1875     }
;;;1876     return HAL_OK;
;;;1877   }
00005c  e8bd81f0          POP      {r4-r8,pc}
                  |L39.96|
000060  6820              LDR      r0,[r4,#0]            ;1872
000062  6800              LDR      r0,[r0,#0]            ;1872
000064  ea350000          BICS     r0,r5,r0              ;1872
000068  d1d6              BNE      |L39.24|
                  |L39.106|
00006a  2000              MOVS     r0,#0                 ;1876
00006c  e8bd81f0          POP      {r4-r8,pc}
;;;1878   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F1_V1.6.0\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f1xx_hal_usart_c_32ae8742____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F1_V1.6.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___21_stm32f1xx_hal_usart_c_32ae8742____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f1xx_hal_usart_c_32ae8742____REVSH|
#line 402
|__asm___21_stm32f1xx_hal_usart_c_32ae8742____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f1xx_hal_usart_c_32ae8742____RRX|
#line 587
|__asm___21_stm32f1xx_hal_usart_c_32ae8742____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
